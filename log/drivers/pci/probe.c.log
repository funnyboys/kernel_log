commit 3925c3bbdf886f1ddf64461b9b380e1bb36f90c1
Merge: 9fa88c5d3f5e 2bd81cd04a3f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jun 6 11:01:58 2020 -0700

    Merge tag 'pci-v5.8-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI updates from Bjorn Helgaas:
     "Enumeration:
    
       - Program MPS for RCiEP devices (Ashok Raj)
    
       - Fix pci_register_host_bridge() device_register() error handling
         (Rob Herring)
    
       - Fix pci_host_bridge struct device release/free handling (Rob
         Herring)
    
      Resource management:
    
       - Allow resizing BARs for devices on root bus (Ard Biesheuvel)
    
      Power management:
    
       - Reduce Thunderbolt resume time by working around devices that don't
         support DLL Link Active reporting (Mika Westerberg)
    
       - Work around a Pericom USB controller OHCI/EHCI PME# defect
         (Kai-Heng Feng)
    
      Virtualization:
    
       - Add ACS quirk for Intel Root Complex Integrated Endpoints (Ashok
         Raj)
    
       - Avoid FLR for AMD Starship USB 3.0 (Kevin Buettner)
    
       - Avoid FLR for AMD Matisse HD Audio & USB 3.0 (Marcos Scriven)
    
      Error handling:
    
       - Use only _OSC (not HEST FIRMWARE_FIRST) to determine AER ownership
         (Alexandru Gagniuc, Kuppuswamy Sathyanarayanan)
    
       - Reduce verbosity by logging only ACPI_NOTIFY_DISCONNECT_RECOVER
         events (Kuppuswamy Sathyanarayanan)
    
       - Don't enable AER by default in Kconfig (Bjorn Helgaas)
    
      Peer-to-peer DMA:
    
       - Add AMD Zen Raven and Renoir Root Ports to whitelist (Alex Deucher)
    
      ASPM:
    
       - Allow ASPM on links to PCIe-to-PCI/PCI-X Bridges (Kai-Heng Feng)
    
      Endpoint framework:
    
       - Fix DMA channel release in test (Kunihiko Hayashi)
    
       - Add page size as argument to pci_epc_mem_init() (Lad Prabhakar)
    
       - Add support to handle multiple base for mapping outbound memory
         (Lad Prabhakar)
    
      Generic host bridge driver:
    
       - Support building as module (Rob Herring)
    
       - Eliminate pci_host_common_probe wrappers (Rob Herring)
    
      Amlogic Meson PCIe controller driver:
    
       - Don't use FAST_LINK_MODE to set up link (Marc Zyngier)
    
      Broadcom STB PCIe controller driver:
    
       - Disable ASPM L0s if 'aspm-no-l0s' in DT (Jim Quinlan)
    
       - Fix clk_put() error (Jim Quinlan)
    
       - Fix window register offset (Jim Quinlan)
    
       - Assert fundamental reset on initialization (Nicolas Saenz Julienne)
    
       - Add notify xHCI reset property (Nicolas Saenz Julienne)
    
       - Add init routine for Raspberry Pi 4 VL805 USB controller (Nicolas
         Saenz Julienne)
    
       - Sync with Raspberry Pi 4 firmware for VL805 initialization (Nicolas
         Saenz Julienne)
    
      Cadence PCIe controller driver:
    
       - Remove "cdns,max-outbound-regions" DT property (replaced by
         "ranges") (Kishon Vijay Abraham I)
    
       - Read 32-bit (not 16-bit) Vendor ID/Device ID property from DT
         (Kishon Vijay Abraham I)
    
      Marvell Aardvark PCIe controller driver:
    
       - Improve link training (Marek Behún)
    
       - Add PHY support (Marek Behún)
    
       - Add "phys", "max-link-speed", "reset-gpios" to dt-binding (Marek
         Behún)
    
       - Train link immediately after enabling training to work around
         detection issues with some cards (Pali Rohár)
    
       - Issue PERST via GPIO to work around detection issues (Pali Rohár)
    
       - Don't blindly enable ASPM L0s (Pali Rohár)
    
       - Replace custom macros by standard linux/pci_regs.h macros (Pali
         Rohár)
    
      Microsoft Hyper-V host bridge driver:
    
       - Fix probe failure path to release resource (Wei Hu)
    
       - Retry PCI bus D0 entry on invalid device state for kdump (Wei Hu)
    
      Renesas R-Car PCIe controller driver:
    
       - Fix incorrect programming of OB windows (Andrew Murray)
    
       - Add suspend/resume (Kazufumi Ikeda)
    
       - Rename pcie-rcar.c to pcie-rcar-host.c (Lad Prabhakar)
    
       - Add endpoint controller driver (Lad Prabhakar)
    
       - Fix PCIEPAMR mask calculation (Lad Prabhakar)
    
       - Add r8a77961 to DT binding (Yoshihiro Shimoda)
    
      Socionext UniPhier Pro5 controller driver:
    
       - Add endpoint controller driver (Kunihiko Hayashi)
    
      Synopsys DesignWare PCIe controller driver:
    
       - Program outbound ATU upper limit register (Alan Mikhak)
    
       - Fix inner MSI IRQ domain registration (Marc Zyngier)
    
      Miscellaneous:
    
       - Check for platform_get_irq() failure consistently (negative return
         means failure) (Aman Sharma)
    
       - Fix several runtime PM get/put imbalances (Dinghao Liu)
    
       - Use flexible-array and struct_size() helpers for code cleanup
         (Gustavo A. R. Silva)
    
       - Update & fix issues in bridge emulation of PCIe registers (Jon
         Derrick)
    
       - Add macros for bridge window names (PCI_BRIDGE_IO_WINDOW, etc)
         (Krzysztof Wilczyński)
    
       - Work around Intel PCH MROMs that have invalid BARs (Xiaochun Lee)"
    
    * tag 'pci-v5.8-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (100 commits)
      PCI: uniphier: Add Socionext UniPhier Pro5 PCIe endpoint controller driver
      PCI: Add ACS quirk for Intel Root Complex Integrated Endpoints
      PCI/DPC: Print IRQ number used by port
      PCI/AER: Use "aer" variable for capability offset
      PCI/AER: Remove redundant dev->aer_cap checks
      PCI/AER: Remove redundant pci_is_pcie() checks
      PCI/AER: Remove HEST/FIRMWARE_FIRST parsing for AER ownership
      PCI: tegra: Fix runtime PM imbalance on error
      PCI: vmd: Filter resource type bits from shadow register
      PCI: tegra194: Fix runtime PM imbalance on error
      dt-bindings: PCI: Add UniPhier PCIe endpoint controller description
      PCI: hv: Use struct_size() helper
      PCI: Rename _DSM constants to align with spec
      PCI: Avoid FLR for AMD Starship USB 3.0
      PCI: Avoid FLR for AMD Matisse HD Audio & USB 3.0
      x86/PCI: Drop unused xen_register_pirq() gsi_override parameter
      PCI: dwc: Use private data pointer of "struct irq_domain" to get pcie_port
      PCI: amlogic: meson: Don't use FAST_LINK_MODE to set up link
      PCI: dwc: Fix inner MSI IRQ domain registration
      PCI: dwc: pci-dra7xx: Use devm_platform_ioremap_resource_byname()
      ...

commit 9f91d05e4aaceb46d9f39da9fa3c9c64643b9154
Merge: 08d6c8fca74c 3910ebaca8ea
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Jun 4 12:59:11 2020 -0500

    Merge branch 'pci/misc'
    
      - Clarify that platform_get_irq() should never return 0 (Bjorn Helgaas)
    
      - Check for platform_get_irq() failure consistently (Bjorn Helgaas)
    
      - Replace zero-length array with flexible-array (Gustavo A. R. Silva)
    
      - Unify pcie_find_root_port() and pci_find_pcie_root_port() (Yicong Yang)
    
      - Quirk Intel C620 MROMs, which have non-BARs in BAR locations (Xiaochun
        Lee)
    
      - Fix pcie_pme_resume() and pcie_pme_remove() kernel-doc (Jay Fang)
    
      - Rename _DSM constants to align with spec (Krzysztof Wilczyński)
    
    * pci/misc:
      PCI: Rename _DSM constants to align with spec
      PCI/PME: Fix kernel-doc of pcie_pme_resume() and pcie_pme_remove()
      x86/PCI: Mark Intel C620 MROMs as having non-compliant BARs
      PCI: Unify pcie_find_root_port() and pci_find_pcie_root_port()
      PCI: Replace zero-length array with flexible-array
      PCI: Check for platform_get_irq() failure consistently
      driver core: platform: Clarify that IRQ 0 is invalid

commit b6caa1d8c80cb71b6162cb1f1ec13aa655026c9f
Author: Jiaxun Yang <jiaxun.yang@flygoat.com>
Date:   Tue May 26 17:21:12 2020 +0800

    PCI: Don't disable decoding when mmio_always_on is set
    
    Don't disable MEM/IO decoding when a device have both non_compliant_bars
    and mmio_always_on.
    
    That would allow us quirk devices with junk in BARs but can't disable
    their decoding.
    
    Signed-off-by: Jiaxun Yang <jiaxun.yang@flygoat.com>
    Acked-by: Bjorn Helgaas <helgaas@kernel.org>
    Signed-off-by: Thomas Bogendoerfer <tsbogend@alpha.franken.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 77b8a145c39b..d9c2c3301a8a 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1822,7 +1822,7 @@ int pci_setup_device(struct pci_dev *dev)
 	/* Device class may be changed after fixup */
 	class = dev->class >> 8;
 
-	if (dev->non_compliant_bars) {
+	if (dev->non_compliant_bars && !dev->mmio_always_on) {
 		pci_read_config_word(dev, PCI_COMMAND, &cmd);
 		if (cmd & (PCI_COMMAND_IO | PCI_COMMAND_MEMORY)) {
 			pci_info(dev, "device has non-compliant BARs; disabling IO/MEM decoding\n");

commit aa0ce96d72dd2e1b0dfd0fb868f82876e7790878
Author: Ashok Raj <ashok.raj@intel.com>
Date:   Fri Mar 27 14:16:15 2020 -0700

    PCI: Program MPS for RCiEP devices
    
    Root Complex Integrated Endpoints (RCiEPs) do not have an upstream bridge,
    so pci_configure_mps() previously ignored them, which may result in reduced
    performance.
    
    Instead, program the Max_Payload_Size of RCiEPs to the maximum supported
    value (unless it is limited for the PCIE_BUS_PEER2PEER case).  This also
    affects the subsequent programming of Max_Read_Request_Size because Linux
    programs MRRS based on the MPS value.
    
    Fixes: 9dae3a97297f ("PCI: Move MPS configuration check to pci_configure_device()")
    Link: https://lore.kernel.org/r/1585343775-4019-1-git-send-email-ashok.raj@intel.com
    Tested-by: Dave Jiang <dave.jiang@intel.com>
    Signed-off-by: Ashok Raj <ashok.raj@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index e064ded6fbec..27c43ff63cd5 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1937,13 +1937,33 @@ static void pci_configure_mps(struct pci_dev *dev)
 	struct pci_dev *bridge = pci_upstream_bridge(dev);
 	int mps, mpss, p_mps, rc;
 
-	if (!pci_is_pcie(dev) || !bridge || !pci_is_pcie(bridge))
+	if (!pci_is_pcie(dev))
 		return;
 
 	/* MPS and MRRS fields are of type 'RsvdP' for VFs, short-circuit out */
 	if (dev->is_virtfn)
 		return;
 
+	/*
+	 * For Root Complex Integrated Endpoints, program the maximum
+	 * supported value unless limited by the PCIE_BUS_PEER2PEER case.
+	 */
+	if (pci_pcie_type(dev) == PCI_EXP_TYPE_RC_END) {
+		if (pcie_bus_config == PCIE_BUS_PEER2PEER)
+			mps = 128;
+		else
+			mps = 128 << dev->pcie_mpss;
+		rc = pcie_set_mps(dev, mps);
+		if (rc) {
+			pci_warn(dev, "can't set Max Payload Size to %d; if necessary, use \"pci=pcie_bus_safe\" and report a bug\n",
+				 mps);
+		}
+		return;
+	}
+
+	if (!bridge || !pci_is_pcie(bridge))
+		return;
+
 	mps = pcie_get_mps(dev);
 	p_mps = pcie_get_mps(bridge);
 

commit 9885440b16b8fc1dd7275800fd28f56a92f60896
Author: Rob Herring <robh@kernel.org>
Date:   Wed May 13 17:38:59 2020 -0500

    PCI: Fix pci_host_bridge struct device release/free handling
    
    The PCI code has several paths where the struct pci_host_bridge is freed
    directly. This is wrong because it contains a struct device which is
    refcounted and should be freed using put_device(). This can result in
    use-after-free errors. I think this problem has existed since 2012 with
    commit 7b5436635800 ("PCI: add generic device into pci_host_bridge
    struct"). It generally hasn't mattered as most host bridge drivers are
    still built-in and can't unbind.
    
    The problem is a struct device should never be freed directly once
    device_initialize() is called and a ref is held, but that doesn't happen
    until pci_register_host_bridge(). There's then a window between allocating
    the host bridge and pci_register_host_bridge() where kfree should be used.
    This is fragile and requires callers to do the right thing. To fix this, we
    need to split device_register() into device_initialize() and device_add()
    calls, so that the host bridge struct is always freed by using a
    put_device().
    
    devm_pci_alloc_host_bridge() is using devm_kzalloc() to allocate struct
    pci_host_bridge which will be freed directly. Instead, we can use a custom
    devres action to call put_device().
    
    Link: https://lore.kernel.org/r/20200513223859.11295-2-robh@kernel.org
    Reported-by: Anders Roxell <anders.roxell@linaro.org>
    Tested-by: Anders Roxell <anders.roxell@linaro.org>
    Signed-off-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index e21dc71b1907..e064ded6fbec 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -565,7 +565,7 @@ static struct pci_bus *pci_alloc_bus(struct pci_bus *parent)
 	return b;
 }
 
-static void devm_pci_release_host_bridge_dev(struct device *dev)
+static void pci_release_host_bridge_dev(struct device *dev)
 {
 	struct pci_host_bridge *bridge = to_pci_host_bridge(dev);
 
@@ -574,12 +574,7 @@ static void devm_pci_release_host_bridge_dev(struct device *dev)
 
 	pci_free_resource_list(&bridge->windows);
 	pci_free_resource_list(&bridge->dma_ranges);
-}
-
-static void pci_release_host_bridge_dev(struct device *dev)
-{
-	devm_pci_release_host_bridge_dev(dev);
-	kfree(to_pci_host_bridge(dev));
+	kfree(bridge);
 }
 
 static void pci_init_host_bridge(struct pci_host_bridge *bridge)
@@ -599,6 +594,8 @@ static void pci_init_host_bridge(struct pci_host_bridge *bridge)
 	bridge->native_pme = 1;
 	bridge->native_ltr = 1;
 	bridge->native_dpc = 1;
+
+	device_initialize(&bridge->dev);
 }
 
 struct pci_host_bridge *pci_alloc_host_bridge(size_t priv)
@@ -616,17 +613,25 @@ struct pci_host_bridge *pci_alloc_host_bridge(size_t priv)
 }
 EXPORT_SYMBOL(pci_alloc_host_bridge);
 
+static void devm_pci_alloc_host_bridge_release(void *data)
+{
+	pci_free_host_bridge(data);
+}
+
 struct pci_host_bridge *devm_pci_alloc_host_bridge(struct device *dev,
 						   size_t priv)
 {
+	int ret;
 	struct pci_host_bridge *bridge;
 
-	bridge = devm_kzalloc(dev, sizeof(*bridge) + priv, GFP_KERNEL);
+	bridge = pci_alloc_host_bridge(priv);
 	if (!bridge)
 		return NULL;
 
-	pci_init_host_bridge(bridge);
-	bridge->dev.release = devm_pci_release_host_bridge_dev;
+	ret = devm_add_action_or_reset(dev, devm_pci_alloc_host_bridge_release,
+				       bridge);
+	if (ret)
+		return NULL;
 
 	return bridge;
 }
@@ -634,10 +639,7 @@ EXPORT_SYMBOL(devm_pci_alloc_host_bridge);
 
 void pci_free_host_bridge(struct pci_host_bridge *bridge)
 {
-	pci_free_resource_list(&bridge->windows);
-	pci_free_resource_list(&bridge->dma_ranges);
-
-	kfree(bridge);
+	put_device(&bridge->dev);
 }
 EXPORT_SYMBOL(pci_free_host_bridge);
 
@@ -908,7 +910,7 @@ static int pci_register_host_bridge(struct pci_host_bridge *bridge)
 	if (err)
 		goto free;
 
-	err = device_register(&bridge->dev);
+	err = device_add(&bridge->dev);
 	if (err) {
 		put_device(&bridge->dev);
 		goto free;
@@ -978,7 +980,7 @@ static int pci_register_host_bridge(struct pci_host_bridge *bridge)
 
 unregister:
 	put_device(&bridge->dev);
-	device_unregister(&bridge->dev);
+	device_del(&bridge->dev);
 
 free:
 	kfree(bus);
@@ -2953,7 +2955,7 @@ struct pci_bus *pci_create_root_bus(struct device *parent, int bus,
 	return bridge->bus;
 
 err_out:
-	kfree(bridge);
+	put_device(&bridge->dev);
 	return NULL;
 }
 EXPORT_SYMBOL_GPL(pci_create_root_bus);

commit 1b54ae8327a4d630111c8d88ba7906483ec6010b
Author: Rob Herring <robh@kernel.org>
Date:   Wed May 13 17:38:58 2020 -0500

    PCI: Fix pci_register_host_bridge() device_register() error handling
    
    If device_register() has an error, we should bail out of
    pci_register_host_bridge() rather than continuing on.
    
    Fixes: 37d6a0a6f470 ("PCI: Add pci_register_host_bridge() interface")
    Link: https://lore.kernel.org/r/20200513223859.11295-1-robh@kernel.org
    Signed-off-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 77b8a145c39b..e21dc71b1907 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -909,9 +909,10 @@ static int pci_register_host_bridge(struct pci_host_bridge *bridge)
 		goto free;
 
 	err = device_register(&bridge->dev);
-	if (err)
+	if (err) {
 		put_device(&bridge->dev);
-
+		goto free;
+	}
 	bus->bridge = get_device(&bridge->dev);
 	device_enable_async_suspend(bus->bridge);
 	pci_set_bus_of_node(bus);

commit 6ae72bfa656ea04806f98ef85cb44b0789064362
Author: Yicong Yang <yangyicong@hisilicon.com>
Date:   Sat May 9 18:19:28 2020 +0800

    PCI: Unify pcie_find_root_port() and pci_find_pcie_root_port()
    
    Previously we used pcie_find_root_port() to find a Root Port from a PCIe
    device and pci_find_pcie_root_port() to find a Root Port from a
    Conventional PCI device.
    
    Unify the two functions and use pcie_find_root_port() to find a Root Port
    from either a Conventional PCI device or a PCIe device.  Then there is no
    need to distinguish the type of the device.
    
    Link: https://lore.kernel.org/r/1589019568-5216-1-git-send-email-yangyicong@hisilicon.com
    Signed-off-by: Yicong Yang <yangyicong@hisilicon.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Kalle Valo <kvalo@codeaurora.org> # wireless
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com> # thunderbolt

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 77b8a145c39b..cdff469ba070 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -2056,7 +2056,7 @@ static void pci_configure_relaxed_ordering(struct pci_dev *dev)
 	 * For now, we only deal with Relaxed Ordering issues with Root
 	 * Ports. Peer-to-Peer DMA is another can of worms.
 	 */
-	root = pci_find_pcie_root_port(dev);
+	root = pcie_find_root_port(dev);
 	if (!root)
 		return;
 

commit eb81b249ba059443916d6cc0cfa3e1987aa938d9
Merge: 4ea40c380dd5 757bfaa2c351
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Apr 2 14:26:32 2020 -0500

    Merge branch 'pci/enumeration'
    
      - Add PCIe 32 GT/s speed decoding for sysfs "max_link_speed" and dmesg
        notes about available bandwidth (Yicong Yang)
    
      - Simplify and unify PCI bus/link speed reporting (Yicong Yang)
    
    * pci/enumeration:
      PCI: Add PCIE_LNKCAP2_SLS2SPEED() macro
      PCI: Use pci_speed_string() for all PCI/PCI-X/PCIe strings
      PCI: Add pci_speed_string()
      PCI: Add 32 GT/s decoding in some macros

commit ac1c8e35a3262d04cc81b07fac6480a3539e3b0f
Author: Kuppuswamy Sathyanarayanan <sathyanarayanan.kuppuswamy@linux.intel.com>
Date:   Mon Mar 23 17:26:07 2020 -0700

    PCI/DPC: Add Error Disconnect Recover (EDR) support
    
    Error Disconnect Recover (EDR) is a feature that allows ACPI firmware to
    notify OSPM that a device has been disconnected due to an error condition
    (ACPI v6.3, sec 5.6.6).  OSPM advertises its support for EDR on PCI devices
    via _OSC (see [1], sec 4.5.1, table 4-4).  The OSPM EDR notify handler
    should invalidate software state associated with disconnected devices and
    may attempt to recover them.  OSPM communicates the status of recovery to
    the firmware via _OST (sec 6.3.5.2).
    
    For PCIe, firmware may use Downstream Port Containment (DPC) to support
    EDR.  Per [1], sec 4.5.1, table 4-6, even if firmware has retained control
    of DPC, OSPM may read/write DPC control and status registers during the EDR
    notification processing window, i.e., from the time it receives an EDR
    notification until it clears the DPC Trigger Status.
    
    Note that per [1], sec 4.5.1 and 4.5.2.4,
    
      1. If the OS supports EDR, it should advertise that to firmware by
         setting OSC_PCI_EDR_SUPPORT in _OSC Support.
    
      2. If the OS sets OSC_PCI_EXPRESS_DPC_CONTROL in _OSC Control to request
         control of the DPC capability, it must also set OSC_PCI_EDR_SUPPORT in
         _OSC Support.
    
    Add an EDR notify handler to attempt recovery.
    
    [1] Downstream Port Containment Related Enhancements ECN, Jan 28, 2019,
        affecting PCI Firmware Specification, Rev. 3.2
        https://members.pcisig.com/wg/PCI-SIG/document/12888
    
    [bhelgaas: squash add/enable patches into one]
    Link: https://lore.kernel.org/r/90f91fe6d25c13f9d2255d2ce97ca15be307e1bb.1585000084.git.sathyanarayanan.kuppuswamy@linux.intel.com
    Signed-off-by: Kuppuswamy Sathyanarayanan <sathyanarayanan.kuppuswamy@linux.intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Len Brown <lenb@kernel.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index c6f91f886818..f67c007edcae 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -598,6 +598,7 @@ static void pci_init_host_bridge(struct pci_host_bridge *bridge)
 	bridge->native_shpc_hotplug = 1;
 	bridge->native_pme = 1;
 	bridge->native_ltr = 1;
+	bridge->native_dpc = 1;
 }
 
 struct pci_host_bridge *pci_alloc_host_bridge(size_t priv)

commit 27005618178ef9e9bf9c42fd91101771c92e9308
Author: Kuppuswamy Sathyanarayanan <sathyanarayanan.kuppuswamy@linux.intel.com>
Date:   Mon Mar 23 17:26:04 2020 -0700

    PCI/DPC: Cache DPC capabilities in pci_init_capabilities()
    
    Since Error Disconnect Recover needs to use DPC error handling routines
    even if the OS doesn't have control of DPC, move the initalization and
    caching of DPC capabilities from the DPC driver to pci_init_capabilities().
    
    Link: https://lore.kernel.org/r/5888380657c8b9551675b5dbd48e370e4fd2703d.1585000084.git.sathyanarayanan.kuppuswamy@linux.intel.com
    Signed-off-by: Kuppuswamy Sathyanarayanan <sathyanarayanan.kuppuswamy@linux.intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 512cb4312ddd..c6f91f886818 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -2329,6 +2329,7 @@ static void pci_init_capabilities(struct pci_dev *dev)
 	pci_enable_acs(dev);		/* Enable ACS P2P upstream forwarding */
 	pci_ptm_init(dev);		/* Precision Time Measurement */
 	pci_aer_init(dev);		/* Advanced Error Reporting */
+	pci_dpc_init(dev);		/* Downstream Port Containment */
 
 	pcie_report_downtraining(dev);
 

commit e56faff57f0b39661093c00e0262d4ab9088830e
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Feb 28 15:02:03 2020 -0600

    PCI: Add pci_speed_string()
    
    Add pci_speed_string() to return a text description of the supplied bus or
    link speed.  The slot code previously used the private
    pci_bus_speed_strings[] array for this purpose, but adding this interface
    will enable us to consolidate similar code elsewhere.
    
    Export pcie_link_speed[] and pci_speed_string() so they can be used by
    modules.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 512cb4312ddd..4fc41b71cc95 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -640,6 +640,7 @@ void pci_free_host_bridge(struct pci_host_bridge *bridge)
 }
 EXPORT_SYMBOL(pci_free_host_bridge);
 
+/* Indexed by PCI_X_SSTATUS_FREQ (secondary bus mode and frequency) */
 static const unsigned char pcix_bus_speed[] = {
 	PCI_SPEED_UNKNOWN,		/* 0 */
 	PCI_SPEED_66MHz_PCIX,		/* 1 */
@@ -659,6 +660,7 @@ static const unsigned char pcix_bus_speed[] = {
 	PCI_SPEED_133MHz_PCIX_533	/* F */
 };
 
+/* Indexed by PCI_EXP_LNKCAP_SLS, PCI_EXP_LNKSTA_CLS */
 const unsigned char pcie_link_speed[] = {
 	PCI_SPEED_UNKNOWN,		/* 0 */
 	PCIE_SPEED_2_5GT,		/* 1 */
@@ -677,6 +679,44 @@ const unsigned char pcie_link_speed[] = {
 	PCI_SPEED_UNKNOWN,		/* E */
 	PCI_SPEED_UNKNOWN		/* F */
 };
+EXPORT_SYMBOL_GPL(pcie_link_speed);
+
+const char *pci_speed_string(enum pci_bus_speed speed)
+{
+	/* Indexed by the pci_bus_speed enum */
+	static const char *speed_strings[] = {
+	    "33 MHz PCI",		/* 0x00 */
+	    "66 MHz PCI",		/* 0x01 */
+	    "66 MHz PCI-X",		/* 0x02 */
+	    "100 MHz PCI-X",		/* 0x03 */
+	    "133 MHz PCI-X",		/* 0x04 */
+	    NULL,			/* 0x05 */
+	    NULL,			/* 0x06 */
+	    NULL,			/* 0x07 */
+	    NULL,			/* 0x08 */
+	    "66 MHz PCI-X 266",		/* 0x09 */
+	    "100 MHz PCI-X 266",	/* 0x0a */
+	    "133 MHz PCI-X 266",	/* 0x0b */
+	    "Unknown AGP",		/* 0x0c */
+	    "1x AGP",			/* 0x0d */
+	    "2x AGP",			/* 0x0e */
+	    "4x AGP",			/* 0x0f */
+	    "8x AGP",			/* 0x10 */
+	    "66 MHz PCI-X 533",		/* 0x11 */
+	    "100 MHz PCI-X 533",	/* 0x12 */
+	    "133 MHz PCI-X 533",	/* 0x13 */
+	    "2.5 GT/s PCIe",		/* 0x14 */
+	    "5.0 GT/s PCIe",		/* 0x15 */
+	    "8.0 GT/s PCIe",		/* 0x16 */
+	    "16.0 GT/s PCIe",		/* 0x17 */
+	    "32.0 GT/s PCIe",		/* 0x18 */
+	};
+
+	if (speed < ARRAY_SIZE(speed_strings))
+		return speed_strings[speed];
+	return "Unknown";
+}
+EXPORT_SYMBOL_GPL(pci_speed_string);
 
 void pcie_update_link_speed(struct pci_bus *bus, u16 linksta)
 {

commit 7e124c40517218e079e580909de2652bddb60ff5
Merge: 48617f03c940 36533f355b1a
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Nov 28 08:54:55 2019 -0600

    Merge branch 'pci/trivial'
    
      - Fix typos and comments (Bjorn Helgaas)
    
      - Fix Kconfig whitespace errors (Krzysztof Kozlowski)
    
    * pci/trivial:
      PCI: Fix indentation
      PCI: Fix typos
      PCI: Remove useless comments and tidy others
      PCI: Remove unnecessary includes
    
    # Conflicts:
    #       drivers/pci/probe.c

commit f52412b151a45d3864833202a4a19729322b4de6
Merge: e771e0bf823f 7cf2cba43f15
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Nov 28 08:54:38 2019 -0600

    Merge branch 'pci/virtualization'
    
      - Fix erroneous intel-iommu dependency on CONFIG_AMD_IOMMU (Bjorn
        Helgaas)
    
      - Move pci_prg_resp_pasid_required() to CONFIG_PCI_PRI (Bjorn Helgaas)
    
      - Allow VFs to use PRI (the PF PRI is shared by the VFs, but the code
        previously didn't recognize that) (Kuppuswamy Sathyanarayanan)
    
      - Allow VFs to use PASID (the PF PASID capability is shared by the VFs,
        but the code previously didn't recognize that) (Kuppuswamy
        Sathyanarayanan)
    
      - Disconnect PF and VF ATS enablement, since ATS in PFs and associated
        VFs can be enabled independently (Kuppuswamy Sathyanarayanan)
    
      - Cache PRI and PASID capability offsets (Kuppuswamy Sathyanarayanan)
    
      - Cache the PRI PRG Response PASID Required bit (Bjorn Helgaas)
    
      - Consolidate ATS declarations in linux/pci-ats.h (Krzysztof Wilczynski)
    
      - Remove unused PRI and PASID stubs (Bjorn Helgaas)
    
      - Removed unnecessary EXPORT_SYMBOL_GPL() from ATS, PRI, and PASID
        interfaces that are only used by built-in IOMMU drivers (Bjorn Helgaas)
    
      - Hide PRI and PASID state restoration functions used only inside the PCI
        core (Bjorn Helgaas)
    
      - Fix the UPDCR register address in the Intel ACS quirk (Steffen
        Liebergeld)
    
      - Add a DMA alias quirk for the Intel VCA NTB (Slawomir Pawlowski)
    
      - Serialize sysfs sriov_numvfs reads vs writes (Pierre Crégut)
    
      - Update Cavium ACS quirk for ThunderX2 and ThunderX3 (George Cherian)
    
      - Unify ACS quirk implementations (Bjorn Helgaas)
    
    * pci/virtualization:
      PCI: Unify ACS quirk desired vs provided checking
      PCI: Make ACS quirk implementations more uniform
      PCI: Apply Cavium ACS quirk to ThunderX2 and ThunderX3
      PCI/IOV: Serialize sysfs sriov_numvfs reads vs writes
      PCI: Add DMA alias quirk for Intel VCA NTB
      PCI: Fix Intel ACS quirk UPDCR register address
      PCI/ATS: Make pci_restore_pri_state(), pci_restore_pasid_state() private
      PCI/ATS: Remove unnecessary EXPORT_SYMBOL_GPL()
      PCI/ATS: Remove unused PRI and PASID stubs
      PCI/ATS: Consolidate ATS declarations in linux/pci-ats.h
      PCI/ATS: Cache PRI PRG Response PASID Required bit
      PCI/ATS: Cache PASID Capability offset
      PCI/ATS: Cache PRI Capability offset
      PCI/ATS: Disable PF/VF ATS service independently
      PCI/ATS: Handle sharing of PF PASID Capability with all VFs
      PCI/ATS: Handle sharing of PF PRI Capability with all VFs
      PCI/ATS: Move pci_prg_resp_pasid_required() to CONFIG_PCI_PRI
      iommu/vt-d: Select PCI_PRI for INTEL_IOMMU_SVM

commit 774800cb099f8ee2f0f5c55ddb1809802d7c7cf8
Merge: 7cfe16393c3c 73884a7082f4
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Nov 28 08:54:36 2019 -0600

    Merge branch 'pci/resource'
    
      - Protect pci_reassign_bridge_resources() against concurrent
        addition/removal (Benjamin Herrenschmidt)
    
      - Fix bridge dma_ranges resource list cleanup (Rob Herring)
    
      - Add PCI_STD_NUM_BARS for the number of standard BARs (Denis Efremov)
    
      - Add "pci=hpmmiosize" and "pci=hpmmioprefsize" parameters to control the
        MMIO and prefetchable MMIO window sizes of hotplug bridges
        independently (Nicholas Johnson)
    
      - Fix MMIO/MMIO_PREF window assignment that assigned more space than
        desired (Nicholas Johnson)
    
      - Only enforce bus numbers from bridge EA if the bridge has EA devices
        downstream (Subbaraya Sundeep)
    
    * pci/resource:
      PCI: Do not use bus number zero from EA capability
      PCI: Avoid double hpmemsize MMIO window assignment
      PCI: Add "pci=hpmmiosize" and "pci=hpmmioprefsize" parameters
      PCI: Add PCI_STD_NUM_BARS for the number of standard BARs
      PCI: Fix missing bridge dma_ranges resource list cleanup
      PCI: Protect pci_reassign_bridge_resources() against concurrent addition/removal

commit e87eb585d31fadb5e9e549a1de4b2da60a79bfc9
Merge: 2df08822a643 3d581b11e34a
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Nov 28 08:54:32 2019 -0600

    Merge branch 'pci/misc'
    
      - Add NumaChip SPDX header (Krzysztof Wilczynski)
    
      - Replace EXTRA_CFLAGS with ccflags-y (Krzysztof Wilczynski)
    
      - Remove unused includes (Krzysztof Wilczynski)
    
      - Avoid AMD FCH XHCI USB PME# from D0 defect that prevents wakeup on USB
        2.0 or 1.1 connect events (Kai-Heng Feng)
    
      - Removed unused sysfs attribute groups (Ben Dooks)
    
      - Remove PTM and ASPM dependencies on PCIEPORTBUS (Bjorn Helgaas)
    
      - Add PCIe Link Control 2 register field definitions to replace magic
        numbers in AMDGPU and Radeon CIK/SI (Bjorn Helgaas)
    
      - Fix incorrect Link Control 2 Transmit Margin usage in AMDGPU and Radeon
        CIK/SI PCIe Gen3 link training (Bjorn Helgaas)
    
      - Use pcie_capability_read_word() instead of pci_read_config_word() in
        AMDGPU and Radeon CIK/SI (Frederick Lawler)
    
    * pci/misc:
      drm/radeon: Prefer pcie_capability_read_word()
      drm/radeon: Replace numbers with PCI_EXP_LNKCTL2 definitions
      drm/radeon: Correct Transmit Margin masks
      drm/amdgpu: Prefer pcie_capability_read_word()
      drm/amdgpu: Replace numbers with PCI_EXP_LNKCTL2 definitions
      drm/amdgpu: Correct Transmit Margin masks
      PCI: Add #defines for Enter Compliance, Transmit Margin
      PCI: Allow building PCIe things without PCIEPORTBUS
      PCI: Remove PCIe Kconfig dependencies on PCI
      PCI/ASPM: Remove dependency on PCIEPORTBUS
      PCI/PTM: Remove dependency on PCIEPORTBUS
      PCI/PTM: Remove spurious "d" from granularity message
      PCI: sysfs: Remove unused attribute groups
      x86/PCI: Avoid AMD FCH XHCI USB PME# from D0 defect
      PCI: Remove unused includes and superfluous struct declaration
      x86/PCI: Replace deprecated EXTRA_CFLAGS with ccflags-y
      x86/PCI: Correct SPDX comment style
      x86/PCI: Add NumaChip SPDX GPL-2.0 to replace COPYING boilerplate

commit bbd8810d399812f2016713565e4d8ff8f1508aa6
Author: Krzysztof Wilczynski <kw@linux.com>
Date:   Tue Sep 3 13:30:59 2019 +0200

    PCI: Remove unused includes and superfluous struct declaration
    
    Remove <linux/pci.h> and <linux/msi.h> from being included directly as part
    of the include/linux/of_pci.h, and remove superfluous declaration of struct
    of_phandle_args.
    
    Move users of include <linux/of_pci.h> to include <linux/pci.h> and
    <linux/msi.h> directly rather than rely on both being included transitively
    through <linux/of_pci.h>.
    
    Link: https://lore.kernel.org/r/20190903113059.2901-1-kw@linux.com
    Signed-off-by: Krzysztof Wilczynski <kw@linux.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 3d5271a7a849..7c5d68b807ef 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -7,6 +7,7 @@
 #include <linux/delay.h>
 #include <linux/init.h>
 #include <linux/pci.h>
+#include <linux/msi.h>
 #include <linux/of_device.h>
 #include <linux/of_pci.h>
 #include <linux/pci_hotplug.h>

commit 73884a7082f466ce6686bb8dd7e6571dd42313b4
Author: Subbaraya Sundeep <sbhatta@marvell.com>
Date:   Mon Nov 4 12:27:44 2019 +0530

    PCI: Do not use bus number zero from EA capability
    
    As per PCIe r5.0, sec 7.8.5.2, fixed bus numbers of a bridge must be zero
    when no function that uses EA is located behind it.  Hence, if EA supplies
    bus numbers of zero, assign bus numbers normally.  A secondary bus can
    never have a bus number of zero, so setting a bridge's Secondary Bus Number
    to zero makes downstream devices unreachable.
    
    [bhelgaas: retain bool return value so "zero is invalid" logic is local]
    Fixes: 2dbce5901179 ("PCI: Assign bus numbers present in EA capability for bridges")
    Link: https://lore.kernel.org/r/1572850664-9861-1-git-send-email-sundeep.lkml@gmail.com
    Signed-off-by: Subbaraya Sundeep <sbhatta@marvell.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: stable@vger.kernel.org      # v5.2+

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index bdbc8490f962..d3033873395d 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1090,14 +1090,15 @@ static unsigned int pci_scan_child_bus_extend(struct pci_bus *bus,
  * @sec: updated with secondary bus number from EA
  * @sub: updated with subordinate bus number from EA
  *
- * If @dev is a bridge with EA capability, update @sec and @sub with
- * fixed bus numbers from the capability and return true.  Otherwise,
- * return false.
+ * If @dev is a bridge with EA capability that specifies valid secondary
+ * and subordinate bus numbers, return true with the bus numbers in @sec
+ * and @sub.  Otherwise return false.
  */
 static bool pci_ea_fixed_busnrs(struct pci_dev *dev, u8 *sec, u8 *sub)
 {
 	int ea, offset;
 	u32 dw;
+	u8 ea_sec, ea_sub;
 
 	if (dev->hdr_type != PCI_HEADER_TYPE_BRIDGE)
 		return false;
@@ -1109,8 +1110,13 @@ static bool pci_ea_fixed_busnrs(struct pci_dev *dev, u8 *sec, u8 *sub)
 
 	offset = ea + PCI_EA_FIRST_ENT;
 	pci_read_config_dword(dev, offset, &dw);
-	*sec =  dw & PCI_EA_SEC_BUS_MASK;
-	*sub = (dw & PCI_EA_SUB_BUS_MASK) >> PCI_EA_SUB_BUS_SHIFT;
+	ea_sec =  dw & PCI_EA_SEC_BUS_MASK;
+	ea_sub = (dw & PCI_EA_SUB_BUS_MASK) >> PCI_EA_SUB_BUS_SHIFT;
+	if (ea_sec  == 0 || ea_sub < ea_sec)
+		return false;
+
+	*sec = ea_sec;
+	*sub = ea_sub;
 	return true;
 }
 

commit ad5086108b9f0361929aa9a79cf959ab5681d249
Author: Yunsheng Lin <linyunsheng@huawei.com>
Date:   Sat Oct 19 14:45:43 2019 +0800

    PCI: Warn if no host bridge NUMA node info
    
    In pci_call_probe(), we try to run driver probe functions on the node where
    the device is attached.  If we don't know which node the device is attached
    to, the driver will likely run on the wrong node.  This will still work,
    but performance will not be as good as it could be.
    
    On NUMA systems, warn if we don't know which node a PCI host bridge is
    attached to.  This is likely an indication that ACPI didn't supply a _PXM
    method or the DT didn't supply a "numa-node-id" property.
    
    [bhelgaas: commit log, check bus node]
    Link: https://lore.kernel.org/r/1571467543-26125-1-git-send-email-linyunsheng@huawei.com
    Signed-off-by: Yunsheng Lin <linyunsheng@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 3d5271a7a849..40259c38d66a 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -897,6 +897,9 @@ static int pci_register_host_bridge(struct pci_host_bridge *bridge)
 	else
 		pr_info("PCI host bridge to bus %s\n", name);
 
+	if (nr_node_ids > 1 && pcibus_to_node(bus) == NUMA_NO_NODE)
+		dev_warn(&bus->dev, "Unknown NUMA node; performance will be reduced\n");
+
 	/* Add initial resources to the bus */
 	resource_list_for_each_entry_safe(window, n, &resources) {
 		list_move_tail(&window->node, &bridge->windows);

commit 9d8b738bb9f8008848b62f58671de3537a6d0734
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Oct 3 16:28:26 2019 -0500

    PCI: Remove useless comments and tidy others
    
    Remove useless comments and tidy others for better readability.  Whitespace
    changes only.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 3d5271a7a849..4afe327df7ae 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -2300,8 +2300,7 @@ void pcie_report_downtraining(struct pci_dev *dev)
 
 static void pci_init_capabilities(struct pci_dev *dev)
 {
-	/* Enhanced Allocation */
-	pci_ea_init(dev);
+	pci_ea_init(dev);		/* Enhanced Allocation */
 
 	/* Setup MSI caps & disable MSI/MSI-X interrupts */
 	pci_msi_setup_pci_dev(dev);
@@ -2309,29 +2308,14 @@ static void pci_init_capabilities(struct pci_dev *dev)
 	/* Buffers for saving PCIe and PCI-X capabilities */
 	pci_allocate_cap_save_buffers(dev);
 
-	/* Power Management */
-	pci_pm_init(dev);
-
-	/* Vital Product Data */
-	pci_vpd_init(dev);
-
-	/* Alternative Routing-ID Forwarding */
-	pci_configure_ari(dev);
-
-	/* Single Root I/O Virtualization */
-	pci_iov_init(dev);
-
-	/* Address Translation Services */
-	pci_ats_init(dev);
-
-	/* Enable ACS P2P upstream forwarding */
-	pci_enable_acs(dev);
-
-	/* Precision Time Measurement */
-	pci_ptm_init(dev);
-
-	/* Advanced Error Reporting */
-	pci_aer_init(dev);
+	pci_pm_init(dev);		/* Power Management */
+	pci_vpd_init(dev);		/* Vital Product Data */
+	pci_configure_ari(dev);		/* Alternative Routing-ID Forwarding */
+	pci_iov_init(dev);		/* Single Root I/O Virtualization */
+	pci_ats_init(dev);		/* Address Translation Services */
+	pci_enable_acs(dev);		/* Enable ACS P2P upstream forwarding */
+	pci_ptm_init(dev);		/* Precision Time Measurement */
+	pci_aer_init(dev);		/* Advanced Error Reporting */
 
 	pcie_report_downtraining(dev);
 
@@ -2403,13 +2387,10 @@ void pci_device_add(struct pci_dev *dev, struct pci_bus *bus)
 	/* Fix up broken headers */
 	pci_fixup_device(pci_fixup_header, dev);
 
-	/* Moved out from quirk header fixup code */
 	pci_reassigndev_resource_alignment(dev);
 
-	/* Clear the state_saved flag */
 	dev->state_saved = false;
 
-	/* Initialize various capabilities */
 	pci_init_capabilities(dev);
 
 	/*

commit 751035b8dc061ae434c3311bac9cd6d0e5e00f94
Author: Kuppuswamy Sathyanarayanan <sathyanarayanan.kuppuswamy@linux.intel.com>
Date:   Thu Sep 5 14:31:46 2019 -0500

    PCI/ATS: Cache PASID Capability offset
    
    Previously each PASID interface searched for the PASID Capability.  Cache
    the capability offset the first time we use it instead of searching each
    time.
    
    [bhelgaas: commit log, reorder patch to later, call pci_pasid_init() from
    pci_init_capabilities()]
    Link: https://lore.kernel.org/r/4957778959fa34eab3e8b3065d1951989c61cb0f.1567029860.git.sathyanarayanan.kuppuswamy@linux.intel.com
    Link: https://lore.kernel.org/r/20190905193146.90250-6-helgaas@kernel.org
    Signed-off-by: Kuppuswamy Sathyanarayanan <sathyanarayanan.kuppuswamy@linux.intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index d145165c799c..df2b77866f3b 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -2327,6 +2327,9 @@ static void pci_init_capabilities(struct pci_dev *dev)
 	/* Page Request Interface */
 	pci_pri_init(dev);
 
+	/* Process Address Space ID */
+	pci_pasid_init(dev);
+
 	/* Enable ACS P2P upstream forwarding */
 	pci_enable_acs(dev);
 

commit c065190bbcd4fb54ce9c5fd34fcad71acf2a0ea4
Author: Kuppuswamy Sathyanarayanan <sathyanarayanan.kuppuswamy@linux.intel.com>
Date:   Thu Sep 5 14:31:45 2019 -0500

    PCI/ATS: Cache PRI Capability offset
    
    Previously each PRI interface searched for the PRI Capability.  Cache the
    capability offset the first time we use it instead of searching each time.
    
    [bhelgaas: commit log, reorder patch to later, call pci_pri_init() from
    pci_init_capabilities()]
    Link: https://lore.kernel.org/r/0c5495d376faf6dbb8eb2165204c474438aaae65.156
    7029860.git.sathyanarayanan.kuppuswamy@linux.intel.com
    Link: https://lore.kernel.org/r/20190905193146.90250-5-helgaas@kernel.org
    Signed-off-by: Kuppuswamy Sathyanarayanan <sathyanarayanan.kuppuswamy@linux.intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 3d5271a7a849..d145165c799c 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -2324,6 +2324,9 @@ static void pci_init_capabilities(struct pci_dev *dev)
 	/* Address Translation Services */
 	pci_ats_init(dev);
 
+	/* Page Request Interface */
+	pci_pri_init(dev);
+
 	/* Enable ACS P2P upstream forwarding */
 	pci_enable_acs(dev);
 

commit 7608158df3ed87a5c938c4a0b91f5b11101a9be1
Author: Rob Herring <robh@kernel.org>
Date:   Mon Oct 7 20:23:25 2019 -0500

    PCI: Fix missing bridge dma_ranges resource list cleanup
    
    Commit e80a91ad302b ("PCI: Add dma_ranges window list") added a
    dma_ranges resource list, but failed to correctly free the list when
    devm_pci_alloc_host_bridge() is used.
    
    Only the iproc host bridge driver is using the dma_ranges list.
    
    Fixes: e80a91ad302b ("PCI: Add dma_ranges window list")
    Link: https://lore.kernel.org/r/20191008012325.25700-1-robh@kernel.org
    Signed-off-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Srinath Mannam <srinath.mannam@broadcom.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 3d5271a7a849..bdbc8490f962 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -572,6 +572,7 @@ static void devm_pci_release_host_bridge_dev(struct device *dev)
 		bridge->release_fn(bridge);
 
 	pci_free_resource_list(&bridge->windows);
+	pci_free_resource_list(&bridge->dma_ranges);
 }
 
 static void pci_release_host_bridge_dev(struct device *dev)

commit 299d14d4c31aff3b37a03894e012edf8421676ee
Merge: e94f8ccde471 c5048a73b477
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Sep 23 19:16:01 2019 -0700

    Merge tag 'pci-v5.4-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI updates from Bjorn Helgaas:
     "Enumeration:
    
       - Consolidate _HPP/_HPX stuff in pci-acpi.c and simplify it
         (Krzysztof Wilczynski)
    
       - Fix incorrect PCIe device types and remove dev->has_secondary_link
         to simplify code that deals with upstream/downstream ports (Mika
         Westerberg)
    
       - After suspend, restore Resizable BAR size bits correctly for 1MB
         BARs (Sumit Saxena)
    
       - Enable PCI_MSI_IRQ_DOMAIN support for RISC-V (Wesley Terpstra)
    
      Virtualization:
    
       - Add ACS quirks for iProc PAXB (Abhinav Ratna), Amazon Annapurna
         Labs (Ali Saidi)
    
       - Move sysfs SR-IOV functions to iov.c (Kelsey Skunberg)
    
       - Remove group write permissions from sysfs sriov_numvfs,
         sriov_drivers_autoprobe (Kelsey Skunberg)
    
      Hotplug:
    
       - Simplify pciehp indicator control (Denis Efremov)
    
      Peer-to-peer DMA:
    
       - Allow P2P DMA between root ports for whitelisted bridges (Logan
         Gunthorpe)
    
       - Whitelist some Intel host bridges for P2P DMA (Logan Gunthorpe)
    
       - DMA map P2P DMA requests that traverse host bridge (Logan
         Gunthorpe)
    
      Amazon Annapurna Labs host bridge driver:
    
       - Add DT binding and controller driver (Jonathan Chocron)
    
      Hyper-V host bridge driver:
    
       - Fix hv_pci_dev->pci_slot use-after-free (Dexuan Cui)
    
       - Fix PCI domain number collisions (Haiyang Zhang)
    
       - Use instance ID bytes 4 & 5 as PCI domain numbers (Haiyang Zhang)
    
       - Fix build errors on non-SYSFS config (Randy Dunlap)
    
      i.MX6 host bridge driver:
    
       - Limit DBI register length (Stefan Agner)
    
      Intel VMD host bridge driver:
    
       - Fix config addressing issues (Jon Derrick)
    
      Layerscape host bridge driver:
    
       - Add bar_fixed_64bit property to endpoint driver (Xiaowei Bao)
    
       - Add CONFIG_PCI_LAYERSCAPE_EP to build EP/RC drivers separately
         (Xiaowei Bao)
    
      Mediatek host bridge driver:
    
       - Add MT7629 controller support (Jianjun Wang)
    
      Mobiveil host bridge driver:
    
       - Fix CPU base address setup (Hou Zhiqiang)
    
       - Make "num-lanes" property optional (Hou Zhiqiang)
    
      Tegra host bridge driver:
    
       - Fix OF node reference leak (Nishka Dasgupta)
    
       - Disable MSI for root ports to work around design problem (Vidya
         Sagar)
    
       - Add Tegra194 DT binding and controller support (Vidya Sagar)
    
       - Add support for sideband pins and slot regulators (Vidya Sagar)
    
       - Add PIPE2UPHY support (Vidya Sagar)
    
      Misc:
    
       - Remove unused pci_block_cfg_access() et al (Kelsey Skunberg)
    
       - Unexport pci_bus_get(), etc (Kelsey Skunberg)
    
       - Hide PM, VC, link speed, ATS, ECRC, PTM constants and interfaces in
         the PCI core (Kelsey Skunberg)
    
       - Clean up sysfs DEVICE_ATTR() usage (Kelsey Skunberg)
    
       - Mark expected switch fall-through (Gustavo A. R. Silva)
    
       - Propagate errors for optional regulators and PHYs (Thierry Reding)
    
       - Fix kernel command line resource_alignment parameter issues (Logan
         Gunthorpe)"
    
    * tag 'pci-v5.4-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (112 commits)
      PCI: Add pci_irq_vector() and other stubs when !CONFIG_PCI
      arm64: tegra: Add PCIe slot supply information in p2972-0000 platform
      arm64: tegra: Add configuration for PCIe C5 sideband signals
      PCI: tegra: Add support to enable slot regulators
      PCI: tegra: Add support to configure sideband pins
      PCI: vmd: Fix shadow offsets to reflect spec changes
      PCI: vmd: Fix config addressing when using bus offsets
      PCI: dwc: Add validation that PCIe core is set to correct mode
      PCI: dwc: al: Add Amazon Annapurna Labs PCIe controller driver
      dt-bindings: PCI: Add Amazon's Annapurna Labs PCIe host bridge binding
      PCI: Add quirk to disable MSI-X support for Amazon's Annapurna Labs Root Port
      PCI/VPD: Prevent VPD access for Amazon's Annapurna Labs Root Port
      PCI: Add ACS quirk for Amazon Annapurna Labs root ports
      PCI: Add Amazon's Annapurna Labs vendor ID
      MAINTAINERS: Add PCI native host/endpoint controllers designated reviewer
      PCI: hv: Use bytes 4 and 5 from instance ID as the PCI domain numbers
      dt-bindings: PCI: tegra: Add PCIe slot supplies regulator entries
      dt-bindings: PCI: tegra: Add sideband pins configuration entries
      PCI: tegra: Add Tegra194 PCIe support
      PCI: Get rid of dev->has_secondary_link flag
      ...

commit ca78410403dd64ac0ee0e3cc8646b38335271bfd
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Thu Aug 22 11:55:53 2019 +0300

    PCI: Get rid of dev->has_secondary_link flag
    
    In some systems, the Device/Port Type in the PCI Express Capabilities
    register incorrectly identifies upstream ports as downstream ports.
    
    d0751b98dfa3 ("PCI: Add dev->has_secondary_link to track downstream PCIe
    links") addressed this by adding pci_dev.has_secondary_link, which is set
    for downstream ports.  But this is confusing because pci_pcie_type()
    sometimes gives the wrong answer, and it's not obvious that we should use
    pci_dev.has_secondary_link instead.
    
    Reduce the confusion by correcting the type of the port itself so that
    pci_pcie_type() returns the actual type regardless of what the Device/Port
    Type register claims it is.  Update the users to call pci_pcie_type() and
    pcie_downstream_port() accordingly, and remove pci_dev.has_secondary_link
    completely.
    
    Link: https://lore.kernel.org/linux-pci/20190703133953.GK128603@google.com/
    Suggested-by: Bjorn Helgaas <bhelgaas@google.com>
    Link: https://lore.kernel.org/r/20190822085553.62697-2-mika.westerberg@linux.intel.com
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index cdf34a3c531a..3bfa57d58402 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1431,26 +1431,38 @@ void set_pcie_port_type(struct pci_dev *pdev)
 	pci_read_config_word(pdev, pos + PCI_EXP_DEVCAP, &reg16);
 	pdev->pcie_mpss = reg16 & PCI_EXP_DEVCAP_PAYLOAD;
 
+	parent = pci_upstream_bridge(pdev);
+	if (!parent)
+		return;
+
 	/*
-	 * A Root Port or a PCI-to-PCIe bridge is always the upstream end
-	 * of a Link.  No PCIe component has two Links.  Two Links are
-	 * connected by a Switch that has a Port on each Link and internal
-	 * logic to connect the two Ports.
+	 * Some systems do not identify their upstream/downstream ports
+	 * correctly so detect impossible configurations here and correct
+	 * the port type accordingly.
 	 */
 	type = pci_pcie_type(pdev);
-	if (type == PCI_EXP_TYPE_ROOT_PORT ||
-	    type == PCI_EXP_TYPE_PCIE_BRIDGE)
-		pdev->has_secondary_link = 1;
-	else if (type == PCI_EXP_TYPE_UPSTREAM ||
-		 type == PCI_EXP_TYPE_DOWNSTREAM) {
-		parent = pci_upstream_bridge(pdev);
-
+	if (type == PCI_EXP_TYPE_DOWNSTREAM) {
 		/*
-		 * Usually there's an upstream device (Root Port or Switch
-		 * Downstream Port), but we can't assume one exists.
+		 * If pdev claims to be downstream port but the parent
+		 * device is also downstream port assume pdev is actually
+		 * upstream port.
 		 */
-		if (parent && !parent->has_secondary_link)
-			pdev->has_secondary_link = 1;
+		if (pcie_downstream_port(parent)) {
+			pci_info(pdev, "claims to be downstream port but is acting as upstream port, correcting type\n");
+			pdev->pcie_flags_reg &= ~PCI_EXP_FLAGS_TYPE;
+			pdev->pcie_flags_reg |= PCI_EXP_TYPE_UPSTREAM;
+		}
+	} else if (type == PCI_EXP_TYPE_UPSTREAM) {
+		/*
+		 * If pdev claims to be upstream port but the parent
+		 * device is also upstream port assume pdev is actually
+		 * downstream port.
+		 */
+		if (pci_pcie_type(parent) == PCI_EXP_TYPE_UPSTREAM) {
+			pci_info(pdev, "claims to be upstream port but is acting as downstream port, correcting type\n");
+			pdev->pcie_flags_reg &= ~PCI_EXP_FLAGS_TYPE;
+			pdev->pcie_flags_reg |= PCI_EXP_TYPE_DOWNSTREAM;
+		}
 	}
 }
 
@@ -2488,12 +2500,8 @@ static int only_one_child(struct pci_bus *bus)
 	 * A PCIe Downstream Port normally leads to a Link with only Device
 	 * 0 on it (PCIe spec r3.1, sec 7.3.1).  As an optimization, scan
 	 * only for Device 0 in that situation.
-	 *
-	 * Checking has_secondary_link is a hack to identify Downstream
-	 * Ports because sometimes Switches are configured such that the
-	 * PCIe Port Type labels are backwards.
 	 */
-	if (bridge && pci_is_pcie(bridge) && bridge->has_secondary_link)
+	if (bridge && pci_is_pcie(bridge) && pcie_downstream_port(bridge))
 		return 1;
 
 	return 0;

commit 4a2dbeddd3d54484d2e9c12965e4f9bfa1a0ee36
Author: Krzysztof Wilczynski <kw@linux.com>
Date:   Tue Aug 27 11:49:51 2019 +0200

    PCI/ACPI: Remove unnecessary struct hotplug_program_ops
    
    Move the ACPI-specific structs hpx_type0, hpx_type1, hpx_type2 and
    hpx_type3 to drivers/pci/pci-acpi.c as they are not used anywhere else.
    Then remove the struct hotplug_program_ops that has been shared between
    drivers/pci/probe.c and drivers/pci/pci-acpi.c from drivers/pci/pci.h as it
    is no longer needed.
    
    The struct hotplug_program_ops was added by 87fcf12e846a ("PCI/ACPI: Remove
    the need for 'struct hotplug_params'") and replaced previously used struct
    hotplug_params enabling the support for the _HPX Type 3 Setting Record that
    was added by f873c51a155a ("PCI/ACPI: Implement _HPX Type 3 Setting
    Record").
    
    The new struct allowed for the static functions such program_hpx_type0(),
    program_hpx_type1(), etc., from the drivers/pci/probe.c to be called from
    the function pci_acpi_program_hp_params() in the drivers/pci/pci-acpi.c.
    
    Previously a programming of _HPX Type 0 was as follows:
    
      drivers/pci/probe.c:
    
        program_hpx_type0()
        ...
        pci_configure_device()
          hp_ops = {
            .program_type0 = program_hpx_type0,
            ...
          }
          pci_acpi_program_hp_params(&hp_ops)
    
      drivers/pci/pci-acpi.c:
    
        pci_acpi_program_hp_params(&hp_ops)
          acpi_run_hpx(hp_ops)
            decode_type0_hpx_record()
              hp_ops->program_type0     # program_hpx_type0() called via hp_ops
    
    After the ACPI-specific functions, structs, enums, etc., have been moved to
    drivers/pci/pci-acpi.c there is no need for the hotplug_program_ops as all
    of the _HPX Type 0, 1, 2 and 3 are directly accessible.
    
    Link: https://lore.kernel.org/r/20190827094951.10613-4-kw@linux.com
    Signed-off-by: Krzysztof Wilczynski <kw@linux.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 5847b557dc9a..cdf34a3c531a 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -2100,13 +2100,6 @@ static void pci_configure_serr(struct pci_dev *dev)
 
 static void pci_configure_device(struct pci_dev *dev)
 {
-	static const struct hotplug_program_ops hp_ops = {
-		.program_type0 = program_hpx_type0,
-		.program_type1 = program_hpx_type1,
-		.program_type2 = program_hpx_type2,
-		.program_type3 = program_hpx_type3,
-	};
-
 	pci_configure_mps(dev);
 	pci_configure_extended_tags(dev, NULL);
 	pci_configure_relaxed_ordering(dev);
@@ -2114,7 +2107,7 @@ static void pci_configure_device(struct pci_dev *dev)
 	pci_configure_eetlp_prefix(dev);
 	pci_configure_serr(dev);
 
-	pci_acpi_program_hp_params(dev, &hp_ops);
+	pci_acpi_program_hp_params(dev);
 }
 
 static void pci_release_capabilities(struct pci_dev *dev)

commit 8c3aac6e1b6146ce771b1cabd78e593136d3e5f2
Author: Krzysztof Wilczynski <kw@linux.com>
Date:   Tue Aug 27 11:49:50 2019 +0200

    PCI/ACPI: Move _HPP & _HPX functions to pci-acpi.c
    
    Move program_hpx_type0(), program_hpx_type1(), etc., and enums
    hpx_type3_dev_type, hpx_type3_fn_type and hpx_type3_cfg_loc to
    drivers/pci/pci-acpi.c as these functions and enums are ACPI-specific.
    
    Move structs hpx_type0, hpx_type1, hpx_type2 and hpx_type3 to
    drivers/pci/pci.h as these are shared between drivers/pci/pci-acpi.c and
    drivers/pci/probe.c.
    
    Link: https://lore.kernel.org/r/20190827094951.10613-3-kw@linux.com
    Signed-off-by: Krzysztof Wilczynski <kw@linux.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 120c70b5003b..5847b557dc9a 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1920,275 +1920,6 @@ static void pci_configure_mps(struct pci_dev *dev)
 		 p_mps, mps, mpss);
 }
 
-static struct hpx_type0 pci_default_type0 = {
-	.revision = 1,
-	.cache_line_size = 8,
-	.latency_timer = 0x40,
-	.enable_serr = 0,
-	.enable_perr = 0,
-};
-
-static void program_hpx_type0(struct pci_dev *dev, struct hpx_type0 *hpx)
-{
-	u16 pci_cmd, pci_bctl;
-
-	if (!hpx)
-		hpx = &pci_default_type0;
-
-	if (hpx->revision > 1) {
-		pci_warn(dev, "PCI settings rev %d not supported; using defaults\n",
-			 hpx->revision);
-		hpx = &pci_default_type0;
-	}
-
-	pci_write_config_byte(dev, PCI_CACHE_LINE_SIZE, hpx->cache_line_size);
-	pci_write_config_byte(dev, PCI_LATENCY_TIMER, hpx->latency_timer);
-	pci_read_config_word(dev, PCI_COMMAND, &pci_cmd);
-	if (hpx->enable_serr)
-		pci_cmd |= PCI_COMMAND_SERR;
-	if (hpx->enable_perr)
-		pci_cmd |= PCI_COMMAND_PARITY;
-	pci_write_config_word(dev, PCI_COMMAND, pci_cmd);
-
-	/* Program bridge control value */
-	if ((dev->class >> 8) == PCI_CLASS_BRIDGE_PCI) {
-		pci_write_config_byte(dev, PCI_SEC_LATENCY_TIMER,
-				      hpx->latency_timer);
-		pci_read_config_word(dev, PCI_BRIDGE_CONTROL, &pci_bctl);
-		if (hpx->enable_perr)
-			pci_bctl |= PCI_BRIDGE_CTL_PARITY;
-		pci_write_config_word(dev, PCI_BRIDGE_CONTROL, pci_bctl);
-	}
-}
-
-static void program_hpx_type1(struct pci_dev *dev, struct hpx_type1 *hpx)
-{
-	int pos;
-
-	if (!hpx)
-		return;
-
-	pos = pci_find_capability(dev, PCI_CAP_ID_PCIX);
-	if (!pos)
-		return;
-
-	pci_warn(dev, "PCI-X settings not supported\n");
-}
-
-static bool pcie_root_rcb_set(struct pci_dev *dev)
-{
-	struct pci_dev *rp = pcie_find_root_port(dev);
-	u16 lnkctl;
-
-	if (!rp)
-		return false;
-
-	pcie_capability_read_word(rp, PCI_EXP_LNKCTL, &lnkctl);
-	if (lnkctl & PCI_EXP_LNKCTL_RCB)
-		return true;
-
-	return false;
-}
-
-static void program_hpx_type2(struct pci_dev *dev, struct hpx_type2 *hpx)
-{
-	int pos;
-	u32 reg32;
-
-	if (!hpx)
-		return;
-
-	if (!pci_is_pcie(dev))
-		return;
-
-	if (hpx->revision > 1) {
-		pci_warn(dev, "PCIe settings rev %d not supported\n",
-			 hpx->revision);
-		return;
-	}
-
-	/*
-	 * Don't allow _HPX to change MPS or MRRS settings.  We manage
-	 * those to make sure they're consistent with the rest of the
-	 * platform.
-	 */
-	hpx->pci_exp_devctl_and |= PCI_EXP_DEVCTL_PAYLOAD |
-				    PCI_EXP_DEVCTL_READRQ;
-	hpx->pci_exp_devctl_or &= ~(PCI_EXP_DEVCTL_PAYLOAD |
-				    PCI_EXP_DEVCTL_READRQ);
-
-	/* Initialize Device Control Register */
-	pcie_capability_clear_and_set_word(dev, PCI_EXP_DEVCTL,
-			~hpx->pci_exp_devctl_and, hpx->pci_exp_devctl_or);
-
-	/* Initialize Link Control Register */
-	if (pcie_cap_has_lnkctl(dev)) {
-
-		/*
-		 * If the Root Port supports Read Completion Boundary of
-		 * 128, set RCB to 128.  Otherwise, clear it.
-		 */
-		hpx->pci_exp_lnkctl_and |= PCI_EXP_LNKCTL_RCB;
-		hpx->pci_exp_lnkctl_or &= ~PCI_EXP_LNKCTL_RCB;
-		if (pcie_root_rcb_set(dev))
-			hpx->pci_exp_lnkctl_or |= PCI_EXP_LNKCTL_RCB;
-
-		pcie_capability_clear_and_set_word(dev, PCI_EXP_LNKCTL,
-			~hpx->pci_exp_lnkctl_and, hpx->pci_exp_lnkctl_or);
-	}
-
-	/* Find Advanced Error Reporting Enhanced Capability */
-	pos = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ERR);
-	if (!pos)
-		return;
-
-	/* Initialize Uncorrectable Error Mask Register */
-	pci_read_config_dword(dev, pos + PCI_ERR_UNCOR_MASK, &reg32);
-	reg32 = (reg32 & hpx->unc_err_mask_and) | hpx->unc_err_mask_or;
-	pci_write_config_dword(dev, pos + PCI_ERR_UNCOR_MASK, reg32);
-
-	/* Initialize Uncorrectable Error Severity Register */
-	pci_read_config_dword(dev, pos + PCI_ERR_UNCOR_SEVER, &reg32);
-	reg32 = (reg32 & hpx->unc_err_sever_and) | hpx->unc_err_sever_or;
-	pci_write_config_dword(dev, pos + PCI_ERR_UNCOR_SEVER, reg32);
-
-	/* Initialize Correctable Error Mask Register */
-	pci_read_config_dword(dev, pos + PCI_ERR_COR_MASK, &reg32);
-	reg32 = (reg32 & hpx->cor_err_mask_and) | hpx->cor_err_mask_or;
-	pci_write_config_dword(dev, pos + PCI_ERR_COR_MASK, reg32);
-
-	/* Initialize Advanced Error Capabilities and Control Register */
-	pci_read_config_dword(dev, pos + PCI_ERR_CAP, &reg32);
-	reg32 = (reg32 & hpx->adv_err_cap_and) | hpx->adv_err_cap_or;
-
-	/* Don't enable ECRC generation or checking if unsupported */
-	if (!(reg32 & PCI_ERR_CAP_ECRC_GENC))
-		reg32 &= ~PCI_ERR_CAP_ECRC_GENE;
-	if (!(reg32 & PCI_ERR_CAP_ECRC_CHKC))
-		reg32 &= ~PCI_ERR_CAP_ECRC_CHKE;
-	pci_write_config_dword(dev, pos + PCI_ERR_CAP, reg32);
-
-	/*
-	 * FIXME: The following two registers are not supported yet.
-	 *
-	 *   o Secondary Uncorrectable Error Severity Register
-	 *   o Secondary Uncorrectable Error Mask Register
-	 */
-}
-
-static u16 hpx3_device_type(struct pci_dev *dev)
-{
-	u16 pcie_type = pci_pcie_type(dev);
-	const int pcie_to_hpx3_type[] = {
-		[PCI_EXP_TYPE_ENDPOINT]    = HPX_TYPE_ENDPOINT,
-		[PCI_EXP_TYPE_LEG_END]     = HPX_TYPE_LEG_END,
-		[PCI_EXP_TYPE_RC_END]      = HPX_TYPE_RC_END,
-		[PCI_EXP_TYPE_RC_EC]       = HPX_TYPE_RC_EC,
-		[PCI_EXP_TYPE_ROOT_PORT]   = HPX_TYPE_ROOT_PORT,
-		[PCI_EXP_TYPE_UPSTREAM]    = HPX_TYPE_UPSTREAM,
-		[PCI_EXP_TYPE_DOWNSTREAM]  = HPX_TYPE_DOWNSTREAM,
-		[PCI_EXP_TYPE_PCI_BRIDGE]  = HPX_TYPE_PCI_BRIDGE,
-		[PCI_EXP_TYPE_PCIE_BRIDGE] = HPX_TYPE_PCIE_BRIDGE,
-	};
-
-	if (pcie_type >= ARRAY_SIZE(pcie_to_hpx3_type))
-		return 0;
-
-	return pcie_to_hpx3_type[pcie_type];
-}
-
-static u8 hpx3_function_type(struct pci_dev *dev)
-{
-	if (dev->is_virtfn)
-		return HPX_FN_SRIOV_VIRT;
-	else if (pci_find_ext_capability(dev, PCI_EXT_CAP_ID_SRIOV) > 0)
-		return HPX_FN_SRIOV_PHYS;
-	else
-		return HPX_FN_NORMAL;
-}
-
-static bool hpx3_cap_ver_matches(u8 pcie_cap_id, u8 hpx3_cap_id)
-{
-	u8 cap_ver = hpx3_cap_id & 0xf;
-
-	if ((hpx3_cap_id & BIT(4)) && cap_ver >= pcie_cap_id)
-		return true;
-	else if (cap_ver == pcie_cap_id)
-		return true;
-
-	return false;
-}
-
-static void program_hpx_type3_register(struct pci_dev *dev,
-				       const struct hpx_type3 *reg)
-{
-	u32 match_reg, write_reg, header, orig_value;
-	u16 pos;
-
-	if (!(hpx3_device_type(dev) & reg->device_type))
-		return;
-
-	if (!(hpx3_function_type(dev) & reg->function_type))
-		return;
-
-	switch (reg->config_space_location) {
-	case HPX_CFG_PCICFG:
-		pos = 0;
-		break;
-	case HPX_CFG_PCIE_CAP:
-		pos = pci_find_capability(dev, reg->pci_exp_cap_id);
-		if (pos == 0)
-			return;
-
-		break;
-	case HPX_CFG_PCIE_CAP_EXT:
-		pos = pci_find_ext_capability(dev, reg->pci_exp_cap_id);
-		if (pos == 0)
-			return;
-
-		pci_read_config_dword(dev, pos, &header);
-		if (!hpx3_cap_ver_matches(PCI_EXT_CAP_VER(header),
-					  reg->pci_exp_cap_ver))
-			return;
-
-		break;
-	case HPX_CFG_VEND_CAP:	/* Fall through */
-	case HPX_CFG_DVSEC:	/* Fall through */
-	default:
-		pci_warn(dev, "Encountered _HPX type 3 with unsupported config space location");
-		return;
-	}
-
-	pci_read_config_dword(dev, pos + reg->match_offset, &match_reg);
-
-	if ((match_reg & reg->match_mask_and) != reg->match_value)
-		return;
-
-	pci_read_config_dword(dev, pos + reg->reg_offset, &write_reg);
-	orig_value = write_reg;
-	write_reg &= reg->reg_mask_and;
-	write_reg |= reg->reg_mask_or;
-
-	if (orig_value == write_reg)
-		return;
-
-	pci_write_config_dword(dev, pos + reg->reg_offset, write_reg);
-
-	pci_dbg(dev, "Applied _HPX3 at [0x%x]: 0x%08x -> 0x%08x",
-		pos, orig_value, write_reg);
-}
-
-static void program_hpx_type3(struct pci_dev *dev, struct hpx_type3 *hpx)
-{
-	if (!hpx)
-		return;
-
-	if (!pci_is_pcie(dev))
-		return;
-
-	program_hpx_type3_register(dev, hpx);
-}
-
 int pci_configure_extended_tags(struct pci_dev *dev, void *ign)
 {
 	struct pci_host_bridge *host;

commit e2797ad31fb40f4ff59ebc4314d6f000d713bad9
Author: Krzysztof Wilczynski <kw@linux.com>
Date:   Tue Aug 27 11:49:49 2019 +0200

    PCI/ACPI: Rename _HPX structs from hpp_* to hpx_*
    
    The names of the hpp_type0, hpp_type1 and hpp_type2 structs suggest that
    they're related to _HPP, when in fact they're related to _HPX.
    
    The struct hpp_type0 denotes an _HPX Type 0 setting record that supersedes
    the _HPP setting record, and it has been used interchangeably for _HPP as
    per the ACPI specification (see version 6.3, section 6.2.9.1) which states
    that it should be applied to PCI, PCI-X and PCI Express devices, with
    settings being ignored if they are not applicable.
    
    Rename them to hpx_type0, hpx_type1 and hpx_type2 to reflect their relation
    to _HPX rather than _HPP.
    
    Link: https://lore.kernel.org/r/20190827094951.10613-2-kw@linux.com
    Signed-off-by: Krzysztof Wilczynski <kw@linux.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index a3c7338fad86..120c70b5003b 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1920,7 +1920,7 @@ static void pci_configure_mps(struct pci_dev *dev)
 		 p_mps, mps, mpss);
 }
 
-static struct hpp_type0 pci_default_type0 = {
+static struct hpx_type0 pci_default_type0 = {
 	.revision = 1,
 	.cache_line_size = 8,
 	.latency_timer = 0x40,
@@ -1928,44 +1928,44 @@ static struct hpp_type0 pci_default_type0 = {
 	.enable_perr = 0,
 };
 
-static void program_hpp_type0(struct pci_dev *dev, struct hpp_type0 *hpp)
+static void program_hpx_type0(struct pci_dev *dev, struct hpx_type0 *hpx)
 {
 	u16 pci_cmd, pci_bctl;
 
-	if (!hpp)
-		hpp = &pci_default_type0;
+	if (!hpx)
+		hpx = &pci_default_type0;
 
-	if (hpp->revision > 1) {
+	if (hpx->revision > 1) {
 		pci_warn(dev, "PCI settings rev %d not supported; using defaults\n",
-			 hpp->revision);
-		hpp = &pci_default_type0;
+			 hpx->revision);
+		hpx = &pci_default_type0;
 	}
 
-	pci_write_config_byte(dev, PCI_CACHE_LINE_SIZE, hpp->cache_line_size);
-	pci_write_config_byte(dev, PCI_LATENCY_TIMER, hpp->latency_timer);
+	pci_write_config_byte(dev, PCI_CACHE_LINE_SIZE, hpx->cache_line_size);
+	pci_write_config_byte(dev, PCI_LATENCY_TIMER, hpx->latency_timer);
 	pci_read_config_word(dev, PCI_COMMAND, &pci_cmd);
-	if (hpp->enable_serr)
+	if (hpx->enable_serr)
 		pci_cmd |= PCI_COMMAND_SERR;
-	if (hpp->enable_perr)
+	if (hpx->enable_perr)
 		pci_cmd |= PCI_COMMAND_PARITY;
 	pci_write_config_word(dev, PCI_COMMAND, pci_cmd);
 
 	/* Program bridge control value */
 	if ((dev->class >> 8) == PCI_CLASS_BRIDGE_PCI) {
 		pci_write_config_byte(dev, PCI_SEC_LATENCY_TIMER,
-				      hpp->latency_timer);
+				      hpx->latency_timer);
 		pci_read_config_word(dev, PCI_BRIDGE_CONTROL, &pci_bctl);
-		if (hpp->enable_perr)
+		if (hpx->enable_perr)
 			pci_bctl |= PCI_BRIDGE_CTL_PARITY;
 		pci_write_config_word(dev, PCI_BRIDGE_CONTROL, pci_bctl);
 	}
 }
 
-static void program_hpp_type1(struct pci_dev *dev, struct hpp_type1 *hpp)
+static void program_hpx_type1(struct pci_dev *dev, struct hpx_type1 *hpx)
 {
 	int pos;
 
-	if (!hpp)
+	if (!hpx)
 		return;
 
 	pos = pci_find_capability(dev, PCI_CAP_ID_PCIX);
@@ -1990,20 +1990,20 @@ static bool pcie_root_rcb_set(struct pci_dev *dev)
 	return false;
 }
 
-static void program_hpp_type2(struct pci_dev *dev, struct hpp_type2 *hpp)
+static void program_hpx_type2(struct pci_dev *dev, struct hpx_type2 *hpx)
 {
 	int pos;
 	u32 reg32;
 
-	if (!hpp)
+	if (!hpx)
 		return;
 
 	if (!pci_is_pcie(dev))
 		return;
 
-	if (hpp->revision > 1) {
+	if (hpx->revision > 1) {
 		pci_warn(dev, "PCIe settings rev %d not supported\n",
-			 hpp->revision);
+			 hpx->revision);
 		return;
 	}
 
@@ -2012,14 +2012,14 @@ static void program_hpp_type2(struct pci_dev *dev, struct hpp_type2 *hpp)
 	 * those to make sure they're consistent with the rest of the
 	 * platform.
 	 */
-	hpp->pci_exp_devctl_and |= PCI_EXP_DEVCTL_PAYLOAD |
+	hpx->pci_exp_devctl_and |= PCI_EXP_DEVCTL_PAYLOAD |
 				    PCI_EXP_DEVCTL_READRQ;
-	hpp->pci_exp_devctl_or &= ~(PCI_EXP_DEVCTL_PAYLOAD |
+	hpx->pci_exp_devctl_or &= ~(PCI_EXP_DEVCTL_PAYLOAD |
 				    PCI_EXP_DEVCTL_READRQ);
 
 	/* Initialize Device Control Register */
 	pcie_capability_clear_and_set_word(dev, PCI_EXP_DEVCTL,
-			~hpp->pci_exp_devctl_and, hpp->pci_exp_devctl_or);
+			~hpx->pci_exp_devctl_and, hpx->pci_exp_devctl_or);
 
 	/* Initialize Link Control Register */
 	if (pcie_cap_has_lnkctl(dev)) {
@@ -2028,13 +2028,13 @@ static void program_hpp_type2(struct pci_dev *dev, struct hpp_type2 *hpp)
 		 * If the Root Port supports Read Completion Boundary of
 		 * 128, set RCB to 128.  Otherwise, clear it.
 		 */
-		hpp->pci_exp_lnkctl_and |= PCI_EXP_LNKCTL_RCB;
-		hpp->pci_exp_lnkctl_or &= ~PCI_EXP_LNKCTL_RCB;
+		hpx->pci_exp_lnkctl_and |= PCI_EXP_LNKCTL_RCB;
+		hpx->pci_exp_lnkctl_or &= ~PCI_EXP_LNKCTL_RCB;
 		if (pcie_root_rcb_set(dev))
-			hpp->pci_exp_lnkctl_or |= PCI_EXP_LNKCTL_RCB;
+			hpx->pci_exp_lnkctl_or |= PCI_EXP_LNKCTL_RCB;
 
 		pcie_capability_clear_and_set_word(dev, PCI_EXP_LNKCTL,
-			~hpp->pci_exp_lnkctl_and, hpp->pci_exp_lnkctl_or);
+			~hpx->pci_exp_lnkctl_and, hpx->pci_exp_lnkctl_or);
 	}
 
 	/* Find Advanced Error Reporting Enhanced Capability */
@@ -2044,22 +2044,22 @@ static void program_hpp_type2(struct pci_dev *dev, struct hpp_type2 *hpp)
 
 	/* Initialize Uncorrectable Error Mask Register */
 	pci_read_config_dword(dev, pos + PCI_ERR_UNCOR_MASK, &reg32);
-	reg32 = (reg32 & hpp->unc_err_mask_and) | hpp->unc_err_mask_or;
+	reg32 = (reg32 & hpx->unc_err_mask_and) | hpx->unc_err_mask_or;
 	pci_write_config_dword(dev, pos + PCI_ERR_UNCOR_MASK, reg32);
 
 	/* Initialize Uncorrectable Error Severity Register */
 	pci_read_config_dword(dev, pos + PCI_ERR_UNCOR_SEVER, &reg32);
-	reg32 = (reg32 & hpp->unc_err_sever_and) | hpp->unc_err_sever_or;
+	reg32 = (reg32 & hpx->unc_err_sever_and) | hpx->unc_err_sever_or;
 	pci_write_config_dword(dev, pos + PCI_ERR_UNCOR_SEVER, reg32);
 
 	/* Initialize Correctable Error Mask Register */
 	pci_read_config_dword(dev, pos + PCI_ERR_COR_MASK, &reg32);
-	reg32 = (reg32 & hpp->cor_err_mask_and) | hpp->cor_err_mask_or;
+	reg32 = (reg32 & hpx->cor_err_mask_and) | hpx->cor_err_mask_or;
 	pci_write_config_dword(dev, pos + PCI_ERR_COR_MASK, reg32);
 
 	/* Initialize Advanced Error Capabilities and Control Register */
 	pci_read_config_dword(dev, pos + PCI_ERR_CAP, &reg32);
-	reg32 = (reg32 & hpp->adv_err_cap_and) | hpp->adv_err_cap_or;
+	reg32 = (reg32 & hpx->adv_err_cap_and) | hpx->adv_err_cap_or;
 
 	/* Don't enable ECRC generation or checking if unsupported */
 	if (!(reg32 & PCI_ERR_CAP_ECRC_GENC))
@@ -2178,15 +2178,15 @@ static void program_hpx_type3_register(struct pci_dev *dev,
 		pos, orig_value, write_reg);
 }
 
-static void program_hpx_type3(struct pci_dev *dev, struct hpx_type3 *hpx3)
+static void program_hpx_type3(struct pci_dev *dev, struct hpx_type3 *hpx)
 {
-	if (!hpx3)
+	if (!hpx)
 		return;
 
 	if (!pci_is_pcie(dev))
 		return;
 
-	program_hpx_type3_register(dev, hpx3);
+	program_hpx_type3_register(dev, hpx);
 }
 
 int pci_configure_extended_tags(struct pci_dev *dev, void *ign)
@@ -2370,9 +2370,9 @@ static void pci_configure_serr(struct pci_dev *dev)
 static void pci_configure_device(struct pci_dev *dev)
 {
 	static const struct hotplug_program_ops hp_ops = {
-		.program_type0 = program_hpp_type0,
-		.program_type1 = program_hpp_type1,
-		.program_type2 = program_hpp_type2,
+		.program_type0 = program_hpx_type0,
+		.program_type1 = program_hpx_type1,
+		.program_type2 = program_hpx_type2,
 		.program_type3 = program_hpx_type3,
 	};
 

commit 6bf85ba9e55f659ddc0747bf1bb504ec6d15f525
Author: Suzuki K Poulose <suzuki.poulose@arm.com>
Date:   Tue Jul 23 23:18:37 2019 +0100

    drivers: Add generic helper to match any device
    
    Add a generic helper to match any/all devices. Using this
    introduce new wrappers {bus/driver/class}_find_next_device().
    
    Cc: Elie Morisse <syniurge@gmail.com>
    Cc: "James E.J. Bottomley" <jejb@linux.ibm.com>
    Cc: "Martin K. Petersen" <martin.petersen@oracle.com>
    Cc: Nehal Shah <nehal-bakulchandra.shah@amd.com>
    Cc: "Rafael J. Wysocki" <rafael.j.wysocki@intel.com>
    Cc: Shyam Sundar S K <shyam-sundar.s-k@amd.com>
    Signed-off-by: Suzuki K Poulose <suzuki.poulose@arm.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com> # PCI
    Link: https://lore.kernel.org/r/20190723221838.12024-7-suzuki.poulose@arm.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index a3c7338fad86..dbeeb385fb9f 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -64,11 +64,6 @@ static struct resource *get_pci_domain_busn_res(int domain_nr)
 	return &r->res;
 }
 
-static int find_anything(struct device *dev, const void *data)
-{
-	return 1;
-}
-
 /*
  * Some device drivers need know if PCI is initiated.
  * Basically, we think PCI is not initiated when there
@@ -79,7 +74,7 @@ int no_pci_devices(void)
 	struct device *dev;
 	int no_devices;
 
-	dev = bus_find_device(&pci_bus_type, NULL, NULL, find_anything);
+	dev = bus_find_next_device(&pci_bus_type, NULL);
 	no_devices = (dev == NULL);
 	put_device(dev);
 	return no_devices;

commit fb4da215ed92f564f7ca090bb81a199b0d6cab8a
Merge: 2a3c389a0fde 7b4b0f6b34d8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jul 15 20:44:49 2019 -0700

    Merge tag 'pci-v5.3-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI updates from Bjorn Helgaas:
     "Enumeration changes:
    
       - Evaluate PCI Boot Configuration _DSM to learn if firmware wants us
         to preserve its resource assignments (Benjamin Herrenschmidt)
    
       - Simplify resource distribution (Nicholas Johnson)
    
       - Decode 32 GT/s link speed (Gustavo Pimentel)
    
      Virtualization:
    
       - Fix incorrect caching of VF config space size (Alex Williamson)
    
       - Fix VF driver probing sysfs knobs (Alex Williamson)
    
      Peer-to-peer DMA:
    
       - Fix dma_virt_ops check (Logan Gunthorpe)
    
      Altera host bridge driver:
    
       - Allow building as module (Ley Foon Tan)
    
      Armada 8K host bridge driver:
    
       - add PHYs support (Miquel Raynal)
    
      DesignWare host bridge driver:
    
       - Export APIs to support removable loadable module (Vidya Sagar)
    
       - Enable Relaxed Ordering erratum workaround only on Tegra20 &
         Tegra30 (Vidya Sagar)
    
      Hyper-V host bridge driver:
    
       - Fix use-after-free in eject (Dexuan Cui)
    
      Mobiveil host bridge driver:
    
       - Clean up and fix many issues, including non-identify mapped
         windows, 64-bit windows, multi-MSI, class code, INTx clearing (Hou
         Zhiqiang)
    
      Qualcomm host bridge driver:
    
       - Use clk bulk API for 2.4.0 controllers (Bjorn Andersson)
    
       - Add QCS404 support (Bjorn Andersson)
    
       - Assert PERST for at least 100ms (Niklas Cassel)
    
      R-Car host bridge driver:
    
       - Add r8a774a1 DT support (Biju Das)
    
      Tegra host bridge driver:
    
       - Add support for Gen2, opportunistic UpdateFC and ACK (PCIe protocol
         details) AER, GPIO-based PERST# (Manikanta Maddireddy)
    
       - Fix many issues, including power-on failure cases, interrupt
         masking in suspend, UPHY settings, AFI dynamic clock gating,
         pending DLL transactions (Manikanta Maddireddy)
    
      Xilinx host bridge driver:
    
       - Fix NWL Multi-MSI programming (Bharat Kumar Gogada)
    
      Endpoint support:
    
       - Fix 64bit BAR support (Alan Mikhak)
    
       - Fix pcitest build issues (Alan Mikhak, Andy Shevchenko)
    
      Bug fixes:
    
       - Fix NVIDIA GPU multi-function power dependencies (Abhishek Sahu)
    
       - Fix NVIDIA GPU HDA enablement issue (Lukas Wunner)
    
       - Ignore lockdep for sysfs "remove" (Marek Vasut)
    
      Misc:
    
       - Convert docs to reST (Changbin Du, Mauro Carvalho Chehab)"
    
    * tag 'pci-v5.3-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (107 commits)
      PCI: Enable NVIDIA HDA controllers
      tools: PCI: Fix installation when `make tools/pci_install`
      PCI: dwc: pci-dra7xx: Fix compilation when !CONFIG_GPIOLIB
      PCI: Fix typos and whitespace errors
      PCI: mobiveil: Fix INTx interrupt clearing in mobiveil_pcie_isr()
      PCI: mobiveil: Fix infinite-loop in the INTx handling function
      PCI: mobiveil: Move PCIe PIO enablement out of inbound window routine
      PCI: mobiveil: Add upper 32-bit PCI base address setup in inbound window
      PCI: mobiveil: Add upper 32-bit CPU base address setup in outbound window
      PCI: mobiveil: Mask out hardcoded bits in inbound/outbound windows setup
      PCI: mobiveil: Clear the control fields before updating it
      PCI: mobiveil: Add configured inbound windows counter
      PCI: mobiveil: Fix the valid check for inbound and outbound windows
      PCI: mobiveil: Clean-up program_{ib/ob}_windows()
      PCI: mobiveil: Remove an unnecessary return value check
      PCI: mobiveil: Fix error return values
      PCI: mobiveil: Refactor the MEM/IO outbound window initialization
      PCI: mobiveil: Make some register updates more readable
      PCI: mobiveil: Reformat the code for readability
      dt-bindings: PCI: mobiveil: Change gpio_slave and apb_csr to optional
      ...

commit 55ab3ecb81d5c071287a17567f7573f16934a9e9
Merge: 8c6af6f04252 06013b647c70
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Jul 12 17:08:29 2019 -0500

    Merge branch 'pci/virtualization'
    
      - Fix problem with caching VF config space size (Alex Williamson)
    
    * pci/virtualization:
      PCI/IOV: Assume SR-IOV VFs support extended config space.
      Revert "PCI/IOV: Use VF0 cached config space size for other VFs"

commit 06013b647c708e4f3179b7b0cf3adf28cb8cbfcf
Author: Alex Williamson <alex.williamson@redhat.com>
Date:   Thu Jun 13 16:57:20 2019 -0600

    PCI/IOV: Assume SR-IOV VFs support extended config space.
    
    The SR-IOV specification requires both PFs and VFs to implement a PCIe
    capability.  Generally this is sufficient to assume extended config space
    is present, but we generally also perform additional tests to make sure the
    extended config space is reachable and not simply an alias of standard
    config space.  For a VF to exist extended config space must be accessible
    on the PF, therefore we can also assume it to be accessible on the VF.
    This enables a micro performance optimization previously implemented in
    commit 975bb8b4dc93 ("PCI/IOV: Use VF0 cached config space size for other
    VFs") to speed up probing of VFs.
    
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Kuppuswamy Sathyanarayanan <sathyanarayanan.kuppuswamy@linux.intel.com>
    Cc: KarimAllah Ahmed <karahmed@amazon.de>
    Cc: Hao Zheng <yinhe@linux.alibaba.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index a3a3c6b28343..439244ff8f09 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1561,6 +1561,21 @@ int pci_cfg_space_size(struct pci_dev *dev)
 	u32 status;
 	u16 class;
 
+#ifdef CONFIG_PCI_IOV
+	/*
+	 * Per the SR-IOV specification (rev 1.1, sec 3.5), VFs are required to
+	 * implement a PCIe capability and therefore must implement extended
+	 * config space.  We can skip the NO_EXTCFG test below and the
+	 * reachability/aliasing test in pci_cfg_space_size_ext() by virtue of
+	 * the fact that the SR-IOV capability on the PF resides in extended
+	 * config space and must be accessible and non-aliased to have enabled
+	 * support for this VF.  This is a micro performance optimization for
+	 * systems supporting many VFs.
+	 */
+	if (dev->is_virtfn)
+		return PCI_CFG_SPACE_EXP_SIZE;
+#endif
+
 	if (dev->bus->bus_flags & PCI_BUS_FLAGS_NO_EXTCFG)
 		return PCI_CFG_SPACE_SIZE;
 

commit 76bf6a8634a1ac04d3075993c31a6d94a7f75580
Author: Alex Williamson <alex.williamson@redhat.com>
Date:   Thu Jun 13 16:57:12 2019 -0600

    Revert "PCI/IOV: Use VF0 cached config space size for other VFs"
    
    Revert 975bb8b4dc93 ("PCI/IOV: Use VF0 cached config space size for other
    VFs"), which attempted to cache the config space size from the first VF to
    re-use for subsequent VFs.
    
    The cached value was determined prior to discovering the PCIe capability on
    the VF, which resulted in the first VF reporting the correct config space
    size (4K), as it has a special case through pci_cfg_space_size(), while all
    the other VFs only reported 256 bytes.  As this was only a performance
    optimization, we're better off without it.
    
    Fixes: 975bb8b4dc93 ("PCI/IOV: Use VF0 cached config space size for other VFs")
    Link: https://lore.kernel.org/r/156046663197.29869.3633634445109057665.stgit@gimli.home
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: KarimAllah Ahmed <karahmed@amazon.de>
    Cc: Kuppuswamy Sathyanarayanan <sathyanarayanan.kuppuswamy@linux.intel.com>
    Cc: Hao Zheng <yinhe@linux.alibaba.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 0e8e2c186f50..a3a3c6b28343 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1555,29 +1555,12 @@ static int pci_cfg_space_size_ext(struct pci_dev *dev)
 	return PCI_CFG_SPACE_EXP_SIZE;
 }
 
-#ifdef CONFIG_PCI_IOV
-static bool is_vf0(struct pci_dev *dev)
-{
-	if (pci_iov_virtfn_devfn(dev->physfn, 0) == dev->devfn &&
-	    pci_iov_virtfn_bus(dev->physfn, 0) == dev->bus->number)
-		return true;
-
-	return false;
-}
-#endif
-
 int pci_cfg_space_size(struct pci_dev *dev)
 {
 	int pos;
 	u32 status;
 	u16 class;
 
-#ifdef CONFIG_PCI_IOV
-	/* Read cached value for all VFs except for VF0 */
-	if (dev->is_virtfn && !is_vf0(dev))
-		return dev->physfn->sriov->cfg_size;
-#endif
-
 	if (dev->bus->bus_flags & PCI_BUS_FLAGS_NO_EXTCFG)
 		return PCI_CFG_SPACE_SIZE;
 

commit 418e3ea157efb0eb2c6dd412a8d5f052477c7f5a
Author: Suzuki K Poulose <suzuki.poulose@arm.com>
Date:   Fri Jun 14 18:53:59 2019 +0100

    bus_find_device: Unify the match callback with class_find_device
    
    There is an arbitrary difference between the prototypes of
    bus_find_device() and class_find_device() preventing their callers
    from passing the same pair of data and match() arguments to both of
    them, which is the const qualifier used in the prototype of
    class_find_device().  If that qualifier is also used in the
    bus_find_device() prototype, it will be possible to pass the same
    match() callback function to both bus_find_device() and
    class_find_device(), which will allow some optimizations to be made in
    order to avoid code duplication going forward.  Also with that, constify
    the "data" parameter as it is passed as a const to the match function.
    
    For this reason, change the prototype of bus_find_device() to match
    the prototype of class_find_device() and adjust its callers to use the
    const qualifier in accordance with the new prototype of it.
    
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Andrew Lunn <andrew@lunn.ch>
    Cc: Andreas Noever <andreas.noever@gmail.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Corey Minyard <minyard@acm.org>
    Cc: Christian Borntraeger <borntraeger@de.ibm.com>
    Cc: David Kershner <david.kershner@unisys.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Felipe Balbi <balbi@kernel.org>
    Cc: Frank Rowand <frowand.list@gmail.com>
    Cc: Grygorii Strashko <grygorii.strashko@ti.com>
    Cc: Harald Freudenberger <freude@linux.ibm.com>
    Cc: Hartmut Knaack <knaack.h@gmx.de>
    Cc: Heiko Stuebner <heiko@sntech.de>
    Cc: Jason Gunthorpe <jgg@ziepe.ca>
    Cc: Jonathan Cameron <jic23@kernel.org>
    Cc: "James E.J. Bottomley" <jejb@linux.ibm.com>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Mark Brown <broonie@kernel.org>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michael Jamet <michael.jamet@intel.com>
    Cc: "Martin K. Petersen" <martin.petersen@oracle.com>
    Cc: Peter Oberparleiter <oberpar@linux.ibm.com>
    Cc: Sebastian Ott <sebott@linux.ibm.com>
    Cc: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
    Cc: Yehezkel Bernat <YehezkelShB@gmail.com>
    Cc: rafael@kernel.org
    Acked-by: Corey Minyard <minyard@acm.org>
    Acked-by: David Kershner <david.kershner@unisys.com>
    Acked-by: Mark Brown <broonie@kernel.org>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
    Acked-by: Wolfram Sang <wsa@the-dreams.de> # for the I2C parts
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Suzuki K Poulose <suzuki.poulose@arm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 0e8e2c186f50..f9ef7ad3f75d 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -64,7 +64,7 @@ static struct resource *get_pci_domain_busn_res(int domain_nr)
 	return &r->res;
 }
 
-static int find_anything(struct device *dev, void *data)
+static int find_anything(struct device *dev, const void *data)
 {
 	return 1;
 }

commit de76cda215d56256ffcda7ffa538b70f9fb301a7
Author: Gustavo Pimentel <Gustavo.Pimentel@synopsys.com>
Date:   Tue Jun 4 18:24:43 2019 +0200

    PCI: Decode PCIe 32 GT/s link speed
    
    PCIe r5.0, sec 7.5.3.18, defines a new 32.0 GT/s bit in the Supported Link
    Speeds Vector of Link Capabilities 2.  Decode this new speed.  This does
    not affect the speed of the link, which should be negotiated automatically
    by the hardware; it only adds decoding when showing the speed to the user.
    
    Previously, reading the speed of a link operating at this speed showed
    "Unknown speed" instead of "32.0 GT/s".
    
    Link: https://lore.kernel.org/lkml/92365e3caf0fc559f9ab14bcd053bfc92d4f661c.1559664969.git.gustavo.pimentel@synopsys.com
    Signed-off-by: Gustavo Pimentel <gustavo.pimentel@synopsys.com>
    [bhelgaas: changelog]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 0e8e2c186f50..c5f27c8cd140 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -668,7 +668,7 @@ const unsigned char pcie_link_speed[] = {
 	PCIE_SPEED_5_0GT,		/* 2 */
 	PCIE_SPEED_8_0GT,		/* 3 */
 	PCIE_SPEED_16_0GT,		/* 4 */
-	PCI_SPEED_UNKNOWN,		/* 5 */
+	PCIE_SPEED_32_0GT,		/* 5 */
 	PCI_SPEED_UNKNOWN,		/* 6 */
 	PCI_SPEED_UNKNOWN,		/* 7 */
 	PCI_SPEED_UNKNOWN,		/* 8 */

commit 414147d99b928c574ed76e9374a5d2cb77866a29
Merge: 318222a35bfb c7a1c2bbb65e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue May 14 10:30:10 2019 -0700

    Merge tag 'pci-v5.2-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI updates from Bjorn Helgaas:
     "Enumeration changes:
    
       - Add _HPX Type 3 settings support, which gives firmware more
         influence over device configuration (Alexandru Gagniuc)
    
       - Support fixed bus numbers from bridge Enhanced Allocation
         capabilities (Subbaraya Sundeep)
    
       - Add "external-facing" DT property to identify cases where we
         require IOMMU protection against untrusted devices (Jean-Philippe
         Brucker)
    
       - Enable PCIe services for host controller drivers that use managed
         host bridge alloc (Jean-Philippe Brucker)
    
       - Log PCIe port service messages with pci_dev, not the pcie_device
         (Frederick Lawler)
    
       - Convert pciehp from pciehp_debug module parameter to generic
         dynamic debug (Frederick Lawler)
    
      Peer-to-peer DMA:
    
       - Add whitelist of Root Complexes that support peer-to-peer DMA
         between Root Ports (Christian König)
    
      Native controller drivers:
    
       - Add PCI host bridge DMA ranges for bridges that can't DMA
         everywhere, e.g., iProc (Srinath Mannam)
    
       - Add Amazon Annapurna Labs PCIe host controller driver (Jonathan
         Chocron)
    
       - Fix Tegra MSI target allocation so DMA doesn't generate unwanted
         MSIs (Vidya Sagar)
    
       - Fix of_node reference leaks (Wen Yang)
    
       - Fix Hyper-V module unload & device removal issues (Dexuan Cui)
    
       - Cleanup R-Car driver (Marek Vasut)
    
       - Cleanup Keystone driver (Kishon Vijay Abraham I)
    
       - Cleanup i.MX6 driver (Andrey Smirnov)
    
      Significant bug fixes:
    
       - Reset Lenovo ThinkPad P50 GPU so nouveau works after reboot (Lyude
         Paul)
    
       - Fix Switchtec firmware update performance issue (Wesley Sheng)
    
       - Work around Pericom switch link retraining erratum (Stefan Mätje)"
    
    * tag 'pci-v5.2-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (141 commits)
      MAINTAINERS: Add Karthikeyan Mitran and Hou Zhiqiang for Mobiveil PCI
      PCI: pciehp: Remove pointless MY_NAME definition
      PCI: pciehp: Remove pointless PCIE_MODULE_NAME definition
      PCI: pciehp: Remove unused dbg/err/info/warn() wrappers
      PCI: pciehp: Log messages with pci_dev, not pcie_device
      PCI: pciehp: Replace pciehp_debug module param with dyndbg
      PCI: pciehp: Remove pciehp_debug uses
      PCI/AER: Log messages with pci_dev, not pcie_device
      PCI/DPC: Log messages with pci_dev, not pcie_device
      PCI/PME: Replace dev_printk(KERN_DEBUG) with dev_info()
      PCI/AER: Replace dev_printk(KERN_DEBUG) with dev_info()
      PCI: Replace dev_printk(KERN_DEBUG) with dev_info(), etc
      PCI: Replace printk(KERN_INFO) with pr_info(), etc
      PCI: Use dev_printk() when possible
      PCI: Cleanup setup-bus.c comments and whitespace
      PCI: imx6: Allow asynchronous probing
      PCI: dwc: Save root bus for driver remove hooks
      PCI: dwc: Use devm_pci_alloc_host_bridge() to simplify code
      PCI: dwc: Free MSI in dw_pcie_host_init() error path
      PCI: dwc: Free MSI IRQ page in dw_pcie_free_msi()
      ...

commit 192415f4986028db53fb76ebcefecf0d73cb900a
Merge: f2e946831625 34c6b7105e5a
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon May 13 18:34:46 2019 -0500

    Merge branch 'pci/printk'
    
    * pci/printk:
      PCI: Replace dev_printk(KERN_DEBUG) with dev_info(), etc
      PCI: Replace printk(KERN_INFO) with pr_info(), etc
      PCI: Use dev_printk() when possible

commit f2e94683162565ff02d8d7386fadee175ab55e40
Merge: ee6df38da848 90199c951bd2
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon May 13 18:34:45 2019 -0500

    Merge branch 'pci/iova-dma-ranges'
    
      - Add list of legal DMA address ranges to PCI host bridge (Srinath
        Mannam)
    
      - Reserve inaccessible DMA ranges so IOMMU doesn't allocate them (Srinath
        Mannam)
    
      - Parse iProc DT dma-ranges to learn what PCI devices can reach via DMA
        (Srinath Mannam)
    
    * pci/iova-dma-ranges:
      PCI: iproc: Add sorted dma ranges resource entries to host bridge
      iommu/dma: Reserve IOVA for PCIe inaccessible DMA address
      PCI: Add dma_ranges window list
    
    # Conflicts:
    #       drivers/pci/probe.c

commit 3ea6f739dca4370f89d8c171b4b0433046256798
Merge: 178901bf6a7d ba11edc65065
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon May 13 18:34:31 2019 -0500

    Merge branch 'pci/hotplug'
    
      - Fix RPA and RPA DLPAR refcount issues (Tyrel Datwyler)
    
      - Stop exporting pci_get_hp_params() (Alexandru Gagniuc)
    
      - Simplify _HPP, _HPX parsing (Alexandru Gagniuc)
    
      - Add support for _HPX Type 3 settings (Alexandru Gagniuc)
    
      - Tell firmware we support _HPX Type 3 via _OSC (Alexandru Gagniuc)
    
    * pci/hotplug:
      PCI/ACPI: Advertise _HPX Type 3 support via _OSC
      PCI/ACPI: Implement _HPX Type 3 Setting Record
      PCI/ACPI: Remove the need for 'struct hotplug_params'
      PCI/ACPI: Do not export pci_get_hp_params()
      PCI: rpaphp: Get/put device node reference during slot alloc/dealloc
      PCI: rpadlpar: Fix leaked device_node references in add/remove paths

commit 34c6b7105e5a11174f856483cde8ad6e61b7236a
Author: Mohan Kumar <mohankumar718@gmail.com>
Date:   Sat Apr 20 07:07:20 2019 +0300

    PCI: Replace dev_printk(KERN_DEBUG) with dev_info(), etc
    
    Replace dev_printk(KERN_DEBUG) with dev_info(), etc to be more consistent
    with other logging and avoid checkpatch warnings.
    
    The KERN_DEBUG messages could be converted to dev_dbg(), but that depends
    on CONFIG_DYNAMIC_DEBUG and DEBUG, and we want most of these messages to
    *always* be in the dmesg log.
    
    Link: https://lore.kernel.org/lkml/1555733240-19875-1-git-send-email-mohankumar718@gmail.com
    Signed-off-by: Mohan Kumar <mohankumar718@gmail.com>
    [bhelgaas: commit log]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 2ec0df04e0dc..ac89f4d7a22a 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -317,7 +317,7 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 	res->flags = 0;
 out:
 	if (res->flags)
-		pci_printk(KERN_DEBUG, dev, "reg 0x%x: %pR\n", pos, res);
+		pci_info(dev, "reg 0x%x: %pR\n", pos, res);
 
 	return (res->flags & IORESOURCE_MEM_64) ? 1 : 0;
 }
@@ -435,7 +435,7 @@ static void pci_read_bridge_io(struct pci_bus *child)
 		region.start = base;
 		region.end = limit + io_granularity - 1;
 		pcibios_bus_to_resource(dev->bus, res, &region);
-		pci_printk(KERN_DEBUG, dev, "  bridge window %pR\n", res);
+		pci_info(dev, "  bridge window %pR\n", res);
 	}
 }
 
@@ -457,7 +457,7 @@ static void pci_read_bridge_mmio(struct pci_bus *child)
 		region.start = base;
 		region.end = limit + 0xfffff;
 		pcibios_bus_to_resource(dev->bus, res, &region);
-		pci_printk(KERN_DEBUG, dev, "  bridge window %pR\n", res);
+		pci_info(dev, "  bridge window %pR\n", res);
 	}
 }
 
@@ -510,7 +510,7 @@ static void pci_read_bridge_mmio_pref(struct pci_bus *child)
 		region.start = base;
 		region.end = limit + 0xfffff;
 		pcibios_bus_to_resource(dev->bus, res, &region);
-		pci_printk(KERN_DEBUG, dev, "  bridge window %pR\n", res);
+		pci_info(dev, "  bridge window %pR\n", res);
 	}
 }
 
@@ -540,8 +540,7 @@ void pci_read_bridge_bases(struct pci_bus *child)
 			if (res && res->flags) {
 				pci_bus_add_resource(child, res,
 						     PCI_SUBTRACTIVE_DECODE);
-				pci_printk(KERN_DEBUG, dev,
-					   "  bridge window %pR (subtractive decode)\n",
+				pci_info(dev, "  bridge window %pR (subtractive decode)\n",
 					   res);
 			}
 		}
@@ -1690,7 +1689,7 @@ int pci_setup_device(struct pci_dev *dev)
 	dev->revision = class & 0xff;
 	dev->class = class >> 8;		    /* upper 3 bytes */
 
-	pci_printk(KERN_DEBUG, dev, "[%04x:%04x] type %02x class %#08x\n",
+	pci_info(dev, "[%04x:%04x] type %02x class %#08x\n",
 		   dev->vendor, dev->device, dev->hdr_type, dev->class);
 
 	if (pci_early_dump)
@@ -3086,7 +3085,7 @@ int pci_bus_insert_busn_res(struct pci_bus *b, int bus, int bus_max)
 	conflict = request_resource_conflict(parent_res, res);
 
 	if (conflict)
-		dev_printk(KERN_DEBUG, &b->dev,
+		dev_info(&b->dev,
 			   "busn_res: can not insert %pR under %s%pR (conflicts with %s %pR)\n",
 			    res, pci_is_root_bus(b) ? "domain " : "",
 			    parent_res, conflict->name, conflict);
@@ -3106,8 +3105,7 @@ int pci_bus_update_busn_res_end(struct pci_bus *b, int bus_max)
 
 	size = bus_max - res->start + 1;
 	ret = adjust_resource(res, res->start, size);
-	dev_printk(KERN_DEBUG, &b->dev,
-			"busn_res: %pR end %s updated to %02x\n",
+	dev_info(&b->dev, "busn_res: %pR end %s updated to %02x\n",
 			&old_res, ret ? "can not be" : "is", bus_max);
 
 	if (!ret && !res->parent)
@@ -3125,8 +3123,7 @@ void pci_bus_release_busn_res(struct pci_bus *b)
 		return;
 
 	ret = release_resource(res);
-	dev_printk(KERN_DEBUG, &b->dev,
-			"busn_res: %pR %s released\n",
+	dev_info(&b->dev, "busn_res: %pR %s released\n",
 			res, ret ? "can not be" : "is");
 }
 

commit e80a91ad302b3b66822756afc61f9f9c1658b9c9
Author: Srinath Mannam <srinath.mannam@broadcom.com>
Date:   Fri May 3 19:35:32 2019 +0530

    PCI: Add dma_ranges window list
    
    Add a dma_ranges field in PCI host bridge structure to hold resource
    entries list of memory regions in sorted order representing memory ranges
    that can be accessed through DMA transactions.
    
    Based-on-a-patch-by: Oza Pawandeep <oza.oza@broadcom.com>
    Signed-off-by: Srinath Mannam <srinath.mannam@broadcom.com>
    [lorenzo.pieralisi@arm.com: updated commit log]
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Oza Pawandeep <poza@codeaurora.org>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 2ec0df04e0dc..2a651089a606 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -595,6 +595,7 @@ struct pci_host_bridge *pci_alloc_host_bridge(size_t priv)
 		return NULL;
 
 	INIT_LIST_HEAD(&bridge->windows);
+	INIT_LIST_HEAD(&bridge->dma_ranges);
 	bridge->dev.release = pci_release_host_bridge_dev;
 
 	/*
@@ -623,6 +624,7 @@ struct pci_host_bridge *devm_pci_alloc_host_bridge(struct device *dev,
 		return NULL;
 
 	INIT_LIST_HEAD(&bridge->windows);
+	INIT_LIST_HEAD(&bridge->dma_ranges);
 	bridge->dev.release = devm_pci_release_host_bridge_dev;
 
 	return bridge;
@@ -632,6 +634,7 @@ EXPORT_SYMBOL(devm_pci_alloc_host_bridge);
 void pci_free_host_bridge(struct pci_host_bridge *bridge)
 {
 	pci_free_resource_list(&bridge->windows);
+	pci_free_resource_list(&bridge->dma_ranges);
 
 	kfree(bridge);
 }

commit f873c51a155aaa6dafdc00fa7fda3754f2f9f794
Author: Alexandru Gagniuc <mr.nuke.me@gmail.com>
Date:   Fri Feb 8 10:24:13 2019 -0600

    PCI/ACPI: Implement _HPX Type 3 Setting Record
    
    The _HPX Type 3 Setting Record is intended to be more generic and allow
    configuration of settings not possible with Type 2 records.  For example,
    firmware could ensure that the completion timeout value is set accordingly
    throughout the PCI tree.
    
    Implement support for _HPX Type 3 Setting Records, which were added in the
    ACPI 6.3 spec.
    
    Link: https://lore.kernel.org/lkml/20190208162414.3996-4-mr.nuke.me@gmail.com
    Signed-off-by: Alexandru Gagniuc <mr.nuke.me@gmail.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index dce5ae39d0d8..ea6c1762d5c8 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -2026,6 +2026,119 @@ static void program_hpp_type2(struct pci_dev *dev, struct hpp_type2 *hpp)
 	 */
 }
 
+static u16 hpx3_device_type(struct pci_dev *dev)
+{
+	u16 pcie_type = pci_pcie_type(dev);
+	const int pcie_to_hpx3_type[] = {
+		[PCI_EXP_TYPE_ENDPOINT]    = HPX_TYPE_ENDPOINT,
+		[PCI_EXP_TYPE_LEG_END]     = HPX_TYPE_LEG_END,
+		[PCI_EXP_TYPE_RC_END]      = HPX_TYPE_RC_END,
+		[PCI_EXP_TYPE_RC_EC]       = HPX_TYPE_RC_EC,
+		[PCI_EXP_TYPE_ROOT_PORT]   = HPX_TYPE_ROOT_PORT,
+		[PCI_EXP_TYPE_UPSTREAM]    = HPX_TYPE_UPSTREAM,
+		[PCI_EXP_TYPE_DOWNSTREAM]  = HPX_TYPE_DOWNSTREAM,
+		[PCI_EXP_TYPE_PCI_BRIDGE]  = HPX_TYPE_PCI_BRIDGE,
+		[PCI_EXP_TYPE_PCIE_BRIDGE] = HPX_TYPE_PCIE_BRIDGE,
+	};
+
+	if (pcie_type >= ARRAY_SIZE(pcie_to_hpx3_type))
+		return 0;
+
+	return pcie_to_hpx3_type[pcie_type];
+}
+
+static u8 hpx3_function_type(struct pci_dev *dev)
+{
+	if (dev->is_virtfn)
+		return HPX_FN_SRIOV_VIRT;
+	else if (pci_find_ext_capability(dev, PCI_EXT_CAP_ID_SRIOV) > 0)
+		return HPX_FN_SRIOV_PHYS;
+	else
+		return HPX_FN_NORMAL;
+}
+
+static bool hpx3_cap_ver_matches(u8 pcie_cap_id, u8 hpx3_cap_id)
+{
+	u8 cap_ver = hpx3_cap_id & 0xf;
+
+	if ((hpx3_cap_id & BIT(4)) && cap_ver >= pcie_cap_id)
+		return true;
+	else if (cap_ver == pcie_cap_id)
+		return true;
+
+	return false;
+}
+
+static void program_hpx_type3_register(struct pci_dev *dev,
+				       const struct hpx_type3 *reg)
+{
+	u32 match_reg, write_reg, header, orig_value;
+	u16 pos;
+
+	if (!(hpx3_device_type(dev) & reg->device_type))
+		return;
+
+	if (!(hpx3_function_type(dev) & reg->function_type))
+		return;
+
+	switch (reg->config_space_location) {
+	case HPX_CFG_PCICFG:
+		pos = 0;
+		break;
+	case HPX_CFG_PCIE_CAP:
+		pos = pci_find_capability(dev, reg->pci_exp_cap_id);
+		if (pos == 0)
+			return;
+
+		break;
+	case HPX_CFG_PCIE_CAP_EXT:
+		pos = pci_find_ext_capability(dev, reg->pci_exp_cap_id);
+		if (pos == 0)
+			return;
+
+		pci_read_config_dword(dev, pos, &header);
+		if (!hpx3_cap_ver_matches(PCI_EXT_CAP_VER(header),
+					  reg->pci_exp_cap_ver))
+			return;
+
+		break;
+	case HPX_CFG_VEND_CAP:	/* Fall through */
+	case HPX_CFG_DVSEC:	/* Fall through */
+	default:
+		pci_warn(dev, "Encountered _HPX type 3 with unsupported config space location");
+		return;
+	}
+
+	pci_read_config_dword(dev, pos + reg->match_offset, &match_reg);
+
+	if ((match_reg & reg->match_mask_and) != reg->match_value)
+		return;
+
+	pci_read_config_dword(dev, pos + reg->reg_offset, &write_reg);
+	orig_value = write_reg;
+	write_reg &= reg->reg_mask_and;
+	write_reg |= reg->reg_mask_or;
+
+	if (orig_value == write_reg)
+		return;
+
+	pci_write_config_dword(dev, pos + reg->reg_offset, write_reg);
+
+	pci_dbg(dev, "Applied _HPX3 at [0x%x]: 0x%08x -> 0x%08x",
+		pos, orig_value, write_reg);
+}
+
+static void program_hpx_type3(struct pci_dev *dev, struct hpx_type3 *hpx3)
+{
+	if (!hpx3)
+		return;
+
+	if (!pci_is_pcie(dev))
+		return;
+
+	program_hpx_type3_register(dev, hpx3);
+}
+
 int pci_configure_extended_tags(struct pci_dev *dev, void *ign)
 {
 	struct pci_host_bridge *host;
@@ -2210,6 +2323,7 @@ static void pci_configure_device(struct pci_dev *dev)
 		.program_type0 = program_hpp_type0,
 		.program_type1 = program_hpp_type1,
 		.program_type2 = program_hpp_type2,
+		.program_type3 = program_hpx_type3,
 	};
 
 	pci_configure_mps(dev);

commit 87fcf12e846a5028c14d21a94a0712fd1ad5bad0
Author: Alexandru Gagniuc <mr.nuke.me@gmail.com>
Date:   Fri Apr 19 14:27:36 2019 -0500

    PCI/ACPI: Remove the need for 'struct hotplug_params'
    
    We used to first parse all the _HPP and _HPX tables before using the
    information to program registers of PCIe devices.  Up through HPX Type 2,
    there was only one structure of each type, so we could cheat and store it
    on the stack.
    
    With HPX Type 3 we get an arbitrary number of entries, so the above model
    doesn't scale that well.  Instead of parsing all tables at once, parse and
    program each entry separately.  For _HPP and _HPX Types 0 through 2, this
    is functionally equivalent.  The change enables the upcoming _HPX Type 3 to
    integrate more easily.
    
    Link: https://lore.kernel.org/lkml/20190208162414.3996-3-mr.nuke.me@gmail.com
    Signed-off-by: Alexandru Gagniuc <mr.nuke.me@gmail.com>
    [bhelgaas: fix build errors]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 2ec0df04e0dc..dce5ae39d0d8 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -2206,8 +2206,11 @@ static void pci_configure_serr(struct pci_dev *dev)
 
 static void pci_configure_device(struct pci_dev *dev)
 {
-	struct hotplug_params hpp;
-	int ret;
+	static const struct hotplug_program_ops hp_ops = {
+		.program_type0 = program_hpp_type0,
+		.program_type1 = program_hpp_type1,
+		.program_type2 = program_hpp_type2,
+	};
 
 	pci_configure_mps(dev);
 	pci_configure_extended_tags(dev, NULL);
@@ -2216,14 +2219,7 @@ static void pci_configure_device(struct pci_dev *dev)
 	pci_configure_eetlp_prefix(dev);
 	pci_configure_serr(dev);
 
-	memset(&hpp, 0, sizeof(hpp));
-	ret = pci_get_hp_params(dev, &hpp);
-	if (ret)
-		return;
-
-	program_hpp_type2(dev, hpp.t2);
-	program_hpp_type1(dev, hpp.t1);
-	program_hpp_type0(dev, hpp.t0);
+	pci_acpi_program_hp_params(dev, &hp_ops);
 }
 
 static void pci_release_capabilities(struct pci_dev *dev)

commit 2dbce590117981196fe355efc0569bc6f949ae9b
Author: Subbaraya Sundeep <sbhatta@marvell.com>
Date:   Mon Nov 19 18:44:32 2018 +0530

    PCI: Assign bus numbers present in EA capability for bridges
    
    The "Enhanced Allocation (EA) for Memory and I/O Resources" ECN, approved
    23 October 2014, sec 6.9.1.2, specifies a second DW in the capability for
    type 1 (bridge) functions to describe fixed secondary and subordinate bus
    numbers.  This ECN was included in the PCIe r4.0 spec, but sec 6.9.1.2 was
    omitted, presumably by mistake.
    
    Read fixed bus numbers from the EA capability for bridges.
    
    Signed-off-by: Subbaraya Sundeep <sbhatta@marvell.com>
    [bhelgaas: add pci_ea_fixed_busnrs() return value]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 012250a78da7..a6874c306908 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1086,6 +1086,36 @@ static void pci_enable_crs(struct pci_dev *pdev)
 
 static unsigned int pci_scan_child_bus_extend(struct pci_bus *bus,
 					      unsigned int available_buses);
+/**
+ * pci_ea_fixed_busnrs() - Read fixed Secondary and Subordinate bus
+ * numbers from EA capability.
+ * @dev: Bridge
+ * @sec: updated with secondary bus number from EA
+ * @sub: updated with subordinate bus number from EA
+ *
+ * If @dev is a bridge with EA capability, update @sec and @sub with
+ * fixed bus numbers from the capability and return true.  Otherwise,
+ * return false.
+ */
+static bool pci_ea_fixed_busnrs(struct pci_dev *dev, u8 *sec, u8 *sub)
+{
+	int ea, offset;
+	u32 dw;
+
+	if (dev->hdr_type != PCI_HEADER_TYPE_BRIDGE)
+		return false;
+
+	/* find PCI EA capability in list */
+	ea = pci_find_capability(dev, PCI_CAP_ID_EA);
+	if (!ea)
+		return false;
+
+	offset = ea + PCI_EA_FIRST_ENT;
+	pci_read_config_dword(dev, offset, &dw);
+	*sec =  dw & PCI_EA_SEC_BUS_MASK;
+	*sub = (dw & PCI_EA_SUB_BUS_MASK) >> PCI_EA_SUB_BUS_SHIFT;
+	return true;
+}
 
 /*
  * pci_scan_bridge_extend() - Scan buses behind a bridge
@@ -1120,6 +1150,9 @@ static int pci_scan_bridge_extend(struct pci_bus *bus, struct pci_dev *dev,
 	u16 bctl;
 	u8 primary, secondary, subordinate;
 	int broken = 0;
+	bool fixed_buses;
+	u8 fixed_sec, fixed_sub;
+	int next_busnr;
 
 	/*
 	 * Make sure the bridge is powered on to be able to access config
@@ -1219,17 +1252,24 @@ static int pci_scan_bridge_extend(struct pci_bus *bus, struct pci_dev *dev,
 		/* Clear errors */
 		pci_write_config_word(dev, PCI_STATUS, 0xffff);
 
+		/* Read bus numbers from EA Capability (if present) */
+		fixed_buses = pci_ea_fixed_busnrs(dev, &fixed_sec, &fixed_sub);
+		if (fixed_buses)
+			next_busnr = fixed_sec;
+		else
+			next_busnr = max + 1;
+
 		/*
 		 * Prevent assigning a bus number that already exists.
 		 * This can happen when a bridge is hot-plugged, so in this
 		 * case we only re-scan this bus.
 		 */
-		child = pci_find_bus(pci_domain_nr(bus), max+1);
+		child = pci_find_bus(pci_domain_nr(bus), next_busnr);
 		if (!child) {
-			child = pci_add_new_bus(bus, dev, max+1);
+			child = pci_add_new_bus(bus, dev, next_busnr);
 			if (!child)
 				goto out;
-			pci_bus_insert_busn_res(child, max+1,
+			pci_bus_insert_busn_res(child, next_busnr,
 						bus->busn_res.end);
 		}
 		max++;
@@ -1290,7 +1330,13 @@ static int pci_scan_bridge_extend(struct pci_bus *bus, struct pci_dev *dev,
 			max += i;
 		}
 
-		/* Set subordinate bus number to its real value */
+		/*
+		 * Set subordinate bus number to its real value.
+		 * If fixed subordinate bus number exists from EA
+		 * capability then use it.
+		 */
+		if (fixed_buses)
+			max = fixed_sub;
 		pci_bus_update_busn_res_end(child, max);
 		pci_write_config_byte(dev, PCI_SUBORDINATE_BUS, max);
 	}

commit 6302bf3ef78dd210b5ff4a922afcb7d8eff8a211
Author: Jean-Philippe Brucker <jean-philippe.brucker@arm.com>
Date:   Mon Mar 18 16:07:18 2019 +0000

    PCI: Init PCIe feature bits for managed host bridge alloc
    
    Two functions allocate a host bridge: devm_pci_alloc_host_bridge() and
    pci_alloc_host_bridge().  At the moment, only the unmanaged one initializes
    the PCIe feature bits, which prevents from using features such as hotplug
    or AER on some systems, when booting with device tree.  Make the
    initialization code common.
    
    Fixes: 02bfeb484230 ("PCI/portdrv: Simplify PCIe feature permission checking")
    Signed-off-by: Jean-Philippe Brucker <jean-philippe.brucker@arm.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    CC: stable@vger.kernel.org      # v4.17+

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 2ec0df04e0dc..012250a78da7 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -586,16 +586,9 @@ static void pci_release_host_bridge_dev(struct device *dev)
 	kfree(to_pci_host_bridge(dev));
 }
 
-struct pci_host_bridge *pci_alloc_host_bridge(size_t priv)
+static void pci_init_host_bridge(struct pci_host_bridge *bridge)
 {
-	struct pci_host_bridge *bridge;
-
-	bridge = kzalloc(sizeof(*bridge) + priv, GFP_KERNEL);
-	if (!bridge)
-		return NULL;
-
 	INIT_LIST_HEAD(&bridge->windows);
-	bridge->dev.release = pci_release_host_bridge_dev;
 
 	/*
 	 * We assume we can manage these PCIe features.  Some systems may
@@ -608,6 +601,18 @@ struct pci_host_bridge *pci_alloc_host_bridge(size_t priv)
 	bridge->native_shpc_hotplug = 1;
 	bridge->native_pme = 1;
 	bridge->native_ltr = 1;
+}
+
+struct pci_host_bridge *pci_alloc_host_bridge(size_t priv)
+{
+	struct pci_host_bridge *bridge;
+
+	bridge = kzalloc(sizeof(*bridge) + priv, GFP_KERNEL);
+	if (!bridge)
+		return NULL;
+
+	pci_init_host_bridge(bridge);
+	bridge->dev.release = pci_release_host_bridge_dev;
 
 	return bridge;
 }
@@ -622,7 +627,7 @@ struct pci_host_bridge *devm_pci_alloc_host_bridge(struct device *dev,
 	if (!bridge)
 		return NULL;
 
-	INIT_LIST_HEAD(&bridge->windows);
+	pci_init_host_bridge(bridge);
 	bridge->dev.release = devm_pci_release_host_bridge_dev;
 
 	return bridge;

commit 0fa635aec9abd718bd18c0bda2261351a0811efc
Author: Lukas Wunner <lukas@wunner.de>
Date:   Wed Mar 20 12:05:30 2019 +0100

    PCI/LINK: Deduplicate bandwidth reports for multi-function devices
    
    If a multi-function device's bandwidth is already limited when it is
    enumerated, a message is logged only for function 0.  By contrast, when
    downtraining occurs after enumeration, a message is logged for all
    functions.  That's because the former uses pcie_report_downtraining(),
    whereas the latter uses __pcie_print_link_status() (which doesn't filter
    functions != 0).  I am seeing this happen on a MacBookPro9,1 with a GPU
    (function 0) and an integrated HDA controller (function 1).
    
    Avoid this incongruence by calling pcie_report_downtraining() in both
    cases.
    
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Alexandru Gagniuc <alex.gagniuc@dellteam.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 2ec0df04e0dc..7e12d0163863 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -2388,7 +2388,7 @@ static struct pci_dev *pci_scan_device(struct pci_bus *bus, int devfn)
 	return dev;
 }
 
-static void pcie_report_downtraining(struct pci_dev *dev)
+void pcie_report_downtraining(struct pci_dev *dev)
 {
 	if (!pci_is_pcie(dev))
 		return;

commit 5d130e3dd8b6995e93aeb7a740709a46e7acf5df
Merge: 1bd2e9ee5c0d 2e095ce7b6ec
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Mar 6 15:30:11 2019 -0600

    Merge branch 'pci/enumeration'
    
      - Probe bridge window attributes only once at enumeration-time to fix
        device accesses during rescan (Bjorn Helgaas)
    
      - Return BAR size (not "size -1 ") from pci_size() to simplify code (Du
        Changbin)
    
      - Use config header type (not class code) identify bridges more reliably
        (Honghui Zhang)
    
      - Work around Intel Denverton incorrect Trace Hub BAR size reporting
        (Alexander Shishkin)
    
    * pci/enumeration:
      x86/PCI: Fixup RTIT_BAR of Intel Denverton Trace Hub
      PCI: Rely on config space header type, not class code
      PCI: Make pci_size() return real BAR size
      PCI: Probe bridge window attributes once at enumeration-time

commit 2fcc19b3410734b1896ba3e9fee1df9036e801fd
Merge: 9d8e0e4b391a dbbfadf23190
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Mar 6 15:30:09 2019 -0600

    Merge branch 'pci/aspm'
    
      - Use Latency Tolerance Reporting if already enabled by platform (Bjorn
        Helgaas)
    
      - Save/restore LTR info for suspend/resume (Bjorn Helgaas)
    
    * pci/aspm:
      PCI/ASPM: Save LTR Capability for suspend/resume
      PCI/ASPM: Use LTR if already enabled by platform

commit 10ecc818ea7319b5d0d2b4e1aa6a77323e776f76
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Jan 4 17:59:07 2019 -0600

    PCI/ASPM: Use LTR if already enabled by platform
    
    RussianNeuroMancer reported that the Intel 7265 wifi on a Dell Venue 11 Pro
    7140 table stopped working after wakeup from suspend and bisected the
    problem to 9ab105deb60f ("PCI/ASPM: Disable ASPM L1.2 Substate if we don't
    have LTR").  David Ward reported the same problem on a Dell Latitude 7350.
    
    After af8bb9f89838 ("PCI/ACPI: Request LTR control from platform before
    using it"), we don't enable LTR unless the platform has granted LTR control
    to us.  In addition, we don't notice if the platform had already enabled
    LTR itself.
    
    After 9ab105deb60f ("PCI/ASPM: Disable ASPM L1.2 Substate if we don't have
    LTR"), we avoid using LTR if we don't think the path to the device has LTR
    enabled.
    
    The combination means that if the platform itself enables LTR but declines
    to give the OS control over LTR, we unnecessarily avoided using ASPM L1.2.
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=201469
    Fixes: 9ab105deb60f ("PCI/ASPM: Disable ASPM L1.2 Substate if we don't have LTR")
    Fixes: af8bb9f89838 ("PCI/ACPI: Request LTR control from platform before using it")
    Reported-by: RussianNeuroMancer <russianneuromancer@ya.ru>
    Reported-by: David Ward <david.ward@ll.mit.edu>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    CC: stable@vger.kernel.org      # v4.18+

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 257b9f6f2ebb..c46a3fcb341e 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -2071,11 +2071,8 @@ static void pci_configure_ltr(struct pci_dev *dev)
 {
 #ifdef CONFIG_PCIEASPM
 	struct pci_host_bridge *host = pci_find_host_bridge(dev->bus);
-	u32 cap;
 	struct pci_dev *bridge;
-
-	if (!host->native_ltr)
-		return;
+	u32 cap, ctl;
 
 	if (!pci_is_pcie(dev))
 		return;
@@ -2084,22 +2081,35 @@ static void pci_configure_ltr(struct pci_dev *dev)
 	if (!(cap & PCI_EXP_DEVCAP2_LTR))
 		return;
 
-	/*
-	 * Software must not enable LTR in an Endpoint unless the Root
-	 * Complex and all intermediate Switches indicate support for LTR.
-	 * PCIe r3.1, sec 6.18.
-	 */
-	if (pci_pcie_type(dev) == PCI_EXP_TYPE_ROOT_PORT)
-		dev->ltr_path = 1;
-	else {
+	pcie_capability_read_dword(dev, PCI_EXP_DEVCTL2, &ctl);
+	if (ctl & PCI_EXP_DEVCTL2_LTR_EN) {
+		if (pci_pcie_type(dev) == PCI_EXP_TYPE_ROOT_PORT) {
+			dev->ltr_path = 1;
+			return;
+		}
+
 		bridge = pci_upstream_bridge(dev);
 		if (bridge && bridge->ltr_path)
 			dev->ltr_path = 1;
+
+		return;
 	}
 
-	if (dev->ltr_path)
+	if (!host->native_ltr)
+		return;
+
+	/*
+	 * Software must not enable LTR in an Endpoint unless the Root
+	 * Complex and all intermediate Switches indicate support for LTR.
+	 * PCIe r4.0, sec 6.18.
+	 */
+	if (pci_pcie_type(dev) == PCI_EXP_TYPE_ROOT_PORT ||
+	    ((bridge = pci_upstream_bridge(dev)) &&
+	      bridge->ltr_path)) {
 		pcie_capability_set_word(dev, PCI_EXP_DEVCTL2,
 					 PCI_EXP_DEVCTL2_LTR_EN);
+		dev->ltr_path = 1;
+	}
 #endif
 }
 

commit b4f6dcb9d35688392d668c46e834f72c55900b49
Author: Bharat Kumar Gogada <bharat.kumar.gogada@xilinx.com>
Date:   Wed Nov 14 20:17:01 2018 +0530

    PCI: Enable SERR# forwarding for all bridges
    
    As per Figure 6-3 in PCIe r4.0, sec 6.2.6, ERR_ messages will be forwarded
    from the secondary interface to the primary interface, if the SERR# Enable
    bit in the Bridge Control register is set.
    
    It seems clear that an ACPI hotplug parameter method (_HPP or _HPX) that
    tells us to "enable SERR in the command register" (ACPI v6.2, sec 6.2.8,
    6.2.9.1) refers to PCI_COMMAND_SERR, which enables reporting of errors by
    the function itself.
    
    For bridges, we also interpreted that to mean we should enable
    PCI_BRIDGE_CTL_SERR, which enables *forwarding* of errors by the bridge.
    But we didn't enable PCI_BRIDGE_CTL_SERR anywhere else, which means we
    never enabled it for non-ACPI systems or ACPI systems that didn't supply
    hotplug parameters.
    
    That means errors reported below bridges were often never forwarded up to a
    Root Port where they could be signaled via AER.
    
    Enable PCI_BRIDGE_CTL_SERR for all bridges so we can get better error
    reporting for downstream devices.
    
    Signed-off-by: Bharat Kumar Gogada <bharat.kumar.gogada@xilinx.com>
    [bhelgaas: changelog]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 257b9f6f2ebb..43e6583417ce 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1856,8 +1856,6 @@ static void program_hpp_type0(struct pci_dev *dev, struct hpp_type0 *hpp)
 		pci_write_config_byte(dev, PCI_SEC_LATENCY_TIMER,
 				      hpp->latency_timer);
 		pci_read_config_word(dev, PCI_BRIDGE_CONTROL, &pci_bctl);
-		if (hpp->enable_serr)
-			pci_bctl |= PCI_BRIDGE_CTL_SERR;
 		if (hpp->enable_perr)
 			pci_bctl |= PCI_BRIDGE_CTL_PARITY;
 		pci_write_config_word(dev, PCI_BRIDGE_CONTROL, pci_bctl);
@@ -2129,6 +2127,24 @@ static void pci_configure_eetlp_prefix(struct pci_dev *dev)
 #endif
 }
 
+static void pci_configure_serr(struct pci_dev *dev)
+{
+	u16 control;
+
+	if (dev->hdr_type == PCI_HEADER_TYPE_BRIDGE) {
+
+		/*
+		 * A bridge will not forward ERR_ messages coming from an
+		 * endpoint unless SERR# forwarding is enabled.
+		 */
+		pci_read_config_word(dev, PCI_BRIDGE_CONTROL, &control);
+		if (!(control & PCI_BRIDGE_CTL_SERR)) {
+			control |= PCI_BRIDGE_CTL_SERR;
+			pci_write_config_word(dev, PCI_BRIDGE_CONTROL, control);
+		}
+	}
+}
+
 static void pci_configure_device(struct pci_dev *dev)
 {
 	struct hotplug_params hpp;
@@ -2139,6 +2155,7 @@ static void pci_configure_device(struct pci_dev *dev)
 	pci_configure_relaxed_ordering(dev);
 	pci_configure_ltr(dev);
 	pci_configure_eetlp_prefix(dev);
+	pci_configure_serr(dev);
 
 	memset(&hpp, 0, sizeof(hpp));
 	ret = pci_get_hp_params(dev, &hpp);

commit b2fb5cc574695a32361a6c1878816b3d6563aa0f
Author: Honghui Zhang <honghui.zhang@mediatek.com>
Date:   Tue Oct 16 18:44:43 2018 +0800

    PCI: Rely on config space header type, not class code
    
    The PCI configuration space header type tells us whether the device is a
    bridge, a CardBus bridge, or a normal device, and defines the layout of the
    rest of the header (PCI r3.0 sec 6.1, PCIe r4.0 sec 7.5.1.1.9).
    
    When we rely on the header format, e.g., when we're dealing with bridge
    windows, we should check the header type, not the class code.  The class
    code is loosely related to the header type, but is often incorrect and the
    spec doesn't actually require it to be related to the header format.
    
    Suggested-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Honghui Zhang <honghui.zhang@mediatek.com>
    [bhelgaas: changelog, keep the PCI_CLASS_BRIDGE_HOST check]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 8e2e4154cdd9..128459a0ffba 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1779,9 +1779,6 @@ int pci_setup_device(struct pci_dev *dev)
 		break;
 
 	case PCI_HEADER_TYPE_BRIDGE:		    /* bridge header */
-		if (class != PCI_CLASS_BRIDGE_PCI)
-			goto bad;
-
 		/*
 		 * The PCI-to-PCI bridge spec requires that subtractive
 		 * decoding (i.e. transparent) bridge must have programming

commit 01b37f851ca150554496fd6e79c6d9a67992a2c0
Author: Du Changbin <changbin.du@gmail.com>
Date:   Sat Oct 13 08:49:19 2018 +0800

    PCI: Make pci_size() return real BAR size
    
    Currently, the pci_size() function actually returns 'size-1'.  Make it
    return real size to avoid confusion.
    
    Signed-off-by: Du Changbin <changbin.du@gmail.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 2ef8b954c65a..8e2e4154cdd9 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -121,13 +121,13 @@ static u64 pci_size(u64 base, u64 maxbase, u64 mask)
 	 * Get the lowest of them to find the decode size, and from that
 	 * the extent.
 	 */
-	size = (size & ~(size-1)) - 1;
+	size = size & ~(size-1);
 
 	/*
 	 * base == maxbase can be valid only if the BAR has already been
 	 * programmed with all 1s.
 	 */
-	if (base == maxbase && ((base | size) & mask) != mask)
+	if (base == maxbase && ((base | (size - 1)) & mask) != mask)
 		return 0;
 
 	return size;
@@ -278,7 +278,7 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 			/* Above 32-bit boundary; try to reallocate */
 			res->flags |= IORESOURCE_UNSET;
 			res->start = 0;
-			res->end = sz64;
+			res->end = sz64 - 1;
 			pci_info(dev, "reg 0x%x: can't handle BAR above 4GB (bus address %#010llx)\n",
 				 pos, (unsigned long long)l64);
 			goto out;
@@ -286,7 +286,7 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 	}
 
 	region.start = l64;
-	region.end = l64 + sz64;
+	region.end = l64 + sz64 - 1;
 
 	pcibios_bus_to_resource(dev->bus, res, &region);
 	pcibios_resource_to_bus(dev->bus, &inverted_region, res);

commit 51c48b310183ab6ba5419edfc6a8de889cc04521
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Sat Jan 19 11:35:04 2019 -0600

    PCI: Probe bridge window attributes once at enumeration-time
    
    pci_bridge_check_ranges() determines whether a bridge supports the optional
    I/O and prefetchable memory windows and sets the flag bits in the bridge
    resources.  This *could* be done once during enumeration except that the
    resource allocation code completely clears the flag bits, e.g., in the
    pci_assign_unassigned_bridge_resources() path.
    
    The problem with pci_bridge_check_ranges() in the resource allocation path
    is that we may allocate resources after devices have been claimed by
    drivers, and pci_bridge_check_ranges() *changes* the window registers to
    determine whether they're writable.  This may break concurrent accesses to
    devices behind the bridge.
    
    Add a new pci_read_bridge_windows() to determine whether a bridge supports
    the optional windows, call it once during enumeration, remember the
    results, and change pci_bridge_check_ranges() so it doesn't touch the
    bridge windows but sets the flag bits based on those remembered results.
    
    Link: https://lore.kernel.org/linux-pci/1506151482-113560-1-git-send-email-wangzhou1@hisilicon.com
    Link: https://lists.gnu.org/archive/html/qemu-devel/2018-12/msg02082.html
    Reported-by: Yandong Xu <xuyandong2@huawei.com>
    Tested-by: Yandong Xu <xuyandong2@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Michael S. Tsirkin <mst@redhat.com>
    Cc: Sagi Grimberg <sagi@grimberg.me>
    Cc: Ofer Hayut <ofer@lightbitslabs.com>
    Cc: Roy Shterman <roys@lightbitslabs.com>
    Cc: Keith Busch <keith.busch@intel.com>
    Cc: Zhou Wang <wangzhou1@hisilicon.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 257b9f6f2ebb..2ef8b954c65a 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -348,6 +348,57 @@ static void pci_read_bases(struct pci_dev *dev, unsigned int howmany, int rom)
 	}
 }
 
+static void pci_read_bridge_windows(struct pci_dev *bridge)
+{
+	u16 io;
+	u32 pmem, tmp;
+
+	pci_read_config_word(bridge, PCI_IO_BASE, &io);
+	if (!io) {
+		pci_write_config_word(bridge, PCI_IO_BASE, 0xe0f0);
+		pci_read_config_word(bridge, PCI_IO_BASE, &io);
+		pci_write_config_word(bridge, PCI_IO_BASE, 0x0);
+	}
+	if (io)
+		bridge->io_window = 1;
+
+	/*
+	 * DECchip 21050 pass 2 errata: the bridge may miss an address
+	 * disconnect boundary by one PCI data phase.  Workaround: do not
+	 * use prefetching on this device.
+	 */
+	if (bridge->vendor == PCI_VENDOR_ID_DEC && bridge->device == 0x0001)
+		return;
+
+	pci_read_config_dword(bridge, PCI_PREF_MEMORY_BASE, &pmem);
+	if (!pmem) {
+		pci_write_config_dword(bridge, PCI_PREF_MEMORY_BASE,
+					       0xffe0fff0);
+		pci_read_config_dword(bridge, PCI_PREF_MEMORY_BASE, &pmem);
+		pci_write_config_dword(bridge, PCI_PREF_MEMORY_BASE, 0x0);
+	}
+	if (!pmem)
+		return;
+
+	bridge->pref_window = 1;
+
+	if ((pmem & PCI_PREF_RANGE_TYPE_MASK) == PCI_PREF_RANGE_TYPE_64) {
+
+		/*
+		 * Bridge claims to have a 64-bit prefetchable memory
+		 * window; verify that the upper bits are actually
+		 * writable.
+		 */
+		pci_read_config_dword(bridge, PCI_PREF_BASE_UPPER32, &pmem);
+		pci_write_config_dword(bridge, PCI_PREF_BASE_UPPER32,
+				       0xffffffff);
+		pci_read_config_dword(bridge, PCI_PREF_BASE_UPPER32, &tmp);
+		pci_write_config_dword(bridge, PCI_PREF_BASE_UPPER32, pmem);
+		if (tmp)
+			bridge->pref_64_window = 1;
+	}
+}
+
 static void pci_read_bridge_io(struct pci_bus *child)
 {
 	struct pci_dev *dev = child->self;
@@ -1739,6 +1790,7 @@ int pci_setup_device(struct pci_dev *dev)
 		pci_read_irq(dev);
 		dev->transparent = ((dev->class & 0xff) == 1);
 		pci_read_bases(dev, 2, PCI_ROM_ADDRESS1);
+		pci_read_bridge_windows(dev);
 		set_pcie_hotplug_bridge(dev);
 		pos = pci_find_capability(dev, PCI_CAP_ID_SSVID);
 		if (pos) {

commit 617654aae50eb59dd98aa53fb562e850937f4cde
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Thu Aug 16 12:28:48 2018 +0300

    PCI / ACPI: Identify untrusted PCI devices
    
    A malicious PCI device may use DMA to attack the system. An external
    Thunderbolt port is a convenient point to attach such a device. The OS
    may use IOMMU to defend against DMA attacks.
    
    Some BIOSes mark these externally facing root ports with this
    ACPI _DSD [1]:
    
      Name (_DSD, Package () {
          ToUUID ("efcc06cc-73ac-4bc3-bff0-76143807c389"),
          Package () {
              Package () {"ExternalFacingPort", 1},
              Package () {"UID", 0 }
          }
      })
    
    If we find such a root port, mark it and all its children as untrusted.
    The rest of the OS may use this information to enable DMA protection
    against malicious devices. For instance the device may be put behind an
    IOMMU to keep it from accessing memory outside of what the driver has
    allocated for it.
    
    While at it, add a comment on top of prp_guids array explaining the
    possible caveat resulting when these GUIDs are treated equivalent.
    
    [1] https://docs.microsoft.com/en-us/windows-hardware/drivers/pci/dsd-for-pcie-root-ports#identifying-externally-exposed-pcie-root-ports
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index b1c05b5054a0..257b9f6f2ebb 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1378,6 +1378,19 @@ static void set_pcie_thunderbolt(struct pci_dev *dev)
 	}
 }
 
+static void set_pcie_untrusted(struct pci_dev *dev)
+{
+	struct pci_dev *parent;
+
+	/*
+	 * If the upstream bridge is untrusted we treat this device
+	 * untrusted as well.
+	 */
+	parent = pci_upstream_bridge(dev);
+	if (parent && parent->untrusted)
+		dev->untrusted = true;
+}
+
 /**
  * pci_ext_cfg_is_aliased - Is ext config space just an alias of std config?
  * @dev: PCI device
@@ -1638,6 +1651,8 @@ int pci_setup_device(struct pci_dev *dev)
 	/* Need to have dev->cfg_size ready */
 	set_pcie_thunderbolt(dev);
 
+	set_pcie_untrusted(dev);
+
 	/* "Unknown power state" */
 	dev->current_state = PCI_UNKNOWN;
 

commit eff81b6f7b1ecad7e8cdf4f44b010b54ef438864
Merge: 1734715493e0 4c243716e77d
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Sat Oct 20 11:45:35 2018 -0500

    Merge branch 'pci/virtualization'
    
      - Cache VF config space size to optimize enumeration of many VFs
        (KarimAllah Ahmed)
    
      - Remove unnecessary <linux/pci-ats.h> include (Bjorn Helgaas)
    
    * pci/virtualization:
      PCI/IOV: Remove unnecessary include of <linux/pci-ats.h>
      PCI/IOV: Use VF0 cached config space size for other VFs

commit ee8360fdafac54eefd0df69fbd99338896cf806b
Merge: 20634dc361e1 fe73c23d7a09
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Sat Oct 20 11:45:30 2018 -0500

    Merge branch 'pci/misc'
    
      - Remove unused Netronome NFP32xx Device IDs (Jakub Kicinski)
    
      - Use bitmap_zalloc() for dma_alias_mask (Andy Shevchenko)
    
      - Add switch fall-through annotations (Gustavo A. R. Silva)
    
      - Remove unused Switchtec quirk variable (Joshua Abraham)
    
      - Fix pci.c kernel-doc warning (Randy Dunlap)
    
      - Remove trivial PCI wrappers for DMA APIs (Christoph Hellwig)
    
      - Add Intel GPU device IDs to spurious interrupt quirk (Bin Meng)
    
      - Run Switchtec DMA aliasing quirk only on NTB endpoints to avoid useless
        dmesg errors (Logan Gunthorpe)
    
      - Update Switchtec NTB documentation (Wesley Yung)
    
      - Remove redundant "default n" from Kconfig (Bartlomiej Zolnierkiewicz)
    
    * pci/misc:
      PCI: pcie: Remove redundant 'default n' from Kconfig
      NTB: switchtec_ntb: Update switchtec documentation with prerequisites for NTB
      PCI: Fix Switchtec DMA aliasing quirk dmesg noise
      PCI: Add macro for Switchtec quirk declarations
      PCI: Add Device IDs for Intel GPU "spurious interrupt" quirk
      PCI: Remove pci_set_dma_max_seg_size()
      PCI: Remove pci_set_dma_seg_boundary()
      PCI: Remove pci_unmap_addr() wrappers for DMA API
      PCI / ACPI: Mark expected switch fall-through
      PCI: Remove set but unused variable
      PCI: Fix pci.c kernel-doc parameter warning
      PCI: Allocate dma_alias_mask with bitmap_zalloc()
      PCI: Remove unused NFP32xx IDs

commit 975bb8b4dc93364bb47fcdb58812fa6cb0accc81
Author: KarimAllah Ahmed <karahmed@amazon.de>
Date:   Thu Oct 11 11:49:58 2018 -0500

    PCI/IOV: Use VF0 cached config space size for other VFs
    
    Cache the config space size from VF0 and use it for all other VFs instead
    of reading it from the config space of each VF.  We assume that it will be
    the same across all associated VFs.
    
    This is an optimization when enabling SR-IOV on a device with many VFs.
    
    Signed-off-by: KarimAllah Ahmed <karahmed@amazon.de>
    [bhelgaas: use CONFIG_PCI_IOV (not CONFIG_PCI_ATS)]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 201f9e5ff55c..575315bb7c4c 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1438,12 +1438,29 @@ static int pci_cfg_space_size_ext(struct pci_dev *dev)
 	return PCI_CFG_SPACE_EXP_SIZE;
 }
 
+#ifdef CONFIG_PCI_IOV
+static bool is_vf0(struct pci_dev *dev)
+{
+	if (pci_iov_virtfn_devfn(dev->physfn, 0) == dev->devfn &&
+	    pci_iov_virtfn_bus(dev->physfn, 0) == dev->bus->number)
+		return true;
+
+	return false;
+}
+#endif
+
 int pci_cfg_space_size(struct pci_dev *dev)
 {
 	int pos;
 	u32 status;
 	u16 class;
 
+#ifdef CONFIG_PCI_IOV
+	/* Read cached value for all VFs except for VF0 */
+	if (dev->is_virtfn && !is_vf0(dev))
+		return dev->physfn->sriov->cfg_size;
+#endif
+
 	if (dev->bus->bus_flags & PCI_BUS_FLAGS_NO_EXTCFG)
 		return PCI_CFG_SPACE_SIZE;
 

commit b0da3498c587c20e64799c4c7ba65a31314b2182
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Oct 9 16:08:24 2018 +0200

    PCI: Remove pci_set_dma_max_seg_size()
    
    The few callers can just use dma_set_max_seg_size ()directly.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 72dd926680be..75d896549360 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -2397,7 +2397,7 @@ void pci_device_add(struct pci_dev *dev, struct pci_bus *bus)
 	dev->dev.dma_parms = &dev->dma_parms;
 	dev->dev.coherent_dma_mask = 0xffffffffull;
 
-	pci_set_dma_max_seg_size(dev, 65536);
+	dma_set_max_seg_size(&dev->dev, 65536);
 	dma_set_seg_boundary(&dev->dev, 0xffffffff);
 
 	/* Fix up broken headers */

commit a6f44cf9f5cc60471cf06f3d5391fc6041eb37a5
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Oct 9 16:08:23 2018 +0200

    PCI: Remove pci_set_dma_seg_boundary()
    
    The two callers can just use dma_set_seg_boundary() directly.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 7c422ccbf9b4..72dd926680be 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -2398,7 +2398,7 @@ void pci_device_add(struct pci_dev *dev, struct pci_bus *bus)
 	dev->dev.coherent_dma_mask = 0xffffffffull;
 
 	pci_set_dma_max_seg_size(dev, 65536);
-	pci_set_dma_seg_boundary(dev, 0xffffffff);
+	dma_set_seg_boundary(&dev->dev, 0xffffffff);
 
 	/* Fix up broken headers */
 	pci_fixup_device(pci_fixup_header, dev);

commit f0157160b359b1d263ee9d4e0a435a7ad85bbcea
Author: Keith Busch <keith.busch@intel.com>
Date:   Thu Sep 20 10:27:17 2018 -0600

    PCI: Make link active reporting detection generic
    
    The spec has timing requirements when waiting for a link to become active
    after a conventional reset.  Implement those hard delays when waiting for
    an active link so pciehp and dpc drivers don't need to duplicate this.
    
    For devices that don't support data link layer active reporting, wait the
    fixed time recommended by the PCIe spec.
    
    Signed-off-by: Keith Busch <keith.busch@intel.com>
    [bhelgaas: changelog]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Sinan Kaya <okaya@kernel.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 201f9e5ff55c..bb2999d1b199 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -713,6 +713,7 @@ static void pci_set_bus_speed(struct pci_bus *bus)
 
 		pcie_capability_read_dword(bridge, PCI_EXP_LNKCAP, &linkcap);
 		bus->max_bus_speed = pcie_link_speed[linkcap & PCI_EXP_LNKCAP_SLS];
+		bridge->link_active_reporting = !!(linkcap & PCI_EXP_LNKCAP_DLLLARC);
 
 		pcie_capability_read_word(bridge, PCI_EXP_LNKSTA, &linksta);
 		pcie_update_link_speed(bus, linksta);

commit c6635792737b881021ead417b281067d56ed3380
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Thu Aug 30 13:32:36 2018 +0300

    PCI: Allocate dma_alias_mask with bitmap_zalloc()
    
    Switch to bitmap_zalloc() to show clearly what we are allocating.  Besides
    that it returns pointer of bitmap type ("unsigned long *") instead of the
    opaque "void *".
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 201f9e5ff55c..7c422ccbf9b4 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -2143,7 +2143,7 @@ static void pci_release_dev(struct device *dev)
 	pcibios_release_device(pci_dev);
 	pci_bus_put(pci_dev->bus);
 	kfree(pci_dev->driver_override);
-	kfree(pci_dev->dma_alias_mask);
+	bitmap_free(pci_dev->dma_alias_mask);
 	kfree(pci_dev);
 }
 

commit 9d27e39d309c93025ae6aa97236af15bef2a5f1f
Author: Felix Kuehling <Felix.Kuehling@amd.com>
Date:   Mon Sep 10 15:27:42 2018 -0400

    PCI: Fix enabling of PASID on RC integrated endpoints
    
    Set the eetlp_prefix_path on PCIE_EXP_TYPE_RC_END devices to allow PASID
    to be enabled on them.  This fixes IOMMUv2 initialization on AMD Carrizo
    APUs.
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=201079
    Fixes: 7ce3f912ae ("PCI: Enable PASID only if entire path supports End-End TLP prefixes")
    Signed-off-by: Felix Kuehling <Felix.Kuehling@amd.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index ec784009a36b..201f9e5ff55c 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -2074,6 +2074,7 @@ static void pci_configure_eetlp_prefix(struct pci_dev *dev)
 {
 #ifdef CONFIG_PCI_PASID
 	struct pci_dev *bridge;
+	int pcie_type;
 	u32 cap;
 
 	if (!pci_is_pcie(dev))
@@ -2083,7 +2084,9 @@ static void pci_configure_eetlp_prefix(struct pci_dev *dev)
 	if (!(cap & PCI_EXP_DEVCAP2_EE_PREFIX))
 		return;
 
-	if (pci_pcie_type(dev) == PCI_EXP_TYPE_ROOT_PORT)
+	pcie_type = pci_pcie_type(dev);
+	if (pcie_type == PCI_EXP_TYPE_ROOT_PORT ||
+	    pcie_type == PCI_EXP_TYPE_RC_END)
 		dev->eetlp_prefix_path = 1;
 	else {
 		bridge = pci_upstream_bridge(dev);

commit 3a48dc6fc260c9cac302a9ffaeab95359431c485
Merge: e7aaf90f9d9d 7695e73f3db4
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Aug 15 14:59:06 2018 -0500

    Merge branch 'pci/virtualization'
    
      - To avoid bus errors, enable PASID only if entire path supports End-End
        TLP prefixes (Sinan Kaya)
    
      - Unify slot and bus reset functions and remove hotplug knowledge from
        callers (Sinan Kaya)
    
      - Add Function-Level Reset quirks for Intel and Samsung NVMe devices to
        fix guest reboot issues (Alex Williamson)
    
      - Add function 1 DMA alias quirk for Marvell 88SS9183 PCIe SSD Controller
        (Bjorn Helgaas)
    
    * pci/virtualization:
      PCI: Add function 1 DMA alias quirk for Marvell 88SS9183
      PCI: Delay after FLR of Intel DC P3700 NVMe
      PCI: Disable Samsung SM961/PM961 NVMe before FLR
      PCI: Export pcie_has_flr()
      PCI: Rename pci_try_reset_bus() to pci_reset_bus()
      PCI: Deprecate pci_reset_bus() and pci_reset_slot() functions
      PCI: Unify try slot and bus reset API
      PCI: Hide pci_reset_bridge_secondary_bus() from drivers
      IB/hfi1: Use pci_try_reset_bus() for initiating PCI Secondary Bus Reset
      PCI: Handle error return from pci_reset_bridge_secondary_bus()
      PCI/IOV: Tidy pci_sriov_set_totalvfs()
      PCI: Enable PASID only if entire path supports End-End TLP prefixes
    
    # Conflicts:
    #       drivers/pci/hotplug/pciehp_hpc.c

commit 5fc054a54476f9e2b3d6cc3eeb1537aa549d0ba3
Merge: c689209be231 783e84961b1d
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Aug 15 14:59:01 2018 -0500

    Merge branch 'pci/resource'
    
      - Clean up devm_of_pci_get_host_bridge_resources() resource allocation
        (Jan Kiszka)
    
      - Fixup resizable BARs after suspend/resume (Christian König)
    
      - Make "pci=earlydump" generic (Sinan Kaya)
    
      - Fix ROM BAR access routines to stay in bounds and check for signature
        correctly (Rex Zhu)
    
    * pci/resource:
      PCI: Make pci_get_rom_size() static
      PCI: Add check code for last image indicator not set
      PCI: Avoid accessing memory outside the ROM BAR
      PCI: Make early dump functionality generic
      PCI: Cleanup PCI_REBAR_CTRL_BAR_SHIFT handling
      PCI: Restore resized BAR state on resume
      PCI: Clean up resource allocation in devm_of_pci_get_host_bridge_resources()
    
    # Conflicts:
    #       Documentation/admin-guide/kernel-parameters.txt

commit a8bcb5e5966ccbd99a6d06cf69ada7f95416aabc
Merge: 1ca358a8e3ff 9f0e89359775
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Aug 15 14:58:52 2018 -0500

    Merge branch 'pci/enumeration'
    
      - Work around IDT switch ACS Source Validation erratum (James
        Puthukattukaran)
    
      - Emit diagnostics for all cases of PCIe Link downtraining (Links
        operating slower than they're capable of) (Alexandru Gagniuc)
    
      - Skip VFs when configuring Max Payload Size (Myron Stowe)
    
      - Reduce Root Port Max Payload Size if necessary when hot-adding a device
        below it (Myron Stowe)
    
    * pci/enumeration:
      PCI: Match Root Port's MPS to endpoint's MPSS as necessary
      PCI: Skip MPS logic for Virtual Functions (VFs)
      PCI: Check for PCIe Link downtraining
      PCI: Workaround IDT switch ACS Source Validation erratum

commit 187dacce194216c4d86c2afd0ca490a6d7fbb981
Merge: 3c3ab37f4c03 ce29af2a5056
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Aug 15 14:58:46 2018 -0500

    Merge branch 'pci/aspm'
    
      - Use sysfs_match_string() to simplify ASPM sysfs parsing (Andy
        Shevchenko)
    
      - Remove unnecessary includes of <linux/pci-aspm.h> (Bjorn Helgaas)
    
    * pci/aspm:
      PCI: Remove unnecessary include of <linux/pci-aspm.h>
      iwlwifi: Remove unnecessary include of <linux/pci-aspm.h>
      ath9k: Remove unnecessary include of <linux/pci-aspm.h>
      igb: Remove unnecessary include of <linux/pci-aspm.h>
      PCI/ASPM: Convert to use sysfs_match_string() helper

commit 3c3ab37f4c03dc9c7c917ff3c1e71d6da81d3bd3
Merge: af863d18a1fb 45687f96c112
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Aug 15 14:58:45 2018 -0500

    Merge branch 'pci/aer'
    
      - Decode AER errors with names similar to "lspci" (Tyler Baicar)
    
      - Expose AER statistics in sysfs (Rajat Jain)
    
      - Clear AER status bits selectively based on the type of recovery (Oza
        Pawandeep)
    
      - Honor "pcie_ports=native" even if HEST sets FIRMWARE_FIRST (Alexandru
        Gagniuc)
    
      - Don't clear AER status bits if we're using the "Firmware-First"
        strategy where firmware owns the registers (Alexandru Gagniuc)
    
    * pci/aer:
      PCI/AER: Don't clear AER bits if error handling is Firmware-First
      PCI/AER: Remove duplicate PCI_EXP_AER_FLAGS definition
      PCI/portdrv: Remove pcie_portdrv_err_handler.slot_reset
      PCI/AER: Clear device status bits during ERR_COR handling
      PCI/AER: Clear device status bits during ERR_FATAL and ERR_NONFATAL
      PCI/AER: Remove ERR_FATAL code from ERR_NONFATAL path
      PCI/AER: Factor out ERR_NONFATAL status bit clearing
      PCI/AER: Clear only ERR_NONFATAL bits during non-fatal recovery
      PCI/AER: Clear only ERR_FATAL status bits during fatal recovery
      PCI/AER: Honor "pcie_ports=native" even if HEST sets FIRMWARE_FIRST
      PCI/AER: Add sysfs attributes for rootport cumulative stats
      PCI/AER: Add sysfs attributes to provide AER stats and breakdown
      PCI/AER: Define aer_stats structure for AER capable devices
      PCI/AER: Move internal declarations to drivers/pci/pci.h
      PCI/AER: Adopt lspci names for AER error decoding
      PCI/AER: Expose internal API for obtaining AER information
    
    # Conflicts:
    #       drivers/pci/pci.h

commit 9f0e89359775ee21fe1ea732e34edb52aef5addf
Author: Myron Stowe <myron.stowe@redhat.com>
Date:   Mon Aug 13 12:19:46 2018 -0600

    PCI: Match Root Port's MPS to endpoint's MPSS as necessary
    
    In commit 27d868b5e6cf ("PCI: Set MPS to match upstream bridge"), we made
    sure every device's MPS setting matches its upstream bridge, making it more
    likely that a hot-added device will work in a system with an optimized MPS
    configuration.
    
    Recently I've started encountering systems where the endpoint device's MPSS
    capability is less than its Root Port's current MPS value, thus the
    endpoint is not capable of matching its upstream bridge's MPS setting (see:
    bugzilla via "Link:" below).  This leaves the system vulnerable - the
    upstream Root Port could respond with larger TLPs than the device can
    handle, and the device will consider them to be 'Malformed'.
    
    One could use the "pci=pcie_bus_safe" kernel parameter to work around the
    issue, but that forces a user to supply a kernel parameter to get the
    system to function reliably and may end up limiting MPS settings of other
    unrelated, sub-topologies which could benefit from maintaining their larger
    values.
    
    Augment Keith's approach to include tuning down a Root Port's MPS setting
    when its hot-added endpoint device is not capable of matching it.
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=200527
    Signed-off-by: Myron Stowe <myron.stowe@redhat.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Jon Mason <jdmason@kudzu.us>
    Cc: Keith Busch <keith.busch@intel.com>
    Cc: Sinan Kaya <okaya@kernel.org>
    Cc: Dongdong Liu <liudongdong3@huawei.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index c2533ed45fff..bca6d2741969 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1725,7 +1725,7 @@ int pci_setup_device(struct pci_dev *dev)
 static void pci_configure_mps(struct pci_dev *dev)
 {
 	struct pci_dev *bridge = pci_upstream_bridge(dev);
-	int mps, p_mps, rc;
+	int mps, mpss, p_mps, rc;
 
 	if (!pci_is_pcie(dev) || !bridge || !pci_is_pcie(bridge))
 		return;
@@ -1753,6 +1753,14 @@ static void pci_configure_mps(struct pci_dev *dev)
 	if (pcie_bus_config != PCIE_BUS_DEFAULT)
 		return;
 
+	mpss = 128 << dev->pcie_mpss;
+	if (mpss < p_mps && pci_pcie_type(bridge) == PCI_EXP_TYPE_ROOT_PORT) {
+		pcie_set_mps(bridge, mpss);
+		pci_info(dev, "Upstream bridge's Max Payload Size set to %d (was %d, max %d)\n",
+			 mpss, p_mps, 128 << bridge->pcie_mpss);
+		p_mps = pcie_get_mps(bridge);
+	}
+
 	rc = pcie_set_mps(dev, p_mps);
 	if (rc) {
 		pci_warn(dev, "can't set Max Payload Size to %d; if necessary, use \"pci=pcie_bus_safe\" and report a bug\n",
@@ -1761,7 +1769,7 @@ static void pci_configure_mps(struct pci_dev *dev)
 	}
 
 	pci_info(dev, "Max Payload Size set to %d (was %d, max %d)\n",
-		 p_mps, mps, 128 << dev->pcie_mpss);
+		 p_mps, mps, mpss);
 }
 
 static struct hpp_type0 pci_default_type0 = {

commit 3dbe97efe8bf450b183d6dee2305cbc032e6b8a4
Author: Myron Stowe <myron.stowe@redhat.com>
Date:   Mon Aug 13 12:19:39 2018 -0600

    PCI: Skip MPS logic for Virtual Functions (VFs)
    
    PCIe r4.0, sec 9.3.5.4, "Device Control Register", shows both
    Max_Payload_Size (MPS) and Max_Read_request_Size (MRRS) to be 'RsvdP' for
    VFs.  Just prior to the table it states:
    
      "PF and VF functionality is defined in Section 7.5.3.4 except where
       noted in Table 9-16.  For VF fields marked 'RsvdP', the PF setting
       applies to the VF."
    
    All of which implies that with respect to Max_Payload_Size Supported
    (MPSS), MPS, and MRRS values, we should not be paying any attention to the
    VF's fields, but rather only to the PF's.  Only looking at the PF's fields
    also logically makes sense as it's the sole physical interface to the PCIe
    bus.
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=200527
    Fixes: 27d868b5e6cf ("PCI: Set MPS to match upstream bridge")
    Signed-off-by: Myron Stowe <myron.stowe@redhat.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: stable@vger.kernel.org # 4.3+
    Cc: Keith Busch <keith.busch@intel.com>
    Cc: Sinan Kaya <okaya@kernel.org>
    Cc: Dongdong Liu <liudongdong3@huawei.com>
    Cc: Jon Mason <jdmason@kudzu.us>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 71412db3cbeb..c2533ed45fff 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1730,6 +1730,10 @@ static void pci_configure_mps(struct pci_dev *dev)
 	if (!pci_is_pcie(dev) || !bridge || !pci_is_pcie(bridge))
 		return;
 
+	/* MPS and MRRS fields are of type 'RsvdP' for VFs, short-circuit out */
+	if (dev->is_virtfn)
+		return;
+
 	mps = pcie_get_mps(dev);
 	p_mps = pcie_get_mps(bridge);
 

commit 2d1ce5ec2117d16047334a1aa4b62e0cfb5a0605
Author: Alexandru Gagniuc <mr.nuke.me@gmail.com>
Date:   Mon Aug 6 18:25:35 2018 -0500

    PCI: Check for PCIe Link downtraining
    
    When both ends of a PCIe Link are capable of a higher bandwidth than is
    currently in use, the Link is said to be "downtrained".  A downtrained Link
    may indicate hardware or configuration problems in the system, but it's
    hard to identify such Links from userspace.
    
    Refactor pcie_print_link_status() so it continues to always print PCIe
    bandwidth information, as several NIC drivers desire.
    
    Add a new internal __pcie_print_link_status() to emit a message only when a
    device's bandwidth is constrained by the fabric and call it from the PCI
    core for all devices, which identifies all downtrained Links.  It also
    emits messages for a few cases that are technically not downtrained, such
    as a x4 device in an open-ended x1 slot.
    
    Signed-off-by: Alexandru Gagniuc <mr.nuke.me@gmail.com>
    [bhelgaas: changelog, move __pcie_print_link_status() declaration to
    drivers/pci/, rename pcie_check_upstream_link() to
    pcie_report_downtraining()]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 7c0c8ab94bcf..71412db3cbeb 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -2223,6 +2223,25 @@ static struct pci_dev *pci_scan_device(struct pci_bus *bus, int devfn)
 	return dev;
 }
 
+static void pcie_report_downtraining(struct pci_dev *dev)
+{
+	if (!pci_is_pcie(dev))
+		return;
+
+	/* Look from the device up to avoid downstream ports with no devices */
+	if ((pci_pcie_type(dev) != PCI_EXP_TYPE_ENDPOINT) &&
+	    (pci_pcie_type(dev) != PCI_EXP_TYPE_LEG_END) &&
+	    (pci_pcie_type(dev) != PCI_EXP_TYPE_UPSTREAM))
+		return;
+
+	/* Multi-function PCIe devices share the same link/status */
+	if (PCI_FUNC(dev->devfn) != 0 || dev->is_virtfn)
+		return;
+
+	/* Print link status only if the device is constrained by the fabric */
+	__pcie_print_link_status(dev, false);
+}
+
 static void pci_init_capabilities(struct pci_dev *dev)
 {
 	/* Enhanced Allocation */
@@ -2258,6 +2277,8 @@ static void pci_init_capabilities(struct pci_dev *dev)
 	/* Advanced Error Reporting */
 	pci_aer_init(dev);
 
+	pcie_report_downtraining(dev);
+
 	if (pci_probe_reset_function(dev) == 0)
 		dev->reset_fn = 1;
 }

commit ce29af2a505627cc8f1deddb84bcbaf186b0bfd5
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Jul 25 14:53:42 2018 -0500

    PCI: Remove unnecessary include of <linux/pci-aspm.h>
    
    Several PCI core files include pci-aspm.h even though they don't need
    anything provided by that file.  Remove the unnecessary includes of it.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Sinan Kaya <okaya@kernel.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index ac876e32de4b..1ed2852dee21 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -13,7 +13,6 @@
 #include <linux/slab.h>
 #include <linux/module.h>
 #include <linux/cpumask.h>
-#include <linux/pci-aspm.h>
 #include <linux/aer.h>
 #include <linux/acpi.h>
 #include <linux/hypervisor.h>

commit 44bda4b7d26e9fffed6d7152d98a2e9edaeb2a76
Author: Hari Vyas <hari.vyas@broadcom.com>
Date:   Tue Jul 3 14:35:41 2018 +0530

    PCI: Fix is_added/is_busmaster race condition
    
    When a PCI device is detected, pdev->is_added is set to 1 and proc and
    sysfs entries are created.
    
    When the device is removed, pdev->is_added is checked for one and then
    device is detached with clearing of proc and sys entries and at end,
    pdev->is_added is set to 0.
    
    is_added and is_busmaster are bit fields in pci_dev structure sharing same
    memory location.
    
    A strange issue was observed with multiple removal and rescan of a PCIe
    NVMe device using sysfs commands where is_added flag was observed as zero
    instead of one while removing device and proc,sys entries are not cleared.
    This causes issue in later device addition with warning message
    "proc_dir_entry" already registered.
    
    Debugging revealed a race condition between the PCI core setting the
    is_added bit in pci_bus_add_device() and the NVMe driver reset work-queue
    setting the is_busmaster bit in pci_set_master().  As these fields are not
    handled atomically, that clears the is_added bit.
    
    Move the is_added bit to a separate private flag variable and use atomic
    functions to set and retrieve the device addition state.  This avoids the
    race because is_added no longer shares a memory location with is_busmaster.
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=200283
    Signed-off-by: Hari Vyas <hari.vyas@broadcom.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Lukas Wunner <lukas@wunner.de>
    Acked-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index ac876e32de4b..611adcd9c169 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -2433,13 +2433,13 @@ int pci_scan_slot(struct pci_bus *bus, int devfn)
 	dev = pci_scan_single_device(bus, devfn);
 	if (!dev)
 		return 0;
-	if (!dev->is_added)
+	if (!pci_dev_is_added(dev))
 		nr++;
 
 	for (fn = next_fn(bus, dev, 0); fn > 0; fn = next_fn(bus, dev, fn)) {
 		dev = pci_scan_single_device(bus, devfn + fn);
 		if (dev) {
-			if (!dev->is_added)
+			if (!pci_dev_is_added(dev))
 				nr++;
 			dev->multifunction = 1;
 		}

commit db89ccbe52c7885644ba578c7771e57620f879b1
Author: Rajat Jain <rajatja@google.com>
Date:   Sat Jun 30 15:07:17 2018 -0500

    PCI/AER: Define aer_stats structure for AER capable devices
    
    Define a structure to hold the AER statistics.  There are 2 groups of
    statistics: dev_* counters that are to be collected for all AER capable
    devices and rootport_* counters that are collected for all (AER capable)
    rootports only.  Allocate and free this structure when device is added or
    released (thus counters survive the lifetime of the device).
    
    Signed-off-by: Rajat Jain <rajatja@google.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index ac876e32de4b..48edd0c9e4bc 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -2064,6 +2064,7 @@ static void pci_configure_device(struct pci_dev *dev)
 
 static void pci_release_capabilities(struct pci_dev *dev)
 {
+	pci_aer_exit(dev);
 	pci_vpd_release(dev);
 	pci_iov_release(dev);
 	pci_free_cap_save_buffers(dev);

commit aa667c6408d20a84c7637420bc3b7aa0abab59a2
Author: James Puthukattukaran <james.puthukattukaran@oracle.com>
Date:   Mon Jul 9 11:31:25 2018 -0400

    PCI: Workaround IDT switch ACS Source Validation erratum
    
    Some IDT switches incorrectly flag an ACS Source Validation error on
    completions for config read requests even though PCIe r4.0, sec 6.12.1.1,
    says that completions are never affected by ACS Source Validation.  Here's
    the text of IDT 89H32H8G3-YC, erratum #36:
    
      Item #36 - Downstream port applies ACS Source Validation to Completions
      Section 6.12.1.1 of the PCI Express Base Specification 3.1 states that
      completions are never affected by ACS Source Validation.  However,
      completions received by a downstream port of the PCIe switch from a
      device that has not yet captured a PCIe bus number are incorrectly
      dropped by ACS Source Validation by the switch downstream port.
    
      Workaround: Issue a CfgWr1 to the downstream device before issuing the
      first CfgRd1 to the device.  This allows the downstream device to capture
      its bus number; ACS Source Validation no longer stops completions from
      being forwarded by the downstream port.  It has been observed that
      Microsoft Windows implements this workaround already; however, some
      versions of Linux and other operating systems may not.
    
    When doing the first config read to probe for a device, if the device is
    behind an IDT switch with this erratum:
    
      1. Disable ACS Source Validation if enabled
      2. Wait for device to become ready to accept config accesses (by using
         the Config Request Retry Status mechanism)
      3. Do a config write to the endpoint
      4. Enable ACS Source Validation (if it was enabled to begin with)
    
    The workaround suggested by IDT is basically only step 3, but we don't know
    when the device is ready to accept config requests.  That means we need to
    do config reads until we receive a non-Config Request Retry Status, which
    means we need to disable ACS SV temporarily.
    
    Signed-off-by: James Puthukattukaran <james.puthukattukaran@oracle.com>
    [bhelgaas: changelog, clean up whitespace, fold in unused variable fix
    from Anders Roxell <anders.roxell@linaro.org>]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Alex Williamson <alex.williamson@redhat.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index ac876e32de4b..7c0c8ab94bcf 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -2156,8 +2156,8 @@ static bool pci_bus_wait_crs(struct pci_bus *bus, int devfn, u32 *l,
 	return true;
 }
 
-bool pci_bus_read_dev_vendor_id(struct pci_bus *bus, int devfn, u32 *l,
-				int timeout)
+bool pci_bus_generic_read_dev_vendor_id(struct pci_bus *bus, int devfn, u32 *l,
+					int timeout)
 {
 	if (pci_bus_read_config_dword(bus, devfn, PCI_VENDOR_ID, l))
 		return false;
@@ -2172,6 +2172,24 @@ bool pci_bus_read_dev_vendor_id(struct pci_bus *bus, int devfn, u32 *l,
 
 	return true;
 }
+
+bool pci_bus_read_dev_vendor_id(struct pci_bus *bus, int devfn, u32 *l,
+				int timeout)
+{
+#ifdef CONFIG_PCI_QUIRKS
+	struct pci_dev *bridge = bus->self;
+
+	/*
+	 * Certain IDT switches have an issue where they improperly trigger
+	 * ACS Source Validation errors on completions for config reads.
+	 */
+	if (bridge && bridge->vendor == PCI_VENDOR_ID_IDT &&
+	    bridge->device == 0x80b5)
+		return pci_idt_bus_quirk(bus, devfn, l, timeout);
+#endif
+
+	return pci_bus_generic_read_dev_vendor_id(bus, devfn, l, timeout);
+}
 EXPORT_SYMBOL(pci_bus_read_dev_vendor_id);
 
 /*

commit 7ce3f912ae0a79e5d738a3ae1f158b281973e849
Author: Sinan Kaya <okaya@codeaurora.org>
Date:   Sat Jun 30 11:24:24 2018 -0400

    PCI: Enable PASID only if entire path supports End-End TLP prefixes
    
    A PCIe endpoint carries the process address space identifier (PASID) in
    the TLP prefix as part of the memory read/write transaction. The address
    information in the TLP is relevant only for a given PASID context.
    
    An IOMMU takes PASID value and the address information from the
    TLP to look up the physical address in the system.
    
    PASID is an End-End TLP Prefix (PCIe r4.0, sec 6.20).  Sec 2.2.10.2 says
    
      It is an error to receive a TLP with an End-End TLP Prefix by a
      Receiver that does not support End-End TLP Prefixes. A TLP in
      violation of this rule is handled as a Malformed TLP. This is a
      reported error associated with the Receiving Port (see Section 6.2).
    
    Prevent error condition by proactively requiring End-End TLP prefix to be
    supported on the entire data path between the endpoint and the root port
    before enabling PASID.
    
    Signed-off-by: Sinan Kaya <okaya@codeaurora.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index ac876e32de4b..4c35c2909d57 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -2042,6 +2042,29 @@ static void pci_configure_ltr(struct pci_dev *dev)
 #endif
 }
 
+static void pci_configure_eetlp_prefix(struct pci_dev *dev)
+{
+#ifdef CONFIG_PCI_PASID
+	struct pci_dev *bridge;
+	u32 cap;
+
+	if (!pci_is_pcie(dev))
+		return;
+
+	pcie_capability_read_dword(dev, PCI_EXP_DEVCAP2, &cap);
+	if (!(cap & PCI_EXP_DEVCAP2_EE_PREFIX))
+		return;
+
+	if (pci_pcie_type(dev) == PCI_EXP_TYPE_ROOT_PORT)
+		dev->eetlp_prefix_path = 1;
+	else {
+		bridge = pci_upstream_bridge(dev);
+		if (bridge && bridge->eetlp_prefix_path)
+			dev->eetlp_prefix_path = 1;
+	}
+#endif
+}
+
 static void pci_configure_device(struct pci_dev *dev)
 {
 	struct hotplug_params hpp;
@@ -2051,6 +2074,7 @@ static void pci_configure_device(struct pci_dev *dev)
 	pci_configure_extended_tags(dev, NULL);
 	pci_configure_relaxed_ordering(dev);
 	pci_configure_ltr(dev);
+	pci_configure_eetlp_prefix(dev);
 
 	memset(&hpp, 0, sizeof(hpp));
 	ret = pci_get_hp_params(dev, &hpp);

commit 11eb0e0e8dea8b97cff972b09cf6fb033b729dff
Author: Sinan Kaya <okaya@codeaurora.org>
Date:   Mon Jun 4 22:16:09 2018 -0400

    PCI: Make early dump functionality generic
    
    Move early dump functionality into common code so that it is available for
    all architectures.  No need to carry arch-specific reads around as the read
    hooks are already initialized by the time pci_setup_device() is getting
    called during scan.
    
    Tested-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Signed-off-by: Sinan Kaya <okaya@codeaurora.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index ac876e32de4b..84034a685f83 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1549,6 +1549,20 @@ static int pci_intx_mask_broken(struct pci_dev *dev)
 	return 0;
 }
 
+static void early_dump_pci_device(struct pci_dev *pdev)
+{
+	u32 value[256 / 4];
+	int i;
+
+	pci_info(pdev, "config space:\n");
+
+	for (i = 0; i < 256; i += 4)
+		pci_read_config_dword(pdev, i, &value[i / 4]);
+
+	print_hex_dump(KERN_INFO, "", DUMP_PREFIX_OFFSET, 16, 1,
+		       value, 256, false);
+}
+
 /**
  * pci_setup_device - Fill in class and map information of a device
  * @dev: the device structure to fill
@@ -1598,6 +1612,9 @@ int pci_setup_device(struct pci_dev *dev)
 	pci_printk(KERN_DEBUG, dev, "[%04x:%04x] type %02x class %#08x\n",
 		   dev->vendor, dev->device, dev->hdr_type, dev->class);
 
+	if (pci_early_dump)
+		early_dump_pci_device(dev);
+
 	/* Need to have dev->class ready */
 	dev->cfg_size = pci_cfg_space_size(dev);
 

commit a7c9d4cf45e1352c3fcca0fabfdf9d7ff708d2ff
Merge: ae08aa13ba4b 37bd62d224c8
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Jun 6 16:10:18 2018 -0500

    Merge branch 'pci/resource'
    
      - add managed interface to get PCI host bridge resources from OF (Jan
        Kiszka)
    
      - add support for unbinding generic PCI host controller (Jan Kiszka)
    
      - fix memory leaks when unbinding generic PCI host controller (Jan Kiszka)
    
    * pci/resource:
      PCI: Enable PCI_DOMAINS along with generic PCI host controller
      PCI: Add support for unbinding the generic PCI host controller
      PCI: Rework of_pci_get_host_bridge_resources() to devm_of_pci_get_host_bridge_resources()
      PCI: Use dev_printk() in of_pci_get_host_bridge_resources()
      PCI: Pass struct device to of_pci_get_host_bridge_resources()
      PCI: Rename of_pci_get_host_bridge_resources() device node parameter
      PCI: Fix devm_pci_alloc_host_bridge() memory leak
      PCI: Make pci_get_new_domain_nr() static

commit f64c14641028d4cbe52a753482ecf7334ec39724
Merge: 5e3165d1a813 e412d63d6025
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Jun 6 16:10:10 2018 -0500

    Merge branch 'pci/hotplug'
    
      - fix use-before-set error in ibmphp (Dan Carpenter)
    
      - fix pciehp timeouts caused by Command Completed errata (Bjorn Helgaas)
    
      - fix refcounting in pnv_php hotplug (Julia Lawall)
    
      - clear pciehp Presence Detect and Data Link Layer Status Changed on
        resume so we don't miss hotplug events (Mika Westerberg)
    
      - only request pciehp control if we support it, so platform can use ACPI
        hotplug otherwise (Mika Westerberg)
    
      - convert SHPC to be builtin only (Mika Westerberg)
    
      - request SHPC control via _OSC if we support it (Mika Westerberg)
    
      - simplify SHPC handoff from firmware (Mika Westerberg)
    
    * pci/hotplug:
      PCI: Improve "partially hidden behind bridge" log message
      PCI: Improve pci_scan_bridge() and pci_scan_bridge_extend() doc
      PCI: Move resource distribution for single bridge outside loop
      PCI: Account for all bridges on bus when distributing bus numbers
      ACPI / hotplug / PCI: Drop unnecessary parentheses
      ACPI / hotplug / PCI: Mark stale PCI devices disconnected
      ACPI / hotplug / PCI: Don't scan bridges managed by native hotplug
      PCI: hotplug: Add hotplug_is_native()
      PCI: shpchp: Add shpchp_is_native()
      PCI: shpchp: Fix AMD POGO identification
      PCI: shpchp: Use dev_printk() for OSHP-related messages
      PCI: shpchp: Remove get_hp_hw_control_from_firmware() wrapper
      PCI: shpchp: Remove acpi_get_hp_hw_control_from_firmware() flags
      PCI: shpchp: Rely on previous _OSC results
      PCI: shpchp: Request SHPC control via _OSC when adding host bridge
      PCI: shpchp: Convert SHPC to be builtin only
      PCI: pciehp: Make pciehp_is_native() stricter
      PCI: pciehp: Rename host->native_hotplug to host->native_pcie_hotplug
      PCI: pciehp: Request control of native hotplug only if supported
      PCI: pciehp: Clear Presence Detect and Data Link Layer Status Changed on resume
      PCI: pnv_php: Add missing of_node_put()
      PCI: pciehp: Add quirk for Command Completed errata
      PCI: Add Qualcomm vendor ID
      PCI: ibmphp: Fix use-before-set in get_max_bus_speed()
    
    # Conflicts:
    #       drivers/acpi/pci_root.c

commit 5e3165d1a813cba0e7fad3880f9d704241e31245
Merge: 8e069da28dfb e5b1db0186bf
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Jun 6 16:10:08 2018 -0500

    Merge branch 'pci/enumeration'
    
      - neaten pci=earlydump output (Andy Shevchenko)
    
      - avoid errors when extended config space inaccessible (Gilles Buloz)
    
      - prevent sysfs disable of device while driver attached (Christoph
        Hellwig)
    
      - use core interface to report PCIe link properties in bnx2x, bnxt_en,
        cxgb4, ixgbe (Bjorn Helgaas)
    
      - remove unused pcie_get_minimum_link() (Bjorn Helgaas)
    
    * pci/enumeration:
      PCI: Remove unused pcie_get_minimum_link()
      ixgbe: Report PCIe link properties with pcie_print_link_status()
      cxgb4: Report PCIe link properties with pcie_print_link_status()
      bnxt_en: Report PCIe link properties with pcie_print_link_status()
      bnx2x: Report PCIe link properties with pcie_print_link_status()
      PCI: Prevent sysfs disable of device while driver is attached
      PCI: Check whether bridges allow access to extended config space
      x86/PCI: Make pci=earlydump output neat

commit e412d63d6025f5713d0e68e710ab5a99f9edc11b
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Thu May 24 13:23:52 2018 -0500

    PCI: Improve "partially hidden behind bridge" log message
    
    pci_scan_child_bus_extend() complains when we assign an unreachable
    secondary bus number to a bridge.  For example, given the topology below:
    
      +-1b.0-[01-39]----00.0-[02-3a]--+-00.0-[03]----00.0
                                      +-01.0-[04-39]--
                                      \-02.0-[3a]----00.0
    
    it logs the following messages:
    
      pci_bus 0000:3a: [bus 3a] partially hidden behind bridge 0000:02 [bus 02-39]
      pci_bus 0000:3a: [bus 3a] partially hidden behind bridge 0000:01 [bus 01-39]
    
    These messages are incorrect (0000:02 is a bus, not a bridge) and
    confusing.  Make the message more understandable:
    
      pci 0000:02:02.0: devices behind bridge are unusable because [bus 3a] cannot be assigned for them
    
    Also, remove the reference to CardBus, because this issue affects all
    varieties of PCI, not just CardBus.
    
    Suggested-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    [bhelgaas: changelog]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index fe5b05bd1887..3100ede3a5bf 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1191,20 +1191,15 @@ static int pci_scan_bridge_extend(struct pci_bus *bus, struct pci_dev *dev,
 		(is_cardbus ? "PCI CardBus %04x:%02x" : "PCI Bus %04x:%02x"),
 		pci_domain_nr(bus), child->number);
 
-	/* Has only triggered on CardBus, fixup is in yenta_socket */
+	/* Check that all devices are accessible */
 	while (bus->parent) {
 		if ((child->busn_res.end > bus->busn_res.end) ||
 		    (child->number > bus->busn_res.end) ||
 		    (child->number < bus->number) ||
 		    (child->busn_res.end < bus->number)) {
-			dev_info(&child->dev, "%pR %s hidden behind%s bridge %s %pR\n",
-				&child->busn_res,
-				(bus->number > child->busn_res.end &&
-				 bus->busn_res.end < child->number) ?
-					"wholly" : "partially",
-				bus->self->transparent ? " transparent" : "",
-				dev_name(&bus->dev),
-				&bus->busn_res);
+			dev_info(&dev->dev, "devices behind bridge are unusable because %pR cannot be assigned for them\n",
+				 &child->busn_res);
+			break;
 		}
 		bus = bus->parent;
 	}

commit 70f7880d2d3175cecc73b0b41fd07e58e6df5fff
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Mon May 28 15:47:56 2018 +0300

    PCI: Improve pci_scan_bridge() and pci_scan_bridge_extend() doc
    
    It is not immediately clear what the two functions actually return so
    add kernel-doc comment explaining it a bit better.
    
    Suggested-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 6d3cae0362c9..fe5b05bd1887 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -999,6 +999,8 @@ static unsigned int pci_scan_child_bus_extend(struct pci_bus *bus,
  * already configured by the BIOS and after we are done with all of
  * them, we proceed to assigning numbers to the remaining buses in
  * order to avoid overlaps between old and new bus numbers.
+ *
+ * Return: New subordinate number covering all buses behind this bridge.
  */
 static int pci_scan_bridge_extend(struct pci_bus *bus, struct pci_dev *dev,
 				  int max, unsigned int available_buses,
@@ -1231,6 +1233,8 @@ static int pci_scan_bridge_extend(struct pci_bus *bus, struct pci_dev *dev,
  * already configured by the BIOS and after we are done with all of
  * them, we proceed to assigning numbers to the remaining buses in
  * order to avoid overlaps between old and new bus numbers.
+ *
+ * Return: New subordinate number covering all buses behind this bridge.
  */
 int pci_scan_bridge(struct pci_bus *bus, struct pci_dev *dev, int max, int pass)
 {

commit 3374c545c27c5350b954d1ab03c880d5502e5eba
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Mon May 28 15:47:50 2018 +0300

    PCI: Account for all bridges on bus when distributing bus numbers
    
    When distributing extra bus number space to hotplug bridges for future
    extension, we don't account for the fact that there might be non-hotplug
    bridges on the bus after the hotplug bridges.  For example:
    
      01:00.0 --+- 02:00.0 (HotPlug-) -- Thunderbolt host controller
                +- 02:01.0 (HotPlug+)
                \- 02:02.0 (HotPlug-) -- xHCI host controller
    
    pci_scan_child_bus_extend() is supposed to distribute the remaining bus
    numbers to the hotplug bridge at 02:01.0, but only after accounting for all
    bridges on bus 02.  Since we don't check whether there's another
    non-hotplug bridge after the hotplug bridge 02:01.0, it may not leave space
    for the non-hotplug bridge:
    
      pci 0000:00:1b.0: PCI bridge to [bus 01-39]  (Root Port)
      pci 0000:01:00.0: PCI bridge to [bus 02-39]
      ...
      pci 0000:02:00.0: PCI bridge to [bus 03]
      pci 0000:02:01.0: PCI bridge to [bus 04]
      pci_bus 0000:04: [bus 04-39] extended by 0x35
      pci_bus 0000:04: bus scan returning with max=39
      pci_bus 0000:04: busn_res: [bus 04-39] end is updated to 39
      pci 0000:02:02.0: scanning [bus 00-00] behind bridge, pass 1
      pci_bus 0000:3a: scanning bus
      pci_bus 0000:3a: bus scan returning with max=3a
      pci_bus 0000:3a: busn_res: [bus 3a] end is updated to 3a
      pci_bus 0000:3a: [bus 3a] partially hidden behind bridge 0000:02 [bus 02-39]
      pci_bus 0000:3a: [bus 3a] partially hidden behind bridge 0000:01 [bus 01-39]
      pci_bus 0000:02: bus scan returning with max=3a
      pci_bus 0000:02: busn_res: [bus 02-39] end can not be updated to 3a
    
    The resulting 'lspci -t' output looks like this:
    
      +-1b.0-[01-39]----00.0-[02-3a]--+-00.0-[03]----00.0
                                 ^^   +-01.0-[04-39]--
                                      \-02.0-[3a]----00.0
                                              ^^
    The xHCI host controller behind 02:02.0 is not usable because it would have
    to be assigned bus 3a, which is not accessible through 00:1b.0.
    
    To fix this, reserve at least one bus for each bridge while scanning
    already configured bridges.  Then use this information in the second
    scan to correct the available extra bus space for hotplug bridges.
    
    After this change the 'lspci -t' output is what is expected:
    
      +-1b.0-[01-39]----00.0-[02-39]--+-00.0-[03]----00.0
                                      +-01.0-[04-38]--
                                      \-02.0-[39]----00.0
    
    The xHCI controller is now on bus 39, where it is usable.
    
    Fixes: 1c02ea810065 ("PCI: Distribute available buses to hotplug-capable bridges")
    Reported-by: Mario Limonciello <mario.limonciello@dell.com>
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    [bhelgaas: changelog]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 91712b2ee2c6..6d3cae0362c9 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -2639,7 +2639,14 @@ static unsigned int pci_scan_child_bus_extend(struct pci_bus *bus,
 	for_each_pci_bridge(dev, bus) {
 		cmax = max;
 		max = pci_scan_bridge_extend(bus, dev, max, 0, 0);
-		used_buses += cmax - max;
+
+		/*
+		 * Reserve one bus for each bridge now to avoid extending
+		 * hotplug bridges too much during the second scan below.
+		 */
+		used_buses++;
+		if (cmax - max > 1)
+			used_buses += cmax - max - 1;
 	}
 
 	/* Scan bridges that need to be reconfigured */
@@ -2662,12 +2669,14 @@ static unsigned int pci_scan_child_bus_extend(struct pci_bus *bus,
 			 * bridges if any.
 			 */
 			buses = available_buses / hotplug_bridges;
-			buses = min(buses, available_buses - used_buses);
+			buses = min(buses, available_buses - used_buses + 1);
 		}
 
 		cmax = max;
 		max = pci_scan_bridge_extend(bus, dev, cmax, buses, 1);
-		used_buses += max - cmax;
+		/* One bus is already accounted so don't add it again */
+		if (max - cmax > 1)
+			used_buses += max - cmax - 1;
 	}
 
 	/*

commit 1df81a6d6e01ff3f351c614c5bc35b49847e1dc5
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Wed May 23 17:40:23 2018 -0500

    PCI: shpchp: Request SHPC control via _OSC when adding host bridge
    
    The SHPC driver now must be builtin (it cannot be a module).  If it is
    present, request SHPC control immediately when adding the ACPI host bridge.
    This is similar to how we handle native PCIe hotplug via pciehp.
    
    Suggested-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    [bhelgaas: split to separate patch]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index eba2b17d2d80..91712b2ee2c6 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -553,6 +553,7 @@ struct pci_host_bridge *pci_alloc_host_bridge(size_t priv)
 	 */
 	bridge->native_aer = 1;
 	bridge->native_pcie_hotplug = 1;
+	bridge->native_shpc_hotplug = 1;
 	bridge->native_pme = 1;
 
 	return bridge;

commit 9310f0dc1c6430ca9e370a8341bea9f5dc85f40b
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Wed May 23 17:22:19 2018 -0500

    PCI: pciehp: Rename host->native_hotplug to host->native_pcie_hotplug
    
    Rename host->native_hotplug to host->native_pcie_hotplug to make room for a
    similar flag for SHPC hotplug.
    
    Suggested-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    [bhelgaas: split to separate patch]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index ac91b6fd0bcd..eba2b17d2d80 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -552,7 +552,7 @@ struct pci_host_bridge *pci_alloc_host_bridge(size_t priv)
 	 * OS from interfering.
 	 */
 	bridge->native_aer = 1;
-	bridge->native_hotplug = 1;
+	bridge->native_pcie_hotplug = 1;
 	bridge->native_pme = 1;
 
 	return bridge;

commit 3bbce531788719749520f28052cabdef16af6b16
Author: Jan Kiszka <jan.kiszka@siemens.com>
Date:   Tue May 15 11:07:01 2018 +0200

    PCI: Fix devm_pci_alloc_host_bridge() memory leak
    
    Fix a memory leak by freeing the PCI resource list in
    devm_pci_release_host_bridge_dev().
    
    Fixes: 5c3f18cce083 ("PCI: Add devm_pci_alloc_host_bridge() interface")
    Signed-off-by: Jan Kiszka <jan.kiszka@siemens.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index ac91b6fd0bcd..eccf204c9160 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -526,12 +526,14 @@ static void devm_pci_release_host_bridge_dev(struct device *dev)
 
 	if (bridge->release_fn)
 		bridge->release_fn(bridge);
+
+	pci_free_resource_list(&bridge->windows);
 }
 
 static void pci_release_host_bridge_dev(struct device *dev)
 {
 	devm_pci_release_host_bridge_dev(dev);
-	pci_free_host_bridge(to_pci_host_bridge(dev));
+	kfree(to_pci_host_bridge(dev));
 }
 
 struct pci_host_bridge *pci_alloc_host_bridge(size_t priv)

commit 17e8f0d4cee2bf50c2764bb4318284ce16152c5f
Author: Gilles Buloz <Gilles.Buloz@kontron.com>
Date:   Thu May 3 15:21:44 2018 -0500

    PCI: Check whether bridges allow access to extended config space
    
    Even if a device supports extended config space, i.e., it is a PCI-X Mode 2
    or a PCI Express device, the extended space may not be accessible if
    there's a conventional PCI bus in the path to it.
    
    We currently figure that out in pci_cfg_space_size() by reading the first
    dword of extended config space.  On most platforms that returns ~0 data if
    the space is inaccessible, but it may set error bits in PCI status
    registers, and on some platforms it causes exceptions that we currently
    don't recover from.
    
    For example, a PCIe-to-conventional PCI bridge treats config transactions
    with a non-zero Extended Register Address as an Unsupported Request on PCIe
    and a received Master-Abort on the destination bus (see PCI Express to
    PCI/PCI-X Bridge spec, r1.0, sec 4.1.3).
    
    A sample case is a LS1043A CPU (NXP QorIQ Layerscape) platform with the
    following bus topology:
    
      LS1043 PCIe Root Port
        -> PEX8112 PCIe-to-PCI bridge (doesn't support ext cfg on PCI side)
          -> PMC slot connector (for legacy PMC modules)
    
    With a PMC module topology as follows:
    
      PMC connector
        -> PCI-to-PCIe bridge
          -> PCIe switch (4 ports)
            -> 4 PCIe devices (one on each port)
    
    The PCIe devices on the PMC module support extended config space, but we
    can't reach it because the PEX8112 can't generate accesses to the extended
    space on its secondary bus.  Attempts to access it cause Unsupported
    Request errors, which result in synchronous aborts on this platform.
    
    To avoid these errors, check whether bridges are capable of generating
    extended config space addresses on their secondary interfaces.  If they
    can't, we restrict devices below the bridge to only the 256-byte
    PCI-compatible config space.
    
    Signed-off-by: Gilles Buloz <gilles.buloz@kontron.com>
    [bhelgaas: changelog, rework patch so bus_flags testing is all in
    pci_bridge_child_ext_cfg_accessible()]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index ac91b6fd0bcd..dcc41de1c2c8 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -882,6 +882,45 @@ static int pci_register_host_bridge(struct pci_host_bridge *bridge)
 	return err;
 }
 
+static bool pci_bridge_child_ext_cfg_accessible(struct pci_dev *bridge)
+{
+	int pos;
+	u32 status;
+
+	/*
+	 * If extended config space isn't accessible on a bridge's primary
+	 * bus, we certainly can't access it on the secondary bus.
+	 */
+	if (bridge->bus->bus_flags & PCI_BUS_FLAGS_NO_EXTCFG)
+		return false;
+
+	/*
+	 * PCIe Root Ports and switch ports are PCIe on both sides, so if
+	 * extended config space is accessible on the primary, it's also
+	 * accessible on the secondary.
+	 */
+	if (pci_is_pcie(bridge) &&
+	    (pci_pcie_type(bridge) == PCI_EXP_TYPE_ROOT_PORT ||
+	     pci_pcie_type(bridge) == PCI_EXP_TYPE_UPSTREAM ||
+	     pci_pcie_type(bridge) == PCI_EXP_TYPE_DOWNSTREAM))
+		return true;
+
+	/*
+	 * For the other bridge types:
+	 *   - PCI-to-PCI bridges
+	 *   - PCIe-to-PCI/PCI-X forward bridges
+	 *   - PCI/PCI-X-to-PCIe reverse bridges
+	 * extended config space on the secondary side is only accessible
+	 * if the bridge supports PCI-X Mode 2.
+	 */
+	pos = pci_find_capability(bridge, PCI_CAP_ID_PCIX);
+	if (!pos)
+		return false;
+
+	pci_read_config_dword(bridge, pos + PCI_X_STATUS, &status);
+	return status & (PCI_X_STATUS_266MHZ | PCI_X_STATUS_533MHZ);
+}
+
 static struct pci_bus *pci_alloc_child_bus(struct pci_bus *parent,
 					   struct pci_dev *bridge, int busnr)
 {
@@ -923,6 +962,16 @@ static struct pci_bus *pci_alloc_child_bus(struct pci_bus *parent,
 	pci_set_bus_of_node(child);
 	pci_set_bus_speed(child);
 
+	/*
+	 * Check whether extended config space is accessible on the child
+	 * bus.  Note that we currently assume it is always accessible on
+	 * the root bus.
+	 */
+	if (!pci_bridge_child_ext_cfg_accessible(bridge)) {
+		child->bus_flags |= PCI_BUS_FLAGS_NO_EXTCFG;
+		pci_info(child, "extended config space not accessible\n");
+	}
+
 	/* Set up default resource pointers and names */
 	for (i = 0; i < PCI_BRIDGE_RESOURCE_NUM; i++) {
 		child->resource[i] = &bridge->resource[PCI_BRIDGE_RESOURCES+i];
@@ -1393,6 +1442,9 @@ int pci_cfg_space_size(struct pci_dev *dev)
 	u32 status;
 	u16 class;
 
+	if (dev->bus->bus_flags & PCI_BUS_FLAGS_NO_EXTCFG)
+		return PCI_CFG_SPACE_SIZE;
+
 	class = dev->class >> 8;
 	if (class == PCI_CLASS_BRIDGE_HOST)
 		return pci_cfg_space_size_ext(dev);

commit af8bb9f89838249872240f258e67774ccbcc5970
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Apr 17 10:58:09 2018 -0500

    PCI/ACPI: Request LTR control from platform before using it
    
    Per the PCI Firmware spec r3.2, sec 4.5, an ACPI-based OS should use _OSC
    to request control of Latency Tolerance Reporting (LTR) before using it.
    
    Request control of LTR, and if the platform does not grant control, don't
    use it.
    
    N.B. If the hardware supports LTR and the ASPM L1.2 substate but the BIOS
    doesn't support LTR in _OSC, we previously would enable ASPM L1.2.  This
    patch will prevent us from enabling ASPM L1.2 in that case.  It does not
    prevent us from enabling PCI-PM L1.2, since that doesn't depend on LTR.
    See PCIe r40, sec 5.5.1, for the L1 PM substate entry conditions.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index ac91b6fd0bcd..cc1688d75664 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -554,6 +554,7 @@ struct pci_host_bridge *pci_alloc_host_bridge(size_t priv)
 	bridge->native_aer = 1;
 	bridge->native_hotplug = 1;
 	bridge->native_pme = 1;
+	bridge->native_ltr = 1;
 
 	return bridge;
 }
@@ -1954,9 +1955,13 @@ static void pci_configure_relaxed_ordering(struct pci_dev *dev)
 static void pci_configure_ltr(struct pci_dev *dev)
 {
 #ifdef CONFIG_PCIEASPM
+	struct pci_host_bridge *host = pci_find_host_bridge(dev->bus);
 	u32 cap;
 	struct pci_dev *bridge;
 
+	if (!host->native_ltr)
+		return;
+
 	if (!pci_is_pcie(dev))
 		return;
 

commit 3c0d551e02b2590fa71a1354f2f1994551a33315
Merge: 19fd08b85bc7 5f7644190986
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Apr 6 18:31:06 2018 -0700

    Merge tag 'pci-v4.17-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI updates from Bjorn Helgaas:
    
     - move pci_uevent_ers() out of pci.h (Michael Ellerman)
    
     - skip ASPM common clock warning if BIOS already configured it (Sinan
       Kaya)
    
     - fix ASPM Coverity warning about threshold_ns (Gustavo A. R. Silva)
    
     - remove last user of pci_get_bus_and_slot() and the function itself
       (Sinan Kaya)
    
     - add decoding for 16 GT/s link speed (Jay Fang)
    
     - add interfaces to get max link speed and width (Tal Gilboa)
    
     - add pcie_bandwidth_capable() to compute max supported link bandwidth
       (Tal Gilboa)
    
     - add pcie_bandwidth_available() to compute bandwidth available to
       device (Tal Gilboa)
    
     - add pcie_print_link_status() to log link speed and whether it's
       limited (Tal Gilboa)
    
     - use PCI core interfaces to report when device performance may be
       limited by its slot instead of doing it in each driver (Tal Gilboa)
    
     - fix possible cpqphp NULL pointer dereference (Shawn Lin)
    
     - rescan more of the hierarchy on ACPI hotplug to fix Thunderbolt/xHCI
       hotplug (Mika Westerberg)
    
     - add support for PCI I/O port space that's neither directly accessible
       via CPU in/out instructions nor directly mapped into CPU physical
       memory space. This is fairly intrusive and includes minor changes to
       interfaces used for I/O space on most platforms (Zhichang Yuan, John
       Garry)
    
     - add support for HiSilicon Hip06/Hip07 LPC I/O space (Zhichang Yuan,
       John Garry)
    
     - use PCI_EXP_DEVCTL2_COMP_TIMEOUT in rapidio/tsi721 (Bjorn Helgaas)
    
     - remove possible NULL pointer dereference in of_pci_bus_find_domain_nr()
       (Shawn Lin)
    
     - report quirk timings with dev_info (Bjorn Helgaas)
    
     - report quirks that take longer than 10ms (Bjorn Helgaas)
    
     - add and use Altera Vendor ID (Johannes Thumshirn)
    
     - tidy Makefiles and comments (Bjorn Helgaas)
    
     - don't set up INTx if MSI or MSI-X is enabled to align cris, frv,
       ia64, and mn10300 with x86 (Bjorn Helgaas)
    
     - move pcieport_if.h to drivers/pci/pcie/ to encapsulate it (Frederick
       Lawler)
    
     - merge pcieport_if.h into portdrv.h (Bjorn Helgaas)
    
     - move workaround for BIOS PME issue from portdrv to PCI core (Bjorn
       Helgaas)
    
     - completely disable portdrv with "pcie_ports=compat" (Bjorn Helgaas)
    
     - remove portdrv link order dependency (Bjorn Helgaas)
    
     - remove support for unused VC portdrv service (Bjorn Helgaas)
    
     - simplify portdrv feature permission checking (Bjorn Helgaas)
    
     - remove "pcie_hp=nomsi" parameter (use "pci=nomsi" instead) (Bjorn
       Helgaas)
    
     - remove unnecessary "pcie_ports=auto" parameter (Bjorn Helgaas)
    
     - use cached AER capability offset (Frederick Lawler)
    
     - don't enable DPC if BIOS hasn't granted AER control (Mika Westerberg)
    
     - rename pcie-dpc.c to dpc.c (Bjorn Helgaas)
    
     - use generic pci_mmap_resource_range() instead of powerpc and xtensa
       arch-specific versions (David Woodhouse)
    
     - support arbitrary PCI host bridge offsets on sparc (Yinghai Lu)
    
     - remove System and Video ROM reservations on sparc (Bjorn Helgaas)
    
     - probe for device reset support during enumeration instead of runtime
       (Bjorn Helgaas)
    
     - add ACS quirk for Ampere (née APM) root ports (Feng Kan)
    
     - add function 1 DMA alias quirk for Marvell 88SE9220 (Thomas
       Vincent-Cross)
    
     - protect device restore with device lock (Sinan Kaya)
    
     - handle failure of FLR gracefully (Sinan Kaya)
    
     - handle CRS (config retry status) after device resets (Sinan Kaya)
    
     - skip various config reads for SR-IOV VFs as an optimization
       (KarimAllah Ahmed)
    
     - consolidate VPD code in vpd.c (Bjorn Helgaas)
    
     - add Tegra dependency on PCI_MSI_IRQ_DOMAIN (Arnd Bergmann)
    
     - add DT support for R-Car r8a7743 (Biju Das)
    
     - fix a PCI_EJECT vs PCI_BUS_RELATIONS race condition in Hyper-V host
       bridge driver that causes a general protection fault (Dexuan Cui)
    
     - fix Hyper-V host bridge hang in MSI setup on 1-vCPU VMs with SR-IOV
       (Dexuan Cui)
    
     - fix Hyper-V host bridge hang when ejecting a VF before setting up MSI
       (Dexuan Cui)
    
     - make several structures static (Fengguang Wu)
    
     - increase number of MSI IRQs supported by Synopsys DesignWare bridges
       from 32 to 256 (Gustavo Pimentel)
    
     - implemented multiplexed IRQ domain API and remove obsolete MSI IRQ
       API from DesignWare drivers (Gustavo Pimentel)
    
     - add Tegra power management support (Manikanta Maddireddy)
    
     - add Tegra loadable module support (Manikanta Maddireddy)
    
     - handle 64-bit BARs correctly in endpoint support (Niklas Cassel)
    
     - support optional regulator for HiSilicon STB (Shawn Guo)
    
     - use regulator bulk API for Qualcomm apq8064 (Srinivas Kandagatla)
    
     - support power supplies for Qualcomm msm8996 (Srinivas Kandagatla)
    
    * tag 'pci-v4.17-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (123 commits)
      MAINTAINERS: Add John Garry as maintainer for HiSilicon LPC driver
      HISI LPC: Add ACPI support
      ACPI / scan: Do not enumerate Indirect IO host children
      ACPI / scan: Rename acpi_is_serial_bus_slave() for more general use
      HISI LPC: Support the LPC host on Hip06/Hip07 with DT bindings
      of: Add missing I/O range exception for indirect-IO devices
      PCI: Apply the new generic I/O management on PCI IO hosts
      PCI: Add fwnode handler as input param of pci_register_io_range()
      PCI: Remove __weak tag from pci_register_io_range()
      MAINTAINERS: Add missing /drivers/pci/cadence directory entry
      fm10k: Report PCIe link properties with pcie_print_link_status()
      net/mlx5e: Use pcie_bandwidth_available() to compute bandwidth
      net/mlx5: Report PCIe link properties with pcie_print_link_status()
      net/mlx4_core: Report PCIe link properties with pcie_print_link_status()
      PCI: Add pcie_print_link_status() to log link speed and whether it's limited
      PCI: Add pcie_bandwidth_available() to compute bandwidth available to device
      misc: pci_endpoint_test: Handle 64-bit BARs properly
      PCI: designware-ep: Make dw_pcie_ep_reset_bar() handle 64-bit BARs properly
      PCI: endpoint: Make sure that BAR_5 does not have 64-bit flag set when clearing
      PCI: endpoint: Make epc->ops->clear_bar()/pci_epc_clear_bar() take struct *epf_bar
      ...

commit a4b88505ac1f77cf4fa75fa6845fe95aa43aac9e
Merge: 0eb6de7872d9 619e6f340cec
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Apr 4 13:28:26 2018 -0500

    Merge branch 'pci/virtualization'
    
      - probe for device reset support during enumeration instead of runtime
        (Bjorn Helgaas)
    
      - add ACS quirk for Ampere (née APM) root ports (Feng Kan)
    
      - add function 1 DMA alias quirk for Marvell 88SE9220 (Thomas
        Vincent-Cross)
    
      - protect device restore with device lock (Sinan Kaya)
    
      - handle failure of FLR gracefully (Sinan Kaya)
    
      - handle CRS (config retry status) after device resets (Sinan Kaya)
    
      - skip various config reads for SR-IOV VFs as an optimization (KarimAllah
        Ahmed)
    
    * pci/virtualization:
      PCI/IOV: Add missing prototypes for powerpc pcibios interfaces
      PCI/IOV: Use VF0 cached config registers for other VFs
      PCI/IOV: Skip BAR sizing for VFs
      PCI/IOV: Skip INTx config reads for VFs
      PCI: Wait for device to become ready after secondary bus reset
      PCI: Add a return type for pci_reset_bridge_secondary_bus()
      PCI: Wait for device to become ready after a power management reset
      PCI: Rename pci_flr_wait() to pci_dev_wait() and make it generic
      PCI: Handle FLR failure and allow other reset types
      PCI: Protect restore with device lock to be consistent
      PCI: Add function 1 DMA alias quirk for Marvell 88SE9220
      PCI: Add ACS quirk for Ampere root ports
      PCI: Remove redundant probes for device reset support
      PCI: Probe for device reset support during enumeration
    
    Conflicts:
            include/linux/pci.h

commit 64ae499cf2eece26bc395184aa2c9a18aa49d199
Merge: ac30aa596996 e02602bd7625
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Apr 4 13:27:58 2018 -0500

    Merge branch 'pci/portdrv'
    
      - move pcieport_if.h to drivers/pci/pcie/ to encapsulate it (Frederick
        Lawler)
    
      - merge pcieport_if.h into portdrv.h (Bjorn Helgaas)
    
      - move workaround for BIOS PME issue from portdrv to PCI core (Bjorn
        Helgaas)
    
      - completely disable portdrv with "pcie_ports=compat" (Bjorn Helgaas)
    
      - remove portdrv link order dependency (Bjorn Helgaas)
    
      - remove support for unused VC portdrv service (Bjorn Helgaas)
    
      - simplify portdrv feature permission checking (Bjorn Helgaas)
    
      - remove "pcie_hp=nomsi" parameter (use "pci=nomsi" instead) (Bjorn
        Helgaas)
    
      - remove unnecessary "pcie_ports=auto" parameter (Bjorn Helgaas)
    
      - use cached AER capability offset (Frederick Lawler)
    
      - don't enable DPC if BIOS hasn't granted AER control (Mika Westerberg)
    
      - rename pcie-dpc.c to dpc.c (Bjorn Helgaas)
    
    * pci/portdrv:
      PCI/DPC: Rename from pcie-dpc.c to dpc.c
      PCI/DPC: Do not enable DPC if AER control is not allowed by the BIOS
      PCI/AER: Use cached AER Capability offset
      PCI/portdrv: Rename and reverse sense of pcie_ports_auto
      PCI/portdrv: Encapsulate pcie_ports_auto inside the port driver
      PCI/portdrv: Remove unnecessary "pcie_ports=auto" parameter
      PCI/portdrv: Remove "pcie_hp=nomsi" kernel parameter
      PCI/portdrv: Remove unnecessary include of <linux/pci-aspm.h>
      PCI/portdrv: Simplify PCIe feature permission checking
      PCI/portdrv: Remove unused PCIE_PORT_SERVICE_VC
      PCI/portdrv: Remove pcie_port_bus_type link order dependency
      PCI/portdrv: Disable port driver in compat mode
      PCI/PM: Clear PCIe PME Status bit for Root Complex Event Collectors
      PCI/PM: Clear PCIe PME Status bit in core, not PCIe port driver
      PCI/PM: Move pcie_clear_root_pme_status() to core
      PCI/portdrv: Merge pcieport_if.h into portdrv.h
      PCI/portdrv: Move pcieport_if.h to drivers/pci/pcie/
    
    Conflicts:
            drivers/pci/pcie/Makefile
            drivers/pci/pcie/portdrv.h

commit 43b90eaed57679731ae340a47cef49e59a321c2e
Merge: 3da1b6174ba3 ad32eb2df801
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Apr 4 13:27:45 2018 -0500

    Merge branch 'pci/misc'
    
      - use PCI_EXP_DEVCTL2_COMP_TIMEOUT in rapidio/tsi721 (Bjorn Helgaas)
    
      - remove possible NULL pointer dereference in of_pci_bus_find_domain_nr()
        (Shawn Lin)
    
      - report quirk timings with dev_info (Bjorn Helgaas)
    
      - report quirks that take longer than 10ms (Bjorn Helgaas)
    
      - add and use Altera Vendor ID (Johannes Thumshirn)
    
      - tidy Makefiles and comments (Bjorn Helgaas)
    
    * pci/misc:
      PCI: Always define the of_node helpers
      PCI: Tidy comments
      PCI: Tidy Makefiles
      mcb: Add Altera PCI ID to mcb-pci
      PCI: Add Altera vendor ID
      PCI: Report quirks that take more than 10ms
      PCI: Report quirk timings with pci_info() instead of pr_debug()
      PCI: Fix NULL pointer dereference in of_pci_bus_find_domain_nr()
      rapidio/tsi721: use PCI_EXP_DEVCTL2_COMP_TIMEOUT macro

commit cf0921bea66c55600a48009597caa5fcb1419748
Author: KarimAllah Ahmed <karahmed@amazon.de>
Date:   Mon Mar 19 21:06:00 2018 +0100

    PCI/IOV: Use VF0 cached config registers for other VFs
    
    Cache some config data from VF0 and use it for all other VFs instead of
    reading it from the config space of each VF.  We assume these items are the
    same across all associated VFs:
    
       Revision ID
       Class Code
       Subsystem Vendor ID
       Subsystem ID
    
    This is an optimization when enabling SR-IOV on a device with many VFs.
    
    Signed-off-by: KarimAllah Ahmed <karahmed@amazon.de>
    [bhelgaas: changelog, simplify comments, remove unused "device", test
    CONFIG_PCI_IOV instead of CONFIG_PCI_ATS, rename functions]
    Signed-off-by: Bjorn Helgaas <helgaas@kernel.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 9f80b904bf76..708094f720fd 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1400,6 +1400,43 @@ int pci_cfg_space_size(struct pci_dev *dev)
 	return PCI_CFG_SPACE_SIZE;
 }
 
+static u32 pci_class(struct pci_dev *dev)
+{
+	u32 class;
+
+#ifdef CONFIG_PCI_IOV
+	if (dev->is_virtfn)
+		return dev->physfn->sriov->class;
+#endif
+	pci_read_config_dword(dev, PCI_CLASS_REVISION, &class);
+	return class;
+}
+
+static void pci_subsystem_ids(struct pci_dev *dev, u16 *vendor, u16 *device)
+{
+#ifdef CONFIG_PCI_IOV
+	if (dev->is_virtfn) {
+		*vendor = dev->physfn->sriov->subsystem_vendor;
+		*device = dev->physfn->sriov->subsystem_device;
+		return;
+	}
+#endif
+	pci_read_config_word(dev, PCI_SUBSYSTEM_VENDOR_ID, vendor);
+	pci_read_config_word(dev, PCI_SUBSYSTEM_ID, device);
+}
+
+static u8 pci_hdr_type(struct pci_dev *dev)
+{
+	u8 hdr_type;
+
+#ifdef CONFIG_PCI_IOV
+	if (dev->is_virtfn)
+		return dev->physfn->sriov->hdr_type;
+#endif
+	pci_read_config_byte(dev, PCI_HEADER_TYPE, &hdr_type);
+	return hdr_type;
+}
+
 #define LEGACY_IO_RESOURCE	(IORESOURCE_IO | IORESOURCE_PCI_FIXED)
 
 static void pci_msi_setup_pci_dev(struct pci_dev *dev)
@@ -1465,8 +1502,7 @@ int pci_setup_device(struct pci_dev *dev)
 	struct pci_bus_region region;
 	struct resource *res;
 
-	if (pci_read_config_byte(dev, PCI_HEADER_TYPE, &hdr_type))
-		return -EIO;
+	hdr_type = pci_hdr_type(dev);
 
 	dev->sysdata = dev->bus->sysdata;
 	dev->dev.parent = dev->bus->bridge;
@@ -1488,7 +1524,8 @@ int pci_setup_device(struct pci_dev *dev)
 		     dev->bus->number, PCI_SLOT(dev->devfn),
 		     PCI_FUNC(dev->devfn));
 
-	pci_read_config_dword(dev, PCI_CLASS_REVISION, &class);
+	class = pci_class(dev);
+
 	dev->revision = class & 0xff;
 	dev->class = class >> 8;		    /* upper 3 bytes */
 
@@ -1528,8 +1565,8 @@ int pci_setup_device(struct pci_dev *dev)
 			goto bad;
 		pci_read_irq(dev);
 		pci_read_bases(dev, 6, PCI_ROM_ADDRESS);
-		pci_read_config_word(dev, PCI_SUBSYSTEM_VENDOR_ID, &dev->subsystem_vendor);
-		pci_read_config_word(dev, PCI_SUBSYSTEM_ID, &dev->subsystem_device);
+
+		pci_subsystem_ids(dev, &dev->subsystem_vendor, &dev->subsystem_device);
 
 		/*
 		 * Do the ugly legacy mode stuff here rather than broken chip

commit 02bfeb484230dfd073148a17253aeb1717ce769c
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Mar 9 11:21:25 2018 -0600

    PCI/portdrv: Simplify PCIe feature permission checking
    
    Some PCIe features (AER, DPC, hotplug, PME) can be managed by either the
    platform firmware or the OS, so the host bridge driver may have to request
    permission from the platform before using them.  On ACPI systems, this is
    done by negotiate_os_control() in acpi_pci_root_add().
    
    The PCIe port driver later uses pcie_port_platform_notify() and
    pcie_port_acpi_setup() to figure out whether it can use these features.
    But all we need is a single bit for each service, so these interfaces are
    needlessly complicated.
    
    Simplify this by adding bits in the struct pci_host_bridge to show when the
    OS has permission to use each feature:
    
      + unsigned int native_aer:1;       /* OS may use PCIe AER */
      + unsigned int native_hotplug:1;   /* OS may use PCIe hotplug */
      + unsigned int native_pme:1;       /* OS may use PCIe PME */
    
    These are set when we create a host bridge, and the host bridge driver can
    clear the bits corresponding to any feature the platform doesn't want us to
    use.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index ef5377438a1e..a00de697a970 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -540,6 +540,16 @@ struct pci_host_bridge *pci_alloc_host_bridge(size_t priv)
 	INIT_LIST_HEAD(&bridge->windows);
 	bridge->dev.release = pci_release_host_bridge_dev;
 
+	/*
+	 * We assume we can manage these PCIe features.  Some systems may
+	 * reserve these for use by the platform itself, e.g., an ACPI BIOS
+	 * may implement its own AER handling and use _OSC to prevent the
+	 * OS from interfering.
+	 */
+	bridge->native_aer = 1;
+	bridge->native_hotplug = 1;
+	bridge->native_pme = 1;
+
 	return bridge;
 }
 EXPORT_SYMBOL(pci_alloc_host_bridge);

commit 1acfb9b7ee0b1881bb8e875b6757976e48293ec4
Author: Jay Fang <f.fangjian@huawei.com>
Date:   Mon Mar 12 17:13:32 2018 +0800

    PCI: Add decoding for 16 GT/s link speed
    
    PCIe 4.0 defines the 16.0 GT/s link speed.  Links can run at that speed
    without any Linux changes, but previously their sysfs "max_link_speed" and
    "current_link_speed" files contained "Unknown speed", not the expected
    "16.0 GT/s".
    
    Add decoding for the new 16 GT/s link speed.
    
    Signed-off-by: Jay Fang <f.fangjian@huawei.com>
    [bhelgaas: add PCI_EXP_LNKCAP2_SLS_16_0GB]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Dongdong Liu <liudongdong3@huawei.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index ef5377438a1e..86bf045f3d59 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -592,7 +592,7 @@ const unsigned char pcie_link_speed[] = {
 	PCIE_SPEED_2_5GT,		/* 1 */
 	PCIE_SPEED_5_0GT,		/* 2 */
 	PCIE_SPEED_8_0GT,		/* 3 */
-	PCI_SPEED_UNKNOWN,		/* 4 */
+	PCIE_SPEED_16_0GT,		/* 4 */
 	PCI_SPEED_UNKNOWN,		/* 5 */
 	PCI_SPEED_UNKNOWN,		/* 6 */
 	PCI_SPEED_UNKNOWN,		/* 7 */

commit bf4447fd1cb6158b60bd60a79998e1d029d31e68
Author: KarimAllah Ahmed <karahmed@amazon.de>
Date:   Sat Mar 3 05:33:10 2018 +0100

    PCI/IOV: Skip BAR sizing for VFs
    
    Per PCIe r4.0, sec 9.3.4.1.11, the BAR registers in VF config space are all
    RO Zero, so skip sizing them.
    
    This is an optimization when enabling SR-IOV on a device with many VFs.
    
    Suggested-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: KarimAllah Ahmed <karahmed@amazon.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index a1cddca37793..9f80b904bf76 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -329,6 +329,10 @@ static void pci_read_bases(struct pci_dev *dev, unsigned int howmany, int rom)
 	if (dev->non_compliant_bars)
 		return;
 
+	/* Per PCIe r4.0, sec 9.3.4.1.11, the VF BARs are all RO Zero */
+	if (dev->is_virtfn)
+		return;
+
 	for (pos = 0; pos < howmany; pos++) {
 		struct resource *res = &dev->resource[pos];
 		reg = PCI_BASE_ADDRESS_0 + (pos << 2);

commit df62ab5e0f75608919df7442654b0fab78246b7b
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Mar 9 16:36:33 2018 -0600

    PCI: Tidy comments
    
    Remove pointless comments that tell us the file name, remove blank line
    comments, follow multi-line comment conventions.  No functional change
    intended.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index ef5377438a1e..7762ba4d9220 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * probe.c - PCI detection and setup code
+ * PCI detection and setup code
  */
 
 #include <linux/kernel.h>

commit 690f4304104f37e473bd5e43fc5247f5cd35b225
Author: Jan Kiszka <jan.kiszka@siemens.com>
Date:   Wed Mar 7 08:39:13 2018 +0100

    PCI: Scan all functions when running over Jailhouse
    
    Per PCIe r4.0, sec 7.5.1.1.9, multi-function devices are required to have a
    function 0.  Therefore, Linux scans for devices at function 0 (devfn
    0/8/16/...) and only scans for other functions if function 0 has its
    Multi-Function Device bit set or ARI or SR-IOV indicate there are more
    functions.
    
    The Jailhouse hypervisor may pass individual functions of a multi-function
    device to a guest without passing function 0, which means a Linux guest
    won't find them.
    
    Change Linux PCI probing so it scans all function numbers when running as a
    guest over Jailhouse.
    
    This is technically prohibited by the spec, so it is possible that PCI
    devices without the Multi-Function Device bit set may have unexpected
    behavior in response to this probe.
    
    Originally-by: Benedikt Spranger <b.spranger@linutronix.de>
    Signed-off-by: Jan Kiszka <jan.kiszka@siemens.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: jailhouse-dev@googlegroups.com
    Cc: Benedikt Spranger <b.spranger@linutronix.de>
    Cc: linux-pci@vger.kernel.org
    Cc: virtualization@lists.linux-foundation.org
    Link: https://lkml.kernel.org/r/06e279b2a3e06cf6689ab3975f8ab592bba02362.1520408357.git.jan.kiszka@siemens.com

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index ef5377438a1e..3c365dc996e7 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -16,6 +16,7 @@
 #include <linux/pci-aspm.h>
 #include <linux/aer.h>
 #include <linux/acpi.h>
+#include <linux/hypervisor.h>
 #include <linux/irqdomain.h>
 #include <linux/pm_runtime.h>
 #include "pci.h"
@@ -2518,14 +2519,29 @@ static unsigned int pci_scan_child_bus_extend(struct pci_bus *bus,
 {
 	unsigned int used_buses, normal_bridges = 0, hotplug_bridges = 0;
 	unsigned int start = bus->busn_res.start;
-	unsigned int devfn, cmax, max = start;
+	unsigned int devfn, fn, cmax, max = start;
 	struct pci_dev *dev;
+	int nr_devs;
 
 	dev_dbg(&bus->dev, "scanning bus\n");
 
 	/* Go find them, Rover! */
-	for (devfn = 0; devfn < 0x100; devfn += 8)
-		pci_scan_slot(bus, devfn);
+	for (devfn = 0; devfn < 256; devfn += 8) {
+		nr_devs = pci_scan_slot(bus, devfn);
+
+		/*
+		 * The Jailhouse hypervisor may pass individual functions of a
+		 * multi-function device to a guest without passing function 0.
+		 * Look for them as well.
+		 */
+		if (jailhouse_paravirt() && nr_devs == 0) {
+			for (fn = 1; fn < 8; fn++) {
+				dev = pci_scan_single_device(bus, devfn + fn);
+				if (dev)
+					dev->multifunction = 1;
+			}
+		}
+	}
 
 	/* Reserve buses for SR-IOV capability */
 	used_buses = pci_iov_bus_range(bus);

commit be20f6b063f51cd77d071b803ee24f23200dc559
Author: KarimAllah Ahmed <karahmed@amazon.de>
Date:   Wed Jan 17 19:30:29 2018 +0100

    PCI/IOV: Skip INTx config reads for VFs
    
    Per PCIe r4.0, sec 9.2.1.4, VFs can not implement INTX, and their Interrupt
    Line and Interrupt Pin registers must be RO Zero.  Some devices have
    thousands of VFs, so skip reading the registers as an optimization.
    
    Signed-off-by: KarimAllah Ahmed <karahmed@amazon.de>
    Signed-off-by: Jan H. Schönherr <jschoenh@amazon.de>
    [bhelgaas: changelog, comment]
    Signed-off-by: Bjorn Helgaas <helgaas@kernel.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 489660d0d384..a1cddca37793 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1230,6 +1230,13 @@ static void pci_read_irq(struct pci_dev *dev)
 {
 	unsigned char irq;
 
+	/* VFs are not allowed to use INTx, so skip the config reads */
+	if (dev->is_virtfn) {
+		dev->pin = 0;
+		dev->irq = 0;
+		return;
+	}
+
 	pci_read_config_byte(dev, PCI_INTERRUPT_PIN, &irq);
 	dev->pin = irq;
 	if (irq)

commit 5b0764cac9f1b70a6704b0e546be67c24cc05517
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Feb 16 10:55:38 2018 -0600

    PCI: Probe for device reset support during enumeration
    
    Previously we called pci_probe_reset_function() in this path:
    
      pci_sysfs_init                              # late_initcall
        for_each_pci_dev(dev)
          pci_create_sysfs_dev_files(dev)
            pci_create_capabilities_sysfs(dev)
              pci_probe_reset_function
                pci_dev_specific_reset
                pcie_has_flr
                  pcie_capability_read_dword
    
    pci_sysfs_init() is a late_initcall, and a driver may have already claimed
    one of these devices and enabled runtime power management for it, so the
    device could already be in D3 by the time we get to pci_sysfs_init().
    
    The device itself should respond to the config read even while it's in
    D3hot, but if an upstream bridge is also in D3hot, the read won't even
    reach the device because the bridge won't forward it downstream to the
    device.  If the bridge is a PCIe port, it should complete the read as an
    Unsupported Request, which may be reported to the CPU as an exception or as
    invalid data.
    
    Avoid this case by probing for reset support from pci_init_capabilities(),
    before a driver can claim the device.  The device may be in D3hot, but any
    bridges leading to it should be in D0, so the device's config space should
    be fully accessible at that point.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index ef5377438a1e..489660d0d384 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -2121,6 +2121,9 @@ static void pci_init_capabilities(struct pci_dev *dev)
 
 	/* Advanced Error Reporting */
 	pci_aer_init(dev);
+
+	if (pci_probe_reset_function(dev) == 0)
+		dev->reset_fn = 1;
 }
 
 /*

commit ab8c609356fbe8dbcd44df11e884ce8cddf3739e
Merge: a5fae846f21d 36b072742a83
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Feb 1 11:40:07 2018 -0600

    Merge branch 'pci/spdx' into next
    
    * pci/spdx:
      PCI: Add SPDX GPL-2.0+ to replace implicit GPL v2 or later statement
      PCI: Add SPDX GPL-2.0+ to replace GPL v2 or later boilerplate
      PCI: Add SPDX GPL-2.0 to replace COPYING boilerplate
      PCI: Add SPDX GPL-2.0 to replace GPL v2 boilerplate
      PCI: Add SPDX GPL-2.0 when no license was specified

commit c7f75aecb2d9436c4bef8b413231f60deae3453c
Merge: a07ae842e209 37dddf14f1ae
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Jan 31 10:21:33 2018 -0600

    Merge remote-tracking branch 'lorenzo/pci/cadence' into next
    
    * lorenzo/pci/cadence:
      PCI: cadence: Add EndPoint Controller driver for Cadence PCIe controller
      dt-bindings: PCI: cadence: Add DT bindings for Cadence PCIe endpoint controller
      PCI: endpoint: Fix EPF device name to support multi-function devices
      PCI: endpoint: Add the function number as argument to EPC ops
      PCI: cadence: Add host driver for Cadence PCIe controller
      dt-bindings: PCI: cadence: Add DT bindings for Cadence PCIe host controller
      PCI: Add vendor ID for Cadence
      PCI: Add generic function to probe PCI host controllers
      PCI: generic: fix missing call of pci_free_resource_list()
      PCI: OF: Add generic function to parse and allocate PCI resources
      PCI: Regroup all PCI related entries into drivers/pci/Makefile
    
    Conflicts:
            drivers/pci/of.c
            include/linux/pci.h

commit 01f095e46ba3a91b06709170c19bc3936e872541
Merge: 6a436fa81252 0aa0f5d1084c
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Jan 31 10:13:07 2018 -0600

    Merge branch 'pci/trivial' into next
    
    * pci/trivial:
      PCI: Clean up whitespace in linux/pci.h, pci/pci.h
      PCI: Tidy up pci/probe.c comments

commit 412ee7cd3dc581a37b7d15a5147a556e45445be1
Merge: 85d24b3fc222 80db6f08b7af
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Jan 31 10:10:32 2018 -0600

    Merge branch 'pci/misc' into next
    
    * pci/misc:
      PCI: Add dummy pci_irqd_intx_xlate() for CONFIG_PCI=n build
      PCI: Add wrappers for dev_printk()
      PCI: Remove unnecessary messages for memory allocation failures
      PCI: Add #defines for Completion Timeout Disable feature
      hinic: Replace PCI pool old API
      net: e100: Replace PCI pool old API
      block: DAC960: Replace PCI pool old API
      MAINTAINERS: Include more PCI files
      PCI: Remove unneeded kallsyms include
      powerpc/pci: Unroll two pass loop when scanning bridges
      powerpc/pci: Use for_each_pci_bridge() helper

commit 5be31686cf4752443e669f48843eed036c69f999
Merge: 6b290397afb8 20c3ff6114b0
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Jan 31 10:10:30 2018 -0600

    Merge branch 'pci/enumeration' into next
    
    * pci/enumeration:
      RDMA/qedr: Use pci_enable_atomic_ops_to_root()
      PCI: Add pci_enable_atomic_ops_to_root()
      PCI: Make PCI_SCAN_ALL_PCIE_DEVS work for Root as well as Downstream Ports

commit 49b8e3f3ed1d411a8f8fa5fbe72c88f3d1d43824
Author: Cyrille Pitchen <cyrille.pitchen@free-electrons.com>
Date:   Tue Jan 30 21:56:52 2018 +0100

    PCI: Add generic function to probe PCI host controllers
    
    This patchs moves generic source code from
    drivers/pci/host/pci-host-common.c into drivers/pci/probe.c.
    
    Indeed the extracted lines of code were duplicated by many host
    controller drivers. Regrouping them into a generic function gives a
    change to properly share this code without introducing a useless
    dependency to PCI_HOST_COMMON, which selects PCI_ECAM when not needed by
    most host controller drivers.
    
    Signed-off-by: Cyrille Pitchen <cyrille.pitchen@free-electrons.com>
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 14e0ea1ff38b..a42bbfc5f2ec 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -2620,6 +2620,39 @@ struct pci_bus *pci_create_root_bus(struct device *parent, int bus,
 }
 EXPORT_SYMBOL_GPL(pci_create_root_bus);
 
+int pci_host_probe(struct pci_host_bridge *bridge)
+{
+	struct pci_bus *bus, *child;
+	int ret;
+
+	ret = pci_scan_root_bus_bridge(bridge);
+	if (ret < 0) {
+		dev_err(bridge->dev.parent, "Scanning root bridge failed");
+		return ret;
+	}
+
+	bus = bridge->bus;
+
+	/*
+	 * We insert PCI resources into the iomem_resource and
+	 * ioport_resource trees in either pci_bus_claim_resources()
+	 * or pci_bus_assign_resources().
+	 */
+	if (pci_has_flag(PCI_PROBE_ONLY)) {
+		pci_bus_claim_resources(bus);
+	} else {
+		pci_bus_size_bridges(bus);
+		pci_bus_assign_resources(bus);
+
+		list_for_each_entry(child, &bus->children, node)
+			pcie_bus_configure_settings(child);
+	}
+
+	pci_bus_add_devices(bus);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(pci_host_probe);
+
 int pci_bus_insert_busn_res(struct pci_bus *b, int bus, int bus_max)
 {
 	struct resource *res = &b->busn_res;

commit 7328c8f48d1895b3fec98b0b319cfb856b4c4fa1
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Jan 26 11:45:16 2018 -0600

    PCI: Add SPDX GPL-2.0 when no license was specified
    
    b24413180f56 ("License cleanup: add SPDX GPL-2.0 license identifier to
    files with no license") added SPDX GPL-2.0 to several PCI files that
    previously contained no license information.
    
    Add SPDX GPL-2.0 to all other PCI files that did not contain any license
    information and hence were under the default GPL version 2 license of the
    kernel.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 14e0ea1ff38b..3ea2d610d607 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * probe.c - PCI detection and setup code
  */

commit 7506dc7989933235e6fc23f3d0516bdbf0f7d1a8
Author: Frederick Lawler <fred@fredlawl.com>
Date:   Thu Jan 18 12:55:24 2018 -0600

    PCI: Add wrappers for dev_printk()
    
    Add PCI-specific dev_printk() wrappers and use them to simplify the code
    slightly.  No functional change intended.
    
    Signed-off-by: Frederick Lawler <fred@fredlawl.com>
    [bhelgaas: squash into one patch]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 14e0ea1ff38b..d37466233ca0 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -253,7 +253,7 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 
 	sz64 = pci_size(l64, sz64, mask64);
 	if (!sz64) {
-		dev_info(&dev->dev, FW_BUG "reg 0x%x: invalid BAR (can't size)\n",
+		pci_info(dev, FW_BUG "reg 0x%x: invalid BAR (can't size)\n",
 			 pos);
 		goto fail;
 	}
@@ -264,7 +264,7 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 			res->flags |= IORESOURCE_UNSET | IORESOURCE_DISABLED;
 			res->start = 0;
 			res->end = 0;
-			dev_err(&dev->dev, "reg 0x%x: can't handle BAR larger than 4GB (size %#010llx)\n",
+			pci_err(dev, "reg 0x%x: can't handle BAR larger than 4GB (size %#010llx)\n",
 				pos, (unsigned long long)sz64);
 			goto out;
 		}
@@ -274,7 +274,7 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 			res->flags |= IORESOURCE_UNSET;
 			res->start = 0;
 			res->end = sz64;
-			dev_info(&dev->dev, "reg 0x%x: can't handle BAR above 4GB (bus address %#010llx)\n",
+			pci_info(dev, "reg 0x%x: can't handle BAR above 4GB (bus address %#010llx)\n",
 				 pos, (unsigned long long)l64);
 			goto out;
 		}
@@ -301,7 +301,7 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 		res->flags |= IORESOURCE_UNSET;
 		res->start = 0;
 		res->end = region.end - region.start;
-		dev_info(&dev->dev, "reg 0x%x: initial BAR value %#010llx invalid\n",
+		pci_info(dev, "reg 0x%x: initial BAR value %#010llx invalid\n",
 			 pos, (unsigned long long)region.start);
 	}
 
@@ -312,7 +312,7 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 	res->flags = 0;
 out:
 	if (res->flags)
-		dev_printk(KERN_DEBUG, &dev->dev, "reg 0x%x: %pR\n", pos, res);
+		pci_printk(KERN_DEBUG, dev, "reg 0x%x: %pR\n", pos, res);
 
 	return (res->flags & IORESOURCE_MEM_64) ? 1 : 0;
 }
@@ -375,7 +375,7 @@ static void pci_read_bridge_io(struct pci_bus *child)
 		region.start = base;
 		region.end = limit + io_granularity - 1;
 		pcibios_bus_to_resource(dev->bus, res, &region);
-		dev_printk(KERN_DEBUG, &dev->dev, "  bridge window %pR\n", res);
+		pci_printk(KERN_DEBUG, dev, "  bridge window %pR\n", res);
 	}
 }
 
@@ -397,7 +397,7 @@ static void pci_read_bridge_mmio(struct pci_bus *child)
 		region.start = base;
 		region.end = limit + 0xfffff;
 		pcibios_bus_to_resource(dev->bus, res, &region);
-		dev_printk(KERN_DEBUG, &dev->dev, "  bridge window %pR\n", res);
+		pci_printk(KERN_DEBUG, dev, "  bridge window %pR\n", res);
 	}
 }
 
@@ -437,7 +437,7 @@ static void pci_read_bridge_mmio_pref(struct pci_bus *child)
 	limit = (pci_bus_addr_t) limit64;
 
 	if (base != base64) {
-		dev_err(&dev->dev, "can't handle bridge window above 4GB (bus address %#010llx)\n",
+		pci_err(dev, "can't handle bridge window above 4GB (bus address %#010llx)\n",
 			(unsigned long long) base64);
 		return;
 	}
@@ -450,7 +450,7 @@ static void pci_read_bridge_mmio_pref(struct pci_bus *child)
 		region.start = base;
 		region.end = limit + 0xfffff;
 		pcibios_bus_to_resource(dev->bus, res, &region);
-		dev_printk(KERN_DEBUG, &dev->dev, "  bridge window %pR\n", res);
+		pci_printk(KERN_DEBUG, dev, "  bridge window %pR\n", res);
 	}
 }
 
@@ -463,7 +463,7 @@ void pci_read_bridge_bases(struct pci_bus *child)
 	if (pci_is_root_bus(child))	/* It's a host bus, nothing to read */
 		return;
 
-	dev_info(&dev->dev, "PCI bridge to %pR%s\n",
+	pci_info(dev, "PCI bridge to %pR%s\n",
 		 &child->busn_res,
 		 dev->transparent ? " (subtractive decode)" : "");
 
@@ -480,7 +480,7 @@ void pci_read_bridge_bases(struct pci_bus *child)
 			if (res && res->flags) {
 				pci_bus_add_resource(child, res,
 						     PCI_SUBTRACTIVE_DECODE);
-				dev_printk(KERN_DEBUG, &dev->dev,
+				pci_printk(KERN_DEBUG, dev,
 					   "  bridge window %pR (subtractive decode)\n",
 					   res);
 			}
@@ -1005,11 +1005,11 @@ static int pci_scan_bridge_extend(struct pci_bus *bus, struct pci_dev *dev,
 	secondary = (buses >> 8) & 0xFF;
 	subordinate = (buses >> 16) & 0xFF;
 
-	dev_dbg(&dev->dev, "scanning [bus %02x-%02x] behind bridge, pass %d\n",
+	pci_dbg(dev, "scanning [bus %02x-%02x] behind bridge, pass %d\n",
 		secondary, subordinate, pass);
 
 	if (!primary && (primary != bus->number) && secondary && subordinate) {
-		dev_warn(&dev->dev, "Primary bus is hard wired to 0\n");
+		pci_warn(dev, "Primary bus is hard wired to 0\n");
 		primary = bus->number;
 	}
 
@@ -1017,7 +1017,7 @@ static int pci_scan_bridge_extend(struct pci_bus *bus, struct pci_dev *dev,
 	if (!pass &&
 	    (primary != bus->number || secondary <= bus->number ||
 	     secondary > subordinate)) {
-		dev_info(&dev->dev, "bridge configuration invalid ([bus %02x-%02x]), reconfiguring\n",
+		pci_info(dev, "bridge configuration invalid ([bus %02x-%02x]), reconfiguring\n",
 			 secondary, subordinate);
 		broken = 1;
 	}
@@ -1058,7 +1058,7 @@ static int pci_scan_bridge_extend(struct pci_bus *bus, struct pci_dev *dev,
 
 		cmax = pci_scan_child_bus(child);
 		if (cmax > subordinate)
-			dev_warn(&dev->dev, "bridge has subordinate %02x but max busn %02x\n",
+			pci_warn(dev, "bridge has subordinate %02x but max busn %02x\n",
 				 subordinate, cmax);
 		/* subordinate should equal child->busn_res.end */
 		if (subordinate > max)
@@ -1468,7 +1468,7 @@ int pci_setup_device(struct pci_dev *dev)
 	dev->revision = class & 0xff;
 	dev->class = class >> 8;		    /* upper 3 bytes */
 
-	dev_printk(KERN_DEBUG, &dev->dev, "[%04x:%04x] type %02x class %#08x\n",
+	pci_printk(KERN_DEBUG, dev, "[%04x:%04x] type %02x class %#08x\n",
 		   dev->vendor, dev->device, dev->hdr_type, dev->class);
 
 	/* need to have dev->class ready */
@@ -1488,7 +1488,7 @@ int pci_setup_device(struct pci_dev *dev)
 	if (dev->non_compliant_bars) {
 		pci_read_config_word(dev, PCI_COMMAND, &cmd);
 		if (cmd & (PCI_COMMAND_IO | PCI_COMMAND_MEMORY)) {
-			dev_info(&dev->dev, "device has non-compliant BARs; disabling IO/MEM decoding\n");
+			pci_info(dev, "device has non-compliant BARs; disabling IO/MEM decoding\n");
 			cmd &= ~PCI_COMMAND_IO;
 			cmd &= ~PCI_COMMAND_MEMORY;
 			pci_write_config_word(dev, PCI_COMMAND, cmd);
@@ -1521,14 +1521,14 @@ int pci_setup_device(struct pci_dev *dev)
 				res = &dev->resource[0];
 				res->flags = LEGACY_IO_RESOURCE;
 				pcibios_bus_to_resource(dev->bus, res, &region);
-				dev_info(&dev->dev, "legacy IDE quirk: reg 0x10: %pR\n",
+				pci_info(dev, "legacy IDE quirk: reg 0x10: %pR\n",
 					 res);
 				region.start = 0x3F6;
 				region.end = 0x3F6;
 				res = &dev->resource[1];
 				res->flags = LEGACY_IO_RESOURCE;
 				pcibios_bus_to_resource(dev->bus, res, &region);
-				dev_info(&dev->dev, "legacy IDE quirk: reg 0x14: %pR\n",
+				pci_info(dev, "legacy IDE quirk: reg 0x14: %pR\n",
 					 res);
 			}
 			if ((progif & 4) == 0) {
@@ -1537,14 +1537,14 @@ int pci_setup_device(struct pci_dev *dev)
 				res = &dev->resource[2];
 				res->flags = LEGACY_IO_RESOURCE;
 				pcibios_bus_to_resource(dev->bus, res, &region);
-				dev_info(&dev->dev, "legacy IDE quirk: reg 0x18: %pR\n",
+				pci_info(dev, "legacy IDE quirk: reg 0x18: %pR\n",
 					 res);
 				region.start = 0x376;
 				region.end = 0x376;
 				res = &dev->resource[3];
 				res->flags = LEGACY_IO_RESOURCE;
 				pcibios_bus_to_resource(dev->bus, res, &region);
-				dev_info(&dev->dev, "legacy IDE quirk: reg 0x1c: %pR\n",
+				pci_info(dev, "legacy IDE quirk: reg 0x1c: %pR\n",
 					 res);
 			}
 		}
@@ -1577,12 +1577,12 @@ int pci_setup_device(struct pci_dev *dev)
 		break;
 
 	default:				    /* unknown header */
-		dev_err(&dev->dev, "unknown header type %02x, ignoring device\n",
+		pci_err(dev, "unknown header type %02x, ignoring device\n",
 			dev->hdr_type);
 		return -EIO;
 
 	bad:
-		dev_err(&dev->dev, "ignoring class %#08x (doesn't match header type %02x)\n",
+		pci_err(dev, "ignoring class %#08x (doesn't match header type %02x)\n",
 			dev->class, dev->hdr_type);
 		dev->class = PCI_CLASS_NOT_DEFINED << 8;
 	}
@@ -1606,7 +1606,7 @@ static void pci_configure_mps(struct pci_dev *dev)
 		return;
 
 	if (pcie_bus_config == PCIE_BUS_TUNE_OFF) {
-		dev_warn(&dev->dev, "Max Payload Size %d, but upstream %s set to %d; if necessary, use \"pci=pcie_bus_safe\" and report a bug\n",
+		pci_warn(dev, "Max Payload Size %d, but upstream %s set to %d; if necessary, use \"pci=pcie_bus_safe\" and report a bug\n",
 			 mps, pci_name(bridge), p_mps);
 		return;
 	}
@@ -1620,12 +1620,12 @@ static void pci_configure_mps(struct pci_dev *dev)
 
 	rc = pcie_set_mps(dev, p_mps);
 	if (rc) {
-		dev_warn(&dev->dev, "can't set Max Payload Size to %d; if necessary, use \"pci=pcie_bus_safe\" and report a bug\n",
+		pci_warn(dev, "can't set Max Payload Size to %d; if necessary, use \"pci=pcie_bus_safe\" and report a bug\n",
 			 p_mps);
 		return;
 	}
 
-	dev_info(&dev->dev, "Max Payload Size set to %d (was %d, max %d)\n",
+	pci_info(dev, "Max Payload Size set to %d (was %d, max %d)\n",
 		 p_mps, mps, 128 << dev->pcie_mpss);
 }
 
@@ -1645,8 +1645,7 @@ static void program_hpp_type0(struct pci_dev *dev, struct hpp_type0 *hpp)
 		hpp = &pci_default_type0;
 
 	if (hpp->revision > 1) {
-		dev_warn(&dev->dev,
-			 "PCI settings rev %d not supported; using defaults\n",
+		pci_warn(dev, "PCI settings rev %d not supported; using defaults\n",
 			 hpp->revision);
 		hpp = &pci_default_type0;
 	}
@@ -1684,7 +1683,7 @@ static void program_hpp_type1(struct pci_dev *dev, struct hpp_type1 *hpp)
 	if (!pos)
 		return;
 
-	dev_warn(&dev->dev, "PCI-X settings not supported\n");
+	pci_warn(dev, "PCI-X settings not supported\n");
 }
 
 static bool pcie_root_rcb_set(struct pci_dev *dev)
@@ -1714,7 +1713,7 @@ static void program_hpp_type2(struct pci_dev *dev, struct hpp_type2 *hpp)
 		return;
 
 	if (hpp->revision > 1) {
-		dev_warn(&dev->dev, "PCIe settings rev %d not supported\n",
+		pci_warn(dev, "PCIe settings rev %d not supported\n",
 			 hpp->revision);
 		return;
 	}
@@ -1818,7 +1817,7 @@ int pci_configure_extended_tags(struct pci_dev *dev, void *ign)
 	 */
 	if (host->no_ext_tags) {
 		if (ctl & PCI_EXP_DEVCTL_EXT_TAG) {
-			dev_info(&dev->dev, "disabling Extended Tags\n");
+			pci_info(dev, "disabling Extended Tags\n");
 			pcie_capability_clear_word(dev, PCI_EXP_DEVCTL,
 						   PCI_EXP_DEVCTL_EXT_TAG);
 		}
@@ -1826,7 +1825,7 @@ int pci_configure_extended_tags(struct pci_dev *dev, void *ign)
 	}
 
 	if (!(ctl & PCI_EXP_DEVCTL_EXT_TAG)) {
-		dev_info(&dev->dev, "enabling Extended Tags\n");
+		pci_info(dev, "enabling Extended Tags\n");
 		pcie_capability_set_word(dev, PCI_EXP_DEVCTL,
 					 PCI_EXP_DEVCTL_EXT_TAG);
 	}
@@ -1871,7 +1870,7 @@ static void pci_configure_relaxed_ordering(struct pci_dev *dev)
 	if (root->dev_flags & PCI_DEV_FLAGS_NO_RELAXED_ORDERING) {
 		pcie_capability_clear_word(dev, PCI_EXP_DEVCTL,
 					   PCI_EXP_DEVCTL_RELAX_EN);
-		dev_info(&dev->dev, "Disable Relaxed Ordering because the Root Port didn't support it\n");
+		pci_info(dev, "Relaxed Ordering disabled because the Root Port didn't support it\n");
 	}
 }
 
@@ -2334,7 +2333,7 @@ static void pcie_write_mps(struct pci_dev *dev, int mps)
 
 	rc = pcie_set_mps(dev, mps);
 	if (rc)
-		dev_err(&dev->dev, "Failed attempting to set the MPS\n");
+		pci_err(dev, "Failed attempting to set the MPS\n");
 }
 
 static void pcie_write_mrrs(struct pci_dev *dev)
@@ -2364,12 +2363,12 @@ static void pcie_write_mrrs(struct pci_dev *dev)
 		if (!rc)
 			break;
 
-		dev_warn(&dev->dev, "Failed attempting to set the MRRS\n");
+		pci_warn(dev, "Failed attempting to set the MRRS\n");
 		mrrs /= 2;
 	}
 
 	if (mrrs < 128)
-		dev_err(&dev->dev, "MRRS was unable to be configured with a safe value.  If problems are experienced, try running with pci=pcie_bus_safe\n");
+		pci_err(dev, "MRRS was unable to be configured with a safe value.  If problems are experienced, try running with pci=pcie_bus_safe\n");
 }
 
 static int pcie_bus_configure_set(struct pci_dev *dev, void *data)
@@ -2389,7 +2388,7 @@ static int pcie_bus_configure_set(struct pci_dev *dev, void *data)
 	pcie_write_mps(dev, mps);
 	pcie_write_mrrs(dev);
 
-	dev_info(&dev->dev, "Max Payload Size set to %4d/%4d (was %4d), Max Read Rq %4d\n",
+	pci_info(dev, "Max Payload Size set to %4d/%4d (was %4d), Max Read Rq %4d\n",
 		 pcie_get_mps(dev), 128 << dev->pcie_mpss,
 		 orig_mps, pcie_get_readrq(dev));
 
@@ -2874,7 +2873,7 @@ int pci_hp_add_bridge(struct pci_dev *dev)
 			break;
 	}
 	if (busnr-- > end) {
-		dev_err(&dev->dev, "No bus number available for hot-added bridge\n");
+		pci_err(dev, "No bus number available for hot-added bridge\n");
 		return -1;
 	}
 

commit 3e466e2d3a04c726cb85f0d97a288769ff9de7a5
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Nov 30 10:58:14 2017 -0600

    PCI: Tidy up pci/probe.c comments
    
    No functional change intended.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 14e0ea1ff38b..4c62d966d545 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -69,8 +69,8 @@ static int find_anything(struct device *dev, void *data)
 }
 
 /*
- * Some device drivers need know if pci is initiated.
- * Basically, we think pci is not initiated when there
+ * Some device drivers need know if PCI is initiated.
+ * Basically, we think PCI is not initiated when there
  * is no device to be found on the pci_bus_type.
  */
 int no_pci_devices(void)
@@ -116,12 +116,16 @@ static u64 pci_size(u64 base, u64 maxbase, u64 mask)
 	if (!size)
 		return 0;
 
-	/* Get the lowest of them to find the decode size, and
-	   from that the extent.  */
+	/*
+	 * Get the lowest of them to find the decode size, and from that
+	 * the extent.
+	 */
 	size = (size & ~(size-1)) - 1;
 
-	/* base == maxbase can be valid only if the BAR has
-	   already been programmed with all 1s.  */
+	/*
+	 * base == maxbase can be valid only if the BAR has already been
+	 * programmed with all 1s.
+	 */
 	if (base == maxbase && ((base | size) & mask) != mask)
 		return 0;
 
@@ -164,7 +168,7 @@ static inline unsigned long decode_bar(struct pci_dev *dev, u32 bar)
 #define PCI_COMMAND_DECODE_ENABLE	(PCI_COMMAND_MEMORY | PCI_COMMAND_IO)
 
 /**
- * pci_read_base - read a PCI BAR
+ * pci_read_base - Read a PCI BAR
  * @dev: the PCI device
  * @type: type of the BAR
  * @res: resource buffer to be filled in
@@ -764,7 +768,7 @@ static int pci_register_host_bridge(struct pci_host_bridge *bridge)
 
 	bridge->bus = bus;
 
-	/* temporarily move resources off the list */
+	/* Temporarily move resources off the list */
 	list_splice_init(&bridge->windows, &resources);
 	bus->sysdata = bridge->sysdata;
 	bus->msi = bridge->msi;
@@ -776,7 +780,7 @@ static int pci_register_host_bridge(struct pci_host_bridge *bridge)
 
 	b = pci_find_bus(pci_domain_nr(bus), bridge->busnr);
 	if (b) {
-		/* If we already got to this bus through a different bridge, ignore it */
+		/* Ignore it if we already got here via a different bridge */
 		dev_dbg(&b->dev, "bus already known\n");
 		err = -EEXIST;
 		goto free;
@@ -869,9 +873,7 @@ static struct pci_bus *pci_alloc_child_bus(struct pci_bus *parent,
 	int i;
 	int ret;
 
-	/*
-	 * Allocate a new bus, and inherit stuff from the parent..
-	 */
+	/* Allocate a new bus and inherit stuff from the parent */
 	child = pci_alloc_bus(parent);
 	if (!child)
 		return NULL;
@@ -882,16 +884,14 @@ static struct pci_bus *pci_alloc_child_bus(struct pci_bus *parent,
 	child->sysdata = parent->sysdata;
 	child->bus_flags = parent->bus_flags;
 
-	/* initialize some portions of the bus device, but don't register it
-	 * now as the parent is not properly set up yet.
+	/*
+	 * Initialize some portions of the bus device, but don't register
+	 * it now as the parent is not properly set up yet.
 	 */
 	child->dev.class = &pcibus_class;
 	dev_set_name(&child->dev, "%04x:%02x", pci_domain_nr(child), busnr);
 
-	/*
-	 * Set up the primary, secondary and subordinate
-	 * bus numbers.
-	 */
+	/* Set up the primary, secondary and subordinate bus numbers */
 	child->number = child->busn_res.start = busnr;
 	child->primary = parent->busn_res.start;
 	child->busn_res.end = 0xff;
@@ -907,7 +907,7 @@ static struct pci_bus *pci_alloc_child_bus(struct pci_bus *parent,
 	pci_set_bus_of_node(child);
 	pci_set_bus_speed(child);
 
-	/* Set up default resource pointers and names.. */
+	/* Set up default resource pointers and names */
 	for (i = 0; i < PCI_BRIDGE_RESOURCE_NUM; i++) {
 		child->resource[i] = &bridge->resource[PCI_BRIDGE_RESOURCES+i];
 		child->resource[i]->name = child->name;
@@ -1022,8 +1022,10 @@ static int pci_scan_bridge_extend(struct pci_bus *bus, struct pci_dev *dev,
 		broken = 1;
 	}
 
-	/* Disable MasterAbortMode during probing to avoid reporting
-	   of bus errors (in some architectures) */
+	/*
+	 * Disable Master-Abort Mode during probing to avoid reporting of
+	 * bus errors in some architectures.
+	 */
 	pci_read_config_word(dev, PCI_BRIDGE_CONTROL, &bctl);
 	pci_write_config_word(dev, PCI_BRIDGE_CONTROL,
 			      bctl & ~PCI_BRIDGE_CTL_MASTER_ABORT);
@@ -1033,18 +1035,19 @@ static int pci_scan_bridge_extend(struct pci_bus *bus, struct pci_dev *dev,
 	if ((secondary || subordinate) && !pcibios_assign_all_busses() &&
 	    !is_cardbus && !broken) {
 		unsigned int cmax;
+
 		/*
-		 * Bus already configured by firmware, process it in the first
-		 * pass and just note the configuration.
+		 * Bus already configured by firmware, process it in the
+		 * first pass and just note the configuration.
 		 */
 		if (pass)
 			goto out;
 
 		/*
-		 * The bus might already exist for two reasons: Either we are
-		 * rescanning the bus or the bus is reachable through more than
-		 * one bridge. The second case can happen with the i450NX
-		 * chipset.
+		 * The bus might already exist for two reasons: Either we
+		 * are rescanning the bus or the bus is reachable through
+		 * more than one bridge. The second case can happen with
+		 * the i450NX chipset.
 		 */
 		child = pci_find_bus(pci_domain_nr(bus), secondary);
 		if (!child) {
@@ -1060,22 +1063,27 @@ static int pci_scan_bridge_extend(struct pci_bus *bus, struct pci_dev *dev,
 		if (cmax > subordinate)
 			dev_warn(&dev->dev, "bridge has subordinate %02x but max busn %02x\n",
 				 subordinate, cmax);
-		/* subordinate should equal child->busn_res.end */
+
+		/* Subordinate should equal child->busn_res.end */
 		if (subordinate > max)
 			max = subordinate;
 	} else {
+
 		/*
 		 * We need to assign a number to this bus which we always
 		 * do in the second pass.
 		 */
 		if (!pass) {
 			if (pcibios_assign_all_busses() || broken || is_cardbus)
-				/* Temporarily disable forwarding of the
-				   configuration cycles on all bridges in
-				   this bus segment to avoid possible
-				   conflicts in the second pass between two
-				   bridges programmed with overlapping
-				   bus ranges. */
+
+				/*
+				 * Temporarily disable forwarding of the
+				 * configuration cycles on all bridges in
+				 * this bus segment to avoid possible
+				 * conflicts in the second pass between two
+				 * bridges programmed with overlapping bus
+				 * ranges.
+				 */
 				pci_write_config_dword(dev, PCI_PRIMARY_BUS,
 						       buses & ~0xffffff);
 			goto out;
@@ -1084,9 +1092,11 @@ static int pci_scan_bridge_extend(struct pci_bus *bus, struct pci_dev *dev,
 		/* Clear errors */
 		pci_write_config_word(dev, PCI_STATUS, 0xffff);
 
-		/* Prevent assigning a bus number that already exists.
-		 * This can happen when a bridge is hot-plugged, so in
-		 * this case we only re-scan this bus. */
+		/*
+		 * Prevent assigning a bus number that already exists.
+		 * This can happen when a bridge is hot-plugged, so in this
+		 * case we only re-scan this bus.
+		 */
 		child = pci_find_bus(pci_domain_nr(bus), max+1);
 		if (!child) {
 			child = pci_add_new_bus(bus, dev, max+1);
@@ -1113,19 +1123,18 @@ static int pci_scan_bridge_extend(struct pci_bus *bus, struct pci_dev *dev,
 			buses |= CARDBUS_LATENCY_TIMER << 24;
 		}
 
-		/*
-		 * We need to blast all three values with a single write.
-		 */
+		/* We need to blast all three values with a single write */
 		pci_write_config_dword(dev, PCI_PRIMARY_BUS, buses);
 
 		if (!is_cardbus) {
 			child->bridge_ctl = bctl;
 			max = pci_scan_child_bus_extend(child, available_buses);
 		} else {
+
 			/*
-			 * For CardBus bridges, we leave 4 bus numbers
-			 * as cards with a PCI-to-PCI bridge can be
-			 * inserted later.
+			 * For CardBus bridges, we leave 4 bus numbers as
+			 * cards with a PCI-to-PCI bridge can be inserted
+			 * later.
 			 */
 			for (i = 0; i < CARDBUS_RESERVE_BUSNR; i++) {
 				struct pci_bus *parent = bus;
@@ -1141,10 +1150,11 @@ static int pci_scan_bridge_extend(struct pci_bus *bus, struct pci_dev *dev,
 					parent = parent->parent;
 				}
 				if (j) {
+
 					/*
-					 * Often, there are two cardbus bridges
-					 * -- try to leave one valid bus number
-					 * for each one.
+					 * Often, there are two CardBus
+					 * bridges -- try to leave one
+					 * valid bus number for each one.
 					 */
 					i /= 2;
 					break;
@@ -1152,9 +1162,8 @@ static int pci_scan_bridge_extend(struct pci_bus *bus, struct pci_dev *dev,
 			}
 			max += i;
 		}
-		/*
-		 * Set the subordinate bus number to its real value.
-		 */
+
+		/* Set subordinate bus number to its real value */
 		pci_bus_update_busn_res_end(child, max);
 		pci_write_config_byte(dev, PCI_SUBORDINATE_BUS, max);
 	}
@@ -1295,7 +1304,7 @@ static void set_pcie_thunderbolt(struct pci_dev *dev)
 }
 
 /**
- * pci_ext_cfg_is_aliased - is ext config space just an alias of std config?
+ * pci_ext_cfg_is_aliased - Is ext config space just an alias of std config?
  * @dev: PCI device
  *
  * PCI Express to PCI/PCI-X Bridge Specification, rev 1.0, 4.1.4 says that
@@ -1332,7 +1341,7 @@ static bool pci_ext_cfg_is_aliased(struct pci_dev *dev)
 }
 
 /**
- * pci_cfg_space_size - get the configuration space size of the PCI device.
+ * pci_cfg_space_size - Get the configuration space size of the PCI device
  * @dev: PCI device
  *
  * Regular PCI devices have 256 bytes, but PCI-X 2 and PCI Express devices
@@ -1398,7 +1407,7 @@ static void pci_msi_setup_pci_dev(struct pci_dev *dev)
 }
 
 /**
- * pci_intx_mask_broken - test PCI_COMMAND_INTX_DISABLE writability
+ * pci_intx_mask_broken - Test PCI_COMMAND_INTX_DISABLE writability
  * @dev: PCI device
  *
  * Test whether PCI_COMMAND_INTX_DISABLE is writable for @dev.  Check this
@@ -1426,11 +1435,11 @@ static int pci_intx_mask_broken(struct pci_dev *dev)
 }
 
 /**
- * pci_setup_device - fill in class and map information of a device
+ * pci_setup_device - Fill in class and map information of a device
  * @dev: the device structure to fill
  *
  * Initialize the device structure with information about the device's
- * vendor,class,memory and IO-space addresses,IRQ lines etc.
+ * vendor,class,memory and IO-space addresses, IRQ lines etc.
  * Called at initialisation of the PCI subsystem and by CardBus services.
  * Returns 0 on success and negative if unknown type of device (not normal,
  * bridge or CardBus).
@@ -1456,8 +1465,11 @@ int pci_setup_device(struct pci_dev *dev)
 	set_pcie_port_type(dev);
 
 	pci_dev_assign_slot(dev);
-	/* Assume 32-bit PCI; let 64-bit PCI cards (which are far rarer)
-	   set this higher, assuming the system even supports it.  */
+
+	/*
+	 * Assume 32-bit PCI; let 64-bit PCI cards (which are far rarer)
+	 * set this higher, assuming the system even supports it.
+	 */
 	dev->dma_mask = 0xffffffff;
 
 	dev_set_name(&dev->dev, "%04x:%02x:%02x.%d", pci_domain_nr(dev->bus),
@@ -1471,10 +1483,10 @@ int pci_setup_device(struct pci_dev *dev)
 	dev_printk(KERN_DEBUG, &dev->dev, "[%04x:%04x] type %02x class %#08x\n",
 		   dev->vendor, dev->device, dev->hdr_type, dev->class);
 
-	/* need to have dev->class ready */
+	/* Need to have dev->class ready */
 	dev->cfg_size = pci_cfg_space_size(dev);
 
-	/* need to have dev->cfg_size ready */
+	/* Need to have dev->cfg_size ready */
 	set_pcie_thunderbolt(dev);
 
 	/* "Unknown power state" */
@@ -1482,7 +1494,8 @@ int pci_setup_device(struct pci_dev *dev)
 
 	/* Early fixups, before probing the BARs */
 	pci_fixup_device(pci_fixup_early, dev);
-	/* device class may be changed after fixup */
+
+	/* Device class may be changed after fixup */
 	class = dev->class >> 8;
 
 	if (dev->non_compliant_bars) {
@@ -1553,9 +1566,12 @@ int pci_setup_device(struct pci_dev *dev)
 	case PCI_HEADER_TYPE_BRIDGE:		    /* bridge header */
 		if (class != PCI_CLASS_BRIDGE_PCI)
 			goto bad;
-		/* The PCI-to-PCI bridge spec requires that subtractive
-		   decoding (i.e. transparent) bridge must have programming
-		   interface code of 0x01. */
+
+		/*
+		 * The PCI-to-PCI bridge spec requires that subtractive
+		 * decoding (i.e. transparent) bridge must have programming
+		 * interface code of 0x01.
+		 */
 		pci_read_irq(dev);
 		dev->transparent = ((dev->class & 0xff) == 1);
 		pci_read_bases(dev, 2, PCI_ROM_ADDRESS1);
@@ -1772,6 +1788,7 @@ static void program_hpp_type2(struct pci_dev *dev, struct hpp_type2 *hpp)
 	/* Initialize Advanced Error Capabilities and Control Register */
 	pci_read_config_dword(dev, pos + PCI_ERR_CAP, &reg32);
 	reg32 = (reg32 & hpp->adv_err_cap_and) | hpp->adv_err_cap_or;
+
 	/* Don't enable ECRC generation or checking if unsupported */
 	if (!(reg32 & PCI_ERR_CAP_ECRC_GENC))
 		reg32 &= ~PCI_ERR_CAP_ECRC_GENE;
@@ -1902,10 +1919,11 @@ static void pci_release_capabilities(struct pci_dev *dev)
 }
 
 /**
- * pci_release_dev - free a pci device structure when all users of it are finished.
+ * pci_release_dev - Free a PCI device structure when all users of it are
+ *		     finished
  * @dev: device that's been disconnected
  *
- * Will be called only by the device core when all users of this pci device are
+ * Will be called only by the device core when all users of this PCI device are
  * done.
  */
 static void pci_release_dev(struct device *dev)
@@ -1993,7 +2011,7 @@ bool pci_bus_read_dev_vendor_id(struct pci_bus *bus, int devfn, u32 *l,
 	if (pci_bus_read_config_dword(bus, devfn, PCI_VENDOR_ID, l))
 		return false;
 
-	/* some broken boards return 0 or ~0 if a slot is empty: */
+	/* Some broken boards return 0 or ~0 if a slot is empty: */
 	if (*l == 0xffffffff || *l == 0x00000000 ||
 	    *l == 0x0000ffff || *l == 0xffff0000)
 		return false;
@@ -2006,8 +2024,8 @@ bool pci_bus_read_dev_vendor_id(struct pci_bus *bus, int devfn, u32 *l,
 EXPORT_SYMBOL(pci_bus_read_dev_vendor_id);
 
 /*
- * Read the config data for a PCI device, sanity-check it
- * and fill in the dev structure...
+ * Read the config data for a PCI device, sanity-check it,
+ * and fill in the dev structure.
  */
 static struct pci_dev *pci_scan_device(struct pci_bus *bus, int devfn)
 {
@@ -2073,7 +2091,7 @@ static void pci_init_capabilities(struct pci_dev *dev)
 }
 
 /*
- * This is the equivalent of pci_host_bridge_msi_domain that acts on
+ * This is the equivalent of pci_host_bridge_msi_domain() that acts on
  * devices. Firmware interfaces that can select the MSI domain on a
  * per-device basis should be called from here.
  */
@@ -2082,7 +2100,7 @@ static struct irq_domain *pci_dev_msi_domain(struct pci_dev *dev)
 	struct irq_domain *d;
 
 	/*
-	 * If a domain has been set through the pcibios_add_device
+	 * If a domain has been set through the pcibios_add_device()
 	 * callback, then this is the one (platform code knows best).
 	 */
 	d = dev_get_msi_domain(&dev->dev);
@@ -2136,10 +2154,10 @@ void pci_device_add(struct pci_dev *dev, struct pci_bus *bus)
 	/* Fix up broken headers */
 	pci_fixup_device(pci_fixup_header, dev);
 
-	/* moved out from quirk header fixup code */
+	/* Moved out from quirk header fixup code */
 	pci_reassigndev_resource_alignment(dev);
 
-	/* Clear the state_saved flag. */
+	/* Clear the state_saved flag */
 	dev->state_saved = false;
 
 	/* Initialize various capabilities */
@@ -2156,7 +2174,7 @@ void pci_device_add(struct pci_dev *dev, struct pci_bus *bus)
 	ret = pcibios_add_device(dev);
 	WARN_ON(ret < 0);
 
-	/* Setup MSI irq domain */
+	/* Set up MSI IRQ domain */
 	pci_set_msi_domain(dev);
 
 	/* Notifier could use PCI capabilities */
@@ -2235,9 +2253,9 @@ static int only_one_child(struct pci_bus *bus)
 }
 
 /**
- * pci_scan_slot - scan a PCI slot on a bus for devices.
+ * pci_scan_slot - Scan a PCI slot on a bus for devices
  * @bus: PCI bus to scan
- * @devfn: slot number to scan (must have zero function.)
+ * @devfn: slot number to scan (must have zero function)
  *
  * Scan a PCI slot on the specified PCI bus for devices, adding
  * discovered devices to the @bus->devices list.  New devices
@@ -2268,7 +2286,7 @@ int pci_scan_slot(struct pci_bus *bus, int devfn)
 		}
 	}
 
-	/* only one slot has pcie device */
+	/* Only one slot has PCIe device */
 	if (bus->self && nr)
 		pcie_aspm_init_link_state(bus->self);
 
@@ -2317,7 +2335,9 @@ static void pcie_write_mps(struct pci_dev *dev, int mps)
 
 		if (pci_pcie_type(dev) != PCI_EXP_TYPE_ROOT_PORT &&
 		    dev->bus->self)
-			/* For "Performance", the assumption is made that
+
+			/*
+			 * For "Performance", the assumption is made that
 			 * downstream communication will never be larger than
 			 * the MRRS.  So, the MPS only needs to be configured
 			 * for the upstream communication.  This being the case,
@@ -2341,20 +2361,23 @@ static void pcie_write_mrrs(struct pci_dev *dev)
 {
 	int rc, mrrs;
 
-	/* In the "safe" case, do not configure the MRRS.  There appear to be
+	/*
+	 * In the "safe" case, do not configure the MRRS.  There appear to be
 	 * issues with setting MRRS to 0 on a number of devices.
 	 */
 	if (pcie_bus_config != PCIE_BUS_PERFORMANCE)
 		return;
 
-	/* For Max performance, the MRRS must be set to the largest supported
+	/*
+	 * For max performance, the MRRS must be set to the largest supported
 	 * value.  However, it cannot be configured larger than the MPS the
 	 * device or the bus can support.  This should already be properly
-	 * configured by a prior call to pcie_write_mps.
+	 * configured by a prior call to pcie_write_mps().
 	 */
 	mrrs = pcie_get_mps(dev);
 
-	/* MRRS is a R/W register.  Invalid values can be written, but a
+	/*
+	 * MRRS is a R/W register.  Invalid values can be written, but a
 	 * subsequent read will verify if the value is acceptable or not.
 	 * If the MRRS value provided is not acceptable (e.g., too large),
 	 * shrink the value until it is acceptable to the HW.
@@ -2396,7 +2419,8 @@ static int pcie_bus_configure_set(struct pci_dev *dev, void *data)
 	return 0;
 }
 
-/* pcie_bus_configure_settings requires that pci_walk_bus work in a top-down,
+/*
+ * pcie_bus_configure_settings() requires that pci_walk_bus work in a top-down,
  * parents then children fashion.  If this changes, then this code will not
  * work as designed.
  */
@@ -2410,7 +2434,8 @@ void pcie_bus_configure_settings(struct pci_bus *bus)
 	if (!pci_is_pcie(bus->self))
 		return;
 
-	/* FIXME - Peer to peer DMA is possible, though the endpoint would need
+	/*
+	 * FIXME - Peer to peer DMA is possible, though the endpoint would need
 	 * to be aware of the MPS of the destination.  To work around this,
 	 * simply force the MPS of the entire system to the smallest possible.
 	 */
@@ -2464,7 +2489,7 @@ static unsigned int pci_scan_child_bus_extend(struct pci_bus *bus,
 	for (devfn = 0; devfn < 0x100; devfn += 8)
 		pci_scan_slot(bus, devfn);
 
-	/* Reserve buses for SR-IOV capability. */
+	/* Reserve buses for SR-IOV capability */
 	used_buses = pci_iov_bus_range(bus);
 	max += used_buses;
 
@@ -2506,6 +2531,7 @@ static unsigned int pci_scan_child_bus_extend(struct pci_bus *bus,
 		unsigned int buses = 0;
 
 		if (!hotplug_bridges && normal_bridges == 1) {
+
 			/*
 			 * There is only one bridge on the bus (upstream
 			 * port) so it gets all available buses which it
@@ -2514,6 +2540,7 @@ static unsigned int pci_scan_child_bus_extend(struct pci_bus *bus,
 			 */
 			buses = available_buses;
 		} else if (dev->is_hotplug_bridge) {
+
 			/*
 			 * Distribute the extra buses between hotplug
 			 * bridges if any.
@@ -2572,8 +2599,8 @@ unsigned int pci_scan_child_bus(struct pci_bus *bus)
 EXPORT_SYMBOL_GPL(pci_scan_child_bus);
 
 /**
- * pcibios_root_bridge_prepare - Platform-specific host bridge setup.
- * @bridge: Host bridge to set up.
+ * pcibios_root_bridge_prepare - Platform-specific host bridge setup
+ * @bridge: Host bridge to set up
  *
  * Default empty implementation.  Replace with an architecture-specific setup
  * routine, if necessary.
@@ -2776,7 +2803,7 @@ struct pci_bus *pci_scan_bus(int bus, struct pci_ops *ops,
 EXPORT_SYMBOL(pci_scan_bus);
 
 /**
- * pci_rescan_bus_bridge_resize - scan a PCI bus for devices.
+ * pci_rescan_bus_bridge_resize - Scan a PCI bus for devices
  * @bridge: PCI bridge for the bus to scan
  *
  * Scan a PCI bus and child buses for new devices, add them,
@@ -2801,11 +2828,11 @@ unsigned int pci_rescan_bus_bridge_resize(struct pci_dev *bridge)
 }
 
 /**
- * pci_rescan_bus - scan a PCI bus for devices.
+ * pci_rescan_bus - Scan a PCI bus for devices
  * @bus: PCI bus to scan
  *
- * Scan a PCI bus and child buses for new devices, adds them,
- * and enables them.
+ * Scan a PCI bus and child buses for new devices, add them,
+ * and enable them.
  *
  * Returns the max number of subordinate bus discovered.
  */

commit d57f0b8c81393e7105331ac037fa465d5a45c65f
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Nov 30 15:22:39 2017 -0600

    PCI: Make PCI_SCAN_ALL_PCIE_DEVS work for Root as well as Downstream Ports
    
    PCIe Downstream Ports normally have only a Device 0 below them.  To
    optimize enumeration, we don't scan for other devices *unless* the
    PCI_SCAN_ALL_PCIE_DEVS flag is set by set by quirks or the
    "pci=pcie_scan_all" kernel parameter.
    
    Previously PCI_SCAN_ALL_PCIE_DEVS only affected scanning below Switch
    Downstream Ports, not Root Ports.
    
    But the "Nemo" system, also known as the AmigaOne X1000, has a PA Semi Root
    Port whose link leads to an AMD/ATI SB600 South Bridge.  The Root Port is a
    PCIe device, of course, but the SB600 contains only conventional PCI
    devices with no visible PCIe port.
    
    Simplify and restructure only_one_child() so that we scan for all possible
    devices below Root Ports as well as Switch Downstream Ports when
    PCI_SCAN_ALL_PCIE_DEVS is set.
    
    This is enough to make Nemo work with "pci=pcie_scan_all".  We would also
    like to add a quirk to set PCI_SCAN_ALL_PCIE_DEVS automatically on Nemo so
    users wouldn't have to use the "pci=pcie_scan_all" parameter, but we don't
    have that yet.
    
    Link: https://lkml.kernel.org/r/CAErSpo55Q8Q=5p6_+uu7ahnw+53ibVDNRXxrzRV9QnUr_9EUfw@mail.gmail.com
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=198057
    Reported-and-Tested-by: Christian Zigotzky <chzigotzky@xenosoft.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 14e0ea1ff38b..303c0cb0550c 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -2215,22 +2215,27 @@ static unsigned next_fn(struct pci_bus *bus, struct pci_dev *dev, unsigned fn)
 
 static int only_one_child(struct pci_bus *bus)
 {
-	struct pci_dev *parent = bus->self;
+	struct pci_dev *bridge = bus->self;
 
-	if (!parent || !pci_is_pcie(parent))
+	/*
+	 * Systems with unusual topologies set PCI_SCAN_ALL_PCIE_DEVS so
+	 * we scan for all possible devices, not just Device 0.
+	 */
+	if (pci_has_flag(PCI_SCAN_ALL_PCIE_DEVS))
 		return 0;
-	if (pci_pcie_type(parent) == PCI_EXP_TYPE_ROOT_PORT)
-		return 1;
 
 	/*
-	 * PCIe downstream ports are bridges that normally lead to only a
-	 * device 0, but if PCI_SCAN_ALL_PCIE_DEVS is set, scan all
-	 * possible devices, not just device 0.  See PCIe spec r3.0,
-	 * sec 7.3.1.
+	 * A PCIe Downstream Port normally leads to a Link with only Device
+	 * 0 on it (PCIe spec r3.1, sec 7.3.1).  As an optimization, scan
+	 * only for Device 0 in that situation.
+	 *
+	 * Checking has_secondary_link is a hack to identify Downstream
+	 * Ports because sometimes Switches are configured such that the
+	 * PCIe Port Type labels are backwards.
 	 */
-	if (parent->has_secondary_link &&
-	    !pci_has_flag(PCI_SCAN_ALL_PCIE_DEVS))
+	if (bridge && pci_is_pcie(bridge) && bridge->has_secondary_link)
 		return 1;
+
 	return 0;
 }
 

commit c46fd358070f22ba68d6e74c22016a33b914c20a
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Nov 28 16:43:50 2017 -0600

    PCI/ASPM: Enable Latency Tolerance Reporting when supported
    
    Enable Latency Tolerance Reporting (LTR).  Note that LTR must be enabled in
    the Root Port first, and must not be enabled in any downstream device
    unless the Root Port and all intermediate Switches also support LTR.
    See PCIe r3.1, sec 6.18.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Vidya Sagar <vidyas@nvidia.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 14e0ea1ff38b..3761b1303529 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1875,6 +1875,38 @@ static void pci_configure_relaxed_ordering(struct pci_dev *dev)
 	}
 }
 
+static void pci_configure_ltr(struct pci_dev *dev)
+{
+#ifdef CONFIG_PCIEASPM
+	u32 cap;
+	struct pci_dev *bridge;
+
+	if (!pci_is_pcie(dev))
+		return;
+
+	pcie_capability_read_dword(dev, PCI_EXP_DEVCAP2, &cap);
+	if (!(cap & PCI_EXP_DEVCAP2_LTR))
+		return;
+
+	/*
+	 * Software must not enable LTR in an Endpoint unless the Root
+	 * Complex and all intermediate Switches indicate support for LTR.
+	 * PCIe r3.1, sec 6.18.
+	 */
+	if (pci_pcie_type(dev) == PCI_EXP_TYPE_ROOT_PORT)
+		dev->ltr_path = 1;
+	else {
+		bridge = pci_upstream_bridge(dev);
+		if (bridge && bridge->ltr_path)
+			dev->ltr_path = 1;
+	}
+
+	if (dev->ltr_path)
+		pcie_capability_set_word(dev, PCI_EXP_DEVCTL2,
+					 PCI_EXP_DEVCTL2_LTR_EN);
+#endif
+}
+
 static void pci_configure_device(struct pci_dev *dev)
 {
 	struct hotplug_params hpp;
@@ -1883,6 +1915,7 @@ static void pci_configure_device(struct pci_dev *dev)
 	pci_configure_mps(dev);
 	pci_configure_extended_tags(dev, NULL);
 	pci_configure_relaxed_ordering(dev);
+	pci_configure_ltr(dev);
 
 	memset(&hpp, 0, sizeof(hpp));
 	ret = pci_get_hp_params(dev, &hpp);

commit 1c02ea81006548a5cd55f7ac6df77cf8d7b08e00
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Fri Oct 13 21:35:44 2017 +0300

    PCI: Distribute available buses to hotplug-capable bridges
    
    System BIOS sometimes allocates extra bus space for hotplug-capable PCIe
    root/downstream ports. This space is needed if the device plugged to the
    port will have more hotplug-capable downstream ports. A good example of
    this is Thunderbolt. Each Thunderbolt device contains a PCIe switch and
    one or more hotplug-capable PCIe downstream ports where the daisy chain
    can be extended.
    
    Currently Linux only allocates minimal bus space to make sure all the
    enumerated devices barely fit there. The BIOS reserved extra space is
    not taken into consideration at all. Because of this we run out of bus
    space pretty quickly when more PCIe devices are attached to hotplug
    downstream ports in order to extend the chain.
    
    Modify the PCI core so we distribute the available BIOS allocated bus space
    equally between hotplug-capable bridges to make sure there is enough bus
    space for extending the hierarchy later on.
    
    Update kernel docs of the affected functions.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 1f82f49c0bb3..14e0ea1ff38b 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -959,7 +959,21 @@ static void pci_enable_crs(struct pci_dev *pdev)
 					 PCI_EXP_RTCTL_CRSSVE);
 }
 
+static unsigned int pci_scan_child_bus_extend(struct pci_bus *bus,
+					      unsigned int available_buses);
+
 /*
+ * pci_scan_bridge_extend() - Scan buses behind a bridge
+ * @bus: Parent bus the bridge is on
+ * @dev: Bridge itself
+ * @max: Starting subordinate number of buses behind this bridge
+ * @available_buses: Total number of buses available for this bridge and
+ *		     the devices below. After the minimal bus space has
+ *		     been allocated the remaining buses will be
+ *		     distributed equally between hotplug-capable bridges.
+ * @pass: Either %0 (scan already configured bridges) or %1 (scan bridges
+ *        that need to be reconfigured.
+ *
  * If it's a bridge, configure it and scan the bus behind it.
  * For CardBus bridges, we don't scan behind as the devices will
  * be handled by the bridge driver itself.
@@ -969,7 +983,9 @@ static void pci_enable_crs(struct pci_dev *pdev)
  * them, we proceed to assigning numbers to the remaining buses in
  * order to avoid overlaps between old and new bus numbers.
  */
-int pci_scan_bridge(struct pci_bus *bus, struct pci_dev *dev, int max, int pass)
+static int pci_scan_bridge_extend(struct pci_bus *bus, struct pci_dev *dev,
+				  int max, unsigned int available_buses,
+				  int pass)
 {
 	struct pci_bus *child;
 	int is_cardbus = (dev->hdr_type == PCI_HEADER_TYPE_CARDBUS);
@@ -1080,6 +1096,9 @@ int pci_scan_bridge(struct pci_bus *bus, struct pci_dev *dev, int max, int pass)
 						bus->busn_res.end);
 		}
 		max++;
+		if (available_buses)
+			available_buses--;
+
 		buses = (buses & 0xff000000)
 		      | ((unsigned int)(child->primary)     <<  0)
 		      | ((unsigned int)(child->busn_res.start)   <<  8)
@@ -1101,7 +1120,7 @@ int pci_scan_bridge(struct pci_bus *bus, struct pci_dev *dev, int max, int pass)
 
 		if (!is_cardbus) {
 			child->bridge_ctl = bctl;
-			max = pci_scan_child_bus(child);
+			max = pci_scan_child_bus_extend(child, available_buses);
 		} else {
 			/*
 			 * For CardBus bridges, we leave 4 bus numbers
@@ -1169,6 +1188,28 @@ int pci_scan_bridge(struct pci_bus *bus, struct pci_dev *dev, int max, int pass)
 
 	return max;
 }
+
+/*
+ * pci_scan_bridge() - Scan buses behind a bridge
+ * @bus: Parent bus the bridge is on
+ * @dev: Bridge itself
+ * @max: Starting subordinate number of buses behind this bridge
+ * @pass: Either %0 (scan already configured bridges) or %1 (scan bridges
+ *        that need to be reconfigured.
+ *
+ * If it's a bridge, configure it and scan the bus behind it.
+ * For CardBus bridges, we don't scan behind as the devices will
+ * be handled by the bridge driver itself.
+ *
+ * We need to process bridges in two passes -- first we scan those
+ * already configured by the BIOS and after we are done with all of
+ * them, we proceed to assigning numbers to the remaining buses in
+ * order to avoid overlaps between old and new bus numbers.
+ */
+int pci_scan_bridge(struct pci_bus *bus, struct pci_dev *dev, int max, int pass)
+{
+	return pci_scan_bridge_extend(bus, dev, max, 0, pass);
+}
 EXPORT_SYMBOL(pci_scan_bridge);
 
 /*
@@ -2397,9 +2438,24 @@ void __weak pcibios_fixup_bus(struct pci_bus *bus)
        /* nothing to do, expected to be removed in the future */
 }
 
-unsigned int pci_scan_child_bus(struct pci_bus *bus)
+/**
+ * pci_scan_child_bus_extend() - Scan devices below a bus
+ * @bus: Bus to scan for devices
+ * @available_buses: Total number of buses available (%0 does not try to
+ *		     extend beyond the minimal)
+ *
+ * Scans devices below @bus including subordinate buses. Returns new
+ * subordinate number including all the found devices. Passing
+ * @available_buses causes the remaining bus space to be distributed
+ * equally between hotplug-capable bridges to allow future extension of the
+ * hierarchy.
+ */
+static unsigned int pci_scan_child_bus_extend(struct pci_bus *bus,
+					      unsigned int available_buses)
 {
-	unsigned int devfn, max = bus->busn_res.start;
+	unsigned int used_buses, normal_bridges = 0, hotplug_bridges = 0;
+	unsigned int start = bus->busn_res.start;
+	unsigned int devfn, cmax, max = start;
 	struct pci_dev *dev;
 
 	dev_dbg(&bus->dev, "scanning bus\n");
@@ -2409,7 +2465,8 @@ unsigned int pci_scan_child_bus(struct pci_bus *bus)
 		pci_scan_slot(bus, devfn);
 
 	/* Reserve buses for SR-IOV capability. */
-	max += pci_iov_bus_range(bus);
+	used_buses = pci_iov_bus_range(bus);
+	max += used_buses;
 
 	/*
 	 * After performing arch-dependent fixup of the bus, look behind
@@ -2421,29 +2478,73 @@ unsigned int pci_scan_child_bus(struct pci_bus *bus)
 		bus->is_added = 1;
 	}
 
+	/*
+	 * Calculate how many hotplug bridges and normal bridges there
+	 * are on this bus. We will distribute the additional available
+	 * buses between hotplug bridges.
+	 */
+	for_each_pci_bridge(dev, bus) {
+		if (dev->is_hotplug_bridge)
+			hotplug_bridges++;
+		else
+			normal_bridges++;
+	}
+
 	/*
 	 * Scan bridges that are already configured. We don't touch them
 	 * unless they are misconfigured (which will be done in the second
 	 * scan below).
 	 */
-	for_each_pci_bridge(dev, bus)
-		max = pci_scan_bridge(bus, dev, max, 0);
+	for_each_pci_bridge(dev, bus) {
+		cmax = max;
+		max = pci_scan_bridge_extend(bus, dev, max, 0, 0);
+		used_buses += cmax - max;
+	}
 
 	/* Scan bridges that need to be reconfigured */
-	for_each_pci_bridge(dev, bus)
-		max = pci_scan_bridge(bus, dev, max, 1);
+	for_each_pci_bridge(dev, bus) {
+		unsigned int buses = 0;
+
+		if (!hotplug_bridges && normal_bridges == 1) {
+			/*
+			 * There is only one bridge on the bus (upstream
+			 * port) so it gets all available buses which it
+			 * can then distribute to the possible hotplug
+			 * bridges below.
+			 */
+			buses = available_buses;
+		} else if (dev->is_hotplug_bridge) {
+			/*
+			 * Distribute the extra buses between hotplug
+			 * bridges if any.
+			 */
+			buses = available_buses / hotplug_bridges;
+			buses = min(buses, available_buses - used_buses);
+		}
+
+		cmax = max;
+		max = pci_scan_bridge_extend(bus, dev, cmax, buses, 1);
+		used_buses += max - cmax;
+	}
 
 	/*
 	 * Make sure a hotplug bridge has at least the minimum requested
-	 * number of buses.
+	 * number of buses but allow it to grow up to the maximum available
+	 * bus number of there is room.
 	 */
-	if (bus->self && bus->self->is_hotplug_bridge && pci_hotplug_bus_size) {
-		if (max - bus->busn_res.start < pci_hotplug_bus_size - 1)
-			max = bus->busn_res.start + pci_hotplug_bus_size - 1;
-
-		/* Do not allocate more buses than we have room left */
-		if (max > bus->busn_res.end)
-			max = bus->busn_res.end;
+	if (bus->self && bus->self->is_hotplug_bridge) {
+		used_buses = max_t(unsigned int, available_buses,
+				   pci_hotplug_bus_size - 1);
+		if (max - start < used_buses) {
+			max = start + used_buses;
+
+			/* Do not allocate more buses than we have room left */
+			if (max > bus->busn_res.end)
+				max = bus->busn_res.end;
+
+			dev_dbg(&bus->dev, "%pR extended by %#02x\n",
+				&bus->busn_res, max - start);
+		}
 	}
 
 	/*
@@ -2456,6 +2557,18 @@ unsigned int pci_scan_child_bus(struct pci_bus *bus)
 	dev_dbg(&bus->dev, "bus scan returning with max=%02x\n", max);
 	return max;
 }
+
+/**
+ * pci_scan_child_bus() - Scan devices below a bus
+ * @bus: Bus to scan for devices
+ *
+ * Scans devices below @bus including subordinate buses. Returns new
+ * subordinate number including all the found devices.
+ */
+unsigned int pci_scan_child_bus(struct pci_bus *bus)
+{
+	return pci_scan_child_bus_extend(bus, 0);
+}
 EXPORT_SYMBOL_GPL(pci_scan_child_bus);
 
 /**
@@ -2753,6 +2866,7 @@ int pci_hp_add_bridge(struct pci_dev *dev)
 {
 	struct pci_bus *parent = dev->bus;
 	int busnr, start = parent->busn_res.start;
+	unsigned int available_buses = 0;
 	int end = parent->busn_res.end;
 
 	for (busnr = start; busnr <= end; busnr++) {
@@ -2767,8 +2881,14 @@ int pci_hp_add_bridge(struct pci_dev *dev)
 	/* Scan bridges that are already configured */
 	busnr = pci_scan_bridge(parent, dev, busnr, 0);
 
+	/*
+	 * Distribute the available bus numbers between hotplug-capable
+	 * bridges to make extending the chain later possible.
+	 */
+	available_buses = end - busnr;
+
 	/* Scan bridges that need to be reconfigured */
-	pci_scan_bridge(parent, dev, busnr, 1);
+	pci_scan_bridge_extend(parent, dev, busnr, available_buses, 1);
 
 	if (!dev->subordinate)
 		return -1;

commit a20c7f36bd3d20d245616ae223bb9d05dfb6f050
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Fri Oct 13 21:35:43 2017 +0300

    PCI: Do not allocate more buses than available in parent
    
    One can ask more buses to be reserved for hotplug bridges by passing
    pci=hpbussize=N in the kernel command line.  If the parent bus does not
    have enough bus space available we incorrectly create child bus with the
    requested number of subordinate buses.
    
    In the example below hpbussize is set to one more than we have available
    buses in the root port:
    
      pci 0000:07:00.0: [8086:1578] type 01 class 0x060400
      pci 0000:07:00.0: scanning [bus 00-00] behind bridge, pass 0
      pci 0000:07:00.0: bridge configuration invalid ([bus 00-00]), reconfiguring
      pci 0000:07:00.0: scanning [bus 00-00] behind bridge, pass 1
      pci_bus 0000:08: busn_res: can not insert [bus 08-ff] under [bus 07-3f] (conflicts with (null) [bus 07-3f])
      pci_bus 0000:08: scanning bus
      ...
      pci_bus 0000:0a: bus scan returning with max=40
      pci_bus 0000:0a: busn_res: [bus 0a-ff] end is updated to 40
      pci_bus 0000:0a: [bus 0a-40] partially hidden behind bridge 0000:07 [bus 07-3f]
      pci_bus 0000:08: bus scan returning with max=40
      pci_bus 0000:08: busn_res: [bus 08-ff] end is updated to 40
    
    Instead of allowing this, limit the subordinate number to be less than or
    equal the maximum subordinate number allocated for the parent bus (if it
    has any).
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    [bhelgaas: remove irrelevant dmesg messages]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 61813938d186..1f82f49c0bb3 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1076,7 +1076,8 @@ int pci_scan_bridge(struct pci_bus *bus, struct pci_dev *dev, int max, int pass)
 			child = pci_add_new_bus(bus, dev, max+1);
 			if (!child)
 				goto out;
-			pci_bus_insert_busn_res(child, max+1, 0xff);
+			pci_bus_insert_busn_res(child, max+1,
+						bus->busn_res.end);
 		}
 		max++;
 		buses = (buses & 0xff000000)
@@ -2439,6 +2440,10 @@ unsigned int pci_scan_child_bus(struct pci_bus *bus)
 	if (bus->self && bus->self->is_hotplug_bridge && pci_hotplug_bus_size) {
 		if (max - bus->busn_res.start < pci_hotplug_bus_size - 1)
 			max = bus->busn_res.start + pci_hotplug_bus_size - 1;
+
+		/* Do not allocate more buses than we have room left */
+		if (max > bus->busn_res.end)
+			max = bus->busn_res.end;
 	}
 
 	/*

commit 4147c2fd9b12ae1e0bdbb2dbb9a9163c94a10a22
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Fri Oct 13 21:35:42 2017 +0300

    PCI: Open-code the two pass loop when scanning bridges
    
    The current scanning code is really hard to understand because it calls
    the same function in a loop where pass value is changed without any
    comments explaining it:
    
      for (pass = 0; pass < 2; pass++)
        for_each_pci_bridge(dev, bus)
          max = pci_scan_bridge(bus, dev, max, pass);
    
    Unfamiliar reader cannot tell easily what is the purpose of this loop
    without looking at internals of pci_scan_bridge().
    
    In order to make this bit easier to understand, open-code the loop in
    pci_scan_child_bus() and pci_hp_add_bridge() with added comments.
    
    No functional changes intended.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 62d45a76f663..61813938d186 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -2398,7 +2398,7 @@ void __weak pcibios_fixup_bus(struct pci_bus *bus)
 
 unsigned int pci_scan_child_bus(struct pci_bus *bus)
 {
-	unsigned int devfn, pass, max = bus->busn_res.start;
+	unsigned int devfn, max = bus->busn_res.start;
 	struct pci_dev *dev;
 
 	dev_dbg(&bus->dev, "scanning bus\n");
@@ -2420,9 +2420,17 @@ unsigned int pci_scan_child_bus(struct pci_bus *bus)
 		bus->is_added = 1;
 	}
 
-	for (pass = 0; pass < 2; pass++)
-		for_each_pci_bridge(dev, bus)
-			max = pci_scan_bridge(bus, dev, max, pass);
+	/*
+	 * Scan bridges that are already configured. We don't touch them
+	 * unless they are misconfigured (which will be done in the second
+	 * scan below).
+	 */
+	for_each_pci_bridge(dev, bus)
+		max = pci_scan_bridge(bus, dev, max, 0);
+
+	/* Scan bridges that need to be reconfigured */
+	for_each_pci_bridge(dev, bus)
+		max = pci_scan_bridge(bus, dev, max, 1);
 
 	/*
 	 * Make sure a hotplug bridge has at least the minimum requested
@@ -2739,7 +2747,7 @@ void __init pci_sort_breadthfirst(void)
 int pci_hp_add_bridge(struct pci_dev *dev)
 {
 	struct pci_bus *parent = dev->bus;
-	int pass, busnr, start = parent->busn_res.start;
+	int busnr, start = parent->busn_res.start;
 	int end = parent->busn_res.end;
 
 	for (busnr = start; busnr <= end; busnr++) {
@@ -2750,8 +2758,13 @@ int pci_hp_add_bridge(struct pci_dev *dev)
 		dev_err(&dev->dev, "No bus number available for hot-added bridge\n");
 		return -1;
 	}
-	for (pass = 0; pass < 2; pass++)
-		busnr = pci_scan_bridge(parent, dev, busnr, pass);
+
+	/* Scan bridges that are already configured */
+	busnr = pci_scan_bridge(parent, dev, busnr, 0);
+
+	/* Scan bridges that need to be reconfigured */
+	pci_scan_bridge(parent, dev, busnr, 1);
+
 	if (!dev->subordinate)
 		return -1;
 

commit 95e3ba9772331502cc33f1e1d4a96f3310e2f31e
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Fri Oct 13 21:35:41 2017 +0300

    PCI: Move pci_hp_add_bridge() to drivers/pci/probe.c
    
    There is not much point of having a file with a single function in it.
    Instead we can just move pci_hp_add_bridge() to drivers/pci/probe.c and
    make it available always when PCI core is enabled.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    [bhelgaas: convert printk to dev_err()]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index cdc2f83c11c5..62d45a76f663 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -2735,3 +2735,26 @@ void __init pci_sort_breadthfirst(void)
 {
 	bus_sort_breadthfirst(&pci_bus_type, &pci_sort_bf_cmp);
 }
+
+int pci_hp_add_bridge(struct pci_dev *dev)
+{
+	struct pci_bus *parent = dev->bus;
+	int pass, busnr, start = parent->busn_res.start;
+	int end = parent->busn_res.end;
+
+	for (busnr = start; busnr <= end; busnr++) {
+		if (!pci_find_bus(pci_domain_nr(parent), busnr))
+			break;
+	}
+	if (busnr-- > end) {
+		dev_err(&dev->dev, "No bus number available for hot-added bridge\n");
+		return -1;
+	}
+	for (pass = 0; pass < 2; pass++)
+		busnr = pci_scan_bridge(parent, dev, busnr, pass);
+	if (!dev->subordinate)
+		return -1;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(pci_hp_add_bridge);

commit 24a0c654d7d6063301c51361f911369264342b3c
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Fri Oct 20 15:38:54 2017 -0500

    PCI: Add for_each_pci_bridge() helper
    
    The following pattern is often used:
    
      list_for_each_entry(dev, &bus->devices, bus_list) {
        if (pci_is_bridge(dev)) {
          ...
        }
      }
    
    Add a for_each_pci_bridge() helper to make that code easier to write and
    read by reducing indentation level.  It also saves one or few lines of code
    in each occurrence.
    
    Convert PCI core parts here at the same time.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    [bhelgaas: fold in http://lkml.kernel.org/r/20171013165352.25550-1-andriy.shevchenko@linux.intel.com]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index ff94b69738a8..cdc2f83c11c5 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -2421,10 +2421,8 @@ unsigned int pci_scan_child_bus(struct pci_bus *bus)
 	}
 
 	for (pass = 0; pass < 2; pass++)
-		list_for_each_entry(dev, &bus->devices, bus_list) {
-			if (pci_is_bridge(dev))
-				max = pci_scan_bridge(bus, dev, max, pass);
-		}
+		for_each_pci_bridge(dev, bus)
+			max = pci_scan_bridge(bus, dev, max, pass);
 
 	/*
 	 * Make sure a hotplug bridge has at least the minimum requested

commit 0d519f2d1ed1f11e49abc88cfcf6cf13b83ba14c
Merge: 0756b7fbb696 cf2d804110d3
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Sep 8 15:47:43 2017 -0700

    Merge tag 'pci-v4.14-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI updates from Bjorn Helgaas:
    
     - add enhanced Downstream Port Containment support, which prints more
       details about Root Port Programmed I/O errors (Dongdong Liu)
    
     - add Layerscape ls1088a and ls2088a support (Hou Zhiqiang)
    
     - add MediaTek MT2712 and MT7622 support (Ryder Lee)
    
     - add MediaTek MT2712 and MT7622 MSI support (Honghui Zhang)
    
     - add Qualcom IPQ8074 support (Varadarajan Narayanan)
    
     - add R-Car r8a7743/5 device tree support (Biju Das)
    
     - add Rockchip per-lane PHY support for better power management (Shawn
       Lin)
    
     - fix IRQ mapping for hot-added devices by replacing the
       pci_fixup_irqs() boot-time design with a host bridge hook called at
       probe-time (Lorenzo Pieralisi, Matthew Minter)
    
     - fix race when enabling two devices that results in upstream bridge
       not being enabled correctly (Srinath Mannam)
    
     - fix pciehp power fault infinite loop (Keith Busch)
    
     - fix SHPC bridge MSI hotplug events by enabling bus mastering
       (Aleksandr Bezzubikov)
    
     - fix a VFIO issue by correcting PCIe capability sizes (Alex
       Williamson)
    
     - fix an INTD issue on Xilinx and possibly other drivers by unifying
       INTx IRQ domain support (Paul Burton)
    
     - avoid IOMMU stalls by marking AMD Stoney GPU ATS as broken (Joerg
       Roedel)
    
     - allow APM X-Gene device assignment to guests by adding an ACS quirk
       (Feng Kan)
    
     - fix driver crashes by disabling Extended Tags on Broadcom HT2100
       (Extended Tags support is required for PCIe Receivers but not
       Requesters, and we now enable them by default when Requesters support
       them) (Sinan Kaya)
    
     - fix MSIs for devices that use phantom RIDs for DMA by assuming MSIs
       use the real Requester ID (not a phantom RID) (Robin Murphy)
    
     - prevent assignment of Intel VMD children to guests (which may be
       supported eventually, but isn't yet) by not associating an IOMMU with
       them (Jon Derrick)
    
     - fix Intel VMD suspend/resume by releasing IRQs on suspend (Scott
       Bauer)
    
     - fix a Function-Level Reset issue with Intel 750 NVMe by waiting
       longer (up to 60sec instead of 1sec) for device to become ready
       (Sinan Kaya)
    
     - fix a Function-Level Reset issue on iProc Stingray by working around
       hardware defects in the CRS implementation (Oza Pawandeep)
    
     - fix an issue with Intel NVMe P3700 after an iProc reset by adding a
       delay during shutdown (Oza Pawandeep)
    
     - fix a Microsoft Hyper-V lockdep issue by polling instead of blocking
       in compose_msi_msg() (Stephen Hemminger)
    
     - fix a wireless LAN driver timeout by clearing DesignWare MSI
       interrupt status after it is handled, not before (Faiz Abbas)
    
     - fix DesignWare ATU enable checking (Jisheng Zhang)
    
     - reduce Layerscape dependencies on the bootloader by doing more
       initialization in the driver (Hou Zhiqiang)
    
     - improve Intel VMD performance allowing allocation of more IRQ vectors
       than present CPUs (Keith Busch)
    
     - improve endpoint framework support for initial DMA mask, different
       BAR sizes, configurable page sizes, MSI, test driver, etc (Kishon
       Vijay Abraham I, Stan Drozd)
    
     - rework CRS support to add periodic messages while we poll during
       enumeration and after Function-Level Reset and prepare for possible
       other uses of CRS (Sinan Kaya)
    
     - clean up Root Port AER handling by removing unnecessary code and
       moving error handler methods to struct pcie_port_service_driver
       (Christoph Hellwig)
    
     - clean up error handling paths in various drivers (Bjorn Andersson,
       Fabio Estevam, Gustavo A. R. Silva, Harunobu Kurokawa, Jeffy Chen,
       Lorenzo Pieralisi, Sergei Shtylyov)
    
     - clean up SR-IOV resource handling by disabling VF decoding before
       updating the corresponding resource structs (Gavin Shan)
    
     - clean up DesignWare-based drivers by unifying quirks to update Class
       Code and Interrupt Pin and related handling of write-protected
       registers (Hou Zhiqiang)
    
     - clean up by adding empty generic pcibios_align_resource() and
       pcibios_fixup_bus() and removing empty arch-specific implementations
       (Palmer Dabbelt)
    
     - request exclusive reset control for several drivers to allow cleanup
       elsewhere (Philipp Zabel)
    
     - constify various structures (Arvind Yadav, Bhumika Goyal)
    
     - convert from full_name() to %pOF (Rob Herring)
    
     - remove unused variables from iProc, HiSi, Altera, Keystone (Shawn
       Lin)
    
    * tag 'pci-v4.14-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (170 commits)
      PCI: xgene: Clean up whitespace
      PCI: xgene: Define XGENE_PCI_EXP_CAP and use generic PCI_EXP_RTCTL offset
      PCI: xgene: Fix platform_get_irq() error handling
      PCI: xilinx-nwl: Fix platform_get_irq() error handling
      PCI: rockchip: Fix platform_get_irq() error handling
      PCI: altera: Fix platform_get_irq() error handling
      PCI: spear13xx: Fix platform_get_irq() error handling
      PCI: artpec6: Fix platform_get_irq() error handling
      PCI: armada8k: Fix platform_get_irq() error handling
      PCI: dra7xx: Fix platform_get_irq() error handling
      PCI: exynos: Fix platform_get_irq() error handling
      PCI: iproc: Clean up whitespace
      PCI: iproc: Rename PCI_EXP_CAP to IPROC_PCI_EXP_CAP
      PCI: iproc: Add 500ms delay during device shutdown
      PCI: Fix typos and whitespace errors
      PCI: Remove unused "res" variable from pci_resource_io()
      PCI: Correct kernel-doc of pci_vpd_srdt_size(), pci_vpd_srdt_tag()
      PCI/AER: Reformat AER register definitions
      iommu/vt-d: Prevent VMD child devices from being remapping targets
      x86/PCI: Use is_vmd() rather than relying on the domain number
      ...

commit 9198407e23ec89f0e1562f439771aeea83345d0d
Merge: d872694bac21 c775697b713b
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Sep 7 13:24:19 2017 -0500

    Merge branch 'pci/resource' into next
    
    * pci/resource:
      microblaze/PCI: Remove pcibios_setup_bus_{self/devices} dead code
      ARC: Remove empty kernel/pcibios.c
      PCI: Add a generic weak pcibios_align_resource()
      PCI: Add a generic weak pcibios_fixup_bus()

commit e78e661fae3296c4e20a029d6bd04c5e925c72de
Author: Sinan Kaya <okaya@codeaurora.org>
Date:   Tue Aug 29 14:45:45 2017 -0500

    PCI: Warn periodically while waiting for non-CRS ("device ready") status
    
    Add a print statement in pci_bus_wait_crs() so that user observes the
    progress of device polling instead of silently waiting for timeout to be
    reached.
    
    Signed-off-by: Sinan Kaya <okaya@codeaurora.org>
    [bhelgaas: check for timeout first so we don't print "waiting, giving up",
    always print time we've slept (not the actual timeout, print a "ready"
    message if we've printed a "waiting" message]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index f09d8cd3df7a..9b8a445b9294 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1876,11 +1876,16 @@ static bool pci_bus_wait_crs(struct pci_bus *bus, int devfn, u32 *l,
 	 */
 	while (pci_bus_crs_vendor_id(*l)) {
 		if (delay > timeout) {
-			printk(KERN_WARNING "pci %04x:%02x:%02x.%d: not responding\n",
-			       pci_domain_nr(bus), bus->number, PCI_SLOT(devfn),
-			       PCI_FUNC(devfn));
+			pr_warn("pci %04x:%02x:%02x.%d: not ready after %dms; giving up\n",
+				pci_domain_nr(bus), bus->number,
+				PCI_SLOT(devfn), PCI_FUNC(devfn), delay - 1);
+
 			return false;
 		}
+		if (delay >= 1000)
+			pr_info("pci %04x:%02x:%02x.%d: not ready after %dms; waiting\n",
+				pci_domain_nr(bus), bus->number,
+				PCI_SLOT(devfn), PCI_FUNC(devfn), delay - 1);
 
 		msleep(delay);
 		delay *= 2;
@@ -1889,6 +1894,11 @@ static bool pci_bus_wait_crs(struct pci_bus *bus, int devfn, u32 *l,
 			return false;
 	}
 
+	if (delay >= 1000)
+		pr_info("pci %04x:%02x:%02x.%d: ready after %dms\n",
+			pci_domain_nr(bus), bus->number,
+			PCI_SLOT(devfn), PCI_FUNC(devfn), delay - 1);
+
 	return true;
 }
 

commit 6a802ef0af94e7148c3fef71f5502654b65ed46a
Author: Sinan Kaya <okaya@codeaurora.org>
Date:   Tue Aug 29 14:45:44 2017 -0500

    PCI: Factor out pci_bus_wait_crs()
    
    Configuration Request Retry Status (CRS) was previously hidden inside
    pci_bus_read_dev_vendor_id().  We want to add support for CRS in other
    situations, such as waiting for a device to become ready after a Function
    Level Reset.
    
    Move CRS handling into pci_bus_wait_crs() so it can be called from other
    places.
    
    Signed-off-by: Sinan Kaya <okaya@codeaurora.org>
    [bhelgaas: pass pointer, not value, to pci_bus_wait_crs() so caller gets
    correct Vendor ID]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 5e001bbc2392..f09d8cd3df7a 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1858,30 +1858,24 @@ static bool pci_bus_crs_vendor_id(u32 l)
 	return (l & 0xffff) == 0x0001;
 }
 
-bool pci_bus_read_dev_vendor_id(struct pci_bus *bus, int devfn, u32 *l,
-				int crs_timeout)
+static bool pci_bus_wait_crs(struct pci_bus *bus, int devfn, u32 *l,
+			     int timeout)
 {
 	int delay = 1;
 
-	if (pci_bus_read_config_dword(bus, devfn, PCI_VENDOR_ID, l))
-		return false;
+	if (!pci_bus_crs_vendor_id(*l))
+		return true;	/* not a CRS completion */
 
-	/* some broken boards return 0 or ~0 if a slot is empty: */
-	if (*l == 0xffffffff || *l == 0x00000000 ||
-	    *l == 0x0000ffff || *l == 0xffff0000)
-		return false;
+	if (!timeout)
+		return false;	/* CRS, but caller doesn't want to wait */
 
 	/*
-	 * Configuration Request Retry Status.  Some root ports return the
-	 * actual device ID instead of the synthetic ID (0xFFFF) required
-	 * by the PCIe spec.  Ignore the device ID and only check for
-	 * (vendor id == 1).
+	 * We got the reserved Vendor ID that indicates a completion with
+	 * Configuration Request Retry Status (CRS).  Retry until we get a
+	 * valid Vendor ID or we time out.
 	 */
 	while (pci_bus_crs_vendor_id(*l)) {
-		if (!crs_timeout)
-			return false;
-
-		if (delay > crs_timeout) {
+		if (delay > timeout) {
 			printk(KERN_WARNING "pci %04x:%02x:%02x.%d: not responding\n",
 			       pci_domain_nr(bus), bus->number, PCI_SLOT(devfn),
 			       PCI_FUNC(devfn));
@@ -1897,6 +1891,23 @@ bool pci_bus_read_dev_vendor_id(struct pci_bus *bus, int devfn, u32 *l,
 
 	return true;
 }
+
+bool pci_bus_read_dev_vendor_id(struct pci_bus *bus, int devfn, u32 *l,
+				int timeout)
+{
+	if (pci_bus_read_config_dword(bus, devfn, PCI_VENDOR_ID, l))
+		return false;
+
+	/* some broken boards return 0 or ~0 if a slot is empty: */
+	if (*l == 0xffffffff || *l == 0x00000000 ||
+	    *l == 0x0000ffff || *l == 0xffff0000)
+		return false;
+
+	if (pci_bus_crs_vendor_id(*l))
+		return pci_bus_wait_crs(bus, devfn, l, timeout);
+
+	return true;
+}
 EXPORT_SYMBOL(pci_bus_read_dev_vendor_id);
 
 /*

commit 62bc6a6f7468bc6d6cb39177504e79df401aea76
Author: Sinan Kaya <okaya@codeaurora.org>
Date:   Tue Aug 29 14:45:44 2017 -0500

    PCI: Add pci_bus_crs_vendor_id() to detect CRS response data
    
    Add pci_bus_crs_vendor_id() to determine whether data returned for a config
    read of the Vendor ID indicates a Configuration Request Retry Status (CRS)
    response.
    
    Per PCIe r3.1, sec 2.3.2, this data is only returned if:
    
      - CRS Software Visibility is enabled,
      - a config read includes both bytes of the Vendor ID, and
      - the read receives a CRS completion
    
    Signed-off-by: Sinan Kaya <okaya@codeaurora.org>
    [bhelgaas: changelog, change name to pci_bus_crs_vendor_id(), make static
    in probe.c, use it in pci_bus_read_dev_vendor_id()]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 150093817c59..5e001bbc2392 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1853,6 +1853,11 @@ struct pci_dev *pci_alloc_dev(struct pci_bus *bus)
 }
 EXPORT_SYMBOL(pci_alloc_dev);
 
+static bool pci_bus_crs_vendor_id(u32 l)
+{
+	return (l & 0xffff) == 0x0001;
+}
+
 bool pci_bus_read_dev_vendor_id(struct pci_bus *bus, int devfn, u32 *l,
 				int crs_timeout)
 {
@@ -1872,7 +1877,7 @@ bool pci_bus_read_dev_vendor_id(struct pci_bus *bus, int devfn, u32 *l,
 	 * by the PCIe spec.  Ignore the device ID and only check for
 	 * (vendor id == 1).
 	 */
-	while ((*l & 0xffff) == 0x0001) {
+	while (pci_bus_crs_vendor_id(*l)) {
 		if (!crs_timeout)
 			return false;
 

commit 9f98275671a58516f87b7eb02a3497635861930a
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Aug 29 14:45:43 2017 -0500

    PCI: Always check for non-CRS response before timeout
    
    While waiting for a device to become ready (i.e., to return a non-CRS
    completion to a read of its Vendor ID), if we got a valid response to the
    very last read before timing out, we printed a warning and gave up on the
    device even though it was actually ready.
    
    For a typical 60s timeout, we wait about 65s (it's not exact because of the
    exponential backoff), but we treated devices that became ready between 33s
    and 65s as though they failed.
    
    Move the Device ID read later so we check whether the device is ready
    before checking for a timeout.
    
    Thanks to Sinan Kaya <okaya@codeaurora.org>, reorder reads so we always
    check device presence after sleep, since it's pointless to sleep unless we
    recheck afterwards.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index c81c9835f4c7..150093817c59 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1876,17 +1876,18 @@ bool pci_bus_read_dev_vendor_id(struct pci_bus *bus, int devfn, u32 *l,
 		if (!crs_timeout)
 			return false;
 
-		msleep(delay);
-		delay *= 2;
-		if (pci_bus_read_config_dword(bus, devfn, PCI_VENDOR_ID, l))
-			return false;
-		/* Card hasn't responded in 60 seconds?  Must be stuck. */
 		if (delay > crs_timeout) {
 			printk(KERN_WARNING "pci %04x:%02x:%02x.%d: not responding\n",
 			       pci_domain_nr(bus), bus->number, PCI_SLOT(devfn),
 			       PCI_FUNC(devfn));
 			return false;
 		}
+
+		msleep(delay);
+		delay *= 2;
+
+		if (pci_bus_read_config_dword(bus, devfn, PCI_VENDOR_ID, l))
+			return false;
 	}
 
 	return true;

commit a99b646afa8a02571ea298bedca6592d818229cd
Author: dingtianhong <dingtianhong@huawei.com>
Date:   Tue Aug 15 11:23:23 2017 +0800

    PCI: Disable PCIe Relaxed Ordering if unsupported
    
    When bit4 is set in the PCIe Device Control register, it indicates
    whether the device is permitted to use relaxed ordering.
    On some platforms using relaxed ordering can have performance issues or
    due to erratum can cause data-corruption. In such cases devices must avoid
    using relaxed ordering.
    
    The patch adds a new flag PCI_DEV_FLAGS_NO_RELAXED_ORDERING to indicate that
    Relaxed Ordering (RO) attribute should not be used for Transaction Layer
    Packets (TLP) targeted towards these affected root complexes.
    
    This patch checks if there is any node in the hierarchy that indicates that
    using relaxed ordering is not safe. In such cases the patch turns off the
    relaxed ordering by clearing the capability for this device.
    
    Signed-off-by: Casey Leedom <leedom@chelsio.com>
    Signed-off-by: Ding Tianhong <dingtianhong@huawei.com>
    Acked-by: Ashok Raj <ashok.raj@intel.com>
    Acked-by: Alexander Duyck <alexander.h.duyck@intel.com>
    Acked-by: Casey Leedom <leedom@chelsio.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index c31310db0404..e6a917b4acd3 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1762,6 +1762,48 @@ static void pci_configure_extended_tags(struct pci_dev *dev)
 					 PCI_EXP_DEVCTL_EXT_TAG);
 }
 
+/**
+ * pcie_relaxed_ordering_enabled - Probe for PCIe relaxed ordering enable
+ * @dev: PCI device to query
+ *
+ * Returns true if the device has enabled relaxed ordering attribute.
+ */
+bool pcie_relaxed_ordering_enabled(struct pci_dev *dev)
+{
+	u16 v;
+
+	pcie_capability_read_word(dev, PCI_EXP_DEVCTL, &v);
+
+	return !!(v & PCI_EXP_DEVCTL_RELAX_EN);
+}
+EXPORT_SYMBOL(pcie_relaxed_ordering_enabled);
+
+static void pci_configure_relaxed_ordering(struct pci_dev *dev)
+{
+	struct pci_dev *root;
+
+	/* PCI_EXP_DEVICE_RELAX_EN is RsvdP in VFs */
+	if (dev->is_virtfn)
+		return;
+
+	if (!pcie_relaxed_ordering_enabled(dev))
+		return;
+
+	/*
+	 * For now, we only deal with Relaxed Ordering issues with Root
+	 * Ports. Peer-to-Peer DMA is another can of worms.
+	 */
+	root = pci_find_pcie_root_port(dev);
+	if (!root)
+		return;
+
+	if (root->dev_flags & PCI_DEV_FLAGS_NO_RELAXED_ORDERING) {
+		pcie_capability_clear_word(dev, PCI_EXP_DEVCTL,
+					   PCI_EXP_DEVCTL_RELAX_EN);
+		dev_info(&dev->dev, "Disable Relaxed Ordering because the Root Port didn't support it\n");
+	}
+}
+
 static void pci_configure_device(struct pci_dev *dev)
 {
 	struct hotplug_params hpp;
@@ -1769,6 +1811,7 @@ static void pci_configure_device(struct pci_dev *dev)
 
 	pci_configure_mps(dev);
 	pci_configure_extended_tags(dev);
+	pci_configure_relaxed_ordering(dev);
 
 	memset(&hpp, 0, sizeof(hpp));
 	ret = pci_get_hp_params(dev, &hpp);

commit bccf90d6e063d278b9ddc78dd266d0adef29886c
Author: Palmer Dabbelt <palmer@dabbelt.com>
Date:   Fri Jun 23 18:50:42 2017 -0700

    PCI: Add a generic weak pcibios_fixup_bus()
    
    Multiple architectures define this as an empty function, and I'm adding
    another one as part of the RISC-V port.  Add a __weak version of
    pcibios_fixup_bus() and delete the now-obselete ones in a handful of
    ports.
    
    The only functional change should be that microblaze used to export
    pcibios_fixup_bus().  None of the other architectures exports this, so I
    just dropped it.
    
    Signed-off-by: Palmer Dabbelt <palmer@dabbelt.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index c31310db0404..376c61173b4e 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -2288,6 +2288,15 @@ void pcie_bus_configure_settings(struct pci_bus *bus)
 }
 EXPORT_SYMBOL_GPL(pcie_bus_configure_settings);
 
+/*
+ * Called after each bus is probed, but before its children are examined.  This
+ * is marked as __weak because multiple architectures define it.
+ */
+void __weak pcibios_fixup_bus(struct pci_bus *bus)
+{
+       /* nothing to do, expected to be removed in the future */
+}
+
 unsigned int pci_scan_child_bus(struct pci_bus *bus)
 {
 	unsigned int devfn, pass, max = bus->busn_res.start;

commit 62ce94a7a5a54aac80975f5e6731707225d4077e
Author: Sinan Kaya <okaya@codeaurora.org>
Date:   Wed Jul 12 00:04:14 2017 -0400

    PCI: Mark Broadcom HT2100 Root Port Extended Tags as broken
    
    Per PCIe r3.1, sec 2.2.6.2 and 7.8.4, a Requester may not use 8-bit Tags
    unless its Extended Tag Field Enable is set, but all Receivers/Completers
    must handle 8-bit Tags correctly regardless of their Extended Tag Field
    Enable.
    
    Some devices do not handle 8-bit Tags as Completers, so add a quirk for
    them.  If we find such a device, we disable Extended Tags for the entire
    hierarchy to make peer-to-peer DMA possible.
    
    The Broadcom HT2100 seems to have issues with handling 8-bit tags.  Mark it
    as broken.
    
    The pci_walk_bus() in the quirk handles devices we've enumerated in the
    past, and pci_configure_device() handles devices we enumerate in the
    future.
    
    Fixes: 60db3a4d8cc9 ("PCI: Enable PCIe Extended Tags if supported")
    Link: https://bugzilla.redhat.com/show_bug.cgi?id=1467674
    Reported-and-tested-by: Wim ten Have <wim.ten.have@oracle.com>
    Signed-off-by: Sinan Kaya <okaya@codeaurora.org>
    [bhelgaas: changelog, tweak messages, rename bit and quirk]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index c31310db0404..c81c9835f4c7 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1745,21 +1745,50 @@ static void program_hpp_type2(struct pci_dev *dev, struct hpp_type2 *hpp)
 	 */
 }
 
-static void pci_configure_extended_tags(struct pci_dev *dev)
+int pci_configure_extended_tags(struct pci_dev *dev, void *ign)
 {
-	u32 dev_cap;
+	struct pci_host_bridge *host;
+	u32 cap;
+	u16 ctl;
 	int ret;
 
 	if (!pci_is_pcie(dev))
-		return;
+		return 0;
 
-	ret = pcie_capability_read_dword(dev, PCI_EXP_DEVCAP, &dev_cap);
+	ret = pcie_capability_read_dword(dev, PCI_EXP_DEVCAP, &cap);
 	if (ret)
-		return;
+		return 0;
+
+	if (!(cap & PCI_EXP_DEVCAP_EXT_TAG))
+		return 0;
 
-	if (dev_cap & PCI_EXP_DEVCAP_EXT_TAG)
+	ret = pcie_capability_read_word(dev, PCI_EXP_DEVCTL, &ctl);
+	if (ret)
+		return 0;
+
+	host = pci_find_host_bridge(dev->bus);
+	if (!host)
+		return 0;
+
+	/*
+	 * If some device in the hierarchy doesn't handle Extended Tags
+	 * correctly, make sure they're disabled.
+	 */
+	if (host->no_ext_tags) {
+		if (ctl & PCI_EXP_DEVCTL_EXT_TAG) {
+			dev_info(&dev->dev, "disabling Extended Tags\n");
+			pcie_capability_clear_word(dev, PCI_EXP_DEVCTL,
+						   PCI_EXP_DEVCTL_EXT_TAG);
+		}
+		return 0;
+	}
+
+	if (!(ctl & PCI_EXP_DEVCTL_EXT_TAG)) {
+		dev_info(&dev->dev, "enabling Extended Tags\n");
 		pcie_capability_set_word(dev, PCI_EXP_DEVCTL,
 					 PCI_EXP_DEVCTL_EXT_TAG);
+	}
+	return 0;
 }
 
 static void pci_configure_device(struct pci_dev *dev)
@@ -1768,7 +1797,7 @@ static void pci_configure_device(struct pci_dev *dev)
 	int ret;
 
 	pci_configure_mps(dev);
-	pci_configure_extended_tags(dev);
+	pci_configure_extended_tags(dev, NULL);
 
 	memset(&hpp, 0, sizeof(hpp));
 	ret = pci_get_hp_params(dev, &hpp);

commit 44d745fb5d06cce62501a39e9dd47a47b111777b
Merge: bb02ce95a59e 769b461fc0c0
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Jul 3 08:00:29 2017 -0500

    Merge branch 'pci/irq-fixups' into next
    
    * pci/irq-fixups:
      arm64: PCI: Drop DT IRQ allocation from pcibios_alloc_irq()
      PCI: xilinx-nwl: Move to struct pci_host_bridge IRQ mapping functions
      PCI: rockchip: Move to struct pci_host_bridge IRQ mapping functions
      PCI: xgene: Move to struct pci_host_bridge IRQ mapping functions
      PCI: altera: Drop pci_fixup_irqs()
      PCI: versatile: Drop pci_fixup_irqs()
      PCI: generic: Drop pci_fixup_irqs()
      PCI: faraday: Drop pci_fixup_irqs()
      PCI: designware: Drop pci_fixup_irqs()
      PCI: iproc: Drop pci_fixup_irqs()
      PCI: rcar: Drop pci_fixup_irqs()
      PCI: xilinx: Drop pci_fixup_irqs()
      PCI: tegra: Drop pci_fixup_irqs()
      ARM/PCI: Remove pci_fixup_irqs() call for bios32 host controllers
      PCI: Add a call to pci_assign_irq() in pci_device_probe()
      OF/PCI: Update of_irq_parse_and_map_pci() comment
      PCI: Add pci_assign_irq() function and have pci_fixup_irqs() use it
      PCI: Add IRQ mapping function pointers to pci_host_bridge struct
      PCI: Build setup-irq.o on all arches
      PCI: Remove pci_scan_root_bus_msi()
      PCI: xilinx-nwl: Convert PCI scan API to pci_scan_root_bus_bridge()
      PCI: rockchip: Convert PCI scan API to pci_scan_root_bus_bridge()
      PCI: generic: Convert PCI scan API to pci_scan_root_bus_bridge()
      PCI: xgene: Convert PCI scan API to pci_scan_root_bus_bridge()
      PCI: xilinx: Convert PCI scan API to pci_scan_root_bus_bridge()
      PCI: altera: Convert PCI scan API to pci_scan_root_bus_bridge()
      PCI: versatile: Convert PCI scan API to pci_scan_root_bus_bridge()
      PCI: iproc: Convert PCI scan API to pci_scan_root_bus_bridge()
      PCI: rcar: Convert PCI scan API to pci_scan_root_bus_bridge()
      PCI: aardvark: Convert PCI scan API to pci_scan_root_bus_bridge()
      PCI: designware: Convert PCI scan API to pci_scan_root_bus_bridge()
      ARM/PCI: Convert PCI scan API to pci_scan_root_bus_bridge()
      PCI: Make pci_register_host_bridge() PCI core internal
      PCI: Add pci_scan_root_bus_bridge() interface
      PCI: tegra: Fix host bridge memory leakage
      PCI: faraday: Fix host bridge memory leakage
      PCI: Add devm_pci_alloc_host_bridge() interface
      PCI: Add pci_free_host_bridge() interface
      PCI: Initialize bridge release function at bridge allocation
      PCI: faraday: Convert IRQ masking to raw PCI config accessors
      PCI: iproc: Convert link check to raw PCI config accessors
      PCI: xilinx-nwl: Remove nwl_pcie_enable_msi() unused bus parameter

commit 9ee8a1c4a0e232e9b86e03f7c628ff0286444e00
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Wed Jun 28 15:14:01 2017 -0500

    PCI: Remove pci_scan_root_bus_msi()
    
    The pci_scan_root_bus_bridge() function allows passing a parameterized
    struct pci_host_bridge and scanning the resulting PCI bus; since the struct
    msi_controller is part of the struct pci_host_bridge and the struct
    pci_host_bridge can now be passed to pci_scan_root_bus_bridge() explicitly,
    there is no need for a scan interface with a MSI controller parameter.
    
    With all PCI host controller drivers and platform code relying on
    pci_scan_root_bus_msi() converted over to pci_scan_root_bus_bridge() the
    pci_scan_root_bus_msi() becomes obsolete and can be removed.
    
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 5c457c17cf5c..bd42ed42c199 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -2324,9 +2324,8 @@ void __weak pcibios_remove_bus(struct pci_bus *bus)
 {
 }
 
-static struct pci_bus *pci_create_root_bus_msi(struct device *parent,
-		int bus, struct pci_ops *ops, void *sysdata,
-		struct list_head *resources, struct msi_controller *msi)
+struct pci_bus *pci_create_root_bus(struct device *parent, int bus,
+		struct pci_ops *ops, void *sysdata, struct list_head *resources)
 {
 	int error;
 	struct pci_host_bridge *bridge;
@@ -2341,7 +2340,6 @@ static struct pci_bus *pci_create_root_bus_msi(struct device *parent,
 	bridge->sysdata = sysdata;
 	bridge->busnr = bus;
 	bridge->ops = ops;
-	bridge->msi = msi;
 
 	error = pci_register_host_bridge(bridge);
 	if (error < 0)
@@ -2353,13 +2351,6 @@ static struct pci_bus *pci_create_root_bus_msi(struct device *parent,
 	kfree(bridge);
 	return NULL;
 }
-
-struct pci_bus *pci_create_root_bus(struct device *parent, int bus,
-		struct pci_ops *ops, void *sysdata, struct list_head *resources)
-{
-	return pci_create_root_bus_msi(parent, bus, ops, sysdata, resources,
-				       NULL);
-}
 EXPORT_SYMBOL_GPL(pci_create_root_bus);
 
 int pci_bus_insert_busn_res(struct pci_bus *b, int bus, int bus_max)
@@ -2464,9 +2455,8 @@ int pci_scan_root_bus_bridge(struct pci_host_bridge *bridge)
 }
 EXPORT_SYMBOL(pci_scan_root_bus_bridge);
 
-struct pci_bus *pci_scan_root_bus_msi(struct device *parent, int bus,
-		struct pci_ops *ops, void *sysdata,
-		struct list_head *resources, struct msi_controller *msi)
+struct pci_bus *pci_scan_root_bus(struct device *parent, int bus,
+		struct pci_ops *ops, void *sysdata, struct list_head *resources)
 {
 	struct resource_entry *window;
 	bool found = false;
@@ -2479,7 +2469,7 @@ struct pci_bus *pci_scan_root_bus_msi(struct device *parent, int bus,
 			break;
 		}
 
-	b = pci_create_root_bus_msi(parent, bus, ops, sysdata, resources, msi);
+	b = pci_create_root_bus(parent, bus, ops, sysdata, resources);
 	if (!b)
 		return NULL;
 
@@ -2497,13 +2487,6 @@ struct pci_bus *pci_scan_root_bus_msi(struct device *parent, int bus,
 
 	return b;
 }
-
-struct pci_bus *pci_scan_root_bus(struct device *parent, int bus,
-		struct pci_ops *ops, void *sysdata, struct list_head *resources)
-{
-	return pci_scan_root_bus_msi(parent, bus, ops, sysdata, resources,
-				     NULL);
-}
 EXPORT_SYMBOL(pci_scan_root_bus);
 
 struct pci_bus *pci_scan_bus(int bus, struct pci_ops *ops,

commit 675734baa361cf044033bb60594dea33d8d8da36
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Mar 21 13:01:30 2017 -0500

    PCI: Enable ECRC only if device supports it
    
    John reported that an Intel QuickAssist crypto accelerator didn't work in a
    Dell PowerEdge R730.  The problem seems to be that we enabled ECRC when the
    device doesn't support it:
    
      85:00.0 Co-processor [0b40]: Intel Corporation DH895XCC Series QAT [8086:0435]
        Capabilities: [100 v1] Advanced Error Reporting
          AERCap: First Error Pointer: 00, GenCap- CGenEn+ ChkCap- ChkEn+
    
    1302fcf0d03e ("PCI: Configure *all* devices, not just hot-added ones")
    exposed the problem because it applies settings from the _HPX method to all
    devices, not just hot-added ones.  The R730 supplies an _HPX method that
    allows the kernel to enable ECRC.
    
    Only enable ECRC if the device advertises support for it.
    
    Link: https://bugs.launchpad.net/ubuntu/+source/linux/+bug/1571798
    Fixes: 1302fcf0d03e ("PCI: Configure *all* devices, not just hot-added ones")
    Reported-by: John Mazzie <john_mazzie@dell.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 8b8826b9a398..7fedfeb0871d 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1704,6 +1704,11 @@ static void program_hpp_type2(struct pci_dev *dev, struct hpp_type2 *hpp)
 	/* Initialize Advanced Error Capabilities and Control Register */
 	pci_read_config_dword(dev, pos + PCI_ERR_CAP, &reg32);
 	reg32 = (reg32 & hpp->adv_err_cap_and) | hpp->adv_err_cap_or;
+	/* Don't enable ECRC generation or checking if unsupported */
+	if (!(reg32 & PCI_ERR_CAP_ECRC_GENC))
+		reg32 &= ~PCI_ERR_CAP_ECRC_GENE;
+	if (!(reg32 & PCI_ERR_CAP_ECRC_CHKC))
+		reg32 &= ~PCI_ERR_CAP_ECRC_CHKE;
 	pci_write_config_dword(dev, pos + PCI_ERR_CAP, reg32);
 
 	/*

commit cea9bc0be624fb0dc488cb10df40be1323b6b758
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Wed Jun 28 15:13:55 2017 -0500

    PCI: Make pci_register_host_bridge() PCI core internal
    
    With the introduction of pci_scan_root_bus_bridge() there is no need to
    export pci_register_host_bridge() to other kernel subsystems other than the
    PCI compilation unit that needs it.
    
    Make pci_register_host_bridge() static to its compilation unit and convert
    the existing drivers usage over to pci_scan_root_bus_bridge().
    
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Arnd Bergmann <arnd@arndb.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 690f0b377a0f..5c457c17cf5c 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -746,7 +746,7 @@ static void pci_set_bus_msi_domain(struct pci_bus *bus)
 	dev_set_msi_domain(&bus->dev, d);
 }
 
-int pci_register_host_bridge(struct pci_host_bridge *bridge)
+static int pci_register_host_bridge(struct pci_host_bridge *bridge)
 {
 	struct device *parent = bridge->dev.parent;
 	struct resource_entry *window, *n;
@@ -861,7 +861,6 @@ int pci_register_host_bridge(struct pci_host_bridge *bridge)
 	kfree(bus);
 	return err;
 }
-EXPORT_SYMBOL(pci_register_host_bridge);
 
 static struct pci_bus *pci_alloc_child_bus(struct pci_bus *parent,
 					   struct pci_dev *bridge, int busnr)

commit 1228c4b6c19a76a2691cfb1403ad1eebf5852b76
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Wed Jun 28 15:13:55 2017 -0500

    PCI: Add pci_scan_root_bus_bridge() interface
    
    The current pci_scan_root_bus() interface is made up of two main code
    paths:
    
      - pci_create_root_bus()
      - pci_scan_child_bus()
    
    pci_create_root_bus() is a wrapper function that allows to create a struct
    pci_host_bridge structure, initialize it with the passed parameters and
    register it with the kernel.
    
    As the struct pci_host_bridge require additional struct members,
    pci_create_root_bus() parameters list has grown in time, making it unwieldy
    to add further parameters to it in case the struct pci_host_bridge gains
    more members fields to augment its functionality.
    
    Since PCI core code provides functions to allocate struct pci_host_bridge,
    instead of forcing the pci_create_root_bus() interface to add new
    parameters to cater for new struct pci_host_bridge functionality, it is
    more suitable to add an interface in PCI core code to scan a PCI bus
    straight from a struct pci_host_bridge created and customized by each
    specific PCI host controller driver.
    
    Add a pci_scan_root_bus_bridge() function to allow PCI host controller
    drivers to create and initialize struct pci_host_bridge and scan the
    resulting bus.
    
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Arnd Bergmann <arnd@arndb.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index e3f69655ca87..690f0b377a0f 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -2426,6 +2426,45 @@ void pci_bus_release_busn_res(struct pci_bus *b)
 			res, ret ? "can not be" : "is");
 }
 
+int pci_scan_root_bus_bridge(struct pci_host_bridge *bridge)
+{
+	struct resource_entry *window;
+	bool found = false;
+	struct pci_bus *b;
+	int max, bus, ret;
+
+	if (!bridge)
+		return -EINVAL;
+
+	resource_list_for_each_entry(window, &bridge->windows)
+		if (window->res->flags & IORESOURCE_BUS) {
+			found = true;
+			break;
+		}
+
+	ret = pci_register_host_bridge(bridge);
+	if (ret < 0)
+		return ret;
+
+	b = bridge->bus;
+	bus = bridge->busnr;
+
+	if (!found) {
+		dev_info(&b->dev,
+		 "No busn resource found for root bus, will use [bus %02x-ff]\n",
+			bus);
+		pci_bus_insert_busn_res(b, bus, 255);
+	}
+
+	max = pci_scan_child_bus(b);
+
+	if (!found)
+		pci_bus_update_busn_res_end(b, max);
+
+	return 0;
+}
+EXPORT_SYMBOL(pci_scan_root_bus_bridge);
+
 struct pci_bus *pci_scan_root_bus_msi(struct device *parent, int bus,
 		struct pci_ops *ops, void *sysdata,
 		struct list_head *resources, struct msi_controller *msi)

commit 5c3f18cce08364ef68163228c0b42725d64cd353
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Wed Jun 28 15:13:53 2017 -0500

    PCI: Add devm_pci_alloc_host_bridge() interface
    
    Struct pci_host_bridge can be allocated by PCI host bridge drivers which
    usually allocate and map memory through devm managed interfaces.
    
    Add a devm version for the pci_alloc_host_bridge() interface to simplify
    PCI host controller driver porting and simplify the driver failure paths.
    
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Arnd Bergmann <arnd@arndb.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index cbf0d0c1b009..e3f69655ca87 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -510,14 +510,18 @@ static struct pci_bus *pci_alloc_bus(struct pci_bus *parent)
 	return b;
 }
 
-static void pci_release_host_bridge_dev(struct device *dev)
+static void devm_pci_release_host_bridge_dev(struct device *dev)
 {
 	struct pci_host_bridge *bridge = to_pci_host_bridge(dev);
 
 	if (bridge->release_fn)
 		bridge->release_fn(bridge);
+}
 
-	pci_free_host_bridge(bridge);
+static void pci_release_host_bridge_dev(struct device *dev)
+{
+	devm_pci_release_host_bridge_dev(dev);
+	pci_free_host_bridge(to_pci_host_bridge(dev));
 }
 
 struct pci_host_bridge *pci_alloc_host_bridge(size_t priv)
@@ -535,6 +539,22 @@ struct pci_host_bridge *pci_alloc_host_bridge(size_t priv)
 }
 EXPORT_SYMBOL(pci_alloc_host_bridge);
 
+struct pci_host_bridge *devm_pci_alloc_host_bridge(struct device *dev,
+						   size_t priv)
+{
+	struct pci_host_bridge *bridge;
+
+	bridge = devm_kzalloc(dev, sizeof(*bridge) + priv, GFP_KERNEL);
+	if (!bridge)
+		return NULL;
+
+	INIT_LIST_HEAD(&bridge->windows);
+	bridge->dev.release = devm_pci_release_host_bridge_dev;
+
+	return bridge;
+}
+EXPORT_SYMBOL(devm_pci_alloc_host_bridge);
+
 void pci_free_host_bridge(struct pci_host_bridge *bridge)
 {
 	pci_free_resource_list(&bridge->windows);

commit dff79b91b8f3279cbe60727368adff1f3a5ab16e
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Wed Jun 28 15:13:52 2017 -0500

    PCI: Add pci_free_host_bridge() interface
    
    Commit a52d1443bba1 ("PCI: Export host bridge registration interface")
    exported the pci_alloc_host_bridge() interface so that PCI host controllers
    drivers can make use of it.
    
    Introduce pci_alloc_host_bridge() kernel counterpart to free the host
    bridge data structures, pci_free_host_bridge(), export it and update kernel
    functions releasing host bridge objects allocated memory to make use of it.
    
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Arnd Bergmann <arnd@arndb.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 586d83d8be4d..cbf0d0c1b009 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -517,9 +517,7 @@ static void pci_release_host_bridge_dev(struct device *dev)
 	if (bridge->release_fn)
 		bridge->release_fn(bridge);
 
-	pci_free_resource_list(&bridge->windows);
-
-	kfree(bridge);
+	pci_free_host_bridge(bridge);
 }
 
 struct pci_host_bridge *pci_alloc_host_bridge(size_t priv)
@@ -537,6 +535,14 @@ struct pci_host_bridge *pci_alloc_host_bridge(size_t priv)
 }
 EXPORT_SYMBOL(pci_alloc_host_bridge);
 
+void pci_free_host_bridge(struct pci_host_bridge *bridge)
+{
+	pci_free_resource_list(&bridge->windows);
+
+	kfree(bridge);
+}
+EXPORT_SYMBOL(pci_free_host_bridge);
+
 static const unsigned char pcix_bus_speed[] = {
 	PCI_SPEED_UNKNOWN,		/* 0 */
 	PCI_SPEED_66MHz_PCIX,		/* 1 */

commit a1c0050a17f58279480e32b4aa5068282c6982bb
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Wed Jun 28 15:13:52 2017 -0500

    PCI: Initialize bridge release function at bridge allocation
    
    The introduction of pci_register_host_bridge() kernel interface allows PCI
    host controller drivers to create the struct pci_host_bridge object,
    initialize it and register it with the kernel so that its corresponding PCI
    bus can be scanned and its devices probed.
    
    The host bridge device release function pci_release_host_bridge_dev() is a
    static function common for all struct pci_host_bridge allocated objects, so
    in its current form cannot be used by PCI host bridge controllers drivers
    to initialize the allocated struct pci_host_bridge, which leaves struct
    pci_host_bridge devices release function uninitialized.
    
    Since pci_release_host_bridge_dev() is a function common to all PCI host
    bridge objects, initialize it in pci_alloc_host_bridge() (ie common host
    bridge allocation interface) so that all struct pci_host_bridge objects
    have their release function initialized by default at allocation time,
    removing the need for exporting the common pci_release_host_bridge_dev()
    function to other compilation units.
    
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Arnd Bergmann <arnd@arndb.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 19c8950c6c38..586d83d8be4d 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -531,6 +531,7 @@ struct pci_host_bridge *pci_alloc_host_bridge(size_t priv)
 		return NULL;
 
 	INIT_LIST_HEAD(&bridge->windows);
+	bridge->dev.release = pci_release_host_bridge_dev;
 
 	return bridge;
 }
@@ -2310,7 +2311,6 @@ static struct pci_bus *pci_create_root_bus_msi(struct device *parent,
 		return NULL;
 
 	bridge->dev.parent = parent;
-	bridge->dev.release = pci_release_host_bridge_dev;
 
 	list_splice_init(resources, &bridge->windows);
 	bridge->sysdata = sysdata;

commit 99b3c58f7ba7fae801e501b45c5fcf6e08d9247f
Author: Piotr Gregor <piotrgregor@rsyncme.org>
Date:   Fri May 26 22:02:25 2017 +0100

    PCI: Test INTx masking during enumeration, not at run-time
    
    The test for INTx masking via PCI_COMMAND_INTX_DISABLE performed in
    pci_intx_mask_supported() should be done before the device can be used.
    This is to avoid writing PCI_COMMAND while the driver owns the device, in
    case that has any effect on MSI/MSI-X interrupts.
    
    Move the content of pci_intx_mask_supported() to pci_intx_mask_broken() and
    call it from pci_setup_device().
    
    The test result can be queried at any time later using the same
    pci_intx_mask_supported() interface as before (though with changed
    implementation), so callers (uio, vfio) should be unaffected.
    
    Signed-off-by: Piotr Gregor <piotrgregor@rsyncme.org>
    [bhelgaas: changelog, remove quirk check, remove locking, move
    dev->broken_intx_masking assignment to caller]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Alex Williamson <alex.williamson@redhat.com>
    Acked-by: Michael S. Tsirkin <mst@redhat.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 19c8950c6c38..8b8826b9a398 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1329,6 +1329,34 @@ static void pci_msi_setup_pci_dev(struct pci_dev *dev)
 		pci_msix_clear_and_set_ctrl(dev, PCI_MSIX_FLAGS_ENABLE, 0);
 }
 
+/**
+ * pci_intx_mask_broken - test PCI_COMMAND_INTX_DISABLE writability
+ * @dev: PCI device
+ *
+ * Test whether PCI_COMMAND_INTX_DISABLE is writable for @dev.  Check this
+ * at enumeration-time to avoid modifying PCI_COMMAND at run-time.
+ */
+static int pci_intx_mask_broken(struct pci_dev *dev)
+{
+	u16 orig, toggle, new;
+
+	pci_read_config_word(dev, PCI_COMMAND, &orig);
+	toggle = orig ^ PCI_COMMAND_INTX_DISABLE;
+	pci_write_config_word(dev, PCI_COMMAND, toggle);
+	pci_read_config_word(dev, PCI_COMMAND, &new);
+
+	pci_write_config_word(dev, PCI_COMMAND, orig);
+
+	/*
+	 * PCI_COMMAND_INTX_DISABLE was reserved and read-only prior to PCI
+	 * r2.3, so strictly speaking, a device is not *broken* if it's not
+	 * writable.  But we'll live with the misnomer for now.
+	 */
+	if (new != toggle)
+		return 1;
+	return 0;
+}
+
 /**
  * pci_setup_device - fill in class and map information of a device
  * @dev: the device structure to fill
@@ -1399,6 +1427,8 @@ int pci_setup_device(struct pci_dev *dev)
 		}
 	}
 
+	dev->broken_intx_masking = pci_intx_mask_broken(dev);
+
 	switch (dev->hdr_type) {		    /* header type */
 	case PCI_HEADER_TYPE_NORMAL:		    /* standard header */
 		if (class == PCI_CLASS_BRIDGE_PCI)

commit 28b47809b2171a6cfbab839936b24280639c9f85
Merge: 4a1e31c68e9f 2c0248d68880
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue May 9 15:15:47 2017 -0700

    Merge tag 'iommu-updates-v4.12' of git://git.kernel.org/pub/scm/linux/kernel/git/joro/iommu
    
    Pull IOMMU updates from Joerg Roedel:
    
     - code optimizations for the Intel VT-d driver
    
     - ability to switch off a previously enabled Intel IOMMU
    
     - support for 'struct iommu_device' for OMAP, Rockchip and Mediatek
       IOMMUs
    
     - header optimizations for IOMMU core code headers and a few fixes that
       became necessary in other parts of the kernel because of that
    
     - ACPI/IORT updates and fixes
    
     - Exynos IOMMU optimizations
    
     - updates for the IOMMU dma-api code to bring it closer to use per-cpu
       iova caches
    
     - new command-line option to set default domain type allocated by the
       iommu core code
    
     - another command line option to allow the Intel IOMMU switched off in
       a tboot environment
    
     - ARM/SMMU: TLB sync optimisations for SMMUv2, Support for using an
       IDENTITY domain in conjunction with DMA ops, Support for SMR masking,
       Support for 16-bit ASIDs (was previously broken)
    
     - various other small fixes and improvements
    
    * tag 'iommu-updates-v4.12' of git://git.kernel.org/pub/scm/linux/kernel/git/joro/iommu: (63 commits)
      soc/qbman: Move dma-mapping.h include to qman_priv.h
      soc/qbman: Fix implicit header dependency now causing build fails
      iommu: Remove trace-events include from iommu.h
      iommu: Remove pci.h include from trace/events/iommu.h
      arm: dma-mapping: Don't override dma_ops in arch_setup_dma_ops()
      ACPI/IORT: Fix CONFIG_IOMMU_API dependency
      iommu/vt-d: Don't print the failure message when booting non-kdump kernel
      iommu: Move report_iommu_fault() to iommu.c
      iommu: Include device.h in iommu.h
      x86, iommu/vt-d: Add an option to disable Intel IOMMU force on
      iommu/arm-smmu: Return IOVA in iova_to_phys when SMMU is bypassed
      iommu/arm-smmu: Correct sid to mask
      iommu/amd: Fix incorrect error handling in amd_iommu_bind_pasid()
      iommu: Make iommu_bus_notifier return NOTIFY_DONE rather than error code
      omap3isp: Remove iommu_group related code
      iommu/omap: Add iommu-group support
      iommu/omap: Make use of 'struct iommu_device'
      iommu/omap: Store iommu_dev pointer in arch_data
      iommu/omap: Move data structures to omap-iommu.h
      iommu/omap: Drop legacy-style device support
      ...

commit 857f8640147c9fb43f20e43cbca6452710e1ca5d
Merge: 8f3207c7eab9 3146c8f4de9b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon May 8 19:03:25 2017 -0700

    Merge tag 'pci-v4.12-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI updates from Bjorn Helgaas:
    
     - add framework for supporting PCIe devices in Endpoint mode (Kishon
       Vijay Abraham I)
    
     - use non-postable PCI config space mappings when possible (Lorenzo
       Pieralisi)
    
     - clean up and unify mmap of PCI BARs (David Woodhouse)
    
     - export and unify Function Level Reset support (Christoph Hellwig)
    
     - avoid FLR for Intel 82579 NICs (Sasha Neftin)
    
     - add pci_request_irq() and pci_free_irq() helpers (Christoph Hellwig)
    
     - short-circuit config access failures for disconnected devices (Keith
       Busch)
    
     - remove D3 sleep delay when possible (Adrian Hunter)
    
     - freeze PME scan before suspending devices (Lukas Wunner)
    
     - stop disabling MSI/MSI-X in pci_device_shutdown() (Prarit Bhargava)
    
     - disable boot interrupt quirk for ASUS M2N-LR (Stefan Assmann)
    
     - add arch-specific alignment control to improve device passthrough by
       avoiding multiple BARs in a page (Yongji Xie)
    
     - add sysfs sriov_drivers_autoprobe to control VF driver binding
       (Bodong Wang)
    
     - allow slots below PCI-to-PCIe "reverse bridges" (Bjorn Helgaas)
    
     - fix crashes when unbinding host controllers that don't support
       removal (Brian Norris)
    
     - add driver for MicroSemi Switchtec management interface (Logan
       Gunthorpe)
    
     - add driver for Faraday Technology FTPCI100 host bridge (Linus
       Walleij)
    
     - add i.MX7D support (Andrey Smirnov)
    
     - use generic MSI support for Aardvark (Thomas Petazzoni)
    
     - make Rockchip driver modular (Brian Norris)
    
     - advertise 128-byte Read Completion Boundary support for Rockchip
       (Shawn Lin)
    
     - advertise PCI_EXP_LNKSTA_SLC for Rockchip root port (Shawn Lin)
    
     - convert atomic_t to refcount_t in HV driver (Elena Reshetova)
    
     - add CPU IRQ affinity in HV driver (K. Y. Srinivasan)
    
     - fix PCI bus removal in HV driver (Long Li)
    
     - add support for ThunderX2 DMA alias topology (Jayachandran C)
    
     - add ThunderX pass2.x 2nd node MCFG quirk (Tomasz Nowicki)
    
     - add ITE 8893 bridge DMA alias quirk (Jarod Wilson)
    
     - restrict Cavium ACS quirk only to CN81xx/CN83xx/CN88xx devices
       (Manish Jaggi)
    
    * tag 'pci-v4.12-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (146 commits)
      PCI: Don't allow unbinding host controllers that aren't prepared
      ARM: DRA7: clockdomain: Change the CLKTRCTRL of CM_PCIE_CLKSTCTRL to SW_WKUP
      MAINTAINERS: Add PCI Endpoint maintainer
      Documentation: PCI: Add userguide for PCI endpoint test function
      tools: PCI: Add sample test script to invoke pcitest
      tools: PCI: Add a userspace tool to test PCI endpoint
      Documentation: misc-devices: Add Documentation for pci-endpoint-test driver
      misc: Add host side PCI driver for PCI test function device
      PCI: Add device IDs for DRA74x and DRA72x
      dt-bindings: PCI: dra7xx: Add DT bindings to enable unaligned access
      PCI: dwc: dra7xx: Workaround for errata id i870
      dt-bindings: PCI: dra7xx: Add DT bindings for PCI dra7xx EP mode
      PCI: dwc: dra7xx: Add EP mode support
      PCI: dwc: dra7xx: Facilitate wrapper and MSI interrupts to be enabled independently
      dt-bindings: PCI: Add DT bindings for PCI designware EP mode
      PCI: dwc: designware: Add EP mode support
      Documentation: PCI: Add binding documentation for pci-test endpoint function
      ixgbe: Use pcie_flr() instead of duplicating it
      IB/hfi1: Use pcie_flr() instead of duplicating it
      PCI: imx6: Fix spelling mistake: "contol" -> "control"
      ...

commit 78f098383a7abb1eb9dfd45346773fe80a65f05a
Merge: acc886ec9349 e3adec72a3c5
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Apr 28 10:34:29 2017 -0500

    Merge branch 'pci/resource' into next
    
    * pci/resource:
      PCI: Don't resize resources when realigning all devices in system
      PCI: Don't reassign resources that are already aligned
      PCI: Factor pci_reassigndev_resource_alignment()
      powerpc/powernv: Override pcibios_default_alignment() to force PCI devices to be page aligned
      PCI: Add pcibios_default_alignment() for arch-specific alignment control
      PCI: Fix calculation of bridge window's size and alignment
      PCI: Ignore requested alignment for IOV BARs
      PCI: Make PCI_ROM_ADDRESS_MASK a 32-bit constant

commit 09515ef5ddad71c7820e5e428da418b709feeb26
Author: Sricharan R <sricharan@codeaurora.org>
Date:   Mon Apr 10 16:51:01 2017 +0530

    of/acpi: Configure dma operations at probe time for platform/amba/pci bus devices
    
    Configuring DMA ops at probe time will allow deferring device probe when
    the IOMMU isn't available yet. The dma_configure for the device is
    now called from the generic device_attach callback just before the
    bus/driver probe is called. This way, configuring the DMA ops for the
    device would be called at the same place for all bus_types, hence the
    deferred probing mechanism should work for all buses as well.
    
    pci_bus_add_devices    (platform/amba)(_device_create/driver_register)
           |                         |
    pci_bus_add_device     (device_add/driver_register)
           |                         |
    device_attach           device_initial_probe
           |                         |
    __device_attach_driver    __device_attach_driver
           |
    driver_probe_device
           |
    really_probe
           |
    dma_configure
    
    Similarly on the device/driver_unregister path __device_release_driver is
    called which inturn calls dma_deconfigure.
    
    This patch changes the dma ops configuration to probe time for
    both OF and ACPI based platform/amba/pci bus devices.
    
    Tested-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Tested-by: Hanjun Guo <hanjun.guo@linaro.org>
    Reviewed-by: Robin Murphy <robin.murphy@arm.com>
    Acked-by: Rob Herring <robh@kernel.org>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com> (drivers/pci part)
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Sricharan R <sricharan@codeaurora.org>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index dfc9a2794141..5a8dd43db336 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1893,33 +1893,6 @@ static void pci_set_msi_domain(struct pci_dev *dev)
 	dev_set_msi_domain(&dev->dev, d);
 }
 
-/**
- * pci_dma_configure - Setup DMA configuration
- * @dev: ptr to pci_dev struct of the PCI device
- *
- * Function to update PCI devices's DMA configuration using the same
- * info from the OF node or ACPI node of host bridge's parent (if any).
- */
-static void pci_dma_configure(struct pci_dev *dev)
-{
-	struct device *bridge = pci_get_host_bridge_device(dev);
-
-	if (IS_ENABLED(CONFIG_OF) &&
-		bridge->parent && bridge->parent->of_node) {
-			of_dma_configure(&dev->dev, bridge->parent->of_node);
-	} else if (has_acpi_companion(bridge)) {
-		struct acpi_device *adev = to_acpi_device_node(bridge->fwnode);
-		enum dev_dma_attr attr = acpi_get_dma_attr(adev);
-
-		if (attr == DEV_DMA_NOT_SUPPORTED)
-			dev_warn(&dev->dev, "DMA not supported.\n");
-		else
-			acpi_dma_configure(&dev->dev, attr);
-	}
-
-	pci_put_host_bridge_device(bridge);
-}
-
 void pci_device_add(struct pci_dev *dev, struct pci_bus *bus)
 {
 	int ret;
@@ -1933,7 +1906,6 @@ void pci_device_add(struct pci_dev *dev, struct pci_bus *bus)
 	dev->dev.dma_mask = &dev->dma_mask;
 	dev->dev.dma_parms = &dev->dma_parms;
 	dev->dev.coherent_dma_mask = 0xffffffffull;
-	pci_dma_configure(dev);
 
 	pci_set_dma_max_seg_size(dev, 65536);
 	pci_set_dma_seg_boundary(dev, 0xffffffff);

commit 76dc52684d0f72971d9f6cc7d5ae198061b715bd
Author: Matthias Kaehlcke <mka@chromium.org>
Date:   Fri Apr 14 13:38:02 2017 -0700

    PCI: Make PCI_ROM_ADDRESS_MASK a 32-bit constant
    
    A 64-bit value is not needed since a PCI ROM address consists in 32 bits.
    This fixes a clang warning about "implicit conversion from 'unsigned long'
    to 'u32'".
    
    Also remove now unnecessary casts to u32 from __pci_read_base() and
    pci_std_update_resource().
    
    Signed-off-by: Matthias Kaehlcke <mka@chromium.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index dfc9a2794141..7d5d4a56a186 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -231,7 +231,7 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 			res->flags |= IORESOURCE_ROM_ENABLE;
 		l64 = l & PCI_ROM_ADDRESS_MASK;
 		sz64 = sz & PCI_ROM_ADDRESS_MASK;
-		mask64 = (u32)PCI_ROM_ADDRESS_MASK;
+		mask64 = PCI_ROM_ADDRESS_MASK;
 	}
 
 	if (res->flags & IORESOURCE_MEM_64) {

commit dc5205ef46231e848562c9275933d7b359f515ba
Author: Marc Gonzalez <marc_gonzalez@sigmadesigns.com>
Date:   Mon Apr 10 19:46:54 2017 +0200

    PCI: Improve __pci_read_base() robustness
    
    Local variables 'l' and 'sz' are uninitialized.  Normally, they would
    be initialized by pci_read_config_dword() but when an error occurs,
    some drivers immediately return an error code, which leaves the
    argument uninitialized.
    
    Provide a safe initial value to make the code more robust.
    
    Signed-off-by: Marc Gonzalez <marc_gonzalez@sigmadesigns.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index dfc9a2794141..f2bd0024cb88 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -175,7 +175,7 @@ static inline unsigned long decode_bar(struct pci_dev *dev, u32 bar)
 int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 		    struct resource *res, unsigned int pos)
 {
-	u32 l, sz, mask;
+	u32 l = 0, sz = 0, mask;
 	u64 l64, sz64, mask64;
 	u16 orig_cmd;
 	struct pci_bus_region region, inverted_region;

commit 8531e283bee66050734fb0e89d53e85fd5ce24a4
Author: Lukas Wunner <lukas@wunner.de>
Date:   Fri Mar 10 21:23:45 2017 +0100

    PCI: Recognize Thunderbolt devices
    
    Detect on probe whether a PCI device is part of a Thunderbolt controller.
    Intel uses a Vendor-Specific Extended Capability (VSEC) with ID 0x1234
    on such devices.  Detect presence of this VSEC and cache it in a newly
    added is_thunderbolt bit in struct pci_dev.
    
    Also, add a helper to check whether a given PCI device is situated on a
    Thunderbolt daisy chain (i.e., below a PCI device with is_thunderbolt
    set).
    
    The necessity arises from the following:
    
    * If an external Thunderbolt GPU is connected to a dual GPU laptop,
      that GPU is currently registered with vga_switcheroo even though it
      can neither drive the laptop's panel nor be powered off by the
      platform.  To vga_switcheroo it will appear as if two discrete
      GPUs are present.  As a result, when the external GPU is runtime
      suspended, vga_switcheroo will cut power to the internal discrete GPU
      which may not be runtime suspended at all at this moment.  The
      solution is to not register external GPUs with vga_switcheroo, which
      necessitates a way to recognize if they're on a Thunderbolt daisy
      chain.
    
    * Dual GPU MacBook Pros introduced 2011+ can no longer switch external
      DisplayPort ports between GPUs.  (They're no longer just used for DP
      but have become combined DP/Thunderbolt ports.)  The driver to switch
      the ports, drivers/platform/x86/apple-gmux.c, needs to detect presence
      of a Thunderbolt controller and, if found, keep external ports
      permanently switched to the discrete GPU.
    
    v2: Make kerneldoc for pci_is_thunderbolt_attached() more precise,
        drop portion of commit message pertaining to separate series.
        (Bjorn Helgaas)
    
    Cc: Andreas Noever <andreas.noever@gmail.com>
    Cc: Michael Jamet <michael.jamet@intel.com>
    Cc: Tomas Winkler <tomas.winkler@intel.com>
    Cc: Amir Levy <amir.jer.levy@intel.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Link: http://patchwork.freedesktop.org/patch/msgid/0ab165a4a35c0b60f29d4c306c653ead14fcd8f9.1489145162.git.lukas@wunner.de

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index dfc9a2794141..90592d424e9b 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1208,6 +1208,24 @@ void set_pcie_hotplug_bridge(struct pci_dev *pdev)
 		pdev->is_hotplug_bridge = 1;
 }
 
+static void set_pcie_thunderbolt(struct pci_dev *dev)
+{
+	int vsec = 0;
+	u32 header;
+
+	while ((vsec = pci_find_next_ext_capability(dev, vsec,
+						    PCI_EXT_CAP_ID_VNDR))) {
+		pci_read_config_dword(dev, vsec + PCI_VNDR_HEADER, &header);
+
+		/* Is the device part of a Thunderbolt controller? */
+		if (dev->vendor == PCI_VENDOR_ID_INTEL &&
+		    PCI_VNDR_HEADER_ID(header) == PCI_VSEC_ID_INTEL_TBT) {
+			dev->is_thunderbolt = 1;
+			return;
+		}
+	}
+}
+
 /**
  * pci_ext_cfg_is_aliased - is ext config space just an alias of std config?
  * @dev: PCI device
@@ -1360,6 +1378,9 @@ int pci_setup_device(struct pci_dev *dev)
 	/* need to have dev->class ready */
 	dev->cfg_size = pci_cfg_space_size(dev);
 
+	/* need to have dev->cfg_size ready */
+	set_pcie_thunderbolt(dev);
+
 	/* "Unknown power state" */
 	dev->current_state = PCI_UNKNOWN;
 

commit 60e8d3e11645a1b9c4197d9786df3894332c1685
Merge: 190c3ee06a0f c4d052ce970e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Feb 23 11:53:22 2017 -0800

    Merge tag 'pci-v4.11-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI updates from Bjorn Helgaas:
    
     - add ASPM L1 substate support
    
     - enable PCIe Extended Tags when supported
    
     - configure PCIe MPS settings on iProc, Versatile, X-Gene, and Xilinx
    
     - increase VPD access timeout
    
     - add ACS quirks for Intel Union Point, Qualcomm QDF2400 and QDF2432
    
     - use new pci_irq_alloc_vectors() in more drivers
    
     - fix MSI affinity memory leak
    
     - remove unused MSI interfaces and update documentation
    
     - remove unused AER .link_reset() callback
    
     - avoid pci_lock / p->pi_lock deadlock seen with perf
    
     - serialize sysfs enable/disable num_vfs operations
    
     - move DesignWare IP from drivers/pci/host/ to drivers/pci/dwc/ and
       refactor so we can support both hosts and endpoints
    
     - add DT ECAM-like support for HiSilicon Hip06/Hip07 controllers
    
     - add Rockchip system power management support
    
     - add Thunder-X cn81xx and cn83xx support
    
     - add Exynos 5440 PCIe PHY support
    
    * tag 'pci-v4.11-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (93 commits)
      PCI: dwc: Remove dependency of designware on CONFIG_PCI
      PCI: dwc: Add CONFIG_PCIE_DW_HOST to enable PCI dwc host
      PCI: dwc: Split pcie-designware.c into host and core files
      PCI: dwc: designware: Fix style errors in pcie-designware.c
      PCI: dwc: designware: Parse "num-lanes" property in dw_pcie_setup_rc()
      PCI: dwc: all: Split struct pcie_port into host-only and core structures
      PCI: dwc: designware: Get device pointer at the start of dw_pcie_host_init()
      PCI: dwc: all: Rename cfg_read/cfg_write to read/write
      PCI: dwc: all: Use platform_set_drvdata() to save private data
      PCI: dwc: designware: Move register defines to designware header file
      PCI: dwc: Use PTR_ERR_OR_ZERO to simplify code
      PCI: dra7xx: Group PHY API invocations
      PCI: dra7xx: Enable MSI and legacy interrupts simultaneously
      PCI: dra7xx: Add support to force RC to work in GEN1 mode
      PCI: dra7xx: Simplify probe code with devm_gpiod_get_optional()
      PCI: Move DesignWare IP support to new drivers/pci/dwc/ directory
      PCI: exynos: Support the PHY generic framework
      Documentation: binding: Modify the exynos5440 PCIe binding
      phy: phy-exynos-pcie: Add support for Exynos PCIe PHY
      Documentation: samsung-phy: Add exynos-pcie-phy binding
      ...

commit 60db3a4d8cc9073cf56264785197ba75ee1caca4
Author: Sinan Kaya <okaya@codeaurora.org>
Date:   Fri Jan 20 09:16:51 2017 -0500

    PCI: Enable PCIe Extended Tags if supported
    
    Every PCIe device can generate 5-bit transaction Tags, which allow up to 32
    concurrent requests.  Some devices can generate 8-bit Extended Tags, which
    allow up to 256 concurrent requests.
    
    Per the ECN mentioned below, all PCIe Receivers are expected to support
    Extended Tags, so devices are allowed (but not required) to enable them by
    default.
    
    If a device supports Extended Tags but does not enable them by default,
    enable them.  This allows the device to have up to 256 outstanding
    transactions at a time, which may improve performance.
    
    [bhelgaas: changelog, check for PCIe device]
    Link: https://pcisig.com/sites/default/files/specification_documents/ECN_Extended_Tag_Enable_Default_05Sept2008_final.pdf
    Signed-off-by: Sinan Kaya <okaya@codeaurora.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index aca5b2466adb..3abc94212197 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1661,12 +1661,30 @@ static void program_hpp_type2(struct pci_dev *dev, struct hpp_type2 *hpp)
 	 */
 }
 
+static void pci_configure_extended_tags(struct pci_dev *dev)
+{
+	u32 dev_cap;
+	int ret;
+
+	if (!pci_is_pcie(dev))
+		return;
+
+	ret = pcie_capability_read_dword(dev, PCI_EXP_DEVCAP, &dev_cap);
+	if (ret)
+		return;
+
+	if (dev_cap & PCI_EXP_DEVCAP_EXT_TAG)
+		pcie_capability_set_word(dev, PCI_EXP_DEVCTL,
+					 PCI_EXP_DEVCTL_EXT_TAG);
+}
+
 static void pci_configure_device(struct pci_dev *dev)
 {
 	struct hotplug_params hpp;
 	int ret;
 
 	pci_configure_mps(dev);
+	pci_configure_extended_tags(dev);
 
 	memset(&hpp, 0, sizeof(hpp));
 	ret = pci_get_hp_params(dev, &hpp);

commit 51ebfc92b72b4f7dac1ab45683bf56741e454b8c
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Jan 11 09:11:53 2017 -0600

    PCI: Enumerate switches below PCI-to-PCIe bridges
    
    A PCI-to-PCIe bridge (a "reverse bridge") has a PCI or PCI-X primary
    interface and a PCI Express secondary interface.  The PCIe interface is a
    Downstream Port that originates a Link.  See the "PCI Express to PCI/PCI-X
    Bridge Specification", rev 1.0, sections 1.2 and A.6.
    
    The bug report below involves a PCI-to-PCIe bridge and a PCIe switch below
    the bridge:
    
      00:1e.0 Intel 82801 PCI Bridge to [bus 01-0a]
      01:00.0 Pericom PI7C9X111SL PCIe-to-PCI Reversible Bridge to [bus 02-0a]
      02:00.0 Pericom Device 8608 [PCIe Upstream Port] to [bus 03-0a]
      03:01.0 Pericom Device 8608 [PCIe Downstream Port] to [bus 0a]
    
    01:00.0 is configured as a PCI-to-PCIe bridge (despite the name printed by
    lspci).  As we traverse a PCIe hierarchy, device connections alternate
    between PCIe Links and internal Switch logic.  Previously we did not
    recognize that 01:00.0 had a secondary link, so we thought the 02:00.0
    Upstream Port *did* have a secondary link.  In fact, it's the other way
    around: 01:00.0 has a secondary link, and 02:00.0 has internal Switch logic
    on its secondary side.
    
    When we thought 02:00.0 had a secondary link, the pci_scan_slot() ->
    only_one_child() path assumed 02:00.0 could have only one child, so 03:00.0
    was the only possible downstream device.  But 03:00.0 doesn't exist, so we
    didn't look for any other devices on bus 03.
    
    Booting with "pci=pcie_scan_all" is a workaround, but we don't want users
    to have to do that.
    
    Recognize that PCI-to-PCIe bridges originate links on their secondary
    interfaces.
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=189361
    Fixes: d0751b98dfa3 ("PCI: Add dev->has_secondary_link to track downstream PCIe links")
    Tested-by: Blake Moore <blake.moore@men.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    CC: stable@vger.kernel.org      # v4.2+

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index e164b5c9f0f0..204960e70333 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1169,6 +1169,7 @@ void set_pcie_port_type(struct pci_dev *pdev)
 	pos = pci_find_capability(pdev, PCI_CAP_ID_EXP);
 	if (!pos)
 		return;
+
 	pdev->pcie_cap = pos;
 	pci_read_config_word(pdev, pos + PCI_EXP_FLAGS, &reg16);
 	pdev->pcie_flags_reg = reg16;
@@ -1176,13 +1177,14 @@ void set_pcie_port_type(struct pci_dev *pdev)
 	pdev->pcie_mpss = reg16 & PCI_EXP_DEVCAP_PAYLOAD;
 
 	/*
-	 * A Root Port is always the upstream end of a Link.  No PCIe
-	 * component has two Links.  Two Links are connected by a Switch
-	 * that has a Port on each Link and internal logic to connect the
-	 * two Ports.
+	 * A Root Port or a PCI-to-PCIe bridge is always the upstream end
+	 * of a Link.  No PCIe component has two Links.  Two Links are
+	 * connected by a Switch that has a Port on each Link and internal
+	 * logic to connect the two Ports.
 	 */
 	type = pci_pcie_type(pdev);
-	if (type == PCI_EXP_TYPE_ROOT_PORT)
+	if (type == PCI_EXP_TYPE_ROOT_PORT ||
+	    type == PCI_EXP_TYPE_PCIE_BRIDGE)
 		pdev->has_secondary_link = 1;
 	else if (type == PCI_EXP_TYPE_UPSTREAM ||
 		 type == PCI_EXP_TYPE_DOWNSTREAM) {

commit 977509f7c5c6fb992ffcdf4291051af343b91645
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Jan 2 14:04:24 2017 -0600

    PCI: Apply _HPX settings only to relevant devices
    
    Previously we didn't check the type of device before trying to apply Type 1
    (PCI-X) or Type 2 (PCIe) Setting Records from _HPX.
    
    We don't support PCI-X Setting Records, so this was harmless, but the
    warning was useless.
    
    We do support PCIe Setting Records, and we didn't check whether a device
    was PCIe before applying settings.  I don't think anything bad happened on
    non-PCIe devices because pcie_capability_clear_and_set_word(),
    pcie_cap_has_lnkctl(), etc., would fail before doing any harm.  But it's
    ugly to depend on those internals.
    
    Check the device type before attempting to apply Type 1 and Type 2 Setting
    Records (Type 0 records are applicable to PCI, PCI-X, and PCIe devices).
    
    A side benefit is that this prevents useless "not supported" warnings when
    a BIOS supplies a Type 1 (PCI-X) Setting Record and we try to apply it to
    every single device:
    
      pci 0000:00:00.0: PCI-X settings not supported
    
    After this patch, we'll get the warning only when a BIOS supplies a Type 1
    record and we have a PCI-X device to which it should be applied.
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=187731
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index e164b5c9f0f0..aca5b2466adb 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1554,8 +1554,16 @@ static void program_hpp_type0(struct pci_dev *dev, struct hpp_type0 *hpp)
 
 static void program_hpp_type1(struct pci_dev *dev, struct hpp_type1 *hpp)
 {
-	if (hpp)
-		dev_warn(&dev->dev, "PCI-X settings not supported\n");
+	int pos;
+
+	if (!hpp)
+		return;
+
+	pos = pci_find_capability(dev, PCI_CAP_ID_PCIX);
+	if (!pos)
+		return;
+
+	dev_warn(&dev->dev, "PCI-X settings not supported\n");
 }
 
 static bool pcie_root_rcb_set(struct pci_dev *dev)
@@ -1581,6 +1589,9 @@ static void program_hpp_type2(struct pci_dev *dev, struct hpp_type2 *hpp)
 	if (!hpp)
 		return;
 
+	if (!pci_is_pcie(dev))
+		return;
+
 	if (hpp->revision > 1) {
 		dev_warn(&dev->dev, "PCIe settings rev %d not supported\n",
 			 hpp->revision);

commit 0ab7b12c49b6fbf2d4d0381374b82935f949be5f
Merge: a9a16a6d1365 b08d2e61a6f9
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Dec 15 12:46:48 2016 -0800

    Merge tag 'pci-v4.10-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI updates from Bjorn Helgaas:
     "PCI changes:
    
       - add support for PCI on ARM64 boxes with ACPI. We already had this
         for theoretical spec-compliant hardware; now we're adding quirks
         for the actual hardware (Cavium, HiSilicon, Qualcomm, X-Gene)
    
       - add runtime PM support for hotplug ports
    
       - enable runtime suspend for Intel UHCI that uses platform-specific
         wakeup signaling
    
       - add yet another host bridge registration interface. We hope this is
         extensible enough to subsume the others
    
       - expose device revision in sysfs for DRM
    
       - to avoid device conflicts, make sure any VF BAR updates are done
         before enabling the VF
    
       - avoid unnecessary link retrains for ASPM
    
       - allow INTx masking on Mellanox devices that support it
    
       - allow access to non-standard VPD for Chelsio devices
    
       - update Broadcom iProc support for PAXB v2, PAXC v2, inbound DMA,
         etc
    
       - update Rockchip support for max-link-speed
    
       - add NVIDIA Tegra210 support
    
       - add Layerscape LS1046a support
    
       - update R-Car compatibility strings
    
       - add Qualcomm MSM8996 support
    
       - remove some uninformative bootup messages"
    
    * tag 'pci-v4.10-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (115 commits)
      PCI: Enable access to non-standard VPD for Chelsio devices (cxgb3)
      PCI: Expand "VPD access disabled" quirk message
      PCI: pciehp: Remove loading message
      PCI: hotplug: Remove hotplug core message
      PCI: Remove service driver load/unload messages
      PCI/AER: Log AER IRQ when claiming Root Port
      PCI/AER: Log errors with PCI device, not PCIe service device
      PCI/AER: Remove unused version macros
      PCI/PME: Log PME IRQ when claiming Root Port
      PCI/PME: Drop unused support for PMEs from Root Complex Event Collectors
      PCI: Move config space size macros to pci_regs.h
      x86/platform/intel-mid: Constify mid_pci_platform_pm
      PCI/ASPM: Don't retrain link if ASPM not possible
      PCI: iproc: Skip check for legacy IRQ on PAXC buses
      PCI: pciehp: Leave power indicator on when enabling already-enabled slot
      PCI: pciehp: Prioritize data-link event over presence detect
      PCI: rcar: Add gen3 fallback compatibility string for pcie-rcar
      PCI: rcar: Use gen2 fallback compatibility last
      PCI: rcar-gen2: Use gen2 fallback compatibility last
      PCI: rockchip: Move the deassert of pm/aclk/pclk after phy_init()
      ..

commit d34efd22acace472ad33887842117933ee631391
Merge: f77b3244c187 af099eab35c3
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Dec 12 11:25:12 2016 -0600

    Merge branch 'pci/host-tegra' into next
    
    * pci/host-tegra:
      arm64: tegra: Enable PCIe on Jetson TX1
      arm64: tegra: Add PCIe host bridge on Tegra210
      PCI: tegra: Enable the driver on 64-bit ARM
      PCI: tegra: Add Tegra210 support
      PCI: tegra: Implement PCA enable workaround
      dt-bindings: pci: tegra: Add Tegra210 support
      PCI: tegra: Use new pci_register_host_bridge() interface
      PCI: Export host bridge registration interface
      PCI: Allow driver-specific data in host bridge
      PCI: Add pci_register_host_bridge() interface

commit a52d1443bba1db98907521414727eee22ae8c380
Author: Thierry Reding <treding@nvidia.com>
Date:   Fri Nov 25 11:57:11 2016 +0100

    PCI: Export host bridge registration interface
    
    Allow PCI host bridge drivers to use the new host bridge interfaces to
    register their host bridge.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Bjorn Helgaas <helgaas@kernel.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index cf9cb6f30782..f85ecb595c30 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -521,7 +521,7 @@ static void pci_release_host_bridge_dev(struct device *dev)
 	kfree(bridge);
 }
 
-static struct pci_host_bridge *pci_alloc_host_bridge(size_t priv)
+struct pci_host_bridge *pci_alloc_host_bridge(size_t priv)
 {
 	struct pci_host_bridge *bridge;
 
@@ -533,6 +533,7 @@ static struct pci_host_bridge *pci_alloc_host_bridge(size_t priv)
 
 	return bridge;
 }
+EXPORT_SYMBOL(pci_alloc_host_bridge);
 
 static const unsigned char pcix_bus_speed[] = {
 	PCI_SPEED_UNKNOWN,		/* 0 */
@@ -717,7 +718,7 @@ static void pci_set_bus_msi_domain(struct pci_bus *bus)
 	dev_set_msi_domain(&bus->dev, d);
 }
 
-static int pci_register_host_bridge(struct pci_host_bridge *bridge)
+int pci_register_host_bridge(struct pci_host_bridge *bridge)
 {
 	struct device *parent = bridge->dev.parent;
 	struct resource_entry *window, *n;
@@ -832,6 +833,7 @@ static int pci_register_host_bridge(struct pci_host_bridge *bridge)
 	kfree(bus);
 	return err;
 }
+EXPORT_SYMBOL(pci_register_host_bridge);
 
 static struct pci_bus *pci_alloc_child_bus(struct pci_bus *parent,
 					   struct pci_dev *bridge, int busnr)

commit 5909406598d9fab58be860b72dff9409bff11653
Author: Thierry Reding <treding@nvidia.com>
Date:   Fri Nov 25 11:57:10 2016 +0100

    PCI: Allow driver-specific data in host bridge
    
    Provide a way to allocate driver-specific data along with a PCI host bridge
    structure. The bridge's ->private field points to this data.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Bjorn Helgaas <helgaas@kernel.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 4853c8fbd701..cf9cb6f30782 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -521,11 +521,11 @@ static void pci_release_host_bridge_dev(struct device *dev)
 	kfree(bridge);
 }
 
-static struct pci_host_bridge *pci_alloc_host_bridge(void)
+static struct pci_host_bridge *pci_alloc_host_bridge(size_t priv)
 {
 	struct pci_host_bridge *bridge;
 
-	bridge = kzalloc(sizeof(*bridge), GFP_KERNEL);
+	bridge = kzalloc(sizeof(*bridge) + priv, GFP_KERNEL);
 	if (!bridge)
 		return NULL;
 
@@ -2253,7 +2253,7 @@ static struct pci_bus *pci_create_root_bus_msi(struct device *parent,
 	int error;
 	struct pci_host_bridge *bridge;
 
-	bridge = pci_alloc_host_bridge();
+	bridge = pci_alloc_host_bridge(0);
 	if (!bridge)
 		return NULL;
 

commit 37d6a0a6f4700ad3ae7bbf8db38b4557e97b3fe4
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Nov 25 11:57:09 2016 +0100

    PCI: Add pci_register_host_bridge() interface
    
    Make the existing pci_host_bridge structure a proper device that is usable
    by PCI host drivers in a more standard way. In addition to the existing
    pci_scan_bus(), pci_scan_root_bus(), pci_scan_root_bus_msi(), and
    pci_create_root_bus() interfaces, this unfortunately means having to add
    yet another interface doing basically the same thing, and add some extra
    code in the initial step.
    
    However, this time it's more likely to be extensible enough that we won't
    have to do another one again in the future, and we should be able to reduce
    code much more as a result.
    
    The main idea is to pull the allocation of 'struct pci_host_bridge' out of
    the registration, and let individual host drivers and architecture code
    fill the members before calling the registration function.
    
    There are a number of things we can do based on this:
    
    * Use a single memory allocation for the driver-specific structure
      and the generic PCI host bridge
    * consolidate the contents of driver-specific structures by moving
      them into pci_host_bridge
    * Add a consistent interface for removing a PCI host bridge again
      when unloading a host driver module
    * Replace the architecture specific __weak pcibios_*() functions with
      callbacks in a pci_host_bridge device
    * Move common boilerplate code from host drivers into the generic
      function, based on contents of the structure
    * Extend pci_host_bridge with additional members when needed without
      having to add arguments to pci_scan_*().
    * Move members of struct pci_bus into pci_host_bridge to avoid
      having lots of identical copies.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Bjorn Helgaas <helgaas@kernel.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index ab002671fa60..4853c8fbd701 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -521,7 +521,7 @@ static void pci_release_host_bridge_dev(struct device *dev)
 	kfree(bridge);
 }
 
-static struct pci_host_bridge *pci_alloc_host_bridge(struct pci_bus *b)
+static struct pci_host_bridge *pci_alloc_host_bridge(void)
 {
 	struct pci_host_bridge *bridge;
 
@@ -530,7 +530,7 @@ static struct pci_host_bridge *pci_alloc_host_bridge(struct pci_bus *b)
 		return NULL;
 
 	INIT_LIST_HEAD(&bridge->windows);
-	bridge->bus = b;
+
 	return bridge;
 }
 
@@ -717,6 +717,122 @@ static void pci_set_bus_msi_domain(struct pci_bus *bus)
 	dev_set_msi_domain(&bus->dev, d);
 }
 
+static int pci_register_host_bridge(struct pci_host_bridge *bridge)
+{
+	struct device *parent = bridge->dev.parent;
+	struct resource_entry *window, *n;
+	struct pci_bus *bus, *b;
+	resource_size_t offset;
+	LIST_HEAD(resources);
+	struct resource *res;
+	char addr[64], *fmt;
+	const char *name;
+	int err;
+
+	bus = pci_alloc_bus(NULL);
+	if (!bus)
+		return -ENOMEM;
+
+	bridge->bus = bus;
+
+	/* temporarily move resources off the list */
+	list_splice_init(&bridge->windows, &resources);
+	bus->sysdata = bridge->sysdata;
+	bus->msi = bridge->msi;
+	bus->ops = bridge->ops;
+	bus->number = bus->busn_res.start = bridge->busnr;
+#ifdef CONFIG_PCI_DOMAINS_GENERIC
+	bus->domain_nr = pci_bus_find_domain_nr(bus, parent);
+#endif
+
+	b = pci_find_bus(pci_domain_nr(bus), bridge->busnr);
+	if (b) {
+		/* If we already got to this bus through a different bridge, ignore it */
+		dev_dbg(&b->dev, "bus already known\n");
+		err = -EEXIST;
+		goto free;
+	}
+
+	dev_set_name(&bridge->dev, "pci%04x:%02x", pci_domain_nr(bus),
+		     bridge->busnr);
+
+	err = pcibios_root_bridge_prepare(bridge);
+	if (err)
+		goto free;
+
+	err = device_register(&bridge->dev);
+	if (err)
+		put_device(&bridge->dev);
+
+	bus->bridge = get_device(&bridge->dev);
+	device_enable_async_suspend(bus->bridge);
+	pci_set_bus_of_node(bus);
+	pci_set_bus_msi_domain(bus);
+
+	if (!parent)
+		set_dev_node(bus->bridge, pcibus_to_node(bus));
+
+	bus->dev.class = &pcibus_class;
+	bus->dev.parent = bus->bridge;
+
+	dev_set_name(&bus->dev, "%04x:%02x", pci_domain_nr(bus), bus->number);
+	name = dev_name(&bus->dev);
+
+	err = device_register(&bus->dev);
+	if (err)
+		goto unregister;
+
+	pcibios_add_bus(bus);
+
+	/* Create legacy_io and legacy_mem files for this bus */
+	pci_create_legacy_files(bus);
+
+	if (parent)
+		dev_info(parent, "PCI host bridge to bus %s\n", name);
+	else
+		pr_info("PCI host bridge to bus %s\n", name);
+
+	/* Add initial resources to the bus */
+	resource_list_for_each_entry_safe(window, n, &resources) {
+		list_move_tail(&window->node, &bridge->windows);
+		offset = window->offset;
+		res = window->res;
+
+		if (res->flags & IORESOURCE_BUS)
+			pci_bus_insert_busn_res(bus, bus->number, res->end);
+		else
+			pci_bus_add_resource(bus, res, 0);
+
+		if (offset) {
+			if (resource_type(res) == IORESOURCE_IO)
+				fmt = " (bus address [%#06llx-%#06llx])";
+			else
+				fmt = " (bus address [%#010llx-%#010llx])";
+
+			snprintf(addr, sizeof(addr), fmt,
+				 (unsigned long long)(res->start - offset),
+				 (unsigned long long)(res->end - offset));
+		} else
+			addr[0] = '\0';
+
+		dev_info(&bus->dev, "root bus resource %pR%s\n", res, addr);
+	}
+
+	down_write(&pci_bus_sem);
+	list_add_tail(&bus->node, &pci_root_buses);
+	up_write(&pci_bus_sem);
+
+	return 0;
+
+unregister:
+	put_device(&bridge->dev);
+	device_unregister(&bridge->dev);
+
+free:
+	kfree(bus);
+	return err;
+}
+
 static struct pci_bus *pci_alloc_child_bus(struct pci_bus *parent,
 					   struct pci_dev *bridge, int busnr)
 {
@@ -2130,113 +2246,43 @@ void __weak pcibios_remove_bus(struct pci_bus *bus)
 {
 }
 
-struct pci_bus *pci_create_root_bus(struct device *parent, int bus,
-		struct pci_ops *ops, void *sysdata, struct list_head *resources)
+static struct pci_bus *pci_create_root_bus_msi(struct device *parent,
+		int bus, struct pci_ops *ops, void *sysdata,
+		struct list_head *resources, struct msi_controller *msi)
 {
 	int error;
 	struct pci_host_bridge *bridge;
-	struct pci_bus *b, *b2;
-	struct resource_entry *window, *n;
-	struct resource *res;
-	resource_size_t offset;
-	char bus_addr[64];
-	char *fmt;
-
-	b = pci_alloc_bus(NULL);
-	if (!b)
-		return NULL;
 
-	b->sysdata = sysdata;
-	b->ops = ops;
-	b->number = b->busn_res.start = bus;
-#ifdef CONFIG_PCI_DOMAINS_GENERIC
-	b->domain_nr = pci_bus_find_domain_nr(b, parent);
-#endif
-	b2 = pci_find_bus(pci_domain_nr(b), bus);
-	if (b2) {
-		/* If we already got to this bus through a different bridge, ignore it */
-		dev_dbg(&b2->dev, "bus already known\n");
-		goto err_out;
-	}
-
-	bridge = pci_alloc_host_bridge(b);
+	bridge = pci_alloc_host_bridge();
 	if (!bridge)
-		goto err_out;
+		return NULL;
 
 	bridge->dev.parent = parent;
 	bridge->dev.release = pci_release_host_bridge_dev;
-	dev_set_name(&bridge->dev, "pci%04x:%02x", pci_domain_nr(b), bus);
-	error = pcibios_root_bridge_prepare(bridge);
-	if (error) {
-		kfree(bridge);
-		goto err_out;
-	}
-
-	error = device_register(&bridge->dev);
-	if (error) {
-		put_device(&bridge->dev);
-		goto err_out;
-	}
-	b->bridge = get_device(&bridge->dev);
-	device_enable_async_suspend(b->bridge);
-	pci_set_bus_of_node(b);
-	pci_set_bus_msi_domain(b);
 
-	if (!parent)
-		set_dev_node(b->bridge, pcibus_to_node(b));
-
-	b->dev.class = &pcibus_class;
-	b->dev.parent = b->bridge;
-	dev_set_name(&b->dev, "%04x:%02x", pci_domain_nr(b), bus);
-	error = device_register(&b->dev);
-	if (error)
-		goto class_dev_reg_err;
+	list_splice_init(resources, &bridge->windows);
+	bridge->sysdata = sysdata;
+	bridge->busnr = bus;
+	bridge->ops = ops;
+	bridge->msi = msi;
 
-	pcibios_add_bus(b);
-
-	/* Create legacy_io and legacy_mem files for this bus */
-	pci_create_legacy_files(b);
-
-	if (parent)
-		dev_info(parent, "PCI host bridge to bus %s\n", dev_name(&b->dev));
-	else
-		printk(KERN_INFO "PCI host bridge to bus %s\n", dev_name(&b->dev));
-
-	/* Add initial resources to the bus */
-	resource_list_for_each_entry_safe(window, n, resources) {
-		list_move_tail(&window->node, &bridge->windows);
-		res = window->res;
-		offset = window->offset;
-		if (res->flags & IORESOURCE_BUS)
-			pci_bus_insert_busn_res(b, bus, res->end);
-		else
-			pci_bus_add_resource(b, res, 0);
-		if (offset) {
-			if (resource_type(res) == IORESOURCE_IO)
-				fmt = " (bus address [%#06llx-%#06llx])";
-			else
-				fmt = " (bus address [%#010llx-%#010llx])";
-			snprintf(bus_addr, sizeof(bus_addr), fmt,
-				 (unsigned long long) (res->start - offset),
-				 (unsigned long long) (res->end - offset));
-		} else
-			bus_addr[0] = '\0';
-		dev_info(&b->dev, "root bus resource %pR%s\n", res, bus_addr);
-	}
+	error = pci_register_host_bridge(bridge);
+	if (error < 0)
+		goto err_out;
 
-	down_write(&pci_bus_sem);
-	list_add_tail(&b->node, &pci_root_buses);
-	up_write(&pci_bus_sem);
+	return bridge->bus;
 
-	return b;
-
-class_dev_reg_err:
-	put_device(&bridge->dev);
-	device_unregister(&bridge->dev);
 err_out:
-	kfree(b);
+	kfree(bridge);
 	return NULL;
 }
+
+struct pci_bus *pci_create_root_bus(struct device *parent, int bus,
+		struct pci_ops *ops, void *sysdata, struct list_head *resources)
+{
+	return pci_create_root_bus_msi(parent, bus, ops, sysdata, resources,
+				       NULL);
+}
 EXPORT_SYMBOL_GPL(pci_create_root_bus);
 
 int pci_bus_insert_busn_res(struct pci_bus *b, int bus, int bus_max)
@@ -2317,12 +2363,10 @@ struct pci_bus *pci_scan_root_bus_msi(struct device *parent, int bus,
 			break;
 		}
 
-	b = pci_create_root_bus(parent, bus, ops, sysdata, resources);
+	b = pci_create_root_bus_msi(parent, bus, ops, sysdata, resources, msi);
 	if (!b)
 		return NULL;
 
-	b->msi = msi;
-
 	if (!found) {
 		dev_info(&b->dev,
 		 "No busn resource found for root bus, will use [bus %02x-ff]\n",

commit 1465f481460cbfc60dc119873099d89a58f9be4f
Merge: 3e5de27e940d 00c7c81f7b49 18b709beb503 ebcfa2843954 37bad55b784c 24c790fbf5d8 2f5f44f205cc
Author: Joerg Roedel <jroedel@suse.de>
Date:   Tue Dec 6 17:32:16 2016 +0100

    Merge branches 'arm/mediatek', 'arm/smmu', 'x86/amd', 's390', 'core' and 'arm/exynos' into next

commit 7a6d312b50e63f598f5b5914c4fd21878ac2b595
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Nov 28 17:21:02 2016 -0600

    PCI: Decouple IORESOURCE_ROM_ENABLE and PCI_ROM_ADDRESS_ENABLE
    
    Remove the assumption that IORESOURCE_ROM_ENABLE == PCI_ROM_ADDRESS_ENABLE.
    PCI_ROM_ADDRESS_ENABLE is the ROM enable bit defined by the PCI spec, so if
    we're reading or writing a BAR register value, that's what we should use.
    IORESOURCE_ROM_ENABLE is a corresponding bit in struct resource flags.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Gavin Shan <gwshan@linux.vnet.ibm.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index ab002671fa60..cf7670e81979 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -227,7 +227,8 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 			mask64 = (u32)PCI_BASE_ADDRESS_MEM_MASK;
 		}
 	} else {
-		res->flags |= (l & IORESOURCE_ROM_ENABLE);
+		if (l & PCI_ROM_ADDRESS_ENABLE)
+			res->flags |= IORESOURCE_ROM_ENABLE;
 		l64 = l & PCI_ROM_ADDRESS_MASK;
 		sz64 = sz & PCI_ROM_ADDRESS_MASK;
 		mask64 = (u32)PCI_ROM_ADDRESS_MASK;

commit d760a1baf20e067d3a063aa134834ddd3d183e2f
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Mon Nov 21 10:01:39 2016 +0000

    ACPI: Implement acpi_dma_configure
    
    On DT based systems, the of_dma_configure() API implements DMA
    configuration for a given device. On ACPI systems an API equivalent to
    of_dma_configure() is missing which implies that it is currently not
    possible to set-up DMA operations for devices through the ACPI generic
    kernel layer.
    
    This patch fills the gap by introducing acpi_dma_configure/deconfigure()
    calls that for now are just wrappers around arch_setup_dma_ops() and
    arch_teardown_dma_ops() and also updates ACPI and PCI core code to use
    the newly introduced acpi_dma_configure/acpi_dma_deconfigure functions.
    
    Since acpi_dma_configure() is used to configure DMA operations, the
    function initializes the dma/coherent_dma masks to sane default values
    if the current masks are uninitialized (also to keep the default values
    consistent with DT systems) to make sure the device has a complete
    default DMA set-up.
    
    The DMA range size passed to arch_setup_dma_ops() is sized according
    to the device coherent_dma_mask (starting at address 0x0), mirroring the
    DT probing path behaviour when a dma-ranges property is not provided
    for the device being probed; this changes the current arch_setup_dma_ops()
    call parameters in the ACPI probing case, but since arch_setup_dma_ops()
    is a NOP on all architectures but ARM/ARM64 this patch does not change
    the current kernel behaviour on them.
    
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com> [pci]
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Tomasz Nowicki <tn@semihalf.com>
    Tested-by: Hanjun Guo <hanjun.guo@linaro.org>
    Tested-by: Tomasz Nowicki <tn@semihalf.com>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Robin Murphy <robin.murphy@arm.com>
    Cc: Tomasz Nowicki <tn@semihalf.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index ab002671fa60..c29e07ad5a7f 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1738,8 +1738,7 @@ static void pci_dma_configure(struct pci_dev *dev)
 		if (attr == DEV_DMA_NOT_SUPPORTED)
 			dev_warn(&dev->dev, "DMA not supported.\n");
 		else
-			arch_setup_dma_ops(&dev->dev, 0, 0, NULL,
-					   attr == DEV_DMA_COHERENT);
+			acpi_dma_configure(&dev->dev, attr);
 	}
 
 	pci_put_host_bridge_device(bridge);

commit e42010d8207f9d15a605ceb8e321bcd9648071b0
Author: Johannes Thumshirn <jthumshirn@suse.de>
Date:   Wed Nov 23 10:56:28 2016 -0600

    PCI: Set Read Completion Boundary to 128 iff Root Port supports it (_HPX)
    
    Per PCIe spec r3.0, sec 2.3.1.1, the Read Completion Boundary (RCB)
    determines the naturally aligned address boundaries on which a Read Request
    may be serviced with multiple Completions:
    
      - For a Root Complex, RCB is 64 bytes or 128 bytes
        This value is reported in the Link Control Register
    
        Note: Bridges and Endpoints may implement a corresponding command bit
        which may be set by system software to indicate the RCB value for the
        Root Complex, allowing the Bridge/Endpoint to optimize its behavior
        when the Root Complex’s RCB is 128 bytes.
    
      - For all other system elements, RCB is 128 bytes
    
    Per sec 7.8.7, if a Root Port only supports a 64-byte RCB, the RCB of all
    downstream devices must be clear, indicating an RCB of 64 bytes.  If the
    Root Port supports a 128-byte RCB, we may optionally set the RCB of
    downstream devices so they know they can generate larger Completions.
    
    Some BIOSes supply an _HPX that tells us to set RCB, even though the Root
    Port doesn't have RCB set, which may lead to Malformed TLP errors if the
    Endpoint generates completions larger than the Root Port can handle.
    
    The IBM x3850 X6 with BIOS version -[A8E120CUS-1.30]- 08/22/2016 supplies
    such an _HPX and a Mellanox MT27500 ConnectX-3 device fails to initialize:
    
      mlx4_core 0000:41:00.0: command 0xfff timed out (go bit not cleared)
      mlx4_core 0000:41:00.0: device is going to be reset
      mlx4_core 0000:41:00.0: Failed to obtain HW semaphore, aborting
      mlx4_core 0000:41:00.0: Fail to reset HCA
      ------------[ cut here ]------------
      kernel BUG at drivers/net/ethernet/mellanox/mlx4/catas.c:193!
    
    After 6cd33649fa83 ("PCI: Add pci_configure_device() during enumeration")
    and 7a1562d4f2d0 ("PCI: Apply _HPX Link Control settings to all devices
    with a link"), we apply _HPX settings to *all* devices, not just those
    hot-added after boot.
    
    Before 7a1562d4f2d0, we didn't touch the Mellanox RCB, and the device
    worked.  After 7a1562d4f2d0, we set its RCB to 128, and it failed.
    
    Set the RCB to 128 iff the Root Port supports a 128-byte RCB.  Otherwise,
    set RCB to 64 bytes.  This effectively ignores what _HPX tells us about
    RCB.
    
    Note that this change only affects _HPX handling.  If we have no _HPX, this
    does nothing with RCB.
    
    [bhelgaas: changelog, clear RCB if not set for Root Port]
    Fixes: 6cd33649fa83 ("PCI: Add pci_configure_device() during enumeration")
    Fixes: 7a1562d4f2d0 ("PCI: Apply _HPX Link Control settings to all devices with a link")
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=187781
    Tested-by: Frank Danapfel <fdanapfe@redhat.com>
    Signed-off-by: Johannes Thumshirn <jthumshirn@suse.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Myron Stowe <myron.stowe@redhat.com>
    CC: stable@vger.kernel.org      # v3.18+

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index ab002671fa60..104c46d53121 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1439,6 +1439,21 @@ static void program_hpp_type1(struct pci_dev *dev, struct hpp_type1 *hpp)
 		dev_warn(&dev->dev, "PCI-X settings not supported\n");
 }
 
+static bool pcie_root_rcb_set(struct pci_dev *dev)
+{
+	struct pci_dev *rp = pcie_find_root_port(dev);
+	u16 lnkctl;
+
+	if (!rp)
+		return false;
+
+	pcie_capability_read_word(rp, PCI_EXP_LNKCTL, &lnkctl);
+	if (lnkctl & PCI_EXP_LNKCTL_RCB)
+		return true;
+
+	return false;
+}
+
 static void program_hpp_type2(struct pci_dev *dev, struct hpp_type2 *hpp)
 {
 	int pos;
@@ -1468,9 +1483,20 @@ static void program_hpp_type2(struct pci_dev *dev, struct hpp_type2 *hpp)
 			~hpp->pci_exp_devctl_and, hpp->pci_exp_devctl_or);
 
 	/* Initialize Link Control Register */
-	if (pcie_cap_has_lnkctl(dev))
+	if (pcie_cap_has_lnkctl(dev)) {
+
+		/*
+		 * If the Root Port supports Read Completion Boundary of
+		 * 128, set RCB to 128.  Otherwise, clear it.
+		 */
+		hpp->pci_exp_lnkctl_and |= PCI_EXP_LNKCTL_RCB;
+		hpp->pci_exp_lnkctl_or &= ~PCI_EXP_LNKCTL_RCB;
+		if (pcie_root_rcb_set(dev))
+			hpp->pci_exp_lnkctl_or |= PCI_EXP_LNKCTL_RCB;
+
 		pcie_capability_clear_and_set_word(dev, PCI_EXP_LNKCTL,
 			~hpp->pci_exp_lnkctl_and, hpp->pci_exp_lnkctl_or);
+	}
 
 	/* Find Advanced Error Reporting Enhanced Capability */
 	pos = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ERR);

commit 4dc2db096a9f7c0316bafc18ee00d89e0acf4ebf
Merge: 9e18ad98ca71 6b20f7285490
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Oct 3 09:42:57 2016 -0500

    Merge branch 'pci/aer' into next
    
    * pci/aer:
      PCI/AER: Fix aer_probe() kernel-doc comment
      PCI/AER: Cache capability position
      PCI/AER: Avoid memory allocation in interrupt handling path
      ACPI / APEI: Send correct severity to calculate AER severity
      PCI/AER: Remove duplicate AER severity translation
      PCI/AER: Remove aerdriver.forceload kernel parameter
      PCI/AER: Remove aerdriver.nosourceid kernel parameter
      x86/PCI: VMD: Add quirk for AER to ignore source ID
      PCI/AER: Add bus flag to skip source ID matching
    
    Conflicts:
            drivers/pci/probe.c

commit 66b808099146166c44157600a166c8372172cd76
Author: Keith Busch <keith.busch@intel.com>
Date:   Tue Sep 27 16:23:34 2016 -0400

    PCI/AER: Cache capability position
    
    Save the position of the error reporting capability so it doesn't need to
    be rediscovered during error handling.
    
    Signed-off-by: Keith Busch <keith.busch@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    CC: Lukas Wunner <lukas@wunner.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 93f280df3428..157572420513 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1666,7 +1666,8 @@ static void pci_init_capabilities(struct pci_dev *dev)
 	/* Enable ACS P2P upstream forwarding */
 	pci_enable_acs(dev);
 
-	pci_cleanup_aer_error_status_regs(dev);
+	/* Advanced Error Reporting */
+	pci_aer_init(dev);
 }
 
 /*

commit 9bb04a0c4e261187be904d05c2bcd1da0eebc20c
Author: Jonathan Yong <jonathan.yong@intel.com>
Date:   Sat Jun 11 14:13:38 2016 -0500

    PCI: Add Precision Time Measurement (PTM) support
    
    Add Precision Time Measurement (PTM) support (see PCIe r3.1, sec 6.22).
    
    Enable PTM on PTM Root devices and switch ports.  This does not enable PTM
    on endpoints.
    
    There currently are no PTM-capable devices on the market, but it is
    expected to be supported by the Intel Apollo Lake platform.
    
    [bhelgaas: complete rework]
    Signed-off-by: Jonathan Yong <jonathan.yong@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 93f280df3428..e2e424472058 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1667,6 +1667,9 @@ static void pci_init_capabilities(struct pci_dev *dev)
 	pci_enable_acs(dev);
 
 	pci_cleanup_aer_error_status_regs(dev);
+
+	/* Precision Time Measurement */
+	pci_ptm_init(dev);
 }
 
 /*

commit a00c74c1664e6de4ad671c7c921a06ef164622c0
Merge: c5cb85b25837 a6c1c6f3547b a4959d8c1eaa e16b46605960 2a2aca316aed 3ee803641e76 ed91de7e14fb 9fad4012db45
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Aug 1 12:23:31 2016 -0500

    Merge branches 'pci/aspm', 'pci/dpc', 'pci/hotplug', 'pci/misc', 'pci/msi', 'pci/pm' and 'pci/virtualization' into next
    
    * pci/aspm:
      PCI/ASPM: Remove redundant check of pcie_set_clkpm
    
    * pci/dpc:
      PCI: Remove DPC tristate module option
      PCI: Bind DPC to Root Ports as well as Downstream Ports
      PCI: Fix whitespace in struct dpc_dev
      PCI: Convert Downstream Port Containment driver to use devm_* functions
    
    * pci/hotplug:
      PCI: Allow additional bus numbers for hotplug bridges
    
    * pci/misc:
      PCI: Include <asm/dma.h> for isa_dma_bridge_buggy
      PCI: Make bus_attr_resource_alignment static
      MAINTAINERS: Add file patterns for PCI device tree bindings
      PCI: Fix comment typo
    
    * pci/msi:
      PCI/MSI: irqchip: Fix PCI_MSI dependencies
    
    * pci/pm:
      PCI: pciehp: Ignore interrupts during D3cold
      PCI: Document connection between pci_power_t and hardware PM capability
      PCI: Add runtime PM support for PCIe ports
      ACPI / hotplug / PCI: Runtime resume bridge before rescan
      PCI: Power on bridges before scanning new devices
      PCI: Put PCIe ports into D3 during suspend
      PCI: Don't clear d3cold_allowed for PCIe ports
      PCI / PM: Enforce type casting for pci_power_t
    
    * pci/virtualization:
      PCI: Add ACS quirk for Solarflare SFC9220
      PCI: Add DMA alias quirk for Adaptec 3805
      PCI: Mark Atheros AR9485 and QCA9882 to avoid bus reset
      PCI: Add function 1 DMA alias quirk for Marvell 88SE9182

commit e16b46605960bd071a3e26f316e0bb600ae91e37
Author: Keith Busch <keith.busch@intel.com>
Date:   Thu Jul 21 21:40:28 2016 -0600

    PCI: Allow additional bus numbers for hotplug bridges
    
    A user may hot add a switch requiring more than one bus to enumerate.  This
    previously required a system reboot if BIOS did not sufficiently pad the
    bus resource, which they frequently don't do.
    
    Add a kernel parameter so a user can specify the minimum number of bus
    numbers to reserve for a hotplug bridge's subordinate buses so rebooting
    won't be necessary.
    
    The default is 1, which is equivalent to previous behavior.
    
    Signed-off-by: Keith Busch <keith.busch@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 8e3ef720997d..f680099c110d 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -2076,6 +2076,15 @@ unsigned int pci_scan_child_bus(struct pci_bus *bus)
 				max = pci_scan_bridge(bus, dev, max, pass);
 		}
 
+	/*
+	 * Make sure a hotplug bridge has at least the minimum requested
+	 * number of buses.
+	 */
+	if (bus->self && bus->self->is_hotplug_bridge && pci_hotplug_bus_size) {
+		if (max - bus->busn_res.start < pci_hotplug_bus_size - 1)
+			max = bus->busn_res.start + pci_hotplug_bus_size - 1;
+	}
+
 	/*
 	 * We've scanned the bus and so we know all about what's on
 	 * the other side of any bridges that may be on this bus plus

commit d963f6512e15fb2c0a9e9770078e2206f55c2f7a
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Thu Jun 2 11:17:13 2016 +0300

    PCI: Power on bridges before scanning new devices
    
    When a PCI device is removed through sysfs interface, the upstream bridge
    (PCIe port) can be runtime suspended if it was the last device on that bus.
    Now, if the bridge is in D3 we cannot find devices below the bridge
    anymore.  For example following fails to find the removed device again:
    
      # echo 1 > /sys/bus/pci/devices/0000:00:01.0/0000:01:00.0/remove
      # echo 1 > /sys/bus/pci/devices/0000:00:01.0/rescan
    
    Where 0000:00:01.0 is the bridge device.
    
    In order to be able to rescan devices below the bridge add
    pm_runtime_get_sync()/pm_runtime_put() calls to pci_scan_bridge().  This
    should keep bridges powered on while their children devices are being
    scanned.
    
    Reported-by: Peter Wu <peter@lekensteyn.nl>
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 8e3ef720997d..11a802daf242 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -16,6 +16,7 @@
 #include <linux/aer.h>
 #include <linux/acpi.h>
 #include <linux/irqdomain.h>
+#include <linux/pm_runtime.h>
 #include "pci.h"
 
 #define CARDBUS_LATENCY_TIMER	176	/* secondary latency timer */
@@ -832,6 +833,12 @@ int pci_scan_bridge(struct pci_bus *bus, struct pci_dev *dev, int max, int pass)
 	u8 primary, secondary, subordinate;
 	int broken = 0;
 
+	/*
+	 * Make sure the bridge is powered on to be able to access config
+	 * space of devices below it.
+	 */
+	pm_runtime_get_sync(&dev->dev);
+
 	pci_read_config_dword(dev, PCI_PRIMARY_BUS, &buses);
 	primary = buses & 0xFF;
 	secondary = (buses >> 8) & 0xFF;
@@ -1012,6 +1019,8 @@ int pci_scan_bridge(struct pci_bus *bus, struct pci_dev *dev, int max, int pass)
 out:
 	pci_write_config_word(dev, PCI_BRIDGE_CONTROL, bctl);
 
+	pm_runtime_put(&dev->dev);
+
 	return max;
 }
 EXPORT_SYMBOL(pci_scan_bridge);

commit 9c7cb891ecfea3b88e4fa255afeec0da84ea6a86
Author: Tomasz Nowicki <tn@semihalf.com>
Date:   Fri Jun 10 21:55:14 2016 +0200

    PCI: Refactor pci_bus_assign_domain_nr() for CONFIG_PCI_DOMAINS_GENERIC
    
    Instead of assigning bus->domain_nr inside pci_bus_assign_domain_nr(),
    return the domain and let the caller do the assignment.  Rename
    pci_bus_assign_domain_nr() to pci_bus_find_domain_nr() to reflect this.
    
    No functional change intended.
    
    [bhelgaas: changelog]
    Signed-off-by: Tomasz Nowicki <tn@semihalf.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 8e3ef720997d..380d46dc9a70 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -2127,7 +2127,9 @@ struct pci_bus *pci_create_root_bus(struct device *parent, int bus,
 	b->sysdata = sysdata;
 	b->ops = ops;
 	b->number = b->busn_res.start = bus;
-	pci_bus_assign_domain_nr(b, parent);
+#ifdef CONFIG_PCI_DOMAINS_GENERIC
+	b->domain_nr = pci_bus_find_domain_nr(b, parent);
+#endif
 	b2 = pci_find_bus(pci_domain_nr(b), bus);
 	if (b2) {
 		/* If we already got to this bus through a different bridge, ignore it */

commit 45604e68ed7acf23e6c4cbac9930c61df19220c8
Merge: d9322d226f91 f8415222837b ad67b437f187
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue May 17 14:35:38 2016 -0500

    Merge branches 'pci/hotplug' and 'pci/resource' into next
    
    * pci/hotplug:
      PCI: Use cached copy of PCI_EXP_SLTCAP_HPC bit
    
    * pci/resource:
      PCI: Disable all BAR sizing for devices with non-compliant BARs
      x86/PCI: Mark Broadwell-EP Home Agent 1 as having non-compliant BARs
      PCI: Identify Enhanced Allocation (EA) BAR Equivalent resources in sysfs

commit ad67b437f187ea818b2860524d10f878fadfdd99
Author: Prarit Bhargava <prarit@redhat.com>
Date:   Wed May 11 12:27:16 2016 -0400

    PCI: Disable all BAR sizing for devices with non-compliant BARs
    
    b84106b4e229 ("PCI: Disable IO/MEM decoding for devices with non-compliant
    BARs") disabled BAR sizing for BARs 0-5 of devices that don't comply with
    the PCI spec.  But it didn't do anything for expansion ROM BARs, so we
    still try to size them, resulting in warnings like this on Broadwell-EP:
    
      pci 0000:ff:12.0: BAR 6: failed to assign [mem size 0x00000001 pref]
    
    Move the non-compliant BAR check from __pci_read_base() up to
    pci_read_bases() so it applies to the expansion ROM BAR as well as
    to BARs 0-5.
    
    Note that direct callers of __pci_read_base(), like sriov_init(), will now
    bypass this check.  We haven't had reports of devices with broken SR-IOV
    BARs yet.
    
    [bhelgaas: changelog]
    Fixes: b84106b4e229 ("PCI: Disable IO/MEM decoding for devices with non-compliant BARs")
    Signed-off-by: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    CC: stable@vger.kernel.org
    CC: Thomas Gleixner <tglx@linutronix.de>
    CC: Ingo Molnar <mingo@redhat.com>
    CC: "H. Peter Anvin" <hpa@zytor.com>
    CC: Andi Kleen <ak@linux.intel.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 8004f67c57ec..bf8405fb4ace 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -179,9 +179,6 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 	u16 orig_cmd;
 	struct pci_bus_region region, inverted_region;
 
-	if (dev->non_compliant_bars)
-		return 0;
-
 	mask = type ? PCI_ROM_ADDRESS_MASK : ~0;
 
 	/* No printks while decoding is disabled! */
@@ -322,6 +319,9 @@ static void pci_read_bases(struct pci_dev *dev, unsigned int howmany, int rom)
 {
 	unsigned int pos, reg;
 
+	if (dev->non_compliant_bars)
+		return;
+
 	for (pos = 0; pos < howmany; pos++) {
 		struct resource *res = &dev->resource[pos];
 		reg = PCI_BASE_ADDRESS_0 + (pos << 2);

commit 338c3149a221527e202ee26b1e35f76c965bb6c0
Author: Jacek Lawrynowicz <jacek.lawrynowicz@intel.com>
Date:   Thu Mar 3 15:38:02 2016 +0100

    PCI: Add support for multiple DMA aliases
    
    Solve IOMMU support issues with PCIe non-transparent bridges that use
    Requester ID look-up tables (RID-LUT), e.g., the PEX8733.
    
    The NTB connects devices in two independent PCI domains.  Devices separated
    by the NTB are not able to discover each other.  A PCI packet being
    forwared from one domain to another has to have its RID modified so it
    appears on correct bus and completions are forwarded back to the original
    domain through the NTB.  The RID is translated using a preprogrammed table
    (LUT) and the PCI packet propagates upstream away from the NTB.  If the
    destination system has IOMMU enabled, the packet will be discarded because
    the new RID is unknown to the IOMMU.  Adding a DMA alias for the new RID
    allows IOMMU to properly recognize the packet.
    
    Each device behind the NTB has a unique RID assigned in the RID-LUT.  The
    current DMA alias implementation supports only a single alias, so it's not
    possible to support mutiple devices behind the NTB when IOMMU is enabled.
    
    Enable all possible aliases on a given bus (256) that are stored in a
    bitset.  Alias devfn is directly translated to a bit number.  The bitset is
    not allocated for devices that have no need for DMA aliases.
    
    More details can be found in the following article:
    http://www.plxtech.com/files/pdf/technical/expresslane/RTC_Enabling%20MulitHostSystemDesigns.pdf
    
    Signed-off-by: Jacek Lawrynowicz <jacek.lawrynowicz@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Alex Williamson <alex.williamson@redhat.com>
    Acked-by: David Woodhouse <David.Woodhouse@intel.com>
    Acked-by: Joerg Roedel <jroedel@suse.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 8004f67c57ec..ae7daeb83e21 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1537,6 +1537,7 @@ static void pci_release_dev(struct device *dev)
 	pcibios_release_device(pci_dev);
 	pci_bus_put(pci_dev->bus);
 	kfree(pci_dev->driver_override);
+	kfree(pci_dev->dma_alias_mask);
 	kfree(pci_dev);
 }
 

commit 6e6f498b039aa5558c7377fbbe65f7421d34cea4
Merge: cfeb8139a1fb bd5174dfb6f1
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Mar 15 08:56:28 2016 -0500

    Merge branch 'pci/resource' into next
    
    * pci/resource:
      PCI: Simplify pci_create_attr() control flow
      PCI: Don't leak memory if sysfs_create_bin_file() fails
      PCI: Simplify sysfs ROM cleanup
      PCI: Remove unused IORESOURCE_ROM_COPY and IORESOURCE_ROM_BIOS_COPY
      MIPS: Loongson 3: Keep CPU physical (not virtual) addresses in shadow ROM resource
      MIPS: Loongson 3: Use temporary struct resource * to avoid repetition
      ia64/PCI: Keep CPU physical (not virtual) addresses in shadow ROM resource
      ia64/PCI: Use ioremap() instead of open-coded equivalent
      ia64/PCI: Use temporary struct resource * to avoid repetition
      PCI: Clean up pci_map_rom() whitespace
      PCI: Remove arch-specific IORESOURCE_ROM_SHADOW size from sysfs
      PCI: Set ROM shadow location in arch code, not in PCI core
      PCI: Don't enable/disable ROM BAR if we're using a RAM shadow copy
      PCI: Don't assign or reassign immutable resources
      PCI: Mark shadow copy of VGA ROM as IORESOURCE_PCI_FIXED
      x86/PCI: Mark Broadwell-EP Home Agent & PCU as having non-compliant BARs
      PCI: Disable IO/MEM decoding for devices with non-compliant BARs

commit cfeb8139a1fbbbae3f1e986133f4e9e7833eeac4
Merge: 562df5c8521e 4daace0d8ce8
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Mar 15 08:56:16 2016 -0500

    Merge branch 'pci/host-hv' into next
    
    * pci/host-hv:
      PCI: hv: Add paravirtual PCI front-end for Microsoft Hyper-V VMs
      PCI: Look up IRQ domain by fwnode_handle
      PCI: Add fwnode_handle to x86 pci_sysdata

commit c334f9c89e40d2c9f4598e87e186bf3264d39e51
Merge: 18e5e6913b1a eff31f4002c4 28e3abe591e2 25de15c958e9 304e6d572bf2 e32faa303f7f 7b6e7ba8e81a 2c2c5c5cd213 01cf9d524ff0 ab597d35ef11
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Mar 15 08:55:19 2016 -0500

    Merge branches 'pci/host-altera', 'pci/host-imx6', 'pci/host-keystone', 'pci/host-rcar', 'pci/host-tegra', 'pci/host-thunder', 'pci/host-vmd', 'pci/host-xilinx' and 'pci/host-xilinx-nwl' into next
    
    * pci/host-altera:
      PCI: altera: Fix altera_pcie_link_is_up()
    
    * pci/host-imx6:
      PCI: imx6: Add DT bindings to configure PHY Tx driver settings
    
    * pci/host-keystone:
      PCI: keystone: Defer probing if devm_phy_get() returns -EPROBE_DEFER
    
    * pci/host-rcar:
      PCI: rcar: Depend on ARCH_RENESAS, not ARCH_SHMOBILE
    
    * pci/host-tegra:
      PCI: tegra: Remove misleading PHYS_OFFSET
      PCI: tegra: Track bus -> CPU mapping
      PCI: tegra: Remove unused struct tegra_pcie.num_ports field
      PCI: tegra: Implement ->{add,remove}_bus() callbacks
      PCI: Add pci_ops.{add,remove}_bus() callbacks
    
    * pci/host-thunder:
      PCI: thunder: Add driver for ThunderX-pass{1,2} on-chip devices
      PCI: thunder: Add PCIe host driver for ThunderX processors
      PCI: generic: Expose pci_host_common_probe() for use by other drivers
      PCI: generic: Add pci_host_common_probe(), based on gen_pci_probe()
      PCI: generic: Move structure definitions to separate header file
    
    * pci/host-vmd:
      x86/PCI: VMD: Attach VMD resources to parent domain's resource tree
      x86/PCI: VMD: Set bus resource start to 0
      x86/PCI: VMD: Document code for maintainability
    
    * pci/host-xilinx:
      microblaze/PCI: Support generic Xilinx AXI PCIe Host Bridge IP driver
      PCI: xilinx: Update Zynq binding with Microblaze node
      PCI: xilinx: Don't call pci_fixup_irqs() on Microblaze
      PCI: xilinx: Remove dependency on ARM-specific struct hw_pci
      PCI: xilinx: Use of_pci_get_host_bridge_resources() to parse DT
    
    * pci/host-xilinx-nwl:
      PCI: xilinx-nwl: Add support for Xilinx NWL PCIe Host Controller

commit 18e5e6913b1ae5c6f60390945d4c8446f5c40c89
Merge: a314966fad61 8e47e15e917f 6ca7227b3e24 cc73176cc91b 7b78f48a0443 5adecf817dd6 7c20078a8197
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Mar 15 08:55:02 2016 -0500

    Merge branches 'pci/aer', 'pci/enumeration', 'pci/kconfig', 'pci/misc', 'pci/virtualization' and 'pci/vpd' into next
    
    * pci/aer:
      PCI/AER: Log aer_inject error injections
      PCI/AER: Log actual error causes in aer_inject
      PCI/AER: Use dev_warn() in aer_inject
      PCI/AER: Fix aer_inject error codes
    
    * pci/enumeration:
      PCI: Fix broken URL for Dell biosdevname
    
    * pci/kconfig:
      PCI: Cleanup pci/pcie/Kconfig whitespace
      PCI: Include pci/hotplug Kconfig directly from pci/Kconfig
      PCI: Include pci/pcie/Kconfig directly from pci/Kconfig
    
    * pci/misc:
      PCI: Add PCI_CLASS_SERIAL_USB_DEVICE definition
      PCI: Add QEMU top-level IDs for (sub)vendor & device
      unicore32: Remove unused HAVE_ARCH_PCI_SET_DMA_MASK definition
      PCI: Consolidate PCI DMA constants and interfaces in linux/pci-dma-compat.h
      PCI: Move pci_dma_* helpers to common code
      frv/PCI: Remove stray pci_{alloc,free}_consistent() declaration
    
    * pci/virtualization:
      PCI: Wait for up to 1000ms after FLR reset
      PCI: Support SR-IOV on any function type
    
    * pci/vpd:
      PCI: Prevent VPD access for buggy devices
      PCI: Sleep rather than busy-wait for VPD access completion
      PCI: Fold struct pci_vpd_pci22 into struct pci_vpd
      PCI: Rename VPD symbols to remove unnecessary "pci22"
      PCI: Remove struct pci_vpd_ops.release function pointer
      PCI: Move pci_vpd_release() from header file to pci/access.c
      PCI: Move pci_read_vpd() and pci_write_vpd() close to other VPD code
      PCI: Determine actual VPD size on first access
      PCI: Use bitfield instead of bool for struct pci_vpd_pci22.busy
      PCI: Allow access to VPD attributes with size 0
      PCI: Update VPD definitions

commit 057bd2e0528ec68b3d0481ede0b26a31a9e5d2f1
Author: Thierry Reding <treding@nvidia.com>
Date:   Tue Feb 9 15:30:47 2016 +0100

    PCI: Add pci_ops.{add,remove}_bus() callbacks
    
    Add pci_ops.{add,remove}_bus() callbacks, which will be called on every
    newly created bus and when a bus is being removed, respectively.  This can
    be used by drivers to implement driver-specific initialization and teardown
    of the bus, in addition to the architecture-specifics implemented by the
    pcibios_add_bus() and the pcibios_remove_bus() functions.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 6d7ab9bb0d5a..3ea4de1c6926 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -758,6 +758,12 @@ static struct pci_bus *pci_alloc_child_bus(struct pci_bus *parent,
 
 	pcibios_add_bus(child);
 
+	if (child->ops->add_bus) {
+		ret = child->ops->add_bus(child);
+		if (WARN_ON(ret < 0))
+			dev_err(&child->dev, "failed to add bus: %d\n", ret);
+	}
+
 	/* Create legacy_io and legacy_mem files for this bus */
 	pci_create_legacy_files(child);
 

commit f1cd93f9aabe3b8dcac53de1c88279dbd8e529c3
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Feb 22 13:58:37 2016 -0600

    PCI: Rename VPD symbols to remove unnecessary "pci22"
    
    There's only one kind of VPD, so we don't need to qualify it as "the
    version described by PCI spec rev 2.2."
    
    Rename the following symbols to remove unnecessary "pci22":
    
      PCI_VPD_PCI22_SIZE    -> PCI_VPD_MAX_SIZE
      pci_vpd_pci22_size()  -> pci_vpd_size()
      pci_vpd_pci22_wait()  -> pci_vpd_wait()
      pci_vpd_pci22_read()  -> pci_vpd_read()
      pci_vpd_pci22_write() -> pci_vpd_write()
      pci_vpd_pci22_ops     -> pci_vpd_ops
      pci_vpd_pci22_init()  -> pci_vpd_init()
    
    Tested-by: Shane Seymour <shane.seymour@hpe.com>
    Tested-by: Babu Moger <babu.moger@oracle.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Hannes Reinecke <hare@suse.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 6d7ab9bb0d5a..39b017447b70 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1608,7 +1608,7 @@ static void pci_init_capabilities(struct pci_dev *dev)
 	pci_pm_init(dev);
 
 	/* Vital Product Data */
-	pci_vpd_pci22_init(dev);
+	pci_vpd_init(dev);
 
 	/* Alternative Routing-ID Forwarding */
 	pci_configure_ari(dev);

commit b84106b4e2290c081cdab521fa832596cdfea246
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Feb 25 14:35:57 2016 -0600

    PCI: Disable IO/MEM decoding for devices with non-compliant BARs
    
    The PCI config header (first 64 bytes of each device's config space) is
    defined by the PCI spec so generic software can identify the device and
    manage its usage of I/O, memory, and IRQ resources.
    
    Some non-spec-compliant devices put registers other than BARs where the
    BARs should be.  When the PCI core sizes these "BARs", the reads and writes
    it does may have unwanted side effects, and the "BAR" may appear to
    describe non-sensical address space.
    
    Add a flag bit to mark non-compliant devices so we don't touch their BARs.
    Turn off IO/MEM decoding to prevent the devices from consuming address
    space, since we can't read the BARs to find out what that address space
    would be.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Tested-by: Andi Kleen <ak@linux.intel.com>
    CC: stable@vger.kernel.org

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 6d7ab9bb0d5a..6b0056e9c33e 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -179,6 +179,9 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 	u16 orig_cmd;
 	struct pci_bus_region region, inverted_region;
 
+	if (dev->non_compliant_bars)
+		return 0;
+
 	mask = type ? PCI_ROM_ADDRESS_MASK : ~0;
 
 	/* No printks while decoding is disabled! */
@@ -1171,6 +1174,7 @@ static void pci_msi_setup_pci_dev(struct pci_dev *dev)
 int pci_setup_device(struct pci_dev *dev)
 {
 	u32 class;
+	u16 cmd;
 	u8 hdr_type;
 	int pos = 0;
 	struct pci_bus_region region;
@@ -1214,6 +1218,16 @@ int pci_setup_device(struct pci_dev *dev)
 	/* device class may be changed after fixup */
 	class = dev->class >> 8;
 
+	if (dev->non_compliant_bars) {
+		pci_read_config_word(dev, PCI_COMMAND, &cmd);
+		if (cmd & (PCI_COMMAND_IO | PCI_COMMAND_MEMORY)) {
+			dev_info(&dev->dev, "device has non-compliant BARs; disabling IO/MEM decoding\n");
+			cmd &= ~PCI_COMMAND_IO;
+			cmd &= ~PCI_COMMAND_MEMORY;
+			pci_write_config_word(dev, PCI_COMMAND, cmd);
+		}
+	}
+
 	switch (dev->hdr_type) {		    /* header type */
 	case PCI_HEADER_TYPE_NORMAL:		    /* standard header */
 		if (class == PCI_CLASS_BRIDGE_PCI)

commit 788858ebc49a07fe5f812778f245a51b0d800d82
Author: Jake Oshins <jakeo@microsoft.com>
Date:   Tue Feb 16 21:56:22 2016 +0000

    PCI: Look up IRQ domain by fwnode_handle
    
    If pci_host_bridge_msi_domain() can't find an IRQ domain through the OF
    tree, try to look it up directly through the fwnode_handle.
    
    [bhelgaas: changelog]
    Signed-off-by: Jake Oshins <jakeo@microsoft.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 6d7ab9bb0d5a..1e34d211389a 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -15,6 +15,7 @@
 #include <linux/pci-aspm.h>
 #include <linux/aer.h>
 #include <linux/acpi.h>
+#include <linux/irqdomain.h>
 #include <asm-generic/pci-bridge.h>
 #include "pci.h"
 
@@ -675,6 +676,20 @@ static struct irq_domain *pci_host_bridge_msi_domain(struct pci_bus *bus)
 	if (!d)
 		d = pci_host_bridge_acpi_msi_domain(bus);
 
+#ifdef CONFIG_PCI_MSI_IRQ_DOMAIN
+	/*
+	 * If no IRQ domain was found via the OF tree, try looking it up
+	 * directly through the fwnode_handle.
+	 */
+	if (!d) {
+		struct fwnode_handle *fwnode = pci_root_bus_fwnode(bus);
+
+		if (fwnode)
+			d = irq_find_matching_fwnode(fwnode,
+						     DOMAIN_BUS_PCI_MSI);
+	}
+#endif
+
 	return d;
 }
 

commit 5bd28338d681dcbde2c4bee4ebea0c4e0dfcd9e4
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Feb 5 14:57:54 2016 -0600

    PCI: Remove includes of empty asm-generic/pci-bridge.h
    
    include/asm-generic/pci-bridge.h is now empty, so remove every #include of
    it.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Will Deacon <will.deacon@arm.com> (arm64)

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index ead1ac1dc1e3..5eb378fbe849 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -15,7 +15,6 @@
 #include <linux/pci-aspm.h>
 #include <linux/aer.h>
 #include <linux/acpi.h>
-#include <asm-generic/pci-bridge.h>
 #include "pci.h"
 
 #define CARDBUS_LATENCY_TIMER	176	/* secondary latency timer */

commit 5bbe029ff7bc8ff82ef31d3480d68c95642a3c7a
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Feb 5 14:57:47 2016 -0600

    PCI: Move pci_set_flags() from asm-generic/pci-bridge.h to linux/pci.h
    
    The PCI flag management constants and functions were previously declared in
    include/asm-generic/pci-bridge.h.  But they are not specific to bridges,
    and arches did not include pci-bridge.h consistently.
    
    Move the following interfaces and related constants to include/linux/pci.h
    and remove pci-bridge.h:
    
      pci_set_flags()
      pci_add_flags()
      pci_clear_flags()
      pci_has_flag()
    
    This fixes these warnings when building for some arches:
    
      drivers/pci/host/pcie-designware.c:562:20: error: 'PCI_PROBE_ONLY' undeclared (first use in this function)
      drivers/pci/host/pcie-designware.c:562:7: error: implicit declaration of function 'pci_has_flag' [-Werror=implicit-function-declaration]
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 6d7ab9bb0d5a..ead1ac1dc1e3 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1803,6 +1803,13 @@ static int only_one_child(struct pci_bus *bus)
 		return 0;
 	if (pci_pcie_type(parent) == PCI_EXP_TYPE_ROOT_PORT)
 		return 1;
+
+	/*
+	 * PCIe downstream ports are bridges that normally lead to only a
+	 * device 0, but if PCI_SCAN_ALL_PCIE_DEVS is set, scan all
+	 * possible devices, not just device 0.  See PCIe spec r3.0,
+	 * sec 7.3.1.
+	 */
 	if (parent->has_secondary_link &&
 	    !pci_has_flag(PCI_SCAN_ALL_PCIE_DEVS))
 		return 1;

commit d43421565bf0510d35e6a39ebf96586ad486f3aa
Merge: 859e76254490 9662e32c810a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jan 21 11:52:16 2016 -0800

    Merge tag 'pci-v4.5-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI updates from Bjorn Helgaas:
     "PCI changes for the v4.5 merge window:
    
      Enumeration:
       - Simplify config space size computation (Bjorn Helgaas)
       - Avoid iterating through ROM outside the resource window (Edward O'Callaghan)
       - Support PCIe devices with short cfg_size (Jason S. McMullan)
       - Add Netronome vendor and device IDs (Jason S. McMullan)
       - Limit config space size for Netronome NFP6000 family (Jason S. McMullan)
       - Add Netronome NFP4000 PF device ID (Simon Horman)
       - Limit config space size for Netronome NFP4000 (Simon Horman)
       - Print warnings for all invalid expansion ROM headers (Vladis Dronov)
    
      Resource management:
       - Fix minimum allocation address overwrite (Christoph Biedl)
    
      PCI device hotplug:
       - acpiphp_ibm: Fix null dereferences on null ibm_slot (Colin Ian King)
       - pciehp: Always protect pciehp_disable_slot() with hotplug mutex (Guenter Roeck)
       - shpchp: Constify hpc_ops structure (Julia Lawall)
       - ibmphp: Remove unneeded NULL test (Julia Lawall)
    
      Power management:
       - Make ASPM sysfs link_state_store() consistent with link_state_show() (Andy Lutomirski)
    
      Virtualization
       - Add function 1 DMA alias quirk for Lite-On/Plextor M6e/Marvell 88SS9183 (Tim Sander)
    
      MSI:
       - Remove empty pci_msi_init_pci_dev() (Bjorn Helgaas)
       - Mark PCIe/PCI (MSI) IRQ cascade handlers as IRQF_NO_THREAD (Grygorii Strashko)
       - Initialize MSI capability for all architectures (Guilherme G. Piccoli)
       - Relax msi_domain_alloc() to support parentless MSI irqdomains (Liu Jiang)
    
      ARM Versatile host bridge driver:
       - Remove unused pci_sys_data structures (Lorenzo Pieralisi)
    
      Broadcom iProc host bridge driver:
       - Hide CONFIG_PCIE_IPROC (Arnd Bergmann)
       - Do not use 0x in front of %pap (Dmitry V. Krivenok)
       - Update iProc PCIe device tree binding (Ray Jui)
       - Add PAXC interface support (Ray Jui)
       - Add iProc PCIe MSI device tree binding (Ray Jui)
       - Add iProc PCIe MSI support (Ray Jui)
    
      Freescale i.MX6 host bridge driver:
       - Use gpio_set_value_cansleep() (Fabio Estevam)
       - Add support for active-low reset GPIO (Petr Štetiar)
    
      HiSilicon host bridge driver:
       - Add support for HiSilicon Hip06 PCIe host controllers (Gabriele Paoloni)
    
      Intel VMD host bridge driver:
       - Export irq_domain_set_info() for module use (Keith Busch)
       - x86/PCI: Allow DMA ops specific to a PCI domain (Keith Busch)
       - Use 32 bit PCI domain numbers (Keith Busch)
       - Add driver for Intel Volume Management Device (VMD) (Keith Busch)
    
      Qualcomm host bridge driver:
       - Document PCIe devicetree bindings (Stanimir Varbanov)
       - Add Qualcomm PCIe controller driver (Stanimir Varbanov)
       - dts: apq8064: add PCIe devicetree node (Stanimir Varbanov)
       - dts: ifc6410: enable PCIe DT node for this board (Stanimir Varbanov)
    
      Renesas R-Car host bridge driver:
       - Add support for R-Car H3 to pcie-rcar (Harunobu Kurokawa)
       - Allow DT to override default window settings (Phil Edworthy)
       - Convert to DT resource parsing API (Phil Edworthy)
       - Revert "PCI: rcar: Build pcie-rcar.c only on ARM" (Phil Edworthy)
       - Remove unused pci_sys_data struct from pcie-rcar (Phil Edworthy)
       - Add runtime PM support to pcie-rcar (Phil Edworthy)
       - Add Gen2 PHY setup to pcie-rcar (Phil Edworthy)
       - Add gen2 fallback compatibility string for pci-rcar-gen2 (Simon Horman)
       - Add gen2 fallback compatibility string for pcie-rcar (Simon Horman)
    
      Synopsys DesignWare host bridge driver:
       - Simplify control flow (Bjorn Helgaas)
       - Make config accessor override checking symmetric (Bjorn Helgaas)
       - Ensure ATU is enabled before IO/conf space accesses (Stanimir Varbanov)
    
      Miscellaneous:
       - Add of_pci_get_host_bridge_resources() stub (Arnd Bergmann)
       - Check for PCI_HEADER_TYPE_BRIDGE equality, not bitmask (Bjorn Helgaas)
       - Fix all whitespace issues (Bogicevic Sasa)
       - x86/PCI: Simplify pci_bios_{read,write} (Geliang Tang)
       - Use to_pci_dev() instead of open-coding it (Geliang Tang)
       - Use kobj_to_dev() instead of open-coding it (Geliang Tang)
       - Use list_for_each_entry() to simplify code (Geliang Tang)
       - Fix typos in <linux/msi.h> (Thomas Petazzoni)
       - x86/PCI: Clarify AMD Fam10h config access restrictions comment (Tomasz Nowicki)"
    
    * tag 'pci-v4.5-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (58 commits)
      PCI: Add function 1 DMA alias quirk for Lite-On/Plextor M6e/Marvell 88SS9183
      PCI: Limit config space size for Netronome NFP4000
      PCI: Add Netronome NFP4000 PF device ID
      x86/PCI: Add driver for Intel Volume Management Device (VMD)
      PCI/AER: Use 32 bit PCI domain numbers
      x86/PCI: Allow DMA ops specific to a PCI domain
      irqdomain: Export irq_domain_set_info() for module use
      PCI: host: Add of_pci_get_host_bridge_resources() stub
      genirq/MSI: Relax msi_domain_alloc() to support parentless MSI irqdomains
      PCI: rcar: Add Gen2 PHY setup to pcie-rcar
      PCI: rcar: Add runtime PM support to pcie-rcar
      PCI: designware: Make config accessor override checking symmetric
      PCI: ibmphp: Remove unneeded NULL test
      ARM: dts: ifc6410: enable PCIe DT node for this board
      ARM: dts: apq8064: add PCIe devicetree node
      PCI: hotplug: Use list_for_each_entry() to simplify code
      PCI: rcar: Remove unused pci_sys_data struct from pcie-rcar
      PCI: hisi: Add support for HiSilicon Hip06 PCIe host controllers
      PCI: Avoid iterating through memory outside the resource window
      PCI: acpiphp_ibm: Fix null dereferences on null ibm_slot
      ...

commit 471036b2b895789c2305428fd879006468e4a758
Author: Suravee Suthikulpanit <Suravee.Suthikulpanit@amd.com>
Date:   Thu Dec 10 08:55:27 2015 -0800

    acpi: pci: Setup MSI domain for ACPI based pci devices
    
    This patch introduces pci_msi_register_fwnode_provider() for irqchip
    to register a callback, to provide a way to determine appropriate MSI
    domain for a pci device.
    
    It also introduces pci_host_bridge_acpi_msi_domain(), which returns
    the MSI domain of the specified PCI host bridge with DOMAIN_BUS_PCI_MSI
    bus token. Then, it is assigned to pci device.
    
    Reviewed-by: Marc Zyngier <marc.zyngier@arm.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rjw@rjwysocki.net>
    Signed-off-by: Suravee Suthikulpanit <Suravee.Suthikulpanit@amd.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index edb1984201e9..553a029e37f1 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -672,6 +672,8 @@ static struct irq_domain *pci_host_bridge_msi_domain(struct pci_bus *bus)
 	 * should be called from here.
 	 */
 	d = pci_host_bridge_of_msi_domain(bus);
+	if (!d)
+		d = pci_host_bridge_acpi_msi_domain(bus);
 
 	return d;
 }

commit 800e07b609bf31c34c1fa08745812fc721101acc
Merge: 1ec218373b8e 57d86a0485a3 64609eaab242 96ae6469ba16 128fc68ca1c3
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Dec 10 19:40:14 2015 -0600

    Merge branches 'pci/aspm', 'pci/hotplug', 'pci/misc' and 'pci/msi' into next
    
    * pci/aspm:
      PCI/ASPM: Make sysfs link_state_store() consistent with link_state_show()
    
    * pci/hotplug:
      PCI: pciehp: Always protect pciehp_disable_slot() with hotplug mutex
    
    * pci/misc:
      x86/PCI: Simplify pci_bios_{read,write}
      PCI: Simplify config space size computation
      PCI: Limit config space size for Netronome NFP6000 family
      PCI: Add Netronome vendor and device IDs
      PCI: Support PCIe devices with short cfg_size
      x86/PCI: Clarify AMD Fam10h config access restrictions comment
      PCI: Print warnings for all invalid expansion ROM headers
      PCI: Check for PCI_HEADER_TYPE_BRIDGE equality, not bitmask
    
    * pci/msi:
      PCI/MSI: Remove empty pci_msi_init_pci_dev()
      PCI/MSI: Initialize MSI capability for all architectures

commit 8e5a395a040a7c72ec283f844eca679b924f5f01
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Dec 7 18:21:10 2015 -0600

    PCI: Simplify config space size computation
    
    Restructure the logic so we return the config space size as soon as we know
    it.  This reduces indentation, removes negations, and removes gotos.
    
    No functional change.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index edb1984201e9..0d86c82b8880 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1107,14 +1107,11 @@ static int pci_cfg_space_size_ext(struct pci_dev *dev)
 	int pos = PCI_CFG_SPACE_SIZE;
 
 	if (pci_read_config_dword(dev, pos, &status) != PCIBIOS_SUCCESSFUL)
-		goto fail;
+		return PCI_CFG_SPACE_SIZE;
 	if (status == 0xffffffff || pci_ext_cfg_is_aliased(dev))
-		goto fail;
+		return PCI_CFG_SPACE_SIZE;
 
 	return PCI_CFG_SPACE_EXP_SIZE;
-
- fail:
-	return PCI_CFG_SPACE_SIZE;
 }
 
 int pci_cfg_space_size(struct pci_dev *dev)
@@ -1127,19 +1124,17 @@ int pci_cfg_space_size(struct pci_dev *dev)
 	if (class == PCI_CLASS_BRIDGE_HOST)
 		return pci_cfg_space_size_ext(dev);
 
-	if (!pci_is_pcie(dev)) {
-		pos = pci_find_capability(dev, PCI_CAP_ID_PCIX);
-		if (!pos)
-			goto fail;
+	if (pci_is_pcie(dev))
+		return pci_cfg_space_size_ext(dev);
 
-		pci_read_config_dword(dev, pos + PCI_X_STATUS, &status);
-		if (!(status & (PCI_X_STATUS_266MHZ | PCI_X_STATUS_533MHZ)))
-			goto fail;
-	}
+	pos = pci_find_capability(dev, PCI_CAP_ID_PCIX);
+	if (!pos)
+		return PCI_CFG_SPACE_SIZE;
 
-	return pci_cfg_space_size_ext(dev);
+	pci_read_config_dword(dev, pos + PCI_X_STATUS, &status);
+	if (status & (PCI_X_STATUS_266MHZ | PCI_X_STATUS_533MHZ))
+		return pci_cfg_space_size_ext(dev);
 
- fail:
 	return PCI_CFG_SPACE_SIZE;
 }
 

commit 128fc68ca1c3c73ed35ef9c7c50b8972de40322f
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Nov 30 19:35:53 2015 -0600

    PCI/MSI: Remove empty pci_msi_init_pci_dev()
    
    4a7cc8316705 ("genirq/MSI: Move msi_list from struct pci_dev to struct
    device") removed the contents of pci_msi_init_pci_dev().  All
    implementation of it are now empty, so remove it completely.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index cd94737af8fd..88f0fedbe891 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1601,9 +1601,6 @@ static void pci_init_capabilities(struct pci_dev *dev)
 	/* Enhanced Allocation */
 	pci_ea_init(dev);
 
-	/* MSI/MSI-X list */
-	pci_msi_init_pci_dev(dev);
-
 	/* Setup MSI caps & disable MSI/MSI-X interrupts */
 	pci_msi_setup_pci_dev(dev);
 

commit e80e7edc55ba711f3fe23975061b3f1c336ceb95
Author: Guilherme G. Piccoli <gpiccoli@linux.vnet.ibm.com>
Date:   Wed Oct 21 12:17:35 2015 -0200

    PCI/MSI: Initialize MSI capability for all architectures
    
    1851617cd2da ("PCI/MSI: Disable MSI at enumeration even if kernel doesn't
    support MSI") moved dev->msi_cap and dev->msix_cap initialization from the
    pci_init_capabilities() path (used on all architectures) to the
    pci_setup_device() path (not used on Open Firmware architectures).
    
    This broke MSI or MSI-X on Open Firmware machines.  4d9aac397a5d
    ("powerpc/PCI: Disable MSI/MSI-X interrupts at PCI probe time in OF case")
    fixed it for PowerPC but not for SPARC.
    
    Set up MSI and MSI-X (initialize msi_cap and msix_cap and disable MSI and
    MSI-X) in pci_init_capabilities() so all architectures do it the same way.
    
    This reverts 4d9aac397a5d since this patch fixes the problem generically
    for both PowerPC and SPARC.
    
    [bhelgaas: changelog, make pci_msi_setup_pci_dev() static]
    Fixes: 1851617cd2da ("PCI/MSI: Disable MSI at enumeration even if kernel doesn't support MSI")
    Signed-off-by: Guilherme G. Piccoli <gpiccoli@linux.vnet.ibm.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index edb1984201e9..cd94737af8fd 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1145,7 +1145,7 @@ int pci_cfg_space_size(struct pci_dev *dev)
 
 #define LEGACY_IO_RESOURCE	(IORESOURCE_IO | IORESOURCE_PCI_FIXED)
 
-void pci_msi_setup_pci_dev(struct pci_dev *dev)
+static void pci_msi_setup_pci_dev(struct pci_dev *dev)
 {
 	/*
 	 * Disable the MSI hardware to avoid screaming interrupts
@@ -1212,8 +1212,6 @@ int pci_setup_device(struct pci_dev *dev)
 	/* "Unknown power state" */
 	dev->current_state = PCI_UNKNOWN;
 
-	pci_msi_setup_pci_dev(dev);
-
 	/* Early fixups, before probing the BARs */
 	pci_fixup_device(pci_fixup_early, dev);
 	/* device class may be changed after fixup */
@@ -1606,6 +1604,9 @@ static void pci_init_capabilities(struct pci_dev *dev)
 	/* MSI/MSI-X list */
 	pci_msi_init_pci_dev(dev);
 
+	/* Setup MSI caps & disable MSI/MSI-X interrupts */
+	pci_msi_setup_pci_dev(dev);
+
 	/* Buffers for saving PCIe and PCI-X capabilities */
 	pci_allocate_cap_save_buffers(dev);
 

commit a3767e3c9da514e63e898772b72b932f9eb3b062
Merge: 0aba0ab8915b a76032e0abef 4981c2b7abfe 768acd64d68b
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Nov 20 01:22:52 2015 +0100

    Merge branches 'acpi-smbus', 'acpi-ec' and 'acpi-pci'
    
    * acpi-smbus:
      Revert "ACPI / SBS: Add 5 us delay to fix SBS hangs on MacBook"
      ACPI / SMBus: Fix boot stalls / high CPU caused by reentrant code
    
    * acpi-ec:
      ACPI-EC: Drop unnecessary check made before calling acpi_ec_delete_query()
    
    * acpi-pci:
      PCI: Fix OF logic in pci_dma_configure()

commit 768acd64d68b232e0d2b9623d9846457355f0c27
Author: Suravee Suthikulpanit <suravee.suthikulpanit@amd.com>
Date:   Wed Nov 18 16:49:52 2015 -0800

    PCI: Fix OF logic in pci_dma_configure()
    
    This patch fixes a bug introduced by previous commit,
    which incorrectly checkes the of_node of the end-point device.
    Instead, it should check the of_node of the host bridge.
    
    Fixes: 50230713b639 ("PCI: OF: Move of_pci_dma_configure() to pci_dma_configure()")
    Reported-by: Robin Murphy <robin.murphy@arm.com>
    Signed-off-by: Suravee Suthikulpanit <suravee.suthikulpanit@amd.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 064078e11017..dc8fbe5c09d3 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1646,8 +1646,8 @@ static void pci_dma_configure(struct pci_dev *dev)
 {
 	struct device *bridge = pci_get_host_bridge_device(dev);
 
-	if (IS_ENABLED(CONFIG_OF) && dev->dev.of_node) {
-		if (bridge->parent)
+	if (IS_ENABLED(CONFIG_OF) &&
+		bridge->parent && bridge->parent->of_node) {
 			of_dma_configure(&dev->dev, bridge->parent->of_node);
 	} else if (has_acpi_companion(bridge)) {
 		struct acpi_device *adev = to_acpi_device_node(bridge->fwnode);

commit be23c9d20b341a58ad7107f9e9aa5735cea3da13
Merge: 5d50ac70fe98 f57ab32a8436
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Nov 12 11:50:33 2015 -0800

    Merge tag 'pm+acpi-4.4-rc1-2' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull more power management and ACPI updates from Rafael Wysocki:
     "The only new feature in this batch is support for the ACPI _CCA device
      configuration object, which it a pre-requisite for future ACPI PCI
      support on ARM64, but should not affect the other architectures.
    
      The rest is fixes and cleanups, mostly in cpufreq (including
      intel_pstate), the Operating Performace Points (OPP) framework and
      tools (cpupower and turbostat).
    
      Specifics:
    
       - Support for the ACPI _CCA configuration object intended to tell the
         OS whether or not a bus master device supports hardware managed
         cache coherency and a new set of functions to allow drivers to
         check the cache coherency support for devices in a platform
         firmware interface agnostic way (Suravee Suthikulpanit, Jeremy
         Linton).
    
       - ACPI backlight quirks for ESPRIMO Mobile M9410 and Dell XPS L421X
         (Aaron Lu, Hans de Goede).
    
       - Fixes for the arm_big_little and s5pv210-cpufreq cpufreq drivers
         (Jon Medhurst, Nicolas Pitre).
    
       - kfree()-related fixup for the recently introduced CPPC cpufreq
         frontend (Markus Elfring).
    
       - intel_pstate fix reducing kernel log noise on systems where
         P-states are managed by hardware (Prarit Bhargava).
    
       - intel_pstate maintainers information update (Srinivas Pandruvada).
    
       - cpufreq core optimization related to the handling of delayed work
         items used by governors (Viresh Kumar).
    
       - Locking fixes and cleanups of the Operating Performance Points
         (OPP) framework (Viresh Kumar).
    
       - Generic power domains framework cleanups (Lina Iyer).
    
       - cpupower tool updates (Jacob Tanenbaum, Sriram Raghunathan, Thomas
         Renninger).
    
       - turbostat tool updates (Len Brown)"
    
    * tag 'pm+acpi-4.4-rc1-2' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (32 commits)
      PCI: ACPI: Add support for PCI device DMA coherency
      PCI: OF: Move of_pci_dma_configure() to pci_dma_configure()
      of/pci: Fix pci_get_host_bridge_device leak
      device property: ACPI: Remove unused DMA APIs
      device property: ACPI: Make use of the new DMA Attribute APIs
      device property: Adding DMA Attribute APIs for Generic Devices
      ACPI: Adding DMA Attribute APIs for ACPI Device
      device property: Introducing enum dev_dma_attr
      ACPI: Honor ACPI _CCA attribute setting
      cpufreq: CPPC: Delete an unnecessary check before the function call kfree()
      PM / OPP: Add opp_rcu_lockdep_assert() to _find_device_opp()
      PM / OPP: Hold dev_opp_list_lock for writers
      PM / OPP: Protect updates to list_dev with mutex
      PM / OPP: Propagate error properly from dev_pm_opp_set_sharing_cpus()
      cpufreq: s5pv210-cpufreq: fix wrong do_div() usage
      MAINTAINERS: update for intel P-state driver
      Creating a common structure initialization pattern for struct option
      cpupower: Enable disabled Cstates if they are below max latency
      cpupower: Remove debug message when using cpupower idle-set -D switch
      cpupower: cpupower monitor reports uninitialized values for offline cpus
      ...

commit f2115faaf0df42623638dfbfc5bdaab6ef7375ab
Merge: 0d51ce9ca111 29dbe1f0af88
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Nov 7 01:30:10 2015 +0100

    Merge branch 'acpi-pci'
    
    * acpi-pci:
      PCI: ACPI: Add support for PCI device DMA coherency
      PCI: OF: Move of_pci_dma_configure() to pci_dma_configure()
      of/pci: Fix pci_get_host_bridge_device leak
      device property: ACPI: Remove unused DMA APIs
      device property: ACPI: Make use of the new DMA Attribute APIs
      device property: Adding DMA Attribute APIs for Generic Devices
      ACPI: Adding DMA Attribute APIs for ACPI Device
      device property: Introducing enum dev_dma_attr
      ACPI: Honor ACPI _CCA attribute setting
    
    Conflicts:
            drivers/crypto/ccp/ccp-platform.c

commit 29dbe1f0af88b4162d2b57e790db7a51ab061f35
Author: Suthikulpanit, Suravee <Suravee.Suthikulpanit@amd.com>
Date:   Wed Oct 28 15:50:54 2015 -0700

    PCI: ACPI: Add support for PCI device DMA coherency
    
    This patch adds support for setting up PCI device DMA coherency from
    ACPI _CCA object that should normally be specified in the DSDT node
    of its PCI host bridge.
    
    Signed-off-by: Suravee Suthikulpanit <Suravee.Suthikulpanit@amd.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Hanjun Guo <hanjun.guo@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index d35f83d80b15..064078e11017 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -13,6 +13,7 @@
 #include <linux/module.h>
 #include <linux/cpumask.h>
 #include <linux/pci-aspm.h>
+#include <linux/acpi.h>
 #include <asm-generic/pci-bridge.h>
 #include "pci.h"
 
@@ -1639,7 +1640,7 @@ static void pci_set_msi_domain(struct pci_dev *dev)
  * @dev: ptr to pci_dev struct of the PCI device
  *
  * Function to update PCI devices's DMA configuration using the same
- * info from the OF node of host bridge's parent (if any).
+ * info from the OF node or ACPI node of host bridge's parent (if any).
  */
 static void pci_dma_configure(struct pci_dev *dev)
 {
@@ -1648,6 +1649,15 @@ static void pci_dma_configure(struct pci_dev *dev)
 	if (IS_ENABLED(CONFIG_OF) && dev->dev.of_node) {
 		if (bridge->parent)
 			of_dma_configure(&dev->dev, bridge->parent->of_node);
+	} else if (has_acpi_companion(bridge)) {
+		struct acpi_device *adev = to_acpi_device_node(bridge->fwnode);
+		enum dev_dma_attr attr = acpi_get_dma_attr(adev);
+
+		if (attr == DEV_DMA_NOT_SUPPORTED)
+			dev_warn(&dev->dev, "DMA not supported.\n");
+		else
+			arch_setup_dma_ops(&dev->dev, 0, 0, NULL,
+					   attr == DEV_DMA_COHERENT);
 	}
 
 	pci_put_host_bridge_device(bridge);

commit 50230713b63941f4b6b562eea0834f751aa0801e
Author: Suthikulpanit, Suravee <Suravee.Suthikulpanit@amd.com>
Date:   Wed Oct 28 15:50:53 2015 -0700

    PCI: OF: Move of_pci_dma_configure() to pci_dma_configure()
    
    This patch move of_pci_dma_configure() to a more generic
    pci_dma_configure(), which can be extended by non-OF code (e.g. ACPI).
    
    This has no functional change.
    
    Signed-off-by: Suravee Suthikulpanit <Suravee.Suthikulpanit@amd.com>
    Acked-by: Rob Herring <robh+dt@kernel.org>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Hanjun Guo <hanjun.guo@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 8361d27e5eca..d35f83d80b15 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -6,6 +6,7 @@
 #include <linux/delay.h>
 #include <linux/init.h>
 #include <linux/pci.h>
+#include <linux/of_device.h>
 #include <linux/of_pci.h>
 #include <linux/pci_hotplug.h>
 #include <linux/slab.h>
@@ -1633,6 +1634,25 @@ static void pci_set_msi_domain(struct pci_dev *dev)
 				   dev_get_msi_domain(&dev->bus->dev));
 }
 
+/**
+ * pci_dma_configure - Setup DMA configuration
+ * @dev: ptr to pci_dev struct of the PCI device
+ *
+ * Function to update PCI devices's DMA configuration using the same
+ * info from the OF node of host bridge's parent (if any).
+ */
+static void pci_dma_configure(struct pci_dev *dev)
+{
+	struct device *bridge = pci_get_host_bridge_device(dev);
+
+	if (IS_ENABLED(CONFIG_OF) && dev->dev.of_node) {
+		if (bridge->parent)
+			of_dma_configure(&dev->dev, bridge->parent->of_node);
+	}
+
+	pci_put_host_bridge_device(bridge);
+}
+
 void pci_device_add(struct pci_dev *dev, struct pci_bus *bus)
 {
 	int ret;
@@ -1646,7 +1666,7 @@ void pci_device_add(struct pci_dev *dev, struct pci_bus *bus)
 	dev->dev.dma_mask = &dev->dma_mask;
 	dev->dev.dma_parms = &dev->dma_parms;
 	dev->dev.coherent_dma_mask = 0xffffffffull;
-	of_pci_dma_configure(dev);
+	pci_dma_configure(dev);
 
 	pci_set_dma_max_seg_size(dev, 65536);
 	pci_set_dma_seg_boundary(dev, 0xffffffff);

commit 3c87b791880a2e0dad281c6494b94968d412bfa3
Merge: 0280d1a099da 7225107e1582
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Nov 6 11:29:53 2015 -0800

    Merge tag 'pci-v4.4-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI updates from Bjorn Helgaas:
     "Resource management:
       - Add support for Enhanced Allocation devices (Sean O. Stalley)
       - Add Enhanced Allocation register entries (Sean O. Stalley)
       - Handle IORESOURCE_PCI_FIXED when sizing resources (David Daney)
       - Handle IORESOURCE_PCI_FIXED when assigning resources (David Daney)
       - Handle Enhanced Allocation capability for SR-IOV devices (David Daney)
       - Clear IORESOURCE_UNSET when reverting to firmware-assigned address (Bjorn Helgaas)
       - Make Enhanced Allocation bitmasks more obvious (Bjorn Helgaas)
       - Expand Enhanced Allocation BAR output (Bjorn Helgaas)
       - Add of_pci_check_probe_only to parse "linux,pci-probe-only" (Marc Zyngier)
       - Fix lookup of linux,pci-probe-only property (Marc Zyngier)
       - Add sparc mem64 resource parsing for root bus (Yinghai Lu)
    
      PCI device hotplug:
       - pciehp: Queue power work requests in dedicated function (Guenter Roeck)
    
      Driver binding:
       - Add builtin_pci_driver() to avoid registration boilerplate (Paul Gortmaker)
    
      Virtualization:
       - Set SR-IOV NumVFs to zero after enumeration (Alexander Duyck)
       - Remove redundant validation of SR-IOV offset/stride registers (Alexander Duyck)
       - Remove VFs in reverse order if virtfn_add() fails (Alexander Duyck)
       - Reorder pcibios_sriov_disable() (Alexander Duyck)
       - Wait 1 second between disabling VFs and clearing NumVFs (Alexander Duyck)
       - Fix sriov_enable() error path for pcibios_enable_sriov() failures (Alexander Duyck)
       - Enable SR-IOV ARI Capable Hierarchy before reading TotalVFs (Ben Shelton)
       - Don't try to restore VF BARs (Wei Yang)
    
      MSI:
       - Don't alloc pcibios-irq when MSI is enabled (Joerg Roedel)
       - Add msi_controller setup_irqs() method for special multivector setup (Lucas Stach)
       - Export all remapped MSIs to sysfs attributes (Romain Bezut)
       - Disable MSI on SiS 761 (Ondrej Zary)
    
      AER:
       - Clear error status registers during enumeration and restore (Taku Izumi)
    
      Generic host bridge driver:
       - Fix lookup of linux,pci-probe-only property (Marc Zyngier)
       - Allow multiple hosts with different map_bus() methods (David Daney)
       - Pass starting bus number to pci_scan_root_bus() (David Daney)
       - Fix address window calculation for non-zero starting bus (David Daney)
    
      Altera host bridge driver:
       - Add msi.h to ARM Kbuild (Ley Foon Tan)
       - Add Altera PCIe host controller driver (Ley Foon Tan)
       - Add Altera PCIe MSI driver (Ley Foon Tan)
    
      APM X-Gene host bridge driver:
       - Remove msi_controller assignment (Duc Dang)
    
      Broadcom iProc host bridge driver:
       - Fix header comment "Corporation" misspelling (Florian Fainelli)
       - Fix code comment to match code (Ray Jui)
       - Remove unused struct iproc_pcie.irqs[] (Ray Jui)
       - Call pci_fixup_irqs() for ARM64 as well as ARM (Ray Jui)
       - Fix PCIe reset logic (Ray Jui)
       - Improve link detection logic (Ray Jui)
       - Update PCIe device tree bindings (Ray Jui)
       - Add outbound mapping support (Ray Jui)
    
      Freescale i.MX6 host bridge driver:
       - Return real error code from imx6_add_pcie_port() (Fabio Estevam)
       - Add PCIE_PHY_RX_ASIC_OUT_VALID definition (Fabio Estevam)
    
      Freescale Layerscape host bridge driver:
       - Remove ls_pcie_establish_link() (Minghuan Lian)
       - Ignore PCIe controllers in Endpoint mode (Minghuan Lian)
       - Factor out SCFG related function (Minghuan Lian)
       - Update ls_add_pcie_port() (Minghuan Lian)
       - Remove unused fields from struct ls_pcie (Minghuan Lian)
       - Add support for LS1043a and LS2080a (Minghuan Lian)
       - Add ls_pcie_msi_host_init() (Minghuan Lian)
    
      HiSilicon host bridge driver:
       - Add HiSilicon SoC Hip05 PCIe driver (Zhou Wang)
    
      Marvell MVEBU host bridge driver:
       - Return zero for reserved or unimplemented config space (Russell King)
       - Use exact config access size; don't read/modify/write (Russell King)
       - Use of_get_available_child_count() (Russell King)
       - Use for_each_available_child_of_node() to walk child nodes (Russell King)
       - Report full node name when reporting a DT error (Russell King)
       - Use port->name rather than "PCIe%d.%d" (Russell King)
       - Move port parsing and resource claiming to  separate function (Russell King)
       - Fix memory leaks and refcount leaks (Russell King)
       - Split port parsing and resource claiming from  port setup (Russell King)
       - Use gpio_set_value_cansleep() (Russell King)
       - Use devm_kcalloc() to allocate an array (Russell King)
       - Use gpio_desc to carry around gpio (Russell King)
       - Improve clock/reset handling (Russell King)
       - Add PCI Express root complex capability block (Russell King)
       - Remove code restricting accesses to slot 0 (Russell King)
    
      NVIDIA Tegra host bridge driver:
       - Wrap static pgprot_t initializer with __pgprot() (Ard Biesheuvel)
    
      Renesas R-Car host bridge driver:
       - Build pci-rcar-gen2.c only on ARM (Geert Uytterhoeven)
       - Build pcie-rcar.c only on ARM (Geert Uytterhoeven)
       - Make PCI aware of the I/O resources (Phil Edworthy)
       - Remove dependency on ARM-specific struct hw_pci (Phil Edworthy)
       - Set root bus nr to that provided in DT (Phil Edworthy)
       - Fix I/O offset for multiple host bridges (Phil Edworthy)
    
      ST Microelectronics SPEAr13xx host bridge driver:
       - Fix dw_pcie_cfg_read/write() usage (Gabriele Paoloni)
    
      Synopsys DesignWare host bridge driver:
       - Make "clocks" and "clock-names" optional DT properties (Bhupesh Sharma)
       - Use exact access size in dw_pcie_cfg_read() (Gabriele Paoloni)
       - Simplify dw_pcie_cfg_read/write() interfaces (Gabriele Paoloni)
       - Require config accesses to be naturally aligned (Gabriele Paoloni)
       - Make "num-lanes" an optional DT property (Gabriele Paoloni)
       - Move calculation of bus addresses to DRA7xx (Gabriele Paoloni)
       - Replace ARM pci_sys_data->align_resource with global function pointer (Gabriele Paoloni)
       - Factor out MSI msg setup (Lucas Stach)
       - Implement multivector MSI IRQ setup (Lucas Stach)
       - Make get_msi_addr() return phys_addr_t, not u32 (Lucas Stach)
       - Set up high part of MSI target address (Lucas Stach)
       - Fix PORT_LOGIC_LINK_WIDTH_MASK (Zhou Wang)
       - Revert "PCI: designware: Program ATU with untranslated address" (Zhou Wang)
       - Use of_pci_get_host_bridge_resources() to parse DT (Zhou Wang)
       - Make driver arch-agnostic (Zhou Wang)
    
      Miscellaneous:
       - Make x86 pci_subsys_init() static (Alexander Kuleshov)
       - Turn off Request Attributes to avoid Chelsio T5 Completion erratum (Hariprasad Shenai)"
    
    * tag 'pci-v4.4-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (94 commits)
      PCI: altera: Add Altera PCIe MSI driver
      PCI: hisi: Add HiSilicon SoC Hip05 PCIe driver
      PCI: layerscape: Add ls_pcie_msi_host_init()
      PCI: layerscape: Add support for LS1043a and LS2080a
      PCI: layerscape: Remove unused fields from struct ls_pcie
      PCI: layerscape: Update ls_add_pcie_port()
      PCI: layerscape: Factor out SCFG related function
      PCI: layerscape: Ignore PCIe controllers in Endpoint mode
      PCI: layerscape: Remove ls_pcie_establish_link()
      PCI: designware: Make "clocks" and "clock-names" optional DT properties
      PCI: designware: Make driver arch-agnostic
      ARM/PCI: Replace pci_sys_data->align_resource with global function pointer
      PCI: designware: Use of_pci_get_host_bridge_resources() to parse DT
      Revert "PCI: designware: Program ATU with untranslated address"
      PCI: designware: Move calculation of bus addresses to DRA7xx
      PCI: designware: Make "num-lanes" an optional DT property
      PCI: designware: Require config accesses to be naturally aligned
      PCI: designware: Simplify dw_pcie_cfg_read/write() interfaces
      PCI: designware: Use exact access size in dw_pcie_cfg_read()
      PCI: spear: Fix dw_pcie_cfg_read/write() usage
      ...

commit 1f9a30ec2a4acee9a4d664e7405c7eb26a7c4b5e
Merge: 6ff33f3902c3 b07461a8e45b bee67756eb4a c56d4450eb68 8affb487d4a4 af86fa4001ca c23b613507b8
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Nov 2 15:57:03 2015 -0600

    Merge branches 'pci/aer', 'pci/hotplug', 'pci/misc', 'pci/msi', 'pci/resource' and 'pci/virtualization' into next
    
    * pci/aer:
      PCI/AER: Clear error status registers during enumeration and restore
    
    * pci/hotplug:
      PCI: pciehp: Queue power work requests in dedicated function
    
    * pci/misc:
      PCI: Turn off Request Attributes to avoid Chelsio T5 Completion erratum
      x86/PCI: Make pci_subsys_init() static
      PCI: Add builtin_pci_driver() to avoid registration boilerplate
      PCI: Remove unnecessary "if" statement
    
    * pci/msi:
      x86/PCI: Don't alloc pcibios-irq when MSI is enabled
      PCI/MSI: Export all remapped MSIs to sysfs attributes
      PCI: Disable MSI on SiS 761
    
    * pci/resource:
      sparc/PCI: Add mem64 resource parsing for root bus
      PCI: Expand Enhanced Allocation BAR output
      PCI: Make Enhanced Allocation bitmasks more obvious
      PCI: Handle Enhanced Allocation capability for SR-IOV devices
      PCI: Add support for Enhanced Allocation devices
      PCI: Add Enhanced Allocation register entries
      PCI: Handle IORESOURCE_PCI_FIXED when assigning resources
      PCI: Handle IORESOURCE_PCI_FIXED when sizing resources
      PCI: Clear IORESOURCE_UNSET when reverting to firmware-assigned address
    
    * pci/virtualization:
      PCI: Fix sriov_enable() error path for pcibios_enable_sriov() failures
      PCI: Wait 1 second between disabling VFs and clearing NumVFs
      PCI: Reorder pcibios_sriov_disable()
      PCI: Remove VFs in reverse order if virtfn_add() fails
      PCI: Remove redundant validation of SR-IOV offset/stride registers
      PCI: Set SR-IOV NumVFs to zero after enumeration
      PCI: Enable SR-IOV ARI Capable Hierarchy before reading TotalVFs
      PCI: Don't try to restore VF BARs

commit 938174e59f83354251a75a2b90171e0ffdf6f1d7
Author: Sean O. Stalley <sean.stalley@intel.com>
Date:   Thu Oct 29 17:35:39 2015 -0500

    PCI: Add support for Enhanced Allocation devices
    
    Add support for devices using Enhanced Allocation entries instead of BARs.
    This allows the kernel to parse the EA Extended Capability structure in PCI
    config space and claim the BAR-equivalent resources.
    
    See https://pcisig.com/sites/default/files/specification_documents/ECN_Enhanced_Allocation_23_Oct_2014_Final.pdf
    
    [bhelgaas: add spec URL, s/pci_ea_set_flags/pci_ea_flags/, consolidate
    declarations, print unknown property in hex to match spec]
    Signed-off-by: Sean O. Stalley <sean.stalley@intel.com>
    [david.daney@cavium.com: Add more support/checking for Entry Properties,
    allow EA behind bridges, rewrite some error messages.]
    Signed-off-by: David Daney <david.daney@cavium.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 0b2be174d981..4293eec540a2 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1598,6 +1598,9 @@ static struct pci_dev *pci_scan_device(struct pci_bus *bus, int devfn)
 
 static void pci_init_capabilities(struct pci_dev *dev)
 {
+	/* Enhanced Allocation */
+	pci_ea_init(dev);
+
 	/* MSI/MSI-X list */
 	pci_msi_init_pci_dev(dev);
 

commit 54fa97eeb9e22b47d68b67ee00987afa7fbc2178
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Fri Oct 2 14:43:06 2015 +0100

    PCI/MSI: Allow the MSI domain to be device-specific
    
    So far, we've always considered that for a given PCI device, its
    MSI controller was either set by the architecture-specific
    pcibios hook, or simply inherited from the host bridge.
    
    This doesn't cover things like firmware-defined topologies like
    msi-map (DT) or IORT (ACPI), which can provide information about
    which MSI controller to use on a per-device basis.
    
    This patch adds the necessary hook into the MSI code to allow this
    feature, and provides the msi-map functionnality as a first
    implementation.
    
    Acked-by: Rob Herring <robh@kernel.org>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 7c333f8c2327..f14a970b61fa 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1639,6 +1639,14 @@ static struct irq_domain *pci_dev_msi_domain(struct pci_dev *dev)
 	if (d)
 		return d;
 
+	/*
+	 * Let's see if we have a firmware interface able to provide
+	 * the domain.
+	 */
+	d = pci_msi_get_device_domain(dev);
+	if (d)
+		return d;
+
 	return NULL;
 }
 

commit 098259eb16675a83e1d6ea31e06dc3ec152810a2
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Fri Oct 2 10:19:32 2015 +0100

    PCI: Add per-device MSI domain hook
    
    So far, we have considered that the MSI domain for a device was
    either set via the architecture-dependent pcibios implementation
    or inherited from the host bridge.
    
    As we're about to break that assumption, add pci_dev_msi_domain
    which is the equivalent of pci_host_bridge_msi_domain, but for
    a single device.
    
    Other than moving things around a bit, this patch on its own
    has no effect.
    
    Acked-by: Rob Herring <robh@kernel.org>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 8361d27e5eca..7c333f8c2327 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1622,15 +1622,40 @@ static void pci_init_capabilities(struct pci_dev *dev)
 	pci_enable_acs(dev);
 }
 
+/*
+ * This is the equivalent of pci_host_bridge_msi_domain that acts on
+ * devices. Firmware interfaces that can select the MSI domain on a
+ * per-device basis should be called from here.
+ */
+static struct irq_domain *pci_dev_msi_domain(struct pci_dev *dev)
+{
+	struct irq_domain *d;
+
+	/*
+	 * If a domain has been set through the pcibios_add_device
+	 * callback, then this is the one (platform code knows best).
+	 */
+	d = dev_get_msi_domain(&dev->dev);
+	if (d)
+		return d;
+
+	return NULL;
+}
+
 static void pci_set_msi_domain(struct pci_dev *dev)
 {
+	struct irq_domain *d;
+
 	/*
-	 * If no domain has been set through the pcibios_add_device
-	 * callback, inherit the default from the bus device.
+	 * If the platform or firmware interfaces cannot supply a
+	 * device-specific MSI domain, then inherit the default domain
+	 * from the host bridge itself.
 	 */
-	if (!dev_get_msi_domain(&dev->dev))
-		dev_set_msi_domain(&dev->dev,
-				   dev_get_msi_domain(&dev->bus->dev));
+	d = pci_dev_msi_domain(dev);
+	if (!d)
+		d = dev_get_msi_domain(&dev->bus->dev);
+
+	dev_set_msi_domain(&dev->dev, d);
 }
 
 void pci_device_add(struct pci_dev *dev, struct pci_bus *bus)

commit 38ea72bdb65df2f40ec77b2c9d1413e7f5e34465
Author: Alex Williamson <alex.williamson@redhat.com>
Date:   Fri Sep 18 15:08:54 2015 -0600

    PCI/MSI: Fix MSI IRQ domains for VFs on virtual buses
    
    SR-IOV creates a virtual bus where bus->self is NULL.  When we add VFs and
    scan for an MSI domain, pci_set_bus_msi_domain() dereferences bus->self,
    which causes a kernel NULL pointer dereference oops.
    
    Scan up to the parent bus until we find a real bridge where we can get the
    MSI domain.
    
    [bhelgaas: changelog]
    Fixes: 44aa0c657e3e ("PCI/MSI: Add hooks to populate the msi_domain field")
    Tested-by: Joerg Roedel <joro@8bytes.org>
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
    Signed-off-by: Bjorn Helgaas <helgaas@kernel.org>
    Acked-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index c8cc0e62a7b9..8361d27e5eca 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -676,15 +676,20 @@ static struct irq_domain *pci_host_bridge_msi_domain(struct pci_bus *bus)
 static void pci_set_bus_msi_domain(struct pci_bus *bus)
 {
 	struct irq_domain *d;
+	struct pci_bus *b;
 
 	/*
-	 * Either bus is the root, and we must obtain it from the
-	 * firmware, or we inherit it from the bridge device.
+	 * The bus can be a root bus, a subordinate bus, or a virtual bus
+	 * created by an SR-IOV device.  Walk up to the first bridge device
+	 * found or derive the domain from the host bridge.
 	 */
-	if (pci_is_root_bus(bus))
-		d = pci_host_bridge_msi_domain(bus);
-	else
-		d = dev_get_msi_domain(&bus->self->dev);
+	for (b = bus, d = NULL; !d && !pci_is_root_bus(b); b = b->parent) {
+		if (b->self)
+			d = dev_get_msi_domain(&b->self->dev);
+	}
+
+	if (!d)
+		d = pci_host_bridge_msi_domain(b);
 
 	dev_set_msi_domain(&bus->dev, d);
 }

commit b07461a8e45b7a62ef7fb46e4f6ada66f63406a8
Author: Taku Izumi <izumi.taku@jp.fujitsu.com>
Date:   Thu Sep 17 10:09:37 2015 -0500

    PCI/AER: Clear error status registers during enumeration and restore
    
    AER errors might be recorded when powering-on devices.  These errors can be
    ignored, so firmware usually clears them before the OS enumerates devices.
    However, firmware is not involved when devices are added via hotplug, so
    the OS may discover power-up errors that should be ignored.  The same may
    happen when powering up devices when resuming after suspend.
    
    Clear the AER error status registers during enumeration and resume.
    
    [bhelgaas: changelog, remove repetitive comments]
    Signed-off-by: Taku Izumi <izumi.taku@jp.fujitsu.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 0b2be174d981..8cd9710498e4 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -12,6 +12,7 @@
 #include <linux/module.h>
 #include <linux/cpumask.h>
 #include <linux/pci-aspm.h>
+#include <linux/aer.h>
 #include <asm-generic/pci-bridge.h>
 #include "pci.h"
 
@@ -1621,6 +1622,8 @@ static void pci_init_capabilities(struct pci_dev *dev)
 
 	/* Enable ACS P2P upstream forwarding */
 	pci_enable_acs(dev);
+
+	pci_cleanup_aer_error_status_regs(dev);
 }
 
 static void pci_set_msi_domain(struct pci_dev *dev)

commit 237865f195f6b10e4724ce49eeb3972641da882a
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Sep 15 13:18:04 2015 -0500

    PCI: Revert "PCI: Call pci_read_bridge_bases() from core instead of arch code"
    
    Revert dff22d2054b5 ("PCI: Call pci_read_bridge_bases() from core instead
    of arch code").
    
    Reading PCI bridge windows is not arch-specific in itself, but there is PCI
    core code that doesn't work correctly if we read them too early.  For
    example, Hannes found this case on an ARM Freescale i.mx6 board:
    
      pci_bus 0000:00: root bus resource [mem 0x01000000-0x01efffff]
      pci 0000:00:00.0: PCI bridge to [bus 01-ff]
      pci 0000:00:00.0: BAR 8: no space for [mem size 0x01000000] (mem window)
      pci 0000:01:00.0: BAR 2: failed to assign [mem size 0x00200000]
      pci 0000:01:00.0: BAR 1: failed to assign [mem size 0x00004000]
      pci 0000:01:00.0: BAR 0: failed to assign [mem size 0x00000100]
    
    The 00:00.0 mem window needs to be at least 3MB: the 01:00.0 device needs
    0x204100 of space, and mem windows are megabyte-aligned.
    
    Bus sizing can increase a bridge window size, but never *decrease* it (see
    d65245c3297a ("PCI: don't shrink bridge resources")).  Prior to
    dff22d2054b5, ARM didn't read bridge windows at all, so the "original size"
    was zero, and we assigned a 3MB window.
    
    After dff22d2054b5, we read the bridge windows before sizing the bus.  The
    firmware programmed a 16MB window (size 0x01000000) in 00:00.0, and since
    we never decrease the size, we kept 16MB even though we only needed 3MB.
    But 16MB doesn't fit in the host bridge aperture, so we failed to assign
    space for the window and the downstream devices.
    
    I think this is a defect in the PCI core: we shouldn't rely on the firmware
    to assign sensible windows.
    
    Ray reported a similar problem, also on ARM, with Broadcom iProc.
    
    Issues like this are too hard to fix right now, so revert dff22d2054b5.
    
    Reported-by: Hannes <oe5hpm@gmail.com>
    Reported-by: Ray Jui <rjui@broadcom.com>
    Link: http://lkml.kernel.org/r/CAAa04yFQEUJm7Jj1qMT57-LG7ZGtnhNDBe=PpSRa70Mj+XhW-A@mail.gmail.com
    Link: http://lkml.kernel.org/r/55F75BB8.4070405@broadcom.com
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>
    Acked-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 0b2be174d981..c8cc0e62a7b9 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -855,9 +855,6 @@ int pci_scan_bridge(struct pci_bus *bus, struct pci_dev *dev, int max, int pass)
 			child->bridge_ctl = bctl;
 		}
 
-		/* Read and initialize bridge resources */
-		pci_read_bridge_bases(child);
-
 		cmax = pci_scan_child_bus(child);
 		if (cmax > subordinate)
 			dev_warn(&dev->dev, "bridge has subordinate %02x but max busn %02x\n",
@@ -918,9 +915,6 @@ int pci_scan_bridge(struct pci_bus *bus, struct pci_dev *dev, int max, int pass)
 
 		if (!is_cardbus) {
 			child->bridge_ctl = bctl;
-
-			/* Read and initialize bridge resources */
-			pci_read_bridge_bases(child);
 			max = pci_scan_child_bus(child);
 		} else {
 			/*

commit 12f03ee606914317e7e6a0815e53a48205c31dae
Merge: d9241b22b58e 004f1afbe199
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Sep 8 14:35:59 2015 -0700

    Merge tag 'libnvdimm-for-4.3' of git://git.kernel.org/pub/scm/linux/kernel/git/nvdimm/nvdimm
    
    Pull libnvdimm updates from Dan Williams:
     "This update has successfully completed a 0day-kbuild run and has
      appeared in a linux-next release.  The changes outside of the typical
      drivers/nvdimm/ and drivers/acpi/nfit.[ch] paths are related to the
      removal of IORESOURCE_CACHEABLE, the introduction of memremap(), and
      the introduction of ZONE_DEVICE + devm_memremap_pages().
    
      Summary:
    
       - Introduce ZONE_DEVICE and devm_memremap_pages() as a generic
         mechanism for adding device-driver-discovered memory regions to the
         kernel's direct map.
    
         This facility is used by the pmem driver to enable pfn_to_page()
         operations on the page frames returned by DAX ('direct_access' in
         'struct block_device_operations').
    
         For now, the 'memmap' allocation for these "device" pages comes
         from "System RAM".  Support for allocating the memmap from device
         memory will arrive in a later kernel.
    
       - Introduce memremap() to replace usages of ioremap_cache() and
         ioremap_wt().  memremap() drops the __iomem annotation for these
         mappings to memory that do not have i/o side effects.  The
         replacement of ioremap_cache() with memremap() is limited to the
         pmem driver to ease merging the api change in v4.3.
    
         Completion of the conversion is targeted for v4.4.
    
       - Similar to the usage of memcpy_to_pmem() + wmb_pmem() in the pmem
         driver, update the VFS DAX implementation and PMEM api to provide
         persistence guarantees for kernel operations on a DAX mapping.
    
       - Convert the ACPI NFIT 'BLK' driver to map the block apertures as
         cacheable to improve performance.
    
       - Miscellaneous updates and fixes to libnvdimm including support for
         issuing "address range scrub" commands, clarifying the optimal
         'sector size' of pmem devices, a clarification of the usage of the
         ACPI '_STA' (status) property for DIMM devices, and other minor
         fixes"
    
    * tag 'libnvdimm-for-4.3' of git://git.kernel.org/pub/scm/linux/kernel/git/nvdimm/nvdimm: (34 commits)
      libnvdimm, pmem: direct map legacy pmem by default
      libnvdimm, pmem: 'struct page' for pmem
      libnvdimm, pfn: 'struct page' provider infrastructure
      x86, pmem: clarify that ARCH_HAS_PMEM_API implies PMEM mapped WB
      add devm_memremap_pages
      mm: ZONE_DEVICE for "device memory"
      mm: move __phys_to_pfn and __pfn_to_phys to asm/generic/memory_model.h
      dax: drop size parameter to ->direct_access()
      nd_blk: change aperture mapping from WC to WB
      nvdimm: change to use generic kvfree()
      pmem, dax: have direct_access use __pmem annotation
      dax: update I/O path to do proper PMEM flushing
      pmem: add copy_from_iter_pmem() and clear_pmem()
      pmem, x86: clean up conditional pmem includes
      pmem: remove layer when calling arch_has_wmb_pmem()
      pmem, x86: move x86 PMEM API to new pmem.h header
      libnvdimm, e820: make CONFIG_X86_PMEM_LEGACY a tristate option
      pmem: switch to devm_ allocations
      devres: add devm_memremap
      libnvdimm, btt: write and validate parent_uuid
      ...

commit 17e6b00ac422b49d44a0b8d98402a211f726282d
Merge: 5e359bf2219d e324c4dc4a59
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Sep 1 14:33:35 2015 -0700

    Merge branch 'irq-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull irq updates from Thomas Gleixner:
     "This updated pull request does not contain the last few GIC related
      patches which were reported to cause a regression.  There is a fix
      available, but I let it breed for a couple of days first.
    
      The irq departement provides:
    
       - new infrastructure to support non PCI based MSI interrupts
       - a couple of new irq chip drivers
       - the usual pile of fixlets and updates to irq chip drivers
       - preparatory changes for removal of the irq argument from interrupt
         flow handlers
       - preparatory changes to remove IRQF_VALID"
    
    * 'irq-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (129 commits)
      irqchip/imx-gpcv2: IMX GPCv2 driver for wakeup sources
      irqchip: Add bcm2836 interrupt controller for Raspberry Pi 2
      irqchip: Add documentation for the bcm2836 interrupt controller
      irqchip/bcm2835: Add support for being used as a second level controller
      irqchip/bcm2835: Refactor handle_IRQ() calls out of MAKE_HWIRQ
      PCI: xilinx: Fix typo in function name
      irqchip/gic: Ensure gic_cpu_if_up/down() programs correct GIC instance
      irqchip/gic: Only allow the primary GIC to set the CPU map
      PCI/MSI: pci-xgene-msi: Consolidate chained IRQ handler install/remove
      unicore32/irq: Prepare puv3_gpio_handler for irq argument removal
      tile/pci_gx: Prepare trio_handle_level_irq for irq argument removal
      m68k/irq: Prepare irq handlers for irq argument removal
      C6X/megamode-pic: Prepare megamod_irq_cascade for irq argument removal
      blackfin: Prepare irq handlers for irq argument removal
      arc/irq: Prepare idu_cascade_isr for irq argument removal
      sparc/irq: Use access helper irq_data_get_affinity_mask()
      sparc/irq: Use helper irq_data_get_irq_handler_data()
      parisc/irq: Use access helper irq_data_get_affinity_mask()
      mn10300/irq: Use access helper irq_data_get_affinity_mask()
      irqchip/i8259: Prepare i8259_irq_dispatch for irq argument removal
      ...

commit 26f8b7edc9eab56638274f5db90848a6df602081
Merge: edc837da4b54 9ca678d1dff6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Aug 31 17:14:39 2015 -0700

    Merge tag 'pci-v4.3-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI updates from Bjorn Helgaas:
     "PCI changes for the v4.3 merge window:
    
      Enumeration:
       - Allocate ATS struct during enumeration (Bjorn Helgaas)
       - Embed ATS info directly into struct pci_dev (Bjorn Helgaas)
       - Reduce size of ATS structure elements (Bjorn Helgaas)
       - Stop caching ATS Invalidate Queue Depth (Bjorn Helgaas)
       - iommu/vt-d: Cache PCI ATS state and Invalidate Queue Depth (Bjorn Helgaas)
       - Move MPS configuration check to pci_configure_device() (Bjorn Helgaas)
       - Set MPS to match upstream bridge (Keith Busch)
       - ARM/PCI: Set MPS before pci_bus_add_devices() (Murali Karicheri)
       - Add pci_scan_root_bus_msi() (Lorenzo Pieralisi)
       - ARM/PCI, designware, xilinx: Use pci_scan_root_bus_msi() (Lorenzo Pieralisi)
    
      Resource management:
       - Call pci_read_bridge_bases() from core instead of arch code (Lorenzo Pieralisi)
    
      PCI device hotplug:
       - pciehp: Remove unused interrupt events (Bjorn Helgaas)
       - pciehp: Remove ignored MRL sensor interrupt events (Bjorn Helgaas)
       - pciehp: Handle invalid data when reading from non-existent devices (Jarod Wilson)
       - pciehp: Simplify pcie_poll_cmd() (Yijing Wang)
       - Use "slot" and "pci_slot" for struct hotplug_slot and struct pci_slot (Yijing Wang)
       - Protect pci_bus->slots with pci_slot_mutex, not pci_bus_sem (Yijing Wang)
       - Hold pci_slot_mutex while searching bus->slots list (Yijing Wang)
    
      Power management:
       - Disable async suspend/resume for JMicron multi-function SATA/AHCI (Zhang Rui)
    
      Virtualization:
       - Add ACS quirks for Intel I219-LM/V (Alex Williamson)
       - Restore ACS configuration as part of pci_restore_state() (Alexander Duyck)
    
      MSI:
       - Add pcibios_alloc_irq() and pcibios_free_irq() (Jiang Liu)
       - x86: Implement pcibios_alloc_irq() and pcibios_free_irq() (Jiang Liu)
       - Add helpers to manage pci_dev->irq and pci_dev->irq_managed (Jiang Liu)
       - Free legacy IRQ when enabling MSI/MSI-X (Jiang Liu)
       - ARM/PCI: Remove msi_controller from struct pci_sys_data (Lorenzo Pieralisi)
       - Remove unused pcibios_msi_controller() hook (Lorenzo Pieralisi)
    
      Generic host bridge driver:
       - Remove dependency on ARM-specific struct hw_pci (Jayachandran C)
       - Build setup-irq.o for arm64 (Jayachandran C)
       - Add arm64 support (Jayachandran C)
    
      APM X-Gene host bridge driver:
       - Add APM X-Gene PCIe 64-bit prefetchable window (Duc Dang)
       - Add support for a 64-bit prefetchable memory window (Duc Dang)
       - Drop owner assignment from platform_driver (Krzysztof Kozlowski)
    
      Broadcom iProc host bridge driver:
       - Allow BCMA bus driver to be built as module (Hauke Mehrtens)
       - Delete unnecessary checks before phy calls (Markus Elfring)
       - Add arm64 support (Ray Jui)
    
      Synopsys DesignWare host bridge driver:
       - Don't complain missing *config* reg space if va_cfg0 is set (Murali Karicheri)
    
      TI DRA7xx host bridge driver:
       - Disable pm_runtime on get_sync failure (Kishon Vijay Abraham I)
       - Add PM support (Kishon Vijay Abraham I)
       - Clear MSE bit during suspend so clocks will idle (Kishon Vijay Abraham I)
       - Add support to make GPIO drive PERST# line (Kishon Vijay Abraham I)
    
      Xilinx AXI host bridge driver:
       - Check for MSI interrupt flag before handling as INTx (Russell Joyce)
    
      Miscellaneous:
       - Fix Intersil/Techwell TW686[4589] AV capture class code (Krzysztof Hałasa)
       - Use PCI_CLASS_SERIAL_USB instead of bare number (Bjorn Helgaas)
       - Fix generic NCR 53c810 class code quirk (Bjorn Helgaas)
       - Fix TI816X class code quirk (Bjorn Helgaas)
       - Remove unused "pci_probe" flags (Bjorn Helgaas)
       - Host bridge driver code simplifications (Fabio Estevam)
       - Add dev_flags bit to access VPD through function 0 (Mark Rustad)
       - Add VPD function 0 quirk for Intel Ethernet devices (Mark Rustad)
       - Kill off set_irq_flags() usage (Rob Herring)
       - Remove Intel Cherrytrail D3 delays (Srinidhi Kasagar)
       - Clean up pci_find_capability() (Wei Yang)"
    
    * tag 'pci-v4.3-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (72 commits)
      PCI: Disable async suspend/resume for JMicron multi-function SATA/AHCI
      PCI: Set MPS to match upstream bridge
      PCI: Move MPS configuration check to pci_configure_device()
      PCI: Drop references acquired by of_parse_phandle()
      PCI/MSI: Remove unused pcibios_msi_controller() hook
      ARM/PCI: Remove msi_controller from struct pci_sys_data
      ARM/PCI, designware, xilinx: Use pci_scan_root_bus_msi()
      PCI: Add pci_scan_root_bus_msi()
      ARM/PCI: Replace panic with WARN messages on failures
      PCI: generic: Add arm64 support
      PCI: Build setup-irq.o for arm64
      PCI: generic: Remove dependency on ARM-specific struct hw_pci
      PCI: imx6: Simplify a trivial if-return sequence
      PCI: spear: Use BUG_ON() instead of condition followed by BUG()
      PCI: dra7xx: Remove unneeded use of IS_ERR_VALUE()
      PCI: Remove pci_ats_enabled()
      PCI: Stop caching ATS Invalidate Queue Depth
      PCI: Move ATS declarations to linux/pci.h so they're all together
      PCI: Clean up ATS error handling
      PCI: Use pci_physfn() rather than looking up physfn by hand
      ...

commit 9ca678d1dff610f7df6ac9b31fd9152c4426f815
Merge: 2fc32c92593d 27d868b5e6cf 91f15fb30c77
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Aug 28 15:53:08 2015 -0500

    Merge branches 'pci/enumeration' and 'pci/misc' into next
    
    * pci/enumeration:
      PCI: Set MPS to match upstream bridge
      PCI: Move MPS configuration check to pci_configure_device()
      PCI: Drop references acquired by of_parse_phandle()
      PCI/MSI: Remove unused pcibios_msi_controller() hook
      ARM/PCI: Remove msi_controller from struct pci_sys_data
      ARM/PCI, designware, xilinx: Use pci_scan_root_bus_msi()
      PCI: Add pci_scan_root_bus_msi()
      ARM/PCI: Replace panic with WARN messages on failures
      PCI: generic: Add arm64 support
      PCI: Build setup-irq.o for arm64
      PCI: generic: Remove dependency on ARM-specific struct hw_pci
      ARM/PCI: Set MPS before pci_bus_add_devices()
    
    * pci/misc:
      PCI: Disable async suspend/resume for JMicron multi-function SATA/AHCI

commit 22b6839b914bbe5d94de11bbb83931952090719c
Author: Guilherme G. Piccoli <gpiccoli@linux.vnet.ibm.com>
Date:   Mon Aug 24 22:42:46 2015 +1000

    PCI: Make pci_msi_setup_pci_dev() non-static for use by arch code
    
    Commit 1851617cd2da ("PCI/MSI: Disable MSI at enumeration even if kernel
    doesn't support MSI") changed the location of the code that initialises
    dev->msi_cap/msix_cap and then disables MSI/MSI-X interrupts at PCI
    probe time in devices that have this flag set. It moved the code from
    pci_msi_init_pci_dev() to a new function named pci_msi_setup_pci_dev(),
    called by pci_setup_device().
    
    The pseries PCI probing code does not call pci_setup_device(), so since
    the aforementioned commit the function pci_msi_setup_pci_dev() is not
    called and MSI/MSI-X interrupts are left enabled. Additionally because
    dev->msi_cap/msix_cap are not initialised no driver can ever enable
    MSI/MSI-X.
    
    To fix this, the pseries PCI probe should manually call
    pci_msi_setup_pci_dev(), so this patch makes it non-static.
    
    Fixes: 1851617cd2da ("PCI/MSI: Disable MSI at enumeration even if kernel doesn't support MSI")
    [mpe: Update change log to mention dev->msi_cap/msix_cap]
    Signed-off-by: Guilherme G. Piccoli <gpiccoli@linux.vnet.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index b978bbfe044c..f6ae0d0052eb 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1108,7 +1108,7 @@ int pci_cfg_space_size(struct pci_dev *dev)
 
 #define LEGACY_IO_RESOURCE	(IORESOURCE_IO | IORESOURCE_PCI_FIXED)
 
-static void pci_msi_setup_pci_dev(struct pci_dev *dev)
+void pci_msi_setup_pci_dev(struct pci_dev *dev)
 {
 	/*
 	 * Disable the MSI hardware to avoid screaming interrupts

commit 27d868b5e6cfaee4fec66b388e4085ff94050fa7
Author: Keith Busch <keith.busch@intel.com>
Date:   Mon Aug 24 08:48:16 2015 -0500

    PCI: Set MPS to match upstream bridge
    
    Firmware typically configures the PCIe fabric with a consistent Max Payload
    Size setting based on the devices present at boot.  A hot-added device
    typically has the power-on default MPS setting (128 bytes), which may not
    match the fabric.
    
    The previous Linux default, in the absence of any "pci=pcie_bus_*" options,
    was PCIE_BUS_TUNE_OFF, in which we never touch MPS, even for hot-added
    devices.
    
    Add a new default setting, PCIE_BUS_DEFAULT, in which we make sure every
    device's MPS setting matches the upstream bridge.  This makes it more
    likely that a hot-added device will work in a system with optimized MPS
    configuration.
    
    Note that if we hot-add a device that only supports 128-byte MPS, it still
    likely won't work because we don't reconfigure the rest of the fabric.
    Booting with "pci=pcie_bus_peer2peer" is a workaround for this because it
    sets MPS to 128 for everything.
    
    [bhelgaas: changelog, new default, rework for pci_configure_device() path]
    Tested-by: Keith Busch <keith.busch@intel.com>
    Tested-by: Jordan Hargrave <jharg93@gmail.com>
    Signed-off-by: Keith Busch <keith.busch@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index eb32395d5897..eebabe3a814e 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1278,7 +1278,7 @@ int pci_setup_device(struct pci_dev *dev)
 static void pci_configure_mps(struct pci_dev *dev)
 {
 	struct pci_dev *bridge = pci_upstream_bridge(dev);
-	int mps, p_mps;
+	int mps, p_mps, rc;
 
 	if (!pci_is_pcie(dev) || !bridge || !pci_is_pcie(bridge))
 		return;
@@ -1294,6 +1294,23 @@ static void pci_configure_mps(struct pci_dev *dev)
 			 mps, pci_name(bridge), p_mps);
 		return;
 	}
+
+	/*
+	 * Fancier MPS configuration is done later by
+	 * pcie_bus_configure_settings()
+	 */
+	if (pcie_bus_config != PCIE_BUS_DEFAULT)
+		return;
+
+	rc = pcie_set_mps(dev, p_mps);
+	if (rc) {
+		dev_warn(&dev->dev, "can't set Max Payload Size to %d; if necessary, use \"pci=pcie_bus_safe\" and report a bug\n",
+			 p_mps);
+		return;
+	}
+
+	dev_info(&dev->dev, "Max Payload Size set to %d (was %d, max %d)\n",
+		 p_mps, mps, 128 << dev->pcie_mpss);
 }
 
 static struct hpp_type0 pci_default_type0 = {
@@ -1821,7 +1838,8 @@ static int pcie_bus_configure_set(struct pci_dev *dev, void *data)
 	if (!pci_is_pcie(dev))
 		return 0;
 
-	if (pcie_bus_config == PCIE_BUS_TUNE_OFF)
+	if (pcie_bus_config == PCIE_BUS_TUNE_OFF ||
+	    pcie_bus_config == PCIE_BUS_DEFAULT)
 		return 0;
 
 	mps = 128 << *(u8 *)data;

commit 9dae3a97297f71e884ed8e7664955bcacb86f010
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Aug 20 16:08:27 2015 -0500

    PCI: Move MPS configuration check to pci_configure_device()
    
    Previously we checked for invalid MPS settings, i.e., a device with MPS
    different than its upstream bridge, in pcie_bus_detect_mps().  We only did
    this if the arch or hotplug driver called pcie_bus_configure_settings(),
    and then only if PCIe bus tuning was disabled (PCIE_BUS_TUNE_OFF).
    
    Move the MPS checking code to pci_configure_device(), so we do it in the
    pci_device_add() path for every device.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 9ff4df0db0c3..eb32395d5897 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1275,6 +1275,27 @@ int pci_setup_device(struct pci_dev *dev)
 	return 0;
 }
 
+static void pci_configure_mps(struct pci_dev *dev)
+{
+	struct pci_dev *bridge = pci_upstream_bridge(dev);
+	int mps, p_mps;
+
+	if (!pci_is_pcie(dev) || !bridge || !pci_is_pcie(bridge))
+		return;
+
+	mps = pcie_get_mps(dev);
+	p_mps = pcie_get_mps(bridge);
+
+	if (mps == p_mps)
+		return;
+
+	if (pcie_bus_config == PCIE_BUS_TUNE_OFF) {
+		dev_warn(&dev->dev, "Max Payload Size %d, but upstream %s set to %d; if necessary, use \"pci=pcie_bus_safe\" and report a bug\n",
+			 mps, pci_name(bridge), p_mps);
+		return;
+	}
+}
+
 static struct hpp_type0 pci_default_type0 = {
 	.revision = 1,
 	.cache_line_size = 8,
@@ -1396,6 +1417,8 @@ static void pci_configure_device(struct pci_dev *dev)
 	struct hotplug_params hpp;
 	int ret;
 
+	pci_configure_mps(dev);
+
 	memset(&hpp, 0, sizeof(hpp));
 	ret = pci_get_hp_params(dev, &hpp);
 	if (ret)
@@ -1791,22 +1814,6 @@ static void pcie_write_mrrs(struct pci_dev *dev)
 		dev_err(&dev->dev, "MRRS was unable to be configured with a safe value.  If problems are experienced, try running with pci=pcie_bus_safe\n");
 }
 
-static void pcie_bus_detect_mps(struct pci_dev *dev)
-{
-	struct pci_dev *bridge = dev->bus->self;
-	int mps, p_mps;
-
-	if (!bridge)
-		return;
-
-	mps = pcie_get_mps(dev);
-	p_mps = pcie_get_mps(bridge);
-
-	if (mps != p_mps)
-		dev_warn(&dev->dev, "Max Payload Size %d, but upstream %s set to %d; if necessary, use \"pci=pcie_bus_safe\" and report a bug\n",
-			 mps, pci_name(bridge), p_mps);
-}
-
 static int pcie_bus_configure_set(struct pci_dev *dev, void *data)
 {
 	int mps, orig_mps;
@@ -1814,10 +1821,8 @@ static int pcie_bus_configure_set(struct pci_dev *dev, void *data)
 	if (!pci_is_pcie(dev))
 		return 0;
 
-	if (pcie_bus_config == PCIE_BUS_TUNE_OFF) {
-		pcie_bus_detect_mps(dev);
+	if (pcie_bus_config == PCIE_BUS_TUNE_OFF)
 		return 0;
-	}
 
 	mps = 128 << *(u8 *)data;
 	orig_mps = pcie_get_mps(dev);

commit d2a7926d42b3b46e45b4e44dc3302b2701ec0856
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Mon Aug 3 21:27:10 2015 -0500

    PCI: Add pci_scan_root_bus_msi()
    
    Add a pci_scan_root_bus_msi() interface so an arch can specify the MSI
    controller up front.  This removes the need for a pcibios callback to set
    the MSI controller later.
    
    This is not exported because I'd like to replace the variety of "scan root
    bus" interfaces with a single, more extensible interface that can handle
    the MSI controller, domain, pci_ops, resources, etc.  I hope this interface
    is temporary.
    
    [bhelgaas: changelog, split into separate patch]
    Suggested-by: Russell King <linux@arm.linux.org.uk>
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Jingoo Han <jingoohan1@gmail.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index cefd636681b6..9ff4df0db0c3 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -2096,8 +2096,9 @@ void pci_bus_release_busn_res(struct pci_bus *b)
 			res, ret ? "can not be" : "is");
 }
 
-struct pci_bus *pci_scan_root_bus(struct device *parent, int bus,
-		struct pci_ops *ops, void *sysdata, struct list_head *resources)
+struct pci_bus *pci_scan_root_bus_msi(struct device *parent, int bus,
+		struct pci_ops *ops, void *sysdata,
+		struct list_head *resources, struct msi_controller *msi)
 {
 	struct resource_entry *window;
 	bool found = false;
@@ -2114,6 +2115,8 @@ struct pci_bus *pci_scan_root_bus(struct device *parent, int bus,
 	if (!b)
 		return NULL;
 
+	b->msi = msi;
+
 	if (!found) {
 		dev_info(&b->dev,
 		 "No busn resource found for root bus, will use [bus %02x-ff]\n",
@@ -2128,6 +2131,13 @@ struct pci_bus *pci_scan_root_bus(struct device *parent, int bus,
 
 	return b;
 }
+
+struct pci_bus *pci_scan_root_bus(struct device *parent, int bus,
+		struct pci_ops *ops, void *sysdata, struct list_head *resources)
+{
+	return pci_scan_root_bus_msi(parent, bus, ops, sysdata, resources,
+				     NULL);
+}
 EXPORT_SYMBOL(pci_scan_root_bus);
 
 struct pci_bus *pci_scan_bus(int bus, struct pci_ops *ops,

commit b35b1df5e6c213b0b0322e6c231b7111efe4a390
Author: Yijing Wang <wangyijing@huawei.com>
Date:   Mon Aug 17 18:47:58 2015 +0800

    PCI: Tolerate hierarchies with no Root Port
    
    We should not assume any particular hardware topology.  Commit d0751b98dfa3
    ("PCI: Add dev->has_secondary_link to track downstream PCIe links") relied
    on the assumption that every PCIe hierarchy is rooted at a Root Port.  But
    we can't rely on any assumption about what hardware we will find; we just
    have to deal with the world as it is.
    
    On some platforms, PCIe devices (endpoints, switch upstream ports, etc.)
    appear directly on the root bus, and there is no Root Port in the PCI bus
    hierarchy.  For example, Meelis observed these top-level devices on a
    Sparc V245:
    
      0000:02:00.0 PCI bridge to [bus 03-0d]    Switch Upstream Port
      0001:02:00.0 PCI bridge to [bus 03]       PCIe to PCI/PCI-X Bridge
    
    These devices *look* like they have links going upstream, but there really
    are no upstream devices.
    
    In set_pcie_port_type(), we used the parent device to figure out which side
    of a switch port has a link, so if the parent device did not exist, we
    dereferenced a NULL parent pointer.
    
    Check whether the parent device exists before dereferencing it.
    
    Meelis observed this oops on Sparc V245 and T2000.  Ben Herrenschmidt says
    this is also possible on IBM PowerVM guests on PowerPC.
    
    [bhelgaas: changelog, comment]
    Link: http://lkml.kernel.org/r/alpine.LRH.2.20.1508122118210.18637@math.ut.ee
    Reported-by: Meelis Roos <mroos@linux.ee>
    Tested-by: Meelis Roos <mroos@linux.ee>
    Signed-off-by: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index cefd636681b6..b978bbfe044c 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -997,7 +997,12 @@ void set_pcie_port_type(struct pci_dev *pdev)
 	else if (type == PCI_EXP_TYPE_UPSTREAM ||
 		 type == PCI_EXP_TYPE_DOWNSTREAM) {
 		parent = pci_upstream_bridge(pdev);
-		if (!parent->has_secondary_link)
+
+		/*
+		 * Usually there's an upstream device (Root Port or Switch
+		 * Downstream Port), but we can't assume one exists.
+		 */
+		if (parent && !parent->has_secondary_link)
 			pdev->has_secondary_link = 1;
 	}
 }

commit 1f408d57437e53ae9aa6edb335ff9fe7ba7aba2c
Merge: 5a4f3cf0d1f0 2db0f71f5679 f7ef1340bb50 3e14675335a1 95e16587ccd0
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Aug 14 08:16:29 2015 -0500

    Merge branches 'pci/hotplug', 'pci/iommu', 'pci/irq' and 'pci/virtualization' into next
    
    * pci/hotplug:
      PCI: pciehp: Remove ignored MRL sensor interrupt events
      PCI: pciehp: Remove unused interrupt events
      PCI: pciehp: Handle invalid data when reading from non-existent devices
      PCI: Hold pci_slot_mutex while searching bus->slots list
      PCI: Protect pci_bus->slots with pci_slot_mutex, not pci_bus_sem
      PCI: pciehp: Simplify pcie_poll_cmd()
      PCI: Use "slot" and "pci_slot" for struct hotplug_slot and struct pci_slot
    
    * pci/iommu:
      PCI: Remove pci_ats_enabled()
      PCI: Stop caching ATS Invalidate Queue Depth
      PCI: Move ATS declarations to linux/pci.h so they're all together
      PCI: Clean up ATS error handling
      PCI: Use pci_physfn() rather than looking up physfn by hand
      PCI: Inline the ATS setup code into pci_ats_init()
      PCI: Rationalize pci_ats_queue_depth() error checking
      PCI: Reduce size of ATS structure elements
      PCI: Embed ATS info directly into struct pci_dev
      PCI: Allocate ATS struct during enumeration
      iommu/vt-d: Cache PCI ATS state and Invalidate Queue Depth
    
    * pci/irq:
      PCI: Kill off set_irq_flags() usage
    
    * pci/virtualization:
      PCI: Add ACS quirks for Intel I219-LM/V

commit edc90fee916b4f0d14af9c6b5c08666747488ef8
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Jul 17 15:05:46 2015 -0500

    PCI: Allocate ATS struct during enumeration
    
    Previously, we allocated pci_ats structures when an IOMMU driver called
    pci_enable_ats().  An SR-IOV VF shares the STU setting with its PF, so when
    enabling ATS on the VF, we allocated a pci_ats struct for the PF if it
    didn't already have one.  We held the sriov->lock to serialize threads
    concurrently enabling ATS on several VFS so only one would allocate the PF
    pci_ats.
    
    Gregor reported a deadlock here:
    
      pci_enable_sriov
        sriov_enable
          virtfn_add
            mutex_lock(dev->sriov->lock)      # acquire sriov->lock
            pci_device_add
              device_add
                BUS_NOTIFY_ADD_DEVICE notifier chain
                iommu_bus_notifier
                  amd_iommu_add_device        # iommu_ops.add_device
                    init_iommu_group
                      iommu_group_get_for_dev
                        iommu_group_add_device
                          __iommu_attach_device
                            amd_iommu_attach_device  # iommu_ops.attach_device
                              attach_device
                                pci_enable_ats
                                  mutex_lock(dev->sriov->lock) # deadlock
    
    There's no reason to delay allocating the pci_ats struct, and if we
    allocate it for each device at enumeration-time, there's no need for
    locking in pci_enable_ats().
    
    Allocate pci_ats struct during enumeration, when we initialize other
    capabilities.
    
    Note that this implementation requires ATS to be enabled on the PF first,
    before on any of the VFs because the PF controls the STU for all the VFs.
    
    Link: http://permalink.gmane.org/gmane.linux.kernel.iommu/9433
    Reported-by: Gregor Dick <gdick@solarflare.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Joerg Roedel <jroedel@suse.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index cefd636681b6..c206398ca67e 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1540,6 +1540,9 @@ static void pci_init_capabilities(struct pci_dev *dev)
 	/* Single Root I/O Virtualization */
 	pci_iov_init(dev);
 
+	/* Address Translation Services */
+	pci_ats_init(dev);
+
 	/* Enable ACS P2P upstream forwarding */
 	pci_enable_acs(dev);
 }

commit 92b19ff50e8f242392d78b2aacc5b5b672f1796b
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Mon Aug 10 23:07:06 2015 -0400

    cleanup IORESOURCE_CACHEABLE vs ioremap()
    
    Quoting Arnd:
        I was thinking the opposite approach and basically removing all uses
        of IORESOURCE_CACHEABLE from the kernel. There are only a handful of
        them.and we can probably replace them all with hardcoded
        ioremap_cached() calls in the cases they are actually useful.
    
    All existing usages of IORESOURCE_CACHEABLE call ioremap() instead of
    ioremap_nocache() if the resource is cacheable, however ioremap() is
    uncached by default. Clearly none of the existing usages care about the
    cacheability. Particularly devm_ioremap_resource() never worked as
    advertised since it always fell back to plain ioremap().
    
    Clean this up as the new direction we want is to convert
    ioremap_<type>() usages to memremap(..., flags).
    
    Suggested-by: Arnd Bergmann <arnd@arndb.de>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index cefd636681b6..8ed37dd04056 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -326,8 +326,7 @@ static void pci_read_bases(struct pci_dev *dev, unsigned int howmany, int rom)
 		struct resource *res = &dev->resource[PCI_ROM_RESOURCE];
 		dev->rom_base_reg = rom;
 		res->flags = IORESOURCE_MEM | IORESOURCE_PREFETCH |
-				IORESOURCE_READONLY | IORESOURCE_CACHEABLE |
-				IORESOURCE_SIZEALIGN;
+				IORESOURCE_READONLY | IORESOURCE_SIZEALIGN;
 		__pci_read_base(dev, pci_bar_mem32, res, rom);
 	}
 }

commit 5a4f3cf0d1f02884c0a64488d22b3bb4bce31b44
Merge: cd66d5c3df7c 5f2269916b0e 24b390aad293 dff22d2054b5 ccbc175aad81
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Aug 4 20:54:05 2015 -0500

    Merge branches 'pci/irq', 'pci/misc', 'pci/resource' and 'pci/virtualization' into next
    
    * pci/irq:
      PCI/MSI: Free legacy IRQ when enabling MSI/MSI-X
      PCI: Add helpers to manage pci_dev->irq and pci_dev->irq_managed
      PCI, x86: Implement pcibios_alloc_irq() and pcibios_free_irq()
      PCI: Add pcibios_alloc_irq() and pcibios_free_irq()
    
    * pci/misc:
      PCI: Remove unused "pci_probe" flags
      PCI: Add VPD function 0 quirk for Intel Ethernet devices
      PCI: Add dev_flags bit to access VPD through function 0
      PCI / ACPI: Fix pci_acpi_optimize_delay() comment
      PCI: Remove a broken link in quirks.c
      PCI: Remove useless redundant code
      PCI: Simplify pci_find_(ext_)capability() return value checks
      PCI: Move PCI_FIND_CAP_TTL to pci.h and use it in quirks
      PCI: Add pcie_downstream_port() (true for Root and Switch Downstream Ports)
      PCI: Fix pcie_port_device_resume() comment
      PCI: Shift PCI_CLASS_NOT_DEFINED consistently with other classes
      PCI: Revert aeb30016fec3 ("PCI: add Intel USB specific reset method")
      PCI: Fix TI816X class code quirk
      PCI: Fix generic NCR 53c810 class code quirk
      PCI: Use PCI_CLASS_SERIAL_USB instead of bare number
      PCI: Add quirk for Intersil/Techwell TW686[4589] AV capture cards
      PCI: Remove Intel Cherrytrail D3 delays
    
    * pci/resource:
      PCI: Call pci_read_bridge_bases() from core instead of arch code
    
    * pci/virtualization:
      PCI: Restore ACS configuration as part of pci_restore_state()

commit 017ffe64e8b8c8db0f50433a71da41c6a4e12710
Author: Yijing Wang <wangyijing@huawei.com>
Date:   Fri Jul 17 17:16:32 2015 +0800

    PCI: Hold pci_slot_mutex while searching bus->slots list
    
    Previously, pci_setup_device() and similar functions searched the
    pci_bus->slots list without any locking.  It was possible for another
    thread to update the list while we searched it.
    
    Add pci_dev_assign_slot() to search the list while holding pci_slot_mutex.
    
    [bhelgaas: changelog, fold in CONFIG_SYSFS fix]
    Tested-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index cefd636681b6..2a9ce16cb374 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1133,7 +1133,6 @@ int pci_setup_device(struct pci_dev *dev)
 {
 	u32 class;
 	u8 hdr_type;
-	struct pci_slot *slot;
 	int pos = 0;
 	struct pci_bus_region region;
 	struct resource *res;
@@ -1149,10 +1148,7 @@ int pci_setup_device(struct pci_dev *dev)
 	dev->error_state = pci_channel_io_normal;
 	set_pcie_port_type(dev);
 
-	list_for_each_entry(slot, &dev->bus->slots, list)
-		if (PCI_SLOT(dev->devfn) == slot->number)
-			dev->slot = slot;
-
+	pci_dev_assign_slot(dev);
 	/* Assume 32-bit PCI; let 64-bit PCI cards (which are far rarer)
 	   set this higher, assuming the system even supports it.  */
 	dev->dma_mask = 0xffffffff;

commit b165e2b60b39888a7ff8efbc1de40137471dda41
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Tue Jul 28 14:46:12 2015 +0100

    PCI/MSI: Add support for OF-provided msi_domain
    
    In order to populate the PCI host bridge msi_domain, use the
    "msi-parent" attribute to lookup a corresponding irq domain.
    If found, this is our MSI domain.
    
    This gets plugged into the core PCI code.
    
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Cc: <linux-arm-kernel@lists.infradead.org>
    Cc: Yijing Wang <wangyijing@huawei.com>
    Cc: Ma Jun <majun258@huawei.com>
    Cc: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Cc: Duc Dang <dhdang@apm.com>
    Cc: Hanjun Guo <hanjun.guo@linaro.org>
    Cc: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Link: http://lkml.kernel.org/r/1438091186-10244-6-git-send-email-marc.zyngier@arm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index c03ecbffc50b..a7afeacce7f1 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -663,12 +663,15 @@ static void pci_set_bus_speed(struct pci_bus *bus)
 
 static struct irq_domain *pci_host_bridge_msi_domain(struct pci_bus *bus)
 {
+	struct irq_domain *d;
+
 	/*
 	 * Any firmware interface that can resolve the msi_domain
 	 * should be called from here.
 	 */
+	d = pci_host_bridge_of_msi_domain(bus);
 
-	return NULL;
+	return d;
 }
 
 static void pci_set_bus_msi_domain(struct pci_bus *bus)

commit 44aa0c657e3e45795a92addeb0dce7d28d9b0bd2
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Tue Jul 28 14:46:11 2015 +0100

    PCI/MSI: Add hooks to populate the msi_domain field
    
    In order to be able to populate the device msi_domain field,
    add the necessary hooks to propagate the host bridge msi_domain
    across secondary busses to devices.
    
    So far, nobody populates the initial msi_domain.
    
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Hanjun Guo <hanjun.guo@linaro.org>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Cc: <linux-arm-kernel@lists.infradead.org>
    Cc: Yijing Wang <wangyijing@huawei.com>
    Cc: Ma Jun <majun258@huawei.com>
    Cc: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Cc: Duc Dang <dhdang@apm.com>
    Cc: Jiang Liu <jiang.liu@linux.intel.com>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Link: http://lkml.kernel.org/r/1438091186-10244-5-git-send-email-marc.zyngier@arm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index cefd636681b6..c03ecbffc50b 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -661,6 +661,32 @@ static void pci_set_bus_speed(struct pci_bus *bus)
 	}
 }
 
+static struct irq_domain *pci_host_bridge_msi_domain(struct pci_bus *bus)
+{
+	/*
+	 * Any firmware interface that can resolve the msi_domain
+	 * should be called from here.
+	 */
+
+	return NULL;
+}
+
+static void pci_set_bus_msi_domain(struct pci_bus *bus)
+{
+	struct irq_domain *d;
+
+	/*
+	 * Either bus is the root, and we must obtain it from the
+	 * firmware, or we inherit it from the bridge device.
+	 */
+	if (pci_is_root_bus(bus))
+		d = pci_host_bridge_msi_domain(bus);
+	else
+		d = dev_get_msi_domain(&bus->self->dev);
+
+	dev_set_msi_domain(&bus->dev, d);
+}
+
 static struct pci_bus *pci_alloc_child_bus(struct pci_bus *parent,
 					   struct pci_dev *bridge, int busnr)
 {
@@ -714,6 +740,7 @@ static struct pci_bus *pci_alloc_child_bus(struct pci_bus *parent,
 	bridge->subordinate = child;
 
 add_dev:
+	pci_set_bus_msi_domain(child);
 	ret = device_register(&child->dev);
 	WARN_ON(ret < 0);
 
@@ -1544,6 +1571,17 @@ static void pci_init_capabilities(struct pci_dev *dev)
 	pci_enable_acs(dev);
 }
 
+static void pci_set_msi_domain(struct pci_dev *dev)
+{
+	/*
+	 * If no domain has been set through the pcibios_add_device
+	 * callback, inherit the default from the bus device.
+	 */
+	if (!dev_get_msi_domain(&dev->dev))
+		dev_set_msi_domain(&dev->dev,
+				   dev_get_msi_domain(&dev->bus->dev));
+}
+
 void pci_device_add(struct pci_dev *dev, struct pci_bus *bus)
 {
 	int ret;
@@ -1585,6 +1623,9 @@ void pci_device_add(struct pci_dev *dev, struct pci_bus *bus)
 	ret = pcibios_add_device(dev);
 	WARN_ON(ret < 0);
 
+	/* Setup MSI irq domain */
+	pci_set_msi_domain(dev);
+
 	/* Notifier could use PCI capabilities */
 	dev->match_driver = false;
 	ret = device_add(&dev->dev);
@@ -1975,6 +2016,7 @@ struct pci_bus *pci_create_root_bus(struct device *parent, int bus,
 	b->bridge = get_device(&bridge->dev);
 	device_enable_async_suspend(b->bridge);
 	pci_set_bus_of_node(b);
+	pci_set_bus_msi_domain(b);
 
 	if (!parent)
 		set_dev_node(b->bridge, pcibus_to_node(b));

commit dff22d2054b5dbb1889f20c03959dd0c494fab8c
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Thu Jul 9 11:59:16 2015 +0100

    PCI: Call pci_read_bridge_bases() from core instead of arch code
    
    When we scan a PCI bus, we read PCI-PCI bridge window registers with
    pci_read_bridge_bases() so we can validate the resource hierarchy.  Most
    architectures call pci_read_bridge_bases() from pcibios_fixup_bus(), but
    PCI-PCI bridges are not arch-specific, so this doesn't need to be in
    arch-specific code.
    
    Call pci_read_bridge_bases() directly from the PCI core instead of from
    arch code.
    
    For alpha and mips, we now call pci_read_bridge_bases() always; previously
    we only called it if PCI_PROBE_ONLY was set.
    
    [bhelgaas: changelog]
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    CC: Ralf Baechle <ralf@linux-mips.org>
    CC: James E.J. Bottomley <jejb@parisc-linux.org>
    CC: Michael Ellerman <mpe@ellerman.id.au>
    CC: Bjorn Helgaas <bhelgaas@google.com>
    CC: Richard Henderson <rth@twiddle.net>
    CC: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    CC: David Howells <dhowells@redhat.com>
    CC: Russell King <linux@arm.linux.org.uk>
    CC: Tony Luck <tony.luck@intel.com>
    CC: David S. Miller <davem@davemloft.net>
    CC: Ingo Molnar <mingo@redhat.com>
    CC: Guenter Roeck <linux@roeck-us.net>
    CC: Michal Simek <monstr@monstr.eu>
    CC: Chris Zankel <chris@zankel.net>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index cefd636681b6..b996aefc1092 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -826,6 +826,9 @@ int pci_scan_bridge(struct pci_bus *bus, struct pci_dev *dev, int max, int pass)
 			child->bridge_ctl = bctl;
 		}
 
+		/* Read and initialize bridge resources */
+		pci_read_bridge_bases(child);
+
 		cmax = pci_scan_child_bus(child);
 		if (cmax > subordinate)
 			dev_warn(&dev->dev, "bridge has subordinate %02x but max busn %02x\n",
@@ -886,6 +889,9 @@ int pci_scan_bridge(struct pci_bus *bus, struct pci_dev *dev, int max, int pass)
 
 		if (!is_cardbus) {
 			child->bridge_ctl = bctl;
+
+			/* Read and initialize bridge resources */
+			pci_read_bridge_bases(child);
 			max = pci_scan_child_bus(child);
 		} else {
 			/*

commit 2b4aed1d1f119634d80d8c701873c2be01480aa9
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Jun 19 16:20:58 2015 -0500

    PCI: Shift PCI_CLASS_NOT_DEFINED consistently with other classes
    
    The PCI class in dev->class is a three-byte value comprising a base class,
    sub-class, and interface type.  PCI_CLASS_NOT_DEFINED includes the base
    class and sub-class, but not the interface type, so it should be shifted to
    make space for the interface.  It happens that PCI_CLASS_NOT_DEFINED is
    zero, so it doesn't matter in the end, but we should still use it
    consistently with other class definitions.
    
    Treat PCI_CLASS_NOT_DEFINED as a base class/sub-class value that should
    appear in bits 8-23 of dev->class.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index cefd636681b6..71bd520e8ff7 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1268,7 +1268,7 @@ int pci_setup_device(struct pci_dev *dev)
 	bad:
 		dev_err(&dev->dev, "ignoring class %#08x (doesn't match header type %02x)\n",
 			dev->class, dev->hdr_type);
-		dev->class = PCI_CLASS_NOT_DEFINED;
+		dev->class = PCI_CLASS_NOT_DEFINED << 8;
 	}
 
 	/* We found a fine healthy device, go go go... */

commit 0ff9b9bad66730e8347cb3350c8d3d1b88a21f13
Merge: 5ebe6afaf005 0c0cbb6c5a04 c0300089fd2d a5dd4b4b0570 01d72a951888 c6201cd8513d 3a9ad0b4fdcd 917bfd93d3c9
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Jun 12 15:26:45 2015 -0500

    Merge branches 'pci/aspm', 'pci/enumeration', 'pci/hotplug', 'pci/misc', 'pci/msi', 'pci/resource' and 'pci/virtualization' into next
    
    * pci/aspm:
      PCI/ASPM: Simplify Clock Power Management setting
      PCI: Use dev->has_secondary_link to find downstream PCIe links
      PCI/ASPM: Use dev->has_secondary_link to find downstream links
      PCI: Add dev->has_secondary_link to track downstream PCIe links
      PCI/ASPM: Remove redundant PCIe port type checking
      PCI/ASPM: Drop __pci_disable_link_state() useless "force" parameter
    
    * pci/enumeration:
      PCI: Remove unused pci_scan_bus_parented()
      xen/pcifront: Don't use deprecated function pci_scan_bus_parented()
      PCI: designware: Use pci_scan_root_bus() for simplicity
      PCI: tegra: Remove tegra_pcie_scan_bus()
      PCI: mvebu: Remove mvebu_pcie_scan_bus()
    
    * pci/hotplug:
      PCI: pciehp: Wait for hotplug command completion where necessary
      PCI: Propagate the "ignore hotplug" setting to parent
      ACPI / hotplug / PCI: Check ignore_hotplug for all downstream devices
      PCI: pciehp: Drop pointless label from pciehp_probe()
      PCI: pciehp: Drop pointless ACPI-based "slot detection" check
    
    * pci/misc:
      PCI: Remove unused pci_dma_burst_advice()
      PCI: Remove unused pcibios_select_root() (again)
      PCI: Remove unnecessary #includes of <asm/pci.h>
      PCI: Include <linux/pci.h>, not <asm/pci.h>
    
    * pci/msi:
      PCI/MSI: Remove unused pci_msi_off()
      PCI/MSI: Drop pci_msi_off() calls from quirks
      ntb: Drop pci_msi_off() call during probe
      virtio_pci: drop pci_msi_off() call during probe
      PCI/MSI: Disable MSI at enumeration even if kernel doesn't support MSI
      PCI/MSI: Export pci_msi_set_enable(), pci_msix_clear_and_set_ctrl()
      PCI/MSI: Rename msi_set_enable(), msix_clear_and_set_ctrl()
    
    * pci/resource:
      PCI: Add pci_bus_addr_t
    
    * pci/virtualization:
      ACPI / PCI: Account for ARI in _PRT lookups
      PCI: Move pci_ari_enabled() to global header
      PCI: Add function 1 DMA alias quirk for Marvell 9120
      PCI: Add ACS quirks for Intel 9-series PCH root ports

commit c0300089fd2dbeebef5ab9b6d66b4e6cedf8500a
Author: Yijing Wang <wangyijing@huawei.com>
Date:   Tue Apr 28 17:32:34 2015 +0800

    PCI: Remove unused pci_scan_bus_parented()
    
    No one uses pci_scan_bus_parented() any more, remove it.
    
    Signed-off-by: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 6675a7a1b9fc..7d6a61c0d5ad 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -2094,25 +2094,6 @@ struct pci_bus *pci_scan_root_bus(struct device *parent, int bus,
 }
 EXPORT_SYMBOL(pci_scan_root_bus);
 
-/* Deprecated; use pci_scan_root_bus() instead */
-struct pci_bus *pci_scan_bus_parented(struct device *parent,
-		int bus, struct pci_ops *ops, void *sysdata)
-{
-	LIST_HEAD(resources);
-	struct pci_bus *b;
-
-	pci_add_resource(&resources, &ioport_resource);
-	pci_add_resource(&resources, &iomem_resource);
-	pci_add_resource(&resources, &busn_resource);
-	b = pci_create_root_bus(parent, bus, ops, sysdata, &resources);
-	if (b)
-		pci_scan_child_bus(b);
-	else
-		pci_free_resource_list(&resources);
-	return b;
-}
-EXPORT_SYMBOL(pci_scan_bus_parented);
-
 struct pci_bus *pci_scan_bus(int bus, struct pci_ops *ops,
 					void *sysdata)
 {

commit 3a9ad0b4fdcd57f775d3615004c8c64c021a9e7d
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Wed May 27 17:23:51 2015 -0700

    PCI: Add pci_bus_addr_t
    
    David Ahern reported that d63e2e1f3df9 ("sparc/PCI: Clip bridge windows
    to fit in upstream windows") fails to boot on sparc/T5-8:
    
      pci 0000:06:00.0: reg 0x184: can't handle BAR above 4GB (bus address 0x110204000)
    
    The problem is that sparc64 assumed that dma_addr_t only needed to hold DMA
    addresses, i.e., bus addresses returned via the DMA API (dma_map_single(),
    etc.), while the PCI core assumed dma_addr_t could hold *any* bus address,
    including raw BAR values.  On sparc64, all DMA addresses fit in 32 bits, so
    dma_addr_t is a 32-bit type.  However, BAR values can be 64 bits wide, so
    they don't fit in a dma_addr_t.  d63e2e1f3df9 added new checking that
    tripped over this mismatch.
    
    Add pci_bus_addr_t, which is wide enough to hold any PCI bus address,
    including both raw BAR values and DMA addresses.  This will be 64 bits
    on 64-bit platforms and on platforms with a 64-bit dma_addr_t.  Then
    dma_addr_t only needs to be wide enough to hold addresses from the DMA API.
    
    [bhelgaas: changelog, bugzilla, Kconfig to ensure pci_bus_addr_t is at
    least as wide as dma_addr_t, documentation]
    Fixes: d63e2e1f3df9 ("sparc/PCI: Clip bridge windows to fit in upstream windows")
    Fixes: 23b13bc76f35 ("PCI: Fail safely if we can't handle BARs larger than 4GB")
    Link: http://lkml.kernel.org/r/CAE9FiQU1gJY1LYrxs+ma5LCTEEe4xmtjRG0aXJ9K_Tsu+m9Wuw@mail.gmail.com
    Link: http://lkml.kernel.org/r/1427857069-6789-1-git-send-email-yinghai@kernel.org
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=96231
    Reported-by: David Ahern <david.ahern@oracle.com>
    Tested-by: David Ahern <david.ahern@oracle.com>
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: David S. Miller <davem@davemloft.net>
    CC: stable@vger.kernel.org      # v3.19+

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 6675a7a1b9fc..c91185721345 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -254,8 +254,8 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 	}
 
 	if (res->flags & IORESOURCE_MEM_64) {
-		if ((sizeof(dma_addr_t) < 8 || sizeof(resource_size_t) < 8) &&
-		    sz64 > 0x100000000ULL) {
+		if ((sizeof(pci_bus_addr_t) < 8 || sizeof(resource_size_t) < 8)
+		    && sz64 > 0x100000000ULL) {
 			res->flags |= IORESOURCE_UNSET | IORESOURCE_DISABLED;
 			res->start = 0;
 			res->end = 0;
@@ -264,7 +264,7 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 			goto out;
 		}
 
-		if ((sizeof(dma_addr_t) < 8) && l) {
+		if ((sizeof(pci_bus_addr_t) < 8) && l) {
 			/* Above 32-bit boundary; try to reallocate */
 			res->flags |= IORESOURCE_UNSET;
 			res->start = 0;
@@ -399,7 +399,7 @@ static void pci_read_bridge_mmio_pref(struct pci_bus *child)
 	struct pci_dev *dev = child->self;
 	u16 mem_base_lo, mem_limit_lo;
 	u64 base64, limit64;
-	dma_addr_t base, limit;
+	pci_bus_addr_t base, limit;
 	struct pci_bus_region region;
 	struct resource *res;
 
@@ -426,8 +426,8 @@ static void pci_read_bridge_mmio_pref(struct pci_bus *child)
 		}
 	}
 
-	base = (dma_addr_t) base64;
-	limit = (dma_addr_t) limit64;
+	base = (pci_bus_addr_t) base64;
+	limit = (pci_bus_addr_t) limit64;
 
 	if (base != base64) {
 		dev_err(&dev->dev, "can't handle bridge window above 4GB (bus address %#010llx)\n",

commit 777e61ea40e4a94081b3123c76ea3fe977c368a2
Author: Yijing Wang <wangyijing@huawei.com>
Date:   Thu May 21 15:05:04 2015 +0800

    PCI: Use dev->has_secondary_link to find downstream PCIe links
    
    Previously we assumed that PCIe Root Ports and Downstream Ports had Links
    on their secondary side.  That is true in most systems, but it is possible
    to connect a switch with either an Upstream or a Downstream Port leading
    downstream.
    
    Instead of relying on the component type to identify devices that have
    links leading downstream, use the "dev->has_secondary_link" field.
    
    [bhelgaas: changelog]
    Signed-off-by: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 96dcd7b8303b..d405d27a92cd 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1629,7 +1629,7 @@ static int only_one_child(struct pci_bus *bus)
 		return 0;
 	if (pci_pcie_type(parent) == PCI_EXP_TYPE_ROOT_PORT)
 		return 1;
-	if (pci_pcie_type(parent) == PCI_EXP_TYPE_DOWNSTREAM &&
+	if (parent->has_secondary_link &&
 	    !pci_has_flag(PCI_SCAN_ALL_PCIE_DEVS))
 		return 1;
 	return 0;

commit d0751b98dfa391f862e02dc36a233a54615e3f1d
Author: Yijing Wang <wangyijing@huawei.com>
Date:   Thu May 21 15:05:02 2015 +0800

    PCI: Add dev->has_secondary_link to track downstream PCIe links
    
    A PCIe Port is an interface to a Link.  A Root Port is a PCI-PCI bridge in
    a Root Complex and has a Link on its secondary (downstream) side.  For
    other Ports, the Link may be on either the upstream (closer to the Root
    Complex) or downstream side of the Port.
    
    The usual topology has a Root Port connected to an Upstream Port.  We
    previously assumed this was the only possible topology, and that a
    Downstream Port's Link was always on its downstream side, like this:
    
                      +---------------------+
      +------+        |          Downstream |
      | Root |        | Upstream       Port +--Link--
      | Port +--Link--+ Port                |
      +------+        |          Downstream |
                      |                Port +--Link--
                      +---------------------+
    
    But systems do exist (see URL below) where the Root Port is connected to a
    Downstream Port.  In this case, a Downstream Port's Link may be on either
    the upstream or downstream side:
    
                      +---------------------+
      +------+        |            Upstream |
      | Root |        | Downstream     Port +--Link--
      | Port +--Link--+ Port                |
      +------+        |          Downstream |
                      |                Port +--Link--
                      +---------------------+
    
    We can't use the Port type to determine which side the Link is on, so add a
    bit in struct pci_dev to keep track.
    
    A Root Port's Link is always on the Port's secondary side.  A component
    (Endpoint or Port) on the other end of the Link obviously has the Link on
    its upstream side.  If that component is a Port, it is part of a Switch or
    a Bridge.  A Bridge has a PCI or PCI-X bus on its secondary side, not a
    Link.  The internal bus of a Switch connects the Port to another Port whose
    Link is on the downstream side.
    
    [bhelgaas: changelog, comment, cache "type", use if/else]
    Link: http://lkml.kernel.org/r/54EB81B2.4050904@pobox.com
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=94361
    Suggested-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 6675a7a1b9fc..96dcd7b8303b 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -973,6 +973,8 @@ void set_pcie_port_type(struct pci_dev *pdev)
 {
 	int pos;
 	u16 reg16;
+	int type;
+	struct pci_dev *parent;
 
 	pos = pci_find_capability(pdev, PCI_CAP_ID_EXP);
 	if (!pos)
@@ -982,6 +984,22 @@ void set_pcie_port_type(struct pci_dev *pdev)
 	pdev->pcie_flags_reg = reg16;
 	pci_read_config_word(pdev, pos + PCI_EXP_DEVCAP, &reg16);
 	pdev->pcie_mpss = reg16 & PCI_EXP_DEVCAP_PAYLOAD;
+
+	/*
+	 * A Root Port is always the upstream end of a Link.  No PCIe
+	 * component has two Links.  Two Links are connected by a Switch
+	 * that has a Port on each Link and internal logic to connect the
+	 * two Ports.
+	 */
+	type = pci_pcie_type(pdev);
+	if (type == PCI_EXP_TYPE_ROOT_PORT)
+		pdev->has_secondary_link = 1;
+	else if (type == PCI_EXP_TYPE_UPSTREAM ||
+		 type == PCI_EXP_TYPE_DOWNSTREAM) {
+		parent = pci_upstream_bridge(pdev);
+		if (!parent->has_secondary_link)
+			pdev->has_secondary_link = 1;
+	}
 }
 
 void set_pcie_hotplug_bridge(struct pci_dev *pdev)

commit 1851617cd2da9cc53cdc1738f4148f4f042c0e56
Author: Michael S. Tsirkin <mst@redhat.com>
Date:   Thu May 7 09:52:21 2015 -0500

    PCI/MSI: Disable MSI at enumeration even if kernel doesn't support MSI
    
    If we enable MSI, then kexec a new kernel, the new kernel may receive MSIs
    it is not prepared for.  Commit d5dea7d95c48 ("PCI: msi: Disable msi
    interrupts when we initialize a pci device") prevents this, but only if the
    new kernel is built with CONFIG_PCI_MSI=y.
    
    Move the "disable MSI" functionality from drivers/pci/msi.c to a new
    pci_msi_setup_pci_dev() in drivers/pci/probe.c so we can disable MSIs when
    we enumerate devices even if the kernel doesn't include full MSI support.
    
    [bhelgaas: changelog, disable MSIs in pci_setup_device(), put
    pci_msi_setup_pci_dev() at its final destination]
    Signed-off-by: Michael S. Tsirkin <mst@redhat.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 6675a7a1b9fc..a9c5e63049a5 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1085,6 +1085,22 @@ int pci_cfg_space_size(struct pci_dev *dev)
 
 #define LEGACY_IO_RESOURCE	(IORESOURCE_IO | IORESOURCE_PCI_FIXED)
 
+static void pci_msi_setup_pci_dev(struct pci_dev *dev)
+{
+	/*
+	 * Disable the MSI hardware to avoid screaming interrupts
+	 * during boot.  This is the power on reset default so
+	 * usually this should be a noop.
+	 */
+	dev->msi_cap = pci_find_capability(dev, PCI_CAP_ID_MSI);
+	if (dev->msi_cap)
+		pci_msi_set_enable(dev, 0);
+
+	dev->msix_cap = pci_find_capability(dev, PCI_CAP_ID_MSIX);
+	if (dev->msix_cap)
+		pci_msix_clear_and_set_ctrl(dev, PCI_MSIX_FLAGS_ENABLE, 0);
+}
+
 /**
  * pci_setup_device - fill in class and map information of a device
  * @dev: the device structure to fill
@@ -1140,6 +1156,8 @@ int pci_setup_device(struct pci_dev *dev)
 	/* "Unknown power state" */
 	dev->current_state = PCI_UNKNOWN;
 
+	pci_msi_setup_pci_dev(dev);
+
 	/* Early fixups, before probing the BARs */
 	pci_fixup_device(pci_fixup_early, dev);
 	/* device class may be changed after fixup */

commit 4dd1f57956ada782fd80b1c11c30a9595d6caafc
Merge: 8e795840e4d8 01d06a9a4c28 1fb37a8178da f76ea574d615 e3dc17a53f96 ab14d45ea58e 7a27db23a3f6 873581698d39
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Apr 10 08:26:54 2015 -0500

    Merge branches 'pci/host-exynos', 'pci/host-iproc', 'pci/host-keystone', 'pci/host-layerscape', 'pci/host-mvebu', 'pci/host-rcar' and 'pci/host-versatile' into next
    
    * pci/host-exynos:
      PCI: exynos: Fix INTx enablement statement termination error
    
    * pci/host-iproc:
      PCI: iproc: Add Broadcom iProc PCIe support
      PCI: iproc: Add DT docs for Broadcom iProc PCIe driver
      PCI: Export symbols required for loadable host driver modules
    
    * pci/host-keystone:
      PCI: keystone: Don't dereference possible NULL pointer
    
    * pci/host-layerscape:
      PCI: layerscape: Simplify platform_get_resource_byname() failure checking
    
    * pci/host-mvebu:
      PCI: mvebu: Add suspend/resume support
    
    * pci/host-rcar:
      PCI: rcar: Verify that mem_res is 64K-aligned
      PCI: rcar: Change PCIEPARL and PCIEPARH to PCIEPALR and PCIEPAUR
      PCI: rcar: Write zeroes to reserved PCIEPARL bits
      PCI: rcar: Fix position of MSI enable bit
    
    * pci/host-versatile:
      PCI: versatile: Check for devm_ioremap_resource() failures

commit e6b29deafad3ce020dcf873a27a95c0cb9966c5b
Author: Ray Jui <rjui@broadcom.com>
Date:   Wed Apr 8 11:21:33 2015 -0700

    PCI: Export symbols required for loadable host driver modules
    
    Export the following symbols so they can be referenced by a PCI host bridge
    driver compiled as a kernel loadable module:
    
      pci_common_swizzle
      pci_create_root_bus
      pci_stop_root_bus
      pci_remove_root_bus
      pci_assign_unassigned_bus_resources
      pci_fixup_irqs
    
    Signed-off-by: Ray Jui <rjui@broadcom.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 8d2f400e96cb..f13a78af909e 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1993,6 +1993,7 @@ struct pci_bus *pci_create_root_bus(struct device *parent, int bus,
 	kfree(b);
 	return NULL;
 }
+EXPORT_SYMBOL_GPL(pci_create_root_bus);
 
 int pci_bus_insert_busn_res(struct pci_bus *b, int bus, int bus_max)
 {

commit 8e795840e4d89df3d594e736989212ee8a4a1fca
Merge: 85e8a0af3740 9e808eb6a768 d748804f5be8
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Mar 23 17:17:34 2015 -0500

    Merge branches 'pci/enumeration' and 'pci/virtualization' into next
    
    * pci/enumeration:
      PCI: Cleanup control flow
      sparc/PCI: Claim bus resources before pci_bus_add_devices()
      PCI: Assign resources before drivers claim devices (pci_scan_root_bus())
      PCI: Assign resources before drivers claim devices (pci_scan_bus())
    
    * pci/virtualization:
      PCI: Add ACS quirks for Intel 1G NICs

commit b97ea289cf6aff8d4cbcefe2b707bb9b00a73c73
Author: Yijing Wang <wangyijing@huawei.com>
Date:   Mon Mar 16 11:18:56 2015 +0800

    PCI: Assign resources before drivers claim devices (pci_scan_root_bus())
    
    Previously, pci_scan_root_bus() created a root PCI bus, enumerated the
    devices on it, and called pci_bus_add_devices(), which made the devices
    available for drivers to claim them.
    
    Most callers assigned resources to devices after pci_scan_root_bus()
    returns, which may be after drivers have claimed the devices.  This is
    incorrect; the PCI core should not change device resources while a driver
    is managing the device.
    
    Remove pci_bus_add_devices() from pci_scan_root_bus() and do it after any
    resource assignment in the callers.
    
    Note that ARM's pci_common_init_dev() already called pci_bus_add_devices()
    after pci_scan_root_bus(), so we only need to remove the first call:
    
      pci_common_init_dev
        pcibios_init_hw
          pci_scan_root_bus
            pci_bus_add_devices        # first call
        pci_bus_assign_resources
        pci_bus_add_devices            # second call
    
    [bhelgaas: changelog, drop "root_bus" var in alpha common_init_pci(),
    return failure earlier in mn10300, add "return" in x86 pcibios_scan_root(),
    return early if xtensa platform_pcibios_fixup() fails]
    Signed-off-by: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    CC: Richard Henderson <rth@twiddle.net>
    CC: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
    CC: Matt Turner <mattst88@gmail.com>
    CC: David Howells <dhowells@redhat.com>
    CC: Tony Luck <tony.luck@intel.com>
    CC: Michal Simek <monstr@monstr.eu>
    CC: Ralf Baechle <ralf@linux-mips.org>
    CC: Koichi Yasutake <yasutake.koichi@jp.panasonic.com>
    CC: Sebastian Ott <sebott@linux.vnet.ibm.com>
    CC: "David S. Miller" <davem@davemloft.net>
    CC: Chris Metcalf <cmetcalf@ezchip.com>
    CC: Chris Zankel <chris@zankel.net>
    CC: Max Filippov <jcmvbkbc@gmail.com>
    CC: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 88604f29d140..8ef0375ea314 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -2087,7 +2087,6 @@ struct pci_bus *pci_scan_root_bus(struct device *parent, int bus,
 	if (!found)
 		pci_bus_update_busn_res_end(b, max);
 
-	pci_bus_add_devices(b);
 	return b;
 }
 EXPORT_SYMBOL(pci_scan_root_bus);

commit c90570d9511d42421c85709b46bffd366185d835
Author: Yijing Wang <wangyijing@huawei.com>
Date:   Mon Mar 9 10:33:58 2015 +0800

    PCI: Assign resources before drivers claim devices (pci_scan_bus())
    
    Previously, pci_scan_bus() created a root PCI bus, enumerated the devices
    on it, and called pci_bus_add_devices(), which made the devices available
    for drivers to claim them.
    
    Most callers assigned resources to devices after pci_scan_bus() returns,
    which may be after drivers have claimed the devices.  This is incorrect;
    the PCI core should not change device resources while a driver is managing
    the device.
    
    Remove pci_bus_add_devices() from pci_scan_bus() and do it after any
    resource assignment in the callers.
    
    [bhelgaas: changelog, check for failure in mcf_pci_init()]
    Signed-off-by: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    CC: "David S. Miller" <davem@davemloft.net>
    CC: Geert Uytterhoeven <geert@linux-m68k.org>
    CC: Guan Xuetao <gxt@mprc.pku.edu.cn>
    CC: Richard Henderson <rth@twiddle.net>
    CC: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
    CC: Matt Turner <mattst88@gmail.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 8d2f400e96cb..88604f29d140 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -2123,7 +2123,6 @@ struct pci_bus *pci_scan_bus(int bus, struct pci_ops *ops,
 	b = pci_create_root_bus(NULL, bus, ops, sysdata, &resources);
 	if (b) {
 		pci_scan_child_bus(b);
-		pci_bus_add_devices(b);
 	} else {
 		pci_free_resource_list(&resources);
 	}

commit de335bb49269037d1e8906ba59f8bacba732bec6
Author: Murali Karicheri <m-karicheri2@ti.com>
Date:   Tue Mar 3 12:52:13 2015 -0500

    PCI: Update DMA configuration from DT
    
    If there is a DT node available for the root bridge's parent device, use
    the DMA configuration from that device node.  For example, Keystone PCI
    devices would require dma_pfn_offset to be set correctly in the device
    structure of the PCI device in order to have the correct DMA mask.  The DT
    node will have dma-ranges defined for this.  Also support using the DT
    property dma-coherent to allow coherent DMA operation by the PCI device.
    
    Use the new helper function of_pci_dma_configure() to update the device DMA
    configuration.  This fixes DMA on systems where DMA addresses are a
    constant offset from CPU physical addresses.
    
    Tested-by: Suravee Suthikulpanit <Suravee.Suthikulpanit@amd.com> (AMD Seattle)
    Signed-off-by: Murali Karicheri <m-karicheri2@ti.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Catalin Marinas <catalin.marinas@arm.com>
    Acked-by: Will Deacon <will.deacon@arm.com>
    CC: Joerg Roedel <joro@8bytes.org>
    CC: Grant Likely <grant.likely@linaro.org>
    CC: Rob Herring <robh+dt@kernel.org>
    CC: Russell King <linux@arm.linux.org.uk>
    CC: Arnd Bergmann <arnd@arndb.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 8d2f400e96cb..413c1dd431b9 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -6,6 +6,7 @@
 #include <linux/delay.h>
 #include <linux/init.h>
 #include <linux/pci.h>
+#include <linux/of_pci.h>
 #include <linux/pci_hotplug.h>
 #include <linux/slab.h>
 #include <linux/module.h>
@@ -1520,6 +1521,7 @@ void pci_device_add(struct pci_dev *dev, struct pci_bus *bus)
 	dev->dev.dma_mask = &dev->dma_mask;
 	dev->dev.dma_parms = &dev->dma_parms;
 	dev->dev.coherent_dma_mask = 0xffffffffull;
+	of_pci_dma_configure(dev);
 
 	pci_set_dma_max_seg_size(dev, 65536);
 	pci_set_dma_seg_boundary(dev, 0xffffffff);

commit 14d76b68f2819a1d0b50236a7e9e9f2ea69869d9
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Thu Feb 5 13:44:44 2015 +0800

    PCI: Use common resource list management code instead of private implementation
    
    Use common resource list management data structure and interfaces
    instead of private implementation.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 23212f8ae09b..8d2f400e96cb 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1895,7 +1895,7 @@ struct pci_bus *pci_create_root_bus(struct device *parent, int bus,
 	int error;
 	struct pci_host_bridge *bridge;
 	struct pci_bus *b, *b2;
-	struct pci_host_bridge_window *window, *n;
+	struct resource_entry *window, *n;
 	struct resource *res;
 	resource_size_t offset;
 	char bus_addr[64];
@@ -1959,8 +1959,8 @@ struct pci_bus *pci_create_root_bus(struct device *parent, int bus,
 		printk(KERN_INFO "PCI host bridge to bus %s\n", dev_name(&b->dev));
 
 	/* Add initial resources to the bus */
-	list_for_each_entry_safe(window, n, resources, list) {
-		list_move_tail(&window->list, &bridge->windows);
+	resource_list_for_each_entry_safe(window, n, resources) {
+		list_move_tail(&window->node, &bridge->windows);
 		res = window->res;
 		offset = window->offset;
 		if (res->flags & IORESOURCE_BUS)
@@ -2060,12 +2060,12 @@ void pci_bus_release_busn_res(struct pci_bus *b)
 struct pci_bus *pci_scan_root_bus(struct device *parent, int bus,
 		struct pci_ops *ops, void *sysdata, struct list_head *resources)
 {
-	struct pci_host_bridge_window *window;
+	struct resource_entry *window;
 	bool found = false;
 	struct pci_bus *b;
 	int max;
 
-	list_for_each_entry(window, resources, list)
+	resource_list_for_each_entry(window, resources)
 		if (window->res->flags & IORESOURCE_BUS) {
 			found = true;
 			break;

commit c75059c46293adf1560162c17148ab94624f5ed2
Merge: f74ea36848ad 149792795d2b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Dec 10 20:58:52 2014 -0800

    Merge tag 'pci-v3.19-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI changes from Bjorn Helgaas:
     "Here are the PCI changes intended for v3.19.  I don't think there's
      anything very exciting here, but there was a lot of MSI-related stuff
      coming via Thomas.
    
      Details:
    
      NUMA
        - Allow numa_node override via sysfs (Prarit Bhargava)
    
      Resource management
        - Restore detection of read-only BARs (Myron Stowe)
        - Shrink decoding-disabled window while sizing BARs (Myron Stowe)
        - Add informational printk for invalid BARs (Myron Stowe)
        - Remove fixed parameter in pci_iov_resource_bar() (Myron Stowe)
    
      MSI
        - Add pci_msi_ignore_mask to prevent writes to MSI/MSI-X Mask Bits (Yijing Wang)
        - Revert "PCI: Add x86_msi.msi_mask_irq() and msix_mask_irq()" (Yijing Wang)
        - s390/MSI: Use __msi_mask_irq() instead of default_msi_mask_irq() (Yijing Wang)
    
      Virtualization
        - xen: Process failure for pcifront_(re)scan_root() (Chen Gang)
        - Make FLR and AF FLR reset warning messages different (Gavin Shan)
    
      Generic host bridge driver
        - Allocate config space windows after limiting bus number range (Lorenzo Pieralisi)
        - Convert to DT resource parsing API (Lorenzo Pieralisi)
    
      Freescale Layerscape
        - Add Freescale Layerscape PCIe driver (Minghuan Lian)
    
      NVIDIA Tegra
        - Do not build on 64-bit ARM (Thierry Reding)
        - Add Kconfig help text (Thierry Reding)
    
      Renesas R-Car
        - Make rcar_pci static (Jingoo Han)
    
      Samsung Exynos
        - Add exynos prefix to add_pcie_port(), pcie_init() (Jingoo Han)
    
      ST Microelectronics SPEAr13xx
        - Add spear prefix to add_pcie_port(), pcie_init() (Jingoo Han)
        - Make spear13xx_add_pcie_port() __init (Jingoo Han)
        - Remove unnecessary OOM message (Jingoo Han)
    
      TI DRA7xx
        - Add dra7xx prefix to add_pcie_port() (Jingoo Han)
        - Make dra7xx_add_pcie_port() __init (Jingoo Han)
    
      TI Keystone
        - Make ks_dw_pcie_msi_domain_ops static (Jingoo Han)
        - Remove unnecessary OOM message (Jingoo Han)
    
      Miscellaneous
        - Delete unnecessary NULL pointer checks (Markus Elfring)
        - Remove unused to_hotplug_slot() (Gavin Shan)
        - Whitespace cleanup (Jingoo Han)
        - Simplify if-return sequences (Quentin Lambert)"
    
    * tag 'pci-v3.19-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (28 commits)
      PCI: Remove fixed parameter in pci_iov_resource_bar()
      PCI: Add informational printk for invalid BARs
      PCI: tegra: Add Kconfig help text
      PCI: tegra: Do not build on 64-bit ARM
      PCI: spear: Remove unnecessary OOM message
      PCI: mvebu: Add a blank line after declarations
      PCI: designware: Add a blank line after declarations
      PCI: exynos: Remove unnecessary return statement
      PCI: imx6: Use tabs for indentation
      PCI: keystone: Remove unnecessary OOM message
      PCI: Remove unused and broken to_hotplug_slot()
      PCI: Make FLR and AF FLR reset warning messages different
      PCI: dra7xx: Add __init annotation to dra7xx_add_pcie_port()
      PCI: spear: Add __init annotation to spear13xx_add_pcie_port()
      PCI: spear: Rename add_pcie_port(), pcie_init() to spear13xx_add_pcie_port(), etc.
      PCI: dra7xx: Rename add_pcie_port() to dra7xx_add_pcie_port()
      PCI: layerscape: Add Freescale Layerscape PCIe driver
      PCI: Simplify if-return sequences
      PCI: Delete unnecessary NULL pointer checks
      PCI: Shrink decoding-disabled window while sizing BARs
      ...

commit 18e88beceb1838cfa7cc1a9abf16f5b419e11fdd
Merge: 35437e3d9b41 26ff46c6f23b a4acded086c4 bb383e283b2c 63692df103e9 23cf1d006f1a
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Nov 19 15:10:33 2014 -0700

    Merge branches 'pci/enumeration', 'pci/hotplug', 'pci/misc', 'pci/numa' and 'pci/virtualization' into next
    
    * pci/enumeration:
      PCI: Remove fixed parameter in pci_iov_resource_bar()
      PCI: Add informational printk for invalid BARs
      PCI: Shrink decoding-disabled window while sizing BARs
      PCI: Restore detection of read-only BARs
    
    * pci/hotplug:
      PCI: Remove unused and broken to_hotplug_slot()
    
    * pci/misc:
      PCI: Make FLR and AF FLR reset warning messages different
      PCI: Simplify if-return sequences
      PCI: Delete unnecessary NULL pointer checks
    
    * pci/numa:
      PCI: Allow numa_node override via sysfs
    
    * pci/virtualization:
      xen/pcifront: Process failure for pcifront_(re)scan_root()

commit 7e79c5f8cad2ac1dc26c03e1aa16216391a04dad
Author: Myron Stowe <myron.stowe@redhat.com>
Date:   Thu Oct 30 11:54:50 2014 -0600

    PCI: Add informational printk for invalid BARs
    
    As a consequence of restoring the detection of invalid BARs, add a new
    informational printk like the following when such occurrences are
    encountered.
    
      pci ssss:bb:dd.f: [Firmware Bug]: reg 0xXX: invalid BAR (can't size)
    
    Reported-by: William Unruh <unruh@physics.ubc.ca>
    Reported-by: Martin Lucina <martin@lucina.net>
    Signed-off-by: Myron Stowe <myron.stowe@redhat.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    CC: Matthew Wilcox <willy@linux.intel.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 529fcd782e43..6029ad786146 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -247,8 +247,11 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 		goto fail;
 
 	sz64 = pci_size(l64, sz64, mask64);
-	if (!sz64)
+	if (!sz64) {
+		dev_info(&dev->dev, FW_BUG "reg 0x%x: invalid BAR (can't size)\n",
+			 pos);
 		goto fail;
+	}
 
 	if (res->flags & IORESOURCE_MEM_64) {
 		if ((sizeof(dma_addr_t) < 8 || sizeof(resource_size_t) < 8) &&

commit 7fc986d8a9727e5d40da3c2c1c343da6142e82a9
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Wed Nov 19 14:30:32 2014 -0700

    PCI: Support 64-bit bridge windows if we have 64-bit dma_addr_t
    
    Aaron reported that a 32-bit x86 kernel with Physical Address Extension
    (PAE) support complains about bridge prefetchable memory windows above 4GB:
    
      pci_bus 0000:00: root bus resource [mem 0x380000000000-0x383fffffffff]
      ...
      pci 0000:03:00.0: reg 0x10: [mem 0x383fffc00000-0x383fffdfffff 64bit pref]
      pci 0000:03:00.0: reg 0x20: [mem 0x383fffe04000-0x383fffe07fff 64bit pref]
      pci 0000:03:00.1: reg 0x10: [mem 0x383fffa00000-0x383fffbfffff 64bit pref]
      pci 0000:03:00.1: reg 0x20: [mem 0x383fffe00000-0x383fffe03fff 64bit pref]
      pci 0000:00:02.2: PCI bridge to [bus 03-04]
      pci 0000:00:02.2:   bridge window [io  0x1000-0x1fff]
      pci 0000:00:02.2:   bridge window [mem 0x91900000-0x91cfffff]
      pci 0000:00:02.2: can't handle 64-bit address space for bridge
    
    In this kernel, unsigned long is 32 bits and dma_addr_t is 64 bits.
    Previously we used "unsigned long" to hold the bridge window address.  But
    this is a bus address, so we should use dma_addr_t instead.
    
    Use dma_addr_t to hold the bridge window base and limit.
    
    The question of whether the CPU can actually *address* the window is
    separate and depends on what the physical address space of the CPU is and
    whether the host bridge does any address translation.
    
    [bhelgaas: fix "shift count > width of type", changelog, stable tag]
    Fixes: d56dbf5bab8c ("PCI: Allocate 64-bit BARs above 4G when possible")
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=88131
    Reported-by: Aaron Ma <mapengyu@gmail.com>
    Tested-by: Aaron Ma <mapengyu@gmail.com>
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    CC: stable@vger.kernel.org      # v3.14+

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 6244b1834dfe..c8ca98c2b480 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -407,15 +407,16 @@ static void pci_read_bridge_mmio_pref(struct pci_bus *child)
 {
 	struct pci_dev *dev = child->self;
 	u16 mem_base_lo, mem_limit_lo;
-	unsigned long base, limit;
+	u64 base64, limit64;
+	dma_addr_t base, limit;
 	struct pci_bus_region region;
 	struct resource *res;
 
 	res = child->resource[2];
 	pci_read_config_word(dev, PCI_PREF_MEMORY_BASE, &mem_base_lo);
 	pci_read_config_word(dev, PCI_PREF_MEMORY_LIMIT, &mem_limit_lo);
-	base = ((unsigned long) mem_base_lo & PCI_PREF_RANGE_MASK) << 16;
-	limit = ((unsigned long) mem_limit_lo & PCI_PREF_RANGE_MASK) << 16;
+	base64 = (mem_base_lo & PCI_PREF_RANGE_MASK) << 16;
+	limit64 = (mem_limit_lo & PCI_PREF_RANGE_MASK) << 16;
 
 	if ((mem_base_lo & PCI_PREF_RANGE_TYPE_MASK) == PCI_PREF_RANGE_TYPE_64) {
 		u32 mem_base_hi, mem_limit_hi;
@@ -429,17 +430,20 @@ static void pci_read_bridge_mmio_pref(struct pci_bus *child)
 		 * this, just assume they are not being used.
 		 */
 		if (mem_base_hi <= mem_limit_hi) {
-#if BITS_PER_LONG == 64
-			base |= ((unsigned long) mem_base_hi) << 32;
-			limit |= ((unsigned long) mem_limit_hi) << 32;
-#else
-			if (mem_base_hi || mem_limit_hi) {
-				dev_err(&dev->dev, "can't handle 64-bit address space for bridge\n");
-				return;
-			}
-#endif
+			base64 |= (u64) mem_base_hi << 32;
+			limit64 |= (u64) mem_limit_hi << 32;
 		}
 	}
+
+	base = (dma_addr_t) base64;
+	limit = (dma_addr_t) limit64;
+
+	if (base != base64) {
+		dev_err(&dev->dev, "can't handle bridge window above 4GB (bus address %#010llx)\n",
+			(unsigned long long) base64);
+		return;
+	}
+
 	if (base <= limit) {
 		res->flags = (mem_base_lo & PCI_PREF_RANGE_TYPE_MASK) |
 					 IORESOURCE_MEM | IORESOURCE_PREFETCH;

commit 7a1562d4f2d01721ad07c3a326db7512077ceea9
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Tue Nov 11 12:09:46 2014 -0800

    PCI: Apply _HPX Link Control settings to all devices with a link
    
    Previously we applied _HPX type 2 record Link Control register settings
    only to bridges with a subordinate bus.  But it's better to apply them to
    all devices with a link because if the subordinate bus has not been
    allocated yet, we won't apply settings to the device.
    
    Use pcie_cap_has_lnkctl() to determine whether the device has a Link
    Control register instead of looking at dev->subordinate.
    
    [bhelgaas: changelog]
    Fixes: 6cd33649fa83 ("PCI: Add pci_configure_device() during enumeration")
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 5ed99309c758..6244b1834dfe 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1323,7 +1323,7 @@ static void program_hpp_type2(struct pci_dev *dev, struct hpp_type2 *hpp)
 			~hpp->pci_exp_devctl_and, hpp->pci_exp_devctl_or);
 
 	/* Initialize Link Control Register */
-	if (dev->subordinate)
+	if (pcie_cap_has_lnkctl(dev))
 		pcie_capability_clear_and_set_word(dev, PCI_EXP_LNKCTL,
 			~hpp->pci_exp_lnkctl_and, hpp->pci_exp_lnkctl_or);
 

commit ff0387c3777f2438bad2088abe442c9f231b0be4
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Mon Nov 10 21:02:17 2014 -0700

    PCI: Delete unnecessary NULL pointer checks
    
    The functions pci_dev_put(), pci_pme_wakeup_bus(), and put_device() return
    immediately if their argument is NULL.  Thus the test before the call is
    not needed.
    
    Remove these unnecessary tests.
    
    This issue was detected by using the Coccinelle software.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 5ed99309c758..eb927c04e290 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -87,8 +87,7 @@ static void release_pcibus_dev(struct device *dev)
 {
 	struct pci_bus *pci_bus = to_pci_bus(dev);
 
-	if (pci_bus->bridge)
-		put_device(pci_bus->bridge);
+	put_device(pci_bus->bridge);
 	pci_bus_remove_resources(pci_bus);
 	pci_release_bus_of_node(pci_bus);
 	kfree(pci_bus);

commit f795d86aaa578501551a2d1b463eac4bbea84db2
Author: Myron Stowe <myron.stowe@redhat.com>
Date:   Thu Oct 30 11:54:43 2014 -0600

    PCI: Shrink decoding-disabled window while sizing BARs
    
    __pci_read_base() disables decoding while sizing device BARs.  We can't
    print while decoding is disabled, which leads to some rather messy exit
    logic.
    
    Coalesce the sizing logic to minimize the time decoding is disabled.  This
    lets us print errors where they're detected.
    
    The refactoring also takes advantage of the symmetry of obtaining the BAR's
    extent (pci_size) and storing the result as the 'region' for both the
    32-bit and 64-bit BARs, consolidating both cases.
    
    No functional change intended.
    
    [bhelgaas: move pci_size() up, per Thomas Petazzoni, Thierry Reding, Kevin Hilman]
    Signed-off-by: Myron Stowe <myron.stowe@redhat.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    CC: Matthew Wilcox <willy@linux.intel.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 19dc247618f8..529fcd782e43 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -175,7 +175,6 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 	u64 l64, sz64, mask64;
 	u16 orig_cmd;
 	struct pci_bus_region region, inverted_region;
-	bool bar_too_big = false, bar_too_high = false, bar_invalid = false;
 
 	mask = type ? PCI_ROM_ADDRESS_MASK : ~0;
 
@@ -201,8 +200,8 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 	 * memory BAR or a ROM, bit 0 must be clear; if it's an io BAR, bit
 	 * 1 must be clear.
 	 */
-	if (!sz || sz == 0xffffffff)
-		goto fail;
+	if (sz == 0xffffffff)
+		sz = 0;
 
 	/*
 	 * I don't know how l can have all bits set.  Copied from old code.
@@ -215,26 +214,22 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 		res->flags = decode_bar(dev, l);
 		res->flags |= IORESOURCE_SIZEALIGN;
 		if (res->flags & IORESOURCE_IO) {
-			l &= PCI_BASE_ADDRESS_IO_MASK;
-			sz &= PCI_BASE_ADDRESS_IO_MASK;
-			mask = PCI_BASE_ADDRESS_IO_MASK & (u32) IO_SPACE_LIMIT;
+			l64 = l & PCI_BASE_ADDRESS_IO_MASK;
+			sz64 = sz & PCI_BASE_ADDRESS_IO_MASK;
+			mask64 = PCI_BASE_ADDRESS_IO_MASK & (u32)IO_SPACE_LIMIT;
 		} else {
-			l &= PCI_BASE_ADDRESS_MEM_MASK;
-			sz &= PCI_BASE_ADDRESS_MEM_MASK;
-			mask = (u32)PCI_BASE_ADDRESS_MEM_MASK;
+			l64 = l & PCI_BASE_ADDRESS_MEM_MASK;
+			sz64 = sz & PCI_BASE_ADDRESS_MEM_MASK;
+			mask64 = (u32)PCI_BASE_ADDRESS_MEM_MASK;
 		}
 	} else {
 		res->flags |= (l & IORESOURCE_ROM_ENABLE);
-		l &= PCI_ROM_ADDRESS_MASK;
-		sz &= PCI_ROM_ADDRESS_MASK;
-		mask = (u32)PCI_ROM_ADDRESS_MASK;
+		l64 = l & PCI_ROM_ADDRESS_MASK;
+		sz64 = sz & PCI_ROM_ADDRESS_MASK;
+		mask64 = (u32)PCI_ROM_ADDRESS_MASK;
 	}
 
 	if (res->flags & IORESOURCE_MEM_64) {
-		l64 = l;
-		sz64 = sz;
-		mask64 = mask | (u64)~0 << 32;
-
 		pci_read_config_dword(dev, pos + 4, &l);
 		pci_write_config_dword(dev, pos + 4, ~0);
 		pci_read_config_dword(dev, pos + 4, &sz);
@@ -242,18 +237,27 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 
 		l64 |= ((u64)l << 32);
 		sz64 |= ((u64)sz << 32);
+		mask64 |= ((u64)~0 << 32);
+	}
 
-		sz64 = pci_size(l64, sz64, mask64);
+	if (!dev->mmio_always_on && (orig_cmd & PCI_COMMAND_DECODE_ENABLE))
+		pci_write_config_word(dev, PCI_COMMAND, orig_cmd);
 
-		if (!sz64)
-			goto fail;
+	if (!sz64)
+		goto fail;
+
+	sz64 = pci_size(l64, sz64, mask64);
+	if (!sz64)
+		goto fail;
 
+	if (res->flags & IORESOURCE_MEM_64) {
 		if ((sizeof(dma_addr_t) < 8 || sizeof(resource_size_t) < 8) &&
 		    sz64 > 0x100000000ULL) {
 			res->flags |= IORESOURCE_UNSET | IORESOURCE_DISABLED;
 			res->start = 0;
 			res->end = 0;
-			bar_too_big = true;
+			dev_err(&dev->dev, "reg 0x%x: can't handle BAR larger than 4GB (size %#010llx)\n",
+				pos, (unsigned long long)sz64);
 			goto out;
 		}
 
@@ -262,22 +266,15 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 			res->flags |= IORESOURCE_UNSET;
 			res->start = 0;
 			res->end = sz64;
-			bar_too_high = true;
+			dev_info(&dev->dev, "reg 0x%x: can't handle BAR above 4GB (bus address %#010llx)\n",
+				 pos, (unsigned long long)l64);
 			goto out;
-		} else {
-			region.start = l64;
-			region.end = l64 + sz64;
 		}
-	} else {
-		sz = pci_size(l, sz, mask);
-
-		if (!sz)
-			goto fail;
-
-		region.start = l;
-		region.end = l + sz;
 	}
 
+	region.start = l64;
+	region.end = l64 + sz64;
+
 	pcibios_bus_to_resource(dev->bus, res, &region);
 	pcibios_resource_to_bus(dev->bus, &inverted_region, res);
 
@@ -296,7 +293,8 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 		res->flags |= IORESOURCE_UNSET;
 		res->start = 0;
 		res->end = region.end - region.start;
-		bar_invalid = true;
+		dev_info(&dev->dev, "reg 0x%x: initial BAR value %#010llx invalid\n",
+			 pos, (unsigned long long)region.start);
 	}
 
 	goto out;
@@ -305,19 +303,6 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 fail:
 	res->flags = 0;
 out:
-	if (!dev->mmio_always_on &&
-	    (orig_cmd & PCI_COMMAND_DECODE_ENABLE))
-		pci_write_config_word(dev, PCI_COMMAND, orig_cmd);
-
-	if (bar_too_big)
-		dev_err(&dev->dev, "reg 0x%x: can't handle BAR larger than 4GB (size %#010llx)\n",
-			pos, (unsigned long long) sz64);
-	if (bar_too_high)
-		dev_info(&dev->dev, "reg 0x%x: can't handle BAR above 4G (bus address %#010llx)\n",
-			 pos, (unsigned long long) l64);
-	if (bar_invalid)
-		dev_info(&dev->dev, "reg 0x%x: initial BAR value %#010llx invalid\n",
-			 pos, (unsigned long long) region.start);
 	if (res->flags)
 		dev_printk(KERN_DEBUG, &dev->dev, "reg 0x%x: %pR\n", pos, res);
 

commit 36e8164882ca6d3c41cb91e6f09a3ed236841f80
Author: Myron Stowe <myron.stowe@redhat.com>
Date:   Thu Oct 30 11:54:37 2014 -0600

    PCI: Restore detection of read-only BARs
    
    Commit 6ac665c63dca ("PCI: rewrite PCI BAR reading code") masked off
    low-order bits from 'l', but not from 'sz'.  Both are passed to pci_size(),
    which compares 'base == maxbase' to check for read-only BARs.  The masking
    of 'l' means that comparison will never be 'true', so the check for
    read-only BARs no longer works.
    
    Resolve this by also masking off the low-order bits of 'sz' before passing
    it into pci_size() as 'maxbase'.  With this change, pci_size() will once
    again catch the problems that have been encountered to date:
    
      - AGP aperture BAR of AMD-7xx host bridges: if the AGP window is
        disabled, this BAR is read-only and read as 0x00000008 [1]
    
      - BARs 0-4 of ALi IDE controllers can be non-zero and read-only [1]
    
      - Intel Sandy Bridge - Thermal Management Controller [8086:0103];
        BAR 0 returning 0xfed98004 [2]
    
      - Intel Xeon E5 v3/Core i7 Power Control Unit [8086:2fc0];
        Bar 0 returning 0x00001a [3]
    
    Link: [1] https://git.kernel.org/cgit/linux/kernel/git/tglx/history.git/commit/drivers/pci/probe.c?id=1307ef6621991f1c4bc3cec1b5a4ebd6fd3d66b9 ("PCI: probing read-only BARs" (pre-git))
    Link: [2] https://bugzilla.kernel.org/show_bug.cgi?id=43331
    Link: [3] https://bugzilla.kernel.org/show_bug.cgi?id=85991
    Reported-by: William Unruh <unruh@physics.ubc.ca>
    Reported-by: Martin Lucina <martin@lucina.net>
    Signed-off-by: Myron Stowe <myron.stowe@redhat.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    CC: Matthew Wilcox <willy@linux.intel.com>
    CC: stable@vger.kernel.org      # v2.6.27+

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 5ed99309c758..19dc247618f8 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -216,14 +216,17 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 		res->flags |= IORESOURCE_SIZEALIGN;
 		if (res->flags & IORESOURCE_IO) {
 			l &= PCI_BASE_ADDRESS_IO_MASK;
+			sz &= PCI_BASE_ADDRESS_IO_MASK;
 			mask = PCI_BASE_ADDRESS_IO_MASK & (u32) IO_SPACE_LIMIT;
 		} else {
 			l &= PCI_BASE_ADDRESS_MEM_MASK;
+			sz &= PCI_BASE_ADDRESS_MEM_MASK;
 			mask = (u32)PCI_BASE_ADDRESS_MEM_MASK;
 		}
 	} else {
 		res->flags |= (l & IORESOURCE_ROM_ENABLE);
 		l &= PCI_ROM_ADDRESS_MASK;
+		sz &= PCI_ROM_ADDRESS_MASK;
 		mask = (u32)PCI_ROM_ADDRESS_MASK;
 	}
 

commit 80213c03c4151d900cf293ef0fc51f8d88495e14
Merge: ea584595fc85 f92d9ee3ab39
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Oct 9 15:03:49 2014 -0400

    Merge tag 'pci-v3.18-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI updates from Bjorn Helgaas:
     "The interesting things here are:
    
       - Turn on Config Request Retry Status Software Visibility.  This
         caused hangs last time, but we included a fix this time.
       - Rework PCI device configuration to use _HPP/_HPX more aggressively
       - Allow PCI devices to be put into D3cold during system suspend
       - Add arm64 PCI support
       - Add APM X-Gene host bridge driver
       - Add TI Keystone host bridge driver
       - Add Xilinx AXI host bridge driver
    
      More detailed summary:
    
      Enumeration
        - Check Vendor ID only for Config Request Retry Status (Rajat Jain)
        - Enable Config Request Retry Status when supported (Rajat Jain)
        - Add generic domain handling (Catalin Marinas)
        - Generate uppercase hex for modalias interface class (Ricardo Ribalda Delgado)
    
      Resource management
        - Add missing MEM_64 mask in pci_assign_unassigned_bridge_resources() (Yinghai Lu)
        - Increase IBM ipr SAS Crocodile BARs to at least system page size (Douglas Lehr)
    
      PCI device hotplug
        - Prevent NULL dereference during pciehp probe (Andreas Noever)
        - Move _HPP & _HPX handling into core (Bjorn Helgaas)
        - Apply _HPP to PCIe devices as well as PCI (Bjorn Helgaas)
        - Apply _HPP/_HPX to display devices (Bjorn Helgaas)
        - Preserve SERR & PARITY settings when applying _HPP/_HPX (Bjorn Helgaas)
        - Preserve MPS and MRRS settings when applying _HPP/_HPX (Bjorn Helgaas)
        - Apply _HPP/_HPX to all devices, not just hot-added ones (Bjorn Helgaas)
        - Fix wait time in pciehp timeout message (Yinghai Lu)
        - Add more pciehp Slot Control debug output (Yinghai Lu)
        - Stop disabling pciehp notifications during init (Yinghai Lu)
    
      MSI
        - Remove arch_msi_check_device() (Alexander Gordeev)
        - Rename pci_msi_check_device() to pci_msi_supported() (Alexander Gordeev)
        - Move D0 check into pci_msi_check_device() (Alexander Gordeev)
        - Remove unused kobject from struct msi_desc (Yijing Wang)
        - Remove "pos" from the struct msi_desc msi_attrib (Yijing Wang)
        - Add "msi_bus" sysfs MSI/MSI-X control for endpoints (Yijing Wang)
        - Use __get_cached_msi_msg() instead of get_cached_msi_msg() (Yijing Wang)
        - Use __read_msi_msg() instead of read_msi_msg() (Yijing Wang)
        - Use __write_msi_msg() instead of write_msi_msg() (Yijing Wang)
    
      Power management
        - Drop unused runtime PM support code for PCIe ports (Rafael J.  Wysocki)
        - Allow PCI devices to be put into D3cold during system suspend (Rafael J. Wysocki)
    
      AER
        - Add additional AER error strings (Gong Chen)
        - Make <linux/aer.h> standalone includable (Thierry Reding)
    
      Virtualization
        - Add ACS quirk for Solarflare SFC9120 & SFC9140 (Alex Williamson)
        - Add ACS quirk for Intel 10G NICs (Alex Williamson)
        - Add ACS quirk for AMD A88X southbridge (Marti Raudsepp)
        - Remove unused pci_find_upstream_pcie_bridge(), pci_get_dma_source() (Alex Williamson)
        - Add device flag helpers (Ethan Zhao)
        - Assume all Mellanox devices have broken INTx masking (Gavin Shan)
    
      Generic host bridge driver
        - Fix ioport_map() for !CONFIG_GENERIC_IOMAP (Liviu Dudau)
        - Add pci_register_io_range() and pci_pio_to_address() (Liviu Dudau)
        - Define PCI_IOBASE as the base of virtual PCI IO space (Liviu Dudau)
        - Fix the conversion of IO ranges into IO resources (Liviu Dudau)
        - Add pci_get_new_domain_nr() and of_get_pci_domain_nr() (Liviu Dudau)
        - Add support for parsing PCI host bridge resources from DT (Liviu Dudau)
        - Add pci_remap_iospace() to map bus I/O resources (Liviu Dudau)
        - Add arm64 architectural support for PCI (Liviu Dudau)
    
      APM X-Gene
        - Add APM X-Gene PCIe driver (Tanmay Inamdar)
        - Add arm64 DT APM X-Gene PCIe device tree nodes (Tanmay Inamdar)
    
      Freescale i.MX6
        - Probe in module_init(), not fs_initcall() (Lucas Stach)
        - Delay enabling reference clock for SS until it stabilizes (Tim Harvey)
    
      Marvell MVEBU
        - Fix uninitialized variable in mvebu_get_tgt_attr() (Thomas Petazzoni)
    
      NVIDIA Tegra
        - Make sure the PCIe PLL is really reset (Eric Yuen)
        - Add error path tegra_msi_teardown_irq() cleanup (Jisheng Zhang)
        - Fix extended configuration space mapping (Peter Daifuku)
        - Implement resource hierarchy (Thierry Reding)
        - Clear CLKREQ# enable on port disable (Thierry Reding)
        - Add Tegra124 support (Thierry Reding)
    
      ST Microelectronics SPEAr13xx
        - Pass config resource through reg property (Pratyush Anand)
    
      Synopsys DesignWare
        - Use NULL instead of false (Fabio Estevam)
        - Parse bus-range property from devicetree (Lucas Stach)
        - Use pci_create_root_bus() instead of pci_scan_root_bus() (Lucas Stach)
        - Remove pci_assign_unassigned_resources() (Lucas Stach)
        - Check private_data validity in single place (Lucas Stach)
        - Setup and clear exactly one MSI at a time (Lucas Stach)
        - Remove open-coded bitmap operations (Lucas Stach)
        - Fix configuration base address when using 'reg' (Minghuan Lian)
        - Fix IO resource end address calculation (Minghuan Lian)
        - Rename get_msi_data() to get_msi_addr() (Minghuan Lian)
        - Add get_msi_data() to pcie_host_ops (Minghuan Lian)
        - Add support for v3.65 hardware (Murali Karicheri)
        - Fold struct pcie_port_info into struct pcie_port (Pratyush Anand)
    
      TI Keystone
        - Add TI Keystone PCIe driver (Murali Karicheri)
        - Limit MRSS for all downstream devices (Murali Karicheri)
        - Assume controller is already in RC mode (Murali Karicheri)
        - Set device ID based on SoC to support multiple ports (Murali Karicheri)
    
      Xilinx AXI
        - Add Xilinx AXI PCIe driver (Srikanth Thokala)
        - Fix xilinx_pcie_assign_msi() return value test (Dan Carpenter)
    
      Miscellaneous
        - Clean up whitespace (Quentin Lambert)
        - Remove assignments from "if" conditions (Quentin Lambert)
        - Move PCI_VENDOR_ID_VMWARE to pci_ids.h (Francesco Ruggeri)
        - x86: Mark DMI tables as initialization data (Mathias Krause)
        - x86: Move __init annotation to the correct place (Mathias Krause)
        - x86: Mark constants of pci_mmcfg_nvidia_mcp55() as __initconst (Mathias Krause)
        - x86: Constify pci_mmcfg_probes[] array (Mathias Krause)
        - x86: Mark PCI BIOS initialization code as such (Mathias Krause)
        - Parenthesize PCI_DEVID and PCI_VPD_LRDT_ID parameters (Megan Kamiya)
        - Remove unnecessary variable in pci_add_dynid() (Tobias Klauser)"
    
    * tag 'pci-v3.18-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (109 commits)
      arm64: dts: Add APM X-Gene PCIe device tree nodes
      PCI: Add ACS quirk for AMD A88X southbridge devices
      PCI: xgene: Add APM X-Gene PCIe driver
      PCI: designware: Remove open-coded bitmap operations
      PCI/MSI: Remove unnecessary temporary variable
      PCI/MSI: Use __write_msi_msg() instead of write_msi_msg()
      MSI/powerpc: Use __read_msi_msg() instead of read_msi_msg()
      PCI/MSI: Use __get_cached_msi_msg() instead of get_cached_msi_msg()
      PCI/MSI: Add "msi_bus" sysfs MSI/MSI-X control for endpoints
      PCI/MSI: Remove "pos" from the struct msi_desc msi_attrib
      PCI/MSI: Remove unused kobject from struct msi_desc
      PCI/MSI: Rename pci_msi_check_device() to pci_msi_supported()
      PCI/MSI: Move D0 check into pci_msi_check_device()
      PCI/MSI: Remove arch_msi_check_device()
      irqchip: armada-370-xp: Remove arch_msi_check_device()
      PCI/MSI/PPC: Remove arch_msi_check_device()
      arm64: Add architectural support for PCI
      PCI: Add pci_remap_iospace() to map bus I/O resources
      of/pci: Add support for parsing PCI host bridge resources from DT
      of/pci: Add pci_get_new_domain_nr() and of_get_pci_domain_nr()
      ...
    
    Conflicts:
            arch/arm64/boot/dts/apm-storm.dtsi

commit 07a7cbd3b815ea77b44d4d5bb4260b37d03a358d
Merge: cc0cb67adb97 d1e6dc91b532
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Oct 1 12:31:23 2014 -0600

    Merge branch 'pci/host-generic' into next
    
    * pci/host-generic:
      arm64: Add architectural support for PCI
      PCI: Add pci_remap_iospace() to map bus I/O resources
      of/pci: Add support for parsing PCI host bridge resources from DT
      of/pci: Add pci_get_new_domain_nr() and of_get_pci_domain_nr()
      PCI: Add generic domain handling
      of/pci: Fix the conversion of IO ranges into IO resources
      of/pci: Move of_pci_range_to_resource() to of/address.c
      ARM: Define PCI_IOBASE as the base of virtual PCI IO space
      of/pci: Add pci_register_io_range() and pci_pio_to_address()
      asm-generic/io.h: Fix ioport_map() for !CONFIG_GENERIC_IOMAP
    
    Conflicts:
            drivers/pci/host/pci-tegra.c

commit 670ba0c8883b576d0aec28bd7a838358a4be1406
Author: Catalin Marinas <catalin.marinas@arm.com>
Date:   Mon Sep 29 15:29:26 2014 +0100

    PCI: Add generic domain handling
    
    The handling of PCI domains (or PCI segments in ACPI speak) is usually a
    straightforward affair but its implementation is currently left to the
    architectural code, with pci_domain_nr(b) querying the value of the domain
    associated with bus b.
    
    This patch introduces CONFIG_PCI_DOMAINS_GENERIC as an option that can be
    selected if an architecture wants a simple implementation where the value
    of the domain associated with a bus is stored in struct pci_bus.
    
    The architectures that select CONFIG_PCI_DOMAINS_GENERIC will then have to
    implement pci_bus_assign_domain_nr() as a way of setting the domain number
    associated with a root bus.  All child buses except the root bus will
    inherit the domain_nr value from their parent.
    
    Signed-off-by: Catalin Marinas <Catalin.Marinas@arm.com>
    [Renamed pci_set_domain_nr() to pci_bus_assign_domain_nr()]
    Signed-off-by: Liviu Dudau <Liviu.Dudau@arm.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    CC: Arnd Bergmann <arnd@arndb.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index e3cf8a2e6292..636d1c9156a9 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -485,7 +485,7 @@ void pci_read_bridge_bases(struct pci_bus *child)
 	}
 }
 
-static struct pci_bus *pci_alloc_bus(void)
+static struct pci_bus *pci_alloc_bus(struct pci_bus *parent)
 {
 	struct pci_bus *b;
 
@@ -500,6 +500,10 @@ static struct pci_bus *pci_alloc_bus(void)
 	INIT_LIST_HEAD(&b->resources);
 	b->max_bus_speed = PCI_SPEED_UNKNOWN;
 	b->cur_bus_speed = PCI_SPEED_UNKNOWN;
+#ifdef CONFIG_PCI_DOMAINS_GENERIC
+	if (parent)
+		b->domain_nr = parent->domain_nr;
+#endif
 	return b;
 }
 
@@ -671,7 +675,7 @@ static struct pci_bus *pci_alloc_child_bus(struct pci_bus *parent,
 	/*
 	 * Allocate a new bus, and inherit stuff from the parent..
 	 */
-	child = pci_alloc_bus();
+	child = pci_alloc_bus(parent);
 	if (!child)
 		return NULL;
 
@@ -1761,13 +1765,14 @@ struct pci_bus *pci_create_root_bus(struct device *parent, int bus,
 	char bus_addr[64];
 	char *fmt;
 
-	b = pci_alloc_bus();
+	b = pci_alloc_bus(NULL);
 	if (!b)
 		return NULL;
 
 	b->sysdata = sysdata;
 	b->ops = ops;
 	b->number = b->busn_res.start = bus;
+	pci_bus_assign_domain_nr(b, parent);
 	b2 = pci_find_bus(pci_domain_nr(b), bus);
 	if (b2) {
 		/* If we already got to this bus through a different bridge, ignore it */

commit 2f419d76599e2fd1a2c2cf31730c80e952201af1
Merge: ef39ab79f740 bceee4a97eb5
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Sep 23 10:03:18 2014 -0600

    Merge branch 'pci/hotplug' into next
    
    * pci/hotplug:
      PCI: pciehp: Prevent NULL dereference during probe
      PCI: pciehp: Reduce PCIe slot_ctrl to 16 bits
      PCI: Configure *all* devices, not just hot-added ones
      PCI: Preserve MPS and MRRS when applying _HPX settings
      PCI: Apply _HPP settings to all hot-added PCI devices
      PCI: Preserve BIOS PCI_COMMAND_SERR and PCI_COMMAND_PARITY settings
      PCI: Apply _HPP settings to PCIe devices as well as PCI and PCI-X
      PCI: Remove unused pci_configure_slot()
      ACPI / hotplug / PCI: Remove pci_configure_slot() usage
      PCI: shpchp: Remove pci_configure_slot() usage
      PCI: pciehp: Remove pci_configure_slot() usage
      PCI: Add pci_configure_device() during enumeration
      PCI: Move pci_configure_slot() to drivers/pci/probe.c
      PCI: Shuffle pci-acpi.c functions to group them logically
      PCI: Whitespace cleanup in pci-acpi.c
      PCI: Move pci_get_hp_params() to drivers/pci/pci-acpi.c
      PCI: pciehp: Configure hot-added display devices
      PCI: Remove "no hotplug settings from platform" warning

commit 12d8706963f073fffad16c7c24160ef20d9aeaff
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Sep 19 11:08:40 2014 -0600

    Revert "PCI: Make sure bus number resources stay within their parents bounds"
    
    This reverts commit 1820ffdccb9b ("PCI: Make sure bus number resources stay
    within their parents bounds") because it breaks some systems with LSI Logic
    FC949ES Fibre Channel Adapters, apparently by exposing a defect in those
    adapters.
    
    Dirk tested a Tyan VX50 (B4985) with this device that worked like this
    prior to 1820ffdccb9b:
    
        bus: [bus 00-7f] on node 0 link 1
        ACPI: PCI Root Bridge [PCI0] (domain 0000 [bus 00-07])
        pci 0000:00:0e.0: PCI bridge to [bus 0a]
        pci_bus 0000:0a: busn_res: can not insert [bus 0a] under [bus 00-07] (conflicts with (null) [bus 00-07])
        pci 0000:0a:00.0: [1000:0646] type 00 class 0x0c0400 (FC adapter)
    
    Note that the root bridge [bus 00-07] aperture is wrong; this is a BIOS
    defect in the PCI0 _CRS method.  But prior to 1820ffdccb9b, we didn't
    enforce that aperture, and the FC adapter worked fine at 0a:00.0.
    
    After 1820ffdccb9b, we notice that 00:0e.0's aperture is not contained in
    the root bridge's aperture, so we reconfigure it so it *is* contained:
    
        pci 0000:00:0e.0: bridge configuration invalid ([bus 0a-0a]), reconfiguring
        pci 0000:00:0e.0: PCI bridge to [bus 06-07]
    
    This effectively moves the FC device from 0a:00.0 to 07:00.0, which should
    be legal.  But when we enumerate bus 06, the FC device doesn't respond, so
    we don't find anything.  This is probably a defect in the FC device.
    
    Possible fixes (due to Yinghai):
    
        1) Add a quirk to fix the _CRS information based on what amd_bus.c read
           from the hardware
    
        2) Reset the FC device after we change its bus number
    
        3) Revert 1820ffdccb9b
    
    Fix 1 would be relatively easy, but it does sweep the LSI FC issue under
    the rug.  We might want to reconfigure bus numbers in the future for some
    other reason, e.g., hotplug, and then we could trip over this again.
    
    For that reason, I like fix 2, but we don't know whether it actually works,
    and we don't have a patch for it yet.
    
    This revert is fix 3, which also sweeps the LSI FC issue under the rug.
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=84281
    Reported-by: Dirk Gouders <dirk@gouders.net>
    Tested-by: Dirk Gouders <dirk@gouders.net>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    CC: stable@vger.kernel.org      # v3.15+
    CC: Yinghai Lu <yinghai@kernel.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 7c8ca351beae..4170113cde61 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -775,7 +775,7 @@ int pci_scan_bridge(struct pci_bus *bus, struct pci_dev *dev, int max, int pass)
 	/* Check if setup is sensible at all */
 	if (!pass &&
 	    (primary != bus->number || secondary <= bus->number ||
-	     secondary > subordinate || subordinate > bus->busn_res.end)) {
+	     secondary > subordinate)) {
 		dev_info(&dev->dev, "bridge configuration invalid ([bus %02x-%02x]), reconfiguring\n",
 			 secondary, subordinate);
 		broken = 1;
@@ -849,8 +849,7 @@ int pci_scan_bridge(struct pci_bus *bus, struct pci_dev *dev, int max, int pass)
 			child = pci_add_new_bus(bus, dev, max+1);
 			if (!child)
 				goto out;
-			pci_bus_insert_busn_res(child, max+1,
-						bus->busn_res.end);
+			pci_bus_insert_busn_res(child, max+1, 0xff);
 		}
 		max++;
 		buses = (buses & 0xff000000)
@@ -909,11 +908,6 @@ int pci_scan_bridge(struct pci_bus *bus, struct pci_dev *dev, int max, int pass)
 		/*
 		 * Set the subordinate bus number to its real value.
 		 */
-		if (max > bus->busn_res.end) {
-			dev_warn(&dev->dev, "max busn %02x is outside %pR\n",
-				 max, &bus->busn_res);
-			max = bus->busn_res.end;
-		}
 		pci_bus_update_busn_res_end(child, max);
 		pci_write_config_byte(dev, PCI_SUBORDINATE_BUS, max);
 	}

commit 7a0b33d4a45d30b9a838fba4efcd80b7b57d4d16
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Sep 19 10:56:06 2014 -0600

    Revert "PCI: Don't scan random busses in pci_scan_bridge()"
    
    This reverts commit fc1b253141b3 ("PCI: Don't scan random busses in
    pci_scan_bridge()") because it breaks CardBus on some machines.
    
    David tested a Dell Latitude D505 that worked like this prior to
    fc1b253141b3:
    
        pci 0000:00:1e.0: PCI bridge to [bus 01]
        pci 0000:01:01.0: CardBus bridge to [bus 02-05]
    
    Note that the 01:01.0 CardBus bridge has a bus number aperture of
    [bus 02-05], but those buses are all outside the 00:1e.0 PCI bridge bus
    number aperture, so accesses to buses 02-05 never reach CardBus.  This is
    later patched up by yenta_fixup_parent_bridge(), which changes the
    subordinate bus number of the 00:1e.0 PCI bridge:
    
        pci_bus 0000:01: Raising subordinate bus# of parent bus (#01) from #01 to #05
    
    With fc1b253141b3, pci_scan_bridge() fails immediately when it notices that
    we can't allocate a valid secondary bus number for the CardBus bridge, and
    CardBus doesn't work at all:
    
        pci 0000:01:01.0: can't allocate child bus 01 from [bus 01]
    
    I'd prefer to fix this by integrating the yenta_fixup_parent_bridge() logic
    into pci_scan_bridge() so we fix the bus number apertures up front.  But
    I don't think we can do that before v3.17, so I'm going to revert this to
    avoid the problem while we're working on the long-term fix.
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=83441
    Link: http://lkml.kernel.org/r/1409303414-5196-1-git-send-email-david.henningsson@canonical.com
    Reported-by: David Henningsson <david.henningsson@canonical.com>
    Tested-by: David Henningsson <david.henningsson@canonical.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    CC: stable@vger.kernel.org      # v3.15+

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index e3cf8a2e6292..7c8ca351beae 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -838,16 +838,12 @@ int pci_scan_bridge(struct pci_bus *bus, struct pci_dev *dev, int max, int pass)
 			goto out;
 		}
 
-		if (max >= bus->busn_res.end) {
-			dev_warn(&dev->dev, "can't allocate child bus %02x from %pR\n",
-				 max, &bus->busn_res);
-			goto out;
-		}
-
 		/* Clear errors */
 		pci_write_config_word(dev, PCI_STATUS, 0xffff);
 
-		/* The bus will already exist if we are rescanning */
+		/* Prevent assigning a bus number that already exists.
+		 * This can happen when a bridge is hot-plugged, so in
+		 * this case we only re-scan this bus. */
 		child = pci_find_bus(pci_domain_nr(bus), max+1);
 		if (!child) {
 			child = pci_add_new_bus(bus, dev, max+1);

commit 1302fcf0d03e6ea74846c7fee14736306ab2ce4b
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Sat Aug 30 07:23:01 2014 -0600

    PCI: Configure *all* devices, not just hot-added ones
    
    There's not really a good way to determine whether firmware has already
    configured a device with _HPP/_HPX settings.  On legacy systems, the BIOS
    has probably configured everything, but on UEFI systems it is not required
    to do so.
    
    Per the PCI Firmware Specification, rev 3.1, sec 3.5, if PCI_COMMAND_IO or
    PCI_COMMAND_MEMORY is set, we can assume firmware has set the corresponding
    BARs and maybe we can assume it has configured the rest of the device.  And
    if a bridge has PCI_COMMAND_PARITY or PCI_COMMAND_SERR set, we can assume
    firmware has configured the bridge.  But we can't tell much about devices
    without BARs.
    
    I think it should be safe to apply _HPP and _HPX settings anyway, even if
    firmware has already configured the device, so configure everything we
    find.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index cb411fbb6435..290c657da0b9 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1358,9 +1358,6 @@ static void pci_configure_device(struct pci_dev *dev)
 	struct hotplug_params hpp;
 	int ret;
 
-	if (system_state == SYSTEM_BOOTING)
-		return;
-
 	memset(&hpp, 0, sizeof(hpp));
 	ret = pci_get_hp_params(dev, &hpp);
 	if (ret)

commit 302328c00341f1c161bfe32d085d3e6549a08f2d
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Sep 3 13:26:29 2014 -0600

    PCI: Preserve MPS and MRRS when applying _HPX settings
    
    Linux manages MPS and MRRS settings to keep them consistent across the PCIe
    fabric.  BIOS doesn't participate in this Linux management, so ignore that
    part of any _HPX settings it supplies.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 1ff2105ba401..cb411fbb6435 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1301,6 +1301,16 @@ static void program_hpp_type2(struct pci_dev *dev, struct hpp_type2 *hpp)
 		return;
 	}
 
+	/*
+	 * Don't allow _HPX to change MPS or MRRS settings.  We manage
+	 * those to make sure they're consistent with the rest of the
+	 * platform.
+	 */
+	hpp->pci_exp_devctl_and |= PCI_EXP_DEVCTL_PAYLOAD |
+				    PCI_EXP_DEVCTL_READRQ;
+	hpp->pci_exp_devctl_or &= ~(PCI_EXP_DEVCTL_PAYLOAD |
+				    PCI_EXP_DEVCTL_READRQ);
+
 	/* Initialize Device Control Register */
 	pcie_capability_clear_and_set_word(dev, PCI_EXP_DEVCTL,
 			~hpp->pci_exp_devctl_and, hpp->pci_exp_devctl_or);

commit ca0647e08acd327d508c0fa4553c2148dc7e08b4
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Sat Aug 30 07:22:13 2014 -0600

    PCI: Apply _HPP settings to all hot-added PCI devices
    
    We currently apply _HPP settings only to:
    
        - non-bridge devices, and
        - PCI-to-PCI bridges
    
    i.e., we do not apply them to PCI-to-ISA bridges and the like.  It has been
    that way since _HPP support was added by 40abb96c51bb ("pciehp: Fix
    programming hotplug parameters"), but I don't think there's any reason to
    exclude these other bridges.
    
    Apply _HPP settings to hot-added PCI devices of any type.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index a16b3472b70d..1ff2105ba401 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1351,11 +1351,6 @@ static void pci_configure_device(struct pci_dev *dev)
 	if (system_state == SYSTEM_BOOTING)
 		return;
 
-	if (!(dev->hdr_type == PCI_HEADER_TYPE_NORMAL ||
-			(dev->hdr_type == PCI_HEADER_TYPE_BRIDGE &&
-			(dev->class >> 8) == PCI_CLASS_BRIDGE_PCI)))
-		return;
-
 	memset(&hpp, 0, sizeof(hpp));
 	ret = pci_get_hp_params(dev, &hpp);
 	if (ret)

commit eab3a0ee342106a1c82e10682c02632e9d6af0df
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Aug 27 14:38:14 2014 -0600

    PCI: Preserve BIOS PCI_COMMAND_SERR and PCI_COMMAND_PARITY settings
    
    Do not clear PCI_COMMAND_SERR or PCI_COMMAND_PARITY based on _HPP.  The
    spec (ACPI rev 5.0, sec 6.2.7) says that when "Enable SERR" is set to 1,
    we should enable SERR in the command register.  It says nothing about
    *disabling* SERR or PERR; in fact, the example in 6.2.7.1 says we should
    leave PERR alone unless "Enable PERR" is 1.
    
    For hot-added devices, this probably doesn't matter because they power up
    with these bits cleared.  But in addition to hot-plugged devices, the spec
    allows the platform to use _HPP for "configuration of PCI devices not
    configured by the BIOS at system boot," and it may make a difference for
    devices present at boot.
    
    This change means that if BIOS enables SERR or PERR on a device, and it
    supplies _HPP or _HPX with the SERR or PERR bits *cleared*, we will now
    leave SERR or PERR reporting enabled on that device instead of disabling it
    as we previously did.
    
    See also 40abb96c51bb ("pciehp: Fix programming hotplug parameters"), where
    this code was first added.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 003d112a783d..a16b3472b70d 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1264,12 +1264,8 @@ static void program_hpp_type0(struct pci_dev *dev, struct hpp_type0 *hpp)
 	pci_read_config_word(dev, PCI_COMMAND, &pci_cmd);
 	if (hpp->enable_serr)
 		pci_cmd |= PCI_COMMAND_SERR;
-	else
-		pci_cmd &= ~PCI_COMMAND_SERR;
 	if (hpp->enable_perr)
 		pci_cmd |= PCI_COMMAND_PARITY;
-	else
-		pci_cmd &= ~PCI_COMMAND_PARITY;
 	pci_write_config_word(dev, PCI_COMMAND, pci_cmd);
 
 	/* Program bridge control value */
@@ -1279,12 +1275,8 @@ static void program_hpp_type0(struct pci_dev *dev, struct hpp_type0 *hpp)
 		pci_read_config_word(dev, PCI_BRIDGE_CONTROL, &pci_bctl);
 		if (hpp->enable_serr)
 			pci_bctl |= PCI_BRIDGE_CTL_SERR;
-		else
-			pci_bctl &= ~PCI_BRIDGE_CTL_SERR;
 		if (hpp->enable_perr)
 			pci_bctl |= PCI_BRIDGE_CTL_PARITY;
-		else
-			pci_bctl &= ~PCI_BRIDGE_CTL_PARITY;
 		pci_write_config_word(dev, PCI_BRIDGE_CONTROL, pci_bctl);
 	}
 }

commit c6285fc5b55ecbf78c53301a191f04bb2fda1b3a
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Aug 29 18:10:19 2014 -0600

    PCI: Apply _HPP settings to PCIe devices as well as PCI and PCI-X
    
    The ACPI _HPP method was defined before PCIe existed, so its documentation
    only mentions PCI.  The _HPX Type 0 setting record is essentially identical
    to _HPP, but the spec (ACPI rev 5.0, sec 6.2.8.1) says it should be applied
    to PCI, PCI-X, and PCIe devices, with settings being ignored if they are
    not applicable.
    
    Some platforms with both conventional PCI and PCIe devices provide only
    _HPP (not _HPX), so treat _HPP the same way as an _HPX Type 0 record and
    apply it to PCIe devices as well as PCI and PCI-X.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 4b3b29bc7a82..003d112a783d 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1249,15 +1249,8 @@ static void program_hpp_type0(struct pci_dev *dev, struct hpp_type0 *hpp)
 {
 	u16 pci_cmd, pci_bctl;
 
-	if (!hpp) {
-		/*
-		 * Perhaps we *should* use default settings for PCIe, but
-		 * pciehp didn't, so we won't either.
-		 */
-		if (pci_is_pcie(dev))
-			return;
+	if (!hpp)
 		hpp = &pci_default_type0;
-	}
 
 	if (hpp->revision > 1) {
 		dev_warn(&dev->dev,

commit fbfa398b84a5fc6e085dedba5ec3e94f21815d05
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Aug 28 12:21:44 2014 -0600

    PCI: Remove unused pci_configure_slot()
    
    All pci_configure_slot() uses have been removed, so remove the definition
    as well.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index e9482867555b..4b3b29bc7a82 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1358,34 +1358,6 @@ static void program_hpp_type2(struct pci_dev *dev, struct hpp_type2 *hpp)
 	 */
 }
 
-void pci_configure_slot(struct pci_dev *dev)
-{
-	struct pci_dev *cdev;
-	struct hotplug_params hpp;
-	int ret;
-
-	if (!(dev->hdr_type == PCI_HEADER_TYPE_NORMAL ||
-			(dev->hdr_type == PCI_HEADER_TYPE_BRIDGE &&
-			(dev->class >> 8) == PCI_CLASS_BRIDGE_PCI)))
-		return;
-
-	pcie_bus_configure_settings(dev->bus);
-
-	memset(&hpp, 0, sizeof(hpp));
-	ret = pci_get_hp_params(dev, &hpp);
-
-	program_hpp_type2(dev, hpp.t2);
-	program_hpp_type1(dev, hpp.t1);
-	program_hpp_type0(dev, hpp.t0);
-
-	if (dev->subordinate) {
-		list_for_each_entry(cdev, &dev->subordinate->devices,
-				    bus_list)
-			pci_configure_slot(cdev);
-	}
-}
-EXPORT_SYMBOL_GPL(pci_configure_slot);
-
 static void pci_configure_device(struct pci_dev *dev)
 {
 	struct hotplug_params hpp;

commit 6cd33649fa83d97ba7b66f1d871a360e867c5220
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Aug 27 14:29:47 2014 -0600

    PCI: Add pci_configure_device() during enumeration
    
    Some platforms can tell the OS how to configure PCI devices, e.g., how to
    set cache line size, error reporting enables, etc.  ACPI defines _HPP and
    _HPX methods for this purpose.
    
    This configuration was previously done by some of the hotplug drivers using
    pci_configure_slot().  But not all hotplug drivers did this, and per the
    spec (ACPI rev 5.0, sec 6.2.7), we can also do it for "devices not
    configured by the BIOS at system boot."
    
    Move this configuration into the PCI core by adding pci_configure_device()
    and calling it from pci_device_add(), so we do this for all devices as we
    enumerate them.
    
    This is based on pci_configure_slot(), which is used by hotplug drivers.
    I omitted:
    
      - pcie_bus_configure_settings() because it configures MPS and MRRS, which
        requires global knowledge of the fabric and must be done later, and
    
      - configuration of subordinate devices; that will happen when we call
        pci_device_add() for those devices.
    
    Because pci_configure_slot() was only done by hotplug drivers, this initial
    version of pci_configure_device() only configures hot-added devices,
    ignoring anything added during boot.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 6a198fc65999..e9482867555b 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1386,6 +1386,29 @@ void pci_configure_slot(struct pci_dev *dev)
 }
 EXPORT_SYMBOL_GPL(pci_configure_slot);
 
+static void pci_configure_device(struct pci_dev *dev)
+{
+	struct hotplug_params hpp;
+	int ret;
+
+	if (system_state == SYSTEM_BOOTING)
+		return;
+
+	if (!(dev->hdr_type == PCI_HEADER_TYPE_NORMAL ||
+			(dev->hdr_type == PCI_HEADER_TYPE_BRIDGE &&
+			(dev->class >> 8) == PCI_CLASS_BRIDGE_PCI)))
+		return;
+
+	memset(&hpp, 0, sizeof(hpp));
+	ret = pci_get_hp_params(dev, &hpp);
+	if (ret)
+		return;
+
+	program_hpp_type2(dev, hpp.t2);
+	program_hpp_type1(dev, hpp.t1);
+	program_hpp_type0(dev, hpp.t0);
+}
+
 static void pci_release_capabilities(struct pci_dev *dev)
 {
 	pci_vpd_release(dev);
@@ -1523,6 +1546,8 @@ void pci_device_add(struct pci_dev *dev, struct pci_bus *bus)
 {
 	int ret;
 
+	pci_configure_device(dev);
+
 	device_initialize(&dev->dev);
 	dev->dev.release = pci_release_dev;
 

commit 589fcc2307423d9c3856a4e2e72e1b57b6826f41
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Sep 12 20:02:00 2014 -0600

    PCI: Move pci_configure_slot() to drivers/pci/probe.c
    
    Move pci_configure_slot() and related functions from
    drivers/pci/hotplug/pcihp_slot to drivers/pci/probe.c.
    
    This is to prepare for doing device configuration during the normal
    enumeration process instead of just after hot-add.
    
    No functional change.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index e3cf8a2e6292..6a198fc65999 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -6,6 +6,7 @@
 #include <linux/delay.h>
 #include <linux/init.h>
 #include <linux/pci.h>
+#include <linux/pci_hotplug.h>
 #include <linux/slab.h>
 #include <linux/module.h>
 #include <linux/cpumask.h>
@@ -1236,6 +1237,155 @@ int pci_setup_device(struct pci_dev *dev)
 	return 0;
 }
 
+static struct hpp_type0 pci_default_type0 = {
+	.revision = 1,
+	.cache_line_size = 8,
+	.latency_timer = 0x40,
+	.enable_serr = 0,
+	.enable_perr = 0,
+};
+
+static void program_hpp_type0(struct pci_dev *dev, struct hpp_type0 *hpp)
+{
+	u16 pci_cmd, pci_bctl;
+
+	if (!hpp) {
+		/*
+		 * Perhaps we *should* use default settings for PCIe, but
+		 * pciehp didn't, so we won't either.
+		 */
+		if (pci_is_pcie(dev))
+			return;
+		hpp = &pci_default_type0;
+	}
+
+	if (hpp->revision > 1) {
+		dev_warn(&dev->dev,
+			 "PCI settings rev %d not supported; using defaults\n",
+			 hpp->revision);
+		hpp = &pci_default_type0;
+	}
+
+	pci_write_config_byte(dev, PCI_CACHE_LINE_SIZE, hpp->cache_line_size);
+	pci_write_config_byte(dev, PCI_LATENCY_TIMER, hpp->latency_timer);
+	pci_read_config_word(dev, PCI_COMMAND, &pci_cmd);
+	if (hpp->enable_serr)
+		pci_cmd |= PCI_COMMAND_SERR;
+	else
+		pci_cmd &= ~PCI_COMMAND_SERR;
+	if (hpp->enable_perr)
+		pci_cmd |= PCI_COMMAND_PARITY;
+	else
+		pci_cmd &= ~PCI_COMMAND_PARITY;
+	pci_write_config_word(dev, PCI_COMMAND, pci_cmd);
+
+	/* Program bridge control value */
+	if ((dev->class >> 8) == PCI_CLASS_BRIDGE_PCI) {
+		pci_write_config_byte(dev, PCI_SEC_LATENCY_TIMER,
+				      hpp->latency_timer);
+		pci_read_config_word(dev, PCI_BRIDGE_CONTROL, &pci_bctl);
+		if (hpp->enable_serr)
+			pci_bctl |= PCI_BRIDGE_CTL_SERR;
+		else
+			pci_bctl &= ~PCI_BRIDGE_CTL_SERR;
+		if (hpp->enable_perr)
+			pci_bctl |= PCI_BRIDGE_CTL_PARITY;
+		else
+			pci_bctl &= ~PCI_BRIDGE_CTL_PARITY;
+		pci_write_config_word(dev, PCI_BRIDGE_CONTROL, pci_bctl);
+	}
+}
+
+static void program_hpp_type1(struct pci_dev *dev, struct hpp_type1 *hpp)
+{
+	if (hpp)
+		dev_warn(&dev->dev, "PCI-X settings not supported\n");
+}
+
+static void program_hpp_type2(struct pci_dev *dev, struct hpp_type2 *hpp)
+{
+	int pos;
+	u32 reg32;
+
+	if (!hpp)
+		return;
+
+	if (hpp->revision > 1) {
+		dev_warn(&dev->dev, "PCIe settings rev %d not supported\n",
+			 hpp->revision);
+		return;
+	}
+
+	/* Initialize Device Control Register */
+	pcie_capability_clear_and_set_word(dev, PCI_EXP_DEVCTL,
+			~hpp->pci_exp_devctl_and, hpp->pci_exp_devctl_or);
+
+	/* Initialize Link Control Register */
+	if (dev->subordinate)
+		pcie_capability_clear_and_set_word(dev, PCI_EXP_LNKCTL,
+			~hpp->pci_exp_lnkctl_and, hpp->pci_exp_lnkctl_or);
+
+	/* Find Advanced Error Reporting Enhanced Capability */
+	pos = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ERR);
+	if (!pos)
+		return;
+
+	/* Initialize Uncorrectable Error Mask Register */
+	pci_read_config_dword(dev, pos + PCI_ERR_UNCOR_MASK, &reg32);
+	reg32 = (reg32 & hpp->unc_err_mask_and) | hpp->unc_err_mask_or;
+	pci_write_config_dword(dev, pos + PCI_ERR_UNCOR_MASK, reg32);
+
+	/* Initialize Uncorrectable Error Severity Register */
+	pci_read_config_dword(dev, pos + PCI_ERR_UNCOR_SEVER, &reg32);
+	reg32 = (reg32 & hpp->unc_err_sever_and) | hpp->unc_err_sever_or;
+	pci_write_config_dword(dev, pos + PCI_ERR_UNCOR_SEVER, reg32);
+
+	/* Initialize Correctable Error Mask Register */
+	pci_read_config_dword(dev, pos + PCI_ERR_COR_MASK, &reg32);
+	reg32 = (reg32 & hpp->cor_err_mask_and) | hpp->cor_err_mask_or;
+	pci_write_config_dword(dev, pos + PCI_ERR_COR_MASK, reg32);
+
+	/* Initialize Advanced Error Capabilities and Control Register */
+	pci_read_config_dword(dev, pos + PCI_ERR_CAP, &reg32);
+	reg32 = (reg32 & hpp->adv_err_cap_and) | hpp->adv_err_cap_or;
+	pci_write_config_dword(dev, pos + PCI_ERR_CAP, reg32);
+
+	/*
+	 * FIXME: The following two registers are not supported yet.
+	 *
+	 *   o Secondary Uncorrectable Error Severity Register
+	 *   o Secondary Uncorrectable Error Mask Register
+	 */
+}
+
+void pci_configure_slot(struct pci_dev *dev)
+{
+	struct pci_dev *cdev;
+	struct hotplug_params hpp;
+	int ret;
+
+	if (!(dev->hdr_type == PCI_HEADER_TYPE_NORMAL ||
+			(dev->hdr_type == PCI_HEADER_TYPE_BRIDGE &&
+			(dev->class >> 8) == PCI_CLASS_BRIDGE_PCI)))
+		return;
+
+	pcie_bus_configure_settings(dev->bus);
+
+	memset(&hpp, 0, sizeof(hpp));
+	ret = pci_get_hp_params(dev, &hpp);
+
+	program_hpp_type2(dev, hpp.t2);
+	program_hpp_type1(dev, hpp.t1);
+	program_hpp_type0(dev, hpp.t0);
+
+	if (dev->subordinate) {
+		list_for_each_entry(cdev, &dev->subordinate->devices,
+				    bus_list)
+			pci_configure_slot(cdev);
+	}
+}
+EXPORT_SYMBOL_GPL(pci_configure_slot);
+
 static void pci_release_capabilities(struct pci_dev *dev)
 {
 	pci_vpd_release(dev);

commit f3dbd802b3caf8da92173870bc270dda6b3f84ba
Author: Rajat Jain <rajatxjain@gmail.com>
Date:   Tue Sep 2 16:26:00 2014 -0700

    PCI: Enable CRS Software Visibility for root port if it is supported
    
    Per PCIe r3.0, sec 2.3.2, an endpoint may respond to a Configuration
    Request with a Completion with Configuration Request Retry Status (CRS).
    This terminates the Configuration Request.
    
    When the CRS Software Visibility feature is disabled (as it is by default),
    a Root Complex must handle a CRS Completion by re-issuing the Configuration
    Request.  This is invisible to software.  From the CPU's point of view, an
    endpoint that always responds with CRS causes a hang because the Root
    Complex never supplies data to complete the CPU read.
    
    When CRS Software Visibility is enabled, a Root Complex that receives a CRS
    Completion for a read of the Vendor ID must return data of 0x0001.  The
    Vendor ID of 0x0001 indicates to software that the endpoint is not ready.
    
    We now have more devices that require CRS Software Visibility.  For
    example, a PLX 8713 NT bridge may respond with CRS until it has been
    configured via I2C, and the I2C configuration is completely independent of
    PCI enumeration.
    
    Enable CRS Software Visibility if it is supported.  This allows a system
    with such a device to work (though the PCI core times out waiting for it to
    become ready, and we have to rescan the bus after it is ready).
    
    This essentially reverts ad7edfe04908 ("[PCI] Do not enable CRS Software
    Visibility by default").  The failures that led to ad7edfe04908 should be
    addressed by 89665a6a7140 ("PCI: Check only the Vendor ID to identify
    Configuration Request Retry").
    
    [bhelgaas: changelog]
    Link: http://lkml.kernel.org/r/20071029061532.5d10dfc6@snowcone
    Link: http://lkml.kernel.org/r/alpine.LFD.0.9999.0712271023090.21557@woody.linux-foundation.org
    Signed-off-by: Rajat Jain <rajatxjain@gmail.com>
    Signed-off-by: Rajat Jain <rajatjain@juniper.net>
    Signed-off-by: Guenter Roeck <groeck@juniper.net>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 9c26663c91d2..e02cdaa5bf0c 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -740,6 +740,17 @@ struct pci_bus *pci_add_new_bus(struct pci_bus *parent, struct pci_dev *dev,
 }
 EXPORT_SYMBOL(pci_add_new_bus);
 
+static void pci_enable_crs(struct pci_dev *pdev)
+{
+	u16 root_cap = 0;
+
+	/* Enable CRS Software Visibility if supported */
+	pcie_capability_read_word(pdev, PCI_EXP_RTCAP, &root_cap);
+	if (root_cap & PCI_EXP_RTCAP_CRSVIS)
+		pcie_capability_set_word(pdev, PCI_EXP_RTCTL,
+					 PCI_EXP_RTCTL_CRSSVE);
+}
+
 /*
  * If it's a bridge, configure it and scan the bus behind it.
  * For CardBus bridges, we don't scan behind as the devices will
@@ -787,6 +798,8 @@ int pci_scan_bridge(struct pci_bus *bus, struct pci_dev *dev, int max, int pass)
 	pci_write_config_word(dev, PCI_BRIDGE_CONTROL,
 			      bctl & ~PCI_BRIDGE_CTL_MASTER_ABORT);
 
+	pci_enable_crs(dev);
+
 	if ((secondary || subordinate) && !pcibios_assign_all_busses() &&
 	    !is_cardbus && !broken) {
 		unsigned int cmax;

commit 89665a6a71408796565bfd29cfa6a7877b17a667
Author: Rajat Jain <rajatxjain@gmail.com>
Date:   Mon Sep 8 14:19:49 2014 -0700

    PCI: Check only the Vendor ID to identify Configuration Request Retry
    
    Per PCIe r3.0, sec 2.3.2, if a Root Complex
    
      - has Configuration Request Retry Status Software Visibility enabled,
      - issues a Configuration Read of both bytes of the Vendor ID, and
      - receives a Completion with Configuration Request Retry Status (CRS),
    
    it must complete the request to the host by fabricating data of 0x0001 for
    the Vendor ID and 0xff for any additional bytes in the request.
    
    Linux issues a single config read for the four bytes containing the Vendor
    ID and the Device ID.  Previously we checked all four bytes for 0xffff0001
    to identify CRS.
    
    However, it is only the Vendor ID that really indicates CRS, because it's
    sufficient to read only those two bytes.  Checking the Device ID verifies
    spec compliance but doesn't add any information.
    
    Some Root Complexes appear to indicate CRS by returning 0x0001 for the
    Vendor ID along with the actual the Device ID.  Previously we interpreted
    that as a valid Vendor/Device ID pair, although 0x0001 is reserved and
    cannot be a valid Vendor ID.
    
    [bhelgaas: changelog]
    Link: http://lkml.kernel.org/r/4729FC36.3040000@gmail.com
    Signed-off-by: Rajat Jain <rajatxjain@gmail.com>
    Signed-off-by: Rajat Jain <rajatjain@juniper.net>
    Signed-off-by: Guenter Roeck <groeck@juniper.net>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index e3cf8a2e6292..9c26663c91d2 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1292,8 +1292,13 @@ bool pci_bus_read_dev_vendor_id(struct pci_bus *bus, int devfn, u32 *l,
 	    *l == 0x0000ffff || *l == 0xffff0000)
 		return false;
 
-	/* Configuration request Retry Status */
-	while (*l == 0xffff0001) {
+	/*
+	 * Configuration Request Retry Status.  Some root ports return the
+	 * actual device ID instead of the synthetic ID (0xFFFF) required
+	 * by the PCIe spec.  Ignore the device ID and only check for
+	 * (vendor id == 1).
+	 */
+	while ((*l & 0xffff) == 0x0001) {
 		if (!crs_timeout)
 			return false;
 

commit 227f06470502c4fea3d93df1f12a77e3e37f6263
Author: Ryan Desfosses <ryan@desfo.org>
Date:   Fri Apr 18 20:13:50 2014 -0400

    PCI: Merge multi-line quoted strings
    
    Merge quoted strings that are broken across lines into a single entity.
    The compiler merges them anyway, but checkpatch complains about it, and
    merging them makes it easier to grep for strings.
    
    No functional change.
    
    [bhelgaas: changelog, do the same for everything under drivers/pci]
    Signed-off-by: Ryan Desfosses <ryan@desfo.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 468a6505bef1..e3cf8a2e6292 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -433,8 +433,7 @@ static void pci_read_bridge_mmio_pref(struct pci_bus *child)
 			limit |= ((unsigned long) mem_limit_hi) << 32;
 #else
 			if (mem_base_hi || mem_limit_hi) {
-				dev_err(&dev->dev, "can't handle 64-bit "
-					"address space for bridge\n");
+				dev_err(&dev->dev, "can't handle 64-bit address space for bridge\n");
 				return;
 			}
 #endif
@@ -933,8 +932,7 @@ int pci_scan_bridge(struct pci_bus *bus, struct pci_dev *dev, int max, int pass)
 		    (child->number > bus->busn_res.end) ||
 		    (child->number < bus->number) ||
 		    (child->busn_res.end < bus->number)) {
-			dev_info(&child->dev, "%pR %s "
-				"hidden behind%s bridge %s %pR\n",
+			dev_info(&child->dev, "%pR %s hidden behind%s bridge %s %pR\n",
 				&child->busn_res,
 				(bus->number > child->busn_res.end &&
 				 bus->busn_res.end < child->number) ?
@@ -1224,13 +1222,13 @@ int pci_setup_device(struct pci_dev *dev)
 		break;
 
 	default:				    /* unknown header */
-		dev_err(&dev->dev, "unknown header type %02x, "
-			"ignoring device\n", dev->hdr_type);
+		dev_err(&dev->dev, "unknown header type %02x, ignoring device\n",
+			dev->hdr_type);
 		return -EIO;
 
 	bad:
-		dev_err(&dev->dev, "ignoring class %#08x (doesn't match header "
-			"type %02x)\n", dev->class, dev->hdr_type);
+		dev_err(&dev->dev, "ignoring class %#08x (doesn't match header type %02x)\n",
+			dev->class, dev->hdr_type);
 		dev->class = PCI_CLASS_NOT_DEFINED;
 	}
 
@@ -1305,10 +1303,9 @@ bool pci_bus_read_dev_vendor_id(struct pci_bus *bus, int devfn, u32 *l,
 			return false;
 		/* Card hasn't responded in 60 seconds?  Must be stuck. */
 		if (delay > crs_timeout) {
-			printk(KERN_WARNING "pci %04x:%02x:%02x.%d: not "
-					"responding\n", pci_domain_nr(bus),
-					bus->number, PCI_SLOT(devfn),
-					PCI_FUNC(devfn));
+			printk(KERN_WARNING "pci %04x:%02x:%02x.%d: not responding\n",
+			       pci_domain_nr(bus), bus->number, PCI_SLOT(devfn),
+			       PCI_FUNC(devfn));
 			return false;
 		}
 	}
@@ -1613,9 +1610,7 @@ static void pcie_write_mrrs(struct pci_dev *dev)
 	}
 
 	if (mrrs < 128)
-		dev_err(&dev->dev, "MRRS was unable to be configured with a "
-			"safe value.  If problems are experienced, try running "
-			"with pci=pcie_bus_safe.\n");
+		dev_err(&dev->dev, "MRRS was unable to be configured with a safe value.  If problems are experienced, try running with pci=pcie_bus_safe\n");
 }
 
 static void pcie_bus_detect_mps(struct pci_dev *dev)
@@ -1652,8 +1647,8 @@ static int pcie_bus_configure_set(struct pci_dev *dev, void *data)
 	pcie_write_mps(dev, mps);
 	pcie_write_mrrs(dev);
 
-	dev_info(&dev->dev, "Max Payload Size set to %4d/%4d (was %4d), "
-		 "Max Read Rq %4d\n", pcie_get_mps(dev), 128 << dev->pcie_mpss,
+	dev_info(&dev->dev, "Max Payload Size set to %4d/%4d (was %4d), Max Read Rq %4d\n",
+		 pcie_get_mps(dev), 128 << dev->pcie_mpss,
 		 orig_mps, pcie_get_readrq(dev));
 
 	return 0;

commit 3c78bc61f5ef3bc87e7f94f67ec737d2273f120b
Author: Ryan Desfosses <ryan@desfo.org>
Date:   Fri Apr 18 20:13:49 2014 -0400

    PCI: Whitespace cleanup
    
    Fix various whitespace errors.
    
    No functional change.
    
    [bhelgaas: fix other similar problems]
    Signed-off-by: Ryan Desfosses <ryan@desfo.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 96b954f55d0d..468a6505bef1 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -168,7 +168,7 @@ static inline unsigned long decode_bar(struct pci_dev *dev, u32 bar)
  * Returns 1 if the BAR is 64-bit, or 0 if 32-bit.
  */
 int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
-			struct resource *res, unsigned int pos)
+		    struct resource *res, unsigned int pos)
 {
 	u32 l, sz, mask;
 	u64 l64, sz64, mask64;
@@ -604,7 +604,6 @@ static enum pci_bus_speed agp_speed(int agp3, int agpstat)
 	return agp_speeds[index];
 }
 
-
 static void pci_set_bus_speed(struct pci_bus *bus)
 {
 	struct pci_dev *bridge = bus->self;
@@ -636,11 +635,10 @@ static void pci_set_bus_speed(struct pci_bus *bus)
 		} else if (status & PCI_X_SSTATUS_266MHZ) {
 			max = PCI_SPEED_133MHz_PCIX_266;
 		} else if (status & PCI_X_SSTATUS_133MHZ) {
-			if ((status & PCI_X_SSTATUS_VERS) == PCI_X_SSTATUS_V2) {
+			if ((status & PCI_X_SSTATUS_VERS) == PCI_X_SSTATUS_V2)
 				max = PCI_SPEED_133MHz_PCIX_ECC;
-			} else {
+			else
 				max = PCI_SPEED_133MHz_PCIX;
-			}
 		} else {
 			max = PCI_SPEED_66MHz_PCIX;
 		}
@@ -664,7 +662,6 @@ static void pci_set_bus_speed(struct pci_bus *bus)
 	}
 }
 
-
 static struct pci_bus *pci_alloc_child_bus(struct pci_bus *parent,
 					   struct pci_dev *bridge, int busnr)
 {
@@ -729,7 +726,8 @@ static struct pci_bus *pci_alloc_child_bus(struct pci_bus *parent,
 	return child;
 }
 
-struct pci_bus *pci_add_new_bus(struct pci_bus *parent, struct pci_dev *dev, int busnr)
+struct pci_bus *pci_add_new_bus(struct pci_bus *parent, struct pci_dev *dev,
+				int busnr)
 {
 	struct pci_bus *child;
 
@@ -888,7 +886,7 @@ int pci_scan_bridge(struct pci_bus *bus, struct pci_dev *dev, int max, int pass)
 			 * as cards with a PCI-to-PCI bridge can be
 			 * inserted later.
 			 */
-			for (i=0; i<CARDBUS_RESERVE_BUSNR; i++) {
+			for (i = 0; i < CARDBUS_RESERVE_BUSNR; i++) {
 				struct pci_bus *parent = bus;
 				if (pci_find_bus(pci_domain_nr(bus),
 							max+i+1))
@@ -994,7 +992,6 @@ void set_pcie_hotplug_bridge(struct pci_dev *pdev)
 		pdev->is_hotplug_bridge = 1;
 }
 
-
 /**
  * pci_ext_cfg_is_aliased - is ext config space just an alias of std config?
  * @dev: PCI device
@@ -1285,7 +1282,7 @@ struct pci_dev *pci_alloc_dev(struct pci_bus *bus)
 EXPORT_SYMBOL(pci_alloc_dev);
 
 bool pci_bus_read_dev_vendor_id(struct pci_bus *bus, int devfn, u32 *l,
-				 int crs_timeout)
+				int crs_timeout)
 {
 	int delay = 1;
 
@@ -1719,7 +1716,7 @@ unsigned int pci_scan_child_bus(struct pci_bus *bus)
 		bus->is_added = 1;
 	}
 
-	for (pass=0; pass < 2; pass++)
+	for (pass = 0; pass < 2; pass++)
 		list_for_each_entry(dev, &bus->devices, bus_list) {
 			if (pci_is_bridge(dev))
 				max = pci_scan_bridge(bus, dev, max, pass);
@@ -2062,7 +2059,8 @@ void pci_unlock_rescan_remove(void)
 }
 EXPORT_SYMBOL_GPL(pci_unlock_rescan_remove);
 
-static int __init pci_sort_bf_cmp(const struct device *d_a, const struct device *d_b)
+static int __init pci_sort_bf_cmp(const struct device *d_a,
+				  const struct device *d_b)
 {
 	const struct pci_dev *a = to_pci_dev(d_a);
 	const struct pci_dev *b = to_pci_dev(d_b);

commit b7fe943421396b61b9f7a97c2554ed999e0f3658
Author: Ryan Desfosses <ryan@desfo.org>
Date:   Fri Apr 25 14:32:25 2014 -0600

    PCI: Move EXPORT_SYMBOL so it immediately follows function/variable
    
    Move EXPORT_SYMBOL so it immediately follows the function or variable.
    
    No functional change.
    
    [bhelgaas: squash similar changes, fix hotplug, probe, rom, search, too]
    Signed-off-by: Ryan Desfosses <ryan@desfo.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 2bbf5221afb3..96b954f55d0d 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -741,6 +741,7 @@ struct pci_bus *pci_add_new_bus(struct pci_bus *parent, struct pci_dev *dev, int
 	}
 	return child;
 }
+EXPORT_SYMBOL(pci_add_new_bus);
 
 /*
  * If it's a bridge, configure it and scan the bus behind it.
@@ -952,6 +953,7 @@ int pci_scan_bridge(struct pci_bus *bus, struct pci_dev *dev, int max, int pass)
 
 	return max;
 }
+EXPORT_SYMBOL(pci_scan_bridge);
 
 /*
  * Read interrupt line and base address registers.
@@ -1519,6 +1521,7 @@ int pci_scan_slot(struct pci_bus *bus, int devfn)
 
 	return nr;
 }
+EXPORT_SYMBOL(pci_scan_slot);
 
 static int pcie_find_smpss(struct pci_dev *dev, void *data)
 {
@@ -1732,6 +1735,7 @@ unsigned int pci_scan_child_bus(struct pci_bus *bus)
 	dev_dbg(&bus->dev, "bus scan returning with max=%02x\n", max);
 	return max;
 }
+EXPORT_SYMBOL_GPL(pci_scan_child_bus);
 
 /**
  * pcibios_root_bridge_prepare - Platform-specific host bridge setup.
@@ -2040,11 +2044,6 @@ unsigned int pci_rescan_bus(struct pci_bus *bus)
 }
 EXPORT_SYMBOL_GPL(pci_rescan_bus);
 
-EXPORT_SYMBOL(pci_add_new_bus);
-EXPORT_SYMBOL(pci_scan_slot);
-EXPORT_SYMBOL(pci_scan_bridge);
-EXPORT_SYMBOL_GPL(pci_scan_child_bus);
-
 /*
  * pci_rescan_bus(), pci_rescan_bus_bridge_resize() and PCI device removal
  * routines should always be executed under this mutex.

commit fdaf36bd360fe1e74b34262ad705ef39d52c12de
Merge: d1a2523d2adc d97ffe236894
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed May 28 16:21:25 2014 -0600

    Merge branch 'pci/misc' into next
    
    * pci/misc:
      PCI: Fix return value from pci_user_{read,write}_config_*()
      PCI: Turn pcibios_penalize_isa_irq() into a weak function
      PCI: Test for std config alias when testing extended config space

commit d1a2523d2adc0b6910dbc2a9aed44c4217134db1
Merge: 79d458bf4743 cab9a128dad0 56604faed112 782a985d7af2
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed May 28 16:21:07 2014 -0600

    Merge branches 'pci/hotplug', 'pci/pci_is_bridge' and 'pci/virtualization' into next
    
    * pci/hotplug:
      PCI: cpqphp: Fix possible null pointer dereference
      NVMe: Implement PCIe reset notification callback
      PCI: Notify driver before and after device reset
    
    * pci/pci_is_bridge:
      pcmcia: Use pci_is_bridge() to simplify code
      PCI: pciehp: Use pci_is_bridge() to simplify code
      PCI: acpiphp: Use pci_is_bridge() to simplify code
      PCI: cpcihp: Use pci_is_bridge() to simplify code
      PCI: shpchp: Use pci_is_bridge() to simplify code
      PCI: rpaphp: Use pci_is_bridge() to simplify code
      sparc/PCI: Use pci_is_bridge() to simplify code
      powerpc/PCI: Use pci_is_bridge() to simplify code
      ia64/PCI: Use pci_is_bridge() to simplify code
      x86/PCI: Use pci_is_bridge() to simplify code
      PCI: Use pci_is_bridge() to simplify code
      PCI: Add new pci_is_bridge() interface
      PCI: Rename pci_is_bridge() to pci_has_subordinate()
    
    * pci/virtualization:
      PCI: Introduce new device binding path using pci_dev.driver_override
    
    Conflicts:
            drivers/pci/pci-sysfs.c

commit 782a985d7af26db39e86070d28f987cad21313c0
Author: Alex Williamson <alex.williamson@redhat.com>
Date:   Tue May 20 08:53:21 2014 -0600

    PCI: Introduce new device binding path using pci_dev.driver_override
    
    The driver_override field allows us to specify the driver for a device
    rather than relying on the driver to provide a positive match of the
    device.  This shortcuts the existing process of looking up the vendor and
    device ID, adding them to the driver new_id, binding the device, then
    removing the ID, but it also provides a couple advantages.
    
    First, the above existing process allows the driver to bind to any device
    matching the new_id for the window where it's enabled.  This is often not
    desired, such as the case of trying to bind a single device to a meta
    driver like pci-stub or vfio-pci.  Using driver_override we can do this
    deterministically using:
    
      echo pci-stub > /sys/bus/pci/devices/0000:03:00.0/driver_override
      echo 0000:03:00.0 > /sys/bus/pci/devices/0000:03:00.0/driver/unbind
      echo 0000:03:00.0 > /sys/bus/pci/drivers_probe
    
    Previously we could not invoke drivers_probe after adding a device to
    new_id for a driver as we get non-deterministic behavior whether the driver
    we intend or the standard driver will claim the device.  Now it becomes a
    deterministic process, only the driver matching driver_override will probe
    the device.
    
    To return the device to the standard driver, we simply clear the
    driver_override and reprobe the device:
    
      echo > /sys/bus/pci/devices/0000:03:00.0/driver_override
      echo 0000:03:00.0 > /sys/bus/pci/devices/0000:03:00.0/driver/unbind
      echo 0000:03:00.0 > /sys/bus/pci/drivers_probe
    
    Another advantage to this approach is that we can specify a driver override
    to force a specific binding or prevent any binding.  For instance when an
    IOMMU group is exposed to userspace through VFIO we require that all
    devices within that group are owned by VFIO.  However, devices can be
    hot-added into an IOMMU group, in which case we want to prevent the device
    from binding to any driver (override driver = "none") or perhaps have it
    automatically bind to vfio-pci.  With driver_override it's a simple matter
    for this field to be set internally when the device is first discovered to
    prevent driver matches.
    
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Reviewed-by: Alexander Graf <agraf@suse.de>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index ef09f5f2fe6c..54268de45f59 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1215,6 +1215,7 @@ static void pci_release_dev(struct device *dev)
 	pci_release_of_node(pci_dev);
 	pcibios_release_device(pci_dev);
 	pci_bus_put(pci_dev->bus);
+	kfree(pci_dev->driver_override);
 	kfree(pci_dev);
 }
 

commit 78916b00f0096059c872f537306b1a464c84fb30
Author: Alex Williamson <alex.williamson@redhat.com>
Date:   Mon May 5 14:20:51 2014 -0600

    PCI: Test for std config alias when testing extended config space
    
    When a PCI-to-PCIe bridge is stacked on a PCIe-to-PCI bridge, we can have
    PCIe endpoints masked by a conventional PCI bus.  This makes the extended
    config space of the PCIe endpoint inaccessible.  The PCIe-to-PCI bridge is
    supposed to handle any type 1 configuration transactions where the extended
    config offset bits are non-zero as an Unsupported Request rather than
    forward it to the secondary interface.  As noted here, there are a couple
    known offenders to this rule.  These bridges drop the extended offset bits,
    resulting in the conventional config space being aliased many times across
    the extended config space.  For Intel NICs, this alias often seems to
    expose a bogus SR-IOV cap.
    
    Stacking bridges may seem like an uncommon scenario, but note that any
    conventional PCI slot in a modern PC is already the secondary interface of
    an onboard PCIe-to-PCI bridge.  The user need only add a PCI-to-PCIe
    adapter and PCIe device to encounter this problem.
    
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 490031fd2108..b47c2dd5b9e1 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -983,6 +983,43 @@ void set_pcie_hotplug_bridge(struct pci_dev *pdev)
 }
 
 
+/**
+ * pci_ext_cfg_is_aliased - is ext config space just an alias of std config?
+ * @dev: PCI device
+ *
+ * PCI Express to PCI/PCI-X Bridge Specification, rev 1.0, 4.1.4 says that
+ * when forwarding a type1 configuration request the bridge must check that
+ * the extended register address field is zero.  The bridge is not permitted
+ * to forward the transactions and must handle it as an Unsupported Request.
+ * Some bridges do not follow this rule and simply drop the extended register
+ * bits, resulting in the standard config space being aliased, every 256
+ * bytes across the entire configuration space.  Test for this condition by
+ * comparing the first dword of each potential alias to the vendor/device ID.
+ * Known offenders:
+ *   ASM1083/1085 PCIe-to-PCI Reversible Bridge (1b21:1080, rev 01 & 03)
+ *   AMD/ATI SBx00 PCI to PCI Bridge (1002:4384, rev 40)
+ */
+static bool pci_ext_cfg_is_aliased(struct pci_dev *dev)
+{
+#ifdef CONFIG_PCI_QUIRKS
+	int pos;
+	u32 header, tmp;
+
+	pci_read_config_dword(dev, PCI_VENDOR_ID, &header);
+
+	for (pos = PCI_CFG_SPACE_SIZE;
+	     pos < PCI_CFG_SPACE_EXP_SIZE; pos += PCI_CFG_SPACE_SIZE) {
+		if (pci_read_config_dword(dev, pos, &tmp) != PCIBIOS_SUCCESSFUL
+		    || header != tmp)
+			return false;
+	}
+
+	return true;
+#else
+	return false;
+#endif
+}
+
 /**
  * pci_cfg_space_size - get the configuration space size of the PCI device.
  * @dev: PCI device
@@ -1001,7 +1038,7 @@ static int pci_cfg_space_size_ext(struct pci_dev *dev)
 
 	if (pci_read_config_dword(dev, pos, &status) != PCIBIOS_SUCCESSFUL)
 		goto fail;
-	if (status == 0xffffffff)
+	if (status == 0xffffffff || pci_ext_cfg_is_aliased(dev))
 		goto fail;
 
 	return PCI_CFG_SPACE_EXP_SIZE;

commit 6788a51fe3391817c8ded5f43dd4c57f3d212c17
Author: Yijing Wang <wangyijing@huawei.com>
Date:   Sun May 4 12:23:38 2014 +0800

    PCI: Use pci_is_bridge() to simplify code
    
    Use pci_is_bridge() to simplify code.  No functional change.
    
    Requires: 326c1cdae741 PCI: Rename pci_is_bridge() to pci_has_subordinate()
    Requires: 1c86438c9423 PCI: Add new pci_is_bridge() interface
    Signed-off-by: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index ef09f5f2fe6c..f831dd80fa2d 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1670,8 +1670,7 @@ unsigned int pci_scan_child_bus(struct pci_bus *bus)
 
 	for (pass=0; pass < 2; pass++)
 		list_for_each_entry(dev, &bus->devices, bus_list) {
-			if (dev->hdr_type == PCI_HEADER_TYPE_BRIDGE ||
-			    dev->hdr_type == PCI_HEADER_TYPE_CARDBUS)
+			if (pci_is_bridge(dev))
 				max = pci_scan_bridge(bus, dev, max, pass);
 		}
 

commit e5558d1a516fa6924fa8d53152b665d4c26f142e
Merge: 518a6a34f645 14574674e461 3cb30b73ad71 034cd97ebda4 9edbcd2252b5 67d29b5c6c40
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon May 26 17:29:17 2014 -0600

    Merge branches 'dma-api', 'pci/virtualization', 'pci/msi', 'pci/misc' and 'pci/resource' into next
    
    * dma-api:
      iommu/exynos: Remove unnecessary "&" from function pointers
      DMA-API: Update dma_pool_create ()and dma_pool_alloc() descriptions
      DMA-API: Fix duplicated word in DMA-API-HOWTO.txt
      DMA-API: Capitalize "CPU" consistently
      sh/PCI: Pass GAPSPCI_DMA_BASE CPU & bus address to dma_declare_coherent_memory()
      DMA-API: Change dma_declare_coherent_memory() CPU address to phys_addr_t
      DMA-API: Clarify physical/bus address distinction
    
    * pci/virtualization:
      PCI: Mark RTL8110SC INTx masking as broken
    
    * pci/msi:
      PCI/MSI: Remove pci_enable_msi_block()
    
    * pci/misc:
      PCI: Remove pcibios_add_platform_entries()
      s390/pci: use pdev->dev.groups for attribute creation
      PCI: Move Open Firmware devspec attribute to PCI common code
    
    * pci/resource:
      PCI: Add resource allocation comments
      PCI: Simplify __pci_assign_resource() coding style
      PCI: Change pbus_size_mem() return values to be more conventional
      PCI: Restrict 64-bit prefetchable bridge windows to 64-bit resources
      PCI: Support BAR sizes up to 8GB
      resources: Clarify sanity check message
      PCI: Don't add disabled subtractive decode bus resources
      PCI: Don't print anything while decoding is disabled
      PCI: Don't set BAR to zero if dma_addr_t is too small
      PCI: Don't convert BAR address to resource if dma_addr_t is too small
      PCI: Reject BAR above 4GB if dma_addr_t is too small
      PCI: Fail safely if we can't handle BARs larger than 4GB
      x86/gart: Tidy messages and add bridge device info
      x86/gart: Replace printk() with pr_info()
      x86/PCI: Move pcibios_assign_resources() annotation to definition
      x86/PCI: Mark ATI SBx00 HPET BAR as IORESOURCE_PCI_FIXED
      x86/PCI: Don't try to move IORESOURCE_PCI_FIXED resources
      x86/PCI: Fix Broadcom CNB20LE unintended sign extension

commit d739a099d0248c78d374b1b610cdb679c7bc052d
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Apr 14 16:10:54 2014 -0600

    PCI: Don't add disabled subtractive decode bus resources
    
    For a subtractive decode bridge, we previously added and printed all
    resources of the primary bus, even if they were not valid.  In the example
    below, the bridge 00:1c.3 has no windows enabled, so there are no valid
    resources on bus 02.  But since 02:00.0 is subtractive decode bridge, we
    add and print all those invalid resources, which don't really make sense:
    
      pci 0000:00:1c.3: PCI bridge to [bus 02-03]
      pci 0000:02:00.0: PCI bridge to [bus 03] (subtractive decode)
      pci 0000:02:00.0:   bridge window [??? 0x00000000 flags 0x0] (subtractive decode)
    
    Add and print the subtractively-decoded resources only if they are valid.
    
    There's an example in the dmesg log attached to the bugzilla below (but
    this patch doesn't fix the bug reported there).
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=73141
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 3bc149b848a8..966514010974 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -475,7 +475,7 @@ void pci_read_bridge_bases(struct pci_bus *child)
 
 	if (dev->transparent) {
 		pci_bus_for_each_resource(child->parent, res, i) {
-			if (res) {
+			if (res && res->flags) {
 				pci_bus_add_resource(child, res,
 						     PCI_SUBTRACTIVE_DECODE);
 				dev_printk(KERN_DEBUG, &dev->dev,

commit 26370fc6647b63eefb85a675382d661d0fed30a1
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Apr 14 15:26:50 2014 -0600

    PCI: Don't print anything while decoding is disabled
    
    If the console is a PCI device, and we try to print to it while its
    decoding is disabled, the system will hang.  This particular printk hasn't
    caused a problem yet, but it could, so this fixes it.
    
    See also 0ff9514b579b ("PCI: Don't print anything while decoding is
    disabled").
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index dd710b12d34c..3bc149b848a8 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -174,7 +174,7 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 	u64 l64, sz64, mask64;
 	u16 orig_cmd;
 	struct pci_bus_region region, inverted_region;
-	bool bar_too_big = false, bar_too_high = false;
+	bool bar_too_big = false, bar_too_high = false, bar_invalid = false;
 
 	mask = type ? PCI_ROM_ADDRESS_MASK : ~0;
 
@@ -289,11 +289,10 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 	 * be claimed by the device.
 	 */
 	if (inverted_region.start != region.start) {
-		dev_info(&dev->dev, "reg 0x%x: initial BAR value %pa invalid; forcing reassignment\n",
-			 pos, &region.start);
 		res->flags |= IORESOURCE_UNSET;
-		res->end -= res->start;
 		res->start = 0;
+		res->end = region.end - region.start;
+		bar_invalid = true;
 	}
 
 	goto out;
@@ -312,6 +311,9 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 	if (bar_too_high)
 		dev_info(&dev->dev, "reg 0x%x: can't handle BAR above 4G (bus address %#010llx)\n",
 			 pos, (unsigned long long) l64);
+	if (bar_invalid)
+		dev_info(&dev->dev, "reg 0x%x: initial BAR value %#010llx invalid\n",
+			 pos, (unsigned long long) region.start);
 	if (res->flags)
 		dev_printk(KERN_DEBUG, &dev->dev, "reg 0x%x: %pR\n", pos, res);
 

commit 31e9dd2565a6e27a3e698d7e3adf929db8d6c767
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Apr 29 18:37:47 2014 -0600

    PCI: Don't set BAR to zero if dma_addr_t is too small
    
    If a BAR is above 4GB and our dma_addr_t is too small, don't clear the BAR
    to zero: that doesn't disable the BAR, and it makes it more likely that the
    BAR will conflict with things if we turn on the memory enable bit (as we
    will at "out:" if the device was already enabled at the handoff).
    
    We should also print the BAR info and its original size so we can follow
    the process when we try to assign space to it.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 82cd75f6118a..dd710b12d34c 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -174,7 +174,7 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 	u64 l64, sz64, mask64;
 	u16 orig_cmd;
 	struct pci_bus_region region, inverted_region;
-	bool bar_too_big = false, bar_disabled = false;
+	bool bar_too_big = false, bar_too_high = false;
 
 	mask = type ? PCI_ROM_ADDRESS_MASK : ~0;
 
@@ -254,13 +254,11 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 		}
 
 		if ((sizeof(dma_addr_t) < 8) && l) {
-			/* Address above 32-bit boundary; disable the BAR */
-			pci_write_config_dword(dev, pos, 0);
-			pci_write_config_dword(dev, pos + 4, 0);
+			/* Above 32-bit boundary; try to reallocate */
 			res->flags |= IORESOURCE_UNSET;
 			res->start = 0;
 			res->end = sz64;
-			bar_disabled = true;
+			bar_too_high = true;
 			goto out;
 		} else {
 			region.start = l64;
@@ -311,7 +309,10 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 	if (bar_too_big)
 		dev_err(&dev->dev, "reg 0x%x: can't handle BAR larger than 4GB (size %#010llx)\n",
 			pos, (unsigned long long) sz64);
-	if (res->flags && !bar_disabled)
+	if (bar_too_high)
+		dev_info(&dev->dev, "reg 0x%x: can't handle BAR above 4G (bus address %#010llx)\n",
+			 pos, (unsigned long long) l64);
+	if (res->flags)
 		dev_printk(KERN_DEBUG, &dev->dev, "reg 0x%x: %pR\n", pos, res);
 
 	return (res->flags & IORESOURCE_MEM_64) ? 1 : 0;

commit 72dc5601fe5fec37cc1bd0efb19d99948fe7e54c
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Apr 29 18:42:49 2014 -0600

    PCI: Don't convert BAR address to resource if dma_addr_t is too small
    
    If dma_addr_t is too small to represent the BAR value,
    pcibios_bus_to_resource() will fail, so just remember the BAR size directly
    in the resource.  The resource is already marked UNSET, so we know the
    address isn't valid anyway.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index afae3bf405fa..82cd75f6118a 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -258,9 +258,10 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 			pci_write_config_dword(dev, pos, 0);
 			pci_write_config_dword(dev, pos + 4, 0);
 			res->flags |= IORESOURCE_UNSET;
-			region.start = 0;
-			region.end = sz64;
+			res->start = 0;
+			res->end = sz64;
 			bar_disabled = true;
+			goto out;
 		} else {
 			region.start = l64;
 			region.end = l64 + sz64;

commit d1a313e4b6ccbb61c746ee10ac198970516e9afc
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Apr 29 18:33:09 2014 -0600

    PCI: Reject BAR above 4GB if dma_addr_t is too small
    
    We can only handle BARs above 4GB if dma_addr_t (not resource_size_t) is 64
    bits wide.  If we have a 64-bit resource_size_t and a 32-bit dma_addr_t,
    we can't deal with BARs above 4GB.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index c7f8b717c2e7..afae3bf405fa 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -253,7 +253,7 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 			goto out;
 		}
 
-		if ((sizeof(resource_size_t) < 8) && l) {
+		if ((sizeof(dma_addr_t) < 8) && l) {
 			/* Address above 32-bit boundary; disable the BAR */
 			pci_write_config_dword(dev, pos, 0);
 			pci_write_config_dword(dev, pos + 4, 0);

commit 23b13bc76f359e99140baf083dc44314f4eb1b87
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Apr 14 15:25:54 2014 -0600

    PCI: Fail safely if we can't handle BARs larger than 4GB
    
    We can only handle BARs larger than 4GB if both dma_addr_t and
    resource_size_t are 64 bits wide.  If dma_addr_t is 32 bits, we can't
    represent all the bus addresses, and if resource_size_t is 32 bits, we
    can't represent all the CPU addresses.
    
    Previously we cleared res->flags (at "fail:") for resources that were too
    large.  That means we think the BAR doesn't exist at all, which in turn
    means that we could enable the device even though we can't keep track of
    where the BAR is and we can't make sure it doesn't overlap something else.
    
    This preserves the type flags (MEM/IO) so we can keep from enabling the
    device.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index ef09f5f2fe6c..c7f8b717c2e7 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -171,6 +171,7 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 			struct resource *res, unsigned int pos)
 {
 	u32 l, sz, mask;
+	u64 l64, sz64, mask64;
 	u16 orig_cmd;
 	struct pci_bus_region region, inverted_region;
 	bool bar_too_big = false, bar_disabled = false;
@@ -226,9 +227,9 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 	}
 
 	if (res->flags & IORESOURCE_MEM_64) {
-		u64 l64 = l;
-		u64 sz64 = sz;
-		u64 mask64 = mask | (u64)~0 << 32;
+		l64 = l;
+		sz64 = sz;
+		mask64 = mask | (u64)~0 << 32;
 
 		pci_read_config_dword(dev, pos + 4, &l);
 		pci_write_config_dword(dev, pos + 4, ~0);
@@ -243,9 +244,13 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 		if (!sz64)
 			goto fail;
 
-		if ((sizeof(resource_size_t) < 8) && (sz64 > 0x100000000ULL)) {
+		if ((sizeof(dma_addr_t) < 8 || sizeof(resource_size_t) < 8) &&
+		    sz64 > 0x100000000ULL) {
+			res->flags |= IORESOURCE_UNSET | IORESOURCE_DISABLED;
+			res->start = 0;
+			res->end = 0;
 			bar_too_big = true;
-			goto fail;
+			goto out;
 		}
 
 		if ((sizeof(resource_size_t) < 8) && l) {
@@ -303,7 +308,8 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 		pci_write_config_word(dev, PCI_COMMAND, orig_cmd);
 
 	if (bar_too_big)
-		dev_err(&dev->dev, "reg 0x%x: can't handle 64-bit BAR\n", pos);
+		dev_err(&dev->dev, "reg 0x%x: can't handle BAR larger than 4GB (size %#010llx)\n",
+			pos, (unsigned long long) sz64);
 	if (res->flags && !bar_disabled)
 		dev_printk(KERN_DEBUG, &dev->dev, "reg 0x%x: %pR\n", pos, res);
 

commit 1e358f94c00570f88a590cabe718daf835440cc9
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Apr 29 12:51:55 2014 -0600

    PCI: Fix use of uninitialized MPS value
    
    If "pcie_bus_config == PCIE_BUS_PERFORMANCE", we don't initialize "smpss",
    so we pass a pointer to garbage into pcie_bus_configure_set(), where we
    compute "mps" based on the garbage.  We then pass the garbage "mps" to
    pcie_write_mps(), which ignores it in the PCIE_BUS_PERFORMANCE case.
    
    Coverity isn't smart enough to deduce that we ignore the garbage (it's a
    lot to expect from a human, too), so initialize "smpss" to a safe value in
    all cases.
    
    Found by Coverity (CID 146454).
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index fe89a982a3da..490031fd2108 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1617,7 +1617,7 @@ static int pcie_bus_configure_set(struct pci_dev *dev, void *data)
  */
 void pcie_bus_configure_settings(struct pci_bus *bus)
 {
-	u8 smpss;
+	u8 smpss = 0;
 
 	if (!bus->self)
 		return;

commit 10874f5a00266343a06e95da680e8a5a383d9a80
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Apr 14 16:11:40 2014 -0600

    PCI: Remove unnecessary __ref annotations
    
    Some PCI functions used to be marked __devinit.  When CONFIG_HOTPLUG was
    not set, these functions were discarded after boot.  A few callers of these
    __devinit functions were marked __ref to indicate that they could safely
    call the __devinit functions even though the callers were not __devinit.
    
    But CONFIG_HOTPLUG and __devinit are now gone, and the need for the __ref
    annotations is also gone, so remove them.  Relevant historical commits:
    
      54b956b90360 Remove __dev* markings from init.h
      a8e4b9c101ae PCI: add generic pci_hp_add_bridge()
      0ab2b57f8db8 PCI: fix section mismatch warning in pci_scan_child_bus
      451124a7cc6c PCI: fix 4x section mismatch warnings
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index ef09f5f2fe6c..fe89a982a3da 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -719,7 +719,7 @@ static struct pci_bus *pci_alloc_child_bus(struct pci_bus *parent,
 	return child;
 }
 
-struct pci_bus *__ref pci_add_new_bus(struct pci_bus *parent, struct pci_dev *dev, int busnr)
+struct pci_bus *pci_add_new_bus(struct pci_bus *parent, struct pci_dev *dev, int busnr)
 {
 	struct pci_bus *child;
 
@@ -1369,7 +1369,7 @@ void pci_device_add(struct pci_dev *dev, struct pci_bus *bus)
 	WARN_ON(ret < 0);
 }
 
-struct pci_dev *__ref pci_scan_single_device(struct pci_bus *bus, int devfn)
+struct pci_dev *pci_scan_single_device(struct pci_bus *bus, int devfn)
 {
 	struct pci_dev *dev;
 
@@ -1958,7 +1958,7 @@ EXPORT_SYMBOL(pci_scan_bus);
  *
  * Returns the max number of subordinate bus discovered.
  */
-unsigned int __ref pci_rescan_bus_bridge_resize(struct pci_dev *bridge)
+unsigned int pci_rescan_bus_bridge_resize(struct pci_dev *bridge)
 {
 	unsigned int max;
 	struct pci_bus *bus = bridge->subordinate;
@@ -1981,7 +1981,7 @@ unsigned int __ref pci_rescan_bus_bridge_resize(struct pci_dev *bridge)
  *
  * Returns the max number of subordinate bus discovered.
  */
-unsigned int __ref pci_rescan_bus(struct pci_bus *bus)
+unsigned int pci_rescan_bus(struct pci_bus *bus)
 {
 	unsigned int max;
 

commit 30723cbf6f7aec2ab4810bdc4bf12c5749a09e33
Merge: 91b4adc983d8 f2e6027b816d
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Mar 19 15:11:19 2014 -0600

    Merge branch 'pci/resource' into next
    
    * pci/resource: (26 commits)
      Revert "[PATCH] Insert GART region into resource map"
      PCI: Log IDE resource quirk in dmesg
      PCI: Change pci_bus_alloc_resource() type_mask to unsigned long
      PCI: Check all IORESOURCE_TYPE_BITS in pci_bus_alloc_from_region()
      resources: Set type in __request_region()
      PCI: Don't check resource_size() in pci_bus_alloc_resource()
      s390/PCI: Use generic pci_enable_resources()
      tile PCI RC: Use default pcibios_enable_device()
      sparc/PCI: Use default pcibios_enable_device() (Leon only)
      sh/PCI: Use default pcibios_enable_device()
      microblaze/PCI: Use default pcibios_enable_device()
      alpha/PCI: Use default pcibios_enable_device()
      PCI: Add "weak" generic pcibios_enable_device() implementation
      PCI: Don't enable decoding if BAR hasn't been assigned an address
      PCI: Mark 64-bit resource as IORESOURCE_UNSET if we only support 32-bit
      PCI: Don't try to claim IORESOURCE_UNSET resources
      PCI: Check IORESOURCE_UNSET before updating BAR
      PCI: Don't clear IORESOURCE_UNSET when updating BAR
      PCI: Mark resources as IORESOURCE_UNSET if we can't assign them
      PCI: Remove pci_find_parent_resource() use for allocation
      ...

commit 075eb9e35578c23ee2414f87d97d2e5065aa1bc1
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Mar 5 14:07:03 2014 -0700

    PCI: Log IDE resource quirk in dmesg
    
    Make a note in dmesg when we overwrite legacy IDE BAR info.  We previously
    logged something like this:
    
      pci 0000:00:1f.1: reg 0x10: [io  0x0000-0x0007]
    
    and then silently overwrote the resource.  There's an example in the
    bugzilla below.  This doesn't fix the bugzilla; it just makes what's going
    on more obvious.
    
    No functional change; merely adds some dev_info() calls.
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=48451
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 78335efbbb74..93dad114eaef 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1126,10 +1126,10 @@ int pci_setup_device(struct pci_dev *dev)
 		pci_read_config_word(dev, PCI_SUBSYSTEM_ID, &dev->subsystem_device);
 
 		/*
-		 *	Do the ugly legacy mode stuff here rather than broken chip
-		 *	quirk code. Legacy mode ATA controllers have fixed
-		 *	addresses. These are not always echoed in BAR0-3, and
-		 *	BAR0-3 in a few cases contain junk!
+		 * Do the ugly legacy mode stuff here rather than broken chip
+		 * quirk code. Legacy mode ATA controllers have fixed
+		 * addresses. These are not always echoed in BAR0-3, and
+		 * BAR0-3 in a few cases contain junk!
 		 */
 		if (class == PCI_CLASS_STORAGE_IDE) {
 			u8 progif;
@@ -1140,11 +1140,15 @@ int pci_setup_device(struct pci_dev *dev)
 				res = &dev->resource[0];
 				res->flags = LEGACY_IO_RESOURCE;
 				pcibios_bus_to_resource(dev->bus, res, &region);
+				dev_info(&dev->dev, "legacy IDE quirk: reg 0x10: %pR\n",
+					 res);
 				region.start = 0x3F6;
 				region.end = 0x3F6;
 				res = &dev->resource[1];
 				res->flags = LEGACY_IO_RESOURCE;
 				pcibios_bus_to_resource(dev->bus, res, &region);
+				dev_info(&dev->dev, "legacy IDE quirk: reg 0x14: %pR\n",
+					 res);
 			}
 			if ((progif & 4) == 0) {
 				region.start = 0x170;
@@ -1152,11 +1156,15 @@ int pci_setup_device(struct pci_dev *dev)
 				res = &dev->resource[2];
 				res->flags = LEGACY_IO_RESOURCE;
 				pcibios_bus_to_resource(dev->bus, res, &region);
+				dev_info(&dev->dev, "legacy IDE quirk: reg 0x18: %pR\n",
+					 res);
 				region.start = 0x376;
 				region.end = 0x376;
 				res = &dev->resource[3];
 				res->flags = LEGACY_IO_RESOURCE;
 				pcibios_bus_to_resource(dev->bus, res, &region);
+				dev_info(&dev->dev, "legacy IDE quirk: reg 0x1c: %pR\n",
+					 res);
 			}
 		}
 		break;

commit c83bd900aac38552b0d903588bbb084d3b26fe71
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Feb 26 11:26:00 2014 -0700

    PCI: Mark 64-bit resource as IORESOURCE_UNSET if we only support 32-bit
    
    If we don't support 64-bit addresses, i.e., CONFIG_PHYS_ADDR_T_64BIT is not
    set, we can't deal with BARs above 4GB.  In this case we already pretend
    the BAR contained zero; this patch also sets IORESOURCE_UNSET so we can try
    to reallocate it later.
    
    I don't think this is exactly correct: what we care about here are *bus*
    addresses, not CPU addresses, so the tests of sizeof(resource_size_t)
    probably should be on sizeof(dma_addr_t) instead.  But this is what's been
    in -next, so we'll fix that later.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 6e34498ec9f0..78335efbbb74 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -252,6 +252,7 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 			/* Address above 32-bit boundary; disable the BAR */
 			pci_write_config_dword(dev, pos, 0);
 			pci_write_config_dword(dev, pos + 4, 0);
+			res->flags |= IORESOURCE_UNSET;
 			region.start = 0;
 			region.end = sz64;
 			bar_disabled = true;

commit fc1b253141b360f9c669d391b4ff663b984ef0c9
Author: Andreas Noever <andreas.noever@gmail.com>
Date:   Thu Jan 23 21:59:28 2014 +0100

    PCI: Don't scan random busses in pci_scan_bridge()
    
    When assigning a new bus number in pci_scan_bridge we check whether
    max+1 is free by calling pci_find_bus. If it does already exist then we
    assume that we are rescanning and that this is the right bus to scan.
    
    This is fragile. If max+1 lies outside of bus->busn_res.end then we will
    rescan some random bus from somewhere else in the hierachy. This patch
    checks for this case and prints a warning.
    
    [bhelgaas: add parent/child bus number info to dev_warn()]
    Signed-off-by: Andreas Noever <andreas.noever@gmail.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 1436288924c3..509494381a7a 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -829,12 +829,16 @@ int pci_scan_bridge(struct pci_bus *bus, struct pci_dev *dev, int max, int pass)
 			goto out;
 		}
 
+		if (max >= bus->busn_res.end) {
+			dev_warn(&dev->dev, "can't allocate child bus %02x from %pR\n",
+				 max, &bus->busn_res);
+			goto out;
+		}
+
 		/* Clear errors */
 		pci_write_config_word(dev, PCI_STATUS, 0xffff);
 
-		/* Prevent assigning a bus number that already exists.
-		 * This can happen when a bridge is hot-plugged, so in
-		 * this case we only re-scan this bus. */
+		/* The bus will already exist if we are rescanning */
 		child = pci_find_bus(pci_domain_nr(bus), max+1);
 		if (!child) {
 			child = pci_add_new_bus(bus, dev, max+1);

commit c95b0bd6ca3dbb1abf8394c38d26df65d890cb9a
Author: Andreas Noever <andreas.noever@gmail.com>
Date:   Thu Jan 23 21:59:27 2014 +0100

    PCI: Check for child busses which use more bus numbers than allocated
    
    pci_scan_child_bus can (potentially) return a bus number higher than the
    subordinate value of the child bus. Possible reasons are that bus numbers
    are reserved for SR-IOV or for CardBus (SR-IOV is done without checks and
    the CardBus checks are sketchy at best).
    
    We clamp the returned value to the actual subordinate value and print a
    warning if too many bus numbers are reserved.
    
    [bhelgaas: whitespace]
    Signed-off-by: Andreas Noever <andreas.noever@gmail.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index e5df03669470..1436288924c3 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -805,10 +805,12 @@ int pci_scan_bridge(struct pci_bus *bus, struct pci_dev *dev, int max, int pass)
 		}
 
 		cmax = pci_scan_child_bus(child);
-		if (cmax > max)
-			max = cmax;
-		if (child->busn_res.end > max)
-			max = child->busn_res.end;
+		if (cmax > subordinate)
+			dev_warn(&dev->dev, "bridge has subordinate %02x but max busn %02x\n",
+				 subordinate, cmax);
+		/* subordinate should equal child->busn_res.end */
+		if (subordinate > max)
+			max = subordinate;
 	} else {
 		/*
 		 * We need to assign a number to this bus which we always

commit f5fb40700fc9a52944fbe07148c858a5025908b1
Author: Andreas Noever <andreas.noever@gmail.com>
Date:   Thu Jan 23 21:59:26 2014 +0100

    PCI: Remove pci_fixup_parent_subordinate_busnr()
    
    The function has no effect.
    
    If pcibios_assign_all_busses() is not set then the function does nothing.
    
    If it is set then in pci_scan_bridge we are always in the branch where
    we assign the bus numbers ourselves and the subordinate values of all
    parent busses will be set to 0xff since that is what they inherited from
    their parent bus and ultimately from the root bus.
    
    Signed-off-by: Andreas Noever <andreas.noever@gmail.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 9a641cc4275d..e5df03669470 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -731,22 +731,6 @@ struct pci_bus *__ref pci_add_new_bus(struct pci_bus *parent, struct pci_dev *de
 	return child;
 }
 
-static void pci_fixup_parent_subordinate_busnr(struct pci_bus *child, int max)
-{
-	struct pci_bus *parent = child->parent;
-
-	/* Attempts to fix that up are really dangerous unless
-	   we're going to re-assign all bus numbers. */
-	if (!pcibios_assign_all_busses())
-		return;
-
-	while (parent->parent && parent->busn_res.end < max) {
-		parent->busn_res.end = max;
-		pci_write_config_byte(parent->self, PCI_SUBORDINATE_BUS, max);
-		parent = parent->parent;
-	}
-}
-
 /*
  * If it's a bridge, configure it and scan the bus behind it.
  * For CardBus bridges, we don't scan behind as the devices will
@@ -879,20 +863,7 @@ int pci_scan_bridge(struct pci_bus *bus, struct pci_dev *dev, int max, int pass)
 
 		if (!is_cardbus) {
 			child->bridge_ctl = bctl;
-			/*
-			 * Adjust subordinate busnr in parent buses.
-			 * We do this before scanning for children because
-			 * some devices may not be detected if the bios
-			 * was lazy.
-			 */
-			pci_fixup_parent_subordinate_busnr(child, max);
-			/* Now we can scan all subordinate buses... */
 			max = pci_scan_child_bus(child);
-			/*
-			 * now fix it up again since we have found
-			 * the real value of max.
-			 */
-			pci_fixup_parent_subordinate_busnr(child, max);
 		} else {
 			/*
 			 * For CardBus bridges, we leave 4 bus numbers
@@ -923,7 +894,6 @@ int pci_scan_bridge(struct pci_bus *bus, struct pci_dev *dev, int max, int pass)
 				}
 			}
 			max += i;
-			pci_fixup_parent_subordinate_busnr(child, max);
 		}
 		/*
 		 * Set the subordinate bus number to its real value.

commit 1820ffdccb9b4398c5f0f70360edc68e039c3c72
Author: Andreas Noever <andreas.noever@gmail.com>
Date:   Thu Jan 23 21:59:25 2014 +0100

    PCI: Make sure bus number resources stay within their parents bounds
    
    Right now we use 0xff for busn_res.end when probing and later reduce it to
    the value that is actually used. This does not work if a parent bridge has
    already a lower subordinate value. For example during hotplug of a new
    bridge below an already-configured bridge the following message is printed
    from pci_bus_insert_busn_res():
    
      pci_bus 0000:06: busn_res: can not insert [bus 06-ff] under [bus 05-9b] (conflicts with (null) [bus 05-9b])
    
    This patch clamps the bus range to that of the parent and also ensures that
    we do not exceed the parents range when assigning the final subordinate
    value.
    
    We also check that busses configured by the firmware fit into their parents
    bounds.
    
    [bhelgaas: reword dev_warn() and fix printk format warning]
    Signed-off-by: Andreas Noever <andreas.noever@gmail.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 21f162c5c7bb..9a641cc4275d 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -782,7 +782,7 @@ int pci_scan_bridge(struct pci_bus *bus, struct pci_dev *dev, int max, int pass)
 	/* Check if setup is sensible at all */
 	if (!pass &&
 	    (primary != bus->number || secondary <= bus->number ||
-	     secondary > subordinate)) {
+	     secondary > subordinate || subordinate > bus->busn_res.end)) {
 		dev_info(&dev->dev, "bridge configuration invalid ([bus %02x-%02x]), reconfiguring\n",
 			 secondary, subordinate);
 		broken = 1;
@@ -854,7 +854,8 @@ int pci_scan_bridge(struct pci_bus *bus, struct pci_dev *dev, int max, int pass)
 			child = pci_add_new_bus(bus, dev, max+1);
 			if (!child)
 				goto out;
-			pci_bus_insert_busn_res(child, max+1, 0xff);
+			pci_bus_insert_busn_res(child, max+1,
+						bus->busn_res.end);
 		}
 		max++;
 		buses = (buses & 0xff000000)
@@ -927,6 +928,11 @@ int pci_scan_bridge(struct pci_bus *bus, struct pci_dev *dev, int max, int pass)
 		/*
 		 * Set the subordinate bus number to its real value.
 		 */
+		if (max > bus->busn_res.end) {
+			dev_warn(&dev->dev, "max busn %02x is outside %pR\n",
+				 max, &bus->busn_res);
+			max = bus->busn_res.end;
+		}
 		pci_bus_update_busn_res_end(child, max);
 		pci_write_config_byte(dev, PCI_SUBORDINATE_BUS, max);
 	}

commit ced04d15519a15d38b46162b94a1f26b4022116e
Author: Andreas Noever <andreas.noever@gmail.com>
Date:   Thu Jan 23 21:59:24 2014 +0100

    PCI: Use request_resource_conflict() instead of insert_ for bus numbers
    
    If a conflict happens during insert_resource_conflict() and all conflicts
    fit within the newly inserted resource then they will become children of
    the new resource. This is almost certainly not what we want for bus
    numbers.
    
    Signed-off-by: Andreas Noever <andreas.noever@gmail.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 5dc8e1a31e4f..21f162c5c7bb 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1835,7 +1835,7 @@ int pci_bus_insert_busn_res(struct pci_bus *b, int bus, int bus_max)
 		res->flags |= IORESOURCE_PCI_FIXED;
 	}
 
-	conflict = insert_resource_conflict(parent_res, res);
+	conflict = request_resource_conflict(parent_res, res);
 
 	if (conflict)
 		dev_printk(KERN_DEBUG, &b->dev,

commit 619c8c310f7f21e59a7e2b53795183c34401a599
Author: Andreas Noever <andreas.noever@gmail.com>
Date:   Thu Jan 23 21:59:23 2014 +0100

    PCI: Assign CardBus bus number only during the second pass
    
    Right now the CardBus code in pci_scan_bridge() is executed during both
    passes. Since we always allocate the bus number ourselves it makes sense
    to put it into the second pass.
    
    Signed-off-by: Andreas Noever <andreas.noever@gmail.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 511a8f6d7636..5dc8e1a31e4f 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -831,7 +831,7 @@ int pci_scan_bridge(struct pci_bus *bus, struct pci_dev *dev, int max, int pass)
 		 * do in the second pass.
 		 */
 		if (!pass) {
-			if (pcibios_assign_all_busses() || broken)
+			if (pcibios_assign_all_busses() || broken || is_cardbus)
 				/* Temporarily disable forwarding of the
 				   configuration cycles on all bridges in
 				   this bus segment to avoid possible

commit 2ed8582341f651ca14d00ab0ada4b46f493e1fcb
Author: Andreas Noever <andreas.noever@gmail.com>
Date:   Thu Jan 23 21:59:22 2014 +0100

    PCI: Clarify the "scan anyway" comment in pci_scan_bridge()
    
    Initially when we encountered a bus that was already present we skipped
    it. Since 74710ded8e16 'PCI: always scan child buses' we continue
    scanning in order to allow user triggered rescans of already existing
    busses.
    
    The old comment suggested that the reason for continuing the scan is a
    bug in the i450NX chipset. This is not the case.
    
    Signed-off-by: Andreas Noever <andreas.noever@gmail.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index f340c947d8cb..511a8f6d7636 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -805,11 +805,10 @@ int pci_scan_bridge(struct pci_bus *bus, struct pci_dev *dev, int max, int pass)
 			goto out;
 
 		/*
-		 * If we already got to this bus through a different bridge,
-		 * don't re-add it. This can happen with the i450NX chipset.
-		 *
-		 * However, we continue to descend down the hierarchy and
-		 * scan remaining child buses.
+		 * The bus might already exist for two reasons: Either we are
+		 * rescanning the bus or the bus is reachable through more than
+		 * one bridge. The second case can happen with the i450NX
+		 * chipset.
 		 */
 		child = pci_find_bus(pci_domain_nr(bus), secondary);
 		if (!child) {

commit 9a4d7d87197e3ff9138981e196aa5021d13a51a8
Author: Andreas Noever <andreas.noever@gmail.com>
Date:   Thu Jan 23 21:59:21 2014 +0100

    PCI: Increment max correctly in pci_scan_bridge()
    
    This patch fixes two small issues:
     - If pci_add_new_bus() fails, max must not be incremented. Otherwise
       an incorrect value is returned from pci_scan_bridge().
     - If the bus is already present, max must be incremented. I think
       that this case should only be hit if we trigger a manual rescan of a
       CardBus bridge.
    
    Signed-off-by: Andreas Noever <andreas.noever@gmail.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 6e34498ec9f0..f340c947d8cb 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -852,11 +852,12 @@ int pci_scan_bridge(struct pci_bus *bus, struct pci_dev *dev, int max, int pass)
 		 * this case we only re-scan this bus. */
 		child = pci_find_bus(pci_domain_nr(bus), max+1);
 		if (!child) {
-			child = pci_add_new_bus(bus, dev, ++max);
+			child = pci_add_new_bus(bus, dev, max+1);
 			if (!child)
 				goto out;
-			pci_bus_insert_busn_res(child, max, 0xff);
+			pci_bus_insert_busn_res(child, max+1, 0xff);
 		}
+		max++;
 		buses = (buses & 0xff000000)
 		      | ((unsigned int)(child->primary)     <<  0)
 		      | ((unsigned int)(child->busn_res.start)   <<  8)

commit 04480094de7242d08bb62088e713fd7fe00443b4
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Feb 1 15:38:29 2014 +0100

    Revert "PCI: Remove from bus_list and release resources in pci_release_dev()"
    
    Revert commit ef83b0781a73 "PCI: Remove from bus_list and release
    resources in pci_release_dev()" that made some nasty race conditions
    become possible.  For example, if a Thunderbolt link is unplugged
    and then replugged immediately, the pci_release_dev() resulting from
    the hot-remove code path may be racing with the hot-add code path
    which after that commit causes various kinds of breakage to happen
    (up to and including a hard crash of the whole system).
    
    Moreover, the problem that commit ef83b0781a73 attempted to address
    cannot happen any more after commit 8a4c5c329de7 "PCI: Check parent
    kobject in pci_destroy_dev()", because pci_destroy_dev() will now
    return immediately if it has already been executed for the given
    device.
    
    Note, however, that the invocation of msi_remove_pci_irq_vectors()
    removed by commit ef83b0781a73 from pci_free_resources() along with
    the other changes made by it is not added back because of subsequent
    code changes depending on that modification.
    
    Fixes: ef83b0781a73 (PCI: Remove from bus_list and release resources in pci_release_dev())
    Reported-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 04796c056d12..6e34498ec9f0 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1208,18 +1208,6 @@ static void pci_release_capabilities(struct pci_dev *dev)
 	pci_free_cap_save_buffers(dev);
 }
 
-static void pci_free_resources(struct pci_dev *dev)
-{
-	int i;
-
-	pci_cleanup_rom(dev);
-	for (i = 0; i < PCI_NUM_RESOURCES; i++) {
-		struct resource *res = dev->resource + i;
-		if (res->parent)
-			release_resource(res);
-	}
-}
-
 /**
  * pci_release_dev - free a pci device structure when all users of it are finished.
  * @dev: device that's been disconnected
@@ -1229,14 +1217,9 @@ static void pci_free_resources(struct pci_dev *dev)
  */
 static void pci_release_dev(struct device *dev)
 {
-	struct pci_dev *pci_dev = to_pci_dev(dev);
-
-	down_write(&pci_bus_sem);
-	list_del(&pci_dev->bus_list);
-	up_write(&pci_bus_sem);
-
-	pci_free_resources(pci_dev);
+	struct pci_dev *pci_dev;
 
+	pci_dev = to_pci_dev(dev);
 	pci_release_capabilities(pci_dev);
 	pci_release_of_node(pci_dev);
 	pcibios_release_device(pci_dev);

commit 9d16947b75831acd317ab9a53e0e94d160731d33
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Jan 10 15:22:18 2014 +0100

    PCI: Add global pci_lock_rescan_remove()
    
    There are multiple PCI device addition and removal code paths that may be
    run concurrently with the generic PCI bus rescan and device removal that
    can be triggered via sysfs.  If that happens, it may lead to multiple
    different, potentially dangerous race conditions.
    
    The most straightforward way to address those problems is to run
    the code in question under the same lock that is used by the
    generic rescan/remove code in pci-sysfs.c.  To prepare for those
    changes, move the definition of the global PCI remove/rescan lock
    to probe.c and provide global wrappers, pci_lock_rescan_remove()
    and pci_unlock_rescan_remove(), allowing drivers to manipulate
    that lock.  Also provide pci_stop_and_remove_bus_device_locked()
    for the callers of pci_stop_and_remove_bus_device() who only need
    to hold the rescan/remove lock around it.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index c86c8638d3c4..04796c056d12 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -2024,6 +2024,24 @@ EXPORT_SYMBOL(pci_scan_slot);
 EXPORT_SYMBOL(pci_scan_bridge);
 EXPORT_SYMBOL_GPL(pci_scan_child_bus);
 
+/*
+ * pci_rescan_bus(), pci_rescan_bus_bridge_resize() and PCI device removal
+ * routines should always be executed under this mutex.
+ */
+static DEFINE_MUTEX(pci_rescan_remove_lock);
+
+void pci_lock_rescan_remove(void)
+{
+	mutex_lock(&pci_rescan_remove_lock);
+}
+EXPORT_SYMBOL_GPL(pci_lock_rescan_remove);
+
+void pci_unlock_rescan_remove(void)
+{
+	mutex_unlock(&pci_rescan_remove_lock);
+}
+EXPORT_SYMBOL_GPL(pci_unlock_rescan_remove);
+
 static int __init pci_sort_bf_cmp(const struct device *d_a, const struct device *d_b)
 {
 	const struct pci_dev *a = to_pci_dev(d_a);

commit 597db6f38c4bcb90406d4e2f56446ba5a5dc20c6
Merge: 6b9bd1e3ee8f 0b950f0f3c67
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Jan 13 16:47:08 2014 -0700

    Merge branch 'pci/dead-code' into next
    
    * pci/dead-code:
      PCI: Make local functions static
      PCI: Remove unused alloc_pci_dev()
      PCI: Remove unused pci_renumber_slot()
      PCI: Remove unused pcie_aspm_enabled()
      PCI: Remove unused pci_vpd_truncate()
      PCI: Remove unused ID-Based Ordering support
      PCI: Remove unused Optimized Buffer Flush/Fill support
      PCI: Remove unused Latency Tolerance Reporting support
      PCI: Removed unused parts of Page Request Interface support
    
    Conflicts:
            drivers/pci/pci.c
            include/linux/pci.h

commit 0b950f0f3c67e42f18c655a3ab3e36ea192635bb
Author: Stephen Hemminger <stephen@networkplumber.org>
Date:   Fri Jan 10 17:14:48 2014 -0700

    PCI: Make local functions static
    
    Using 'make namespacecheck' identify code which should be declared static.
    Checked for users in other driver/archs as well.  Compile tested only.
    
    This stops exporting the following interfaces to modules:
    
        pci_target_state()
        pci_load_saved_state()
    
    [bhelgaas: retained pci_find_next_ext_capability() and pci_cfg_space_size()]
    Signed-off-by: Stephen Hemminger <stephen@networkplumber.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index a4f53b677185..7fef23ba6bc6 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -16,7 +16,7 @@
 #define CARDBUS_LATENCY_TIMER	176	/* secondary latency timer */
 #define CARDBUS_RESERVE_BUSNR	3
 
-struct resource busn_resource = {
+static struct resource busn_resource = {
 	.name	= "PCI busn",
 	.start	= 0,
 	.end	= 255,
@@ -518,7 +518,7 @@ static struct pci_host_bridge *pci_alloc_host_bridge(struct pci_bus *b)
 	return bridge;
 }
 
-const unsigned char pcix_bus_speed[] = {
+static const unsigned char pcix_bus_speed[] = {
 	PCI_SPEED_UNKNOWN,		/* 0 */
 	PCI_SPEED_66MHz_PCIX,		/* 1 */
 	PCI_SPEED_100MHz_PCIX,		/* 2 */
@@ -999,6 +999,60 @@ void set_pcie_hotplug_bridge(struct pci_dev *pdev)
 		pdev->is_hotplug_bridge = 1;
 }
 
+
+/**
+ * pci_cfg_space_size - get the configuration space size of the PCI device.
+ * @dev: PCI device
+ *
+ * Regular PCI devices have 256 bytes, but PCI-X 2 and PCI Express devices
+ * have 4096 bytes.  Even if the device is capable, that doesn't mean we can
+ * access it.  Maybe we don't have a way to generate extended config space
+ * accesses, or the device is behind a reverse Express bridge.  So we try
+ * reading the dword at 0x100 which must either be 0 or a valid extended
+ * capability header.
+ */
+static int pci_cfg_space_size_ext(struct pci_dev *dev)
+{
+	u32 status;
+	int pos = PCI_CFG_SPACE_SIZE;
+
+	if (pci_read_config_dword(dev, pos, &status) != PCIBIOS_SUCCESSFUL)
+		goto fail;
+	if (status == 0xffffffff)
+		goto fail;
+
+	return PCI_CFG_SPACE_EXP_SIZE;
+
+ fail:
+	return PCI_CFG_SPACE_SIZE;
+}
+
+int pci_cfg_space_size(struct pci_dev *dev)
+{
+	int pos;
+	u32 status;
+	u16 class;
+
+	class = dev->class >> 8;
+	if (class == PCI_CLASS_BRIDGE_HOST)
+		return pci_cfg_space_size_ext(dev);
+
+	if (!pci_is_pcie(dev)) {
+		pos = pci_find_capability(dev, PCI_CAP_ID_PCIX);
+		if (!pos)
+			goto fail;
+
+		pci_read_config_dword(dev, pos + PCI_X_STATUS, &status);
+		if (!(status & (PCI_X_STATUS_266MHZ | PCI_X_STATUS_533MHZ)))
+			goto fail;
+	}
+
+	return pci_cfg_space_size_ext(dev);
+
+ fail:
+	return PCI_CFG_SPACE_SIZE;
+}
+
 #define LEGACY_IO_RESOURCE	(IORESOURCE_IO | IORESOURCE_PCI_FIXED)
 
 /**
@@ -1173,59 +1227,6 @@ static void pci_release_dev(struct device *dev)
 	kfree(pci_dev);
 }
 
-/**
- * pci_cfg_space_size - get the configuration space size of the PCI device.
- * @dev: PCI device
- *
- * Regular PCI devices have 256 bytes, but PCI-X 2 and PCI Express devices
- * have 4096 bytes.  Even if the device is capable, that doesn't mean we can
- * access it.  Maybe we don't have a way to generate extended config space
- * accesses, or the device is behind a reverse Express bridge.  So we try
- * reading the dword at 0x100 which must either be 0 or a valid extended
- * capability header.
- */
-int pci_cfg_space_size_ext(struct pci_dev *dev)
-{
-	u32 status;
-	int pos = PCI_CFG_SPACE_SIZE;
-
-	if (pci_read_config_dword(dev, pos, &status) != PCIBIOS_SUCCESSFUL)
-		goto fail;
-	if (status == 0xffffffff)
-		goto fail;
-
-	return PCI_CFG_SPACE_EXP_SIZE;
-
- fail:
-	return PCI_CFG_SPACE_SIZE;
-}
-
-int pci_cfg_space_size(struct pci_dev *dev)
-{
-	int pos;
-	u32 status;
-	u16 class;
-
-	class = dev->class >> 8;
-	if (class == PCI_CLASS_BRIDGE_HOST)
-		return pci_cfg_space_size_ext(dev);
-
-	if (!pci_is_pcie(dev)) {
-		pos = pci_find_capability(dev, PCI_CAP_ID_PCIX);
-		if (!pos)
-			goto fail;
-
-		pci_read_config_dword(dev, pos + PCI_X_STATUS, &status);
-		if (!(status & (PCI_X_STATUS_266MHZ | PCI_X_STATUS_533MHZ)))
-			goto fail;
-	}
-
-	return pci_cfg_space_size_ext(dev);
-
- fail:
-	return PCI_CFG_SPACE_SIZE;
-}
-
 struct pci_dev *pci_alloc_dev(struct pci_bus *bus)
 {
 	struct pci_dev *dev;

commit e2760c54a4f5131867bf1b35d59169267d35d3d0
Author: Stephen Hemminger <stephen@networkplumber.org>
Date:   Fri Jan 10 15:46:34 2014 -0700

    PCI: Remove unused alloc_pci_dev()
    
    My philosophy is unused code is dead code.  And dead code is subject to bit
    rot and is a likely source of bugs.  Use it or lose it.
    
    This removes this unused and deprecated interface:
    
        alloc_pci_dev()
    
    [bhelgaas: split to separate patch]
    Signed-off-by: Stephen Hemminger <stephen@networkplumber.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 38e403dddf6e..a4f53b677185 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1242,12 +1242,6 @@ struct pci_dev *pci_alloc_dev(struct pci_bus *bus)
 }
 EXPORT_SYMBOL(pci_alloc_dev);
 
-struct pci_dev *alloc_pci_dev(void)
-{
-	return pci_alloc_dev(NULL);
-}
-EXPORT_SYMBOL(alloc_pci_dev);
-
 bool pci_bus_read_dev_vendor_id(struct pci_bus *bus, int devfn, u32 *l,
 				 int crs_timeout)
 {

commit 96702be560374ee7e7139a34cab03554129abbb4
Merge: 04f982beb900 d56dbf5bab8c
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Jan 10 14:23:15 2014 -0700

    Merge branch 'pci/resource' into next
    
    * pci/resource:
      PCI: Allocate 64-bit BARs above 4G when possible
      PCI: Enforce bus address limits in resource allocation
      PCI: Split out bridge window override of minimum allocation address
      agp/ati: Use PCI_COMMAND instead of hard-coded 4
      agp/intel: Use CPU physical address, not bus address, for ioremap()
      agp/intel: Use pci_bus_address() to get GTTADR bus address
      agp/intel: Use pci_bus_address() to get MMADR bus address
      agp/intel: Support 64-bit GMADR
      agp/intel: Rename gtt_bus_addr to gtt_phys_addr
      drm/i915: Rename gtt_bus_addr to gtt_phys_addr
      agp: Use pci_resource_start() to get CPU physical address for BAR
      agp: Support 64-bit APBASE
      PCI: Add pci_bus_address() to get bus address of a BAR
      PCI: Convert pcibios_resource_to_bus() to take a pci_bus, not a pci_dev
      PCI: Change pci_bus_region addresses to dma_addr_t

commit fc2798502f860b18f3c7121e4dc659d3d9d28d74
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Mon Dec 9 22:54:40 2013 -0800

    PCI: Convert pcibios_resource_to_bus() to take a pci_bus, not a pci_dev
    
    These interfaces:
    
      pcibios_resource_to_bus(struct pci_dev *dev, *bus_region, *resource)
      pcibios_bus_to_resource(struct pci_dev *dev, *resource, *bus_region)
    
    took a pci_dev, but they really depend only on the pci_bus.  And we want to
    use them in resource allocation paths where we have the bus but not a
    device, so this patch converts them to take the pci_bus instead of the
    pci_dev:
    
      pcibios_resource_to_bus(struct pci_bus *bus, *bus_region, *resource)
      pcibios_bus_to_resource(struct pci_bus *bus, *resource, *bus_region)
    
    In fact, with standard PCI-PCI bridges, they only depend on the host
    bridge, because that's the only place address translation occurs, but
    we aren't going that far yet.
    
    [bhelgaas: changelog]
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 38e403dddf6e..f049e3f53fcc 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -269,8 +269,8 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 		region.end = l + sz;
 	}
 
-	pcibios_bus_to_resource(dev, res, &region);
-	pcibios_resource_to_bus(dev, &inverted_region, res);
+	pcibios_bus_to_resource(dev->bus, res, &region);
+	pcibios_resource_to_bus(dev->bus, &inverted_region, res);
 
 	/*
 	 * If "A" is a BAR value (a bus address), "bus_to_resource(A)" is
@@ -364,7 +364,7 @@ static void pci_read_bridge_io(struct pci_bus *child)
 		res->flags = (io_base_lo & PCI_IO_RANGE_TYPE_MASK) | IORESOURCE_IO;
 		region.start = base;
 		region.end = limit + io_granularity - 1;
-		pcibios_bus_to_resource(dev, res, &region);
+		pcibios_bus_to_resource(dev->bus, res, &region);
 		dev_printk(KERN_DEBUG, &dev->dev, "  bridge window %pR\n", res);
 	}
 }
@@ -386,7 +386,7 @@ static void pci_read_bridge_mmio(struct pci_bus *child)
 		res->flags = (mem_base_lo & PCI_MEMORY_RANGE_TYPE_MASK) | IORESOURCE_MEM;
 		region.start = base;
 		region.end = limit + 0xfffff;
-		pcibios_bus_to_resource(dev, res, &region);
+		pcibios_bus_to_resource(dev->bus, res, &region);
 		dev_printk(KERN_DEBUG, &dev->dev, "  bridge window %pR\n", res);
 	}
 }
@@ -436,7 +436,7 @@ static void pci_read_bridge_mmio_pref(struct pci_bus *child)
 			res->flags |= IORESOURCE_MEM_64;
 		region.start = base;
 		region.end = limit + 0xfffff;
-		pcibios_bus_to_resource(dev, res, &region);
+		pcibios_bus_to_resource(dev->bus, res, &region);
 		dev_printk(KERN_DEBUG, &dev->dev, "  bridge window %pR\n", res);
 	}
 }
@@ -1084,24 +1084,24 @@ int pci_setup_device(struct pci_dev *dev)
 				region.end = 0x1F7;
 				res = &dev->resource[0];
 				res->flags = LEGACY_IO_RESOURCE;
-				pcibios_bus_to_resource(dev, res, &region);
+				pcibios_bus_to_resource(dev->bus, res, &region);
 				region.start = 0x3F6;
 				region.end = 0x3F6;
 				res = &dev->resource[1];
 				res->flags = LEGACY_IO_RESOURCE;
-				pcibios_bus_to_resource(dev, res, &region);
+				pcibios_bus_to_resource(dev->bus, res, &region);
 			}
 			if ((progif & 4) == 0) {
 				region.start = 0x170;
 				region.end = 0x177;
 				res = &dev->resource[2];
 				res->flags = LEGACY_IO_RESOURCE;
-				pcibios_bus_to_resource(dev, res, &region);
+				pcibios_bus_to_resource(dev->bus, res, &region);
 				region.start = 0x376;
 				region.end = 0x376;
 				res = &dev->resource[3];
 				res->flags = LEGACY_IO_RESOURCE;
-				pcibios_bus_to_resource(dev, res, &region);
+				pcibios_bus_to_resource(dev->bus, res, &region);
 			}
 		}
 		break;

commit ef83b0781a73f9efcb1228256bfdfb97fc9533a8
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Sat Nov 30 14:40:29 2013 -0800

    PCI: Remove from bus_list and release resources in pci_release_dev()
    
    Previously we removed the pci_dev from the bus_list and released its
    resources in pci_destroy_dev().  But that's too early: it's possible to
    call pci_destroy_dev() twice for the same device (e.g., via sysfs), and
    that will cause an oops when we try to remove it from bus_list the second
    time.
    
    We should remove it from the bus_list only when the last reference to the
    pci_dev has been released, i.e., in pci_release_dev().
    
    [bhelgaas: changelog]
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 173a9cf4593e..12ec56c9a913 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1154,6 +1154,18 @@ static void pci_release_capabilities(struct pci_dev *dev)
 	pci_free_cap_save_buffers(dev);
 }
 
+static void pci_free_resources(struct pci_dev *dev)
+{
+	int i;
+
+	pci_cleanup_rom(dev);
+	for (i = 0; i < PCI_NUM_RESOURCES; i++) {
+		struct resource *res = dev->resource + i;
+		if (res->parent)
+			release_resource(res);
+	}
+}
+
 /**
  * pci_release_dev - free a pci device structure when all users of it are finished.
  * @dev: device that's been disconnected
@@ -1163,9 +1175,14 @@ static void pci_release_capabilities(struct pci_dev *dev)
  */
 static void pci_release_dev(struct device *dev)
 {
-	struct pci_dev *pci_dev;
+	struct pci_dev *pci_dev = to_pci_dev(dev);
+
+	down_write(&pci_bus_sem);
+	list_del(&pci_dev->bus_list);
+	up_write(&pci_bus_sem);
+
+	pci_free_resources(pci_dev);
 
-	pci_dev = to_pci_dev(dev);
 	pci_release_capabilities(pci_dev);
 	pci_release_of_node(pci_dev);
 	pcibios_release_device(pci_dev);

commit ef37702eb3cae2ec35d56ddd4f096cd47fec3f0d
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Sat Nov 30 14:40:28 2013 -0800

    PCI: Move pci_proc_attach_device() to pci_bus_add_device()
    
    4f535093cf8f ("PCI: Put pci_dev in device tree as early as possible")
    moved pci_proc_attach_device() from pci_bus_add_device() to
    pci_device_add().
    
    This moves it back to pci_bus_add_device(), essentially reverting that
    part of 4f535093cf8f.  This makes it symmetric with pci_stop_dev(),
    where we call pci_proc_detach_device() and pci_remove_sysfs_dev_files()
    and set dev->is_added = 0.
    
    [bhelgaas: changelog, create sysfs then attach proc for symmetry]
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 38e403dddf6e..173a9cf4593e 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1381,8 +1381,6 @@ void pci_device_add(struct pci_dev *dev, struct pci_bus *bus)
 	dev->match_driver = false;
 	ret = device_add(&dev->dev);
 	WARN_ON(ret < 0);
-
-	pci_proc_attach_device(dev);
 }
 
 struct pci_dev *__ref pci_scan_single_device(struct pci_bus *bus, int devfn)

commit f7625980f5820edd1a73536e1a03bcbc1f889fec
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Nov 14 11:28:18 2013 -0700

    PCI: Fix whitespace, capitalization, and spelling errors
    
    Fix whitespace, capitalization, and spelling errors.  No functional change.
    I know "busses" is not an error, but "buses" was more common, so I used it
    consistently.
    
    Signed-off-by: Marta Rybczynska <rybczynska@gmail.com> (pci_reset_bridge_secondary_bus())
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 5e14f5a51357..38e403dddf6e 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -582,7 +582,7 @@ static enum pci_bus_speed agp_speed(int agp3, int agpstat)
 		index = 1;
 	else
 		goto out;
-	
+
 	if (agp3) {
 		index += 2;
 		if (index == 5)
@@ -789,7 +789,7 @@ int pci_scan_bridge(struct pci_bus *bus, struct pci_dev *dev, int max, int pass)
 	}
 
 	/* Disable MasterAbortMode during probing to avoid reporting
-	   of bus errors (in some architectures) */ 
+	   of bus errors (in some architectures) */
 	pci_read_config_word(dev, PCI_BRIDGE_CONTROL, &bctl);
 	pci_write_config_word(dev, PCI_BRIDGE_CONTROL,
 			      bctl & ~PCI_BRIDGE_CTL_MASTER_ABORT);
@@ -1005,7 +1005,7 @@ void set_pcie_hotplug_bridge(struct pci_dev *pdev)
  * pci_setup_device - fill in class and map information of a device
  * @dev: the device structure to fill
  *
- * Initialize the device structure with information about the device's 
+ * Initialize the device structure with information about the device's
  * vendor,class,memory and IO-space addresses,IRQ lines etc.
  * Called at initialisation of the PCI subsystem and by CardBus services.
  * Returns 0 on success and negative if unknown type of device (not normal,
@@ -1111,7 +1111,7 @@ int pci_setup_device(struct pci_dev *dev)
 			goto bad;
 		/* The PCI-to-PCI bridge spec requires that subtractive
 		   decoding (i.e. transparent) bridge must have programming
-		   interface code of 0x01. */ 
+		   interface code of 0x01. */
 		pci_read_irq(dev);
 		dev->transparent = ((dev->class & 0xff) == 1);
 		pci_read_bases(dev, 2, PCI_ROM_ADDRESS1);
@@ -1570,7 +1570,7 @@ static void pcie_write_mrrs(struct pci_dev *dev)
 	 * subsequent read will verify if the value is acceptable or not.
 	 * If the MRRS value provided is not acceptable (e.g., too large),
 	 * shrink the value until it is acceptable to the HW.
- 	 */
+	 */
 	while (mrrs != pcie_get_readrq(dev) && mrrs >= 128) {
 		rc = pcie_set_readrq(dev, mrrs);
 		if (!rc)

commit 605d240052473228bf0c8c051cad825fddb25502
Merge: d3c02799d320 09a2c73ddfc7
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Sep 27 16:35:43 2013 -0600

    Merge branch 'pci/misc' into next
    
    * pci/misc:
      PCI: Remove unused PCI_MSIX_FLAGS_BIRMASK definition
      PCI: acpiphp_ibm: Convert to dynamic debug
      PCI: acpiphp: Convert to dynamic debug
      PCI: Remove Intel Haswell D3 delays
      PCI: Pass type, width, and prefetchability for window alignment
      PCI: Document reason for using pci_is_root_bus()
      PCI: Use pci_is_root_bus() to check for root bus
      PCI: Remove unused "is_pcie" from pci_dev structure
      PCI: Update pci_find_slot() description in pci.txt
      [SCSI] qla2xxx: Use standard PCIe Capability Link register field names
      PCI: Fix comment typo, remove unnecessary !! in pci_is_pcie()
      PCI: Drop "setting latency timer" messages

commit 115e3bc5e23e7ec3c85a2014bfa96c0ddd036083
Author: Yijing Wang <wangyijing@huawei.com>
Date:   Tue Sep 3 10:02:09 2013 +0800

    PCI: Remove unused "is_pcie" from pci_dev structure
    
    No one uses "is_pcie" now; remove this obsolete member.
    
    Signed-off-by: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 7ef0f868b3e0..2372babe2fc5 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -984,7 +984,6 @@ void set_pcie_port_type(struct pci_dev *pdev)
 	pos = pci_find_capability(pdev, PCI_CAP_ID_EXP);
 	if (!pos)
 		return;
-	pdev->is_pcie = 1;
 	pdev->pcie_cap = pos;
 	pci_read_config_word(pdev, pos + PCI_EXP_FLAGS, &reg16);
 	pdev->pcie_flags_reg = reg16;

commit fdfe151127a75de037c7e32cef110ae9c7c5e3c8
Author: Yijing Wang <wangyijing@huawei.com>
Date:   Thu Sep 5 15:55:29 2013 +0800

    PCI: Use pci_is_pcie() to simplify code
    
    Use pci_is_pcie() instead of pci_find_capability() to simplify code.
    
    Signed-off-by: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 7ef0f868b3e0..c90d0f8021e7 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -641,8 +641,7 @@ static void pci_set_bus_speed(struct pci_bus *bus)
 		return;
 	}
 
-	pos = pci_find_capability(bridge, PCI_CAP_ID_EXP);
-	if (pos) {
+	if (pci_is_pcie(bridge)) {
 		u32 linkcap;
 		u16 linksta;
 

commit b4b50fd78b1e31989940dfc647e64453d0f7176a
Merge: dccfd1e439c1 f97c43bbdf8a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Sep 6 13:30:06 2013 -0700

    Merge tag 'soc-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM SoC platform changes from Olof Johansson:
     "This branch contains mostly additions and changes to platform
      enablement and SoC-level drivers.  Since there's sometimes a
      dependency on device-tree changes, there's also a fair amount of
      those in this branch.
    
      Pieces worth mentioning are:
    
       - Mbus driver for Marvell platforms, allowing kernel configuration
         and resource allocation of on-chip peripherals.
       - Enablement of the mbus infrastructure from Marvell PCI-e drivers.
       - Preparation of MSI support for Marvell platforms.
       - Addition of new PCI-e host controller driver for Tegra platforms
       - Some churn caused by sharing of macro names between i.MX 6Q and 6DL
         platforms in the device tree sources and header files.
       - Various suspend/PM updates for Tegra, including LP1 support.
       - Versatile Express support for MCPM, part of big little support.
       - Allwinner platform support for A20 and A31 SoCs (dual and quad
         Cortex-A7)
       - OMAP2+ support for DRA7, a new Cortex-A15-based SoC.
    
      The code that touches other architectures are patches moving MSI
      arch-specific functions over to weak symbols and removal of
      ARCH_SUPPORTS_MSI, acked by PCI maintainers"
    
    * tag 'soc-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (266 commits)
      tegra-cpuidle: provide stub when !CONFIG_CPU_IDLE
      PCI: tegra: replace devm_request_and_ioremap by devm_ioremap_resource
      ARM: tegra: Drop ARCH_SUPPORTS_MSI and sort list
      ARM: dts: vf610-twr: enable i2c0 device
      ARM: dts: i.MX51: Add one more I2C2 pinmux entry
      ARM: dts: i.MX51: Move pins configuration under "iomuxc" label
      ARM: dtsi: imx6qdl-sabresd: Add USB OTG vbus pin to pinctrl_hog
      ARM: dtsi: imx6qdl-sabresd: Add USB host 1 VBUS regulator
      ARM: dts: imx27-phytec-phycore-som: Enable AUDMUX
      ARM: dts: i.MX27: Disable AUDMUX in the template
      ARM: dts: wandboard: Add support for SDIO bcm4329
      ARM: i.MX5 clocks: Remove optional clock setup (CKIH1) from i.MX51 template
      ARM: dts: imx53-qsb: Make USBH1 functional
      ARM i.MX6Q: dts: Enable I2C1 with EEPROM and PMIC on Phytec phyFLEX-i.MX6 Ouad module
      ARM i.MX6Q: dts: Enable SPI NOR flash on Phytec phyFLEX-i.MX6 Ouad module
      ARM: dts: imx6qdl-sabresd: Add touchscreen support
      ARM: imx: add ocram clock for imx53
      ARM: dts: imx: ocram size is different between imx6q and imx6dl
      ARM: dts: imx27-phytec-phycore-som: Fix regulator settings
      ARM: dts: i.MX27: Remove clock name from CPU node
      ...

commit cc998ff8811530be521f6b316f37ab7676a07938
Merge: 57d730924d5c 0d40f75bdab2
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Sep 5 14:54:29 2013 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net-next
    
    Pull networking changes from David Miller:
     "Noteworthy changes this time around:
    
       1) Multicast rejoin support for team driver, from Jiri Pirko.
    
       2) Centralize and simplify TCP RTT measurement handling in order to
          reduce the impact of bad RTO seeding from SYN/ACKs.  Also, when
          both timestamps and local RTT measurements are available prefer
          the later because there are broken middleware devices which
          scramble the timestamp.
    
          From Yuchung Cheng.
    
       3) Add TCP_NOTSENT_LOWAT socket option to limit the amount of kernel
          memory consumed to queue up unsend user data.  From Eric Dumazet.
    
       4) Add a "physical port ID" abstraction for network devices, from
          Jiri Pirko.
    
       5) Add a "suppress" operation to influence fib_rules lookups, from
          Stefan Tomanek.
    
       6) Add a networking development FAQ, from Paul Gortmaker.
    
       7) Extend the information provided by tcp_probe and add ipv6 support,
          from Daniel Borkmann.
    
       8) Use RCU locking more extensively in openvswitch data paths, from
          Pravin B Shelar.
    
       9) Add SCTP support to openvswitch, from Joe Stringer.
    
      10) Add EF10 chip support to SFC driver, from Ben Hutchings.
    
      11) Add new SYNPROXY netfilter target, from Patrick McHardy.
    
      12) Compute a rate approximation for sending in TCP sockets, and use
          this to more intelligently coalesce TSO frames.  Furthermore, add
          a new packet scheduler which takes advantage of this estimate when
          available.  From Eric Dumazet.
    
      13) Allow AF_PACKET fanouts with random selection, from Daniel
          Borkmann.
    
      14) Add ipv6 support to vxlan driver, from Cong Wang"
    
    Resolved conflicts as per discussion.
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/davem/net-next: (1218 commits)
      openvswitch: Fix alignment of struct sw_flow_key.
      netfilter: Fix build errors with xt_socket.c
      tcp: Add missing braces to do_tcp_setsockopt
      caif: Add missing braces to multiline if in cfctrl_linkup_request
      bnx2x: Add missing braces in bnx2x:bnx2x_link_initialize
      vxlan: Fix kernel panic on device delete.
      net: mvneta: implement ->ndo_do_ioctl() to support PHY ioctls
      net: mvneta: properly disable HW PHY polling and ensure adjust_link() works
      icplus: Use netif_running to determine device state
      ethernet/arc/arc_emac: Fix huge delays in large file copies
      tuntap: orphan frags before trying to set tx timestamp
      tuntap: purge socket error queue on detach
      qlcnic: use standard NAPI weights
      ipv6:introduce function to find route for redirect
      bnx2x: VF RSS support - VF side
      bnx2x: VF RSS support - PF side
      vxlan: Notify drivers for listening UDP port changes
      net: usbnet: update addr_assign_type if appropriate
      driver/net: enic: update enic maintainers and driver
      driver/net: enic: Exposing symbols for Cisco's low latency driver
      ...

commit 2e8b5f621dbe29425906852c6079afb6b28720cb
Merge: 07f2daad094b fed245151249
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Aug 28 20:55:41 2013 -0600

    Merge branch 'pci/misc' into next
    
    * pci/misc:
      PCI: Remove pcie_cap_has_devctl()
      PCI: Support PCIe Capability Slot registers only for ports with slots
      PCI: Remove PCIe Capability version checks
      PCI: Allow PCIe Capability link-related register access for switches
      PCI: Add offsets of PCIe capability registers
      PCI: Tidy bitmasks and spacing of PCIe capability definitions
      PCI: Remove obsolete comment reference to pci_pcie_cap2()
      PCI: Clarify PCI_EXP_TYPE_PCI_BRIDGE comment
      PCI: Rename PCIe capability definitions to follow convention
      PCI: Disable decoding for BAR sizing only when it was actually enabled
      PCI: Add comment about needing pci_msi_off() even when CONFIG_PCI_MSI=n
      PCI: Add pcibios_pm_ops for optional arch-specific hibernate functionality

commit 07f2daad094bc9e9770143cd2d619de24d84bb3e
Merge: 1193725f543c 5895af79158a
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Aug 26 15:40:34 2013 -0600

    Merge branch 'pci/yijing-mps-v8' into next
    
    * pci/yijing-mps-v8:
      PCI: Warn if unsafe MPS settings detected
      PCI: Fix MPS peer-to-peer DMA comment syntax
      PCI: Don't restrict MPS for slots below Root Ports
      PCI: Simplify MPS test for Downstream Port
      PCI: Remove unnecessary check for pcie_get_mps() failure
      PCI: Simplify pcie_bus_configure_settings() interface
      PCI: Drop "PCI-E" prefix from Max Payload Size message

commit 1193725f543c92a77c73769bc2fbe48c53275f53
Merge: 7d8c4a2c5ae6 39772038ea93
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Aug 26 15:40:03 2013 -0600

    Merge branch 'pci/yinghai-assign-unassigned-v6' into next
    
    * pci/yinghai-assign-unassigned-v6:
      PCI: Assign resources for hot-added host bridge more aggressively
      PCI: Move resource reallocation code to non-__init
      PCI: Delay enabling bridges until they're needed
      PCI: Assign resources on a per-bus basis
      PCI: Enable unassigned resource reallocation on per-bus basis
      PCI: Turn on reallocation for unassigned resources with host bridge offset
      PCI: Look for unassigned resources on per-bus basis
      PCI: Drop temporary variable in pci_assign_unassigned_resources()

commit 5895af79158a55562753f7f05762f3bd766d32b9
Author: Yijing Wang <wangyijing@huawei.com>
Date:   Mon Aug 26 16:33:06 2013 +0800

    PCI: Warn if unsafe MPS settings detected
    
    If a BIOS configures MPS incorrectly, devices may not work normally.
    For example, if a bridge has MPS set larger than an endpoint below it,
    the endpoint may discard packets.
    
    To help diagnose this issue, print a warning if we find an endpoint
    MPS setting different than that of the upstream bridge.
    
    [bhelgaas: changelog, "bridge" temporary, warning text]
    Reference: https://bugzilla.kernel.org/show_bug.cgi?id=60799
    Reported-by: Joe Jin <joe.jin@oracle.com>
    Signed-off-by: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Jon Mason <jdmason@kudzu.us>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 94c5a77ce853..cd5c4acb5367 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1582,6 +1582,22 @@ static void pcie_write_mrrs(struct pci_dev *dev)
 			"with pci=pcie_bus_safe.\n");
 }
 
+static void pcie_bus_detect_mps(struct pci_dev *dev)
+{
+	struct pci_dev *bridge = dev->bus->self;
+	int mps, p_mps;
+
+	if (!bridge)
+		return;
+
+	mps = pcie_get_mps(dev);
+	p_mps = pcie_get_mps(bridge);
+
+	if (mps != p_mps)
+		dev_warn(&dev->dev, "Max Payload Size %d, but upstream %s set to %d; if necessary, use \"pci=pcie_bus_safe\" and report a bug\n",
+			 mps, pci_name(bridge), p_mps);
+}
+
 static int pcie_bus_configure_set(struct pci_dev *dev, void *data)
 {
 	int mps, orig_mps;
@@ -1589,6 +1605,11 @@ static int pcie_bus_configure_set(struct pci_dev *dev, void *data)
 	if (!pci_is_pcie(dev))
 		return 0;
 
+	if (pcie_bus_config == PCIE_BUS_TUNE_OFF) {
+		pcie_bus_detect_mps(dev);
+		return 0;
+	}
+
 	mps = 128 << *(u8 *)data;
 	orig_mps = pcie_get_mps(dev);
 
@@ -1616,9 +1637,6 @@ void pcie_bus_configure_settings(struct pci_bus *bus)
 	if (!pci_is_pcie(bus->self))
 		return;
 
-	if (pcie_bus_config == PCIE_BUS_TUNE_OFF)
-		return;
-
 	/* FIXME - Peer to peer DMA is possible, though the endpoint would need
 	 * to be aware of the MPS of the destination.  To work around this,
 	 * simply force the MPS of the entire system to the smallest possible.

commit 3315472c474af8e1c2beb40d980dfc92f03e4d8e
Author: Jon Mason <jdmason@kudzu.us>
Date:   Mon Aug 26 16:33:05 2013 +0800

    PCI: Fix MPS peer-to-peer DMA comment syntax
    
    Correct minor wording issue in MPS peer-to-peer comment.  Noticed by Don
    Dutile.
    
    Signed-off-by: Jon Mason <jdmason@kudzu.us>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 94b1d227ddcd..94c5a77ce853 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1620,7 +1620,7 @@ void pcie_bus_configure_settings(struct pci_bus *bus)
 		return;
 
 	/* FIXME - Peer to peer DMA is possible, though the endpoint would need
-	 * to be aware to the MPS of the destination.  To work around this,
+	 * to be aware of the MPS of the destination.  To work around this,
 	 * simply force the MPS of the entire system to the smallest possible.
 	 */
 	if (pcie_bus_config == PCIE_BUS_PEER2PEER)

commit 808e34e2cd6bc74a2311b6a00d12a52e37fb50c0
Author: Zoltan Kiss <zoltan.kiss@citrix.com>
Date:   Thu Aug 22 23:19:18 2013 +0100

    PCI: Disable decoding for BAR sizing only when it was actually enabled
    
    We disable BARs while sizing them so we don't cause conflicts with other
    devices (see 253d2e5498 and bbffe43524).  But if device decoding is already
    disabled before we size the BAR, we don't need to disable it again.
    
    [bhelgaas: changelog, add PCI_COMMAND_DECODING_ENABLE for readability]
    Signed-off-by: Zoltan Kiss <zoltan.kiss@citrix.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index cf57fe79450a..b50386dc72e0 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -156,6 +156,8 @@ static inline unsigned long decode_bar(struct pci_dev *dev, u32 bar)
 	return flags;
 }
 
+#define PCI_COMMAND_DECODE_ENABLE	(PCI_COMMAND_MEMORY | PCI_COMMAND_IO)
+
 /**
  * pci_read_base - read a PCI BAR
  * @dev: the PCI device
@@ -178,8 +180,10 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 	/* No printks while decoding is disabled! */
 	if (!dev->mmio_always_on) {
 		pci_read_config_word(dev, PCI_COMMAND, &orig_cmd);
-		pci_write_config_word(dev, PCI_COMMAND,
-			orig_cmd & ~(PCI_COMMAND_MEMORY | PCI_COMMAND_IO));
+		if (orig_cmd & PCI_COMMAND_DECODE_ENABLE) {
+			pci_write_config_word(dev, PCI_COMMAND,
+				orig_cmd & ~PCI_COMMAND_DECODE_ENABLE);
+		}
 	}
 
 	res->name = pci_name(dev);
@@ -293,7 +297,8 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 fail:
 	res->flags = 0;
 out:
-	if (!dev->mmio_always_on)
+	if (!dev->mmio_always_on &&
+	    (orig_cmd & PCI_COMMAND_DECODE_ENABLE))
 		pci_write_config_word(dev, PCI_COMMAND, orig_cmd);
 
 	if (bar_too_big)

commit d4aa68f614201e9fbf74e8b9593bb2ec94061dd3
Author: Yijing Wang <wangyijing@huawei.com>
Date:   Thu Aug 22 11:24:47 2013 +0800

    PCI: Don't restrict MPS for slots below Root Ports
    
    When booting with "pci=pcie_bus_safe", we previously limited the
    fabric MPS to 128 when we found:
    
      (1) A hotplug-capable Downstream Port ("dev->is_hotplug_bridge &&
          pci_pcie_type(dev) != PCI_EXP_TYPE_ROOT_PORT"), or
    
      (2) A hotplug-capable Root Port with a slot that was either empty or
          contained a multi-function device ("dev->is_hotplug_bridge &&
          !list_is_singular(&dev->bus->devices)")
    
    Part (1) is valid, but part (2) is not.
    
    After a hot-add in the slot below a Root Port, we can reconfigure all
    MPS values in the fabric below the Root Port because the new device is
    the only thing below the Root Port and there are no active drivers.
    Therefore, there's no reason to limit the MPS for Root Ports, no
    matter what's in the slot.
    
    Test info:
    
        -+-[0000:40]-+-07.0-[0000:46]--+-00.0  Intel 82576 NIC
                                       \-00.1  Intel 82576 NIC
    
        0000:40:07.0 Root Port bridge to [bus 46] (MPS supported=256)
        0000:46:00.0 Endpoint                     (MPS supported=512)
        0000:46:00.1 Endpoint                     (MPS supported=512)
    
        # echo 0 > /sys/bus/pci/slots/7/power
        # echo 1 > /sys/bus/pci/slots/7/power
        pcieport 0000:40:07.0: PCI-E Max Payload Size set to 256/ 256 (was 256)
        pci 0000:46:00.0:      PCI-E Max Payload Size set to 256/ 512 (was 128)
        pci 0000:46:00.1:      PCI-E Max Payload Size set to 256/ 512 (was 128)
    
    Before this change, we set MPS to 128 for the Root Port and both NICs
    because the slot contained a multi-function device and
    
        dev->is_hotplug_bridge && !list_is_singular(&dev->bus->devices)
    
    was true.  After this change, we set it to 256.
    
    [bhelgaas: changelog, comments, split out upstream bridge check]
    Signed-off-by: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Jon Mason <jdmason@kudzu.us>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 0591b087a6c3..94b1d227ddcd 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1491,23 +1491,23 @@ static int pcie_find_smpss(struct pci_dev *dev, void *data)
 	if (!pci_is_pcie(dev))
 		return 0;
 
-	/* For PCIE hotplug enabled slots not connected directly to a
-	 * PCI-E root port, there can be problems when hotplugging
-	 * devices.  This is due to the possibility of hotplugging a
-	 * device into the fabric with a smaller MPS that the devices
-	 * currently running have configured.  Modifying the MPS on the
-	 * running devices could cause a fatal bus error due to an
-	 * incoming frame being larger than the newly configured MPS.
-	 * To work around this, the MPS for the entire fabric must be
-	 * set to the minimum size.  Any devices hotplugged into this
-	 * fabric will have the minimum MPS set.  If the PCI hotplug
-	 * slot is directly connected to the root port and there are not
-	 * other devices on the fabric (which seems to be the most
-	 * common case), then this is not an issue and MPS discovery
-	 * will occur as normal.
+	/*
+	 * We don't have a way to change MPS settings on devices that have
+	 * drivers attached.  A hot-added device might support only the minimum
+	 * MPS setting (MPS=128).  Therefore, if the fabric contains a bridge
+	 * where devices may be hot-added, we limit the fabric MPS to 128 so
+	 * hot-added devices will work correctly.
+	 *
+	 * However, if we hot-add a device to a slot directly below a Root
+	 * Port, it's impossible for there to be other existing devices below
+	 * the port.  We don't limit the MPS in this case because we can
+	 * reconfigure MPS on both the Root Port and the hot-added device,
+	 * and there are no other devices involved.
+	 *
+	 * Note that this PCIE_BUS_SAFE path assumes no peer-to-peer DMA.
 	 */
-	if (dev->is_hotplug_bridge && (!list_is_singular(&dev->bus->devices) ||
-	    pci_pcie_type(dev) != PCI_EXP_TYPE_ROOT_PORT))
+	if (dev->is_hotplug_bridge &&
+	    pci_pcie_type(dev) != PCI_EXP_TYPE_ROOT_PORT)
 		*smpss = 0;
 
 	if (*smpss > dev->pcie_mpss)

commit c2996948ac36a9082f27b9ad94dac4c821a9c33d
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Aug 22 11:24:46 2013 +0800

    PCI: Simplify MPS test for Downstream Port
    
    PCIe hotplug bridges are always either Root Ports or Downstream Ports.  No
    other device type can have a PCIe link leading downstream to a slot.
    
    Root Ports don't have an upstream bridge, so "dev->is_hotplug_bridge &&
    dev->bus->self" is true if and only if "dev" is a Downstream Port.  That
    means we can simplify this by looking at the type of "dev" itself, without
    looking upstream at all.
    
    No functional change.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index ecae7f290647..0591b087a6c3 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1507,8 +1507,7 @@ static int pcie_find_smpss(struct pci_dev *dev, void *data)
 	 * will occur as normal.
 	 */
 	if (dev->is_hotplug_bridge && (!list_is_singular(&dev->bus->devices) ||
-	     (dev->bus->self &&
-	      pci_pcie_type(dev->bus->self) != PCI_EXP_TYPE_ROOT_PORT)))
+	    pci_pcie_type(dev) != PCI_EXP_TYPE_ROOT_PORT))
 		*smpss = 0;
 
 	if (*smpss > dev->pcie_mpss)

commit a58674ff8383f5b8f6a77f03c48f6a47840b9325
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Aug 22 11:24:44 2013 +0800

    PCI: Simplify pcie_bus_configure_settings() interface
    
    Based on a patch by Jon Mason (see URL below).
    
    All users of pcie_bus_configure_settings() pass arguments of the form
    "bus, bus->self->pcie_mpss".  The "mpss" argument is redundant since we
    can easily look it up internally.  In addition, all callers check
    "bus->self" for NULL, which we can also do internally.
    
    This patch simplifies the interface and the callers.  No functional change.
    
    Reference: http://lkml.kernel.org/r/1317048850-30728-2-git-send-email-mason@myri.com
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 9a334301a8f4..ecae7f290647 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1607,10 +1607,13 @@ static int pcie_bus_configure_set(struct pci_dev *dev, void *data)
  * parents then children fashion.  If this changes, then this code will not
  * work as designed.
  */
-void pcie_bus_configure_settings(struct pci_bus *bus, u8 mpss)
+void pcie_bus_configure_settings(struct pci_bus *bus)
 {
 	u8 smpss;
 
+	if (!bus->self)
+		return;
+
 	if (!pci_is_pcie(bus->self))
 		return;
 
@@ -1625,7 +1628,7 @@ void pcie_bus_configure_settings(struct pci_bus *bus, u8 mpss)
 		smpss = 0;
 
 	if (pcie_bus_config == PCIE_BUS_SAFE) {
-		smpss = mpss;
+		smpss = bus->self->pcie_mpss;
 
 		pcie_find_smpss(bus->self, &smpss);
 		pci_walk_bus(bus, pcie_find_smpss, &smpss);

commit 2c25e34c7531ca1849b85cbcdb5a2f507ffe240c
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Aug 22 11:24:43 2013 +0800

    PCI: Drop "PCI-E" prefix from Max Payload Size message
    
    The conventional spelling is "PCIe", but I think even that is superfluous,
    so remove the whole thing.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 46ada5c098eb..9a334301a8f4 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1596,7 +1596,7 @@ static int pcie_bus_configure_set(struct pci_dev *dev, void *data)
 	pcie_write_mps(dev, mps);
 	pcie_write_mrrs(dev);
 
-	dev_info(&dev->dev, "PCI-E Max Payload Size set to %4d/%4d (was %4d), "
+	dev_info(&dev->dev, "Max Payload Size set to %4d/%4d (was %4d), "
 		 "Max Read Rq %4d\n", pcie_get_mps(dev), 128 << dev->pcie_mpss,
 		 orig_mps, pcie_get_readrq(dev));
 

commit 0cbdcfcf427b63b9670e56760ef5e67cd7081b35
Author: Thierry Reding <thierry.reding@avionic-design.de>
Date:   Fri Aug 9 22:27:08 2013 +0200

    PCI: Introduce new MSI chip infrastructure
    
    The new struct msi_chip is used to associated an MSI controller with a
    PCI bus. It is automatically handed down from the root to its children
    during bus enumeration.
    
    This patch provides default (weak) implementations for the architecture-
    specific MSI functions (arch_setup_msi_irq(), arch_teardown_msi_irq()
    and arch_msi_check_device()) which check if a PCI device's bus has an
    attached MSI chip and forward the call appropriately.
    
    Signed-off-by: Thierry Reding <thierry.reding@avionic-design.de>
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Tested-by: Daniel Price <daniel.price@gmail.com>
    Tested-by: Thierry Reding <thierry.reding@gmail.com>
    Signed-off-by: Jason Cooper <jason@lakedaemon.net>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 46ada5c098eb..b8eaa8167849 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -666,6 +666,7 @@ static struct pci_bus *pci_alloc_child_bus(struct pci_bus *parent,
 
 	child->parent = parent;
 	child->ops = parent->ops;
+	child->msi = parent->msi;
 	child->sysdata = parent->sysdata;
 	child->bus_flags = parent->bus_flags;
 

commit 343e51ae6e3f64ed26d96f5560f4962529794c9f
Author: Jacob Keller <jacob.e.keller@intel.com>
Date:   Wed Jul 31 06:53:16 2013 +0000

    PCI: expose pcie_link_speed and pcix_bus_speed arrays
    
    pcie_link_speed and pcix_bus_speed are arrays used by probe.c to correctly
    convert lnksta register values into the pci_bus_speed enum. These static arrays
    are useful outside probe for this purpose. This patch makes these defines into
    conist arrays and exposes them with an extern header in drivers/pci/pci.h
    
    -v2-
    * move extern declarations to drivers/pci/pci.h
    
    CC: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Jacob Keller <jacob.e.keller@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 46ada5c098eb..496c5b082d42 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -513,7 +513,7 @@ static struct pci_host_bridge *pci_alloc_host_bridge(struct pci_bus *b)
 	return bridge;
 }
 
-static unsigned char pcix_bus_speed[] = {
+const unsigned char pcix_bus_speed[] = {
 	PCI_SPEED_UNKNOWN,		/* 0 */
 	PCI_SPEED_66MHz_PCIX,		/* 1 */
 	PCI_SPEED_100MHz_PCIX,		/* 2 */
@@ -532,7 +532,7 @@ static unsigned char pcix_bus_speed[] = {
 	PCI_SPEED_133MHz_PCIX_533	/* F */
 };
 
-static unsigned char pcie_link_speed[] = {
+const unsigned char pcie_link_speed[] = {
 	PCI_SPEED_UNKNOWN,		/* 0 */
 	PCIE_SPEED_2_5GT,		/* 1 */
 	PCIE_SPEED_5_0GT,		/* 2 */

commit 928bea964827d7824b548c1f8e06eccbbc4d0d7d
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Mon Jul 22 14:37:17 2013 -0700

    PCI: Delay enabling bridges until they're needed
    
    We currently enable PCI bridges after scanning a bus and assigning
    resources.  This is often done in arch code.
    
    This patch changes this so we don't enable a bridge until necessary, i.e.,
    until we enable a PCI device behind the bridge.  We do this in the generic
    pci_enable_device() path, so this also removes the arch-specific code to
    enable bridges.
    
    [bhelgaas: changelog]
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 46ada5c098eb..85c114cd91cc 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1979,7 +1979,6 @@ unsigned int __ref pci_rescan_bus(struct pci_bus *bus)
 
 	max = pci_scan_child_bus(bus);
 	pci_assign_unassigned_bus_resources(bus);
-	pci_enable_bridges(bus);
 	pci_bus_add_devices(bus);
 
 	return max;

commit 56039e658cc902fe6e3d1276bb78f7e69768cd35
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Jul 24 15:05:17 2013 -0700

    PCI: Convert class code to use dev_groups
    
    The dev_attrs field of struct class is going away soon, dev_groups
    should be used instead.  This converts the PCI class code to use the
    correct field.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 46ada5c098eb..cf57fe79450a 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -96,7 +96,7 @@ static void release_pcibus_dev(struct device *dev)
 static struct class pcibus_class = {
 	.name		= "pci_bus",
 	.dev_release	= &release_pcibus_dev,
-	.dev_attrs	= pcibus_dev_attrs,
+	.dev_groups	= pcibus_groups,
 };
 
 static int __init pcibus_class_init(void)

commit df58f46c0f2a1d69268b734ac25c87ffb7aeb32a
Merge: 726246d2e6d0 050134864c1c
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Jun 14 17:47:46 2013 -0600

    Merge branch 'pci/jiang-bus-lock-v3' into next
    
    * pci/jiang-bus-lock-v3:
      PCI: Return early on allocation failures to unindent mainline code
      PCI: Simplify IOV implementation and fix reference count races
      PCI: Drop redundant setting of bus->is_added in virtfn_add_bus()
      unicore32/PCI: Remove redundant call of pci_bus_add_devices()
      m68k/PCI: Remove redundant call of pci_bus_add_devices()
      PCI: Rename pci_release_bus_bridge_dev() to pci_release_host_bridge_dev()
      PCI: Fix refcount issue in pci_create_root_bus() error recovery path
      ia64/PCI: Clean up pci_scan_root_bus() usage
      PCI: Convert alloc_pci_dev(void) to pci_alloc_dev(bus)
      PCI: Introduce pci_alloc_dev(struct pci_bus*) to replace alloc_pci_dev()
      PCI: Introduce pci_bus_{get|put}() to manage PCI bus reference count
    
    Conflicts:
            drivers/pci/probe.c

commit 050134864c1c76f49eb86c134a0e02fb3c196382
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Jun 5 14:22:11 2013 -0600

    PCI: Return early on allocation failures to unindent mainline code
    
    On allocation failure, return early so the main body of the function
    doesn't have to be indented as the body of an "if" statement.  No
    functional change.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index a723b2b93ab4..14af6ef4959c 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -451,20 +451,21 @@ void pci_read_bridge_bases(struct pci_bus *child)
 	}
 }
 
-static struct pci_bus * pci_alloc_bus(void)
+static struct pci_bus *pci_alloc_bus(void)
 {
 	struct pci_bus *b;
 
 	b = kzalloc(sizeof(*b), GFP_KERNEL);
-	if (b) {
-		INIT_LIST_HEAD(&b->node);
-		INIT_LIST_HEAD(&b->children);
-		INIT_LIST_HEAD(&b->devices);
-		INIT_LIST_HEAD(&b->slots);
-		INIT_LIST_HEAD(&b->resources);
-		b->max_bus_speed = PCI_SPEED_UNKNOWN;
-		b->cur_bus_speed = PCI_SPEED_UNKNOWN;
-	}
+	if (!b)
+		return NULL;
+
+	INIT_LIST_HEAD(&b->node);
+	INIT_LIST_HEAD(&b->children);
+	INIT_LIST_HEAD(&b->devices);
+	INIT_LIST_HEAD(&b->slots);
+	INIT_LIST_HEAD(&b->resources);
+	b->max_bus_speed = PCI_SPEED_UNKNOWN;
+	b->cur_bus_speed = PCI_SPEED_UNKNOWN;
 	return b;
 }
 
@@ -485,11 +486,11 @@ static struct pci_host_bridge *pci_alloc_host_bridge(struct pci_bus *b)
 	struct pci_host_bridge *bridge;
 
 	bridge = kzalloc(sizeof(*bridge), GFP_KERNEL);
-	if (bridge) {
-		INIT_LIST_HEAD(&bridge->windows);
-		bridge->bus = b;
-	}
+	if (!bridge)
+		return NULL;
 
+	INIT_LIST_HEAD(&bridge->windows);
+	bridge->bus = b;
 	return bridge;
 }
 

commit 726246d2e6d0ed53ac22b6fec50d1345f25e6730
Merge: 5899309c9097 fc6504b3a4dc
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Jun 14 17:08:48 2013 -0600

    Merge branch 'pci/misc' into next
    
    * pci/misc:
      PCI / ACPI / PM: Use correct power state strings in messages
      PCI: Fix comment typo for pcie_pme_remove()
      PCI: Add pcibios_release_device()

commit 70efde2a2920c12f2b14eb640944ca7e61b2c02d
Author: Jiang Liu <liuj97@gmail.com>
Date:   Fri Jun 7 16:16:51 2013 -0600

    PCI: Rename pci_release_bus_bridge_dev() to pci_release_host_bridge_dev()
    
    This renames pci_release_bus_bridge_dev() to pci_release_host_bridge_dev()
    and moves it next to pci_alloc_host_bridge().  No functional change.
    
    [bhelgaas: split rename & move out of create/destroy symmetry patch]
    Signed-off-by: Jiang Liu <jiang.liu@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 15c39cb09619..a723b2b93ab4 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -468,6 +468,18 @@ static struct pci_bus * pci_alloc_bus(void)
 	return b;
 }
 
+static void pci_release_host_bridge_dev(struct device *dev)
+{
+	struct pci_host_bridge *bridge = to_pci_host_bridge(dev);
+
+	if (bridge->release_fn)
+		bridge->release_fn(bridge);
+
+	pci_free_resource_list(&bridge->windows);
+
+	kfree(bridge);
+}
+
 static struct pci_host_bridge *pci_alloc_host_bridge(struct pci_bus *b)
 {
 	struct pci_host_bridge *bridge;
@@ -1189,18 +1201,6 @@ int pci_cfg_space_size(struct pci_dev *dev)
 	return PCI_CFG_SPACE_SIZE;
 }
 
-static void pci_release_bus_bridge_dev(struct device *dev)
-{
-	struct pci_host_bridge *bridge = to_pci_host_bridge(dev);
-
-	if (bridge->release_fn)
-		bridge->release_fn(bridge);
-
-	pci_free_resource_list(&bridge->windows);
-
-	kfree(bridge);
-}
-
 struct pci_dev *pci_alloc_dev(struct pci_bus *bus)
 {
 	struct pci_dev *dev;
@@ -1708,7 +1708,7 @@ struct pci_bus *pci_create_root_bus(struct device *parent, int bus,
 		goto err_out;
 
 	bridge->dev.parent = parent;
-	bridge->dev.release = pci_release_bus_bridge_dev;
+	bridge->dev.release = pci_release_host_bridge_dev;
 	dev_set_name(&bridge->dev, "pci%04x:%02x", pci_domain_nr(b), bus);
 	error = pcibios_root_bridge_prepare(bridge);
 	if (error) {

commit 343df771e671d821478dd3ef525a0610b808dbf8
Author: Jiang Liu <liuj97@gmail.com>
Date:   Fri Jun 7 01:10:08 2013 +0800

    PCI: Fix refcount issue in pci_create_root_bus() error recovery path
    
    After calling device_register(&bridge->dev), the bridge is reference-
    counted, and it is illegal to call kfree() on it except in the release
    function.
    
    [bhelgaas: changelog, use put_device() after device_register() failure]
    Signed-off-by: Jiang Liu <jiang.liu@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index ed5ce185eed9..15c39cb09619 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1711,12 +1711,16 @@ struct pci_bus *pci_create_root_bus(struct device *parent, int bus,
 	bridge->dev.release = pci_release_bus_bridge_dev;
 	dev_set_name(&bridge->dev, "pci%04x:%02x", pci_domain_nr(b), bus);
 	error = pcibios_root_bridge_prepare(bridge);
-	if (error)
-		goto bridge_dev_reg_err;
+	if (error) {
+		kfree(bridge);
+		goto err_out;
+	}
 
 	error = device_register(&bridge->dev);
-	if (error)
-		goto bridge_dev_reg_err;
+	if (error) {
+		put_device(&bridge->dev);
+		goto err_out;
+	}
 	b->bridge = get_device(&bridge->dev);
 	device_enable_async_suspend(b->bridge);
 	pci_set_bus_of_node(b);
@@ -1772,8 +1776,6 @@ struct pci_bus *pci_create_root_bus(struct device *parent, int bus,
 class_dev_reg_err:
 	put_device(&bridge->dev);
 	device_unregister(&bridge->dev);
-bridge_dev_reg_err:
-	kfree(bridge);
 err_out:
 	kfree(b);
 	return NULL;

commit 8b1fce04dc2a2210f050484afa85acc3a81cfbba
Author: Gu Zheng <guz.fnst@cn.fujitsu.com>
Date:   Sat May 25 21:48:31 2013 +0800

    PCI: Convert alloc_pci_dev(void) to pci_alloc_dev(bus)
    
    Use the new pci_alloc_dev(bus) to replace the existing using of
    alloc_pci_dev(void).
    
    [bhelgaas: drop pci_bus ref later in pci_release_dev()]
    Signed-off-by: Gu Zheng <guz.fnst@cn.fujitsu.com>
    Signed-off-by: Jiang Liu <jiang.liu@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Neela Syam Kolli <megaraidlinux@lsi.com>
    Cc: "James E.J. Bottomley" <JBottomley@parallels.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index d47ce1400c26..ed5ce185eed9 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1132,6 +1132,7 @@ static void pci_release_dev(struct device *dev)
 	pci_dev = to_pci_dev(dev);
 	pci_release_capabilities(pci_dev);
 	pci_release_of_node(pci_dev);
+	pci_bus_put(pci_dev->bus);
 	kfree(pci_dev);
 }
 
@@ -1270,11 +1271,10 @@ static struct pci_dev *pci_scan_device(struct pci_bus *bus, int devfn)
 	if (!pci_bus_read_dev_vendor_id(bus, devfn, &l, 60*1000))
 		return NULL;
 
-	dev = alloc_pci_dev();
+	dev = pci_alloc_dev(bus);
 	if (!dev)
 		return NULL;
 
-	dev->bus = bus;
 	dev->devfn = devfn;
 	dev->vendor = l & 0xffff;
 	dev->device = (l >> 16) & 0xffff;
@@ -1282,6 +1282,7 @@ static struct pci_dev *pci_scan_device(struct pci_bus *bus, int devfn)
 	pci_set_of_node(dev);
 
 	if (pci_setup_device(dev)) {
+		pci_bus_put(dev->bus);
 		kfree(dev);
 		return NULL;
 	}

commit 6ae32c539c0412ca789fb6041be45eeabf78431c
Author: Sebastian Ott <sebott@linux.vnet.ibm.com>
Date:   Tue Jun 4 19:18:14 2013 +0200

    PCI: Add pcibios_release_device()
    
    Platforms may want to provide architecture-specific functionality when
    a PCI device is released.  Add a pcibios_release_device() call that
    architectures can override to do so.
    
    Signed-off-by: Sebastian Ott <sebott@linux.vnet.ibm.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 70f10fa3c1b2..58cc0a8a0979 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1132,6 +1132,7 @@ static void pci_release_dev(struct device *dev)
 	pci_dev = to_pci_dev(dev);
 	pci_release_capabilities(pci_dev);
 	pci_release_of_node(pci_dev);
+	pcibios_release_device(pci_dev);
 	kfree(pci_dev);
 }
 

commit 3c6e6ae770f338ef3e54c5823c21063204f53537
Author: Gu Zheng <guz.fnst@cn.fujitsu.com>
Date:   Sat May 25 21:48:30 2013 +0800

    PCI: Introduce pci_alloc_dev(struct pci_bus*) to replace alloc_pci_dev()
    
    Here we introduce a new interface to replace alloc_pci_dev():
    
        struct pci_dev *pci_alloc_dev(struct pci_bus *bus)
    
    It takes a "struct pci_bus *" argument, so we can alloc a PCI device
    on a target PCI bus, and it acquires a reference on the pci_bus.
    We use pci_alloc_dev(NULL) to simplify the old alloc_pci_dev(),
    and keep it for a while but mark it as __deprecated.
    
    Holding a reference to the pci_bus ensures that referencing
    pci_dev->bus is valid as long as the pci_dev is valid.
    
    [bhelgaas: keep existing "return error early" structure in pci_alloc_dev()]
    Signed-off-by: Gu Zheng <guz.fnst@cn.fujitsu.com>
    Signed-off-by: Jiang Liu <jiang.liu@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 70f10fa3c1b2..d47ce1400c26 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1200,7 +1200,7 @@ static void pci_release_bus_bridge_dev(struct device *dev)
 	kfree(bridge);
 }
 
-struct pci_dev *alloc_pci_dev(void)
+struct pci_dev *pci_alloc_dev(struct pci_bus *bus)
 {
 	struct pci_dev *dev;
 
@@ -1210,9 +1210,16 @@ struct pci_dev *alloc_pci_dev(void)
 
 	INIT_LIST_HEAD(&dev->bus_list);
 	dev->dev.type = &pci_dev_type;
+	dev->bus = pci_bus_get(bus);
 
 	return dev;
 }
+EXPORT_SYMBOL(pci_alloc_dev);
+
+struct pci_dev *alloc_pci_dev(void)
+{
+	return pci_alloc_dev(NULL);
+}
 EXPORT_SYMBOL(alloc_pci_dev);
 
 bool pci_bus_read_dev_vendor_id(struct pci_bus *bus, int devfn, u32 *l,

commit cf4d1cf5ac5e7d2b886af6ed906ea0dcdc5b6855
Author: Kevin Hao <haokexin@gmail.com>
Date:   Sat May 25 19:36:27 2013 +0800

    PCI: Unset resource if initial BAR value is invalid
    
    The initial BAR value in the following example is invalid:
    
      pci_bus 0000:00: root bus resource [mem 0xa0000000-0xbfffffff] (bus address [0xe0000000-0xffffffff])
      pci 0000:01:00.0: reg 10: initial BAR value: 0xa0000000
      pci 0000:01:00.0: reg 10: [mem 0xa0000000-0xa000007f 64bit]
    
    bus_to_resource(0xa0000000) yields 0xa0000000 because there's no host
    bridge window whose bus address range contains 0xa0000000.  But CPU
    accesses to 0xa0000000 appear on the bus at 0xe0000000, so they will
    not be claimed if the BAR contains 0xa0000000.
    
    If we find a BAR where resource_to_bus(bus_to_resource(A)) != A, we can
    work around this problem by reassigning the BAR.
    
    [bhelgaas: changelog, comment]
    Reference: https://lkml.kernel.org/r/1368536876-27307-3-git-send-email-haokexin@gmail.com
    Signed-off-by: Kevin Hao <haokexin@gmail.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index cd7b6de9376c..fe5b50bd7536 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -170,7 +170,7 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 {
 	u32 l, sz, mask;
 	u16 orig_cmd;
-	struct pci_bus_region region;
+	struct pci_bus_region region, inverted_region;
 	bool bar_too_big = false, bar_disabled = false;
 
 	mask = type ? PCI_ROM_ADDRESS_MASK : ~0;
@@ -266,6 +266,26 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 	}
 
 	pcibios_bus_to_resource(dev, res, &region);
+	pcibios_resource_to_bus(dev, &inverted_region, res);
+
+	/*
+	 * If "A" is a BAR value (a bus address), "bus_to_resource(A)" is
+	 * the corresponding resource address (the physical address used by
+	 * the CPU.  Converting that resource address back to a bus address
+	 * should yield the original BAR value:
+	 *
+	 *     resource_to_bus(bus_to_resource(A)) == A
+	 *
+	 * If it doesn't, CPU accesses to "bus_to_resource(A)" will not
+	 * be claimed by the device.
+	 */
+	if (inverted_region.start != region.start) {
+		dev_info(&dev->dev, "reg 0x%x: initial BAR value %pa invalid; forcing reassignment\n",
+			 pos, &region.start);
+		res->flags |= IORESOURCE_UNSET;
+		res->end -= res->start;
+		res->start = 0;
+	}
 
 	goto out;
 

commit 96ddef25b24a6159e78fb53c1b13336914ff1154
Author: Kevin Hao <haokexin@gmail.com>
Date:   Sat May 25 19:36:26 2013 +0800

    PCI: Consolidate calls to pcibios_bus_to_resource() in __pci_read_base()
    
    Since we will invoke pcibios_bus_to_resource() unconditionally if we
    don't goto fail, move it out of if/else wrap.  No function change.
    
    Signed-off-by: Kevin Hao <haokexin@gmail.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index d40cd05bbf64..cd7b6de9376c 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -250,12 +250,10 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 			pci_write_config_dword(dev, pos + 4, 0);
 			region.start = 0;
 			region.end = sz64;
-			pcibios_bus_to_resource(dev, res, &region);
 			bar_disabled = true;
 		} else {
 			region.start = l64;
 			region.end = l64 + sz64;
-			pcibios_bus_to_resource(dev, res, &region);
 		}
 	} else {
 		sz = pci_size(l, sz, mask);
@@ -265,9 +263,10 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 
 		region.start = l;
 		region.end = l + sz;
-		pcibios_bus_to_resource(dev, res, &region);
 	}
 
+	pcibios_bus_to_resource(dev, res, &region);
+
 	goto out;
 
 

commit 33963e308e98064ce89d961ffeede2fb055f8ffc
Author: Kevin Hao <haokexin@gmail.com>
Date:   Sat May 25 19:36:25 2013 +0800

    PCI: Add 0x prefix to BAR register position in __pci_read_base()
    
    We print the BAR register's position in hexadecimal format, so it
    is more readable if 0x prefix is added.
    
    [bhelgaas: keep dev_printk(), not dev_dbg(), so this is always in dmesg]
    Signed-off-by: Kevin Hao <haokexin@gmail.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 70f10fa3c1b2..d40cd05bbf64 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -278,9 +278,9 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 		pci_write_config_word(dev, PCI_COMMAND, orig_cmd);
 
 	if (bar_too_big)
-		dev_err(&dev->dev, "reg %x: can't handle 64-bit BAR\n", pos);
+		dev_err(&dev->dev, "reg 0x%x: can't handle 64-bit BAR\n", pos);
 	if (res->flags && !bar_disabled)
-		dev_printk(KERN_DEBUG, &dev->dev, "reg %x: %pR\n", pos, res);
+		dev_printk(KERN_DEBUG, &dev->dev, "reg 0x%x: %pR\n", pos, res);
 
 	return (res->flags & IORESOURCE_MEM_64) ? 1 : 0;
 }

commit e15e6119062d20cc96f95c8b345e361589a90244
Merge: a637b0d45947 e253aaf0af51
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu May 9 10:21:44 2013 -0700

    Merge tag 'pci-v3.10-fixes-1' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI updates from Bjorn Helgaas:
     "MSI:
          PCI: Set ->mask_pos correctly
      Hotplug:
          PCI: Delay final fixups until resources are assigned
      Moorestown:
          x86/pci/mrst: Use configuration mechanism 1 for 00:00.0, 00:02.0, 00:03.0"
    
    * tag 'pci-v3.10-fixes-1' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci:
      PCI: Delay final fixups until resources are assigned
      x86/pci/mrst: Use configuration mechanism 1 for 00:00.0, 00:02.0, 00:03.0
      PCI: Set ->mask_pos correctly

commit e253aaf0af51c1e4dc7dd3b26ea8e666bf9a2d8d
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Tue May 7 14:35:44 2013 -0600

    PCI: Delay final fixups until resources are assigned
    
    Commit 4f535093cf "PCI: Put pci_dev in device tree as early as possible"
    moved final fixups from pci_bus_add_device() to pci_device_add().  But
    pci_device_add() happens before resource assignment, so BARs may not be
    valid yet.
    
    Typical flow for hot-add:
    
        pciehp_configure_device
          pci_scan_slot
            pci_scan_single_device
              pci_device_add
                pci_fixup_device(pci_fixup_final, dev)  # previous location
          # resource assignment happens here
          pci_bus_add_devices
            pci_bus_add_device
              pci_fixup_device(pci_fixup_final, dev)    # new location
    
    [bhelgaas: changelog, move fixups to pci_bus_add_device()]
    Reference: https://lkml.kernel.org/r/20130415182614.GB9224@xanatos
    Reported-by: David Bulkow <David.Bulkow@stratus.com>
    Tested-by: David Bulkow <David.Bulkow@stratus.com>
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    CC: stable@vger.kernel.org      # v3.9+

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 43ece5d41d36..67cd04575e2e 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1341,7 +1341,6 @@ void pci_device_add(struct pci_dev *dev, struct pci_bus *bus)
 	list_add_tail(&dev->bus_list, &bus->devices);
 	up_write(&pci_bus_sem);
 
-	pci_fixup_device(pci_fixup_final, dev);
 	ret = pcibios_add_device(dev);
 	WARN_ON(ret < 0);
 

commit 5a148af66932c31814e263366094b5812210b501
Merge: 99c6bcf46d22 54d5999d98f2
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu May 2 10:16:16 2013 -0700

    Merge branch 'next' of git://git.kernel.org/pub/scm/linux/kernel/git/benh/powerpc
    
    Pull powerpc update from Benjamin Herrenschmidt:
     "The main highlights this time around are:
    
       - A pile of addition POWER8 bits and nits, such as updated
         performance counter support (Michael Ellerman), new branch history
         buffer support (Anshuman Khandual), base support for the new PCI
         host bridge when not using the hypervisor (Gavin Shan) and other
         random related bits and fixes from various contributors.
    
       - Some rework of our page table format by Aneesh Kumar which fixes a
         thing or two and paves the way for THP support.  THP itself will
         not make it this time around however.
    
       - More Freescale updates, including Altivec support on the new e6500
         cores, new PCI controller support, and a pile of new boards support
         and updates.
    
       - The usual batch of trivial cleanups & fixes"
    
    * 'next' of git://git.kernel.org/pub/scm/linux/kernel/git/benh/powerpc: (156 commits)
      powerpc: Fix build error for book3e
      powerpc: Context switch the new EBB SPRs
      powerpc: Turn on the EBB H/FSCR bits
      powerpc: Replace CPU_FTR_BCTAR with CPU_FTR_ARCH_207S
      powerpc: Setup BHRB instructions facility in HFSCR for POWER8
      powerpc: Fix interrupt range check on debug exception
      powerpc: Update tlbie/tlbiel as per ISA doc
      powerpc: Print page size info during boot
      powerpc: print both base and actual page size on hash failure
      powerpc: Fix hpte_decode to use the correct decoding for page sizes
      powerpc: Decode the pte-lp-encoding bits correctly.
      powerpc: Use encode avpn where we need only avpn values
      powerpc: Reduce PTE table memory wastage
      powerpc: Move the pte free routines from common header
      powerpc: Reduce the PTE_INDEX_SIZE
      powerpc: Switch 16GB and 16MB explicit hugepages to a different page table format
      powerpc: New hugepage directory format
      powerpc: Don't truncate pgd_index wrongly
      powerpc: Don't hard code the size of pte page
      powerpc: Save DAR and DSISR in pt_regs on MCE
      ...

commit 88e7b167a079f090405ab4390b629b5effdab41a
Author: Brian King <brking@linux.vnet.ibm.com>
Date:   Mon Apr 8 03:05:07 2013 +0000

    pci: Set dev->dev.type in alloc_pci_dev
    
    Set dev->dev.type in alloc_pci_dev so that archs that have their own
    versions of pci_setup_device get this set properly in order to ensure
    things like the boot_vga sysfs parameter get created as expected.
    
    Signed-off-by: Brian King <brking@linux.vnet.ibm.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Michael Ellerman <michael@ellerman.id.au>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index b494066ef32f..92be60cf5214 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -988,7 +988,6 @@ int pci_setup_device(struct pci_dev *dev)
 	dev->sysdata = dev->bus->sysdata;
 	dev->dev.parent = dev->bus->bridge;
 	dev->dev.bus = &pci_bus_type;
-	dev->dev.type = &pci_dev_type;
 	dev->hdr_type = hdr_type & 0x7f;
 	dev->multifunction = !!(hdr_type & 0x80);
 	dev->error_state = pci_channel_io_normal;
@@ -1208,6 +1207,7 @@ struct pci_dev *alloc_pci_dev(void)
 		return NULL;
 
 	INIT_LIST_HEAD(&dev->bus_list);
+	dev->dev.type = &pci_dev_type;
 
 	return dev;
 }

commit 10a9574756201fbbdd0cac11f370f00d3d02bfa1
Author: Jiang Liu <liuj97@gmail.com>
Date:   Fri Apr 12 05:44:20 2013 +0000

    PCI: Add pcibios hooks for adding and removing PCI buses
    
    On ACPI-based platforms, the pci_slot driver creates PCI slot devices
    according to information from ACPI tables by registering an ACPI PCI
    subdriver.  The ACPI PCI subdriver will only be called when creating/
    destroying PCI root buses, and it won't be called when hot-plugging
    P2P bridges.  It may cause stale PCI slot devices after hot-removing
    a P2P bridge if that bridge has associated PCI slots.  And the acpiphp
    driver has the same issue too.
    
    This patch introduces two hook points into the PCI core, which will
    be invoked when creating/destroying PCI buses for PCI host and P2P
    bridges.  They could be used to setup/destroy platform dependent stuff
    in a unified way, both at boot time and for PCI hotplug operations.
    
    Signed-off-by: Jiang Liu <jiang.liu@huawei.com>
    Signed-off-by: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Yinghai Lu <yinghai@kernel.org>
    Cc: "Rafael J. Wysocki" <rafael.j.wysocki@intel.com>
    Cc: Toshi Kani <toshi.kani@hp.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Fenghua Yu <fenghua.yu@intel.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Myron Stowe <myron.stowe@redhat.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 45c93b39af35..43ece5d41d36 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -673,6 +673,8 @@ static struct pci_bus *pci_alloc_child_bus(struct pci_bus *parent,
 	ret = device_register(&child->dev);
 	WARN_ON(ret < 0);
 
+	pcibios_add_bus(child);
+
 	/* Create legacy_io and legacy_mem files for this bus */
 	pci_create_legacy_files(child);
 
@@ -1660,6 +1662,14 @@ int __weak pcibios_root_bridge_prepare(struct pci_host_bridge *bridge)
 	return 0;
 }
 
+void __weak pcibios_add_bus(struct pci_bus *bus)
+{
+}
+
+void __weak pcibios_remove_bus(struct pci_bus *bus)
+{
+}
+
 struct pci_bus *pci_create_root_bus(struct device *parent, int bus,
 		struct pci_ops *ops, void *sysdata, struct list_head *resources)
 {
@@ -1714,6 +1724,8 @@ struct pci_bus *pci_create_root_bus(struct device *parent, int bus,
 	if (error)
 		goto class_dev_reg_err;
 
+	pcibios_add_bus(b);
+
 	/* Create legacy_io and legacy_mem files for this bus */
 	pci_create_legacy_files(b);
 

commit 981cf9ea9a6a6c422e51fc04bedad00b7792ccbc
Author: Jiang Liu <liuj97@gmail.com>
Date:   Fri Apr 12 05:44:16 2013 +0000

    PCI: Clean up usages of pci_bus->is_added
    
    Now pci_bus->is_added is only used to guard invoking of
    pcibios_fixup_bus() in pci_scan_child_bus(), so just set
    it directly after the fixups and remove the other test
    and set in pci_bus_add_devices().
    
    [bhelgaas: changelog]
    Signed-off-by: Jiang Liu <jiang.liu@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Yinghai Lu <yinghai@kernel.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index b494066ef32f..45c93b39af35 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1627,8 +1627,7 @@ unsigned int pci_scan_child_bus(struct pci_bus *bus)
 	if (!bus->is_added) {
 		dev_dbg(&bus->dev, "fixups for bus\n");
 		pcibios_fixup_bus(bus);
-		if (pci_is_root_bus(bus))
-			bus->is_added = 1;
+		bus->is_added = 1;
 	}
 
 	for (pass=0; pass < 2; pass++)

commit 939de1d69c5fb0da0cfe05a1a7c981421cf876f7
Merge: fb455792d914 4f535093cf8f
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Sat Jan 26 17:35:58 2013 -0700

    Merge branch 'pci/yinghai-root-bus-hotplug' into next
    
    * pci/yinghai-root-bus-hotplug:
      PCI: Put pci_dev in device tree as early as possible
      PCI: Skip attaching driver in device_add()
      PCI: acpiphp: Keep driver loaded even if no slots found
      PCI/ACPI: Print info if host bridge notify handler installation fails
      PCI: acpiphp: Move host bridge hotplug to pci_root.c
      PCI/ACPI: acpiphp: Rename alloc_acpiphp_hp_work() to alloc_acpi_hp_work()
      PCI: Make device create/destroy logic symmetric
      PCI: Fix reference count leak in pci_dev_present()
      PCI: Set pci_dev dev_node early so IOAPIC irq_descs are allocated locally
      PCI: Add root bus children dev's res to fail list
      PCI: acpiphp: Add is_hotplug_bridge detection
    
    Conflicts:
            drivers/pci/pci.h

commit 14b5cb37cc6172a54ce920c61784f44422ae306d
Merge: 708b59bfe1d1 fcbed0bcb216
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Sat Jan 26 17:27:36 2013 -0700

    Merge branch 'pci/yijing-ari' into next
    
    * pci/yijing-ari:
      PCI: shpchp: Iterate over all devices in slot, not functions 0-7
      PCI: sgihp: Iterate over all devices in slot, not functions 0-7
      PCI: cpcihp: Iterate over all devices in slot, not functions 0-7
      PCI: pciehp: Iterate over all devices in slot, not functions 0-7
      PCI: Consolidate "next-function" functions
      PCI: Rename pci_enable_ari() to pci_configure_ari()
      PCI: Enable ARI if dev and upstream bridge support it; disable otherwise

commit 4f535093cf8f6da8cfda7c36c2c1ecd2e9586ee4
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Mon Jan 21 13:20:52 2013 -0800

    PCI: Put pci_dev in device tree as early as possible
    
    We want to put pci_dev structs in the device tree as soon as possible so
    for_each_pci_dev() iteration will not miss them, but driver attachment
    needs to be delayed until after pci_assign_unassigned_resources() to make
    sure all devices have resources assigned first.
    
    This patch moves device registering from pci_bus_add_devices() to
    pci_device_add(), which happens earlier, leaving driver attachment in
    pci_bus_add_devices().
    
    It also removes unattached child bus handling in pci_bus_add_devices().
    That's not needed because child bus via pci_add_new_bus() is already
    in parent bus children list.
    
    [bhelgaas: changelog]
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 48b35e15374d..281d90f19c7a 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -623,6 +623,7 @@ static struct pci_bus *pci_alloc_child_bus(struct pci_bus *parent,
 {
 	struct pci_bus *child;
 	int i;
+	int ret;
 
 	/*
 	 * Allocate a new bus, and inherit stuff from the parent..
@@ -637,8 +638,7 @@ static struct pci_bus *pci_alloc_child_bus(struct pci_bus *parent,
 	child->bus_flags = parent->bus_flags;
 
 	/* initialize some portions of the bus device, but don't register it
-	 * now as the parent is not properly set up yet.  This device will get
-	 * registered later in pci_bus_add_devices()
+	 * now as the parent is not properly set up yet.
 	 */
 	child->dev.class = &pcibus_class;
 	dev_set_name(&child->dev, "%04x:%02x", pci_domain_nr(child), busnr);
@@ -651,11 +651,14 @@ static struct pci_bus *pci_alloc_child_bus(struct pci_bus *parent,
 	child->primary = parent->busn_res.start;
 	child->busn_res.end = 0xff;
 
-	if (!bridge)
-		return child;
+	if (!bridge) {
+		child->dev.parent = parent->bridge;
+		goto add_dev;
+	}
 
 	child->self = bridge;
 	child->bridge = get_device(&bridge->dev);
+	child->dev.parent = child->bridge;
 	pci_set_bus_of_node(child);
 	pci_set_bus_speed(child);
 
@@ -666,6 +669,13 @@ static struct pci_bus *pci_alloc_child_bus(struct pci_bus *parent,
 	}
 	bridge->subordinate = child;
 
+add_dev:
+	ret = device_register(&child->dev);
+	WARN_ON(ret < 0);
+
+	/* Create legacy_io and legacy_mem files for this bus */
+	pci_create_legacy_files(child);
+
 	return child;
 }
 
@@ -1296,6 +1306,8 @@ static void pci_init_capabilities(struct pci_dev *dev)
 
 void pci_device_add(struct pci_dev *dev, struct pci_bus *bus)
 {
+	int ret;
+
 	device_initialize(&dev->dev);
 	dev->dev.release = pci_release_dev;
 
@@ -1326,6 +1338,17 @@ void pci_device_add(struct pci_dev *dev, struct pci_bus *bus)
 	down_write(&pci_bus_sem);
 	list_add_tail(&dev->bus_list, &bus->devices);
 	up_write(&pci_bus_sem);
+
+	pci_fixup_device(pci_fixup_final, dev);
+	ret = pcibios_add_device(dev);
+	WARN_ON(ret < 0);
+
+	/* Notifier could use PCI capabilities */
+	dev->match_driver = false;
+	ret = device_add(&dev->dev);
+	WARN_ON(ret < 0);
+
+	pci_proc_attach_device(dev);
 }
 
 struct pci_dev *__ref pci_scan_single_device(struct pci_bus *bus, int devfn)
@@ -1644,13 +1667,13 @@ struct pci_bus *pci_create_root_bus(struct device *parent, int bus,
 	char bus_addr[64];
 	char *fmt;
 
-
 	b = pci_alloc_bus();
 	if (!b)
 		return NULL;
 
 	b->sysdata = sysdata;
 	b->ops = ops;
+	b->number = b->busn_res.start = bus;
 	b2 = pci_find_bus(pci_domain_nr(b), bus);
 	if (b2) {
 		/* If we already got to this bus through a different bridge, ignore it */
@@ -1685,8 +1708,6 @@ struct pci_bus *pci_create_root_bus(struct device *parent, int bus,
 	/* Create legacy_io and legacy_mem files for this bus */
 	pci_create_legacy_files(b);
 
-	b->number = b->busn_res.start = bus;
-
 	if (parent)
 		dev_info(parent, "PCI host bridge to bus %s\n", dev_name(&b->dev));
 	else

commit e723f0b4f4ecaf3fdd542124b3f99379ab8df757
Author: Jiang Liu <jiang.liu@huawei.com>
Date:   Mon Jan 21 13:20:46 2013 -0800

    PCI: Make device create/destroy logic symmetric
    
    According to device model documentation, the way to create/destroy PCI
    devices should be symmetric.  The rule is to either use
      1) device_register()/device_unregister()
    or
      2) device_initialize()/device_add()/device_del()/put_device().
    
    So change PCI core logic to follow the rule and get rid of the redundant
    pci_dev_get()/pci_dev_put() pair.
    
    Signed-off-by: Jiang Liu <jiang.liu@huawei.com>
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index b97dea5784ff..48b35e15374d 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1298,7 +1298,6 @@ void pci_device_add(struct pci_dev *dev, struct pci_bus *bus)
 {
 	device_initialize(&dev->dev);
 	dev->dev.release = pci_release_dev;
-	pci_dev_get(dev);
 
 	set_dev_node(&dev->dev, pcibus_to_node(bus));
 	dev->dev.dma_mask = &dev->dma_mask;

commit 7629d19a4df922e7497e170c1c7b508b5e27f486
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Mon Jan 21 13:20:44 2013 -0800

    PCI: Set pci_dev dev_node early so IOAPIC irq_descs are allocated locally
    
    Otherwise irq_desc for PCI bridge with hot-added IOAPIC may not be
    allocated on the local node.
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 2dcd22d9c816..b97dea5784ff 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1300,6 +1300,7 @@ void pci_device_add(struct pci_dev *dev, struct pci_bus *bus)
 	dev->dev.release = pci_release_dev;
 	pci_dev_get(dev);
 
+	set_dev_node(&dev->dev, pcibus_to_node(bus));
 	dev->dev.dma_mask = &dev->dma_mask;
 	dev->dev.dma_parms = &dev->dma_parms;
 	dev->dev.coherent_dma_mask = 0xffffffffull;

commit b1bd58e448f28531207124eea3fd43b81d6f8d06
Author: Yijing Wang <wangyijing@huawei.com>
Date:   Fri Jan 25 09:12:31 2013 -0700

    PCI: Consolidate "next-function" functions
    
    There are several next_fn functions (no_next_fn, next_trad_fn,
    next_ari_fn); consolidate them in next_fn() to simplify the code.
    
    [bhelgaas: make next_fn() static, rework control flow]
    Signed-off-by: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Jiang Liu <jiang.liu@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 7b9e691b95b1..2a9958c1556e 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1349,31 +1349,31 @@ struct pci_dev *__ref pci_scan_single_device(struct pci_bus *bus, int devfn)
 }
 EXPORT_SYMBOL(pci_scan_single_device);
 
-static unsigned next_ari_fn(struct pci_dev *dev, unsigned fn)
+static unsigned next_fn(struct pci_bus *bus, struct pci_dev *dev, unsigned fn)
 {
-	u16 cap;
-	unsigned pos, next_fn;
+	int pos;
+	u16 cap = 0;
+	unsigned next_fn;
 
-	if (!dev)
-		return 0;
+	if (pci_ari_enabled(bus)) {
+		if (!dev)
+			return 0;
+		pos = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ARI);
+		if (!pos)
+			return 0;
 
-	pos = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ARI);
-	if (!pos)
-		return 0;
-	pci_read_config_word(dev, pos + 4, &cap);
-	next_fn = cap >> 8;
-	if (next_fn <= fn)
-		return 0;
-	return next_fn;
-}
+		pci_read_config_word(dev, pos + PCI_ARI_CAP, &cap);
+		next_fn = PCI_ARI_CAP_NFN(cap);
+		if (next_fn <= fn)
+			return 0;	/* protect against malformed list */
 
-static unsigned next_trad_fn(struct pci_dev *dev, unsigned fn)
-{
-	return (fn + 1) % 8;
-}
+		return next_fn;
+	}
+
+	/* dev may be NULL for non-contiguous multifunction devices */
+	if (!dev || dev->multifunction)
+		return (fn + 1) % 8;
 
-static unsigned no_next_fn(struct pci_dev *dev, unsigned fn)
-{
 	return 0;
 }
 
@@ -1406,7 +1406,6 @@ int pci_scan_slot(struct pci_bus *bus, int devfn)
 {
 	unsigned fn, nr = 0;
 	struct pci_dev *dev;
-	unsigned (*next_fn)(struct pci_dev *, unsigned) = no_next_fn;
 
 	if (only_one_child(bus) && (devfn > 0))
 		return 0; /* Already scanned the entire slot */
@@ -1417,12 +1416,7 @@ int pci_scan_slot(struct pci_bus *bus, int devfn)
 	if (!dev->is_added)
 		nr++;
 
-	if (pci_ari_enabled(bus))
-		next_fn = next_ari_fn;
-	else if (dev->multifunction)
-		next_fn = next_trad_fn;
-
-	for (fn = next_fn(dev, 0); fn > 0; fn = next_fn(dev, fn)) {
+	for (fn = next_fn(bus, dev, 0); fn > 0; fn = next_fn(bus, dev, fn)) {
 		dev = pci_scan_single_device(bus, devfn + fn);
 		if (dev) {
 			if (!dev->is_added)

commit 31ab247623c541d56b39a0b792cdfe4e94dd2a45
Author: Yijing Wang <wangyijing@huawei.com>
Date:   Tue Jan 15 11:12:17 2013 +0800

    PCI: Rename pci_enable_ari() to pci_configure_ari()
    
    pci_enable_ari() now supports enabling or disabling ARI forwarding.  So
    rename pci_enable_ari() to pci_configure_ari() for easy understanding.
    
    No functional change.
    
    [bhelgaas: changelog]
    Signed-off-by: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 6186f03d84f3..7b9e691b95b1 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1286,7 +1286,7 @@ static void pci_init_capabilities(struct pci_dev *dev)
 	pci_vpd_pci22_init(dev);
 
 	/* Alternative Routing-ID Forwarding */
-	pci_enable_ari(dev);
+	pci_configure_ari(dev);
 
 	/* Single Root I/O Virtualization */
 	pci_iov_init(dev);

commit 6c0cc950ae670403a362bdcbf3cde0df33744928
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Jan 9 22:33:37 2013 +0100

    ACPI / PCI: Set root bridge ACPI handle in advance
    
    The ACPI handles of PCI root bridges need to be known to
    acpi_bind_one(), so that it can create the appropriate
    "firmware_node" and "physical_node" files for them, but currently
    the way it gets to know those handles is not exactly straightforward
    (to put it lightly).
    
    This is how it works, roughly:
    
      1. acpi_bus_scan() finds the handle of a PCI root bridge,
         creates a struct acpi_device object for it and passes that
         object to acpi_pci_root_add().
    
      2. acpi_pci_root_add() creates a struct acpi_pci_root object,
         populates its "device" field with its argument's address
         (device->handle is the ACPI handle found in step 1).
    
      3. The struct acpi_pci_root object created in step 2 is passed
         to pci_acpi_scan_root() and used to get resources that are
         passed to pci_create_root_bus().
    
      4. pci_create_root_bus() creates a struct pci_host_bridge object
         and passes its "dev" member to device_register().
    
      5. platform_notify(), which for systems with ACPI is set to
         acpi_platform_notify(), is called.
    
    So far, so good.  Now it starts to be "interesting".
    
      6. acpi_find_bridge_device() is used to find the ACPI handle of
         the given device (which is the PCI root bridge) and executes
         acpi_pci_find_root_bridge(), among other things, for the
         given device object.
    
      7. acpi_pci_find_root_bridge() uses the name (sic!) of the given
         device object to extract the segment and bus numbers of the PCI
         root bridge and passes them to acpi_get_pci_rootbridge_handle().
    
      8. acpi_get_pci_rootbridge_handle() browses the list of ACPI PCI
         root bridges and finds the one that matches the given segment
         and bus numbers.  Its handle is then used to initialize the
         ACPI handle of the PCI root bridge's device object by
         acpi_bind_one().  However, this is *exactly* the ACPI handle we
         started with in step 1.
    
    Needless to say, this is quite embarassing, but it may be avoided
    thanks to commit f3fd0c8 (ACPI: Allow ACPI handles of devices to be
    initialized in advance), which makes it possible to initialize the
    ACPI handle of a device before passing it to device_register().
    
    Accordingly, add a new __weak routine, pcibios_root_bridge_prepare(),
    defaulting to an empty implementation that can be replaced by the
    interested architecutres (x86 and ia64 at the moment) with functions
    that will set the root bridge's ACPI handle before its dev member is
    passed to device_register().  Make both x86 and ia64 provide such
    implementations of pcibios_root_bridge_prepare() and remove
    acpi_pci_find_root_bridge() and acpi_get_pci_rootbridge_handle() that
    aren't necessary any more.
    
    Included is a fix for breakage on systems with non-ACPI PCI host
    bridges from Bjorn Helgaas.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 2dcd22d9c816..bbe4be7fc685 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1632,6 +1632,18 @@ unsigned int pci_scan_child_bus(struct pci_bus *bus)
 	return max;
 }
 
+/**
+ * pcibios_root_bridge_prepare - Platform-specific host bridge setup.
+ * @bridge: Host bridge to set up.
+ *
+ * Default empty implementation.  Replace with an architecture-specific setup
+ * routine, if necessary.
+ */
+int __weak pcibios_root_bridge_prepare(struct pci_host_bridge *bridge)
+{
+	return 0;
+}
+
 struct pci_bus *pci_create_root_bus(struct device *parent, int bus,
 		struct pci_ops *ops, void *sysdata, struct list_head *resources)
 {
@@ -1665,6 +1677,10 @@ struct pci_bus *pci_create_root_bus(struct device *parent, int bus,
 	bridge->dev.parent = parent;
 	bridge->dev.release = pci_release_bus_bridge_dev;
 	dev_set_name(&bridge->dev, "pci%04x:%02x", pci_domain_nr(b), bus);
+	error = pcibios_root_bridge_prepare(bridge);
+	if (error)
+		goto bridge_dev_reg_err;
+
 	error = device_register(&bridge->dev);
 	if (error)
 		goto bridge_dev_reg_err;

commit d2e5f0c16ad60a7208fd371233e63b73c990ece2
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Dec 23 00:02:44 2012 +0100

    ACPI / PCI: Rework the setup and cleanup of device wakeup
    
    Currently, the ACPI wakeup capability of PCI devices is set up
    in two different places, partially in acpi_pci_bind() where
    runtime wakeup is initialized and partially in
    platform_pci_wakeup_init(), where system wakeup is initialized.
    The cleanup is only done in acpi_pci_unbind() and it only covers
    runtime wakeup.
    
    Use the new .setup() and .cleanup() callbacks in struct acpi_bus_type
    to consolidate that code and do the setup and the cleanup each in one
    place.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>
    Acked-by: Toshi Kani <toshi.kani@hp.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 6186f03d84f3..2dcd22d9c816 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1280,7 +1280,6 @@ static void pci_init_capabilities(struct pci_dev *dev)
 
 	/* Power Management */
 	pci_pm_init(dev);
-	platform_pci_wakeup_init(dev);
 
 	/* Vital Product Data */
 	pci_vpd_pci22_init(dev);

commit 193c0d682525987db59ac3a24531a77e4947aa95
Merge: 8b0cab14951f 1cb73f8c479e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Dec 13 12:14:47 2012 -0800

    Merge tag 'for-3.8' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI update from Bjorn Helgaas:
     "Host bridge hotplug:
       - Untangle _PRT from struct pci_bus (Bjorn Helgaas)
       - Request _OSC control before scanning root bus (Taku Izumi)
       - Assign resources when adding host bridge (Yinghai Lu)
       - Remove root bus when removing host bridge (Yinghai Lu)
       - Remove _PRT during hot remove (Yinghai Lu)
    
      SRIOV
        - Add sysfs knobs to control numVFs (Don Dutile)
    
      Power management
       - Notify devices when power resource turned on (Huang Ying)
    
      Bug fixes
       - Work around broken _SEG on HP xw9300 (Bjorn Helgaas)
       - Keep runtime PM enabled for unbound PCI devices (Huang Ying)
       - Fix Optimus dual-GPU runtime D3 suspend issue (Dave Airlie)
       - Fix xen frontend shutdown issue (David Vrabel)
       - Work around PLX PCI 9050 BAR alignment erratum (Ian Abbott)
    
      Miscellaneous
       - Add GPL license for drivers/pci/ioapic (Andrew Cooks)
       - Add standard PCI-X, PCIe ASPM register #defines (Bjorn Helgaas)
       - NumaChip remote PCI support (Daniel Blueman)
       - Fix PCIe Link Capabilities Supported Link Speed definition (Jingoo
         Han)
       - Convert dev_printk() to dev_info(), etc (Joe Perches)
       - Add support for non PCI BAR ROM data (Matthew Garrett)
       - Add x86 support for host bridge translation offset (Mike Yoknis)
       - Report success only when every driver supports AER (Vijay
         Pandarathil)"
    
    Fix up trivial conflicts.
    
    * tag 'for-3.8' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (48 commits)
      PCI: Use phys_addr_t for physical ROM address
      x86/PCI: Add NumaChip remote PCI support
      ath9k: Use standard #defines for PCIe Capability ASPM fields
      iwlwifi: Use standard #defines for PCIe Capability ASPM fields
      iwlwifi: collapse wrapper for pcie_capability_read_word()
      iwlegacy: Use standard #defines for PCIe Capability ASPM fields
      iwlegacy: collapse wrapper for pcie_capability_read_word()
      cxgb3: Use standard #defines for PCIe Capability ASPM fields
      PCI: Add standard PCIe Capability Link ASPM field names
      PCI/portdrv: Use PCI Express Capability accessors
      PCI: Use standard PCIe Capability Link register field names
      x86: Use PCI setup data
      PCI: Add support for non-BAR ROMs
      PCI: Add pcibios_add_device
      EFI: Stash ROMs if they're not in the PCI BAR
      PCI: Add and use standard PCI-X Capability register names
      PCI/PM: Keep runtime PM enabled for unbound PCI devices
      xen-pcifront: Handle backend CLOSED without CLOSING
      PCI: SRIOV control and status via sysfs (documentation)
      PCI/AER: Report success only when every device has AER-aware driver
      ...

commit 27e1c8ee0170e80f6426c35d54f3b5cd9dadb25b
Merge: 72e1e868ca8f a875621ec153
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Dec 7 12:11:52 2012 -0700

    Merge branch 'pci/bjorn-pcie-cap' into next
    
    * pci/bjorn-pcie-cap:
      ath9k: Use standard #defines for PCIe Capability ASPM fields
      iwlwifi: Use standard #defines for PCIe Capability ASPM fields
      iwlwifi: collapse wrapper for pcie_capability_read_word()
      iwlegacy: Use standard #defines for PCIe Capability ASPM fields
      iwlegacy: collapse wrapper for pcie_capability_read_word()
      cxgb3: Use standard #defines for PCIe Capability ASPM fields
      PCI: Add standard PCIe Capability Link ASPM field names
      PCI/portdrv: Use PCI Express Capability accessors
      PCI: Use standard PCIe Capability Link register field names
      PCI: Add and use standard PCI-X Capability register names

commit 231afea189c6363f2921042576da74e1fb0f2fc3
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Dec 5 13:51:18 2012 -0700

    PCI: Use standard PCIe Capability Link register field names
    
    Use the standard #defines for PCIe Link Status and Capability registers
    rather than bare numbers.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 81d06676ce34..7ec6973378fe 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -521,7 +521,7 @@ static unsigned char pcie_link_speed[] = {
 
 void pcie_update_link_speed(struct pci_bus *bus, u16 linksta)
 {
-	bus->cur_bus_speed = pcie_link_speed[linksta & 0xf];
+	bus->cur_bus_speed = pcie_link_speed[linksta & PCI_EXP_LNKSTA_CLS];
 }
 EXPORT_SYMBOL_GPL(pcie_update_link_speed);
 
@@ -610,7 +610,7 @@ static void pci_set_bus_speed(struct pci_bus *bus)
 		u16 linksta;
 
 		pcie_capability_read_dword(bridge, PCI_EXP_LNKCAP, &linkcap);
-		bus->max_bus_speed = pcie_link_speed[linkcap & 0xf];
+		bus->max_bus_speed = pcie_link_speed[linkcap & PCI_EXP_LNKCAP_SLS];
 
 		pcie_capability_read_word(bridge, PCI_EXP_LNKSTA, &linksta);
 		pcie_update_link_speed(bus, linksta);

commit 7793eeabc89fd342b96fdadce5a50c46ab77f3f9
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Dec 5 13:51:17 2012 -0700

    PCI: Add and use standard PCI-X Capability register names
    
    Add and use #defines for PCI-X Capability registers and fields.
    Note that the PCI-X Capability has a different layout for
    type 0 (endpoint) and type 1 (bridge) devices.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index ec909afa90b6..81d06676ce34 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -579,14 +579,16 @@ static void pci_set_bus_speed(struct pci_bus *bus)
 	if (pos) {
 		u16 status;
 		enum pci_bus_speed max;
-		pci_read_config_word(bridge, pos + 2, &status);
 
-		if (status & 0x8000) {
+		pci_read_config_word(bridge, pos + PCI_X_BRIDGE_SSTATUS,
+				     &status);
+
+		if (status & PCI_X_SSTATUS_533MHZ) {
 			max = PCI_SPEED_133MHz_PCIX_533;
-		} else if (status & 0x4000) {
+		} else if (status & PCI_X_SSTATUS_266MHZ) {
 			max = PCI_SPEED_133MHz_PCIX_266;
-		} else if (status & 0x0002) {
-			if (((status >> 12) & 0x3) == 2) {
+		} else if (status & PCI_X_SSTATUS_133MHZ) {
+			if ((status & PCI_X_SSTATUS_VERS) == PCI_X_SSTATUS_V2) {
 				max = PCI_SPEED_133MHz_PCIX_ECC;
 			} else {
 				max = PCI_SPEED_133MHz_PCIX;
@@ -596,7 +598,8 @@ static void pci_set_bus_speed(struct pci_bus *bus)
 		}
 
 		bus->max_bus_speed = max;
-		bus->cur_bus_speed = pcix_bus_speed[(status >> 6) & 0xf];
+		bus->cur_bus_speed = pcix_bus_speed[
+			(status & PCI_X_SSTATUS_FREQ) >> 6];
 
 		return;
 	}

commit 15856ad50bf5ea02a5ee22399c036d49e7e1124d
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Wed Nov 21 15:35:00 2012 -0500

    PCI: Remove __dev* markings
    
    CONFIG_HOTPLUG is going away as an option so __devexit_p, __devint,
    __devinitdata, __devinitconst, and _devexit are no longer needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 034cb1c73092..3683f6094e3f 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -305,7 +305,7 @@ static void pci_read_bases(struct pci_dev *dev, unsigned int howmany, int rom)
 	}
 }
 
-static void __devinit pci_read_bridge_io(struct pci_bus *child)
+static void pci_read_bridge_io(struct pci_bus *child)
 {
 	struct pci_dev *dev = child->self;
 	u8 io_base_lo, io_limit_lo;
@@ -345,7 +345,7 @@ static void __devinit pci_read_bridge_io(struct pci_bus *child)
 	}
 }
 
-static void __devinit pci_read_bridge_mmio(struct pci_bus *child)
+static void pci_read_bridge_mmio(struct pci_bus *child)
 {
 	struct pci_dev *dev = child->self;
 	u16 mem_base_lo, mem_limit_lo;
@@ -367,7 +367,7 @@ static void __devinit pci_read_bridge_mmio(struct pci_bus *child)
 	}
 }
 
-static void __devinit pci_read_bridge_mmio_pref(struct pci_bus *child)
+static void pci_read_bridge_mmio_pref(struct pci_bus *child)
 {
 	struct pci_dev *dev = child->self;
 	u16 mem_base_lo, mem_limit_lo;
@@ -417,7 +417,7 @@ static void __devinit pci_read_bridge_mmio_pref(struct pci_bus *child)
 	}
 }
 
-void __devinit pci_read_bridge_bases(struct pci_bus *child)
+void pci_read_bridge_bases(struct pci_bus *child)
 {
 	struct pci_dev *dev = child->self;
 	struct resource *res;
@@ -705,7 +705,7 @@ static void pci_fixup_parent_subordinate_busnr(struct pci_bus *child, int max)
  * them, we proceed to assigning numbers to the remaining buses in
  * order to avoid overlaps between old and new bus numbers.
  */
-int __devinit pci_scan_bridge(struct pci_bus *bus, struct pci_dev *dev, int max, int pass)
+int pci_scan_bridge(struct pci_bus *bus, struct pci_dev *dev, int max, int pass)
 {
 	struct pci_bus *child;
 	int is_cardbus = (dev->hdr_type == PCI_HEADER_TYPE_CARDBUS);
@@ -1586,7 +1586,7 @@ void pcie_bus_configure_settings(struct pci_bus *bus, u8 mpss)
 }
 EXPORT_SYMBOL_GPL(pcie_bus_configure_settings);
 
-unsigned int __devinit pci_scan_child_bus(struct pci_bus *bus)
+unsigned int pci_scan_child_bus(struct pci_bus *bus)
 {
 	unsigned int devfn, pass, max = bus->busn_res.start;
 	struct pci_dev *dev;
@@ -1790,7 +1790,7 @@ void pci_bus_release_busn_res(struct pci_bus *b)
 			res, ret ? "can not be" : "is");
 }
 
-struct pci_bus * __devinit pci_scan_root_bus(struct device *parent, int bus,
+struct pci_bus *pci_scan_root_bus(struct device *parent, int bus,
 		struct pci_ops *ops, void *sysdata, struct list_head *resources)
 {
 	struct pci_host_bridge_window *window;
@@ -1826,7 +1826,7 @@ struct pci_bus * __devinit pci_scan_root_bus(struct device *parent, int bus,
 EXPORT_SYMBOL(pci_scan_root_bus);
 
 /* Deprecated; use pci_scan_root_bus() instead */
-struct pci_bus * __devinit pci_scan_bus_parented(struct device *parent,
+struct pci_bus *pci_scan_bus_parented(struct device *parent,
 		int bus, struct pci_ops *ops, void *sysdata)
 {
 	LIST_HEAD(resources);
@@ -1844,7 +1844,7 @@ struct pci_bus * __devinit pci_scan_bus_parented(struct device *parent,
 }
 EXPORT_SYMBOL(pci_scan_bus_parented);
 
-struct pci_bus * __devinit pci_scan_bus(int bus, struct pci_ops *ops,
+struct pci_bus *pci_scan_bus(int bus, struct pci_ops *ops,
 					void *sysdata)
 {
 	LIST_HEAD(resources);

commit b40b97ae736cad3084b13d2969b10c474572de89
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Wed Nov 21 15:34:57 2012 -0500

    PCI: Remove CONFIG_HOTPLUG ifdefs
    
    Remove conditional code based on CONFIG_HOTPLUG being false.  It's
    always on now in preparation of it going away as an option.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index ec909afa90b6..034cb1c73092 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1864,7 +1864,6 @@ struct pci_bus * __devinit pci_scan_bus(int bus, struct pci_ops *ops,
 }
 EXPORT_SYMBOL(pci_scan_bus);
 
-#ifdef CONFIG_HOTPLUG
 /**
  * pci_rescan_bus_bridge_resize - scan a PCI bus for devices.
  * @bridge: PCI bridge for the bus to scan
@@ -1894,7 +1893,6 @@ EXPORT_SYMBOL(pci_add_new_bus);
 EXPORT_SYMBOL(pci_scan_slot);
 EXPORT_SYMBOL(pci_scan_bridge);
 EXPORT_SYMBOL_GPL(pci_scan_child_bus);
-#endif
 
 static int __init pci_sort_bf_cmp(const struct device *d_a, const struct device *d_b)
 {

commit f9c15b429a5c82e613d59a32d4f49cea6e9d64eb
Merge: 0dcccc5c53c5 1452cd76a97b
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Nov 13 14:33:32 2012 -0700

    Merge branch 'pci/don-sriov' into next
    
    * pci/don-sriov:
      PCI: Remove useless "!dev" tests
      PCI: Use spec names for SR-IOV capability fields
      PCI: Provide method to reduce the number of total VFs supported
      PCI: SRIOV control and status via sysfs
      PCI: Use is_visible() with boot_vga attribute for pci_dev
      PCI: Add pci_device_type to pdev's device struct

commit 4e15c46bdc4d5ea0e7991a05edbd807328d38a2c
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Mon Nov 5 15:20:34 2012 -0500

    PCI: Add pci_device_type to pdev's device struct
    
    Need type filled in device structure so it can be used for visible
    attribute control in sysfs for pci_dev.
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index ec909afa90b6..0312f1c48b3c 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -975,6 +975,7 @@ int pci_setup_device(struct pci_dev *dev)
 	dev->sysdata = dev->bus->sysdata;
 	dev->dev.parent = dev->bus->bridge;
 	dev->dev.bus = &pci_bus_type;
+	dev->dev.type = &pci_dev_type;
 	dev->hdr_type = hdr_type & 0x7f;
 	dev->multifunction = !!(hdr_type & 0x80);
 	dev->error_state = pci_channel_io_normal;

commit e164f658f209b85566732bd85c62009237be0909
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Tue Oct 30 14:31:26 2012 -0600

    PCI: Move out pci_enable_bridges out of assign_unsigned_bus_res
    
    So could use assign_unassigned_bus_res pci root bus add
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 65f62e353719..59cf1ba34936 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1905,6 +1905,7 @@ unsigned int __ref pci_rescan_bus(struct pci_bus *bus)
 
 	max = pci_scan_child_bus(bus);
 	pci_assign_unassigned_bus_resources(bus);
+	pci_enable_bridges(bus);
 	pci_bus_add_devices(bus);
 
 	return max;

commit a5213a3194f73cd29c68128d1540ce81f03ba7b9
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Tue Oct 30 14:31:21 2012 -0600

    PCI: Move pci_rescan_bus() back to probe.c
    
    We have pci_assign_unassigned_bus_resources() in as global function now.
    
    Move pci_rescan_bus() back to probe.c where it should be.
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index ec909afa90b6..65f62e353719 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1890,6 +1890,27 @@ unsigned int __ref pci_rescan_bus_bridge_resize(struct pci_dev *bridge)
 	return max;
 }
 
+/**
+ * pci_rescan_bus - scan a PCI bus for devices.
+ * @bus: PCI bus to scan
+ *
+ * Scan a PCI bus and child buses for new devices, adds them,
+ * and enables them.
+ *
+ * Returns the max number of subordinate bus discovered.
+ */
+unsigned int __ref pci_rescan_bus(struct pci_bus *bus)
+{
+	unsigned int max;
+
+	max = pci_scan_child_bus(bus);
+	pci_assign_unassigned_bus_resources(bus);
+	pci_bus_add_devices(bus);
+
+	return max;
+}
+EXPORT_SYMBOL_GPL(pci_rescan_bus);
+
 EXPORT_SYMBOL(pci_add_new_bus);
 EXPORT_SYMBOL(pci_scan_slot);
 EXPORT_SYMBOL(pci_scan_bridge);

commit 78c8f84302ce007aedcfa11912fd4aacf22727ab
Merge: d3ce52f50cc1 84544a1dea61
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Sep 24 17:24:11 2012 -0600

    Merge branch 'pci/yinghai-misc' into next

commit 1965f66e7db08d1ebccd24a59043eba826cc1ce8
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Mon Sep 10 17:19:33 2012 -0700

    PCI: Check P2P bridge for invalid secondary/subordinate range
    
    For bridges with "secondary > subordinate", i.e., invalid bus number
    apertures, we don't enumerate anything behind the bridge unless the
    user specified "pci=assign-busses".
    
    This patch makes us automatically try to reassign the downstream bus
    numbers in this case (just for that bridge, not for all bridges as
    "pci=assign-busses" does).
    
    We don't discover all the devices on the Intel DP43BF motherboard
    without this change (or "pci=assign-busses") because its BIOS configures
    a bridge as:
    
        pci 0000:00:1e.0: PCI bridge to [bus 20-08] (subtractive decode)
    
    [bhelgaas: changelog, change message to dev_info]
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=18412
    Bugzilla: https://bugzilla.redhat.com/show_bug.cgi?id=625754
    Reported-by: Brian C. Huffman <bhuffman@graze.net>
    Reported-by: VL <vl.homutov@gmail.com>
    Tested-by: VL <vl.homutov@gmail.com>
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 9f8a6b79a8ec..61859d04cfea 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -729,8 +729,10 @@ int __devinit pci_scan_bridge(struct pci_bus *bus, struct pci_dev *dev, int max,
 
 	/* Check if setup is sensible at all */
 	if (!pass &&
-	    (primary != bus->number || secondary <= bus->number)) {
-		dev_dbg(&dev->dev, "bus configuration invalid, reconfiguring\n");
+	    (primary != bus->number || secondary <= bus->number ||
+	     secondary > subordinate)) {
+		dev_info(&dev->dev, "bridge configuration invalid ([bus %02x-%02x]), reconfiguring\n",
+			 secondary, subordinate);
 		broken = 1;
 	}
 

commit 6dabee73d46bfafb8c588b21b14606914de97ee6
Merge: 78890b5989d9 769ae543dc8d
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Sep 13 09:08:02 2012 -0600

    Merge branch 'pci/trivial' into next
    
    * pci/trivial:
      PCI: Drop duplicate const in DECLARE_PCI_FIXUP_SECTION
      PCI: Drop bogus default from ARCH_SUPPORTS_MSI
      PCI: cpqphp: Remove unreachable path
      PCI: Remove bus number resource debug messages
      PCI/AER: Print completion message at KERN_INFO to match starting message
      PCI: Fix drivers/pci/pci.c kernel-doc warnings

commit 78890b5989d96ddce989cde929c45ceeded0fcaf
Merge: 1959ec5f82ac 55d512e245bc
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Sep 13 08:41:01 2012 -0600

    Merge commit 'v3.6-rc5' into next
    
    * commit 'v3.6-rc5': (1098 commits)
      Linux 3.6-rc5
      HID: tpkbd: work even if the new Lenovo Keyboard driver is not configured
      Remove user-triggerable BUG from mpol_to_str
      xen/pciback: Fix proper FLR steps.
      uml: fix compile error in deliver_alarm()
      dj: memory scribble in logi_dj
      Fix order of arguments to compat_put_time[spec|val]
      xen: Use correct masking in xen_swiotlb_alloc_coherent.
      xen: fix logical error in tlb flushing
      xen/p2m: Fix one-off error in checking the P2M tree directory.
      powerpc: Don't use __put_user() in patch_instruction
      powerpc: Make sure IPI handlers see data written by IPI senders
      powerpc: Restore correct DSCR in context switch
      powerpc: Fix DSCR inheritance in copy_thread()
      powerpc: Keep thread.dscr and thread.dscr_inherit in sync
      powerpc: Update DSCR on all CPUs when writing sysfs dscr_default
      powerpc/powernv: Always go into nap mode when CPU is offline
      powerpc: Give hypervisor decrementer interrupts their own handler
      powerpc/vphn: Fix arch_update_cpu_topology() return value
      ARM: gemini: fix the gemini build
      ...
    
    Conflicts:
            drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c
            drivers/rapidio/devices/tsi721.c

commit f8ba65e8fbbc364b2a49d8713126fb345fe7ec65
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Aug 24 15:05:06 2012 -0600

    PCI: Remove bus number resource debug messages
    
    These messages don't seem to add much value.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 6c143b4497ca..e2dd4b7c6001 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1753,11 +1753,6 @@ int pci_bus_insert_busn_res(struct pci_bus *b, int bus, int bus_max)
 			   "busn_res: can not insert %pR under %s%pR (conflicts with %s %pR)\n",
 			    res, pci_is_root_bus(b) ? "domain " : "",
 			    parent_res, conflict->name, conflict);
-	else
-		dev_printk(KERN_DEBUG, &b->dev,
-			   "busn_res: %pR is inserted under %s%pR\n",
-			   res, pci_is_root_bus(b) ? "domain " : "",
-			   parent_res);
 
 	return conflict == NULL;
 }

commit 0ff9514b579b4f2f3e6038cd961ce64c224c3c73
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Aug 23 10:53:08 2012 -0600

    PCI: Don't print anything while decoding is disabled
    
    If we try to print to the console device while its decoding is disabled,
    the system will hang.
    
    Reported-and-tested-by: Olof Johansson <olof@lixom.net>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Olof Johansson <olof@lixom.net>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 6c143b4497ca..9f8a6b79a8ec 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -144,15 +144,13 @@ static inline unsigned long decode_bar(struct pci_dev *dev, u32 bar)
 	case PCI_BASE_ADDRESS_MEM_TYPE_32:
 		break;
 	case PCI_BASE_ADDRESS_MEM_TYPE_1M:
-		dev_info(&dev->dev, "1M mem BAR treated as 32-bit BAR\n");
+		/* 1M mem BAR treated as 32-bit BAR */
 		break;
 	case PCI_BASE_ADDRESS_MEM_TYPE_64:
 		flags |= IORESOURCE_MEM_64;
 		break;
 	default:
-		dev_warn(&dev->dev,
-			 "mem unknown type %x treated as 32-bit BAR\n",
-			 mem_type);
+		/* mem unknown type treated as 32-bit BAR */
 		break;
 	}
 	return flags;
@@ -173,9 +171,11 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 	u32 l, sz, mask;
 	u16 orig_cmd;
 	struct pci_bus_region region;
+	bool bar_too_big = false, bar_disabled = false;
 
 	mask = type ? PCI_ROM_ADDRESS_MASK : ~0;
 
+	/* No printks while decoding is disabled! */
 	if (!dev->mmio_always_on) {
 		pci_read_config_word(dev, PCI_COMMAND, &orig_cmd);
 		pci_write_config_word(dev, PCI_COMMAND,
@@ -240,8 +240,7 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 			goto fail;
 
 		if ((sizeof(resource_size_t) < 8) && (sz64 > 0x100000000ULL)) {
-			dev_err(&dev->dev, "reg %x: can't handle 64-bit BAR\n",
-				pos);
+			bar_too_big = true;
 			goto fail;
 		}
 
@@ -252,12 +251,11 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 			region.start = 0;
 			region.end = sz64;
 			pcibios_bus_to_resource(dev, res, &region);
+			bar_disabled = true;
 		} else {
 			region.start = l64;
 			region.end = l64 + sz64;
 			pcibios_bus_to_resource(dev, res, &region);
-			dev_printk(KERN_DEBUG, &dev->dev, "reg %x: %pR\n",
-				   pos, res);
 		}
 	} else {
 		sz = pci_size(l, sz, mask);
@@ -268,18 +266,23 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 		region.start = l;
 		region.end = l + sz;
 		pcibios_bus_to_resource(dev, res, &region);
-
-		dev_printk(KERN_DEBUG, &dev->dev, "reg %x: %pR\n", pos, res);
 	}
 
- out:
+	goto out;
+
+
+fail:
+	res->flags = 0;
+out:
 	if (!dev->mmio_always_on)
 		pci_write_config_word(dev, PCI_COMMAND, orig_cmd);
 
+	if (bar_too_big)
+		dev_err(&dev->dev, "reg %x: can't handle 64-bit BAR\n", pos);
+	if (res->flags && !bar_disabled)
+		dev_printk(KERN_DEBUG, &dev->dev, "reg %x: %pR\n", pos, res);
+
 	return (res->flags & IORESOURCE_MEM_64) ? 1 : 0;
- fail:
-	res->flags = 0;
-	goto out;
 }
 
 static void pci_read_bases(struct pci_dev *dev, unsigned int howmany, int rom)

commit 59875ae489609b2267548dc85160c5f0f0c6f9d4
Author: Jiang Liu <jiang.liu@huawei.com>
Date:   Tue Jul 24 17:20:06 2012 +0800

    PCI/core: Use PCI Express Capability accessors
    
    Use PCI Express Capability access functions to simplify core.
    
    Signed-off-by: Jiang Liu <jiang.liu@huawei.com>
    Signed-off-by: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 8bcc985faa16..d8f513bdf95c 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -603,10 +603,10 @@ static void pci_set_bus_speed(struct pci_bus *bus)
 		u32 linkcap;
 		u16 linksta;
 
-		pci_read_config_dword(bridge, pos + PCI_EXP_LNKCAP, &linkcap);
+		pcie_capability_read_dword(bridge, PCI_EXP_LNKCAP, &linkcap);
 		bus->max_bus_speed = pcie_link_speed[linkcap & 0xf];
 
-		pci_read_config_word(bridge, pos + PCI_EXP_LNKSTA, &linksta);
+		pcie_capability_read_word(bridge, PCI_EXP_LNKSTA, &linksta);
 		pcie_update_link_speed(bus, linksta);
 	}
 }
@@ -936,17 +936,9 @@ void set_pcie_port_type(struct pci_dev *pdev)
 
 void set_pcie_hotplug_bridge(struct pci_dev *pdev)
 {
-	int pos;
-	u16 reg16;
 	u32 reg32;
 
-	pos = pci_pcie_cap(pdev);
-	if (!pos)
-		return;
-	pci_read_config_word(pdev, pos + PCI_EXP_FLAGS, &reg16);
-	if (!(reg16 & PCI_EXP_FLAGS_SLOT))
-		return;
-	pci_read_config_dword(pdev, pos + PCI_EXP_SLTCAP, &reg32);
+	pcie_capability_read_dword(pdev, PCI_EXP_SLTCAP, &reg32);
 	if (reg32 & PCI_EXP_SLTCAP_HPC)
 		pdev->is_hotplug_bridge = 1;
 }
@@ -1160,8 +1152,7 @@ int pci_cfg_space_size(struct pci_dev *dev)
 	if (class == PCI_CLASS_BRIDGE_HOST)
 		return pci_cfg_space_size_ext(dev);
 
-	pos = pci_pcie_cap(dev);
-	if (!pos) {
+	if (!pci_is_pcie(dev)) {
 		pos = pci_find_capability(dev, PCI_CAP_ID_PCIX);
 		if (!pos)
 			goto fail;

commit b2ef39be5744d4d3575474444345e71bd95013ba
Author: Yijing Wang <wangyijing@huawei.com>
Date:   Tue Jul 24 17:20:04 2012 +0800

    PCI: Remove unused field pcie_type from struct pci_dev
    
    With introduction of pci_pcie_type(), pci_dev->pcie_type field becomes
    redundant, so remove it.
    
    Signed-off-by: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Jiang Liu <jiang.liu@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 1d52a43eb086..8bcc985faa16 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -930,7 +930,6 @@ void set_pcie_port_type(struct pci_dev *pdev)
 	pdev->pcie_cap = pos;
 	pci_read_config_word(pdev, pos + PCI_EXP_FLAGS, &reg16);
 	pdev->pcie_flags_reg = reg16;
-	pdev->pcie_type = pci_pcie_type(pdev);
 	pci_read_config_word(pdev, pos + PCI_EXP_DEVCAP, &reg16);
 	pdev->pcie_mpss = reg16 & PCI_EXP_DEVCAP_PAYLOAD;
 }

commit 62f87c0e31d646d5501edf4f7feb07d0ad689d80
Author: Yijing Wang <wangyijing@huawei.com>
Date:   Tue Jul 24 17:20:03 2012 +0800

    PCI: Introduce pci_pcie_type(dev) to replace pci_dev->pcie_type
    
    Introduce an inline function pci_pcie_type(dev) to extract PCIe
    device type from pci_dev->pcie_flags_reg field, and prepare for
    removing pci_dev->pcie_type.
    
    Signed-off-by: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Jiang Liu <jiang.liu@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index ba4d8550503c..1d52a43eb086 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1384,9 +1384,9 @@ static int only_one_child(struct pci_bus *bus)
 
 	if (!parent || !pci_is_pcie(parent))
 		return 0;
-	if (parent->pcie_type == PCI_EXP_TYPE_ROOT_PORT)
+	if (pci_pcie_type(parent) == PCI_EXP_TYPE_ROOT_PORT)
 		return 1;
-	if (parent->pcie_type == PCI_EXP_TYPE_DOWNSTREAM &&
+	if (pci_pcie_type(parent) == PCI_EXP_TYPE_DOWNSTREAM &&
 	    !pci_has_flag(PCI_SCAN_ALL_PCIE_DEVS))
 		return 1;
 	return 0;
@@ -1463,7 +1463,7 @@ static int pcie_find_smpss(struct pci_dev *dev, void *data)
 	 */
 	if (dev->is_hotplug_bridge && (!list_is_singular(&dev->bus->devices) ||
 	     (dev->bus->self &&
-	      dev->bus->self->pcie_type != PCI_EXP_TYPE_ROOT_PORT)))
+	      pci_pcie_type(dev->bus->self) != PCI_EXP_TYPE_ROOT_PORT)))
 		*smpss = 0;
 
 	if (*smpss > dev->pcie_mpss)
@@ -1479,7 +1479,8 @@ static void pcie_write_mps(struct pci_dev *dev, int mps)
 	if (pcie_bus_config == PCIE_BUS_PERFORMANCE) {
 		mps = 128 << dev->pcie_mpss;
 
-		if (dev->pcie_type != PCI_EXP_TYPE_ROOT_PORT && dev->bus->self)
+		if (pci_pcie_type(dev) != PCI_EXP_TYPE_ROOT_PORT &&
+		    dev->bus->self)
 			/* For "Performance", the assumption is made that
 			 * downstream communication will never be larger than
 			 * the MRRS.  So, the MPS only needs to be configured

commit 786e22885d9959fda0473ace5a61cb11620fba9b
Author: Yijing Wang <wangyijing@huawei.com>
Date:   Tue Jul 24 17:20:02 2012 +0800

    PCI: Add pcie_flags_reg to cache PCIe capabilities register
    
    Since PCI Express Capabilities Register is read only, cache its value
    into struct pci_dev to avoid repeatedly calling pci_read_config_*().
    
    Signed-off-by: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Jiang Liu <jiang.liu@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 6c143b4497ca..ba4d8550503c 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -929,7 +929,8 @@ void set_pcie_port_type(struct pci_dev *pdev)
 	pdev->is_pcie = 1;
 	pdev->pcie_cap = pos;
 	pci_read_config_word(pdev, pos + PCI_EXP_FLAGS, &reg16);
-	pdev->pcie_type = (reg16 & PCI_EXP_FLAGS_TYPE) >> 4;
+	pdev->pcie_flags_reg = reg16;
+	pdev->pcie_type = pci_pcie_type(pdev);
 	pci_read_config_word(pdev, pos + PCI_EXP_DEVCAP, &reg16);
 	pdev->pcie_mpss = reg16 & PCI_EXP_DEVCAP_PAYLOAD;
 }

commit 6ee53f4c38e70ba34777ad38807a50c1812ff36f
Merge: d68e70c6e59a 1c975931128c
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Jul 10 08:36:09 2012 -0600

    Merge branch 'pci/bjorn-p2p-bridge-windows' into next
    
    * pci/bjorn-p2p-bridge-windows:
      sparc/PCI: replace pci_cfg_fake_ranges() with pci_read_bridge_bases()
      PCI: support sizing P2P bridge I/O windows with 1K granularity
      PCI: reimplement P2P bridge 1K I/O windows (Intel P64H2)
      PCI: allow P2P bridge windows starting at PCI bus address zero
    
    Conflicts:
            drivers/pci/probe.c
            include/linux/pci.h

commit d68e70c6e59ad08feca291c2790164d3231c425e
Merge: 9349b44a4596 9aac537e0e33
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Jul 9 21:02:44 2012 -0600

    Merge branch 'pci/bjorn-disable-decode' into next
    
    * pci/bjorn-disable-decode:
      PCI: disable MEM decoding while updating 64-bit MEM BARs
      PCI: leave MEM and IO decoding disabled during 64-bit BAR sizing, too

commit 2b28ae1912e5ce5bb0527e352ae6ff04e76183d1
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Jul 9 13:38:57 2012 -0600

    PCI: reimplement P2P bridge 1K I/O windows (Intel P64H2)
    
    9d265124d051 and 15a260d53f7c added quirks for P2P bridges that support
    I/O windows that start/end at 1K boundaries, not just the 4K boundaries
    defined by the PCI spec.  For details, see the IOBL_ADR register and the
    EN1K bit in the CNF register in the Intel 82870P2 (P64H2).
    
    These quirks complicate the code that reads P2P bridge windows
    (pci_read_bridge_io() and pci_cfg_fake_ranges()) because the bridge
    I/O resource is updated in the HEADER quirk, in pci_read_bridge_io(),
    in pci_setup_bridge(), and again in the FINAL quirk.  This is confusing
    and makes it impossible to reassign the bridge windows after FINAL
    quirks are run.
    
    This patch adds support for 1K windows in the generic paths, so the
    HEADER quirk only has to enable this support.  The FINAL quirk, which
    used to undo damage done by pci_setup_bridge(), is no longer needed.
    
    This removes "if (!res->start) res->start = ..." from pci_read_bridge_io();
    that was part of 9d265124d051 to avoid overwriting the resource filled in
    by the quirk.  Since pci_read_bridge_io() itself now knows about
    granularity, the quirk no longer updates the resource and this test is no
    longer needed.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 9c5d2a992999..ef24cf765b2f 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -269,15 +269,23 @@ static void __devinit pci_read_bridge_io(struct pci_bus *child)
 {
 	struct pci_dev *dev = child->self;
 	u8 io_base_lo, io_limit_lo;
-	unsigned long base, limit;
+	unsigned long io_mask, io_granularity, base, limit;
 	struct pci_bus_region region;
-	struct resource *res, res2;
+	struct resource *res;
+
+	io_mask = PCI_IO_RANGE_MASK;
+	io_granularity = 0x1000;
+	if (dev->io_window_1k) {
+		/* Support 1K I/O space granularity */
+		io_mask = PCI_IO_1K_RANGE_MASK;
+		io_granularity = 0x400;
+	}
 
 	res = child->resource[0];
 	pci_read_config_byte(dev, PCI_IO_BASE, &io_base_lo);
 	pci_read_config_byte(dev, PCI_IO_LIMIT, &io_limit_lo);
-	base = (io_base_lo & PCI_IO_RANGE_MASK) << 8;
-	limit = (io_limit_lo & PCI_IO_RANGE_MASK) << 8;
+	base = (io_base_lo & io_mask) << 8;
+	limit = (io_limit_lo & io_mask) << 8;
 
 	if ((io_base_lo & PCI_IO_RANGE_TYPE_MASK) == PCI_IO_RANGE_TYPE_32) {
 		u16 io_base_hi, io_limit_hi;
@@ -289,14 +297,9 @@ static void __devinit pci_read_bridge_io(struct pci_bus *child)
 
 	if (base <= limit) {
 		res->flags = (io_base_lo & PCI_IO_RANGE_TYPE_MASK) | IORESOURCE_IO;
-		res2.flags = res->flags;
 		region.start = base;
-		region.end = limit + 0xfff;
-		pcibios_bus_to_resource(dev, &res2, &region);
-		if (!res->start)
-			res->start = res2.start;
-		if (!res->end)
-			res->end = res2.end;
+		region.end = limit + io_granularity - 1;
+		pcibios_bus_to_resource(dev, res, &region);
 		dev_printk(KERN_DEBUG, &dev->dev, "  bridge window %pR\n", res);
 	}
 }

commit bbffe435248444065bd76141c41bbe65db950cc9
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Jul 6 12:08:18 2012 -0600

    PCI: leave MEM and IO decoding disabled during 64-bit BAR sizing, too
    
    After 253d2e5498, we disable MEM and IO decoding for most devices while we
    size 32-bit BARs.  However, we restore the original COMMAND register before
    we size the upper 32 bits of 64-bit BARs, so we can still cause a conflict.
    
    This patch waits to restore the original COMMAND register until we're
    completely finished sizing the BAR.
    
    Reference: https://lkml.org/lkml/2007/8/25/154
    Acked-by: Jacob Pan <jacob.jun.pan@linux.intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 658ac977cb56..66b3a6ffe5a0 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -152,9 +152,6 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 	pci_read_config_dword(dev, pos, &sz);
 	pci_write_config_dword(dev, pos, l);
 
-	if (!dev->mmio_always_on)
-		pci_write_config_word(dev, PCI_COMMAND, orig_cmd);
-
 	/*
 	 * All bits set in sz means the device isn't working properly.
 	 * If the BAR isn't implemented, all bits must be 0.  If it's a
@@ -239,6 +236,9 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 	}
 
  out:
+	if (!dev->mmio_always_on)
+		pci_write_config_word(dev, PCI_COMMAND, orig_cmd);
+
 	return (res->flags & IORESOURCE_MEM_64) ? 1 : 0;
  fail:
 	res->flags = 0;

commit 5dde383e2ef5e22fe7db689dc38c1aabfb801449
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Jul 9 13:38:41 2012 -0600

    PCI: allow P2P bridge windows starting at PCI bus address zero
    
    cd81e1ea1a4c added checks that prevent us from using P2P bridge windows
    that start at PCI bus address zero.  The reason was to "prevent us from
    overwriting resources that are unassigned."
    
    But generic code should allow address zero in both BARs and bridge
    windows, so I think that commit was a mistake.
    
    Windows at bus address zero are legal and likely to exist on machines with
    an offset between bus addresses and CPU addresses.  For example, in the
    following hypothetical scenario, the bridge at 00:01.0 has a window at bus
    address zero and the device at 01:00.0 has a BAR at bus address zero, and
    I think both are perfectly valid:
    
        PCI host bridge to bus 0000:00
        pci_bus 0000:00: root bus resource [mem 0x100000000-0x1ffffffff] (bus address [0x00000000-0xffffffff])
        pci 0000:00:01.0: PCI bridge to [bus 01]
        pci 0000:00:01.0:   bridge window [mem 0x100000000-0x100ffffff]
        pci 0000:01:00.0: reg 10: [mem 0x100000000-0x100ffffff]
    
    Acked-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 658ac977cb56..9c5d2a992999 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -287,7 +287,7 @@ static void __devinit pci_read_bridge_io(struct pci_bus *child)
 		limit |= (io_limit_hi << 16);
 	}
 
-	if (base && base <= limit) {
+	if (base <= limit) {
 		res->flags = (io_base_lo & PCI_IO_RANGE_TYPE_MASK) | IORESOURCE_IO;
 		res2.flags = res->flags;
 		region.start = base;
@@ -314,7 +314,7 @@ static void __devinit pci_read_bridge_mmio(struct pci_bus *child)
 	pci_read_config_word(dev, PCI_MEMORY_LIMIT, &mem_limit_lo);
 	base = (mem_base_lo & PCI_MEMORY_RANGE_MASK) << 16;
 	limit = (mem_limit_lo & PCI_MEMORY_RANGE_MASK) << 16;
-	if (base && base <= limit) {
+	if (base <= limit) {
 		res->flags = (mem_base_lo & PCI_MEMORY_RANGE_TYPE_MASK) | IORESOURCE_MEM;
 		region.start = base;
 		region.end = limit + 0xfffff;
@@ -360,7 +360,7 @@ static void __devinit pci_read_bridge_mmio_pref(struct pci_bus *child)
 #endif
 		}
 	}
-	if (base && base <= limit) {
+	if (base <= limit) {
 		res->flags = (mem_base_lo & PCI_PREF_RANGE_TYPE_MASK) |
 					 IORESOURCE_MEM | IORESOURCE_PREFETCH;
 		if (res->flags & PCI_PREF_RANGE_TYPE_64)

commit 0f6662a49bf1b5a163ed4e6321c382d2390c817b
Merge: 1693c4276d76 809a3bf9f34c
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Jun 22 15:32:50 2012 -0600

    Merge branch 'topic/bjorn-trivial' into next
    
    * topic/bjorn-trivial:
      PCI: remove useless pcix_set_mmrbc() dev->bus check
      PCI: acpiphp: check whether _ADR evaluation succeeded
      PCI: shpchp: remove dead code
      PCI: fix P2P bridge I/O port window sign extension
      PCI: fix upstream P2P bridge checks when enabling OBFF and LTR
      PCI: use __weak consistently
      PCI: cleanup assign_requested_resources_sorted() kernel-doc warning
      sparc/PCI: remove unused pcibios_assign_resource() definition

commit 8f38eaca55d0fab7499b33adb1dec33e16de5abb
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Jun 19 07:45:44 2012 -0600

    PCI: fix P2P bridge I/O port window sign extension
    
    On P2P bridges with 32-bit I/O decoding, we incorrectly sign-extended
    windows starting at 0x80000000 or above.  In "base |= (io_base_hi << 16)",
    "io_base_hi" is promoted to a signed int before being extended to an
    unsigned long.
    
    This would cause a window starting at I/O address 0x80000000 to be
    treated as though it started at 0xffffffff80008000 instead, which
    should cause "no compatible bridge window" errors when we enumerate
    devices using that I/O space.
    
    The mmio and mmio_pref casts are not strictly necessary, but without
    them, correctness depends on the types of the PCI_MEMORY_RANGE_MASK and
    PCI_PREF_RANGE_MASK constants, which are not obvious from reading the
    local code.
    
    Found by Coverity (CID 138747 and CID 138748).
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 658ac977cb56..a7a504fc82b9 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -281,10 +281,11 @@ static void __devinit pci_read_bridge_io(struct pci_bus *child)
 
 	if ((io_base_lo & PCI_IO_RANGE_TYPE_MASK) == PCI_IO_RANGE_TYPE_32) {
 		u16 io_base_hi, io_limit_hi;
+
 		pci_read_config_word(dev, PCI_IO_BASE_UPPER16, &io_base_hi);
 		pci_read_config_word(dev, PCI_IO_LIMIT_UPPER16, &io_limit_hi);
-		base |= (io_base_hi << 16);
-		limit |= (io_limit_hi << 16);
+		base |= ((unsigned long) io_base_hi << 16);
+		limit |= ((unsigned long) io_limit_hi << 16);
 	}
 
 	if (base && base <= limit) {
@@ -312,8 +313,8 @@ static void __devinit pci_read_bridge_mmio(struct pci_bus *child)
 	res = child->resource[1];
 	pci_read_config_word(dev, PCI_MEMORY_BASE, &mem_base_lo);
 	pci_read_config_word(dev, PCI_MEMORY_LIMIT, &mem_limit_lo);
-	base = (mem_base_lo & PCI_MEMORY_RANGE_MASK) << 16;
-	limit = (mem_limit_lo & PCI_MEMORY_RANGE_MASK) << 16;
+	base = ((unsigned long) mem_base_lo & PCI_MEMORY_RANGE_MASK) << 16;
+	limit = ((unsigned long) mem_limit_lo & PCI_MEMORY_RANGE_MASK) << 16;
 	if (base && base <= limit) {
 		res->flags = (mem_base_lo & PCI_MEMORY_RANGE_TYPE_MASK) | IORESOURCE_MEM;
 		region.start = base;
@@ -334,11 +335,12 @@ static void __devinit pci_read_bridge_mmio_pref(struct pci_bus *child)
 	res = child->resource[2];
 	pci_read_config_word(dev, PCI_PREF_MEMORY_BASE, &mem_base_lo);
 	pci_read_config_word(dev, PCI_PREF_MEMORY_LIMIT, &mem_limit_lo);
-	base = (mem_base_lo & PCI_PREF_RANGE_MASK) << 16;
-	limit = (mem_limit_lo & PCI_PREF_RANGE_MASK) << 16;
+	base = ((unsigned long) mem_base_lo & PCI_PREF_RANGE_MASK) << 16;
+	limit = ((unsigned long) mem_limit_lo & PCI_PREF_RANGE_MASK) << 16;
 
 	if ((mem_base_lo & PCI_PREF_RANGE_TYPE_MASK) == PCI_PREF_RANGE_TYPE_64) {
 		u32 mem_base_hi, mem_limit_hi;
+
 		pci_read_config_dword(dev, PCI_PREF_BASE_UPPER32, &mem_base_hi);
 		pci_read_config_dword(dev, PCI_PREF_LIMIT_UPPER32, &mem_limit_hi);
 
@@ -349,8 +351,8 @@ static void __devinit pci_read_bridge_mmio_pref(struct pci_bus *child)
 		 */
 		if (mem_base_hi <= mem_limit_hi) {
 #if BITS_PER_LONG == 64
-			base |= ((long) mem_base_hi) << 32;
-			limit |= ((long) mem_limit_hi) << 32;
+			base |= ((unsigned long) mem_base_hi) << 32;
+			limit |= ((unsigned long) mem_limit_hi) << 32;
 #else
 			if (mem_base_hi || mem_limit_hi) {
 				dev_err(&dev->dev, "can't handle 64-bit "

commit bc76b7310a352be1c2ed24133e89c5df24eff05e
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Thu May 17 18:51:13 2012 -0700

    PCI: insert busn_res for child bus
    
    Now we can insert busn_res now, after all root bus's get inserted.
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 9f68b9d3597c..08404098080b 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -755,7 +755,7 @@ int __devinit pci_scan_bridge(struct pci_bus *bus, struct pci_dev *dev, int max,
 			if (!child)
 				goto out;
 			child->primary = primary;
-			child->busn_res.end = subordinate;
+			pci_bus_insert_busn_res(child, secondary, subordinate);
 			child->bridge_ctl = bctl;
 		}
 
@@ -793,6 +793,7 @@ int __devinit pci_scan_bridge(struct pci_bus *bus, struct pci_dev *dev, int max,
 			child = pci_add_new_bus(bus, dev, ++max);
 			if (!child)
 				goto out;
+			pci_bus_insert_busn_res(child, max, 0xff);
 		}
 		buses = (buses & 0xff000000)
 		      | ((unsigned int)(child->primary)     <<  0)
@@ -864,7 +865,7 @@ int __devinit pci_scan_bridge(struct pci_bus *bus, struct pci_dev *dev, int max,
 		/*
 		 * Set the subordinate bus number to its real value.
 		 */
-		child->busn_res.end = max;
+		pci_bus_update_busn_res_end(child, max);
 		pci_write_config_byte(dev, PCI_SUBORDINATE_BUS, max);
 	}
 

commit 857c3b668ae35c48d9d7a4248b6c0bdb65797d0e
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Thu May 17 18:51:12 2012 -0700

    PCI: add default busn_res for pci_scan_bus()
    
    also do not need to shrink busn_res.
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 68e75cb0831b..9f68b9d3597c 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1836,9 +1836,10 @@ struct pci_bus * __devinit pci_scan_bus_parented(struct device *parent,
 
 	pci_add_resource(&resources, &ioport_resource);
 	pci_add_resource(&resources, &iomem_resource);
+	pci_add_resource(&resources, &busn_resource);
 	b = pci_create_root_bus(parent, bus, ops, sysdata, &resources);
 	if (b)
-		b->busn_res.end = pci_scan_child_bus(b);
+		pci_scan_child_bus(b);
 	else
 		pci_free_resource_list(&resources);
 	return b;
@@ -1853,9 +1854,10 @@ struct pci_bus * __devinit pci_scan_bus(int bus, struct pci_ops *ops,
 
 	pci_add_resource(&resources, &ioport_resource);
 	pci_add_resource(&resources, &iomem_resource);
+	pci_add_resource(&resources, &busn_resource);
 	b = pci_create_root_bus(NULL, bus, ops, sysdata, &resources);
 	if (b) {
-		b->busn_res.end = pci_scan_child_bus(b);
+		pci_scan_child_bus(b);
 		pci_bus_add_devices(b);
 	} else {
 		pci_free_resource_list(&resources);

commit 67cdc827286366acb6c60c821013c1185ee00b36
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Thu May 17 18:51:12 2012 -0700

    PCI: add default busn_resource
    
    We need to put into the resources list for legacy system.
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 6258f6f24983..68e75cb0831b 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -16,6 +16,13 @@
 #define CARDBUS_LATENCY_TIMER	176	/* secondary latency timer */
 #define CARDBUS_RESERVE_BUSNR	3
 
+struct resource busn_resource = {
+	.name	= "PCI busn",
+	.start	= 0,
+	.end	= 255,
+	.flags	= IORESOURCE_BUS,
+};
+
 /* Ugh.  Need to stop exporting this to modules. */
 LIST_HEAD(pci_root_buses);
 EXPORT_SYMBOL(pci_root_buses);

commit 4d99f524234c2e772eea68ad019ec9c805991f23
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Thu May 17 18:51:12 2012 -0700

    PCI: checking busn_res in pci_scan_root_bus()
    
    Some callers do not supply the bus number aperture, usually because they do
    not know the end.  In this case, we assume the aperture extends from the
    root bus number to bus 255, scan the bus, and shrink the bus number
    resource so it ends at the largest bus number we found.
    
    This is obviously not correct because the actual end of the aperture may
    well be larger than the largest bus number we found.  But I guess it's all
    we have for now.
    
    Also print out one info about that, so we could find out which path
    does not have busn_res in resources list.
    
    [bhelgaas: changelog, _safe iterator unnecessary, use %pR format for bus]
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 59011ce9840f..6258f6f24983 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1788,13 +1788,33 @@ void pci_bus_release_busn_res(struct pci_bus *b)
 struct pci_bus * __devinit pci_scan_root_bus(struct device *parent, int bus,
 		struct pci_ops *ops, void *sysdata, struct list_head *resources)
 {
+	struct pci_host_bridge_window *window;
+	bool found = false;
 	struct pci_bus *b;
+	int max;
+
+	list_for_each_entry(window, resources, list)
+		if (window->res->flags & IORESOURCE_BUS) {
+			found = true;
+			break;
+		}
 
 	b = pci_create_root_bus(parent, bus, ops, sysdata, resources);
 	if (!b)
 		return NULL;
 
-	b->busn_res.end = pci_scan_child_bus(b);
+	if (!found) {
+		dev_info(&b->dev,
+		 "No busn resource found for root bus, will use [bus %02x-ff]\n",
+			bus);
+		pci_bus_insert_busn_res(b, bus, 255);
+	}
+
+	max = pci_scan_child_bus(b);
+
+	if (!found)
+		pci_bus_update_busn_res_end(b, max);
+
 	pci_bus_add_devices(b);
 	return b;
 }

commit f848ffb1043ed0d168064176fb452cc51ec8e0b7
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Thu May 17 18:51:12 2012 -0700

    PCI: insert busn_res in pci_create_root_bus()
    
    That busn_res is from resources list.
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 7662ab7b2640..59011ce9840f 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1684,7 +1684,10 @@ struct pci_bus *pci_create_root_bus(struct device *parent, int bus,
 		list_move_tail(&window->list, &bridge->windows);
 		res = window->res;
 		offset = window->offset;
-		pci_bus_add_resource(b, res, 0);
+		if (res->flags & IORESOURCE_BUS)
+			pci_bus_insert_busn_res(b, bus, res->end);
+		else
+			pci_bus_add_resource(b, res, 0);
 		if (offset) {
 			if (resource_type(res) == IORESOURCE_IO)
 				fmt = " (bus address [%#06llx-%#06llx])";

commit 98a3583107ed587ed3cfe2a1d8e5347421de5a80
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Fri May 18 11:35:50 2012 -0600

    PCI: add busn_res operation functions
    
    Will use them insert/update busn res in pci_bus struct.
    
    [bhelgaas: print conflicting entry if insertion fails]
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 674a477a6486..7662ab7b2640 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1714,6 +1714,74 @@ struct pci_bus *pci_create_root_bus(struct device *parent, int bus,
 	return NULL;
 }
 
+int pci_bus_insert_busn_res(struct pci_bus *b, int bus, int bus_max)
+{
+	struct resource *res = &b->busn_res;
+	struct resource *parent_res, *conflict;
+
+	res->start = bus;
+	res->end = bus_max;
+	res->flags = IORESOURCE_BUS;
+
+	if (!pci_is_root_bus(b))
+		parent_res = &b->parent->busn_res;
+	else {
+		parent_res = get_pci_domain_busn_res(pci_domain_nr(b));
+		res->flags |= IORESOURCE_PCI_FIXED;
+	}
+
+	conflict = insert_resource_conflict(parent_res, res);
+
+	if (conflict)
+		dev_printk(KERN_DEBUG, &b->dev,
+			   "busn_res: can not insert %pR under %s%pR (conflicts with %s %pR)\n",
+			    res, pci_is_root_bus(b) ? "domain " : "",
+			    parent_res, conflict->name, conflict);
+	else
+		dev_printk(KERN_DEBUG, &b->dev,
+			   "busn_res: %pR is inserted under %s%pR\n",
+			   res, pci_is_root_bus(b) ? "domain " : "",
+			   parent_res);
+
+	return conflict == NULL;
+}
+
+int pci_bus_update_busn_res_end(struct pci_bus *b, int bus_max)
+{
+	struct resource *res = &b->busn_res;
+	struct resource old_res = *res;
+	resource_size_t size;
+	int ret;
+
+	if (res->start > bus_max)
+		return -EINVAL;
+
+	size = bus_max - res->start + 1;
+	ret = adjust_resource(res, res->start, size);
+	dev_printk(KERN_DEBUG, &b->dev,
+			"busn_res: %pR end %s updated to %02x\n",
+			&old_res, ret ? "can not be" : "is", bus_max);
+
+	if (!ret && !res->parent)
+		pci_bus_insert_busn_res(b, res->start, res->end);
+
+	return ret;
+}
+
+void pci_bus_release_busn_res(struct pci_bus *b)
+{
+	struct resource *res = &b->busn_res;
+	int ret;
+
+	if (!res->flags || !res->parent)
+		return;
+
+	ret = release_resource(res);
+	dev_printk(KERN_DEBUG, &b->dev,
+			"busn_res: %pR %s released\n",
+			res, ret ? "can not be" : "is");
+}
+
 struct pci_bus * __devinit pci_scan_root_bus(struct device *parent, int bus,
 		struct pci_ops *ops, void *sysdata, struct list_head *resources)
 {

commit 5cc62c202211096ec26309722ec27455d52c8726
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Thu May 17 18:51:11 2012 -0700

    PCI: build a bus number resource tree for every domain
    
    This adds get_pci_domain_busn_res(), which returns the root of the
    bus number resource tree for a domain, creating it if necessary.
    We will later populate the tree with the bus numbers used by host
    bridges and P2P bridges in the domain.
    
    [bhelgaas: changelog]
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 651b096134dc..674a477a6486 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -20,6 +20,36 @@
 LIST_HEAD(pci_root_buses);
 EXPORT_SYMBOL(pci_root_buses);
 
+static LIST_HEAD(pci_domain_busn_res_list);
+
+struct pci_domain_busn_res {
+	struct list_head list;
+	struct resource res;
+	int domain_nr;
+};
+
+static struct resource *get_pci_domain_busn_res(int domain_nr)
+{
+	struct pci_domain_busn_res *r;
+
+	list_for_each_entry(r, &pci_domain_busn_res_list, list)
+		if (r->domain_nr == domain_nr)
+			return &r->res;
+
+	r = kzalloc(sizeof(*r), GFP_KERNEL);
+	if (!r)
+		return NULL;
+
+	r->domain_nr = domain_nr;
+	r->res.start = 0;
+	r->res.end = 0xff;
+	r->res.flags = IORESOURCE_BUS | IORESOURCE_PCI_FIXED;
+
+	list_add_tail(&r->list, &pci_domain_busn_res_list);
+
+	return &r->res;
+}
+
 static int find_anything(struct device *dev, void *data)
 {
 	return 1;

commit b918c62e086b2130a7bae44110ca516ef10bfe5a
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Thu May 17 18:51:11 2012 -0700

    PCI: replace struct pci_bus secondary/subordinate with busn_res
    
    Replace the struct pci_bus secondary/subordinate members with the
    struct resource busn_res.  Later we'll build a resource tree of these
    bus numbers.
    
    [bhelgaas: changelog]
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 658ac977cb56..651b096134dc 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -381,8 +381,8 @@ void __devinit pci_read_bridge_bases(struct pci_bus *child)
 	if (pci_is_root_bus(child))	/* It's a host bus, nothing to read */
 		return;
 
-	dev_info(&dev->dev, "PCI bridge to [bus %02x-%02x]%s\n",
-		 child->secondary, child->subordinate,
+	dev_info(&dev->dev, "PCI bridge to %pR%s\n",
+		 &child->busn_res,
 		 dev->transparent ? " (subtractive decode)" : "");
 
 	pci_bus_remove_resources(child);
@@ -599,9 +599,9 @@ static struct pci_bus *pci_alloc_child_bus(struct pci_bus *parent,
 	 * Set up the primary, secondary and subordinate
 	 * bus numbers.
 	 */
-	child->number = child->secondary = busnr;
-	child->primary = parent->secondary;
-	child->subordinate = 0xff;
+	child->number = child->busn_res.start = busnr;
+	child->primary = parent->busn_res.start;
+	child->busn_res.end = 0xff;
 
 	if (!bridge)
 		return child;
@@ -643,8 +643,8 @@ static void pci_fixup_parent_subordinate_busnr(struct pci_bus *child, int max)
 	if (!pcibios_assign_all_busses())
 		return;
 
-	while (parent->parent && parent->subordinate < max) {
-		parent->subordinate = max;
+	while (parent->parent && parent->busn_res.end < max) {
+		parent->busn_res.end = max;
 		pci_write_config_byte(parent->self, PCI_SUBORDINATE_BUS, max);
 		parent = parent->parent;
 	}
@@ -718,15 +718,15 @@ int __devinit pci_scan_bridge(struct pci_bus *bus, struct pci_dev *dev, int max,
 			if (!child)
 				goto out;
 			child->primary = primary;
-			child->subordinate = subordinate;
+			child->busn_res.end = subordinate;
 			child->bridge_ctl = bctl;
 		}
 
 		cmax = pci_scan_child_bus(child);
 		if (cmax > max)
 			max = cmax;
-		if (child->subordinate > max)
-			max = child->subordinate;
+		if (child->busn_res.end > max)
+			max = child->busn_res.end;
 	} else {
 		/*
 		 * We need to assign a number to this bus which we always
@@ -759,8 +759,8 @@ int __devinit pci_scan_bridge(struct pci_bus *bus, struct pci_dev *dev, int max,
 		}
 		buses = (buses & 0xff000000)
 		      | ((unsigned int)(child->primary)     <<  0)
-		      | ((unsigned int)(child->secondary)   <<  8)
-		      | ((unsigned int)(child->subordinate) << 16);
+		      | ((unsigned int)(child->busn_res.start)   <<  8)
+		      | ((unsigned int)(child->busn_res.end) << 16);
 
 		/*
 		 * yenta.c forces a secondary latency timer of 176.
@@ -805,8 +805,8 @@ int __devinit pci_scan_bridge(struct pci_bus *bus, struct pci_dev *dev, int max,
 					break;
 				while (parent->parent) {
 					if ((!pcibios_assign_all_busses()) &&
-					    (parent->subordinate > max) &&
-					    (parent->subordinate <= max+i)) {
+					    (parent->busn_res.end > max) &&
+					    (parent->busn_res.end <= max+i)) {
 						j = 1;
 					}
 					parent = parent->parent;
@@ -827,7 +827,7 @@ int __devinit pci_scan_bridge(struct pci_bus *bus, struct pci_dev *dev, int max,
 		/*
 		 * Set the subordinate bus number to its real value.
 		 */
-		child->subordinate = max;
+		child->busn_res.end = max;
 		pci_write_config_byte(dev, PCI_SUBORDINATE_BUS, max);
 	}
 
@@ -837,19 +837,19 @@ int __devinit pci_scan_bridge(struct pci_bus *bus, struct pci_dev *dev, int max,
 
 	/* Has only triggered on CardBus, fixup is in yenta_socket */
 	while (bus->parent) {
-		if ((child->subordinate > bus->subordinate) ||
-		    (child->number > bus->subordinate) ||
+		if ((child->busn_res.end > bus->busn_res.end) ||
+		    (child->number > bus->busn_res.end) ||
 		    (child->number < bus->number) ||
-		    (child->subordinate < bus->number)) {
-			dev_info(&child->dev, "[bus %02x-%02x] %s "
-				"hidden behind%s bridge %s [bus %02x-%02x]\n",
-				child->number, child->subordinate,
-				(bus->number > child->subordinate &&
-				 bus->subordinate < child->number) ?
+		    (child->busn_res.end < bus->number)) {
+			dev_info(&child->dev, "%pR %s "
+				"hidden behind%s bridge %s %pR\n",
+				&child->busn_res,
+				(bus->number > child->busn_res.end &&
+				 bus->busn_res.end < child->number) ?
 					"wholly" : "partially",
 				bus->self->transparent ? " transparent" : "",
 				dev_name(&bus->dev),
-				bus->number, bus->subordinate);
+				&bus->busn_res);
 		}
 		bus = bus->parent;
 	}
@@ -1548,7 +1548,7 @@ EXPORT_SYMBOL_GPL(pcie_bus_configure_settings);
 
 unsigned int __devinit pci_scan_child_bus(struct pci_bus *bus)
 {
-	unsigned int devfn, pass, max = bus->secondary;
+	unsigned int devfn, pass, max = bus->busn_res.start;
 	struct pci_dev *dev;
 
 	dev_dbg(&bus->dev, "scanning bus\n");
@@ -1642,7 +1642,7 @@ struct pci_bus *pci_create_root_bus(struct device *parent, int bus,
 	/* Create legacy_io and legacy_mem files for this bus */
 	pci_create_legacy_files(b);
 
-	b->number = b->secondary = bus;
+	b->number = b->busn_res.start = bus;
 
 	if (parent)
 		dev_info(parent, "PCI host bridge to bus %s\n", dev_name(&b->dev));
@@ -1693,7 +1693,7 @@ struct pci_bus * __devinit pci_scan_root_bus(struct device *parent, int bus,
 	if (!b)
 		return NULL;
 
-	b->subordinate = pci_scan_child_bus(b);
+	b->busn_res.end = pci_scan_child_bus(b);
 	pci_bus_add_devices(b);
 	return b;
 }
@@ -1710,7 +1710,7 @@ struct pci_bus * __devinit pci_scan_bus_parented(struct device *parent,
 	pci_add_resource(&resources, &iomem_resource);
 	b = pci_create_root_bus(parent, bus, ops, sysdata, &resources);
 	if (b)
-		b->subordinate = pci_scan_child_bus(b);
+		b->busn_res.end = pci_scan_child_bus(b);
 	else
 		pci_free_resource_list(&resources);
 	return b;
@@ -1727,7 +1727,7 @@ struct pci_bus * __devinit pci_scan_bus(int bus, struct pci_ops *ops,
 	pci_add_resource(&resources, &iomem_resource);
 	b = pci_create_root_bus(NULL, bus, ops, sysdata, &resources);
 	if (b) {
-		b->subordinate = pci_scan_child_bus(b);
+		b->busn_res.end = pci_scan_child_bus(b);
 		pci_bus_add_devices(b);
 	} else {
 		pci_free_resource_list(&resources);

commit 0cbaa57d828aa0a067e06d3c6d795b12ae9fb776
Merge: 99662dd1ce05 284f5f9dbac1
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon May 7 09:23:27 2012 -0600

    Merge branch 'topic/stratus' into next

commit 284f5f9dbac170b054c1e386ef92cbf654e91bba
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Apr 30 15:21:02 2012 -0600

    PCI: work around Stratus ftServer broken PCIe hierarchy
    
    A PCIe downstream port is a P2P bridge.  Its secondary interface is
    a link that should lead only to device 0 (unless ARI is enabled)[1], so
    we don't probe for non-zero device numbers.
    
    Some Stratus ftServer systems have a PCIe downstream port (02:00.0) that
    leads to both an upstream port (03:00.0) and a downstream port (03:01.0),
    and 03:01.0 has important devices below it:
    
      [0000:02]-+-00.0-[03-3c]--+-00.0-[04-09]--...
                                \-01.0-[0a-0d]--+-[USB]
                                                +-[NIC]
                                                +-...
    
    Previously, we didn't enumerate device 03:01.0, so USB and the network
    didn't work.  This patch adds a DMI quirk to scan all device numbers,
    not just 0, below a downstream port.
    
    Based on a patch by Prarit Bhargava.
    
    [1] PCIe spec r3.0, sec 7.3.1
    
    CC: Myron Stowe <mstowe@redhat.com>
    CC: Don Dutile <ddutile@redhat.com>
    CC: James Paradis <james.paradis@stratus.com>
    CC: Matthew Wilcox <matthew.r.wilcox@intel.com>
    CC: Jesse Barnes <jbarnes@virtuousgeek.org>
    CC: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 5e1ca3c58a7d..2dc8675eea1a 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -10,6 +10,7 @@
 #include <linux/module.h>
 #include <linux/cpumask.h>
 #include <linux/pci-aspm.h>
+#include <asm-generic/pci-bridge.h>
 #include "pci.h"
 
 #define CARDBUS_LATENCY_TIMER	176	/* secondary latency timer */
@@ -1395,10 +1396,13 @@ static unsigned no_next_fn(struct pci_dev *dev, unsigned fn)
 static int only_one_child(struct pci_bus *bus)
 {
 	struct pci_dev *parent = bus->self;
+
 	if (!parent || !pci_is_pcie(parent))
 		return 0;
-	if (parent->pcie_type == PCI_EXP_TYPE_ROOT_PORT ||
-	    parent->pcie_type == PCI_EXP_TYPE_DOWNSTREAM)
+	if (parent->pcie_type == PCI_EXP_TYPE_ROOT_PORT)
+		return 1;
+	if (parent->pcie_type == PCI_EXP_TYPE_DOWNSTREAM &&
+	    !pci_has_flag(PCI_SCAN_ALL_PCIE_DEVS))
 		return 1;
 	return 0;
 }

commit 4fa2649a01a4357a82dcc60ef8fb7b8c441e64ed
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Mon Apr 2 18:31:53 2012 -0700

    PCI: add host bridge release support
    
    We need a hook to release host bridge resources allocated when creating
    root bus.
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 8d291ee15257..4c2f22668ea7 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1137,7 +1137,8 @@ static void pci_release_bus_bridge_dev(struct device *dev)
 {
 	struct pci_host_bridge *bridge = to_pci_host_bridge(dev);
 
-	/* TODO: need to free window->res */
+	if (bridge->release_fn)
+		bridge->release_fn(bridge);
 
 	pci_free_resource_list(&bridge->windows);
 

commit 7b54366358008241f88228f02cc80ab352265eac
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Mon Apr 2 18:31:53 2012 -0700

    PCI: add generic device into pci_host_bridge struct
    
    Use that device for pci_root_bus bridge pointer.
    
    Use pci_release_bus_bridge_dev() to release allocated pci_host_bridge in
    remove path.
    
    Use root bus bridge pointer to get host bridge pointer instead of searching
    host bridge list.  That leaves the host bridge list unused, so remove it.
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index bcea52b90e0d..8d291ee15257 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -422,6 +422,19 @@ static struct pci_bus * pci_alloc_bus(void)
 	return b;
 }
 
+static struct pci_host_bridge *pci_alloc_host_bridge(struct pci_bus *b)
+{
+	struct pci_host_bridge *bridge;
+
+	bridge = kzalloc(sizeof(*bridge), GFP_KERNEL);
+	if (bridge) {
+		INIT_LIST_HEAD(&bridge->windows);
+		bridge->bus = b;
+	}
+
+	return bridge;
+}
+
 static unsigned char pcix_bus_speed[] = {
 	PCI_SPEED_UNKNOWN,		/* 0 */
 	PCI_SPEED_66MHz_PCIX,		/* 1 */
@@ -1122,7 +1135,13 @@ int pci_cfg_space_size(struct pci_dev *dev)
 
 static void pci_release_bus_bridge_dev(struct device *dev)
 {
-	kfree(dev);
+	struct pci_host_bridge *bridge = to_pci_host_bridge(dev);
+
+	/* TODO: need to free window->res */
+
+	pci_free_resource_list(&bridge->windows);
+
+	kfree(bridge);
 }
 
 struct pci_dev *alloc_pci_dev(void)
@@ -1571,28 +1590,19 @@ struct pci_bus *pci_create_root_bus(struct device *parent, int bus,
 	int error;
 	struct pci_host_bridge *bridge;
 	struct pci_bus *b, *b2;
-	struct device *dev;
 	struct pci_host_bridge_window *window, *n;
 	struct resource *res;
 	resource_size_t offset;
 	char bus_addr[64];
 	char *fmt;
 
-	bridge = kzalloc(sizeof(*bridge), GFP_KERNEL);
-	if (!bridge)
-		return NULL;
 
 	b = pci_alloc_bus();
 	if (!b)
-		goto err_bus;
-
-	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
-	if (!dev)
-		goto err_dev;
+		return NULL;
 
 	b->sysdata = sysdata;
 	b->ops = ops;
-
 	b2 = pci_find_bus(pci_domain_nr(b), bus);
 	if (b2) {
 		/* If we already got to this bus through a different bridge, ignore it */
@@ -1600,13 +1610,17 @@ struct pci_bus *pci_create_root_bus(struct device *parent, int bus,
 		goto err_out;
 	}
 
-	dev->parent = parent;
-	dev->release = pci_release_bus_bridge_dev;
-	dev_set_name(dev, "pci%04x:%02x", pci_domain_nr(b), bus);
-	error = device_register(dev);
+	bridge = pci_alloc_host_bridge(b);
+	if (!bridge)
+		goto err_out;
+
+	bridge->dev.parent = parent;
+	bridge->dev.release = pci_release_bus_bridge_dev;
+	dev_set_name(&bridge->dev, "pci%04x:%02x", pci_domain_nr(b), bus);
+	error = device_register(&bridge->dev);
 	if (error)
-		goto dev_reg_err;
-	b->bridge = get_device(dev);
+		goto bridge_dev_reg_err;
+	b->bridge = get_device(&bridge->dev);
 	device_enable_async_suspend(b->bridge);
 	pci_set_bus_of_node(b);
 
@@ -1625,9 +1639,6 @@ struct pci_bus *pci_create_root_bus(struct device *parent, int bus,
 
 	b->number = b->secondary = bus;
 
-	bridge->bus = b;
-	INIT_LIST_HEAD(&bridge->windows);
-
 	if (parent)
 		dev_info(parent, "PCI host bridge to bus %s\n", dev_name(&b->dev));
 	else
@@ -1653,25 +1664,18 @@ struct pci_bus *pci_create_root_bus(struct device *parent, int bus,
 	}
 
 	down_write(&pci_bus_sem);
-	add_to_pci_host_bridges(bridge);
 	list_add_tail(&b->node, &pci_root_buses);
 	up_write(&pci_bus_sem);
 
 	return b;
 
 class_dev_reg_err:
-	device_unregister(dev);
-dev_reg_err:
-	down_write(&pci_bus_sem);
-	list_del(&bridge->list);
-	list_del(&b->node);
-	up_write(&pci_bus_sem);
+	put_device(&bridge->dev);
+	device_unregister(&bridge->dev);
+bridge_dev_reg_err:
+	kfree(bridge);
 err_out:
-	kfree(dev);
-err_dev:
 	kfree(b);
-err_bus:
-	kfree(bridge);
 	return NULL;
 }
 

commit 610929e119b2166167f4f8fce85408472e77a16a
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Mon Apr 2 18:31:53 2012 -0700

    PCI: move host bridge-related code to host-bridge.c
    
    Move host bridge-related code from probe.c to a new host-bridge.c.
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 5e1ca3c58a7d..bcea52b90e0d 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -15,13 +15,10 @@
 #define CARDBUS_LATENCY_TIMER	176	/* secondary latency timer */
 #define CARDBUS_RESERVE_BUSNR	3
 
-static LIST_HEAD(pci_host_bridges);
-
 /* Ugh.  Need to stop exporting this to modules. */
 LIST_HEAD(pci_root_buses);
 EXPORT_SYMBOL(pci_root_buses);
 
-
 static int find_anything(struct device *dev, void *data)
 {
 	return 1;
@@ -44,82 +41,6 @@ int no_pci_devices(void)
 }
 EXPORT_SYMBOL(no_pci_devices);
 
-static struct pci_host_bridge *pci_host_bridge(struct pci_dev *dev)
-{
-	struct pci_bus *bus;
-	struct pci_host_bridge *bridge;
-
-	bus = dev->bus;
-	while (bus->parent)
-		bus = bus->parent;
-
-	list_for_each_entry(bridge, &pci_host_bridges, list) {
-		if (bridge->bus == bus)
-			return bridge;
-	}
-
-	return NULL;
-}
-
-static bool resource_contains(struct resource *res1, struct resource *res2)
-{
-	return res1->start <= res2->start && res1->end >= res2->end;
-}
-
-void pcibios_resource_to_bus(struct pci_dev *dev, struct pci_bus_region *region,
-			     struct resource *res)
-{
-	struct pci_host_bridge *bridge = pci_host_bridge(dev);
-	struct pci_host_bridge_window *window;
-	resource_size_t offset = 0;
-
-	list_for_each_entry(window, &bridge->windows, list) {
-		if (resource_type(res) != resource_type(window->res))
-			continue;
-
-		if (resource_contains(window->res, res)) {
-			offset = window->offset;
-			break;
-		}
-	}
-
-	region->start = res->start - offset;
-	region->end = res->end - offset;
-}
-EXPORT_SYMBOL(pcibios_resource_to_bus);
-
-static bool region_contains(struct pci_bus_region *region1,
-			    struct pci_bus_region *region2)
-{
-	return region1->start <= region2->start && region1->end >= region2->end;
-}
-
-void pcibios_bus_to_resource(struct pci_dev *dev, struct resource *res,
-			     struct pci_bus_region *region)
-{
-	struct pci_host_bridge *bridge = pci_host_bridge(dev);
-	struct pci_host_bridge_window *window;
-	struct pci_bus_region bus_region;
-	resource_size_t offset = 0;
-
-	list_for_each_entry(window, &bridge->windows, list) {
-		if (resource_type(res) != resource_type(window->res))
-			continue;
-
-		bus_region.start = window->res->start - window->offset;
-		bus_region.end = window->res->end - window->offset;
-
-		if (region_contains(&bus_region, region)) {
-			offset = window->offset;
-			break;
-		}
-	}
-
-	res->start = region->start + offset;
-	res->end = region->end + offset;
-}
-EXPORT_SYMBOL(pcibios_bus_to_resource);
-
 /*
  * PCI Bus Class
  */
@@ -1732,7 +1653,7 @@ struct pci_bus *pci_create_root_bus(struct device *parent, int bus,
 	}
 
 	down_write(&pci_bus_sem);
-	list_add_tail(&bridge->list, &pci_host_bridges);
+	add_to_pci_host_bridges(bridge);
 	list_add_tail(&b->node, &pci_root_buses);
 	up_write(&pci_bus_sem);
 

commit cf48fb6a2bf2e59990e1438d0dedc706df911996
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Mar 16 17:47:59 2012 -0600

    PCI: fix bridge I/O window bus-to-resource conversion
    
    In 5bfa14ed9f3c, I forgot to initialize res2.flags before calling
    pcibios_bus_to_resource(), which depends on the resource type to locate the
    correct aperture.  This bug won't hurt x86, which currently never has an
    offset between bus and CPU addresses, but will affect other architectures.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 944e05a66b97..5e1ca3c58a7d 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -367,6 +367,7 @@ static void __devinit pci_read_bridge_io(struct pci_bus *child)
 
 	if (base && base <= limit) {
 		res->flags = (io_base_lo & PCI_IO_RANGE_TYPE_MASK) | IORESOURCE_IO;
+		res2.flags = res->flags;
 		region.start = base;
 		region.end = limit + 0xfff;
 		pcibios_bus_to_resource(dev, &res2, &region);

commit 2069ecfbe14ebd71a6f98e8a00724e9adf4fe4ee
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Wed Feb 15 21:40:31 2012 -0800

    PCI: Move "pci reassigndev resource alignment" out of quirks.c
    
    This isn't really a quirk; calling it directly from pci_add_device makes
    more sense.
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 36c22032ea14..944e05a66b97 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1325,6 +1325,9 @@ void pci_device_add(struct pci_dev *dev, struct pci_bus *bus)
 	/* Fix up broken headers */
 	pci_fixup_device(pci_fixup_header, dev);
 
+	/* moved out from quirk header fixup code */
+	pci_reassigndev_resource_alignment(dev);
+
 	/* Clear the state_saved flag. */
 	dev->state_saved = false;
 

commit fb127cb9de791d62fb393d6e65fa9869bddd2460
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Feb 23 20:19:04 2012 -0700

    PCI: collapse pcibios_resource_to_bus
    
    Everybody uses the generic pcibios_resource_to_bus() supplied by the core
    now, so remove the ARCH_HAS_GENERIC_PCI_OFFSETS used during conversion.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index a677b1e995de..36c22032ea14 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -66,8 +66,8 @@ static bool resource_contains(struct resource *res1, struct resource *res2)
 	return res1->start <= res2->start && res1->end >= res2->end;
 }
 
-void pci_resource_to_bus(struct pci_dev *dev, struct pci_bus_region *region,
-			struct resource *res)
+void pcibios_resource_to_bus(struct pci_dev *dev, struct pci_bus_region *region,
+			     struct resource *res)
 {
 	struct pci_host_bridge *bridge = pci_host_bridge(dev);
 	struct pci_host_bridge_window *window;
@@ -86,6 +86,7 @@ void pci_resource_to_bus(struct pci_dev *dev, struct pci_bus_region *region,
 	region->start = res->start - offset;
 	region->end = res->end - offset;
 }
+EXPORT_SYMBOL(pcibios_resource_to_bus);
 
 static bool region_contains(struct pci_bus_region *region1,
 			    struct pci_bus_region *region2)
@@ -93,8 +94,8 @@ static bool region_contains(struct pci_bus_region *region1,
 	return region1->start <= region2->start && region1->end >= region2->end;
 }
 
-void pci_bus_to_resource(struct pci_dev *dev, struct resource *res,
-			 struct pci_bus_region *region)
+void pcibios_bus_to_resource(struct pci_dev *dev, struct resource *res,
+			     struct pci_bus_region *region)
 {
 	struct pci_host_bridge *bridge = pci_host_bridge(dev);
 	struct pci_host_bridge_window *window;
@@ -117,22 +118,7 @@ void pci_bus_to_resource(struct pci_dev *dev, struct resource *res,
 	res->start = region->start + offset;
 	res->end = region->end + offset;
 }
-
-#ifdef ARCH_HAS_GENERIC_PCI_OFFSETS
-void pcibios_resource_to_bus(struct pci_dev *dev, struct pci_bus_region *region,
-			     struct resource *res)
-{
-	pci_resource_to_bus(dev, region, res);
-}
-EXPORT_SYMBOL(pcibios_resource_to_bus);
-
-void pcibios_bus_to_resource(struct pci_dev *dev, struct resource *res,
-			     struct pci_bus_region *region)
-{
-	pci_bus_to_resource(dev, res, region);
-}
 EXPORT_SYMBOL(pcibios_bus_to_resource);
-#endif
 
 /*
  * PCI Bus Class
@@ -309,11 +295,11 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 			pci_write_config_dword(dev, pos + 4, 0);
 			region.start = 0;
 			region.end = sz64;
-			pci_bus_to_resource(dev, res, &region);
+			pcibios_bus_to_resource(dev, res, &region);
 		} else {
 			region.start = l64;
 			region.end = l64 + sz64;
-			pci_bus_to_resource(dev, res, &region);
+			pcibios_bus_to_resource(dev, res, &region);
 			dev_printk(KERN_DEBUG, &dev->dev, "reg %x: %pR\n",
 				   pos, res);
 		}
@@ -325,7 +311,7 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 
 		region.start = l;
 		region.end = l + sz;
-		pci_bus_to_resource(dev, res, &region);
+		pcibios_bus_to_resource(dev, res, &region);
 
 		dev_printk(KERN_DEBUG, &dev->dev, "reg %x: %pR\n", pos, res);
 	}
@@ -383,7 +369,7 @@ static void __devinit pci_read_bridge_io(struct pci_bus *child)
 		res->flags = (io_base_lo & PCI_IO_RANGE_TYPE_MASK) | IORESOURCE_IO;
 		region.start = base;
 		region.end = limit + 0xfff;
-		pci_bus_to_resource(dev, &res2, &region);
+		pcibios_bus_to_resource(dev, &res2, &region);
 		if (!res->start)
 			res->start = res2.start;
 		if (!res->end)
@@ -409,7 +395,7 @@ static void __devinit pci_read_bridge_mmio(struct pci_bus *child)
 		res->flags = (mem_base_lo & PCI_MEMORY_RANGE_TYPE_MASK) | IORESOURCE_MEM;
 		region.start = base;
 		region.end = limit + 0xfffff;
-		pci_bus_to_resource(dev, res, &region);
+		pcibios_bus_to_resource(dev, res, &region);
 		dev_printk(KERN_DEBUG, &dev->dev, "  bridge window %pR\n", res);
 	}
 }
@@ -458,7 +444,7 @@ static void __devinit pci_read_bridge_mmio_pref(struct pci_bus *child)
 			res->flags |= IORESOURCE_MEM_64;
 		region.start = base;
 		region.end = limit + 0xfffff;
-		pci_bus_to_resource(dev, res, &region);
+		pcibios_bus_to_resource(dev, res, &region);
 		dev_printk(KERN_DEBUG, &dev->dev, "  bridge window %pR\n", res);
 	}
 }
@@ -1071,24 +1057,24 @@ int pci_setup_device(struct pci_dev *dev)
 				region.end = 0x1F7;
 				res = &dev->resource[0];
 				res->flags = LEGACY_IO_RESOURCE;
-				pci_bus_to_resource(dev, res, &region);
+				pcibios_bus_to_resource(dev, res, &region);
 				region.start = 0x3F6;
 				region.end = 0x3F6;
 				res = &dev->resource[1];
 				res->flags = LEGACY_IO_RESOURCE;
-				pci_bus_to_resource(dev, res, &region);
+				pcibios_bus_to_resource(dev, res, &region);
 			}
 			if ((progif & 4) == 0) {
 				region.start = 0x170;
 				region.end = 0x177;
 				res = &dev->resource[2];
 				res->flags = LEGACY_IO_RESOURCE;
-				pci_bus_to_resource(dev, res, &region);
+				pcibios_bus_to_resource(dev, res, &region);
 				region.start = 0x376;
 				region.end = 0x376;
 				res = &dev->resource[3];
 				res->flags = LEGACY_IO_RESOURCE;
-				pci_bus_to_resource(dev, res, &region);
+				pcibios_bus_to_resource(dev, res, &region);
 			}
 		}
 		break;

commit 36a66cd6fd0a70ac6848d740d9cf7a4360b5776a
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Feb 23 20:19:00 2012 -0700

    PCI: add generic pcibios_resource_to_bus()
    
    This replaces the generic versions of pcibios_resource_to_bus() and
    pcibios_bus_to_resource() in asm-generic/pci.h with versions that use
    pci_resource_to_bus() and pci_bus_to_resource().
    
    The replacements are equivalent except that they can apply host
    bridge window offsets when the arch has supplied them by using
    pci_add_resource_offset().
    
    Each arch can convert to using pci_add_resource_offset() individually by
    removing its device resource fixups from pcibios_fixup_bus() and supplying
    ARCH_HAS_GENERIC_PCI_OFFSETS.  ARCH_HAS_GENERIC_PCI_OFFSETS can be removed
    after all have converted.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 3539171d8a98..a677b1e995de 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -118,6 +118,22 @@ void pci_bus_to_resource(struct pci_dev *dev, struct resource *res,
 	res->end = region->end + offset;
 }
 
+#ifdef ARCH_HAS_GENERIC_PCI_OFFSETS
+void pcibios_resource_to_bus(struct pci_dev *dev, struct pci_bus_region *region,
+			     struct resource *res)
+{
+	pci_resource_to_bus(dev, region, res);
+}
+EXPORT_SYMBOL(pcibios_resource_to_bus);
+
+void pcibios_bus_to_resource(struct pci_dev *dev, struct resource *res,
+			     struct pci_bus_region *region)
+{
+	pci_bus_to_resource(dev, res, region);
+}
+EXPORT_SYMBOL(pcibios_bus_to_resource);
+#endif
+
 /*
  * PCI Bus Class
  */

commit 5bfa14ed9f3ca21fcecbcfbf4a848c002b740c41
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Feb 23 20:19:00 2012 -0700

    PCI: convert bus addresses to resource when reading BARs
    
    Some PCI host bridges translate CPU addresses to PCI bus addresses.
    Previously, we initialized pci_dev resources with PCI bus addresses,
    then converted them to CPU addresses later in arch-specific code
    (pcibios_fixup_resources()), which leaves a window of time where the
    pci_dev resources are incorrect.
    
    This patch adds support in the core for this address translation.
    When the arch creates the root bus, it can supply the host bridge
    address translation information, and the core can use it to set the
    pci_dev resources correctly from the beginning.
    
    This gives us a way to fix the problem that quirks that run between device
    discovery and pcibios_fixup_resources() fail because they use pci_dev
    resources that haven't been converted.  The reference below is to one
    such problem that affected ARM and ia64.
    
    Note that this patch has no effect until an arch starts using
    pci_add_resource_offset() with a non-zero offset: before that, all
    all host bridge windows have a zero offset and pci_bus_to_resource()
    copies the pci_bus_region directly to the struct resource.
    
    Reference: https://lkml.org/lkml/2009/10/12/405
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 3f07cb6bae32..3539171d8a98 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -61,6 +61,63 @@ static struct pci_host_bridge *pci_host_bridge(struct pci_dev *dev)
 	return NULL;
 }
 
+static bool resource_contains(struct resource *res1, struct resource *res2)
+{
+	return res1->start <= res2->start && res1->end >= res2->end;
+}
+
+void pci_resource_to_bus(struct pci_dev *dev, struct pci_bus_region *region,
+			struct resource *res)
+{
+	struct pci_host_bridge *bridge = pci_host_bridge(dev);
+	struct pci_host_bridge_window *window;
+	resource_size_t offset = 0;
+
+	list_for_each_entry(window, &bridge->windows, list) {
+		if (resource_type(res) != resource_type(window->res))
+			continue;
+
+		if (resource_contains(window->res, res)) {
+			offset = window->offset;
+			break;
+		}
+	}
+
+	region->start = res->start - offset;
+	region->end = res->end - offset;
+}
+
+static bool region_contains(struct pci_bus_region *region1,
+			    struct pci_bus_region *region2)
+{
+	return region1->start <= region2->start && region1->end >= region2->end;
+}
+
+void pci_bus_to_resource(struct pci_dev *dev, struct resource *res,
+			 struct pci_bus_region *region)
+{
+	struct pci_host_bridge *bridge = pci_host_bridge(dev);
+	struct pci_host_bridge_window *window;
+	struct pci_bus_region bus_region;
+	resource_size_t offset = 0;
+
+	list_for_each_entry(window, &bridge->windows, list) {
+		if (resource_type(res) != resource_type(window->res))
+			continue;
+
+		bus_region.start = window->res->start - window->offset;
+		bus_region.end = window->res->end - window->offset;
+
+		if (region_contains(&bus_region, region)) {
+			offset = window->offset;
+			break;
+		}
+	}
+
+	res->start = region->start + offset;
+	res->end = region->end + offset;
+}
+
 /*
  * PCI Bus Class
  */
@@ -154,6 +211,7 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 {
 	u32 l, sz, mask;
 	u16 orig_cmd;
+	struct pci_bus_region region;
 
 	mask = type ? PCI_ROM_ADDRESS_MASK : ~0;
 
@@ -233,11 +291,13 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 			/* Address above 32-bit boundary; disable the BAR */
 			pci_write_config_dword(dev, pos, 0);
 			pci_write_config_dword(dev, pos + 4, 0);
-			res->start = 0;
-			res->end = sz64;
+			region.start = 0;
+			region.end = sz64;
+			pci_bus_to_resource(dev, res, &region);
 		} else {
-			res->start = l64;
-			res->end = l64 + sz64;
+			region.start = l64;
+			region.end = l64 + sz64;
+			pci_bus_to_resource(dev, res, &region);
 			dev_printk(KERN_DEBUG, &dev->dev, "reg %x: %pR\n",
 				   pos, res);
 		}
@@ -247,8 +307,9 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 		if (!sz)
 			goto fail;
 
-		res->start = l;
-		res->end = l + sz;
+		region.start = l;
+		region.end = l + sz;
+		pci_bus_to_resource(dev, res, &region);
 
 		dev_printk(KERN_DEBUG, &dev->dev, "reg %x: %pR\n", pos, res);
 	}
@@ -285,7 +346,8 @@ static void __devinit pci_read_bridge_io(struct pci_bus *child)
 	struct pci_dev *dev = child->self;
 	u8 io_base_lo, io_limit_lo;
 	unsigned long base, limit;
-	struct resource *res;
+	struct pci_bus_region region;
+	struct resource *res, res2;
 
 	res = child->resource[0];
 	pci_read_config_byte(dev, PCI_IO_BASE, &io_base_lo);
@@ -303,10 +365,13 @@ static void __devinit pci_read_bridge_io(struct pci_bus *child)
 
 	if (base && base <= limit) {
 		res->flags = (io_base_lo & PCI_IO_RANGE_TYPE_MASK) | IORESOURCE_IO;
+		region.start = base;
+		region.end = limit + 0xfff;
+		pci_bus_to_resource(dev, &res2, &region);
 		if (!res->start)
-			res->start = base;
+			res->start = res2.start;
 		if (!res->end)
-			res->end = limit + 0xfff;
+			res->end = res2.end;
 		dev_printk(KERN_DEBUG, &dev->dev, "  bridge window %pR\n", res);
 	}
 }
@@ -316,6 +381,7 @@ static void __devinit pci_read_bridge_mmio(struct pci_bus *child)
 	struct pci_dev *dev = child->self;
 	u16 mem_base_lo, mem_limit_lo;
 	unsigned long base, limit;
+	struct pci_bus_region region;
 	struct resource *res;
 
 	res = child->resource[1];
@@ -325,8 +391,9 @@ static void __devinit pci_read_bridge_mmio(struct pci_bus *child)
 	limit = (mem_limit_lo & PCI_MEMORY_RANGE_MASK) << 16;
 	if (base && base <= limit) {
 		res->flags = (mem_base_lo & PCI_MEMORY_RANGE_TYPE_MASK) | IORESOURCE_MEM;
-		res->start = base;
-		res->end = limit + 0xfffff;
+		region.start = base;
+		region.end = limit + 0xfffff;
+		pci_bus_to_resource(dev, res, &region);
 		dev_printk(KERN_DEBUG, &dev->dev, "  bridge window %pR\n", res);
 	}
 }
@@ -336,6 +403,7 @@ static void __devinit pci_read_bridge_mmio_pref(struct pci_bus *child)
 	struct pci_dev *dev = child->self;
 	u16 mem_base_lo, mem_limit_lo;
 	unsigned long base, limit;
+	struct pci_bus_region region;
 	struct resource *res;
 
 	res = child->resource[2];
@@ -372,8 +440,9 @@ static void __devinit pci_read_bridge_mmio_pref(struct pci_bus *child)
 					 IORESOURCE_MEM | IORESOURCE_PREFETCH;
 		if (res->flags & PCI_PREF_RANGE_TYPE_64)
 			res->flags |= IORESOURCE_MEM_64;
-		res->start = base;
-		res->end = limit + 0xfffff;
+		region.start = base;
+		region.end = limit + 0xfffff;
+		pci_bus_to_resource(dev, res, &region);
 		dev_printk(KERN_DEBUG, &dev->dev, "  bridge window %pR\n", res);
 	}
 }
@@ -919,6 +988,8 @@ int pci_setup_device(struct pci_dev *dev)
 	u8 hdr_type;
 	struct pci_slot *slot;
 	int pos = 0;
+	struct pci_bus_region region;
+	struct resource *res;
 
 	if (pci_read_config_byte(dev, PCI_HEADER_TYPE, &hdr_type))
 		return -EIO;
@@ -980,20 +1051,28 @@ int pci_setup_device(struct pci_dev *dev)
 			u8 progif;
 			pci_read_config_byte(dev, PCI_CLASS_PROG, &progif);
 			if ((progif & 1) == 0) {
-				dev->resource[0].start = 0x1F0;
-				dev->resource[0].end = 0x1F7;
-				dev->resource[0].flags = LEGACY_IO_RESOURCE;
-				dev->resource[1].start = 0x3F6;
-				dev->resource[1].end = 0x3F6;
-				dev->resource[1].flags = LEGACY_IO_RESOURCE;
+				region.start = 0x1F0;
+				region.end = 0x1F7;
+				res = &dev->resource[0];
+				res->flags = LEGACY_IO_RESOURCE;
+				pci_bus_to_resource(dev, res, &region);
+				region.start = 0x3F6;
+				region.end = 0x3F6;
+				res = &dev->resource[1];
+				res->flags = LEGACY_IO_RESOURCE;
+				pci_bus_to_resource(dev, res, &region);
 			}
 			if ((progif & 4) == 0) {
-				dev->resource[2].start = 0x170;
-				dev->resource[2].end = 0x177;
-				dev->resource[2].flags = LEGACY_IO_RESOURCE;
-				dev->resource[3].start = 0x376;
-				dev->resource[3].end = 0x376;
-				dev->resource[3].flags = LEGACY_IO_RESOURCE;
+				region.start = 0x170;
+				region.end = 0x177;
+				res = &dev->resource[2];
+				res->flags = LEGACY_IO_RESOURCE;
+				pci_bus_to_resource(dev, res, &region);
+				region.start = 0x376;
+				region.end = 0x376;
+				res = &dev->resource[3];
+				res->flags = LEGACY_IO_RESOURCE;
+				pci_bus_to_resource(dev, res, &region);
 			}
 		}
 		break;

commit 0efd5aab41e18a1175f72641696cfda154ba6c87
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Feb 23 20:19:00 2012 -0700

    PCI: add struct pci_host_bridge_window with CPU/bus address offset
    
    Some PCI host bridges apply an address offset, so bus addresses on PCI are
    different from CPU addresses.  This patch adds a way for architectures to
    tell the PCI core about this offset.  For example:
    
        LIST_HEAD(resources);
        pci_add_resource_offset(&resources, host->io_space, host->io_offset);
        pci_add_resource_offset(&resources, host->mem_space, host->mem_offset);
        pci_scan_root_bus(parent, bus, ops, sysdata, &resources);
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 3a30023a123c..3f07cb6bae32 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1562,12 +1562,15 @@ unsigned int __devinit pci_scan_child_bus(struct pci_bus *bus)
 struct pci_bus *pci_create_root_bus(struct device *parent, int bus,
 		struct pci_ops *ops, void *sysdata, struct list_head *resources)
 {
-	int error, i;
+	int error;
 	struct pci_host_bridge *bridge;
 	struct pci_bus *b, *b2;
 	struct device *dev;
-	struct pci_bus_resource *bus_res, *n;
+	struct pci_host_bridge_window *window, *n;
 	struct resource *res;
+	resource_size_t offset;
+	char bus_addr[64];
+	char *fmt;
 
 	bridge = kzalloc(sizeof(*bridge), GFP_KERNEL);
 	if (!bridge)
@@ -1617,19 +1620,30 @@ struct pci_bus *pci_create_root_bus(struct device *parent, int bus,
 	b->number = b->secondary = bus;
 
 	bridge->bus = b;
-
-	/* Add initial resources to the bus */
-	list_for_each_entry_safe(bus_res, n, resources, list)
-		list_move_tail(&bus_res->list, &b->resources);
+	INIT_LIST_HEAD(&bridge->windows);
 
 	if (parent)
 		dev_info(parent, "PCI host bridge to bus %s\n", dev_name(&b->dev));
 	else
 		printk(KERN_INFO "PCI host bridge to bus %s\n", dev_name(&b->dev));
 
-	pci_bus_for_each_resource(b, res, i) {
-		if (res)
-			dev_info(&b->dev, "root bus resource %pR\n", res);
+	/* Add initial resources to the bus */
+	list_for_each_entry_safe(window, n, resources, list) {
+		list_move_tail(&window->list, &bridge->windows);
+		res = window->res;
+		offset = window->offset;
+		pci_bus_add_resource(b, res, 0);
+		if (offset) {
+			if (resource_type(res) == IORESOURCE_IO)
+				fmt = " (bus address [%#06llx-%#06llx])";
+			else
+				fmt = " (bus address [%#010llx-%#010llx])";
+			snprintf(bus_addr, sizeof(bus_addr), fmt,
+				 (unsigned long long) (res->start - offset),
+				 (unsigned long long) (res->end - offset));
+		} else
+			bus_addr[0] = '\0';
+		dev_info(&b->dev, "root bus resource %pR%s\n", res, bus_addr);
 	}
 
 	down_write(&pci_bus_sem);

commit 5a21d70dbd33d20713fb735ad9381711b0ae2c9b
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Feb 23 20:18:59 2012 -0700

    PCI: add struct pci_host_bridge and a list of all bridges found
    
    This adds a list of all PCI host bridges we find and a way to look up
    the host bridge from a pci_dev.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index e4c0d1c6324d..3a30023a123c 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -15,6 +15,8 @@
 #define CARDBUS_LATENCY_TIMER	176	/* secondary latency timer */
 #define CARDBUS_RESERVE_BUSNR	3
 
+static LIST_HEAD(pci_host_bridges);
+
 /* Ugh.  Need to stop exporting this to modules. */
 LIST_HEAD(pci_root_buses);
 EXPORT_SYMBOL(pci_root_buses);
@@ -42,6 +44,23 @@ int no_pci_devices(void)
 }
 EXPORT_SYMBOL(no_pci_devices);
 
+static struct pci_host_bridge *pci_host_bridge(struct pci_dev *dev)
+{
+	struct pci_bus *bus;
+	struct pci_host_bridge *bridge;
+
+	bus = dev->bus;
+	while (bus->parent)
+		bus = bus->parent;
+
+	list_for_each_entry(bridge, &pci_host_bridges, list) {
+		if (bridge->bus == bus)
+			return bridge;
+	}
+
+	return NULL;
+}
+
 /*
  * PCI Bus Class
  */
@@ -1544,20 +1563,23 @@ struct pci_bus *pci_create_root_bus(struct device *parent, int bus,
 		struct pci_ops *ops, void *sysdata, struct list_head *resources)
 {
 	int error, i;
+	struct pci_host_bridge *bridge;
 	struct pci_bus *b, *b2;
 	struct device *dev;
 	struct pci_bus_resource *bus_res, *n;
 	struct resource *res;
 
+	bridge = kzalloc(sizeof(*bridge), GFP_KERNEL);
+	if (!bridge)
+		return NULL;
+
 	b = pci_alloc_bus();
 	if (!b)
-		return NULL;
+		goto err_bus;
 
 	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
-	if (!dev) {
-		kfree(b);
-		return NULL;
-	}
+	if (!dev)
+		goto err_dev;
 
 	b->sysdata = sysdata;
 	b->ops = ops;
@@ -1594,6 +1616,8 @@ struct pci_bus *pci_create_root_bus(struct device *parent, int bus,
 
 	b->number = b->secondary = bus;
 
+	bridge->bus = b;
+
 	/* Add initial resources to the bus */
 	list_for_each_entry_safe(bus_res, n, resources, list)
 		list_move_tail(&bus_res->list, &b->resources);
@@ -1609,6 +1633,7 @@ struct pci_bus *pci_create_root_bus(struct device *parent, int bus,
 	}
 
 	down_write(&pci_bus_sem);
+	list_add_tail(&bridge->list, &pci_host_bridges);
 	list_add_tail(&b->node, &pci_root_buses);
 	up_write(&pci_bus_sem);
 
@@ -1618,11 +1643,15 @@ struct pci_bus *pci_create_root_bus(struct device *parent, int bus,
 	device_unregister(dev);
 dev_reg_err:
 	down_write(&pci_bus_sem);
+	list_del(&bridge->list);
 	list_del(&b->node);
 	up_write(&pci_bus_sem);
 err_out:
 	kfree(dev);
+err_dev:
 	kfree(b);
+err_bus:
+	kfree(bridge);
 	return NULL;
 }
 

commit a5390aa6dc3646b08bed421944cef0daf78ab994
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Feb 23 20:18:59 2012 -0700

    PCI: don't publish new root bus until it's fully initialized
    
    When pci_create_root_bus() adds the new struct pci_bus to the global
    pci_root_buses list, the bus becomes visible to other parts of the
    kernel, so it should be fully initialized.
    
    This patch delays adding the bus to the pci_root_buses list until after
    all the struct pci_bus initialization is finished.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index dc904bd4b569..e4c0d1c6324d 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1569,10 +1569,6 @@ struct pci_bus *pci_create_root_bus(struct device *parent, int bus,
 		goto err_out;
 	}
 
-	down_write(&pci_bus_sem);
-	list_add_tail(&b->node, &pci_root_buses);
-	up_write(&pci_bus_sem);
-
 	dev->parent = parent;
 	dev->release = pci_release_bus_bridge_dev;
 	dev_set_name(dev, "pci%04x:%02x", pci_domain_nr(b), bus);
@@ -1612,6 +1608,10 @@ struct pci_bus *pci_create_root_bus(struct device *parent, int bus,
 			dev_info(&b->dev, "root bus resource %pR\n", res);
 	}
 
+	down_write(&pci_bus_sem);
+	list_add_tail(&b->node, &pci_root_buses);
+	up_write(&pci_bus_sem);
+
 	return b;
 
 class_dev_reg_err:

commit f796841e49fe086176e27ed0e1f3f7a1123a4a6b
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Sat Feb 11 00:18:30 2012 -0800

    PCI: fix memleak for pci dev removing during hotplug
    
    unreferenced object 0xffff880276d17700 (size 64):
      comm "swapper/0", pid 1, jiffies 4294897182 (age 3976.028s)
      hex dump (first 32 bytes):
        00 00 00 00 00 00 00 00 18 f9 de 76 02 88 ff ff  ...........v....
        10 00 00 00 0e 00 00 00 0f 28 40 00 00 00 00 00  .........(@.....
      backtrace:
        [<ffffffff81c8aede>] kmemleak_alloc+0x26/0x43
        [<ffffffff811385f0>] __kmalloc+0x121/0x183
        [<ffffffff813cf821>] pci_add_cap_save_buffer+0x35/0x7c
        [<ffffffff813d12b7>] pci_allocate_cap_save_buffers+0x1d/0x65
        [<ffffffff813cdb52>] pci_device_add+0x92/0xf1
        [<ffffffff81c8afe6>] pci_scan_single_device+0x9f/0xa1
        [<ffffffff813cdbd2>] pci_scan_slot.part.20+0x21/0x106
        [<ffffffff813cdce2>] pci_scan_slot+0x2b/0x35
        [<ffffffff81c8dae4>] __pci_scan_child_bus+0x51/0x107
        [<ffffffff81c8d75b>] pci_scan_bridge+0x376/0x6ae
        [<ffffffff81c8db60>] __pci_scan_child_bus+0xcd/0x107
        [<ffffffff81c8dbab>] pci_scan_child_bus+0x11/0x2a
        [<ffffffff81cca58c>] pci_acpi_scan_root+0x18b/0x21c
        [<ffffffff81c916be>] acpi_pci_root_add+0x1e1/0x42a
        [<ffffffff81406210>] acpi_device_probe+0x50/0x190
        [<ffffffff814a0227>] really_probe+0x99/0x126
    
    Need to free saved_buffer for capabilities.
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index aa9b1dec0d3e..dc904bd4b569 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1024,6 +1024,7 @@ static void pci_release_capabilities(struct pci_dev *dev)
 {
 	pci_vpd_release(dev);
 	pci_iov_release(dev);
+	pci_free_cap_save_buffers(dev);
 }
 
 /**

commit 2dd8ba921d570fcd016f8038c63fa9668892d16b
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Sun Feb 19 14:50:12 2012 -0800

    PCI: Fix device class print out
    
    Found debug print of class is shifted.
    
    | pci 0000:f8:15.2: [8086:2b56] type 0 class 0x000600
    
    Code is trying to print class with 6 digits, but use shifted class with
    4 digits valid value as variable.
    
    Change to original dev->class directly.
    
    Also remove not needed calculating of local variable class, because it
    will be updated after pci_fixup_device(pci_fixup_early...)
    
    Also unify type print out when class and header is not matched.
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 9f2ff8c5dc2f..aa9b1dec0d3e 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -926,12 +926,10 @@ int pci_setup_device(struct pci_dev *dev)
 
 	pci_read_config_dword(dev, PCI_CLASS_REVISION, &class);
 	dev->revision = class & 0xff;
-	class >>= 8;				    /* upper 3 bytes */
-	dev->class = class;
-	class >>= 8;
+	dev->class = class >> 8;		    /* upper 3 bytes */
 
-	dev_printk(KERN_DEBUG, &dev->dev, "[%04x:%04x] type %d class %#08x\n",
-		   dev->vendor, dev->device, dev->hdr_type, class);
+	dev_printk(KERN_DEBUG, &dev->dev, "[%04x:%04x] type %02x class %#08x\n",
+		   dev->vendor, dev->device, dev->hdr_type, dev->class);
 
 	/* need to have dev->class ready */
 	dev->cfg_size = pci_cfg_space_size(dev);
@@ -1013,8 +1011,8 @@ int pci_setup_device(struct pci_dev *dev)
 		return -EIO;
 
 	bad:
-		dev_err(&dev->dev, "ignoring class %02x (doesn't match header "
-			"type %02x)\n", class, dev->hdr_type);
+		dev_err(&dev->dev, "ignoring class %#08x (doesn't match header "
+			"type %02x)\n", dev->class, dev->hdr_type);
 		dev->class = PCI_CLASS_NOT_DEFINED;
 	}
 

commit efdc87dab1cdf25ba631181ac0ead3fb2023dd10
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Fri Jan 27 10:55:10 2012 -0800

    PCI: Separate pci_bus_read_dev_vendor_id from pci_scan_device
    
    We can reuse it for pciehp probing.
    
    -v2: according to Kenji, fix crs timeout checking, and export the function
         for later use when pciehp is compiled as a module.
    
    Suggested-by: Matthew Wilcox <matthew@wil.cx>
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index aad7d0ff6b08..9f2ff8c5dc2f 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1118,40 +1118,54 @@ struct pci_dev *alloc_pci_dev(void)
 }
 EXPORT_SYMBOL(alloc_pci_dev);
 
-/*
- * Read the config data for a PCI device, sanity-check it
- * and fill in the dev structure...
- */
-static struct pci_dev *pci_scan_device(struct pci_bus *bus, int devfn)
+bool pci_bus_read_dev_vendor_id(struct pci_bus *bus, int devfn, u32 *l,
+				 int crs_timeout)
 {
-	struct pci_dev *dev;
-	u32 l;
 	int delay = 1;
 
-	if (pci_bus_read_config_dword(bus, devfn, PCI_VENDOR_ID, &l))
-		return NULL;
+	if (pci_bus_read_config_dword(bus, devfn, PCI_VENDOR_ID, l))
+		return false;
 
 	/* some broken boards return 0 or ~0 if a slot is empty: */
-	if (l == 0xffffffff || l == 0x00000000 ||
-	    l == 0x0000ffff || l == 0xffff0000)
-		return NULL;
+	if (*l == 0xffffffff || *l == 0x00000000 ||
+	    *l == 0x0000ffff || *l == 0xffff0000)
+		return false;
 
 	/* Configuration request Retry Status */
-	while (l == 0xffff0001) {
+	while (*l == 0xffff0001) {
+		if (!crs_timeout)
+			return false;
+
 		msleep(delay);
 		delay *= 2;
-		if (pci_bus_read_config_dword(bus, devfn, PCI_VENDOR_ID, &l))
-			return NULL;
+		if (pci_bus_read_config_dword(bus, devfn, PCI_VENDOR_ID, l))
+			return false;
 		/* Card hasn't responded in 60 seconds?  Must be stuck. */
-		if (delay > 60 * 1000) {
+		if (delay > crs_timeout) {
 			printk(KERN_WARNING "pci %04x:%02x:%02x.%d: not "
 					"responding\n", pci_domain_nr(bus),
 					bus->number, PCI_SLOT(devfn),
 					PCI_FUNC(devfn));
-			return NULL;
+			return false;
 		}
 	}
 
+	return true;
+}
+EXPORT_SYMBOL(pci_bus_read_dev_vendor_id);
+
+/*
+ * Read the config data for a PCI device, sanity-check it
+ * and fill in the dev structure...
+ */
+static struct pci_dev *pci_scan_device(struct pci_bus *bus, int devfn)
+{
+	struct pci_dev *dev;
+	u32 l;
+
+	if (!pci_bus_read_dev_vendor_id(bus, devfn, &l, 60*1000))
+		return NULL;
+
 	dev = alloc_pci_dev();
 	if (!dev)
 		return NULL;

commit 9b03088f955552299f50a1f660372698b07ab339
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Sat Jan 21 02:08:23 2012 -0800

    PCI: Make pci_rescan_bus handle add_list
    
    This allows us to allocate resources to hotplug bridges during
    remove/rescan.
    
    We need to move the function to setup-bus.c so it can use
    __pci_bus_size_bridges and __pci_bus_assign_resources directly to take
    the add_list resource tracking list.
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 0e84e8c2a6d0..aad7d0ff6b08 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1691,38 +1691,6 @@ unsigned int __ref pci_rescan_bus_bridge_resize(struct pci_dev *bridge)
 	return max;
 }
 
-/**
- * pci_rescan_bus - scan a PCI bus for devices.
- * @bus: PCI bus to scan
- *
- * Scan a PCI bus and child buses for new devices, adds them,
- * and enables them.
- *
- * Returns the max number of subordinate bus discovered.
- */
-unsigned int __ref pci_rescan_bus(struct pci_bus *bus)
-{
-	unsigned int max;
-	struct pci_dev *dev;
-
-	max = pci_scan_child_bus(bus);
-
-	down_read(&pci_bus_sem);
-	list_for_each_entry(dev, &bus->devices, bus_list)
-		if (dev->hdr_type == PCI_HEADER_TYPE_BRIDGE ||
-		    dev->hdr_type == PCI_HEADER_TYPE_CARDBUS)
-			if (dev->subordinate)
-				pci_bus_size_bridges(dev->subordinate);
-	up_read(&pci_bus_sem);
-
-	pci_bus_assign_resources(bus);
-	pci_enable_bridges(bus);
-	pci_bus_add_devices(bus);
-
-	return max;
-}
-EXPORT_SYMBOL_GPL(pci_rescan_bus);
-
 EXPORT_SYMBOL(pci_add_new_bus);
 EXPORT_SYMBOL(pci_scan_slot);
 EXPORT_SYMBOL(pci_scan_bridge);

commit 2f320521a0d2d11fb857be09d05e2fbbf3ef8c13
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Sat Jan 21 02:08:22 2012 -0800

    PCI: Make rescan bus increase bridge resource size if needed
    
    Current rescan will not touch bridge MMIO and IO.
    
    Try to reuse pci_assign_unassigned_bridge_resources(bridge) to update bridge
    resources, if child devices need more resources.
    
    Only do that for bridges whose children are all removed already; i.e. don't
    release resources that could already be in use by drivers on child devices.
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 71eac9cd724d..0e84e8c2a6d0 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1666,6 +1666,31 @@ struct pci_bus * __devinit pci_scan_bus(int bus, struct pci_ops *ops,
 EXPORT_SYMBOL(pci_scan_bus);
 
 #ifdef CONFIG_HOTPLUG
+/**
+ * pci_rescan_bus_bridge_resize - scan a PCI bus for devices.
+ * @bridge: PCI bridge for the bus to scan
+ *
+ * Scan a PCI bus and child buses for new devices, add them,
+ * and enable them, resizing bridge mmio/io resource if necessary
+ * and possible.  The caller must ensure the child devices are already
+ * removed for resizing to occur.
+ *
+ * Returns the max number of subordinate bus discovered.
+ */
+unsigned int __ref pci_rescan_bus_bridge_resize(struct pci_dev *bridge)
+{
+	unsigned int max;
+	struct pci_bus *bus = bridge->subordinate;
+
+	max = pci_scan_child_bus(bus);
+
+	pci_assign_unassigned_bridge_resources(bridge);
+
+	pci_bus_add_devices(bus);
+
+	return max;
+}
+
 /**
  * pci_rescan_bus - scan a PCI bus for devices.
  * @bus: PCI bus to scan

commit 71f6bd4a23130cd2f4b036010c5790b1295290b9
Author: Yinghai Lu <yinghai.lu@oracle.com>
Date:   Mon Jan 30 12:25:24 2012 +0100

    PCI: workaround hard-wired bus number V2
    
    Fixes PCI device detection on IBM xSeries IBM 3850 M2 / x3950 M2
    when using ACPI resources (_CRS).
    This is default, a manual workaround (without this patch)
    would be pci=nocrs boot param.
    
    V2: Add dev_warn if the workaround is hit. This should reveal
    how common such setups are (via google) and point to possible
    problems if things are still not working as expected.
    -> Suggested by Jan Beulich.
    
    Cc: stable@vger.kernel.org
    Tested-by: garyhade@us.ibm.com
    Signed-off-by: Yinghai Lu <yinghai.lu@oracle.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 7cc9e2f0f47c..71eac9cd724d 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -651,6 +651,11 @@ int __devinit pci_scan_bridge(struct pci_bus *bus, struct pci_dev *dev, int max,
 	dev_dbg(&dev->dev, "scanning [bus %02x-%02x] behind bridge, pass %d\n",
 		secondary, subordinate, pass);
 
+	if (!primary && (primary != bus->number) && secondary && subordinate) {
+		dev_warn(&dev->dev, "Primary bus is hard wired to 0\n");
+		primary = bus->number;
+	}
+
 	/* Check if setup is sensible at all */
 	if (!pass &&
 	    (primary != bus->number || secondary <= bus->number)) {

commit 118faafaf987f521832843d36c6be580983f9a6b
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Oct 28 16:28:24 2011 -0600

    PCI: remove pci_create_bus()
    
    All users of pci_create_bus() have been converted to pci_create_root_bus(),
    so remove it.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 944ea2170f48..7cc9e2f0f47c 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1623,20 +1623,6 @@ struct pci_bus * __devinit pci_scan_root_bus(struct device *parent, int bus,
 }
 EXPORT_SYMBOL(pci_scan_root_bus);
 
-struct pci_bus *pci_create_bus(struct device *parent,
-		int bus, struct pci_ops *ops, void *sysdata)
-{
-	LIST_HEAD(resources);
-	struct pci_bus *b;
-
-	pci_add_resource(&resources, &ioport_resource);
-	pci_add_resource(&resources, &iomem_resource);
-	b = pci_create_root_bus(parent, bus, ops, sysdata, &resources);
-	if (!b)
-		pci_free_resource_list(&resources);
-	return b;
-}
-
 /* Deprecated; use pci_scan_root_bus() instead */
 struct pci_bus * __devinit pci_scan_bus_parented(struct device *parent,
 		int bus, struct pci_ops *ops, void *sysdata)

commit 7e00fe2e53fd3a1540febcb2d2bee9d0b2eea507
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Oct 28 16:26:05 2011 -0600

    PCI: deprecate pci_scan_bus_parented()
    
    Users of pci_scan_bus_parented() should be converted to use either
        pci_scan_root_bus() (preferred, but also calls pci_bus_add_devices)
    or
        pci_create_root_bus()
        pci_scan_child_bus()
    
    Since pci_scan_bus_parented(), I'm marking it deprecated now and will
    actually remove it later.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 04c2dc709276..944ea2170f48 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1637,6 +1637,7 @@ struct pci_bus *pci_create_bus(struct device *parent,
 	return b;
 }
 
+/* Deprecated; use pci_scan_root_bus() instead */
 struct pci_bus * __devinit pci_scan_bus_parented(struct device *parent,
 		int bus, struct pci_ops *ops, void *sysdata)
 {

commit 1e39ae9f9035ee02e014b5fe29461674fe19624d
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Oct 28 16:26:00 2011 -0600

    PCI: convert pci_scan_bus_parented() to use pci_create_root_bus()
    
    This converts pci_scan_bus_parented() to use pci_create_root_bus()
    instead of pci_create_bus().  The new bus still has the default (incorrect)
    resources, so this patch doesn't help fix that problem, but it does remove
    one more use of pci_create_bus().
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index d09644b52d1c..04c2dc709276 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1640,11 +1640,16 @@ struct pci_bus *pci_create_bus(struct device *parent,
 struct pci_bus * __devinit pci_scan_bus_parented(struct device *parent,
 		int bus, struct pci_ops *ops, void *sysdata)
 {
+	LIST_HEAD(resources);
 	struct pci_bus *b;
 
-	b = pci_create_bus(parent, bus, ops, sysdata);
+	pci_add_resource(&resources, &ioport_resource);
+	pci_add_resource(&resources, &iomem_resource);
+	b = pci_create_root_bus(parent, bus, ops, sysdata, &resources);
 	if (b)
 		b->subordinate = pci_scan_child_bus(b);
+	else
+		pci_free_resource_list(&resources);
 	return b;
 }
 EXPORT_SYMBOL(pci_scan_bus_parented);

commit de4b2f76d69673cea08be952dcb4df2f4c81c6e3
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Oct 28 16:25:55 2011 -0600

    PCI: convert pci_scan_bus() to use pci_create_root_bus()
    
    I plan to deprecate pci_scan_bus_parented(), so use pci_create_root_bus()
    directly instead.  pci_scan_bus() itself will be removed as soon as all
    callers are gone, so this is just an interim step.
    
    v2: export pci_scan_bus
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 7fc7e14118cc..d09644b52d1c 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1649,6 +1649,25 @@ struct pci_bus * __devinit pci_scan_bus_parented(struct device *parent,
 }
 EXPORT_SYMBOL(pci_scan_bus_parented);
 
+struct pci_bus * __devinit pci_scan_bus(int bus, struct pci_ops *ops,
+					void *sysdata)
+{
+	LIST_HEAD(resources);
+	struct pci_bus *b;
+
+	pci_add_resource(&resources, &ioport_resource);
+	pci_add_resource(&resources, &iomem_resource);
+	b = pci_create_root_bus(NULL, bus, ops, sysdata, &resources);
+	if (b) {
+		b->subordinate = pci_scan_child_bus(b);
+		pci_bus_add_devices(b);
+	} else {
+		pci_free_resource_list(&resources);
+	}
+	return b;
+}
+EXPORT_SYMBOL(pci_scan_bus);
+
 #ifdef CONFIG_HOTPLUG
 /**
  * pci_rescan_bus - scan a PCI bus for devices.

commit a2ebb827958a4ab3577443f89037f229683c644a
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Oct 28 16:25:50 2011 -0600

    PCI: add pci_scan_root_bus() that accepts resource list
    
    "Early" and "header" quirks often use incorrect bus resources because they
    see the default resources assigned by pci_create_bus(), before the
    architecture fixes them up (typically in pcibios_fixup_bus()).  Regions
    reserved by these quirks end up with the wrong parents.
    
    Here's the standard path for scanning a PCI root bus:
    
      pci_scan_bus or pci_scan_bus_parented
        pci_create_bus                     <-- A create with default resources
        pci_scan_child_bus
          pci_scan_slot
            pci_scan_single_device
              pci_scan_device
                pci_setup_device
                  pci_fixup_device(early)  <-- B
              pci_device_add
                pci_fixup_device(header)   <-- C
          pcibios_fixup_bus                <-- D fill in correct resources
    
    Early and header quirks at B and C use the default (incorrect) root bus
    resources rather than those filled in at D.
    
    This patch adds a new pci_scan_root_bus() function that sets the bus
    resources correctly from a supplied list of resources.
    
    I intend to remove pci_scan_bus() and pci_scan_bus_parented() after
    fixing all callers.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 89ecded0581b..7fc7e14118cc 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1608,6 +1608,21 @@ struct pci_bus *pci_create_root_bus(struct device *parent, int bus,
 	return NULL;
 }
 
+struct pci_bus * __devinit pci_scan_root_bus(struct device *parent, int bus,
+		struct pci_ops *ops, void *sysdata, struct list_head *resources)
+{
+	struct pci_bus *b;
+
+	b = pci_create_root_bus(parent, bus, ops, sysdata, resources);
+	if (!b)
+		return NULL;
+
+	b->subordinate = pci_scan_child_bus(b);
+	pci_bus_add_devices(b);
+	return b;
+}
+EXPORT_SYMBOL(pci_scan_root_bus);
+
 struct pci_bus *pci_create_bus(struct device *parent,
 		int bus, struct pci_ops *ops, void *sysdata)
 {

commit 166c6370754a0a92386e2ffb0eeb06e50ac8588d
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Oct 28 16:25:45 2011 -0600

    PCI: add pci_create_root_bus() that accepts resource list
    
    pci_create_bus() assigns ioport_resource and iomem_resource as the default
    bus resources, i.e., the entire address space.  Architectures fix these
    later, typically in pcibios_fixup_bus() or after pci_scan_bus_parented()
    returns, but code that runs in the interim sees incorrect resource
    information.
    
    This patch adds a new pci_create_root_bus() that sets the bus resources
    correctly from a supplied list of resources.
    
    I intend to remove pci_create_bus() after changing all callers.
    
    Based on original patch by Deng-Cheng Zhu.
    
    Reference: http://www.spinics.net/lists/mips/msg41654.html
    Reference: https://lkml.org/lkml/2011/8/26/88
    Signed-off-by: Deng-Cheng Zhu <dczhu@mips.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 2f0b14451d9d..89ecded0581b 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1522,12 +1522,13 @@ unsigned int __devinit pci_scan_child_bus(struct pci_bus *bus)
 	return max;
 }
 
-struct pci_bus * pci_create_bus(struct device *parent,
-		int bus, struct pci_ops *ops, void *sysdata)
+struct pci_bus *pci_create_root_bus(struct device *parent, int bus,
+		struct pci_ops *ops, void *sysdata, struct list_head *resources)
 {
 	int error, i;
 	struct pci_bus *b, *b2;
 	struct device *dev;
+	struct pci_bus_resource *bus_res, *n;
 	struct resource *res;
 
 	b = pci_alloc_bus();
@@ -1578,8 +1579,10 @@ struct pci_bus * pci_create_bus(struct device *parent,
 	pci_create_legacy_files(b);
 
 	b->number = b->secondary = bus;
-	b->resource[0] = &ioport_resource;
-	b->resource[1] = &iomem_resource;
+
+	/* Add initial resources to the bus */
+	list_for_each_entry_safe(bus_res, n, resources, list)
+		list_move_tail(&bus_res->list, &b->resources);
 
 	if (parent)
 		dev_info(parent, "PCI host bridge to bus %s\n", dev_name(&b->dev));
@@ -1605,6 +1608,20 @@ struct pci_bus * pci_create_bus(struct device *parent,
 	return NULL;
 }
 
+struct pci_bus *pci_create_bus(struct device *parent,
+		int bus, struct pci_ops *ops, void *sysdata)
+{
+	LIST_HEAD(resources);
+	struct pci_bus *b;
+
+	pci_add_resource(&resources, &ioport_resource);
+	pci_add_resource(&resources, &iomem_resource);
+	b = pci_create_root_bus(parent, bus, ops, sysdata, &resources);
+	if (!b)
+		pci_free_resource_list(&resources);
+	return b;
+}
+
 struct pci_bus * __devinit pci_scan_bus_parented(struct device *parent,
 		int bus, struct pci_ops *ops, void *sysdata)
 {

commit a9d9f5276cb3fa08351e8837ab9398bfd8e69a2e
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Oct 28 16:25:40 2011 -0600

    PCI: show host bridges and root bus resources
    
    Show the bus number and resources for every root bus we create.  This
    will become more interesting when we supply the correct resources
    instead of using the defaults (ioport_resource and iomem_resource).
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index d5d0ab810f79..2f0b14451d9d 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1525,9 +1525,10 @@ unsigned int __devinit pci_scan_child_bus(struct pci_bus *bus)
 struct pci_bus * pci_create_bus(struct device *parent,
 		int bus, struct pci_ops *ops, void *sysdata)
 {
-	int error;
+	int error, i;
 	struct pci_bus *b, *b2;
 	struct device *dev;
+	struct resource *res;
 
 	b = pci_alloc_bus();
 	if (!b)
@@ -1580,6 +1581,16 @@ struct pci_bus * pci_create_bus(struct device *parent,
 	b->resource[0] = &ioport_resource;
 	b->resource[1] = &iomem_resource;
 
+	if (parent)
+		dev_info(parent, "PCI host bridge to bus %s\n", dev_name(&b->dev));
+	else
+		printk(KERN_INFO "PCI host bridge to bus %s\n", dev_name(&b->dev));
+
+	pci_bus_for_each_resource(b, res, i) {
+		if (res)
+			dev_info(&b->dev, "root bus resource %pR\n", res);
+	}
+
 	return b;
 
 class_dev_reg_err:

commit 68e35c9b0b9dfad1ec5d1e2858b9c7e2076763e5
Author: Zac Storer <zac.3.14159@gmail.com>
Date:   Thu Nov 17 23:07:49 2011 -0700

    PCI: fix a brace coding style issue in probe.c
    
    Fixed a brace coding style issue.
    
    Signed-off-by: Zac Storer <zac.3.14159@gmail.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 04e74f485714..d5d0ab810f79 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1534,7 +1534,7 @@ struct pci_bus * pci_create_bus(struct device *parent,
 		return NULL;
 
 	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
-	if (!dev){
+	if (!dev) {
 		kfree(b);
 		return NULL;
 	}

commit a513a99a7cebfb452839cc09c9c0586f72d96414
Author: Jon Mason <mason@myri.com>
Date:   Fri Oct 14 14:56:16 2011 -0500

    PCI: Clean-up MPS debug output
    
    Clean-up MPS debug output to make it a single line and aligned, thus
    making it more readable for a large number of buses and devices in a
    single system.
    
    Suggested by Benjamin Herrenschmidt <benh@kernel.crashing.org>
    
    Signed-off-by: Jon Mason <mason@myri.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 482942439852..04e74f485714 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1428,24 +1428,25 @@ static void pcie_write_mrrs(struct pci_dev *dev)
 
 static int pcie_bus_configure_set(struct pci_dev *dev, void *data)
 {
-	int mps = 128 << *(u8 *)data;
+	int mps, orig_mps;
 
 	if (!pci_is_pcie(dev))
 		return 0;
 
-	dev_dbg(&dev->dev, "Dev MPS %d MPSS %d MRRS %d\n",
-		 pcie_get_mps(dev), 128<<dev->pcie_mpss, pcie_get_readrq(dev));
+	mps = 128 << *(u8 *)data;
+	orig_mps = pcie_get_mps(dev);
 
 	pcie_write_mps(dev, mps);
 	pcie_write_mrrs(dev);
 
-	dev_dbg(&dev->dev, "Dev MPS %d MPSS %d MRRS %d\n",
-		 pcie_get_mps(dev), 128<<dev->pcie_mpss, pcie_get_readrq(dev));
+	dev_info(&dev->dev, "PCI-E Max Payload Size set to %4d/%4d (was %4d), "
+		 "Max Read Rq %4d\n", pcie_get_mps(dev), 128 << dev->pcie_mpss,
+		 orig_mps, pcie_get_readrq(dev));
 
 	return 0;
 }
 
-/* pcie_bus_configure_mps requires that pci_walk_bus work in a top-down,
+/* pcie_bus_configure_settings requires that pci_walk_bus work in a top-down,
  * parents then children fashion.  If this changes, then this code will not
  * work as designed.
  */

commit 62f392ea5b5f87b641e16e61a4cedda21ef7341f
Author: Jon Mason <mason@myri.com>
Date:   Fri Oct 14 14:56:14 2011 -0500

    PCI: enable MPS "performance" setting to properly handle bridge MPS
    
    Rework the "performance" MPS option to configure the device MPS with the
    smaller of the device MPSS or the bridge MPS (which is assumed to be
    properly configured at this point to the largest allowable MPS based on
    its parent bus).
    
    Also, rework the MRRS setting to report an inability to set the MRRS to
    a valid setting.
    
    Signed-off-by: Jon Mason <mason@myri.com>
    Acked-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 6ab6bd3df4b2..482942439852 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1363,31 +1363,25 @@ static int pcie_find_smpss(struct pci_dev *dev, void *data)
 
 static void pcie_write_mps(struct pci_dev *dev, int mps)
 {
-	int rc, dev_mpss;
-
-	dev_mpss = 128 << dev->pcie_mpss;
+	int rc;
 
 	if (pcie_bus_config == PCIE_BUS_PERFORMANCE) {
-		if (dev->bus->self) {
-			dev_dbg(&dev->bus->dev, "Bus MPSS %d\n",
-				128 << dev->bus->self->pcie_mpss);
+		mps = 128 << dev->pcie_mpss;
 
-			/* For "MPS Force Max", the assumption is made that
+		if (dev->pcie_type != PCI_EXP_TYPE_ROOT_PORT && dev->bus->self)
+			/* For "Performance", the assumption is made that
 			 * downstream communication will never be larger than
 			 * the MRRS.  So, the MPS only needs to be configured
 			 * for the upstream communication.  This being the case,
 			 * walk from the top down and set the MPS of the child
 			 * to that of the parent bus.
+			 *
+			 * Configure the device MPS with the smaller of the
+			 * device MPSS or the bridge MPS (which is assumed to be
+			 * properly configured at this point to the largest
+			 * allowable MPS based on its parent bus).
 			 */
-			mps = 128 << dev->bus->self->pcie_mpss;
-			if (mps > dev_mpss)
-				dev_warn(&dev->dev, "MPS configured higher than"
-					 " maximum supported by the device.  If"
-					 " a bus issue occurs, try running with"
-					 " pci=pcie_bus_safe.\n");
-		}
-
-		dev->pcie_mpss = ffs(mps) - 8;
+			mps = min(mps, pcie_get_mps(dev->bus->self));
 	}
 
 	rc = pcie_set_mps(dev, mps);
@@ -1395,25 +1389,22 @@ static void pcie_write_mps(struct pci_dev *dev, int mps)
 		dev_err(&dev->dev, "Failed attempting to set the MPS\n");
 }
 
-static void pcie_write_mrrs(struct pci_dev *dev, int mps)
+static void pcie_write_mrrs(struct pci_dev *dev)
 {
-	int rc, mrrs, dev_mpss;
+	int rc, mrrs;
 
 	/* In the "safe" case, do not configure the MRRS.  There appear to be
 	 * issues with setting MRRS to 0 on a number of devices.
 	 */
-
 	if (pcie_bus_config != PCIE_BUS_PERFORMANCE)
 		return;
 
-	dev_mpss = 128 << dev->pcie_mpss;
-
 	/* For Max performance, the MRRS must be set to the largest supported
 	 * value.  However, it cannot be configured larger than the MPS the
-	 * device or the bus can support.  This assumes that the largest MRRS
-	 * available on the device cannot be smaller than the device MPSS.
+	 * device or the bus can support.  This should already be properly
+	 * configured by a prior call to pcie_write_mps.
 	 */
-	mrrs = min(mps, dev_mpss);
+	mrrs = pcie_get_mps(dev);
 
 	/* MRRS is a R/W register.  Invalid values can be written, but a
 	 * subsequent read will verify if the value is acceptable or not.
@@ -1421,16 +1412,18 @@ static void pcie_write_mrrs(struct pci_dev *dev, int mps)
 	 * shrink the value until it is acceptable to the HW.
  	 */
 	while (mrrs != pcie_get_readrq(dev) && mrrs >= 128) {
-		dev_warn(&dev->dev, "Attempting to modify the PCI-E MRRS value"
-			 " to %d.  If any issues are encountered, please try "
-			 "running with pci=pcie_bus_safe\n", mrrs);
 		rc = pcie_set_readrq(dev, mrrs);
-		if (rc)
-			dev_err(&dev->dev,
-				"Failed attempting to set the MRRS\n");
+		if (!rc)
+			break;
 
+		dev_warn(&dev->dev, "Failed attempting to set the MRRS\n");
 		mrrs /= 2;
 	}
+
+	if (mrrs < 128)
+		dev_err(&dev->dev, "MRRS was unable to be configured with a "
+			"safe value.  If problems are experienced, try running "
+			"with pci=pcie_bus_safe.\n");
 }
 
 static int pcie_bus_configure_set(struct pci_dev *dev, void *data)
@@ -1444,7 +1437,7 @@ static int pcie_bus_configure_set(struct pci_dev *dev, void *data)
 		 pcie_get_mps(dev), 128<<dev->pcie_mpss, pcie_get_readrq(dev));
 
 	pcie_write_mps(dev, mps);
-	pcie_write_mrrs(dev, mps);
+	pcie_write_mrrs(dev);
 
 	dev_dbg(&dev->dev, "Dev MPS %d MPSS %d MRRS %d\n",
 		 pcie_get_mps(dev), 128<<dev->pcie_mpss, pcie_get_readrq(dev));

commit 5f39e6705faade2e89d119958a8c51b9b6e2c53c
Author: Jon Mason <mason@myri.com>
Date:   Mon Oct 3 09:50:20 2011 -0500

    PCI: Disable MPS configuration by default
    
    Add the ability to disable PCI-E MPS turning and using the BIOS
    configured MPS defaults.  Due to the number of issues recently
    discovered on some x86 chipsets, make this the default behavior.
    
    Also, add the option for peer to peer DMA MPS configuration.  Peer to
    peer DMA is outside the scope of this patch, but MPS configuration could
    prevent it from working by having the MPS on one root port different
    than the MPS on another.  To work around this, simply make the system
    wide MPS the smallest possible value (128B).
    
    Signed-off-by: Jon Mason <mason@myri.com>
    Acked-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index f3f94a5c068f..6ab6bd3df4b2 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1458,12 +1458,24 @@ static int pcie_bus_configure_set(struct pci_dev *dev, void *data)
  */
 void pcie_bus_configure_settings(struct pci_bus *bus, u8 mpss)
 {
-	u8 smpss = mpss;
+	u8 smpss;
 
 	if (!pci_is_pcie(bus->self))
 		return;
 
+	if (pcie_bus_config == PCIE_BUS_TUNE_OFF)
+		return;
+
+	/* FIXME - Peer to peer DMA is possible, though the endpoint would need
+	 * to be aware to the MPS of the destination.  To work around this,
+	 * simply force the MPS of the entire system to the smallest possible.
+	 */
+	if (pcie_bus_config == PCIE_BUS_PEER2PEER)
+		smpss = 0;
+
 	if (pcie_bus_config == PCIE_BUS_SAFE) {
+		smpss = mpss;
+
 		pcie_find_smpss(bus->self, &smpss);
 		pci_walk_bus(bus, pcie_find_smpss, &smpss);
 	}

commit 1a4b1a41b8a3d5256019854e851beed063b34344
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Tue Sep 13 15:16:33 2011 -0300

    pci: Don't crash when reading mpss from root complex
    
    In pcie_find_smpss(), we have the following statement:
    
            if (dev->is_hotplug_bridge && (!list_is_singular(&dev->bus->devices) ||
                dev->bus->self->pcie_type != PCI_EXP_TYPE_ROOT_PORT))
    
    The problem is that at least on my machine, this gets called for the
    root complex (virtual P2P bridge), and dev->bus->self is NULL since
    the parent bus for this is not itself anchor to a PCI device.
    
    This adds the necessary NULL check.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Acked-by: Jon Mason <mason@myri.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index b1187ff31d89..f3f94a5c068f 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1351,7 +1351,8 @@ static int pcie_find_smpss(struct pci_dev *dev, void *data)
 	 * will occur as normal.
 	 */
 	if (dev->is_hotplug_bridge && (!list_is_singular(&dev->bus->devices) ||
-	    dev->bus->self->pcie_type != PCI_EXP_TYPE_ROOT_PORT))
+	     (dev->bus->self &&
+	      dev->bus->self->pcie_type != PCI_EXP_TYPE_ROOT_PORT)))
 		*smpss = 0;
 
 	if (*smpss > dev->pcie_mpss)

commit ed2888e906b56769b4ffabb9c577190438aa68b8
Author: Jon Mason <mason@myri.com>
Date:   Thu Sep 8 16:41:18 2011 -0500

    PCI: Remove MRRS modification from MPS setting code
    
    Modifying the Maximum Read Request Size to 0 (value of 128Bytes) has
    massive negative ramifications on some devices.  Without knowing which
    devices have this issue, do not modify from the default value when
    walking the PCI-E bus in pcie_bus_safe mode.  Also, make pcie_bus_safe
    the default procedure.
    
    Tested-by: Sven Schnelle <svens@stackframe.org>
    Tested-by: Simon Kirby <sim@hostway.ca>
    Tested-by: Stephen M. Cameron <scameron@beardog.cce.hp.com>
    Reported-and-tested-by: Eric Dumazet <eric.dumazet@gmail.com>
    Reported-and-tested-by: Niels Ole Salscheider <niels_ole@salscheider-online.de>
    References: https://bugzilla.kernel.org/show_bug.cgi?id=42162
    Signed-off-by: Jon Mason <mason@myri.com>
    Acked-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 0820fc1544e8..b1187ff31d89 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1396,34 +1396,37 @@ static void pcie_write_mps(struct pci_dev *dev, int mps)
 
 static void pcie_write_mrrs(struct pci_dev *dev, int mps)
 {
-	int rc, mrrs;
+	int rc, mrrs, dev_mpss;
 
-	if (pcie_bus_config == PCIE_BUS_PERFORMANCE) {
-		int dev_mpss = 128 << dev->pcie_mpss;
+	/* In the "safe" case, do not configure the MRRS.  There appear to be
+	 * issues with setting MRRS to 0 on a number of devices.
+	 */
 
-		/* For Max performance, the MRRS must be set to the largest
-		 * supported value.  However, it cannot be configured larger
-		 * than the MPS the device or the bus can support.  This assumes
-		 * that the largest MRRS available on the device cannot be
-		 * smaller than the device MPSS.
-		 */
-		mrrs = mps < dev_mpss ? mps : dev_mpss;
-	} else
-		/* In the "safe" case, configure the MRRS for fairness on the
-		 * bus by making all devices have the same size
-		 */
-		mrrs = mps;
+	if (pcie_bus_config != PCIE_BUS_PERFORMANCE)
+		return;
+
+	dev_mpss = 128 << dev->pcie_mpss;
 
+	/* For Max performance, the MRRS must be set to the largest supported
+	 * value.  However, it cannot be configured larger than the MPS the
+	 * device or the bus can support.  This assumes that the largest MRRS
+	 * available on the device cannot be smaller than the device MPSS.
+	 */
+	mrrs = min(mps, dev_mpss);
 
 	/* MRRS is a R/W register.  Invalid values can be written, but a
-	 * subsiquent read will verify if the value is acceptable or not.
+	 * subsequent read will verify if the value is acceptable or not.
 	 * If the MRRS value provided is not acceptable (e.g., too large),
 	 * shrink the value until it is acceptable to the HW.
  	 */
 	while (mrrs != pcie_get_readrq(dev) && mrrs >= 128) {
+		dev_warn(&dev->dev, "Attempting to modify the PCI-E MRRS value"
+			 " to %d.  If any issues are encountered, please try "
+			 "running with pci=pcie_bus_safe\n", mrrs);
 		rc = pcie_set_readrq(dev, mrrs);
 		if (rc)
-			dev_err(&dev->dev, "Failed attempting to set the MRRS\n");
+			dev_err(&dev->dev,
+				"Failed attempting to set the MRRS\n");
 
 		mrrs /= 2;
 	}
@@ -1436,13 +1439,13 @@ static int pcie_bus_configure_set(struct pci_dev *dev, void *data)
 	if (!pci_is_pcie(dev))
 		return 0;
 
-	dev_info(&dev->dev, "Dev MPS %d MPSS %d MRRS %d\n",
+	dev_dbg(&dev->dev, "Dev MPS %d MPSS %d MRRS %d\n",
 		 pcie_get_mps(dev), 128<<dev->pcie_mpss, pcie_get_readrq(dev));
 
 	pcie_write_mps(dev, mps);
 	pcie_write_mrrs(dev, mps);
 
-	dev_info(&dev->dev, "Dev MPS %d MPSS %d MRRS %d\n",
+	dev_dbg(&dev->dev, "Dev MPS %d MPSS %d MRRS %d\n",
 		 pcie_get_mps(dev), 128<<dev->pcie_mpss, pcie_get_readrq(dev));
 
 	return 0;

commit 5307f6d5fb12fd01f9f321bc4a8fd77e74858647
Author: Shyam Iyer <shyam.iyer.t@gmail.com>
Date:   Thu Sep 8 16:41:17 2011 -0500

    Fix pointer dereference before call to pcie_bus_configure_settings
    
    Commit b03e7495a862 ("PCI: Set PCI-E Max Payload Size on fabric")
    introduced a potential NULL pointer dereference in calls to
    pcie_bus_configure_settings due to attempts to access pci_bus self
    variables when the self pointer is NULL.
    
    To correct this, verify that the self pointer in pci_bus is non-NULL
    before dereferencing it.
    
    Reported-by: Stanislaw Gruszka <sgruszka@redhat.com>
    Signed-off-by: Shyam Iyer <shyam_iyer@dell.com>
    Signed-off-by: Jon Mason <mason@myri.com>
    Acked-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 8473727b29fa..0820fc1544e8 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1456,9 +1456,6 @@ void pcie_bus_configure_settings(struct pci_bus *bus, u8 mpss)
 {
 	u8 smpss = mpss;
 
-	if (!bus->self)
-		return;
-
 	if (!pci_is_pcie(bus->self))
 		return;
 

commit debc3b778508f59696ff188f0feca271dcbfa7d9
Author: Jon Mason <mason@myri.com>
Date:   Tue Aug 2 00:01:18 2011 -0500

    PCI: export pcie_bus_configure_settings symbol
    
    pcie_bus_configure_settings needs to be exported if the PCI hotplug
    driver is being compiled as a module.
    
    Reported-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Jon Mason <mason@myri.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 5becf7cd50d8..8473727b29fa 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1470,6 +1470,7 @@ void pcie_bus_configure_settings(struct pci_bus *bus, u8 mpss)
 	pcie_bus_configure_set(bus->self, &smpss);
 	pci_walk_bus(bus, pcie_bus_configure_set, &smpss);
 }
+EXPORT_SYMBOL_GPL(pcie_bus_configure_settings);
 
 unsigned int __devinit pci_scan_child_bus(struct pci_bus *bus)
 {

commit b03e7495a862b028294f59fc87286d6d78ee7fa1
Author: Jon Mason <mason@myri.com>
Date:   Wed Jul 20 15:20:54 2011 -0500

    PCI: Set PCI-E Max Payload Size on fabric
    
    On a given PCI-E fabric, each device, bridge, and root port can have a
    different PCI-E maximum payload size.  There is a sizable performance
    boost for having the largest possible maximum payload size on each PCI-E
    device.  However, if improperly configured, fatal bus errors can occur.
    Thus, it is important to ensure that PCI-E payloads sends by a device
    are never larger than the MPS setting of all devices on the way to the
    destination.
    
    This can be achieved two ways:
    
    - A conservative approach is to use the smallest common denominator of
      the entire tree below a root complex for every device on that fabric.
    
    This means for example that having a 128 bytes MPS USB controller on one
    leg of a switch will dramatically reduce performances of a video card or
    10GE adapter on another leg of that same switch.
    
    It also means that any hierarchy supporting hotplug slots (including
    expresscard or thunderbolt I suppose, dbl check that) will have to be
    entirely clamped to 128 bytes since we cannot predict what will be
    plugged into those slots, and we cannot change the MPS on a "live"
    system.
    
    - A more optimal way is possible, if it falls within a couple of
      constraints:
    * The top-level host bridge will never generate packets larger than the
      smallest TLP (or if it can be controlled independently from its MPS at
      least)
    * The device will never generate packets larger than MPS (which can be
      configured via MRRS)
    * No support of direct PCI-E <-> PCI-E transfers between devices without
      some additional code to specifically deal with that case
    
    Then we can use an approach that basically ignores downstream requests
    and focuses exclusively on upstream requests. In that case, all we need
    to care about is that a device MPS is no larger than its parent MPS,
    which allows us to keep all switches/bridges to the max MPS supported by
    their parent and eventually the PHB.
    
    In this case, your USB controller would no longer "starve" your 10GE
    Ethernet and your hotplug slots won't affect your global MPS.
    Additionally, the hotplugged devices themselves can be configured to a
    larger MPS up to the value configured in the hotplug bridge.
    
    To choose between the two available options, two PCI kernel boot args
    have been added to the PCI calls.  "pcie_bus_safe" will provide the
    former behavior, while "pcie_bus_perf" will perform the latter behavior.
    By default, the latter behavior is used.
    
    NOTE: due to the location of the enablement, each arch will need to add
    calls to this function.  This patch only enables x86.
    
    This patch includes a number of changes recommended by Benjamin
    Herrenschmidt.
    
    Tested-by: Jordan_Hargrave@dell.com
    Signed-off-by: Jon Mason <mason@myri.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 795c9026d55f..5becf7cd50d8 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -856,6 +856,8 @@ void set_pcie_port_type(struct pci_dev *pdev)
 	pdev->pcie_cap = pos;
 	pci_read_config_word(pdev, pos + PCI_EXP_FLAGS, &reg16);
 	pdev->pcie_type = (reg16 & PCI_EXP_FLAGS_TYPE) >> 4;
+	pci_read_config_word(pdev, pos + PCI_EXP_DEVCAP, &reg16);
+	pdev->pcie_mpss = reg16 & PCI_EXP_DEVCAP_PAYLOAD;
 }
 
 void set_pcie_hotplug_bridge(struct pci_dev *pdev)
@@ -1326,6 +1328,149 @@ int pci_scan_slot(struct pci_bus *bus, int devfn)
 	return nr;
 }
 
+static int pcie_find_smpss(struct pci_dev *dev, void *data)
+{
+	u8 *smpss = data;
+
+	if (!pci_is_pcie(dev))
+		return 0;
+
+	/* For PCIE hotplug enabled slots not connected directly to a
+	 * PCI-E root port, there can be problems when hotplugging
+	 * devices.  This is due to the possibility of hotplugging a
+	 * device into the fabric with a smaller MPS that the devices
+	 * currently running have configured.  Modifying the MPS on the
+	 * running devices could cause a fatal bus error due to an
+	 * incoming frame being larger than the newly configured MPS.
+	 * To work around this, the MPS for the entire fabric must be
+	 * set to the minimum size.  Any devices hotplugged into this
+	 * fabric will have the minimum MPS set.  If the PCI hotplug
+	 * slot is directly connected to the root port and there are not
+	 * other devices on the fabric (which seems to be the most
+	 * common case), then this is not an issue and MPS discovery
+	 * will occur as normal.
+	 */
+	if (dev->is_hotplug_bridge && (!list_is_singular(&dev->bus->devices) ||
+	    dev->bus->self->pcie_type != PCI_EXP_TYPE_ROOT_PORT))
+		*smpss = 0;
+
+	if (*smpss > dev->pcie_mpss)
+		*smpss = dev->pcie_mpss;
+
+	return 0;
+}
+
+static void pcie_write_mps(struct pci_dev *dev, int mps)
+{
+	int rc, dev_mpss;
+
+	dev_mpss = 128 << dev->pcie_mpss;
+
+	if (pcie_bus_config == PCIE_BUS_PERFORMANCE) {
+		if (dev->bus->self) {
+			dev_dbg(&dev->bus->dev, "Bus MPSS %d\n",
+				128 << dev->bus->self->pcie_mpss);
+
+			/* For "MPS Force Max", the assumption is made that
+			 * downstream communication will never be larger than
+			 * the MRRS.  So, the MPS only needs to be configured
+			 * for the upstream communication.  This being the case,
+			 * walk from the top down and set the MPS of the child
+			 * to that of the parent bus.
+			 */
+			mps = 128 << dev->bus->self->pcie_mpss;
+			if (mps > dev_mpss)
+				dev_warn(&dev->dev, "MPS configured higher than"
+					 " maximum supported by the device.  If"
+					 " a bus issue occurs, try running with"
+					 " pci=pcie_bus_safe.\n");
+		}
+
+		dev->pcie_mpss = ffs(mps) - 8;
+	}
+
+	rc = pcie_set_mps(dev, mps);
+	if (rc)
+		dev_err(&dev->dev, "Failed attempting to set the MPS\n");
+}
+
+static void pcie_write_mrrs(struct pci_dev *dev, int mps)
+{
+	int rc, mrrs;
+
+	if (pcie_bus_config == PCIE_BUS_PERFORMANCE) {
+		int dev_mpss = 128 << dev->pcie_mpss;
+
+		/* For Max performance, the MRRS must be set to the largest
+		 * supported value.  However, it cannot be configured larger
+		 * than the MPS the device or the bus can support.  This assumes
+		 * that the largest MRRS available on the device cannot be
+		 * smaller than the device MPSS.
+		 */
+		mrrs = mps < dev_mpss ? mps : dev_mpss;
+	} else
+		/* In the "safe" case, configure the MRRS for fairness on the
+		 * bus by making all devices have the same size
+		 */
+		mrrs = mps;
+
+
+	/* MRRS is a R/W register.  Invalid values can be written, but a
+	 * subsiquent read will verify if the value is acceptable or not.
+	 * If the MRRS value provided is not acceptable (e.g., too large),
+	 * shrink the value until it is acceptable to the HW.
+ 	 */
+	while (mrrs != pcie_get_readrq(dev) && mrrs >= 128) {
+		rc = pcie_set_readrq(dev, mrrs);
+		if (rc)
+			dev_err(&dev->dev, "Failed attempting to set the MRRS\n");
+
+		mrrs /= 2;
+	}
+}
+
+static int pcie_bus_configure_set(struct pci_dev *dev, void *data)
+{
+	int mps = 128 << *(u8 *)data;
+
+	if (!pci_is_pcie(dev))
+		return 0;
+
+	dev_info(&dev->dev, "Dev MPS %d MPSS %d MRRS %d\n",
+		 pcie_get_mps(dev), 128<<dev->pcie_mpss, pcie_get_readrq(dev));
+
+	pcie_write_mps(dev, mps);
+	pcie_write_mrrs(dev, mps);
+
+	dev_info(&dev->dev, "Dev MPS %d MPSS %d MRRS %d\n",
+		 pcie_get_mps(dev), 128<<dev->pcie_mpss, pcie_get_readrq(dev));
+
+	return 0;
+}
+
+/* pcie_bus_configure_mps requires that pci_walk_bus work in a top-down,
+ * parents then children fashion.  If this changes, then this code will not
+ * work as designed.
+ */
+void pcie_bus_configure_settings(struct pci_bus *bus, u8 mpss)
+{
+	u8 smpss = mpss;
+
+	if (!bus->self)
+		return;
+
+	if (!pci_is_pcie(bus->self))
+		return;
+
+	if (pcie_bus_config == PCIE_BUS_SAFE) {
+		pcie_find_smpss(bus->self, &smpss);
+		pci_walk_bus(bus, pcie_find_smpss, &smpss);
+	}
+
+	pcie_bus_configure_set(bus->self, &smpss);
+	pci_walk_bus(bus, pcie_bus_configure_set, &smpss);
+}
+
 unsigned int __devinit pci_scan_child_bus(struct pci_bus *bus)
 {
 	unsigned int devfn, pass, max = bus->secondary;

commit f85f19de90a9997583bb26e6f1f9297a4e152c18
Merge: b993fdbc7fe2 7b87c9df5602
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jul 29 23:35:05 2011 -0700

    Merge branch 'linux-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jbarnes/pci-2.6
    
    * 'linux-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jbarnes/pci-2.6:
      PCI: remove printks about disabled bridge windows
      PCI: fold pci_calc_resource_flags() into decode_bar()
      PCI: treat mem BAR type "11" (reserved) as 32-bit, not 64-bit, BAR
      PCI: correct pcie_set_readrq write size
      PCI: pciehp: change wait time for valid configuration access
      x86/PCI: Preserve existing pci=bfsort whitelist for Dell systems
      PCI: ARI is a PCIe v2 feature
      x86/PCI: quirks: Use pci_dev->revision
      PCI: Make the struct pci_dev * argument of pci_fixup_irqs const.
      PCI hotplug: cpqphp: use pci_dev->vendor
      PCI hotplug: cpqphp: use pci_dev->subsystem_{vendor|device}
      x86/PCI: config space accessor functions should not ignore the segment argument
      PCI: Assign values to 'pci_obff_signal_type' enumeration constants
      x86/PCI: reduce severity of host bridge window conflict warnings
      PCI: enumerate the PCI device only removed out PCI hieratchy of OS when re-scanning PCI
      PCI: PCIe AER: add aer_recover_queue
      x86/PCI: select direct access mode for mmconfig option
      PCI hotplug: Rename is_ejectable which also exists in dock.c

commit acb41c0f928fdb84a1c3753ac92c534a2a0f08d2
Merge: 8181780c163e ef3b4f8cc20e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jul 22 14:54:02 2011 -0700

    Merge branch 'of-pci' of git://git.kernel.org/pub/scm/linux/kernel/git/benh/powerpc
    
    * 'of-pci' of git://git.kernel.org/pub/scm/linux/kernel/git/benh/powerpc:
      pci/of: Consolidate pci_bus_to_OF_node()
      pci/of: Consolidate pci_device_to_OF_node()
      x86/devicetree: Use generic PCI <-> OF matching
      microblaze/pci: Move the remains of pci_32.c to pci-common.c
      microblaze/pci: Remove powermac originated cruft
      pci/of: Match PCI devices to OF nodes dynamically

commit 7b87c9df5602efd6c7edeb291bbd104d49a6babf
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Jun 14 13:04:40 2011 -0600

    PCI: remove printks about disabled bridge windows
    
    I don't think there's enough value in the fact of a bridge window
    being disabled to justify cluttering the dmesg log with it.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index ef17cf99830e..fd6066dfde5c 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -288,10 +288,6 @@ static void __devinit pci_read_bridge_io(struct pci_bus *child)
 		if (!res->end)
 			res->end = limit + 0xfff;
 		dev_printk(KERN_DEBUG, &dev->dev, "  bridge window %pR\n", res);
-	} else {
-		dev_printk(KERN_DEBUG, &dev->dev,
-			 "  bridge window [io  %#06lx-%#06lx] (disabled)\n",
-				 base, limit);
 	}
 }
 
@@ -312,10 +308,6 @@ static void __devinit pci_read_bridge_mmio(struct pci_bus *child)
 		res->start = base;
 		res->end = limit + 0xfffff;
 		dev_printk(KERN_DEBUG, &dev->dev, "  bridge window %pR\n", res);
-	} else {
-		dev_printk(KERN_DEBUG, &dev->dev,
-			"  bridge window [mem %#010lx-%#010lx] (disabled)\n",
-					 base, limit + 0xfffff);
 	}
 }
 
@@ -363,10 +355,6 @@ static void __devinit pci_read_bridge_mmio_pref(struct pci_bus *child)
 		res->start = base;
 		res->end = limit + 0xfffff;
 		dev_printk(KERN_DEBUG, &dev->dev, "  bridge window %pR\n", res);
-	} else {
-		dev_printk(KERN_DEBUG, &dev->dev,
-		     "  bridge window [mem %#010lx-%#010lx pref] (disabled)\n",
-					 base, limit + 0xfffff);
 	}
 }
 

commit 28c6821a0f8e686d4f1a6107d970705d37475d87
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Jun 14 13:04:35 2011 -0600

    PCI: fold pci_calc_resource_flags() into decode_bar()
    
    decode_bar() and pci_calc_resource_flags() both looked at the PCI BAR
    type information, and it's simpler to just do it all in one place.
    
    decode_bar() sets IORESOURCE_IO, IORESOURCE_MEM, and IORESOURCE_MEM_64
    as appropriate, so res->flags contains all the information pci_bar_type
    does, so we don't need to test the pci_bar_type return value.
    
    decode_bar() used to return pci_bar_type, which we no longer need.  We
    can simplify it a bit by returning the struct resource flags rather than
    updating them internally.
    
    In pci_update_resource(), there's no need to decode the BAR type bits
    again; we can just test for IORESOURCE_MEM_64 directly.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 3e7a00a3fc81..ef17cf99830e 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -67,21 +67,6 @@ static int __init pcibus_class_init(void)
 }
 postcore_initcall(pcibus_class_init);
 
-/*
- * Translate the low bits of the PCI base
- * to the resource type
- */
-static inline unsigned int pci_calc_resource_flags(unsigned int flags)
-{
-	if (flags & PCI_BASE_ADDRESS_SPACE_IO)
-		return IORESOURCE_IO;
-
-	if (flags & PCI_BASE_ADDRESS_MEM_PREFETCH)
-		return IORESOURCE_MEM | IORESOURCE_PREFETCH;
-
-	return IORESOURCE_MEM;
-}
-
 static u64 pci_size(u64 base, u64 maxbase, u64 mask)
 {
 	u64 size = mask & maxbase;	/* Find the significant bits */
@@ -100,17 +85,21 @@ static u64 pci_size(u64 base, u64 maxbase, u64 mask)
 	return size;
 }
 
-static inline enum pci_bar_type decode_bar(struct pci_dev *dev,
-					   struct resource *res, u32 bar)
+static inline unsigned long decode_bar(struct pci_dev *dev, u32 bar)
 {
 	u32 mem_type;
+	unsigned long flags;
 
 	if ((bar & PCI_BASE_ADDRESS_SPACE) == PCI_BASE_ADDRESS_SPACE_IO) {
-		res->flags = bar & ~PCI_BASE_ADDRESS_IO_MASK;
-		return pci_bar_io;
+		flags = bar & ~PCI_BASE_ADDRESS_IO_MASK;
+		flags |= IORESOURCE_IO;
+		return flags;
 	}
 
-	res->flags = bar & ~PCI_BASE_ADDRESS_MEM_MASK;
+	flags = bar & ~PCI_BASE_ADDRESS_MEM_MASK;
+	flags |= IORESOURCE_MEM;
+	if (flags & PCI_BASE_ADDRESS_MEM_PREFETCH)
+		flags |= IORESOURCE_PREFETCH;
 
 	mem_type = bar & PCI_BASE_ADDRESS_MEM_TYPE_MASK;
 	switch (mem_type) {
@@ -120,14 +109,15 @@ static inline enum pci_bar_type decode_bar(struct pci_dev *dev,
 		dev_info(&dev->dev, "1M mem BAR treated as 32-bit BAR\n");
 		break;
 	case PCI_BASE_ADDRESS_MEM_TYPE_64:
-		return pci_bar_mem64;
+		flags |= IORESOURCE_MEM_64;
+		break;
 	default:
 		dev_warn(&dev->dev,
 			 "mem unknown type %x treated as 32-bit BAR\n",
 			 mem_type);
 		break;
 	}
-	return pci_bar_mem32;
+	return flags;
 }
 
 /**
@@ -180,9 +170,9 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 		l = 0;
 
 	if (type == pci_bar_unknown) {
-		type = decode_bar(dev, res, l);
-		res->flags |= pci_calc_resource_flags(l) | IORESOURCE_SIZEALIGN;
-		if (type == pci_bar_io) {
+		res->flags = decode_bar(dev, l);
+		res->flags |= IORESOURCE_SIZEALIGN;
+		if (res->flags & IORESOURCE_IO) {
 			l &= PCI_BASE_ADDRESS_IO_MASK;
 			mask = PCI_BASE_ADDRESS_IO_MASK & (u32) IO_SPACE_LIMIT;
 		} else {
@@ -195,7 +185,7 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 		mask = (u32)PCI_ROM_ADDRESS_MASK;
 	}
 
-	if (type == pci_bar_mem64) {
+	if (res->flags & IORESOURCE_MEM_64) {
 		u64 l64 = l;
 		u64 sz64 = sz;
 		u64 mask64 = mask | (u64)~0 << 32;
@@ -219,7 +209,6 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 			goto fail;
 		}
 
-		res->flags |= IORESOURCE_MEM_64;
 		if ((sizeof(resource_size_t) < 8) && l) {
 			/* Address above 32-bit boundary; disable the BAR */
 			pci_write_config_dword(dev, pos, 0);
@@ -245,7 +234,7 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 	}
 
  out:
-	return (type == pci_bar_mem64) ? 1 : 0;
+	return (res->flags & IORESOURCE_MEM_64) ? 1 : 0;
  fail:
 	res->flags = 0;
 	goto out;

commit 8d6a6a47636648754dc371b01228520a2adaf430
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Jun 14 13:04:29 2011 -0600

    PCI: treat mem BAR type "11" (reserved) as 32-bit, not 64-bit, BAR
    
    This fixes a minor regression where broken PCI devices that use the
    reserved "11" memory BAR type worked before e354597cce but not after.
    
    The low four bits of a memory BAR are "PTT0" where P=1 for prefetchable
    BARs, and TT is as follows:
    
      00  32-bit BAR, anywhere in lower 4GB
      01  anywhere below 1MB (reserved as of PCI 2.2)
      10  64-bit BAR
      11  reserved
    
    Prior to e354597cce, we treated "0100" as a 64-bit BAR and all others,
    including prefetchable 64-bit BARs ("1100") as 32-bit BARs.  The e354597cce
    fix, which appeared in 2.6.28, treats "x1x0" as 64-bit BARs, so the
    reserved "x110" types are treated as 64-bit instead of 32-bit.
    
    This patch returns to treating the reserved "11" type as a 32-bit BAR and
    adds a warning if we see it.
    
    It also logs a note if we see a 1M BAR.  This is not a warning, because
    such hardware conforms to pre-PCI 2.2 spec, but I think it's worth noting
    because Linux ignores the 1M restriction if it ever has to assign the BAR.
    
    CC: Peter Chubb <peterc@gelato.unsw.edu.au>
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=35952
    Reported-by: Jan Zwiegers <jan@radicalsystems.co.za>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index f03ed96533d5..3e7a00a3fc81 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -100,8 +100,11 @@ static u64 pci_size(u64 base, u64 maxbase, u64 mask)
 	return size;
 }
 
-static inline enum pci_bar_type decode_bar(struct resource *res, u32 bar)
+static inline enum pci_bar_type decode_bar(struct pci_dev *dev,
+					   struct resource *res, u32 bar)
 {
+	u32 mem_type;
+
 	if ((bar & PCI_BASE_ADDRESS_SPACE) == PCI_BASE_ADDRESS_SPACE_IO) {
 		res->flags = bar & ~PCI_BASE_ADDRESS_IO_MASK;
 		return pci_bar_io;
@@ -109,8 +112,21 @@ static inline enum pci_bar_type decode_bar(struct resource *res, u32 bar)
 
 	res->flags = bar & ~PCI_BASE_ADDRESS_MEM_MASK;
 
-	if (res->flags & PCI_BASE_ADDRESS_MEM_TYPE_64)
+	mem_type = bar & PCI_BASE_ADDRESS_MEM_TYPE_MASK;
+	switch (mem_type) {
+	case PCI_BASE_ADDRESS_MEM_TYPE_32:
+		break;
+	case PCI_BASE_ADDRESS_MEM_TYPE_1M:
+		dev_info(&dev->dev, "1M mem BAR treated as 32-bit BAR\n");
+		break;
+	case PCI_BASE_ADDRESS_MEM_TYPE_64:
 		return pci_bar_mem64;
+	default:
+		dev_warn(&dev->dev,
+			 "mem unknown type %x treated as 32-bit BAR\n",
+			 mem_type);
+		break;
+	}
 	return pci_bar_mem32;
 }
 
@@ -164,7 +180,7 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 		l = 0;
 
 	if (type == pci_bar_unknown) {
-		type = decode_bar(res, l);
+		type = decode_bar(dev, res, l);
 		res->flags |= pci_calc_resource_flags(l) | IORESOURCE_SIZEALIGN;
 		if (type == pci_bar_io) {
 			l &= PCI_BASE_ADDRESS_IO_MASK;

commit b1a98b695b4efe10067d0e1cb5b66146a4e517bf
Author: Tiejun Chen <tiejun.chen@windriver.com>
Date:   Thu Jun 2 11:02:50 2011 +0800

    PCI: enumerate the PCI device only removed out PCI hieratchy of OS when re-scanning PCI
    
    When hot-plugging a root bridge, we always prevent assigning a bus number
    that already exists. This makes sure we don't step over an existing bus.
    But sometimes we only remove PCI device in PCI hieratchy of OS, i,e.
    
    echo 1 > /sys/bus/pci/devices/.../remove
    
    but actually don't hotplug this device out the platform, so in this case
    we still should re-scan this bus to enumerate this device when re-scanning
    PCI again.
    
    Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index bafb3c3d4a89..f03ed96533d5 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -724,12 +724,14 @@ int __devinit pci_scan_bridge(struct pci_bus *bus, struct pci_dev *dev, int max,
 		pci_write_config_word(dev, PCI_STATUS, 0xffff);
 
 		/* Prevent assigning a bus number that already exists.
-		 * This can happen when a bridge is hot-plugged */
-		if (pci_find_bus(pci_domain_nr(bus), max+1))
-			goto out;
-		child = pci_add_new_bus(bus, dev, ++max);
-		if (!child)
-			goto out;
+		 * This can happen when a bridge is hot-plugged, so in
+		 * this case we only re-scan this bus. */
+		child = pci_find_bus(pci_domain_nr(bus), max+1);
+		if (!child) {
+			child = pci_add_new_bus(bus, dev, ++max);
+			if (!child)
+				goto out;
+		}
 		buses = (buses & 0xff000000)
 		      | ((unsigned int)(child->primary)     <<  0)
 		      | ((unsigned int)(child->secondary)   <<  8)

commit 98d9f30c820d509145757e6ecbc36013aa02f7bc
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Mon Apr 11 11:37:07 2011 +1000

    pci/of: Match PCI devices to OF nodes dynamically
    
    powerpc has two different ways of matching PCI devices to their
    corresponding OF node (if any) for historical reasons. The ppc64 one
    does a scan looking for matching bus/dev/fn, while the ppc32 one does a
    scan looking only for matching dev/fn on each level in order to be
    agnostic to busses being renumbered (which Linux does on some
    platforms).
    
    This removes both and instead moves the matching code to the PCI core
    itself. It's the most logical place to do it: when a pci_dev is created,
    we know the parent and thus can do a single level scan for the matching
    device_node (if any).
    
    The benefit is that all archs now get the matching for free. There's one
    hook the arch might want to provide to match a PHB bus to its device
    node. A default weak implementation is provided that looks for the
    parent device device node, but it's not entirely reliable on powerpc for
    various reasons so powerpc provides its own.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Acked-by: Michal Simek <monstr@monstr.eu>
    Acked-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 48849ffdd672..c28c7b91910e 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -52,6 +52,7 @@ static void release_pcibus_dev(struct device *dev)
 	if (pci_bus->bridge)
 		put_device(pci_bus->bridge);
 	pci_bus_remove_resources(pci_bus);
+	pci_release_bus_of_node(pci_bus);
 	kfree(pci_bus);
 }
 
@@ -588,7 +589,7 @@ static struct pci_bus *pci_alloc_child_bus(struct pci_bus *parent,
 
 	child->self = bridge;
 	child->bridge = get_device(&bridge->dev);
-
+	pci_set_bus_of_node(child);
 	pci_set_bus_speed(child);
 
 	/* Set up default resource pointers and names.. */
@@ -1038,6 +1039,7 @@ static void pci_release_dev(struct device *dev)
 
 	pci_dev = to_pci_dev(dev);
 	pci_release_capabilities(pci_dev);
+	pci_release_of_node(pci_dev);
 	kfree(pci_dev);
 }
 
@@ -1157,6 +1159,8 @@ static struct pci_dev *pci_scan_device(struct pci_bus *bus, int devfn)
 	dev->vendor = l & 0xffff;
 	dev->device = (l >> 16) & 0xffff;
 
+	pci_set_of_node(dev);
+
 	if (pci_setup_device(dev)) {
 		kfree(dev);
 		return NULL;
@@ -1409,6 +1413,7 @@ struct pci_bus * pci_create_bus(struct device *parent,
 		goto dev_reg_err;
 	b->bridge = get_device(dev);
 	device_enable_async_suspend(b->bridge);
+	pci_set_bus_of_node(b);
 
 	if (!parent)
 		set_dev_node(b->bridge, pcibus_to_node(b));

commit 5aceca9d3cbdacbd017712513387d930f9f944d9
Author: David S. Miller <davem@davemloft.net>
Date:   Mon May 23 17:12:22 2011 -0700

    PCI: Fix warning in drivers/pci/probe.c on sparc64
    
    IO_SPACE_LIMIT is currently used in two ways:
    
    1) As a way to mask I/O port values read out of PCI base address
       registers.  This value should be 64-bit.
    
    2) As a value which is the upper limit for all I/O "ports" in the
       system.
    
    On sparc64 we store the full 64-bit physical I/O address in the
    resources.  For this reason we define IO_SPACE_LIMIT at a 64-bit
    "all 1's".
    
    This is the right value to use for ioport_resource.end and for the
    check made in drivers/pcmcia/rsrc_nonstatic.c:adjust_io().
    
    But in driver/pci/probe.c:__pci_read_base() we mask this against
    a "u32" variable and thus get the following warning:
    
    drivers/pci/probe.c: In function ¡__pci_read_base¢:
    drivers/pci/probe.c:207: warning: large integer implicitly truncated to unsigned type
    
    Fix this by using an explicit "u32" cast.
    
    I considered changing sparc64 to define a 32-bit "all 1's" like
    most other systems do, but this wouldn't work because the checks
    in PCMCIA's rsrc_nonstatic.c would no longer be right since they
    are testing against fully formed 64-bit resources.  As described
    above, on sparc64 such resources will hold full 64-bit physical
    I/O addresses, not bus-centric 32-bit ones.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 48849ffdd672..bafb3c3d4a89 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -168,7 +168,7 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 		res->flags |= pci_calc_resource_flags(l) | IORESOURCE_SIZEALIGN;
 		if (type == pci_bar_io) {
 			l &= PCI_BASE_ADDRESS_IO_MASK;
-			mask = PCI_BASE_ADDRESS_IO_MASK & IO_SPACE_LIMIT;
+			mask = PCI_BASE_ADDRESS_IO_MASK & (u32) IO_SPACE_LIMIT;
 		} else {
 			l &= PCI_BASE_ADDRESS_MEM_MASK;
 			mask = (u32)PCI_BASE_ADDRESS_MEM_MASK;

commit dc2c2c9dd513dec6c17df04e8abff795e20a5271
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Thu May 12 17:11:40 2011 -0700

    PCI/sysfs: move bus cpuaffinity to class dev_attrs
    
    Requested by Greg KH to fix a race condition in the creating of PCI bus
    cpuaffinity files.
    
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index c471295cd4b9..48849ffdd672 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -42,43 +42,6 @@ int no_pci_devices(void)
 }
 EXPORT_SYMBOL(no_pci_devices);
 
-/*
- * PCI Bus Class Devices
- */
-static ssize_t pci_bus_show_cpuaffinity(struct device *dev,
-					int type,
-					struct device_attribute *attr,
-					char *buf)
-{
-	int ret;
-	const struct cpumask *cpumask;
-
-	cpumask = cpumask_of_pcibus(to_pci_bus(dev));
-	ret = type?
-		cpulist_scnprintf(buf, PAGE_SIZE-2, cpumask) :
-		cpumask_scnprintf(buf, PAGE_SIZE-2, cpumask);
-	buf[ret++] = '\n';
-	buf[ret] = '\0';
-	return ret;
-}
-
-static ssize_t inline pci_bus_show_cpumaskaffinity(struct device *dev,
-					struct device_attribute *attr,
-					char *buf)
-{
-	return pci_bus_show_cpuaffinity(dev, 0, attr, buf);
-}
-
-static ssize_t inline pci_bus_show_cpulistaffinity(struct device *dev,
-					struct device_attribute *attr,
-					char *buf)
-{
-	return pci_bus_show_cpuaffinity(dev, 1, attr, buf);
-}
-
-DEVICE_ATTR(cpuaffinity,     S_IRUGO, pci_bus_show_cpumaskaffinity, NULL);
-DEVICE_ATTR(cpulistaffinity, S_IRUGO, pci_bus_show_cpulistaffinity, NULL);
-
 /*
  * PCI Bus Class
  */
@@ -1456,9 +1419,6 @@ struct pci_bus * pci_create_bus(struct device *parent,
 	error = device_register(&b->dev);
 	if (error)
 		goto class_dev_reg_err;
-	error = device_create_file(&b->dev, &dev_attr_cpuaffinity);
-	if (error)
-		goto dev_create_file_err;
 
 	/* Create legacy_io and legacy_mem files for this bus */
 	pci_create_legacy_files(b);
@@ -1469,8 +1429,6 @@ struct pci_bus * pci_create_bus(struct device *parent,
 
 	return b;
 
-dev_create_file_err:
-	device_unregister(&b->dev);
 class_dev_reg_err:
 	device_unregister(dev);
 dev_reg_err:

commit b9d320fcb6259baffaeaf93a5fce252cd09333d6
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Thu May 12 17:11:39 2011 -0700

    PCI: add rescan to /sys/.../pci_bus/.../
    
    After remove the device from /sys, we have to rescan all or
    find out the bridge and access /sys../device/rescan there.
    
    this patch add /sys/.../pci_bus/.../rescan. So user can rescan more easy.
    that is more clean and easy to understand.
    
    like after remove 0000:c4:00.0, you can rescan 0000:c4 directly.
    
    -v2: According to Jesse, use function instead of exposing attr, so could hide
            #ifdef in header file.
         also add code to remove rescan file in remove path.
    -v3: GregKH pointed out that we should use dev_attrs to avoid racing.
         So add pcibus_attrs and make it to be member of pcibus_attrs.
    -v4: Change name to pcibus_dev_attrs according to GregKH
    
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 44cbbbaa499d..c471295cd4b9 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -95,6 +95,7 @@ static void release_pcibus_dev(struct device *dev)
 static struct class pcibus_class = {
 	.name		= "pci_bus",
 	.dev_release	= &release_pcibus_dev,
+	.dev_attrs	= pcibus_dev_attrs,
 };
 
 static int __init pcibus_class_init(void)

commit 7c867c8899e873652ef98a890d2e647c092bec25
Author: Jesper Juhl <jj@chaosbits.net>
Date:   Mon Jan 24 21:14:33 2011 +0100

    PCI: Avoid potential NULL pointer dereference in pci_scan_bridge
    
    pci_add_new_bus() calls pci_alloc_child_bus() which calls pci_alloc_bus()
    that allocates memory dynamically with kzalloc(). The return value of
    kzalloc() is the pointer that's eventually returned from
    pci_add_new_bus(), so since kzalloc() can fail and return NULL so can
    pci_add_new_bus(). Thus we may end up dereferencing a NULL pointer in
    drivers/pci/probe.c::pci_scan_bridge(). Seems to me we should test for
    this and bail out if it happens rather than crashing.
    Also removed some trailing whitespace that bugged me while looking at
    this.
    
    Signed-off-by: Jesper Juhl <jj@chaosbits.net>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index c84900da3c59..44cbbbaa499d 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -764,6 +764,8 @@ int __devinit pci_scan_bridge(struct pci_bus *bus, struct pci_dev *dev, int max,
 		if (pci_find_bus(pci_domain_nr(bus), max+1))
 			goto out;
 		child = pci_add_new_bus(bus, dev, ++max);
+		if (!child)
+			goto out;
 		buses = (buses & 0xff000000)
 		      | ((unsigned int)(child->primary)     <<  0)
 		      | ((unsigned int)(child->secondary)   <<  8)
@@ -777,7 +779,7 @@ int __devinit pci_scan_bridge(struct pci_bus *bus, struct pci_dev *dev, int max,
 			buses &= ~0xff000000;
 			buses |= CARDBUS_LATENCY_TIMER << 24;
 		}
-			
+
 		/*
 		 * We need to blast all three values with a single write.
 		 */

commit 2c6413aee215a43b1f95e218067abcde50ccbc5e
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Wed Sep 29 12:23:21 2010 -0600

    PCI: log vendor/device ID always
    
    Previously we had to have CONFIG_PCI_DEBUG=y or CONFIG_DYNAMIC_DEBUG=y
    to turn on this printk, but I think the IDs are valuable enough that it's
    worth putting them in the log always.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 12625d90f8b5..c84900da3c59 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -961,8 +961,8 @@ int pci_setup_device(struct pci_dev *dev)
 	dev->class = class;
 	class >>= 8;
 
-	dev_dbg(&dev->dev, "found [%04x:%04x] class %06x header type %02x\n",
-		 dev->vendor, dev->device, class, dev->hdr_type);
+	dev_printk(KERN_DEBUG, &dev->dev, "[%04x:%04x] type %d class %#08x\n",
+		   dev->vendor, dev->device, dev->hdr_type, class);
 
 	/* need to have dev->class ready */
 	dev->cfg_size = pci_cfg_space_size(dev);

commit 253d2e549818f5a4a52e2db0aba3dacee21e5b38
Author: Jacob Pan <jacob.jun.pan@linux.intel.com>
Date:   Fri Jul 16 10:19:22 2010 -0700

    PCI: disable mmio during bar sizing
    
    It is a known issue that mmio decoding shall be disabled while doing PCI
    bar sizing. Host bridge and other devices (PCI PIC) shall be excluded for
    certain platforms. This patch mainly comes from Mathew Willcox's
    patch in http://kerneltrap.org/mailarchive/linux-kernel/2007/9/13/258969.
    
    A new flag bit "mmio_alway_on" is added to pci_dev with the intention that
    devices with their mmio decoding cannot be disabled during BAR sizing shall
    have this bit set, preferrablly in their quirks.
    
    Without this patch, Intel Moorestown platform graphics unit will be
    corrupted during bar sizing activities.
    
    Signed-off-by: Jacob Pan <jacob.jun.pan@linux.intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index f4adba2d1dd3..12625d90f8b5 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -163,9 +163,16 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 			struct resource *res, unsigned int pos)
 {
 	u32 l, sz, mask;
+	u16 orig_cmd;
 
 	mask = type ? PCI_ROM_ADDRESS_MASK : ~0;
 
+	if (!dev->mmio_always_on) {
+		pci_read_config_word(dev, PCI_COMMAND, &orig_cmd);
+		pci_write_config_word(dev, PCI_COMMAND,
+			orig_cmd & ~(PCI_COMMAND_MEMORY | PCI_COMMAND_IO));
+	}
+
 	res->name = pci_name(dev);
 
 	pci_read_config_dword(dev, pos, &l);
@@ -173,6 +180,9 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 	pci_read_config_dword(dev, pos, &sz);
 	pci_write_config_dword(dev, pos, l);
 
+	if (!dev->mmio_always_on)
+		pci_write_config_word(dev, PCI_COMMAND, orig_cmd);
+
 	/*
 	 * All bits set in sz means the device isn't working properly.
 	 * If the BAR isn't implemented, all bits must be 0.  If it's a

commit affb72c3a8984ba55e055b0a0228c3ea1a056758
Author: Huang Ying <ying.huang@intel.com>
Date:   Tue May 18 14:35:16 2010 +0800

    ACPI, APEI, PCIE AER, use general HEST table parsing in AER firmware_first setup
    
    Now, a dedicated HEST tabling parsing code is used for PCIE AER
    firmware_first setup. It is rebased on general HEST tabling parsing
    code of APEI. The firmware_first setup code is moved from PCI core to
    AER driver too, because it is only AER related.
    
    Signed-off-by: Huang Ying <ying.huang@intel.com>
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Reviewed-by: Hidetoshi Seto <seto.hidetoshi@jp.fujitsu.com>
    Acked-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index c82548afcd5c..f4adba2d1dd3 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -10,7 +10,6 @@
 #include <linux/module.h>
 #include <linux/cpumask.h>
 #include <linux/pci-aspm.h>
-#include <acpi/acpi_hest.h>
 #include "pci.h"
 
 #define CARDBUS_LATENCY_TIMER	176	/* secondary latency timer */
@@ -904,12 +903,6 @@ void set_pcie_hotplug_bridge(struct pci_dev *pdev)
 		pdev->is_hotplug_bridge = 1;
 }
 
-static void set_pci_aer_firmware_first(struct pci_dev *pdev)
-{
-	if (acpi_hest_firmware_first_pci(pdev))
-		pdev->aer_firmware_first = 1;
-}
-
 #define LEGACY_IO_RESOURCE	(IORESOURCE_IO | IORESOURCE_PCI_FIXED)
 
 /**
@@ -939,7 +932,6 @@ int pci_setup_device(struct pci_dev *dev)
 	dev->multifunction = !!(hdr_type & 0x80);
 	dev->error_state = pci_channel_io_normal;
 	set_pcie_port_type(dev);
-	set_pci_aer_firmware_first(dev);
 
 	list_for_each_entry(slot, &dev->bus->slots, list)
 		if (PCI_SLOT(dev->devfn) == slot->number)

commit 45aa23b4cbd37408678c96cd113241860d3321f6
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Thu Apr 22 09:02:43 2010 -0600

    PCI: revert broken device warning
    
    This reverts c519a5a7dab2d.  That change added a warning about devices that
    didn't respond correctly when sizing BARs, which helped diagnose broken
    devices.  But the test wasn't specific enough, so it also complained about
    working devices with zero-size BARs, e.g.,
    https://bugzilla.kernel.org/show_bug.cgi?id=15822
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 882bd8d29fe3..c82548afcd5c 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -174,19 +174,14 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 	pci_read_config_dword(dev, pos, &sz);
 	pci_write_config_dword(dev, pos, l);
 
-	if (!sz)
-		goto fail;	/* BAR not implemented */
-
 	/*
 	 * All bits set in sz means the device isn't working properly.
-	 * If it's a memory BAR or a ROM, bit 0 must be clear; if it's
-	 * an io BAR, bit 1 must be clear.
+	 * If the BAR isn't implemented, all bits must be 0.  If it's a
+	 * memory BAR or a ROM, bit 0 must be clear; if it's an io BAR, bit
+	 * 1 must be clear.
 	 */
-	if (sz == 0xffffffff) {
-		dev_err(&dev->dev, "reg %x: invalid size %#x; broken device?\n",
-			pos, sz);
+	if (!sz || sz == 0xffffffff)
 		goto fail;
-	}
 
 	/*
 	 * I don't know how l can have all bits set.  Copied from old code.
@@ -249,17 +244,13 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 				   pos, res);
 		}
 	} else {
-		u32 size = pci_size(l, sz, mask);
+		sz = pci_size(l, sz, mask);
 
-		if (!size) {
-			dev_err(&dev->dev, "reg %x: invalid size "
-			        "(l %#x sz %#x mask %#x); broken device?",
-				pos, l, sz, mask);
+		if (!sz)
 			goto fail;
-		}
 
 		res->start = l;
-		res->end = l + size;
+		res->end = l + sz;
 
 		dev_printk(KERN_DEBUG, &dev->dev, "reg %x: %pR\n", pos, res);
 	}

commit c519a5a7dab2d8e9a114f003e2d369bcf8e913f3
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Fri Mar 19 14:56:27 2010 -0600

    PCI: complain about devices that seem to be broken
    
    If we can tell that a device isn't working correctly, we should tell
    the user to make debugging easier.  Otherwise, it can take a lot of
    work to determine whether the problem is in the driver, PCMCIA, PCI,
    hardware, etc., as in http://bugzilla.kernel.org/show_bug.cgi?id=12006
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index c82548afcd5c..882bd8d29fe3 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -174,14 +174,19 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 	pci_read_config_dword(dev, pos, &sz);
 	pci_write_config_dword(dev, pos, l);
 
+	if (!sz)
+		goto fail;	/* BAR not implemented */
+
 	/*
 	 * All bits set in sz means the device isn't working properly.
-	 * If the BAR isn't implemented, all bits must be 0.  If it's a
-	 * memory BAR or a ROM, bit 0 must be clear; if it's an io BAR, bit
-	 * 1 must be clear.
+	 * If it's a memory BAR or a ROM, bit 0 must be clear; if it's
+	 * an io BAR, bit 1 must be clear.
 	 */
-	if (!sz || sz == 0xffffffff)
+	if (sz == 0xffffffff) {
+		dev_err(&dev->dev, "reg %x: invalid size %#x; broken device?\n",
+			pos, sz);
 		goto fail;
+	}
 
 	/*
 	 * I don't know how l can have all bits set.  Copied from old code.
@@ -244,13 +249,17 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 				   pos, res);
 		}
 	} else {
-		sz = pci_size(l, sz, mask);
+		u32 size = pci_size(l, sz, mask);
 
-		if (!sz)
+		if (!size) {
+			dev_err(&dev->dev, "reg %x: invalid size "
+			        "(l %#x sz %#x mask %#x); broken device?",
+				pos, l, sz, mask);
 			goto fail;
+		}
 
 		res->start = l;
-		res->end = l + sz;
+		res->end = l + size;
 
 		dev_printk(KERN_DEBUG, &dev->dev, "reg %x: %pR\n", pos, res);
 	}

commit 7b8ff6da028232aadae6bcc7c7406c8966d0b3c4
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Mar 16 15:53:03 2010 -0600

    PCI: make disabled window printk style match the enabled ones
    
    No functional change; this just tweaks the changes from 349e1823a405
    so the new printks for disabled PCI-to-PCI bridge windows match the
    ones for the enabled windows.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    CC: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 7feacf521e14..c82548afcd5c 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -312,7 +312,7 @@ static void __devinit pci_read_bridge_io(struct pci_bus *child)
 		dev_printk(KERN_DEBUG, &dev->dev, "  bridge window %pR\n", res);
 	} else {
 		dev_printk(KERN_DEBUG, &dev->dev,
-			 "  bridge window [io  %04lx - %04lx] reg reading\n",
+			 "  bridge window [io  %#06lx-%#06lx] (disabled)\n",
 				 base, limit);
 	}
 }
@@ -336,7 +336,7 @@ static void __devinit pci_read_bridge_mmio(struct pci_bus *child)
 		dev_printk(KERN_DEBUG, &dev->dev, "  bridge window %pR\n", res);
 	} else {
 		dev_printk(KERN_DEBUG, &dev->dev,
-			"  bridge window [mem 0x%08lx - 0x%08lx] reg reading\n",
+			"  bridge window [mem %#010lx-%#010lx] (disabled)\n",
 					 base, limit + 0xfffff);
 	}
 }
@@ -387,7 +387,7 @@ static void __devinit pci_read_bridge_mmio_pref(struct pci_bus *child)
 		dev_printk(KERN_DEBUG, &dev->dev, "  bridge window %pR\n", res);
 	} else {
 		dev_printk(KERN_DEBUG, &dev->dev,
-		     "  bridge window [mem 0x%08lx - %08lx pref] reg reading\n",
+		     "  bridge window [mem %#010lx-%#010lx pref] (disabled)\n",
 					 base, limit + 0xfffff);
 	}
 }

commit 99ddd552fef7e6e3b7dc76ba8fee9ea5869d1e14
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Mar 16 15:52:58 2010 -0600

    PCI: break out primary/secondary/subordinate for readability
    
    No functional change; just add names for the primary/secondary/subordinate
    bus numbers read from config space rather than repeatedly masking/shifting.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 2a943090a3b7..7feacf521e14 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -673,16 +673,20 @@ int __devinit pci_scan_bridge(struct pci_bus *bus, struct pci_dev *dev, int max,
 	int is_cardbus = (dev->hdr_type == PCI_HEADER_TYPE_CARDBUS);
 	u32 buses, i, j = 0;
 	u16 bctl;
+	u8 primary, secondary, subordinate;
 	int broken = 0;
 
 	pci_read_config_dword(dev, PCI_PRIMARY_BUS, &buses);
+	primary = buses & 0xFF;
+	secondary = (buses >> 8) & 0xFF;
+	subordinate = (buses >> 16) & 0xFF;
 
-	dev_dbg(&dev->dev, "scanning behind bridge, config %06x, pass %d\n",
-		buses & 0xffffff, pass);
+	dev_dbg(&dev->dev, "scanning [bus %02x-%02x] behind bridge, pass %d\n",
+		secondary, subordinate, pass);
 
 	/* Check if setup is sensible at all */
 	if (!pass &&
-	    ((buses & 0xff) != bus->number || ((buses >> 8) & 0xff) <= bus->number)) {
+	    (primary != bus->number || secondary <= bus->number)) {
 		dev_dbg(&dev->dev, "bus configuration invalid, reconfiguring\n");
 		broken = 1;
 	}
@@ -693,15 +697,15 @@ int __devinit pci_scan_bridge(struct pci_bus *bus, struct pci_dev *dev, int max,
 	pci_write_config_word(dev, PCI_BRIDGE_CONTROL,
 			      bctl & ~PCI_BRIDGE_CTL_MASTER_ABORT);
 
-	if ((buses & 0xffff00) && !pcibios_assign_all_busses() && !is_cardbus && !broken) {
-		unsigned int cmax, busnr;
+	if ((secondary || subordinate) && !pcibios_assign_all_busses() &&
+	    !is_cardbus && !broken) {
+		unsigned int cmax;
 		/*
 		 * Bus already configured by firmware, process it in the first
 		 * pass and just note the configuration.
 		 */
 		if (pass)
 			goto out;
-		busnr = (buses >> 8) & 0xFF;
 
 		/*
 		 * If we already got to this bus through a different bridge,
@@ -710,13 +714,13 @@ int __devinit pci_scan_bridge(struct pci_bus *bus, struct pci_dev *dev, int max,
 		 * However, we continue to descend down the hierarchy and
 		 * scan remaining child buses.
 		 */
-		child = pci_find_bus(pci_domain_nr(bus), busnr);
+		child = pci_find_bus(pci_domain_nr(bus), secondary);
 		if (!child) {
-			child = pci_add_new_bus(bus, dev, busnr);
+			child = pci_add_new_bus(bus, dev, secondary);
 			if (!child)
 				goto out;
-			child->primary = buses & 0xFF;
-			child->subordinate = (buses >> 16) & 0xFF;
+			child->primary = primary;
+			child->subordinate = subordinate;
 			child->bridge_ctl = bctl;
 		}
 

commit a1e4d72cd3024999bfb6703092ea271438805c89
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Feb 8 19:16:33 2010 +0100

    PM: Allow PCI devices to suspend/resume asynchronously
    
    Set power.async_suspend for all PCI devices and PCIe port services,
    so that they can be suspended and resumed in parallel with other
    devices they don't depend on in a known way (i.e. devices which are
    not their parents or children).
    
    This only affects the "regular" suspend and resume stages, which
    means in particular that the restoration of the PCI devices' standard
    configuration registers during resume will still be carried out
    synchronously (at the "early" resume stage).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 270d069819f7..2a943090a3b7 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1436,6 +1436,7 @@ struct pci_bus * pci_create_bus(struct device *parent,
 	if (error)
 		goto dev_reg_err;
 	b->bridge = get_device(dev);
+	device_enable_async_suspend(b->bridge);
 
 	if (!parent)
 		set_dev_node(b->bridge, pcibus_to_node(b));

commit 2fe2abf896c1e7a0ee65faaf3ef0ce654848abbd
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Feb 23 10:24:36 2010 -0700

    PCI: augment bus resource table with a list
    
    Previously we used a table of size PCI_BUS_NUM_RESOURCES (16) for resources
    forwarded to a bus by its upstream bridge.  We've increased this size
    several times when the table overflowed.
    
    But there's no good limit on the number of resources because host bridges
    and subtractive decode bridges can forward any number of ranges to their
    secondary buses.
    
    This patch reduces the table to only PCI_BRIDGE_RESOURCE_NUM (4) entries,
    which corresponds to the number of windows a PCI-to-PCI (3) or CardBus (4)
    bridge can positively decode.  Any additional resources, e.g., PCI host
    bridge windows or subtractively-decoded regions, are kept in a list.
    
    I'd prefer a single list rather than this split table/list approach, but
    that requires simultaneous changes to every architecture.  This approach
    only requires immediate changes where we set up (a) host bridges with more
    than four windows and (b) subtractive-decode P2P bridges, and we can
    incrementally change other architectures to use the list.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 70c4ed2e67cc..270d069819f7 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -89,6 +89,7 @@ static void release_pcibus_dev(struct device *dev)
 
 	if (pci_bus->bridge)
 		put_device(pci_bus->bridge);
+	pci_bus_remove_resources(pci_bus);
 	kfree(pci_bus);
 }
 
@@ -394,6 +395,7 @@ static void __devinit pci_read_bridge_mmio_pref(struct pci_bus *child)
 void __devinit pci_read_bridge_bases(struct pci_bus *child)
 {
 	struct pci_dev *dev = child->self;
+	struct resource *res;
 	int i;
 
 	if (pci_is_root_bus(child))	/* It's a host bus, nothing to read */
@@ -403,17 +405,23 @@ void __devinit pci_read_bridge_bases(struct pci_bus *child)
 		 child->secondary, child->subordinate,
 		 dev->transparent ? " (subtractive decode)" : "");
 
+	pci_bus_remove_resources(child);
+	for (i = 0; i < PCI_BRIDGE_RESOURCE_NUM; i++)
+		child->resource[i] = &dev->resource[PCI_BRIDGE_RESOURCES+i];
+
 	pci_read_bridge_io(child);
 	pci_read_bridge_mmio(child);
 	pci_read_bridge_mmio_pref(child);
 
 	if (dev->transparent) {
-		for (i = 3; i < PCI_BUS_NUM_RESOURCES; i++) {
-			child->resource[i] = child->parent->resource[i - 3];
-			if (child->resource[i])
+		pci_bus_for_each_resource(child->parent, res, i) {
+			if (res) {
+				pci_bus_add_resource(child, res,
+						     PCI_SUBTRACTIVE_DECODE);
 				dev_printk(KERN_DEBUG, &dev->dev,
 					   "  bridge window %pR (subtractive decode)\n",
-					   child->resource[i]);
+					   res);
+			}
 		}
 	}
 }
@@ -428,6 +436,7 @@ static struct pci_bus * pci_alloc_bus(void)
 		INIT_LIST_HEAD(&b->children);
 		INIT_LIST_HEAD(&b->devices);
 		INIT_LIST_HEAD(&b->slots);
+		INIT_LIST_HEAD(&b->resources);
 		b->max_bus_speed = PCI_SPEED_UNKNOWN;
 		b->cur_bus_speed = PCI_SPEED_UNKNOWN;
 	}

commit 2adf75160b10bf3f09ed7d3d04e937f923fc557e
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Feb 23 10:24:26 2010 -0700

    PCI: read bridge windows before filling in subtractive decode resources
    
    No functional change; this fills in the bus subtractive decode resources
    after reading the bridge window information rather than before.  Also,
    print out the subtractive decode resources as we already do for the
    positive decode windows.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 4b47b4bfb066..70c4ed2e67cc 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -403,14 +403,19 @@ void __devinit pci_read_bridge_bases(struct pci_bus *child)
 		 child->secondary, child->subordinate,
 		 dev->transparent ? " (subtractive decode)" : "");
 
-	if (dev->transparent) {
-		for (i = 3; i < PCI_BUS_NUM_RESOURCES; i++)
-			child->resource[i] = child->parent->resource[i - 3];
-	}
-
 	pci_read_bridge_io(child);
 	pci_read_bridge_mmio(child);
 	pci_read_bridge_mmio_pref(child);
+
+	if (dev->transparent) {
+		for (i = 3; i < PCI_BUS_NUM_RESOURCES; i++) {
+			child->resource[i] = child->parent->resource[i - 3];
+			if (child->resource[i])
+				dev_printk(KERN_DEBUG, &dev->dev,
+					   "  bridge window %pR (subtractive decode)\n",
+					   child->resource[i]);
+		}
+	}
 }
 
 static struct pci_bus * pci_alloc_bus(void)

commit fa27b2d108fa49685129867a8c5b968344d6e197
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Feb 23 10:24:21 2010 -0700

    PCI: split up pci_read_bridge_bases()
    
    No functional change; this breaks up pci_read_bridge_bases() into separate
    pieces for the I/O, memory, and prefetchable memory windows, similar to how
    Yinghai recently split up pci_setup_bridge() in 68e84ff3bdc.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index d3009430eab6..4b47b4bfb066 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -281,26 +281,12 @@ static void pci_read_bases(struct pci_dev *dev, unsigned int howmany, int rom)
 	}
 }
 
-void __devinit pci_read_bridge_bases(struct pci_bus *child)
+static void __devinit pci_read_bridge_io(struct pci_bus *child)
 {
 	struct pci_dev *dev = child->self;
 	u8 io_base_lo, io_limit_lo;
-	u16 mem_base_lo, mem_limit_lo;
 	unsigned long base, limit;
 	struct resource *res;
-	int i;
-
-	if (pci_is_root_bus(child))	/* It's a host bus, nothing to read */
-		return;
-
-	dev_info(&dev->dev, "PCI bridge to [bus %02x-%02x]%s\n",
-		 child->secondary, child->subordinate,
-		 dev->transparent ? " (subtractive decode)": "");
-
-	if (dev->transparent) {
-		for(i = 3; i < PCI_BUS_NUM_RESOURCES; i++)
-			child->resource[i] = child->parent->resource[i - 3];
-	}
 
 	res = child->resource[0];
 	pci_read_config_byte(dev, PCI_IO_BASE, &io_base_lo);
@@ -328,6 +314,14 @@ void __devinit pci_read_bridge_bases(struct pci_bus *child)
 			 "  bridge window [io  %04lx - %04lx] reg reading\n",
 				 base, limit);
 	}
+}
+
+static void __devinit pci_read_bridge_mmio(struct pci_bus *child)
+{
+	struct pci_dev *dev = child->self;
+	u16 mem_base_lo, mem_limit_lo;
+	unsigned long base, limit;
+	struct resource *res;
 
 	res = child->resource[1];
 	pci_read_config_word(dev, PCI_MEMORY_BASE, &mem_base_lo);
@@ -344,6 +338,14 @@ void __devinit pci_read_bridge_bases(struct pci_bus *child)
 			"  bridge window [mem 0x%08lx - 0x%08lx] reg reading\n",
 					 base, limit + 0xfffff);
 	}
+}
+
+static void __devinit pci_read_bridge_mmio_pref(struct pci_bus *child)
+{
+	struct pci_dev *dev = child->self;
+	u16 mem_base_lo, mem_limit_lo;
+	unsigned long base, limit;
+	struct resource *res;
 
 	res = child->resource[2];
 	pci_read_config_word(dev, PCI_PREF_MEMORY_BASE, &mem_base_lo);
@@ -389,6 +391,28 @@ void __devinit pci_read_bridge_bases(struct pci_bus *child)
 	}
 }
 
+void __devinit pci_read_bridge_bases(struct pci_bus *child)
+{
+	struct pci_dev *dev = child->self;
+	int i;
+
+	if (pci_is_root_bus(child))	/* It's a host bus, nothing to read */
+		return;
+
+	dev_info(&dev->dev, "PCI bridge to [bus %02x-%02x]%s\n",
+		 child->secondary, child->subordinate,
+		 dev->transparent ? " (subtractive decode)" : "");
+
+	if (dev->transparent) {
+		for (i = 3; i < PCI_BUS_NUM_RESOURCES; i++)
+			child->resource[i] = child->parent->resource[i - 3];
+	}
+
+	pci_read_bridge_io(child);
+	pci_read_bridge_mmio(child);
+	pci_read_bridge_mmio_pref(child);
+}
+
 static struct pci_bus * pci_alloc_bus(void)
 {
 	struct pci_bus *b;

commit cd81e1ea1a4cda94aa5f3e942301cf0da497c262
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Fri Jan 22 01:02:22 2010 -0800

    PCI: reject mmio ranges starting at 0 on pci_bridge read
    
    We already track unassigned resources in struct resource, and this
    prevents us from overwriting resource flags and info in the unassigned
    case.
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 233d1c275d96..d3009430eab6 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -316,13 +316,17 @@ void __devinit pci_read_bridge_bases(struct pci_bus *child)
 		limit |= (io_limit_hi << 16);
 	}
 
-	if (base <= limit) {
+	if (base && base <= limit) {
 		res->flags = (io_base_lo & PCI_IO_RANGE_TYPE_MASK) | IORESOURCE_IO;
 		if (!res->start)
 			res->start = base;
 		if (!res->end)
 			res->end = limit + 0xfff;
 		dev_printk(KERN_DEBUG, &dev->dev, "  bridge window %pR\n", res);
+	} else {
+		dev_printk(KERN_DEBUG, &dev->dev,
+			 "  bridge window [io  %04lx - %04lx] reg reading\n",
+				 base, limit);
 	}
 
 	res = child->resource[1];
@@ -330,11 +334,15 @@ void __devinit pci_read_bridge_bases(struct pci_bus *child)
 	pci_read_config_word(dev, PCI_MEMORY_LIMIT, &mem_limit_lo);
 	base = (mem_base_lo & PCI_MEMORY_RANGE_MASK) << 16;
 	limit = (mem_limit_lo & PCI_MEMORY_RANGE_MASK) << 16;
-	if (base <= limit) {
+	if (base && base <= limit) {
 		res->flags = (mem_base_lo & PCI_MEMORY_RANGE_TYPE_MASK) | IORESOURCE_MEM;
 		res->start = base;
 		res->end = limit + 0xfffff;
 		dev_printk(KERN_DEBUG, &dev->dev, "  bridge window %pR\n", res);
+	} else {
+		dev_printk(KERN_DEBUG, &dev->dev,
+			"  bridge window [mem 0x%08lx - 0x%08lx] reg reading\n",
+					 base, limit + 0xfffff);
 	}
 
 	res = child->resource[2];
@@ -366,7 +374,7 @@ void __devinit pci_read_bridge_bases(struct pci_bus *child)
 #endif
 		}
 	}
-	if (base <= limit) {
+	if (base && base <= limit) {
 		res->flags = (mem_base_lo & PCI_PREF_RANGE_TYPE_MASK) |
 					 IORESOURCE_MEM | IORESOURCE_PREFETCH;
 		if (res->flags & PCI_PREF_RANGE_TYPE_64)
@@ -374,6 +382,10 @@ void __devinit pci_read_bridge_bases(struct pci_bus *child)
 		res->start = base;
 		res->end = limit + 0xfffff;
 		dev_printk(KERN_DEBUG, &dev->dev, "  bridge window %pR\n", res);
+	} else {
+		dev_printk(KERN_DEBUG, &dev->dev,
+		     "  bridge window [mem 0x%08lx - %08lx pref] reg reading\n",
+					 base, limit + 0xfffff);
 	}
 }
 

commit 4fb88c1a28a8dc302bdc09858e7cdafc97bef794
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Sun Jan 17 14:01:41 2010 -0700

    PCI: Make pci_scan_slot more robust
    
    Yinghai pointed out that the new pci_scan_slot() crashes when called
    on an ARI-capable slot that is empty.  Fix this by exiting early from
    pci_scan_slot if there is no device in the slot.
    
    Also make next_ari_func() robust against devices not existing in case
    the ARI capability is corrupt.  ARI also requires that the devices be
    listed in order, so if we find a function listed that is out of order,
    stop scanning to prevent loops.
    
    Signed-off-by: Matthew Wilcox <matthew@wil.cx>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 9672760c7ade..233d1c275d96 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1222,11 +1222,19 @@ EXPORT_SYMBOL(pci_scan_single_device);
 static unsigned next_ari_fn(struct pci_dev *dev, unsigned fn)
 {
 	u16 cap;
-	unsigned pos = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ARI);
+	unsigned pos, next_fn;
+
+	if (!dev)
+		return 0;
+
+	pos = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ARI);
 	if (!pos)
 		return 0;
 	pci_read_config_word(dev, pos + 4, &cap);
-	return cap >> 8;
+	next_fn = cap >> 8;
+	if (next_fn <= fn)
+		return 0;
+	return next_fn;
 }
 
 static unsigned next_trad_fn(struct pci_dev *dev, unsigned fn)
@@ -1271,12 +1279,14 @@ int pci_scan_slot(struct pci_bus *bus, int devfn)
 		return 0; /* Already scanned the entire slot */
 
 	dev = pci_scan_single_device(bus, devfn);
-	if (dev && !dev->is_added)	/* new device? */
+	if (!dev)
+		return 0;
+	if (!dev->is_added)
 		nr++;
 
 	if (pci_ari_enabled(bus))
 		next_fn = next_ari_fn;
-	else if (dev && dev->multifunction)
+	else if (dev->multifunction)
 		next_fn = next_trad_fn;
 
 	for (fn = next_fn(dev, 0); fn > 0; fn = next_fn(dev, fn)) {

commit 9dfd97fe12f79ec8b68feb63912a4ef2f31f571a
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Sun Dec 13 08:11:35 2009 -0500

    PCI: Add support for reporting PCIe 3.0 speeds
    
    Add the 8.0 GT/s speed.
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 2803ab96a98c..9672760c7ade 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -416,7 +416,7 @@ static unsigned char pcie_link_speed[] = {
 	PCI_SPEED_UNKNOWN,		/* 0 */
 	PCIE_SPEED_2_5GT,		/* 1 */
 	PCIE_SPEED_5_0GT,		/* 2 */
-	PCI_SPEED_UNKNOWN,		/* 3 */
+	PCIE_SPEED_8_0GT,		/* 3 */
 	PCI_SPEED_UNKNOWN,		/* 4 */
 	PCI_SPEED_UNKNOWN,		/* 5 */
 	PCI_SPEED_UNKNOWN,		/* 6 */

commit 45b4cdd57ef0e57555b2ab61b584784819b39365
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Sun Dec 13 08:11:34 2009 -0500

    PCI: Add support for AGP in cur/max bus speed
    
    Take advantage of some gaps in the table to fit in support for AGP speeds.
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 188ee9cf0605..2803ab96a98c 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -437,11 +437,56 @@ void pcie_update_link_speed(struct pci_bus *bus, u16 linksta)
 }
 EXPORT_SYMBOL_GPL(pcie_update_link_speed);
 
+static unsigned char agp_speeds[] = {
+	AGP_UNKNOWN,
+	AGP_1X,
+	AGP_2X,
+	AGP_4X,
+	AGP_8X
+};
+
+static enum pci_bus_speed agp_speed(int agp3, int agpstat)
+{
+	int index = 0;
+
+	if (agpstat & 4)
+		index = 3;
+	else if (agpstat & 2)
+		index = 2;
+	else if (agpstat & 1)
+		index = 1;
+	else
+		goto out;
+	
+	if (agp3) {
+		index += 2;
+		if (index == 5)
+			index = 0;
+	}
+
+ out:
+	return agp_speeds[index];
+}
+
+
 static void pci_set_bus_speed(struct pci_bus *bus)
 {
 	struct pci_dev *bridge = bus->self;
 	int pos;
 
+	pos = pci_find_capability(bridge, PCI_CAP_ID_AGP);
+	if (!pos)
+		pos = pci_find_capability(bridge, PCI_CAP_ID_AGP3);
+	if (pos) {
+		u32 agpstat, agpcmd;
+
+		pci_read_config_dword(bridge, pos + PCI_AGP_STATUS, &agpstat);
+		bus->max_bus_speed = agp_speed(agpstat & 8, agpstat & 7);
+
+		pci_read_config_dword(bridge, pos + PCI_AGP_COMMAND, &agpcmd);
+		bus->cur_bus_speed = agp_speed(agpstat & 8, agpcmd & 7);
+	}
+
 	pos = pci_find_capability(bridge, PCI_CAP_ID_PCIX);
 	if (pos) {
 		u16 status;

commit 9be60ca0497a2563662fde4c9007841c3b79a742
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Sun Dec 13 08:11:33 2009 -0500

    PCI: Add support for detection of PCIe and PCI-X bus speeds
    
    Both PCIe and PCI-X bridges report their secondary bus speed in their
    respective capabilities.
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 51cf8982fec7..188ee9cf0605 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -393,6 +393,25 @@ static struct pci_bus * pci_alloc_bus(void)
 	return b;
 }
 
+static unsigned char pcix_bus_speed[] = {
+	PCI_SPEED_UNKNOWN,		/* 0 */
+	PCI_SPEED_66MHz_PCIX,		/* 1 */
+	PCI_SPEED_100MHz_PCIX,		/* 2 */
+	PCI_SPEED_133MHz_PCIX,		/* 3 */
+	PCI_SPEED_UNKNOWN,		/* 4 */
+	PCI_SPEED_66MHz_PCIX_ECC,	/* 5 */
+	PCI_SPEED_100MHz_PCIX_ECC,	/* 6 */
+	PCI_SPEED_133MHz_PCIX_ECC,	/* 7 */
+	PCI_SPEED_UNKNOWN,		/* 8 */
+	PCI_SPEED_66MHz_PCIX_266,	/* 9 */
+	PCI_SPEED_100MHz_PCIX_266,	/* A */
+	PCI_SPEED_133MHz_PCIX_266,	/* B */
+	PCI_SPEED_UNKNOWN,		/* C */
+	PCI_SPEED_66MHz_PCIX_533,	/* D */
+	PCI_SPEED_100MHz_PCIX_533,	/* E */
+	PCI_SPEED_133MHz_PCIX_533	/* F */
+};
+
 static unsigned char pcie_link_speed[] = {
 	PCI_SPEED_UNKNOWN,		/* 0 */
 	PCIE_SPEED_2_5GT,		/* 1 */
@@ -418,6 +437,51 @@ void pcie_update_link_speed(struct pci_bus *bus, u16 linksta)
 }
 EXPORT_SYMBOL_GPL(pcie_update_link_speed);
 
+static void pci_set_bus_speed(struct pci_bus *bus)
+{
+	struct pci_dev *bridge = bus->self;
+	int pos;
+
+	pos = pci_find_capability(bridge, PCI_CAP_ID_PCIX);
+	if (pos) {
+		u16 status;
+		enum pci_bus_speed max;
+		pci_read_config_word(bridge, pos + 2, &status);
+
+		if (status & 0x8000) {
+			max = PCI_SPEED_133MHz_PCIX_533;
+		} else if (status & 0x4000) {
+			max = PCI_SPEED_133MHz_PCIX_266;
+		} else if (status & 0x0002) {
+			if (((status >> 12) & 0x3) == 2) {
+				max = PCI_SPEED_133MHz_PCIX_ECC;
+			} else {
+				max = PCI_SPEED_133MHz_PCIX;
+			}
+		} else {
+			max = PCI_SPEED_66MHz_PCIX;
+		}
+
+		bus->max_bus_speed = max;
+		bus->cur_bus_speed = pcix_bus_speed[(status >> 6) & 0xf];
+
+		return;
+	}
+
+	pos = pci_find_capability(bridge, PCI_CAP_ID_EXP);
+	if (pos) {
+		u32 linkcap;
+		u16 linksta;
+
+		pci_read_config_dword(bridge, pos + PCI_EXP_LNKCAP, &linkcap);
+		bus->max_bus_speed = pcie_link_speed[linkcap & 0xf];
+
+		pci_read_config_word(bridge, pos + PCI_EXP_LNKSTA, &linksta);
+		pcie_update_link_speed(bus, linksta);
+	}
+}
+
+
 static struct pci_bus *pci_alloc_child_bus(struct pci_bus *parent,
 					   struct pci_dev *bridge, int busnr)
 {
@@ -457,6 +521,8 @@ static struct pci_bus *pci_alloc_child_bus(struct pci_bus *parent,
 	child->self = bridge;
 	child->bridge = get_device(&bridge->dev);
 
+	pci_set_bus_speed(child);
+
 	/* Set up default resource pointers and names.. */
 	for (i = 0; i < PCI_BRIDGE_RESOURCE_NUM; i++) {
 		child->resource[i] = &bridge->resource[PCI_BRIDGE_RESOURCES+i];

commit 3749c51ac6c1560aa1cb1520066bed84c6f8152a
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Sun Dec 13 08:11:32 2009 -0500

    PCI: Make current and maximum bus speeds part of the PCI core
    
    Move the max_bus_speed and cur_bus_speed into the pci_bus.  Expose the
    values through the PCI slot driver instead of the hotplug slot driver.
    Update all the hotplug drivers to use the pci_bus instead of their own
    data structures.
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index dd64310a735e..51cf8982fec7 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -387,10 +387,37 @@ static struct pci_bus * pci_alloc_bus(void)
 		INIT_LIST_HEAD(&b->children);
 		INIT_LIST_HEAD(&b->devices);
 		INIT_LIST_HEAD(&b->slots);
+		b->max_bus_speed = PCI_SPEED_UNKNOWN;
+		b->cur_bus_speed = PCI_SPEED_UNKNOWN;
 	}
 	return b;
 }
 
+static unsigned char pcie_link_speed[] = {
+	PCI_SPEED_UNKNOWN,		/* 0 */
+	PCIE_SPEED_2_5GT,		/* 1 */
+	PCIE_SPEED_5_0GT,		/* 2 */
+	PCI_SPEED_UNKNOWN,		/* 3 */
+	PCI_SPEED_UNKNOWN,		/* 4 */
+	PCI_SPEED_UNKNOWN,		/* 5 */
+	PCI_SPEED_UNKNOWN,		/* 6 */
+	PCI_SPEED_UNKNOWN,		/* 7 */
+	PCI_SPEED_UNKNOWN,		/* 8 */
+	PCI_SPEED_UNKNOWN,		/* 9 */
+	PCI_SPEED_UNKNOWN,		/* A */
+	PCI_SPEED_UNKNOWN,		/* B */
+	PCI_SPEED_UNKNOWN,		/* C */
+	PCI_SPEED_UNKNOWN,		/* D */
+	PCI_SPEED_UNKNOWN,		/* E */
+	PCI_SPEED_UNKNOWN		/* F */
+};
+
+void pcie_update_link_speed(struct pci_bus *bus, u16 linksta)
+{
+	bus->cur_bus_speed = pcie_link_speed[linksta & 0xf];
+}
+EXPORT_SYMBOL_GPL(pcie_update_link_speed);
+
 static struct pci_bus *pci_alloc_child_bus(struct pci_bus *parent,
 					   struct pci_dev *bridge, int busnr)
 {

commit f07852d6442c46c50b59c7e2acc8a1b291f9ab6d
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Sun Dec 13 08:10:02 2009 -0500

    PCI: Rewrite pci_scan_slot
    
    The Alternate Routing-ID Interpretation capability allows a single device
    to have up to 256 functions.  They can be populated sparsely, so the
    current technique of scanning every eighth function is not guaranteed
    to find them all.  By introducing a 'next_fn' function pointer, we can
    use the linked list of functions in the ARI capability to scan all the
    functions which exist.
    
    We can then speed up the pci_scan_slot by skipping the scan of subsequent
    devfns for PCIe devices which are the direct children of Root Ports or
    Downstream Ports.  These devices are only permitted to implement device
    0, unless they are ARI devices, in which case they'll be scanned by the
    ARI code above.
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 446e4a94d7d3..dd64310a735e 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1081,6 +1081,37 @@ struct pci_dev *__ref pci_scan_single_device(struct pci_bus *bus, int devfn)
 }
 EXPORT_SYMBOL(pci_scan_single_device);
 
+static unsigned next_ari_fn(struct pci_dev *dev, unsigned fn)
+{
+	u16 cap;
+	unsigned pos = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ARI);
+	if (!pos)
+		return 0;
+	pci_read_config_word(dev, pos + 4, &cap);
+	return cap >> 8;
+}
+
+static unsigned next_trad_fn(struct pci_dev *dev, unsigned fn)
+{
+	return (fn + 1) % 8;
+}
+
+static unsigned no_next_fn(struct pci_dev *dev, unsigned fn)
+{
+	return 0;
+}
+
+static int only_one_child(struct pci_bus *bus)
+{
+	struct pci_dev *parent = bus->self;
+	if (!parent || !pci_is_pcie(parent))
+		return 0;
+	if (parent->pcie_type == PCI_EXP_TYPE_ROOT_PORT ||
+	    parent->pcie_type == PCI_EXP_TYPE_DOWNSTREAM)
+		return 1;
+	return 0;
+}
+
 /**
  * pci_scan_slot - scan a PCI slot on a bus for devices.
  * @bus: PCI bus to scan
@@ -1094,21 +1125,28 @@ EXPORT_SYMBOL(pci_scan_single_device);
  */
 int pci_scan_slot(struct pci_bus *bus, int devfn)
 {
-	int fn, nr = 0;
+	unsigned fn, nr = 0;
 	struct pci_dev *dev;
+	unsigned (*next_fn)(struct pci_dev *, unsigned) = no_next_fn;
+
+	if (only_one_child(bus) && (devfn > 0))
+		return 0; /* Already scanned the entire slot */
 
 	dev = pci_scan_single_device(bus, devfn);
 	if (dev && !dev->is_added)	/* new device? */
 		nr++;
 
-	if (dev && dev->multifunction) {
-		for (fn = 1; fn < 8; fn++) {
-			dev = pci_scan_single_device(bus, devfn + fn);
-			if (dev) {
-				if (!dev->is_added)
-					nr++;
-				dev->multifunction = 1;
-			}
+	if (pci_ari_enabled(bus))
+		next_fn = next_ari_fn;
+	else if (dev && dev->multifunction)
+		next_fn = next_trad_fn;
+
+	for (fn = next_fn(dev, 0); fn > 0; fn = next_fn(dev, fn)) {
+		dev = pci_scan_single_device(bus, devfn + fn);
+		if (dev) {
+			if (!dev->is_added)
+				nr++;
+			dev->multifunction = 1;
 		}
 	}
 

commit bb209c8287d2d55ec4a67e3933346e0a3ee0da76
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Tue Jan 26 17:10:03 2010 +0000

    powerpc/pci: Add calls to set_pcie_port_type() and set_pcie_hotplug_bridge()
    
    We are missing these when building the pci_dev from scratch off
    the Open Firmware device-tree
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Acked-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 98ffb2de22e9..446e4a94d7d3 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -681,7 +681,7 @@ static void pci_read_irq(struct pci_dev *dev)
 	dev->irq = irq;
 }
 
-static void set_pcie_port_type(struct pci_dev *pdev)
+void set_pcie_port_type(struct pci_dev *pdev)
 {
 	int pos;
 	u16 reg16;
@@ -695,7 +695,7 @@ static void set_pcie_port_type(struct pci_dev *pdev)
 	pdev->pcie_type = (reg16 & PCI_EXP_FLAGS_TYPE) >> 4;
 }
 
-static void set_pcie_hotplug_bridge(struct pci_dev *pdev)
+void set_pcie_hotplug_bridge(struct pci_dev *pdev)
 {
 	int pos;
 	u16 reg16;

commit 5d990b627537e59a3a2f039ff588a4750e9c1a6a
Author: Chris Wright <chrisw@sous-sol.org>
Date:   Fri Dec 4 12:15:21 2009 -0800

    PCI: add pci_request_acs
    
    Commit ae21ee65e8bc228416bbcc8a1da01c56a847a60c "PCI: acs p2p upsteram
    forwarding enabling" doesn't actually enable ACS.
    
    Add a function to pci core to allow an IOMMU to request that ACS
    be enabled.  The existing mechanism of using iommu_found() in the pci
    core to know when ACS should be enabled doesn't actually work due to
    initialization order;  iommu has only been detected not initialized.
    
    Have Intel and AMD IOMMUs request ACS, and Xen does as well during early
    init of dom0.
    
    Cc: Allen Kay <allen.m.kay@intel.com>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: Jeremy Fitzhardinge <jeremy@goop.org>
    Cc: Joerg Roedel <joerg.roedel@amd.com>
    Signed-off-by: Chris Wright <chrisw@sous-sol.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 2fdffc02a308..98ffb2de22e9 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -10,9 +10,7 @@
 #include <linux/module.h>
 #include <linux/cpumask.h>
 #include <linux/pci-aspm.h>
-#include <linux/iommu.h>
 #include <acpi/acpi_hest.h>
-#include <xen/xen.h>
 #include "pci.h"
 
 #define CARDBUS_LATENCY_TIMER	176	/* secondary latency timer */
@@ -1029,8 +1027,7 @@ static void pci_init_capabilities(struct pci_dev *dev)
 	pci_iov_init(dev);
 
 	/* Enable ACS P2P upstream forwarding */
-	if (iommu_found() || xen_initial_domain())
-		pci_enable_acs(dev);
+	pci_enable_acs(dev);
 }
 
 void pci_device_add(struct pci_dev *dev, struct pci_bus *bus)

commit 06a1cbafb253c4c60d6a54a994887f5fbceabcc0
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Wed Nov 11 14:30:56 2009 +0900

    PCI: use pci_pcie_cap() in pci core
    
    Use pcie_cap() instead of pci_find_capability() to get PCIe capability
    offset in PCI core code. This avoids unnecessary search in PCI
    configuration space.
    
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 54b9f1501487..2fdffc02a308 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -703,7 +703,7 @@ static void set_pcie_hotplug_bridge(struct pci_dev *pdev)
 	u16 reg16;
 	u32 reg32;
 
-	pos = pci_find_capability(pdev, PCI_CAP_ID_EXP);
+	pos = pci_pcie_cap(pdev);
 	if (!pos)
 		return;
 	pci_read_config_word(pdev, pos + PCI_EXP_FLAGS, &reg16);
@@ -920,7 +920,7 @@ int pci_cfg_space_size(struct pci_dev *dev)
 	if (class == PCI_CLASS_BRIDGE_HOST)
 		return pci_cfg_space_size_ext(dev);
 
-	pos = pci_find_capability(dev, PCI_CAP_ID_EXP);
+	pos = pci_pcie_cap(dev);
 	if (!pos) {
 		pos = pci_find_capability(dev, PCI_CAP_ID_PCIX);
 		if (!pos)

commit 0efea0006335a2425b1a12a2ad35efad626fe353
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Thu Nov 5 12:05:11 2009 +0900

    PCI: cache PCIe capability offset
    
    There are a lot of codes that searches PCI express capability offset
    in the PCI configuration space using pci_find_capability(). Caching it
    in the struct pci_dev will reduce unncecessary search. This patch adds
    an additional 'pcie_cap' fields into struct pci_dev, which is
    initialized at pci device scan time (in set_pcie_port_type()).
    
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 623086f9ba84..54b9f1501487 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -692,6 +692,7 @@ static void set_pcie_port_type(struct pci_dev *pdev)
 	if (!pos)
 		return;
 	pdev->is_pcie = 1;
+	pdev->pcie_cap = pos;
 	pci_read_config_word(pdev, pos + PCI_EXP_FLAGS, &reg16);
 	pdev->pcie_type = (reg16 & PCI_EXP_FLAGS_TYPE) >> 4;
 }

commit 865df576e8fc70daf297b53e61a4fbefc719d065
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Wed Nov 4 10:32:57 2009 -0700

    PCI: improve discovery/configuration messages
    
    This makes PCI resource management messages more consistent and adds a few
    new messages to aid debugging.
    
    Whenever we assign resources to a device, update a BAR, or change a
    bridge aperture, it's worth noting it.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index a7fdc4344cef..623086f9ba84 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -226,7 +226,8 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 			goto fail;
 
 		if ((sizeof(resource_size_t) < 8) && (sz64 > 0x100000000ULL)) {
-			dev_err(&dev->dev, "can't handle 64-bit BAR\n");
+			dev_err(&dev->dev, "reg %x: can't handle 64-bit BAR\n",
+				pos);
 			goto fail;
 		}
 
@@ -294,8 +295,11 @@ void __devinit pci_read_bridge_bases(struct pci_bus *child)
 	if (pci_is_root_bus(child))	/* It's a host bus, nothing to read */
 		return;
 
+	dev_info(&dev->dev, "PCI bridge to [bus %02x-%02x]%s\n",
+		 child->secondary, child->subordinate,
+		 dev->transparent ? " (subtractive decode)": "");
+
 	if (dev->transparent) {
-		dev_info(&dev->dev, "transparent bridge\n");
 		for(i = 3; i < PCI_BUS_NUM_RESOURCES; i++)
 			child->resource[i] = child->parent->resource[i - 3];
 	}
@@ -645,13 +649,14 @@ int __devinit pci_scan_bridge(struct pci_bus *bus, struct pci_dev *dev, int max,
 		    (child->number > bus->subordinate) ||
 		    (child->number < bus->number) ||
 		    (child->subordinate < bus->number)) {
-			pr_debug("PCI: Bus #%02x (-#%02x) is %s "
-				"hidden behind%s bridge #%02x (-#%02x)\n",
+			dev_info(&child->dev, "[bus %02x-%02x] %s "
+				"hidden behind%s bridge %s [bus %02x-%02x]\n",
 				child->number, child->subordinate,
 				(bus->number > child->subordinate &&
 				 bus->subordinate < child->number) ?
 					"wholly" : "partially",
 				bus->self->transparent ? " transparent" : "",
+				dev_name(&bus->dev),
 				bus->number, bus->subordinate);
 		}
 		bus = bus->parent;

commit 0207c356ef0e2bae6ce4603080d42c130d7debc6
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Wed Nov 4 10:32:52 2009 -0700

    PCI: replace pr_debug with dev_dbg
    
    Since we have a struct device, we might as well use dev_printk.  Note that
    both pr_debug() and dev_dbg() are completely compiled out unless DEBUG or
    DYNAMIC_DEBUG is defined.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 4c4aca53ae09..a7fdc4344cef 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1121,7 +1121,7 @@ unsigned int __devinit pci_scan_child_bus(struct pci_bus *bus)
 	unsigned int devfn, pass, max = bus->secondary;
 	struct pci_dev *dev;
 
-	pr_debug("PCI: Scanning bus %04x:%02x\n", pci_domain_nr(bus), bus->number);
+	dev_dbg(&bus->dev, "scanning bus\n");
 
 	/* Go find them, Rover! */
 	for (devfn = 0; devfn < 0x100; devfn += 8)
@@ -1135,8 +1135,7 @@ unsigned int __devinit pci_scan_child_bus(struct pci_bus *bus)
 	 * all PCI-to-PCI bridges on this bus.
 	 */
 	if (!bus->is_added) {
-		pr_debug("PCI: Fixups for bus %04x:%02x\n",
-			 pci_domain_nr(bus), bus->number);
+		dev_dbg(&bus->dev, "fixups for bus\n");
 		pcibios_fixup_bus(bus);
 		if (pci_is_root_bus(bus))
 			bus->is_added = 1;
@@ -1156,8 +1155,7 @@ unsigned int __devinit pci_scan_child_bus(struct pci_bus *bus)
 	 *
 	 * Return how far we've got finding sub-buses.
 	 */
-	pr_debug("PCI: Bus scan for %04x:%02x returning with max=%02x\n",
-		pci_domain_nr(bus), bus->number, max);
+	dev_dbg(&bus->dev, "bus scan returning with max=%02x\n", max);
 	return max;
 }
 
@@ -1165,7 +1163,7 @@ struct pci_bus * pci_create_bus(struct device *parent,
 		int bus, struct pci_ops *ops, void *sysdata)
 {
 	int error;
-	struct pci_bus *b;
+	struct pci_bus *b, *b2;
 	struct device *dev;
 
 	b = pci_alloc_bus();
@@ -1181,9 +1179,10 @@ struct pci_bus * pci_create_bus(struct device *parent,
 	b->sysdata = sysdata;
 	b->ops = ops;
 
-	if (pci_find_bus(pci_domain_nr(b), bus)) {
+	b2 = pci_find_bus(pci_domain_nr(b), bus);
+	if (b2) {
 		/* If we already got to this bus through a different bridge, ignore it */
-		pr_debug("PCI: Bus %04x:%02x already known\n", pci_domain_nr(b), bus);
+		dev_dbg(&b2->dev, "bus already known\n");
 		goto err_out;
 	}
 

commit c7dabef8a2c59e6a3de9d66fc35fb6a43ef7172d
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Oct 27 13:26:47 2009 -0600

    vsprintf: use %pR, %pr instead of %pRt, %pRf
    
    Jesse accidentally applied v1 [1] of the patchset instead of v2 [2].  This
    is the diff between v1 and v2.
    
    The changes in this patch are:
        - tidied vsprintf stack buffer to shrink and compute size more
          accurately
        - use %pR for decoding and %pr for "raw" (with type and flags) instead
          of adding %pRt and %pRf
    
    [1] http://lkml.org/lkml/2009/10/6/491
    [2] http://lkml.org/lkml/2009/10/13/441
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 4842b09b7f3c..4c4aca53ae09 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -225,12 +225,13 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 		if (!sz64)
 			goto fail;
 
-		res->flags |= IORESOURCE_MEM_64;
-
 		if ((sizeof(resource_size_t) < 8) && (sz64 > 0x100000000ULL)) {
 			dev_err(&dev->dev, "can't handle 64-bit BAR\n");
 			goto fail;
-		} else if ((sizeof(resource_size_t) < 8) && l) {
+		}
+
+		res->flags |= IORESOURCE_MEM_64;
+		if ((sizeof(resource_size_t) < 8) && l) {
 			/* Address above 32-bit boundary; disable the BAR */
 			pci_write_config_dword(dev, pos, 0);
 			pci_write_config_dword(dev, pos + 4, 0);
@@ -239,7 +240,7 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 		} else {
 			res->start = l64;
 			res->end = l64 + sz64;
-			dev_printk(KERN_DEBUG, &dev->dev, "reg %x: %pRt\n",
+			dev_printk(KERN_DEBUG, &dev->dev, "reg %x: %pR\n",
 				   pos, res);
 		}
 	} else {
@@ -251,7 +252,7 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 		res->start = l;
 		res->end = l + sz;
 
-		dev_printk(KERN_DEBUG, &dev->dev, "reg %x: %pRt\n", pos, res);
+		dev_printk(KERN_DEBUG, &dev->dev, "reg %x: %pR\n", pos, res);
 	}
 
  out:
@@ -319,7 +320,7 @@ void __devinit pci_read_bridge_bases(struct pci_bus *child)
 			res->start = base;
 		if (!res->end)
 			res->end = limit + 0xfff;
-		dev_printk(KERN_DEBUG, &dev->dev, "bridge window: %pRt\n", res);
+		dev_printk(KERN_DEBUG, &dev->dev, "  bridge window %pR\n", res);
 	}
 
 	res = child->resource[1];
@@ -331,7 +332,7 @@ void __devinit pci_read_bridge_bases(struct pci_bus *child)
 		res->flags = (mem_base_lo & PCI_MEMORY_RANGE_TYPE_MASK) | IORESOURCE_MEM;
 		res->start = base;
 		res->end = limit + 0xfffff;
-		dev_printk(KERN_DEBUG, &dev->dev, "bridge window: %pRt\n", res);
+		dev_printk(KERN_DEBUG, &dev->dev, "  bridge window %pR\n", res);
 	}
 
 	res = child->resource[2];
@@ -370,7 +371,7 @@ void __devinit pci_read_bridge_bases(struct pci_bus *child)
 			res->flags |= IORESOURCE_MEM_64;
 		res->start = base;
 		res->end = limit + 0xfffff;
-		dev_printk(KERN_DEBUG, &dev->dev, "bridge window: %pRt\n", res);
+		dev_printk(KERN_DEBUG, &dev->dev, "  bridge window %pR\n", res);
 	}
 }
 

commit bc577d2bb98cc44371287fce3e892d26ad4050a8
Author: Gabe Black <gabe.black@ni.com>
Date:   Tue Oct 6 10:45:19 2009 -0500

    PCI: populate subsystem vendor and device IDs for PCI bridges
    
    Change to populate the subsystem vendor and subsytem device IDs for
    PCI-PCI bridges that implement the PCI Subsystem Vendor ID capability.
    Previously bridges left subsystem vendor IDs unpopulated.
    
    Signed-off-by: Gabe Black <gabe.black@ni.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 118463befef0..4842b09b7f3c 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -730,6 +730,7 @@ int pci_setup_device(struct pci_dev *dev)
 	u32 class;
 	u8 hdr_type;
 	struct pci_slot *slot;
+	int pos = 0;
 
 	if (pci_read_config_byte(dev, PCI_HEADER_TYPE, &hdr_type))
 		return -EIO;
@@ -822,6 +823,11 @@ int pci_setup_device(struct pci_dev *dev)
 		dev->transparent = ((dev->class & 0xff) == 1);
 		pci_read_bases(dev, 2, PCI_ROM_ADDRESS1);
 		set_pcie_hotplug_bridge(dev);
+		pos = pci_find_capability(dev, PCI_CAP_ID_SSVID);
+		if (pos) {
+			pci_read_config_word(dev, pos + PCI_SSVID_VENDOR_ID, &dev->subsystem_vendor);
+			pci_read_config_word(dev, pos + PCI_SSVID_DEVICE_ID, &dev->subsystem_device);
+		}
 		break;
 
 	case PCI_HEADER_TYPE_CARDBUS:		    /* CardBus bridge header */

commit 0584396157ad2d008e2cc76b4ed6254151183a25
Author: Matt Domsch <Matt_Domsch@dell.com>
Date:   Mon Nov 2 11:51:24 2009 -0600

    PCI: PCIe AER: honor ACPI HEST FIRMWARE FIRST mode
    
    Feedback from Hidetoshi Seto and Kenji Kaneshige incorporated.  This
    correctly handles PCI-X bridges, PCIe root ports and endpoints, and
    prints debug messages when invalid/reserved types are found in the
    HEST.  PCI devices not in domain/segment 0 are not represented in
    HEST, thus will be ignored.
    
    Today, the PCIe Advanced Error Reporting (AER) driver attaches itself
    to every PCIe root port for which BIOS reports it should, via ACPI
    _OSC.
    
    However, _OSC alone is insufficient for newer BIOSes.  Part of ACPI
    4.0 is the new APEI (ACPI Platform Error Interfaces) which is a way
    for OS and BIOS to handshake over which errors for which components
    each will handle.  One table in ACPI 4.0 is the Hardware Error Source
    Table (HEST), where BIOS can define that errors for certain PCIe
    devices (or all devices), should be handled by BIOS ("Firmware First
    mode"), rather than be handled by the OS.
    
    Dell PowerEdge 11G server BIOS defines Firmware First mode in HEST, so
    that it may manage such errors, log them to the System Event Log, and
    possibly take other actions.  The aer driver should honor this, and
    not attach itself to devices noted as such.
    
    Furthermore, Kenji Kaneshige reminded us to disallow changing the AER
    registers when respecting Firmware First mode.  Platform firmware is
    expected to manage these, and if changes to them are allowed, it could
    break that firmware's behavior.
    
    The HEST parsing code may be replaced in the future by a more
    feature-rich implementation.  This patch provides the minimum needed
    to prevent breakage until that implementation is available.
    
    Reviewed-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Reviewed-by: Hidetoshi Seto <seto.hidetoshi@jp.fujitsu.com>
    Signed-off-by: Matt Domsch <Matt_Domsch@dell.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 9cefc54a0125..118463befef0 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -11,6 +11,7 @@
 #include <linux/cpumask.h>
 #include <linux/pci-aspm.h>
 #include <linux/iommu.h>
+#include <acpi/acpi_hest.h>
 #include <xen/xen.h>
 #include "pci.h"
 
@@ -706,6 +707,12 @@ static void set_pcie_hotplug_bridge(struct pci_dev *pdev)
 		pdev->is_hotplug_bridge = 1;
 }
 
+static void set_pci_aer_firmware_first(struct pci_dev *pdev)
+{
+	if (acpi_hest_firmware_first_pci(pdev))
+		pdev->aer_firmware_first = 1;
+}
+
 #define LEGACY_IO_RESOURCE	(IORESOURCE_IO | IORESOURCE_PCI_FIXED)
 
 /**
@@ -734,6 +741,7 @@ int pci_setup_device(struct pci_dev *dev)
 	dev->multifunction = !!(hdr_type & 0x80);
 	dev->error_state = pci_channel_io_normal;
 	set_pcie_port_type(dev);
+	set_pci_aer_firmware_first(dev);
 
 	list_for_each_entry(slot, &dev->bus->slots, list)
 		if (PCI_SLOT(dev->devfn) == slot->number)

commit 1ed6743918abbec69c0f0b725fa56e3c3248bbab
Author: Michael S. Tsirkin <mst@redhat.com>
Date:   Thu Oct 29 17:24:59 2009 +0200

    PCI: fix nit in ROM BAR size probing
    
    When probing for ROM BAR size, we should not change bits 1:10 in this
    BAR, because these bits are marked as "reserved for future use" in PCI
    spec, so changing them might have side effects.
    
    No such issue for I/O or memory, as there is an implementation note in
    PCI spec which explicitly allows writing 0xfffffffff there.
    
    Signed-off-by: Michael S. Tsirkin <mst@redhat.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index bb2cc39b64ff..9cefc54a0125 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -165,12 +165,12 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 {
 	u32 l, sz, mask;
 
-	mask = type ? ~PCI_ROM_ADDRESS_ENABLE : ~0;
+	mask = type ? PCI_ROM_ADDRESS_MASK : ~0;
 
 	res->name = pci_name(dev);
 
 	pci_read_config_dword(dev, pos, &l);
-	pci_write_config_dword(dev, pos, mask);
+	pci_write_config_dword(dev, pos, l | mask);
 	pci_read_config_dword(dev, pos, &sz);
 	pci_write_config_dword(dev, pos, l);
 

commit df0e97c6f1f2fdca686036998fe816cefd8e27d7
Author: Allen Kay <allen.m.kay@intel.com>
Date:   Wed Oct 7 10:27:51 2009 -0700

    PCI: add xen dom0 checking before ACS initialization
    
    This patch is predicated on Jeremy's patch in include/xen/xen.h.  It'll
    prevent ACS init unless the platform has both an IOMMU and we're running
    as dom0.
    
    Signed-off-by: Allen Kay <allen.m.kay@intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index aac5b156a5c5..bb2cc39b64ff 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -11,6 +11,7 @@
 #include <linux/cpumask.h>
 #include <linux/pci-aspm.h>
 #include <linux/iommu.h>
+#include <xen/xen.h>
 #include "pci.h"
 
 #define CARDBUS_LATENCY_TIMER	176	/* secondary latency timer */
@@ -1007,7 +1008,7 @@ static void pci_init_capabilities(struct pci_dev *dev)
 	pci_iov_init(dev);
 
 	/* Enable ACS P2P upstream forwarding */
-	if (iommu_found())
+	if (iommu_found() || xen_initial_domain())
 		pci_enable_acs(dev);
 }
 

commit ae21ee65e8bc228416bbcc8a1da01c56a847a60c
Author: Allen Kay <allen.m.kay@intel.com>
Date:   Wed Oct 7 10:27:17 2009 -0700

    PCI: acs p2p upsteram forwarding enabling
    
    Note: dom0 checking in v4 has been separated out into 2/2.
    
    This patch enables P2P upstream forwarding in ACS capable PCIe switches.
    It solves two potential problems in virtualization environment where a PCIe
    device is assigned to a guest domain using a HW iommu such as VT-d:
    
    1) Unintentional failure caused by guest physical address programmed
       into the device's DMA that happens to match the memory address range
       of other downstream ports in the same PCIe switch.  This causes the PCI
       transaction to go to the matching downstream port instead of go to the
       root complex to get translated by VT-d as it should be.
    
    2) Malicious guest software intentionally attacks another downstream
       PCIe device by programming the DMA address into the assigned device
       that matches memory address range of the downstream PCIe port.
    
    We are in process of implementing device filtering software in KVM/XEN
    management software to allow device assignment of PCIe devices behind a PCIe
    switch only if it has ACS capability and with the P2P upstream forwarding bits
    enabled.  This patch is intended to work for both KVM and Xen environments.
    
    Signed-off-by: Allen Kay <allen.m.kay@intel.com>
    Reviewed-by: Mathew Wilcox <willy@linux.intel.com>
    Reviewed-by: Chris Wright <chris@sous-sol.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 2adb47574d86..aac5b156a5c5 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -10,6 +10,7 @@
 #include <linux/module.h>
 #include <linux/cpumask.h>
 #include <linux/pci-aspm.h>
+#include <linux/iommu.h>
 #include "pci.h"
 
 #define CARDBUS_LATENCY_TIMER	176	/* secondary latency timer */
@@ -1004,6 +1005,10 @@ static void pci_init_capabilities(struct pci_dev *dev)
 
 	/* Single Root I/O Virtualization */
 	pci_iov_init(dev);
+
+	/* Enable ACS P2P upstream forwarding */
+	if (iommu_found())
+		pci_enable_acs(dev);
 }
 
 void pci_device_add(struct pci_dev *dev, struct pci_bus *bus)

commit a369c791e881503a6253dafc0d0ad5e41e5557e5
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Oct 6 15:33:44 2009 -0600

    PCI: print resources consistently with %pRt
    
    This uses %pRt to print additional resource information (type, size,
    prefetchability, etc.) consistently.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 8105e32117f6..2adb47574d86 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -222,6 +222,8 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 		if (!sz64)
 			goto fail;
 
+		res->flags |= IORESOURCE_MEM_64;
+
 		if ((sizeof(resource_size_t) < 8) && (sz64 > 0x100000000ULL)) {
 			dev_err(&dev->dev, "can't handle 64-bit BAR\n");
 			goto fail;
@@ -234,14 +236,9 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 		} else {
 			res->start = l64;
 			res->end = l64 + sz64;
-			dev_printk(KERN_DEBUG, &dev->dev,
-				"reg %x %s: %pR\n", pos,
-				 (res->flags & IORESOURCE_PREFETCH) ?
-					"64bit mmio pref" : "64bit mmio",
-				 res);
+			dev_printk(KERN_DEBUG, &dev->dev, "reg %x: %pRt\n",
+				   pos, res);
 		}
-
-		res->flags |= IORESOURCE_MEM_64;
 	} else {
 		sz = pci_size(l, sz, mask);
 
@@ -251,11 +248,7 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 		res->start = l;
 		res->end = l + sz;
 
-		dev_printk(KERN_DEBUG, &dev->dev, "reg %x %s: %pR\n", pos,
-			(res->flags & IORESOURCE_IO) ? "io port" :
-			 ((res->flags & IORESOURCE_PREFETCH) ?
-				 "32bit mmio pref" : "32bit mmio"),
-			res);
+		dev_printk(KERN_DEBUG, &dev->dev, "reg %x: %pRt\n", pos, res);
 	}
 
  out:
@@ -323,7 +316,7 @@ void __devinit pci_read_bridge_bases(struct pci_bus *child)
 			res->start = base;
 		if (!res->end)
 			res->end = limit + 0xfff;
-		dev_printk(KERN_DEBUG, &dev->dev, "bridge io port: %pR\n", res);
+		dev_printk(KERN_DEBUG, &dev->dev, "bridge window: %pRt\n", res);
 	}
 
 	res = child->resource[1];
@@ -335,8 +328,7 @@ void __devinit pci_read_bridge_bases(struct pci_bus *child)
 		res->flags = (mem_base_lo & PCI_MEMORY_RANGE_TYPE_MASK) | IORESOURCE_MEM;
 		res->start = base;
 		res->end = limit + 0xfffff;
-		dev_printk(KERN_DEBUG, &dev->dev, "bridge 32bit mmio: %pR\n",
-			res);
+		dev_printk(KERN_DEBUG, &dev->dev, "bridge window: %pRt\n", res);
 	}
 
 	res = child->resource[2];
@@ -375,9 +367,7 @@ void __devinit pci_read_bridge_bases(struct pci_bus *child)
 			res->flags |= IORESOURCE_MEM_64;
 		res->start = base;
 		res->end = limit + 0xfffff;
-		dev_printk(KERN_DEBUG, &dev->dev, "bridge %sbit mmio pref: %pR\n",
-			(res->flags & PCI_PREF_RANGE_TYPE_64) ? "64" : "32",
-			res);
+		dev_printk(KERN_DEBUG, &dev->dev, "bridge window: %pRt\n", res);
 	}
 }
 

commit 4b77b0a2ba27d64f58f16d8d4d48d8319dda36ff
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Sep 9 23:49:59 2009 +0200

    PCI: Clear saved_state after the state has been restored
    
    Some PCI devices fail if their standard configuration registers are
    restored twice in a row.  Prevent this from happening by making
    pci_restore_state() clear the saved_state flag of the device right
    after the device's standard configuration registers have been
    populated with the previously saved values.
    
    Simplify PCI PM callbacks by removing the direct clearing of
    state_saved from them, as it shouldn't be necessary any more (except
    in pci_pm_thaw(), where it has to be cleared, so that the values saved
    during the "freeze" phase of hibernation are not used later by mistake).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 882383b61d30..8105e32117f6 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1032,6 +1032,9 @@ void pci_device_add(struct pci_dev *dev, struct pci_bus *bus)
 	/* Fix up broken headers */
 	pci_fixup_device(pci_fixup_header, dev);
 
+	/* Clear the state_saved flag. */
+	dev->state_saved = false;
+
 	/* Initialize various capabilities */
 	pci_init_capabilities(dev);
 

commit 28760489a3f1e136c5ae8581c0fa8f63511f2f4c
Author: Eric W. Biederman <ebiederm@aristanetworks.com>
Date:   Wed Sep 9 14:09:24 2009 -0700

    PCI: pcie: Ensure hotplug ports have a minimum number of resources
    
    In general a BIOS may goof or we may hotplug in a hotplug controller.
    In either case the kernel needs to reserve resources for plugging
    in more devices in the future instead of creating a minimal resource
    assignment.
    
    We already do this for cardbus bridges I am just adding a variant
    for pcie bridges.
    
    v2: Make testing for pcie hotplug bridges based on a flag.
    
        So far we only set the flag for pcie but a header_quirk
        could easily be added for the non-standard pci hotplug
        bridges.
    
    Signed-off-by: Eric W. Biederman <ebiederm@aristanetworks.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index ab52840f4753..882383b61d30 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -697,6 +697,23 @@ static void set_pcie_port_type(struct pci_dev *pdev)
 	pdev->pcie_type = (reg16 & PCI_EXP_FLAGS_TYPE) >> 4;
 }
 
+static void set_pcie_hotplug_bridge(struct pci_dev *pdev)
+{
+	int pos;
+	u16 reg16;
+	u32 reg32;
+
+	pos = pci_find_capability(pdev, PCI_CAP_ID_EXP);
+	if (!pos)
+		return;
+	pci_read_config_word(pdev, pos + PCI_EXP_FLAGS, &reg16);
+	if (!(reg16 & PCI_EXP_FLAGS_SLOT))
+		return;
+	pci_read_config_dword(pdev, pos + PCI_EXP_SLTCAP, &reg32);
+	if (reg32 & PCI_EXP_SLTCAP_HPC)
+		pdev->is_hotplug_bridge = 1;
+}
+
 #define LEGACY_IO_RESOURCE	(IORESOURCE_IO | IORESOURCE_PCI_FIXED)
 
 /**
@@ -804,6 +821,7 @@ int pci_setup_device(struct pci_dev *dev)
 		pci_read_irq(dev);
 		dev->transparent = ((dev->class & 0xff) == 1);
 		pci_read_bases(dev, 2, PCI_ROM_ADDRESS1);
+		set_pcie_hotplug_bridge(dev);
 		break;
 
 	case PCI_HEADER_TYPE_CARDBUS:		    /* CardBus bridge header */

commit d0b8cbed648334924728642eea879878bc930b33
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Fri Aug 7 03:53:34 2009 -0700

    PCI: print out pref if mmio is prefetchable
    
    We already print it out for pci bridges, so also print it out for pci devices.
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index b9d4e95aafba..ab52840f4753 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -235,7 +235,10 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 			res->start = l64;
 			res->end = l64 + sz64;
 			dev_printk(KERN_DEBUG, &dev->dev,
-				"reg %x 64bit mmio: %pR\n", pos, res);
+				"reg %x %s: %pR\n", pos,
+				 (res->flags & IORESOURCE_PREFETCH) ?
+					"64bit mmio pref" : "64bit mmio",
+				 res);
 		}
 
 		res->flags |= IORESOURCE_MEM_64;
@@ -249,7 +252,9 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 		res->end = l + sz;
 
 		dev_printk(KERN_DEBUG, &dev->dev, "reg %x %s: %pR\n", pos,
-			(res->flags & IORESOURCE_IO) ? "io port" : "32bit mmio",
+			(res->flags & IORESOURCE_IO) ? "io port" :
+			 ((res->flags & IORESOURCE_PREFETCH) ?
+				 "32bit mmio pref" : "32bit mmio"),
 			res);
 	}
 

commit a7db50405216610c8a0d62b8b400180b6f366733
Author: Alex Chiang <achiang@hp.com>
Date:   Mon Jun 22 08:08:07 2009 -0600

    PCI: remove pcibios_scan_all_fns()
    
    This was #define'd as 0 on all platforms, so let's get rid of it.
    
    This change makes pci_scan_slot() slightly easier to read.
    
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: David Howells <dhowells@redhat.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Jeff Dike <jdike@addtoit.com>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
    Reviewed-by: Matthew Wilcox <willy@linux.intel.com>
    Acked-by: Russell King <linux@arm.linux.org.uk>
    Acked-by: Ralf Baechle <ralf@linux-mips.org>
    Acked-by: Kyle McMartin <kyle@mcmartin.ca>
    Acked-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Acked-by: Paul Mundt <lethal@linux-sh.org>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Alex Chiang <achiang@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 40e75f6a5056..b9d4e95aafba 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1061,8 +1061,7 @@ int pci_scan_slot(struct pci_bus *bus, int devfn)
 	if (dev && !dev->is_added)	/* new device? */
 		nr++;
 
-	if ((dev && dev->multifunction) ||
-	    (!dev && pcibios_scan_all_fns(bus, devfn))) {
+	if (dev && dev->multifunction) {
 		for (fn = 1; fn < 8; fn++) {
 			dev = pci_scan_single_device(bus, devfn + fn);
 			if (dev) {

commit 9fc39256508c18d2861de11622183dfb6e79de87
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Tue May 26 16:06:48 2009 +0900

    PCI: use pci_is_root_bus() in pci_read_bridge_bases()
    
    Use pci_is_root_bus() in pci_read_bridge_bases() to check if the pci
    bus is root, for code consistency.
    
    Reviewed-by: Alex Chiang <achiang@hp.com>
    Reviewed-by: Grant Grundler <grundler@parisc-linux.org>
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index b962326e3d95..40e75f6a5056 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -289,7 +289,7 @@ void __devinit pci_read_bridge_bases(struct pci_bus *child)
 	struct resource *res;
 	int i;
 
-	if (!child->parent)	/* It's a host bus, nothing to read */
+	if (pci_is_root_bus(child))	/* It's a host bus, nothing to read */
 		return;
 
 	if (dev->transparent) {

commit 1f82de10d6b1d845155363c895c552e61b36b51a
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Thu Apr 23 20:48:32 2009 -0700

    PCI/x86: don't assume prefetchable ranges are 64bit
    
    We should not assign 64bit ranges to PCI devices that only take 32bit
    prefetchable addresses.
    
    Try to set IORESOURCE_MEM_64 in 64bit resource of pci_device/pci_bridge
    and make the bus resource only have that bit set when all devices under
    it support 64bit prefetchable memory.  Use that flag to allocate
    resources from that range.
    
    Reported-by: Yannick <yannick.roehlly@free.fr>
    Reviewed-by: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index f1ae2475ffff..b962326e3d95 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -193,7 +193,7 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 		res->flags |= pci_calc_resource_flags(l) | IORESOURCE_SIZEALIGN;
 		if (type == pci_bar_io) {
 			l &= PCI_BASE_ADDRESS_IO_MASK;
-			mask = PCI_BASE_ADDRESS_IO_MASK & 0xffff;
+			mask = PCI_BASE_ADDRESS_IO_MASK & IO_SPACE_LIMIT;
 		} else {
 			l &= PCI_BASE_ADDRESS_MEM_MASK;
 			mask = (u32)PCI_BASE_ADDRESS_MEM_MASK;
@@ -237,6 +237,8 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 			dev_printk(KERN_DEBUG, &dev->dev,
 				"reg %x 64bit mmio: %pR\n", pos, res);
 		}
+
+		res->flags |= IORESOURCE_MEM_64;
 	} else {
 		sz = pci_size(l, sz, mask);
 
@@ -362,7 +364,10 @@ void __devinit pci_read_bridge_bases(struct pci_bus *child)
 		}
 	}
 	if (base <= limit) {
-		res->flags = (mem_base_lo & PCI_MEMORY_RANGE_TYPE_MASK) | IORESOURCE_MEM | IORESOURCE_PREFETCH;
+		res->flags = (mem_base_lo & PCI_PREF_RANGE_TYPE_MASK) |
+					 IORESOURCE_MEM | IORESOURCE_PREFETCH;
+		if (res->flags & PCI_PREF_RANGE_TYPE_64)
+			res->flags |= IORESOURCE_MEM_64;
 		res->start = base;
 		res->end = limit + 0xfffff;
 		dev_printk(KERN_DEBUG, &dev->dev, "bridge %sbit mmio pref: %pR\n",

commit f79b1b146b52765ee38bfb91bb14eb850fa98017
Author: Yu Zhao <yu.zhao@intel.com>
Date:   Thu May 28 00:25:05 2009 +0800

    PCI: use fixed-up device class when configuring device
    
    The device class may be changed after the fixup, so re-read the class
    value from pci_dev when configuring the device.  Otherwise some devices
    such as JMicron SATA controller won't work.
    
    Reviewed-by: Matthew Wilcox <willy@linux.intel.com>
    Reviewed-by: Grant Grundler <grundler@parisc-linux.org>
    Tested-by: Marc Dionne <marc.c.dionne@gmail.com>
    Signed-off-by: Yu Zhao <yu.zhao@intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index e3c3e081b834..f1ae2475ffff 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -745,6 +745,8 @@ int pci_setup_device(struct pci_dev *dev)
 
 	/* Early fixups, before probing the BARs */
 	pci_fixup_device(pci_fixup_early, dev);
+	/* device class may be changed after fixup */
+	class = dev->class >> 8;
 
 	switch (dev->hdr_type) {		    /* header type */
 	case PCI_HEADER_TYPE_NORMAL:		    /* standard header */

commit 0bb1be3e30bfc3e09fa0ff1e887ac7da4a16c3a2
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Thu Apr 16 13:31:10 2009 -0600

    x86/PCI: Move set_pci_bus_resources_arch_default into arch/x86
    
    Commit 30a18d6c3f1e774de656ebd8ff219d53e2ba4029 introduced a new
    function to set the PCI bus resources.  Unfortunately, neither the
    author, nor the committers seemed to know that we already have somewhere
    to do that -- pcibios_fixup_bus().  This patch moves the hook (used only
    by the K8 code) into x86-specific code where it should have been in the
    first place.
    
    Cc: Yinghai Lu <yinghai.lu@sun.com>
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Acked-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 8eb50dffb78a..e3c3e081b834 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1118,10 +1118,6 @@ unsigned int __devinit pci_scan_child_bus(struct pci_bus *bus)
 	return max;
 }
 
-void __attribute__((weak)) set_pci_bus_resources_arch_default(struct pci_bus *b)
-{
-}
-
 struct pci_bus * pci_create_bus(struct device *parent,
 		int bus, struct pci_ops *ops, void *sysdata)
 {
@@ -1180,8 +1176,6 @@ struct pci_bus * pci_create_bus(struct device *parent,
 	b->resource[0] = &ioport_resource;
 	b->resource[1] = &iomem_resource;
 
-	set_pci_bus_resources_arch_default(b);
-
 	return b;
 
 dev_create_file_err:

commit 5446a6bdb51e71da7a203e395b0b4c668d559a3a
Author: Alex Chiang <achiang@hp.com>
Date:   Wed Apr 1 18:24:12 2009 -0600

    PCI: annotate pci_rescan_bus as __ref, not __devinit
    
    pci_rescan_bus was annotated as __devinit, which is wrong,
    because it will never be part of device initialization.
    Howevever, we can't simply drop the annotation, because then we
    get section warnings about calling pci_scan_child_bus (which is
    correctly marked as __devinit).
    
    pci_rescan_bus will only get built when CONFIG_HOTPLUG is set,
    meaning that __devinit is a nop, so we know that pci_scan_child_bus
    has not been freed.
    
    Annotate as __ref to silence modpost.
    
    Signed-off-by: Alex Chiang <achiang@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index e2f3dd098cfa..8eb50dffb78a 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1220,7 +1220,7 @@ EXPORT_SYMBOL(pci_scan_bus_parented);
  *
  * Returns the max number of subordinate bus discovered.
  */
-unsigned int __devinit pci_rescan_bus(struct pci_bus *bus)
+unsigned int __ref pci_rescan_bus(struct pci_bus *bus)
 {
 	unsigned int max;
 	struct pci_dev *dev;

commit 853346e4354c948b50a6fb0002f8af2cf5fbf2ae
Author: Yu Zhao <yu.zhao@intel.com>
Date:   Sat Mar 21 22:05:11 2009 +0800

    PCI: fix conflict between SR-IOV and config space sizing
    
    New pci_cfg_space_size() needs invalid pdev->class, put it in the
    right place in the pci_setup_device().
    
    Signed-off-by: Yu Zhao <yu.zhao@intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 56c71e585f3d..e2f3dd098cfa 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -713,7 +713,6 @@ int pci_setup_device(struct pci_dev *dev)
 	dev->dev.bus = &pci_bus_type;
 	dev->hdr_type = hdr_type & 0x7f;
 	dev->multifunction = !!(hdr_type & 0x80);
-	dev->cfg_size = pci_cfg_space_size(dev);
 	dev->error_state = pci_channel_io_normal;
 	set_pcie_port_type(dev);
 
@@ -738,6 +737,9 @@ int pci_setup_device(struct pci_dev *dev)
 	dev_dbg(&dev->dev, "found [%04x:%04x] class %06x header type %02x\n",
 		 dev->vendor, dev->device, class, dev->hdr_type);
 
+	/* need to have dev->class ready */
+	dev->cfg_size = pci_cfg_space_size(dev);
+
 	/* "Unknown power state" */
 	dev->current_state = PCI_UNKNOWN;
 
@@ -959,9 +961,6 @@ static struct pci_dev *pci_scan_device(struct pci_bus *bus, int devfn)
 		return NULL;
 	}
 
-	/* need to have dev->class ready */
-	dev->cfg_size = pci_cfg_space_size(dev);
-
 	return dev;
 }
 

commit 705b1aaa823e800490f157cd9366ad8cff385f5f
Author: Alex Chiang <achiang@hp.com>
Date:   Fri Mar 20 14:56:31 2009 -0600

    PCI: Introduce /sys/bus/pci/rescan
    
    This interface allows the user to force a rescan of all PCI buses
    in system, and rediscover devices that have been removed earlier.
    
    pci_bus_attrs implementation from Trent Piepho.
    
    Thanks to Vegard Nossum for discovering locking issues with the
    sysfs interface.
    
    Cc: Trent Piepho <xyzzy@speakeasy.org>
    Signed-off-by: Alex Chiang <achiang@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 60a8e5fec6c5..56c71e585f3d 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1228,13 +1228,13 @@ unsigned int __devinit pci_rescan_bus(struct pci_bus *bus)
 
 	max = pci_scan_child_bus(bus);
 
-	up_read(&pci_bus_sem);
+	down_read(&pci_bus_sem);
 	list_for_each_entry(dev, &bus->devices, bus_list)
 		if (dev->hdr_type == PCI_HEADER_TYPE_BRIDGE ||
 		    dev->hdr_type == PCI_HEADER_TYPE_CARDBUS)
 			if (dev->subordinate)
 				pci_bus_size_bridges(dev->subordinate);
-	down_read(&pci_bus_sem);
+	up_read(&pci_bus_sem);
 
 	pci_bus_assign_resources(bus);
 	pci_enable_bridges(bus);

commit 3ed4fd96b3188406ac5357d9290bcffa08c65cf6
Author: Alex Chiang <achiang@hp.com>
Date:   Fri Mar 20 14:56:25 2009 -0600

    PCI: Introduce pci_rescan_bus()
    
    This API is used by the PCI core to rescan a bus and rediscover
    newly added devices.
    
    Over time, it is expected that the various PCI hotplug drivers
    will migrate to this interface and away from the old
    pci_do_scan_bus() interface.
    
    Signed-off-by: Alex Chiang <achiang@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index f69256c63b2b..60a8e5fec6c5 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1212,6 +1212,38 @@ struct pci_bus * __devinit pci_scan_bus_parented(struct device *parent,
 EXPORT_SYMBOL(pci_scan_bus_parented);
 
 #ifdef CONFIG_HOTPLUG
+/**
+ * pci_rescan_bus - scan a PCI bus for devices.
+ * @bus: PCI bus to scan
+ *
+ * Scan a PCI bus and child buses for new devices, adds them,
+ * and enables them.
+ *
+ * Returns the max number of subordinate bus discovered.
+ */
+unsigned int __devinit pci_rescan_bus(struct pci_bus *bus)
+{
+	unsigned int max;
+	struct pci_dev *dev;
+
+	max = pci_scan_child_bus(bus);
+
+	up_read(&pci_bus_sem);
+	list_for_each_entry(dev, &bus->devices, bus_list)
+		if (dev->hdr_type == PCI_HEADER_TYPE_BRIDGE ||
+		    dev->hdr_type == PCI_HEADER_TYPE_CARDBUS)
+			if (dev->subordinate)
+				pci_bus_size_bridges(dev->subordinate);
+	down_read(&pci_bus_sem);
+
+	pci_bus_assign_resources(bus);
+	pci_enable_bridges(bus);
+	pci_bus_add_devices(bus);
+
+	return max;
+}
+EXPORT_SYMBOL_GPL(pci_rescan_bus);
+
 EXPORT_SYMBOL(pci_add_new_bus);
 EXPORT_SYMBOL(pci_scan_slot);
 EXPORT_SYMBOL(pci_scan_bridge);

commit 74710ded8e16fc8dacbb702a5bac1a493d88549a
Author: Alex Chiang <achiang@hp.com>
Date:   Fri Mar 20 14:56:10 2009 -0600

    PCI: always scan child buses
    
    While scanning bridges, we stop our scan if we encounter a bus
    that we've seen before, to work around some buggy chipsets. This
    is a good idea, but prevents us from fully scanning the PCI bus
    at a future time (to find newly hot-added devices, for example).
    
    Change the logic so that we skip _re-adding_ an existing bus
    that we've seen before, but also allow the scan to descend to
    all child buses.
    
    Now that we're potentially scanning our child buses again, we
    also need to be sure not to attempt re-initializing their BARs
    so we avoid that.
    
    This patch lays the groundwork to allow the user to issue a
    rescan of the PCI bus at any time.
    
    Signed-off-by: Alex Chiang <achiang@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index f3aabdf28f84..f69256c63b2b 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -511,21 +511,21 @@ int __devinit pci_scan_bridge(struct pci_bus *bus, struct pci_dev *dev, int max,
 
 		/*
 		 * If we already got to this bus through a different bridge,
-		 * ignore it.  This can happen with the i450NX chipset.
+		 * don't re-add it. This can happen with the i450NX chipset.
+		 *
+		 * However, we continue to descend down the hierarchy and
+		 * scan remaining child buses.
 		 */
-		if (pci_find_bus(pci_domain_nr(bus), busnr)) {
-			dev_info(&dev->dev, "bus %04x:%02x already known\n",
-				 pci_domain_nr(bus), busnr);
-			goto out;
+		child = pci_find_bus(pci_domain_nr(bus), busnr);
+		if (!child) {
+			child = pci_add_new_bus(bus, dev, busnr);
+			if (!child)
+				goto out;
+			child->primary = buses & 0xFF;
+			child->subordinate = (buses >> 16) & 0xFF;
+			child->bridge_ctl = bctl;
 		}
 
-		child = pci_add_new_bus(bus, dev, busnr);
-		if (!child)
-			goto out;
-		child->primary = buses & 0xFF;
-		child->subordinate = (buses >> 16) & 0xFF;
-		child->bridge_ctl = bctl;
-
 		cmax = pci_scan_child_bus(child);
 		if (cmax > max)
 			max = cmax;
@@ -1092,8 +1092,14 @@ unsigned int __devinit pci_scan_child_bus(struct pci_bus *bus)
 	 * After performing arch-dependent fixup of the bus, look behind
 	 * all PCI-to-PCI bridges on this bus.
 	 */
-	pr_debug("PCI: Fixups for bus %04x:%02x\n", pci_domain_nr(bus), bus->number);
-	pcibios_fixup_bus(bus);
+	if (!bus->is_added) {
+		pr_debug("PCI: Fixups for bus %04x:%02x\n",
+			 pci_domain_nr(bus), bus->number);
+		pcibios_fixup_bus(bus);
+		if (pci_is_root_bus(bus))
+			bus->is_added = 1;
+	}
+
 	for (pass=0; pass < 2; pass++)
 		list_for_each_entry(dev, &bus->devices, bus_list) {
 			if (dev->hdr_type == PCI_HEADER_TYPE_BRIDGE ||

commit 1b69dfc649e6658fc38499cf704750d74cabc73d
Author: Trent Piepho <xyzzy@speakeasy.org>
Date:   Fri Mar 20 14:56:05 2009 -0600

    PCI: pci_scan_slot() returns newly found devices
    
    pci_scan_slot() has been rewritten to be less complex and will now
    return the number of *new* devices found.
    
    Existing callers need not worry because they already assume that
    they can't call pci_scan_slot() on an already-scanned slot.
    
    Thus, there is no semantic change for existing callers: returning
    newly found devices (this patch) is exactly equal to returning all
    found devices (before this patch).
    
    This patch adds some more groundwork to allow us to rescan the
    PCI bus during runtime to discover newly added devices.
    
    Signed-off-by: Trent Piepho <xyzzy@speakeasy.org>
    Reviewed-by: Alex Chiang <achiang@hp.com>
    Signed-off-by: Alex Chiang <achiang@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 140b9deb482c..f3aabdf28f84 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1043,35 +1043,27 @@ EXPORT_SYMBOL(pci_scan_single_device);
  * Scan a PCI slot on the specified PCI bus for devices, adding
  * discovered devices to the @bus->devices list.  New devices
  * will not have is_added set.
+ *
+ * Returns the number of new devices found.
  */
 int pci_scan_slot(struct pci_bus *bus, int devfn)
 {
-	int func, nr = 0;
-	int scan_all_fns;
-
-	scan_all_fns = pcibios_scan_all_fns(bus, devfn);
-
-	for (func = 0; func < 8; func++, devfn++) {
-		struct pci_dev *dev;
-
-		dev = pci_scan_single_device(bus, devfn);
-		if (dev) {
-			nr++;
+	int fn, nr = 0;
+	struct pci_dev *dev;
 
-			/*
-		 	 * If this is a single function device,
-		 	 * don't scan past the first function.
-		 	 */
-			if (!dev->multifunction) {
-				if (func > 0) {
-					dev->multifunction = 1;
-				} else {
- 					break;
-				}
+	dev = pci_scan_single_device(bus, devfn);
+	if (dev && !dev->is_added)	/* new device? */
+		nr++;
+
+	if ((dev && dev->multifunction) ||
+	    (!dev && pcibios_scan_all_fns(bus, devfn))) {
+		for (fn = 1; fn < 8; fn++) {
+			dev = pci_scan_single_device(bus, devfn + fn);
+			if (dev) {
+				if (!dev->is_added)
+					nr++;
+				dev->multifunction = 1;
 			}
-		} else {
-			if (func == 0 && !scan_all_fns)
-				break;
 		}
 	}
 

commit 90bdb3117f4209baa6d712b126f0e7791b24dc3f
Author: Trent Piepho <xyzzy@speakeasy.org>
Date:   Fri Mar 20 14:56:00 2009 -0600

    PCI: don't scan existing devices
    
    pci_scan_single_device is supposed to add newly discovered
    devices to pci_bus->devices, but doesn't check to see if the
    device has already been added. This can cause problems if we ever
    want to use this interface to rescan the PCI bus.
    
    If the device is already added, just return it.
    
    Signed-off-by: Trent Piepho <xyzzy@speakeasy.org>
    Signed-off-by: Alex Chiang <achiang@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 943c49a7842c..140b9deb482c 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1019,6 +1019,12 @@ struct pci_dev *__ref pci_scan_single_device(struct pci_bus *bus, int devfn)
 {
 	struct pci_dev *dev;
 
+	dev = pci_get_slot(bus, devfn);
+	if (dev) {
+		pci_dev_put(dev);
+		return dev;
+	}
+
 	dev = pci_scan_device(bus, devfn);
 	if (!dev)
 		return NULL;

commit 480b93b7837fb3cf0579a42f4953ac463a5b9e1e
Author: Yu Zhao <yu.zhao@intel.com>
Date:   Fri Mar 20 11:25:14 2009 +0800

    PCI: centralize device setup code
    
    Move the device setup stuff into pci_setup_device() which will be used
    to setup the Virtual Function later.
    
    Reviewed-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: Yu Zhao <yu.zhao@intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 0ecdaea3915f..943c49a7842c 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -674,6 +674,19 @@ static void pci_read_irq(struct pci_dev *dev)
 	dev->irq = irq;
 }
 
+static void set_pcie_port_type(struct pci_dev *pdev)
+{
+	int pos;
+	u16 reg16;
+
+	pos = pci_find_capability(pdev, PCI_CAP_ID_EXP);
+	if (!pos)
+		return;
+	pdev->is_pcie = 1;
+	pci_read_config_word(pdev, pos + PCI_EXP_FLAGS, &reg16);
+	pdev->pcie_type = (reg16 & PCI_EXP_FLAGS_TYPE) >> 4;
+}
+
 #define LEGACY_IO_RESOURCE	(IORESOURCE_IO | IORESOURCE_PCI_FIXED)
 
 /**
@@ -683,12 +696,34 @@ static void pci_read_irq(struct pci_dev *dev)
  * Initialize the device structure with information about the device's 
  * vendor,class,memory and IO-space addresses,IRQ lines etc.
  * Called at initialisation of the PCI subsystem and by CardBus services.
- * Returns 0 on success and -1 if unknown type of device (not normal, bridge
- * or CardBus).
+ * Returns 0 on success and negative if unknown type of device (not normal,
+ * bridge or CardBus).
  */
-static int pci_setup_device(struct pci_dev * dev)
+int pci_setup_device(struct pci_dev *dev)
 {
 	u32 class;
+	u8 hdr_type;
+	struct pci_slot *slot;
+
+	if (pci_read_config_byte(dev, PCI_HEADER_TYPE, &hdr_type))
+		return -EIO;
+
+	dev->sysdata = dev->bus->sysdata;
+	dev->dev.parent = dev->bus->bridge;
+	dev->dev.bus = &pci_bus_type;
+	dev->hdr_type = hdr_type & 0x7f;
+	dev->multifunction = !!(hdr_type & 0x80);
+	dev->cfg_size = pci_cfg_space_size(dev);
+	dev->error_state = pci_channel_io_normal;
+	set_pcie_port_type(dev);
+
+	list_for_each_entry(slot, &dev->bus->slots, list)
+		if (PCI_SLOT(dev->devfn) == slot->number)
+			dev->slot = slot;
+
+	/* Assume 32-bit PCI; let 64-bit PCI cards (which are far rarer)
+	   set this higher, assuming the system even supports it.  */
+	dev->dma_mask = 0xffffffff;
 
 	dev_set_name(&dev->dev, "%04x:%02x:%02x.%d", pci_domain_nr(dev->bus),
 		     dev->bus->number, PCI_SLOT(dev->devfn),
@@ -708,7 +743,6 @@ static int pci_setup_device(struct pci_dev * dev)
 
 	/* Early fixups, before probing the BARs */
 	pci_fixup_device(pci_fixup_early, dev);
-	class = dev->class >> 8;
 
 	switch (dev->hdr_type) {		    /* header type */
 	case PCI_HEADER_TYPE_NORMAL:		    /* standard header */
@@ -770,7 +804,7 @@ static int pci_setup_device(struct pci_dev * dev)
 	default:				    /* unknown header */
 		dev_err(&dev->dev, "unknown header type %02x, "
 			"ignoring device\n", dev->hdr_type);
-		return -1;
+		return -EIO;
 
 	bad:
 		dev_err(&dev->dev, "ignoring class %02x (doesn't match header "
@@ -804,19 +838,6 @@ static void pci_release_dev(struct device *dev)
 	kfree(pci_dev);
 }
 
-static void set_pcie_port_type(struct pci_dev *pdev)
-{
-	int pos;
-	u16 reg16;
-
-	pos = pci_find_capability(pdev, PCI_CAP_ID_EXP);
-	if (!pos)
-		return;
-	pdev->is_pcie = 1;
-	pci_read_config_word(pdev, pos + PCI_EXP_FLAGS, &reg16);
-	pdev->pcie_type = (reg16 & PCI_EXP_FLAGS_TYPE) >> 4;
-}
-
 /**
  * pci_cfg_space_size - get the configuration space size of the PCI device.
  * @dev: PCI device
@@ -897,9 +918,7 @@ EXPORT_SYMBOL(alloc_pci_dev);
 static struct pci_dev *pci_scan_device(struct pci_bus *bus, int devfn)
 {
 	struct pci_dev *dev;
-	struct pci_slot *slot;
 	u32 l;
-	u8 hdr_type;
 	int delay = 1;
 
 	if (pci_bus_read_config_dword(bus, devfn, PCI_VENDOR_ID, &l))
@@ -926,33 +945,16 @@ static struct pci_dev *pci_scan_device(struct pci_bus *bus, int devfn)
 		}
 	}
 
-	if (pci_bus_read_config_byte(bus, devfn, PCI_HEADER_TYPE, &hdr_type))
-		return NULL;
-
 	dev = alloc_pci_dev();
 	if (!dev)
 		return NULL;
 
 	dev->bus = bus;
-	dev->sysdata = bus->sysdata;
-	dev->dev.parent = bus->bridge;
-	dev->dev.bus = &pci_bus_type;
 	dev->devfn = devfn;
-	dev->hdr_type = hdr_type & 0x7f;
-	dev->multifunction = !!(hdr_type & 0x80);
 	dev->vendor = l & 0xffff;
 	dev->device = (l >> 16) & 0xffff;
-	dev->error_state = pci_channel_io_normal;
-	set_pcie_port_type(dev);
-
-	list_for_each_entry(slot, &bus->slots, list)
-		if (PCI_SLOT(devfn) == slot->number)
-			dev->slot = slot;
 
-	/* Assume 32-bit PCI; let 64-bit PCI cards (which are far rarer)
-	   set this higher, assuming the system even supports it.  */
-	dev->dma_mask = 0xffffffff;
-	if (pci_setup_device(dev) < 0) {
+	if (pci_setup_device(dev)) {
 		kfree(dev);
 		return NULL;
 	}

commit a28724b0fb909d247229a70761c90bb37b13366a
Author: Yu Zhao <yu.zhao@intel.com>
Date:   Fri Mar 20 11:25:13 2009 +0800

    PCI: reserve bus range for SR-IOV device
    
    Reserve the bus number range used by the Virtual Function when
    pcibios_assign_all_busses() returns true.
    
    Reviewed-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: Yu Zhao <yu.zhao@intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 0471f6ea1466..0ecdaea3915f 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1085,6 +1085,9 @@ unsigned int __devinit pci_scan_child_bus(struct pci_bus *bus)
 	for (devfn = 0; devfn < 0x100; devfn += 8)
 		pci_scan_slot(bus, devfn);
 
+	/* Reserve buses for SR-IOV capability. */
+	max += pci_iov_bus_range(bus);
+
 	/*
 	 * After performing arch-dependent fixup of the bus, look behind
 	 * all PCI-to-PCI bridges on this bus.

commit d1b054da8f599905f3c18a218961dcf17f9d5f13
Author: Yu Zhao <yu.zhao@intel.com>
Date:   Fri Mar 20 11:25:11 2009 +0800

    PCI: initialize and release SR-IOV capability
    
    If a device has the SR-IOV capability, initialize it (set the ARI
    Capable Hierarchy in the lowest numbered PF if necessary; calculate
    the System Page Size for the VF MMIO, probe the VF Offset, Stride
    and BARs). A lock for the VF bus allocation is also initialized if
    a PF is the lowest numbered PF.
    
    Reviewed-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: Yu Zhao <yu.zhao@intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 579a56c8181f..0471f6ea1466 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -785,6 +785,7 @@ static int pci_setup_device(struct pci_dev * dev)
 static void pci_release_capabilities(struct pci_dev *dev)
 {
 	pci_vpd_release(dev);
+	pci_iov_release(dev);
 }
 
 /**
@@ -979,6 +980,9 @@ static void pci_init_capabilities(struct pci_dev *dev)
 
 	/* Alternative Routing-ID Forwarding */
 	pci_enable_ari(dev);
+
+	/* Single Root I/O Virtualization */
+	pci_iov_init(dev);
 }
 
 void pci_device_add(struct pci_dev *dev, struct pci_bus *bus)

commit dfadd9edff498d767008edc6b2a6e86a7a19934d
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Sun Mar 8 21:35:37 2009 -0700

    PCI/x86: detect host bridge config space size w/o using quirks
    
    Many host bridges support a 4k config space, so check them directy
    instead of using quirks to add them.
    
    We only need to do this extra check for host bridges at this point,
    because only host bridges are known to have extended address space
    without also having a PCI-X/PCI-E caps.  Other devices with this
    property could be done with quirks (if there are any).
    
    As a bonus, we can remove the quirks for AMD host bridges with family
    10h and 11h since they're not needed any more.
    
    With this patch, we can get correct pci cfg size of new Intel CPUs/IOHs
    with host bridges.
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Acked-by: H. Peter Anvin <hpa@zytor.com>
    Reviewed-by: Matthew Wilcox <willy@linux.intel.com>
    Cc: <stable@kernel.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 9e7d642e66b0..579a56c8181f 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -847,6 +847,11 @@ int pci_cfg_space_size(struct pci_dev *dev)
 {
 	int pos;
 	u32 status;
+	u16 class;
+
+	class = dev->class >> 8;
+	if (class == PCI_CLASS_BRIDGE_HOST)
+		return pci_cfg_space_size_ext(dev);
 
 	pos = pci_find_capability(dev, PCI_CAP_ID_EXP);
 	if (!pos) {
@@ -936,7 +941,6 @@ static struct pci_dev *pci_scan_device(struct pci_bus *bus, int devfn)
 	dev->multifunction = !!(hdr_type & 0x80);
 	dev->vendor = l & 0xffff;
 	dev->device = (l >> 16) & 0xffff;
-	dev->cfg_size = pci_cfg_space_size(dev);
 	dev->error_state = pci_channel_io_normal;
 	set_pcie_port_type(dev);
 
@@ -952,6 +956,9 @@ static struct pci_dev *pci_scan_device(struct pci_bus *bus, int devfn)
 		return NULL;
 	}
 
+	/* need to have dev->class ready */
+	dev->cfg_size = pci_cfg_space_size(dev);
+
 	return dev;
 }
 

commit 6a3b3e26803fc823058fbb05abb5e0d92a52e1bd
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Sun Mar 15 20:14:37 2009 +0100

    PCI: Use kzalloc() in pci_create_bus()
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 23362e8c696f..9e7d642e66b0 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1114,7 +1114,7 @@ struct pci_bus * pci_create_bus(struct device *parent,
 	if (!b)
 		return NULL;
 
-	dev = kmalloc(sizeof(*dev), GFP_KERNEL);
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
 	if (!dev){
 		kfree(b);
 		return NULL;
@@ -1133,7 +1133,6 @@ struct pci_bus * pci_create_bus(struct device *parent,
 	list_add_tail(&b->node, &pci_root_buses);
 	up_write(&pci_bus_sem);
 
-	memset(dev, 0, sizeof(*dev));
 	dev->parent = parent;
 	dev->release = pci_release_bus_bridge_dev;
 	dev_set_name(dev, "pci%04x:%02x", pci_domain_nr(b), bus);

commit f92d4e29d785f1d4217dee7f1ae6ff7140547ed5
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Tue Feb 17 14:15:16 2009 +0900

    PCI: fix wrong assumption in pci_read_bridge_bases
    
    Current pci_read_bridge_bases() has an assumption that pci_bus->self
    is NULL on the pci root bus (It checks pci_bus->self to see if the pci
    bus is root bus). But is might not true on some platforms. We must
    check pci_bus->parent instead.
    
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 55ec44a27e89..23362e8c696f 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -287,7 +287,7 @@ void __devinit pci_read_bridge_bases(struct pci_bus *child)
 	struct resource *res;
 	int i;
 
-	if (!dev)		/* It's a host bus, nothing to read */
+	if (!child->parent)	/* It's a host bus, nothing to read */
 		return;
 
 	if (dev->transparent) {

commit 4e9b1c184cadbece3694603de5f880b6e35bd7a7
Merge: 0176260fc308 36c401a44abc
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jan 10 06:12:18 2009 -0800

    Merge branch 'cpus4096-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'cpus4096-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      [IA64] fix typo in cpumask_of_pcibus()
      x86: fix x86_32 builds for summit and es7000 arch's
      cpumask: use work_on_cpu in acpi-cpufreq.c for read_measured_perf_ctrs
      cpumask: use work_on_cpu in acpi-cpufreq.c for drv_read and drv_write
      cpumask: use cpumask_var_t in acpi-cpufreq.c
      cpumask: use work_on_cpu in acpi/cstate.c
      cpumask: convert struct cpufreq_policy to cpumask_var_t
      cpumask: replace CPUMASK_ALLOC etc with cpumask_var_t
      x86: cleanup remaining cpumask_t ops in smpboot code
      cpumask: update pci_bus_show_cpuaffinity to use new cpumask API
      cpumask: update local_cpus_show to use new cpumask API
      ia64: cpumask fix for is_affinity_mask_valid()

commit eb9c39d031bbcfd4005bd7e0337c3fd3909c1bf7
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Wed Dec 17 12:10:05 2008 -0800

    PCI: set device wakeup capable flag if platform support is present
    
    When PCI devices are initialized, we check whether they support PCI PM
    caps and set the device can_wakeup flag if so.  However, some devices
    may have platform provided wakeup events rather than PCI PME signals, so
    we need to set can_wakeup in that case too.  Doing so should allow
    wakeups from many more devices, especially on cost constrained systems.
    
    Reported-by: Alan Stern <stern@rowland.harvard.edu>
    Tested-by: Joseph Chan <JosephChan@via.com.tw>
    Acked-by: "Rafael J. Wysocki" <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 2ee00962734b..303644614eea 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -965,6 +965,7 @@ static void pci_init_capabilities(struct pci_dev *dev)
 
 	/* Power Management */
 	pci_pm_init(dev);
+	platform_pci_wakeup_init(dev);
 
 	/* Vital Product Data */
 	pci_vpd_pci22_init(dev);

commit 3789fa8a2e534523c896a32a9f27f78d52ad7d82
Author: Yu Zhao <yu.zhao@intel.com>
Date:   Sat Nov 22 02:41:07 2008 +0800

    PCI: allow pci_alloc_child_bus() to handle a NULL bridge
    
    Allow pci_alloc_child_bus() to allocate buses without bridge devices.
    Some SR-IOV devices can occupy more than one bus number, but there is no
    explicit bridges because that have internal routing mechanism.
    
    Signed-off-by: Yu Zhao <yu.zhao@intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 5372d3699e08..2ee00962734b 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -398,12 +398,10 @@ static struct pci_bus *pci_alloc_child_bus(struct pci_bus *parent,
 	if (!child)
 		return NULL;
 
-	child->self = bridge;
 	child->parent = parent;
 	child->ops = parent->ops;
 	child->sysdata = parent->sysdata;
 	child->bus_flags = parent->bus_flags;
-	child->bridge = get_device(&bridge->dev);
 
 	/* initialize some portions of the bus device, but don't register it
 	 * now as the parent is not properly set up yet.  This device will get
@@ -420,6 +418,12 @@ static struct pci_bus *pci_alloc_child_bus(struct pci_bus *parent,
 	child->primary = parent->secondary;
 	child->subordinate = 0xff;
 
+	if (!bridge)
+		return child;
+
+	child->self = bridge;
+	child->bridge = get_device(&bridge->dev);
+
 	/* Set up default resource pointers and names.. */
 	for (i = 0; i < PCI_BRIDGE_RESOURCE_NUM; i++) {
 		child->resource[i] = &bridge->resource[PCI_BRIDGE_RESOURCES+i];

commit 0b400c7ed4d027e02f6231afa39852a2d48e6f25
Author: Yu Zhao <yu.zhao@intel.com>
Date:   Sat Nov 22 02:40:40 2008 +0800

    PCI: export __pci_read_base()
    
    Export __pci_read_base() so it can be used by whole PCI subsystem.
    
    Signed-off-by: Yu Zhao <yu.zhao@intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index e1cf5d50ed4d..5372d3699e08 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -135,13 +135,6 @@ static u64 pci_size(u64 base, u64 maxbase, u64 mask)
 	return size;
 }
 
-enum pci_bar_type {
-	pci_bar_unknown,	/* Standard PCI BAR probe */
-	pci_bar_io,		/* An io port BAR */
-	pci_bar_mem32,		/* A 32-bit memory BAR */
-	pci_bar_mem64,		/* A 64-bit memory BAR */
-};
-
 static inline enum pci_bar_type decode_bar(struct resource *res, u32 bar)
 {
 	if ((bar & PCI_BASE_ADDRESS_SPACE) == PCI_BASE_ADDRESS_SPACE_IO) {
@@ -156,11 +149,16 @@ static inline enum pci_bar_type decode_bar(struct resource *res, u32 bar)
 	return pci_bar_mem32;
 }
 
-/*
- * If the type is not unknown, we assume that the lowest bit is 'enable'.
- * Returns 1 if the BAR was 64-bit and 0 if it was 32-bit.
+/**
+ * pci_read_base - read a PCI BAR
+ * @dev: the PCI device
+ * @type: type of the BAR
+ * @res: resource buffer to be filled in
+ * @pos: BAR position in the config space
+ *
+ * Returns 1 if the BAR is 64-bit, or 0 if 32-bit.
  */
-static int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
+int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 			struct resource *res, unsigned int pos)
 {
 	u32 l, sz, mask;

commit fde09c6d8f92de0c9f75698a75f0989f2234c517
Author: Yu Zhao <yu.zhao@intel.com>
Date:   Sat Nov 22 02:39:32 2008 +0800

    PCI: define PCI resource names in an 'enum'
    
    This patch moves all definitions of the PCI resource names to an 'enum',
    and also replaces some hard-coded resource variables with symbol
    names. This change eases introduction of device specific resources.
    
    Reviewed-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Yu Zhao <yu.zhao@intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 5dcf2b65e3f9..e1cf5d50ed4d 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -423,7 +423,7 @@ static struct pci_bus *pci_alloc_child_bus(struct pci_bus *parent,
 	child->subordinate = 0xff;
 
 	/* Set up default resource pointers and names.. */
-	for (i = 0; i < 4; i++) {
+	for (i = 0; i < PCI_BRIDGE_RESOURCE_NUM; i++) {
 		child->resource[i] = &bridge->resource[PCI_BRIDGE_RESOURCES+i];
 		child->resource[i]->name = child->name;
 	}

commit 63f4898ace2788a89ed685672aab092e1c3e50e6
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Dec 7 22:02:58 2008 +0100

    PCI: handle PCI state saving with interrupts disabled
    
    Since interrupts will soon be disabled at PCI resume time, we need to
    pre-allocate memory to save/restore PCI config space (or use GFP_ATOMIC,
    but this is safer).
    
    Reported-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: "Rafael J. Wysocki" <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index eb2b985beb48..5dcf2b65e3f9 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -958,6 +958,9 @@ static void pci_init_capabilities(struct pci_dev *dev)
 	/* MSI/MSI-X list */
 	pci_msi_init_pci_dev(dev);
 
+	/* Buffers for saving PCIe and PCI-X capabilities */
+	pci_allocate_cap_save_buffers(dev);
+
 	/* Power Management */
 	pci_pm_init(dev);
 

commit 1a9271331ab663f3c7cda78d86b884f2ea86d4d7
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Thu Oct 30 02:17:49 2008 +0100

    PCI: struct device - replace bus_id with dev_name(), dev_set_name()
    
    This patch is part of a larger patch series which will remove
    the "char bus_id[20]" name string from struct device. The device
    name is managed in the kobject anyway, and without any size
    limitation, and just needlessly copied into "struct device".
    
    To set and read the device name dev_name(dev) and dev_set_name(dev)
    must be used. If your code uses static kobjects, which it shouldn't
    do, "const char *init_name" can be used to statically provide the
    name the registered device should have. At registration time, the
    init_name field is cleared, to enforce the use of dev_name(dev) to
    access the device name at a later time.
    
    We need to get rid of all occurrences of bus_id in the entire tree
    to be able to enable the new interface. Please apply this patch,
    and possibly convert any remaining remaining occurrences of bus_id.
    
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-Off-By: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 5b3f5937ecf5..eb2b985beb48 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -412,7 +412,7 @@ static struct pci_bus *pci_alloc_child_bus(struct pci_bus *parent,
 	 * registered later in pci_bus_add_devices()
 	 */
 	child->dev.class = &pcibus_class;
-	sprintf(child->dev.bus_id, "%04x:%02x", pci_domain_nr(child), busnr);
+	dev_set_name(&child->dev, "%04x:%02x", pci_domain_nr(child), busnr);
 
 	/*
 	 * Set up the primary, secondary and subordinate
@@ -1130,7 +1130,7 @@ struct pci_bus * pci_create_bus(struct device *parent,
 	memset(dev, 0, sizeof(*dev));
 	dev->parent = parent;
 	dev->release = pci_release_bus_bridge_dev;
-	sprintf(dev->bus_id, "pci%04x:%02x", pci_domain_nr(b), bus);
+	dev_set_name(dev, "pci%04x:%02x", pci_domain_nr(b), bus);
 	error = device_register(dev);
 	if (error)
 		goto dev_reg_err;
@@ -1141,7 +1141,7 @@ struct pci_bus * pci_create_bus(struct device *parent,
 
 	b->dev.class = &pcibus_class;
 	b->dev.parent = b->bridge;
-	sprintf(b->dev.bus_id, "%04x:%02x", pci_domain_nr(b), bus);
+	dev_set_name(&b->dev, "%04x:%02x", pci_domain_nr(b), bus);
 	error = device_register(&b->dev);
 	if (error)
 		goto class_dev_reg_err;

commit 588235bb53f2c215f0d4b08fd30b461fedc3338e
Author: Mike Travis <travis@sgi.com>
Date:   Sun Jan 4 05:18:02 2009 -0800

    cpumask: update pci_bus_show_cpuaffinity to use new cpumask API
    
    Impact: use new cpumask API to reduce stack usage
    
    Replace the local cpumask_t variable with a pointer to the
    const cpumask that needs to be printed.
    
    Signed-off-by: Mike Travis <travis@sgi.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 5b3f5937ecf5..5a021b82bc04 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -51,12 +51,12 @@ static ssize_t pci_bus_show_cpuaffinity(struct device *dev,
 					char *buf)
 {
 	int ret;
-	cpumask_t cpumask;
+	const struct cpumask *cpumask;
 
-	cpumask = pcibus_to_cpumask(to_pci_bus(dev));
+	cpumask = cpumask_of_pcibus(to_pci_bus(dev));
 	ret = type?
-		cpulist_scnprintf(buf, PAGE_SIZE-2, &cpumask) :
-		cpumask_scnprintf(buf, PAGE_SIZE-2, &cpumask);
+		cpulist_scnprintf(buf, PAGE_SIZE-2, cpumask) :
+		cpumask_scnprintf(buf, PAGE_SIZE-2, cpumask);
 	buf[ret++] = '\n';
 	buf[ret] = '\0';
 	return ret;

commit 29c0177e6a4ac094302bed54a1d4bbb6b740a9ef
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Sat Dec 13 21:20:25 2008 +1030

    cpumask: change cpumask_scnprintf, cpumask_parse_user, cpulist_parse, and cpulist_scnprintf to take pointers.
    
    Impact: change calling convention of existing cpumask APIs
    
    Most cpumask functions started with cpus_: these have been replaced by
    cpumask_ ones which take struct cpumask pointers as expected.
    
    These four functions don't have good replacement names; fortunately
    they're rarely used, so we just change them over.
    
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Mike Travis <travis@sgi.com>
    Acked-by: Ingo Molnar <mingo@elte.hu>
    Cc: paulus@samba.org
    Cc: mingo@redhat.com
    Cc: tony.luck@intel.com
    Cc: ralf@linux-mips.org
    Cc: Greg Kroah-Hartman <gregkh@suse.de>
    Cc: cl@linux-foundation.org
    Cc: srostedt@redhat.com

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 003a9b3c293f..5b3f5937ecf5 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -55,8 +55,8 @@ static ssize_t pci_bus_show_cpuaffinity(struct device *dev,
 
 	cpumask = pcibus_to_cpumask(to_pci_bus(dev));
 	ret = type?
-		cpulist_scnprintf(buf, PAGE_SIZE-2, cpumask):
-		cpumask_scnprintf(buf, PAGE_SIZE-2, cpumask);
+		cpulist_scnprintf(buf, PAGE_SIZE-2, &cpumask) :
+		cpumask_scnprintf(buf, PAGE_SIZE-2, &cpumask);
 	buf[ret++] = '\n';
 	buf[ret] = '\0';
 	return ret;

commit a491913ff22c2b69d937d14296db6fa34dbff068
Author: Zhao, Yu <yu.zhao@intel.com>
Date:   Mon Oct 13 21:02:27 2008 +0800

    PCI: remove unused resource assignment in pci_read_bridge_bases()
    
    This cleanup removes the resource assignment in pci_read_bridge_bases()
    since it has taken care by pci_alloc_child_bus() when allocating the bus:
    
            /* Set up default resource pointers and names.. */
            for (i = 0; i < PCI_BRIDGE_RES_NUM; i++) {
                    child->resource[i] = &bridge->resource[PCI_BRIDGE_RESOURCES+i];
                    child->resource[i]->name = child->name;
            }
    
    Signed-off-by: Yu Zhao <yu.zhao@intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 6f1e51d77bce..003a9b3c293f 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -298,9 +298,6 @@ void __devinit pci_read_bridge_bases(struct pci_bus *child)
 			child->resource[i] = child->parent->resource[i - 3];
 	}
 
-	for(i=0; i<3; i++)
-		child->resource[i] = &dev->resource[PCI_BRIDGE_RESOURCES+i];
-
 	res = child->resource[0];
 	pci_read_config_byte(dev, PCI_IO_BASE, &io_base_lo);
 	pci_read_config_byte(dev, PCI_IO_LIMIT, &io_limit_lo);

commit a1c19894b786f10c76ac40e93c6b5d70c9b946d2
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Tue Oct 21 10:06:29 2008 +1100

    PCI: Workaround invalid P2P bridge bus numbers
    
    Some firmware fail to properly configure P2P bridges, leaving them
    with invalid bus numbers. In some cases, this happens on some embedded
    4xx boards as the result of the kernel allocating different bus space
    than the firmware does to host bridges while not setting
    pcibios_assign_all_busses() for various reasons. In other cases, it can
    just be bogus firmware.
    
    This adds some sanity checking to the PCI probing code. If a bridge is
    found whose primary bus number doesn't match the bus it's sitting on,
    or whose secondary bus number not strictly above it's primary bus
    number, then the bridge bus numbers are deconfigured in the first pass
    of pci_scan_bridge() to be re-assigned in the second pass.
    
    Tested-by: "Ayman El-Khashab" <AymanE@tanisys.com>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index aaaf0a1fed22..6f1e51d77bce 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -480,19 +480,27 @@ int __devinit pci_scan_bridge(struct pci_bus *bus, struct pci_dev *dev, int max,
 	int is_cardbus = (dev->hdr_type == PCI_HEADER_TYPE_CARDBUS);
 	u32 buses, i, j = 0;
 	u16 bctl;
+	int broken = 0;
 
 	pci_read_config_dword(dev, PCI_PRIMARY_BUS, &buses);
 
 	dev_dbg(&dev->dev, "scanning behind bridge, config %06x, pass %d\n",
 		buses & 0xffffff, pass);
 
+	/* Check if setup is sensible at all */
+	if (!pass &&
+	    ((buses & 0xff) != bus->number || ((buses >> 8) & 0xff) <= bus->number)) {
+		dev_dbg(&dev->dev, "bus configuration invalid, reconfiguring\n");
+		broken = 1;
+	}
+
 	/* Disable MasterAbortMode during probing to avoid reporting
 	   of bus errors (in some architectures) */ 
 	pci_read_config_word(dev, PCI_BRIDGE_CONTROL, &bctl);
 	pci_write_config_word(dev, PCI_BRIDGE_CONTROL,
 			      bctl & ~PCI_BRIDGE_CTL_MASTER_ABORT);
 
-	if ((buses & 0xffff00) && !pcibios_assign_all_busses() && !is_cardbus) {
+	if ((buses & 0xffff00) && !pcibios_assign_all_busses() && !is_cardbus && !broken) {
 		unsigned int cmax, busnr;
 		/*
 		 * Bus already configured by firmware, process it in the first
@@ -530,7 +538,7 @@ int __devinit pci_scan_bridge(struct pci_bus *bus, struct pci_dev *dev, int max,
 		 * do in the second pass.
 		 */
 		if (!pass) {
-			if (pcibios_assign_all_busses())
+			if (pcibios_assign_all_busses() || broken)
 				/* Temporarily disable forwarding of the
 				   configuration cycles on all bridges in
 				   this bus segment to avoid possible

commit f19aeb1f3638b7bb4ca21eb361f004fac2bfe259
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Fri Oct 3 19:49:32 2008 +1000

    PCI: Add ability to mmap legacy_io on some platforms
    
    This adds the ability to mmap legacy IO space to the legacy_io files
    in sysfs on platforms that support it. This will allow to clean up
    X to use this instead of /dev/mem for legacy IO accesses such as
    those performed by Int10.
    
    While at it I moved pci_create/remove_legacy_files() to pci-sysfs.c
    where I think they belong, thus making more things statis in there
    and cleaned up some spurrious prototypes in the ia64 pci.h file
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index afb9f1c0bc28..aaaf0a1fed22 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -42,72 +42,6 @@ int no_pci_devices(void)
 }
 EXPORT_SYMBOL(no_pci_devices);
 
-#ifdef HAVE_PCI_LEGACY
-/**
- * pci_create_legacy_files - create legacy I/O port and memory files
- * @b: bus to create files under
- *
- * Some platforms allow access to legacy I/O port and ISA memory space on
- * a per-bus basis.  This routine creates the files and ties them into
- * their associated read, write and mmap files from pci-sysfs.c
- *
- * On error unwind, but don't propogate the error to the caller
- * as it is ok to set up the PCI bus without these files.
- */
-static void pci_create_legacy_files(struct pci_bus *b)
-{
-	int error;
-
-	b->legacy_io = kzalloc(sizeof(struct bin_attribute) * 2,
-			       GFP_ATOMIC);
-	if (!b->legacy_io)
-		goto kzalloc_err;
-
-	b->legacy_io->attr.name = "legacy_io";
-	b->legacy_io->size = 0xffff;
-	b->legacy_io->attr.mode = S_IRUSR | S_IWUSR;
-	b->legacy_io->read = pci_read_legacy_io;
-	b->legacy_io->write = pci_write_legacy_io;
-	error = device_create_bin_file(&b->dev, b->legacy_io);
-	if (error)
-		goto legacy_io_err;
-
-	/* Allocated above after the legacy_io struct */
-	b->legacy_mem = b->legacy_io + 1;
-	b->legacy_mem->attr.name = "legacy_mem";
-	b->legacy_mem->size = 1024*1024;
-	b->legacy_mem->attr.mode = S_IRUSR | S_IWUSR;
-	b->legacy_mem->mmap = pci_mmap_legacy_mem;
-	error = device_create_bin_file(&b->dev, b->legacy_mem);
-	if (error)
-		goto legacy_mem_err;
-
-	return;
-
-legacy_mem_err:
-	device_remove_bin_file(&b->dev, b->legacy_io);
-legacy_io_err:
-	kfree(b->legacy_io);
-	b->legacy_io = NULL;
-kzalloc_err:
-	printk(KERN_WARNING "pci: warning: could not create legacy I/O port "
-	       "and ISA memory resources to sysfs\n");
-	return;
-}
-
-void pci_remove_legacy_files(struct pci_bus *b)
-{
-	if (b->legacy_io) {
-		device_remove_bin_file(&b->dev, b->legacy_io);
-		device_remove_bin_file(&b->dev, b->legacy_mem);
-		kfree(b->legacy_io); /* both are allocated here */
-	}
-}
-#else /* !HAVE_PCI_LEGACY */
-static inline void pci_create_legacy_files(struct pci_bus *bus) { return; }
-void pci_remove_legacy_files(struct pci_bus *bus) { return; }
-#endif /* HAVE_PCI_LEGACY */
-
 /*
  * PCI Bus Class Devices
  */

commit f393d9b130423a7a47c751b26df07ceaa5dc76a9
Author: Vincent Legoll <vincent.legoll@gmail.com>
Date:   Sun Oct 12 12:26:12 2008 +0200

    PCI: probing debug message uniformization
    
    This patch uniformizes PCI probing debug boot messages with dev_printk()
    intead of manual printk()
    
    It changes adress range output from [%llx, %llx] to [%#llx-%#llx], like
    in pci_request_region().
    
    For example, it goes from the mixed-style:
    
    PCI: 0000:00:1b.0 reg 10 64bit mmio: [f4280000, f4283fff]
    pci 0000:00:1b.0: PME# supported from D0 D3hot D3cold
    
    to uniform:
    
    pci 0000:00:1b.0: reg 10 64bit mmio: [0xf4280000-0xf4283fff]
    pci 0000:00:1b.0: PME# supported from D0 D3hot D3cold
    
    This patch has been runtime tested, boot log messages diffed, everything
    looks OK.
    
    Acked-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Vincent Legoll <vincent.legoll@gmail.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 3141e8deeac4..afb9f1c0bc28 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -302,8 +302,8 @@ static int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 		} else {
 			res->start = l64;
 			res->end = l64 + sz64;
-			printk(KERN_DEBUG "PCI: %s reg %x 64bit mmio: %pR\n",
-				pci_name(dev), pos, res);
+			dev_printk(KERN_DEBUG, &dev->dev,
+				"reg %x 64bit mmio: %pR\n", pos, res);
 		}
 	} else {
 		sz = pci_size(l, sz, mask);
@@ -313,10 +313,10 @@ static int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 
 		res->start = l;
 		res->end = l + sz;
-		printk(KERN_DEBUG "PCI: %s reg %x %s: %pR\n",
-		       pci_name(dev), pos,
-		       (res->flags & IORESOURCE_IO) ? "io port":"32bit mmio",
-		       res);
+
+		dev_printk(KERN_DEBUG, &dev->dev, "reg %x %s: %pR\n", pos,
+			(res->flags & IORESOURCE_IO) ? "io port" : "32bit mmio",
+			res);
 	}
 
  out:
@@ -387,8 +387,7 @@ void __devinit pci_read_bridge_bases(struct pci_bus *child)
 			res->start = base;
 		if (!res->end)
 			res->end = limit + 0xfff;
-		printk(KERN_DEBUG "PCI: bridge %s io port: %pR\n",
-		       pci_name(dev), res);
+		dev_printk(KERN_DEBUG, &dev->dev, "bridge io port: %pR\n", res);
 	}
 
 	res = child->resource[1];
@@ -400,8 +399,8 @@ void __devinit pci_read_bridge_bases(struct pci_bus *child)
 		res->flags = (mem_base_lo & PCI_MEMORY_RANGE_TYPE_MASK) | IORESOURCE_MEM;
 		res->start = base;
 		res->end = limit + 0xfffff;
-		printk(KERN_DEBUG "PCI: bridge %s 32bit mmio: %pR\n",
-		       pci_name(dev), res);
+		dev_printk(KERN_DEBUG, &dev->dev, "bridge 32bit mmio: %pR\n",
+			res);
 	}
 
 	res = child->resource[2];
@@ -437,9 +436,9 @@ void __devinit pci_read_bridge_bases(struct pci_bus *child)
 		res->flags = (mem_base_lo & PCI_MEMORY_RANGE_TYPE_MASK) | IORESOURCE_MEM | IORESOURCE_PREFETCH;
 		res->start = base;
 		res->end = limit + 0xfffff;
-		printk(KERN_DEBUG "PCI: bridge %s %sbit mmio pref: %pR\n",
-		       pci_name(dev),
-		       (res->flags & PCI_PREF_RANGE_TYPE_64) ? "64":"32", res);
+		dev_printk(KERN_DEBUG, &dev->dev, "bridge %sbit mmio pref: %pR\n",
+			(res->flags & PCI_PREF_RANGE_TYPE_64) ? "64" : "32",
+			res);
 	}
 }
 

commit 58c3a727cb73b75a9104d295f096cca12959a5a5
Author: Yu Zhao <yu.zhao@intel.com>
Date:   Tue Oct 14 14:02:53 2008 +0800

    PCI: support PCIe ARI capability
    
    This patch adds support for PCI Express Alternative Routing-ID
    Interpretation (ARI) capability.
    
    The ARI capability extends the Function Number field of the PCI Express
    Endpoint by reusing the Device Number which is otherwise hardwired to 0.
    With ARI, an Endpoint can have up to 256 functions.
    
    Signed-off-by: Yu Zhao <yu.zhao@intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 8c158b9abd41..3141e8deeac4 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1025,6 +1025,9 @@ static void pci_init_capabilities(struct pci_dev *dev)
 
 	/* Vital Product Data */
 	pci_vpd_pci22_init(dev);
+
+	/* Alternative Routing-ID Forwarding */
+	pci_enable_ari(dev);
 }
 
 void pci_device_add(struct pci_dev *dev, struct pci_bus *bus)

commit 201de56eb22f1ff3f36804bc70cbff220b50f067
Author: Zhao, Yu <yu.zhao@intel.com>
Date:   Mon Oct 13 19:49:55 2008 +0800

    PCI: centralize the capabilities code in probe.c
    
    This patch centralizes the initialization and release functions of
    various PCI capabilities in probe.c, which makes the introduction
    of new capability support functions cleaner in the future.
    
    Signed-off-by: Yu Zhao <yu.zhao@intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 49599ac49bda..8c158b9abd41 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -842,6 +842,11 @@ static int pci_setup_device(struct pci_dev * dev)
 	return 0;
 }
 
+static void pci_release_capabilities(struct pci_dev *dev)
+{
+	pci_vpd_release(dev);
+}
+
 /**
  * pci_release_dev - free a pci device structure when all users of it are finished.
  * @dev: device that's been disconnected
@@ -854,7 +859,7 @@ static void pci_release_dev(struct device *dev)
 	struct pci_dev *pci_dev;
 
 	pci_dev = to_pci_dev(dev);
-	pci_vpd_release(pci_dev);
+	pci_release_capabilities(pci_dev);
 	kfree(pci_dev);
 }
 
@@ -935,8 +940,6 @@ struct pci_dev *alloc_pci_dev(void)
 
 	INIT_LIST_HEAD(&dev->bus_list);
 
-	pci_msi_init_pci_dev(dev);
-
 	return dev;
 }
 EXPORT_SYMBOL(alloc_pci_dev);
@@ -1009,11 +1012,21 @@ static struct pci_dev *pci_scan_device(struct pci_bus *bus, int devfn)
 		return NULL;
 	}
 
-	pci_vpd_pci22_init(dev);
-
 	return dev;
 }
 
+static void pci_init_capabilities(struct pci_dev *dev)
+{
+	/* MSI/MSI-X list */
+	pci_msi_init_pci_dev(dev);
+
+	/* Power Management */
+	pci_pm_init(dev);
+
+	/* Vital Product Data */
+	pci_vpd_pci22_init(dev);
+}
+
 void pci_device_add(struct pci_dev *dev, struct pci_bus *bus)
 {
 	device_initialize(&dev->dev);
@@ -1030,8 +1043,8 @@ void pci_device_add(struct pci_dev *dev, struct pci_bus *bus)
 	/* Fix up broken headers */
 	pci_fixup_device(pci_fixup_header, dev);
 
-	/* Initialize power management of the device */
-	pci_pm_init(dev);
+	/* Initialize various capabilities */
+	pci_init_capabilities(dev);
 
 	/*
 	 * Add the device to our list of discovered devices

commit e354597cce8d219d135d65e585dc4f30323486b9
Author: Peter Chubb <peterc@gelato.unsw.edu.au>
Date:   Mon Oct 13 11:49:04 2008 +1100

    PCI: fix 64-vbit prefetchable memory resource BARs
    
    Since patch 6ac665c63dcac8fcec534a1d224ecbb8b867ad59 my infiniband
    controller hasn't worked.  This is because it has 64-bit prefetchable
    memory, which was mistakenly being  taken to be 32-bit memory.  The
    resource flags in this case are PCI_BASE_ADDRESS_MEM_TYPE_64 |
    PCI_BASE_ADDRESS_MEM_PREFETCH.
    
    This patch checks only for the PCI_BASE_ADDRESS_MEM_TYPE_64 bit; thus
    whether the region is prefetchable or not is ignored.  This fixes my
    Infiniband.
    
    Reviewed-by: Matthew Wilcox <matthew@wil.cx>
    Signed-off-by: Peter Chubb <peterc@gelato.unsw.edu.au>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index f6754e87f046..49599ac49bda 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -217,7 +217,7 @@ static inline enum pci_bar_type decode_bar(struct resource *res, u32 bar)
 
 	res->flags = bar & ~PCI_BASE_ADDRESS_MEM_MASK;
 
-	if (res->flags == PCI_BASE_ADDRESS_MEM_TYPE_64)
+	if (res->flags & PCI_BASE_ADDRESS_MEM_TYPE_64)
 		return pci_bar_mem64;
 	return pci_bar_mem32;
 }

commit 557848c3c03ad1d1e66cb3b5b06698e3a9ebc33c
Author: Zhao, Yu <yu.zhao@intel.com>
Date:   Mon Oct 13 19:18:07 2008 +0800

    PCI: replace cfg space size (256/4096) by macros.
    
    This is a cleanup that changes all PCI configuration space size
    representations to the macros (PCI_CFG_SPACE_SIZE and
    PCI_CFG_SPACE_EXP_SIZE). And the macros are also moved from
    drivers/pci/probe.c to drivers/pci/pci.h.
    
    Signed-off-by: Yu Zhao <yu.zhao@intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 7aa71636dd3c..f6754e87f046 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -14,8 +14,6 @@
 
 #define CARDBUS_LATENCY_TIMER	176	/* secondary latency timer */
 #define CARDBUS_RESERVE_BUSNR	3
-#define PCI_CFG_SPACE_SIZE	256
-#define PCI_CFG_SPACE_EXP_SIZE	4096
 
 /* Ugh.  Need to stop exporting this to modules. */
 LIST_HEAD(pci_root_buses);
@@ -887,8 +885,9 @@ static void set_pcie_port_type(struct pci_dev *pdev)
 int pci_cfg_space_size_ext(struct pci_dev *dev)
 {
 	u32 status;
+	int pos = PCI_CFG_SPACE_SIZE;
 
-	if (pci_read_config_dword(dev, 256, &status) != PCIBIOS_SUCCESSFUL)
+	if (pci_read_config_dword(dev, pos, &status) != PCIBIOS_SUCCESSFUL)
 		goto fail;
 	if (status == 0xffffffff)
 		goto fail;

commit cef354db0d7a7207ea78c716753d9216a9c2b7e1
Author: Alex Chiang <achiang@hp.com>
Date:   Tue Sep 2 09:40:51 2008 -0600

    PCI: connect struct pci_dev to struct pci_slot
    
    The introduction of struct pci_slot (f46753c5e354b857b20ab8e0fe7b25)
    added a struct pci_slot pointer to struct pci_dev, but we forgot to
    associate the two.
    
    Connect the two structs together; the interesting portions of the object
    lifetimes are:
    
            - when a new pci_slot is created, connect it to the appropriate
              pci_dev's. A single pci_slot may be associated with multiple
              pci_dev's, e.g. any multi-function PCI device.
    
            - when a pci_slot is released, look for all the pci_dev's it was
              associated with, and set their pci_slot pointers to NULL
    
            - when a pci_dev is created, look for slots to associate with.
    
    Note -- when a pci_dev is released, we don't need to do any bookkeeping,
    since pci_slot's do not have pointers to pci_dev's.
    
    Signed-off-by: Alex Chiang <achiang@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 578d15f49e02..7aa71636dd3c 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -949,6 +949,7 @@ EXPORT_SYMBOL(alloc_pci_dev);
 static struct pci_dev *pci_scan_device(struct pci_bus *bus, int devfn)
 {
 	struct pci_dev *dev;
+	struct pci_slot *slot;
 	u32 l;
 	u8 hdr_type;
 	int delay = 1;
@@ -997,6 +998,10 @@ static struct pci_dev *pci_scan_device(struct pci_bus *bus, int devfn)
 	dev->error_state = pci_channel_io_normal;
 	set_pcie_port_type(dev);
 
+	list_for_each_entry(slot, &bus->slots, list)
+		if (PCI_SLOT(devfn) == slot->number)
+			dev->slot = slot;
+
 	/* Assume 32-bit PCI; let 64-bit PCI cards (which are far rarer)
 	   set this higher, assuming the system even supports it.  */
 	dev->dma_mask = 0xffffffff;

commit 34a2e15e95fce6d6f4d30162f53a0ceb25d5bbaf
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Aug 25 15:45:20 2008 -0600

    PCI: follow lspci device/vendor style
    
    Use "[%04x:%04x]" for PCI vendor/device IDs to follow the format
    used by lspci(8).
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index d3db8b249729..578d15f49e02 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -762,7 +762,7 @@ static int pci_setup_device(struct pci_dev * dev)
 	dev->class = class;
 	class >>= 8;
 
-	dev_dbg(&dev->dev, "found [%04x/%04x] class %06x header type %02x\n",
+	dev_dbg(&dev->dev, "found [%04x:%04x] class %06x header type %02x\n",
 		 dev->vendor, dev->device, class, dev->hdr_type);
 
 	/* "Unknown power state" */

commit 096e6f673dc02a6394dc9a7d8f8735c6978f5b91
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Mon Oct 20 15:07:37 2008 +1100

    pci: Use new %pR to print resource ranges
    
    This converts things in drivers/pci to use %pR to printout the
    content of a struct resource instead of hand-casted %llx or
    other variants.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index dd9161a054e1..d3db8b249729 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -304,9 +304,8 @@ static int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 		} else {
 			res->start = l64;
 			res->end = l64 + sz64;
-			printk(KERN_DEBUG "PCI: %s reg %x 64bit mmio: [%llx, %llx]\n",
-				pci_name(dev), pos, (unsigned long long)res->start,
-				(unsigned long long)res->end);
+			printk(KERN_DEBUG "PCI: %s reg %x 64bit mmio: %pR\n",
+				pci_name(dev), pos, res);
 		}
 	} else {
 		sz = pci_size(l, sz, mask);
@@ -316,9 +315,10 @@ static int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 
 		res->start = l;
 		res->end = l + sz;
-		printk(KERN_DEBUG "PCI: %s reg %x %s: [%llx, %llx]\n", pci_name(dev),
-			pos, (res->flags & IORESOURCE_IO) ? "io port":"32bit mmio",
-			(unsigned long long)res->start, (unsigned long long)res->end);
+		printk(KERN_DEBUG "PCI: %s reg %x %s: %pR\n",
+		       pci_name(dev), pos,
+		       (res->flags & IORESOURCE_IO) ? "io port":"32bit mmio",
+		       res);
 	}
 
  out:
@@ -389,9 +389,8 @@ void __devinit pci_read_bridge_bases(struct pci_bus *child)
 			res->start = base;
 		if (!res->end)
 			res->end = limit + 0xfff;
-		printk(KERN_DEBUG "PCI: bridge %s io port: [%llx, %llx]\n",
-			pci_name(dev), (unsigned long long) res->start,
-			(unsigned long long) res->end);
+		printk(KERN_DEBUG "PCI: bridge %s io port: %pR\n",
+		       pci_name(dev), res);
 	}
 
 	res = child->resource[1];
@@ -403,9 +402,8 @@ void __devinit pci_read_bridge_bases(struct pci_bus *child)
 		res->flags = (mem_base_lo & PCI_MEMORY_RANGE_TYPE_MASK) | IORESOURCE_MEM;
 		res->start = base;
 		res->end = limit + 0xfffff;
-		printk(KERN_DEBUG "PCI: bridge %s 32bit mmio: [%llx, %llx]\n",
-			pci_name(dev), (unsigned long long) res->start,
-			(unsigned long long) res->end);
+		printk(KERN_DEBUG "PCI: bridge %s 32bit mmio: %pR\n",
+		       pci_name(dev), res);
 	}
 
 	res = child->resource[2];
@@ -441,9 +439,9 @@ void __devinit pci_read_bridge_bases(struct pci_bus *child)
 		res->flags = (mem_base_lo & PCI_MEMORY_RANGE_TYPE_MASK) | IORESOURCE_MEM | IORESOURCE_PREFETCH;
 		res->start = base;
 		res->end = limit + 0xfffff;
-		printk(KERN_DEBUG "PCI: bridge %s %sbit mmio pref: [%llx, %llx]\n",
-			pci_name(dev), (res->flags & PCI_PREF_RANGE_TYPE_64) ? "64" : "32",
-			(unsigned long long) res->start, (unsigned long long) res->end);
+		printk(KERN_DEBUG "PCI: bridge %s %sbit mmio pref: %pR\n",
+		       pci_name(dev),
+		       (res->flags & PCI_PREF_RANGE_TYPE_64) ? "64":"32", res);
 	}
 }
 

commit 99178b036c97293a65004ff5ec5cff9f833aaecd
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Aug 26 11:00:57 2008 -0500

    Driver core: add bus_sort_breadthfirst() function
    
    The PCI core wants to reorder the devices in the bus list.  So move this
    functionality out of the pci core and into the driver core so that
    anyone else can also do this if needed.  This also lets us change how
    struct device is attached to drivers in the future without messing with
    the PCI core.
    
    Acked-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 36698e57b97f..dd9161a054e1 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1237,8 +1237,11 @@ EXPORT_SYMBOL(pci_scan_bridge);
 EXPORT_SYMBOL_GPL(pci_scan_child_bus);
 #endif
 
-static int __init pci_sort_bf_cmp(const struct pci_dev *a, const struct pci_dev *b)
+static int __init pci_sort_bf_cmp(const struct device *d_a, const struct device *d_b)
 {
+	const struct pci_dev *a = to_pci_dev(d_a);
+	const struct pci_dev *b = to_pci_dev(d_b);
+
 	if      (pci_domain_nr(a->bus) < pci_domain_nr(b->bus)) return -1;
 	else if (pci_domain_nr(a->bus) > pci_domain_nr(b->bus)) return  1;
 
@@ -1251,50 +1254,7 @@ static int __init pci_sort_bf_cmp(const struct pci_dev *a, const struct pci_dev
 	return 0;
 }
 
-/*
- * Yes, this forcably breaks the klist abstraction temporarily.  It
- * just wants to sort the klist, not change reference counts and
- * take/drop locks rapidly in the process.  It does all this while
- * holding the lock for the list, so objects can't otherwise be
- * added/removed while we're swizzling.
- */
-static void __init pci_insertion_sort_klist(struct pci_dev *a, struct list_head *list)
-{
-	struct list_head *pos;
-	struct klist_node *n;
-	struct device *dev;
-	struct pci_dev *b;
-
-	list_for_each(pos, list) {
-		n = container_of(pos, struct klist_node, n_node);
-		dev = container_of(n, struct device, knode_bus);
-		b = to_pci_dev(dev);
-		if (pci_sort_bf_cmp(a, b) <= 0) {
-			list_move_tail(&a->dev.knode_bus.n_node, &b->dev.knode_bus.n_node);
-			return;
-		}
-	}
-	list_move_tail(&a->dev.knode_bus.n_node, list);
-}
-
 void __init pci_sort_breadthfirst(void)
 {
-	LIST_HEAD(sorted_devices);
-	struct list_head *pos, *tmp;
-	struct klist_node *n;
-	struct device *dev;
-	struct pci_dev *pdev;
-	struct klist *device_klist;
-
-	device_klist = bus_get_device_klist(&pci_bus_type);
-
-	spin_lock(&device_klist->k_lock);
-	list_for_each_safe(pos, tmp, &device_klist->k_list) {
-		n = container_of(pos, struct klist_node, n_node);
-		dev = container_of(n, struct device, knode_bus);
-		pdev = to_pci_dev(dev);
-		pci_insertion_sort_klist(pdev, &sorted_devices);
-	}
-	list_splice(&sorted_devices, &device_klist->k_list);
-	spin_unlock(&device_klist->k_lock);
+	bus_sort_breadthfirst(&pci_bus_type, &pci_sort_bf_cmp);
 }

commit 395a125c6237802b19bf22b41017c99ff57f1024
Author: Yinghai Lu <yhlu.kernel@gmail.com>
Date:   Tue Sep 9 12:27:52 2008 -0700

    PCI: re-add debug prints for unmodified BARs
    
    Print out for device BAR values before the kernel tries to update them.
    Also make related output use KERN_DEBUG.
    
    Signed-off-by: Yinghai Lu <yhlu.kernel@gmail.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 0ad936765b26..36698e57b97f 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -304,6 +304,9 @@ static int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 		} else {
 			res->start = l64;
 			res->end = l64 + sz64;
+			printk(KERN_DEBUG "PCI: %s reg %x 64bit mmio: [%llx, %llx]\n",
+				pci_name(dev), pos, (unsigned long long)res->start,
+				(unsigned long long)res->end);
 		}
 	} else {
 		sz = pci_size(l, sz, mask);
@@ -313,6 +316,9 @@ static int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 
 		res->start = l;
 		res->end = l + sz;
+		printk(KERN_DEBUG "PCI: %s reg %x %s: [%llx, %llx]\n", pci_name(dev),
+			pos, (res->flags & IORESOURCE_IO) ? "io port":"32bit mmio",
+			(unsigned long long)res->start, (unsigned long long)res->end);
 	}
 
  out:
@@ -383,7 +389,7 @@ void __devinit pci_read_bridge_bases(struct pci_bus *child)
 			res->start = base;
 		if (!res->end)
 			res->end = limit + 0xfff;
-		printk(KERN_INFO "PCI: bridge %s io port: [%llx, %llx]\n",
+		printk(KERN_DEBUG "PCI: bridge %s io port: [%llx, %llx]\n",
 			pci_name(dev), (unsigned long long) res->start,
 			(unsigned long long) res->end);
 	}
@@ -397,8 +403,9 @@ void __devinit pci_read_bridge_bases(struct pci_bus *child)
 		res->flags = (mem_base_lo & PCI_MEMORY_RANGE_TYPE_MASK) | IORESOURCE_MEM;
 		res->start = base;
 		res->end = limit + 0xfffff;
-		printk(KERN_INFO "PCI: bridge %s 32bit mmio: [%llx, %llx]\n", pci_name(dev),
-			(unsigned long long) res->start, (unsigned long long) res->end);
+		printk(KERN_DEBUG "PCI: bridge %s 32bit mmio: [%llx, %llx]\n",
+			pci_name(dev), (unsigned long long) res->start,
+			(unsigned long long) res->end);
 	}
 
 	res = child->resource[2];
@@ -434,7 +441,7 @@ void __devinit pci_read_bridge_bases(struct pci_bus *child)
 		res->flags = (mem_base_lo & PCI_MEMORY_RANGE_TYPE_MASK) | IORESOURCE_MEM | IORESOURCE_PREFETCH;
 		res->start = base;
 		res->end = limit + 0xfffff;
-		printk(KERN_INFO "PCI: bridge %s %sbit mmio pref: [%llx, %llx]\n",
+		printk(KERN_DEBUG "PCI: bridge %s %sbit mmio pref: [%llx, %llx]\n",
 			pci_name(dev), (res->flags & PCI_PREF_RANGE_TYPE_64) ? "64" : "32",
 			(unsigned long long) res->start, (unsigned long long) res->end);
 	}

commit 4ca8a7726fb0e8094fdb56f2ae2d69fcf9254eae
Author: Johann Felix Soden <johfel@users.sourceforge.net>
Date:   Fri Aug 22 20:46:59 2008 +0200

    PCI: Fix printk warnings in probe.c
    
    The cleaned up resource code in probe.c introduced some warnings:
    drivers/pci/probe.c: In function 'pci_read_bridge_bases':
    drivers/pci/probe.c:386: warning: format '%llx' expects type 'long long unsigned int', but argument 3 has type 'resource_size_t'
    drivers/pci/probe.c:386: warning: format '%llx' expects type 'long long unsigned int', but argument 4 has type 'resource_size_t'
    drivers/pci/probe.c:398: warning: format '%llx' expects type 'long long unsigned int', but argument 3 has type 'resource_size_t'
    drivers/pci/probe.c:398: warning: format '%llx' expects type 'long long unsigned int', but argument 4 has type 'resource_size_t'
    drivers/pci/probe.c:434: warning: format '%llx' expects type 'long long unsigned int', but argument 4 has type 'resource_size_t'
    drivers/pci/probe.c:434: warning: format '%llx' expects type 'long long unsigned int', but argument 5 has type 'resource_size_t'
    
    So fix them up.
    
    Signed-off-by: Johann Felix Soden <johfel@users.sourceforge.net>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index cce2f4cb1fbf..0ad936765b26 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -383,7 +383,9 @@ void __devinit pci_read_bridge_bases(struct pci_bus *child)
 			res->start = base;
 		if (!res->end)
 			res->end = limit + 0xfff;
-		printk(KERN_INFO "PCI: bridge %s io port: [%llx, %llx]\n", pci_name(dev), res->start, res->end);
+		printk(KERN_INFO "PCI: bridge %s io port: [%llx, %llx]\n",
+			pci_name(dev), (unsigned long long) res->start,
+			(unsigned long long) res->end);
 	}
 
 	res = child->resource[1];
@@ -395,7 +397,8 @@ void __devinit pci_read_bridge_bases(struct pci_bus *child)
 		res->flags = (mem_base_lo & PCI_MEMORY_RANGE_TYPE_MASK) | IORESOURCE_MEM;
 		res->start = base;
 		res->end = limit + 0xfffff;
-		printk(KERN_INFO "PCI: bridge %s 32bit mmio: [%llx, %llx]\n", pci_name(dev), res->start, res->end);
+		printk(KERN_INFO "PCI: bridge %s 32bit mmio: [%llx, %llx]\n", pci_name(dev),
+			(unsigned long long) res->start, (unsigned long long) res->end);
 	}
 
 	res = child->resource[2];
@@ -431,7 +434,9 @@ void __devinit pci_read_bridge_bases(struct pci_bus *child)
 		res->flags = (mem_base_lo & PCI_MEMORY_RANGE_TYPE_MASK) | IORESOURCE_MEM | IORESOURCE_PREFETCH;
 		res->start = base;
 		res->end = limit + 0xfffff;
-		printk(KERN_INFO "PCI: bridge %s %sbit mmio pref: [%llx, %llx]\n", pci_name(dev), (res->flags & PCI_PREF_RANGE_TYPE_64)?"64":"32",res->start, res->end);
+		printk(KERN_INFO "PCI: bridge %s %sbit mmio pref: [%llx, %llx]\n",
+			pci_name(dev), (res->flags & PCI_PREF_RANGE_TYPE_64) ? "64" : "32",
+			(unsigned long long) res->start, (unsigned long long) res->end);
 	}
 }
 

commit ce6754235b423610e91f5300e1555c2e4ee1c03a
Merge: 89499759dc0d a83fe32fa668
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Mon Aug 18 09:54:13 2008 -0700

    Merge branch 'pci-for-jesse' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip into x86-merge
    
    Conflicts:
    
            drivers/pci/probe.c

commit a844158a642ffe8b3b29964a88ee802c2834ed0a
Author: Simon Horman <horms@verge.net.au>
Date:   Thu Aug 7 14:56:34 2008 +1000

    PCI: check the return value of device_create_bin_file() in pci_create_bus()
    
    Check the return value of device_create_bin_file in pci_create_bus and
    unwind if necessary. Don't propagate error to caller, as failure to create
    these files shouldn't prevent PCI from being initialised. Instead, just
    log a warning.
    
    Cc: Sven Wegener <sven.wegener@stealer.net>
    Cc: Michael Ellerman <michael@ellerman.id.au>
    Cc: Matthew Wilcox <matthew@wil.cx>
    Signed-off-by: Simon Horman <horms@verge.net.au>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 7098dfb07449..a04498d390c8 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -52,27 +52,49 @@ EXPORT_SYMBOL(no_pci_devices);
  * Some platforms allow access to legacy I/O port and ISA memory space on
  * a per-bus basis.  This routine creates the files and ties them into
  * their associated read, write and mmap files from pci-sysfs.c
+ *
+ * On error unwind, but don't propogate the error to the caller
+ * as it is ok to set up the PCI bus without these files.
  */
 static void pci_create_legacy_files(struct pci_bus *b)
 {
+	int error;
+
 	b->legacy_io = kzalloc(sizeof(struct bin_attribute) * 2,
 			       GFP_ATOMIC);
-	if (b->legacy_io) {
-		b->legacy_io->attr.name = "legacy_io";
-		b->legacy_io->size = 0xffff;
-		b->legacy_io->attr.mode = S_IRUSR | S_IWUSR;
-		b->legacy_io->read = pci_read_legacy_io;
-		b->legacy_io->write = pci_write_legacy_io;
-		device_create_bin_file(&b->dev, b->legacy_io);
-
-		/* Allocated above after the legacy_io struct */
-		b->legacy_mem = b->legacy_io + 1;
-		b->legacy_mem->attr.name = "legacy_mem";
-		b->legacy_mem->size = 1024*1024;
-		b->legacy_mem->attr.mode = S_IRUSR | S_IWUSR;
-		b->legacy_mem->mmap = pci_mmap_legacy_mem;
-		device_create_bin_file(&b->dev, b->legacy_mem);
-	}
+	if (!b->legacy_io)
+		goto kzalloc_err;
+
+	b->legacy_io->attr.name = "legacy_io";
+	b->legacy_io->size = 0xffff;
+	b->legacy_io->attr.mode = S_IRUSR | S_IWUSR;
+	b->legacy_io->read = pci_read_legacy_io;
+	b->legacy_io->write = pci_write_legacy_io;
+	error = device_create_bin_file(&b->dev, b->legacy_io);
+	if (error)
+		goto legacy_io_err;
+
+	/* Allocated above after the legacy_io struct */
+	b->legacy_mem = b->legacy_io + 1;
+	b->legacy_mem->attr.name = "legacy_mem";
+	b->legacy_mem->size = 1024*1024;
+	b->legacy_mem->attr.mode = S_IRUSR | S_IWUSR;
+	b->legacy_mem->mmap = pci_mmap_legacy_mem;
+	error = device_create_bin_file(&b->dev, b->legacy_mem);
+	if (error)
+		goto legacy_mem_err;
+
+	return;
+
+legacy_mem_err:
+	device_remove_bin_file(&b->dev, b->legacy_io);
+legacy_io_err:
+	kfree(b->legacy_io);
+	b->legacy_io = NULL;
+kzalloc_err:
+	printk(KERN_WARNING "pci: warning: could not create legacy I/O port "
+	       "and ISA memory resources to sysfs\n");
+	return;
 }
 
 void pci_remove_legacy_files(struct pci_bus *b)

commit 149e16372a2066c5474d8a8db9b252afd57eb427
Author: Shaohua Li <shaohua.li@intel.com>
Date:   Wed Jul 23 10:32:31 2008 +0800

    PCI: disable ASPM on pre-1.1 PCIe devices
    
    Disable ASPM on pre-1.1 PCIe devices, as many of them don't implement it
    correctly.
    
    Tested-by: Jack Howarth <howarth@bromo.msbb.uc.edu>
    Signed-off-by: Shaohua Li <shaohua.li@intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 203630065839..7098dfb07449 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1057,7 +1057,8 @@ int pci_scan_slot(struct pci_bus *bus, int devfn)
 		}
 	}
 
-	if (bus->self)
+	/* only one slot has pcie device */
+	if (bus->self && nr)
 		pcie_aspm_init_link_state(bus->self);
 
 	return nr;

commit cc5499c3a607a392e8a7adb934aaf14b2c6a3519
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Mon Jul 28 13:39:00 2008 -0400

    PCI: handle 64-bit resources better on 32-bit machines
    
    If the kernel is configured to support 64-bit resources on a 32-bit
    machine, we can support 64-bit BARs properly.  Just change the condition
    to check sizeof(resource_size_t) instead of BITS_PER_LONG.
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 3b690c3512f3..203630065839 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -270,10 +270,10 @@ static int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 		if (!sz64)
 			goto fail;
 
-		if ((BITS_PER_LONG < 64) && (sz64 > 0x100000000ULL)) {
+		if ((sizeof(resource_size_t) < 8) && (sz64 > 0x100000000ULL)) {
 			dev_err(&dev->dev, "can't handle 64-bit BAR\n");
 			goto fail;
-		} else if ((BITS_PER_LONG < 64) && l) {
+		} else if ((sizeof(resource_size_t) < 8) && l) {
 			/* Address above 32-bit boundary; disable the BAR */
 			pci_write_config_dword(dev, pos, 0);
 			pci_write_config_dword(dev, pos + 4, 0);

commit 6ac665c63dcac8fcec534a1d224ecbb8b867ad59
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Mon Jul 28 13:38:59 2008 -0400

    PCI: rewrite PCI BAR reading code
    
    Factor out the code to read one BAR from the loop in pci_read_bases into
    a new function, __pci_read_base.  The new code is slightly more
    readable, better commented and removes the ifdef.
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index b1724cf31b66..3b690c3512f3 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -163,12 +163,9 @@ static inline unsigned int pci_calc_resource_flags(unsigned int flags)
 	return IORESOURCE_MEM;
 }
 
-/*
- * Find the extent of a PCI decode..
- */
-static u32 pci_size(u32 base, u32 maxbase, u32 mask)
+static u64 pci_size(u64 base, u64 maxbase, u64 mask)
 {
-	u32 size = mask & maxbase;	/* Find the significant bits */
+	u64 size = mask & maxbase;	/* Find the significant bits */
 	if (!size)
 		return 0;
 
@@ -184,135 +181,142 @@ static u32 pci_size(u32 base, u32 maxbase, u32 mask)
 	return size;
 }
 
-static u64 pci_size64(u64 base, u64 maxbase, u64 mask)
-{
-	u64 size = mask & maxbase;	/* Find the significant bits */
-	if (!size)
-		return 0;
+enum pci_bar_type {
+	pci_bar_unknown,	/* Standard PCI BAR probe */
+	pci_bar_io,		/* An io port BAR */
+	pci_bar_mem32,		/* A 32-bit memory BAR */
+	pci_bar_mem64,		/* A 64-bit memory BAR */
+};
 
-	/* Get the lowest of them to find the decode size, and
-	   from that the extent.  */
-	size = (size & ~(size-1)) - 1;
+static inline enum pci_bar_type decode_bar(struct resource *res, u32 bar)
+{
+	if ((bar & PCI_BASE_ADDRESS_SPACE) == PCI_BASE_ADDRESS_SPACE_IO) {
+		res->flags = bar & ~PCI_BASE_ADDRESS_IO_MASK;
+		return pci_bar_io;
+	}
 
-	/* base == maxbase can be valid only if the BAR has
-	   already been programmed with all 1s.  */
-	if (base == maxbase && ((base | size) & mask) != mask)
-		return 0;
+	res->flags = bar & ~PCI_BASE_ADDRESS_MEM_MASK;
 
-	return size;
+	if (res->flags == PCI_BASE_ADDRESS_MEM_TYPE_64)
+		return pci_bar_mem64;
+	return pci_bar_mem32;
 }
 
-static inline int is_64bit_memory(u32 mask)
+/*
+ * If the type is not unknown, we assume that the lowest bit is 'enable'.
+ * Returns 1 if the BAR was 64-bit and 0 if it was 32-bit.
+ */
+static int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
+			struct resource *res, unsigned int pos)
 {
-	if ((mask & (PCI_BASE_ADDRESS_SPACE|PCI_BASE_ADDRESS_MEM_TYPE_MASK)) ==
-	    (PCI_BASE_ADDRESS_SPACE_MEMORY|PCI_BASE_ADDRESS_MEM_TYPE_64))
-		return 1;
-	return 0;
-}
+	u32 l, sz, mask;
 
-static void pci_read_bases(struct pci_dev *dev, unsigned int howmany, int rom)
-{
-	unsigned int pos, reg, next;
-	u32 l, sz;
-	struct resource *res;
+	mask = type ? ~PCI_ROM_ADDRESS_ENABLE : ~0;
 
-	for(pos=0; pos<howmany; pos = next) {
-		u64 l64;
-		u64 sz64;
-		u32 raw_sz;
+	res->name = pci_name(dev);
 
-		next = pos+1;
-		res = &dev->resource[pos];
-		res->name = pci_name(dev);
-		reg = PCI_BASE_ADDRESS_0 + (pos << 2);
-		pci_read_config_dword(dev, reg, &l);
-		pci_write_config_dword(dev, reg, ~0);
-		pci_read_config_dword(dev, reg, &sz);
-		pci_write_config_dword(dev, reg, l);
-		if (!sz || sz == 0xffffffff)
-			continue;
-		if (l == 0xffffffff)
-			l = 0;
-		raw_sz = sz;
-		if ((l & PCI_BASE_ADDRESS_SPACE) ==
-				PCI_BASE_ADDRESS_SPACE_MEMORY) {
-			sz = pci_size(l, sz, (u32)PCI_BASE_ADDRESS_MEM_MASK);
-			/*
-			 * For 64bit prefetchable memory sz could be 0, if the
-			 * real size is bigger than 4G, so we need to check
-			 * szhi for that.
-			 */
-			if (!is_64bit_memory(l) && !sz)
-				continue;
-			res->start = l & PCI_BASE_ADDRESS_MEM_MASK;
-			res->flags |= l & ~PCI_BASE_ADDRESS_MEM_MASK;
+	pci_read_config_dword(dev, pos, &l);
+	pci_write_config_dword(dev, pos, mask);
+	pci_read_config_dword(dev, pos, &sz);
+	pci_write_config_dword(dev, pos, l);
+
+	/*
+	 * All bits set in sz means the device isn't working properly.
+	 * If the BAR isn't implemented, all bits must be 0.  If it's a
+	 * memory BAR or a ROM, bit 0 must be clear; if it's an io BAR, bit
+	 * 1 must be clear.
+	 */
+	if (!sz || sz == 0xffffffff)
+		goto fail;
+
+	/*
+	 * I don't know how l can have all bits set.  Copied from old code.
+	 * Maybe it fixes a bug on some ancient platform.
+	 */
+	if (l == 0xffffffff)
+		l = 0;
+
+	if (type == pci_bar_unknown) {
+		type = decode_bar(res, l);
+		res->flags |= pci_calc_resource_flags(l) | IORESOURCE_SIZEALIGN;
+		if (type == pci_bar_io) {
+			l &= PCI_BASE_ADDRESS_IO_MASK;
+			mask = PCI_BASE_ADDRESS_IO_MASK & 0xffff;
 		} else {
-			sz = pci_size(l, sz, PCI_BASE_ADDRESS_IO_MASK & 0xffff);
-			if (!sz)
-				continue;
-			res->start = l & PCI_BASE_ADDRESS_IO_MASK;
-			res->flags |= l & ~PCI_BASE_ADDRESS_IO_MASK;
+			l &= PCI_BASE_ADDRESS_MEM_MASK;
+			mask = (u32)PCI_BASE_ADDRESS_MEM_MASK;
 		}
-		res->end = res->start + (unsigned long) sz;
-		res->flags |= pci_calc_resource_flags(l) | IORESOURCE_SIZEALIGN;
-		if (is_64bit_memory(l)) {
-			u32 szhi, lhi;
-
-			pci_read_config_dword(dev, reg+4, &lhi);
-			pci_write_config_dword(dev, reg+4, ~0);
-			pci_read_config_dword(dev, reg+4, &szhi);
-			pci_write_config_dword(dev, reg+4, lhi);
-			sz64 = ((u64)szhi << 32) | raw_sz;
-			l64 = ((u64)lhi << 32) | l;
-			sz64 = pci_size64(l64, sz64, PCI_BASE_ADDRESS_MEM_MASK);
-			next++;
-#if BITS_PER_LONG == 64
-			if (!sz64) {
-				res->start = 0;
-				res->end = 0;
-				res->flags = 0;
-				continue;
-			}
-			res->start = l64 & PCI_BASE_ADDRESS_MEM_MASK;
-			res->end = res->start + sz64;
-#else
-			if (sz64 > 0x100000000ULL) {
-				dev_err(&dev->dev, "BAR %d: can't handle 64-bit"
-					" BAR\n", pos);
-				res->start = 0;
-				res->flags = 0;
-			} else if (lhi) {
-				/* 64-bit wide address, treat as disabled */
-				pci_write_config_dword(dev, reg,
-					l & ~(u32)PCI_BASE_ADDRESS_MEM_MASK);
-				pci_write_config_dword(dev, reg+4, 0);
-				res->start = 0;
-				res->end = sz;
-			}
-#endif
+	} else {
+		res->flags |= (l & IORESOURCE_ROM_ENABLE);
+		l &= PCI_ROM_ADDRESS_MASK;
+		mask = (u32)PCI_ROM_ADDRESS_MASK;
+	}
+
+	if (type == pci_bar_mem64) {
+		u64 l64 = l;
+		u64 sz64 = sz;
+		u64 mask64 = mask | (u64)~0 << 32;
+
+		pci_read_config_dword(dev, pos + 4, &l);
+		pci_write_config_dword(dev, pos + 4, ~0);
+		pci_read_config_dword(dev, pos + 4, &sz);
+		pci_write_config_dword(dev, pos + 4, l);
+
+		l64 |= ((u64)l << 32);
+		sz64 |= ((u64)sz << 32);
+
+		sz64 = pci_size(l64, sz64, mask64);
+
+		if (!sz64)
+			goto fail;
+
+		if ((BITS_PER_LONG < 64) && (sz64 > 0x100000000ULL)) {
+			dev_err(&dev->dev, "can't handle 64-bit BAR\n");
+			goto fail;
+		} else if ((BITS_PER_LONG < 64) && l) {
+			/* Address above 32-bit boundary; disable the BAR */
+			pci_write_config_dword(dev, pos, 0);
+			pci_write_config_dword(dev, pos + 4, 0);
+			res->start = 0;
+			res->end = sz64;
+		} else {
+			res->start = l64;
+			res->end = l64 + sz64;
 		}
+	} else {
+		sz = pci_size(l, sz, mask);
+
+		if (!sz)
+			goto fail;
+
+		res->start = l;
+		res->end = l + sz;
 	}
+
+ out:
+	return (type == pci_bar_mem64) ? 1 : 0;
+ fail:
+	res->flags = 0;
+	goto out;
+}
+
+static void pci_read_bases(struct pci_dev *dev, unsigned int howmany, int rom)
+{
+	unsigned int pos, reg;
+
+	for (pos = 0; pos < howmany; pos++) {
+		struct resource *res = &dev->resource[pos];
+		reg = PCI_BASE_ADDRESS_0 + (pos << 2);
+		pos += __pci_read_base(dev, pci_bar_unknown, res, reg);
+	}
+
 	if (rom) {
+		struct resource *res = &dev->resource[PCI_ROM_RESOURCE];
 		dev->rom_base_reg = rom;
-		res = &dev->resource[PCI_ROM_RESOURCE];
-		res->name = pci_name(dev);
-		pci_read_config_dword(dev, rom, &l);
-		pci_write_config_dword(dev, rom, ~PCI_ROM_ADDRESS_ENABLE);
-		pci_read_config_dword(dev, rom, &sz);
-		pci_write_config_dword(dev, rom, l);
-		if (l == 0xffffffff)
-			l = 0;
-		if (sz && sz != 0xffffffff) {
-			sz = pci_size(l, sz, (u32)PCI_ROM_ADDRESS_MASK);
-			if (sz) {
-				res->flags = (l & IORESOURCE_ROM_ENABLE) |
-				  IORESOURCE_MEM | IORESOURCE_PREFETCH |
-				  IORESOURCE_READONLY | IORESOURCE_CACHEABLE |
-				  IORESOURCE_SIZEALIGN;
-				res->start = l & PCI_ROM_ADDRESS_MASK;
-				res->end = res->start + (unsigned long) sz;
-			}
-		}
+		res->flags = IORESOURCE_MEM | IORESOURCE_PREFETCH |
+				IORESOURCE_READONLY | IORESOURCE_CACHEABLE |
+				IORESOURCE_SIZEALIGN;
+		__pci_read_base(dev, pci_bar_mem32, res, rom);
 	}
 }
 

commit 0679c2f47d50651018dd5e0bf35330f6e6ae35ec
Merge: 76fbc263ff7e 5b664cb235e9
Author: Ingo Molnar <mingo@elte.hu>
Date:   Fri Jul 18 22:39:59 2008 +0200

    Merge branch 'linus' into pci-for-jesse

commit eb9d0fe40e313c0a74115ef456a2e43a6c8da72f
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Jul 7 03:34:48 2008 +0200

    PCI ACPI: Rework PCI handling of wake-up
    
    * Introduce function acpi_pm_device_sleep_wake() for enabling and
      disabling the system wake-up capability of devices that are power
      manageable by ACPI.
    
    * Introduce function acpi_bus_can_wakeup() allowing other (dependent)
      subsystems to check if ACPI is able to enable the system wake-up
      capability of given device.
    
    * Introduce callback .sleep_wake() in struct pci_platform_pm_ops and
      for the ACPI PCI 'driver' make it use acpi_pm_device_sleep_wake().
    
    * Introduce callback .can_wakeup() in struct pci_platform_pm_ops and
      for the ACPI 'driver' make it use acpi_bus_can_wakeup().
    
    * Move the PME# handlig code out of pci_enable_wake() and split it
      into two functions, pci_pme_capable() and pci_pme_active(),
      allowing the caller to check if given device is capable of
      generating PME# from given power state and to enable/disable the
      device's PME# functionality, respectively.
    
    * Modify pci_enable_wake() to use the new ACPI callbacks and the new
      PME#-related functions.
    
    * Drop the generic .platform_enable_wakeup() callback that is not
      used any more.
    
    * Introduce device_set_wakeup_capable() that will set the
      power.can_wakeup flag of given device.
    
    * Rework PCI device PM initialization so that, if given device is
      capable of generating wake-up events, either natively through the
      PME# mechanism, or with the help of the platform, its
      power.can_wakeup flag is set and its power.should_wakeup flag is
      unset as appropriate.
    
    * Make ACPI set the power.can_wakeup flag for devices found to be
      wake-up capable by it.
    
    * Make the ACPI wake-up code enable/disable GPEs for devices that
      have the wakeup.flags.prepared flag set (which means that their
      wake-up power has been enabled).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 2f0ae70710d6..b1724cf31b66 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -860,49 +860,6 @@ int pci_cfg_space_size_ext(struct pci_dev *dev)
 	return PCI_CFG_SPACE_SIZE;
 }
 
-/**
- * pci_disable_pme - Disable the PME function of PCI device
- * @dev: PCI device affected
- * -EINVAL is returned if PCI device doesn't support PME.
- * Zero is returned if the PME is supported and can be disabled.
- */
-static int pci_disable_pme(struct pci_dev *dev)
-{
-	int pm;
-	u16 value;
-
-	/* find PCI PM capability in list */
-	pm = pci_find_capability(dev, PCI_CAP_ID_PM);
-
-	/* If device doesn't support PM Capabilities, it means that PME is
-	 * not supported.
-	 */
-	if (!pm)
-		return -EINVAL;
-	/* Check device's ability to generate PME# */
-	pci_read_config_word(dev, pm + PCI_PM_PMC, &value);
-
-	value &= PCI_PM_CAP_PME_MASK;
-	/* Check if it can generate PME# */
-	if (!value) {
-		/*
-		 * If it is zero, it means that PME is still unsupported
-		 * although there exists the PM capability.
-		 */
-		return -EINVAL;
-	}
-
-	pci_read_config_word(dev, pm + PCI_PM_CTRL, &value);
-
-	/* Clear PME_Status by writing 1 to it */
-	value |= PCI_PM_CTRL_PME_STATUS ;
-	/* Disable PME enable bit */
-	value &= ~PCI_PM_CTRL_PME_ENABLE;
-	pci_write_config_word(dev, pm + PCI_PM_CTRL, value);
-
-	return 0;
-}
-
 int pci_cfg_space_size(struct pci_dev *dev)
 {
 	int pos;
@@ -1010,7 +967,6 @@ static struct pci_dev *pci_scan_device(struct pci_bus *bus, int devfn)
 	}
 
 	pci_vpd_pci22_init(dev);
-	pci_disable_pme(dev);
 
 	return dev;
 }
@@ -1031,6 +987,9 @@ void pci_device_add(struct pci_dev *dev, struct pci_bus *bus)
 	/* Fix up broken headers */
 	pci_fixup_device(pci_fixup_header, dev);
 
+	/* Initialize power management of the device */
+	pci_pm_init(dev);
+
 	/*
 	 * Add the device to our list of discovered devices
 	 * and the bus list for fixup functions, etc.

commit eebfcfb52ce753eaaa8525078bda6b539586066c
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed Jul 2 13:24:49 2008 -0700

    PCI: handle pci_name() being const
    
    This changes pci_setup_device to handle pci_name() now returning a
    constant string.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 0420fd8027b6..2f0ae70710d6 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -713,9 +713,9 @@ static int pci_setup_device(struct pci_dev * dev)
 {
 	u32 class;
 
-	snprintf(dev->dev.bus_id, BUS_ID_SIZE,
-		 "%04x:%02x:%02x.%d", pci_domain_nr(dev->bus),
-		 dev->bus->number, PCI_SLOT(dev->devfn), PCI_FUNC(dev->devfn));
+	dev_set_name(&dev->dev, "%04x:%02x:%02x.%d", pci_domain_nr(dev->bus),
+		     dev->bus->number, PCI_SLOT(dev->devfn),
+		     PCI_FUNC(dev->devfn));
 
 	pci_read_config_dword(dev, PCI_CLASS_REVISION, &class);
 	dev->revision = class & 0xff;

commit 8b285ce84bbc719e363a796f466404576b840d36
Author: David Howells <dhowells@redhat.com>
Date:   Fri Jun 27 13:23:20 2008 +0100

    PCI: fix pci_setup_device()'s sprinting into a const buffer
    
    Make pci_setup_device() write the bus ID directly into the allotted storage,
    rather than using pci_name() as the address as that now returns a const
    pointer.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index f8291191ef91..0420fd8027b6 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -713,8 +713,9 @@ static int pci_setup_device(struct pci_dev * dev)
 {
 	u32 class;
 
-	sprintf(pci_name(dev), "%04x:%02x:%02x.%d", pci_domain_nr(dev->bus),
-		dev->bus->number, PCI_SLOT(dev->devfn), PCI_FUNC(dev->devfn));
+	snprintf(dev->dev.bus_id, BUS_ID_SIZE,
+		 "%04x:%02x:%02x.%d", pci_domain_nr(dev->bus),
+		 dev->bus->number, PCI_SLOT(dev->devfn), PCI_FUNC(dev->devfn));
 
 	pci_read_config_dword(dev, PCI_CLASS_REVISION, &class);
 	dev->revision = class & 0xff;

commit 80ccba1186d48fa728dc4b1456cc07ffb07da501
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Fri Jun 13 10:52:11 2008 -0600

    PCI: use dev_printk when possible
    
    Convert printks to use dev_printk().
    
    I converted pr_debug() to dev_dbg().  Both use KERN_DEBUG and are enabled
    only when DEBUG is defined.
    
    I converted printk(KERN_DEBUG) to dev_printk(KERN_DEBUG), not to dev_dbg(),
    because dev_dbg() is only enabled when DEBUG is defined.
    
    I converted DBG(KERN_INFO) (only in setup-bus.c) to dev_info().  The DBG()
    name makes it sound like debug, but it's been enabled forever, so dev_info()
    preserves the previous behavior.
    
    I tried to make the resource assignment formats more consistent, e.g.,
      "BAR %d: got res [%#llx-%#llx] bus [%#llx-%#llx] flags %#lx\n"
    instead of sometimes using "start-end" and sometimes using "size@start".
    I'm not attached to one or the other; I'd just like them consistent.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 4562827b7e22..f8291191ef91 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -277,8 +277,8 @@ static void pci_read_bases(struct pci_dev *dev, unsigned int howmany, int rom)
 			res->end = res->start + sz64;
 #else
 			if (sz64 > 0x100000000ULL) {
-				printk(KERN_ERR "PCI: Unable to handle 64-bit "
-					"BAR for device %s\n", pci_name(dev));
+				dev_err(&dev->dev, "BAR %d: can't handle 64-bit"
+					" BAR\n", pos);
 				res->start = 0;
 				res->flags = 0;
 			} else if (lhi) {
@@ -329,7 +329,7 @@ void __devinit pci_read_bridge_bases(struct pci_bus *child)
 		return;
 
 	if (dev->transparent) {
-		printk(KERN_INFO "PCI: Transparent bridge - %s\n", pci_name(dev));
+		dev_info(&dev->dev, "transparent bridge\n");
 		for(i = 3; i < PCI_BUS_NUM_RESOURCES; i++)
 			child->resource[i] = child->parent->resource[i - 3];
 	}
@@ -392,7 +392,8 @@ void __devinit pci_read_bridge_bases(struct pci_bus *child)
 			limit |= ((long) mem_limit_hi) << 32;
 #else
 			if (mem_base_hi || mem_limit_hi) {
-				printk(KERN_ERR "PCI: Unable to handle 64-bit address space for bridge %s\n", pci_name(dev));
+				dev_err(&dev->dev, "can't handle 64-bit "
+					"address space for bridge\n");
 				return;
 			}
 #endif
@@ -512,8 +513,8 @@ int __devinit pci_scan_bridge(struct pci_bus *bus, struct pci_dev *dev, int max,
 
 	pci_read_config_dword(dev, PCI_PRIMARY_BUS, &buses);
 
-	pr_debug("PCI: Scanning behind PCI bridge %s, config %06x, pass %d\n",
-		 pci_name(dev), buses & 0xffffff, pass);
+	dev_dbg(&dev->dev, "scanning behind bridge, config %06x, pass %d\n",
+		buses & 0xffffff, pass);
 
 	/* Disable MasterAbortMode during probing to avoid reporting
 	   of bus errors (in some architectures) */ 
@@ -536,8 +537,8 @@ int __devinit pci_scan_bridge(struct pci_bus *bus, struct pci_dev *dev, int max,
 		 * ignore it.  This can happen with the i450NX chipset.
 		 */
 		if (pci_find_bus(pci_domain_nr(bus), busnr)) {
-			printk(KERN_INFO "PCI: Bus %04x:%02x already known\n",
-					pci_domain_nr(bus), busnr);
+			dev_info(&dev->dev, "bus %04x:%02x already known\n",
+				 pci_domain_nr(bus), busnr);
 			goto out;
 		}
 
@@ -721,7 +722,7 @@ static int pci_setup_device(struct pci_dev * dev)
 	dev->class = class;
 	class >>= 8;
 
-	pr_debug("PCI: Found %s [%04x/%04x] %06x %02x\n", pci_name(dev),
+	dev_dbg(&dev->dev, "found [%04x/%04x] class %06x header type %02x\n",
 		 dev->vendor, dev->device, class, dev->hdr_type);
 
 	/* "Unknown power state" */
@@ -789,13 +790,13 @@ static int pci_setup_device(struct pci_dev * dev)
 		break;
 
 	default:				    /* unknown header */
-		printk(KERN_ERR "PCI: device %s has unknown header type %02x, ignoring.\n",
-			pci_name(dev), dev->hdr_type);
+		dev_err(&dev->dev, "unknown header type %02x, "
+			"ignoring device\n", dev->hdr_type);
 		return -1;
 
 	bad:
-		printk(KERN_ERR "PCI: %s: class %x doesn't match header type %02x. Ignoring class.\n",
-		       pci_name(dev), class, dev->hdr_type);
+		dev_err(&dev->dev, "ignoring class %02x (doesn't match header "
+			"type %02x)\n", class, dev->hdr_type);
 		dev->class = PCI_CLASS_NOT_DEFINED;
 	}
 
@@ -971,7 +972,7 @@ static struct pci_dev *pci_scan_device(struct pci_bus *bus, int devfn)
 			return NULL;
 		/* Card hasn't responded in 60 seconds?  Must be stuck. */
 		if (delay > 60 * 1000) {
-			printk(KERN_WARNING "Device %04x:%02x:%02x.%d not "
+			printk(KERN_WARNING "pci %04x:%02x:%02x.%d: not "
 					"responding\n", pci_domain_nr(bus),
 					bus->number, PCI_SLOT(devfn),
 					PCI_FUNC(devfn));

commit 9bf8a1a79d549a0cf3b26c88d1ac8cdf07deafee
Author: Yinghai Lu <yhlu.kernel@gmail.com>
Date:   Mon Jun 23 20:33:06 2008 +0200

    pci: debug extra pci resources range
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 3706ce7972dd..27cdbb06c4dd 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -275,6 +275,7 @@ static void pci_read_bases(struct pci_dev *dev, unsigned int howmany, int rom)
 			}
 			res->start = l64 & PCI_BASE_ADDRESS_MEM_MASK;
 			res->end = res->start + sz64;
+			printk(KERN_INFO "PCI: %s reg %x 64bit mmio: [%llx, %llx]\n", pci_name(dev), reg, res->start, res->end);
 #else
 			if (sz64 > 0x100000000ULL) {
 				printk(KERN_ERR "PCI: Unable to handle 64-bit "
@@ -290,6 +291,8 @@ static void pci_read_bases(struct pci_dev *dev, unsigned int howmany, int rom)
 				res->end = sz;
 			}
 #endif
+		} else {
+			printk(KERN_INFO "PCI: %s reg %x %s: [%llx, %llx]\n", pci_name(dev), reg, (res->flags & IORESOURCE_IO)? "io port":"32bit mmio", res->start, res->end);
 		}
 	}
 	if (rom) {
@@ -357,6 +360,7 @@ void __devinit pci_read_bridge_bases(struct pci_bus *child)
 			res->start = base;
 		if (!res->end)
 			res->end = limit + 0xfff;
+		printk(KERN_INFO "PCI: bridge %s io port: [%llx, %llx]\n", pci_name(dev), res->start, res->end);
 	}
 
 	res = child->resource[1];
@@ -368,6 +372,7 @@ void __devinit pci_read_bridge_bases(struct pci_bus *child)
 		res->flags = (mem_base_lo & PCI_MEMORY_RANGE_TYPE_MASK) | IORESOURCE_MEM;
 		res->start = base;
 		res->end = limit + 0xfffff;
+		printk(KERN_INFO "PCI: bridge %s 32bit mmio: [%llx, %llx]\n", pci_name(dev), res->start, res->end);
 	}
 
 	res = child->resource[2];
@@ -402,6 +407,7 @@ void __devinit pci_read_bridge_bases(struct pci_bus *child)
 		res->flags = (mem_base_lo & PCI_MEMORY_RANGE_TYPE_MASK) | IORESOURCE_MEM | IORESOURCE_PREFETCH;
 		res->start = base;
 		res->end = limit + 0xfffff;
+		printk(KERN_INFO "PCI: bridge %s %sbit mmio pref: [%llx, %llx]\n", pci_name(dev), (res->flags & PCI_PREF_RANGE_TYPE_64)?"64":"32",res->start, res->end);
 	}
 }
 

commit f46753c5e354b857b20ab8e0fe7b2579831dc369
Author: Alex Chiang <achiang@hp.com>
Date:   Tue Jun 10 15:28:50 2008 -0600

    PCI: introduce pci_slot
    
    Currently, /sys/bus/pci/slots/ only exposes hotplug attributes when a
    hotplug driver is loaded, but PCI slots have attributes such as address,
    speed, width, etc.  that are not related to hotplug at all.
    
    Introduce pci_slot as the primary data structure and kobject model.
    Hotplug attributes described in hotplug_slot become a secondary
    structure associated with the pci_slot.
    
    This patch only creates the infrastructure that allows the separation of
    PCI slot attributes and hotplug attributes.  In this patch, the PCI
    hotplug core remains the only user of this infrastructure, and thus,
    /sys/bus/pci/slots/ will still only become populated when a hotplug
    driver is loaded.
    
    A later patch in this series will add a second user of this new
    infrastructure and demonstrate splitting the task of exposing pci_slot
    attributes from hotplug_slot attributes.
    
      - Make pci_slot the primary sysfs entity. hotplug_slot becomes a
        subsidiary structure.
        o pci_create_slot() creates and registers a slot with the PCI core
        o pci_slot_add_hotplug() gives it hotplug capability
    
      - Change the prototype of pci_hp_register() to take the bus and
        slot number (on parent bus) as parameters.
    
      - Remove all the ->get_address methods since this functionality is
        now handled by pci_slot directly.
    
    [achiang@hp.com: rpaphp-correctly-pci_hp_register-for-empty-pci-slots]
    Tested-by: Badari Pulavarty <pbadari@us.ibm.com>
    Acked-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    [akpm@linux-foundation.org: build fix]
    [akpm@linux-foundation.org: make headers_check happy]
    [akpm@linux-foundation.org: nuther build fix]
    [akpm@linux-foundation.org: fix typo in #include]
    Signed-off-by: Alex Chiang <achiang@hp.com>
    Signed-off-by: Matthew Wilcox <matthew@wil.cx>
    Cc: Greg KH <greg@kroah.com>
    Cc: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
    Cc: Len Brown <lenb@kernel.org>
    Acked-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index aebab71abebf..4562827b7e22 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -414,6 +414,7 @@ static struct pci_bus * pci_alloc_bus(void)
 		INIT_LIST_HEAD(&b->node);
 		INIT_LIST_HEAD(&b->children);
 		INIT_LIST_HEAD(&b->devices);
+		INIT_LIST_HEAD(&b->slots);
 	}
 	return b;
 }

commit 49db139955d3392c6c4facf987905d0a9afed581
Author: Zhao Yakui <yakui.zhao@intel.com>
Date:   Tue May 13 11:15:05 2008 +0800

    PCI: Disable PME during PCI scan
    
    If a device supports #PME and can generate PME events from D0, we may see
    superfluous events before a driver is loaded (drivers should only enable PME as
    needed), preventing suspend from working if the corresponding GPE was enabled.
    
    Likewise, if the ACPI device has the _PRW object, the _PSW/_DSW object will be
    called in order to disable the wakeup functionality. But when it is allowed to
    wake up the sleeping state, OSPM will enable it again.
    
    So we should disable PME in the course of scanning PCI devices and enable it
    again only when PME events are actually required to be generated from the
    requested PCI state (for example, D3_hot or D3_cold).  It is also safe to
    disable PME again when the PME is disabled for the PCI devices.
    
    Signed-off-by: Zhao Yakui <yakui.zhao@intel.com>
    Signed-off-by: Li Shaohua <shaohua.li@intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 3706ce7972dd..aebab71abebf 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -857,6 +857,49 @@ int pci_cfg_space_size_ext(struct pci_dev *dev)
 	return PCI_CFG_SPACE_SIZE;
 }
 
+/**
+ * pci_disable_pme - Disable the PME function of PCI device
+ * @dev: PCI device affected
+ * -EINVAL is returned if PCI device doesn't support PME.
+ * Zero is returned if the PME is supported and can be disabled.
+ */
+static int pci_disable_pme(struct pci_dev *dev)
+{
+	int pm;
+	u16 value;
+
+	/* find PCI PM capability in list */
+	pm = pci_find_capability(dev, PCI_CAP_ID_PM);
+
+	/* If device doesn't support PM Capabilities, it means that PME is
+	 * not supported.
+	 */
+	if (!pm)
+		return -EINVAL;
+	/* Check device's ability to generate PME# */
+	pci_read_config_word(dev, pm + PCI_PM_PMC, &value);
+
+	value &= PCI_PM_CAP_PME_MASK;
+	/* Check if it can generate PME# */
+	if (!value) {
+		/*
+		 * If it is zero, it means that PME is still unsupported
+		 * although there exists the PM capability.
+		 */
+		return -EINVAL;
+	}
+
+	pci_read_config_word(dev, pm + PCI_PM_CTRL, &value);
+
+	/* Clear PME_Status by writing 1 to it */
+	value |= PCI_PM_CTRL_PME_STATUS ;
+	/* Disable PME enable bit */
+	value &= ~PCI_PM_CTRL_PME_ENABLE;
+	pci_write_config_word(dev, pm + PCI_PM_CTRL, value);
+
+	return 0;
+}
+
 int pci_cfg_space_size(struct pci_dev *dev)
 {
 	int pos;
@@ -964,6 +1007,7 @@ static struct pci_dev *pci_scan_device(struct pci_bus *bus, int devfn)
 	}
 
 	pci_vpd_pci22_init(dev);
+	pci_disable_pme(dev);
 
 	return dev;
 }

commit 70b9f7dc1435412ca2b89b13a8353bd9915a7189
Author: Yinghai Lu <yhlu.kernel.send@gmail.com>
Date:   Mon Apr 28 16:27:23 2008 -0700

    x86/pci: remove flag in pci_cfg_space_size_ext
    
    so let pci_cfg_space_size call it directly without flag.
    
    Signed-off-by: Yinghai Lu <yhlu.kernel@gmail.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 4a55bf380957..3706ce7972dd 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -842,13 +842,25 @@ static void set_pcie_port_type(struct pci_dev *pdev)
  * reading the dword at 0x100 which must either be 0 or a valid extended
  * capability header.
  */
-int pci_cfg_space_size_ext(struct pci_dev *dev, unsigned check_exp_pcix)
+int pci_cfg_space_size_ext(struct pci_dev *dev)
 {
-	int pos;
 	u32 status;
 
-	if (!check_exp_pcix)
-		goto skip;
+	if (pci_read_config_dword(dev, 256, &status) != PCIBIOS_SUCCESSFUL)
+		goto fail;
+	if (status == 0xffffffff)
+		goto fail;
+
+	return PCI_CFG_SPACE_EXP_SIZE;
+
+ fail:
+	return PCI_CFG_SPACE_SIZE;
+}
+
+int pci_cfg_space_size(struct pci_dev *dev)
+{
+	int pos;
+	u32 status;
 
 	pos = pci_find_capability(dev, PCI_CAP_ID_EXP);
 	if (!pos) {
@@ -861,23 +873,12 @@ int pci_cfg_space_size_ext(struct pci_dev *dev, unsigned check_exp_pcix)
 			goto fail;
 	}
 
- skip:
-	if (pci_read_config_dword(dev, 256, &status) != PCIBIOS_SUCCESSFUL)
-		goto fail;
-	if (status == 0xffffffff)
-		goto fail;
-
-	return PCI_CFG_SPACE_EXP_SIZE;
+	return pci_cfg_space_size_ext(dev);
 
  fail:
 	return PCI_CFG_SPACE_SIZE;
 }
 
-int pci_cfg_space_size(struct pci_dev *dev)
-{
-	return pci_cfg_space_size_ext(dev, 1);
-}
-
 static void pci_release_bus_bridge_dev(struct device *dev)
 {
 	kfree(dev);

commit 30a18d6c3f1e774de656ebd8ff219d53e2ba4029
Author: Yinghai Lu <Yinghai.Lu@Sun.COM>
Date:   Tue Feb 19 03:21:20 2008 -0800

    x86: multi pci root bus with different io resource range, on 64-bit
    
    scan AMD opteron io/mmio routing to make sure every pci root bus get correct
    resource range. Thus later pci scan could assign correct resource to device
    with unassigned resource.
    
    this can fix a system without _CRS for multi pci root bus.
    
    Signed-off-by: Yinghai Lu <yinghai.lu@sun.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index a40043bd3257..4a55bf380957 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1088,6 +1088,10 @@ unsigned int __devinit pci_scan_child_bus(struct pci_bus *bus)
 	return max;
 }
 
+void __attribute__((weak)) set_pci_bus_resources_arch_default(struct pci_bus *b)
+{
+}
+
 struct pci_bus * pci_create_bus(struct device *parent,
 		int bus, struct pci_ops *ops, void *sysdata)
 {
@@ -1147,6 +1151,8 @@ struct pci_bus * pci_create_bus(struct device *parent,
 	b->resource[0] = &ioport_resource;
 	b->resource[1] = &iomem_resource;
 
+	set_pci_bus_resources_arch_default(b);
+
 	return b;
 
 dev_create_file_err:

commit 0d358f22f6c8f03ab215eee8d52b74f78cc3c7db
Author: Yinghai Lu <Yinghai.Lu@Sun.COM>
Date:   Tue Feb 19 03:20:41 2008 -0800

    driver core: try parent numa_node at first before using default
    
    in the device_add, we try to use use parent numa_node.
    need to make sure pci root bus's bridge device numa_node is set.
    then we could use device->numa_node direclty for all device.
    and don't need to call pcibus_to_node().
    
    Signed-off-by: Yinghai Lu <yinghai.lu@sun.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index a8efdaef1870..a40043bd3257 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -973,7 +973,6 @@ void pci_device_add(struct pci_dev *dev, struct pci_bus *bus)
 	dev->dev.release = pci_release_dev;
 	pci_dev_get(dev);
 
-	set_dev_node(&dev->dev, pcibus_to_node(bus));
 	dev->dev.dma_mask = &dev->dma_mask;
 	dev->dev.dma_parms = &dev->dma_parms;
 	dev->dev.coherent_dma_mask = 0xffffffffull;
@@ -1128,6 +1127,9 @@ struct pci_bus * pci_create_bus(struct device *parent,
 		goto dev_reg_err;
 	b->bridge = get_device(dev);
 
+	if (!parent)
+		set_dev_node(b->bridge, pcibus_to_node(b));
+
 	b->dev.class = &pcibus_class;
 	b->dev.parent = b->bridge;
 	sprintf(b->dev.bus_id, "%04x:%02x", pci_domain_nr(b), bus);

commit 57741a779070e0b141b6148136b420c8d35ccbce
Author: Yinghai Lu <Yinghai.Lu@Sun.COM>
Date:   Fri Feb 15 01:32:50 2008 -0800

    x86_64: set cfg_size for AMD Family 10h in case MMCONFIG
    
    reuse pci_cfg_space_size but skip check pci express and pci-x CAP ID.
    
    Signed-off-by: Yinghai Lu <yinghai.lu@sun.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index f991359f0c36..a8efdaef1870 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -842,11 +842,14 @@ static void set_pcie_port_type(struct pci_dev *pdev)
  * reading the dword at 0x100 which must either be 0 or a valid extended
  * capability header.
  */
-int pci_cfg_space_size(struct pci_dev *dev)
+int pci_cfg_space_size_ext(struct pci_dev *dev, unsigned check_exp_pcix)
 {
 	int pos;
 	u32 status;
 
+	if (!check_exp_pcix)
+		goto skip;
+
 	pos = pci_find_capability(dev, PCI_CAP_ID_EXP);
 	if (!pos) {
 		pos = pci_find_capability(dev, PCI_CAP_ID_PCIX);
@@ -858,6 +861,7 @@ int pci_cfg_space_size(struct pci_dev *dev)
 			goto fail;
 	}
 
+ skip:
 	if (pci_read_config_dword(dev, 256, &status) != PCIBIOS_SUCCESSFUL)
 		goto fail;
 	if (status == 0xffffffff)
@@ -869,6 +873,11 @@ int pci_cfg_space_size(struct pci_dev *dev)
 	return PCI_CFG_SPACE_SIZE;
 }
 
+int pci_cfg_space_size(struct pci_dev *dev)
+{
+	return pci_cfg_space_size_ext(dev, 1);
+}
+
 static void pci_release_bus_bridge_dev(struct device *dev)
 {
 	kfree(dev);

commit bda0c0afa7a694bb1459fd023515aca681e4d79a
Merge: 904e0ab54b75 af40b485ea2d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Apr 21 15:58:35 2008 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/pci-2.6
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/pci-2.6: (42 commits)
      PCI: Change PCI subsystem MAINTAINER
      PCI: pci-iommu-iotlb-flushing-speedup
      PCI: pci_setup_bridge() mustn't be __devinit
      PCI: pci_bus_size_cardbus() mustn't be __devinit
      PCI: pci_scan_device() mustn't be __devinit
      PCI: pci_alloc_child_bus() mustn't be __devinit
      PCI: replace remaining __FUNCTION__ occurrences
      PCI: Hotplug: fakephp: Return success, not ENODEV, when bus rescan is triggered
      PCI: Hotplug: Fix leaks in IBM Hot Plug Controller Driver - ibmphp_init_devno()
      PCI: clean up resource alignment management
      PCI: aerdrv_acpi.c: remove unneeded NULL check
      PCI: Update VIA CX700 quirk
      PCI: Expose PCI VPD through sysfs
      PCI: iommu: iotlb flushing
      PCI: simplify quirk debug output
      PCI: iova RB tree setup tweak
      PCI: parisc: use generic pci_enable_resources()
      PCI: ppc: use generic pci_enable_resources()
      PCI: powerpc: use generic pci_enable_resources()
      PCI: ia64: use generic pci_enable_resources()
      ...

commit 7f7b5de2c0e10aa35ad9909edb1af9f2aed2f5d0
Author: Adrian Bunk <bunk@kernel.org>
Date:   Fri Apr 18 13:53:55 2008 -0700

    PCI: pci_scan_device() mustn't be __devinit
    
    WARNING: drivers/pci/built-in.o(.text+0x150f): Section mismatch in reference from the function pci_scan_single_device() to the function .devinit.text:pci_scan_device()
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 165553360f24..46a475384362 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -875,8 +875,7 @@ EXPORT_SYMBOL(alloc_pci_dev);
  * Read the config data for a PCI device, sanity-check it
  * and fill in the dev structure...
  */
-static struct pci_dev * __devinit
-pci_scan_device(struct pci_bus *bus, int devfn)
+static struct pci_dev *pci_scan_device(struct pci_bus *bus, int devfn)
 {
 	struct pci_dev *dev;
 	u32 l;

commit cbd4e055fc8f09db82d31a5ff6cec3c083cc97a8
Author: Adrian Bunk <bunk@kernel.org>
Date:   Fri Apr 18 13:53:55 2008 -0700

    PCI: pci_alloc_child_bus() mustn't be __devinit
    
    WARNING: drivers/pci/built-in.o(.text+0xc4c): Section mismatch in reference from the function pci_add_new_bus() to the function .devinit.text:pci_alloc_child_bus()
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 33d9b8bea6e0..165553360f24 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -399,8 +399,8 @@ static struct pci_bus * pci_alloc_bus(void)
 	return b;
 }
 
-static struct pci_bus * __devinit
-pci_alloc_child_bus(struct pci_bus *parent, struct pci_dev *bridge, int busnr)
+static struct pci_bus *pci_alloc_child_bus(struct pci_bus *parent,
+					   struct pci_dev *bridge, int busnr)
 {
 	struct pci_bus *child;
 	int i;

commit 884525655d07fdee9245716b998ecdc45cdd8007
Author: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
Date:   Sun Mar 30 19:50:14 2008 +0400

    PCI: clean up resource alignment management
    
    Done per Linus' request and suggestions. Linus has explained that
    better than I'll be able to explain:
    
    On Thu, Mar 27, 2008 at 10:12:10AM -0700, Linus Torvalds wrote:
    > Actually, before we go any further, there might be a less intrusive
    > alternative: add just a couple of flags to the resource flags field (we
    > still have something like 8 unused bits on 32-bit), and use those to
    > implement a generic "resource_alignment()" routine.
    >
    > Two flags would do it:
    >
    >  - IORESOURCE_SIZEALIGN: size indicates alignment (regular PCI device
    >    resources)
    >
    >  - IORESOURCE_STARTALIGN: start field is alignment (PCI bus resources
    >    during probing)
    >
    > and then the case of both flags zero (or both bits set) would actually be
    > "invalid", and we would also clear the IORESOURCE_STARTALIGN flag when we
    > actually allocate the resource (so that we don't use the "start" field as
    > alignment incorrectly when it no longer indicates alignment).
    >
    > That wouldn't be totally generic, but it would have the nice property of
    > automatically at least add sanity checking for that whole "res->start has
    > the odd meaning of 'alignment' during probing" and remove the need for a
    > new field, and it would allow us to have a generic "resource_alignment()"
    > routine that just gets a resource pointer.
    
    Besides, I removed IORESOURCE_BUS_HAS_VGA flag which was unused for ages.
    
    Signed-off-by: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Gary Hade <garyhade@us.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index c2e99fd87faf..33d9b8bea6e0 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -235,7 +235,7 @@ static void pci_read_bases(struct pci_dev *dev, unsigned int howmany, int rom)
 			res->flags |= l & ~PCI_BASE_ADDRESS_IO_MASK;
 		}
 		res->end = res->start + (unsigned long) sz;
-		res->flags |= pci_calc_resource_flags(l);
+		res->flags |= pci_calc_resource_flags(l) | IORESOURCE_SIZEALIGN;
 		if (is_64bit_memory(l)) {
 			u32 szhi, lhi;
 
@@ -288,7 +288,8 @@ static void pci_read_bases(struct pci_dev *dev, unsigned int howmany, int rom)
 			if (sz) {
 				res->flags = (l & IORESOURCE_ROM_ENABLE) |
 				  IORESOURCE_MEM | IORESOURCE_PREFETCH |
-				  IORESOURCE_READONLY | IORESOURCE_CACHEABLE;
+				  IORESOURCE_READONLY | IORESOURCE_CACHEABLE |
+				  IORESOURCE_SIZEALIGN;
 				res->start = l & PCI_ROM_ADDRESS_MASK;
 				res->end = res->start + (unsigned long) sz;
 			}

commit 94e6108803469a37ee1e3c92dafdd1d59298602f
Author: Ben Hutchings <bhutchings@solarflare.com>
Date:   Wed Mar 5 16:52:39 2008 +0000

    PCI: Expose PCI VPD through sysfs
    
    Vital Product Data (VPD) may be exposed by PCI devices in several
    ways.  It is generally unsafe to read this information through the
    existing interfaces to user-land because of stateful interfaces.
    
    This adds:
    - abstract operations for VPD access (struct pci_vpd_ops)
    - VPD state information in struct pci_dev (struct pci_vpd)
    - an implementation of the VPD access method specified in PCI 2.2
      (in access.c)
    - a 'vpd' binary file in sysfs directories for PCI devices with VPD
      operations defined
    
    It adds a probe for PCI 2.2 VPD in pci_scan_device() and release of
    VPD state in pci_release_dev().
    
    Signed-off-by: Ben Hutchings <bhutchings@solarflare.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 284ef392c3ea..c2e99fd87faf 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -794,6 +794,7 @@ static void pci_release_dev(struct device *dev)
 	struct pci_dev *pci_dev;
 
 	pci_dev = to_pci_dev(dev);
+	pci_vpd_release(pci_dev);
 	kfree(pci_dev);
 }
 
@@ -933,6 +934,8 @@ pci_scan_device(struct pci_bus *bus, int devfn)
 		return NULL;
 	}
 
+	pci_vpd_pci22_init(dev);
+
 	return dev;
 }
 

commit 7d715a6c1ae5785d00fb9a876b5abdfc43abc44b
Author: Shaohua Li <shaohua.li@intel.com>
Date:   Mon Feb 25 09:46:41 2008 +0800

    PCI: add PCI Express ASPM support
    
    PCI Express ASPM defines a protocol for PCI Express components in the D0
    state to reduce Link power by placing their Links into a low power state
    and instructing the other end of the Link to do likewise. This
    capability allows hardware-autonomous, dynamic Link power reduction
    beyond what is achievable by software-only controlled power management.
    However, The device should be configured by software appropriately.
    Enabling ASPM will save power, but will introduce device latency.
    
    This patch adds ASPM support in Linux. It introduces a global policy for
    ASPM, a sysfs file /sys/module/pcie_aspm/parameters/policy can control
    it. The interface can be used as a boot option too. Currently we have
    below setting:
            -default, BIOS default setting
            -powersave, highest power saving mode, enable all available ASPM
    state and clock power management
            -performance, highest performance, disable ASPM and clock power
    management
    By default, the 'default' policy is used currently.
    
    In my test, power difference between powersave mode and performance mode
    is about 1.3w in a system with 3 PCIE links.
    
    Note: some devices might not work well with aspm, either because chipset
    issue or device issue. The patch provide API (pci_disable_link_state),
    driver can disable ASPM for specific device.
    
    Signed-off-by: Shaohua Li <shaohua.li@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 07d5c7424b01..284ef392c3ea 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -9,6 +9,7 @@
 #include <linux/slab.h>
 #include <linux/module.h>
 #include <linux/cpumask.h>
+#include <linux/pci-aspm.h>
 #include "pci.h"
 
 #define CARDBUS_LATENCY_TIMER	176	/* secondary latency timer */
@@ -1014,6 +1015,10 @@ int pci_scan_slot(struct pci_bus *bus, int devfn)
 				break;
 		}
 	}
+
+	if (bus->self)
+		pcie_aspm_init_link_state(bus->self);
+
 	return nr;
 }
 

commit cb3576fa34e36907e292f408cb6c258f4fd112ad
Author: Gary Hade <garyhade@us.ibm.com>
Date:   Fri Feb 8 14:00:52 2008 -0800

    PCI: Include PCI domain in PCI bus names on x86/x86_64
    
    The PCI bus names included in /proc/iomem and /proc/ioports are
    of the form 'PCI Bus #XX' where XX is the bus number.  This patch
    changes the naming to 'PCI Bus XXXX:YY' where XXXX is the domain
    number and YY is the bus number.  For example, PCI bus 14 in
    domain 0 will show as 'PCI Bus 0000:14' instead of 'PCI Bus #14'.
    This change makes the naming consistent with other architectures
    such as ia64 where multiple PCI domain support has been around
    longer.
    
    Signed-off-by: Gary Hade <garyhade@us.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 504f19b2af45..07d5c7424b01 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -631,7 +631,9 @@ int __devinit pci_scan_bridge(struct pci_bus *bus, struct pci_dev *dev, int max,
 		pci_write_config_byte(dev, PCI_SUBORDINATE_BUS, max);
 	}
 
-	sprintf(child->name, (is_cardbus ? "PCI CardBus #%02x" : "PCI Bus #%02x"), child->number);
+	sprintf(child->name,
+		(is_cardbus ? "PCI CardBus %04x:%02x" : "PCI Bus %04x:%02x"),
+		pci_domain_nr(bus), child->number);
 
 	/* Has only triggered on CardBus, fixup is in yenta_socket */
 	while (bus->parent) {

commit 5ff580c10ec06fd296bd23d4570c1a95194094a0
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Feb 14 14:56:56 2008 -0800

    PCI: remove global list of PCI devices
    
    This patch finally removes the global list of PCI devices.  We are
    relying entirely on the list held in the driver core now, and do not
    need a separate "shadow" list as no one uses it.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 7217f4283ce8..504f19b2af45 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -20,8 +20,6 @@
 LIST_HEAD(pci_root_buses);
 EXPORT_SYMBOL(pci_root_buses);
 
-LIST_HEAD(pci_devices);
-
 
 static int find_anything(struct device *dev, void *data)
 {
@@ -860,7 +858,6 @@ struct pci_dev *alloc_pci_dev(void)
 	if (!dev)
 		return NULL;
 
-	INIT_LIST_HEAD(&dev->global_list);
 	INIT_LIST_HEAD(&dev->bus_list);
 
 	pci_msi_init_pci_dev(dev);
@@ -957,7 +954,6 @@ void pci_device_add(struct pci_dev *dev, struct pci_bus *bus)
 	 * Add the device to our list of discovered devices
 	 * and the bus list for fixup functions, etc.
 	 */
-	INIT_LIST_HEAD(&dev->global_list);
 	down_write(&pci_bus_sem);
 	list_add_tail(&dev->bus_list, &bus->devices);
 	up_write(&pci_bus_sem);
@@ -1186,7 +1182,7 @@ static void __init pci_insertion_sort_klist(struct pci_dev *a, struct list_head
 	list_move_tail(&a->dev.knode_bus.n_node, list);
 }
 
-static void __init pci_sort_breadthfirst_klist(void)
+void __init pci_sort_breadthfirst(void)
 {
 	LIST_HEAD(sorted_devices);
 	struct list_head *pos, *tmp;
@@ -1207,36 +1203,3 @@ static void __init pci_sort_breadthfirst_klist(void)
 	list_splice(&sorted_devices, &device_klist->k_list);
 	spin_unlock(&device_klist->k_lock);
 }
-
-static void __init pci_insertion_sort_devices(struct pci_dev *a, struct list_head *list)
-{
-	struct pci_dev *b;
-
-	list_for_each_entry(b, list, global_list) {
-		if (pci_sort_bf_cmp(a, b) <= 0) {
-			list_move_tail(&a->global_list, &b->global_list);
-			return;
-		}
-	}
-	list_move_tail(&a->global_list, list);
-}
-
-static void __init pci_sort_breadthfirst_devices(void)
-{
-	LIST_HEAD(sorted_devices);
-	struct pci_dev *dev, *tmp;
-
-	down_write(&pci_bus_sem);
-	list_for_each_entry_safe(dev, tmp, &pci_devices, global_list) {
-		pci_insertion_sort_devices(dev, &sorted_devices);
-	}
-	list_splice(&sorted_devices, &pci_devices);
-	up_write(&pci_bus_sem);
-}
-
-void __init pci_sort_breadthfirst(void)
-{
-	pci_sort_breadthfirst_devices();
-	pci_sort_breadthfirst_klist();
-}
-

commit 8a1bc9013a03d41a0e36ee413bb6f97281b30bd1
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Feb 14 14:56:56 2008 -0800

    PCI: add is_added flag to struct pci_dev
    
    This lets us check if the device is really added to the driver core or
    not, which is what we need when walking some of the bus lists.  The flag
    is there in anticipation of getting rid of the other PCI device list,
    which is what we used to check in this situation.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 387fbbb97431..7217f4283ce8 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -984,7 +984,7 @@ EXPORT_SYMBOL(pci_scan_single_device);
  *
  * Scan a PCI slot on the specified PCI bus for devices, adding
  * discovered devices to the @bus->devices list.  New devices
- * will have an empty dev->global_list head.
+ * will not have is_added set.
  */
 int pci_scan_slot(struct pci_bus *bus, int devfn)
 {

commit 70308923d317f2ad4973c30d90bb48ae38761317
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed Feb 13 22:30:39 2008 -0800

    PCI: make no_pci_devices() use the pci_bus_type list
    
    no_pci_devices() should use the driver core list of PCI devices, not our
    "separate" one.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 2db2e4bb0d1e..387fbbb97431 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -22,16 +22,27 @@ EXPORT_SYMBOL(pci_root_buses);
 
 LIST_HEAD(pci_devices);
 
+
+static int find_anything(struct device *dev, void *data)
+{
+	return 1;
+}
+
 /*
  * Some device drivers need know if pci is initiated.
  * Basically, we think pci is not initiated when there
- * is no device in list of pci_devices.
+ * is no device to be found on the pci_bus_type.
  */
 int no_pci_devices(void)
 {
-	return list_empty(&pci_devices);
-}
+	struct device *dev;
+	int no_devices;
 
+	dev = bus_find_device(&pci_bus_type, NULL, NULL, find_anything);
+	no_devices = (dev == NULL);
+	put_device(dev);
+	return no_devices;
+}
 EXPORT_SYMBOL(no_pci_devices);
 
 #ifdef HAVE_PCI_LEGACY

commit 39106dcf85285e78f3b290022122c76f851379b8
Author: Mike Travis <travis@sgi.com>
Date:   Tue Apr 8 11:43:03 2008 -0700

    cpumask: use new cpus_scnprintf function
    
      * Cleaned up references to cpumask_scnprintf() and added new
        cpulist_scnprintf() interfaces where appropriate.
    
      * Fix some small bugs (or code efficiency improvments) for various uses
        of cpumask_scnprintf.
    
      * Clean up some checkpatch errors.
    
    Signed-off-by: Mike Travis <travis@sgi.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 2db2e4bb0d1e..4b3011a23eff 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -82,6 +82,7 @@ void pci_remove_legacy_files(struct pci_bus *bus) { return; }
  * PCI Bus Class Devices
  */
 static ssize_t pci_bus_show_cpuaffinity(struct device *dev,
+					int type,
 					struct device_attribute *attr,
 					char *buf)
 {
@@ -89,12 +90,30 @@ static ssize_t pci_bus_show_cpuaffinity(struct device *dev,
 	cpumask_t cpumask;
 
 	cpumask = pcibus_to_cpumask(to_pci_bus(dev));
-	ret = cpumask_scnprintf(buf, PAGE_SIZE, cpumask);
-	if (ret < PAGE_SIZE)
-		buf[ret++] = '\n';
+	ret = type?
+		cpulist_scnprintf(buf, PAGE_SIZE-2, cpumask):
+		cpumask_scnprintf(buf, PAGE_SIZE-2, cpumask);
+	buf[ret++] = '\n';
+	buf[ret] = '\0';
 	return ret;
 }
-DEVICE_ATTR(cpuaffinity, S_IRUGO, pci_bus_show_cpuaffinity, NULL);
+
+static ssize_t inline pci_bus_show_cpumaskaffinity(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	return pci_bus_show_cpuaffinity(dev, 0, attr, buf);
+}
+
+static ssize_t inline pci_bus_show_cpulistaffinity(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	return pci_bus_show_cpuaffinity(dev, 1, attr, buf);
+}
+
+DEVICE_ATTR(cpuaffinity,     S_IRUGO, pci_bus_show_cpumaskaffinity, NULL);
+DEVICE_ATTR(cpulistaffinity, S_IRUGO, pci_bus_show_cpulistaffinity, NULL);
 
 /*
  * PCI Bus Class

commit 0ab2b57f8db8a1bcdf24089074f5d2856a3ffb42
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sun Feb 17 10:45:28 2008 +0100

    PCI: fix section mismatch warning in pci_scan_child_bus
    
    Fix following warning:
    WARNING: vmlinux.o(.text+0x47bdb1): Section mismatch in reference from the function pci_scan_child_bus() to the function .devinit.text:pcibios_fixup_bus()
    
    We had plenty of functions that could be annotated __devinit but due to
    the former restriction that exported symbols could not be annotated
    they were not so.  So annotate these function and fix the references
    from the pci/hotplug/* code to silence the resuting warnings.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 4d23b9fb551b..2db2e4bb0d1e 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -286,7 +286,7 @@ static void pci_read_bases(struct pci_dev *dev, unsigned int howmany, int rom)
 	}
 }
 
-void pci_read_bridge_bases(struct pci_bus *child)
+void __devinit pci_read_bridge_bases(struct pci_bus *child)
 {
 	struct pci_dev *dev = child->self;
 	u8 io_base_lo, io_limit_lo;
@@ -472,7 +472,7 @@ static void pci_fixup_parent_subordinate_busnr(struct pci_bus *child, int max)
  * them, we proceed to assigning numbers to the remaining buses in
  * order to avoid overlaps between old and new bus numbers.
  */
-int pci_scan_bridge(struct pci_bus *bus, struct pci_dev * dev, int max, int pass)
+int __devinit pci_scan_bridge(struct pci_bus *bus, struct pci_dev *dev, int max, int pass)
 {
 	struct pci_bus *child;
 	int is_cardbus = (dev->hdr_type == PCI_HEADER_TYPE_CARDBUS);
@@ -1008,7 +1008,7 @@ int pci_scan_slot(struct pci_bus *bus, int devfn)
 	return nr;
 }
 
-unsigned int pci_scan_child_bus(struct pci_bus *bus)
+unsigned int __devinit pci_scan_child_bus(struct pci_bus *bus)
 {
 	unsigned int devfn, pass, max = bus->secondary;
 	struct pci_dev *dev;
@@ -1116,7 +1116,7 @@ struct pci_bus * pci_create_bus(struct device *parent,
 	return NULL;
 }
 
-struct pci_bus *pci_scan_bus_parented(struct device *parent,
+struct pci_bus * __devinit pci_scan_bus_parented(struct device *parent,
 		int bus, struct pci_ops *ops, void *sysdata)
 {
 	struct pci_bus *b;

commit 59fc67dedb46c29442989e52af39da67aea52512
Author: FUJITA Tomonori <tomof@acm.org>
Date:   Mon Feb 4 22:28:14 2008 -0800

    iommu sg merging: PCI: add dma segment boundary support
    
    This adds PCI's accessor for segment_boundary_mask in device_dma_parameters.
    
    The default segment_boundary is set to 0xffffffff, same to the block layer's
    default value (and the scsi mid layer uses the same value).
    
    Signed-off-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Cc: James Bottomley <James.Bottomley@steeleye.com>
    Cc: Jens Axboe <jens.axboe@oracle.com>
    Cc: Greg KH <greg@kroah.com>
    Cc: Jeff Garzik <jeff@garzik.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index f47d596d5ebc..4d23b9fb551b 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -937,6 +937,7 @@ void pci_device_add(struct pci_dev *dev, struct pci_bus *bus)
 	dev->dev.coherent_dma_mask = 0xffffffffull;
 
 	pci_set_dma_max_seg_size(dev, 65536);
+	pci_set_dma_seg_boundary(dev, 0xffffffff);
 
 	/* Fix up broken headers */
 	pci_fixup_device(pci_fixup_header, dev);

commit 4d57cdfacaa1c207bf4c071f89835e0368766a50
Author: FUJITA Tomonori <tomof@acm.org>
Date:   Mon Feb 4 22:27:55 2008 -0800

    iommu sg merging: PCI: add device_dma_parameters support
    
    This adds struct device_dma_parameters in struct pci_dev and properly
    sets up a pointer in struct device.
    
    The default max_segment_size is set to 64K, same to the block layer's
    default value.
    
    Signed-off-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Mostly-acked-by: Jeff Garzik <jeff@garzik.org>
    Cc: James Bottomley <James.Bottomley@steeleye.com>
    Acked-by: Jens Axboe <jens.axboe@oracle.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 7f5dab34d315..f47d596d5ebc 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -933,8 +933,11 @@ void pci_device_add(struct pci_dev *dev, struct pci_bus *bus)
 
 	set_dev_node(&dev->dev, pcibus_to_node(bus));
 	dev->dev.dma_mask = &dev->dma_mask;
+	dev->dev.dma_parms = &dev->dma_parms;
 	dev->dev.coherent_dma_mask = 0xffffffffull;
 
+	pci_set_dma_max_seg_size(dev, 65536);
+
 	/* Fix up broken headers */
 	pci_fixup_device(pci_fixup_header, dev);
 

commit 451124a7cc6c89fcb83d48082c7290f16f652f1c
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sat Feb 2 22:33:43 2008 +0100

    PCI: fix 4x section mismatch warnings
    
    The following warnings were issued during build of
    drivers/pci with an allyesconfig build:
    WARNING: o-x86_64/drivers/pci/built-in.o(.text+0xdaf): Section mismatch in reference from the function pci_add_new_bus() to the function .devinit.text:pci_alloc_child_bus()
    WARNING: o-x86_64/drivers/pci/built-in.o(.text+0x15e2): Section mismatch in reference from the function pci_scan_single_device() to the function .devinit.text:pci_scan_device()
    WARNING: o-x86_64/drivers/pci/built-in.o(.text+0x1b0c5): Section mismatch in reference from the function pci_bus_assign_resources() to the function .devinit.text:pci_setup_bridge()
    WARNING: o-x86_64/drivers/pci/built-in.o(.text+0x1b32d): Section mismatch in reference from the function pci_bus_size_bridges() to the function .devinit.text:pci_bus_size_cardbus()
    
    Investigating each case closer it looked like all
    referred functions are only used in the init phase
    or during hotplug.
    So to avoid wasting too much memory in the non-hotplug
    case the simpler fix was to allow the fuctions to
    use code/data from the __devinit sections.
    This was done in all four case by adding the __ref
    annotation.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Cc: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 3bb2bc2a1e70..7f5dab34d315 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -433,7 +433,7 @@ pci_alloc_child_bus(struct pci_bus *parent, struct pci_dev *bridge, int busnr)
 	return child;
 }
 
-struct pci_bus *pci_add_new_bus(struct pci_bus *parent, struct pci_dev *dev, int busnr)
+struct pci_bus *__ref pci_add_new_bus(struct pci_bus *parent, struct pci_dev *dev, int busnr)
 {
 	struct pci_bus *child;
 
@@ -948,7 +948,7 @@ void pci_device_add(struct pci_dev *dev, struct pci_bus *bus)
 	up_write(&pci_bus_sem);
 }
 
-struct pci_dev *pci_scan_single_device(struct pci_bus *bus, int devfn)
+struct pci_dev *__ref pci_scan_single_device(struct pci_bus *bus, int devfn)
 {
 	struct pci_dev *dev;
 

commit 4105717bc98ba01663ff28f8a16d8716ba9d07fe
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sat Feb 2 22:32:23 2008 +0100

    PCI: fix section mismatch warnings referring to pci_do_scan_bus
    
    Fix following warnings:
    WARNING: o-x86_64/drivers/pci/built-in.o(.text+0xb054): Section mismatch in reference from the function cpci_configure_slot() to the function .devinit.text:pci_do_scan_bus()
    WARNING: o-x86_64/drivers/pci/built-in.o(.text+0x153ab): Section mismatch in reference from the function shpchp_configure_device() to the function .devinit.text:pci_do_scan_bus()
    WARNING: o-x86_64/drivers/pci/built-in.o(__ksymtab+0xc0): Section mismatch in reference from the variable __ksymtab_pci_do_scan_bus to the function .devinit.text:pci_do_scan_bus()
    
    PCI hotplug were the only user of pci_do_scan_bus()
    so moving this function to a separate file that is build
    only when we enable CONFIG_HOTPLUG_PCI.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Cc: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 34fa0397b55d..3bb2bc2a1e70 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1040,20 +1040,6 @@ unsigned int pci_scan_child_bus(struct pci_bus *bus)
 	return max;
 }
 
-unsigned int __devinit pci_do_scan_bus(struct pci_bus *bus)
-{
-	unsigned int max;
-
-	max = pci_scan_child_bus(bus);
-
-	/*
-	 * Make the discovered devices available.
-	 */
-	pci_bus_add_devices(bus);
-
-	return max;
-}
-
 struct pci_bus * pci_create_bus(struct device *parent,
 		int bus, struct pci_ops *ops, void *sysdata)
 {
@@ -1140,7 +1126,6 @@ EXPORT_SYMBOL(pci_scan_bus_parented);
 
 #ifdef CONFIG_HOTPLUG
 EXPORT_SYMBOL(pci_add_new_bus);
-EXPORT_SYMBOL(pci_do_scan_bus);
 EXPORT_SYMBOL(pci_scan_slot);
 EXPORT_SYMBOL(pci_scan_bridge);
 EXPORT_SYMBOL_GPL(pci_scan_child_bus);

commit cc3a1378b4dd45d3e78dd4aeb10641b06a87d614
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Sat Feb 2 11:32:01 2008 -0800

    Revert "PCI: PCIE ASPM support"
    
    This reverts commit 6c723d5bd89f03fc3ef627d50f89ade054d2ee3b.
    
    It caused build errors on non-x86 platforms, config file confusion, and
    even some boot errors on some x86-64 boxes.  All around, not quite ready
    for prime-time :(
    
    Cc: Shaohua Li <shaohua.li@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 8b505bd925aa..34fa0397b55d 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -9,7 +9,6 @@
 #include <linux/slab.h>
 #include <linux/module.h>
 #include <linux/cpumask.h>
-#include <linux/aspm.h>
 #include "pci.h"
 
 #define CARDBUS_LATENCY_TIMER	176	/* secondary latency timer */
@@ -1002,10 +1001,6 @@ int pci_scan_slot(struct pci_bus *bus, int devfn)
 				break;
 		}
 	}
-
-	if (bus->self)
-		pcie_aspm_init_link_state(bus->self);
-
 	return nr;
 }
 

commit fd7d1ced29e5beb88c9068801da7a362606d8273
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue May 22 22:47:54 2007 -0400

    PCI: make pci_bus a struct device
    
    This moves the pci_bus class device to be a real struct device and at
    the same time, place it in the device tree in the correct location.
    
    Note, the old "bridge" symlink is now gone, but this was a non-standard
    link and no userspace program used it.  If you need to determine the
    device that the bus is on, follow the standard device symlink, or walk
    up the device tree.
    
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 9b4673df27e7..8b505bd925aa 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -54,7 +54,7 @@ static void pci_create_legacy_files(struct pci_bus *b)
 		b->legacy_io->attr.mode = S_IRUSR | S_IWUSR;
 		b->legacy_io->read = pci_read_legacy_io;
 		b->legacy_io->write = pci_write_legacy_io;
-		class_device_create_bin_file(&b->class_dev, b->legacy_io);
+		device_create_bin_file(&b->dev, b->legacy_io);
 
 		/* Allocated above after the legacy_io struct */
 		b->legacy_mem = b->legacy_io + 1;
@@ -62,15 +62,15 @@ static void pci_create_legacy_files(struct pci_bus *b)
 		b->legacy_mem->size = 1024*1024;
 		b->legacy_mem->attr.mode = S_IRUSR | S_IWUSR;
 		b->legacy_mem->mmap = pci_mmap_legacy_mem;
-		class_device_create_bin_file(&b->class_dev, b->legacy_mem);
+		device_create_bin_file(&b->dev, b->legacy_mem);
 	}
 }
 
 void pci_remove_legacy_files(struct pci_bus *b)
 {
 	if (b->legacy_io) {
-		class_device_remove_bin_file(&b->class_dev, b->legacy_io);
-		class_device_remove_bin_file(&b->class_dev, b->legacy_mem);
+		device_remove_bin_file(&b->dev, b->legacy_io);
+		device_remove_bin_file(&b->dev, b->legacy_mem);
 		kfree(b->legacy_io); /* both are allocated here */
 	}
 }
@@ -82,26 +82,27 @@ void pci_remove_legacy_files(struct pci_bus *bus) { return; }
 /*
  * PCI Bus Class Devices
  */
-static ssize_t pci_bus_show_cpuaffinity(struct class_device *class_dev,
+static ssize_t pci_bus_show_cpuaffinity(struct device *dev,
+					struct device_attribute *attr,
 					char *buf)
 {
 	int ret;
 	cpumask_t cpumask;
 
-	cpumask = pcibus_to_cpumask(to_pci_bus(class_dev));
+	cpumask = pcibus_to_cpumask(to_pci_bus(dev));
 	ret = cpumask_scnprintf(buf, PAGE_SIZE, cpumask);
 	if (ret < PAGE_SIZE)
 		buf[ret++] = '\n';
 	return ret;
 }
-CLASS_DEVICE_ATTR(cpuaffinity, S_IRUGO, pci_bus_show_cpuaffinity, NULL);
+DEVICE_ATTR(cpuaffinity, S_IRUGO, pci_bus_show_cpuaffinity, NULL);
 
 /*
  * PCI Bus Class
  */
-static void release_pcibus_dev(struct class_device *class_dev)
+static void release_pcibus_dev(struct device *dev)
 {
-	struct pci_bus *pci_bus = to_pci_bus(class_dev);
+	struct pci_bus *pci_bus = to_pci_bus(dev);
 
 	if (pci_bus->bridge)
 		put_device(pci_bus->bridge);
@@ -110,7 +111,7 @@ static void release_pcibus_dev(struct class_device *class_dev)
 
 static struct class pcibus_class = {
 	.name		= "pci_bus",
-	.release	= &release_pcibus_dev,
+	.dev_release	= &release_pcibus_dev,
 };
 
 static int __init pcibus_class_init(void)
@@ -393,7 +394,6 @@ pci_alloc_child_bus(struct pci_bus *parent, struct pci_dev *bridge, int busnr)
 {
 	struct pci_bus *child;
 	int i;
-	int retval;
 
 	/*
 	 * Allocate a new bus, and inherit stuff from the parent..
@@ -409,15 +409,12 @@ pci_alloc_child_bus(struct pci_bus *parent, struct pci_dev *bridge, int busnr)
 	child->bus_flags = parent->bus_flags;
 	child->bridge = get_device(&bridge->dev);
 
-	child->class_dev.class = &pcibus_class;
-	sprintf(child->class_dev.class_id, "%04x:%02x", pci_domain_nr(child), busnr);
-	retval = class_device_register(&child->class_dev);
-	if (retval)
-		goto error_register;
-	retval = class_device_create_file(&child->class_dev,
-					  &class_device_attr_cpuaffinity);
-	if (retval)
-		goto error_file_create;
+	/* initialize some portions of the bus device, but don't register it
+	 * now as the parent is not properly set up yet.  This device will get
+	 * registered later in pci_bus_add_devices()
+	 */
+	child->dev.class = &pcibus_class;
+	sprintf(child->dev.bus_id, "%04x:%02x", pci_domain_nr(child), busnr);
 
 	/*
 	 * Set up the primary, secondary and subordinate
@@ -435,12 +432,6 @@ pci_alloc_child_bus(struct pci_bus *parent, struct pci_dev *bridge, int busnr)
 	bridge->subordinate = child;
 
 	return child;
-
-error_file_create:
-	class_device_unregister(&child->class_dev);
-error_register:
-	kfree(child);
-	return NULL;
 }
 
 struct pci_bus *pci_add_new_bus(struct pci_bus *parent, struct pci_dev *dev, int busnr)
@@ -1107,32 +1098,27 @@ struct pci_bus * pci_create_bus(struct device *parent,
 		goto dev_reg_err;
 	b->bridge = get_device(dev);
 
-	b->class_dev.class = &pcibus_class;
-	sprintf(b->class_dev.class_id, "%04x:%02x", pci_domain_nr(b), bus);
-	error = class_device_register(&b->class_dev);
+	b->dev.class = &pcibus_class;
+	b->dev.parent = b->bridge;
+	sprintf(b->dev.bus_id, "%04x:%02x", pci_domain_nr(b), bus);
+	error = device_register(&b->dev);
 	if (error)
 		goto class_dev_reg_err;
-	error = class_device_create_file(&b->class_dev, &class_device_attr_cpuaffinity);
+	error = device_create_file(&b->dev, &dev_attr_cpuaffinity);
 	if (error)
-		goto class_dev_create_file_err;
+		goto dev_create_file_err;
 
 	/* Create legacy_io and legacy_mem files for this bus */
 	pci_create_legacy_files(b);
 
-	error = sysfs_create_link(&b->class_dev.kobj, &b->bridge->kobj, "bridge");
-	if (error)
-		goto sys_create_link_err;
-
 	b->number = b->secondary = bus;
 	b->resource[0] = &ioport_resource;
 	b->resource[1] = &iomem_resource;
 
 	return b;
 
-sys_create_link_err:
-	class_device_remove_file(&b->class_dev, &class_device_attr_cpuaffinity);
-class_dev_create_file_err:
-	class_device_unregister(&b->class_dev);
+dev_create_file_err:
+	device_unregister(&b->dev);
 class_dev_reg_err:
 	device_unregister(dev);
 dev_reg_err:

commit 6c723d5bd89f03fc3ef627d50f89ade054d2ee3b
Author: Shaohua Li <shaohua.li@intel.com>
Date:   Thu Jan 24 10:21:57 2008 +0800

    PCI: PCIE ASPM support
    
    PCI Express ASPM defines a protocol for PCI Express components in the D0
    state to reduce Link power by placing their Links into a low power state
    and instructing the other end of the Link to do likewise. This
    capability allows hardware-autonomous, dynamic Link power reduction
    beyond what is achievable by software-only controlled power management.
    However, The device should be configured by software appropriately.
    Enabling ASPM will save power, but will introduce device latency.
    
    This patch adds ASPM support in Linux. It introduces a global policy for
    ASPM, a sysfs file /sys/module/pcie_aspm/parameters/policy can control
    it. The interface can be used as a boot option too. Currently we have
    below setting:
            -default, BIOS default setting
            -powersave, highest power saving mode, enable all available ASPM
    state
    and clock power management
            -performance, highest performance, disable ASPM and clock power
    management
    By default, the 'default' policy is used currently.
    
    In my test, power difference between powersave mode and performance mode
    is about 1.3w in a system with 3 PCIE links.
    
    Signed-off-by: Shaohua Li <shaohua.li@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 4262dfec5676..9b4673df27e7 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -9,6 +9,7 @@
 #include <linux/slab.h>
 #include <linux/module.h>
 #include <linux/cpumask.h>
+#include <linux/aspm.h>
 #include "pci.h"
 
 #define CARDBUS_LATENCY_TIMER	176	/* secondary latency timer */
@@ -1010,6 +1011,10 @@ int pci_scan_slot(struct pci_bus *bus, int devfn)
 				break;
 		}
 	}
+
+	if (bus->self)
+		pcie_aspm_init_link_state(bus->self);
+
 	return nr;
 }
 

commit a6f29a98af278a8d784a870ae9f08e530de73ffe
Author: Joe Perches <joe@perches.com>
Date:   Mon Nov 19 17:48:29 2007 -0800

    PCI: Add missing "space" in printk messages
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Cc: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 93c7f35db5d0..4262dfec5676 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -639,13 +639,13 @@ int pci_scan_bridge(struct pci_bus *bus, struct pci_dev * dev, int max, int pass
 		    (child->number > bus->subordinate) ||
 		    (child->number < bus->number) ||
 		    (child->subordinate < bus->number)) {
-			pr_debug("PCI: Bus #%02x (-#%02x) is %s"
+			pr_debug("PCI: Bus #%02x (-#%02x) is %s "
 				"hidden behind%s bridge #%02x (-#%02x)\n",
 				child->number, child->subordinate,
 				(bus->number > child->subordinate &&
 				 bus->subordinate < child->number) ?
-					"wholly " : " partially",
-				bus->self->transparent ? " transparent" : " ",
+					"wholly" : "partially",
+				bus->self->transparent ? " transparent" : "",
 				bus->number, bus->subordinate);
 		}
 		bus = bus->parent;

commit 943e6c0d5cb88453210747d9042d4a8f92ee2974
Author: Adrian Bunk <bunk@kernel.org>
Date:   Wed Nov 21 15:07:12 2007 -0800

    PCI: remove additional pci_scan_child_bus() prototype
    
    There's already a prototype for pci_scan_child_bus() at the correct place in
    pci.h, so there's no reason for an additional one.
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index d8e32e111632..93c7f35db5d0 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -471,8 +471,6 @@ static void pci_fixup_parent_subordinate_busnr(struct pci_bus *child, int max)
 	}
 }
 
-unsigned int pci_scan_child_bus(struct pci_bus *bus);
-
 /*
  * If it's a bridge, configure it and scan the bus behind it.
  * For CardBus bridges, we don't scan behind as the devices will

commit b73e96878d5d57605aeea89068c8dacd568f5e7e
Author: Adrian Bunk <bunk@kernel.org>
Date:   Wed Nov 21 15:07:11 2007 -0800

    PCI: always export pci_scan_single_device
    
    This patch fixes the following build error with CONFIG_HOTPLUG=n:
    
      MODPOST 2137 modules
    ERROR: "pci_scan_single_device" [drivers/edac/i82875p_edac.ko] undefined!
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Acked-by: Doug Thompson <norsk5@yahoo.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index ceaeac1bd655..d8e32e111632 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -971,6 +971,7 @@ struct pci_dev *pci_scan_single_device(struct pci_bus *bus, int devfn)
 
 	return dev;
 }
+EXPORT_SYMBOL(pci_scan_single_device);
 
 /**
  * pci_scan_slot - scan a PCI slot on a bus for devices.
@@ -1158,7 +1159,6 @@ EXPORT_SYMBOL(pci_add_new_bus);
 EXPORT_SYMBOL(pci_do_scan_bus);
 EXPORT_SYMBOL(pci_scan_slot);
 EXPORT_SYMBOL(pci_scan_bridge);
-EXPORT_SYMBOL(pci_scan_single_device);
 EXPORT_SYMBOL_GPL(pci_scan_child_bus);
 #endif
 

commit eb003ec26556057e5f27d4b989bbb432d0bdc0f4
Author: Adrian Bunk <bunk@kernel.org>
Date:   Sat Oct 27 03:06:33 2007 +0200

    PCI: drivers/pci/: remove unused exports
    
    This patch removes the following unused exports:
    - remove the following unused EXPORT_SYMBOL's:
     - pci-acpi.c: pci_osc_support_set
     - proc.c: pci_proc_detach_bus
    - remove the following unused EXPORT_SYMBOL_GPL's:
      - bus.c: pci_walk_bus
      - probe.c: pci_create_bus
      - setup-res.c: pci_claim_resource
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 5fd585293e79..ceaeac1bd655 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1140,7 +1140,6 @@ struct pci_bus * pci_create_bus(struct device *parent,
 	kfree(b);
 	return NULL;
 }
-EXPORT_SYMBOL_GPL(pci_create_bus);
 
 struct pci_bus *pci_scan_bus_parented(struct device *parent,
 		int bus, struct pci_ops *ops, void *sysdata)

commit b249072ee6897fe4f8d461c7bb4b926223263c28
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Nov 1 19:41:16 2007 -0700

    driver core: add way to get to bus device klist
    
    This allows an easier way to get to the device klist associated with a
    struct bus_type (you have three to choose from...)  This will make it
    easier to move these fields to be dynamic in a future patch.
    
    The only user of this is the PCI core which horribly abuses this
    interface to rearrange the order of the pci devices.  This should be
    done using the existing bus device walking functions, but that's left
    for future patches.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index c5ca3134513a..5fd585293e79 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1210,16 +1210,19 @@ static void __init pci_sort_breadthfirst_klist(void)
 	struct klist_node *n;
 	struct device *dev;
 	struct pci_dev *pdev;
+	struct klist *device_klist;
 
-	spin_lock(&pci_bus_type.klist_devices.k_lock);
-	list_for_each_safe(pos, tmp, &pci_bus_type.klist_devices.k_list) {
+	device_klist = bus_get_device_klist(&pci_bus_type);
+
+	spin_lock(&device_klist->k_lock);
+	list_for_each_safe(pos, tmp, &device_klist->k_list) {
 		n = container_of(pos, struct klist_node, n_node);
 		dev = container_of(n, struct device, knode_bus);
 		pdev = to_pci_dev(dev);
 		pci_insertion_sort_klist(pdev, &sorted_devices);
 	}
-	list_splice(&sorted_devices, &pci_bus_type.klist_devices.k_list);
-	spin_unlock(&pci_bus_type.klist_devices.k_lock);
+	list_splice(&sorted_devices, &device_klist->k_list);
+	spin_unlock(&device_klist->k_lock);
 }
 
 static void __init pci_insertion_sort_devices(struct pci_dev *a, struct list_head *list)

commit ad7edfe0490877864dc0312e5f3315ea37fc4b3a
Author: Linus Torvalds <torvalds@woody.linux-foundation.org>
Date:   Thu Dec 27 21:21:36 2007 -0800

    [PCI] Do not enable CRS Software Visibility by default
    
    It appears that some PCI-E bridges do the wrong thing in the presense of
    CRS Software Visibility and MMCONFIG.  In particular, it looks like an
    ATI bridge (device ID 7936) will return 0001 in the vendor ID field of
    any bridged devices indefinitely.
    
    Not enabling CRS SV avoids the problem, and as we currently do not
    really make good use of the feature anyway (we just time out rather than
    do any threaded discovery as suggested by the CRS specs), we're better
    off just not enabling it.
    
    This should fix a slew of problem reports with random devices (generally
    graphics adapters or fairly high-performance networking cards, since it
    only affected PCI-E) not getting properly recognized on these AMD systems.
    
    If we really want to use CRS-SV, we may end up eventually needing a
    whitelist of systems where this should be enabled, along with some kind
    of "pcibios_enable_crs()" query to call the system-specific code.
    
    Suggested-by: Loic Prylli <loic@myri.com>
    Tested-by: Kai Ruhnau <kai@tragetaschen.dyndns.org>
    Cc: Matthew Wilcox <matthew@wil.cx>
    Cc: Greg Kroah-Hartman <greg@kroah.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 2f75d695eed7..c5ca3134513a 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -455,22 +455,6 @@ struct pci_bus *pci_add_new_bus(struct pci_bus *parent, struct pci_dev *dev, int
 	return child;
 }
 
-static void pci_enable_crs(struct pci_dev *dev)
-{
-	u16 cap, rpctl;
-	int rpcap = pci_find_capability(dev, PCI_CAP_ID_EXP);
-	if (!rpcap)
-		return;
-
-	pci_read_config_word(dev, rpcap + PCI_CAP_FLAGS, &cap);
-	if (((cap & PCI_EXP_FLAGS_TYPE) >> 4) != PCI_EXP_TYPE_ROOT_PORT)
-		return;
-
-	pci_read_config_word(dev, rpcap + PCI_EXP_RTCTL, &rpctl);
-	rpctl |= PCI_EXP_RTCTL_CRSSVE;
-	pci_write_config_word(dev, rpcap + PCI_EXP_RTCTL, rpctl);
-}
-
 static void pci_fixup_parent_subordinate_busnr(struct pci_bus *child, int max)
 {
 	struct pci_bus *parent = child->parent;
@@ -517,8 +501,6 @@ int pci_scan_bridge(struct pci_bus *bus, struct pci_dev * dev, int max, int pass
 	pci_write_config_word(dev, PCI_BRIDGE_CONTROL,
 			      bctl & ~PCI_BRIDGE_CTL_MASTER_ABORT);
 
-	pci_enable_crs(dev);
-
 	if ((buses & 0xffff00) && !pcibios_assign_all_busses() && !is_cardbus) {
 		unsigned int cmax, busnr;
 		/*

commit bb44609361fe87c5e136c2b8dfde59bcbdbabf61
Author: Gary Hade <garyhade@us.ibm.com>
Date:   Tue Dec 11 17:09:13 2007 -0800

    PCI: Restore PCI expansion ROM P2P prefetch window creation
    
    Restore PCI expansion ROM P2P prefetch window creation.
    
    This patch reverts previous "Avoid creating P2P prefetch
    window for expansion ROMs" change due to regressions that
    were spotted on some systems.
    
    Signed-off-by: Gary Hade <garyhade@us.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index c2f8a78c894c..2f75d695eed7 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -276,7 +276,8 @@ static void pci_read_bases(struct pci_dev *dev, unsigned int howmany, int rom)
 			sz = pci_size(l, sz, (u32)PCI_ROM_ADDRESS_MASK);
 			if (sz) {
 				res->flags = (l & IORESOURCE_ROM_ENABLE) |
-				  IORESOURCE_MEM | IORESOURCE_READONLY;
+				  IORESOURCE_MEM | IORESOURCE_PREFETCH |
+				  IORESOURCE_READONLY | IORESOURCE_CACHEABLE;
 				res->start = l & PCI_ROM_ADDRESS_MASK;
 				res->end = res->start + (unsigned long) sz;
 			}

commit af1bff4f1d117f99ad8a88e6532baff475fb44a5
Author: Linus Torvalds <torvalds@woody.linux-foundation.org>
Date:   Mon Dec 10 07:40:54 2007 -0800

    Revert "PCI: fix IDE legacy mode resources"
    
    This reverts commit fd6e732186ab522c812ab19c2c5e5befb8ec8115, which
    helped up things on MIPS, but was wrong for everything else.  As Ralf
    Baechle puts it:
    
      "It seems the whole MIPS resource managment is complicated enough (out
       of necessity) that only a few people actually grok it.  Ioports being
       actually memory mapped on MIPS only makes the confusion worse, sigh."
    
    Requested-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Acked-by: Alan Cox <alan@redhat.com>
    Acked-by: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 463a5a9d583d..c2f8a78c894c 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -743,46 +743,22 @@ static int pci_setup_device(struct pci_dev * dev)
 		 */
 		if (class == PCI_CLASS_STORAGE_IDE) {
 			u8 progif;
-			struct pci_bus_region region;
-
 			pci_read_config_byte(dev, PCI_CLASS_PROG, &progif);
 			if ((progif & 1) == 0) {
-				struct resource resource = {
-					.start = 0x1F0,
-					.end = 0x1F7,
-					.flags = LEGACY_IO_RESOURCE,
-				};
-
-				pcibios_resource_to_bus(dev, &region, &resource);
-				dev->resource[0].start = region.start;
-				dev->resource[0].end = region.end;
-				dev->resource[0].flags = resource.flags;
-				resource.start = 0x3F6;
-				resource.end = 0x3F6;
-				resource.flags = LEGACY_IO_RESOURCE;
-				pcibios_resource_to_bus(dev, &region, &resource);
-				dev->resource[1].start = region.start;
-				dev->resource[1].end = region.end;
-				dev->resource[1].flags = resource.flags;
+				dev->resource[0].start = 0x1F0;
+				dev->resource[0].end = 0x1F7;
+				dev->resource[0].flags = LEGACY_IO_RESOURCE;
+				dev->resource[1].start = 0x3F6;
+				dev->resource[1].end = 0x3F6;
+				dev->resource[1].flags = LEGACY_IO_RESOURCE;
 			}
 			if ((progif & 4) == 0) {
-				struct resource resource = {
-					.start = 0x170,
-					.end = 0x177,
-					.flags = LEGACY_IO_RESOURCE,
-				};
-
-				pcibios_resource_to_bus(dev, &region, &resource);
-				dev->resource[2].start = region.start;
-				dev->resource[2].end = region.end;
-				dev->resource[2].flags = resource.flags;
-				resource.start = 0x376;
-				resource.end = 0x376;
-				resource.flags = LEGACY_IO_RESOURCE;
-				pcibios_resource_to_bus(dev, &region, &resource);
-				dev->resource[3].start = region.start;
-				dev->resource[3].end = region.end;
-				dev->resource[3].flags = resource.flags;
+				dev->resource[2].start = 0x170;
+				dev->resource[2].end = 0x177;
+				dev->resource[2].flags = LEGACY_IO_RESOURCE;
+				dev->resource[3].start = 0x376;
+				dev->resource[3].end = 0x376;
+				dev->resource[3].flags = LEGACY_IO_RESOURCE;
 			}
 		}
 		break;

commit 994a65e25df85abc465cfee495557200e8205f9e
Author: Keshavamurthy, Anil S <anil.s.keshavamurthy@intel.com>
Date:   Sun Oct 21 16:41:46 2007 -0700

    Intel IOMMU: PCI generic helper function
    
    When devices are under a p2p bridge, upstream transactions get replaced by the
    device id of the bridge as it owns the PCIE transaction.  Hence its necessary
    to setup translations on behalf of the bridge as well.  Due to this limitation
    all devices under a p2p share the same domain in a DMAR.
    
    We just cache the type of device, if its a native PCIe device
    or not for later use.
    
    [akpm@linux-foundation.org: BUG_ON -> WARN_ON+recover]
    Signed-off-by: Anil S Keshavamurthy <anil.s.keshavamurthy@intel.com>
    Cc: Andi Kleen <ak@suse.de>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Muli Ben-Yehuda <muli@il.ibm.com>
    Cc: "Siddha, Suresh B" <suresh.b.siddha@intel.com>
    Cc: Arjan van de Ven <arjan@infradead.org>
    Cc: Ashok Raj <ashok.raj@intel.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Christoph Lameter <clameter@sgi.com>
    Cc: Greg KH <greg@kroah.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 5db6b6690b59..463a5a9d583d 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -837,6 +837,19 @@ static void pci_release_dev(struct device *dev)
 	kfree(pci_dev);
 }
 
+static void set_pcie_port_type(struct pci_dev *pdev)
+{
+	int pos;
+	u16 reg16;
+
+	pos = pci_find_capability(pdev, PCI_CAP_ID_EXP);
+	if (!pos)
+		return;
+	pdev->is_pcie = 1;
+	pci_read_config_word(pdev, pos + PCI_EXP_FLAGS, &reg16);
+	pdev->pcie_type = (reg16 & PCI_EXP_FLAGS_TYPE) >> 4;
+}
+
 /**
  * pci_cfg_space_size - get the configuration space size of the PCI device.
  * @dev: PCI device
@@ -951,6 +964,7 @@ pci_scan_device(struct pci_bus *bus, int devfn)
 	dev->device = (l >> 16) & 0xffff;
 	dev->cfg_size = pci_cfg_space_size(dev);
 	dev->error_state = pci_channel_io_normal;
+	set_pcie_port_type(dev);
 
 	/* Assume 32-bit PCI; let 64-bit PCI cards (which are far rarer)
 	   set this higher, assuming the system even supports it.  */

commit 11949255d9433ea6c0908b7390ec4faecd1d4cf0
Author: Gary Hade <garyhade@us.ibm.com>
Date:   Mon Oct 8 16:24:16 2007 -0700

    PCI: modify PCI bridge control ISA flag for clarity
    
    Modify PCI Bridge Control ISA flag for clarity
    
    This patch changes PCI_BRIDGE_CTL_NO_ISA to PCI_BRIDGE_CTL_ISA
    and modifies it's clarifying comment and locations where used.
    The change reduces the chance of future confusion since it makes
    the set/unset meaning of the bit the same in both the bridge
    control register and bridge_ctl field of the pci_bus struct.
    
    Signed-off-by: Gary Hade <garyhade@us.ibm.com>
    Acked-by: Linas Vepstas <linas@austin.ibm.com>
    Cc: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 3112024bdc2a..5db6b6690b59 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -543,7 +543,7 @@ int pci_scan_bridge(struct pci_bus *bus, struct pci_dev * dev, int max, int pass
 			goto out;
 		child->primary = buses & 0xFF;
 		child->subordinate = (buses >> 16) & 0xFF;
-		child->bridge_ctl = bctl ^ PCI_BRIDGE_CTL_NO_ISA;
+		child->bridge_ctl = bctl;
 
 		cmax = pci_scan_child_bus(child);
 		if (cmax > max)
@@ -596,7 +596,7 @@ int pci_scan_bridge(struct pci_bus *bus, struct pci_dev * dev, int max, int pass
 		pci_write_config_dword(dev, PCI_PRIMARY_BUS, buses);
 
 		if (!is_cardbus) {
-			child->bridge_ctl = bctl ^ PCI_BRIDGE_CTL_NO_ISA;
+			child->bridge_ctl = bctl;
 			/*
 			 * Adjust subordinate busnr in parent buses.
 			 * We do this before scanning for children because

commit fd64cb4606cbdd592b7119e82341d4ae5b56f2cc
Author: Gary Hade <garyhade@us.ibm.com>
Date:   Wed Oct 3 15:56:30 2007 -0700

    PCI: avoid P2P prefetch window for expansion ROMs
    
    Avoid creating P2P prefetch window for expansion ROMs
    
    Because of the future possibility that P2P prefetch windows will contain
    address ranges above 4GB some BIOSes are providing space in the P2P
    non-prefetch windows for expansion ROMs.  This is due to expansion ROM
    BAR 32-bit limitation.  When expansion ROM BARs without BIOS assigned
    address(es) are currently found behind a P2P bridge, the kernel attempts
    to create a P2P prefetch window for them even though space for them has
    already been provided in the non-prefetch window.  _CRS on some systems
    with certain resource conservation conscious BIOSes may not provide the
    extra 1MB or more memory resource needed for the expansion ROM motivated
    prefetch window causing resource allocation errors.
    
    This change corrects the problem by removing IORESOURCE_PREFETCH from
    the expansion ROM flags initialization.  It also removes
    IORESOURCE_CACHEABLE which seems inappropriate if only non-cacheable
    memory is available.
    
    Signed-off-by: Gary Hade <gary.hade@us.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 59d6c3092812..3112024bdc2a 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -276,8 +276,7 @@ static void pci_read_bases(struct pci_dev *dev, unsigned int howmany, int rom)
 			sz = pci_size(l, sz, (u32)PCI_ROM_ADDRESS_MASK);
 			if (sz) {
 				res->flags = (l & IORESOURCE_ROM_ENABLE) |
-				  IORESOURCE_MEM | IORESOURCE_PREFETCH |
-				  IORESOURCE_READONLY | IORESOURCE_CACHEABLE;
+				  IORESOURCE_MEM | IORESOURCE_READONLY;
 				res->start = l & PCI_ROM_ADDRESS_MASK;
 				res->end = res->start + (unsigned long) sz;
 			}

commit 036fff4cf732c4d69f99a2915924935705744b00
Author: Gary Hade <garyhade@us.ibm.com>
Date:   Wed Oct 3 15:56:14 2007 -0700

    PCI: skip ISA ioresource alignment on some systems
    
    Skip ISA ioresource alignment on some systems
    
    To conserve limited PCI i/o resource on some IBM multi-node systems, the
    BIOS allocates (via _CRS) and expects the kernel to use addresses in
    ranges currently excluded by pcibios_align_resource() [i386/pci/i386.c].
    This change allows the kernel to use the currently excluded address
    ranges on the IBM x3800, x3850, and x3950.
    
    Signed-off-by: Gary Hade <gary.hade@us.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 40e571d3c392..59d6c3092812 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -544,7 +544,7 @@ int pci_scan_bridge(struct pci_bus *bus, struct pci_dev * dev, int max, int pass
 			goto out;
 		child->primary = buses & 0xFF;
 		child->subordinate = (buses >> 16) & 0xFF;
-		child->bridge_ctl = bctl;
+		child->bridge_ctl = bctl ^ PCI_BRIDGE_CTL_NO_ISA;
 
 		cmax = pci_scan_child_bus(child);
 		if (cmax > max)
@@ -597,7 +597,7 @@ int pci_scan_bridge(struct pci_bus *bus, struct pci_dev * dev, int max, int pass
 		pci_write_config_dword(dev, PCI_PRIMARY_BUS, buses);
 
 		if (!is_cardbus) {
-			child->bridge_ctl = bctl | PCI_BRIDGE_CTL_NO_ISA;
+			child->bridge_ctl = bctl ^ PCI_BRIDGE_CTL_NO_ISA;
 			/*
 			 * Adjust subordinate busnr in parent buses.
 			 * We do this before scanning for children because

commit fd6e732186ab522c812ab19c2c5e5befb8ec8115
Author: Yoichi Yuasa <yoichi_yuasa@tripeaks.co.jp>
Date:   Tue Oct 2 14:19:23 2007 -0700

    PCI: fix IDE legacy mode resources
    
    I got the following error on MIPS Cobalt.
    
    PCI: Unable to reserve I/O region #1:8@f00001f0 for device 0000:00:09.1
    pata_via 0000:00:09.1: failed to request/iomap BARs for port 0 (errno=-16)
    PCI: Unable to reserve I/O region #3:8@f0000170 for device 0000:00:09.1
    pata_via 0000:00:09.1: failed to request/iomap BARs for port 1 (errno=-16)
    pata_via 0000:00:09.1: no available native port
    
    The legacy mode IDE resources set the following order.
    
    pci_setup_device()
        Legacy mode ATA controllers have fixed addresses.
        IDE resources: 0x1F0-0x1F7, 0x3F6, 0x170-0x177, 0x376
        |
        V
    pcibios_fixup_bus()
        MIPS Cobalt PCI bus regions have the -0x10000000 offset from PCI resources.
        pcibios_fixup_bus() fix PCI bus regions.
        0x1F0 - 0x10000000 = 0xF00001F0
        |
        V
    ata_pci_init_one()
        PCI: Unable to reserve I/O region #1:8@f00001f0 for device 0000:00:09.1
    
    In some architectures, PCI bus regions have the offset from PCI resources.
    For this reason, pci_setup_device() should set PCI bus regions to
    dev->resource[].
    
    [akpm@linux-foundation.org: use struct initialiser]
    Signed-off-by: Yoichi Yuasa <yoichi_yuasa@tripeaks.co.jp>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Cc: Greg KH <greg@kroah.com>
    Cc: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 171ca712e523..40e571d3c392 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -744,22 +744,46 @@ static int pci_setup_device(struct pci_dev * dev)
 		 */
 		if (class == PCI_CLASS_STORAGE_IDE) {
 			u8 progif;
+			struct pci_bus_region region;
+
 			pci_read_config_byte(dev, PCI_CLASS_PROG, &progif);
 			if ((progif & 1) == 0) {
-				dev->resource[0].start = 0x1F0;
-				dev->resource[0].end = 0x1F7;
-				dev->resource[0].flags = LEGACY_IO_RESOURCE;
-				dev->resource[1].start = 0x3F6;
-				dev->resource[1].end = 0x3F6;
-				dev->resource[1].flags = LEGACY_IO_RESOURCE;
+				struct resource resource = {
+					.start = 0x1F0,
+					.end = 0x1F7,
+					.flags = LEGACY_IO_RESOURCE,
+				};
+
+				pcibios_resource_to_bus(dev, &region, &resource);
+				dev->resource[0].start = region.start;
+				dev->resource[0].end = region.end;
+				dev->resource[0].flags = resource.flags;
+				resource.start = 0x3F6;
+				resource.end = 0x3F6;
+				resource.flags = LEGACY_IO_RESOURCE;
+				pcibios_resource_to_bus(dev, &region, &resource);
+				dev->resource[1].start = region.start;
+				dev->resource[1].end = region.end;
+				dev->resource[1].flags = resource.flags;
 			}
 			if ((progif & 4) == 0) {
-				dev->resource[2].start = 0x170;
-				dev->resource[2].end = 0x177;
-				dev->resource[2].flags = LEGACY_IO_RESOURCE;
-				dev->resource[3].start = 0x376;
-				dev->resource[3].end = 0x376;
-				dev->resource[3].flags = LEGACY_IO_RESOURCE;
+				struct resource resource = {
+					.start = 0x170,
+					.end = 0x177,
+					.flags = LEGACY_IO_RESOURCE,
+				};
+
+				pcibios_resource_to_bus(dev, &region, &resource);
+				dev->resource[2].start = region.start;
+				dev->resource[2].end = region.end;
+				dev->resource[2].flags = resource.flags;
+				resource.start = 0x376;
+				resource.end = 0x376;
+				resource.flags = LEGACY_IO_RESOURCE;
+				pcibios_resource_to_bus(dev, &region, &resource);
+				dev->resource[3].start = region.start;
+				dev->resource[3].end = region.end;
+				dev->resource[3].flags = resource.flags;
 			}
 		}
 		break;

commit e365c3e75ef00a78bd38757a9da12e84039c2828
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Thu Aug 23 18:49:17 2007 +0100

    PCI: remove devinit from pci_read_bridge_bases
    
    On MIPS with PCI && !HOTPLUG, I'm currently getting the following modpost
    warning:
    
      MODPOST vmlinux.o
    WARNING: vmlinux.o(.text+0x1ce128): Section mismatch: reference to .init.text:pci_read_bridge_bases (between 'pcibios_fixup_bus' and 'pcibios_enable_device')
    
    On MIPS I have the call chains pci_scan_child_bus -> pcibios_fixup_bus ->
    pci_read_bridge_bases.  pci_scan_child_bus can't be __devinit because it
    it is an exported symbol, thus pcibios_fixup_bus and pci_read_bridge_bases
    can't be either.
    
    For some reason I don't see this issue on x86; I blame compiler differences.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 27e00b2d7b5b..171ca712e523 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -285,7 +285,7 @@ static void pci_read_bases(struct pci_dev *dev, unsigned int howmany, int rom)
 	}
 }
 
-void __devinit pci_read_bridge_bases(struct pci_bus *child)
+void pci_read_bridge_bases(struct pci_bus *child)
 {
 	struct pci_dev *dev = child->self;
 	u8 io_base_lo, io_limit_lo;

commit d55bef515a01c85aa65c03c285ea8d285fcbab3b
Author: Bernhard Kaindl <bk@suse.de>
Date:   Mon Jul 30 20:35:13 2007 +0200

    PCI: lets kill the 'PCI hidden behind bridge' message
    
    Adrian Bunk wrote:
    > Alois Nešpor wrote
    >> PCI: Bus #0b (-#0e) is hidden behind transparent bridge #0a (-#0b) (try 'pci=assign-busses')
    >> Please report the result to linux-kernel to fix this permanently"
    >>
    >> dmesg:
    >> "Yenta: Raising subordinate bus# of parent bus (#0a) from #0b to #0e"
    >> without pci=assign-busses and nothing with pci=assign-busses.
    >
    > Bernhard?
    
    Ok, lets kill the message. As Alois Nešpor also saw, that's fixed up by Yenta,
    so PCI does not have to warn about it. PCI could still warn about it if
    is_cardbus is 0 in that instance of pci_scan_bridge(), but so far I have
    not seen a report where this would have been the case so I think we can
    spare the kernel of that check (removes ~300 lines of asm) unless debugging
    is done.
    
    History: The whole check was added in the days before we had the fixup
    for this in Yenta and pci=assign-busses was the only way to get CardBus
    cards detected on many (not all) of the machines which give this warning.
    
    In theory, there could be cases when this warning would be triggered and
    it's not cardbus, then the warning should still apply, but I think this
    should only be the case when working on a completely broken PCI setup,
    but one may have already enabled the debug code in drivers/pci and the
    patched check would then trigger.
    
    I do not sign this off yet because it's completely untested so far, but
    everyone is free to test it (with the #ifdef DEBUG replaced by #if 1 and
    pr_debug( changed to printk(.
    
    We may also dump the whole check (remove everything within the #ifdef from
    the source) if that's perferred.
    
    On Alois Nešpor's machine this would then (only when debugging) this message:
    
    "PCI: Bus #0b (-#0e) is partially hidden behind transparent bridge #0a (-#0b)"
    
    "partially" should be in the message on his machine because #0b of #0b-#0e
    is reachable behind #0a-#0b, but not #0c-#0e.
    
    But that differentiation is now moot anyway because the fixup in Yenta takes
    care of it as far as I could see so far, which means that unless somebody
    is debugging a totally broken PCI setup, this message is not needed anymore,
    not even for debugging PCI.
    
    
    Ok, here the patch with the following changes:
    
    * Refined to say that the bus is only partially hidden when the parent
      bus numbers are not totally way off (outside of) the child bus range
    * remove the reference to pci=assign-busses and the plea to report it
    
    We could add a pure source code-only comment to keep a reference to
    pci=assign-busses the in case when this is triggered by someone who
    is debugging the cause of this message and looking the way to solve it.
    
    From: Bernhard Kaindl <bk@suse.de>
    Cc: stable <stable@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 34b8dae0d90f..27e00b2d7b5b 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -653,20 +653,20 @@ int pci_scan_bridge(struct pci_bus *bus, struct pci_dev * dev, int max, int pass
 
 	sprintf(child->name, (is_cardbus ? "PCI CardBus #%02x" : "PCI Bus #%02x"), child->number);
 
+	/* Has only triggered on CardBus, fixup is in yenta_socket */
 	while (bus->parent) {
 		if ((child->subordinate > bus->subordinate) ||
 		    (child->number > bus->subordinate) ||
 		    (child->number < bus->number) ||
 		    (child->subordinate < bus->number)) {
-			printk(KERN_WARNING "PCI: Bus #%02x (-#%02x) is "
-			       "hidden behind%s bridge #%02x (-#%02x)%s\n",
-			       child->number, child->subordinate,
-			       bus->self->transparent ? " transparent" : " ",
-			       bus->number, bus->subordinate,
-			       pcibios_assign_all_busses() ? " " :
-			       " (try 'pci=assign-busses')");
-			printk(KERN_WARNING "Please report the result to "
-			       "<bk@suse.de> to fix this permanently\n");
+			pr_debug("PCI: Bus #%02x (-#%02x) is %s"
+				"hidden behind%s bridge #%02x (-#%02x)\n",
+				child->number, child->subordinate,
+				(bus->number > child->subordinate &&
+				 bus->subordinate < child->number) ?
+					"wholly " : " partially",
+				bus->self->transparent ? " transparent" : " ",
+				bus->number, bus->subordinate);
 		}
 		bus = bus->parent;
 	}

commit ed4aaadb1a7913f509f05d3e67840541a180713f
Author: Zhang, Yanmin <yanmin_zhang@linux.intel.com>
Date:   Sun Jul 15 23:39:39 2007 -0700

    fix jvc cdrom drive lockup
    
    Before calling init_hwif_default, ide_unregister gets lock ide_lock and
    disables irq.  init_hwif_default calls ide_default_io_base which calls
    pci_get_device and later pci_get_subsys tries to apply for semaphore
    pci_bus_sem and goes to sleep.
    
    Mostly, pci_get_device should be called when irq is turned on.
    
    ide_default_io_base just needs find if list pci_devices is empty.
    
    Signed-off-by: Zhang Yanmin <yanmin.zhang@intel.com>
    Cc: Greg KH <greg@kroah.com>
    Cc: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index a7bce75c6732..34b8dae0d90f 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -22,6 +22,18 @@ EXPORT_SYMBOL(pci_root_buses);
 
 LIST_HEAD(pci_devices);
 
+/*
+ * Some device drivers need know if pci is initiated.
+ * Basically, we think pci is not initiated when there
+ * is no device in list of pci_devices.
+ */
+int no_pci_devices(void)
+{
+	return list_empty(&pci_devices);
+}
+
+EXPORT_SYMBOL(no_pci_devices);
+
 #ifdef HAVE_PCI_LEGACY
 /**
  * pci_create_legacy_files - create legacy I/O port and memory files

commit 21ba0f88ae56da82a3a15fe54d729208b64c4f4b
Merge: dc690d8ef842 36e235901f90
Author: Linus Torvalds <torvalds@woody.linux-foundation.org>
Date:   Thu Jul 12 13:40:57 2007 -0700

    Merge master.kernel.org:/pub/scm/linux/kernel/git/gregkh/pci-2.6
    
    * master.kernel.org:/pub/scm/linux/kernel/git/gregkh/pci-2.6: (34 commits)
      PCI: Only build PCI syscalls on architectures that want them
      PCI: limit pci_get_bus_and_slot to domain 0
      PCI: hotplug: acpiphp: avoid acpiphp "cannot get bridge info" PCI hotplug failure
      PCI: hotplug: acpiphp: remove hot plug parameter write to PCI host bridge
      PCI: hotplug: acpiphp: fix slot poweroff problem on systems without _PS3
      PCI: hotplug: pciehp: wait for 1 second after power off slot
      PCI: pci_set_power_state(): check for PM capabilities earlier
      PCI: cpci_hotplug: Convert to use the kthread API
      PCI: add pci_try_set_mwi
      PCI: pcie: remove SPIN_LOCK_UNLOCKED
      PCI: ROUND_UP macro cleanup in drivers/pci
      PCI: remove pci_dac_dma_... APIs
      PCI: pci-x-pci-express-read-control-interfaces cleanups
      PCI: Fix typo in include/linux/pci.h
      PCI: pci_ids, remove double or more empty lines
      PCI: pci_ids, add atheros and 3com_2 vendors
      PCI: pci_ids, reorder some entries
      PCI: i386: traps, change VENDOR to DEVICE
      PCI: ATM: lanai, change VENDOR to DEVICE
      PCI: Change all drivers to use pci_device->revision
      ...

commit 7b595756ec1f49e0049a9e01a1298d53a7faaa15
Author: Tejun Heo <htejun@gmail.com>
Date:   Thu Jun 14 03:45:17 2007 +0900

    sysfs: kill unnecessary attribute->owner
    
    sysfs is now completely out of driver/module lifetime game.  After
    deletion, a sysfs node doesn't access anything outside sysfs proper,
    so there's no reason to hold onto the attribute owners.  Note that
    often the wrong modules were accounted for as owners leading to
    accessing removed modules.
    
    This patch kills now unnecessary attribute->owner.  Note that with
    this change, userland holding a sysfs node does not prevent the
    backing module from being unloaded.
    
    For more info regarding lifetime rule cleanup, please read the
    following message.
    
      http://article.gmane.org/gmane.linux.kernel/510293
    
    (tweaked by Greg to not delete the field just yet, to make it easier to
    merge things properly.)
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Cc: Cornelia Huck <cornelia.huck@de.ibm.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index e48fcf089621..08783bd381f5 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -39,7 +39,6 @@ static void pci_create_legacy_files(struct pci_bus *b)
 		b->legacy_io->attr.name = "legacy_io";
 		b->legacy_io->size = 0xffff;
 		b->legacy_io->attr.mode = S_IRUSR | S_IWUSR;
-		b->legacy_io->attr.owner = THIS_MODULE;
 		b->legacy_io->read = pci_read_legacy_io;
 		b->legacy_io->write = pci_write_legacy_io;
 		class_device_create_bin_file(&b->class_dev, b->legacy_io);
@@ -49,7 +48,6 @@ static void pci_create_legacy_files(struct pci_bus *b)
 		b->legacy_mem->attr.name = "legacy_mem";
 		b->legacy_mem->size = 1024*1024;
 		b->legacy_mem->attr.mode = S_IRUSR | S_IWUSR;
-		b->legacy_mem->attr.owner = THIS_MODULE;
 		b->legacy_mem->mmap = pci_mmap_legacy_mem;
 		class_device_create_bin_file(&b->class_dev, b->legacy_mem);
 	}

commit b8a3a5214d7cc115f1ca3a3967b7229d97c46f4a
Author: Auke Kok <auke-jan.h.kok@intel.com>
Date:   Fri Jun 8 15:46:30 2007 -0700

    PCI: read revision ID by default
    
    Currently there are 97 occurrences where drivers need the pci
    revision ID. We can do this once for all devices. Even the pci
    subsystem needs the revision several times for quirks. The extra
    u8 member pads out nicely in the pci_dev struct.
    
    Signed-off-by: Auke Kok <auke-jan.h.kok@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 9cd983acba8c..8802fcb4aaf0 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -702,6 +702,7 @@ static int pci_setup_device(struct pci_dev * dev)
 		dev->bus->number, PCI_SLOT(dev->devfn), PCI_FUNC(dev->devfn));
 
 	pci_read_config_dword(dev, PCI_CLASS_REVISION, &class);
+	dev->revision = class & 0xff;
 	class >>= 8;				    /* upper 3 bytes */
 	dev->class = class;
 	class >>= 8;

commit a23adb5b2db7f2a0758abfa20b0220dbcbfd7aa9
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Jun 7 13:27:09 2007 -0700

    PCI: point people to Bernhard instead of the linux-kernel list
    
    Back in commit 8c4b2cf9af9b4ecc29d4f0ec4ecc8e94dc4432d7, Bernhard said
    that he would fix up all instances of when this message happens.  So
    point people at him instead of the linux-kernel list which can not fix
    things up.
    
    Cc: Bernhard Kaindl <bk@suse.de>
    Cc: Dave Jones <davej@redhat.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Miles Lane <miles.lane@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index e48fcf089621..9cd983acba8c 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -656,7 +656,7 @@ int pci_scan_bridge(struct pci_bus *bus, struct pci_dev * dev, int max, int pass
 			       pcibios_assign_all_busses() ? " " :
 			       " (try 'pci=assign-busses')");
 			printk(KERN_WARNING "Please report the result to "
-			       "linux-kernel to fix this permanently\n");
+			       "<bk@suse.de> to fix this permanently\n");
 		}
 		bus = bus->parent;
 	}

commit 4aa9bc955d61fdf03b5f9cee67db188fe1ffa8b7
Author: Michael Ellerman <michael@ellerman.id.au>
Date:   Thu Apr 5 17:19:10 2007 +1000

    MSI: Use a list instead of the custom link structure
    
    The msi descriptors are linked together with what looks a lot like
    a linked list, but isn't a struct list_head list. Make it one.
    
    The only complication is that previously we walked a list of irqs, and
    got the descriptor for each with get_irq_msi(). Now we have a list of
    descriptors and need to get the irq out of it, so it needs to be in the
    actual struct msi_desc. We use 0 to indicate no irq is setup.
    
    Signed-off-by: Michael Ellerman <michael@ellerman.id.au>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index c659f8ae441a..e48fcf089621 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -857,6 +857,8 @@ struct pci_dev *alloc_pci_dev(void)
 	INIT_LIST_HEAD(&dev->global_list);
 	INIT_LIST_HEAD(&dev->bus_list);
 
+	pci_msi_init_pci_dev(dev);
+
 	return dev;
 }
 EXPORT_SYMBOL(alloc_pci_dev);

commit bab41e9be75121c473b00df2ffa33af3c44066a7
Author: Michael Ellerman <michael@ellerman.id.au>
Date:   Thu Apr 5 17:19:09 2007 +1000

    PCI: Convert to alloc_pci_dev()
    
    Convert code that allocs a struct pci_dev to use alloc_pci_dev().
    
    Signed-off-by: Michael Ellerman <michael@ellerman.id.au>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 70d37bbf09bb..c659f8ae441a 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -900,7 +900,7 @@ pci_scan_device(struct pci_bus *bus, int devfn)
 	if (pci_bus_read_config_byte(bus, devfn, PCI_HEADER_TYPE, &hdr_type))
 		return NULL;
 
-	dev = kzalloc(sizeof(struct pci_dev), GFP_KERNEL);
+	dev = alloc_pci_dev();
 	if (!dev)
 		return NULL;
 

commit 65891215e6b822c368fb3f36abf129ed48af8be0
Author: Michael Ellerman <michael@ellerman.id.au>
Date:   Thu Apr 5 17:19:08 2007 +1000

    PCI: Create alloc_pci_dev(), the one true way to create a struct pci_dev
    
    There are currently several places in the kernel where we kmalloc()
    a struct pci_dev and start initialising it. It'd be preferable to
    have an allocator so we can ensure the pci_dev is correctly initialised
    in one place.
    
    Signed-off-by: Michael Ellerman <michael@ellerman.id.au>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 629edf39a07d..70d37bbf09bb 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -846,6 +846,21 @@ static void pci_release_bus_bridge_dev(struct device *dev)
 	kfree(dev);
 }
 
+struct pci_dev *alloc_pci_dev(void)
+{
+	struct pci_dev *dev;
+
+	dev = kzalloc(sizeof(struct pci_dev), GFP_KERNEL);
+	if (!dev)
+		return NULL;
+
+	INIT_LIST_HEAD(&dev->global_list);
+	INIT_LIST_HEAD(&dev->bus_list);
+
+	return dev;
+}
+EXPORT_SYMBOL(alloc_pci_dev);
+
 /*
  * Read the config data for a PCI device, sanity-check it
  * and fill in the dev structure...

commit 96bde06a2df1b363206d3cdef53134b84ff37813
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Mon Mar 26 21:53:30 2007 -0800

    pci: do not mark exported functions as __devinit
    
    Functions marked __devinit will be removed after kernel init.  But being
    exported they are potentially called by a module much later.
    
    So the safer choice seems to be to keep the function even in the non
    CONFIG_HOTPLUG case.
    
    This silence the follwoing section mismatch warnings:
    WARNING: drivers/built-in.o - Section mismatch: reference to .init.text:pci_bus_add_device from __ksymtab_gpl between '__ksymtab_pci_bus_add_device' (at offset 0x20) and '__ksymtab_pci_walk_bus'
    WARNING: drivers/built-in.o - Section mismatch: reference to .init.text:pci_create_bus from __ksymtab_gpl between '__ksymtab_pci_create_bus' (at offset 0x40) and '__ksymtab_pci_stop_bus_device'
    WARNING: drivers/built-in.o - Section mismatch: reference to .init.text:pci_bus_max_busnr from __ksymtab_gpl between '__ksymtab_pci_bus_max_busnr' (at offset 0xc0) and '__ksymtab_pci_assign_resource_fixed'
    WARNING: drivers/built-in.o - Section mismatch: reference to .init.text:pci_claim_resource from __ksymtab_gpl between '__ksymtab_pci_claim_resource' (at offset 0xe0) and '__ksymtab_pcie_port_bus_type'
    WARNING: drivers/built-in.o - Section mismatch: reference to .init.text:pci_bus_add_devices from __ksymtab between '__ksymtab_pci_bus_add_devices' (at offset 0x70) and '__ksymtab_pci_bus_alloc_resource'
    WARNING: drivers/built-in.o - Section mismatch: reference to .init.text:pci_scan_bus_parented from __ksymtab between '__ksymtab_pci_scan_bus_parented' (at offset 0x90) and '__ksymtab_pci_root_buses'
    WARNING: drivers/built-in.o - Section mismatch: reference to .init.text:pci_bus_assign_resources from __ksymtab between '__ksymtab_pci_bus_assign_resources' (at offset 0x4d0) and '__ksymtab_pci_bus_size_bridges'
    WARNING: drivers/built-in.o - Section mismatch: reference to .init.text:pci_bus_size_bridges from __ksymtab between '__ksymtab_pci_bus_size_bridges' (at offset 0x4e0) and '__ksymtab_pci_setup_cardbus'
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 2fe1d690eb13..629edf39a07d 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -364,7 +364,7 @@ void __devinit pci_read_bridge_bases(struct pci_bus *child)
 	}
 }
 
-static struct pci_bus * __devinit pci_alloc_bus(void)
+static struct pci_bus * pci_alloc_bus(void)
 {
 	struct pci_bus *b;
 
@@ -432,7 +432,7 @@ pci_alloc_child_bus(struct pci_bus *parent, struct pci_dev *bridge, int busnr)
 	return NULL;
 }
 
-struct pci_bus * __devinit pci_add_new_bus(struct pci_bus *parent, struct pci_dev *dev, int busnr)
+struct pci_bus *pci_add_new_bus(struct pci_bus *parent, struct pci_dev *dev, int busnr)
 {
 	struct pci_bus *child;
 
@@ -461,7 +461,7 @@ static void pci_enable_crs(struct pci_dev *dev)
 	pci_write_config_word(dev, rpcap + PCI_EXP_RTCTL, rpctl);
 }
 
-static void __devinit pci_fixup_parent_subordinate_busnr(struct pci_bus *child, int max)
+static void pci_fixup_parent_subordinate_busnr(struct pci_bus *child, int max)
 {
 	struct pci_bus *parent = child->parent;
 
@@ -477,7 +477,7 @@ static void __devinit pci_fixup_parent_subordinate_busnr(struct pci_bus *child,
 	}
 }
 
-unsigned int __devinit pci_scan_child_bus(struct pci_bus *bus);
+unsigned int pci_scan_child_bus(struct pci_bus *bus);
 
 /*
  * If it's a bridge, configure it and scan the bus behind it.
@@ -489,7 +489,7 @@ unsigned int __devinit pci_scan_child_bus(struct pci_bus *bus);
  * them, we proceed to assigning numbers to the remaining buses in
  * order to avoid overlaps between old and new bus numbers.
  */
-int __devinit pci_scan_bridge(struct pci_bus *bus, struct pci_dev * dev, int max, int pass)
+int pci_scan_bridge(struct pci_bus *bus, struct pci_dev * dev, int max, int pass)
 {
 	struct pci_bus *child;
 	int is_cardbus = (dev->hdr_type == PCI_HEADER_TYPE_CARDBUS);
@@ -912,7 +912,7 @@ pci_scan_device(struct pci_bus *bus, int devfn)
 	return dev;
 }
 
-void __devinit pci_device_add(struct pci_dev *dev, struct pci_bus *bus)
+void pci_device_add(struct pci_dev *dev, struct pci_bus *bus)
 {
 	device_initialize(&dev->dev);
 	dev->dev.release = pci_release_dev;
@@ -935,8 +935,7 @@ void __devinit pci_device_add(struct pci_dev *dev, struct pci_bus *bus)
 	up_write(&pci_bus_sem);
 }
 
-struct pci_dev * __devinit
-pci_scan_single_device(struct pci_bus *bus, int devfn)
+struct pci_dev *pci_scan_single_device(struct pci_bus *bus, int devfn)
 {
 	struct pci_dev *dev;
 
@@ -958,7 +957,7 @@ pci_scan_single_device(struct pci_bus *bus, int devfn)
  * discovered devices to the @bus->devices list.  New devices
  * will have an empty dev->global_list head.
  */
-int __devinit pci_scan_slot(struct pci_bus *bus, int devfn)
+int pci_scan_slot(struct pci_bus *bus, int devfn)
 {
 	int func, nr = 0;
 	int scan_all_fns;
@@ -991,7 +990,7 @@ int __devinit pci_scan_slot(struct pci_bus *bus, int devfn)
 	return nr;
 }
 
-unsigned int __devinit pci_scan_child_bus(struct pci_bus *bus)
+unsigned int pci_scan_child_bus(struct pci_bus *bus)
 {
 	unsigned int devfn, pass, max = bus->secondary;
 	struct pci_dev *dev;
@@ -1041,7 +1040,7 @@ unsigned int __devinit pci_do_scan_bus(struct pci_bus *bus)
 	return max;
 }
 
-struct pci_bus * __devinit pci_create_bus(struct device *parent,
+struct pci_bus * pci_create_bus(struct device *parent,
 		int bus, struct pci_ops *ops, void *sysdata)
 {
 	int error;
@@ -1119,7 +1118,7 @@ struct pci_bus * __devinit pci_create_bus(struct device *parent,
 }
 EXPORT_SYMBOL_GPL(pci_create_bus);
 
-struct pci_bus * __devinit pci_scan_bus_parented(struct device *parent,
+struct pci_bus *pci_scan_bus_parented(struct device *parent,
 		int bus, struct pci_ops *ops, void *sysdata)
 {
 	struct pci_bus *b;

commit 01abc2aa0f447bce2f6beb06dd0607ba0f01c5bb
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Mon Apr 23 23:19:36 2007 +0200

    Revert "adjust legacy IDE resource setting (v2)"
    
    This reverts commit ed8ccee0918ad063a4741c0656fda783e02df627.
    
    It causes hang on boot for some users and we don't yet know why:
    
    http://bugzilla.kernel.org/show_bug.cgi?id=7562
    
    http://lkml.org/lkml/2007/4/20/404
    http://lkml.org/lkml/2007/3/25/113
    
    Just reverse it for 2.6.21-final, having broken X server is somehow
    better than unbootable system.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index a4a96826d9e0..2fe1d690eb13 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -682,34 +682,7 @@ static void pci_read_irq(struct pci_dev *dev)
 	dev->irq = irq;
 }
 
-static void change_legacy_io_resource(struct pci_dev * dev, unsigned index,
-                                      unsigned start, unsigned end)
-{
-	unsigned base = start & PCI_BASE_ADDRESS_IO_MASK;
-	unsigned len = (end | ~PCI_BASE_ADDRESS_IO_MASK) - base + 1;
-
-	/*
-	 * Some X versions get confused when the BARs reported through
-	 * /sys or /proc differ from those seen in config space, thus
-	 * try to update the config space values, too.
-	 */
-	if (!(pci_resource_flags(dev, index) & IORESOURCE_IO))
-		printk(KERN_WARNING "%s: cannot adjust BAR%u (not I/O)\n",
-		       pci_name(dev), index);
-	else if (pci_resource_len(dev, index) != len)
-		printk(KERN_WARNING "%s: cannot adjust BAR%u (size %04X)\n",
-		       pci_name(dev), index, (unsigned)pci_resource_len(dev, index));
-	else {
-		printk(KERN_INFO "%s: trying to change BAR%u from %04X to %04X\n",
-		       pci_name(dev), index,
-		       (unsigned)pci_resource_start(dev, index), base);
-		pci_write_config_dword(dev, PCI_BASE_ADDRESS_0 + index * 4, base);
-	}
-	pci_resource_start(dev, index) = start;
-	pci_resource_end(dev, index)   = end;
-	pci_resource_flags(dev, index) =
-		IORESOURCE_IO | IORESOURCE_PCI_FIXED | PCI_BASE_ADDRESS_SPACE_IO;
-}
+#define LEGACY_IO_RESOURCE	(IORESOURCE_IO | IORESOURCE_PCI_FIXED)
 
 /**
  * pci_setup_device - fill in class and map information of a device
@@ -762,12 +735,20 @@ static int pci_setup_device(struct pci_dev * dev)
 			u8 progif;
 			pci_read_config_byte(dev, PCI_CLASS_PROG, &progif);
 			if ((progif & 1) == 0) {
-				change_legacy_io_resource(dev, 0, 0x1F0, 0x1F7);
-				change_legacy_io_resource(dev, 1, 0x3F6, 0x3F6);
+				dev->resource[0].start = 0x1F0;
+				dev->resource[0].end = 0x1F7;
+				dev->resource[0].flags = LEGACY_IO_RESOURCE;
+				dev->resource[1].start = 0x3F6;
+				dev->resource[1].end = 0x3F6;
+				dev->resource[1].flags = LEGACY_IO_RESOURCE;
 			}
 			if ((progif & 4) == 0) {
-				change_legacy_io_resource(dev, 2, 0x170, 0x177);
-				change_legacy_io_resource(dev, 3, 0x376, 0x376);
+				dev->resource[2].start = 0x170;
+				dev->resource[2].end = 0x177;
+				dev->resource[2].flags = LEGACY_IO_RESOURCE;
+				dev->resource[3].start = 0x376;
+				dev->resource[3].end = 0x376;
+				dev->resource[3].flags = LEGACY_IO_RESOURCE;
 			}
 		}
 		break;

commit ed8ccee0918ad063a4741c0656fda783e02df627
Author: Jan Beulich <jbeulich@novell.com>
Date:   Sat Mar 3 17:48:54 2007 +0100

    adjust legacy IDE resource setting (v2)
    
    The change to force legacy mode IDE channels' resources to fixed non-zero
    values confuses (at least some versions of) X, because the values reported
    by the kernel and those readable from PCI config space aren't consistent
    anymore.  Therefore, this patch arranges for the respective BARs to also
    get updated if possible.
    
    Signed-off-by: Jan Beulich <jbeulich@novell.com>
    Acked-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 2fe1d690eb13..a4a96826d9e0 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -682,7 +682,34 @@ static void pci_read_irq(struct pci_dev *dev)
 	dev->irq = irq;
 }
 
-#define LEGACY_IO_RESOURCE	(IORESOURCE_IO | IORESOURCE_PCI_FIXED)
+static void change_legacy_io_resource(struct pci_dev * dev, unsigned index,
+                                      unsigned start, unsigned end)
+{
+	unsigned base = start & PCI_BASE_ADDRESS_IO_MASK;
+	unsigned len = (end | ~PCI_BASE_ADDRESS_IO_MASK) - base + 1;
+
+	/*
+	 * Some X versions get confused when the BARs reported through
+	 * /sys or /proc differ from those seen in config space, thus
+	 * try to update the config space values, too.
+	 */
+	if (!(pci_resource_flags(dev, index) & IORESOURCE_IO))
+		printk(KERN_WARNING "%s: cannot adjust BAR%u (not I/O)\n",
+		       pci_name(dev), index);
+	else if (pci_resource_len(dev, index) != len)
+		printk(KERN_WARNING "%s: cannot adjust BAR%u (size %04X)\n",
+		       pci_name(dev), index, (unsigned)pci_resource_len(dev, index));
+	else {
+		printk(KERN_INFO "%s: trying to change BAR%u from %04X to %04X\n",
+		       pci_name(dev), index,
+		       (unsigned)pci_resource_start(dev, index), base);
+		pci_write_config_dword(dev, PCI_BASE_ADDRESS_0 + index * 4, base);
+	}
+	pci_resource_start(dev, index) = start;
+	pci_resource_end(dev, index)   = end;
+	pci_resource_flags(dev, index) =
+		IORESOURCE_IO | IORESOURCE_PCI_FIXED | PCI_BASE_ADDRESS_SPACE_IO;
+}
 
 /**
  * pci_setup_device - fill in class and map information of a device
@@ -735,20 +762,12 @@ static int pci_setup_device(struct pci_dev * dev)
 			u8 progif;
 			pci_read_config_byte(dev, PCI_CLASS_PROG, &progif);
 			if ((progif & 1) == 0) {
-				dev->resource[0].start = 0x1F0;
-				dev->resource[0].end = 0x1F7;
-				dev->resource[0].flags = LEGACY_IO_RESOURCE;
-				dev->resource[1].start = 0x3F6;
-				dev->resource[1].end = 0x3F6;
-				dev->resource[1].flags = LEGACY_IO_RESOURCE;
+				change_legacy_io_resource(dev, 0, 0x1F0, 0x1F7);
+				change_legacy_io_resource(dev, 1, 0x3F6, 0x3F6);
 			}
 			if ((progif & 4) == 0) {
-				dev->resource[2].start = 0x170;
-				dev->resource[2].end = 0x177;
-				dev->resource[2].flags = LEGACY_IO_RESOURCE;
-				dev->resource[3].start = 0x376;
-				dev->resource[3].end = 0x376;
-				dev->resource[3].flags = LEGACY_IO_RESOURCE;
+				change_legacy_io_resource(dev, 2, 0x170, 0x177);
+				change_legacy_io_resource(dev, 3, 0x376, 0x376);
 			}
 		}
 		break;

commit 0fcfdabbdbedb3bdc63f29209aeeac805df78a92
Author: Michael Ellerman <michael@ellerman.id.au>
Date:   Thu Jan 25 19:34:08 2007 +1100

    MSI: Remove pci_scan_msi_device()
    
    pci_scan_msi_device() doesn't do anything anymore, so remove it.
    
    Signed-off-by: Michael Ellerman <michael@ellerman.id.au>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 9d7788428642..2fe1d690eb13 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -945,7 +945,6 @@ pci_scan_single_device(struct pci_bus *bus, int devfn)
 		return NULL;
 
 	pci_device_add(dev, bus);
-	pci_scan_msi_device(dev);
 
 	return dev;
 }

commit 07eddf3d597f2d009a37a4e8c7c32a1ffe992f3e
Author: Yinghai Lu <yinghai.lu@amd.com>
Date:   Wed Nov 29 13:53:10 2006 -0800

    PCI: check szhi when sz is 0 when 64 bit iomem bigger than 4G
    
    For pci mem resource that size is bigger than 4G, the sz returned by
    pc_size will be 0.
    So that resource is skipped, and register contained hi address will be
    treated as another 32bit resource. We need to use sz64 and pci_sz64 for
    64 bit resource for clear logical.  Typical usages for this: Opteron
    system with co-processor and the co-processor could take more than 4G
    RAM as pre-fetchable mem resource.
    
    
    Signed-off-by: Yinghai Lu <yinghai.lu@amd.com>
    Cc: Andi Kleen <ak@suse.de>
    Cc: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 0e0401dd02cb..9d7788428642 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -144,6 +144,32 @@ static u32 pci_size(u32 base, u32 maxbase, u32 mask)
 	return size;
 }
 
+static u64 pci_size64(u64 base, u64 maxbase, u64 mask)
+{
+	u64 size = mask & maxbase;	/* Find the significant bits */
+	if (!size)
+		return 0;
+
+	/* Get the lowest of them to find the decode size, and
+	   from that the extent.  */
+	size = (size & ~(size-1)) - 1;
+
+	/* base == maxbase can be valid only if the BAR has
+	   already been programmed with all 1s.  */
+	if (base == maxbase && ((base | size) & mask) != mask)
+		return 0;
+
+	return size;
+}
+
+static inline int is_64bit_memory(u32 mask)
+{
+	if ((mask & (PCI_BASE_ADDRESS_SPACE|PCI_BASE_ADDRESS_MEM_TYPE_MASK)) ==
+	    (PCI_BASE_ADDRESS_SPACE_MEMORY|PCI_BASE_ADDRESS_MEM_TYPE_64))
+		return 1;
+	return 0;
+}
+
 static void pci_read_bases(struct pci_dev *dev, unsigned int howmany, int rom)
 {
 	unsigned int pos, reg, next;
@@ -151,6 +177,10 @@ static void pci_read_bases(struct pci_dev *dev, unsigned int howmany, int rom)
 	struct resource *res;
 
 	for(pos=0; pos<howmany; pos = next) {
+		u64 l64;
+		u64 sz64;
+		u32 raw_sz;
+
 		next = pos+1;
 		res = &dev->resource[pos];
 		res->name = pci_name(dev);
@@ -163,9 +193,16 @@ static void pci_read_bases(struct pci_dev *dev, unsigned int howmany, int rom)
 			continue;
 		if (l == 0xffffffff)
 			l = 0;
-		if ((l & PCI_BASE_ADDRESS_SPACE) == PCI_BASE_ADDRESS_SPACE_MEMORY) {
+		raw_sz = sz;
+		if ((l & PCI_BASE_ADDRESS_SPACE) ==
+				PCI_BASE_ADDRESS_SPACE_MEMORY) {
 			sz = pci_size(l, sz, (u32)PCI_BASE_ADDRESS_MEM_MASK);
-			if (!sz)
+			/*
+			 * For 64bit prefetchable memory sz could be 0, if the
+			 * real size is bigger than 4G, so we need to check
+			 * szhi for that.
+			 */
+			if (!is_64bit_memory(l) && !sz)
 				continue;
 			res->start = l & PCI_BASE_ADDRESS_MEM_MASK;
 			res->flags |= l & ~PCI_BASE_ADDRESS_MEM_MASK;
@@ -178,30 +215,36 @@ static void pci_read_bases(struct pci_dev *dev, unsigned int howmany, int rom)
 		}
 		res->end = res->start + (unsigned long) sz;
 		res->flags |= pci_calc_resource_flags(l);
-		if ((l & (PCI_BASE_ADDRESS_SPACE | PCI_BASE_ADDRESS_MEM_TYPE_MASK))
-		    == (PCI_BASE_ADDRESS_SPACE_MEMORY | PCI_BASE_ADDRESS_MEM_TYPE_64)) {
+		if (is_64bit_memory(l)) {
 			u32 szhi, lhi;
+
 			pci_read_config_dword(dev, reg+4, &lhi);
 			pci_write_config_dword(dev, reg+4, ~0);
 			pci_read_config_dword(dev, reg+4, &szhi);
 			pci_write_config_dword(dev, reg+4, lhi);
-			szhi = pci_size(lhi, szhi, 0xffffffff);
+			sz64 = ((u64)szhi << 32) | raw_sz;
+			l64 = ((u64)lhi << 32) | l;
+			sz64 = pci_size64(l64, sz64, PCI_BASE_ADDRESS_MEM_MASK);
 			next++;
 #if BITS_PER_LONG == 64
-			res->start |= ((unsigned long) lhi) << 32;
-			res->end = res->start + sz;
-			if (szhi) {
-				/* This BAR needs > 4GB?  Wow. */
-				res->end |= (unsigned long)szhi<<32;
+			if (!sz64) {
+				res->start = 0;
+				res->end = 0;
+				res->flags = 0;
+				continue;
 			}
+			res->start = l64 & PCI_BASE_ADDRESS_MEM_MASK;
+			res->end = res->start + sz64;
 #else
-			if (szhi) {
-				printk(KERN_ERR "PCI: Unable to handle 64-bit BAR for device %s\n", pci_name(dev));
+			if (sz64 > 0x100000000ULL) {
+				printk(KERN_ERR "PCI: Unable to handle 64-bit "
+					"BAR for device %s\n", pci_name(dev));
 				res->start = 0;
 				res->flags = 0;
 			} else if (lhi) {
 				/* 64-bit wide address, treat as disabled */
-				pci_write_config_dword(dev, reg, l & ~(u32)PCI_BASE_ADDRESS_MEM_MASK);
+				pci_write_config_dword(dev, reg,
+					l & ~(u32)PCI_BASE_ADDRESS_MEM_MASK);
 				pci_write_config_dword(dev, reg+4, 0);
 				res->start = 0;
 				res->end = sz;

commit 76e6a1d6607e5b58003bb87e3b3220d5fdb7568d
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Fri Dec 29 16:47:29 2006 -0800

    [PATCH] pci/probe: fix macro that confuses kernel-doc
    
    Don't have macros between a function's kernel-doc block and the function
    definition.  This is not valid for kernel-doc.
    
    Warning(/var/linsrc/linux-2.6.20-rc1-git8//drivers/pci/probe.c:653): No description found for parameter 'IORESOURCE_PCI_FIXED'
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Cc: Greg KH <greg@kroah.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 1ae9c3f50ffa..0e0401dd02cb 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -639,6 +639,8 @@ static void pci_read_irq(struct pci_dev *dev)
 	dev->irq = irq;
 }
 
+#define LEGACY_IO_RESOURCE	(IORESOURCE_IO | IORESOURCE_PCI_FIXED)
+
 /**
  * pci_setup_device - fill in class and map information of a device
  * @dev: the device structure to fill
@@ -649,9 +651,6 @@ static void pci_read_irq(struct pci_dev *dev)
  * Returns 0 on success and -1 if unknown type of device (not normal, bridge
  * or CardBus).
  */
-
-#define LEGACY_IO_RESOURCE	(IORESOURCE_IO | IORESOURCE_PCI_FIXED)
-
 static int pci_setup_device(struct pci_dev * dev)
 {
 	u32 class;

commit fb0f2b40faff41f03acaa2ee6e6231fc96ca497c
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue Dec 19 13:12:08 2006 -0800

    PCI legacy resource fix
    
    Since commit 368c73d4f689dae0807d0a2aa74c61fd2b9b075f the kernel will try
    to update the non-writeable BAR registers 0..3 of PIIX4 IDE adapters if
    pci_assign_unassigned_resources() is used to do full resource assignment of
    the bus.  This fails because in the PIIX4 these BAR registers have
    implicitly assumed values and read back as zero; it used to work because
    the kernel used to just write zero to that register the read back value did
    match what was written.
    
    The fix is a new resource flag IORESOURCE_PCI_FIXED used to mark a resource
    as non-movable.  This will also be useful to keep other import system
    resources from being moved around - for example system consoles on PCI
    busses.
    
    [akpm@osdl.org: cleanup]
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
    Acked-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 6a3c1e728900..1ae9c3f50ffa 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -649,6 +649,9 @@ static void pci_read_irq(struct pci_dev *dev)
  * Returns 0 on success and -1 if unknown type of device (not normal, bridge
  * or CardBus).
  */
+
+#define LEGACY_IO_RESOURCE	(IORESOURCE_IO | IORESOURCE_PCI_FIXED)
+
 static int pci_setup_device(struct pci_dev * dev)
 {
 	u32 class;
@@ -692,18 +695,18 @@ static int pci_setup_device(struct pci_dev * dev)
 			if ((progif & 1) == 0) {
 				dev->resource[0].start = 0x1F0;
 				dev->resource[0].end = 0x1F7;
-				dev->resource[0].flags = IORESOURCE_IO;
+				dev->resource[0].flags = LEGACY_IO_RESOURCE;
 				dev->resource[1].start = 0x3F6;
 				dev->resource[1].end = 0x3F6;
-				dev->resource[1].flags = IORESOURCE_IO;
+				dev->resource[1].flags = LEGACY_IO_RESOURCE;
 			}
 			if ((progif & 4) == 0) {
 				dev->resource[2].start = 0x170;
 				dev->resource[2].end = 0x177;
-				dev->resource[2].flags = IORESOURCE_IO;
+				dev->resource[2].flags = LEGACY_IO_RESOURCE;
 				dev->resource[3].start = 0x376;
 				dev->resource[3].end = 0x376;
-				dev->resource[3].flags = IORESOURCE_IO;
+				dev->resource[3].flags = LEGACY_IO_RESOURCE;
 			}
 		}
 		break;

commit 873481367edb18a7d0d7e5a285e6728c16bb44a9
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Dec 6 20:32:33 2006 -0800

    [PATCH] add numa node information to struct device
    
    For node-aware skb allocations we need information about the node in struct
    net_device or struct device.  Davem suggested to put it into struct device
    which this patch does.
    
    In particular:
    
     - struct device gets a new int numa_node member if CONFIG_NUMA is set
     - there are two new helpers, dev_to_node and set_dev_node to
       transparently deal with the non-numa case
     - for pci devices the node-info is set to the value we get from
       pcibus_to_node.
    
    Note that for some architectures pcibus_to_node doesn't work yet at the time
    we call it currently.  This is harmless and will just mean skb allocations
    aren't node-local on this architectures until the implementation of
    pcibus_to_node on these architectures have been updated (There are patches for
    x86 and x86_64 floating around)
    
    [akpm@osdl.org: cleanup]
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Cc: Christoph Lameter <clameter@engr.sgi.com>
    Cc: Greg KH <greg@kroah.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 0eeac60042b3..6a3c1e728900 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -873,6 +873,7 @@ void __devinit pci_device_add(struct pci_dev *dev, struct pci_bus *bus)
 	dev->dev.release = pci_release_dev;
 	pci_dev_get(dev);
 
+	set_dev_node(&dev->dev, pcibus_to_node(bus));
 	dev->dev.dma_mask = &dev->dma_mask;
 	dev->dev.coherent_dma_mask = 0xffffffffull;
 

commit 368c73d4f689dae0807d0a2aa74c61fd2b9b075f
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Wed Oct 4 00:41:26 2006 +0100

    PCI: quirks: fix the festering mess that claims to handle IDE quirks
    
    The number of permutations of crap we do is amazing and almost all of it
    has the wrong effect in 2.6.
    
    At the heart of this is the PCI SFF magic which says that compatibility
    mode PCI IDE controllers use ISA IRQ routing and hard coded addresses
    not the BAR values. The old quirks variously clears them, sets them,
    adjusts them and then IDE ignores the result.
    
    In order to drive all this garbage out and to do it portably we need to
    handle the SFF rules directly and properly. Because we know the device
    BAR 0-3 are not used in compatibility mode we load them with the values
    that are implied (and indeed which many controllers actually
    thoughtfully put there in this mode anyway).
    
    This removes special cases in the IDE layer and libata which now knows
    that bar 0/1/2/3 always contain the correct address. It means our
    resource allocation map is accurate from boot, not "mostly accurate"
    after ide is loaded, and it shoots lots of code. There is also lots more
    code and magic constant knowledge to shoot once this is in and settled.
    
    Been in my test tree for a while both with drivers/ide and with libata.
    Wants some -mm shakedown in case I've missed something dumb or there are
    corner cases lurking.
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index e159d6604494..0eeac60042b3 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -679,6 +679,33 @@ static int pci_setup_device(struct pci_dev * dev)
 		pci_read_bases(dev, 6, PCI_ROM_ADDRESS);
 		pci_read_config_word(dev, PCI_SUBSYSTEM_VENDOR_ID, &dev->subsystem_vendor);
 		pci_read_config_word(dev, PCI_SUBSYSTEM_ID, &dev->subsystem_device);
+
+		/*
+		 *	Do the ugly legacy mode stuff here rather than broken chip
+		 *	quirk code. Legacy mode ATA controllers have fixed
+		 *	addresses. These are not always echoed in BAR0-3, and
+		 *	BAR0-3 in a few cases contain junk!
+		 */
+		if (class == PCI_CLASS_STORAGE_IDE) {
+			u8 progif;
+			pci_read_config_byte(dev, PCI_CLASS_PROG, &progif);
+			if ((progif & 1) == 0) {
+				dev->resource[0].start = 0x1F0;
+				dev->resource[0].end = 0x1F7;
+				dev->resource[0].flags = IORESOURCE_IO;
+				dev->resource[1].start = 0x3F6;
+				dev->resource[1].end = 0x3F6;
+				dev->resource[1].flags = IORESOURCE_IO;
+			}
+			if ((progif & 4) == 0) {
+				dev->resource[2].start = 0x170;
+				dev->resource[2].end = 0x177;
+				dev->resource[2].flags = IORESOURCE_IO;
+				dev->resource[3].start = 0x376;
+				dev->resource[3].end = 0x376;
+				dev->resource[3].flags = IORESOURCE_IO;
+			}
+		}
 		break;
 
 	case PCI_HEADER_TYPE_BRIDGE:		    /* bridge header */

commit 6b4b78fed47e7380dfe9280b154e8b9bfcd4c86c
Author: Matt Domsch <Matt_Domsch@dell.com>
Date:   Fri Sep 29 15:23:23 2006 -0500

    PCI: optionally sort device lists breadth-first
    
    Problem:
    New Dell PowerEdge servers have 2 embedded ethernet ports, which are
    labeled NIC1 and NIC2 on the chassis, in the BIOS setup screens, and
    in the printed documentation.  Assuming no other add-in ethernet ports
    in the system, Linux 2.4 kernels name these eth0 and eth1
    respectively.  Many people have come to expect this naming.  Linux 2.6
    kernels name these eth1 and eth0 respectively (backwards from
    expectations).  I also have reports that various Sun and HP servers
    have similar behavior.
    
    
    Root cause:
    Linux 2.4 kernels walk the pci_devices list, which happens to be
    sorted in breadth-first order (or pcbios_find_device order on i386,
    which most often is breadth-first also).  2.6 kernels have both the
    pci_devices list and the pci_bus_type.klist_devices list, the latter
    is what is walked at driver load time to match the pci_id tables; this
    klist happens to be in depth-first order.
    
    On systems where, for physical routing reasons, NIC1 appears on a
    lower bus number than NIC2, but NIC2's bridge is discovered first in
    the depth-first ordering, NIC2 will be discovered before NIC1.  If the
    list were sorted breadth-first, NIC1 would be discovered before NIC2.
    
    A PowerEdge 1955 system has the following topology which easily
    exhibits the difference between depth-first and breadth-first device
    lists.
    
    -[0000:00]-+-00.0  Intel Corporation 5000P Chipset Memory Controller Hub
               +-02.0-[0000:03-08]--+-00.0-[0000:04-07]--+-00.0-[0000:05-06]----00.0-[0000:06]----00.0  Broadcom Corporation NetXtreme II BCM5708S Gigabit Ethernet (labeled NIC2, 2.4 kernel name eth1, 2.6 kernel name eth0)
               +-1c.0-[0000:01-02]----00.0-[0000:02]----00.0  Broadcom Corporation NetXtreme II BCM5708S Gigabit Ethernet (labeled NIC1, 2.4 kernel name eth0, 2.6 kernel name eth1)
    
    
    Other factors, such as device driver load order and the presence of
    PCI slots at various points in the bus hierarchy further complicate
    this problem; I'm not trying to solve those here, just restore the
    device order, and thus basic behavior, that 2.4 kernels had.
    
    
    Solution:
    
    The solution can come in multiple steps.
    
    Suggested fix #1: kernel
    Patch below optionally sorts the two device lists into breadth-first
    ordering to maintain compatibility with 2.4 kernels.  It adds two new
    command line options:
      pci=bfsort
      pci=nobfsort
    to force the sort order, or not, as you wish.  It also adds DMI checks
    for the specific Dell systems which exhibit "backwards" ordering, to
    make them "right".
    
    
    Suggested fix #2: udev rules from userland
    Many people also have the expectation that embedded NICs are always
    discovered before add-in NICs (which this patch does not try to do).
    Using the PCI IRQ Routing Table provided by system BIOS, it's easy to
    determine which PCI devices are embedded, or if add-in, which PCI slot
    they're in.  I'm working on a tool that would allow udev to name
    ethernet devices in ascending embedded, slot 1 .. slot N order,
    subsort by PCI bus/dev/fn breadth-first.  It'll be possible to use it
    independent of udev as well for those distributions that don't use
    udev in their installers.
    
    Suggested fix #3: system board routing rules
    One can constrain the system board layout to put NIC1 ahead of NIC2
    regardless of breadth-first or depth-first discovery order.  This adds
    a significant level of complexity to board routing, and may not be
    possible in all instances (witness the above systems from several
    major manufacturers).  I don't want to encourage this particular train
    of thought too far, at the expense of not doing #1 or #2 above.
    
    
    Feedback appreciated.  Patch tested on a Dell PowerEdge 1955 blade
    with 2.6.18.
    
    You'll also note I took some liberty and temporarily break the klist
    abstraction to simplify and speed up the sort algorithm.  I think
    that's both safe and appropriate in this instance.
    
    
    Signed-off-by: Matt Domsch <Matt_Domsch@dell.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index a3b0a5eb5054..e159d6604494 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1067,3 +1067,95 @@ EXPORT_SYMBOL(pci_scan_bridge);
 EXPORT_SYMBOL(pci_scan_single_device);
 EXPORT_SYMBOL_GPL(pci_scan_child_bus);
 #endif
+
+static int __init pci_sort_bf_cmp(const struct pci_dev *a, const struct pci_dev *b)
+{
+	if      (pci_domain_nr(a->bus) < pci_domain_nr(b->bus)) return -1;
+	else if (pci_domain_nr(a->bus) > pci_domain_nr(b->bus)) return  1;
+
+	if      (a->bus->number < b->bus->number) return -1;
+	else if (a->bus->number > b->bus->number) return  1;
+
+	if      (a->devfn < b->devfn) return -1;
+	else if (a->devfn > b->devfn) return  1;
+
+	return 0;
+}
+
+/*
+ * Yes, this forcably breaks the klist abstraction temporarily.  It
+ * just wants to sort the klist, not change reference counts and
+ * take/drop locks rapidly in the process.  It does all this while
+ * holding the lock for the list, so objects can't otherwise be
+ * added/removed while we're swizzling.
+ */
+static void __init pci_insertion_sort_klist(struct pci_dev *a, struct list_head *list)
+{
+	struct list_head *pos;
+	struct klist_node *n;
+	struct device *dev;
+	struct pci_dev *b;
+
+	list_for_each(pos, list) {
+		n = container_of(pos, struct klist_node, n_node);
+		dev = container_of(n, struct device, knode_bus);
+		b = to_pci_dev(dev);
+		if (pci_sort_bf_cmp(a, b) <= 0) {
+			list_move_tail(&a->dev.knode_bus.n_node, &b->dev.knode_bus.n_node);
+			return;
+		}
+	}
+	list_move_tail(&a->dev.knode_bus.n_node, list);
+}
+
+static void __init pci_sort_breadthfirst_klist(void)
+{
+	LIST_HEAD(sorted_devices);
+	struct list_head *pos, *tmp;
+	struct klist_node *n;
+	struct device *dev;
+	struct pci_dev *pdev;
+
+	spin_lock(&pci_bus_type.klist_devices.k_lock);
+	list_for_each_safe(pos, tmp, &pci_bus_type.klist_devices.k_list) {
+		n = container_of(pos, struct klist_node, n_node);
+		dev = container_of(n, struct device, knode_bus);
+		pdev = to_pci_dev(dev);
+		pci_insertion_sort_klist(pdev, &sorted_devices);
+	}
+	list_splice(&sorted_devices, &pci_bus_type.klist_devices.k_list);
+	spin_unlock(&pci_bus_type.klist_devices.k_lock);
+}
+
+static void __init pci_insertion_sort_devices(struct pci_dev *a, struct list_head *list)
+{
+	struct pci_dev *b;
+
+	list_for_each_entry(b, list, global_list) {
+		if (pci_sort_bf_cmp(a, b) <= 0) {
+			list_move_tail(&a->global_list, &b->global_list);
+			return;
+		}
+	}
+	list_move_tail(&a->global_list, list);
+}
+
+static void __init pci_sort_breadthfirst_devices(void)
+{
+	LIST_HEAD(sorted_devices);
+	struct pci_dev *dev, *tmp;
+
+	down_write(&pci_bus_sem);
+	list_for_each_entry_safe(dev, tmp, &pci_devices, global_list) {
+		pci_insertion_sort_devices(dev, &sorted_devices);
+	}
+	list_splice(&sorted_devices, &pci_devices);
+	up_write(&pci_bus_sem);
+}
+
+void __init pci_sort_breadthfirst(void)
+{
+	pci_sort_breadthfirst_devices();
+	pci_sort_breadthfirst_klist();
+}
+

commit b19441af185559118e8247382ea4f2f76ebffc6d
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Aug 28 11:43:25 2006 -0700

    PCI: fix __must_check warnings
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index c5a58d1c6c1c..a3b0a5eb5054 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -339,6 +339,7 @@ pci_alloc_child_bus(struct pci_bus *parent, struct pci_dev *bridge, int busnr)
 {
 	struct pci_bus *child;
 	int i;
+	int retval;
 
 	/*
 	 * Allocate a new bus, and inherit stuff from the parent..
@@ -356,8 +357,13 @@ pci_alloc_child_bus(struct pci_bus *parent, struct pci_dev *bridge, int busnr)
 
 	child->class_dev.class = &pcibus_class;
 	sprintf(child->class_dev.class_id, "%04x:%02x", pci_domain_nr(child), busnr);
-	class_device_register(&child->class_dev);
-	class_device_create_file(&child->class_dev, &class_device_attr_cpuaffinity);
+	retval = class_device_register(&child->class_dev);
+	if (retval)
+		goto error_register;
+	retval = class_device_create_file(&child->class_dev,
+					  &class_device_attr_cpuaffinity);
+	if (retval)
+		goto error_file_create;
 
 	/*
 	 * Set up the primary, secondary and subordinate
@@ -375,6 +381,12 @@ pci_alloc_child_bus(struct pci_bus *parent, struct pci_dev *bridge, int busnr)
 	bridge->subordinate = child;
 
 	return child;
+
+error_file_create:
+	class_device_unregister(&child->class_dev);
+error_register:
+	kfree(child);
+	return NULL;
 }
 
 struct pci_bus * __devinit pci_add_new_bus(struct pci_bus *parent, struct pci_dev *dev, int busnr)

commit 82081797b7d72108a47c82997349d1ea6a3eb3d5
Author: Linas Vepstas <linas@austin.ibm.com>
Date:   Mon Jul 10 04:44:46 2006 -0700

    [PATCH] pci: initialize struct pci_dev.error_state
    
    The pci channel state is currently uninitialized, thus there are two ways
    of indicating that "everything's OK": 0 and 1.  This is a bit of a burden.
    
    If a devce driver wants to check if the pci channel is in a working or a
    disconnected state, the driver writer must perform checks similar to
    
       if((pdev->error_state != 0) &&
          (pdev->error_state != pci_channel_io_normal)) {
             whatever();
       }
    
    which is rather akward.  The first check is needed because stuct pci_dev is
    inited to all-zeros.  The scond is needed because the error recovery will
    set the state to pci_channel_io_normal (which is not zero).
    
    This patch fixes this awkwardness.
    
    Signed-off-by: Linas Vepstas <linas@austin.ibm.com>
    Cc: Greg KH <greg@kroah.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index f89dbc3738b7..c5a58d1c6c1c 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -815,6 +815,7 @@ pci_scan_device(struct pci_bus *bus, int devfn)
 	dev->vendor = l & 0xffff;
 	dev->device = (l >> 16) & 0xffff;
 	dev->cfg_size = pci_cfg_space_size(dev);
+	dev->error_state = pci_channel_io_normal;
 
 	/* Assume 32-bit PCI; let 64-bit PCI cards (which are far rarer)
 	   set this higher, assuming the system even supports it.  */

commit d71374dafbba7ec3f67371d3b7e9f6310a588808
Author: Zhang Yanmin <yanmin.zhang@intel.com>
Date:   Fri Jun 2 12:35:43 2006 +0800

    [PATCH] PCI: fix race with pci_walk_bus and pci_destroy_dev
    
    pci_walk_bus has a race with pci_destroy_dev. When cb is called
    in pci_walk_bus, pci_destroy_dev might unlink the dev pointed by next.
    Later on in the next loop, pointer next becomes NULL and cause
    kernel panic.
    
    Below patch against 2.6.17-rc4 fixes it by changing pci_bus_lock (spin_lock)
    to pci_bus_sem (rw_semaphore).
    
    Signed-off-by: Zhang Yanmin <yanmin.zhang@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 27148db06ba0..f89dbc3738b7 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -383,9 +383,9 @@ struct pci_bus * __devinit pci_add_new_bus(struct pci_bus *parent, struct pci_de
 
 	child = pci_alloc_child_bus(parent, dev, busnr);
 	if (child) {
-		spin_lock(&pci_bus_lock);
+		down_write(&pci_bus_sem);
 		list_add_tail(&child->node, &parent->children);
-		spin_unlock(&pci_bus_lock);
+		up_write(&pci_bus_sem);
 	}
 	return child;
 }
@@ -844,9 +844,9 @@ void __devinit pci_device_add(struct pci_dev *dev, struct pci_bus *bus)
 	 * and the bus list for fixup functions, etc.
 	 */
 	INIT_LIST_HEAD(&dev->global_list);
-	spin_lock(&pci_bus_lock);
+	down_write(&pci_bus_sem);
 	list_add_tail(&dev->bus_list, &bus->devices);
-	spin_unlock(&pci_bus_lock);
+	up_write(&pci_bus_sem);
 }
 
 struct pci_dev * __devinit
@@ -981,9 +981,10 @@ struct pci_bus * __devinit pci_create_bus(struct device *parent,
 		pr_debug("PCI: Bus %04x:%02x already known\n", pci_domain_nr(b), bus);
 		goto err_out;
 	}
-	spin_lock(&pci_bus_lock);
+
+	down_write(&pci_bus_sem);
 	list_add_tail(&b->node, &pci_root_buses);
-	spin_unlock(&pci_bus_lock);
+	up_write(&pci_bus_sem);
 
 	memset(dev, 0, sizeof(*dev));
 	dev->parent = parent;
@@ -1023,9 +1024,9 @@ struct pci_bus * __devinit pci_create_bus(struct device *parent,
 class_dev_reg_err:
 	device_unregister(dev);
 dev_reg_err:
-	spin_lock(&pci_bus_lock);
+	down_write(&pci_bus_sem);
 	list_del(&b->node);
-	spin_unlock(&pci_bus_lock);
+	up_write(&pci_bus_sem);
 err_out:
 	kfree(dev);
 	kfree(b);

commit ea28502d5d0fc624777a8a6b4d6865d282055b05
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Fri Jun 9 11:28:29 2006 -0700

    [PATCH] PCI: fix to pci ignore pre-set 64-bit bars on 32-bit platforms
    
    When we detect a 64-bit pre-set address in a BAR on a 32-bit platform,
    we disable it and treat it as if it had been unset, thus allowing the
    general address assignment code to assign a new address to it when the
    device is enabled.  This can happen either if the firmware assigns
    64-bit addresses; additionally, some cards have been found "in the
    wild" which do not come out of reset with all the BAR registers set to
    zero.
    
    Unfortunately, the patch that implemented this tested the low part of
    the address instead of the high part of the address.  This patch fixes
    that.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 5c4924c27f09..27148db06ba0 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -199,7 +199,7 @@ static void pci_read_bases(struct pci_dev *dev, unsigned int howmany, int rom)
 				printk(KERN_ERR "PCI: Unable to handle 64-bit BAR for device %s\n", pci_name(dev));
 				res->start = 0;
 				res->flags = 0;
-			} else if (l) {
+			} else if (lhi) {
 				/* 64-bit wide address, treat as disabled */
 				pci_write_config_dword(dev, reg, l & ~(u32)PCI_BASE_ADDRESS_MEM_MASK);
 				pci_write_config_dword(dev, reg+4, 0);

commit 17d6dc8ff098cc8c57941c82f7702804302b1ea1
Author: H. Peter Anvin <hpa@c2micro.com>
Date:   Tue Apr 18 17:19:52 2006 -0700

    [PATCH] PCI: Ignore pre-set 64-bit BARs on 32-bit platforms
    
    [pci] Ignore pre-set 64-bit BARs on 32-bit platforms
    
    Currently, Linux always rejects a device which has a pre-set 64-bit
    address on a 32-bit platform.  On systems which do not do PCI
    initialization in firmware, this causes some devices which don't
    correctly power up with all BARs zero to fail.
    
    This patch makes the kernel automatically zero out such an address
    (thus treating it as if it had not been set at all, meaning it will
    assign an address if necessary).
    
    I have done this only for devices, not bridges.  It seems potentially
    hazardous to do for bridges.
    
    Signed-off-by: H. Peter Anvin <hpa@c2micro.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index a10ed9dab2c2..5c4924c27f09 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -180,25 +180,31 @@ static void pci_read_bases(struct pci_dev *dev, unsigned int howmany, int rom)
 		res->flags |= pci_calc_resource_flags(l);
 		if ((l & (PCI_BASE_ADDRESS_SPACE | PCI_BASE_ADDRESS_MEM_TYPE_MASK))
 		    == (PCI_BASE_ADDRESS_SPACE_MEMORY | PCI_BASE_ADDRESS_MEM_TYPE_64)) {
-			pci_read_config_dword(dev, reg+4, &l);
+			u32 szhi, lhi;
+			pci_read_config_dword(dev, reg+4, &lhi);
+			pci_write_config_dword(dev, reg+4, ~0);
+			pci_read_config_dword(dev, reg+4, &szhi);
+			pci_write_config_dword(dev, reg+4, lhi);
+			szhi = pci_size(lhi, szhi, 0xffffffff);
 			next++;
 #if BITS_PER_LONG == 64
-			res->start |= ((unsigned long) l) << 32;
+			res->start |= ((unsigned long) lhi) << 32;
 			res->end = res->start + sz;
-			pci_write_config_dword(dev, reg+4, ~0);
-			pci_read_config_dword(dev, reg+4, &sz);
-			pci_write_config_dword(dev, reg+4, l);
-			sz = pci_size(l, sz, 0xffffffff);
-			if (sz) {
+			if (szhi) {
 				/* This BAR needs > 4GB?  Wow. */
-				res->end |= (unsigned long)sz<<32;
+				res->end |= (unsigned long)szhi<<32;
 			}
 #else
-			if (l) {
-				printk(KERN_ERR "PCI: Unable to handle 64-bit address for device %s\n", pci_name(dev));
+			if (szhi) {
+				printk(KERN_ERR "PCI: Unable to handle 64-bit BAR for device %s\n", pci_name(dev));
 				res->start = 0;
 				res->flags = 0;
-				continue;
+			} else if (l) {
+				/* 64-bit wide address, treat as disabled */
+				pci_write_config_dword(dev, reg, l & ~(u32)PCI_BASE_ADDRESS_MEM_MASK);
+				pci_write_config_dword(dev, reg+4, 0);
+				res->start = 0;
+				res->end = sz;
 			}
 #endif
 		}

commit f5afe8064f3087bead8fea7e32547c2a3ada5fd0
Author: Eric Sesterhenn <snakebyte@gmx.de>
Date:   Tue Feb 28 15:34:49 2006 +0100

    [PATCH] PCI: kzalloc() conversion in drivers/pci
    
    this patch converts drivers/pci to kzalloc usage.
    Compile tested with allyes config.
    
    Signed-off-by: Eric Sesterhenn <snakebyte@gmx.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index e3dc3063e05b..a10ed9dab2c2 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -33,10 +33,9 @@ LIST_HEAD(pci_devices);
  */
 static void pci_create_legacy_files(struct pci_bus *b)
 {
-	b->legacy_io = kmalloc(sizeof(struct bin_attribute) * 2,
+	b->legacy_io = kzalloc(sizeof(struct bin_attribute) * 2,
 			       GFP_ATOMIC);
 	if (b->legacy_io) {
-		memset(b->legacy_io, 0, sizeof(struct bin_attribute) * 2);
 		b->legacy_io->attr.name = "legacy_io";
 		b->legacy_io->size = 0xffff;
 		b->legacy_io->attr.mode = S_IRUSR | S_IWUSR;
@@ -320,9 +319,8 @@ static struct pci_bus * __devinit pci_alloc_bus(void)
 {
 	struct pci_bus *b;
 
-	b = kmalloc(sizeof(*b), GFP_KERNEL);
+	b = kzalloc(sizeof(*b), GFP_KERNEL);
 	if (b) {
-		memset(b, 0, sizeof(*b));
 		INIT_LIST_HEAD(&b->node);
 		INIT_LIST_HEAD(&b->children);
 		INIT_LIST_HEAD(&b->devices);
@@ -797,11 +795,10 @@ pci_scan_device(struct pci_bus *bus, int devfn)
 	if (pci_bus_read_config_byte(bus, devfn, PCI_HEADER_TYPE, &hdr_type))
 		return NULL;
 
-	dev = kmalloc(sizeof(struct pci_dev), GFP_KERNEL);
+	dev = kzalloc(sizeof(struct pci_dev), GFP_KERNEL);
 	if (!dev)
 		return NULL;
 
-	memset(dev, 0, sizeof(struct pci_dev));
 	dev->bus = bus;
 	dev->sysdata = bus->sysdata;
 	dev->dev.parent = bus->bridge;

commit 8c4b2cf9af9b4ecc29d4f0ec4ecc8e94dc4432d7
Author: Bernhard Kaindl <bk@suse.de>
Date:   Sat Feb 18 01:36:55 2006 -0800

    [PATCH] PCI: PCI/Cardbus cards hidden, needs pci=assign-busses to fix
    
    "In some cases, especially on modern laptops with a lot of PCI and cardbus
    bridges, we're unable to assign correct secondary/subordinate bus numbers
    to all cardbus bridges due to BIOS limitations unless we are using
    "pci=assign-busses" boot option." -- Ivan Kokshaysky (from a patch comment)
    
    Without it, Cardbus cards inserted are never seen by PCI because the parent
    PCI-PCI Bridge of the Cardbus bridge will not pass and translate Type 1 PCI
    configuration cycles correctly and the system will fail to find and
    initialise the PCI devices in the system.
    
    Reference: PCI-PCI Bridges: PCI Configuration Cycles and PCI Bus Numbering:
    http://www.science.unitn.it/~fiorella/guidelinux/tlk/node72.html
    
    The reason for this is that:
     ``All PCI busses located behind a PCI-PCI bridge must reside between the
    secondary bus number and the subordinate bus number (inclusive).''
    
    "pci=assign-busses" makes pcibios_assign_all_busses return 1 and this
    turns on PCI renumbering during PCI probing.
    
    Alan suggested to use DMI automatically set assign-busses on problem systems.
    
    The only question for me was where to put it.  I put it directly before
    scanning PCI bus into pcibios_scan_root() because it's called from legacy,
    acpi and numa and so it can be one place for all systems and configurations
    which may need it.
    
    AMD64 Laptops are also affected and fixed by assign-busses, and the code is
    also incuded from arch/x86_64/pci/ that place will also work for x86_64
    kernels, I only ifdef'-ed the x86-only Laptop in this example.
    
    Affected and known or assumed to be fixed with it are (found by googling):
    
    * ASUS Z71V and L3s
    * Samsung X20
    * Compaq R3140us and all Compaq R3000 series laptops with TI1620 Controller,
      also Compaq R4000 series (from a kernel.org bugreport)
    * HP zv5000z (AMD64 3700+, known that fixup_parent_subordinate_busnr fixes it)
    * HP zv5200z
    * IBM ThinkPad 240
    * An IBM ThinkPad (1.8 GHz Pentium M) debugged by Pavel Machek
      gives the correspondig message which detects the possible problem.
    * MSI S260 / Medion SIM 2100 MD 95600
    
    The patch also expands the "try pci=assign-busses" warning so testers will
    help us to update the DMI table.
    
    Cc: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Cc: Dominik Brodowski <linux@dominikbrodowski.net>
    Cc: Russell King <rmk@arm.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 542e7dfb371b..e3dc3063e05b 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -589,13 +589,15 @@ int __devinit pci_scan_bridge(struct pci_bus *bus, struct pci_dev * dev, int max
 		    (child->number > bus->subordinate) ||
 		    (child->number < bus->number) ||
 		    (child->subordinate < bus->number)) {
-			printk(KERN_WARNING "PCI: Bus #%02x (-#%02x) may be "
+			printk(KERN_WARNING "PCI: Bus #%02x (-#%02x) is "
 			       "hidden behind%s bridge #%02x (-#%02x)%s\n",
 			       child->number, child->subordinate,
 			       bus->self->transparent ? " transparent" : " ",
 			       bus->number, bus->subordinate,
 			       pcibios_assign_all_busses() ? " " :
 			       " (try 'pci=assign-busses')");
+			printk(KERN_WARNING "Please report the result to "
+			       "linux-kernel to fix this permanently\n");
 		}
 		bus = bus->parent;
 	}

commit 6e325a62a0a228cd0222783802b53cce04551776
Author: Michael S. Tsirkin <mst@mellanox.co.il>
Date:   Tue Feb 14 18:52:22 2006 +0200

    [PATCH] PCI: make MSI quirk inheritable from the pci bus
    
    It turns out AMD 8131 quirk only affects MSI for devices behind the 8131 bridge.
    Handle this by adding a flags field in pci_bus, inherited from parent to child.
    
    Signed-off-by: Michael S. Tsirkin <mst@mellanox.co.il>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 3bc0fcd71d03..542e7dfb371b 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -347,6 +347,7 @@ pci_alloc_child_bus(struct pci_bus *parent, struct pci_dev *bridge, int busnr)
 	child->parent = parent;
 	child->ops = parent->ops;
 	child->sysdata = parent->sysdata;
+	child->bus_flags = parent->bus_flags;
 	child->bridge = get_device(&bridge->dev);
 
 	child->class_dev.class = &pcibus_class;

commit bbe8f9a3e76c551973ee739de10b26581d78b45f
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue Feb 14 16:23:57 2006 +0000

    [PATCH] PCI: Avoid leaving MASTER_ABORT disabled permanently when returning from pci_scan_bridge.
    
    > On Mon, Feb 13, 2006 at 05:13:21PM -0800, David S. Miller wrote:
    > >
    > > In drivers/pci/probe.c:pci_scan_bridge(), if this is not the first
    > > pass (pass != 0) we don't restore the PCI_BRIDGE_CONTROL_REGISTER and
    > > thus leave PCI_BRIDGE_CTL_MASTER_ABORT off:
    > >
    > > int __devinit pci_scan_bridge(struct pci_bus *bus, struct pci_dev * dev, int max, int pass)
    > > {
    > >  ...
    > >     /* Disable MasterAbortMode during probing to avoid reporting
    > >        of bus errors (in some architectures) */
    > >     pci_read_config_word(dev, PCI_BRIDGE_CONTROL, &bctl);
    > >     pci_write_config_word(dev, PCI_BRIDGE_CONTROL,
    > >                           bctl & ~PCI_BRIDGE_CTL_MASTER_ABORT);
    > >  ...
    > >     if ((buses & 0xffff00) && !pcibios_assign_all_busses() && !is_cardbus) {
    > >             unsigned int cmax, busnr;
    > >             /*
    > >              * Bus already configured by firmware, process it in the first
    > >              * pass and just note the configuration.
    > >              */
    > >             if (pass)
    > >                     return max;
    > >  ...
    > >     }
    > >
    > >     pci_write_config_word(dev, PCI_BRIDGE_CONTROL, bctl);
    > >  ...
    > >
    > > This doesn't seem intentional.
    
    Agreed, looks like an accident.  The patch [1] originally came from Kip
    Walker (Broadcom back then) between 2.6.0-test3 and 2.6.0-test4.  As I
    recall it was supposed to fix an issue with with PCI aborts being
    signalled by the PCI bridge of the Broadcom BCM1250 family of SOCs when
    probing behind pci_scan_bridge.  It is undeseriable to disable
    PCI_BRIDGE_CTL_MASTER_ABORT in pci_{read,write)_config_* and the
    behaviour wasn't considered a bug in need of a workaround, so this was
    put in probe.c.
    
    I don't have an affected system at hand, so can't really test but I
    propose something like the below patch.
    
    [1] http://www.linux-mips.org/git?p=linux.git;a=commit;h=599457e0cb702a31a3247ea6a5d9c6c99c4cf195
    
    [PCI] Avoid leaving MASTER_ABORT disabled permanently when returning from pci_scan_bridge.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 63751a283817..3bc0fcd71d03 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -456,7 +456,7 @@ int __devinit pci_scan_bridge(struct pci_bus *bus, struct pci_dev * dev, int max
 		 * pass and just note the configuration.
 		 */
 		if (pass)
-			return max;
+			goto out;
 		busnr = (buses >> 8) & 0xFF;
 
 		/*
@@ -466,12 +466,12 @@ int __devinit pci_scan_bridge(struct pci_bus *bus, struct pci_dev * dev, int max
 		if (pci_find_bus(pci_domain_nr(bus), busnr)) {
 			printk(KERN_INFO "PCI: Bus %04x:%02x already known\n",
 					pci_domain_nr(bus), busnr);
-			return max;
+			goto out;
 		}
 
 		child = pci_add_new_bus(bus, dev, busnr);
 		if (!child)
-			return max;
+			goto out;
 		child->primary = buses & 0xFF;
 		child->subordinate = (buses >> 16) & 0xFF;
 		child->bridge_ctl = bctl;
@@ -496,7 +496,7 @@ int __devinit pci_scan_bridge(struct pci_bus *bus, struct pci_dev * dev, int max
 				   bus ranges. */
 				pci_write_config_dword(dev, PCI_PRIMARY_BUS,
 						       buses & ~0xffffff);
-			return max;
+			goto out;
 		}
 
 		/* Clear errors */
@@ -505,7 +505,7 @@ int __devinit pci_scan_bridge(struct pci_bus *bus, struct pci_dev * dev, int max
 		/* Prevent assigning a bus number that already exists.
 		 * This can happen when a bridge is hot-plugged */
 		if (pci_find_bus(pci_domain_nr(bus), max+1))
-			return max;
+			goto out;
 		child = pci_add_new_bus(bus, dev, ++max);
 		buses = (buses & 0xff000000)
 		      | ((unsigned int)(child->primary)     <<  0)
@@ -581,8 +581,6 @@ int __devinit pci_scan_bridge(struct pci_bus *bus, struct pci_dev * dev, int max
 		pci_write_config_byte(dev, PCI_SUBORDINATE_BUS, max);
 	}
 
-	pci_write_config_word(dev, PCI_BRIDGE_CONTROL, bctl);
-
 	sprintf(child->name, (is_cardbus ? "PCI CardBus #%02x" : "PCI Bus #%02x"), child->number);
 
 	while (bus->parent) {
@@ -601,6 +599,9 @@ int __devinit pci_scan_bridge(struct pci_bus *bus, struct pci_dev * dev, int max
 		bus = bus->parent;
 	}
 
+out:
+	pci_write_config_word(dev, PCI_BRIDGE_CONTROL, bctl);
+
 	return max;
 }
 

commit e3ac86d8b3f5cee1afaa3e9e6984d0321149b948
Author: Kristen Accardi <kristen.c.accardi@intel.com>
Date:   Tue Jan 17 16:57:01 2006 -0800

    [PATCH] PCI: really fix parent's subordinate busnr
    
    After you find the maximum value of the subordinate buses below the child
    bus, you must fix the parent's subordinate bus number again, otherwise
    it may be too small.
    
    Signed-off-by: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index adfad4fd6a13..63751a283817 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -537,6 +537,11 @@ int __devinit pci_scan_bridge(struct pci_bus *bus, struct pci_dev * dev, int max
 			pci_fixup_parent_subordinate_busnr(child, max);
 			/* Now we can scan all subordinate buses... */
 			max = pci_scan_child_bus(child);
+			/*
+			 * now fix it up again since we have found
+			 * the real value of max.
+			 */
+			pci_fixup_parent_subordinate_busnr(child, max);
 		} else {
 			/*
 			 * For CardBus bridges, we leave 4 bus numbers

commit ac7dc65ac0b945270548414491efa9c4357417d9
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Tue Dec 13 18:09:16 2005 +1100

    [PATCH] PCI: Export pci_cfg_space_size
    
    The powerpc PCI code sets up the PCI tree without doing config space
    accesses in most cases, from the firmware tree. However, it still wants
    to call pci_cfg_space_size() under some conditions, thus it needs to
    be made non-static (though I don't see a point to export it to modules).
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 3c9834d80850..adfad4fd6a13 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -717,7 +717,7 @@ static void pci_release_dev(struct device *dev)
  * reading the dword at 0x100 which must either be 0 or a valid extended
  * capability header.
  */
-static int pci_cfg_space_size(struct pci_dev *dev)
+int pci_cfg_space_size(struct pci_dev *dev)
 {
 	int pos;
 	u32 status;

commit 498879417756effe6dc385ee04645a83d724fdef
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Thu Dec 8 16:53:12 2005 +0100

    [PATCH] PCI: use bus numbers sparsely, if necessary
    
    Add a warning if a child bus may be inaccessible because the
    parent bridge has wrong secondary or subordinate bus numbers.
    Note that this may or may not happen on "transparent" bridges,
    as can be seen in bug #5557.
    
    Also, if we do not fix up the assignment of bus numbers, try to
    make use of the bus number space available.
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 00ba6a03dca5..3c9834d80850 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -433,7 +433,7 @@ int __devinit pci_scan_bridge(struct pci_bus *bus, struct pci_dev * dev, int max
 {
 	struct pci_bus *child;
 	int is_cardbus = (dev->hdr_type == PCI_HEADER_TYPE_CARDBUS);
-	u32 buses, i;
+	u32 buses, i, j = 0;
 	u16 bctl;
 
 	pci_read_config_dword(dev, PCI_PRIMARY_BUS, &buses);
@@ -543,10 +543,29 @@ int __devinit pci_scan_bridge(struct pci_bus *bus, struct pci_dev * dev, int max
 			 * as cards with a PCI-to-PCI bridge can be
 			 * inserted later.
 			 */
-			for (i=0; i<CARDBUS_RESERVE_BUSNR; i++)
+			for (i=0; i<CARDBUS_RESERVE_BUSNR; i++) {
+				struct pci_bus *parent = bus;
 				if (pci_find_bus(pci_domain_nr(bus),
 							max+i+1))
 					break;
+				while (parent->parent) {
+					if ((!pcibios_assign_all_busses()) &&
+					    (parent->subordinate > max) &&
+					    (parent->subordinate <= max+i)) {
+						j = 1;
+					}
+					parent = parent->parent;
+				}
+				if (j) {
+					/*
+					 * Often, there are two cardbus bridges
+					 * -- try to leave one valid bus number
+					 * for each one.
+					 */
+					i /= 2;
+					break;
+				}
+			}
 			max += i;
 			pci_fixup_parent_subordinate_busnr(child, max);
 		}
@@ -561,6 +580,22 @@ int __devinit pci_scan_bridge(struct pci_bus *bus, struct pci_dev * dev, int max
 
 	sprintf(child->name, (is_cardbus ? "PCI CardBus #%02x" : "PCI Bus #%02x"), child->number);
 
+	while (bus->parent) {
+		if ((child->subordinate > bus->subordinate) ||
+		    (child->number > bus->subordinate) ||
+		    (child->number < bus->number) ||
+		    (child->subordinate < bus->number)) {
+			printk(KERN_WARNING "PCI: Bus #%02x (-#%02x) may be "
+			       "hidden behind%s bridge #%02x (-#%02x)%s\n",
+			       child->number, child->subordinate,
+			       bus->self->transparent ? " transparent" : " ",
+			       bus->number, bus->subordinate,
+			       pcibios_assign_all_busses() ? " " :
+			       " (try 'pci=assign-busses')");
+		}
+		bus = bus->parent;
+	}
+
 	return max;
 }
 

commit 9d265124d051c2cf6716639239609d83f736dcdb
Author: Daniel Yeisley <dan.yeisley@unisys.com>
Date:   Mon Dec 5 07:06:43 2005 -0500

    [PATCH] PCI Quirk: 1K I/O space granularity on Intel P64H2
    
    I've implemented a quirk to take advantage of the 1KB I/O space
    granularity option on the Intel P64H2 PCI Bridge.  I had to change
    probe.c because it sets the resource start and end to be aligned on 4k
    boundaries (after the quirk sets them to 1k boundaries).  I've tested
    this patch on a Unisys ES7000-600 both with and without the 1KB option
    enabled.  I also tested this on a 2 processor Dell box that doesn't have
    a P64H2 to make sure there were no negative affects there.
    
    Signed-off-by: Dan Yeisley <dan.yeisley@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 79be37a53397..00ba6a03dca5 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -264,8 +264,10 @@ void __devinit pci_read_bridge_bases(struct pci_bus *child)
 
 	if (base <= limit) {
 		res->flags = (io_base_lo & PCI_IO_RANGE_TYPE_MASK) | IORESOURCE_IO;
-		res->start = base;
-		res->end = limit + 0xfff;
+		if (!res->start)
+			res->start = base;
+		if (!res->end)
+			res->end = limit + 0xfff;
 	}
 
 	res = child->resource[1];

commit 3efd273b4d52f0d3ae5ce61b2161cb3752f360a0
Author: Kristen Accardi <kristen.c.accardi@intel.com>
Date:   Wed Nov 2 16:55:49 2005 -0800

    [PATCH] pci: call pci_read_irq for bridges
    
    Call pci_read_irq() for bridges too, so that the pin value
    is stored for bridges that require interrupts.
    
    Signed-off-by: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 2f82e63323f3..79be37a53397 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -625,6 +625,7 @@ static int pci_setup_device(struct pci_dev * dev)
 		/* The PCI-to-PCI bridge spec requires that subtractive
 		   decoding (i.e. transparent) bridge must have programming
 		   interface code of 0x01. */ 
+		pci_read_irq(dev);
 		dev->transparent = ((dev->class & 0xff) == 1);
 		pci_read_bases(dev, 2, PCI_ROM_ADDRESS1);
 		break;

commit ffeff788d6b10e342b4a887f28d339dfec1737f6
Author: Kristen Accardi <kristen.c.accardi@intel.com>
Date:   Wed Nov 2 16:24:32 2005 -0800

    [PATCH] pci: store PCI_INTERRUPT_PIN in pci_dev
    
    Store the value of the INTERRUPT_PIN in the pci_dev structure
    so that it can be retrieved later.
    
    Signed-off-by: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index fce2cb2112d8..2f82e63323f3 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -571,6 +571,7 @@ static void pci_read_irq(struct pci_dev *dev)
 	unsigned char irq;
 
 	pci_read_config_byte(dev, PCI_INTERRUPT_PIN, &irq);
+	dev->pin = irq;
 	if (irq)
 		pci_read_config_byte(dev, PCI_INTERRUPT_LINE, &irq);
 	dev->irq = irq;

commit 8f7020d36374dda9366fee1343f8eacfe8f5e641
Author: Randy Dunlap <rdunlap@xenotime.net>
Date:   Sun Oct 23 11:57:38 2005 -0700

    [PATCH] kernel-doc: PCI fixes
    
    PCI: add descriptions for missing function parameters.
    Eliminate all kernel-doc warnings here.
    
    Signed-off-by: Randy Dunlap <rdunlap@xenotime.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 005786416bb5..fce2cb2112d8 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -669,6 +669,7 @@ static void pci_release_dev(struct device *dev)
 
 /**
  * pci_cfg_space_size - get the configuration space size of the PCI device.
+ * @dev: PCI device
  *
  * Regular PCI devices have 256 bytes, but PCI-X 2 and PCI Express devices
  * have 4096 bytes.  Even if the device is capable, that doesn't mean we can

commit 12f44f46bc9c6dc79255e661b085797af395d8da
Author: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
Date:   Thu Sep 22 21:06:31 2005 -0700

    [PATCH] pci: fixup parent subordinate busnr
    
    I believe the change that broke things is introduction of
    pci_fixup_parent_subordinate_busnr().
    
    The patch here does two things:
    - hunk #1 should fix the problems you've seen when you boot without
      additional "pci" kernel options;
    - hunk #2 supposedly fixes boot with "pci=assign-busses" option which
      otherwise hangs Acer TM81xx machines as reported.
    
    Please try this with and without "pci=assign-busses". If it boots,
    I'd like to see 'lspci -vvx' for both cases.
    
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index c77d5b1bbff6..005786416bb5 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -402,6 +402,12 @@ static void pci_enable_crs(struct pci_dev *dev)
 static void __devinit pci_fixup_parent_subordinate_busnr(struct pci_bus *child, int max)
 {
 	struct pci_bus *parent = child->parent;
+
+	/* Attempts to fix that up are really dangerous unless
+	   we're going to re-assign all bus numbers. */
+	if (!pcibios_assign_all_busses())
+		return;
+
 	while (parent->parent && parent->subordinate < max) {
 		parent->subordinate = max;
 		pci_write_config_byte(parent->self, PCI_SUBORDINATE_BUS, max);
@@ -478,8 +484,18 @@ int __devinit pci_scan_bridge(struct pci_bus *bus, struct pci_dev * dev, int max
 		 * We need to assign a number to this bus which we always
 		 * do in the second pass.
 		 */
-		if (!pass)
+		if (!pass) {
+			if (pcibios_assign_all_busses())
+				/* Temporarily disable forwarding of the
+				   configuration cycles on all bridges in
+				   this bus segment to avoid possible
+				   conflicts in the second pass between two
+				   bridges programmed with overlapping
+				   bus ranges. */
+				pci_write_config_dword(dev, PCI_PRIMARY_BUS,
+						       buses & ~0xffffff);
 			return max;
+		}
 
 		/* Clear errors */
 		pci_write_config_word(dev, PCI_STATUS, 0xffff);

commit 3c6de9295d28a4fc868b2c09f23e318e3e7b9b6b
Author: Amos Waterland <apw@us.ibm.com>
Date:   Thu Sep 22 00:48:19 2005 -0700

    [PATCH] fix drivers/pci/probe.c warning
    
    This function expects an unsigned 32-bit type as its third argument:
    
     static u32 pci_size(u32 base, u32 maxbase, u32 mask)
    
    However, given these definitions:
    
     #define PCI_BASE_ADDRESS_MEM_MASK (~0x0fUL)
     #define PCI_ROM_ADDRESS_MASK (~0x7ffUL)
    
    these two calls in drivers/pci/probe.c are problematic for architectures
    for which a UL is not equivalent to a u32:
    
     sz = pci_size(l, sz, PCI_BASE_ADDRESS_MEM_MASK);
     sz = pci_size(l, sz, PCI_ROM_ADDRESS_MASK);
    
    Hence the below compile warning when building for ARCH=ppc64:
    
     drivers/pci/probe.c: In function `pci_read_bases':
     /.../probe.c:168: warning: large integer implicitly truncated to unsigned type
     /.../probe.c:218: warning: large integer implicitly truncated to unsigned type
    
    Here is a simple fix.
    
    Signed-off-by: Amos Waterland <apw@us.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 26a55d08b506..c77d5b1bbff6 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -165,7 +165,7 @@ static void pci_read_bases(struct pci_dev *dev, unsigned int howmany, int rom)
 		if (l == 0xffffffff)
 			l = 0;
 		if ((l & PCI_BASE_ADDRESS_SPACE) == PCI_BASE_ADDRESS_SPACE_MEMORY) {
-			sz = pci_size(l, sz, PCI_BASE_ADDRESS_MEM_MASK);
+			sz = pci_size(l, sz, (u32)PCI_BASE_ADDRESS_MEM_MASK);
 			if (!sz)
 				continue;
 			res->start = l & PCI_BASE_ADDRESS_MEM_MASK;
@@ -215,7 +215,7 @@ static void pci_read_bases(struct pci_dev *dev, unsigned int howmany, int rom)
 		if (l == 0xffffffff)
 			l = 0;
 		if (sz && sz != 0xffffffff) {
-			sz = pci_size(l, sz, PCI_ROM_ADDRESS_MASK);
+			sz = pci_size(l, sz, (u32)PCI_ROM_ADDRESS_MASK);
 			if (sz) {
 				res->flags = (l & IORESOURCE_ROM_ENABLE) |
 				  IORESOURCE_MEM | IORESOURCE_PREFETCH |

commit 4327edf6b8a7ac7dce144313947995538842d8fd
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Sat Sep 10 00:25:49 2005 -0700

    [PATCH] Subject: PATCH: fix numa caused compile warnings
    
    pcibus_to_cpumask expands into more than just an initialiser so gcc
    moans about code before variable declarations.
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 35caec13023a..26a55d08b506 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -72,11 +72,13 @@ void pci_remove_legacy_files(struct pci_bus *bus) { return; }
 /*
  * PCI Bus Class Devices
  */
-static ssize_t pci_bus_show_cpuaffinity(struct class_device *class_dev, char *buf)
+static ssize_t pci_bus_show_cpuaffinity(struct class_device *class_dev,
+					char *buf)
 {
-	cpumask_t cpumask = pcibus_to_cpumask(to_pci_bus(class_dev));
 	int ret;
+	cpumask_t cpumask;
 
+	cpumask = pcibus_to_cpumask(to_pci_bus(class_dev));
 	ret = cpumask_scnprintf(buf, PAGE_SIZE, cpumask);
 	if (ret < PAGE_SIZE)
 		buf[ret++] = '\n';

commit cdb9b9f730eac4f947a2c552806a3a550bf019ef
Author: Paul Mackerras <paulus@samba.org>
Date:   Tue Sep 6 09:31:03 2005 +1000

    [PATCH] PCI: Small rearrangement of PCI probing code
    
    This patch makes some small rearrangements of the PCI probing code in
    order to make it possible for arch code to set up the PCI tree
    without needing to duplicate code from the PCI layer unnecessarily.
    PPC64 will use this to set up the PCI tree from the Open Firmware
    device tree, which we need to do on logically-partitioned pSeries
    systems.
    
    Signed-off-by: Paul Mackerras <paulus@samba.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index b9c9b03919d4..35caec13023a 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -753,27 +753,19 @@ pci_scan_device(struct pci_bus *bus, int devfn)
 		kfree(dev);
 		return NULL;
 	}
-	device_initialize(&dev->dev);
-	dev->dev.release = pci_release_dev;
-	pci_dev_get(dev);
-
-	dev->dev.dma_mask = &dev->dma_mask;
-	dev->dev.coherent_dma_mask = 0xffffffffull;
 
 	return dev;
 }
 
-struct pci_dev * __devinit
-pci_scan_single_device(struct pci_bus *bus, int devfn)
+void __devinit pci_device_add(struct pci_dev *dev, struct pci_bus *bus)
 {
-	struct pci_dev *dev;
+	device_initialize(&dev->dev);
+	dev->dev.release = pci_release_dev;
+	pci_dev_get(dev);
 
-	dev = pci_scan_device(bus, devfn);
-	pci_scan_msi_device(dev);
+	dev->dev.dma_mask = &dev->dma_mask;
+	dev->dev.coherent_dma_mask = 0xffffffffull;
 
-	if (!dev)
-		return NULL;
-	
 	/* Fix up broken headers */
 	pci_fixup_device(pci_fixup_header, dev);
 
@@ -785,6 +777,19 @@ pci_scan_single_device(struct pci_bus *bus, int devfn)
 	spin_lock(&pci_bus_lock);
 	list_add_tail(&dev->bus_list, &bus->devices);
 	spin_unlock(&pci_bus_lock);
+}
+
+struct pci_dev * __devinit
+pci_scan_single_device(struct pci_bus *bus, int devfn)
+{
+	struct pci_dev *dev;
+
+	dev = pci_scan_device(bus, devfn);
+	if (!dev)
+		return NULL;
+
+	pci_device_add(dev, bus);
+	pci_scan_msi_device(dev);
 
 	return dev;
 }
@@ -881,7 +886,8 @@ unsigned int __devinit pci_do_scan_bus(struct pci_bus *bus)
 	return max;
 }
 
-struct pci_bus * __devinit pci_scan_bus_parented(struct device *parent, int bus, struct pci_ops *ops, void *sysdata)
+struct pci_bus * __devinit pci_create_bus(struct device *parent,
+		int bus, struct pci_ops *ops, void *sysdata)
 {
 	int error;
 	struct pci_bus *b;
@@ -938,8 +944,6 @@ struct pci_bus * __devinit pci_scan_bus_parented(struct device *parent, int bus,
 	b->resource[0] = &ioport_resource;
 	b->resource[1] = &iomem_resource;
 
-	b->subordinate = pci_scan_child_bus(b);
-
 	return b;
 
 sys_create_link_err:
@@ -957,6 +961,18 @@ struct pci_bus * __devinit pci_scan_bus_parented(struct device *parent, int bus,
 	kfree(b);
 	return NULL;
 }
+EXPORT_SYMBOL_GPL(pci_create_bus);
+
+struct pci_bus * __devinit pci_scan_bus_parented(struct device *parent,
+		int bus, struct pci_ops *ops, void *sysdata)
+{
+	struct pci_bus *b;
+
+	b = pci_create_bus(parent, bus, ops, sysdata);
+	if (b)
+		b->subordinate = pci_scan_child_bus(b);
+	return b;
+}
 EXPORT_SYMBOL(pci_scan_bus_parented);
 
 #ifdef CONFIG_HOTPLUG

commit 3fe9d19f9e86a55679f5f2b38ec0a43a1a510cee
Author: Daniel Ritz <daniel.ritz@gmx.ch>
Date:   Wed Aug 17 15:32:19 2005 -0700

    [PATCH] PCI: Support PCM PM CAP version 3
    
    - support PCI PM CAP version 3 (as defined in PCI PM Interface Spec v1.2)
    
    - pci/probe.c sets the PM state initially to 4 which is D3cold.  add a
      PCI_UNKNOWN
    
    - minor cleanups
    
    Signed-off-by: Daniel Ritz <daniel.ritz@gmx.ch>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 4be1b887ab62..b9c9b03919d4 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -584,7 +584,7 @@ static int pci_setup_device(struct pci_dev * dev)
 		 dev->vendor, dev->device, class, dev->hdr_type);
 
 	/* "Unknown power state" */
-	dev->current_state = 4;
+	dev->current_state = PCI_UNKNOWN;
 
 	/* Early fixups, before probing the BARs */
 	pci_fixup_device(pci_fixup_early, dev);

commit 982245f01734e9d5a3ab98b2b2e9761ae7719094
Author: Adrian Bunk <bunk@stusta.de>
Date:   Sun Jul 17 04:22:20 2005 +0200

    [PATCH] PCI: remove CONFIG_PCI_NAMES
    
    This patch removes CONFIG_PCI_NAMES.
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 93e8a878ea95..4be1b887ab62 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -757,8 +757,6 @@ pci_scan_device(struct pci_bus *bus, int devfn)
 	dev->dev.release = pci_release_dev;
 	pci_dev_get(dev);
 
-	pci_name_device(dev);
-
 	dev->dev.dma_mask = &dev->dma_mask;
 	dev->dev.coherent_dma_mask = 0xffffffffull;
 

commit 10f4338ca8534823bc6c843edbbe42fd4e73d258
Author: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
Date:   Fri Jul 29 12:16:22 2005 -0700

    [PATCH] PCI: remove PCI_BRIDGE_CTL_VGA handling from setup-bus.c
    
    The setup-bus code doesn't work correctly for configurations
    with more than one display adapter in the same PCI domain.
    This stuff actually is a leftover of an early 2.4 PCI setup code
    and apparently it stopped working after some "bridge_ctl" changes.
    So the best thing we can do is just to remove it and rely on the fact
    that any firmware *has* to configure VGA port forwarding for the boot
    display device properly.
    
    But then we need to ensure that the bus->bridge_ctl will always
    contain valid information collected at the probe time, therefore
    the following change in pci_scan_bridge() is needed.
    
    Signed-off-by: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index df3bdae2040f..93e8a878ea95 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -507,7 +507,7 @@ int __devinit pci_scan_bridge(struct pci_bus *bus, struct pci_dev * dev, int max
 		pci_write_config_dword(dev, PCI_PRIMARY_BUS, buses);
 
 		if (!is_cardbus) {
-			child->bridge_ctl = PCI_BRIDGE_CTL_NO_ISA;
+			child->bridge_ctl = bctl | PCI_BRIDGE_CTL_NO_ISA;
 			/*
 			 * Adjust subordinate busnr in parent buses.
 			 * We do this before scanning for children because

commit 90b54929b626c80056262d9d99b3f48522e404d0
Author: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
Date:   Tue Jun 7 04:07:02 2005 +0400

    [PATCH] PCI: handle subtractive decode pci-pci bridge better
    
    With the number of PCI bus resources increased to 8, we can
    handle the subtractive decode PCI-PCI bridge like a normal
    bridge, taking into account standard PCI-PCI bridge windows
    (resources 0-2). This helps to avoid problems with peer-to-peer DMA
    behind such bridges, poor performance for MMIO ranges outside bridge
    windows and prefetchable vs. non-prefetchable memory issues.
    
    To reflect the fact that such bridges do forward all addresses to
    the secondary bus (transparency), remaining bus resources 3-7 are
    linked to resources 0-4 of the primary bus. These resources will be
    used as fallback by resource management code if allocation from
    standard bridge windows fails for some reason.
    
    Signed-off-by: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
    Acked-by: Dominik Brodowski <linux@dominikbrodowski.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 9392ff3fb803..df3bdae2040f 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -239,9 +239,8 @@ void __devinit pci_read_bridge_bases(struct pci_bus *child)
 
 	if (dev->transparent) {
 		printk(KERN_INFO "PCI: Transparent bridge - %s\n", pci_name(dev));
-		for(i = 0; i < PCI_BUS_NUM_RESOURCES; i++)
-			child->resource[i] = child->parent->resource[i];
-		return;
+		for(i = 3; i < PCI_BUS_NUM_RESOURCES; i++)
+			child->resource[i] = child->parent->resource[i - 3];
 	}
 
 	for(i=0; i<3; i++)

commit 26f674ae0e37190bf61c988e52911e4372fdb5f5
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Jun 2 15:41:48 2005 -0700

    [PATCH] PCI: Fix up PCI routing in parent bridge
    
    When the cardbus bridge is behind another bridge change the routing
    in the parent bridge for new cards.  This fixes Cardbus on various AMD64
    laptops.
    
    Signed-off-by: Andi Kleen <ak@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 6a0a82f0508b..9392ff3fb803 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -398,6 +398,16 @@ static void pci_enable_crs(struct pci_dev *dev)
 	pci_write_config_word(dev, rpcap + PCI_EXP_RTCTL, rpctl);
 }
 
+static void __devinit pci_fixup_parent_subordinate_busnr(struct pci_bus *child, int max)
+{
+	struct pci_bus *parent = child->parent;
+	while (parent->parent && parent->subordinate < max) {
+		parent->subordinate = max;
+		pci_write_config_byte(parent->self, PCI_SUBORDINATE_BUS, max);
+		parent = parent->parent;
+	}
+}
+
 unsigned int __devinit pci_scan_child_bus(struct pci_bus *bus);
 
 /*
@@ -499,7 +509,13 @@ int __devinit pci_scan_bridge(struct pci_bus *bus, struct pci_dev * dev, int max
 
 		if (!is_cardbus) {
 			child->bridge_ctl = PCI_BRIDGE_CTL_NO_ISA;
-
+			/*
+			 * Adjust subordinate busnr in parent buses.
+			 * We do this before scanning for children because
+			 * some devices may not be detected if the bios
+			 * was lazy.
+			 */
+			pci_fixup_parent_subordinate_busnr(child, max);
 			/* Now we can scan all subordinate buses... */
 			max = pci_scan_child_bus(child);
 		} else {
@@ -513,6 +529,7 @@ int __devinit pci_scan_bridge(struct pci_bus *bus, struct pci_dev * dev, int max
 							max+i+1))
 					break;
 			max += i;
+			pci_fixup_parent_subordinate_busnr(child, max);
 		}
 		/*
 		 * Set the subordinate bus number to its real value.

commit 6ef6f0e33c4645fc8d23201ad5a6a289b4303cbb
Author: Rajesh Shah <rajesh.shah@intel.com>
Date:   Thu Apr 28 00:25:49 2005 -0700

    [PATCH] acpi bridge hotadd: Link newly created pci child bus to its parent on creation
    
    When a pci child bus is created, add it to the parent's children list
    immediately rather than waiting till pci_bus_add_devices().  For hot-plug
    bridges/devices, pci_bus_add_devices() may be called much later, after they
    have been properly configured.  In the meantime, this allows us to use the
    normal pci bus search functions for the hot-plug bridges/buses.
    
    Signed-off-by: Rajesh Shah <rajesh.shah@intel.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 7d171f83257f..6a0a82f0508b 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -450,7 +450,7 @@ int __devinit pci_scan_bridge(struct pci_bus *bus, struct pci_dev * dev, int max
 			return max;
 		}
 
-		child = pci_alloc_child_bus(bus, dev, busnr);
+		child = pci_add_new_bus(bus, dev, busnr);
 		if (!child)
 			return max;
 		child->primary = buses & 0xFF;
@@ -477,7 +477,7 @@ int __devinit pci_scan_bridge(struct pci_bus *bus, struct pci_dev * dev, int max
 		 * This can happen when a bridge is hot-plugged */
 		if (pci_find_bus(pci_domain_nr(bus), max+1))
 			return max;
-		child = pci_alloc_child_bus(bus, dev, ++max);
+		child = pci_add_new_bus(bus, dev, ++max);
 		buses = (buses & 0xff000000)
 		      | ((unsigned int)(child->primary)     <<  0)
 		      | ((unsigned int)(child->secondary)   <<  8)

commit e4ea9bb7e9f177e03a917b1f1213de0315f819ee
Author: Rajesh Shah <rajesh.shah@intel.com>
Date:   Thu Apr 28 00:25:48 2005 -0700

    [PATCH] acpi bridge hotadd: Take the PCI lock when modifying pci bus or device lists
    
    With root bridge and pci bridge hot-plug, new buses and devices can be added
    or removed at run time.  Protect the pci bus and device lists with the pci
    lock when doing so.
    
    Signed-off-by: Rajesh Shah <rajesh.shah@intel.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 6186f4d7b119..7d171f83257f 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -374,8 +374,11 @@ struct pci_bus * __devinit pci_add_new_bus(struct pci_bus *parent, struct pci_de
 	struct pci_bus *child;
 
 	child = pci_alloc_child_bus(parent, dev, busnr);
-	if (child)
+	if (child) {
+		spin_lock(&pci_bus_lock);
 		list_add_tail(&child->node, &parent->children);
+		spin_unlock(&pci_bus_lock);
+	}
 	return child;
 }
 
@@ -765,7 +768,9 @@ pci_scan_single_device(struct pci_bus *bus, int devfn)
 	 * and the bus list for fixup functions, etc.
 	 */
 	INIT_LIST_HEAD(&dev->global_list);
+	spin_lock(&pci_bus_lock);
 	list_add_tail(&dev->bus_list, &bus->devices);
+	spin_unlock(&pci_bus_lock);
 
 	return dev;
 }
@@ -886,7 +891,9 @@ struct pci_bus * __devinit pci_scan_bus_parented(struct device *parent, int bus,
 		pr_debug("PCI: Bus %04x:%02x already known\n", pci_domain_nr(b), bus);
 		goto err_out;
 	}
+	spin_lock(&pci_bus_lock);
 	list_add_tail(&b->node, &pci_root_buses);
+	spin_unlock(&pci_bus_lock);
 
 	memset(dev, 0, sizeof(*dev));
 	dev->parent = parent;
@@ -928,7 +935,9 @@ struct pci_bus * __devinit pci_scan_bus_parented(struct device *parent, int bus,
 class_dev_reg_err:
 	device_unregister(dev);
 dev_reg_err:
+	spin_lock(&pci_bus_lock);
 	list_del(&b->node);
+	spin_unlock(&pci_bus_lock);
 err_out:
 	kfree(dev);
 	kfree(b);

commit cc57450f5c044270d2cf1dd437c1850422262109
Author: Rajesh Shah <rajesh.shah@intel.com>
Date:   Thu Apr 28 00:25:47 2005 -0700

    [PATCH] acpi bridge hotadd: Prevent duplicate bus numbers when scanning PCI bridge
    
    When hot-plugging a root bridge, as we try to assign bus numbers we may find
    that the hotplugged hieratchy has more PCI to PCI bridges (i.e.  bus
    requirements) than available.  Make sure we don't step over an existing bus
    when that happens.
    
    Signed-off-by: Rajesh Shah <rajesh.shah@intel.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 3dc00f0ca8a0..6186f4d7b119 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -411,7 +411,7 @@ int __devinit pci_scan_bridge(struct pci_bus *bus, struct pci_dev * dev, int max
 {
 	struct pci_bus *child;
 	int is_cardbus = (dev->hdr_type == PCI_HEADER_TYPE_CARDBUS);
-	u32 buses;
+	u32 buses, i;
 	u16 bctl;
 
 	pci_read_config_dword(dev, PCI_PRIMARY_BUS, &buses);
@@ -470,6 +470,10 @@ int __devinit pci_scan_bridge(struct pci_bus *bus, struct pci_dev * dev, int max
 		/* Clear errors */
 		pci_write_config_word(dev, PCI_STATUS, 0xffff);
 
+		/* Prevent assigning a bus number that already exists.
+		 * This can happen when a bridge is hot-plugged */
+		if (pci_find_bus(pci_domain_nr(bus), max+1))
+			return max;
 		child = pci_alloc_child_bus(bus, dev, ++max);
 		buses = (buses & 0xff000000)
 		      | ((unsigned int)(child->primary)     <<  0)
@@ -501,7 +505,11 @@ int __devinit pci_scan_bridge(struct pci_bus *bus, struct pci_dev * dev, int max
 			 * as cards with a PCI-to-PCI bridge can be
 			 * inserted later.
 			 */
-			max += CARDBUS_RESERVE_BUSNR;
+			for (i=0; i<CARDBUS_RESERVE_BUSNR; i++)
+				if (pci_find_bus(pci_domain_nr(bus),
+							max+i+1))
+					break;
+			max += i;
 		}
 		/*
 		 * Set the subordinate bus number to its real value.

commit c431ada45d65b305a6aab4557067e564b23ce5a5
Author: Rajesh Shah <rajesh.shah@intel.com>
Date:   Thu Apr 28 00:25:45 2005 -0700

    [PATCH] acpi bridge hotadd: ACPI based root bridge hot-add
    
    When you hot-plug a (root) bridge hierarchy, it may have p2p bridges and
    devices attached to it that have not been configured by firmware.  In this
    case, we need to configure the devices before starting them.  This patch
    separates device start from device scan so that we can introduce the
    configuration step in the middle.
    
    I kept the existing semantics for pci_scan_bus() since there are a huge number
    of callers to that function.
    
    Also, I have no way of testing the changes I made to the parisc files, so this
    needs review by those folks.  Sorry for the massive cross-post, this touches
    files in many different places.
    
    Signed-off-by: Rajesh Shah <rajesh.shah@intel.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index fd48b201eb53..3dc00f0ca8a0 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -911,8 +911,6 @@ struct pci_bus * __devinit pci_scan_bus_parented(struct device *parent, int bus,
 
 	b->subordinate = pci_scan_child_bus(b);
 
-	pci_bus_add_devices(b);
-
 	return b;
 
 sys_create_link_err:

commit f797f9cc5485b50c35c106b462e1bc432ec37f90
Author: Olof Johansson <olof@lixom.net>
Date:   Mon Jun 13 15:52:27 2005 -0700

    [PATCH] Fix PCI BAR size interpretation on 64-bit arches
    
    On 64-bit machines, PCI_BASE_ADDRESS_MEM_MASK and other mask constants
    passed to pci_size() are 64-bit (for example ~0x0fUL).  However, pci_size
    does comparisons between the u32 arguments and the mask, which will fail
    even though any result from pci_size is still just 32-bit.
    
    Changing the mask argument to u32 seems the obvious thing to do, since all
    arithmetic in the function is 32-bit and having a larger mask makes no
    sense.
    
    This triggered on a PPC64 system here where an adapter (VGA, as it
    happened) had a memory region base of 0xfe000000 and a sz of the same,
    matching the if (max == maxbase ...) test at the bottom of pci_size but
    failing the mask comparison.  Quite a corner case which I guess explains
    why we haven't seen it until now.
    
    Signed-off-by: Olof Johansson <olof@lixom.net>
    Acked-by: Greg KH <greg@kroah.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index b7ae87823c69..fd48b201eb53 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -125,7 +125,7 @@ static inline unsigned int pci_calc_resource_flags(unsigned int flags)
 /*
  * Find the extent of a PCI decode..
  */
-static u32 pci_size(u32 base, u32 maxbase, unsigned long mask)
+static u32 pci_size(u32 base, u32 maxbase, u32 mask)
 {
 	u32 size = mask & maxbase;	/* Find the significant bits */
 	if (!size)

commit bc56b9e01190b9f1ad6b7c5c694b61bfe34c7aa5
Author: Greg KH <gregkh@suse.de>
Date:   Fri Apr 8 14:53:31 2005 +0900

    [PATCH] PCI: Clean up a lot of sparse "Should it be static?" warnings.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 6f0edadd132c..b7ae87823c69 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -9,6 +9,7 @@
 #include <linux/slab.h>
 #include <linux/module.h>
 #include <linux/cpumask.h>
+#include "pci.h"
 
 #define CARDBUS_LATENCY_TIMER	176	/* secondary latency timer */
 #define CARDBUS_RESERVE_BUSNR	3

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
new file mode 100644
index 000000000000..6f0edadd132c
--- /dev/null
+++ b/drivers/pci/probe.c
@@ -0,0 +1,939 @@
+/*
+ * probe.c - PCI detection and setup code
+ */
+
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/cpumask.h>
+
+#define CARDBUS_LATENCY_TIMER	176	/* secondary latency timer */
+#define CARDBUS_RESERVE_BUSNR	3
+#define PCI_CFG_SPACE_SIZE	256
+#define PCI_CFG_SPACE_EXP_SIZE	4096
+
+/* Ugh.  Need to stop exporting this to modules. */
+LIST_HEAD(pci_root_buses);
+EXPORT_SYMBOL(pci_root_buses);
+
+LIST_HEAD(pci_devices);
+
+#ifdef HAVE_PCI_LEGACY
+/**
+ * pci_create_legacy_files - create legacy I/O port and memory files
+ * @b: bus to create files under
+ *
+ * Some platforms allow access to legacy I/O port and ISA memory space on
+ * a per-bus basis.  This routine creates the files and ties them into
+ * their associated read, write and mmap files from pci-sysfs.c
+ */
+static void pci_create_legacy_files(struct pci_bus *b)
+{
+	b->legacy_io = kmalloc(sizeof(struct bin_attribute) * 2,
+			       GFP_ATOMIC);
+	if (b->legacy_io) {
+		memset(b->legacy_io, 0, sizeof(struct bin_attribute) * 2);
+		b->legacy_io->attr.name = "legacy_io";
+		b->legacy_io->size = 0xffff;
+		b->legacy_io->attr.mode = S_IRUSR | S_IWUSR;
+		b->legacy_io->attr.owner = THIS_MODULE;
+		b->legacy_io->read = pci_read_legacy_io;
+		b->legacy_io->write = pci_write_legacy_io;
+		class_device_create_bin_file(&b->class_dev, b->legacy_io);
+
+		/* Allocated above after the legacy_io struct */
+		b->legacy_mem = b->legacy_io + 1;
+		b->legacy_mem->attr.name = "legacy_mem";
+		b->legacy_mem->size = 1024*1024;
+		b->legacy_mem->attr.mode = S_IRUSR | S_IWUSR;
+		b->legacy_mem->attr.owner = THIS_MODULE;
+		b->legacy_mem->mmap = pci_mmap_legacy_mem;
+		class_device_create_bin_file(&b->class_dev, b->legacy_mem);
+	}
+}
+
+void pci_remove_legacy_files(struct pci_bus *b)
+{
+	if (b->legacy_io) {
+		class_device_remove_bin_file(&b->class_dev, b->legacy_io);
+		class_device_remove_bin_file(&b->class_dev, b->legacy_mem);
+		kfree(b->legacy_io); /* both are allocated here */
+	}
+}
+#else /* !HAVE_PCI_LEGACY */
+static inline void pci_create_legacy_files(struct pci_bus *bus) { return; }
+void pci_remove_legacy_files(struct pci_bus *bus) { return; }
+#endif /* HAVE_PCI_LEGACY */
+
+/*
+ * PCI Bus Class Devices
+ */
+static ssize_t pci_bus_show_cpuaffinity(struct class_device *class_dev, char *buf)
+{
+	cpumask_t cpumask = pcibus_to_cpumask(to_pci_bus(class_dev));
+	int ret;
+
+	ret = cpumask_scnprintf(buf, PAGE_SIZE, cpumask);
+	if (ret < PAGE_SIZE)
+		buf[ret++] = '\n';
+	return ret;
+}
+CLASS_DEVICE_ATTR(cpuaffinity, S_IRUGO, pci_bus_show_cpuaffinity, NULL);
+
+/*
+ * PCI Bus Class
+ */
+static void release_pcibus_dev(struct class_device *class_dev)
+{
+	struct pci_bus *pci_bus = to_pci_bus(class_dev);
+
+	if (pci_bus->bridge)
+		put_device(pci_bus->bridge);
+	kfree(pci_bus);
+}
+
+static struct class pcibus_class = {
+	.name		= "pci_bus",
+	.release	= &release_pcibus_dev,
+};
+
+static int __init pcibus_class_init(void)
+{
+	return class_register(&pcibus_class);
+}
+postcore_initcall(pcibus_class_init);
+
+/*
+ * Translate the low bits of the PCI base
+ * to the resource type
+ */
+static inline unsigned int pci_calc_resource_flags(unsigned int flags)
+{
+	if (flags & PCI_BASE_ADDRESS_SPACE_IO)
+		return IORESOURCE_IO;
+
+	if (flags & PCI_BASE_ADDRESS_MEM_PREFETCH)
+		return IORESOURCE_MEM | IORESOURCE_PREFETCH;
+
+	return IORESOURCE_MEM;
+}
+
+/*
+ * Find the extent of a PCI decode..
+ */
+static u32 pci_size(u32 base, u32 maxbase, unsigned long mask)
+{
+	u32 size = mask & maxbase;	/* Find the significant bits */
+	if (!size)
+		return 0;
+
+	/* Get the lowest of them to find the decode size, and
+	   from that the extent.  */
+	size = (size & ~(size-1)) - 1;
+
+	/* base == maxbase can be valid only if the BAR has
+	   already been programmed with all 1s.  */
+	if (base == maxbase && ((base | size) & mask) != mask)
+		return 0;
+
+	return size;
+}
+
+static void pci_read_bases(struct pci_dev *dev, unsigned int howmany, int rom)
+{
+	unsigned int pos, reg, next;
+	u32 l, sz;
+	struct resource *res;
+
+	for(pos=0; pos<howmany; pos = next) {
+		next = pos+1;
+		res = &dev->resource[pos];
+		res->name = pci_name(dev);
+		reg = PCI_BASE_ADDRESS_0 + (pos << 2);
+		pci_read_config_dword(dev, reg, &l);
+		pci_write_config_dword(dev, reg, ~0);
+		pci_read_config_dword(dev, reg, &sz);
+		pci_write_config_dword(dev, reg, l);
+		if (!sz || sz == 0xffffffff)
+			continue;
+		if (l == 0xffffffff)
+			l = 0;
+		if ((l & PCI_BASE_ADDRESS_SPACE) == PCI_BASE_ADDRESS_SPACE_MEMORY) {
+			sz = pci_size(l, sz, PCI_BASE_ADDRESS_MEM_MASK);
+			if (!sz)
+				continue;
+			res->start = l & PCI_BASE_ADDRESS_MEM_MASK;
+			res->flags |= l & ~PCI_BASE_ADDRESS_MEM_MASK;
+		} else {
+			sz = pci_size(l, sz, PCI_BASE_ADDRESS_IO_MASK & 0xffff);
+			if (!sz)
+				continue;
+			res->start = l & PCI_BASE_ADDRESS_IO_MASK;
+			res->flags |= l & ~PCI_BASE_ADDRESS_IO_MASK;
+		}
+		res->end = res->start + (unsigned long) sz;
+		res->flags |= pci_calc_resource_flags(l);
+		if ((l & (PCI_BASE_ADDRESS_SPACE | PCI_BASE_ADDRESS_MEM_TYPE_MASK))
+		    == (PCI_BASE_ADDRESS_SPACE_MEMORY | PCI_BASE_ADDRESS_MEM_TYPE_64)) {
+			pci_read_config_dword(dev, reg+4, &l);
+			next++;
+#if BITS_PER_LONG == 64
+			res->start |= ((unsigned long) l) << 32;
+			res->end = res->start + sz;
+			pci_write_config_dword(dev, reg+4, ~0);
+			pci_read_config_dword(dev, reg+4, &sz);
+			pci_write_config_dword(dev, reg+4, l);
+			sz = pci_size(l, sz, 0xffffffff);
+			if (sz) {
+				/* This BAR needs > 4GB?  Wow. */
+				res->end |= (unsigned long)sz<<32;
+			}
+#else
+			if (l) {
+				printk(KERN_ERR "PCI: Unable to handle 64-bit address for device %s\n", pci_name(dev));
+				res->start = 0;
+				res->flags = 0;
+				continue;
+			}
+#endif
+		}
+	}
+	if (rom) {
+		dev->rom_base_reg = rom;
+		res = &dev->resource[PCI_ROM_RESOURCE];
+		res->name = pci_name(dev);
+		pci_read_config_dword(dev, rom, &l);
+		pci_write_config_dword(dev, rom, ~PCI_ROM_ADDRESS_ENABLE);
+		pci_read_config_dword(dev, rom, &sz);
+		pci_write_config_dword(dev, rom, l);
+		if (l == 0xffffffff)
+			l = 0;
+		if (sz && sz != 0xffffffff) {
+			sz = pci_size(l, sz, PCI_ROM_ADDRESS_MASK);
+			if (sz) {
+				res->flags = (l & IORESOURCE_ROM_ENABLE) |
+				  IORESOURCE_MEM | IORESOURCE_PREFETCH |
+				  IORESOURCE_READONLY | IORESOURCE_CACHEABLE;
+				res->start = l & PCI_ROM_ADDRESS_MASK;
+				res->end = res->start + (unsigned long) sz;
+			}
+		}
+	}
+}
+
+void __devinit pci_read_bridge_bases(struct pci_bus *child)
+{
+	struct pci_dev *dev = child->self;
+	u8 io_base_lo, io_limit_lo;
+	u16 mem_base_lo, mem_limit_lo;
+	unsigned long base, limit;
+	struct resource *res;
+	int i;
+
+	if (!dev)		/* It's a host bus, nothing to read */
+		return;
+
+	if (dev->transparent) {
+		printk(KERN_INFO "PCI: Transparent bridge - %s\n", pci_name(dev));
+		for(i = 0; i < PCI_BUS_NUM_RESOURCES; i++)
+			child->resource[i] = child->parent->resource[i];
+		return;
+	}
+
+	for(i=0; i<3; i++)
+		child->resource[i] = &dev->resource[PCI_BRIDGE_RESOURCES+i];
+
+	res = child->resource[0];
+	pci_read_config_byte(dev, PCI_IO_BASE, &io_base_lo);
+	pci_read_config_byte(dev, PCI_IO_LIMIT, &io_limit_lo);
+	base = (io_base_lo & PCI_IO_RANGE_MASK) << 8;
+	limit = (io_limit_lo & PCI_IO_RANGE_MASK) << 8;
+
+	if ((io_base_lo & PCI_IO_RANGE_TYPE_MASK) == PCI_IO_RANGE_TYPE_32) {
+		u16 io_base_hi, io_limit_hi;
+		pci_read_config_word(dev, PCI_IO_BASE_UPPER16, &io_base_hi);
+		pci_read_config_word(dev, PCI_IO_LIMIT_UPPER16, &io_limit_hi);
+		base |= (io_base_hi << 16);
+		limit |= (io_limit_hi << 16);
+	}
+
+	if (base <= limit) {
+		res->flags = (io_base_lo & PCI_IO_RANGE_TYPE_MASK) | IORESOURCE_IO;
+		res->start = base;
+		res->end = limit + 0xfff;
+	}
+
+	res = child->resource[1];
+	pci_read_config_word(dev, PCI_MEMORY_BASE, &mem_base_lo);
+	pci_read_config_word(dev, PCI_MEMORY_LIMIT, &mem_limit_lo);
+	base = (mem_base_lo & PCI_MEMORY_RANGE_MASK) << 16;
+	limit = (mem_limit_lo & PCI_MEMORY_RANGE_MASK) << 16;
+	if (base <= limit) {
+		res->flags = (mem_base_lo & PCI_MEMORY_RANGE_TYPE_MASK) | IORESOURCE_MEM;
+		res->start = base;
+		res->end = limit + 0xfffff;
+	}
+
+	res = child->resource[2];
+	pci_read_config_word(dev, PCI_PREF_MEMORY_BASE, &mem_base_lo);
+	pci_read_config_word(dev, PCI_PREF_MEMORY_LIMIT, &mem_limit_lo);
+	base = (mem_base_lo & PCI_PREF_RANGE_MASK) << 16;
+	limit = (mem_limit_lo & PCI_PREF_RANGE_MASK) << 16;
+
+	if ((mem_base_lo & PCI_PREF_RANGE_TYPE_MASK) == PCI_PREF_RANGE_TYPE_64) {
+		u32 mem_base_hi, mem_limit_hi;
+		pci_read_config_dword(dev, PCI_PREF_BASE_UPPER32, &mem_base_hi);
+		pci_read_config_dword(dev, PCI_PREF_LIMIT_UPPER32, &mem_limit_hi);
+
+		/*
+		 * Some bridges set the base > limit by default, and some
+		 * (broken) BIOSes do not initialize them.  If we find
+		 * this, just assume they are not being used.
+		 */
+		if (mem_base_hi <= mem_limit_hi) {
+#if BITS_PER_LONG == 64
+			base |= ((long) mem_base_hi) << 32;
+			limit |= ((long) mem_limit_hi) << 32;
+#else
+			if (mem_base_hi || mem_limit_hi) {
+				printk(KERN_ERR "PCI: Unable to handle 64-bit address space for bridge %s\n", pci_name(dev));
+				return;
+			}
+#endif
+		}
+	}
+	if (base <= limit) {
+		res->flags = (mem_base_lo & PCI_MEMORY_RANGE_TYPE_MASK) | IORESOURCE_MEM | IORESOURCE_PREFETCH;
+		res->start = base;
+		res->end = limit + 0xfffff;
+	}
+}
+
+static struct pci_bus * __devinit pci_alloc_bus(void)
+{
+	struct pci_bus *b;
+
+	b = kmalloc(sizeof(*b), GFP_KERNEL);
+	if (b) {
+		memset(b, 0, sizeof(*b));
+		INIT_LIST_HEAD(&b->node);
+		INIT_LIST_HEAD(&b->children);
+		INIT_LIST_HEAD(&b->devices);
+	}
+	return b;
+}
+
+static struct pci_bus * __devinit
+pci_alloc_child_bus(struct pci_bus *parent, struct pci_dev *bridge, int busnr)
+{
+	struct pci_bus *child;
+	int i;
+
+	/*
+	 * Allocate a new bus, and inherit stuff from the parent..
+	 */
+	child = pci_alloc_bus();
+	if (!child)
+		return NULL;
+
+	child->self = bridge;
+	child->parent = parent;
+	child->ops = parent->ops;
+	child->sysdata = parent->sysdata;
+	child->bridge = get_device(&bridge->dev);
+
+	child->class_dev.class = &pcibus_class;
+	sprintf(child->class_dev.class_id, "%04x:%02x", pci_domain_nr(child), busnr);
+	class_device_register(&child->class_dev);
+	class_device_create_file(&child->class_dev, &class_device_attr_cpuaffinity);
+
+	/*
+	 * Set up the primary, secondary and subordinate
+	 * bus numbers.
+	 */
+	child->number = child->secondary = busnr;
+	child->primary = parent->secondary;
+	child->subordinate = 0xff;
+
+	/* Set up default resource pointers and names.. */
+	for (i = 0; i < 4; i++) {
+		child->resource[i] = &bridge->resource[PCI_BRIDGE_RESOURCES+i];
+		child->resource[i]->name = child->name;
+	}
+	bridge->subordinate = child;
+
+	return child;
+}
+
+struct pci_bus * __devinit pci_add_new_bus(struct pci_bus *parent, struct pci_dev *dev, int busnr)
+{
+	struct pci_bus *child;
+
+	child = pci_alloc_child_bus(parent, dev, busnr);
+	if (child)
+		list_add_tail(&child->node, &parent->children);
+	return child;
+}
+
+static void pci_enable_crs(struct pci_dev *dev)
+{
+	u16 cap, rpctl;
+	int rpcap = pci_find_capability(dev, PCI_CAP_ID_EXP);
+	if (!rpcap)
+		return;
+
+	pci_read_config_word(dev, rpcap + PCI_CAP_FLAGS, &cap);
+	if (((cap & PCI_EXP_FLAGS_TYPE) >> 4) != PCI_EXP_TYPE_ROOT_PORT)
+		return;
+
+	pci_read_config_word(dev, rpcap + PCI_EXP_RTCTL, &rpctl);
+	rpctl |= PCI_EXP_RTCTL_CRSSVE;
+	pci_write_config_word(dev, rpcap + PCI_EXP_RTCTL, rpctl);
+}
+
+unsigned int __devinit pci_scan_child_bus(struct pci_bus *bus);
+
+/*
+ * If it's a bridge, configure it and scan the bus behind it.
+ * For CardBus bridges, we don't scan behind as the devices will
+ * be handled by the bridge driver itself.
+ *
+ * We need to process bridges in two passes -- first we scan those
+ * already configured by the BIOS and after we are done with all of
+ * them, we proceed to assigning numbers to the remaining buses in
+ * order to avoid overlaps between old and new bus numbers.
+ */
+int __devinit pci_scan_bridge(struct pci_bus *bus, struct pci_dev * dev, int max, int pass)
+{
+	struct pci_bus *child;
+	int is_cardbus = (dev->hdr_type == PCI_HEADER_TYPE_CARDBUS);
+	u32 buses;
+	u16 bctl;
+
+	pci_read_config_dword(dev, PCI_PRIMARY_BUS, &buses);
+
+	pr_debug("PCI: Scanning behind PCI bridge %s, config %06x, pass %d\n",
+		 pci_name(dev), buses & 0xffffff, pass);
+
+	/* Disable MasterAbortMode during probing to avoid reporting
+	   of bus errors (in some architectures) */ 
+	pci_read_config_word(dev, PCI_BRIDGE_CONTROL, &bctl);
+	pci_write_config_word(dev, PCI_BRIDGE_CONTROL,
+			      bctl & ~PCI_BRIDGE_CTL_MASTER_ABORT);
+
+	pci_enable_crs(dev);
+
+	if ((buses & 0xffff00) && !pcibios_assign_all_busses() && !is_cardbus) {
+		unsigned int cmax, busnr;
+		/*
+		 * Bus already configured by firmware, process it in the first
+		 * pass and just note the configuration.
+		 */
+		if (pass)
+			return max;
+		busnr = (buses >> 8) & 0xFF;
+
+		/*
+		 * If we already got to this bus through a different bridge,
+		 * ignore it.  This can happen with the i450NX chipset.
+		 */
+		if (pci_find_bus(pci_domain_nr(bus), busnr)) {
+			printk(KERN_INFO "PCI: Bus %04x:%02x already known\n",
+					pci_domain_nr(bus), busnr);
+			return max;
+		}
+
+		child = pci_alloc_child_bus(bus, dev, busnr);
+		if (!child)
+			return max;
+		child->primary = buses & 0xFF;
+		child->subordinate = (buses >> 16) & 0xFF;
+		child->bridge_ctl = bctl;
+
+		cmax = pci_scan_child_bus(child);
+		if (cmax > max)
+			max = cmax;
+		if (child->subordinate > max)
+			max = child->subordinate;
+	} else {
+		/*
+		 * We need to assign a number to this bus which we always
+		 * do in the second pass.
+		 */
+		if (!pass)
+			return max;
+
+		/* Clear errors */
+		pci_write_config_word(dev, PCI_STATUS, 0xffff);
+
+		child = pci_alloc_child_bus(bus, dev, ++max);
+		buses = (buses & 0xff000000)
+		      | ((unsigned int)(child->primary)     <<  0)
+		      | ((unsigned int)(child->secondary)   <<  8)
+		      | ((unsigned int)(child->subordinate) << 16);
+
+		/*
+		 * yenta.c forces a secondary latency timer of 176.
+		 * Copy that behaviour here.
+		 */
+		if (is_cardbus) {
+			buses &= ~0xff000000;
+			buses |= CARDBUS_LATENCY_TIMER << 24;
+		}
+			
+		/*
+		 * We need to blast all three values with a single write.
+		 */
+		pci_write_config_dword(dev, PCI_PRIMARY_BUS, buses);
+
+		if (!is_cardbus) {
+			child->bridge_ctl = PCI_BRIDGE_CTL_NO_ISA;
+
+			/* Now we can scan all subordinate buses... */
+			max = pci_scan_child_bus(child);
+		} else {
+			/*
+			 * For CardBus bridges, we leave 4 bus numbers
+			 * as cards with a PCI-to-PCI bridge can be
+			 * inserted later.
+			 */
+			max += CARDBUS_RESERVE_BUSNR;
+		}
+		/*
+		 * Set the subordinate bus number to its real value.
+		 */
+		child->subordinate = max;
+		pci_write_config_byte(dev, PCI_SUBORDINATE_BUS, max);
+	}
+
+	pci_write_config_word(dev, PCI_BRIDGE_CONTROL, bctl);
+
+	sprintf(child->name, (is_cardbus ? "PCI CardBus #%02x" : "PCI Bus #%02x"), child->number);
+
+	return max;
+}
+
+/*
+ * Read interrupt line and base address registers.
+ * The architecture-dependent code can tweak these, of course.
+ */
+static void pci_read_irq(struct pci_dev *dev)
+{
+	unsigned char irq;
+
+	pci_read_config_byte(dev, PCI_INTERRUPT_PIN, &irq);
+	if (irq)
+		pci_read_config_byte(dev, PCI_INTERRUPT_LINE, &irq);
+	dev->irq = irq;
+}
+
+/**
+ * pci_setup_device - fill in class and map information of a device
+ * @dev: the device structure to fill
+ *
+ * Initialize the device structure with information about the device's 
+ * vendor,class,memory and IO-space addresses,IRQ lines etc.
+ * Called at initialisation of the PCI subsystem and by CardBus services.
+ * Returns 0 on success and -1 if unknown type of device (not normal, bridge
+ * or CardBus).
+ */
+static int pci_setup_device(struct pci_dev * dev)
+{
+	u32 class;
+
+	sprintf(pci_name(dev), "%04x:%02x:%02x.%d", pci_domain_nr(dev->bus),
+		dev->bus->number, PCI_SLOT(dev->devfn), PCI_FUNC(dev->devfn));
+
+	pci_read_config_dword(dev, PCI_CLASS_REVISION, &class);
+	class >>= 8;				    /* upper 3 bytes */
+	dev->class = class;
+	class >>= 8;
+
+	pr_debug("PCI: Found %s [%04x/%04x] %06x %02x\n", pci_name(dev),
+		 dev->vendor, dev->device, class, dev->hdr_type);
+
+	/* "Unknown power state" */
+	dev->current_state = 4;
+
+	/* Early fixups, before probing the BARs */
+	pci_fixup_device(pci_fixup_early, dev);
+	class = dev->class >> 8;
+
+	switch (dev->hdr_type) {		    /* header type */
+	case PCI_HEADER_TYPE_NORMAL:		    /* standard header */
+		if (class == PCI_CLASS_BRIDGE_PCI)
+			goto bad;
+		pci_read_irq(dev);
+		pci_read_bases(dev, 6, PCI_ROM_ADDRESS);
+		pci_read_config_word(dev, PCI_SUBSYSTEM_VENDOR_ID, &dev->subsystem_vendor);
+		pci_read_config_word(dev, PCI_SUBSYSTEM_ID, &dev->subsystem_device);
+		break;
+
+	case PCI_HEADER_TYPE_BRIDGE:		    /* bridge header */
+		if (class != PCI_CLASS_BRIDGE_PCI)
+			goto bad;
+		/* The PCI-to-PCI bridge spec requires that subtractive
+		   decoding (i.e. transparent) bridge must have programming
+		   interface code of 0x01. */ 
+		dev->transparent = ((dev->class & 0xff) == 1);
+		pci_read_bases(dev, 2, PCI_ROM_ADDRESS1);
+		break;
+
+	case PCI_HEADER_TYPE_CARDBUS:		    /* CardBus bridge header */
+		if (class != PCI_CLASS_BRIDGE_CARDBUS)
+			goto bad;
+		pci_read_irq(dev);
+		pci_read_bases(dev, 1, 0);
+		pci_read_config_word(dev, PCI_CB_SUBSYSTEM_VENDOR_ID, &dev->subsystem_vendor);
+		pci_read_config_word(dev, PCI_CB_SUBSYSTEM_ID, &dev->subsystem_device);
+		break;
+
+	default:				    /* unknown header */
+		printk(KERN_ERR "PCI: device %s has unknown header type %02x, ignoring.\n",
+			pci_name(dev), dev->hdr_type);
+		return -1;
+
+	bad:
+		printk(KERN_ERR "PCI: %s: class %x doesn't match header type %02x. Ignoring class.\n",
+		       pci_name(dev), class, dev->hdr_type);
+		dev->class = PCI_CLASS_NOT_DEFINED;
+	}
+
+	/* We found a fine healthy device, go go go... */
+	return 0;
+}
+
+/**
+ * pci_release_dev - free a pci device structure when all users of it are finished.
+ * @dev: device that's been disconnected
+ *
+ * Will be called only by the device core when all users of this pci device are
+ * done.
+ */
+static void pci_release_dev(struct device *dev)
+{
+	struct pci_dev *pci_dev;
+
+	pci_dev = to_pci_dev(dev);
+	kfree(pci_dev);
+}
+
+/**
+ * pci_cfg_space_size - get the configuration space size of the PCI device.
+ *
+ * Regular PCI devices have 256 bytes, but PCI-X 2 and PCI Express devices
+ * have 4096 bytes.  Even if the device is capable, that doesn't mean we can
+ * access it.  Maybe we don't have a way to generate extended config space
+ * accesses, or the device is behind a reverse Express bridge.  So we try
+ * reading the dword at 0x100 which must either be 0 or a valid extended
+ * capability header.
+ */
+static int pci_cfg_space_size(struct pci_dev *dev)
+{
+	int pos;
+	u32 status;
+
+	pos = pci_find_capability(dev, PCI_CAP_ID_EXP);
+	if (!pos) {
+		pos = pci_find_capability(dev, PCI_CAP_ID_PCIX);
+		if (!pos)
+			goto fail;
+
+		pci_read_config_dword(dev, pos + PCI_X_STATUS, &status);
+		if (!(status & (PCI_X_STATUS_266MHZ | PCI_X_STATUS_533MHZ)))
+			goto fail;
+	}
+
+	if (pci_read_config_dword(dev, 256, &status) != PCIBIOS_SUCCESSFUL)
+		goto fail;
+	if (status == 0xffffffff)
+		goto fail;
+
+	return PCI_CFG_SPACE_EXP_SIZE;
+
+ fail:
+	return PCI_CFG_SPACE_SIZE;
+}
+
+static void pci_release_bus_bridge_dev(struct device *dev)
+{
+	kfree(dev);
+}
+
+/*
+ * Read the config data for a PCI device, sanity-check it
+ * and fill in the dev structure...
+ */
+static struct pci_dev * __devinit
+pci_scan_device(struct pci_bus *bus, int devfn)
+{
+	struct pci_dev *dev;
+	u32 l;
+	u8 hdr_type;
+	int delay = 1;
+
+	if (pci_bus_read_config_dword(bus, devfn, PCI_VENDOR_ID, &l))
+		return NULL;
+
+	/* some broken boards return 0 or ~0 if a slot is empty: */
+	if (l == 0xffffffff || l == 0x00000000 ||
+	    l == 0x0000ffff || l == 0xffff0000)
+		return NULL;
+
+	/* Configuration request Retry Status */
+	while (l == 0xffff0001) {
+		msleep(delay);
+		delay *= 2;
+		if (pci_bus_read_config_dword(bus, devfn, PCI_VENDOR_ID, &l))
+			return NULL;
+		/* Card hasn't responded in 60 seconds?  Must be stuck. */
+		if (delay > 60 * 1000) {
+			printk(KERN_WARNING "Device %04x:%02x:%02x.%d not "
+					"responding\n", pci_domain_nr(bus),
+					bus->number, PCI_SLOT(devfn),
+					PCI_FUNC(devfn));
+			return NULL;
+		}
+	}
+
+	if (pci_bus_read_config_byte(bus, devfn, PCI_HEADER_TYPE, &hdr_type))
+		return NULL;
+
+	dev = kmalloc(sizeof(struct pci_dev), GFP_KERNEL);
+	if (!dev)
+		return NULL;
+
+	memset(dev, 0, sizeof(struct pci_dev));
+	dev->bus = bus;
+	dev->sysdata = bus->sysdata;
+	dev->dev.parent = bus->bridge;
+	dev->dev.bus = &pci_bus_type;
+	dev->devfn = devfn;
+	dev->hdr_type = hdr_type & 0x7f;
+	dev->multifunction = !!(hdr_type & 0x80);
+	dev->vendor = l & 0xffff;
+	dev->device = (l >> 16) & 0xffff;
+	dev->cfg_size = pci_cfg_space_size(dev);
+
+	/* Assume 32-bit PCI; let 64-bit PCI cards (which are far rarer)
+	   set this higher, assuming the system even supports it.  */
+	dev->dma_mask = 0xffffffff;
+	if (pci_setup_device(dev) < 0) {
+		kfree(dev);
+		return NULL;
+	}
+	device_initialize(&dev->dev);
+	dev->dev.release = pci_release_dev;
+	pci_dev_get(dev);
+
+	pci_name_device(dev);
+
+	dev->dev.dma_mask = &dev->dma_mask;
+	dev->dev.coherent_dma_mask = 0xffffffffull;
+
+	return dev;
+}
+
+struct pci_dev * __devinit
+pci_scan_single_device(struct pci_bus *bus, int devfn)
+{
+	struct pci_dev *dev;
+
+	dev = pci_scan_device(bus, devfn);
+	pci_scan_msi_device(dev);
+
+	if (!dev)
+		return NULL;
+	
+	/* Fix up broken headers */
+	pci_fixup_device(pci_fixup_header, dev);
+
+	/*
+	 * Add the device to our list of discovered devices
+	 * and the bus list for fixup functions, etc.
+	 */
+	INIT_LIST_HEAD(&dev->global_list);
+	list_add_tail(&dev->bus_list, &bus->devices);
+
+	return dev;
+}
+
+/**
+ * pci_scan_slot - scan a PCI slot on a bus for devices.
+ * @bus: PCI bus to scan
+ * @devfn: slot number to scan (must have zero function.)
+ *
+ * Scan a PCI slot on the specified PCI bus for devices, adding
+ * discovered devices to the @bus->devices list.  New devices
+ * will have an empty dev->global_list head.
+ */
+int __devinit pci_scan_slot(struct pci_bus *bus, int devfn)
+{
+	int func, nr = 0;
+	int scan_all_fns;
+
+	scan_all_fns = pcibios_scan_all_fns(bus, devfn);
+
+	for (func = 0; func < 8; func++, devfn++) {
+		struct pci_dev *dev;
+
+		dev = pci_scan_single_device(bus, devfn);
+		if (dev) {
+			nr++;
+
+			/*
+		 	 * If this is a single function device,
+		 	 * don't scan past the first function.
+		 	 */
+			if (!dev->multifunction) {
+				if (func > 0) {
+					dev->multifunction = 1;
+				} else {
+ 					break;
+				}
+			}
+		} else {
+			if (func == 0 && !scan_all_fns)
+				break;
+		}
+	}
+	return nr;
+}
+
+unsigned int __devinit pci_scan_child_bus(struct pci_bus *bus)
+{
+	unsigned int devfn, pass, max = bus->secondary;
+	struct pci_dev *dev;
+
+	pr_debug("PCI: Scanning bus %04x:%02x\n", pci_domain_nr(bus), bus->number);
+
+	/* Go find them, Rover! */
+	for (devfn = 0; devfn < 0x100; devfn += 8)
+		pci_scan_slot(bus, devfn);
+
+	/*
+	 * After performing arch-dependent fixup of the bus, look behind
+	 * all PCI-to-PCI bridges on this bus.
+	 */
+	pr_debug("PCI: Fixups for bus %04x:%02x\n", pci_domain_nr(bus), bus->number);
+	pcibios_fixup_bus(bus);
+	for (pass=0; pass < 2; pass++)
+		list_for_each_entry(dev, &bus->devices, bus_list) {
+			if (dev->hdr_type == PCI_HEADER_TYPE_BRIDGE ||
+			    dev->hdr_type == PCI_HEADER_TYPE_CARDBUS)
+				max = pci_scan_bridge(bus, dev, max, pass);
+		}
+
+	/*
+	 * We've scanned the bus and so we know all about what's on
+	 * the other side of any bridges that may be on this bus plus
+	 * any devices.
+	 *
+	 * Return how far we've got finding sub-buses.
+	 */
+	pr_debug("PCI: Bus scan for %04x:%02x returning with max=%02x\n",
+		pci_domain_nr(bus), bus->number, max);
+	return max;
+}
+
+unsigned int __devinit pci_do_scan_bus(struct pci_bus *bus)
+{
+	unsigned int max;
+
+	max = pci_scan_child_bus(bus);
+
+	/*
+	 * Make the discovered devices available.
+	 */
+	pci_bus_add_devices(bus);
+
+	return max;
+}
+
+struct pci_bus * __devinit pci_scan_bus_parented(struct device *parent, int bus, struct pci_ops *ops, void *sysdata)
+{
+	int error;
+	struct pci_bus *b;
+	struct device *dev;
+
+	b = pci_alloc_bus();
+	if (!b)
+		return NULL;
+
+	dev = kmalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev){
+		kfree(b);
+		return NULL;
+	}
+
+	b->sysdata = sysdata;
+	b->ops = ops;
+
+	if (pci_find_bus(pci_domain_nr(b), bus)) {
+		/* If we already got to this bus through a different bridge, ignore it */
+		pr_debug("PCI: Bus %04x:%02x already known\n", pci_domain_nr(b), bus);
+		goto err_out;
+	}
+	list_add_tail(&b->node, &pci_root_buses);
+
+	memset(dev, 0, sizeof(*dev));
+	dev->parent = parent;
+	dev->release = pci_release_bus_bridge_dev;
+	sprintf(dev->bus_id, "pci%04x:%02x", pci_domain_nr(b), bus);
+	error = device_register(dev);
+	if (error)
+		goto dev_reg_err;
+	b->bridge = get_device(dev);
+
+	b->class_dev.class = &pcibus_class;
+	sprintf(b->class_dev.class_id, "%04x:%02x", pci_domain_nr(b), bus);
+	error = class_device_register(&b->class_dev);
+	if (error)
+		goto class_dev_reg_err;
+	error = class_device_create_file(&b->class_dev, &class_device_attr_cpuaffinity);
+	if (error)
+		goto class_dev_create_file_err;
+
+	/* Create legacy_io and legacy_mem files for this bus */
+	pci_create_legacy_files(b);
+
+	error = sysfs_create_link(&b->class_dev.kobj, &b->bridge->kobj, "bridge");
+	if (error)
+		goto sys_create_link_err;
+
+	b->number = b->secondary = bus;
+	b->resource[0] = &ioport_resource;
+	b->resource[1] = &iomem_resource;
+
+	b->subordinate = pci_scan_child_bus(b);
+
+	pci_bus_add_devices(b);
+
+	return b;
+
+sys_create_link_err:
+	class_device_remove_file(&b->class_dev, &class_device_attr_cpuaffinity);
+class_dev_create_file_err:
+	class_device_unregister(&b->class_dev);
+class_dev_reg_err:
+	device_unregister(dev);
+dev_reg_err:
+	list_del(&b->node);
+err_out:
+	kfree(dev);
+	kfree(b);
+	return NULL;
+}
+EXPORT_SYMBOL(pci_scan_bus_parented);
+
+#ifdef CONFIG_HOTPLUG
+EXPORT_SYMBOL(pci_add_new_bus);
+EXPORT_SYMBOL(pci_do_scan_bus);
+EXPORT_SYMBOL(pci_scan_slot);
+EXPORT_SYMBOL(pci_scan_bridge);
+EXPORT_SYMBOL(pci_scan_single_device);
+EXPORT_SYMBOL_GPL(pci_scan_child_bus);
+#endif
