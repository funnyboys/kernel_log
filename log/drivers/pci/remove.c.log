commit 9885440b16b8fc1dd7275800fd28f56a92f60896
Author: Rob Herring <robh@kernel.org>
Date:   Wed May 13 17:38:59 2020 -0500

    PCI: Fix pci_host_bridge struct device release/free handling
    
    The PCI code has several paths where the struct pci_host_bridge is freed
    directly. This is wrong because it contains a struct device which is
    refcounted and should be freed using put_device(). This can result in
    use-after-free errors. I think this problem has existed since 2012 with
    commit 7b5436635800 ("PCI: add generic device into pci_host_bridge
    struct"). It generally hasn't mattered as most host bridge drivers are
    still built-in and can't unbind.
    
    The problem is a struct device should never be freed directly once
    device_initialize() is called and a ref is held, but that doesn't happen
    until pci_register_host_bridge(). There's then a window between allocating
    the host bridge and pci_register_host_bridge() where kfree should be used.
    This is fragile and requires callers to do the right thing. To fix this, we
    need to split device_register() into device_initialize() and device_add()
    calls, so that the host bridge struct is always freed by using a
    put_device().
    
    devm_pci_alloc_host_bridge() is using devm_kzalloc() to allocate struct
    pci_host_bridge which will be freed directly. Instead, we can use a custom
    devres action to call put_device().
    
    Link: https://lore.kernel.org/r/20200513223859.11295-2-robh@kernel.org
    Reported-by: Anders Roxell <anders.roxell@linaro.org>
    Tested-by: Anders Roxell <anders.roxell@linaro.org>
    Signed-off-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/drivers/pci/remove.c b/drivers/pci/remove.c
index e9c6b120cf45..95dec03d9f2a 100644
--- a/drivers/pci/remove.c
+++ b/drivers/pci/remove.c
@@ -160,6 +160,6 @@ void pci_remove_root_bus(struct pci_bus *bus)
 	host_bridge->bus = NULL;
 
 	/* remove the host bridge */
-	device_unregister(&host_bridge->dev);
+	device_del(&host_bridge->dev);
 }
 EXPORT_SYMBOL_GPL(pci_remove_root_bus);

commit aeae4f3e5c38d47bdaef50446dc0ec857307df68
Author: Lukas Wunner <lukas@wunner.de>
Date:   Tue Sep 4 12:34:18 2018 -0500

    PCI/ASPM: Fix link_state teardown on device removal
    
    Upon removal of the last device on a bus, the link_state of the bridge
    leading to that bus is sought to be torn down by having pci_stop_dev()
    call pcie_aspm_exit_link_state().
    
    When ASPM was originally introduced by commit 7d715a6c1ae5 ("PCI: add
    PCI Express ASPM support"), it determined whether the device being
    removed is the last one by calling list_empty() on the bridge's
    subordinate devices list.  That didn't work because the device is only
    removed from the list slightly later in pci_destroy_dev().
    
    Commit 3419c75e15f8 ("PCI: properly clean up ASPM link state on device
    remove") attempted to fix it by calling list_is_last(), but that's not
    correct either because it checks whether the device is at the *end* of
    the list, not whether it's the last one *left* in the list.  If the user
    removes the device which happens to be at the end of the list via sysfs
    but other devices are preceding the device in the list, the link_state
    is torn down prematurely.
    
    The real fix is to move the invocation of pcie_aspm_exit_link_state() to
    pci_destroy_dev() and reinstate the call to list_empty().  Remove a
    duplicate check for dev->bus->self because pcie_aspm_exit_link_state()
    already contains an identical check.
    
    Fixes: 7d715a6c1ae5 ("PCI: add PCI Express ASPM support")
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Shaohua Li <shaohua.li@intel.com>
    Cc: stable@vger.kernel.org # v2.6.26

diff --git a/drivers/pci/remove.c b/drivers/pci/remove.c
index 461e7fd2756f..e9c6b120cf45 100644
--- a/drivers/pci/remove.c
+++ b/drivers/pci/remove.c
@@ -25,9 +25,6 @@ static void pci_stop_dev(struct pci_dev *dev)
 
 		pci_dev_assign_added(dev, false);
 	}
-
-	if (dev->bus->self)
-		pcie_aspm_exit_link_state(dev);
 }
 
 static void pci_destroy_dev(struct pci_dev *dev)
@@ -41,6 +38,7 @@ static void pci_destroy_dev(struct pci_dev *dev)
 	list_del(&dev->bus_list);
 	up_write(&pci_bus_sem);
 
+	pcie_aspm_exit_link_state(dev);
 	pci_bridge_d3_update(dev);
 	pci_free_resources(dev);
 	put_device(&dev->dev);

commit 187dacce194216c4d86c2afd0ca490a6d7fbb981
Merge: 3c3ab37f4c03 ce29af2a5056
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Aug 15 14:58:46 2018 -0500

    Merge branch 'pci/aspm'
    
      - Use sysfs_match_string() to simplify ASPM sysfs parsing (Andy
        Shevchenko)
    
      - Remove unnecessary includes of <linux/pci-aspm.h> (Bjorn Helgaas)
    
    * pci/aspm:
      PCI: Remove unnecessary include of <linux/pci-aspm.h>
      iwlwifi: Remove unnecessary include of <linux/pci-aspm.h>
      ath9k: Remove unnecessary include of <linux/pci-aspm.h>
      igb: Remove unnecessary include of <linux/pci-aspm.h>
      PCI/ASPM: Convert to use sysfs_match_string() helper

commit ce29af2a505627cc8f1deddb84bcbaf186b0bfd5
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Jul 25 14:53:42 2018 -0500

    PCI: Remove unnecessary include of <linux/pci-aspm.h>
    
    Several PCI core files include pci-aspm.h even though they don't need
    anything provided by that file.  Remove the unnecessary includes of it.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Sinan Kaya <okaya@kernel.org>

diff --git a/drivers/pci/remove.c b/drivers/pci/remove.c
index 6f072eae4f7a..01ec7fcb5634 100644
--- a/drivers/pci/remove.c
+++ b/drivers/pci/remove.c
@@ -1,7 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 #include <linux/pci.h>
 #include <linux/module.h>
-#include <linux/pci-aspm.h>
 #include "pci.h"
 
 static void pci_free_resources(struct pci_dev *dev)

commit 44bda4b7d26e9fffed6d7152d98a2e9edaeb2a76
Author: Hari Vyas <hari.vyas@broadcom.com>
Date:   Tue Jul 3 14:35:41 2018 +0530

    PCI: Fix is_added/is_busmaster race condition
    
    When a PCI device is detected, pdev->is_added is set to 1 and proc and
    sysfs entries are created.
    
    When the device is removed, pdev->is_added is checked for one and then
    device is detached with clearing of proc and sys entries and at end,
    pdev->is_added is set to 0.
    
    is_added and is_busmaster are bit fields in pci_dev structure sharing same
    memory location.
    
    A strange issue was observed with multiple removal and rescan of a PCIe
    NVMe device using sysfs commands where is_added flag was observed as zero
    instead of one while removing device and proc,sys entries are not cleared.
    This causes issue in later device addition with warning message
    "proc_dir_entry" already registered.
    
    Debugging revealed a race condition between the PCI core setting the
    is_added bit in pci_bus_add_device() and the NVMe driver reset work-queue
    setting the is_busmaster bit in pci_set_master().  As these fields are not
    handled atomically, that clears the is_added bit.
    
    Move the is_added bit to a separate private flag variable and use atomic
    functions to set and retrieve the device addition state.  This avoids the
    race because is_added no longer shares a memory location with is_busmaster.
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=200283
    Signed-off-by: Hari Vyas <hari.vyas@broadcom.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Lukas Wunner <lukas@wunner.de>
    Acked-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/drivers/pci/remove.c b/drivers/pci/remove.c
index 6f072eae4f7a..5e3d0dced2b8 100644
--- a/drivers/pci/remove.c
+++ b/drivers/pci/remove.c
@@ -19,11 +19,12 @@ static void pci_stop_dev(struct pci_dev *dev)
 {
 	pci_pme_active(dev, false);
 
-	if (dev->is_added) {
+	if (pci_dev_is_added(dev)) {
 		device_release_driver(&dev->dev);
 		pci_proc_detach_device(dev);
 		pci_remove_sysfs_dev_files(dev);
-		dev->is_added = 0;
+
+		pci_dev_assign_added(dev, false);
 	}
 
 	if (dev->bus->self)

commit 7328c8f48d1895b3fec98b0b319cfb856b4c4fa1
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Jan 26 11:45:16 2018 -0600

    PCI: Add SPDX GPL-2.0 when no license was specified
    
    b24413180f56 ("License cleanup: add SPDX GPL-2.0 license identifier to
    files with no license") added SPDX GPL-2.0 to several PCI files that
    previously contained no license information.
    
    Add SPDX GPL-2.0 to all other PCI files that did not contain any license
    information and hence were under the default GPL version 2 license of the
    kernel.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pci/remove.c b/drivers/pci/remove.c
index 2fa0dbde36b7..6f072eae4f7a 100644
--- a/drivers/pci/remove.c
+++ b/drivers/pci/remove.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 #include <linux/pci.h>
 #include <linux/module.h>
 #include <linux/pci-aspm.h>

commit 16b6c8bb687cc3bec914de09061fcb8411951fda
Author: Alex Williamson <alex.williamson@redhat.com>
Date:   Wed Oct 11 15:35:56 2017 -0600

    PCI: Detach driver before procfs & sysfs teardown on device remove
    
    When removing a device, for example a VF being removed due to SR-IOV
    teardown, a "soft" hot-unplug via 'echo 1 > remove' in sysfs, or an actual
    hot-unplug, we first remove the procfs and sysfs attributes for the device
    before attempting to release the device from any driver bound to it.
    Unbinding the driver from the device can take time.  The device might need
    to write out data or it might be actively in use.  If it's in use by
    userspace through a vfio driver, the unbind might block until the user
    releases the device.  This leads to a potentially non-trivial amount of
    time where the device exists, but we've torn down the interfaces that
    userspace uses to examine devices, for instance lspci might generate this
    sort of error:
    
      pcilib: Cannot open /sys/bus/pci/devices/0000:01:0a.3/config
      lspci: Unable to read the standard configuration space header of device 0000:01:0a.3
    
    We don't seem to have any dependence on this teardown ordering in the
    kernel, so let's unbind the driver first, which is also more symmetric with
    the instantiation of the device in pci_bus_add_device().
    
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/remove.c b/drivers/pci/remove.c
index 73a03d382590..2fa0dbde36b7 100644
--- a/drivers/pci/remove.c
+++ b/drivers/pci/remove.c
@@ -19,9 +19,9 @@ static void pci_stop_dev(struct pci_dev *dev)
 	pci_pme_active(dev, false);
 
 	if (dev->is_added) {
+		device_release_driver(&dev->dev);
 		pci_proc_detach_device(dev);
 		pci_remove_sysfs_dev_files(dev);
-		device_release_driver(&dev->dev);
 		dev->is_added = 0;
 	}
 

commit 1ed276a7b9d84626e5243fc54863440c74a4100a
Author: Lukas Wunner <lukas@wunner.de>
Date:   Fri Oct 28 10:52:06 2016 +0200

    PCI: Autosense device removal in pci_bridge_d3_update()
    
    The algorithm to update the flag indicating whether a bridge may go to D3
    makes a few optimizations based on whether the update was caused by the
    removal of a device on the one hand, versus the addition of a device or the
    change of its D3cold flags on the other hand.
    
    The information whether the update pertains to a removal is currently
    passed in by the caller, but the function may as well determine that itself
    by examining the device in question, thereby allowing for a considerable
    simplification and reduction of the code.
    
    Out of several options to determine removal, I've chosen the function
    device_is_registered() because it's cheap:  It merely returns the
    dev->kobj.state_in_sysfs flag.  That flag is set through device_add() when
    the root bus is scanned and cleared through device_remove().  The call to
    pci_bridge_d3_update() happens after each of these calls, respectively, so
    the ordering is correct.
    
    No functional change intended.
    
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/remove.c b/drivers/pci/remove.c
index f9357e09e9b3..73a03d382590 100644
--- a/drivers/pci/remove.c
+++ b/drivers/pci/remove.c
@@ -40,7 +40,7 @@ static void pci_destroy_dev(struct pci_dev *dev)
 	list_del(&dev->bus_list);
 	up_write(&pci_bus_sem);
 
-	pci_bridge_d3_device_removed(dev);
+	pci_bridge_d3_update(dev);
 	pci_free_resources(dev);
 	put_device(&dev->dev);
 }

commit 035ee288ae7ade4152f1c3cf23a587b04fdc526c
Author: Lukas Wunner <lukas@wunner.de>
Date:   Tue Sep 6 06:20:46 2016 +0200

    PCI: Fix bridge_d3 update on device removal
    
    Starting with v4.8, we allow a PCIe port to runtime suspend to D3hot if the
    port itself and its children satisfy a number of conditions.  Once a child
    is removed, we recheck those conditions in case the removed device was
    blocking the port from suspending.
    
    The rechecking needs to happen *after* the device has been removed from the
    bus it resides on.  Otherwise when walking the port's subordinate bus in
    pci_bridge_d3_update(), the device being removed would erroneously still be
    taken into account.
    
    However the device is removed from the bus_list in pci_destroy_dev() and we
    currently recheck *before* that.  Fix it.
    
    Fixes: 9d26d3a8f1b0 ("PCI: Put PCIe ports into D3 during suspend")
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Rafael J. Wysocki <mika.westerberg@linux.intel.com>

diff --git a/drivers/pci/remove.c b/drivers/pci/remove.c
index d1ef7acf6930..f9357e09e9b3 100644
--- a/drivers/pci/remove.c
+++ b/drivers/pci/remove.c
@@ -40,6 +40,7 @@ static void pci_destroy_dev(struct pci_dev *dev)
 	list_del(&dev->bus_list);
 	up_write(&pci_bus_sem);
 
+	pci_bridge_d3_device_removed(dev);
 	pci_free_resources(dev);
 	put_device(&dev->dev);
 }
@@ -96,8 +97,6 @@ static void pci_remove_bus_device(struct pci_dev *dev)
 		dev->subordinate = NULL;
 	}
 
-	pci_bridge_d3_device_removed(dev);
-
 	pci_destroy_dev(dev);
 }
 

commit 9d26d3a8f1b0c442339a235f9508bdad8af91043
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Thu Jun 2 11:17:12 2016 +0300

    PCI: Put PCIe ports into D3 during suspend
    
    Currently the Linux PCI core does not touch power state of PCI bridges and
    PCIe ports when system suspend is entered.  Leaving them in D0 consumes
    power unnecessarily and may prevent the CPU from entering deeper C-states.
    
    With recent PCIe hardware we can power down the ports to save power given
    that we take into account few restrictions:
    
      - The PCIe port hardware is recent enough, starting from 2015.
    
      - Devices connected to PCIe ports are effectively in D3cold once the port
        is transitioned to D3 (the config space is not accessible anymore and
        the link may be powered down).
    
      - Devices behind the PCIe port need to be allowed to transition to D3cold
        and back.  There is a way both drivers and userspace can forbid this.
    
      - If the device behind the PCIe port is capable of waking the system it
        needs to be able to do so from D3cold.
    
    This patch adds a new flag to struct pci_device called 'bridge_d3'.  This
    flag is set and cleared by the PCI core whenever there is a change in power
    management state of any of the devices behind the PCIe port.  When system
    later on is suspended we only need to check this flag and if it is true
    transition the port to D3 otherwise we leave it in D0.
    
    Also provide override mechanism via command line parameter
    "pcie_port_pm=[off|force]" that can be used to disable or enable the
    feature regardless of the BIOS manufacturing date.
    
    Tested-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/remove.c b/drivers/pci/remove.c
index 8982026637d5..d1ef7acf6930 100644
--- a/drivers/pci/remove.c
+++ b/drivers/pci/remove.c
@@ -96,6 +96,8 @@ static void pci_remove_bus_device(struct pci_dev *dev)
 		dev->subordinate = NULL;
 	}
 
+	pci_bridge_d3_device_removed(dev);
+
 	pci_destroy_dev(dev);
 }
 

commit 6e6f498b039aa5558c7377fbbe65f7421d34cea4
Merge: cfeb8139a1fb bd5174dfb6f1
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Mar 15 08:56:28 2016 -0500

    Merge branch 'pci/resource' into next
    
    * pci/resource:
      PCI: Simplify pci_create_attr() control flow
      PCI: Don't leak memory if sysfs_create_bin_file() fails
      PCI: Simplify sysfs ROM cleanup
      PCI: Remove unused IORESOURCE_ROM_COPY and IORESOURCE_ROM_BIOS_COPY
      MIPS: Loongson 3: Keep CPU physical (not virtual) addresses in shadow ROM resource
      MIPS: Loongson 3: Use temporary struct resource * to avoid repetition
      ia64/PCI: Keep CPU physical (not virtual) addresses in shadow ROM resource
      ia64/PCI: Use ioremap() instead of open-coded equivalent
      ia64/PCI: Use temporary struct resource * to avoid repetition
      PCI: Clean up pci_map_rom() whitespace
      PCI: Remove arch-specific IORESOURCE_ROM_SHADOW size from sysfs
      PCI: Set ROM shadow location in arch code, not in PCI core
      PCI: Don't enable/disable ROM BAR if we're using a RAM shadow copy
      PCI: Don't assign or reassign immutable resources
      PCI: Mark shadow copy of VGA ROM as IORESOURCE_PCI_FIXED
      x86/PCI: Mark Broadwell-EP Home Agent & PCU as having non-compliant BARs
      PCI: Disable IO/MEM decoding for devices with non-compliant BARs

commit d9c8bea179a6906a74ea42a2a162c4d1c6d9a16b
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Mar 2 21:46:50 2016 -0600

    PCI: Remove unused IORESOURCE_ROM_COPY and IORESOURCE_ROM_BIOS_COPY
    
    The IORESOURCE_ROM_COPY and IORESOURCE_ROM_BIOS_COPY bits are unused.
    Remove them and code that depends on them.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/remove.c b/drivers/pci/remove.c
index 8a280e9c2ad1..6b66329a6bff 100644
--- a/drivers/pci/remove.c
+++ b/drivers/pci/remove.c
@@ -7,7 +7,6 @@ static void pci_free_resources(struct pci_dev *dev)
 {
 	int i;
 
-	pci_cleanup_rom(dev);
 	for (i = 0; i < PCI_NUM_RESOURCES; i++) {
 		struct resource *res = dev->resource + i;
 		if (res->parent)

commit 057bd2e0528ec68b3d0481ede0b26a31a9e5d2f1
Author: Thierry Reding <treding@nvidia.com>
Date:   Tue Feb 9 15:30:47 2016 +0100

    PCI: Add pci_ops.{add,remove}_bus() callbacks
    
    Add pci_ops.{add,remove}_bus() callbacks, which will be called on every
    newly created bus and when a bus is being removed, respectively.  This can
    be used by drivers to implement driver-specific initialization and teardown
    of the bus, in addition to the architecture-specifics implemented by the
    pcibios_add_bus() and the pcibios_remove_bus() functions.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/remove.c b/drivers/pci/remove.c
index 8a280e9c2ad1..d35c7fcde3af 100644
--- a/drivers/pci/remove.c
+++ b/drivers/pci/remove.c
@@ -54,6 +54,10 @@ void pci_remove_bus(struct pci_bus *bus)
 	pci_bus_release_busn_res(bus);
 	up_write(&pci_bus_sem);
 	pci_remove_legacy_files(bus);
+
+	if (bus->ops->remove_bus)
+		bus->ops->remove_bus(bus);
+
 	pcibios_remove_bus(bus);
 	device_unregister(&bus->dev);
 }

commit e6b29deafad3ce020dcf873a27a95c0cb9966c5b
Author: Ray Jui <rjui@broadcom.com>
Date:   Wed Apr 8 11:21:33 2015 -0700

    PCI: Export symbols required for loadable host driver modules
    
    Export the following symbols so they can be referenced by a PCI host bridge
    driver compiled as a kernel loadable module:
    
      pci_common_swizzle
      pci_create_root_bus
      pci_stop_root_bus
      pci_remove_root_bus
      pci_assign_unassigned_bus_resources
      pci_fixup_irqs
    
    Signed-off-by: Ray Jui <rjui@broadcom.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/drivers/pci/remove.c b/drivers/pci/remove.c
index 8bd76c9ba21c..8a280e9c2ad1 100644
--- a/drivers/pci/remove.c
+++ b/drivers/pci/remove.c
@@ -139,6 +139,7 @@ void pci_stop_root_bus(struct pci_bus *bus)
 	/* stop the host bridge */
 	device_release_driver(&host_bridge->dev);
 }
+EXPORT_SYMBOL_GPL(pci_stop_root_bus);
 
 void pci_remove_root_bus(struct pci_bus *bus)
 {
@@ -158,3 +159,4 @@ void pci_remove_root_bus(struct pci_bus *bus)
 	/* remove the host bridge */
 	device_unregister(&host_bridge->dev);
 }
+EXPORT_SYMBOL_GPL(pci_remove_root_bus);

commit 04480094de7242d08bb62088e713fd7fe00443b4
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Feb 1 15:38:29 2014 +0100

    Revert "PCI: Remove from bus_list and release resources in pci_release_dev()"
    
    Revert commit ef83b0781a73 "PCI: Remove from bus_list and release
    resources in pci_release_dev()" that made some nasty race conditions
    become possible.  For example, if a Thunderbolt link is unplugged
    and then replugged immediately, the pci_release_dev() resulting from
    the hot-remove code path may be racing with the hot-add code path
    which after that commit causes various kinds of breakage to happen
    (up to and including a hard crash of the whole system).
    
    Moreover, the problem that commit ef83b0781a73 attempted to address
    cannot happen any more after commit 8a4c5c329de7 "PCI: Check parent
    kobject in pci_destroy_dev()", because pci_destroy_dev() will now
    return immediately if it has already been executed for the given
    device.
    
    Note, however, that the invocation of msi_remove_pci_irq_vectors()
    removed by commit ef83b0781a73 from pci_free_resources() along with
    the other changes made by it is not added back because of subsequent
    code changes depending on that modification.
    
    Fixes: ef83b0781a73 (PCI: Remove from bus_list and release resources in pci_release_dev())
    Reported-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pci/remove.c b/drivers/pci/remove.c
index 4ff36bfa785e..8bd76c9ba21c 100644
--- a/drivers/pci/remove.c
+++ b/drivers/pci/remove.c
@@ -3,6 +3,18 @@
 #include <linux/pci-aspm.h>
 #include "pci.h"
 
+static void pci_free_resources(struct pci_dev *dev)
+{
+	int i;
+
+	pci_cleanup_rom(dev);
+	for (i = 0; i < PCI_NUM_RESOURCES; i++) {
+		struct resource *res = dev->resource + i;
+		if (res->parent)
+			release_resource(res);
+	}
+}
+
 static void pci_stop_dev(struct pci_dev *dev)
 {
 	pci_pme_active(dev, false);
@@ -25,6 +37,11 @@ static void pci_destroy_dev(struct pci_dev *dev)
 
 	device_del(&dev->dev);
 
+	down_write(&pci_bus_sem);
+	list_del(&dev->bus_list);
+	up_write(&pci_bus_sem);
+
+	pci_free_resources(dev);
 	put_device(&dev->dev);
 }
 

commit 8a4c5c329de716996eea03d93753ccbb5406072b
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Jan 14 12:04:51 2014 -0700

    PCI: Check parent kobject in pci_destroy_dev()
    
    If pci_stop_and_remove_bus_device() is run concurrently for a device and
    its parent bridge via remove_callback(), both code paths attempt to acquire
    pci_rescan_remove_lock.  If the child device removal acquires it first,
    there will be no problems.  However, if the parent bridge removal acquires
    it first, it will eventually execute pci_destroy_dev() for the child
    device, but that device object will not be freed yet due to the reference
    held by the concurrent child removal.  Consequently, both
    pci_stop_bus_device() and pci_remove_bus_device() will be executed for that
    device unnecessarily and pci_destroy_dev() will see a corrupted list head
    in that object.  Moreover, an excess put_device() will be executed for that
    device in that case which may lead to a use-after-free in the final
    kobject_put() done by sysfs_schedule_callback_work().
    
    To avoid that problem, make pci_destroy_dev() check if the device's parent
    kobject is NULL, which only happens after device_del() has already run for
    it.  Make pci_destroy_dev() return immediately whithout doing anything in
    that case.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/remove.c b/drivers/pci/remove.c
index 10fa13f9e309..4ff36bfa785e 100644
--- a/drivers/pci/remove.c
+++ b/drivers/pci/remove.c
@@ -20,6 +20,9 @@ static void pci_stop_dev(struct pci_dev *dev)
 
 static void pci_destroy_dev(struct pci_dev *dev)
 {
+	if (!dev->dev.kobj.parent)
+		return;
+
 	device_del(&dev->dev);
 
 	put_device(&dev->dev);

commit 9d16947b75831acd317ab9a53e0e94d160731d33
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Jan 10 15:22:18 2014 +0100

    PCI: Add global pci_lock_rescan_remove()
    
    There are multiple PCI device addition and removal code paths that may be
    run concurrently with the generic PCI bus rescan and device removal that
    can be triggered via sysfs.  If that happens, it may lead to multiple
    different, potentially dangerous race conditions.
    
    The most straightforward way to address those problems is to run
    the code in question under the same lock that is used by the
    generic rescan/remove code in pci-sysfs.c.  To prepare for those
    changes, move the definition of the global PCI remove/rescan lock
    to probe.c and provide global wrappers, pci_lock_rescan_remove()
    and pci_unlock_rescan_remove(), allowing drivers to manipulate
    that lock.  Also provide pci_stop_and_remove_bus_device_locked()
    for the callers of pci_stop_and_remove_bus_device() who only need
    to hold the rescan/remove lock around it.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/remove.c b/drivers/pci/remove.c
index f452148e6d55..10fa13f9e309 100644
--- a/drivers/pci/remove.c
+++ b/drivers/pci/remove.c
@@ -95,6 +95,14 @@ void pci_stop_and_remove_bus_device(struct pci_dev *dev)
 }
 EXPORT_SYMBOL(pci_stop_and_remove_bus_device);
 
+void pci_stop_and_remove_bus_device_locked(struct pci_dev *dev)
+{
+	pci_lock_rescan_remove();
+	pci_stop_and_remove_bus_device(dev);
+	pci_unlock_rescan_remove();
+}
+EXPORT_SYMBOL_GPL(pci_stop_and_remove_bus_device_locked);
+
 void pci_stop_root_bus(struct pci_bus *bus)
 {
 	struct pci_dev *child, *tmp;

commit ef83b0781a73f9efcb1228256bfdfb97fc9533a8
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Sat Nov 30 14:40:29 2013 -0800

    PCI: Remove from bus_list and release resources in pci_release_dev()
    
    Previously we removed the pci_dev from the bus_list and released its
    resources in pci_destroy_dev().  But that's too early: it's possible to
    call pci_destroy_dev() twice for the same device (e.g., via sysfs), and
    that will cause an oops when we try to remove it from bus_list the second
    time.
    
    We should remove it from the bus_list only when the last reference to the
    pci_dev has been released, i.e., in pci_release_dev().
    
    [bhelgaas: changelog]
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/remove.c b/drivers/pci/remove.c
index 692f4c39ac48..f452148e6d55 100644
--- a/drivers/pci/remove.c
+++ b/drivers/pci/remove.c
@@ -3,20 +3,6 @@
 #include <linux/pci-aspm.h>
 #include "pci.h"
 
-static void pci_free_resources(struct pci_dev *dev)
-{
-	int i;
-
-	msi_remove_pci_irq_vectors(dev);
-
-	pci_cleanup_rom(dev);
-	for (i = 0; i < PCI_NUM_RESOURCES; i++) {
-		struct resource *res = dev->resource + i;
-		if (res->parent)
-			release_resource(res);
-	}
-}
-
 static void pci_stop_dev(struct pci_dev *dev)
 {
 	pci_pme_active(dev, false);
@@ -36,11 +22,6 @@ static void pci_destroy_dev(struct pci_dev *dev)
 {
 	device_del(&dev->dev);
 
-	down_write(&pci_bus_sem);
-	list_del(&dev->bus_list);
-	up_write(&pci_bus_sem);
-
-	pci_free_resources(dev);
 	put_device(&dev->dev);
 }
 

commit e3b439e1d315aff59c1b4f0fc43c5cd2d82b4138
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Sat Nov 30 14:40:27 2013 -0800

    PCI: Use device_release_driver() in pci_stop_root_bus()
    
    To be consistent with 4bff6749905d ("PCI: Move device_del() from
    pci_stop_dev() to pci_destroy_dev()", this changes pci_stop_root_bus()
    to use device_release_driver() instead of device_del().
    
    This also changes pci_remove_root_bus() to use device_unregister()
    instead of put_device() so it corresponds with the device_register()
    call in pci_create_root_bus().
    
    [bhelgaas: changelog]
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/remove.c b/drivers/pci/remove.c
index cc9337a71529..692f4c39ac48 100644
--- a/drivers/pci/remove.c
+++ b/drivers/pci/remove.c
@@ -128,7 +128,7 @@ void pci_stop_root_bus(struct pci_bus *bus)
 		pci_stop_bus_device(child);
 
 	/* stop the host bridge */
-	device_del(&host_bridge->dev);
+	device_release_driver(&host_bridge->dev);
 }
 
 void pci_remove_root_bus(struct pci_bus *bus)
@@ -147,5 +147,5 @@ void pci_remove_root_bus(struct pci_bus *bus)
 	host_bridge->bus = NULL;
 
 	/* remove the host bridge */
-	put_device(&host_bridge->dev);
+	device_unregister(&host_bridge->dev);
 }

commit c4a0a5d964e90b93eb4101c3927b788e083e530f
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Dec 18 13:53:32 2013 -0700

    PCI: Move device_del() from pci_stop_dev() to pci_destroy_dev()
    
    After commit bcdde7e221a8 (sysfs: make __sysfs_remove_dir() recursive)
    I'm seeing traces analogous to the one below in Thunderbolt testing:
    
    WARNING: CPU: 3 PID: 76 at /scratch/rafael/work/linux-pm/fs/sysfs/group.c:214 sysfs_remove_group+0x59/0xe0()
     sysfs group ffffffff81c6c500 not found for kobject '0000:08'
     Modules linked in: ...
     CPU: 3 PID: 76 Comm: kworker/u16:7 Not tainted 3.13.0-rc1+ #76
     Hardware name: Acer Aspire S5-391/Venus    , BIOS V1.02 05/29/2012
     Workqueue: kacpi_hotplug acpi_hotplug_work_fn
      0000000000000009 ffff8801644b9ac8 ffffffff816b23bf 0000000000000007
      ffff8801644b9b18 ffff8801644b9b08 ffffffff81046607 ffff88016925b800
      0000000000000000 ffffffff81c6c500 ffff88016924f928 ffff88016924f800
     Call Trace:
      [<ffffffff816b23bf>] dump_stack+0x4e/0x71
      [<ffffffff81046607>] warn_slowpath_common+0x87/0xb0
      [<ffffffff810466d1>] warn_slowpath_fmt+0x41/0x50
      [<ffffffff811e42ef>] ? sysfs_get_dirent_ns+0x6f/0x80
      [<ffffffff811e5389>] sysfs_remove_group+0x59/0xe0
      [<ffffffff8149f00b>] dpm_sysfs_remove+0x3b/0x50
      [<ffffffff81495818>] device_del+0x58/0x1c0
      [<ffffffff814959c8>] device_unregister+0x48/0x60
      [<ffffffff813254fe>] pci_remove_bus+0x6e/0x80
      [<ffffffff81325548>] pci_remove_bus_device+0x38/0x110
      [<ffffffff8132555d>] pci_remove_bus_device+0x4d/0x110
      [<ffffffff81325639>] pci_stop_and_remove_bus_device+0x19/0x20
      [<ffffffff813418d0>] disable_slot+0x20/0xe0
      [<ffffffff81341a38>] acpiphp_check_bridge+0xa8/0xd0
      [<ffffffff813427ad>] hotplug_event+0x17d/0x220
      [<ffffffff81342880>] hotplug_event_work+0x30/0x70
      [<ffffffff8136d665>] acpi_hotplug_work_fn+0x18/0x24
      [<ffffffff81061331>] process_one_work+0x261/0x450
      [<ffffffff81061a7e>] worker_thread+0x21e/0x370
      [<ffffffff81061860>] ? rescuer_thread+0x300/0x300
      [<ffffffff81068342>] kthread+0xd2/0xe0
      [<ffffffff81068270>] ? flush_kthread_worker+0x70/0x70
      [<ffffffff816c19bc>] ret_from_fork+0x7c/0xb0
      [<ffffffff81068270>] ? flush_kthread_worker+0x70/0x70
    
    (Mika Westerberg sees them too in his tests).
    
    Some investigation documented in kernel bug #65281 led me to the
    conclusion that the source of the problem is the device_del() in
    pci_stop_dev() as it now causes the sysfs directory of the device to be
    removed recursively along with all of its subdirectories.  That includes
    the sysfs directory of the device's subordinate bus (dev->subordinate) and
    its "power" group.
    
    Consequently, when pci_remove_bus() is called for dev->subordinate in
    pci_remove_bus_device(), it calls device_unregister(&bus->dev), but at this
    point the sysfs directory of bus->dev doesn't exist any more and its
    "power" group doesn't exist either.  Thus, when dpm_sysfs_remove() called
    from device_del() tries to remove that group, it triggers the above
    warning.
    
    That indicates a logical mistake in the design of
    pci_stop_and_remove_bus_device(), which causes bus device objects to be
    left behind their parents (bridge device objects) and can be fixed by
    moving the device_del() from pci_stop_dev() into pci_destroy_dev(), so
    pci_remove_bus() can be called for the device's subordinate bus before the
    device itself is unregistered from the hierarchy.  Still, the driver, if
    any, should be detached from the device in pci_stop_dev(), so use
    device_release_driver() directly from there.
    
    References: https://bugzilla.kernel.org/show_bug.cgi?id=65281#c6
    Reported-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/remove.c b/drivers/pci/remove.c
index 1576851028db..cc9337a71529 100644
--- a/drivers/pci/remove.c
+++ b/drivers/pci/remove.c
@@ -24,7 +24,7 @@ static void pci_stop_dev(struct pci_dev *dev)
 	if (dev->is_added) {
 		pci_proc_detach_device(dev);
 		pci_remove_sysfs_dev_files(dev);
-		device_del(&dev->dev);
+		device_release_driver(&dev->dev);
 		dev->is_added = 0;
 	}
 
@@ -34,6 +34,8 @@ static void pci_stop_dev(struct pci_dev *dev)
 
 static void pci_destroy_dev(struct pci_dev *dev)
 {
+	device_del(&dev->dev);
+
 	down_write(&pci_bus_sem);
 	list_del(&dev->bus_list);
 	up_write(&pci_bus_sem);

commit f7625980f5820edd1a73536e1a03bcbc1f889fec
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Nov 14 11:28:18 2013 -0700

    PCI: Fix whitespace, capitalization, and spelling errors
    
    Fix whitespace, capitalization, and spelling errors.  No functional change.
    I know "busses" is not an error, but "buses" was more common, so I used it
    consistently.
    
    Signed-off-by: Marta Rybczynska <rybczynska@gmail.com> (pci_reset_bridge_secondary_bus())
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/remove.c b/drivers/pci/remove.c
index 8fc54b7327bc..1576851028db 100644
--- a/drivers/pci/remove.c
+++ b/drivers/pci/remove.c
@@ -7,7 +7,7 @@ static void pci_free_resources(struct pci_dev *dev)
 {
 	int i;
 
- 	msi_remove_pci_irq_vectors(dev);
+	msi_remove_pci_irq_vectors(dev);
 
 	pci_cleanup_rom(dev);
 	for (i = 0; i < PCI_NUM_RESOURCES; i++) {

commit 10a9574756201fbbdd0cac11f370f00d3d02bfa1
Author: Jiang Liu <liuj97@gmail.com>
Date:   Fri Apr 12 05:44:20 2013 +0000

    PCI: Add pcibios hooks for adding and removing PCI buses
    
    On ACPI-based platforms, the pci_slot driver creates PCI slot devices
    according to information from ACPI tables by registering an ACPI PCI
    subdriver.  The ACPI PCI subdriver will only be called when creating/
    destroying PCI root buses, and it won't be called when hot-plugging
    P2P bridges.  It may cause stale PCI slot devices after hot-removing
    a P2P bridge if that bridge has associated PCI slots.  And the acpiphp
    driver has the same issue too.
    
    This patch introduces two hook points into the PCI core, which will
    be invoked when creating/destroying PCI buses for PCI host and P2P
    bridges.  They could be used to setup/destroy platform dependent stuff
    in a unified way, both at boot time and for PCI hotplug operations.
    
    Signed-off-by: Jiang Liu <jiang.liu@huawei.com>
    Signed-off-by: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Yinghai Lu <yinghai@kernel.org>
    Cc: "Rafael J. Wysocki" <rafael.j.wysocki@intel.com>
    Cc: Toshi Kani <toshi.kani@hp.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Fenghua Yu <fenghua.yu@intel.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Myron Stowe <myron.stowe@redhat.com>

diff --git a/drivers/pci/remove.c b/drivers/pci/remove.c
index a8318801c092..8fc54b7327bc 100644
--- a/drivers/pci/remove.c
+++ b/drivers/pci/remove.c
@@ -51,6 +51,7 @@ void pci_remove_bus(struct pci_bus *bus)
 	pci_bus_release_busn_res(bus);
 	up_write(&pci_bus_sem);
 	pci_remove_legacy_files(bus);
+	pcibios_remove_bus(bus);
 	device_unregister(&bus->dev);
 }
 EXPORT_SYMBOL(pci_remove_bus);

commit 1e89d268e7a83d8388d4d09d3f2089ced72cc15f
Author: Jiang Liu <liuj97@gmail.com>
Date:   Fri Apr 12 05:44:15 2013 +0000

    PCI: When removing bus, always remove legacy files & unregister
    
    We always call device_register() and pci_create_legacy_files() for a
    new bus before handing out the "struct pci_bus *".  Therefore, there's
    no possiblity of removing the bus with pci_remove_bus() before those
    calls have been made, so we don't need to check "bus->is_added" before
    calling pci_remove_legacy_files() and device_unregister().
    
    [bhelgaas: changelog]
    Signed-off-by: Jiang Liu <jiang.liu@huawei.com>
    Signed-off-by: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Yinghai Lu <yinghai@kernel.org>
    Cc: "Rafael J. Wysocki" <rafael.j.wysocki@intel.com>
    Cc: Toshi Kani <toshi.kani@hp.com>

diff --git a/drivers/pci/remove.c b/drivers/pci/remove.c
index cc875e6ed159..a8318801c092 100644
--- a/drivers/pci/remove.c
+++ b/drivers/pci/remove.c
@@ -50,9 +50,6 @@ void pci_remove_bus(struct pci_bus *bus)
 	list_del(&bus->node);
 	pci_bus_release_busn_res(bus);
 	up_write(&pci_bus_sem);
-	if (!bus->is_added)
-		return;
-
 	pci_remove_legacy_files(bus);
 	device_unregister(&bus->dev);
 }

commit 556f12f602ac0a18a82ca83e9f8e8547688fc633
Merge: fffddfd6c8e0 018ba0a6efad
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Feb 25 21:18:18 2013 -0800

    Merge tag 'pci-v3.9-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI changes from Bjorn Helgaas:
     "Host bridge hotplug
        - Major overhaul of ACPI host bridge add/start (Rafael Wysocki, Yinghai Lu)
        - Major overhaul of PCI/ACPI binding (Rafael Wysocki, Yinghai Lu)
        - Split out ACPI host bridge and ACPI PCI device hotplug (Yinghai Lu)
        - Stop caching _PRT and make independent of bus numbers (Yinghai Lu)
    
      PCI device hotplug
        - Clean up cpqphp dead code (Sasha Levin)
        - Disable ARI unless device and upstream bridge support it (Yijing Wang)
        - Initialize all hot-added devices (not functions 0-7) (Yijing Wang)
    
      Power management
        - Don't touch ASPM if disabled (Joe Lawrence)
        - Fix ASPM link state management (Myron Stowe)
    
      Miscellaneous
        - Fix PCI_EXP_FLAGS accessor (Alex Williamson)
        - Disable Bus Master in pci_device_shutdown (Konstantin Khlebnikov)
        - Document hotplug resource and MPS parameters (Yijing Wang)
        - Add accessor for PCIe capabilities (Myron Stowe)
        - Drop pciehp suspend/resume messages (Paul Bolle)
        - Make pci_slot built-in only (not a module) (Jiang Liu)
        - Remove unused PCI/ACPI bind ops (Jiang Liu)
        - Removed used pci_root_bus (Bjorn Helgaas)"
    
    * tag 'pci-v3.9-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (51 commits)
      PCI/ACPI: Don't cache _PRT, and don't associate them with bus numbers
      PCI: Fix PCI Express Capability accessors for PCI_EXP_FLAGS
      ACPI / PCI: Make pci_slot built-in only, not a module
      PCI/PM: Clear state_saved during suspend
      PCI: Use atomic_inc_return() rather than atomic_add_return()
      PCI: Catch attempts to disable already-disabled devices
      PCI: Disable Bus Master unconditionally in pci_device_shutdown()
      PCI: acpiphp: Remove dead code for PCI host bridge hotplug
      PCI: acpiphp: Create companion ACPI devices before creating PCI devices
      PCI: Remove unused "rc" in virtfn_add_bus()
      PCI: pciehp: Drop suspend/resume ENTRY messages
      PCI/ASPM: Don't touch ASPM if forcibly disabled
      PCI/ASPM: Deallocate upstream link state even if device is not PCIe
      PCI: Document MPS parameters pci=pcie_bus_safe, pci=pcie_bus_perf, etc
      PCI: Document hpiosize= and hpmemsize= resource reservation parameters
      PCI: Use PCI Express Capability accessor
      PCI: Introduce accessor to retrieve PCIe Capabilities Register
      PCI: Put pci_dev in device tree as early as possible
      PCI: Skip attaching driver in device_add()
      PCI: acpiphp: Keep driver loaded even if no slots found
      ...

commit 249bfb83cf8ba658955f0245ac3981d941f746ee
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Feb 11 20:49:49 2013 +0100

    PCI/PM: Clean up PME state when removing a device
    
    Devices are added to pci_pme_list when drivers use pci_enable_wake()
    or pci_wake_from_d3(), but they aren't removed from the list unless
    the driver explicitly disables wakeup.  Many drivers never disable
    wakeup, so their devices remain on the list even after they are
    removed, e.g., via hotplug.  A subsequent PME poll will oops when
    it tries to touch the device.
    
    This patch disables PME# on a device before removing it, which removes
    the device from pci_pme_list.  This is safe even if the device never
    had PME# enabled.
    
    This oops can be triggered by unplugging a Thunderbolt ethernet adapter
    on a Macbook Pro, as reported by Daniel below.
    
    [bhelgaas: changelog]
    Reference: http://lkml.kernel.org/r/CAMVG2svG21yiM1wkH4_2pen2n+cr2-Zv7TbH3Gj+8MwevZjDbw@mail.gmail.com
    Reported-and-tested-by: Daniel J Blueman <daniel@quora.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    CC: stable@vger.kernel.org

diff --git a/drivers/pci/remove.c b/drivers/pci/remove.c
index 7c0fd9252e6f..84954a726a94 100644
--- a/drivers/pci/remove.c
+++ b/drivers/pci/remove.c
@@ -19,6 +19,8 @@ static void pci_free_resources(struct pci_dev *dev)
 
 static void pci_stop_dev(struct pci_dev *dev)
 {
+	pci_pme_active(dev, false);
+
 	if (dev->is_added) {
 		pci_proc_detach_device(dev);
 		pci_remove_sysfs_dev_files(dev);

commit e723f0b4f4ecaf3fdd542124b3f99379ab8df757
Author: Jiang Liu <jiang.liu@huawei.com>
Date:   Mon Jan 21 13:20:46 2013 -0800

    PCI: Make device create/destroy logic symmetric
    
    According to device model documentation, the way to create/destroy PCI
    devices should be symmetric.  The rule is to either use
      1) device_register()/device_unregister()
    or
      2) device_initialize()/device_add()/device_del()/put_device().
    
    So change PCI core logic to follow the rule and get rid of the redundant
    pci_dev_get()/pci_dev_put() pair.
    
    Signed-off-by: Jiang Liu <jiang.liu@huawei.com>
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/remove.c b/drivers/pci/remove.c
index 7c0fd9252e6f..fc38c4883e1d 100644
--- a/drivers/pci/remove.c
+++ b/drivers/pci/remove.c
@@ -22,7 +22,7 @@ static void pci_stop_dev(struct pci_dev *dev)
 	if (dev->is_added) {
 		pci_proc_detach_device(dev);
 		pci_remove_sysfs_dev_files(dev);
-		device_unregister(&dev->dev);
+		device_del(&dev->dev);
 		dev->is_added = 0;
 	}
 
@@ -37,7 +37,7 @@ static void pci_destroy_dev(struct pci_dev *dev)
 	up_write(&pci_bus_sem);
 
 	pci_free_resources(dev);
-	pci_dev_put(dev);
+	put_device(&dev->dev);
 }
 
 void pci_remove_bus(struct pci_bus *bus)

commit cdfcc572be0a8b423cecfb4ab5fd735fafe9c54a
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Tue Oct 30 14:31:38 2012 -0600

    PCI: Add pci_stop_and_remove_root_bus()
    
    It supports both PCI root bus and PCI bus under PCI bridge.
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/remove.c b/drivers/pci/remove.c
index 513972f3ed13..7c0fd9252e6f 100644
--- a/drivers/pci/remove.c
+++ b/drivers/pci/remove.c
@@ -111,3 +111,39 @@ void pci_stop_and_remove_bus_device(struct pci_dev *dev)
 	pci_remove_bus_device(dev);
 }
 EXPORT_SYMBOL(pci_stop_and_remove_bus_device);
+
+void pci_stop_root_bus(struct pci_bus *bus)
+{
+	struct pci_dev *child, *tmp;
+	struct pci_host_bridge *host_bridge;
+
+	if (!pci_is_root_bus(bus))
+		return;
+
+	host_bridge = to_pci_host_bridge(bus->bridge);
+	list_for_each_entry_safe_reverse(child, tmp,
+					 &bus->devices, bus_list)
+		pci_stop_bus_device(child);
+
+	/* stop the host bridge */
+	device_del(&host_bridge->dev);
+}
+
+void pci_remove_root_bus(struct pci_bus *bus)
+{
+	struct pci_dev *child, *tmp;
+	struct pci_host_bridge *host_bridge;
+
+	if (!pci_is_root_bus(bus))
+		return;
+
+	host_bridge = to_pci_host_bridge(bus->bridge);
+	list_for_each_entry_safe(child, tmp,
+				 &bus->devices, bus_list)
+		pci_remove_bus_device(child);
+	pci_remove_bus(bus);
+	host_bridge->bus = NULL;
+
+	/* remove the host bridge */
+	put_device(&host_bridge->dev);
+}

commit 3891b6acb4f443cbe2e99367ee5e67c6bc29d446
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Wed Sep 19 11:54:20 2012 -0700

    PCI: Stop all children first, before removing all children
    
    This restores the previous behavior of stopping all child devices before
    removing any of them.  The current SR-IOV design, where removing the PF
    also drops references on all the VFs, depends on having the VFs continue
    to exist after having been stopped.
    
    [bhelgaas: changelog]
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/remove.c b/drivers/pci/remove.c
index 4f9ca9162895..513972f3ed13 100644
--- a/drivers/pci/remove.c
+++ b/drivers/pci/remove.c
@@ -56,25 +56,13 @@ void pci_remove_bus(struct pci_bus *bus)
 }
 EXPORT_SYMBOL(pci_remove_bus);
 
-/**
- * pci_stop_and_remove_bus_device - remove a PCI device and any children
- * @dev: the device to remove
- *
- * Remove a PCI device from the device lists, informing the drivers
- * that the device has been removed.  We also remove any subordinate
- * buses and children in a depth-first manner.
- *
- * For each device we remove, delete the device structure from the
- * device lists, remove the /proc entry, and notify userspace
- * (/sbin/hotplug).
- */
-void pci_stop_and_remove_bus_device(struct pci_dev *dev)
+static void pci_stop_bus_device(struct pci_dev *dev)
 {
 	struct pci_bus *bus = dev->subordinate;
 	struct pci_dev *child, *tmp;
 
 	/*
-	 * Removing an SR-IOV PF device removes all the associated VFs,
+	 * Stopping an SR-IOV PF device removes all the associated VFs,
 	 * which will update the bus->devices list and confuse the
 	 * iterator.  Therefore, iterate in reverse so we remove the VFs
 	 * first, then the PF.
@@ -82,13 +70,44 @@ void pci_stop_and_remove_bus_device(struct pci_dev *dev)
 	if (bus) {
 		list_for_each_entry_safe_reverse(child, tmp,
 						 &bus->devices, bus_list)
-			pci_stop_and_remove_bus_device(child);
+			pci_stop_bus_device(child);
+	}
+
+	pci_stop_dev(dev);
+}
+
+static void pci_remove_bus_device(struct pci_dev *dev)
+{
+	struct pci_bus *bus = dev->subordinate;
+	struct pci_dev *child, *tmp;
+
+	if (bus) {
+		list_for_each_entry_safe(child, tmp,
+					 &bus->devices, bus_list)
+			pci_remove_bus_device(child);
 
 		pci_remove_bus(bus);
 		dev->subordinate = NULL;
 	}
 
-	pci_stop_dev(dev);
 	pci_destroy_dev(dev);
 }
+
+/**
+ * pci_stop_and_remove_bus_device - remove a PCI device and any children
+ * @dev: the device to remove
+ *
+ * Remove a PCI device from the device lists, informing the drivers
+ * that the device has been removed.  We also remove any subordinate
+ * buses and children in a depth-first manner.
+ *
+ * For each device we remove, delete the device structure from the
+ * device lists, remove the /proc entry, and notify userspace
+ * (/sbin/hotplug).
+ */
+void pci_stop_and_remove_bus_device(struct pci_dev *dev)
+{
+	pci_stop_bus_device(dev);
+	pci_remove_bus_device(dev);
+}
 EXPORT_SYMBOL(pci_stop_and_remove_bus_device);

commit a7479d74460a4873b73534aa89cb82ab70ff8a32
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Aug 16 21:12:38 2012 -0600

    PCI: Leave normal LIST_POISON in deleted list entries
    
    list_del() already sets next/prev to LIST_POISON1/LIST_POISON2, so we
    don't need to do anything special here to prevent further list accesses.
    
    Tested-by: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>

diff --git a/drivers/pci/remove.c b/drivers/pci/remove.c
index c01bacad9fd9..4f9ca9162895 100644
--- a/drivers/pci/remove.c
+++ b/drivers/pci/remove.c
@@ -32,11 +32,8 @@ static void pci_stop_dev(struct pci_dev *dev)
 
 static void pci_destroy_dev(struct pci_dev *dev)
 {
-	/* Remove the device from the device lists, and prevent any further
-	 * list accesses from this device */
 	down_write(&pci_bus_sem);
 	list_del(&dev->bus_list);
-	dev->bus_list.next = dev->bus_list.prev = NULL;
 	up_write(&pci_bus_sem);
 
 	pci_free_resources(dev);

commit d563e2ccc8adb1385da42e6077736ba6854117bb
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Aug 16 20:43:11 2012 -0600

    PCI: Rename local variables to conventional names
    
    "bus" is the conventional name for a "struct pci_bus *" variable.
    
    Tested-by: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>

diff --git a/drivers/pci/remove.c b/drivers/pci/remove.c
index 44f479f08fff..c01bacad9fd9 100644
--- a/drivers/pci/remove.c
+++ b/drivers/pci/remove.c
@@ -43,19 +43,19 @@ static void pci_destroy_dev(struct pci_dev *dev)
 	pci_dev_put(dev);
 }
 
-void pci_remove_bus(struct pci_bus *pci_bus)
+void pci_remove_bus(struct pci_bus *bus)
 {
-	pci_proc_detach_bus(pci_bus);
+	pci_proc_detach_bus(bus);
 
 	down_write(&pci_bus_sem);
-	list_del(&pci_bus->node);
-	pci_bus_release_busn_res(pci_bus);
+	list_del(&bus->node);
+	pci_bus_release_busn_res(bus);
 	up_write(&pci_bus_sem);
-	if (!pci_bus->is_added)
+	if (!bus->is_added)
 		return;
 
-	pci_remove_legacy_files(pci_bus);
-	device_unregister(&pci_bus->dev);
+	pci_remove_legacy_files(bus);
+	device_unregister(&bus->dev);
 }
 EXPORT_SYMBOL(pci_remove_bus);
 

commit 7990681ad8215977b27ac855520720193de2c98f
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Aug 16 20:38:50 2012 -0600

    PCI: Remove unused, commented-out, code
    
    This removes unused code that was already commented out.
    
    Tested-by: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>

diff --git a/drivers/pci/remove.c b/drivers/pci/remove.c
index 38281042c31c..44f479f08fff 100644
--- a/drivers/pci/remove.c
+++ b/drivers/pci/remove.c
@@ -43,25 +43,6 @@ static void pci_destroy_dev(struct pci_dev *dev)
 	pci_dev_put(dev);
 }
 
-/**
- * pci_remove_device_safe - remove an unused hotplug device
- * @dev: the device to remove
- *
- * Delete the device structure from the device lists and 
- * notify userspace (/sbin/hotplug), but only if the device
- * in question is not being used by a driver.
- * Returns 0 on success.
- */
-#if 0
-int pci_remove_device_safe(struct pci_dev *dev)
-{
-	if (pci_dev_driver(dev))
-		return -EBUSY;
-	pci_destroy_dev(dev);
-	return 0;
-}
-#endif  /*  0  */
-
 void pci_remove_bus(struct pci_bus *pci_bus)
 {
 	pci_proc_detach_bus(pci_bus);

commit 282e1d655fe7c7c2e6b0dd8166c4c6b7c2a1219b
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Aug 17 11:57:48 2012 -0600

    PCI: Stop and remove devices in one pass
    
    Previously, when we removed a PCI device, we made two passes over the
    hierarchy rooted at the device.  In the first pass, we stopped all
    the devices, and in the second, we removed them.
    
    This patch combines the two passes into one so that we remove a device as
    soon as it and all its children have been stopped.
    
    Note that we previously stopped devices in reverse order and removed them
    in forward order.  Now we stop and remove them in reverse order.
    
    Tested-by: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>

diff --git a/drivers/pci/remove.c b/drivers/pci/remove.c
index 30d002e83e2d..38281042c31c 100644
--- a/drivers/pci/remove.c
+++ b/drivers/pci/remove.c
@@ -78,8 +78,6 @@ void pci_remove_bus(struct pci_bus *pci_bus)
 }
 EXPORT_SYMBOL(pci_remove_bus);
 
-static void pci_stop_bus_device(struct pci_dev *dev);
-
 /**
  * pci_stop_and_remove_bus_device - remove a PCI device and any children
  * @dev: the device to remove
@@ -92,37 +90,7 @@ static void pci_stop_bus_device(struct pci_dev *dev);
  * device lists, remove the /proc entry, and notify userspace
  * (/sbin/hotplug).
  */
-static void __pci_remove_bus_device(struct pci_dev *dev)
-{
-	struct pci_bus *bus = dev->subordinate;
-	struct pci_dev *child, *tmp;
-
-	if (bus) {
-		list_for_each_entry_safe(child, tmp, &bus->devices, bus_list)
-			__pci_remove_bus_device(child);
-
-		pci_remove_bus(bus);
-		dev->subordinate = NULL;
-	}
-
-	pci_destroy_dev(dev);
-}
-
 void pci_stop_and_remove_bus_device(struct pci_dev *dev)
-{
-	pci_stop_bus_device(dev);
-	__pci_remove_bus_device(dev);
-}
-
-/**
- * pci_stop_bus_device - stop a PCI device and any children
- * @dev: the device to stop
- *
- * Stop a PCI device (detach the driver, remove from the global list
- * and so on). This also stop any subordinate buses and children in a
- * depth-first manner.
- */
-static void pci_stop_bus_device(struct pci_dev *dev)
 {
 	struct pci_bus *bus = dev->subordinate;
 	struct pci_dev *child, *tmp;
@@ -133,12 +101,16 @@ static void pci_stop_bus_device(struct pci_dev *dev)
 	 * iterator.  Therefore, iterate in reverse so we remove the VFs
 	 * first, then the PF.
 	 */
-	if (bus)
+	if (bus) {
 		list_for_each_entry_safe_reverse(child, tmp,
 						 &bus->devices, bus_list)
-			pci_stop_bus_device(child);
+			pci_stop_and_remove_bus_device(child);
+
+		pci_remove_bus(bus);
+		dev->subordinate = NULL;
+	}
 
 	pci_stop_dev(dev);
+	pci_destroy_dev(dev);
 }
-
 EXPORT_SYMBOL(pci_stop_and_remove_bus_device);

commit 2ed168eeb3edec029aa0eca5cb981d6376f931f9
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Aug 17 11:25:01 2012 -0600

    PCI: Fold stop and remove helpers into their callers
    
    pci_stop_bus_devices() is only two lines of code and is only called by
    pci_stop_bus_device(), so I think it's easier to read if we just fold it
    into the caller.  Similarly for __pci_remove_behind_bridge().
    
    Tested-by: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>

diff --git a/drivers/pci/remove.c b/drivers/pci/remove.c
index f17a02781e67..30d002e83e2d 100644
--- a/drivers/pci/remove.c
+++ b/drivers/pci/remove.c
@@ -78,7 +78,6 @@ void pci_remove_bus(struct pci_bus *pci_bus)
 }
 EXPORT_SYMBOL(pci_remove_bus);
 
-static void __pci_remove_behind_bridge(struct pci_dev *dev);
 static void pci_stop_bus_device(struct pci_dev *dev);
 
 /**
@@ -95,11 +94,14 @@ static void pci_stop_bus_device(struct pci_dev *dev);
  */
 static void __pci_remove_bus_device(struct pci_dev *dev)
 {
-	if (dev->subordinate) {
-		struct pci_bus *b = dev->subordinate;
+	struct pci_bus *bus = dev->subordinate;
+	struct pci_dev *child, *tmp;
+
+	if (bus) {
+		list_for_each_entry_safe(child, tmp, &bus->devices, bus_list)
+			__pci_remove_bus_device(child);
 
-		__pci_remove_behind_bridge(dev);
-		pci_remove_bus(b);
+		pci_remove_bus(bus);
 		dev->subordinate = NULL;
 	}
 
@@ -112,32 +114,6 @@ void pci_stop_and_remove_bus_device(struct pci_dev *dev)
 	__pci_remove_bus_device(dev);
 }
 
-static void __pci_remove_behind_bridge(struct pci_dev *dev)
-{
-	struct pci_dev *child, *tmp;
-
-	if (dev->subordinate)
-		list_for_each_entry_safe(child, tmp,
-					 &dev->subordinate->devices, bus_list)
-			__pci_remove_bus_device(child);
-}
-
-static void pci_stop_bus_devices(struct pci_bus *bus)
-{
-	struct pci_dev *dev, *tmp;
-
-	/*
-	 * VFs could be removed by pci_stop_and_remove_bus_device() in the
-	 *  pci_stop_bus_devices() code path for PF.
-	 *  aka, bus->devices get updated in the process.
-	 * but VFs are inserted after PFs when SRIOV is enabled for PF,
-	 * We can iterate the list backwards to get prev valid PF instead
-	 *  of removed VF.
-	 */
-	list_for_each_entry_safe_reverse(dev, tmp, &bus->devices, bus_list)
-		pci_stop_bus_device(dev);
-}
-
 /**
  * pci_stop_bus_device - stop a PCI device and any children
  * @dev: the device to stop
@@ -148,8 +124,19 @@ static void pci_stop_bus_devices(struct pci_bus *bus)
  */
 static void pci_stop_bus_device(struct pci_dev *dev)
 {
-	if (dev->subordinate)
-		pci_stop_bus_devices(dev->subordinate);
+	struct pci_bus *bus = dev->subordinate;
+	struct pci_dev *child, *tmp;
+
+	/*
+	 * Removing an SR-IOV PF device removes all the associated VFs,
+	 * which will update the bus->devices list and confuse the
+	 * iterator.  Therefore, iterate in reverse so we remove the VFs
+	 * first, then the PF.
+	 */
+	if (bus)
+		list_for_each_entry_safe_reverse(child, tmp,
+						 &bus->devices, bus_list)
+			pci_stop_bus_device(child);
 
 	pci_stop_dev(dev);
 }

commit 66455f5472383df3632140e04f0852215e5c9ce8
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Aug 17 15:53:27 2012 -0600

    PCI: Use list_for_each_entry() for bus->devices traversal
    
    Replace list_for_each() + pci_dev_b() with the simpler
    list_for_each_entry().
    
    Tested-by: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>

diff --git a/drivers/pci/remove.c b/drivers/pci/remove.c
index b18dc2ef09f2..f17a02781e67 100644
--- a/drivers/pci/remove.c
+++ b/drivers/pci/remove.c
@@ -114,16 +114,17 @@ void pci_stop_and_remove_bus_device(struct pci_dev *dev)
 
 static void __pci_remove_behind_bridge(struct pci_dev *dev)
 {
-	struct list_head *l, *n;
+	struct pci_dev *child, *tmp;
 
 	if (dev->subordinate)
-		list_for_each_safe(l, n, &dev->subordinate->devices)
-			__pci_remove_bus_device(pci_dev_b(l));
+		list_for_each_entry_safe(child, tmp,
+					 &dev->subordinate->devices, bus_list)
+			__pci_remove_bus_device(child);
 }
 
 static void pci_stop_bus_devices(struct pci_bus *bus)
 {
-	struct list_head *l, *n;
+	struct pci_dev *dev, *tmp;
 
 	/*
 	 * VFs could be removed by pci_stop_and_remove_bus_device() in the
@@ -133,10 +134,8 @@ static void pci_stop_bus_devices(struct pci_bus *bus)
 	 * We can iterate the list backwards to get prev valid PF instead
 	 *  of removed VF.
 	 */
-	list_for_each_prev_safe(l, n, &bus->devices) {
-		struct pci_dev *dev = pci_dev_b(l);
+	list_for_each_entry_safe_reverse(dev, tmp, &bus->devices, bus_list)
 		pci_stop_bus_device(dev);
-	}
 }
 
 /**

commit 125e14bb35e65b1ddfb7252fa8f6e3c50dbb6db2
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Aug 17 11:07:49 2012 -0600

    PCI: Remove pci_stop_and_remove_behind_bridge()
    
    The PCMCIA CardBus driver was the only user of
    pci_stop_and_remove_behind_bridge(), and it now uses
    pci_stop_and_remove_bus_device() instead, so remove this interface.
    
    This removes exported symbol pci_stop_and_remove_behind_bridge.
    
    Tested-by: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>

diff --git a/drivers/pci/remove.c b/drivers/pci/remove.c
index 534377f967ff..b18dc2ef09f2 100644
--- a/drivers/pci/remove.c
+++ b/drivers/pci/remove.c
@@ -121,30 +121,6 @@ static void __pci_remove_behind_bridge(struct pci_dev *dev)
 			__pci_remove_bus_device(pci_dev_b(l));
 }
 
-static void pci_stop_behind_bridge(struct pci_dev *dev)
-{
-	struct list_head *l, *n;
-
-	if (dev->subordinate)
-		list_for_each_safe(l, n, &dev->subordinate->devices)
-			pci_stop_bus_device(pci_dev_b(l));
-}
-
-/**
- * pci_stop_and_remove_behind_bridge - stop and remove all devices behind
- *					 a PCI bridge
- * @dev: PCI bridge device
- *
- * Remove all devices on the bus, except for the parent bridge.
- * This also removes any child buses, and any devices they may
- * contain in a depth-first manner.
- */
-void pci_stop_and_remove_behind_bridge(struct pci_dev *dev)
-{
-	pci_stop_behind_bridge(dev);
-	__pci_remove_behind_bridge(dev);
-}
-
 static void pci_stop_bus_devices(struct pci_bus *bus)
 {
 	struct list_head *l, *n;
@@ -180,4 +156,3 @@ static void pci_stop_bus_device(struct pci_dev *dev)
 }
 
 EXPORT_SYMBOL(pci_stop_and_remove_bus_device);
-EXPORT_SYMBOL(pci_stop_and_remove_behind_bridge);

commit 657c2077a2dab228fcf28a708df1b1bcf4195803
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Aug 17 10:07:00 2012 -0600

    PCI: Don't export stop_bus_device and remove_bus_device interfaces
    
    The acpiphp hotplug driver was the only user of pci_stop_bus_device() and
    __pci_remove_bus_device(), and it now uses pci_stop_and_remove_bus_device()
    instead, so stop exposing these interfaces.
    
    This removes these exported symbols:
    
        __pci_remove_bus_device
        pci_stop_bus_device
    
    Tested-by: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>

diff --git a/drivers/pci/remove.c b/drivers/pci/remove.c
index 04a4861b4749..534377f967ff 100644
--- a/drivers/pci/remove.c
+++ b/drivers/pci/remove.c
@@ -79,6 +79,8 @@ void pci_remove_bus(struct pci_bus *pci_bus)
 EXPORT_SYMBOL(pci_remove_bus);
 
 static void __pci_remove_behind_bridge(struct pci_dev *dev);
+static void pci_stop_bus_device(struct pci_dev *dev);
+
 /**
  * pci_stop_and_remove_bus_device - remove a PCI device and any children
  * @dev: the device to remove
@@ -91,7 +93,7 @@ static void __pci_remove_behind_bridge(struct pci_dev *dev);
  * device lists, remove the /proc entry, and notify userspace
  * (/sbin/hotplug).
  */
-void __pci_remove_bus_device(struct pci_dev *dev)
+static void __pci_remove_bus_device(struct pci_dev *dev)
 {
 	if (dev->subordinate) {
 		struct pci_bus *b = dev->subordinate;
@@ -103,7 +105,6 @@ void __pci_remove_bus_device(struct pci_dev *dev)
 
 	pci_destroy_dev(dev);
 }
-EXPORT_SYMBOL(__pci_remove_bus_device);
 
 void pci_stop_and_remove_bus_device(struct pci_dev *dev)
 {
@@ -170,7 +171,7 @@ static void pci_stop_bus_devices(struct pci_bus *bus)
  * and so on). This also stop any subordinate buses and children in a
  * depth-first manner.
  */
-void pci_stop_bus_device(struct pci_dev *dev)
+static void pci_stop_bus_device(struct pci_dev *dev)
 {
 	if (dev->subordinate)
 		pci_stop_bus_devices(dev->subordinate);
@@ -180,4 +181,3 @@ void pci_stop_bus_device(struct pci_dev *dev)
 
 EXPORT_SYMBOL(pci_stop_and_remove_bus_device);
 EXPORT_SYMBOL(pci_stop_and_remove_behind_bridge);
-EXPORT_SYMBOL_GPL(pci_stop_bus_device);

commit f6dd68a77f9c07088eee71a1787cfc84dcf49198
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Thu May 17 18:51:11 2012 -0700

    PCI: release busn_res when removing bus
    
    Release bus number resource when removing a bus.
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/remove.c b/drivers/pci/remove.c
index fd77e2bde2e8..04a4861b4749 100644
--- a/drivers/pci/remove.c
+++ b/drivers/pci/remove.c
@@ -68,6 +68,7 @@ void pci_remove_bus(struct pci_bus *pci_bus)
 
 	down_write(&pci_bus_sem);
 	list_del(&pci_bus->node);
+	pci_bus_release_busn_res(pci_bus);
 	up_write(&pci_bus_sem);
 	if (!pci_bus->is_added)
 		return;

commit 6b22cf3f35fd332e4cc2c1b27056920b3643667a
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Sat Feb 25 13:54:21 2012 -0800

    PCI: export __pci_remove_bus_device
    
    Don't switch to pci_remove_bus_device yet, keep the __ prefix for now
    (the behavior is still the same: remove without stopping first).
    
    This allows other out of tree users or pending patches to get notified
    from compiler warning.
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/remove.c b/drivers/pci/remove.c
index bd2be1c4c668..fd77e2bde2e8 100644
--- a/drivers/pci/remove.c
+++ b/drivers/pci/remove.c
@@ -90,7 +90,7 @@ static void __pci_remove_behind_bridge(struct pci_dev *dev);
  * device lists, remove the /proc entry, and notify userspace
  * (/sbin/hotplug).
  */
-static void __pci_remove_bus_device(struct pci_dev *dev)
+void __pci_remove_bus_device(struct pci_dev *dev)
 {
 	if (dev->subordinate) {
 		struct pci_bus *b = dev->subordinate;
@@ -102,6 +102,8 @@ static void __pci_remove_bus_device(struct pci_dev *dev)
 
 	pci_destroy_dev(dev);
 }
+EXPORT_SYMBOL(__pci_remove_bus_device);
+
 void pci_stop_and_remove_bus_device(struct pci_dev *dev)
 {
 	pci_stop_bus_device(dev);

commit 6754b9e9c33502223db066de50dda8a876f70c2c
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Sat Feb 25 13:54:22 2012 -0800

    PCI: Rename pci_remove_behind_bridge to pci_stop_and_remove_behind_bridge
    
    The old pci_remove_behind_bridge actually do stop and remove.
    
    Make the name reflect that to reduce confusion.
    
    Suggested-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/remove.c b/drivers/pci/remove.c
index 7abe67b45cc8..bd2be1c4c668 100644
--- a/drivers/pci/remove.c
+++ b/drivers/pci/remove.c
@@ -127,14 +127,15 @@ static void pci_stop_behind_bridge(struct pci_dev *dev)
 }
 
 /**
- * pci_remove_behind_bridge - remove all devices behind a PCI bridge
+ * pci_stop_and_remove_behind_bridge - stop and remove all devices behind
+ *					 a PCI bridge
  * @dev: PCI bridge device
  *
  * Remove all devices on the bus, except for the parent bridge.
  * This also removes any child buses, and any devices they may
  * contain in a depth-first manner.
  */
-void pci_remove_behind_bridge(struct pci_dev *dev)
+void pci_stop_and_remove_behind_bridge(struct pci_dev *dev)
 {
 	pci_stop_behind_bridge(dev);
 	__pci_remove_behind_bridge(dev);
@@ -175,5 +176,5 @@ void pci_stop_bus_device(struct pci_dev *dev)
 }
 
 EXPORT_SYMBOL(pci_stop_and_remove_bus_device);
-EXPORT_SYMBOL(pci_remove_behind_bridge);
+EXPORT_SYMBOL(pci_stop_and_remove_behind_bridge);
 EXPORT_SYMBOL_GPL(pci_stop_bus_device);

commit 210647af897af8ef2d00828aa2a6b1b42206aae6
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Sat Feb 25 13:54:20 2012 -0800

    PCI: Rename pci_remove_bus_device to pci_stop_and_remove_bus_device
    
    The old pci_remove_bus_device actually did stop and remove.
    
    Make the name reflect that to reduce confusion.
    
    This patch is done by sed scripts and changes back some incorrect
    __pci_remove_bus_device changes.
    
    Suggested-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/remove.c b/drivers/pci/remove.c
index 82f8ae572703..7abe67b45cc8 100644
--- a/drivers/pci/remove.c
+++ b/drivers/pci/remove.c
@@ -79,7 +79,7 @@ EXPORT_SYMBOL(pci_remove_bus);
 
 static void __pci_remove_behind_bridge(struct pci_dev *dev);
 /**
- * pci_remove_bus_device - remove a PCI device and any children
+ * pci_stop_and_remove_bus_device - remove a PCI device and any children
  * @dev: the device to remove
  *
  * Remove a PCI device from the device lists, informing the drivers
@@ -102,7 +102,7 @@ static void __pci_remove_bus_device(struct pci_dev *dev)
 
 	pci_destroy_dev(dev);
 }
-void pci_remove_bus_device(struct pci_dev *dev)
+void pci_stop_and_remove_bus_device(struct pci_dev *dev)
 {
 	pci_stop_bus_device(dev);
 	__pci_remove_bus_device(dev);
@@ -145,7 +145,7 @@ static void pci_stop_bus_devices(struct pci_bus *bus)
 	struct list_head *l, *n;
 
 	/*
-	 * VFs could be removed by pci_remove_bus_device() in the
+	 * VFs could be removed by pci_stop_and_remove_bus_device() in the
 	 *  pci_stop_bus_devices() code path for PF.
 	 *  aka, bus->devices get updated in the process.
 	 * but VFs are inserted after PFs when SRIOV is enabled for PF,
@@ -174,6 +174,6 @@ void pci_stop_bus_device(struct pci_dev *dev)
 	pci_stop_dev(dev);
 }
 
-EXPORT_SYMBOL(pci_remove_bus_device);
+EXPORT_SYMBOL(pci_stop_and_remove_bus_device);
 EXPORT_SYMBOL(pci_remove_behind_bridge);
 EXPORT_SYMBOL_GPL(pci_stop_bus_device);

commit ac205b7bb72fa4227d2e79979bbe2b4687cdf44d
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Fri Jan 27 10:55:09 2012 -0800

    PCI: make sriov work with hotplug remove
    
    When hot removing a pci express module that has a pcie switch and supports
    SRIOV, we got:
    
    [ 5918.610127] pciehp 0000:80:02.2:pcie04: pcie_isr: intr_loc 1
    [ 5918.615779] pciehp 0000:80:02.2:pcie04: Attention button interrupt received
    [ 5918.622730] pciehp 0000:80:02.2:pcie04: Button pressed on Slot(3)
    [ 5918.629002] pciehp 0000:80:02.2:pcie04: pciehp_get_power_status: SLOTCTRL a8 value read 1f9
    [ 5918.637416] pciehp 0000:80:02.2:pcie04: PCI slot #3 - powering off due to button press.
    [ 5918.647125] pciehp 0000:80:02.2:pcie04: pcie_isr: intr_loc 10
    [ 5918.653039] pciehp 0000:80:02.2:pcie04: pciehp_green_led_blink: SLOTCTRL a8 write cmd 200
    [ 5918.661229] pciehp 0000:80:02.2:pcie04: pciehp_set_attention_status: SLOTCTRL a8 write cmd c0
    [ 5924.667627] pciehp 0000:80:02.2:pcie04: Disabling domain:bus:device=0000:b0:00
    [ 5924.674909] pciehp 0000:80:02.2:pcie04: pciehp_get_power_status: SLOTCTRL a8 value read 2f9
    [ 5924.683262] pciehp 0000:80:02.2:pcie04: pciehp_unconfigure_device: domain:bus:dev = 0000:b0:00
    [ 5924.693976] libfcoe_device_notification: NETDEV_UNREGISTER eth6
    [ 5924.764979] libfcoe_device_notification: NETDEV_UNREGISTER eth14
    [ 5924.873539] libfcoe_device_notification: NETDEV_UNREGISTER eth15
    [ 5924.995209] libfcoe_device_notification: NETDEV_UNREGISTER eth16
    [ 5926.114407] sxge 0000:b2:00.0: PCI INT A disabled
    [ 5926.119342] BUG: unable to handle kernel NULL pointer dereference at (null)
    [ 5926.127189] IP: [<ffffffff81353a3b>] pci_stop_bus_device+0x33/0x83
    [ 5926.133377] PGD 0
    [ 5926.135402] Oops: 0000 [#1] SMP
    [ 5926.138659] CPU 2
    [ 5926.140499] Modules linked in:
    ...
    [ 5926.143754]
    [ 5926.275823] Call Trace:
    [ 5926.278267]  [<ffffffff81353a38>] pci_stop_bus_device+0x30/0x83
    [ 5926.284180]  [<ffffffff81353af4>] pci_remove_bus_device+0x1a/0xba
    [ 5926.290264]  [<ffffffff81366311>] pciehp_unconfigure_device+0x110/0x17b
    [ 5926.296866]  [<ffffffff81365dd9>] ? pciehp_disable_slot+0x188/0x188
    [ 5926.303123]  [<ffffffff81365d6f>] pciehp_disable_slot+0x11e/0x188
    [ 5926.309206]  [<ffffffff81365e68>] pciehp_power_thread+0x8f/0xe0
    ...
    
     +-[0000:80]-+-00.0-[81-8f]--
     |           +-01.0-[90-9f]--
     |           +-02.0-[a0-af]--
     |           +-02.2-[b0-bf]----00.0-[b1-b3]--+-02.0-[b2]--+-00.0 Device
     |           |                               |            +-00.1 Device
     |           |                               |            +-00.2 Device
     |           |                               |            \-00.3 Device
     |           |                               \-03.0-[b3]--+-00.0 Device
     |           |                                            +-00.1 Device
     |           |                                            +-00.2 Device
     |           |                                            \-00.3 Device
    
    root complex: 80:02.2
    pci express modules: have pcie switch and are listed as b0:00.0, b1:02.0 and b1:03.0.
    end devices  are b2:00.0 and b3.00.0.
    VFs are: b2:00.1,... b2:00.3, and b3:00.1,...,b3:00.3
    
    Root cause: when doing pci_stop_bus_device() with phys fn, it will stop
    virt fn and remove the fn, so
            list_for_each_safe(l, n, &bus->devices)
    will have problem to refer freed n that is pointed to vf entry.
    
    Solution is just replacing list_for_each_safe() with
    list_for_each_prev_safe().  This will make sure we can get valid n pointer
    to PF instead of the freed VF pointer (because newly added devices are
    inserted to the bus->devices list tail).
    
    During reviewing the patch, Bjorn said:
    |   The PCI hot-remove path calls pci_stop_bus_devices() via
    |   pci_remove_bus_device().
    |
    |   pci_stop_bus_devices() traverses the bus->devices list (point A below),
    |   stopping each device in turn, which calls the driver remove() method.  When
    |   the device is an SR-IOV PF, the driver calls pci_disable_sriov(), which
    |   also uses pci_remove_bus_device() to remove the VF devices from the
    |   bus->devices list (point B).
    |
    |       pci_remove_bus_device
    |         pci_stop_bus_device
    |           pci_stop_bus_devices(subordinate)
    |             list_for_each(bus->devices)             <-- A
    |               pci_stop_bus_device(PF)
    |                 ...
    |                   driver->remove
    |                     pci_disable_sriov
    |                       ...
    |                         pci_remove_bus_device(VF)
    |                             <remove from bus_list>  <-- B
    |
    |   At B, we're changing the same list we're iterating through at A, so when
    |   the driver remove() method returns, the pci_stop_bus_devices() iterator has
    |   a pointer to a list entry that has already been freed.
    
    Discussion thread can be found : https://lkml.org/lkml/2011/10/15/141
                                     https://lkml.org/lkml/2012/1/23/360
    
    -v5: According to Linus to make remove more robust, Change to
         list_for_each_prev_safe instead. That is more reasonable, because
         those devices are added to tail of the list before.
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/remove.c b/drivers/pci/remove.c
index ef8b18c48f26..82f8ae572703 100644
--- a/drivers/pci/remove.c
+++ b/drivers/pci/remove.c
@@ -144,7 +144,15 @@ static void pci_stop_bus_devices(struct pci_bus *bus)
 {
 	struct list_head *l, *n;
 
-	list_for_each_safe(l, n, &bus->devices) {
+	/*
+	 * VFs could be removed by pci_remove_bus_device() in the
+	 *  pci_stop_bus_devices() code path for PF.
+	 *  aka, bus->devices get updated in the process.
+	 * but VFs are inserted after PFs when SRIOV is enabled for PF,
+	 * We can iterate the list backwards to get prev valid PF instead
+	 *  of removed VF.
+	 */
+	list_for_each_prev_safe(l, n, &bus->devices) {
 		struct pci_dev *dev = pci_dev_b(l);
 		pci_stop_bus_device(dev);
 	}

commit 3682a3946d2b0bad621db871e3bead83e523a238
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Sat Feb 4 22:55:00 2012 -0800

    PCI: Fix pci cardbus removal
    
    During test busn_res allocation with cardbus, found pci card removal is not
    working anymore, and it turns out it is broken by:
    
    |commit 79cc9601c3e42b4f0650fe7e69132ebce7ab48f9
    |Date:   Tue Nov 22 21:06:53 2011 -0800
    |
    |    PCI: Only call pci_stop_bus_device() one time for child devices at remove
    
    The above changed the behavior of pci_remove_behind_bridge that
    yenta_cardbus depended on.  So restore the old behavoir of
    pci_remove_behind_bridge (which requires stopping and removing of all
    devices) by:
    
    1. rename pci_remove_behind_bridge to __pci_remove_behind_bridge, and let
       __pci_remove_bus_device() call it instead.
    2. add pci_stop_behind_bridge that will stop devices behind a bridge
    3. add back pci_remove_behind_bridge that will stop and remove devices
       under bridge.
    
    -v2: update commit description a little bit.
    
    Tested-by: Dominik Brodowski <linux@dominikbrodowski.net>
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/remove.c b/drivers/pci/remove.c
index 6def3624c688..ef8b18c48f26 100644
--- a/drivers/pci/remove.c
+++ b/drivers/pci/remove.c
@@ -77,6 +77,7 @@ void pci_remove_bus(struct pci_bus *pci_bus)
 }
 EXPORT_SYMBOL(pci_remove_bus);
 
+static void __pci_remove_behind_bridge(struct pci_dev *dev);
 /**
  * pci_remove_bus_device - remove a PCI device and any children
  * @dev: the device to remove
@@ -94,7 +95,7 @@ static void __pci_remove_bus_device(struct pci_dev *dev)
 	if (dev->subordinate) {
 		struct pci_bus *b = dev->subordinate;
 
-		pci_remove_behind_bridge(dev);
+		__pci_remove_behind_bridge(dev);
 		pci_remove_bus(b);
 		dev->subordinate = NULL;
 	}
@@ -107,6 +108,24 @@ void pci_remove_bus_device(struct pci_dev *dev)
 	__pci_remove_bus_device(dev);
 }
 
+static void __pci_remove_behind_bridge(struct pci_dev *dev)
+{
+	struct list_head *l, *n;
+
+	if (dev->subordinate)
+		list_for_each_safe(l, n, &dev->subordinate->devices)
+			__pci_remove_bus_device(pci_dev_b(l));
+}
+
+static void pci_stop_behind_bridge(struct pci_dev *dev)
+{
+	struct list_head *l, *n;
+
+	if (dev->subordinate)
+		list_for_each_safe(l, n, &dev->subordinate->devices)
+			pci_stop_bus_device(pci_dev_b(l));
+}
+
 /**
  * pci_remove_behind_bridge - remove all devices behind a PCI bridge
  * @dev: PCI bridge device
@@ -117,11 +136,8 @@ void pci_remove_bus_device(struct pci_dev *dev)
  */
 void pci_remove_behind_bridge(struct pci_dev *dev)
 {
-	struct list_head *l, *n;
-
-	if (dev->subordinate)
-		list_for_each_safe(l, n, &dev->subordinate->devices)
-			__pci_remove_bus_device(pci_dev_b(l));
+	pci_stop_behind_bridge(dev);
+	__pci_remove_behind_bridge(dev);
 }
 
 static void pci_stop_bus_devices(struct pci_bus *bus)

commit 79cc9601c3e42b4f0650fe7e69132ebce7ab48f9
Author: Yinghai Lu <yinghai.lu@oracle.com>
Date:   Tue Nov 22 21:06:53 2011 -0800

    PCI: Only call pci_stop_bus_device() one time for child devices at remove
    
    During debugging pcie hotplug with SRIOV with pcie switch, I found
    pci_stop_bus_device() is called several times for some child devices.
    
    So change original pci_remove_bus_device() to __pci_remove_bus_device(),
    and make it only do remove work, and add a new pci_remove_bus_device
    that calls pci_stop_bus_device() one time, and then call
    __pci_remove_bus_device().
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/remove.c b/drivers/pci/remove.c
index 7f87beed35ac..6def3624c688 100644
--- a/drivers/pci/remove.c
+++ b/drivers/pci/remove.c
@@ -89,9 +89,8 @@ EXPORT_SYMBOL(pci_remove_bus);
  * device lists, remove the /proc entry, and notify userspace
  * (/sbin/hotplug).
  */
-void pci_remove_bus_device(struct pci_dev *dev)
+static void __pci_remove_bus_device(struct pci_dev *dev)
 {
-	pci_stop_bus_device(dev);
 	if (dev->subordinate) {
 		struct pci_bus *b = dev->subordinate;
 
@@ -102,6 +101,11 @@ void pci_remove_bus_device(struct pci_dev *dev)
 
 	pci_destroy_dev(dev);
 }
+void pci_remove_bus_device(struct pci_dev *dev)
+{
+	pci_stop_bus_device(dev);
+	__pci_remove_bus_device(dev);
+}
 
 /**
  * pci_remove_behind_bridge - remove all devices behind a PCI bridge
@@ -117,7 +121,7 @@ void pci_remove_behind_bridge(struct pci_dev *dev)
 
 	if (dev->subordinate)
 		list_for_each_safe(l, n, &dev->subordinate->devices)
-			pci_remove_bus_device(pci_dev_b(l));
+			__pci_remove_bus_device(pci_dev_b(l));
 }
 
 static void pci_stop_bus_devices(struct pci_bus *bus)

commit dc2c2c9dd513dec6c17df04e8abff795e20a5271
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Thu May 12 17:11:40 2011 -0700

    PCI/sysfs: move bus cpuaffinity to class dev_attrs
    
    Requested by Greg KH to fix a race condition in the creating of PCI bus
    cpuaffinity files.
    
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/remove.c b/drivers/pci/remove.c
index 176615e7231f..7f87beed35ac 100644
--- a/drivers/pci/remove.c
+++ b/drivers/pci/remove.c
@@ -73,8 +73,6 @@ void pci_remove_bus(struct pci_bus *pci_bus)
 		return;
 
 	pci_remove_legacy_files(pci_bus);
-	device_remove_file(&pci_bus->dev, &dev_attr_cpuaffinity);
-	device_remove_file(&pci_bus->dev, &dev_attr_cpulistaffinity);
 	device_unregister(&pci_bus->dev);
 }
 EXPORT_SYMBOL(pci_remove_bus);

commit af4c5f985afd8d4cfdf402aaa03677f2cb96e37c
Author: Alex Chiang <achiang@hp.com>
Date:   Mon May 18 19:02:38 2009 -0600

    PCI: eliminate redundant pci_stop_dev() call from pci_destroy_dev()
    
    We always call pci_stop_bus_device before calling pci_destroy_dev.
    
    Since pci_stop_bus_device calls pci_stop_dev, there is no need
    for pci_destroy_dev to repeat the call.
    
    Signed-off-by: Alex Chiang <achiang@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/remove.c b/drivers/pci/remove.c
index 86503c14ce7e..176615e7231f 100644
--- a/drivers/pci/remove.c
+++ b/drivers/pci/remove.c
@@ -32,8 +32,6 @@ static void pci_stop_dev(struct pci_dev *dev)
 
 static void pci_destroy_dev(struct pci_dev *dev)
 {
-	pci_stop_dev(dev);
-
 	/* Remove the device from the device lists, and prevent any further
 	 * list accesses from this device */
 	down_write(&pci_bus_sem);

commit 7ae0567fd3f4f51d55c4c638ecc6836347992de2
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Thu Mar 26 16:49:52 2009 +0900

    PCI: fix kernel oops on bridge removal
    
    Fix the following kernel oops problem that happens when removing PCI
    bridge with pciehp loaded. It should also occur with other hotplug
    driver that is implemented as a bridge's driver.
    
    [  459.997257] pciehp 0000:2f:04.0:pcie24: unloading service driver pciehp
    [  459.997495] general protection fault: 0000 [#1] SMP
    [  459.997737] last sysfs file: /sys/devices/pci0000:00/0000:00:04.0/0000:2e:00.0/0000:2f:04.0/remove
    [  459.997964] CPU 4
    [  459.998129] Modules linked in: pciehp ipv6 autofs4 hidp rfcomm l2cap bluetooth sunrpc cpufreq_ondemand acpi_cpufreq dm_mirror dm_region_hash dm_log dm_multipath scsi_dh dm_mod sbs sbshc battery ac parport_pc lp parport mptspi mptscsih mptbase scsi_transport_spi e1000e sg sr_mod cdrom button serio_raw i2c_i801 i2c_core shpchp pcspkr ata_piix libata megaraid_sas sd_mod scsi_mod crc_t10dif ext3 jbd uhci_hcd ohci_hcd ehci_hcd [last unloaded: microcode]
    [  459.998129] Pid: 56, comm: events/4 Not tainted 2.6.29-rc8-kk #1 PRIMERGY
    [  459.998129] RIP: 0010:[<ffffffff803bf047>]  [<ffffffff803bf047>] pci_slot_release+0x37/0x100
    [  459.998129] RSP: 0018:ffff88083b3bf9e0  EFLAGS: 00010246
    [  459.998129] RAX: ffff88083adc5158 RBX: ffff880836c1bc80 RCX: 6b6b6b6b6b6b6b6b
    [  459.998129] RDX: 0000000000000000 RSI: ffffffff803a77f0 RDI: ffff880836c1bc48
    [  459.998129] RBP: ffff88083b3bfa00 R08: 0000000000000002 R09: 0000000000000000
    [  459.998129] R10: 0000000000000000 R11: 0000000000000000 R12: ffff880836c1bc48
    [  459.998129] R13: ffff880836c1bc20 R14: ffff880836c1bc48 R15: ffff880836d1ec38
    [  459.998129] FS:  0000000000000000(0000) GS:ffff88083ccc3770(0000) knlGS:0000000000000000
    [  459.998129] CS:  0010 DS: 0018 ES: 0018 CR0: 000000008005003b
    [  459.998129] CR2: 00007f1562f1d558 CR3: 0000000838090000 CR4: 00000000000006e0
    [  459.998129] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
    [  459.998129] DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400
    [  459.998129] Process events/4 (pid: 56, threadinfo ffff88083b3be000, task ffff88083b3b3e40)
    [  459.998129] Stack:
    [  459.998129]  ffff880836c1bc80 ffff880836c1bc48 ffffffff80793320 ffff88083b0d0960
    [  459.998129]  ffff88083b3bfa30 ffffffff803a788a ffff880836c1bc80 ffffffff803a77f0
    [  459.998129]  ffff880836c1bc20 ffff880836d1ec38 ffff88083b3bfa50 ffffffff803a8ce7
    [  459.998129] Call Trace:
    [  459.998129]  [<ffffffff803a788a>] kobject_release+0x9a/0x290
    [  459.998129]  [<ffffffff803a77f0>] ? kobject_release+0x0/0x290
    [  459.998129]  [<ffffffff803a8ce7>] kref_put+0x37/0x80
    [  459.998129]  [<ffffffff803a76f7>] kobject_put+0x27/0x60
    [  459.998129]  [<ffffffff803bebcc>] ? pci_destroy_slot+0x3c/0xc0
    [  459.998129]  [<ffffffff803bebd5>] pci_destroy_slot+0x45/0xc0
    [  459.998129]  [<ffffffff803c797d>] pci_hp_deregister+0x13d/0x210
    [  459.998129]  [<ffffffffa031141d>] cleanup_slots+0x2d/0x80 [pciehp]
    [  459.998129]  [<ffffffffa0311735>] pciehp_remove+0x15/0x30 [pciehp]
    [  459.998129]  [<ffffffff803c4c99>] pcie_port_remove_service+0x69/0x90
    [  459.998129]  [<ffffffff80441da9>] __device_release_driver+0x59/0x90
    [  459.998129]  [<ffffffff80441edb>] device_release_driver+0x2b/0x40
    [  459.998129]  [<ffffffff804419d6>] bus_remove_device+0xa6/0x120
    [  459.998129]  [<ffffffff8043e46b>] device_del+0x12b/0x190
    [  459.998129]  [<ffffffff803c4d90>] ? remove_iter+0x0/0x40
    [  459.998129]  [<ffffffff8043e4f6>] device_unregister+0x26/0x70
    [  459.998129]  [<ffffffff803c4dbf>] remove_iter+0x2f/0x40
    [  459.998129]  [<ffffffff8043ddf3>] device_for_each_child+0x33/0x60
    [  459.998129]  [<ffffffff8033ee30>] ? sysfs_schedule_callback_work+0x0/0x50
    [  459.998129]  [<ffffffff803c4d30>] pcie_port_device_remove+0x30/0x80
    [  459.998129]  [<ffffffff803c55a1>] pcie_portdrv_remove+0x11/0x20
    [  459.998129]  [<ffffffff803bfeb2>] pci_device_remove+0x32/0x70
    [  459.998129]  [<ffffffff80441da9>] __device_release_driver+0x59/0x90
    [  459.998129]  [<ffffffff80441edb>] device_release_driver+0x2b/0x40
    [  459.998129]  [<ffffffff804419d6>] bus_remove_device+0xa6/0x120
    [  459.998129]  [<ffffffff8043e46b>] device_del+0x12b/0x190
    [  459.998129]  [<ffffffff8043e4f6>] device_unregister+0x26/0x70
    [  459.998129]  [<ffffffff803ba969>] pci_stop_dev+0x49/0x60
    [  459.998129]  [<ffffffff803baab0>] pci_remove_bus_device+0x40/0xc0
    [  459.998129]  [<ffffffff803c10d9>] remove_callback+0x29/0x40
    [  459.998129]  [<ffffffff8033ee4f>] sysfs_schedule_callback_work+0x1f/0x50
    [  459.998129]  [<ffffffff8025769a>] run_workqueue+0x15a/0x230
    [  459.998129]  [<ffffffff80257648>] ? run_workqueue+0x108/0x230
    [  459.998129]  [<ffffffff8025846f>] worker_thread+0x9f/0x100
    [  459.998129]  [<ffffffff8025bce0>] ? autoremove_wake_function+0x0/0x40
    [  459.998129]  [<ffffffff802583d0>] ? worker_thread+0x0/0x100
    [  459.998129]  [<ffffffff8025b89d>] kthread+0x4d/0x80
    [  459.998129]  [<ffffffff8020d4ba>] child_rip+0xa/0x20
    [  459.998129]  [<ffffffff8020cebc>] ? restore_args+0x0/0x30
    [  459.998129]  [<ffffffff8025b850>] ? kthread+0x0/0x80
    [  459.998129]  [<ffffffff8020d4b0>] ? child_rip+0x0/0x20
    [  459.998129] Code: 56 49 89 fe 41 55 4c 8d 6f d8 41 54 53 74 09 f6 05 b8 05 c7 00 08 75 72 49 8b 45 00 48 8b 48 28 eb 05 66 90 48 89 f1 49 8b 45 00 <48> 8b 31 48 83 c0 28 0f 18 0e 48 39 c1 74 1c 8b 41 38 41 0f b6
    [  459.998129] RIP  [<ffffffff803bf047>] pci_slot_release+0x37/0x100
    [  459.998129]  RSP <ffff88083b3bf9e0>
    [  460.018595] ---[ end trace 5a08d2095374aedc ]---
    
    The pci_remove_bus_device() removes all buses and devices under the
    bridge, and then removes the bridge. So the remove() callback of the
    hotplug drivers implemented as a bridge's driver is executed after the
    struct pci_bus of the bridge's secondary bus is removed. The remove()
    callback of those driver unregisters the slot using pci_destroy_slot(),
    and slot's release callback refers to the the struct pci_bus that was
    already freed. This is the cause of the kernel oops.
    
    This patch solves the problem by stopping bus drivers before removing the
    bridge and its child bus and devices.
    
    Acked-by: Alex Chiang <achiang@hp.com>
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/remove.c b/drivers/pci/remove.c
index caf8e1eae45e..86503c14ce7e 100644
--- a/drivers/pci/remove.c
+++ b/drivers/pci/remove.c
@@ -95,6 +95,7 @@ EXPORT_SYMBOL(pci_remove_bus);
  */
 void pci_remove_bus_device(struct pci_dev *dev)
 {
+	pci_stop_bus_device(dev);
 	if (dev->subordinate) {
 		struct pci_bus *b = dev->subordinate;
 

commit 2b56313448bb8efad3af19f211d988c8352ac04d
Author: Yu Zhao <yu.zhao@intel.com>
Date:   Wed Jan 28 18:27:21 2009 +0800

    PCI: check if a bus is added when removing it
    
    When removing a bus, 'is_added' should be checked to make sure the
    bus has been successfully added by pci_bus_add_child() who will sets
    'is_added'.
    
    Signed-off-by: Yu Zhao <yu.zhao@intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/remove.c b/drivers/pci/remove.c
index 042e08924421..caf8e1eae45e 100644
--- a/drivers/pci/remove.c
+++ b/drivers/pci/remove.c
@@ -71,6 +71,9 @@ void pci_remove_bus(struct pci_bus *pci_bus)
 	down_write(&pci_bus_sem);
 	list_del(&pci_bus->node);
 	up_write(&pci_bus_sem);
+	if (!pci_bus->is_added)
+		return;
+
 	pci_remove_legacy_files(pci_bus);
 	device_remove_file(&pci_bus->dev, &dev_attr_cpuaffinity);
 	device_remove_file(&pci_bus->dev, &dev_attr_cpulistaffinity);

commit 11d587429e9cbb40ac20d7ed8126c66da0d7aba5
Author: Stephen Hemminger <shemminger@vyatta.com>
Date:   Fri Sep 5 21:45:36 2008 -0700

    PCI: fix sparse warning in pci_remove_behind_bridge
    
    Get rid of the second definition of dev which hides the earlier one in
    the argument list and causes a warning from sparse.
    
    Signed-off-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/remove.c b/drivers/pci/remove.c
index f94f6d5ae297..042e08924421 100644
--- a/drivers/pci/remove.c
+++ b/drivers/pci/remove.c
@@ -115,13 +115,9 @@ void pci_remove_behind_bridge(struct pci_dev *dev)
 {
 	struct list_head *l, *n;
 
-	if (dev->subordinate) {
-		list_for_each_safe(l, n, &dev->subordinate->devices) {
-			struct pci_dev *dev = pci_dev_b(l);
-
-			pci_remove_bus_device(dev);
-		}
-	}
+	if (dev->subordinate)
+		list_for_each_safe(l, n, &dev->subordinate->devices)
+			pci_remove_bus_device(pci_dev_b(l));
 }
 
 static void pci_stop_bus_devices(struct pci_bus *bus)

commit 93ff68a55aa92180a765d6c51c3303f6200167a6
Author: Mike Travis <travis@sgi.com>
Date:   Sat Sep 6 05:46:42 2008 -0700

    PCI: make CPU list affinity visible
    
    Stephen Hemminger wrote:
    > Looks like Mike created cpulistaffinty in sysfs but never completed
    > the job.
    
    This patch hooks things up correctly, taking care to remove the new file
    when the bus is destroyed.
    
    Signed-off-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: Mike Travis <travis@sgi.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/remove.c b/drivers/pci/remove.c
index bdc2a44d68e1..f94f6d5ae297 100644
--- a/drivers/pci/remove.c
+++ b/drivers/pci/remove.c
@@ -73,6 +73,7 @@ void pci_remove_bus(struct pci_bus *pci_bus)
 	up_write(&pci_bus_sem);
 	pci_remove_legacy_files(pci_bus);
 	device_remove_file(&pci_bus->dev, &dev_attr_cpuaffinity);
+	device_remove_file(&pci_bus->dev, &dev_attr_cpulistaffinity);
 	device_unregister(&pci_bus->dev);
 }
 EXPORT_SYMBOL(pci_remove_bus);

commit 7d715a6c1ae5785d00fb9a876b5abdfc43abc44b
Author: Shaohua Li <shaohua.li@intel.com>
Date:   Mon Feb 25 09:46:41 2008 +0800

    PCI: add PCI Express ASPM support
    
    PCI Express ASPM defines a protocol for PCI Express components in the D0
    state to reduce Link power by placing their Links into a low power state
    and instructing the other end of the Link to do likewise. This
    capability allows hardware-autonomous, dynamic Link power reduction
    beyond what is achievable by software-only controlled power management.
    However, The device should be configured by software appropriately.
    Enabling ASPM will save power, but will introduce device latency.
    
    This patch adds ASPM support in Linux. It introduces a global policy for
    ASPM, a sysfs file /sys/module/pcie_aspm/parameters/policy can control
    it. The interface can be used as a boot option too. Currently we have
    below setting:
            -default, BIOS default setting
            -powersave, highest power saving mode, enable all available ASPM
    state and clock power management
            -performance, highest performance, disable ASPM and clock power
    management
    By default, the 'default' policy is used currently.
    
    In my test, power difference between powersave mode and performance mode
    is about 1.3w in a system with 3 PCIE links.
    
    Note: some devices might not work well with aspm, either because chipset
    issue or device issue. The patch provide API (pci_disable_link_state),
    driver can disable ASPM for specific device.
    
    Signed-off-by: Shaohua Li <shaohua.li@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/remove.c b/drivers/pci/remove.c
index b6824833343f..bdc2a44d68e1 100644
--- a/drivers/pci/remove.c
+++ b/drivers/pci/remove.c
@@ -1,5 +1,6 @@
 #include <linux/pci.h>
 #include <linux/module.h>
+#include <linux/pci-aspm.h>
 #include "pci.h"
 
 static void pci_free_resources(struct pci_dev *dev)
@@ -24,6 +25,9 @@ static void pci_stop_dev(struct pci_dev *dev)
 		device_unregister(&dev->dev);
 		dev->is_added = 0;
 	}
+
+	if (dev->bus->self)
+		pcie_aspm_exit_link_state(dev);
 }
 
 static void pci_destroy_dev(struct pci_dev *dev)

commit 5ff580c10ec06fd296bd23d4570c1a95194094a0
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Feb 14 14:56:56 2008 -0800

    PCI: remove global list of PCI devices
    
    This patch finally removes the global list of PCI devices.  We are
    relying entirely on the list held in the driver core now, and do not
    need a separate "shadow" list as no one uses it.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/remove.c b/drivers/pci/remove.c
index d3c77cbe3279..b6824833343f 100644
--- a/drivers/pci/remove.c
+++ b/drivers/pci/remove.c
@@ -23,10 +23,6 @@ static void pci_stop_dev(struct pci_dev *dev)
 		pci_remove_sysfs_dev_files(dev);
 		device_unregister(&dev->dev);
 		dev->is_added = 0;
-		down_write(&pci_bus_sem);
-		list_del(&dev->global_list);
-		dev->global_list.next = dev->global_list.prev = NULL;
-		up_write(&pci_bus_sem);
 	}
 }
 

commit 8a1bc9013a03d41a0e36ee413bb6f97281b30bd1
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Feb 14 14:56:56 2008 -0800

    PCI: add is_added flag to struct pci_dev
    
    This lets us check if the device is really added to the driver core or
    not, which is what we need when walking some of the bus lists.  The flag
    is there in anticipation of getting rid of the other PCI device list,
    which is what we used to check in this situation.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/remove.c b/drivers/pci/remove.c
index 9684e1bde277..d3c77cbe3279 100644
--- a/drivers/pci/remove.c
+++ b/drivers/pci/remove.c
@@ -18,13 +18,11 @@ static void pci_free_resources(struct pci_dev *dev)
 
 static void pci_stop_dev(struct pci_dev *dev)
 {
-	if (!dev->global_list.next)
-		return;
-
-	if (!list_empty(&dev->global_list)) {
+	if (dev->is_added) {
 		pci_proc_detach_device(dev);
 		pci_remove_sysfs_dev_files(dev);
 		device_unregister(&dev->dev);
+		dev->is_added = 0;
 		down_write(&pci_bus_sem);
 		list_del(&dev->global_list);
 		dev->global_list.next = dev->global_list.prev = NULL;

commit cc3a1378b4dd45d3e78dd4aeb10641b06a87d614
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Sat Feb 2 11:32:01 2008 -0800

    Revert "PCI: PCIE ASPM support"
    
    This reverts commit 6c723d5bd89f03fc3ef627d50f89ade054d2ee3b.
    
    It caused build errors on non-x86 platforms, config file confusion, and
    even some boot errors on some x86-64 boxes.  All around, not quite ready
    for prime-time :(
    
    Cc: Shaohua Li <shaohua.li@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/remove.c b/drivers/pci/remove.c
index ec4a82ba29a8..9684e1bde277 100644
--- a/drivers/pci/remove.c
+++ b/drivers/pci/remove.c
@@ -1,6 +1,5 @@
 #include <linux/pci.h>
 #include <linux/module.h>
-#include <linux/aspm.h>
 #include "pci.h"
 
 static void pci_free_resources(struct pci_dev *dev)
@@ -31,9 +30,6 @@ static void pci_stop_dev(struct pci_dev *dev)
 		dev->global_list.next = dev->global_list.prev = NULL;
 		up_write(&pci_bus_sem);
 	}
-
-	if (dev->bus->self)
-		pcie_aspm_exit_link_state(dev);
 }
 
 static void pci_destroy_dev(struct pci_dev *dev)

commit fd7d1ced29e5beb88c9068801da7a362606d8273
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue May 22 22:47:54 2007 -0400

    PCI: make pci_bus a struct device
    
    This moves the pci_bus class device to be a real struct device and at
    the same time, place it in the device tree in the correct location.
    
    Note, the old "bridge" symlink is now gone, but this was a non-standard
    link and no userspace program used it.  If you need to determine the
    device that the bus is on, follow the standard device symlink, or walk
    up the device tree.
    
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/remove.c b/drivers/pci/remove.c
index 05c9ad2a7f8b..ec4a82ba29a8 100644
--- a/drivers/pci/remove.c
+++ b/drivers/pci/remove.c
@@ -78,10 +78,8 @@ void pci_remove_bus(struct pci_bus *pci_bus)
 	list_del(&pci_bus->node);
 	up_write(&pci_bus_sem);
 	pci_remove_legacy_files(pci_bus);
-	class_device_remove_file(&pci_bus->class_dev,
-		&class_device_attr_cpuaffinity);
-	sysfs_remove_link(&pci_bus->class_dev.kobj, "bridge");
-	class_device_unregister(&pci_bus->class_dev);
+	device_remove_file(&pci_bus->dev, &dev_attr_cpuaffinity);
+	device_unregister(&pci_bus->dev);
 }
 EXPORT_SYMBOL(pci_remove_bus);
 

commit 6c723d5bd89f03fc3ef627d50f89ade054d2ee3b
Author: Shaohua Li <shaohua.li@intel.com>
Date:   Thu Jan 24 10:21:57 2008 +0800

    PCI: PCIE ASPM support
    
    PCI Express ASPM defines a protocol for PCI Express components in the D0
    state to reduce Link power by placing their Links into a low power state
    and instructing the other end of the Link to do likewise. This
    capability allows hardware-autonomous, dynamic Link power reduction
    beyond what is achievable by software-only controlled power management.
    However, The device should be configured by software appropriately.
    Enabling ASPM will save power, but will introduce device latency.
    
    This patch adds ASPM support in Linux. It introduces a global policy for
    ASPM, a sysfs file /sys/module/pcie_aspm/parameters/policy can control
    it. The interface can be used as a boot option too. Currently we have
    below setting:
            -default, BIOS default setting
            -powersave, highest power saving mode, enable all available ASPM
    state
    and clock power management
            -performance, highest performance, disable ASPM and clock power
    management
    By default, the 'default' policy is used currently.
    
    In my test, power difference between powersave mode and performance mode
    is about 1.3w in a system with 3 PCIE links.
    
    Signed-off-by: Shaohua Li <shaohua.li@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/remove.c b/drivers/pci/remove.c
index 430281b2e921..05c9ad2a7f8b 100644
--- a/drivers/pci/remove.c
+++ b/drivers/pci/remove.c
@@ -1,5 +1,6 @@
 #include <linux/pci.h>
 #include <linux/module.h>
+#include <linux/aspm.h>
 #include "pci.h"
 
 static void pci_free_resources(struct pci_dev *dev)
@@ -30,6 +31,9 @@ static void pci_stop_dev(struct pci_dev *dev)
 		dev->global_list.next = dev->global_list.prev = NULL;
 		up_write(&pci_bus_sem);
 	}
+
+	if (dev->bus->self)
+		pcie_aspm_exit_link_state(dev);
 }
 
 static void pci_destroy_dev(struct pci_dev *dev)

commit 24f8aa9b464b73e0553f092b747770940ee0ea54
Author: Satoru Takeuchi <takeuchi_satoru@jp.fujitsu.com>
Date:   Tue Sep 12 10:16:36 2006 -0700

    PCI: add pci_stop_bus_device
    
    This patch adds pci_stop_bus_device() which stops a PCI device (detach
    the driver, remove from the global list and so on) and any children.
    This is needed for ACPI based PCI-to-PCI bridge hot-remove, and it will
    be also needed for ACPI based PCI root bridge hot-remove.
    
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: MUNEDA Takahiro <muneda.takahiro@jp.fujitsu.com>
    Signed-off-by: Satoru Takeuchi <takeuchi_satoru@jp.fujitsu.com>
    Signed-off-by: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/remove.c b/drivers/pci/remove.c
index 99ffbd478b29..430281b2e921 100644
--- a/drivers/pci/remove.c
+++ b/drivers/pci/remove.c
@@ -16,8 +16,11 @@ static void pci_free_resources(struct pci_dev *dev)
 	}
 }
 
-static void pci_destroy_dev(struct pci_dev *dev)
+static void pci_stop_dev(struct pci_dev *dev)
 {
+	if (!dev->global_list.next)
+		return;
+
 	if (!list_empty(&dev->global_list)) {
 		pci_proc_detach_device(dev);
 		pci_remove_sysfs_dev_files(dev);
@@ -27,6 +30,11 @@ static void pci_destroy_dev(struct pci_dev *dev)
 		dev->global_list.next = dev->global_list.prev = NULL;
 		up_write(&pci_bus_sem);
 	}
+}
+
+static void pci_destroy_dev(struct pci_dev *dev)
+{
+	pci_stop_dev(dev);
 
 	/* Remove the device from the device lists, and prevent any further
 	 * list accesses from this device */
@@ -119,5 +127,32 @@ void pci_remove_behind_bridge(struct pci_dev *dev)
 	}
 }
 
+static void pci_stop_bus_devices(struct pci_bus *bus)
+{
+	struct list_head *l, *n;
+
+	list_for_each_safe(l, n, &bus->devices) {
+		struct pci_dev *dev = pci_dev_b(l);
+		pci_stop_bus_device(dev);
+	}
+}
+
+/**
+ * pci_stop_bus_device - stop a PCI device and any children
+ * @dev: the device to stop
+ *
+ * Stop a PCI device (detach the driver, remove from the global list
+ * and so on). This also stop any subordinate buses and children in a
+ * depth-first manner.
+ */
+void pci_stop_bus_device(struct pci_dev *dev)
+{
+	if (dev->subordinate)
+		pci_stop_bus_devices(dev->subordinate);
+
+	pci_stop_dev(dev);
+}
+
 EXPORT_SYMBOL(pci_remove_bus_device);
 EXPORT_SYMBOL(pci_remove_behind_bridge);
+EXPORT_SYMBOL_GPL(pci_stop_bus_device);

commit d71374dafbba7ec3f67371d3b7e9f6310a588808
Author: Zhang Yanmin <yanmin.zhang@intel.com>
Date:   Fri Jun 2 12:35:43 2006 +0800

    [PATCH] PCI: fix race with pci_walk_bus and pci_destroy_dev
    
    pci_walk_bus has a race with pci_destroy_dev. When cb is called
    in pci_walk_bus, pci_destroy_dev might unlink the dev pointed by next.
    Later on in the next loop, pointer next becomes NULL and cause
    kernel panic.
    
    Below patch against 2.6.17-rc4 fixes it by changing pci_bus_lock (spin_lock)
    to pci_bus_sem (rw_semaphore).
    
    Signed-off-by: Zhang Yanmin <yanmin.zhang@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/remove.c b/drivers/pci/remove.c
index 1a6bf9de166f..99ffbd478b29 100644
--- a/drivers/pci/remove.c
+++ b/drivers/pci/remove.c
@@ -22,18 +22,18 @@ static void pci_destroy_dev(struct pci_dev *dev)
 		pci_proc_detach_device(dev);
 		pci_remove_sysfs_dev_files(dev);
 		device_unregister(&dev->dev);
-		spin_lock(&pci_bus_lock);
+		down_write(&pci_bus_sem);
 		list_del(&dev->global_list);
 		dev->global_list.next = dev->global_list.prev = NULL;
-		spin_unlock(&pci_bus_lock);
+		up_write(&pci_bus_sem);
 	}
 
 	/* Remove the device from the device lists, and prevent any further
 	 * list accesses from this device */
-	spin_lock(&pci_bus_lock);
+	down_write(&pci_bus_sem);
 	list_del(&dev->bus_list);
 	dev->bus_list.next = dev->bus_list.prev = NULL;
-	spin_unlock(&pci_bus_lock);
+	up_write(&pci_bus_sem);
 
 	pci_free_resources(dev);
 	pci_dev_put(dev);
@@ -62,9 +62,9 @@ void pci_remove_bus(struct pci_bus *pci_bus)
 {
 	pci_proc_detach_bus(pci_bus);
 
-	spin_lock(&pci_bus_lock);
+	down_write(&pci_bus_sem);
 	list_del(&pci_bus->node);
-	spin_unlock(&pci_bus_lock);
+	up_write(&pci_bus_sem);
 	pci_remove_legacy_files(pci_bus);
 	class_device_remove_file(&pci_bus->class_dev,
 		&class_device_attr_cpuaffinity);

commit 54c762fe62d9ff0982f38e80cbec9c59104311e9
Author: Adrian Bunk <bunk@stusta.de>
Date:   Thu Dec 22 01:08:52 2005 +0100

    [PATCH] PCI: drivers/pci: some cleanups
    
    This patch contains the following cleanups:
    - hotplug/pciehp_core.c: make the needlessly global hpdriver_context
                             static
    - #if 0 the following unused functions:
      - pci.c: pci_bus_max_busnr()
      - pci.c: pci_max_busnr()
      - proc.c: pci_proc_attach_bus()
      - remove.c: pci_remove_device_safe
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/remove.c b/drivers/pci/remove.c
index 27a294b6965d..1a6bf9de166f 100644
--- a/drivers/pci/remove.c
+++ b/drivers/pci/remove.c
@@ -48,6 +48,7 @@ static void pci_destroy_dev(struct pci_dev *dev)
  * in question is not being used by a driver.
  * Returns 0 on success.
  */
+#if 0
 int pci_remove_device_safe(struct pci_dev *dev)
 {
 	if (pci_dev_driver(dev))
@@ -55,7 +56,7 @@ int pci_remove_device_safe(struct pci_dev *dev)
 	pci_destroy_dev(dev);
 	return 0;
 }
-EXPORT_SYMBOL(pci_remove_device_safe);
+#endif  /*  0  */
 
 void pci_remove_bus(struct pci_bus *pci_bus)
 {

commit 091ca9f06382e46d77213c35a97f7d0be9e350d2
Author: Rajesh Shah <rajesh.shah@intel.com>
Date:   Thu Apr 28 00:25:49 2005 -0700

    [PATCH] acpi bridge hotadd: Make the PCI remove routines safe for failed hot-plug
    
    When a root bridge hierarchy is hot-plugged, resource requirements for the new
    devices may be greater than what the root bridge is decoding.  In this case,
    we want to remove devices that did not get needed resources.  These devices
    have been scanned into bus specific lists but not yet added to the global
    device list.  Make sure the pci remove functions can handle this case.
    
    Signed-off-by: Rajesh Shah <rajesh.shah@intel.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/remove.c b/drivers/pci/remove.c
index 96f077f9a659..27a294b6965d 100644
--- a/drivers/pci/remove.c
+++ b/drivers/pci/remove.c
@@ -18,17 +18,21 @@ static void pci_free_resources(struct pci_dev *dev)
 
 static void pci_destroy_dev(struct pci_dev *dev)
 {
-	pci_proc_detach_device(dev);
-	pci_remove_sysfs_dev_files(dev);
-	device_unregister(&dev->dev);
+	if (!list_empty(&dev->global_list)) {
+		pci_proc_detach_device(dev);
+		pci_remove_sysfs_dev_files(dev);
+		device_unregister(&dev->dev);
+		spin_lock(&pci_bus_lock);
+		list_del(&dev->global_list);
+		dev->global_list.next = dev->global_list.prev = NULL;
+		spin_unlock(&pci_bus_lock);
+	}
 
 	/* Remove the device from the device lists, and prevent any further
 	 * list accesses from this device */
 	spin_lock(&pci_bus_lock);
 	list_del(&dev->bus_list);
-	list_del(&dev->global_list);
 	dev->bus_list.next = dev->bus_list.prev = NULL;
-	dev->global_list.next = dev->global_list.prev = NULL;
 	spin_unlock(&pci_bus_lock);
 
 	pci_free_resources(dev);

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/pci/remove.c b/drivers/pci/remove.c
new file mode 100644
index 000000000000..96f077f9a659
--- /dev/null
+++ b/drivers/pci/remove.c
@@ -0,0 +1,118 @@
+#include <linux/pci.h>
+#include <linux/module.h>
+#include "pci.h"
+
+static void pci_free_resources(struct pci_dev *dev)
+{
+	int i;
+
+ 	msi_remove_pci_irq_vectors(dev);
+
+	pci_cleanup_rom(dev);
+	for (i = 0; i < PCI_NUM_RESOURCES; i++) {
+		struct resource *res = dev->resource + i;
+		if (res->parent)
+			release_resource(res);
+	}
+}
+
+static void pci_destroy_dev(struct pci_dev *dev)
+{
+	pci_proc_detach_device(dev);
+	pci_remove_sysfs_dev_files(dev);
+	device_unregister(&dev->dev);
+
+	/* Remove the device from the device lists, and prevent any further
+	 * list accesses from this device */
+	spin_lock(&pci_bus_lock);
+	list_del(&dev->bus_list);
+	list_del(&dev->global_list);
+	dev->bus_list.next = dev->bus_list.prev = NULL;
+	dev->global_list.next = dev->global_list.prev = NULL;
+	spin_unlock(&pci_bus_lock);
+
+	pci_free_resources(dev);
+	pci_dev_put(dev);
+}
+
+/**
+ * pci_remove_device_safe - remove an unused hotplug device
+ * @dev: the device to remove
+ *
+ * Delete the device structure from the device lists and 
+ * notify userspace (/sbin/hotplug), but only if the device
+ * in question is not being used by a driver.
+ * Returns 0 on success.
+ */
+int pci_remove_device_safe(struct pci_dev *dev)
+{
+	if (pci_dev_driver(dev))
+		return -EBUSY;
+	pci_destroy_dev(dev);
+	return 0;
+}
+EXPORT_SYMBOL(pci_remove_device_safe);
+
+void pci_remove_bus(struct pci_bus *pci_bus)
+{
+	pci_proc_detach_bus(pci_bus);
+
+	spin_lock(&pci_bus_lock);
+	list_del(&pci_bus->node);
+	spin_unlock(&pci_bus_lock);
+	pci_remove_legacy_files(pci_bus);
+	class_device_remove_file(&pci_bus->class_dev,
+		&class_device_attr_cpuaffinity);
+	sysfs_remove_link(&pci_bus->class_dev.kobj, "bridge");
+	class_device_unregister(&pci_bus->class_dev);
+}
+EXPORT_SYMBOL(pci_remove_bus);
+
+/**
+ * pci_remove_bus_device - remove a PCI device and any children
+ * @dev: the device to remove
+ *
+ * Remove a PCI device from the device lists, informing the drivers
+ * that the device has been removed.  We also remove any subordinate
+ * buses and children in a depth-first manner.
+ *
+ * For each device we remove, delete the device structure from the
+ * device lists, remove the /proc entry, and notify userspace
+ * (/sbin/hotplug).
+ */
+void pci_remove_bus_device(struct pci_dev *dev)
+{
+	if (dev->subordinate) {
+		struct pci_bus *b = dev->subordinate;
+
+		pci_remove_behind_bridge(dev);
+		pci_remove_bus(b);
+		dev->subordinate = NULL;
+	}
+
+	pci_destroy_dev(dev);
+}
+
+/**
+ * pci_remove_behind_bridge - remove all devices behind a PCI bridge
+ * @dev: PCI bridge device
+ *
+ * Remove all devices on the bus, except for the parent bridge.
+ * This also removes any child buses, and any devices they may
+ * contain in a depth-first manner.
+ */
+void pci_remove_behind_bridge(struct pci_dev *dev)
+{
+	struct list_head *l, *n;
+
+	if (dev->subordinate) {
+		list_for_each_safe(l, n, &dev->subordinate->devices) {
+			struct pci_dev *dev = pci_dev_b(l);
+
+			pci_remove_bus_device(dev);
+		}
+	}
+}
+
+EXPORT_SYMBOL(pci_remove_bus_device);
+EXPORT_SYMBOL(pci_remove_behind_bridge);
