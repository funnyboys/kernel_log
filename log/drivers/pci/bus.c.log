commit fae6b93b19b42fcae0ef71e669b643f3366f6824
Author: Kelsey Skunberg <skunberg.kelsey@gmail.com>
Date:   Wed Jul 17 12:23:53 2019 -0600

    PCI: Unexport pci_bus_get() and pci_bus_put()
    
    pci_bus_get() and pci_bus_put() are not used by a loadable kernel module
    and do not need to be exported.
    
    These were exported by fe830ef62ac6 ("PCI: Introduce pci_bus_{get|put}() to
    manage PCI bus reference count"), but there are no loadable modules in the
    tree that use them.
    
    Link: https://lore.kernel.org/r/20190717182353.45557-1-skunberg.kelsey@gmail.com
    Signed-off-by: Kelsey Skunberg <skunberg.kelsey@gmail.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index 495059d923f7..8e40b3e6da77 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -417,11 +417,9 @@ struct pci_bus *pci_bus_get(struct pci_bus *bus)
 		get_device(&bus->dev);
 	return bus;
 }
-EXPORT_SYMBOL(pci_bus_get);
 
 void pci_bus_put(struct pci_bus *bus)
 {
 	if (bus)
 		put_device(&bus->dev);
 }
-EXPORT_SYMBOL(pci_bus_put);

commit 34c6b7105e5a11174f856483cde8ad6e61b7236a
Author: Mohan Kumar <mohankumar718@gmail.com>
Date:   Sat Apr 20 07:07:20 2019 +0300

    PCI: Replace dev_printk(KERN_DEBUG) with dev_info(), etc
    
    Replace dev_printk(KERN_DEBUG) with dev_info(), etc to be more consistent
    with other logging and avoid checkpatch warnings.
    
    The KERN_DEBUG messages could be converted to dev_dbg(), but that depends
    on CONFIG_DYNAMIC_DEBUG and DEBUG, and we want most of these messages to
    *always* be in the dmesg log.
    
    Link: https://lore.kernel.org/lkml/1555733240-19875-1-git-send-email-mohankumar718@gmail.com
    Signed-off-by: Mohan Kumar <mohankumar718@gmail.com>
    [bhelgaas: commit log]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index 2179a8baef52..495059d923f7 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -288,8 +288,7 @@ bool pci_bus_clip_resource(struct pci_dev *dev, int idx)
 		res->end = end;
 		res->flags &= ~IORESOURCE_UNSET;
 		orig_res.flags &= ~IORESOURCE_UNSET;
-		pci_printk(KERN_DEBUG, dev, "%pR clipped to %pR\n",
-				 &orig_res, res);
+		pci_info(dev, "%pR clipped to %pR\n", &orig_res, res);
 
 		return true;
 	}

commit 25da8dbaaf0679b3b22c783952a8392071cfa135
Author: Mohan Kumar <mohankumar718@gmail.com>
Date:   Sat Apr 20 07:03:46 2019 +0300

    PCI: Replace printk(KERN_INFO) with pr_info(), etc
    
    Replace printk() with pr_*() to be more consistent with other logging and
    avoid checkpatch warnings.
    
    Link: https://lore.kernel.org/lkml/1555733026-19609-1-git-send-email-mohankumar718@gmail.com
    Link: https://lore.kernel.org/lkml/1555733130-19804-1-git-send-email-mohankumar718@gmail.com
    Signed-off-by: Mohan Kumar <mohankumar718@gmail.com>
    [bhelgaas: squash in similar changes from second patch in series]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index 5cb40b2518f9..2179a8baef52 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -23,7 +23,7 @@ void pci_add_resource_offset(struct list_head *resources, struct resource *res,
 
 	entry = resource_list_create_entry(res, 0);
 	if (!entry) {
-		printk(KERN_ERR "PCI: can't add host bridge window %pR\n", res);
+		pr_err("PCI: can't add host bridge window %pR\n", res);
 		return;
 	}
 

commit 44bda4b7d26e9fffed6d7152d98a2e9edaeb2a76
Author: Hari Vyas <hari.vyas@broadcom.com>
Date:   Tue Jul 3 14:35:41 2018 +0530

    PCI: Fix is_added/is_busmaster race condition
    
    When a PCI device is detected, pdev->is_added is set to 1 and proc and
    sysfs entries are created.
    
    When the device is removed, pdev->is_added is checked for one and then
    device is detached with clearing of proc and sys entries and at end,
    pdev->is_added is set to 0.
    
    is_added and is_busmaster are bit fields in pci_dev structure sharing same
    memory location.
    
    A strange issue was observed with multiple removal and rescan of a PCIe
    NVMe device using sysfs commands where is_added flag was observed as zero
    instead of one while removing device and proc,sys entries are not cleared.
    This causes issue in later device addition with warning message
    "proc_dir_entry" already registered.
    
    Debugging revealed a race condition between the PCI core setting the
    is_added bit in pci_bus_add_device() and the NVMe driver reset work-queue
    setting the is_busmaster bit in pci_set_master().  As these fields are not
    handled atomically, that clears the is_added bit.
    
    Move the is_added bit to a separate private flag variable and use atomic
    functions to set and retrieve the device addition state.  This avoids the
    race because is_added no longer shares a memory location with is_busmaster.
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=200283
    Signed-off-by: Hari Vyas <hari.vyas@broadcom.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Lukas Wunner <lukas@wunner.de>
    Acked-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index 35b7fc87eac5..5cb40b2518f9 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -330,7 +330,7 @@ void pci_bus_add_device(struct pci_dev *dev)
 		return;
 	}
 
-	dev->is_added = 1;
+	pci_dev_assign_added(dev, true);
 }
 EXPORT_SYMBOL_GPL(pci_bus_add_device);
 
@@ -347,14 +347,14 @@ void pci_bus_add_devices(const struct pci_bus *bus)
 
 	list_for_each_entry(dev, &bus->devices, bus_list) {
 		/* Skip already-added devices */
-		if (dev->is_added)
+		if (pci_dev_is_added(dev))
 			continue;
 		pci_bus_add_device(dev);
 	}
 
 	list_for_each_entry(dev, &bus->devices, bus_list) {
 		/* Skip if device attach failed */
-		if (!dev->is_added)
+		if (!pci_dev_is_added(dev))
 			continue;
 		child = dev->subordinate;
 		if (child)

commit 8e6390795eacf87f717bc755f352f0aa85da5700
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Apr 3 16:40:54 2018 +0200

    PCI: remove CONFIG_PCI_BUS_ADDR_T_64BIT
    
    This symbol is now always identical to CONFIG_ARCH_DMA_ADDR_T_64BIT, so
    remove it.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index bc2ded4c451f..35b7fc87eac5 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -120,7 +120,7 @@ int devm_request_pci_bus_resources(struct device *dev,
 EXPORT_SYMBOL_GPL(devm_request_pci_bus_resources);
 
 static struct pci_bus_region pci_32_bit = {0, 0xffffffffULL};
-#ifdef CONFIG_PCI_BUS_ADDR_T_64BIT
+#ifdef CONFIG_ARCH_DMA_ADDR_T_64BIT
 static struct pci_bus_region pci_64_bit = {0,
 				(pci_bus_addr_t) 0xffffffffffffffffULL};
 static struct pci_bus_region pci_high = {(pci_bus_addr_t) 0x100000000ULL,
@@ -230,7 +230,7 @@ int pci_bus_alloc_resource(struct pci_bus *bus, struct resource *res,
 					  resource_size_t),
 		void *alignf_data)
 {
-#ifdef CONFIG_PCI_BUS_ADDR_T_64BIT
+#ifdef CONFIG_ARCH_DMA_ADDR_T_64BIT
 	int rc;
 
 	if (res->flags & IORESOURCE_MEM_64) {

commit df62ab5e0f75608919df7442654b0fab78246b7b
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Mar 9 16:36:33 2018 -0600

    PCI: Tidy comments
    
    Remove pointless comments that tell us the file name, remove blank line
    comments, follow multi-line comment conventions.  No functional change
    intended.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index 737d1c52f002..bc2ded4c451f 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -1,7 +1,5 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- *	drivers/pci/bus.c
- *
  * From setup-res.c, by:
  *	Dave Rusling (david.rusling@reo.mts.dec.com)
  *	David Mosberger (davidm@cs.arizona.edu)

commit ab8c609356fbe8dbcd44df11e884ce8cddf3739e
Merge: a5fae846f21d 36b072742a83
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Feb 1 11:40:07 2018 -0600

    Merge branch 'pci/spdx' into next
    
    * pci/spdx:
      PCI: Add SPDX GPL-2.0+ to replace implicit GPL v2 or later statement
      PCI: Add SPDX GPL-2.0+ to replace GPL v2 or later boilerplate
      PCI: Add SPDX GPL-2.0 to replace COPYING boilerplate
      PCI: Add SPDX GPL-2.0 to replace GPL v2 boilerplate
      PCI: Add SPDX GPL-2.0 when no license was specified

commit 7328c8f48d1895b3fec98b0b319cfb856b4c4fa1
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Jan 26 11:45:16 2018 -0600

    PCI: Add SPDX GPL-2.0 when no license was specified
    
    b24413180f56 ("License cleanup: add SPDX GPL-2.0 license identifier to
    files with no license") added SPDX GPL-2.0 to several PCI files that
    previously contained no license information.
    
    Add SPDX GPL-2.0 to all other PCI files that did not contain any license
    information and hence were under the default GPL version 2 license of the
    kernel.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index bc56cf19afd3..30a4d33038bf 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  *	drivers/pci/bus.c
  *

commit 7506dc7989933235e6fc23f3d0516bdbf0f7d1a8
Author: Frederick Lawler <fred@fredlawl.com>
Date:   Thu Jan 18 12:55:24 2018 -0600

    PCI: Add wrappers for dev_printk()
    
    Add PCI-specific dev_printk() wrappers and use them to simplify the code
    slightly.  No functional change intended.
    
    Signed-off-by: Frederick Lawler <fred@fredlawl.com>
    [bhelgaas: squash into one patch]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index bc56cf19afd3..efe61c0fb4cb 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -289,7 +289,7 @@ bool pci_bus_clip_resource(struct pci_dev *dev, int idx)
 		res->end = end;
 		res->flags &= ~IORESOURCE_UNSET;
 		orig_res.flags &= ~IORESOURCE_UNSET;
-		dev_printk(KERN_DEBUG, &dev->dev, "%pR clipped to %pR\n",
+		pci_printk(KERN_DEBUG, dev, "%pR clipped to %pR\n",
 				 &orig_res, res);
 
 		return true;
@@ -325,7 +325,7 @@ void pci_bus_add_device(struct pci_dev *dev)
 	dev->match_driver = true;
 	retval = device_attach(&dev->dev);
 	if (retval < 0 && retval != -EPROBE_DEFER) {
-		dev_warn(&dev->dev, "device attach failed (%d)\n", retval);
+		pci_warn(dev, "device attach failed (%d)\n", retval);
 		pci_proc_detach_device(dev);
 		pci_remove_sysfs_dev_files(dev);
 		return;

commit 1ed276a7b9d84626e5243fc54863440c74a4100a
Author: Lukas Wunner <lukas@wunner.de>
Date:   Fri Oct 28 10:52:06 2016 +0200

    PCI: Autosense device removal in pci_bridge_d3_update()
    
    The algorithm to update the flag indicating whether a bridge may go to D3
    makes a few optimizations based on whether the update was caused by the
    removal of a device on the one hand, versus the addition of a device or the
    change of its D3cold flags on the other hand.
    
    The information whether the update pertains to a removal is currently
    passed in by the caller, but the function may as well determine that itself
    by examining the device in question, thereby allowing for a considerable
    simplification and reduction of the code.
    
    Out of several options to determine removal, I've chosen the function
    device_is_registered() because it's cheap:  It merely returns the
    dev->kobj.state_in_sysfs flag.  That flag is set through device_add() when
    the root bus is scanned and cleared through device_remove().  The call to
    pci_bridge_d3_update() happens after each of these calls, respectively, so
    the ordering is correct.
    
    No functional change intended.
    
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index c288e5a52575..bc56cf19afd3 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -320,7 +320,7 @@ void pci_bus_add_device(struct pci_dev *dev)
 	pci_fixup_device(pci_fixup_final, dev);
 	pci_create_sysfs_dev_files(dev);
 	pci_proc_attach_device(dev);
-	pci_bridge_d3_device_changed(dev);
+	pci_bridge_d3_update(dev);
 
 	dev->match_driver = true;
 	retval = device_attach(&dev->dev);

commit 79dd99346166bcbf3b082f6e234db788da1db3c9
Merge: 3efc7023787f 50dcd29096cb da6163ad3aae
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Aug 1 12:23:57 2016 -0500

    Merge branches 'pci/demodularize-hosts' and 'pci/host-request-windows' into next
    
    * pci/demodularize-hosts:
      PCI: xgene: Make explicitly non-modular
      PCI: thunder-pem: Make explicitly non-modular
      PCI: thunder-ecam: Make explicitly non-modular
      PCI: tegra: Make explicitly non-modular
      PCI: rcar-gen2: Make explicitly non-modular
      PCI: rcar: Make explicitly non-modular
      PCI: mvebu: Make explicitly non-modular
      PCI: layerscape: Make explicitly non-modular
      PCI: keystone: Make explicitly non-modular
      PCI: hisi: Make explicitly non-modular
      PCI: generic: Make explicitly non-modular
      PCI: designware-plat: Make it explicitly non-modular
      PCI: artpec6: Make explicitly non-modular
      PCI: armada8k: Make explicitly non-modular
      PCI: artpec: Add PCI_MSI_IRQ_DOMAIN dependency
      PCI: artpec: Add Axis ARTPEC-6 PCIe controller driver
      PCI: Add DT binding for Axis ARTPEC-6 PCIe controller
      PCI: generic: Select IRQ_DOMAIN
    
    * pci/host-request-windows:
      PCI: versatile: Simplify host bridge window iteration
      PCI: versatile: Request host bridge window resources with core function
      PCI: tegra: Request host bridge window resources with core function
      PCI: tegra: Remove top-level resource from hierarchy
      PCI: rcar: Simplify host bridge window iteration
      PCI: rcar: Request host bridge window resources with core function
      PCI: rcar Gen2: Request host bridge window resources
      PCI: rcar: Drop gen2 dummy I/O port region
      ARM: Make PCI I/O space optional
      PCI: mvebu: Request host bridge window resources with core function
      PCI: generic: Simplify host bridge window iteration
      PCI: generic: Request host bridge window resources with core function
      PCI: altera: Simplify host bridge window iteration
      PCI: altera: Request host bridge window resources with core function
      PCI: xilinx-nwl: Use dev_printk() when possible
      PCI: xilinx-nwl: Request host bridge window resources
      PCI: xilinx-nwl: Free bridge resource list on failure
      PCI: xilinx: Request host bridge window resources
      PCI: xilinx: Free bridge resource list on failure
      PCI: xgene: Request host bridge window resources
      PCI: xgene: Free bridge resource list on failure
      PCI: iproc: Request host bridge window resources
      PCI: designware: Simplify host bridge window iteration
      PCI: designware: Request host bridge window resources
      PCI: designware: Free bridge resource list on failure
      PCI: Add devm_request_pci_bus_resources()

commit 9d26d3a8f1b0c442339a235f9508bdad8af91043
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Thu Jun 2 11:17:12 2016 +0300

    PCI: Put PCIe ports into D3 during suspend
    
    Currently the Linux PCI core does not touch power state of PCI bridges and
    PCIe ports when system suspend is entered.  Leaving them in D0 consumes
    power unnecessarily and may prevent the CPU from entering deeper C-states.
    
    With recent PCIe hardware we can power down the ports to save power given
    that we take into account few restrictions:
    
      - The PCIe port hardware is recent enough, starting from 2015.
    
      - Devices connected to PCIe ports are effectively in D3cold once the port
        is transitioned to D3 (the config space is not accessible anymore and
        the link may be powered down).
    
      - Devices behind the PCIe port need to be allowed to transition to D3cold
        and back.  There is a way both drivers and userspace can forbid this.
    
      - If the device behind the PCIe port is capable of waking the system it
        needs to be able to do so from D3cold.
    
    This patch adds a new flag to struct pci_device called 'bridge_d3'.  This
    flag is set and cleared by the PCI core whenever there is a change in power
    management state of any of the devices behind the PCIe port.  When system
    later on is suspended we only need to check this flag and if it is true
    transition the port to D3 otherwise we leave it in D0.
    
    Also provide override mechanism via command line parameter
    "pcie_port_pm=[off|force]" that can be used to disable or enable the
    feature regardless of the BIOS manufacturing date.
    
    Tested-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index dd7cdbee8029..28731360b457 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -291,6 +291,7 @@ void pci_bus_add_device(struct pci_dev *dev)
 	pci_fixup_device(pci_fixup_final, dev);
 	pci_create_sysfs_dev_files(dev);
 	pci_proc_attach_device(dev);
+	pci_bridge_d3_device_changed(dev);
 
 	dev->match_driver = true;
 	retval = device_attach(&dev->dev);

commit 950334bcf17a6ab55ce13d3bdf050f7b429320d5
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Sat May 28 18:09:16 2016 -0500

    PCI: Add devm_request_pci_bus_resources()
    
    Several host bridge drivers iterate through the list of bridge windows to
    request resources.  Several others don't request the window resources at
    all.
    
    Add a devm_request_pci_bus_resources() interface to make it easier for
    drivers to request all the window resources.  Export to GPL modules (from
    Arnd Bergmann <arnd@arndb.de>).
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index dd7cdbee8029..6293ce0f3532 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -91,6 +91,35 @@ void pci_bus_remove_resources(struct pci_bus *bus)
 	}
 }
 
+int devm_request_pci_bus_resources(struct device *dev,
+				   struct list_head *resources)
+{
+	struct resource_entry *win;
+	struct resource *parent, *res;
+	int err;
+
+	resource_list_for_each_entry(win, resources) {
+		res = win->res;
+		switch (resource_type(res)) {
+		case IORESOURCE_IO:
+			parent = &ioport_resource;
+			break;
+		case IORESOURCE_MEM:
+			parent = &iomem_resource;
+			break;
+		default:
+			continue;
+		}
+
+		err = devm_request_resource(dev, parent, res);
+		if (err)
+			return err;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(devm_request_pci_bus_resources);
+
 static struct pci_bus_region pci_32_bit = {0, 0xffffffffULL};
 #ifdef CONFIG_PCI_BUS_ADDR_T_64BIT
 static struct pci_bus_region pci_64_bit = {0,
@@ -397,4 +426,3 @@ void pci_bus_put(struct pci_bus *bus)
 		put_device(&bus->dev);
 }
 EXPORT_SYMBOL(pci_bus_put);
-

commit 9a2a5a638f8eb9c612a7a9af0afab93f506f6ba4
Author: Lukas Wunner <lukas@wunner.de>
Date:   Mon May 2 13:48:31 2016 -0500

    PCI: Do not treat EPROBE_DEFER as device attach failure
    
    Linux 4.5 introduced a behavioral change in device probing during the
    suspend process with commit 013c074f8642 ("PM / sleep: prohibit devices
    probing during suspend/hibernation"): It defers device probing during the
    entire suspend process, starting from the prepare phase and ending with the
    complete phase.  A rule existed before that "we rely on subsystems not to
    do any probing once a device is suspended" but it is enforced only now
    (Alan Stern, https://lkml.org/lkml/2015/9/15/908).
    
    This resulted in a WARN splat if a PCI device (e.g., Thunderbolt) is
    plugged in while the system is asleep: Upon waking up, pciehp_resume()
    discovers new devices in the resume phase and immediately tries to bind
    them to a driver.  Since probing is now deferred, device_attach() returns
    -EPROBE_DEFER, which provoked a WARN in pci_bus_add_device().
    
    Linux 4.6-rc1 aggravates the situation with commit ab1a187bba5c ("PCI:
    Check device_attach() return value always"): If device_attach() returns a
    negative value, pci_bus_add_device() now removes the sysfs and procfs
    entries for the device and pci_bus_add_devices() subsequently locks up with
    a BUG.  Even with the BUG fixed we're still in trouble because the device
    remains on the deferred probing list even though its sysfs and procfs
    entries are gone and its children won't be added.
    
    Fix by not interpreting -EPROBE_DEFER as failure.  The device will be
    probed eventually (through device_unblock_probing() in dpm_complete()) and
    there is proper locking in place to avoid races (e.g., if devices are
    unplugged again und thus deleted from the system before deferred probing
    happens, I have tested this).  Also, those functions which dereference
    dev->driver (e.g. pci_pm_*()) do contain proper NULL pointer checks.  So it
    seems safe to ignore -EPROBE_DEFER.
    
    Fixes: ab1a187bba5c ("PCI: Check device_attach() return value always")
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: Grygorii Strashko <grygorii.strashko@ti.com>
    Cc: Alan Stern <stern@rowland.harvard.edu>

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index 23a39fdc311e..dd7cdbee8029 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -294,7 +294,7 @@ void pci_bus_add_device(struct pci_dev *dev)
 
 	dev->match_driver = true;
 	retval = device_attach(&dev->dev);
-	if (retval < 0) {
+	if (retval < 0 && retval != -EPROBE_DEFER) {
 		dev_warn(&dev->dev, "device attach failed (%d)\n", retval);
 		pci_proc_detach_device(dev);
 		pci_remove_sysfs_dev_files(dev);

commit 1e398eae8407abdc02cde8a449b14d17ed193d56
Author: Lukas Wunner <lukas@wunner.de>
Date:   Mon May 2 13:48:25 2016 -0500

    PCI: Fix BUG on device attach failure
    
    Previously when pci_bus_add_device() called device_attach() and it returned
    a negative value, we emitted a WARN but carried on.
    
    Commit ab1a187bba5c ("PCI: Check device_attach() return value always"),
    introduced in Linux 4.6-rc1, changed this to unwind all steps preceding
    device_attach() and to not set dev->is_added = 1.
    
    The latter leads to a BUG if pci_bus_add_device() was called from
    pci_bus_add_devices().  Fix by not recursing to a child bus if
    device_attach() failed for the bridge leading to it.
    
    This can be triggered by plugging in a PCI device (e.g. Thunderbolt) while
    the system is asleep.  The system locks up when woken because
    device_attach() returns -EPROBE_DEFER.
    
    Fixes: ab1a187bba5c ("PCI: Check device_attach() return value always")
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index 6c9f5467bc5f..23a39fdc311e 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -324,7 +324,9 @@ void pci_bus_add_devices(const struct pci_bus *bus)
 	}
 
 	list_for_each_entry(dev, &bus->devices, bus_list) {
-		BUG_ON(!dev->is_added);
+		/* Skip if device attach failed */
+		if (!dev->is_added)
+			continue;
 		child = dev->subordinate;
 		if (child)
 			pci_bus_add_devices(child);

commit d5e2d00898bdfed9586472679760fc81a2ca2d02
Merge: 31e182363b39 6e669f085d59
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Mar 19 15:38:41 2016 -0700

    Merge tag 'powerpc-4.6-1' of git://git.kernel.org/pub/scm/linux/kernel/git/powerpc/linux
    
    Pull powerpc updates from Michael Ellerman:
     "This was delayed a day or two by some build-breakage on old toolchains
      which we've now fixed.
    
      There's two PCI commits both acked by Bjorn.
    
      There's one commit to mm/hugepage.c which is (co)authored by Kirill.
    
      Highlights:
       - Restructure Linux PTE on Book3S/64 to Radix format from Paul
         Mackerras
       - Book3s 64 MMU cleanup in preparation for Radix MMU from Aneesh
         Kumar K.V
       - Add POWER9 cputable entry from Michael Neuling
       - FPU/Altivec/VSX save/restore optimisations from Cyril Bur
       - Add support for new ftrace ABI on ppc64le from Torsten Duwe
    
      Various cleanups & minor fixes from:
       - Adam Buchbinder, Andrew Donnellan, Balbir Singh, Christophe Leroy,
         Cyril Bur, Luis Henriques, Madhavan Srinivasan, Pan Xinhui, Russell
         Currey, Sukadev Bhattiprolu, Suraj Jitindar Singh.
    
      General:
       - atomics: Allow architectures to define their own __atomic_op_*
         helpers from Boqun Feng
       - Implement atomic{, 64}_*_return_* variants and acquire/release/
         relaxed variants for (cmp)xchg from Boqun Feng
       - Add powernv_defconfig from Jeremy Kerr
       - Fix BUG_ON() reporting in real mode from Balbir Singh
       - Add xmon command to dump OPAL msglog from Andrew Donnellan
       - Add xmon command to dump process/task similar to ps(1) from Douglas
         Miller
       - Clean up memory hotplug failure paths from David Gibson
    
      pci/eeh:
       - Redesign SR-IOV on PowerNV to give absolute isolation between VFs
         from Wei Yang.
       - EEH Support for SRIOV VFs from Wei Yang and Gavin Shan.
       - PCI/IOV: Rename and export virtfn_{add, remove} from Wei Yang
       - PCI: Add pcibios_bus_add_device() weak function from Wei Yang
       - MAINTAINERS: Update EEH details and maintainership from Russell
         Currey
    
      cxl:
       - Support added to the CXL driver for running on both bare-metal and
         hypervisor systems, from Christophe Lombard and Frederic Barrat.
       - Ignore probes for virtual afu pci devices from Vaibhav Jain
    
      perf:
       - Export Power8 generic and cache events to sysfs from Sukadev
         Bhattiprolu
       - hv-24x7: Fix usage with chip events, display change in counter
         values, display domain indices in sysfs, eliminate domain suffix in
         event names, from Sukadev Bhattiprolu
    
      Freescale:
       - Updates from Scott: "Highlights include 8xx optimizations, 32-bit
         checksum optimizations, 86xx consolidation, e5500/e6500 cpu
         hotplug, more fman and other dt bits, and minor fixes/cleanup"
    
    * tag 'powerpc-4.6-1' of git://git.kernel.org/pub/scm/linux/kernel/git/powerpc/linux: (179 commits)
      powerpc: Fix unrecoverable SLB miss during restore_math()
      powerpc/8xx: Fix do_mtspr_cpu6() build on older compilers
      powerpc/rcpm: Fix build break when SMP=n
      powerpc/book3e-64: Use hardcoded mttmr opcode
      powerpc/fsl/dts: Add "jedec,spi-nor" flash compatible
      powerpc/T104xRDB: add tdm riser card node to device tree
      powerpc32: PAGE_EXEC required for inittext
      powerpc/mpc85xx: Add pcsphy nodes to FManV3 device tree
      powerpc/mpc85xx: Add MDIO bus muxing support to the board device tree(s)
      powerpc/86xx: Introduce and use common dtsi
      powerpc/86xx: Update device tree
      powerpc/86xx: Move dts files to fsl directory
      powerpc/86xx: Switch to kconfig fragments approach
      powerpc/86xx: Update defconfigs
      powerpc/86xx: Consolidate common platform code
      powerpc32: Remove one insn in mulhdu
      powerpc32: small optimisation in flush_icache_range()
      powerpc: Simplify test in __dma_sync()
      powerpc32: move xxxxx_dcache_range() functions inline
      powerpc32: Remove clear_pages() and define clear_page() inline
      ...

commit 7b77061f8d03cdaf71d91ea356835131d651b103
Author: Wei Yang <weiyang@linux.vnet.ibm.com>
Date:   Fri Mar 4 10:53:04 2016 +1100

    PCI: Add pcibios_bus_add_device() weak function
    
    This adds weak function pcibios_bus_add_device() for arch dependent
    code could do proper setup. For example, powerpc could setup EEH
    related resources for SRIOV VFs.
    
    Signed-off-by: Wei Yang <weiyang@linux.vnet.ibm.com>
    Reviewed-by: Gavin Shan <gwshan@linux.vnet.ibm.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index 89b3befc7155..6469ff6208b0 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -271,6 +271,8 @@ bool pci_bus_clip_resource(struct pci_dev *dev, int idx)
 
 void __weak pcibios_resource_survey_bus(struct pci_bus *bus) { }
 
+void __weak pcibios_bus_add_device(struct pci_dev *pdev) { }
+
 /**
  * pci_bus_add_device - start driver for a single device
  * @dev: device to add
@@ -285,6 +287,7 @@ void pci_bus_add_device(struct pci_dev *dev)
 	 * Can not put in pci_device_add yet because resources
 	 * are not assigned yet for some devices.
 	 */
+	pcibios_bus_add_device(dev);
 	pci_fixup_device(pci_fixup_final, dev);
 	pci_create_sysfs_dev_files(dev);
 	pci_proc_attach_device(dev);

commit ab1a187bba5c4e5ed8aa6e7bb7dcd7cd7e065aef
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Jan 27 07:35:07 2016 -0600

    PCI: Check device_attach() return value always
    
    Previously we checked the device_attach() return value only when
    CONFIG_BUG=y.  That caused this warning in builds where CONFIG_BUG is not
    set:
    
      drivers/pci/bus.c:237:6: warning: variable 'retval' set but not used [-Wunused-but-set-variable]
    
    Check the return value of device_attach() always and clean up after
    failure.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index 89b3befc7155..f2187d491475 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -291,7 +291,12 @@ void pci_bus_add_device(struct pci_dev *dev)
 
 	dev->match_driver = true;
 	retval = device_attach(&dev->dev);
-	WARN_ON(retval < 0);
+	if (retval < 0) {
+		dev_warn(&dev->dev, "device attach failed (%d)\n", retval);
+		pci_proc_detach_device(dev);
+		pci_remove_sysfs_dev_files(dev);
+		return;
+	}
 
 	dev->is_added = 1;
 }

commit 3460baa620685c20f5ee19afb6d99d26150c382c
Author: Christoph Biedl <linux-kernel.bfrz@manchmal.in-ulm.de>
Date:   Wed Dec 23 16:51:57 2015 +0100

    PCI: Fix minimum allocation address overwrite
    
    Commit 36e097a8a297 ("PCI: Split out bridge window override of minimum
    allocation address") claimed to do no functional changes but unfortunately
    did: The "min" variable is altered.  At least the AVM A1 PCMCIA adapter was
    no longer detected, breaking ISDN operation.
    
    Use a local copy of "min" to restore the previous behaviour.
    
    [bhelgaas: avoid gcc "?:" extension for portability and readability]
    Fixes: 36e097a8a297 ("PCI: Split out bridge window override of minimum allocation address")
    Signed-off-by: Christoph Biedl <linux-kernel.bfrz@manchmal.in-ulm.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    CC: stable@vger.kernel.org      # v3.14+

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index d3346d23963b..89b3befc7155 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -140,6 +140,8 @@ static int pci_bus_alloc_from_region(struct pci_bus *bus, struct resource *res,
 	type_mask |= IORESOURCE_TYPE_BITS;
 
 	pci_bus_for_each_resource(bus, r, i) {
+		resource_size_t min_used = min;
+
 		if (!r)
 			continue;
 
@@ -163,12 +165,12 @@ static int pci_bus_alloc_from_region(struct pci_bus *bus, struct resource *res,
 		 * overrides "min".
 		 */
 		if (avail.start)
-			min = avail.start;
+			min_used = avail.start;
 
 		max = avail.end;
 
 		/* Ok, try it out.. */
-		ret = allocate_resource(r, res, size, min, max,
+		ret = allocate_resource(r, res, size, min_used, max,
 					align, alignf, alignf_data);
 		if (ret == 0)
 			return 0;

commit b838b39e930aa1cfd099ea82ac40ed6d6413af26
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Sep 22 17:03:54 2015 -0500

    PCI: Clear IORESOURCE_UNSET when clipping a bridge window
    
    c770cb4cb505 ("PCI: Mark invalid BARs as unassigned") sets IORESOURCE_UNSET
    if we fail to claim a resource.  If we tried to claim a bridge window,
    failed, clipped the window, and tried to claim the clipped window, we
    failed again because of IORESOURCE_UNSET:
    
      pci_bus 0000:00: root bus resource [mem 0xc0000000-0xffffffff window]
      pci 0000:00:01.0: can't claim BAR 15 [mem 0xbdf00000-0xddefffff 64bit pref]: no compatible bridge window
      pci 0000:00:01.0: [mem size 0x20000000 64bit pref] clipped to [mem size 0x1df00000 64bit pref]
      pci 0000:00:01.0:   bridge window [mem size 0x1df00000 64bit pref]
      pci 0000:00:01.0: can't claim BAR 15 [mem size 0x1df00000 64bit pref]: no address assigned
    
    The 00:01.0 window started as [mem 0xbdf00000-0xddefffff 64bit pref].  That
    starts before the host bridge window [mem 0xc0000000-0xffffffff window], so
    we clipped the 00:01.0 window to [mem 0xc0000000-0xddefffff 64bit pref].
    But we left it marked IORESOURCE_UNSET, so the second claim failed when it
    should have succeeded.
    
    This means downstream devices will also fail for lack of resources, e.g.,
    in the bugzilla below,
    
      radeon 0000:01:00.0: Fatal error during GPU init
    
    Clear IORESOURCE_UNSET when we clip a bridge window.  Also clear
    IORESOURCE_UNSET in our copy of the unclipped window so we can see exactly
    what the original window was and how it now fits inside the upstream
    window.
    
    Fixes: c770cb4cb505 ("PCI: Mark invalid BARs as unassigned")
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=85491#c47
    Based-on-patch-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Based-on-patch-by: Yinghai Lu <yinghai@kernel.org>
    Tested-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>
    CC: stable@vger.kernel.org      # v4.1+

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index 6fbd3f2b5992..d3346d23963b 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -256,6 +256,8 @@ bool pci_bus_clip_resource(struct pci_dev *dev, int idx)
 
 		res->start = start;
 		res->end = end;
+		res->flags &= ~IORESOURCE_UNSET;
+		orig_res.flags &= ~IORESOURCE_UNSET;
 		dev_printk(KERN_DEBUG, &dev->dev, "%pR clipped to %pR\n",
 				 &orig_res, res);
 

commit 3a9ad0b4fdcd57f775d3615004c8c64c021a9e7d
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Wed May 27 17:23:51 2015 -0700

    PCI: Add pci_bus_addr_t
    
    David Ahern reported that d63e2e1f3df9 ("sparc/PCI: Clip bridge windows
    to fit in upstream windows") fails to boot on sparc/T5-8:
    
      pci 0000:06:00.0: reg 0x184: can't handle BAR above 4GB (bus address 0x110204000)
    
    The problem is that sparc64 assumed that dma_addr_t only needed to hold DMA
    addresses, i.e., bus addresses returned via the DMA API (dma_map_single(),
    etc.), while the PCI core assumed dma_addr_t could hold *any* bus address,
    including raw BAR values.  On sparc64, all DMA addresses fit in 32 bits, so
    dma_addr_t is a 32-bit type.  However, BAR values can be 64 bits wide, so
    they don't fit in a dma_addr_t.  d63e2e1f3df9 added new checking that
    tripped over this mismatch.
    
    Add pci_bus_addr_t, which is wide enough to hold any PCI bus address,
    including both raw BAR values and DMA addresses.  This will be 64 bits
    on 64-bit platforms and on platforms with a 64-bit dma_addr_t.  Then
    dma_addr_t only needs to be wide enough to hold addresses from the DMA API.
    
    [bhelgaas: changelog, bugzilla, Kconfig to ensure pci_bus_addr_t is at
    least as wide as dma_addr_t, documentation]
    Fixes: d63e2e1f3df9 ("sparc/PCI: Clip bridge windows to fit in upstream windows")
    Fixes: 23b13bc76f35 ("PCI: Fail safely if we can't handle BARs larger than 4GB")
    Link: http://lkml.kernel.org/r/CAE9FiQU1gJY1LYrxs+ma5LCTEEe4xmtjRG0aXJ9K_Tsu+m9Wuw@mail.gmail.com
    Link: http://lkml.kernel.org/r/1427857069-6789-1-git-send-email-yinghai@kernel.org
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=96231
    Reported-by: David Ahern <david.ahern@oracle.com>
    Tested-by: David Ahern <david.ahern@oracle.com>
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: David S. Miller <davem@davemloft.net>
    CC: stable@vger.kernel.org      # v3.19+

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index 90fa3a78fb7c..6fbd3f2b5992 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -92,11 +92,11 @@ void pci_bus_remove_resources(struct pci_bus *bus)
 }
 
 static struct pci_bus_region pci_32_bit = {0, 0xffffffffULL};
-#ifdef CONFIG_ARCH_DMA_ADDR_T_64BIT
+#ifdef CONFIG_PCI_BUS_ADDR_T_64BIT
 static struct pci_bus_region pci_64_bit = {0,
-				(dma_addr_t) 0xffffffffffffffffULL};
-static struct pci_bus_region pci_high = {(dma_addr_t) 0x100000000ULL,
-				(dma_addr_t) 0xffffffffffffffffULL};
+				(pci_bus_addr_t) 0xffffffffffffffffULL};
+static struct pci_bus_region pci_high = {(pci_bus_addr_t) 0x100000000ULL,
+				(pci_bus_addr_t) 0xffffffffffffffffULL};
 #endif
 
 /*
@@ -200,7 +200,7 @@ int pci_bus_alloc_resource(struct pci_bus *bus, struct resource *res,
 					  resource_size_t),
 		void *alignf_data)
 {
-#ifdef CONFIG_ARCH_DMA_ADDR_T_64BIT
+#ifdef CONFIG_PCI_BUS_ADDR_T_64BIT
 	int rc;
 
 	if (res->flags & IORESOURCE_MEM_64) {

commit 14d76b68f2819a1d0b50236a7e9e9f2ea69869d9
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Thu Feb 5 13:44:44 2015 +0800

    PCI: Use common resource list management code instead of private implementation
    
    Use common resource list management data structure and interfaces
    instead of private implementation.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index 8fb16188cd82..90fa3a78fb7c 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -20,17 +20,16 @@
 void pci_add_resource_offset(struct list_head *resources, struct resource *res,
 			     resource_size_t offset)
 {
-	struct pci_host_bridge_window *window;
+	struct resource_entry *entry;
 
-	window = kzalloc(sizeof(struct pci_host_bridge_window), GFP_KERNEL);
-	if (!window) {
+	entry = resource_list_create_entry(res, 0);
+	if (!entry) {
 		printk(KERN_ERR "PCI: can't add host bridge window %pR\n", res);
 		return;
 	}
 
-	window->res = res;
-	window->offset = offset;
-	list_add_tail(&window->list, resources);
+	entry->offset = offset;
+	resource_list_add_tail(entry, resources);
 }
 EXPORT_SYMBOL(pci_add_resource_offset);
 
@@ -42,12 +41,7 @@ EXPORT_SYMBOL(pci_add_resource);
 
 void pci_free_resource_list(struct list_head *resources)
 {
-	struct pci_host_bridge_window *window, *tmp;
-
-	list_for_each_entry_safe(window, tmp, resources, list) {
-		list_del(&window->list);
-		kfree(window);
-	}
+	resource_list_free(resources);
 }
 EXPORT_SYMBOL(pci_free_resource_list);
 

commit 0f7e7aee2f37119a32e6e8b63250922442528961
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Thu Jan 15 16:21:49 2015 -0600

    PCI: Add pci_bus_clip_resource() to clip to fit upstream window
    
    Add pci_bus_clip_resource().  If a PCI-PCI bridge window overlaps an
    upstream bridge window but is not completely contained by it, this clips
    the downstream window so it fits inside the upstream one.
    
    No functional change (this adds the function but no callers).
    
    [bhelgaas: changelog, split into separate patch]
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=85491
    Reported-by: Marek Kordik <kordikmarek@gmail.com>
    Fixes: 5b28541552ef ("PCI: Restrict 64-bit prefetchable bridge windows to 64-bit resources")
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    CC: stable@vger.kernel.org      # v3.16+

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index 73aef51a28f0..8fb16188cd82 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -228,6 +228,49 @@ int pci_bus_alloc_resource(struct pci_bus *bus, struct resource *res,
 }
 EXPORT_SYMBOL(pci_bus_alloc_resource);
 
+/*
+ * The @idx resource of @dev should be a PCI-PCI bridge window.  If this
+ * resource fits inside a window of an upstream bridge, do nothing.  If it
+ * overlaps an upstream window but extends outside it, clip the resource so
+ * it fits completely inside.
+ */
+bool pci_bus_clip_resource(struct pci_dev *dev, int idx)
+{
+	struct pci_bus *bus = dev->bus;
+	struct resource *res = &dev->resource[idx];
+	struct resource orig_res = *res;
+	struct resource *r;
+	int i;
+
+	pci_bus_for_each_resource(bus, r, i) {
+		resource_size_t start, end;
+
+		if (!r)
+			continue;
+
+		if (resource_type(res) != resource_type(r))
+			continue;
+
+		start = max(r->start, res->start);
+		end = min(r->end, res->end);
+
+		if (start > end)
+			continue;	/* no overlap */
+
+		if (res->start == start && res->end == end)
+			return false;	/* no change */
+
+		res->start = start;
+		res->end = end;
+		dev_printk(KERN_DEBUG, &dev->dev, "%pR clipped to %pR\n",
+				 &orig_res, res);
+
+		return true;
+	}
+
+	return false;
+}
+
 void __weak pcibios_resource_survey_bus(struct pci_bus *bus) { }
 
 /**

commit b7fe943421396b61b9f7a97c2554ed999e0f3658
Author: Ryan Desfosses <ryan@desfo.org>
Date:   Fri Apr 25 14:32:25 2014 -0600

    PCI: Move EXPORT_SYMBOL so it immediately follows function/variable
    
    Move EXPORT_SYMBOL so it immediately follows the function or variable.
    
    No functional change.
    
    [bhelgaas: squash similar changes, fix hotplug, probe, rom, search, too]
    Signed-off-by: Ryan Desfosses <ryan@desfo.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index 447d393725e1..73aef51a28f0 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -226,6 +226,7 @@ int pci_bus_alloc_resource(struct pci_bus *bus, struct resource *res,
 					 type_mask, alignf, alignf_data,
 					 &pci_32_bit);
 }
+EXPORT_SYMBOL(pci_bus_alloc_resource);
 
 void __weak pcibios_resource_survey_bus(struct pci_bus *bus) { }
 
@@ -253,6 +254,7 @@ void pci_bus_add_device(struct pci_dev *dev)
 
 	dev->is_added = 1;
 }
+EXPORT_SYMBOL_GPL(pci_bus_add_device);
 
 /**
  * pci_bus_add_devices - start driver for PCI devices
@@ -279,6 +281,7 @@ void pci_bus_add_devices(const struct pci_bus *bus)
 			pci_bus_add_devices(child);
 	}
 }
+EXPORT_SYMBOL(pci_bus_add_devices);
 
 /** pci_walk_bus - walk devices on/under bus, calling callback.
  *  @top      bus whose devices should be walked
@@ -344,6 +347,3 @@ void pci_bus_put(struct pci_bus *bus)
 }
 EXPORT_SYMBOL(pci_bus_put);
 
-EXPORT_SYMBOL(pci_bus_alloc_resource);
-EXPORT_SYMBOL_GPL(pci_bus_add_device);
-EXPORT_SYMBOL(pci_bus_add_devices);

commit c893d133eaccdda2516a3e71cd05a7dac2e14b00
Author: Yijing Wang <wangyijing@huawei.com>
Date:   Fri May 30 11:01:03 2014 +0800

    PCI: Make pci_bus_add_device() void
    
    pci_bus_add_device() always returns 0, so there's no point in returning
    anything at all.  Make it a void function and remove the tests of the
    return value from the callers.
    
    [bhelgaas: changelog, remove unused "err" from i82875p_setup_overfl_dev()]
    Signed-off-by: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index ba2bf55a38df..447d393725e1 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -235,7 +235,7 @@ void __weak pcibios_resource_survey_bus(struct pci_bus *bus) { }
  *
  * This adds add sysfs entries and start device drivers
  */
-int pci_bus_add_device(struct pci_dev *dev)
+void pci_bus_add_device(struct pci_dev *dev)
 {
 	int retval;
 
@@ -252,8 +252,6 @@ int pci_bus_add_device(struct pci_dev *dev)
 	WARN_ON(retval < 0);
 
 	dev->is_added = 1;
-
-	return 0;
 }
 
 /**
@@ -266,16 +264,12 @@ void pci_bus_add_devices(const struct pci_bus *bus)
 {
 	struct pci_dev *dev;
 	struct pci_bus *child;
-	int retval;
 
 	list_for_each_entry(dev, &bus->devices, bus_list) {
 		/* Skip already-added devices */
 		if (dev->is_added)
 			continue;
-		retval = pci_bus_add_device(dev);
-		if (retval)
-			dev_err(&dev->dev, "Error adding device (%d)\n",
-				retval);
+		pci_bus_add_device(dev);
 	}
 
 	list_for_each_entry(dev, &bus->devices, bus_list) {

commit 56a3d18279f00c7ccbcdc193ceaf1a2f88c51457
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Sat Apr 5 15:13:33 2014 -0600

    PCI: Remove unnecessary includes of <linux/init.h>
    
    None of these files are actually using any __init type directives and hence
    don't need to include <linux/init.h>.   Most are just a left over from
    __devinit and __cpuinit removal, or simply due to code getting copied from
    one driver to the next.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index fb8aed307c28..ba2bf55a38df 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -13,7 +13,6 @@
 #include <linux/errno.h>
 #include <linux/ioport.h>
 #include <linux/proc_fs.h>
-#include <linux/init.h>
 #include <linux/slab.h>
 
 #include "pci.h"

commit 664c28480c90fb8541bcdd1d4b349e9436165ec7
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Mar 7 13:51:12 2014 -0700

    PCI: Change pci_bus_alloc_resource() type_mask to unsigned long
    
    The pci_bus_alloc_resource() "type_mask" parameter is used to compare with
    the "flags" member of a struct resource, so it should be the same type,
    namely "unsigned long".
    
    No functional change because all current IORESOURCE_* flags fit in 32 bits.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index e3bdc88668ec..fb8aed307c28 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -132,7 +132,7 @@ static void pci_clip_resource_to_region(struct pci_bus *bus,
 
 static int pci_bus_alloc_from_region(struct pci_bus *bus, struct resource *res,
 		resource_size_t size, resource_size_t align,
-		resource_size_t min, unsigned int type_mask,
+		resource_size_t min, unsigned long type_mask,
 		resource_size_t (*alignf)(void *,
 					  const struct resource *,
 					  resource_size_t,
@@ -200,7 +200,7 @@ static int pci_bus_alloc_from_region(struct pci_bus *bus, struct resource *res,
  */
 int pci_bus_alloc_resource(struct pci_bus *bus, struct resource *res,
 		resource_size_t size, resource_size_t align,
-		resource_size_t min, unsigned int type_mask,
+		resource_size_t min, unsigned long type_mask,
 		resource_size_t (*alignf)(void *,
 					  const struct resource *,
 					  resource_size_t,

commit aa11fc58dc71c27701b1f9a529a36a38d4337722
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Mar 7 13:39:01 2014 -0700

    PCI: Check all IORESOURCE_TYPE_BITS in pci_bus_alloc_from_region()
    
    When allocating space from a bus resource, i.e., from apertures leading to
    this bus, make sure the entire resource type matches.  The previous code
    assumed the IORESOURCE_TYPE_BITS field was a bitmask with only a single bit
    set, but this is not true.  IORESOURCE_TYPE_BITS is really an enumeration,
    and we have to check all the bits.
    
    See 72dcb1197228 ("resources: Add register address resource type").
    
    No functional change.  If we used this path for allocating IRQs, DMA
    channels, or bus numbers, this would fix a bug because those types are
    indistinguishable when masked by IORESOURCE_IO | IORESOURCE_MEM.  But we
    don't, so this shouldn't make any difference.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index 38901665c770..e3bdc88668ec 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -144,7 +144,7 @@ static int pci_bus_alloc_from_region(struct pci_bus *bus, struct resource *res,
 	struct resource *r, avail;
 	resource_size_t max;
 
-	type_mask |= IORESOURCE_IO | IORESOURCE_MEM;
+	type_mask |= IORESOURCE_TYPE_BITS;
 
 	pci_bus_for_each_resource(bus, r, i) {
 		if (!r)

commit e20fa6609a0076def469aeb799b1c25558e70042
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Mar 10 10:46:56 2014 -0600

    PCI: Don't check resource_size() in pci_bus_alloc_resource()
    
    Paul reported that after f75b99d5a77d ("PCI: Enforce bus address limits in
    resource allocation") on a 32-bit kernel (CONFIG_PHYS_ADDR_T_64BIT not
    set), intel-gtt complained "can't ioremap flush page - no chipset
    flushing".  In addition, other PCI resource allocations, e.g., for bridge
    windows, failed.
    
    This happens because we incorrectly skip bus resources of
    [mem 0x00000000-0xffffffff] because we think they are of size zero.
    When resource_size_t is 32 bits wide, resource_size() on
    [mem 0x00000000-0xffffffff] returns 0 because (r->end - r->start + 1)
    overflows.
    
    Therefore, we can't use "resource_size() == 0" to decide that allocation
    from this resource will fail.  allocate_resource() should fail anyway if it
    can't satisfy the address constraints, so we should just depend on that.
    
    A [mem 0x00000000-0xffffffff] bus resource is obviously not really valid,
    but we do fall back to it as a default when we don't have information about
    host bridge apertures.
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=71611
    Fixes: f75b99d5a77d PCI: Enforce bus address limits in resource allocation
    Reported-and-tested-by: Paul Bolle <pebolle@tiscali.nl>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index 00660cc502c5..38901665c770 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -162,8 +162,6 @@ static int pci_bus_alloc_from_region(struct pci_bus *bus, struct resource *res,
 
 		avail = *r;
 		pci_clip_resource_to_region(bus, &avail, region);
-		if (!resource_size(&avail))
-			continue;
 
 		/*
 		 * "min" is typically PCIBIOS_MIN_IO or PCIBIOS_MIN_MEM to

commit 96702be560374ee7e7139a34cab03554129abbb4
Merge: 04f982beb900 d56dbf5bab8c
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Jan 10 14:23:15 2014 -0700

    Merge branch 'pci/resource' into next
    
    * pci/resource:
      PCI: Allocate 64-bit BARs above 4G when possible
      PCI: Enforce bus address limits in resource allocation
      PCI: Split out bridge window override of minimum allocation address
      agp/ati: Use PCI_COMMAND instead of hard-coded 4
      agp/intel: Use CPU physical address, not bus address, for ioremap()
      agp/intel: Use pci_bus_address() to get GTTADR bus address
      agp/intel: Use pci_bus_address() to get MMADR bus address
      agp/intel: Support 64-bit GMADR
      agp/intel: Rename gtt_bus_addr to gtt_phys_addr
      drm/i915: Rename gtt_bus_addr to gtt_phys_addr
      agp: Use pci_resource_start() to get CPU physical address for BAR
      agp: Support 64-bit APBASE
      PCI: Add pci_bus_address() to get bus address of a BAR
      PCI: Convert pcibios_resource_to_bus() to take a pci_bus, not a pci_dev
      PCI: Change pci_bus_region addresses to dma_addr_t

commit d56dbf5bab8ce44c5407bb099f71987f58d18bb4
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Fri Dec 20 10:55:44 2013 -0700

    PCI: Allocate 64-bit BARs above 4G when possible
    
    Try to allocate space for 64-bit BARs above 4G first, to preserve the space
    below 4G for 32-bit BARs.  If there's no space above 4G available, fall
    back to allocating anywhere.
    
    [bhelgaas: reworked starting from http://lkml.kernel.org/r/1387485843-17403-2-git-send-email-yinghai@kernel.org]
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index c30baae929f4..86fb8ec5e448 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -102,6 +102,8 @@ static struct pci_bus_region pci_32_bit = {0, 0xffffffffULL};
 #ifdef CONFIG_ARCH_DMA_ADDR_T_64BIT
 static struct pci_bus_region pci_64_bit = {0,
 				(dma_addr_t) 0xffffffffffffffffULL};
+static struct pci_bus_region pci_high = {(dma_addr_t) 0x100000000ULL,
+				(dma_addr_t) 0xffffffffffffffffULL};
 #endif
 
 /*
@@ -198,8 +200,7 @@ static int pci_bus_alloc_from_region(struct pci_bus *bus, struct resource *res,
  * alignment and type, try to find an acceptable resource allocation
  * for a specific device resource.
  */
-int
-pci_bus_alloc_resource(struct pci_bus *bus, struct resource *res,
+int pci_bus_alloc_resource(struct pci_bus *bus, struct resource *res,
 		resource_size_t size, resource_size_t align,
 		resource_size_t min, unsigned int type_mask,
 		resource_size_t (*alignf)(void *,
@@ -209,10 +210,19 @@ pci_bus_alloc_resource(struct pci_bus *bus, struct resource *res,
 		void *alignf_data)
 {
 #ifdef CONFIG_ARCH_DMA_ADDR_T_64BIT
-	if (res->flags & IORESOURCE_MEM_64)
+	int rc;
+
+	if (res->flags & IORESOURCE_MEM_64) {
+		rc = pci_bus_alloc_from_region(bus, res, size, align, min,
+					       type_mask, alignf, alignf_data,
+					       &pci_high);
+		if (rc == 0)
+			return 0;
+
 		return pci_bus_alloc_from_region(bus, res, size, align, min,
 						 type_mask, alignf, alignf_data,
 						 &pci_64_bit);
+	}
 #endif
 
 	return pci_bus_alloc_from_region(bus, res, size, align, min,

commit f75b99d5a77d63f20e07bd276d5a427808ac8ef6
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Fri Dec 20 09:57:37 2013 -0700

    PCI: Enforce bus address limits in resource allocation
    
    When allocating space for 32-bit BARs, we previously limited RESOURCE
    addresses so they would fit in 32 bits.  However, the BUS address need not
    be the same as the resource address, and it's the bus address that must fit
    in the 32-bit BAR.
    
    This patch adds:
    
      - pci_clip_resource_to_region(), which clips a resource so it contains
        only the range that maps to the specified bus address region, e.g., to
        clip a resource to 32-bit bus addresses, and
    
      - pci_bus_alloc_from_region(), which allocates space for a resource from
        the specified bus address region,
    
    and changes pci_bus_alloc_resource() to allocate space for 64-bit BARs from
    the entire bus address region, and space for 32-bit BARs from only the bus
    address region below 4GB.
    
    If we had this window:
    
      pci_root HWP0002:0a: host bridge window [mem 0xf0180000000-0xf01fedfffff] (bus address [0x80000000-0xfedfffff])
    
    we previously could not put a 32-bit BAR there, because the CPU addresses
    don't fit in 32 bits.  This patch fixes this, so we can use this space for
    32-bit BARs.
    
    It's also possible (though unlikely) to have resources with 32-bit CPU
    addresses but bus addresses above 4GB.  In this case the previous code
    would allocate space that a 32-bit BAR could not map.
    
    Remove PCIBIOS_MAX_MEM_32, which is no longer used.
    
    [bhelgaas: reworked starting from http://lkml.kernel.org/r/1386658484-15774-3-git-send-email-yinghai@kernel.org]
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index 6f2f47a7b6c6..c30baae929f4 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -98,41 +98,52 @@ void pci_bus_remove_resources(struct pci_bus *bus)
 	}
 }
 
-/**
- * pci_bus_alloc_resource - allocate a resource from a parent bus
- * @bus: PCI bus
- * @res: resource to allocate
- * @size: size of resource to allocate
- * @align: alignment of resource to allocate
- * @min: minimum /proc/iomem address to allocate
- * @type_mask: IORESOURCE_* type flags
- * @alignf: resource alignment function
- * @alignf_data: data argument for resource alignment function
- *
- * Given the PCI bus a device resides on, the size, minimum address,
- * alignment and type, try to find an acceptable resource allocation
- * for a specific device resource.
+static struct pci_bus_region pci_32_bit = {0, 0xffffffffULL};
+#ifdef CONFIG_ARCH_DMA_ADDR_T_64BIT
+static struct pci_bus_region pci_64_bit = {0,
+				(dma_addr_t) 0xffffffffffffffffULL};
+#endif
+
+/*
+ * @res contains CPU addresses.  Clip it so the corresponding bus addresses
+ * on @bus are entirely within @region.  This is used to control the bus
+ * addresses of resources we allocate, e.g., we may need a resource that
+ * can be mapped by a 32-bit BAR.
  */
-int
-pci_bus_alloc_resource(struct pci_bus *bus, struct resource *res,
+static void pci_clip_resource_to_region(struct pci_bus *bus,
+					struct resource *res,
+					struct pci_bus_region *region)
+{
+	struct pci_bus_region r;
+
+	pcibios_resource_to_bus(bus, &r, res);
+	if (r.start < region->start)
+		r.start = region->start;
+	if (r.end > region->end)
+		r.end = region->end;
+
+	if (r.end < r.start)
+		res->end = res->start - 1;
+	else
+		pcibios_bus_to_resource(bus, res, &r);
+}
+
+static int pci_bus_alloc_from_region(struct pci_bus *bus, struct resource *res,
 		resource_size_t size, resource_size_t align,
 		resource_size_t min, unsigned int type_mask,
 		resource_size_t (*alignf)(void *,
 					  const struct resource *,
 					  resource_size_t,
 					  resource_size_t),
-		void *alignf_data)
+		void *alignf_data,
+		struct pci_bus_region *region)
 {
-	int i, ret = -ENOMEM;
-	struct resource *r;
-	resource_size_t max = -1;
+	int i, ret;
+	struct resource *r, avail;
+	resource_size_t max;
 
 	type_mask |= IORESOURCE_IO | IORESOURCE_MEM;
 
-	/* don't allocate too high if the pref mem doesn't support 64bit*/
-	if (!(res->flags & IORESOURCE_MEM_64))
-		max = PCIBIOS_MAX_MEM_32;
-
 	pci_bus_for_each_resource(bus, r, i) {
 		if (!r)
 			continue;
@@ -147,22 +158,66 @@ pci_bus_alloc_resource(struct pci_bus *bus, struct resource *res,
 		    !(res->flags & IORESOURCE_PREFETCH))
 			continue;
 
+		avail = *r;
+		pci_clip_resource_to_region(bus, &avail, region);
+		if (!resource_size(&avail))
+			continue;
+
 		/*
 		 * "min" is typically PCIBIOS_MIN_IO or PCIBIOS_MIN_MEM to
 		 * protect badly documented motherboard resources, but if
 		 * this is an already-configured bridge window, its start
 		 * overrides "min".
 		 */
-		if (r->start)
-			min = r->start;
+		if (avail.start)
+			min = avail.start;
+
+		max = avail.end;
 
 		/* Ok, try it out.. */
 		ret = allocate_resource(r, res, size, min, max,
 					align, alignf, alignf_data);
 		if (ret == 0)
-			break;
+			return 0;
 	}
-	return ret;
+	return -ENOMEM;
+}
+
+/**
+ * pci_bus_alloc_resource - allocate a resource from a parent bus
+ * @bus: PCI bus
+ * @res: resource to allocate
+ * @size: size of resource to allocate
+ * @align: alignment of resource to allocate
+ * @min: minimum /proc/iomem address to allocate
+ * @type_mask: IORESOURCE_* type flags
+ * @alignf: resource alignment function
+ * @alignf_data: data argument for resource alignment function
+ *
+ * Given the PCI bus a device resides on, the size, minimum address,
+ * alignment and type, try to find an acceptable resource allocation
+ * for a specific device resource.
+ */
+int
+pci_bus_alloc_resource(struct pci_bus *bus, struct resource *res,
+		resource_size_t size, resource_size_t align,
+		resource_size_t min, unsigned int type_mask,
+		resource_size_t (*alignf)(void *,
+					  const struct resource *,
+					  resource_size_t,
+					  resource_size_t),
+		void *alignf_data)
+{
+#ifdef CONFIG_ARCH_DMA_ADDR_T_64BIT
+	if (res->flags & IORESOURCE_MEM_64)
+		return pci_bus_alloc_from_region(bus, res, size, align, min,
+						 type_mask, alignf, alignf_data,
+						 &pci_64_bit);
+#endif
+
+	return pci_bus_alloc_from_region(bus, res, size, align, min,
+					 type_mask, alignf, alignf_data,
+					 &pci_32_bit);
 }
 
 void __weak pcibios_resource_survey_bus(struct pci_bus *bus) { }

commit 36e097a8a29761e0e2c951c0390f1057df248a87
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Dec 18 16:31:39 2013 -0700

    PCI: Split out bridge window override of minimum allocation address
    
    pci_bus_alloc_resource() avoids allocating space below the "min" supplied
    by the caller (usually PCIBIOS_MIN_IO or PCIBIOS_MIN_MEM).  This is to
    protect badly documented motherboard resources.  But if we're allocating
    space inside an already-configured PCI-PCI bridge window, we ignore "min".
    
    See 688d191821de ("pci: make bus resource start address override minimum IO
    address").
    
    This patch moves the check to make it more visible and simplify future
    patches.  No functional change.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index fc1b74013743..6f2f47a7b6c6 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -147,11 +147,18 @@ pci_bus_alloc_resource(struct pci_bus *bus, struct resource *res,
 		    !(res->flags & IORESOURCE_PREFETCH))
 			continue;
 
+		/*
+		 * "min" is typically PCIBIOS_MIN_IO or PCIBIOS_MIN_MEM to
+		 * protect badly documented motherboard resources, but if
+		 * this is an already-configured bridge window, its start
+		 * overrides "min".
+		 */
+		if (r->start)
+			min = r->start;
+
 		/* Ok, try it out.. */
-		ret = allocate_resource(r, res, size,
-					r->start ? : min,
-					max, align,
-					alignf, alignf_data);
+		ret = allocate_resource(r, res, size, min, max,
+					align, alignf, alignf_data);
 		if (ret == 0)
 			break;
 	}

commit ef37702eb3cae2ec35d56ddd4f096cd47fec3f0d
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Sat Nov 30 14:40:28 2013 -0800

    PCI: Move pci_proc_attach_device() to pci_bus_add_device()
    
    4f535093cf8f ("PCI: Put pci_dev in device tree as early as possible")
    moved pci_proc_attach_device() from pci_bus_add_device() to
    pci_device_add().
    
    This moves it back to pci_bus_add_device(), essentially reverting that
    part of 4f535093cf8f.  This makes it symmetric with pci_stop_dev(),
    where we call pci_proc_detach_device() and pci_remove_sysfs_dev_files()
    and set dev->is_added = 0.
    
    [bhelgaas: changelog, create sysfs then attach proc for symmetry]
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index fc1b74013743..a037d81f21ed 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -176,6 +176,7 @@ int pci_bus_add_device(struct pci_dev *dev)
 	 */
 	pci_fixup_device(pci_fixup_final, dev);
 	pci_create_sysfs_dev_files(dev);
+	pci_proc_attach_device(dev);
 
 	dev->match_driver = true;
 	retval = device_attach(&dev->dev);

commit 928bea964827d7824b548c1f8e06eccbbc4d0d7d
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Mon Jul 22 14:37:17 2013 -0700

    PCI: Delay enabling bridges until they're needed
    
    We currently enable PCI bridges after scanning a bus and assigning
    resources.  This is often done in arch code.
    
    This patch changes this so we don't enable a bridge until necessary, i.e.,
    until we enable a PCI device behind the bridge.  We do this in the generic
    pci_enable_device() path, so this also removes the arch-specific code to
    enable bridges.
    
    [bhelgaas: changelog]
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index b1ff02ab4f13..fc1b74013743 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -216,24 +216,6 @@ void pci_bus_add_devices(const struct pci_bus *bus)
 	}
 }
 
-void pci_enable_bridges(struct pci_bus *bus)
-{
-	struct pci_dev *dev;
-	int retval;
-
-	list_for_each_entry(dev, &bus->devices, bus_list) {
-		if (dev->subordinate) {
-			if (!pci_is_enabled(dev)) {
-				retval = pci_enable_device(dev);
-				if (retval)
-					dev_err(&dev->dev, "Error enabling bridge (%d), continuing\n", retval);
-				pci_set_master(dev);
-			}
-			pci_enable_bridges(dev->subordinate);
-		}
-	}
-}
-
 /** pci_walk_bus - walk devices on/under bus, calling callback.
  *  @top      bus whose devices should be walked
  *  @cb       callback to be called for each device found
@@ -301,4 +283,3 @@ EXPORT_SYMBOL(pci_bus_put);
 EXPORT_SYMBOL(pci_bus_alloc_resource);
 EXPORT_SYMBOL_GPL(pci_bus_add_device);
 EXPORT_SYMBOL(pci_bus_add_devices);
-EXPORT_SYMBOL(pci_enable_bridges);

commit fe830ef62ac6d8814e27b7e2f632848694b0e5c7
Author: Jiang Liu <liuj97@gmail.com>
Date:   Sat May 25 21:48:29 2013 +0800

    PCI: Introduce pci_bus_{get|put}() to manage PCI bus reference count
    
    Introduce helper functions pci_bus_{get|put}() to manage PCI bus
    reference count.
    
    Signed-off-by: Jiang Liu <jiang.liu@huawei.com>
    Signed-off-by: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Gu Zheng <guz.fnst@cn.fujitsu.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index 32e66a6f12d9..b1ff02ab4f13 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -283,6 +283,21 @@ void pci_walk_bus(struct pci_bus *top, int (*cb)(struct pci_dev *, void *),
 }
 EXPORT_SYMBOL_GPL(pci_walk_bus);
 
+struct pci_bus *pci_bus_get(struct pci_bus *bus)
+{
+	if (bus)
+		get_device(&bus->dev);
+	return bus;
+}
+EXPORT_SYMBOL(pci_bus_get);
+
+void pci_bus_put(struct pci_bus *bus)
+{
+	if (bus)
+		put_device(&bus->dev);
+}
+EXPORT_SYMBOL(pci_bus_put);
+
 EXPORT_SYMBOL(pci_bus_alloc_resource);
 EXPORT_SYMBOL_GPL(pci_bus_add_device);
 EXPORT_SYMBOL(pci_bus_add_devices);

commit e253aaf0af51c1e4dc7dd3b26ea8e666bf9a2d8d
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Tue May 7 14:35:44 2013 -0600

    PCI: Delay final fixups until resources are assigned
    
    Commit 4f535093cf "PCI: Put pci_dev in device tree as early as possible"
    moved final fixups from pci_bus_add_device() to pci_device_add().  But
    pci_device_add() happens before resource assignment, so BARs may not be
    valid yet.
    
    Typical flow for hot-add:
    
        pciehp_configure_device
          pci_scan_slot
            pci_scan_single_device
              pci_device_add
                pci_fixup_device(pci_fixup_final, dev)  # previous location
          # resource assignment happens here
          pci_bus_add_devices
            pci_bus_add_device
              pci_fixup_device(pci_fixup_final, dev)    # new location
    
    [bhelgaas: changelog, move fixups to pci_bus_add_device()]
    Reference: https://lkml.kernel.org/r/20130415182614.GB9224@xanatos
    Reported-by: David Bulkow <David.Bulkow@stratus.com>
    Tested-by: David Bulkow <David.Bulkow@stratus.com>
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    CC: stable@vger.kernel.org      # v3.9+

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index 748f8f3e9ff5..32e66a6f12d9 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -174,6 +174,7 @@ int pci_bus_add_device(struct pci_dev *dev)
 	 * Can not put in pci_device_add yet because resources
 	 * are not assigned yet for some devices.
 	 */
+	pci_fixup_device(pci_fixup_final, dev);
 	pci_create_sysfs_dev_files(dev);
 
 	dev->match_driver = true;

commit 723ec4d06cb2eed481436cfe008f5f63c45e88fd
Merge: a3b6bbd5774c f39d5b72913e
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Apr 17 10:31:34 2013 -0600

    Merge branch 'pci/cleanup' into next
    
    * pci/cleanup:
      PCI: Remove "extern" from function declarations
      PCI: Warn about failures instead of "must_check" functions
      PCI: Remove __must_check from definitions
      PCI: Remove unused variables
      PCI: Move cpci_hotplug_init() proto to header file
      PCI: Make local functions/structs static
      PCI: Fix missing prototype for pcie_port_acpi_setup()
    
    Conflicts:
            drivers/pci/hotplug/acpiphp.h
            include/linux/pci.h

commit 9fc9eea09f518b9bbdc0a14ef668698c913ba614
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Apr 12 11:35:40 2013 -0600

    PCI: Warn about failures instead of "must_check" functions
    
    These places capture return values to avoid "must_check" warnings,
    but we didn't *do* anything with the return values, which causes
    "set but not used" warnings.  We might as well do something instead
    of just trying to evade the "must_check" warnings.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index 8647dc6f52d0..ee4c4c4fde17 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -202,6 +202,9 @@ void pci_bus_add_devices(const struct pci_bus *bus)
 		if (dev->is_added)
 			continue;
 		retval = pci_bus_add_device(dev);
+		if (retval)
+			dev_err(&dev->dev, "Error adding device (%d)\n",
+				retval);
 	}
 
 	list_for_each_entry(dev, &bus->devices, bus_list) {

commit 981cf9ea9a6a6c422e51fc04bedad00b7792ccbc
Author: Jiang Liu <liuj97@gmail.com>
Date:   Fri Apr 12 05:44:16 2013 +0000

    PCI: Clean up usages of pci_bus->is_added
    
    Now pci_bus->is_added is only used to guard invoking of
    pcibios_fixup_bus() in pci_scan_child_bus(), so just set
    it directly after the fixups and remove the other test
    and set in pci_bus_add_devices().
    
    [bhelgaas: changelog]
    Signed-off-by: Jiang Liu <jiang.liu@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Yinghai Lu <yinghai@kernel.org>

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index 8647dc6f52d0..bdc1e8bf7e60 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -206,16 +206,9 @@ void pci_bus_add_devices(const struct pci_bus *bus)
 
 	list_for_each_entry(dev, &bus->devices, bus_list) {
 		BUG_ON(!dev->is_added);
-
 		child = dev->subordinate;
-
-		if (!child)
-			continue;
-		pci_bus_add_devices(child);
-
-		if (child->is_added)
-			continue;
-		child->is_added = 1;
+		if (child)
+			pci_bus_add_devices(child);
 	}
 }
 

commit 4f535093cf8f6da8cfda7c36c2c1ecd2e9586ee4
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Mon Jan 21 13:20:52 2013 -0800

    PCI: Put pci_dev in device tree as early as possible
    
    We want to put pci_dev structs in the device tree as soon as possible so
    for_each_pci_dev() iteration will not miss them, but driver attachment
    needs to be delayed until after pci_assign_unassigned_resources() to make
    sure all devices have resources assigned first.
    
    This patch moves device registering from pci_bus_add_devices() to
    pci_device_add(), which happens earlier, leaving driver attachment in
    pci_bus_add_devices().
    
    It also removes unattached child bus handling in pci_bus_add_devices().
    That's not needed because child bus via pci_add_new_bus() is already
    in parent bus children list.
    
    [bhelgaas: changelog]
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index c8709c6fdb7c..8647dc6f52d0 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -161,73 +161,35 @@ pci_bus_alloc_resource(struct pci_bus *bus, struct resource *res,
 void __weak pcibios_resource_survey_bus(struct pci_bus *bus) { }
 
 /**
- * pci_bus_add_device - add a single device
+ * pci_bus_add_device - start driver for a single device
  * @dev: device to add
  *
- * This adds a single pci device to the global
- * device list and adds sysfs and procfs entries
+ * This adds add sysfs entries and start device drivers
  */
 int pci_bus_add_device(struct pci_dev *dev)
 {
 	int retval;
 
-	pci_fixup_device(pci_fixup_final, dev);
-
-	retval = pcibios_add_device(dev);
-	if (retval)
-		return retval;
-
-	dev->match_driver = false;
-	retval = device_add(&dev->dev);
-	if (retval)
-		return retval;
+	/*
+	 * Can not put in pci_device_add yet because resources
+	 * are not assigned yet for some devices.
+	 */
+	pci_create_sysfs_dev_files(dev);
 
 	dev->match_driver = true;
 	retval = device_attach(&dev->dev);
 	WARN_ON(retval < 0);
 
 	dev->is_added = 1;
-	pci_proc_attach_device(dev);
-	pci_create_sysfs_dev_files(dev);
-	return 0;
-}
-
-/**
- * pci_bus_add_child - add a child bus
- * @bus: bus to add
- *
- * This adds sysfs entries for a single bus
- */
-int pci_bus_add_child(struct pci_bus *bus)
-{
-	int retval;
-
-	if (bus->bridge)
-		bus->dev.parent = bus->bridge;
-
-	retval = device_register(&bus->dev);
-	if (retval)
-		return retval;
 
-	bus->is_added = 1;
-
-	/* Create legacy_io and legacy_mem files for this bus */
-	pci_create_legacy_files(bus);
-
-	return retval;
+	return 0;
 }
 
 /**
- * pci_bus_add_devices - insert newly discovered PCI devices
+ * pci_bus_add_devices - start driver for PCI devices
  * @bus: bus to check for new devices
  *
- * Add newly discovered PCI devices (which are on the bus->devices
- * list) to the global PCI device list, add the sysfs and procfs
- * entries.  Where a bridge is found, add the discovered bus to
- * the parents list of child buses, and recurse (breadth-first
- * to be compatible with 2.4)
- *
- * Call hotplug for each new devices.
+ * Start driver for PCI devices and add some sysfs entries.
  */
 void pci_bus_add_devices(const struct pci_bus *bus)
 {
@@ -240,36 +202,20 @@ void pci_bus_add_devices(const struct pci_bus *bus)
 		if (dev->is_added)
 			continue;
 		retval = pci_bus_add_device(dev);
-		if (retval)
-			dev_err(&dev->dev, "Error adding device, continuing\n");
 	}
 
 	list_for_each_entry(dev, &bus->devices, bus_list) {
 		BUG_ON(!dev->is_added);
 
 		child = dev->subordinate;
-		/*
-		 * If there is an unattached subordinate bus, attach
-		 * it and then scan for unattached PCI devices.
-		 */
+
 		if (!child)
 			continue;
-		if (list_empty(&child->node)) {
-			down_write(&pci_bus_sem);
-			list_add_tail(&child->node, &dev->bus->children);
-			up_write(&pci_bus_sem);
-		}
 		pci_bus_add_devices(child);
 
-		/*
-		 * register the bus with sysfs as the parent is now
-		 * properly registered.
-		 */
 		if (child->is_added)
 			continue;
-		retval = pci_bus_add_child(child);
-		if (retval)
-			dev_err(&dev->dev, "Error adding bus, continuing\n");
+		child->is_added = 1;
 	}
 }
 

commit 58d9a38f6facb28e935ec2747f6d9e9bf4684118
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Mon Jan 21 13:20:51 2013 -0800

    PCI: Skip attaching driver in device_add()
    
    We want to add PCI devices to the device tree as early as possible but
    delay attaching drivers.
    
    device_add() adds a device to the device hierarchy and (via
    device_attach()) attaches a matching driver and calls its .probe() method.
    We want to separate adding the device to the hierarchy from attaching the
    driver.
    
    This patch does that by adding "match_driver" in struct pci_dev.  When
    false, we return failure from pci_bus_match(), which makes device_attach()
    believe there's no matching driver.
    
    Later, we set "match_driver = true" and call device_attach() again, which
    now attaches the driver and calls its .probe() method.
    
    [bhelgaas: changelog, explicitly init dev->match_driver,
    fold device_attach() call into pci_bus_add_device()]
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index 847f3ca47bb8..c8709c6fdb7c 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -177,10 +177,15 @@ int pci_bus_add_device(struct pci_dev *dev)
 	if (retval)
 		return retval;
 
+	dev->match_driver = false;
 	retval = device_add(&dev->dev);
 	if (retval)
 		return retval;
 
+	dev->match_driver = true;
+	retval = device_attach(&dev->dev);
+	WARN_ON(retval < 0);
+
 	dev->is_added = 1;
 	pci_proc_attach_device(dev);
 	pci_create_sysfs_dev_files(dev);

commit 3c449ed0075994b3f3371f8254560428ba787efc
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Sat Nov 3 21:39:31 2012 -0700

    PCI/ACPI: Reserve firmware-allocated resources for hot-added root buses
    
    Firmware may have assigned PCI BARs for hot-added devices, so reserve
    those resources before trying to allocate more.
    
    [bhelgaas: move empty weak definition here]
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index ad6a8b635692..847f3ca47bb8 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -158,6 +158,8 @@ pci_bus_alloc_resource(struct pci_bus *bus, struct resource *res,
 	return ret;
 }
 
+void __weak pcibios_resource_survey_bus(struct pci_bus *bus) { }
+
 /**
  * pci_bus_add_device - add a single device
  * @dev: device to add

commit 72e1e868ca8f14ef34c95e0e8b73f64b6acf5934
Merge: edb1daab8e91 f9a37be0f02a
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Dec 6 14:37:32 2012 -0700

    Merge branch 'pci/mjg-pci-roms-from-efi' into next
    
    * pci/mjg-pci-roms-from-efi:
      x86: Use PCI setup data
      PCI: Add support for non-BAR ROMs
      PCI: Add pcibios_add_device
      EFI: Stash ROMs if they're not in the PCI BAR

commit eca0d4676d8e29c209ddce0c0c1755472ffc70a6
Author: Matthew Garrett <mjg@redhat.com>
Date:   Wed Dec 5 14:33:27 2012 -0700

    PCI: Add pcibios_add_device
    
    Platforms may want to provide architecture-specific functionality during
    PCI enumeration. Add a pcibios_add_device() call that architectures can
    override to do so.
    
    Signed-off-by: Matthew Garrett <mjg@redhat.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Tested-by: Seth Forshee <seth.forshee@canonical.com>

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index 6241fd05bd41..4f22fa16a3ba 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -170,6 +170,11 @@ int pci_bus_add_device(struct pci_dev *dev)
 	int retval;
 
 	pci_fixup_device(pci_fixup_final, dev);
+
+	retval = pcibios_add_device(dev);
+	if (retval)
+		return retval;
+
 	retval = device_add(&dev->dev);
 	if (retval)
 		return retval;

commit 90b5c1d7c45eeb622302680ff96ed30c1a2b6f0e
Author: Huang Ying <ying.huang@intel.com>
Date:   Wed Oct 24 14:54:13 2012 +0800

    PCI/PM: Fix deadlock when unbinding device if parent in D3cold
    
    If a PCI device and its parents are put into D3cold, unbinding the
    device will trigger deadlock as follow:
    
    - driver_unbind
      - device_release_driver
        - device_lock(dev)                          <--- previous lock here
        - __device_release_driver
          - pm_runtime_get_sync
            ...
              - rpm_resume(dev)
                - rpm_resume(dev->parent)
                  ...
                    - pci_pm_runtime_resume
                      ...
                      - pci_set_power_state
                        - __pci_start_power_transition
                          - pci_wakeup_bus(dev->parent->subordinate)
                            - pci_walk_bus
                              - device_lock(dev)    <--- deadlock here
    
    
    If we do not do device_lock in pci_walk_bus, we can avoid deadlock.
    Device_lock in pci_walk_bus is introduced in commit:
    d71374dafbba7ec3f67371d3b7e9f6310a588808, corresponding email thread
    is: https://lkml.org/lkml/2006/5/26/38.  The patch author Zhang Yanmin
    said device_lock is added to pci_walk_bus because:
    
      Some error handling functions call pci_walk_bus. For example, PCIe
      aer. Here we lock the device, so the driver wouldn't detach from the
      device, as the cb might call driver's callback function.
    
    So I fixed the deadlock as follows:
    
    - remove device_lock from pci_walk_bus
    - add device_lock into callback if callback will call driver's callback
    
    I checked pci_walk_bus users one by one, and found only PCIe aer needs
    device lock.
    
    Signed-off-by: Huang Ying <ying.huang@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    CC: stable@vger.kernel.org              # v3.6+
    CC: Zhang Yanmin <yanmin.zhang@intel.com>

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index 6241fd05bd41..a543746fb354 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -320,10 +320,7 @@ void pci_walk_bus(struct pci_bus *top, int (*cb)(struct pci_dev *, void *),
 		} else
 			next = dev->bus_list.next;
 
-		/* Run device routines with the device locked */
-		device_lock(&dev->dev);
 		retval = cb(dev, userdata);
-		device_unlock(&dev->dev);
 		if (retval)
 			break;
 	}

commit 817a268516f3aaf9e54c5a0f880de37d03ef4c79
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Fri Sep 14 17:48:41 2012 -0700

    PCI: Use correct type when freeing bus resource list
    
    Should use struct pci_bus_resource instead of struct pci_host_bridge_window
    
    Commit 45ca9e9730 ("PCI: add helpers for building PCI bus resource lists")
    added pci_free_resource_list() and used it in pci_bus_remove_resources().
    Later it was also used for host bridge aperture lists, which was fine until
    commit 0efd5aab41 ("PCI: add struct pci_host_bridge_window with CPU/bus
    address offset").  That commit added offset information, so we needed a
    struct pci_host_bridge_window that was separate from struct
    pci_bus_resource.
    
    Commit 0efd5aab41 should have split the host bridge aperture users of
    pci_free_resource_list() from the pci_bus_resource user
    (pci_bus_remove_resources()), but it did not.
    
    [bhelgaas: changelog -- 0efd5aab41 was mine, so this is all my fault]
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index 4b0970b46e0b..6241fd05bd41 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -87,11 +87,15 @@ EXPORT_SYMBOL_GPL(pci_bus_resource_n);
 void pci_bus_remove_resources(struct pci_bus *bus)
 {
 	int i;
+	struct pci_bus_resource *bus_res, *tmp;
 
 	for (i = 0; i < PCI_BRIDGE_RESOURCE_NUM; i++)
 		bus->resource[i] = NULL;
 
-	pci_free_resource_list(&bus->resources);
+	list_for_each_entry_safe(bus_res, tmp, &bus->resources, list) {
+		list_del(&bus_res->list);
+		kfree(bus_res);
+	}
 }
 
 /**

commit 95df8b8708a8b381bf276d83c56f7b4e7de04a71
Author: Myron Stowe <myron.stowe@redhat.com>
Date:   Fri Jul 13 14:29:00 2012 -0600

    PCI: fix undefined reference to 'pci_fixup_final_inited'
    
    My "PCI: Integrate 'pci_fixup_final' quirks into hot-plug paths" patch
    introduced an undefined reference to 'pci_fixup_final_inited' when
    CONFIG_PCI_QUIRKS is not enabled (on x86_64):
      drivers/built-in.o: In function `pci_bus_add_device':
      (.text+0x4f62): undefined reference to `pci_fixup_final_inited'
    
    This patch removes the external reference ending up with a result closer
    to what we ultimately want when the boot path issues described in the
    original patch are resolved.
    
    References:
      https://lkml.org/lkml/2012/7/9/542    Original, offending, patch
      https://lkml.org/lkml/2012/7/12/338   Randy's catch
    
    Reported-by: Randy Dunlap <rdunlap@xenotime.net>
    Signed-off-by: Myron Stowe <myron.stowe@redhat.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Randy Dunlap <rdunlap@xenotime.net>

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index b511bd4e3f7c..4b0970b46e0b 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -164,10 +164,8 @@ pci_bus_alloc_resource(struct pci_bus *bus, struct resource *res,
 int pci_bus_add_device(struct pci_dev *dev)
 {
 	int retval;
-	extern bool pci_fixup_final_inited;
 
-	if (pci_fixup_final_inited)
-		pci_fixup_device(pci_fixup_final, dev);
+	pci_fixup_device(pci_fixup_final, dev);
 	retval = device_add(&dev->dev);
 	if (retval)
 		return retval;

commit 735bff10c157fdbba2291e10ca3e28a59c7acc1c
Author: Myron Stowe <myron.stowe@redhat.com>
Date:   Mon Jul 9 15:36:46 2012 -0600

    PCI: call final fixups hot-added devices
    
    Final fixups are currently applied only at boot-time by
    pci_apply_final_quirks(), which is an fs_initcall().  Hot-added devices
    don't get these fixups, so they may not be completely initialized.
    
    This patch makes us run final fixups for hot-added devices in
    pci_bus_add_device() just before the new device becomes eligible for driver
    binding.
    
    This patch keeps the fs_initcall() for devices present at boot because we
    do resource assignment between pci_bus_add_device and the fs_initcall(),
    and we don't want to break any fixups that depend on that assignment.  This
    is a design issue that may be addressed in the future -- any resource
    assignment should be done *before* device_add().
    
    [bhelgaas: changelog]
    Signed-off-by: Myron Stowe <myron.stowe@redhat.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index 4ce5ef2f2826..b511bd4e3f7c 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -164,6 +164,10 @@ pci_bus_alloc_resource(struct pci_bus *bus, struct resource *res,
 int pci_bus_add_device(struct pci_dev *dev)
 {
 	int retval;
+	extern bool pci_fixup_final_inited;
+
+	if (pci_fixup_final_inited)
+		pci_fixup_device(pci_fixup_final, dev);
 	retval = device_add(&dev->dev);
 	if (retval)
 		return retval;

commit 0efd5aab41e18a1175f72641696cfda154ba6c87
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Feb 23 20:19:00 2012 -0700

    PCI: add struct pci_host_bridge_window with CPU/bus address offset
    
    Some PCI host bridges apply an address offset, so bus addresses on PCI are
    different from CPU addresses.  This patch adds a way for architectures to
    tell the PCI core about this offset.  For example:
    
        LIST_HEAD(resources);
        pci_add_resource_offset(&resources, host->io_space, host->io_offset);
        pci_add_resource_offset(&resources, host->mem_space, host->mem_offset);
        pci_scan_root_bus(parent, bus, ops, sysdata, &resources);
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index 398f5d859791..4ce5ef2f2826 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -18,28 +18,36 @@
 
 #include "pci.h"
 
-void pci_add_resource(struct list_head *resources, struct resource *res)
+void pci_add_resource_offset(struct list_head *resources, struct resource *res,
+			     resource_size_t offset)
 {
-	struct pci_bus_resource *bus_res;
+	struct pci_host_bridge_window *window;
 
-	bus_res = kzalloc(sizeof(struct pci_bus_resource), GFP_KERNEL);
-	if (!bus_res) {
-		printk(KERN_ERR "PCI: can't add bus resource %pR\n", res);
+	window = kzalloc(sizeof(struct pci_host_bridge_window), GFP_KERNEL);
+	if (!window) {
+		printk(KERN_ERR "PCI: can't add host bridge window %pR\n", res);
 		return;
 	}
 
-	bus_res->res = res;
-	list_add_tail(&bus_res->list, resources);
+	window->res = res;
+	window->offset = offset;
+	list_add_tail(&window->list, resources);
+}
+EXPORT_SYMBOL(pci_add_resource_offset);
+
+void pci_add_resource(struct list_head *resources, struct resource *res)
+{
+	pci_add_resource_offset(resources, res, 0);
 }
 EXPORT_SYMBOL(pci_add_resource);
 
 void pci_free_resource_list(struct list_head *resources)
 {
-	struct pci_bus_resource *bus_res, *tmp;
+	struct pci_host_bridge_window *window, *tmp;
 
-	list_for_each_entry_safe(bus_res, tmp, resources, list) {
-		list_del(&bus_res->list);
-		kfree(bus_res);
+	list_for_each_entry_safe(window, tmp, resources, list) {
+		list_del(&window->list);
+		kfree(window);
 	}
 }
 EXPORT_SYMBOL(pci_free_resource_list);

commit 45ca9e9730c5acdb482dd95799fd8ac834481897
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Oct 28 16:25:35 2011 -0600

    PCI: add helpers for building PCI bus resource lists
    
    We'd like to supply a list of resources when we create a new PCI bus,
    e.g., the root bus under a PCI host bridge.  These are helpers for
    constructing that list.
    
    These are exported because the plan is to replace this exported interface:
        pci_scan_bus_parented()
    with this one:
        pci_add_resource(resources, ...)
        pci_scan_root_bus(..., resources)
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index 1e2ad92a4752..398f5d859791 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -18,6 +18,32 @@
 
 #include "pci.h"
 
+void pci_add_resource(struct list_head *resources, struct resource *res)
+{
+	struct pci_bus_resource *bus_res;
+
+	bus_res = kzalloc(sizeof(struct pci_bus_resource), GFP_KERNEL);
+	if (!bus_res) {
+		printk(KERN_ERR "PCI: can't add bus resource %pR\n", res);
+		return;
+	}
+
+	bus_res->res = res;
+	list_add_tail(&bus_res->list, resources);
+}
+EXPORT_SYMBOL(pci_add_resource);
+
+void pci_free_resource_list(struct list_head *resources)
+{
+	struct pci_bus_resource *bus_res, *tmp;
+
+	list_for_each_entry_safe(bus_res, tmp, resources, list) {
+		list_del(&bus_res->list);
+		kfree(bus_res);
+	}
+}
+EXPORT_SYMBOL(pci_free_resource_list);
+
 void pci_bus_add_resource(struct pci_bus *bus, struct resource *res,
 			  unsigned int flags)
 {
@@ -52,16 +78,12 @@ EXPORT_SYMBOL_GPL(pci_bus_resource_n);
 
 void pci_bus_remove_resources(struct pci_bus *bus)
 {
-	struct pci_bus_resource *bus_res, *tmp;
 	int i;
 
 	for (i = 0; i < PCI_BRIDGE_RESOURCE_NUM; i++)
 		bus->resource[i] = NULL;
 
-	list_for_each_entry_safe(bus_res, tmp, &bus->resources, list) {
-		list_del(&bus_res->list);
-		kfree(bus_res);
-	}
+	pci_free_resource_list(&bus->resources);
 }
 
 /**

commit dc2c2c9dd513dec6c17df04e8abff795e20a5271
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Thu May 12 17:11:40 2011 -0700

    PCI/sysfs: move bus cpuaffinity to class dev_attrs
    
    Requested by Greg KH to fix a race condition in the creating of PCI bus
    cpuaffinity files.
    
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index 69546e9213dd..1e2ad92a4752 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -163,12 +163,6 @@ int pci_bus_add_child(struct pci_bus *bus)
 
 	bus->is_added = 1;
 
-	retval = device_create_file(&bus->dev, &dev_attr_cpuaffinity);
-	if (retval)
-		return retval;
-
-	retval = device_create_file(&bus->dev, &dev_attr_cpulistaffinity);
-
 	/* Create legacy_io and legacy_mem files for this bus */
 	pci_create_legacy_files(bus);
 

commit 6db45b76eaa08133187f2cb44d496de7e9503aa8
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Thu Dec 16 10:38:36 2010 -0700

    Revert "PCI: allocate bus resources from the top down"
    
    This reverts commit b126b4703afa4010b161784a43650337676dd03b.
    
    We're going back to the old behavior of allocating from bus resources
    in _CRS order.
    
    Acked-by: H. Peter Anvin <hpa@zytor.com>
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index 5624db8c9ad0..69546e9213dd 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -64,49 +64,6 @@ void pci_bus_remove_resources(struct pci_bus *bus)
 	}
 }
 
-/*
- * Find the highest-address bus resource below the cursor "res".  If the
- * cursor is NULL, return the highest resource.
- */
-static struct resource *pci_bus_find_resource_prev(struct pci_bus *bus,
-						   unsigned int type,
-						   struct resource *res)
-{
-	struct resource *r, *prev = NULL;
-	int i;
-
-	pci_bus_for_each_resource(bus, r, i) {
-		if (!r)
-			continue;
-
-		if ((r->flags & IORESOURCE_TYPE_BITS) != type)
-			continue;
-
-		/* If this resource is at or past the cursor, skip it */
-		if (res) {
-			if (r == res)
-				continue;
-			if (r->end > res->end)
-				continue;
-			if (r->end == res->end && r->start > res->start)
-				continue;
-		}
-
-		if (!prev)
-			prev = r;
-
-		/*
-		 * A small resource is higher than a large one that ends at
-		 * the same address.
-		 */
-		if (r->end > prev->end ||
-		    (r->end == prev->end && r->start > prev->start))
-			prev = r;
-	}
-
-	return prev;
-}
-
 /**
  * pci_bus_alloc_resource - allocate a resource from a parent bus
  * @bus: PCI bus
@@ -132,10 +89,9 @@ pci_bus_alloc_resource(struct pci_bus *bus, struct resource *res,
 					  resource_size_t),
 		void *alignf_data)
 {
-	int ret = -ENOMEM;
+	int i, ret = -ENOMEM;
 	struct resource *r;
 	resource_size_t max = -1;
-	unsigned int type = res->flags & IORESOURCE_TYPE_BITS;
 
 	type_mask |= IORESOURCE_IO | IORESOURCE_MEM;
 
@@ -143,9 +99,10 @@ pci_bus_alloc_resource(struct pci_bus *bus, struct resource *res,
 	if (!(res->flags & IORESOURCE_MEM_64))
 		max = PCIBIOS_MAX_MEM_32;
 
-	/* Look for space at highest addresses first */
-	r = pci_bus_find_resource_prev(bus, type, NULL);
-	for ( ; r; r = pci_bus_find_resource_prev(bus, type, r)) {
+	pci_bus_for_each_resource(bus, r, i) {
+		if (!r)
+			continue;
+
 		/* type_mask must match */
 		if ((res->flags ^ r->flags) & type_mask)
 			continue;

commit ac57cd5ee1935d1e60de86d75f13f377775f1c96
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Thu Dec 16 10:38:20 2010 -0700

    Revert "PCI: fix pci_bus_alloc_resource() hang, prefer positive decode"
    
    This reverts commit 82e3e767c21fef2b1b38868e20eb4e470a1e38e3.
    
    We're going back to considering bus resources in the order we found
    them (in _CRS order, when we're using _CRS), so we don't need to
    define any ordering.
    
    Acked-by: H. Peter Anvin <hpa@zytor.com>
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index 003170ea2e39..5624db8c9ad0 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -64,57 +64,17 @@ void pci_bus_remove_resources(struct pci_bus *bus)
 	}
 }
 
-static bool pci_bus_resource_better(struct resource *res1, bool pos1,
-				    struct resource *res2, bool pos2)
-{
-	/* If exactly one is positive decode, always prefer that one */
-	if (pos1 != pos2)
-		return pos1 ? true : false;
-
-	/* Prefer the one that contains the highest address */
-	if (res1->end != res2->end)
-		return (res1->end > res2->end) ? true : false;
-
-	/* Otherwise, prefer the one with highest "center of gravity" */
-	if (res1->start != res2->start)
-		return (res1->start > res2->start) ? true : false;
-
-	/* Otherwise, choose one arbitrarily (but consistently) */
-	return (res1 > res2) ? true : false;
-}
-
-static bool pci_bus_resource_positive(struct pci_bus *bus, struct resource *res)
-{
-	struct pci_bus_resource *bus_res;
-
-	/*
-	 * This relies on the fact that pci_bus.resource[] refers to P2P or
-	 * CardBus bridge base/limit registers, which are always positively
-	 * decoded.  The pci_bus.resources list contains host bridge or
-	 * subtractively decoded resources.
-	 */
-	list_for_each_entry(bus_res, &bus->resources, list) {
-		if (bus_res->res == res)
-			return (bus_res->flags & PCI_SUBTRACTIVE_DECODE) ?
-				false : true;
-	}
-	return true;
-}
-
 /*
- * Find the next-best bus resource after the cursor "res".  If the cursor is
- * NULL, return the best resource.  "Best" means that we prefer positive
- * decode regions over subtractive decode, then those at higher addresses.
+ * Find the highest-address bus resource below the cursor "res".  If the
+ * cursor is NULL, return the highest resource.
  */
 static struct resource *pci_bus_find_resource_prev(struct pci_bus *bus,
 						   unsigned int type,
 						   struct resource *res)
 {
-	bool res_pos, r_pos, prev_pos = false;
 	struct resource *r, *prev = NULL;
 	int i;
 
-	res_pos = pci_bus_resource_positive(bus, res);
 	pci_bus_for_each_resource(bus, r, i) {
 		if (!r)
 			continue;
@@ -122,14 +82,26 @@ static struct resource *pci_bus_find_resource_prev(struct pci_bus *bus,
 		if ((r->flags & IORESOURCE_TYPE_BITS) != type)
 			continue;
 
-		r_pos = pci_bus_resource_positive(bus, r);
-		if (!res || pci_bus_resource_better(res, res_pos, r, r_pos)) {
-			if (!prev || pci_bus_resource_better(r, r_pos,
-							     prev, prev_pos)) {
-				prev = r;
-				prev_pos = r_pos;
-			}
+		/* If this resource is at or past the cursor, skip it */
+		if (res) {
+			if (r == res)
+				continue;
+			if (r->end > res->end)
+				continue;
+			if (r->end == res->end && r->start > res->start)
+				continue;
 		}
+
+		if (!prev)
+			prev = r;
+
+		/*
+		 * A small resource is higher than a large one that ends at
+		 * the same address.
+		 */
+		if (r->end > prev->end ||
+		    (r->end == prev->end && r->start > prev->start))
+			prev = r;
 	}
 
 	return prev;

commit 82e3e767c21fef2b1b38868e20eb4e470a1e38e3
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Wed Nov 10 10:26:07 2010 -0700

    PCI: fix pci_bus_alloc_resource() hang, prefer positive decode
    
    When a PCI bus has two resources with the same start/end, e.g.,
    
        pci_bus 0000:04: resource 2 [mem 0xd0000000-0xd7ffffff pref]
        pci_bus 0000:04: resource 7 [mem 0xd0000000-0xd7ffffff]
    
    the previous pci_bus_find_resource_prev() implementation would alternate
    between them forever:
    
        pci_bus_find_resource_prev(... [mem 0xd0000000-0xd7ffffff pref])
            returns [mem 0xd0000000-0xd7ffffff]
        pci_bus_find_resource_prev(... [mem 0xd0000000-0xd7ffffff])
            returns [mem 0xd0000000-0xd7ffffff pref]
        pci_bus_find_resource_prev(... [mem 0xd0000000-0xd7ffffff pref])
            returns [mem 0xd0000000-0xd7ffffff]
        ...
    
    This happened because there was no ordering between two resources with the
    same start and end.  A resource that had the same start and end as the
    cursor, but was not itself the cursor, was considered to be before the
    cursor.
    
    This patch fixes the hang by making a fixed ordering between any two
    resources.
    
    In addition, it tries to allocate from positively decoded regions before
    using any subtractively decoded resources.  This means we will use a
    positive decode region before a subtractive decode one, even if it means
    using a smaller address.
    
    Reference: https://bugzilla.kernel.org/show_bug.cgi?id=22062
    Reported-by: Borislav Petkov <bp@amd64.org>
    Tested-by: Borislav Petkov <bp@amd64.org>
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index 5624db8c9ad0..003170ea2e39 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -64,17 +64,57 @@ void pci_bus_remove_resources(struct pci_bus *bus)
 	}
 }
 
+static bool pci_bus_resource_better(struct resource *res1, bool pos1,
+				    struct resource *res2, bool pos2)
+{
+	/* If exactly one is positive decode, always prefer that one */
+	if (pos1 != pos2)
+		return pos1 ? true : false;
+
+	/* Prefer the one that contains the highest address */
+	if (res1->end != res2->end)
+		return (res1->end > res2->end) ? true : false;
+
+	/* Otherwise, prefer the one with highest "center of gravity" */
+	if (res1->start != res2->start)
+		return (res1->start > res2->start) ? true : false;
+
+	/* Otherwise, choose one arbitrarily (but consistently) */
+	return (res1 > res2) ? true : false;
+}
+
+static bool pci_bus_resource_positive(struct pci_bus *bus, struct resource *res)
+{
+	struct pci_bus_resource *bus_res;
+
+	/*
+	 * This relies on the fact that pci_bus.resource[] refers to P2P or
+	 * CardBus bridge base/limit registers, which are always positively
+	 * decoded.  The pci_bus.resources list contains host bridge or
+	 * subtractively decoded resources.
+	 */
+	list_for_each_entry(bus_res, &bus->resources, list) {
+		if (bus_res->res == res)
+			return (bus_res->flags & PCI_SUBTRACTIVE_DECODE) ?
+				false : true;
+	}
+	return true;
+}
+
 /*
- * Find the highest-address bus resource below the cursor "res".  If the
- * cursor is NULL, return the highest resource.
+ * Find the next-best bus resource after the cursor "res".  If the cursor is
+ * NULL, return the best resource.  "Best" means that we prefer positive
+ * decode regions over subtractive decode, then those at higher addresses.
  */
 static struct resource *pci_bus_find_resource_prev(struct pci_bus *bus,
 						   unsigned int type,
 						   struct resource *res)
 {
+	bool res_pos, r_pos, prev_pos = false;
 	struct resource *r, *prev = NULL;
 	int i;
 
+	res_pos = pci_bus_resource_positive(bus, res);
 	pci_bus_for_each_resource(bus, r, i) {
 		if (!r)
 			continue;
@@ -82,26 +122,14 @@ static struct resource *pci_bus_find_resource_prev(struct pci_bus *bus,
 		if ((r->flags & IORESOURCE_TYPE_BITS) != type)
 			continue;
 
-		/* If this resource is at or past the cursor, skip it */
-		if (res) {
-			if (r == res)
-				continue;
-			if (r->end > res->end)
-				continue;
-			if (r->end == res->end && r->start > res->start)
-				continue;
+		r_pos = pci_bus_resource_positive(bus, r);
+		if (!res || pci_bus_resource_better(res, res_pos, r, r_pos)) {
+			if (!prev || pci_bus_resource_better(r, r_pos,
+							     prev, prev_pos)) {
+				prev = r;
+				prev_pos = r_pos;
+			}
 		}
-
-		if (!prev)
-			prev = r;
-
-		/*
-		 * A small resource is higher than a large one that ends at
-		 * the same address.
-		 */
-		if (r->end > prev->end ||
-		    (r->end == prev->end && r->start > prev->start))
-			prev = r;
 	}
 
 	return prev;

commit 18cb657ca1bafe635f368346a1676fb04c512edf
Merge: 2301b65b86df e28c31a96b15
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Oct 28 17:11:17 2010 -0700

    Merge branch 'stable/xen-pcifront-0.8.2' of git://git.kernel.org/pub/scm/linux/kernel/git/konrad/xen
      and branch 'for-linus' of git://xenbits.xen.org/people/sstabellini/linux-pvhvm
    
    * 'for-linus' of git://xenbits.xen.org/people/sstabellini/linux-pvhvm:
      xen: register xen pci notifier
      xen: initialize cpu masks for pv guests in xen_smp_init
      xen: add a missing #include to arch/x86/pci/xen.c
      xen: mask the MTRR feature from the cpuid
      xen: make hvc_xen console work for dom0.
      xen: add the direct mapping area for ISA bus access
      xen: Initialize xenbus for dom0.
      xen: use vcpu_ops to setup cpu masks
      xen: map a dummy page for local apic and ioapic in xen_set_fixmap
      xen: remap MSIs into pirqs when running as initial domain
      xen: remap GSIs as pirqs when running as initial domain
      xen: introduce XEN_DOM0 as a silent option
      xen: map MSIs into pirqs
      xen: support GSI -> pirq remapping in PV on HVM guests
      xen: add xen hvm acpi_register_gsi variant
      acpi: use indirect call to register gsi in different modes
      xen: implement xen_hvm_register_pirq
      xen: get the maximum number of pirqs from xen
      xen: support pirq != irq
    
    * 'stable/xen-pcifront-0.8.2' of git://git.kernel.org/pub/scm/linux/kernel/git/konrad/xen: (27 commits)
      X86/PCI: Remove the dependency on isapnp_disable.
      xen: Update Makefile with CONFIG_BLOCK dependency for biomerge.c
      MAINTAINERS: Add myself to the Xen Hypervisor Interface and remove Chris Wright.
      x86: xen: Sanitse irq handling (part two)
      swiotlb-xen: On x86-32 builts, select SWIOTLB instead of depending on it.
      MAINTAINERS: Add myself for Xen PCI and Xen SWIOTLB maintainer.
      xen/pci: Request ACS when Xen-SWIOTLB is activated.
      xen-pcifront: Xen PCI frontend driver.
      xenbus: prevent warnings on unhandled enumeration values
      xenbus: Xen paravirtualised PCI hotplug support.
      xen/x86/PCI: Add support for the Xen PCI subsystem
      x86: Introduce x86_msi_ops
      msi: Introduce default_[teardown|setup]_msi_irqs with fallback.
      x86/PCI: Export pci_walk_bus function.
      x86/PCI: make sure _PAGE_IOMAP it set on pci mappings
      x86/PCI: Clean up pci_cache_line_size
      xen: fix shared irq device passthrough
      xen: Provide a variant of xen_poll_irq with timeout.
      xen: Find an unbound irq number in reverse order (high to low).
      xen: statically initialize cpu_evtchn_mask_p
      ...
    
    Fix up trivial conflicts in drivers/pci/Makefile

commit b126b4703afa4010b161784a43650337676dd03b
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Oct 26 15:41:39 2010 -0600

    PCI: allocate bus resources from the top down
    
    Allocate space from the highest-address PCI bus resource first, then work
    downward.
    
    Previously, we looked for space in PCI host bridge windows in the order
    we discovered the windows.  For example, given the following windows
    (discovered via an ACPI _CRS method):
    
        pci_root PNP0A03:00: host bridge window [mem 0x000a0000-0x000bffff]
        pci_root PNP0A03:00: host bridge window [mem 0x000c0000-0x000effff]
        pci_root PNP0A03:00: host bridge window [mem 0x000f0000-0x000fffff]
        pci_root PNP0A03:00: host bridge window [mem 0xbff00000-0xf7ffffff]
        pci_root PNP0A03:00: host bridge window [mem 0xff980000-0xff980fff]
        pci_root PNP0A03:00: host bridge window [mem 0xff97c000-0xff97ffff]
        pci_root PNP0A03:00: host bridge window [mem 0xfed20000-0xfed9ffff]
    
    we attempted to allocate from [mem 0x000a0000-0x000bffff] first, then
    [mem 0x000c0000-0x000effff], and so on.
    
    With this patch, we allocate from [mem 0xff980000-0xff980fff] first, then
    [mem 0xff97c000-0xff97ffff], [mem 0xfed20000-0xfed9ffff], etc.
    
    Allocating top-down follows Windows practice, so we're less likely to
    trip over BIOS defects in the _CRS description.
    
    On the machine above (a Dell T3500), the [mem 0xbff00000-0xbfffffff] region
    doesn't actually work and is likely a BIOS defect.  The symptom is that we
    move the AHCI controller to 0xbff00000, which leads to "Boot has failed,
    sleeping forever," a BUG in ahci_stop_engine(), or some other boot failure.
    
    Reference: https://bugzilla.kernel.org/show_bug.cgi?id=16228#c43
    Reference: https://bugzilla.redhat.com/show_bug.cgi?id=620313
    Reference: https://bugzilla.redhat.com/show_bug.cgi?id=629933
    Reported-by: Brian Bloniarz <phunge0@hotmail.com>
    Reported-and-tested-by: Stefan Becker <chemobejk@gmail.com>
    Reported-by: Denys Vlasenko <dvlasenk@redhat.com>
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index 7f0af0e9b826..172bf26e0680 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -64,6 +64,49 @@ void pci_bus_remove_resources(struct pci_bus *bus)
 	}
 }
 
+/*
+ * Find the highest-address bus resource below the cursor "res".  If the
+ * cursor is NULL, return the highest resource.
+ */
+static struct resource *pci_bus_find_resource_prev(struct pci_bus *bus,
+						   unsigned int type,
+						   struct resource *res)
+{
+	struct resource *r, *prev = NULL;
+	int i;
+
+	pci_bus_for_each_resource(bus, r, i) {
+		if (!r)
+			continue;
+
+		if ((r->flags & IORESOURCE_TYPE_BITS) != type)
+			continue;
+
+		/* If this resource is at or past the cursor, skip it */
+		if (res) {
+			if (r == res)
+				continue;
+			if (r->end > res->end)
+				continue;
+			if (r->end == res->end && r->start > res->start)
+				continue;
+		}
+
+		if (!prev)
+			prev = r;
+
+		/*
+		 * A small resource is higher than a large one that ends at
+		 * the same address.
+		 */
+		if (r->end > prev->end ||
+		    (r->end == prev->end && r->start > prev->start))
+			prev = r;
+	}
+
+	return prev;
+}
+
 /**
  * pci_bus_alloc_resource - allocate a resource from a parent bus
  * @bus: PCI bus
@@ -89,9 +132,10 @@ pci_bus_alloc_resource(struct pci_bus *bus, struct resource *res,
 					  resource_size_t),
 		void *alignf_data)
 {
-	int i, ret = -ENOMEM;
+	int ret = -ENOMEM;
 	struct resource *r;
 	resource_size_t max = -1;
+	unsigned int type = res->flags & IORESOURCE_TYPE_BITS;
 
 	type_mask |= IORESOURCE_IO | IORESOURCE_MEM;
 
@@ -99,10 +143,9 @@ pci_bus_alloc_resource(struct pci_bus *bus, struct resource *res,
 	if (!(res->flags & IORESOURCE_MEM_64))
 		max = PCIBIOS_MAX_MEM_32;
 
-	pci_bus_for_each_resource(bus, r, i) {
-		if (!r)
-			continue;
-
+	/* Look for space at highest addresses first */
+	r = pci_bus_find_resource_prev(bus, type, NULL);
+	for ( ; r; r = pci_bus_find_resource_prev(bus, type, r)) {
 		/* type_mask must match */
 		if ((res->flags ^ r->flags) & type_mask)
 			continue;

commit 7c94def89aa5091706e03b98047c074d7ac74af0
Author: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
Date:   Tue Dec 22 14:49:45 2009 -0500

    x86/PCI: Export pci_walk_bus function.
    
    In preperation of modularizing Xen-pcifront the pci_walk_bus
    needs to be exported so that the xen-pcifront module can walk
    call the pci subsystem to walk the PCI devices and claim them.
    
    Signed-off-by: Jeremy Fitzhardinge <jeremy.fitzhardinge@citrix.com>
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Acked-by: Jesse Barnes <jbarnes@virtuousgeek.org> [http://marc.info/?l=linux-pci&m=126149958010298&w=2]

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index 7f0af0e9b826..69546e9213dd 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -299,6 +299,7 @@ void pci_walk_bus(struct pci_bus *top, int (*cb)(struct pci_dev *, void *),
 	}
 	up_read(&pci_bus_sem);
 }
+EXPORT_SYMBOL_GPL(pci_walk_bus);
 
 EXPORT_SYMBOL(pci_bus_alloc_resource);
 EXPORT_SYMBOL_GPL(pci_bus_add_device);

commit 2eb5ebd3665a38a4526b45cb3a31a132b2aa9927
Author: Junchang Wang <junchangwang@gmail.com>
Date:   Fri Jun 18 10:02:33 2010 +0800

    PCI: check return value of pci_enable_device() when enabling bridges
    
    pci_enable_device can fail. In that case, a printed warning would be
    more appropriate.
    
    Signed-off-by: Justin P. Mattock <justinmattock@gmail.com>
    Signed-off-by: Junchang Wang <junchangwang@gmail.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index 42eea5fbc13b..7f0af0e9b826 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -240,6 +240,8 @@ void pci_enable_bridges(struct pci_bus *bus)
 		if (dev->subordinate) {
 			if (!pci_is_enabled(dev)) {
 				retval = pci_enable_device(dev);
+				if (retval)
+					dev_err(&dev->dev, "Error enabling bridge (%d), continuing\n", retval);
 				pci_set_master(dev);
 			}
 			pci_enable_bridges(dev->subordinate);

commit 7736a05a320712c0a9b8f9e1cd0688b2c0848009
Author: Stephen Hemminger <shemminger@vyatta.com>
Date:   Tue Jun 1 09:00:16 2010 -0700

    PCI: sparse warning (trivial)
    
    Assigning zero where NULL should be used.
    
    Signed-off-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index 628ea20a8841..42eea5fbc13b 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -56,7 +56,7 @@ void pci_bus_remove_resources(struct pci_bus *bus)
 	int i;
 
 	for (i = 0; i < PCI_BRIDGE_RESOURCE_NUM; i++)
-		bus->resource[i] = 0;
+		bus->resource[i] = NULL;
 
 	list_for_each_entry_safe(bus_res, tmp, &bus->resources, list) {
 		list_del(&bus_res->list);

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index 26301cb25e7f..628ea20a8841 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -14,6 +14,7 @@
 #include <linux/ioport.h>
 #include <linux/proc_fs.h>
 #include <linux/init.h>
+#include <linux/slab.h>
 
 #include "pci.h"
 

commit 8e9394ce2412254ec69fd2a4f3e44a66eade2297
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed Feb 17 10:57:05 2010 -0800

    Driver core: create lock/unlock functions for struct device
    
    In the future, we are going to be changing the lock type for struct
    device (once we get the lockdep infrastructure properly worked out)  To
    make that changeover easier, and to possibly burry the lock in a
    different part of struct device, let's create some functions to lock and
    unlock a device so that no out-of-core code needs to be changed in the
    future.
    
    This patch creates the device_lock/unlock/trylock() functions, and
    converts all in-tree users to them.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Jean Delvare <khali@linux-fr.org>
    Cc: Dave Young <hidave.darkstar@gmail.com>
    Cc: Ming Lei <tom.leiming@gmail.com>
    Cc: Jiri Kosina <jkosina@suse.cz>
    Cc: Phil Carmody <ext-phil.2.carmody@nokia.com>
    Cc: Arjan van de Ven <arjan@linux.intel.com>
    Cc: Cornelia Huck <cornelia.huck@de.ibm.com>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: Len Brown <len.brown@intel.com>
    Cc: Magnus Damm <damm@igel.co.jp>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Randy Dunlap <randy.dunlap@oracle.com>
    Cc: Stefan Richter <stefanr@s5r6.in-berlin.de>
    Cc: David Brownell <dbrownell@users.sourceforge.net>
    Cc: Vegard Nossum <vegard.nossum@gmail.com>
    Cc: Jesse Barnes <jbarnes@virtuousgeek.org>
    Cc: Alex Chiang <achiang@hp.com>
    Cc: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Andrew Patterson <andrew.patterson@hp.com>
    Cc: Yu Zhao <yu.zhao@intel.com>
    Cc: Dominik Brodowski <linux@dominikbrodowski.net>
    Cc: Samuel Ortiz <sameo@linux.intel.com>
    Cc: Wolfram Sang <w.sang@pengutronix.de>
    Cc: CHENG Renquan <rqcheng@smu.edu.sg>
    Cc: Oliver Neukum <oliver@neukum.org>
    Cc: Frans Pop <elendil@planet.nl>
    Cc: David Vrabel <david.vrabel@csr.com>
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Cc: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index 712250f5874a..26301cb25e7f 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -288,9 +288,9 @@ void pci_walk_bus(struct pci_bus *top, int (*cb)(struct pci_dev *, void *),
 			next = dev->bus_list.next;
 
 		/* Run device routines with the device locked */
-		down(&dev->dev.sem);
+		device_lock(&dev->dev);
 		retval = cb(dev, userdata);
-		up(&dev->dev.sem);
+		device_unlock(&dev->dev);
 		if (retval)
 			break;
 	}

commit 2fe2abf896c1e7a0ee65faaf3ef0ce654848abbd
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Feb 23 10:24:36 2010 -0700

    PCI: augment bus resource table with a list
    
    Previously we used a table of size PCI_BUS_NUM_RESOURCES (16) for resources
    forwarded to a bus by its upstream bridge.  We've increased this size
    several times when the table overflowed.
    
    But there's no good limit on the number of resources because host bridges
    and subtractive decode bridges can forward any number of ranges to their
    secondary buses.
    
    This patch reduces the table to only PCI_BRIDGE_RESOURCE_NUM (4) entries,
    which corresponds to the number of windows a PCI-to-PCI (3) or CardBus (4)
    bridge can positively decode.  Any additional resources, e.g., PCI host
    bridge windows or subtractively-decoded regions, are kept in a list.
    
    I'd prefer a single list rather than this split table/list approach, but
    that requires simultaneous changes to every architecture.  This approach
    only requires immediate changes where we set up (a) host bridges with more
    than four windows and (b) subtractive-decode P2P bridges, and we can
    incrementally change other architectures to use the list.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index e75d219fd107..712250f5874a 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -17,6 +17,52 @@
 
 #include "pci.h"
 
+void pci_bus_add_resource(struct pci_bus *bus, struct resource *res,
+			  unsigned int flags)
+{
+	struct pci_bus_resource *bus_res;
+
+	bus_res = kzalloc(sizeof(struct pci_bus_resource), GFP_KERNEL);
+	if (!bus_res) {
+		dev_err(&bus->dev, "can't add %pR resource\n", res);
+		return;
+	}
+
+	bus_res->res = res;
+	bus_res->flags = flags;
+	list_add_tail(&bus_res->list, &bus->resources);
+}
+
+struct resource *pci_bus_resource_n(const struct pci_bus *bus, int n)
+{
+	struct pci_bus_resource *bus_res;
+
+	if (n < PCI_BRIDGE_RESOURCE_NUM)
+		return bus->resource[n];
+
+	n -= PCI_BRIDGE_RESOURCE_NUM;
+	list_for_each_entry(bus_res, &bus->resources, list) {
+		if (n-- == 0)
+			return bus_res->res;
+	}
+	return NULL;
+}
+EXPORT_SYMBOL_GPL(pci_bus_resource_n);
+
+void pci_bus_remove_resources(struct pci_bus *bus)
+{
+	struct pci_bus_resource *bus_res, *tmp;
+	int i;
+
+	for (i = 0; i < PCI_BRIDGE_RESOURCE_NUM; i++)
+		bus->resource[i] = 0;
+
+	list_for_each_entry_safe(bus_res, tmp, &bus->resources, list) {
+		list_del(&bus_res->list);
+		kfree(bus_res);
+	}
+}
+
 /**
  * pci_bus_alloc_resource - allocate a resource from a parent bus
  * @bus: PCI bus

commit 89a74ecccd1f78e51faf6287e5c0e93a92ac096e
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Feb 23 10:24:31 2010 -0700

    PCI: add pci_bus_for_each_resource(), remove direct bus->resource[] refs
    
    No functional change; this converts loops that iterate from 0 to
    PCI_BUS_NUM_RESOURCES through pci_bus resource[] table to use the
    pci_bus_for_each_resource() iterator instead.
    
    This doesn't change the way resources are stored; it merely removes
    dependencies on the fact that they're in a table.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index a26135bb0ffd..e75d219fd107 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -43,6 +43,7 @@ pci_bus_alloc_resource(struct pci_bus *bus, struct resource *res,
 		void *alignf_data)
 {
 	int i, ret = -ENOMEM;
+	struct resource *r;
 	resource_size_t max = -1;
 
 	type_mask |= IORESOURCE_IO | IORESOURCE_MEM;
@@ -51,8 +52,7 @@ pci_bus_alloc_resource(struct pci_bus *bus, struct resource *res,
 	if (!(res->flags & IORESOURCE_MEM_64))
 		max = PCIBIOS_MAX_MEM_32;
 
-	for (i = 0; i < PCI_BUS_NUM_RESOURCES; i++) {
-		struct resource *r = bus->resource[i];
+	pci_bus_for_each_resource(bus, r, i) {
 		if (!r)
 			continue;
 

commit 3b7a17fcdae532d29dffab9d564a28be08960988
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Fri Jan 1 17:40:50 2010 +0100

    resource/PCI: mark struct resource as const
    
    Now that we return the new resource start position, there is no
    need to update "struct resource" inside the align function.
    Therefore, mark the struct resource as const.
    
    Cc: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Cc: Yinghai Lu <yhlu.kernel@gmail.com>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index d29d69a37940..a26135bb0ffd 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -37,7 +37,7 @@ pci_bus_alloc_resource(struct pci_bus *bus, struct resource *res,
 		resource_size_t size, resource_size_t align,
 		resource_size_t min, unsigned int type_mask,
 		resource_size_t (*alignf)(void *,
-					  struct resource *,
+					  const struct resource *,
 					  resource_size_t,
 					  resource_size_t),
 		void *alignf_data)

commit b26b2d494b659f988b4d75eb394dfa0ddac415c9
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Fri Jan 1 17:40:49 2010 +0100

    resource/PCI: align functions now return start of resource
    
    As suggested by Linus, align functions should return the start
    of a resource, not void. An update of "res->start" is no longer
    necessary.
    
    Cc: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Cc: Yinghai Lu <yhlu.kernel@gmail.com>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index cef28a79103f..d29d69a37940 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -36,8 +36,10 @@ int
 pci_bus_alloc_resource(struct pci_bus *bus, struct resource *res,
 		resource_size_t size, resource_size_t align,
 		resource_size_t min, unsigned int type_mask,
-		void (*alignf)(void *, struct resource *, resource_size_t,
-				resource_size_t),
+		resource_size_t (*alignf)(void *,
+					  struct resource *,
+					  resource_size_t,
+					  resource_size_t),
 		void *alignf_data)
 {
 	int i, ret = -ENOMEM;

commit 70298c6e6c1ba68346336b4ea54bd5c0abbf73c8
Author: Zhang, Yanmin <yanmin_zhang@linux.intel.com>
Date:   Tue Jun 16 13:34:38 2009 +0800

    PCI AER: support Multiple Error Received and no error source id
    
    Based on PCI Express AER specs, a root port might receive multiple
    TLP errors while it could only save a correctable error source id
    and an uncorrectable error source id at the same time. In addition,
    some root port hardware might be unable to provide a correct source
    id, i.e., the source id, or the bus id part of the source id provided
    by root port might be equal to 0.
    
    The patchset implements the support in kernel by searching the device
    tree under the root port.
    
    Patch 1 changes parameter cb of function pci_walk_bus to return a value.
    When cb return non-zero, pci_walk_bus stops more searching on the
    device tree.
    
    Reviewed-by: Andrew Patterson <andrew.patterson@hp.com>
    Signed-off-by: Zhang Yanmin <yanmin_zhang@linux.intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index 40af27f31043..cef28a79103f 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -206,13 +206,18 @@ void pci_enable_bridges(struct pci_bus *bus)
  *  Walk the given bus, including any bridged devices
  *  on buses under this bus.  Call the provided callback
  *  on each device found.
+ *
+ *  We check the return of @cb each time. If it returns anything
+ *  other than 0, we break out.
+ *
  */
-void pci_walk_bus(struct pci_bus *top, void (*cb)(struct pci_dev *, void *),
+void pci_walk_bus(struct pci_bus *top, int (*cb)(struct pci_dev *, void *),
 		  void *userdata)
 {
 	struct pci_dev *dev;
 	struct pci_bus *bus;
 	struct list_head *next;
+	int retval;
 
 	bus = top;
 	down_read(&pci_bus_sem);
@@ -236,8 +241,10 @@ void pci_walk_bus(struct pci_bus *top, void (*cb)(struct pci_dev *, void *),
 
 		/* Run device routines with the device locked */
 		down(&dev->dev.sem);
-		cb(dev, userdata);
+		retval = cb(dev, userdata);
 		up(&dev->dev.sem);
+		if (retval)
+			break;
 	}
 	up_read(&pci_bus_sem);
 }

commit 1f82de10d6b1d845155363c895c552e61b36b51a
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Thu Apr 23 20:48:32 2009 -0700

    PCI/x86: don't assume prefetchable ranges are 64bit
    
    We should not assign 64bit ranges to PCI devices that only take 32bit
    prefetchable addresses.
    
    Try to set IORESOURCE_MEM_64 in 64bit resource of pci_device/pci_bridge
    and make the bus resource only have that bit set when all devices under
    it support 64bit prefetchable memory.  Use that flag to allocate
    resources from that range.
    
    Reported-by: Yannick <yannick.roehlly@free.fr>
    Reviewed-by: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index 97a8194063b5..40af27f31043 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -41,9 +41,14 @@ pci_bus_alloc_resource(struct pci_bus *bus, struct resource *res,
 		void *alignf_data)
 {
 	int i, ret = -ENOMEM;
+	resource_size_t max = -1;
 
 	type_mask |= IORESOURCE_IO | IORESOURCE_MEM;
 
+	/* don't allocate too high if the pref mem doesn't support 64bit*/
+	if (!(res->flags & IORESOURCE_MEM_64))
+		max = PCIBIOS_MAX_MEM_32;
+
 	for (i = 0; i < PCI_BUS_NUM_RESOURCES; i++) {
 		struct resource *r = bus->resource[i];
 		if (!r)
@@ -62,7 +67,7 @@ pci_bus_alloc_resource(struct pci_bus *bus, struct resource *res,
 		/* Ok, try it out.. */
 		ret = allocate_resource(r, res, size,
 					r->start ? : min,
-					-1, align,
+					max, align,
 					alignf, alignf_data);
 		if (ret == 0)
 			break;

commit 296ccb086dfb89b5b8d73ef08c795ffdff12a597
Author: Yuji Shimada <shimada-yxb@necst.nec.co.jp>
Date:   Fri Apr 3 16:41:46 2009 +0900

    PCI: Setup disabled bridges even if buses are added
    
    This patch sets up disabled bridges even if buses have already been
    added.
    
    pci_assign_unassigned_resources is called after buses are added.
    pci_assign_unassigned_resources calls pci_bus_assign_resources.
    pci_bus_assign_resources calls pci_setup_bridge to configure BARs of
    bridges.
    
    Currently pci_setup_bridge returns immediately if the bus have already
    been added. So pci_assign_unassigned_resources can't configure BARs of
    bridges that were added in a disabled state; this patch fixes the issue.
    
    On logical hot-add, we need to prevent the kernel from re-initializing
    bridges that have already been initialized. To achieve this,
    pci_setup_bridge returns immediately if the bridge have already been
    enabled.
    
    We don't need to check whether the specified bus is a root bus or not.
    pci_setup_bridge is not called on a root bus, because a root bus does
    not have a bridge.
    
    The patch adds a new helper function, pci_is_enabled. I made the
    function name similar to pci_is_managed. The codes which use
    enable_cnt directly are changed to use pci_is_enabled.
    
    Acked-by: Alex Chiang <achiang@hp.com>
    Signed-off-by: Yuji Shimada <shimada-yxb@necst.nec.co.jp>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index 68f91a252595..97a8194063b5 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -184,7 +184,7 @@ void pci_enable_bridges(struct pci_bus *bus)
 
 	list_for_each_entry(dev, &bus->devices, bus_list) {
 		if (dev->subordinate) {
-			if (atomic_read(&dev->enable_cnt) == 0) {
+			if (!pci_is_enabled(dev)) {
 				retval = pci_enable_device(dev);
 				pci_set_master(dev);
 			}

commit 9dd90cafa7a712d283e2e0c625b022e19f746762
Author: Alex Chiang <achiang@hp.com>
Date:   Fri Mar 20 14:56:20 2009 -0600

    PCI: do not enable bridges more than once
    
    In preparation for PCI core hotplug, we need to ensure that we do
    not attempt to re-enable bridges that have already been enabled.
    
    Reported-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Alex Chiang <achiang@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index 118c77778d29..68f91a252595 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -184,8 +184,10 @@ void pci_enable_bridges(struct pci_bus *bus)
 
 	list_for_each_entry(dev, &bus->devices, bus_list) {
 		if (dev->subordinate) {
-			retval = pci_enable_device(dev);
-			pci_set_master(dev);
+			if (atomic_read(&dev->enable_cnt) == 0) {
+				retval = pci_enable_device(dev);
+				pci_set_master(dev);
+			}
 			pci_enable_bridges(dev->subordinate);
 		}
 	}

commit c48f1670f42b71f39f4a3bfba01ffb691cc9206c
Author: akpm@linux-foundation.org <akpm@linux-foundation.org>
Date:   Tue Feb 3 15:45:26 2009 -0800

    PCI: constify pci_bus_add_devices()
    
    drivers/pci/hotplug/fakephp.c:283: warning: passing argument 1 of 'pci_bus_add_devices' discards qualifiers from pointer target type
    
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index 52b54f053be0..118c77778d29 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -133,7 +133,7 @@ int pci_bus_add_child(struct pci_bus *bus)
  *
  * Call hotplug for each new devices.
  */
-void pci_bus_add_devices(struct pci_bus *bus)
+void pci_bus_add_devices(const struct pci_bus *bus)
 {
 	struct pci_dev *dev;
 	struct pci_bus *child;

commit 876e501ab25dcd683574a5d3d56d8fe450083ed6
Author: Yu Zhao <yu.zhao@intel.com>
Date:   Sat Nov 22 02:42:35 2008 +0800

    PCI: factor pci_bus_add_child() from pci_bus_add_devices()
    
    This patch splits a new function, pci_bus_add_child(), from
    pci_bus_add_devices(). The new function can be used to register PCI
    buses to the device core.
    
    Signed-off-by: Yu Zhao <yu.zhao@intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index 1b6de1b565aa..52b54f053be0 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -90,6 +90,37 @@ int pci_bus_add_device(struct pci_dev *dev)
 	return 0;
 }
 
+/**
+ * pci_bus_add_child - add a child bus
+ * @bus: bus to add
+ *
+ * This adds sysfs entries for a single bus
+ */
+int pci_bus_add_child(struct pci_bus *bus)
+{
+	int retval;
+
+	if (bus->bridge)
+		bus->dev.parent = bus->bridge;
+
+	retval = device_register(&bus->dev);
+	if (retval)
+		return retval;
+
+	bus->is_added = 1;
+
+	retval = device_create_file(&bus->dev, &dev_attr_cpuaffinity);
+	if (retval)
+		return retval;
+
+	retval = device_create_file(&bus->dev, &dev_attr_cpulistaffinity);
+
+	/* Create legacy_io and legacy_mem files for this bus */
+	pci_create_legacy_files(bus);
+
+	return retval;
+}
+
 /**
  * pci_bus_add_devices - insert newly discovered PCI devices
  * @bus: bus to check for new devices
@@ -140,30 +171,9 @@ void pci_bus_add_devices(struct pci_bus *bus)
 		 */
 		if (child->is_added)
 			continue;
-		child->dev.parent = child->bridge;
-		retval = device_register(&child->dev);
+		retval = pci_bus_add_child(child);
 		if (retval)
-			dev_err(&dev->dev, "Error registering pci_bus,"
-				" continuing...\n");
-		else {
-			child->is_added = 1;
-			retval = device_create_file(&child->dev,
-						&dev_attr_cpuaffinity);
-			if (retval)
-				dev_err(&dev->dev, "Error creating cpuaffinity"
-					" file, continuing...\n");
-
-			retval = device_create_file(&child->dev,
-						&dev_attr_cpulistaffinity);
-			if (retval)
-				dev_err(&dev->dev,
-					"Error creating cpulistaffinity"
-					" file, continuing...\n");
-
-			/* Create legacy_io and legacy_mem files for this bus */
-			pci_create_legacy_files(child_bus);
-
-		}
+			dev_err(&dev->dev, "Error adding bus, continuing\n");
 	}
 }
 

commit 3fa16fdb48e0d83c2acf46e357548c89891df58b
Author: Yu Zhao <yu.zhao@intel.com>
Date:   Sat Nov 22 02:41:45 2008 +0800

    PCI: cleanup pci_bus_add_devices()
    
    Cleanup pci_bus_add_devices() by negating the conditional and
    continuing, rather than having a single conditional take up the whole
    body.
    
    Signed-off-by: Yu Zhao <yu.zhao@intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index 3e1c135b174a..1b6de1b565aa 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -71,7 +71,7 @@ pci_bus_alloc_resource(struct pci_bus *bus, struct resource *res,
 }
 
 /**
- * add a single device
+ * pci_bus_add_device - add a single device
  * @dev: device to add
  *
  * This adds a single pci device to the global
@@ -105,7 +105,7 @@ int pci_bus_add_device(struct pci_dev *dev)
 void pci_bus_add_devices(struct pci_bus *bus)
 {
 	struct pci_dev *dev;
-	struct pci_bus *child_bus;
+	struct pci_bus *child;
 	int retval;
 
 	list_for_each_entry(dev, &bus->devices, bus_list) {
@@ -120,39 +120,40 @@ void pci_bus_add_devices(struct pci_bus *bus)
 	list_for_each_entry(dev, &bus->devices, bus_list) {
 		BUG_ON(!dev->is_added);
 
+		child = dev->subordinate;
 		/*
 		 * If there is an unattached subordinate bus, attach
 		 * it and then scan for unattached PCI devices.
 		 */
-		if (dev->subordinate) {
-		       if (list_empty(&dev->subordinate->node)) {
-			       down_write(&pci_bus_sem);
-			       list_add_tail(&dev->subordinate->node,
-					       &dev->bus->children);
-			       up_write(&pci_bus_sem);
-			}
-			pci_bus_add_devices(dev->subordinate);
-
-			/* register the bus with sysfs as the parent is now
-			 * properly registered. */
-			child_bus = dev->subordinate;
-			if (child_bus->is_added)
-				continue;
-			child_bus->dev.parent = child_bus->bridge;
-			retval = device_register(&child_bus->dev);
-			if (retval)
-				dev_err(&dev->dev, "Error registering pci_bus,"
-					" continuing...\n");
-			else {
-				child_bus->is_added = 1;
-				retval = device_create_file(&child_bus->dev,
-							&dev_attr_cpuaffinity);
-			}
+		if (!child)
+			continue;
+		if (list_empty(&child->node)) {
+			down_write(&pci_bus_sem);
+			list_add_tail(&child->node, &dev->bus->children);
+			up_write(&pci_bus_sem);
+		}
+		pci_bus_add_devices(child);
+
+		/*
+		 * register the bus with sysfs as the parent is now
+		 * properly registered.
+		 */
+		if (child->is_added)
+			continue;
+		child->dev.parent = child->bridge;
+		retval = device_register(&child->dev);
+		if (retval)
+			dev_err(&dev->dev, "Error registering pci_bus,"
+				" continuing...\n");
+		else {
+			child->is_added = 1;
+			retval = device_create_file(&child->dev,
+						&dev_attr_cpuaffinity);
 			if (retval)
 				dev_err(&dev->dev, "Error creating cpuaffinity"
 					" file, continuing...\n");
 
-			retval = device_create_file(&child_bus->dev,
+			retval = device_create_file(&child->dev,
 						&dev_attr_cpulistaffinity);
 			if (retval)
 				dev_err(&dev->dev,

commit d3a54014e2a94bd37b7dee5e76e03f7bc4fab49a
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Wed Nov 12 14:38:53 2008 +1100

    PCI: Add legacy_io/mem to all busses
    
    Currently, only PHBs get the legacy_* files, which makes it tricky for
    userland to get access to the legacy space.  This commit exposes them in
    every bus, since even child buses may forward legacy cycles if
    configured properly.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index 999cc4088b59..3e1c135b174a 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -158,6 +158,10 @@ void pci_bus_add_devices(struct pci_bus *bus)
 				dev_err(&dev->dev,
 					"Error creating cpulistaffinity"
 					" file, continuing...\n");
+
+			/* Create legacy_io and legacy_mem files for this bus */
+			pci_create_legacy_files(child_bus);
+
 		}
 	}
 }

commit 93ff68a55aa92180a765d6c51c3303f6200167a6
Author: Mike Travis <travis@sgi.com>
Date:   Sat Sep 6 05:46:42 2008 -0700

    PCI: make CPU list affinity visible
    
    Stephen Hemminger wrote:
    > Looks like Mike created cpulistaffinty in sysfs but never completed
    > the job.
    
    This patch hooks things up correctly, taking care to remove the new file
    when the bus is destroyed.
    
    Signed-off-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: Mike Travis <travis@sgi.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index 529d9d7727b0..999cc4088b59 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -151,6 +151,13 @@ void pci_bus_add_devices(struct pci_bus *bus)
 			if (retval)
 				dev_err(&dev->dev, "Error creating cpuaffinity"
 					" file, continuing...\n");
+
+			retval = device_create_file(&child_bus->dev,
+						&dev_attr_cpulistaffinity);
+			if (retval)
+				dev_err(&dev->dev,
+					"Error creating cpulistaffinity"
+					" file, continuing...\n");
 		}
 	}
 }

commit 5ff580c10ec06fd296bd23d4570c1a95194094a0
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Feb 14 14:56:56 2008 -0800

    PCI: remove global list of PCI devices
    
    This patch finally removes the global list of PCI devices.  We are
    relying entirely on the list held in the driver core now, and do not
    need a separate "shadow" list as no one uses it.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index e1c079aa0e82..529d9d7727b0 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -85,10 +85,6 @@ int pci_bus_add_device(struct pci_dev *dev)
 		return retval;
 
 	dev->is_added = 1;
-	down_write(&pci_bus_sem);
-	list_add_tail(&dev->global_list, &pci_devices);
-	up_write(&pci_bus_sem);
-
 	pci_proc_attach_device(dev);
 	pci_create_sysfs_dev_files(dev);
 	return 0;

commit 8a1bc9013a03d41a0e36ee413bb6f97281b30bd1
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Feb 14 14:56:56 2008 -0800

    PCI: add is_added flag to struct pci_dev
    
    This lets us check if the device is really added to the driver core or
    not, which is what we need when walking some of the bus lists.  The flag
    is there in anticipation of getting rid of the other PCI device list,
    which is what we used to check in this situation.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index d708358326e5..e1c079aa0e82 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -84,6 +84,7 @@ int pci_bus_add_device(struct pci_dev *dev)
 	if (retval)
 		return retval;
 
+	dev->is_added = 1;
 	down_write(&pci_bus_sem);
 	list_add_tail(&dev->global_list, &pci_devices);
 	up_write(&pci_bus_sem);
@@ -112,11 +113,8 @@ void pci_bus_add_devices(struct pci_bus *bus)
 	int retval;
 
 	list_for_each_entry(dev, &bus->devices, bus_list) {
-		/*
-		 * Skip already-present devices (which are on the
-		 * global device list.)
-		 */
-		if (!list_empty(&dev->global_list))
+		/* Skip already-added devices */
+		if (dev->is_added)
 			continue;
 		retval = pci_bus_add_device(dev);
 		if (retval)
@@ -124,8 +122,7 @@ void pci_bus_add_devices(struct pci_bus *bus)
 	}
 
 	list_for_each_entry(dev, &bus->devices, bus_list) {
-
-		BUG_ON(list_empty(&dev->global_list));
+		BUG_ON(!dev->is_added);
 
 		/*
 		 * If there is an unattached subordinate bus, attach

commit cc74d96f47b0d916840f92092595e3be9731e047
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed Mar 12 21:48:03 2008 -0700

    PCI: fix issue with busses registering multiple times in sysfs
    
    PCI busses can be registered multiple times, so we need to detect if we
    have registered our bus structure in sysfs already.  If so, don't do it
    again.
    
    Thanks to Guennadi Liakhovetski <g.liakhovetski@gmx.de> for reporting
    the problem, and to Linus for poking me to get me to believe that it was
    a real problem.
    
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index 6a9403d79e0c..d708358326e5 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -143,14 +143,18 @@ void pci_bus_add_devices(struct pci_bus *bus)
 			/* register the bus with sysfs as the parent is now
 			 * properly registered. */
 			child_bus = dev->subordinate;
+			if (child_bus->is_added)
+				continue;
 			child_bus->dev.parent = child_bus->bridge;
 			retval = device_register(&child_bus->dev);
 			if (retval)
 				dev_err(&dev->dev, "Error registering pci_bus,"
 					" continuing...\n");
-			else
+			else {
+				child_bus->is_added = 1;
 				retval = device_create_file(&child_bus->dev,
 							&dev_attr_cpuaffinity);
+			}
 			if (retval)
 				dev_err(&dev->dev, "Error creating cpuaffinity"
 					" file, continuing...\n");

commit 4725e7bdb831b9d4bd4ba0b0909398ebcf0c2df9
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Mar 3 14:47:13 2008 -0800

    PCI: fix up error messages for pci_bus registering
    
    Due to the class_device cleanup of pci_bus, the error messages when
    things go wrong are incorrect.  So fix this up to properly report what
    is really happening, if things go wrong.
    
    Thanks to Kay for pointing out the issue.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index ef5a6a245f5f..6a9403d79e0c 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -145,13 +145,15 @@ void pci_bus_add_devices(struct pci_bus *bus)
 			child_bus = dev->subordinate;
 			child_bus->dev.parent = child_bus->bridge;
 			retval = device_register(&child_bus->dev);
-			if (!retval)
+			if (retval)
+				dev_err(&dev->dev, "Error registering pci_bus,"
+					" continuing...\n");
+			else
 				retval = device_create_file(&child_bus->dev,
 							&dev_attr_cpuaffinity);
 			if (retval)
-				dev_err(&dev->dev, "Error registering pci_bus"
-					" device bridge symlink,"
-					" continuing...\n");
+				dev_err(&dev->dev, "Error creating cpuaffinity"
+					" file, continuing...\n");
 		}
 	}
 }

commit fd7d1ced29e5beb88c9068801da7a362606d8273
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue May 22 22:47:54 2007 -0400

    PCI: make pci_bus a struct device
    
    This moves the pci_bus class device to be a real struct device and at
    the same time, place it in the device tree in the correct location.
    
    Note, the old "bridge" symlink is now gone, but this was a non-standard
    link and no userspace program used it.  If you need to determine the
    device that the bus is on, follow the standard device symlink, or walk
    up the device tree.
    
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index 863340a7b77f..ef5a6a245f5f 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -108,6 +108,7 @@ int pci_bus_add_device(struct pci_dev *dev)
 void pci_bus_add_devices(struct pci_bus *bus)
 {
 	struct pci_dev *dev;
+	struct pci_bus *child_bus;
 	int retval;
 
 	list_for_each_entry(dev, &bus->devices, bus_list) {
@@ -138,11 +139,19 @@ void pci_bus_add_devices(struct pci_bus *bus)
 			       up_write(&pci_bus_sem);
 			}
 			pci_bus_add_devices(dev->subordinate);
-			retval = sysfs_create_link(&dev->subordinate->class_dev.kobj,
-						   &dev->dev.kobj, "bridge");
+
+			/* register the bus with sysfs as the parent is now
+			 * properly registered. */
+			child_bus = dev->subordinate;
+			child_bus->dev.parent = child_bus->bridge;
+			retval = device_register(&child_bus->dev);
+			if (!retval)
+				retval = device_create_file(&child_bus->dev,
+							&dev_attr_cpuaffinity);
 			if (retval)
-				dev_err(&dev->dev, "Error creating sysfs "
-					"bridge symlink, continuing...\n");
+				dev_err(&dev->dev, "Error registering pci_bus"
+					" device bridge symlink,"
+					" continuing...\n");
 		}
 	}
 }

commit eb003ec26556057e5f27d4b989bbb432d0bdc0f4
Author: Adrian Bunk <bunk@kernel.org>
Date:   Sat Oct 27 03:06:33 2007 +0200

    PCI: drivers/pci/: remove unused exports
    
    This patch removes the following unused exports:
    - remove the following unused EXPORT_SYMBOL's:
     - pci-acpi.c: pci_osc_support_set
     - proc.c: pci_proc_detach_bus
    - remove the following unused EXPORT_SYMBOL_GPL's:
      - bus.c: pci_walk_bus
      - probe.c: pci_create_bus
      - setup-res.c: pci_claim_resource
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index 9e5ea074ad20..863340a7b77f 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -204,7 +204,6 @@ void pci_walk_bus(struct pci_bus *top, void (*cb)(struct pci_dev *, void *),
 	}
 	up_read(&pci_bus_sem);
 }
-EXPORT_SYMBOL_GPL(pci_walk_bus);
 
 EXPORT_SYMBOL(pci_bus_alloc_resource);
 EXPORT_SYMBOL_GPL(pci_bus_add_device);

commit 96bde06a2df1b363206d3cdef53134b84ff37813
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Mon Mar 26 21:53:30 2007 -0800

    pci: do not mark exported functions as __devinit
    
    Functions marked __devinit will be removed after kernel init.  But being
    exported they are potentially called by a module much later.
    
    So the safer choice seems to be to keep the function even in the non
    CONFIG_HOTPLUG case.
    
    This silence the follwoing section mismatch warnings:
    WARNING: drivers/built-in.o - Section mismatch: reference to .init.text:pci_bus_add_device from __ksymtab_gpl between '__ksymtab_pci_bus_add_device' (at offset 0x20) and '__ksymtab_pci_walk_bus'
    WARNING: drivers/built-in.o - Section mismatch: reference to .init.text:pci_create_bus from __ksymtab_gpl between '__ksymtab_pci_create_bus' (at offset 0x40) and '__ksymtab_pci_stop_bus_device'
    WARNING: drivers/built-in.o - Section mismatch: reference to .init.text:pci_bus_max_busnr from __ksymtab_gpl between '__ksymtab_pci_bus_max_busnr' (at offset 0xc0) and '__ksymtab_pci_assign_resource_fixed'
    WARNING: drivers/built-in.o - Section mismatch: reference to .init.text:pci_claim_resource from __ksymtab_gpl between '__ksymtab_pci_claim_resource' (at offset 0xe0) and '__ksymtab_pcie_port_bus_type'
    WARNING: drivers/built-in.o - Section mismatch: reference to .init.text:pci_bus_add_devices from __ksymtab between '__ksymtab_pci_bus_add_devices' (at offset 0x70) and '__ksymtab_pci_bus_alloc_resource'
    WARNING: drivers/built-in.o - Section mismatch: reference to .init.text:pci_scan_bus_parented from __ksymtab between '__ksymtab_pci_scan_bus_parented' (at offset 0x90) and '__ksymtab_pci_root_buses'
    WARNING: drivers/built-in.o - Section mismatch: reference to .init.text:pci_bus_assign_resources from __ksymtab between '__ksymtab_pci_bus_assign_resources' (at offset 0x4d0) and '__ksymtab_pci_bus_size_bridges'
    WARNING: drivers/built-in.o - Section mismatch: reference to .init.text:pci_bus_size_bridges from __ksymtab between '__ksymtab_pci_bus_size_bridges' (at offset 0x4e0) and '__ksymtab_pci_setup_cardbus'
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index aadaa3c8096b..9e5ea074ad20 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -77,7 +77,7 @@ pci_bus_alloc_resource(struct pci_bus *bus, struct resource *res,
  * This adds a single pci device to the global
  * device list and adds sysfs and procfs entries
  */
-int __devinit pci_bus_add_device(struct pci_dev *dev)
+int pci_bus_add_device(struct pci_dev *dev)
 {
 	int retval;
 	retval = device_add(&dev->dev);
@@ -105,7 +105,7 @@ int __devinit pci_bus_add_device(struct pci_dev *dev)
  *
  * Call hotplug for each new devices.
  */
-void __devinit pci_bus_add_devices(struct pci_bus *bus)
+void pci_bus_add_devices(struct pci_bus *bus)
 {
 	struct pci_dev *dev;
 	int retval;

commit b19441af185559118e8247382ea4f2f76ebffc6d
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Aug 28 11:43:25 2006 -0700

    PCI: fix __must_check warnings
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index 5f7db9d2436e..aadaa3c8096b 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -77,9 +77,12 @@ pci_bus_alloc_resource(struct pci_bus *bus, struct resource *res,
  * This adds a single pci device to the global
  * device list and adds sysfs and procfs entries
  */
-void __devinit pci_bus_add_device(struct pci_dev *dev)
+int __devinit pci_bus_add_device(struct pci_dev *dev)
 {
-	device_add(&dev->dev);
+	int retval;
+	retval = device_add(&dev->dev);
+	if (retval)
+		return retval;
 
 	down_write(&pci_bus_sem);
 	list_add_tail(&dev->global_list, &pci_devices);
@@ -87,6 +90,7 @@ void __devinit pci_bus_add_device(struct pci_dev *dev)
 
 	pci_proc_attach_device(dev);
 	pci_create_sysfs_dev_files(dev);
+	return 0;
 }
 
 /**
@@ -104,6 +108,7 @@ void __devinit pci_bus_add_device(struct pci_dev *dev)
 void __devinit pci_bus_add_devices(struct pci_bus *bus)
 {
 	struct pci_dev *dev;
+	int retval;
 
 	list_for_each_entry(dev, &bus->devices, bus_list) {
 		/*
@@ -112,7 +117,9 @@ void __devinit pci_bus_add_devices(struct pci_bus *bus)
 		 */
 		if (!list_empty(&dev->global_list))
 			continue;
-		pci_bus_add_device(dev);
+		retval = pci_bus_add_device(dev);
+		if (retval)
+			dev_err(&dev->dev, "Error adding device, continuing\n");
 	}
 
 	list_for_each_entry(dev, &bus->devices, bus_list) {
@@ -129,10 +136,13 @@ void __devinit pci_bus_add_devices(struct pci_bus *bus)
 			       list_add_tail(&dev->subordinate->node,
 					       &dev->bus->children);
 			       up_write(&pci_bus_sem);
-		       }
+			}
 			pci_bus_add_devices(dev->subordinate);
-
-			sysfs_create_link(&dev->subordinate->class_dev.kobj, &dev->dev.kobj, "bridge");
+			retval = sysfs_create_link(&dev->subordinate->class_dev.kobj,
+						   &dev->dev.kobj, "bridge");
+			if (retval)
+				dev_err(&dev->dev, "Error creating sysfs "
+					"bridge symlink, continuing...\n");
 		}
 	}
 }

commit e31dd6e4520439ceae4753f32dd2da2c345e929a
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Jun 12 17:06:02 2006 -0700

    [PATCH] 64bit resource: change pci core and arch code to use resource_size_t
    
    Based on a patch series originally from Vivek Goyal <vgoyal@in.ibm.com>
    
    Cc: Vivek Goyal <vgoyal@in.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index 723092682023..5f7db9d2436e 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -34,11 +34,11 @@
  */
 int
 pci_bus_alloc_resource(struct pci_bus *bus, struct resource *res,
-	unsigned long size, unsigned long align, unsigned long min,
-	unsigned int type_mask,
-	void (*alignf)(void *, struct resource *,
-			unsigned long, unsigned long),
-	void *alignf_data)
+		resource_size_t size, resource_size_t align,
+		resource_size_t min, unsigned int type_mask,
+		void (*alignf)(void *, struct resource *, resource_size_t,
+				resource_size_t),
+		void *alignf_data)
 {
 	int i, ret = -ENOMEM;
 

commit d71374dafbba7ec3f67371d3b7e9f6310a588808
Author: Zhang Yanmin <yanmin.zhang@intel.com>
Date:   Fri Jun 2 12:35:43 2006 +0800

    [PATCH] PCI: fix race with pci_walk_bus and pci_destroy_dev
    
    pci_walk_bus has a race with pci_destroy_dev. When cb is called
    in pci_walk_bus, pci_destroy_dev might unlink the dev pointed by next.
    Later on in the next loop, pointer next becomes NULL and cause
    kernel panic.
    
    Below patch against 2.6.17-rc4 fixes it by changing pci_bus_lock (spin_lock)
    to pci_bus_sem (rw_semaphore).
    
    Signed-off-by: Zhang Yanmin <yanmin.zhang@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index eed67d9e73bc..723092682023 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -81,9 +81,9 @@ void __devinit pci_bus_add_device(struct pci_dev *dev)
 {
 	device_add(&dev->dev);
 
-	spin_lock(&pci_bus_lock);
+	down_write(&pci_bus_sem);
 	list_add_tail(&dev->global_list, &pci_devices);
-	spin_unlock(&pci_bus_lock);
+	up_write(&pci_bus_sem);
 
 	pci_proc_attach_device(dev);
 	pci_create_sysfs_dev_files(dev);
@@ -125,10 +125,10 @@ void __devinit pci_bus_add_devices(struct pci_bus *bus)
 		 */
 		if (dev->subordinate) {
 		       if (list_empty(&dev->subordinate->node)) {
-			       spin_lock(&pci_bus_lock);
+			       down_write(&pci_bus_sem);
 			       list_add_tail(&dev->subordinate->node,
 					       &dev->bus->children);
-			       spin_unlock(&pci_bus_lock);
+			       up_write(&pci_bus_sem);
 		       }
 			pci_bus_add_devices(dev->subordinate);
 
@@ -168,7 +168,7 @@ void pci_walk_bus(struct pci_bus *top, void (*cb)(struct pci_dev *, void *),
 	struct list_head *next;
 
 	bus = top;
-	spin_lock(&pci_bus_lock);
+	down_read(&pci_bus_sem);
 	next = top->devices.next;
 	for (;;) {
 		if (next == &bus->devices) {
@@ -180,22 +180,19 @@ void pci_walk_bus(struct pci_bus *top, void (*cb)(struct pci_dev *, void *),
 			continue;
 		}
 		dev = list_entry(next, struct pci_dev, bus_list);
-		pci_dev_get(dev);
 		if (dev->subordinate) {
 			/* this is a pci-pci bridge, do its devices next */
 			next = dev->subordinate->devices.next;
 			bus = dev->subordinate;
 		} else
 			next = dev->bus_list.next;
-		spin_unlock(&pci_bus_lock);
 
-		/* Run device routines with the bus unlocked */
+		/* Run device routines with the device locked */
+		down(&dev->dev.sem);
 		cb(dev, userdata);
-
-		spin_lock(&pci_bus_lock);
-		pci_dev_put(dev);
+		up(&dev->dev.sem);
 	}
-	spin_unlock(&pci_bus_lock);
+	up_read(&pci_bus_sem);
 }
 EXPORT_SYMBOL_GPL(pci_walk_bus);
 

commit cecf4864cf52a4a243a62b2856a6a155edbb55e8
Author: Paul Mackerras <paulus@samba.org>
Date:   Thu Aug 18 14:33:01 2005 +1000

    [PATCH] PCI: Add pci_walk_bus function to PCI core (nonrecursive)
    
    The PCI error recovery infrastructure needs to be able to contact all
    the drivers affected by a PCI error event, which may mean traversing
    all the devices under a given PCI-PCI bridge.  This patch adds a
    function to the PCI core that traverses all the PCI devices on a PCI
    bus and under any PCI-PCI bridges on that bus (and so on), calling a
    given function for each device.  This provides a way for the error
    recovery code to iterate through all devices that are affected by an
    error event.
    
    This version is not implemented as a recursive function.  Instead,
    when we reach a PCI-PCI bridge, we set the pointers to start doing the
    devices on the bus under the bridge, and when we reach the end of a
    bus's devices, we use the bus->self pointer to go back up to the next
    higher bus and continue doing its devices.
    
    Signed-off-by: Paul Mackerras <paulus@samba.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index a83ee0b85394..eed67d9e73bc 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -151,6 +151,54 @@ void pci_enable_bridges(struct pci_bus *bus)
 	}
 }
 
+/** pci_walk_bus - walk devices on/under bus, calling callback.
+ *  @top      bus whose devices should be walked
+ *  @cb       callback to be called for each device found
+ *  @userdata arbitrary pointer to be passed to callback.
+ *
+ *  Walk the given bus, including any bridged devices
+ *  on buses under this bus.  Call the provided callback
+ *  on each device found.
+ */
+void pci_walk_bus(struct pci_bus *top, void (*cb)(struct pci_dev *, void *),
+		  void *userdata)
+{
+	struct pci_dev *dev;
+	struct pci_bus *bus;
+	struct list_head *next;
+
+	bus = top;
+	spin_lock(&pci_bus_lock);
+	next = top->devices.next;
+	for (;;) {
+		if (next == &bus->devices) {
+			/* end of this bus, go up or finish */
+			if (bus == top)
+				break;
+			next = bus->self->bus_list.next;
+			bus = bus->self->bus;
+			continue;
+		}
+		dev = list_entry(next, struct pci_dev, bus_list);
+		pci_dev_get(dev);
+		if (dev->subordinate) {
+			/* this is a pci-pci bridge, do its devices next */
+			next = dev->subordinate->devices.next;
+			bus = dev->subordinate;
+		} else
+			next = dev->bus_list.next;
+		spin_unlock(&pci_bus_lock);
+
+		/* Run device routines with the bus unlocked */
+		cb(dev, userdata);
+
+		spin_lock(&pci_bus_lock);
+		pci_dev_put(dev);
+	}
+	spin_unlock(&pci_bus_lock);
+}
+EXPORT_SYMBOL_GPL(pci_walk_bus);
+
 EXPORT_SYMBOL(pci_bus_alloc_resource);
 EXPORT_SYMBOL_GPL(pci_bus_add_device);
 EXPORT_SYMBOL(pci_bus_add_devices);

commit 95a629657dbe28e44a312c47815b3dc3f1ce0970
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Jul 28 11:37:33 2005 -0700

    [PATCH] PCI: start paying attention to a lot of pci function return values
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index fb9a11243d2a..a83ee0b85394 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -140,10 +140,11 @@ void __devinit pci_bus_add_devices(struct pci_bus *bus)
 void pci_enable_bridges(struct pci_bus *bus)
 {
 	struct pci_dev *dev;
+	int retval;
 
 	list_for_each_entry(dev, &bus->devices, bus_list) {
 		if (dev->subordinate) {
-			pci_enable_device(dev);
+			retval = pci_enable_device(dev);
 			pci_set_master(dev);
 			pci_enable_bridges(dev->subordinate);
 		}

commit 688d191821de7893043f5a37970472627aaffa4e
Author: Linus Torvalds <torvalds@g5.osdl.org>
Date:   Tue Aug 2 14:55:40 2005 -0700

    pci: make bus resource start address override minimum IO address
    
    The reason we have PCIBIOS_MIN_IO and PCIBIOS_MIN_CARDBUS_IO is because
    we want to protect badly documented motherboard PCI resources and thus
    don't want to allocate new resources in low IO/MEM space.
    
    However, if we have already discovered a PCI bridge with a specified
    resource base, that should override that decision.
    
    This change will allow us to move the "careful" region upwards without
    resulting in problems allocating resources in low mappings.  This was
    brought on by us having allocated a bus resource at 0x1000, conflicting
    with a undocumented VAIO Sony PI resources.

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index fedae89d8f7d..fb9a11243d2a 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -60,7 +60,9 @@ pci_bus_alloc_resource(struct pci_bus *bus, struct resource *res,
 			continue;
 
 		/* Ok, try it out.. */
-		ret = allocate_resource(r, res, size, min, -1, align,
+		ret = allocate_resource(r, res, size,
+					r->start ? : min,
+					-1, align,
 					alignf, alignf_data);
 		if (ret == 0)
 			break;

commit 6ef6f0e33c4645fc8d23201ad5a6a289b4303cbb
Author: Rajesh Shah <rajesh.shah@intel.com>
Date:   Thu Apr 28 00:25:49 2005 -0700

    [PATCH] acpi bridge hotadd: Link newly created pci child bus to its parent on creation
    
    When a pci child bus is created, add it to the parent's children list
    immediately rather than waiting till pci_bus_add_devices().  For hot-plug
    bridges/devices, pci_bus_add_devices() may be called much later, after they
    have been properly configured.  In the meantime, this allows us to use the
    normal pci bus search functions for the hot-plug bridges/buses.
    
    Signed-off-by: Rajesh Shah <rajesh.shah@intel.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index dbd33605cc10..fedae89d8f7d 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -121,10 +121,13 @@ void __devinit pci_bus_add_devices(struct pci_bus *bus)
 		 * If there is an unattached subordinate bus, attach
 		 * it and then scan for unattached PCI devices.
 		 */
-		if (dev->subordinate && list_empty(&dev->subordinate->node)) {
-			spin_lock(&pci_bus_lock);
-			list_add_tail(&dev->subordinate->node, &dev->bus->children);
-			spin_unlock(&pci_bus_lock);
+		if (dev->subordinate) {
+		       if (list_empty(&dev->subordinate->node)) {
+			       spin_lock(&pci_bus_lock);
+			       list_add_tail(&dev->subordinate->node,
+					       &dev->bus->children);
+			       spin_unlock(&pci_bus_lock);
+		       }
 			pci_bus_add_devices(dev->subordinate);
 
 			sysfs_create_link(&dev->subordinate->class_dev.kobj, &dev->dev.kobj, "bridge");

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
new file mode 100644
index 000000000000..dbd33605cc10
--- /dev/null
+++ b/drivers/pci/bus.c
@@ -0,0 +1,151 @@
+/*
+ *	drivers/pci/bus.c
+ *
+ * From setup-res.c, by:
+ *	Dave Rusling (david.rusling@reo.mts.dec.com)
+ *	David Mosberger (davidm@cs.arizona.edu)
+ *	David Miller (davem@redhat.com)
+ *	Ivan Kokshaysky (ink@jurassic.park.msu.ru)
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/errno.h>
+#include <linux/ioport.h>
+#include <linux/proc_fs.h>
+#include <linux/init.h>
+
+#include "pci.h"
+
+/**
+ * pci_bus_alloc_resource - allocate a resource from a parent bus
+ * @bus: PCI bus
+ * @res: resource to allocate
+ * @size: size of resource to allocate
+ * @align: alignment of resource to allocate
+ * @min: minimum /proc/iomem address to allocate
+ * @type_mask: IORESOURCE_* type flags
+ * @alignf: resource alignment function
+ * @alignf_data: data argument for resource alignment function
+ *
+ * Given the PCI bus a device resides on, the size, minimum address,
+ * alignment and type, try to find an acceptable resource allocation
+ * for a specific device resource.
+ */
+int
+pci_bus_alloc_resource(struct pci_bus *bus, struct resource *res,
+	unsigned long size, unsigned long align, unsigned long min,
+	unsigned int type_mask,
+	void (*alignf)(void *, struct resource *,
+			unsigned long, unsigned long),
+	void *alignf_data)
+{
+	int i, ret = -ENOMEM;
+
+	type_mask |= IORESOURCE_IO | IORESOURCE_MEM;
+
+	for (i = 0; i < PCI_BUS_NUM_RESOURCES; i++) {
+		struct resource *r = bus->resource[i];
+		if (!r)
+			continue;
+
+		/* type_mask must match */
+		if ((res->flags ^ r->flags) & type_mask)
+			continue;
+
+		/* We cannot allocate a non-prefetching resource
+		   from a pre-fetching area */
+		if ((r->flags & IORESOURCE_PREFETCH) &&
+		    !(res->flags & IORESOURCE_PREFETCH))
+			continue;
+
+		/* Ok, try it out.. */
+		ret = allocate_resource(r, res, size, min, -1, align,
+					alignf, alignf_data);
+		if (ret == 0)
+			break;
+	}
+	return ret;
+}
+
+/**
+ * add a single device
+ * @dev: device to add
+ *
+ * This adds a single pci device to the global
+ * device list and adds sysfs and procfs entries
+ */
+void __devinit pci_bus_add_device(struct pci_dev *dev)
+{
+	device_add(&dev->dev);
+
+	spin_lock(&pci_bus_lock);
+	list_add_tail(&dev->global_list, &pci_devices);
+	spin_unlock(&pci_bus_lock);
+
+	pci_proc_attach_device(dev);
+	pci_create_sysfs_dev_files(dev);
+}
+
+/**
+ * pci_bus_add_devices - insert newly discovered PCI devices
+ * @bus: bus to check for new devices
+ *
+ * Add newly discovered PCI devices (which are on the bus->devices
+ * list) to the global PCI device list, add the sysfs and procfs
+ * entries.  Where a bridge is found, add the discovered bus to
+ * the parents list of child buses, and recurse (breadth-first
+ * to be compatible with 2.4)
+ *
+ * Call hotplug for each new devices.
+ */
+void __devinit pci_bus_add_devices(struct pci_bus *bus)
+{
+	struct pci_dev *dev;
+
+	list_for_each_entry(dev, &bus->devices, bus_list) {
+		/*
+		 * Skip already-present devices (which are on the
+		 * global device list.)
+		 */
+		if (!list_empty(&dev->global_list))
+			continue;
+		pci_bus_add_device(dev);
+	}
+
+	list_for_each_entry(dev, &bus->devices, bus_list) {
+
+		BUG_ON(list_empty(&dev->global_list));
+
+		/*
+		 * If there is an unattached subordinate bus, attach
+		 * it and then scan for unattached PCI devices.
+		 */
+		if (dev->subordinate && list_empty(&dev->subordinate->node)) {
+			spin_lock(&pci_bus_lock);
+			list_add_tail(&dev->subordinate->node, &dev->bus->children);
+			spin_unlock(&pci_bus_lock);
+			pci_bus_add_devices(dev->subordinate);
+
+			sysfs_create_link(&dev->subordinate->class_dev.kobj, &dev->dev.kobj, "bridge");
+		}
+	}
+}
+
+void pci_enable_bridges(struct pci_bus *bus)
+{
+	struct pci_dev *dev;
+
+	list_for_each_entry(dev, &bus->devices, bus_list) {
+		if (dev->subordinate) {
+			pci_enable_device(dev);
+			pci_set_master(dev);
+			pci_enable_bridges(dev->subordinate);
+		}
+	}
+}
+
+EXPORT_SYMBOL(pci_bus_alloc_resource);
+EXPORT_SYMBOL_GPL(pci_bus_add_device);
+EXPORT_SYMBOL(pci_bus_add_devices);
+EXPORT_SYMBOL(pci_enable_bridges);
