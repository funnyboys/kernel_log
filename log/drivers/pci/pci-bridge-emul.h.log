commit e0d9d30b73548fbfe5c024ed630169bdc9a08aee
Author: Grzegorz Jaszczyk <jaz@semihalf.com>
Date:   Tue Jul 16 14:13:46 2019 +0200

    PCI: pci-bridge-emul: Fix big-endian support
    
    Perform conversion to little-endian before every write to configuration
    space and convert it back to CPU endianness on reads.
    
    Additionally, initialise every multiple byte field of config space with
    the cpu_to_le* macro, which is required since the structure describing
    config space of emulated bridge assumes little-endian convention.
    
    Signed-off-by: Grzegorz Jaszczyk <jaz@semihalf.com>
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>

diff --git a/drivers/pci/pci-bridge-emul.h b/drivers/pci/pci-bridge-emul.h
index e65b1b79899d..b31883022a8e 100644
--- a/drivers/pci/pci-bridge-emul.h
+++ b/drivers/pci/pci-bridge-emul.h
@@ -6,65 +6,65 @@
 
 /* PCI configuration space of a PCI-to-PCI bridge. */
 struct pci_bridge_emul_conf {
-	u16 vendor;
-	u16 device;
-	u16 command;
-	u16 status;
-	u32 class_revision;
+	__le16 vendor;
+	__le16 device;
+	__le16 command;
+	__le16 status;
+	__le32 class_revision;
 	u8 cache_line_size;
 	u8 latency_timer;
 	u8 header_type;
 	u8 bist;
-	u32 bar[2];
+	__le32 bar[2];
 	u8 primary_bus;
 	u8 secondary_bus;
 	u8 subordinate_bus;
 	u8 secondary_latency_timer;
 	u8 iobase;
 	u8 iolimit;
-	u16 secondary_status;
-	u16 membase;
-	u16 memlimit;
-	u16 pref_mem_base;
-	u16 pref_mem_limit;
-	u32 prefbaseupper;
-	u32 preflimitupper;
-	u16 iobaseupper;
-	u16 iolimitupper;
+	__le16 secondary_status;
+	__le16 membase;
+	__le16 memlimit;
+	__le16 pref_mem_base;
+	__le16 pref_mem_limit;
+	__le32 prefbaseupper;
+	__le32 preflimitupper;
+	__le16 iobaseupper;
+	__le16 iolimitupper;
 	u8 capabilities_pointer;
 	u8 reserve[3];
-	u32 romaddr;
+	__le32 romaddr;
 	u8 intline;
 	u8 intpin;
-	u16 bridgectrl;
+	__le16 bridgectrl;
 };
 
 /* PCI configuration space of the PCIe capabilities */
 struct pci_bridge_emul_pcie_conf {
 	u8 cap_id;
 	u8 next;
-	u16 cap;
-	u32 devcap;
-	u16 devctl;
-	u16 devsta;
-	u32 lnkcap;
-	u16 lnkctl;
-	u16 lnksta;
-	u32 slotcap;
-	u16 slotctl;
-	u16 slotsta;
-	u16 rootctl;
-	u16 rsvd;
-	u32 rootsta;
-	u32 devcap2;
-	u16 devctl2;
-	u16 devsta2;
-	u32 lnkcap2;
-	u16 lnkctl2;
-	u16 lnksta2;
-	u32 slotcap2;
-	u16 slotctl2;
-	u16 slotsta2;
+	__le16 cap;
+	__le32 devcap;
+	__le16 devctl;
+	__le16 devsta;
+	__le32 lnkcap;
+	__le16 lnkctl;
+	__le16 lnksta;
+	__le32 slotcap;
+	__le16 slotctl;
+	__le16 slotsta;
+	__le16 rootctl;
+	__le16 rsvd;
+	__le32 rootsta;
+	__le32 devcap2;
+	__le16 devctl2;
+	__le16 devsta2;
+	__le32 lnkcap2;
+	__le16 lnkctl2;
+	__le16 lnksta2;
+	__le32 slotcap2;
+	__le16 slotctl2;
+	__le16 slotsta2;
 };
 
 struct pci_bridge_emul;

commit 33776d059630e5045ea9ccf756c74de8f9cc86de
Author: Thomas Petazzoni <thomas.petazzoni@bootlin.com>
Date:   Wed Feb 20 10:48:41 2019 +0100

    PCI: pci-bridge-emul: Extend pci_bridge_emul_init() with flags
    
    Depending on the capabilities of the PCI controller/platform, the
    PCI-to-PCI bridge emulation behavior might need to be different. For
    example, on platforms that use the pci-mvebu code, we currently don't
    support prefetchable memory BARs, so the corresponding fields in the
    PCI-to-PCI bridge configuration space should be read-only.
    
    To implement this, extend pci_bridge_emul_init() to take a "flags"
    argument, with currently one flag supported:
    
    PCI_BRIDGE_EMUL_NO_PREFETCHABLE_BAR
    
    that will make the prefetchable memory base and limit registers
    read-only.
    
    The pci-mvebu and pci-aardvark drivers are updated accordingly.
    
    Fixes: 1f08673eef123 ("PCI: mvebu: Convert to PCI emulated bridge config space")
    Reported-by: Luís Mendes <luis.p.mendes@gmail.com>
    Reported-by: Leigh Brown <leigh@solinno.co.uk>
    Tested-by: Leigh Brown <leigh@solinno.co.uk>
    Tested-by: Luis Mendes <luis.p.mendes@gmail.com>
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@bootlin.com>
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Cc: stable@vger.kernel.org
    Cc: Luís Mendes <luis.p.mendes@gmail.com>
    Cc: Leigh Brown <leigh@solinno.co.uk>

diff --git a/drivers/pci/pci-bridge-emul.h b/drivers/pci/pci-bridge-emul.h
index f04637bb3222..e65b1b79899d 100644
--- a/drivers/pci/pci-bridge-emul.h
+++ b/drivers/pci/pci-bridge-emul.h
@@ -119,7 +119,12 @@ struct pci_bridge_emul {
 	bool has_pcie;
 };
 
-int pci_bridge_emul_init(struct pci_bridge_emul *bridge);
+enum {
+	PCI_BRIDGE_EMUL_NO_PREFETCHABLE_BAR = BIT(0),
+};
+
+int pci_bridge_emul_init(struct pci_bridge_emul *bridge,
+			 unsigned int flags);
 void pci_bridge_emul_cleanup(struct pci_bridge_emul *bridge);
 
 int pci_bridge_emul_conf_read(struct pci_bridge_emul *bridge, int where,

commit 59f81c35e0df840f7112cb296dde48df84a67c79
Author: Thomas Petazzoni <thomas.petazzoni@bootlin.com>
Date:   Wed Feb 20 10:48:40 2019 +0100

    PCI: pci-bridge-emul: Create per-bridge copy of register behavior
    
    The behavior of the different registers of the PCI-to-PCI bridge is
    currently encoded in two global arrays, shared by all instances of
    PCI-to-PCI bridge emulation.
    
    However, we will need to tweak the behavior on a per-bridge basis, to
    accommodate for different capabilities of the platforms where this
    code is used. In preparation for this, create a per-bridge copy of the
    register behavior arrays, so that they can later be tweaked on a
    per-bridge basis.
    
    Fixes: 1f08673eef123 ("PCI: mvebu: Convert to PCI emulated bridge config space")
    Reported-by: Luís Mendes <luis.p.mendes@gmail.com>
    Reported-by: Leigh Brown <leigh@solinno.co.uk>
    Tested-by: Leigh Brown <leigh@solinno.co.uk>
    Tested-by: Luis Mendes <luis.p.mendes@gmail.com>
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@bootlin.com>
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Cc: stable@vger.kernel.org
    Cc: Luís Mendes <luis.p.mendes@gmail.com>
    Cc: Leigh Brown <leigh@solinno.co.uk>

diff --git a/drivers/pci/pci-bridge-emul.h b/drivers/pci/pci-bridge-emul.h
index 9d510ccf738b..f04637bb3222 100644
--- a/drivers/pci/pci-bridge-emul.h
+++ b/drivers/pci/pci-bridge-emul.h
@@ -107,15 +107,21 @@ struct pci_bridge_emul_ops {
 			   u32 old, u32 new, u32 mask);
 };
 
+struct pci_bridge_reg_behavior;
+
 struct pci_bridge_emul {
 	struct pci_bridge_emul_conf conf;
 	struct pci_bridge_emul_pcie_conf pcie_conf;
 	struct pci_bridge_emul_ops *ops;
+	struct pci_bridge_reg_behavior *pci_regs_behavior;
+	struct pci_bridge_reg_behavior *pcie_cap_regs_behavior;
 	void *data;
 	bool has_pcie;
 };
 
-void pci_bridge_emul_init(struct pci_bridge_emul *bridge);
+int pci_bridge_emul_init(struct pci_bridge_emul *bridge);
+void pci_bridge_emul_cleanup(struct pci_bridge_emul *bridge);
+
 int pci_bridge_emul_conf_read(struct pci_bridge_emul *bridge, int where,
 			      int size, u32 *value);
 int pci_bridge_emul_conf_write(struct pci_bridge_emul *bridge, int where,

commit 23a5fba4d9411787c8e86ff5808e7d8e41bf3935
Author: Thomas Petazzoni <thomas.petazzoni@bootlin.com>
Date:   Thu Oct 18 17:37:16 2018 +0200

    PCI: Introduce PCI bridge emulated config space common logic
    
    Some PCI host controllers do not expose a configuration space for the
    root port PCI bridge. Due to this, the Marvell Armada 370/38x/XP PCI
    controller driver (pci-mvebu) emulates a root port PCI bridge
    configuration space, and uses that to (among other things) dynamically
    create the memory windows that correspond to the PCI MEM and I/O
    regions.
    
    Since we now need to add a very similar logic for the Marvell Armada
    37xx PCI controller driver (pci-aardvark), instead of duplicating the
    code, we create in this commit a common logic called pci-bridge-emul.
    
    The idea of this logic is to emulate a root port PCI bridge
    configuration space by providing configuration space read/write
    operations, and faking behind the scenes the configuration space of a
    PCI bridge. A PCI host controller driver simply has to call
    pci_bridge_emul_conf_read() and pci_bridge_emul_conf_write() to
    read/write the configuration space of the bridge.
    
    By default, the PCI bridge configuration space is simply emulated by a
    chunk of memory, but the PCI host controller can override the behavior
    of the read and write operations on a per-register basis to do
    additional actions if needed. We take care of complying with the
    behavior of the PCI configuration space registers in terms of bits
    that are read-write, read-only, reserved and write-1-to-clear.
    
    Signed-off-by: Thomas Petazzoni <thomas.petazzoni@bootlin.com>
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Russell King <rmk+kernel@armlinux.org.uk>

diff --git a/drivers/pci/pci-bridge-emul.h b/drivers/pci/pci-bridge-emul.h
new file mode 100644
index 000000000000..9d510ccf738b
--- /dev/null
+++ b/drivers/pci/pci-bridge-emul.h
@@ -0,0 +1,124 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef __PCI_BRIDGE_EMUL_H__
+#define __PCI_BRIDGE_EMUL_H__
+
+#include <linux/kernel.h>
+
+/* PCI configuration space of a PCI-to-PCI bridge. */
+struct pci_bridge_emul_conf {
+	u16 vendor;
+	u16 device;
+	u16 command;
+	u16 status;
+	u32 class_revision;
+	u8 cache_line_size;
+	u8 latency_timer;
+	u8 header_type;
+	u8 bist;
+	u32 bar[2];
+	u8 primary_bus;
+	u8 secondary_bus;
+	u8 subordinate_bus;
+	u8 secondary_latency_timer;
+	u8 iobase;
+	u8 iolimit;
+	u16 secondary_status;
+	u16 membase;
+	u16 memlimit;
+	u16 pref_mem_base;
+	u16 pref_mem_limit;
+	u32 prefbaseupper;
+	u32 preflimitupper;
+	u16 iobaseupper;
+	u16 iolimitupper;
+	u8 capabilities_pointer;
+	u8 reserve[3];
+	u32 romaddr;
+	u8 intline;
+	u8 intpin;
+	u16 bridgectrl;
+};
+
+/* PCI configuration space of the PCIe capabilities */
+struct pci_bridge_emul_pcie_conf {
+	u8 cap_id;
+	u8 next;
+	u16 cap;
+	u32 devcap;
+	u16 devctl;
+	u16 devsta;
+	u32 lnkcap;
+	u16 lnkctl;
+	u16 lnksta;
+	u32 slotcap;
+	u16 slotctl;
+	u16 slotsta;
+	u16 rootctl;
+	u16 rsvd;
+	u32 rootsta;
+	u32 devcap2;
+	u16 devctl2;
+	u16 devsta2;
+	u32 lnkcap2;
+	u16 lnkctl2;
+	u16 lnksta2;
+	u32 slotcap2;
+	u16 slotctl2;
+	u16 slotsta2;
+};
+
+struct pci_bridge_emul;
+
+typedef enum { PCI_BRIDGE_EMUL_HANDLED,
+	       PCI_BRIDGE_EMUL_NOT_HANDLED } pci_bridge_emul_read_status_t;
+
+struct pci_bridge_emul_ops {
+	/*
+	 * Called when reading from the regular PCI bridge
+	 * configuration space. Return PCI_BRIDGE_EMUL_HANDLED when the
+	 * operation has handled the read operation and filled in the
+	 * *value, or PCI_BRIDGE_EMUL_NOT_HANDLED when the read should
+	 * be emulated by the common code by reading from the
+	 * in-memory copy of the configuration space.
+	 */
+	pci_bridge_emul_read_status_t (*read_base)(struct pci_bridge_emul *bridge,
+						   int reg, u32 *value);
+
+	/*
+	 * Same as ->read_base(), except it is for reading from the
+	 * PCIe capability configuration space.
+	 */
+	pci_bridge_emul_read_status_t (*read_pcie)(struct pci_bridge_emul *bridge,
+						   int reg, u32 *value);
+	/*
+	 * Called when writing to the regular PCI bridge configuration
+	 * space. old is the current value, new is the new value being
+	 * written, and mask indicates which parts of the value are
+	 * being changed.
+	 */
+	void (*write_base)(struct pci_bridge_emul *bridge, int reg,
+			   u32 old, u32 new, u32 mask);
+
+	/*
+	 * Same as ->write_base(), except it is for writing from the
+	 * PCIe capability configuration space.
+	 */
+	void (*write_pcie)(struct pci_bridge_emul *bridge, int reg,
+			   u32 old, u32 new, u32 mask);
+};
+
+struct pci_bridge_emul {
+	struct pci_bridge_emul_conf conf;
+	struct pci_bridge_emul_pcie_conf pcie_conf;
+	struct pci_bridge_emul_ops *ops;
+	void *data;
+	bool has_pcie;
+};
+
+void pci_bridge_emul_init(struct pci_bridge_emul *bridge);
+int pci_bridge_emul_conf_read(struct pci_bridge_emul *bridge, int where,
+			      int size, u32 *value);
+int pci_bridge_emul_conf_write(struct pci_bridge_emul *bridge, int where,
+			       int size, u32 value);
+
+#endif /* __PCI_BRIDGE_EMUL_H__ */
