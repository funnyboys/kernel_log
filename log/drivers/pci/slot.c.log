commit e56faff57f0b39661093c00e0262d4ab9088830e
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Feb 28 15:02:03 2020 -0600

    PCI: Add pci_speed_string()
    
    Add pci_speed_string() to return a text description of the supplied bus or
    link speed.  The slot code previously used the private
    pci_bus_speed_strings[] array for this purpose, but adding this interface
    will enable us to consolidate similar code elsewhere.
    
    Export pcie_link_speed[] and pci_speed_string() so they can be used by
    modules.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/slot.c b/drivers/pci/slot.c
index ae4aa0e1f2f4..cc386ef2fa12 100644
--- a/drivers/pci/slot.c
+++ b/drivers/pci/slot.c
@@ -49,45 +49,9 @@ static ssize_t address_read_file(struct pci_slot *slot, char *buf)
 				slot->number);
 }
 
-/* these strings match up with the values in pci_bus_speed */
-static const char *pci_bus_speed_strings[] = {
-	"33 MHz PCI",		/* 0x00 */
-	"66 MHz PCI",		/* 0x01 */
-	"66 MHz PCI-X",		/* 0x02 */
-	"100 MHz PCI-X",	/* 0x03 */
-	"133 MHz PCI-X",	/* 0x04 */
-	NULL,			/* 0x05 */
-	NULL,			/* 0x06 */
-	NULL,			/* 0x07 */
-	NULL,			/* 0x08 */
-	"66 MHz PCI-X 266",	/* 0x09 */
-	"100 MHz PCI-X 266",	/* 0x0a */
-	"133 MHz PCI-X 266",	/* 0x0b */
-	"Unknown AGP",		/* 0x0c */
-	"1x AGP",		/* 0x0d */
-	"2x AGP",		/* 0x0e */
-	"4x AGP",		/* 0x0f */
-	"8x AGP",		/* 0x10 */
-	"66 MHz PCI-X 533",	/* 0x11 */
-	"100 MHz PCI-X 533",	/* 0x12 */
-	"133 MHz PCI-X 533",	/* 0x13 */
-	"2.5 GT/s PCIe",	/* 0x14 */
-	"5.0 GT/s PCIe",	/* 0x15 */
-	"8.0 GT/s PCIe",	/* 0x16 */
-	"16.0 GT/s PCIe",	/* 0x17 */
-	"32.0 GT/s PCIe",	/* 0x18 */
-};
-
 static ssize_t bus_speed_read(enum pci_bus_speed speed, char *buf)
 {
-	const char *speed_string;
-
-	if (speed < ARRAY_SIZE(pci_bus_speed_strings))
-		speed_string = pci_bus_speed_strings[speed];
-	else
-		speed_string = "Unknown";
-
-	return sprintf(buf, "%s\n", speed_string);
+	return sprintf(buf, "%s\n", pci_speed_string(speed));
 }
 
 static ssize_t max_speed_read_file(struct pci_slot *slot, char *buf)

commit de76cda215d56256ffcda7ffa538b70f9fb301a7
Author: Gustavo Pimentel <Gustavo.Pimentel@synopsys.com>
Date:   Tue Jun 4 18:24:43 2019 +0200

    PCI: Decode PCIe 32 GT/s link speed
    
    PCIe r5.0, sec 7.5.3.18, defines a new 32.0 GT/s bit in the Supported Link
    Speeds Vector of Link Capabilities 2.  Decode this new speed.  This does
    not affect the speed of the link, which should be negotiated automatically
    by the hardware; it only adds decoding when showing the speed to the user.
    
    Previously, reading the speed of a link operating at this speed showed
    "Unknown speed" instead of "32.0 GT/s".
    
    Link: https://lore.kernel.org/lkml/92365e3caf0fc559f9ab14bcd053bfc92d4f661c.1559664969.git.gustavo.pimentel@synopsys.com
    Signed-off-by: Gustavo Pimentel <gustavo.pimentel@synopsys.com>
    [bhelgaas: changelog]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/slot.c b/drivers/pci/slot.c
index f4d92b1afe7b..ae4aa0e1f2f4 100644
--- a/drivers/pci/slot.c
+++ b/drivers/pci/slot.c
@@ -75,6 +75,7 @@ static const char *pci_bus_speed_strings[] = {
 	"5.0 GT/s PCIe",	/* 0x15 */
 	"8.0 GT/s PCIe",	/* 0x16 */
 	"16.0 GT/s PCIe",	/* 0x17 */
+	"32.0 GT/s PCIe",	/* 0x18 */
 };
 
 static ssize_t bus_speed_read(enum pci_bus_speed speed, char *buf)

commit 25da8dbaaf0679b3b22c783952a8392071cfa135
Author: Mohan Kumar <mohankumar718@gmail.com>
Date:   Sat Apr 20 07:03:46 2019 +0300

    PCI: Replace printk(KERN_INFO) with pr_info(), etc
    
    Replace printk() with pr_*() to be more consistent with other logging and
    avoid checkpatch warnings.
    
    Link: https://lore.kernel.org/lkml/1555733026-19609-1-git-send-email-mohankumar718@gmail.com
    Link: https://lore.kernel.org/lkml/1555733130-19804-1-git-send-email-mohankumar718@gmail.com
    Signed-off-by: Mohan Kumar <mohankumar718@gmail.com>
    [bhelgaas: squash in similar changes from second patch in series]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/slot.c b/drivers/pci/slot.c
index c46d5e1ff536..f4d92b1afe7b 100644
--- a/drivers/pci/slot.c
+++ b/drivers/pci/slot.c
@@ -403,7 +403,7 @@ static int pci_slot_init(void)
 	pci_slots_kset = kset_create_and_add("slots", NULL,
 						&pci_bus_kset->kobj);
 	if (!pci_slots_kset) {
-		printk(KERN_ERR "PCI: Slot initialization failure\n");
+		pr_err("PCI: Slot initialization failure\n");
 		return -ENOMEM;
 	}
 	return 0;

commit c4eed62a214330908eec11b0dc170d34fa50b412
Author: Keith Busch <keith.busch@intel.com>
Date:   Thu Sep 20 10:27:11 2018 -0600

    PCI/ERR: Use slot reset if available
    
    The secondary bus reset may have link side effects that a hotplug capable
    port may incorrectly react to.  Use the slot specific reset for hotplug
    ports, fixing the undesirable link down-up handling during error
    recovering.
    
    Signed-off-by: Keith Busch <keith.busch@intel.com>
    [bhelgaas: fold in
    https://lore.kernel.org/linux-pci/20180926152326.14821-1-keith.busch@intel.com
    for issue reported by Stephen Rothwell <sfr@canb.auug.org.au>]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Sinan Kaya <okaya@kernel.org>

diff --git a/drivers/pci/slot.c b/drivers/pci/slot.c
index 145cd953b518..c46d5e1ff536 100644
--- a/drivers/pci/slot.c
+++ b/drivers/pci/slot.c
@@ -14,7 +14,6 @@
 
 struct kset *pci_slots_kset;
 EXPORT_SYMBOL_GPL(pci_slots_kset);
-static DEFINE_MUTEX(pci_slot_mutex);
 
 static ssize_t pci_slot_attr_show(struct kobject *kobj,
 					struct attribute *attr, char *buf)

commit 81c4b5bf30de01a0f6b43ccaa1d220f4a0a5d99c
Author: Lukas Wunner <lukas@wunner.de>
Date:   Sat Sep 8 09:59:01 2018 +0200

    PCI: hotplug: Constify hotplug_slot_ops
    
    Hotplug drivers cannot declare their hotplug_slot_ops const, making them
    attractive targets for attackers, because upon registration of a hotplug
    slot, __pci_hp_initialize() writes to the "owner" and "mod_name" members
    in that struct.
    
    Fix by moving these members to struct hotplug_slot and constify every
    driver's hotplug_slot_ops except for pciehp.
    
    pciehp constructs its hotplug_slot_ops at runtime based on the PCIe
    port's capabilities, hence cannot declare them const.  It can be
    converted to __write_rarely once that's mainlined:
    http://www.openwall.com/lists/kernel-hardening/2016/11/16/3
    
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Tyrel Datwyler <tyreld@linux.vnet.ibm.com>  # drivers/pci/hotplug/rpa*
    Acked-by: Andy Shevchenko <andy.shevchenko@gmail.com> # drivers/platform/x86
    Cc: Len Brown <lenb@kernel.org>
    Cc: Scott Murray <scott@spiteful.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Oliver OHalloran <oliveroh@au1.ibm.com>
    Cc: Gavin Shan <gwshan@linux.vnet.ibm.com>
    Cc: Sebastian Ott <sebott@linux.vnet.ibm.com>
    Cc: Gerald Schaefer <gerald.schaefer@de.ibm.com>
    Cc: Corentin Chary <corentin.chary@gmail.com>
    Cc: Darren Hart <dvhart@infradead.org>

diff --git a/drivers/pci/slot.c b/drivers/pci/slot.c
index e634229ece89..145cd953b518 100644
--- a/drivers/pci/slot.c
+++ b/drivers/pci/slot.c
@@ -371,7 +371,7 @@ void pci_hp_create_module_link(struct pci_slot *pci_slot)
 
 	if (!slot || !slot->ops)
 		return;
-	kobj = kset_find_obj(module_kset, slot->ops->mod_name);
+	kobj = kset_find_obj(module_kset, slot->mod_name);
 	if (!kobj)
 		return;
 	ret = sysfs_create_link(&pci_slot->kobj, kobj, "module");

commit 43b90eaed57679731ae340a47cef49e59a321c2e
Merge: 3da1b6174ba3 ad32eb2df801
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Apr 4 13:27:45 2018 -0500

    Merge branch 'pci/misc'
    
      - use PCI_EXP_DEVCTL2_COMP_TIMEOUT in rapidio/tsi721 (Bjorn Helgaas)
    
      - remove possible NULL pointer dereference in of_pci_bus_find_domain_nr()
        (Shawn Lin)
    
      - report quirk timings with dev_info (Bjorn Helgaas)
    
      - report quirks that take longer than 10ms (Bjorn Helgaas)
    
      - add and use Altera Vendor ID (Johannes Thumshirn)
    
      - tidy Makefiles and comments (Bjorn Helgaas)
    
    * pci/misc:
      PCI: Always define the of_node helpers
      PCI: Tidy comments
      PCI: Tidy Makefiles
      mcb: Add Altera PCI ID to mcb-pci
      PCI: Add Altera vendor ID
      PCI: Report quirks that take more than 10ms
      PCI: Report quirk timings with pci_info() instead of pr_debug()
      PCI: Fix NULL pointer dereference in of_pci_bus_find_domain_nr()
      rapidio/tsi721: use PCI_EXP_DEVCTL2_COMP_TIMEOUT macro

commit 1acfb9b7ee0b1881bb8e875b6757976e48293ec4
Author: Jay Fang <f.fangjian@huawei.com>
Date:   Mon Mar 12 17:13:32 2018 +0800

    PCI: Add decoding for 16 GT/s link speed
    
    PCIe 4.0 defines the 16.0 GT/s link speed.  Links can run at that speed
    without any Linux changes, but previously their sysfs "max_link_speed" and
    "current_link_speed" files contained "Unknown speed", not the expected
    "16.0 GT/s".
    
    Add decoding for the new 16 GT/s link speed.
    
    Signed-off-by: Jay Fang <f.fangjian@huawei.com>
    [bhelgaas: add PCI_EXP_LNKCAP2_SLS_16_0GB]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Dongdong Liu <liudongdong3@huawei.com>

diff --git a/drivers/pci/slot.c b/drivers/pci/slot.c
index d10f556dc03e..191893e19d5c 100644
--- a/drivers/pci/slot.c
+++ b/drivers/pci/slot.c
@@ -76,6 +76,7 @@ static const char *pci_bus_speed_strings[] = {
 	"2.5 GT/s PCIe",	/* 0x14 */
 	"5.0 GT/s PCIe",	/* 0x15 */
 	"8.0 GT/s PCIe",	/* 0x16 */
+	"16.0 GT/s PCIe",	/* 0x17 */
 };
 
 static ssize_t bus_speed_read(enum pci_bus_speed speed, char *buf)

commit df62ab5e0f75608919df7442654b0fab78246b7b
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Mar 9 16:36:33 2018 -0600

    PCI: Tidy comments
    
    Remove pointless comments that tell us the file name, remove blank line
    comments, follow multi-line comment conventions.  No functional change
    intended.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/slot.c b/drivers/pci/slot.c
index d10f556dc03e..bdea6d4061ae 100644
--- a/drivers/pci/slot.c
+++ b/drivers/pci/slot.c
@@ -1,6 +1,5 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * drivers/pci/slot.c
  * Copyright (C) 2006 Matthew Wilcox <matthew@wil.cx>
  * Copyright (C) 2006-2009 Hewlett-Packard Development Company, L.P.
  *	Alex Chiang <achiang@hp.com>

commit 7328c8f48d1895b3fec98b0b319cfb856b4c4fa1
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Jan 26 11:45:16 2018 -0600

    PCI: Add SPDX GPL-2.0 when no license was specified
    
    b24413180f56 ("License cleanup: add SPDX GPL-2.0 license identifier to
    files with no license") added SPDX GPL-2.0 to several PCI files that
    previously contained no license information.
    
    Add SPDX GPL-2.0 to all other PCI files that did not contain any license
    information and hence were under the default GPL version 2 license of the
    kernel.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pci/slot.c b/drivers/pci/slot.c
index e42909524dee..d10f556dc03e 100644
--- a/drivers/pci/slot.c
+++ b/drivers/pci/slot.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * drivers/pci/slot.c
  * Copyright (C) 2006 Matthew Wilcox <matthew@wil.cx>

commit 2c935bc57221cc2edc787c72ea0e2d30cdcd3d5e
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Mon Nov 14 17:29:48 2016 +0100

    locking/atomic, kref: Add kref_read()
    
    Since we need to change the implementation, stop exposing internals.
    
    Provide kref_read() to read the current reference count; typically
    used for debug messages.
    
    Kills two anti-patterns:
    
            atomic_read(&kref->refcount)
            kref->refcount.counter
    
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/pci/slot.c b/drivers/pci/slot.c
index 429d34c348b9..e42909524dee 100644
--- a/drivers/pci/slot.c
+++ b/drivers/pci/slot.c
@@ -345,7 +345,7 @@ EXPORT_SYMBOL_GPL(pci_create_slot);
 void pci_destroy_slot(struct pci_slot *slot)
 {
 	dev_dbg(&slot->bus->dev, "dev %02x, dec refcount to %d\n",
-		slot->number, atomic_read(&slot->kobj.kref.refcount) - 1);
+		slot->number, kref_read(&slot->kobj.kref) - 1);
 
 	mutex_lock(&pci_slot_mutex);
 	kobject_put(&slot->kobj);

commit 017ffe64e8b8c8db0f50433a71da41c6a4e12710
Author: Yijing Wang <wangyijing@huawei.com>
Date:   Fri Jul 17 17:16:32 2015 +0800

    PCI: Hold pci_slot_mutex while searching bus->slots list
    
    Previously, pci_setup_device() and similar functions searched the
    pci_bus->slots list without any locking.  It was possible for another
    thread to update the list while we searched it.
    
    Add pci_dev_assign_slot() to search the list while holding pci_slot_mutex.
    
    [bhelgaas: changelog, fold in CONFIG_SYSFS fix]
    Tested-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/slot.c b/drivers/pci/slot.c
index 4bd3fce93fa4..429d34c348b9 100644
--- a/drivers/pci/slot.c
+++ b/drivers/pci/slot.c
@@ -194,6 +194,17 @@ static int rename_slot(struct pci_slot *slot, const char *name)
 	return result;
 }
 
+void pci_dev_assign_slot(struct pci_dev *dev)
+{
+	struct pci_slot *slot;
+
+	mutex_lock(&pci_slot_mutex);
+	list_for_each_entry(slot, &dev->bus->slots, list)
+		if (PCI_SLOT(dev->devfn) == slot->number)
+			dev->slot = slot;
+	mutex_unlock(&pci_slot_mutex);
+}
+
 static struct pci_slot *get_slot(struct pci_bus *parent, int slot_nr)
 {
 	struct pci_slot *slot;

commit 67546762978f523749eac157903e0b01c18e083a
Author: Yijing Wang <wangyijing@huawei.com>
Date:   Fri Jul 17 17:16:31 2015 +0800

    PCI: Protect pci_bus->slots with pci_slot_mutex, not pci_bus_sem
    
    Rajat Jain reported a deadlock when PCIe hot-add and AER recovery happen at
    the same time:
    
    thread 1:
    
      pciehp_enable_slot
        pciehp_configure_device
          pci_bus_add_devices
            pci_bus_add_device
              device_attach
                device_lock(dev)                       # acquire device lock
                ...
                pciehp_probe
                  init_slot
                    pci_hp_register
                      pci_create_slot
                        down_write(pci_bus_sem)        # deadlock here
    
    thread 2:
    
      aer_isr_one_error
        aer_process_err_device
          do_recovery
            broadcast_error_message(..., report_error_detected)
              pci_walk_bus(..., cb=report_error_detected, ...)
                down_read(&pci_bus_sem)                # acquire pci_bus_sem
                report_error_detected(dev)             # cb()
                  device_lock(dev)                     # deadlock here
    
    Previously, the bus->devices and bus->slots list were protected by
    pci_bus_sem.  In pci_create_slot(), we held it for writing so we could
    add to the bus->slots list.
    
    Add a new local pci_slot_mutex to protect bus->slots.  Hold pci_bus_sem for
    reading while searching the bus->devices list.
    
    [bhelgaas: changelog]
    Link: http://lkml.kernel.org/r/CAA93t1qpPqbih+UB0McA_d_+2rVaNkXsinAUxYzK9+JXSS+L-g@mail.gmail.com
    Reported-by: Rajat Jain <rajatja@google.com>
    Tested-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/slot.c b/drivers/pci/slot.c
index 396c200b9ddb..4bd3fce93fa4 100644
--- a/drivers/pci/slot.c
+++ b/drivers/pci/slot.c
@@ -14,6 +14,7 @@
 
 struct kset *pci_slots_kset;
 EXPORT_SYMBOL_GPL(pci_slots_kset);
+static DEFINE_MUTEX(pci_slot_mutex);
 
 static ssize_t pci_slot_attr_show(struct kobject *kobj,
 					struct attribute *attr, char *buf)
@@ -106,9 +107,11 @@ static void pci_slot_release(struct kobject *kobj)
 	dev_dbg(&slot->bus->dev, "dev %02x, released physical slot %s\n",
 		slot->number, pci_slot_name(slot));
 
+	down_read(&pci_bus_sem);
 	list_for_each_entry(dev, &slot->bus->devices, bus_list)
 		if (PCI_SLOT(dev->devfn) == slot->number)
 			dev->slot = NULL;
+	up_read(&pci_bus_sem);
 
 	list_del(&slot->list);
 
@@ -194,9 +197,8 @@ static int rename_slot(struct pci_slot *slot, const char *name)
 static struct pci_slot *get_slot(struct pci_bus *parent, int slot_nr)
 {
 	struct pci_slot *slot;
-	/*
-	 * We already hold pci_bus_sem so don't worry
-	 */
+
+	/* We already hold pci_slot_mutex */
 	list_for_each_entry(slot, &parent->slots, list)
 		if (slot->number == slot_nr) {
 			kobject_get(&slot->kobj);
@@ -253,7 +255,7 @@ struct pci_slot *pci_create_slot(struct pci_bus *parent, int slot_nr,
 	int err = 0;
 	char *slot_name = NULL;
 
-	down_write(&pci_bus_sem);
+	mutex_lock(&pci_slot_mutex);
 
 	if (slot_nr == -1)
 		goto placeholder;
@@ -301,16 +303,18 @@ struct pci_slot *pci_create_slot(struct pci_bus *parent, int slot_nr,
 	INIT_LIST_HEAD(&slot->list);
 	list_add(&slot->list, &parent->slots);
 
+	down_read(&pci_bus_sem);
 	list_for_each_entry(dev, &parent->devices, bus_list)
 		if (PCI_SLOT(dev->devfn) == slot_nr)
 			dev->slot = slot;
+	up_read(&pci_bus_sem);
 
 	dev_dbg(&parent->dev, "dev %02x, created physical slot %s\n",
 		slot_nr, pci_slot_name(slot));
 
 out:
 	kfree(slot_name);
-	up_write(&pci_bus_sem);
+	mutex_unlock(&pci_slot_mutex);
 	return slot;
 err:
 	kfree(slot);
@@ -332,9 +336,9 @@ void pci_destroy_slot(struct pci_slot *slot)
 	dev_dbg(&slot->bus->dev, "dev %02x, dec refcount to %d\n",
 		slot->number, atomic_read(&slot->kobj.kref.refcount) - 1);
 
-	down_write(&pci_bus_sem);
+	mutex_lock(&pci_slot_mutex);
 	kobject_put(&slot->kobj);
-	up_write(&pci_bus_sem);
+	mutex_unlock(&pci_slot_mutex);
 }
 EXPORT_SYMBOL_GPL(pci_destroy_slot);
 

commit 58f86cc89c3372d3e61d5b71e5513ec5a0b02848
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Mon Mar 24 12:00:34 2014 +1030

    VERIFY_OCTAL_PERMISSIONS: stricter checking for sysfs perms.
    
    Summary of http://lkml.org/lkml/2014/3/14/363 :
    
      Ted: module_param(queue_depth, int, 444)
      Joe: 0444!
      Rusty: User perms >= group perms >= other perms?
      Joe: CLASS_ATTR, DEVICE_ATTR, SENSOR_ATTR and SENSOR_ATTR_2?
    
    Side effect of stricter permissions means removing the unnecessary
    S_IFREG from several callers.
    
    Note that the BUILD_BUG_ON_ZERO((perm) & 2) test was removed: a fair
    number of drivers fail this test, so that will be the debate for a
    future patch.
    
    Suggested-by: Joe Perches <joe@perches.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com> for drivers/pci/slot.c
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Miklos Szeredi <miklos@szeredi.hu>
    Cc: Mark Fasheh <mfasheh@suse.com>
    Cc: Joel Becker <jlbec@evilplan.org>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/drivers/pci/slot.c b/drivers/pci/slot.c
index 7dd62fa9d0bd..396c200b9ddb 100644
--- a/drivers/pci/slot.c
+++ b/drivers/pci/slot.c
@@ -116,11 +116,11 @@ static void pci_slot_release(struct kobject *kobj)
 }
 
 static struct pci_slot_attribute pci_slot_attr_address =
-	__ATTR(address, (S_IFREG | S_IRUGO), address_read_file, NULL);
+	__ATTR(address, S_IRUGO, address_read_file, NULL);
 static struct pci_slot_attribute pci_slot_attr_max_speed =
-	__ATTR(max_bus_speed, (S_IFREG | S_IRUGO), max_speed_read_file, NULL);
+	__ATTR(max_bus_speed, S_IRUGO, max_speed_read_file, NULL);
 static struct pci_slot_attribute pci_slot_attr_cur_speed =
-	__ATTR(cur_bus_speed, (S_IFREG | S_IRUGO), cur_speed_read_file, NULL);
+	__ATTR(cur_bus_speed, S_IRUGO, cur_speed_read_file, NULL);
 
 static struct attribute *pci_slot_default_attrs[] = {
 	&pci_slot_attr_address.attr,

commit 4ab44676064baeb6c7d807c0f627e07d29ce48e0
Author: Stephen Hemminger <stephen@networkplumber.org>
Date:   Fri Jan 10 15:41:35 2014 -0700

    PCI: Remove unused pci_renumber_slot()
    
    My philosophy is unused code is dead code.  And dead code is subject to bit
    rot and is a likely source of bugs.  Use it or lose it.
    
    This reverts part of f46753c5e354 ("PCI: introduce pci_slot") and
    d25b7c8d6ba2 ("PCI: rename pci_update_slot_number to pci_renumber_slot"),
    removing this interface:
    
        pci_renumber_slot()
    
    [bhelgaas: split to separate patch, add historical link from Alex]
    Link: http://lkml.kernel.org/r/20081009043140.8678.44164.stgit@bob.kio
    Signed-off-by: Stephen Hemminger <stephen@networkplumber.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Alex Chiang <achiang@canonical.com>

diff --git a/drivers/pci/slot.c b/drivers/pci/slot.c
index 448ca562d1f8..7dd62fa9d0bd 100644
--- a/drivers/pci/slot.c
+++ b/drivers/pci/slot.c
@@ -319,32 +319,6 @@ struct pci_slot *pci_create_slot(struct pci_bus *parent, int slot_nr,
 }
 EXPORT_SYMBOL_GPL(pci_create_slot);
 
-/**
- * pci_renumber_slot - update %struct pci_slot -> number
- * @slot: &struct pci_slot to update
- * @slot_nr: new number for slot
- *
- * The primary purpose of this interface is to allow callers who earlier
- * created a placeholder slot in pci_create_slot() by passing a -1 as
- * slot_nr, to update their %struct pci_slot with the correct @slot_nr.
- */
-void pci_renumber_slot(struct pci_slot *slot, int slot_nr)
-{
-	struct pci_slot *tmp;
-
-	down_write(&pci_bus_sem);
-
-	list_for_each_entry(tmp, &slot->bus->slots, list) {
-		WARN_ON(tmp->number == slot_nr);
-		goto out;
-	}
-
-	slot->number = slot_nr;
-out:
-	up_write(&pci_bus_sem);
-}
-EXPORT_SYMBOL_GPL(pci_renumber_slot);
-
 /**
  * pci_destroy_slot - decrement refcount for physical PCI slot
  * @slot: struct pci_slot to decrement

commit f7625980f5820edd1a73536e1a03bcbc1f889fec
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Nov 14 11:28:18 2013 -0700

    PCI: Fix whitespace, capitalization, and spelling errors
    
    Fix whitespace, capitalization, and spelling errors.  No functional change.
    I know "busses" is not an error, but "buses" was more common, so I used it
    consistently.
    
    Signed-off-by: Marta Rybczynska <rybczynska@gmail.com> (pci_reset_bridge_secondary_bus())
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/slot.c b/drivers/pci/slot.c
index c1e9284a677b..448ca562d1f8 100644
--- a/drivers/pci/slot.c
+++ b/drivers/pci/slot.c
@@ -53,7 +53,7 @@ static ssize_t address_read_file(struct pci_slot *slot, char *buf)
 static const char *pci_bus_speed_strings[] = {
 	"33 MHz PCI",		/* 0x00 */
 	"66 MHz PCI",		/* 0x01 */
-	"66 MHz PCI-X", 	/* 0x02 */
+	"66 MHz PCI-X",		/* 0x02 */
 	"100 MHz PCI-X",	/* 0x03 */
 	"133 MHz PCI-X",	/* 0x04 */
 	NULL,			/* 0x05 */

commit 9fc9eea09f518b9bbdc0a14ef668698c913ba614
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Apr 12 11:35:40 2013 -0600

    PCI: Warn about failures instead of "must_check" functions
    
    These places capture return values to avoid "must_check" warnings,
    but we didn't *do* anything with the return values, which causes
    "set but not used" warnings.  We might as well do something instead
    of just trying to evade the "must_check" warnings.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/slot.c b/drivers/pci/slot.c
index ac6412fb8d6f..c1e9284a677b 100644
--- a/drivers/pci/slot.c
+++ b/drivers/pci/slot.c
@@ -377,14 +377,17 @@ void pci_hp_create_module_link(struct pci_slot *pci_slot)
 {
 	struct hotplug_slot *slot = pci_slot->hotplug;
 	struct kobject *kobj = NULL;
-	int no_warn;
+	int ret;
 
 	if (!slot || !slot->ops)
 		return;
 	kobj = kset_find_obj(module_kset, slot->ops->mod_name);
 	if (!kobj)
 		return;
-	no_warn = sysfs_create_link(&pci_slot->kobj, kobj, "module");
+	ret = sysfs_create_link(&pci_slot->kobj, kobj, "module");
+	if (ret)
+		dev_err(&pci_slot->bus->dev, "Error creating sysfs link (%d)\n",
+			ret);
 	kobject_put(kobj);
 }
 EXPORT_SYMBOL_GPL(pci_hp_create_module_link);

commit eefa9cfc891d18aa83744353d2a3fbe95a86ee2d
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Fri May 27 09:42:30 2011 -0400

    pci: add module.h to files implicitly relying on its presence.
    
    These were getting module.h implicitly from device.h but we want
    to clean that up, so we fix it here to avoid things like:
    
    pci/slot.c: In function ‘pci_hp_create_module_link’:
    pci/slot.c:383: error: ‘module_kset’ undeclared (first use in this function)
    
    Similarly, rpadlpar_core.c is modular, so add module.h to its includes.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/drivers/pci/slot.c b/drivers/pci/slot.c
index 968cfea04f74..ac6412fb8d6f 100644
--- a/drivers/pci/slot.c
+++ b/drivers/pci/slot.c
@@ -7,6 +7,7 @@
 
 #include <linux/kobject.h>
 #include <linux/slab.h>
+#include <linux/module.h>
 #include <linux/pci.h>
 #include <linux/err.h>
 #include "pci.h"

commit 17134d96735115644cc2f0e2b1bab51ca6e3ab95
Author: Stephen Hemminger <shemminger@vyatta.com>
Date:   Tue Aug 31 15:25:55 2010 -0700

    PCI: bus speed strings should be const
    
    Signed-off-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/slot.c b/drivers/pci/slot.c
index 659eaa0fc48f..968cfea04f74 100644
--- a/drivers/pci/slot.c
+++ b/drivers/pci/slot.c
@@ -49,7 +49,7 @@ static ssize_t address_read_file(struct pci_slot *slot, char *buf)
 }
 
 /* these strings match up with the values in pci_bus_speed */
-static char *pci_bus_speed_strings[] = {
+static const char *pci_bus_speed_strings[] = {
 	"33 MHz PCI",		/* 0x00 */
 	"66 MHz PCI",		/* 0x01 */
 	"66 MHz PCI-X", 	/* 0x02 */

commit 3be434f0244ee059432f92de7e891ee514f41738
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Fri Jun 11 13:08:37 2010 -0700

    Revert "PCI: create function symlinks in /sys/bus/pci/slots/N/"
    
    This reverts commit 75568f8094eb0333e9c2109b23cbc8b82d318a3c.
    
    Since they're just a convenience anyway, remove these symlinks since
    they're causing duplicate filename errors in the wild.
    
    Acked-by: Alex Chiang <achiang@canonical.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/slot.c b/drivers/pci/slot.c
index e0189cf7c558..659eaa0fc48f 100644
--- a/drivers/pci/slot.c
+++ b/drivers/pci/slot.c
@@ -97,50 +97,6 @@ static ssize_t cur_speed_read_file(struct pci_slot *slot, char *buf)
 	return bus_speed_read(slot->bus->cur_bus_speed, buf);
 }
 
-static void remove_sysfs_files(struct pci_slot *slot)
-{
-	char func[10];
-	struct list_head *tmp;
-
-	list_for_each(tmp, &slot->bus->devices) {
-		struct pci_dev *dev = pci_dev_b(tmp);
-		if (PCI_SLOT(dev->devfn) != slot->number)
-			continue;
-		sysfs_remove_link(&dev->dev.kobj, "slot");
-
-		snprintf(func, 10, "function%d", PCI_FUNC(dev->devfn));
-		sysfs_remove_link(&slot->kobj, func);
-	}
-}
-
-static int create_sysfs_files(struct pci_slot *slot)
-{
-	int result;
-	char func[10];
-	struct list_head *tmp;
-
-	list_for_each(tmp, &slot->bus->devices) {
-		struct pci_dev *dev = pci_dev_b(tmp);
-		if (PCI_SLOT(dev->devfn) != slot->number)
-			continue;
-
-		result = sysfs_create_link(&dev->dev.kobj, &slot->kobj, "slot");
-		if (result)
-			goto fail;
-
-		snprintf(func, 10, "function%d", PCI_FUNC(dev->devfn));
-		result = sysfs_create_link(&slot->kobj, &dev->dev.kobj, func);
-		if (result)
-			goto fail;
-	}
-
-	return 0;
-
-fail:
-	remove_sysfs_files(slot);
-	return result;
-}
-
 static void pci_slot_release(struct kobject *kobj)
 {
 	struct pci_dev *dev;
@@ -153,8 +109,6 @@ static void pci_slot_release(struct kobject *kobj)
 		if (PCI_SLOT(dev->devfn) == slot->number)
 			dev->slot = NULL;
 
-	remove_sysfs_files(slot);
-
 	list_del(&slot->list);
 
 	kfree(slot);
@@ -346,8 +300,6 @@ struct pci_slot *pci_create_slot(struct pci_bus *parent, int slot_nr,
 	INIT_LIST_HEAD(&slot->list);
 	list_add(&slot->list, &parent->slots);
 
-	create_sysfs_files(slot);
-
 	list_for_each_entry(dev, &parent->devices, bus_list)
 		if (PCI_SLOT(dev->devfn) == slot_nr)
 			dev->slot = slot;

commit 75568f8094eb0333e9c2109b23cbc8b82d318a3c
Author: Alex Chiang <achiang@hp.com>
Date:   Mon Mar 8 10:24:29 2010 -0700

    PCI: create function symlinks in /sys/bus/pci/slots/N/
    
    Create convenience symlinks in sysfs, linking slots to device
    functions, and vice versa. These links make it easier for users to
    figure out which devices actually live in what slots.
    
    For example:
    
    sapphire:/sys/bus/pci/slots # ls
    1  10  2  3  4  5  6  7  8  9
    
    sapphire:/sys/bus/pci/slots # ls -l 3
    total 0
    -r--r--r-- 1 root root 65536 Aug 18 14:10 address
    lrwxrwxrwx 1 root root     0 Aug 18 14:10 function0 ->
    ../../../../devices/pci0000:23/0000:23:01.0
    lrwxrwxrwx 1 root root     0 Aug 18 14:10 function1 ->
    ../../../../devices/pci0000:23/0000:23:01.1
    
    sapphire:/sys/bus/pci/slots # ls -l 3/function0/slot
    lrwxrwxrwx 1 root root 0 Aug 18 14:13 3/function0/slot ->
    ../../../bus/pci/slots/3
    
    The original form of this patch was written by Matthew Wilcox,
    and was enhanced to include links from the sysfs slots/ directory
    pointing back at the device functions.
    
    Cc: willy@linux.intel.com
    Signed-off-by: Alex Chiang <achiang@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/slot.c b/drivers/pci/slot.c
index 659eaa0fc48f..e0189cf7c558 100644
--- a/drivers/pci/slot.c
+++ b/drivers/pci/slot.c
@@ -97,6 +97,50 @@ static ssize_t cur_speed_read_file(struct pci_slot *slot, char *buf)
 	return bus_speed_read(slot->bus->cur_bus_speed, buf);
 }
 
+static void remove_sysfs_files(struct pci_slot *slot)
+{
+	char func[10];
+	struct list_head *tmp;
+
+	list_for_each(tmp, &slot->bus->devices) {
+		struct pci_dev *dev = pci_dev_b(tmp);
+		if (PCI_SLOT(dev->devfn) != slot->number)
+			continue;
+		sysfs_remove_link(&dev->dev.kobj, "slot");
+
+		snprintf(func, 10, "function%d", PCI_FUNC(dev->devfn));
+		sysfs_remove_link(&slot->kobj, func);
+	}
+}
+
+static int create_sysfs_files(struct pci_slot *slot)
+{
+	int result;
+	char func[10];
+	struct list_head *tmp;
+
+	list_for_each(tmp, &slot->bus->devices) {
+		struct pci_dev *dev = pci_dev_b(tmp);
+		if (PCI_SLOT(dev->devfn) != slot->number)
+			continue;
+
+		result = sysfs_create_link(&dev->dev.kobj, &slot->kobj, "slot");
+		if (result)
+			goto fail;
+
+		snprintf(func, 10, "function%d", PCI_FUNC(dev->devfn));
+		result = sysfs_create_link(&slot->kobj, &dev->dev.kobj, func);
+		if (result)
+			goto fail;
+	}
+
+	return 0;
+
+fail:
+	remove_sysfs_files(slot);
+	return result;
+}
+
 static void pci_slot_release(struct kobject *kobj)
 {
 	struct pci_dev *dev;
@@ -109,6 +153,8 @@ static void pci_slot_release(struct kobject *kobj)
 		if (PCI_SLOT(dev->devfn) == slot->number)
 			dev->slot = NULL;
 
+	remove_sysfs_files(slot);
+
 	list_del(&slot->list);
 
 	kfree(slot);
@@ -300,6 +346,8 @@ struct pci_slot *pci_create_slot(struct pci_bus *parent, int slot_nr,
 	INIT_LIST_HEAD(&slot->list);
 	list_add(&slot->list, &parent->slots);
 
+	create_sysfs_files(slot);
+
 	list_for_each_entry(dev, &parent->devices, bus_list)
 		if (PCI_SLOT(dev->devfn) == slot_nr)
 			dev->slot = slot;

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/pci/slot.c b/drivers/pci/slot.c
index f75a44d37fbe..659eaa0fc48f 100644
--- a/drivers/pci/slot.c
+++ b/drivers/pci/slot.c
@@ -6,6 +6,7 @@
  */
 
 #include <linux/kobject.h>
+#include <linux/slab.h>
 #include <linux/pci.h>
 #include <linux/err.h>
 #include "pci.h"

commit 52cf25d0ab7f78eeecc59ac652ed5090f69b619e
Author: Emese Revfy <re.emese@gmail.com>
Date:   Tue Jan 19 02:58:23 2010 +0100

    Driver core: Constify struct sysfs_ops in struct kobj_type
    
    Constify struct sysfs_ops.
    
    This is part of the ops structure constification
    effort started by Arjan van de Ven et al.
    
    Benefits of this constification:
    
     * prevents modification of data that is shared
       (referenced) by many other structure instances
       at runtime
    
     * detects/prevents accidental (but not intentional)
       modification attempts on archs that enforce
       read-only kernel data at runtime
    
     * potentially better optimized code as the compiler
       can assume that the const data cannot be changed
    
     * the compiler/linker move const data into .rodata
       and therefore exclude them from false sharing
    
    Signed-off-by: Emese Revfy <re.emese@gmail.com>
    Acked-by: David Teigland <teigland@redhat.com>
    Acked-by: Matt Domsch <Matt_Domsch@dell.com>
    Acked-by: Maciej Sosnowski <maciej.sosnowski@intel.com>
    Acked-by: Hans J. Koch <hjk@linutronix.de>
    Acked-by: Pekka Enberg <penberg@cs.helsinki.fi>
    Acked-by: Jens Axboe <jens.axboe@oracle.com>
    Acked-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/slot.c b/drivers/pci/slot.c
index 49c9e6c9779a..f75a44d37fbe 100644
--- a/drivers/pci/slot.c
+++ b/drivers/pci/slot.c
@@ -29,7 +29,7 @@ static ssize_t pci_slot_attr_store(struct kobject *kobj,
 	return attribute->store ? attribute->store(slot, buf, len) : -EIO;
 }
 
-static struct sysfs_ops pci_slot_sysfs_ops = {
+static const struct sysfs_ops pci_slot_sysfs_ops = {
 	.show = pci_slot_attr_show,
 	.store = pci_slot_attr_store,
 };

commit 9dfd97fe12f79ec8b68feb63912a4ef2f31f571a
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Sun Dec 13 08:11:35 2009 -0500

    PCI: Add support for reporting PCIe 3.0 speeds
    
    Add the 8.0 GT/s speed.
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/slot.c b/drivers/pci/slot.c
index c7260d4e339b..49c9e6c9779a 100644
--- a/drivers/pci/slot.c
+++ b/drivers/pci/slot.c
@@ -71,6 +71,7 @@ static char *pci_bus_speed_strings[] = {
 	"133 MHz PCI-X 533",	/* 0x13 */
 	"2.5 GT/s PCIe",	/* 0x14 */
 	"5.0 GT/s PCIe",	/* 0x15 */
+	"8.0 GT/s PCIe",	/* 0x16 */
 };
 
 static ssize_t bus_speed_read(enum pci_bus_speed speed, char *buf)

commit 45b4cdd57ef0e57555b2ab61b584784819b39365
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Sun Dec 13 08:11:34 2009 -0500

    PCI: Add support for AGP in cur/max bus speed
    
    Take advantage of some gaps in the table to fit in support for AGP speeds.
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/slot.c b/drivers/pci/slot.c
index 6f6b8d24786a..c7260d4e339b 100644
--- a/drivers/pci/slot.c
+++ b/drivers/pci/slot.c
@@ -61,11 +61,11 @@ static char *pci_bus_speed_strings[] = {
 	"66 MHz PCI-X 266",	/* 0x09 */
 	"100 MHz PCI-X 266",	/* 0x0a */
 	"133 MHz PCI-X 266",	/* 0x0b */
-	NULL,			/* 0x0c */
-	NULL,			/* 0x0d */
-	NULL,			/* 0x0e */
-	NULL,			/* 0x0f */
-	NULL,			/* 0x10 */
+	"Unknown AGP",		/* 0x0c */
+	"1x AGP",		/* 0x0d */
+	"2x AGP",		/* 0x0e */
+	"4x AGP",		/* 0x0f */
+	"8x AGP",		/* 0x10 */
 	"66 MHz PCI-X 533",	/* 0x11 */
 	"100 MHz PCI-X 533",	/* 0x12 */
 	"133 MHz PCI-X 533",	/* 0x13 */

commit 3749c51ac6c1560aa1cb1520066bed84c6f8152a
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Sun Dec 13 08:11:32 2009 -0500

    PCI: Make current and maximum bus speeds part of the PCI core
    
    Move the max_bus_speed and cur_bus_speed into the pci_bus.  Expose the
    values through the PCI slot driver instead of the hotplug slot driver.
    Update all the hotplug drivers to use the pci_bus instead of their own
    data structures.
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/slot.c b/drivers/pci/slot.c
index 8c02b6c53bdb..6f6b8d24786a 100644
--- a/drivers/pci/slot.c
+++ b/drivers/pci/slot.c
@@ -47,6 +47,54 @@ static ssize_t address_read_file(struct pci_slot *slot, char *buf)
 				slot->number);
 }
 
+/* these strings match up with the values in pci_bus_speed */
+static char *pci_bus_speed_strings[] = {
+	"33 MHz PCI",		/* 0x00 */
+	"66 MHz PCI",		/* 0x01 */
+	"66 MHz PCI-X", 	/* 0x02 */
+	"100 MHz PCI-X",	/* 0x03 */
+	"133 MHz PCI-X",	/* 0x04 */
+	NULL,			/* 0x05 */
+	NULL,			/* 0x06 */
+	NULL,			/* 0x07 */
+	NULL,			/* 0x08 */
+	"66 MHz PCI-X 266",	/* 0x09 */
+	"100 MHz PCI-X 266",	/* 0x0a */
+	"133 MHz PCI-X 266",	/* 0x0b */
+	NULL,			/* 0x0c */
+	NULL,			/* 0x0d */
+	NULL,			/* 0x0e */
+	NULL,			/* 0x0f */
+	NULL,			/* 0x10 */
+	"66 MHz PCI-X 533",	/* 0x11 */
+	"100 MHz PCI-X 533",	/* 0x12 */
+	"133 MHz PCI-X 533",	/* 0x13 */
+	"2.5 GT/s PCIe",	/* 0x14 */
+	"5.0 GT/s PCIe",	/* 0x15 */
+};
+
+static ssize_t bus_speed_read(enum pci_bus_speed speed, char *buf)
+{
+	const char *speed_string;
+
+	if (speed < ARRAY_SIZE(pci_bus_speed_strings))
+		speed_string = pci_bus_speed_strings[speed];
+	else
+		speed_string = "Unknown";
+
+	return sprintf(buf, "%s\n", speed_string);
+}
+
+static ssize_t max_speed_read_file(struct pci_slot *slot, char *buf)
+{
+	return bus_speed_read(slot->bus->max_bus_speed, buf);
+}
+
+static ssize_t cur_speed_read_file(struct pci_slot *slot, char *buf)
+{
+	return bus_speed_read(slot->bus->cur_bus_speed, buf);
+}
+
 static void pci_slot_release(struct kobject *kobj)
 {
 	struct pci_dev *dev;
@@ -66,9 +114,15 @@ static void pci_slot_release(struct kobject *kobj)
 
 static struct pci_slot_attribute pci_slot_attr_address =
 	__ATTR(address, (S_IFREG | S_IRUGO), address_read_file, NULL);
+static struct pci_slot_attribute pci_slot_attr_max_speed =
+	__ATTR(max_bus_speed, (S_IFREG | S_IRUGO), max_speed_read_file, NULL);
+static struct pci_slot_attribute pci_slot_attr_cur_speed =
+	__ATTR(cur_bus_speed, (S_IFREG | S_IRUGO), cur_speed_read_file, NULL);
 
 static struct attribute *pci_slot_default_attrs[] = {
 	&pci_slot_attr_address.attr,
+	&pci_slot_attr_max_speed.attr,
+	&pci_slot_attr_cur_speed.attr,
 	NULL,
 };
 

commit 503998ca4a295f7da233689850ba4b9d13cf41e7
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Wed Jun 24 09:18:14 2009 -0700

    PCI: fix kernel-doc warnings
    
    Add documentation for missing parameters in PCI hotplug code.
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/slot.c b/drivers/pci/slot.c
index eddb0748b0ea..8c02b6c53bdb 100644
--- a/drivers/pci/slot.c
+++ b/drivers/pci/slot.c
@@ -311,7 +311,7 @@ EXPORT_SYMBOL_GPL(pci_destroy_slot);
 #include <linux/pci_hotplug.h>
 /**
  * pci_hp_create_link - create symbolic link to the hotplug driver module.
- * @slot: struct pci_slot
+ * @pci_slot: struct pci_slot
  *
  * Helper function for pci_hotplug_core.c to create symbolic link to
  * the hotplug driver module.
@@ -334,7 +334,7 @@ EXPORT_SYMBOL_GPL(pci_hp_create_module_link);
 
 /**
  * pci_hp_remove_link - remove symbolic link to the hotplug driver module.
- * @slot: struct pci_slot
+ * @pci_slot: struct pci_slot
  *
  * Helper function for pci_hotplug_core.c to remove symbolic link to
  * the hotplug driver module.

commit c825bc94c8c1908750ab20413eb639c6be029e2d
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Tue Jun 16 11:01:25 2009 +0900

    PCI hotplug: create symlink to hotplug driver module
    
    Create symbolic link to hotplug driver module in the PCI slot
    directory (/sys/bus/pci/slots/<SLOT#>). In the past, we need to load
    hotplug drivers one by one to identify the hotplug driver that handles
    the slot, and it was very inconvenient especially for trouble shooting.
    With this change, we can easily identify the hotplug driver.
    
    Signed-off-by: Taku Izumi <izumi.taku@jp.fujitsu.com>
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Reviewed-by: Alex Chiang <achiang@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/slot.c b/drivers/pci/slot.c
index fe95ce20bcbd..eddb0748b0ea 100644
--- a/drivers/pci/slot.c
+++ b/drivers/pci/slot.c
@@ -307,6 +307,45 @@ void pci_destroy_slot(struct pci_slot *slot)
 }
 EXPORT_SYMBOL_GPL(pci_destroy_slot);
 
+#if defined(CONFIG_HOTPLUG_PCI) || defined(CONFIG_HOTPLUG_PCI_MODULE)
+#include <linux/pci_hotplug.h>
+/**
+ * pci_hp_create_link - create symbolic link to the hotplug driver module.
+ * @slot: struct pci_slot
+ *
+ * Helper function for pci_hotplug_core.c to create symbolic link to
+ * the hotplug driver module.
+ */
+void pci_hp_create_module_link(struct pci_slot *pci_slot)
+{
+	struct hotplug_slot *slot = pci_slot->hotplug;
+	struct kobject *kobj = NULL;
+	int no_warn;
+
+	if (!slot || !slot->ops)
+		return;
+	kobj = kset_find_obj(module_kset, slot->ops->mod_name);
+	if (!kobj)
+		return;
+	no_warn = sysfs_create_link(&pci_slot->kobj, kobj, "module");
+	kobject_put(kobj);
+}
+EXPORT_SYMBOL_GPL(pci_hp_create_module_link);
+
+/**
+ * pci_hp_remove_link - remove symbolic link to the hotplug driver module.
+ * @slot: struct pci_slot
+ *
+ * Helper function for pci_hotplug_core.c to remove symbolic link to
+ * the hotplug driver module.
+ */
+void pci_hp_remove_module_link(struct pci_slot *pci_slot)
+{
+	sysfs_remove_link(&pci_slot->kobj, "module");
+}
+EXPORT_SYMBOL_GPL(pci_hp_remove_module_link);
+#endif
+
 static int pci_slot_init(void)
 {
 	struct kset *pci_bus_kset;

commit cffb2fafb726c898fec1c5ae33717741f94fda83
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Fri Apr 10 15:17:50 2009 -0700

    docbooks: add/fix PCI kernel-doc
    
    Add drivers/pci/*.c source files to DocBook/kernel-api.tmpl
    and update those pci/*.c source files that need kernel-doc fixes.
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/slot.c b/drivers/pci/slot.c
index 21189447e545..fe95ce20bcbd 100644
--- a/drivers/pci/slot.c
+++ b/drivers/pci/slot.c
@@ -264,8 +264,8 @@ EXPORT_SYMBOL_GPL(pci_create_slot);
 
 /**
  * pci_renumber_slot - update %struct pci_slot -> number
- * @slot - %struct pci_slot to update
- * @slot_nr - new number for slot
+ * @slot: &struct pci_slot to update
+ * @slot_nr: new number for slot
  *
  * The primary purpose of this interface is to allow callers who earlier
  * created a placeholder slot in pci_create_slot() by passing a -1 as

commit 62795041418dd63cd9ff6ff7bbdf1d1c513c189b
Author: Alex Chiang <achiang@hp.com>
Date:   Wed Feb 4 11:25:22 2009 -0700

    PCI: enhance physical slot debug information
    
    Convert usages of pr_debug to dev_dbg and add physical slot name.
    
    Note that we use dev_dbg on the struct pci_bus and still manually
    print out the PCI slot number (instead of calling dev_dbg on a
    pci_dev) because a struct pci_bus with empty physical slots will
    not have any pci_devs.
    
    Reviewed-by: Andrew Patterson <andrew.patterson@hp.com>
    Signed-off-by: Alex Chiang <achiang@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/slot.c b/drivers/pci/slot.c
index 5a8ccb4f604d..21189447e545 100644
--- a/drivers/pci/slot.c
+++ b/drivers/pci/slot.c
@@ -1,8 +1,8 @@
 /*
  * drivers/pci/slot.c
  * Copyright (C) 2006 Matthew Wilcox <matthew@wil.cx>
- * Copyright (C) 2006-2008 Hewlett-Packard Development Company, L.P.
- * 	Alex Chiang <achiang@hp.com>
+ * Copyright (C) 2006-2009 Hewlett-Packard Development Company, L.P.
+ *	Alex Chiang <achiang@hp.com>
  */
 
 #include <linux/kobject.h>
@@ -52,8 +52,8 @@ static void pci_slot_release(struct kobject *kobj)
 	struct pci_dev *dev;
 	struct pci_slot *slot = to_pci_slot(kobj);
 
-	pr_debug("%s: releasing pci_slot on %x:%d\n", __func__,
-		 slot->bus->number, slot->number);
+	dev_dbg(&slot->bus->dev, "dev %02x, released physical slot %s\n",
+		slot->number, pci_slot_name(slot));
 
 	list_for_each_entry(dev, &slot->bus->devices, bus_list)
 		if (PCI_SLOT(dev->devfn) == slot->number)
@@ -248,9 +248,8 @@ struct pci_slot *pci_create_slot(struct pci_bus *parent, int slot_nr,
 		if (PCI_SLOT(dev->devfn) == slot_nr)
 			dev->slot = slot;
 
-	/* Don't care if debug printk has a -1 for slot_nr */
-	pr_debug("%s: created pci_slot on %04x:%02x:%02x\n",
-		 __func__, pci_domain_nr(parent), parent->number, slot_nr);
+	dev_dbg(&parent->dev, "dev %02x, created physical slot %s\n",
+		slot_nr, pci_slot_name(slot));
 
 out:
 	kfree(slot_name);
@@ -299,9 +298,8 @@ EXPORT_SYMBOL_GPL(pci_renumber_slot);
  */
 void pci_destroy_slot(struct pci_slot *slot)
 {
-	pr_debug("%s: dec refcount to %d on %04x:%02x:%02x\n", __func__,
-		 atomic_read(&slot->kobj.kref.refcount) - 1,
-		 pci_domain_nr(slot->bus), slot->bus->number, slot->number);
+	dev_dbg(&slot->bus->dev, "dev %02x, dec refcount to %d\n",
+		slot->number, atomic_read(&slot->kobj.kref.refcount) - 1);
 
 	down_write(&pci_bus_sem);
 	kobject_put(&slot->kobj);

commit 3b5dd45e947ecd21491e1658fba7bb4bc4a54995
Author: Alex Chiang <achiang@hp.com>
Date:   Mon Dec 1 18:17:21 2008 -0700

    PCI: stop leaking 'slot_name' in pci_create_slot
    
    In pci_create_slot(), the local variable 'slot_name' is allocated by
    make_slot_name(), but never freed. We never use it after passing it to
    the kobject core, so we should free it upon function exit.
    
    Cc: stable@kernel.org
    Signed-off-by: Alex Chiang <achiang@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/slot.c b/drivers/pci/slot.c
index 4dd1c3e157ae..5a8ccb4f604d 100644
--- a/drivers/pci/slot.c
+++ b/drivers/pci/slot.c
@@ -253,6 +253,7 @@ struct pci_slot *pci_create_slot(struct pci_bus *parent, int slot_nr,
 		 __func__, pci_domain_nr(parent), parent->number, slot_nr);
 
 out:
+	kfree(slot_name);
 	up_write(&pci_bus_sem);
 	return slot;
 err:

commit 0ad772ec464d3fcf9d210836b97e654f393606c4
Author: Alex Chiang <achiang@hp.com>
Date:   Mon Oct 20 17:41:07 2008 -0600

    PCI, PCI Hotplug: introduce slot_name helpers
    
    In preparation for cleaning up the various hotplug drivers
    such that they don't have to manage their own 'name' parameters
    anymore, we provide the following convenience functions:
    
            pci_slot_name()
            hotplug_slot_name()
    
    These helpers will be used by individual hotplug drivers.
    
    Cc: kristen.c.accardi@intel.com
    Cc: matthew@wil.cx
    Acked-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Alex Chiang <achiang@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/slot.c b/drivers/pci/slot.c
index b6ee352ae459..4dd1c3e157ae 100644
--- a/drivers/pci/slot.c
+++ b/drivers/pci/slot.c
@@ -121,7 +121,7 @@ static int rename_slot(struct pci_slot *slot, const char *name)
 	int result = 0;
 	char *slot_name;
 
-	if (strcmp(kobject_name(&slot->kobj), name) == 0)
+	if (strcmp(pci_slot_name(slot), name) == 0)
 		return result;
 
 	slot_name = make_slot_name(name);

commit 5fe6cc60680d29740b85278e17a002fa27b7e642
Author: Alex Chiang <achiang@hp.com>
Date:   Mon Oct 20 17:41:02 2008 -0600

    PCI: prevent duplicate slot names
    
    Prevent callers of pci_create_slot() from registering slots with
    duplicate names. This condition occurs most often when PCI hotplug
    drivers are loaded on platforms with broken firmware that assigns
    identical names to multiple slots.
    
    We now rename these duplicate slots on behalf of the user.
    
    If firmware assigns the name N to multiple slots, then:
    
            The first registered slot is assigned N
            The second registered slot is assigned N-1
            The third registered slot is assigned N-2
            etc.
    
    This is the permanent fix mentioned in earlier commits d6a9e9b4 and
    167e782e (shpchp/pciehp: Rename duplicate slot name...).
    
    We take advantage of the new 'hotplug' parameter in pci_create_slot()
    to prevent a slot create/rename race between hotplug drivers and
    detection drivers.
    
            Scenario A:
            hotplug driver                  detection driver
            --------------                  ----------------
            pci_create_slot(hotplug=set)
                                            pci_create_slot(hotplug=NULL)
    
    The hotplug driver creates the slot with its desired name, and then
    releases the semaphore. Now, the detection driver tries to create
    the same slot, but it already exists. We don't care about renaming,
    so return the existing slot.
    
            Scenario B:
            hotplug driver                  detection driver
            --------------                  ----------------
                                            pci_create_slot(hotplug=NULL)
            pci_create_slot(hotplug=set)
    
    The detection driver creates the slot with name "X". Then the hotplug
    driver tries to create the same slot, but wants the name "Y" instead.
    We detect that we're trying to create the same slot and that we also
    want a rename, so rename the slot to "Y" and return.
    
            Scenario C:
            hotplug driver                  hotplug driver
            --------------                  ----------------
            pci_create_slot(hotplug=set)
                                            pci_create_slot(hotplug=set)
    
    Two separate hotplug drivers are attempting to claim the slot and
    are passing valid hotplug_slot args to pci_create_slot(). We detect
    that the slot already has a ->hotplug callback, prevent a rename,
    and return -EBUSY.
    
    Cc: kristen.c.accardi@intel.com
    Cc: matthew@wil.cx
    Acked-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Alex Chiang <achiang@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/slot.c b/drivers/pci/slot.c
index 0e009c3ba5fd..b6ee352ae459 100644
--- a/drivers/pci/slot.c
+++ b/drivers/pci/slot.c
@@ -78,6 +78,77 @@ static struct kobj_type pci_slot_ktype = {
 	.default_attrs = pci_slot_default_attrs,
 };
 
+static char *make_slot_name(const char *name)
+{
+	char *new_name;
+	int len, max, dup;
+
+	new_name = kstrdup(name, GFP_KERNEL);
+	if (!new_name)
+		return NULL;
+
+	/*
+	 * Make sure we hit the realloc case the first time through the
+	 * loop.  'len' will be strlen(name) + 3 at that point which is
+	 * enough space for "name-X" and the trailing NUL.
+	 */
+	len = strlen(name) + 2;
+	max = 1;
+	dup = 1;
+
+	for (;;) {
+		struct kobject *dup_slot;
+		dup_slot = kset_find_obj(pci_slots_kset, new_name);
+		if (!dup_slot)
+			break;
+		kobject_put(dup_slot);
+		if (dup == max) {
+			len++;
+			max *= 10;
+			kfree(new_name);
+			new_name = kmalloc(len, GFP_KERNEL);
+			if (!new_name)
+				break;
+		}
+		sprintf(new_name, "%s-%d", name, dup++);
+	}
+
+	return new_name;
+}
+
+static int rename_slot(struct pci_slot *slot, const char *name)
+{
+	int result = 0;
+	char *slot_name;
+
+	if (strcmp(kobject_name(&slot->kobj), name) == 0)
+		return result;
+
+	slot_name = make_slot_name(name);
+	if (!slot_name)
+		return -ENOMEM;
+
+	result = kobject_rename(&slot->kobj, slot_name);
+	kfree(slot_name);
+
+	return result;
+}
+
+static struct pci_slot *get_slot(struct pci_bus *parent, int slot_nr)
+{
+	struct pci_slot *slot;
+	/*
+	 * We already hold pci_bus_sem so don't worry
+	 */
+	list_for_each_entry(slot, &parent->slots, list)
+		if (slot->number == slot_nr) {
+			kobject_get(&slot->kobj);
+			return slot;
+		}
+
+	return NULL;
+}
+
 /**
  * pci_create_slot - create or increment refcount for physical PCI slot
  * @parent: struct pci_bus of parent bridge
@@ -90,7 +161,17 @@ static struct kobj_type pci_slot_ktype = {
  * either return a new &struct pci_slot to the caller, or if the pci_slot
  * already exists, its refcount will be incremented.
  *
- * Slots are uniquely identified by a @pci_bus, @slot_nr, @name tuple.
+ * Slots are uniquely identified by a @pci_bus, @slot_nr tuple.
+ *
+ * There are known platforms with broken firmware that assign the same
+ * name to multiple slots. Workaround these broken platforms by renaming
+ * the slots on behalf of the caller. If firmware assigns name N to
+ * multiple slots:
+ *
+ * The first slot is assigned N
+ * The second slot is assigned N-1
+ * The third slot is assigned N-2
+ * etc.
  *
  * Placeholder slots:
  * In most cases, @pci_bus, @slot_nr will be sufficient to uniquely identify
@@ -99,62 +180,67 @@ static struct kobj_type pci_slot_ktype = {
  * the slot. In this scenario, the caller may pass -1 for @slot_nr.
  *
  * The following semantics are imposed when the caller passes @slot_nr ==
- * -1. First, the check for existing %struct pci_slot is skipped, as the
- * caller may know about several unpopulated slots on a given %struct
- * pci_bus, and each slot would have a @slot_nr of -1.  Uniqueness for
- * these slots is then determined by the @name parameter. We expect
- * kobject_init_and_add() to warn us if the caller attempts to create
- * multiple slots with the same name. The other change in semantics is
+ * -1. First, we no longer check for an existing %struct pci_slot, as there
+ * may be many slots with @slot_nr of -1.  The other change in semantics is
  * user-visible, which is the 'address' parameter presented in sysfs will
  * consist solely of a dddd:bb tuple, where dddd is the PCI domain of the
  * %struct pci_bus and bb is the bus number. In other words, the devfn of
  * the 'placeholder' slot will not be displayed.
  */
-
 struct pci_slot *pci_create_slot(struct pci_bus *parent, int slot_nr,
 				 const char *name,
 				 struct hotplug_slot *hotplug)
 {
 	struct pci_dev *dev;
 	struct pci_slot *slot;
-	int err;
+	int err = 0;
+	char *slot_name = NULL;
 
 	down_write(&pci_bus_sem);
 
 	if (slot_nr == -1)
 		goto placeholder;
 
-	/* If we've already created this slot, bump refcount and return. */
-	list_for_each_entry(slot, &parent->slots, list) {
-		if (slot->number == slot_nr) {
-			kobject_get(&slot->kobj);
-			pr_debug("%s: inc refcount to %d on %04x:%02x:%02x\n",
-				 __func__,
-				 atomic_read(&slot->kobj.kref.refcount),
-				 pci_domain_nr(parent), parent->number,
-				 slot_nr);
-			goto out;
+	/*
+	 * Hotplug drivers are allowed to rename an existing slot,
+	 * but only if not already claimed.
+	 */
+	slot = get_slot(parent, slot_nr);
+	if (slot) {
+		if (hotplug) {
+			if ((err = slot->hotplug ? -EBUSY : 0)
+			     || (err = rename_slot(slot, name))) {
+				kobject_put(&slot->kobj);
+				slot = NULL;
+				goto err;
+			}
 		}
+		goto out;
 	}
 
 placeholder:
 	slot = kzalloc(sizeof(*slot), GFP_KERNEL);
 	if (!slot) {
-		slot = ERR_PTR(-ENOMEM);
-		goto out;
+		err = -ENOMEM;
+		goto err;
 	}
 
 	slot->bus = parent;
 	slot->number = slot_nr;
 
 	slot->kobj.kset = pci_slots_kset;
-	err = kobject_init_and_add(&slot->kobj, &pci_slot_ktype, NULL,
-				   "%s", name);
-	if (err) {
-		printk(KERN_ERR "Unable to register kobject %s\n", name);
+
+	slot_name = make_slot_name(name);
+	if (!slot_name) {
+		err = -ENOMEM;
 		goto err;
 	}
 
+	err = kobject_init_and_add(&slot->kobj, &pci_slot_ktype, NULL,
+				   "%s", slot_name);
+	if (err)
+		goto err;
+
 	INIT_LIST_HEAD(&slot->list);
 	list_add(&slot->list, &parent->slots);
 
@@ -166,10 +252,10 @@ struct pci_slot *pci_create_slot(struct pci_bus *parent, int slot_nr,
 	pr_debug("%s: created pci_slot on %04x:%02x:%02x\n",
 		 __func__, pci_domain_nr(parent), parent->number, slot_nr);
 
- out:
+out:
 	up_write(&pci_bus_sem);
 	return slot;
- err:
+err:
 	kfree(slot);
 	slot = ERR_PTR(err);
 	goto out;
@@ -210,7 +296,6 @@ EXPORT_SYMBOL_GPL(pci_renumber_slot);
  * just call kobject_put on its kobj and let our release methods do the
  * rest.
  */
-
 void pci_destroy_slot(struct pci_slot *slot)
 {
 	pr_debug("%s: dec refcount to %d on %04x:%02x:%02x\n", __func__,

commit 828f37683e6d3ab5912989df0d04201db7ad798e
Author: Alex Chiang <achiang@hp.com>
Date:   Mon Oct 20 17:40:52 2008 -0600

    PCI: update pci_create_slot() to take a 'hotplug' param
    
    Slot detection drivers can co-exist with hotplug drivers. The names
    of the detected/claimed slots may be different depending on module
    load order.
    
    For legacy reasons, we need to allow hotplug drivers to override
    the slot name if a detection driver is loaded first (and they find
    the same slots).
    
    Creating and overriding slot names should be an atomic operation,
    otherwise you get a locking nightmare as various drivers race to
    call pci_create_slot().
    
    pci_create_slot() is already serialized by grabbing the pci_bus_sem.
    
    We update the API and add a 'hotplug' param, which is:
    
            set if the caller is a hotplug driver
            NULL if the caller is a detection driver
    
    pci_create_slot() does not actually use the 'hotplug' parameter in this
    patch. A later patch will add the logic that uses it.
    
    Cc: kristen.c.accardi@intel.com
    Cc: matthew@wil.cx
    Acked-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Alex Chiang <achiang@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/slot.c b/drivers/pci/slot.c
index b9b90ab6b861..0e009c3ba5fd 100644
--- a/drivers/pci/slot.c
+++ b/drivers/pci/slot.c
@@ -83,6 +83,7 @@ static struct kobj_type pci_slot_ktype = {
  * @parent: struct pci_bus of parent bridge
  * @slot_nr: PCI_SLOT(pci_dev->devfn) or -1 for placeholder
  * @name: user visible string presented in /sys/bus/pci/slots/<name>
+ * @hotplug: set if caller is hotplug driver, NULL otherwise
  *
  * PCI slots have first class attributes such as address, speed, width,
  * and a &struct pci_slot is used to manage them. This interface will
@@ -111,7 +112,8 @@ static struct kobj_type pci_slot_ktype = {
  */
 
 struct pci_slot *pci_create_slot(struct pci_bus *parent, int slot_nr,
-				 const char *name)
+				 const char *name,
+				 struct hotplug_slot *hotplug)
 {
 	struct pci_dev *dev;
 	struct pci_slot *slot;

commit d25b7c8d6ba2735602003d75a28894772fe8ad6a
Author: Alex Chiang <achiang@hp.com>
Date:   Mon Oct 20 17:40:47 2008 -0600

    PCI: rename pci_update_slot_number to pci_renumber_slot
    
    The GPL exported symbol pci_update_slot_number has been renamed to
    pci_renumber_slot. Some of the safety checks were unnecessary and
    were removed.
    
    Cc: kristen.c.accardi@intel.com
    Cc: matthew@wil.cx
    Acked-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Alex Chiang <achiang@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/slot.c b/drivers/pci/slot.c
index 0c6db03698ea..b9b90ab6b861 100644
--- a/drivers/pci/slot.c
+++ b/drivers/pci/slot.c
@@ -175,7 +175,7 @@ struct pci_slot *pci_create_slot(struct pci_bus *parent, int slot_nr,
 EXPORT_SYMBOL_GPL(pci_create_slot);
 
 /**
- * pci_update_slot_number - update %struct pci_slot -> number
+ * pci_renumber_slot - update %struct pci_slot -> number
  * @slot - %struct pci_slot to update
  * @slot_nr - new number for slot
  *
@@ -183,27 +183,22 @@ EXPORT_SYMBOL_GPL(pci_create_slot);
  * created a placeholder slot in pci_create_slot() by passing a -1 as
  * slot_nr, to update their %struct pci_slot with the correct @slot_nr.
  */
-
-void pci_update_slot_number(struct pci_slot *slot, int slot_nr)
+void pci_renumber_slot(struct pci_slot *slot, int slot_nr)
 {
-	int name_count = 0;
 	struct pci_slot *tmp;
 
 	down_write(&pci_bus_sem);
 
 	list_for_each_entry(tmp, &slot->bus->slots, list) {
 		WARN_ON(tmp->number == slot_nr);
-		if (!strcmp(kobject_name(&tmp->kobj), kobject_name(&slot->kobj)))
-			name_count++;
+		goto out;
 	}
 
-	if (name_count > 1)
-		printk(KERN_WARNING "pci_update_slot_number found %d slots with the same name: %s\n", name_count, kobject_name(&slot->kobj));
-
 	slot->number = slot_nr;
+out:
 	up_write(&pci_bus_sem);
 }
-EXPORT_SYMBOL_GPL(pci_update_slot_number);
+EXPORT_SYMBOL_GPL(pci_renumber_slot);
 
 /**
  * pci_destroy_slot - decrement refcount for physical PCI slot

commit cef354db0d7a7207ea78c716753d9216a9c2b7e1
Author: Alex Chiang <achiang@hp.com>
Date:   Tue Sep 2 09:40:51 2008 -0600

    PCI: connect struct pci_dev to struct pci_slot
    
    The introduction of struct pci_slot (f46753c5e354b857b20ab8e0fe7b25)
    added a struct pci_slot pointer to struct pci_dev, but we forgot to
    associate the two.
    
    Connect the two structs together; the interesting portions of the object
    lifetimes are:
    
            - when a new pci_slot is created, connect it to the appropriate
              pci_dev's. A single pci_slot may be associated with multiple
              pci_dev's, e.g. any multi-function PCI device.
    
            - when a pci_slot is released, look for all the pci_dev's it was
              associated with, and set their pci_slot pointers to NULL
    
            - when a pci_dev is created, look for slots to associate with.
    
    Note -- when a pci_dev is released, we don't need to do any bookkeeping,
    since pci_slot's do not have pointers to pci_dev's.
    
    Signed-off-by: Alex Chiang <achiang@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/slot.c b/drivers/pci/slot.c
index 7e5b85cbd948..0c6db03698ea 100644
--- a/drivers/pci/slot.c
+++ b/drivers/pci/slot.c
@@ -49,11 +49,16 @@ static ssize_t address_read_file(struct pci_slot *slot, char *buf)
 
 static void pci_slot_release(struct kobject *kobj)
 {
+	struct pci_dev *dev;
 	struct pci_slot *slot = to_pci_slot(kobj);
 
 	pr_debug("%s: releasing pci_slot on %x:%d\n", __func__,
 		 slot->bus->number, slot->number);
 
+	list_for_each_entry(dev, &slot->bus->devices, bus_list)
+		if (PCI_SLOT(dev->devfn) == slot->number)
+			dev->slot = NULL;
+
 	list_del(&slot->list);
 
 	kfree(slot);
@@ -108,6 +113,7 @@ static struct kobj_type pci_slot_ktype = {
 struct pci_slot *pci_create_slot(struct pci_bus *parent, int slot_nr,
 				 const char *name)
 {
+	struct pci_dev *dev;
 	struct pci_slot *slot;
 	int err;
 
@@ -150,6 +156,10 @@ struct pci_slot *pci_create_slot(struct pci_bus *parent, int slot_nr,
 	INIT_LIST_HEAD(&slot->list);
 	list_add(&slot->list, &parent->slots);
 
+	list_for_each_entry(dev, &parent->devices, bus_list)
+		if (PCI_SLOT(dev->devfn) == slot_nr)
+			dev->slot = slot;
+
 	/* Don't care if debug printk has a -1 for slot_nr */
 	pr_debug("%s: created pci_slot on %04x:%02x:%02x\n",
 		 __func__, pci_domain_nr(parent), parent->number, slot_nr);

commit f46753c5e354b857b20ab8e0fe7b2579831dc369
Author: Alex Chiang <achiang@hp.com>
Date:   Tue Jun 10 15:28:50 2008 -0600

    PCI: introduce pci_slot
    
    Currently, /sys/bus/pci/slots/ only exposes hotplug attributes when a
    hotplug driver is loaded, but PCI slots have attributes such as address,
    speed, width, etc.  that are not related to hotplug at all.
    
    Introduce pci_slot as the primary data structure and kobject model.
    Hotplug attributes described in hotplug_slot become a secondary
    structure associated with the pci_slot.
    
    This patch only creates the infrastructure that allows the separation of
    PCI slot attributes and hotplug attributes.  In this patch, the PCI
    hotplug core remains the only user of this infrastructure, and thus,
    /sys/bus/pci/slots/ will still only become populated when a hotplug
    driver is loaded.
    
    A later patch in this series will add a second user of this new
    infrastructure and demonstrate splitting the task of exposing pci_slot
    attributes from hotplug_slot attributes.
    
      - Make pci_slot the primary sysfs entity. hotplug_slot becomes a
        subsidiary structure.
        o pci_create_slot() creates and registers a slot with the PCI core
        o pci_slot_add_hotplug() gives it hotplug capability
    
      - Change the prototype of pci_hp_register() to take the bus and
        slot number (on parent bus) as parameters.
    
      - Remove all the ->get_address methods since this functionality is
        now handled by pci_slot directly.
    
    [achiang@hp.com: rpaphp-correctly-pci_hp_register-for-empty-pci-slots]
    Tested-by: Badari Pulavarty <pbadari@us.ibm.com>
    Acked-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    [akpm@linux-foundation.org: build fix]
    [akpm@linux-foundation.org: make headers_check happy]
    [akpm@linux-foundation.org: nuther build fix]
    [akpm@linux-foundation.org: fix typo in #include]
    Signed-off-by: Alex Chiang <achiang@hp.com>
    Signed-off-by: Matthew Wilcox <matthew@wil.cx>
    Cc: Greg KH <greg@kroah.com>
    Cc: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
    Cc: Len Brown <lenb@kernel.org>
    Acked-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/slot.c b/drivers/pci/slot.c
new file mode 100644
index 000000000000..7e5b85cbd948
--- /dev/null
+++ b/drivers/pci/slot.c
@@ -0,0 +1,233 @@
+/*
+ * drivers/pci/slot.c
+ * Copyright (C) 2006 Matthew Wilcox <matthew@wil.cx>
+ * Copyright (C) 2006-2008 Hewlett-Packard Development Company, L.P.
+ * 	Alex Chiang <achiang@hp.com>
+ */
+
+#include <linux/kobject.h>
+#include <linux/pci.h>
+#include <linux/err.h>
+#include "pci.h"
+
+struct kset *pci_slots_kset;
+EXPORT_SYMBOL_GPL(pci_slots_kset);
+
+static ssize_t pci_slot_attr_show(struct kobject *kobj,
+					struct attribute *attr, char *buf)
+{
+	struct pci_slot *slot = to_pci_slot(kobj);
+	struct pci_slot_attribute *attribute = to_pci_slot_attr(attr);
+	return attribute->show ? attribute->show(slot, buf) : -EIO;
+}
+
+static ssize_t pci_slot_attr_store(struct kobject *kobj,
+			struct attribute *attr, const char *buf, size_t len)
+{
+	struct pci_slot *slot = to_pci_slot(kobj);
+	struct pci_slot_attribute *attribute = to_pci_slot_attr(attr);
+	return attribute->store ? attribute->store(slot, buf, len) : -EIO;
+}
+
+static struct sysfs_ops pci_slot_sysfs_ops = {
+	.show = pci_slot_attr_show,
+	.store = pci_slot_attr_store,
+};
+
+static ssize_t address_read_file(struct pci_slot *slot, char *buf)
+{
+	if (slot->number == 0xff)
+		return sprintf(buf, "%04x:%02x\n",
+				pci_domain_nr(slot->bus),
+				slot->bus->number);
+	else
+		return sprintf(buf, "%04x:%02x:%02x\n",
+				pci_domain_nr(slot->bus),
+				slot->bus->number,
+				slot->number);
+}
+
+static void pci_slot_release(struct kobject *kobj)
+{
+	struct pci_slot *slot = to_pci_slot(kobj);
+
+	pr_debug("%s: releasing pci_slot on %x:%d\n", __func__,
+		 slot->bus->number, slot->number);
+
+	list_del(&slot->list);
+
+	kfree(slot);
+}
+
+static struct pci_slot_attribute pci_slot_attr_address =
+	__ATTR(address, (S_IFREG | S_IRUGO), address_read_file, NULL);
+
+static struct attribute *pci_slot_default_attrs[] = {
+	&pci_slot_attr_address.attr,
+	NULL,
+};
+
+static struct kobj_type pci_slot_ktype = {
+	.sysfs_ops = &pci_slot_sysfs_ops,
+	.release = &pci_slot_release,
+	.default_attrs = pci_slot_default_attrs,
+};
+
+/**
+ * pci_create_slot - create or increment refcount for physical PCI slot
+ * @parent: struct pci_bus of parent bridge
+ * @slot_nr: PCI_SLOT(pci_dev->devfn) or -1 for placeholder
+ * @name: user visible string presented in /sys/bus/pci/slots/<name>
+ *
+ * PCI slots have first class attributes such as address, speed, width,
+ * and a &struct pci_slot is used to manage them. This interface will
+ * either return a new &struct pci_slot to the caller, or if the pci_slot
+ * already exists, its refcount will be incremented.
+ *
+ * Slots are uniquely identified by a @pci_bus, @slot_nr, @name tuple.
+ *
+ * Placeholder slots:
+ * In most cases, @pci_bus, @slot_nr will be sufficient to uniquely identify
+ * a slot. There is one notable exception - pSeries (rpaphp), where the
+ * @slot_nr cannot be determined until a device is actually inserted into
+ * the slot. In this scenario, the caller may pass -1 for @slot_nr.
+ *
+ * The following semantics are imposed when the caller passes @slot_nr ==
+ * -1. First, the check for existing %struct pci_slot is skipped, as the
+ * caller may know about several unpopulated slots on a given %struct
+ * pci_bus, and each slot would have a @slot_nr of -1.  Uniqueness for
+ * these slots is then determined by the @name parameter. We expect
+ * kobject_init_and_add() to warn us if the caller attempts to create
+ * multiple slots with the same name. The other change in semantics is
+ * user-visible, which is the 'address' parameter presented in sysfs will
+ * consist solely of a dddd:bb tuple, where dddd is the PCI domain of the
+ * %struct pci_bus and bb is the bus number. In other words, the devfn of
+ * the 'placeholder' slot will not be displayed.
+ */
+
+struct pci_slot *pci_create_slot(struct pci_bus *parent, int slot_nr,
+				 const char *name)
+{
+	struct pci_slot *slot;
+	int err;
+
+	down_write(&pci_bus_sem);
+
+	if (slot_nr == -1)
+		goto placeholder;
+
+	/* If we've already created this slot, bump refcount and return. */
+	list_for_each_entry(slot, &parent->slots, list) {
+		if (slot->number == slot_nr) {
+			kobject_get(&slot->kobj);
+			pr_debug("%s: inc refcount to %d on %04x:%02x:%02x\n",
+				 __func__,
+				 atomic_read(&slot->kobj.kref.refcount),
+				 pci_domain_nr(parent), parent->number,
+				 slot_nr);
+			goto out;
+		}
+	}
+
+placeholder:
+	slot = kzalloc(sizeof(*slot), GFP_KERNEL);
+	if (!slot) {
+		slot = ERR_PTR(-ENOMEM);
+		goto out;
+	}
+
+	slot->bus = parent;
+	slot->number = slot_nr;
+
+	slot->kobj.kset = pci_slots_kset;
+	err = kobject_init_and_add(&slot->kobj, &pci_slot_ktype, NULL,
+				   "%s", name);
+	if (err) {
+		printk(KERN_ERR "Unable to register kobject %s\n", name);
+		goto err;
+	}
+
+	INIT_LIST_HEAD(&slot->list);
+	list_add(&slot->list, &parent->slots);
+
+	/* Don't care if debug printk has a -1 for slot_nr */
+	pr_debug("%s: created pci_slot on %04x:%02x:%02x\n",
+		 __func__, pci_domain_nr(parent), parent->number, slot_nr);
+
+ out:
+	up_write(&pci_bus_sem);
+	return slot;
+ err:
+	kfree(slot);
+	slot = ERR_PTR(err);
+	goto out;
+}
+EXPORT_SYMBOL_GPL(pci_create_slot);
+
+/**
+ * pci_update_slot_number - update %struct pci_slot -> number
+ * @slot - %struct pci_slot to update
+ * @slot_nr - new number for slot
+ *
+ * The primary purpose of this interface is to allow callers who earlier
+ * created a placeholder slot in pci_create_slot() by passing a -1 as
+ * slot_nr, to update their %struct pci_slot with the correct @slot_nr.
+ */
+
+void pci_update_slot_number(struct pci_slot *slot, int slot_nr)
+{
+	int name_count = 0;
+	struct pci_slot *tmp;
+
+	down_write(&pci_bus_sem);
+
+	list_for_each_entry(tmp, &slot->bus->slots, list) {
+		WARN_ON(tmp->number == slot_nr);
+		if (!strcmp(kobject_name(&tmp->kobj), kobject_name(&slot->kobj)))
+			name_count++;
+	}
+
+	if (name_count > 1)
+		printk(KERN_WARNING "pci_update_slot_number found %d slots with the same name: %s\n", name_count, kobject_name(&slot->kobj));
+
+	slot->number = slot_nr;
+	up_write(&pci_bus_sem);
+}
+EXPORT_SYMBOL_GPL(pci_update_slot_number);
+
+/**
+ * pci_destroy_slot - decrement refcount for physical PCI slot
+ * @slot: struct pci_slot to decrement
+ *
+ * %struct pci_slot is refcounted, so destroying them is really easy; we
+ * just call kobject_put on its kobj and let our release methods do the
+ * rest.
+ */
+
+void pci_destroy_slot(struct pci_slot *slot)
+{
+	pr_debug("%s: dec refcount to %d on %04x:%02x:%02x\n", __func__,
+		 atomic_read(&slot->kobj.kref.refcount) - 1,
+		 pci_domain_nr(slot->bus), slot->bus->number, slot->number);
+
+	down_write(&pci_bus_sem);
+	kobject_put(&slot->kobj);
+	up_write(&pci_bus_sem);
+}
+EXPORT_SYMBOL_GPL(pci_destroy_slot);
+
+static int pci_slot_init(void)
+{
+	struct kset *pci_bus_kset;
+
+	pci_bus_kset = bus_get_kset(&pci_bus_type);
+	pci_slots_kset = kset_create_and_add("slots", NULL,
+						&pci_bus_kset->kobj);
+	if (!pci_slots_kset) {
+		printk(KERN_ERR "PCI: Slot initialization failure\n");
+		return -ENOMEM;
+	}
+	return 0;
+}
+
+subsys_initcall(pci_slot_init);
