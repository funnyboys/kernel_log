commit 3910ebaca8eae0cb9d41a20efe1bcb375ec64dfb
Author: Krzysztof Wilczyński <kw@linux.com>
Date:   Tue May 26 21:39:05 2020 +0000

    PCI: Rename _DSM constants to align with spec
    
    Rename PCI-related _DSM constants to align them with the PCI Firmware Spec,
    r3.2, sec 4.6.  No functional change intended.
    
    Link: https://lore.kernel.org/r/20200526213905.2479381-1-kw@linux.com
    Signed-off-by: Krzysztof Wilczyński <kw@linux.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index d820a55ae71c..7224b1e5f2a8 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -1128,7 +1128,7 @@ void acpi_pci_add_bus(struct pci_bus *bus)
 		return;
 
 	obj = acpi_evaluate_dsm(ACPI_HANDLE(bus->bridge), &pci_acpi_dsm_guid, 3,
-				RESET_DELAY_DSM, NULL);
+				DSM_PCI_POWER_ON_RESET_DELAY, NULL);
 	if (!obj)
 		return;
 
@@ -1193,7 +1193,7 @@ static void pci_acpi_optimize_delay(struct pci_dev *pdev,
 		pdev->d3cold_delay = 0;
 
 	obj = acpi_evaluate_dsm(handle, &pci_acpi_dsm_guid, 3,
-				FUNCTION_DELAY_DSM, NULL);
+				DSM_PCI_DEVICE_READINESS_DURATIONS, NULL);
 	if (!obj)
 		return;
 

commit 6ae72bfa656ea04806f98ef85cb44b0789064362
Author: Yicong Yang <yangyicong@hisilicon.com>
Date:   Sat May 9 18:19:28 2020 +0800

    PCI: Unify pcie_find_root_port() and pci_find_pcie_root_port()
    
    Previously we used pcie_find_root_port() to find a Root Port from a PCIe
    device and pci_find_pcie_root_port() to find a Root Port from a
    Conventional PCI device.
    
    Unify the two functions and use pcie_find_root_port() to find a Root Port
    from either a Conventional PCI device or a PCIe device.  Then there is no
    need to distinguish the type of the device.
    
    Link: https://lore.kernel.org/r/1589019568-5216-1-git-send-email-yangyicong@hisilicon.com
    Signed-off-by: Yicong Yang <yangyicong@hisilicon.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Kalle Valo <kvalo@codeaurora.org> # wireless
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com> # thunderbolt

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index d21969fba6ab..d820a55ae71c 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -948,7 +948,7 @@ static bool acpi_pci_bridge_d3(struct pci_dev *dev)
 	 * Look for a special _DSD property for the root port and if it
 	 * is set we know the hierarchy behind it supports D3 just fine.
 	 */
-	root = pci_find_pcie_root_port(dev);
+	root = pcie_find_root_port(dev);
 	if (!root)
 		return false;
 

commit 10e8141baa7c5585c2d1ad98397186689ccf99b3
Merge: 74f0862cc983 bd641fd8303a
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Apr 2 14:26:38 2020 -0500

    Merge branch 'pci/misc'
    
      - Move _HPX type array from stack to static data (Colin Ian King)
    
      - Avoid an ASMedia XHCI USB PME# defect; apparently it doesn't assert
        PME# when USB3.0 devices are hotplugged in D0 (Kai-Heng Feng)
    
      - Revert sysfs "rescan" file renames that broke an application (Kelsey
        Skunberg)
    
    * pci/misc:
      PCI: sysfs: Revert "rescan" file renames
      PCI: Avoid ASMedia XHCI USB PME# from D0 defect
      PCI/ACPI: Move pcie_to_hpx3_type[] from stack to static data

commit ac1c8e35a3262d04cc81b07fac6480a3539e3b0f
Author: Kuppuswamy Sathyanarayanan <sathyanarayanan.kuppuswamy@linux.intel.com>
Date:   Mon Mar 23 17:26:07 2020 -0700

    PCI/DPC: Add Error Disconnect Recover (EDR) support
    
    Error Disconnect Recover (EDR) is a feature that allows ACPI firmware to
    notify OSPM that a device has been disconnected due to an error condition
    (ACPI v6.3, sec 5.6.6).  OSPM advertises its support for EDR on PCI devices
    via _OSC (see [1], sec 4.5.1, table 4-4).  The OSPM EDR notify handler
    should invalidate software state associated with disconnected devices and
    may attempt to recover them.  OSPM communicates the status of recovery to
    the firmware via _OST (sec 6.3.5.2).
    
    For PCIe, firmware may use Downstream Port Containment (DPC) to support
    EDR.  Per [1], sec 4.5.1, table 4-6, even if firmware has retained control
    of DPC, OSPM may read/write DPC control and status registers during the EDR
    notification processing window, i.e., from the time it receives an EDR
    notification until it clears the DPC Trigger Status.
    
    Note that per [1], sec 4.5.1 and 4.5.2.4,
    
      1. If the OS supports EDR, it should advertise that to firmware by
         setting OSC_PCI_EDR_SUPPORT in _OSC Support.
    
      2. If the OS sets OSC_PCI_EXPRESS_DPC_CONTROL in _OSC Control to request
         control of the DPC capability, it must also set OSC_PCI_EDR_SUPPORT in
         _OSC Support.
    
    Add an EDR notify handler to attempt recovery.
    
    [1] Downstream Port Containment Related Enhancements ECN, Jan 28, 2019,
        affecting PCI Firmware Specification, Rev. 3.2
        https://members.pcisig.com/wg/PCI-SIG/document/12888
    
    [bhelgaas: squash add/enable patches into one]
    Link: https://lore.kernel.org/r/90f91fe6d25c13f9d2255d2ce97ca15be307e1bb.1585000084.git.sathyanarayanan.kuppuswamy@linux.intel.com
    Signed-off-by: Kuppuswamy Sathyanarayanan <sathyanarayanan.kuppuswamy@linux.intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Len Brown <lenb@kernel.org>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 0c02d500158f..1a6d2062cf8d 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -1241,6 +1241,7 @@ static void pci_acpi_setup(struct device *dev)
 
 	pci_acpi_optimize_delay(pci_dev, adev->handle);
 	pci_acpi_set_untrusted(pci_dev);
+	pci_acpi_add_edr_notifier(pci_dev);
 
 	pci_acpi_add_pm_notifier(adev, pci_dev);
 	if (!adev->wakeup.flags.valid)
@@ -1268,6 +1269,7 @@ static void pci_acpi_cleanup(struct device *dev)
 	if (!adev)
 		return;
 
+	pci_acpi_remove_edr_notifier(pci_dev);
 	pci_acpi_remove_pm_notifier(adev);
 	if (adev->wakeup.flags.valid) {
 		acpi_device_power_remove_dependent(adev, dev);

commit e3cdcfcea363edadebf94576c29d33a441fd5a6f
Author: Colin Ian King <colin.king@canonical.com>
Date:   Mon Feb 10 08:52:56 2020 +0000

    PCI/ACPI: Move pcie_to_hpx3_type[] from stack to static data
    
    Move pcie_to_hpx3_type[] from the stack to static data.  This reduces stack
    usage and also makes the object code slightly smaller.
    
    Link: https://lore.kernel.org/r/20200210085256.319424-1-colin.king@canonical.com
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 0c02d500158f..d914f8bc31ea 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -439,7 +439,7 @@ enum hpx_type3_dev_type {
 static u16 hpx3_device_type(struct pci_dev *dev)
 {
 	u16 pcie_type = pci_pcie_type(dev);
-	const int pcie_to_hpx3_type[] = {
+	static const int pcie_to_hpx3_type[] = {
 		[PCI_EXP_TYPE_ENDPOINT]    = HPX_TYPE_ENDPOINT,
 		[PCI_EXP_TYPE_LEG_END]     = HPX_TYPE_LEG_END,
 		[PCI_EXP_TYPE_RC_END]      = HPX_TYPE_RC_END,

commit a10a1f60c7a35f59bee803fe2796ec5172e73edb
Merge: 77dc51fd557f ca78410403dd
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Sep 23 16:10:08 2019 -0500

    Merge branch 'pci/enumeration'
    
      - Consolidate _HPP & _HPX code in pci-acpi.h and remove unnecessary
        struct hotplug_program_ops (Krzysztof Wilczynski)
    
      - Fixup PCIe device types to remove the need for dev->has_secondary_link
        (Mika Westerberg)
    
    * pci/enumeration:
      PCI: Get rid of dev->has_secondary_link flag
      PCI: Make pcie_downstream_port() available outside of access.c
      PCI/ACPI: Remove unnecessary struct hotplug_program_ops
      PCI/ACPI: Move _HPP & _HPX functions to pci-acpi.c
      PCI/ACPI: Rename _HPX structs from hpp_* to hpx_*

commit 4a2dbeddd3d54484d2e9c12965e4f9bfa1a0ee36
Author: Krzysztof Wilczynski <kw@linux.com>
Date:   Tue Aug 27 11:49:51 2019 +0200

    PCI/ACPI: Remove unnecessary struct hotplug_program_ops
    
    Move the ACPI-specific structs hpx_type0, hpx_type1, hpx_type2 and
    hpx_type3 to drivers/pci/pci-acpi.c as they are not used anywhere else.
    Then remove the struct hotplug_program_ops that has been shared between
    drivers/pci/probe.c and drivers/pci/pci-acpi.c from drivers/pci/pci.h as it
    is no longer needed.
    
    The struct hotplug_program_ops was added by 87fcf12e846a ("PCI/ACPI: Remove
    the need for 'struct hotplug_params'") and replaced previously used struct
    hotplug_params enabling the support for the _HPX Type 3 Setting Record that
    was added by f873c51a155a ("PCI/ACPI: Implement _HPX Type 3 Setting
    Record").
    
    The new struct allowed for the static functions such program_hpx_type0(),
    program_hpx_type1(), etc., from the drivers/pci/probe.c to be called from
    the function pci_acpi_program_hp_params() in the drivers/pci/pci-acpi.c.
    
    Previously a programming of _HPX Type 0 was as follows:
    
      drivers/pci/probe.c:
    
        program_hpx_type0()
        ...
        pci_configure_device()
          hp_ops = {
            .program_type0 = program_hpx_type0,
            ...
          }
          pci_acpi_program_hp_params(&hp_ops)
    
      drivers/pci/pci-acpi.c:
    
        pci_acpi_program_hp_params(&hp_ops)
          acpi_run_hpx(hp_ops)
            decode_type0_hpx_record()
              hp_ops->program_type0     # program_hpx_type0() called via hp_ops
    
    After the ACPI-specific functions, structs, enums, etc., have been moved to
    drivers/pci/pci-acpi.c there is no need for the hotplug_program_ops as all
    of the _HPX Type 0, 1, 2 and 3 are directly accessible.
    
    Link: https://lore.kernel.org/r/20190827094951.10613-4-kw@linux.com
    Signed-off-by: Krzysztof Wilczynski <kw@linux.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 0bfabb3f9931..6e65d1ff93da 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -118,6 +118,15 @@ phys_addr_t acpi_pci_root_get_mcfg_addr(acpi_handle handle)
 	return (phys_addr_t)mcfg_addr;
 }
 
+/* _HPX PCI Setting Record (Type 0); same as _HPP */
+struct hpx_type0 {
+	u32 revision;		/* Not present in _HPP */
+	u8  cache_line_size;	/* Not applicable to PCIe */
+	u8  latency_timer;	/* Not applicable to PCIe */
+	u8  enable_serr;
+	u8  enable_perr;
+};
+
 static struct hpx_type0 pci_default_type0 = {
 	.revision = 1,
 	.cache_line_size = 8,
@@ -126,7 +135,7 @@ static struct hpx_type0 pci_default_type0 = {
 	.enable_perr = 0,
 };
 
-void program_hpx_type0(struct pci_dev *dev, struct hpx_type0 *hpx)
+static void program_hpx_type0(struct pci_dev *dev, struct hpx_type0 *hpx)
 {
 	u16 pci_cmd, pci_bctl;
 
@@ -187,7 +196,15 @@ static acpi_status decode_type0_hpx_record(union acpi_object *record,
 	return AE_OK;
 }
 
-void program_hpx_type1(struct pci_dev *dev, struct hpx_type1 *hpx)
+/* _HPX PCI-X Setting Record (Type 1) */
+struct hpx_type1 {
+	u32 revision;
+	u8  max_mem_read;
+	u8  avg_max_split;
+	u16 tot_max_split;
+};
+
+static void program_hpx_type1(struct pci_dev *dev, struct hpx_type1 *hpx)
 {
 	int pos;
 
@@ -243,7 +260,28 @@ static bool pcie_root_rcb_set(struct pci_dev *dev)
 	return false;
 }
 
-void program_hpx_type2(struct pci_dev *dev, struct hpx_type2 *hpx)
+/* _HPX PCI Express Setting Record (Type 2) */
+struct hpx_type2 {
+	u32 revision;
+	u32 unc_err_mask_and;
+	u32 unc_err_mask_or;
+	u32 unc_err_sever_and;
+	u32 unc_err_sever_or;
+	u32 cor_err_mask_and;
+	u32 cor_err_mask_or;
+	u32 adv_err_cap_and;
+	u32 adv_err_cap_or;
+	u16 pci_exp_devctl_and;
+	u16 pci_exp_devctl_or;
+	u16 pci_exp_lnkctl_and;
+	u16 pci_exp_lnkctl_or;
+	u32 sec_unc_err_sever_and;
+	u32 sec_unc_err_sever_or;
+	u32 sec_unc_err_mask_and;
+	u32 sec_unc_err_mask_or;
+};
+
+static void program_hpx_type2(struct pci_dev *dev, struct hpx_type2 *hpx)
 {
 	int pos;
 	u32 reg32;
@@ -369,6 +407,24 @@ static acpi_status decode_type2_hpx_record(union acpi_object *record,
 	return AE_OK;
 }
 
+/* _HPX PCI Express Setting Record (Type 3) */
+struct hpx_type3 {
+	u16 device_type;
+	u16 function_type;
+	u16 config_space_location;
+	u16 pci_exp_cap_id;
+	u16 pci_exp_cap_ver;
+	u16 pci_exp_vendor_id;
+	u16 dvsec_id;
+	u16 dvsec_rev;
+	u16 match_offset;
+	u32 match_mask_and;
+	u32 match_value;
+	u16 reg_offset;
+	u32 reg_mask_and;
+	u32 reg_mask_or;
+};
+
 enum hpx_type3_dev_type {
 	HPX_TYPE_ENDPOINT	= BIT(0),
 	HPX_TYPE_LEG_END	= BIT(1),
@@ -498,7 +554,7 @@ static void program_hpx_type3_register(struct pci_dev *dev,
 		pos, orig_value, write_reg);
 }
 
-void program_hpx_type3(struct pci_dev *dev, struct hpx_type3 *hpx)
+static void program_hpx_type3(struct pci_dev *dev, struct hpx_type3 *hpx)
 {
 	if (!hpx)
 		return;
@@ -529,8 +585,7 @@ static void parse_hpx3_register(struct hpx_type3 *hpx3_reg,
 }
 
 static acpi_status program_type3_hpx_record(struct pci_dev *dev,
-					   union acpi_object *record,
-					   const struct hotplug_program_ops *hp_ops)
+					   union acpi_object *record)
 {
 	union acpi_object *fields = record->package.elements;
 	u32 desc_count, expected_length, revision;
@@ -554,7 +609,7 @@ static acpi_status program_type3_hpx_record(struct pci_dev *dev,
 		for (i = 0; i < desc_count; i++) {
 			reg_fields = fields + 3 + i * 14;
 			parse_hpx3_register(&hpx3, reg_fields);
-			hp_ops->program_type3(dev, &hpx3);
+			program_hpx_type3(dev, &hpx3);
 		}
 
 		break;
@@ -567,8 +622,7 @@ static acpi_status program_type3_hpx_record(struct pci_dev *dev,
 	return AE_OK;
 }
 
-static acpi_status acpi_run_hpx(struct pci_dev *dev, acpi_handle handle,
-				const struct hotplug_program_ops *hp_ops)
+static acpi_status acpi_run_hpx(struct pci_dev *dev, acpi_handle handle)
 {
 	acpi_status status;
 	struct acpi_buffer buffer = {ACPI_ALLOCATE_BUFFER, NULL};
@@ -610,24 +664,24 @@ static acpi_status acpi_run_hpx(struct pci_dev *dev, acpi_handle handle,
 			status = decode_type0_hpx_record(record, &hpx0);
 			if (ACPI_FAILURE(status))
 				goto exit;
-			hp_ops->program_type0(dev, &hpx0);
+			program_hpx_type0(dev, &hpx0);
 			break;
 		case 1:
 			memset(&hpx1, 0, sizeof(hpx1));
 			status = decode_type1_hpx_record(record, &hpx1);
 			if (ACPI_FAILURE(status))
 				goto exit;
-			hp_ops->program_type1(dev, &hpx1);
+			program_hpx_type1(dev, &hpx1);
 			break;
 		case 2:
 			memset(&hpx2, 0, sizeof(hpx2));
 			status = decode_type2_hpx_record(record, &hpx2);
 			if (ACPI_FAILURE(status))
 				goto exit;
-			hp_ops->program_type2(dev, &hpx2);
+			program_hpx_type2(dev, &hpx2);
 			break;
 		case 3:
-			status = program_type3_hpx_record(dev, record, hp_ops);
+			status = program_type3_hpx_record(dev, record);
 			if (ACPI_FAILURE(status))
 				goto exit;
 			break;
@@ -643,8 +697,7 @@ static acpi_status acpi_run_hpx(struct pci_dev *dev, acpi_handle handle,
 	return status;
 }
 
-static acpi_status acpi_run_hpp(struct pci_dev *dev, acpi_handle handle,
-				const struct hotplug_program_ops *hp_ops)
+static acpi_status acpi_run_hpp(struct pci_dev *dev, acpi_handle handle)
 {
 	acpi_status status;
 	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
@@ -679,20 +732,18 @@ static acpi_status acpi_run_hpp(struct pci_dev *dev, acpi_handle handle,
 	hpx0.enable_serr     = fields[2].integer.value;
 	hpx0.enable_perr     = fields[3].integer.value;
 
-	hp_ops->program_type0(dev, &hpx0);
+	program_hpx_type0(dev, &hpx0);
 
 exit:
 	kfree(buffer.pointer);
 	return status;
 }
 
-/* pci_get_hp_params
+/* pci_acpi_program_hp_params
  *
  * @dev - the pci_dev for which we want parameters
- * @hpp - allocated by the caller
  */
-int pci_acpi_program_hp_params(struct pci_dev *dev,
-			       const struct hotplug_program_ops *hp_ops)
+int pci_acpi_program_hp_params(struct pci_dev *dev)
 {
 	acpi_status status;
 	acpi_handle handle, phandle;
@@ -715,10 +766,10 @@ int pci_acpi_program_hp_params(struct pci_dev *dev,
 	 * this pci dev.
 	 */
 	while (handle) {
-		status = acpi_run_hpx(dev, handle, hp_ops);
+		status = acpi_run_hpx(dev, handle);
 		if (ACPI_SUCCESS(status))
 			return 0;
-		status = acpi_run_hpp(dev, handle, hp_ops);
+		status = acpi_run_hpp(dev, handle);
 		if (ACPI_SUCCESS(status))
 			return 0;
 		if (acpi_is_root_bridge(handle))

commit 8c3aac6e1b6146ce771b1cabd78e593136d3e5f2
Author: Krzysztof Wilczynski <kw@linux.com>
Date:   Tue Aug 27 11:49:50 2019 +0200

    PCI/ACPI: Move _HPP & _HPX functions to pci-acpi.c
    
    Move program_hpx_type0(), program_hpx_type1(), etc., and enums
    hpx_type3_dev_type, hpx_type3_fn_type and hpx_type3_cfg_loc to
    drivers/pci/pci-acpi.c as these functions and enums are ACPI-specific.
    
    Move structs hpx_type0, hpx_type1, hpx_type2 and hpx_type3 to
    drivers/pci/pci.h as these are shared between drivers/pci/pci-acpi.c and
    drivers/pci/probe.c.
    
    Link: https://lore.kernel.org/r/20190827094951.10613-3-kw@linux.com
    Signed-off-by: Krzysztof Wilczynski <kw@linux.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 02addc47edae..0bfabb3f9931 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -118,6 +118,47 @@ phys_addr_t acpi_pci_root_get_mcfg_addr(acpi_handle handle)
 	return (phys_addr_t)mcfg_addr;
 }
 
+static struct hpx_type0 pci_default_type0 = {
+	.revision = 1,
+	.cache_line_size = 8,
+	.latency_timer = 0x40,
+	.enable_serr = 0,
+	.enable_perr = 0,
+};
+
+void program_hpx_type0(struct pci_dev *dev, struct hpx_type0 *hpx)
+{
+	u16 pci_cmd, pci_bctl;
+
+	if (!hpx)
+		hpx = &pci_default_type0;
+
+	if (hpx->revision > 1) {
+		pci_warn(dev, "PCI settings rev %d not supported; using defaults\n",
+			 hpx->revision);
+		hpx = &pci_default_type0;
+	}
+
+	pci_write_config_byte(dev, PCI_CACHE_LINE_SIZE, hpx->cache_line_size);
+	pci_write_config_byte(dev, PCI_LATENCY_TIMER, hpx->latency_timer);
+	pci_read_config_word(dev, PCI_COMMAND, &pci_cmd);
+	if (hpx->enable_serr)
+		pci_cmd |= PCI_COMMAND_SERR;
+	if (hpx->enable_perr)
+		pci_cmd |= PCI_COMMAND_PARITY;
+	pci_write_config_word(dev, PCI_COMMAND, pci_cmd);
+
+	/* Program bridge control value */
+	if ((dev->class >> 8) == PCI_CLASS_BRIDGE_PCI) {
+		pci_write_config_byte(dev, PCI_SEC_LATENCY_TIMER,
+				      hpx->latency_timer);
+		pci_read_config_word(dev, PCI_BRIDGE_CONTROL, &pci_bctl);
+		if (hpx->enable_perr)
+			pci_bctl |= PCI_BRIDGE_CTL_PARITY;
+		pci_write_config_word(dev, PCI_BRIDGE_CONTROL, pci_bctl);
+	}
+}
+
 static acpi_status decode_type0_hpx_record(union acpi_object *record,
 					   struct hpx_type0 *hpx0)
 {
@@ -146,6 +187,20 @@ static acpi_status decode_type0_hpx_record(union acpi_object *record,
 	return AE_OK;
 }
 
+void program_hpx_type1(struct pci_dev *dev, struct hpx_type1 *hpx)
+{
+	int pos;
+
+	if (!hpx)
+		return;
+
+	pos = pci_find_capability(dev, PCI_CAP_ID_PCIX);
+	if (!pos)
+		return;
+
+	pci_warn(dev, "PCI-X settings not supported\n");
+}
+
 static acpi_status decode_type1_hpx_record(union acpi_object *record,
 					   struct hpx_type1 *hpx1)
 {
@@ -173,6 +228,107 @@ static acpi_status decode_type1_hpx_record(union acpi_object *record,
 	return AE_OK;
 }
 
+static bool pcie_root_rcb_set(struct pci_dev *dev)
+{
+	struct pci_dev *rp = pcie_find_root_port(dev);
+	u16 lnkctl;
+
+	if (!rp)
+		return false;
+
+	pcie_capability_read_word(rp, PCI_EXP_LNKCTL, &lnkctl);
+	if (lnkctl & PCI_EXP_LNKCTL_RCB)
+		return true;
+
+	return false;
+}
+
+void program_hpx_type2(struct pci_dev *dev, struct hpx_type2 *hpx)
+{
+	int pos;
+	u32 reg32;
+
+	if (!hpx)
+		return;
+
+	if (!pci_is_pcie(dev))
+		return;
+
+	if (hpx->revision > 1) {
+		pci_warn(dev, "PCIe settings rev %d not supported\n",
+			 hpx->revision);
+		return;
+	}
+
+	/*
+	 * Don't allow _HPX to change MPS or MRRS settings.  We manage
+	 * those to make sure they're consistent with the rest of the
+	 * platform.
+	 */
+	hpx->pci_exp_devctl_and |= PCI_EXP_DEVCTL_PAYLOAD |
+				    PCI_EXP_DEVCTL_READRQ;
+	hpx->pci_exp_devctl_or &= ~(PCI_EXP_DEVCTL_PAYLOAD |
+				    PCI_EXP_DEVCTL_READRQ);
+
+	/* Initialize Device Control Register */
+	pcie_capability_clear_and_set_word(dev, PCI_EXP_DEVCTL,
+			~hpx->pci_exp_devctl_and, hpx->pci_exp_devctl_or);
+
+	/* Initialize Link Control Register */
+	if (pcie_cap_has_lnkctl(dev)) {
+
+		/*
+		 * If the Root Port supports Read Completion Boundary of
+		 * 128, set RCB to 128.  Otherwise, clear it.
+		 */
+		hpx->pci_exp_lnkctl_and |= PCI_EXP_LNKCTL_RCB;
+		hpx->pci_exp_lnkctl_or &= ~PCI_EXP_LNKCTL_RCB;
+		if (pcie_root_rcb_set(dev))
+			hpx->pci_exp_lnkctl_or |= PCI_EXP_LNKCTL_RCB;
+
+		pcie_capability_clear_and_set_word(dev, PCI_EXP_LNKCTL,
+			~hpx->pci_exp_lnkctl_and, hpx->pci_exp_lnkctl_or);
+	}
+
+	/* Find Advanced Error Reporting Enhanced Capability */
+	pos = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ERR);
+	if (!pos)
+		return;
+
+	/* Initialize Uncorrectable Error Mask Register */
+	pci_read_config_dword(dev, pos + PCI_ERR_UNCOR_MASK, &reg32);
+	reg32 = (reg32 & hpx->unc_err_mask_and) | hpx->unc_err_mask_or;
+	pci_write_config_dword(dev, pos + PCI_ERR_UNCOR_MASK, reg32);
+
+	/* Initialize Uncorrectable Error Severity Register */
+	pci_read_config_dword(dev, pos + PCI_ERR_UNCOR_SEVER, &reg32);
+	reg32 = (reg32 & hpx->unc_err_sever_and) | hpx->unc_err_sever_or;
+	pci_write_config_dword(dev, pos + PCI_ERR_UNCOR_SEVER, reg32);
+
+	/* Initialize Correctable Error Mask Register */
+	pci_read_config_dword(dev, pos + PCI_ERR_COR_MASK, &reg32);
+	reg32 = (reg32 & hpx->cor_err_mask_and) | hpx->cor_err_mask_or;
+	pci_write_config_dword(dev, pos + PCI_ERR_COR_MASK, reg32);
+
+	/* Initialize Advanced Error Capabilities and Control Register */
+	pci_read_config_dword(dev, pos + PCI_ERR_CAP, &reg32);
+	reg32 = (reg32 & hpx->adv_err_cap_and) | hpx->adv_err_cap_or;
+
+	/* Don't enable ECRC generation or checking if unsupported */
+	if (!(reg32 & PCI_ERR_CAP_ECRC_GENC))
+		reg32 &= ~PCI_ERR_CAP_ECRC_GENE;
+	if (!(reg32 & PCI_ERR_CAP_ECRC_CHKC))
+		reg32 &= ~PCI_ERR_CAP_ECRC_CHKE;
+	pci_write_config_dword(dev, pos + PCI_ERR_CAP, reg32);
+
+	/*
+	 * FIXME: The following two registers are not supported yet.
+	 *
+	 *   o Secondary Uncorrectable Error Severity Register
+	 *   o Secondary Uncorrectable Error Mask Register
+	 */
+}
+
 static acpi_status decode_type2_hpx_record(union acpi_object *record,
 					   struct hpx_type2 *hpx2)
 {
@@ -213,6 +369,146 @@ static acpi_status decode_type2_hpx_record(union acpi_object *record,
 	return AE_OK;
 }
 
+enum hpx_type3_dev_type {
+	HPX_TYPE_ENDPOINT	= BIT(0),
+	HPX_TYPE_LEG_END	= BIT(1),
+	HPX_TYPE_RC_END		= BIT(2),
+	HPX_TYPE_RC_EC		= BIT(3),
+	HPX_TYPE_ROOT_PORT	= BIT(4),
+	HPX_TYPE_UPSTREAM	= BIT(5),
+	HPX_TYPE_DOWNSTREAM	= BIT(6),
+	HPX_TYPE_PCI_BRIDGE	= BIT(7),
+	HPX_TYPE_PCIE_BRIDGE	= BIT(8),
+};
+
+static u16 hpx3_device_type(struct pci_dev *dev)
+{
+	u16 pcie_type = pci_pcie_type(dev);
+	const int pcie_to_hpx3_type[] = {
+		[PCI_EXP_TYPE_ENDPOINT]    = HPX_TYPE_ENDPOINT,
+		[PCI_EXP_TYPE_LEG_END]     = HPX_TYPE_LEG_END,
+		[PCI_EXP_TYPE_RC_END]      = HPX_TYPE_RC_END,
+		[PCI_EXP_TYPE_RC_EC]       = HPX_TYPE_RC_EC,
+		[PCI_EXP_TYPE_ROOT_PORT]   = HPX_TYPE_ROOT_PORT,
+		[PCI_EXP_TYPE_UPSTREAM]    = HPX_TYPE_UPSTREAM,
+		[PCI_EXP_TYPE_DOWNSTREAM]  = HPX_TYPE_DOWNSTREAM,
+		[PCI_EXP_TYPE_PCI_BRIDGE]  = HPX_TYPE_PCI_BRIDGE,
+		[PCI_EXP_TYPE_PCIE_BRIDGE] = HPX_TYPE_PCIE_BRIDGE,
+	};
+
+	if (pcie_type >= ARRAY_SIZE(pcie_to_hpx3_type))
+		return 0;
+
+	return pcie_to_hpx3_type[pcie_type];
+}
+
+enum hpx_type3_fn_type {
+	HPX_FN_NORMAL		= BIT(0),
+	HPX_FN_SRIOV_PHYS	= BIT(1),
+	HPX_FN_SRIOV_VIRT	= BIT(2),
+};
+
+static u8 hpx3_function_type(struct pci_dev *dev)
+{
+	if (dev->is_virtfn)
+		return HPX_FN_SRIOV_VIRT;
+	else if (pci_find_ext_capability(dev, PCI_EXT_CAP_ID_SRIOV) > 0)
+		return HPX_FN_SRIOV_PHYS;
+	else
+		return HPX_FN_NORMAL;
+}
+
+static bool hpx3_cap_ver_matches(u8 pcie_cap_id, u8 hpx3_cap_id)
+{
+	u8 cap_ver = hpx3_cap_id & 0xf;
+
+	if ((hpx3_cap_id & BIT(4)) && cap_ver >= pcie_cap_id)
+		return true;
+	else if (cap_ver == pcie_cap_id)
+		return true;
+
+	return false;
+}
+
+enum hpx_type3_cfg_loc {
+	HPX_CFG_PCICFG		= 0,
+	HPX_CFG_PCIE_CAP	= 1,
+	HPX_CFG_PCIE_CAP_EXT	= 2,
+	HPX_CFG_VEND_CAP	= 3,
+	HPX_CFG_DVSEC		= 4,
+	HPX_CFG_MAX,
+};
+
+static void program_hpx_type3_register(struct pci_dev *dev,
+				       const struct hpx_type3 *reg)
+{
+	u32 match_reg, write_reg, header, orig_value;
+	u16 pos;
+
+	if (!(hpx3_device_type(dev) & reg->device_type))
+		return;
+
+	if (!(hpx3_function_type(dev) & reg->function_type))
+		return;
+
+	switch (reg->config_space_location) {
+	case HPX_CFG_PCICFG:
+		pos = 0;
+		break;
+	case HPX_CFG_PCIE_CAP:
+		pos = pci_find_capability(dev, reg->pci_exp_cap_id);
+		if (pos == 0)
+			return;
+
+		break;
+	case HPX_CFG_PCIE_CAP_EXT:
+		pos = pci_find_ext_capability(dev, reg->pci_exp_cap_id);
+		if (pos == 0)
+			return;
+
+		pci_read_config_dword(dev, pos, &header);
+		if (!hpx3_cap_ver_matches(PCI_EXT_CAP_VER(header),
+					  reg->pci_exp_cap_ver))
+			return;
+
+		break;
+	case HPX_CFG_VEND_CAP:	/* Fall through */
+	case HPX_CFG_DVSEC:	/* Fall through */
+	default:
+		pci_warn(dev, "Encountered _HPX type 3 with unsupported config space location");
+		return;
+	}
+
+	pci_read_config_dword(dev, pos + reg->match_offset, &match_reg);
+
+	if ((match_reg & reg->match_mask_and) != reg->match_value)
+		return;
+
+	pci_read_config_dword(dev, pos + reg->reg_offset, &write_reg);
+	orig_value = write_reg;
+	write_reg &= reg->reg_mask_and;
+	write_reg |= reg->reg_mask_or;
+
+	if (orig_value == write_reg)
+		return;
+
+	pci_write_config_dword(dev, pos + reg->reg_offset, write_reg);
+
+	pci_dbg(dev, "Applied _HPX3 at [0x%x]: 0x%08x -> 0x%08x",
+		pos, orig_value, write_reg);
+}
+
+void program_hpx_type3(struct pci_dev *dev, struct hpx_type3 *hpx)
+{
+	if (!hpx)
+		return;
+
+	if (!pci_is_pcie(dev))
+		return;
+
+	program_hpx_type3_register(dev, hpx);
+}
+
 static void parse_hpx3_register(struct hpx_type3 *hpx3_reg,
 				union acpi_object *reg_fields)
 {

commit e2797ad31fb40f4ff59ebc4314d6f000d713bad9
Author: Krzysztof Wilczynski <kw@linux.com>
Date:   Tue Aug 27 11:49:49 2019 +0200

    PCI/ACPI: Rename _HPX structs from hpp_* to hpx_*
    
    The names of the hpp_type0, hpp_type1 and hpp_type2 structs suggest that
    they're related to _HPP, when in fact they're related to _HPX.
    
    The struct hpp_type0 denotes an _HPX Type 0 setting record that supersedes
    the _HPP setting record, and it has been used interchangeably for _HPP as
    per the ACPI specification (see version 6.3, section 6.2.9.1) which states
    that it should be applied to PCI, PCI-X and PCI Express devices, with
    settings being ignored if they are not applicable.
    
    Rename them to hpx_type0, hpx_type1 and hpx_type2 to reflect their relation
    to _HPX rather than _HPP.
    
    Link: https://lore.kernel.org/r/20190827094951.10613-2-kw@linux.com
    Signed-off-by: Krzysztof Wilczynski <kw@linux.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 45049f558860..02addc47edae 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -119,7 +119,7 @@ phys_addr_t acpi_pci_root_get_mcfg_addr(acpi_handle handle)
 }
 
 static acpi_status decode_type0_hpx_record(union acpi_object *record,
-					   struct hpp_type0 *hpx0)
+					   struct hpx_type0 *hpx0)
 {
 	int i;
 	union acpi_object *fields = record->package.elements;
@@ -147,7 +147,7 @@ static acpi_status decode_type0_hpx_record(union acpi_object *record,
 }
 
 static acpi_status decode_type1_hpx_record(union acpi_object *record,
-					   struct hpp_type1 *hpx1)
+					   struct hpx_type1 *hpx1)
 {
 	int i;
 	union acpi_object *fields = record->package.elements;
@@ -174,7 +174,7 @@ static acpi_status decode_type1_hpx_record(union acpi_object *record,
 }
 
 static acpi_status decode_type2_hpx_record(union acpi_object *record,
-					   struct hpp_type2 *hpx2)
+					   struct hpx_type2 *hpx2)
 {
 	int i;
 	union acpi_object *fields = record->package.elements;
@@ -277,9 +277,9 @@ static acpi_status acpi_run_hpx(struct pci_dev *dev, acpi_handle handle,
 	acpi_status status;
 	struct acpi_buffer buffer = {ACPI_ALLOCATE_BUFFER, NULL};
 	union acpi_object *package, *record, *fields;
-	struct hpp_type0 hpx0;
-	struct hpp_type1 hpx1;
-	struct hpp_type2 hpx2;
+	struct hpx_type0 hpx0;
+	struct hpx_type1 hpx1;
+	struct hpx_type2 hpx2;
 	u32 type;
 	int i;
 
@@ -353,10 +353,10 @@ static acpi_status acpi_run_hpp(struct pci_dev *dev, acpi_handle handle,
 	acpi_status status;
 	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
 	union acpi_object *package, *fields;
-	struct hpp_type0 hpp0;
+	struct hpx_type0 hpx0;
 	int i;
 
-	memset(&hpp0, 0, sizeof(hpp0));
+	memset(&hpx0, 0, sizeof(hpx0));
 
 	status = acpi_evaluate_object(handle, "_HPP", NULL, &buffer);
 	if (ACPI_FAILURE(status))
@@ -377,13 +377,13 @@ static acpi_status acpi_run_hpp(struct pci_dev *dev, acpi_handle handle,
 		}
 	}
 
-	hpp0.revision        = 1;
-	hpp0.cache_line_size = fields[0].integer.value;
-	hpp0.latency_timer   = fields[1].integer.value;
-	hpp0.enable_serr     = fields[2].integer.value;
-	hpp0.enable_perr     = fields[3].integer.value;
+	hpx0.revision        = 1;
+	hpx0.cache_line_size = fields[0].integer.value;
+	hpx0.latency_timer   = fields[1].integer.value;
+	hpx0.enable_serr     = fields[2].integer.value;
+	hpx0.enable_perr     = fields[3].integer.value;
 
-	hp_ops->program_type0(dev, &hpp0);
+	hp_ops->program_type0(dev, &hpx0);
 
 exit:
 	kfree(buffer.pointer);

commit 7ce2e76a0420801fb4b53b9e6850940e6b326433
Author: Krzysztof Wilczynski <kw@linux.com>
Date:   Tue Aug 27 11:56:20 2019 +0200

    PCI: Move ASPM declarations to linux/pci.h
    
    Move ASPM definitions and function prototypes from include/linux/pci-aspm.h
    to include/linux/pci.h so users only need to include <linux/pci.h>:
    
      PCIE_LINK_STATE_L0S
      PCIE_LINK_STATE_L1
      PCIE_LINK_STATE_CLKPM
      pci_disable_link_state()
      pci_disable_link_state_locked()
      pcie_no_aspm()
    
    No functional changes intended.
    
    Link: https://lore.kernel.org/r/20190827095620.11213-1-kw@linux.com
    Signed-off-by: Krzysztof Wilczynski <kw@linux.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 45049f558860..dd520fe927db 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -14,7 +14,6 @@
 #include <linux/msi.h>
 #include <linux/pci_hotplug.h>
 #include <linux/module.h>
-#include <linux/pci-aspm.h>
 #include <linux/pci-acpi.h>
 #include <linux/pm_runtime.h>
 #include <linux/pm_qos.h>

commit b51033e06c2ebbad322370f4a35c84488e61b342
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Jun 25 14:09:12 2019 +0200

    PCI: PM/ACPI: Refresh all stale power state data in pci_pm_complete()
    
    In pci_pm_complete() there are checks to decide whether or not to
    resume devices that were left in runtime-suspend during the preceding
    system-wide transition into a sleep state.  They involve checking the
    current power state of the device and comparing it with the power
    state of it set before the preceding system-wide transition, but the
    platform component of the device's power state is not handled
    correctly in there.
    
    Namely, on platforms with ACPI, the device power state information
    needs to be updated with care, so that the reference counters of
    power resources used by the device (if any) are set to ensure that
    the refreshed power state of it will be maintained going forward.
    
    To that end, introduce a new ->refresh_state() platform PM callback
    for PCI devices, for asking the platform to refresh the device power
    state data and ensure that the corresponding power state will be
    maintained going forward, make it invoke acpi_device_update_power()
    (for devices with ACPI PM) on platforms with ACPI and make
    pci_pm_complete() use it, through a new pci_refresh_power_state()
    wrapper function.
    
    Fixes: a0d2a959d3da (PCI: Avoid unnecessary resume after direct-complete)
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 2abe0eeafb53..45049f558860 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -692,6 +692,14 @@ static pci_power_t acpi_pci_get_power_state(struct pci_dev *dev)
 	return state_conv[state];
 }
 
+static void acpi_pci_refresh_power_state(struct pci_dev *dev)
+{
+	struct acpi_device *adev = ACPI_COMPANION(&dev->dev);
+
+	if (adev && acpi_device_power_manageable(adev))
+		acpi_device_update_power(adev, NULL);
+}
+
 static int acpi_pci_propagate_wakeup(struct pci_bus *bus, bool enable)
 {
 	while (bus->parent) {
@@ -749,6 +757,7 @@ static const struct pci_platform_pm_ops acpi_pci_platform_pm = {
 	.is_manageable = acpi_pci_power_manageable,
 	.set_state = acpi_pci_set_power_state,
 	.get_state = acpi_pci_get_power_state,
+	.refresh_state = acpi_pci_refresh_power_state,
 	.choose_state = acpi_pci_choose_state,
 	.set_wakeup = acpi_pci_wakeup,
 	.need_resume = acpi_pci_need_resume,

commit 53b22f900c2d282bf6499712930188cc02306e4e
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Tue Jun 25 13:29:42 2019 +0300

    PCI / ACPI: Add _PR0 dependent devices
    
    If otherwise unrelated PCI devices share ACPI power resources turning
    them on causes the devices to enter D0uninitialized power state which may
    cause problems.
    
    For example in Intel Ice Lake two root ports (RP0 and RP1), Thunderbolt
    controller (NHI) and xHCI controller all share power resources as can be
    ween in the topology below where power resources are marked with []:
    
      Host bridge
        |
        +- RP0 ---\
        +- RP1 ---|--+--> [TBT]
        +- NHI --/   |
        |            |
        |            v
        +- xHCI --> [D3C]
    
    In a situation where all devices sharing the power resources are in
    D3cold (the power resources are turned off) and for example the
    Thunderbolt controller is runtime resumed resulting that the power
    resources are turned on. This means that the other devices sharing them
    (RP0, RP1 and xHCI) are transitioned into D0uninitialized state. If they
    were configured to trigger wake (PME) on a certain event that
    configuration gets lost after reset so we would need to re-initialize
    them to get the wakeup working as expected again. To do so we would need
    to runtime resume all of them to make sure their registers get restored
    properly before we can runtime suspend them again.
    
    Since we just added concept of "_PR0 dependent device" we can solve this
    by calling the relevant add/remove functions when the PCI device is bind
    to its ACPI representation. If it has power resources the PCI device
    will be added as dependent device to them and runtime resumed whenever
    they are physically turned on. This should make sure PCI core can
    reconfigure wakes after the device is transitioned into D0uninitialized.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index b782acac26c5..2abe0eeafb53 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -902,6 +902,7 @@ static void pci_acpi_setup(struct device *dev)
 		device_wakeup_enable(dev);
 
 	acpi_pci_wakeup(pci_dev, false);
+	acpi_device_power_add_dependent(adev, dev);
 }
 
 static void pci_acpi_cleanup(struct device *dev)
@@ -914,6 +915,7 @@ static void pci_acpi_cleanup(struct device *dev)
 
 	pci_acpi_remove_pm_notifier(adev);
 	if (adev->wakeup.flags.valid) {
+		acpi_device_power_remove_dependent(adev, dev);
 		if (pci_dev->bridge_d3)
 			device_wakeup_disable(dev);
 

commit 83a16e3f6d70da99896c7a2639c0b60fff13afb8
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Tue Jun 25 13:29:40 2019 +0300

    PCI / ACPI: Use cached ACPI device state to get PCI device power state
    
    The ACPI power state returned by acpi_device_get_power() may depend on
    the configuration of ACPI power resources in the system which may change
    any time after acpi_device_get_power() has returned, unless the
    reference counters of the ACPI power resources in question are set to
    prevent that from happening. Thus it is invalid to use acpi_device_get_power()
    in acpi_pci_get_power_state() the way it is done now and the value of
    the ->power.state field in the corresponding struct acpi_device objects
    (which reflects the ACPI power resources reference counting, among other
    things) should be used instead.
    
    As an example where this becomes an issue is Intel Ice Lake where the
    Thunderbolt controller (NHI), two PCIe root ports (RP0 and RP1) and xHCI
    all share the same power resources. The following picture with power
    resources marked with [] shows the topology:
    
      Host bridge
        |
        +- RP0 ---\
        +- RP1 ---|--+--> [TBT]
        +- NHI --/   |
        |            |
        |            v
        +- xHCI --> [D3C]
    
    Here TBT and D3C are the shared ACPI power resources. ACPI _PR3() method
    of the devices in question returns either TBT or D3C or both.
    
    Say we runtime suspend first the root ports RP0 and RP1, then NHI. Now
    since the TBT power resource is still on when the root ports are runtime
    suspended their dev->current_state is set to D3hot. When NHI is runtime
    suspended TBT is finally turned off but state of the root ports remain
    to be D3hot. Now when the xHCI is runtime suspended D3C gets also turned
    off. PCI core thus has power states of these devices cached in their
    dev->current_state as follows:
    
      RP0 -> D3hot
      RP1 -> D3hot
      NHI -> D3cold
      xHCI -> D3cold
    
    If the user now runs lspci for instance, the result is all 1's like in
    the below output (00:07.0 is the first root port, RP0):
    
    00:07.0 PCI bridge: Intel Corporation Device 8a1d (rev ff) (prog-if ff)
        !!! Unknown header type 7f
        Kernel driver in use: pcieport
    
    In short the hardware state is not in sync with the software state
    anymore. The exact same thing happens with the PME polling thread which
    ends up bringing the root ports back into D0 after they are runtime
    suspended.
    
    For this reason, modify acpi_pci_get_power_state() so that it uses the
    ACPI device power state that was cached by the ACPI core. This makes the
    PCI device power state match the ACPI device power state regardless of
    state of the shared power resources which may still be on at this point.
    
    Link: https://lore.kernel.org/r/20190618161858.77834-2-mika.westerberg@linux.intel.com
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 1897847ceb0c..b782acac26c5 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -685,7 +685,8 @@ static pci_power_t acpi_pci_get_power_state(struct pci_dev *dev)
 	if (!adev || !acpi_device_power_manageable(adev))
 		return PCI_UNKNOWN;
 
-	if (acpi_device_get_power(adev, &state) || state == ACPI_STATE_UNKNOWN)
+	state = adev->power.state;
+	if (state == ACPI_STATE_UNKNOWN)
 		return PCI_UNKNOWN;
 
 	return state_conv[state];

commit 9a51c6b1f9e0239a9435db036b212498a2a3b75c
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu May 16 12:42:20 2019 +0200

    ACPI/PCI: PM: Add missing wakeup.flags.valid checks
    
    Both acpi_pci_need_resume() and acpi_dev_needs_resume() check if the
    current ACPI wakeup configuration of the device matches what is
    expected as far as system wakeup from sleep states is concerned, as
    reflected by the device_may_wakeup() return value for the device.
    
    However, they only should do that if wakeup.flags.valid is set for
    the device's ACPI companion, because otherwise the wakeup.prepare_count
    value for it is meaningless.
    
    Add the missing wakeup.flags.valid checks to these functions.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index c5e1a097d7e3..1897847ceb0c 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -733,7 +733,8 @@ static bool acpi_pci_need_resume(struct pci_dev *dev)
 	if (!adev || !acpi_device_power_manageable(adev))
 		return false;
 
-	if (device_may_wakeup(&dev->dev) != !!adev->wakeup.prepare_count)
+	if (adev->wakeup.flags.valid &&
+	    device_may_wakeup(&dev->dev) != !!adev->wakeup.prepare_count)
 		return true;
 
 	if (acpi_target_system_state() == ACPI_STATE_S0)

commit 192415f4986028db53fb76ebcefecf0d73cb900a
Merge: f2e946831625 34c6b7105e5a
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon May 13 18:34:46 2019 -0500

    Merge branch 'pci/printk'
    
    * pci/printk:
      PCI: Replace dev_printk(KERN_DEBUG) with dev_info(), etc
      PCI: Replace printk(KERN_INFO) with pr_info(), etc
      PCI: Use dev_printk() when possible

commit 25da8dbaaf0679b3b22c783952a8392071cfa135
Author: Mohan Kumar <mohankumar718@gmail.com>
Date:   Sat Apr 20 07:03:46 2019 +0300

    PCI: Replace printk(KERN_INFO) with pr_info(), etc
    
    Replace printk() with pr_*() to be more consistent with other logging and
    avoid checkpatch warnings.
    
    Link: https://lore.kernel.org/lkml/1555733026-19609-1-git-send-email-mohankumar718@gmail.com
    Link: https://lore.kernel.org/lkml/1555733130-19804-1-git-send-email-mohankumar718@gmail.com
    Signed-off-by: Mohan Kumar <mohankumar718@gmail.com>
    [bhelgaas: squash in similar changes from second patch in series]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index e1949f7efd9c..3ada0266974c 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -140,8 +140,7 @@ static acpi_status decode_type0_hpx_record(union acpi_object *record,
 		hpx->t0->enable_perr     = fields[5].integer.value;
 		break;
 	default:
-		printk(KERN_WARNING
-		       "%s: Type 0 Revision %d record not supported\n",
+		pr_warn("%s: Type 0 Revision %d record not supported\n",
 		       __func__, revision);
 		return AE_ERROR;
 	}
@@ -169,8 +168,7 @@ static acpi_status decode_type1_hpx_record(union acpi_object *record,
 		hpx->t1->tot_max_split = fields[4].integer.value;
 		break;
 	default:
-		printk(KERN_WARNING
-		       "%s: Type 1 Revision %d record not supported\n",
+		pr_warn("%s: Type 1 Revision %d record not supported\n",
 		       __func__, revision);
 		return AE_ERROR;
 	}
@@ -211,8 +209,7 @@ static acpi_status decode_type2_hpx_record(union acpi_object *record,
 		hpx->t2->sec_unc_err_mask_or   = fields[17].integer.value;
 		break;
 	default:
-		printk(KERN_WARNING
-		       "%s: Type 2 Revision %d record not supported\n",
+		pr_warn("%s: Type 2 Revision %d record not supported\n",
 		       __func__, revision);
 		return AE_ERROR;
 	}
@@ -272,7 +269,7 @@ static acpi_status acpi_run_hpx(acpi_handle handle, struct hotplug_params *hpx)
 				goto exit;
 			break;
 		default:
-			printk(KERN_ERR "%s: Type %d record not supported\n",
+			pr_err("%s: Type %d record not supported\n",
 			       __func__, type);
 			status = AE_ERROR;
 			goto exit;

commit f873c51a155aaa6dafdc00fa7fda3754f2f9f794
Author: Alexandru Gagniuc <mr.nuke.me@gmail.com>
Date:   Fri Feb 8 10:24:13 2019 -0600

    PCI/ACPI: Implement _HPX Type 3 Setting Record
    
    The _HPX Type 3 Setting Record is intended to be more generic and allow
    configuration of settings not possible with Type 2 records.  For example,
    firmware could ensure that the completion timeout value is set accordingly
    throughout the PCI tree.
    
    Implement support for _HPX Type 3 Setting Records, which were added in the
    ACPI 6.3 spec.
    
    Link: https://lore.kernel.org/lkml/20190208162414.3996-4-mr.nuke.me@gmail.com
    Signed-off-by: Alexandru Gagniuc <mr.nuke.me@gmail.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 95f4f86d2f34..03e02dd6c1d9 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -216,6 +216,64 @@ static acpi_status decode_type2_hpx_record(union acpi_object *record,
 	return AE_OK;
 }
 
+static void parse_hpx3_register(struct hpx_type3 *hpx3_reg,
+				union acpi_object *reg_fields)
+{
+	hpx3_reg->device_type            = reg_fields[0].integer.value;
+	hpx3_reg->function_type          = reg_fields[1].integer.value;
+	hpx3_reg->config_space_location  = reg_fields[2].integer.value;
+	hpx3_reg->pci_exp_cap_id         = reg_fields[3].integer.value;
+	hpx3_reg->pci_exp_cap_ver        = reg_fields[4].integer.value;
+	hpx3_reg->pci_exp_vendor_id      = reg_fields[5].integer.value;
+	hpx3_reg->dvsec_id               = reg_fields[6].integer.value;
+	hpx3_reg->dvsec_rev              = reg_fields[7].integer.value;
+	hpx3_reg->match_offset           = reg_fields[8].integer.value;
+	hpx3_reg->match_mask_and         = reg_fields[9].integer.value;
+	hpx3_reg->match_value            = reg_fields[10].integer.value;
+	hpx3_reg->reg_offset             = reg_fields[11].integer.value;
+	hpx3_reg->reg_mask_and           = reg_fields[12].integer.value;
+	hpx3_reg->reg_mask_or            = reg_fields[13].integer.value;
+}
+
+static acpi_status program_type3_hpx_record(struct pci_dev *dev,
+					   union acpi_object *record,
+					   const struct hotplug_program_ops *hp_ops)
+{
+	union acpi_object *fields = record->package.elements;
+	u32 desc_count, expected_length, revision;
+	union acpi_object *reg_fields;
+	struct hpx_type3 hpx3;
+	int i;
+
+	revision = fields[1].integer.value;
+	switch (revision) {
+	case 1:
+		desc_count = fields[2].integer.value;
+		expected_length = 3 + desc_count * 14;
+
+		if (record->package.count != expected_length)
+			return AE_ERROR;
+
+		for (i = 2; i < expected_length; i++)
+			if (fields[i].type != ACPI_TYPE_INTEGER)
+				return AE_ERROR;
+
+		for (i = 0; i < desc_count; i++) {
+			reg_fields = fields + 3 + i * 14;
+			parse_hpx3_register(&hpx3, reg_fields);
+			hp_ops->program_type3(dev, &hpx3);
+		}
+
+		break;
+	default:
+		printk(KERN_WARNING
+			"%s: Type 3 Revision %d record not supported\n",
+			__func__, revision);
+		return AE_ERROR;
+	}
+	return AE_OK;
+}
+
 static acpi_status acpi_run_hpx(struct pci_dev *dev, acpi_handle handle,
 				const struct hotplug_program_ops *hp_ops)
 {
@@ -275,6 +333,11 @@ static acpi_status acpi_run_hpx(struct pci_dev *dev, acpi_handle handle,
 				goto exit;
 			hp_ops->program_type2(dev, &hpx2);
 			break;
+		case 3:
+			status = program_type3_hpx_record(dev, record, hp_ops);
+			if (ACPI_FAILURE(status))
+				goto exit;
+			break;
 		default:
 			printk(KERN_ERR "%s: Type %d record not supported\n",
 			       __func__, type);

commit 87fcf12e846a5028c14d21a94a0712fd1ad5bad0
Author: Alexandru Gagniuc <mr.nuke.me@gmail.com>
Date:   Fri Apr 19 14:27:36 2019 -0500

    PCI/ACPI: Remove the need for 'struct hotplug_params'
    
    We used to first parse all the _HPP and _HPX tables before using the
    information to program registers of PCIe devices.  Up through HPX Type 2,
    there was only one structure of each type, so we could cheat and store it
    on the stack.
    
    With HPX Type 3 we get an arbitrary number of entries, so the above model
    doesn't scale that well.  Instead of parsing all tables at once, parse and
    program each entry separately.  For _HPP and _HPX Types 0 through 2, this
    is functionally equivalent.  The change enables the upcoming _HPX Type 3 to
    integrate more easily.
    
    Link: https://lore.kernel.org/lkml/20190208162414.3996-3-mr.nuke.me@gmail.com
    Signed-off-by: Alexandru Gagniuc <mr.nuke.me@gmail.com>
    [bhelgaas: fix build errors]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index b25e5fa9d1c9..95f4f86d2f34 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -119,7 +119,7 @@ phys_addr_t acpi_pci_root_get_mcfg_addr(acpi_handle handle)
 }
 
 static acpi_status decode_type0_hpx_record(union acpi_object *record,
-					   struct hotplug_params *hpx)
+					   struct hpp_type0 *hpx0)
 {
 	int i;
 	union acpi_object *fields = record->package.elements;
@@ -132,12 +132,11 @@ static acpi_status decode_type0_hpx_record(union acpi_object *record,
 		for (i = 2; i < 6; i++)
 			if (fields[i].type != ACPI_TYPE_INTEGER)
 				return AE_ERROR;
-		hpx->t0 = &hpx->type0_data;
-		hpx->t0->revision        = revision;
-		hpx->t0->cache_line_size = fields[2].integer.value;
-		hpx->t0->latency_timer   = fields[3].integer.value;
-		hpx->t0->enable_serr     = fields[4].integer.value;
-		hpx->t0->enable_perr     = fields[5].integer.value;
+		hpx0->revision        = revision;
+		hpx0->cache_line_size = fields[2].integer.value;
+		hpx0->latency_timer   = fields[3].integer.value;
+		hpx0->enable_serr     = fields[4].integer.value;
+		hpx0->enable_perr     = fields[5].integer.value;
 		break;
 	default:
 		printk(KERN_WARNING
@@ -149,7 +148,7 @@ static acpi_status decode_type0_hpx_record(union acpi_object *record,
 }
 
 static acpi_status decode_type1_hpx_record(union acpi_object *record,
-					   struct hotplug_params *hpx)
+					   struct hpp_type1 *hpx1)
 {
 	int i;
 	union acpi_object *fields = record->package.elements;
@@ -162,11 +161,10 @@ static acpi_status decode_type1_hpx_record(union acpi_object *record,
 		for (i = 2; i < 5; i++)
 			if (fields[i].type != ACPI_TYPE_INTEGER)
 				return AE_ERROR;
-		hpx->t1 = &hpx->type1_data;
-		hpx->t1->revision      = revision;
-		hpx->t1->max_mem_read  = fields[2].integer.value;
-		hpx->t1->avg_max_split = fields[3].integer.value;
-		hpx->t1->tot_max_split = fields[4].integer.value;
+		hpx1->revision      = revision;
+		hpx1->max_mem_read  = fields[2].integer.value;
+		hpx1->avg_max_split = fields[3].integer.value;
+		hpx1->tot_max_split = fields[4].integer.value;
 		break;
 	default:
 		printk(KERN_WARNING
@@ -178,7 +176,7 @@ static acpi_status decode_type1_hpx_record(union acpi_object *record,
 }
 
 static acpi_status decode_type2_hpx_record(union acpi_object *record,
-					   struct hotplug_params *hpx)
+					   struct hpp_type2 *hpx2)
 {
 	int i;
 	union acpi_object *fields = record->package.elements;
@@ -191,24 +189,23 @@ static acpi_status decode_type2_hpx_record(union acpi_object *record,
 		for (i = 2; i < 18; i++)
 			if (fields[i].type != ACPI_TYPE_INTEGER)
 				return AE_ERROR;
-		hpx->t2 = &hpx->type2_data;
-		hpx->t2->revision      = revision;
-		hpx->t2->unc_err_mask_and      = fields[2].integer.value;
-		hpx->t2->unc_err_mask_or       = fields[3].integer.value;
-		hpx->t2->unc_err_sever_and     = fields[4].integer.value;
-		hpx->t2->unc_err_sever_or      = fields[5].integer.value;
-		hpx->t2->cor_err_mask_and      = fields[6].integer.value;
-		hpx->t2->cor_err_mask_or       = fields[7].integer.value;
-		hpx->t2->adv_err_cap_and       = fields[8].integer.value;
-		hpx->t2->adv_err_cap_or        = fields[9].integer.value;
-		hpx->t2->pci_exp_devctl_and    = fields[10].integer.value;
-		hpx->t2->pci_exp_devctl_or     = fields[11].integer.value;
-		hpx->t2->pci_exp_lnkctl_and    = fields[12].integer.value;
-		hpx->t2->pci_exp_lnkctl_or     = fields[13].integer.value;
-		hpx->t2->sec_unc_err_sever_and = fields[14].integer.value;
-		hpx->t2->sec_unc_err_sever_or  = fields[15].integer.value;
-		hpx->t2->sec_unc_err_mask_and  = fields[16].integer.value;
-		hpx->t2->sec_unc_err_mask_or   = fields[17].integer.value;
+		hpx2->revision      = revision;
+		hpx2->unc_err_mask_and      = fields[2].integer.value;
+		hpx2->unc_err_mask_or       = fields[3].integer.value;
+		hpx2->unc_err_sever_and     = fields[4].integer.value;
+		hpx2->unc_err_sever_or      = fields[5].integer.value;
+		hpx2->cor_err_mask_and      = fields[6].integer.value;
+		hpx2->cor_err_mask_or       = fields[7].integer.value;
+		hpx2->adv_err_cap_and       = fields[8].integer.value;
+		hpx2->adv_err_cap_or        = fields[9].integer.value;
+		hpx2->pci_exp_devctl_and    = fields[10].integer.value;
+		hpx2->pci_exp_devctl_or     = fields[11].integer.value;
+		hpx2->pci_exp_lnkctl_and    = fields[12].integer.value;
+		hpx2->pci_exp_lnkctl_or     = fields[13].integer.value;
+		hpx2->sec_unc_err_sever_and = fields[14].integer.value;
+		hpx2->sec_unc_err_sever_or  = fields[15].integer.value;
+		hpx2->sec_unc_err_mask_and  = fields[16].integer.value;
+		hpx2->sec_unc_err_mask_or   = fields[17].integer.value;
 		break;
 	default:
 		printk(KERN_WARNING
@@ -219,17 +216,18 @@ static acpi_status decode_type2_hpx_record(union acpi_object *record,
 	return AE_OK;
 }
 
-static acpi_status acpi_run_hpx(acpi_handle handle, struct hotplug_params *hpx)
+static acpi_status acpi_run_hpx(struct pci_dev *dev, acpi_handle handle,
+				const struct hotplug_program_ops *hp_ops)
 {
 	acpi_status status;
 	struct acpi_buffer buffer = {ACPI_ALLOCATE_BUFFER, NULL};
 	union acpi_object *package, *record, *fields;
+	struct hpp_type0 hpx0;
+	struct hpp_type1 hpx1;
+	struct hpp_type2 hpx2;
 	u32 type;
 	int i;
 
-	/* Clear the return buffer with zeros */
-	memset(hpx, 0, sizeof(struct hotplug_params));
-
 	status = acpi_evaluate_object(handle, "_HPX", NULL, &buffer);
 	if (ACPI_FAILURE(status))
 		return status;
@@ -257,19 +255,25 @@ static acpi_status acpi_run_hpx(acpi_handle handle, struct hotplug_params *hpx)
 		type = fields[0].integer.value;
 		switch (type) {
 		case 0:
-			status = decode_type0_hpx_record(record, hpx);
+			memset(&hpx0, 0, sizeof(hpx0));
+			status = decode_type0_hpx_record(record, &hpx0);
 			if (ACPI_FAILURE(status))
 				goto exit;
+			hp_ops->program_type0(dev, &hpx0);
 			break;
 		case 1:
-			status = decode_type1_hpx_record(record, hpx);
+			memset(&hpx1, 0, sizeof(hpx1));
+			status = decode_type1_hpx_record(record, &hpx1);
 			if (ACPI_FAILURE(status))
 				goto exit;
+			hp_ops->program_type1(dev, &hpx1);
 			break;
 		case 2:
-			status = decode_type2_hpx_record(record, hpx);
+			memset(&hpx2, 0, sizeof(hpx2));
+			status = decode_type2_hpx_record(record, &hpx2);
 			if (ACPI_FAILURE(status))
 				goto exit;
+			hp_ops->program_type2(dev, &hpx2);
 			break;
 		default:
 			printk(KERN_ERR "%s: Type %d record not supported\n",
@@ -283,14 +287,16 @@ static acpi_status acpi_run_hpx(acpi_handle handle, struct hotplug_params *hpx)
 	return status;
 }
 
-static acpi_status acpi_run_hpp(acpi_handle handle, struct hotplug_params *hpp)
+static acpi_status acpi_run_hpp(struct pci_dev *dev, acpi_handle handle,
+				const struct hotplug_program_ops *hp_ops)
 {
 	acpi_status status;
 	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
 	union acpi_object *package, *fields;
+	struct hpp_type0 hpp0;
 	int i;
 
-	memset(hpp, 0, sizeof(struct hotplug_params));
+	memset(&hpp0, 0, sizeof(hpp0));
 
 	status = acpi_evaluate_object(handle, "_HPP", NULL, &buffer);
 	if (ACPI_FAILURE(status))
@@ -311,12 +317,13 @@ static acpi_status acpi_run_hpp(acpi_handle handle, struct hotplug_params *hpp)
 		}
 	}
 
-	hpp->t0 = &hpp->type0_data;
-	hpp->t0->revision        = 1;
-	hpp->t0->cache_line_size = fields[0].integer.value;
-	hpp->t0->latency_timer   = fields[1].integer.value;
-	hpp->t0->enable_serr     = fields[2].integer.value;
-	hpp->t0->enable_perr     = fields[3].integer.value;
+	hpp0.revision        = 1;
+	hpp0.cache_line_size = fields[0].integer.value;
+	hpp0.latency_timer   = fields[1].integer.value;
+	hpp0.enable_serr     = fields[2].integer.value;
+	hpp0.enable_perr     = fields[3].integer.value;
+
+	hp_ops->program_type0(dev, &hpp0);
 
 exit:
 	kfree(buffer.pointer);
@@ -328,7 +335,8 @@ static acpi_status acpi_run_hpp(acpi_handle handle, struct hotplug_params *hpp)
  * @dev - the pci_dev for which we want parameters
  * @hpp - allocated by the caller
  */
-int pci_get_hp_params(struct pci_dev *dev, struct hotplug_params *hpp)
+int pci_acpi_program_hp_params(struct pci_dev *dev,
+			       const struct hotplug_program_ops *hp_ops)
 {
 	acpi_status status;
 	acpi_handle handle, phandle;
@@ -351,10 +359,10 @@ int pci_get_hp_params(struct pci_dev *dev, struct hotplug_params *hpp)
 	 * this pci dev.
 	 */
 	while (handle) {
-		status = acpi_run_hpx(handle, hpp);
+		status = acpi_run_hpx(dev, handle, hp_ops);
 		if (ACPI_SUCCESS(status))
 			return 0;
-		status = acpi_run_hpp(handle, hpp);
+		status = acpi_run_hpp(dev, handle, hp_ops);
 		if (ACPI_SUCCESS(status))
 			return 0;
 		if (acpi_is_root_bridge(handle))

commit e77704501ca00ecb3f2f6439b3eb0d8afbe3a1bf
Author: Alexandru Gagniuc <mr.nuke.me@gmail.com>
Date:   Fri Feb 8 10:24:11 2019 -0600

    PCI/ACPI: Do not export pci_get_hp_params()
    
    pci_get_hp_params() is only used within drivers/pci, and there is no reason
    to make it available outside of the PCI core, so stop exporting it.
    
    Link: https://lore.kernel.org/lkml/20190208162414.3996-2-mr.nuke.me@gmail.com
    Signed-off-by: Alexandru Gagniuc <mr.nuke.me@gmail.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index e1949f7efd9c..b25e5fa9d1c9 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -366,7 +366,6 @@ int pci_get_hp_params(struct pci_dev *dev, struct hotplug_params *hpp)
 	}
 	return -ENODEV;
 }
-EXPORT_SYMBOL_GPL(pci_get_hp_params);
 
 /**
  * pciehp_is_native - Check whether a hotplug port is handled by the OS

commit 617654aae50eb59dd98aa53fb562e850937f4cde
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Thu Aug 16 12:28:48 2018 +0300

    PCI / ACPI: Identify untrusted PCI devices
    
    A malicious PCI device may use DMA to attack the system. An external
    Thunderbolt port is a convenient point to attach such a device. The OS
    may use IOMMU to defend against DMA attacks.
    
    Some BIOSes mark these externally facing root ports with this
    ACPI _DSD [1]:
    
      Name (_DSD, Package () {
          ToUUID ("efcc06cc-73ac-4bc3-bff0-76143807c389"),
          Package () {
              Package () {"ExternalFacingPort", 1},
              Package () {"UID", 0 }
          }
      })
    
    If we find such a root port, mark it and all its children as untrusted.
    The rest of the OS may use this information to enable DMA protection
    against malicious devices. For instance the device may be put behind an
    IOMMU to keep it from accessing memory outside of what the driver has
    allocated for it.
    
    While at it, add a comment on top of prp_guids array explaining the
    possible caveat resulting when these GUIDs are treated equivalent.
    
    [1] https://docs.microsoft.com/en-us/windows-hardware/drivers/pci/dsd-for-pcie-root-ports#identifying-externally-exposed-pcie-root-ports
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 921db6f80340..e1949f7efd9c 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -789,6 +789,24 @@ static void pci_acpi_optimize_delay(struct pci_dev *pdev,
 	ACPI_FREE(obj);
 }
 
+static void pci_acpi_set_untrusted(struct pci_dev *dev)
+{
+	u8 val;
+
+	if (pci_pcie_type(dev) != PCI_EXP_TYPE_ROOT_PORT)
+		return;
+	if (device_property_read_u8(&dev->dev, "ExternalFacingPort", &val))
+		return;
+
+	/*
+	 * These root ports expose PCIe (including DMA) outside of the
+	 * system so make sure we treat them and everything behind as
+	 * untrusted.
+	 */
+	if (val)
+		dev->untrusted = 1;
+}
+
 static void pci_acpi_setup(struct device *dev)
 {
 	struct pci_dev *pci_dev = to_pci_dev(dev);
@@ -798,6 +816,7 @@ static void pci_acpi_setup(struct device *dev)
 		return;
 
 	pci_acpi_optimize_delay(pci_dev, adev->handle);
+	pci_acpi_set_untrusted(pci_dev);
 
 	pci_acpi_add_pm_notifier(adev, pci_dev);
 	if (!adev->wakeup.flags.valid)

commit 0d76bcc960e6057750fcf556b65da13f8bbdfd2b
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Nov 13 08:38:17 2018 -0600

    Revert "ACPI/PCI: Pay attention to device-specific _PXM node values"
    
    This reverts commit bad7dcd94f3956bcfc0a69ef71fdf0fcca3de4a8.
    
    bad7dcd94f39 ("ACPI/PCI: Pay attention to device-specific _PXM node
    values") caused boot failures (no console output at all) for Martin [1]
    and Ingo [2] on AMD ThreadRipper systems.
    
    Revert the commit until we figure out how to safely use these
    device-specific _PXM values.
    
    [1] https://lore.kernel.org/linux-pci/20180912152140.3676-2-Jonathan.Cameron@huawei.com
    [2] https://lore.kernel.org/linux-pci/20181113071712.GA2353@gmail.com
    Fixes: bad7dcd94f39 ("ACPI/PCI: Pay attention to device-specific _PXM node values")
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 2a4aa6468579..921db6f80340 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -793,15 +793,10 @@ static void pci_acpi_setup(struct device *dev)
 {
 	struct pci_dev *pci_dev = to_pci_dev(dev);
 	struct acpi_device *adev = ACPI_COMPANION(dev);
-	int node;
 
 	if (!adev)
 		return;
 
-	node = acpi_get_node(adev->handle);
-	if (node != NUMA_NO_NODE)
-		set_dev_node(dev, node);
-
 	pci_acpi_optimize_delay(pci_dev, adev->handle);
 
 	pci_acpi_add_pm_notifier(adev, pci_dev);

commit ee8360fdafac54eefd0df69fbd99338896cf806b
Merge: 20634dc361e1 fe73c23d7a09
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Sat Oct 20 11:45:30 2018 -0500

    Merge branch 'pci/misc'
    
      - Remove unused Netronome NFP32xx Device IDs (Jakub Kicinski)
    
      - Use bitmap_zalloc() for dma_alias_mask (Andy Shevchenko)
    
      - Add switch fall-through annotations (Gustavo A. R. Silva)
    
      - Remove unused Switchtec quirk variable (Joshua Abraham)
    
      - Fix pci.c kernel-doc warning (Randy Dunlap)
    
      - Remove trivial PCI wrappers for DMA APIs (Christoph Hellwig)
    
      - Add Intel GPU device IDs to spurious interrupt quirk (Bin Meng)
    
      - Run Switchtec DMA aliasing quirk only on NTB endpoints to avoid useless
        dmesg errors (Logan Gunthorpe)
    
      - Update Switchtec NTB documentation (Wesley Yung)
    
      - Remove redundant "default n" from Kconfig (Bartlomiej Zolnierkiewicz)
    
    * pci/misc:
      PCI: pcie: Remove redundant 'default n' from Kconfig
      NTB: switchtec_ntb: Update switchtec documentation with prerequisites for NTB
      PCI: Fix Switchtec DMA aliasing quirk dmesg noise
      PCI: Add macro for Switchtec quirk declarations
      PCI: Add Device IDs for Intel GPU "spurious interrupt" quirk
      PCI: Remove pci_set_dma_max_seg_size()
      PCI: Remove pci_set_dma_seg_boundary()
      PCI: Remove pci_unmap_addr() wrappers for DMA API
      PCI / ACPI: Mark expected switch fall-through
      PCI: Remove set but unused variable
      PCI: Fix pci.c kernel-doc parameter warning
      PCI: Allocate dma_alias_mask with bitmap_zalloc()
      PCI: Remove unused NFP32xx IDs

commit 20634dc361e1c5fe2dae380a7d0a21ca7f32c4f7
Merge: de468b755464 e51cd9ce5dd3
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Sat Oct 20 11:45:29 2018 -0500

    Merge branch 'pci/hotplug'
    
      - Differentiate between pciehp surprise and safe removal (Lukas Wunner)
    
      - Remove unnecessary pciehp includes (Lukas Wunner)
    
      - Drop pciehp hotplug_slot_ops wrappers (Lukas Wunner)
    
      - Tolerate PCIe Slot Presence Detect being hardwired to zero to
        workaround broken hardware, e.g., the Wilocity switch/wireless device
        (Lukas Wunner)
    
      - Unify pciehp controller & slot structs (Lukas Wunner)
    
      - Constify hotplug_slot_ops (Lukas Wunner)
    
      - Drop hotplug_slot_info (Lukas Wunner)
    
      - Embed hotplug_slot struct into users instead of allocating it
        separately (Lukas Wunner)
    
      - Initialize PCIe port service drivers directly instead of relying on
        initcall ordering (Keith Busch)
    
      - Restore PCI config state after a slot reset (Keith Busch)
    
      - Save/restore DPC config state along with other PCI config state (Keith
        Busch)
    
      - Reference count devices during AER handling to avoid race issue with
        concurrent hot removal (Keith Busch)
    
      - If an Upstream Port reports ERR_FATAL, don't try to read the Port's
        config space because it is probably unreachable (Keith Busch)
    
      - During error handling, use slot-specific reset instead of secondary
        bus reset to avoid link up/down issues on hotplug ports (Keith Busch)
    
      - Restore previous AER/DPC handling that does not remove and re-enumerate
        devices on ERR_FATAL (Keith Busch)
    
      - Notify all drivers that may be affected by error recovery resets (Keith
        Busch)
    
      - Always generate error recovery uevents, even if a driver doesn't have
        error callbacks (Keith Busch)
    
      - Make PCIe link active reporting detection generic (Keith Busch)
    
      - Support D3cold in PCIe hierarchies during system sleep and runtime,
        including hotplug and Thunderbolt ports (Mika Westerberg)
    
      - Handle hpmemsize/hpiosize kernel parameters uniformly, whether slots
        are empty or occupied (Jon Derrick)
    
      - Remove duplicated include from pci/pcie/err.c and unused variable from
        cpqphp (YueHaibing)
    
      - Remove driver pci_cleanup_aer_uncorrect_error_status() calls (Oza
        Pawandeep)
    
      - Uninline PCI bus accessors for better ftracing (Keith Busch)
    
      - Remove unused AER Root Port .error_resume method (Keith Busch)
    
      - Use kfifo in AER instead of a local version (Keith Busch)
    
      - Use threaded IRQ in AER bottom half (Keith Busch)
    
      - Use managed resources in AER core (Keith Busch)
    
      - Reuse pcie_port_find_device() for AER injection (Keith Busch)
    
      - Abstract AER interrupt handling to disconnect error injection (Keith
        Busch)
    
      - Refactor AER injection callbacks to simplify future improvments (Keith
        Busch)
    
    * pci/hotplug:
      PCI/AER: Refactor error injection fallbacks
      PCI/AER: Abstract AER interrupt handling
      PCI/AER: Reuse existing pcie_port_find_device() interface
      PCI/AER: Use managed resource allocations
      PCI/AER: Use threaded IRQ for bottom half
      PCI/AER: Use kfifo_in_spinlocked() to insert locked elements
      PCI/AER: Use kfifo for tracking events instead of reimplementing it
      PCI/AER: Remove error source from AER struct aer_rpc
      PCI/AER: Remove unused aer_error_resume()
      PCI: Uninline PCI bus accessors for better ftracing
      PCI/AER: Remove pci_cleanup_aer_uncorrect_error_status() calls
      PCI: pnv_php: Use kmemdup()
      PCI: cpqphp: Remove set but not used variable 'physical_slot'
      PCI/ERR: Remove duplicated include from err.c
      PCI: Equalize hotplug memory and io for occupied and empty slots
      PCI / ACPI: Whitelist D3 for more PCIe hotplug ports
      ACPI / property: Allow multiple property compatible _DSD entries
      PCI/PME: Implement runtime PM callbacks
      PCI: pciehp: Implement runtime PM callbacks
      PCI/portdrv: Add runtime PM hooks for port service drivers
      PCI/portdrv: Resume upon exit from system suspend if left runtime suspended
      PCI: pciehp: Do not handle events if interrupts are masked
      PCI: pciehp: Disable hotplug interrupt during suspend
      PCI / ACPI: Enable wake automatically for power managed bridges
      PCI: Do not skip power-managed bridges in pci_enable_wake()
      PCI: Make link active reporting detection generic
      PCI: Unify device inaccessible
      PCI/ERR: Always report current recovery status for udev
      PCI/ERR: Simplify broadcast callouts
      PCI/ERR: Run error recovery callbacks for all affected devices
      PCI/ERR: Handle fatal error recovery
      PCI/ERR: Use slot reset if available
      PCI/AER: Don't read upstream ports below fatal errors
      PCI/AER: Take reference on error devices
      PCI/DPC: Save and restore config state
      PCI: portdrv: Restore PCI config state on slot reset
      PCI: portdrv: Initialize service drivers directly
      PCI: hotplug: Document TODOs
      PCI: hotplug: Embed hotplug_slot
      PCI: hotplug: Drop hotplug_slot_info
      PCI: hotplug: Constify hotplug_slot_ops
      PCI: pciehp: Reshuffle controller struct for clarity
      PCI: pciehp: Rename controller struct members for clarity
      PCI: pciehp: Unify controller and slot structs
      PCI: pciehp: Tolerate Presence Detect hardwired to zero
      PCI: pciehp: Drop hotplug_slot_ops wrappers
      PCI: pciehp: Drop unnecessary includes
      PCI: pciehp: Differentiate between surprise and safe removal
      PCI: Simplify disconnected marking

commit fa295becc533234e4b1ea774caed2446a65ff695
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Thu Oct 4 17:40:41 2018 +0200

    PCI / ACPI: Mark expected switch fall-through
    
    In preparation to enabling -Wimplicit-fallthrough, mark switch cases
    where we are expecting to fall through.
    
    Addresses-Coverity-ID: 1472052 ("Missing break in switch")
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index c2ab57705043..deb96d1a4728 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -548,6 +548,7 @@ static int acpi_pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 			error = -EBUSY;
 			break;
 		}
+		/* Fall through */
 	case PCI_D0:
 	case PCI_D1:
 	case PCI_D2:

commit 26ad34d510a87fc65caeb48fa85cce58d2477a88
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Thu Sep 27 16:57:14 2018 -0500

    PCI / ACPI: Whitelist D3 for more PCIe hotplug ports
    
    In order to have better power management for Thunderbolt PCIe chains,
    Windows enables power management for native PCIe hotplug ports if there is
    the following ACPI _DSD attached to the root port:
    
      Name (_DSD, Package () {
          ToUUID ("6211e2c0-58a3-4af3-90e1-927a4e0c55a4"),
          Package () {
              Package () {"HotPlugSupportInD3", 1}
          }
      })
    
    This is also documented in:
    
      https://docs.microsoft.com/en-us/windows-hardware/drivers/pci/dsd-for-pcie-root-ports#identifying-pcie-root-ports-supporting-hot-plug-in-d3
    
    Do the same in Linux by introducing new firmware PM callback
    (->bridge_d3()) and then implement it for ACPI based systems so that the
    above property is checked.
    
    There is one catch, though. The initial pci_dev->bridge_d3 is set before
    the root port has ACPI companion bound (the device is not added to the PCI
    bus either) so we need to look up the ACPI companion manually in that case
    in acpi_pci_bridge_d3().
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index f8436d1c4d45..c8d0549580f4 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -519,6 +519,46 @@ static pci_power_t acpi_pci_choose_state(struct pci_dev *pdev)
 	return PCI_POWER_ERROR;
 }
 
+static struct acpi_device *acpi_pci_find_companion(struct device *dev);
+
+static bool acpi_pci_bridge_d3(struct pci_dev *dev)
+{
+	const struct fwnode_handle *fwnode;
+	struct acpi_device *adev;
+	struct pci_dev *root;
+	u8 val;
+
+	if (!dev->is_hotplug_bridge)
+		return false;
+
+	/*
+	 * Look for a special _DSD property for the root port and if it
+	 * is set we know the hierarchy behind it supports D3 just fine.
+	 */
+	root = pci_find_pcie_root_port(dev);
+	if (!root)
+		return false;
+
+	adev = ACPI_COMPANION(&root->dev);
+	if (root == dev) {
+		/*
+		 * It is possible that the ACPI companion is not yet bound
+		 * for the root port so look it up manually here.
+		 */
+		if (!adev && !pci_dev_is_added(root))
+			adev = acpi_pci_find_companion(&root->dev);
+	}
+
+	if (!adev)
+		return false;
+
+	fwnode = acpi_fwnode_handle(adev);
+	if (fwnode_property_read_u8(fwnode, "HotPlugSupportInD3", &val))
+		return false;
+
+	return val == 1;
+}
+
 static bool acpi_pci_power_manageable(struct pci_dev *dev)
 {
 	struct acpi_device *adev = ACPI_COMPANION(&dev->dev);
@@ -635,6 +675,7 @@ static bool acpi_pci_need_resume(struct pci_dev *dev)
 }
 
 static const struct pci_platform_pm_ops acpi_pci_platform_pm = {
+	.bridge_d3 = acpi_pci_bridge_d3,
 	.is_manageable = acpi_pci_power_manageable,
 	.set_state = acpi_pci_set_power_state,
 	.get_state = acpi_pci_get_power_state,

commit 6299cf9ec3985cac70bede8a855b5087b81a6640
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Thu Sep 27 16:54:13 2018 -0500

    PCI / ACPI: Enable wake automatically for power managed bridges
    
    We enable power management automatically for bridges where
    pci_bridge_d3_possible() returns true. However, these bridges may have
    ACPI methods such as _DSW that need to be called before D3 entry. For
    example in Lenovo Thinkpad X1 Carbon 6th _DSW method is used to prepare
    D3cold for the PCIe root port hosting Thunderbolt chain. Because wake is
    not enabled _DSW method is never called and the port does not enter
    D3cold properly consuming more power than necessary.
    
    Users can work this around by writing "enabled" to "wakeup" sysfs file
    under the device in question but that is not something an ordinary user
    is expected to do.
    
    Since we already automatically enable power management for PCIe ports
    with ->bridge_d3 set extend that to enable wake for them as well,
    assuming the port has any ACPI wakeup related objects implemented in the
    namespace (adev->wakeup.flags.valid is true). This ensures the necessary
    ACPI methods get called at appropriate times and allows the root port in
    Thinkpad X1 Carbon 6th to go into D3cold.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index c2ab57705043..f8436d1c4d45 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -762,19 +762,33 @@ static void pci_acpi_setup(struct device *dev)
 		return;
 
 	device_set_wakeup_capable(dev, true);
+	/*
+	 * For bridges that can do D3 we enable wake automatically (as
+	 * we do for the power management itself in that case). The
+	 * reason is that the bridge may have additional methods such as
+	 * _DSW that need to be called.
+	 */
+	if (pci_dev->bridge_d3)
+		device_wakeup_enable(dev);
+
 	acpi_pci_wakeup(pci_dev, false);
 }
 
 static void pci_acpi_cleanup(struct device *dev)
 {
 	struct acpi_device *adev = ACPI_COMPANION(dev);
+	struct pci_dev *pci_dev = to_pci_dev(dev);
 
 	if (!adev)
 		return;
 
 	pci_acpi_remove_pm_notifier(adev);
-	if (adev->wakeup.flags.valid)
+	if (adev->wakeup.flags.valid) {
+		if (pci_dev->bridge_d3)
+			device_wakeup_disable(dev);
+
 		device_set_wakeup_capable(dev, false);
+	}
 }
 
 static bool pci_acpi_bus_match(struct device *dev)

commit bad7dcd94f3956bcfc0a69ef71fdf0fcca3de4a8
Author: Jonathan Cameron <Jonathan.Cameron@huawei.com>
Date:   Wed Sep 12 16:21:40 2018 +0100

    ACPI/PCI: Pay attention to device-specific _PXM node values
    
    The ACPI specification allows you to provide _PXM entries for devices based
    on their location on a particular bus.  Let us use that if it is provided
    rather than just assuming it makes sense to put the device into the
    proximity domain of the root.
    
    An example DSDT entry that will supply this is:
    
      Device (PCI2)
      {
        Name (_HID, "PNP0A08") // PCI Express Root Bridge
        Name (_CID, "PNP0A03") // Compatible PCI Root Bridge
        Name(_SEG, 2) // Segment of this Root complex
        Name(_BBN, 0xF8) // Base Bus Number
        Name(_CCA, 1)
        Method (_PXM, 0, NotSerialized) {
          Return(0x00)
        }
    
        ...
        Device (BRI0) {
          Name (_HID, "19E51610")
          Name (_ADR, 0)
          Name (_BBN, 0xF9)
          Device (CAR0) {
            Name (_HID, "97109912")
            Name (_ADR, 0)
            Method (_PXM, 0, NotSerialized) {
              Return(0x02)
            }
          }
        }
      }
    
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index c2ab57705043..8f75ba068d45 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -751,10 +751,15 @@ static void pci_acpi_setup(struct device *dev)
 {
 	struct pci_dev *pci_dev = to_pci_dev(dev);
 	struct acpi_device *adev = ACPI_COMPANION(dev);
+	int node;
 
 	if (!adev)
 		return;
 
+	node = acpi_get_node(adev->handle);
+	if (node != NUMA_NO_NODE)
+		set_dev_node(dev, node);
+
 	pci_acpi_optimize_delay(pci_dev, adev->handle);
 
 	pci_acpi_add_pm_notifier(adev, pci_dev);

commit dfec4a8478e8e81483a94b663f13153bb7796800
Merge: 159127ea8318 01ac7c4c2e03
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Aug 22 07:42:36 2018 -0700

    Merge tag 'pm-4.19-rc1-2' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull more power management updates from Rafael Wysocki:
     "These fix the main idle loop and the menu cpuidle governor, clean up
      the latter, fix a mistake in the PCI bus type's support for system
      suspend and resume, fix the ondemand and conservative cpufreq
      governors, address a build issue in the system wakeup framework and
      make the ACPI C-states desciptions less confusing.
    
      Specifics:
    
       - Make the idle loop handle stopped scheduler tick correctly (Rafael
         Wysocki).
    
       - Prevent the menu cpuidle governor from letting CPUs spend too much
         time in shallow idle states when it is invoked with scheduler tick
         stopped and clean it up somewhat (Rafael Wysocki).
    
       - Avoid invoking the platform firmware to make the platform enter the
         ACPI S3 sleep state with suspended PCIe root ports which may
         confuse the firmware and cause it to crash (Rafael Wysocki).
    
       - Fix sysfs-related race in the ondemand and conservative cpufreq
         governors which may cause the system to crash if the governor
         module is removed during an update of CPU frequency limits (Henry
         Willard).
    
       - Select SRCU when building the system wakeup framework to avoid a
         build issue in it (zhangyi).
    
       - Make the descriptions of ACPI C-states vendor-neutral to avoid
         confusion (Prarit Bhargava)"
    
    * tag 'pm-4.19-rc1-2' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm:
      cpuidle: menu: Handle stopped tick more aggressively
      sched: idle: Avoid retaining the tick when it has been stopped
      PCI / ACPI / PM: Resume all bridges on suspend-to-RAM
      cpuidle: menu: Update stale polling override comment
      cpufreq: governor: Avoid accessing invalid governor_data
      x86/ACPI/cstate: Make APCI C1 FFH MWAIT C-state description vendor-neutral
      cpuidle: menu: Fix white space
      PM / sleep: wakeup: Fix build error caused by missing SRCU support

commit 9d64b539b738fc181442caab95f1f76d9bd58539
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Aug 16 12:56:46 2018 +0200

    PCI / ACPI / PM: Resume all bridges on suspend-to-RAM
    
    Commit 26112ddc254c (PCI / ACPI / PM: Resume bridges w/o drivers on
    suspend-to-RAM) attempted to fix a functional regression resulting
    from commit c62ec4610c40 (PM / core: Fix direct_complete handling
    for devices with no callbacks) by resuming PCI bridges without
    drivers (that is, "parallel PCI" ones) during system-wide suspend if
    the target system state is not ACPI S0 (working state).
    
    That turns out insufficient, however, as it is reported that, at
    least in one case, the platform firmware gets confused if a PCIe
    root port is suspended before entering the ACPI S3 sleep state.
    That issue was exposed by commit 77b3729ca03 (PCI / PM: Use
    SMART_SUSPEND and LEAVE_SUSPENDED flags for PCIe ports) that allowed
    PCIe ports to stay in runtime suspend during system-wide suspend
    (which is OK for suspend-to-idle, but turns out to be problematic
    otherwise).
    
    For this reason, drop the driver check from acpi_pci_need_resume()
    and resume all bridges (including PCIe ports with drivers) during
    system-wide suspend if the target system state is not ACPI S0.
    
    [If the target system state is ACPI S0, it means suspend-to-idle
     and the platform firmware is not going to be invoked to actually
     suspend the system, so there is no need to resume the bridges in
     that case.]
    
    Fixes: 77b3729ca03 (PCI / PM: Use SMART_SUSPEND and LEAVE_SUSPENDED flags for PCIe ports)
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=200675
    Reported-by: teika kazura <teika@gmx.com>
    Tested-by: teika kazura <teika@gmx.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: 4.16+ <stable@vger.kernel.org> # 4.16+: 26112ddc254c (PCI / ACPI / PM: Resume bridges ...)
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 89ee6a2b6eb8..5d1698265da5 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -632,13 +632,11 @@ static bool acpi_pci_need_resume(struct pci_dev *dev)
 	/*
 	 * In some cases (eg. Samsung 305V4A) leaving a bridge in suspend over
 	 * system-wide suspend/resume confuses the platform firmware, so avoid
-	 * doing that, unless the bridge has a driver that should take care of
-	 * the PM handling.  According to Section 16.1.6 of ACPI 6.2, endpoint
+	 * doing that.  According to Section 16.1.6 of ACPI 6.2, endpoint
 	 * devices are expected to be in D3 before invoking the S3 entry path
 	 * from the firmware, so they should not be affected by this issue.
 	 */
-	if (pci_is_bridge(dev) && !dev->driver &&
-	    acpi_target_system_state() != ACPI_STATE_S0)
+	if (pci_is_bridge(dev) && acpi_target_system_state() != ACPI_STATE_S0)
 		return true;
 
 	if (!adev || !acpi_device_power_manageable(adev))

commit 4e31843f681c34f7185e7d169fe627c9d891ce2c
Merge: f91e654474d4 fa687fb9ced4
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Aug 16 09:21:54 2018 -0700

    Merge tag 'pci-v4.19-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull pci updates from Bjorn Helgaas:
    
     - Decode AER errors with names similar to "lspci" (Tyler Baicar)
    
     - Expose AER statistics in sysfs (Rajat Jain)
    
     - Clear AER status bits selectively based on the type of recovery (Oza
       Pawandeep)
    
     - Honor "pcie_ports=native" even if HEST sets FIRMWARE_FIRST (Alexandru
       Gagniuc)
    
     - Don't clear AER status bits if we're using the "Firmware-First"
       strategy where firmware owns the registers (Alexandru Gagniuc)
    
     - Use sysfs_match_string() to simplify ASPM sysfs parsing (Andy
       Shevchenko)
    
     - Remove unnecessary includes of <linux/pci-aspm.h> (Bjorn Helgaas)
    
     - Defer DPC event handling to work queue (Keith Busch)
    
     - Use threaded IRQ for DPC bottom half (Keith Busch)
    
     - Print AER status while handling DPC events (Keith Busch)
    
     - Work around IDT switch ACS Source Validation erratum (James
       Puthukattukaran)
    
     - Emit diagnostics for all cases of PCIe Link downtraining (Links
       operating slower than they're capable of) (Alexandru Gagniuc)
    
     - Skip VFs when configuring Max Payload Size (Myron Stowe)
    
     - Reduce Root Port Max Payload Size if necessary when hot-adding a
       device below it (Myron Stowe)
    
     - Simplify SHPC existence/permission checks (Bjorn Helgaas)
    
     - Remove hotplug sample skeleton driver (Lukas Wunner)
    
     - Convert pciehp to threaded IRQ handling (Lukas Wunner)
    
     - Improve pciehp tolerance of missed events and initially unstable
       links (Lukas Wunner)
    
     - Clear spurious pciehp events on resume (Lukas Wunner)
    
     - Add pciehp runtime PM support, including for Thunderbolt controllers
       (Lukas Wunner)
    
     - Support interrupts from pciehp bridges in D3hot (Lukas Wunner)
    
     - Mark fall-through switch cases before enabling -Wimplicit-fallthrough
       (Gustavo A. R. Silva)
    
     - Move DMA-debug PCI init from arch code to PCI core (Christoph
       Hellwig)
    
     - Fix pci_request_irq() usage of IRQF_ONESHOT when no handler is
       supplied (Heiner Kallweit)
    
     - Unify PCI and DMA direction #defines (Shunyong Yang)
    
     - Add PCI_DEVICE_DATA() macro (Andy Shevchenko)
    
     - Check for VPD completion before checking for timeout (Bert Kenward)
    
     - Limit Netronome NFP5000 config space size to work around erratum
       (Jakub Kicinski)
    
     - Set IRQCHIP_ONESHOT_SAFE for PCI MSI irqchips (Heiner Kallweit)
    
     - Document ACPI description of PCI host bridges (Bjorn Helgaas)
    
     - Add "pci=disable_acs_redir=" parameter to disable ACS redirection for
       peer-to-peer DMA support (we don't have the peer-to-peer support yet;
       this is just one piece) (Logan Gunthorpe)
    
     - Clean up devm_of_pci_get_host_bridge_resources() resource allocation
       (Jan Kiszka)
    
     - Fixup resizable BARs after suspend/resume (Christian König)
    
     - Make "pci=earlydump" generic (Sinan Kaya)
    
     - Fix ROM BAR access routines to stay in bounds and check for signature
       correctly (Rex Zhu)
    
     - Add DMA alias quirk for Microsemi Switchtec NTB (Doug Meyer)
    
     - Expand documentation for pci_add_dma_alias() (Logan Gunthorpe)
    
     - To avoid bus errors, enable PASID only if entire path supports
       End-End TLP prefixes (Sinan Kaya)
    
     - Unify slot and bus reset functions and remove hotplug knowledge from
       callers (Sinan Kaya)
    
     - Add Function-Level Reset quirks for Intel and Samsung NVMe devices to
       fix guest reboot issues (Alex Williamson)
    
     - Add function 1 DMA alias quirk for Marvell 88SS9183 PCIe SSD
       Controller (Bjorn Helgaas)
    
     - Remove Xilinx AXI-PCIe host bridge arch dependency (Palmer Dabbelt)
    
     - Remove Aardvark outbound window configuration (Evan Wang)
    
     - Fix Aardvark bridge window sizing issue (Zachary Zhang)
    
     - Convert Aardvark to use pci_host_probe() to reduce code duplication
       (Thomas Petazzoni)
    
     - Correct the Cadence cdns_pcie_writel() signature (Alan Douglas)
    
     - Add Cadence support for optional generic PHYs (Alan Douglas)
    
     - Add Cadence power management ops (Alan Douglas)
    
     - Remove redundant variable from Cadence driver (Colin Ian King)
    
     - Add Kirin MSI support (Xiaowei Song)
    
     - Drop unnecessary root_bus_nr setting from exynos, imx6, keystone,
       armada8k, artpec6, designware-plat, histb, qcom, spear13xx (Shawn
       Guo)
    
     - Move link notification settings from DesignWare core to individual
       drivers (Gustavo Pimentel)
    
     - Add endpoint library MSI-X interfaces (Gustavo Pimentel)
    
     - Correct signature of endpoint library IRQ interfaces (Gustavo
       Pimentel)
    
     - Add DesignWare endpoint library MSI-X callbacks (Gustavo Pimentel)
    
     - Add endpoint library MSI-X test support (Gustavo Pimentel)
    
     - Remove unnecessary GFP_ATOMIC from Hyper-V "new child" allocation
       (Jia-Ju Bai)
    
     - Add more devices to Broadcom PAXC quirk (Ray Jui)
    
     - Work around corrupted Broadcom PAXC config space to enable SMMU and
       GICv3 ITS (Ray Jui)
    
     - Disable MSI parsing to work around broken Broadcom PAXC logic in some
       devices (Ray Jui)
    
     - Hide unconfigured functions to work around a Broadcom PAXC defect
       (Ray Jui)
    
     - Lower iproc log level to reduce console output during boot (Ray Jui)
    
     - Fix mobiveil iomem/phys_addr_t type usage (Lorenzo Pieralisi)
    
     - Fix mobiveil missing include file (Lorenzo Pieralisi)
    
     - Add mobiveil Kconfig/Makefile support (Lorenzo Pieralisi)
    
     - Fix mvebu I/O space remapping issues (Thomas Petazzoni)
    
     - Use generic pci_host_bridge in mvebu instead of ARM-specific API
       (Thomas Petazzoni)
    
     - Whitelist VMD devices with fast interrupt handlers to avoid sharing
       vectors with slow handlers (Keith Busch)
    
    * tag 'pci-v4.19-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (153 commits)
      PCI/AER: Don't clear AER bits if error handling is Firmware-First
      PCI: Limit config space size for Netronome NFP5000
      PCI/MSI: Set IRQCHIP_ONESHOT_SAFE for PCI-MSI irqchips
      PCI/VPD: Check for VPD access completion before checking for timeout
      PCI: Add PCI_DEVICE_DATA() macro to fully describe device ID entry
      PCI: Match Root Port's MPS to endpoint's MPSS as necessary
      PCI: Skip MPS logic for Virtual Functions (VFs)
      PCI: Add function 1 DMA alias quirk for Marvell 88SS9183
      PCI: Check for PCIe Link downtraining
      PCI: Add ACS Redirect disable quirk for Intel Sunrise Point
      PCI: Add device-specific ACS Redirect disable infrastructure
      PCI: Convert device-specific ACS quirks from NULL termination to ARRAY_SIZE
      PCI: Add "pci=disable_acs_redir=" parameter for peer-to-peer support
      PCI: Allow specifying devices using a base bus and path of devfns
      PCI: Make specifying PCI devices in kernel parameters reusable
      PCI: Hide ACS quirk declarations inside PCI core
      PCI: Delay after FLR of Intel DC P3700 NVMe
      PCI: Disable Samsung SM961/PM961 NVMe before FLR
      PCI: Export pcie_has_flr()
      PCI: mvebu: Drop bogus comment above mvebu_pcie_map_registers()
      ...

commit 26112ddc254c98681b224aa9ededefc01b6e02d2
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Jun 30 23:19:33 2018 +0200

    PCI / ACPI / PM: Resume bridges w/o drivers on suspend-to-RAM
    
    It is reported that commit c62ec4610c40 (PM / core: Fix direct_complete
    handling for devices with no callbacks) introduced a system suspend
    regression on Samsung 305V4A by allowing a PCI bridge (not a PCIe
    port) to stay in D3 over suspend-to-RAM, which is a side effect of
    setting power.direct_complete for the children of that bridge that
    have no PM callbacks.
    
    On the majority of systems PCI bridges are not allowed to be
    runtime-suspended (the power/control sysfs attribute is set to "on"
    for them by default), but user space can change that setting and if
    it does so and a given bridge has no children with PM callbacks, the
    direct_complete optimization will be applied to it and it will stay
    in suspend over system suspend.  Apparently, that confuses the
    platform firmware on the affected machine and that may very well
    happen elsewhere, so avoid the direct_complete optimization for
    PCI bridges with no drivers (if there is a driver, it should take
    care of the PM handling) on suspend-to-RAM altogether (that should
    not matter for suspend-to-idle as platform firmware is not involved
    in it).
    
    Fixes: c62ec4610c40 (PM / core: Fix direct_complete handling for devices with no callbacks)
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=199941
    Reported-by: n0000b.n000b@gmail.com
    Tested-by: n0000b.n000b@gmail.com
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: 4.15+ <stable@vger.kernel.org> # 4.15+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 65113b6eed14..89ee6a2b6eb8 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -629,6 +629,18 @@ static bool acpi_pci_need_resume(struct pci_dev *dev)
 {
 	struct acpi_device *adev = ACPI_COMPANION(&dev->dev);
 
+	/*
+	 * In some cases (eg. Samsung 305V4A) leaving a bridge in suspend over
+	 * system-wide suspend/resume confuses the platform firmware, so avoid
+	 * doing that, unless the bridge has a driver that should take care of
+	 * the PM handling.  According to Section 16.1.6 of ACPI 6.2, endpoint
+	 * devices are expected to be in D3 before invoking the S3 entry path
+	 * from the firmware, so they should not be affected by this issue.
+	 */
+	if (pci_is_bridge(dev) && !dev->driver &&
+	    acpi_target_system_state() != ACPI_STATE_S0)
+		return true;
+
 	if (!adev || !acpi_device_power_manageable(adev))
 		return false;
 

commit b03799b0cb35dbc39e89602b1203863e2a6e06bf
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Jun 25 16:49:06 2018 -0500

    PCI: shpchp: Separate existence of SHPC and permission to use it
    
    The shpchp driver registers for all PCI bridge devices.  Its probe method
    should fail if either (1) the bridge doesn't have an SHPC or (2) the OS
    isn't allowed to use it (the platform firmware may be operating the SHPC
    itself).
    
    Separate these two tests into:
    
      - A new shpc_capable() that looks for the SHPC hardware and is applicable
        on all systems (ACPI and non-ACPI), and
    
      - A simplified acpi_get_hp_hw_control_from_firmware() that we call only
        when we already know an SHPC exists and there may be ACPI methods to
        either request permission to use it (_OSC) or transfer control to the
        OS (OSHP).
    
    acpi_get_hp_hw_control_from_firmware() is implemented when CONFIG_ACPI=y,
    but does nothing if the current platform doesn't support ACPI.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 65113b6eed14..5100fd2d5a75 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -403,24 +403,7 @@ bool pciehp_is_native(struct pci_dev *bridge)
  */
 bool shpchp_is_native(struct pci_dev *bridge)
 {
-	const struct pci_host_bridge *host;
-
-	if (!IS_ENABLED(CONFIG_HOTPLUG_PCI_SHPC))
-		return false;
-
-	/*
-	 * It is assumed that AMD GOLAM chips support SHPC but they do not
-	 * have SHPC capability.
-	 */
-	if (bridge->vendor == PCI_VENDOR_ID_AMD &&
-	    bridge->device == PCI_DEVICE_ID_AMD_GOLAM_7450)
-		return true;
-
-	if (!pci_find_capability(bridge, PCI_CAP_ID_SHPC))
-		return false;
-
-	host = pci_find_host_bridge(bridge->bus);
-	return host->native_shpc_hotplug;
+	return bridge->shpc_managed;
 }
 
 /**

commit 90cc0c3cc7092ea4c7871fdd5fb00a9ba62842e3
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Thu May 31 11:42:11 2018 -0500

    PCI: shpchp: Add shpchp_is_native()
    
    In the same way we do for pciehp, add shpchp_is_native(), which returns
    true if the bridge should be handled by the native SHPC driver.  Then
    convert the driver to use this function.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 52b8434d4d6e..65113b6eed14 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -394,6 +394,35 @@ bool pciehp_is_native(struct pci_dev *bridge)
 	return host->native_pcie_hotplug;
 }
 
+/**
+ * shpchp_is_native - Check whether a hotplug port is handled by the OS
+ * @bridge: Hotplug port to check
+ *
+ * Returns true if the given @bridge is handled by the native SHPC hotplug
+ * driver.
+ */
+bool shpchp_is_native(struct pci_dev *bridge)
+{
+	const struct pci_host_bridge *host;
+
+	if (!IS_ENABLED(CONFIG_HOTPLUG_PCI_SHPC))
+		return false;
+
+	/*
+	 * It is assumed that AMD GOLAM chips support SHPC but they do not
+	 * have SHPC capability.
+	 */
+	if (bridge->vendor == PCI_VENDOR_ID_AMD &&
+	    bridge->device == PCI_DEVICE_ID_AMD_GOLAM_7450)
+		return true;
+
+	if (!pci_find_capability(bridge, PCI_CAP_ID_SHPC))
+		return false;
+
+	host = pci_find_host_bridge(bridge->bus);
+	return host->native_shpc_hotplug;
+}
+
 /**
  * pci_acpi_wake_bus - Root bus wakeup notification fork function.
  * @context: Device wakeup context.

commit 5352a44a561d708f1a975a90f5ce16a054fe265c
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Wed May 23 17:24:08 2018 -0500

    PCI: pciehp: Make pciehp_is_native() stricter
    
    Previously pciehp_is_native() returned true for any PCI device in a
    hierarchy where _OSC says we can use pciehp.  This is incorrect because
    bridges without PCI_EXP_SLTCAP_HPC capability should be managed by acpiphp
    instead.
    
    Improve pciehp_is_native() to return true only when PCI_EXP_SLTCAP_HPC is
    set and the pciehp driver is present.  In any other case return false
    to let acpiphp handle those.
    
    Suggested-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    [bhelgaas: remove NULL pointer check]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 1abdbf267c19..52b8434d4d6e 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -370,26 +370,28 @@ EXPORT_SYMBOL_GPL(pci_get_hp_params);
 
 /**
  * pciehp_is_native - Check whether a hotplug port is handled by the OS
- * @pdev: Hotplug port to check
+ * @bridge: Hotplug port to check
  *
- * Walk up from @pdev to the host bridge, obtain its cached _OSC Control Field
- * and return the value of the "PCI Express Native Hot Plug control" bit.
- * On failure to obtain the _OSC Control Field return %false.
+ * Returns true if the given @bridge is handled by the native PCIe hotplug
+ * driver.
  */
-bool pciehp_is_native(struct pci_dev *pdev)
+bool pciehp_is_native(struct pci_dev *bridge)
 {
-	struct acpi_pci_root *root;
-	acpi_handle handle;
+	const struct pci_host_bridge *host;
+	u32 slot_cap;
 
-	handle = acpi_find_root_bridge_handle(pdev);
-	if (!handle)
+	if (!IS_ENABLED(CONFIG_HOTPLUG_PCI_PCIE))
 		return false;
 
-	root = acpi_pci_find_root(handle);
-	if (!root)
+	pcie_capability_read_dword(bridge, PCI_EXP_SLTCAP, &slot_cap);
+	if (!(slot_cap & PCI_EXP_SLTCAP_HPC))
 		return false;
 
-	return root->osc_control_set & OSC_PCI_EXPRESS_NATIVE_HP_CONTROL;
+	if (pcie_ports_native)
+		return true;
+
+	host = pci_find_host_bridge(bridge->bus);
+	return host->native_pcie_hotplug;
 }
 
 /**

commit df62ab5e0f75608919df7442654b0fab78246b7b
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Mar 9 16:36:33 2018 -0600

    PCI: Tidy comments
    
    Remove pointless comments that tell us the file name, remove blank line
    comments, follow multi-line comment conventions.  No functional change
    intended.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 78157688dcc9..1abdbf267c19 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -1,7 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * File:	pci-acpi.c
- * Purpose:	Provide PCI support in ACPI
+ * PCI support in ACPI
  *
  * Copyright (C) 2005 David Shaohua Li <shaohua.li@intel.com>
  * Copyright (C) 2004 Tom Long Nguyen <tom.l.nguyen@intel.com>

commit ab8c609356fbe8dbcd44df11e884ce8cddf3739e
Merge: a5fae846f21d 36b072742a83
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Feb 1 11:40:07 2018 -0600

    Merge branch 'pci/spdx' into next
    
    * pci/spdx:
      PCI: Add SPDX GPL-2.0+ to replace implicit GPL v2 or later statement
      PCI: Add SPDX GPL-2.0+ to replace GPL v2 or later boilerplate
      PCI: Add SPDX GPL-2.0 to replace COPYING boilerplate
      PCI: Add SPDX GPL-2.0 to replace GPL v2 boilerplate
      PCI: Add SPDX GPL-2.0 when no license was specified

commit 7328c8f48d1895b3fec98b0b319cfb856b4c4fa1
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Jan 26 11:45:16 2018 -0600

    PCI: Add SPDX GPL-2.0 when no license was specified
    
    b24413180f56 ("License cleanup: add SPDX GPL-2.0 license identifier to
    files with no license") added SPDX GPL-2.0 to several PCI files that
    previously contained no license information.
    
    Add SPDX GPL-2.0 to all other PCI files that did not contain any license
    information and hence were under the default GPL version 2 license of the
    kernel.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 4708eb9df71b..3b82bb86a203 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * File:	pci-acpi.c
  * Purpose:	Provide PCI support in ACPI

commit 7506dc7989933235e6fc23f3d0516bdbf0f7d1a8
Author: Frederick Lawler <fred@fredlawl.com>
Date:   Thu Jan 18 12:55:24 2018 -0600

    PCI: Add wrappers for dev_printk()
    
    Add PCI-specific dev_printk() wrappers and use them to simplify the code
    slightly.  No functional change intended.
    
    Signed-off-by: Frederick Lawler <fred@fredlawl.com>
    [bhelgaas: squash into one patch]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 4708eb9df71b..189e6ccf3589 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -542,7 +542,7 @@ static int acpi_pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 	}
 
 	if (!error)
-		dev_dbg(&dev->dev, "power state changed by ACPI to %s\n",
+		pci_dbg(dev, "power state changed by ACPI to %s\n",
 			 acpi_power_state_string(state_conv[state]));
 
 	return error;

commit a0040c0145945d3bd203df8fa97f6dfa819f3f7d
Author: Vitaly Kuznetsov <vkuznets@redhat.com>
Date:   Thu Sep 14 16:50:14 2017 +0200

    ACPI / PCI: Bail early in acpi_pci_add_bus() if there is no ACPI handle
    
    Hyper-V instances support PCI pass-through which is implemented through PV
    pci-hyperv driver. When a device is passed through, a new root PCI bus is
    created in the guest. The bus sits on top of VMBus and has no associated
    information in ACPI. acpi_pci_add_bus() in this case proceeds all the way
    to acpi_evaluate_dsm(), which reports
    
      ACPI: \: failed to evaluate _DSM (0x1001)
    
    While acpi_pci_slot_enumerate() and acpiphp_enumerate_slots() are protected
    against ACPI_HANDLE() being NULL and do nothing, acpi_evaluate_dsm() is not
    and gives us the error. It seems the correct fix is to not do anything in
    acpi_pci_add_bus() in such cases.
    
    Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index a8da543b3814..4708eb9df71b 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -624,7 +624,7 @@ void acpi_pci_add_bus(struct pci_bus *bus)
 	union acpi_object *obj;
 	struct pci_host_bridge *bridge;
 
-	if (acpi_pci_disabled || !bus->bridge)
+	if (acpi_pci_disabled || !bus->bridge || !ACPI_HANDLE(bus->bridge))
 		return;
 
 	acpi_pci_slot_enumerate(bus);

commit 1ba51a7c1496fd8f6d5bdd58dafcb1894275b7f0
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Aug 1 02:56:18 2017 +0200

    ACPI / PCI / PM: Rework acpi_pci_propagate_wakeup()
    
    The acpi_pci_propagate_wakeup() routine is there to handle cases in
    which PCI bridges (or PCIe ports) are expected to signal wakeup
    for devices below them, but currently it doesn't do that correctly.
    
    The problem is that acpi_pci_propagate_wakeup() uses
    acpi_pm_set_device_wakeup() for bridges and if that routine is
    called for multiple times to disable wakeup for the same device,
    it will disable it on the first invocation and the next calls
    will have no effect (it works analogously when called to enable
    wakeup, but that is not a problem).
    
    Now, say acpi_pci_propagate_wakeup() has been called for two
    different devices under the same bridge and it has called
    acpi_pm_set_device_wakeup() for that bridge each time.  The
    bridge is now enabled to generate wakeup signals.  Next,
    suppose that one of the devices below it resumes and
    acpi_pci_propagate_wakeup() is called to disable wakeup for that
    device.  It will then call acpi_pm_set_device_wakeup() for the bridge
    and that will effectively disable remote wakeup for all devices under
    it even though some of them may still be suspended and remote wakeup
    may be expected to work for them.
    
    To address this (arguably theoretical) issue, allow
    wakeup.enable_count under struct acpi_device to grow beyond 1 in
    certain situations.  In particular, allow that to happen in
    acpi_pci_propagate_wakeup() when wakeup is enabled or disabled
    for PCI bridges, so that wakeup is actually disabled for the
    bridge when all devices under it resume and not when just one
    of them does that.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index e70c1c7ba1bf..a8da543b3814 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -573,7 +573,7 @@ static int acpi_pci_propagate_wakeup(struct pci_bus *bus, bool enable)
 {
 	while (bus->parent) {
 		if (acpi_pm_device_can_wakeup(&bus->self->dev))
-			return acpi_pm_set_device_wakeup(&bus->self->dev, enable);
+			return acpi_pm_set_bridge_wakeup(&bus->self->dev, enable);
 
 		bus = bus->parent;
 	}
@@ -581,7 +581,7 @@ static int acpi_pci_propagate_wakeup(struct pci_bus *bus, bool enable)
 	/* We have reached the root bus. */
 	if (bus->bridge) {
 		if (acpi_pm_device_can_wakeup(bus->bridge))
-			return acpi_pm_set_device_wakeup(bus->bridge, enable);
+			return acpi_pm_set_bridge_wakeup(bus->bridge, enable);
 	}
 	return 0;
 }

commit de3ef1eb1cd0cc3a75f7a3661e10ed827f370ab8
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Jun 24 01:58:53 2017 +0200

    PM / core: Drop run_wake flag from struct dev_pm_info
    
    The run_wake flag in struct dev_pm_info is used to indicate whether
    or not the device is capable of generating remote wakeup signals at
    run time (or in the system working state), but the distinction
    between runtime remote wakeup and system wakeup signaling has always
    been rather artificial.  The only practical reason for it to exist
    at the core level was that ACPI and PCI treated those two cases
    differently, but that's not the case any more after recent changes.
    
    For this reason, get rid of the run_wake flag and, when applicable,
    use device_set_wakeup_capable() and device_can_wakeup() instead of
    device_set_run_wake() and device_run_wake(), respectively.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 138a3c55d80e..e70c1c7ba1bf 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -738,7 +738,6 @@ static void pci_acpi_setup(struct device *dev)
 		return;
 
 	device_set_wakeup_capable(dev, true);
-	device_set_run_wake(dev, true);
 	acpi_pci_wakeup(pci_dev, false);
 }
 
@@ -750,10 +749,8 @@ static void pci_acpi_cleanup(struct device *dev)
 		return;
 
 	pci_acpi_remove_pm_notifier(adev);
-	if (adev->wakeup.flags.valid) {
+	if (adev->wakeup.flags.valid)
 		device_set_wakeup_capable(dev, false);
-		device_set_run_wake(dev, false);
-	}
 }
 
 static bool pci_acpi_bus_match(struct device *dev)

commit 0847684cfc5f0e9f009919bfdcb041d60e19b856
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Jun 24 01:57:35 2017 +0200

    PCI / PM: Simplify device wakeup settings code
    
    After previous changes it is not necessary to distinguish between
    device wakeup for run time and device wakeup from system sleep states
    any more, so rework the PCI device wakeup settings code accordingly.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index de255bc9736b..138a3c55d80e 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -615,8 +615,7 @@ static const struct pci_platform_pm_ops acpi_pci_platform_pm = {
 	.set_state = acpi_pci_set_power_state,
 	.get_state = acpi_pci_get_power_state,
 	.choose_state = acpi_pci_choose_state,
-	.sleep_wake = acpi_pci_wakeup,
-	.run_wake = acpi_pci_wakeup,
+	.set_wakeup = acpi_pci_wakeup,
 	.need_resume = acpi_pci_need_resume,
 };
 

commit 8370c2dc4c7b91be7e1231130f0ae08b5aebecf4
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Jun 24 01:56:13 2017 +0200

    PCI / PM: Drop pme_interrupt flag from struct pci_dev
    
    The pme_interrupt flag in struct pci_dev is set when PMEs generated
    by the device are going to be signaled via root port PME interrupts.
    
    Ironically enough, that information is only used by the code setting
    up device wakeup through ACPI which returns as soon as it sees the
    pme_interrupt flag set while setting up "remote runtime wakeup".
    That is questionable, however, because in theory there may be PCIe
    devices using out-of-band PME signaling under root ports handled
    by the native PME code or devices requiring wakeup power setup to be
    carried out by AML.  For such devices, ACPI wakeup should be invoked
    regardless of whether or not native PME signaling is used in general.
    
    For this reason, drop the pme_interrupt flag and rework the code
    using it which then allows the ACPI-based device wakeup handling
    in PCI to be consolidated to use one code path for both "runtime
    remote wakeup" and system wakeup (from sleep states).
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index eb014b8ab01a..de255bc9736b 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -569,67 +569,29 @@ static pci_power_t acpi_pci_get_power_state(struct pci_dev *dev)
 	return state_conv[state];
 }
 
-static bool acpi_pci_can_wakeup(struct pci_dev *dev)
-{
-	struct acpi_device *adev = ACPI_COMPANION(&dev->dev);
-	return adev ? acpi_device_can_wakeup(adev) : false;
-}
-
-static void acpi_pci_propagate_wakeup_enable(struct pci_bus *bus, bool enable)
+static int acpi_pci_propagate_wakeup(struct pci_bus *bus, bool enable)
 {
 	while (bus->parent) {
-		if (!acpi_pm_set_device_wakeup(&bus->self->dev, enable))
-			return;
-		bus = bus->parent;
-	}
-
-	/* We have reached the root bus. */
-	if (bus->bridge)
-		acpi_pm_set_device_wakeup(bus->bridge, enable);
-}
+		if (acpi_pm_device_can_wakeup(&bus->self->dev))
+			return acpi_pm_set_device_wakeup(&bus->self->dev, enable);
 
-static int acpi_pci_sleep_wake(struct pci_dev *dev, bool enable)
-{
-	if (acpi_pci_can_wakeup(dev))
-		return acpi_pm_set_device_wakeup(&dev->dev, enable);
-
-	acpi_pci_propagate_wakeup_enable(dev->bus, enable);
-	return 0;
-}
-
-static void acpi_pci_propagate_run_wake(struct pci_bus *bus, bool enable)
-{
-	while (bus->parent) {
-		struct pci_dev *bridge = bus->self;
-
-		if (bridge->pme_interrupt)
-			return;
-		if (!acpi_pm_set_device_wakeup(&bridge->dev, enable))
-			return;
 		bus = bus->parent;
 	}
 
 	/* We have reached the root bus. */
-	if (bus->bridge)
-		acpi_pm_set_device_wakeup(bus->bridge, enable);
+	if (bus->bridge) {
+		if (acpi_pm_device_can_wakeup(bus->bridge))
+			return acpi_pm_set_device_wakeup(bus->bridge, enable);
+	}
+	return 0;
 }
 
-static int acpi_pci_run_wake(struct pci_dev *dev, bool enable)
+static int acpi_pci_wakeup(struct pci_dev *dev, bool enable)
 {
-	/*
-	 * Per PCI Express Base Specification Revision 2.0 section
-	 * 5.3.3.2 Link Wakeup, platform support is needed for D3cold
-	 * waking up to power on the main link even if there is PME
-	 * support for D3cold
-	 */
-	if (dev->pme_interrupt && !dev->runtime_d3cold)
-		return 0;
-
-	if (!acpi_pm_set_device_wakeup(&dev->dev, enable))
-		return 0;
+	if (acpi_pm_device_can_wakeup(&dev->dev))
+		return acpi_pm_set_device_wakeup(&dev->dev, enable);
 
-	acpi_pci_propagate_run_wake(dev->bus, enable);
-	return 0;
+	return acpi_pci_propagate_wakeup(dev->bus, enable);
 }
 
 static bool acpi_pci_need_resume(struct pci_dev *dev)
@@ -653,8 +615,8 @@ static const struct pci_platform_pm_ops acpi_pci_platform_pm = {
 	.set_state = acpi_pci_set_power_state,
 	.get_state = acpi_pci_get_power_state,
 	.choose_state = acpi_pci_choose_state,
-	.sleep_wake = acpi_pci_sleep_wake,
-	.run_wake = acpi_pci_run_wake,
+	.sleep_wake = acpi_pci_wakeup,
+	.run_wake = acpi_pci_wakeup,
 	.need_resume = acpi_pci_need_resume,
 };
 
@@ -778,7 +740,7 @@ static void pci_acpi_setup(struct device *dev)
 
 	device_set_wakeup_capable(dev, true);
 	device_set_run_wake(dev, true);
-	acpi_pci_sleep_wake(pci_dev, false);
+	acpi_pci_wakeup(pci_dev, false);
 }
 
 static void pci_acpi_cleanup(struct device *dev)

commit 4d183d04195318c8ee8bce048f3f9a89c0e2056d
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Jun 24 01:54:39 2017 +0200

    ACPI / PM: Consolidate device wakeup settings code
    
    Currently, there are two separate ways of handling device wakeup
    settings in the ACPI core, depending on whether this is runtime
    wakeup or system wakeup (from sleep states).  However, after the
    previous commit eliminating the run_wake ACPI device wakeup flag,
    there is no difference between the two any more at the ACPI level,
    so they can be combined.
    
    For this reason, introduce acpi_pm_set_device_wakeup() to replace both
    acpi_pm_device_run_wake() and acpi_pm_device_sleep_wake() and make it
    check the ACPI device object's wakeup.valid flag to determine whether
    or not the device can be set up to generate wakeup signals.
    
    Also notice that zpodd_enable/disable_run_wake() only call
    device_set_run_wake() because acpi_pm_device_run_wake() called
    device_run_wake(), which is not done by acpi_pm_set_device_wakeup(),
    so drop the now redundant device_set_run_wake() calls from there.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index f084046e1feb..eb014b8ab01a 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -578,20 +578,20 @@ static bool acpi_pci_can_wakeup(struct pci_dev *dev)
 static void acpi_pci_propagate_wakeup_enable(struct pci_bus *bus, bool enable)
 {
 	while (bus->parent) {
-		if (!acpi_pm_device_sleep_wake(&bus->self->dev, enable))
+		if (!acpi_pm_set_device_wakeup(&bus->self->dev, enable))
 			return;
 		bus = bus->parent;
 	}
 
 	/* We have reached the root bus. */
 	if (bus->bridge)
-		acpi_pm_device_sleep_wake(bus->bridge, enable);
+		acpi_pm_set_device_wakeup(bus->bridge, enable);
 }
 
 static int acpi_pci_sleep_wake(struct pci_dev *dev, bool enable)
 {
 	if (acpi_pci_can_wakeup(dev))
-		return acpi_pm_device_sleep_wake(&dev->dev, enable);
+		return acpi_pm_set_device_wakeup(&dev->dev, enable);
 
 	acpi_pci_propagate_wakeup_enable(dev->bus, enable);
 	return 0;
@@ -604,14 +604,14 @@ static void acpi_pci_propagate_run_wake(struct pci_bus *bus, bool enable)
 
 		if (bridge->pme_interrupt)
 			return;
-		if (!acpi_pm_device_run_wake(&bridge->dev, enable))
+		if (!acpi_pm_set_device_wakeup(&bridge->dev, enable))
 			return;
 		bus = bus->parent;
 	}
 
 	/* We have reached the root bus. */
 	if (bus->bridge)
-		acpi_pm_device_run_wake(bus->bridge, enable);
+		acpi_pm_set_device_wakeup(bus->bridge, enable);
 }
 
 static int acpi_pci_run_wake(struct pci_dev *dev, bool enable)
@@ -625,7 +625,7 @@ static int acpi_pci_run_wake(struct pci_dev *dev, bool enable)
 	if (dev->pme_interrupt && !dev->runtime_d3cold)
 		return 0;
 
-	if (!acpi_pm_device_run_wake(&dev->dev, enable))
+	if (!acpi_pm_set_device_wakeup(&dev->dev, enable))
 		return 0;
 
 	acpi_pci_propagate_run_wake(dev->bus, enable);

commit a1a66393e39a97433bcc1737133ba7478993d247
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Jun 24 01:53:14 2017 +0200

    ACPI / PM: Drop run_wake from struct acpi_device_wakeup_flags
    
    The run_wake flag in struct acpi_device_wakeup_flags stores the
    information on whether or not the device can generate wakeup
    signals at run time, but in ACPI that really is equivalent to
    being able to generate wakeup signals at all.
    
    In fact, run_wake will always be set after successful executeion of
    acpi_setup_gpe_for_wake(), but if that fails, the device will not be
    able to use a wakeup GPE at all, so it won't be able to wake up the
    systems from sleep states too.  Hence, run_wake actually means that
    the device is capable of triggering wakeup and so it is equivalent
    to the valid flag.
    
    For this reason, drop run_wake from struct acpi_device_wakeup_flags
    and make sure that the valid flag is only set if
    acpi_setup_gpe_for_wake() has been successful.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 61296f20c37a..f084046e1feb 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -777,9 +777,8 @@ static void pci_acpi_setup(struct device *dev)
 		return;
 
 	device_set_wakeup_capable(dev, true);
+	device_set_run_wake(dev, true);
 	acpi_pci_sleep_wake(pci_dev, false);
-	if (adev->wakeup.flags.run_wake)
-		device_set_run_wake(dev, true);
 }
 
 static void pci_acpi_cleanup(struct device *dev)

commit d07ff6523b1ed24d636365f8479b0db70946dc14
Merge: 33e4f80ee69b 87085ff2e90e
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jun 22 16:28:35 2017 +0200

    Merge branch 'uuid-types'
    
    Merge branch 'uuid-types' from git://git.infradead.org/users/hch/uuid.git
    to satisfy dependencies.

commit 64fd1c7040880292710e6592ddc88d0d73cfb6fb
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Jun 12 22:48:41 2017 +0200

    ACPI / PM: Run wakeup notify handlers synchronously
    
    The work functions provided by the users of acpi_add_pm_notifier()
    should be run synchronously before re-enabling the wakeup GPE in
    case they are used to clear the status and/or disable the wakeup
    signaling at the source.  Otherwise, which is the case currently in
    the PCI bus type code, the same wakeup event may be signaled for
    multiple times while the execution of the work function in response
    to it has already been queued up.
    
    Fortunately, acpi_add_pm_notifier() is only used by PCI and by
    ACPI device PM code internally, so the change is relatively
    straightforward to make.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 001860361434..9284ae6f669a 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -395,29 +395,26 @@ bool pciehp_is_native(struct pci_dev *pdev)
 
 /**
  * pci_acpi_wake_bus - Root bus wakeup notification fork function.
- * @work: Work item to handle.
+ * @context: Device wakeup context.
  */
-static void pci_acpi_wake_bus(struct work_struct *work)
+static void pci_acpi_wake_bus(struct acpi_device_wakeup_context *context)
 {
 	struct acpi_device *adev;
 	struct acpi_pci_root *root;
 
-	adev = container_of(work, struct acpi_device, wakeup.context.work);
+	adev = container_of(context, struct acpi_device, wakeup.context);
 	root = acpi_driver_data(adev);
 	pci_pme_wakeup_bus(root->bus);
 }
 
 /**
  * pci_acpi_wake_dev - PCI device wakeup notification work function.
- * @handle: ACPI handle of a device the notification is for.
- * @work: Work item to handle.
+ * @context: Device wakeup context.
  */
-static void pci_acpi_wake_dev(struct work_struct *work)
+static void pci_acpi_wake_dev(struct acpi_device_wakeup_context *context)
 {
-	struct acpi_device_wakeup_context *context;
 	struct pci_dev *pci_dev;
 
-	context = container_of(work, struct acpi_device_wakeup_context, work);
 	pci_dev = to_pci_dev(context->dev);
 
 	if (pci_dev->pme_poll)
@@ -425,7 +422,7 @@ static void pci_acpi_wake_dev(struct work_struct *work)
 
 	if (pci_dev->current_state == PCI_D3cold) {
 		pci_wakeup_event(pci_dev);
-		pm_runtime_resume(&pci_dev->dev);
+		pm_request_resume(&pci_dev->dev);
 		return;
 	}
 
@@ -434,7 +431,7 @@ static void pci_acpi_wake_dev(struct work_struct *work)
 		pci_check_pme_status(pci_dev);
 
 	pci_wakeup_event(pci_dev);
-	pm_runtime_resume(&pci_dev->dev);
+	pm_request_resume(&pci_dev->dev);
 
 	pci_pme_wakeup_bus(pci_dev->subordinate);
 }

commit 94116f8126de9762751fd92731581b73b56292e5
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Mon Jun 5 19:40:46 2017 +0300

    ACPI: Switch to use generic guid_t in acpi_evaluate_dsm()
    
    acpi_evaluate_dsm() and friends take a pointer to a raw buffer of 16
    bytes. Instead we convert them to use guid_t type. At the same time we
    convert current users.
    
    acpi_str_to_uuid() becomes useless after the conversion and it's safe to
    get rid of it.
    
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: Borislav Petkov <bp@suse.de>
    Acked-by: Dan Williams <dan.j.williams@intel.com>
    Cc: Amir Goldstein <amir73il@gmail.com>
    Reviewed-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
    Reviewed-by: Jani Nikula <jani.nikula@intel.com>
    Acked-by: Jani Nikula <jani.nikula@intel.com>
    Cc: Ben Skeggs <bskeggs@redhat.com>
    Acked-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Acked-by: Joerg Roedel <jroedel@suse.de>
    Acked-by: Adrian Hunter <adrian.hunter@intel.com>
    Cc: Yisen Zhuang <yisen.zhuang@huawei.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Acked-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Reviewed-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Acked-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 001860361434..47070cff508c 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -21,13 +21,12 @@
 #include "pci.h"
 
 /*
- * The UUID is defined in the PCI Firmware Specification available here:
+ * The GUID is defined in the PCI Firmware Specification available here:
  * https://www.pcisig.com/members/downloads/pcifw_r3_1_13Dec10.pdf
  */
-const u8 pci_acpi_dsm_uuid[] = {
-	0xd0, 0x37, 0xc9, 0xe5, 0x53, 0x35, 0x7a, 0x4d,
-	0x91, 0x17, 0xea, 0x4d, 0x19, 0xc3, 0x43, 0x4d
-};
+const guid_t pci_acpi_dsm_guid =
+	GUID_INIT(0xe5c937d0, 0x3553, 0x4d7a,
+		  0x91, 0x17, 0xea, 0x4d, 0x19, 0xc3, 0x43, 0x4d);
 
 #if defined(CONFIG_PCI_QUIRKS) && defined(CONFIG_ARM64)
 static int acpi_get_rc_addr(struct acpi_device *adev, struct resource *res)
@@ -680,7 +679,7 @@ void acpi_pci_add_bus(struct pci_bus *bus)
 	if (!pci_is_root_bus(bus))
 		return;
 
-	obj = acpi_evaluate_dsm(ACPI_HANDLE(bus->bridge), pci_acpi_dsm_uuid, 3,
+	obj = acpi_evaluate_dsm(ACPI_HANDLE(bus->bridge), &pci_acpi_dsm_guid, 3,
 				RESET_DELAY_DSM, NULL);
 	if (!obj)
 		return;
@@ -745,7 +744,7 @@ static void pci_acpi_optimize_delay(struct pci_dev *pdev,
 	if (bridge->ignore_reset_delay)
 		pdev->d3cold_delay = 0;
 
-	obj = acpi_evaluate_dsm(handle, pci_acpi_dsm_uuid, 3,
+	obj = acpi_evaluate_dsm(handle, &pci_acpi_dsm_guid, 3,
 				FUNCTION_DELAY_DSM, NULL);
 	if (!obj)
 		return;

commit daaed10443da09ad0d2042b71cb99f3927d52164
Merge: db5ba8641264 c931225480ae
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Dec 12 11:25:04 2016 -0600

    Merge branch 'pci/pm' into next
    
    * pci/pm:
      x86/platform/intel-mid: Constify mid_pci_platform_pm
      PCI: pciehp: Add runtime PM support for PCIe hotplug ports
      ACPI / hotplug / PCI: Make device_is_managed_by_native_pciehp() public
      ACPI / hotplug / PCI: Use cached copy of PCI_EXP_SLTCAP_HPC bit
      PCI: Unfold conditions to block runtime PM on PCIe ports
      PCI: Consolidate conditions to allow runtime PM on PCIe ports
      PCI: Activate runtime PM on a PCIe port only if it can suspend
      PCI: Speed up algorithm in pci_bridge_d3_update()
      PCI: Autosense device removal in pci_bridge_d3_update()
      PCI: Don't acquire ref on parent in pci_bridge_d3_update()
      USB: UHCI: report non-PME wakeup signalling for Intel hardware
      PCI: Check for PME in targeted sleep state

commit 169de969c0188be69bd5ff1e148d42a49bf47738
Author: Dongdong Liu <liudongdong3@huawei.com>
Date:   Thu Dec 1 00:33:42 2016 -0600

    PCI/ACPI: Provide acpi_get_rc_resources() for ARM64 platform
    
    The acpi_get_rc_resources() is used to get the RC register address that can
    not be described in MCFG.  It takes the _HID & segment to look for and
    outputs the RC address resource.  Use PNP0C02 devices to describe such RC
    address resource.  Use _UID to match segment to tell which root bus the
    PNP0C02 resource belongs to.
    
    [bhelgaas: add dev argument, wrap in #ifdef CONFIG_PCI_QUIRKS]
    Signed-off-by: Dongdong Liu <liudongdong3@huawei.com>
    Signed-off-by: Tomasz Nowicki <tn@semihalf.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index d966d47c9e80..92384dece4b4 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -29,6 +29,82 @@ const u8 pci_acpi_dsm_uuid[] = {
 	0x91, 0x17, 0xea, 0x4d, 0x19, 0xc3, 0x43, 0x4d
 };
 
+#if defined(CONFIG_PCI_QUIRKS) && defined(CONFIG_ARM64)
+static int acpi_get_rc_addr(struct acpi_device *adev, struct resource *res)
+{
+	struct device *dev = &adev->dev;
+	struct resource_entry *entry;
+	struct list_head list;
+	unsigned long flags;
+	int ret;
+
+	INIT_LIST_HEAD(&list);
+	flags = IORESOURCE_MEM;
+	ret = acpi_dev_get_resources(adev, &list,
+				     acpi_dev_filter_resource_type_cb,
+				     (void *) flags);
+	if (ret < 0) {
+		dev_err(dev, "failed to parse _CRS method, error code %d\n",
+			ret);
+		return ret;
+	}
+
+	if (ret == 0) {
+		dev_err(dev, "no IO and memory resources present in _CRS\n");
+		return -EINVAL;
+	}
+
+	entry = list_first_entry(&list, struct resource_entry, node);
+	*res = *entry->res;
+	acpi_dev_free_resource_list(&list);
+	return 0;
+}
+
+static acpi_status acpi_match_rc(acpi_handle handle, u32 lvl, void *context,
+				 void **retval)
+{
+	u16 *segment = context;
+	unsigned long long uid;
+	acpi_status status;
+
+	status = acpi_evaluate_integer(handle, "_UID", NULL, &uid);
+	if (ACPI_FAILURE(status) || uid != *segment)
+		return AE_CTRL_DEPTH;
+
+	*(acpi_handle *)retval = handle;
+	return AE_CTRL_TERMINATE;
+}
+
+int acpi_get_rc_resources(struct device *dev, const char *hid, u16 segment,
+			  struct resource *res)
+{
+	struct acpi_device *adev;
+	acpi_status status;
+	acpi_handle handle;
+	int ret;
+
+	status = acpi_get_devices(hid, acpi_match_rc, &segment, &handle);
+	if (ACPI_FAILURE(status)) {
+		dev_err(dev, "can't find _HID %s device to locate resources\n",
+			hid);
+		return -ENODEV;
+	}
+
+	ret = acpi_bus_get_device(handle, &adev);
+	if (ret)
+		return ret;
+
+	ret = acpi_get_rc_addr(adev, res);
+	if (ret) {
+		dev_err(dev, "can't get resource from %s\n",
+			dev_name(&adev->dev));
+		return ret;
+	}
+
+	return 0;
+}
+#endif
+
 phys_addr_t acpi_pci_root_get_mcfg_addr(acpi_handle handle)
 {
 	acpi_status status = AE_NOT_EXIST;

commit 437eb7bf7b28472f8b7689e166dc1dd691367121
Author: Lukas Wunner <lukas@wunner.de>
Date:   Fri Oct 28 10:52:06 2016 +0200

    ACPI / hotplug / PCI: Make device_is_managed_by_native_pciehp() public
    
    We're about to add runtime PM of hotplug ports, but we need to restrict it
    to ports that are handled natively by the OS:  If they're handled by the
    firmware (which is the case for Thunderbolt on non-Macs), things would
    break if the OS put the ports into D3hot behind the firmware's back.
    
    To determine if a hotplug port is handled natively, one has to walk up from
    the port to the root bridge and check the cached _OSC Control Field for the
    value of the "PCI Express Native Hot Plug control" bit.  There's already a
    function to do that, device_is_managed_by_native_pciehp(), but it's private
    to drivers/pci/hotplug/acpiphp_glue.c and only compiled in if
    CONFIG_HOTPLUG_PCI_ACPI is enabled.
    
    Make it public and move it to drivers/pci/pci-acpi.c, so that it is
    available in the more general CONFIG_ACPI case.
    
    The function contains a check if the device in question is a hotplug port
    and returns false if it's not.  The caller we're going to add doesn't need
    this as it only calls the function if it actually *is* a hotplug port.
    Move the check out of the function into the single existing caller.
    
    Rename it to pciehp_is_native() and add some kerneldoc and polish.
    
    No functional change intended.
    
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index d966d47c9e80..ed3daa8e7658 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -293,6 +293,30 @@ int pci_get_hp_params(struct pci_dev *dev, struct hotplug_params *hpp)
 }
 EXPORT_SYMBOL_GPL(pci_get_hp_params);
 
+/**
+ * pciehp_is_native - Check whether a hotplug port is handled by the OS
+ * @pdev: Hotplug port to check
+ *
+ * Walk up from @pdev to the host bridge, obtain its cached _OSC Control Field
+ * and return the value of the "PCI Express Native Hot Plug control" bit.
+ * On failure to obtain the _OSC Control Field return %false.
+ */
+bool pciehp_is_native(struct pci_dev *pdev)
+{
+	struct acpi_pci_root *root;
+	acpi_handle handle;
+
+	handle = acpi_find_root_bridge_handle(pdev);
+	if (!handle)
+		return false;
+
+	root = acpi_pci_find_root(handle);
+	if (!root)
+		return false;
+
+	return root->osc_control_set & OSC_PCI_EXPRESS_NATIVE_HP_CONTROL;
+}
+
 /**
  * pci_acpi_wake_bus - Root bus wakeup notification fork function.
  * @work: Work item to handle.

commit cc7cc02bada84f0d707aa5b6d2ef8728a2e1f911
Author: Lukas Wunner <lukas@wunner.de>
Date:   Sun Sep 18 05:39:20 2016 +0200

    PCI: Query platform firmware for device power state
    
    Usually the most accurate way to determine a PCI device's power state is to
    read its PM Control & Status Register.  There are two cases however when
    this is not an option:  If the device doesn't have the PM capability at
    all, or if it is in D3cold (in which case its config space is
    inaccessible).
    
    In both cases, we can alternatively query the platform firmware for its
    opinion on the device's power state.  To facilitate this, augment struct
    pci_platform_pm_ops with a ->get_power callback and implement it for
    acpi_pci_platform_pm (the only pci_platform_pm_ops existing so far).
    
    It is used by a forthcoming commit to let pci_update_current_state()
    recognize D3cold.
    
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 9a033e8ee9a4..d966d47c9e80 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -452,6 +452,27 @@ static int acpi_pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 	return error;
 }
 
+static pci_power_t acpi_pci_get_power_state(struct pci_dev *dev)
+{
+	struct acpi_device *adev = ACPI_COMPANION(&dev->dev);
+	static const pci_power_t state_conv[] = {
+		[ACPI_STATE_D0]      = PCI_D0,
+		[ACPI_STATE_D1]      = PCI_D1,
+		[ACPI_STATE_D2]      = PCI_D2,
+		[ACPI_STATE_D3_HOT]  = PCI_D3hot,
+		[ACPI_STATE_D3_COLD] = PCI_D3cold,
+	};
+	int state;
+
+	if (!adev || !acpi_device_power_manageable(adev))
+		return PCI_UNKNOWN;
+
+	if (acpi_device_get_power(adev, &state) || state == ACPI_STATE_UNKNOWN)
+		return PCI_UNKNOWN;
+
+	return state_conv[state];
+}
+
 static bool acpi_pci_can_wakeup(struct pci_dev *dev)
 {
 	struct acpi_device *adev = ACPI_COMPANION(&dev->dev);
@@ -534,6 +555,7 @@ static bool acpi_pci_need_resume(struct pci_dev *dev)
 static const struct pci_platform_pm_ops acpi_pci_platform_pm = {
 	.is_manageable = acpi_pci_power_manageable,
 	.set_state = acpi_pci_set_power_state,
+	.get_state = acpi_pci_get_power_state,
 	.choose_state = acpi_pci_choose_state,
 	.sleep_wake = acpi_pci_sleep_wake,
 	.run_wake = acpi_pci_run_wake,

commit 67990608c8b95d2b8ccc29932376ae73d5818727
Merge: c17488d06666 a889f766dbb7
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jan 12 20:25:09 2016 -0800

    Merge tag 'pm+acpi-4.5-rc1-1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull oower management and ACPI updates from Rafael Wysocki:
     "As far as the number of commits goes, ACPICA takes the lead this time,
      followed by cpufreq and the device properties framework changes.
    
      The most significant new feature is the debugfs-based interface to the
      ACPICA's AML debugger added in the previous cycle and a new user space
      tool for accessing it.
    
      On the cpufreq front, the core is updated to handle governors more
      efficiently, particularly on systems where a single cpufreq policy
      object is shared between multiple CPUs, and there are quite a few
      changes in drivers (intel_pstate, cpufreq-dt etc).
    
      The device properties framework is updated to handle built-in (ie
      included in the kernel itself) device properties better, among other
      things by adding a fallback mechanism that will allow drivers to
      provide default properties to be used in case the plaform firmware
      doesn't provide the properties expected by them.
    
      The Operating Performance Points (OPP) framework gets new DT bindings
      and debugfs support.
    
      A new cpufreq driver for ST platforms is added and the ACPI driver for
      AMD SoCs will now support the APM X-Gene ACPI I2C device.
    
      The rest is mostly fixes and cleanups all over.
    
      Specifics:
    
       - Add a debugfs-based interface for interacting with the ACPICA's AML
         debugger introduced in the previous cycle and a new user space tool
         for that, fix some bugs related to the AML debugger and clean up
         the code in question (Lv Zheng, Dan Carpenter, Colin Ian King,
         Markus Elfring).
    
       - Update ACPICA to upstream revision 20151218 including a number of
         fixes and cleanups in the ACPICA core (Bob Moore, Lv Zheng, Labbe
         Corentin, Prarit Bhargava, Colin Ian King, David E Box, Rafael
         Wysocki).
    
         In particular, the previously added erroneous support for the _SUB
         object is dropped, the concatenate operator will support all ACPI
         objects now, the Debug Object handling is improved, the SuperName
         handling of parameters being control methods is fixed, the
         ObjectType operator handling is updated to follow ACPI 5.0A and the
         handling of CondRefOf and RefOf is updated accordingly, module-
         level code will be executed after loading each ACPI table now
         (instead of being run once after all tables containing AML have
         been loaded), the Operation Region handlers management is updated
         to fix some reported problems and a the ACPICA code in the kernel
         is more in line with the upstream now.
    
       - Update the ACPI backlight driver to provide information on whether
         or not it will generate key-presses for brightness change hotkeys
         and update some platform drivers (dell-wmi, thinkpad_acpi) to use
         that information to avoid sending double key-events to users pace
         for these, add new ACPI backlight quirks (Hans de Goede, Aaron Lu,
         Adrien Schildknecht).
    
       - Improve the ACPI handling of interrupt GPIOs (Christophe Ricard).
    
       - Fix the handling of the list of device IDs of device objects found
         in the ACPI namespace and add a helper for checking if there is a
         device object for a given device ID (Lukas Wunner).
    
       - Change the logic in the ACPI namespace scanning code to create
         struct acpi_device objects for all ACPI device objects found in the
         namespace even if _STA fails for them which helps to avoid device
         enumeration problems on Microsoft Surface 3 (Aaron Lu).
    
       - Add support for the APM X-Gene ACPI I2C device to the ACPI driver
         for AMD SoCs (Loc Ho).
    
       - Fix the long-standing issue with the DMA controller on Intel SoCs
         where ACPI tables have no power management support for the DMA
         controller itself, but it can be powered off automatically when the
         last (other) device on the SoC is powered off via ACPI and clean up
         the ACPI driver for Intel SoCs (acpi-lpss) after previous attempts
         to fix that problem (Andy Shevchenko).
    
       - Assorted ACPI fixes and cleanups (Andy Lutomirski, Colin Ian King,
         Javier Martinez Canillas, Ken Xue, Mathias Krause, Rafael Wysocki,
         Sinan Kaya).
    
       - Update the device properties framework for better handling of
         built-in properties, add support for built-in properties to the
         platform bus type, update the MFD subsystem's handling of device
         properties and add support for passing default configuration data
         as device properties to the intel-lpss MFD drivers, convert the
         designware I2C driver to use the unified device properties API and
         add a fallback mechanism for using default built-in properties if
         the platform firmware fails to provide the properties as expected
         by drivers (Andy Shevchenko, Mika Westerberg, Heikki Krogerus,
         Andrew Morton).
    
       - Add new Device Tree bindings to the Operating Performance Points
         (OPP) framework and update the exynos4412 DT binding accordingly,
         introduce debugfs support for the OPP framework (Viresh Kumar,
         Bartlomiej Zolnierkiewicz).
    
       - Migrate the mt8173 cpufreq driver to the new OPP bindings (Pi-Cheng
         Chen).
    
       - Update the cpufreq core to make the handling of governors more
         efficient, especially on systems where policy objects are shared
         between multiple CPUs (Viresh Kumar, Rafael Wysocki).
    
       - Fix cpufreq governor handling on configurations with
         CONFIG_HZ_PERIODIC set (Chen Yu).
    
       - Clean up the cpufreq core code related to the boost sysfs knob
         support and update the ACPI cpufreq driver accordingly (Rafael
         Wysocki).
    
       - Add a new cpufreq driver for ST platforms and corresponding Device
         Tree bindings (Lee Jones).
    
       - Update the intel_pstate driver to allow the P-state selection
         algorithm used by it to depend on the CPU ID of the processor it is
         running on, make it use a special P-state selection algorithm (with
         an IO wait time compensation tweak) on Atom CPUs based on the
         Airmont and Silvermont cores so as to reduce their energy
         consumption and improve intel_pstate documentation (Philippe
         Longepe, Srinivas Pandruvada).
    
       - Update the cpufreq-dt driver to support registering cooling devices
         that use the (P * V^2 * f) dynamic power draw formula where V is
         the voltage, f is the frequency and P is a constant coefficient
         provided by Device Tree and update the arm_big_little cpufreq
         driver to use that support (Punit Agrawal).
    
       - Assorted cpufreq driver (cpufreq-dt, qoriq, pcc-cpufreq,
         blackfin-cpufreq) updates (Andrzej Hajda, Hongtao Jia, Jacob
         Tanenbaum, Markus Elfring).
    
       - cpuidle core tweaks related to polling and measured_us calculation
         (Rik van Riel).
    
       - Removal of modularity from a few cpuidle drivers (clps711x, ux500,
         exynos) that cannot be built as modules in practice (Paul
         Gortmaker).
    
       - PM core update to prevent devices from being probed during system
         suspend/resume which is generally problematic and may lead to
         inconsistent behavior (Grygorii Strashko).
    
       - Assorted updates of the PM core and related code (Julia Lawall,
         Manuel Pégourié-Gonnard, Maruthi Bayyavarapu, Rafael Wysocki, Ulf
         Hansson).
    
       - PNP bus type updates (Christophe Le Roy, Heiner Kallweit).
    
       - PCI PM code cleanups (Jarkko Nikula, Julia Lawall).
    
       - cpupower tool updates (Jacob Tanenbaum, Thomas Renninger)"
    
    * tag 'pm+acpi-4.5-rc1-1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (177 commits)
      PM / clk: don't leave clocks enabled when driver not bound
      i2c: dw: Add APM X-Gene ACPI I2C device support
      ACPI / APD: Add APM X-Gene ACPI I2C device support
      ACPI / LPSS: change 'does not have' to 'has' in comment
      Revert "dmaengine: dw: platform: provide platform data for Intel"
      dmaengine: dw: return immediately from IRQ when DMA isn't in use
      dmaengine: dw: platform: power on device on shutdown
      ACPI / LPSS: override power state for LPSS DMA device
      PM / OPP: Use snprintf() instead of sprintf()
      Documentation: cpufreq: intel_pstate: enhance documentation
      ACPI, PCI, irq: remove redundant check for null string pointer
      ACPI / video: driver must be registered before checking for keypresses
      cpufreq-dt: fix handling regulator_get_voltage() result
      cpufreq: governor: Fix negative idle_time when configured with CONFIG_HZ_PERIODIC
      PM / sleep: Add support for read-only sysfs attributes
      ACPI: Fix white space in a structure definition
      ACPI / SBS: fix inconsistent indenting inside if statement
      PNP: respect PNP_DRIVER_RES_DO_NOT_CHANGE when detaching
      ACPI / PNP: constify device IDs
      ACPI / PCI: Simplify acpi_penalize_isa_irq()
      ...

commit 471036b2b895789c2305428fd879006468e4a758
Author: Suravee Suthikulpanit <Suravee.Suthikulpanit@amd.com>
Date:   Thu Dec 10 08:55:27 2015 -0800

    acpi: pci: Setup MSI domain for ACPI based pci devices
    
    This patch introduces pci_msi_register_fwnode_provider() for irqchip
    to register a callback, to provide a way to determine appropriate MSI
    domain for a pci device.
    
    It also introduces pci_host_bridge_acpi_msi_domain(), which returns
    the MSI domain of the specified PCI host bridge with DOMAIN_BUS_PCI_MSI
    bus token. Then, it is assigned to pci device.
    
    Reviewed-by: Marc Zyngier <marc.zyngier@arm.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rjw@rjwysocki.net>
    Signed-off-by: Suravee Suthikulpanit <Suravee.Suthikulpanit@amd.com>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index a32ba753e413..d3f32d6417ef 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -9,7 +9,9 @@
 
 #include <linux/delay.h>
 #include <linux/init.h>
+#include <linux/irqdomain.h>
 #include <linux/pci.h>
+#include <linux/msi.h>
 #include <linux/pci_hotplug.h>
 #include <linux/module.h>
 #include <linux/pci-aspm.h>
@@ -689,6 +691,46 @@ static struct acpi_bus_type acpi_pci_bus = {
 	.cleanup = pci_acpi_cleanup,
 };
 
+
+static struct fwnode_handle *(*pci_msi_get_fwnode_cb)(struct device *dev);
+
+/**
+ * pci_msi_register_fwnode_provider - Register callback to retrieve fwnode
+ * @fn:       Callback matching a device to a fwnode that identifies a PCI
+ *            MSI domain.
+ *
+ * This should be called by irqchip driver, which is the parent of
+ * the MSI domain to provide callback interface to query fwnode.
+ */
+void
+pci_msi_register_fwnode_provider(struct fwnode_handle *(*fn)(struct device *))
+{
+	pci_msi_get_fwnode_cb = fn;
+}
+
+/**
+ * pci_host_bridge_acpi_msi_domain - Retrieve MSI domain of a PCI host bridge
+ * @bus:      The PCI host bridge bus.
+ *
+ * This function uses the callback function registered by
+ * pci_msi_register_fwnode_provider() to retrieve the irq_domain with
+ * type DOMAIN_BUS_PCI_MSI of the specified host bridge bus.
+ * This returns NULL on error or when the domain is not found.
+ */
+struct irq_domain *pci_host_bridge_acpi_msi_domain(struct pci_bus *bus)
+{
+	struct fwnode_handle *fwnode;
+
+	if (!pci_msi_get_fwnode_cb)
+		return NULL;
+
+	fwnode = pci_msi_get_fwnode_cb(&bus->dev);
+	if (!fwnode)
+		return NULL;
+
+	return irq_find_matching_fwnode(fwnode, DOMAIN_BUS_PCI_MSI);
+}
+
 static int __init acpi_pci_init(void)
 {
 	int ret;

commit 299f2ffed329c1a2ea8d6e90f0df26b885d16e08
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Sun Dec 6 17:33:45 2015 +0100

    PCI / PM: constify pci_platform_pm_ops structure
    
    The pci_platform_pm_ops structure is never modified, so declare it as
    const.
    
    Done with the help of Coccinelle.
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index a32ba753e413..8400f8017882 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -529,7 +529,7 @@ static bool acpi_pci_need_resume(struct pci_dev *dev)
 	return !!adev->power.flags.dsw_present;
 }
 
-static struct pci_platform_pm_ops acpi_pci_platform_pm = {
+static const struct pci_platform_pm_ops acpi_pci_platform_pm = {
 	.is_manageable = acpi_pci_power_manageable,
 	.set_state = acpi_pci_set_power_state,
 	.choose_state = acpi_pci_choose_state,

commit 113e0d118a93c964feea376de8c94dd8c7c63ff8
Author: Srinidhi Kasagar <srinidhi.kasagar@intel.com>
Date:   Wed Jul 15 14:59:46 2015 +0530

    PCI / ACPI: Fix pci_acpi_optimize_delay() comment
    
    The function takes ACPI handle, not the device itself. Fix the
    comment
    
    Signed-off-by: Srinidhi Kasagar <srinidhi.kasagar@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 314a625b78d6..a32ba753e413 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -594,7 +594,7 @@ static struct acpi_device *acpi_pci_find_companion(struct device *dev)
 /**
  * pci_acpi_optimize_delay - optimize PCI D3 and D3cold delay from ACPI
  * @pdev: the PCI device whose delay is to be updated
- * @adev: the companion ACPI device of this PCI device
+ * @handle: ACPI handle of this device
  *
  * Update the d3_delay and d3cold_delay of a PCI device from the ACPI _DSM
  * control method of either the device itself or the PCI host bridge.

commit 20dacb71ad283b9506ee7e01286a424999fb8309
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat May 16 01:55:35 2015 +0200

    ACPI / PM: Rework device power management to follow ACPI 6
    
    The ACPI 6 specification has made some changes in the device power
    management area.  In particular:
    
     * The D3hot power state is now supposed to be always available
       (instead of D3cold) and D3cold is only regarded as valid if the
       _PR3 object is present for the given device.
    
     * The required ordering of transitions into power states deeper than
       D0 is now such that for a transition into state Dx the _PSx method
       is supposed to be executed first, if present, and the states of
       the power resources the device depends on are supposed to be
       changed after that.
    
     * It is now explicitly forbidden to transition devices from
       lower-power (deeper) into higher-power (shallower) power states
       other than D0.
    
    Those changes have been made so the specification reflects the
    Windows' device power management code that the vast majority of
    systems using ACPI is validated against.
    
    To avoid artificial differences in ACPI device power management
    between Windows and Linux, modify the ACPI device power management
    code to follow the new specification.  Add comments explaining the
    code flow in some unclear places.
    
    This only may affect some real corner cases in which the OS behavior
    expected by the firmware is different from the Windows one, but that's
    quite unlikely.  The transition ordering change affects transitions
    to D1 and D2 which are rarely used (if at all) and into D3hot and
    D3cold for devices actually having _PR3, but those are likely to
    be validated against Windows anyway.  The other changes may affect
    code calling acpi_device_get_power() or acpi_device_update_power()
    where ACPI_STATE_D3_HOT may be returned instead of ACPI_STATE_D3_COLD
    (that's why the ACPI fan driver needs to be updated too) and since
    transitions into ACPI_STATE_D3_HOT may remove power now, it is better
    to avoid this one in acpi_pm_device_sleep_state() if the "no power
    off" PM QoS flag is set.
    
    The only existing user of acpi_device_can_poweroff() really cares
    about the case when _PR3 is present, so the change in that function
    should not cause any problems to happen too.
    
    A plus is that PCI_D3hot can be mapped to ACPI_STATE_D3_HOT
    now and the compatibility with older systems should be covered
    automatically.
    
    In any case, if any real problems result from this, it still will
    be better to follow the Windows' behavior (which now is reflected
    by the specification too) in general and handle the cases when it
    doesn't work via quirks.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 6f6f175f51f7..314a625b78d6 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -420,7 +420,7 @@ static int acpi_pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 		[PCI_D0] = ACPI_STATE_D0,
 		[PCI_D1] = ACPI_STATE_D1,
 		[PCI_D2] = ACPI_STATE_D2,
-		[PCI_D3hot] = ACPI_STATE_D3_COLD,
+		[PCI_D3hot] = ACPI_STATE_D3_HOT,
 		[PCI_D3cold] = ACPI_STATE_D3_COLD,
 	};
 	int error = -EINVAL;

commit 3be1b98e073bdd4c1bb3144201a927c4a21330ba
Merge: 392b46f31f43 5468d5a64bf1
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Apr 13 15:45:47 2015 -0700

    Merge tag 'pci-v4.1-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI changes from Bjorn Helgaas:
     "Enumeration
        - Read capability list as dwords, not bytes (Sean O. Stalley)
    
      Resource management
        - Don't check for PNP overlaps with unassigned PCI BARs (Bjorn Helgaas)
        - Mark invalid BARs as unassigned (Bjorn Helgaas)
        - Show driver, BAR#, and resource on pci_ioremap_bar() failure (Bjorn Helgaas)
        - Fail pci_ioremap_bar() on unassigned resources (Bjorn Helgaas)
        - Assign resources before drivers claim devices (Yijing Wang)
        - Claim bus resources before pci_bus_add_devices() (Yijing Wang)
    
      Power management
        - Optimize device state transition delays (Aaron Lu)
        - Don't clear ASPM bits when the FADT declares it's unsupported (Matthew Garrett)
    
      Virtualization
        - Add ACS quirks for Intel 1G NICs (Alex Williamson)
    
      IOMMU
        - Add ptr to OF node arg to of_iommu_configure() (Murali Karicheri)
        - Move of_dma_configure() to device.c to help re-use (Murali Karicheri)
        - Fix size when dma-range is not used (Murali Karicheri)
        - Add helper functions pci_get[put]_host_bridge_device() (Murali Karicheri)
        - Add of_pci_dma_configure() to update DMA configuration (Murali Karicheri)
        - Update DMA configuration from DT (Murali Karicheri)
        - dma-mapping: limit IOMMU mapping size (Murali Karicheri)
        - Calculate device DMA masks based on DT dma-range size (Murali Karicheri)
    
      ARM Versatile host bridge driver
        - Check for devm_ioremap_resource() failures (Jisheng Zhang)
    
      Broadcom iProc host bridge driver
        - Add Broadcom iProc PCIe driver (Ray Jui)
    
      Marvell MVEBU host bridge driver
        - Add suspend/resume support (Thomas Petazzoni)
    
      Renesas R-Car host bridge driver
        - Fix position of MSI enable bit (Nobuhiro Iwamatsu)
        - Write zeroes to reserved PCIEPARL bits (Nobuhiro Iwamatsu)
        - Change PCIEPARL and PCIEPARH to PCIEPALR and PCIEPAUR (Nobuhiro Iwamatsu)
        - Verify that mem_res is 64K-aligned (Nobuhiro Iwamatsu)
    
      Samsung Exynos host bridge driver
        - Fix INTx enablement statement termination error (Jaehoon Chung)
    
      Miscellaneous
        - Make a shareable UUID for PCI firmware ACPI _DSM (Aaron Lu)
        - Clarify policy for vendor IDs in pci.txt (Michael S. Tsirkin)"
    
    * tag 'pci-v4.1-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (36 commits)
      PCI: Read capability list as dwords, not bytes
      PCI: layerscape: Simplify platform_get_resource_byname() failure checking
      PCI: keystone: Don't dereference possible NULL pointer
      PCI: versatile: Check for devm_ioremap_resource() failures
      PCI: Don't clear ASPM bits when the FADT declares it's unsupported
      PCI: Clarify policy for vendor IDs in pci.txt
      PCI/ACPI: Optimize device state transition delays
      PCI: Export pci_find_host_bridge() for use inside PCI core
      PCI: Make a shareable UUID for PCI firmware ACPI _DSM
      PCI: Fix typo in Thunderbolt kernel message
      PCI: exynos: Fix INTx enablement statement termination error
      PCI: iproc: Add Broadcom iProc PCIe support
      PCI: iproc: Add DT docs for Broadcom iProc PCIe driver
      PCI: Export symbols required for loadable host driver modules
      PCI: Add ACS quirks for Intel 1G NICs
      PCI: mvebu: Add suspend/resume support
      PCI: Cleanup control flow
      sparc/PCI: Claim bus resources before pci_bus_add_devices()
      PCI: Assign resources before drivers claim devices (pci_scan_root_bus())
      PCI: Fail pci_ioremap_bar() on unassigned resources
      ...

commit e33caa82e221b0bbeba373b507e3f134dc2efa1a
Author: Aaron Lu <aaron.lu@intel.com>
Date:   Wed Mar 25 14:37:06 2015 +0800

    PCI/ACPI: Optimize device state transition delays
    
    The PCI "ACPI additions for FW latency optimizations" ECN (link below)
    defines two functions in the PCI _DSM:
    
      Function 8, "Reset Delay," applies to the entire hierarchy below a PCI
      host bridge.  If it returns one, the OS may assume that all devices in
      the hierarchy have already completed power-on reset delays.
    
      Function 9, "Device Readiness Durations," applies only to the object
      where it is located.  It returns delay durations required after various
      events if the device requires less time than the spec requires.  Delays
      from this function take precedence over the Reset Delay function.
    
    Add support for Reset Delay and part of Device Readiness Durations.
    
    [bhelgaas: changelog, comments]
    Link: https://www.pcisig.com/specifications/conventional/pci_firmware/ECN_fw_latency_optimization_final.pdf
    Signed-off-by: Aaron Lu <aaron.lu@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index bea6be4992c3..5eba74716900 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -537,11 +537,32 @@ static struct pci_platform_pm_ops acpi_pci_platform_pm = {
 
 void acpi_pci_add_bus(struct pci_bus *bus)
 {
+	union acpi_object *obj;
+	struct pci_host_bridge *bridge;
+
 	if (acpi_pci_disabled || !bus->bridge)
 		return;
 
 	acpi_pci_slot_enumerate(bus);
 	acpiphp_enumerate_slots(bus);
+
+	/*
+	 * For a host bridge, check its _DSM for function 8 and if
+	 * that is available, mark it in pci_host_bridge.
+	 */
+	if (!pci_is_root_bus(bus))
+		return;
+
+	obj = acpi_evaluate_dsm(ACPI_HANDLE(bus->bridge), pci_acpi_dsm_uuid, 3,
+				RESET_DELAY_DSM, NULL);
+	if (!obj)
+		return;
+
+	if (obj->type == ACPI_TYPE_INTEGER && obj->integer.value == 1) {
+		bridge = pci_find_host_bridge(bus);
+		bridge->ignore_reset_delay = 1;
+	}
+	ACPI_FREE(obj);
 }
 
 void acpi_pci_remove_bus(struct pci_bus *bus)
@@ -567,6 +588,57 @@ static struct acpi_device *acpi_pci_find_companion(struct device *dev)
 				      check_children);
 }
 
+/**
+ * pci_acpi_optimize_delay - optimize PCI D3 and D3cold delay from ACPI
+ * @pdev: the PCI device whose delay is to be updated
+ * @adev: the companion ACPI device of this PCI device
+ *
+ * Update the d3_delay and d3cold_delay of a PCI device from the ACPI _DSM
+ * control method of either the device itself or the PCI host bridge.
+ *
+ * Function 8, "Reset Delay," applies to the entire hierarchy below a PCI
+ * host bridge.  If it returns one, the OS may assume that all devices in
+ * the hierarchy have already completed power-on reset delays.
+ *
+ * Function 9, "Device Readiness Durations," applies only to the object
+ * where it is located.  It returns delay durations required after various
+ * events if the device requires less time than the spec requires.  Delays
+ * from this function take precedence over the Reset Delay function.
+ *
+ * These _DSM functions are defined by the draft ECN of January 28, 2014,
+ * titled "ACPI additions for FW latency optimizations."
+ */
+static void pci_acpi_optimize_delay(struct pci_dev *pdev,
+				    acpi_handle handle)
+{
+	struct pci_host_bridge *bridge = pci_find_host_bridge(pdev->bus);
+	int value;
+	union acpi_object *obj, *elements;
+
+	if (bridge->ignore_reset_delay)
+		pdev->d3cold_delay = 0;
+
+	obj = acpi_evaluate_dsm(handle, pci_acpi_dsm_uuid, 3,
+				FUNCTION_DELAY_DSM, NULL);
+	if (!obj)
+		return;
+
+	if (obj->type == ACPI_TYPE_PACKAGE && obj->package.count == 5) {
+		elements = obj->package.elements;
+		if (elements[0].type == ACPI_TYPE_INTEGER) {
+			value = (int)elements[0].integer.value / 1000;
+			if (value < PCI_PM_D3COLD_WAIT)
+				pdev->d3cold_delay = value;
+		}
+		if (elements[3].type == ACPI_TYPE_INTEGER) {
+			value = (int)elements[3].integer.value / 1000;
+			if (value < PCI_PM_D3_WAIT)
+				pdev->d3_delay = value;
+		}
+	}
+	ACPI_FREE(obj);
+}
+
 static void pci_acpi_setup(struct device *dev)
 {
 	struct pci_dev *pci_dev = to_pci_dev(dev);
@@ -575,6 +647,8 @@ static void pci_acpi_setup(struct device *dev)
 	if (!adev)
 		return;
 
+	pci_acpi_optimize_delay(pci_dev, adev->handle);
+
 	pci_acpi_add_pm_notifier(adev, pci_dev);
 	if (!adev->wakeup.flags.valid)
 		return;

commit 18e94a3384368340d438cf67fcaebd72084f34f8
Author: Aaron Lu <aaron.lu@intel.com>
Date:   Wed Mar 25 14:31:41 2015 +0800

    PCI: Make a shareable UUID for PCI firmware ACPI _DSM
    
    The PCI Firmware Specification, r3.0, sec 4.6.4.1.3, defines a single UUID
    for an ACPI _DSM method to provide device-specific control functions.  This
    _DSM method support several functions, including PCI Express Slot
    Information, PCI Express Slot Number, PCI Bus Capabilities, etc.
    
    Move the UUID definition from pci/pci-label.c, where it could be used only
    for one function, to pci/pci-acpi.c where it can be shared for all these
    functions.
    
    [bhelgaas: changelog]
    Signed-off-by: Aaron Lu <aaron.lu@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 489063987325..bea6be4992c3 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -18,6 +18,15 @@
 #include <linux/pm_qos.h>
 #include "pci.h"
 
+/*
+ * The UUID is defined in the PCI Firmware Specification available here:
+ * https://www.pcisig.com/members/downloads/pcifw_r3_1_13Dec10.pdf
+ */
+const u8 pci_acpi_dsm_uuid[] = {
+	0xd0, 0x37, 0xc9, 0xe5, 0x53, 0x35, 0x7a, 0x4d,
+	0x91, 0x17, 0xea, 0x4d, 0x19, 0xc3, 0x43, 0x4d
+};
+
 phys_addr_t acpi_pci_root_get_mcfg_addr(acpi_handle handle)
 {
 	acpi_status status = AE_NOT_EXIST;

commit 8647ca9ad5a0065ad53a2ad7e39163592b6ed35e
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Mar 24 11:12:45 2015 -0500

    PCI: Don't look for ACPI hotplug parameters if ACPI is disabled
    
    Booting a v3.18 or newer Xen domU kernel with PCI devices passed through
    results in an oops (this is a 32-bit 3.13.11 dom0 with a 64-bit 4.4.0
    hypervisor and 32-bit domU):
    
      BUG: unable to handle kernel paging request at 0030303e
      IP: [<c06ed0e6>] acpi_ns_validate_handle+0x12/0x1a
      Call Trace:
       [<c06eda4d>] ? acpi_evaluate_object+0x31/0x1fc
       [<c06b78e1>] ? pci_get_hp_params+0x111/0x4e0
       [<c0407bc7>] ? xen_force_evtchn_callback+0x17/0x30
       [<c04085fb>] ? xen_restore_fl_direct_reloc+0x4/0x4
       [<c0699d34>] ? pci_device_add+0x24/0x450
    
    Don't look for ACPI configuration information if ACPI has been disabled.
    
    I don't think this is the best fix, because we can boot plain Linux (no
    Xen) with "acpi=off", and we don't need this check in pci_get_hp_params().
    There should be a better fix that would make Xen domU work the same way.
    The domU kernel has ACPI support but it has no AML.  There should be a way
    to initialize the ACPI data structures so things fail gracefully rather
    than oopsing.  This is an interim fix to address the regression.
    
    Fixes: 6cd33649fa83 ("PCI: Add pci_configure_device() during enumeration")
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=96301
    Reported-by: Michael D Labriola <mlabriol@gdeb.com>
    Tested-by: Michael D Labriola <mlabriol@gdeb.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    CC: stable@vger.kernel.org      # v3.18+

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 489063987325..c93fbe76d281 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -248,6 +248,9 @@ int pci_get_hp_params(struct pci_dev *dev, struct hotplug_params *hpp)
 	acpi_handle handle, phandle;
 	struct pci_bus *pbus;
 
+	if (acpi_pci_disabled)
+		return -ENODEV;
+
 	handle = NULL;
 	for (pbus = dev->bus; pbus; pbus = pbus->parent) {
 		handle = acpi_pci_get_bridge_handle(pbus);

commit bac2a909a096c9110525c18cbb8ce73c660d5f71
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Jan 21 02:17:42 2015 +0100

    PCI / PM: Avoid resuming PCI devices during system suspend
    
    Commit f25c0ae2b4c4 (ACPI / PM: Avoid resuming devices in ACPI PM
    domain during system suspend) modified the ACPI PM domain's system
    suspend callbacks to allow devices attached to it to be left in the
    runtime-suspended state during system suspend so as to optimize
    the suspend process.
    
    This was based on the general mechanism introduced by commit
    aae4518b3124 (PM / sleep: Mechanism to avoid resuming runtime-suspended
    devices unnecessarily).
    
    Extend that approach to PCI devices by modifying the PCI bus type's
    ->prepare callback to return 1 for devices that are runtime-suspended
    when it is being executed and that are in a suitable power state and
    need not be resumed going forward.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 3542150fc8a3..489063987325 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -501,12 +501,29 @@ static int acpi_pci_run_wake(struct pci_dev *dev, bool enable)
 	return 0;
 }
 
+static bool acpi_pci_need_resume(struct pci_dev *dev)
+{
+	struct acpi_device *adev = ACPI_COMPANION(&dev->dev);
+
+	if (!adev || !acpi_device_power_manageable(adev))
+		return false;
+
+	if (device_may_wakeup(&dev->dev) != !!adev->wakeup.prepare_count)
+		return true;
+
+	if (acpi_target_system_state() == ACPI_STATE_S0)
+		return false;
+
+	return !!adev->power.flags.dsw_present;
+}
+
 static struct pci_platform_pm_ops acpi_pci_platform_pm = {
 	.is_manageable = acpi_pci_power_manageable,
 	.set_state = acpi_pci_set_power_state,
 	.choose_state = acpi_pci_choose_state,
 	.sleep_wake = acpi_pci_sleep_wake,
 	.run_wake = acpi_pci_run_wake,
+	.need_resume = acpi_pci_need_resume,
 };
 
 void acpi_pci_add_bus(struct pci_bus *bus)

commit ff0387c3777f2438bad2088abe442c9f231b0be4
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Mon Nov 10 21:02:17 2014 -0700

    PCI: Delete unnecessary NULL pointer checks
    
    The functions pci_dev_put(), pci_pme_wakeup_bus(), and put_device() return
    immediately if their argument is NULL.  Thus the test before the call is
    not needed.
    
    Remove these unnecessary tests.
    
    This issue was detected by using the Coccinelle software.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 6ebf8edc5f3c..3542150fc8a3 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -322,8 +322,7 @@ static void pci_acpi_wake_dev(struct work_struct *work)
 	pci_wakeup_event(pci_dev);
 	pm_runtime_resume(&pci_dev->dev);
 
-	if (pci_dev->subordinate)
-		pci_pme_wakeup_bus(pci_dev->subordinate);
+	pci_pme_wakeup_bus(pci_dev->subordinate);
 }
 
 /**

commit 5e3d234456e25f664e0755c23689173588f4ca9b
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Sep 12 15:36:29 2014 -0600

    PCI: Shuffle pci-acpi.c functions to group them logically
    
    Move code around to put all the ACPI power management stuff together and
    all the pieces related to ACPI methods (_CBA, _HPP, _HPX) together.
    
    No functional change.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index e514d50eaddc..6ebf8edc5f3c 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -18,73 +18,6 @@
 #include <linux/pm_qos.h>
 #include "pci.h"
 
-/**
- * pci_acpi_wake_bus - Root bus wakeup notification fork function.
- * @work: Work item to handle.
- */
-static void pci_acpi_wake_bus(struct work_struct *work)
-{
-	struct acpi_device *adev;
-	struct acpi_pci_root *root;
-
-	adev = container_of(work, struct acpi_device, wakeup.context.work);
-	root = acpi_driver_data(adev);
-	pci_pme_wakeup_bus(root->bus);
-}
-
-/**
- * pci_acpi_wake_dev - PCI device wakeup notification work function.
- * @handle: ACPI handle of a device the notification is for.
- * @work: Work item to handle.
- */
-static void pci_acpi_wake_dev(struct work_struct *work)
-{
-	struct acpi_device_wakeup_context *context;
-	struct pci_dev *pci_dev;
-
-	context = container_of(work, struct acpi_device_wakeup_context, work);
-	pci_dev = to_pci_dev(context->dev);
-
-	if (pci_dev->pme_poll)
-		pci_dev->pme_poll = false;
-
-	if (pci_dev->current_state == PCI_D3cold) {
-		pci_wakeup_event(pci_dev);
-		pm_runtime_resume(&pci_dev->dev);
-		return;
-	}
-
-	/* Clear PME Status if set. */
-	if (pci_dev->pme_support)
-		pci_check_pme_status(pci_dev);
-
-	pci_wakeup_event(pci_dev);
-	pm_runtime_resume(&pci_dev->dev);
-
-	if (pci_dev->subordinate)
-		pci_pme_wakeup_bus(pci_dev->subordinate);
-}
-
-/**
- * pci_acpi_add_bus_pm_notifier - Register PM notifier for root PCI bus.
- * @dev: PCI root bridge ACPI device.
- */
-acpi_status pci_acpi_add_bus_pm_notifier(struct acpi_device *dev)
-{
-	return acpi_add_pm_notifier(dev, NULL, pci_acpi_wake_bus);
-}
-
-/**
- * pci_acpi_add_pm_notifier - Register PM notifier for given PCI device.
- * @dev: ACPI device to add the notifier for.
- * @pci_dev: PCI device to check for the PME status if an event is signaled.
- */
-acpi_status pci_acpi_add_pm_notifier(struct acpi_device *dev,
-				     struct pci_dev *pci_dev)
-{
-	return acpi_add_pm_notifier(dev, &pci_dev->dev, pci_acpi_wake_dev);
-}
-
 phys_addr_t acpi_pci_root_get_mcfg_addr(acpi_handle handle)
 {
 	acpi_status status = AE_NOT_EXIST;
@@ -346,6 +279,73 @@ int pci_get_hp_params(struct pci_dev *dev, struct hotplug_params *hpp)
 }
 EXPORT_SYMBOL_GPL(pci_get_hp_params);
 
+/**
+ * pci_acpi_wake_bus - Root bus wakeup notification fork function.
+ * @work: Work item to handle.
+ */
+static void pci_acpi_wake_bus(struct work_struct *work)
+{
+	struct acpi_device *adev;
+	struct acpi_pci_root *root;
+
+	adev = container_of(work, struct acpi_device, wakeup.context.work);
+	root = acpi_driver_data(adev);
+	pci_pme_wakeup_bus(root->bus);
+}
+
+/**
+ * pci_acpi_wake_dev - PCI device wakeup notification work function.
+ * @handle: ACPI handle of a device the notification is for.
+ * @work: Work item to handle.
+ */
+static void pci_acpi_wake_dev(struct work_struct *work)
+{
+	struct acpi_device_wakeup_context *context;
+	struct pci_dev *pci_dev;
+
+	context = container_of(work, struct acpi_device_wakeup_context, work);
+	pci_dev = to_pci_dev(context->dev);
+
+	if (pci_dev->pme_poll)
+		pci_dev->pme_poll = false;
+
+	if (pci_dev->current_state == PCI_D3cold) {
+		pci_wakeup_event(pci_dev);
+		pm_runtime_resume(&pci_dev->dev);
+		return;
+	}
+
+	/* Clear PME Status if set. */
+	if (pci_dev->pme_support)
+		pci_check_pme_status(pci_dev);
+
+	pci_wakeup_event(pci_dev);
+	pm_runtime_resume(&pci_dev->dev);
+
+	if (pci_dev->subordinate)
+		pci_pme_wakeup_bus(pci_dev->subordinate);
+}
+
+/**
+ * pci_acpi_add_bus_pm_notifier - Register PM notifier for root PCI bus.
+ * @dev: PCI root bridge ACPI device.
+ */
+acpi_status pci_acpi_add_bus_pm_notifier(struct acpi_device *dev)
+{
+	return acpi_add_pm_notifier(dev, NULL, pci_acpi_wake_bus);
+}
+
+/**
+ * pci_acpi_add_pm_notifier - Register PM notifier for given PCI device.
+ * @dev: ACPI device to add the notifier for.
+ * @pci_dev: PCI device to check for the PME status if an event is signaled.
+ */
+acpi_status pci_acpi_add_pm_notifier(struct acpi_device *dev,
+				     struct pci_dev *pci_dev)
+{
+	return acpi_add_pm_notifier(dev, &pci_dev->dev, pci_acpi_wake_dev);
+}
+
 /*
  * _SxD returns the D-state with the highest power
  * (lowest D-state number) supported in the S-state "x".

commit abbfec34e1df3073429cd6b0fad1c26635597799
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Sep 12 15:29:55 2014 -0600

    PCI: Whitespace cleanup in pci-acpi.c
    
    Whitespace fixes only; no functional change.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 06e0b41c397e..e514d50eaddc 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -99,8 +99,8 @@ phys_addr_t acpi_pci_root_get_mcfg_addr(acpi_handle handle)
 	return (phys_addr_t)mcfg_addr;
 }
 
-static acpi_status
-decode_type0_hpx_record(union acpi_object *record, struct hotplug_params *hpx)
+static acpi_status decode_type0_hpx_record(union acpi_object *record,
+					   struct hotplug_params *hpx)
 {
 	int i;
 	union acpi_object *fields = record->package.elements;
@@ -129,8 +129,8 @@ decode_type0_hpx_record(union acpi_object *record, struct hotplug_params *hpx)
 	return AE_OK;
 }
 
-static acpi_status
-decode_type1_hpx_record(union acpi_object *record, struct hotplug_params *hpx)
+static acpi_status decode_type1_hpx_record(union acpi_object *record,
+					   struct hotplug_params *hpx)
 {
 	int i;
 	union acpi_object *fields = record->package.elements;
@@ -158,8 +158,8 @@ decode_type1_hpx_record(union acpi_object *record, struct hotplug_params *hpx)
 	return AE_OK;
 }
 
-static acpi_status
-decode_type2_hpx_record(union acpi_object *record, struct hotplug_params *hpx)
+static acpi_status decode_type2_hpx_record(union acpi_object *record,
+					   struct hotplug_params *hpx)
 {
 	int i;
 	union acpi_object *fields = record->package.elements;
@@ -200,8 +200,7 @@ decode_type2_hpx_record(union acpi_object *record, struct hotplug_params *hpx)
 	return AE_OK;
 }
 
-static acpi_status
-acpi_run_hpx(acpi_handle handle, struct hotplug_params *hpx)
+static acpi_status acpi_run_hpx(acpi_handle handle, struct hotplug_params *hpx)
 {
 	acpi_status status;
 	struct acpi_buffer buffer = {ACPI_ALLOCATE_BUFFER, NULL};
@@ -265,8 +264,7 @@ acpi_run_hpx(acpi_handle handle, struct hotplug_params *hpx)
 	return status;
 }
 
-static acpi_status
-acpi_run_hpp(acpi_handle handle, struct hotplug_params *hpp)
+static acpi_status acpi_run_hpp(acpi_handle handle, struct hotplug_params *hpp)
 {
 	acpi_status status;
 	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };

commit 9ce90ea5c0d512ff66693b238167b56dbaef786b
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Sep 12 15:23:14 2014 -0600

    PCI: Move pci_get_hp_params() to drivers/pci/pci-acpi.c
    
    Move pci_get_hp_params() and related functions from
    drivers/pci/hotplug/acpi_pcihp.c to drivers/pci/pci-acpi.c.
    
    Previously, pci_get_hp_params() was used only by hotplug drivers.  But
    future changes will move this into the normal device enumeration process,
    so it will be used even when CONFIG_HOTPLUG_PCI is not set.
    
    No functional change.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 37263b0ebfe3..06e0b41c397e 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -10,6 +10,7 @@
 #include <linux/delay.h>
 #include <linux/init.h>
 #include <linux/pci.h>
+#include <linux/pci_hotplug.h>
 #include <linux/module.h>
 #include <linux/pci-aspm.h>
 #include <linux/pci-acpi.h>
@@ -98,6 +99,255 @@ phys_addr_t acpi_pci_root_get_mcfg_addr(acpi_handle handle)
 	return (phys_addr_t)mcfg_addr;
 }
 
+static acpi_status
+decode_type0_hpx_record(union acpi_object *record, struct hotplug_params *hpx)
+{
+	int i;
+	union acpi_object *fields = record->package.elements;
+	u32 revision = fields[1].integer.value;
+
+	switch (revision) {
+	case 1:
+		if (record->package.count != 6)
+			return AE_ERROR;
+		for (i = 2; i < 6; i++)
+			if (fields[i].type != ACPI_TYPE_INTEGER)
+				return AE_ERROR;
+		hpx->t0 = &hpx->type0_data;
+		hpx->t0->revision        = revision;
+		hpx->t0->cache_line_size = fields[2].integer.value;
+		hpx->t0->latency_timer   = fields[3].integer.value;
+		hpx->t0->enable_serr     = fields[4].integer.value;
+		hpx->t0->enable_perr     = fields[5].integer.value;
+		break;
+	default:
+		printk(KERN_WARNING
+		       "%s: Type 0 Revision %d record not supported\n",
+		       __func__, revision);
+		return AE_ERROR;
+	}
+	return AE_OK;
+}
+
+static acpi_status
+decode_type1_hpx_record(union acpi_object *record, struct hotplug_params *hpx)
+{
+	int i;
+	union acpi_object *fields = record->package.elements;
+	u32 revision = fields[1].integer.value;
+
+	switch (revision) {
+	case 1:
+		if (record->package.count != 5)
+			return AE_ERROR;
+		for (i = 2; i < 5; i++)
+			if (fields[i].type != ACPI_TYPE_INTEGER)
+				return AE_ERROR;
+		hpx->t1 = &hpx->type1_data;
+		hpx->t1->revision      = revision;
+		hpx->t1->max_mem_read  = fields[2].integer.value;
+		hpx->t1->avg_max_split = fields[3].integer.value;
+		hpx->t1->tot_max_split = fields[4].integer.value;
+		break;
+	default:
+		printk(KERN_WARNING
+		       "%s: Type 1 Revision %d record not supported\n",
+		       __func__, revision);
+		return AE_ERROR;
+	}
+	return AE_OK;
+}
+
+static acpi_status
+decode_type2_hpx_record(union acpi_object *record, struct hotplug_params *hpx)
+{
+	int i;
+	union acpi_object *fields = record->package.elements;
+	u32 revision = fields[1].integer.value;
+
+	switch (revision) {
+	case 1:
+		if (record->package.count != 18)
+			return AE_ERROR;
+		for (i = 2; i < 18; i++)
+			if (fields[i].type != ACPI_TYPE_INTEGER)
+				return AE_ERROR;
+		hpx->t2 = &hpx->type2_data;
+		hpx->t2->revision      = revision;
+		hpx->t2->unc_err_mask_and      = fields[2].integer.value;
+		hpx->t2->unc_err_mask_or       = fields[3].integer.value;
+		hpx->t2->unc_err_sever_and     = fields[4].integer.value;
+		hpx->t2->unc_err_sever_or      = fields[5].integer.value;
+		hpx->t2->cor_err_mask_and      = fields[6].integer.value;
+		hpx->t2->cor_err_mask_or       = fields[7].integer.value;
+		hpx->t2->adv_err_cap_and       = fields[8].integer.value;
+		hpx->t2->adv_err_cap_or        = fields[9].integer.value;
+		hpx->t2->pci_exp_devctl_and    = fields[10].integer.value;
+		hpx->t2->pci_exp_devctl_or     = fields[11].integer.value;
+		hpx->t2->pci_exp_lnkctl_and    = fields[12].integer.value;
+		hpx->t2->pci_exp_lnkctl_or     = fields[13].integer.value;
+		hpx->t2->sec_unc_err_sever_and = fields[14].integer.value;
+		hpx->t2->sec_unc_err_sever_or  = fields[15].integer.value;
+		hpx->t2->sec_unc_err_mask_and  = fields[16].integer.value;
+		hpx->t2->sec_unc_err_mask_or   = fields[17].integer.value;
+		break;
+	default:
+		printk(KERN_WARNING
+		       "%s: Type 2 Revision %d record not supported\n",
+		       __func__, revision);
+		return AE_ERROR;
+	}
+	return AE_OK;
+}
+
+static acpi_status
+acpi_run_hpx(acpi_handle handle, struct hotplug_params *hpx)
+{
+	acpi_status status;
+	struct acpi_buffer buffer = {ACPI_ALLOCATE_BUFFER, NULL};
+	union acpi_object *package, *record, *fields;
+	u32 type;
+	int i;
+
+	/* Clear the return buffer with zeros */
+	memset(hpx, 0, sizeof(struct hotplug_params));
+
+	status = acpi_evaluate_object(handle, "_HPX", NULL, &buffer);
+	if (ACPI_FAILURE(status))
+		return status;
+
+	package = (union acpi_object *)buffer.pointer;
+	if (package->type != ACPI_TYPE_PACKAGE) {
+		status = AE_ERROR;
+		goto exit;
+	}
+
+	for (i = 0; i < package->package.count; i++) {
+		record = &package->package.elements[i];
+		if (record->type != ACPI_TYPE_PACKAGE) {
+			status = AE_ERROR;
+			goto exit;
+		}
+
+		fields = record->package.elements;
+		if (fields[0].type != ACPI_TYPE_INTEGER ||
+		    fields[1].type != ACPI_TYPE_INTEGER) {
+			status = AE_ERROR;
+			goto exit;
+		}
+
+		type = fields[0].integer.value;
+		switch (type) {
+		case 0:
+			status = decode_type0_hpx_record(record, hpx);
+			if (ACPI_FAILURE(status))
+				goto exit;
+			break;
+		case 1:
+			status = decode_type1_hpx_record(record, hpx);
+			if (ACPI_FAILURE(status))
+				goto exit;
+			break;
+		case 2:
+			status = decode_type2_hpx_record(record, hpx);
+			if (ACPI_FAILURE(status))
+				goto exit;
+			break;
+		default:
+			printk(KERN_ERR "%s: Type %d record not supported\n",
+			       __func__, type);
+			status = AE_ERROR;
+			goto exit;
+		}
+	}
+ exit:
+	kfree(buffer.pointer);
+	return status;
+}
+
+static acpi_status
+acpi_run_hpp(acpi_handle handle, struct hotplug_params *hpp)
+{
+	acpi_status status;
+	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
+	union acpi_object *package, *fields;
+	int i;
+
+	memset(hpp, 0, sizeof(struct hotplug_params));
+
+	status = acpi_evaluate_object(handle, "_HPP", NULL, &buffer);
+	if (ACPI_FAILURE(status))
+		return status;
+
+	package = (union acpi_object *) buffer.pointer;
+	if (package->type != ACPI_TYPE_PACKAGE ||
+	    package->package.count != 4) {
+		status = AE_ERROR;
+		goto exit;
+	}
+
+	fields = package->package.elements;
+	for (i = 0; i < 4; i++) {
+		if (fields[i].type != ACPI_TYPE_INTEGER) {
+			status = AE_ERROR;
+			goto exit;
+		}
+	}
+
+	hpp->t0 = &hpp->type0_data;
+	hpp->t0->revision        = 1;
+	hpp->t0->cache_line_size = fields[0].integer.value;
+	hpp->t0->latency_timer   = fields[1].integer.value;
+	hpp->t0->enable_serr     = fields[2].integer.value;
+	hpp->t0->enable_perr     = fields[3].integer.value;
+
+exit:
+	kfree(buffer.pointer);
+	return status;
+}
+
+/* pci_get_hp_params
+ *
+ * @dev - the pci_dev for which we want parameters
+ * @hpp - allocated by the caller
+ */
+int pci_get_hp_params(struct pci_dev *dev, struct hotplug_params *hpp)
+{
+	acpi_status status;
+	acpi_handle handle, phandle;
+	struct pci_bus *pbus;
+
+	handle = NULL;
+	for (pbus = dev->bus; pbus; pbus = pbus->parent) {
+		handle = acpi_pci_get_bridge_handle(pbus);
+		if (handle)
+			break;
+	}
+
+	/*
+	 * _HPP settings apply to all child buses, until another _HPP is
+	 * encountered. If we don't find an _HPP for the input pci dev,
+	 * look for it in the parent device scope since that would apply to
+	 * this pci dev.
+	 */
+	while (handle) {
+		status = acpi_run_hpx(handle, hpp);
+		if (ACPI_SUCCESS(status))
+			return 0;
+		status = acpi_run_hpp(handle, hpp);
+		if (ACPI_SUCCESS(status))
+			return 0;
+		if (acpi_is_root_bridge(handle))
+			break;
+		status = acpi_get_parent(handle, &phandle);
+		if (ACPI_FAILURE(status))
+			break;
+		handle = phandle;
+	}
+	return -ENODEV;
+}
+EXPORT_SYMBOL_GPL(pci_get_hp_params);
+
 /*
  * _SxD returns the D-state with the highest power
  * (lowest D-state number) supported in the S-state "x".

commit 91af125c33af02340355b96a6ed0761e5132cde0
Merge: 805c52815825 e70dba6020ea 85dbb3d05ec6
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Jul 27 23:55:35 2014 +0200

    Merge branches 'acpi-pnp' and 'acpi-pci'
    
    * acpi-pnp:
      ACPI / PNP: Use ACPI_COMPANION() instead of ACPI_HANDLE()
      ACPI / PNP: do ACPI binding directly
    
    * acpi-pci:
      ACPI / PCI: Use ACPI_COMPANION() instead of ACPI_HANDLE()

commit 85dbb3d05ec6d063f6f8ad4d6dfc13793d566374
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jul 24 01:18:53 2014 +0200

    ACPI / PCI: Use ACPI_COMPANION() instead of ACPI_HANDLE()
    
    The ACPI_HANDLE() macro evaluates ACPI_COMPANION() internally to
    return the handle of the device's ACPI companion, so it is much
    more straightforward and efficient to use ACPI_COMPANION()
    directly to obtain the device's ACPI companion object instead of
    using ACPI_HANDLE() and acpi_bus_get_device() on the returned
    handle for the same thing.
    
    Use ACPI_COMPANION() instead of ACPI_HANDLE() in the PCI ACPI support
    code.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index ca4927ba8433..740efa8be969 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -170,14 +170,13 @@ static pci_power_t acpi_pci_choose_state(struct pci_dev *pdev)
 
 static bool acpi_pci_power_manageable(struct pci_dev *dev)
 {
-	acpi_handle handle = ACPI_HANDLE(&dev->dev);
-
-	return handle ? acpi_bus_power_manageable(handle) : false;
+	struct acpi_device *adev = ACPI_COMPANION(&dev->dev);
+	return adev ? acpi_device_power_manageable(adev) : false;
 }
 
 static int acpi_pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 {
-	acpi_handle handle = ACPI_HANDLE(&dev->dev);
+	struct acpi_device *adev = ACPI_COMPANION(&dev->dev);
 	static const u8 state_conv[] = {
 		[PCI_D0] = ACPI_STATE_D0,
 		[PCI_D1] = ACPI_STATE_D1,
@@ -188,7 +187,7 @@ static int acpi_pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 	int error = -EINVAL;
 
 	/* If the ACPI device has _EJ0, ignore the device */
-	if (!handle || acpi_has_method(handle, "_EJ0"))
+	if (!adev || acpi_has_method(adev->handle, "_EJ0"))
 		return -ENODEV;
 
 	switch (state) {
@@ -202,7 +201,7 @@ static int acpi_pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 	case PCI_D1:
 	case PCI_D2:
 	case PCI_D3hot:
-		error = acpi_bus_set_power(handle, state_conv[state]);
+		error = acpi_device_set_power(adev, state_conv[state]);
 	}
 
 	if (!error)
@@ -214,9 +213,8 @@ static int acpi_pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 
 static bool acpi_pci_can_wakeup(struct pci_dev *dev)
 {
-	acpi_handle handle = ACPI_HANDLE(&dev->dev);
-
-	return handle ? acpi_bus_can_wakeup(handle) : false;
+	struct acpi_device *adev = ACPI_COMPANION(&dev->dev);
+	return adev ? acpi_device_can_wakeup(adev) : false;
 }
 
 static void acpi_pci_propagate_wakeup_enable(struct pci_bus *bus, bool enable)

commit c072530f391e33bd22ed0638c08f07528f154493
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Jul 23 01:00:45 2014 +0200

    ACPI / PM: Revork the handling of ACPI device wakeup notifications
    
    Since ACPI wakeup GPEs are going to be enabled during system suspend
    as well as for runtime wakeup by a subsequent patch and the same
    notify handlers will be used in both cases, rework the ACPI device
    wakeup notification framework so that the part specific to physical
    devices is always run asynchronously from the PM workqueue.  This
    prevents runtime resume callbacks for those devices from being
    run during system suspend and resume which may not be appropriate,
    among other things.
    
    Also make ACPI device wakeup notification handling a bit more robust
    agaist subsequent removal of ACPI device objects, whould that ever
    happen, and create a wakeup source object for each ACPI device
    configured for wakeup so that wakeup notifications for those
    devices can wake up the system from the "freeze" sleep state.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index ca4927ba8433..7b8b2298840a 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -18,31 +18,31 @@
 #include "pci.h"
 
 /**
- * pci_acpi_wake_bus - Wake-up notification handler for root buses.
- * @handle: ACPI handle of a device the notification is for.
- * @event: Type of the signaled event.
- * @context: PCI root bus to wake up devices on.
+ * pci_acpi_wake_bus - Root bus wakeup notification fork function.
+ * @work: Work item to handle.
  */
-static void pci_acpi_wake_bus(acpi_handle handle, u32 event, void *context)
+static void pci_acpi_wake_bus(struct work_struct *work)
 {
-	struct pci_bus *pci_bus = context;
+	struct acpi_device *adev;
+	struct acpi_pci_root *root;
 
-	if (event == ACPI_NOTIFY_DEVICE_WAKE && pci_bus)
-		pci_pme_wakeup_bus(pci_bus);
+	adev = container_of(work, struct acpi_device, wakeup.context.work);
+	root = acpi_driver_data(adev);
+	pci_pme_wakeup_bus(root->bus);
 }
 
 /**
- * pci_acpi_wake_dev - Wake-up notification handler for PCI devices.
+ * pci_acpi_wake_dev - PCI device wakeup notification work function.
  * @handle: ACPI handle of a device the notification is for.
- * @event: Type of the signaled event.
- * @context: PCI device object to wake up.
+ * @work: Work item to handle.
  */
-static void pci_acpi_wake_dev(acpi_handle handle, u32 event, void *context)
+static void pci_acpi_wake_dev(struct work_struct *work)
 {
-	struct pci_dev *pci_dev = context;
+	struct acpi_device_wakeup_context *context;
+	struct pci_dev *pci_dev;
 
-	if (event != ACPI_NOTIFY_DEVICE_WAKE || !pci_dev)
-		return;
+	context = container_of(work, struct acpi_device_wakeup_context, work);
+	pci_dev = to_pci_dev(context->dev);
 
 	if (pci_dev->pme_poll)
 		pci_dev->pme_poll = false;
@@ -65,23 +65,12 @@ static void pci_acpi_wake_dev(acpi_handle handle, u32 event, void *context)
 }
 
 /**
- * pci_acpi_add_bus_pm_notifier - Register PM notifier for given PCI bus.
- * @dev: ACPI device to add the notifier for.
- * @pci_bus: PCI bus to walk checking for PME status if an event is signaled.
+ * pci_acpi_add_bus_pm_notifier - Register PM notifier for root PCI bus.
+ * @dev: PCI root bridge ACPI device.
  */
-acpi_status pci_acpi_add_bus_pm_notifier(struct acpi_device *dev,
-					 struct pci_bus *pci_bus)
+acpi_status pci_acpi_add_bus_pm_notifier(struct acpi_device *dev)
 {
-	return acpi_add_pm_notifier(dev, pci_acpi_wake_bus, pci_bus);
-}
-
-/**
- * pci_acpi_remove_bus_pm_notifier - Unregister PCI bus PM notifier.
- * @dev: ACPI device to remove the notifier from.
- */
-acpi_status pci_acpi_remove_bus_pm_notifier(struct acpi_device *dev)
-{
-	return acpi_remove_pm_notifier(dev, pci_acpi_wake_bus);
+	return acpi_add_pm_notifier(dev, NULL, pci_acpi_wake_bus);
 }
 
 /**
@@ -92,16 +81,7 @@ acpi_status pci_acpi_remove_bus_pm_notifier(struct acpi_device *dev)
 acpi_status pci_acpi_add_pm_notifier(struct acpi_device *dev,
 				     struct pci_dev *pci_dev)
 {
-	return acpi_add_pm_notifier(dev, pci_acpi_wake_dev, pci_dev);
-}
-
-/**
- * pci_acpi_remove_pm_notifier - Unregister PCI device PM notifier.
- * @dev: ACPI device to remove the notifier from.
- */
-acpi_status pci_acpi_remove_pm_notifier(struct acpi_device *dev)
-{
-	return acpi_remove_pm_notifier(dev, pci_acpi_wake_dev);
+	return acpi_add_pm_notifier(dev, &pci_dev->dev, pci_acpi_wake_dev);
 }
 
 phys_addr_t acpi_pci_root_get_mcfg_addr(acpi_handle handle)

commit 6788a51fe3391817c8ded5f43dd4c57f3d212c17
Author: Yijing Wang <wangyijing@huawei.com>
Date:   Sun May 4 12:23:38 2014 +0800

    PCI: Use pci_is_bridge() to simplify code
    
    Use pci_is_bridge() to simplify code.  No functional change.
    
    Requires: 326c1cdae741 PCI: Rename pci_is_bridge() to pci_has_subordinate()
    Requires: 1c86438c9423 PCI: Add new pci_is_bridge() interface
    Signed-off-by: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index f49abef88485..ca4927ba8433 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -309,13 +309,7 @@ static struct acpi_device *acpi_pci_find_companion(struct device *dev)
 	bool check_children;
 	u64 addr;
 
-	/*
-	 * pci_is_bridge() is not suitable here, because pci_dev->subordinate
-	 * is set only after acpi_pci_find_device() has been called for the
-	 * given device.
-	 */
-	check_children = pci_dev->hdr_type == PCI_HEADER_TYPE_BRIDGE
-			|| pci_dev->hdr_type == PCI_HEADER_TYPE_CARDBUS;
+	check_children = pci_is_bridge(pci_dev);
 	/* Please ref to ACPI spec for the syntax of _ADR */
 	addr = (PCI_SLOT(pci_dev->devfn) << 16) | PCI_FUNC(pci_dev->devfn);
 	return acpi_find_child_device(ACPI_COMPANION(dev->parent), addr,

commit 09da8dfa98682d871987145ed11e3232accac860
Merge: 3aacd625f201 7744064731a9
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jan 24 15:51:02 2014 -0800

    Merge tag 'pm+acpi-3.14-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull ACPI and power management updates from Rafael Wysocki:
     "As far as the number of commits goes, the top spot belongs to ACPI
      this time with cpufreq in the second position and a handful of PM
      core, PNP and cpuidle updates.  They are fixes and cleanups mostly, as
      usual, with a couple of new features in the mix.
    
      The most visible change is probably that we will create struct
      acpi_device objects (visible in sysfs) for all devices represented in
      the ACPI tables regardless of their status and there will be a new
      sysfs attribute under those objects allowing user space to check that
      status via _STA.
    
      Consequently, ACPI device eject or generally hot-removal will not
      delete those objects, unless the table containing the corresponding
      namespace nodes is unloaded, which is extremely rare.  Also ACPI
      container hotplug will be handled quite a bit differently and cpufreq
      will support CPU boost ("turbo") generically and not only in the
      acpi-cpufreq driver.
    
      Specifics:
    
       - ACPI core changes to make it create a struct acpi_device object for
         every device represented in the ACPI tables during all namespace
         scans regardless of the current status of that device.  In
         accordance with this, ACPI hotplug operations will not delete those
         objects, unless the underlying ACPI tables go away.
    
       - On top of the above, new sysfs attribute for ACPI device objects
         allowing user space to check device status by triggering the
         execution of _STA for its ACPI object.  From Srinivas Pandruvada.
    
       - ACPI core hotplug changes reducing code duplication, integrating
         the PCI root hotplug with the core and reworking container hotplug.
    
       - ACPI core simplifications making it use ACPI_COMPANION() in the
         code "glueing" ACPI device objects to "physical" devices.
    
       - ACPICA update to upstream version 20131218.  This adds support for
         the DBG2 and PCCT tables to ACPICA, fixes some bugs and improves
         debug facilities.  From Bob Moore, Lv Zheng and Betty Dall.
    
       - Init code change to carry out the early ACPI initialization
         earlier.  That should allow us to use ACPI during the timekeeping
         initialization and possibly to simplify the EFI initialization too.
         From Chun-Yi Lee.
    
       - Clenups of the inclusions of ACPI headers in many places all over
         from Lv Zheng and Rashika Kheria (work in progress).
    
       - New helper for ACPI _DSM execution and rework of the code in
         drivers that uses _DSM to execute it via the new helper.  From
         Jiang Liu.
    
       - New Win8 OSI blacklist entries from Takashi Iwai.
    
       - Assorted ACPI fixes and cleanups from Al Stone, Emil Goode, Hanjun
         Guo, Lan Tianyu, Masanari Iida, Oliver Neukum, Prarit Bhargava,
         Rashika Kheria, Tang Chen, Zhang Rui.
    
       - intel_pstate driver updates, including proper Baytrail support,
         from Dirk Brandewie and intel_pstate documentation from Ramkumar
         Ramachandra.
    
       - Generic CPU boost ("turbo") support for cpufreq from Lukasz
         Majewski.
    
       - powernow-k6 cpufreq driver fixes from Mikulas Patocka.
    
       - cpufreq core fixes and cleanups from Viresh Kumar, Jane Li, Mark
         Brown.
    
       - Assorted cpufreq drivers fixes and cleanups from Anson Huang, John
         Tobias, Paul Bolle, Paul Walmsley, Sachin Kamat, Shawn Guo, Viresh
         Kumar.
    
       - cpuidle cleanups from Bartlomiej Zolnierkiewicz.
    
       - Support for hibernation APM events from Bin Shi.
    
       - Hibernation fix to avoid bringing up nonboot CPUs with ACPI EC
         disabled during thaw transitions from Bjørn Mork.
    
       - PM core fixes and cleanups from Ben Dooks, Leonardo Potenza, Ulf
         Hansson.
    
       - PNP subsystem fixes and cleanups from Dmitry Torokhov, Levente
         Kurusa, Rashika Kheria.
    
       - New tool for profiling system suspend from Todd E Brandt and a
         cpupower tool cleanup from One Thousand Gnomes"
    
    * tag 'pm+acpi-3.14-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (153 commits)
      thermal: exynos: boost: Automatic enable/disable of BOOST feature (at Exynos4412)
      cpufreq: exynos4x12: Change L0 driver data to CPUFREQ_BOOST_FREQ
      Documentation: cpufreq / boost: Update BOOST documentation
      cpufreq: exynos: Extend Exynos cpufreq driver to support boost
      cpufreq / boost: Kconfig: Support for software-managed BOOST
      acpi-cpufreq: Adjust the code to use the common boost attribute
      cpufreq: Add boost frequency support in core
      intel_pstate: Add trace point to report internal state.
      cpufreq: introduce cpufreq_generic_get() routine
      ARM: SA1100: Create dummy clk_get_rate() to avoid build failures
      cpufreq: stats: create sysfs entries when cpufreq_stats is a module
      cpufreq: stats: free table and remove sysfs entry in a single routine
      cpufreq: stats: remove hotplug notifiers
      cpufreq: stats: handle cpufreq_unregister_driver() and suspend/resume properly
      cpufreq: speedstep: remove unused speedstep_get_state
      platform: introduce OF style 'modalias' support for platform bus
      PM / tools: new tool for suspend/resume performance optimization
      ACPI: fix module autoloading for ACPI enumerated devices
      ACPI: add module autoloading support for ACPI enumerated devices
      ACPI: fix create_modalias() return value handling
      ...

commit e1ba84597c9012b9f9075aac283ac7537d7561ba
Merge: 60eaa0190f6b cef09b808e58
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jan 22 16:39:28 2014 -0800

    Merge tag 'pci-v3.14-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI updates from Bjorn Helgaas:
     "PCI changes for the v3.14 merge window:
    
      Resource management
        - Change pci_bus_region addresses to dma_addr_t (Bjorn Helgaas)
        - Support 64-bit AGP BARs (Bjorn Helgaas, Yinghai Lu)
        - Add pci_bus_address() to get bus address of a BAR (Bjorn Helgaas)
        - Use pci_resource_start() for CPU address of AGP BARs (Bjorn Helgaas)
        - Enforce bus address limits in resource allocation (Yinghai Lu)
        - Allocate 64-bit BARs above 4G when possible (Yinghai Lu)
        - Convert pcibios_resource_to_bus() to take pci_bus, not pci_dev (Yinghai Lu)
    
      PCI device hotplug
        - Major rescan/remove locking update (Rafael J. Wysocki)
        - Make ioapic builtin only (not modular) (Yinghai Lu)
        - Fix release/free issues (Yinghai Lu)
        - Clean up pciehp (Bjorn Helgaas)
        - Announce pciehp slot info during enumeration (Bjorn Helgaas)
    
      MSI
        - Add pci_msi_vec_count(), pci_msix_vec_count() (Alexander Gordeev)
        - Add pci_enable_msi_range(), pci_enable_msix_range() (Alexander Gordeev)
        - Deprecate "tri-state" interfaces: fail/success/fail+info (Alexander Gordeev)
        - Export MSI mode using attributes, not kobjects (Greg Kroah-Hartman)
        - Drop "irq" param from *_restore_msi_irqs() (DuanZhenzhong)
    
      SR-IOV
        - Clear NumVFs when disabling SR-IOV in sriov_init() (ethan.zhao)
    
      Virtualization
        - Add support for save/restore of extended capabilities (Alex Williamson)
        - Add Virtual Channel to save/restore support (Alex Williamson)
        - Never treat a VF as a multifunction device (Alex Williamson)
        - Add pci_try_reset_function(), et al (Alex Williamson)
    
      AER
        - Ignore non-PCIe error sources (Betty Dall)
        - Support ACPI HEST error sources for domains other than 0 (Betty Dall)
        - Consolidate HEST error source parsers (Bjorn Helgaas)
        - Add a TLP header print helper (Borislav Petkov)
    
      Freescale i.MX6
        - Remove unnecessary code (Fabio Estevam)
        - Make reset-gpio optional (Marek Vasut)
        - Report "link up" only after link training completes (Marek Vasut)
        - Start link in Gen1 before negotiating for Gen2 mode (Marek Vasut)
        - Fix PCIe startup code (Richard Zhu)
    
      Marvell MVEBU
        - Remove duplicate of_clk_get_by_name() call (Andrew Lunn)
        - Drop writes to bridge Secondary Status register (Jason Gunthorpe)
        - Obey bridge PCI_COMMAND_MEM and PCI_COMMAND_IO bits (Jason Gunthorpe)
        - Support a bridge with no IO port window (Jason Gunthorpe)
        - Use max_t() instead of max(resource_size_t,) (Jingoo Han)
        - Remove redundant of_match_ptr (Sachin Kamat)
        - Call pci_ioremap_io() at startup instead of dynamically (Thomas Petazzoni)
    
      NVIDIA Tegra
        - Disable Gen2 for Tegra20 and Tegra30 (Eric Brower)
    
      Renesas R-Car
        - Add runtime PM support (Valentine Barshak)
        - Fix rcar_pci_probe() return value check (Wei Yongjun)
    
      Synopsys DesignWare
        - Fix crash in dw_msi_teardown_irq() (Bjørn Erik Nilsen)
        - Remove redundant call to pci_write_config_word() (Bjørn Erik Nilsen)
        - Fix missing MSI IRQs (Harro Haan)
        - Add dw_pcie prefix before cfg_read/write (Pratyush Anand)
        - Fix I/O transfers by using CPU (not realio) address (Pratyush Anand)
        - Whitespace cleanup (Jingoo Han)
    
      EISA
        - Call put_device() if device_register() fails (Levente Kurusa)
        - Revert EISA initialization breakage ((Bjorn Helgaas)
    
      Miscellaneous
        - Remove unused code, including PCIe 3.0 interfaces (Stephen Hemminger)
        - Prevent bus conflicts while checking for bridge apertures (Bjorn Helgaas)
        - Stop clearing bridge Secondary Status when setting up I/O aperture (Bjorn Helgaas)
        - Use dev_is_pci() to identify PCI devices (Yijing Wang)
        - Deprecate DEFINE_PCI_DEVICE_TABLE (Joe Perches)
        - Update documentation 00-INDEX (Erik Ekman)"
    
    * tag 'pci-v3.14-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (119 commits)
      Revert "EISA: Initialize device before its resources"
      Revert "EISA: Log device resources in dmesg"
      vfio-pci: Use pci "try" reset interface
      PCI: Check parent kobject in pci_destroy_dev()
      xen/pcifront: Use global PCI rescan-remove locking
      powerpc/eeh: Use global PCI rescan-remove locking
      PCI: Fix pci_check_and_unmask_intx() comment typos
      PCI: Add pci_try_reset_function(), pci_try_reset_slot(), pci_try_reset_bus()
      MPT / PCI: Use pci_stop_and_remove_bus_device_locked()
      platform / x86: Use global PCI rescan-remove locking
      PCI: hotplug: Use global PCI rescan-remove locking
      pcmcia: Use global PCI rescan-remove locking
      ACPI / hotplug / PCI: Use global PCI rescan-remove locking
      ACPI / PCI: Use global PCI rescan-remove locking in PCI root hotplug
      PCI: Add global pci_lock_rescan_remove()
      PCI: Cleanup pci.h whitespace
      PCI: Reorder so actual code comes before stubs
      PCI/AER: Support ACPI HEST AER error sources for PCI domains other than 0
      ACPICA: Add helper macros to extract bus/segment numbers from HEST table.
      PCI: Make local functions static
      ...

commit 25d412d932fb3289ae5b510845d523330b80bb71
Merge: 98feb7cc61c5 c713cd7f2d79
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Jan 12 23:45:04 2014 +0100

    Merge branch 'acpi-hotplug'
    
    * acpi-hotplug:
      ACPI / scan: ACPI device object sysfs attribute for _STA evaluation
      ACPI / hotplug / driver core: Handle containers in a special way
      ACPI / hotplug: Add demand_offline hotplug profile flag
      ACPI / bind: Move acpi_get_child() to drivers/ide/ide-acpi.c
      ACPI / bind: Pass struct acpi_device pointer to acpi_bind_one()
      ACPI / bind: Rework struct acpi_bus_type
      ACPI / bind: Redefine acpi_preset_companion()
      ACPI / bind: Redefine acpi_get_child()
      PCI / ACPI: Use acpi_find_child_device() for child devices lookup
      ACPI / bind: Simplify child device lookups
      ACPI / scan: Use direct recurrence for device hierarchy walks
      ACPI: Introduce acpi_set_device_status()
      ACPI / hotplug: Drop unfinished global notification handling routines
      ACPI / hotplug: Rework generic code to handle suprise removals
      ACPI / hotplug: Move container-specific code out of the core
      ACPI / hotplug: Make ACPI PCI root hotplug use common hotplug code
      ACPI / hotplug: Introduce common hotplug function acpi_device_hotplug()
      ACPI / hotplug: Do not fail bus and device checks for disabled hotplug
      ACPI / scan: Add acpi_device objects for all device nodes in the namespace
      ACPI / scan: Define non-empty device removal handler

commit 98feb7cc61c50fe0fa36eeb994d5db527ca9e103
Merge: 7e22e91102c6 f8a571b2a128
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Jan 12 23:44:09 2014 +0100

    Merge branch 'acpi-cleanup'
    
    * acpi-cleanup: (22 commits)
      ACPI / tables: Return proper error codes from acpi_table_parse() and fix comment.
      ACPI / tables: Check if id is NULL in acpi_table_parse()
      ACPI / proc: Include appropriate header file in proc.c
      ACPI / EC: Remove unused functions and add prototype declaration in internal.h
      ACPI / dock: Include appropriate header file in dock.c
      ACPI / PCI: Include appropriate header file in pci_link.c
      ACPI / PCI: Include appropriate header file in pci_slot.c
      ACPI / EC: Mark the function acpi_ec_add_debugfs() as static in ec_sys.c
      ACPI / NVS: Include appropriate header file in nvs.c
      ACPI / OSL: Mark the function acpi_table_checksum() as static
      ACPI / processor: initialize a variable to silence compiler warning
      ACPI / processor: use ACPI_COMPANION() to get ACPI device
      ACPI: correct minor typos
      ACPI / sleep: Drop redundant acpi_disabled check
      ACPI / dock: Drop redundant acpi_disabled check
      ACPI / table: Replace '1' with specific error return values
      ACPI: remove trailing whitespace
      ACPI / IBFT: Fix incorrect <acpi/acpi.h> inclusion in iSCSI boot firmware module
      ACPI / i915: Fix incorrect <acpi/acpi.h> inclusions via <linux/acpi_io.h>
      SFI / ACPI: Fix warnings reported during builds with W=1
      ...
    
    Conflicts:
            drivers/acpi/nvs.c
            drivers/hwmon/asus_atk0110.c

commit f084280cd34e375cd9736d14b023cfc7df3374bb
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Dec 29 23:37:15 2013 +0100

    PCI / ACPI: Install wakeup notify handlers for all PCI devs with ACPI
    
    It turns out that some BIOSes don't report wakeup GPEs through
    _PRW, but use them for signaling wakeup anyway, which causes GPE
    storms to occur on some systems after resume from system suspend.
    This issue has been uncovered by commit d2e5f0c16ad6 (ACPI / PCI:
    Rework the setup and cleanup of device wakeup) during the 3.9
    development cycle.
    
    Work around the problem by installing wakeup notify handlers for all
    PCI devices with ACPI support (i.e. having ACPI companions) regardless
    of whether or not the BIOS reports ACPI wakeup support for them.  The
    presence of the wakeup notify handlers alone is not harmful in any
    way if there are no events for them to handle (they are simply never
    executed then), but on some systems they are needed to take care of
    spurious events.
    
    Fixes: d2e5f0c16ad6 (ACPI / PCI: Rework the setup and cleanup of device wakeup)
    References: https://bugzilla.kernel.org/show_bug.cgi?id=63021
    Reported-and-tested-by: Agustin Barto <abarto@gmail.com>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 577074efbe62..f7ebdba14bde 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -330,29 +330,32 @@ static int acpi_pci_find_device(struct device *dev, acpi_handle *handle)
 static void pci_acpi_setup(struct device *dev)
 {
 	struct pci_dev *pci_dev = to_pci_dev(dev);
-	acpi_handle handle = ACPI_HANDLE(dev);
-	struct acpi_device *adev;
+	struct acpi_device *adev = ACPI_COMPANION(dev);
 
-	if (acpi_bus_get_device(handle, &adev) || !adev->wakeup.flags.valid)
+	if (!adev)
+		return;
+
+	pci_acpi_add_pm_notifier(adev, pci_dev);
+	if (!adev->wakeup.flags.valid)
 		return;
 
 	device_set_wakeup_capable(dev, true);
 	acpi_pci_sleep_wake(pci_dev, false);
-
-	pci_acpi_add_pm_notifier(adev, pci_dev);
 	if (adev->wakeup.flags.run_wake)
 		device_set_run_wake(dev, true);
 }
 
 static void pci_acpi_cleanup(struct device *dev)
 {
-	acpi_handle handle = ACPI_HANDLE(dev);
-	struct acpi_device *adev;
+	struct acpi_device *adev = ACPI_COMPANION(dev);
+
+	if (!adev)
+		return;
 
-	if (!acpi_bus_get_device(handle, &adev) && adev->wakeup.flags.valid) {
+	pci_acpi_remove_pm_notifier(adev);
+	if (adev->wakeup.flags.valid) {
 		device_set_wakeup_capable(dev, false);
 		device_set_run_wake(dev, false);
-		pci_acpi_remove_pm_notifier(adev);
 	}
 }
 

commit 40c368c1ef6379db08d2ebd36f5a45efb93cff73
Author: Yijing Wang <wangyijing@huawei.com>
Date:   Thu Dec 5 19:52:53 2013 +0800

    PCI: Use dev_is_pci() to identify PCI devices
    
    Use dev_is_pci() instead of checking bus type directly.
    
    Signed-off-by: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 577074efbe62..e0431f1af33b 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -358,7 +358,7 @@ static void pci_acpi_cleanup(struct device *dev)
 
 static bool pci_acpi_bus_match(struct device *dev)
 {
-	return dev->bus == &pci_bus_type;
+	return dev_is_pci(dev);
 }
 
 static struct acpi_bus_type acpi_pci_bus = {

commit e3f02c5228c4b600abf6ca243301176f25553bd5
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Nov 29 16:27:34 2013 +0100

    ACPI / bind: Rework struct acpi_bus_type
    
    Replace the .find_device function pointer in struct acpi_bus_type
    with a new one, .find_companion, that is supposed to point to a
    function returning struct acpi_device pointer (instead of an int)
    and takes one argument (instead of two).  This way the role of
    this callback is more clear and the implementation of it can
    be more straightforward.
    
    Update all of the users of struct acpi_bus_type (PCI, PNP/ACPI and
    USB) to reflect the structure change.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Tested-by: Lan Tianyu <tianyu.lan@intel.com> # for USB/ACPI

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index adbf34003995..ce31eb0cdca7 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -303,10 +303,9 @@ void acpi_pci_remove_bus(struct pci_bus *bus)
 }
 
 /* ACPI bus type */
-static int acpi_pci_find_device(struct device *dev, acpi_handle *handle)
+static struct acpi_device *acpi_pci_find_companion(struct device *dev)
 {
 	struct pci_dev *pci_dev = to_pci_dev(dev);
-	struct acpi_device *adev;
 	bool check_children;
 	u64 addr;
 
@@ -319,13 +318,8 @@ static int acpi_pci_find_device(struct device *dev, acpi_handle *handle)
 			|| pci_dev->hdr_type == PCI_HEADER_TYPE_CARDBUS;
 	/* Please ref to ACPI spec for the syntax of _ADR */
 	addr = (PCI_SLOT(pci_dev->devfn) << 16) | PCI_FUNC(pci_dev->devfn);
-	adev = acpi_find_child_device(ACPI_COMPANION(dev->parent), addr,
+	return acpi_find_child_device(ACPI_COMPANION(dev->parent), addr,
 				      check_children);
-	if (adev) {
-		*handle = adev->handle;
-		return 0;
-	}
-	return -ENODEV;
 }
 
 static void pci_acpi_setup(struct device *dev)
@@ -365,7 +359,7 @@ static bool pci_acpi_bus_match(struct device *dev)
 static struct acpi_bus_type acpi_pci_bus = {
 	.name = "PCI",
 	.match = pci_acpi_bus_match,
-	.find_device = acpi_pci_find_device,
+	.find_companion = acpi_pci_find_companion,
 	.setup = pci_acpi_setup,
 	.cleanup = pci_acpi_cleanup,
 };

commit 5ce79d201358d36f13d13b01d8614bd8e646036c
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Nov 28 23:58:08 2013 +0100

    PCI / ACPI: Use acpi_find_child_device() for child devices lookup
    
    It is much more efficient to use acpi_find_child_device()
    for child devices lookup in acpi_pci_find_device() and pass
    ACPI_COMPANION(dev->parent) to it directly instead of obtaining
    ACPI_HANDLE() of ACPI_COMPANION(dev->parent) and passing it to
    acpi_find_child() which has to run acpi_bus_get_device() to
    obtain ACPI_COMPANION(dev->parent) from that again.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Aaron Lu <aaron.lu@intel.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 43e317991326..adbf34003995 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -306,7 +306,8 @@ void acpi_pci_remove_bus(struct pci_bus *bus)
 static int acpi_pci_find_device(struct device *dev, acpi_handle *handle)
 {
 	struct pci_dev *pci_dev = to_pci_dev(dev);
-	bool is_bridge;
+	struct acpi_device *adev;
+	bool check_children;
 	u64 addr;
 
 	/*
@@ -314,14 +315,17 @@ static int acpi_pci_find_device(struct device *dev, acpi_handle *handle)
 	 * is set only after acpi_pci_find_device() has been called for the
 	 * given device.
 	 */
-	is_bridge = pci_dev->hdr_type == PCI_HEADER_TYPE_BRIDGE
+	check_children = pci_dev->hdr_type == PCI_HEADER_TYPE_BRIDGE
 			|| pci_dev->hdr_type == PCI_HEADER_TYPE_CARDBUS;
 	/* Please ref to ACPI spec for the syntax of _ADR */
 	addr = (PCI_SLOT(pci_dev->devfn) << 16) | PCI_FUNC(pci_dev->devfn);
-	*handle = acpi_find_child(ACPI_HANDLE(dev->parent), addr, is_bridge);
-	if (!*handle)
-		return -ENODEV;
-	return 0;
+	adev = acpi_find_child_device(ACPI_COMPANION(dev->parent), addr,
+				      check_children);
+	if (adev) {
+		*handle = adev->handle;
+		return 0;
+	}
+	return -ENODEV;
 }
 
 static void pci_acpi_setup(struct device *dev)

commit 8b48463f89429af408ff695244dc627e1acff4f7
Author: Lv Zheng <lv.zheng@intel.com>
Date:   Tue Dec 3 08:49:16 2013 +0800

    ACPI: Clean up inclusions of ACPI header files
    
    Replace direct inclusions of <acpi/acpi.h>, <acpi/acpi_bus.h> and
    <acpi/acpi_drivers.h>, which are incorrect, with <linux/acpi.h>
    inclusions and remove some inclusions of those files that aren't
    necessary.
    
    First of all, <acpi/acpi.h>, <acpi/acpi_bus.h> and <acpi/acpi_drivers.h>
    should not be included directly from any files that are built for
    CONFIG_ACPI unset, because that generally leads to build warnings about
    undefined symbols in !CONFIG_ACPI builds.  For CONFIG_ACPI set,
    <linux/acpi.h> includes those files and for CONFIG_ACPI unset it
    provides stub ACPI symbols to be used in that case.
    
    Second, there are ordering dependencies between those files that always
    have to be met.  Namely, it is required that <acpi/acpi_bus.h> be included
    prior to <acpi/acpi_drivers.h> so that the acpi_pci_root declarations the
    latter depends on are always there.  And <acpi/acpi.h> which provides
    basic ACPICA type declarations should always be included prior to any other
    ACPI headers in CONFIG_ACPI builds.  That also is taken care of including
    <linux/acpi.h> as appropriate.
    
    Signed-off-by: Lv Zheng <lv.zheng@intel.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Matthew Garrett <mjg59@srcf.ucam.org>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com> (drivers/pci stuff)
    Acked-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com> (Xen stuff)
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 577074efbe62..43e317991326 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -12,9 +12,6 @@
 #include <linux/pci.h>
 #include <linux/module.h>
 #include <linux/pci-aspm.h>
-#include <acpi/acpi.h>
-#include <acpi/acpi_bus.h>
-
 #include <linux/pci-acpi.h>
 #include <linux/pm_runtime.h>
 #include <linux/pm_qos.h>

commit e3414786ffb40a1fd524624369d350ed70a90a08
Merge: b0e3636f656c e7cc5cf74544
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Nov 22 10:53:47 2013 -0800

    Merge tag 'pci-v3.13-fixes-1' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI updates from Bjorn Helgaas:
     "Miscellaneous
       - Remove duplicate disable from pcie_portdrv_remove() (Yinghai Lu)
       - Fix whitespace, capitalization, and spelling errors (Bjorn Helgaas)"
    
    * tag 'pci-v3.13-fixes-1' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci:
      PCI: Remove duplicate pci_disable_device() from pcie_portdrv_remove()
      PCI: Fix whitespace, capitalization, and spelling errors

commit 3a83f992490f8235661b768e53bd5f14915420ac
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Nov 14 23:17:21 2013 +0100

    ACPI: Eliminate the DEVICE_ACPI_HANDLE() macro
    
    Since DEVICE_ACPI_HANDLE() is now literally identical to
    ACPI_HANDLE(), replace it with the latter everywhere and drop its
    definition from include/acpi.h.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index dfd1f59de729..f166126e28d1 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -173,14 +173,14 @@ static pci_power_t acpi_pci_choose_state(struct pci_dev *pdev)
 
 static bool acpi_pci_power_manageable(struct pci_dev *dev)
 {
-	acpi_handle handle = DEVICE_ACPI_HANDLE(&dev->dev);
+	acpi_handle handle = ACPI_HANDLE(&dev->dev);
 
 	return handle ? acpi_bus_power_manageable(handle) : false;
 }
 
 static int acpi_pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 {
-	acpi_handle handle = DEVICE_ACPI_HANDLE(&dev->dev);
+	acpi_handle handle = ACPI_HANDLE(&dev->dev);
 	static const u8 state_conv[] = {
 		[PCI_D0] = ACPI_STATE_D0,
 		[PCI_D1] = ACPI_STATE_D1,
@@ -217,7 +217,7 @@ static int acpi_pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 
 static bool acpi_pci_can_wakeup(struct pci_dev *dev)
 {
-	acpi_handle handle = DEVICE_ACPI_HANDLE(&dev->dev);
+	acpi_handle handle = ACPI_HANDLE(&dev->dev);
 
 	return handle ? acpi_bus_can_wakeup(handle) : false;
 }

commit f7625980f5820edd1a73536e1a03bcbc1f889fec
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Nov 14 11:28:18 2013 -0700

    PCI: Fix whitespace, capitalization, and spelling errors
    
    Fix whitespace, capitalization, and spelling errors.  No functional change.
    I know "busses" is not an error, but "buses" was more common, so I used it
    consistently.
    
    Signed-off-by: Marta Rybczynska <rybczynska@gmail.com> (pci_reset_bridge_secondary_bus())
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index dfd1f59de729..92a49c2b1fda 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -141,7 +141,7 @@ phys_addr_t acpi_pci_root_get_mcfg_addr(acpi_handle handle)
  * if (_PRW at S-state x)
  *	choose from highest power _SxD to lowest power _SxW
  * else // no _PRW at S-state x
- * 	choose highest power _SxD or any lower power
+ *	choose highest power _SxD or any lower power
  */
 
 static pci_power_t acpi_pci_choose_state(struct pci_dev *pdev)

commit be07c00e1639e6aa098d8ac5ea4d5ac58c3dbc50
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Tue Sep 3 08:32:02 2013 +0800

    pci-acpi: convert acpi_get_handle() to acpi_has_method()
    
    acpi_has_method() is a new ACPI API introduced to check
    the existence of an ACPI control method.
    
    It can be used to replace acpi_get_handle() in the case that
    1. the calling function doesn't need the ACPI handle of the control method.
    and
    2. the calling function doesn't care the reason why the method is unavailable.
    
    Convert acpi_get_handle() to acpi_has_method()
    in drivers/pci/pci-acpi.c in this patch.
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    CC: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index b0299e6d9a3f..dfd1f59de729 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -181,7 +181,6 @@ static bool acpi_pci_power_manageable(struct pci_dev *dev)
 static int acpi_pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 {
 	acpi_handle handle = DEVICE_ACPI_HANDLE(&dev->dev);
-	acpi_handle tmp;
 	static const u8 state_conv[] = {
 		[PCI_D0] = ACPI_STATE_D0,
 		[PCI_D1] = ACPI_STATE_D1,
@@ -192,7 +191,7 @@ static int acpi_pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 	int error = -EINVAL;
 
 	/* If the ACPI device has _EJ0, ignore the device */
-	if (!handle || ACPI_SUCCESS(acpi_get_handle(handle, "_EJ0", &tmp)))
+	if (!handle || acpi_has_method(handle, "_EJ0"))
 		return -ENODEV;
 
 	switch (state) {

commit 834145156bedadfb50121f0bc5e9d9f9f942bcca
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Sep 14 03:38:20 2013 +0200

    PCI / ACPI / PM: Clear pme_poll for devices in D3cold on wakeup
    
    Commit 448bd85 (PCI/PM: add PCIe runtime D3cold support) added a
    piece of code to pci_acpi_wake_dev() causing that function to behave
    in a special way for devices in D3cold (so that their configuration
    registers are not accessed before those devices are resumed).
    However, it didn't take the clearing of the pme_poll flag into
    account.  That has to be done for all devices, even if they are in
    D3cold, or pci_pme_list_scan() will not know that wakeup has been
    signaled for the device and will poll its PME Status bit
    unnecessarily.
    
    Fix the problem by moving the clearing of the pme_poll flag in
    pci_acpi_wake_dev() before the code introduced by commit 448bd85.
    
    Reported-and-tested-by: David E. Box <david.e.box@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: 3.6+ <stable@vger.kernel.org> # 3.6+

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 7c29ee4ed0ae..b0299e6d9a3f 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -47,6 +47,9 @@ static void pci_acpi_wake_dev(acpi_handle handle, u32 event, void *context)
 	if (event != ACPI_NOTIFY_DEVICE_WAKE || !pci_dev)
 		return;
 
+	if (pci_dev->pme_poll)
+		pci_dev->pme_poll = false;
+
 	if (pci_dev->current_state == PCI_D3cold) {
 		pci_wakeup_event(pci_dev);
 		pm_runtime_resume(&pci_dev->dev);
@@ -57,9 +60,6 @@ static void pci_acpi_wake_dev(acpi_handle handle, u32 event, void *context)
 	if (pci_dev->pme_support)
 		pci_check_pme_status(pci_dev);
 
-	if (pci_dev->pme_poll)
-		pci_dev->pme_poll = false;
-
 	pci_wakeup_event(pci_dev);
 	pm_runtime_resume(&pci_dev->dev);
 

commit abe5430e9d5314190ca571b3bfc0c42000634378
Merge: c92f56cbdfc0 ad07277e82de
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Aug 27 01:26:37 2013 +0200

    Merge branch 'acpi-pci-hotplug'
    
    * acpi-pci-hotplug: (34 commits)
      ACPI / PM: Hold acpi_scan_lock over system PM transitions
      ACPI / hotplug / PCI: Fix NULL pointer dereference in cleanup_bridge()
      PCI / ACPI: Use dev_dbg() instead of dev_info() in acpi_pci_set_power_state()
      ACPI / hotplug / PCI: Get rid of check_sub_bridges()
      ACPI / hotplug / PCI: Clean up bridge_mutex usage
      ACPI / hotplug / PCI: Redefine enable_device() and disable_device()
      ACPI / hotplug / PCI: Sanitize acpiphp_get_(latch)|(adapter)_status()
      ACPI / hotplug / PCI: Get rid of unused constants in acpiphp.h
      ACPI / hotplug / PCI: Check for new devices on enabled slots
      ACPI / hotplug / PCI: Allow slots without new devices to be rescanned
      ACPI / hotplug / PCI: Do not check SLOT_ENABLED in enable_device()
      ACPI / hotplug / PCI: Do not exectute _PS0 and _PS3 directly
      ACPI / hotplug / PCI: Do not queue up event handling work items in vain
      ACPI / hotplug / PCI: Consolidate slot disabling and ejecting
      ACPI / hotplug / PCI: Drop redundant checks from check_hotplug_bridge()
      ACPI / hotplug / PCI: Rework namespace scanning and trimming routines
      ACPI / hotplug / PCI: Store parent in functions and bus in slots
      ACPI / hotplug / PCI: Drop handle field from struct acpiphp_bridge
      ACPI / hotplug / PCI: Drop handle field from struct acpiphp_func
      ACPI / hotplug / PCI: Embed function struct into struct acpiphp_context
      ...

commit 60f75b8e97daf4a39790a20d962cb861b9220af5
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Aug 7 22:55:00 2013 +0200

    ACPI: Try harder to resolve _ADR collisions for bridges
    
    In theory, under a given ACPI namespace node there should be only
    one child device object with _ADR whose value matches a given bus
    address exactly.  In practice, however, there are systems in which
    multiple child device objects under a given parent have _ADR matching
    exactly the same address.  In those cases we use _STA to determine
    which of the multiple matching devices is enabled, since some systems
    are known to indicate which ACPI device object to associate with the
    given physical (usually PCI) device this way.
    
    Unfortunately, as it turns out, there are systems in which many
    device objects under the same parent have _ADR matching exactly the
    same bus address and none of them has _STA, in which case they all
    should be regarded as enabled according to the spec.  Still, if
    those device objects are supposed to represent bridges (e.g. this
    is the case for device objects corresponding to PCIe ports), we can
    try harder and skip the ones that have no child device objects in the
    ACPI namespace.  With luck, we can avoid using device objects that we
    are not expected to use this way.
    
    Although this only works for bridges whose children also have ACPI
    namespace representation, it is sufficient to address graphics
    adapter detection issues on some systems, so rework the code finding
    a matching device ACPI handle for a given bus address to implement
    this idea.
    
    Introduce a new function, acpi_find_child(), taking three arguments:
    the ACPI handle of the device's parent, a bus address suitable for
    the device's bus type and a bool indicating if the device is a
    bridge and make it work as outlined above.  Reimplement the function
    currently used for this purpose, acpi_get_child(), as a call to
    acpi_find_child() with the last argument set to 'false' and make
    the PCI subsystem use acpi_find_child() with the bridge information
    passed as the last argument to it.  [Lan Tianyu notices that it is
    not sufficient to use pci_is_bridge() for that, because the device's
    subordinate pointer hasn't been set yet at this point, so use
    hdr_type instead.]
    
    This change fixes a regression introduced inadvertently by commit
    33f767d (ACPI: Rework acpi_get_child() to be more efficient) which
    overlooked the fact that for acpi_walk_namespace() "post-order" means
    "after all children have been visited" rather than "on the way back",
    so for device objects without children and for namespace walks of
    depth 1, as in the acpi_get_child() case, the "post-order" callbacks
    ordering is actually the same as the ordering of "pre-order" ones.
    Since that commit changed the namespace walk in acpi_get_child() to
    terminate after finding the first matching object instead of going
    through all of them and returning the last one, it effectively
    changed the result returned by that function in some rare cases and
    that led to problems (the switch from a "pre-order" to a "post-order"
    callback was supposed to prevent that from happening, but it was
    ineffective).
    
    As it turns out, the systems where the change made by commit
    33f767d actually matters are those where there are multiple ACPI
    device objects representing the same PCIe port (which effectively
    is a bridge).  Moreover, only one of them, and the one we are
    expected to use, has child device objects in the ACPI namespace,
    so the regression can be addressed as described above.
    
    References: https://bugzilla.kernel.org/show_bug.cgi?id=60561
    Reported-by: Peter Wu <lekensteyn@gmail.com>
    Tested-by: Vladimir Lalov <mail@vlalov.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: 3.9+ <stable@vger.kernel.org> # 3.9+

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index dbdc5f7e2b29..01e264fb50e0 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -317,13 +317,20 @@ void acpi_pci_remove_bus(struct pci_bus *bus)
 /* ACPI bus type */
 static int acpi_pci_find_device(struct device *dev, acpi_handle *handle)
 {
-	struct pci_dev * pci_dev;
-	u64	addr;
+	struct pci_dev *pci_dev = to_pci_dev(dev);
+	bool is_bridge;
+	u64 addr;
 
-	pci_dev = to_pci_dev(dev);
+	/*
+	 * pci_is_bridge() is not suitable here, because pci_dev->subordinate
+	 * is set only after acpi_pci_find_device() has been called for the
+	 * given device.
+	 */
+	is_bridge = pci_dev->hdr_type == PCI_HEADER_TYPE_BRIDGE
+			|| pci_dev->hdr_type == PCI_HEADER_TYPE_CARDBUS;
 	/* Please ref to ACPI spec for the syntax of _ADR */
 	addr = (PCI_SLOT(pci_dev->devfn) << 16) | PCI_FUNC(pci_dev->devfn);
-	*handle = acpi_get_child(DEVICE_ACPI_HANDLE(dev->parent), addr);
+	*handle = acpi_find_child(ACPI_HANDLE(dev->parent), addr, is_bridge);
 	if (!*handle)
 		return -ENODEV;
 	return 0;

commit d010e5769a5ab2ae8d2bcb36e77b98172c24d80c
Author: Lan Tianyu <tianyu.lan@intel.com>
Date:   Tue Jul 30 10:32:30 2013 +0800

    PCI / ACPI: Use dev_dbg() instead of dev_info() in acpi_pci_set_power_state()
    
    acpi_pci_set_power_state() uses dev_info() to print diagnostic
    messages regarding ACPI power state changes of devices, but that
    results in too much not really interesting output into the kernel
    log in some cases.
    
    For this reason, change it to use dev_dbg() instead and prevent
    kernel log from being spammed.
    
    [rjw: Changelog]
    References: https://bugzilla.kernel.org/show_bug.cgi?id=60636
    Suggested-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Lan Tianyu <tianyu.lan@intel.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index c78cc432edab..fb3522957f01 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -210,7 +210,7 @@ static int acpi_pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 	}
 
 	if (!error)
-		dev_info(&dev->dev, "power state changed by ACPI to %s\n",
+		dev_dbg(&dev->dev, "power state changed by ACPI to %s\n",
 			 acpi_power_state_string(state_conv[state]));
 
 	return error;

commit be1c9de98d8904c75a5ab8b2a0d97bea0f7c07cc
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Jul 13 23:27:23 2013 +0200

    ACPI / PCI: Make bus registration and unregistration symmetric
    
    Since acpi_pci_slot_enumerate() and acpiphp_enumerate_slots() can get
    the ACPI device handle they need from bus->bridge, it is not
    necessary to pass that handle to them as an argument.
    
    Drop the second argument of acpi_pci_slot_enumerate() and
    acpiphp_enumerate_slots(), rework them to obtain the ACPI handle
    from bus->bridge and make acpi_pci_add_bus() and
    acpi_pci_remove_bus() entirely symmetrical.
    
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index dbdc5f7e2b29..c78cc432edab 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -290,24 +290,16 @@ static struct pci_platform_pm_ops acpi_pci_platform_pm = {
 
 void acpi_pci_add_bus(struct pci_bus *bus)
 {
-	acpi_handle handle = NULL;
-
-	if (bus->bridge)
-		handle = ACPI_HANDLE(bus->bridge);
-	if (acpi_pci_disabled || handle == NULL)
+	if (acpi_pci_disabled || !bus->bridge)
 		return;
 
-	acpi_pci_slot_enumerate(bus, handle);
-	acpiphp_enumerate_slots(bus, handle);
+	acpi_pci_slot_enumerate(bus);
+	acpiphp_enumerate_slots(bus);
 }
 
 void acpi_pci_remove_bus(struct pci_bus *bus)
 {
-	/*
-	 * bus->bridge->acpi_node.handle has already been reset to NULL
-	 * when acpi_pci_remove_bus() is called, so don't check ACPI handle.
-	 */
-	if (acpi_pci_disabled)
+	if (acpi_pci_disabled || !bus->bridge)
 		return;
 
 	acpiphp_remove_slots(bus);

commit fc6504b3a4dc9beae782a11e6f7c3c4a9f077fb8
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Jun 14 00:29:50 2013 +0200

    PCI / ACPI / PM: Use correct power state strings in messages
    
    Make acpi_pci_set_power_state() print the name of the ACPI device
    power state the device has been actually put into instead of printing
    the name of the requested PCI device power state, which need not be
    the same.
    
    [bhelgaas: use ACPI_STATE_D3_COLD (ACPI_STATE_D3 == ACPI_STATE_D3_COLD)]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 6c15d6a96935..dbdc5f7e2b29 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -186,8 +186,8 @@ static int acpi_pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 		[PCI_D0] = ACPI_STATE_D0,
 		[PCI_D1] = ACPI_STATE_D1,
 		[PCI_D2] = ACPI_STATE_D2,
-		[PCI_D3hot] = ACPI_STATE_D3,
-		[PCI_D3cold] = ACPI_STATE_D3
+		[PCI_D3hot] = ACPI_STATE_D3_COLD,
+		[PCI_D3cold] = ACPI_STATE_D3_COLD,
 	};
 	int error = -EINVAL;
 
@@ -211,7 +211,7 @@ static int acpi_pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 
 	if (!error)
 		dev_info(&dev->dev, "power state changed by ACPI to %s\n",
-			 pci_power_name(state));
+			 acpi_power_state_string(state_conv[state]));
 
 	return error;
 }

commit e7d4515209db5246245eb5667a94ad86ba9a12cc
Author: Yijing Wang <wangyijing@huawei.com>
Date:   Tue May 28 16:03:46 2013 +0800

    PCI: Replace printks with appropriate pr_*()
    
    Replace deprecated printk(KERN_ERR...) with pr_err() in pci-acpi.c
    
    Signed-off-by: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index e4b1fb2c0f5d..6c15d6a96935 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -376,12 +376,12 @@ static int __init acpi_pci_init(void)
 	int ret;
 
 	if (acpi_gbl_FADT.boot_flags & ACPI_FADT_NO_MSI) {
-		printk(KERN_INFO"ACPI FADT declares the system doesn't support MSI, so disable it\n");
+		pr_info("ACPI FADT declares the system doesn't support MSI, so disable it\n");
 		pci_no_msi();
 	}
 
 	if (acpi_gbl_FADT.boot_flags & ACPI_FADT_NO_ASPM) {
-		printk(KERN_INFO"ACPI FADT declares the system doesn't support PCIe ASPM, so disable it\n");
+		pr_info("ACPI FADT declares the system doesn't support PCIe ASPM, so disable it\n");
 		pcie_no_aspm();
 	}
 

commit 96a3e8af5a54c324535472ca946215d5bafe6539
Merge: a87451052fb9 d4f09c5d7fba
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Apr 29 09:30:25 2013 -0700

    Merge tag 'pci-v3.10-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI updates from Bjorn Helgaas:
     "PCI changes for the v3.10 merge window:
    
      PCI device hotplug
       - Remove ACPI PCI subdrivers (Jiang Liu, Myron Stowe)
       - Make acpiphp builtin only, not modular (Jiang Liu)
       - Add acpiphp mutual exclusion (Jiang Liu)
    
      Power management
       - Skip "PME enabled/disabled" messages when not supported (Rafael
         Wysocki)
       - Fix fallback to PCI_D0 (Rafael Wysocki)
    
      Miscellaneous
       - Factor quirk_io_region (Yinghai Lu)
       - Cache MSI capability offsets & cleanup (Gavin Shan, Bjorn Helgaas)
       - Clean up EISA resource initialization and logging (Bjorn Helgaas)
       - Fix prototype warnings (Andy Shevchenko, Bjorn Helgaas)
       - MIPS: Initialize of_node before scanning bus (Gabor Juhos)
       - Fix pcibios_get_phb_of_node() declaration "weak" annotation (Gabor
         Juhos)
       - Add MSI INTX_DISABLE quirks for AR8161/AR8162/etc (Xiong Huang)
       - Fix aer_inject return values (Prarit Bhargava)
       - Remove PME/ACPI dependency (Andrew Murray)
       - Use shared PCI_BUS_NUM() and PCI_DEVID() (Shuah Khan)"
    
    * tag 'pci-v3.10-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (63 commits)
      vfio-pci: Use cached MSI/MSI-X capabilities
      vfio-pci: Use PCI_MSIX_TABLE_BIR, not PCI_MSIX_FLAGS_BIRMASK
      PCI: Remove "extern" from function declarations
      PCI: Use PCI_MSIX_TABLE_BIR, not PCI_MSIX_FLAGS_BIRMASK
      PCI: Drop msi_mask_reg() and remove drivers/pci/msi.h
      PCI: Use msix_table_size() directly, drop multi_msix_capable()
      PCI: Drop msix_table_offset_reg() and msix_pba_offset_reg() macros
      PCI: Drop is_64bit_address() and is_mask_bit_support() macros
      PCI: Drop msi_data_reg() macro
      PCI: Drop msi_lower_address_reg() and msi_upper_address_reg() macros
      PCI: Drop msi_control_reg() macro and use PCI_MSI_FLAGS directly
      PCI: Use cached MSI/MSI-X offsets from dev, not from msi_desc
      PCI: Clean up MSI/MSI-X capability #defines
      PCI: Use cached MSI-X cap while enabling MSI-X
      PCI: Use cached MSI cap while enabling MSI interrupts
      PCI: Remove MSI/MSI-X cap check in pci_msi_check_device()
      PCI: Cache MSI/MSI-X capability offsets in struct pci_dev
      PCI: Use u8, not int, for PM capability offset
      [SCSI] megaraid_sas: Use correct #define for MSI-X capability
      PCI: Remove "extern" from function declarations
      ...

commit 3b63aaa70e1ccc4b66d60acc78da09700706a703
Author: Jiang Liu <liuj97@gmail.com>
Date:   Fri Apr 12 05:44:26 2013 +0000

    PCI: acpiphp: Do not use ACPI PCI subdriver mechanism
    
    Previously the acpiphp driver registered itself as an ACPI PCI subdriver,
    so its callbacks were invoked when creating/destroying PCI root
    buses to manage ACPI-based PCI hotplug slots.  But it doesn't handle
    P2P bridge hotplug events, so it will cause strange behaviour if there
    are hotplug slots associated with a hot-removed P2P bridge.
    
    This patch fixes this issue by:
    1) Directly hooking into PCI core to update hotplug slot devices when
       creating/destroying PCI buses through:
            pci_{add|remove}_bus() -> acpi_pci_{add|remove}_bus()
    2) Getting rid of unused ACPI PCI subdriver-related code
    
    It also cleans up unused code in the acpiphp driver.
    
    [bhelgaas: keep acpi_pci_add_bus() stub for CONFIG_ACPI=n]
    Signed-off-by: Jiang Liu <jiang.liu@huawei.com>
    Signed-off-by: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Yinghai Lu <yinghai@kernel.org>
    Cc: "Rafael J. Wysocki" <rafael.j.wysocki@intel.com>
    Cc: Toshi Kani <toshi.kani@hp.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 98e582a2c909..d927933dcf44 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -297,6 +297,7 @@ void acpi_pci_add_bus(struct pci_bus *bus)
 		return;
 
 	acpi_pci_slot_enumerate(bus, handle);
+	acpiphp_enumerate_slots(bus, handle);
 }
 
 void acpi_pci_remove_bus(struct pci_bus *bus)
@@ -308,6 +309,7 @@ void acpi_pci_remove_bus(struct pci_bus *bus)
 	if (acpi_pci_disabled)
 		return;
 
+	acpiphp_remove_slots(bus);
 	acpi_pci_slot_remove(bus);
 }
 
@@ -388,6 +390,7 @@ static int __init acpi_pci_init(void)
 
 	pci_set_platform_pm(&acpi_pci_platform_pm);
 	acpi_pci_slot_init();
+	acpiphp_init();
 
 	return 0;
 }

commit 5c0b04e3d913c91aee6e48e567e20a3f67849618
Author: Jiang Liu <liuj97@gmail.com>
Date:   Fri Apr 12 05:44:24 2013 +0000

    PCI/ACPI: Handle PCI slot devices when creating/destroying PCI buses
    
    Currently the pci_slot driver doesn't update PCI slot devices when PCI
    device hotplug event happens, which may cause memory leak and returning
    stale information to user.
    
    Now the pci_slot driver has been changed as built-in driver, so invoke
    PCI slot enumeration and destroy routines directly from the PCI core.
    And remove ACPI PCI sub-driver related code because it isn't needed
    any more.
    
    [bhelgas: removed "extern" from function declarations]
    Signed-off-by: Jiang Liu <jiang.liu@huawei.com>
    Signed-off-by: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Yinghai Lu <yinghai@kernel.org>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: Toshi Kani <toshi.kani@hp.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index b8b8437c703e..98e582a2c909 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -296,7 +296,7 @@ void acpi_pci_add_bus(struct pci_bus *bus)
 	if (acpi_pci_disabled || handle == NULL)
 		return;
 
-	/* TODO: add PCI slots and acpiphp hotplug slots */
+	acpi_pci_slot_enumerate(bus, handle);
 }
 
 void acpi_pci_remove_bus(struct pci_bus *bus)
@@ -308,7 +308,7 @@ void acpi_pci_remove_bus(struct pci_bus *bus)
 	if (acpi_pci_disabled)
 		return;
 
-	/* TODO: remove PCI slots and acpiphp hotplug slots */
+	acpi_pci_slot_remove(bus);
 }
 
 /* ACPI bus type */
@@ -385,7 +385,10 @@ static int __init acpi_pci_init(void)
 	ret = register_acpi_bus_type(&acpi_pci_bus);
 	if (ret)
 		return 0;
+
 	pci_set_platform_pm(&acpi_pci_platform_pm);
+	acpi_pci_slot_init();
+
 	return 0;
 }
 arch_initcall(acpi_pci_init);

commit 5090d4a6a1f150ec593ac5f2a755b5a3e878b21e
Author: Jiang Liu <liuj97@gmail.com>
Date:   Fri Apr 12 05:44:21 2013 +0000

    PCI/ACPI: Prepare stub functions to handle ACPI PCI (hotplug) slots
    
    Prepare two stub functions to handle ACPI PCI slots and ACPI PCI hotplug
    slots, which will be invoked by the PCI core when creating/destroying
    PCI buses.
    
    It will be used to get rid of ACPI PCI subdrivers for pci_slot and
    acpiphp, and eventually remove the ACPI PCI subdriver mechanism.
    
    And it will also be used to handle ACPI PCI (hotplug) slots in a unified
    way, both at boot time and for PCI hotplug operations.
    
    Signed-off-by: Jiang Liu <jiang.liu@huawei.com>
    Signed-off-by: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Yinghai Lu <yinghai@kernel.org>
    Cc: "Rafael J. Wysocki" <rafael.j.wysocki@intel.com>
    Cc: Toshi Kani <toshi.kani@hp.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Fenghua Yu <fenghua.yu@intel.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Myron Stowe <myron.stowe@redhat.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index dee5dddaa292..b8b8437c703e 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -287,6 +287,30 @@ static struct pci_platform_pm_ops acpi_pci_platform_pm = {
 	.run_wake = acpi_pci_run_wake,
 };
 
+void acpi_pci_add_bus(struct pci_bus *bus)
+{
+	acpi_handle handle = NULL;
+
+	if (bus->bridge)
+		handle = ACPI_HANDLE(bus->bridge);
+	if (acpi_pci_disabled || handle == NULL)
+		return;
+
+	/* TODO: add PCI slots and acpiphp hotplug slots */
+}
+
+void acpi_pci_remove_bus(struct pci_bus *bus)
+{
+	/*
+	 * bus->bridge->acpi_node.handle has already been reset to NULL
+	 * when acpi_pci_remove_bus() is called, so don't check ACPI handle.
+	 */
+	if (acpi_pci_disabled)
+		return;
+
+	/* TODO: remove PCI slots and acpiphp hotplug slots */
+}
+
 /* ACPI bus type */
 static int acpi_pci_find_device(struct device *dev, acpi_handle *handle)
 {

commit 24ad0ef9c8b946ed2abe681e4e44f4a1e643d882
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Mar 28 11:07:29 2013 +0000

    PCI/ACPI: Always resume devices on ACPI wakeup notifications
    
    It turns out that the _Lxx control methods provided by some BIOSes
    clear the PME Status bit of PCI devices they handle, which means that
    pci_acpi_wake_dev() cannot really use that bit to check whether or
    not the device has signalled wakeup.
    
    One symptom of the problem is, for example, that when an affected PCI
    USB controller is runtime-suspended, then plugging in a new USB device
    into one of the controller's ports will not wake up the controller,
    which should happen.
    
    For this reason, make pci_acpi_wake_dev() always attempt to resume
    the device it is called for regardless of the device's PME Status bit
    value (that bit still has to be cleared if set at this point,
    though).
    
    Reported-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Matthew Garrett <mjg59@srcf.ucam.org>
    CC: stable@vger.kernel.org      # v3.7+

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index dee5dddaa292..5147c210df52 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -53,14 +53,15 @@ static void pci_acpi_wake_dev(acpi_handle handle, u32 event, void *context)
 		return;
 	}
 
-	if (!pci_dev->pm_cap || !pci_dev->pme_support
-	     || pci_check_pme_status(pci_dev)) {
-		if (pci_dev->pme_poll)
-			pci_dev->pme_poll = false;
+	/* Clear PME Status if set. */
+	if (pci_dev->pme_support)
+		pci_check_pme_status(pci_dev);
 
-		pci_wakeup_event(pci_dev);
-		pm_runtime_resume(&pci_dev->dev);
-	}
+	if (pci_dev->pme_poll)
+		pci_dev->pme_poll = false;
+
+	pci_wakeup_event(pci_dev);
+	pm_runtime_resume(&pci_dev->dev);
 
 	if (pci_dev->subordinate)
 		pci_pme_wakeup_bus(pci_dev->subordinate);

commit 53540098b23c3884b4a0b4f220b9d977bc496af3
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Mar 3 22:35:20 2013 +0100

    ACPI / glue: Add .match() callback to struct acpi_bus_type
    
    USB uses the .find_bridge() callback from struct acpi_bus_type
    incorrectly, because as a result of the way it is used by USB every
    device in the system that doesn't have a bus type or parent is
    passed to usb_acpi_find_device() for inspection.
    
    What USB actually needs, though, is to call usb_acpi_find_device()
    for USB ports that don't have a bus type defined, but have
    usb_port_device_type as their device type, as well as for USB
    devices.
    
    To fix that replace the struct bus_type pointer in struct
    acpi_bus_type used for matching devices to specific subsystems
    with a .match() callback to be used for this purpose and update
    the users of struct acpi_bus_type, including USB, accordingly.
    Define the .match() callback routine for USB, usb_acpi_bus_match(),
    in such a way that it will cover both USB devices and USB ports
    and remove the now redundant .find_bridge() callback pointer from
    usb_acpi_bus.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Yinghai Lu <yinghai@kernel.org>
    Acked-by: Jeff Garzik <jgarzik@pobox.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 39c937f9b426..dee5dddaa292 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -331,8 +331,14 @@ static void pci_acpi_cleanup(struct device *dev)
 	}
 }
 
+static bool pci_acpi_bus_match(struct device *dev)
+{
+	return dev->bus == &pci_bus_type;
+}
+
 static struct acpi_bus_type acpi_pci_bus = {
-	.bus = &pci_bus_type,
+	.name = "PCI",
+	.match = pci_acpi_bus_match,
 	.find_device = acpi_pci_find_device,
 	.setup = pci_acpi_setup,
 	.cleanup = pci_acpi_cleanup,

commit 556f12f602ac0a18a82ca83e9f8e8547688fc633
Merge: fffddfd6c8e0 018ba0a6efad
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Feb 25 21:18:18 2013 -0800

    Merge tag 'pci-v3.9-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI changes from Bjorn Helgaas:
     "Host bridge hotplug
        - Major overhaul of ACPI host bridge add/start (Rafael Wysocki, Yinghai Lu)
        - Major overhaul of PCI/ACPI binding (Rafael Wysocki, Yinghai Lu)
        - Split out ACPI host bridge and ACPI PCI device hotplug (Yinghai Lu)
        - Stop caching _PRT and make independent of bus numbers (Yinghai Lu)
    
      PCI device hotplug
        - Clean up cpqphp dead code (Sasha Levin)
        - Disable ARI unless device and upstream bridge support it (Yijing Wang)
        - Initialize all hot-added devices (not functions 0-7) (Yijing Wang)
    
      Power management
        - Don't touch ASPM if disabled (Joe Lawrence)
        - Fix ASPM link state management (Myron Stowe)
    
      Miscellaneous
        - Fix PCI_EXP_FLAGS accessor (Alex Williamson)
        - Disable Bus Master in pci_device_shutdown (Konstantin Khlebnikov)
        - Document hotplug resource and MPS parameters (Yijing Wang)
        - Add accessor for PCIe capabilities (Myron Stowe)
        - Drop pciehp suspend/resume messages (Paul Bolle)
        - Make pci_slot built-in only (not a module) (Jiang Liu)
        - Remove unused PCI/ACPI bind ops (Jiang Liu)
        - Removed used pci_root_bus (Bjorn Helgaas)"
    
    * tag 'pci-v3.9-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (51 commits)
      PCI/ACPI: Don't cache _PRT, and don't associate them with bus numbers
      PCI: Fix PCI Express Capability accessors for PCI_EXP_FLAGS
      ACPI / PCI: Make pci_slot built-in only, not a module
      PCI/PM: Clear state_saved during suspend
      PCI: Use atomic_inc_return() rather than atomic_add_return()
      PCI: Catch attempts to disable already-disabled devices
      PCI: Disable Bus Master unconditionally in pci_device_shutdown()
      PCI: acpiphp: Remove dead code for PCI host bridge hotplug
      PCI: acpiphp: Create companion ACPI devices before creating PCI devices
      PCI: Remove unused "rc" in virtfn_add_bus()
      PCI: pciehp: Drop suspend/resume ENTRY messages
      PCI/ASPM: Don't touch ASPM if forcibly disabled
      PCI/ASPM: Deallocate upstream link state even if device is not PCIe
      PCI: Document MPS parameters pci=pcie_bus_safe, pci=pcie_bus_perf, etc
      PCI: Document hpiosize= and hpmemsize= resource reservation parameters
      PCI: Use PCI Express Capability accessor
      PCI: Introduce accessor to retrieve PCIe Capabilities Register
      PCI: Put pci_dev in device tree as early as possible
      PCI: Skip attaching driver in device_add()
      PCI: acpiphp: Keep driver loaded even if no slots found
      ...

commit 018ba0a6efada61b9bc17500101d81c3d35807c2
Merge: fd5e20bcb465 181380b702ee
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Feb 19 11:42:17 2013 -0700

    Merge branch 'pci/yinghai-root-bus-hotplug' into next
    
    * pci/yinghai-root-bus-hotplug:
      PCI/ACPI: Don't cache _PRT, and don't associate them with bus numbers

commit 181380b702eee1a9aca51354d7b87c7b08541fcf
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Sat Feb 16 11:58:34 2013 -0700

    PCI/ACPI: Don't cache _PRT, and don't associate them with bus numbers
    
    Previously, we cached _PRT (PCI routing table, ACPI 5.0 sec 6.2.12)
    contents and associated each _PRT entry with a PCI bus number.  The bus
    number association means dependencies on PCI device enumeration and bus
    number assignment, as well as on the PCI/ACPI binding process.
    
    After 4f535093cf ("PCI: Put pci_dev in device tree as early as possible"),
    these dependencies caused the IRQ issues reported by Peter:
    
        pci 0000:00:1e.0: PCI bridge to [bus 09] (subtractive decode)
        pci 0000:00:1e.0: can't derive routing for PCI INT A
        snd_ctxfi 0000:09:02.0: PCI INT A: no GSI - using ISA IRQ 5
        irq 18: nobody cared (try booting with the "irqpoll" option)
    
    This patch removes _PRT caching.  Instead, we evaluate _PRT as needed
    in the pci_enable_device() path.  This also removes the dependency on
    PCI bus numbers: we can simply look at the _PRT associated with each
    bridge as we walk upstream toward the root.
    
    [bhelgaas: changelog]
    Reference: https://bugzilla.kernel.org/show_bug.cgi?id=53561
    Reported-and-tested-by: Peter Hurley <peter@hurleysoftware.com>
    Suggested-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 42736e213f25..9ba9df5f6161 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -325,25 +325,6 @@ static void pci_acpi_setup(struct device *dev)
 	struct pci_dev *pci_dev = to_pci_dev(dev);
 	acpi_handle handle = ACPI_HANDLE(dev);
 	struct acpi_device *adev;
-	acpi_status status;
-	acpi_handle dummy;
-
-	/*
-	 * Evaluate and parse _PRT, if exists.  This code allows parsing of
-	 * _PRT objects within the scope of non-bridge devices.  Note that
-	 * _PRTs within the scope of a PCI bridge assume the bridge's
-	 * subordinate bus number.
-	 *
-	 * TBD: Can _PRTs exist within the scope of non-bridge PCI devices?
-	 */
-	status = acpi_get_handle(handle, METHOD_NAME__PRT, &dummy);
-	if (ACPI_SUCCESS(status)) {
-		unsigned char bus;
-
-		bus = pci_dev->subordinate ?
-			pci_dev->subordinate->number : pci_dev->bus->number;
-		acpi_pci_irq_add_prt(handle, pci_domain_nr(pci_dev->bus), bus);
-	}
 
 	acpi_power_resource_register_device(dev, handle);
 	if (acpi_bus_get_device(handle, &adev) || !adev->wakeup.flags.valid)
@@ -359,7 +340,6 @@ static void pci_acpi_setup(struct device *dev)
 
 static void pci_acpi_cleanup(struct device *dev)
 {
-	struct pci_dev *pci_dev = to_pci_dev(dev);
 	acpi_handle handle = ACPI_HANDLE(dev);
 	struct acpi_device *adev;
 
@@ -369,10 +349,6 @@ static void pci_acpi_cleanup(struct device *dev)
 		pci_acpi_remove_pm_notifier(adev);
 	}
 	acpi_power_resource_unregister_device(dev, handle);
-
-	if (pci_dev->subordinate)
-		acpi_pci_irq_del_prt(pci_domain_nr(pci_dev->bus),
-				     pci_dev->subordinate->number);
 }
 
 static struct acpi_bus_type acpi_pci_bus = {

commit bc9b6407bd6df3ab7189e5622816bbc11ae9d2d8
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jan 17 14:11:05 2013 +0100

    ACPI / PM: Rework the handling of devices depending on power resources
    
    Commit 0090def6 (ACPI: Add interface to register/unregister device
    to/from power resources) made it possible to indicate to the ACPI
    core that if the given device depends on any power resources, then
    it should be resumed as soon as all of the power resources required
    by it to transition to the D0 power state have been turned on.
    
    Unfortunately, however, this was a mistake, because all devices
    depending on power resources should be treated this way (i.e. they
    should be resumed when all power resources required by their D0
    state have been turned on) and for the majority of those devices
    the ACPI core can figure out by itself which (physical) devices
    depend on what power resources.
    
    For this reason, replace the code added by commit 0090def6 with a
    new, much more straightforward, mechanism that will be used
    internally by the ACPI core and remove all references to that code
    from kernel subsystems using ACPI.
    
    For the cases when there are (physical) devices that should be
    resumed whenever a not directly related ACPI device node goes into
    D0 as a result of power resources configuration changes, like in
    the SATA case, add two new routines, acpi_dev_pm_add_dependent()
    and acpi_dev_pm_remove_dependent(), allowing subsystems to manage
    such dependencies.  Convert the SATA subsystem to use the new
    functions accordingly.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 42736e213f25..e407c61559ca 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -345,7 +345,6 @@ static void pci_acpi_setup(struct device *dev)
 		acpi_pci_irq_add_prt(handle, pci_domain_nr(pci_dev->bus), bus);
 	}
 
-	acpi_power_resource_register_device(dev, handle);
 	if (acpi_bus_get_device(handle, &adev) || !adev->wakeup.flags.valid)
 		return;
 
@@ -368,7 +367,6 @@ static void pci_acpi_cleanup(struct device *dev)
 		device_set_run_wake(dev, false);
 		pci_acpi_remove_pm_notifier(adev);
 	}
-	acpi_power_resource_unregister_device(dev, handle);
 
 	if (pci_dev->subordinate)
 		acpi_pci_irq_del_prt(pci_domain_nr(pci_dev->bus),

commit 6c0cc950ae670403a362bdcbf3cde0df33744928
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Jan 9 22:33:37 2013 +0100

    ACPI / PCI: Set root bridge ACPI handle in advance
    
    The ACPI handles of PCI root bridges need to be known to
    acpi_bind_one(), so that it can create the appropriate
    "firmware_node" and "physical_node" files for them, but currently
    the way it gets to know those handles is not exactly straightforward
    (to put it lightly).
    
    This is how it works, roughly:
    
      1. acpi_bus_scan() finds the handle of a PCI root bridge,
         creates a struct acpi_device object for it and passes that
         object to acpi_pci_root_add().
    
      2. acpi_pci_root_add() creates a struct acpi_pci_root object,
         populates its "device" field with its argument's address
         (device->handle is the ACPI handle found in step 1).
    
      3. The struct acpi_pci_root object created in step 2 is passed
         to pci_acpi_scan_root() and used to get resources that are
         passed to pci_create_root_bus().
    
      4. pci_create_root_bus() creates a struct pci_host_bridge object
         and passes its "dev" member to device_register().
    
      5. platform_notify(), which for systems with ACPI is set to
         acpi_platform_notify(), is called.
    
    So far, so good.  Now it starts to be "interesting".
    
      6. acpi_find_bridge_device() is used to find the ACPI handle of
         the given device (which is the PCI root bridge) and executes
         acpi_pci_find_root_bridge(), among other things, for the
         given device object.
    
      7. acpi_pci_find_root_bridge() uses the name (sic!) of the given
         device object to extract the segment and bus numbers of the PCI
         root bridge and passes them to acpi_get_pci_rootbridge_handle().
    
      8. acpi_get_pci_rootbridge_handle() browses the list of ACPI PCI
         root bridges and finds the one that matches the given segment
         and bus numbers.  Its handle is then used to initialize the
         ACPI handle of the PCI root bridge's device object by
         acpi_bind_one().  However, this is *exactly* the ACPI handle we
         started with in step 1.
    
    Needless to say, this is quite embarassing, but it may be avoided
    thanks to commit f3fd0c8 (ACPI: Allow ACPI handles of devices to be
    initialized in advance), which makes it possible to initialize the
    ACPI handle of a device before passing it to device_register().
    
    Accordingly, add a new __weak routine, pcibios_root_bridge_prepare(),
    defaulting to an empty implementation that can be replaced by the
    interested architecutres (x86 and ia64 at the moment) with functions
    that will set the root bridge's ACPI handle before its dev member is
    passed to device_register().  Make both x86 and ia64 provide such
    implementations of pcibios_root_bridge_prepare() and remove
    acpi_pci_find_root_bridge() and acpi_get_pci_rootbridge_handle() that
    aren't necessary any more.
    
    Included is a fix for breakage on systems with non-ACPI PCI host
    bridges from Bjorn Helgaas.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 42736e213f25..1c2587c40299 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -302,24 +302,6 @@ static int acpi_pci_find_device(struct device *dev, acpi_handle *handle)
 	return 0;
 }
 
-static int acpi_pci_find_root_bridge(struct device *dev, acpi_handle *handle)
-{
-	int num;
-	unsigned int seg, bus;
-
-	/*
-	 * The string should be the same as root bridge's name
-	 * Please look at 'pci_scan_bus_parented'
-	 */
-	num = sscanf(dev_name(dev), "pci%04x:%02x", &seg, &bus);
-	if (num != 2)
-		return -ENODEV;
-	*handle = acpi_get_pci_rootbridge_handle(seg, bus);
-	if (!*handle)
-		return -ENODEV;
-	return 0;
-}
-
 static void pci_acpi_setup(struct device *dev)
 {
 	struct pci_dev *pci_dev = to_pci_dev(dev);
@@ -378,7 +360,6 @@ static void pci_acpi_cleanup(struct device *dev)
 static struct acpi_bus_type acpi_pci_bus = {
 	.bus = &pci_bus_type,
 	.find_device = acpi_pci_find_device,
-	.find_bridge = acpi_pci_find_root_bridge,
 	.setup = pci_acpi_setup,
 	.cleanup = pci_acpi_cleanup,
 };

commit 38a9a67a281eeebcd7cccf87f0e371f58ae625e3
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Dec 23 00:02:54 2012 +0100

    ACPI / PCI: Move the _PRT setup and cleanup code to pci-acpi.c
    
    Move the code related to _PRT setup and removal and to power
    resources from acpi_pci_bind() and acpi_pci_unbind() to the .setup()
    and .cleanup() callbacks in acpi_pci_bus and remove acpi_pci_bind()
    and acpi_pci_unbind() that have no purpose any more.  Accordingly,
    remove the code related to device .bind() and .unbind() operations
    from the ACPI PCI root bridge driver.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>
    Acked-by: Toshi Kani <toshi.kani@hp.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index b98106c110e7..42736e213f25 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -320,12 +320,33 @@ static int acpi_pci_find_root_bridge(struct device *dev, acpi_handle *handle)
 	return 0;
 }
 
-static void acpi_pci_wakeup_setup(struct device *dev)
+static void pci_acpi_setup(struct device *dev)
 {
-	struct acpi_device *adev = acpi_dev_pm_get_node(dev);
 	struct pci_dev *pci_dev = to_pci_dev(dev);
+	acpi_handle handle = ACPI_HANDLE(dev);
+	struct acpi_device *adev;
+	acpi_status status;
+	acpi_handle dummy;
 
-	if (!adev || !adev->wakeup.flags.valid)
+	/*
+	 * Evaluate and parse _PRT, if exists.  This code allows parsing of
+	 * _PRT objects within the scope of non-bridge devices.  Note that
+	 * _PRTs within the scope of a PCI bridge assume the bridge's
+	 * subordinate bus number.
+	 *
+	 * TBD: Can _PRTs exist within the scope of non-bridge PCI devices?
+	 */
+	status = acpi_get_handle(handle, METHOD_NAME__PRT, &dummy);
+	if (ACPI_SUCCESS(status)) {
+		unsigned char bus;
+
+		bus = pci_dev->subordinate ?
+			pci_dev->subordinate->number : pci_dev->bus->number;
+		acpi_pci_irq_add_prt(handle, pci_domain_nr(pci_dev->bus), bus);
+	}
+
+	acpi_power_resource_register_device(dev, handle);
+	if (acpi_bus_get_device(handle, &adev) || !adev->wakeup.flags.valid)
 		return;
 
 	device_set_wakeup_capable(dev, true);
@@ -336,23 +357,30 @@ static void acpi_pci_wakeup_setup(struct device *dev)
 		device_set_run_wake(dev, true);
 }
 
-static void acpi_pci_wakeup_cleanup(struct device *dev)
+static void pci_acpi_cleanup(struct device *dev)
 {
-	struct acpi_device *adev = acpi_dev_pm_get_node(dev);
+	struct pci_dev *pci_dev = to_pci_dev(dev);
+	acpi_handle handle = ACPI_HANDLE(dev);
+	struct acpi_device *adev;
 
-	if (adev && adev->wakeup.flags.valid) {
+	if (!acpi_bus_get_device(handle, &adev) && adev->wakeup.flags.valid) {
 		device_set_wakeup_capable(dev, false);
 		device_set_run_wake(dev, false);
 		pci_acpi_remove_pm_notifier(adev);
 	}
+	acpi_power_resource_unregister_device(dev, handle);
+
+	if (pci_dev->subordinate)
+		acpi_pci_irq_del_prt(pci_domain_nr(pci_dev->bus),
+				     pci_dev->subordinate->number);
 }
 
 static struct acpi_bus_type acpi_pci_bus = {
 	.bus = &pci_bus_type,
 	.find_device = acpi_pci_find_device,
 	.find_bridge = acpi_pci_find_root_bridge,
-	.setup = acpi_pci_wakeup_setup,
-	.cleanup = acpi_pci_wakeup_cleanup,
+	.setup = pci_acpi_setup,
+	.cleanup = pci_acpi_cleanup,
 };
 
 static int __init acpi_pci_init(void)

commit d2e5f0c16ad60a7208fd371233e63b73c990ece2
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Dec 23 00:02:44 2012 +0100

    ACPI / PCI: Rework the setup and cleanup of device wakeup
    
    Currently, the ACPI wakeup capability of PCI devices is set up
    in two different places, partially in acpi_pci_bind() where
    runtime wakeup is initialized and partially in
    platform_pci_wakeup_init(), where system wakeup is initialized.
    The cleanup is only done in acpi_pci_unbind() and it only covers
    runtime wakeup.
    
    Use the new .setup() and .cleanup() callbacks in struct acpi_bus_type
    to consolidate that code and do the setup and the cleanup each in one
    place.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>
    Acked-by: Toshi Kani <toshi.kani@hp.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 1af4008182fd..b98106c110e7 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -283,7 +283,6 @@ static struct pci_platform_pm_ops acpi_pci_platform_pm = {
 	.is_manageable = acpi_pci_power_manageable,
 	.set_state = acpi_pci_set_power_state,
 	.choose_state = acpi_pci_choose_state,
-	.can_wakeup = acpi_pci_can_wakeup,
 	.sleep_wake = acpi_pci_sleep_wake,
 	.run_wake = acpi_pci_run_wake,
 };
@@ -321,10 +320,39 @@ static int acpi_pci_find_root_bridge(struct device *dev, acpi_handle *handle)
 	return 0;
 }
 
+static void acpi_pci_wakeup_setup(struct device *dev)
+{
+	struct acpi_device *adev = acpi_dev_pm_get_node(dev);
+	struct pci_dev *pci_dev = to_pci_dev(dev);
+
+	if (!adev || !adev->wakeup.flags.valid)
+		return;
+
+	device_set_wakeup_capable(dev, true);
+	acpi_pci_sleep_wake(pci_dev, false);
+
+	pci_acpi_add_pm_notifier(adev, pci_dev);
+	if (adev->wakeup.flags.run_wake)
+		device_set_run_wake(dev, true);
+}
+
+static void acpi_pci_wakeup_cleanup(struct device *dev)
+{
+	struct acpi_device *adev = acpi_dev_pm_get_node(dev);
+
+	if (adev && adev->wakeup.flags.valid) {
+		device_set_wakeup_capable(dev, false);
+		device_set_run_wake(dev, false);
+		pci_acpi_remove_pm_notifier(adev);
+	}
+}
+
 static struct acpi_bus_type acpi_pci_bus = {
 	.bus = &pci_bus_type,
 	.find_device = acpi_pci_find_device,
 	.find_bridge = acpi_pci_find_root_bridge,
+	.setup = acpi_pci_wakeup_setup,
+	.cleanup = acpi_pci_wakeup_cleanup,
 };
 
 static int __init acpi_pci_init(void)

commit ec2cd81ccfc055155ef4ca673f207168f516d287
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Nov 2 01:40:09 2012 +0100

    ACPI / PM: Move routines for adding/removing device wakeup notifiers
    
    ACPI routines for adding and removing device wakeup notifiers are
    currently defined in a PCI-specific file, but they will be necessary
    for non-PCI devices too, so move them to a separate file under
    drivers/acpi and rename them to indicate their ACPI origins.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 63d6618a4804..1af4008182fd 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -20,8 +20,6 @@
 #include <linux/pm_qos.h>
 #include "pci.h"
 
-static DEFINE_MUTEX(pci_acpi_pm_notify_mtx);
-
 /**
  * pci_acpi_wake_bus - Wake-up notification handler for root buses.
  * @handle: ACPI handle of a device the notification is for.
@@ -68,67 +66,6 @@ static void pci_acpi_wake_dev(acpi_handle handle, u32 event, void *context)
 		pci_pme_wakeup_bus(pci_dev->subordinate);
 }
 
-/**
- * add_pm_notifier - Register PM notifier for given ACPI device.
- * @dev: ACPI device to add the notifier for.
- * @context: PCI device or bus to check for PME status if an event is signaled.
- *
- * NOTE: @dev need not be a run-wake or wake-up device to be a valid source of
- * PM wake-up events.  For example, wake-up events may be generated for bridges
- * if one of the devices below the bridge is signaling PME, even if the bridge
- * itself doesn't have a wake-up GPE associated with it.
- */
-static acpi_status add_pm_notifier(struct acpi_device *dev,
-				   acpi_notify_handler handler,
-				   void *context)
-{
-	acpi_status status = AE_ALREADY_EXISTS;
-
-	mutex_lock(&pci_acpi_pm_notify_mtx);
-
-	if (dev->wakeup.flags.notifier_present)
-		goto out;
-
-	status = acpi_install_notify_handler(dev->handle,
-					     ACPI_SYSTEM_NOTIFY,
-					     handler, context);
-	if (ACPI_FAILURE(status))
-		goto out;
-
-	dev->wakeup.flags.notifier_present = true;
-
- out:
-	mutex_unlock(&pci_acpi_pm_notify_mtx);
-	return status;
-}
-
-/**
- * remove_pm_notifier - Unregister PM notifier from given ACPI device.
- * @dev: ACPI device to remove the notifier from.
- */
-static acpi_status remove_pm_notifier(struct acpi_device *dev,
-				      acpi_notify_handler handler)
-{
-	acpi_status status = AE_BAD_PARAMETER;
-
-	mutex_lock(&pci_acpi_pm_notify_mtx);
-
-	if (!dev->wakeup.flags.notifier_present)
-		goto out;
-
-	status = acpi_remove_notify_handler(dev->handle,
-					    ACPI_SYSTEM_NOTIFY,
-					    handler);
-	if (ACPI_FAILURE(status))
-		goto out;
-
-	dev->wakeup.flags.notifier_present = false;
-
- out:
-	mutex_unlock(&pci_acpi_pm_notify_mtx);
-	return status;
-}
-
 /**
  * pci_acpi_add_bus_pm_notifier - Register PM notifier for given PCI bus.
  * @dev: ACPI device to add the notifier for.
@@ -137,7 +74,7 @@ static acpi_status remove_pm_notifier(struct acpi_device *dev,
 acpi_status pci_acpi_add_bus_pm_notifier(struct acpi_device *dev,
 					 struct pci_bus *pci_bus)
 {
-	return add_pm_notifier(dev, pci_acpi_wake_bus, pci_bus);
+	return acpi_add_pm_notifier(dev, pci_acpi_wake_bus, pci_bus);
 }
 
 /**
@@ -146,7 +83,7 @@ acpi_status pci_acpi_add_bus_pm_notifier(struct acpi_device *dev,
  */
 acpi_status pci_acpi_remove_bus_pm_notifier(struct acpi_device *dev)
 {
-	return remove_pm_notifier(dev, pci_acpi_wake_bus);
+	return acpi_remove_pm_notifier(dev, pci_acpi_wake_bus);
 }
 
 /**
@@ -157,7 +94,7 @@ acpi_status pci_acpi_remove_bus_pm_notifier(struct acpi_device *dev)
 acpi_status pci_acpi_add_pm_notifier(struct acpi_device *dev,
 				     struct pci_dev *pci_dev)
 {
-	return add_pm_notifier(dev, pci_acpi_wake_dev, pci_dev);
+	return acpi_add_pm_notifier(dev, pci_acpi_wake_dev, pci_dev);
 }
 
 /**
@@ -166,7 +103,7 @@ acpi_status pci_acpi_add_pm_notifier(struct acpi_device *dev,
  */
 acpi_status pci_acpi_remove_pm_notifier(struct acpi_device *dev)
 {
-	return remove_pm_notifier(dev, pci_acpi_wake_dev);
+	return acpi_remove_pm_notifier(dev, pci_acpi_wake_dev);
 }
 
 phys_addr_t acpi_pci_root_get_mcfg_addr(acpi_handle handle)

commit 8b713a88cc8b746f975958183fa641e9f1c8086d
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Oct 24 02:08:38 2012 +0200

    PM / ACPI: Take device PM QoS flags into account
    
    Make ACPI power management routines and PCI power management
    routines depending on ACPI take device PM QoS flags into account
    when deciding what power state to put the device into.
    
    In particular, after this change acpi_pm_device_sleep_state() will
    not return ACPI_STATE_D3_COLD as the deepest available low-power
    state if PM_QOS_FLAG_NO_POWER_OFF is requested for the device and it
    will not require remote wakeup to work for the device in the returned
    low-power state if there is at least one PM QoS flags request for the
    device, but PM_QOS_FLAG_REMOTE_WAKEUP is not requested for it.
    
    Accordingly, acpi_pci_set_power_state() will refuse to put the
    device into D3cold if PM_QOS_FLAG_NO_POWER_OFF is requested for it.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Jean Pihet <j-pihet@ti.com>
    Reviewed-by: Huang Ying <ying.huang@intel.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index c5792d622dc4..63d6618a4804 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -17,6 +17,7 @@
 
 #include <linux/pci-acpi.h>
 #include <linux/pm_runtime.h>
+#include <linux/pm_qos.h>
 #include "pci.h"
 
 static DEFINE_MUTEX(pci_acpi_pm_notify_mtx);
@@ -257,11 +258,16 @@ static int acpi_pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 		return -ENODEV;
 
 	switch (state) {
+	case PCI_D3cold:
+		if (dev_pm_qos_flags(&dev->dev, PM_QOS_FLAG_NO_POWER_OFF) ==
+				PM_QOS_FLAGS_ALL) {
+			error = -EBUSY;
+			break;
+		}
 	case PCI_D0:
 	case PCI_D1:
 	case PCI_D2:
 	case PCI_D3hot:
-	case PCI_D3cold:
 		error = acpi_bus_set_power(handle, state_conv[state]);
 	}
 

commit 3d0882c0d10d4b4785aeaf26043e764e3aaca825
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sat Aug 4 23:27:32 2012 +0200

    PCI / PM: Fix D3/D3cold/D4 messages printed by acpi_pci_set_power_state()
    
    If a PCI device is put into D3_cold by acpi_bus_set_power(),
    the message printed by acpi_pci_set_power_state() says that its
    power state has been changed to D4, which doesn't make sense.
    In turn, if the device is put into D3_hot, the message simply
    says "D3" without specifying the variant of the D3 state.
    
    Fix this by using the pci_power_name() macro for printing the state
    name instead of building it from the numeric value corresponding to
    the given state directly.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index fbf7b26c7c8a..c5792d622dc4 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -266,8 +266,8 @@ static int acpi_pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 	}
 
 	if (!error)
-		dev_printk(KERN_INFO, &dev->dev,
-				"power state changed by ACPI to D%d\n", state);
+		dev_info(&dev->dev, "power state changed by ACPI to %s\n",
+			 pci_power_name(state));
 
 	return error;
 }

commit 35e7f73c32ad44a931d918d04e317a7fb0c63e6e
Merge: e5028b52e46e 448bd857d48e
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Sat Jun 23 11:59:43 2012 -0600

    Merge branch 'topic/huang-d3cold-v7' into next
    
    * topic/huang-d3cold-v7:
      PCI/PM: add PCIe runtime D3cold support
      PCI: do not call pci_set_power_state with PCI_D3cold
      PCI/PM: add runtime PM support to PCIe port
      ACPI/PM: specify lowest allowed state for device sleep state

commit 448bd857d48e69b33ef323739dc6d8ca20d4cda7
Author: Huang Ying <ying.huang@intel.com>
Date:   Sat Jun 23 10:23:51 2012 +0800

    PCI/PM: add PCIe runtime D3cold support
    
    This patch adds runtime D3cold support and corresponding ACPI platform
    support.  This patch only enables runtime D3cold support; it does not
    enable D3cold support during system suspend/hibernate.
    
    D3cold is the deepest power saving state for a PCIe device, where its main
    power is removed.  While it is in D3cold, you can't access the device at
    all, not even its configuration space (which is still accessible in D3hot).
    Therefore the PCI PM registers can not be used to transition into/out of
    the D3cold state; that must be done by platform logic such as ACPI _PR3.
    
    To support wakeup from D3cold, a system may provide auxiliary power, which
    allows a device to request wakeup using a Beacon or the sideband WAKE#
    signal.  WAKE# is usually connected to platform logic such as ACPI GPE.
    This is quite different from other power saving states, where devices
    request wakeup via a PME message on the PCIe link.
    
    Some devices, such as those in plug-in slots, have no direct platform
    logic.  For example, there is usually no ACPI _PR3 for them.  D3cold
    support for these devices can be done via the PCIe Downstream Port leading
    to the device.  When the PCIe port is powered on/off, the device is powered
    on/off too.  Wakeup events from the device will be notified to the
    corresponding PCIe port.
    
    For more information about PCIe D3cold and corresponding ACPI support,
    please refer to:
    
    - PCI Express Base Specification Revision 2.0
    - Advanced Configuration and Power Interface Specification Revision 5.0
    
    [bhelgaas: changelog]
    Reviewed-by: Rafael J. Wysocki <rjw@sisk.pl>
    Originally-by: Zheng Yan <zheng.z.yan@intel.com>
    Signed-off-by: Huang Ying <ying.huang@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index a9efebc586b4..e1658afef873 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -48,6 +48,12 @@ static void pci_acpi_wake_dev(acpi_handle handle, u32 event, void *context)
 	if (event != ACPI_NOTIFY_DEVICE_WAKE || !pci_dev)
 		return;
 
+	if (pci_dev->current_state == PCI_D3cold) {
+		pci_wakeup_event(pci_dev);
+		pm_runtime_resume(&pci_dev->dev);
+		return;
+	}
+
 	if (!pci_dev->pm_cap || !pci_dev->pme_support
 	     || pci_check_pme_status(pci_dev)) {
 		if (pci_dev->pme_poll)
@@ -187,10 +193,13 @@ acpi_status pci_acpi_remove_pm_notifier(struct acpi_device *dev)
 
 static pci_power_t acpi_pci_choose_state(struct pci_dev *pdev)
 {
-	int acpi_state;
+	int acpi_state, d_max;
 
-	acpi_state = acpi_pm_device_sleep_state(&pdev->dev, NULL,
-						ACPI_STATE_D3);
+	if (pdev->no_d3cold)
+		d_max = ACPI_STATE_D3_HOT;
+	else
+		d_max = ACPI_STATE_D3_COLD;
+	acpi_state = acpi_pm_device_sleep_state(&pdev->dev, NULL, d_max);
 	if (acpi_state < 0)
 		return PCI_POWER_ERROR;
 
@@ -297,7 +306,13 @@ static void acpi_pci_propagate_run_wake(struct pci_bus *bus, bool enable)
 
 static int acpi_pci_run_wake(struct pci_dev *dev, bool enable)
 {
-	if (dev->pme_interrupt)
+	/*
+	 * Per PCI Express Base Specification Revision 2.0 section
+	 * 5.3.3.2 Link Wakeup, platform support is needed for D3cold
+	 * waking up to power on the main link even if there is PME
+	 * support for D3cold
+	 */
+	if (dev->pme_interrupt && !dev->runtime_d3cold)
 		return 0;
 
 	if (!acpi_pm_device_run_wake(&dev->dev, enable))

commit ee85f543710dd56ce526cb44e39191f32972e5ad
Author: Huang Ying <ying.huang@intel.com>
Date:   Sat Jun 23 10:23:48 2012 +0800

    ACPI/PM: specify lowest allowed state for device sleep state
    
    Lower device sleep state can save more power, but has more exit
    latency too.  Sometimes, to satisfy some power QoS and other
    requirement, we need to constrain the lowest device sleep state.
    
    In this patch, a parameter to specify lowest allowed state for
    acpi_pm_device_sleep_state is added.  So that the caller can enforce
    the constraint via the parameter.
    
    This is needed by PCIe D3cold support, where the lowest power state
    allowed may be D3_HOT instead of default D3_COLD.
    
    CC: Len Brown <lenb@kernel.org>
    CC: linux-acpi@vger.kernel.org
    Reviewed-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Huang Ying <ying.huang@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 61e2fefeedab..a9efebc586b4 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -189,7 +189,8 @@ static pci_power_t acpi_pci_choose_state(struct pci_dev *pdev)
 {
 	int acpi_state;
 
-	acpi_state = acpi_pm_device_sleep_state(&pdev->dev, NULL);
+	acpi_state = acpi_pm_device_sleep_state(&pdev->dev, NULL,
+						ACPI_STATE_D3);
 	if (acpi_state < 0)
 		return PCI_POWER_ERROR;
 

commit f4b57a3b4352f72e461e362cb25917e28bdba80f
Author: Jiang Liu <jiang.liu@huawei.com>
Date:   Fri Jun 22 14:55:16 2012 +0800

    PCI/ACPI: provide MMCONFIG address for PCI host bridges
    
    This patch provide MMCONFIG address for PCI host bridges, which will
    be used to support host bridge hotplug.  It gets MMCONFIG address
    by evaluating _CBA method if available.
    
    Reviewed-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Jiang Liu <liuj97@gmail.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 61e2fefeedab..87f4c504eafb 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -162,6 +162,20 @@ acpi_status pci_acpi_remove_pm_notifier(struct acpi_device *dev)
 	return remove_pm_notifier(dev, pci_acpi_wake_dev);
 }
 
+phys_addr_t acpi_pci_root_get_mcfg_addr(acpi_handle handle)
+{
+	acpi_status status = AE_NOT_EXIST;
+	unsigned long long mcfg_addr;
+
+	if (handle)
+		status = acpi_evaluate_integer(handle, METHOD_NAME__CBA,
+					       NULL, &mcfg_addr);
+	if (ACPI_FAILURE(status))
+		return 0;
+
+	return (phys_addr_t)mcfg_addr;
+}
+
 /*
  * _SxD returns the D-state with the highest power
  * (lowest D-state number) supported in the S-state "x".

commit 5c7dd710f691d1b44c39e32d2f05b4286ff51f99
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri May 18 00:39:35 2012 +0200

    ACPI / PCI / PM: Fix device PM regression related to D3hot/D3cold
    
    Commit 1cc0c998fdf2 ("ACPI: Fix D3hot v D3cold confusion") introduced a
    bug in __acpi_bus_set_power() and changed the behavior of
    acpi_pci_set_power_state() in such a way that it generally doesn't work
    as expected if PCI_D3hot is passed to it as the second argument.
    
    First off, if ACPI_STATE_D3 (equal to ACPI_STATE_D3_COLD) is passed to
    __acpi_bus_set_power() and the explicit_set flag is set for the D3cold
    state, the function will try to execute AML method called "_PS4", which
    doesn't exist.
    
    Fix this by adding a check to ensure that the name of the AML method
    to execute for transitions to ACPI_STATE_D3_COLD is correct in
    __acpi_bus_set_power().  Also make sure that the explicit_set flag
    for ACPI_STATE_D3_COLD will be set if _PS3 is present and modify
    acpi_power_transition() to avoid accessing power resources for
    ACPI_STATE_D3_COLD, because they don't exist.
    
    Second, if PCI_D3hot is passed to acpi_pci_set_power_state() as the
    target state, the function will request a transition to
    ACPI_STATE_D3_HOT instead of ACPI_STATE_D3.  However,
    ACPI_STATE_D3_HOT is now only marked as supported if the _PR3 AML
    method is defined for the given device, which is rare.  This causes
    problems to happen on systems where devices were successfully put
    into ACPI D3 by pci_set_power_state(PCI_D3hot) which doesn't work
    now.  In particular, some unused graphics adapters are not turned
    off as a result.
    
    To fix this issue restore the old behavior of
    acpi_pci_set_power_state(), which is to request a transition to
    ACPI_STATE_D3 (equal to ACPI_STATE_D3_COLD) if either PCI_D3hot or
    PCI_D3cold is passed to it as the argument.
    
    This approach is not ideal, because generally power should not
    be removed from devices if PCI_D3hot is the target power state,
    but since this behavior is relied on, we have no choice but to
    restore it at the moment and spend more time on designing a
    better solution in the future.
    
    References: https://bugzilla.kernel.org/show_bug.cgi?id=43228
    Reported-by: rocko <rockorequin@hotmail.com>
    Reported-by: Cristian Rodríguez <crrodriguez@opensuse.org>
    Reported-and-tested-by: Peter <lekensteyn@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 1929c0c63b75..61e2fefeedab 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -223,7 +223,7 @@ static int acpi_pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 		[PCI_D0] = ACPI_STATE_D0,
 		[PCI_D1] = ACPI_STATE_D1,
 		[PCI_D2] = ACPI_STATE_D2,
-		[PCI_D3hot] = ACPI_STATE_D3_HOT,
+		[PCI_D3hot] = ACPI_STATE_D3,
 		[PCI_D3cold] = ACPI_STATE_D3
 	};
 	int error = -EINVAL;

commit 1cc0c998fdf2cb665d625fb565a0d6db5c81c639
Author: Lin Ming <ming.m.lin@intel.com>
Date:   Mon Apr 23 09:03:49 2012 +0800

    ACPI: Fix D3hot v D3cold confusion
    
    Before this patch, ACPI_STATE_D3 incorrectly referenced D3hot
    in some places, but D3cold in other places.
    
    After this patch, ACPI_STATE_D3 always means ACPI_STATE_D3_COLD;
    and all references to D3hot use ACPI_STATE_D3_HOT.
    
    ACPI's _PR3 method is used to enter both D3hot and D3cold states.
    What distinguishes D3hot from D3cold is the presence _PR3
    (Power Resources for D3hot)  If these resources are all ON,
    then the state is D3hot.  If _PR3 is not present,
    or all _PR0 resources for the devices are OFF,
    then the state is D3cold.
    
    This patch applies after Linux-3.4-rc1.
    A future syntax cleanup may remove ACPI_STATE_D3
    to emphasize that it always means ACPI_STATE_D3_COLD.
    
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Acked-by: Rafael J. Wysocki <rjw@sisk.pl>
    Reviewed-by: Aaron Lu <aaron.lu@amd.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 0f150f271c2a..1929c0c63b75 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -200,7 +200,7 @@ static pci_power_t acpi_pci_choose_state(struct pci_dev *pdev)
 		return PCI_D1;
 	case ACPI_STATE_D2:
 		return PCI_D2;
-	case ACPI_STATE_D3:
+	case ACPI_STATE_D3_HOT:
 		return PCI_D3hot;
 	case ACPI_STATE_D3_COLD:
 		return PCI_D3cold;
@@ -223,7 +223,7 @@ static int acpi_pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 		[PCI_D0] = ACPI_STATE_D0,
 		[PCI_D1] = ACPI_STATE_D1,
 		[PCI_D2] = ACPI_STATE_D2,
-		[PCI_D3hot] = ACPI_STATE_D3,
+		[PCI_D3hot] = ACPI_STATE_D3_HOT,
 		[PCI_D3cold] = ACPI_STATE_D3
 	};
 	int error = -EINVAL;

commit b24e5098853653554baf6ec975b9e855f3d6e5c0
Author: Lin Ming <ming.m.lin@intel.com>
Date:   Tue Mar 27 15:43:25 2012 +0800

    ACPI, PCI: Move acpi_dev_run_wake() to ACPI core
    
    acpi_dev_run_wake() is a generic function which can be used by
    other subsystem too. Rename it to acpi_pm_device_run_wake, to be
    consistent with acpi_pm_device_sleep_wake.
    
    Then move it to ACPI core.
    
    Acked-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 060fd22a1103..0f150f271c2a 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -277,40 +277,6 @@ static int acpi_pci_sleep_wake(struct pci_dev *dev, bool enable)
 	return 0;
 }
 
-/**
- * acpi_dev_run_wake - Enable/disable wake-up for given device.
- * @phys_dev: Device to enable/disable the platform to wake-up the system for.
- * @enable: Whether enable or disable the wake-up functionality.
- *
- * Find the ACPI device object corresponding to @pci_dev and try to
- * enable/disable the GPE associated with it.
- */
-static int acpi_dev_run_wake(struct device *phys_dev, bool enable)
-{
-	struct acpi_device *dev;
-	acpi_handle handle;
-
-	if (!device_run_wake(phys_dev))
-		return -EINVAL;
-
-	handle = DEVICE_ACPI_HANDLE(phys_dev);
-	if (!handle || ACPI_FAILURE(acpi_bus_get_device(handle, &dev))) {
-		dev_dbg(phys_dev, "ACPI handle has no context in %s!\n",
-			__func__);
-		return -ENODEV;
-	}
-
-	if (enable) {
-		acpi_enable_wakeup_device_power(dev, ACPI_STATE_S0);
-		acpi_enable_gpe(dev->wakeup.gpe_device, dev->wakeup.gpe_number);
-	} else {
-		acpi_disable_gpe(dev->wakeup.gpe_device, dev->wakeup.gpe_number);
-		acpi_disable_wakeup_device_power(dev);
-	}
-
-	return 0;
-}
-
 static void acpi_pci_propagate_run_wake(struct pci_bus *bus, bool enable)
 {
 	while (bus->parent) {
@@ -318,14 +284,14 @@ static void acpi_pci_propagate_run_wake(struct pci_bus *bus, bool enable)
 
 		if (bridge->pme_interrupt)
 			return;
-		if (!acpi_dev_run_wake(&bridge->dev, enable))
+		if (!acpi_pm_device_run_wake(&bridge->dev, enable))
 			return;
 		bus = bus->parent;
 	}
 
 	/* We have reached the root bus. */
 	if (bus->bridge)
-		acpi_dev_run_wake(bus->bridge, enable);
+		acpi_pm_device_run_wake(bus->bridge, enable);
 }
 
 static int acpi_pci_run_wake(struct pci_dev *dev, bool enable)
@@ -333,7 +299,7 @@ static int acpi_pci_run_wake(struct pci_dev *dev, bool enable)
 	if (dev->pme_interrupt)
 		return 0;
 
-	if (!acpi_dev_run_wake(&dev->dev, enable))
+	if (!acpi_pm_device_run_wake(&dev->dev, enable))
 		return 0;
 
 	acpi_pci_propagate_run_wake(dev->bus, enable);

commit a424948dde8421089826e2f782d0efe9e565707e
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Nov 6 22:21:46 2011 +0100

    PCI/ACPI/PM: Avoid resuming devices that don't signal PME
    
    Modify pci_acpi_wake_dev() to avoid resuming PME-capable devices
    whose PME Status bits are not set, which may happen currently if
    several devices are associated with the same wakeup GPE and all
    of them are notified whenever at least one of them signals PME.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index c8e75851a314..060fd22a1103 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -45,16 +45,20 @@ static void pci_acpi_wake_dev(acpi_handle handle, u32 event, void *context)
 {
 	struct pci_dev *pci_dev = context;
 
-	if (event == ACPI_NOTIFY_DEVICE_WAKE && pci_dev) {
+	if (event != ACPI_NOTIFY_DEVICE_WAKE || !pci_dev)
+		return;
+
+	if (!pci_dev->pm_cap || !pci_dev->pme_support
+	     || pci_check_pme_status(pci_dev)) {
 		if (pci_dev->pme_poll)
 			pci_dev->pme_poll = false;
 
 		pci_wakeup_event(pci_dev);
-		pci_check_pme_status(pci_dev);
 		pm_runtime_resume(&pci_dev->dev);
-		if (pci_dev->subordinate)
-			pci_pme_wakeup_bus(pci_dev->subordinate);
 	}
+
+	if (pci_dev->subordinate)
+		pci_pme_wakeup_bus(pci_dev->subordinate);
 }
 
 /**

commit 3c076351c4027a56d5005a39a0b518a4ba393ce2
Author: Matthew Garrett <mjg@redhat.com>
Date:   Thu Nov 10 16:38:33 2011 -0500

    PCI: Rework ASPM disable code
    
    Right now we forcibly clear ASPM state on all devices if the BIOS indicates
    that the feature isn't supported. Based on the Microsoft presentation
    "PCI Express In Depth for Windows Vista and Beyond", I'm starting to think
    that this may be an error. The implication is that unless the platform
    grants full control via _OSC, Windows will not touch any PCIe features -
    including ASPM. In that case clearing ASPM state would be an error unless
    the platform has granted us that control.
    
    This patch reworks the ASPM disabling code such that the actual clearing
    of state is triggered by a successful handoff of PCIe control to the OS.
    The general ASPM code undergoes some changes in order to ensure that the
    ability to clear the bits isn't overridden by ASPM having already been
    disabled. Further, this theoretically now allows for situations where
    only a subset of PCIe roots hand over control, leaving the others in the
    BIOS state.
    
    It's difficult to know for sure that this is the right thing to do -
    there's zero public documentation on the interaction between all of these
    components. But enough vendors enable ASPM on platforms and then set this
    bit that it seems likely that they're expecting the OS to leave them alone.
    
    Measured to save around 5W on an idle Thinkpad X220.
    
    Signed-off-by: Matthew Garrett <mjg@redhat.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 4ecb6408b0d6..c8e75851a314 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -395,7 +395,6 @@ static int __init acpi_pci_init(void)
 
 	if (acpi_gbl_FADT.boot_flags & ACPI_FADT_NO_ASPM) {
 		printk(KERN_INFO"ACPI FADT declares the system doesn't support PCIe ASPM, so disable it\n");
-		pcie_clear_aspm();
 		pcie_no_aspm();
 	}
 

commit 78d090b0be3f072a3c95022771c35183af961aaa
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Sep 28 21:44:36 2011 +0200

    PCI / PM: Remove unnecessary error variable from acpi_dev_run_wake()
    
    The result returned by acpi_dev_run_wake() is always either -EINVAL
    or -ENODEV, while obviously it should return 0 on success.  The
    problem is that the leftover error variable, that's not really used
    in the function, is initialized with -ENODEV and then returned
    without modification.
    
    To fix this issue remove the error variable from acpi_dev_run_wake()
    and make the function return 0 on success as appropriate.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index cd3c4f1cdf1b..4ecb6408b0d6 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -285,7 +285,6 @@ static int acpi_dev_run_wake(struct device *phys_dev, bool enable)
 {
 	struct acpi_device *dev;
 	acpi_handle handle;
-	int error = -ENODEV;
 
 	if (!device_run_wake(phys_dev))
 		return -EINVAL;
@@ -305,7 +304,7 @@ static int acpi_dev_run_wake(struct device *phys_dev, bool enable)
 		acpi_disable_wakeup_device_power(dev);
 	}
 
-	return error;
+	return 0;
 }
 
 static void acpi_pci_propagate_run_wake(struct pci_bus *bus, bool enable)

commit 379021d5c0899fcf9410cae4ca7a59a5a94ca769
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Oct 3 23:16:33 2011 +0200

    PCI / PM: Extend PME polling to all PCI devices
    
    The land of PCI power management is a land of sorrow and ugliness,
    especially in the area of signaling events by devices.  There are
    devices that set their PME Status bits, but don't really bother
    to send a PME message or assert PME#.  There are hardware vendors
    who don't connect PME# lines to the system core logic (they know
    who they are).  There are PCI Express Root Ports that don't bother
    to trigger interrupts when they receive PME messages from the devices
    below.  There are ACPI BIOSes that forget to provide _PRW methods for
    devices capable of signaling wakeup.  Finally, there are BIOSes that
    do provide _PRW methods for such devices, but then don't bother to
    call Notify() for those devices from the corresponding _Lxx/_Exx
    GPE-handling methods.  In all of these cases the kernel doesn't have
    a chance to receive a proper notification that it should wake up a
    device, so devices stay in low-power states forever.  Worse yet, in
    some cases they continuously send PME Messages that are silently
    ignored, because the kernel simply doesn't know that it should clear
    the device's PME Status bit.
    
    This problem was first observed for "parallel" (non-Express) PCI
    devices on add-on cards and Matthew Garrett addressed it by adding
    code that polls PME Status bits of such devices, if they are enabled
    to signal PME, to the kernel.  Recently, however, it has turned out
    that PCI Express devices are also affected by this issue and that it
    is not limited to add-on devices, so it seems necessary to extend
    the PME polling to all PCI devices, including PCI Express and planar
    ones.  Still, it would be wasteful to poll the PME Status bits of
    devices that are known to receive proper PME notifications, so make
    the kernel (1) poll the PME Status bits of all PCI and PCIe devices
    enabled to signal PME and (2) disable the PME Status polling for
    devices for which correct PME notifications are received.
    
    Tested-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index d36f41ea8cbf..cd3c4f1cdf1b 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -46,6 +46,9 @@ static void pci_acpi_wake_dev(acpi_handle handle, u32 event, void *context)
 	struct pci_dev *pci_dev = context;
 
 	if (event == ACPI_NOTIFY_DEVICE_WAKE && pci_dev) {
+		if (pci_dev->pme_poll)
+			pci_dev->pme_poll = false;
+
 		pci_wakeup_event(pci_dev);
 		pci_check_pme_status(pci_dev);
 		pm_runtime_resume(&pci_dev->dev);

commit 28c2103dad04dba29ba86e22dad5735db8f0e13c
Author: Lin Ming <ming.m.lin@intel.com>
Date:   Wed May 4 22:56:43 2011 +0800

    ACPI: Add D3 cold state
    
    _SxW returns an Integer containing the lowest D-state supported in state
    Sx. If OSPM has not indicated that it supports _PR3, then the value “3”
    corresponds to D3.  If it has indicated _PR3 support, the value “3”
    represents D3hot and the value “4” represents D3cold.
    
    Linux does set _OSC._PR3, so we should fix it to expect that _SxW can
    return 4.
    
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Acked-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 7c3b18e78cee..d36f41ea8cbf 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -195,6 +195,8 @@ static pci_power_t acpi_pci_choose_state(struct pci_dev *pdev)
 		return PCI_D2;
 	case ACPI_STATE_D3:
 		return PCI_D3hot;
+	case ACPI_STATE_D3_COLD:
+		return PCI_D3cold;
 	}
 	return PCI_POWER_ERROR;
 }

commit 5190726765b40774c069e187a958e10ccd970e65
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Feb 8 23:40:37 2011 +0100

    ACPI: Remove the wakeup.run_wake_count device field
    
    The wakeup.run_wake_count ACPI device field is only used by the PCI
    runtime PM code to "protect" devices from being prepared for
    generating wakeup signals more than once in a row.  However, it
    really doesn't provide any protection, because (1) all of the
    functions it is supposed to protect use their own reference counters
    effectively ensuring that the device will be set up for generating
    wakeup signals just once and (2) the PCI runtime PM code uses
    wakeup.run_wake_count in a racy way, since nothing prevents
    acpi_dev_run_wake() from being called concurrently from two different
    threads for the same device.
    
    Remove the wakeup.run_wake_count ACPI device field which is
    unnecessary, confusing and used in a wrong way.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 6fe0772e0e7d..7c3b18e78cee 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -293,19 +293,11 @@ static int acpi_dev_run_wake(struct device *phys_dev, bool enable)
 	}
 
 	if (enable) {
-		if (!dev->wakeup.run_wake_count++) {
-			acpi_enable_wakeup_device_power(dev, ACPI_STATE_S0);
-			acpi_enable_gpe(dev->wakeup.gpe_device,
-					dev->wakeup.gpe_number);
-		}
-	} else if (dev->wakeup.run_wake_count > 0) {
-		if (!--dev->wakeup.run_wake_count) {
-			acpi_disable_gpe(dev->wakeup.gpe_device,
-					 dev->wakeup.gpe_number);
-			acpi_disable_wakeup_device_power(dev);
-		}
+		acpi_enable_wakeup_device_power(dev, ACPI_STATE_S0);
+		acpi_enable_gpe(dev->wakeup.gpe_device, dev->wakeup.gpe_number);
 	} else {
-		error = -EALREADY;
+		acpi_disable_gpe(dev->wakeup.gpe_device, dev->wakeup.gpe_number);
+		acpi_disable_wakeup_device_power(dev);
 	}
 
 	return error;

commit 0f953bf6b4efa0daddb7c418130a9bd3ee97f7ed
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Dec 29 13:22:08 2010 +0100

    PCI/PM: Report wakeup events before resuming devices
    
    Make wakeup events be reported by the PCI subsystem before attempting to
    resume devices or queuing up runtime resume requests for them, because
    wakeup events should be reported as soon as they have been detected.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index d7ea699b8ddc..6fe0772e0e7d 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -46,9 +46,9 @@ static void pci_acpi_wake_dev(acpi_handle handle, u32 event, void *context)
 	struct pci_dev *pci_dev = context;
 
 	if (event == ACPI_NOTIFY_DEVICE_WAKE && pci_dev) {
+		pci_wakeup_event(pci_dev);
 		pci_check_pme_status(pci_dev);
 		pm_runtime_resume(&pci_dev->dev);
-		pci_wakeup_event(pci_dev);
 		if (pci_dev->subordinate)
 			pci_pme_wakeup_bus(pci_dev->subordinate);
 	}

commit 2f671e2dbff6eb5ef4e2600adbec550c13b8fe72
Author: Matthew Garrett <mjg@redhat.com>
Date:   Mon Dec 6 14:00:56 2010 -0500

    PCI: Disable ASPM if BIOS asks us to
    
    We currently refuse to touch the ASPM registers if the BIOS tells us that
    ASPM isn't supported. This can cause problems if the BIOS has (for any
    reason) enabled ASPM on some devices anyway. Change the code such that we
    explicitly clear ASPM if the FADT indicates that ASPM isn't supported,
    and make sure we tidy up appropriately on device removal in order to deal
    with the hotplug case. If ASPM is disabled because the BIOS doesn't hand
    over control then we won't touch the registers.
    
    Signed-off-by: Matthew Garrett <mjg@redhat.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 24e19c594e57..d7ea699b8ddc 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -399,6 +399,7 @@ static int __init acpi_pci_init(void)
 
 	if (acpi_gbl_FADT.boot_flags & ACPI_FADT_NO_ASPM) {
 		printk(KERN_INFO"ACPI FADT declares the system doesn't support PCIe ASPM, so disable it\n");
+		pcie_clear_aspm();
 		pcie_no_aspm();
 	}
 

commit 9e50ab91d025afc17ca14a1764be2e1d0c24245d
Merge: 3cc08fc35db7 a0d468718b90
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Aug 7 17:08:30 2010 -0700

    Merge branch 'acpica' of git://git.kernel.org/pub/scm/linux/kernel/git/lenb/linux-acpi-2.6
    
    * 'acpica' of git://git.kernel.org/pub/scm/linux/kernel/git/lenb/linux-acpi-2.6: (27 commits)
      ACPI / ACPICA: Simplify acpi_ev_initialize_gpe_block()
      ACPI / ACPICA: Fail acpi_gpe_wakeup() if ACPI_GPE_CAN_WAKE is unset
      ACPI / ACPICA: Do not execute _PRW methods during initialization
      ACPI: Fix bogus GPE test in acpi_bus_set_run_wake_flags()
      ACPICA: Update version to 20100702
      ACPICA: Fix for Alias references within Package objects
      ACPICA: Fix lint warning for 64-bit constant
      ACPICA: Remove obsolete GPE function
      ACPICA: Update debug output components
      ACPICA: Add support for WDDT - Watchdog Descriptor Table
      ACPICA: Drop acpi_set_gpe
      ACPICA: Use low-level GPE enable during GPE block initialization
      ACPI / EC: Do not use acpi_set_gpe
      ACPI / EC: Drop suspend and resume routines
      ACPICA: Remove wakeup GPE reference counting which is not used
      ACPICA: Introduce acpi_gpe_wakeup()
      ACPICA: Rename acpi_hw_gpe_register_bit
      ACPICA: Update version to 20100528
      ACPICA: Add signatures for undefined tables: ATKG, GSCI, IEIT
      ACPICA: Optimization: Reduce the number of namespace walks
      ...

commit c125e96f044427f38d106fab7bc5e4a5e6a18262
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Jul 5 22:43:53 2010 +0200

    PM: Make it possible to avoid races between wakeup and system sleep
    
    One of the arguments during the suspend blockers discussion was that
    the mainline kernel didn't contain any mechanisms making it possible
    to avoid races between wakeup and system suspend.
    
    Generally, there are two problems in that area.  First, if a wakeup
    event occurs exactly when /sys/power/state is being written to, it
    may be delivered to user space right before the freezer kicks in, so
    the user space consumer of the event may not be able to process it
    before the system is suspended.  Second, if a wakeup event occurs
    after user space has been frozen, it is not generally guaranteed that
    the ongoing transition of the system into a sleep state will be
    aborted.
    
    To address these issues introduce a new global sysfs attribute,
    /sys/power/wakeup_count, associated with a running counter of wakeup
    events and three helper functions, pm_stay_awake(), pm_relax(), and
    pm_wakeup_event(), that may be used by kernel subsystems to control
    the behavior of this attribute and to request the PM core to abort
    system transitions into a sleep state already in progress.
    
    The /sys/power/wakeup_count file may be read from or written to by
    user space.  Reads will always succeed (unless interrupted by a
    signal) and return the current value of the wakeup events counter.
    Writes, however, will only succeed if the written number is equal to
    the current value of the wakeup events counter.  If a write is
    successful, it will cause the kernel to save the current value of the
    wakeup events counter and to abort the subsequent system transition
    into a sleep state if any wakeup events are reported after the write
    has returned.
    
    [The assumption is that before writing to /sys/power/state user space
    will first read from /sys/power/wakeup_count.  Next, user space
    consumers of wakeup events will have a chance to acknowledge or
    veto the upcoming system transition to a sleep state.  Finally, if
    the transition is allowed to proceed, /sys/power/wakeup_count will
    be written to and if that succeeds, /sys/power/state will be written
    to as well.  Still, if any wakeup events are reported to the PM core
    by kernel subsystems after that point, the transition will be
    aborted.]
    
    Additionally, put a wakeup events counter into struct dev_pm_info and
    make these per-device wakeup event counters available via sysfs,
    so that it's possible to check the activity of various wakeup event
    sources within the kernel.
    
    To illustrate how subsystems can use pm_wakeup_event(), make the
    low-level PCI runtime PM wakeup-handling code use it.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Acked-by: markgross <markgross@thegnar.org>
    Reviewed-by: Alan Stern <stern@rowland.harvard.edu>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 2e7a3bf13824..1ab98bbe58dd 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -48,6 +48,7 @@ static void pci_acpi_wake_dev(acpi_handle handle, u32 event, void *context)
 	if (event == ACPI_NOTIFY_DEVICE_WAKE && pci_dev) {
 		pci_check_pme_status(pci_dev);
 		pm_runtime_resume(&pci_dev->dev);
+		pci_wakeup_event(pci_dev);
 		if (pci_dev->subordinate)
 			pci_pme_wakeup_bus(pci_dev->subordinate);
 	}

commit a44061aa8b5d58b2729faca4c155a94a5bea2a09
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Jul 1 10:11:45 2010 +0800

    ACPICA: Remove wakeup GPE reference counting which is not used
    
    After the previous patch that introduced acpi_gpe_wakeup() and
    modified the ACPI suspend and wakeup code to use it, the third
    argument of acpi_{enable|disable}_gpe() and the GPE wakeup
    reference counter are not necessary any more.  Remove them and
    modify all of the users of acpi_{enable|disable}_gpe()
    accordingly.  Also drop GPE type constants that aren't used
    any more.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 2e7a3bf13824..5342e037e37f 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -295,14 +295,12 @@ static int acpi_dev_run_wake(struct device *phys_dev, bool enable)
 		if (!dev->wakeup.run_wake_count++) {
 			acpi_enable_wakeup_device_power(dev, ACPI_STATE_S0);
 			acpi_enable_gpe(dev->wakeup.gpe_device,
-					dev->wakeup.gpe_number,
-					ACPI_GPE_TYPE_RUNTIME);
+					dev->wakeup.gpe_number);
 		}
 	} else if (dev->wakeup.run_wake_count > 0) {
 		if (!--dev->wakeup.run_wake_count) {
 			acpi_disable_gpe(dev->wakeup.gpe_device,
-					 dev->wakeup.gpe_number,
-					 ACPI_GPE_TYPE_RUNTIME);
+					 dev->wakeup.gpe_number);
 			acpi_disable_wakeup_device_power(dev);
 		}
 	} else {

commit bc535154137601400ffe44c2a7be047ca041fe06
Merge: d03ab7ff335b 439913fffd39
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Mar 1 10:36:22 2010 -0800

    Merge branch 'acpica' of git://git.kernel.org/pub/scm/linux/kernel/git/lenb/linux-acpi-2.6
    
    * 'acpica' of git://git.kernel.org/pub/scm/linux/kernel/git/lenb/linux-acpi-2.6:
      ACPI: replace acpi_integer by u64
      ACPICA: Update version to 20100121.
      ACPICA: Remove unused uint32_struct type
      ACPICA: Disassembler: Remove obsolete "Integer64" field in parse object
      ACPICA: Remove obsolete ACPI_INTEGER (acpi_integer) type
      ACPICA: Predefined name repair: fix NULL package elements
      ACPICA: AcpiGetDevices: Eliminate unnecessary _STA calls
      ACPICA: Update all ACPICA copyrights and signons to 2010
      ACPICA: Update for new gcc-4 warning options

commit b67ea76172d4b1922c4b3c46c8ea8e9fec1ff38c
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Feb 17 23:44:09 2010 +0100

    PCI / ACPI / PM: Platform support for PCI PME wake-up
    
    Although the majority of PCI devices can generate PMEs that in
    principle may be used to wake up devices suspended at run time,
    platform support is generally necessary to convert PMEs into wake-up
    events that can be delivered to the kernel.  If ACPI is used for this
    purpose, PME signals generated by a PCI device will trigger the ACPI
    GPE associated with the device to generate an ACPI wake-up event that
    we can set up a handler for, provided that everything is configured
    correctly.
    
    Unfortunately, the subset of PCI devices that have GPEs associated
    with them is quite limited.  The devices without dedicated GPEs have
    to rely on the GPEs associated with other devices (in the majority of
    cases their upstream bridges and, possibly, the root bridge) to
    generate ACPI wake-up events in response to PME signals from them.
    
    Add ACPI platform support for PCI PME wake-up:
    o Add a framework making is possible to use ACPI system notify
      handlers for run-time PM.
    o Add new PCI platform callback ->run_wake() to struct
      pci_platform_pm_ops allowing us to enable/disable the platform to
      generate wake-up events for given device.  Implemet this callback
      for the ACPI platform.
    o Define ACPI wake-up handlers for PCI devices and PCI root buses and
      make the PCI-ACPI binding code register wake-up notifiers for all
      PCI devices present in the ACPI tables.
    o Add function pci_dev_run_wake() which can be used by PCI drivers to
      check if given device is capable of generating wake-up events at
      run time.
    
    Developed in cooperation with Matthew Garrett <mjg@redhat.com>.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 7e2829538a4c..c0c73913833d 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -16,8 +16,144 @@
 #include <acpi/acpi_bus.h>
 
 #include <linux/pci-acpi.h>
+#include <linux/pm_runtime.h>
 #include "pci.h"
 
+static DEFINE_MUTEX(pci_acpi_pm_notify_mtx);
+
+/**
+ * pci_acpi_wake_bus - Wake-up notification handler for root buses.
+ * @handle: ACPI handle of a device the notification is for.
+ * @event: Type of the signaled event.
+ * @context: PCI root bus to wake up devices on.
+ */
+static void pci_acpi_wake_bus(acpi_handle handle, u32 event, void *context)
+{
+	struct pci_bus *pci_bus = context;
+
+	if (event == ACPI_NOTIFY_DEVICE_WAKE && pci_bus)
+		pci_pme_wakeup_bus(pci_bus);
+}
+
+/**
+ * pci_acpi_wake_dev - Wake-up notification handler for PCI devices.
+ * @handle: ACPI handle of a device the notification is for.
+ * @event: Type of the signaled event.
+ * @context: PCI device object to wake up.
+ */
+static void pci_acpi_wake_dev(acpi_handle handle, u32 event, void *context)
+{
+	struct pci_dev *pci_dev = context;
+
+	if (event == ACPI_NOTIFY_DEVICE_WAKE && pci_dev) {
+		pci_check_pme_status(pci_dev);
+		pm_runtime_resume(&pci_dev->dev);
+		if (pci_dev->subordinate)
+			pci_pme_wakeup_bus(pci_dev->subordinate);
+	}
+}
+
+/**
+ * add_pm_notifier - Register PM notifier for given ACPI device.
+ * @dev: ACPI device to add the notifier for.
+ * @context: PCI device or bus to check for PME status if an event is signaled.
+ *
+ * NOTE: @dev need not be a run-wake or wake-up device to be a valid source of
+ * PM wake-up events.  For example, wake-up events may be generated for bridges
+ * if one of the devices below the bridge is signaling PME, even if the bridge
+ * itself doesn't have a wake-up GPE associated with it.
+ */
+static acpi_status add_pm_notifier(struct acpi_device *dev,
+				   acpi_notify_handler handler,
+				   void *context)
+{
+	acpi_status status = AE_ALREADY_EXISTS;
+
+	mutex_lock(&pci_acpi_pm_notify_mtx);
+
+	if (dev->wakeup.flags.notifier_present)
+		goto out;
+
+	status = acpi_install_notify_handler(dev->handle,
+					     ACPI_SYSTEM_NOTIFY,
+					     handler, context);
+	if (ACPI_FAILURE(status))
+		goto out;
+
+	dev->wakeup.flags.notifier_present = true;
+
+ out:
+	mutex_unlock(&pci_acpi_pm_notify_mtx);
+	return status;
+}
+
+/**
+ * remove_pm_notifier - Unregister PM notifier from given ACPI device.
+ * @dev: ACPI device to remove the notifier from.
+ */
+static acpi_status remove_pm_notifier(struct acpi_device *dev,
+				      acpi_notify_handler handler)
+{
+	acpi_status status = AE_BAD_PARAMETER;
+
+	mutex_lock(&pci_acpi_pm_notify_mtx);
+
+	if (!dev->wakeup.flags.notifier_present)
+		goto out;
+
+	status = acpi_remove_notify_handler(dev->handle,
+					    ACPI_SYSTEM_NOTIFY,
+					    handler);
+	if (ACPI_FAILURE(status))
+		goto out;
+
+	dev->wakeup.flags.notifier_present = false;
+
+ out:
+	mutex_unlock(&pci_acpi_pm_notify_mtx);
+	return status;
+}
+
+/**
+ * pci_acpi_add_bus_pm_notifier - Register PM notifier for given PCI bus.
+ * @dev: ACPI device to add the notifier for.
+ * @pci_bus: PCI bus to walk checking for PME status if an event is signaled.
+ */
+acpi_status pci_acpi_add_bus_pm_notifier(struct acpi_device *dev,
+					 struct pci_bus *pci_bus)
+{
+	return add_pm_notifier(dev, pci_acpi_wake_bus, pci_bus);
+}
+
+/**
+ * pci_acpi_remove_bus_pm_notifier - Unregister PCI bus PM notifier.
+ * @dev: ACPI device to remove the notifier from.
+ */
+acpi_status pci_acpi_remove_bus_pm_notifier(struct acpi_device *dev)
+{
+	return remove_pm_notifier(dev, pci_acpi_wake_bus);
+}
+
+/**
+ * pci_acpi_add_pm_notifier - Register PM notifier for given PCI device.
+ * @dev: ACPI device to add the notifier for.
+ * @pci_dev: PCI device to check for the PME status if an event is signaled.
+ */
+acpi_status pci_acpi_add_pm_notifier(struct acpi_device *dev,
+				     struct pci_dev *pci_dev)
+{
+	return add_pm_notifier(dev, pci_acpi_wake_dev, pci_dev);
+}
+
+/**
+ * pci_acpi_remove_pm_notifier - Unregister PCI device PM notifier.
+ * @dev: ACPI device to remove the notifier from.
+ */
+acpi_status pci_acpi_remove_pm_notifier(struct acpi_device *dev)
+{
+	return remove_pm_notifier(dev, pci_acpi_wake_dev);
+}
+
 /*
  * _SxD returns the D-state with the highest power
  * (lowest D-state number) supported in the S-state "x".
@@ -131,12 +267,87 @@ static int acpi_pci_sleep_wake(struct pci_dev *dev, bool enable)
 	return 0;
 }
 
+/**
+ * acpi_dev_run_wake - Enable/disable wake-up for given device.
+ * @phys_dev: Device to enable/disable the platform to wake-up the system for.
+ * @enable: Whether enable or disable the wake-up functionality.
+ *
+ * Find the ACPI device object corresponding to @pci_dev and try to
+ * enable/disable the GPE associated with it.
+ */
+static int acpi_dev_run_wake(struct device *phys_dev, bool enable)
+{
+	struct acpi_device *dev;
+	acpi_handle handle;
+	int error = -ENODEV;
+
+	if (!device_run_wake(phys_dev))
+		return -EINVAL;
+
+	handle = DEVICE_ACPI_HANDLE(phys_dev);
+	if (!handle || ACPI_FAILURE(acpi_bus_get_device(handle, &dev))) {
+		dev_dbg(phys_dev, "ACPI handle has no context in %s!\n",
+			__func__);
+		return -ENODEV;
+	}
+
+	if (enable) {
+		if (!dev->wakeup.run_wake_count++) {
+			acpi_enable_wakeup_device_power(dev, ACPI_STATE_S0);
+			acpi_enable_gpe(dev->wakeup.gpe_device,
+					dev->wakeup.gpe_number,
+					ACPI_GPE_TYPE_RUNTIME);
+		}
+	} else if (dev->wakeup.run_wake_count > 0) {
+		if (!--dev->wakeup.run_wake_count) {
+			acpi_disable_gpe(dev->wakeup.gpe_device,
+					 dev->wakeup.gpe_number,
+					 ACPI_GPE_TYPE_RUNTIME);
+			acpi_disable_wakeup_device_power(dev);
+		}
+	} else {
+		error = -EALREADY;
+	}
+
+	return error;
+}
+
+static void acpi_pci_propagate_run_wake(struct pci_bus *bus, bool enable)
+{
+	while (bus->parent) {
+		struct pci_dev *bridge = bus->self;
+
+		if (bridge->pme_interrupt)
+			return;
+		if (!acpi_dev_run_wake(&bridge->dev, enable))
+			return;
+		bus = bus->parent;
+	}
+
+	/* We have reached the root bus. */
+	if (bus->bridge)
+		acpi_dev_run_wake(bus->bridge, enable);
+}
+
+static int acpi_pci_run_wake(struct pci_dev *dev, bool enable)
+{
+	if (dev->pme_interrupt)
+		return 0;
+
+	if (!acpi_dev_run_wake(&dev->dev, enable))
+		return 0;
+
+	acpi_pci_propagate_run_wake(dev->bus, enable);
+	return 0;
+}
+
 static struct pci_platform_pm_ops acpi_pci_platform_pm = {
 	.is_manageable = acpi_pci_power_manageable,
 	.set_state = acpi_pci_set_power_state,
 	.choose_state = acpi_pci_choose_state,
 	.can_wakeup = acpi_pci_can_wakeup,
 	.sleep_wake = acpi_pci_sleep_wake,
+	.run_wake = acpi_pci_run_wake,
 };
 
 /* ACPI bus type */

commit 439913fffd39374c3737186b22d2d56c3a0ae526
Author: Lin Ming <ming.m.lin@intel.com>
Date:   Thu Jan 28 10:53:19 2010 +0800

    ACPI: replace acpi_integer by u64
    
    acpi_integer is now obsolete and removed from the ACPICA code base,
    replaced by u64.
    
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 7e2829538a4c..441326c44138 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -143,7 +143,7 @@ static struct pci_platform_pm_ops acpi_pci_platform_pm = {
 static int acpi_pci_find_device(struct device *dev, acpi_handle *handle)
 {
 	struct pci_dev * pci_dev;
-	acpi_integer	addr;
+	u64	addr;
 
 	pci_dev = to_pci_dev(dev);
 	/* Please ref to ACPI spec for the syntax of _ADR */

commit dc1a94ae1749d14c55f8b54e9d92bd89df82d51a
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Nov 29 16:35:54 2009 +0100

    PCI/PM: Propagate wake-up enable for PCIe devices too
    
    Having read the PM part of the PCIe 2.0 specification more carefully
    I think that it was a mistake to restrict the wake-up enable
    propagation to non-PCIe devices, because if we do not request
    control of the root ports' PME registers via OSC, PCIe PME is
    supposed to be handled by the platform, just like the non-PCIe PME.
    Even if we do that, the wake-up propagation is done to allow the
    devices to wake up the system from sleep states which involves the
    platform anyway, so it won't hurt.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index cc617ddd33d0..7e2829538a4c 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -112,11 +112,7 @@ static bool acpi_pci_can_wakeup(struct pci_dev *dev)
 static void acpi_pci_propagate_wakeup_enable(struct pci_bus *bus, bool enable)
 {
 	while (bus->parent) {
-		struct pci_dev *bridge = bus->self;
-		int ret;
-
-		ret = acpi_pm_device_sleep_wake(&bridge->dev, enable);
-		if (!ret || pci_is_pcie(bridge))
+		if (!acpi_pm_device_sleep_wake(&bus->self->dev, enable))
 			return;
 		bus = bus->parent;
 	}
@@ -131,9 +127,7 @@ static int acpi_pci_sleep_wake(struct pci_dev *dev, bool enable)
 	if (acpi_pci_can_wakeup(dev))
 		return acpi_pm_device_sleep_wake(&dev->dev, enable);
 
-	if (!pci_is_pcie(dev))
-		acpi_pci_propagate_wakeup_enable(dev->bus, enable);
-
+	acpi_pci_propagate_wakeup_enable(dev->bus, enable);
 	return 0;
 }
 

commit 5f4d91a1228ac85c75b099efd36fff1a3407335c
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Wed Nov 11 14:36:17 2009 +0900

    PCI: use pci_is_pcie() in pci core
    
    Change for PCI core to use pci_is_pcie() instead of checking
    pci_dev->is_pcie.
    
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 33317df47699..cc617ddd33d0 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -116,7 +116,7 @@ static void acpi_pci_propagate_wakeup_enable(struct pci_bus *bus, bool enable)
 		int ret;
 
 		ret = acpi_pm_device_sleep_wake(&bridge->dev, enable);
-		if (!ret || bridge->is_pcie)
+		if (!ret || pci_is_pcie(bridge))
 			return;
 		bus = bus->parent;
 	}
@@ -131,7 +131,7 @@ static int acpi_pci_sleep_wake(struct pci_dev *dev, bool enable)
 	if (acpi_pci_can_wakeup(dev))
 		return acpi_pm_device_sleep_wake(&dev->dev, enable);
 
-	if (!dev->is_pcie)
+	if (!pci_is_pcie(dev))
 		acpi_pci_propagate_wakeup_enable(dev->bus, enable);
 
 	return 0;

commit 0baed8da1ed91b664759f6c7f955b3a804457389
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Sep 8 23:16:24 2009 +0200

    PCI / ACPI PM: Propagate wake-up enable for devices w/o ACPI support
    
    Some PCI devices (not PCI Express), like PCI add-on cards, can
    generate PME#, but they don't have any special platform wake-up
    support.  For this reason, even if they generate PME# to wake up the
    system from a sleep state, wake-up events are not generated by the
    platform.
    
    It turns out that, at least on some systems, PCI bridges and the PCI
    host bridge have ACPI GPEs associated with them that, if enabled to
    generate wake-up events, allow the system to wake up if one of the
    add-on devices asserts PME# while the system is in a sleep state.
    Following this observation, if a PCI device without direct ACPI
    wake-up support is prepared to wake up the system during a transition
    into a sleep state (eg. suspend to RAM), try to configure the bridges
    on the path from the device to the root bridge to wake-up the system.
    
    Reviewed-by: Matthew Garrett <mjg59@srcf.ucam.org>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 0bddd787490d..33317df47699 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -109,10 +109,32 @@ static bool acpi_pci_can_wakeup(struct pci_dev *dev)
 	return handle ? acpi_bus_can_wakeup(handle) : false;
 }
 
+static void acpi_pci_propagate_wakeup_enable(struct pci_bus *bus, bool enable)
+{
+	while (bus->parent) {
+		struct pci_dev *bridge = bus->self;
+		int ret;
+
+		ret = acpi_pm_device_sleep_wake(&bridge->dev, enable);
+		if (!ret || bridge->is_pcie)
+			return;
+		bus = bus->parent;
+	}
+
+	/* We have reached the root bus. */
+	if (bus->bridge)
+		acpi_pm_device_sleep_wake(bus->bridge, enable);
+}
+
 static int acpi_pci_sleep_wake(struct pci_dev *dev, bool enable)
 {
-	return acpi_pci_can_wakeup(dev) ?
-		acpi_pm_device_sleep_wake(&dev->dev, enable) : 0;
+	if (acpi_pci_can_wakeup(dev))
+		return acpi_pm_device_sleep_wake(&dev->dev, enable);
+
+	if (!dev->is_pcie)
+		acpi_pci_propagate_wakeup_enable(dev->bus, enable);
+
+	return 0;
 }
 
 static struct pci_platform_pm_ops acpi_pci_platform_pm = {

commit df8db91fc3b543d373afa61beef35b072eea1368
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Sep 8 23:13:49 2009 +0200

    PCI / ACPI PM: Rework some debug messages
    
    Move a debug message from acpi_pci_sleep_wake() to
    acpi_pm_device_sleep_wake() and use the standard dev_*() macros
    in there.
    
    Reviewed-by: Matthew Garrett <mjg59@srcf.ucam.org>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index e798c4736a66..0bddd787490d 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -111,17 +111,8 @@ static bool acpi_pci_can_wakeup(struct pci_dev *dev)
 
 static int acpi_pci_sleep_wake(struct pci_dev *dev, bool enable)
 {
-	int error;
-
-	if (!acpi_pci_can_wakeup(dev))
-		return 0;
-
-	error = acpi_pm_device_sleep_wake(&dev->dev, enable);
-	if (!error)
-		dev_info(&dev->dev, "wake-up capability %s by ACPI\n",
-				enable ? "enabled" : "disabled");
-
-	return error;
+	return acpi_pci_can_wakeup(dev) ?
+		acpi_pm_device_sleep_wake(&dev->dev, enable) : 0;
 }
 
 static struct pci_platform_pm_ops acpi_pci_platform_pm = {

commit 5bcc2fb4e8157d829a38093b98e23329ac8acff7
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Sep 8 23:12:59 2009 +0200

    PCI PM: Simplify PCI wake-up code
    
    Rework the PCI wake-up code so that it's easier to read without
    changing the functionality.
    
    Reviewed-by: Matthew Garrett <mjg59@srcf.ucam.org>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index ea15b0537457..e798c4736a66 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -111,12 +111,16 @@ static bool acpi_pci_can_wakeup(struct pci_dev *dev)
 
 static int acpi_pci_sleep_wake(struct pci_dev *dev, bool enable)
 {
-	int error = acpi_pm_device_sleep_wake(&dev->dev, enable);
+	int error;
 
+	if (!acpi_pci_can_wakeup(dev))
+		return 0;
+
+	error = acpi_pm_device_sleep_wake(&dev->dev, enable);
 	if (!error)
-		dev_printk(KERN_INFO, &dev->dev,
-				"wake-up capability %s by ACPI\n",
+		dev_info(&dev->dev, "wake-up capability %s by ACPI\n",
 				enable ? "enabled" : "disabled");
+
 	return error;
 }
 

commit 478c6a43fcbc6c11609f8cee7c7b57223907754f
Merge: 8a3f257c704e 6bb597507f98
Author: Len Brown <len.brown@intel.com>
Date:   Sun Apr 5 02:14:15 2009 -0400

    Merge branch 'linus' into release
    
    Conflicts:
            arch/x86/kernel/cpu/cpufreq/longhaul.c
    
    Signed-off-by: Len Brown <len.brown@intel.com>

commit 993958fecab6eabc6ee5b7ed65c56d716fd5cfe3
Author: Bob Moore <robert.moore@intel.com>
Date:   Tue Feb 3 15:14:33 2009 +0800

    ACPICA: Update FADT flag definitions
    
    Add new flags in the Boot Architecture flags field. Update comments
    for all FADT flags. Add FADT version when each flag was defined.
    
    Signed-off-by: Bob Moore <robert.moore@intel.com>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index deea8a187eb8..368ca72dffbc 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -386,12 +386,12 @@ static int __init acpi_pci_init(void)
 {
 	int ret;
 
-	if (acpi_gbl_FADT.boot_flags & BAF_MSI_NOT_SUPPORTED) {
+	if (acpi_gbl_FADT.boot_flags & ACPI_FADT_NO_MSI) {
 		printk(KERN_INFO"ACPI FADT declares the system doesn't support MSI, so disable it\n");
 		pci_no_msi();
 	}
 
-	if (acpi_gbl_FADT.boot_flags & BAF_PCIE_ASPM_CONTROL) {
+	if (acpi_gbl_FADT.boot_flags & ACPI_FADT_NO_ASPM) {
 		printk(KERN_INFO"ACPI FADT declares the system doesn't support PCIe ASPM, so disable it\n");
 		pcie_no_aspm();
 	}

commit 63f10f0f6df4e4e860b790d64bebfde85b540b0a
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Mon Feb 9 15:59:29 2009 +0900

    PCI/ACPI: move _OSC code to pci_root.c
    
    Move PCI _OSC management code from drivers/pci/pci-acpi.c to
    drivers/acpi/pci_root.c. The benefits are
    
    - We no longer need struct osc_data and its management code (contents
      are moved to struct acpi_pci_root). This simplify the code, and we
      no longer care about kmalloc() failure.
    
    - We can make pci_acpi_osc_support() be a static function, which is
      called only from drivers/acpi/pci_root.c.
    
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Reviewed-by: Andrew Patterson <andrew.patterson@hp.com>
    Tested-by: Andrew Patterson <andrew.patterson@hp.com>
    Acked-by: Alex Chiang <achiang@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index deea8a187eb8..fac5eddcefd2 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -18,221 +18,6 @@
 #include <linux/pci-acpi.h>
 #include "pci.h"
 
-struct acpi_osc_data {
-	acpi_handle handle;
-	u32 support_set;
-	u32 control_set;
-	u32 control_query;
-	int is_queried;
-	struct list_head sibiling;
-};
-static LIST_HEAD(acpi_osc_data_list);
-
-struct acpi_osc_args {
-	u32 capbuf[3];
-};
-
-static DEFINE_MUTEX(pci_acpi_lock);
-
-static struct acpi_osc_data *acpi_get_osc_data(acpi_handle handle)
-{
-	struct acpi_osc_data *data;
-
-	list_for_each_entry(data, &acpi_osc_data_list, sibiling) {
-		if (data->handle == handle)
-			return data;
-	}
-	data = kzalloc(sizeof(*data), GFP_KERNEL);
-	if (!data)
-		return NULL;
-	INIT_LIST_HEAD(&data->sibiling);
-	data->handle = handle;
-	list_add_tail(&data->sibiling, &acpi_osc_data_list);
-	return data;
-}
-
-static u8 OSC_UUID[16] = {0x5B, 0x4D, 0xDB, 0x33, 0xF7, 0x1F, 0x1C, 0x40,
-			  0x96, 0x57, 0x74, 0x41, 0xC0, 0x3D, 0xD7, 0x66};
-
-static acpi_status acpi_run_osc(acpi_handle handle,
-				struct acpi_osc_args *osc_args, u32 *retval)
-{
-	acpi_status status;
-	struct acpi_object_list input;
-	union acpi_object in_params[4];
-	struct acpi_buffer output = {ACPI_ALLOCATE_BUFFER, NULL};
-	union acpi_object *out_obj;
-	u32 errors, flags = osc_args->capbuf[OSC_QUERY_TYPE];
-
-	/* Setting up input parameters */
-	input.count = 4;
-	input.pointer = in_params;
-	in_params[0].type 		= ACPI_TYPE_BUFFER;
-	in_params[0].buffer.length 	= 16;
-	in_params[0].buffer.pointer	= OSC_UUID;
-	in_params[1].type 		= ACPI_TYPE_INTEGER;
-	in_params[1].integer.value 	= 1;
-	in_params[2].type 		= ACPI_TYPE_INTEGER;
-	in_params[2].integer.value	= 3;
-	in_params[3].type		= ACPI_TYPE_BUFFER;
-	in_params[3].buffer.length 	= 12;
-	in_params[3].buffer.pointer 	= (u8 *)osc_args->capbuf;
-
-	status = acpi_evaluate_object(handle, "_OSC", &input, &output);
-	if (ACPI_FAILURE(status))
-		return status;
-
-	if (!output.length)
-		return AE_NULL_OBJECT;
-
-	out_obj = output.pointer;
-	if (out_obj->type != ACPI_TYPE_BUFFER) {
-		printk(KERN_DEBUG "Evaluate _OSC returns wrong type\n");
-		status = AE_TYPE;
-		goto out_kfree;
-	}
-	/* Need to ignore the bit0 in result code */
-	errors = *((u32 *)out_obj->buffer.pointer) & ~(1 << 0);
-	if (errors) {
-		if (errors & OSC_REQUEST_ERROR)
-			printk(KERN_DEBUG "_OSC request fails\n"); 
-		if (errors & OSC_INVALID_UUID_ERROR)
-			printk(KERN_DEBUG "_OSC invalid UUID\n"); 
-		if (errors & OSC_INVALID_REVISION_ERROR)
-			printk(KERN_DEBUG "_OSC invalid revision\n"); 
-		if (errors & OSC_CAPABILITIES_MASK_ERROR) {
-			if (flags & OSC_QUERY_ENABLE)
-				goto out_success;
-			printk(KERN_DEBUG "_OSC FW not grant req. control\n");
-			status = AE_SUPPORT;
-			goto out_kfree;
-		}
-		status = AE_ERROR;
-		goto out_kfree;
-	}
-out_success:
-	*retval = *((u32 *)(out_obj->buffer.pointer + 8));
-	status = AE_OK;
-
-out_kfree:
-	kfree(output.pointer);
-	return status;
-}
-
-static acpi_status __acpi_query_osc(u32 flags, struct acpi_osc_data *osc_data)
-{
-	acpi_status status;
-	u32 support_set, result;
-	struct acpi_osc_args osc_args;
-
-	/* do _OSC query for all possible controls */
-	support_set = osc_data->support_set | (flags & OSC_SUPPORT_MASKS);
-	osc_args.capbuf[OSC_QUERY_TYPE] = OSC_QUERY_ENABLE;
-	osc_args.capbuf[OSC_SUPPORT_TYPE] = support_set;
-	osc_args.capbuf[OSC_CONTROL_TYPE] = OSC_CONTROL_MASKS;
-
-	status = acpi_run_osc(osc_data->handle, &osc_args, &result);
-	if (ACPI_SUCCESS(status)) {
-		osc_data->support_set = support_set;
-		osc_data->control_query = result;
-		osc_data->is_queried = 1;
-	}
-
-	return status;
-}
-
-/*
- * pci_acpi_osc_support: Invoke _OSC indicating support for the given feature
- * @flags: Bitmask of flags to support
- *
- * See the ACPI spec for the definition of the flags
- */
-int pci_acpi_osc_support(acpi_handle handle, u32 flags)
-{
-	acpi_status status;
-	acpi_handle tmp;
-	struct acpi_osc_data *osc_data;
-	int rc = 0;
-
-	status = acpi_get_handle(handle, "_OSC", &tmp);
-	if (ACPI_FAILURE(status))
-		return -ENOTTY;
-
-	mutex_lock(&pci_acpi_lock);
-	osc_data = acpi_get_osc_data(handle);
-	if (!osc_data) {
-		printk(KERN_ERR "acpi osc data array is full\n");
-		rc = -ENOMEM;
-		goto out;
-	}
-
-	__acpi_query_osc(flags, osc_data);
-out:
-	mutex_unlock(&pci_acpi_lock);
-	return rc;
-}
-
-/**
- * pci_osc_control_set - commit requested control to Firmware
- * @handle: acpi_handle for the target ACPI object
- * @flags: driver's requested control bits
- *
- * Attempt to take control from Firmware on requested control bits.
- **/
-acpi_status pci_osc_control_set(acpi_handle handle, u32 flags)
-{
-	acpi_status status;
-	u32 control_req, control_set, result;
-	acpi_handle tmp;
-	struct acpi_osc_data *osc_data;
-	struct acpi_osc_args osc_args;
-
-	status = acpi_get_handle(handle, "_OSC", &tmp);
-	if (ACPI_FAILURE(status))
-		return status;
-
-	mutex_lock(&pci_acpi_lock);
-	osc_data = acpi_get_osc_data(handle);
-	if (!osc_data) {
-		printk(KERN_ERR "acpi osc data array is full\n");
-		status = AE_ERROR;
-		goto out;
-	}
-
-	control_req = (flags & OSC_CONTROL_MASKS);
-	if (!control_req) {
-		status = AE_TYPE;
-		goto out;
-	}
-
-	/* No need to evaluate _OSC if the control was already granted. */
-	if ((osc_data->control_set & control_req) == control_req)
-		goto out;
-
-	if (!osc_data->is_queried) {
-		status = __acpi_query_osc(osc_data->support_set, osc_data);
-		if (ACPI_FAILURE(status))
-			goto out;
-	}
-
-	if ((osc_data->control_query & control_req) != control_req) {
-		status = AE_SUPPORT;
-		goto out;
-	}
-
-	control_set = osc_data->control_set | control_req;
-	osc_args.capbuf[OSC_QUERY_TYPE] = 0;
-	osc_args.capbuf[OSC_SUPPORT_TYPE] = osc_data->support_set;
-	osc_args.capbuf[OSC_CONTROL_TYPE] = control_set;
-	status = acpi_run_osc(handle, &osc_args, &result);
-	if (ACPI_SUCCESS(status))
-		osc_data->control_set = result;
-out:
-	mutex_unlock(&pci_acpi_lock);
-	return status;
-}
-EXPORT_SYMBOL(pci_osc_control_set);
-
 /*
  * _SxD returns the D-state with the highest power
  * (lowest D-state number) supported in the S-state "x".

commit b2576e1d4408e134e2188c967b1f28af39cd79d4
Merge: 3cc8a5f4ba91 2150edc6c5cf
Author: Len Brown <len.brown@intel.com>
Date:   Fri Jan 9 03:39:43 2009 -0500

    Merge branch 'linus' into release

commit 86d8698027fd30cc067d2aeeb1e3603d43c83df0
Author: Taku Izumi <izumi.taku@jp.fujitsu.com>
Date:   Thu Nov 20 15:22:39 2008 +0900

    pci-acpi: Cleanup _OSC evaluation code
    
    Cleanup _OSC evaluation code.  Some whitespace changes and a few other
    minor cleanups.
    
    Reviewed-by: Andrew Patterson <andrew.patterson@hp.com>
    Tested-by: Andrew Patterson <andrew.patterson@hp.com>
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Taku Izumi <izumi.taku@jp.fujitsu.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 736bb248008e..3582512e7226 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -24,15 +24,14 @@ struct acpi_osc_data {
 	acpi_handle handle;
 	u32 support_set;
 	u32 control_set;
+	u32 control_query;
 	int is_queried;
-	u32 query_result;
 	struct list_head sibiling;
 };
 static LIST_HEAD(acpi_osc_data_list);
 
 struct acpi_osc_args {
 	u32 capbuf[3];
-	u32 query_result;
 };
 
 static DEFINE_MUTEX(pci_acpi_lock);
@@ -58,7 +57,7 @@ static u8 OSC_UUID[16] = {0x5B, 0x4D, 0xDB, 0x33, 0xF7, 0x1F, 0x1C, 0x40,
 			  0x96, 0x57, 0x74, 0x41, 0xC0, 0x3D, 0xD7, 0x66};
 
 static acpi_status acpi_run_osc(acpi_handle handle,
-				struct acpi_osc_args *osc_args)
+				struct acpi_osc_args *osc_args, u32 *retval)
 {
 	acpi_status status;
 	struct acpi_object_list input;
@@ -114,9 +113,7 @@ static acpi_status acpi_run_osc(acpi_handle handle,
 		goto out_kfree;
 	}
 out_success:
-	if (flags & OSC_QUERY_ENABLE)
-		osc_args->query_result =
-			*((u32 *)(out_obj->buffer.pointer + 8));
+	*retval = *((u32 *)(out_obj->buffer.pointer + 8));
 	status = AE_OK;
 
 out_kfree:
@@ -127,7 +124,7 @@ static acpi_status acpi_run_osc(acpi_handle handle,
 static acpi_status __acpi_query_osc(u32 flags, struct acpi_osc_data *osc_data)
 {
 	acpi_status status;
-	u32 support_set;
+	u32 support_set, result;
 	struct acpi_osc_args osc_args;
 
 	/* do _OSC query for all possible controls */
@@ -136,10 +133,10 @@ static acpi_status __acpi_query_osc(u32 flags, struct acpi_osc_data *osc_data)
 	osc_args.capbuf[OSC_SUPPORT_TYPE] = support_set;
 	osc_args.capbuf[OSC_CONTROL_TYPE] = OSC_CONTROL_MASKS;
 
-	status = acpi_run_osc(osc_data->handle, &osc_args);
+	status = acpi_run_osc(osc_data->handle, &osc_args, &result);
 	if (ACPI_SUCCESS(status)) {
 		osc_data->support_set = support_set;
-		osc_data->query_result = osc_args.query_result;
+		osc_data->control_query = result;
 		osc_data->is_queried = 1;
 	}
 
@@ -187,7 +184,7 @@ int pci_acpi_osc_support(acpi_handle handle, u32 flags)
 acpi_status pci_osc_control_set(acpi_handle handle, u32 flags)
 {
 	acpi_status status;
-	u32 ctrlset, control_set;
+	u32 control_req, control_set, result;
 	acpi_handle tmp;
 	struct acpi_osc_data *osc_data;
 	struct acpi_osc_args osc_args;
@@ -204,14 +201,14 @@ acpi_status pci_osc_control_set(acpi_handle handle, u32 flags)
 		goto out;
 	}
 
-	ctrlset = (flags & OSC_CONTROL_MASKS);
-	if (!ctrlset) {
+	control_req = (flags & OSC_CONTROL_MASKS);
+	if (!control_req) {
 		status = AE_TYPE;
 		goto out;
 	}
 
 	/* No need to evaluate _OSC if the control was already granted. */
-	if ((osc_data->control_set & ctrlset) == ctrlset)
+	if ((osc_data->control_set & control_req) == control_req)
 		goto out;
 
 	if (!osc_data->is_queried) {
@@ -220,18 +217,18 @@ acpi_status pci_osc_control_set(acpi_handle handle, u32 flags)
 			goto out;
 	}
 
-	if ((osc_data->query_result & ctrlset) != ctrlset) {
+	if ((osc_data->control_query & control_req) != control_req) {
 		status = AE_SUPPORT;
 		goto out;
 	}
 
-	control_set = osc_data->control_set | ctrlset;
+	control_set = osc_data->control_set | control_req;
 	osc_args.capbuf[OSC_QUERY_TYPE] = 0;
 	osc_args.capbuf[OSC_SUPPORT_TYPE] = osc_data->support_set;
 	osc_args.capbuf[OSC_CONTROL_TYPE] = control_set;
-	status = acpi_run_osc(handle, &osc_args);
+	status = acpi_run_osc(handle, &osc_args, &result);
 	if (ACPI_SUCCESS(status))
-		osc_data->control_set = control_set;
+		osc_data->control_set = result;
 out:
 	mutex_unlock(&pci_acpi_lock);
 	return status;

commit e0fa3b43df0b57967857b2c83bad9a5193fbddf5
Author: Taku Izumi <izumi.taku@jp.fujitsu.com>
Date:   Thu Nov 20 15:22:37 2008 +0900

    PCI/ACPI: Remove unnecessary _OSC evaluation for control request
    
    If a control had already been granted, we don't need to re-evaluate
    _OSC for it because firmware may not reject control of any feature it
    has previously granted control to.
    
    Reviewed-by: Andrew Patterson <andrew.patterson@hp.com>
    Tested-by: Andrew Patterson <andrew.patterson@hp.com>
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Taku Izumi <izumi.taku@jp.fujitsu.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index c580a525d9ce..736bb248008e 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -210,6 +210,10 @@ acpi_status pci_osc_control_set(acpi_handle handle, u32 flags)
 		goto out;
 	}
 
+	/* No need to evaluate _OSC if the control was already granted. */
+	if ((osc_data->control_set & ctrlset) == ctrlset)
+		goto out;
+
 	if (!osc_data->is_queried) {
 		status = __acpi_query_osc(osc_data->support_set, osc_data);
 		if (ACPI_FAILURE(status))

commit 753e3aca735dc446f66d501b625122661738b57d
Author: Taku Izumi <izumi.taku@jp.fujitsu.com>
Date:   Thu Nov 20 15:22:32 2008 +0900

    PCI: revert additional _OSC evaluation
    
    Reverts adf411b819adc9fa96e9b3e638c7480d5e71d270.
    
    The commit adf411b819adc9fa96e9b3e638c7480d5e71d270 was based on the
    improper assumption that queried result was not updated when _OSC
    support field was changed. But, in fact, queried result is updated
    whenever _OSC support field was changed through __acpi_query_osc().
    As a result, the commit adf411b819adc9fa96e9b3e638c7480d5e71d270 only
    introduced unnecessary additional _OSC evaluation...
    
    Tested-by: Andrew Patterson <andrew.patterson@hp.com>
    Reviewed-by: Andrew Patterson <andrew.patterson@hp.com>
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Taku Izumi <izumi.taku@jp.fujitsu.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 8f923ee5177f..c580a525d9ce 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -24,13 +24,15 @@ struct acpi_osc_data {
 	acpi_handle handle;
 	u32 support_set;
 	u32 control_set;
+	int is_queried;
+	u32 query_result;
 	struct list_head sibiling;
 };
 static LIST_HEAD(acpi_osc_data_list);
 
 struct acpi_osc_args {
 	u32 capbuf[3];
-	u32 ctrl_result;
+	u32 query_result;
 };
 
 static DEFINE_MUTEX(pci_acpi_lock);
@@ -112,8 +114,9 @@ static acpi_status acpi_run_osc(acpi_handle handle,
 		goto out_kfree;
 	}
 out_success:
-	osc_args->ctrl_result =
-		*((u32 *)(out_obj->buffer.pointer + 8));
+	if (flags & OSC_QUERY_ENABLE)
+		osc_args->query_result =
+			*((u32 *)(out_obj->buffer.pointer + 8));
 	status = AE_OK;
 
 out_kfree:
@@ -121,8 +124,7 @@ static acpi_status acpi_run_osc(acpi_handle handle,
 	return status;
 }
 
-static acpi_status __acpi_query_osc(u32 flags, struct acpi_osc_data *osc_data,
-				    u32 *result)
+static acpi_status __acpi_query_osc(u32 flags, struct acpi_osc_data *osc_data)
 {
 	acpi_status status;
 	u32 support_set;
@@ -137,7 +139,8 @@ static acpi_status __acpi_query_osc(u32 flags, struct acpi_osc_data *osc_data,
 	status = acpi_run_osc(osc_data->handle, &osc_args);
 	if (ACPI_SUCCESS(status)) {
 		osc_data->support_set = support_set;
-		*result = osc_args.ctrl_result;
+		osc_data->query_result = osc_args.query_result;
+		osc_data->is_queried = 1;
 	}
 
 	return status;
@@ -151,7 +154,6 @@ static acpi_status __acpi_query_osc(u32 flags, struct acpi_osc_data *osc_data,
  */
 int pci_acpi_osc_support(acpi_handle handle, u32 flags)
 {
-	u32 dummy;
 	acpi_status status;
 	acpi_handle tmp;
 	struct acpi_osc_data *osc_data;
@@ -169,7 +171,7 @@ int pci_acpi_osc_support(acpi_handle handle, u32 flags)
 		goto out;
 	}
 
-	__acpi_query_osc(flags, osc_data, &dummy);
+	__acpi_query_osc(flags, osc_data);
 out:
 	mutex_unlock(&pci_acpi_lock);
 	return rc;
@@ -185,7 +187,7 @@ int pci_acpi_osc_support(acpi_handle handle, u32 flags)
 acpi_status pci_osc_control_set(acpi_handle handle, u32 flags)
 {
 	acpi_status status;
-	u32 ctrlset, control_set, result;
+	u32 ctrlset, control_set;
 	acpi_handle tmp;
 	struct acpi_osc_data *osc_data;
 	struct acpi_osc_args osc_args;
@@ -208,11 +210,13 @@ acpi_status pci_osc_control_set(acpi_handle handle, u32 flags)
 		goto out;
 	}
 
-	status = __acpi_query_osc(osc_data->support_set, osc_data, &result);
-	if (ACPI_FAILURE(status))
-		goto out;
+	if (!osc_data->is_queried) {
+		status = __acpi_query_osc(osc_data->support_set, osc_data);
+		if (ACPI_FAILURE(status))
+			goto out;
+	}
 
-	if ((result & ctrlset) != ctrlset) {
+	if ((osc_data->query_result & ctrlset) != ctrlset) {
 		status = AE_SUPPORT;
 		goto out;
 	}

commit 23616941914917cf25b94789856b5326b68d8ee8
Author: Andrew Patterson <andrew.patterson@hp.com>
Date:   Mon Nov 10 15:31:10 2008 -0700

    ACPI/PCI: remove obsolete _OSC capability support functions
    
    The acpi_query_osc, __pci_osc_support_set, pci_osc_support_set, and
    pcie_osc_support_set functions have been obsoleted in favor of setting
    these capabilities during root bridge discovery with
    pci_acpi_osc_support.  There are no longer any callers of these
    functions, so remove them.
    
    Signed-off-by: Andrew Patterson <andrew.patterson@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 8a1f02c3c915..8f923ee5177f 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -175,31 +175,6 @@ int pci_acpi_osc_support(acpi_handle handle, u32 flags)
 	return rc;
 }
 
-static acpi_status acpi_query_osc(acpi_handle handle, u32 level,
-				  void *context, void **retval)
-{
-	pci_acpi_osc_support(handle, (unsigned long)context);
-	return AE_OK;
-}
-
-/**
- * __pci_osc_support_set - register OS support to Firmware
- * @flags: OS support bits
- * @hid: hardware ID
- *
- * Update OS support fields and doing a _OSC Query to obtain an update
- * from Firmware on supported control bits.
- **/
-acpi_status __pci_osc_support_set(u32 flags, const char *hid)
-{
-	if (!(flags & OSC_SUPPORT_MASKS))
-		return AE_TYPE;
-
-	acpi_get_devices(hid, acpi_query_osc,
-			 (void *)(unsigned long)flags, NULL);
-	return AE_OK;
-}
-
 /**
  * pci_osc_control_set - commit requested control to Firmware
  * @handle: acpi_handle for the target ACPI object

commit 990a7ac5645883a833a11b900bb6f25b65dea65b
Author: Andrew Patterson <andrew.patterson@hp.com>
Date:   Mon Nov 10 15:30:45 2008 -0700

    ACPI/PCI: call _OSC support during root bridge discovery
    
    Add pci_acpi_osc_support() and call it when a PCI bridge is added.  This
    allows us to avoid having every individual PCI root bridge driver call
    _OSC support for every root bridge in their probe functions, a
    significant savings in boot time.
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 2ed3f10d0860..8a1f02c3c915 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -143,28 +143,42 @@ static acpi_status __acpi_query_osc(u32 flags, struct acpi_osc_data *osc_data,
 	return status;
 }
 
-static acpi_status acpi_query_osc(acpi_handle handle,
-				  u32 level, void *context, void **retval)
+/*
+ * pci_acpi_osc_support: Invoke _OSC indicating support for the given feature
+ * @flags: Bitmask of flags to support
+ *
+ * See the ACPI spec for the definition of the flags
+ */
+int pci_acpi_osc_support(acpi_handle handle, u32 flags)
 {
+	u32 dummy;
 	acpi_status status;
-	struct acpi_osc_data *osc_data;
-	u32 flags = (unsigned long)context, dummy;
 	acpi_handle tmp;
+	struct acpi_osc_data *osc_data;
+	int rc = 0;
 
 	status = acpi_get_handle(handle, "_OSC", &tmp);
 	if (ACPI_FAILURE(status))
-		return AE_OK;
+		return -ENOTTY;
 
 	mutex_lock(&pci_acpi_lock);
 	osc_data = acpi_get_osc_data(handle);
 	if (!osc_data) {
 		printk(KERN_ERR "acpi osc data array is full\n");
+		rc = -ENOMEM;
 		goto out;
 	}
 
 	__acpi_query_osc(flags, osc_data, &dummy);
 out:
 	mutex_unlock(&pci_acpi_lock);
+	return rc;
+}
+
+static acpi_status acpi_query_osc(acpi_handle handle, u32 level,
+				  void *context, void **retval)
+{
+	pci_acpi_osc_support(handle, (unsigned long)context);
 	return AE_OK;
 }
 

commit 1a9271331ab663f3c7cda78d86b884f2ea86d4d7
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Thu Oct 30 02:17:49 2008 +0100

    PCI: struct device - replace bus_id with dev_name(), dev_set_name()
    
    This patch is part of a larger patch series which will remove
    the "char bus_id[20]" name string from struct device. The device
    name is managed in the kobject anyway, and without any size
    limitation, and just needlessly copied into "struct device".
    
    To set and read the device name dev_name(dev) and dev_set_name(dev)
    must be used. If your code uses static kobjects, which it shouldn't
    do, "const char *init_name" can be used to statically provide the
    name the registered device should have. At registration time, the
    init_name field is cleared, to enforce the use of dev_name(dev) to
    access the device name at a later time.
    
    We need to get rid of all occurrences of bus_id in the entire tree
    to be able to enable the new interface. Please apply this patch,
    and possibly convert any remaining remaining occurrences of bus_id.
    
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-Off-By: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index ae5ec76dca77..2ed3f10d0860 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -375,7 +375,7 @@ static int acpi_pci_find_root_bridge(struct device *dev, acpi_handle *handle)
 	 * The string should be the same as root bridge's name
 	 * Please look at 'pci_scan_bus_parented'
 	 */
-	num = sscanf(dev->bus_id, "pci%04x:%02x", &seg, &bus);
+	num = sscanf(dev_name(dev), "pci%04x:%02x", &seg, &bus);
 	if (num != 2)
 		return -ENODEV;
 	*handle = acpi_get_pci_rootbridge_handle(seg, bus);

commit ea7e96e0f2277107d9ea14c3f16c86ba82b2e560
Author: Lin Ming <ming.m.lin@intel.com>
Date:   Tue Dec 16 16:28:17 2008 +0800

    ACPI: remove private acpica headers from driver files
    
    External driver files should not include any private acpica headers.
    
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index ae5ec76dca77..9d976d51d406 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -13,8 +13,6 @@
 #include <linux/module.h>
 #include <linux/pci-aspm.h>
 #include <acpi/acpi.h>
-#include <acpi/acnamesp.h>
-#include <acpi/acresrc.h>
 #include <acpi/acpi_bus.h>
 
 #include <linux/pci-acpi.h>

commit 2485b8674bf5762822e14e1554938e36511c0ae4
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Mon Nov 10 13:54:43 2008 +0900

    PCI: ignore bit0 of _OSC return code
    
    Currently acpi_run_osc() checks all the bits in _OSC result code (the
    first DWORD in the capabilities buffer) to see error condition. But the
    bit 0, which doesn't indicate any error, must be ignored.
    
    The bit 0 is used as the query flag at _OSC invocation time. Some
    platforms clear it during _OSC evaluation, but the others don't. On
    latter platforms, current acpi_run_osc() mis-detects error when _OSC is
    evaluated with query flag set because it doesn't ignore the bit 0.
    Because of this, the __acpi_query_osc() always fails on such platforms.
    
    And this is the cause of the problem that pci_osc_control_set() doesn't
    work since the commit 4e39432f4df544d3dfe4fc90a22d87de64d15815 which
    changed pci_osc_control_set() to use __acpi_query_osc().
    
    Tested-by:"Tomasz Czernecki <czernecki@gmail.com>
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index b3a63edb6901..ae5ec76dca77 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -63,7 +63,7 @@ static acpi_status acpi_run_osc(acpi_handle handle,
 	union acpi_object in_params[4];
 	struct acpi_buffer output = {ACPI_ALLOCATE_BUFFER, NULL};
 	union acpi_object *out_obj;
-	u32 osc_dw0, flags = osc_args->capbuf[OSC_QUERY_TYPE];
+	u32 errors, flags = osc_args->capbuf[OSC_QUERY_TYPE];
 
 	/* Setting up input parameters */
 	input.count = 4;
@@ -92,15 +92,16 @@ static acpi_status acpi_run_osc(acpi_handle handle,
 		status = AE_TYPE;
 		goto out_kfree;
 	}
-	osc_dw0 = *((u32 *)out_obj->buffer.pointer);
-	if (osc_dw0) {
-		if (osc_dw0 & OSC_REQUEST_ERROR)
+	/* Need to ignore the bit0 in result code */
+	errors = *((u32 *)out_obj->buffer.pointer) & ~(1 << 0);
+	if (errors) {
+		if (errors & OSC_REQUEST_ERROR)
 			printk(KERN_DEBUG "_OSC request fails\n"); 
-		if (osc_dw0 & OSC_INVALID_UUID_ERROR)
+		if (errors & OSC_INVALID_UUID_ERROR)
 			printk(KERN_DEBUG "_OSC invalid UUID\n"); 
-		if (osc_dw0 & OSC_INVALID_REVISION_ERROR)
+		if (errors & OSC_INVALID_REVISION_ERROR)
 			printk(KERN_DEBUG "_OSC invalid revision\n"); 
-		if (osc_dw0 & OSC_CAPABILITIES_MASK_ERROR) {
+		if (errors & OSC_CAPABILITIES_MASK_ERROR) {
 			if (flags & OSC_QUERY_ENABLE)
 				goto out_success;
 			printk(KERN_DEBUG "_OSC FW not grant req. control\n");

commit f8123381bae8d581d81f24b55719db3d9a6a262c
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri Oct 24 21:50:31 2008 +0200

    ACPI: Oops in ACPI with git latest
    
    ACPI Warning (nseval-0168): Insufficient arguments - method [_OSC] needs 5, found 4 [20080926]
    ACPI Warning (nspredef-0252): \_SB_.PCI0._OSC: Parameter count mismatch - ASL declared 5, expected 4 [20080926]
    ACPI Error (nspredef-0163): \_SB_.PCI0._OSC: Missing expected return value [20080926]
    BUG: unable to handle kernel NULL pointer dereference at 00000000
    IP: [<c0237671>] acpi_run_osc+0xa1/0x170
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Tested-by: James Bottomley <James.Bottomley@HansenPartnership.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index dfe7c8e1b185..b3a63edb6901 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -83,6 +83,9 @@ static acpi_status acpi_run_osc(acpi_handle handle,
 	if (ACPI_FAILURE(status))
 		return status;
 
+	if (!output.length)
+		return AE_NULL_OBJECT;
+
 	out_obj = output.pointer;
 	if (out_obj->type != ACPI_TYPE_BUFFER) {
 		printk(KERN_DEBUG "Evaluate _OSC returns wrong type\n");

commit ab20440c376ff0454cb93904a888212d874fbb6b
Author: Taku Izumi <izumi.taku@jp.fujitsu.com>
Date:   Fri Oct 17 13:51:53 2008 +0900

    ACPI/PCI: Fix return value of acpi_cuery_osc()
    
    If acpi_query_osc() returns other than AE_OK, __pci_osc_support_set()
    stops scanning ACPI objects to evaluate _OSC. This prevents subsequent
    _OSCs from being evaluated if some of root bridge doesn't have _OSC, for
    example. So acpi_query_osc() should return always AE_OK to evaluate all
    _OSC.
    
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Taku Izumi <izumi.taku@jp.fujitsu.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 981919d163a0..dfe7c8e1b185 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -149,20 +149,19 @@ static acpi_status acpi_query_osc(acpi_handle handle,
 
 	status = acpi_get_handle(handle, "_OSC", &tmp);
 	if (ACPI_FAILURE(status))
-		return status;
+		return AE_OK;
 
 	mutex_lock(&pci_acpi_lock);
 	osc_data = acpi_get_osc_data(handle);
 	if (!osc_data) {
 		printk(KERN_ERR "acpi osc data array is full\n");
-		status = AE_ERROR;
 		goto out;
 	}
 
-	status = __acpi_query_osc(flags, osc_data, &dummy);
+	__acpi_query_osc(flags, osc_data, &dummy);
 out:
 	mutex_unlock(&pci_acpi_lock);
-	return status;
+	return AE_OK;
 }
 
 /**

commit adf411b819adc9fa96e9b3e638c7480d5e71d270
Author: Taku Izumi <izumi.taku@jp.fujitsu.com>
Date:   Fri Oct 17 13:51:00 2008 +0900

    ACPI/PCI: Always query _OSC control field in pci_osc_control_set()
    
    In current pci_osc_control_set() implementation, once the _OSC control
    field is queried, it is never queried again. But the query result can
    change depending on the _OSC support field. For example, if PCI Express
    Native Hot Plug control depends on ASPM support on a certain platform, a
    PCI Express Native Hot Plug Control query would fail before the ASPM
    driver was loaded, but it would succeed if the ASPM driver was loaded
    first.  Therefore, pci_osc_control_set() should query the _OSC control
    field every time.
    
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Taku Izumi <izumi.taku@jp.fujitsu.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 7d33fc0ec2fc..981919d163a0 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -24,15 +24,13 @@ struct acpi_osc_data {
 	acpi_handle handle;
 	u32 support_set;
 	u32 control_set;
-	int is_queried;
-	u32 query_result;
 	struct list_head sibiling;
 };
 static LIST_HEAD(acpi_osc_data_list);
 
 struct acpi_osc_args {
 	u32 capbuf[3];
-	u32 query_result;
+	u32 ctrl_result;
 };
 
 static DEFINE_MUTEX(pci_acpi_lock);
@@ -110,9 +108,8 @@ static acpi_status acpi_run_osc(acpi_handle handle,
 		goto out_kfree;
 	}
 out_success:
-	if (flags & OSC_QUERY_ENABLE)
-		osc_args->query_result =
-			*((u32 *)(out_obj->buffer.pointer + 8));
+	osc_args->ctrl_result =
+		*((u32 *)(out_obj->buffer.pointer + 8));
 	status = AE_OK;
 
 out_kfree:
@@ -120,7 +117,8 @@ static acpi_status acpi_run_osc(acpi_handle handle,
 	return status;
 }
 
-static acpi_status __acpi_query_osc(u32 flags, struct acpi_osc_data *osc_data)
+static acpi_status __acpi_query_osc(u32 flags, struct acpi_osc_data *osc_data,
+				    u32 *result)
 {
 	acpi_status status;
 	u32 support_set;
@@ -135,8 +133,7 @@ static acpi_status __acpi_query_osc(u32 flags, struct acpi_osc_data *osc_data)
 	status = acpi_run_osc(osc_data->handle, &osc_args);
 	if (ACPI_SUCCESS(status)) {
 		osc_data->support_set = support_set;
-		osc_data->query_result = osc_args.query_result;
-		osc_data->is_queried = 1;
+		*result = osc_args.ctrl_result;
 	}
 
 	return status;
@@ -147,7 +144,7 @@ static acpi_status acpi_query_osc(acpi_handle handle,
 {
 	acpi_status status;
 	struct acpi_osc_data *osc_data;
-	u32 flags = (unsigned long)context;
+	u32 flags = (unsigned long)context, dummy;
 	acpi_handle tmp;
 
 	status = acpi_get_handle(handle, "_OSC", &tmp);
@@ -162,7 +159,7 @@ static acpi_status acpi_query_osc(acpi_handle handle,
 		goto out;
 	}
 
-	status = __acpi_query_osc(flags, osc_data);
+	status = __acpi_query_osc(flags, osc_data, &dummy);
 out:
 	mutex_unlock(&pci_acpi_lock);
 	return status;
@@ -196,7 +193,7 @@ acpi_status __pci_osc_support_set(u32 flags, const char *hid)
 acpi_status pci_osc_control_set(acpi_handle handle, u32 flags)
 {
 	acpi_status status;
-	u32 ctrlset, control_set;
+	u32 ctrlset, control_set, result;
 	acpi_handle tmp;
 	struct acpi_osc_data *osc_data;
 	struct acpi_osc_args osc_args;
@@ -219,13 +216,11 @@ acpi_status pci_osc_control_set(acpi_handle handle, u32 flags)
 		goto out;
 	}
 
-	if (!osc_data->is_queried) {
-		status = __acpi_query_osc(osc_data->support_set, osc_data);
-		if (ACPI_FAILURE(status))
-			goto out;
-	}
+	status = __acpi_query_osc(osc_data->support_set, osc_data, &result);
+	if (ACPI_FAILURE(status))
+		goto out;
 
-	if ((osc_data->query_result & ctrlset) != ctrlset) {
+	if ((result & ctrlset) != ctrlset) {
 		status = AE_SUPPORT;
 		goto out;
 	}

commit 4e39432f4df544d3dfe4fc90a22d87de64d15815
Author: Taku Izumi <izumi.taku@jp.fujitsu.com>
Date:   Fri Oct 17 13:49:46 2008 +0900

    ACPI/PCI: Change pci_osc_control_set() to query control bits first
    
    Current pci_osc_control_set() evaluates _OSC without query for control
    bits, unless __pci_osc_support_set() is called beforehand. But as
    strongly recommended in PCI firmware specification, it should query
    control bits first.
    
    This patch changes pci_osc_control_set() to query control bits first
    even if __pci_osc_support_set() is not called beforehand.
    
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Taku Izumi <izumi.taku@jp.fujitsu.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 14848bf95e82..7d33fc0ec2fc 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -120,14 +120,35 @@ static acpi_status acpi_run_osc(acpi_handle handle,
 	return status;
 }
 
+static acpi_status __acpi_query_osc(u32 flags, struct acpi_osc_data *osc_data)
+{
+	acpi_status status;
+	u32 support_set;
+	struct acpi_osc_args osc_args;
+
+	/* do _OSC query for all possible controls */
+	support_set = osc_data->support_set | (flags & OSC_SUPPORT_MASKS);
+	osc_args.capbuf[OSC_QUERY_TYPE] = OSC_QUERY_ENABLE;
+	osc_args.capbuf[OSC_SUPPORT_TYPE] = support_set;
+	osc_args.capbuf[OSC_CONTROL_TYPE] = OSC_CONTROL_MASKS;
+
+	status = acpi_run_osc(osc_data->handle, &osc_args);
+	if (ACPI_SUCCESS(status)) {
+		osc_data->support_set = support_set;
+		osc_data->query_result = osc_args.query_result;
+		osc_data->is_queried = 1;
+	}
+
+	return status;
+}
+
 static acpi_status acpi_query_osc(acpi_handle handle,
 				  u32 level, void *context, void **retval)
 {
 	acpi_status status;
 	struct acpi_osc_data *osc_data;
-	u32 flags = (unsigned long)context, support_set;
+	u32 flags = (unsigned long)context;
 	acpi_handle tmp;
-	struct acpi_osc_args osc_args;
 
 	status = acpi_get_handle(handle, "_OSC", &tmp);
 	if (ACPI_FAILURE(status))
@@ -141,18 +162,7 @@ static acpi_status acpi_query_osc(acpi_handle handle,
 		goto out;
 	}
 
-	/* do _OSC query for all possible controls */
-	support_set = osc_data->support_set | (flags & OSC_SUPPORT_MASKS);
-	osc_args.capbuf[OSC_QUERY_TYPE] = OSC_QUERY_ENABLE;
-	osc_args.capbuf[OSC_SUPPORT_TYPE] = support_set;
-	osc_args.capbuf[OSC_CONTROL_TYPE] = OSC_CONTROL_MASKS;
-
-	status = acpi_run_osc(handle, &osc_args);
-	if (ACPI_SUCCESS(status)) {
-		osc_data->support_set = support_set;
-		osc_data->query_result = osc_args.query_result;
-		osc_data->is_queried = 1;
-	}
+	status = __acpi_query_osc(flags, osc_data);
 out:
 	mutex_unlock(&pci_acpi_lock);
 	return status;
@@ -209,8 +219,13 @@ acpi_status pci_osc_control_set(acpi_handle handle, u32 flags)
 		goto out;
 	}
 
-	if (osc_data->is_queried &&
-	    ((osc_data->query_result & ctrlset) != ctrlset)) {
+	if (!osc_data->is_queried) {
+		status = __acpi_query_osc(osc_data->support_set, osc_data);
+		if (ACPI_FAILURE(status))
+			goto out;
+	}
+
+	if ((osc_data->query_result & ctrlset) != ctrlset) {
 		status = AE_SUPPORT;
 		goto out;
 	}

commit 9778c14b4ca2c81e437fc2fd2b1f3d676937db27
Author: Taku Izumi <izumi.taku@jp.fujitsu.com>
Date:   Fri Oct 17 13:48:36 2008 +0900

    ACPI/PCI: Fix possible race condition on _OSC evaluation
    
    Fix possible race condition on _OSC evaluation.
    
    Current _OSC evaluation code has possible race condition because it
    maniputes osc_data linked list or its contents without any lock
    mechanism.
    
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Taku Izumi <izumi.taku@jp.fujitsu.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 89a2f0fa10f9..14848bf95e82 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -35,6 +35,8 @@ struct acpi_osc_args {
 	u32 query_result;
 };
 
+static DEFINE_MUTEX(pci_acpi_lock);
+
 static struct acpi_osc_data *acpi_get_osc_data(acpi_handle handle)
 {
 	struct acpi_osc_data *data;
@@ -131,10 +133,12 @@ static acpi_status acpi_query_osc(acpi_handle handle,
 	if (ACPI_FAILURE(status))
 		return status;
 
+	mutex_lock(&pci_acpi_lock);
 	osc_data = acpi_get_osc_data(handle);
 	if (!osc_data) {
 		printk(KERN_ERR "acpi osc data array is full\n");
-		return AE_ERROR;
+		status = AE_ERROR;
+		goto out;
 	}
 
 	/* do _OSC query for all possible controls */
@@ -149,7 +153,8 @@ static acpi_status acpi_query_osc(acpi_handle handle,
 		osc_data->query_result = osc_args.query_result;
 		osc_data->is_queried = 1;
 	}
-
+out:
+	mutex_unlock(&pci_acpi_lock);
 	return status;
 }
 
@@ -190,19 +195,25 @@ acpi_status pci_osc_control_set(acpi_handle handle, u32 flags)
 	if (ACPI_FAILURE(status))
 		return status;
 
+	mutex_lock(&pci_acpi_lock);
 	osc_data = acpi_get_osc_data(handle);
 	if (!osc_data) {
 		printk(KERN_ERR "acpi osc data array is full\n");
-		return AE_ERROR;
+		status = AE_ERROR;
+		goto out;
 	}
 
 	ctrlset = (flags & OSC_CONTROL_MASKS);
-	if (!ctrlset)
-		return AE_TYPE;
+	if (!ctrlset) {
+		status = AE_TYPE;
+		goto out;
+	}
 
 	if (osc_data->is_queried &&
-	    ((osc_data->query_result & ctrlset) != ctrlset))
-		return AE_SUPPORT;
+	    ((osc_data->query_result & ctrlset) != ctrlset)) {
+		status = AE_SUPPORT;
+		goto out;
+	}
 
 	control_set = osc_data->control_set | ctrlset;
 	osc_args.capbuf[OSC_QUERY_TYPE] = 0;
@@ -211,7 +222,8 @@ acpi_status pci_osc_control_set(acpi_handle handle, u32 flags)
 	status = acpi_run_osc(handle, &osc_args);
 	if (ACPI_SUCCESS(status))
 		osc_data->control_set = control_set;
-
+out:
+	mutex_unlock(&pci_acpi_lock);
 	return status;
 }
 EXPORT_SYMBOL(pci_osc_control_set);

commit 5fde244d39b88625ac578d83e6625138714de031
Author: Shaohua Li <shaohua.li@intel.com>
Date:   Wed Jul 23 10:32:24 2008 +0800

    PCI: disable ASPM per ACPI FADT setting
    
    The ACPI FADT table includes an ASPM control bit. If the bit is set, do
    not enable ASPM since it may indicate that the platform doesn't actually
    support the feature.
    
    Tested-by: Jack Howarth <howarth@bromo.msbb.uc.edu>
    Signed-off-by: Shaohua Li <shaohua.li@intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 7764768b6a0e..89a2f0fa10f9 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -11,6 +11,7 @@
 #include <linux/init.h>
 #include <linux/pci.h>
 #include <linux/module.h>
+#include <linux/pci-aspm.h>
 #include <acpi/acpi.h>
 #include <acpi/acnamesp.h>
 #include <acpi/acresrc.h>
@@ -372,6 +373,12 @@ static int __init acpi_pci_init(void)
 		printk(KERN_INFO"ACPI FADT declares the system doesn't support MSI, so disable it\n");
 		pci_no_msi();
 	}
+
+	if (acpi_gbl_FADT.boot_flags & BAF_PCIE_ASPM_CONTROL) {
+		printk(KERN_INFO"ACPI FADT declares the system doesn't support PCIe ASPM, so disable it\n");
+		pcie_no_aspm();
+	}
+
 	ret = register_acpi_bus_type(&acpi_pci_bus);
 	if (ret)
 		return 0;

commit eb9d0fe40e313c0a74115ef456a2e43a6c8da72f
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Jul 7 03:34:48 2008 +0200

    PCI ACPI: Rework PCI handling of wake-up
    
    * Introduce function acpi_pm_device_sleep_wake() for enabling and
      disabling the system wake-up capability of devices that are power
      manageable by ACPI.
    
    * Introduce function acpi_bus_can_wakeup() allowing other (dependent)
      subsystems to check if ACPI is able to enable the system wake-up
      capability of given device.
    
    * Introduce callback .sleep_wake() in struct pci_platform_pm_ops and
      for the ACPI PCI 'driver' make it use acpi_pm_device_sleep_wake().
    
    * Introduce callback .can_wakeup() in struct pci_platform_pm_ops and
      for the ACPI 'driver' make it use acpi_bus_can_wakeup().
    
    * Move the PME# handlig code out of pci_enable_wake() and split it
      into two functions, pci_pme_capable() and pci_pme_active(),
      allowing the caller to check if given device is capable of
      generating PME# from given power state and to enable/disable the
      device's PME# functionality, respectively.
    
    * Modify pci_enable_wake() to use the new ACPI callbacks and the new
      PME#-related functions.
    
    * Drop the generic .platform_enable_wakeup() callback that is not
      used any more.
    
    * Introduce device_set_wakeup_capable() that will set the
      power.can_wakeup flag of given device.
    
    * Rework PCI device PM initialization so that, if given device is
      capable of generating wake-up events, either natively through the
      PME# mechanism, or with the help of the platform, its
      power.can_wakeup flag is set and its power.should_wakeup flag is
      unset as appropriate.
    
    * Make ACPI set the power.can_wakeup flag for devices found to be
      wake-up capable by it.
    
    * Make the ACPI wake-up code enable/disable GPEs for devices that
      have the wakeup.flags.prepared flag set (which means that their
      wake-up power has been enabled).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 6bc0d8c870af..7764768b6a0e 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -299,10 +299,30 @@ static int acpi_pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 	return error;
 }
 
+static bool acpi_pci_can_wakeup(struct pci_dev *dev)
+{
+	acpi_handle handle = DEVICE_ACPI_HANDLE(&dev->dev);
+
+	return handle ? acpi_bus_can_wakeup(handle) : false;
+}
+
+static int acpi_pci_sleep_wake(struct pci_dev *dev, bool enable)
+{
+	int error = acpi_pm_device_sleep_wake(&dev->dev, enable);
+
+	if (!error)
+		dev_printk(KERN_INFO, &dev->dev,
+				"wake-up capability %s by ACPI\n",
+				enable ? "enabled" : "disabled");
+	return error;
+}
+
 static struct pci_platform_pm_ops acpi_pci_platform_pm = {
 	.is_manageable = acpi_pci_power_manageable,
 	.set_state = acpi_pci_set_power_state,
 	.choose_state = acpi_pci_choose_state,
+	.can_wakeup = acpi_pci_can_wakeup,
+	.sleep_wake = acpi_pci_sleep_wake,
 };
 
 /* ACPI bus type */

commit 44e4e66eeae5338b3ca0b28f8352e60bf18d5ba8
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Jul 7 03:32:52 2008 +0200

    PCI: rework pci_set_power_state function to call platform first
    
    Rework pci_set_power_state() so that the platform callback is
    invoked before the native mechanism, if necessary.  Also, make
    the function check if the device is power manageable by the
    platform before invoking the platform callback.
    
    This may matter if the device dependent on additional power
    resources controlled by the platform is being put into D0, in which
    case those power resources must be turned on before we attempt to
    handle the device itself.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@suse.cz>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index e4df71ab79b3..6bc0d8c870af 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -277,12 +277,11 @@ static int acpi_pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 		[PCI_D3hot] = ACPI_STATE_D3,
 		[PCI_D3cold] = ACPI_STATE_D3
 	};
+	int error = -EINVAL;
 
-	if (!handle)
-		return -ENODEV;
 	/* If the ACPI device has _EJ0, ignore the device */
-	if (ACPI_SUCCESS(acpi_get_handle(handle, "_EJ0", &tmp)))
-		return 0;
+	if (!handle || ACPI_SUCCESS(acpi_get_handle(handle, "_EJ0", &tmp)))
+		return -ENODEV;
 
 	switch (state) {
 	case PCI_D0:
@@ -290,9 +289,14 @@ static int acpi_pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 	case PCI_D2:
 	case PCI_D3hot:
 	case PCI_D3cold:
-		return acpi_bus_set_power(handle, state_conv[state]);
+		error = acpi_bus_set_power(handle, state_conv[state]);
 	}
-	return -EINVAL;
+
+	if (!error)
+		dev_printk(KERN_INFO, &dev->dev,
+				"power state changed by ACPI to D%d\n", state);
+
+	return error;
 }
 
 static struct pci_platform_pm_ops acpi_pci_platform_pm = {

commit 961d9120fa6f078492a1c762dd91f2c097e56c83
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Jul 7 03:32:02 2008 +0200

    PCI: Introduce platform_pci_power_manageable function
    
    Introduce function pointer platform_pci_power_manageable to be used
    by the platform-related code to point to a function allowing us to
    check if given device is power manageable by the platform.
    
    Introduce acpi_pci_power_manageable() playing that role for ACPI.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 056ea80ee27a..e4df71ab79b3 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -215,7 +215,6 @@ acpi_status pci_osc_control_set(acpi_handle handle, u32 flags)
 }
 EXPORT_SYMBOL(pci_osc_control_set);
 
-#ifdef CONFIG_ACPI_SLEEP
 /*
  * _SxD returns the D-state with the highest power
  * (lowest D-state number) supported in the S-state "x".
@@ -259,7 +258,13 @@ static pci_power_t acpi_pci_choose_state(struct pci_dev *pdev)
 	}
 	return PCI_POWER_ERROR;
 }
-#endif
+
+static bool acpi_pci_power_manageable(struct pci_dev *dev)
+{
+	acpi_handle handle = DEVICE_ACPI_HANDLE(&dev->dev);
+
+	return handle ? acpi_bus_power_manageable(handle) : false;
+}
 
 static int acpi_pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 {
@@ -290,6 +295,11 @@ static int acpi_pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 	return -EINVAL;
 }
 
+static struct pci_platform_pm_ops acpi_pci_platform_pm = {
+	.is_manageable = acpi_pci_power_manageable,
+	.set_state = acpi_pci_set_power_state,
+	.choose_state = acpi_pci_choose_state,
+};
 
 /* ACPI bus type */
 static int acpi_pci_find_device(struct device *dev, acpi_handle *handle)
@@ -341,10 +351,7 @@ static int __init acpi_pci_init(void)
 	ret = register_acpi_bus_type(&acpi_pci_bus);
 	if (ret)
 		return 0;
-#ifdef	CONFIG_ACPI_SLEEP
-	platform_pci_choose_state = acpi_pci_choose_state;
-#endif
-	platform_pci_set_power_state = acpi_pci_set_power_state;
+	pci_set_platform_pm(&acpi_pci_platform_pm);
 	return 0;
 }
 arch_initcall(acpi_pci_init);

commit 53eb2fbeb9e68e1a9a23945de8450999c46270ce
Merge: 8344b568f5bd 0e6859d49ff1
Author: Jesse Barnes <jbarnes@hobbes.lan>
Date:   Thu Jun 12 12:06:58 2008 -0700

    Merge branch 'suspend' of git://git.kernel.org/pub/scm/linux/kernel/git/lenb/linux-acpi-2.6 into linux-next

commit 8d2bdf49481b27096e242119e73abe9348c1019b
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Jun 5 01:16:37 2008 +0200

    PCI ACPI: Drop the second argument of platform_pci_choose_state
    
    Since the second argument of acpi_pci_choose_state() and
    platform_pci_choose_state() is never used, remove it.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@suse.cz>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index caabf0573c3d..dab9d471914c 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -293,8 +293,7 @@ EXPORT_SYMBOL(pci_osc_control_set);
  * 	choose highest power _SxD or any lower power
  */
 
-static pci_power_t acpi_pci_choose_state(struct pci_dev *pdev,
-	pm_message_t state)
+static pci_power_t acpi_pci_choose_state(struct pci_dev *pdev)
 {
 	int acpi_state;
 

commit 06166780eb53685e72b589814d535d1f9948e761
Author: David Brownell <dbrownell@users.sourceforge.net>
Date:   Thu Jun 5 01:15:40 2008 +0200

    ACPI PM: acpi_pm_device_sleep_state() cleanup
    
    Get rid of a superfluous acpi_pm_device_sleep_state() parameter.  The
    only legitimate value of that parameter must be derived from the first
    parameter, which is what all the callers already do.  (However, this
    does not address the fact that ACPI still doesn't set up those flags.)
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 9d6fc8e6285d..caabf0573c3d 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -298,8 +298,7 @@ static pci_power_t acpi_pci_choose_state(struct pci_dev *pdev,
 {
 	int acpi_state;
 
-	acpi_state = acpi_pm_device_sleep_state(&pdev->dev,
-		device_may_wakeup(&pdev->dev), NULL);
+	acpi_state = acpi_pm_device_sleep_state(&pdev->dev, NULL);
 	if (acpi_state < 0)
 		return PCI_POWER_ERROR;
 

commit 90a57dab6a2bce7f2ef186fe2d07a84d14a2a625
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Thu May 15 15:23:13 2008 +0900

    pci-acpi: formatting cleanups for _OSC
    
    Minor cleanup in pci-acpi.c.
    
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Acked-by: Shaohua Li <shaohua.li@intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 3f279990cd7e..5f96b869a566 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -51,7 +51,8 @@ static struct acpi_osc_data *acpi_get_osc_data(acpi_handle handle)
 	return data;
 }
 
-static u8 OSC_UUID[16] = {0x5B, 0x4D, 0xDB, 0x33, 0xF7, 0x1F, 0x1C, 0x40, 0x96, 0x57, 0x74, 0x41, 0xC0, 0x3D, 0xD7, 0x66};
+static u8 OSC_UUID[16] = {0x5B, 0x4D, 0xDB, 0x33, 0xF7, 0x1F, 0x1C, 0x40,
+			  0x96, 0x57, 0x74, 0x41, 0xC0, 0x3D, 0xD7, 0x66};
 
 static acpi_status acpi_run_osc(acpi_handle handle,
 				struct acpi_osc_args *osc_args)
@@ -87,7 +88,7 @@ static acpi_status acpi_run_osc(acpi_handle handle,
 		status = AE_TYPE;
 		goto out_kfree;
 	}
-	osc_dw0 = *((u32 *) out_obj->buffer.pointer);
+	osc_dw0 = *((u32 *)out_obj->buffer.pointer);
 	if (osc_dw0) {
 		if (osc_dw0 & OSC_REQUEST_ERROR)
 			printk(KERN_DEBUG "_OSC request fails\n"); 

commit c155062d6ebed676f62761f90c62894a97816932
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Thu May 15 15:22:35 2008 +0900

    pci-acpi: remove unused variable in __pci_osc_support_set
    
    The 'retval' variable in __pci_osc_support_set() is no longer
    used. Remove this unused variable.
    
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Acked-by: Shaohua Li <shaohua.li@intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 951021838055..3f279990cd7e 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -120,7 +120,6 @@ static acpi_status acpi_query_osc(acpi_handle handle,
 				  u32 level, void *context, void **retval)
 {
 	acpi_status status;
-	acpi_status *ret_status = (acpi_status *)retval;
 	struct acpi_osc_data *osc_data;
 	u32 flags = (unsigned long)context, support_set;
 	acpi_handle tmp;
@@ -143,8 +142,6 @@ static acpi_status acpi_query_osc(acpi_handle handle,
 	osc_args.capbuf[OSC_CONTROL_TYPE] = OSC_CONTROL_MASKS;
 
 	status = acpi_run_osc(handle, &osc_args);
-	*ret_status = status;
-
 	if (ACPI_SUCCESS(status)) {
 		osc_data->support_set = support_set;
 		osc_data->query_result = osc_args.query_result;
@@ -164,15 +161,11 @@ static acpi_status acpi_query_osc(acpi_handle handle,
  **/
 acpi_status __pci_osc_support_set(u32 flags, const char *hid)
 {
-	acpi_status retval = AE_NOT_FOUND;
-
-	if (!(flags & OSC_SUPPORT_MASKS)) {
+	if (!(flags & OSC_SUPPORT_MASKS))
 		return AE_TYPE;
-	}
-	acpi_get_devices(hid,
-			acpi_query_osc,
-			(void *)(unsigned long)flags,
-			(void **) &retval );
+
+	acpi_get_devices(hid, acpi_query_osc,
+			 (void *)(unsigned long)flags, NULL);
 	return AE_OK;
 }
 

commit 681f7d9db58d2b6dc3c3b784d6815f86a53b6ba0
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Thu May 15 15:21:16 2008 +0900

    pci-acpi: add flag to indicate query had been done
    
    Current pci-acpi implementation checks osc_data->support_stat to see
    if control bits had been already queried. It is not good from the
    viewpoint of easy understanding. So this patch adds new 'is_queried'
    flag to indicate query had been done.
    
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Acked-by: Shaohua Li <shaohua.li@intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index b1bd6e6155a3..951021838055 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -23,6 +23,7 @@ struct acpi_osc_data {
 	acpi_handle handle;
 	u32 support_set;
 	u32 control_set;
+	int is_queried;
 	u32 query_result;
 	struct list_head sibiling;
 };
@@ -147,6 +148,7 @@ static acpi_status acpi_query_osc(acpi_handle handle,
 	if (ACPI_SUCCESS(status)) {
 		osc_data->support_set = support_set;
 		osc_data->query_result = osc_args.query_result;
+		osc_data->is_queried = 1;
 	}
 
 	return status;
@@ -203,7 +205,7 @@ acpi_status pci_osc_control_set(acpi_handle handle, u32 flags)
 	if (!ctrlset)
 		return AE_TYPE;
 
-	if (osc_data->support_set &&
+	if (osc_data->is_queried &&
 	    ((osc_data->query_result & ctrlset) != ctrlset))
 		return AE_SUPPORT;
 

commit 5e0b9947452c824d66fafe728a46312cff544a7f
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Thu May 15 15:20:11 2008 +0900

    pci-acpi: use local buffer for _OSC
    
    Current pci-acpi implementation uses array in osc_data directly to
    evaluate _OSC. It needs to save the old data and restore it if _OSC
    evaluation fails. To make it more robust, we should use local array to
    evaluate _OSC.
    
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Acked-by: Shaohua Li <shaohua.li@intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 032b3268018b..b1bd6e6155a3 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -21,12 +21,18 @@
 
 struct acpi_osc_data {
 	acpi_handle handle;
-	u32 ctrlset_buf[3];
-	u32 global_ctrlsets;
+	u32 support_set;
+	u32 control_set;
+	u32 query_result;
 	struct list_head sibiling;
 };
 static LIST_HEAD(acpi_osc_data_list);
 
+struct acpi_osc_args {
+	u32 capbuf[3];
+	u32 query_result;
+};
+
 static struct acpi_osc_data *acpi_get_osc_data(acpi_handle handle)
 {
 	struct acpi_osc_data *data;
@@ -47,14 +53,14 @@ static struct acpi_osc_data *acpi_get_osc_data(acpi_handle handle)
 static u8 OSC_UUID[16] = {0x5B, 0x4D, 0xDB, 0x33, 0xF7, 0x1F, 0x1C, 0x40, 0x96, 0x57, 0x74, 0x41, 0xC0, 0x3D, 0xD7, 0x66};
 
 static acpi_status acpi_run_osc(acpi_handle handle,
-				struct acpi_osc_data *osc_data)
+				struct acpi_osc_args *osc_args)
 {
 	acpi_status status;
 	struct acpi_object_list input;
 	union acpi_object in_params[4];
 	struct acpi_buffer output = {ACPI_ALLOCATE_BUFFER, NULL};
 	union acpi_object *out_obj;
-	u32 osc_dw0, flags = osc_data->ctrlset_buf[OSC_QUERY_TYPE];
+	u32 osc_dw0, flags = osc_args->capbuf[OSC_QUERY_TYPE];
 
 	/* Setting up input parameters */
 	input.count = 4;
@@ -68,7 +74,7 @@ static acpi_status acpi_run_osc(acpi_handle handle,
 	in_params[2].integer.value	= 3;
 	in_params[3].type		= ACPI_TYPE_BUFFER;
 	in_params[3].buffer.length 	= 12;
-	in_params[3].buffer.pointer 	= (u8 *)osc_data->ctrlset_buf;
+	in_params[3].buffer.pointer 	= (u8 *)osc_args->capbuf;
 
 	status = acpi_evaluate_object(handle, "_OSC", &input, &output);
 	if (ACPI_FAILURE(status))
@@ -99,11 +105,9 @@ static acpi_status acpi_run_osc(acpi_handle handle,
 		goto out_kfree;
 	}
 out_success:
-	if (flags & OSC_QUERY_ENABLE) {
-		/* Update Global Control Set */
-		osc_data->global_ctrlsets =
+	if (flags & OSC_QUERY_ENABLE)
+		osc_args->query_result =
 			*((u32 *)(out_obj->buffer.pointer + 8));
-	}
 	status = AE_OK;
 
 out_kfree:
@@ -117,8 +121,9 @@ static acpi_status acpi_query_osc(acpi_handle handle,
 	acpi_status status;
 	acpi_status *ret_status = (acpi_status *)retval;
 	struct acpi_osc_data *osc_data;
-	u32 flags = (unsigned long)context, temp;
+	u32 flags = (unsigned long)context, support_set;
 	acpi_handle tmp;
+	struct acpi_osc_args osc_args;
 
 	status = acpi_get_handle(handle, "_OSC", &tmp);
 	if (ACPI_FAILURE(status))
@@ -130,21 +135,18 @@ static acpi_status acpi_query_osc(acpi_handle handle,
 		return AE_ERROR;
 	}
 
-	osc_data->ctrlset_buf[OSC_SUPPORT_TYPE] |= (flags & OSC_SUPPORT_MASKS);
-
 	/* do _OSC query for all possible controls */
-	temp = osc_data->ctrlset_buf[OSC_CONTROL_TYPE];
-	osc_data->ctrlset_buf[OSC_QUERY_TYPE] = OSC_QUERY_ENABLE;
-	osc_data->ctrlset_buf[OSC_CONTROL_TYPE] = OSC_CONTROL_MASKS;
+	support_set = osc_data->support_set | (flags & OSC_SUPPORT_MASKS);
+	osc_args.capbuf[OSC_QUERY_TYPE] = OSC_QUERY_ENABLE;
+	osc_args.capbuf[OSC_SUPPORT_TYPE] = support_set;
+	osc_args.capbuf[OSC_CONTROL_TYPE] = OSC_CONTROL_MASKS;
 
-	status = acpi_run_osc(handle, osc_data);
+	status = acpi_run_osc(handle, &osc_args);
 	*ret_status = status;
 
-	osc_data->ctrlset_buf[OSC_QUERY_TYPE] = !OSC_QUERY_ENABLE;
-	osc_data->ctrlset_buf[OSC_CONTROL_TYPE] = temp;
-	if (ACPI_FAILURE(status)) {
-		/* no osc support at all */
-		osc_data->ctrlset_buf[OSC_SUPPORT_TYPE] = 0;
+	if (ACPI_SUCCESS(status)) {
+		osc_data->support_set = support_set;
+		osc_data->query_result = osc_args.query_result;
 	}
 
 	return status;
@@ -181,10 +183,11 @@ acpi_status __pci_osc_support_set(u32 flags, const char *hid)
  **/
 acpi_status pci_osc_control_set(acpi_handle handle, u32 flags)
 {
-	acpi_status	status;
-	u32		ctrlset;
+	acpi_status status;
+	u32 ctrlset, control_set;
 	acpi_handle tmp;
 	struct acpi_osc_data *osc_data;
+	struct acpi_osc_args osc_args;
 
 	status = acpi_get_handle(handle, "_OSC", &tmp);
 	if (ACPI_FAILURE(status))
@@ -197,19 +200,21 @@ acpi_status pci_osc_control_set(acpi_handle handle, u32 flags)
 	}
 
 	ctrlset = (flags & OSC_CONTROL_MASKS);
-	if (!ctrlset) {
+	if (!ctrlset)
 		return AE_TYPE;
-	}
-	if (osc_data->ctrlset_buf[OSC_SUPPORT_TYPE] &&
-		((osc_data->global_ctrlsets & ctrlset) != ctrlset)) {
+
+	if (osc_data->support_set &&
+	    ((osc_data->query_result & ctrlset) != ctrlset))
 		return AE_SUPPORT;
-	}
-	osc_data->ctrlset_buf[OSC_CONTROL_TYPE] |= ctrlset;
-	status = acpi_run_osc(handle, osc_data);
-	if (ACPI_FAILURE (status)) {
-		osc_data->ctrlset_buf[OSC_CONTROL_TYPE] &= ~ctrlset;
-	}
-	
+
+	control_set = osc_data->control_set | ctrlset;
+	osc_args.capbuf[OSC_QUERY_TYPE] = 0;
+	osc_args.capbuf[OSC_SUPPORT_TYPE] = osc_data->support_set;
+	osc_args.capbuf[OSC_CONTROL_TYPE] = control_set;
+	status = acpi_run_osc(handle, &osc_args);
+	if (ACPI_SUCCESS(status))
+		osc_data->control_set = control_set;
+
 	return status;
 }
 EXPORT_SYMBOL(pci_osc_control_set);

commit 8a7a4faf96eef8c87421be0d3f33ea036804289b
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Thu May 15 15:18:53 2008 +0900

    pci-acpi: remove duplicate code for _OSC
    
    Remove the duplicated code in acpi_query_osc() and acpi_run_osc().
    It simplifies the code very much.
    
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Acked-by: Shaohua Li <shaohua.li@intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 9d6fc8e6285d..032b3268018b 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -46,40 +46,15 @@ static struct acpi_osc_data *acpi_get_osc_data(acpi_handle handle)
 
 static u8 OSC_UUID[16] = {0x5B, 0x4D, 0xDB, 0x33, 0xF7, 0x1F, 0x1C, 0x40, 0x96, 0x57, 0x74, 0x41, 0xC0, 0x3D, 0xD7, 0x66};
 
-static acpi_status  
-acpi_query_osc (
-	acpi_handle	handle,
-	u32		level,
-	void		*context,
-	void		**retval )
+static acpi_status acpi_run_osc(acpi_handle handle,
+				struct acpi_osc_data *osc_data)
 {
-	acpi_status		status;
-	struct acpi_object_list	input;
-	union acpi_object 	in_params[4];
-	struct acpi_buffer	output = {ACPI_ALLOCATE_BUFFER, NULL};
-	union acpi_object 	*out_obj;
-	u32			osc_dw0;
-	acpi_status *ret_status = (acpi_status *)retval;
-	struct acpi_osc_data *osc_data;
-	u32 flags = (unsigned long)context, temp;
-	acpi_handle tmp;
-
-	status = acpi_get_handle(handle, "_OSC", &tmp);
-	if (ACPI_FAILURE(status))
-		return status;
-
-	osc_data = acpi_get_osc_data(handle);
-	if (!osc_data) {
-		printk(KERN_ERR "acpi osc data array is full\n");
-		return AE_ERROR;
-	}
-
-	osc_data->ctrlset_buf[OSC_SUPPORT_TYPE] |= (flags & OSC_SUPPORT_MASKS);
-
-	/* do _OSC query for all possible controls */
-	temp = osc_data->ctrlset_buf[OSC_CONTROL_TYPE];
-	osc_data->ctrlset_buf[OSC_QUERY_TYPE] = OSC_QUERY_ENABLE;
-	osc_data->ctrlset_buf[OSC_CONTROL_TYPE] = OSC_CONTROL_MASKS;
+	acpi_status status;
+	struct acpi_object_list input;
+	union acpi_object in_params[4];
+	struct acpi_buffer output = {ACPI_ALLOCATE_BUFFER, NULL};
+	union acpi_object *out_obj;
+	u32 osc_dw0, flags = osc_data->ctrlset_buf[OSC_QUERY_TYPE];
 
 	/* Setting up input parameters */
 	input.count = 4;
@@ -97,14 +72,13 @@ acpi_query_osc (
 
 	status = acpi_evaluate_object(handle, "_OSC", &input, &output);
 	if (ACPI_FAILURE(status))
-		goto out_nofree;
-	out_obj = output.pointer;
+		return status;
 
+	out_obj = output.pointer;
 	if (out_obj->type != ACPI_TYPE_BUFFER) {
-		printk(KERN_DEBUG  
-			"Evaluate _OSC returns wrong type\n");
+		printk(KERN_DEBUG "Evaluate _OSC returns wrong type\n");
 		status = AE_TYPE;
-		goto query_osc_out;
+		goto out_kfree;
 	}
 	osc_dw0 = *((u32 *) out_obj->buffer.pointer);
 	if (osc_dw0) {
@@ -115,93 +89,64 @@ acpi_query_osc (
 		if (osc_dw0 & OSC_INVALID_REVISION_ERROR)
 			printk(KERN_DEBUG "_OSC invalid revision\n"); 
 		if (osc_dw0 & OSC_CAPABILITIES_MASK_ERROR) {
-			/* Update Global Control Set */
-			osc_data->global_ctrlsets =
-				*((u32 *)(out_obj->buffer.pointer + 8));
-			status = AE_OK;
-			goto query_osc_out;
+			if (flags & OSC_QUERY_ENABLE)
+				goto out_success;
+			printk(KERN_DEBUG "_OSC FW not grant req. control\n");
+			status = AE_SUPPORT;
+			goto out_kfree;
 		}
 		status = AE_ERROR;
-		goto query_osc_out;
+		goto out_kfree;
+	}
+out_success:
+	if (flags & OSC_QUERY_ENABLE) {
+		/* Update Global Control Set */
+		osc_data->global_ctrlsets =
+			*((u32 *)(out_obj->buffer.pointer + 8));
 	}
-
-	/* Update Global Control Set */
-	osc_data->global_ctrlsets = *((u32 *)(out_obj->buffer.pointer + 8));
 	status = AE_OK;
 
-query_osc_out:
+out_kfree:
 	kfree(output.pointer);
-out_nofree:
-	*ret_status = status;
-
-	osc_data->ctrlset_buf[OSC_QUERY_TYPE] = !OSC_QUERY_ENABLE;
-	osc_data->ctrlset_buf[OSC_CONTROL_TYPE] = temp;
-	if (ACPI_FAILURE(status)) {
-		/* no osc support at all */
-		osc_data->ctrlset_buf[OSC_SUPPORT_TYPE] = 0;
-	}
-
 	return status;
 }
 
-
-static acpi_status  
-acpi_run_osc (
-	acpi_handle	handle,
-	void		*context)
+static acpi_status acpi_query_osc(acpi_handle handle,
+				  u32 level, void *context, void **retval)
 {
-	acpi_status		status;
-	struct acpi_object_list	input;
-	union acpi_object 	in_params[4];
-	struct acpi_buffer	output = {ACPI_ALLOCATE_BUFFER, NULL};
-	union acpi_object 	*out_obj;
-	u32			osc_dw0;
-
-	/* Setting up input parameters */
-	input.count = 4;
-	input.pointer = in_params;
-	in_params[0].type 		= ACPI_TYPE_BUFFER;
-	in_params[0].buffer.length 	= 16;
-	in_params[0].buffer.pointer	= OSC_UUID;
-	in_params[1].type 		= ACPI_TYPE_INTEGER;
-	in_params[1].integer.value 	= 1;
-	in_params[2].type 		= ACPI_TYPE_INTEGER;
-	in_params[2].integer.value	= 3;
-	in_params[3].type		= ACPI_TYPE_BUFFER;
-	in_params[3].buffer.length 	= 12;
-	in_params[3].buffer.pointer 	= (u8 *)context;
+	acpi_status status;
+	acpi_status *ret_status = (acpi_status *)retval;
+	struct acpi_osc_data *osc_data;
+	u32 flags = (unsigned long)context, temp;
+	acpi_handle tmp;
 
-	status = acpi_evaluate_object(handle, "_OSC", &input, &output);
-	if (ACPI_FAILURE (status))
+	status = acpi_get_handle(handle, "_OSC", &tmp);
+	if (ACPI_FAILURE(status))
 		return status;
 
-	out_obj = output.pointer;
-	if (out_obj->type != ACPI_TYPE_BUFFER) {
-		printk(KERN_DEBUG  
-			"Evaluate _OSC returns wrong type\n");
-		status = AE_TYPE;
-		goto run_osc_out;
+	osc_data = acpi_get_osc_data(handle);
+	if (!osc_data) {
+		printk(KERN_ERR "acpi osc data array is full\n");
+		return AE_ERROR;
 	}
-	osc_dw0 = *((u32 *) out_obj->buffer.pointer);
-	if (osc_dw0) {
-		if (osc_dw0 & OSC_REQUEST_ERROR)
-			printk(KERN_DEBUG "_OSC request fails\n"); 
-		if (osc_dw0 & OSC_INVALID_UUID_ERROR)
-			printk(KERN_DEBUG "_OSC invalid UUID\n"); 
-		if (osc_dw0 & OSC_INVALID_REVISION_ERROR)
-			printk(KERN_DEBUG "_OSC invalid revision\n"); 
-		if (osc_dw0 & OSC_CAPABILITIES_MASK_ERROR) {
-			printk(KERN_DEBUG "_OSC FW not grant req. control\n");
-			status = AE_SUPPORT;
-			goto run_osc_out;
-		}
-		status = AE_ERROR;
-		goto run_osc_out;
+
+	osc_data->ctrlset_buf[OSC_SUPPORT_TYPE] |= (flags & OSC_SUPPORT_MASKS);
+
+	/* do _OSC query for all possible controls */
+	temp = osc_data->ctrlset_buf[OSC_CONTROL_TYPE];
+	osc_data->ctrlset_buf[OSC_QUERY_TYPE] = OSC_QUERY_ENABLE;
+	osc_data->ctrlset_buf[OSC_CONTROL_TYPE] = OSC_CONTROL_MASKS;
+
+	status = acpi_run_osc(handle, osc_data);
+	*ret_status = status;
+
+	osc_data->ctrlset_buf[OSC_QUERY_TYPE] = !OSC_QUERY_ENABLE;
+	osc_data->ctrlset_buf[OSC_CONTROL_TYPE] = temp;
+	if (ACPI_FAILURE(status)) {
+		/* no osc support at all */
+		osc_data->ctrlset_buf[OSC_SUPPORT_TYPE] = 0;
 	}
-	status = AE_OK;
 
-run_osc_out:
-	kfree(output.pointer);
 	return status;
 }
 
@@ -260,7 +205,7 @@ acpi_status pci_osc_control_set(acpi_handle handle, u32 flags)
 		return AE_SUPPORT;
 	}
 	osc_data->ctrlset_buf[OSC_CONTROL_TYPE] |= ctrlset;
-	status = acpi_run_osc(handle, osc_data->ctrlset_buf);
+	status = acpi_run_osc(handle, osc_data);
 	if (ACPI_FAILURE (status)) {
 		osc_data->ctrlset_buf[OSC_CONTROL_TYPE] &= ~ctrlset;
 	}

commit c4e5fadd2a6fc0da465dcde761877d9a87313b33
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Tue May 13 16:48:50 2008 +0900

    ACPI/PCI: another multiple _OSC memory leak fix
    
    The acpi_query_osc() function can be called for the ACPI object that
    doesn't have _OSC method. In this case, acpi_get_osc_data() would
    allocate a useless memory region. To avoid this, we need to check the
    existence of _OSC before calling acpi_get_osc_data() in acpi_query_osc().
    
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 38fc8b1ff881..9d6fc8e6285d 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -60,9 +60,15 @@ acpi_query_osc (
 	union acpi_object 	*out_obj;
 	u32			osc_dw0;
 	acpi_status *ret_status = (acpi_status *)retval;
-	struct acpi_osc_data *osc_data = acpi_get_osc_data(handle);
+	struct acpi_osc_data *osc_data;
 	u32 flags = (unsigned long)context, temp;
+	acpi_handle tmp;
 
+	status = acpi_get_handle(handle, "_OSC", &tmp);
+	if (ACPI_FAILURE(status))
+		return status;
+
+	osc_data = acpi_get_osc_data(handle);
 	if (!osc_data) {
 		printk(KERN_ERR "acpi osc data array is full\n");
 		return AE_ERROR;

commit 34a65055e5e7304b3d6ad0f7542bf66308eae50a
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Mon May 12 22:55:45 2008 +0900

    ACPI/PCI: handle multiple _OSC
    
    The pci_osc_control_set() function can be called for the ACPI object
    that doesn't have _OSC method. In this case, acpi_get_osc_data() would
    allocate a useless memory region. To avoid this, we need to check the
    existence of _OSC before calling acpi_get_osc_data(). Here is a patch
    to fix this problem in pci_osc_control_set.
    
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 468d13e1458e..38fc8b1ff881 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -232,8 +232,14 @@ acpi_status pci_osc_control_set(acpi_handle handle, u32 flags)
 {
 	acpi_status	status;
 	u32		ctrlset;
-	struct acpi_osc_data *osc_data = acpi_get_osc_data(handle);
+	acpi_handle tmp;
+	struct acpi_osc_data *osc_data;
+
+	status = acpi_get_handle(handle, "_OSC", &tmp);
+	if (ACPI_FAILURE(status))
+		return status;
 
+	osc_data = acpi_get_osc_data(handle);
 	if (!osc_data) {
 		printk(KERN_ERR "acpi osc data array is full\n");
 		return AE_ERROR;

commit a5d1c8798309a384c2776e5ff472f8ceb6d9065d
Author: Shaohua Li <shaohua.li@intel.com>
Date:   Mon May 12 10:48:10 2008 +0800

    ACPI/PCI: handle multiple _OSC
    
    There is an IA64 system here which have two pci root bridges with _OSC.
    One _OSC disables SHPC control bit but the other not. Below patch makes
    _OSC data per-device instead of one global, otherwise linux takes both
    root bridges don't support SHPC.
    
    Signed-off-by: Shaohua Li <shaohua.li@intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index ddfd756fc8ed..468d13e1458e 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -19,8 +19,31 @@
 #include <linux/pci-acpi.h>
 #include "pci.h"
 
-static u32 ctrlset_buf[3] = {0, 0, 0};
-static u32 global_ctrlsets = 0;
+struct acpi_osc_data {
+	acpi_handle handle;
+	u32 ctrlset_buf[3];
+	u32 global_ctrlsets;
+	struct list_head sibiling;
+};
+static LIST_HEAD(acpi_osc_data_list);
+
+static struct acpi_osc_data *acpi_get_osc_data(acpi_handle handle)
+{
+	struct acpi_osc_data *data;
+
+	list_for_each_entry(data, &acpi_osc_data_list, sibiling) {
+		if (data->handle == handle)
+			return data;
+	}
+	data = kzalloc(sizeof(*data), GFP_KERNEL);
+	if (!data)
+		return NULL;
+	INIT_LIST_HEAD(&data->sibiling);
+	data->handle = handle;
+	list_add_tail(&data->sibiling, &acpi_osc_data_list);
+	return data;
+}
+
 static u8 OSC_UUID[16] = {0x5B, 0x4D, 0xDB, 0x33, 0xF7, 0x1F, 0x1C, 0x40, 0x96, 0x57, 0x74, 0x41, 0xC0, 0x3D, 0xD7, 0x66};
 
 static acpi_status  
@@ -37,8 +60,21 @@ acpi_query_osc (
 	union acpi_object 	*out_obj;
 	u32			osc_dw0;
 	acpi_status *ret_status = (acpi_status *)retval;
+	struct acpi_osc_data *osc_data = acpi_get_osc_data(handle);
+	u32 flags = (unsigned long)context, temp;
+
+	if (!osc_data) {
+		printk(KERN_ERR "acpi osc data array is full\n");
+		return AE_ERROR;
+	}
+
+	osc_data->ctrlset_buf[OSC_SUPPORT_TYPE] |= (flags & OSC_SUPPORT_MASKS);
+
+	/* do _OSC query for all possible controls */
+	temp = osc_data->ctrlset_buf[OSC_CONTROL_TYPE];
+	osc_data->ctrlset_buf[OSC_QUERY_TYPE] = OSC_QUERY_ENABLE;
+	osc_data->ctrlset_buf[OSC_CONTROL_TYPE] = OSC_CONTROL_MASKS;
 
-	
 	/* Setting up input parameters */
 	input.count = 4;
 	input.pointer = in_params;
@@ -51,13 +87,11 @@ acpi_query_osc (
 	in_params[2].integer.value	= 3;
 	in_params[3].type		= ACPI_TYPE_BUFFER;
 	in_params[3].buffer.length 	= 12;
-	in_params[3].buffer.pointer 	= (u8 *)context;
+	in_params[3].buffer.pointer 	= (u8 *)osc_data->ctrlset_buf;
 
 	status = acpi_evaluate_object(handle, "_OSC", &input, &output);
-	if (ACPI_FAILURE (status)) {
-		*ret_status = status;
-		return status;
-	}
+	if (ACPI_FAILURE(status))
+		goto out_nofree;
 	out_obj = output.pointer;
 
 	if (out_obj->type != ACPI_TYPE_BUFFER) {
@@ -76,7 +110,8 @@ acpi_query_osc (
 			printk(KERN_DEBUG "_OSC invalid revision\n"); 
 		if (osc_dw0 & OSC_CAPABILITIES_MASK_ERROR) {
 			/* Update Global Control Set */
-			global_ctrlsets = *((u32 *)(out_obj->buffer.pointer+8));
+			osc_data->global_ctrlsets =
+				*((u32 *)(out_obj->buffer.pointer + 8));
 			status = AE_OK;
 			goto query_osc_out;
 		}
@@ -85,12 +120,21 @@ acpi_query_osc (
 	}
 
 	/* Update Global Control Set */
-	global_ctrlsets = *((u32 *)(out_obj->buffer.pointer + 8));
+	osc_data->global_ctrlsets = *((u32 *)(out_obj->buffer.pointer + 8));
 	status = AE_OK;
 
 query_osc_out:
 	kfree(output.pointer);
+out_nofree:
 	*ret_status = status;
+
+	osc_data->ctrlset_buf[OSC_QUERY_TYPE] = !OSC_QUERY_ENABLE;
+	osc_data->ctrlset_buf[OSC_CONTROL_TYPE] = temp;
+	if (ACPI_FAILURE(status)) {
+		/* no osc support at all */
+		osc_data->ctrlset_buf[OSC_SUPPORT_TYPE] = 0;
+	}
+
 	return status;
 }
 
@@ -165,28 +209,15 @@ acpi_run_osc (
  **/
 acpi_status __pci_osc_support_set(u32 flags, const char *hid)
 {
-	u32 temp;
 	acpi_status retval = AE_NOT_FOUND;
 
 	if (!(flags & OSC_SUPPORT_MASKS)) {
 		return AE_TYPE;
 	}
-	ctrlset_buf[OSC_SUPPORT_TYPE] |= (flags & OSC_SUPPORT_MASKS);
-
-	/* do _OSC query for all possible controls */
-	temp = ctrlset_buf[OSC_CONTROL_TYPE];
-	ctrlset_buf[OSC_QUERY_TYPE] = OSC_QUERY_ENABLE;
-	ctrlset_buf[OSC_CONTROL_TYPE] = OSC_CONTROL_MASKS;
 	acpi_get_devices(hid,
 			acpi_query_osc,
-			ctrlset_buf,
+			(void *)(unsigned long)flags,
 			(void **) &retval );
-	ctrlset_buf[OSC_QUERY_TYPE] = !OSC_QUERY_ENABLE;
-	ctrlset_buf[OSC_CONTROL_TYPE] = temp;
-	if (ACPI_FAILURE(retval)) {
-		/* no osc support at all */
-		ctrlset_buf[OSC_SUPPORT_TYPE] = 0;
-	}
 	return AE_OK;
 }
 
@@ -201,19 +232,25 @@ acpi_status pci_osc_control_set(acpi_handle handle, u32 flags)
 {
 	acpi_status	status;
 	u32		ctrlset;
+	struct acpi_osc_data *osc_data = acpi_get_osc_data(handle);
+
+	if (!osc_data) {
+		printk(KERN_ERR "acpi osc data array is full\n");
+		return AE_ERROR;
+	}
 
 	ctrlset = (flags & OSC_CONTROL_MASKS);
 	if (!ctrlset) {
 		return AE_TYPE;
 	}
-	if (ctrlset_buf[OSC_SUPPORT_TYPE] && 
-	 	((global_ctrlsets & ctrlset) != ctrlset)) {
+	if (osc_data->ctrlset_buf[OSC_SUPPORT_TYPE] &&
+		((osc_data->global_ctrlsets & ctrlset) != ctrlset)) {
 		return AE_SUPPORT;
 	}
-	ctrlset_buf[OSC_CONTROL_TYPE] |= ctrlset;
-	status = acpi_run_osc(handle, ctrlset_buf);
+	osc_data->ctrlset_buf[OSC_CONTROL_TYPE] |= ctrlset;
+	status = acpi_run_osc(handle, osc_data->ctrlset_buf);
 	if (ACPI_FAILURE (status)) {
-		ctrlset_buf[OSC_CONTROL_TYPE] &= ~ctrlset;
+		osc_data->ctrlset_buf[OSC_CONTROL_TYPE] &= ~ctrlset;
 	}
 	
 	return status;

commit 21e2b0a5efb3a01de58e7cb630f2eb70894da352
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Thu May 8 14:37:25 2008 +0900

    PCI ACPI: fix uninitialized variable in __pci_osc_support_set
    
    Fix uninitialized variable in __pci_osc_support_set().
    
    If the ACPI namespace doesn't have any device object corresponding to
    the specified hid, 'retval' in __pci_osc_support_set() is not changed
    by the acpi_query_osc() callback. Since 'retval' is not initizlized in
    the current implementation, the contents of 'retval' is undefined in
    this case. This causes a mis-handling of ctrlset_buf[OSC_SUPPORT_TYPE]
    and will cause an unexpected result in the subsequent
    pci_osc_control_set() call as a result.
    
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 72f7476930c8..ddfd756fc8ed 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -166,7 +166,7 @@ acpi_run_osc (
 acpi_status __pci_osc_support_set(u32 flags, const char *hid)
 {
 	u32 temp;
-	acpi_status retval;
+	acpi_status retval = AE_NOT_FOUND;
 
 	if (!(flags & OSC_SUPPORT_MASKS)) {
 		return AE_TYPE;

commit 583c377f1d58e705f75d8d5648ab41722be1ebca
Author: David Brownell <david-b@pacbell.net>
Date:   Fri Feb 22 21:41:51 2008 -0800

    ACPI: acpi_pci_set_power_state() cleanups
    
    Minor cleanups to acpi_pci_set_power_state():  use the ACPI and PCI
    state symbols to make clear that a mapping is being done between PCI
    and ACPI states, instead of using magic numbers.  For paranoia's sake,
    report any errors.  Save five bytes (x86_64) too.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 4a23654184fc..72f7476930c8 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -272,21 +272,29 @@ static int acpi_pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 {
 	acpi_handle handle = DEVICE_ACPI_HANDLE(&dev->dev);
 	acpi_handle tmp;
-	static int state_conv[] = {
-		[0] = 0,
-		[1] = 1,
-		[2] = 2,
-		[3] = 3,
-		[4] = 3
+	static const u8 state_conv[] = {
+		[PCI_D0] = ACPI_STATE_D0,
+		[PCI_D1] = ACPI_STATE_D1,
+		[PCI_D2] = ACPI_STATE_D2,
+		[PCI_D3hot] = ACPI_STATE_D3,
+		[PCI_D3cold] = ACPI_STATE_D3
 	};
-	int acpi_state = state_conv[(int __force) state];
 
 	if (!handle)
 		return -ENODEV;
 	/* If the ACPI device has _EJ0, ignore the device */
 	if (ACPI_SUCCESS(acpi_get_handle(handle, "_EJ0", &tmp)))
 		return 0;
-	return acpi_bus_set_power(handle, acpi_state);
+
+	switch (state) {
+	case PCI_D0:
+	case PCI_D1:
+	case PCI_D2:
+	case PCI_D3hot:
+	case PCI_D3cold:
+		return acpi_bus_set_power(handle, state_conv[state]);
+	}
+	return -EINVAL;
 }
 
 

commit 1f1519ef597ae4628dbd47244f0f68d700231523
Merge: 208c70a45624 f28bb45e2863 1186974f3ffe e85ff4b53eb4 19e20c913bae 69f6b8dd6b94 6c231bd5eb07 613311684921
Author: Len Brown <len.brown@intel.com>
Date:   Thu Feb 21 02:41:58 2008 -0500

    Merge branches 'release', 'bugzilla-9916', 'bugzilla-9982', 'bugzilla-9989', 'misc', 'suspend', 'thermal', 'thinkpad' and 'tsc' into release

commit c6868ea00bdebe5762fa59e54b74b4cd4e3b4e6e
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Feb 3 22:53:31 2008 +0100

    PCI ACPI: Fix comment describing acpi_pci_choose_state
    
    The last line of the comment preceding the definition of
    acpi_pci_choose_state() is incorrect.  Remove it.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index e569645d59e2..e818e52dc39a 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -241,8 +241,6 @@ EXPORT_SYMBOL(pci_osc_control_set);
  *	choose from highest power _SxD to lowest power _SxW
  * else // no _PRW at S-state x
  * 	choose highest power _SxD or any lower power
- *
- * currently we simply return _SxD, if present.
  */
 
 static pci_power_t acpi_pci_choose_state(struct pci_dev *pdev,

commit 5958f1a4da39581074bab50cabd0a582e651b90f
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Sun Feb 3 15:06:25 2008 -0800

    kernel-doc: fix pci-acpi warning
    
    Fix PCI kernel-doc warning:
    Warning(linux-2.6.24-git12//drivers/pci/pci-acpi.c:166): No description found for parameter 'hid'
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index e569645d59e2..2f2d308c9aa3 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -158,6 +158,7 @@ acpi_run_osc (
 /**
  * __pci_osc_support_set - register OS support to Firmware
  * @flags: OS support bits
+ * @hid: hardware ID
  *
  * Update OS support fields and doing a _OSC Query to obtain an update
  * from Firmware on supported control bits.

commit c2778357234f84668eab5558b54ad28478439d0b
Author: Andrew Patterson <andrew.patterson@hp.com>
Date:   Tue Jan 22 17:18:12 2008 -0700

    PCI ACPI: Added a function to register _OSC with only PCIe devices.
    
    The function pci_osc_support_set() traverses every root bridge when
    checking for _OSC support for a capability.  It quits as soon as it finds a
    device/bridge that doesn't support the requested capability. This won't
    work for systems that have mixed PCI and PCIe bridges when checking for
    PCIe features.  I split this function into two -- pci_osc_support_set() and
    pcie_osc_support_set(). The latter is used when only PCIe devices should be
    traversed.
    
    Signed-off-by: Andrew Patterson <andrew.patterson@hp.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 02e4876b3b2c..e569645d59e2 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -156,13 +156,13 @@ acpi_run_osc (
 }
 
 /**
- * pci_osc_support_set - register OS support to Firmware
+ * __pci_osc_support_set - register OS support to Firmware
  * @flags: OS support bits
  *
  * Update OS support fields and doing a _OSC Query to obtain an update
  * from Firmware on supported control bits.
  **/
-acpi_status pci_osc_support_set(u32 flags)
+acpi_status __pci_osc_support_set(u32 flags, const char *hid)
 {
 	u32 temp;
 	acpi_status retval;
@@ -176,7 +176,7 @@ acpi_status pci_osc_support_set(u32 flags)
 	temp = ctrlset_buf[OSC_CONTROL_TYPE];
 	ctrlset_buf[OSC_QUERY_TYPE] = OSC_QUERY_ENABLE;
 	ctrlset_buf[OSC_CONTROL_TYPE] = OSC_CONTROL_MASKS;
-	acpi_get_devices ( PCI_ROOT_HID_STRING,
+	acpi_get_devices(hid,
 			acpi_query_osc,
 			ctrlset_buf,
 			(void **) &retval );

commit eb003ec26556057e5f27d4b989bbb432d0bdc0f4
Author: Adrian Bunk <bunk@kernel.org>
Date:   Sat Oct 27 03:06:33 2007 +0200

    PCI: drivers/pci/: remove unused exports
    
    This patch removes the following unused exports:
    - remove the following unused EXPORT_SYMBOL's:
     - pci-acpi.c: pci_osc_support_set
     - proc.c: pci_proc_detach_bus
    - remove the following unused EXPORT_SYMBOL_GPL's:
      - bus.c: pci_walk_bus
      - probe.c: pci_create_bus
      - setup-res.c: pci_claim_resource
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 5c6a5d043007..02e4876b3b2c 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -188,7 +188,6 @@ acpi_status pci_osc_support_set(u32 flags)
 	}
 	return AE_OK;
 }
-EXPORT_SYMBOL(pci_osc_support_set);
 
 /**
  * pci_osc_control_set - commit requested control to Firmware

commit 673d5b43daa00b42759cecc6b0760b8bf6be80d2
Author: Len Brown <len.brown@intel.com>
Date:   Sat Jul 28 03:33:16 2007 -0400

    ACPI: restore CONFIG_ACPI_SLEEP
    
    Restore the 2.6.22 CONFIG_ACPI_SLEEP build option, but now shadowing the
    new CONFIG_PM_SLEEP option.
    
    Signed-off-by: Len Brown <len.brown@intel.com>
    [ Modified to work with the PM config setup changes. ]
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 67c63d1f1582..5c6a5d043007 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -220,6 +220,7 @@ acpi_status pci_osc_control_set(acpi_handle handle, u32 flags)
 }
 EXPORT_SYMBOL(pci_osc_control_set);
 
+#ifdef CONFIG_ACPI_SLEEP
 /*
  * _SxD returns the D-state with the highest power
  * (lowest D-state number) supported in the S-state "x".
@@ -267,6 +268,7 @@ static pci_power_t acpi_pci_choose_state(struct pci_dev *pdev,
 	}
 	return PCI_POWER_ERROR;
 }
+#endif
 
 static int acpi_pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 {
@@ -340,7 +342,9 @@ static int __init acpi_pci_init(void)
 	ret = register_acpi_bus_type(&acpi_pci_bus);
 	if (ret)
 		return 0;
+#ifdef	CONFIG_ACPI_SLEEP
 	platform_pci_choose_state = acpi_pci_choose_state;
+#endif
 	platform_pci_set_power_state = acpi_pci_set_power_state;
 	return 0;
 }

commit 10b3dcae0f275e2546e55303d64ddbb58cec7599
Author: Shaohua Li <shaohua.li@intel.com>
Date:   Fri Jul 20 10:03:25 2007 +0800

    ACPI: ignore _PSx method for hotplugable PCI devices
    
    If the ACPI device has _EJ0, ignore the device.
    _PSx will set power for the slot,
    and the hotplug driver will take care of _PSx.
    
    Signed-off-by: Shaohua Li <shaohua.li@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 5e866b94bcab..67c63d1f1582 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -271,6 +271,7 @@ static pci_power_t acpi_pci_choose_state(struct pci_dev *pdev,
 static int acpi_pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 {
 	acpi_handle handle = DEVICE_ACPI_HANDLE(&dev->dev);
+	acpi_handle tmp;
 	static int state_conv[] = {
 		[0] = 0,
 		[1] = 1,
@@ -282,6 +283,9 @@ static int acpi_pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 
 	if (!handle)
 		return -ENODEV;
+	/* If the ACPI device has _EJ0, ignore the device */
+	if (ACPI_SUCCESS(acpi_get_handle(handle, "_EJ0", &tmp)))
+		return 0;
 	return acpi_bus_set_power(handle, acpi_state);
 }
 

commit ab826ca4cf2fe8ebcfd21189ca8bfeb47ca88359
Author: Shaohua Li <shaohua.li@intel.com>
Date:   Fri Jul 20 10:03:22 2007 +0800

    ACPI: Use ACPI methods to select PCI device suspend state
    
    applied after Rafel's 'PM: Update global suspend and hibernation
    operations framework' patch set
    
    Signed-off-by: Shaohua Li<shaohua.li@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index c8062494009f..5e866b94bcab 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -245,11 +245,27 @@ EXPORT_SYMBOL(pci_osc_control_set);
  * currently we simply return _SxD, if present.
  */
 
-static int acpi_pci_choose_state(struct pci_dev *pdev, pm_message_t state)
+static pci_power_t acpi_pci_choose_state(struct pci_dev *pdev,
+	pm_message_t state)
 {
-	/* TBD */
-
-	return -ENODEV;
+	int acpi_state;
+
+	acpi_state = acpi_pm_device_sleep_state(&pdev->dev,
+		device_may_wakeup(&pdev->dev), NULL);
+	if (acpi_state < 0)
+		return PCI_POWER_ERROR;
+
+	switch (acpi_state) {
+	case ACPI_STATE_D0:
+		return PCI_D0;
+	case ACPI_STATE_D1:
+		return PCI_D1;
+	case ACPI_STATE_D2:
+		return PCI_D2;
+	case ACPI_STATE_D3:
+		return PCI_D3hot;
+	}
+	return PCI_POWER_ERROR;
 }
 
 static int acpi_pci_set_power_state(struct pci_dev *dev, pci_power_t state)

commit 8d29bfb79e632fe318f4c01c9c2e8faacb89b800
Author: Zhang, Yanmin <yanmin_zhang@linux.intel.com>
Date:   Wed Jun 6 11:44:16 2007 +0800

    PCI: fix AER driver error information
    
    Below patch fixes aer driver error information and enables aer driver
    although CONFIG_ACPI=n.
    
    As a matter of fact, the new patch is created from below 2 patches plus
    a minor patch apply fuzz fixing. Because the second patch fixed a compilation
    error introduced by the first patch, I merge them to facilitate bisect.
    
    
    1) http://marc.info/?l=linux-kernel&m=117783233918191&w=2;
    2) http://marc.info/?l=linux-mm-commits&m=118046936720790&w=2
    
    
    Signed-off-by: Zhang Yanmin <yanmin.zhang@intel.com>
    Signed-off-by: Michael Ellerman <michael@ellerman.id.au>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index b5ac810404c0..c8062494009f 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -55,8 +55,6 @@ acpi_query_osc (
 
 	status = acpi_evaluate_object(handle, "_OSC", &input, &output);
 	if (ACPI_FAILURE (status)) {
-		printk(KERN_DEBUG  
-			"Evaluate _OSC Set fails. Status = 0x%04x\n", status);
 		*ret_status = status;
 		return status;
 	}
@@ -124,11 +122,9 @@ acpi_run_osc (
 	in_params[3].buffer.pointer 	= (u8 *)context;
 
 	status = acpi_evaluate_object(handle, "_OSC", &input, &output);
-	if (ACPI_FAILURE (status)) {
-		printk(KERN_DEBUG  
-			"Evaluate _OSC Set fails. Status = 0x%04x\n", status);
+	if (ACPI_FAILURE (status))
 		return status;
-	}
+
 	out_obj = output.pointer;
 	if (out_obj->type != ACPI_TYPE_BUFFER) {
 		printk(KERN_DEBUG  

commit f8993aff8b4de0317c6e081802ca5c86c449fef2
Author: Shaohua Li <shaohua.li@intel.com>
Date:   Wed Apr 25 11:05:12 2007 +0800

    ACPI: Disable MSI on request of FADT
    
    The ACPI spec defines the bit and Microsoft uses it,
    so Linux must use it too.
    
    Signed-off-by: Shaohua Li <shaohua.li@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index a064f36a0805..b5ac810404c0 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -317,6 +317,10 @@ static int __init acpi_pci_init(void)
 {
 	int ret;
 
+	if (acpi_gbl_FADT.boot_flags & BAF_MSI_NOT_SUPPORTED) {
+		printk(KERN_INFO"ACPI FADT declares the system doesn't support MSI, so disable it\n");
+		pci_no_msi();
+	}
 	ret = register_acpi_bus_type(&acpi_pci_bus);
 	if (ret)
 		return 0;

commit 0dcb2b7e722f62b886f28b01150860de67d219fa
Author: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
Date:   Mon Oct 30 13:08:12 2006 -0800

    pci: clear osc support flags if no _OSC method
    
    So it looks like pci aer code will call pci_osc_support_set to tell the
    firmware about  OSC_EXT_PCI_CONFIG_SUPPORT flag.  that causes
    ctrlset_buf[OSC_SUPPORT_TYPE] to evaluate to true when pciehp calls
    pci_osc_control_set() is called (to attempt to use OSC to gain native
    pcie control from firmware), regardless of whether or not _OSC was
    actually successfully executed.  That causes this section of code:
     if (ctrlset_buf[OSC_SUPPORT_TYPE] &&
                    ((global_ctrlsets & ctrlset) != ctrlset)) {
                    return AE_SUPPORT;
            }
    to be hit.
    
    This patch will reset the OSC_SUPPORT_TYPE field if _OSC fails, and then
    would allow pciehp to go ahead and try to run _OSC again.
    
    Signed-off-by:  Kristen Carlson Accardi <kristen.c.accardi@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index bb7456c1dbac..a064f36a0805 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -36,6 +36,7 @@ acpi_query_osc (
 	struct acpi_buffer	output = {ACPI_ALLOCATE_BUFFER, NULL};
 	union acpi_object 	*out_obj;
 	u32			osc_dw0;
+	acpi_status *ret_status = (acpi_status *)retval;
 
 	
 	/* Setting up input parameters */
@@ -56,6 +57,7 @@ acpi_query_osc (
 	if (ACPI_FAILURE (status)) {
 		printk(KERN_DEBUG  
 			"Evaluate _OSC Set fails. Status = 0x%04x\n", status);
+		*ret_status = status;
 		return status;
 	}
 	out_obj = output.pointer;
@@ -90,6 +92,7 @@ acpi_query_osc (
 
 query_osc_out:
 	kfree(output.pointer);
+	*ret_status = status;
 	return status;
 }
 
@@ -166,6 +169,7 @@ acpi_run_osc (
 acpi_status pci_osc_support_set(u32 flags)
 {
 	u32 temp;
+	acpi_status retval;
 
 	if (!(flags & OSC_SUPPORT_MASKS)) {
 		return AE_TYPE;
@@ -179,9 +183,13 @@ acpi_status pci_osc_support_set(u32 flags)
 	acpi_get_devices ( PCI_ROOT_HID_STRING,
 			acpi_query_osc,
 			ctrlset_buf,
-			NULL );
+			(void **) &retval );
 	ctrlset_buf[OSC_QUERY_TYPE] = !OSC_QUERY_ENABLE;
 	ctrlset_buf[OSC_CONTROL_TYPE] = temp;
+	if (ACPI_FAILURE(retval)) {
+		/* no osc support at all */
+		ctrlset_buf[OSC_SUPPORT_TYPE] = 0;
+	}
 	return AE_OK;
 }
 EXPORT_SYMBOL(pci_osc_support_set);

commit 9c273b95808c270149e9be9e172e4ef19f5d5c98
Author: Muthu Kumar <muthu.lkml@gmail.com>
Date:   Fri Apr 28 00:42:21 2006 -0700

    [PATCH] PCI ACPI: Rename the functions to avoid multiple instances.
    
    There were two instances of pci_acpi_init(), one in
    drivers/pci/pci-acpi.c and another in arch/i386/pci/acpi.c.
    Rename the one in pci-acpi.c and make it consistent with
    other names in the same file.
    
    Signed-off-by: Muthukumar R <muthur@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index c2ecae5ff0c1..bb7456c1dbac 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -267,7 +267,7 @@ static int acpi_pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 
 
 /* ACPI bus type */
-static int pci_acpi_find_device(struct device *dev, acpi_handle *handle)
+static int acpi_pci_find_device(struct device *dev, acpi_handle *handle)
 {
 	struct pci_dev * pci_dev;
 	acpi_integer	addr;
@@ -281,7 +281,7 @@ static int pci_acpi_find_device(struct device *dev, acpi_handle *handle)
 	return 0;
 }
 
-static int pci_acpi_find_root_bridge(struct device *dev, acpi_handle *handle)
+static int acpi_pci_find_root_bridge(struct device *dev, acpi_handle *handle)
 {
 	int num;
 	unsigned int seg, bus;
@@ -299,21 +299,21 @@ static int pci_acpi_find_root_bridge(struct device *dev, acpi_handle *handle)
 	return 0;
 }
 
-static struct acpi_bus_type pci_acpi_bus = {
+static struct acpi_bus_type acpi_pci_bus = {
 	.bus = &pci_bus_type,
-	.find_device = pci_acpi_find_device,
-	.find_bridge = pci_acpi_find_root_bridge,
+	.find_device = acpi_pci_find_device,
+	.find_bridge = acpi_pci_find_root_bridge,
 };
 
-static int __init pci_acpi_init(void)
+static int __init acpi_pci_init(void)
 {
 	int ret;
 
-	ret = register_acpi_bus_type(&pci_acpi_bus);
+	ret = register_acpi_bus_type(&acpi_pci_bus);
 	if (ret)
 		return 0;
 	platform_pci_choose_state = acpi_pci_choose_state;
 	platform_pci_set_power_state = acpi_pci_set_power_state;
 	return 0;
 }
-arch_initcall(pci_acpi_init);
+arch_initcall(acpi_pci_init);

commit 593ee20766921fec643194dff829e17f30552220
Author: Kristen Accardi <kristen.c.accardi@intel.com>
Date:   Sat May 20 15:00:08 2006 -0700

    [PATCH] pci: correctly allocate return buffers for osc calls
    
    The OSC set and query functions do not allocate enough space for return
    values, and set the output buffer length to a false, too large value.  This
    causes the acpi-ca code to assume that the output buffer is larger than it
    actually is, and overwrite memory when copying acpi return buffers into
    this caller provided buffer.  In some cases this can cause kernel oops if
    the memory that is overwritten is a pointer.  This patch will change these
    calls to use a dynamically allocated output buffer, thus allowing the
    acpi-ca code to decide how much space is needed.
    
    Signed-off-by: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
    Cc: "Brown, Len" <len.brown@intel.com>
    Cc: "Yu, Luming" <luming.yu@intel.com>
    Cc: Greg KH <greg@kroah.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 6917c6cb0912..c2ecae5ff0c1 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -33,13 +33,10 @@ acpi_query_osc (
 	acpi_status		status;
 	struct acpi_object_list	input;
 	union acpi_object 	in_params[4];
-	struct acpi_buffer	output;
-	union acpi_object 	out_obj;	
+	struct acpi_buffer	output = {ACPI_ALLOCATE_BUFFER, NULL};
+	union acpi_object 	*out_obj;
 	u32			osc_dw0;
 
-	/* Setting up output buffer */
-	output.length = sizeof(out_obj) + 3*sizeof(u32);  
-	output.pointer = &out_obj;
 	
 	/* Setting up input parameters */
 	input.count = 4;
@@ -61,12 +58,15 @@ acpi_query_osc (
 			"Evaluate _OSC Set fails. Status = 0x%04x\n", status);
 		return status;
 	}
-	if (out_obj.type != ACPI_TYPE_BUFFER) {
+	out_obj = output.pointer;
+
+	if (out_obj->type != ACPI_TYPE_BUFFER) {
 		printk(KERN_DEBUG  
 			"Evaluate _OSC returns wrong type\n");
-		return AE_TYPE;
+		status = AE_TYPE;
+		goto query_osc_out;
 	}
-	osc_dw0 = *((u32 *) out_obj.buffer.pointer);
+	osc_dw0 = *((u32 *) out_obj->buffer.pointer);
 	if (osc_dw0) {
 		if (osc_dw0 & OSC_REQUEST_ERROR)
 			printk(KERN_DEBUG "_OSC request fails\n"); 
@@ -76,15 +76,21 @@ acpi_query_osc (
 			printk(KERN_DEBUG "_OSC invalid revision\n"); 
 		if (osc_dw0 & OSC_CAPABILITIES_MASK_ERROR) {
 			/* Update Global Control Set */
-			global_ctrlsets = *((u32 *)(out_obj.buffer.pointer+8));
-			return AE_OK;
+			global_ctrlsets = *((u32 *)(out_obj->buffer.pointer+8));
+			status = AE_OK;
+			goto query_osc_out;
 		}
-		return AE_ERROR;
+		status = AE_ERROR;
+		goto query_osc_out;
 	}
 
 	/* Update Global Control Set */
-	global_ctrlsets = *((u32 *)(out_obj.buffer.pointer + 8));
-	return AE_OK;
+	global_ctrlsets = *((u32 *)(out_obj->buffer.pointer + 8));
+	status = AE_OK;
+
+query_osc_out:
+	kfree(output.pointer);
+	return status;
 }
 
 
@@ -96,14 +102,10 @@ acpi_run_osc (
 	acpi_status		status;
 	struct acpi_object_list	input;
 	union acpi_object 	in_params[4];
-	struct acpi_buffer	output;
-	union acpi_object 	out_obj;	
+	struct acpi_buffer	output = {ACPI_ALLOCATE_BUFFER, NULL};
+	union acpi_object 	*out_obj;
 	u32			osc_dw0;
 
-	/* Setting up output buffer */
-	output.length = sizeof(out_obj) + 3*sizeof(u32);  
-	output.pointer = &out_obj;
-	
 	/* Setting up input parameters */
 	input.count = 4;
 	input.pointer = in_params;
@@ -124,12 +126,14 @@ acpi_run_osc (
 			"Evaluate _OSC Set fails. Status = 0x%04x\n", status);
 		return status;
 	}
-	if (out_obj.type != ACPI_TYPE_BUFFER) {
+	out_obj = output.pointer;
+	if (out_obj->type != ACPI_TYPE_BUFFER) {
 		printk(KERN_DEBUG  
 			"Evaluate _OSC returns wrong type\n");
-		return AE_TYPE;
+		status = AE_TYPE;
+		goto run_osc_out;
 	}
-	osc_dw0 = *((u32 *) out_obj.buffer.pointer);
+	osc_dw0 = *((u32 *) out_obj->buffer.pointer);
 	if (osc_dw0) {
 		if (osc_dw0 & OSC_REQUEST_ERROR)
 			printk(KERN_DEBUG "_OSC request fails\n"); 
@@ -139,11 +143,17 @@ acpi_run_osc (
 			printk(KERN_DEBUG "_OSC invalid revision\n"); 
 		if (osc_dw0 & OSC_CAPABILITIES_MASK_ERROR) {
 			printk(KERN_DEBUG "_OSC FW not grant req. control\n");
-			return AE_SUPPORT;
+			status = AE_SUPPORT;
+			goto run_osc_out;
 		}
-		return AE_ERROR;
+		status = AE_ERROR;
+		goto run_osc_out;
 	}
-	return AE_OK;
+	status = AE_OK;
+
+run_osc_out:
+	kfree(output.pointer);
+	return status;
 }
 
 /**

commit f366633fc31db1668b4c261e94816d7304ae9810
Author: Randy Dunlap <rdunlap@xenotime.net>
Date:   Wed Nov 23 15:45:04 2005 -0800

    [PATCH] PCI: kernel-doc fix for pci-acpi.c
    
    Fix kernel-doc warning in pci/pci-acpi.c.
    
    Signed-off-by: Randy Dunlap <rdunlap@xenotime.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index a9b00cc2d885..6917c6cb0912 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -178,6 +178,7 @@ EXPORT_SYMBOL(pci_osc_support_set);
 
 /**
  * pci_osc_control_set - commit requested control to Firmware
+ * @handle: acpi_handle for the target ACPI object
  * @flags: driver's requested control bits
  *
  * Attempt to take control from Firmware on requested control bits.

commit 427bf532b5ad6db5addc2bce675d13f874397c0c
Author: rajesh.shah@intel.com <rajesh.shah@intel.com>
Date:   Mon Oct 31 16:20:11 2005 -0800

    [PATCH] pciehp: request control of each hotplug controller individually
    
    This patch tweaks the way pciehp requests control of the hotplug
    hardware from BIOS. It now tries to invoke the ACPI _OSC method
    for a specific hotplug controller only, rather than walking the
    entire acpi namespace invoking all possible _OSC methods under
    all host bridges. This allows us to gain control of each hotplug
    controller individually, even if BIOS fails to give us control of
    some other hotplug controller in the system.
    
    Signed-off-by: Rajesh Shah <rajesh.shah@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index e9e37abe1f76..a9b00cc2d885 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -91,9 +91,7 @@ acpi_query_osc (
 static acpi_status  
 acpi_run_osc (
 	acpi_handle	handle,
-	u32		level,
-	void		*context,
-	void		**retval )
+	void		*context)
 {
 	acpi_status		status;
 	struct acpi_object_list	input;
@@ -184,7 +182,7 @@ EXPORT_SYMBOL(pci_osc_support_set);
  *
  * Attempt to take control from Firmware on requested control bits.
  **/
-acpi_status pci_osc_control_set(u32 flags)
+acpi_status pci_osc_control_set(acpi_handle handle, u32 flags)
 {
 	acpi_status	status;
 	u32		ctrlset;
@@ -198,10 +196,7 @@ acpi_status pci_osc_control_set(u32 flags)
 		return AE_SUPPORT;
 	}
 	ctrlset_buf[OSC_CONTROL_TYPE] |= ctrlset;
-	status = acpi_get_devices ( PCI_ROOT_HID_STRING,
-				acpi_run_osc,
-				ctrlset_buf,
-				NULL );
+	status = acpi_run_osc(handle, ctrlset_buf);
 	if (ACPI_FAILURE (status)) {
 		ctrlset_buf[OSC_CONTROL_TYPE] &= ~ctrlset;
 	}

commit a406d9e63e1d7088aad22565449de2e109300e5c
Author: Len Brown <len.brown@intel.com>
Date:   Wed Mar 23 16:16:03 2005 -0500

    [ACPI] gut acpi_pci_choose_state() to avoid conflict
    with pending pm_message_t re-definition.
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index a0d43ea872df..e9e37abe1f76 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -1,6 +1,6 @@
 /*
  * File:	pci-acpi.c
- * Purpose:	Provde PCI support in ACPI
+ * Purpose:	Provide PCI support in ACPI
  *
  * Copyright (C) 2005 David Shaohua Li <shaohua.li@intel.com>
  * Copyright (C) 2004 Tom Long Nguyen <tom.l.nguyen@intel.com>
@@ -237,19 +237,8 @@ EXPORT_SYMBOL(pci_osc_control_set);
 
 static int acpi_pci_choose_state(struct pci_dev *pdev, pm_message_t state)
 {
-	char dstate_str[] = "_S0D";
-	acpi_status status;
-	unsigned long val;
-	struct device *dev = &pdev->dev;
+	/* TBD */
 
-	/* Fixme: the check is wrong after pm_message_t is a struct */
-	if ((state >= PM_SUSPEND_MAX) || !DEVICE_ACPI_HANDLE(dev))
-		return -EINVAL;
-	dstate_str[2] += state;	/* _S1D, _S2D, _S3D, _S4D */
-	status = acpi_evaluate_integer(DEVICE_ACPI_HANDLE(dev), dstate_str,
-		NULL, &val);
-	if (ACPI_SUCCESS(status))
-		return val;
 	return -ENODEV;
 }
 

commit b913100d7304ea9596d8d85ab5f3ae04bd2b0ddb
Author: David Shaohua Li <shaohua.li@intel.com>
Date:   Sat Mar 19 00:16:18 2005 -0500

    [ACPI] pci_set_power_state() now calls
            platform_pci_set_power_state()
                    and ACPI can answer
    
    http://bugzilla.kernel.org/show_bug.cgi?id=4277
    
    Signed-off-by: David Shaohua Li <shaohua.li@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 8eb599708de8..a0d43ea872df 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -253,6 +253,24 @@ static int acpi_pci_choose_state(struct pci_dev *pdev, pm_message_t state)
 	return -ENODEV;
 }
 
+static int acpi_pci_set_power_state(struct pci_dev *dev, pci_power_t state)
+{
+	acpi_handle handle = DEVICE_ACPI_HANDLE(&dev->dev);
+	static int state_conv[] = {
+		[0] = 0,
+		[1] = 1,
+		[2] = 2,
+		[3] = 3,
+		[4] = 3
+	};
+	int acpi_state = state_conv[(int __force) state];
+
+	if (!handle)
+		return -ENODEV;
+	return acpi_bus_set_power(handle, acpi_state);
+}
+
+
 /* ACPI bus type */
 static int pci_acpi_find_device(struct device *dev, acpi_handle *handle)
 {
@@ -300,6 +318,7 @@ static int __init pci_acpi_init(void)
 	if (ret)
 		return 0;
 	platform_pci_choose_state = acpi_pci_choose_state;
+	platform_pci_set_power_state = acpi_pci_set_power_state;
 	return 0;
 }
 arch_initcall(pci_acpi_init);

commit 0f64474b8f7f1f7f3af5b24ef997baa35f923509
Author: David Shaohua Li <shaohua.li@intel.com>
Date:   Sat Mar 19 00:15:48 2005 -0500

    [ACPI] PCI can now get suspend state from firmware
    
    pci_choose_state() can now call
            platform_pci_choose_state()
                    and ACPI can answer
    
    http://bugzilla.kernel.org/show_bug.cgi?id=4277
    
    Signed-off-by: David Shaohua Li <shaohua.li@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index f94c86fbc669..8eb599708de8 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -1,6 +1,6 @@
 /*
  * File:	pci-acpi.c
- * Purpose:	Provide PCI support in ACPI
+ * Purpose:	Provde PCI support in ACPI
  *
  * Copyright (C) 2005 David Shaohua Li <shaohua.li@intel.com>
  * Copyright (C) 2004 Tom Long Nguyen <tom.l.nguyen@intel.com>
@@ -17,6 +17,7 @@
 #include <acpi/acpi_bus.h>
 
 #include <linux/pci-acpi.h>
+#include "pci.h"
 
 static u32 ctrlset_buf[3] = {0, 0, 0};
 static u32 global_ctrlsets = 0;
@@ -209,6 +210,49 @@ acpi_status pci_osc_control_set(u32 flags)
 }
 EXPORT_SYMBOL(pci_osc_control_set);
 
+/*
+ * _SxD returns the D-state with the highest power
+ * (lowest D-state number) supported in the S-state "x".
+ *
+ * If the devices does not have a _PRW
+ * (Power Resources for Wake) supporting system wakeup from "x"
+ * then the OS is free to choose a lower power (higher number
+ * D-state) than the return value from _SxD.
+ *
+ * But if _PRW is enabled at S-state "x", the OS
+ * must not choose a power lower than _SxD --
+ * unless the device has an _SxW method specifying
+ * the lowest power (highest D-state number) the device
+ * may enter while still able to wake the system.
+ *
+ * ie. depending on global OS policy:
+ *
+ * if (_PRW at S-state x)
+ *	choose from highest power _SxD to lowest power _SxW
+ * else // no _PRW at S-state x
+ * 	choose highest power _SxD or any lower power
+ *
+ * currently we simply return _SxD, if present.
+ */
+
+static int acpi_pci_choose_state(struct pci_dev *pdev, pm_message_t state)
+{
+	char dstate_str[] = "_S0D";
+	acpi_status status;
+	unsigned long val;
+	struct device *dev = &pdev->dev;
+
+	/* Fixme: the check is wrong after pm_message_t is a struct */
+	if ((state >= PM_SUSPEND_MAX) || !DEVICE_ACPI_HANDLE(dev))
+		return -EINVAL;
+	dstate_str[2] += state;	/* _S1D, _S2D, _S3D, _S4D */
+	status = acpi_evaluate_integer(DEVICE_ACPI_HANDLE(dev), dstate_str,
+		NULL, &val);
+	if (ACPI_SUCCESS(status))
+		return val;
+	return -ENODEV;
+}
+
 /* ACPI bus type */
 static int pci_acpi_find_device(struct device *dev, acpi_handle *handle)
 {
@@ -255,6 +299,7 @@ static int __init pci_acpi_init(void)
 	ret = register_acpi_bus_type(&pci_acpi_bus);
 	if (ret)
 		return 0;
+	platform_pci_choose_state = acpi_pci_choose_state;
 	return 0;
 }
 arch_initcall(pci_acpi_init);

commit 84df749f364209c9623304b7a94ddb954dc343bb
Author: David Shaohua Li <shaohua.li@intel.com>
Date:   Fri Mar 18 18:53:36 2005 -0500

    [ACPI] Bind ACPI and PCI devices
    
    http://bugzilla.kernel.org/show_bug.cgi?id=4277
    
    Signed-off-by: David Shaohua Li <shaohua.li@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index bc01d34e2634..f94c86fbc669 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -1,9 +1,10 @@
 /*
  * File:	pci-acpi.c
- * Purpose:	Provide PCI supports in ACPI
+ * Purpose:	Provide PCI support in ACPI
  *
- * Copyright (C) 2004 Intel
- * Copyright (C) Tom Long Nguyen (tom.l.nguyen@intel.com)
+ * Copyright (C) 2005 David Shaohua Li <shaohua.li@intel.com>
+ * Copyright (C) 2004 Tom Long Nguyen <tom.l.nguyen@intel.com>
+ * Copyright (C) 2004 Intel Corp.
  */
 
 #include <linux/delay.h>
@@ -207,3 +208,53 @@ acpi_status pci_osc_control_set(u32 flags)
 	return status;
 }
 EXPORT_SYMBOL(pci_osc_control_set);
+
+/* ACPI bus type */
+static int pci_acpi_find_device(struct device *dev, acpi_handle *handle)
+{
+	struct pci_dev * pci_dev;
+	acpi_integer	addr;
+
+	pci_dev = to_pci_dev(dev);
+	/* Please ref to ACPI spec for the syntax of _ADR */
+	addr = (PCI_SLOT(pci_dev->devfn) << 16) | PCI_FUNC(pci_dev->devfn);
+	*handle = acpi_get_child(DEVICE_ACPI_HANDLE(dev->parent), addr);
+	if (!*handle)
+		return -ENODEV;
+	return 0;
+}
+
+static int pci_acpi_find_root_bridge(struct device *dev, acpi_handle *handle)
+{
+	int num;
+	unsigned int seg, bus;
+
+	/*
+	 * The string should be the same as root bridge's name
+	 * Please look at 'pci_scan_bus_parented'
+	 */
+	num = sscanf(dev->bus_id, "pci%04x:%02x", &seg, &bus);
+	if (num != 2)
+		return -ENODEV;
+	*handle = acpi_get_pci_rootbridge_handle(seg, bus);
+	if (!*handle)
+		return -ENODEV;
+	return 0;
+}
+
+static struct acpi_bus_type pci_acpi_bus = {
+	.bus = &pci_bus_type,
+	.find_device = pci_acpi_find_device,
+	.find_bridge = pci_acpi_find_root_bridge,
+};
+
+static int __init pci_acpi_init(void)
+{
+	int ret;
+
+	ret = register_acpi_bus_type(&pci_acpi_bus);
+	if (ret)
+		return 0;
+	return 0;
+}
+arch_initcall(pci_acpi_init);

commit bc56b9e01190b9f1ad6b7c5c694b61bfe34c7aa5
Author: Greg KH <gregkh@suse.de>
Date:   Fri Apr 8 14:53:31 2005 +0900

    [PATCH] PCI: Clean up a lot of sparse "Should it be static?" warnings.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 968eb32f292d..bc01d34e2634 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -19,7 +19,7 @@
 
 static u32 ctrlset_buf[3] = {0, 0, 0};
 static u32 global_ctrlsets = 0;
-u8 OSC_UUID[16] = {0x5B, 0x4D, 0xDB, 0x33, 0xF7, 0x1F, 0x1C, 0x40, 0x96, 0x57, 0x74, 0x41, 0xC0, 0x3D, 0xD7, 0x66};
+static u8 OSC_UUID[16] = {0x5B, 0x4D, 0xDB, 0x33, 0xF7, 0x1F, 0x1C, 0x40, 0x96, 0x57, 0x74, 0x41, 0xC0, 0x3D, 0xD7, 0x66};
 
 static acpi_status  
 acpi_query_osc (

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
new file mode 100644
index 000000000000..968eb32f292d
--- /dev/null
+++ b/drivers/pci/pci-acpi.c
@@ -0,0 +1,209 @@
+/*
+ * File:	pci-acpi.c
+ * Purpose:	Provide PCI supports in ACPI
+ *
+ * Copyright (C) 2004 Intel
+ * Copyright (C) Tom Long Nguyen (tom.l.nguyen@intel.com)
+ */
+
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/module.h>
+#include <acpi/acpi.h>
+#include <acpi/acnamesp.h>
+#include <acpi/acresrc.h>
+#include <acpi/acpi_bus.h>
+
+#include <linux/pci-acpi.h>
+
+static u32 ctrlset_buf[3] = {0, 0, 0};
+static u32 global_ctrlsets = 0;
+u8 OSC_UUID[16] = {0x5B, 0x4D, 0xDB, 0x33, 0xF7, 0x1F, 0x1C, 0x40, 0x96, 0x57, 0x74, 0x41, 0xC0, 0x3D, 0xD7, 0x66};
+
+static acpi_status  
+acpi_query_osc (
+	acpi_handle	handle,
+	u32		level,
+	void		*context,
+	void		**retval )
+{
+	acpi_status		status;
+	struct acpi_object_list	input;
+	union acpi_object 	in_params[4];
+	struct acpi_buffer	output;
+	union acpi_object 	out_obj;	
+	u32			osc_dw0;
+
+	/* Setting up output buffer */
+	output.length = sizeof(out_obj) + 3*sizeof(u32);  
+	output.pointer = &out_obj;
+	
+	/* Setting up input parameters */
+	input.count = 4;
+	input.pointer = in_params;
+	in_params[0].type 		= ACPI_TYPE_BUFFER;
+	in_params[0].buffer.length 	= 16;
+	in_params[0].buffer.pointer	= OSC_UUID;
+	in_params[1].type 		= ACPI_TYPE_INTEGER;
+	in_params[1].integer.value 	= 1;
+	in_params[2].type 		= ACPI_TYPE_INTEGER;
+	in_params[2].integer.value	= 3;
+	in_params[3].type		= ACPI_TYPE_BUFFER;
+	in_params[3].buffer.length 	= 12;
+	in_params[3].buffer.pointer 	= (u8 *)context;
+
+	status = acpi_evaluate_object(handle, "_OSC", &input, &output);
+	if (ACPI_FAILURE (status)) {
+		printk(KERN_DEBUG  
+			"Evaluate _OSC Set fails. Status = 0x%04x\n", status);
+		return status;
+	}
+	if (out_obj.type != ACPI_TYPE_BUFFER) {
+		printk(KERN_DEBUG  
+			"Evaluate _OSC returns wrong type\n");
+		return AE_TYPE;
+	}
+	osc_dw0 = *((u32 *) out_obj.buffer.pointer);
+	if (osc_dw0) {
+		if (osc_dw0 & OSC_REQUEST_ERROR)
+			printk(KERN_DEBUG "_OSC request fails\n"); 
+		if (osc_dw0 & OSC_INVALID_UUID_ERROR)
+			printk(KERN_DEBUG "_OSC invalid UUID\n"); 
+		if (osc_dw0 & OSC_INVALID_REVISION_ERROR)
+			printk(KERN_DEBUG "_OSC invalid revision\n"); 
+		if (osc_dw0 & OSC_CAPABILITIES_MASK_ERROR) {
+			/* Update Global Control Set */
+			global_ctrlsets = *((u32 *)(out_obj.buffer.pointer+8));
+			return AE_OK;
+		}
+		return AE_ERROR;
+	}
+
+	/* Update Global Control Set */
+	global_ctrlsets = *((u32 *)(out_obj.buffer.pointer + 8));
+	return AE_OK;
+}
+
+
+static acpi_status  
+acpi_run_osc (
+	acpi_handle	handle,
+	u32		level,
+	void		*context,
+	void		**retval )
+{
+	acpi_status		status;
+	struct acpi_object_list	input;
+	union acpi_object 	in_params[4];
+	struct acpi_buffer	output;
+	union acpi_object 	out_obj;	
+	u32			osc_dw0;
+
+	/* Setting up output buffer */
+	output.length = sizeof(out_obj) + 3*sizeof(u32);  
+	output.pointer = &out_obj;
+	
+	/* Setting up input parameters */
+	input.count = 4;
+	input.pointer = in_params;
+	in_params[0].type 		= ACPI_TYPE_BUFFER;
+	in_params[0].buffer.length 	= 16;
+	in_params[0].buffer.pointer	= OSC_UUID;
+	in_params[1].type 		= ACPI_TYPE_INTEGER;
+	in_params[1].integer.value 	= 1;
+	in_params[2].type 		= ACPI_TYPE_INTEGER;
+	in_params[2].integer.value	= 3;
+	in_params[3].type		= ACPI_TYPE_BUFFER;
+	in_params[3].buffer.length 	= 12;
+	in_params[3].buffer.pointer 	= (u8 *)context;
+
+	status = acpi_evaluate_object(handle, "_OSC", &input, &output);
+	if (ACPI_FAILURE (status)) {
+		printk(KERN_DEBUG  
+			"Evaluate _OSC Set fails. Status = 0x%04x\n", status);
+		return status;
+	}
+	if (out_obj.type != ACPI_TYPE_BUFFER) {
+		printk(KERN_DEBUG  
+			"Evaluate _OSC returns wrong type\n");
+		return AE_TYPE;
+	}
+	osc_dw0 = *((u32 *) out_obj.buffer.pointer);
+	if (osc_dw0) {
+		if (osc_dw0 & OSC_REQUEST_ERROR)
+			printk(KERN_DEBUG "_OSC request fails\n"); 
+		if (osc_dw0 & OSC_INVALID_UUID_ERROR)
+			printk(KERN_DEBUG "_OSC invalid UUID\n"); 
+		if (osc_dw0 & OSC_INVALID_REVISION_ERROR)
+			printk(KERN_DEBUG "_OSC invalid revision\n"); 
+		if (osc_dw0 & OSC_CAPABILITIES_MASK_ERROR) {
+			printk(KERN_DEBUG "_OSC FW not grant req. control\n");
+			return AE_SUPPORT;
+		}
+		return AE_ERROR;
+	}
+	return AE_OK;
+}
+
+/**
+ * pci_osc_support_set - register OS support to Firmware
+ * @flags: OS support bits
+ *
+ * Update OS support fields and doing a _OSC Query to obtain an update
+ * from Firmware on supported control bits.
+ **/
+acpi_status pci_osc_support_set(u32 flags)
+{
+	u32 temp;
+
+	if (!(flags & OSC_SUPPORT_MASKS)) {
+		return AE_TYPE;
+	}
+	ctrlset_buf[OSC_SUPPORT_TYPE] |= (flags & OSC_SUPPORT_MASKS);
+
+	/* do _OSC query for all possible controls */
+	temp = ctrlset_buf[OSC_CONTROL_TYPE];
+	ctrlset_buf[OSC_QUERY_TYPE] = OSC_QUERY_ENABLE;
+	ctrlset_buf[OSC_CONTROL_TYPE] = OSC_CONTROL_MASKS;
+	acpi_get_devices ( PCI_ROOT_HID_STRING,
+			acpi_query_osc,
+			ctrlset_buf,
+			NULL );
+	ctrlset_buf[OSC_QUERY_TYPE] = !OSC_QUERY_ENABLE;
+	ctrlset_buf[OSC_CONTROL_TYPE] = temp;
+	return AE_OK;
+}
+EXPORT_SYMBOL(pci_osc_support_set);
+
+/**
+ * pci_osc_control_set - commit requested control to Firmware
+ * @flags: driver's requested control bits
+ *
+ * Attempt to take control from Firmware on requested control bits.
+ **/
+acpi_status pci_osc_control_set(u32 flags)
+{
+	acpi_status	status;
+	u32		ctrlset;
+
+	ctrlset = (flags & OSC_CONTROL_MASKS);
+	if (!ctrlset) {
+		return AE_TYPE;
+	}
+	if (ctrlset_buf[OSC_SUPPORT_TYPE] && 
+	 	((global_ctrlsets & ctrlset) != ctrlset)) {
+		return AE_SUPPORT;
+	}
+	ctrlset_buf[OSC_CONTROL_TYPE] |= ctrlset;
+	status = acpi_get_devices ( PCI_ROOT_HID_STRING,
+				acpi_run_osc,
+				ctrlset_buf,
+				NULL );
+	if (ACPI_FAILURE (status)) {
+		ctrlset_buf[OSC_CONTROL_TYPE] &= ~ctrlset;
+	}
+	
+	return status;
+}
+EXPORT_SYMBOL(pci_osc_control_set);
