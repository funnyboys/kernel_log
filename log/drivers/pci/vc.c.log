commit c5048a73b4770304699cb15e3ffcb97acab685f7
Merge: cdc7e184abb3 55507aea5882
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Sep 23 16:10:31 2019 -0500

    Merge branch 'pci/trivial'
    
      - Fix typos and whitespace errors (Bjorn Helgaas, Krzysztof Wilczynski)
    
      - Remove unnecessary "return" statements (Krzysztof Wilczynski)
    
      - Correct of_irq_parse_pci() function documentation (Lubomir Rintel)
    
    * pci/trivial:
      PCI: Remove unnecessary returns
      PCI: OF: Correct of_irq_parse_pci() documentation
      PCI: Fix typos and whitespace errors

commit ca78410403dd64ac0ee0e3cc8646b38335271bfd
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Thu Aug 22 11:55:53 2019 +0300

    PCI: Get rid of dev->has_secondary_link flag
    
    In some systems, the Device/Port Type in the PCI Express Capabilities
    register incorrectly identifies upstream ports as downstream ports.
    
    d0751b98dfa3 ("PCI: Add dev->has_secondary_link to track downstream PCIe
    links") addressed this by adding pci_dev.has_secondary_link, which is set
    for downstream ports.  But this is confusing because pci_pcie_type()
    sometimes gives the wrong answer, and it's not obvious that we should use
    pci_dev.has_secondary_link instead.
    
    Reduce the confusion by correcting the type of the port itself so that
    pci_pcie_type() returns the actual type regardless of what the Device/Port
    Type register claims it is.  Update the users to call pci_pcie_type() and
    pcie_downstream_port() accordingly, and remove pci_dev.has_secondary_link
    completely.
    
    Link: https://lore.kernel.org/linux-pci/20190703133953.GK128603@google.com/
    Suggested-by: Bjorn Helgaas <bhelgaas@google.com>
    Link: https://lore.kernel.org/r/20190822085553.62697-2-mika.westerberg@linux.intel.com
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/pci/vc.c b/drivers/pci/vc.c
index 5acd9c02683a..9ae9fb9339e8 100644
--- a/drivers/pci/vc.c
+++ b/drivers/pci/vc.c
@@ -13,6 +13,8 @@
 #include <linux/pci_regs.h>
 #include <linux/types.h>
 
+#include "pci.h"
+
 /**
  * pci_vc_save_restore_dwords - Save or restore a series of dwords
  * @dev: device
@@ -105,7 +107,7 @@ static void pci_vc_enable(struct pci_dev *dev, int pos, int res)
 	struct pci_dev *link = NULL;
 
 	/* Enable VCs from the downstream device */
-	if (!dev->has_secondary_link)
+	if (!pci_is_pcie(dev) || !pcie_downstream_port(dev))
 		return;
 
 	ctrl_pos = pos + PCI_VC_RES_CTRL + (res * PCI_CAP_VC_PER_VC_SIZEOF);

commit d1bbf38aaf882240cccca414e5a48db42e105da7
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Jul 30 08:04:00 2019 -0500

    PCI: Fix typos and whitespace errors
    
    Fix typos in drivers/pci.  Comment and whitespace changes only.
    
    Link: https://lore.kernel.org/r/20190819115306.27338-1-kw@linux.com
    Signed-off-by: Krzysztof Wilczynski <kw@linux.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rob Herring <robh@kernel.org>
    Acked-by: Thomas Petazzoni <thomas.petazzoni@bootlin.com>       # armada8k

diff --git a/drivers/pci/vc.c b/drivers/pci/vc.c
index 5acd9c02683a..b39e854b80ec 100644
--- a/drivers/pci/vc.c
+++ b/drivers/pci/vc.c
@@ -409,7 +409,6 @@ void pci_restore_vc_state(struct pci_dev *dev)
  * For each type of VC capability, VC/VC9/MFVC, find the capability, size
  * it, and allocate a buffer for save/restore.
  */
-
 void pci_allocate_vc_save_buffers(struct pci_dev *dev)
 {
 	int i;

commit ab8c609356fbe8dbcd44df11e884ce8cddf3739e
Merge: a5fae846f21d 36b072742a83
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Feb 1 11:40:07 2018 -0600

    Merge branch 'pci/spdx' into next
    
    * pci/spdx:
      PCI: Add SPDX GPL-2.0+ to replace implicit GPL v2 or later statement
      PCI: Add SPDX GPL-2.0+ to replace GPL v2 or later boilerplate
      PCI: Add SPDX GPL-2.0 to replace COPYING boilerplate
      PCI: Add SPDX GPL-2.0 to replace GPL v2 boilerplate
      PCI: Add SPDX GPL-2.0 when no license was specified

commit 8cfab3cf63cfe5a53e2e566b3b86b30c187edf3a
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Jan 26 12:50:27 2018 -0600

    PCI: Add SPDX GPL-2.0 to replace GPL v2 boilerplate
    
    Add SPDX GPL-2.0 to all PCI files that specified the GPL version 2 license.
    
    Remove the boilerplate GPL version 2 language, relying on the assertion in
    b24413180f56 ("License cleanup: add SPDX GPL-2.0 license identifier to
    files with no license") that the SPDX identifier may be used instead of the
    full boilerplate text.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pci/vc.c b/drivers/pci/vc.c
index 1fa3a3219c45..825c4bddb5fd 100644
--- a/drivers/pci/vc.c
+++ b/drivers/pci/vc.c
@@ -1,12 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * PCI Virtual Channel support
  *
  * Copyright (C) 2013 Red Hat, Inc.  All rights reserved.
  *     Author: Alex Williamson <alex.williamson@redhat.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
  */
 
 #include <linux/device.h>

commit 7506dc7989933235e6fc23f3d0516bdbf0f7d1a8
Author: Frederick Lawler <fred@fredlawl.com>
Date:   Thu Jan 18 12:55:24 2018 -0600

    PCI: Add wrappers for dev_printk()
    
    Add PCI-specific dev_printk() wrappers and use them to simplify the code
    slightly.  No functional change intended.
    
    Signed-off-by: Frederick Lawler <fred@fredlawl.com>
    [bhelgaas: squash into one patch]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/vc.c b/drivers/pci/vc.c
index 1fa3a3219c45..881b9861aed4 100644
--- a/drivers/pci/vc.c
+++ b/drivers/pci/vc.c
@@ -57,7 +57,7 @@ static void pci_vc_load_arb_table(struct pci_dev *dev, int pos)
 				 PCI_VC_PORT_STATUS_TABLE))
 		return;
 
-	dev_err(&dev->dev, "VC arbitration table failed to load\n");
+	pci_err(dev, "VC arbitration table failed to load\n");
 }
 
 /**
@@ -85,7 +85,7 @@ static void pci_vc_load_port_arb_table(struct pci_dev *dev, int pos, int res)
 	if (pci_wait_for_pending(dev, status_pos, PCI_VC_RES_STATUS_TABLE))
 		return;
 
-	dev_err(&dev->dev, "VC%d port arbitration table failed to load\n", res);
+	pci_err(dev, "VC%d port arbitration table failed to load\n", res);
 }
 
 /**
@@ -161,11 +161,11 @@ static void pci_vc_enable(struct pci_dev *dev, int pos, int res)
 	pci_write_config_dword(dev, ctrl_pos, ctrl);
 
 	if (!pci_wait_for_pending(dev, status_pos, PCI_VC_RES_STATUS_NEGO))
-		dev_err(&dev->dev, "VC%d negotiation stuck pending\n", id);
+		pci_err(dev, "VC%d negotiation stuck pending\n", id);
 
 	if (link && !pci_wait_for_pending(link, status_pos2,
 					  PCI_VC_RES_STATUS_NEGO))
-		dev_err(&link->dev, "VC%d negotiation stuck pending\n", id);
+		pci_err(link, "VC%d negotiation stuck pending\n", id);
 }
 
 /**
@@ -195,8 +195,7 @@ static int pci_vc_do_save_buffer(struct pci_dev *dev, int pos,
 	/* Sanity check buffer size for save/restore */
 	if (buf && save_state->cap.size !=
 	    pci_vc_do_save_buffer(dev, pos, NULL, save)) {
-		dev_err(&dev->dev,
-			"VC save buffer size does not match @0x%x\n", pos);
+		pci_err(dev, "VC save buffer size does not match @0x%x\n", pos);
 		return -ENOMEM;
 	}
 
@@ -366,14 +365,14 @@ int pci_save_vc_state(struct pci_dev *dev)
 
 		save_state = pci_find_saved_ext_cap(dev, vc_caps[i].id);
 		if (!save_state) {
-			dev_err(&dev->dev, "%s buffer not found in %s\n",
+			pci_err(dev, "%s buffer not found in %s\n",
 				vc_caps[i].name, __func__);
 			return -ENOMEM;
 		}
 
 		ret = pci_vc_do_save_buffer(dev, pos, save_state, true);
 		if (ret) {
-			dev_err(&dev->dev, "%s save unsuccessful %s\n",
+			pci_err(dev, "%s save unsuccessful %s\n",
 				vc_caps[i].name, __func__);
 			return ret;
 		}
@@ -426,8 +425,7 @@ void pci_allocate_vc_save_buffers(struct pci_dev *dev)
 
 		len = pci_vc_do_save_buffer(dev, pos, NULL, false);
 		if (pci_add_ext_cap_save_buffer(dev, vc_caps[i].id, len))
-			dev_err(&dev->dev,
-				"unable to preallocate %s save buffer\n",
+			pci_err(dev, "unable to preallocate %s save buffer\n",
 				vc_caps[i].name);
 	}
 }

commit ef0dab4aae14e25efddf1577736f8450132800c5
Author: David Miller <davem@davemloft.net>
Date:   Sat Jun 18 23:52:25 2016 -0700

    PCI: Fix unaligned accesses in VC code
    
    The save/restore buffers for VC state is first composed of a 2-byte control
    register, then a bunch of 4-byte words.
    
    This causes unaligned accesses which trap on platform such as sparc.
    
    This is easy to fix by simply moving the buffer pointer forward by 4 bytes
    instead of 2 after dealing with the control register.  The length
    adjustment needs to be changed likewise as well.
    
    Fixes: 5f8fc43217a0 ("PCI: Include pci/pcie/Kconfig directly from pci/Kconfig")
    Reported-by: Meelis Roos <mroos@linux.ee>
    Reported-by: Anatoly Pugachev <matorola@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    CC: stable@vger.kernel.org      # v4.6+

diff --git a/drivers/pci/vc.c b/drivers/pci/vc.c
index dfbab61a1b47..1fa3a3219c45 100644
--- a/drivers/pci/vc.c
+++ b/drivers/pci/vc.c
@@ -221,9 +221,9 @@ static int pci_vc_do_save_buffer(struct pci_dev *dev, int pos,
 		else
 			pci_write_config_word(dev, pos + PCI_VC_PORT_CTRL,
 					      *(u16 *)buf);
-		buf += 2;
+		buf += 4;
 	}
-	len += 2;
+	len += 4;
 
 	/*
 	 * If we have any Low Priority VCs and a VC Arbitration Table Offset

commit 777e61ea40e4a94081b3123c76ea3fe977c368a2
Author: Yijing Wang <wangyijing@huawei.com>
Date:   Thu May 21 15:05:04 2015 +0800

    PCI: Use dev->has_secondary_link to find downstream PCIe links
    
    Previously we assumed that PCIe Root Ports and Downstream Ports had Links
    on their secondary side.  That is true in most systems, but it is possible
    to connect a switch with either an Upstream or a Downstream Port leading
    downstream.
    
    Instead of relying on the component type to identify devices that have
    links leading downstream, use the "dev->has_secondary_link" field.
    
    [bhelgaas: changelog]
    Signed-off-by: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/vc.c b/drivers/pci/vc.c
index 7e1304d2e389..dfbab61a1b47 100644
--- a/drivers/pci/vc.c
+++ b/drivers/pci/vc.c
@@ -108,8 +108,7 @@ static void pci_vc_enable(struct pci_dev *dev, int pos, int res)
 	struct pci_dev *link = NULL;
 
 	/* Enable VCs from the downstream device */
-	if (pci_pcie_type(dev) == PCI_EXP_TYPE_ROOT_PORT ||
-	    pci_pcie_type(dev) == PCI_EXP_TYPE_DOWNSTREAM)
+	if (!dev->has_secondary_link)
 		return;
 
 	ctrl_pos = pos + PCI_VC_RES_CTRL + (res * PCI_CAP_VC_PER_VC_SIZEOF);

commit 274127a1fdbad3c0d64e813521f4a0ef96cfc70e
Author: Alex Williamson <alex.williamson@redhat.com>
Date:   Tue Dec 17 16:43:57 2013 -0700

    PCI: Rename PCI_VC_PORT_REG1/2 to PCI_VC_PORT_CAP1/2
    
    These are set of two capability registers, it's pretty much given that
    they're registers, so reflect their purpose in the name.
    
    Suggested-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/vc.c b/drivers/pci/vc.c
index c10567e4f14f..7e1304d2e389 100644
--- a/drivers/pci/vc.c
+++ b/drivers/pci/vc.c
@@ -104,7 +104,7 @@ static void pci_vc_load_port_arb_table(struct pci_dev *dev, int pos, int res)
 static void pci_vc_enable(struct pci_dev *dev, int pos, int res)
 {
 	int ctrl_pos, status_pos, id, pos2, evcc, i, ctrl_pos2, status_pos2;
-	u32 ctrl, header, reg1, ctrl2;
+	u32 ctrl, header, cap1, ctrl2;
 	struct pci_dev *link = NULL;
 
 	/* Enable VCs from the downstream device */
@@ -129,8 +129,8 @@ static void pci_vc_enable(struct pci_dev *dev, int pos, int res)
 	if (!pos2)
 		goto enable;
 
-	pci_read_config_dword(dev->bus->self, pos2 + PCI_VC_PORT_REG1, &reg1);
-	evcc = reg1 & PCI_VC_REG1_EVCC;
+	pci_read_config_dword(dev->bus->self, pos2 + PCI_VC_PORT_CAP1, &cap1);
+	evcc = cap1 & PCI_VC_CAP1_EVCC;
 
 	/* VC0 is hardwired enabled, so we can start with 1 */
 	for (i = 1; i < evcc + 1; i++) {
@@ -188,7 +188,7 @@ static int pci_vc_do_save_buffer(struct pci_dev *dev, int pos,
 				 struct pci_cap_saved_state *save_state,
 				 bool save)
 {
-	u32 reg1;
+	u32 cap1;
 	char evcc, lpevcc, parb_size;
 	int i, len = 0;
 	u8 *buf = save_state ? (u8 *)save_state->cap.data : NULL;
@@ -201,13 +201,13 @@ static int pci_vc_do_save_buffer(struct pci_dev *dev, int pos,
 		return -ENOMEM;
 	}
 
-	pci_read_config_dword(dev, pos + PCI_VC_PORT_REG1, &reg1);
+	pci_read_config_dword(dev, pos + PCI_VC_PORT_CAP1, &cap1);
 	/* Extended VC Count (not counting VC0) */
-	evcc = reg1 & PCI_VC_REG1_EVCC;
+	evcc = cap1 & PCI_VC_CAP1_EVCC;
 	/* Low Priority Extended VC Count (not counting VC0) */
-	lpevcc = (reg1 & PCI_VC_REG1_LPEVCC) >> 4;
+	lpevcc = (cap1 & PCI_VC_CAP1_LPEVCC) >> 4;
 	/* Port Arbitration Table Entry Size (bits) */
-	parb_size = 1 << ((reg1 & PCI_VC_REG1_ARB_SIZE) >> 10);
+	parb_size = 1 << ((cap1 & PCI_VC_CAP1_ARB_SIZE) >> 10);
 
 	/*
 	 * Port VC Control Register contains VC Arbitration Select, which
@@ -231,20 +231,20 @@ static int pci_vc_do_save_buffer(struct pci_dev *dev, int pos,
 	 * in Port VC Capability Register 2 then save/restore it next.
 	 */
 	if (lpevcc) {
-		u32 reg2;
+		u32 cap2;
 		int vcarb_offset;
 
-		pci_read_config_dword(dev, pos + PCI_VC_PORT_REG2, &reg2);
-		vcarb_offset = ((reg2 & PCI_VC_REG2_ARB_OFF) >> 24) * 16;
+		pci_read_config_dword(dev, pos + PCI_VC_PORT_CAP2, &cap2);
+		vcarb_offset = ((cap2 & PCI_VC_CAP2_ARB_OFF) >> 24) * 16;
 
 		if (vcarb_offset) {
 			int size, vcarb_phases = 0;
 
-			if (reg2 & PCI_VC_REG2_128_PHASE)
+			if (cap2 & PCI_VC_CAP2_128_PHASE)
 				vcarb_phases = 128;
-			else if (reg2 & PCI_VC_REG2_64_PHASE)
+			else if (cap2 & PCI_VC_CAP2_64_PHASE)
 				vcarb_phases = 64;
-			else if (reg2 & PCI_VC_REG2_32_PHASE)
+			else if (cap2 & PCI_VC_CAP2_32_PHASE)
 				vcarb_phases = 32;
 
 			/* Fixed 4 bits per phase per lpevcc (plus VC0) */

commit 425c1b223dac456d00a61fd6b451b6d1cf00d065
Author: Alex Williamson <alex.williamson@redhat.com>
Date:   Tue Dec 17 16:43:51 2013 -0700

    PCI: Add Virtual Channel to save/restore support
    
    While we don't really have any infrastructure for making use of VC
    support, the system BIOS can configure the topology to non-default
    VC values prior to boot.  This may be due to silicon bugs, desire to
    reserve traffic classes, or perhaps just BIOS bugs.  When we reset
    devices, the VC configuration may return to default values, which can
    be incompatible with devices upstream.  For instance, Nvidia GRID
    cards provide a PCIe switch and some number of GPUs, all supporting
    VC.  The power-on default for VC is to support TC0-7 across VC0,
    however some platforms will only enable TC0/VC0 mapping across the
    topology.  When we do a secondary bus reset on the downstream switch
    port, the GPU is reset to a TC0-7/VC0 mapping while the opposite end
    of the link only enables TC0/VC0.  If the GPU attempts to use TC1-7,
    it fails.
    
    This patch attempts to provide complete support for VC save/restore,
    even beyond the minimally required use case above.  This includes
    save/restore and reload of the arbitration table, save/restore and
    reload of the port arbitration tables, and re-enabling of the
    channels for VC, VC9, and MFVC capabilities.
    
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/vc.c b/drivers/pci/vc.c
new file mode 100644
index 000000000000..c10567e4f14f
--- /dev/null
+++ b/drivers/pci/vc.c
@@ -0,0 +1,434 @@
+/*
+ * PCI Virtual Channel support
+ *
+ * Copyright (C) 2013 Red Hat, Inc.  All rights reserved.
+ *     Author: Alex Williamson <alex.williamson@redhat.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/device.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/pci_regs.h>
+#include <linux/types.h>
+
+/**
+ * pci_vc_save_restore_dwords - Save or restore a series of dwords
+ * @dev: device
+ * @pos: starting config space position
+ * @buf: buffer to save to or restore from
+ * @dwords: number of dwords to save/restore
+ * @save: whether to save or restore
+ */
+static void pci_vc_save_restore_dwords(struct pci_dev *dev, int pos,
+				       u32 *buf, int dwords, bool save)
+{
+	int i;
+
+	for (i = 0; i < dwords; i++, buf++) {
+		if (save)
+			pci_read_config_dword(dev, pos + (i * 4), buf);
+		else
+			pci_write_config_dword(dev, pos + (i * 4), *buf);
+	}
+}
+
+/**
+ * pci_vc_load_arb_table - load and wait for VC arbitration table
+ * @dev: device
+ * @pos: starting position of VC capability (VC/VC9/MFVC)
+ *
+ * Set Load VC Arbitration Table bit requesting hardware to apply the VC
+ * Arbitration Table (previously loaded).  When the VC Arbitration Table
+ * Status clears, hardware has latched the table into VC arbitration logic.
+ */
+static void pci_vc_load_arb_table(struct pci_dev *dev, int pos)
+{
+	u16 ctrl;
+
+	pci_read_config_word(dev, pos + PCI_VC_PORT_CTRL, &ctrl);
+	pci_write_config_word(dev, pos + PCI_VC_PORT_CTRL,
+			      ctrl | PCI_VC_PORT_CTRL_LOAD_TABLE);
+	if (pci_wait_for_pending(dev, pos + PCI_VC_PORT_STATUS,
+				 PCI_VC_PORT_STATUS_TABLE))
+		return;
+
+	dev_err(&dev->dev, "VC arbitration table failed to load\n");
+}
+
+/**
+ * pci_vc_load_port_arb_table - Load and wait for VC port arbitration table
+ * @dev: device
+ * @pos: starting position of VC capability (VC/VC9/MFVC)
+ * @res: VC resource number, ie. VCn (0-7)
+ *
+ * Set Load Port Arbitration Table bit requesting hardware to apply the Port
+ * Arbitration Table (previously loaded).  When the Port Arbitration Table
+ * Status clears, hardware has latched the table into port arbitration logic.
+ */
+static void pci_vc_load_port_arb_table(struct pci_dev *dev, int pos, int res)
+{
+	int ctrl_pos, status_pos;
+	u32 ctrl;
+
+	ctrl_pos = pos + PCI_VC_RES_CTRL + (res * PCI_CAP_VC_PER_VC_SIZEOF);
+	status_pos = pos + PCI_VC_RES_STATUS + (res * PCI_CAP_VC_PER_VC_SIZEOF);
+
+	pci_read_config_dword(dev, ctrl_pos, &ctrl);
+	pci_write_config_dword(dev, ctrl_pos,
+			       ctrl | PCI_VC_RES_CTRL_LOAD_TABLE);
+
+	if (pci_wait_for_pending(dev, status_pos, PCI_VC_RES_STATUS_TABLE))
+		return;
+
+	dev_err(&dev->dev, "VC%d port arbitration table failed to load\n", res);
+}
+
+/**
+ * pci_vc_enable - Enable virtual channel
+ * @dev: device
+ * @pos: starting position of VC capability (VC/VC9/MFVC)
+ * @res: VC res number, ie. VCn (0-7)
+ *
+ * A VC is enabled by setting the enable bit in matching resource control
+ * registers on both sides of a link.  We therefore need to find the opposite
+ * end of the link.  To keep this simple we enable from the downstream device.
+ * RC devices do not have an upstream device, nor does it seem that VC9 do
+ * (spec is unclear).  Once we find the upstream device, match the VC ID to
+ * get the correct resource, disable and enable on both ends.
+ */
+static void pci_vc_enable(struct pci_dev *dev, int pos, int res)
+{
+	int ctrl_pos, status_pos, id, pos2, evcc, i, ctrl_pos2, status_pos2;
+	u32 ctrl, header, reg1, ctrl2;
+	struct pci_dev *link = NULL;
+
+	/* Enable VCs from the downstream device */
+	if (pci_pcie_type(dev) == PCI_EXP_TYPE_ROOT_PORT ||
+	    pci_pcie_type(dev) == PCI_EXP_TYPE_DOWNSTREAM)
+		return;
+
+	ctrl_pos = pos + PCI_VC_RES_CTRL + (res * PCI_CAP_VC_PER_VC_SIZEOF);
+	status_pos = pos + PCI_VC_RES_STATUS + (res * PCI_CAP_VC_PER_VC_SIZEOF);
+
+	pci_read_config_dword(dev, ctrl_pos, &ctrl);
+	id = ctrl & PCI_VC_RES_CTRL_ID;
+
+	pci_read_config_dword(dev, pos, &header);
+
+	/* If there is no opposite end of the link, skip to enable */
+	if (PCI_EXT_CAP_ID(header) == PCI_EXT_CAP_ID_VC9 ||
+	    pci_is_root_bus(dev->bus))
+		goto enable;
+
+	pos2 = pci_find_ext_capability(dev->bus->self, PCI_EXT_CAP_ID_VC);
+	if (!pos2)
+		goto enable;
+
+	pci_read_config_dword(dev->bus->self, pos2 + PCI_VC_PORT_REG1, &reg1);
+	evcc = reg1 & PCI_VC_REG1_EVCC;
+
+	/* VC0 is hardwired enabled, so we can start with 1 */
+	for (i = 1; i < evcc + 1; i++) {
+		ctrl_pos2 = pos2 + PCI_VC_RES_CTRL +
+				(i * PCI_CAP_VC_PER_VC_SIZEOF);
+		status_pos2 = pos2 + PCI_VC_RES_STATUS +
+				(i * PCI_CAP_VC_PER_VC_SIZEOF);
+		pci_read_config_dword(dev->bus->self, ctrl_pos2, &ctrl2);
+		if ((ctrl2 & PCI_VC_RES_CTRL_ID) == id) {
+			link = dev->bus->self;
+			break;
+		}
+	}
+
+	if (!link)
+		goto enable;
+
+	/* Disable if enabled */
+	if (ctrl2 & PCI_VC_RES_CTRL_ENABLE) {
+		ctrl2 &= ~PCI_VC_RES_CTRL_ENABLE;
+		pci_write_config_dword(link, ctrl_pos2, ctrl2);
+	}
+
+	/* Enable on both ends */
+	ctrl2 |= PCI_VC_RES_CTRL_ENABLE;
+	pci_write_config_dword(link, ctrl_pos2, ctrl2);
+enable:
+	ctrl |= PCI_VC_RES_CTRL_ENABLE;
+	pci_write_config_dword(dev, ctrl_pos, ctrl);
+
+	if (!pci_wait_for_pending(dev, status_pos, PCI_VC_RES_STATUS_NEGO))
+		dev_err(&dev->dev, "VC%d negotiation stuck pending\n", id);
+
+	if (link && !pci_wait_for_pending(link, status_pos2,
+					  PCI_VC_RES_STATUS_NEGO))
+		dev_err(&link->dev, "VC%d negotiation stuck pending\n", id);
+}
+
+/**
+ * pci_vc_do_save_buffer - Size, save, or restore VC state
+ * @dev: device
+ * @pos: starting position of VC capability (VC/VC9/MFVC)
+ * @save_state: buffer for save/restore
+ * @name: for error message
+ * @save: if provided a buffer, this indicates what to do with it
+ *
+ * Walking Virtual Channel config space to size, save, or restore it
+ * is complicated, so we do it all from one function to reduce code and
+ * guarantee ordering matches in the buffer.  When called with NULL
+ * @save_state, return the size of the necessary save buffer.  When called
+ * with a non-NULL @save_state, @save determines whether we save to the
+ * buffer or restore from it.
+ */
+static int pci_vc_do_save_buffer(struct pci_dev *dev, int pos,
+				 struct pci_cap_saved_state *save_state,
+				 bool save)
+{
+	u32 reg1;
+	char evcc, lpevcc, parb_size;
+	int i, len = 0;
+	u8 *buf = save_state ? (u8 *)save_state->cap.data : NULL;
+
+	/* Sanity check buffer size for save/restore */
+	if (buf && save_state->cap.size !=
+	    pci_vc_do_save_buffer(dev, pos, NULL, save)) {
+		dev_err(&dev->dev,
+			"VC save buffer size does not match @0x%x\n", pos);
+		return -ENOMEM;
+	}
+
+	pci_read_config_dword(dev, pos + PCI_VC_PORT_REG1, &reg1);
+	/* Extended VC Count (not counting VC0) */
+	evcc = reg1 & PCI_VC_REG1_EVCC;
+	/* Low Priority Extended VC Count (not counting VC0) */
+	lpevcc = (reg1 & PCI_VC_REG1_LPEVCC) >> 4;
+	/* Port Arbitration Table Entry Size (bits) */
+	parb_size = 1 << ((reg1 & PCI_VC_REG1_ARB_SIZE) >> 10);
+
+	/*
+	 * Port VC Control Register contains VC Arbitration Select, which
+	 * cannot be modified when more than one LPVC is in operation.  We
+	 * therefore save/restore it first, as only VC0 should be enabled
+	 * after device reset.
+	 */
+	if (buf) {
+		if (save)
+			pci_read_config_word(dev, pos + PCI_VC_PORT_CTRL,
+					     (u16 *)buf);
+		else
+			pci_write_config_word(dev, pos + PCI_VC_PORT_CTRL,
+					      *(u16 *)buf);
+		buf += 2;
+	}
+	len += 2;
+
+	/*
+	 * If we have any Low Priority VCs and a VC Arbitration Table Offset
+	 * in Port VC Capability Register 2 then save/restore it next.
+	 */
+	if (lpevcc) {
+		u32 reg2;
+		int vcarb_offset;
+
+		pci_read_config_dword(dev, pos + PCI_VC_PORT_REG2, &reg2);
+		vcarb_offset = ((reg2 & PCI_VC_REG2_ARB_OFF) >> 24) * 16;
+
+		if (vcarb_offset) {
+			int size, vcarb_phases = 0;
+
+			if (reg2 & PCI_VC_REG2_128_PHASE)
+				vcarb_phases = 128;
+			else if (reg2 & PCI_VC_REG2_64_PHASE)
+				vcarb_phases = 64;
+			else if (reg2 & PCI_VC_REG2_32_PHASE)
+				vcarb_phases = 32;
+
+			/* Fixed 4 bits per phase per lpevcc (plus VC0) */
+			size = ((lpevcc + 1) * vcarb_phases * 4) / 8;
+
+			if (size && buf) {
+				pci_vc_save_restore_dwords(dev,
+							   pos + vcarb_offset,
+							   (u32 *)buf,
+							   size / 4, save);
+				/*
+				 * On restore, we need to signal hardware to
+				 * re-load the VC Arbitration Table.
+				 */
+				if (!save)
+					pci_vc_load_arb_table(dev, pos);
+
+				buf += size;
+			}
+			len += size;
+		}
+	}
+
+	/*
+	 * In addition to each VC Resource Control Register, we may have a
+	 * Port Arbitration Table attached to each VC.  The Port Arbitration
+	 * Table Offset in each VC Resource Capability Register tells us if
+	 * it exists.  The entry size is global from the Port VC Capability
+	 * Register1 above.  The number of phases is determined per VC.
+	 */
+	for (i = 0; i < evcc + 1; i++) {
+		u32 cap;
+		int parb_offset;
+
+		pci_read_config_dword(dev, pos + PCI_VC_RES_CAP +
+				      (i * PCI_CAP_VC_PER_VC_SIZEOF), &cap);
+		parb_offset = ((cap & PCI_VC_RES_CAP_ARB_OFF) >> 24) * 16;
+		if (parb_offset) {
+			int size, parb_phases = 0;
+
+			if (cap & PCI_VC_RES_CAP_256_PHASE)
+				parb_phases = 256;
+			else if (cap & (PCI_VC_RES_CAP_128_PHASE |
+					PCI_VC_RES_CAP_128_PHASE_TB))
+				parb_phases = 128;
+			else if (cap & PCI_VC_RES_CAP_64_PHASE)
+				parb_phases = 64;
+			else if (cap & PCI_VC_RES_CAP_32_PHASE)
+				parb_phases = 32;
+
+			size = (parb_size * parb_phases) / 8;
+
+			if (size && buf) {
+				pci_vc_save_restore_dwords(dev,
+							   pos + parb_offset,
+							   (u32 *)buf,
+							   size / 4, save);
+				buf += size;
+			}
+			len += size;
+		}
+
+		/* VC Resource Control Register */
+		if (buf) {
+			int ctrl_pos = pos + PCI_VC_RES_CTRL +
+						(i * PCI_CAP_VC_PER_VC_SIZEOF);
+			if (save)
+				pci_read_config_dword(dev, ctrl_pos,
+						      (u32 *)buf);
+			else {
+				u32 tmp, ctrl = *(u32 *)buf;
+				/*
+				 * For an FLR case, the VC config may remain.
+				 * Preserve enable bit, restore the rest.
+				 */
+				pci_read_config_dword(dev, ctrl_pos, &tmp);
+				tmp &= PCI_VC_RES_CTRL_ENABLE;
+				tmp |= ctrl & ~PCI_VC_RES_CTRL_ENABLE;
+				pci_write_config_dword(dev, ctrl_pos, tmp);
+				/* Load port arbitration table if used */
+				if (ctrl & PCI_VC_RES_CTRL_ARB_SELECT)
+					pci_vc_load_port_arb_table(dev, pos, i);
+				/* Re-enable if needed */
+				if ((ctrl ^ tmp) & PCI_VC_RES_CTRL_ENABLE)
+					pci_vc_enable(dev, pos, i);
+			}
+			buf += 4;
+		}
+		len += 4;
+	}
+
+	return buf ? 0 : len;
+}
+
+static struct {
+	u16 id;
+	const char *name;
+} vc_caps[] = { { PCI_EXT_CAP_ID_MFVC, "MFVC" },
+		{ PCI_EXT_CAP_ID_VC, "VC" },
+		{ PCI_EXT_CAP_ID_VC9, "VC9" } };
+
+/**
+ * pci_save_vc_state - Save VC state to pre-allocate save buffer
+ * @dev: device
+ *
+ * For each type of VC capability, VC/VC9/MFVC, find the capability and
+ * save it to the pre-allocated save buffer.
+ */
+int pci_save_vc_state(struct pci_dev *dev)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(vc_caps); i++) {
+		int pos, ret;
+		struct pci_cap_saved_state *save_state;
+
+		pos = pci_find_ext_capability(dev, vc_caps[i].id);
+		if (!pos)
+			continue;
+
+		save_state = pci_find_saved_ext_cap(dev, vc_caps[i].id);
+		if (!save_state) {
+			dev_err(&dev->dev, "%s buffer not found in %s\n",
+				vc_caps[i].name, __func__);
+			return -ENOMEM;
+		}
+
+		ret = pci_vc_do_save_buffer(dev, pos, save_state, true);
+		if (ret) {
+			dev_err(&dev->dev, "%s save unsuccessful %s\n",
+				vc_caps[i].name, __func__);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+/**
+ * pci_restore_vc_state - Restore VC state from save buffer
+ * @dev: device
+ *
+ * For each type of VC capability, VC/VC9/MFVC, find the capability and
+ * restore it from the previously saved buffer.
+ */
+void pci_restore_vc_state(struct pci_dev *dev)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(vc_caps); i++) {
+		int pos;
+		struct pci_cap_saved_state *save_state;
+
+		pos = pci_find_ext_capability(dev, vc_caps[i].id);
+		save_state = pci_find_saved_ext_cap(dev, vc_caps[i].id);
+		if (!save_state || !pos)
+			continue;
+
+		pci_vc_do_save_buffer(dev, pos, save_state, false);
+	}
+}
+
+/**
+ * pci_allocate_vc_save_buffers - Allocate save buffers for VC caps
+ * @dev: device
+ *
+ * For each type of VC capability, VC/VC9/MFVC, find the capability, size
+ * it, and allocate a buffer for save/restore.
+ */
+
+void pci_allocate_vc_save_buffers(struct pci_dev *dev)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(vc_caps); i++) {
+		int len, pos = pci_find_ext_capability(dev, vc_caps[i].id);
+
+		if (!pos)
+			continue;
+
+		len = pci_vc_do_save_buffer(dev, pos, NULL, false);
+		if (pci_add_ext_cap_save_buffer(dev, vc_caps[i].id, len))
+			dev_err(&dev->dev,
+				"unable to preallocate %s save buffer\n",
+				vc_caps[i].name);
+	}
+}
