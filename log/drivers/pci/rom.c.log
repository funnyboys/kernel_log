commit 72e0ef0e5f067fd991f702f0b2635d911d0cf208
Author: Mikel Rychliski <mikel@mikelr.com>
Date:   Wed Mar 18 22:16:23 2020 -0400

    PCI: Use ioremap(), not phys_to_virt() for platform ROM
    
    On some EFI systems, the video BIOS is provided by the EFI firmware.  The
    boot stub code stores the physical address of the ROM image in pdev->rom.
    Currently we attempt to access this pointer using phys_to_virt(), which
    doesn't work with CONFIG_HIGHMEM.
    
    On these systems, attempting to load the radeon module on a x86_32 kernel
    can result in the following:
    
      BUG: unable to handle page fault for address: 3e8ed03c
      #PF: supervisor read access in kernel mode
      #PF: error_code(0x0000) - not-present page
      *pde = 00000000
      Oops: 0000 [#1] PREEMPT SMP
      CPU: 0 PID: 317 Comm: systemd-udevd Not tainted 5.6.0-rc3-next-20200228 #2
      Hardware name: Apple Computer, Inc. MacPro1,1/Mac-F4208DC8, BIOS     MP11.88Z.005C.B08.0707021221 07/02/07
      EIP: radeon_get_bios+0x5ed/0xe50 [radeon]
      Code: 00 00 84 c0 0f 85 12 fd ff ff c7 87 64 01 00 00 00 00 00 00 8b 47 08 8b 55 b0 e8 1e 83 e1 d6 85 c0 74 1a 8b 55 c0 85 d2 74 13 <80> 38 55 75 0e 80 78 01 aa 0f 84 a4 03 00 00 8d 74 26 00 68 dc 06
      EAX: 3e8ed03c EBX: 00000000 ECX: 3e8ed03c EDX: 00010000
      ESI: 00040000 EDI: eec04000 EBP: eef3fc60 ESP: eef3fbe0
      DS: 007b ES: 007b FS: 00d8 GS: 00e0 SS: 0068 EFLAGS: 00010206
      CR0: 80050033 CR2: 3e8ed03c CR3: 2ec77000 CR4: 000006d0
      Call Trace:
       r520_init+0x26/0x240 [radeon]
       radeon_device_init+0x533/0xa50 [radeon]
       radeon_driver_load_kms+0x80/0x220 [radeon]
       drm_dev_register+0xa7/0x180 [drm]
       radeon_pci_probe+0x10f/0x1a0 [radeon]
       pci_device_probe+0xd4/0x140
    
    Fix the issue by updating all drivers which can access a platform provided
    ROM. Instead of calling the helper function pci_platform_rom() which uses
    phys_to_virt(), call ioremap() directly on the pdev->rom.
    
    radeon_read_platform_bios() previously directly accessed an __iomem
    pointer. Avoid this by calling memcpy_fromio() instead of kmemdup().
    
    pci_platform_rom() now has no remaining callers, so remove it.
    
    Link: https://lore.kernel.org/r/20200319021623.5426-1-mikel@mikelr.com
    Signed-off-by: Mikel Rychliski <mikel@mikelr.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/pci/rom.c b/drivers/pci/rom.c
index 137bf0cee897..8fc9a4e911e3 100644
--- a/drivers/pci/rom.c
+++ b/drivers/pci/rom.c
@@ -195,20 +195,3 @@ void pci_unmap_rom(struct pci_dev *pdev, void __iomem *rom)
 		pci_disable_rom(pdev);
 }
 EXPORT_SYMBOL(pci_unmap_rom);
-
-/**
- * pci_platform_rom - provides a pointer to any ROM image provided by the
- * platform
- * @pdev: pointer to pci device struct
- * @size: pointer to receive size of pci window over ROM
- */
-void __iomem *pci_platform_rom(struct pci_dev *pdev, size_t *size)
-{
-	if (pdev->rom && pdev->romlen) {
-		*size = pdev->romlen;
-		return phys_to_virt((phys_addr_t)pdev->rom);
-	}
-
-	return NULL;
-}
-EXPORT_SYMBOL(pci_platform_rom);

commit 783e84961b1d7a75045383586b8c49e02b7704cd
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Jun 29 21:17:26 2018 -0500

    PCI: Make pci_get_rom_size() static
    
    pci_get_rom_size() is called only from pci_map_rom(), so it can be static.
    Make it static and remove the declaration from include/linux/pci.h.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/rom.c b/drivers/pci/rom.c
index 3a33f5ce314a..137bf0cee897 100644
--- a/drivers/pci/rom.c
+++ b/drivers/pci/rom.c
@@ -80,7 +80,8 @@ EXPORT_SYMBOL_GPL(pci_disable_rom);
  * The PCI window size could be much larger than the
  * actual image size.
  */
-size_t pci_get_rom_size(struct pci_dev *pdev, void __iomem *rom, size_t size)
+static size_t pci_get_rom_size(struct pci_dev *pdev, void __iomem *rom,
+			       size_t size)
 {
 	void __iomem *image;
 	int last_image;

commit beced88e6af43c9653cee09f5111ae7495824e07
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Tue Jun 5 09:46:46 2018 +0800

    PCI: Add check code for last image indicator not set
    
    If the "last image" indicator was not set in the PCI data struct, print "No
    more image in the PCI ROM" instead of looping back and printing "Invalid
    PCI ROM header signature".
    
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/pci/rom.c b/drivers/pci/rom.c
index 946795fc0071..3a33f5ce314a 100644
--- a/drivers/pci/rom.c
+++ b/drivers/pci/rom.c
@@ -108,6 +108,12 @@ size_t pci_get_rom_size(struct pci_dev *pdev, void __iomem *rom, size_t size)
 		/* Avoid iterating through memory outside the resource window */
 		if (image >= rom + size)
 			break;
+		if (!last_image) {
+			if (readw(image) != 0xAA55) {
+				pci_info(pdev, "No more image in the PCI ROM\n");
+				break;
+			}
+		}
 	} while (length && !last_image);
 
 	/* never return a size larger than the PCI resource window */

commit 445ec321e71b3124abacfb358f72ac6a70d87602
Author: Rex Zhu <Rex.Zhu@amd.com>
Date:   Tue Jun 5 09:46:45 2018 +0800

    PCI: Avoid accessing memory outside the ROM BAR
    
    pci_get_rom_size() accepts the base and size of the ROM BAR as arguments.
    The byte at "rom + size" is the first byte *past* the ROM, so change ">" to
    ">=" to avoid accessing beyond the actual length of the ROM BAR.
    
    Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
    [bhelgaas: changelog]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/pci/rom.c b/drivers/pci/rom.c
index a7b5c37a85ec..946795fc0071 100644
--- a/drivers/pci/rom.c
+++ b/drivers/pci/rom.c
@@ -106,7 +106,7 @@ size_t pci_get_rom_size(struct pci_dev *pdev, void __iomem *rom, size_t size)
 		length = readw(pds + 16);
 		image += length * 512;
 		/* Avoid iterating through memory outside the resource window */
-		if (image > rom + size)
+		if (image >= rom + size)
 			break;
 	} while (length && !last_image);
 

commit df62ab5e0f75608919df7442654b0fab78246b7b
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Mar 9 16:36:33 2018 -0600

    PCI: Tidy comments
    
    Remove pointless comments that tell us the file name, remove blank line
    comments, follow multi-line comment conventions.  No functional change
    intended.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/rom.c b/drivers/pci/rom.c
index 374a33443be9..a7b5c37a85ec 100644
--- a/drivers/pci/rom.c
+++ b/drivers/pci/rom.c
@@ -1,11 +1,9 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * drivers/pci/rom.c
+ * PCI ROM access routines
  *
  * (C) Copyright 2004 Jon Smirl <jonsmirl@yahoo.com>
  * (C) Copyright 2004 Silicon Graphics, Inc. Jesse Barnes <jbarnes@sgi.com>
- *
- * PCI ROM access routines
  */
 #include <linux/kernel.h>
 #include <linux/export.h>

commit ab8c609356fbe8dbcd44df11e884ce8cddf3739e
Merge: a5fae846f21d 36b072742a83
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Feb 1 11:40:07 2018 -0600

    Merge branch 'pci/spdx' into next
    
    * pci/spdx:
      PCI: Add SPDX GPL-2.0+ to replace implicit GPL v2 or later statement
      PCI: Add SPDX GPL-2.0+ to replace GPL v2 or later boilerplate
      PCI: Add SPDX GPL-2.0 to replace COPYING boilerplate
      PCI: Add SPDX GPL-2.0 to replace GPL v2 boilerplate
      PCI: Add SPDX GPL-2.0 when no license was specified

commit 414ae7609e19580a56647344e61f13f3768e0820
Merge: 11377725da46 a9b94b74806b
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Jan 31 10:12:56 2018 -0600

    Merge branch 'pci/resource' into next
    
    * pci/resource:
      PCI: tegra: Remove PCI_REASSIGN_ALL_BUS use on Tegra
      resource: Set type when reserving new regions
      resource: Set type of "reserve=" user-specified resources
      irqchip/i8259: Set I/O port resource types correctly
      powerpc: Set I/O port resource types correctly
      MIPS: Set I/O port resource types correctly
      vgacon: Set VGA struct resource types
      PCI: Use dev_info() rather than dev_err() for ROM validation
      PCI: Remove PCI_REASSIGN_ALL_RSRC use on arm and arm64
      PCI: Remove sysfs resource mmap warning
    
    Conflicts:
            drivers/pci/rom.c

commit 7328c8f48d1895b3fec98b0b319cfb856b4c4fa1
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Jan 26 11:45:16 2018 -0600

    PCI: Add SPDX GPL-2.0 when no license was specified
    
    b24413180f56 ("License cleanup: add SPDX GPL-2.0 license identifier to
    files with no license") added SPDX GPL-2.0 to several PCI files that
    previously contained no license information.
    
    Add SPDX GPL-2.0 to all other PCI files that did not contain any license
    information and hence were under the default GPL version 2 license of the
    kernel.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pci/rom.c b/drivers/pci/rom.c
index 1f5e6af96c83..9ba3fa841eb0 100644
--- a/drivers/pci/rom.c
+++ b/drivers/pci/rom.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * drivers/pci/rom.c
  *

commit 7506dc7989933235e6fc23f3d0516bdbf0f7d1a8
Author: Frederick Lawler <fred@fredlawl.com>
Date:   Thu Jan 18 12:55:24 2018 -0600

    PCI: Add wrappers for dev_printk()
    
    Add PCI-specific dev_printk() wrappers and use them to simplify the code
    slightly.  No functional change intended.
    
    Signed-off-by: Frederick Lawler <fred@fredlawl.com>
    [bhelgaas: squash into one patch]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/rom.c b/drivers/pci/rom.c
index 1f5e6af96c83..61f9e8a5ea8b 100644
--- a/drivers/pci/rom.c
+++ b/drivers/pci/rom.c
@@ -92,14 +92,14 @@ size_t pci_get_rom_size(struct pci_dev *pdev, void __iomem *rom, size_t size)
 		void __iomem *pds;
 		/* Standard PCI ROMs start out with these bytes 55 AA */
 		if (readw(image) != 0xAA55) {
-			dev_err(&pdev->dev, "Invalid PCI ROM header signature: expecting 0xaa55, got %#06x\n",
+			pci_err(pdev, "Invalid PCI ROM header signature: expecting 0xaa55, got %#06x\n",
 				readw(image));
 			break;
 		}
 		/* get the PCI data structure and check its "PCIR" signature */
 		pds = image + readw(image + 24);
 		if (readl(pds) != 0x52494350) {
-			dev_err(&pdev->dev, "Invalid PCI ROM data signature: expecting 0x52494350, got %#010x\n",
+			pci_err(pdev, "Invalid PCI ROM data signature: expecting 0x52494350, got %#010x\n",
 				readl(pds));
 			break;
 		}

commit 116a6063cac3107d5abfe7bd14fc01a19271b14a
Author: Alex Deucher <alexdeucher@gmail.com>
Date:   Mon Nov 27 12:21:10 2017 -0500

    PCI: Use dev_info() rather than dev_err() for ROM validation
    
    On AMD GPUs, we use several mechanisms to fetch the VBIOS ROM depending on
    the platform.  We try to read the ROM via the ROM BAR and fall back to
    other methods in some cases.  This leads to spurious error messages from
    the PCI ROM code which are harmless in our case.  This leads to bugs being
    filed, etc.  Change these to dev_info() rather than dev_err() to avoid
    that.
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=198077
    Link: https://bugzilla.redhat.com/show_bug.cgi?id=1462438
    Link: https://bugs.freedesktop.org/show_bug.cgi?id=98798
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Christian König <christian.koenig@amd.com

diff --git a/drivers/pci/rom.c b/drivers/pci/rom.c
index 1f5e6af96c83..68ab7c17955a 100644
--- a/drivers/pci/rom.c
+++ b/drivers/pci/rom.c
@@ -92,14 +92,14 @@ size_t pci_get_rom_size(struct pci_dev *pdev, void __iomem *rom, size_t size)
 		void __iomem *pds;
 		/* Standard PCI ROMs start out with these bytes 55 AA */
 		if (readw(image) != 0xAA55) {
-			dev_err(&pdev->dev, "Invalid PCI ROM header signature: expecting 0xaa55, got %#06x\n",
+			dev_info(&pdev->dev, "Invalid PCI ROM header signature: expecting 0xaa55, got %#06x\n",
 				readw(image));
 			break;
 		}
 		/* get the PCI data structure and check its "PCIR" signature */
 		pds = image + readw(image + 24);
 		if (readl(pds) != 0x52494350) {
-			dev_err(&pdev->dev, "Invalid PCI ROM data signature: expecting 0x52494350, got %#010x\n",
+			dev_info(&pdev->dev, "Invalid PCI ROM data signature: expecting 0x52494350, got %#010x\n",
 				readl(pds));
 			break;
 		}

commit a405f191f42ead45a03c000110a16683d30f7333
Author: Changbin Du <changbin.du@intel.com>
Date:   Tue Nov 7 18:26:53 2017 -0600

    PCI: Fail pci_map_rom() if the option ROM is invalid
    
    If we detect a invalid PCI option ROM (e.g., invalid ROM header signature),
    we should unmap it immediately and fail. It doesn't make any sense to
    return a mapped area with size of 0.
    
    I have seen this case on Intel GVTg vGPU, which has no VBIOS. It will not
    cause a real problem, but we should skip it as early as possible.
    
    Signed-off-by: Changbin Du <changbin.du@intel.com>
    [bhelgaas: split non-functional change into separate patch]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/rom.c b/drivers/pci/rom.c
index 0decf0d81cf5..1f5e6af96c83 100644
--- a/drivers/pci/rom.c
+++ b/drivers/pci/rom.c
@@ -156,8 +156,13 @@ void __iomem *pci_map_rom(struct pci_dev *pdev, size_t *size)
 	 * True size is important if the ROM is going to be copied.
 	 */
 	*size = pci_get_rom_size(pdev, rom, *size);
+	if (!*size)
+		goto invalid_rom;
+
 	return rom;
 
+invalid_rom:
+	iounmap(rom);
 err_ioremap:
 	/* restore enable if ioremap fails */
 	if (!(res->flags & IORESOURCE_ROM_ENABLE))

commit a48a687d8cdf9a51a6283cc91f9637403b221ed3
Author: Changbin Du <changbin.du@intel.com>
Date:   Tue Nov 7 18:22:26 2017 -0600

    PCI: Move pci_map_rom() error path
    
    Move pci_map_rom() error code to the end to prepare for adding another
    error path.  No functional change intended.
    
    Signed-off-by: Changbin Du <changbin.du@intel.com>
    [bhelgaas: split non-functional change into separate patch]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/rom.c b/drivers/pci/rom.c
index b6edb187d160..0decf0d81cf5 100644
--- a/drivers/pci/rom.c
+++ b/drivers/pci/rom.c
@@ -147,12 +147,8 @@ void __iomem *pci_map_rom(struct pci_dev *pdev, size_t *size)
 		return NULL;
 
 	rom = ioremap(start, *size);
-	if (!rom) {
-		/* restore enable if ioremap fails */
-		if (!(res->flags & IORESOURCE_ROM_ENABLE))
-			pci_disable_rom(pdev);
-		return NULL;
-	}
+	if (!rom)
+		goto err_ioremap;
 
 	/*
 	 * Try to find the true size of the ROM since sometimes the PCI window
@@ -161,6 +157,12 @@ void __iomem *pci_map_rom(struct pci_dev *pdev, size_t *size)
 	 */
 	*size = pci_get_rom_size(pdev, rom, *size);
 	return rom;
+
+err_ioremap:
+	/* restore enable if ioremap fails */
+	if (!(res->flags & IORESOURCE_ROM_ENABLE))
+		pci_disable_rom(pdev);
+	return NULL;
 }
 EXPORT_SYMBOL(pci_map_rom);
 

commit 0b457dde3cf8b7c76a60f8e960f21bbd4abdc416
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Nov 28 16:17:41 2016 -0600

    PCI: Add comments about ROM BAR updating
    
    pci_update_resource() updates a hardware BAR so its address matches the
    kernel's struct resource UNLESS it's a disabled ROM BAR.  We only update
    those when we enable the ROM.
    
    It's not obvious from the code why ROM BARs should be handled specially.
    Apparently there are Matrox devices with defective ROM BARs that read as
    zero when disabled.  That means that if pci_enable_rom() reads the disabled
    BAR, sets PCI_ROM_ADDRESS_ENABLE (without re-inserting the address), and
    writes it back, it would enable the ROM at address zero.
    
    Add comments and references to explain why we can't make the code look more
    rational.
    
    The code changes are from 755528c860b0 ("Ignore disabled ROM resources at
    setup") and 8085ce084c0f ("[PATCH] Fix PCI ROM mapping").
    
    Link: https://lkml.org/lkml/2005/8/30/138
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Gavin Shan <gwshan@linux.vnet.ibm.com>

diff --git a/drivers/pci/rom.c b/drivers/pci/rom.c
index 06663d391b39..b6edb187d160 100644
--- a/drivers/pci/rom.c
+++ b/drivers/pci/rom.c
@@ -35,6 +35,11 @@ int pci_enable_rom(struct pci_dev *pdev)
 	if (res->flags & IORESOURCE_ROM_SHADOW)
 		return 0;
 
+	/*
+	 * Ideally pci_update_resource() would update the ROM BAR address,
+	 * and we would only set the enable bit here.  But apparently some
+	 * devices have buggy ROM BARs that read as zero when disabled.
+	 */
 	pcibios_resource_to_bus(pdev->bus, &region, res);
 	pci_read_config_dword(pdev, pdev->rom_base_reg, &rom_addr);
 	rom_addr &= ~PCI_ROM_ADDRESS_MASK;

commit d9c8bea179a6906a74ea42a2a162c4d1c6d9a16b
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Mar 2 21:46:50 2016 -0600

    PCI: Remove unused IORESOURCE_ROM_COPY and IORESOURCE_ROM_BIOS_COPY
    
    The IORESOURCE_ROM_COPY and IORESOURCE_ROM_BIOS_COPY bits are unused.
    Remove them and code that depends on them.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/rom.c b/drivers/pci/rom.c
index 2a07f344616e..06663d391b39 100644
--- a/drivers/pci/rom.c
+++ b/drivers/pci/rom.c
@@ -128,12 +128,6 @@ void __iomem *pci_map_rom(struct pci_dev *pdev, size_t *size)
 	loff_t start;
 	void __iomem *rom;
 
-	if (res->flags & (IORESOURCE_ROM_COPY | IORESOURCE_ROM_BIOS_COPY)) {
-		*size = pci_resource_len(pdev, PCI_ROM_RESOURCE);
-		return (void __iomem *)(unsigned long)
-			pci_resource_start(pdev, PCI_ROM_RESOURCE);
-	}
-
 	/* assign the ROM an address if it doesn't have one */
 	if (res->parent == NULL && pci_assign_resource(pdev, PCI_ROM_RESOURCE))
 		return NULL;
@@ -150,8 +144,7 @@ void __iomem *pci_map_rom(struct pci_dev *pdev, size_t *size)
 	rom = ioremap(start, *size);
 	if (!rom) {
 		/* restore enable if ioremap fails */
-		if (!(res->flags & (IORESOURCE_ROM_ENABLE |
-				    IORESOURCE_ROM_COPY)))
+		if (!(res->flags & IORESOURCE_ROM_ENABLE))
 			pci_disable_rom(pdev);
 		return NULL;
 	}
@@ -177,9 +170,6 @@ void pci_unmap_rom(struct pci_dev *pdev, void __iomem *rom)
 {
 	struct resource *res = &pdev->resource[PCI_ROM_RESOURCE];
 
-	if (res->flags & (IORESOURCE_ROM_COPY | IORESOURCE_ROM_BIOS_COPY))
-		return;
-
 	iounmap(rom);
 
 	/* Disable again before continuing */
@@ -188,25 +178,6 @@ void pci_unmap_rom(struct pci_dev *pdev, void __iomem *rom)
 }
 EXPORT_SYMBOL(pci_unmap_rom);
 
-/**
- * pci_cleanup_rom - free the ROM copy created by pci_map_rom_copy
- * @pdev: pointer to pci device struct
- *
- * Free the copied ROM if we allocated one.
- */
-void pci_cleanup_rom(struct pci_dev *pdev)
-{
-	struct resource *res = &pdev->resource[PCI_ROM_RESOURCE];
-
-	if (res->flags & IORESOURCE_ROM_COPY) {
-		kfree((void *)(unsigned long)res->start);
-		res->flags |= IORESOURCE_UNSET;
-		res->flags &= ~IORESOURCE_ROM_COPY;
-		res->start = 0;
-		res->end = 0;
-	}
-}
-
 /**
  * pci_platform_rom - provides a pointer to any ROM image provided by the
  * platform

commit f50dd8c3dae5703704441ab2255dff99c021a340
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Mar 1 11:13:30 2016 -0600

    PCI: Clean up pci_map_rom() whitespace
    
    Remove unnecessary indentation in pci_map_rom().  This is logically part of
    the previous patch; I split it out to make the critical changes in that
    patch more obvious.  No functional change intended.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/rom.c b/drivers/pci/rom.c
index 80e82b13292f..2a07f344616e 100644
--- a/drivers/pci/rom.c
+++ b/drivers/pci/rom.c
@@ -128,25 +128,24 @@ void __iomem *pci_map_rom(struct pci_dev *pdev, size_t *size)
 	loff_t start;
 	void __iomem *rom;
 
-		if (res->flags &
-			(IORESOURCE_ROM_COPY | IORESOURCE_ROM_BIOS_COPY)) {
-			*size = pci_resource_len(pdev, PCI_ROM_RESOURCE);
-			return (void __iomem *)(unsigned long)
-				pci_resource_start(pdev, PCI_ROM_RESOURCE);
-		} else {
-			/* assign the ROM an address if it doesn't have one */
-			if (res->parent == NULL &&
-			    pci_assign_resource(pdev, PCI_ROM_RESOURCE))
-				return NULL;
-			start = pci_resource_start(pdev, PCI_ROM_RESOURCE);
-			*size = pci_resource_len(pdev, PCI_ROM_RESOURCE);
-			if (*size == 0)
-				return NULL;
-
-			/* Enable ROM space decodes */
-			if (pci_enable_rom(pdev))
-				return NULL;
-		}
+	if (res->flags & (IORESOURCE_ROM_COPY | IORESOURCE_ROM_BIOS_COPY)) {
+		*size = pci_resource_len(pdev, PCI_ROM_RESOURCE);
+		return (void __iomem *)(unsigned long)
+			pci_resource_start(pdev, PCI_ROM_RESOURCE);
+	}
+
+	/* assign the ROM an address if it doesn't have one */
+	if (res->parent == NULL && pci_assign_resource(pdev, PCI_ROM_RESOURCE))
+		return NULL;
+
+	start = pci_resource_start(pdev, PCI_ROM_RESOURCE);
+	*size = pci_resource_len(pdev, PCI_ROM_RESOURCE);
+	if (*size == 0)
+		return NULL;
+
+	/* Enable ROM space decodes */
+	if (pci_enable_rom(pdev))
+		return NULL;
 
 	rom = ioremap(start, *size);
 	if (!rom) {

commit 0c0e0736acad4e76e718456c75d78ad95eea0011
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Mar 1 11:38:46 2016 -0600

    PCI: Set ROM shadow location in arch code, not in PCI core
    
    IORESOURCE_ROM_SHADOW means there is a copy of a device's option ROM in
    RAM.  The existence of such a copy and its location are arch-specific.
    Previously the IORESOURCE_ROM_SHADOW flag was set in arch code, but the
    0xC0000-0xDFFFF location was hard-coded into the PCI core.
    
    If we're using a shadow copy in RAM, disable the ROM BAR and release the
    address space it was consuming.  Move the location information from the PCI
    core to the arch code that sets IORESOURCE_ROM_SHADOW.  Save the location
    of the RAM copy in the struct resource for PCI_ROM_RESOURCE.
    
    After this change, pci_map_rom() will call pci_assign_resource() and
    pci_enable_rom() for these IORESOURCE_ROM_SHADOW resources, which we did
    not do before.  This is safe because:
    
      - pci_assign_resource() will do nothing because the resource is marked
        IORESOURCE_PCI_FIXED, which means we can't move it, and
    
      - pci_enable_rom() will not turn on the ROM BAR's enable bit because the
        resource is marked IORESOURCE_ROM_SHADOW, which means it is in RAM
        rather than in PCI memory space.
    
    Storing the location in the struct resource means "lspci" will show the
    shadow location, not the value from the ROM BAR.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/rom.c b/drivers/pci/rom.c
index 5da8d061d600..80e82b13292f 100644
--- a/drivers/pci/rom.c
+++ b/drivers/pci/rom.c
@@ -128,16 +128,6 @@ void __iomem *pci_map_rom(struct pci_dev *pdev, size_t *size)
 	loff_t start;
 	void __iomem *rom;
 
-	/*
-	 * IORESOURCE_ROM_SHADOW set on x86, x86_64 and IA64 supports legacy
-	 * memory map if the VGA enable bit of the Bridge Control register is
-	 * set for embedded VGA.
-	 */
-	if (res->flags & IORESOURCE_ROM_SHADOW) {
-		/* primary video rom always starts here */
-		start = (loff_t)0xC0000;
-		*size = 0x20000; /* cover C000:0 through E000:0 */
-	} else {
 		if (res->flags &
 			(IORESOURCE_ROM_COPY | IORESOURCE_ROM_BIOS_COPY)) {
 			*size = pci_resource_len(pdev, PCI_ROM_RESOURCE);
@@ -157,7 +147,6 @@ void __iomem *pci_map_rom(struct pci_dev *pdev, size_t *size)
 			if (pci_enable_rom(pdev))
 				return NULL;
 		}
-	}
 
 	rom = ioremap(start, *size);
 	if (!rom) {

commit 4708f9a55b31062dd19b12788ecf614aa4e79bea
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Mar 3 08:53:47 2016 -0600

    PCI: Don't enable/disable ROM BAR if we're using a RAM shadow copy
    
    If we're using a RAM shadow copy instead of the ROM BAR, we don't need to
    touch the ROM BAR enable bit.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/rom.c b/drivers/pci/rom.c
index 9eaca39ef38d..5da8d061d600 100644
--- a/drivers/pci/rom.c
+++ b/drivers/pci/rom.c
@@ -24,13 +24,17 @@
  */
 int pci_enable_rom(struct pci_dev *pdev)
 {
-	struct resource *res = pdev->resource + PCI_ROM_RESOURCE;
+	struct resource *res = &pdev->resource[PCI_ROM_RESOURCE];
 	struct pci_bus_region region;
 	u32 rom_addr;
 
 	if (!res->flags)
 		return -1;
 
+	/* Nothing to enable if we're using a shadow copy in RAM */
+	if (res->flags & IORESOURCE_ROM_SHADOW)
+		return 0;
+
 	pcibios_resource_to_bus(pdev->bus, &region, res);
 	pci_read_config_dword(pdev, pdev->rom_base_reg, &rom_addr);
 	rom_addr &= ~PCI_ROM_ADDRESS_MASK;
@@ -49,7 +53,12 @@ EXPORT_SYMBOL_GPL(pci_enable_rom);
  */
 void pci_disable_rom(struct pci_dev *pdev)
 {
+	struct resource *res = &pdev->resource[PCI_ROM_RESOURCE];
 	u32 rom_addr;
+
+	if (res->flags & IORESOURCE_ROM_SHADOW)
+		return;
+
 	pci_read_config_dword(pdev, pdev->rom_base_reg, &rom_addr);
 	rom_addr &= ~PCI_ROM_ADDRESS_ENABLE;
 	pci_write_config_dword(pdev, pdev->rom_base_reg, rom_addr);
@@ -154,7 +163,6 @@ void __iomem *pci_map_rom(struct pci_dev *pdev, size_t *size)
 	if (!rom) {
 		/* restore enable if ioremap fails */
 		if (!(res->flags & (IORESOURCE_ROM_ENABLE |
-				    IORESOURCE_ROM_SHADOW |
 				    IORESOURCE_ROM_COPY)))
 			pci_disable_rom(pdev);
 		return NULL;
@@ -186,8 +194,8 @@ void pci_unmap_rom(struct pci_dev *pdev, void __iomem *rom)
 
 	iounmap(rom);
 
-	/* Disable again before continuing, leave enabled if pci=rom */
-	if (!(res->flags & (IORESOURCE_ROM_ENABLE | IORESOURCE_ROM_SHADOW)))
+	/* Disable again before continuing */
+	if (!(res->flags & IORESOURCE_ROM_ENABLE))
 		pci_disable_rom(pdev);
 }
 EXPORT_SYMBOL(pci_unmap_rom);

commit 472358412b93025b13f39e46008af3ed9541ae2b
Merge: c111e8bf6edf 4058937a40f7 47b975d234ea
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Jan 15 12:33:29 2016 -0600

    Merge branches 'pci/hotplug' and 'pci/resource' into next
    
    * pci/hotplug:
      PCI: ibmphp: Remove unneeded NULL test
      PCI: hotplug: Use list_for_each_entry() to simplify code
      PCI: acpiphp_ibm: Fix null dereferences on null ibm_slot
    
    * pci/resource:
      PCI: Avoid iterating through memory outside the resource window
      PCI: Fix minimum allocation address overwrite

commit 47b975d234eac39f3a72e5496d5f6158d8b806d1
Author: Edward O'Callaghan <eocallaghan@alterapraxis.com>
Date:   Fri Jan 8 12:16:04 2016 -0600

    PCI: Avoid iterating through memory outside the resource window
    
    If the 'image' pointer has been advanced more than 'size', we've already
    iterated through memory outside the resource window.
    
    We have zero control over whatever we find in the option ROM, if it's even
    an option ROM and not just an accident of random data just happening to
    look like an option ROM.
    
    Signed-off-by: Edward O'Callaghan <eocallaghan@alterapraxis.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/rom.c b/drivers/pci/rom.c
index eb0ad530dc43..45987adb9eae 100644
--- a/drivers/pci/rom.c
+++ b/drivers/pci/rom.c
@@ -96,6 +96,9 @@ size_t pci_get_rom_size(struct pci_dev *pdev, void __iomem *rom, size_t size)
 		last_image = readb(pds + 21) & 0x80;
 		length = readw(pds + 16);
 		image += length * 512;
+		/* Avoid iterating through memory outside the resource window */
+		if (image > rom + size)
+			break;
 	} while (length && !last_image);
 
 	/* never return a size larger than the PCI resource window */

commit 4066df6345f5b3bacdf7944c4d9a839f1eef5773
Author: Vladis Dronov <vdronov@redhat.com>
Date:   Fri Nov 27 18:20:06 2015 +0100

    PCI: Print warnings for all invalid expansion ROM headers
    
    We've always validated that both bytes of the Expansion ROM signature and
    all four bytes of the PCI Data Structure signature (see PCI Firmware spec
    r3.0, sec 5.1.1), but we only printed a warning if the first byte of the
    ROM signature was invalid.
    
    Print warnings if *any* of those bytes are invalid.  Note that we only look
    at these headers if we map or read the ROM.
    
    [bhelgaas: changelog, tweak printk format]
    Signed-off-by: Vladis Dronov <vdronov@redhat.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/rom.c b/drivers/pci/rom.c
index eb0ad530dc43..5a1a39df75a1 100644
--- a/drivers/pci/rom.c
+++ b/drivers/pci/rom.c
@@ -77,22 +77,18 @@ size_t pci_get_rom_size(struct pci_dev *pdev, void __iomem *rom, size_t size)
 	do {
 		void __iomem *pds;
 		/* Standard PCI ROMs start out with these bytes 55 AA */
-		if (readb(image) != 0x55) {
-			dev_err(&pdev->dev, "Invalid ROM contents\n");
+		if (readw(image) != 0xAA55) {
+			dev_err(&pdev->dev, "Invalid PCI ROM header signature: expecting 0xaa55, got %#06x\n",
+				readw(image));
 			break;
 		}
-		if (readb(image + 1) != 0xAA)
-			break;
-		/* get the PCI data structure and check its signature */
+		/* get the PCI data structure and check its "PCIR" signature */
 		pds = image + readw(image + 24);
-		if (readb(pds) != 'P')
-			break;
-		if (readb(pds + 1) != 'C')
-			break;
-		if (readb(pds + 2) != 'I')
-			break;
-		if (readb(pds + 3) != 'R')
+		if (readl(pds) != 0x52494350) {
+			dev_err(&pdev->dev, "Invalid PCI ROM data signature: expecting 0x52494350, got %#010x\n",
+				readl(pds));
 			break;
+		}
 		last_image = readb(pds + 21) & 0x80;
 		length = readw(pds + 16);
 		image += length * 512;

commit 16b036af31e1456cb69243a5a0c9ef801ecd1f17
Author: Michel Dänzer <michel.daenzer@amd.com>
Date:   Mon Jan 19 17:53:20 2015 +0900

    PCI: Fix infinite loop with ROM image of size 0
    
    If the image size would ever read as 0, pci_get_rom_size() could keep
    processing the same image over and over again.  Exit the loop if we ever
    read a length of zero.
    
    This fixes a soft lockup on boot when the radeon driver calls
    pci_get_rom_size() on an AMD Radeon R7 250X PCIe discrete graphics card.
    
    [bhelgaas: changelog, reference]
    Link: https://bugs.launchpad.net/ubuntu/+source/linux/+bug/1386973
    Reported-by: Federico <federicotg@gmail.com>
    Signed-off-by: Michel Dänzer <michel.daenzer@amd.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
    CC: stable@vger.kernel.org

diff --git a/drivers/pci/rom.c b/drivers/pci/rom.c
index f955edb9bea7..eb0ad530dc43 100644
--- a/drivers/pci/rom.c
+++ b/drivers/pci/rom.c
@@ -71,6 +71,7 @@ size_t pci_get_rom_size(struct pci_dev *pdev, void __iomem *rom, size_t size)
 {
 	void __iomem *image;
 	int last_image;
+	unsigned length;
 
 	image = rom;
 	do {
@@ -93,9 +94,9 @@ size_t pci_get_rom_size(struct pci_dev *pdev, void __iomem *rom, size_t size)
 		if (readb(pds + 3) != 'R')
 			break;
 		last_image = readb(pds + 21) & 0x80;
-		/* this length is reliable */
-		image += readw(pds + 16) * 512;
-	} while (!last_image);
+		length = readw(pds + 16);
+		image += length * 512;
+	} while (length && !last_image);
 
 	/* never return a size larger than the PCI resource window */
 	/* there are known ROMs that get the size wrong */

commit 3c78bc61f5ef3bc87e7f94f67ec737d2273f120b
Author: Ryan Desfosses <ryan@desfo.org>
Date:   Fri Apr 18 20:13:49 2014 -0400

    PCI: Whitespace cleanup
    
    Fix various whitespace errors.
    
    No functional change.
    
    [bhelgaas: fix other similar problems]
    Signed-off-by: Ryan Desfosses <ryan@desfo.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/rom.c b/drivers/pci/rom.c
index 7fdd2200c9cb..f955edb9bea7 100644
--- a/drivers/pci/rom.c
+++ b/drivers/pci/rom.c
@@ -137,7 +137,7 @@ void __iomem *pci_map_rom(struct pci_dev *pdev, size_t *size)
 		} else {
 			/* assign the ROM an address if it doesn't have one */
 			if (res->parent == NULL &&
-			    pci_assign_resource(pdev,PCI_ROM_RESOURCE))
+			    pci_assign_resource(pdev, PCI_ROM_RESOURCE))
 				return NULL;
 			start = pci_resource_start(pdev, PCI_ROM_RESOURCE);
 			*size = pci_resource_len(pdev, PCI_ROM_RESOURCE);
@@ -203,7 +203,7 @@ void pci_cleanup_rom(struct pci_dev *pdev)
 	struct resource *res = &pdev->resource[PCI_ROM_RESOURCE];
 
 	if (res->flags & IORESOURCE_ROM_COPY) {
-		kfree((void*)(unsigned long)res->start);
+		kfree((void *)(unsigned long)res->start);
 		res->flags |= IORESOURCE_UNSET;
 		res->flags &= ~IORESOURCE_ROM_COPY;
 		res->start = 0;

commit b7fe943421396b61b9f7a97c2554ed999e0f3658
Author: Ryan Desfosses <ryan@desfo.org>
Date:   Fri Apr 25 14:32:25 2014 -0600

    PCI: Move EXPORT_SYMBOL so it immediately follows function/variable
    
    Move EXPORT_SYMBOL so it immediately follows the function or variable.
    
    No functional change.
    
    [bhelgaas: squash similar changes, fix hotplug, probe, rom, search, too]
    Signed-off-by: Ryan Desfosses <ryan@desfo.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/rom.c b/drivers/pci/rom.c
index c1839450d4d6..7fdd2200c9cb 100644
--- a/drivers/pci/rom.c
+++ b/drivers/pci/rom.c
@@ -38,6 +38,7 @@ int pci_enable_rom(struct pci_dev *pdev)
 	pci_write_config_dword(pdev, pdev->rom_base_reg, rom_addr);
 	return 0;
 }
+EXPORT_SYMBOL_GPL(pci_enable_rom);
 
 /**
  * pci_disable_rom - disable ROM decoding for a PCI device
@@ -53,6 +54,7 @@ void pci_disable_rom(struct pci_dev *pdev)
 	rom_addr &= ~PCI_ROM_ADDRESS_ENABLE;
 	pci_write_config_dword(pdev, pdev->rom_base_reg, rom_addr);
 }
+EXPORT_SYMBOL_GPL(pci_disable_rom);
 
 /**
  * pci_get_rom_size - obtain the actual size of the ROM image
@@ -166,6 +168,7 @@ void __iomem *pci_map_rom(struct pci_dev *pdev, size_t *size)
 	*size = pci_get_rom_size(pdev, rom, *size);
 	return rom;
 }
+EXPORT_SYMBOL(pci_map_rom);
 
 /**
  * pci_unmap_rom - unmap the ROM from kernel space
@@ -187,6 +190,7 @@ void pci_unmap_rom(struct pci_dev *pdev, void __iomem *rom)
 	if (!(res->flags & (IORESOURCE_ROM_ENABLE | IORESOURCE_ROM_SHADOW)))
 		pci_disable_rom(pdev);
 }
+EXPORT_SYMBOL(pci_unmap_rom);
 
 /**
  * pci_cleanup_rom - free the ROM copy created by pci_map_rom_copy
@@ -222,9 +226,4 @@ void __iomem *pci_platform_rom(struct pci_dev *pdev, size_t *size)
 
 	return NULL;
 }
-
-EXPORT_SYMBOL(pci_map_rom);
-EXPORT_SYMBOL(pci_unmap_rom);
-EXPORT_SYMBOL_GPL(pci_enable_rom);
-EXPORT_SYMBOL_GPL(pci_disable_rom);
 EXPORT_SYMBOL(pci_platform_rom);

commit bd064f0a231af336218838474ea45a64f1672190
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Feb 26 11:25:58 2014 -0700

    PCI: Mark resources as IORESOURCE_UNSET if we can't assign them
    
    When assigning addresses to resources, mark them with IORESOURCE_UNSET
    before we start and clear IORESOURCE_UNSET if assignment is successful.
    That means that if we print the resource during assignment, we will show
    the size, not a meaningless address.
    
    Also, clear IORESOURCE_UNSET if we do assign an address, so we print the
    address when it is valid.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/rom.c b/drivers/pci/rom.c
index 5d595724e5f4..c1839450d4d6 100644
--- a/drivers/pci/rom.c
+++ b/drivers/pci/rom.c
@@ -197,8 +197,10 @@ void pci_unmap_rom(struct pci_dev *pdev, void __iomem *rom)
 void pci_cleanup_rom(struct pci_dev *pdev)
 {
 	struct resource *res = &pdev->resource[PCI_ROM_RESOURCE];
+
 	if (res->flags & IORESOURCE_ROM_COPY) {
 		kfree((void*)(unsigned long)res->start);
+		res->flags |= IORESOURCE_UNSET;
 		res->flags &= ~IORESOURCE_ROM_COPY;
 		res->start = 0;
 		res->end = 0;

commit fc2798502f860b18f3c7121e4dc659d3d9d28d74
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Mon Dec 9 22:54:40 2013 -0800

    PCI: Convert pcibios_resource_to_bus() to take a pci_bus, not a pci_dev
    
    These interfaces:
    
      pcibios_resource_to_bus(struct pci_dev *dev, *bus_region, *resource)
      pcibios_bus_to_resource(struct pci_dev *dev, *resource, *bus_region)
    
    took a pci_dev, but they really depend only on the pci_bus.  And we want to
    use them in resource allocation paths where we have the bus but not a
    device, so this patch converts them to take the pci_bus instead of the
    pci_dev:
    
      pcibios_resource_to_bus(struct pci_bus *bus, *bus_region, *resource)
      pcibios_bus_to_resource(struct pci_bus *bus, *resource, *bus_region)
    
    In fact, with standard PCI-PCI bridges, they only depend on the host
    bridge, because that's the only place address translation occurs, but
    we aren't going that far yet.
    
    [bhelgaas: changelog]
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/rom.c b/drivers/pci/rom.c
index c5d0a08a8747..5d595724e5f4 100644
--- a/drivers/pci/rom.c
+++ b/drivers/pci/rom.c
@@ -31,7 +31,7 @@ int pci_enable_rom(struct pci_dev *pdev)
 	if (!res->flags)
 		return -1;
 
-	pcibios_resource_to_bus(pdev, &region, res);
+	pcibios_resource_to_bus(pdev->bus, &region, res);
 	pci_read_config_dword(pdev, pdev->rom_base_reg, &rom_addr);
 	rom_addr &= ~PCI_ROM_ADDRESS_MASK;
 	rom_addr |= region.start | PCI_ROM_ADDRESS_ENABLE;

commit fffe01f7a768d07cc50ace71abe28fbf2f786a43
Author: Matthew Garrett <matthew.garrett@nebula.com>
Date:   Tue Mar 26 17:25:54 2013 -0400

    PCI: Add PCI ROM helper for platform-provided ROM images
    
    It turns out that some UEFI systems provide apparently an apparently valid
    PCI ROM BAR that turns out to contain garbage, so the attempt in 547b52463
    to prefer the ROM from the BAR actually breaks a different set of machines.
    As Linus pointed out, the graphics drivers are probably in the best
    position to make this judgement, so this basically reverts 547b52463 and
    f9a37be0f and adds a new helper function. Followup patches will add support
    to nouveau and radeon for probing this ROM source if they can't find a ROM
    from some other source.
    
    [bhelgaas: added reporter and bugzilla pointers, s/f4eb5ff05/547b52463]
    Reference: https://bugzilla.redhat.com/show_bug.cgi?id=927451
    Reference: http://lkml.kernel.org/r/kg69ef$vdb$1@ger.gmane.org
    Reported-by: Mantas Mikulėnas <grawity@gmail.com>
    Reported-by: Chris Murphy <bugzilla@colorremedies.com>
    Signed-off-by: Matthew Garrett <matthew.garrett@nebula.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/rom.c b/drivers/pci/rom.c
index b41ac7756a4b..c5d0a08a8747 100644
--- a/drivers/pci/rom.c
+++ b/drivers/pci/rom.c
@@ -100,27 +100,6 @@ size_t pci_get_rom_size(struct pci_dev *pdev, void __iomem *rom, size_t size)
 	return min((size_t)(image - rom), size);
 }
 
-static loff_t pci_find_rom(struct pci_dev *pdev, size_t *size)
-{
-	struct resource *res = &pdev->resource[PCI_ROM_RESOURCE];
-	loff_t start;
-
-	/* assign the ROM an address if it doesn't have one */
-	if (res->parent == NULL && pci_assign_resource(pdev, PCI_ROM_RESOURCE))
-		return 0;
-	start = pci_resource_start(pdev, PCI_ROM_RESOURCE);
-	*size = pci_resource_len(pdev, PCI_ROM_RESOURCE);
-
-	if (*size == 0)
-		return 0;
-
-	/* Enable ROM space decodes */
-	if (pci_enable_rom(pdev))
-		return 0;
-
-	return start;
-}
-
 /**
  * pci_map_rom - map a PCI ROM to kernel space
  * @pdev: pointer to pci device struct
@@ -135,7 +114,7 @@ static loff_t pci_find_rom(struct pci_dev *pdev, size_t *size)
 void __iomem *pci_map_rom(struct pci_dev *pdev, size_t *size)
 {
 	struct resource *res = &pdev->resource[PCI_ROM_RESOURCE];
-	loff_t start = 0;
+	loff_t start;
 	void __iomem *rom;
 
 	/*
@@ -154,21 +133,21 @@ void __iomem *pci_map_rom(struct pci_dev *pdev, size_t *size)
 			return (void __iomem *)(unsigned long)
 				pci_resource_start(pdev, PCI_ROM_RESOURCE);
 		} else {
-			start = pci_find_rom(pdev, size);
-		}
-	}
+			/* assign the ROM an address if it doesn't have one */
+			if (res->parent == NULL &&
+			    pci_assign_resource(pdev,PCI_ROM_RESOURCE))
+				return NULL;
+			start = pci_resource_start(pdev, PCI_ROM_RESOURCE);
+			*size = pci_resource_len(pdev, PCI_ROM_RESOURCE);
+			if (*size == 0)
+				return NULL;
 
-	/*
-	 * Some devices may provide ROMs via a source other than the BAR
-	 */
-	if (!start && pdev->rom && pdev->romlen) {
-		*size = pdev->romlen;
-		return phys_to_virt(pdev->rom);
+			/* Enable ROM space decodes */
+			if (pci_enable_rom(pdev))
+				return NULL;
+		}
 	}
 
-	if (!start)
-		return NULL;
-
 	rom = ioremap(start, *size);
 	if (!rom) {
 		/* restore enable if ioremap fails */
@@ -202,8 +181,7 @@ void pci_unmap_rom(struct pci_dev *pdev, void __iomem *rom)
 	if (res->flags & (IORESOURCE_ROM_COPY | IORESOURCE_ROM_BIOS_COPY))
 		return;
 
-	if (!pdev->rom || !pdev->romlen)
-		iounmap(rom);
+	iounmap(rom);
 
 	/* Disable again before continuing, leave enabled if pci=rom */
 	if (!(res->flags & (IORESOURCE_ROM_ENABLE | IORESOURCE_ROM_SHADOW)))
@@ -227,7 +205,24 @@ void pci_cleanup_rom(struct pci_dev *pdev)
 	}
 }
 
+/**
+ * pci_platform_rom - provides a pointer to any ROM image provided by the
+ * platform
+ * @pdev: pointer to pci device struct
+ * @size: pointer to receive size of pci window over ROM
+ */
+void __iomem *pci_platform_rom(struct pci_dev *pdev, size_t *size)
+{
+	if (pdev->rom && pdev->romlen) {
+		*size = pdev->romlen;
+		return phys_to_virt((phys_addr_t)pdev->rom);
+	}
+
+	return NULL;
+}
+
 EXPORT_SYMBOL(pci_map_rom);
 EXPORT_SYMBOL(pci_unmap_rom);
 EXPORT_SYMBOL_GPL(pci_enable_rom);
 EXPORT_SYMBOL_GPL(pci_disable_rom);
+EXPORT_SYMBOL(pci_platform_rom);

commit 547b524636249fbe906ab78a50ab0017c490316c
Author: Matthew Garrett <matthew.garrett@nebula.com>
Date:   Tue Mar 19 17:26:57 2013 -0400

    PCI: Use ROM images from firmware only if no other ROM source available
    
    Mantas Mikulėnas reported that his graphics hardware failed to
    initialise after commit f9a37be0f02a ("x86: Use PCI setup data").
    
    The aim of this commit was to ensure that ROM images were available on
    some Apple systems that don't expose the GPU ROM via any other source.
    In this case, UEFI appears to have provided a broken ROM image that we
    were using even though there was a perfectly valid ROM available via
    other sources.  The simplest way to handle this seems to be to just
    re-order pci_map_rom() and leave any firmare-supplied ROM to last.
    
    Signed-off-by: Matthew Garrett <matthew.garrett@nebula.com>
    Tested-by: Mantas Mikulėnas <grawity@gmail.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pci/rom.c b/drivers/pci/rom.c
index ab886b7ee327..b41ac7756a4b 100644
--- a/drivers/pci/rom.c
+++ b/drivers/pci/rom.c
@@ -100,6 +100,27 @@ size_t pci_get_rom_size(struct pci_dev *pdev, void __iomem *rom, size_t size)
 	return min((size_t)(image - rom), size);
 }
 
+static loff_t pci_find_rom(struct pci_dev *pdev, size_t *size)
+{
+	struct resource *res = &pdev->resource[PCI_ROM_RESOURCE];
+	loff_t start;
+
+	/* assign the ROM an address if it doesn't have one */
+	if (res->parent == NULL && pci_assign_resource(pdev, PCI_ROM_RESOURCE))
+		return 0;
+	start = pci_resource_start(pdev, PCI_ROM_RESOURCE);
+	*size = pci_resource_len(pdev, PCI_ROM_RESOURCE);
+
+	if (*size == 0)
+		return 0;
+
+	/* Enable ROM space decodes */
+	if (pci_enable_rom(pdev))
+		return 0;
+
+	return start;
+}
+
 /**
  * pci_map_rom - map a PCI ROM to kernel space
  * @pdev: pointer to pci device struct
@@ -114,21 +135,15 @@ size_t pci_get_rom_size(struct pci_dev *pdev, void __iomem *rom, size_t size)
 void __iomem *pci_map_rom(struct pci_dev *pdev, size_t *size)
 {
 	struct resource *res = &pdev->resource[PCI_ROM_RESOURCE];
-	loff_t start;
+	loff_t start = 0;
 	void __iomem *rom;
 
-	/*
-	 * Some devices may provide ROMs via a source other than the BAR
-	 */
-	if (pdev->rom && pdev->romlen) {
-		*size = pdev->romlen;
-		return phys_to_virt(pdev->rom);
 	/*
 	 * IORESOURCE_ROM_SHADOW set on x86, x86_64 and IA64 supports legacy
 	 * memory map if the VGA enable bit of the Bridge Control register is
 	 * set for embedded VGA.
 	 */
-	} else if (res->flags & IORESOURCE_ROM_SHADOW) {
+	if (res->flags & IORESOURCE_ROM_SHADOW) {
 		/* primary video rom always starts here */
 		start = (loff_t)0xC0000;
 		*size = 0x20000; /* cover C000:0 through E000:0 */
@@ -139,21 +154,21 @@ void __iomem *pci_map_rom(struct pci_dev *pdev, size_t *size)
 			return (void __iomem *)(unsigned long)
 				pci_resource_start(pdev, PCI_ROM_RESOURCE);
 		} else {
-			/* assign the ROM an address if it doesn't have one */
-			if (res->parent == NULL &&
-			    pci_assign_resource(pdev,PCI_ROM_RESOURCE))
-				return NULL;
-			start = pci_resource_start(pdev, PCI_ROM_RESOURCE);
-			*size = pci_resource_len(pdev, PCI_ROM_RESOURCE);
-			if (*size == 0)
-				return NULL;
-
-			/* Enable ROM space decodes */
-			if (pci_enable_rom(pdev))
-				return NULL;
+			start = pci_find_rom(pdev, size);
 		}
 	}
 
+	/*
+	 * Some devices may provide ROMs via a source other than the BAR
+	 */
+	if (!start && pdev->rom && pdev->romlen) {
+		*size = pdev->romlen;
+		return phys_to_virt(pdev->rom);
+	}
+
+	if (!start)
+		return NULL;
+
 	rom = ioremap(start, *size);
 	if (!rom) {
 		/* restore enable if ioremap fails */

commit dbd3fc3345390a989a033427aa915a0dfb62149f
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Dec 10 11:24:42 2012 -0700

    PCI: Use phys_addr_t for physical ROM address
    
    Use phys_addr_t rather than "void *" for physical memory address.
    This removes casts and fixes a "cast from pointer to integer of different
    size" warning on ppc44x_defconfig.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/rom.c b/drivers/pci/rom.c
index 3a3828fbc879..ab886b7ee327 100644
--- a/drivers/pci/rom.c
+++ b/drivers/pci/rom.c
@@ -122,7 +122,7 @@ void __iomem *pci_map_rom(struct pci_dev *pdev, size_t *size)
 	 */
 	if (pdev->rom && pdev->romlen) {
 		*size = pdev->romlen;
-		return phys_to_virt((phys_addr_t)pdev->rom);
+		return phys_to_virt(pdev->rom);
 	/*
 	 * IORESOURCE_ROM_SHADOW set on x86, x86_64 and IA64 supports legacy
 	 * memory map if the VGA enable bit of the Bridge Control register is

commit 84c1b80e32638f881c17390dfe88143e5cd3f583
Author: Matthew Garrett <mjg@redhat.com>
Date:   Wed Dec 5 14:33:27 2012 -0700

    PCI: Add support for non-BAR ROMs
    
    Platforms may provide their own mechanisms for obtaining ROMs. Add support
    for using data provided by the platform in that case.
    
    Signed-off-by: Matthew Garrett <mjg@redhat.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Tested-by: Seth Forshee <seth.forshee@canonical.com>

diff --git a/drivers/pci/rom.c b/drivers/pci/rom.c
index 0b3037ab8b93..3a3828fbc879 100644
--- a/drivers/pci/rom.c
+++ b/drivers/pci/rom.c
@@ -117,12 +117,18 @@ void __iomem *pci_map_rom(struct pci_dev *pdev, size_t *size)
 	loff_t start;
 	void __iomem *rom;
 
+	/*
+	 * Some devices may provide ROMs via a source other than the BAR
+	 */
+	if (pdev->rom && pdev->romlen) {
+		*size = pdev->romlen;
+		return phys_to_virt((phys_addr_t)pdev->rom);
 	/*
 	 * IORESOURCE_ROM_SHADOW set on x86, x86_64 and IA64 supports legacy
 	 * memory map if the VGA enable bit of the Bridge Control register is
 	 * set for embedded VGA.
 	 */
-	if (res->flags & IORESOURCE_ROM_SHADOW) {
+	} else if (res->flags & IORESOURCE_ROM_SHADOW) {
 		/* primary video rom always starts here */
 		start = (loff_t)0xC0000;
 		*size = 0x20000; /* cover C000:0 through E000:0 */
@@ -181,7 +187,8 @@ void pci_unmap_rom(struct pci_dev *pdev, void __iomem *rom)
 	if (res->flags & (IORESOURCE_ROM_COPY | IORESOURCE_ROM_BIOS_COPY))
 		return;
 
-	iounmap(rom);
+	if (!pdev->rom || !pdev->romlen)
+		iounmap(rom);
 
 	/* Disable again before continuing, leave enabled if pci=rom */
 	if (!(res->flags & (IORESOURCE_ROM_ENABLE | IORESOURCE_ROM_SHADOW)))

commit 7990681ad8215977b27ac855520720193de2c98f
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Aug 16 20:38:50 2012 -0600

    PCI: Remove unused, commented-out, code
    
    This removes unused code that was already commented out.
    
    Tested-by: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>

diff --git a/drivers/pci/rom.c b/drivers/pci/rom.c
index 48ebdb237f3f..0b3037ab8b93 100644
--- a/drivers/pci/rom.c
+++ b/drivers/pci/rom.c
@@ -167,44 +167,6 @@ void __iomem *pci_map_rom(struct pci_dev *pdev, size_t *size)
 	return rom;
 }
 
-#if 0
-/**
- * pci_map_rom_copy - map a PCI ROM to kernel space, create a copy
- * @pdev: pointer to pci device struct
- * @size: pointer to receive size of pci window over ROM
- *
- * Return: kernel virtual pointer to image of ROM
- *
- * Map a PCI ROM into kernel space. If ROM is boot video ROM,
- * the shadow BIOS copy will be returned instead of the
- * actual ROM.
- */
-void __iomem *pci_map_rom_copy(struct pci_dev *pdev, size_t *size)
-{
-	struct resource *res = &pdev->resource[PCI_ROM_RESOURCE];
-	void __iomem *rom;
-
-	rom = pci_map_rom(pdev, size);
-	if (!rom)
-		return NULL;
-
-	if (res->flags & (IORESOURCE_ROM_COPY | IORESOURCE_ROM_SHADOW |
-			  IORESOURCE_ROM_BIOS_COPY))
-		return rom;
-
-	res->start = (unsigned long)kmalloc(*size, GFP_KERNEL);
-	if (!res->start)
-		return rom;
-
-	res->end = res->start + *size;
-	memcpy_fromio((void*)(unsigned long)res->start, rom, *size);
-	pci_unmap_rom(pdev, rom);
-	res->flags |= IORESOURCE_ROM_COPY;
-
-	return (void __iomem *)(unsigned long)res->start;
-}
-#endif  /*  0  */
-
 /**
  * pci_unmap_rom - unmap the ROM from kernel space
  * @pdev: pointer to pci device struct
@@ -226,27 +188,6 @@ void pci_unmap_rom(struct pci_dev *pdev, void __iomem *rom)
 		pci_disable_rom(pdev);
 }
 
-#if 0
-/**
- * pci_remove_rom - disable the ROM and remove its sysfs attribute
- * @pdev: pointer to pci device struct
- *
- * Remove the rom file in sysfs and disable ROM decoding.
- */
-void pci_remove_rom(struct pci_dev *pdev)
-{
-	struct resource *res = &pdev->resource[PCI_ROM_RESOURCE];
-
-	if (pci_resource_len(pdev, PCI_ROM_RESOURCE))
-		sysfs_remove_bin_file(&pdev->dev.kobj, pdev->rom_attr);
-	if (!(res->flags & (IORESOURCE_ROM_ENABLE |
-			    IORESOURCE_ROM_SHADOW |
-			    IORESOURCE_ROM_BIOS_COPY |
-			    IORESOURCE_ROM_COPY)))
-		pci_disable_rom(pdev);
-}
-#endif  /*  0  */
-
 /**
  * pci_cleanup_rom - free the ROM copy created by pci_map_rom_copy
  * @pdev: pointer to pci device struct

commit 363c75db1d7bbda0aa90e680565f2673bab92ee4
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Fri May 27 09:37:25 2011 -0400

    pci: Fix files needing export.h for EXPORT_SYMBOL/THIS_MODULE
    
    They were implicitly getting it from device.h --> module.h but
    we want to clean that up.  So add the minimal header for these
    macros.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/drivers/pci/rom.c b/drivers/pci/rom.c
index 36864a935d68..48ebdb237f3f 100644
--- a/drivers/pci/rom.c
+++ b/drivers/pci/rom.c
@@ -7,6 +7,7 @@
  * PCI ROM access routines
  */
 #include <linux/kernel.h>
+#include <linux/export.h>
 #include <linux/pci.h>
 #include <linux/slab.h>
 

commit 4cc59c721cba27a4644e29103afac0f91af8da3c
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Mon Feb 9 09:31:20 2009 -0800

    PCI: fix rom.c kernel-doc warning
    
    Fix PCI kernel-doc warning:
    
    Warning(linux-2.6.29-rc4-git1/drivers/pci/rom.c:67): No description found for parameter 'pdev'
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    cc: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/rom.c b/drivers/pci/rom.c
index 29cbe47f219f..36864a935d68 100644
--- a/drivers/pci/rom.c
+++ b/drivers/pci/rom.c
@@ -55,6 +55,7 @@ void pci_disable_rom(struct pci_dev *pdev)
 
 /**
  * pci_get_rom_size - obtain the actual size of the ROM image
+ * @pdev: target PCI device
  * @rom: kernel virtual pointer to image of ROM
  * @size: size of PCI window
  *  return: size of actual ROM image

commit 97c44836cdec1ea713a15d84098a1a908157e68f
Author: Timothy S. Nelson <wayland@wayland.id.au>
Date:   Fri Jan 30 06:12:47 2009 +1100

    PCI: return error on failure to read PCI ROMs
    
    This patch makes the ROM reading code return an error to user space if
    the size of the ROM read is equal to 0.
    
    The patch also emits a warnings if the contents of the ROM are invalid,
    and documents the effects of the "enable" file on ROM reading.
    
    Signed-off-by: Timothy S. Nelson <wayland@wayland.id.au>
    Acked-by: Alex Villacis-Lasso <a_villacis@palosanto.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/rom.c b/drivers/pci/rom.c
index 132a78159b60..29cbe47f219f 100644
--- a/drivers/pci/rom.c
+++ b/drivers/pci/rom.c
@@ -63,7 +63,7 @@ void pci_disable_rom(struct pci_dev *pdev)
  * The PCI window size could be much larger than the
  * actual image size.
  */
-size_t pci_get_rom_size(void __iomem *rom, size_t size)
+size_t pci_get_rom_size(struct pci_dev *pdev, void __iomem *rom, size_t size)
 {
 	void __iomem *image;
 	int last_image;
@@ -72,8 +72,10 @@ size_t pci_get_rom_size(void __iomem *rom, size_t size)
 	do {
 		void __iomem *pds;
 		/* Standard PCI ROMs start out with these bytes 55 AA */
-		if (readb(image) != 0x55)
+		if (readb(image) != 0x55) {
+			dev_err(&pdev->dev, "Invalid ROM contents\n");
 			break;
+		}
 		if (readb(image + 1) != 0xAA)
 			break;
 		/* get the PCI data structure and check its signature */
@@ -159,7 +161,7 @@ void __iomem *pci_map_rom(struct pci_dev *pdev, size_t *size)
 	 * size is much larger than the actual size of the ROM.
 	 * True size is important if the ROM is going to be copied.
 	 */
-	*size = pci_get_rom_size(rom, *size);
+	*size = pci_get_rom_size(pdev, rom, *size);
 	return rom;
 }
 

commit f5dafca52d366ef8c6c86cbdfecc71a9a78b63a6
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Wed Oct 29 22:35:12 2008 -0700

    PCI: remove excess kernel-doc notation
    
    Fix pci/rom.c kernel-doc function notation:
    
    Warning(drivers/pci/rom.c:110): Excess function parameter or struct member 'return' description in 'pci_map_rom'
    Warning(drivers/pci/rom.c:177): Excess function parameter or struct member 'return' description in 'pci_map_rom_copy'
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/rom.c b/drivers/pci/rom.c
index 1f5f6143f35c..132a78159b60 100644
--- a/drivers/pci/rom.c
+++ b/drivers/pci/rom.c
@@ -100,7 +100,8 @@ size_t pci_get_rom_size(void __iomem *rom, size_t size)
  * pci_map_rom - map a PCI ROM to kernel space
  * @pdev: pointer to pci device struct
  * @size: pointer to receive size of pci window over ROM
- * @return: kernel virtual pointer to image of ROM
+ *
+ * Return: kernel virtual pointer to image of ROM
  *
  * Map a PCI ROM into kernel space. If ROM is boot video ROM,
  * the shadow BIOS copy will be returned instead of the
@@ -167,7 +168,8 @@ void __iomem *pci_map_rom(struct pci_dev *pdev, size_t *size)
  * pci_map_rom_copy - map a PCI ROM to kernel space, create a copy
  * @pdev: pointer to pci device struct
  * @size: pointer to receive size of pci window over ROM
- * @return: kernel virtual pointer to image of ROM
+ *
+ * Return: kernel virtual pointer to image of ROM
  *
  * Map a PCI ROM into kernel space. If ROM is boot video ROM,
  * the shadow BIOS copy will be returned instead of the

commit e416de5e61e1a9b7f987804cbb67230b5f5293c6
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Tue Sep 23 17:25:10 2008 +0100

    Export the ROM enable/disable helpers
    
    .... so that they can be used by MTD map drivers. Lets us close #9420
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/pci/rom.c b/drivers/pci/rom.c
index bd5c0e031398..1f5f6143f35c 100644
--- a/drivers/pci/rom.c
+++ b/drivers/pci/rom.c
@@ -21,7 +21,7 @@
  * between the ROM and other resources, so enabling it may disable access
  * to MMIO registers or other card memory.
  */
-static int pci_enable_rom(struct pci_dev *pdev)
+int pci_enable_rom(struct pci_dev *pdev)
 {
 	struct resource *res = pdev->resource + PCI_ROM_RESOURCE;
 	struct pci_bus_region region;
@@ -45,7 +45,7 @@ static int pci_enable_rom(struct pci_dev *pdev)
  * Disable ROM decoding on a PCI device by turning off the last bit in the
  * ROM BAR.
  */
-static void pci_disable_rom(struct pci_dev *pdev)
+void pci_disable_rom(struct pci_dev *pdev)
 {
 	u32 rom_addr;
 	pci_read_config_dword(pdev, pdev->rom_base_reg, &rom_addr);
@@ -260,3 +260,5 @@ void pci_cleanup_rom(struct pci_dev *pdev)
 
 EXPORT_SYMBOL(pci_map_rom);
 EXPORT_SYMBOL(pci_unmap_rom);
+EXPORT_SYMBOL_GPL(pci_enable_rom);
+EXPORT_SYMBOL_GPL(pci_disable_rom);

commit 0643245f595dc175c14245fa1e1e9efda3e12f2a
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Fri Feb 29 22:03:15 2008 -0800

    docbook: fix kernel-api source files
    
    Fix docbook problems in kernel-api.tmpl.
    These cause the generated docbook to be incorrect.
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pci/rom.c b/drivers/pci/rom.c
index a98b2470b9ea..bd5c0e031398 100644
--- a/drivers/pci/rom.c
+++ b/drivers/pci/rom.c
@@ -242,8 +242,7 @@ void pci_remove_rom(struct pci_dev *pdev)
 #endif  /*  0  */
 
 /**
- * pci_cleanup_rom - internal routine for freeing the ROM copy created
- * by pci_map_rom_copy called from remove.c
+ * pci_cleanup_rom - free the ROM copy created by pci_map_rom_copy
  * @pdev: pointer to pci device struct
  *
  * Free the copied ROM if we allocated one.

commit b09549ef9b66b9547520572bedd7af3c1f0747d7
Author: Adrian Bunk <bunk@kernel.org>
Date:   Sat Oct 27 03:06:25 2007 +0200

    PCI: drivers/pci/rom.c: #if 0 two functions
    
    This patch #if 0's the following unused global functions:
    - rom.c: pci_map_rom_copy()
    - rom.c: pci_remove_rom()
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/rom.c b/drivers/pci/rom.c
index dbbcc04abd1a..a98b2470b9ea 100644
--- a/drivers/pci/rom.c
+++ b/drivers/pci/rom.c
@@ -162,6 +162,7 @@ void __iomem *pci_map_rom(struct pci_dev *pdev, size_t *size)
 	return rom;
 }
 
+#if 0
 /**
  * pci_map_rom_copy - map a PCI ROM to kernel space, create a copy
  * @pdev: pointer to pci device struct
@@ -196,6 +197,7 @@ void __iomem *pci_map_rom_copy(struct pci_dev *pdev, size_t *size)
 
 	return (void __iomem *)(unsigned long)res->start;
 }
+#endif  /*  0  */
 
 /**
  * pci_unmap_rom - unmap the ROM from kernel space
@@ -218,6 +220,7 @@ void pci_unmap_rom(struct pci_dev *pdev, void __iomem *rom)
 		pci_disable_rom(pdev);
 }
 
+#if 0
 /**
  * pci_remove_rom - disable the ROM and remove its sysfs attribute
  * @pdev: pointer to pci device struct
@@ -236,6 +239,7 @@ void pci_remove_rom(struct pci_dev *pdev)
 			    IORESOURCE_ROM_COPY)))
 		pci_disable_rom(pdev);
 }
+#endif  /*  0  */
 
 /**
  * pci_cleanup_rom - internal routine for freeing the ROM copy created
@@ -256,6 +260,4 @@ void pci_cleanup_rom(struct pci_dev *pdev)
 }
 
 EXPORT_SYMBOL(pci_map_rom);
-EXPORT_SYMBOL(pci_map_rom_copy);
 EXPORT_SYMBOL(pci_unmap_rom);
-EXPORT_SYMBOL(pci_remove_rom);

commit d7ad2254fa7cc11aec3faeba076c1243f6adeb47
Author: John Keller <jpk@sgi.com>
Date:   Mon Jul 9 11:42:24 2007 -0700

    [IA64] SN: Correct ROM resource length for BIOS copy
    
    On SN systems, when setting the IORESOURCE_ROM_BIOS_COPY resource flag,
    the resource length should be set to the actual size of the ROM image
    so that a call to pci_map_rom() returns the correct size.
    
    Signed-off-by: John Keller <jpk@sgi.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Tony Luck <tony.luck@intel.com>

diff --git a/drivers/pci/rom.c b/drivers/pci/rom.c
index d087e0817715..dbbcc04abd1a 100644
--- a/drivers/pci/rom.c
+++ b/drivers/pci/rom.c
@@ -53,6 +53,49 @@ static void pci_disable_rom(struct pci_dev *pdev)
 	pci_write_config_dword(pdev, pdev->rom_base_reg, rom_addr);
 }
 
+/**
+ * pci_get_rom_size - obtain the actual size of the ROM image
+ * @rom: kernel virtual pointer to image of ROM
+ * @size: size of PCI window
+ *  return: size of actual ROM image
+ *
+ * Determine the actual length of the ROM image.
+ * The PCI window size could be much larger than the
+ * actual image size.
+ */
+size_t pci_get_rom_size(void __iomem *rom, size_t size)
+{
+	void __iomem *image;
+	int last_image;
+
+	image = rom;
+	do {
+		void __iomem *pds;
+		/* Standard PCI ROMs start out with these bytes 55 AA */
+		if (readb(image) != 0x55)
+			break;
+		if (readb(image + 1) != 0xAA)
+			break;
+		/* get the PCI data structure and check its signature */
+		pds = image + readw(image + 24);
+		if (readb(pds) != 'P')
+			break;
+		if (readb(pds + 1) != 'C')
+			break;
+		if (readb(pds + 2) != 'I')
+			break;
+		if (readb(pds + 3) != 'R')
+			break;
+		last_image = readb(pds + 21) & 0x80;
+		/* this length is reliable */
+		image += readw(pds + 16) * 512;
+	} while (!last_image);
+
+	/* never return a size larger than the PCI resource window */
+	/* there are known ROMs that get the size wrong */
+	return min((size_t)(image - rom), size);
+}
+
 /**
  * pci_map_rom - map a PCI ROM to kernel space
  * @pdev: pointer to pci device struct
@@ -68,8 +111,6 @@ void __iomem *pci_map_rom(struct pci_dev *pdev, size_t *size)
 	struct resource *res = &pdev->resource[PCI_ROM_RESOURCE];
 	loff_t start;
 	void __iomem *rom;
-	void __iomem *image;
-	int last_image;
 
 	/*
 	 * IORESOURCE_ROM_SHADOW set on x86, x86_64 and IA64 supports legacy
@@ -117,33 +158,7 @@ void __iomem *pci_map_rom(struct pci_dev *pdev, size_t *size)
 	 * size is much larger than the actual size of the ROM.
 	 * True size is important if the ROM is going to be copied.
 	 */
-	image = rom;
-	do {
-		void __iomem *pds;
-		/* Standard PCI ROMs start out with these bytes 55 AA */
-		if (readb(image) != 0x55)
-			break;
-		if (readb(image + 1) != 0xAA)
-			break;
-		/* get the PCI data structure and check its signature */
-		pds = image + readw(image + 24);
-		if (readb(pds) != 'P')
-			break;
-		if (readb(pds + 1) != 'C')
-			break;
-		if (readb(pds + 2) != 'I')
-			break;
-		if (readb(pds + 3) != 'R')
-			break;
-		last_image = readb(pds + 21) & 0x80;
-		/* this length is reliable */
-		image += readw(pds + 16) * 512;
-	} while (!last_image);
-
-	/* never return a size larger than the PCI resource window */
-	/* there are known ROMs that get the size wrong */
-	*size = min((size_t)(image - rom), *size);
-
+	*size = pci_get_rom_size(rom, *size);
 	return rom;
 }
 

commit a2302c68d923537436b1114aa207787c1a31bd50
Author: John Keller <jpk@sgi.com>
Date:   Wed Oct 4 16:49:52 2006 -0500

    Altix: Initial ACPI support - ROM shadowing.
    
    Support a shadowed ROM when running with an ACPI capable PROM.
    
    Define a new dev.resource flag IORESOURCE_ROM_BIOS_COPY to
    describe the case of a BIOS shadowed ROM, which can then
    be used to avoid pci_map_rom() making an unneeded call to
    pci_enable_rom().
    
    
    Signed-off-by: John Keller <jpk@sgi.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/rom.c b/drivers/pci/rom.c
index e1dcefc69bb4..d087e0817715 100644
--- a/drivers/pci/rom.c
+++ b/drivers/pci/rom.c
@@ -81,7 +81,8 @@ void __iomem *pci_map_rom(struct pci_dev *pdev, size_t *size)
 		start = (loff_t)0xC0000;
 		*size = 0x20000; /* cover C000:0 through E000:0 */
 	} else {
-		if (res->flags & IORESOURCE_ROM_COPY) {
+		if (res->flags &
+			(IORESOURCE_ROM_COPY | IORESOURCE_ROM_BIOS_COPY)) {
 			*size = pci_resource_len(pdev, PCI_ROM_RESOURCE);
 			return (void __iomem *)(unsigned long)
 				pci_resource_start(pdev, PCI_ROM_RESOURCE);
@@ -165,7 +166,8 @@ void __iomem *pci_map_rom_copy(struct pci_dev *pdev, size_t *size)
 	if (!rom)
 		return NULL;
 
-	if (res->flags & (IORESOURCE_ROM_COPY | IORESOURCE_ROM_SHADOW))
+	if (res->flags & (IORESOURCE_ROM_COPY | IORESOURCE_ROM_SHADOW |
+			  IORESOURCE_ROM_BIOS_COPY))
 		return rom;
 
 	res->start = (unsigned long)kmalloc(*size, GFP_KERNEL);
@@ -191,7 +193,7 @@ void pci_unmap_rom(struct pci_dev *pdev, void __iomem *rom)
 {
 	struct resource *res = &pdev->resource[PCI_ROM_RESOURCE];
 
-	if (res->flags & IORESOURCE_ROM_COPY)
+	if (res->flags & (IORESOURCE_ROM_COPY | IORESOURCE_ROM_BIOS_COPY))
 		return;
 
 	iounmap(rom);
@@ -215,6 +217,7 @@ void pci_remove_rom(struct pci_dev *pdev)
 		sysfs_remove_bin_file(&pdev->dev.kobj, pdev->rom_attr);
 	if (!(res->flags & (IORESOURCE_ROM_ENABLE |
 			    IORESOURCE_ROM_SHADOW |
+			    IORESOURCE_ROM_BIOS_COPY |
 			    IORESOURCE_ROM_COPY)))
 		pci_disable_rom(pdev);
 }

commit 6b5c76b8e2ff204fa8d7201acce461188873bf2b
Author: Eiichiro Oiwa <eiichiro.oiwa.nm@hitachi.com>
Date:   Mon Oct 23 15:14:07 2006 +0900

    PCI: fix pci_fixup_video as it blows up on sparc64
    
    This reverts much of the original pci_fixup_video change and makes it
    work for all arches that need it.
    
    fixed, and tested on x86, x86_64 and IA64 dig.
    
    Signed-off-by: Eiichiro Oiwa <eiichiro.oiwa.nm@hitachi.com>
    Acked-by: David Miller <davem@davemloft.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/rom.c b/drivers/pci/rom.c
index 43e4a49f2cc4..e1dcefc69bb4 100644
--- a/drivers/pci/rom.c
+++ b/drivers/pci/rom.c
@@ -72,8 +72,9 @@ void __iomem *pci_map_rom(struct pci_dev *pdev, size_t *size)
 	int last_image;
 
 	/*
-	 * IORESOURCE_ROM_SHADOW set if the VGA enable bit of the Bridge Control
-	 * register is set for embedded VGA.
+	 * IORESOURCE_ROM_SHADOW set on x86, x86_64 and IA64 supports legacy
+	 * memory map if the VGA enable bit of the Bridge Control register is
+	 * set for embedded VGA.
 	 */
 	if (res->flags & IORESOURCE_ROM_SHADOW) {
 		/* primary video rom always starts here */

commit b5e4efe7e061ff52ac97b9fa45acca529d8daeea
Author: eiichiro.oiwa.nm@hitachi.com <eiichiro.oiwa.nm@hitachi.com>
Date:   Thu Sep 28 13:55:47 2006 +0900

    PCI: Turn pci_fixup_video into generic for embedded VGA
    
    pci_fixup_video turns into generic code because there are many platforms need this fixup
    for embedded VGA as well as x86. The Video BIOS integrates into System BIOS on a machine
    has embedded VGA although embedded VGA generally don't have PCI ROM. As a result,
    embedded VGA need the way that the sysfs rom points to the Video BIOS of System
    RAM (0xC0000). PCI-to-PCI Bridge Architecture specification describes the condition whether
    or not PCI ROM forwards VGA compatible memory address. fixup_video suits this specification.
    Although the Video ROM generally implements in x86 code regardless of platform, some
    application such as X Window System can run this code by dosemu86. Therefore,
    pci_fixup_video should turn into generic code.
    
    
    Signed-off-by: Eiichiro Oiwa <eiichiro.oiwa.nm@hitachi.com>
    Acked-by: Alan Cox <alan@redhat.com>
    Acked-by: Jesse Barnes <jesse.barnes@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/rom.c b/drivers/pci/rom.c
index f5ee7ce16fa6..43e4a49f2cc4 100644
--- a/drivers/pci/rom.c
+++ b/drivers/pci/rom.c
@@ -71,7 +71,10 @@ void __iomem *pci_map_rom(struct pci_dev *pdev, size_t *size)
 	void __iomem *image;
 	int last_image;
 
-	/* IORESOURCE_ROM_SHADOW only set on x86 */
+	/*
+	 * IORESOURCE_ROM_SHADOW set if the VGA enable bit of the Bridge Control
+	 * register is set for embedded VGA.
+	 */
 	if (res->flags & IORESOURCE_ROM_SHADOW) {
 		/* primary video rom always starts here */
 		start = (loff_t)0xC0000;

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jörn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jörn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/drivers/pci/rom.c b/drivers/pci/rom.c
index cbb69cf41311..f5ee7ce16fa6 100644
--- a/drivers/pci/rom.c
+++ b/drivers/pci/rom.c
@@ -6,7 +6,6 @@
  *
  * PCI ROM access routines
  */
-#include <linux/config.h>
 #include <linux/kernel.h>
 #include <linux/pci.h>
 #include <linux/slab.h>

commit e31dd6e4520439ceae4753f32dd2da2c345e929a
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Jun 12 17:06:02 2006 -0700

    [PATCH] 64bit resource: change pci core and arch code to use resource_size_t
    
    Based on a patch series originally from Vivek Goyal <vgoyal@in.ibm.com>
    
    Cc: Vivek Goyal <vgoyal@in.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/rom.c b/drivers/pci/rom.c
index 598a115cd00e..cbb69cf41311 100644
--- a/drivers/pci/rom.c
+++ b/drivers/pci/rom.c
@@ -80,8 +80,8 @@ void __iomem *pci_map_rom(struct pci_dev *pdev, size_t *size)
 	} else {
 		if (res->flags & IORESOURCE_ROM_COPY) {
 			*size = pci_resource_len(pdev, PCI_ROM_RESOURCE);
-			return (void __iomem *)pci_resource_start(pdev,
-							     PCI_ROM_RESOURCE);
+			return (void __iomem *)(unsigned long)
+				pci_resource_start(pdev, PCI_ROM_RESOURCE);
 		} else {
 			/* assign the ROM an address if it doesn't have one */
 			if (res->parent == NULL &&
@@ -170,11 +170,11 @@ void __iomem *pci_map_rom_copy(struct pci_dev *pdev, size_t *size)
 		return rom;
 
 	res->end = res->start + *size;
-	memcpy_fromio((void*)res->start, rom, *size);
+	memcpy_fromio((void*)(unsigned long)res->start, rom, *size);
 	pci_unmap_rom(pdev, rom);
 	res->flags |= IORESOURCE_ROM_COPY;
 
-	return (void __iomem *)res->start;
+	return (void __iomem *)(unsigned long)res->start;
 }
 
 /**
@@ -227,7 +227,7 @@ void pci_cleanup_rom(struct pci_dev *pdev)
 {
 	struct resource *res = &pdev->resource[PCI_ROM_RESOURCE];
 	if (res->flags & IORESOURCE_ROM_COPY) {
-		kfree((void*)res->start);
+		kfree((void*)(unsigned long)res->start);
 		res->flags &= ~IORESOURCE_ROM_COPY;
 		res->start = 0;
 		res->end = 0;

commit 4e57b6817880946a3a78d5d8cad1ace363f7e449
Author: Tim Schmielau <tim@physik3.uni-rostock.de>
Date:   Sun Oct 30 15:03:48 2005 -0800

    [PATCH] fix missing includes
    
    I recently picked up my older work to remove unnecessary #includes of
    sched.h, starting from a patch by Dave Jones to not include sched.h
    from module.h. This reduces the number of indirect includes of sched.h
    by ~300. Another ~400 pointless direct includes can be removed after
    this disentangling (patch to follow later).
    However, quite a few indirect includes need to be fixed up for this.
    
    In order to feed the patches through -mm with as little disturbance as
    possible, I've split out the fixes I accumulated up to now (complete for
    i386 and x86_64, more archs to follow later) and post them before the real
    patch.  This way this large part of the patch is kept simple with only
    adding #includes, and all hunks are independent of each other.  So if any
    hunk rejects or gets in the way of other patches, just drop it.  My scripts
    will pick it up again in the next round.
    
    Signed-off-by: Tim Schmielau <tim@physik3.uni-rostock.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/pci/rom.c b/drivers/pci/rom.c
index 49bd21702314..598a115cd00e 100644
--- a/drivers/pci/rom.c
+++ b/drivers/pci/rom.c
@@ -9,6 +9,7 @@
 #include <linux/config.h>
 #include <linux/kernel.h>
 #include <linux/pci.h>
+#include <linux/slab.h>
 
 #include "pci.h"
 

commit 8085ce084c0f0144c353963853f81486fc331120
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Wed Aug 31 14:16:53 2005 +1000

    [PATCH] Fix PCI ROM mapping
    
    This fixes a problem with pci_map_rom() which doesn't properly
    update the ROM BAR value with the address thas allocated for it by the
    PCI code. This problem, among other, breaks boot on Mac laptops.
    
    It'ss a new version based on Linus latest one with better error
    checking.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/pci/rom.c b/drivers/pci/rom.c
index 713c78f3a65d..49bd21702314 100644
--- a/drivers/pci/rom.c
+++ b/drivers/pci/rom.c
@@ -21,13 +21,21 @@
  * between the ROM and other resources, so enabling it may disable access
  * to MMIO registers or other card memory.
  */
-static void pci_enable_rom(struct pci_dev *pdev)
+static int pci_enable_rom(struct pci_dev *pdev)
 {
+	struct resource *res = pdev->resource + PCI_ROM_RESOURCE;
+	struct pci_bus_region region;
 	u32 rom_addr;
 
+	if (!res->flags)
+		return -1;
+
+	pcibios_resource_to_bus(pdev, &region, res);
 	pci_read_config_dword(pdev, pdev->rom_base_reg, &rom_addr);
-	rom_addr |= PCI_ROM_ADDRESS_ENABLE;
+	rom_addr &= ~PCI_ROM_ADDRESS_MASK;
+	rom_addr |= region.start | PCI_ROM_ADDRESS_ENABLE;
 	pci_write_config_dword(pdev, pdev->rom_base_reg, rom_addr);
+	return 0;
 }
 
 /**
@@ -71,19 +79,21 @@ void __iomem *pci_map_rom(struct pci_dev *pdev, size_t *size)
 	} else {
 		if (res->flags & IORESOURCE_ROM_COPY) {
 			*size = pci_resource_len(pdev, PCI_ROM_RESOURCE);
-			return (void __iomem *)pci_resource_start(pdev, PCI_ROM_RESOURCE);
+			return (void __iomem *)pci_resource_start(pdev,
+							     PCI_ROM_RESOURCE);
 		} else {
 			/* assign the ROM an address if it doesn't have one */
-			if (res->parent == NULL)
-				pci_assign_resource(pdev, PCI_ROM_RESOURCE);
-
+			if (res->parent == NULL &&
+			    pci_assign_resource(pdev,PCI_ROM_RESOURCE))
+				return NULL;
 			start = pci_resource_start(pdev, PCI_ROM_RESOURCE);
 			*size = pci_resource_len(pdev, PCI_ROM_RESOURCE);
 			if (*size == 0)
 				return NULL;
 
 			/* Enable ROM space decodes */
-			pci_enable_rom(pdev);
+			if (pci_enable_rom(pdev))
+				return NULL;
 		}
 	}
 

commit 761a3ac08c63718dacde12aaf0ec6d6760e8c2b7
Author: Jon Smirl <jonsmirl@gmail.com>
Date:   Fri Jul 29 12:16:17 2005 -0700

    [PATCH] PCI: Adjust PCI rom code to handle more broken ROMs
    
    There are ROMs reporting that their size exceeds their PCI ROM
    resource window. This patch returns the minimum of the resource window
    size or the size in the ROM.  An example of this breakage is the XGI
    Volari Z7.
    
    Signed-off-by: Jon Smirl <jonsmirl@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/pci/rom.c b/drivers/pci/rom.c
index 838575e3fac6..713c78f3a65d 100644
--- a/drivers/pci/rom.c
+++ b/drivers/pci/rom.c
@@ -125,7 +125,9 @@ void __iomem *pci_map_rom(struct pci_dev *pdev, size_t *size)
 		image += readw(pds + 16) * 512;
 	} while (!last_image);
 
-	*size = image - rom;
+	/* never return a size larger than the PCI resource window */
+	/* there are known ROMs that get the size wrong */
+	*size = min((size_t)(image - rom), *size);
 
 	return rom;
 }

commit 67be2dd1bace0ec7ce2dbc1bba3f8df3d7be597e
Author: Martin Waitz <tali@admingilde.org>
Date:   Sun May 1 08:59:26 2005 -0700

    [PATCH] DocBook: fix some descriptions
    
    Some KernelDoc descriptions are updated to match the current code.
    No code changes.
    
    Signed-off-by: Martin Waitz <tali@admingilde.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/pci/rom.c b/drivers/pci/rom.c
index 3e64ff64b38c..838575e3fac6 100644
--- a/drivers/pci/rom.c
+++ b/drivers/pci/rom.c
@@ -14,7 +14,7 @@
 
 /**
  * pci_enable_rom - enable ROM decoding for a PCI device
- * @dev: PCI device to enable
+ * @pdev: PCI device to enable
  *
  * Enable ROM decoding on @dev.  This involves simply turning on the last
  * bit of the PCI ROM BAR.  Note that some cards may share address decoders
@@ -32,7 +32,7 @@ static void pci_enable_rom(struct pci_dev *pdev)
 
 /**
  * pci_disable_rom - disable ROM decoding for a PCI device
- * @dev: PCI device to disable
+ * @pdev: PCI device to disable
  *
  * Disable ROM decoding on a PCI device by turning off the last bit in the
  * ROM BAR.
@@ -47,7 +47,7 @@ static void pci_disable_rom(struct pci_dev *pdev)
 
 /**
  * pci_map_rom - map a PCI ROM to kernel space
- * @dev: pointer to pci device struct
+ * @pdev: pointer to pci device struct
  * @size: pointer to receive size of pci window over ROM
  * @return: kernel virtual pointer to image of ROM
  *
@@ -132,7 +132,7 @@ void __iomem *pci_map_rom(struct pci_dev *pdev, size_t *size)
 
 /**
  * pci_map_rom_copy - map a PCI ROM to kernel space, create a copy
- * @dev: pointer to pci device struct
+ * @pdev: pointer to pci device struct
  * @size: pointer to receive size of pci window over ROM
  * @return: kernel virtual pointer to image of ROM
  *
@@ -166,7 +166,7 @@ void __iomem *pci_map_rom_copy(struct pci_dev *pdev, size_t *size)
 
 /**
  * pci_unmap_rom - unmap the ROM from kernel space
- * @dev: pointer to pci device struct
+ * @pdev: pointer to pci device struct
  * @rom: virtual address of the previous mapping
  *
  * Remove a mapping of a previously mapped ROM
@@ -187,7 +187,7 @@ void pci_unmap_rom(struct pci_dev *pdev, void __iomem *rom)
 
 /**
  * pci_remove_rom - disable the ROM and remove its sysfs attribute
- * @dev: pointer to pci device struct
+ * @pdev: pointer to pci device struct
  *
  * Remove the rom file in sysfs and disable ROM decoding.
  */
@@ -206,7 +206,7 @@ void pci_remove_rom(struct pci_dev *pdev)
 /**
  * pci_cleanup_rom - internal routine for freeing the ROM copy created
  * by pci_map_rom_copy called from remove.c
- * @dev: pointer to pci device struct
+ * @pdev: pointer to pci device struct
  *
  * Free the copied ROM if we allocated one.
  */

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/pci/rom.c b/drivers/pci/rom.c
new file mode 100644
index 000000000000..3e64ff64b38c
--- /dev/null
+++ b/drivers/pci/rom.c
@@ -0,0 +1,227 @@
+/*
+ * drivers/pci/rom.c
+ *
+ * (C) Copyright 2004 Jon Smirl <jonsmirl@yahoo.com>
+ * (C) Copyright 2004 Silicon Graphics, Inc. Jesse Barnes <jbarnes@sgi.com>
+ *
+ * PCI ROM access routines
+ */
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/pci.h>
+
+#include "pci.h"
+
+/**
+ * pci_enable_rom - enable ROM decoding for a PCI device
+ * @dev: PCI device to enable
+ *
+ * Enable ROM decoding on @dev.  This involves simply turning on the last
+ * bit of the PCI ROM BAR.  Note that some cards may share address decoders
+ * between the ROM and other resources, so enabling it may disable access
+ * to MMIO registers or other card memory.
+ */
+static void pci_enable_rom(struct pci_dev *pdev)
+{
+	u32 rom_addr;
+
+	pci_read_config_dword(pdev, pdev->rom_base_reg, &rom_addr);
+	rom_addr |= PCI_ROM_ADDRESS_ENABLE;
+	pci_write_config_dword(pdev, pdev->rom_base_reg, rom_addr);
+}
+
+/**
+ * pci_disable_rom - disable ROM decoding for a PCI device
+ * @dev: PCI device to disable
+ *
+ * Disable ROM decoding on a PCI device by turning off the last bit in the
+ * ROM BAR.
+ */
+static void pci_disable_rom(struct pci_dev *pdev)
+{
+	u32 rom_addr;
+	pci_read_config_dword(pdev, pdev->rom_base_reg, &rom_addr);
+	rom_addr &= ~PCI_ROM_ADDRESS_ENABLE;
+	pci_write_config_dword(pdev, pdev->rom_base_reg, rom_addr);
+}
+
+/**
+ * pci_map_rom - map a PCI ROM to kernel space
+ * @dev: pointer to pci device struct
+ * @size: pointer to receive size of pci window over ROM
+ * @return: kernel virtual pointer to image of ROM
+ *
+ * Map a PCI ROM into kernel space. If ROM is boot video ROM,
+ * the shadow BIOS copy will be returned instead of the
+ * actual ROM.
+ */
+void __iomem *pci_map_rom(struct pci_dev *pdev, size_t *size)
+{
+	struct resource *res = &pdev->resource[PCI_ROM_RESOURCE];
+	loff_t start;
+	void __iomem *rom;
+	void __iomem *image;
+	int last_image;
+
+	/* IORESOURCE_ROM_SHADOW only set on x86 */
+	if (res->flags & IORESOURCE_ROM_SHADOW) {
+		/* primary video rom always starts here */
+		start = (loff_t)0xC0000;
+		*size = 0x20000; /* cover C000:0 through E000:0 */
+	} else {
+		if (res->flags & IORESOURCE_ROM_COPY) {
+			*size = pci_resource_len(pdev, PCI_ROM_RESOURCE);
+			return (void __iomem *)pci_resource_start(pdev, PCI_ROM_RESOURCE);
+		} else {
+			/* assign the ROM an address if it doesn't have one */
+			if (res->parent == NULL)
+				pci_assign_resource(pdev, PCI_ROM_RESOURCE);
+
+			start = pci_resource_start(pdev, PCI_ROM_RESOURCE);
+			*size = pci_resource_len(pdev, PCI_ROM_RESOURCE);
+			if (*size == 0)
+				return NULL;
+
+			/* Enable ROM space decodes */
+			pci_enable_rom(pdev);
+		}
+	}
+
+	rom = ioremap(start, *size);
+	if (!rom) {
+		/* restore enable if ioremap fails */
+		if (!(res->flags & (IORESOURCE_ROM_ENABLE |
+				    IORESOURCE_ROM_SHADOW |
+				    IORESOURCE_ROM_COPY)))
+			pci_disable_rom(pdev);
+		return NULL;
+	}
+
+	/*
+	 * Try to find the true size of the ROM since sometimes the PCI window
+	 * size is much larger than the actual size of the ROM.
+	 * True size is important if the ROM is going to be copied.
+	 */
+	image = rom;
+	do {
+		void __iomem *pds;
+		/* Standard PCI ROMs start out with these bytes 55 AA */
+		if (readb(image) != 0x55)
+			break;
+		if (readb(image + 1) != 0xAA)
+			break;
+		/* get the PCI data structure and check its signature */
+		pds = image + readw(image + 24);
+		if (readb(pds) != 'P')
+			break;
+		if (readb(pds + 1) != 'C')
+			break;
+		if (readb(pds + 2) != 'I')
+			break;
+		if (readb(pds + 3) != 'R')
+			break;
+		last_image = readb(pds + 21) & 0x80;
+		/* this length is reliable */
+		image += readw(pds + 16) * 512;
+	} while (!last_image);
+
+	*size = image - rom;
+
+	return rom;
+}
+
+/**
+ * pci_map_rom_copy - map a PCI ROM to kernel space, create a copy
+ * @dev: pointer to pci device struct
+ * @size: pointer to receive size of pci window over ROM
+ * @return: kernel virtual pointer to image of ROM
+ *
+ * Map a PCI ROM into kernel space. If ROM is boot video ROM,
+ * the shadow BIOS copy will be returned instead of the
+ * actual ROM.
+ */
+void __iomem *pci_map_rom_copy(struct pci_dev *pdev, size_t *size)
+{
+	struct resource *res = &pdev->resource[PCI_ROM_RESOURCE];
+	void __iomem *rom;
+
+	rom = pci_map_rom(pdev, size);
+	if (!rom)
+		return NULL;
+
+	if (res->flags & (IORESOURCE_ROM_COPY | IORESOURCE_ROM_SHADOW))
+		return rom;
+
+	res->start = (unsigned long)kmalloc(*size, GFP_KERNEL);
+	if (!res->start)
+		return rom;
+
+	res->end = res->start + *size;
+	memcpy_fromio((void*)res->start, rom, *size);
+	pci_unmap_rom(pdev, rom);
+	res->flags |= IORESOURCE_ROM_COPY;
+
+	return (void __iomem *)res->start;
+}
+
+/**
+ * pci_unmap_rom - unmap the ROM from kernel space
+ * @dev: pointer to pci device struct
+ * @rom: virtual address of the previous mapping
+ *
+ * Remove a mapping of a previously mapped ROM
+ */
+void pci_unmap_rom(struct pci_dev *pdev, void __iomem *rom)
+{
+	struct resource *res = &pdev->resource[PCI_ROM_RESOURCE];
+
+	if (res->flags & IORESOURCE_ROM_COPY)
+		return;
+
+	iounmap(rom);
+
+	/* Disable again before continuing, leave enabled if pci=rom */
+	if (!(res->flags & (IORESOURCE_ROM_ENABLE | IORESOURCE_ROM_SHADOW)))
+		pci_disable_rom(pdev);
+}
+
+/**
+ * pci_remove_rom - disable the ROM and remove its sysfs attribute
+ * @dev: pointer to pci device struct
+ *
+ * Remove the rom file in sysfs and disable ROM decoding.
+ */
+void pci_remove_rom(struct pci_dev *pdev)
+{
+	struct resource *res = &pdev->resource[PCI_ROM_RESOURCE];
+
+	if (pci_resource_len(pdev, PCI_ROM_RESOURCE))
+		sysfs_remove_bin_file(&pdev->dev.kobj, pdev->rom_attr);
+	if (!(res->flags & (IORESOURCE_ROM_ENABLE |
+			    IORESOURCE_ROM_SHADOW |
+			    IORESOURCE_ROM_COPY)))
+		pci_disable_rom(pdev);
+}
+
+/**
+ * pci_cleanup_rom - internal routine for freeing the ROM copy created
+ * by pci_map_rom_copy called from remove.c
+ * @dev: pointer to pci device struct
+ *
+ * Free the copied ROM if we allocated one.
+ */
+void pci_cleanup_rom(struct pci_dev *pdev)
+{
+	struct resource *res = &pdev->resource[PCI_ROM_RESOURCE];
+	if (res->flags & IORESOURCE_ROM_COPY) {
+		kfree((void*)res->start);
+		res->flags &= ~IORESOURCE_ROM_COPY;
+		res->start = 0;
+		res->end = 0;
+	}
+}
+
+EXPORT_SYMBOL(pci_map_rom);
+EXPORT_SYMBOL(pci_map_rom_copy);
+EXPORT_SYMBOL(pci_unmap_rom);
+EXPORT_SYMBOL(pci_remove_rom);
