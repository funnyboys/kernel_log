commit ae7322a06d225fadfc43a3eda950fc2b65d2d7a1
Merge: ff33cc2fc01c ec411e02b7a2
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Jun 4 12:59:12 2020 -0500

    Merge branch 'pci/pm'
    
      - Check .bridge_d3() hook for NULL before calling it (Bjorn Helgaas)
    
      - Disable PME# for Pericom OHCI/UHCI USB controllers because it's
        not reliably asserted on USB hotplug (Kai-Heng Feng)
    
      - Assume ports without DLL Link Active train links in 100 ms to work
        around Thunderbolt bridge defects (Mika Westerberg)
    
    * pci/pm:
      PCI/PM: Assume ports without DLL Link Active train links in 100 ms
      PCI/PM: Adjust pcie_wait_for_link_delay() for caller delay
      PCI: Avoid Pericom USB controller OHCI/EHCI PME# defect
      serial: 8250_pci: Move Pericom IDs to pci_ids.h
      PCI/PM: Call .bridge_d3() hook only if non-NULL

commit ec411e02b7a2e785a4ed9ed283207cd14f48699d
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Thu May 14 16:30:43 2020 +0300

    PCI/PM: Assume ports without DLL Link Active train links in 100 ms
    
    Kai-Heng Feng reported that it takes a long time (> 1 s) to resume
    Thunderbolt-connected devices from both runtime suspend and system sleep
    (s2idle).
    
    This was because some Downstream Ports that support > 5 GT/s do not also
    support Data Link Layer Link Active reporting.  Per PCIe r5.0 sec 6.6.1:
    
      With a Downstream Port that supports Link speeds greater than 5.0 GT/s,
      software must wait a minimum of 100 ms after Link training completes
      before sending a Configuration Request to the device immediately below
      that Port. Software can determine when Link training completes by polling
      the Data Link Layer Link Active bit or by setting up an associated
      interrupt (see Section 6.7.3.3).
    
    Sec 7.5.3.6 requires such Ports to support DLL Link Active reporting, but
    at least the Intel JHL6240 Thunderbolt 3 Bridge [8086:15c0] and the Intel
    JHL7540 Thunderbolt 3 Bridge [8086:15ea] do not.
    
    Previously we tried to wait for Link training to complete, but since there
    was no DLL Link Active reporting, all we could do was wait the worst-case
    1000 ms, then another 100 ms.
    
    Instead of using the supported speeds to determine whether to wait for Link
    training, check whether the port supports DLL Link Active reporting.  The
    Ports in question do not, so we'll wait only the 100 ms required for Ports
    that support Link speeds <= 5 GT/s.
    
    This of course assumes these Ports always train the Link within 100 ms even
    if they are operating at > 5 GT/s, which is not required by the spec.
    
    [bhelgaas: commit log, comment]
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=206837
    Link: https://lore.kernel.org/r/20200514133043.27429-1-mika.westerberg@linux.intel.com
    Reported-by: Kai-Heng Feng <kai.heng.feng@canonical.com>
    Tested-by: Kai-Heng Feng <kai.heng.feng@canonical.com>
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index a4efc7e0061f..d4758518a97b 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -4662,7 +4662,8 @@ static int pci_pm_reset(struct pci_dev *dev, int probe)
  * pcie_wait_for_link_delay - Wait until link is active or inactive
  * @pdev: Bridge device
  * @active: waiting for active or inactive?
- * @delay: Delay to wait after link has become active (in ms)
+ * @delay: Delay to wait after link has become active (in ms). Specify %0
+ *	   for no delay.
  *
  * Use this to wait till link becomes active or inactive.
  */
@@ -4703,7 +4704,7 @@ static bool pcie_wait_for_link_delay(struct pci_dev *pdev, bool active,
 		msleep(10);
 		timeout -= 10;
 	}
-	if (active && ret)
+	if (active && ret && delay)
 		msleep(delay);
 	else if (ret != active)
 		pci_info(pdev, "Data Link Layer Link Active not %s in 1000 msec\n",
@@ -4824,17 +4825,28 @@ void pci_bridge_wait_for_secondary_bus(struct pci_dev *dev)
 	if (!pcie_downstream_port(dev))
 		return;
 
-	if (pcie_get_speed_cap(dev) <= PCIE_SPEED_5_0GT) {
-		pci_dbg(dev, "waiting %d ms for downstream link\n", delay);
-		msleep(delay);
-	} else {
-		pci_dbg(dev, "waiting %d ms for downstream link, after activation\n",
-			delay);
-		if (!pcie_wait_for_link_delay(dev, true, delay)) {
+	/*
+	 * Per PCIe r5.0, sec 6.6.1, for downstream ports that support
+	 * speeds > 5 GT/s, we must wait for link training to complete
+	 * before the mandatory delay.
+	 *
+	 * We can only tell when link training completes via DLL Link
+	 * Active, which is required for downstream ports that support
+	 * speeds > 5 GT/s (sec 7.5.3.6).  Unfortunately some common
+	 * devices do not implement Link Active reporting even when it's
+	 * required, so we'll check for that directly instead of checking
+	 * the supported link speed.  We assume devices without Link Active
+	 * reporting can train in 100 ms regardless of speed.
+	 */
+	if (dev->link_active_reporting) {
+		pci_dbg(dev, "waiting for link to train\n");
+		if (!pcie_wait_for_link_delay(dev, true, 0)) {
 			/* Did not train, no need to wait any further */
 			return;
 		}
 	}
+	pci_dbg(child, "waiting %d ms to become accessible\n", delay);
+	msleep(delay);
 
 	if (!pci_device_is_present(child)) {
 		pci_dbg(child, "waiting additional %d ms to become accessible\n", delay);

commit f044baaff1eb7ae5aa7a36f1b7ad5bd8eeb672c4
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri May 15 14:31:16 2020 -0500

    PCI/PM: Adjust pcie_wait_for_link_delay() for caller delay
    
    The caller of pcie_wait_for_link_delay() specifies the time to wait after
    the link becomes active.  When the downstream port doesn't support link
    active reporting, obviously we can't tell when the link becomes active, so
    we waited the worst-case time (1000 ms) plus 100 ms, ignoring the delay
    from the caller.
    
    Instead, wait for 1000 ms + the delay from the caller.
    
    Fixes: 4827d63891b6 ("PCI/PM: Add pcie_wait_for_link_delay()")
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index dfa7ec008963..a4efc7e0061f 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -4675,10 +4675,10 @@ static bool pcie_wait_for_link_delay(struct pci_dev *pdev, bool active,
 
 	/*
 	 * Some controllers might not implement link active reporting. In this
-	 * case, we wait for 1000 + 100 ms.
+	 * case, we wait for 1000 ms + any delay requested by the caller.
 	 */
 	if (!pdev->link_active_reporting) {
-		msleep(1100);
+		msleep(timeout + delay);
 		return true;
 	}
 

commit 6ae72bfa656ea04806f98ef85cb44b0789064362
Author: Yicong Yang <yangyicong@hisilicon.com>
Date:   Sat May 9 18:19:28 2020 +0800

    PCI: Unify pcie_find_root_port() and pci_find_pcie_root_port()
    
    Previously we used pcie_find_root_port() to find a Root Port from a PCIe
    device and pci_find_pcie_root_port() to find a Root Port from a
    Conventional PCI device.
    
    Unify the two functions and use pcie_find_root_port() to find a Root Port
    from either a Conventional PCI device or a PCIe device.  Then there is no
    need to distinguish the type of the device.
    
    Link: https://lore.kernel.org/r/1589019568-5216-1-git-send-email-yangyicong@hisilicon.com
    Signed-off-by: Yicong Yang <yangyicong@hisilicon.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Kalle Valo <kvalo@codeaurora.org> # wireless
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com> # thunderbolt

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index bb78f580814e..227a3a979ec4 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -751,30 +751,6 @@ struct resource *pci_find_resource(struct pci_dev *dev, struct resource *res)
 }
 EXPORT_SYMBOL(pci_find_resource);
 
-/**
- * pci_find_pcie_root_port - return PCIe Root Port
- * @dev: PCI device to query
- *
- * Traverse up the parent chain and return the PCIe Root Port PCI Device
- * for a given PCI Device.
- */
-struct pci_dev *pci_find_pcie_root_port(struct pci_dev *dev)
-{
-	struct pci_dev *bridge, *highest_pcie_bridge = dev;
-
-	bridge = pci_upstream_bridge(dev);
-	while (bridge && pci_is_pcie(bridge)) {
-		highest_pcie_bridge = bridge;
-		bridge = pci_upstream_bridge(bridge);
-	}
-
-	if (pci_pcie_type(highest_pcie_bridge) != PCI_EXP_TYPE_ROOT_PORT)
-		return NULL;
-
-	return highest_pcie_bridge;
-}
-EXPORT_SYMBOL(pci_find_pcie_root_port);
-
 /**
  * pci_wait_for_pending - wait for @mask bit(s) to clear in status word @pos
  * @dev: the PCI device to operate on

commit 914a1951d88968371c7d43400c9d936382cd7d69
Author: Gustavo A. R. Silva <gustavoars@kernel.org>
Date:   Thu May 7 14:05:44 2020 -0500

    PCI: Replace zero-length array with flexible-array
    
    The current codebase makes use of the zero-length array language extension
    to the C90 standard, but the preferred mechanism to declare variable-length
    types such as these as a flexible array member [1][2], introduced in C99:
    
      struct foo {
        int stuff;
        struct boo array[];
      };
    
    By making use of the mechanism above, we will get a compiler warning in
    case the flexible array does not occur last in the structure, which will
    help us prevent some kind of undefined behavior bugs from being
    inadvertently introduced[3] to the codebase from now on.
    
    Also, notice that dynamic memory allocations won't be affected by this
    change:
    
      Flexible array members have incomplete type, and so the sizeof operator
      may not be applied. As a quirk of the original implementation of
      zero-length arrays, sizeof evaluates to zero. [1]
    
    sizeof(flexible-array-member) triggers a warning because flexible array
    members have incomplete type [1]. There are some instances of code in which
    the sizeof() operator is being incorrectly/erroneously applied to
    zero-length arrays, and the result is zero. Such instances may be hiding
    some bugs. So, this work (flexible-array member conversions) will also help
    to get completely rid of those sorts of issues.
    
    This issue was found with the help of Coccinelle.
    
    [1] https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html
    [2] https://github.com/KSPP/linux/issues/21
    [3] commit 76497732932f ("cxgb3/l2t: Fix undefined behaviour")
    
    Link: https://lore.kernel.org/r/20200507190544.GA15633@embeddedor
    Signed-off-by: Gustavo A. R. Silva <gustavoars@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 595fcf59843f..bb78f580814e 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1578,7 +1578,7 @@ EXPORT_SYMBOL(pci_restore_state);
 
 struct pci_saved_state {
 	u32 config_space[16];
-	struct pci_cap_saved_data cap[0];
+	struct pci_cap_saved_data cap[];
 };
 
 /**

commit c3aaf086701d05a82c8156ee8620af41e5a7d6fe
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Apr 7 18:23:15 2020 -0500

    PCI/PM: Call .bridge_d3() hook only if non-NULL
    
    26ad34d510a8 ("PCI / ACPI: Whitelist D3 for more PCIe hotplug ports") added
    the struct pci_platform_pm_ops.bridge_d3() function pointer and
    platform_pci_bridge_d3() to use it.
    
    The .bridge_d3() op is implemented by acpi_pci_platform_pm, but not by
    mid_pci_platform_pm.  We don't expect platform_pci_bridge_d3() to be called
    on Intel MID platforms, but nothing in the code itself would prevent that.
    
    Check the .bridge_d3() pointer for NULL before calling it.
    
    Fixes: 26ad34d510a8 ("PCI / ACPI: Whitelist D3 for more PCIe hotplug ports")
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 595fcf59843f..dfa7ec008963 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -868,7 +868,9 @@ static inline bool platform_pci_need_resume(struct pci_dev *dev)
 
 static inline bool platform_pci_bridge_d3(struct pci_dev *dev)
 {
-	return pci_platform_pm ? pci_platform_pm->bridge_d3(dev) : false;
+	if (pci_platform_pm && pci_platform_pm->bridge_d3)
+		return pci_platform_pm->bridge_d3(dev);
+	return false;
 }
 
 /**

commit 86f26a77cb0cf532a92be18d2c065f5158e1a545
Merge: 0ad5b053d438 86ce3c90c910
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Apr 3 14:25:02 2020 -0700

    Merge tag 'pci-v5.7-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull pci updates from Bjorn Helgaas:
     "Enumeration:
    
       - Revert sysfs "rescan" renames that broke apps (Kelsey Skunberg)
    
       - Add more 32 GT/s link speed decoding and improve the implementation
         (Yicong Yang)
    
      Resource management:
    
       - Add support for sizing programmable host bridge apertures and fix a
         related alpha Nautilus regression (Ivan Kokshaysky)
    
      Interrupts:
    
       - Add boot interrupt quirk mechanism for Xeon chipsets and document
         boot interrupts (Sean V Kelley)
    
      PCIe native device hotplug:
    
       - When possible, disable in-band presence detect and use PDS
         (Alexandru Gagniuc)
    
       - Add DMI table for devices that don't use in-band presence detection
         but don't advertise that correctly (Stuart Hayes)
    
       - Fix hang when powering slots up/down via sysfs (Lukas Wunner)
    
       - Fix an MSI interrupt race (Stuart Hayes)
    
      Virtualization:
    
       - Add ACS quirks for Zhaoxin devices (Raymond Pang)
    
      Error handling:
    
       - Add Error Disconnect Recover (EDR) support so firmware can report
         devices disconnected via DPC and we can try to recover (Kuppuswamy
         Sathyanarayanan)
    
      Peer-to-peer DMA:
    
       - Add Intel Sky Lake-E Root Ports B, C, D to the whitelist (Andrew
         Maier)
    
      ASPM:
    
       - Reduce severity of common clock config message (Chris Packham)
    
       - Clear the correct bits when enabling L1 substates, so we don't go
         to the wrong state (Yicong Yang)
    
      Endpoint framework:
    
       - Replace EPF linkup ops with notifier call chain and improve locking
         (Kishon Vijay Abraham I)
    
       - Fix concurrent memory allocation in OB address region (Kishon Vijay
         Abraham I)
    
       - Move PF function number assignment to EPC core to support multiple
         function creation methods (Kishon Vijay Abraham I)
    
       - Fix issue with clearing configfs "start" entry (Kunihiko Hayashi)
    
       - Fix issue with endpoint MSI-X ignoring BAR Indicator and Table
         Offset (Kishon Vijay Abraham I)
    
       - Add support for testing DMA transfers (Kishon Vijay Abraham I)
    
       - Add support for testing > 10 endpoint devices (Kishon Vijay Abraham I)
    
       - Add support for tests to clear IRQ (Kishon Vijay Abraham I)
    
       - Add common DT schema for endpoint controllers (Kishon Vijay Abraham I)
    
      Amlogic Meson PCIe controller driver:
    
       - Add DT bindings for AXG PCIe PHY, shared MIPI/PCIe analog PHY (Remi
         Pommarel)
    
       - Add Amlogic AXG PCIe PHY, AXG MIPI/PCIe analog PHY drivers (Remi
         Pommarel)
    
      Cadence PCIe controller driver:
    
       - Add Root Complex/Endpoint DT schema for Cadence PCIe (Kishon Vijay
         Abraham I)
    
      Intel VMD host bridge driver:
    
       - Add two VMD Device IDs that require bus restriction mode (Sushma
         Kalakota)
    
      Mobiveil PCIe controller driver:
    
       - Refactor and modularize mobiveil driver (Hou Zhiqiang)
    
       - Add support for Mobiveil GPEX Gen4 host (Hou Zhiqiang)
    
      Microsoft Hyper-V host bridge driver:
    
       - Add support for Hyper-V PCI protocol version 1.3 and
         PCI_BUS_RELATIONS2 (Long Li)
    
       - Refactor to prepare for virtual PCI on non-x86 architectures (Boqun
         Feng)
    
       - Fix memory leak in hv_pci_probe()'s error path (Dexuan Cui)
    
      NVIDIA Tegra PCIe controller driver:
    
       - Use pci_parse_request_of_pci_ranges() (Rob Herring)
    
       - Add support for endpoint mode and related DT updates (Vidya Sagar)
    
       - Reduce -EPROBE_DEFER error message log level (Thierry Reding)
    
      Qualcomm PCIe controller driver:
    
       - Restrict class fixup to specific Qualcomm devices (Bjorn Andersson)
    
      Synopsys DesignWare PCIe controller driver:
    
       - Refactor core initialization code for endpoint mode (Vidya Sagar)
    
       - Fix endpoint MSI-X to use correct table address (Kishon Vijay
         Abraham I)
    
      TI DRA7xx PCIe controller driver:
    
       - Fix MSI IRQ handling (Vignesh Raghavendra)
    
      TI Keystone PCIe controller driver:
    
       - Allow AM654 endpoint to raise MSI-X interrupt (Kishon Vijay Abraham I)
    
      Miscellaneous:
    
       - Quirk ASMedia XHCI USB to avoid "PME# from D0" defect (Kai-Heng
         Feng)
    
       - Use ioremap(), not phys_to_virt(), for platform ROM to fix video
         ROM mapping with CONFIG_HIGHMEM (Mikel Rychliski)"
    
    * tag 'pci-v5.7-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (96 commits)
      misc: pci_endpoint_test: remove duplicate macro PCI_ENDPOINT_TEST_STATUS
      PCI: tegra: Print -EPROBE_DEFER error message at debug level
      misc: pci_endpoint_test: Use full pci-endpoint-test name in request_irq()
      misc: pci_endpoint_test: Fix to support > 10 pci-endpoint-test devices
      tools: PCI: Add 'e' to clear IRQ
      misc: pci_endpoint_test: Add ioctl to clear IRQ
      misc: pci_endpoint_test: Avoid using module parameter to determine irqtype
      PCI: keystone: Allow AM654 PCIe Endpoint to raise MSI-X interrupt
      PCI: dwc: Fix dw_pcie_ep_raise_msix_irq() to get correct MSI-X table address
      PCI: endpoint: Fix ->set_msix() to take BIR and offset as arguments
      misc: pci_endpoint_test: Add support to get DMA option from userspace
      tools: PCI: Add 'd' command line option to support DMA
      misc: pci_endpoint_test: Use streaming DMA APIs for buffer allocation
      PCI: endpoint: functions/pci-epf-test: Print throughput information
      PCI: endpoint: functions/pci-epf-test: Add DMA support to transfer data
      PCI: pciehp: Fix MSI interrupt race
      PCI: pciehp: Fix indefinite wait on sysfs requests
      PCI: endpoint: Fix clearing start entry in configfs
      PCI: tegra: Add support for PCIe endpoint mode in Tegra194
      PCI: sysfs: Revert "rescan" file renames
      ...

commit eb81b249ba059443916d6cc0cfa3e1987aa938d9
Merge: 4ea40c380dd5 757bfaa2c351
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Apr 2 14:26:32 2020 -0500

    Merge branch 'pci/enumeration'
    
      - Add PCIe 32 GT/s speed decoding for sysfs "max_link_speed" and dmesg
        notes about available bandwidth (Yicong Yang)
    
      - Simplify and unify PCI bus/link speed reporting (Yicong Yang)
    
    * pci/enumeration:
      PCI: Add PCIE_LNKCAP2_SLS2SPEED() macro
      PCI: Use pci_speed_string() for all PCI/PCI-X/PCIe strings
      PCI: Add pci_speed_string()
      PCI: Add 32 GT/s decoding in some macros

commit 894020fdd88c1e9a74c60b67c0f19f1c7696ba2f
Author: Kuppuswamy Sathyanarayanan <sathyanarayanan.kuppuswamy@linux.intel.com>
Date:   Mon Mar 23 17:26:08 2020 -0700

    PCI/AER: Rationalize error status register clearing
    
    The AER interfaces to clear error status registers were a confusing mess:
    
      - pci_cleanup_aer_uncorrect_error_status() cleared non-fatal errors
        from the Uncorrectable Error Status register.
    
      - pci_aer_clear_fatal_status() cleared fatal errors from the
        Uncorrectable Error Status register.
    
      - pci_cleanup_aer_error_status_regs() cleared the Root Error Status
        register (for Root Ports), the Uncorrectable Error Status register,
        and the Correctable Error Status register.
    
    Rename them to make them consistent:
    
      From                                     To
      ---------------------------------------- -------------------------------
      pci_cleanup_aer_uncorrect_error_status() pci_aer_clear_nonfatal_status()
      pci_aer_clear_fatal_status()             pci_aer_clear_fatal_status()
      pci_cleanup_aer_error_status_regs()      pci_aer_clear_status()
    
    Since pci_cleanup_aer_error_status_regs() (renamed to
    pci_aer_clear_status()) is only used within drivers/pci/, move the
    declaration from <linux/aer.h> to drivers/pci/pci.h.
    
    [bhelgaas: commit log, add renames]
    Link: https://lore.kernel.org/r/d1310a75dc3d28f7e8da4e99c45fbd3e60fe238e.1585000084.git.sathyanarayanan.kuppuswamy@linux.intel.com
    Signed-off-by: Kuppuswamy Sathyanarayanan <sathyanarayanan.kuppuswamy@linux.intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index d828ca835a98..6c6e8c73fd8f 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1503,7 +1503,7 @@ void pci_restore_state(struct pci_dev *dev)
 	pci_restore_rebar_state(dev);
 	pci_restore_dpc_state(dev);
 
-	pci_cleanup_aer_error_status_regs(dev);
+	pci_aer_clear_status(dev);
 	pci_restore_aer_state(dev);
 
 	pci_restore_config_space(dev);

commit 757bfaa2c3515803dde9a6728bbf8c8a3c5f098a
Author: Yicong Yang <yangyicong@hisilicon.com>
Date:   Mon Feb 17 19:13:03 2020 +0800

    PCI: Add PCIE_LNKCAP2_SLS2SPEED() macro
    
    Add PCIE_LNKCAP2_SLS2SPEED macro for transforming raw Link Capabilities 2
    values to the pci_bus_speed. This is next to PCIE_SPEED2MBS_ENC() to make
    it easier to update both places when adding support for new speeds.
    
    Link: https://lore.kernel.org/r/1581937984-40353-10-git-send-email-yangyicong@hisilicon.com
    Signed-off-by: Yicong Yang <yangyicong@hisilicon.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 421587badecf..e79cccbbdd39 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -5784,19 +5784,10 @@ enum pci_bus_speed pcie_get_speed_cap(struct pci_dev *dev)
 	 * where only 2.5 GT/s and 5.0 GT/s speeds were defined.
 	 */
 	pcie_capability_read_dword(dev, PCI_EXP_LNKCAP2, &lnkcap2);
-	if (lnkcap2) { /* PCIe r3.0-compliant */
-		if (lnkcap2 & PCI_EXP_LNKCAP2_SLS_32_0GB)
-			return PCIE_SPEED_32_0GT;
-		else if (lnkcap2 & PCI_EXP_LNKCAP2_SLS_16_0GB)
-			return PCIE_SPEED_16_0GT;
-		else if (lnkcap2 & PCI_EXP_LNKCAP2_SLS_8_0GB)
-			return PCIE_SPEED_8_0GT;
-		else if (lnkcap2 & PCI_EXP_LNKCAP2_SLS_5_0GB)
-			return PCIE_SPEED_5_0GT;
-		else if (lnkcap2 & PCI_EXP_LNKCAP2_SLS_2_5GB)
-			return PCIE_SPEED_2_5GT;
-		return PCI_SPEED_UNKNOWN;
-	}
+
+	/* PCIe r3.0-compliant */
+	if (lnkcap2)
+		return PCIE_LNKCAP2_SLS2SPEED(lnkcap2);
 
 	pcie_capability_read_dword(dev, PCI_EXP_LNKCAP, &lnkcap);
 	if ((lnkcap & PCI_EXP_LNKCAP_SLS) == PCI_EXP_LNKCAP_SLS_5_0GB)

commit 6348a34dcb98d8e285685a205f2a601817fa2d38
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Feb 28 15:24:52 2020 -0600

    PCI: Use pci_speed_string() for all PCI/PCI-X/PCIe strings
    
    Previously some PCI speed strings came from pci_speed_string(), some came
    from the PCIe-specific PCIE_SPEED2STR(), and some came from a PCIe-specific
    switch statement.  These methods were inconsistent:
    
      pci_speed_string()     PCIE_SPEED2STR()     switch
      ------------------     ----------------     ------
      33 MHz PCI
      ...
      2.5 GT/s PCIe          2.5 GT/s             2.5 GT/s
      5.0 GT/s PCIe          5 GT/s               5 GT/s
      8.0 GT/s PCIe          8 GT/s               8 GT/s
      16.0 GT/s PCIe         16 GT/s              16 GT/s
      32.0 GT/s PCIe         32 GT/s              32 GT/s
    
    Standardize on pci_speed_string() as the single source of these strings.
    
    Note that this adds ".0" and "PCIe" to some messages, including sysfs
    "max_link_speed" files, a brcmstb "link up" message, and the link status
    dmesg logging, e.g.,
    
      nvme 0000:01:00.0: 16.000 Gb/s available PCIe bandwidth, limited by 5.0 GT/s PCIe x4 link at 0000:00:01.1 (capable of 31.504 Gb/s with 8.0 GT/s PCIe x4 link)
    
    I think it's better to standardize on a single version of the speed text.
    Previously we had strings like this:
    
      /sys/bus/pci/slots/0/cur_bus_speed: 8.0 GT/s PCIe
      /sys/bus/pci/slots/0/max_bus_speed: 8.0 GT/s PCIe
      /sys/devices/pci0000:00/0000:00:1c.0/current_link_speed: 8 GT/s
      /sys/devices/pci0000:00/0000:00:1c.0/max_link_speed: 8 GT/s
    
    This changes the latter two to match the slots files:
    
      /sys/devices/pci0000:00/0000:00:1c.0/current_link_speed: 8.0 GT/s PCIe
      /sys/devices/pci0000:00/0000:00:1c.0/max_link_speed: 8.0 GT/s PCIe
    
    Based-on-patch by: Yicong Yang <yangyicong@hisilicon.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index d828ca835a98..421587badecf 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -5872,14 +5872,14 @@ void __pcie_print_link_status(struct pci_dev *dev, bool verbose)
 	if (bw_avail >= bw_cap && verbose)
 		pci_info(dev, "%u.%03u Gb/s available PCIe bandwidth (%s x%d link)\n",
 			 bw_cap / 1000, bw_cap % 1000,
-			 PCIE_SPEED2STR(speed_cap), width_cap);
+			 pci_speed_string(speed_cap), width_cap);
 	else if (bw_avail < bw_cap)
 		pci_info(dev, "%u.%03u Gb/s available PCIe bandwidth, limited by %s x%d link at %s (capable of %u.%03u Gb/s with %s x%d link)\n",
 			 bw_avail / 1000, bw_avail % 1000,
-			 PCIE_SPEED2STR(speed), width,
+			 pci_speed_string(speed), width,
 			 limiting_dev ? pci_name(limiting_dev) : "<unknown>",
 			 bw_cap / 1000, bw_cap % 1000,
-			 PCIE_SPEED2STR(speed_cap), width_cap);
+			 pci_speed_string(speed_cap), width_cap);
 }
 
 /**

commit 70c0923b0ef10b1c8d8f78fb50fcaef8eaae619d
Author: Jacob Keller <jacob.e.keller@intel.com>
Date:   Mon Mar 2 18:25:00 2020 -0800

    PCI: Introduce pci_get_dsn
    
    Several device drivers read their Device Serial Number from the PCIe
    extended config space.
    
    Introduce a new helper function, pci_get_dsn(). This function reads the
    eight bytes of the DSN and returns them as a u64. If the capability does not
    exist for the device, the function returns 0.
    
    Signed-off-by: Jacob Keller <jacob.e.keller@intel.com>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
    Cc: Michael Chan <michael.chan@broadcom.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index c16b0ba2a895..86821313c007 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -580,6 +580,40 @@ int pci_find_ext_capability(struct pci_dev *dev, int cap)
 }
 EXPORT_SYMBOL_GPL(pci_find_ext_capability);
 
+/**
+ * pci_get_dsn - Read and return the 8-byte Device Serial Number
+ * @dev: PCI device to query
+ *
+ * Looks up the PCI_EXT_CAP_ID_DSN and reads the 8 bytes of the Device Serial
+ * Number.
+ *
+ * Returns the DSN, or zero if the capability does not exist.
+ */
+u64 pci_get_dsn(struct pci_dev *dev)
+{
+	u32 dword;
+	u64 dsn;
+	int pos;
+
+	pos = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_DSN);
+	if (!pos)
+		return 0;
+
+	/*
+	 * The Device Serial Number is two dwords offset 4 bytes from the
+	 * capability position. The specification says that the first dword is
+	 * the lower half, and the second dword is the upper half.
+	 */
+	pos += 4;
+	pci_read_config_dword(dev, pos, &dword);
+	dsn = (u64)dword;
+	pci_read_config_dword(dev, pos + 4, &dword);
+	dsn |= ((u64)dword) << 32;
+
+	return dsn;
+}
+EXPORT_SYMBOL_GPL(pci_get_dsn);
+
 static int __pci_find_next_ht_cap(struct pci_dev *dev, int pos, int ht_cap)
 {
 	int rc, ttl = PCI_FIND_CAP_TTL;

commit ec5d9e87842a43be3a10ada0d5f560bbd3f31d5d
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Sat Feb 29 23:24:23 2020 +0100

    PCI: Add pci_status_get_and_clear_errors
    
    Several drivers use the following code sequence:
    1. Read PCI_STATUS
    2. Mask out non-error bits
    3. Action based on error bits set
    4. Write back set error bits to clear them
    
    As this is a repeated pattern, add a helper to the PCI core.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index d828ca835a98..c16b0ba2a895 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -173,6 +173,29 @@ unsigned char pci_bus_max_busnr(struct pci_bus *bus)
 }
 EXPORT_SYMBOL_GPL(pci_bus_max_busnr);
 
+/**
+ * pci_status_get_and_clear_errors - return and clear error bits in PCI_STATUS
+ * @pdev: the PCI device
+ *
+ * Returns error bits set in PCI_STATUS and clears them.
+ */
+int pci_status_get_and_clear_errors(struct pci_dev *pdev)
+{
+	u16 status;
+	int ret;
+
+	ret = pci_read_config_word(pdev, PCI_STATUS, &status);
+	if (ret != PCIBIOS_SUCCESSFUL)
+		return -EIO;
+
+	status &= PCI_STATUS_ERROR_BITS;
+	if (status)
+		pci_write_config_word(pdev, PCI_STATUS, status);
+
+	return status;
+}
+EXPORT_SYMBOL_GPL(pci_status_get_and_clear_errors);
+
 #ifdef CONFIG_HAS_IOMEM
 void __iomem *pci_ioremap_bar(struct pci_dev *pdev, int bar)
 {

commit 4fc2ea6a8608d9a649eff5e3c2ee477eb70f0fb6
Merge: d271ab29230b e3b5ee0cfb65
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Feb 5 17:49:54 2020 +0000

    Merge tag 'iommu-updates-v5.6' of git://git.kernel.org/pub/scm/linux/kernel/git/joro/iommu
    
    Pull iommu updates from Joerg Roedel:
    
     - Allow compiling the ARM-SMMU drivers as modules.
    
     - Fixes and cleanups for the ARM-SMMU drivers and io-pgtable code
       collected by Will Deacon. The merge-commit (6855d1ba7537) has all the
       details.
    
     - Cleanup of the iommu_put_resv_regions() call-backs in various
       drivers.
    
     - AMD IOMMU driver cleanups.
    
     - Update for the x2APIC support in the AMD IOMMU driver.
    
     - Preparation patches for Intel VT-d nested mode support.
    
     - RMRR and identity domain handling fixes for the Intel VT-d driver.
    
     - More small fixes and cleanups.
    
    * tag 'iommu-updates-v5.6' of git://git.kernel.org/pub/scm/linux/kernel/git/joro/iommu: (87 commits)
      iommu/amd: Remove the unnecessary assignment
      iommu/vt-d: Remove unnecessary WARN_ON_ONCE()
      iommu/vt-d: Unnecessary to handle default identity domain
      iommu/vt-d: Allow devices with RMRRs to use identity domain
      iommu/vt-d: Add RMRR base and end addresses sanity check
      iommu/vt-d: Mark firmware tainted if RMRR fails sanity check
      iommu/amd: Remove unused struct member
      iommu/amd: Replace two consecutive readl calls with one readq
      iommu/vt-d: Don't reject Host Bridge due to scope mismatch
      PCI/ATS: Add PASID stubs
      iommu/arm-smmu-v3: Return -EBUSY when trying to re-add a device
      iommu/arm-smmu-v3: Improve add_device() error handling
      iommu/arm-smmu-v3: Use WRITE_ONCE() when changing validity of an STE
      iommu/arm-smmu-v3: Add second level of context descriptor table
      iommu/arm-smmu-v3: Prepare for handling arm_smmu_write_ctx_desc() failure
      iommu/arm-smmu-v3: Propagate ssid_bits
      iommu/arm-smmu-v3: Add support for Substream IDs
      iommu/arm-smmu-v3: Add context descriptor tables allocators
      iommu/arm-smmu-v3: Prepare arm_smmu_s1_cfg for SSID support
      ACPI/IORT: Parse SSID property of named component node
      ...

commit 26dca6dbd62d74a5012cafab6b2d6d65a01ea69c
Merge: 846de71bedef 01b810ed7187
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jan 31 14:48:54 2020 -0800

    Merge tag 'pci-v5.6-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI updates from Bjorn Helgaas:
    
     "Resource management:
    
       - Improve resource assignment for hot-added nested bridges, e.g.,
         Thunderbolt (Nicholas Johnson)
    
      Power management:
    
       - Optionally print config space of devices before suspend (Chen Yu)
    
       - Increase D3 delay for AMD Ryzen5/7 XHCI controllers (Daniel Drake)
    
      Virtualization:
    
       - Generalize DMA alias quirks (James Sewart)
    
       - Add DMA alias quirk for PLX PEX NTB (James Sewart)
    
       - Fix IOV memory leak (Navid Emamdoost)
    
      AER:
    
       - Log which device prevents error recovery (Yicong Yang)
    
      Peer-to-peer DMA:
    
       - Whitelist Intel SkyLake-E (Armen Baloyan)
    
      Broadcom iProc host bridge driver:
    
       - Apply PAXC quirk whether driver is built-in or module (Wei Liu)
    
      Broadcom STB host bridge driver:
    
       - Add Broadcom STB PCIe host controller driver (Jim Quinlan)
    
      Intel Gateway SoC host bridge driver:
    
       - Add driver for Intel Gateway SoC (Dilip Kota)
    
      Intel VMD host bridge driver:
    
       - Add support for DMA aliases on other buses (Jon Derrick)
    
       - Remove dma_map_ops overrides (Jon Derrick)
    
       - Remove now-unused X86_DEV_DMA_OPS (Christoph Hellwig)
    
      NVIDIA Tegra host bridge driver:
    
       - Fix Tegra30 afi_pex2_ctrl register offset (Marcel Ziswiler)
    
      Panasonic UniPhier host bridge driver:
    
       - Remove module code since driver can't be built as a module
         (Masahiro Yamada)
    
      Qualcomm host bridge driver:
    
       - Add support for SDM845 PCIe controller (Bjorn Andersson)
    
      TI Keystone host bridge driver:
    
       - Fix "num-viewport" DT property error handling (Kishon Vijay Abraham I)
    
       - Fix link training retries initiation (Yurii Monakov)
    
       - Fix outbound region mapping (Yurii Monakov)
    
      Misc:
    
       - Add Switchtec Gen4 support (Kelvin Cao)
    
       - Add Switchtec Intercomm Notify and Upstream Error Containment
         support (Logan Gunthorpe)
    
       - Use dma_set_mask_and_coherent() since Switchtec supports 64-bit
         addressing (Wesley Sheng)"
    
    * tag 'pci-v5.6-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (60 commits)
      PCI: Allow adjust_bridge_window() to shrink resource if necessary
      PCI: Set resource size directly in adjust_bridge_window()
      PCI: Rename extend_bridge_window() to adjust_bridge_window()
      PCI: Rename extend_bridge_window() parameter
      PCI: Consider alignment of hot-added bridges when assigning resources
      PCI: Remove local variable usage in pci_bus_distribute_available_resources()
      PCI: Pass size + alignment to pci_bus_distribute_available_resources()
      PCI: Rename variables
      PCI: vmd: Add two VMD Device IDs
      PCI: Remove unnecessary braces
      PCI: brcmstb: Add MSI support
      PCI: brcmstb: Add Broadcom STB PCIe host controller driver
      x86/PCI: Remove X86_DEV_DMA_OPS
      PCI: vmd: Remove dma_map_ops overrides
      iommu/vt-d: Remove VMD child device sanity check
      iommu/vt-d: Use pci_real_dma_dev() for mapping
      PCI: Introduce pci_real_dma_dev()
      x86/PCI: Expose VMD's pci_dev in struct pci_sysdata
      x86/PCI: Add to_pci_sysdata() helper
      PCI/AER: Initialize aer_fifo
      ...

commit db83c269d22598ec1f5e3e6692a58a92a153e5f1
Merge: c7417cf36aab db51b4c85fb7
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Jan 29 17:00:02 2020 -0600

    Merge branch 'pci/host-vmd'
    
      - Save VMD's pci_dev in x86 struct pci_sysdata (Jon Derrick)
    
      - Add pci_real_dma_dev() for DMA aliases not on the same bus as requester
        (Jon Derrick)
    
      - Add IOMMU mappings for pci_real_dma_dev() (Jon Derrick)
    
      - Remove IOMMU sanity checks for VMD devices (Jon Derrick)
    
      - Remove VMD dma_map_ops overrides (Jon Derrick)
    
      - Remove unused X86_DEV_DMA_OPS (Christoph Hellwig)
    
      - Add VMD device IDs that need bus restriction mode (Sushma Kalakota)
    
    * pci/host-vmd:
      PCI: vmd: Add two VMD Device IDs
      x86/PCI: Remove X86_DEV_DMA_OPS
      PCI: vmd: Remove dma_map_ops overrides
      iommu/vt-d: Remove VMD child device sanity check
      iommu/vt-d: Use pci_real_dma_dev() for mapping
      PCI: Introduce pci_real_dma_dev()
      x86/PCI: Expose VMD's pci_dev in struct pci_sysdata
      x86/PCI: Add to_pci_sysdata() helper

commit c7417cf36aabb93f3b1e37b7e28bece46711429e
Merge: 5272b7fc3a45 7b90dfc4873b
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Jan 29 17:00:01 2020 -0600

    Merge branch 'pci/virtualization'
    
      - Fix memory leak in pci_iov_add_virtfn() (Navid Emamdoost)
    
      - Extend pci_add_dma_alias() so it can add a range of aliases (James
        Sewart)
    
      - Add DMA aliases for PLX PEX NTB (James Sewart)
    
    * pci/virtualization:
      PCI: Add DMA alias quirk for PLX PEX NTB
      PCI: Add nr_devfns parameter to pci_add_dma_alias()
      PCI: Fix pci_add_dma_alias() bitmask size
      PCI/IOV: Fix memory leak in pci_iov_add_virtfn()

commit 2856ba6020fc5cbf051d5a75b2abb3046072c144
Author: Jon Derrick <jonathan.derrick@intel.com>
Date:   Tue Jan 21 06:37:47 2020 -0700

    PCI: Introduce pci_real_dma_dev()
    
    The current DMA alias implementation requires the aliased device be on the
    same PCI bus as the requester ID.  Add an arch-specific mechanism to point
    to another PCI device when doing mapping and PCI DMA alias search.  The
    default case returns the actual device.
    
    Link: https://lore.kernel.org/r/1579613871-301529-4-git-send-email-jonathan.derrick@intel.com
    Signed-off-by: Jon Derrick <jonathan.derrick@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index e87196cc1a7f..ab2b8bcd29bf 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -6033,7 +6033,9 @@ bool pci_devs_are_dma_aliases(struct pci_dev *dev1, struct pci_dev *dev2)
 	return (dev1->dma_alias_mask &&
 		test_bit(dev2->devfn, dev1->dma_alias_mask)) ||
 	       (dev2->dma_alias_mask &&
-		test_bit(dev1->devfn, dev2->dma_alias_mask));
+		test_bit(dev1->devfn, dev2->dma_alias_mask)) ||
+	       pci_real_dma_dev(dev1) == dev2 ||
+	       pci_real_dma_dev(dev2) == dev1;
 }
 
 bool pci_device_is_present(struct pci_dev *pdev)
@@ -6057,6 +6059,21 @@ void pci_ignore_hotplug(struct pci_dev *dev)
 }
 EXPORT_SYMBOL_GPL(pci_ignore_hotplug);
 
+/**
+ * pci_real_dma_dev - Get PCI DMA device for PCI device
+ * @dev: the PCI device that may have a PCI DMA alias
+ *
+ * Permits the platform to provide architecture-specific functionality to
+ * devices needing to alias DMA to another PCI device on another PCI bus. If
+ * the PCI device is on the same bus, it is recommended to use
+ * pci_add_dma_alias(). This is the default implementation. Architecture
+ * implementations can override this.
+ */
+struct pci_dev __weak *pci_real_dma_dev(struct pci_dev *dev)
+{
+	return dev;
+}
+
 resource_size_t __weak pcibios_default_alignment(void)
 {
 	return 0;

commit 47b802d5d80c2fef3ccd9772d518bd602c83cea1
Author: Chen Yu <yu.c.chen@intel.com>
Date:   Mon Jan 13 14:07:24 2020 +0800

    PCI/PM: Print config space of devices before suspend
    
    When resuming from hibernation (S4, also known as "suspend to disk") on a
    VM, we have seen invalid config space, e.g.,
    
      serial 0000:00:16.3: restoring config space at offset 0x14 (was 0x9104e000, writing 0xffffffff)
    
    To help debug problems like this, log the config space being saved before
    suspend, similar to the log in pci_restore_config_dword() when resuming.
    
    Link: https://lore.kernel.org/r/20200113060724.19571-1-yu.c.chen@intel.com
    [bhelgaas: commit log]
    Signed-off-by: Chen Yu <yu.c.chen@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Len Brown <lenb@kernel.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index e87196cc1a7f..34cde70440c3 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1372,8 +1372,11 @@ int pci_save_state(struct pci_dev *dev)
 {
 	int i;
 	/* XXX: 100% dword access ok here? */
-	for (i = 0; i < 16; i++)
+	for (i = 0; i < 16; i++) {
 		pci_read_config_dword(dev, i * 4, &dev->saved_config_space[i]);
+		pci_dbg(dev, "saving config space at offset %#x (reading %#x)\n",
+			i * 4, dev->saved_config_space[i]);
+	}
 	dev->state_saved = true;
 
 	i = pci_save_pcie_state(dev);

commit 4bdc0d676a643140bdf17dbf7eafedee3d496a3c
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Jan 6 09:43:50 2020 +0100

    remove ioremap_nocache and devm_ioremap_nocache
    
    ioremap has provided non-cached semantics by default since the Linux 2.6
    days, so remove the additional ioremap_nocache interface.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index e87196cc1a7f..df21e3227b57 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -184,7 +184,7 @@ void __iomem *pci_ioremap_bar(struct pci_dev *pdev, int bar)
 		pci_warn(pdev, "can't ioremap BAR %d: %pR\n", bar, res);
 		return NULL;
 	}
-	return ioremap_nocache(res->start, resource_size(res));
+	return ioremap(res->start, resource_size(res));
 }
 EXPORT_SYMBOL_GPL(pci_ioremap_bar);
 

commit 1a373a78b8e2fae1d61dd9c5ed22472045d83d24
Author: Will Deacon <will@kernel.org>
Date:   Thu Dec 19 12:03:40 2019 +0000

    PCI: Export pci_ats_disabled() as a GPL symbol to modules
    
    Building drivers for ATS-aware IOMMUs as modules requires access to
    pci_ats_disabled(). Export it as a GPL symbol to get things working.
    
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Will Deacon <will@kernel.org>
    Tested-by: John Garry <john.garry@huawei.com> # smmu v3
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index e87196cc1a7f..ad746d903ceb 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -131,6 +131,7 @@ bool pci_ats_disabled(void)
 {
 	return pcie_ats_disabled;
 }
+EXPORT_SYMBOL_GPL(pci_ats_disabled);
 
 /* Disable bridge_d3 for all PCIe ports */
 static bool pci_bridge_d3_disable;

commit 09298542cd891b43778db1f65aa3613aa5a562eb
Author: James Sewart <jamessewart@arista.com>
Date:   Tue Dec 10 16:07:30 2019 -0600

    PCI: Add nr_devfns parameter to pci_add_dma_alias()
    
    Add a "nr_devfns" parameter to pci_add_dma_alias() so it can be used to
    create DMA aliases for a range of devfns.
    
    [bhelgaas: incorporate nr_devfns fix from James, update
    quirk_pex_vca_alias() and setup_aliases()]
    Signed-off-by: James Sewart <jamessewart@arista.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 7b5fa2eabe09..951099279192 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -5998,7 +5998,8 @@ EXPORT_SYMBOL_GPL(pci_pr3_present);
 /**
  * pci_add_dma_alias - Add a DMA devfn alias for a device
  * @dev: the PCI device for which alias is added
- * @devfn: alias slot and function
+ * @devfn_from: alias slot and function
+ * @nr_devfns: number of subsequent devfns to alias
  *
  * This helper encodes an 8-bit devfn as a bit number in dma_alias_mask
  * which is used to program permissible bus-devfn source addresses for DMA
@@ -6014,8 +6015,13 @@ EXPORT_SYMBOL_GPL(pci_pr3_present);
  * cannot be left as a userspace activity).  DMA aliases should therefore
  * be configured via quirks, such as the PCI fixup header quirk.
  */
-void pci_add_dma_alias(struct pci_dev *dev, u8 devfn)
+void pci_add_dma_alias(struct pci_dev *dev, u8 devfn_from, unsigned nr_devfns)
 {
+	int devfn_to;
+
+	nr_devfns = min(nr_devfns, (unsigned) MAX_NR_DEVFNS - devfn_from);
+	devfn_to = devfn_from + nr_devfns - 1;
+
 	if (!dev->dma_alias_mask)
 		dev->dma_alias_mask = bitmap_zalloc(MAX_NR_DEVFNS, GFP_KERNEL);
 	if (!dev->dma_alias_mask) {
@@ -6023,9 +6029,15 @@ void pci_add_dma_alias(struct pci_dev *dev, u8 devfn)
 		return;
 	}
 
-	set_bit(devfn, dev->dma_alias_mask);
-	pci_info(dev, "Enabling fixed DMA alias to %02x.%d\n",
-		 PCI_SLOT(devfn), PCI_FUNC(devfn));
+	bitmap_set(dev->dma_alias_mask, devfn_from, nr_devfns);
+
+	if (nr_devfns == 1)
+		pci_info(dev, "Enabling fixed DMA alias to %02x.%d\n",
+				PCI_SLOT(devfn_from), PCI_FUNC(devfn_from));
+	else if (nr_devfns > 1)
+		pci_info(dev, "Enabling fixed DMA alias for devfn range from %02x.%d to %02x.%d\n",
+				PCI_SLOT(devfn_from), PCI_FUNC(devfn_from),
+				PCI_SLOT(devfn_to), PCI_FUNC(devfn_to));
 }
 
 bool pci_devs_are_dma_aliases(struct pci_dev *dev1, struct pci_dev *dev2)

commit f8bf2aeb651b3460a4b36fd7ba1ba1d31777d35c
Author: James Sewart <jamessewart@arista.com>
Date:   Tue Dec 10 15:51:33 2019 -0600

    PCI: Fix pci_add_dma_alias() bitmask size
    
    The number of possible devfns is 256, but pci_add_dma_alias() allocated a
    bitmap of size 255.  Fix this off-by-one error.
    
    This fixes commits 338c3149a221 ("PCI: Add support for multiple DMA
    aliases") and c6635792737b ("PCI: Allocate dma_alias_mask with
    bitmap_zalloc()"), but I doubt it was possible to see a problem because
    it takes 4 64-bit longs (or 8 32-bit longs) to hold 255 bits, and
    bitmap_zalloc() doesn't save the 255-bit size anywhere.
    
    [bhelgaas: commit log, move #define to drivers/pci/pci.h, include loop
    limit fix from Qian Cai:
    https://lore.kernel.org/r/20191218170004.5297-1-cai@lca.pw]
    Signed-off-by: James Sewart <jamessewart@arista.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Logan Gunthorpe <logang@deltatee.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index e87196cc1a7f..7b5fa2eabe09 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -6017,7 +6017,7 @@ EXPORT_SYMBOL_GPL(pci_pr3_present);
 void pci_add_dma_alias(struct pci_dev *dev, u8 devfn)
 {
 	if (!dev->dma_alias_mask)
-		dev->dma_alias_mask = bitmap_zalloc(U8_MAX, GFP_KERNEL);
+		dev->dma_alias_mask = bitmap_zalloc(MAX_NR_DEVFNS, GFP_KERNEL);
 	if (!dev->dma_alias_mask) {
 		pci_warn(dev, "Unable to allocate DMA alias mask\n");
 		return;

commit c3bed3b20e40ab44b98ac5f0471a5bd92a802f5a
Merge: 4672c2f2026d 7e124c405172
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Dec 3 13:58:22 2019 -0800

    Merge tag 'pci-v5.5-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI updates from Bjorn Helgaas:
     "Enumeration:
    
       - Warn if a host bridge has no NUMA info (Yunsheng Lin)
    
       - Add PCI_STD_NUM_BARS for the number of standard BARs (Denis
         Efremov)
    
      Resource management:
    
       - Fix boot-time Embedded Controller GPE storm caused by incorrect
         resource assignment after ACPI Bus Check Notification (Mika
         Westerberg)
    
       - Protect pci_reassign_bridge_resources() against concurrent
         addition/removal (Benjamin Herrenschmidt)
    
       - Fix bridge dma_ranges resource list cleanup (Rob Herring)
    
       - Add "pci=hpmmiosize" and "pci=hpmmioprefsize" parameters to control
         the MMIO and prefetchable MMIO window sizes of hotplug bridges
         independently (Nicholas Johnson)
    
       - Fix MMIO/MMIO_PREF window assignment that assigned more space than
         desired (Nicholas Johnson)
    
       - Only enforce bus numbers from bridge EA if the bridge has EA
         devices downstream (Subbaraya Sundeep)
    
       - Consolidate DT "dma-ranges" parsing and convert all host drivers to
         use shared parsing (Rob Herring)
    
      Error reporting:
    
       - Restore AER capability after resume (Mayurkumar Patel)
    
       - Add PoisonTLPBlocked AER counter (Rajat Jain)
    
       - Use for_each_set_bit() to simplify AER code (Andy Shevchenko)
    
       - Fix AER kernel-doc (Andy Shevchenko)
    
       - Add "pcie_ports=dpc-native" parameter to allow native use of DPC
         even if platform didn't grant control over AER (Olof Johansson)
    
      Hotplug:
    
       - Avoid returning prematurely from sysfs requests to enable or
         disable a PCIe hotplug slot (Lukas Wunner)
    
       - Don't disable interrupts twice when suspending hotplug ports (Mika
         Westerberg)
    
       - Fix deadlocks when PCIe ports are hot-removed while suspended (Mika
         Westerberg)
    
      Power management:
    
       - Remove unnecessary ASPM locking (Bjorn Helgaas)
    
       - Add support for disabling L1 PM Substates (Heiner Kallweit)
    
       - Allow re-enabling Clock PM after it has been disabled (Heiner
         Kallweit)
    
       - Add sysfs attributes for controlling ASPM link states (Heiner
         Kallweit)
    
       - Remove CONFIG_PCIEASPM_DEBUG, including "link_state" and "clk_ctl"
         sysfs files (Heiner Kallweit)
    
       - Avoid AMD FCH XHCI USB PME# from D0 defect that prevents wakeup on
         USB 2.0 or 1.1 connect events (Kai-Heng Feng)
    
       - Move power state check out of pci_msi_supported() (Bjorn Helgaas)
    
       - Fix incorrect MSI-X masking on resume and revert related nvme quirk
         for Kingston NVME SSD running FW E8FK11.T (Jian-Hong Pan)
    
       - Always return devices to D0 when thawing to fix hibernation with
         drivers like mlx4 that used legacy power management (previously we
         only did it for drivers with new power management ops) (Dexuan Cui)
    
       - Clear PCIe PME Status even for legacy power management (Bjorn
         Helgaas)
    
       - Fix PCI PM documentation errors (Bjorn Helgaas)
    
       - Use dev_printk() for more power management messages (Bjorn Helgaas)
    
       - Apply D2 delay as milliseconds, not microseconds (Bjorn Helgaas)
    
       - Convert xen-platform from legacy to generic power management (Bjorn
         Helgaas)
    
       - Removed unused .resume_early() and .suspend_late() legacy power
         management hooks (Bjorn Helgaas)
    
       - Rearrange power management code for clarity (Rafael J. Wysocki)
    
       - Decode power states more clearly ("4" or "D4" really refers to
         "D3cold") (Bjorn Helgaas)
    
       - Notice when reading PM Control register returns an error (~0)
         instead of interpreting it as being in D3hot (Bjorn Helgaas)
    
       - Add missing link delays required by the PCIe spec (Mika Westerberg)
    
      Virtualization:
    
       - Move pci_prg_resp_pasid_required() to CONFIG_PCI_PRI (Bjorn
         Helgaas)
    
       - Allow VFs to use PRI (the PF PRI is shared by the VFs, but the code
         previously didn't recognize that) (Kuppuswamy Sathyanarayanan)
    
       - Allow VFs to use PASID (the PF PASID capability is shared by the
         VFs, but the code previously didn't recognize that) (Kuppuswamy
         Sathyanarayanan)
    
       - Disconnect PF and VF ATS enablement, since ATS in PFs and
         associated VFs can be enabled independently (Kuppuswamy
         Sathyanarayanan)
    
       - Cache PRI and PASID capability offsets (Kuppuswamy Sathyanarayanan)
    
       - Cache the PRI PRG Response PASID Required bit (Bjorn Helgaas)
    
       - Consolidate ATS declarations in linux/pci-ats.h (Krzysztof
         Wilczynski)
    
       - Remove unused PRI and PASID stubs (Bjorn Helgaas)
    
       - Removed unnecessary EXPORT_SYMBOL_GPL() from ATS, PRI, and PASID
         interfaces that are only used by built-in IOMMU drivers (Bjorn
         Helgaas)
    
       - Hide PRI and PASID state restoration functions used only inside the
         PCI core (Bjorn Helgaas)
    
       - Add a DMA alias quirk for the Intel VCA NTB (Slawomir Pawlowski)
    
       - Serialize sysfs sriov_numvfs reads vs writes (Pierre Crégut)
    
       - Update Cavium ACS quirk for ThunderX2 and ThunderX3 (George
         Cherian)
    
       - Fix the UPDCR register address in the Intel ACS quirk (Steffen
         Liebergeld)
    
       - Unify ACS quirk implementations (Bjorn Helgaas)
    
      Amlogic Meson host bridge driver:
    
       - Fix meson PERST# GPIO polarity problem (Remi Pommarel)
    
       - Add DT bindings for Amlogic Meson G12A (Neil Armstrong)
    
       - Fix meson clock names to match DT bindings (Neil Armstrong)
    
       - Add meson support for Amlogic G12A SoC with separate shared PHY
         (Neil Armstrong)
    
       - Add meson extended PCIe PHY functions for Amlogic G12A USB3+PCIe
         combo PHY (Neil Armstrong)
    
       - Add arm64 DT for Amlogic G12A PCIe controller node (Neil Armstrong)
    
       - Add commented-out description of VIM3 USB3/PCIe mux in arm64 DT
         (Neil Armstrong)
    
      Broadcom iProc host bridge driver:
    
       - Invalidate iProc PAXB address mapping before programming it
         (Abhishek Shah)
    
       - Fix iproc-msi and mvebu __iomem annotations (Ben Dooks)
    
      Cadence host bridge driver:
    
       - Refactor Cadence PCIe host controller to use as a library for both
         host and endpoint (Tom Joseph)
    
      Freescale Layerscape host bridge driver:
    
       - Add layerscape LS1028a support (Xiaowei Bao)
    
      Intel VMD host bridge driver:
    
       - Add VMD bus 224-255 restriction decode (Jon Derrick)
    
       - Add VMD 8086:9A0B device ID (Jon Derrick)
    
       - Remove Keith from VMD maintainer list (Keith Busch)
    
      Marvell ARMADA 3700 / Aardvark host bridge driver:
    
       - Use LTSSM state to build link training flag since Aardvark doesn't
         implement the Link Training bit (Remi Pommarel)
    
       - Delay before training Aardvark link in case PERST# was asserted
         before the driver probe (Remi Pommarel)
    
       - Fix Aardvark issues with Root Control reads and writes (Remi
         Pommarel)
    
       - Don't rely on jiffies in Aardvark config access path since
         interrupts may be disabled (Remi Pommarel)
    
       - Fix Aardvark big-endian support (Grzegorz Jaszczyk)
    
      Marvell ARMADA 370 / XP host bridge driver:
    
       - Make mvebu_pci_bridge_emul_ops static (Ben Dooks)
    
      Microsoft Hyper-V host bridge driver:
    
       - Add hibernation support for Hyper-V virtual PCI devices (Dexuan
         Cui)
    
       - Track Hyper-V pci_protocol_version per-hbus, not globally (Dexuan
         Cui)
    
       - Avoid kmemleak false positive on hv hbus buffer (Dexuan Cui)
    
      Mobiveil host bridge driver:
    
       - Change mobiveil csr_read()/write() function names that conflict
         with riscv arch functions (Kefeng Wang)
    
      NVIDIA Tegra host bridge driver:
    
       - Fix Tegra CLKREQ dependency programming (Vidya Sagar)
    
      Renesas R-Car host bridge driver:
    
       - Remove unnecessary header include from rcar (Andrew Murray)
    
       - Tighten register index checking for rcar inbound range programming
         (Marek Vasut)
    
       - Fix rcar inbound range alignment calculation to improve packing of
         multiple entries (Marek Vasut)
    
       - Update rcar MACCTLR setting to match documentation (Yoshihiro
         Shimoda)
    
       - Clear bit 0 of MACCTLR before PCIETCTLR.CFINIT per manual
         (Yoshihiro Shimoda)
    
       - Add Marek Vasut and Yoshihiro Shimoda as R-Car maintainers (Simon
         Horman)
    
      Rockchip host bridge driver:
    
       - Make rockchip 0V9 and 1V8 power regulators non-optional (Robin
         Murphy)
    
      Socionext UniPhier host bridge driver:
    
       - Set uniphier to host (RC) mode always (Kunihiko Hayashi)
    
      Endpoint drivers:
    
       - Fix endpoint driver sign extension problem when shifting page
         number to phys_addr_t (Alan Mikhak)
    
      Misc:
    
       - Add NumaChip SPDX header (Krzysztof Wilczynski)
    
       - Replace EXTRA_CFLAGS with ccflags-y (Krzysztof Wilczynski)
    
       - Remove unused includes (Krzysztof Wilczynski)
    
       - Removed unused sysfs attribute groups (Ben Dooks)
    
       - Remove PTM and ASPM dependencies on PCIEPORTBUS (Bjorn Helgaas)
    
       - Add PCIe Link Control 2 register field definitions to replace magic
         numbers in AMDGPU and Radeon CIK/SI (Bjorn Helgaas)
    
       - Fix incorrect Link Control 2 Transmit Margin usage in AMDGPU and
         Radeon CIK/SI PCIe Gen3 link training (Bjorn Helgaas)
    
       - Use pcie_capability_read_word() instead of pci_read_config_word()
         in AMDGPU and Radeon CIK/SI (Frederick Lawler)
    
       - Remove unused pci_irq_get_node() Greg Kroah-Hartman)
    
       - Make asm/msi.h mandatory and simplify PCI_MSI_IRQ_DOMAIN Kconfig
         (Palmer Dabbelt, Michal Simek)
    
       - Read all 64 bits of Switchtec part_event_bitmap (Logan Gunthorpe)
    
       - Fix erroneous intel-iommu dependency on CONFIG_AMD_IOMMU (Bjorn
         Helgaas)
    
       - Fix bridge emulation big-endian support (Grzegorz Jaszczyk)
    
       - Fix dwc find_next_bit() usage (Niklas Cassel)
    
       - Fix pcitest.c fd leak (Hewenliang)
    
       - Fix typos and comments (Bjorn Helgaas)
    
       - Fix Kconfig whitespace errors (Krzysztof Kozlowski)"
    
    * tag 'pci-v5.5-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (160 commits)
      PCI: Remove PCI_MSI_IRQ_DOMAIN architecture whitelist
      asm-generic: Make msi.h a mandatory include/asm header
      Revert "nvme: Add quirk for Kingston NVME SSD running FW E8FK11.T"
      PCI/MSI: Fix incorrect MSI-X masking on resume
      PCI/MSI: Move power state check out of pci_msi_supported()
      PCI/MSI: Remove unused pci_irq_get_node()
      PCI: hv: Avoid a kmemleak false positive caused by the hbus buffer
      PCI: hv: Change pci_protocol_version to per-hbus
      PCI: hv: Add hibernation support
      PCI: hv: Reorganize the code in preparation of hibernation
      MAINTAINERS: Remove Keith from VMD maintainer
      PCI/ASPM: Remove PCIEASPM_DEBUG Kconfig option and related code
      PCI/ASPM: Add sysfs attributes for controlling ASPM link states
      PCI: Fix indentation
      drm/radeon: Prefer pcie_capability_read_word()
      drm/radeon: Replace numbers with PCI_EXP_LNKCTL2 definitions
      drm/radeon: Correct Transmit Margin masks
      drm/amdgpu: Prefer pcie_capability_read_word()
      PCI: uniphier: Set mode register to host mode
      drm/amdgpu: Replace numbers with PCI_EXP_LNKCTL2 definitions
      ...

commit 774800cb099f8ee2f0f5c55ddb1809802d7c7cf8
Merge: 7cfe16393c3c 73884a7082f4
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Nov 28 08:54:36 2019 -0600

    Merge branch 'pci/resource'
    
      - Protect pci_reassign_bridge_resources() against concurrent
        addition/removal (Benjamin Herrenschmidt)
    
      - Fix bridge dma_ranges resource list cleanup (Rob Herring)
    
      - Add PCI_STD_NUM_BARS for the number of standard BARs (Denis Efremov)
    
      - Add "pci=hpmmiosize" and "pci=hpmmioprefsize" parameters to control the
        MMIO and prefetchable MMIO window sizes of hotplug bridges
        independently (Nicholas Johnson)
    
      - Fix MMIO/MMIO_PREF window assignment that assigned more space than
        desired (Nicholas Johnson)
    
      - Only enforce bus numbers from bridge EA if the bridge has EA devices
        downstream (Subbaraya Sundeep)
    
    * pci/resource:
      PCI: Do not use bus number zero from EA capability
      PCI: Avoid double hpmemsize MMIO window assignment
      PCI: Add "pci=hpmmiosize" and "pci=hpmmioprefsize" parameters
      PCI: Add PCI_STD_NUM_BARS for the number of standard BARs
      PCI: Fix missing bridge dma_ranges resource list cleanup
      PCI: Protect pci_reassign_bridge_resources() against concurrent addition/removal

commit 7cfe16393c3c9fed45545b234b852e1154c7cc5b
Merge: c59f0da5780f bae26849372b
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Nov 28 08:54:35 2019 -0600

    Merge branch 'pci/pm'
    
      - Always return devices to D0 when thawing to fix hibernation with
        drivers like mlx4 that used legacy power management (previously we only
        did it for drivers with new power management ops) (Dexuan Cui)
    
      - Clear PCIe PME Status even for legacy power management (Bjorn Helgaas)
    
      - Fix PCI PM documentation errors (Bjorn Helgaas)
    
      - Use dev_printk() for more power management messages (Bjorn Helgaas)
    
      - Apply D2 delay as milliseconds, not microseconds (Bjorn Helgaas)
    
      - Convert xen-platform from legacy to generic power management (Bjorn
        Helgaas)
    
      - Removed unused .resume_early() and .suspend_late() legacy power
        management hooks (Bjorn Helgaas)
    
      - Rearrange power management code for clarity (Rafael J. Wysocki)
    
      - Decode power states more clearly ("4" or "D4" really refers to
        "D3cold") (Bjorn Helgaas)
    
      - Notice when reading PM Control register returns an error (~0) instead
        of interpreting it as being in D3hot (Bjorn Helgaas)
    
      - Add missing link delays required by the PCIe spec (Mika Westerberg)
    
    * pci/pm:
      PCI/PM: Move pci_dev_wait() definition earlier
      PCI/PM: Add missing link delays required by the PCIe spec
      PCI/PM: Add pcie_wait_for_link_delay()
      PCI/PM: Return error when changing power state from D3cold
      PCI/PM: Decode D3cold power state correctly
      PCI/PM: Fold __pci_complete_power_transition() into its caller
      PCI/PM: Avoid exporting __pci_complete_power_transition()
      PCI/PM: Fold __pci_start_power_transition() into its caller
      PCI/PM: Use pci_power_up() in pci_set_power_state()
      PCI/PM: Move power state update away from pci_power_up()
      PCI/PM: Remove unused pci_driver.suspend_late() hook
      PCI/PM: Remove unused pci_driver.resume_early() hook
      xen-platform: Convert to generic power management
      PCI/PM: Simplify pci_set_power_state()
      PCI/PM: Expand PM reset messages to mention D3hot (not just D3)
      PCI/PM: Apply D2 delay as milliseconds, not microseconds
      PCI/PM: Use pci_WARN() to include device information
      PCI/PM: Use PCI dev_printk() wrappers for consistency
      PCI/PM: Wrap long lines in documentation
      PCI/PM: Note that PME can be generated from D0
      PCI/PM: Make power management op coding style consistent
      PCI/PM: Run resume fixups before disabling wakeup events
      PCI/PM: Clear PCIe PME Status even for legacy power management
      PCI/PM: Correct pci_pm_thaw_noirq() documentation
      PCI/PM: Always return devices to D0 when thawing

commit e87eb585d31fadb5e9e549a1de4b2da60a79bfc9
Merge: 2df08822a643 3d581b11e34a
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Nov 28 08:54:32 2019 -0600

    Merge branch 'pci/misc'
    
      - Add NumaChip SPDX header (Krzysztof Wilczynski)
    
      - Replace EXTRA_CFLAGS with ccflags-y (Krzysztof Wilczynski)
    
      - Remove unused includes (Krzysztof Wilczynski)
    
      - Avoid AMD FCH XHCI USB PME# from D0 defect that prevents wakeup on USB
        2.0 or 1.1 connect events (Kai-Heng Feng)
    
      - Removed unused sysfs attribute groups (Ben Dooks)
    
      - Remove PTM and ASPM dependencies on PCIEPORTBUS (Bjorn Helgaas)
    
      - Add PCIe Link Control 2 register field definitions to replace magic
        numbers in AMDGPU and Radeon CIK/SI (Bjorn Helgaas)
    
      - Fix incorrect Link Control 2 Transmit Margin usage in AMDGPU and Radeon
        CIK/SI PCIe Gen3 link training (Bjorn Helgaas)
    
      - Use pcie_capability_read_word() instead of pci_read_config_word() in
        AMDGPU and Radeon CIK/SI (Frederick Lawler)
    
    * pci/misc:
      drm/radeon: Prefer pcie_capability_read_word()
      drm/radeon: Replace numbers with PCI_EXP_LNKCTL2 definitions
      drm/radeon: Correct Transmit Margin masks
      drm/amdgpu: Prefer pcie_capability_read_word()
      drm/amdgpu: Replace numbers with PCI_EXP_LNKCTL2 definitions
      drm/amdgpu: Correct Transmit Margin masks
      PCI: Add #defines for Enter Compliance, Transmit Margin
      PCI: Allow building PCIe things without PCIEPORTBUS
      PCI: Remove PCIe Kconfig dependencies on PCI
      PCI/ASPM: Remove dependency on PCIEPORTBUS
      PCI/PTM: Remove dependency on PCIEPORTBUS
      PCI/PTM: Remove spurious "d" from granularity message
      PCI: sysfs: Remove unused attribute groups
      x86/PCI: Avoid AMD FCH XHCI USB PME# from D0 defect
      PCI: Remove unused includes and superfluous struct declaration
      x86/PCI: Replace deprecated EXTRA_CFLAGS with ccflags-y
      x86/PCI: Correct SPDX comment style
      x86/PCI: Add NumaChip SPDX GPL-2.0 to replace COPYING boilerplate

commit c2a3d213d1bc007683f63790b1cf522d5586d1a8
Merge: 7d194c2100ad 35a0b2378c19
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Nov 28 08:54:28 2019 -0600

    Merge branch 'pci/aer'
    
      - Restore AER capability after resume (Mayurkumar Patel)
    
      - Add PoisonTLPBlocked AER counter (Rajat Jain)
    
      - Use for_each_set_bit() to simplify AER code (Andy Shevchenko)
    
      - Fix AER kernel-doc (Andy Shevchenko)
    
      - Add "pcie_ports=dpc-native" parameter to allow native use of DPC even
        if platform didn't grant control over AER (Olof Johansson)
    
    * pci/aer:
      PCI/DPC: Add "pcie_ports=dpc-native" to allow DPC without AER control
      PCI/AER: Fix kernel-doc warnings
      PCI/AER: Use for_each_set_bit() to simplify code
      PCI/AER: Add PoisonTLPBlocked to Uncorrectable error counters
      PCI/AER: Save AER Capability for suspend/resume

commit 09578eacaaa44149738267083ccc050990409f86
Merge: c6b6fc206586 8c4d2a0bfbd2
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Nov 25 14:27:33 2019 +0100

    Merge tag 'asoc-v5.5-2' of https://git.kernel.org/pub/scm/linux/kernel/git/broonie/sound into for-linus
    
    ASoC: More updates for v5.5
    
    Some more development work for v5.5.  Highlights include:
    
     - More cleanups from Morimoto-san.
     - Trigger word detection for RT5677.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

commit bbd8810d399812f2016713565e4d8ff8f1508aa6
Author: Krzysztof Wilczynski <kw@linux.com>
Date:   Tue Sep 3 13:30:59 2019 +0200

    PCI: Remove unused includes and superfluous struct declaration
    
    Remove <linux/pci.h> and <linux/msi.h> from being included directly as part
    of the include/linux/of_pci.h, and remove superfluous declaration of struct
    of_phandle_args.
    
    Move users of include <linux/of_pci.h> to include <linux/pci.h> and
    <linux/msi.h> directly rather than rely on both being included transitively
    through <linux/of_pci.h>.
    
    Link: https://lore.kernel.org/r/20190903113059.2901-1-kw@linux.com
    Signed-off-by: Krzysztof Wilczynski <kw@linux.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index e7982af9a5d8..2d36995e4ea5 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -13,6 +13,7 @@
 #include <linux/delay.h>
 #include <linux/dmi.h>
 #include <linux/init.h>
+#include <linux/msi.h>
 #include <linux/of.h>
 #include <linux/of_pci.h>
 #include <linux/pci.h>

commit bae26849372b83c65da73d19ff58e987d70e6600
Author: Vidya Sagar <vidyas@nvidia.com>
Date:   Wed Nov 20 10:47:42 2019 +0530

    PCI/PM: Move pci_dev_wait() definition earlier
    
    Move the definition of pci_dev_wait() above pci_power_up() so that it can
    be called from the latter with no change in functionality.  This is a pure
    code move with no functional change.
    
    Link: https://lore.kernel.org/r/20191120051743.23124-1-vidyas@nvidia.com
    Signed-off-by: Vidya Sagar <vidyas@nvidia.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index b9d91370856a..d6b44ae8baa4 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1012,6 +1012,47 @@ void pci_wakeup_bus(struct pci_bus *bus)
 		pci_walk_bus(bus, pci_wakeup, NULL);
 }
 
+static int pci_dev_wait(struct pci_dev *dev, char *reset_type, int timeout)
+{
+	int delay = 1;
+	u32 id;
+
+	/*
+	 * After reset, the device should not silently discard config
+	 * requests, but it may still indicate that it needs more time by
+	 * responding to them with CRS completions.  The Root Port will
+	 * generally synthesize ~0 data to complete the read (except when
+	 * CRS SV is enabled and the read was for the Vendor ID; in that
+	 * case it synthesizes 0x0001 data).
+	 *
+	 * Wait for the device to return a non-CRS completion.  Read the
+	 * Command register instead of Vendor ID so we don't have to
+	 * contend with the CRS SV value.
+	 */
+	pci_read_config_dword(dev, PCI_COMMAND, &id);
+	while (id == ~0) {
+		if (delay > timeout) {
+			pci_warn(dev, "not ready %dms after %s; giving up\n",
+				 delay - 1, reset_type);
+			return -ENOTTY;
+		}
+
+		if (delay > 1000)
+			pci_info(dev, "not ready %dms after %s; waiting\n",
+				 delay - 1, reset_type);
+
+		msleep(delay);
+		delay *= 2;
+		pci_read_config_dword(dev, PCI_COMMAND, &id);
+	}
+
+	if (delay > 1000)
+		pci_info(dev, "ready %dms after %s\n", delay - 1,
+			 reset_type);
+
+	return 0;
+}
+
 /**
  * pci_power_up - Put the given device into D0
  * @dev: PCI device to power up
@@ -4406,47 +4447,6 @@ int pci_wait_for_pending_transaction(struct pci_dev *dev)
 }
 EXPORT_SYMBOL(pci_wait_for_pending_transaction);
 
-static int pci_dev_wait(struct pci_dev *dev, char *reset_type, int timeout)
-{
-	int delay = 1;
-	u32 id;
-
-	/*
-	 * After reset, the device should not silently discard config
-	 * requests, but it may still indicate that it needs more time by
-	 * responding to them with CRS completions.  The Root Port will
-	 * generally synthesize ~0 data to complete the read (except when
-	 * CRS SV is enabled and the read was for the Vendor ID; in that
-	 * case it synthesizes 0x0001 data).
-	 *
-	 * Wait for the device to return a non-CRS completion.  Read the
-	 * Command register instead of Vendor ID so we don't have to
-	 * contend with the CRS SV value.
-	 */
-	pci_read_config_dword(dev, PCI_COMMAND, &id);
-	while (id == ~0) {
-		if (delay > timeout) {
-			pci_warn(dev, "not ready %dms after %s; giving up\n",
-				 delay - 1, reset_type);
-			return -ENOTTY;
-		}
-
-		if (delay > 1000)
-			pci_info(dev, "not ready %dms after %s; waiting\n",
-				 delay - 1, reset_type);
-
-		msleep(delay);
-		delay *= 2;
-		pci_read_config_dword(dev, PCI_COMMAND, &id);
-	}
-
-	if (delay > 1000)
-		pci_info(dev, "ready %dms after %s\n", delay - 1,
-			 reset_type);
-
-	return 0;
-}
-
 /**
  * pcie_has_flr - check if a device supports function level resets
  * @dev: device to check

commit ad9001f2f41198784b0423646450ba2cb24793a3
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Tue Nov 12 12:16:17 2019 +0300

    PCI/PM: Add missing link delays required by the PCIe spec
    
    Currently Linux does not follow PCIe spec regarding the required delays
    after reset. A concrete example is a Thunderbolt add-in-card that consists
    of a PCIe switch and two PCIe endpoints:
    
      +-1b.0-[01-6b]----00.0-[02-6b]--+-00.0-[03]----00.0 TBT controller
                                      +-01.0-[04-36]-- DS hotplug port
                                      +-02.0-[37]----00.0 xHCI controller
                                      \-04.0-[38-6b]-- DS hotplug port
    
    The root port (1b.0) and the PCIe switch downstream ports are all PCIe Gen3
    so they support 8GT/s link speeds.
    
    We wait for the PCIe hierarchy to enter D3cold (runtime):
    
      pcieport 0000:00:1b.0: power state changed by ACPI to D3cold
    
    When it wakes up from D3cold, according to the PCIe 5.0 section 5.8 the
    PCIe switch is put to reset and its power is re-applied. This means that we
    must follow the rules in PCIe 5.0 section 6.6.1.
    
    For the PCIe Gen3 ports we are dealing with here, the following applies:
    
      With a Downstream Port that supports Link speeds greater than 5.0 GT/s,
      software must wait a minimum of 100 ms after Link training completes
      before sending a Configuration Request to the device immediately below
      that Port. Software can determine when Link training completes by polling
      the Data Link Layer Link Active bit or by setting up an associated
      interrupt (see Section 6.7.3.3).
    
    Translating this into the above topology we would need to do this (DLLLA
    stands for Data Link Layer Link Active):
    
      0000:00:1b.0: wait for 100 ms after DLLLA is set before access to 0000:01:00.0
      0000:02:00.0: wait for 100 ms after DLLLA is set before access to 0000:03:00.0
      0000:02:02.0: wait for 100 ms after DLLLA is set before access to 0000:37:00.0
    
    I've instrumented the kernel with some additional logging so we can see the
    actual delays performed:
    
      pcieport 0000:00:1b.0: power state changed by ACPI to D0
      pcieport 0000:00:1b.0: waiting for D3cold delay of 100 ms
      pcieport 0000:00:1b.0: waiting for D3hot delay of 10 ms
      pcieport 0000:02:01.0: waiting for D3hot delay of 10 ms
      pcieport 0000:02:04.0: waiting for D3hot delay of 10 ms
    
    For the switch upstream port (01:00.0 reachable through 00:1b.0 root port)
    we wait for 100 ms but not taking into account the DLLLA requirement. We
    then wait 10 ms for D3hot -> D0 transition of the root port and the two
    downstream hotplug ports. This means that we deviate from what the spec
    requires.
    
    Performing the same check for system sleep (s2idle) transitions it turns
    out to be even worse. None of the mandatory delays are performed. If this
    would be S3 instead of s2idle then according to PCI FW spec 3.2 section
    4.6.8. there is a specific _DSM that allows the OS to skip the delays but
    this platform does not provide the _DSM and does not go to S3 anyway so no
    firmware is involved that could already handle these delays.
    
    On this particular platform these delays are not actually needed because
    there is an additional delay as part of the ACPI power resource that is
    used to turn on power to the hierarchy but since that additional delay is
    not required by any of standards (PCIe, ACPI) it is not present in the
    Intel Ice Lake, for example where missing the mandatory delays causes
    pciehp to start tearing down the stack too early (links are not yet
    trained). Below is an example how it looks like when this happens:
    
      pcieport 0000:83:04.0: pciehp: Slot(4): Card not present
      pcieport 0000:87:04.0: PME# disabled
      pcieport 0000:83:04.0: pciehp: pciehp_unconfigure_device: domain:bus:dev = 0000:86:00
      pcieport 0000:86:00.0: Refused to change power state, currently in D3
      pcieport 0000:86:00.0: restoring config space at offset 0x3c (was 0xffffffff, writing 0x201ff)
      pcieport 0000:86:00.0: restoring config space at offset 0x38 (was 0xffffffff, writing 0x0)
      ...
    
    There is also one reported case (see the bugzilla link below) where the
    missing delay causes xHCI on a Titan Ridge controller fail to runtime
    resume when USB-C dock is plugged. This does not involve pciehp but instead
    the PCI core fails to runtime resume the xHCI device:
    
      pcieport 0000:04:02.0: restoring config space at offset 0xc (was 0x10000, writing 0x10020)
      pcieport 0000:04:02.0: restoring config space at offset 0x4 (was 0x100000, writing 0x100406)
      xhci_hcd 0000:39:00.0: Refused to change power state, currently in D3
      xhci_hcd 0000:39:00.0: restoring config space at offset 0x3c (was 0xffffffff, writing 0x1ff)
      xhci_hcd 0000:39:00.0: restoring config space at offset 0x38 (was 0xffffffff, writing 0x0)
      ...
    
    Add a new function pci_bridge_wait_for_secondary_bus() that is called on
    PCI core resume and runtime resume paths accordingly if the bridge entered
    D3cold (and thus went through reset).
    
    This is second attempt to add the missing delays. The previous solution in
    c2bf1fc212f7 ("PCI: Add missing link delays required by the PCIe spec") was
    reverted because of two issues it caused:
    
      1. One system become unresponsive after S3 resume due to PME service
         spinning in pcie_pme_work_fn(). The root port in question reports that
         the xHCI sent PME but the xHCI device itself does not have PME status
         set. The PME status bit is never cleared in the root port resulting
         the indefinite loop in pcie_pme_work_fn().
    
      2. Slows down resume if the root/downstream port does not support Data
         Link Layer Active Reporting because pcie_wait_for_link_delay() waits
         1100 ms in that case.
    
    This version should avoid the above issues because we restrict the delay to
    happen only if the port went into D3cold.
    
    Link: https://lore.kernel.org/linux-pci/SL2P216MB01878BBCD75F21D882AEEA2880C60@SL2P216MB0187.KORP216.PROD.OUTLOOK.COM/
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=203885
    Link: https://lore.kernel.org/r/20191112091617.70282-3-mika.westerberg@linux.intel.com
    Reported-by: Kai-Heng Feng <kai.heng.feng@canonical.com>
    Tested-by: Kai-Heng Feng <kai.heng.feng@canonical.com>
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 11e4b495cfac..b9d91370856a 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1021,14 +1021,11 @@ int pci_power_up(struct pci_dev *dev)
 	pci_platform_power_transition(dev, PCI_D0);
 
 	/*
-	 * Mandatory power management transition delays, see PCI Express Base
-	 * Specification Revision 2.0 Section 6.6.1: Conventional Reset.  Do not
-	 * delay for devices powered on/off by corresponding bridge, because
-	 * have already delayed for the bridge.
+	 * Mandatory power management transition delays are handled in
+	 * pci_pm_resume_noirq() and pci_pm_runtime_resume() of the
+	 * corresponding bridge.
 	 */
 	if (dev->runtime_d3cold) {
-		if (dev->d3cold_delay && !dev->imm_ready)
-			msleep(dev->d3cold_delay);
 		/*
 		 * When powering on a bridge from D3cold, the whole hierarchy
 		 * may be powered on into D0uninitialized state, resume them to
@@ -4652,6 +4649,125 @@ bool pcie_wait_for_link(struct pci_dev *pdev, bool active)
 	return pcie_wait_for_link_delay(pdev, active, 100);
 }
 
+/*
+ * Find maximum D3cold delay required by all the devices on the bus.  The
+ * spec says 100 ms, but firmware can lower it and we allow drivers to
+ * increase it as well.
+ *
+ * Called with @pci_bus_sem locked for reading.
+ */
+static int pci_bus_max_d3cold_delay(const struct pci_bus *bus)
+{
+	const struct pci_dev *pdev;
+	int min_delay = 100;
+	int max_delay = 0;
+
+	list_for_each_entry(pdev, &bus->devices, bus_list) {
+		if (pdev->d3cold_delay < min_delay)
+			min_delay = pdev->d3cold_delay;
+		if (pdev->d3cold_delay > max_delay)
+			max_delay = pdev->d3cold_delay;
+	}
+
+	return max(min_delay, max_delay);
+}
+
+/**
+ * pci_bridge_wait_for_secondary_bus - Wait for secondary bus to be accessible
+ * @dev: PCI bridge
+ *
+ * Handle necessary delays before access to the devices on the secondary
+ * side of the bridge are permitted after D3cold to D0 transition.
+ *
+ * For PCIe this means the delays in PCIe 5.0 section 6.6.1. For
+ * conventional PCI it means Tpvrh + Trhfa specified in PCI 3.0 section
+ * 4.3.2.
+ */
+void pci_bridge_wait_for_secondary_bus(struct pci_dev *dev)
+{
+	struct pci_dev *child;
+	int delay;
+
+	if (pci_dev_is_disconnected(dev))
+		return;
+
+	if (!pci_is_bridge(dev) || !dev->bridge_d3)
+		return;
+
+	down_read(&pci_bus_sem);
+
+	/*
+	 * We only deal with devices that are present currently on the bus.
+	 * For any hot-added devices the access delay is handled in pciehp
+	 * board_added(). In case of ACPI hotplug the firmware is expected
+	 * to configure the devices before OS is notified.
+	 */
+	if (!dev->subordinate || list_empty(&dev->subordinate->devices)) {
+		up_read(&pci_bus_sem);
+		return;
+	}
+
+	/* Take d3cold_delay requirements into account */
+	delay = pci_bus_max_d3cold_delay(dev->subordinate);
+	if (!delay) {
+		up_read(&pci_bus_sem);
+		return;
+	}
+
+	child = list_first_entry(&dev->subordinate->devices, struct pci_dev,
+				 bus_list);
+	up_read(&pci_bus_sem);
+
+	/*
+	 * Conventional PCI and PCI-X we need to wait Tpvrh + Trhfa before
+	 * accessing the device after reset (that is 1000 ms + 100 ms). In
+	 * practice this should not be needed because we don't do power
+	 * management for them (see pci_bridge_d3_possible()).
+	 */
+	if (!pci_is_pcie(dev)) {
+		pci_dbg(dev, "waiting %d ms for secondary bus\n", 1000 + delay);
+		msleep(1000 + delay);
+		return;
+	}
+
+	/*
+	 * For PCIe downstream and root ports that do not support speeds
+	 * greater than 5 GT/s need to wait minimum 100 ms. For higher
+	 * speeds (gen3) we need to wait first for the data link layer to
+	 * become active.
+	 *
+	 * However, 100 ms is the minimum and the PCIe spec says the
+	 * software must allow at least 1s before it can determine that the
+	 * device that did not respond is a broken device. There is
+	 * evidence that 100 ms is not always enough, for example certain
+	 * Titan Ridge xHCI controller does not always respond to
+	 * configuration requests if we only wait for 100 ms (see
+	 * https://bugzilla.kernel.org/show_bug.cgi?id=203885).
+	 *
+	 * Therefore we wait for 100 ms and check for the device presence.
+	 * If it is still not present give it an additional 100 ms.
+	 */
+	if (!pcie_downstream_port(dev))
+		return;
+
+	if (pcie_get_speed_cap(dev) <= PCIE_SPEED_5_0GT) {
+		pci_dbg(dev, "waiting %d ms for downstream link\n", delay);
+		msleep(delay);
+	} else {
+		pci_dbg(dev, "waiting %d ms for downstream link, after activation\n",
+			delay);
+		if (!pcie_wait_for_link_delay(dev, true, delay)) {
+			/* Did not train, no need to wait any further */
+			return;
+		}
+	}
+
+	if (!pci_device_is_present(child)) {
+		pci_dbg(child, "waiting additional %d ms to become accessible\n", delay);
+		msleep(delay);
+	}
+}
+
 void pci_reset_secondary_bus(struct pci_dev *dev)
 {
 	u16 ctrl;

commit 4827d63891b6a839dac49c6ab62e61c4b011c4f2
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Tue Nov 12 12:16:16 2019 +0300

    PCI/PM: Add pcie_wait_for_link_delay()
    
    Add pcie_wait_for_link_delay().  Similar to pcie_wait_for_link() but allows
    passing custom activation delay in milliseconds.
    
    Link: https://lore.kernel.org/r/20191112091617.70282-2-mika.westerberg@linux.intel.com
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index d6ff1a98bd8d..11e4b495cfac 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -4586,14 +4586,17 @@ static int pci_pm_reset(struct pci_dev *dev, int probe)
 
 	return pci_dev_wait(dev, "PM D3hot->D0", PCIE_RESET_READY_POLL_MS);
 }
+
 /**
- * pcie_wait_for_link - Wait until link is active or inactive
+ * pcie_wait_for_link_delay - Wait until link is active or inactive
  * @pdev: Bridge device
  * @active: waiting for active or inactive?
+ * @delay: Delay to wait after link has become active (in ms)
  *
  * Use this to wait till link becomes active or inactive.
  */
-bool pcie_wait_for_link(struct pci_dev *pdev, bool active)
+static bool pcie_wait_for_link_delay(struct pci_dev *pdev, bool active,
+				     int delay)
 {
 	int timeout = 1000;
 	bool ret;
@@ -4630,13 +4633,25 @@ bool pcie_wait_for_link(struct pci_dev *pdev, bool active)
 		timeout -= 10;
 	}
 	if (active && ret)
-		msleep(100);
+		msleep(delay);
 	else if (ret != active)
 		pci_info(pdev, "Data Link Layer Link Active not %s in 1000 msec\n",
 			active ? "set" : "cleared");
 	return ret == active;
 }
 
+/**
+ * pcie_wait_for_link - Wait until link is active or inactive
+ * @pdev: Bridge device
+ * @active: waiting for active or inactive?
+ *
+ * Use this to wait till link becomes active or inactive.
+ */
+bool pcie_wait_for_link(struct pci_dev *pdev, bool active)
+{
+	return pcie_wait_for_link_delay(pdev, active, 100);
+}
+
 void pci_reset_secondary_bus(struct pci_dev *dev)
 {
 	u16 ctrl;

commit 327ccbbcc1497bff6d6f543c1f37c43a1653671f
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Aug 1 11:50:56 2019 -0500

    PCI/PM: Return error when changing power state from D3cold
    
    pci_raw_set_power_state() uses the Power Management capability to change a
    device's power state.  The capability is in config space, which is
    accessible in D0, D1, D2, and D3hot, but not in D3cold.
    
    If we call pci_raw_set_power_state() on a device that's in D3cold, config
    reads fail and return ~0 data, which we erroneously interpreted as "the
    device is in D3hot", leading to messages like this:
    
      pcieport 0000:03:00.0: Refused to change power state, currently in D3
    
    The PCI_PM_CTRL has several RsvdP fields, so ~0 is never a valid register
    value.  If we get that value, print a more informative message and return
    an error.
    
    Changing the power state of a device from D3cold must be done by a platform
    power management method or some other non-config space mechanism.
    
    Link: https://lore.kernel.org/r/20190822200551.129039-4-helgaas@kernel.org
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Keith Busch <kbusch@kernel.org>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 3376c663035d..d6ff1a98bd8d 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -853,6 +853,12 @@ static int pci_raw_set_power_state(struct pci_dev *dev, pci_power_t state)
 		return -EIO;
 
 	pci_read_config_word(dev, dev->pm_cap + PCI_PM_CTRL, &pmcsr);
+	if (pmcsr == (u16) ~0) {
+		pci_err(dev, "can't change power state from %s to %s (config space inaccessible)\n",
+			pci_power_name(dev->current_state),
+			pci_power_name(state));
+		return -EIO;
+	}
 
 	/*
 	 * If we're (effectively) in D3, force entire word to 0.

commit e43f15ea2f6d6858675fa1baa5cb624f17269af0
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Aug 2 18:47:22 2019 -0500

    PCI/PM: Decode D3cold power state correctly
    
    Use pci_power_name() to print pci_power_t correctly.  This changes:
    
      "state 0" or "D0"   to   "D0"
      "state 1" or "D1"   to   "D1"
      "state 2" or "D2"   to   "D2"
      "state 3" or "D3"   to   "D3hot"
      "state 4" or "D4"   to   "D3cold"
    
    Changes dmesg logging only, no other functional change intended.
    
    Link: https://lore.kernel.org/r/20190822200551.129039-3-helgaas@kernel.org
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Keith Busch <kbusch@kernel.org>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 37fca1e51d16..3376c663035d 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -834,14 +834,16 @@ static int pci_raw_set_power_state(struct pci_dev *dev, pci_power_t state)
 		return -EINVAL;
 
 	/*
-	 * Validate current state:
-	 * Can enter D0 from any state, but if we can only go deeper
-	 * to sleep if we're already in a low power state
+	 * Validate transition: We can enter D0 from any state, but if
+	 * we're already in a low-power state, we can only go deeper.  E.g.,
+	 * we can go from D1 to D3, but we can't go directly from D3 to D1;
+	 * we'd have to go from D3 to D0, then to D1.
 	 */
 	if (state != PCI_D0 && dev->current_state <= PCI_D3cold
 	    && dev->current_state > state) {
-		pci_err(dev, "invalid power transition (from state %d to %d)\n",
-			dev->current_state, state);
+		pci_err(dev, "invalid power transition (from %s to %s)\n",
+			pci_power_name(dev->current_state),
+			pci_power_name(state));
 		return -EINVAL;
 	}
 
@@ -891,8 +893,9 @@ static int pci_raw_set_power_state(struct pci_dev *dev, pci_power_t state)
 	pci_read_config_word(dev, dev->pm_cap + PCI_PM_CTRL, &pmcsr);
 	dev->current_state = (pmcsr & PCI_PM_CTRL_STATE_MASK);
 	if (dev->current_state != state)
-		pci_info_ratelimited(dev, "Refused to change power state, currently in D%d\n",
-			 dev->current_state);
+		pci_info_ratelimited(dev, "refused to change power state from %s to %s\n",
+			 pci_power_name(dev->current_state),
+			 pci_power_name(state));
 
 	/*
 	 * According to section 5.4.1 of the "PCI BUS POWER MANAGEMENT

commit 9c77e63bd8dcbb3b59294e9176c00c5fcab3c9c6
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Nov 5 17:32:08 2019 +0100

    PCI/PM: Fold __pci_complete_power_transition() into its caller
    
    Because pci_set_power_state() has become the only caller of
    __pci_complete_power_transition(), there is no need for the latter to
    be a separate function any more, so fold it into the former, drop a
    redundant check and reduce the number of lines of code somewhat.
    
    Code rearrangement, no intentional functional impact.
    
    Link: https://lore.kernel.org/r/15576968.k611qn3UU0@kreacher
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 2f53234f9e91..37fca1e51d16 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1055,26 +1055,6 @@ void pci_bus_set_current_state(struct pci_bus *bus, pci_power_t state)
 		pci_walk_bus(bus, __pci_dev_set_current_state, &state);
 }
 
-/**
- * __pci_complete_power_transition - Complete power transition of a PCI device
- * @dev: PCI device to handle.
- * @state: State to put the device into.
- *
- * This function should not be called directly by device drivers.
- */
-static int __pci_complete_power_transition(struct pci_dev *dev, pci_power_t state)
-{
-	int ret;
-
-	if (state <= PCI_D0)
-		return -EINVAL;
-	ret = pci_platform_power_transition(dev, state);
-	/* Power off the bridge may power off the whole hierarchy */
-	if (!ret && state == PCI_D3cold)
-		pci_bus_set_current_state(dev->subordinate, PCI_D3cold);
-	return ret;
-}
-
 /**
  * pci_set_power_state - Set the power state of a PCI device
  * @dev: PCI device to handle.
@@ -1132,10 +1112,14 @@ int pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 	error = pci_raw_set_power_state(dev, state > PCI_D3hot ?
 					PCI_D3hot : state);
 
-	if (!__pci_complete_power_transition(dev, state))
-		error = 0;
+	if (pci_platform_power_transition(dev, state))
+		return error;
 
-	return error;
+	/* Powering off a bridge may power off the whole hierarchy */
+	if (state == PCI_D3cold)
+		pci_bus_set_current_state(dev->subordinate, PCI_D3cold);
+
+	return 0;
 }
 EXPORT_SYMBOL(pci_set_power_state);
 

commit d6aa37cd04fdafaf31ae89691e537535df43ca78
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Nov 5 11:30:36 2019 +0100

    PCI/PM: Avoid exporting __pci_complete_power_transition()
    
    Notice that radeon_set_suspend(), which is the only caller of
    __pci_complete_power_transition() outside of pci.c, really only
    cares about the pci_platform_power_transition() invoked by it,
    so export the latter instead of it, update the radeon driver to
    call pci_platform_power_transition() directly and make
    __pci_complete_power_transition() static.
    
    Code rearrangement, no intentional functional impact.
    
    Link: https://lore.kernel.org/r/1731661.ykamz2Tiuf@kreacher
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 56bc79e33286..2f53234f9e91 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -963,7 +963,7 @@ void pci_refresh_power_state(struct pci_dev *dev)
  * @dev: PCI device to handle.
  * @state: State to put the device into.
  */
-static int pci_platform_power_transition(struct pci_dev *dev, pci_power_t state)
+int pci_platform_power_transition(struct pci_dev *dev, pci_power_t state)
 {
 	int error;
 
@@ -979,6 +979,7 @@ static int pci_platform_power_transition(struct pci_dev *dev, pci_power_t state)
 
 	return error;
 }
+EXPORT_SYMBOL_GPL(pci_platform_power_transition);
 
 /**
  * pci_wakeup - Wake up a PCI device
@@ -1061,7 +1062,7 @@ void pci_bus_set_current_state(struct pci_bus *bus, pci_power_t state)
  *
  * This function should not be called directly by device drivers.
  */
-int __pci_complete_power_transition(struct pci_dev *dev, pci_power_t state)
+static int __pci_complete_power_transition(struct pci_dev *dev, pci_power_t state)
 {
 	int ret;
 
@@ -1073,7 +1074,6 @@ int __pci_complete_power_transition(struct pci_dev *dev, pci_power_t state)
 		pci_bus_set_current_state(dev->subordinate, PCI_D3cold);
 	return ret;
 }
-EXPORT_SYMBOL_GPL(__pci_complete_power_transition);
 
 /**
  * pci_set_power_state - Set the power state of a PCI device

commit dc2256b0735d03664a92a6cb94ea4e564dfa237b
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Nov 5 11:29:16 2019 +0100

    PCI/PM: Fold __pci_start_power_transition() into its caller
    
    Because pci_power_up() has become the only caller of
    __pci_start_power_transition(), there is no need for the latter to
    be a separate function any more, so fold it into the former, drop a
    redundant check and reduce the number of lines of code somewhat.
    
    Code rearrangement, no intentional functional impact.
    
    Link: https://lore.kernel.org/r/3458080.lsoDbfkST9@kreacher
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 9f0977d0ac5a..56bc79e33286 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1003,42 +1003,30 @@ void pci_wakeup_bus(struct pci_bus *bus)
 }
 
 /**
- * __pci_start_power_transition - Start power transition of a PCI device
- * @dev: PCI device to handle.
- * @state: State to put the device into.
+ * pci_power_up - Put the given device into D0
+ * @dev: PCI device to power up
  */
-static void __pci_start_power_transition(struct pci_dev *dev, pci_power_t state)
+int pci_power_up(struct pci_dev *dev)
 {
-	if (state == PCI_D0) {
-		pci_platform_power_transition(dev, PCI_D0);
+	pci_platform_power_transition(dev, PCI_D0);
+
+	/*
+	 * Mandatory power management transition delays, see PCI Express Base
+	 * Specification Revision 2.0 Section 6.6.1: Conventional Reset.  Do not
+	 * delay for devices powered on/off by corresponding bridge, because
+	 * have already delayed for the bridge.
+	 */
+	if (dev->runtime_d3cold) {
+		if (dev->d3cold_delay && !dev->imm_ready)
+			msleep(dev->d3cold_delay);
 		/*
-		 * Mandatory power management transition delays, see
-		 * PCI Express Base Specification Revision 2.0 Section
-		 * 6.6.1: Conventional Reset.  Do not delay for
-		 * devices powered on/off by corresponding bridge,
-		 * because have already delayed for the bridge.
+		 * When powering on a bridge from D3cold, the whole hierarchy
+		 * may be powered on into D0uninitialized state, resume them to
+		 * give them a chance to suspend again
 		 */
-		if (dev->runtime_d3cold) {
-			if (dev->d3cold_delay && !dev->imm_ready)
-				msleep(dev->d3cold_delay);
-			/*
-			 * When powering on a bridge from D3cold, the
-			 * whole hierarchy may be powered on into
-			 * D0uninitialized state, resume them to give
-			 * them a chance to suspend again
-			 */
-			pci_wakeup_bus(dev->subordinate);
-		}
+		pci_wakeup_bus(dev->subordinate);
 	}
-}
 
-/**
- * pci_power_up - Put the given device into D0
- * @dev: PCI device to power up
- */
-int pci_power_up(struct pci_dev *dev)
-{
-	__pci_start_power_transition(dev, PCI_D0);
 	return pci_raw_set_power_state(dev, PCI_D0);
 }
 

commit adfac8f6b7396b408fa9a8f40ea41112bebb980f
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Nov 5 11:27:49 2019 +0100

    PCI/PM: Use pci_power_up() in pci_set_power_state()
    
    Make it explicitly clear that the code to put devices into D0 in
    pci_set_power_state() and in pci_pm_default_resume_early() is the
    same by making the latter use pci_power_up() for transitions into D0.
    
    Code rearrangement, no intentional functional impact.
    
    Link: https://lore.kernel.org/r/2520019.OZ1nXS5aSj@kreacher
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 11b4d9274d96..9f0977d0ac5a 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1032,6 +1032,16 @@ static void __pci_start_power_transition(struct pci_dev *dev, pci_power_t state)
 	}
 }
 
+/**
+ * pci_power_up - Put the given device into D0
+ * @dev: PCI device to power up
+ */
+int pci_power_up(struct pci_dev *dev)
+{
+	__pci_start_power_transition(dev, PCI_D0);
+	return pci_raw_set_power_state(dev, PCI_D0);
+}
+
 /**
  * __pci_dev_set_current_state - Set current state of a PCI device
  * @dev: Device to handle
@@ -1117,6 +1127,9 @@ int pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 	if (dev->current_state == state)
 		return 0;
 
+	if (state == PCI_D0)
+		return pci_power_up(dev);
+
 	/*
 	 * This device is quirked not to be put into D3, so don't put it in
 	 * D3
@@ -1124,8 +1137,6 @@ int pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 	if (state >= PCI_D3hot && (dev->dev_flags & PCI_DEV_FLAGS_NO_D3))
 		return 0;
 
-	__pci_start_power_transition(dev, state);
-
 	/*
 	 * To put device in D3cold, we put device into D3hot in native
 	 * way, then put device into D3cold with platform ops
@@ -1140,16 +1151,6 @@ int pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 }
 EXPORT_SYMBOL(pci_set_power_state);
 
-/**
- * pci_power_up - Put the given device into D0 forcibly
- * @dev: PCI device to power up
- */
-void pci_power_up(struct pci_dev *dev)
-{
-	__pci_start_power_transition(dev, PCI_D0);
-	pci_raw_set_power_state(dev, PCI_D0);
-}
-
 /**
  * pci_choose_state - Choose the power state of a PCI device
  * @dev: PCI device to be suspended

commit 81cfa5908fd6fe610b7c47b742fe30d6d897ba0f
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Nov 5 11:13:43 2019 +0100

    PCI/PM: Move power state update away from pci_power_up()
    
    Move the invocation of pci_update_current_state() from pci_power_up() to
    pci_pm_default_resume_early(), which is the only caller of that function.
    
    Preparatory change, no functional impact.
    
    Link: https://lore.kernel.org/r/37482337.udjOGdOKNb@kreacher
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index ea98c77a6512..11b4d9274d96 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1148,7 +1148,6 @@ void pci_power_up(struct pci_dev *dev)
 {
 	__pci_start_power_transition(dev, PCI_D0);
 	pci_raw_set_power_state(dev, PCI_D0);
-	pci_update_current_state(dev, PCI_D0);
 }
 
 /**

commit baef7f8e5e91f85ce7625c11370479f9f0778fae
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Oct 16 15:23:20 2019 -0500

    PCI/PM: Simplify pci_set_power_state()
    
    Check for the PCI_DEV_FLAGS_NO_D3 quirk early, before calling
    __pci_start_power_transition().  This way all the cases where we don't need
    to do anything at all are checked up front.
    
    This doesn't fix anything because if the caller requested D3hot or D3cold,
    __pci_start_power_transition() is a no-op.  But calling it is pointless and
    makes the code harder to analyze.
    
    Link: https://lore.kernel.org/r/20191101204558.210235-4-helgaas@kernel.org
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 9378fe5fe475..ea98c77a6512 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1117,8 +1117,6 @@ int pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 	if (dev->current_state == state)
 		return 0;
 
-	__pci_start_power_transition(dev, state);
-
 	/*
 	 * This device is quirked not to be put into D3, so don't put it in
 	 * D3
@@ -1126,6 +1124,8 @@ int pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 	if (state >= PCI_D3hot && (dev->dev_flags & PCI_DEV_FLAGS_NO_D3))
 		return 0;
 
+	__pci_start_power_transition(dev, state);
+
 	/*
 	 * To put device in D3cold, we put device into D3hot in native
 	 * way, then put device into D3cold with platform ops

commit 993cc6d1bd3af734693a74a3ccc9445dd5b31f9c
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Oct 28 08:27:00 2019 -0500

    PCI/PM: Expand PM reset messages to mention D3hot (not just D3)
    
    pci_pm_reset() resets a device by putting it in D3hot and bringing it back
    to D0.  Clarify related messages to mention "D3hot" explicitly instead of
    just "D3".
    
    Link: https://lore.kernel.org/r/20191101204558.210235-3-helgaas@kernel.org
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 4dfbde4f944e..9378fe5fe475 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -4603,7 +4603,7 @@ static int pci_pm_reset(struct pci_dev *dev, int probe)
 	pci_write_config_word(dev, dev->pm_cap + PCI_PM_CTRL, csr);
 	pci_dev_d3_sleep(dev);
 
-	return pci_dev_wait(dev, "PM D3->D0", PCIE_RESET_READY_POLL_MS);
+	return pci_dev_wait(dev, "PM D3hot->D0", PCIE_RESET_READY_POLL_MS);
 }
 /**
  * pcie_wait_for_link - Wait until link is active or inactive

commit 7e24bc347e57992d532bc2ed700209b0fc0a4bf5
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Oct 23 17:40:52 2019 -0500

    PCI/PM: Apply D2 delay as milliseconds, not microseconds
    
    PCI_PM_D2_DELAY is defined as 200, which is milliseconds, but previously we
    used udelay(), which only waited for 200 microseconds.  Use msleep()
    instead so we wait the correct amount of time.  See PCIe r5.0, sec 5.9.
    
    Link: https://lore.kernel.org/r/20191101204558.210235-2-helgaas@kernel.org
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index a97e2571a527..4dfbde4f944e 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -886,7 +886,7 @@ static int pci_raw_set_power_state(struct pci_dev *dev, pci_power_t state)
 	if (state == PCI_D3hot || dev->current_state == PCI_D3hot)
 		pci_dev_d3_sleep(dev);
 	else if (state == PCI_D2 || dev->current_state == PCI_D2)
-		udelay(PCI_PM_D2_DELAY);
+		msleep(PCI_PM_D2_DELAY);
 
 	pci_read_config_word(dev, dev->pm_cap + PCI_PM_CTRL, &pmcsr);
 	dev->current_state = (pmcsr & PCI_PM_CTRL_STATE_MASK);

commit d7b8a217521ca21e2c6391da88d4928c6ce1f539
Author: Nicholas Johnson <nicholas.johnson-opensource@outlook.com.au>
Date:   Wed Oct 23 12:12:29 2019 +0000

    PCI: Add "pci=hpmmiosize" and "pci=hpmmioprefsize" parameters
    
    The existing "pci=hpmemsize=nn[KMG]" kernel parameter overrides the default
    size of both the non-prefetchable and the prefetchable MMIO windows for
    hotplug bridges.
    
    Add "pci=hpmmiosize=nn[KMG]" to override the default size of only the
    non-prefetchable MMIO window.
    
    Add "pci=hpmmioprefsize=nn[KMG]" to override the default size of only the
    prefetchable MMIO window.
    
    Link: https://lore.kernel.org/r/SL2P216MB0187E4D0055791957B7E2660806B0@SL2P216MB0187.KORP216.PROD.OUTLOOK.COM
    Signed-off-by: Nicholas Johnson <nicholas.johnson-opensource@outlook.com.au>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 184765f12848..66ff1ca5b688 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -85,10 +85,17 @@ unsigned long pci_cardbus_io_size = DEFAULT_CARDBUS_IO_SIZE;
 unsigned long pci_cardbus_mem_size = DEFAULT_CARDBUS_MEM_SIZE;
 
 #define DEFAULT_HOTPLUG_IO_SIZE		(256)
-#define DEFAULT_HOTPLUG_MEM_SIZE	(2*1024*1024)
-/* pci=hpmemsize=nnM,hpiosize=nn can override this */
+#define DEFAULT_HOTPLUG_MMIO_SIZE	(2*1024*1024)
+#define DEFAULT_HOTPLUG_MMIO_PREF_SIZE	(2*1024*1024)
+/* hpiosize=nn can override this */
 unsigned long pci_hotplug_io_size  = DEFAULT_HOTPLUG_IO_SIZE;
-unsigned long pci_hotplug_mem_size = DEFAULT_HOTPLUG_MEM_SIZE;
+/*
+ * pci=hpmmiosize=nnM overrides non-prefetchable MMIO size,
+ * pci=hpmmioprefsize=nnM overrides prefetchable MMIO size;
+ * pci=hpmemsize=nnM overrides both
+ */
+unsigned long pci_hotplug_mmio_size = DEFAULT_HOTPLUG_MMIO_SIZE;
+unsigned long pci_hotplug_mmio_pref_size = DEFAULT_HOTPLUG_MMIO_PREF_SIZE;
 
 #define DEFAULT_HOTPLUG_BUS_SIZE	1
 unsigned long pci_hotplug_bus_size = DEFAULT_HOTPLUG_BUS_SIZE;
@@ -6289,8 +6296,13 @@ static int __init pci_setup(char *str)
 				pcie_ecrc_get_policy(str + 5);
 			} else if (!strncmp(str, "hpiosize=", 9)) {
 				pci_hotplug_io_size = memparse(str + 9, &str);
+			} else if (!strncmp(str, "hpmmiosize=", 11)) {
+				pci_hotplug_mmio_size = memparse(str + 11, &str);
+			} else if (!strncmp(str, "hpmmioprefsize=", 15)) {
+				pci_hotplug_mmio_pref_size = memparse(str + 15, &str);
 			} else if (!strncmp(str, "hpmemsize=", 10)) {
-				pci_hotplug_mem_size = memparse(str + 10, &str);
+				pci_hotplug_mmio_size = memparse(str + 10, &str);
+				pci_hotplug_mmio_pref_size = pci_hotplug_mmio_size;
 			} else if (!strncmp(str, "hpbussize=", 10)) {
 				pci_hotplug_bus_size =
 					simple_strtoul(str + 10, &str, 0);

commit 52525b7a3cf82adec5c6cf0ecbd23ff228badc94
Author: Kai-Heng Feng <kai.heng.feng@canonical.com>
Date:   Fri Oct 18 15:38:47 2019 +0800

    PCI: Add a helper to check Power Resource Requirements _PR3 existence
    
    A driver may want to know the existence of _PR3, to choose different
    runtime suspend behavior. A user will be add in next patch.
    
    This is mostly the same as nouveau_pr3_present().
    
    Signed-off-by: Kai-Heng Feng <kai.heng.feng@canonical.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Link: https://lore.kernel.org/r/20191018073848.14590-1-kai.heng.feng@canonical.com
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index e7982af9a5d8..1df99d9e350e 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -5856,6 +5856,24 @@ int pci_set_vga_state(struct pci_dev *dev, bool decode,
 	return 0;
 }
 
+#ifdef CONFIG_ACPI
+bool pci_pr3_present(struct pci_dev *pdev)
+{
+	struct acpi_device *adev;
+
+	if (acpi_disabled)
+		return false;
+
+	adev = ACPI_COMPANION(&pdev->dev);
+	if (!adev)
+		return false;
+
+	return adev->power.flags.power_resources &&
+		acpi_has_method(adev->handle, "_PR3");
+}
+EXPORT_SYMBOL_GPL(pci_pr3_present);
+#endif
+
 /**
  * pci_add_dma_alias - Add a DMA devfn alias for a device
  * @dev: the PCI device for which alias is added

commit af65d1ad416bc6e069ccb9e649faeda224248f96
Author: Patel, Mayurkumar <mayurkumar.patel@intel.com>
Date:   Fri Oct 18 16:52:21 2019 +0000

    PCI/AER: Save AER Capability for suspend/resume
    
    Previously we did not save and restore the AER configuration on
    suspend/resume, so the configuration may be lost after resume.
    
    Save the AER configuration during suspend and restore it during resume.
    
    [bhelgaas: commit log]
    Link: https://lore.kernel.org/r/92EBB4272BF81E4089A7126EC1E7B28492C3B007@IRSMSX101.ger.corp.intel.com
    Signed-off-by: Mayurkumar Patel <mayurkumar.patel@intel.com>
    Signed-off-by: Kuppuswamy Sathyanarayanan <sathyanarayanan.kuppuswamy@linux.intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index e7982af9a5d8..d02636540ca1 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1361,6 +1361,7 @@ int pci_save_state(struct pci_dev *dev)
 
 	pci_save_ltr_state(dev);
 	pci_save_dpc_state(dev);
+	pci_save_aer_state(dev);
 	return pci_save_vc_state(dev);
 }
 EXPORT_SYMBOL(pci_save_state);
@@ -1474,6 +1475,7 @@ void pci_restore_state(struct pci_dev *dev)
 	pci_restore_dpc_state(dev);
 
 	pci_cleanup_aer_error_status_regs(dev);
+	pci_restore_aer_state(dev);
 
 	pci_restore_config_space(dev);
 

commit 45144d42f299455911cc29366656c7324a3a7c97
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Oct 14 13:25:00 2019 +0200

    PCI: PM: Fix pci_power_up()
    
    There is an arbitrary difference between the system resume and
    runtime resume code paths for PCI devices regarding the delay to
    apply when switching the devices from D3cold to D0.
    
    Namely, pci_restore_standard_config() used in the runtime resume
    code path calls pci_set_power_state() which in turn invokes
    __pci_start_power_transition() to power up the device through the
    platform firmware and that function applies the transition delay
    (as per PCI Express Base Specification Revision 2.0, Section 6.6.1).
    However, pci_pm_default_resume_early() used in the system resume
    code path calls pci_power_up() which doesn't apply the delay at
    all and that causes issues to occur during resume from
    suspend-to-idle on some systems where the delay is required.
    
    Since there is no reason for that difference to exist, modify
    pci_power_up() to follow pci_set_power_state() more closely and
    invoke __pci_start_power_transition() from there to call the
    platform firmware to power up the device (in case that's necessary).
    
    Fixes: db288c9c5f9d ("PCI / PM: restore the original behavior of pci_set_power_state()")
    Reported-by: Daniel Drake <drake@endlessm.com>
    Tested-by: Daniel Drake <drake@endlessm.com>
    Link: https://lore.kernel.org/linux-pm/CAD8Lp44TYxrMgPLkHCqF9hv6smEurMXvmmvmtyFhZ6Q4SE+dig@mail.gmail.com/T/#m21be74af263c6a34f36e0fc5c77c5449d9406925
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: 3.10+ <stable@vger.kernel.org> # 3.10+

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index e7982af9a5d8..a97e2571a527 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -958,19 +958,6 @@ void pci_refresh_power_state(struct pci_dev *dev)
 	pci_update_current_state(dev, dev->current_state);
 }
 
-/**
- * pci_power_up - Put the given device into D0 forcibly
- * @dev: PCI device to power up
- */
-void pci_power_up(struct pci_dev *dev)
-{
-	if (platform_pci_power_manageable(dev))
-		platform_pci_set_power_state(dev, PCI_D0);
-
-	pci_raw_set_power_state(dev, PCI_D0);
-	pci_update_current_state(dev, PCI_D0);
-}
-
 /**
  * pci_platform_power_transition - Use platform to change device power state
  * @dev: PCI device to handle.
@@ -1153,6 +1140,17 @@ int pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 }
 EXPORT_SYMBOL(pci_set_power_state);
 
+/**
+ * pci_power_up - Put the given device into D0 forcibly
+ * @dev: PCI device to power up
+ */
+void pci_power_up(struct pci_dev *dev)
+{
+	__pci_start_power_transition(dev, PCI_D0);
+	pci_raw_set_power_state(dev, PCI_D0);
+	pci_update_current_state(dev, PCI_D0);
+}
+
 /**
  * pci_choose_state - Choose the power state of a PCI device
  * @dev: PCI device to be suspended

commit c9c13ba428ef90a9b408a6cdf874e14ab5754516
Author: Denis Efremov <efremov@linux.com>
Date:   Sat Sep 28 02:43:08 2019 +0300

    PCI: Add PCI_STD_NUM_BARS for the number of standard BARs
    
    Code that iterates over all standard PCI BARs typically uses
    PCI_STD_RESOURCE_END.  However, that requires the unusual test
    "i <= PCI_STD_RESOURCE_END" rather than something the typical
    "i < PCI_STD_NUM_BARS".
    
    Add a definition for PCI_STD_NUM_BARS and change loops to use the more
    idiomatic C style to help avoid fencepost errors.
    
    Link: https://lore.kernel.org/r/20190927234026.23342-1-efremov@linux.com
    Link: https://lore.kernel.org/r/20190927234308.23935-1-efremov@linux.com
    Link: https://lore.kernel.org/r/20190916204158.6889-3-efremov@linux.com
    Signed-off-by: Denis Efremov <efremov@linux.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Sebastian Ott <sebott@linux.ibm.com>                  # arch/s390/
    Acked-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>  # video/fbdev/
    Acked-by: Gustavo Pimentel <gustavo.pimentel@synopsys.com>      # pci/controller/dwc/
    Acked-by: Jack Wang <jinpu.wang@cloud.ionos.com>                # scsi/pm8001/
    Acked-by: Martin K. Petersen <martin.petersen@oracle.com>       # scsi/pm8001/
    Acked-by: Ulf Hansson <ulf.hansson@linaro.org>                  # memstick/

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index e7982af9a5d8..184765f12848 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -674,7 +674,7 @@ struct resource *pci_find_resource(struct pci_dev *dev, struct resource *res)
 {
 	int i;
 
-	for (i = 0; i < PCI_ROM_RESOURCE; i++) {
+	for (i = 0; i < PCI_STD_NUM_BARS; i++) {
 		struct resource *r = &dev->resource[i];
 
 		if (r->start && resource_contains(r, res))
@@ -3768,7 +3768,7 @@ void pci_release_selected_regions(struct pci_dev *pdev, int bars)
 {
 	int i;
 
-	for (i = 0; i < 6; i++)
+	for (i = 0; i < PCI_STD_NUM_BARS; i++)
 		if (bars & (1 << i))
 			pci_release_region(pdev, i);
 }
@@ -3779,7 +3779,7 @@ static int __pci_request_selected_regions(struct pci_dev *pdev, int bars,
 {
 	int i;
 
-	for (i = 0; i < 6; i++)
+	for (i = 0; i < PCI_STD_NUM_BARS; i++)
 		if (bars & (1 << i))
 			if (__pci_request_region(pdev, i, res_name, excl))
 				goto err_out;
@@ -3827,7 +3827,7 @@ EXPORT_SYMBOL(pci_request_selected_regions_exclusive);
 
 void pci_release_regions(struct pci_dev *pdev)
 {
-	pci_release_selected_regions(pdev, (1 << 6) - 1);
+	pci_release_selected_regions(pdev, (1 << PCI_STD_NUM_BARS) - 1);
 }
 EXPORT_SYMBOL(pci_release_regions);
 
@@ -3846,7 +3846,8 @@ EXPORT_SYMBOL(pci_release_regions);
  */
 int pci_request_regions(struct pci_dev *pdev, const char *res_name)
 {
-	return pci_request_selected_regions(pdev, ((1 << 6) - 1), res_name);
+	return pci_request_selected_regions(pdev,
+			((1 << PCI_STD_NUM_BARS) - 1), res_name);
 }
 EXPORT_SYMBOL(pci_request_regions);
 
@@ -3868,7 +3869,7 @@ EXPORT_SYMBOL(pci_request_regions);
 int pci_request_regions_exclusive(struct pci_dev *pdev, const char *res_name)
 {
 	return pci_request_selected_regions_exclusive(pdev,
-					((1 << 6) - 1), res_name);
+				((1 << PCI_STD_NUM_BARS) - 1), res_name);
 }
 EXPORT_SYMBOL(pci_request_regions_exclusive);
 

commit 299d14d4c31aff3b37a03894e012edf8421676ee
Merge: e94f8ccde471 c5048a73b477
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Sep 23 19:16:01 2019 -0700

    Merge tag 'pci-v5.4-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI updates from Bjorn Helgaas:
     "Enumeration:
    
       - Consolidate _HPP/_HPX stuff in pci-acpi.c and simplify it
         (Krzysztof Wilczynski)
    
       - Fix incorrect PCIe device types and remove dev->has_secondary_link
         to simplify code that deals with upstream/downstream ports (Mika
         Westerberg)
    
       - After suspend, restore Resizable BAR size bits correctly for 1MB
         BARs (Sumit Saxena)
    
       - Enable PCI_MSI_IRQ_DOMAIN support for RISC-V (Wesley Terpstra)
    
      Virtualization:
    
       - Add ACS quirks for iProc PAXB (Abhinav Ratna), Amazon Annapurna
         Labs (Ali Saidi)
    
       - Move sysfs SR-IOV functions to iov.c (Kelsey Skunberg)
    
       - Remove group write permissions from sysfs sriov_numvfs,
         sriov_drivers_autoprobe (Kelsey Skunberg)
    
      Hotplug:
    
       - Simplify pciehp indicator control (Denis Efremov)
    
      Peer-to-peer DMA:
    
       - Allow P2P DMA between root ports for whitelisted bridges (Logan
         Gunthorpe)
    
       - Whitelist some Intel host bridges for P2P DMA (Logan Gunthorpe)
    
       - DMA map P2P DMA requests that traverse host bridge (Logan
         Gunthorpe)
    
      Amazon Annapurna Labs host bridge driver:
    
       - Add DT binding and controller driver (Jonathan Chocron)
    
      Hyper-V host bridge driver:
    
       - Fix hv_pci_dev->pci_slot use-after-free (Dexuan Cui)
    
       - Fix PCI domain number collisions (Haiyang Zhang)
    
       - Use instance ID bytes 4 & 5 as PCI domain numbers (Haiyang Zhang)
    
       - Fix build errors on non-SYSFS config (Randy Dunlap)
    
      i.MX6 host bridge driver:
    
       - Limit DBI register length (Stefan Agner)
    
      Intel VMD host bridge driver:
    
       - Fix config addressing issues (Jon Derrick)
    
      Layerscape host bridge driver:
    
       - Add bar_fixed_64bit property to endpoint driver (Xiaowei Bao)
    
       - Add CONFIG_PCI_LAYERSCAPE_EP to build EP/RC drivers separately
         (Xiaowei Bao)
    
      Mediatek host bridge driver:
    
       - Add MT7629 controller support (Jianjun Wang)
    
      Mobiveil host bridge driver:
    
       - Fix CPU base address setup (Hou Zhiqiang)
    
       - Make "num-lanes" property optional (Hou Zhiqiang)
    
      Tegra host bridge driver:
    
       - Fix OF node reference leak (Nishka Dasgupta)
    
       - Disable MSI for root ports to work around design problem (Vidya
         Sagar)
    
       - Add Tegra194 DT binding and controller support (Vidya Sagar)
    
       - Add support for sideband pins and slot regulators (Vidya Sagar)
    
       - Add PIPE2UPHY support (Vidya Sagar)
    
      Misc:
    
       - Remove unused pci_block_cfg_access() et al (Kelsey Skunberg)
    
       - Unexport pci_bus_get(), etc (Kelsey Skunberg)
    
       - Hide PM, VC, link speed, ATS, ECRC, PTM constants and interfaces in
         the PCI core (Kelsey Skunberg)
    
       - Clean up sysfs DEVICE_ATTR() usage (Kelsey Skunberg)
    
       - Mark expected switch fall-through (Gustavo A. R. Silva)
    
       - Propagate errors for optional regulators and PHYs (Thierry Reding)
    
       - Fix kernel command line resource_alignment parameter issues (Logan
         Gunthorpe)"
    
    * tag 'pci-v5.4-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (112 commits)
      PCI: Add pci_irq_vector() and other stubs when !CONFIG_PCI
      arm64: tegra: Add PCIe slot supply information in p2972-0000 platform
      arm64: tegra: Add configuration for PCIe C5 sideband signals
      PCI: tegra: Add support to enable slot regulators
      PCI: tegra: Add support to configure sideband pins
      PCI: vmd: Fix shadow offsets to reflect spec changes
      PCI: vmd: Fix config addressing when using bus offsets
      PCI: dwc: Add validation that PCIe core is set to correct mode
      PCI: dwc: al: Add Amazon Annapurna Labs PCIe controller driver
      dt-bindings: PCI: Add Amazon's Annapurna Labs PCIe host bridge binding
      PCI: Add quirk to disable MSI-X support for Amazon's Annapurna Labs Root Port
      PCI/VPD: Prevent VPD access for Amazon's Annapurna Labs Root Port
      PCI: Add ACS quirk for Amazon Annapurna Labs root ports
      PCI: Add Amazon's Annapurna Labs vendor ID
      MAINTAINERS: Add PCI native host/endpoint controllers designated reviewer
      PCI: hv: Use bytes 4 and 5 from instance ID as the PCI domain numbers
      dt-bindings: PCI: tegra: Add PCIe slot supplies regulator entries
      dt-bindings: PCI: tegra: Add sideband pins configuration entries
      PCI: tegra: Add Tegra194 PCIe support
      PCI: Get rid of dev->has_secondary_link flag
      ...

commit 0ca0ef1042f49c4b457ca6cb48ebb5d1c0bcf003
Merge: 203104c8d5ec 3b1b1ce35964
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Sep 23 16:10:15 2019 -0500

    Merge branch 'pci/resource'
    
      - Convert pci_resource_to_user() to a weak function to remove
        HAVE_ARCH_PCI_RESOURCE_TO_USER #defines (Denis Efremov)
    
      - Use PCI_SRIOV_NUM_BARS for idiomatic loop structure (Denis Efremov)
    
      - Fix Resizable BAR size suspend/restore for 1MB BARs (Sumit Saxena)
    
      - Correct "pci=resource_alignment" example in documentation (Alexey
        Kardashevskiy)
    
    * pci/resource:
      PCI: Correct pci=resource_alignment parameter example
      PCI: Restore Resizable BAR size bits correctly for 1MB BARs
      PCI: Use PCI_SRIOV_NUM_BARS in loops instead of PCI_IOV_RESOURCE_END
      PCI: Convert pci_resource_to_user() to a weak function
    
    # Conflicts:
    #       drivers/pci/pci.c

commit 6ce54f0219c8794b603b0dea2673cfa1998a137c
Merge: a10a1f60c7a3 0d8006ddbe89
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Sep 23 16:10:10 2019 -0500

    Merge branch 'pci/misc'
    
      - Use devm_add_action_or_reset() helper (Fuqian Huang)
    
      - Mark expected switch fall-through (Gustavo A. R. Silva)
    
      - Convert sysfs device attributes from __ATTR() to DEVICE_ATTR() (Kelsey
        Skunberg)
    
      - Convert sysfs file permissions from S_IRUSR etc to octal (Kelsey
        Skunberg)
    
      - Move SR-IOV sysfs functions to iov.c (Kelsey Skunberg)
    
      - Add pci_info_ratelimited() to ratelimit PCI messages separately
        (Krzysztof Wilczynski)
    
      - Fix "'static' not at beginning of declaration" warnings (Krzysztof
        Wilczynski)
    
      - Clean up resource_alignment parameter to not require static buffer
        (Logan Gunthorpe)
    
      - Add ACS quirk for iProc PAXB (Abhinav Ratna)
    
      - Add pci_irq_vector() and other stubs for !CONFIG_PCI (Herbert Xu)
    
    * pci/misc:
      PCI: Add pci_irq_vector() and other stubs when !CONFIG_PCI
      PCI: Add ACS quirk for iProc PAXB
      PCI: Force trailing new line to resource_alignment_param in sysfs
      PCI: Move pci_[get|set]_resource_alignment_param() into their callers
      PCI: Clean up resource_alignment parameter to not require static buffer
      PCI: Use static const struct, not const static struct
      PCI: Add pci_info_ratelimited() to ratelimit PCI separately
      PCI/IOV: Remove group write permission from sriov_numvfs, sriov_drivers_autoprobe
      PCI/IOV: Move sysfs SR-IOV functions to iov.c
      PCI: sysfs: Change permissions from symbolic to octal
      PCI: sysfs: Change DEVICE_ATTR() to DEVICE_ATTR_WO()
      PCI: sysfs: Define device attributes with DEVICE_ATTR*()
      PCI: Mark expected switch fall-through
      PCI: Use devm_add_action_or_reset()

commit ca78410403dd64ac0ee0e3cc8646b38335271bfd
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Thu Aug 22 11:55:53 2019 +0300

    PCI: Get rid of dev->has_secondary_link flag
    
    In some systems, the Device/Port Type in the PCI Express Capabilities
    register incorrectly identifies upstream ports as downstream ports.
    
    d0751b98dfa3 ("PCI: Add dev->has_secondary_link to track downstream PCIe
    links") addressed this by adding pci_dev.has_secondary_link, which is set
    for downstream ports.  But this is confusing because pci_pcie_type()
    sometimes gives the wrong answer, and it's not obvious that we should use
    pci_dev.has_secondary_link instead.
    
    Reduce the confusion by correcting the type of the port itself so that
    pci_pcie_type() returns the actual type regardless of what the Device/Port
    Type register claims it is.  Update the users to call pci_pcie_type() and
    pcie_downstream_port() accordingly, and remove pci_dev.has_secondary_link
    completely.
    
    Link: https://lore.kernel.org/linux-pci/20190703133953.GK128603@google.com/
    Suggested-by: Bjorn Helgaas <bhelgaas@google.com>
    Link: https://lore.kernel.org/r/20190822085553.62697-2-mika.westerberg@linux.intel.com
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 29ed5ec1ac27..97e7f6e0821e 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -3576,7 +3576,7 @@ int pci_enable_atomic_ops_to_root(struct pci_dev *dev, u32 cap_mask)
 		}
 
 		/* Ensure upstream ports don't block AtomicOps on egress */
-		if (!bridge->has_secondary_link) {
+		if (pci_pcie_type(bridge) == PCI_EXP_TYPE_UPSTREAM) {
 			pcie_capability_read_dword(bridge, PCI_EXP_DEVCTL2,
 						   &ctl2);
 			if (ctl2 & PCI_EXP_DEVCTL2_ATOMIC_EGRESS_BLOCK)

commit e499081da1a247a8a5a234211c7127fb0b91ca92
Author: Logan Gunthorpe <logang@deltatee.com>
Date:   Thu Aug 22 10:10:13 2019 -0600

    PCI: Force trailing new line to resource_alignment_param in sysfs
    
    When 'pci=resource_alignment=' is specified on the command line, there is
    no trailing new line.  Then, when it's read through the corresponding sysfs
    attribute, there will be no newline and a cat command will not show
    correctly in a shell. If the parameter is set through sysfs a new line will
    be stored and it will 'cat' correctly.
    
    To solve this, append a new line character in the show function if one does
    not already exist.
    
    Link: https://lore.kernel.org/r/20190822161013.5481-4-logang@deltatee.com
    Signed-off-by: Logan Gunthorpe <logang@deltatee.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index ff3abc577a25..5f70ff1031d2 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -6126,6 +6126,16 @@ static ssize_t resource_alignment_show(struct bus_type *bus, char *buf)
 		count = snprintf(buf, PAGE_SIZE, "%s", resource_alignment_param);
 	spin_unlock(&resource_alignment_lock);
 
+	/*
+	 * When set by the command line, resource_alignment_param will not
+	 * have a trailing line feed, which is ugly. So conditionally add
+	 * it here.
+	 */
+	if (count >= 2 && buf[count - 2] != '\n' && count < PAGE_SIZE - 1) {
+		buf[count - 1] = '\n';
+		buf[count++] = 0;
+	}
+
 	return count;
 }
 

commit 273b177cac4b649c3c6d448e85bbc64cebfe7a0a
Author: Logan Gunthorpe <logang@deltatee.com>
Date:   Thu Aug 22 10:10:12 2019 -0600

    PCI: Move pci_[get|set]_resource_alignment_param() into their callers
    
    Both the functions pci_get_resource_alignment_param() and
    pci_set_resource_alignment_param() are now only called in one place:
    resource_alignment_show() and resource_alignment_store() respectively.
    
    There is no value in this extra set of functions so move both into their
    callers respectively.
    
    [bhelgaas: fold in "GFP_KERNEL while atomic" fix from Christoph Hellwig
    <hch@infradead.org>
    https://lore.kernel.org/r/20190902075006.GB754@infradead.org]
    Link: https://lore.kernel.org/r/20190822161013.5481-3-logang@deltatee.com
    Signed-off-by: Logan Gunthorpe <logang@deltatee.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index fbfb64ba447d..ff3abc577a25 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -6117,39 +6117,31 @@ void pci_reassigndev_resource_alignment(struct pci_dev *dev)
 	}
 }
 
-static ssize_t pci_set_resource_alignment_param(const char *buf, size_t count)
-{
-	spin_lock(&resource_alignment_lock);
-
-	kfree(resource_alignment_param);
-	resource_alignment_param = kstrndup(buf, count, GFP_KERNEL);
-
-	spin_unlock(&resource_alignment_lock);
-
-	return resource_alignment_param ? count : -ENOMEM;
-}
-
-static ssize_t pci_get_resource_alignment_param(char *buf, size_t size)
+static ssize_t resource_alignment_show(struct bus_type *bus, char *buf)
 {
 	size_t count = 0;
 
 	spin_lock(&resource_alignment_lock);
 	if (resource_alignment_param)
-		count = snprintf(buf, size, "%s", resource_alignment_param);
+		count = snprintf(buf, PAGE_SIZE, "%s", resource_alignment_param);
 	spin_unlock(&resource_alignment_lock);
 
 	return count;
 }
 
-static ssize_t resource_alignment_show(struct bus_type *bus, char *buf)
-{
-	return pci_get_resource_alignment_param(buf, PAGE_SIZE);
-}
-
 static ssize_t resource_alignment_store(struct bus_type *bus,
 					const char *buf, size_t count)
 {
-	return pci_set_resource_alignment_param(buf, count);
+	char *param = kstrndup(buf, count, GFP_KERNEL);
+
+	if (!param)
+		return -ENOMEM;
+
+	spin_lock(&resource_alignment_lock);
+	kfree(resource_alignment_param);
+	resource_alignment_param = param;
+	spin_unlock(&resource_alignment_lock);
+	return count;
 }
 
 static BUS_ATTR_RW(resource_alignment);

commit 70aaf61a9b8b86eb08da96344efd1c0f0925ee6e
Author: Logan Gunthorpe <logang@deltatee.com>
Date:   Thu Aug 22 10:10:11 2019 -0600

    PCI: Clean up resource_alignment parameter to not require static buffer
    
    Clean up the 'resource_alignment' parameter code to use kstrdup() in the
    initcall routine instead of a static buffer that wastes memory regardless
    of whether the feature is used.  This allows us to drop 'COMMAND_LINE_SIZE'
    bytes (typically 256-4096 depending on architecture) of static data.
    
    This is similar to what has been done for the 'disable_acs_redir'
    parameter.
    
    Link: https://lore.kernel.org/r/20190822161013.5481-2-logang@deltatee.com
    Signed-off-by: Logan Gunthorpe <logang@deltatee.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 08dfb16bd084..fbfb64ba447d 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -5932,8 +5932,7 @@ resource_size_t __weak pcibios_default_alignment(void)
 	return 0;
 }
 
-#define RESOURCE_ALIGNMENT_PARAM_SIZE COMMAND_LINE_SIZE
-static char resource_alignment_param[RESOURCE_ALIGNMENT_PARAM_SIZE] = {0};
+static char *resource_alignment_param;
 static DEFINE_SPINLOCK(resource_alignment_lock);
 
 /**
@@ -5954,7 +5953,7 @@ static resource_size_t pci_specified_resource_alignment(struct pci_dev *dev,
 
 	spin_lock(&resource_alignment_lock);
 	p = resource_alignment_param;
-	if (!*p && !align)
+	if (!p || !*p)
 		goto out;
 	if (pci_has_flag(PCI_PROBE_ONLY)) {
 		align = 0;
@@ -6120,21 +6119,25 @@ void pci_reassigndev_resource_alignment(struct pci_dev *dev)
 
 static ssize_t pci_set_resource_alignment_param(const char *buf, size_t count)
 {
-	if (count > RESOURCE_ALIGNMENT_PARAM_SIZE - 1)
-		count = RESOURCE_ALIGNMENT_PARAM_SIZE - 1;
 	spin_lock(&resource_alignment_lock);
-	strncpy(resource_alignment_param, buf, count);
-	resource_alignment_param[count] = '\0';
+
+	kfree(resource_alignment_param);
+	resource_alignment_param = kstrndup(buf, count, GFP_KERNEL);
+
 	spin_unlock(&resource_alignment_lock);
-	return count;
+
+	return resource_alignment_param ? count : -ENOMEM;
 }
 
 static ssize_t pci_get_resource_alignment_param(char *buf, size_t size)
 {
-	size_t count;
+	size_t count = 0;
+
 	spin_lock(&resource_alignment_lock);
-	count = snprintf(buf, size, "%s", resource_alignment_param);
+	if (resource_alignment_param)
+		count = snprintf(buf, size, "%s", resource_alignment_param);
 	spin_unlock(&resource_alignment_lock);
+
 	return count;
 }
 
@@ -6275,8 +6278,7 @@ static int __init pci_setup(char *str)
 			} else if (!strncmp(str, "cbmemsize=", 10)) {
 				pci_cardbus_mem_size = memparse(str + 10, &str);
 			} else if (!strncmp(str, "resource_alignment=", 19)) {
-				pci_set_resource_alignment_param(str + 19,
-							strlen(str + 19));
+				resource_alignment_param = str + 19;
 			} else if (!strncmp(str, "ecrc=", 5)) {
 				pcie_ecrc_get_policy(str + 5);
 			} else if (!strncmp(str, "hpiosize=", 9)) {
@@ -6311,15 +6313,18 @@ static int __init pci_setup(char *str)
 early_param("pci", pci_setup);
 
 /*
- * 'disable_acs_redir_param' is initialized in pci_setup(), above, to point
- * to data in the __initdata section which will be freed after the init
- * sequence is complete. We can't allocate memory in pci_setup() because some
- * architectures do not have any memory allocation service available during
- * an early_param() call. So we allocate memory and copy the variable here
- * before the init section is freed.
+ * 'resource_alignment_param' and 'disable_acs_redir_param' are initialized
+ * in pci_setup(), above, to point to data in the __initdata section which
+ * will be freed after the init sequence is complete. We can't allocate memory
+ * in pci_setup() because some architectures do not have any memory allocation
+ * service available during an early_param() call. So we allocate memory and
+ * copy the variable here before the init section is freed.
+ *
  */
 static int __init pci_realloc_setup_params(void)
 {
+	resource_alignment_param = kstrdup(resource_alignment_param,
+					   GFP_KERNEL);
 	disable_acs_redir_param = kstrdup(disable_acs_redir_param, GFP_KERNEL);
 
 	return 0;

commit 7f1c62c443a453deb6eb3515e3c05650ffe0dcf0
Author: Krzysztof Wilczynski <kw@linux.com>
Date:   Mon Aug 26 00:46:16 2019 +0200

    PCI: Add pci_info_ratelimited() to ratelimit PCI separately
    
    Do not use printk_ratelimit() in drivers/pci/pci.c as it shares the rate
    limiting state with all other callers to the printk_ratelimit().
    
    Add pci_info_ratelimited() (similar to pci_notice_ratelimited() added in
    the commit a88a7b3eb076 ("vfio: Use dev_printk() when possible")) and use
    it instead of printk_ratelimit() + pci_info().
    
    Link: https://lore.kernel.org/r/20190825224616.8021-1-kw@linux.com
    Signed-off-by: Krzysztof Wilczynski <kw@linux.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 29ed5ec1ac27..08dfb16bd084 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -890,8 +890,8 @@ static int pci_raw_set_power_state(struct pci_dev *dev, pci_power_t state)
 
 	pci_read_config_word(dev, dev->pm_cap + PCI_PM_CTRL, &pmcsr);
 	dev->current_state = (pmcsr & PCI_PM_CTRL_STATE_MASK);
-	if (dev->current_state != state && printk_ratelimit())
-		pci_info(dev, "Refused to change power state, currently in D%d\n",
+	if (dev->current_state != state)
+		pci_info_ratelimited(dev, "Refused to change power state, currently in D%d\n",
 			 dev->current_state);
 
 	/*

commit d2182b2d4b71ff0549a07f414d921525fade707b
Author: Sumit Saxena <sumit.saxena@broadcom.com>
Date:   Fri Jul 26 00:55:52 2019 +0530

    PCI: Restore Resizable BAR size bits correctly for 1MB BARs
    
    In a Resizable BAR Control Register, bits 13:8 control the size of the BAR.
    The encoded values of these bits are as follows (see PCIe r5.0, sec
    7.8.6.3):
    
      Value    BAR size
         0     1 MB (2^20 bytes)
         1     2 MB (2^21 bytes)
         2     4 MB (2^22 bytes)
       ...
        43     8 EB (2^63 bytes)
    
    Previously we incorrectly set the BAR size bits for a 1 MB BAR to 0x1f
    instead of 0, so devices that support that size, e.g., new megaraid_sas and
    mpt3sas adapters, fail to initialize during resume from S3 sleep.
    
    Correctly calculate the BAR size bits for Resizable BAR control registers.
    
    Link: https://lore.kernel.org/r/20190725192552.24295-1-sumit.saxena@broadcom.com
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=203939
    Fixes: d3252ace0bc6 ("PCI: Restore resized BAR state on resume")
    Signed-off-by: Sumit Saxena <sumit.saxena@broadcom.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Christian König <christian.koenig@amd.com>
    Cc: stable@vger.kernel.org      # v4.19+

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index da3241bb4479..5836eb576d96 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1438,7 +1438,7 @@ static void pci_restore_rebar_state(struct pci_dev *pdev)
 		pci_read_config_dword(pdev, pos + PCI_REBAR_CTRL, &ctrl);
 		bar_idx = ctrl & PCI_REBAR_CTRL_BAR_IDX;
 		res = pdev->resource + bar_idx;
-		size = order_base_2((resource_size(res) >> 20) | 1) - 1;
+		size = ilog2(resource_size(res)) - 20;
 		ctrl &= ~PCI_REBAR_CTRL_BAR_SIZE;
 		ctrl |= size << PCI_REBAR_CTRL_BAR_SHIFT;
 		pci_write_config_dword(pdev, pos + PCI_REBAR_CTRL, ctrl);

commit b8074aa2460b535915e8f65bf83c4bcb4220f804
Author: Denis Efremov <efremov@linux.com>
Date:   Mon Jul 29 13:13:57 2019 +0300

    PCI: Convert pci_resource_to_user() to a weak function
    
    Convert pci_resource_to_user() to a weak function so the existing
    architecture-specific implementations will automatically override the
    generic one.  This allows us to remove HAVE_ARCH_PCI_RESOURCE_TO_USER
    definitions and avoid the conditional compilation for this single function.
    
    Link: https://lore.kernel.org/r/20190729101401.28068-1-efremov@linux.com
    Link: https://lore.kernel.org/r/20190729101401.28068-2-efremov@linux.com
    Link: https://lore.kernel.org/r/20190729101401.28068-3-efremov@linux.com
    Link: https://lore.kernel.org/r/20190729101401.28068-4-efremov@linux.com
    Link: https://lore.kernel.org/r/20190729101401.28068-5-efremov@linux.com
    Link: https://lore.kernel.org/r/20190729101401.28068-6-efremov@linux.com
    Signed-off-by: Denis Efremov <efremov@linux.com>
    [bhelgaas: squash into one commit]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Paul Burton <paul.burton@mips.com>    # MIPS

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 29ed5ec1ac27..da3241bb4479 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -5932,6 +5932,18 @@ resource_size_t __weak pcibios_default_alignment(void)
 	return 0;
 }
 
+/*
+ * Arches that don't want to expose struct resource to userland as-is in
+ * sysfs and /proc can implement their own pci_resource_to_user().
+ */
+void __weak pci_resource_to_user(const struct pci_dev *dev, int bar,
+				 const struct resource *rsrc,
+				 resource_size_t *start, resource_size_t *end)
+{
+	*start = rsrc->start;
+	*end = rsrc->end;
+}
+
 #define RESOURCE_ALIGNMENT_PARAM_SIZE COMMAND_LINE_SIZE
 static char resource_alignment_param[RESOURCE_ALIGNMENT_PARAM_SIZE] = {0};
 static DEFINE_SPINLOCK(resource_alignment_lock);

commit 0617bdede5114a0002298b12cd0ca2b0cfd0395d
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Wed Aug 7 13:57:18 2019 +0300

    Revert "PCI: Add missing link delays required by the PCIe spec"
    
    Commit c2bf1fc212f7 ("PCI: Add missing link delays required by the PCIe
    spec") turned out causing issues with some systems either by making them
    unresponsive or slowing down runtime and system wide resume of PCIe
    devices. While root cause for the unresponsiveness is still under
    investigation given the amount of issues reported better to revert it
    for now.
    
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=204413
    Link: https://lore.kernel.org/linux-pci/SL2P216MB01878BBCD75F21D882AEEA2880C60@SL2P216MB0187.KORP216.PROD.OUTLOOK.COM/
    Link: https://lore.kernel.org/linux-pci/2857501d-c167-547d-c57d-d5d24ea1f1dc@molgen.mpg.de/
    Reported-by: Matthias Andree <matthias.andree@gmx.de>
    Reported-by: Paul Menzel <pmenzel@molgen.mpg.de>
    Reported-by: Nicholas Johnson <nicholas.johnson-opensource@outlook.com.au>
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 29ed5ec1ac27..1b27b5af3d55 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1025,10 +1025,15 @@ static void __pci_start_power_transition(struct pci_dev *dev, pci_power_t state)
 	if (state == PCI_D0) {
 		pci_platform_power_transition(dev, PCI_D0);
 		/*
-		 * Mandatory power management transition delays are
-		 * handled in the PCIe portdrv resume hooks.
+		 * Mandatory power management transition delays, see
+		 * PCI Express Base Specification Revision 2.0 Section
+		 * 6.6.1: Conventional Reset.  Do not delay for
+		 * devices powered on/off by corresponding bridge,
+		 * because have already delayed for the bridge.
 		 */
 		if (dev->runtime_d3cold) {
+			if (dev->d3cold_delay && !dev->imm_ready)
+				msleep(dev->d3cold_delay);
 			/*
 			 * When powering on a bridge from D3cold, the
 			 * whole hierarchy may be powered on into
@@ -4602,16 +4607,14 @@ static int pci_pm_reset(struct pci_dev *dev, int probe)
 
 	return pci_dev_wait(dev, "PM D3->D0", PCIE_RESET_READY_POLL_MS);
 }
-
 /**
- * pcie_wait_for_link_delay - Wait until link is active or inactive
+ * pcie_wait_for_link - Wait until link is active or inactive
  * @pdev: Bridge device
  * @active: waiting for active or inactive?
- * @delay: Delay to wait after link has become active (in ms)
  *
  * Use this to wait till link becomes active or inactive.
  */
-bool pcie_wait_for_link_delay(struct pci_dev *pdev, bool active, int delay)
+bool pcie_wait_for_link(struct pci_dev *pdev, bool active)
 {
 	int timeout = 1000;
 	bool ret;
@@ -4648,25 +4651,13 @@ bool pcie_wait_for_link_delay(struct pci_dev *pdev, bool active, int delay)
 		timeout -= 10;
 	}
 	if (active && ret)
-		msleep(delay);
+		msleep(100);
 	else if (ret != active)
 		pci_info(pdev, "Data Link Layer Link Active not %s in 1000 msec\n",
 			active ? "set" : "cleared");
 	return ret == active;
 }
 
-/**
- * pcie_wait_for_link - Wait until link is active or inactive
- * @pdev: Bridge device
- * @active: waiting for active or inactive?
- *
- * Use this to wait till link becomes active or inactive.
- */
-bool pcie_wait_for_link(struct pci_dev *pdev, bool active)
-{
-	return pcie_wait_for_link_delay(pdev, active, 100);
-}
-
 void pci_reset_secondary_bus(struct pci_dev *dev)
 {
 	u16 ctrl;

commit fb4da215ed92f564f7ca090bb81a199b0d6cab8a
Merge: 2a3c389a0fde 7b4b0f6b34d8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jul 15 20:44:49 2019 -0700

    Merge tag 'pci-v5.3-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI updates from Bjorn Helgaas:
     "Enumeration changes:
    
       - Evaluate PCI Boot Configuration _DSM to learn if firmware wants us
         to preserve its resource assignments (Benjamin Herrenschmidt)
    
       - Simplify resource distribution (Nicholas Johnson)
    
       - Decode 32 GT/s link speed (Gustavo Pimentel)
    
      Virtualization:
    
       - Fix incorrect caching of VF config space size (Alex Williamson)
    
       - Fix VF driver probing sysfs knobs (Alex Williamson)
    
      Peer-to-peer DMA:
    
       - Fix dma_virt_ops check (Logan Gunthorpe)
    
      Altera host bridge driver:
    
       - Allow building as module (Ley Foon Tan)
    
      Armada 8K host bridge driver:
    
       - add PHYs support (Miquel Raynal)
    
      DesignWare host bridge driver:
    
       - Export APIs to support removable loadable module (Vidya Sagar)
    
       - Enable Relaxed Ordering erratum workaround only on Tegra20 &
         Tegra30 (Vidya Sagar)
    
      Hyper-V host bridge driver:
    
       - Fix use-after-free in eject (Dexuan Cui)
    
      Mobiveil host bridge driver:
    
       - Clean up and fix many issues, including non-identify mapped
         windows, 64-bit windows, multi-MSI, class code, INTx clearing (Hou
         Zhiqiang)
    
      Qualcomm host bridge driver:
    
       - Use clk bulk API for 2.4.0 controllers (Bjorn Andersson)
    
       - Add QCS404 support (Bjorn Andersson)
    
       - Assert PERST for at least 100ms (Niklas Cassel)
    
      R-Car host bridge driver:
    
       - Add r8a774a1 DT support (Biju Das)
    
      Tegra host bridge driver:
    
       - Add support for Gen2, opportunistic UpdateFC and ACK (PCIe protocol
         details) AER, GPIO-based PERST# (Manikanta Maddireddy)
    
       - Fix many issues, including power-on failure cases, interrupt
         masking in suspend, UPHY settings, AFI dynamic clock gating,
         pending DLL transactions (Manikanta Maddireddy)
    
      Xilinx host bridge driver:
    
       - Fix NWL Multi-MSI programming (Bharat Kumar Gogada)
    
      Endpoint support:
    
       - Fix 64bit BAR support (Alan Mikhak)
    
       - Fix pcitest build issues (Alan Mikhak, Andy Shevchenko)
    
      Bug fixes:
    
       - Fix NVIDIA GPU multi-function power dependencies (Abhishek Sahu)
    
       - Fix NVIDIA GPU HDA enablement issue (Lukas Wunner)
    
       - Ignore lockdep for sysfs "remove" (Marek Vasut)
    
      Misc:
    
       - Convert docs to reST (Changbin Du, Mauro Carvalho Chehab)"
    
    * tag 'pci-v5.3-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (107 commits)
      PCI: Enable NVIDIA HDA controllers
      tools: PCI: Fix installation when `make tools/pci_install`
      PCI: dwc: pci-dra7xx: Fix compilation when !CONFIG_GPIOLIB
      PCI: Fix typos and whitespace errors
      PCI: mobiveil: Fix INTx interrupt clearing in mobiveil_pcie_isr()
      PCI: mobiveil: Fix infinite-loop in the INTx handling function
      PCI: mobiveil: Move PCIe PIO enablement out of inbound window routine
      PCI: mobiveil: Add upper 32-bit PCI base address setup in inbound window
      PCI: mobiveil: Add upper 32-bit CPU base address setup in outbound window
      PCI: mobiveil: Mask out hardcoded bits in inbound/outbound windows setup
      PCI: mobiveil: Clear the control fields before updating it
      PCI: mobiveil: Add configured inbound windows counter
      PCI: mobiveil: Fix the valid check for inbound and outbound windows
      PCI: mobiveil: Clean-up program_{ib/ob}_windows()
      PCI: mobiveil: Remove an unnecessary return value check
      PCI: mobiveil: Fix error return values
      PCI: mobiveil: Refactor the MEM/IO outbound window initialization
      PCI: mobiveil: Make some register updates more readable
      PCI: mobiveil: Reformat the code for readability
      dt-bindings: PCI: mobiveil: Change gpio_slave and apb_csr to optional
      ...

commit 7b4b0f6b34d893be569da81ffad865a9d3a7d014
Merge: 31d5a608b13b f6b6aefee70a
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Jul 12 17:08:41 2019 -0500

    Merge branch 'pci/trivial'
    
      - Fix typos and whitespace errors (Bjorn Helgaas)
    
    * pci/trivial:
      PCI: Fix typos and whitespace errors

commit f6b6aefee70aa5261deec7feab80c249bf58397f
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu May 30 08:05:58 2019 -0500

    PCI: Fix typos and whitespace errors
    
    Fix typos in drivers/pci.  Comment and whitespace changes only.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Randy Dunlap <rdunlap@infradead.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 8abc843b1615..3fd4eaa32b21 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -4501,7 +4501,7 @@ static int pci_af_flr(struct pci_dev *dev, int probe)
 
 	/*
 	 * Wait for Transaction Pending bit to clear.  A word-aligned test
-	 * is used, so we use the conrol offset rather than status and shift
+	 * is used, so we use the control offset rather than status and shift
 	 * the test bit to match.
 	 */
 	if (!pci_wait_for_pending(dev, pos + PCI_AF_CTRL,

commit b51033e06c2ebbad322370f4a35c84488e61b342
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Jun 25 14:09:12 2019 +0200

    PCI: PM/ACPI: Refresh all stale power state data in pci_pm_complete()
    
    In pci_pm_complete() there are checks to decide whether or not to
    resume devices that were left in runtime-suspend during the preceding
    system-wide transition into a sleep state.  They involve checking the
    current power state of the device and comparing it with the power
    state of it set before the preceding system-wide transition, but the
    platform component of the device's power state is not handled
    correctly in there.
    
    Namely, on platforms with ACPI, the device power state information
    needs to be updated with care, so that the reference counters of
    power resources used by the device (if any) are set to ensure that
    the refreshed power state of it will be maintained going forward.
    
    To that end, introduce a new ->refresh_state() platform PM callback
    for PCI devices, for asking the platform to refresh the device power
    state data and ensure that the corresponding power state will be
    maintained going forward, make it invoke acpi_device_update_power()
    (for devices with ACPI PM) on platforms with ACPI and make
    pci_pm_complete() use it, through a new pci_refresh_power_state()
    wrapper function.
    
    Fixes: a0d2a959d3da (PCI: Avoid unnecessary resume after direct-complete)
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index e34fb2b3c466..b1f563916036 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -777,6 +777,12 @@ static inline pci_power_t platform_pci_get_power_state(struct pci_dev *dev)
 	return pci_platform_pm ? pci_platform_pm->get_state(dev) : PCI_UNKNOWN;
 }
 
+static inline void platform_pci_refresh_power_state(struct pci_dev *dev)
+{
+	if (pci_platform_pm && pci_platform_pm->refresh_state)
+		pci_platform_pm->refresh_state(dev);
+}
+
 static inline pci_power_t platform_pci_choose_state(struct pci_dev *dev)
 {
 	return pci_platform_pm ?
@@ -937,6 +943,21 @@ void pci_update_current_state(struct pci_dev *dev, pci_power_t state)
 	}
 }
 
+/**
+ * pci_refresh_power_state - Refresh the given device's power state data
+ * @dev: Target PCI device.
+ *
+ * Ask the platform to refresh the devices power state information and invoke
+ * pci_update_current_state() to update its current PCI power state.
+ */
+void pci_refresh_power_state(struct pci_dev *dev)
+{
+	if (platform_pci_power_manageable(dev))
+		platform_pci_refresh_power_state(dev);
+
+	pci_update_current_state(dev, dev->current_state);
+}
+
 /**
  * pci_power_up - Put the given device into D0 forcibly
  * @dev: PCI device to power up

commit 000dd5316e1c756a1c028f22e01d06a38249dd4d
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Wed Jun 12 13:57:39 2019 +0300

    PCI: Do not poll for PME if the device is in D3cold
    
    PME polling does not take into account that a device that is directly
    connected to the host bridge may go into D3cold as well. This leads to a
    situation where the PME poll thread reads from a config space of a
    device that is in D3cold and gets incorrect information because the
    config space is not accessible.
    
    Here is an example from Intel Ice Lake system where two PCIe root ports
    are in D3cold (I've instrumented the kernel to log the PMCSR register
    contents):
    
      [   62.971442] pcieport 0000:00:07.1: Check PME status, PMCSR=0xffff
      [   62.971504] pcieport 0000:00:07.0: Check PME status, PMCSR=0xffff
    
    Since 0xffff is interpreted so that PME is pending, the root ports will
    be runtime resumed. This repeats over and over again essentially
    blocking all runtime power management.
    
    Prevent this from happening by checking whether the device is in D3cold
    before its PME status is read.
    
    Fixes: 71a83bd727cc ("PCI/PM: add runtime PM support to PCIe port")
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Reviewed-by: Lukas Wunner <lukas@wunner.de>
    Cc: 3.6+ <stable@vger.kernel.org> # v3.6+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 9839d6f9bcb5..e34fb2b3c466 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2060,6 +2060,13 @@ static void pci_pme_list_scan(struct work_struct *work)
 			 */
 			if (bridge && bridge->current_state != PCI_D0)
 				continue;
+			/*
+			 * If the device is in D3cold it should not be
+			 * polled either.
+			 */
+			if (pme_dev->dev->current_state == PCI_D3cold)
+				continue;
+
 			pci_pme_wakeup(pme_dev->dev, NULL);
 		} else {
 			list_del(&pme_dev->list);

commit c2bf1fc212f7e6f25ace1af8f0b3ac061ea48ba5
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Wed Jun 12 13:57:38 2019 +0300

    PCI: Add missing link delays required by the PCIe spec
    
    Currently Linux does not follow PCIe spec regarding the required delays
    after reset. A concrete example is a Thunderbolt add-in-card that
    consists of a PCIe switch and two PCIe endpoints:
    
      +-1b.0-[01-6b]----00.0-[02-6b]--+-00.0-[03]----00.0 TBT controller
                                      +-01.0-[04-36]-- DS hotplug port
                                      +-02.0-[37]----00.0 xHCI controller
                                      \-04.0-[38-6b]-- DS hotplug port
    
    The root port (1b.0) and the PCIe switch downstream ports are all PCIe
    gen3 so they support 8GT/s link speeds.
    
    We wait for the PCIe hierarchy to enter D3cold (runtime):
    
      pcieport 0000:00:1b.0: power state changed by ACPI to D3cold
    
    When it wakes up from D3cold, according to the PCIe 4.0 section 5.8 the
    PCIe switch is put to reset and its power is re-applied. This means that
    we must follow the rules in PCIe 4.0 section 6.6.1.
    
    For the PCIe gen3 ports we are dealing with here, the following applies:
    
      With a Downstream Port that supports Link speeds greater than 5.0
      GT/s, software must wait a minimum of 100 ms after Link training
      completes before sending a Configuration Request to the device
      immediately below that Port. Software can determine when Link training
      completes by polling the Data Link Layer Link Active bit or by setting
      up an associated interrupt (see Section 6.7.3.3).
    
    Translating this into the above topology we would need to do this (DLLLA
    stands for Data Link Layer Link Active):
    
      pcieport 0000:00:1b.0: wait for 100ms after DLLLA is set before access to 0000:01:00.0
      pcieport 0000:02:00.0: wait for 100ms after DLLLA is set before access to 0000:03:00.0
      pcieport 0000:02:02.0: wait for 100ms after DLLLA is set before access to 0000:37:00.0
    
    I've instrumented the kernel with additional logging so we can see the
    actual delays the kernel performs:
    
      pcieport 0000:00:1b.0: power state changed by ACPI to D0
      pcieport 0000:00:1b.0: waiting for D3cold delay of 100 ms
      pcieport 0000:00:1b.0: waking up bus
      pcieport 0000:00:1b.0: waiting for D3hot delay of 10 ms
      pcieport 0000:00:1b.0: restoring config space at offset 0x2c (was 0x60, writing 0x60)
      ...
      pcieport 0000:00:1b.0: PME# disabled
      pcieport 0000:01:00.0: restoring config space at offset 0x3c (was 0x1ff, writing 0x201ff)
      ...
      pcieport 0000:01:00.0: PME# disabled
      pcieport 0000:02:00.0: restoring config space at offset 0x3c (was 0x1ff, writing 0x201ff)
      ...
      pcieport 0000:02:00.0: PME# disabled
      pcieport 0000:02:01.0: restoring config space at offset 0x3c (was 0x1ff, writing 0x201ff)
      ...
      pcieport 0000:02:01.0: restoring config space at offset 0x4 (was 0x100000, writing 0x100407)
      pcieport 0000:02:01.0: PME# disabled
      pcieport 0000:02:02.0: restoring config space at offset 0x3c (was 0x1ff, writing 0x201ff)
      ...
      pcieport 0000:02:02.0: PME# disabled
      pcieport 0000:02:04.0: restoring config space at offset 0x3c (was 0x1ff, writing 0x201ff)
      ...
      pcieport 0000:02:04.0: PME# disabled
      pcieport 0000:02:01.0: PME# enabled
      pcieport 0000:02:01.0: waiting for D3hot delay of 10 ms
      pcieport 0000:02:04.0: PME# enabled
      pcieport 0000:02:04.0: waiting for D3hot delay of 10 ms
      thunderbolt 0000:03:00.0: restoring config space at offset 0x14 (was 0x0, writing 0x8a040000)
      ...
      thunderbolt 0000:03:00.0: PME# disabled
      xhci_hcd 0000:37:00.0: restoring config space at offset 0x10 (was 0x0, writing 0x73f00000)
      ...
      xhci_hcd 0000:37:00.0: PME# disabled
    
    For the switch upstream port (01:00.0) we wait for 100ms but not taking
    into account the DLLLA requirement. We then wait 10ms for D3hot -> D0
    transition of the root port and the two downstream hotplug ports. This
    means that we deviate from what the spec requires.
    
    Performing the same check for system sleep (s2idle) transitions we can
    see following when resuming from s2idle:
    
      pcieport 0000:00:1b.0: power state changed by ACPI to D0
      pcieport 0000:00:1b.0: restoring config space at offset 0x2c (was 0x60, writing 0x60)
      ...
      pcieport 0000:01:00.0: restoring config space at offset 0x3c (was 0x1ff, writing 0x201ff)
      ...
      pcieport 0000:02:02.0: restoring config space at offset 0x3c (was 0x1ff, writing 0x201ff)
      pcieport 0000:02:02.0: restoring config space at offset 0x2c (was 0x0, writing 0x0)
      pcieport 0000:02:01.0: restoring config space at offset 0x3c (was 0x1ff, writing 0x201ff)
      pcieport 0000:02:04.0: restoring config space at offset 0x3c (was 0x1ff, writing 0x201ff)
      pcieport 0000:02:02.0: restoring config space at offset 0x28 (was 0x0, writing 0x0)
      pcieport 0000:02:00.0: restoring config space at offset 0x3c (was 0x1ff, writing 0x201ff)
      pcieport 0000:02:02.0: restoring config space at offset 0x24 (was 0x10001, writing 0x1fff1)
      pcieport 0000:02:01.0: restoring config space at offset 0x2c (was 0x0, writing 0x60)
      pcieport 0000:02:02.0: restoring config space at offset 0x20 (was 0x0, writing 0x73f073f0)
      pcieport 0000:02:04.0: restoring config space at offset 0x2c (was 0x0, writing 0x60)
      pcieport 0000:02:01.0: restoring config space at offset 0x28 (was 0x0, writing 0x60)
      pcieport 0000:02:00.0: restoring config space at offset 0x2c (was 0x0, writing 0x0)
      pcieport 0000:02:02.0: restoring config space at offset 0x1c (was 0x101, writing 0x1f1)
      pcieport 0000:02:04.0: restoring config space at offset 0x28 (was 0x0, writing 0x60)
      pcieport 0000:02:01.0: restoring config space at offset 0x24 (was 0x10001, writing 0x1ff10001)
      pcieport 0000:02:00.0: restoring config space at offset 0x28 (was 0x0, writing 0x0)
      pcieport 0000:02:02.0: restoring config space at offset 0x18 (was 0x0, writing 0x373702)
      pcieport 0000:02:04.0: restoring config space at offset 0x24 (was 0x10001, writing 0x49f12001)
      pcieport 0000:02:01.0: restoring config space at offset 0x20 (was 0x0, writing 0x73e05c00)
      pcieport 0000:02:00.0: restoring config space at offset 0x24 (was 0x10001, writing 0x1fff1)
      pcieport 0000:02:04.0: restoring config space at offset 0x20 (was 0x0, writing 0x89f07400)
      pcieport 0000:02:01.0: restoring config space at offset 0x1c (was 0x101, writing 0x5151)
      pcieport 0000:02:00.0: restoring config space at offset 0x20 (was 0x0, writing 0x8a008a00)
      pcieport 0000:02:02.0: restoring config space at offset 0xc (was 0x10000, writing 0x10020)
      pcieport 0000:02:04.0: restoring config space at offset 0x1c (was 0x101, writing 0x6161)
      pcieport 0000:02:01.0: restoring config space at offset 0x18 (was 0x0, writing 0x360402)
      pcieport 0000:02:00.0: restoring config space at offset 0x1c (was 0x101, writing 0x1f1)
      pcieport 0000:02:04.0: restoring config space at offset 0x18 (was 0x0, writing 0x6b3802)
      pcieport 0000:02:02.0: restoring config space at offset 0x4 (was 0x100000, writing 0x100407)
      pcieport 0000:02:00.0: restoring config space at offset 0x18 (was 0x0, writing 0x30302)
      pcieport 0000:02:01.0: restoring config space at offset 0xc (was 0x10000, writing 0x10020)
      pcieport 0000:02:04.0: restoring config space at offset 0xc (was 0x10000, writing 0x10020)
      pcieport 0000:02:00.0: restoring config space at offset 0xc (was 0x10000, writing 0x10020)
      pcieport 0000:02:01.0: restoring config space at offset 0x4 (was 0x100000, writing 0x100407)
      pcieport 0000:02:04.0: restoring config space at offset 0x4 (was 0x100000, writing 0x100407)
      pcieport 0000:02:00.0: restoring config space at offset 0x4 (was 0x100000, writing 0x100407)
      xhci_hcd 0000:37:00.0: restoring config space at offset 0x10 (was 0x0, writing 0x73f00000)
      ...
      thunderbolt 0000:03:00.0: restoring config space at offset 0x14 (was 0x0, writing 0x8a040000)
    
    This is even worse. None of the mandatory delays are performed. If this
    would be S3 instead of s2idle then according to PCI FW spec 3.2 section
    4.6.8.  there is a specific _DSM that allows the OS to skip the delays
    but this platform does not provide the _DSM and does not go to S3 anyway
    so no firmware is involved that could already handle these delays.
    
    In this particular Intel Coffee Lake platform these delays are not
    actually needed because there is an additional delay as part of the ACPI
    power resource that is used to turn on power to the hierarchy but since
    that additional delay is not required by any of standards (PCIe, ACPI)
    it is not present in the Intel Ice Lake, for example where missing the
    mandatory delays causes pciehp to start tearing down the stack too early
    (links are not yet trained).
    
    For this reason, change the PCIe portdrv PM resume hooks so that they
    perform the mandatory delays before the downstream component gets
    resumed. We perform the delays before port services are resumed because
    otherwise pciehp might find that the link is not up (even if it is just
    training) and tears-down the hierarchy.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 24d86bd1bba1..9839d6f9bcb5 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1004,15 +1004,10 @@ static void __pci_start_power_transition(struct pci_dev *dev, pci_power_t state)
 	if (state == PCI_D0) {
 		pci_platform_power_transition(dev, PCI_D0);
 		/*
-		 * Mandatory power management transition delays, see
-		 * PCI Express Base Specification Revision 2.0 Section
-		 * 6.6.1: Conventional Reset.  Do not delay for
-		 * devices powered on/off by corresponding bridge,
-		 * because have already delayed for the bridge.
+		 * Mandatory power management transition delays are
+		 * handled in the PCIe portdrv resume hooks.
 		 */
 		if (dev->runtime_d3cold) {
-			if (dev->d3cold_delay && !dev->imm_ready)
-				msleep(dev->d3cold_delay);
 			/*
 			 * When powering on a bridge from D3cold, the
 			 * whole hierarchy may be powered on into
@@ -4579,14 +4574,16 @@ static int pci_pm_reset(struct pci_dev *dev, int probe)
 
 	return pci_dev_wait(dev, "PM D3->D0", PCIE_RESET_READY_POLL_MS);
 }
+
 /**
- * pcie_wait_for_link - Wait until link is active or inactive
+ * pcie_wait_for_link_delay - Wait until link is active or inactive
  * @pdev: Bridge device
  * @active: waiting for active or inactive?
+ * @delay: Delay to wait after link has become active (in ms)
  *
  * Use this to wait till link becomes active or inactive.
  */
-bool pcie_wait_for_link(struct pci_dev *pdev, bool active)
+bool pcie_wait_for_link_delay(struct pci_dev *pdev, bool active, int delay)
 {
 	int timeout = 1000;
 	bool ret;
@@ -4623,13 +4620,25 @@ bool pcie_wait_for_link(struct pci_dev *pdev, bool active)
 		timeout -= 10;
 	}
 	if (active && ret)
-		msleep(100);
+		msleep(delay);
 	else if (ret != active)
 		pci_info(pdev, "Data Link Layer Link Active not %s in 1000 msec\n",
 			active ? "set" : "cleared");
 	return ret == active;
 }
 
+/**
+ * pcie_wait_for_link - Wait until link is active or inactive
+ * @pdev: Bridge device
+ * @active: waiting for active or inactive?
+ *
+ * Use this to wait till link becomes active or inactive.
+ */
+bool pcie_wait_for_link(struct pci_dev *pdev, bool active)
+{
+	return pcie_wait_for_link_delay(pdev, active, 100);
+}
+
 void pci_reset_secondary_bus(struct pci_dev *dev)
 {
 	u16 ctrl;

commit 0c7376ada9508141becec9b897d73b65ce66a15a
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Jun 7 00:32:31 2019 +0200

    PCI: PM: Replace pci_dev_keep_suspended() with two functions
    
    The code in pci_dev_keep_suspended() is relatively hard to follow due
    to the negative checks in it and in its callers and the function has
    a possible side-effect (disabling the PME) which doesn't really match
    its role.
    
    For this reason, move the PME disabling from pci_dev_keep_suspended()
    to a separate function and change the semantics (and name) of the
    rest of it, so that 'true' is returned when the device needs to be
    resumed (and not the other way around).  Change the callers of
    pci_dev_keep_suspended() accordingly.
    
    While at it, make the code flow in pci_pm_poweroff() reflect the
    pci_pm_suspend() more closely to avoid arbitrary differences between
    them.
    
    This is a cosmetic change with no intention to alter behavior.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 324175509e94..24d86bd1bba1 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2459,55 +2459,56 @@ bool pci_dev_run_wake(struct pci_dev *dev)
 EXPORT_SYMBOL_GPL(pci_dev_run_wake);
 
 /**
- * pci_dev_keep_suspended - Check if the device can stay in the suspended state.
+ * pci_dev_need_resume - Check if it is necessary to resume the device.
  * @pci_dev: Device to check.
  *
- * Return 'true' if the device is runtime-suspended, it doesn't have to be
+ * Return 'true' if the device is not runtime-suspended or it has to be
  * reconfigured due to wakeup settings difference between system and runtime
- * suspend and the current power state of it is suitable for the upcoming
- * (system) transition.
- *
- * If the device is not configured for system wakeup, disable PME for it before
- * returning 'true' to prevent it from waking up the system unnecessarily.
+ * suspend, or the current power state of it is not suitable for the upcoming
+ * (system-wide) transition.
  */
-bool pci_dev_keep_suspended(struct pci_dev *pci_dev)
+bool pci_dev_need_resume(struct pci_dev *pci_dev)
 {
 	struct device *dev = &pci_dev->dev;
-	bool wakeup = device_may_wakeup(dev);
 	pci_power_t target_state;
 
 	if (!pm_runtime_suspended(dev) || platform_pci_need_resume(pci_dev))
-		return false;
+		return true;
 
-	target_state = pci_target_state(pci_dev, wakeup);
+	target_state = pci_target_state(pci_dev, device_may_wakeup(dev));
 
 	/*
 	 * If the earlier platform check has not triggered, D3cold is just power
 	 * removal on top of D3hot, so no need to resume the device in that
 	 * case.
 	 */
-	if (target_state != pci_dev->current_state &&
-	    target_state != PCI_D3cold && pci_dev->current_state != PCI_D3hot)
-		return false;
+	return target_state != pci_dev->current_state &&
+		target_state != PCI_D3cold &&
+		pci_dev->current_state != PCI_D3hot;
+}
+
+/**
+ * pci_dev_adjust_pme - Adjust PME setting for a suspended device.
+ * @pci_dev: Device to check.
+ *
+ * If the device is suspended and it is not configured for system wakeup,
+ * disable PME for it to prevent it from waking up the system unnecessarily.
+ *
+ * Note that if the device's power state is D3cold and the platform check in
+ * pci_dev_need_resume() has not triggered, the device's configuration need not
+ * be changed.
+ */
+void pci_dev_adjust_pme(struct pci_dev *pci_dev)
+{
+	struct device *dev = &pci_dev->dev;
 
-	/*
-	 * At this point the device is good to go unless it's been configured
-	 * to generate PME at the runtime suspend time, but it is not supposed
-	 * to wake up the system.  In that case, simply disable PME for it
-	 * (it will have to be re-enabled on exit from system resume).
-	 *
-	 * If the device's power state is D3cold and the platform check above
-	 * hasn't triggered, the device's configuration is suitable and we don't
-	 * need to manipulate it at all.
-	 */
 	spin_lock_irq(&dev->power.lock);
 
-	if (pm_runtime_suspended(dev) && pci_dev->current_state < PCI_D3cold &&
-	    !wakeup)
+	if (pm_runtime_suspended(dev) && !device_may_wakeup(dev) &&
+	    pci_dev->current_state < PCI_D3cold)
 		__pci_pme_active(pci_dev, false);
 
 	spin_unlock_irq(&dev->power.lock);
-	return true;
 }
 
 /**

commit 234f223d63d8f7db64a682ccf02871d40d38db52
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Jun 7 00:30:58 2019 +0200

    PCI: PM: Avoid resuming devices in D3hot during system suspend
    
    The current code resumes devices in D3hot during system suspend if
    the target power state for them is D3cold, but that is not necessary
    in general.  It only is necessary to do that if the platform firmware
    requires the device to be resumed, but that should be covered by
    the platform_pci_need_resume() check anyway, so rework
    pci_dev_keep_suspended() to avoid returning 'false' for devices
    in D3hot which need not be resumed due to platform firmware
    requirements.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 8abc843b1615..324175509e94 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2474,10 +2474,20 @@ bool pci_dev_keep_suspended(struct pci_dev *pci_dev)
 {
 	struct device *dev = &pci_dev->dev;
 	bool wakeup = device_may_wakeup(dev);
+	pci_power_t target_state;
+
+	if (!pm_runtime_suspended(dev) || platform_pci_need_resume(pci_dev))
+		return false;
 
-	if (!pm_runtime_suspended(dev)
-	    || pci_target_state(pci_dev, wakeup) != pci_dev->current_state
-	    || platform_pci_need_resume(pci_dev))
+	target_state = pci_target_state(pci_dev, wakeup);
+
+	/*
+	 * If the earlier platform check has not triggered, D3cold is just power
+	 * removal on top of D3hot, so no need to resume the device in that
+	 * case.
+	 */
+	if (target_state != pci_dev->current_state &&
+	    target_state != PCI_D3cold && pci_dev->current_state != PCI_D3hot)
 		return false;
 
 	/*

commit de76cda215d56256ffcda7ffa538b70f9fb301a7
Author: Gustavo Pimentel <Gustavo.Pimentel@synopsys.com>
Date:   Tue Jun 4 18:24:43 2019 +0200

    PCI: Decode PCIe 32 GT/s link speed
    
    PCIe r5.0, sec 7.5.3.18, defines a new 32.0 GT/s bit in the Supported Link
    Speeds Vector of Link Capabilities 2.  Decode this new speed.  This does
    not affect the speed of the link, which should be negotiated automatically
    by the hardware; it only adds decoding when showing the speed to the user.
    
    Previously, reading the speed of a link operating at this speed showed
    "Unknown speed" instead of "32.0 GT/s".
    
    Link: https://lore.kernel.org/lkml/92365e3caf0fc559f9ab14bcd053bfc92d4f661c.1559664969.git.gustavo.pimentel@synopsys.com
    Signed-off-by: Gustavo Pimentel <gustavo.pimentel@synopsys.com>
    [bhelgaas: changelog]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 8abc843b1615..4729a7c7a9d9 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -5621,7 +5621,9 @@ enum pci_bus_speed pcie_get_speed_cap(struct pci_dev *dev)
 	 */
 	pcie_capability_read_dword(dev, PCI_EXP_LNKCAP2, &lnkcap2);
 	if (lnkcap2) { /* PCIe r3.0-compliant */
-		if (lnkcap2 & PCI_EXP_LNKCAP2_SLS_16_0GB)
+		if (lnkcap2 & PCI_EXP_LNKCAP2_SLS_32_0GB)
+			return PCIE_SPEED_32_0GT;
+		else if (lnkcap2 & PCI_EXP_LNKCAP2_SLS_16_0GB)
 			return PCIE_SPEED_16_0GT;
 		else if (lnkcap2 & PCI_EXP_LNKCAP2_SLS_8_0GB)
 			return PCIE_SPEED_8_0GT;

commit 414147d99b928c574ed76e9374a5d2cb77866a29
Merge: 318222a35bfb c7a1c2bbb65e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue May 14 10:30:10 2019 -0700

    Merge tag 'pci-v5.2-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI updates from Bjorn Helgaas:
     "Enumeration changes:
    
       - Add _HPX Type 3 settings support, which gives firmware more
         influence over device configuration (Alexandru Gagniuc)
    
       - Support fixed bus numbers from bridge Enhanced Allocation
         capabilities (Subbaraya Sundeep)
    
       - Add "external-facing" DT property to identify cases where we
         require IOMMU protection against untrusted devices (Jean-Philippe
         Brucker)
    
       - Enable PCIe services for host controller drivers that use managed
         host bridge alloc (Jean-Philippe Brucker)
    
       - Log PCIe port service messages with pci_dev, not the pcie_device
         (Frederick Lawler)
    
       - Convert pciehp from pciehp_debug module parameter to generic
         dynamic debug (Frederick Lawler)
    
      Peer-to-peer DMA:
    
       - Add whitelist of Root Complexes that support peer-to-peer DMA
         between Root Ports (Christian König)
    
      Native controller drivers:
    
       - Add PCI host bridge DMA ranges for bridges that can't DMA
         everywhere, e.g., iProc (Srinath Mannam)
    
       - Add Amazon Annapurna Labs PCIe host controller driver (Jonathan
         Chocron)
    
       - Fix Tegra MSI target allocation so DMA doesn't generate unwanted
         MSIs (Vidya Sagar)
    
       - Fix of_node reference leaks (Wen Yang)
    
       - Fix Hyper-V module unload & device removal issues (Dexuan Cui)
    
       - Cleanup R-Car driver (Marek Vasut)
    
       - Cleanup Keystone driver (Kishon Vijay Abraham I)
    
       - Cleanup i.MX6 driver (Andrey Smirnov)
    
      Significant bug fixes:
    
       - Reset Lenovo ThinkPad P50 GPU so nouveau works after reboot (Lyude
         Paul)
    
       - Fix Switchtec firmware update performance issue (Wesley Sheng)
    
       - Work around Pericom switch link retraining erratum (Stefan Mätje)"
    
    * tag 'pci-v5.2-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (141 commits)
      MAINTAINERS: Add Karthikeyan Mitran and Hou Zhiqiang for Mobiveil PCI
      PCI: pciehp: Remove pointless MY_NAME definition
      PCI: pciehp: Remove pointless PCIE_MODULE_NAME definition
      PCI: pciehp: Remove unused dbg/err/info/warn() wrappers
      PCI: pciehp: Log messages with pci_dev, not pcie_device
      PCI: pciehp: Replace pciehp_debug module param with dyndbg
      PCI: pciehp: Remove pciehp_debug uses
      PCI/AER: Log messages with pci_dev, not pcie_device
      PCI/DPC: Log messages with pci_dev, not pcie_device
      PCI/PME: Replace dev_printk(KERN_DEBUG) with dev_info()
      PCI/AER: Replace dev_printk(KERN_DEBUG) with dev_info()
      PCI: Replace dev_printk(KERN_DEBUG) with dev_info(), etc
      PCI: Replace printk(KERN_INFO) with pr_info(), etc
      PCI: Use dev_printk() when possible
      PCI: Cleanup setup-bus.c comments and whitespace
      PCI: imx6: Allow asynchronous probing
      PCI: dwc: Save root bus for driver remove hooks
      PCI: dwc: Use devm_pci_alloc_host_bridge() to simplify code
      PCI: dwc: Free MSI in dw_pcie_host_init() error path
      PCI: dwc: Free MSI IRQ page in dw_pcie_free_msi()
      ...

commit c7a1c2bbb65e25551d585fba0fd36a01e0a22690
Merge: f8587c80c62a 0d6076184aec
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon May 13 18:34:48 2019 -0500

    Merge branch 'pci/trivial'
    
      - Cleanup PCI register definitions, typos, etc (Bjorn Helgaas)
    
      - Remove unnecessary use of user-space types in CPER (Bjorn Helgaas)
    
      - Cleanup setup-bus.c comments & whitespace (Nicholas Johnson)
    
    * pci/trivial:
      PCI: Cleanup setup-bus.c comments and whitespace
      CPER: Remove unnecessary use of user-space types
      CPER: Add UEFI spec references
      PCI: Fix comment typos
      PCI: Cleanup register definition width and whitespace
    
    # Conflicts:
    #       drivers/pci/pci.c
    #       drivers/pci/setup-bus.c

commit 192415f4986028db53fb76ebcefecf0d73cb900a
Merge: f2e946831625 34c6b7105e5a
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon May 13 18:34:46 2019 -0500

    Merge branch 'pci/printk'
    
    * pci/printk:
      PCI: Replace dev_printk(KERN_DEBUG) with dev_info(), etc
      PCI: Replace printk(KERN_INFO) with pr_info(), etc
      PCI: Use dev_printk() when possible

commit 34c6b7105e5a11174f856483cde8ad6e61b7236a
Author: Mohan Kumar <mohankumar718@gmail.com>
Date:   Sat Apr 20 07:07:20 2019 +0300

    PCI: Replace dev_printk(KERN_DEBUG) with dev_info(), etc
    
    Replace dev_printk(KERN_DEBUG) with dev_info(), etc to be more consistent
    with other logging and avoid checkpatch warnings.
    
    The KERN_DEBUG messages could be converted to dev_dbg(), but that depends
    on CONFIG_DYNAMIC_DEBUG and DEBUG, and we want most of these messages to
    *always* be in the dmesg log.
    
    Link: https://lore.kernel.org/lkml/1555733240-19875-1-git-send-email-mohankumar718@gmail.com
    Signed-off-by: Mohan Kumar <mohankumar718@gmail.com>
    [bhelgaas: commit log]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 225145ba4cf3..2d6d857a3d67 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2777,14 +2777,14 @@ void pci_pm_init(struct pci_dev *dev)
 			dev->d2_support = true;
 
 		if (dev->d1_support || dev->d2_support)
-			pci_printk(KERN_DEBUG, dev, "supports%s%s\n",
+			pci_info(dev, "supports%s%s\n",
 				   dev->d1_support ? " D1" : "",
 				   dev->d2_support ? " D2" : "");
 	}
 
 	pmc &= PCI_PM_CAP_PME_MASK;
 	if (pmc) {
-		pci_printk(KERN_DEBUG, dev, "PME# supported from%s%s%s%s%s\n",
+		pci_info(dev, "PME# supported from%s%s%s%s%s\n",
 			 (pmc & PCI_PM_CAP_PME_D0) ? " D0" : "",
 			 (pmc & PCI_PM_CAP_PME_D1) ? " D1" : "",
 			 (pmc & PCI_PM_CAP_PME_D2) ? " D2" : "",
@@ -2952,16 +2952,16 @@ static int pci_ea_read(struct pci_dev *dev, int offset)
 	res->flags = flags;
 
 	if (bei <= PCI_EA_BEI_BAR5)
-		pci_printk(KERN_DEBUG, dev, "BAR %d: %pR (from Enhanced Allocation, properties %#02x)\n",
+		pci_info(dev, "BAR %d: %pR (from Enhanced Allocation, properties %#02x)\n",
 			   bei, res, prop);
 	else if (bei == PCI_EA_BEI_ROM)
-		pci_printk(KERN_DEBUG, dev, "ROM: %pR (from Enhanced Allocation, properties %#02x)\n",
+		pci_info(dev, "ROM: %pR (from Enhanced Allocation, properties %#02x)\n",
 			   res, prop);
 	else if (bei >= PCI_EA_BEI_VF_BAR0 && bei <= PCI_EA_BEI_VF_BAR5)
-		pci_printk(KERN_DEBUG, dev, "VF BAR %d: %pR (from Enhanced Allocation, properties %#02x)\n",
+		pci_info(dev, "VF BAR %d: %pR (from Enhanced Allocation, properties %#02x)\n",
 			   bei - PCI_EA_BEI_VF_BAR0, res, prop);
 	else
-		pci_printk(KERN_DEBUG, dev, "BEI %d res: %pR (from Enhanced Allocation, properties %#02x)\n",
+		pci_info(dev, "BEI %d res: %pR (from Enhanced Allocation, properties %#02x)\n",
 			   bei, res, prop);
 
 out:
@@ -4185,7 +4185,7 @@ int pci_set_cacheline_size(struct pci_dev *dev)
 	if (cacheline_size == pci_cache_line_size)
 		return 0;
 
-	pci_printk(KERN_DEBUG, dev, "cache line size of %d is not supported\n",
+	pci_info(dev, "cache line size of %d is not supported\n",
 		   pci_cache_line_size << 2);
 
 	return -EINVAL;

commit 25da8dbaaf0679b3b22c783952a8392071cfa135
Author: Mohan Kumar <mohankumar718@gmail.com>
Date:   Sat Apr 20 07:03:46 2019 +0300

    PCI: Replace printk(KERN_INFO) with pr_info(), etc
    
    Replace printk() with pr_*() to be more consistent with other logging and
    avoid checkpatch warnings.
    
    Link: https://lore.kernel.org/lkml/1555733026-19609-1-git-send-email-mohankumar718@gmail.com
    Link: https://lore.kernel.org/lkml/1555733130-19804-1-git-send-email-mohankumar718@gmail.com
    Signed-off-by: Mohan Kumar <mohankumar718@gmail.com>
    [bhelgaas: squash in similar changes from second patch in series]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 7c1b362f599a..225145ba4cf3 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -6265,8 +6265,7 @@ static int __init pci_setup(char *str)
 				disable_acs_redir_param =
 					kstrdup(str + 18, GFP_KERNEL);
 			} else {
-				printk(KERN_ERR "PCI: Unknown option `%s'\n",
-						str);
+				pr_err("PCI: Unknown option `%s'\n", str);
 			}
 		}
 		str = k;

commit 804ee5be633f051f85270ae3f4770a5fc6cd92d5
Author: Johannes Thumshirn <jthumshirn@suse.de>
Date:   Wed Apr 17 10:23:56 2019 +0200

    PCI: Remove unused pci_request_region_exclusive()
    
    pci_request_region_exclusive() was introduced with commit e8de1481fd71
    ("resource: allow MMIO exclusivity for device drivers") in 2.6.29 which
    was released 2008.
    
    It never had an in tree user since then, so after 11 years later let's
    remove it.
    
    Signed-off-by: Johannes Thumshirn <jthumshirn@suse.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 7c1b362f599a..d185b49e105a 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -3706,31 +3706,6 @@ int pci_request_region(struct pci_dev *pdev, int bar, const char *res_name)
 }
 EXPORT_SYMBOL(pci_request_region);
 
-/**
- *	pci_request_region_exclusive - Reserved PCI I/O and memory resource
- *	@pdev: PCI device whose resources are to be reserved
- *	@bar: BAR to be reserved
- *	@res_name: Name to be associated with resource.
- *
- *	Mark the PCI region associated with PCI device @pdev BR @bar as
- *	being reserved by owner @res_name.  Do not access any
- *	address inside the PCI regions unless this call returns
- *	successfully.
- *
- *	Returns 0 on success, or %EBUSY on error.  A warning
- *	message is also printed on failure.
- *
- *	The key difference that _exclusive makes it that userspace is
- *	explicitly not allowed to map the resource via /dev/mem or
- *	sysfs.
- */
-int pci_request_region_exclusive(struct pci_dev *pdev, int bar,
-				 const char *res_name)
-{
-	return __pci_request_region(pdev, bar, res_name, IORESOURCE_EXCLUSIVE);
-}
-EXPORT_SYMBOL(pci_request_region_exclusive);
-
 /**
  * pci_release_selected_regions - Release selected PCI I/O and memory resources
  * @pdev: PCI device whose resources were previously reserved

commit 74356addc0b32e891327bcb1e36d7f798f7b1c7d
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Jan 9 14:14:42 2019 -0600

    PCI: Fix comment typos
    
    Fix spelling errors and format function comments consistently.  Changes
    whitespace and comments only; no functional change intended.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Mukesh Ojha <mojha@codeaurora.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 7c1b362f599a..530eec3191e7 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -197,8 +197,8 @@ EXPORT_SYMBOL_GPL(pci_ioremap_wc_bar);
 
 /**
  * pci_dev_str_match_path - test if a path string matches a device
- * @dev:    the PCI device to test
- * @path:   string to match the device against
+ * @dev: the PCI device to test
+ * @path: string to match the device against
  * @endptr: pointer to the string after the match
  *
  * Test if a string (typically from a kernel parameter) formatted as a
@@ -280,8 +280,8 @@ static int pci_dev_str_match_path(struct pci_dev *dev, const char *path,
 
 /**
  * pci_dev_str_match - test if a string matches a device
- * @dev:    the PCI device to test
- * @p:      string to match the device against
+ * @dev: the PCI device to test
+ * @p: string to match the device against
  * @endptr: pointer to the string after the match
  *
  * Test if a string (typically from a kernel parameter) matches a specified
@@ -341,7 +341,7 @@ static int pci_dev_str_match(struct pci_dev *dev, const char *p,
 	} else {
 		/*
 		 * PCI Bus, Device, Function IDs are specified
-		 *  (optionally, may include a path of devfns following it)
+		 * (optionally, may include a path of devfns following it)
 		 */
 		ret = pci_dev_str_match_path(dev, p, &p);
 		if (ret < 0)
@@ -425,7 +425,7 @@ static int __pci_bus_find_cap_start(struct pci_bus *bus,
  * Tell if a device supports a given PCI capability.
  * Returns the address of the requested capability structure within the
  * device's PCI configuration space or 0 in case the device does not
- * support it.  Possible values for @cap:
+ * support it.  Possible values for @cap include:
  *
  *  %PCI_CAP_ID_PM           Power Management
  *  %PCI_CAP_ID_AGP          Accelerated Graphics Port
@@ -450,11 +450,11 @@ EXPORT_SYMBOL(pci_find_capability);
 
 /**
  * pci_bus_find_capability - query for devices' capabilities
- * @bus:   the PCI bus to query
+ * @bus: the PCI bus to query
  * @devfn: PCI device to query
- * @cap:   capability code
+ * @cap: capability code
  *
- * Like pci_find_capability() but works for pci devices that do not have a
+ * Like pci_find_capability() but works for PCI devices that do not have a
  * pci_dev structure set up yet.
  *
  * Returns the address of the requested capability structure within the
@@ -535,7 +535,7 @@ EXPORT_SYMBOL_GPL(pci_find_next_ext_capability);
  *
  * Returns the address of the requested extended capability structure
  * within the device's PCI configuration space or 0 if the device does
- * not support it.  Possible values for @cap:
+ * not support it.  Possible values for @cap include:
  *
  *  %PCI_EXT_CAP_ID_ERR		Advanced Error Reporting
  *  %PCI_EXT_CAP_ID_VC		Virtual Channel
@@ -618,12 +618,13 @@ int pci_find_ht_capability(struct pci_dev *dev, int ht_cap)
 EXPORT_SYMBOL_GPL(pci_find_ht_capability);
 
 /**
- * pci_find_parent_resource - return resource region of parent bus of given region
+ * pci_find_parent_resource - return resource region of parent bus of given
+ *			      region
  * @dev: PCI device structure contains resources to be searched
  * @res: child resource record for which parent is sought
  *
- *  For given resource region of given device, return the resource
- *  region of parent bus the given region is contained in.
+ * For given resource region of given device, return the resource region of
+ * parent bus the given region is contained in.
  */
 struct resource *pci_find_parent_resource(const struct pci_dev *dev,
 					  struct resource *res)
@@ -800,7 +801,7 @@ static inline bool platform_pci_bridge_d3(struct pci_dev *dev)
 
 /**
  * pci_raw_set_power_state - Use PCI PM registers to set the power state of
- *                           given PCI device
+ *			     given PCI device
  * @dev: PCI device to handle.
  * @state: PCI power state (D0, D1, D2, D3hot) to put the device into.
  *
@@ -826,7 +827,8 @@ static int pci_raw_set_power_state(struct pci_dev *dev, pci_power_t state)
 	if (state < PCI_D0 || state > PCI_D3hot)
 		return -EINVAL;
 
-	/* Validate current state:
+	/*
+	 * Validate current state:
 	 * Can enter D0 from any state, but if we can only go deeper
 	 * to sleep if we're already in a low power state
 	 */
@@ -837,14 +839,15 @@ static int pci_raw_set_power_state(struct pci_dev *dev, pci_power_t state)
 		return -EINVAL;
 	}
 
-	/* check if this device supports the desired state */
+	/* Check if this device supports the desired state */
 	if ((state == PCI_D1 && !dev->d1_support)
 	   || (state == PCI_D2 && !dev->d2_support))
 		return -EIO;
 
 	pci_read_config_word(dev, dev->pm_cap + PCI_PM_CTRL, &pmcsr);
 
-	/* If we're (effectively) in D3, force entire word to 0.
+	/*
+	 * If we're (effectively) in D3, force entire word to 0.
 	 * This doesn't affect PME_Status, disables PME_En, and
 	 * sets PowerState to 0.
 	 */
@@ -867,11 +870,13 @@ static int pci_raw_set_power_state(struct pci_dev *dev, pci_power_t state)
 		break;
 	}
 
-	/* enter specified state */
+	/* Enter specified state */
 	pci_write_config_word(dev, dev->pm_cap + PCI_PM_CTRL, pmcsr);
 
-	/* Mandatory power management transition delays */
-	/* see PCI PM 1.1 5.6.1 table 18 */
+	/*
+	 * Mandatory power management transition delays; see PCI PM 1.1
+	 * 5.6.1 table 18
+	 */
 	if (state == PCI_D3hot || dev->current_state == PCI_D3hot)
 		pci_dev_d3_sleep(dev);
 	else if (state == PCI_D2 || dev->current_state == PCI_D2)
@@ -1085,16 +1090,18 @@ int pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 {
 	int error;
 
-	/* bound the state we're entering */
+	/* Bound the state we're entering */
 	if (state > PCI_D3cold)
 		state = PCI_D3cold;
 	else if (state < PCI_D0)
 		state = PCI_D0;
 	else if ((state == PCI_D1 || state == PCI_D2) && pci_no_d1d2(dev))
+
 		/*
-		 * If the device or the parent bridge do not support PCI PM,
-		 * ignore the request if we're doing anything other than putting
-		 * it into D0 (which would only happen on boot).
+		 * If the device or the parent bridge do not support PCI
+		 * PM, ignore the request if we're doing anything other
+		 * than putting it into D0 (which would only happen on
+		 * boot).
 		 */
 		return 0;
 
@@ -1104,8 +1111,10 @@ int pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 
 	__pci_start_power_transition(dev, state);
 
-	/* This device is quirked not to be put into D3, so
-	   don't put it in D3 */
+	/*
+	 * This device is quirked not to be put into D3, so don't put it in
+	 * D3
+	 */
 	if (state >= PCI_D3hot && (dev->dev_flags & PCI_DEV_FLAGS_NO_D3))
 		return 0;
 
@@ -1127,12 +1136,11 @@ EXPORT_SYMBOL(pci_set_power_state);
  * pci_choose_state - Choose the power state of a PCI device
  * @dev: PCI device to be suspended
  * @state: target sleep state for the whole system. This is the value
- *	that is passed to suspend() function.
+ *	   that is passed to suspend() function.
  *
  * Returns PCI power state suitable for given device and given system
  * message.
  */
-
 pci_power_t pci_choose_state(struct pci_dev *dev, pm_message_t state)
 {
 	pci_power_t ret;
@@ -1310,8 +1318,9 @@ static void pci_restore_ltr_state(struct pci_dev *dev)
 }
 
 /**
- * pci_save_state - save the PCI configuration space of a device before suspending
- * @dev: - PCI device that we're dealing with
+ * pci_save_state - save the PCI configuration space of a device before
+ *		    suspending
+ * @dev: PCI device that we're dealing with
  */
 int pci_save_state(struct pci_dev *dev)
 {
@@ -1422,7 +1431,7 @@ static void pci_restore_rebar_state(struct pci_dev *pdev)
 
 /**
  * pci_restore_state - Restore the saved state of a PCI device
- * @dev: - PCI device that we're dealing with
+ * @dev: PCI device that we're dealing with
  */
 void pci_restore_state(struct pci_dev *dev)
 {
@@ -1599,8 +1608,8 @@ static int do_pci_enable_device(struct pci_dev *dev, int bars)
  * pci_reenable_device - Resume abandoned device
  * @dev: PCI device to be resumed
  *
- *  Note this function is a backend of pci_default_resume and is not supposed
- *  to be called by normal code, write proper resume handler and use it instead.
+ * NOTE: This function is a backend of pci_default_resume() and is not supposed
+ * to be called by normal code, write proper resume handler and use it instead.
  */
 int pci_reenable_device(struct pci_dev *dev)
 {
@@ -1675,9 +1684,9 @@ static int pci_enable_device_flags(struct pci_dev *dev, unsigned long flags)
  * pci_enable_device_io - Initialize a device for use with IO space
  * @dev: PCI device to be initialized
  *
- *  Initialize device before it's used by a driver. Ask low-level code
- *  to enable I/O resources. Wake up the device if it was suspended.
- *  Beware, this function can fail.
+ * Initialize device before it's used by a driver. Ask low-level code
+ * to enable I/O resources. Wake up the device if it was suspended.
+ * Beware, this function can fail.
  */
 int pci_enable_device_io(struct pci_dev *dev)
 {
@@ -1689,9 +1698,9 @@ EXPORT_SYMBOL(pci_enable_device_io);
  * pci_enable_device_mem - Initialize a device for use with Memory space
  * @dev: PCI device to be initialized
  *
- *  Initialize device before it's used by a driver. Ask low-level code
- *  to enable Memory resources. Wake up the device if it was suspended.
- *  Beware, this function can fail.
+ * Initialize device before it's used by a driver. Ask low-level code
+ * to enable Memory resources. Wake up the device if it was suspended.
+ * Beware, this function can fail.
  */
 int pci_enable_device_mem(struct pci_dev *dev)
 {
@@ -1703,12 +1712,12 @@ EXPORT_SYMBOL(pci_enable_device_mem);
  * pci_enable_device - Initialize device before it's used by a driver.
  * @dev: PCI device to be initialized
  *
- *  Initialize device before it's used by a driver. Ask low-level code
- *  to enable I/O and memory. Wake up the device if it was suspended.
- *  Beware, this function can fail.
+ * Initialize device before it's used by a driver. Ask low-level code
+ * to enable I/O and memory. Wake up the device if it was suspended.
+ * Beware, this function can fail.
  *
- *  Note we don't actually enable the device many times if we call
- *  this function repeatedly (we just increment the count).
+ * Note we don't actually enable the device many times if we call
+ * this function repeatedly (we just increment the count).
  */
 int pci_enable_device(struct pci_dev *dev)
 {
@@ -1717,8 +1726,8 @@ int pci_enable_device(struct pci_dev *dev)
 EXPORT_SYMBOL(pci_enable_device);
 
 /*
- * Managed PCI resources.  This manages device on/off, intx/msi/msix
- * on/off and BAR regions.  pci_dev itself records msi/msix status, so
+ * Managed PCI resources.  This manages device on/off, INTx/MSI/MSI-X
+ * on/off and BAR regions.  pci_dev itself records MSI/MSI-X status, so
  * there's no need to track it separately.  pci_devres is initialized
  * when a device is enabled using managed PCI device enable interface.
  */
@@ -1836,7 +1845,8 @@ int __weak pcibios_add_device(struct pci_dev *dev)
 }
 
 /**
- * pcibios_release_device - provide arch specific hooks when releasing device dev
+ * pcibios_release_device - provide arch specific hooks when releasing
+ *			    device dev
  * @dev: the PCI device being released
  *
  * Permits the platform to provide architecture specific functionality when
@@ -1927,8 +1937,7 @@ EXPORT_SYMBOL(pci_disable_device);
  * @dev: the PCIe device reset
  * @state: Reset state to enter into
  *
- *
- * Sets the PCIe reset state for the device. This is the default
+ * Set the PCIe reset state for the device. This is the default
  * implementation. Architecture implementations can override this.
  */
 int __weak pcibios_set_pcie_reset_state(struct pci_dev *dev,
@@ -1942,7 +1951,6 @@ int __weak pcibios_set_pcie_reset_state(struct pci_dev *dev,
  * @dev: the PCIe device reset
  * @state: Reset state to enter into
  *
- *
  * Sets the PCI reset state for the device.
  */
 int pci_set_pcie_reset_state(struct pci_dev *dev, enum pcie_reset_state state)
@@ -2339,7 +2347,8 @@ static pci_power_t pci_target_state(struct pci_dev *dev, bool wakeup)
 }
 
 /**
- * pci_prepare_to_sleep - prepare PCI device for system-wide transition into a sleep state
+ * pci_prepare_to_sleep - prepare PCI device for system-wide transition
+ *			  into a sleep state
  * @dev: Device to handle.
  *
  * Choose the power state appropriate for the device depending on whether
@@ -2367,7 +2376,8 @@ int pci_prepare_to_sleep(struct pci_dev *dev)
 EXPORT_SYMBOL(pci_prepare_to_sleep);
 
 /**
- * pci_back_from_sleep - turn PCI device on during system-wide transition into working state
+ * pci_back_from_sleep - turn PCI device on during system-wide transition
+ *			 into working state
  * @dev: Device to handle.
  *
  * Disable device's system wake-up capability and put it into D0.
@@ -3005,7 +3015,7 @@ static void pci_add_saved_cap(struct pci_dev *pci_dev,
 
 /**
  * _pci_add_cap_save_buffer - allocate buffer for saving given
- *                            capability registers
+ *			      capability registers
  * @dev: the PCI device
  * @cap: the capability to allocate the buffer for
  * @extended: Standard or Extended capability ID
@@ -3186,7 +3196,7 @@ static void pci_disable_acs_redir(struct pci_dev *dev)
 }
 
 /**
- * pci_std_enable_acs - enable ACS on devices using standard ACS capabilites
+ * pci_std_enable_acs - enable ACS on devices using standard ACS capabilities
  * @dev: the PCI device
  */
 static void pci_std_enable_acs(struct pci_dev *dev)
@@ -3609,13 +3619,14 @@ u8 pci_common_swizzle(struct pci_dev *dev, u8 *pinp)
 EXPORT_SYMBOL_GPL(pci_common_swizzle);
 
 /**
- *	pci_release_region - Release a PCI bar
- *	@pdev: PCI device whose resources were previously reserved by pci_request_region
- *	@bar: BAR to release
+ * pci_release_region - Release a PCI bar
+ * @pdev: PCI device whose resources were previously reserved by
+ *	  pci_request_region()
+ * @bar: BAR to release
  *
- *	Releases the PCI I/O and memory resources previously reserved by a
- *	successful call to pci_request_region.  Call this function only
- *	after all use of the PCI regions has ceased.
+ * Releases the PCI I/O and memory resources previously reserved by a
+ * successful call to pci_request_region().  Call this function only
+ * after all use of the PCI regions has ceased.
  */
 void pci_release_region(struct pci_dev *pdev, int bar)
 {
@@ -3637,23 +3648,23 @@ void pci_release_region(struct pci_dev *pdev, int bar)
 EXPORT_SYMBOL(pci_release_region);
 
 /**
- *	__pci_request_region - Reserved PCI I/O and memory resource
- *	@pdev: PCI device whose resources are to be reserved
- *	@bar: BAR to be reserved
- *	@res_name: Name to be associated with resource.
- *	@exclusive: whether the region access is exclusive or not
+ * __pci_request_region - Reserved PCI I/O and memory resource
+ * @pdev: PCI device whose resources are to be reserved
+ * @bar: BAR to be reserved
+ * @res_name: Name to be associated with resource.
+ * @exclusive: whether the region access is exclusive or not
  *
- *	Mark the PCI region associated with PCI device @pdev BR @bar as
- *	being reserved by owner @res_name.  Do not access any
- *	address inside the PCI regions unless this call returns
- *	successfully.
+ * Mark the PCI region associated with PCI device @pdev BAR @bar as
+ * being reserved by owner @res_name.  Do not access any
+ * address inside the PCI regions unless this call returns
+ * successfully.
  *
- *	If @exclusive is set, then the region is marked so that userspace
- *	is explicitly not allowed to map the resource via /dev/mem or
- *	sysfs MMIO access.
+ * If @exclusive is set, then the region is marked so that userspace
+ * is explicitly not allowed to map the resource via /dev/mem or
+ * sysfs MMIO access.
  *
- *	Returns 0 on success, or %EBUSY on error.  A warning
- *	message is also printed on failure.
+ * Returns 0 on success, or %EBUSY on error.  A warning
+ * message is also printed on failure.
  */
 static int __pci_request_region(struct pci_dev *pdev, int bar,
 				const char *res_name, int exclusive)
@@ -3687,18 +3698,18 @@ static int __pci_request_region(struct pci_dev *pdev, int bar,
 }
 
 /**
- *	pci_request_region - Reserve PCI I/O and memory resource
- *	@pdev: PCI device whose resources are to be reserved
- *	@bar: BAR to be reserved
- *	@res_name: Name to be associated with resource
+ * pci_request_region - Reserve PCI I/O and memory resource
+ * @pdev: PCI device whose resources are to be reserved
+ * @bar: BAR to be reserved
+ * @res_name: Name to be associated with resource
  *
- *	Mark the PCI region associated with PCI device @pdev BAR @bar as
- *	being reserved by owner @res_name.  Do not access any
- *	address inside the PCI regions unless this call returns
- *	successfully.
+ * Mark the PCI region associated with PCI device @pdev BAR @bar as
+ * being reserved by owner @res_name.  Do not access any
+ * address inside the PCI regions unless this call returns
+ * successfully.
  *
- *	Returns 0 on success, or %EBUSY on error.  A warning
- *	message is also printed on failure.
+ * Returns 0 on success, or %EBUSY on error.  A warning
+ * message is also printed on failure.
  */
 int pci_request_region(struct pci_dev *pdev, int bar, const char *res_name)
 {
@@ -3707,22 +3718,22 @@ int pci_request_region(struct pci_dev *pdev, int bar, const char *res_name)
 EXPORT_SYMBOL(pci_request_region);
 
 /**
- *	pci_request_region_exclusive - Reserved PCI I/O and memory resource
- *	@pdev: PCI device whose resources are to be reserved
- *	@bar: BAR to be reserved
- *	@res_name: Name to be associated with resource.
+ * pci_request_region_exclusive - Reserved PCI I/O and memory resource
+ * @pdev: PCI device whose resources are to be reserved
+ * @bar: BAR to be reserved
+ * @res_name: Name to be associated with resource.
  *
- *	Mark the PCI region associated with PCI device @pdev BR @bar as
- *	being reserved by owner @res_name.  Do not access any
- *	address inside the PCI regions unless this call returns
- *	successfully.
+ * Mark the PCI region associated with PCI device @pdev BAR @bar as
+ * being reserved by owner @res_name.  Do not access any
+ * address inside the PCI regions unless this call returns
+ * successfully.
  *
- *	Returns 0 on success, or %EBUSY on error.  A warning
- *	message is also printed on failure.
+ * Returns 0 on success, or %EBUSY on error.  A warning
+ * message is also printed on failure.
  *
- *	The key difference that _exclusive makes it that userspace is
- *	explicitly not allowed to map the resource via /dev/mem or
- *	sysfs.
+ * The key difference that _exclusive makes it that userspace is
+ * explicitly not allowed to map the resource via /dev/mem or
+ * sysfs.
  */
 int pci_request_region_exclusive(struct pci_dev *pdev, int bar,
 				 const char *res_name)
@@ -3791,12 +3802,13 @@ int pci_request_selected_regions_exclusive(struct pci_dev *pdev, int bars,
 EXPORT_SYMBOL(pci_request_selected_regions_exclusive);
 
 /**
- *	pci_release_regions - Release reserved PCI I/O and memory resources
- *	@pdev: PCI device whose resources were previously reserved by pci_request_regions
+ * pci_release_regions - Release reserved PCI I/O and memory resources
+ * @pdev: PCI device whose resources were previously reserved by
+ *	  pci_request_regions()
  *
- *	Releases all PCI I/O and memory resources previously reserved by a
- *	successful call to pci_request_regions.  Call this function only
- *	after all use of the PCI regions has ceased.
+ * Releases all PCI I/O and memory resources previously reserved by a
+ * successful call to pci_request_regions().  Call this function only
+ * after all use of the PCI regions has ceased.
  */
 
 void pci_release_regions(struct pci_dev *pdev)
@@ -3806,17 +3818,17 @@ void pci_release_regions(struct pci_dev *pdev)
 EXPORT_SYMBOL(pci_release_regions);
 
 /**
- *	pci_request_regions - Reserved PCI I/O and memory resources
- *	@pdev: PCI device whose resources are to be reserved
- *	@res_name: Name to be associated with resource.
+ * pci_request_regions - Reserve PCI I/O and memory resources
+ * @pdev: PCI device whose resources are to be reserved
+ * @res_name: Name to be associated with resource.
  *
- *	Mark all PCI regions associated with PCI device @pdev as
- *	being reserved by owner @res_name.  Do not access any
- *	address inside the PCI regions unless this call returns
- *	successfully.
+ * Mark all PCI regions associated with PCI device @pdev as
+ * being reserved by owner @res_name.  Do not access any
+ * address inside the PCI regions unless this call returns
+ * successfully.
  *
- *	Returns 0 on success, or %EBUSY on error.  A warning
- *	message is also printed on failure.
+ * Returns 0 on success, or %EBUSY on error.  A warning
+ * message is also printed on failure.
  */
 int pci_request_regions(struct pci_dev *pdev, const char *res_name)
 {
@@ -3825,20 +3837,19 @@ int pci_request_regions(struct pci_dev *pdev, const char *res_name)
 EXPORT_SYMBOL(pci_request_regions);
 
 /**
- *	pci_request_regions_exclusive - Reserved PCI I/O and memory resources
- *	@pdev: PCI device whose resources are to be reserved
- *	@res_name: Name to be associated with resource.
+ * pci_request_regions_exclusive - Reserve PCI I/O and memory resources
+ * @pdev: PCI device whose resources are to be reserved
+ * @res_name: Name to be associated with resource.
  *
- *	Mark all PCI regions associated with PCI device @pdev as
- *	being reserved by owner @res_name.  Do not access any
- *	address inside the PCI regions unless this call returns
- *	successfully.
+ * Mark all PCI regions associated with PCI device @pdev as being reserved
+ * by owner @res_name.  Do not access any address inside the PCI regions
+ * unless this call returns successfully.
  *
- *	pci_request_regions_exclusive() will mark the region so that
- *	/dev/mem and the sysfs MMIO access will not be allowed.
+ * pci_request_regions_exclusive() will mark the region so that /dev/mem
+ * and the sysfs MMIO access will not be allowed.
  *
- *	Returns 0 on success, or %EBUSY on error.  A warning
- *	message is also printed on failure.
+ * Returns 0 on success, or %EBUSY on error.  A warning message is also
+ * printed on failure.
  */
 int pci_request_regions_exclusive(struct pci_dev *pdev, const char *res_name)
 {
@@ -3849,7 +3860,7 @@ EXPORT_SYMBOL(pci_request_regions_exclusive);
 
 /*
  * Record the PCI IO range (expressed as CPU physical address + size).
- * Return a negative value if an error has occured, zero otherwise
+ * Return a negative value if an error has occurred, zero otherwise
  */
 int pci_register_io_range(struct fwnode_handle *fwnode, phys_addr_t addr,
 			resource_size_t	size)
@@ -3905,14 +3916,14 @@ unsigned long __weak pci_address_to_pio(phys_addr_t address)
 }
 
 /**
- *	pci_remap_iospace - Remap the memory mapped I/O space
- *	@res: Resource describing the I/O space
- *	@phys_addr: physical address of range to be mapped
+ * pci_remap_iospace - Remap the memory mapped I/O space
+ * @res: Resource describing the I/O space
+ * @phys_addr: physical address of range to be mapped
  *
- *	Remap the memory mapped I/O space described by the @res
- *	and the CPU physical address @phys_addr into virtual address space.
- *	Only architectures that have memory mapped IO functions defined
- *	(and the PCI_IOBASE value defined) should call this function.
+ * Remap the memory mapped I/O space described by the @res and the CPU
+ * physical address @phys_addr into virtual address space.  Only
+ * architectures that have memory mapped IO functions defined (and the
+ * PCI_IOBASE value defined) should call this function.
  */
 int pci_remap_iospace(const struct resource *res, phys_addr_t phys_addr)
 {
@@ -3928,8 +3939,10 @@ int pci_remap_iospace(const struct resource *res, phys_addr_t phys_addr)
 	return ioremap_page_range(vaddr, vaddr + resource_size(res), phys_addr,
 				  pgprot_device(PAGE_KERNEL));
 #else
-	/* this architecture does not have memory mapped I/O space,
-	   so this function should never be called */
+	/*
+	 * This architecture does not have memory mapped I/O space,
+	 * so this function should never be called
+	 */
 	WARN_ONCE(1, "This architecture does not support memory mapped I/O\n");
 	return -ENODEV;
 #endif
@@ -3937,12 +3950,12 @@ int pci_remap_iospace(const struct resource *res, phys_addr_t phys_addr)
 EXPORT_SYMBOL(pci_remap_iospace);
 
 /**
- *	pci_unmap_iospace - Unmap the memory mapped I/O space
- *	@res: resource to be unmapped
+ * pci_unmap_iospace - Unmap the memory mapped I/O space
+ * @res: resource to be unmapped
  *
- *	Unmap the CPU virtual address @res from virtual address space.
- *	Only architectures that have memory mapped IO functions defined
- *	(and the PCI_IOBASE value defined) should call this function.
+ * Unmap the CPU virtual address @res from virtual address space.  Only
+ * architectures that have memory mapped IO functions defined (and the
+ * PCI_IOBASE value defined) should call this function.
  */
 void pci_unmap_iospace(struct resource *res)
 {
@@ -4288,7 +4301,7 @@ EXPORT_SYMBOL(pci_clear_mwi);
  * @pdev: the PCI device to operate on
  * @enable: boolean: whether to enable or disable PCI INTx
  *
- * Enables/disables PCI INTx for device dev
+ * Enables/disables PCI INTx for device @pdev
  */
 void pci_intx(struct pci_dev *pdev, int enable)
 {
@@ -4364,9 +4377,8 @@ static bool pci_check_and_set_intx_mask(struct pci_dev *dev, bool mask)
  * pci_check_and_mask_intx - mask INTx on pending interrupt
  * @dev: the PCI device to operate on
  *
- * Check if the device dev has its INTx line asserted, mask it and
- * return true in that case. False is returned if no interrupt was
- * pending.
+ * Check if the device dev has its INTx line asserted, mask it and return
+ * true in that case. False is returned if no interrupt was pending.
  */
 bool pci_check_and_mask_intx(struct pci_dev *dev)
 {
@@ -4378,9 +4390,9 @@ EXPORT_SYMBOL_GPL(pci_check_and_mask_intx);
  * pci_check_and_unmask_intx - unmask INTx if no interrupt is pending
  * @dev: the PCI device to operate on
  *
- * Check if the device dev has its INTx line asserted, unmask it if not
- * and return true. False is returned and the mask remains active if
- * there was still an interrupt pending.
+ * Check if the device dev has its INTx line asserted, unmask it if not and
+ * return true. False is returned and the mask remains active if there was
+ * still an interrupt pending.
  */
 bool pci_check_and_unmask_intx(struct pci_dev *dev)
 {
@@ -4389,7 +4401,7 @@ bool pci_check_and_unmask_intx(struct pci_dev *dev)
 EXPORT_SYMBOL_GPL(pci_check_and_unmask_intx);
 
 /**
- * pci_wait_for_pending_transaction - waits for pending transaction
+ * pci_wait_for_pending_transaction - wait for pending transaction
  * @dev: the PCI device to operate on
  *
  * Return 0 if transaction is pending 1 otherwise.
@@ -4447,7 +4459,7 @@ static int pci_dev_wait(struct pci_dev *dev, char *reset_type, int timeout)
 
 /**
  * pcie_has_flr - check if a device supports function level resets
- * @dev:	device to check
+ * @dev: device to check
  *
  * Returns true if the device advertises support for PCIe function level
  * resets.
@@ -4466,7 +4478,7 @@ EXPORT_SYMBOL_GPL(pcie_has_flr);
 
 /**
  * pcie_flr - initiate a PCIe function level reset
- * @dev:	device to reset
+ * @dev: device to reset
  *
  * Initiate a function level reset on @dev.  The caller should ensure the
  * device supports FLR before calling this function, e.g. by using the
@@ -4810,6 +4822,7 @@ static void pci_dev_restore(struct pci_dev *dev)
  *
  * The device function is presumed to be unused and the caller is holding
  * the device mutex lock when this function is called.
+ *
  * Resetting the device will make the contents of PCI configuration space
  * random, so any caller of this must be prepared to reinitialise the
  * device including MSI, bus mastering, BARs, decoding IO and memory spaces,
@@ -5373,8 +5386,8 @@ EXPORT_SYMBOL_GPL(pci_reset_bus);
  * pcix_get_max_mmrbc - get PCI-X maximum designed memory read byte count
  * @dev: PCI device to query
  *
- * Returns mmrbc: maximum designed memory read count in bytes
- *    or appropriate error value.
+ * Returns mmrbc: maximum designed memory read count in bytes or
+ * appropriate error value.
  */
 int pcix_get_max_mmrbc(struct pci_dev *dev)
 {
@@ -5396,8 +5409,8 @@ EXPORT_SYMBOL(pcix_get_max_mmrbc);
  * pcix_get_mmrbc - get PCI-X maximum memory read byte count
  * @dev: PCI device to query
  *
- * Returns mmrbc: maximum memory read count in bytes
- *    or appropriate error value.
+ * Returns mmrbc: maximum memory read count in bytes or appropriate error
+ * value.
  */
 int pcix_get_mmrbc(struct pci_dev *dev)
 {
@@ -5421,7 +5434,7 @@ EXPORT_SYMBOL(pcix_get_mmrbc);
  * @mmrbc: maximum memory read count in bytes
  *    valid values are 512, 1024, 2048, 4096
  *
- * If possible sets maximum memory read byte count, some bridges have erratas
+ * If possible sets maximum memory read byte count, some bridges have errata
  * that prevent this.
  */
 int pcix_set_mmrbc(struct pci_dev *dev, int mmrbc)
@@ -5466,8 +5479,7 @@ EXPORT_SYMBOL(pcix_set_mmrbc);
  * pcie_get_readrq - get PCI Express read request size
  * @dev: PCI device to query
  *
- * Returns maximum memory read request in bytes
- *    or appropriate error value.
+ * Returns maximum memory read request in bytes or appropriate error value.
  */
 int pcie_get_readrq(struct pci_dev *dev)
 {
@@ -5495,10 +5507,9 @@ int pcie_set_readrq(struct pci_dev *dev, int rq)
 		return -EINVAL;
 
 	/*
-	 * If using the "performance" PCIe config, we clamp the
-	 * read rq size to the max packet size to prevent the
-	 * host bridge generating requests larger than we can
-	 * cope with
+	 * If using the "performance" PCIe config, we clamp the read rq
+	 * size to the max packet size to keep the host bridge from
+	 * generating requests larger than we can cope with.
 	 */
 	if (pcie_bus_config == PCIE_BUS_PERFORMANCE) {
 		int mps = pcie_get_mps(dev);
@@ -6144,6 +6155,7 @@ static int of_pci_bus_find_domain_nr(struct device *parent)
 
 	if (parent)
 		domain = of_get_pci_domain_nr(parent->of_node);
+
 	/*
 	 * Check DT domain and use_dt_domains values.
 	 *

commit d5bc73f34cc97c4b4b9202cc93182c2515076edf
Author: Logan Gunthorpe <logang@deltatee.com>
Date:   Wed Apr 10 15:05:31 2019 -0600

    PCI: Fix issue with "pci=disable_acs_redir" parameter being ignored
    
    In most cases, kmalloc() will not be available early in boot when
    pci_setup() is called.  Thus, the kstrdup() call that was added to fix the
    __initdata bug with the disable_acs_redir parameter usually returns NULL,
    so the parameter is discarded and has no effect.
    
    To fix this, store the string that's in initdata until an initcall function
    can allocate the memory appropriately.  This way we don't need any
    additional static memory.
    
    Fixes: d2fd6e81912a ("PCI: Fix __initdata issue with "pci=disable_acs_redir" parameter")
    Signed-off-by: Logan Gunthorpe <logang@deltatee.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 7c1b362f599a..766f5779db92 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -6262,8 +6262,7 @@ static int __init pci_setup(char *str)
 			} else if (!strncmp(str, "pcie_scan_all", 13)) {
 				pci_add_flags(PCI_SCAN_ALL_PCIE_DEVS);
 			} else if (!strncmp(str, "disable_acs_redir=", 18)) {
-				disable_acs_redir_param =
-					kstrdup(str + 18, GFP_KERNEL);
+				disable_acs_redir_param = str + 18;
 			} else {
 				printk(KERN_ERR "PCI: Unknown option `%s'\n",
 						str);
@@ -6274,3 +6273,19 @@ static int __init pci_setup(char *str)
 	return 0;
 }
 early_param("pci", pci_setup);
+
+/*
+ * 'disable_acs_redir_param' is initialized in pci_setup(), above, to point
+ * to data in the __initdata section which will be freed after the init
+ * sequence is complete. We can't allocate memory in pci_setup() because some
+ * architectures do not have any memory allocation service available during
+ * an early_param() call. So we allocate memory and copy the variable here
+ * before the init section is freed.
+ */
+static int __init pci_realloc_setup_params(void)
+{
+	disable_acs_redir_param = kstrdup(disable_acs_redir_param, GFP_KERNEL);
+
+	return 0;
+}
+pure_initcall(pci_realloc_setup_params);

commit 2901752c14b8e1b7dd898d2e5245c93e531aa624
Merge: 96a6de1a541c dd92b6677e3d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Mar 9 14:57:08 2019 -0800

    Merge tag 'pci-v5.1-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI updates from Bjorn Helgaas:
    
     - Use match_string() instead of reimplementing it (Andy Shevchenko)
    
     - Enable SERR# forwarding for all bridges (Bharat Kumar Gogada)
    
     - Use Latency Tolerance Reporting if already enabled by platform (Bjorn
       Helgaas)
    
     - Save/restore LTR info for suspend/resume (Bjorn Helgaas)
    
     - Fix DPC use of uninitialized data (Dongdong Liu)
    
     - Probe bridge window attributes only once at enumeration-time to fix
       device accesses during rescan (Bjorn Helgaas)
    
     - Return BAR size (not "size -1 ") from pci_size() to simplify code (Du
       Changbin)
    
     - Use config header type (not class code) identify bridges more
       reliably (Honghui Zhang)
    
     - Work around Intel Denverton incorrect Trace Hub BAR size reporting
       (Alexander Shishkin)
    
     - Reorder pciehp cached state/hardware state updates to avoid missed
       interrupts (Mika Westerberg)
    
     - Turn ibmphp semaphores into completions or mutexes (Arnd Bergmann)
    
     - Mark expected switch fall-through (Mathieu Malaterre)
    
     - Use of_node_name_eq() for node name comparisons (Rob Herring)
    
     - Add ACS and pciehp quirks for HXT SD4800 (Shunyong Yang)
    
     - Consolidate Rohm Vendor ID definitions (Andy Shevchenko)
    
     - Use u32 (not __u32) for things not exposed to userspace (Logan
       Gunthorpe)
    
     - Fix locking semantics of bus and slot reset interfaces (Alex
       Williamson)
    
     - Update PCIEPORTBUS Kconfig help text (Hou Zhiqiang)
    
     - Allow portdrv to claim subtractive decode Ports so PCIe services will
       work for them (Honghui Zhang)
    
     - Report PCIe links that become degraded at run-time (Alexandru
       Gagniuc)
    
     - Blacklist Gigabyte X299 Root Port power management to fix Thunderbolt
       hotplug (Mika Westerberg)
    
     - Revert runtime PM suspend/resume callbacks that broke PME on network
       cable plug (Mika Westerberg)
    
     - Disable Data Link State Changed interrupts to prevent wakeup
       immediately after suspend (Mika Westerberg)
    
     - Extend altera to support Stratix 10 (Ley Foon Tan)
    
     - Allow building altera driver on ARM64 (Ley Foon Tan)
    
     - Replace Douglas with Tom Joseph as Cadence PCI host/endpoint
       maintainer (Lorenzo Pieralisi)
    
     - Add DT support for R-Car RZ/G2E (R8A774C0) (Fabrizio Castro)
    
     - Add dra72x/dra74x/dra76x SoC compatible strings (Kishon Vijay Abraham I)
    
     - Enable x2 mode support for dra72x/dra74x/dra76x SoC (Kishon Vijay
       Abraham I)
    
     - Configure dra7xx PHY to PCIe mode (Kishon Vijay Abraham I)
    
     - Simplify dwc (remove unnecessary header includes, name variables
       consistently, reduce inverted logic, etc) (Gustavo Pimentel)
    
     - Add i.MX8MQ support (Andrey Smirnov)
    
     - Add message to help debug dwc MSI-X mask bit errors (Gustavo
       Pimentel)
    
     - Work around imx7d PCIe PLL erratum (Trent Piepho)
    
     - Don't assert qcom reset GPIO during probe (Bjorn Andersson)
    
     - Skip dwc MSI init if MSIs have been disabled (Lucas Stach)
    
     - Use memcpy_fromio()/memcpy_toio() instead of plain memcpy() in PCI
       endpoint framework (Wen Yang)
    
     - Add interface to discover supported endpoint features to replace a
       bitfield that wasn't flexible enough (Kishon Vijay Abraham I)
    
     - Implement the new supported-feature interface for designware-plat,
       dra7xx, rockchip, cadence (Kishon Vijay Abraham I)
    
     - Fix issues with 64-bit BAR in endpoints (Kishon Vijay Abraham I)
    
     - Add layerscape endpoint mode support (Xiaowei Bao)
    
     - Remove duplicate struct hv_vp_set in favor of struct hv_vpset (Maya
       Nakamura)
    
     - Rework hv_irq_unmask() to use cpumask_to_vpset() instead of
       open-coded reimplementation (Maya Nakamura)
    
     - Align Hyper-V struct retarget_msi_interrupt arguments (Maya Nakamura)
    
     - Fix mediatek MMIO size computation to enable full size of available
       MMIO space (Honghui Zhang)
    
     - Fix mediatek DMA window size computation to allow endpoint DMA access
       to full DRAM address range (Honghui Zhang)
    
     - Fix mvebu prefetchable BAR regression caused by common bridge
       emulation that assumed all bridges had prefetchable windows (Thomas
       Petazzoni)
    
     - Make advk_pci_bridge_emul_ops static (Wei Yongjun)
    
     - Configure MPS settings for VMD root ports (Jon Derrick)
    
    * tag 'pci-v5.1-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (92 commits)
      PCI: Update PCIEPORTBUS Kconfig help text
      PCI: Fix "try" semantics of bus and slot reset
      PCI/LINK: Report degraded links via link bandwidth notification
      dt-bindings: PCI: altera: Add altr,pcie-root-port-2.0
      PCI: altera: Enable driver on ARM64
      PCI: altera: Add Stratix 10 PCIe support
      PCI/PME: Fix possible use-after-free on remove
      PCI: aardvark: Make symbol 'advk_pci_bridge_emul_ops' static
      PCI: dwc: skip MSI init if MSIs have been explicitly disabled
      PCI: hv: Refactor hv_irq_unmask() to use cpumask_to_vpset()
      PCI: hv: Replace hv_vp_set with hv_vpset
      PCI: hv: Add __aligned(8) to struct retarget_msi_interrupt
      PCI: mediatek: Enlarge PCIe2AHB window size to support 4GB DRAM
      PCI: mediatek: Fix memory mapped IO range size computation
      PCI: dwc: Remove superfluous shifting in definitions
      PCI: dwc: Make use of GENMASK/FIELD_PREP
      PCI: dwc: Make use of BIT() in constant definitions
      PCI: dwc: Share code for dw_pcie_rd/wr_other_conf()
      PCI: dwc: Make use of IS_ALIGNED()
      PCI: imx6: Add code to request/control "pcie_aux" clock for i.MX8MQ
      ...

commit 7733f69288572c5f2b1c291e033401a13abd0bb3
Merge: 9c926ec78551 7cf58b79b307
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Mar 6 15:30:15 2019 -0600

    Merge branch 'pci/pm'
    
      - Blacklist Gigabyte X299 Root Port power management to fix Thunderbolt
        hotplug (Mika Westerberg)
    
      - Revert runtime PM suspend/resume callbacks that broke PME on network
        cable plug (Mika Westerberg)
    
      - Disable Data Link State Changed interrupts to prevent wakeup
        immediately after suspend (Mika Westerberg)
    
    * pci/pm:
      PCI/PME: Fix possible use-after-free on remove
      PCI/PME: Fix hotplug/sysfs remove deadlock in pcie_pme_remove()
      PCI: pciehp: Disable Data Link Layer State Changed event on suspend
      Revert "PCI/PME: Implement runtime PM callbacks"
      PCI: Blacklist power management of Gigabyte X299 DESIGNARE EX PCIe ports

commit 6d940a71c97bb5ba60456e69d612a9a5278013e4
Merge: 58a79db48182 8f55ed3f5554
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Mar 6 15:30:13 2019 -0600

    Merge branch 'pci/misc'
    
      - Mark expected switch fall-through (Mathieu Malaterre)
    
      - Use of_node_name_eq() for node name comparisons (Rob Herring)
    
      - Add ACS and pciehp quirks for HXT SD4800 (Shunyong Yang)
    
      - Consolidate Rohm Vendor ID definitions (Andy Shevchenko)
    
      - Use u32 (not __u32) for things not exposed to userspace (Logan
        Gunthorpe)
    
      - Fix locking semantics of bus and slot reset interfaces (Alex
        Williamson)
    
      - Update PCIEPORTBUS Kconfig help text (Hou Zhiqiang)
    
    * pci/misc:
      PCI: Update PCIEPORTBUS Kconfig help text
      PCI: Fix "try" semantics of bus and slot reset
      PCI: Clean up usage of __u32 type
      genirq/msi: Clean up usage of __u8/__u16 types
      PCI: Move Rohm Vendor ID to generic list
      PCI: pciehp: Add HXT quirk for Command Completed errata
      PCI: Add ACS quirk for HXT SD4800
      PCI: Add HXT vendor ID
      PCI: Use of_node_name_eq() for node name comparisons
      PCI: Mark expected switch fall-through

commit 5d130e3dd8b6995e93aeb7a740709a46e7acf5df
Merge: 1bd2e9ee5c0d 2e095ce7b6ec
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Mar 6 15:30:11 2019 -0600

    Merge branch 'pci/enumeration'
    
      - Probe bridge window attributes only once at enumeration-time to fix
        device accesses during rescan (Bjorn Helgaas)
    
      - Return BAR size (not "size -1 ") from pci_size() to simplify code (Du
        Changbin)
    
      - Use config header type (not class code) identify bridges more reliably
        (Honghui Zhang)
    
      - Work around Intel Denverton incorrect Trace Hub BAR size reporting
        (Alexander Shishkin)
    
    * pci/enumeration:
      x86/PCI: Fixup RTIT_BAR of Intel Denverton Trace Hub
      PCI: Rely on config space header type, not class code
      PCI: Make pci_size() return real BAR size
      PCI: Probe bridge window attributes once at enumeration-time

commit ddefc033eecf23f1e8b81d0663c5db965adf5516
Author: Alex Williamson <alex.williamson@redhat.com>
Date:   Mon Feb 18 12:46:46 2019 -0700

    PCI: Fix "try" semantics of bus and slot reset
    
    The commit referenced below introduced device locking around save and
    restore of state for each device during a PCI bus "try" reset, making it
    decidely non-"try" and prone to deadlock in the event that a device is
    already locked.  Restore __pci_reset_bus() and __pci_reset_slot() to their
    advertised locking semantics by pushing the save and restore functions into
    the branch where the entire tree is already locked.  Extend the helper
    function names with "_locked" and update the comment to reflect this
    calling requirement.
    
    Fixes: b014e96d1abb ("PCI: Protect pci_error_handlers->reset_notify() usage with device_lock()")
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Sinan Kaya <okaya@kernel.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 94069fc35e91..a3e8edd62a04 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -5058,39 +5058,42 @@ static int pci_slot_trylock(struct pci_slot *slot)
 	return 0;
 }
 
-/* Save and disable devices from the top of the tree down */
-static void pci_bus_save_and_disable(struct pci_bus *bus)
+/*
+ * Save and disable devices from the top of the tree down while holding
+ * the @dev mutex lock for the entire tree.
+ */
+static void pci_bus_save_and_disable_locked(struct pci_bus *bus)
 {
 	struct pci_dev *dev;
 
 	list_for_each_entry(dev, &bus->devices, bus_list) {
-		pci_dev_lock(dev);
 		pci_dev_save_and_disable(dev);
-		pci_dev_unlock(dev);
 		if (dev->subordinate)
-			pci_bus_save_and_disable(dev->subordinate);
+			pci_bus_save_and_disable_locked(dev->subordinate);
 	}
 }
 
 /*
- * Restore devices from top of the tree down - parent bridges need to be
- * restored before we can get to subordinate devices.
+ * Restore devices from top of the tree down while holding @dev mutex lock
+ * for the entire tree.  Parent bridges need to be restored before we can
+ * get to subordinate devices.
  */
-static void pci_bus_restore(struct pci_bus *bus)
+static void pci_bus_restore_locked(struct pci_bus *bus)
 {
 	struct pci_dev *dev;
 
 	list_for_each_entry(dev, &bus->devices, bus_list) {
-		pci_dev_lock(dev);
 		pci_dev_restore(dev);
-		pci_dev_unlock(dev);
 		if (dev->subordinate)
-			pci_bus_restore(dev->subordinate);
+			pci_bus_restore_locked(dev->subordinate);
 	}
 }
 
-/* Save and disable devices from the top of the tree down */
-static void pci_slot_save_and_disable(struct pci_slot *slot)
+/*
+ * Save and disable devices from the top of the tree down while holding
+ * the @dev mutex lock for the entire tree.
+ */
+static void pci_slot_save_and_disable_locked(struct pci_slot *slot)
 {
 	struct pci_dev *dev;
 
@@ -5099,26 +5102,25 @@ static void pci_slot_save_and_disable(struct pci_slot *slot)
 			continue;
 		pci_dev_save_and_disable(dev);
 		if (dev->subordinate)
-			pci_bus_save_and_disable(dev->subordinate);
+			pci_bus_save_and_disable_locked(dev->subordinate);
 	}
 }
 
 /*
- * Restore devices from top of the tree down - parent bridges need to be
- * restored before we can get to subordinate devices.
+ * Restore devices from top of the tree down while holding @dev mutex lock
+ * for the entire tree.  Parent bridges need to be restored before we can
+ * get to subordinate devices.
  */
-static void pci_slot_restore(struct pci_slot *slot)
+static void pci_slot_restore_locked(struct pci_slot *slot)
 {
 	struct pci_dev *dev;
 
 	list_for_each_entry(dev, &slot->bus->devices, bus_list) {
 		if (!dev->slot || dev->slot != slot)
 			continue;
-		pci_dev_lock(dev);
 		pci_dev_restore(dev);
-		pci_dev_unlock(dev);
 		if (dev->subordinate)
-			pci_bus_restore(dev->subordinate);
+			pci_bus_restore_locked(dev->subordinate);
 	}
 }
 
@@ -5177,17 +5179,15 @@ static int __pci_reset_slot(struct pci_slot *slot)
 	if (rc)
 		return rc;
 
-	pci_slot_save_and_disable(slot);
-
 	if (pci_slot_trylock(slot)) {
+		pci_slot_save_and_disable_locked(slot);
 		might_sleep();
 		rc = pci_reset_hotplug_slot(slot->hotplug, 0);
+		pci_slot_restore_locked(slot);
 		pci_slot_unlock(slot);
 	} else
 		rc = -EAGAIN;
 
-	pci_slot_restore(slot);
-
 	return rc;
 }
 
@@ -5273,17 +5273,15 @@ static int __pci_reset_bus(struct pci_bus *bus)
 	if (rc)
 		return rc;
 
-	pci_bus_save_and_disable(bus);
-
 	if (pci_bus_trylock(bus)) {
+		pci_bus_save_and_disable_locked(bus);
 		might_sleep();
 		rc = pci_bridge_secondary_bus_reset(bus->self);
+		pci_bus_restore_locked(bus);
 		pci_bus_unlock(bus);
 	} else
 		rc = -EAGAIN;
 
-	pci_bus_restore(bus);
-
 	return rc;
 }
 

commit dbbfadf2319005cf528b0f15f12a05d4e4644303
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Jan 9 08:22:08 2019 -0600

    PCI/ASPM: Save LTR Capability for suspend/resume
    
    Latency Tolerance Reporting (LTR) allows Endpoints and Switch Upstream
    Ports to report their latency requirements to upstream components.  If ASPM
    L1 PM substates are enabled, the LTR information helps determine when a
    Link enters L1.2 [1].
    
    Software must set the maximum latency values in the LTR Capability based on
    characteristics of the platform, then set LTR Mechanism Enable in the
    Device Control 2 register in the PCIe Capability.  The device can then use
    LTR to report its latency tolerance.
    
    If the device reports a maximum latency value of zero, that means the
    device requires the highest possible performance and the ASPM L1.2 substate
    is effectively disabled.
    
    We put devices in D3 for suspend, and we assume their internal state is
    lost.  On resume, previously we did not restore the LTR Capability, but we
    did restore the LTR Mechanism Enable bit, so devices would request the
    highest possible performance and ASPM L1.2 wouldn't be used.
    
    [1] PCIe r4.0, sec 5.5.1
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=201469
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index c9d8e3c837de..13d65991c77b 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1233,7 +1233,6 @@ static void pci_restore_pcie_state(struct pci_dev *dev)
 	pcie_capability_write_word(dev, PCI_EXP_SLTCTL2, cap[i++]);
 }
 
-
 static int pci_save_pcix_state(struct pci_dev *dev)
 {
 	int pos;
@@ -1270,6 +1269,45 @@ static void pci_restore_pcix_state(struct pci_dev *dev)
 	pci_write_config_word(dev, pos + PCI_X_CMD, cap[i++]);
 }
 
+static void pci_save_ltr_state(struct pci_dev *dev)
+{
+	int ltr;
+	struct pci_cap_saved_state *save_state;
+	u16 *cap;
+
+	if (!pci_is_pcie(dev))
+		return;
+
+	ltr = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_LTR);
+	if (!ltr)
+		return;
+
+	save_state = pci_find_saved_ext_cap(dev, PCI_EXT_CAP_ID_LTR);
+	if (!save_state) {
+		pci_err(dev, "no suspend buffer for LTR; ASPM issues possible after resume\n");
+		return;
+	}
+
+	cap = (u16 *)&save_state->cap.data[0];
+	pci_read_config_word(dev, ltr + PCI_LTR_MAX_SNOOP_LAT, cap++);
+	pci_read_config_word(dev, ltr + PCI_LTR_MAX_NOSNOOP_LAT, cap++);
+}
+
+static void pci_restore_ltr_state(struct pci_dev *dev)
+{
+	struct pci_cap_saved_state *save_state;
+	int ltr;
+	u16 *cap;
+
+	save_state = pci_find_saved_ext_cap(dev, PCI_EXT_CAP_ID_LTR);
+	ltr = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_LTR);
+	if (!save_state || !ltr)
+		return;
+
+	cap = (u16 *)&save_state->cap.data[0];
+	pci_write_config_word(dev, ltr + PCI_LTR_MAX_SNOOP_LAT, *cap++);
+	pci_write_config_word(dev, ltr + PCI_LTR_MAX_NOSNOOP_LAT, *cap++);
+}
 
 /**
  * pci_save_state - save the PCI configuration space of a device before suspending
@@ -1291,6 +1329,7 @@ int pci_save_state(struct pci_dev *dev)
 	if (i != 0)
 		return i;
 
+	pci_save_ltr_state(dev);
 	pci_save_dpc_state(dev);
 	return pci_save_vc_state(dev);
 }
@@ -1390,7 +1429,12 @@ void pci_restore_state(struct pci_dev *dev)
 	if (!dev->state_saved)
 		return;
 
-	/* PCI Express register must be restored first */
+	/*
+	 * Restore max latencies (in the LTR capability) before enabling
+	 * LTR itself (in the PCIe capability).
+	 */
+	pci_restore_ltr_state(dev);
+
 	pci_restore_pcie_state(dev);
 	pci_restore_pasid_state(dev);
 	pci_restore_pri_state(dev);
@@ -2998,6 +3042,11 @@ void pci_allocate_cap_save_buffers(struct pci_dev *dev)
 	if (error)
 		pci_err(dev, "unable to preallocate PCI-X save buffer\n");
 
+	error = pci_add_ext_cap_save_buffer(dev, PCI_EXT_CAP_ID_LTR,
+					    2 * sizeof(u16));
+	if (error)
+		pci_err(dev, "unable to allocate suspend buffer for LTR\n");
+
 	pci_allocate_vc_save_buffers(dev);
 }
 

commit 85b0cae89d5266e6a7abb2e83c6f716326fc494c
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Thu Jan 31 19:38:56 2019 +0300

    PCI: Blacklist power management of Gigabyte X299 DESIGNARE EX PCIe ports
    
    Gigabyte X299 DESIGNARE EX motherboard has one PCIe root port that is
    connected to an Alpine Ridge Thunderbolt controller.  This port has slot
    implemented bit set in the config space but other than that it is not
    hotplug capable in the sense we are expecting in Linux (it has
    dev->is_hotplug_bridge set to 0):
    
      00:1c.4 PCI bridge: Intel Corporation 200 Series PCH PCI Express Root Port #5
        Bus: primary=00, secondary=05, subordinate=46, sec-latency=0
        Memory behind bridge: 78000000-8fffffff [size=384M]
        Prefetchable memory behind bridge: 00003800f8000000-00003800ffffffff [size=128M]
        ...
        Capabilities: [40] Express (v2) Root Port (Slot+), MSI 00
        ...
          SltCap: AttnBtn- PwrCtrl- MRL- AttnInd- PwrInd- HotPlug- Surprise-
                  Slot #8, PowerLimit 25.000W; Interlock- NoCompl+
          SltCtl: Enable: AttnBtn- PwrFlt- MRL- PresDet- CmdCplt- HPIrq- LinkChg-
                  Control: AttnInd Unknown, PwrInd Unknown, Power- Interlock-
          SltSta: Status: AttnBtn- PowerFlt- MRL- CmdCplt- PresDet- Interlock-
                  Changed: MRL- PresDet+ LinkState+
    
    This system is using ACPI based hotplug to notify the OS that it needs to
    rescan the PCI bus (ACPI hotplug).
    
    If there is nothing connected in any of the Thunderbolt ports the root port
    will not have any runtime PM active children and is thus automatically
    runtime suspended pretty soon after boot by PCI PM core.  Now, when a
    device is connected the BIOS SMI handler responsible for enumerating newly
    added devices is not able to find anything because the port is in D3.
    
    Prevent this from happening by blacklisting PCI power management of this
    particular Gigabyte system.
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=202031
    Reported-by: Kedar A Dongre <kedar.a.dongre@intel.com>
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index c9d8e3c837de..0f29cd1d36d3 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2501,6 +2501,25 @@ void pci_config_pm_runtime_put(struct pci_dev *pdev)
 		pm_runtime_put_sync(parent);
 }
 
+static const struct dmi_system_id bridge_d3_blacklist[] = {
+#ifdef CONFIG_X86
+	{
+		/*
+		 * Gigabyte X299 root port is not marked as hotplug capable
+		 * which allows Linux to power manage it.  However, this
+		 * confuses the BIOS SMI handler so don't power manage root
+		 * ports on that system.
+		 */
+		.ident = "X299 DESIGNARE EX-CF",
+		.matches = {
+			DMI_MATCH(DMI_BOARD_VENDOR, "Gigabyte Technology Co., Ltd."),
+			DMI_MATCH(DMI_BOARD_NAME, "X299 DESIGNARE EX-CF"),
+		},
+	},
+#endif
+	{ }
+};
+
 /**
  * pci_bridge_d3_possible - Is it possible to put the bridge into D3
  * @bridge: Bridge to check
@@ -2546,6 +2565,9 @@ bool pci_bridge_d3_possible(struct pci_dev *bridge)
 		if (bridge->is_hotplug_bridge)
 			return false;
 
+		if (dmi_check_system(bridge_d3_blacklist))
+			return false;
+
 		/*
 		 * It should be safe to put PCIe ports from 2015 or newer
 		 * to D3.

commit 9481caf39bf55a862067007ffc53621b4305a387
Merge: 344c0152d878 d13937116f1e
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Feb 11 09:09:02 2019 +0100

    Merge 5.0-rc6 into driver-core-next
    
    We need the debugfs fixes in here as well.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit b2fb5cc574695a32361a6c1878816b3d6563aa0f
Author: Honghui Zhang <honghui.zhang@mediatek.com>
Date:   Tue Oct 16 18:44:43 2018 +0800

    PCI: Rely on config space header type, not class code
    
    The PCI configuration space header type tells us whether the device is a
    bridge, a CardBus bridge, or a normal device, and defines the layout of the
    rest of the header (PCI r3.0 sec 6.1, PCIe r4.0 sec 7.5.1.1.9).
    
    When we rely on the header format, e.g., when we're dealing with bridge
    windows, we should check the header type, not the class code.  The class
    code is loosely related to the header type, but is often incorrect and the
    spec doesn't actually require it to be related to the header format.
    
    Suggested-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Honghui Zhang <honghui.zhang@mediatek.com>
    [bhelgaas: changelog, keep the PCI_CLASS_BRIDGE_HOST check]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index c9d8e3c837de..e9d938e14ba8 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -6000,8 +6000,7 @@ void pci_reassigndev_resource_alignment(struct pci_dev *dev)
 	 * to enable the kernel to reassign new resource
 	 * window later on.
 	 */
-	if (dev->hdr_type == PCI_HEADER_TYPE_BRIDGE &&
-	    (dev->class >> 8) == PCI_CLASS_BRIDGE_PCI) {
+	if (dev->hdr_type == PCI_HEADER_TYPE_BRIDGE) {
 		for (i = PCI_BRIDGE_RESOURCES; i < PCI_NUM_RESOURCES; i++) {
 			r = &dev->resource[i];
 			if (!(r->flags & IORESOURCE_MEM))

commit d61dfafc30b44dd55d886cda54543dd37cea3e13
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Dec 21 08:54:33 2018 +0100

    PCI: pci.c: convert to use BUS_ATTR_RW
    
    We are trying to get rid of BUS_ATTR() and the usage of that in pci.c
    can be trivially converted to use BUS_ATTR_RW(), so use that instead.
    
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index c9d8e3c837de..fda84538de79 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -6034,19 +6034,18 @@ static ssize_t pci_get_resource_alignment_param(char *buf, size_t size)
 	return count;
 }
 
-static ssize_t pci_resource_alignment_show(struct bus_type *bus, char *buf)
+static ssize_t resource_alignment_show(struct bus_type *bus, char *buf)
 {
 	return pci_get_resource_alignment_param(buf, PAGE_SIZE);
 }
 
-static ssize_t pci_resource_alignment_store(struct bus_type *bus,
+static ssize_t resource_alignment_store(struct bus_type *bus,
 					const char *buf, size_t count)
 {
 	return pci_set_resource_alignment_param(buf, count);
 }
 
-static BUS_ATTR(resource_alignment, 0644, pci_resource_alignment_show,
-					pci_resource_alignment_store);
+static BUS_ATTR_RW(resource_alignment);
 
 static int __init pci_resource_alignment_sysfs_init(void)
 {

commit d2fd6e81912a665993b24dcdc1c1384a42a54f7e
Author: Logan Gunthorpe <logang@deltatee.com>
Date:   Thu Jan 17 08:46:34 2019 -0600

    PCI: Fix __initdata issue with "pci=disable_acs_redir" parameter
    
    The disable_acs_redir parameter stores a pointer to the string passed to
    pci_setup().  However, the string passed to PCI setup is actually a
    temporary copy allocated in static __initdata memory.  After init, once the
    memory is freed, it is no longer valid to reference this pointer.
    
    This bug was noticed in v5.0-rc1 after a change in commit c5eb1190074c
    ("PCI / PM: Allow runtime PM without callback functions") caused
    pci_disable_acs_redir() to be called during shutdown which manifested
    as an unable to handle kernel paging request at:
    
      RIP: 0010:pci_enable_acs+0x3f/0x1e0
      Call Trace:
         pci_restore_state.part.44+0x159/0x3c0
         pci_restore_standard_config+0x33/0x40
         pci_pm_runtime_resume+0x2b/0xd0
         ? pci_restore_standard_config+0x40/0x40
         __rpm_callback+0xbc/0x1b0
         rpm_callback+0x1f/0x70
         ? pci_restore_standard_config+0x40/0x40
          rpm_resume+0x4f9/0x710
         ? pci_conf1_read+0xb6/0xf0
         ? pci_conf1_write+0xb2/0xe0
         __pm_runtime_resume+0x47/0x70
         pci_device_shutdown+0x1e/0x60
         device_shutdown+0x14a/0x1f0
         kernel_restart+0xe/0x50
         __do_sys_reboot+0x1ee/0x210
         ? __fput+0x144/0x1d0
         do_writev+0x5e/0xf0
         ? do_writev+0x5e/0xf0
         do_syscall_64+0x48/0xf0
         entry_SYSCALL_64_after_hwframe+0x44/0xa9
    
    It was also likely possible to trigger this bug when hotplugging PCI
    devices.
    
    To fix this, instead of storing a pointer, we use kstrdup() to copy the
    disable_acs_redir_param to its own buffer which will never be freed.
    
    Fixes: aaca43fda742 ("PCI: Add "pci=disable_acs_redir=" parameter for peer-to-peer support")
    Tested-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Logan Gunthorpe <logang@deltatee.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index c9d8e3c837de..c25acace7d91 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -6195,7 +6195,8 @@ static int __init pci_setup(char *str)
 			} else if (!strncmp(str, "pcie_scan_all", 13)) {
 				pci_add_flags(PCI_SCAN_ALL_PCIE_DEVS);
 			} else if (!strncmp(str, "disable_acs_redir=", 18)) {
-				disable_acs_redir_param = str + 18;
+				disable_acs_redir_param =
+					kstrdup(str + 18, GFP_KERNEL);
 			} else {
 				printk(KERN_ERR "PCI: Unknown option `%s'\n",
 						str);

commit 1d09d57728fedd7357ee22d407ae8aae6477757f
Author: Mathieu Malaterre <malat@debian.org>
Date:   Mon Jan 14 21:41:36 2019 +0100

    PCI: Mark expected switch fall-through
    
    There is a plan to build the kernel with -Wimplicit-fallthrough and
    these places in the code produced warnings (W=1).  Fix them up.
    
    Signed-off-by: Mathieu Malaterre <malat@debian.org>
    [bhelgaas: squash into one patch, drop extra changelog detail]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index c9d8e3c837de..94069fc35e91 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -861,7 +861,7 @@ static int pci_raw_set_power_state(struct pci_dev *dev, pci_power_t state)
 		if ((pmcsr & PCI_PM_CTRL_STATE_MASK) == PCI_D3hot
 		 && !(pmcsr & PCI_PM_CTRL_NO_SOFT_RESET))
 			need_restore = true;
-		/* Fall-through: force to D0 */
+		/* Fall-through - force to D0 */
 	default:
 		pmcsr = 0;
 		break;
@@ -2260,7 +2260,7 @@ static pci_power_t pci_target_state(struct pci_dev *dev, bool wakeup)
 		case PCI_D2:
 			if (pci_no_d1d2(dev))
 				break;
-			/* else: fall through */
+			/* else, fall through */
 		default:
 			target_state = state;
 		}

commit f1f90e254e46e0a14220e4090041f68256fbe297
Author: Mikulas Patocka <mpatocka@redhat.com>
Date:   Mon Nov 26 10:37:13 2018 -0600

    PCI: Fix incorrect value returned from pcie_get_speed_cap()
    
    The macros PCI_EXP_LNKCAP_SLS_*GB are values, not bit masks.  We must mask
    the register and compare it against them.
    
    This fixes errors like this:
    
      amdgpu: [powerplay] failed to send message 261 ret is 0
    
    when a PCIe-v3 card is plugged into a PCIe-v1 slot, because the slot is
    being incorrectly reported as PCIe-v3 capable.
    
    6cf57be0f78e, which appeared in v4.17, added pcie_get_speed_cap() with the
    incorrect test of PCI_EXP_LNKCAP_SLS as a bitmask.  5d9a63304032, which
    appeared in v4.19, changed amdgpu to use pcie_get_speed_cap(), so the
    amdgpu bug reports below are regressions in v4.19.
    
    Fixes: 6cf57be0f78e ("PCI: Add pcie_get_speed_cap() to find max supported link speed")
    Fixes: 5d9a63304032 ("drm/amdgpu: use pcie functions for link width and speed")
    Link: https://bugs.freedesktop.org/show_bug.cgi?id=108704
    Link: https://bugs.freedesktop.org/show_bug.cgi?id=108778
    Signed-off-by: Mikulas Patocka <mpatocka@redhat.com>
    [bhelgaas: update comment, remove use of PCI_EXP_LNKCAP_SLS_8_0GB and
    PCI_EXP_LNKCAP_SLS_16_0GB since those should be covered by PCI_EXP_LNKCAP2,
    remove test of PCI_EXP_LNKCAP for zero, since that register is required]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Cc: stable@vger.kernel.org      # v4.17+

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index d068f11d08a7..c9d8e3c837de 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -5556,9 +5556,13 @@ enum pci_bus_speed pcie_get_speed_cap(struct pci_dev *dev)
 	u32 lnkcap2, lnkcap;
 
 	/*
-	 * PCIe r4.0 sec 7.5.3.18 recommends using the Supported Link
-	 * Speeds Vector in Link Capabilities 2 when supported, falling
-	 * back to Max Link Speed in Link Capabilities otherwise.
+	 * Link Capabilities 2 was added in PCIe r3.0, sec 7.8.18.  The
+	 * implementation note there recommends using the Supported Link
+	 * Speeds Vector in Link Capabilities 2 when supported.
+	 *
+	 * Without Link Capabilities 2, i.e., prior to PCIe r3.0, software
+	 * should use the Supported Link Speeds field in Link Capabilities,
+	 * where only 2.5 GT/s and 5.0 GT/s speeds were defined.
 	 */
 	pcie_capability_read_dword(dev, PCI_EXP_LNKCAP2, &lnkcap2);
 	if (lnkcap2) { /* PCIe r3.0-compliant */
@@ -5574,16 +5578,10 @@ enum pci_bus_speed pcie_get_speed_cap(struct pci_dev *dev)
 	}
 
 	pcie_capability_read_dword(dev, PCI_EXP_LNKCAP, &lnkcap);
-	if (lnkcap) {
-		if (lnkcap & PCI_EXP_LNKCAP_SLS_16_0GB)
-			return PCIE_SPEED_16_0GT;
-		else if (lnkcap & PCI_EXP_LNKCAP_SLS_8_0GB)
-			return PCIE_SPEED_8_0GT;
-		else if (lnkcap & PCI_EXP_LNKCAP_SLS_5_0GB)
-			return PCIE_SPEED_5_0GT;
-		else if (lnkcap & PCI_EXP_LNKCAP_SLS_2_5GB)
-			return PCIE_SPEED_2_5GT;
-	}
+	if ((lnkcap & PCI_EXP_LNKCAP_SLS) == PCI_EXP_LNKCAP_SLS_5_0GB)
+		return PCIE_SPEED_5_0GT;
+	else if ((lnkcap & PCI_EXP_LNKCAP_SLS) == PCI_EXP_LNKCAP_SLS_2_5GB)
+		return PCIE_SPEED_2_5GT;
 
 	return PCI_SPEED_UNKNOWN;
 }

commit bd6bf7c10484f026505814b690104cdef27ed460
Merge: a41efc2a0f68 663569db6476
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Oct 25 06:50:48 2018 -0700

    Merge tag 'pci-v4.20-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI updates from Bjorn Helgaas:
    
     - Fix ASPM link_state teardown on removal (Lukas Wunner)
    
     - Fix misleading _OSC ASPM message (Sinan Kaya)
    
     - Make _OSC optional for PCI (Sinan Kaya)
    
     - Don't initialize ASPM link state when ACPI_FADT_NO_ASPM is set
       (Patrick Talbert)
    
     - Remove x86 and arm64 node-local allocation for host bridge structures
       (Punit Agrawal)
    
     - Pay attention to device-specific _PXM node values (Jonathan Cameron)
    
     - Support new Immediate Readiness bit (Felipe Balbi)
    
     - Differentiate between pciehp surprise and safe removal (Lukas Wunner)
    
     - Remove unnecessary pciehp includes (Lukas Wunner)
    
     - Drop pciehp hotplug_slot_ops wrappers (Lukas Wunner)
    
     - Tolerate PCIe Slot Presence Detect being hardwired to zero to
       workaround broken hardware, e.g., the Wilocity switch/wireless device
       (Lukas Wunner)
    
     - Unify pciehp controller & slot structs (Lukas Wunner)
    
     - Constify hotplug_slot_ops (Lukas Wunner)
    
     - Drop hotplug_slot_info (Lukas Wunner)
    
     - Embed hotplug_slot struct into users instead of allocating it
       separately (Lukas Wunner)
    
     - Initialize PCIe port service drivers directly instead of relying on
       initcall ordering (Keith Busch)
    
     - Restore PCI config state after a slot reset (Keith Busch)
    
     - Save/restore DPC config state along with other PCI config state
       (Keith Busch)
    
     - Reference count devices during AER handling to avoid race issue with
       concurrent hot removal (Keith Busch)
    
     - If an Upstream Port reports ERR_FATAL, don't try to read the Port's
       config space because it is probably unreachable (Keith Busch)
    
     - During error handling, use slot-specific reset instead of secondary
       bus reset to avoid link up/down issues on hotplug ports (Keith Busch)
    
     - Restore previous AER/DPC handling that does not remove and
       re-enumerate devices on ERR_FATAL (Keith Busch)
    
     - Notify all drivers that may be affected by error recovery resets
       (Keith Busch)
    
     - Always generate error recovery uevents, even if a driver doesn't have
       error callbacks (Keith Busch)
    
     - Make PCIe link active reporting detection generic (Keith Busch)
    
     - Support D3cold in PCIe hierarchies during system sleep and runtime,
       including hotplug and Thunderbolt ports (Mika Westerberg)
    
     - Handle hpmemsize/hpiosize kernel parameters uniformly, whether slots
       are empty or occupied (Jon Derrick)
    
     - Remove duplicated include from pci/pcie/err.c and unused variable
       from cpqphp (YueHaibing)
    
     - Remove driver pci_cleanup_aer_uncorrect_error_status() calls (Oza
       Pawandeep)
    
     - Uninline PCI bus accessors for better ftracing (Keith Busch)
    
     - Remove unused AER Root Port .error_resume method (Keith Busch)
    
     - Use kfifo in AER instead of a local version (Keith Busch)
    
     - Use threaded IRQ in AER bottom half (Keith Busch)
    
     - Use managed resources in AER core (Keith Busch)
    
     - Reuse pcie_port_find_device() for AER injection (Keith Busch)
    
     - Abstract AER interrupt handling to disconnect error injection (Keith
       Busch)
    
     - Refactor AER injection callbacks to simplify future improvments
       (Keith Busch)
    
     - Remove unused Netronome NFP32xx Device IDs (Jakub Kicinski)
    
     - Use bitmap_zalloc() for dma_alias_mask (Andy Shevchenko)
    
     - Add switch fall-through annotations (Gustavo A. R. Silva)
    
     - Remove unused Switchtec quirk variable (Joshua Abraham)
    
     - Fix pci.c kernel-doc warning (Randy Dunlap)
    
     - Remove trivial PCI wrappers for DMA APIs (Christoph Hellwig)
    
     - Add Intel GPU device IDs to spurious interrupt quirk (Bin Meng)
    
     - Run Switchtec DMA aliasing quirk only on NTB endpoints to avoid
       useless dmesg errors (Logan Gunthorpe)
    
     - Update Switchtec NTB documentation (Wesley Yung)
    
     - Remove redundant "default n" from Kconfig (Bartlomiej Zolnierkiewicz)
    
     - Avoid panic when drivers enable MSI/MSI-X twice (Tonghao Zhang)
    
     - Add PCI support for peer-to-peer DMA (Logan Gunthorpe)
    
     - Add sysfs group for PCI peer-to-peer memory statistics (Logan
       Gunthorpe)
    
     - Add PCI peer-to-peer DMA scatterlist mapping interface (Logan
       Gunthorpe)
    
     - Add PCI configfs/sysfs helpers for use by peer-to-peer users (Logan
       Gunthorpe)
    
     - Add PCI peer-to-peer DMA driver writer's documentation (Logan
       Gunthorpe)
    
     - Add block layer flag to indicate driver support for PCI peer-to-peer
       DMA (Logan Gunthorpe)
    
     - Map Infiniband scatterlists for peer-to-peer DMA if they contain P2P
       memory (Logan Gunthorpe)
    
     - Register nvme-pci CMB buffer as PCI peer-to-peer memory (Logan
       Gunthorpe)
    
     - Add nvme-pci support for PCI peer-to-peer memory in requests (Logan
       Gunthorpe)
    
     - Use PCI peer-to-peer memory in nvme (Stephen Bates, Steve Wise,
       Christoph Hellwig, Logan Gunthorpe)
    
     - Cache VF config space size to optimize enumeration of many VFs
       (KarimAllah Ahmed)
    
     - Remove unnecessary <linux/pci-ats.h> include (Bjorn Helgaas)
    
     - Fix VMD AERSID quirk Device ID matching (Jon Derrick)
    
     - Fix Cadence PHY handling during probe (Alan Douglas)
    
     - Signal Cadence Endpoint interrupts via AXI region 0 instead of last
       region (Alan Douglas)
    
     - Write Cadence Endpoint MSI interrupts with 32 bits of data (Alan
       Douglas)
    
     - Remove redundant controller tests for "device_type == pci" (Rob
       Herring)
    
     - Document R-Car E3 (R8A77990) bindings (Tho Vu)
    
     - Add device tree support for R-Car r8a7744 (Biju Das)
    
     - Drop unused mvebu PCIe capability code (Thomas Petazzoni)
    
     - Add shared PCI bridge emulation code (Thomas Petazzoni)
    
     - Convert mvebu to use shared PCI bridge emulation (Thomas Petazzoni)
    
     - Add aardvark Root Port emulation (Thomas Petazzoni)
    
     - Support 100MHz/200MHz refclocks for i.MX6 (Lucas Stach)
    
     - Add initial power management for i.MX7 (Leonard Crestez)
    
     - Add PME_Turn_Off support for i.MX7 (Leonard Crestez)
    
     - Fix qcom runtime power management error handling (Bjorn Andersson)
    
     - Update TI dra7xx unaligned access errata workaround for host mode as
       well as endpoint mode (Vignesh R)
    
     - Fix kirin section mismatch warning (Nathan Chancellor)
    
     - Remove iproc PAXC slot check to allow VF support (Jitendra Bhivare)
    
     - Quirk Keystone K2G to limit MRRS to 256 (Kishon Vijay Abraham I)
    
     - Update Keystone to use MRRS quirk for host bridge instead of open
       coding (Kishon Vijay Abraham I)
    
     - Refactor Keystone link establishment (Kishon Vijay Abraham I)
    
     - Simplify and speed up Keystone link training (Kishon Vijay Abraham I)
    
     - Remove unused Keystone host_init argument (Kishon Vijay Abraham I)
    
     - Merge Keystone driver files into one (Kishon Vijay Abraham I)
    
     - Remove redundant Keystone platform_set_drvdata() (Kishon Vijay
       Abraham I)
    
     - Rename Keystone functions for uniformity (Kishon Vijay Abraham I)
    
     - Add Keystone device control module DT binding (Kishon Vijay Abraham
       I)
    
     - Use SYSCON API to get Keystone control module device IDs (Kishon
       Vijay Abraham I)
    
     - Clean up Keystone PHY handling (Kishon Vijay Abraham I)
    
     - Use runtime PM APIs to enable Keystone clock (Kishon Vijay Abraham I)
    
     - Clean up Keystone config space access checks (Kishon Vijay Abraham I)
    
     - Get Keystone outbound window count from DT (Kishon Vijay Abraham I)
    
     - Clean up Keystone outbound window configuration (Kishon Vijay Abraham
       I)
    
     - Clean up Keystone DBI setup (Kishon Vijay Abraham I)
    
     - Clean up Keystone ks_pcie_link_up() (Kishon Vijay Abraham I)
    
     - Fix Keystone IRQ status checking (Kishon Vijay Abraham I)
    
     - Add debug messages for all Keystone errors (Kishon Vijay Abraham I)
    
     - Clean up Keystone includes and macros (Kishon Vijay Abraham I)
    
     - Fix Mediatek unchecked return value from devm_pci_remap_iospace()
       (Gustavo A. R. Silva)
    
     - Fix Mediatek endpoint/port matching logic (Honghui Zhang)
    
     - Change Mediatek Root Port Class Code to PCI_CLASS_BRIDGE_PCI (Honghui
       Zhang)
    
     - Remove redundant Mediatek PM domain check (Honghui Zhang)
    
     - Convert Mediatek to pci_host_probe() (Honghui Zhang)
    
     - Fix Mediatek MSI enablement (Honghui Zhang)
    
     - Add Mediatek system PM support for MT2712 and MT7622 (Honghui Zhang)
    
     - Add Mediatek loadable module support (Honghui Zhang)
    
     - Detach VMD resources after stopping root bus to prevent orphan
       resources (Jon Derrick)
    
     - Convert pcitest build process to that used by other tools (iio, perf,
       etc) (Gustavo Pimentel)
    
    * tag 'pci-v4.20-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (140 commits)
      PCI/AER: Refactor error injection fallbacks
      PCI/AER: Abstract AER interrupt handling
      PCI/AER: Reuse existing pcie_port_find_device() interface
      PCI/AER: Use managed resource allocations
      PCI: pcie: Remove redundant 'default n' from Kconfig
      PCI: aardvark: Implement emulated root PCI bridge config space
      PCI: mvebu: Convert to PCI emulated bridge config space
      PCI: mvebu: Drop unused PCI express capability code
      PCI: Introduce PCI bridge emulated config space common logic
      PCI: vmd: Detach resources after stopping root bus
      nvmet: Optionally use PCI P2P memory
      nvmet: Introduce helper functions to allocate and free request SGLs
      nvme-pci: Add support for P2P memory in requests
      nvme-pci: Use PCI p2pmem subsystem to manage the CMB
      IB/core: Ensure we map P2P memory correctly in rdma_rw_ctx_[init|destroy]()
      block: Add PCI P2P flag for request queue
      PCI/P2PDMA: Add P2P DMA driver writer's documentation
      docs-rst: Add a new directory for PCI documentation
      PCI/P2PDMA: Introduce configfs/sysfs enable attribute helpers
      PCI/P2PDMA: Add PCI p2pmem DMA mappings to adjust the bus offset
      ...

commit ee8360fdafac54eefd0df69fbd99338896cf806b
Merge: 20634dc361e1 fe73c23d7a09
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Sat Oct 20 11:45:30 2018 -0500

    Merge branch 'pci/misc'
    
      - Remove unused Netronome NFP32xx Device IDs (Jakub Kicinski)
    
      - Use bitmap_zalloc() for dma_alias_mask (Andy Shevchenko)
    
      - Add switch fall-through annotations (Gustavo A. R. Silva)
    
      - Remove unused Switchtec quirk variable (Joshua Abraham)
    
      - Fix pci.c kernel-doc warning (Randy Dunlap)
    
      - Remove trivial PCI wrappers for DMA APIs (Christoph Hellwig)
    
      - Add Intel GPU device IDs to spurious interrupt quirk (Bin Meng)
    
      - Run Switchtec DMA aliasing quirk only on NTB endpoints to avoid useless
        dmesg errors (Logan Gunthorpe)
    
      - Update Switchtec NTB documentation (Wesley Yung)
    
      - Remove redundant "default n" from Kconfig (Bartlomiej Zolnierkiewicz)
    
    * pci/misc:
      PCI: pcie: Remove redundant 'default n' from Kconfig
      NTB: switchtec_ntb: Update switchtec documentation with prerequisites for NTB
      PCI: Fix Switchtec DMA aliasing quirk dmesg noise
      PCI: Add macro for Switchtec quirk declarations
      PCI: Add Device IDs for Intel GPU "spurious interrupt" quirk
      PCI: Remove pci_set_dma_max_seg_size()
      PCI: Remove pci_set_dma_seg_boundary()
      PCI: Remove pci_unmap_addr() wrappers for DMA API
      PCI / ACPI: Mark expected switch fall-through
      PCI: Remove set but unused variable
      PCI: Fix pci.c kernel-doc parameter warning
      PCI: Allocate dma_alias_mask with bitmap_zalloc()
      PCI: Remove unused NFP32xx IDs

commit 20634dc361e1c5fe2dae380a7d0a21ca7f32c4f7
Merge: de468b755464 e51cd9ce5dd3
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Sat Oct 20 11:45:29 2018 -0500

    Merge branch 'pci/hotplug'
    
      - Differentiate between pciehp surprise and safe removal (Lukas Wunner)
    
      - Remove unnecessary pciehp includes (Lukas Wunner)
    
      - Drop pciehp hotplug_slot_ops wrappers (Lukas Wunner)
    
      - Tolerate PCIe Slot Presence Detect being hardwired to zero to
        workaround broken hardware, e.g., the Wilocity switch/wireless device
        (Lukas Wunner)
    
      - Unify pciehp controller & slot structs (Lukas Wunner)
    
      - Constify hotplug_slot_ops (Lukas Wunner)
    
      - Drop hotplug_slot_info (Lukas Wunner)
    
      - Embed hotplug_slot struct into users instead of allocating it
        separately (Lukas Wunner)
    
      - Initialize PCIe port service drivers directly instead of relying on
        initcall ordering (Keith Busch)
    
      - Restore PCI config state after a slot reset (Keith Busch)
    
      - Save/restore DPC config state along with other PCI config state (Keith
        Busch)
    
      - Reference count devices during AER handling to avoid race issue with
        concurrent hot removal (Keith Busch)
    
      - If an Upstream Port reports ERR_FATAL, don't try to read the Port's
        config space because it is probably unreachable (Keith Busch)
    
      - During error handling, use slot-specific reset instead of secondary
        bus reset to avoid link up/down issues on hotplug ports (Keith Busch)
    
      - Restore previous AER/DPC handling that does not remove and re-enumerate
        devices on ERR_FATAL (Keith Busch)
    
      - Notify all drivers that may be affected by error recovery resets (Keith
        Busch)
    
      - Always generate error recovery uevents, even if a driver doesn't have
        error callbacks (Keith Busch)
    
      - Make PCIe link active reporting detection generic (Keith Busch)
    
      - Support D3cold in PCIe hierarchies during system sleep and runtime,
        including hotplug and Thunderbolt ports (Mika Westerberg)
    
      - Handle hpmemsize/hpiosize kernel parameters uniformly, whether slots
        are empty or occupied (Jon Derrick)
    
      - Remove duplicated include from pci/pcie/err.c and unused variable from
        cpqphp (YueHaibing)
    
      - Remove driver pci_cleanup_aer_uncorrect_error_status() calls (Oza
        Pawandeep)
    
      - Uninline PCI bus accessors for better ftracing (Keith Busch)
    
      - Remove unused AER Root Port .error_resume method (Keith Busch)
    
      - Use kfifo in AER instead of a local version (Keith Busch)
    
      - Use threaded IRQ in AER bottom half (Keith Busch)
    
      - Use managed resources in AER core (Keith Busch)
    
      - Reuse pcie_port_find_device() for AER injection (Keith Busch)
    
      - Abstract AER interrupt handling to disconnect error injection (Keith
        Busch)
    
      - Refactor AER injection callbacks to simplify future improvments (Keith
        Busch)
    
    * pci/hotplug:
      PCI/AER: Refactor error injection fallbacks
      PCI/AER: Abstract AER interrupt handling
      PCI/AER: Reuse existing pcie_port_find_device() interface
      PCI/AER: Use managed resource allocations
      PCI/AER: Use threaded IRQ for bottom half
      PCI/AER: Use kfifo_in_spinlocked() to insert locked elements
      PCI/AER: Use kfifo for tracking events instead of reimplementing it
      PCI/AER: Remove error source from AER struct aer_rpc
      PCI/AER: Remove unused aer_error_resume()
      PCI: Uninline PCI bus accessors for better ftracing
      PCI/AER: Remove pci_cleanup_aer_uncorrect_error_status() calls
      PCI: pnv_php: Use kmemdup()
      PCI: cpqphp: Remove set but not used variable 'physical_slot'
      PCI/ERR: Remove duplicated include from err.c
      PCI: Equalize hotplug memory and io for occupied and empty slots
      PCI / ACPI: Whitelist D3 for more PCIe hotplug ports
      ACPI / property: Allow multiple property compatible _DSD entries
      PCI/PME: Implement runtime PM callbacks
      PCI: pciehp: Implement runtime PM callbacks
      PCI/portdrv: Add runtime PM hooks for port service drivers
      PCI/portdrv: Resume upon exit from system suspend if left runtime suspended
      PCI: pciehp: Do not handle events if interrupts are masked
      PCI: pciehp: Disable hotplug interrupt during suspend
      PCI / ACPI: Enable wake automatically for power managed bridges
      PCI: Do not skip power-managed bridges in pci_enable_wake()
      PCI: Make link active reporting detection generic
      PCI: Unify device inaccessible
      PCI/ERR: Always report current recovery status for udev
      PCI/ERR: Simplify broadcast callouts
      PCI/ERR: Run error recovery callbacks for all affected devices
      PCI/ERR: Handle fatal error recovery
      PCI/ERR: Use slot reset if available
      PCI/AER: Don't read upstream ports below fatal errors
      PCI/AER: Take reference on error devices
      PCI/DPC: Save and restore config state
      PCI: portdrv: Restore PCI config state on slot reset
      PCI: portdrv: Initialize service drivers directly
      PCI: hotplug: Document TODOs
      PCI: hotplug: Embed hotplug_slot
      PCI: hotplug: Drop hotplug_slot_info
      PCI: hotplug: Constify hotplug_slot_ops
      PCI: pciehp: Reshuffle controller struct for clarity
      PCI: pciehp: Rename controller struct members for clarity
      PCI: pciehp: Unify controller and slot structs
      PCI: pciehp: Tolerate Presence Detect hardwired to zero
      PCI: pciehp: Drop hotplug_slot_ops wrappers
      PCI: pciehp: Drop unnecessary includes
      PCI: pciehp: Differentiate between surprise and safe removal
      PCI: Simplify disconnected marking

commit 26ad34d510a87fc65caeb48fa85cce58d2477a88
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Thu Sep 27 16:57:14 2018 -0500

    PCI / ACPI: Whitelist D3 for more PCIe hotplug ports
    
    In order to have better power management for Thunderbolt PCIe chains,
    Windows enables power management for native PCIe hotplug ports if there is
    the following ACPI _DSD attached to the root port:
    
      Name (_DSD, Package () {
          ToUUID ("6211e2c0-58a3-4af3-90e1-927a4e0c55a4"),
          Package () {
              Package () {"HotPlugSupportInD3", 1}
          }
      })
    
    This is also documented in:
    
      https://docs.microsoft.com/en-us/windows-hardware/drivers/pci/dsd-for-pcie-root-ports#identifying-pcie-root-ports-supporting-hot-plug-in-d3
    
    Do the same in Linux by introducing new firmware PM callback
    (->bridge_d3()) and then implement it for ACPI based systems so that the
    above property is checked.
    
    There is one catch, though. The initial pci_dev->bridge_d3 is set before
    the root port has ACPI companion bound (the device is not added to the PCI
    bus either) so we need to look up the ACPI companion manually in that case
    in acpi_pci_bridge_d3().
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 4a1b1f76dc92..e6fcf11f5dcc 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -793,6 +793,11 @@ static inline bool platform_pci_need_resume(struct pci_dev *dev)
 	return pci_platform_pm ? pci_platform_pm->need_resume(dev) : false;
 }
 
+static inline bool platform_pci_bridge_d3(struct pci_dev *dev)
+{
+	return pci_platform_pm ? pci_platform_pm->bridge_d3(dev) : false;
+}
+
 /**
  * pci_raw_set_power_state - Use PCI PM registers to set the power state of
  *                           given PCI device
@@ -2518,6 +2523,10 @@ bool pci_bridge_d3_possible(struct pci_dev *bridge)
 		if (bridge->is_thunderbolt)
 			return true;
 
+		/* Platform might know better if the bridge supports D3 */
+		if (platform_pci_bridge_d3(bridge))
+			return true;
+
 		/*
 		 * Hotplug ports handled natively by the OS were not validated
 		 * by vendors for runtime D3 at least until 2018 because there

commit ac86e8eeb0542d1089d8cba55884eeeb9410f027
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Thu Sep 27 16:53:53 2018 -0500

    PCI: Do not skip power-managed bridges in pci_enable_wake()
    
    Commit baecc470d5fd ("PCI / PM: Skip bridges in pci_enable_wake()") changed
    pci_enable_wake() so that all bridges are skipped when wakeup is enabled
    (or disabled) with the reasoning that bridges can only signal wakeup on
    behalf of their subordinate devices.
    
    However, there are bridges that can signal wakeup themselves.  For example
    PCIe downstream and root ports supporting hotplug may signal wakeup upon
    hotplug event.
    
    For this reason change pci_enable_wake() so that it skips all bridges
    except those that we power manage (->bridge_d3 is set).  Those are the ones
    that can go into low power states and may need to signal wakeup.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 4b0b1d0548f0..4a1b1f76dc92 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2137,10 +2137,13 @@ static int __pci_enable_wake(struct pci_dev *dev, pci_power_t state, bool enable
 	int ret = 0;
 
 	/*
-	 * Bridges can only signal wakeup on behalf of subordinate devices,
-	 * but that is set up elsewhere, so skip them.
+	 * Bridges that are not power-manageable directly only signal
+	 * wakeup on behalf of subordinate devices which is set up
+	 * elsewhere, so skip them. However, bridges that are
+	 * power-manageable may signal wakeup for themselves (for example,
+	 * on a hotplug event) and they need to be covered here.
 	 */
-	if (pci_has_subordinate(dev))
+	if (!pci_power_manageable(dev))
 		return 0;
 
 	/* Don't do the same thing twice in a row for one device. */

commit f0157160b359b1d263ee9d4e0a435a7ad85bbcea
Author: Keith Busch <keith.busch@intel.com>
Date:   Thu Sep 20 10:27:17 2018 -0600

    PCI: Make link active reporting detection generic
    
    The spec has timing requirements when waiting for a link to become active
    after a conventional reset.  Implement those hard delays when waiting for
    an active link so pciehp and dpc drivers don't need to duplicate this.
    
    For devices that don't support data link layer active reporting, wait the
    fixed time recommended by the PCIe spec.
    
    Signed-off-by: Keith Busch <keith.busch@intel.com>
    [bhelgaas: changelog]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Sinan Kaya <okaya@kernel.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 6916af269b19..4b0b1d0548f0 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -4489,21 +4489,42 @@ bool pcie_wait_for_link(struct pci_dev *pdev, bool active)
 	bool ret;
 	u16 lnk_status;
 
+	/*
+	 * Some controllers might not implement link active reporting. In this
+	 * case, we wait for 1000 + 100 ms.
+	 */
+	if (!pdev->link_active_reporting) {
+		msleep(1100);
+		return true;
+	}
+
+	/*
+	 * PCIe r4.0 sec 6.6.1, a component must enter LTSSM Detect within 20ms,
+	 * after which we should expect an link active if the reset was
+	 * successful. If so, software must wait a minimum 100ms before sending
+	 * configuration requests to devices downstream this port.
+	 *
+	 * If the link fails to activate, either the device was physically
+	 * removed or the link is permanently failed.
+	 */
+	if (active)
+		msleep(20);
 	for (;;) {
 		pcie_capability_read_word(pdev, PCI_EXP_LNKSTA, &lnk_status);
 		ret = !!(lnk_status & PCI_EXP_LNKSTA_DLLLA);
 		if (ret == active)
-			return true;
+			break;
 		if (timeout <= 0)
 			break;
 		msleep(10);
 		timeout -= 10;
 	}
-
-	pci_info(pdev, "Data Link Layer Link Active not %s in 1000 msec\n",
-		 active ? "set" : "cleared");
-
-	return false;
+	if (active && ret)
+		msleep(100);
+	else if (ret != active)
+		pci_info(pdev, "Data Link Layer Link Active not %s in 1000 msec\n",
+			active ? "set" : "cleared");
+	return ret == active;
 }
 
 void pci_reset_secondary_bus(struct pci_dev *dev)

commit d6112f8def514e019658bcc9b57d53acdb71ca3f
Author: Felipe Balbi <felipe.balbi@linux.intel.com>
Date:   Fri Sep 7 09:16:51 2018 +0300

    PCI: Add support for Immediate Readiness
    
    PCIe r4.0, sec 7.5.1.1.4 defines a new bit in the Status Register:
    
      Immediate Readiness – This optional bit, when Set, indicates the Function
      is guaranteed to be ready to successfully complete valid configuration
      accesses at any time following any reset that the host is capable of
      issuing Configuration Requests to this Function.
    
      When this bit is Set, for accesses to this Function, software is exempt
      from all requirements to delay configuration accesses following any type
      of reset, including but not limited to the timing requirements defined in
      Section 6.6.
    
    This means that all delays after a Conventional or Function Reset can be
    skipped.
    
    This patch reads such bit and caches its value in a flag inside struct
    pci_dev to be checked later if we should delay or can skip delays after a
    reset.  While at that, also move the explicit msleep(100) call from
    pcie_flr() and pci_af_flr() to pci_dev_wait().
    
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    [bhelgaas: rename PCI_STATUS_IMMEDIATE to PCI_STATUS_IMM_READY]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 1835f3a7aa8d..ee7c2f4eef9b 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -999,7 +999,7 @@ static void __pci_start_power_transition(struct pci_dev *dev, pci_power_t state)
 		 * because have already delayed for the bridge.
 		 */
 		if (dev->runtime_d3cold) {
-			if (dev->d3cold_delay)
+			if (dev->d3cold_delay && !dev->imm_ready)
 				msleep(dev->d3cold_delay);
 			/*
 			 * When powering on a bridge from D3cold, the
@@ -2644,6 +2644,7 @@ EXPORT_SYMBOL_GPL(pci_d3cold_disable);
 void pci_pm_init(struct pci_dev *dev)
 {
 	int pm;
+	u16 status;
 	u16 pmc;
 
 	pm_runtime_forbid(&dev->dev);
@@ -2706,6 +2707,10 @@ void pci_pm_init(struct pci_dev *dev)
 		/* Disable the PME# generation functionality */
 		pci_pme_active(dev, false);
 	}
+
+	pci_read_config_word(dev, PCI_STATUS, &status);
+	if (status & PCI_STATUS_IMM_READY)
+		dev->imm_ready = 1;
 }
 
 static unsigned long pci_ea_flags(struct pci_dev *dev, u8 prop)
@@ -4376,6 +4381,9 @@ int pcie_flr(struct pci_dev *dev)
 
 	pcie_capability_set_word(dev, PCI_EXP_DEVCTL, PCI_EXP_DEVCTL_BCR_FLR);
 
+	if (dev->imm_ready)
+		return 0;
+
 	/*
 	 * Per PCIe r4.0, sec 6.6.2, a device must complete an FLR within
 	 * 100ms, but may silently discard requests while the FLR is in
@@ -4417,6 +4425,9 @@ static int pci_af_flr(struct pci_dev *dev, int probe)
 
 	pci_write_config_byte(dev, pos + PCI_AF_CTRL, PCI_AF_CTRL_FLR);
 
+	if (dev->imm_ready)
+		return 0;
+
 	/*
 	 * Per Advanced Capabilities for Conventional PCI ECN, 13 April 2006,
 	 * updated 27 July 2006; a device must complete an FLR within

commit 083874549fdfefa629dfa752785e20427dde1511
Author: Daniel Drake <drake@endlessm.com>
Date:   Thu Sep 27 15:47:33 2018 -0500

    PCI: Reprogram bridge prefetch registers on resume
    
    On 38+ Intel-based ASUS products, the NVIDIA GPU becomes unusable after S3
    suspend/resume.  The affected products include multiple generations of
    NVIDIA GPUs and Intel SoCs.  After resume, nouveau logs many errors such
    as:
    
      fifo: fault 00 [READ] at 0000005555555000 engine 00 [GR] client 04
            [HUB/FE] reason 4a [] on channel -1 [007fa91000 unknown]
      DRM: failed to idle channel 0 [DRM]
    
    Similarly, the NVIDIA proprietary driver also fails after resume (black
    screen, 100% CPU usage in Xorg process).  We shipped a sample to NVIDIA for
    diagnosis, and their response indicated that it's a problem with the parent
    PCI bridge (on the Intel SoC), not the GPU.
    
    Runtime suspend/resume works fine, only S3 suspend is affected.
    
    We found a workaround: on resume, rewrite the Intel PCI bridge
    'Prefetchable Base Upper 32 Bits' register (PCI_PREF_BASE_UPPER32).  In the
    cases that I checked, this register has value 0 and we just have to rewrite
    that value.
    
    Linux already saves and restores PCI config space during suspend/resume,
    but this register was being skipped because upon resume, it already has
    value 0 (the correct, pre-suspend value).
    
    Intel appear to have previously acknowledged this behaviour and the
    requirement to rewrite this register:
    https://bugzilla.kernel.org/show_bug.cgi?id=116851#c23
    
    Based on that, rewrite the prefetch register values even when that appears
    unnecessary.
    
    We have confirmed this solution on all the affected models we have in-hands
    (X542UQ, UX533FD, X530UN, V272UN).
    
    Additionally, this solves an issue where r8169 MSI-X interrupts were broken
    after S3 suspend/resume on ASUS X441UAR.  This issue was recently worked
    around in commit 7bb05b85bc2d ("r8169: don't use MSI-X on RTL8106e").  It
    also fixes the same issue on RTL6186evl/8111evl on an Aimfor-tech laptop
    that we had not yet patched.  I suspect it will also fix the issue that was
    worked around in commit 7c53a722459c ("r8169: don't use MSI-X on
    RTL8168g").
    
    Thomas Martitz reports that this change also solves an issue where the AMD
    Radeon Polaris 10 GPU on the HP Zbook 14u G5 is unresponsive after S3
    suspend/resume.
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=201069
    Signed-off-by: Daniel Drake <drake@endlessm.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-By: Peter Wu <peter@lekensteyn.nl>
    CC: stable@vger.kernel.org

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 1835f3a7aa8d..51b6c81671c1 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1289,12 +1289,12 @@ int pci_save_state(struct pci_dev *dev)
 EXPORT_SYMBOL(pci_save_state);
 
 static void pci_restore_config_dword(struct pci_dev *pdev, int offset,
-				     u32 saved_val, int retry)
+				     u32 saved_val, int retry, bool force)
 {
 	u32 val;
 
 	pci_read_config_dword(pdev, offset, &val);
-	if (val == saved_val)
+	if (!force && val == saved_val)
 		return;
 
 	for (;;) {
@@ -1313,25 +1313,36 @@ static void pci_restore_config_dword(struct pci_dev *pdev, int offset,
 }
 
 static void pci_restore_config_space_range(struct pci_dev *pdev,
-					   int start, int end, int retry)
+					   int start, int end, int retry,
+					   bool force)
 {
 	int index;
 
 	for (index = end; index >= start; index--)
 		pci_restore_config_dword(pdev, 4 * index,
 					 pdev->saved_config_space[index],
-					 retry);
+					 retry, force);
 }
 
 static void pci_restore_config_space(struct pci_dev *pdev)
 {
 	if (pdev->hdr_type == PCI_HEADER_TYPE_NORMAL) {
-		pci_restore_config_space_range(pdev, 10, 15, 0);
+		pci_restore_config_space_range(pdev, 10, 15, 0, false);
 		/* Restore BARs before the command register. */
-		pci_restore_config_space_range(pdev, 4, 9, 10);
-		pci_restore_config_space_range(pdev, 0, 3, 0);
+		pci_restore_config_space_range(pdev, 4, 9, 10, false);
+		pci_restore_config_space_range(pdev, 0, 3, 0, false);
+	} else if (pdev->hdr_type == PCI_HEADER_TYPE_BRIDGE) {
+		pci_restore_config_space_range(pdev, 12, 15, 0, false);
+
+		/*
+		 * Force rewriting of prefetch registers to avoid S3 resume
+		 * issues on Intel PCI bridges that occur when these
+		 * registers are not explicitly written.
+		 */
+		pci_restore_config_space_range(pdev, 9, 11, 0, true);
+		pci_restore_config_space_range(pdev, 0, 8, 0, false);
 	} else {
-		pci_restore_config_space_range(pdev, 0, 15, 0);
+		pci_restore_config_space_range(pdev, 0, 15, 0, false);
 	}
 }
 

commit c4eed62a214330908eec11b0dc170d34fa50b412
Author: Keith Busch <keith.busch@intel.com>
Date:   Thu Sep 20 10:27:11 2018 -0600

    PCI/ERR: Use slot reset if available
    
    The secondary bus reset may have link side effects that a hotplug capable
    port may incorrectly react to.  Use the slot specific reset for hotplug
    ports, fixing the undesirable link down-up handling during error
    recovering.
    
    Signed-off-by: Keith Busch <keith.busch@intel.com>
    [bhelgaas: fold in
    https://lore.kernel.org/linux-pci/20180926152326.14821-1-keith.busch@intel.com
    for issue reported by Stephen Rothwell <sfr@canb.auug.org.au>]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Sinan Kaya <okaya@kernel.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index d6bb56fbee6d..6916af269b19 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -35,6 +35,8 @@
 #include <linux/aer.h>
 #include "pci.h"
 
+DEFINE_MUTEX(pci_slot_mutex);
+
 const char *pci_power_names[] = {
 	"error", "D0", "D1", "D2", "D3hot", "D3cold", "unknown",
 };
@@ -5155,6 +5157,41 @@ static int pci_bus_reset(struct pci_bus *bus, int probe)
 	return ret;
 }
 
+/**
+ * pci_bus_error_reset - reset the bridge's subordinate bus
+ * @bridge: The parent device that connects to the bus to reset
+ *
+ * This function will first try to reset the slots on this bus if the method is
+ * available. If slot reset fails or is not available, this will fall back to a
+ * secondary bus reset.
+ */
+int pci_bus_error_reset(struct pci_dev *bridge)
+{
+	struct pci_bus *bus = bridge->subordinate;
+	struct pci_slot *slot;
+
+	if (!bus)
+		return -ENOTTY;
+
+	mutex_lock(&pci_slot_mutex);
+	if (list_empty(&bus->slots))
+		goto bus_reset;
+
+	list_for_each_entry(slot, &bus->slots, list)
+		if (pci_probe_reset_slot(slot))
+			goto bus_reset;
+
+	list_for_each_entry(slot, &bus->slots, list)
+		if (pci_slot_reset(slot, 0))
+			goto bus_reset;
+
+	mutex_unlock(&pci_slot_mutex);
+	return 0;
+bus_reset:
+	mutex_unlock(&pci_slot_mutex);
+	return pci_bus_reset(bridge->subordinate, 0);
+}
+
 /**
  * pci_probe_reset_bus - probe whether a PCI bus can be reset
  * @bus: PCI bus to probe

commit 4f802170a861265680cad03f47b19c4c3a137052
Author: Keith Busch <keith.busch@intel.com>
Date:   Thu Sep 20 10:27:08 2018 -0600

    PCI/DPC: Save and restore config state
    
    This patch provides DPC save and restore capabilities.  This is necessary
    for the driver to observe DPC events in the event the configuration space
    needs to be restored after a reset.
    
    Signed-off-by: Keith Busch <keith.busch@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Sinan Kaya <okaya@kernel.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 0e54588825cb..d6bb56fbee6d 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1284,6 +1284,7 @@ int pci_save_state(struct pci_dev *dev)
 	if (i != 0)
 		return i;
 
+	pci_save_dpc_state(dev);
 	return pci_save_vc_state(dev);
 }
 EXPORT_SYMBOL(pci_save_state);
@@ -1378,6 +1379,7 @@ void pci_restore_state(struct pci_dev *dev)
 	pci_restore_ats_state(dev);
 	pci_restore_vc_state(dev);
 	pci_restore_rebar_state(dev);
+	pci_restore_dpc_state(dev);
 
 	pci_cleanup_aer_error_status_regs(dev);
 

commit 81c4b5bf30de01a0f6b43ccaa1d220f4a0a5d99c
Author: Lukas Wunner <lukas@wunner.de>
Date:   Sat Sep 8 09:59:01 2018 +0200

    PCI: hotplug: Constify hotplug_slot_ops
    
    Hotplug drivers cannot declare their hotplug_slot_ops const, making them
    attractive targets for attackers, because upon registration of a hotplug
    slot, __pci_hp_initialize() writes to the "owner" and "mod_name" members
    in that struct.
    
    Fix by moving these members to struct hotplug_slot and constify every
    driver's hotplug_slot_ops except for pciehp.
    
    pciehp constructs its hotplug_slot_ops at runtime based on the PCIe
    port's capabilities, hence cannot declare them const.  It can be
    converted to __write_rarely once that's mainlined:
    http://www.openwall.com/lists/kernel-hardening/2016/11/16/3
    
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Tyrel Datwyler <tyreld@linux.vnet.ibm.com>  # drivers/pci/hotplug/rpa*
    Acked-by: Andy Shevchenko <andy.shevchenko@gmail.com> # drivers/platform/x86
    Cc: Len Brown <lenb@kernel.org>
    Cc: Scott Murray <scott@spiteful.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Oliver OHalloran <oliveroh@au1.ibm.com>
    Cc: Gavin Shan <gwshan@linux.vnet.ibm.com>
    Cc: Sebastian Ott <sebott@linux.vnet.ibm.com>
    Cc: Gerald Schaefer <gerald.schaefer@de.ibm.com>
    Cc: Corentin Chary <corentin.chary@gmail.com>
    Cc: Darren Hart <dvhart@infradead.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 1835f3a7aa8d..0e54588825cb 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -4571,13 +4571,13 @@ static int pci_reset_hotplug_slot(struct hotplug_slot *hotplug, int probe)
 {
 	int rc = -ENOTTY;
 
-	if (!hotplug || !try_module_get(hotplug->ops->owner))
+	if (!hotplug || !try_module_get(hotplug->owner))
 		return rc;
 
 	if (hotplug->ops->reset_slot)
 		rc = hotplug->ops->reset_slot(hotplug, probe);
 
-	module_put(hotplug->ops->owner);
+	module_put(hotplug->owner);
 
 	return rc;
 }

commit 7eb3702504c64425961ee9dd7080396a9477b7e1
Author: Randy Dunlap <rdunlap@infradead.org>
Date:   Sun Sep 2 19:32:50 2018 -0700

    PCI: Fix pci.c kernel-doc parameter warning
    
    Fix kernel-doc warning:
    
      ../drivers/pci/pci.c:218: warning: Excess function parameter 'p' description in 'pci_dev_str_match_path'
    
    Signed-off-by: Randy Dunlap <rdunlap@infradead.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index dc3313d26c79..455783d3acdf 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -196,7 +196,7 @@ EXPORT_SYMBOL_GPL(pci_ioremap_wc_bar);
 /**
  * pci_dev_str_match_path - test if a path string matches a device
  * @dev:    the PCI device to test
- * @p:      string to match the device against
+ * @path:   string to match the device against
  * @endptr: pointer to the string after the match
  *
  * Test if a string (typically from a kernel parameter) formatted as a

commit c6635792737b881021ead417b281067d56ed3380
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Thu Aug 30 13:32:36 2018 +0300

    PCI: Allocate dma_alias_mask with bitmap_zalloc()
    
    Switch to bitmap_zalloc() to show clearly what we are allocating.  Besides
    that it returns pointer of bitmap type ("unsigned long *") instead of the
    opaque "void *".
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 1835f3a7aa8d..dc3313d26c79 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -5690,8 +5690,7 @@ int pci_set_vga_state(struct pci_dev *dev, bool decode,
 void pci_add_dma_alias(struct pci_dev *dev, u8 devfn)
 {
 	if (!dev->dma_alias_mask)
-		dev->dma_alias_mask = kcalloc(BITS_TO_LONGS(U8_MAX),
-					      sizeof(long), GFP_KERNEL);
+		dev->dma_alias_mask = bitmap_zalloc(U8_MAX, GFP_KERNEL);
 	if (!dev->dma_alias_mask) {
 		pci_warn(dev, "Unable to allocate DMA alias mask\n");
 		return;

commit bfc456060d0cbcf6902a436d358b60cb1534668c
Author: Dennis Dalessandro <dennis.dalessandro@intel.com>
Date:   Fri Aug 31 10:34:14 2018 -0700

    IB/hfi1,PCI: Allow bus reset while probing
    
    Calling into the new API to reset the secondary bus results in a deadlock.
    This occurs because the device/bus is already locked at probe time.
    Reverting back to the old behavior while the API is improved.
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=200985
    Fixes: c6a44ba950d1 ("PCI: Rename pci_try_reset_bus() to pci_reset_bus()")
    Fixes: 409888e0966e ("IB/hfi1: Use pci_try_reset_bus() for initiating PCI Secondary Bus Reset")
    Signed-off-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Michael J. Ruhl <michael.j.ruhl@intel.com>
    Cc: Sinan Kaya <okaya@codeaurora.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 30b260332a10..1835f3a7aa8d 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -4547,6 +4547,7 @@ int pci_bridge_secondary_bus_reset(struct pci_dev *dev)
 
 	return pci_dev_wait(dev, "bus reset", PCIE_RESET_READY_POLL_MS);
 }
+EXPORT_SYMBOL_GPL(pci_bridge_secondary_bus_reset);
 
 static int pci_parent_bus_reset(struct pci_dev *dev, int probe)
 {

commit d8a5281035895cdb5ff77756eff72966ec76edd0
Author: Dennis Dalessandro <dennis.dalessandro@intel.com>
Date:   Wed Sep 5 16:08:03 2018 +0000

    PCI: Fix faulty logic in pci_reset_bus()
    
    The pci_reset_bus() function calls pci_probe_reset_slot() to determine
    whether to call the slot or bus reset.  The check has faulty logic in that
    it does not account for pci_probe_reset_slot() being able to return an
    errno.  Fix by only calling the slot reset when the function returns 0.
    
    Fixes: 811c5cb37df4 ("PCI: Unify try slot and bus reset API")
    Signed-off-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Michael J. Ruhl <michael.j.ruhl@intel.com>
    Cc: Sinan Kaya <okaya@codeaurora.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 29ff9619b5fa..30b260332a10 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -5200,7 +5200,7 @@ static int __pci_reset_bus(struct pci_bus *bus)
  */
 int pci_reset_bus(struct pci_dev *pdev)
 {
-	return pci_probe_reset_slot(pdev->slot) ?
+	return (!pci_probe_reset_slot(pdev->slot)) ?
 	    __pci_reset_slot(pdev->slot) : __pci_reset_bus(pdev->bus);
 }
 EXPORT_SYMBOL_GPL(pci_reset_bus);

commit 4e31843f681c34f7185e7d169fe627c9d891ce2c
Merge: f91e654474d4 fa687fb9ced4
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Aug 16 09:21:54 2018 -0700

    Merge tag 'pci-v4.19-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull pci updates from Bjorn Helgaas:
    
     - Decode AER errors with names similar to "lspci" (Tyler Baicar)
    
     - Expose AER statistics in sysfs (Rajat Jain)
    
     - Clear AER status bits selectively based on the type of recovery (Oza
       Pawandeep)
    
     - Honor "pcie_ports=native" even if HEST sets FIRMWARE_FIRST (Alexandru
       Gagniuc)
    
     - Don't clear AER status bits if we're using the "Firmware-First"
       strategy where firmware owns the registers (Alexandru Gagniuc)
    
     - Use sysfs_match_string() to simplify ASPM sysfs parsing (Andy
       Shevchenko)
    
     - Remove unnecessary includes of <linux/pci-aspm.h> (Bjorn Helgaas)
    
     - Defer DPC event handling to work queue (Keith Busch)
    
     - Use threaded IRQ for DPC bottom half (Keith Busch)
    
     - Print AER status while handling DPC events (Keith Busch)
    
     - Work around IDT switch ACS Source Validation erratum (James
       Puthukattukaran)
    
     - Emit diagnostics for all cases of PCIe Link downtraining (Links
       operating slower than they're capable of) (Alexandru Gagniuc)
    
     - Skip VFs when configuring Max Payload Size (Myron Stowe)
    
     - Reduce Root Port Max Payload Size if necessary when hot-adding a
       device below it (Myron Stowe)
    
     - Simplify SHPC existence/permission checks (Bjorn Helgaas)
    
     - Remove hotplug sample skeleton driver (Lukas Wunner)
    
     - Convert pciehp to threaded IRQ handling (Lukas Wunner)
    
     - Improve pciehp tolerance of missed events and initially unstable
       links (Lukas Wunner)
    
     - Clear spurious pciehp events on resume (Lukas Wunner)
    
     - Add pciehp runtime PM support, including for Thunderbolt controllers
       (Lukas Wunner)
    
     - Support interrupts from pciehp bridges in D3hot (Lukas Wunner)
    
     - Mark fall-through switch cases before enabling -Wimplicit-fallthrough
       (Gustavo A. R. Silva)
    
     - Move DMA-debug PCI init from arch code to PCI core (Christoph
       Hellwig)
    
     - Fix pci_request_irq() usage of IRQF_ONESHOT when no handler is
       supplied (Heiner Kallweit)
    
     - Unify PCI and DMA direction #defines (Shunyong Yang)
    
     - Add PCI_DEVICE_DATA() macro (Andy Shevchenko)
    
     - Check for VPD completion before checking for timeout (Bert Kenward)
    
     - Limit Netronome NFP5000 config space size to work around erratum
       (Jakub Kicinski)
    
     - Set IRQCHIP_ONESHOT_SAFE for PCI MSI irqchips (Heiner Kallweit)
    
     - Document ACPI description of PCI host bridges (Bjorn Helgaas)
    
     - Add "pci=disable_acs_redir=" parameter to disable ACS redirection for
       peer-to-peer DMA support (we don't have the peer-to-peer support yet;
       this is just one piece) (Logan Gunthorpe)
    
     - Clean up devm_of_pci_get_host_bridge_resources() resource allocation
       (Jan Kiszka)
    
     - Fixup resizable BARs after suspend/resume (Christian König)
    
     - Make "pci=earlydump" generic (Sinan Kaya)
    
     - Fix ROM BAR access routines to stay in bounds and check for signature
       correctly (Rex Zhu)
    
     - Add DMA alias quirk for Microsemi Switchtec NTB (Doug Meyer)
    
     - Expand documentation for pci_add_dma_alias() (Logan Gunthorpe)
    
     - To avoid bus errors, enable PASID only if entire path supports
       End-End TLP prefixes (Sinan Kaya)
    
     - Unify slot and bus reset functions and remove hotplug knowledge from
       callers (Sinan Kaya)
    
     - Add Function-Level Reset quirks for Intel and Samsung NVMe devices to
       fix guest reboot issues (Alex Williamson)
    
     - Add function 1 DMA alias quirk for Marvell 88SS9183 PCIe SSD
       Controller (Bjorn Helgaas)
    
     - Remove Xilinx AXI-PCIe host bridge arch dependency (Palmer Dabbelt)
    
     - Remove Aardvark outbound window configuration (Evan Wang)
    
     - Fix Aardvark bridge window sizing issue (Zachary Zhang)
    
     - Convert Aardvark to use pci_host_probe() to reduce code duplication
       (Thomas Petazzoni)
    
     - Correct the Cadence cdns_pcie_writel() signature (Alan Douglas)
    
     - Add Cadence support for optional generic PHYs (Alan Douglas)
    
     - Add Cadence power management ops (Alan Douglas)
    
     - Remove redundant variable from Cadence driver (Colin Ian King)
    
     - Add Kirin MSI support (Xiaowei Song)
    
     - Drop unnecessary root_bus_nr setting from exynos, imx6, keystone,
       armada8k, artpec6, designware-plat, histb, qcom, spear13xx (Shawn
       Guo)
    
     - Move link notification settings from DesignWare core to individual
       drivers (Gustavo Pimentel)
    
     - Add endpoint library MSI-X interfaces (Gustavo Pimentel)
    
     - Correct signature of endpoint library IRQ interfaces (Gustavo
       Pimentel)
    
     - Add DesignWare endpoint library MSI-X callbacks (Gustavo Pimentel)
    
     - Add endpoint library MSI-X test support (Gustavo Pimentel)
    
     - Remove unnecessary GFP_ATOMIC from Hyper-V "new child" allocation
       (Jia-Ju Bai)
    
     - Add more devices to Broadcom PAXC quirk (Ray Jui)
    
     - Work around corrupted Broadcom PAXC config space to enable SMMU and
       GICv3 ITS (Ray Jui)
    
     - Disable MSI parsing to work around broken Broadcom PAXC logic in some
       devices (Ray Jui)
    
     - Hide unconfigured functions to work around a Broadcom PAXC defect
       (Ray Jui)
    
     - Lower iproc log level to reduce console output during boot (Ray Jui)
    
     - Fix mobiveil iomem/phys_addr_t type usage (Lorenzo Pieralisi)
    
     - Fix mobiveil missing include file (Lorenzo Pieralisi)
    
     - Add mobiveil Kconfig/Makefile support (Lorenzo Pieralisi)
    
     - Fix mvebu I/O space remapping issues (Thomas Petazzoni)
    
     - Use generic pci_host_bridge in mvebu instead of ARM-specific API
       (Thomas Petazzoni)
    
     - Whitelist VMD devices with fast interrupt handlers to avoid sharing
       vectors with slow handlers (Keith Busch)
    
    * tag 'pci-v4.19-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (153 commits)
      PCI/AER: Don't clear AER bits if error handling is Firmware-First
      PCI: Limit config space size for Netronome NFP5000
      PCI/MSI: Set IRQCHIP_ONESHOT_SAFE for PCI-MSI irqchips
      PCI/VPD: Check for VPD access completion before checking for timeout
      PCI: Add PCI_DEVICE_DATA() macro to fully describe device ID entry
      PCI: Match Root Port's MPS to endpoint's MPSS as necessary
      PCI: Skip MPS logic for Virtual Functions (VFs)
      PCI: Add function 1 DMA alias quirk for Marvell 88SS9183
      PCI: Check for PCIe Link downtraining
      PCI: Add ACS Redirect disable quirk for Intel Sunrise Point
      PCI: Add device-specific ACS Redirect disable infrastructure
      PCI: Convert device-specific ACS quirks from NULL termination to ARRAY_SIZE
      PCI: Add "pci=disable_acs_redir=" parameter for peer-to-peer support
      PCI: Allow specifying devices using a base bus and path of devfns
      PCI: Make specifying PCI devices in kernel parameters reusable
      PCI: Hide ACS quirk declarations inside PCI core
      PCI: Delay after FLR of Intel DC P3700 NVMe
      PCI: Disable Samsung SM961/PM961 NVMe before FLR
      PCI: Export pcie_has_flr()
      PCI: mvebu: Drop bogus comment above mvebu_pcie_map_registers()
      ...

commit 3a48dc6fc260c9cac302a9ffaeab95359431c485
Merge: e7aaf90f9d9d 7695e73f3db4
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Aug 15 14:59:06 2018 -0500

    Merge branch 'pci/virtualization'
    
      - To avoid bus errors, enable PASID only if entire path supports End-End
        TLP prefixes (Sinan Kaya)
    
      - Unify slot and bus reset functions and remove hotplug knowledge from
        callers (Sinan Kaya)
    
      - Add Function-Level Reset quirks for Intel and Samsung NVMe devices to
        fix guest reboot issues (Alex Williamson)
    
      - Add function 1 DMA alias quirk for Marvell 88SS9183 PCIe SSD Controller
        (Bjorn Helgaas)
    
    * pci/virtualization:
      PCI: Add function 1 DMA alias quirk for Marvell 88SS9183
      PCI: Delay after FLR of Intel DC P3700 NVMe
      PCI: Disable Samsung SM961/PM961 NVMe before FLR
      PCI: Export pcie_has_flr()
      PCI: Rename pci_try_reset_bus() to pci_reset_bus()
      PCI: Deprecate pci_reset_bus() and pci_reset_slot() functions
      PCI: Unify try slot and bus reset API
      PCI: Hide pci_reset_bridge_secondary_bus() from drivers
      IB/hfi1: Use pci_try_reset_bus() for initiating PCI Secondary Bus Reset
      PCI: Handle error return from pci_reset_bridge_secondary_bus()
      PCI/IOV: Tidy pci_sriov_set_totalvfs()
      PCI: Enable PASID only if entire path supports End-End TLP prefixes
    
    # Conflicts:
    #       drivers/pci/hotplug/pciehp_hpc.c

commit e7aaf90f9d9dbbba54f67c653a1c56c2bf117268
Merge: 5fc054a54476 f778a0d26fe3
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Aug 15 14:59:03 2018 -0500

    Merge branch 'pci/switchtec'
    
      - Add DMA alias quirk for Microsemi Switchtec NTB (Doug Meyer)
    
      - Expand documentation for pci_add_dma_alias() (Logan Gunthorpe)
    
    * pci/switchtec:
      PCI: Expand documentation for pci_add_dma_alias()
      PCI: Add DMA alias quirk for Microsemi Switchtec NTB
      switchtec: Use generic PCI Vendor ID and Class Code
    
    # Conflicts:
    #       drivers/pci/quirks.c

commit 5fc054a54476f9e2b3d6cc3eeb1537aa549d0ba3
Merge: c689209be231 783e84961b1d
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Aug 15 14:59:01 2018 -0500

    Merge branch 'pci/resource'
    
      - Clean up devm_of_pci_get_host_bridge_resources() resource allocation
        (Jan Kiszka)
    
      - Fixup resizable BARs after suspend/resume (Christian König)
    
      - Make "pci=earlydump" generic (Sinan Kaya)
    
      - Fix ROM BAR access routines to stay in bounds and check for signature
        correctly (Rex Zhu)
    
    * pci/resource:
      PCI: Make pci_get_rom_size() static
      PCI: Add check code for last image indicator not set
      PCI: Avoid accessing memory outside the ROM BAR
      PCI: Make early dump functionality generic
      PCI: Cleanup PCI_REBAR_CTRL_BAR_SHIFT handling
      PCI: Restore resized BAR state on resume
      PCI: Clean up resource allocation in devm_of_pci_get_host_bridge_resources()
    
    # Conflicts:
    #       Documentation/admin-guide/kernel-parameters.txt

commit c689209be23166b340c224df8ecd5deea163da56
Merge: eadf3d320943 10dbc9fedcf1
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Aug 15 14:58:58 2018 -0500

    Merge branch 'pci/peer-to-peer'
    
      - Add "pci=disable_acs_redir=" parameter to disable ACS redirection for
        peer-to-peer DMA support (we don't have the peer-to-peer support yet;
        this is just one piece) (Logan Gunthorpe)
    
    * pci/peer-to-peer:
      PCI: Add ACS Redirect disable quirk for Intel Sunrise Point
      PCI: Add device-specific ACS Redirect disable infrastructure
      PCI: Convert device-specific ACS quirks from NULL termination to ARRAY_SIZE
      PCI: Add "pci=disable_acs_redir=" parameter for peer-to-peer support
      PCI: Allow specifying devices using a base bus and path of devfns
      PCI: Make specifying PCI devices in kernel parameters reusable
      PCI: Hide ACS quirk declarations inside PCI core

commit a40f72db8a3770ea135f4f48a007256fd1519549
Merge: c0638a455382 2538fb89b8f4
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Aug 15 14:58:54 2018 -0500

    Merge branch 'pci/misc'
    
      - Mark fall-through switch cases before enabling -Wimplicit-fallthrough
        (Gustavo A. R. Silva)
    
      - Move DMA-debug PCI init from arch code to PCI core (Christoph Hellwig)
    
      - Fix pci_request_irq() usage of IRQF_ONESHOT when no handler is supplied
        (Heiner Kallweit)
    
      - Unify PCI and DMA direction #defines (Shunyong Yang)
    
      - Add PCI_DEVICE_DATA() macro (Andy Shevchenko)
    
      - Check for VPD completion before checking for timeout (Bert Kenward)
    
      - Limit Netronome NFP5000 config space size to work around erratum (Jakub
        Kicinski)
    
    * pci/misc:
      PCI: Limit config space size for Netronome NFP5000
      PCI/VPD: Check for VPD access completion before checking for timeout
      PCI: Add PCI_DEVICE_DATA() macro to fully describe device ID entry
      PCI: Unify PCI and normal DMA direction definitions
      PCI: Use IRQF_ONESHOT if pci_request_irq() called with no handler
      PCI: Call dma_debug_add_bus() for pci_bus_type from PCI core
      PCI: Mark fall-through switch cases before enabling -Wimplicit-fallthrough
    
    # Conflicts:
    #       drivers/pci/hotplug/pciehp_ctrl.c

commit c0638a455382e01e42bf66d8d41e4b703f1550a5
Merge: a8bcb5e5966c 4e6a13356f1c
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Aug 15 14:58:52 2018 -0500

    Merge branch 'pci/hotplug'
    
      - Simplify SHPC existence/permission checks (Bjorn Helgaas)
    
      - Remove hotplug sample skeleton driver (Lukas Wunner)
    
      - Convert pciehp to threaded IRQ handling (Lukas Wunner)
    
      - Improve pciehp tolerance of missed events and initially unstable links
        (Lukas Wunner)
    
      - Clear spurious pciehp events on resume (Lukas Wunner)
    
      - Add pciehp runtime PM support, including for Thunderbolt controllers
        (Lukas Wunner)
    
      - Support interrupts from pciehp bridges in D3hot (Lukas Wunner)
    
    * pci/hotplug:
      PCI: pciehp: Deduplicate presence check on probe & resume
      PCI: pciehp: Avoid implicit fallthroughs in switch statements
      PCI: Whitelist Thunderbolt ports for runtime D3
      PCI: Whitelist native hotplug ports for runtime D3
      PCI: sysfs: Resume to D0 on function reset
      PCI: pciehp: Resume parent to D0 on config space access
      PCI: pciehp: Resume to D0 on enable/disable
      PCI: pciehp: Support interrupts sent from D3hot
      PCI: pciehp: Obey compulsory command delay after resume
      PCI: pciehp: Clear spurious events earlier on resume
      PCI: portdrv: Deduplicate PM callback iterator
      PCI: pciehp: Avoid slot access during reset
      PCI: pciehp: Always enable occupied slot on probe
      PCI: pciehp: Become resilient to missed events
      PCI: pciehp: Tolerate initially unstable link
      PCI: pciehp: Declare pciehp_enable/disable_slot() static
      PCI: pciehp: Drop enable/disable lock
      PCI: pciehp: Enable/disable exclusively from IRQ thread
      PCI: pciehp: Track enable/disable status
      PCI: pciehp: Publish to user space last on probe
      PCI: hotplug: Demidlayer registration with the core
      PCI: pciehp: Drop slot workqueue
      PCI: pciehp: Handle events synchronously
      PCI: pciehp: Stop blinking on slot enable failure
      PCI: pciehp: Convert to threaded polling
      PCI: pciehp: Convert to threaded IRQ
      PCI: pciehp: Document struct slot and struct controller
      PCI: pciehp: Declare pciehp_unconfigure_device() void
      PCI: pciehp: Drop unnecessary NULL pointer check
      PCI: pciehp: Fix unprotected list iteration in IRQ handler
      PCI: pciehp: Fix use-after-free on unplug
      PCI: hotplug: Don't leak pci_slot on registration failure
      PCI: hotplug: Delete skeleton driver
      PCI: shpchp: Separate existence of SHPC and permission to use it

commit a8bcb5e5966ccbd99a6d06cf69ada7f95416aabc
Merge: 1ca358a8e3ff 9f0e89359775
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Aug 15 14:58:52 2018 -0500

    Merge branch 'pci/enumeration'
    
      - Work around IDT switch ACS Source Validation erratum (James
        Puthukattukaran)
    
      - Emit diagnostics for all cases of PCIe Link downtraining (Links
        operating slower than they're capable of) (Alexandru Gagniuc)
    
      - Skip VFs when configuring Max Payload Size (Myron Stowe)
    
      - Reduce Root Port Max Payload Size if necessary when hot-adding a device
        below it (Myron Stowe)
    
    * pci/enumeration:
      PCI: Match Root Port's MPS to endpoint's MPSS as necessary
      PCI: Skip MPS logic for Virtual Functions (VFs)
      PCI: Check for PCIe Link downtraining
      PCI: Workaround IDT switch ACS Source Validation erratum

commit 187dacce194216c4d86c2afd0ca490a6d7fbb981
Merge: 3c3ab37f4c03 ce29af2a5056
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Aug 15 14:58:46 2018 -0500

    Merge branch 'pci/aspm'
    
      - Use sysfs_match_string() to simplify ASPM sysfs parsing (Andy
        Shevchenko)
    
      - Remove unnecessary includes of <linux/pci-aspm.h> (Bjorn Helgaas)
    
    * pci/aspm:
      PCI: Remove unnecessary include of <linux/pci-aspm.h>
      iwlwifi: Remove unnecessary include of <linux/pci-aspm.h>
      ath9k: Remove unnecessary include of <linux/pci-aspm.h>
      igb: Remove unnecessary include of <linux/pci-aspm.h>
      PCI/ASPM: Convert to use sysfs_match_string() helper

commit 2d1ce5ec2117d16047334a1aa4b62e0cfb5a0605
Author: Alexandru Gagniuc <mr.nuke.me@gmail.com>
Date:   Mon Aug 6 18:25:35 2018 -0500

    PCI: Check for PCIe Link downtraining
    
    When both ends of a PCIe Link are capable of a higher bandwidth than is
    currently in use, the Link is said to be "downtrained".  A downtrained Link
    may indicate hardware or configuration problems in the system, but it's
    hard to identify such Links from userspace.
    
    Refactor pcie_print_link_status() so it continues to always print PCIe
    bandwidth information, as several NIC drivers desire.
    
    Add a new internal __pcie_print_link_status() to emit a message only when a
    device's bandwidth is constrained by the fabric and call it from the PCI
    core for all devices, which identifies all downtrained Links.  It also
    emits messages for a few cases that are technically not downtrained, such
    as a x4 device in an open-ended x1 slot.
    
    Signed-off-by: Alexandru Gagniuc <mr.nuke.me@gmail.com>
    [bhelgaas: changelog, move __pcie_print_link_status() declaration to
    drivers/pci/, rename pcie_check_upstream_link() to
    pcie_report_downtraining()]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 97acba712e4e..a84d341504a5 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -5264,14 +5264,16 @@ u32 pcie_bandwidth_capable(struct pci_dev *dev, enum pci_bus_speed *speed,
 }
 
 /**
- * pcie_print_link_status - Report the PCI device's link speed and width
+ * __pcie_print_link_status - Report the PCI device's link speed and width
  * @dev: PCI device to query
+ * @verbose: Print info even when enough bandwidth is available
  *
- * Report the available bandwidth at the device.  If this is less than the
- * device is capable of, report the device's maximum possible bandwidth and
- * the upstream link that limits its performance to less than that.
+ * If the available bandwidth at the device is less than the device is
+ * capable of, report the device's maximum possible bandwidth and the
+ * upstream link that limits its performance.  If @verbose, always print
+ * the available bandwidth, even if the device isn't constrained.
  */
-void pcie_print_link_status(struct pci_dev *dev)
+void __pcie_print_link_status(struct pci_dev *dev, bool verbose)
 {
 	enum pcie_link_width width, width_cap;
 	enum pci_bus_speed speed, speed_cap;
@@ -5281,11 +5283,11 @@ void pcie_print_link_status(struct pci_dev *dev)
 	bw_cap = pcie_bandwidth_capable(dev, &speed_cap, &width_cap);
 	bw_avail = pcie_bandwidth_available(dev, &limiting_dev, &speed, &width);
 
-	if (bw_avail >= bw_cap)
+	if (bw_avail >= bw_cap && verbose)
 		pci_info(dev, "%u.%03u Gb/s available PCIe bandwidth (%s x%d link)\n",
 			 bw_cap / 1000, bw_cap % 1000,
 			 PCIE_SPEED2STR(speed_cap), width_cap);
-	else
+	else if (bw_avail < bw_cap)
 		pci_info(dev, "%u.%03u Gb/s available PCIe bandwidth, limited by %s x%d link at %s (capable of %u.%03u Gb/s with %s x%d link)\n",
 			 bw_avail / 1000, bw_avail % 1000,
 			 PCIE_SPEED2STR(speed), width,
@@ -5293,6 +5295,17 @@ void pcie_print_link_status(struct pci_dev *dev)
 			 bw_cap / 1000, bw_cap % 1000,
 			 PCIE_SPEED2STR(speed_cap), width_cap);
 }
+
+/**
+ * pcie_print_link_status - Report the PCI device's link speed and width
+ * @dev: PCI device to query
+ *
+ * Report the available bandwidth at the device.
+ */
+void pcie_print_link_status(struct pci_dev *dev)
+{
+	__pcie_print_link_status(dev, true);
+}
 EXPORT_SYMBOL(pcie_print_link_status);
 
 /**

commit 73c47ddef29b5869a2221e93cefdb56fd8263718
Author: Logan Gunthorpe <logang@deltatee.com>
Date:   Thu Aug 9 16:51:43 2018 -0500

    PCI: Add device-specific ACS Redirect disable infrastructure
    
    Intel Sunrise Point (SPT) PCH hardware has an implementation of the ACS
    bits that does not comply with the PCIe standard.  To deal with this we
    need device-specific quirks to disable ACS redirection.
    
    Add a new pci_dev_specific_disable_acs_redir() quirk and a new
    .disable_acs_redir() function pointer for use by non-compliant devices.  No
    functional change intended.
    
    Signed-off-by: Logan Gunthorpe <logang@deltatee.com>
    [bhelgaas: split to separate patch, move
    pci_dev_specific_disable_acs_redir() declarations to drivers/pci/pci.h]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Alex Williamson <alex.williamson@redhat.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 822577d9b39e..17d8de109556 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -3023,6 +3023,9 @@ static void pci_disable_acs_redir(struct pci_dev *dev)
 	if (ret != 1)
 		return;
 
+	if (!pci_dev_specific_disable_acs_redir(dev))
+		return;
+
 	pos = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ACS);
 	if (!pos) {
 		pci_warn(dev, "cannot disable ACS redirect for this hardware as it does not have ACS capabilities\n");

commit aaca43fda742223e4f62bd73e13055f5364e9a9b
Author: Logan Gunthorpe <logang@deltatee.com>
Date:   Mon Jul 30 10:18:40 2018 -0600

    PCI: Add "pci=disable_acs_redir=" parameter for peer-to-peer support
    
    To support peer-to-peer traffic on a segment of the PCI hierarchy, we must
    disable the ACS redirect bits for select PCI bridges.  The bridges must be
    selected before the devices are discovered by the kernel and the IOMMU
    groups created.  Therefore, add a kernel command line parameter to specify
    devices which must have their ACS bits disabled.
    
    The new parameter takes a list of devices separated by a semicolon.  Each
    device specified will have its ACS redirect bits disabled.  This is
    similar to the existing 'resource_alignment' parameter.
    
    The ACS Request P2P Request Redirect, P2P Completion Redirect and P2P
    Egress Control bits are disabled, which is sufficient to always allow
    passing P2P traffic uninterrupted.  The bits are set after the kernel
    (optionally) enables the ACS bits itself.  It is also done regardless of
    whether the kernel or platform firmware sets the bits.
    
    If the user tries to disable the ACS redirect for a device without the ACS
    capability, print a warning to dmesg.
    
    Signed-off-by: Logan Gunthorpe <logang@deltatee.com>
    [bhelgaas: reorder to add the generic code first and move the
    device-specific quirk to subsequent patches]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Stephen Bates <sbates@raithlin.com>
    Reviewed-by: Alex Williamson <alex.williamson@redhat.com>
    Acked-by: Christian König <christian.koenig@amd.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index a6c38b15ac33..822577d9b39e 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2982,6 +2982,63 @@ void pci_request_acs(void)
 	pci_acs_enable = 1;
 }
 
+static const char *disable_acs_redir_param;
+
+/**
+ * pci_disable_acs_redir - disable ACS redirect capabilities
+ * @dev: the PCI device
+ *
+ * For only devices specified in the disable_acs_redir parameter.
+ */
+static void pci_disable_acs_redir(struct pci_dev *dev)
+{
+	int ret = 0;
+	const char *p;
+	int pos;
+	u16 ctrl;
+
+	if (!disable_acs_redir_param)
+		return;
+
+	p = disable_acs_redir_param;
+	while (*p) {
+		ret = pci_dev_str_match(dev, p, &p);
+		if (ret < 0) {
+			pr_info_once("PCI: Can't parse disable_acs_redir parameter: %s\n",
+				     disable_acs_redir_param);
+
+			break;
+		} else if (ret == 1) {
+			/* Found a match */
+			break;
+		}
+
+		if (*p != ';' && *p != ',') {
+			/* End of param or invalid format */
+			break;
+		}
+		p++;
+	}
+
+	if (ret != 1)
+		return;
+
+	pos = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ACS);
+	if (!pos) {
+		pci_warn(dev, "cannot disable ACS redirect for this hardware as it does not have ACS capabilities\n");
+		return;
+	}
+
+	pci_read_config_word(dev, pos + PCI_ACS_CTRL, &ctrl);
+
+	/* P2P Request & Completion Redirect */
+	ctrl &= ~(PCI_ACS_RR | PCI_ACS_CR | PCI_ACS_EC);
+
+	pci_write_config_word(dev, pos + PCI_ACS_CTRL, ctrl);
+
+	pci_info(dev, "disabled ACS redirect\n");
+}
+
 /**
  * pci_std_enable_acs - enable ACS on devices using standard ACS capabilites
  * @dev: the PCI device
@@ -3021,12 +3078,22 @@ static void pci_std_enable_acs(struct pci_dev *dev)
 void pci_enable_acs(struct pci_dev *dev)
 {
 	if (!pci_acs_enable)
-		return;
+		goto disable_acs_redir;
 
 	if (!pci_dev_specific_enable_acs(dev))
-		return;
+		goto disable_acs_redir;
 
 	pci_std_enable_acs(dev);
+
+disable_acs_redir:
+	/*
+	 * Note: pci_disable_acs_redir() must be called even if ACS was not
+	 * enabled by the kernel because it may have been enabled by
+	 * platform firmware.  So if we are told to disable it, we should
+	 * always disable it after setting the kernel's default
+	 * preferences.
+	 */
+	pci_disable_acs_redir(dev);
 }
 
 static bool pci_acs_flags_enabled(struct pci_dev *pdev, u16 acs_flags)
@@ -5966,6 +6033,8 @@ static int __init pci_setup(char *str)
 				pcie_bus_config = PCIE_BUS_PEER2PEER;
 			} else if (!strncmp(str, "pcie_scan_all", 13)) {
 				pci_add_flags(PCI_SCAN_ALL_PCIE_DEVS);
+			} else if (!strncmp(str, "disable_acs_redir=", 18)) {
+				disable_acs_redir_param = str + 18;
 			} else {
 				printk(KERN_ERR "PCI: Unknown option `%s'\n",
 						str);

commit 45db33709ccc7330c55fc6751c96468de407f2ac
Author: Logan Gunthorpe <logang@deltatee.com>
Date:   Mon Jul 30 10:18:38 2018 -0600

    PCI: Allow specifying devices using a base bus and path of devfns
    
    When specifying PCI devices on the kernel command line using a
    bus/device/function address, bus numbers can change when adding or
    replacing a device, changing motherboard firmware, or applying kernel
    parameters like "pci=assign-buses".  When bus numbers change, it's likely
    the command line tweak will be applied to the wrong device.
    
    Therefore, it is useful to be able to specify devices with a base bus
    number and the path of devfns needed to get to it, similar to the "device
    scope" structure in the Intel VT-d spec, Section 8.3.1.
    
    Thus, we add an option to specify devices in the following format:
    
      [<domain>:]<bus>:<device>.<func>[/<device>.<func>]*
    
    The path can be any segment within the PCI hierarchy of any length and
    determined through the use of 'lspci -t'.  When specified this way, it is
    less likely that a renumbered bus will result in a valid device
    specification and the tweak won't be applied to the wrong device.
    
    Signed-off-by: Logan Gunthorpe <logang@deltatee.com>
    [bhelgaas: use "device" instead of "slot" in documentation since that's the
    usual language in the PCI specs]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Stephen Bates <sbates@raithlin.com>
    Reviewed-by: Alex Williamson <alex.williamson@redhat.com>
    Acked-by: Christian König <christian.koenig@amd.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 1574b2da25e7..a6c38b15ac33 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -191,6 +191,89 @@ void __iomem *pci_ioremap_wc_bar(struct pci_dev *pdev, int bar)
 EXPORT_SYMBOL_GPL(pci_ioremap_wc_bar);
 #endif
 
+/**
+ * pci_dev_str_match_path - test if a path string matches a device
+ * @dev:    the PCI device to test
+ * @p:      string to match the device against
+ * @endptr: pointer to the string after the match
+ *
+ * Test if a string (typically from a kernel parameter) formatted as a
+ * path of device/function addresses matches a PCI device. The string must
+ * be of the form:
+ *
+ *   [<domain>:]<bus>:<device>.<func>[/<device>.<func>]*
+ *
+ * A path for a device can be obtained using 'lspci -t'.  Using a path
+ * is more robust against bus renumbering than using only a single bus,
+ * device and function address.
+ *
+ * Returns 1 if the string matches the device, 0 if it does not and
+ * a negative error code if it fails to parse the string.
+ */
+static int pci_dev_str_match_path(struct pci_dev *dev, const char *path,
+				  const char **endptr)
+{
+	int ret;
+	int seg, bus, slot, func;
+	char *wpath, *p;
+	char end;
+
+	*endptr = strchrnul(path, ';');
+
+	wpath = kmemdup_nul(path, *endptr - path, GFP_KERNEL);
+	if (!wpath)
+		return -ENOMEM;
+
+	while (1) {
+		p = strrchr(wpath, '/');
+		if (!p)
+			break;
+		ret = sscanf(p, "/%x.%x%c", &slot, &func, &end);
+		if (ret != 2) {
+			ret = -EINVAL;
+			goto free_and_exit;
+		}
+
+		if (dev->devfn != PCI_DEVFN(slot, func)) {
+			ret = 0;
+			goto free_and_exit;
+		}
+
+		/*
+		 * Note: we don't need to get a reference to the upstream
+		 * bridge because we hold a reference to the top level
+		 * device which should hold a reference to the bridge,
+		 * and so on.
+		 */
+		dev = pci_upstream_bridge(dev);
+		if (!dev) {
+			ret = 0;
+			goto free_and_exit;
+		}
+
+		*p = 0;
+	}
+
+	ret = sscanf(wpath, "%x:%x:%x.%x%c", &seg, &bus, &slot,
+		     &func, &end);
+	if (ret != 4) {
+		seg = 0;
+		ret = sscanf(wpath, "%x:%x.%x%c", &bus, &slot, &func, &end);
+		if (ret != 3) {
+			ret = -EINVAL;
+			goto free_and_exit;
+		}
+	}
+
+	ret = (seg == pci_domain_nr(dev->bus) &&
+	       bus == dev->bus->number &&
+	       dev->devfn == PCI_DEVFN(slot, func));
+
+free_and_exit:
+	kfree(wpath);
+	return ret;
+}
+
 /**
  * pci_dev_str_match - test if a string matches a device
  * @dev:    the PCI device to test
@@ -200,13 +283,16 @@ EXPORT_SYMBOL_GPL(pci_ioremap_wc_bar);
  * Test if a string (typically from a kernel parameter) matches a specified
  * PCI device. The string may be of one of the following formats:
  *
- *   [<domain>:]<bus>:<device>.<func>
+ *   [<domain>:]<bus>:<device>.<func>[/<device>.<func>]*
  *   pci:<vendor>:<device>[:<subvendor>:<subdevice>]
  *
  * The first format specifies a PCI bus/device/function address which
  * may change if new hardware is inserted, if motherboard firmware changes,
  * or due to changes caused in kernel parameters. If the domain is
- * left unspecified, it is taken to be 0.
+ * left unspecified, it is taken to be 0.  In order to be robust against
+ * bus renumbering issues, a path of PCI device/function numbers may be used
+ * to address the specific device.  The path for a device can be determined
+ * through the use of 'lspci -t'.
  *
  * The second format matches devices using IDs in the configuration
  * space which may match multiple devices in the system. A value of 0
@@ -222,7 +308,7 @@ static int pci_dev_str_match(struct pci_dev *dev, const char *p,
 			     const char **endptr)
 {
 	int ret;
-	int seg, bus, slot, func, count;
+	int count;
 	unsigned short vendor, device, subsystem_vendor, subsystem_device;
 
 	if (strncmp(p, "pci:", 4) == 0) {
@@ -248,25 +334,15 @@ static int pci_dev_str_match(struct pci_dev *dev, const char *p,
 		    (!subsystem_device ||
 			    subsystem_device == dev->subsystem_device))
 			goto found;
-
 	} else {
-		/* PCI Bus, Device, Function IDs are specified */
-		ret = sscanf(p, "%x:%x:%x.%x%n", &seg, &bus, &slot,
-			     &func, &count);
-		if (ret != 4) {
-			seg = 0;
-			ret = sscanf(p, "%x:%x.%x%n", &bus, &slot,
-				     &func, &count);
-			if (ret != 3)
-				return -EINVAL;
-		}
-
-		p += count;
-
-		if (seg == pci_domain_nr(dev->bus) &&
-		    bus == dev->bus->number &&
-		    slot == PCI_SLOT(dev->devfn) &&
-		    func == PCI_FUNC(dev->devfn))
+		/*
+		 * PCI Bus, Device, Function IDs are specified
+		 *  (optionally, may include a path of devfns following it)
+		 */
+		ret = pci_dev_str_match_path(dev, p, &p);
+		if (ret < 0)
+			return ret;
+		else if (ret)
 			goto found;
 	}
 

commit 07d8d7e57c28ca9a07dab4efd75dad3a654aeb85
Author: Logan Gunthorpe <logang@deltatee.com>
Date:   Mon Jul 30 10:18:37 2018 -0600

    PCI: Make specifying PCI devices in kernel parameters reusable
    
    Separate out the code to match a PCI device with a string (typically
    originating from a kernel parameter) from the
    pci_specified_resource_alignment() function into its own helper function.
    
    While we are at it, this change fixes the kernel style of the function
    (fixing a number of long lines and extra parentheses).
    
    Additionally, make the analogous change to the kernel parameter
    documentation: Separate the description of how to specify a PCI device
    into its own section at the head of the "pci=" parameter.
    
    This patch should have no functional alterations.
    
    Signed-off-by: Logan Gunthorpe <logang@deltatee.com>
    [bhelgaas: use "device" instead of "slot" in documentation since that's the
    usual language in the PCI specs]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Stephen Bates <sbates@raithlin.com>
    Reviewed-by: Alex Williamson <alex.williamson@redhat.com>
    Acked-by: Christian König <christian.koenig@amd.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 97acba712e4e..1574b2da25e7 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -191,6 +191,92 @@ void __iomem *pci_ioremap_wc_bar(struct pci_dev *pdev, int bar)
 EXPORT_SYMBOL_GPL(pci_ioremap_wc_bar);
 #endif
 
+/**
+ * pci_dev_str_match - test if a string matches a device
+ * @dev:    the PCI device to test
+ * @p:      string to match the device against
+ * @endptr: pointer to the string after the match
+ *
+ * Test if a string (typically from a kernel parameter) matches a specified
+ * PCI device. The string may be of one of the following formats:
+ *
+ *   [<domain>:]<bus>:<device>.<func>
+ *   pci:<vendor>:<device>[:<subvendor>:<subdevice>]
+ *
+ * The first format specifies a PCI bus/device/function address which
+ * may change if new hardware is inserted, if motherboard firmware changes,
+ * or due to changes caused in kernel parameters. If the domain is
+ * left unspecified, it is taken to be 0.
+ *
+ * The second format matches devices using IDs in the configuration
+ * space which may match multiple devices in the system. A value of 0
+ * for any field will match all devices. (Note: this differs from
+ * in-kernel code that uses PCI_ANY_ID which is ~0; this is for
+ * legacy reasons and convenience so users don't have to specify
+ * FFFFFFFFs on the command line.)
+ *
+ * Returns 1 if the string matches the device, 0 if it does not and
+ * a negative error code if the string cannot be parsed.
+ */
+static int pci_dev_str_match(struct pci_dev *dev, const char *p,
+			     const char **endptr)
+{
+	int ret;
+	int seg, bus, slot, func, count;
+	unsigned short vendor, device, subsystem_vendor, subsystem_device;
+
+	if (strncmp(p, "pci:", 4) == 0) {
+		/* PCI vendor/device (subvendor/subdevice) IDs are specified */
+		p += 4;
+		ret = sscanf(p, "%hx:%hx:%hx:%hx%n", &vendor, &device,
+			     &subsystem_vendor, &subsystem_device, &count);
+		if (ret != 4) {
+			ret = sscanf(p, "%hx:%hx%n", &vendor, &device, &count);
+			if (ret != 2)
+				return -EINVAL;
+
+			subsystem_vendor = 0;
+			subsystem_device = 0;
+		}
+
+		p += count;
+
+		if ((!vendor || vendor == dev->vendor) &&
+		    (!device || device == dev->device) &&
+		    (!subsystem_vendor ||
+			    subsystem_vendor == dev->subsystem_vendor) &&
+		    (!subsystem_device ||
+			    subsystem_device == dev->subsystem_device))
+			goto found;
+
+	} else {
+		/* PCI Bus, Device, Function IDs are specified */
+		ret = sscanf(p, "%x:%x:%x.%x%n", &seg, &bus, &slot,
+			     &func, &count);
+		if (ret != 4) {
+			seg = 0;
+			ret = sscanf(p, "%x:%x.%x%n", &bus, &slot,
+				     &func, &count);
+			if (ret != 3)
+				return -EINVAL;
+		}
+
+		p += count;
+
+		if (seg == pci_domain_nr(dev->bus) &&
+		    bus == dev->bus->number &&
+		    slot == PCI_SLOT(dev->devfn) &&
+		    func == PCI_FUNC(dev->devfn))
+			goto found;
+	}
+
+	*endptr = p;
+	return 0;
+
+found:
+	*endptr = p;
+	return 1;
+}
 
 static int __pci_find_next_cap_ttl(struct pci_bus *bus, unsigned int devfn,
 				   u8 pos, int cap, int *ttl)
@@ -5454,10 +5540,10 @@ static DEFINE_SPINLOCK(resource_alignment_lock);
 static resource_size_t pci_specified_resource_alignment(struct pci_dev *dev,
 							bool *resize)
 {
-	int seg, bus, slot, func, align_order, count;
-	unsigned short vendor, device, subsystem_vendor, subsystem_device;
+	int align_order, count;
 	resource_size_t align = pcibios_default_alignment();
-	char *p;
+	const char *p;
+	int ret;
 
 	spin_lock(&resource_alignment_lock);
 	p = resource_alignment_param;
@@ -5477,58 +5563,21 @@ static resource_size_t pci_specified_resource_alignment(struct pci_dev *dev,
 		} else {
 			align_order = -1;
 		}
-		if (strncmp(p, "pci:", 4) == 0) {
-			/* PCI vendor/device (subvendor/subdevice) ids are specified */
-			p += 4;
-			if (sscanf(p, "%hx:%hx:%hx:%hx%n",
-				&vendor, &device, &subsystem_vendor, &subsystem_device, &count) != 4) {
-				if (sscanf(p, "%hx:%hx%n", &vendor, &device, &count) != 2) {
-					printk(KERN_ERR "PCI: Can't parse resource_alignment parameter: pci:%s\n",
-						p);
-					break;
-				}
-				subsystem_vendor = subsystem_device = 0;
-			}
-			p += count;
-			if ((!vendor || (vendor == dev->vendor)) &&
-				(!device || (device == dev->device)) &&
-				(!subsystem_vendor || (subsystem_vendor == dev->subsystem_vendor)) &&
-				(!subsystem_device || (subsystem_device == dev->subsystem_device))) {
-				*resize = true;
-				if (align_order == -1)
-					align = PAGE_SIZE;
-				else
-					align = 1 << align_order;
-				/* Found */
-				break;
-			}
-		}
-		else {
-			if (sscanf(p, "%x:%x:%x.%x%n",
-				&seg, &bus, &slot, &func, &count) != 4) {
-				seg = 0;
-				if (sscanf(p, "%x:%x.%x%n",
-						&bus, &slot, &func, &count) != 3) {
-					/* Invalid format */
-					printk(KERN_ERR "PCI: Can't parse resource_alignment parameter: %s\n",
-						p);
-					break;
-				}
-			}
-			p += count;
-			if (seg == pci_domain_nr(dev->bus) &&
-				bus == dev->bus->number &&
-				slot == PCI_SLOT(dev->devfn) &&
-				func == PCI_FUNC(dev->devfn)) {
-				*resize = true;
-				if (align_order == -1)
-					align = PAGE_SIZE;
-				else
-					align = 1 << align_order;
-				/* Found */
-				break;
-			}
+
+		ret = pci_dev_str_match(dev, p, &p);
+		if (ret == 1) {
+			*resize = true;
+			if (align_order == -1)
+				align = PAGE_SIZE;
+			else
+				align = 1 << align_order;
+			break;
+		} else if (ret < 0) {
+			pr_err("PCI: Can't parse resource_alignment parameter: %s\n",
+			       p);
+			break;
 		}
+
 		if (*p != ';' && *p != ',') {
 			/* End of param or invalid format */
 			break;

commit 2d2917f7747805a1f4188672f308d82a8ba01700
Author: Alex Williamson <alex.williamson@redhat.com>
Date:   Thu Aug 9 14:04:14 2018 -0600

    PCI: Export pcie_has_flr()
    
    pcie_flr() suggests pcie_has_flr() to ensure that PCIe FLR support is
    present prior to calling.  pcie_flr() is exported while pcie_has_flr()
    is not.  Resolve this.
    
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index d123c2b173da..85e5b80a69a7 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -4039,7 +4039,7 @@ static int pci_dev_wait(struct pci_dev *dev, char *reset_type, int timeout)
  * Returns true if the device advertises support for PCIe function level
  * resets.
  */
-static bool pcie_has_flr(struct pci_dev *dev)
+bool pcie_has_flr(struct pci_dev *dev)
 {
 	u32 cap;
 
@@ -4049,6 +4049,7 @@ static bool pcie_has_flr(struct pci_dev *dev)
 	pcie_capability_read_dword(dev, PCI_EXP_DEVCAP, &cap);
 	return cap & PCI_EXP_DEVCAP_FLR;
 }
+EXPORT_SYMBOL_GPL(pcie_has_flr);
 
 /**
  * pcie_flr - initiate a PCIe function level reset

commit ce29af2a505627cc8f1deddb84bcbaf186b0bfd5
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Jul 25 14:53:42 2018 -0500

    PCI: Remove unnecessary include of <linux/pci-aspm.h>
    
    Several PCI core files include pci-aspm.h even though they don't need
    anything provided by that file.  Remove the unnecessary includes of it.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Sinan Kaya <okaya@kernel.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 97acba712e4e..d92d216e4f64 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -23,7 +23,6 @@
 #include <linux/string.h>
 #include <linux/log2.h>
 #include <linux/logic_pio.h>
-#include <linux/pci-aspm.h>
 #include <linux/pm_wakeup.h>
 #include <linux/interrupt.h>
 #include <linux/device.h>

commit 47a8e237ed443c174f8f73402755c458c56eb611
Author: Lukas Wunner <lukas@wunner.de>
Date:   Thu Jul 19 17:28:00 2018 -0500

    PCI: Whitelist Thunderbolt ports for runtime D3
    
    Thunderbolt controllers can be runtime suspended to D3cold to save ~1.5W.
    This requires that runtime D3 is allowed on its PCIe ports, so whitelist
    them.
    
    The 2015 BIOS cutoff that we've instituted for runtime D3 on PCIe ports
    is unnecessary on Thunderbolt because we know that even the oldest
    controller, Light Ridge (2010), is able to suspend its ports to D3 just
    fine -- specifically including its hotplug ports.  And the power saving
    should be afforded to machines even if their BIOS predates 2015.
    
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Cc: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: Andreas Noever <andreas.noever@gmail.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 4099a6c14b6d..c4d10726c59a 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2290,7 +2290,7 @@ void pci_config_pm_runtime_put(struct pci_dev *pdev)
  * @bridge: Bridge to check
  *
  * This function checks if it is possible to move the bridge to D3.
- * Currently we only allow D3 for recent enough PCIe ports.
+ * Currently we only allow D3 for recent enough PCIe ports and Thunderbolt.
  */
 bool pci_bridge_d3_possible(struct pci_dev *bridge)
 {
@@ -2314,6 +2314,10 @@ bool pci_bridge_d3_possible(struct pci_dev *bridge)
 		if (pci_bridge_d3_force)
 			return true;
 
+		/* Even the oldest 2010 Thunderbolt controller supports D3. */
+		if (bridge->is_thunderbolt)
+			return true;
+
 		/*
 		 * Hotplug ports handled natively by the OS were not validated
 		 * by vendors for runtime D3 at least until 2018 because there

commit eb3b5bf1a88d0cc1cd7acc7464eb211d69779808
Author: Lukas Wunner <lukas@wunner.de>
Date:   Thu Jul 19 17:27:59 2018 -0500

    PCI: Whitelist native hotplug ports for runtime D3
    
    Previously we blacklisted PCIe hotplug ports for runtime D3 because:
    
    (a) Ports handled by the firmware must not be transitioned to D3 by the
        OS behind the firmware's back:
        https://bugzilla.kernel.org/show_bug.cgi?id=53811
    
    (b) Ports handled natively by the OS lacked runtime D3 support in the
        pciehp driver.
    
    We've just rectified the latter, so allow users to manually enable and
    test it by passing pcie_port_pm=force on the command line.  Vendors are
    thus put in a position to validate hotplug ports for runtime D3 and
    perhaps we can someday enable it by default, but with a BIOS cutoff date.
    
    Ashok Raj tested runtime D3 on hotplug ports of a SkyLake Xeon-SP in
    2017 and encountered Hardware Error NMIs, so this feature clearly cannot
    be enabled for everyone yet:
    https://lkml.kernel.org/r/20170503180426.GA4058@otc-nc-03
    
    While at it, remove an erroneous code comment I added with 97a90aee5dab
    ("PCI: Consolidate conditions to allow runtime PM on PCIe ports") which
    claims that parents of a hotplug port must stay awake lest interrupts
    cannot be delivered.  That has turned out to be wrong at least for
    Thunderbolt hotplug ports.
    
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: Mika Westerberg <mika.westerberg@linux.intel.com>
    Cc: Ashok Raj <ashok.raj@intel.com>
    Cc: Keith Busch <keith.busch@intel.com>
    Cc: Yinghai Lu <yinghai@kernel.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 97acba712e4e..4099a6c14b6d 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2305,18 +2305,23 @@ bool pci_bridge_d3_possible(struct pci_dev *bridge)
 			return false;
 
 		/*
-		 * Hotplug interrupts cannot be delivered if the link is down,
-		 * so parents of a hotplug port must stay awake. In addition,
-		 * hotplug ports handled by firmware in System Management Mode
+		 * Hotplug ports handled by firmware in System Management Mode
 		 * may not be put into D3 by the OS (Thunderbolt on non-Macs).
-		 * For simplicity, disallow in general for now.
 		 */
-		if (bridge->is_hotplug_bridge)
+		if (bridge->is_hotplug_bridge && !pciehp_is_native(bridge))
 			return false;
 
 		if (pci_bridge_d3_force)
 			return true;
 
+		/*
+		 * Hotplug ports handled natively by the OS were not validated
+		 * by vendors for runtime D3 at least until 2018 because there
+		 * was no OS support.
+		 */
+		if (bridge->is_hotplug_bridge)
+			return false;
+
 		/*
 		 * It should be safe to put PCIe ports from 2015 or newer
 		 * to D3.

commit 3fce4618279373efc59a91adb16c11da46cd69e5
Merge: ecd7963f7cf9 acb1872577b3
Author: Dave Airlie <airlied@redhat.com>
Date:   Mon Jul 30 10:39:22 2018 +1000

    BackMerge v4.18-rc7 into drm-next
    
    rmk requested this for armada and I think we've had a few
    conflicts build up.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>

commit c6a44ba950d147e15fe6dab6455a52f91d8fe625
Author: Sinan Kaya <okaya@codeaurora.org>
Date:   Thu Jul 19 18:04:15 2018 -0500

    PCI: Rename pci_try_reset_bus() to pci_reset_bus()
    
    Now that the old implementation of pci_reset_bus() is gone, replace
    pci_try_reset_bus() with pci_reset_bus().
    
    Compared to the old implementation, new code will fail immmediately with
    -EAGAIN if object lock cannot be obtained.
    
    Signed-off-by: Sinan Kaya <okaya@codeaurora.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 8ee9f386c1ee..d123c2b173da 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -4784,7 +4784,7 @@ int pci_probe_reset_slot(struct pci_slot *slot)
 EXPORT_SYMBOL_GPL(pci_probe_reset_slot);
 
 /**
- * __pci_try_reset_slot - Try to reset a PCI slot
+ * __pci_reset_slot - Try to reset a PCI slot
  * @slot: PCI slot to reset
  *
  * A PCI bus may host multiple slots, each slot may support a reset mechanism
@@ -4798,7 +4798,7 @@ EXPORT_SYMBOL_GPL(pci_probe_reset_slot);
  *
  * Same as above except return -EAGAIN if the slot cannot be locked
  */
-static int __pci_try_reset_slot(struct pci_slot *slot)
+static int __pci_reset_slot(struct pci_slot *slot)
 {
 	int rc;
 
@@ -4854,12 +4854,12 @@ int pci_probe_reset_bus(struct pci_bus *bus)
 EXPORT_SYMBOL_GPL(pci_probe_reset_bus);
 
 /**
- * __pci_try_reset_bus - Try to reset a PCI bus
+ * __pci_reset_bus - Try to reset a PCI bus
  * @bus: top level PCI bus to reset
  *
  * Same as above except return -EAGAIN if the bus cannot be locked
  */
-static int __pci_try_reset_bus(struct pci_bus *bus)
+static int __pci_reset_bus(struct pci_bus *bus)
 {
 	int rc;
 
@@ -4882,17 +4882,17 @@ static int __pci_try_reset_bus(struct pci_bus *bus)
 }
 
 /**
- * pci_try_reset_bus - Try to reset a PCI bus
+ * pci_reset_bus - Try to reset a PCI bus
  * @pdev: top level PCI device to reset via slot/bus
  *
  * Same as above except return -EAGAIN if the bus cannot be locked
  */
-int pci_try_reset_bus(struct pci_dev *pdev)
+int pci_reset_bus(struct pci_dev *pdev)
 {
 	return pci_probe_reset_slot(pdev->slot) ?
-	    __pci_try_reset_slot(pdev->slot) : __pci_try_reset_bus(pdev->bus);
+	    __pci_reset_slot(pdev->slot) : __pci_reset_bus(pdev->bus);
 }
-EXPORT_SYMBOL_GPL(pci_try_reset_bus);
+EXPORT_SYMBOL_GPL(pci_reset_bus);
 
 /**
  * pcix_get_max_mmrbc - get PCI-X maximum designed memory read byte count

commit fe32e2fa656c29d5d25f959f8e6168ac405d9ab4
Author: Sinan Kaya <okaya@codeaurora.org>
Date:   Thu Jul 19 18:04:14 2018 -0500

    PCI: Deprecate pci_reset_bus() and pci_reset_slot() functions
    
    pci_reset_bus() and pci_reset_slot() functions are not being used by any
    code.  Remove them from the kernel in favor of pci_try_reset_bus() and
    pci_try_reset_slot() functions.
    
    Signed-off-by: Sinan Kaya <okaya@codeaurora.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index a31e6dbf21c3..8ee9f386c1ee 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -4784,7 +4784,7 @@ int pci_probe_reset_slot(struct pci_slot *slot)
 EXPORT_SYMBOL_GPL(pci_probe_reset_slot);
 
 /**
- * pci_reset_slot - reset a PCI slot
+ * __pci_try_reset_slot - Try to reset a PCI slot
  * @slot: PCI slot to reset
  *
  * A PCI bus may host multiple slots, each slot may support a reset mechanism
@@ -4796,30 +4796,6 @@ EXPORT_SYMBOL_GPL(pci_probe_reset_slot);
  * through this function.  PCI config space of all devices in the slot and
  * behind the slot is saved before and restored after reset.
  *
- * Return 0 on success, non-zero on error.
- */
-int pci_reset_slot(struct pci_slot *slot)
-{
-	int rc;
-
-	rc = pci_slot_reset(slot, 1);
-	if (rc)
-		return rc;
-
-	pci_slot_save_and_disable(slot);
-
-	rc = pci_slot_reset(slot, 0);
-
-	pci_slot_restore(slot);
-
-	return rc;
-}
-EXPORT_SYMBOL_GPL(pci_reset_slot);
-
-/**
- * __pci_try_reset_slot - Try to reset a PCI slot
- * @slot: PCI slot to reset
- *
  * Same as above except return -EAGAIN if the slot cannot be locked
  */
 static int __pci_try_reset_slot(struct pci_slot *slot)
@@ -4877,33 +4853,6 @@ int pci_probe_reset_bus(struct pci_bus *bus)
 }
 EXPORT_SYMBOL_GPL(pci_probe_reset_bus);
 
-/**
- * pci_reset_bus - reset a PCI bus
- * @bus: top level PCI bus to reset
- *
- * Do a bus reset on the given bus and any subordinate buses, saving
- * and restoring state of all devices.
- *
- * Return 0 on success, non-zero on error.
- */
-int pci_reset_bus(struct pci_bus *bus)
-{
-	int rc;
-
-	rc = pci_bus_reset(bus, 1);
-	if (rc)
-		return rc;
-
-	pci_bus_save_and_disable(bus);
-
-	rc = pci_bus_reset(bus, 0);
-
-	pci_bus_restore(bus);
-
-	return rc;
-}
-EXPORT_SYMBOL_GPL(pci_reset_bus);
-
 /**
  * __pci_try_reset_bus - Try to reset a PCI bus
  * @bus: top level PCI bus to reset

commit 811c5cb37df46b0cd714dbd053d19cdb97d08cff
Author: Sinan Kaya <okaya@codeaurora.org>
Date:   Thu Jul 19 18:04:12 2018 -0500

    PCI: Unify try slot and bus reset API
    
    Drivers are expected to call pci_try_reset_slot() or pci_try_reset_bus() by
    querying if a system supports hotplug or not.  A survey showed that most
    drivers don't do this and we are leaking hotplug capability to the user.
    
    Hide pci_try_slot_reset() from drivers and embed into pci_try_bus_reset().
    Change pci_try_reset_bus() parameter from struct pci_bus to struct pci_dev.
    
    Signed-off-by: Sinan Kaya <okaya@codeaurora.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 236220cb0f77..a31e6dbf21c3 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -4817,12 +4817,12 @@ int pci_reset_slot(struct pci_slot *slot)
 EXPORT_SYMBOL_GPL(pci_reset_slot);
 
 /**
- * pci_try_reset_slot - Try to reset a PCI slot
+ * __pci_try_reset_slot - Try to reset a PCI slot
  * @slot: PCI slot to reset
  *
  * Same as above except return -EAGAIN if the slot cannot be locked
  */
-int pci_try_reset_slot(struct pci_slot *slot)
+static int __pci_try_reset_slot(struct pci_slot *slot)
 {
 	int rc;
 
@@ -4843,7 +4843,6 @@ int pci_try_reset_slot(struct pci_slot *slot)
 
 	return rc;
 }
-EXPORT_SYMBOL_GPL(pci_try_reset_slot);
 
 static int pci_bus_reset(struct pci_bus *bus, int probe)
 {
@@ -4906,12 +4905,12 @@ int pci_reset_bus(struct pci_bus *bus)
 EXPORT_SYMBOL_GPL(pci_reset_bus);
 
 /**
- * pci_try_reset_bus - Try to reset a PCI bus
+ * __pci_try_reset_bus - Try to reset a PCI bus
  * @bus: top level PCI bus to reset
  *
  * Same as above except return -EAGAIN if the bus cannot be locked
  */
-int pci_try_reset_bus(struct pci_bus *bus)
+static int __pci_try_reset_bus(struct pci_bus *bus)
 {
 	int rc;
 
@@ -4932,6 +4931,18 @@ int pci_try_reset_bus(struct pci_bus *bus)
 
 	return rc;
 }
+
+/**
+ * pci_try_reset_bus - Try to reset a PCI bus
+ * @pdev: top level PCI device to reset via slot/bus
+ *
+ * Same as above except return -EAGAIN if the bus cannot be locked
+ */
+int pci_try_reset_bus(struct pci_dev *pdev)
+{
+	return pci_probe_reset_slot(pdev->slot) ?
+	    __pci_try_reset_slot(pdev->slot) : __pci_try_reset_bus(pdev->bus);
+}
 EXPORT_SYMBOL_GPL(pci_try_reset_bus);
 
 /**

commit 381634cad15b711e033a2638d558232b60f753f6
Author: Sinan Kaya <okaya@codeaurora.org>
Date:   Thu Jul 19 18:04:11 2018 -0500

    PCI: Hide pci_reset_bridge_secondary_bus() from drivers
    
    Rename pci_reset_bridge_secondary_bus() to pci_bridge_secondary_bus_reset()
    and move the declaration from linux/pci.h to drivers/pci.h to be used
    internally in PCI directory only.
    
    Signed-off-by: Sinan Kaya <okaya@codeaurora.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 98d149070205..236220cb0f77 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -4224,19 +4224,18 @@ void __weak pcibios_reset_secondary_bus(struct pci_dev *dev)
 }
 
 /**
- * pci_reset_bridge_secondary_bus - Reset the secondary bus on a PCI bridge.
+ * pci_bridge_secondary_bus_reset - Reset the secondary bus on a PCI bridge.
  * @dev: Bridge device
  *
  * Use the bridge control register to assert reset on the secondary bus.
  * Devices on the secondary bus are left in power-on state.
  */
-int pci_reset_bridge_secondary_bus(struct pci_dev *dev)
+int pci_bridge_secondary_bus_reset(struct pci_dev *dev)
 {
 	pcibios_reset_secondary_bus(dev);
 
 	return pci_dev_wait(dev, "bus reset", PCIE_RESET_READY_POLL_MS);
 }
-EXPORT_SYMBOL_GPL(pci_reset_bridge_secondary_bus);
 
 static int pci_parent_bus_reset(struct pci_dev *dev, int probe)
 {
@@ -4253,7 +4252,7 @@ static int pci_parent_bus_reset(struct pci_dev *dev, int probe)
 	if (probe)
 		return 0;
 
-	return pci_reset_bridge_secondary_bus(dev->bus->self);
+	return pci_bridge_secondary_bus_reset(dev->bus->self);
 }
 
 static int pci_reset_hotplug_slot(struct hotplug_slot *hotplug, int probe)
@@ -4860,7 +4859,7 @@ static int pci_bus_reset(struct pci_bus *bus, int probe)
 
 	might_sleep();
 
-	ret = pci_reset_bridge_secondary_bus(bus->self);
+	ret = pci_bridge_secondary_bus_reset(bus->self);
 
 	pci_bus_unlock(bus);
 
@@ -4924,7 +4923,7 @@ int pci_try_reset_bus(struct pci_bus *bus)
 
 	if (pci_bus_trylock(bus)) {
 		might_sleep();
-		rc = pci_reset_bridge_secondary_bus(bus->self);
+		rc = pci_bridge_secondary_bus_reset(bus->self);
 		pci_bus_unlock(bus);
 	} else
 		rc = -EAGAIN;

commit 1842623850d09b0b1147d4974573aa305658d97f
Author: Sinan Kaya <okaya@codeaurora.org>
Date:   Thu Jul 19 18:04:09 2018 -0500

    PCI: Handle error return from pci_reset_bridge_secondary_bus()
    
    Commit 01fd61c0b9bd ("PCI: Add a return type for
    pci_reset_bridge_secondary_bus()") added a return value to the function to
    return if a device is accessible following a reset.  Callers are not
    checking the value.
    
    Pass error code up high in the stack if device is not accessible.
    
    Fixes: 01fd61c0b9bd ("PCI: Add a return type for pci_reset_bridge_secondary_bus()")
    Signed-off-by: Sinan Kaya <okaya@codeaurora.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 97acba712e4e..98d149070205 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -4253,9 +4253,7 @@ static int pci_parent_bus_reset(struct pci_dev *dev, int probe)
 	if (probe)
 		return 0;
 
-	pci_reset_bridge_secondary_bus(dev->bus->self);
-
-	return 0;
+	return pci_reset_bridge_secondary_bus(dev->bus->self);
 }
 
 static int pci_reset_hotplug_slot(struct hotplug_slot *hotplug, int probe)
@@ -4850,6 +4848,8 @@ EXPORT_SYMBOL_GPL(pci_try_reset_slot);
 
 static int pci_bus_reset(struct pci_bus *bus, int probe)
 {
+	int ret;
+
 	if (!bus->self || !pci_bus_resetable(bus))
 		return -ENOTTY;
 
@@ -4860,11 +4860,11 @@ static int pci_bus_reset(struct pci_bus *bus, int probe)
 
 	might_sleep();
 
-	pci_reset_bridge_secondary_bus(bus->self);
+	ret = pci_reset_bridge_secondary_bus(bus->self);
 
 	pci_bus_unlock(bus);
 
-	return 0;
+	return ret;
 }
 
 /**
@@ -4924,7 +4924,7 @@ int pci_try_reset_bus(struct pci_bus *bus)
 
 	if (pci_bus_trylock(bus)) {
 		might_sleep();
-		pci_reset_bridge_secondary_bus(bus->self);
+		rc = pci_reset_bridge_secondary_bus(bus->self);
 		pci_bus_unlock(bus);
 	} else
 		rc = -EAGAIN;

commit a5fb9fb023a1435f2b42bccd7f547560f3a21dc3
Author: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
Date:   Wed Jul 18 15:40:26 2018 -0500

    PCI: OF: Fix I/O space page leak
    
    When testing the R-Car PCIe driver on the Condor board, if the PCIe PHY
    driver was left disabled, the kernel crashed with this BUG:
    
      kernel BUG at lib/ioremap.c:72!
      Internal error: Oops - BUG: 0 [#1] PREEMPT SMP
      Modules linked in:
      CPU: 0 PID: 39 Comm: kworker/0:1 Not tainted 4.17.0-dirty #1092
      Hardware name: Renesas Condor board based on r8a77980 (DT)
      Workqueue: events deferred_probe_work_func
      pstate: 80000005 (Nzcv daif -PAN -UAO)
      pc : ioremap_page_range+0x370/0x3c8
      lr : ioremap_page_range+0x40/0x3c8
      sp : ffff000008da39e0
      x29: ffff000008da39e0 x28: 00e8000000000f07
      x27: ffff7dfffee00000 x26: 0140000000000000
      x25: ffff7dfffef00000 x24: 00000000000fe100
      x23: ffff80007b906000 x22: ffff000008ab8000
      x21: ffff000008bb1d58 x20: ffff7dfffef00000
      x19: ffff800009c30fb8 x18: 0000000000000001
      x17: 00000000000152d0 x16: 00000000014012d0
      x15: 0000000000000000 x14: 0720072007200720
      x13: 0720072007200720 x12: 0720072007200720
      x11: 0720072007300730 x10: 00000000000000ae
      x9 : 0000000000000000 x8 : ffff7dffff000000
      x7 : 0000000000000000 x6 : 0000000000000100
      x5 : 0000000000000000 x4 : 000000007b906000
      x3 : ffff80007c61a880 x2 : ffff7dfffeefffff
      x1 : 0000000040000000 x0 : 00e80000fe100f07
      Process kworker/0:1 (pid: 39, stack limit = 0x        (ptrval))
      Call trace:
       ioremap_page_range+0x370/0x3c8
       pci_remap_iospace+0x7c/0xac
       pci_parse_request_of_pci_ranges+0x13c/0x190
       rcar_pcie_probe+0x4c/0xb04
       platform_drv_probe+0x50/0xbc
       driver_probe_device+0x21c/0x308
       __device_attach_driver+0x98/0xc8
       bus_for_each_drv+0x54/0x94
       __device_attach+0xc4/0x12c
       device_initial_probe+0x10/0x18
       bus_probe_device+0x90/0x98
       deferred_probe_work_func+0xb0/0x150
       process_one_work+0x12c/0x29c
       worker_thread+0x200/0x3fc
       kthread+0x108/0x134
       ret_from_fork+0x10/0x18
      Code: f9004ba2 54000080 aa0003fb 17ffff48 (d4210000)
    
    It turned out that pci_remap_iospace() wasn't undone when the driver's
    probe failed, and since devm_phy_optional_get() returned -EPROBE_DEFER,
    the probe was retried, finally causing the BUG due to trying to remap
    already remapped pages.
    
    Introduce the devm_pci_remap_iospace() managed API and replace the
    pci_remap_iospace() call with it to fix the bug.
    
    Fixes: dbf9826d5797 ("PCI: generic: Convert to DT resource parsing API")
    Signed-off-by: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
    [lorenzo.pieralisi@arm.com: split commit/updated the commit log]
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 97acba712e4e..316496e99da9 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -3579,6 +3579,44 @@ void pci_unmap_iospace(struct resource *res)
 }
 EXPORT_SYMBOL(pci_unmap_iospace);
 
+static void devm_pci_unmap_iospace(struct device *dev, void *ptr)
+{
+	struct resource **res = ptr;
+
+	pci_unmap_iospace(*res);
+}
+
+/**
+ * devm_pci_remap_iospace - Managed pci_remap_iospace()
+ * @dev: Generic device to remap IO address for
+ * @res: Resource describing the I/O space
+ * @phys_addr: physical address of range to be mapped
+ *
+ * Managed pci_remap_iospace().  Map is automatically unmapped on driver
+ * detach.
+ */
+int devm_pci_remap_iospace(struct device *dev, const struct resource *res,
+			   phys_addr_t phys_addr)
+{
+	const struct resource **ptr;
+	int error;
+
+	ptr = devres_alloc(devm_pci_unmap_iospace, sizeof(*ptr), GFP_KERNEL);
+	if (!ptr)
+		return -ENOMEM;
+
+	error = pci_remap_iospace(res, phys_addr);
+	if (error) {
+		devres_free(ptr);
+	} else	{
+		*ptr = res;
+		devres_add(dev, ptr);
+	}
+
+	return error;
+}
+EXPORT_SYMBOL(devm_pci_remap_iospace);
+
 /**
  * devm_pci_remap_cfgspace - Managed pci_remap_cfgspace()
  * @dev: Generic device to remap IO address for

commit d6488ac19aabcc6c85a74b69eaf1b7301124c323
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Thu Jul 5 09:56:00 2018 -0500

    PCI: Mark fall-through switch cases before enabling -Wimplicit-fallthrough
    
    In preparation to enabling -Wimplicit-fallthrough, mark switch cases where
    we are expecting to fall through.
    
    Warning level 2 was used: -Wimplicit-fallthrough=2
    
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 97acba712e4e..f5c6ab14fb31 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2045,6 +2045,7 @@ static pci_power_t pci_target_state(struct pci_dev *dev, bool wakeup)
 		case PCI_D2:
 			if (pci_no_d1d2(dev))
 				break;
+			/* else: fall through */
 		default:
 			target_state = state;
 		}

commit 576c7218a1546e0153480b208b125509cec71470
Author: Alex Deucher <alexander.deucher@amd.com>
Date:   Mon Jun 25 13:17:41 2018 -0500

    PCI: Export pcie_get_speed_cap and pcie_get_width_cap
    
    So drivers can use them.  This can be used to replace
    duplicate code in the drm subsystem.
    
    Acked-by: Christian König <christian.koenig@amd.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 97acba712e4e..22adaf35b136 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -5222,6 +5222,7 @@ enum pci_bus_speed pcie_get_speed_cap(struct pci_dev *dev)
 
 	return PCI_SPEED_UNKNOWN;
 }
+EXPORT_SYMBOL(pcie_get_speed_cap);
 
 /**
  * pcie_get_width_cap - query for the PCI device's link width capability
@@ -5240,6 +5241,7 @@ enum pcie_link_width pcie_get_width_cap(struct pci_dev *dev)
 
 	return PCIE_LNK_WIDTH_UNKNOWN;
 }
+EXPORT_SYMBOL(pcie_get_width_cap);
 
 /**
  * pcie_bandwidth_capable - calculate a PCI device's link bandwidth capability

commit f778a0d26fe3912424401e7b997155094de36487
Author: Logan Gunthorpe <logang@deltatee.com>
Date:   Wed May 30 14:13:11 2018 -0600

    PCI: Expand documentation for pci_add_dma_alias()
    
    Seeing there's been some confusion about the use of pci_add_dma_alias(),
    expand the comment to describe why it must be called early and how
    early it must be called.
    
    Also, expand on the purpose of this function and common reasons it would
    be used.
    
    [The comment was reworded to some extent by Alex Williamson]
    
    Signed-off-by: Logan Gunthorpe <logang@deltatee.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Alex Williamson <alex.williamson@redhat.com>
    Cc: Doug Meyer <dmeyer@gigaio.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 97acba712e4e..ea4a9d3be9f9 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -5387,8 +5387,19 @@ int pci_set_vga_state(struct pci_dev *dev, bool decode,
  * @dev: the PCI device for which alias is added
  * @devfn: alias slot and function
  *
- * This helper encodes 8-bit devfn as bit number in dma_alias_mask.
- * It should be called early, preferably as PCI fixup header quirk.
+ * This helper encodes an 8-bit devfn as a bit number in dma_alias_mask
+ * which is used to program permissible bus-devfn source addresses for DMA
+ * requests in an IOMMU.  These aliases factor into IOMMU group creation
+ * and are useful for devices generating DMA requests beyond or different
+ * from their logical bus-devfn.  Examples include device quirks where the
+ * device simply uses the wrong devfn, as well as non-transparent bridges
+ * where the alias may be a proxy for devices in another domain.
+ *
+ * IOMMU group creation is performed during device discovery or addition,
+ * prior to any potential DMA mapping and therefore prior to driver probing
+ * (especially for userspace assigned devices where IOMMU group definition
+ * cannot be left as a userspace activity).  DMA aliases should therefore
+ * be configured via quirks, such as the PCI fixup header quirk.
  */
 void pci_add_dma_alias(struct pci_dev *dev, u8 devfn)
 {

commit 11eb0e0e8dea8b97cff972b09cf6fb033b729dff
Author: Sinan Kaya <okaya@codeaurora.org>
Date:   Mon Jun 4 22:16:09 2018 -0400

    PCI: Make early dump functionality generic
    
    Move early dump functionality into common code so that it is available for
    all architectures.  No need to carry arch-specific reads around as the read
    hooks are already initialized by the time pci_setup_device() is getting
    called during scan.
    
    Tested-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Signed-off-by: Sinan Kaya <okaya@codeaurora.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 1b20c4392f09..e1b0bbd05fa3 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -115,6 +115,9 @@ static bool pcie_ari_disabled;
 /* If set, the PCIe ATS capability will not be used. */
 static bool pcie_ats_disabled;
 
+/* If set, the PCI config space of each device is printed during boot. */
+bool pci_early_dump;
+
 bool pci_ats_disabled(void)
 {
 	return pcie_ats_disabled;
@@ -5833,6 +5836,8 @@ static int __init pci_setup(char *str)
 				pcie_ats_disabled = true;
 			} else if (!strcmp(str, "noaer")) {
 				pci_no_aer();
+			} else if (!strcmp(str, "earlydump")) {
+				pci_early_dump = true;
 			} else if (!strncmp(str, "realloc=", 8)) {
 				pci_realloc_get_opt(str + 8);
 			} else if (!strncmp(str, "realloc", 7)) {

commit b1277a226d8c519b8c33e23fe68b4e1658f15963
Author: Christian König <ckoenig.leichtzumerken@gmail.com>
Date:   Fri Jun 29 19:55:03 2018 -0500

    PCI: Cleanup PCI_REBAR_CTRL_BAR_SHIFT handling
    
    Cleanup PCI_REBAR_CTRL_BAR_SHIFT handling.  That was hard coded instead of
    properly defined in the header for some reason.
    
    Signed-off-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 44ccfb31363e..1b20c4392f09 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1193,7 +1193,7 @@ static void pci_restore_rebar_state(struct pci_dev *pdev)
 		res = pdev->resource + bar_idx;
 		size = order_base_2((resource_size(res) >> 20) | 1) - 1;
 		ctrl &= ~PCI_REBAR_CTRL_BAR_SIZE;
-		ctrl |= size << 8;
+		ctrl |= size << PCI_REBAR_CTRL_BAR_SHIFT;
 		pci_write_config_dword(pdev, pos + PCI_REBAR_CTRL, ctrl);
 	}
 }
@@ -3098,7 +3098,7 @@ int pci_rebar_get_current_size(struct pci_dev *pdev, int bar)
 		return pos;
 
 	pci_read_config_dword(pdev, pos + PCI_REBAR_CTRL, &ctrl);
-	return (ctrl & PCI_REBAR_CTRL_BAR_SIZE) >> 8;
+	return (ctrl & PCI_REBAR_CTRL_BAR_SIZE) >> PCI_REBAR_CTRL_BAR_SHIFT;
 }
 
 /**
@@ -3121,7 +3121,7 @@ int pci_rebar_set_size(struct pci_dev *pdev, int bar, int size)
 
 	pci_read_config_dword(pdev, pos + PCI_REBAR_CTRL, &ctrl);
 	ctrl &= ~PCI_REBAR_CTRL_BAR_SIZE;
-	ctrl |= size << 8;
+	ctrl |= size << PCI_REBAR_CTRL_BAR_SHIFT;
 	pci_write_config_dword(pdev, pos + PCI_REBAR_CTRL, ctrl);
 	return 0;
 }

commit d3252ace0bc652a1a244455556b6a549f969bf99
Author: Christian König <ckoenig.leichtzumerken@gmail.com>
Date:   Fri Jun 29 19:54:55 2018 -0500

    PCI: Restore resized BAR state on resume
    
    Resize BARs after resume to the expected size again.
    
    BugLink: https://bugzilla.kernel.org/show_bug.cgi?id=199959
    Fixes: d6895ad39f3b ("drm/amdgpu: resize VRAM BAR for CPU access v6")
    Fixes: 276b738deb5b ("PCI: Add resizable BAR infrastructure")
    Signed-off-by: Christian König <christian.koenig@amd.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    CC: stable@vger.kernel.org      # v4.15+

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 97acba712e4e..44ccfb31363e 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1171,6 +1171,33 @@ static void pci_restore_config_space(struct pci_dev *pdev)
 	}
 }
 
+static void pci_restore_rebar_state(struct pci_dev *pdev)
+{
+	unsigned int pos, nbars, i;
+	u32 ctrl;
+
+	pos = pci_find_ext_capability(pdev, PCI_EXT_CAP_ID_REBAR);
+	if (!pos)
+		return;
+
+	pci_read_config_dword(pdev, pos + PCI_REBAR_CTRL, &ctrl);
+	nbars = (ctrl & PCI_REBAR_CTRL_NBAR_MASK) >>
+		    PCI_REBAR_CTRL_NBAR_SHIFT;
+
+	for (i = 0; i < nbars; i++, pos += 8) {
+		struct resource *res;
+		int bar_idx, size;
+
+		pci_read_config_dword(pdev, pos + PCI_REBAR_CTRL, &ctrl);
+		bar_idx = ctrl & PCI_REBAR_CTRL_BAR_IDX;
+		res = pdev->resource + bar_idx;
+		size = order_base_2((resource_size(res) >> 20) | 1) - 1;
+		ctrl &= ~PCI_REBAR_CTRL_BAR_SIZE;
+		ctrl |= size << 8;
+		pci_write_config_dword(pdev, pos + PCI_REBAR_CTRL, ctrl);
+	}
+}
+
 /**
  * pci_restore_state - Restore the saved state of a PCI device
  * @dev: - PCI device that we're dealing with
@@ -1186,6 +1213,7 @@ void pci_restore_state(struct pci_dev *dev)
 	pci_restore_pri_state(dev);
 	pci_restore_ats_state(dev);
 	pci_restore_vc_state(dev);
+	pci_restore_rebar_state(dev);
 
 	pci_cleanup_aer_error_status_regs(dev);
 

commit 3a3869f1c443383ef8354ffa0e5fb8df65d8b549
Merge: 3036bc45364f 488ad6d3678b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jun 7 12:45:58 2018 -0700

    Merge tag 'pci-v4.18-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI updates from Bjorn Helgaas:
    
      - unify AER decoding for native and ACPI CPER sources (Alexandru
        Gagniuc)
    
      - add TLP header info to AER tracepoint (Thomas Tai)
    
      - add generic pcie_wait_for_link() interface (Oza Pawandeep)
    
      - handle AER ERR_FATAL by removing and re-enumerating devices, as
        Downstream Port Containment does (Oza Pawandeep)
    
      - factor out common code between AER and DPC recovery (Oza Pawandeep)
    
      - stop triggering DPC for ERR_NONFATAL errors (Oza Pawandeep)
    
      - share ERR_FATAL recovery path between AER and DPC (Oza Pawandeep)
    
      - disable ASPM L1.2 substate if we don't have LTR (Bjorn Helgaas)
    
      - respect platform ownership of LTR (Bjorn Helgaas)
    
      - clear interrupt status in top half to avoid interrupt storm (Oza
        Pawandeep)
    
      - neaten pci=earlydump output (Andy Shevchenko)
    
      - avoid errors when extended config space inaccessible (Gilles Buloz)
    
      - prevent sysfs disable of device while driver attached (Christoph
        Hellwig)
    
      - use core interface to report PCIe link properties in bnx2x, bnxt_en,
        cxgb4, ixgbe (Bjorn Helgaas)
    
      - remove unused pcie_get_minimum_link() (Bjorn Helgaas)
    
      - fix use-before-set error in ibmphp (Dan Carpenter)
    
      - fix pciehp timeouts caused by Command Completed errata (Bjorn
        Helgaas)
    
      - fix refcounting in pnv_php hotplug (Julia Lawall)
    
      - clear pciehp Presence Detect and Data Link Layer Status Changed on
        resume so we don't miss hotplug events (Mika Westerberg)
    
      - only request pciehp control if we support it, so platform can use
        ACPI hotplug otherwise (Mika Westerberg)
    
      - convert SHPC to be builtin only (Mika Westerberg)
    
      - request SHPC control via _OSC if we support it (Mika Westerberg)
    
      - simplify SHPC handoff from firmware (Mika Westerberg)
    
      - fix an SHPC quirk that mistakenly included *all* AMD bridges as well
        as devices from any vendor with device ID 0x7458 (Bjorn Helgaas)
    
      - assign a bus number even to non-native hotplug bridges to leave
        space for acpiphp additions, to fix a common Thunderbolt xHCI
        hot-add failure (Mika Westerberg)
    
      - keep acpiphp from scanning native hotplug bridges, to fix common
        Thunderbolt hot-add failures (Mika Westerberg)
    
      - improve "partially hidden behind bridge" messages from core (Mika
        Westerberg)
    
      - add macros for PCIe Link Control 2 register (Frederick Lawler)
    
      - replace IB/hfi1 custom macros with PCI core versions (Frederick
        Lawler)
    
      - remove dead microblaze and xtensa code (Bjorn Helgaas)
    
      - use dev_printk() when possible in xtensa and mips (Bjorn Helgaas)
    
      - remove unused pcie_port_acpi_setup() and portdrv_acpi.c (Bjorn
        Helgaas)
    
      - add managed interface to get PCI host bridge resources from OF (Jan
        Kiszka)
    
      - add support for unbinding generic PCI host controller (Jan Kiszka)
    
      - fix memory leaks when unbinding generic PCI host controller (Jan
        Kiszka)
    
      - request legacy VGA framebuffer only for VGA devices to avoid false
        device conflicts (Bjorn Helgaas)
    
      - turn on PCI_COMMAND_IO & PCI_COMMAND_MEMORY in pci_enable_device()
        like everybody else, not in pcibios_fixup_bus() (Bjorn Helgaas)
    
      - add generic enable function for simple SR-IOV hardware (Alexander
        Duyck)
    
      - use generic SR-IOV enable for ena, nvme (Alexander Duyck)
    
      - add ACS quirk for Intel 7th & 8th Gen mobile (Alex Williamson)
    
      - add ACS quirk for Intel 300 series (Mika Westerberg)
    
      - enable register clock for Armada 7K/8K (Gregory CLEMENT)
    
      - reduce Keystone "link already up" log level (Fabio Estevam)
    
      - move private DT functions to drivers/pci/ (Rob Herring)
    
      - factor out dwc CONFIG_PCI Kconfig dependencies (Rob Herring)
    
      - add DesignWare support to the endpoint test driver (Gustavo
        Pimentel)
    
      - add DesignWare support for endpoint mode (Gustavo Pimentel)
    
      - use devm_ioremap_resource() instead of devm_ioremap() in dra7xx and
        artpec6 (Gustavo Pimentel)
    
      - fix Qualcomm bitwise NOT issue (Dan Carpenter)
    
      - add Qualcomm runtime PM support (Srinivas Kandagatla)
    
      - fix DesignWare enumeration below bridges (Koen Vandeputte)
    
      - use usleep() instead of mdelay() in endpoint test (Jia-Ju Bai)
    
      - add configfs entries for pci_epf_driver device IDs (Kishon Vijay
        Abraham I)
    
      - clean up pci_endpoint_test driver (Gustavo Pimentel)
    
      - update Layerscape maintainer email addresses (Minghuan Lian)
    
      - add COMPILE_TEST to improve build test coverage (Rob Herring)
    
      - fix Hyper-V bus registration failure caused by domain/serial number
        confusion (Sridhar Pitchai)
    
      - improve Hyper-V refcounting and coding style (Stephen Hemminger)
    
      - avoid potential Hyper-V hang waiting for a response that will never
        come (Dexuan Cui)
    
      - implement Mediatek chained IRQ handling (Honghui Zhang)
    
      - fix vendor ID & class type for Mediatek MT7622 (Honghui Zhang)
    
      - add Mobiveil PCIe host controller driver (Subrahmanya Lingappa)
    
      - add Mobiveil MSI support (Subrahmanya Lingappa)
    
      - clean up clocks, MSI, IRQ mappings in R-Car probe failure paths
        (Marek Vasut)
    
      - poll more frequently (5us vs 5ms) while waiting for R-Car data link
        active (Marek Vasut)
    
      - use generic OF parsing interface in R-Car (Vladimir Zapolskiy)
    
      - add R-Car V3H (R8A77980) "compatible" string (Sergei Shtylyov)
    
      - add R-Car gen3 PHY support (Sergei Shtylyov)
    
      - improve R-Car PHYRDY polling (Sergei Shtylyov)
    
      - clean up R-Car macros (Marek Vasut)
    
      - use runtime PM for R-Car controller clock (Dien Pham)
    
      - update arm64 defconfig for Rockchip (Shawn Lin)
    
      - refactor Rockchip code to facilitate both root port and endpoint
        mode (Shawn Lin)
    
      - add Rockchip endpoint mode driver (Shawn Lin)
    
      - support VMD "membar shadow" feature (Jon Derrick)
    
      - support VMD bus number offsets (Jon Derrick)
    
      - add VMD "no AER source ID" quirk for more device IDs (Jon Derrick)
    
      - remove unnecessary host controller CONFIG_PCIEPORTBUS Kconfig
        selections (Bjorn Helgaas)
    
      - clean up quirks.c organization and whitespace (Bjorn Helgaas)
    
    * tag 'pci-v4.18-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (144 commits)
      PCI/AER: Replace struct pcie_device with pci_dev
      PCI/AER: Remove unused parameters
      PCI: qcom: Include gpio/consumer.h
      PCI: Improve "partially hidden behind bridge" log message
      PCI: Improve pci_scan_bridge() and pci_scan_bridge_extend() doc
      PCI: Move resource distribution for single bridge outside loop
      PCI: Account for all bridges on bus when distributing bus numbers
      ACPI / hotplug / PCI: Drop unnecessary parentheses
      ACPI / hotplug / PCI: Mark stale PCI devices disconnected
      ACPI / hotplug / PCI: Don't scan bridges managed by native hotplug
      PCI: hotplug: Add hotplug_is_native()
      PCI: shpchp: Add shpchp_is_native()
      PCI: shpchp: Fix AMD POGO identification
      PCI: mobiveil: Add MSI support
      PCI: mobiveil: Add Mobiveil PCIe Host Bridge IP driver
      PCI/AER: Decode Error Source Requester ID
      PCI/AER: Remove aer_recover_work_func() forward declaration
      PCI/DPC: Use the generic pcie_do_fatal_recovery() path
      PCI/AER: Pass service type to pcie_do_fatal_recovery()
      PCI/DPC: Disable ERR_NONFATAL handling by DPC
      ...

commit fd83941d50cbbe70e9dc1929d8f4631dd56d8c62
Merge: 13fbadcd512c 8d85a7a4f2c9
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Jun 6 16:10:21 2018 -0500

    Merge branch 'pci/virtualization'
    
      - add generic enable function for simple SR-IOV hardware (Alexander
        Duyck)
    
      - use generic SR-IOV enable for ena, nvme (Alexander Duyck)
    
      - add ACS quirk for Intel 7th & 8th Gen mobile (Alex Williamson)
    
      - add ACS quirk for Intel 300 series (Mika Westerberg)
    
    * pci/virtualization:
      PCI/IOV: Allow PF drivers to limit total_VFs to 0
      PCI: Add "pci=noats" boot parameter
      PCI: Add ACS quirk for Intel 300 series
      PCI: Add ACS quirk for Intel 7th & 8th Gen mobile
      nvme-pci: Use pci_sriov_configure_simple() to enable VFs
      net: ena: Use pci_sriov_configure_simple() to enable VFs
      PCI/IOV: Add pci-pf-stub driver for PFs that only enable VFs
      PCI/IOV: Add pci_sriov_configure_simple()

commit a7c9d4cf45e1352c3fcca0fabfdf9d7ff708d2ff
Merge: ae08aa13ba4b 37bd62d224c8
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Jun 6 16:10:18 2018 -0500

    Merge branch 'pci/resource'
    
      - add managed interface to get PCI host bridge resources from OF (Jan
        Kiszka)
    
      - add support for unbinding generic PCI host controller (Jan Kiszka)
    
      - fix memory leaks when unbinding generic PCI host controller (Jan Kiszka)
    
    * pci/resource:
      PCI: Enable PCI_DOMAINS along with generic PCI host controller
      PCI: Add support for unbinding the generic PCI host controller
      PCI: Rework of_pci_get_host_bridge_resources() to devm_of_pci_get_host_bridge_resources()
      PCI: Use dev_printk() in of_pci_get_host_bridge_resources()
      PCI: Pass struct device to of_pci_get_host_bridge_resources()
      PCI: Rename of_pci_get_host_bridge_resources() device node parameter
      PCI: Fix devm_pci_alloc_host_bridge() memory leak
      PCI: Make pci_get_new_domain_nr() static

commit 5e3165d1a813cba0e7fad3880f9d704241e31245
Merge: 8e069da28dfb e5b1db0186bf
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Jun 6 16:10:08 2018 -0500

    Merge branch 'pci/enumeration'
    
      - neaten pci=earlydump output (Andy Shevchenko)
    
      - avoid errors when extended config space inaccessible (Gilles Buloz)
    
      - prevent sysfs disable of device while driver attached (Christoph
        Hellwig)
    
      - use core interface to report PCIe link properties in bnx2x, bnxt_en,
        cxgb4, ixgbe (Bjorn Helgaas)
    
      - remove unused pcie_get_minimum_link() (Bjorn Helgaas)
    
    * pci/enumeration:
      PCI: Remove unused pcie_get_minimum_link()
      ixgbe: Report PCIe link properties with pcie_print_link_status()
      cxgb4: Report PCIe link properties with pcie_print_link_status()
      bnxt_en: Report PCIe link properties with pcie_print_link_status()
      bnx2x: Report PCIe link properties with pcie_print_link_status()
      PCI: Prevent sysfs disable of device while driver is attached
      PCI: Check whether bridges allow access to extended config space
      x86/PCI: Make pci=earlydump output neat

commit e5b1db0186bfb3bede41e412b27c9bcf2b336622
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Mar 30 14:41:49 2018 -0500

    PCI: Remove unused pcie_get_minimum_link()
    
    In some cases pcie_get_minimum_link() returned misleading information
    because it found the slowest link and the narrowest link without
    considering the total bandwidth of the link.
    
    For example, consider a path with these two links:
    
      - 16.0 GT/s  x1 link  (16.0 * 10^9 * 128 / 130) *  1 / 8 = 1969 MB/s
      -  2.5 GT/s x16 link  ( 2.5 * 10^9 *   8 /  10) * 16 / 8 = 4000 MB/s
    
    The available bandwidth of the path is limited by the 16 GT/s link to about
    1969 MB/s, but pcie_get_minimum_link() returned 2.5 GT/s x1, which
    corresponds to only 250 MB/s.
    
    Callers should use pcie_print_link_status() instead, or
    pcie_bandwidth_available() if they need more detailed information.
    
    Remove pcie_get_minimum_link() since there are no callers left.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index e597655a5643..4bafa817c40a 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -5069,49 +5069,6 @@ int pcie_set_mps(struct pci_dev *dev, int mps)
 }
 EXPORT_SYMBOL(pcie_set_mps);
 
-/**
- * pcie_get_minimum_link - determine minimum link settings of a PCI device
- * @dev: PCI device to query
- * @speed: storage for minimum speed
- * @width: storage for minimum width
- *
- * This function will walk up the PCI device chain and determine the minimum
- * link width and speed of the device.
- */
-int pcie_get_minimum_link(struct pci_dev *dev, enum pci_bus_speed *speed,
-			  enum pcie_link_width *width)
-{
-	int ret;
-
-	*speed = PCI_SPEED_UNKNOWN;
-	*width = PCIE_LNK_WIDTH_UNKNOWN;
-
-	while (dev) {
-		u16 lnksta;
-		enum pci_bus_speed next_speed;
-		enum pcie_link_width next_width;
-
-		ret = pcie_capability_read_word(dev, PCI_EXP_LNKSTA, &lnksta);
-		if (ret)
-			return ret;
-
-		next_speed = pcie_link_speed[lnksta & PCI_EXP_LNKSTA_CLS];
-		next_width = (lnksta & PCI_EXP_LNKSTA_NLW) >>
-			PCI_EXP_LNKSTA_NLW_SHIFT;
-
-		if (next_speed < *speed)
-			*speed = next_speed;
-
-		if (next_width < *width)
-			*width = next_width;
-
-		dev = dev->bus->self;
-	}
-
-	return 0;
-}
-EXPORT_SYMBOL(pcie_get_minimum_link);
-
 /**
  * pcie_bandwidth_available - determine minimum link settings of a PCIe
  *			      device and its bandwidth limitation

commit 60ee031aabbe602df01cb12f3098e99262832e62
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon May 21 13:11:12 2018 +0200

    PCI / PM: Clean up outdated comments in pci_target_state()
    
    Two comments in pci_target_state() are outdated, as the function
    doesn't set the target power state for the device any more, only
    finds one for it, so fix them accordingly.
    
    Reported-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index dbfe7c4f3776..e90cf5c32e14 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2025,8 +2025,7 @@ static pci_power_t pci_target_state(struct pci_dev *dev, bool wakeup)
 
 	if (platform_pci_power_manageable(dev)) {
 		/*
-		 * Call the platform to choose the target state of the device
-		 * and enable wake-up from this state if supported.
+		 * Call the platform to find the target state for the device.
 		 */
 		pci_power_t state = platform_pci_choose_state(dev);
 
@@ -2059,8 +2058,7 @@ static pci_power_t pci_target_state(struct pci_dev *dev, bool wakeup)
 	if (wakeup) {
 		/*
 		 * Find the deepest state from which the device can generate
-		 * wake-up events, make it the target state and enable device
-		 * to generate PME#.
+		 * PME#.
 		 */
 		if (dev->pme_support) {
 			while (target_state

commit 9f5a70f18c5893a30d6c339adc48de43c57dd7e2
Author: Oza Pawandeep <poza@codeaurora.org>
Date:   Thu May 17 16:44:11 2018 -0500

    PCI: Add generic pcie_wait_for_link() interface
    
    Clients such as hotplug and Downstream Port Containment (DPC) both need to
    wait until a link becomes active or inactive.
    
    Add a generic pcie_wait_link_active() interface and use it instead of
    duplicating the code.
    
    Signed-off-by: Oza Pawandeep <poza@codeaurora.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Keith Busch <keith.busch@intel.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index e597655a5643..764bf64a097d 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -4138,6 +4138,35 @@ static int pci_pm_reset(struct pci_dev *dev, int probe)
 
 	return pci_dev_wait(dev, "PM D3->D0", PCIE_RESET_READY_POLL_MS);
 }
+/**
+ * pcie_wait_for_link - Wait until link is active or inactive
+ * @pdev: Bridge device
+ * @active: waiting for active or inactive?
+ *
+ * Use this to wait till link becomes active or inactive.
+ */
+bool pcie_wait_for_link(struct pci_dev *pdev, bool active)
+{
+	int timeout = 1000;
+	bool ret;
+	u16 lnk_status;
+
+	for (;;) {
+		pcie_capability_read_word(pdev, PCI_EXP_LNKSTA, &lnk_status);
+		ret = !!(lnk_status & PCI_EXP_LNKSTA_DLLLA);
+		if (ret == active)
+			return true;
+		if (timeout <= 0)
+			break;
+		msleep(10);
+		timeout -= 10;
+	}
+
+	pci_info(pdev, "Data Link Layer Link Active not %s in 1000 msec\n",
+		 active ? "set" : "cleared");
+
+	return false;
+}
 
 void pci_reset_secondary_bus(struct pci_dev *dev)
 {

commit ae07b786888f1872ac2b63d74a17e206d441ec9f
Author: Jan Kiszka <jan.kiszka@siemens.com>
Date:   Tue May 15 11:07:00 2018 +0200

    PCI: Make pci_get_new_domain_nr() static
    
    The only user of pci_get_new_domain_nr() is of_pci_bus_find_domain_nr().
    Since they are defined in the same file, pci_get_new_domain_nr() can be
    made static, which also simplifies preprocessor conditionals.
    
    No functional change intended.
    
    Signed-off-by: Jan Kiszka <jan.kiszka@siemens.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index e597655a5643..695c2bb4e853 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -5702,15 +5702,14 @@ static void pci_no_domains(void)
 #endif
 }
 
-#ifdef CONFIG_PCI_DOMAINS
+#ifdef CONFIG_PCI_DOMAINS_GENERIC
 static atomic_t __domain_nr = ATOMIC_INIT(-1);
 
-int pci_get_new_domain_nr(void)
+static int pci_get_new_domain_nr(void)
 {
 	return atomic_inc_return(&__domain_nr);
 }
 
-#ifdef CONFIG_PCI_DOMAINS_GENERIC
 static int of_pci_bus_find_domain_nr(struct device *parent)
 {
 	static int use_dt_domains = -1;
@@ -5765,7 +5764,6 @@ int pci_bus_find_domain_nr(struct pci_bus *bus, struct device *parent)
 			       acpi_pci_bus_find_domain_nr(bus);
 }
 #endif
-#endif
 
 /**
  * pci_ext_cfg_avail - can we access extended PCI config space?

commit cef74409ea79b0a37af6889e7abf7a2a9c47979b
Author: Gil Kupfer <gilkup@gmail.com>
Date:   Thu May 10 17:56:02 2018 -0500

    PCI: Add "pci=noats" boot parameter
    
    Adds a "pci=noats" boot parameter.  When supplied, all ATS related
    functions fail immediately and the IOMMU is configured to not use
    device-IOTLB.
    
    Any function that checks for ATS capabilities directly against the devices
    should also check this flag.  Currently, such functions exist only in IOMMU
    drivers, and they are covered by this patch.
    
    The motivation behind this patch is the existence of malicious devices.
    Lots of research has been done about how to use the IOMMU as protection
    from such devices.  When ATS is supported, any I/O device can access any
    physical address by faking device-IOTLB entries.  Adding the ability to
    ignore these entries lets sysadmins enhance system security.
    
    Signed-off-by: Gil Kupfer <gilkup@cs.technion.ac.il>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Joerg Roedel <jroedel@suse.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index e597655a5643..789ce36be341 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -112,6 +112,14 @@ unsigned int pcibios_max_latency = 255;
 /* If set, the PCIe ARI capability will not be used. */
 static bool pcie_ari_disabled;
 
+/* If set, the PCIe ATS capability will not be used. */
+static bool pcie_ats_disabled;
+
+bool pci_ats_disabled(void)
+{
+	return pcie_ats_disabled;
+}
+
 /* Disable bridge_d3 for all PCIe ports */
 static bool pci_bridge_d3_disable;
 /* Force bridge_d3 for all PCIe ports */
@@ -5793,6 +5801,9 @@ static int __init pci_setup(char *str)
 		if (*str && (str = pcibios_setup(str)) && *str) {
 			if (!strcmp(str, "nomsi")) {
 				pci_no_msi();
+			} else if (!strncmp(str, "noats", 5)) {
+				pr_info("PCIe: ATS is disabled\n");
+				pcie_ats_disabled = true;
 			} else if (!strcmp(str, "noaer")) {
 				pci_no_aer();
 			} else if (!strncmp(str, "realloc=", 8)) {

commit cfcadfaad7251d8b640713724b388164d75465b2
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed May 9 00:18:32 2018 +0200

    PCI / PM: Check device_may_wakeup() in pci_enable_wake()
    
    Commit 0847684cfc5f0 (PCI / PM: Simplify device wakeup settings code)
    went too far and dropped the device_may_wakeup() check from
    pci_enable_wake() which causes wakeup to be enabled during system
    suspend, hibernation or shutdown for some PCI devices that are not
    allowed by user space to wake up the system from sleep (or power off).
    
    As a result of this, excessive power is drawn by some of the affected
    systems while in sleep states or off.
    
    Restore the device_may_wakeup() check in pci_enable_wake(), but make
    sure that the PCI bus type's runtime suspend callback will not call
    device_may_wakeup() which is about system wakeup from sleep and not
    about device wakeup from runtime suspend.
    
    Fixes: 0847684cfc5f0 (PCI / PM: Simplify device wakeup settings code)
    Reported-by: Joseph Salisbury <joseph.salisbury@canonical.com>
    Cc: 4.13+ <stable@vger.kernel.org> # 4.13+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index c2616cad3a1d..dbfe7c4f3776 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1910,7 +1910,7 @@ void pci_pme_active(struct pci_dev *dev, bool enable)
 EXPORT_SYMBOL(pci_pme_active);
 
 /**
- * pci_enable_wake - enable PCI device as wakeup event source
+ * __pci_enable_wake - enable PCI device as wakeup event source
  * @dev: PCI device affected
  * @state: PCI state from which device will issue wakeup events
  * @enable: True to enable event generation; false to disable
@@ -1928,7 +1928,7 @@ EXPORT_SYMBOL(pci_pme_active);
  * Error code depending on the platform is returned if both the platform and
  * the native mechanism fail to enable the generation of wake-up events
  */
-int pci_enable_wake(struct pci_dev *dev, pci_power_t state, bool enable)
+static int __pci_enable_wake(struct pci_dev *dev, pci_power_t state, bool enable)
 {
 	int ret = 0;
 
@@ -1969,6 +1969,23 @@ int pci_enable_wake(struct pci_dev *dev, pci_power_t state, bool enable)
 
 	return ret;
 }
+
+/**
+ * pci_enable_wake - change wakeup settings for a PCI device
+ * @pci_dev: Target device
+ * @state: PCI state from which device will issue wakeup events
+ * @enable: Whether or not to enable event generation
+ *
+ * If @enable is set, check device_may_wakeup() for the device before calling
+ * __pci_enable_wake() for it.
+ */
+int pci_enable_wake(struct pci_dev *pci_dev, pci_power_t state, bool enable)
+{
+	if (enable && !device_may_wakeup(&pci_dev->dev))
+		return -EINVAL;
+
+	return __pci_enable_wake(pci_dev, state, enable);
+}
 EXPORT_SYMBOL(pci_enable_wake);
 
 /**
@@ -1981,9 +1998,9 @@ EXPORT_SYMBOL(pci_enable_wake);
  * should not be called twice in a row to enable wake-up due to PCI PM vs ACPI
  * ordering constraints.
  *
- * This function only returns error code if the device is not capable of
- * generating PME# from both D3_hot and D3_cold, and the platform is unable to
- * enable wake-up power for it.
+ * This function only returns error code if the device is not allowed to wake
+ * up the system from sleep or it is not capable of generating PME# from both
+ * D3_hot and D3_cold and the platform is unable to enable wake-up power for it.
  */
 int pci_wake_from_d3(struct pci_dev *dev, bool enable)
 {
@@ -2114,7 +2131,7 @@ int pci_finish_runtime_suspend(struct pci_dev *dev)
 
 	dev->runtime_d3cold = target_state == PCI_D3cold;
 
-	pci_enable_wake(dev, target_state, pci_dev_run_wake(dev));
+	__pci_enable_wake(dev, target_state, pci_dev_run_wake(dev));
 
 	error = pci_set_power_state(dev, target_state);
 

commit 8feaec33b9868582654cd3d5355225dcb79aeca6
Author: Kai Heng Feng <kai.heng.feng@canonical.com>
Date:   Mon May 7 14:11:20 2018 +0800

    PCI / PM: Always check PME wakeup capability for runtime wakeup support
    
    USB controller ASM1042 stops working after commit de3ef1eb1cd0 (PM /
    core: Drop run_wake flag from struct dev_pm_info).
    
    The device in question is not power managed by platform firmware,
    furthermore, it only supports PME# from D3cold:
    Capabilities: [78] Power Management version 3
           Flags: PMEClk- DSI- D1- D2- AuxCurrent=55mA PME(D0-,D1-,D2-,D3hot-,D3cold+)
           Status: D0 NoSoftRst+ PME-Enable- DSel=0 DScale=0 PME-
    
    Before commit de3ef1eb1cd0, the device never gets runtime suspended.
    After that commit, the device gets runtime suspended to D3hot, which can
    not generate any PME#.
    
    usb_hcd_pci_probe() unconditionally calls device_wakeup_enable(), hence
    device_can_wakeup() in pci_dev_run_wake() always returns true.
    
    So pci_dev_run_wake() needs to check PME wakeup capability as its first
    condition.
    
    In addition, change wakeup flag passed to pci_target_state() from false
    to true, because we want to find the deepest state different from D3cold
    that the device can still generate PME#. In this case, it's D0 for the
    device in question.
    
    Fixes: de3ef1eb1cd0 (PM / core: Drop run_wake flag from struct dev_pm_info)
    Signed-off-by: Kai-Heng Feng <kai.heng.feng@canonical.com>
    Cc: 4.13+ <stable@vger.kernel.org> # 4.13+
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index a04197ce767d..c2616cad3a1d 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2138,16 +2138,16 @@ bool pci_dev_run_wake(struct pci_dev *dev)
 {
 	struct pci_bus *bus = dev->bus;
 
-	if (device_can_wakeup(&dev->dev))
-		return true;
-
 	if (!dev->pme_support)
 		return false;
 
 	/* PME-capable in principle, but not from the target power state */
-	if (!pci_pme_capable(dev, pci_target_state(dev, false)))
+	if (!pci_pme_capable(dev, pci_target_state(dev, true)))
 		return false;
 
+	if (device_can_wakeup(&dev->dev))
+		return true;
+
 	while (bus->parent) {
 		struct pci_dev *bridge = bus->self;
 

commit 0cf22d6b317ce0103b7d5a47878aa5ef94240433
Author: Jakub Kicinski <jakub.kicinski@netronome.com>
Date:   Fri Apr 20 12:56:36 2018 -0500

    PCI: Add "PCIe" to pcie_print_link_status() messages
    
    Currently the pcie_print_link_status() will print PCIe bandwidth and link
    width information but does not mention it is pertaining to the PCIe.  Since
    this and related functions are used exclusively by networking drivers today
    users may get confused into thinking that it's the NIC bandwidth that is
    being talked about.  Insert a "PCIe" into the messages.
    
    Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index e597655a5643..a04197ce767d 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -5273,11 +5273,11 @@ void pcie_print_link_status(struct pci_dev *dev)
 	bw_avail = pcie_bandwidth_available(dev, &limiting_dev, &speed, &width);
 
 	if (bw_avail >= bw_cap)
-		pci_info(dev, "%u.%03u Gb/s available bandwidth (%s x%d link)\n",
+		pci_info(dev, "%u.%03u Gb/s available PCIe bandwidth (%s x%d link)\n",
 			 bw_cap / 1000, bw_cap % 1000,
 			 PCIE_SPEED2STR(speed_cap), width_cap);
 	else
-		pci_info(dev, "%u.%03u Gb/s available bandwidth, limited by %s x%d link at %s (capable of %u.%03u Gb/s with %s x%d link)\n",
+		pci_info(dev, "%u.%03u Gb/s available PCIe bandwidth, limited by %s x%d link at %s (capable of %u.%03u Gb/s with %s x%d link)\n",
 			 bw_avail / 1000, bw_avail % 1000,
 			 PCIE_SPEED2STR(speed), width,
 			 limiting_dev ? pci_name(limiting_dev) : "<unknown>",

commit adf58458bcb2890efe94e5a58506c27bfecf518d
Author: Desnes A. Nunes do Rosario <desnesn@linux.vnet.ibm.com>
Date:   Tue Apr 10 14:51:06 2018 -0500

    PCI: Remove messages about reassigning resources
    
    When reassigning device resources to increase their alignment, e.g.,
    because of a "pci=resource_alignment=" kernel parameter or because the
    platform aligns resources to its page size, we previously emitted messages
    like this:
    
      pci 0000:00:00.0: Disabling memory decoding and releasing memory resources
      pci 0000:00:00.0: disabling bridge mem windows
    
    These messages don't convey any useful information, so remove them.
    
    Fixes: 38274637699 ("powerpc/powernv: Override pcibios_default_alignment() to force PCI devices to be page aligned")
    Signed-off-by: Desnes A. Nunes do Rosario <desnesn@linux.vnet.ibm.com>
    [bhelgaas: changelog]
    Signed-off-by: Bjorn Helgaas <helgaas@kernel.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index aa86e904f93c..e597655a5643 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -5628,7 +5628,6 @@ void pci_reassigndev_resource_alignment(struct pci_dev *dev)
 		return;
 	}
 
-	pci_info(dev, "Disabling memory decoding and releasing memory resources\n");
 	pci_read_config_word(dev, PCI_COMMAND, &command);
 	command &= ~PCI_COMMAND_MEMORY;
 	pci_write_config_word(dev, PCI_COMMAND, command);

commit 3c0d551e02b2590fa71a1354f2f1994551a33315
Merge: 19fd08b85bc7 5f7644190986
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Apr 6 18:31:06 2018 -0700

    Merge tag 'pci-v4.17-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI updates from Bjorn Helgaas:
    
     - move pci_uevent_ers() out of pci.h (Michael Ellerman)
    
     - skip ASPM common clock warning if BIOS already configured it (Sinan
       Kaya)
    
     - fix ASPM Coverity warning about threshold_ns (Gustavo A. R. Silva)
    
     - remove last user of pci_get_bus_and_slot() and the function itself
       (Sinan Kaya)
    
     - add decoding for 16 GT/s link speed (Jay Fang)
    
     - add interfaces to get max link speed and width (Tal Gilboa)
    
     - add pcie_bandwidth_capable() to compute max supported link bandwidth
       (Tal Gilboa)
    
     - add pcie_bandwidth_available() to compute bandwidth available to
       device (Tal Gilboa)
    
     - add pcie_print_link_status() to log link speed and whether it's
       limited (Tal Gilboa)
    
     - use PCI core interfaces to report when device performance may be
       limited by its slot instead of doing it in each driver (Tal Gilboa)
    
     - fix possible cpqphp NULL pointer dereference (Shawn Lin)
    
     - rescan more of the hierarchy on ACPI hotplug to fix Thunderbolt/xHCI
       hotplug (Mika Westerberg)
    
     - add support for PCI I/O port space that's neither directly accessible
       via CPU in/out instructions nor directly mapped into CPU physical
       memory space. This is fairly intrusive and includes minor changes to
       interfaces used for I/O space on most platforms (Zhichang Yuan, John
       Garry)
    
     - add support for HiSilicon Hip06/Hip07 LPC I/O space (Zhichang Yuan,
       John Garry)
    
     - use PCI_EXP_DEVCTL2_COMP_TIMEOUT in rapidio/tsi721 (Bjorn Helgaas)
    
     - remove possible NULL pointer dereference in of_pci_bus_find_domain_nr()
       (Shawn Lin)
    
     - report quirk timings with dev_info (Bjorn Helgaas)
    
     - report quirks that take longer than 10ms (Bjorn Helgaas)
    
     - add and use Altera Vendor ID (Johannes Thumshirn)
    
     - tidy Makefiles and comments (Bjorn Helgaas)
    
     - don't set up INTx if MSI or MSI-X is enabled to align cris, frv,
       ia64, and mn10300 with x86 (Bjorn Helgaas)
    
     - move pcieport_if.h to drivers/pci/pcie/ to encapsulate it (Frederick
       Lawler)
    
     - merge pcieport_if.h into portdrv.h (Bjorn Helgaas)
    
     - move workaround for BIOS PME issue from portdrv to PCI core (Bjorn
       Helgaas)
    
     - completely disable portdrv with "pcie_ports=compat" (Bjorn Helgaas)
    
     - remove portdrv link order dependency (Bjorn Helgaas)
    
     - remove support for unused VC portdrv service (Bjorn Helgaas)
    
     - simplify portdrv feature permission checking (Bjorn Helgaas)
    
     - remove "pcie_hp=nomsi" parameter (use "pci=nomsi" instead) (Bjorn
       Helgaas)
    
     - remove unnecessary "pcie_ports=auto" parameter (Bjorn Helgaas)
    
     - use cached AER capability offset (Frederick Lawler)
    
     - don't enable DPC if BIOS hasn't granted AER control (Mika Westerberg)
    
     - rename pcie-dpc.c to dpc.c (Bjorn Helgaas)
    
     - use generic pci_mmap_resource_range() instead of powerpc and xtensa
       arch-specific versions (David Woodhouse)
    
     - support arbitrary PCI host bridge offsets on sparc (Yinghai Lu)
    
     - remove System and Video ROM reservations on sparc (Bjorn Helgaas)
    
     - probe for device reset support during enumeration instead of runtime
       (Bjorn Helgaas)
    
     - add ACS quirk for Ampere (née APM) root ports (Feng Kan)
    
     - add function 1 DMA alias quirk for Marvell 88SE9220 (Thomas
       Vincent-Cross)
    
     - protect device restore with device lock (Sinan Kaya)
    
     - handle failure of FLR gracefully (Sinan Kaya)
    
     - handle CRS (config retry status) after device resets (Sinan Kaya)
    
     - skip various config reads for SR-IOV VFs as an optimization
       (KarimAllah Ahmed)
    
     - consolidate VPD code in vpd.c (Bjorn Helgaas)
    
     - add Tegra dependency on PCI_MSI_IRQ_DOMAIN (Arnd Bergmann)
    
     - add DT support for R-Car r8a7743 (Biju Das)
    
     - fix a PCI_EJECT vs PCI_BUS_RELATIONS race condition in Hyper-V host
       bridge driver that causes a general protection fault (Dexuan Cui)
    
     - fix Hyper-V host bridge hang in MSI setup on 1-vCPU VMs with SR-IOV
       (Dexuan Cui)
    
     - fix Hyper-V host bridge hang when ejecting a VF before setting up MSI
       (Dexuan Cui)
    
     - make several structures static (Fengguang Wu)
    
     - increase number of MSI IRQs supported by Synopsys DesignWare bridges
       from 32 to 256 (Gustavo Pimentel)
    
     - implemented multiplexed IRQ domain API and remove obsolete MSI IRQ
       API from DesignWare drivers (Gustavo Pimentel)
    
     - add Tegra power management support (Manikanta Maddireddy)
    
     - add Tegra loadable module support (Manikanta Maddireddy)
    
     - handle 64-bit BARs correctly in endpoint support (Niklas Cassel)
    
     - support optional regulator for HiSilicon STB (Shawn Guo)
    
     - use regulator bulk API for Qualcomm apq8064 (Srinivas Kandagatla)
    
     - support power supplies for Qualcomm msm8996 (Srinivas Kandagatla)
    
    * tag 'pci-v4.17-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (123 commits)
      MAINTAINERS: Add John Garry as maintainer for HiSilicon LPC driver
      HISI LPC: Add ACPI support
      ACPI / scan: Do not enumerate Indirect IO host children
      ACPI / scan: Rename acpi_is_serial_bus_slave() for more general use
      HISI LPC: Support the LPC host on Hip06/Hip07 with DT bindings
      of: Add missing I/O range exception for indirect-IO devices
      PCI: Apply the new generic I/O management on PCI IO hosts
      PCI: Add fwnode handler as input param of pci_register_io_range()
      PCI: Remove __weak tag from pci_register_io_range()
      MAINTAINERS: Add missing /drivers/pci/cadence directory entry
      fm10k: Report PCIe link properties with pcie_print_link_status()
      net/mlx5e: Use pcie_bandwidth_available() to compute bandwidth
      net/mlx5: Report PCIe link properties with pcie_print_link_status()
      net/mlx4_core: Report PCIe link properties with pcie_print_link_status()
      PCI: Add pcie_print_link_status() to log link speed and whether it's limited
      PCI: Add pcie_bandwidth_available() to compute bandwidth available to device
      misc: pci_endpoint_test: Handle 64-bit BARs properly
      PCI: designware-ep: Make dw_pcie_ep_reset_bar() handle 64-bit BARs properly
      PCI: endpoint: Make sure that BAR_5 does not have 64-bit flag set when clearing
      PCI: endpoint: Make epc->ops->clear_bar()/pci_epc_clear_bar() take struct *epf_bar
      ...

commit a4b88505ac1f77cf4fa75fa6845fe95aa43aac9e
Merge: 0eb6de7872d9 619e6f340cec
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Apr 4 13:28:26 2018 -0500

    Merge branch 'pci/virtualization'
    
      - probe for device reset support during enumeration instead of runtime
        (Bjorn Helgaas)
    
      - add ACS quirk for Ampere (née APM) root ports (Feng Kan)
    
      - add function 1 DMA alias quirk for Marvell 88SE9220 (Thomas
        Vincent-Cross)
    
      - protect device restore with device lock (Sinan Kaya)
    
      - handle failure of FLR gracefully (Sinan Kaya)
    
      - handle CRS (config retry status) after device resets (Sinan Kaya)
    
      - skip various config reads for SR-IOV VFs as an optimization (KarimAllah
        Ahmed)
    
    * pci/virtualization:
      PCI/IOV: Add missing prototypes for powerpc pcibios interfaces
      PCI/IOV: Use VF0 cached config registers for other VFs
      PCI/IOV: Skip BAR sizing for VFs
      PCI/IOV: Skip INTx config reads for VFs
      PCI: Wait for device to become ready after secondary bus reset
      PCI: Add a return type for pci_reset_bridge_secondary_bus()
      PCI: Wait for device to become ready after a power management reset
      PCI: Rename pci_flr_wait() to pci_dev_wait() and make it generic
      PCI: Handle FLR failure and allow other reset types
      PCI: Protect restore with device lock to be consistent
      PCI: Add function 1 DMA alias quirk for Marvell 88SE9220
      PCI: Add ACS quirk for Ampere root ports
      PCI: Remove redundant probes for device reset support
      PCI: Probe for device reset support during enumeration
    
    Conflicts:
            include/linux/pci.h

commit 64ae499cf2eece26bc395184aa2c9a18aa49d199
Merge: ac30aa596996 e02602bd7625
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Apr 4 13:27:58 2018 -0500

    Merge branch 'pci/portdrv'
    
      - move pcieport_if.h to drivers/pci/pcie/ to encapsulate it (Frederick
        Lawler)
    
      - merge pcieport_if.h into portdrv.h (Bjorn Helgaas)
    
      - move workaround for BIOS PME issue from portdrv to PCI core (Bjorn
        Helgaas)
    
      - completely disable portdrv with "pcie_ports=compat" (Bjorn Helgaas)
    
      - remove portdrv link order dependency (Bjorn Helgaas)
    
      - remove support for unused VC portdrv service (Bjorn Helgaas)
    
      - simplify portdrv feature permission checking (Bjorn Helgaas)
    
      - remove "pcie_hp=nomsi" parameter (use "pci=nomsi" instead) (Bjorn
        Helgaas)
    
      - remove unnecessary "pcie_ports=auto" parameter (Bjorn Helgaas)
    
      - use cached AER capability offset (Frederick Lawler)
    
      - don't enable DPC if BIOS hasn't granted AER control (Mika Westerberg)
    
      - rename pcie-dpc.c to dpc.c (Bjorn Helgaas)
    
    * pci/portdrv:
      PCI/DPC: Rename from pcie-dpc.c to dpc.c
      PCI/DPC: Do not enable DPC if AER control is not allowed by the BIOS
      PCI/AER: Use cached AER Capability offset
      PCI/portdrv: Rename and reverse sense of pcie_ports_auto
      PCI/portdrv: Encapsulate pcie_ports_auto inside the port driver
      PCI/portdrv: Remove unnecessary "pcie_ports=auto" parameter
      PCI/portdrv: Remove "pcie_hp=nomsi" kernel parameter
      PCI/portdrv: Remove unnecessary include of <linux/pci-aspm.h>
      PCI/portdrv: Simplify PCIe feature permission checking
      PCI/portdrv: Remove unused PCIE_PORT_SERVICE_VC
      PCI/portdrv: Remove pcie_port_bus_type link order dependency
      PCI/portdrv: Disable port driver in compat mode
      PCI/PM: Clear PCIe PME Status bit for Root Complex Event Collectors
      PCI/PM: Clear PCIe PME Status bit in core, not PCIe port driver
      PCI/PM: Move pcie_clear_root_pme_status() to core
      PCI/portdrv: Merge pcieport_if.h into portdrv.h
      PCI/portdrv: Move pcieport_if.h to drivers/pci/pcie/
    
    Conflicts:
            drivers/pci/pcie/Makefile
            drivers/pci/pcie/portdrv.h

commit 43b90eaed57679731ae340a47cef49e59a321c2e
Merge: 3da1b6174ba3 ad32eb2df801
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Apr 4 13:27:45 2018 -0500

    Merge branch 'pci/misc'
    
      - use PCI_EXP_DEVCTL2_COMP_TIMEOUT in rapidio/tsi721 (Bjorn Helgaas)
    
      - remove possible NULL pointer dereference in of_pci_bus_find_domain_nr()
        (Shawn Lin)
    
      - report quirk timings with dev_info (Bjorn Helgaas)
    
      - report quirks that take longer than 10ms (Bjorn Helgaas)
    
      - add and use Altera Vendor ID (Johannes Thumshirn)
    
      - tidy Makefiles and comments (Bjorn Helgaas)
    
    * pci/misc:
      PCI: Always define the of_node helpers
      PCI: Tidy comments
      PCI: Tidy Makefiles
      mcb: Add Altera PCI ID to mcb-pci
      PCI: Add Altera vendor ID
      PCI: Report quirks that take more than 10ms
      PCI: Report quirk timings with pci_info() instead of pr_debug()
      PCI: Fix NULL pointer dereference in of_pci_bus_find_domain_nr()
      rapidio/tsi721: use PCI_EXP_DEVCTL2_COMP_TIMEOUT macro

commit 3da1b6174ba3f573ee795cc25c4b8633749bd036
Merge: a5c6ad7840e1 6183d9b3ce79
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Apr 4 13:27:43 2018 -0500

    Merge branch 'pci/lpc'
    
      - add support for PCI I/O port space that's neither directly accessible
        via CPU in/out instructions nor directly mapped into CPU physical
        memory space (Zhichang Yuan)
    
      - add support for HiSilicon Hip06/Hip07 LPC I/O space (Zhichang Yuan,
        John Garry)
    
    * pci/lpc:
      MAINTAINERS: Add John Garry as maintainer for HiSilicon LPC driver
      HISI LPC: Add ACPI support
      ACPI / scan: Do not enumerate Indirect IO host children
      ACPI / scan: Rename acpi_is_serial_bus_slave() for more general use
      HISI LPC: Support the LPC host on Hip06/Hip07 with DT bindings
      of: Add missing I/O range exception for indirect-IO devices
      PCI: Apply the new generic I/O management on PCI IO hosts
      PCI: Add fwnode handler as input param of pci_register_io_range()
      PCI: Remove __weak tag from pci_register_io_range()
      lib: Add generic PIO mapping method

commit 5745392e0c2b78e0d73203281d5c42cbd6993194
Author: Zhichang Yuan <yuanzhichang@hisilicon.com>
Date:   Thu Mar 15 02:15:53 2018 +0800

    PCI: Apply the new generic I/O management on PCI IO hosts
    
    After introducing the new generic I/O space management (Logical PIO), the
    original PCI MMIO relevant helpers need to be updated based on the new
    interfaces defined in logical PIO.
    
    Adapt the corresponding code to match the changes introduced by logical
    PIO.
    
    Tested-by: dann frazier <dann.frazier@canonical.com>
    Signed-off-by: Zhichang Yuan <yuanzhichang@hisilicon.com>
    Signed-off-by: Gabriele Paoloni <gabriele.paoloni@huawei.com>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>        # earlier draft
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 07290a31370c..83a263fc9246 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -22,6 +22,7 @@
 #include <linux/spinlock.h>
 #include <linux/string.h>
 #include <linux/log2.h>
+#include <linux/logic_pio.h>
 #include <linux/pci-aspm.h>
 #include <linux/pm_wakeup.h>
 #include <linux/interrupt.h>
@@ -3440,17 +3441,6 @@ int pci_request_regions_exclusive(struct pci_dev *pdev, const char *res_name)
 }
 EXPORT_SYMBOL(pci_request_regions_exclusive);
 
-#ifdef PCI_IOBASE
-struct io_range {
-	struct list_head list;
-	phys_addr_t start;
-	resource_size_t size;
-};
-
-static LIST_HEAD(io_range_list);
-static DEFINE_SPINLOCK(io_range_lock);
-#endif
-
 /*
  * Record the PCI IO range (expressed as CPU physical address + size).
  * Return a negative value if an error has occured, zero otherwise
@@ -3458,51 +3448,28 @@ static DEFINE_SPINLOCK(io_range_lock);
 int pci_register_io_range(struct fwnode_handle *fwnode, phys_addr_t addr,
 			resource_size_t	size)
 {
-	int err = 0;
-
+	int ret = 0;
 #ifdef PCI_IOBASE
-	struct io_range *range;
-	resource_size_t allocated_size = 0;
-
-	/* check if the range hasn't been previously recorded */
-	spin_lock(&io_range_lock);
-	list_for_each_entry(range, &io_range_list, list) {
-		if (addr >= range->start && addr + size <= range->start + size) {
-			/* range already registered, bail out */
-			goto end_register;
-		}
-		allocated_size += range->size;
-	}
+	struct logic_pio_hwaddr *range;
 
-	/* range not registed yet, check for available space */
-	if (allocated_size + size - 1 > IO_SPACE_LIMIT) {
-		/* if it's too big check if 64K space can be reserved */
-		if (allocated_size + SZ_64K - 1 > IO_SPACE_LIMIT) {
-			err = -E2BIG;
-			goto end_register;
-		}
-
-		size = SZ_64K;
-		pr_warn("Requested IO range too big, new size set to 64K\n");
-	}
+	if (!size || addr + size < addr)
+		return -EINVAL;
 
-	/* add the range to the list */
 	range = kzalloc(sizeof(*range), GFP_ATOMIC);
-	if (!range) {
-		err = -ENOMEM;
-		goto end_register;
-	}
+	if (!range)
+		return -ENOMEM;
 
-	range->start = addr;
+	range->fwnode = fwnode;
 	range->size = size;
+	range->hw_start = addr;
+	range->flags = LOGIC_PIO_CPU_MMIO;
 
-	list_add_tail(&range->list, &io_range_list);
-
-end_register:
-	spin_unlock(&io_range_lock);
+	ret = logic_pio_register_range(range);
+	if (ret)
+		kfree(range);
 #endif
 
-	return err;
+	return ret;
 }
 
 phys_addr_t pci_pio_to_address(unsigned long pio)
@@ -3510,21 +3477,10 @@ phys_addr_t pci_pio_to_address(unsigned long pio)
 	phys_addr_t address = (phys_addr_t)OF_BAD_ADDR;
 
 #ifdef PCI_IOBASE
-	struct io_range *range;
-	resource_size_t allocated_size = 0;
-
-	if (pio > IO_SPACE_LIMIT)
+	if (pio >= MMIO_UPPER_LIMIT)
 		return address;
 
-	spin_lock(&io_range_lock);
-	list_for_each_entry(range, &io_range_list, list) {
-		if (pio >= allocated_size && pio < allocated_size + range->size) {
-			address = range->start + pio - allocated_size;
-			break;
-		}
-		allocated_size += range->size;
-	}
-	spin_unlock(&io_range_lock);
+	address = logic_pio_to_hwaddr(pio);
 #endif
 
 	return address;
@@ -3533,21 +3489,7 @@ phys_addr_t pci_pio_to_address(unsigned long pio)
 unsigned long __weak pci_address_to_pio(phys_addr_t address)
 {
 #ifdef PCI_IOBASE
-	struct io_range *res;
-	resource_size_t offset = 0;
-	unsigned long addr = -1;
-
-	spin_lock(&io_range_lock);
-	list_for_each_entry(res, &io_range_list, list) {
-		if (address >= res->start && address < res->start + res->size) {
-			addr = address - res->start + offset;
-			break;
-		}
-		offset += res->size;
-	}
-	spin_unlock(&io_range_lock);
-
-	return addr;
+	return logic_pio_trans_cpuaddr(address);
 #else
 	if (address > IO_SPACE_LIMIT)
 		return (unsigned long)-1;

commit fcfaab30933bd151bd8cb4dd07b3f11d885bb611
Author: Gabriele Paoloni <gabriele.paoloni@huawei.com>
Date:   Thu Mar 15 02:15:52 2018 +0800

    PCI: Add fwnode handler as input param of pci_register_io_range()
    
    In preparation for having the PCI MMIO helpers use the new generic I/O
    space management (logical PIO) we need to add the fwnode handler as an
    extra input parameter.
    
    Changes the signature of pci_register_io_range() and its callers as
    needed.
    
    Tested-by: dann frazier <dann.frazier@canonical.com>
    Signed-off-by: Gabriele Paoloni <gabriele.paoloni@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Acked-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 4666a016356e..07290a31370c 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -3455,7 +3455,8 @@ static DEFINE_SPINLOCK(io_range_lock);
  * Record the PCI IO range (expressed as CPU physical address + size).
  * Return a negative value if an error has occured, zero otherwise
  */
-int pci_register_io_range(phys_addr_t addr, resource_size_t size)
+int pci_register_io_range(struct fwnode_handle *fwnode, phys_addr_t addr,
+			resource_size_t	size)
 {
 	int err = 0;
 

commit e2515476ab3ca228369be14ac4792787c91d1804
Author: Gabriele Paoloni <gabriele.paoloni@huawei.com>
Date:   Thu Mar 15 02:15:51 2018 +0800

    PCI: Remove __weak tag from pci_register_io_range()
    
    pci_register_io_range() has only one definition, so there is no need for
    the __weak attribute.  Remove it.
    
    Tested-by: dann frazier <dann.frazier@canonical.com>
    Signed-off-by: Gabriele Paoloni <gabriele.paoloni@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index f6a4dd10d9b0..4666a016356e 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -3455,7 +3455,7 @@ static DEFINE_SPINLOCK(io_range_lock);
  * Record the PCI IO range (expressed as CPU physical address + size).
  * Return a negative value if an error has occured, zero otherwise
  */
-int __weak pci_register_io_range(phys_addr_t addr, resource_size_t size)
+int pci_register_io_range(phys_addr_t addr, resource_size_t size)
 {
 	int err = 0;
 

commit 9e506a7b51474241f0c900e53e85512780275c05
Author: Tal Gilboa <talgi@mellanox.com>
Date:   Fri Mar 30 08:56:47 2018 -0500

    PCI: Add pcie_print_link_status() to log link speed and whether it's limited
    
    Add pcie_print_link_status().  This logs the current settings of the link
    (speed, width, and total available bandwidth).
    
    If the device is capable of more bandwidth but is limited by a slower
    upstream link, we include information about the link that limits the
    device's performance.
    
    The user may be able to move the device to a different slot for better
    performance.
    
    This provides a unified method for all PCI devices to report status and
    issues, instead of each device reporting in a different way, using
    different code.
    
    Signed-off-by: Tal Gilboa <talgi@mellanox.com>
    [bhelgaas: changelog, reword log messages, print device capabilities when
    not limited, print bandwidth in Gb/s]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 91138cbeb853..e7a3917ed389 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -5288,6 +5288,38 @@ u32 pcie_bandwidth_capable(struct pci_dev *dev, enum pci_bus_speed *speed,
 	return *width * PCIE_SPEED2MBS_ENC(*speed);
 }
 
+/**
+ * pcie_print_link_status - Report the PCI device's link speed and width
+ * @dev: PCI device to query
+ *
+ * Report the available bandwidth at the device.  If this is less than the
+ * device is capable of, report the device's maximum possible bandwidth and
+ * the upstream link that limits its performance to less than that.
+ */
+void pcie_print_link_status(struct pci_dev *dev)
+{
+	enum pcie_link_width width, width_cap;
+	enum pci_bus_speed speed, speed_cap;
+	struct pci_dev *limiting_dev = NULL;
+	u32 bw_avail, bw_cap;
+
+	bw_cap = pcie_bandwidth_capable(dev, &speed_cap, &width_cap);
+	bw_avail = pcie_bandwidth_available(dev, &limiting_dev, &speed, &width);
+
+	if (bw_avail >= bw_cap)
+		pci_info(dev, "%u.%03u Gb/s available bandwidth (%s x%d link)\n",
+			 bw_cap / 1000, bw_cap % 1000,
+			 PCIE_SPEED2STR(speed_cap), width_cap);
+	else
+		pci_info(dev, "%u.%03u Gb/s available bandwidth, limited by %s x%d link at %s (capable of %u.%03u Gb/s with %s x%d link)\n",
+			 bw_avail / 1000, bw_avail % 1000,
+			 PCIE_SPEED2STR(speed), width,
+			 limiting_dev ? pci_name(limiting_dev) : "<unknown>",
+			 bw_cap / 1000, bw_cap % 1000,
+			 PCIE_SPEED2STR(speed_cap), width_cap);
+}
+EXPORT_SYMBOL(pcie_print_link_status);
+
 /**
  * pci_select_bars - Make BAR mask from the type of resource
  * @dev: the PCI device for which BAR mask is made

commit 6db79a88c67e4679d9c1e4a3f05c6385e21f6e9a
Author: Tal Gilboa <talgi@mellanox.com>
Date:   Fri Mar 30 08:37:44 2018 -0500

    PCI: Add pcie_bandwidth_available() to compute bandwidth available to device
    
    Add pcie_bandwidth_available() to compute the bandwidth available to a
    device.  This may be limited by the device itself or by a slower upstream
    link leading to the device.
    
    The available bandwidth at each link along the path is computed as:
    
      link_width * link_speed * (1 - encoding_overhead)
    
    2.5 and 5.0 GT/s links use 8b/10b encoding, which reduces the raw bandwidth
    available by 20%; 8.0 GT/s and faster links use 128b/130b encoding, which
    reduces it by about 1.5%.
    
    The result is in Mb/s, i.e., megabits/second, of raw bandwidth.
    
    Also return the device with the slowest link and the speed and width of
    that link.
    
    Signed-off-by: Tal Gilboa <talgi@mellanox.com>
    [bhelgaas: changelog, leave pcie_get_minimum_link() alone for now, return
    bw directly, use pci_upstream_bridge(), check "next_bw <= bw" to find
    uppermost limiting device, return speed/width of the limiting device]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index ff1e72060952..91138cbeb853 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -5146,6 +5146,64 @@ int pcie_get_minimum_link(struct pci_dev *dev, enum pci_bus_speed *speed,
 }
 EXPORT_SYMBOL(pcie_get_minimum_link);
 
+/**
+ * pcie_bandwidth_available - determine minimum link settings of a PCIe
+ *			      device and its bandwidth limitation
+ * @dev: PCI device to query
+ * @limiting_dev: storage for device causing the bandwidth limitation
+ * @speed: storage for speed of limiting device
+ * @width: storage for width of limiting device
+ *
+ * Walk up the PCI device chain and find the point where the minimum
+ * bandwidth is available.  Return the bandwidth available there and (if
+ * limiting_dev, speed, and width pointers are supplied) information about
+ * that point.  The bandwidth returned is in Mb/s, i.e., megabits/second of
+ * raw bandwidth.
+ */
+u32 pcie_bandwidth_available(struct pci_dev *dev, struct pci_dev **limiting_dev,
+			     enum pci_bus_speed *speed,
+			     enum pcie_link_width *width)
+{
+	u16 lnksta;
+	enum pci_bus_speed next_speed;
+	enum pcie_link_width next_width;
+	u32 bw, next_bw;
+
+	if (speed)
+		*speed = PCI_SPEED_UNKNOWN;
+	if (width)
+		*width = PCIE_LNK_WIDTH_UNKNOWN;
+
+	bw = 0;
+
+	while (dev) {
+		pcie_capability_read_word(dev, PCI_EXP_LNKSTA, &lnksta);
+
+		next_speed = pcie_link_speed[lnksta & PCI_EXP_LNKSTA_CLS];
+		next_width = (lnksta & PCI_EXP_LNKSTA_NLW) >>
+			PCI_EXP_LNKSTA_NLW_SHIFT;
+
+		next_bw = next_width * PCIE_SPEED2MBS_ENC(next_speed);
+
+		/* Check if current device limits the total bandwidth */
+		if (!bw || next_bw <= bw) {
+			bw = next_bw;
+
+			if (limiting_dev)
+				*limiting_dev = dev;
+			if (speed)
+				*speed = next_speed;
+			if (width)
+				*width = next_width;
+		}
+
+		dev = pci_upstream_bridge(dev);
+	}
+
+	return bw;
+}
+EXPORT_SYMBOL(pcie_bandwidth_available);
+
 /**
  * pcie_get_speed_cap - query for the PCI device's link speed capability
  * @dev: PCI device to query

commit cea061e455c88312b86142e68c8fc5b8e1294ca2
Merge: d22fff81418e 47a9973d3ed8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Apr 2 16:15:32 2018 -0700

    Merge branch 'x86-platform-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull x86 platform updates from Ingo Molnar:
     "The main changes in this cycle were:
    
       - Add "Jailhouse" hypervisor support (Jan Kiszka)
    
       - Update DeviceTree support (Ivan Gorinov)
    
       - Improve DMI date handling (Andy Shevchenko)"
    
    * 'x86-platform-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      x86/PCI: Fix a potential regression when using dmi_get_bios_year()
      firmware/dmi_scan: Uninline dmi_get_bios_year() helper
      x86/devicetree: Use CPU description from Device Tree
      of/Documentation: Specify local APIC ID in "reg"
      MAINTAINERS: Add entry for Jailhouse
      x86/jailhouse: Allow to use PCI_MMCONFIG without ACPI
      x86: Consolidate PCI_MMCONFIG configs
      x86: Align x86_64 PCI_MMCONFIG with 32-bit variant
      x86/jailhouse: Enable PCI mmconfig access in inmates
      PCI: Scan all functions when running over Jailhouse
      jailhouse: Provide detection for non-x86 systems
      x86/devicetree: Fix device IRQ settings in DT
      x86/devicetree: Initialize device tree before using it
      pci: Simplify code by using the new dmi_get_bios_year() helper
      ACPI/sleep: Simplify code by using the new dmi_get_bios_year() helper
      x86/pci: Simplify code by using the new dmi_get_bios_year() helper
      dmi: Introduce the dmi_get_bios_year() helper function
      x86/platform/quark: Re-use DEFINE_SHOW_ATTRIBUTE() macro
      x86/platform/atom: Re-use DEFINE_SHOW_ATTRIBUTE() macro

commit b852f63aa6cee3f4846383377c414ae9c4fbc166
Author: Tal Gilboa <talgi@mellanox.com>
Date:   Fri Mar 30 08:32:03 2018 -0500

    PCI: Add pcie_bandwidth_capable() to compute max supported link bandwidth
    
    Add pcie_bandwidth_capable() to compute the max link bandwidth supported by
    a device, based on the max link speed and width, adjusted by the encoding
    overhead.
    
    The maximum bandwidth of the link is computed as:
    
      max_link_width * max_link_speed * (1 - encoding_overhead)
    
    2.5 and 5.0 GT/s links use 8b/10b encoding, which reduces the raw bandwidth
    available by 20%; 8.0 GT/s and faster links use 128b/130b encoding, which
    reduces it by about 1.5%.
    
    The result is in Mb/s, i.e., megabits/second, of raw bandwidth.
    
    Signed-off-by: Tal Gilboa <talgi@mellanox.com>
    [bhelgaas: add 16 GT/s, adjust for pcie_get_speed_cap() and
    pcie_get_width_cap() signatures, don't export outside drivers/pci]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 43075be79388..ff1e72060952 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -5208,6 +5208,28 @@ enum pcie_link_width pcie_get_width_cap(struct pci_dev *dev)
 	return PCIE_LNK_WIDTH_UNKNOWN;
 }
 
+/**
+ * pcie_bandwidth_capable - calculate a PCI device's link bandwidth capability
+ * @dev: PCI device
+ * @speed: storage for link speed
+ * @width: storage for link width
+ *
+ * Calculate a PCI device's link bandwidth by querying for its link speed
+ * and width, multiplying them, and applying encoding overhead.  The result
+ * is in Mb/s, i.e., megabits/second of raw bandwidth.
+ */
+u32 pcie_bandwidth_capable(struct pci_dev *dev, enum pci_bus_speed *speed,
+			   enum pcie_link_width *width)
+{
+	*speed = pcie_get_speed_cap(dev);
+	*width = pcie_get_width_cap(dev);
+
+	if (*speed == PCI_SPEED_UNKNOWN || *width == PCIE_LNK_WIDTH_UNKNOWN)
+		return 0;
+
+	return *width * PCIE_SPEED2MBS_ENC(*speed);
+}
+
 /**
  * pci_select_bars - Make BAR mask from the type of resource
  * @dev: the PCI device for which BAR mask is made

commit c70b65fb7f121da7d01f62588ce6abb4741f513f
Author: Tal Gilboa <talgi@mellanox.com>
Date:   Fri Mar 30 08:24:36 2018 -0500

    PCI: Add pcie_get_width_cap() to find max supported link width
    
    Add pcie_get_width_cap() to find the max link width supported by a device.
    Change max_link_width_show() to use pcie_get_width_cap().
    
    Signed-off-by: Tal Gilboa <talgi@mellanox.com>
    [bhelgaas: return width directly instead of error and *width, don't export
    outside drivers/pci]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Tariq Toukan <tariqt@mellanox.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index b29d3436ee9f..43075be79388 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -5190,6 +5190,24 @@ enum pci_bus_speed pcie_get_speed_cap(struct pci_dev *dev)
 	return PCI_SPEED_UNKNOWN;
 }
 
+/**
+ * pcie_get_width_cap - query for the PCI device's link width capability
+ * @dev: PCI device to query
+ *
+ * Query the PCI device width capability.  Return the maximum link width
+ * supported by the device.
+ */
+enum pcie_link_width pcie_get_width_cap(struct pci_dev *dev)
+{
+	u32 lnkcap;
+
+	pcie_capability_read_dword(dev, PCI_EXP_LNKCAP, &lnkcap);
+	if (lnkcap)
+		return (lnkcap & PCI_EXP_LNKCAP_MLW) >> 4;
+
+	return PCIE_LNK_WIDTH_UNKNOWN;
+}
+
 /**
  * pci_select_bars - Make BAR mask from the type of resource
  * @dev: the PCI device for which BAR mask is made

commit 6cf57be0f78e289aaf236f8bc55c40ea6c422c75
Author: Tal Gilboa <talgi@mellanox.com>
Date:   Fri Mar 30 07:44:05 2018 -0500

    PCI: Add pcie_get_speed_cap() to find max supported link speed
    
    Add pcie_get_speed_cap() to find the max link speed supported by a device.
    Change max_link_speed_show() to use pcie_get_speed_cap().
    
    Signed-off-by: Tal Gilboa <talgi@mellanox.com>
    [bhelgaas: return speed directly instead of error and *speed, don't export
    outside drivers/pci]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Tariq Toukan <tariqt@mellanox.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index f6a4dd10d9b0..b29d3436ee9f 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -5146,6 +5146,50 @@ int pcie_get_minimum_link(struct pci_dev *dev, enum pci_bus_speed *speed,
 }
 EXPORT_SYMBOL(pcie_get_minimum_link);
 
+/**
+ * pcie_get_speed_cap - query for the PCI device's link speed capability
+ * @dev: PCI device to query
+ *
+ * Query the PCI device speed capability.  Return the maximum link speed
+ * supported by the device.
+ */
+enum pci_bus_speed pcie_get_speed_cap(struct pci_dev *dev)
+{
+	u32 lnkcap2, lnkcap;
+
+	/*
+	 * PCIe r4.0 sec 7.5.3.18 recommends using the Supported Link
+	 * Speeds Vector in Link Capabilities 2 when supported, falling
+	 * back to Max Link Speed in Link Capabilities otherwise.
+	 */
+	pcie_capability_read_dword(dev, PCI_EXP_LNKCAP2, &lnkcap2);
+	if (lnkcap2) { /* PCIe r3.0-compliant */
+		if (lnkcap2 & PCI_EXP_LNKCAP2_SLS_16_0GB)
+			return PCIE_SPEED_16_0GT;
+		else if (lnkcap2 & PCI_EXP_LNKCAP2_SLS_8_0GB)
+			return PCIE_SPEED_8_0GT;
+		else if (lnkcap2 & PCI_EXP_LNKCAP2_SLS_5_0GB)
+			return PCIE_SPEED_5_0GT;
+		else if (lnkcap2 & PCI_EXP_LNKCAP2_SLS_2_5GB)
+			return PCIE_SPEED_2_5GT;
+		return PCI_SPEED_UNKNOWN;
+	}
+
+	pcie_capability_read_dword(dev, PCI_EXP_LNKCAP, &lnkcap);
+	if (lnkcap) {
+		if (lnkcap & PCI_EXP_LNKCAP_SLS_16_0GB)
+			return PCIE_SPEED_16_0GT;
+		else if (lnkcap & PCI_EXP_LNKCAP_SLS_8_0GB)
+			return PCIE_SPEED_8_0GT;
+		else if (lnkcap & PCI_EXP_LNKCAP_SLS_5_0GB)
+			return PCIE_SPEED_5_0GT;
+		else if (lnkcap & PCI_EXP_LNKCAP_SLS_2_5GB)
+			return PCIE_SPEED_2_5GT;
+	}
+
+	return PCI_SPEED_UNKNOWN;
+}
+
 /**
  * pci_select_bars - Make BAR mask from the type of resource
  * @dev: the PCI device for which BAR mask is made

commit df62ab5e0f75608919df7442654b0fab78246b7b
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Mar 9 16:36:33 2018 -0600

    PCI: Tidy comments
    
    Remove pointless comments that tell us the file name, remove blank line
    comments, follow multi-line comment conventions.  No functional change
    intended.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index b7ff5786b76b..22f06de93696 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1,11 +1,11 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- *	PCI Bus Services, see include/linux/pci.h for further explanation.
+ * PCI Bus Services, see include/linux/pci.h for further explanation.
  *
- *	Copyright 1993 -- 1997 Drew Eckhardt, Frederic Potter,
- *	David Mosberger-Tang
+ * Copyright 1993 -- 1997 Drew Eckhardt, Frederic Potter,
+ * David Mosberger-Tang
  *
- *	Copyright 1997 -- 2000 Martin Mares <mj@ucw.cz>
+ * Copyright 1997 -- 2000 Martin Mares <mj@ucw.cz>
  */
 
 #include <linux/acpi.h>
@@ -4183,6 +4183,7 @@ void pci_reset_secondary_bus(struct pci_dev *dev)
 	pci_read_config_word(dev, PCI_BRIDGE_CONTROL, &ctrl);
 	ctrl |= PCI_BRIDGE_CTL_BUS_RESET;
 	pci_write_config_word(dev, PCI_BRIDGE_CONTROL, ctrl);
+
 	/*
 	 * PCI spec v3.0 7.6.4.2 requires minimum Trst of 1ms.  Double
 	 * this to 2ms to ensure that we meet the minimum requirement.

commit 2a4d2c4240c00e7db8fb64e377bd2180cc30b146
Author: Lukas Wunner <lukas@wunner.de>
Date:   Sat Mar 3 10:53:24 2018 +0100

    PCI: Make pci_wakeup_bus() & pci_bus_set_current_state() public
    
    There are PCI devices which are power-manageable by a nonstandard means,
    such as a custom ACPI method.  One example are discrete GPUs in hybrid
    graphics laptops, another are Thunderbolt controllers in Macs.
    
    Such devices can't be put into D3cold with pci_set_power_state() because
    pci_platform_power_transition() fails with -ENODEV.  Instead they're put
    into D3hot by pci_set_power_state() and subsequently into D3cold by
    invoking the nonstandard means.  However as a consequence the cached
    current_state is incorrectly left at D3hot.
    
    What we need to do is walk the hierarchy below such a PCI device on
    powerdown and update the current_state to D3cold.  On powerup the PCI
    device itself and the hierarchy below it is in D0uninitialized, so we
    need to walk the hierarchy again and wake all devices, causing them to
    be put into D0active and then letting them autosuspend as they see fit.
    
    To this end make pci_wakeup_bus() & pci_bus_set_current_state() public
    so PCI drivers don't have to reinvent the wheel.
    
    Cc: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Link: https://patchwork.freedesktop.org/patch/msgid/2962443259e7faec577274b4ef8c54aad66f9a94.1520068884.git.lukas@wunner.de

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index f6a4dd10d9b0..bd6f156dc3cf 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -800,7 +800,7 @@ static int pci_wakeup(struct pci_dev *pci_dev, void *ign)
  * pci_wakeup_bus - Walk given bus and wake up devices on it
  * @bus: Top bus of the subtree to walk.
  */
-static void pci_wakeup_bus(struct pci_bus *bus)
+void pci_wakeup_bus(struct pci_bus *bus)
 {
 	if (bus)
 		pci_walk_bus(bus, pci_wakeup, NULL);
@@ -850,11 +850,11 @@ static int __pci_dev_set_current_state(struct pci_dev *dev, void *data)
 }
 
 /**
- * __pci_bus_set_current_state - Walk given bus and set current state of devices
+ * pci_bus_set_current_state - Walk given bus and set current state of devices
  * @bus: Top bus of the subtree to walk.
  * @state: state to be set
  */
-static void __pci_bus_set_current_state(struct pci_bus *bus, pci_power_t state)
+void pci_bus_set_current_state(struct pci_bus *bus, pci_power_t state)
 {
 	if (bus)
 		pci_walk_bus(bus, __pci_dev_set_current_state, &state);
@@ -876,7 +876,7 @@ int __pci_complete_power_transition(struct pci_dev *dev, pci_power_t state)
 	ret = pci_platform_power_transition(dev, state);
 	/* Power off the bridge may power off the whole hierarchy */
 	if (!ret && state == PCI_D3cold)
-		__pci_bus_set_current_state(dev->subordinate, PCI_D3cold);
+		pci_bus_set_current_state(dev->subordinate, PCI_D3cold);
 	return ret;
 }
 EXPORT_SYMBOL_GPL(__pci_complete_power_transition);

commit dcb0453d71e361d4718bb566d99e6ae498284419
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Mar 9 11:06:53 2018 -0600

    PCI/PM: Move pcie_clear_root_pme_status() to core
    
    Move pcie_clear_root_pme_status() from the port driver to the PCI core so
    it will be available even when the port driver isn't present.  No
    functional change intended.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index f6a4dd10d9b0..120e3393fc35 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1683,6 +1683,15 @@ int pci_set_pcie_reset_state(struct pci_dev *dev, enum pcie_reset_state state)
 }
 EXPORT_SYMBOL_GPL(pci_set_pcie_reset_state);
 
+/**
+ * pcie_clear_root_pme_status - Clear root port PME interrupt status.
+ * @dev: PCIe root port or event collector.
+ */
+void pcie_clear_root_pme_status(struct pci_dev *dev)
+{
+	pcie_capability_set_dword(dev, PCI_EXP_RTSTA, PCI_EXP_RTSTA_PME);
+}
+
 /**
  * pci_check_pme_status - Check if given device has generated PME.
  * @dev: Device to check.

commit 6b2f1351af567110cec80d7c067314c633a14f50
Author: Sinan Kaya <okaya@codeaurora.org>
Date:   Tue Feb 27 14:14:12 2018 -0600

    PCI: Wait for device to become ready after secondary bus reset
    
    Setting Secondary Bus Reset of a downstream port sends a hot reset.  PCIe
    r4.0, sec 2.3.1, Request Handling Rules, indicates that a device can return
    CRS Completion Status following such a reset.  Wait until the device
    becomes ready in that situation.
    
    Signed-off-by: Sinan Kaya <okaya@codeaurora.org>
    Signed-off-by: Bjorn Helgaas <helgaas@kernel.org>
    Reviewed-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index dde40506ffe5..0b8e8ee84bbc 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -4233,7 +4233,7 @@ int pci_reset_bridge_secondary_bus(struct pci_dev *dev)
 {
 	pcibios_reset_secondary_bus(dev);
 
-	return 0;
+	return pci_dev_wait(dev, "bus reset", PCIE_RESET_READY_POLL_MS);
 }
 EXPORT_SYMBOL_GPL(pci_reset_bridge_secondary_bus);
 

commit 01fd61c0b9bd85ab41fb60fbd781d44882ee6887
Author: Sinan Kaya <okaya@codeaurora.org>
Date:   Tue Feb 27 14:14:11 2018 -0600

    PCI: Add a return type for pci_reset_bridge_secondary_bus()
    
    Add a return value to pci_reset_bridge_secondary_bus() so we can return an
    error if the device doesn't become ready after the reset.
    
    Signed-off-by: Sinan Kaya <okaya@codeaurora.org>
    Signed-off-by: Bjorn Helgaas <helgaas@kernel.org>
    Reviewed-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index a3042e475901..dde40506ffe5 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -4229,9 +4229,11 @@ void __weak pcibios_reset_secondary_bus(struct pci_dev *dev)
  * Use the bridge control register to assert reset on the secondary bus.
  * Devices on the secondary bus are left in power-on state.
  */
-void pci_reset_bridge_secondary_bus(struct pci_dev *dev)
+int pci_reset_bridge_secondary_bus(struct pci_dev *dev)
 {
 	pcibios_reset_secondary_bus(dev);
+
+	return 0;
 }
 EXPORT_SYMBOL_GPL(pci_reset_bridge_secondary_bus);
 

commit abbcf0e2a99d55433b2ee44794e6f875fc36aae2
Author: Sinan Kaya <okaya@codeaurora.org>
Date:   Tue Feb 27 14:14:10 2018 -0600

    PCI: Wait for device to become ready after a power management reset
    
    PCIe r4.0, sec 2.3.1, Request Handling Rules, indicates that a device can
    return CRS Completion Status following a D3hot to D0 transition.  Wait
    until the device becomes ready in that situation.
    
    Signed-off-by: Sinan Kaya <okaya@codeaurora.org>
    Signed-off-by: Bjorn Helgaas <helgaas@kernel.org>
    Reviewed-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 9493b97436c3..a3042e475901 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -4188,7 +4188,7 @@ static int pci_pm_reset(struct pci_dev *dev, int probe)
 	pci_write_config_word(dev, dev->pm_cap + PCI_PM_CTRL, csr);
 	pci_dev_d3_sleep(dev);
 
-	return 0;
+	return pci_dev_wait(dev, "PM D3->D0", PCIE_RESET_READY_POLL_MS);
 }
 
 void pci_reset_secondary_bus(struct pci_dev *dev)

commit 9df1c6ecbf172fedb1f4f76585338860595b9bf7
Author: Shawn Lin <shawn.lin@rock-chips.com>
Date:   Thu Mar 1 09:26:55 2018 +0800

    PCI: Fix NULL pointer dereference in of_pci_bus_find_domain_nr()
    
    If the "parent" pointer passed to of_pci_bus_find_domain_nr() is NULL,
    don't dereference it.
    
    Signed-off-by: Shawn Lin <shawn.lin@rock-chips.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index f6a4dd10d9b0..b7ff5786b76b 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -5611,8 +5611,9 @@ static int of_pci_bus_find_domain_nr(struct device *parent)
 		use_dt_domains = 0;
 		domain = pci_get_new_domain_nr();
 	} else {
-		dev_err(parent, "Node %pOF has inconsistent \"linux,pci-domain\" property in DT\n",
-			parent->of_node);
+		if (parent)
+			pr_err("Node %pOF has ", parent->of_node);
+		pr_err("Inconsistent \"linux,pci-domain\" property in DT\n");
 		domain = -1;
 	}
 

commit a2758b6b8fdba5f1045f571fdb39d9bdb8ba0813
Author: Sinan Kaya <okaya@codeaurora.org>
Date:   Tue Feb 27 14:14:10 2018 -0600

    PCI: Rename pci_flr_wait() to pci_dev_wait() and make it generic
    
    PCIe r4.0, sec 2.3.1, Request Handling Rules, says:
    
      Valid reset conditions after which a device is permitted to return CRS
      are:
      * Cold, Warm, and Hot Resets,
      * FLR
      * A reset initiated in response to a D3hot to D0 uninitialized
    
    Try to reuse FLR implementation towards other reset types.
    
    Signed-off-by: Sinan Kaya <okaya@codeaurora.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 7aa11b1fbee3..9493b97436c3 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -126,6 +126,9 @@ static int __init pcie_port_pm_setup(char *str)
 }
 __setup("pcie_port_pm=", pcie_port_pm_setup);
 
+/* Time to wait after a reset for device to become responsive */
+#define PCIE_RESET_READY_POLL_MS 60000
+
 /**
  * pci_bus_max_busnr - returns maximum PCI bus number of given bus' children
  * @bus: pointer to PCI bus structure to search
@@ -4017,20 +4020,13 @@ int pci_wait_for_pending_transaction(struct pci_dev *dev)
 }
 EXPORT_SYMBOL(pci_wait_for_pending_transaction);
 
-static int pci_flr_wait(struct pci_dev *dev)
+static int pci_dev_wait(struct pci_dev *dev, char *reset_type, int timeout)
 {
-	int delay = 1, timeout = 60000;
+	int delay = 1;
 	u32 id;
 
 	/*
-	 * Per PCIe r3.1, sec 6.6.2, a device must complete an FLR within
-	 * 100ms, but may silently discard requests while the FLR is in
-	 * progress.  Wait 100ms before trying to access the device.
-	 */
-	msleep(100);
-
-	/*
-	 * After 100ms, the device should not silently discard config
+	 * After reset, the device should not silently discard config
 	 * requests, but it may still indicate that it needs more time by
 	 * responding to them with CRS completions.  The Root Port will
 	 * generally synthesize ~0 data to complete the read (except when
@@ -4044,14 +4040,14 @@ static int pci_flr_wait(struct pci_dev *dev)
 	pci_read_config_dword(dev, PCI_COMMAND, &id);
 	while (id == ~0) {
 		if (delay > timeout) {
-			pci_warn(dev, "not ready %dms after FLR; giving up\n",
-				 100 + delay - 1);
+			pci_warn(dev, "not ready %dms after %s; giving up\n",
+				 delay - 1, reset_type);
 			return -ENOTTY;
 		}
 
 		if (delay > 1000)
-			pci_info(dev, "not ready %dms after FLR; waiting\n",
-				 100 + delay - 1);
+			pci_info(dev, "not ready %dms after %s; waiting\n",
+				 delay - 1, reset_type);
 
 		msleep(delay);
 		delay *= 2;
@@ -4059,7 +4055,8 @@ static int pci_flr_wait(struct pci_dev *dev)
 	}
 
 	if (delay > 1000)
-		pci_info(dev, "ready %dms after FLR\n", 100 + delay - 1);
+		pci_info(dev, "ready %dms after %s\n", delay - 1,
+			 reset_type);
 
 	return 0;
 }
@@ -4096,7 +4093,15 @@ int pcie_flr(struct pci_dev *dev)
 		pci_err(dev, "timed out waiting for pending transaction; performing function level reset anyway\n");
 
 	pcie_capability_set_word(dev, PCI_EXP_DEVCTL, PCI_EXP_DEVCTL_BCR_FLR);
-	return pci_flr_wait(dev);
+
+	/*
+	 * Per PCIe r4.0, sec 6.6.2, a device must complete an FLR within
+	 * 100ms, but may silently discard requests while the FLR is in
+	 * progress.  Wait 100ms before trying to access the device.
+	 */
+	msleep(100);
+
+	return pci_dev_wait(dev, "FLR", PCIE_RESET_READY_POLL_MS);
 }
 EXPORT_SYMBOL_GPL(pcie_flr);
 
@@ -4129,7 +4134,16 @@ static int pci_af_flr(struct pci_dev *dev, int probe)
 		pci_err(dev, "timed out waiting for pending transaction; performing AF function level reset anyway\n");
 
 	pci_write_config_byte(dev, pos + PCI_AF_CTRL, PCI_AF_CTRL_FLR);
-	return pci_flr_wait(dev);
+
+	/*
+	 * Per Advanced Capabilities for Conventional PCI ECN, 13 April 2006,
+	 * updated 27 July 2006; a device must complete an FLR within
+	 * 100ms, but may silently discard requests while the FLR is in
+	 * progress.  Wait 100ms before trying to access the device.
+	 */
+	msleep(100);
+
+	return pci_dev_wait(dev, "AF_FLR", PCIE_RESET_READY_POLL_MS);
 }
 
 /**

commit 91295d79d65892eabd02a2a75fd4ac88197d17a1
Author: Sinan Kaya <okaya@codeaurora.org>
Date:   Tue Feb 27 14:14:08 2018 -0600

    PCI: Handle FLR failure and allow other reset types
    
    pci_flr_wait() and pci_af_flr() functions assume graceful return even
    though the device is inaccessible under error conditions.
    
    Return -ENOTTY in error cases so that __pci_reset_function_locked() can
    try other reset types if AF_FLR/FLR reset fails.
    
    Signed-off-by: Sinan Kaya <okaya@codeaurora.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 660c848aa14a..7aa11b1fbee3 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -4017,7 +4017,7 @@ int pci_wait_for_pending_transaction(struct pci_dev *dev)
 }
 EXPORT_SYMBOL(pci_wait_for_pending_transaction);
 
-static void pci_flr_wait(struct pci_dev *dev)
+static int pci_flr_wait(struct pci_dev *dev)
 {
 	int delay = 1, timeout = 60000;
 	u32 id;
@@ -4046,7 +4046,7 @@ static void pci_flr_wait(struct pci_dev *dev)
 		if (delay > timeout) {
 			pci_warn(dev, "not ready %dms after FLR; giving up\n",
 				 100 + delay - 1);
-			return;
+			return -ENOTTY;
 		}
 
 		if (delay > 1000)
@@ -4060,6 +4060,8 @@ static void pci_flr_wait(struct pci_dev *dev)
 
 	if (delay > 1000)
 		pci_info(dev, "ready %dms after FLR\n", 100 + delay - 1);
+
+	return 0;
 }
 
 /**
@@ -4088,13 +4090,13 @@ static bool pcie_has_flr(struct pci_dev *dev)
  * device supports FLR before calling this function, e.g. by using the
  * pcie_has_flr() helper.
  */
-void pcie_flr(struct pci_dev *dev)
+int pcie_flr(struct pci_dev *dev)
 {
 	if (!pci_wait_for_pending_transaction(dev))
 		pci_err(dev, "timed out waiting for pending transaction; performing function level reset anyway\n");
 
 	pcie_capability_set_word(dev, PCI_EXP_DEVCTL, PCI_EXP_DEVCTL_BCR_FLR);
-	pci_flr_wait(dev);
+	return pci_flr_wait(dev);
 }
 EXPORT_SYMBOL_GPL(pcie_flr);
 
@@ -4127,8 +4129,7 @@ static int pci_af_flr(struct pci_dev *dev, int probe)
 		pci_err(dev, "timed out waiting for pending transaction; performing AF function level reset anyway\n");
 
 	pci_write_config_byte(dev, pos + PCI_AF_CTRL, PCI_AF_CTRL_FLR);
-	pci_flr_wait(dev);
-	return 0;
+	return pci_flr_wait(dev);
 }
 
 /**
@@ -4379,8 +4380,9 @@ int __pci_reset_function_locked(struct pci_dev *dev)
 	if (rc != -ENOTTY)
 		return rc;
 	if (pcie_has_flr(dev)) {
-		pcie_flr(dev);
-		return 0;
+		rc = pcie_flr(dev);
+		if (rc != -ENOTTY)
+			return rc;
 	}
 	rc = pci_af_flr(dev, 0);
 	if (rc != -ENOTTY)

commit cb5e0d060fb1f3136e96acecbd4001a7f0cbac94
Author: Sinan Kaya <okaya@codeaurora.org>
Date:   Tue Feb 27 14:14:08 2018 -0600

    PCI: Protect restore with device lock to be consistent
    
    Commit b014e96d1abb ("PCI: Protect pci_error_handlers->reset_notify() usage
    with device_lock()") added protection around pci_dev_restore() function so
    a device-specific remove callback does not cause a race condition with
    hotplug.
    
    pci_dev_lock() usage has been forgotten in two places.  Add locks for
    pci_slot_restore() and moving pci_dev_restore() inside the locks for
    pci_try_reset_function().
    
    Signed-off-by: Sinan Kaya <okaya@codeaurora.org>
    Signed-off-by: Bjorn Helgaas <helgaas@kernel.org>
    Reviewed-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 4db740e4f50a..660c848aa14a 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -4517,9 +4517,9 @@ int pci_try_reset_function(struct pci_dev *dev)
 
 	pci_dev_save_and_disable(dev);
 	rc = __pci_reset_function_locked(dev);
+	pci_dev_restore(dev);
 	pci_dev_unlock(dev);
 
-	pci_dev_restore(dev);
 	return rc;
 }
 EXPORT_SYMBOL_GPL(pci_try_reset_function);
@@ -4727,7 +4727,9 @@ static void pci_slot_restore(struct pci_slot *slot)
 	list_for_each_entry(dev, &slot->bus->devices, bus_list) {
 		if (!dev->slot || dev->slot != slot)
 			continue;
+		pci_dev_lock(dev);
 		pci_dev_restore(dev);
+		pci_dev_unlock(dev);
 		if (dev->subordinate)
 			pci_bus_restore(dev->subordinate);
 	}

commit ac95090a0440be1b17aa1b5d9462d9c67146ce0b
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Thu Feb 22 14:59:23 2018 +0200

    pci: Simplify code by using the new dmi_get_bios_year() helper
    
    ...instead of open coding its functionality.
    
    No changes in functionality.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Jean Delvare <jdelvare@suse.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-acpi@vger.kernel.org
    Cc: linux-pci@vger.kernel.org
    Link: http://lkml.kernel.org/r/20180222125923.57385-4-andriy.shevchenko@linux.intel.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index f6a4dd10d9b0..ae654e21439d 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2258,8 +2258,6 @@ void pci_config_pm_runtime_put(struct pci_dev *pdev)
  */
 bool pci_bridge_d3_possible(struct pci_dev *bridge)
 {
-	unsigned int year;
-
 	if (!pci_is_pcie(bridge))
 		return false;
 
@@ -2287,10 +2285,8 @@ bool pci_bridge_d3_possible(struct pci_dev *bridge)
 		 * It should be safe to put PCIe ports from 2015 or newer
 		 * to D3.
 		 */
-		if (dmi_get_date(DMI_BIOS_DATE, &year, NULL, NULL) &&
-		    year >= 2015) {
+		if (dmi_get_bios_year() >= 2015)
 			return true;
-		}
 		break;
 	}
 

commit 204f4afa7ae50239c39adb13af42f5720fe7e9a5
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Feb 16 15:22:39 2018 -0600

    PCI: Remove redundant probes for device reset support
    
    We probe every device for whether it supports reset so we can tell whether
    to create a sysfs "reset" file for it.  We do that probe in
    pci_init_capabilities() during enumeration and save the result in
    dev->reset_fn.  The result doesn't depend on any other devices on the bus
    and shouldn't change after boot, so we don't need to do the probe again.
    
    Remove the pci_probe_reset_function() calls and rely on the dev->reset_fn
    we found during enumeration.  No functional change intended.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index f6a4dd10d9b0..4db740e4f50a 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -4450,9 +4450,8 @@ int pci_reset_function(struct pci_dev *dev)
 {
 	int rc;
 
-	rc = pci_probe_reset_function(dev);
-	if (rc)
-		return rc;
+	if (!dev->reset_fn)
+		return -ENOTTY;
 
 	pci_dev_lock(dev);
 	pci_dev_save_and_disable(dev);
@@ -4487,9 +4486,8 @@ int pci_reset_function_locked(struct pci_dev *dev)
 {
 	int rc;
 
-	rc = pci_probe_reset_function(dev);
-	if (rc)
-		return rc;
+	if (!dev->reset_fn)
+		return -ENOTTY;
 
 	pci_dev_save_and_disable(dev);
 
@@ -4511,9 +4509,8 @@ int pci_try_reset_function(struct pci_dev *dev)
 {
 	int rc;
 
-	rc = pci_probe_reset_function(dev);
-	if (rc)
-		return rc;
+	if (!dev->reset_fn)
+		return -ENOTTY;
 
 	if (!pci_dev_trylock(dev))
 		return -EAGAIN;

commit 105cf3c8c6264dce4bcdab877feb8037bc4109b1
Merge: e237f98a9c13 ab8c609356fb
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Feb 6 09:59:40 2018 -0800

    Merge tag 'pci-v4.16-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI updates from Bjorn Helgaas:
    
     - skip AER driver error recovery callbacks for correctable errors
       reported via ACPI APEI, as we already do for errors reported via the
       native path (Tyler Baicar)
    
     - fix DPC shared interrupt handling (Alex Williamson)
    
     - print full DPC interrupt number (Keith Busch)
    
     - enable DPC only if AER is available (Keith Busch)
    
     - simplify DPC code (Bjorn Helgaas)
    
     - calculate ASPM L1 substate parameter instead of hardcoding it (Bjorn
       Helgaas)
    
     - enable Latency Tolerance Reporting for ASPM L1 substates (Bjorn
       Helgaas)
    
     - move ASPM internal interfaces out of public header (Bjorn Helgaas)
    
     - allow hot-removal of VGA devices (Mika Westerberg)
    
     - speed up unplug and shutdown by assuming Thunderbolt controllers
       don't support Command Completed events (Lukas Wunner)
    
     - add AtomicOps support for GPU and Infiniband drivers (Felix Kuehling,
       Jay Cornwall)
    
     - expose "ari_enabled" in sysfs to help NIC naming (Stuart Hayes)
    
     - clean up PCI DMA interface usage (Christoph Hellwig)
    
     - remove PCI pool API (replaced with DMA pool) (Romain Perier)
    
     - deprecate pci_get_bus_and_slot(), which assumed PCI domain 0 (Sinan
       Kaya)
    
     - move DT PCI code from drivers/of/ to drivers/pci/ (Rob Herring)
    
     - add PCI-specific wrappers for dev_info(), etc (Frederick Lawler)
    
     - remove warnings on sysfs mmap failure (Bjorn Helgaas)
    
     - quiet ROM validation messages (Alex Deucher)
    
     - remove redundant memory alloc failure messages (Markus Elfring)
    
     - fill in types for compile-time VGA and other I/O port resources
       (Bjorn Helgaas)
    
     - make "pci=pcie_scan_all" work for Root Ports as well as Downstream
       Ports to help AmigaOne X1000 (Bjorn Helgaas)
    
     - add SPDX tags to all PCI files (Bjorn Helgaas)
    
     - quirk Marvell 9128 DMA aliases (Alex Williamson)
    
     - quirk broken INTx disable on Ceton InfiniTV4 (Bjorn Helgaas)
    
     - fix CONFIG_PCI=n build by adding dummy pci_irqd_intx_xlate() (Niklas
       Cassel)
    
     - use DMA API to get MSI address for DesignWare IP (Niklas Cassel)
    
     - fix endpoint-mode DMA mask configuration (Kishon Vijay Abraham I)
    
     - fix ARTPEC-6 incorrect IS_ERR() usage (Wei Yongjun)
    
     - add support for ARTPEC-7 SoC (Niklas Cassel)
    
     - add endpoint-mode support for ARTPEC (Niklas Cassel)
    
     - add Cadence PCIe host and endpoint controller driver (Cyrille
       Pitchen)
    
     - handle multiple INTx status bits being set in dra7xx (Vignesh R)
    
     - translate dra7xx hwirq range to fix INTD handling (Vignesh R)
    
     - remove deprecated Exynos PHY initialization code (Jaehoon Chung)
    
     - fix MSI erratum workaround for HiSilicon Hip06/Hip07 (Dongdong Liu)
    
     - fix NULL pointer dereference in iProc BCMA driver (Ray Jui)
    
     - fix Keystone interrupt-controller-node lookup (Johan Hovold)
    
     - constify qcom driver structures (Julia Lawall)
    
     - rework Tegra config space mapping to increase space available for
       endpoints (Vidya Sagar)
    
     - simplify Tegra driver by using bus->sysdata (Manikanta Maddireddy)
    
     - remove PCI_REASSIGN_ALL_BUS usage on Tegra (Manikanta Maddireddy)
    
     - add support for Global Fabric Manager Server (GFMS) event to
       Microsemi Switchtec switch driver (Logan Gunthorpe)
    
     - add IDs for Switchtec PSX 24xG3 and PSX 48xG3 (Kelvin Cao)
    
    * tag 'pci-v4.16-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (140 commits)
      PCI: cadence: Add EndPoint Controller driver for Cadence PCIe controller
      dt-bindings: PCI: cadence: Add DT bindings for Cadence PCIe endpoint controller
      PCI: endpoint: Fix EPF device name to support multi-function devices
      PCI: endpoint: Add the function number as argument to EPC ops
      PCI: cadence: Add host driver for Cadence PCIe controller
      dt-bindings: PCI: cadence: Add DT bindings for Cadence PCIe host controller
      PCI: Add vendor ID for Cadence
      PCI: Add generic function to probe PCI host controllers
      PCI: generic: fix missing call of pci_free_resource_list()
      PCI: OF: Add generic function to parse and allocate PCI resources
      PCI: Regroup all PCI related entries into drivers/pci/Makefile
      PCI/DPC: Reformat DPC register definitions
      PCI/DPC: Add and use DPC Status register field definitions
      PCI/DPC: Squash dpc_rp_pio_get_info() into dpc_process_rp_pio_error()
      PCI/DPC: Remove unnecessary RP PIO register structs
      PCI/DPC: Push dpc->rp_pio_status assignment into dpc_rp_pio_get_info()
      PCI/DPC: Squash dpc_rp_pio_print_error() into dpc_rp_pio_get_info()
      PCI/DPC: Make RP PIO log size check more generic
      PCI/DPC: Rename local "status" to "dpc_status"
      PCI/DPC: Squash dpc_rp_pio_print_tlp_header() into dpc_rp_pio_print_error()
      ...

commit ab8c609356fbe8dbcd44df11e884ce8cddf3739e
Merge: a5fae846f21d 36b072742a83
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Feb 1 11:40:07 2018 -0600

    Merge branch 'pci/spdx' into next
    
    * pci/spdx:
      PCI: Add SPDX GPL-2.0+ to replace implicit GPL v2 or later statement
      PCI: Add SPDX GPL-2.0+ to replace GPL v2 or later boilerplate
      PCI: Add SPDX GPL-2.0 to replace COPYING boilerplate
      PCI: Add SPDX GPL-2.0 to replace GPL v2 boilerplate
      PCI: Add SPDX GPL-2.0 when no license was specified

commit 412ee7cd3dc581a37b7d15a5147a556e45445be1
Merge: 85d24b3fc222 80db6f08b7af
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Jan 31 10:10:32 2018 -0600

    Merge branch 'pci/misc' into next
    
    * pci/misc:
      PCI: Add dummy pci_irqd_intx_xlate() for CONFIG_PCI=n build
      PCI: Add wrappers for dev_printk()
      PCI: Remove unnecessary messages for memory allocation failures
      PCI: Add #defines for Completion Timeout Disable feature
      hinic: Replace PCI pool old API
      net: e100: Replace PCI pool old API
      block: DAC960: Replace PCI pool old API
      MAINTAINERS: Include more PCI files
      PCI: Remove unneeded kallsyms include
      powerpc/pci: Unroll two pass loop when scanning bridges
      powerpc/pci: Use for_each_pci_bridge() helper

commit 7328c8f48d1895b3fec98b0b319cfb856b4c4fa1
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Jan 26 11:45:16 2018 -0600

    PCI: Add SPDX GPL-2.0 when no license was specified
    
    b24413180f56 ("License cleanup: add SPDX GPL-2.0 license identifier to
    files with no license") added SPDX GPL-2.0 to several PCI files that
    previously contained no license information.
    
    Add SPDX GPL-2.0 to all other PCI files that did not contain any license
    information and hence were under the default GPL version 2 license of the
    kernel.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 4a7c6864fdf4..50e716b3e2b8 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  *	PCI Bus Services, see include/linux/pci.h for further explanation.
  *

commit 430a23689dea2e36ae5a0fc75a67301fd46b18bf
Author: Jay Cornwall <Jay.Cornwall@amd.com>
Date:   Thu Jan 4 19:44:59 2018 -0500

    PCI: Add pci_enable_atomic_ops_to_root()
    
    The Atomic Operations feature (PCIe r4.0, sec 6.15) allows atomic
    transctions to be requested by, routed through and completed by PCIe
    components. Routing and completion do not require software support.
    Component support for each is detectable via the DEVCAP2 register.
    
    A Requester may use AtomicOps only if its PCI_EXP_DEVCTL2_ATOMIC_REQ is
    set. This should be set only if the Completer and all intermediate routing
    elements support AtomicOps.
    
    A concrete example is the AMD Fiji-class GPU (which is capable of making
    AtomicOp requests), below a PLX 8747 switch (advertising AtomicOp routing)
    with a Haswell host bridge (advertising AtomicOp completion support).
    
    Add pci_enable_atomic_ops_to_root() for per-device control over AtomicOp
    requests. This checks to be sure the Root Port supports completion of the
    desired AtomicOp sizes and the path to the Root Port supports routing the
    AtomicOps.
    
    Signed-off-by: Jay Cornwall <Jay.Cornwall@amd.com>
    Signed-off-by: Felix Kuehling <Felix.Kuehling@amd.com>
    [bhelgaas: changelog, comments, whitespace]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 4a7c6864fdf4..6112dd8d68b6 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -3065,6 +3065,81 @@ int pci_rebar_set_size(struct pci_dev *pdev, int bar, int size)
 	return 0;
 }
 
+/**
+ * pci_enable_atomic_ops_to_root - enable AtomicOp requests to root port
+ * @dev: the PCI device
+ * @cap_mask: mask of desired AtomicOp sizes, including one or more of:
+ *	PCI_EXP_DEVCAP2_ATOMIC_COMP32
+ *	PCI_EXP_DEVCAP2_ATOMIC_COMP64
+ *	PCI_EXP_DEVCAP2_ATOMIC_COMP128
+ *
+ * Return 0 if all upstream bridges support AtomicOp routing, egress
+ * blocking is disabled on all upstream ports, and the root port supports
+ * the requested completion capabilities (32-bit, 64-bit and/or 128-bit
+ * AtomicOp completion), or negative otherwise.
+ */
+int pci_enable_atomic_ops_to_root(struct pci_dev *dev, u32 cap_mask)
+{
+	struct pci_bus *bus = dev->bus;
+	struct pci_dev *bridge;
+	u32 cap, ctl2;
+
+	if (!pci_is_pcie(dev))
+		return -EINVAL;
+
+	/*
+	 * Per PCIe r4.0, sec 6.15, endpoints and root ports may be
+	 * AtomicOp requesters.  For now, we only support endpoints as
+	 * requesters and root ports as completers.  No endpoints as
+	 * completers, and no peer-to-peer.
+	 */
+
+	switch (pci_pcie_type(dev)) {
+	case PCI_EXP_TYPE_ENDPOINT:
+	case PCI_EXP_TYPE_LEG_END:
+	case PCI_EXP_TYPE_RC_END:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	while (bus->parent) {
+		bridge = bus->self;
+
+		pcie_capability_read_dword(bridge, PCI_EXP_DEVCAP2, &cap);
+
+		switch (pci_pcie_type(bridge)) {
+		/* Ensure switch ports support AtomicOp routing */
+		case PCI_EXP_TYPE_UPSTREAM:
+		case PCI_EXP_TYPE_DOWNSTREAM:
+			if (!(cap & PCI_EXP_DEVCAP2_ATOMIC_ROUTE))
+				return -EINVAL;
+			break;
+
+		/* Ensure root port supports all the sizes we care about */
+		case PCI_EXP_TYPE_ROOT_PORT:
+			if ((cap & cap_mask) != cap_mask)
+				return -EINVAL;
+			break;
+		}
+
+		/* Ensure upstream ports don't block AtomicOps on egress */
+		if (!bridge->has_secondary_link) {
+			pcie_capability_read_dword(bridge, PCI_EXP_DEVCTL2,
+						   &ctl2);
+			if (ctl2 & PCI_EXP_DEVCTL2_ATOMIC_EGRESS_BLOCK)
+				return -EINVAL;
+		}
+
+		bus = bus->parent;
+	}
+
+	pcie_capability_set_word(dev, PCI_EXP_DEVCTL2,
+				 PCI_EXP_DEVCTL2_ATOMIC_REQ);
+	return 0;
+}
+EXPORT_SYMBOL(pci_enable_atomic_ops_to_root);
+
 /**
  * pci_swizzle_interrupt_pin - swizzle INTx for device behind bridge
  * @dev: the PCI device

commit 7506dc7989933235e6fc23f3d0516bdbf0f7d1a8
Author: Frederick Lawler <fred@fredlawl.com>
Date:   Thu Jan 18 12:55:24 2018 -0600

    PCI: Add wrappers for dev_printk()
    
    Add PCI-specific dev_printk() wrappers and use them to simplify the code
    slightly.  No functional change intended.
    
    Signed-off-by: Frederick Lawler <fred@fredlawl.com>
    [bhelgaas: squash into one patch]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 4a7c6864fdf4..d32dfd646ced 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -156,7 +156,7 @@ void __iomem *pci_ioremap_bar(struct pci_dev *pdev, int bar)
 	 * Make sure the BAR is actually a memory resource, not an IO resource
 	 */
 	if (res->flags & IORESOURCE_UNSET || !(res->flags & IORESOURCE_MEM)) {
-		dev_warn(&pdev->dev, "can't ioremap BAR %d: %pR\n", bar, res);
+		pci_warn(pdev, "can't ioremap BAR %d: %pR\n", bar, res);
 		return NULL;
 	}
 	return ioremap_nocache(res->start, resource_size(res));
@@ -648,7 +648,7 @@ static int pci_raw_set_power_state(struct pci_dev *dev, pci_power_t state)
 	 */
 	if (state != PCI_D0 && dev->current_state <= PCI_D3cold
 	    && dev->current_state > state) {
-		dev_err(&dev->dev, "invalid power transition (from state %d to %d)\n",
+		pci_err(dev, "invalid power transition (from state %d to %d)\n",
 			dev->current_state, state);
 		return -EINVAL;
 	}
@@ -696,7 +696,7 @@ static int pci_raw_set_power_state(struct pci_dev *dev, pci_power_t state)
 	pci_read_config_word(dev, dev->pm_cap + PCI_PM_CTRL, &pmcsr);
 	dev->current_state = (pmcsr & PCI_PM_CTRL_STATE_MASK);
 	if (dev->current_state != state && printk_ratelimit())
-		dev_info(&dev->dev, "Refused to change power state, currently in D%d\n",
+		pci_info(dev, "Refused to change power state, currently in D%d\n",
 			 dev->current_state);
 
 	/*
@@ -970,7 +970,7 @@ pci_power_t pci_choose_state(struct pci_dev *dev, pm_message_t state)
 	case PM_EVENT_HIBERNATE:
 		return PCI_D3hot;
 	default:
-		dev_info(&dev->dev, "unrecognized suspend event %d\n",
+		pci_info(dev, "unrecognized suspend event %d\n",
 			 state.event);
 		BUG();
 	}
@@ -1013,7 +1013,7 @@ static int pci_save_pcie_state(struct pci_dev *dev)
 
 	save_state = pci_find_saved_cap(dev, PCI_CAP_ID_EXP);
 	if (!save_state) {
-		dev_err(&dev->dev, "buffer not found in %s\n", __func__);
+		pci_err(dev, "buffer not found in %s\n", __func__);
 		return -ENOMEM;
 	}
 
@@ -1061,7 +1061,7 @@ static int pci_save_pcix_state(struct pci_dev *dev)
 
 	save_state = pci_find_saved_cap(dev, PCI_CAP_ID_PCIX);
 	if (!save_state) {
-		dev_err(&dev->dev, "buffer not found in %s\n", __func__);
+		pci_err(dev, "buffer not found in %s\n", __func__);
 		return -ENOMEM;
 	}
 
@@ -1121,7 +1121,7 @@ static void pci_restore_config_dword(struct pci_dev *pdev, int offset,
 		return;
 
 	for (;;) {
-		dev_dbg(&pdev->dev, "restoring config space at offset %#x (was %#x, writing %#x)\n",
+		pci_dbg(pdev, "restoring config space at offset %#x (was %#x, writing %#x)\n",
 			offset, val, saved_val);
 		pci_write_config_dword(pdev, offset, saved_val);
 		if (retry-- <= 0)
@@ -1358,7 +1358,7 @@ static void pci_enable_bridge(struct pci_dev *dev)
 
 	retval = pci_enable_device(dev);
 	if (retval)
-		dev_err(&dev->dev, "Error enabling bridge (%d), continuing\n",
+		pci_err(dev, "Error enabling bridge (%d), continuing\n",
 			retval);
 	pci_set_master(dev);
 }
@@ -1863,7 +1863,7 @@ void pci_pme_active(struct pci_dev *dev, bool enable)
 			pme_dev = kmalloc(sizeof(struct pci_pme_device),
 					  GFP_KERNEL);
 			if (!pme_dev) {
-				dev_warn(&dev->dev, "can't enable PME#\n");
+				pci_warn(dev, "can't enable PME#\n");
 				return;
 			}
 			pme_dev->dev = dev;
@@ -1887,7 +1887,7 @@ void pci_pme_active(struct pci_dev *dev, bool enable)
 		}
 	}
 
-	dev_dbg(&dev->dev, "PME# %s\n", enable ? "enabled" : "disabled");
+	pci_dbg(dev, "PME# %s\n", enable ? "enabled" : "disabled");
 }
 EXPORT_SYMBOL(pci_pme_active);
 
@@ -2424,7 +2424,7 @@ void pci_pm_init(struct pci_dev *dev)
 	pci_read_config_word(dev, pm + PCI_PM_PMC, &pmc);
 
 	if ((pmc & PCI_PM_CAP_VER_MASK) > 3) {
-		dev_err(&dev->dev, "unsupported PM cap regs version (%u)\n",
+		pci_err(dev, "unsupported PM cap regs version (%u)\n",
 			pmc & PCI_PM_CAP_VER_MASK);
 		return;
 	}
@@ -2444,15 +2444,14 @@ void pci_pm_init(struct pci_dev *dev)
 			dev->d2_support = true;
 
 		if (dev->d1_support || dev->d2_support)
-			dev_printk(KERN_DEBUG, &dev->dev, "supports%s%s\n",
+			pci_printk(KERN_DEBUG, dev, "supports%s%s\n",
 				   dev->d1_support ? " D1" : "",
 				   dev->d2_support ? " D2" : "");
 	}
 
 	pmc &= PCI_PM_CAP_PME_MASK;
 	if (pmc) {
-		dev_printk(KERN_DEBUG, &dev->dev,
-			 "PME# supported from%s%s%s%s%s\n",
+		pci_printk(KERN_DEBUG, dev, "PME# supported from%s%s%s%s%s\n",
 			 (pmc & PCI_PM_CAP_PME_D0) ? " D0" : "",
 			 (pmc & PCI_PM_CAP_PME_D1) ? " D1" : "",
 			 (pmc & PCI_PM_CAP_PME_D2) ? " D2" : "",
@@ -2544,13 +2543,13 @@ static int pci_ea_read(struct pci_dev *dev, int offset)
 
 	res = pci_ea_get_resource(dev, bei, prop);
 	if (!res) {
-		dev_err(&dev->dev, "Unsupported EA entry BEI: %u\n", bei);
+		pci_err(dev, "Unsupported EA entry BEI: %u\n", bei);
 		goto out;
 	}
 
 	flags = pci_ea_flags(dev, prop);
 	if (!flags) {
-		dev_err(&dev->dev, "Unsupported EA properties: %#x\n", prop);
+		pci_err(dev, "Unsupported EA properties: %#x\n", prop);
 		goto out;
 	}
 
@@ -2600,13 +2599,12 @@ static int pci_ea_read(struct pci_dev *dev, int offset)
 	}
 
 	if (end < start) {
-		dev_err(&dev->dev, "EA Entry crosses address boundary\n");
+		pci_err(dev, "EA Entry crosses address boundary\n");
 		goto out;
 	}
 
 	if (ent_size != ent_offset - offset) {
-		dev_err(&dev->dev,
-			"EA Entry Size (%d) does not match length read (%d)\n",
+		pci_err(dev, "EA Entry Size (%d) does not match length read (%d)\n",
 			ent_size, ent_offset - offset);
 		goto out;
 	}
@@ -2617,16 +2615,16 @@ static int pci_ea_read(struct pci_dev *dev, int offset)
 	res->flags = flags;
 
 	if (bei <= PCI_EA_BEI_BAR5)
-		dev_printk(KERN_DEBUG, &dev->dev, "BAR %d: %pR (from Enhanced Allocation, properties %#02x)\n",
+		pci_printk(KERN_DEBUG, dev, "BAR %d: %pR (from Enhanced Allocation, properties %#02x)\n",
 			   bei, res, prop);
 	else if (bei == PCI_EA_BEI_ROM)
-		dev_printk(KERN_DEBUG, &dev->dev, "ROM: %pR (from Enhanced Allocation, properties %#02x)\n",
+		pci_printk(KERN_DEBUG, dev, "ROM: %pR (from Enhanced Allocation, properties %#02x)\n",
 			   res, prop);
 	else if (bei >= PCI_EA_BEI_VF_BAR0 && bei <= PCI_EA_BEI_VF_BAR5)
-		dev_printk(KERN_DEBUG, &dev->dev, "VF BAR %d: %pR (from Enhanced Allocation, properties %#02x)\n",
+		pci_printk(KERN_DEBUG, dev, "VF BAR %d: %pR (from Enhanced Allocation, properties %#02x)\n",
 			   bei - PCI_EA_BEI_VF_BAR0, res, prop);
 	else
-		dev_printk(KERN_DEBUG, &dev->dev, "BEI %d res: %pR (from Enhanced Allocation, properties %#02x)\n",
+		pci_printk(KERN_DEBUG, dev, "BEI %d res: %pR (from Enhanced Allocation, properties %#02x)\n",
 			   bei, res, prop);
 
 out:
@@ -2723,13 +2721,11 @@ void pci_allocate_cap_save_buffers(struct pci_dev *dev)
 	error = pci_add_cap_save_buffer(dev, PCI_CAP_ID_EXP,
 					PCI_EXP_SAVE_REGS * sizeof(u16));
 	if (error)
-		dev_err(&dev->dev,
-			"unable to preallocate PCI Express save buffer\n");
+		pci_err(dev, "unable to preallocate PCI Express save buffer\n");
 
 	error = pci_add_cap_save_buffer(dev, PCI_CAP_ID_PCIX, sizeof(u16));
 	if (error)
-		dev_err(&dev->dev,
-			"unable to preallocate PCI-X save buffer\n");
+		pci_err(dev, "unable to preallocate PCI-X save buffer\n");
 
 	pci_allocate_vc_save_buffers(dev);
 }
@@ -3198,7 +3194,7 @@ static int __pci_request_region(struct pci_dev *pdev, int bar,
 	return 0;
 
 err_out:
-	dev_warn(&pdev->dev, "BAR %d: can't reserve %pR\n", bar,
+	pci_warn(pdev, "BAR %d: can't reserve %pR\n", bar,
 		 &pdev->resource[bar]);
 	return -EBUSY;
 }
@@ -3621,7 +3617,7 @@ static void __pci_set_master(struct pci_dev *dev, bool enable)
 	else
 		cmd = old_cmd & ~PCI_COMMAND_MASTER;
 	if (cmd != old_cmd) {
-		dev_dbg(&dev->dev, "%s bus mastering\n",
+		pci_dbg(dev, "%s bus mastering\n",
 			enable ? "enabling" : "disabling");
 		pci_write_config_word(dev, PCI_COMMAND, cmd);
 	}
@@ -3722,7 +3718,7 @@ int pci_set_cacheline_size(struct pci_dev *dev)
 	if (cacheline_size == pci_cache_line_size)
 		return 0;
 
-	dev_printk(KERN_DEBUG, &dev->dev, "cache line size of %d is not supported\n",
+	pci_printk(KERN_DEBUG, dev, "cache line size of %d is not supported\n",
 		   pci_cache_line_size << 2);
 
 	return -EINVAL;
@@ -3751,7 +3747,7 @@ int pci_set_mwi(struct pci_dev *dev)
 
 	pci_read_config_word(dev, PCI_COMMAND, &cmd);
 	if (!(cmd & PCI_COMMAND_INVALIDATE)) {
-		dev_dbg(&dev->dev, "enabling Mem-Wr-Inval\n");
+		pci_dbg(dev, "enabling Mem-Wr-Inval\n");
 		cmd |= PCI_COMMAND_INVALIDATE;
 		pci_write_config_word(dev, PCI_COMMAND, cmd);
 	}
@@ -3947,13 +3943,13 @@ static void pci_flr_wait(struct pci_dev *dev)
 	pci_read_config_dword(dev, PCI_COMMAND, &id);
 	while (id == ~0) {
 		if (delay > timeout) {
-			dev_warn(&dev->dev, "not ready %dms after FLR; giving up\n",
+			pci_warn(dev, "not ready %dms after FLR; giving up\n",
 				 100 + delay - 1);
 			return;
 		}
 
 		if (delay > 1000)
-			dev_info(&dev->dev, "not ready %dms after FLR; waiting\n",
+			pci_info(dev, "not ready %dms after FLR; waiting\n",
 				 100 + delay - 1);
 
 		msleep(delay);
@@ -3962,7 +3958,7 @@ static void pci_flr_wait(struct pci_dev *dev)
 	}
 
 	if (delay > 1000)
-		dev_info(&dev->dev, "ready %dms after FLR\n", 100 + delay - 1);
+		pci_info(dev, "ready %dms after FLR\n", 100 + delay - 1);
 }
 
 /**
@@ -3994,7 +3990,7 @@ static bool pcie_has_flr(struct pci_dev *dev)
 void pcie_flr(struct pci_dev *dev)
 {
 	if (!pci_wait_for_pending_transaction(dev))
-		dev_err(&dev->dev, "timed out waiting for pending transaction; performing function level reset anyway\n");
+		pci_err(dev, "timed out waiting for pending transaction; performing function level reset anyway\n");
 
 	pcie_capability_set_word(dev, PCI_EXP_DEVCTL, PCI_EXP_DEVCTL_BCR_FLR);
 	pci_flr_wait(dev);
@@ -4027,7 +4023,7 @@ static int pci_af_flr(struct pci_dev *dev, int probe)
 	 */
 	if (!pci_wait_for_pending(dev, pos + PCI_AF_CTRL,
 				 PCI_AF_STATUS_TP << 8))
-		dev_err(&dev->dev, "timed out waiting for pending transaction; performing AF function level reset anyway\n");
+		pci_err(dev, "timed out waiting for pending transaction; performing AF function level reset anyway\n");
 
 	pci_write_config_byte(dev, pos + PCI_AF_CTRL, PCI_AF_CTRL_FLR);
 	pci_flr_wait(dev);
@@ -5150,12 +5146,12 @@ void pci_add_dma_alias(struct pci_dev *dev, u8 devfn)
 		dev->dma_alias_mask = kcalloc(BITS_TO_LONGS(U8_MAX),
 					      sizeof(long), GFP_KERNEL);
 	if (!dev->dma_alias_mask) {
-		dev_warn(&dev->dev, "Unable to allocate DMA alias mask\n");
+		pci_warn(dev, "Unable to allocate DMA alias mask\n");
 		return;
 	}
 
 	set_bit(devfn, dev->dma_alias_mask);
-	dev_info(&dev->dev, "Enabling fixed DMA alias to %02x.%d\n",
+	pci_info(dev, "Enabling fixed DMA alias to %02x.%d\n",
 		 PCI_SLOT(devfn), PCI_FUNC(devfn));
 }
 
@@ -5304,7 +5300,7 @@ static void pci_request_resource_alignment(struct pci_dev *dev, int bar,
 		return;
 
 	if (r->flags & IORESOURCE_PCI_FIXED) {
-		dev_info(&dev->dev, "BAR%d %pR: ignoring requested alignment %#llx\n",
+		pci_info(dev, "BAR%d %pR: ignoring requested alignment %#llx\n",
 			 bar, r, (unsigned long long)align);
 		return;
 	}
@@ -5341,7 +5337,7 @@ static void pci_request_resource_alignment(struct pci_dev *dev, int bar,
 	 * devices and we use the second.
 	 */
 
-	dev_info(&dev->dev, "BAR%d %pR: requesting alignment to %#llx\n",
+	pci_info(dev, "BAR%d %pR: requesting alignment to %#llx\n",
 		 bar, r, (unsigned long long)align);
 
 	if (resize) {
@@ -5387,13 +5383,11 @@ void pci_reassigndev_resource_alignment(struct pci_dev *dev)
 
 	if (dev->hdr_type == PCI_HEADER_TYPE_NORMAL &&
 	    (dev->class >> 8) == PCI_CLASS_BRIDGE_HOST) {
-		dev_warn(&dev->dev,
-			"Can't reassign resources to host bridge.\n");
+		pci_warn(dev, "Can't reassign resources to host bridge\n");
 		return;
 	}
 
-	dev_info(&dev->dev,
-		"Disabling memory decoding and releasing memory resources.\n");
+	pci_info(dev, "Disabling memory decoding and releasing memory resources\n");
 	pci_read_config_word(dev, PCI_COMMAND, &command);
 	command &= ~PCI_COMMAND_MEMORY;
 	pci_write_config_word(dev, PCI_COMMAND, command);

commit fc0f9f4d2f26b12fd2eda239bb8f18ceaf192c91
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Tue Dec 12 07:40:56 2017 +0100

    PCI: Add pcim_set_mwi(), a device-managed pci_set_mwi()
    
    Add pcim_set_mwi(), a device-managed version of pci_set_mwi().
    First user is the Realtek r8169 driver.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 4a7c6864fdf4..764ca7b8840d 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1458,6 +1458,7 @@ struct pci_devres {
 	unsigned int pinned:1;
 	unsigned int orig_intx:1;
 	unsigned int restore_intx:1;
+	unsigned int mwi:1;
 	u32 region_mask;
 };
 
@@ -1476,6 +1477,9 @@ static void pcim_release(struct device *gendev, void *res)
 		if (this->region_mask & (1 << i))
 			pci_release_region(dev, i);
 
+	if (this->mwi)
+		pci_clear_mwi(dev);
+
 	if (this->restore_intx)
 		pci_intx(dev, this->orig_intx);
 
@@ -3760,6 +3764,27 @@ int pci_set_mwi(struct pci_dev *dev)
 }
 EXPORT_SYMBOL(pci_set_mwi);
 
+/**
+ * pcim_set_mwi - a device-managed pci_set_mwi()
+ * @dev: the PCI device for which MWI is enabled
+ *
+ * Managed pci_set_mwi().
+ *
+ * RETURNS: An appropriate -ERRNO error value on error, or zero for success.
+ */
+int pcim_set_mwi(struct pci_dev *dev)
+{
+	struct pci_devres *dr;
+
+	dr = find_pci_dr(dev);
+	if (!dr)
+		return -ENOMEM;
+
+	dr->mwi = 1;
+	return pci_set_mwi(dev);
+}
+EXPORT_SYMBOL(pcim_set_mwi);
+
 /**
  * pci_try_set_mwi - enables memory-write-invalidate PCI transaction
  * @dev: the PCI device for which MWI is enabled

commit 1b6115fbe3b3db746d7baa11399dd617fc75e1c4
Merge: ad0835a93008 91f3140fdef6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Nov 15 15:01:28 2017 -0800

    Merge tag 'pci-v4.15-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI updates from Bjorn Helgaas:
    
      - detach driver before tearing down procfs/sysfs (Alex Williamson)
    
      - disable PCIe services during shutdown (Sinan Kaya)
    
      - fix ASPM oops on systems with no Root Ports (Ard Biesheuvel)
    
      - fix ASPM LTR_L1.2_THRESHOLD programming (Bjorn Helgaas)
    
      - fix ASPM Common_Mode_Restore_Time computation (Bjorn Helgaas)
    
      - fix portdrv MSI/MSI-X vector allocation (Dongdong Liu, Bjorn
        Helgaas)
    
      - report non-fatal AER errors only to the affected endpoint (Gabriele
        Paoloni)
    
      - distribute bus numbers, MMIO, and I/O space among hotplug bridges to
        allow more devices to be hot-added (Mika Westerberg)
    
      - fix pciehp races during initialization and surprise link down (Mika
        Westerberg)
    
      - handle surprise-removed devices in PME handling (Qiang)
    
      - support resizable BARs for large graphics devices (Christian König)
    
      - expose SR-IOV offset, stride, and VF device ID via sysfs (Filippo
        Sironi)
    
      - create SR-IOV virtfn/physfn sysfs links before attaching driver
        (Stuart Hayes)
    
      - fix SR-IOV "ARI Capable Hierarchy" restore issue (Tony Nguyen)
    
      - enforce Kconfig IOV/REALLOC dependency (Sascha El-Sharkawy)
    
      - avoid slot reset if bridge itself is broken (Jan Glauber)
    
      - clean up pci_reset_function() path (Jan H. Schönherr)
    
      - make pci_map_rom() fail if the option ROM is invalid (Changbin Du)
    
      - convert timers to timer_setup() (Kees Cook)
    
      - move PCI_QUIRKS to PCI bus Kconfig menu (Randy Dunlap)
    
      - constify pci_dev_type and intel_mid_pci_ops (Bhumika Goyal)
    
      - remove unnecessary pci_dev, pci_bus, resource, pcibios_set_master()
        declarations (Bjorn Helgaas)
    
      - fix endpoint framework overflows and BUG()s (Dan Carpenter)
    
      - fix endpoint framework issues (Kishon Vijay Abraham I)
    
      - avoid broken Cavium CN8xxx bus reset behavior (David Daney)
    
      - extend Cavium ACS capability quirks (Vadim Lomovtsev)
    
      - support Synopsys DesignWare RC in ECAM mode (Ard Biesheuvel)
    
      - turn off dra7xx clocks cleanly on shutdown (Keerthy)
    
      - fix Faraday probe error path (Wei Yongjun)
    
      - support HiSilicon STB SoC PCIe host controller (Jianguo Sun)
    
      - fix Hyper-V interrupt affinity issue (Dexuan Cui)
    
      - remove useless ACPI warning for Hyper-V pass-through devices (Vitaly
        Kuznetsov)
    
      - support multiple MSI on iProc (Sandor Bodo-Merle)
    
      - support Layerscape LS1012a and LS1046a PCIe host controllers (Hou
        Zhiqiang)
    
      - fix Layerscape default error response (Minghuan Lian)
    
      - support MSI on Tango host controller (Marc Gonzalez)
    
      - support Tegra186 PCIe host controller (Manikanta Maddireddy)
    
      - use generic accessors on Tegra when possible (Thierry Reding)
    
      - support V3 Semiconductor PCI host controller (Linus Walleij)
    
    * tag 'pci-v4.15-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (85 commits)
      PCI/ASPM: Add L1 Substates definitions
      PCI/ASPM: Reformat ASPM register definitions
      PCI/ASPM: Use correct capability pointer to program LTR_L1.2_THRESHOLD
      PCI/ASPM: Account for downstream device's Port Common_Mode_Restore_Time
      PCI: xgene: Rename xgene_pcie_probe_bridge() to xgene_pcie_probe()
      PCI: xilinx: Rename xilinx_pcie_link_is_up() to xilinx_pcie_link_up()
      PCI: altera: Rename altera_pcie_link_is_up() to altera_pcie_link_up()
      PCI: Fix kernel-doc build warning
      PCI: Fail pci_map_rom() if the option ROM is invalid
      PCI: Move pci_map_rom() error path
      PCI: Move PCI_QUIRKS to the PCI bus menu
      alpha/PCI: Make pdev_save_srm_config() static
      PCI: Remove unused declarations
      PCI: Remove redundant pci_dev, pci_bus, resource declarations
      PCI: Remove redundant pcibios_set_master() declarations
      PCI/PME: Handle invalid data when reading Root Status
      PCI: hv: Use effective affinity mask
      PCI: pciehp: Do not clear Presence Detect Changed during initialization
      PCI: pciehp: Fix race condition handling surprise link down
      PCI: Distribute available resources to hotplug-capable bridges
      ...

commit 29d0d4411fafa1a934ff6ff00840df4f880add41
Merge: d238be6957b2 33ba90aa4d44
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Nov 14 12:11:36 2017 -0600

    Merge branch 'pci/host-thunder' into next
    
    * pci/host-thunder:
      PCI: Avoid slot reset if bridge itself is broken
      PCI: Avoid bus reset if bridge itself is broken
      PCI: Mark Cavium CN8xxx to avoid bus reset

commit 9ceb09cce1a30bdbcff861d1bbbbe0dbb7de05de
Merge: 9af21ac53f97 832c418a1530
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Nov 14 12:11:26 2017 -0600

    Merge branch 'pci/virtualization' into next
    
    * pci/virtualization:
      PCI: Document reset method return values
      PCI: Detach driver before procfs & sysfs teardown on device remove
      PCI: Apply Cavium ThunderX ACS quirk to more Root Ports
      PCI: Set Cavium ACS capability quirk flags to assert RR/CR/SV/UF
      PCI: Restore ARI Capable Hierarchy before setting numVFs
      PCI: Create SR-IOV virtfn/physfn links before attaching driver
      PCI: Expose SR-IOV offset, stride, and VF device ID via sysfs
      PCI: Cache the VF device ID in the SR-IOV structure
      PCI: Add Kconfig PCI_IOV dependency for PCI_REALLOC_ENABLE_AUTO
      PCI: Remove unused function __pci_reset_function()
      PCI: Remove reset argument from pci_iov_{add,remove}_virtfn()

commit 104d1e40cfcd69934f3f57c6abf13980eb703feb
Merge: 8dceeaf8fff3 a405f191f42e
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Nov 14 12:11:25 2017 -0600

    Merge branch 'pci/resource' into next
    
    * pci/resource:
      PCI: Fail pci_map_rom() if the option ROM is invalid
      PCI: Move pci_map_rom() error path
      x86/PCI: Enable a 64bit BAR on AMD Family 15h (Models 00-1f, 30-3f, 60-7f)
      PCI: Add pci_resize_resource() for resizing BARs
      PCI: Add resizable BAR infrastructure
      PCI: Add PCI resource type mask #define

commit 505fb74664d534618258f4120d7e110a8b885c87
Author: Randy Dunlap <rdunlap@infradead.org>
Date:   Sun Oct 29 17:07:11 2017 -0700

    PCI: Fix kernel-doc build warning
    
    Fix build error in kernel-doc notation:
    
      ../drivers/pci/pci.c:3479: ERROR: Unexpected indentation.
    
    "::" tells the kernel-doc "reStructuredText" processor that the following
    block is a literal block of some blob that should be kept as is.
    
    Signed-off-by: Randy Dunlap <rdunlap@infradead.org>
    [bhelgaas: add hint about "::" meaning]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 6078dfc11b11..d50c58d6acd3 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -3471,7 +3471,7 @@ EXPORT_SYMBOL(devm_pci_remap_cfgspace);
  * All operations are managed and will be undone on driver detach.
  *
  * Returns a pointer to the remapped memory or an ERR_PTR() encoded error code
- * on failure. Usage example:
+ * on failure. Usage example::
  *
  *	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
  *	base = devm_pci_remap_cfg_resource(&pdev->dev, res);

commit c2eac4d3a115e2f511844e7bcf73f4e877fbf5da
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Oct 25 14:16:46 2017 +0200

    PCI / PM: Use the NEVER_SKIP driver flag
    
    Replace the PCI-specific flag PCI_DEV_FLAGS_NEEDS_RESUME with the
    PM core's DPM_FLAG_NEVER_SKIP one everywhere and drop it.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 6078dfc11b11..374f5686e2bc 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2166,8 +2166,7 @@ bool pci_dev_keep_suspended(struct pci_dev *pci_dev)
 
 	if (!pm_runtime_suspended(dev)
 	    || pci_target_state(pci_dev, wakeup) != pci_dev->current_state
-	    || platform_pci_need_resume(pci_dev)
-	    || (pci_dev->dev_flags & PCI_DEV_FLAGS_NEEDS_RESUME))
+	    || platform_pci_need_resume(pci_dev))
 		return false;
 
 	/*

commit 832c418a1530afba54fd96a2cca0912ec9036080
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Oct 25 17:09:24 2017 -0500

    PCI: Document reset method return values
    
    The pci_reset_function() path may try several different reset methods:
    device-specific resets, PCIe Function Level Resets, PCI Advanced Features
    Function Level Reset, etc.
    
    Add a comment about what the return values from these methods mean.  If one
    of the methods fails, in some cases we want to continue and try the next
    one in the list, but sometimes we want to stop trying.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index f0d68066c726..3ff0c3c18276 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -4170,6 +4170,14 @@ int __pci_reset_function_locked(struct pci_dev *dev)
 
 	might_sleep();
 
+	/*
+	 * A reset method returns -ENOTTY if it doesn't support this device
+	 * and we should try the next method.
+	 *
+	 * If it returns 0 (success), we're finished.  If it returns any
+	 * other error, we're also finished: this indicates that further
+	 * reset mechanisms might be broken on the device.
+	 */
 	rc = pci_dev_specific_reset(dev, 0);
 	if (rc != -ENOTTY)
 		return rc;

commit 276b738deb5bf856b9f6049fcd92a967f52643d7
Author: Christian König <christian.koenig@amd.com>
Date:   Tue Oct 24 14:40:20 2017 -0500

    PCI: Add resizable BAR infrastructure
    
    Add resizable BAR infrastructure, including defines and helper functions to
    read the possible sizes of a BAR and update its size.  See PCIe r3.1, sec
    7.22.
    
    Link: https://pcisig.com/sites/default/files/specification_documents/ECN_Resizable-BAR_24Apr2008.pdf
    Signed-off-by: Christian König <christian.koenig@amd.com>
    [bhelgaas: rename to functions with "rebar" (to match #defines), drop shift
    #defines, drop "_MASK" suffixes, fix typos, fix kerneldoc]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 6078dfc11b11..832b96756e83 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2965,6 +2965,107 @@ bool pci_acs_path_enabled(struct pci_dev *start,
 	return true;
 }
 
+/**
+ * pci_rebar_find_pos - find position of resize ctrl reg for BAR
+ * @pdev: PCI device
+ * @bar: BAR to find
+ *
+ * Helper to find the position of the ctrl register for a BAR.
+ * Returns -ENOTSUPP if resizable BARs are not supported at all.
+ * Returns -ENOENT if no ctrl register for the BAR could be found.
+ */
+static int pci_rebar_find_pos(struct pci_dev *pdev, int bar)
+{
+	unsigned int pos, nbars, i;
+	u32 ctrl;
+
+	pos = pci_find_ext_capability(pdev, PCI_EXT_CAP_ID_REBAR);
+	if (!pos)
+		return -ENOTSUPP;
+
+	pci_read_config_dword(pdev, pos + PCI_REBAR_CTRL, &ctrl);
+	nbars = (ctrl & PCI_REBAR_CTRL_NBAR_MASK) >>
+		    PCI_REBAR_CTRL_NBAR_SHIFT;
+
+	for (i = 0; i < nbars; i++, pos += 8) {
+		int bar_idx;
+
+		pci_read_config_dword(pdev, pos + PCI_REBAR_CTRL, &ctrl);
+		bar_idx = ctrl & PCI_REBAR_CTRL_BAR_IDX;
+		if (bar_idx == bar)
+			return pos;
+	}
+
+	return -ENOENT;
+}
+
+/**
+ * pci_rebar_get_possible_sizes - get possible sizes for BAR
+ * @pdev: PCI device
+ * @bar: BAR to query
+ *
+ * Get the possible sizes of a resizable BAR as bitmask defined in the spec
+ * (bit 0=1MB, bit 19=512GB). Returns 0 if BAR isn't resizable.
+ */
+u32 pci_rebar_get_possible_sizes(struct pci_dev *pdev, int bar)
+{
+	int pos;
+	u32 cap;
+
+	pos = pci_rebar_find_pos(pdev, bar);
+	if (pos < 0)
+		return 0;
+
+	pci_read_config_dword(pdev, pos + PCI_REBAR_CAP, &cap);
+	return (cap & PCI_REBAR_CAP_SIZES) >> 4;
+}
+
+/**
+ * pci_rebar_get_current_size - get the current size of a BAR
+ * @pdev: PCI device
+ * @bar: BAR to set size to
+ *
+ * Read the size of a BAR from the resizable BAR config.
+ * Returns size if found or negative error code.
+ */
+int pci_rebar_get_current_size(struct pci_dev *pdev, int bar)
+{
+	int pos;
+	u32 ctrl;
+
+	pos = pci_rebar_find_pos(pdev, bar);
+	if (pos < 0)
+		return pos;
+
+	pci_read_config_dword(pdev, pos + PCI_REBAR_CTRL, &ctrl);
+	return (ctrl & PCI_REBAR_CTRL_BAR_SIZE) >> 8;
+}
+
+/**
+ * pci_rebar_set_size - set a new size for a BAR
+ * @pdev: PCI device
+ * @bar: BAR to set size to
+ * @size: new size as defined in the spec (0=1MB, 19=512GB)
+ *
+ * Set the new size of a BAR as defined in the spec.
+ * Returns zero if resizing was successful, error code otherwise.
+ */
+int pci_rebar_set_size(struct pci_dev *pdev, int bar, int size)
+{
+	int pos;
+	u32 ctrl;
+
+	pos = pci_rebar_find_pos(pdev, bar);
+	if (pos < 0)
+		return pos;
+
+	pci_read_config_dword(pdev, pos + PCI_REBAR_CTRL, &ctrl);
+	ctrl &= ~PCI_REBAR_CTRL_BAR_SIZE;
+	ctrl |= size << 8;
+	pci_write_config_dword(pdev, pos + PCI_REBAR_CTRL, ctrl);
+	return 0;
+}
+
 /**
  * pci_swizzle_interrupt_pin - swizzle INTx for device behind bridge
  * @dev: the PCI device

commit 33ba90aa4d4432b884fc0ed57ba9dc12eb8fa288
Author: Jan Glauber <jglauber@cavium.com>
Date:   Fri Sep 8 10:10:33 2017 +0200

    PCI: Avoid slot reset if bridge itself is broken
    
    When checking to see if a PCI slot can safely be reset, we previously
    checked to see if any of the children had their PCI_DEV_FLAGS_NO_BUS_RESET
    flag set.
    
    Some PCIe root port bridges do not behave well after a slot reset, and may
    cause the device in the slot to become unusable.
    
    Add a check for PCI_DEV_FLAGS_NO_BUS_RESET being set in the bridge device
    to prevent the slot from being reset.
    
    Signed-off-by: Jan Glauber <jglauber@cavium.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Alex Williamson <alex.williamson@redhat.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 74f1c57ab93b..3e0557bb02c8 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -4424,6 +4424,10 @@ static bool pci_slot_resetable(struct pci_slot *slot)
 {
 	struct pci_dev *dev;
 
+	if (slot->bus->self &&
+	    (slot->bus->self->dev_flags & PCI_DEV_FLAGS_NO_BUS_RESET))
+		return false;
+
 	list_for_each_entry(dev, &slot->bus->devices, bus_list) {
 		if (!dev->slot || dev->slot != slot)
 			continue;

commit 357027786f3523d26f42391aa4c075b8495e5d28
Author: David Daney <david.daney@cavium.com>
Date:   Fri Sep 8 10:10:31 2017 +0200

    PCI: Avoid bus reset if bridge itself is broken
    
    When checking to see if a PCI bus can safely be reset, we previously
    checked to see if any of the children had their PCI_DEV_FLAGS_NO_BUS_RESET
    flag set.  Children marked with that flag are known not to behave well
    after a bus reset.
    
    Some PCIe root port bridges also do not behave well after a bus reset,
    sometimes causing the devices behind the bridge to become unusable.
    
    Add a check for PCI_DEV_FLAGS_NO_BUS_RESET being set in the bridge device
    to allow these bridges to be flagged, and prevent their secondary buses
    from being reset.
    
    Signed-off-by: David Daney <david.daney@cavium.com>
    [jglauber@cavium.com: fixed typo]
    Signed-off-by: Jan Glauber <jglauber@cavium.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Alex Williamson <alex.williamson@redhat.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 6078dfc11b11..74f1c57ab93b 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -4356,6 +4356,10 @@ static bool pci_bus_resetable(struct pci_bus *bus)
 {
 	struct pci_dev *dev;
 
+
+	if (bus->self && (bus->self->dev_flags & PCI_DEV_FLAGS_NO_BUS_RESET))
+		return false;
+
 	list_for_each_entry(dev, &bus->devices, bus_list) {
 		if (dev->dev_flags & PCI_DEV_FLAGS_NO_BUS_RESET ||
 		    (dev->subordinate && !pci_bus_resetable(dev->subordinate)))

commit 79e699b648b93f76d0f6e692499d5c6a2295ef05
Author: Jan H. Schönherr <jschoenh@amazon.de>
Date:   Wed Sep 6 01:21:23 2017 +0200

    PCI: Remove unused function __pci_reset_function()
    
    The last caller of __pci_reset_function() has been removed. Remove the
    function as well.
    
    Signed-off-by: Jan H. Schönherr <jschoenh@amazon.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 6078dfc11b11..f0d68066c726 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -4145,35 +4145,6 @@ static void pci_dev_restore(struct pci_dev *dev)
 		err_handler->reset_done(dev);
 }
 
-/**
- * __pci_reset_function - reset a PCI device function
- * @dev: PCI device to reset
- *
- * Some devices allow an individual function to be reset without affecting
- * other functions in the same device.  The PCI device must be responsive
- * to PCI config space in order to use this function.
- *
- * The device function is presumed to be unused when this function is called.
- * Resetting the device will make the contents of PCI configuration space
- * random, so any caller of this must be prepared to reinitialise the
- * device including MSI, bus mastering, BARs, decoding IO and memory spaces,
- * etc.
- *
- * Returns 0 if the device function was successfully reset or negative if the
- * device doesn't support resetting a single function.
- */
-int __pci_reset_function(struct pci_dev *dev)
-{
-	int ret;
-
-	pci_dev_lock(dev);
-	ret = __pci_reset_function_locked(dev);
-	pci_dev_unlock(dev);
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(__pci_reset_function);
-
 /**
  * __pci_reset_function_locked - reset a PCI device function while holding
  * the @dev mutex lock.
@@ -4264,8 +4235,8 @@ int pci_probe_reset_function(struct pci_dev *dev)
  *
  * This function does not just reset the PCI portion of a device, but
  * clears all the state associated with the device.  This function differs
- * from __pci_reset_function in that it saves and restores device state
- * over the reset.
+ * from __pci_reset_function_locked() in that it saves and restores device state
+ * over the reset and takes the PCI device lock.
  *
  * Returns 0 if the device function was successfully reset or negative if the
  * device doesn't support resetting a single function.
@@ -4300,7 +4271,7 @@ EXPORT_SYMBOL_GPL(pci_reset_function);
  *
  * This function does not just reset the PCI portion of a device, but
  * clears all the state associated with the device.  This function differs
- * from __pci_reset_function() in that it saves and restores device state
+ * from __pci_reset_function_locked() in that it saves and restores device state
  * over the reset.  It also differs from pci_reset_function() in that it
  * requires the PCI device lock to be held.
  *

commit 0f50a49e3008597abed0fff052d487f77db89093
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Sep 15 01:33:51 2017 -0500

    Revert "PCI: Avoid race while enabling upstream bridges"
    
    This reverts commit 40f11adc7cd9281227f0a6a627d966dd0a5f0cd9.
    
    Jens found that iwlwifi firmware loading failed on a Lenovo X1 Carbon,
    gen4:
    
      iwlwifi 0000:04:00.0: Direct firmware load for iwlwifi-8000C-34.ucode failed with error -2
      iwlwifi 0000:04:00.0: Direct firmware load for iwlwifi-8000C-33.ucode failed with error -2
      iwlwifi 0000:04:00.0: Direct firmware load for iwlwifi-8000C-32.ucode failed with error -2
      iwlwifi 0000:04:00.0: loaded firmware version 31.532993.0 op_mode iwlmvm
      iwlwifi 0000:04:00.0: Detected Intel(R) Dual Band Wireless AC 8260, REV=0x208
      ...
      iwlwifi 0000:04:00.0: Failed to load firmware chunk!
      iwlwifi 0000:04:00.0: Could not load the [0] uCode section
      iwlwifi 0000:04:00.0: Failed to start INIT ucode: -110
      iwlwifi 0000:04:00.0: Failed to run INIT ucode: -110
    
    He bisected it to 40f11adc7cd9 ("PCI: Avoid race while enabling upstream
    bridges").  Revert that commit to fix the regression.
    
    Link: http://lkml.kernel.org/r/4bcbcbc1-7c79-09f0-5071-bc2f53bf6574@kernel.dk
    Fixes: 40f11adc7cd9 ("PCI: Avoid race while enabling upstream bridges")
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    CC: Srinath Mannam <srinath.mannam@broadcom.com>
    CC: Jens Axboe <axboe@kernel.dk>
    CC: Luca Coelho <luca@coelho.fi>
    CC: Johannes Berg <johannes@sipsolutions.net>
    CC: Emmanuel Grumbach <emmanuel.grumbach@intel.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index b0002daa50f3..6078dfc11b11 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -52,7 +52,6 @@ static void pci_pme_list_scan(struct work_struct *work);
 static LIST_HEAD(pci_pme_list);
 static DEFINE_MUTEX(pci_pme_list_mutex);
 static DECLARE_DELAYED_WORK(pci_pme_work, pci_pme_list_scan);
-static DEFINE_MUTEX(pci_bridge_mutex);
 
 struct pci_pme_device {
 	struct list_head list;
@@ -1351,16 +1350,10 @@ static void pci_enable_bridge(struct pci_dev *dev)
 	if (bridge)
 		pci_enable_bridge(bridge);
 
-	/*
-	 * Hold pci_bridge_mutex to prevent a race when enabling two
-	 * devices below the bridge simultaneously.  The race may cause a
-	 * PCI_COMMAND_MEMORY update to be lost (see changelog).
-	 */
-	mutex_lock(&pci_bridge_mutex);
 	if (pci_is_enabled(dev)) {
 		if (!dev->is_busmaster)
 			pci_set_master(dev);
-		goto end;
+		return;
 	}
 
 	retval = pci_enable_device(dev);
@@ -1368,8 +1361,6 @@ static void pci_enable_bridge(struct pci_dev *dev)
 		dev_err(&dev->dev, "Error enabling bridge (%d), continuing\n",
 			retval);
 	pci_set_master(dev);
-end:
-	mutex_unlock(&pci_bridge_mutex);
 }
 
 static int pci_enable_device_flags(struct pci_dev *dev, unsigned long flags)
@@ -1394,7 +1385,7 @@ static int pci_enable_device_flags(struct pci_dev *dev, unsigned long flags)
 		return 0;		/* already enabled */
 
 	bridge = pci_upstream_bridge(dev);
-	if (bridge && !pci_is_enabled(bridge))
+	if (bridge)
 		pci_enable_bridge(bridge);
 
 	/* only skip sriov related */

commit 0d519f2d1ed1f11e49abc88cfcf6cf13b83ba14c
Merge: 0756b7fbb696 cf2d804110d3
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Sep 8 15:47:43 2017 -0700

    Merge tag 'pci-v4.14-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI updates from Bjorn Helgaas:
    
     - add enhanced Downstream Port Containment support, which prints more
       details about Root Port Programmed I/O errors (Dongdong Liu)
    
     - add Layerscape ls1088a and ls2088a support (Hou Zhiqiang)
    
     - add MediaTek MT2712 and MT7622 support (Ryder Lee)
    
     - add MediaTek MT2712 and MT7622 MSI support (Honghui Zhang)
    
     - add Qualcom IPQ8074 support (Varadarajan Narayanan)
    
     - add R-Car r8a7743/5 device tree support (Biju Das)
    
     - add Rockchip per-lane PHY support for better power management (Shawn
       Lin)
    
     - fix IRQ mapping for hot-added devices by replacing the
       pci_fixup_irqs() boot-time design with a host bridge hook called at
       probe-time (Lorenzo Pieralisi, Matthew Minter)
    
     - fix race when enabling two devices that results in upstream bridge
       not being enabled correctly (Srinath Mannam)
    
     - fix pciehp power fault infinite loop (Keith Busch)
    
     - fix SHPC bridge MSI hotplug events by enabling bus mastering
       (Aleksandr Bezzubikov)
    
     - fix a VFIO issue by correcting PCIe capability sizes (Alex
       Williamson)
    
     - fix an INTD issue on Xilinx and possibly other drivers by unifying
       INTx IRQ domain support (Paul Burton)
    
     - avoid IOMMU stalls by marking AMD Stoney GPU ATS as broken (Joerg
       Roedel)
    
     - allow APM X-Gene device assignment to guests by adding an ACS quirk
       (Feng Kan)
    
     - fix driver crashes by disabling Extended Tags on Broadcom HT2100
       (Extended Tags support is required for PCIe Receivers but not
       Requesters, and we now enable them by default when Requesters support
       them) (Sinan Kaya)
    
     - fix MSIs for devices that use phantom RIDs for DMA by assuming MSIs
       use the real Requester ID (not a phantom RID) (Robin Murphy)
    
     - prevent assignment of Intel VMD children to guests (which may be
       supported eventually, but isn't yet) by not associating an IOMMU with
       them (Jon Derrick)
    
     - fix Intel VMD suspend/resume by releasing IRQs on suspend (Scott
       Bauer)
    
     - fix a Function-Level Reset issue with Intel 750 NVMe by waiting
       longer (up to 60sec instead of 1sec) for device to become ready
       (Sinan Kaya)
    
     - fix a Function-Level Reset issue on iProc Stingray by working around
       hardware defects in the CRS implementation (Oza Pawandeep)
    
     - fix an issue with Intel NVMe P3700 after an iProc reset by adding a
       delay during shutdown (Oza Pawandeep)
    
     - fix a Microsoft Hyper-V lockdep issue by polling instead of blocking
       in compose_msi_msg() (Stephen Hemminger)
    
     - fix a wireless LAN driver timeout by clearing DesignWare MSI
       interrupt status after it is handled, not before (Faiz Abbas)
    
     - fix DesignWare ATU enable checking (Jisheng Zhang)
    
     - reduce Layerscape dependencies on the bootloader by doing more
       initialization in the driver (Hou Zhiqiang)
    
     - improve Intel VMD performance allowing allocation of more IRQ vectors
       than present CPUs (Keith Busch)
    
     - improve endpoint framework support for initial DMA mask, different
       BAR sizes, configurable page sizes, MSI, test driver, etc (Kishon
       Vijay Abraham I, Stan Drozd)
    
     - rework CRS support to add periodic messages while we poll during
       enumeration and after Function-Level Reset and prepare for possible
       other uses of CRS (Sinan Kaya)
    
     - clean up Root Port AER handling by removing unnecessary code and
       moving error handler methods to struct pcie_port_service_driver
       (Christoph Hellwig)
    
     - clean up error handling paths in various drivers (Bjorn Andersson,
       Fabio Estevam, Gustavo A. R. Silva, Harunobu Kurokawa, Jeffy Chen,
       Lorenzo Pieralisi, Sergei Shtylyov)
    
     - clean up SR-IOV resource handling by disabling VF decoding before
       updating the corresponding resource structs (Gavin Shan)
    
     - clean up DesignWare-based drivers by unifying quirks to update Class
       Code and Interrupt Pin and related handling of write-protected
       registers (Hou Zhiqiang)
    
     - clean up by adding empty generic pcibios_align_resource() and
       pcibios_fixup_bus() and removing empty arch-specific implementations
       (Palmer Dabbelt)
    
     - request exclusive reset control for several drivers to allow cleanup
       elsewhere (Philipp Zabel)
    
     - constify various structures (Arvind Yadav, Bhumika Goyal)
    
     - convert from full_name() to %pOF (Rob Herring)
    
     - remove unused variables from iProc, HiSi, Altera, Keystone (Shawn
       Lin)
    
    * tag 'pci-v4.14-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (170 commits)
      PCI: xgene: Clean up whitespace
      PCI: xgene: Define XGENE_PCI_EXP_CAP and use generic PCI_EXP_RTCTL offset
      PCI: xgene: Fix platform_get_irq() error handling
      PCI: xilinx-nwl: Fix platform_get_irq() error handling
      PCI: rockchip: Fix platform_get_irq() error handling
      PCI: altera: Fix platform_get_irq() error handling
      PCI: spear13xx: Fix platform_get_irq() error handling
      PCI: artpec6: Fix platform_get_irq() error handling
      PCI: armada8k: Fix platform_get_irq() error handling
      PCI: dra7xx: Fix platform_get_irq() error handling
      PCI: exynos: Fix platform_get_irq() error handling
      PCI: iproc: Clean up whitespace
      PCI: iproc: Rename PCI_EXP_CAP to IPROC_PCI_EXP_CAP
      PCI: iproc: Add 500ms delay during device shutdown
      PCI: Fix typos and whitespace errors
      PCI: Remove unused "res" variable from pci_resource_io()
      PCI: Correct kernel-doc of pci_vpd_srdt_size(), pci_vpd_srdt_tag()
      PCI/AER: Reformat AER register definitions
      iommu/vt-d: Prevent VMD child devices from being remapping targets
      x86/PCI: Use is_vmd() rather than relying on the domain number
      ...

commit d872694bac212f76ca13fd20a85e5c1bdb53a945
Merge: 79ab592c700e ab4b8a47abee
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Sep 7 13:24:18 2017 -0500

    Merge branch 'pci/pm' into next
    
    * pci/pm:
      PCI/PM: Expand description of pci_set_power_state()

commit 33db87de6ab7ba9a3cca5b57033621ad154c1d0a
Merge: d4fdf844c9c3 ea5311c7e752
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Sep 7 13:24:16 2017 -0500

    Merge branch 'pci/misc' into next
    
    * pci/misc:
      PCI: Fix PCIe capability sizes
      PCI: Convert to using %pOF instead of full_name()
      PCI: Constify endpoint pci_epf_type device_type
      PCI: Constify bin_attribute structures
      PCI: Constify hotplug pci_device_id structures
      PCI: Constify hotplug attribute_group structures
      PCI: Constify label attribute_group structures
      PCI: Constify sysfs attribute_group structures

commit 4467ade90d62a87c449bc35df61378a81a702741
Merge: b2a84eedca1b eb7f43c4adb4 020a63756707
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Sep 3 23:53:19 2017 +0200

    Merge branches 'acpi-scan' and 'acpi-pm'
    
    * acpi-scan:
      ACPI / scan: Enable GPEs before scanning the namespace
      ACPICA: Make it possible to enable runtime GPEs earlier
      ACPICA: Dispatch active GPEs at init time
    
    * acpi-pm:
      ACPI / PM: Add debug statements to acpi_pm_notify_handler()
      ACPI: Add debug statements to acpi_global_event_handler()
      ACPI / sleep: Make acpi_sleep_syscore_init() static
      ACPI / PCI / PM: Rework acpi_pci_propagate_wakeup()
      ACPI / PM: Split acpi_device_wakeup()
      PCI / PM: Skip bridges in pci_enable_wake()

commit 821cdad5c46cae94ce65b9a98614c70a6ff021f8
Author: Sinan Kaya <okaya@codeaurora.org>
Date:   Tue Aug 29 14:45:45 2017 -0500

    PCI: Wait up to 60 seconds for device to become ready after FLR
    
    Sporadic reset issues have been observed with an Intel 750 NVMe drive while
    assigning the physical function to the guest machine.  The sequence of
    events observed is as follows:
    
      - perform a Function Level Reset (FLR)
      - sleep up to 1000ms total
      - read ~0 from PCI_COMMAND (CRS completion for config read)
      - warn that the device didn't return from FLR
      - touch the device before it's ready
      - device drops config writes when we restore register settings (there's
        no mechanism for software to learn about CRS completions for writes)
      - incomplete register restore leaves device in inconsistent state
      - device probe fails because device is in inconsistent state
    
    After reset, an endpoint may respond to config requests with Configuration
    Request Retry Status (CRS) to indicate that it is not ready to accept new
    requests. See PCIe r3.1, sec 2.3.1 and 6.6.2.
    
    Increase the timeout value from 1 second to 60 seconds to cover the period
    where device responds with CRS and also report polling progress.
    
    Signed-off-by: Sinan Kaya <okaya@codeaurora.org>
    [bhelgaas: include the mandatory 100ms in the delays we print]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 7cb29a223b73..827a9f99a8e5 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -3820,27 +3820,49 @@ int pci_wait_for_pending_transaction(struct pci_dev *dev)
 }
 EXPORT_SYMBOL(pci_wait_for_pending_transaction);
 
-/*
- * We should only need to wait 100ms after FLR, but some devices take longer.
- * Wait for up to 1000ms for config space to return something other than -1.
- * Intel IGD requires this when an LCD panel is attached.  We read the 2nd
- * dword because VFs don't implement the 1st dword.
- */
 static void pci_flr_wait(struct pci_dev *dev)
 {
-	int i = 0;
+	int delay = 1, timeout = 60000;
 	u32 id;
 
-	do {
-		msleep(100);
+	/*
+	 * Per PCIe r3.1, sec 6.6.2, a device must complete an FLR within
+	 * 100ms, but may silently discard requests while the FLR is in
+	 * progress.  Wait 100ms before trying to access the device.
+	 */
+	msleep(100);
+
+	/*
+	 * After 100ms, the device should not silently discard config
+	 * requests, but it may still indicate that it needs more time by
+	 * responding to them with CRS completions.  The Root Port will
+	 * generally synthesize ~0 data to complete the read (except when
+	 * CRS SV is enabled and the read was for the Vendor ID; in that
+	 * case it synthesizes 0x0001 data).
+	 *
+	 * Wait for the device to return a non-CRS completion.  Read the
+	 * Command register instead of Vendor ID so we don't have to
+	 * contend with the CRS SV value.
+	 */
+	pci_read_config_dword(dev, PCI_COMMAND, &id);
+	while (id == ~0) {
+		if (delay > timeout) {
+			dev_warn(&dev->dev, "not ready %dms after FLR; giving up\n",
+				 100 + delay - 1);
+			return;
+		}
+
+		if (delay > 1000)
+			dev_info(&dev->dev, "not ready %dms after FLR; waiting\n",
+				 100 + delay - 1);
+
+		msleep(delay);
+		delay *= 2;
 		pci_read_config_dword(dev, PCI_COMMAND, &id);
-	} while (i++ < 10 && id == ~0);
+	}
 
-	if (id == ~0)
-		dev_warn(&dev->dev, "Failed to return from FLR\n");
-	else if (i > 1)
-		dev_info(&dev->dev, "Required additional %dms to return from FLR\n",
-			 (i - 1) * 100);
+	if (delay > 1000)
+		dev_info(&dev->dev, "ready %dms after FLR\n", 100 + delay - 1);
 }
 
 /**

commit b63773a801ff7f7f047894a9be23616f4491aca8
Author: Rob Herring <robh@kernel.org>
Date:   Tue Jul 18 16:43:21 2017 -0500

    PCI: Convert to using %pOF instead of full_name()
    
    Now that we have a custom printf format specifier, convert users of
    full_name() to use %pOF instead.  This is preparation for removing storing
    of the full path string for each node.
    
    Signed-off-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Tyrel Datwyler <tyreld@linux.vnet.ibm.com>
    Cc: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Cc: Jason Cooper <jason@lakedaemon.net>
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Cc: Jonathan Hunter <jonathanh@nvidia.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index af0cc3456dc1..e8e40dea2842 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -5363,8 +5363,8 @@ static int of_pci_bus_find_domain_nr(struct device *parent)
 		use_dt_domains = 0;
 		domain = pci_get_new_domain_nr();
 	} else {
-		dev_err(parent, "Node %s has inconsistent \"linux,pci-domain\" property in DT\n",
-			parent->of_node->full_name);
+		dev_err(parent, "Node %pOF has inconsistent \"linux,pci-domain\" property in DT\n",
+			parent->of_node);
 		domain = -1;
 	}
 

commit 40f11adc7cd9281227f0a6a627d966dd0a5f0cd9
Author: Srinath Mannam <srinath.mannam@broadcom.com>
Date:   Fri Aug 18 21:50:48 2017 -0500

    PCI: Avoid race while enabling upstream bridges
    
    When we enable a device, we first enable any upstream bridges.  If a bridge
    has multiple downstream devices and we enable them simultaneously, the race
    to enable the upstream bridge may cause problems.  Consider this hierarchy:
    
      bridge A --+-- device B
                 +-- device C
    
    If drivers for B and C call pci_enable_device() simultaneously, both will
    attempt to enable A, which involves setting PCI_COMMAND_MASTER via
    pci_set_master() and PCI_COMMAND_MEMORY via pci_enable_resources().
    
    In the following sequence, B's update to set A's PCI_COMMAND_MEMORY is
    lost, and neither B nor C will work correctly:
    
          B                                C
      pci_set_master(A)
        cmd = read(A, PCI_COMMAND)
        cmd |= PCI_COMMAND_MASTER
                                       pci_set_master(A)
                                         cmd = read(A, PCI_COMMAND)
                                         cmd |= PCI_COMMAND_MASTER
        write(A, PCI_COMMAND, cmd)
      pci_enable_device(A)
        pci_enable_resources(A)
          cmd = read(A, PCI_COMMAND)
          cmd |= PCI_COMMAND_MEMORY
          write(A, PCI_COMMAND, cmd)
                                         write(A, PCI_COMMAND, cmd)
    
    Avoid this race by holding a new pci_bridge_mutex while enabling a bridge.
    This ensures that both PCI_COMMAND_MASTER and PCI_COMMAND_MEMORY will be
    updated before another thread can start enabling the bridge.
    
    Note that although pci_enable_bridge() is recursive, it enables any
    upstream bridges *before* acquiring the mutex.  When it acquires the mutex
    and calls pci_set_master() and pci_enable_device(), any upstream bridges
    have already been enabled so pci_enable_device() will not deadlock by
    calling pci_enable_bridge() again.
    
    Signed-off-by: Srinath Mannam <srinath.mannam@broadcom.com>
    [bhelgaas: changelog, comment]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index af0cc3456dc1..7cb29a223b73 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -52,6 +52,7 @@ static void pci_pme_list_scan(struct work_struct *work);
 static LIST_HEAD(pci_pme_list);
 static DEFINE_MUTEX(pci_pme_list_mutex);
 static DECLARE_DELAYED_WORK(pci_pme_work, pci_pme_list_scan);
+static DEFINE_MUTEX(pci_bridge_mutex);
 
 struct pci_pme_device {
 	struct list_head list;
@@ -1348,10 +1349,16 @@ static void pci_enable_bridge(struct pci_dev *dev)
 	if (bridge)
 		pci_enable_bridge(bridge);
 
+	/*
+	 * Hold pci_bridge_mutex to prevent a race when enabling two
+	 * devices below the bridge simultaneously.  The race may cause a
+	 * PCI_COMMAND_MEMORY update to be lost (see changelog).
+	 */
+	mutex_lock(&pci_bridge_mutex);
 	if (pci_is_enabled(dev)) {
 		if (!dev->is_busmaster)
 			pci_set_master(dev);
-		return;
+		goto end;
 	}
 
 	retval = pci_enable_device(dev);
@@ -1359,6 +1366,8 @@ static void pci_enable_bridge(struct pci_dev *dev)
 		dev_err(&dev->dev, "Error enabling bridge (%d), continuing\n",
 			retval);
 	pci_set_master(dev);
+end:
+	mutex_unlock(&pci_bridge_mutex);
 }
 
 static int pci_enable_device_flags(struct pci_dev *dev, unsigned long flags)
@@ -1383,7 +1392,7 @@ static int pci_enable_device_flags(struct pci_dev *dev, unsigned long flags)
 		return 0;		/* already enabled */
 
 	bridge = pci_upstream_bridge(dev);
-	if (bridge)
+	if (bridge && !pci_is_enabled(bridge))
 		pci_enable_bridge(bridge);
 
 	/* only skip sriov related */

commit b6f6d56c91f5261c55edef2df300698c4486b669
Author: Thierry Reding <treding@nvidia.com>
Date:   Thu Aug 17 13:06:14 2017 +0200

    PCI: Allow PCI express root ports to find themselves
    
    If the pci_find_pcie_root_port() function is called on a root port
    itself, return the root port rather than NULL.
    
    This effectively reverts commit 0e405232871d6 ("PCI: fix oops when
    try to find Root Port for a PCI device") which added an extra check
    that would now be redundant.
    
    Fixes: a99b646afa8a ("PCI: Disable PCIe Relaxed Ordering if unsupported")
    Fixes: c56d4450eb68 ("PCI: Turn off Request Attributes to avoid Chelsio T5 Completion erratum")
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Tested-by: Shawn Lin <shawn.lin@rock-chips.com>
    Tested-by: Michael Ellerman <mpe@ellerman.id.au>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index da5570cf5c6a..fdf65a6c13f6 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -514,7 +514,7 @@ EXPORT_SYMBOL(pci_find_resource);
  */
 struct pci_dev *pci_find_pcie_root_port(struct pci_dev *dev)
 {
-	struct pci_dev *bridge, *highest_pcie_bridge = NULL;
+	struct pci_dev *bridge, *highest_pcie_bridge = dev;
 
 	bridge = pci_upstream_bridge(dev);
 	while (bridge && pci_is_pcie(bridge)) {
@@ -522,11 +522,10 @@ struct pci_dev *pci_find_pcie_root_port(struct pci_dev *dev)
 		bridge = pci_upstream_bridge(bridge);
 	}
 
-	if (highest_pcie_bridge &&
-	    pci_pcie_type(highest_pcie_bridge) == PCI_EXP_TYPE_ROOT_PORT)
-		return highest_pcie_bridge;
+	if (pci_pcie_type(highest_pcie_bridge) != PCI_EXP_TYPE_ROOT_PORT)
+		return NULL;
 
-	return NULL;
+	return highest_pcie_bridge;
 }
 EXPORT_SYMBOL(pci_find_pcie_root_port);
 

commit 510c8a899caf095cb13d09d203573deef15db2fe
Merge: 40c6d1b9e2fc 88a5c690b661
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Aug 15 18:52:28 2017 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    Pull networking fixes from David Miller:
    
     1) Fix TCP checksum offload handling in iwlwifi driver, from Emmanuel
        Grumbach.
    
     2) In ksz DSA tagging code, free SKB if skb_put_padto() fails. From
        Vivien Didelot.
    
     3) Fix two regressions with bonding on wireless, from Andreas Born.
    
     4) Fix build when busypoll is disabled, from Daniel Borkmann.
    
     5) Fix copy_linear_skb() wrt. SO_PEEK_OFF, from Eric Dumazet.
    
     6) Set SKB cached route properly in inet_rtm_getroute(), from Florian
        Westphal.
    
     7) Fix PCI-E relaxed ordering handling in cxgb4 driver, from Ding
        Tianhong.
    
     8) Fix module refcnt leak in ULP code, from Sabrina Dubroca.
    
     9) Fix use of GFP_KERNEL in atomic contexts in AF_KEY code, from Eric
        Dumazet.
    
    10) Need to purge socket write queue in dccp_destroy_sock(), also from
        Eric Dumazet.
    
    11) Make bpf_trace_printk() work properly on 32-bit architectures, from
        Daniel Borkmann.
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/davem/net: (47 commits)
      bpf: fix bpf_trace_printk on 32 bit archs
      PCI: fix oops when try to find Root Port for a PCI device
      sfc: don't try and read ef10 data on non-ef10 NIC
      net_sched: remove warning from qdisc_hash_add
      net_sched/sfq: update hierarchical backlog when drop packet
      net_sched: reset pointers to tcf blocks in classful qdiscs' destructors
      ipv4: fix NULL dereference in free_fib_info_rcu()
      net: Fix a typo in comment about sock flags.
      ipv6: fix NULL dereference in ip6_route_dev_notify()
      tcp: fix possible deadlock in TCP stack vs BPF filter
      dccp: purge write queue in dccp_destroy_sock()
      udp: fix linear skb reception with PEEK_OFF
      ipv6: release rt6->rt6i_idev properly during ifdown
      af_key: do not use GFP_KERNEL in atomic contexts
      tcp: ulp: avoid module refcnt leak in tcp_set_ulp
      net/cxgb4vf: Use new PCI_DEV_FLAGS_NO_RELAXED_ORDERING flag
      net/cxgb4: Use new PCI_DEV_FLAGS_NO_RELAXED_ORDERING flag
      PCI: Disable Relaxed Ordering Attributes for AMD A1100
      PCI: Disable Relaxed Ordering for some Intel processors
      PCI: Disable PCIe Relaxed Ordering if unsupported
      ...

commit 0e405232871d67bf1b238d56b6b3d500e69ebbf3
Author: dingtianhong <dingtianhong@huawei.com>
Date:   Tue Aug 15 23:24:48 2017 +0800

    PCI: fix oops when try to find Root Port for a PCI device
    
    Eric report a oops when booting the system after applying
    the commit a99b646afa8a ("PCI: Disable PCIe Relaxed..."):
    
    [    4.241029] BUG: unable to handle kernel NULL pointer dereference at 0000000000000050
    [    4.247001] IP: pci_find_pcie_root_port+0x62/0x80
    [    4.253011] PGD 0
    [    4.253011] P4D 0
    [    4.253011]
    [    4.258013] Oops: 0000 [#1] SMP DEBUG_PAGEALLOC
    [    4.262015] Modules linked in:
    [    4.265005] CPU: 31 PID: 1 Comm: swapper/0 Not tainted 4.13.0-dbx-DEV #316
    [    4.271002] Hardware name: Intel RML,PCH/Iota_QC_19, BIOS 2.40.0 06/22/2016
    [    4.279002] task: ffffa2ee38cfa040 task.stack: ffffa51ec0004000
    [    4.285001] RIP: 0010:pci_find_pcie_root_port+0x62/0x80
    [    4.290012] RSP: 0000:ffffa51ec0007ab8 EFLAGS: 00010246
    [    4.295003] RAX: 0000000000000000 RBX: ffffa2ee36bae000 RCX: 0000000000000006
    [    4.303002] RDX: 000000000000081c RSI: ffffa2ee38cfa8c8 RDI: ffffa2ee36bae000
    [    4.310013] RBP: ffffa51ec0007b58 R08: 0000000000000001 R09: 0000000000000000
    [    4.317001] R10: 0000000000000000 R11: 0000000000000000 R12: ffffa51ec0007ad0
    [    4.324005] R13: ffffa2ee36bae098 R14: 0000000000000002 R15: ffffa2ee37204818
    [    4.331002] FS:  0000000000000000(0000) GS:ffffa2ee3fcc0000(0000) knlGS:0000000000000000
    [    4.339002] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [    4.345001] CR2: 0000000000000050 CR3: 000000401000f000 CR4: 00000000001406e0
    [    4.351002] Call Trace:
    [    4.354012]  ? pci_configure_device+0x19f/0x570
    [    4.359002]  ? pci_conf1_read+0xb8/0xf0
    [    4.363002]  ? raw_pci_read+0x23/0x40
    [    4.366011]  ? pci_read+0x2c/0x30
    [    4.370014]  ? pci_read_config_word+0x67/0x70
    [    4.374012]  pci_device_add+0x28/0x230
    [    4.378012]  ? pci_vpd_f0_read+0x50/0x80
    [    4.382014]  pci_scan_single_device+0x96/0xc0
    [    4.386012]  pci_scan_slot+0x79/0xf0
    [    4.389001]  pci_scan_child_bus+0x31/0x180
    [    4.394014]  acpi_pci_root_create+0x1c6/0x240
    [    4.398013]  pci_acpi_scan_root+0x15f/0x1b0
    [    4.402012]  acpi_pci_root_add+0x2e6/0x400
    [    4.406012]  ? acpi_evaluate_integer+0x37/0x60
    [    4.411002]  acpi_bus_attach+0xdf/0x200
    [    4.415002]  acpi_bus_attach+0x6a/0x200
    [    4.418014]  acpi_bus_attach+0x6a/0x200
    [    4.422013]  acpi_bus_scan+0x38/0x70
    [    4.426011]  acpi_scan_init+0x10c/0x271
    [    4.429001]  acpi_init+0x2fa/0x348
    [    4.433004]  ? acpi_sleep_proc_init+0x2d/0x2d
    [    4.437001]  do_one_initcall+0x43/0x169
    [    4.441001]  kernel_init_freeable+0x1d0/0x258
    [    4.445003]  ? rest_init+0xe0/0xe0
    [    4.449001]  kernel_init+0xe/0x150
    
    ====================== cut here =============================
    
    It looks like the pci_find_pcie_root_port() was trying to
    find the Root Port for the PCI device which is the Root
    Port already, it will return NULL and trigger the problem,
    so check the highest_pcie_bridge to fix thie problem.
    
    Fixes: a99b646afa8a ("PCI: Disable PCIe Relaxed Ordering if unsupported")
    Fixes: c56d4450eb68 ("PCI: Turn off Request Attributes to avoid Chelsio T5 Completion erratum")
    Reported-by: Eric Dumazet <eric.dumazet@gmail.com>
    Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com>
    Signed-off-by: Ding Tianhong <dingtianhong@huawei.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index af0cc3456dc1..587cd7623ed8 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -522,10 +522,11 @@ struct pci_dev *pci_find_pcie_root_port(struct pci_dev *dev)
 		bridge = pci_upstream_bridge(bridge);
 	}
 
-	if (pci_pcie_type(highest_pcie_bridge) != PCI_EXP_TYPE_ROOT_PORT)
-		return NULL;
+	if (highest_pcie_bridge &&
+	    pci_pcie_type(highest_pcie_bridge) == PCI_EXP_TYPE_ROOT_PORT)
+		return highest_pcie_bridge;
 
-	return highest_pcie_bridge;
+	return NULL;
 }
 EXPORT_SYMBOL(pci_find_pcie_root_port);
 

commit ab4b8a47abeefad94cdb6b4c0df6a13f4f6ae4e0
Author: Piotr Gregor <piotrgregor@rsyncme.org>
Date:   Wed Aug 2 20:42:18 2017 +0100

    PCI/PM: Expand description of pci_set_power_state()
    
    Add two reasons for returning 0 value to the description of
    pci_set_power_state() to include the cases when:
    
      - the transition is to D1 or D2 but D1 and D2 are not supported
      - the transition is to D3 but D3 is not supported
    
    Signed-off-by: Piotr Gregor <piotrgregor@rsyncme.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index af0cc3456dc1..9528781db4d3 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -892,7 +892,9 @@ EXPORT_SYMBOL_GPL(__pci_complete_power_transition);
  * -EINVAL if the requested state is invalid.
  * -EIO if device does not support PCI PM or its PM capabilities register has a
  * wrong version, or device doesn't support the requested state.
+ * 0 if the transition is to D1 or D2 but D1 and D2 are not supported.
  * 0 if device already is in the requested state.
+ * 0 if the transition is to D3 but D3 is not supported.
  * 0 if device's power state has been successfully changed.
  */
 int pci_set_power_state(struct pci_dev *dev, pci_power_t state)

commit a477b9cd37aa81a490dfa3265b7ff4f2c5a92463
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Tue Aug 1 20:11:02 2017 -0500

    PCI: Add pci_reset_function_locked()
    
    The implementation of PCI workarounds may require that the device is reset
    from its probe function.  This implies that the PCI device lock is already
    held, and makes calling pci_reset_function() impossible (since it will
    itself try to take that lock).
    
    Add pci_reset_function_locked(), which is the equivalent of
    pci_reset_function(), except that it requires the PCI device lock to be
    already held by the caller.
    
    Tested-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    [bhelgaas: folded in fix for conflict with 52354b9d1f46 ("PCI: Remove
    __pci_dev_reset() and pci_dev_reset()")]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: stable@vger.kernel.org      # 4.11: 52354b9d1f46: PCI: Remove __pci_dev_reset() and pci_dev_reset()
    Cc: stable@vger.kernel.org      # 4.11

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index af0cc3456dc1..b4b7eab29400 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -4259,6 +4259,41 @@ int pci_reset_function(struct pci_dev *dev)
 }
 EXPORT_SYMBOL_GPL(pci_reset_function);
 
+/**
+ * pci_reset_function_locked - quiesce and reset a PCI device function
+ * @dev: PCI device to reset
+ *
+ * Some devices allow an individual function to be reset without affecting
+ * other functions in the same device.  The PCI device must be responsive
+ * to PCI config space in order to use this function.
+ *
+ * This function does not just reset the PCI portion of a device, but
+ * clears all the state associated with the device.  This function differs
+ * from __pci_reset_function() in that it saves and restores device state
+ * over the reset.  It also differs from pci_reset_function() in that it
+ * requires the PCI device lock to be held.
+ *
+ * Returns 0 if the device function was successfully reset or negative if the
+ * device doesn't support resetting a single function.
+ */
+int pci_reset_function_locked(struct pci_dev *dev)
+{
+	int rc;
+
+	rc = pci_probe_reset_function(dev);
+	if (rc)
+		return rc;
+
+	pci_dev_save_and_disable(dev);
+
+	rc = __pci_reset_function_locked(dev);
+
+	pci_dev_restore(dev);
+
+	return rc;
+}
+EXPORT_SYMBOL_GPL(pci_reset_function_locked);
+
 /**
  * pci_try_reset_function - quiesce and reset a PCI device function
  * @dev: PCI device to reset

commit baecc470d5fd6e2d94eb2a7e242ba291ac7182ac
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Jul 21 14:38:08 2017 +0200

    PCI / PM: Skip bridges in pci_enable_wake()
    
    PCI bridges only have a reason to generate wakeup signals on behalf
    of devices below them, so avoid preparing bridges for wakeup directly
    in pci_enable_wake().
    
    Also drop the pci_has_subordinate() check from pci_pm_default_resume()
    as this will be done by pci_enable_wake() itself now.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index af0cc3456dc1..0d142031ebfb 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1912,6 +1912,13 @@ int pci_enable_wake(struct pci_dev *dev, pci_power_t state, bool enable)
 {
 	int ret = 0;
 
+	/*
+	 * Bridges can only signal wakeup on behalf of subordinate devices,
+	 * but that is set up elsewhere, so skip them.
+	 */
+	if (pci_has_subordinate(dev))
+		return 0;
+
 	/* Don't do the same thing twice in a row for one device. */
 	if (!!enable == !!dev->wakeup_prepared)
 		return 0;

commit ec4b8ddcd3b9836ae06fcf8d7f6442e7d9f0c6e6
Merge: 1633b396105b c7b5a4e6e8fb
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Jul 14 13:15:49 2017 +0200

    Merge branch 'pm-pci'
    
    * pm-pci:
      PCI / PM: Fix native PME handling during system suspend/resume
      PCI / PM: Restore PME Enable after config space restoration

commit 0ce3fcaff92908c370334ce3b9111aeea71159d6
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Jul 12 03:05:39 2017 +0200

    PCI / PM: Restore PME Enable after config space restoration
    
    Commit dc15e71eefc7 (PCI / PM: Restore PME Enable if skipping wakeup
    setup) introduced a mechanism by which the PME Enable bit can be
    restored by pci_enable_wake() if dev->wakeup_prepared is set in
    case it has been overwritten by PCI config space restoration.
    
    However, that commit overlooked the fact that on some systems (Dell
    XPS13 9360 in particular) the AML handling wakeup events checks PME
    Status and PME Enable and it won't trigger a Notify() for devices
    where those bits are not set while it is running.
    
    That happens during resume from suspend-to-idle when pci_restore_state()
    invoked by pci_pm_default_resume_early() clears PME Enable before the
    wakeup events are processed by AML, effectively causing those wakeup
    events to be ignored.
    
    Fix this issue by restoring the PME Enable configuration right after
    pci_restore_state() has been called instead of doing that in
    pci_enable_wake().
    
    Fixes: dc15e71eefc7 (PCI / PM: Restore PME Enable if skipping wakeup setup)
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 0b5302a9fdae..d1443a161b35 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1798,7 +1798,11 @@ static void __pci_pme_active(struct pci_dev *dev, bool enable)
 	pci_write_config_word(dev, dev->pm_cap + PCI_PM_CTRL, pmcsr);
 }
 
-static void pci_pme_restore(struct pci_dev *dev)
+/**
+ * pci_pme_restore - Restore PME configuration after config space restore.
+ * @dev: PCI device to update.
+ */
+void pci_pme_restore(struct pci_dev *dev)
 {
 	u16 pmcsr;
 
@@ -1808,6 +1812,7 @@ static void pci_pme_restore(struct pci_dev *dev)
 	pci_read_config_word(dev, dev->pm_cap + PCI_PM_CTRL, &pmcsr);
 	if (dev->wakeup_prepared) {
 		pmcsr |= PCI_PM_CTRL_PME_ENABLE;
+		pmcsr &= ~PCI_PM_CTRL_PME_STATUS;
 	} else {
 		pmcsr &= ~PCI_PM_CTRL_PME_ENABLE;
 		pmcsr |= PCI_PM_CTRL_PME_STATUS;
@@ -1904,14 +1909,9 @@ int pci_enable_wake(struct pci_dev *dev, pci_power_t state, bool enable)
 {
 	int ret = 0;
 
-	/*
-	 * Don't do the same thing twice in a row for one device, but restore
-	 * PME Enable in case it has been updated by config space restoration.
-	 */
-	if (!!enable == !!dev->wakeup_prepared) {
-		pci_pme_restore(dev);
+	/* Don't do the same thing twice in a row for one device. */
+	if (!!enable == !!dev->wakeup_prepared)
 		return 0;
-	}
 
 	/*
 	 * According to "PCI System Architecture" 4th ed. by Tom Shanley & Don

commit f263fbb8d60824993c1b64385056a3cfdbb21d45
Merge: 026d15f6b987 6aed468480e8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jul 8 15:51:57 2017 -0700

    Merge tag 'pci-v4.13-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI updates from Bjorn Helgaas:
    
      - add sysfs max_link_speed/width, current_link_speed/width (Wong Vee
        Khee)
    
      - make host bridge IRQ mapping much more generic (Matthew Minter,
        Lorenzo Pieralisi)
    
      - convert most drivers to pci_scan_root_bus_bridge() (Lorenzo
        Pieralisi)
    
      - mutex sriov_configure() (Jakub Kicinski)
    
      - mutex pci_error_handlers callbacks (Christoph Hellwig)
    
      - split ->reset_notify() into ->reset_prepare()/reset_done()
        (Christoph Hellwig)
    
      - support multiple PCIe portdrv interrupts for MSI as well as MSI-X
        (Gabriele Paoloni)
    
      - allocate MSI/MSI-X vector for Downstream Port Containment (Gabriele
        Paoloni)
    
      - fix MSI IRQ affinity pre/post/min_vecs issue (Michael Hernandez)
    
      - test INTx masking during enumeration, not at run-time (Piotr Gregor)
    
      - avoid using device_may_wakeup() for runtime PM (Rafael J. Wysocki)
    
      - restore the status of PCI devices across hibernation (Chen Yu)
    
      - keep parent resources that start at 0x0 (Ard Biesheuvel)
    
      - enable ECRC only if device supports it (Bjorn Helgaas)
    
      - restore PRI and PASID state after Function-Level Reset (CQ Tang)
    
      - skip DPC event if device is not present (Keith Busch)
    
      - check domain when matching SMBIOS info (Sujith Pandel)
    
      - mark Intel XXV710 NIC INTx masking as broken (Alex Williamson)
    
      - avoid AMD SB7xx EHCI USB wakeup defect (Kai-Heng Feng)
    
      - work around long-standing Macbook Pro poweroff issue (Bjorn Helgaas)
    
      - add Switchtec "running" status flag (Logan Gunthorpe)
    
      - fix dra7xx incorrect RW1C IRQ register usage (Arvind Yadav)
    
      - modify xilinx-nwl IRQ chip for legacy interrupts (Bharat Kumar
        Gogada)
    
      - move VMD SRCU cleanup after bus, child device removal (Jon Derrick)
    
      - add Faraday clock handling (Linus Walleij)
    
      - configure Rockchip MPS and reorganize (Shawn Lin)
    
      - limit Qualcomm TLP size to 2K (hardware issue) (Srinivas Kandagatla)
    
      - support Tegra MSI 64-bit addressing (Thierry Reding)
    
      - use Rockchip normal (not privileged) register bank (Shawn Lin)
    
      - add HiSilicon Kirin SoC PCIe controller driver (Xiaowei Song)
    
      - add Sigma Designs Tango SMP8759 PCIe controller driver (Marc
        Gonzalez)
    
      - add MediaTek PCIe host controller support (Ryder Lee)
    
      - add Qualcomm IPQ4019 support (John Crispin)
    
      - add HyperV vPCI protocol v1.2 support (Jork Loeser)
    
      - add i.MX6 regulator support (Quentin Schulz)
    
    * tag 'pci-v4.13-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (113 commits)
      PCI: tango: Add Sigma Designs Tango SMP8759 PCIe host bridge support
      PCI: Add DT binding for Sigma Designs Tango PCIe controller
      PCI: rockchip: Use normal register bank for config accessors
      dt-bindings: PCI: Add documentation for MediaTek PCIe
      PCI: Remove __pci_dev_reset() and pci_dev_reset()
      PCI: Split ->reset_notify() method into ->reset_prepare() and ->reset_done()
      PCI: xilinx: Make of_device_ids const
      PCI: xilinx-nwl: Modify IRQ chip for legacy interrupts
      PCI: vmd: Move SRCU cleanup after bus, child device removal
      PCI: vmd: Correct comment: VMD domains start at 0x10000, not 0x1000
      PCI: versatile: Add local struct device pointers
      PCI: tegra: Do not allocate MSI target memory
      PCI: tegra: Support MSI 64-bit addressing
      PCI: rockchip: Use local struct device pointer consistently
      PCI: rockchip: Check for clk_prepare_enable() errors during resume
      MAINTAINERS: Remove Wenrui Li as Rockchip PCIe driver maintainer
      PCI: rockchip: Configure RC's MPS setting
      PCI: rockchip: Reconfigure configuration space header type
      PCI: rockchip: Split out rockchip_pcie_cfg_configuration_accesses()
      PCI: rockchip: Move configuration accesses into rockchip_pcie_cfg_atu()
      ...

commit bb02ce95a59ee5b96579fab2e2e7635ee26d535b
Merge: c781f85bc195 52354b9d1f46
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Jul 3 08:00:29 2017 -0500

    Merge branch 'pci/virtualization' into next
    
    * pci/virtualization:
      PCI: Remove __pci_dev_reset() and pci_dev_reset()
      PCI: Split ->reset_notify() method into ->reset_prepare() and ->reset_done()
      PCI: Protect pci_error_handlers->reset_notify() usage with device_lock()
      PCI: Protect pci_driver->sriov_configure() usage with device_lock()
      PCI: Mark Intel XXV710 NIC INTx masking as broken
      PCI: Restore PRI and PASID state after Function-Level Reset
      PCI: Cache PRI and PASID bits in pci_dev

commit 52354b9d1f46aae7386db7bb8ec8484b5488087f
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Jun 1 13:10:39 2017 +0200

    PCI: Remove __pci_dev_reset() and pci_dev_reset()
    
    Implement the reset probing / reset chain directly in
    __pci_probe_reset_function() and __pci_reset_function_locked()
    respectively.
    
    Link: http://lkml.kernel.org/r/20170601111039.8913-4-hch@lst.de
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 56407eb1dc88..7a75502ece1d 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -4071,40 +4071,6 @@ static int pci_dev_reset_slot_function(struct pci_dev *dev, int probe)
 	return pci_reset_hotplug_slot(dev->slot->hotplug, probe);
 }
 
-static int __pci_dev_reset(struct pci_dev *dev, int probe)
-{
-	int rc;
-
-	might_sleep();
-
-	rc = pci_dev_specific_reset(dev, probe);
-	if (rc != -ENOTTY)
-		goto done;
-
-	if (pcie_has_flr(dev)) {
-		if (!probe)
-			pcie_flr(dev);
-		rc = 0;
-		goto done;
-	}
-
-	rc = pci_af_flr(dev, probe);
-	if (rc != -ENOTTY)
-		goto done;
-
-	rc = pci_pm_reset(dev, probe);
-	if (rc != -ENOTTY)
-		goto done;
-
-	rc = pci_dev_reset_slot_function(dev, probe);
-	if (rc != -ENOTTY)
-		goto done;
-
-	rc = pci_parent_bus_reset(dev, probe);
-done:
-	return rc;
-}
-
 static void pci_dev_lock(struct pci_dev *dev)
 {
 	pci_cfg_access_lock(dev);
@@ -4177,21 +4143,6 @@ static void pci_dev_restore(struct pci_dev *dev)
 		err_handler->reset_done(dev);
 }
 
-static int pci_dev_reset(struct pci_dev *dev, int probe)
-{
-	int rc;
-
-	if (!probe)
-		pci_dev_lock(dev);
-
-	rc = __pci_dev_reset(dev, probe);
-
-	if (!probe)
-		pci_dev_unlock(dev);
-
-	return rc;
-}
-
 /**
  * __pci_reset_function - reset a PCI device function
  * @dev: PCI device to reset
@@ -4211,7 +4162,13 @@ static int pci_dev_reset(struct pci_dev *dev, int probe)
  */
 int __pci_reset_function(struct pci_dev *dev)
 {
-	return pci_dev_reset(dev, 0);
+	int ret;
+
+	pci_dev_lock(dev);
+	ret = __pci_reset_function_locked(dev);
+	pci_dev_unlock(dev);
+
+	return ret;
 }
 EXPORT_SYMBOL_GPL(__pci_reset_function);
 
@@ -4236,7 +4193,27 @@ EXPORT_SYMBOL_GPL(__pci_reset_function);
  */
 int __pci_reset_function_locked(struct pci_dev *dev)
 {
-	return __pci_dev_reset(dev, 0);
+	int rc;
+
+	might_sleep();
+
+	rc = pci_dev_specific_reset(dev, 0);
+	if (rc != -ENOTTY)
+		return rc;
+	if (pcie_has_flr(dev)) {
+		pcie_flr(dev);
+		return 0;
+	}
+	rc = pci_af_flr(dev, 0);
+	if (rc != -ENOTTY)
+		return rc;
+	rc = pci_pm_reset(dev, 0);
+	if (rc != -ENOTTY)
+		return rc;
+	rc = pci_dev_reset_slot_function(dev, 0);
+	if (rc != -ENOTTY)
+		return rc;
+	return pci_parent_bus_reset(dev, 0);
 }
 EXPORT_SYMBOL_GPL(__pci_reset_function_locked);
 
@@ -4253,7 +4230,26 @@ EXPORT_SYMBOL_GPL(__pci_reset_function_locked);
  */
 int pci_probe_reset_function(struct pci_dev *dev)
 {
-	return pci_dev_reset(dev, 1);
+	int rc;
+
+	might_sleep();
+
+	rc = pci_dev_specific_reset(dev, 1);
+	if (rc != -ENOTTY)
+		return rc;
+	if (pcie_has_flr(dev))
+		return 0;
+	rc = pci_af_flr(dev, 1);
+	if (rc != -ENOTTY)
+		return rc;
+	rc = pci_pm_reset(dev, 1);
+	if (rc != -ENOTTY)
+		return rc;
+	rc = pci_dev_reset_slot_function(dev, 1);
+	if (rc != -ENOTTY)
+		return rc;
+
+	return pci_parent_bus_reset(dev, 1);
 }
 
 /**
@@ -4276,14 +4272,14 @@ int pci_reset_function(struct pci_dev *dev)
 {
 	int rc;
 
-	rc = pci_dev_reset(dev, 1);
+	rc = pci_probe_reset_function(dev);
 	if (rc)
 		return rc;
 
 	pci_dev_lock(dev);
 	pci_dev_save_and_disable(dev);
 
-	rc = __pci_dev_reset(dev, 0);
+	rc = __pci_reset_function_locked(dev);
 
 	pci_dev_restore(dev);
 	pci_dev_unlock(dev);
@@ -4302,7 +4298,7 @@ int pci_try_reset_function(struct pci_dev *dev)
 {
 	int rc;
 
-	rc = pci_dev_reset(dev, 1);
+	rc = pci_probe_reset_function(dev);
 	if (rc)
 		return rc;
 
@@ -4310,7 +4306,7 @@ int pci_try_reset_function(struct pci_dev *dev)
 		return -EAGAIN;
 
 	pci_dev_save_and_disable(dev);
-	rc = __pci_dev_reset(dev, 0);
+	rc = __pci_reset_function_locked(dev);
 	pci_dev_unlock(dev);
 
 	pci_dev_restore(dev);

commit 775755ed3c65fb2d31f9268162495d76eaa2c281
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Jun 1 13:10:38 2017 +0200

    PCI: Split ->reset_notify() method into ->reset_prepare() and ->reset_done()
    
    The pci_error_handlers->reset_notify() method had a flag to indicate
    whether to prepare for or clean up after a reset.  The prepare and done
    cases have no shared functionality whatsoever, so split them into separate
    methods.
    
    [bhelgaas: changelog, update locking comments]
    Link: http://lkml.kernel.org/r/20170601111039.8913-3-hch@lst.de
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index f4587f6f8739..56407eb1dc88 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -4130,32 +4130,18 @@ static void pci_dev_unlock(struct pci_dev *dev)
 	pci_cfg_access_unlock(dev);
 }
 
-/**
- * pci_reset_notify - notify device driver of reset
- * @dev: device to be notified of reset
- * @prepare: 'true' if device is about to be reset; 'false' if reset attempt
- *           completed
- *
- * Must be called prior to device access being disabled and after device
- * access is restored.
- */
-static void pci_reset_notify(struct pci_dev *dev, bool prepare)
+static void pci_dev_save_and_disable(struct pci_dev *dev)
 {
 	const struct pci_error_handlers *err_handler =
 			dev->driver ? dev->driver->err_handler : NULL;
 
 	/*
-	 * dev->driver->err_handler->reset_notify() is protected against
+	 * dev->driver->err_handler->reset_prepare() is protected against
 	 * races with ->remove() by the device lock, which must be held by
 	 * the caller.
 	 */
-	if (err_handler && err_handler->reset_notify)
-		err_handler->reset_notify(dev, prepare);
-}
-
-static void pci_dev_save_and_disable(struct pci_dev *dev)
-{
-	pci_reset_notify(dev, true);
+	if (err_handler && err_handler->reset_prepare)
+		err_handler->reset_prepare(dev);
 
 	/*
 	 * Wake-up device prior to save.  PM registers default to D0 after
@@ -4177,8 +4163,18 @@ static void pci_dev_save_and_disable(struct pci_dev *dev)
 
 static void pci_dev_restore(struct pci_dev *dev)
 {
+	const struct pci_error_handlers *err_handler =
+			dev->driver ? dev->driver->err_handler : NULL;
+
 	pci_restore_state(dev);
-	pci_reset_notify(dev, false);
+
+	/*
+	 * dev->driver->err_handler->reset_done() is protected against
+	 * races with ->remove() by the device lock, which must be held by
+	 * the caller.
+	 */
+	if (err_handler && err_handler->reset_done)
+		err_handler->reset_done(dev);
 }
 
 static int pci_dev_reset(struct pci_dev *dev, int probe)

commit 8cd93850347bb4487d332d6638a22c7686ae237d
Merge: 74da4a0180fb 13cfc732160f
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Sun Jul 2 18:49:49 2017 -0500

    Merge branch 'pci/resource' into next
    
    * pci/resource:
      PCI: Work around poweroff & suspend-to-RAM issue on Macbook Pro 11
      PCI: Do not disregard parent resources starting at 0x0
    
    Conflicts:
    arch/x86/pci/fixup.c

commit 2cf816a947e0f729825a1bb73d2eed6255c29f88
Merge: 6a1c1d553ebf 666ff6f83e1d
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Sun Jul 2 18:48:49 2017 -0500

    Merge branch 'pci/pm' into next
    
    * pci/pm:
      PCI/PM: Avoid using device_may_wakeup() for runtime PM
      x86/PCI: Avoid AMD SB7xx EHCI USB wakeup defect
      PCI/PM: Restore the status of PCI devices across hibernation
      drm/radeon: make MacBook Pro d3_delay quirk more generic
      drm/amdgpu: remove unnecessary save/restore of pdev->d3_delay
      PCI/PM: Add needs_resume flag to avoid suspend complete optimization
      PCI: imx6: Fix config read timeout handling
      switchtec: Fix minor bug with partition ID register
      switchtec: Use new cdev_device_add() helper function
      PCI: endpoint: Make PCI_ENDPOINT depend on HAS_DMA

commit 666ff6f83e1db6ed847abf44eb5e3402d82b9350
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Jun 23 14:58:11 2017 +0200

    PCI/PM: Avoid using device_may_wakeup() for runtime PM
    
    pci_target_state() calls device_may_wakeup() which checks whether or not
    the device may wake up the system from sleep states, but pci_target_state()
    is used for runtime PM too.
    
    Since runtime PM is expected to always enable remote wakeup if possible,
    modify pci_target_state() to take additional argument indicating whether or
    not it should look for a state from which the device can signal wakeup and
    pass either the return value of device_can_wakeup(), or "false" (if the
    device itself is not wakeup-capable) to it from the code related to runtime
    PM.
    
    While at it, fix the comment in pci_dev_run_wake() which is not about sleep
    states.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 563901cd9c06..05c2a130544e 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1960,12 +1960,13 @@ EXPORT_SYMBOL(pci_wake_from_d3);
 /**
  * pci_target_state - find an appropriate low power state for a given PCI dev
  * @dev: PCI device
+ * @wakeup: Whether or not wakeup functionality will be enabled for the device.
  *
  * Use underlying platform code to find a supported low power state for @dev.
  * If the platform can't manage @dev, return the deepest state from which it
  * can generate wake events, based on any available PME info.
  */
-static pci_power_t pci_target_state(struct pci_dev *dev)
+static pci_power_t pci_target_state(struct pci_dev *dev, bool wakeup)
 {
 	pci_power_t target_state = PCI_D3hot;
 
@@ -2002,7 +2003,7 @@ static pci_power_t pci_target_state(struct pci_dev *dev)
 	if (dev->current_state == PCI_D3cold)
 		target_state = PCI_D3cold;
 
-	if (device_may_wakeup(&dev->dev)) {
+	if (wakeup) {
 		/*
 		 * Find the deepest state from which the device can generate
 		 * wake-up events, make it the target state and enable device
@@ -2028,13 +2029,14 @@ static pci_power_t pci_target_state(struct pci_dev *dev)
  */
 int pci_prepare_to_sleep(struct pci_dev *dev)
 {
-	pci_power_t target_state = pci_target_state(dev);
+	bool wakeup = device_may_wakeup(&dev->dev);
+	pci_power_t target_state = pci_target_state(dev, wakeup);
 	int error;
 
 	if (target_state == PCI_POWER_ERROR)
 		return -EIO;
 
-	pci_enable_wake(dev, target_state, device_may_wakeup(&dev->dev));
+	pci_enable_wake(dev, target_state, wakeup);
 
 	error = pci_set_power_state(dev, target_state);
 
@@ -2067,9 +2069,10 @@ EXPORT_SYMBOL(pci_back_from_sleep);
  */
 int pci_finish_runtime_suspend(struct pci_dev *dev)
 {
-	pci_power_t target_state = pci_target_state(dev);
+	pci_power_t target_state;
 	int error;
 
+	target_state = pci_target_state(dev, device_can_wakeup(&dev->dev));
 	if (target_state == PCI_POWER_ERROR)
 		return -EIO;
 
@@ -2105,8 +2108,8 @@ bool pci_dev_run_wake(struct pci_dev *dev)
 	if (!dev->pme_support)
 		return false;
 
-	/* PME-capable in principle, but not from the intended sleep state */
-	if (!pci_pme_capable(dev, pci_target_state(dev)))
+	/* PME-capable in principle, but not from the target power state */
+	if (!pci_pme_capable(dev, pci_target_state(dev, false)))
 		return false;
 
 	while (bus->parent) {
@@ -2141,9 +2144,10 @@ EXPORT_SYMBOL_GPL(pci_dev_run_wake);
 bool pci_dev_keep_suspended(struct pci_dev *pci_dev)
 {
 	struct device *dev = &pci_dev->dev;
+	bool wakeup = device_may_wakeup(dev);
 
 	if (!pm_runtime_suspended(dev)
-	    || pci_target_state(pci_dev) != pci_dev->current_state
+	    || pci_target_state(pci_dev, wakeup) != pci_dev->current_state
 	    || platform_pci_need_resume(pci_dev)
 	    || (pci_dev->dev_flags & PCI_DEV_FLAGS_NEEDS_RESUME))
 		return false;
@@ -2161,7 +2165,7 @@ bool pci_dev_keep_suspended(struct pci_dev *pci_dev)
 	spin_lock_irq(&dev->power.lock);
 
 	if (pm_runtime_suspended(dev) && pci_dev->current_state < PCI_D3cold &&
-	    !device_may_wakeup(dev))
+	    !wakeup)
 		__pci_pme_active(pci_dev, false);
 
 	spin_unlock_irq(&dev->power.lock);

commit de3ef1eb1cd0cc3a75f7a3661e10ed827f370ab8
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Jun 24 01:58:53 2017 +0200

    PM / core: Drop run_wake flag from struct dev_pm_info
    
    The run_wake flag in struct dev_pm_info is used to indicate whether
    or not the device is capable of generating remote wakeup signals at
    run time (or in the system working state), but the distinction
    between runtime remote wakeup and system wakeup signaling has always
    been rather artificial.  The only practical reason for it to exist
    at the core level was that ACPI and PCI treated those two cases
    differently, but that's not the case any more after recent changes.
    
    For this reason, get rid of the run_wake flag and, when applicable,
    use device_set_wakeup_capable() and device_can_wakeup() instead of
    device_set_run_wake() and device_run_wake(), respectively.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index d378262d30e3..0b5302a9fdae 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2105,7 +2105,7 @@ bool pci_dev_run_wake(struct pci_dev *dev)
 {
 	struct pci_bus *bus = dev->bus;
 
-	if (device_run_wake(&dev->dev))
+	if (device_can_wakeup(&dev->dev))
 		return true;
 
 	if (!dev->pme_support)
@@ -2118,7 +2118,7 @@ bool pci_dev_run_wake(struct pci_dev *dev)
 	while (bus->parent) {
 		struct pci_dev *bridge = bus->self;
 
-		if (device_run_wake(&bridge->dev))
+		if (device_can_wakeup(&bridge->dev))
 			return true;
 
 		bus = bus->parent;
@@ -2126,7 +2126,7 @@ bool pci_dev_run_wake(struct pci_dev *dev)
 
 	/* We have reached the root bus. */
 	if (bus->bridge)
-		return device_run_wake(bus->bridge);
+		return device_can_wakeup(bus->bridge);
 
 	return false;
 }

commit 0847684cfc5f0e9f009919bfdcb041d60e19b856
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Jun 24 01:57:35 2017 +0200

    PCI / PM: Simplify device wakeup settings code
    
    After previous changes it is not necessary to distinguish between
    device wakeup for run time and device wakeup from system sleep states
    any more, so rework the PCI device wakeup settings code accordingly.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 5641035e58fa..d378262d30e3 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -574,8 +574,7 @@ static const struct pci_platform_pm_ops *pci_platform_pm;
 int pci_set_platform_pm(const struct pci_platform_pm_ops *ops)
 {
 	if (!ops->is_manageable || !ops->set_state  || !ops->get_state ||
-	    !ops->choose_state  || !ops->sleep_wake || !ops->run_wake  ||
-	    !ops->need_resume)
+	    !ops->choose_state  || !ops->set_wakeup || !ops->need_resume)
 		return -EINVAL;
 	pci_platform_pm = ops;
 	return 0;
@@ -603,16 +602,10 @@ static inline pci_power_t platform_pci_choose_state(struct pci_dev *dev)
 			pci_platform_pm->choose_state(dev) : PCI_POWER_ERROR;
 }
 
-static inline int platform_pci_sleep_wake(struct pci_dev *dev, bool enable)
+static inline int platform_pci_set_wakeup(struct pci_dev *dev, bool enable)
 {
 	return pci_platform_pm ?
-			pci_platform_pm->sleep_wake(dev, enable) : -ENODEV;
-}
-
-static inline int platform_pci_run_wake(struct pci_dev *dev, bool enable)
-{
-	return pci_platform_pm ?
-			pci_platform_pm->run_wake(dev, enable) : -ENODEV;
+			pci_platform_pm->set_wakeup(dev, enable) : -ENODEV;
 }
 
 static inline bool platform_pci_need_resume(struct pci_dev *dev)
@@ -1889,10 +1882,9 @@ void pci_pme_active(struct pci_dev *dev, bool enable)
 EXPORT_SYMBOL(pci_pme_active);
 
 /**
- * __pci_enable_wake - enable PCI device as wakeup event source
+ * pci_enable_wake - enable PCI device as wakeup event source
  * @dev: PCI device affected
  * @state: PCI state from which device will issue wakeup events
- * @runtime: True if the events are to be generated at run time
  * @enable: True to enable event generation; false to disable
  *
  * This enables the device as a wakeup event source, or disables it.
@@ -1908,14 +1900,10 @@ EXPORT_SYMBOL(pci_pme_active);
  * Error code depending on the platform is returned if both the platform and
  * the native mechanism fail to enable the generation of wake-up events
  */
-int __pci_enable_wake(struct pci_dev *dev, pci_power_t state,
-		      bool runtime, bool enable)
+int pci_enable_wake(struct pci_dev *dev, pci_power_t state, bool enable)
 {
 	int ret = 0;
 
-	if (enable && !runtime && !device_may_wakeup(&dev->dev))
-		return -EINVAL;
-
 	/*
 	 * Don't do the same thing twice in a row for one device, but restore
 	 * PME Enable in case it has been updated by config space restoration.
@@ -1938,24 +1926,20 @@ int __pci_enable_wake(struct pci_dev *dev, pci_power_t state,
 			pci_pme_active(dev, true);
 		else
 			ret = 1;
-		error = runtime ? platform_pci_run_wake(dev, true) :
-					platform_pci_sleep_wake(dev, true);
+		error = platform_pci_set_wakeup(dev, true);
 		if (ret)
 			ret = error;
 		if (!ret)
 			dev->wakeup_prepared = true;
 	} else {
-		if (runtime)
-			platform_pci_run_wake(dev, false);
-		else
-			platform_pci_sleep_wake(dev, false);
+		platform_pci_set_wakeup(dev, false);
 		pci_pme_active(dev, false);
 		dev->wakeup_prepared = false;
 	}
 
 	return ret;
 }
-EXPORT_SYMBOL(__pci_enable_wake);
+EXPORT_SYMBOL(pci_enable_wake);
 
 /**
  * pci_wake_from_d3 - enable/disable device to wake up from D3_hot or D3_cold
@@ -2097,12 +2081,12 @@ int pci_finish_runtime_suspend(struct pci_dev *dev)
 
 	dev->runtime_d3cold = target_state == PCI_D3cold;
 
-	__pci_enable_wake(dev, target_state, true, pci_dev_run_wake(dev));
+	pci_enable_wake(dev, target_state, pci_dev_run_wake(dev));
 
 	error = pci_set_power_state(dev, target_state);
 
 	if (error) {
-		__pci_enable_wake(dev, target_state, true, false);
+		pci_enable_wake(dev, target_state, false);
 		dev->runtime_d3cold = false;
 	}
 

commit 99b3c58f7ba7fae801e501b45c5fcf6e08d9247f
Author: Piotr Gregor <piotrgregor@rsyncme.org>
Date:   Fri May 26 22:02:25 2017 +0100

    PCI: Test INTx masking during enumeration, not at run-time
    
    The test for INTx masking via PCI_COMMAND_INTX_DISABLE performed in
    pci_intx_mask_supported() should be done before the device can be used.
    This is to avoid writing PCI_COMMAND while the driver owns the device, in
    case that has any effect on MSI/MSI-X interrupts.
    
    Move the content of pci_intx_mask_supported() to pci_intx_mask_broken() and
    call it from pci_setup_device().
    
    The test result can be queried at any time later using the same
    pci_intx_mask_supported() interface as before (though with changed
    implementation), so callers (uio, vfio) should be unaffected.
    
    Signed-off-by: Piotr Gregor <piotrgregor@rsyncme.org>
    [bhelgaas: changelog, remove quirk check, remove locking, move
    dev->broken_intx_masking assignment to caller]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Alex Williamson <alex.williamson@redhat.com>
    Acked-by: Michael S. Tsirkin <mst@redhat.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index b01bd5bba8e6..7c4e1aa67c67 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -3708,46 +3708,6 @@ void pci_intx(struct pci_dev *pdev, int enable)
 }
 EXPORT_SYMBOL_GPL(pci_intx);
 
-/**
- * pci_intx_mask_supported - probe for INTx masking support
- * @dev: the PCI device to operate on
- *
- * Check if the device dev support INTx masking via the config space
- * command word.
- */
-bool pci_intx_mask_supported(struct pci_dev *dev)
-{
-	bool mask_supported = false;
-	u16 orig, new;
-
-	if (dev->broken_intx_masking)
-		return false;
-
-	pci_cfg_access_lock(dev);
-
-	pci_read_config_word(dev, PCI_COMMAND, &orig);
-	pci_write_config_word(dev, PCI_COMMAND,
-			      orig ^ PCI_COMMAND_INTX_DISABLE);
-	pci_read_config_word(dev, PCI_COMMAND, &new);
-
-	/*
-	 * There's no way to protect against hardware bugs or detect them
-	 * reliably, but as long as we know what the value should be, let's
-	 * go ahead and check it.
-	 */
-	if ((new ^ orig) & ~PCI_COMMAND_INTX_DISABLE) {
-		dev_err(&dev->dev, "Command register changed from 0x%x to 0x%x: driver or hardware bug?\n",
-			orig, new);
-	} else if ((new ^ orig) & PCI_COMMAND_INTX_DISABLE) {
-		mask_supported = true;
-		pci_write_config_word(dev, PCI_COMMAND, orig);
-	}
-
-	pci_cfg_access_unlock(dev);
-	return mask_supported;
-}
-EXPORT_SYMBOL_GPL(pci_intx_mask_supported);
-
 static bool pci_check_and_set_intx_mask(struct pci_dev *dev, bool mask)
 {
 	struct pci_bus *bus = dev->bus;
@@ -3798,7 +3758,7 @@ static bool pci_check_and_set_intx_mask(struct pci_dev *dev, bool mask)
  * @dev: the PCI device to operate on
  *
  * Check if the device dev has its INTx line asserted, mask it and
- * return true in that case. False is returned if not interrupt was
+ * return true in that case. False is returned if no interrupt was
  * pending.
  */
 bool pci_check_and_mask_intx(struct pci_dev *dev)

commit b014e96d1abbd67404bbe2018937b46466299e9e
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Jun 1 13:10:37 2017 +0200

    PCI: Protect pci_error_handlers->reset_notify() usage with device_lock()
    
    Every method in struct device_driver or structures derived from it like
    struct pci_driver MUST provide exclusion vs the driver's ->remove() method,
    usually by using device_lock().
    
    Protect use of pci_error_handlers->reset_notify() by holding the device
    lock while calling it.
    
    Note:
    
      - pci_dev_lock() calls device_lock() in addition to blocking user-space
        config accesses.
    
      - pci_err_handlers->reset_notify() is used inside
        pci_dev_save_and_disable() and pci_dev_restore().  We could hold the
        device lock directly in pci_reset_notify(), but we expand the region
        since we have several calls following each other.
    
    Without this, ->reset_notify() may race with ->remove() calls, which can be
    easily triggered in NVMe.
    
    [bhelgaas: changelog, add pci_reset_notify() comment]
    [bhelgaas: fold in fix from Dan Carpenter <dan.carpenter@oracle.com>:
    http://lkml.kernel.org/r/20170701135323.x5vaj4e2wcs2mcro@mwanda]
    Link: http://lkml.kernel.org/r/20170601111039.8913-2-hch@lst.de
    Reported-by: Rakesh Pandit <rakesh@tuxera.com>
    Tested-by: Rakesh Pandit <rakesh@tuxera.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 3b38e98e68df..f4587f6f8739 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -4143,6 +4143,12 @@ static void pci_reset_notify(struct pci_dev *dev, bool prepare)
 {
 	const struct pci_error_handlers *err_handler =
 			dev->driver ? dev->driver->err_handler : NULL;
+
+	/*
+	 * dev->driver->err_handler->reset_notify() is protected against
+	 * races with ->remove() by the device lock, which must be held by
+	 * the caller.
+	 */
 	if (err_handler && err_handler->reset_notify)
 		err_handler->reset_notify(dev, prepare);
 }
@@ -4278,11 +4284,13 @@ int pci_reset_function(struct pci_dev *dev)
 	if (rc)
 		return rc;
 
+	pci_dev_lock(dev);
 	pci_dev_save_and_disable(dev);
 
-	rc = pci_dev_reset(dev, 0);
+	rc = __pci_dev_reset(dev, 0);
 
 	pci_dev_restore(dev);
+	pci_dev_unlock(dev);
 
 	return rc;
 }
@@ -4302,16 +4310,14 @@ int pci_try_reset_function(struct pci_dev *dev)
 	if (rc)
 		return rc;
 
-	pci_dev_save_and_disable(dev);
+	if (!pci_dev_trylock(dev))
+		return -EAGAIN;
 
-	if (pci_dev_trylock(dev)) {
-		rc = __pci_dev_reset(dev, 0);
-		pci_dev_unlock(dev);
-	} else
-		rc = -EAGAIN;
+	pci_dev_save_and_disable(dev);
+	rc = __pci_dev_reset(dev, 0);
+	pci_dev_unlock(dev);
 
 	pci_dev_restore(dev);
-
 	return rc;
 }
 EXPORT_SYMBOL_GPL(pci_try_reset_function);
@@ -4461,7 +4467,9 @@ static void pci_bus_save_and_disable(struct pci_bus *bus)
 	struct pci_dev *dev;
 
 	list_for_each_entry(dev, &bus->devices, bus_list) {
+		pci_dev_lock(dev);
 		pci_dev_save_and_disable(dev);
+		pci_dev_unlock(dev);
 		if (dev->subordinate)
 			pci_bus_save_and_disable(dev->subordinate);
 	}
@@ -4476,7 +4484,9 @@ static void pci_bus_restore(struct pci_bus *bus)
 	struct pci_dev *dev;
 
 	list_for_each_entry(dev, &bus->devices, bus_list) {
+		pci_dev_lock(dev);
 		pci_dev_restore(dev);
+		pci_dev_unlock(dev);
 		if (dev->subordinate)
 			pci_bus_restore(dev->subordinate);
 	}

commit dc15e71eefc766373833602c353cf6b4f49da036
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Jun 12 22:53:36 2017 +0200

    PCI / PM: Restore PME Enable if skipping wakeup setup
    
    The wakeup_prepared PCI device flag is used for preventing subsequent
    changes of PCI device wakeup settings in the same way (e.g. enabling
    device wakeup twice in a row).
    
    However, in some cases PME Enable may be updated by things like PCI
    configuration space restoration in the meantime and it may need to be
    set again even though the rest of the settings need not change, so
    modify __pci_enable_wake() to do that when it is about to return
    early.
    
    Also, it is reasonable to expect that __pci_enable_wake() will always
    clear PME Status when invoked to disable device wakeup, so make it do
    so even if it is going to return early then.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 563901cd9c06..5641035e58fa 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1805,6 +1805,23 @@ static void __pci_pme_active(struct pci_dev *dev, bool enable)
 	pci_write_config_word(dev, dev->pm_cap + PCI_PM_CTRL, pmcsr);
 }
 
+static void pci_pme_restore(struct pci_dev *dev)
+{
+	u16 pmcsr;
+
+	if (!dev->pme_support)
+		return;
+
+	pci_read_config_word(dev, dev->pm_cap + PCI_PM_CTRL, &pmcsr);
+	if (dev->wakeup_prepared) {
+		pmcsr |= PCI_PM_CTRL_PME_ENABLE;
+	} else {
+		pmcsr &= ~PCI_PM_CTRL_PME_ENABLE;
+		pmcsr |= PCI_PM_CTRL_PME_STATUS;
+	}
+	pci_write_config_word(dev, dev->pm_cap + PCI_PM_CTRL, pmcsr);
+}
+
 /**
  * pci_pme_active - enable or disable PCI device's PME# function
  * @dev: PCI device to handle.
@@ -1899,9 +1916,14 @@ int __pci_enable_wake(struct pci_dev *dev, pci_power_t state,
 	if (enable && !runtime && !device_may_wakeup(&dev->dev))
 		return -EINVAL;
 
-	/* Don't do the same thing twice in a row for one device. */
-	if (!!enable == !!dev->wakeup_prepared)
+	/*
+	 * Don't do the same thing twice in a row for one device, but restore
+	 * PME Enable in case it has been updated by config space restoration.
+	 */
+	if (!!enable == !!dev->wakeup_prepared) {
+		pci_pme_restore(dev);
 		return 0;
+	}
 
 	/*
 	 * According to "PCI System Architecture" 4th ed. by Tom Shanley & Don

commit 4ebeb1ec56d4c54a56b6f43c2603d9a4688c83ba
Author: CQ Tang <cq.tang@intel.com>
Date:   Tue May 30 09:25:49 2017 -0700

    PCI: Restore PRI and PASID state after Function-Level Reset
    
    After a Function-Level Reset, PCI states need to be restored.  Save PASID
    features and PRI reqs cached.
    
    [bhelgaas: search for capability only if PRI/PASID were enabled]
    Signed-off-by: CQ Tang <cq.tang@intel.com>
    Signed-off-by: Ashok Raj <ashok.raj@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: Jean-Phillipe Brucker <jean-philippe.brucker@arm.com>
    Cc: David Woodhouse <dwmw2@infradead.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index b01bd5bba8e6..3b38e98e68df 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -28,6 +28,7 @@
 #include <linux/pm_runtime.h>
 #include <linux/pci_hotplug.h>
 #include <linux/vmalloc.h>
+#include <linux/pci-ats.h>
 #include <asm/setup.h>
 #include <asm/dma.h>
 #include <linux/aer.h>
@@ -1173,6 +1174,8 @@ void pci_restore_state(struct pci_dev *dev)
 
 	/* PCI Express register must be restored first */
 	pci_restore_pcie_state(dev);
+	pci_restore_pasid_state(dev);
+	pci_restore_pri_state(dev);
 	pci_restore_ats_state(dev);
 	pci_restore_vc_state(dev);
 

commit 4d071c3238987325b9e50e33051a40d1cce311cc
Author: Imre Deak <imre.deak@intel.com>
Date:   Tue May 23 14:18:17 2017 -0500

    PCI/PM: Add needs_resume flag to avoid suspend complete optimization
    
    Some drivers - like i915 - may not support the system suspend direct
    complete optimization due to differences in their runtime and system
    suspend sequence.  Add a flag that when set resumes the device before
    calling the driver's system suspend handlers which effectively disables
    the optimization.
    
    Needed by a future patch fixing suspend/resume on i915.
    
    Suggested by Rafael.
    
    Signed-off-by: Imre Deak <imre.deak@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index b01bd5bba8e6..563901cd9c06 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2144,7 +2144,8 @@ bool pci_dev_keep_suspended(struct pci_dev *pci_dev)
 
 	if (!pm_runtime_suspended(dev)
 	    || pci_target_state(pci_dev) != pci_dev->current_state
-	    || platform_pci_need_resume(pci_dev))
+	    || platform_pci_need_resume(pci_dev)
+	    || (pci_dev->dev_flags & PCI_DEV_FLAGS_NEEDS_RESUME))
 		return false;
 
 	/*

commit 3134233097791ae64002a51c2c8c9bf2ab200ea0
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Tue Apr 11 17:33:12 2017 +0100

    PCI: Do not disregard parent resources starting at 0x0
    
    Commit f44116ae8818 ("PCI: Remove pci_find_parent_resource() use for
    allocation") updated the logic that iterates over all bus resources and
    compares them to a given resource, in order to decide whether one is the
    parent of the latter.
    
    This change inadvertently causes pci_find_parent_resource() to disregard
    resources starting at address 0x0, resulting in an error such as the one
    below on ARM systems whose I/O window starts at 0x0.
    
      pci_bus 0000:00: root bus resource [mem 0x10000000-0x3efeffff window]
      pci_bus 0000:00: root bus resource [io  0x0000-0xffff window]
      pci_bus 0000:00: root bus resource [mem 0x8000000000-0xffffffffff window]
      pci_bus 0000:00: root bus resource [bus 00-0f]
      pci 0000:00:01.0: PCI bridge to [bus 01]
      pci 0000:00:02.0: PCI bridge to [bus 02]
      pci 0000:00:03.0: PCI bridge to [bus 03]
      pci 0000:00:03.0: can't claim BAR 13 [io  0x0000-0x0fff]: no compatible bridge window
      pci 0000:03:01.0: can't claim BAR 0 [io  0x0000-0x001f]: no compatible bridge window
    
    While this never happens on x86, it is perfectly legal in general for a PCI
    MMIO or IO window to start at address 0x0, and it was supported in the code
    before commit f44116ae8818.
    
    Drop the test for res->start != 0; resource_contains() already checks
    whether [start, end) completely covers the resource, and so it should be
    redundant.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index b01bd5bba8e6..d5575f6b9c62 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -455,7 +455,7 @@ struct resource *pci_find_parent_resource(const struct pci_dev *dev,
 	pci_bus_for_each_resource(bus, r, i) {
 		if (!r)
 			continue;
-		if (res->start && resource_contains(r, res)) {
+		if (resource_contains(r, res)) {
 
 			/*
 			 * If the window is prefetchable but the BAR is

commit ef1b5dad5a386885998d11eb45ca7fd183079965
Merge: 889e4dd916a1 63af8f7a8293
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Apr 28 10:36:12 2017 -0500

    Merge branch 'pci/virtualization' into next
    
    * pci/virtualization:
      ixgbe: Use pcie_flr() instead of duplicating it
      IB/hfi1: Use pcie_flr() instead of duplicating it
      PCI: Call pcie_flr() from reset_chelsio_generic_dev()
      PCI: Call pcie_flr() from reset_intel_82599_sfp_virtfn()
      PCI: Export pcie_flr()
      PCI: Add sysfs sriov_drivers_autoprobe to control VF driver binding
      PCI: Avoid FLR for Intel 82579 NICs
    
    Conflicts:
            include/linux/pci.h

commit 78f098383a7abb1eb9dfd45346773fe80a65f05a
Merge: acc886ec9349 e3adec72a3c5
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Apr 28 10:34:29 2017 -0500

    Merge branch 'pci/resource' into next
    
    * pci/resource:
      PCI: Don't resize resources when realigning all devices in system
      PCI: Don't reassign resources that are already aligned
      PCI: Factor pci_reassigndev_resource_alignment()
      powerpc/powernv: Override pcibios_default_alignment() to force PCI devices to be page aligned
      PCI: Add pcibios_default_alignment() for arch-specific alignment control
      PCI: Fix calculation of bridge window's size and alignment
      PCI: Ignore requested alignment for IOV BARs
      PCI: Make PCI_ROM_ADDRESS_MASK a 32-bit constant

commit acc886ec934980a45ae8962dbe88e221a40c77a2
Merge: c6a7a77cc4e6 ea00353f36b6
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Apr 28 10:34:24 2017 -0500

    Merge branch 'pci/pm' into next
    
    * pci/pm:
      PCI: Freeze PME scan before suspending devices
      PCI/PM: Don't sleep at all when d3_delay or d3cold_delay is zero

commit 0b0ee66c4f4debaaf2f07662ad20a6e89b568c1e
Merge: 27e99676f0f1 bc636ee94501
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Apr 28 10:34:05 2017 -0500

    Merge branch 'pci/ioremap' into next
    
    * pci/ioremap:
      PCI: versatile: Update PCI config space remap function
      PCI: keystone-dw: Update PCI config space remap function
      PCI: layerscape: Update PCI config space remap function
      PCI: hisi: Update PCI config space remap function
      PCI: tegra: Update PCI config space remap function
      PCI: xgene: Update PCI config space remap function
      PCI: armada8k: Update PCI config space remap function
      PCI: designware: Update PCI config space remap function
      PCI: iproc-platform: Update PCI config space remap function
      PCI: qcom: Update PCI config space remap function
      PCI: rockchip: Update PCI config space remap function
      PCI: spear13xx: Update PCI config space remap function
      PCI: xilinx-nwl: Update PCI config space remap function
      PCI: xilinx: Update PCI config space remap function
      PCI: ECAM: Map config region with pci_remap_cfgspace()
      PCI: Implement devm_pci_remap_cfgspace()
      devres: fix devm_ioremap_*() offset parameter kerneldoc description
      ARM: Implement pci_remap_cfgspace() interface
      ARM64: Implement pci_remap_cfgspace() interface
      linux/io.h: Add pci_remap_cfgspace() interface
      PCI: Remove __weak tag from pci_remap_iospace()

commit f503ee4cbef9c5459d9e176542e4d0e0ed3915f6
Merge: d060c6fcef97 9b70ae495174
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Apr 28 10:33:55 2017 -0500

    Merge branch 'pci/enumeration' into next
    
    * pci/enumeration:
      PCI: Include PCI-to-PCIe bridges as "Downstream Ports"
      PCI: Improve __pci_read_base() robustness
      PCI: Short-circuit pci_device_is_present() for disconnected devices
      PCI/MSI: Skip disabling disconnected devices
      PCI: Don't attempt config access to disconnected devices
      PCI: Add device disconnected state
      PCI: Export PCI device config accessors

commit 490cb6ddb17df5ef5f5eb33c9a34f3033b31c204
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Wed Apr 19 17:48:55 2017 +0100

    PCI: Implement devm_pci_remap_cfgspace()
    
    The introduction of the pci_remap_cfgspace() interface allows PCI host
    controller drivers to map PCI config space through a dedicated kernel
    interface. Current PCI host controller drivers use the devm_ioremap_*()
    devres interfaces to map PCI configuration space regions so in order to
    update them to the new pci_remap_cfgspace() mapping interface a new set of
    devres interfaces should be implemented so that PCI host controller drivers
    can make use of them.
    
    Introduce two new functions in the PCI kernel layer and Devres
    documentation:
    
    - devm_pci_remap_cfgspace()
    - devm_pci_remap_cfg_resource()
    
    so that PCI host controller drivers can make use of them to map PCI
    configuration space regions.
    
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Jonathan Corbet <corbet@lwn.net>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index bd98674a0419..4129f9453861 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -3401,6 +3401,88 @@ void pci_unmap_iospace(struct resource *res)
 #endif
 }
 
+/**
+ * devm_pci_remap_cfgspace - Managed pci_remap_cfgspace()
+ * @dev: Generic device to remap IO address for
+ * @offset: Resource address to map
+ * @size: Size of map
+ *
+ * Managed pci_remap_cfgspace().  Map is automatically unmapped on driver
+ * detach.
+ */
+void __iomem *devm_pci_remap_cfgspace(struct device *dev,
+				      resource_size_t offset,
+				      resource_size_t size)
+{
+	void __iomem **ptr, *addr;
+
+	ptr = devres_alloc(devm_ioremap_release, sizeof(*ptr), GFP_KERNEL);
+	if (!ptr)
+		return NULL;
+
+	addr = pci_remap_cfgspace(offset, size);
+	if (addr) {
+		*ptr = addr;
+		devres_add(dev, ptr);
+	} else
+		devres_free(ptr);
+
+	return addr;
+}
+EXPORT_SYMBOL(devm_pci_remap_cfgspace);
+
+/**
+ * devm_pci_remap_cfg_resource - check, request region and ioremap cfg resource
+ * @dev: generic device to handle the resource for
+ * @res: configuration space resource to be handled
+ *
+ * Checks that a resource is a valid memory region, requests the memory
+ * region and ioremaps with pci_remap_cfgspace() API that ensures the
+ * proper PCI configuration space memory attributes are guaranteed.
+ *
+ * All operations are managed and will be undone on driver detach.
+ *
+ * Returns a pointer to the remapped memory or an ERR_PTR() encoded error code
+ * on failure. Usage example:
+ *
+ *	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+ *	base = devm_pci_remap_cfg_resource(&pdev->dev, res);
+ *	if (IS_ERR(base))
+ *		return PTR_ERR(base);
+ */
+void __iomem *devm_pci_remap_cfg_resource(struct device *dev,
+					  struct resource *res)
+{
+	resource_size_t size;
+	const char *name;
+	void __iomem *dest_ptr;
+
+	BUG_ON(!dev);
+
+	if (!res || resource_type(res) != IORESOURCE_MEM) {
+		dev_err(dev, "invalid resource\n");
+		return IOMEM_ERR_PTR(-EINVAL);
+	}
+
+	size = resource_size(res);
+	name = res->name ?: dev_name(dev);
+
+	if (!devm_request_mem_region(dev, res->start, size, name)) {
+		dev_err(dev, "can't request region for resource %pR\n", res);
+		return IOMEM_ERR_PTR(-EBUSY);
+	}
+
+	dest_ptr = devm_pci_remap_cfgspace(dev, res->start, size);
+	if (!dest_ptr) {
+		dev_err(dev, "ioremap failed for resource %pR\n", res);
+		devm_release_mem_region(dev, res->start, size);
+		dest_ptr = IOMEM_ERR_PTR(-ENOMEM);
+	}
+
+	return dest_ptr;
+}
+EXPORT_SYMBOL(devm_pci_remap_cfg_resource);
+
 static void __pci_set_master(struct pci_dev *dev, bool enable)
 {
 	u16 old_cmd, cmd;

commit f90b0875463e450c5dcb714fb887720ecb53a600
Author: Brian Norris <briannorris@chromium.org>
Date:   Thu Mar 9 18:46:16 2017 -0800

    PCI: Export pci_remap_iospace() and pci_unmap_iospace()
    
    These are useful for PCIe host drivers, and those drivers can be modules.
    
    [bhelgaas: don't remove __weak; it's removed elsewhere]
    Signed-off-by: Brian Norris <briannorris@chromium.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Shawn Lin <shawn.lin@rock-chips.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 7904d02ffdb9..c87d1edf0203 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -3383,6 +3383,7 @@ int __weak pci_remap_iospace(const struct resource *res, phys_addr_t phys_addr)
 	return -ENODEV;
 #endif
 }
+EXPORT_SYMBOL(pci_remap_iospace);
 
 /**
  *	pci_unmap_iospace - Unmap the memory mapped I/O space
@@ -3400,6 +3401,7 @@ void pci_unmap_iospace(struct resource *res)
 	unmap_kernel_range(vaddr, resource_size(res));
 #endif
 }
+EXPORT_SYMBOL(pci_unmap_iospace);
 
 static void __pci_set_master(struct pci_dev *dev, bool enable)
 {

commit a60a2b73ba69abca26653fff157b0fd8947bc498
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Apr 14 21:11:25 2017 +0200

    PCI: Export pcie_flr()
    
    Currently we opencode the FLR sequence in lots of place; export a core
    helper instead.  We split out the probing for FLR support as all the
    non-core callers already know their hardware.
    
    Note that in the new pci_has_flr() function the quirk check has been moved
    before the capability check as there is no point in reading the capability
    in this case.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index bef14777bb30..957a11a6a840 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -3773,27 +3773,41 @@ static void pci_flr_wait(struct pci_dev *dev)
 			 (i - 1) * 100);
 }
 
-static int pcie_flr(struct pci_dev *dev, int probe)
+/**
+ * pcie_has_flr - check if a device supports function level resets
+ * @dev:	device to check
+ *
+ * Returns true if the device advertises support for PCIe function level
+ * resets.
+ */
+static bool pcie_has_flr(struct pci_dev *dev)
 {
 	u32 cap;
 
-	pcie_capability_read_dword(dev, PCI_EXP_DEVCAP, &cap);
-	if (!(cap & PCI_EXP_DEVCAP_FLR))
-		return -ENOTTY;
-
 	if (dev->dev_flags & PCI_DEV_FLAGS_NO_FLR_RESET)
-		return -ENOTTY;
+		return false;
 
-	if (probe)
-		return 0;
+	pcie_capability_read_dword(dev, PCI_EXP_DEVCAP, &cap);
+	return cap & PCI_EXP_DEVCAP_FLR;
+}
 
+/**
+ * pcie_flr - initiate a PCIe function level reset
+ * @dev:	device to reset
+ *
+ * Initiate a function level reset on @dev.  The caller should ensure the
+ * device supports FLR before calling this function, e.g. by using the
+ * pcie_has_flr() helper.
+ */
+void pcie_flr(struct pci_dev *dev)
+{
 	if (!pci_wait_for_pending_transaction(dev))
 		dev_err(&dev->dev, "timed out waiting for pending transaction; performing function level reset anyway\n");
 
 	pcie_capability_set_word(dev, PCI_EXP_DEVCTL, PCI_EXP_DEVCTL_BCR_FLR);
 	pci_flr_wait(dev);
-	return 0;
 }
+EXPORT_SYMBOL_GPL(pcie_flr);
 
 static int pci_af_flr(struct pci_dev *dev, int probe)
 {
@@ -3977,9 +3991,12 @@ static int __pci_dev_reset(struct pci_dev *dev, int probe)
 	if (rc != -ENOTTY)
 		goto done;
 
-	rc = pcie_flr(dev, probe);
-	if (rc != -ENOTTY)
+	if (pcie_has_flr(dev)) {
+		if (!probe)
+			pcie_flr(dev);
+		rc = 0;
 		goto done;
+	}
 
 	rc = pci_af_flr(dev, probe);
 	if (rc != -ENOTTY)

commit 7b309aef0463340d3ad5449d1f605d14e10a4225
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Wed Apr 19 17:48:50 2017 +0100

    PCI: Remove __weak tag from pci_remap_iospace()
    
    pci_remap_iospace() is marked as a weak symbol even though no architecture
    is currently overriding it; given that its implementation internals have
    already code paths that are arch specific (ie PCI_IOBASE and
    ioremap_page_range() attributes) there is no need to leave the weak symbol
    in the kernel since the same functionality can be achieved by customizing
    per-arch the corresponding functionality.
    
    Remove the __weak symbol from pci_remap_iospace().
    
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 7904d02ffdb9..bd98674a0419 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -3363,7 +3363,7 @@ unsigned long __weak pci_address_to_pio(phys_addr_t address)
  *	Only architectures that have memory mapped IO functions defined
  *	(and the PCI_IOBASE value defined) should call this function.
  */
-int __weak pci_remap_iospace(const struct resource *res, phys_addr_t phys_addr)
+int pci_remap_iospace(const struct resource *res, phys_addr_t phys_addr)
 {
 #if defined(PCI_IOBASE) && defined(CONFIG_MMU)
 	unsigned long vaddr = (unsigned long)PCI_IOBASE + res->start;

commit e3adec72a3c50b733eb277a9f93c044f59ff55eb
Author: Yongji Xie <elohimes@gmail.com>
Date:   Mon Apr 10 19:58:14 2017 +0800

    PCI: Don't resize resources when realigning all devices in system
    
    The "pci=resource_alignment" argument aligns BARs of designated devices by
    artificially increasing their size.  Increasing the size increases the
    alignment and prevents other resources from being assigned in the same
    alignment region, e.g., in the same page, but it can break drivers that use
    the BAR size to locate things, e.g., ilo_map_device() does this:
    
      off = pci_resource_len(pdev, bar) - 0x2000;
    
    The new pcibios_default_alignment() interface allows an arch to request
    that *all* BARs in the system be aligned to a larger size.  In this case,
    we don't need to artificially increase the resource size because we know
    every BAR of every device will be realigned, so nothing will share the same
    alignment region.
    
    Use IORESOURCE_STARTALIGN to request realignment of PCI BARs when we know
    we're realigning all BARs in the system.
    
    [bhelgaas: comment, changelog]
    Signed-off-by: Yongji Xie <elohimes@gmail.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 7eb6eb384e36..c140cb29ee7e 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -4959,11 +4959,13 @@ static DEFINE_SPINLOCK(resource_alignment_lock);
 /**
  * pci_specified_resource_alignment - get resource alignment specified by user.
  * @dev: the PCI device to get
+ * @resize: whether or not to change resources' size when reassigning alignment
  *
  * RETURNS: Resource alignment if it is specified.
  *          Zero if it is not specified.
  */
-static resource_size_t pci_specified_resource_alignment(struct pci_dev *dev)
+static resource_size_t pci_specified_resource_alignment(struct pci_dev *dev,
+							bool *resize)
 {
 	int seg, bus, slot, func, align_order, count;
 	unsigned short vendor, device, subsystem_vendor, subsystem_device;
@@ -5005,6 +5007,7 @@ static resource_size_t pci_specified_resource_alignment(struct pci_dev *dev)
 				(!device || (device == dev->device)) &&
 				(!subsystem_vendor || (subsystem_vendor == dev->subsystem_vendor)) &&
 				(!subsystem_device || (subsystem_device == dev->subsystem_device))) {
+				*resize = true;
 				if (align_order == -1)
 					align = PAGE_SIZE;
 				else
@@ -5030,6 +5033,7 @@ static resource_size_t pci_specified_resource_alignment(struct pci_dev *dev)
 				bus == dev->bus->number &&
 				slot == PCI_SLOT(dev->devfn) &&
 				func == PCI_FUNC(dev->devfn)) {
+				*resize = true;
 				if (align_order == -1)
 					align = PAGE_SIZE;
 				else
@@ -5050,7 +5054,7 @@ static resource_size_t pci_specified_resource_alignment(struct pci_dev *dev)
 }
 
 static void pci_request_resource_alignment(struct pci_dev *dev, int bar,
-					   resource_size_t align)
+					   resource_size_t align, bool resize)
 {
 	struct resource *r = &dev->resource[bar];
 	resource_size_t size;
@@ -5069,23 +5073,45 @@ static void pci_request_resource_alignment(struct pci_dev *dev, int bar,
 		return;
 
 	/*
-	 * Increase the size of the resource.  BARs are aligned on their
-	 * size, so when we reallocate space for this resource, we'll
-	 * allocate it with the larger alignment.  It also prevents
-	 * assignment of any other BARs inside the size.  If we're
-	 * requesting page alignment, this means no other BARs will share
-	 * the page.
+	 * Increase the alignment of the resource.  There are two ways we
+	 * can do this:
 	 *
-	 * This makes the resource larger than the hardware BAR, which may
-	 * break drivers that compute things based on the resource size,
-	 * e.g., to find registers at a fixed offset before the end of the
-	 * BAR.  We hope users don't request alignment for such devices.
+	 * 1) Increase the size of the resource.  BARs are aligned on their
+	 *    size, so when we reallocate space for this resource, we'll
+	 *    allocate it with the larger alignment.  This also prevents
+	 *    assignment of any other BARs inside the alignment region, so
+	 *    if we're requesting page alignment, this means no other BARs
+	 *    will share the page.
+	 *
+	 *    The disadvantage is that this makes the resource larger than
+	 *    the hardware BAR, which may break drivers that compute things
+	 *    based on the resource size, e.g., to find registers at a
+	 *    fixed offset before the end of the BAR.
+	 *
+	 * 2) Retain the resource size, but use IORESOURCE_STARTALIGN and
+	 *    set r->start to the desired alignment.  By itself this
+	 *    doesn't prevent other BARs being put inside the alignment
+	 *    region, but if we realign *every* resource of every device in
+	 *    the system, none of them will share an alignment region.
+	 *
+	 * When the user has requested alignment for only some devices via
+	 * the "pci=resource_alignment" argument, "resize" is true and we
+	 * use the first method.  Otherwise we assume we're aligning all
+	 * devices and we use the second.
 	 */
+
 	dev_info(&dev->dev, "BAR%d %pR: requesting alignment to %#llx\n",
 		 bar, r, (unsigned long long)align);
 
-	r->start = 0;
-	r->end = align - 1;
+	if (resize) {
+		r->start = 0;
+		r->end = align - 1;
+	} else {
+		r->flags &= ~IORESOURCE_SIZEALIGN;
+		r->flags |= IORESOURCE_STARTALIGN;
+		r->start = align;
+		r->end = r->start + size - 1;
+	}
 	r->flags |= IORESOURCE_UNSET;
 }
 
@@ -5102,6 +5128,7 @@ void pci_reassigndev_resource_alignment(struct pci_dev *dev)
 	struct resource *r;
 	resource_size_t align;
 	u16 command;
+	bool resize = false;
 
 	/*
 	 * VF BARs are read-only zero according to SR-IOV spec r1.1, sec
@@ -5113,7 +5140,7 @@ void pci_reassigndev_resource_alignment(struct pci_dev *dev)
 		return;
 
 	/* check if specified PCI is target device to reassign */
-	align = pci_specified_resource_alignment(dev);
+	align = pci_specified_resource_alignment(dev, &resize);
 	if (!align)
 		return;
 
@@ -5131,7 +5158,7 @@ void pci_reassigndev_resource_alignment(struct pci_dev *dev)
 	pci_write_config_word(dev, PCI_COMMAND, command);
 
 	for (i = 0; i <= PCI_ROM_RESOURCE; i++)
-		pci_request_resource_alignment(dev, i, align);
+		pci_request_resource_alignment(dev, i, align, resize);
 
 	/*
 	 * Need to disable bridge's resource window,

commit 0dde1c08d1b9dea01cefb327dba8a6e3ae795214
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Apr 17 15:20:58 2017 -0500

    PCI: Don't reassign resources that are already aligned
    
    The "pci=resource_alignment=" kernel argument designates devices for which
    we want alignment greater than is required by the PCI specs.  Previously we
    set IORESOURCE_UNSET for every MEM resource of those devices, even if the
    resource was *already* sufficiently aligned.
    
    If a resource is already sufficiently aligned, leave it alone and don't try
    to reassign it.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 1d8bb090a40b..7eb6eb384e36 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -5065,30 +5065,28 @@ static void pci_request_resource_alignment(struct pci_dev *dev, int bar,
 	}
 
 	size = resource_size(r);
-	if (size < align) {
+	if (size >= align)
+		return;
 
-		/*
-		 * Increase the size of the resource.  BARs are aligned on
-		 * their size, so when we reallocate space for this
-		 * resource, we'll allocate it with the larger alignment.
-		 * It also prevents assignment of any other BARs inside the
-		 * size.  If we're requesting page alignment, this means no
-		 * other BARs will share the page.
-		 *
-		 * This makes the resource larger than the hardware BAR,
-		 * which may break drivers that compute things based on the
-		 * resource size, e.g., to find registers at a fixed offset
-		 * before the end of the BAR.  We hope users don't request
-		 * alignment for such devices.
-		 */
-		size = align;
-		dev_info(&dev->dev, "BAR%d %pR: requesting alignment to %#llx\n",
-			 bar, r, (unsigned long long)align);
+	/*
+	 * Increase the size of the resource.  BARs are aligned on their
+	 * size, so when we reallocate space for this resource, we'll
+	 * allocate it with the larger alignment.  It also prevents
+	 * assignment of any other BARs inside the size.  If we're
+	 * requesting page alignment, this means no other BARs will share
+	 * the page.
+	 *
+	 * This makes the resource larger than the hardware BAR, which may
+	 * break drivers that compute things based on the resource size,
+	 * e.g., to find registers at a fixed offset before the end of the
+	 * BAR.  We hope users don't request alignment for such devices.
+	 */
+	dev_info(&dev->dev, "BAR%d %pR: requesting alignment to %#llx\n",
+		 bar, r, (unsigned long long)align);
 
-	}
-	r->flags |= IORESOURCE_UNSET;
-	r->end = size - 1;
 	r->start = 0;
+	r->end = align - 1;
+	r->flags |= IORESOURCE_UNSET;
 }
 
 /*

commit 81a5e70e0de55707c3184d186b2103b5bb9377ec
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Apr 14 14:12:06 2017 -0500

    PCI: Factor pci_reassigndev_resource_alignment()
    
    Pull the BAR size adjustment out into a new function,
    pci_request_resource_alignment(), and add a comment about how and why we
    increase the resource size and alignment.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index d22fb35be26e..1d8bb090a40b 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -5049,6 +5049,48 @@ static resource_size_t pci_specified_resource_alignment(struct pci_dev *dev)
 	return align;
 }
 
+static void pci_request_resource_alignment(struct pci_dev *dev, int bar,
+					   resource_size_t align)
+{
+	struct resource *r = &dev->resource[bar];
+	resource_size_t size;
+
+	if (!(r->flags & IORESOURCE_MEM))
+		return;
+
+	if (r->flags & IORESOURCE_PCI_FIXED) {
+		dev_info(&dev->dev, "BAR%d %pR: ignoring requested alignment %#llx\n",
+			 bar, r, (unsigned long long)align);
+		return;
+	}
+
+	size = resource_size(r);
+	if (size < align) {
+
+		/*
+		 * Increase the size of the resource.  BARs are aligned on
+		 * their size, so when we reallocate space for this
+		 * resource, we'll allocate it with the larger alignment.
+		 * It also prevents assignment of any other BARs inside the
+		 * size.  If we're requesting page alignment, this means no
+		 * other BARs will share the page.
+		 *
+		 * This makes the resource larger than the hardware BAR,
+		 * which may break drivers that compute things based on the
+		 * resource size, e.g., to find registers at a fixed offset
+		 * before the end of the BAR.  We hope users don't request
+		 * alignment for such devices.
+		 */
+		size = align;
+		dev_info(&dev->dev, "BAR%d %pR: requesting alignment to %#llx\n",
+			 bar, r, (unsigned long long)align);
+
+	}
+	r->flags |= IORESOURCE_UNSET;
+	r->end = size - 1;
+	r->start = 0;
+}
+
 /*
  * This function disables memory decoding and releases memory resources
  * of the device specified by kernel's boot parameter 'pci=resource_alignment='.
@@ -5060,7 +5102,7 @@ void pci_reassigndev_resource_alignment(struct pci_dev *dev)
 {
 	int i;
 	struct resource *r;
-	resource_size_t align, size;
+	resource_size_t align;
 	u16 command;
 
 	/*
@@ -5090,28 +5132,11 @@ void pci_reassigndev_resource_alignment(struct pci_dev *dev)
 	command &= ~PCI_COMMAND_MEMORY;
 	pci_write_config_word(dev, PCI_COMMAND, command);
 
-	for (i = 0; i <= PCI_ROM_RESOURCE; i++) {
-		r = &dev->resource[i];
-		if (!(r->flags & IORESOURCE_MEM))
-			continue;
-		if (r->flags & IORESOURCE_PCI_FIXED) {
-			dev_info(&dev->dev, "Ignoring requested alignment for BAR%d: %pR\n",
-				i, r);
-			continue;
-		}
+	for (i = 0; i <= PCI_ROM_RESOURCE; i++)
+		pci_request_resource_alignment(dev, i, align);
 
-		size = resource_size(r);
-		if (size < align) {
-			size = align;
-			dev_info(&dev->dev,
-				"Rounding up size of resource #%d to %#llx.\n",
-				i, (unsigned long long)size);
-		}
-		r->flags |= IORESOURCE_UNSET;
-		r->end = size - 1;
-		r->start = 0;
-	}
-	/* Need to disable bridge's resource window,
+	/*
+	 * Need to disable bridge's resource window,
 	 * to enable the kernel to reassign new resource
 	 * window later on.
 	 */

commit 0a701aa6378496ea54fb065c68b41d918e372e94
Author: Yongji Xie <elohimes@gmail.com>
Date:   Mon Apr 10 19:58:12 2017 +0800

    PCI: Add pcibios_default_alignment() for arch-specific alignment control
    
    When VFIO passes through a PCI device to a guest, it does not allow the
    guest to mmap BARs that are smaller than PAGE_SIZE unless it can reserve
    the rest of the page (see vfio_pci_probe_mmaps()). This is because a page
    might contain several small BARs for unrelated devices and a guest should
    not be able to access all of them.
    
    VFIO emulates guest accesses to non-mappable BARs, which is functional but
    slow. On systems with large page sizes, e.g., PowerNV with 64K pages, BARs
    are more likely to share a page and performance is more likely to be a
    problem.
    
    Add a weak function to set default alignment for all PCI devices.  An arch
    can override it to force the PCI core to place memory BARs on their own
    pages.
    
    Signed-off-by: Yongji Xie <elohimes@gmail.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 679af2a253ad..d22fb35be26e 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -4947,6 +4947,11 @@ void pci_ignore_hotplug(struct pci_dev *dev)
 }
 EXPORT_SYMBOL_GPL(pci_ignore_hotplug);
 
+resource_size_t __weak pcibios_default_alignment(void)
+{
+	return 0;
+}
+
 #define RESOURCE_ALIGNMENT_PARAM_SIZE COMMAND_LINE_SIZE
 static char resource_alignment_param[RESOURCE_ALIGNMENT_PARAM_SIZE] = {0};
 static DEFINE_SPINLOCK(resource_alignment_lock);
@@ -4962,14 +4967,15 @@ static resource_size_t pci_specified_resource_alignment(struct pci_dev *dev)
 {
 	int seg, bus, slot, func, align_order, count;
 	unsigned short vendor, device, subsystem_vendor, subsystem_device;
-	resource_size_t align = 0;
+	resource_size_t align = pcibios_default_alignment();
 	char *p;
 
 	spin_lock(&resource_alignment_lock);
 	p = resource_alignment_param;
-	if (!*p)
+	if (!*p && !align)
 		goto out;
 	if (pci_has_flag(PCI_PROBE_ONLY)) {
+		align = 0;
 		pr_info_once("PCI: Ignoring requested alignments (PCI_PROBE_ONLY)\n");
 		goto out;
 	}

commit ea00353f36b64375518662a8ad15e39218a1f324
Author: Lukas Wunner <lukas@wunner.de>
Date:   Tue Apr 18 20:44:30 2017 +0200

    PCI: Freeze PME scan before suspending devices
    
    Laurent Pinchart reported that the Renesas R-Car H2 Lager board (r8a7790)
    crashes during suspend tests.  Geert Uytterhoeven managed to reproduce the
    issue on an M2-W Koelsch board (r8a7791):
    
      It occurs when the PME scan runs, once per second.  During PME scan, the
      PCI host bridge (rcar-pci) registers are accessed while its module clock
      has already been disabled, leading to the crash.
    
    One reproducer is to configure s2ram to use "s2idle" instead of "deep"
    suspend:
    
      # echo 0 > /sys/module/printk/parameters/console_suspend
      # echo s2idle > /sys/power/mem_sleep
      # echo mem > /sys/power/state
    
    Another reproducer is to write either "platform" or "processors" to
    /sys/power/pm_test.  It does not (or is less likely) to happen during full
    system suspend ("core" or "none") because system suspend also disables
    timers, and thus the workqueue handling PME scans no longer runs.  Geert
    believes the issue may still happen in the small window between disabling
    module clocks and disabling timers:
    
      # echo 0 > /sys/module/printk/parameters/console_suspend
      # echo platform > /sys/power/pm_test    # Or "processors"
      # echo mem > /sys/power/state
    
    (Make sure CONFIG_PCI_RCAR_GEN2 and CONFIG_USB_OHCI_HCD_PCI are enabled.)
    
    Rafael Wysocki agrees that PME scans should be suspended before the host
    bridge registers become inaccessible.  To that end, queue the task on a
    workqueue that gets frozen before devices suspend.
    
    Rafael notes however that as a result, some wakeup events may be missed if
    they are delivered via PME from a device without working IRQ (which hence
    must be polled) and occur after the workqueue has been frozen.  If that
    turns out to be an issue in practice, it may be possible to solve it by
    calling pci_pme_list_scan() once directly from one of the host bridge's
    pm_ops callbacks.
    
    Stacktrace for posterity:
    
      PM: Syncing filesystems ... [   38.566237] done.
      PM: Preparing system for sleep (mem)
      Freezing user space processes ... [   38.579813] (elapsed 0.001 seconds) done.
      Freezing remaining freezable tasks ... (elapsed 0.001 seconds) done.
      PM: Suspending system (mem)
      PM: suspend of devices complete after 152.456 msecs
      PM: late suspend of devices complete after 2.809 msecs
      PM: noirq suspend of devices complete after 29.863 msecs
      suspend debug: Waiting for 5 second(s).
      Unhandled fault: asynchronous external abort (0x1211) at 0x00000000
      pgd = c0003000
      [00000000] *pgd=80000040004003, *pmd=00000000
      Internal error: : 1211 [#1] SMP ARM
      Modules linked in:
      CPU: 1 PID: 20 Comm: kworker/1:1 Not tainted
      4.9.0-rc1-koelsch-00011-g68db9bc814362e7f #3383
      Hardware name: Generic R8A7791 (Flattened Device Tree)
      Workqueue: events pci_pme_list_scan
      task: eb56e140 task.stack: eb58e000
      PC is at pci_generic_config_read+0x64/0x6c
      LR is at rcar_pci_cfg_base+0x64/0x84
      pc : [<c041d7b4>]    lr : [<c04309a0>]    psr: 600d0093
      sp : eb58fe98  ip : c041d750  fp : 00000008
      r10: c0e2283c  r9 : 00000000  r8 : 600d0013
      r7 : 00000008  r6 : eb58fed6  r5 : 00000002  r4 : eb58feb4
      r3 : 00000000  r2 : 00000044  r1 : 00000008  r0 : 00000000
      Flags: nZCv  IRQs off  FIQs on  Mode SVC_32  ISA ARM  Segment user
      Control: 30c5387d  Table: 6a9f6c80  DAC: 55555555
      Process kworker/1:1 (pid: 20, stack limit = 0xeb58e210)
      Stack: (0xeb58fe98 to 0xeb590000)
      fe80:                                                       00000002 00000044
      fea0: eb6f5800 c041d9b0 eb58feb4 00000008 00000044 00000000 eb78a000 eb78a000
      fec0: 00000044 00000000 eb9aff00 c0424bf0 eb78a000 00000000 eb78a000 c0e22830
      fee0: ea8a6fc0 c0424c5c eaae79c0 c0424ce0 eb55f380 c0e22838 eb9a9800 c0235fbc
      ff00: eb55f380 c0e22838 eb55f380 eb9a9800 eb9a9800 eb58e000 eb9a9824 c0e02100
      ff20: eb55f398 c02366c4 eb56e140 eb5631c0 00000000 eb55f380 c023641c 00000000
      ff40: 00000000 00000000 00000000 c023a928 cd105598 00000000 40506a34 eb55f380
      ff60: 00000000 00000000 dead4ead ffffffff ffffffff eb58ff74 eb58ff74 00000000
      ff80: 00000000 dead4ead ffffffff ffffffff eb58ff90 eb58ff90 eb58ffac eb5631c0
      ffa0: c023a844 00000000 00000000 c0206d68 00000000 00000000 00000000 00000000
      ffc0: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
      ffe0: 00000000 00000000 00000000 00000000 00000013 00000000 3a81336c 10ccd1dd
      [<c041d7b4>] (pci_generic_config_read) from [<c041d9b0>]
      (pci_bus_read_config_word+0x58/0x80)
      [<c041d9b0>] (pci_bus_read_config_word) from [<c0424bf0>]
      (pci_check_pme_status+0x34/0x78)
      [<c0424bf0>] (pci_check_pme_status) from [<c0424c5c>] (pci_pme_wakeup+0x28/0x54)
      [<c0424c5c>] (pci_pme_wakeup) from [<c0424ce0>] (pci_pme_list_scan+0x58/0xb4)
      [<c0424ce0>] (pci_pme_list_scan) from [<c0235fbc>]
      (process_one_work+0x1bc/0x308)
      [<c0235fbc>] (process_one_work) from [<c02366c4>] (worker_thread+0x2a8/0x3e0)
      [<c02366c4>] (worker_thread) from [<c023a928>] (kthread+0xe4/0xfc)
      [<c023a928>] (kthread) from [<c0206d68>] (ret_from_fork+0x14/0x2c)
      Code: ea000000 e5903000 f57ff04f e3a00000 (e5843000)
      ---[ end trace 667d43ba3aa9e589 ]---
    
    Fixes: df17e62e5bff ("PCI: Add support for polling PME state on suspended legacy PCI devices")
    Reported-and-tested-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Reported-and-tested-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: stable@vger.kernel.org      # 2.6.37+
    Cc: Mika Westerberg <mika.westerberg@linux.intel.com>
    Cc: Niklas Söderlund <niklas.soderlund+renesas@ragnatech.se>
    Cc: Simon Horman <horms+renesas@verge.net.au>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Matthew Garrett <mjg59@srcf.ucam.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 9779483f81fd..6541cba8eef0 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1784,8 +1784,8 @@ static void pci_pme_list_scan(struct work_struct *work)
 		}
 	}
 	if (!list_empty(&pci_pme_list))
-		schedule_delayed_work(&pci_pme_work,
-				      msecs_to_jiffies(PME_TIMEOUT));
+		queue_delayed_work(system_freezable_wq, &pci_pme_work,
+				   msecs_to_jiffies(PME_TIMEOUT));
 	mutex_unlock(&pci_pme_list_mutex);
 }
 
@@ -1850,8 +1850,9 @@ void pci_pme_active(struct pci_dev *dev, bool enable)
 			mutex_lock(&pci_pme_list_mutex);
 			list_add(&pme_dev->list, &pci_pme_list);
 			if (list_is_singular(&pci_pme_list))
-				schedule_delayed_work(&pci_pme_work,
-						      msecs_to_jiffies(PME_TIMEOUT));
+				queue_delayed_work(system_freezable_wq,
+						   &pci_pme_work,
+						   msecs_to_jiffies(PME_TIMEOUT));
 			mutex_unlock(&pci_pme_list_mutex);
 		} else {
 			mutex_lock(&pci_pme_list_mutex);

commit ea629d873f3e140fb2e3181c30413e485ee9002b
Author: Yongji Xie <xyjxie@linux.vnet.ibm.com>
Date:   Wed Feb 15 14:50:22 2017 +0800

    PCI: Ignore requested alignment for IOV BARs
    
    We would call pci_reassigndev_resource_alignment() before
    pci_init_capabilities().  So the requested alignment would never work for
    IOV BARs.
    
    Furthermore, it's meaningless to request additional alignment for IOV BARs,
    the IOV BAR alignment is only determined by the VF BAR size.
    
    Signed-off-by: Yongji Xie <xyjxie@linux.vnet.ibm.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Gavin Shan <gwshan@linux.vnet.ibm.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 7904d02ffdb9..679af2a253ad 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -5084,7 +5084,7 @@ void pci_reassigndev_resource_alignment(struct pci_dev *dev)
 	command &= ~PCI_COMMAND_MEMORY;
 	pci_write_config_word(dev, PCI_COMMAND, command);
 
-	for (i = 0; i < PCI_BRIDGE_RESOURCES; i++) {
+	for (i = 0; i <= PCI_ROM_RESOURCE; i++) {
 		r = &dev->resource[i];
 		if (!(r->flags & IORESOURCE_MEM))
 			continue;

commit f65fd1aa4f9881d5540192d11f7b8ed2fec936db
Author: Sasha Neftin <sasha.neftin@intel.com>
Date:   Mon Apr 3 16:02:50 2017 -0500

    PCI: Avoid FLR for Intel 82579 NICs
    
    Per Intel Specification Update 335553-002 (see link below), some 82579
    network adapters advertise a Function Level Reset (FLR) capability, but
    they can hang when an FLR is triggered.
    
    To reproduce the problem, attach the device to a VM, then detach and try to
    attach again.
    
    Add a quirk to prevent the use of FLR on these devices.
    
    [bhelgaas: changelog, comments]
    Link: http://www.intel.com/content/dam/www/public/us/en/documents/specification-updates/82579lm-82579v-gigabit-network-connection-spec-update.pdf
    Signed-off-by: Sasha Neftin <sasha.neftin@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 7904d02ffdb9..bef14777bb30 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -3781,6 +3781,9 @@ static int pcie_flr(struct pci_dev *dev, int probe)
 	if (!(cap & PCI_EXP_DEVCAP_FLR))
 		return -ENOTTY;
 
+	if (dev->dev_flags & PCI_DEV_FLAGS_NO_FLR_RESET)
+		return -ENOTTY;
+
 	if (probe)
 		return 0;
 
@@ -3801,6 +3804,9 @@ static int pci_af_flr(struct pci_dev *dev, int probe)
 	if (!pos)
 		return -ENOTTY;
 
+	if (dev->dev_flags & PCI_DEV_FLAGS_NO_FLR_RESET)
+		return -ENOTTY;
+
 	pci_read_config_byte(dev, pos + PCI_AF_CAP, &cap);
 	if (!(cap & PCI_AF_CAP_TP) || !(cap & PCI_AF_CAP_FLR))
 		return -ENOTTY;

commit fe2bd75b2290bf6acd4b91312697e445668dd773
Author: Keith Busch <keith.busch@intel.com>
Date:   Wed Mar 29 22:49:17 2017 -0500

    PCI: Short-circuit pci_device_is_present() for disconnected devices
    
    If the PCI device is disconnected, return false immediately from
    pci_device_is_present().  pci_device_is_present() uses the bus accessors,
    so the early return in the device accessors doesn't help here.
    
    Tested-by: Krishna Dhulipala <krishnad@fb.com>
    Signed-off-by: Keith Busch <keith.busch@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Wei Zhang <wzhang@fb.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 7904d02ffdb9..8ab0a0d3cddb 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -4932,6 +4932,8 @@ bool pci_device_is_present(struct pci_dev *pdev)
 {
 	u32 v;
 
+	if (pci_dev_is_disconnected(pdev))
+		return false;
 	return pci_bus_read_dev_vendor_id(pdev->bus, pdev->devfn, &v, 0);
 }
 EXPORT_SYMBOL_GPL(pci_device_is_present);

commit 50b2b540c00941ced618df9deafccc30826b13b5
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Tue Mar 14 15:21:58 2017 +0200

    PCI/PM: Don't sleep at all when d3_delay or d3cold_delay is zero
    
    msleep() still sleeps 1 jiffy even when told to sleep for zero
    milliseconds.  That can end up being 1-2 milliseconds or more.  In the
    cases of d3_delay and d3cold_delay, that unnecessarily increases suspend
    and/or resume latencies.
    
    Do not sleep at all for the respective cases if d3_delay is zero or
    d3cold_delay is zero.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 7904d02ffdb9..9779483f81fd 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -66,7 +66,8 @@ static void pci_dev_d3_sleep(struct pci_dev *dev)
 	if (delay < pci_pm_d3_delay)
 		delay = pci_pm_d3_delay;
 
-	msleep(delay);
+	if (delay)
+		msleep(delay);
 }
 
 #ifdef CONFIG_PCI_DOMAINS
@@ -827,7 +828,8 @@ static void __pci_start_power_transition(struct pci_dev *dev, pci_power_t state)
 		 * because have already delayed for the bridge.
 		 */
 		if (dev->runtime_d3cold) {
-			msleep(dev->d3cold_delay);
+			if (dev->d3cold_delay)
+				msleep(dev->d3cold_delay);
 			/*
 			 * When powering on a bridge from D3cold, the
 			 * whole hierarchy may be powered on into

commit d98e0929071e7ef63d35c1838b0ad0805ae366dd
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Feb 3 08:53:51 2017 -0600

    Revert "PCI: pciehp: Add runtime PM support for PCIe hotplug ports"
    
    This reverts commit 68db9bc814362e7f24371c27d12a4f34477d9356.
    
    Yinghai reported that the following manual hotplug sequence:
    
      # echo 0 > /sys/bus/pci/slots/8/power
      # echo 1 > /sys/bus/pci/slots/8/power
    
    worked in v4.9, but fails in v4.10-rc1, and that reverting 68db9bc81436
    ("PCI: pciehp: Add runtime PM support for PCIe hotplug ports") makes it
    work again.
    
    Fixes: 68db9bc81436 ("PCI: pciehp: Add runtime PM support for PCIe hotplug ports")
    Link: https://lkml.kernel.org/r/CAE9FiQVCMCa7iVyuwp9z6VrY0cE7V_xghuXip28Ft52=8QmTWw@mail.gmail.com
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=193951
    Reported-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index a881c0d3d2e8..7904d02ffdb9 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2241,10 +2241,13 @@ bool pci_bridge_d3_possible(struct pci_dev *bridge)
 			return false;
 
 		/*
-		 * Hotplug ports handled by firmware in System Management Mode
+		 * Hotplug interrupts cannot be delivered if the link is down,
+		 * so parents of a hotplug port must stay awake. In addition,
+		 * hotplug ports handled by firmware in System Management Mode
 		 * may not be put into D3 by the OS (Thunderbolt on non-Macs).
+		 * For simplicity, disallow in general for now.
 		 */
-		if (bridge->is_hotplug_bridge && !pciehp_is_native(bridge))
+		if (bridge->is_hotplug_bridge)
 			return false;
 
 		if (pci_bridge_d3_force)
@@ -2276,10 +2279,7 @@ static int pci_dev_check_d3cold(struct pci_dev *dev, void *data)
 	     !pci_pme_capable(dev, PCI_D3cold)) ||
 
 	    /* If it is a bridge it must be allowed to go to D3. */
-	    !pci_power_manageable(dev) ||
-
-	    /* Hotplug interrupts cannot be delivered if the link is down. */
-	    dev->is_hotplug_bridge)
+	    !pci_power_manageable(dev))
 
 		*d3cold_ok = false;
 

commit 258315714198c122c819cbeb5fd3fb236cb245b4
Merge: daaed10443da 0b457dde3cf8
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Dec 12 11:25:05 2016 -0600

    Merge branch 'pci/virtualization' into next
    
    * pci/virtualization:
      PCI: Add comments about ROM BAR updating
      PCI: Decouple IORESOURCE_ROM_ENABLE and PCI_ROM_ADDRESS_ENABLE
      PCI: Remove pci_resource_bar() and pci_iov_resource_bar()
      PCI: Don't update VF BARs while VF memory space is enabled
      PCI: Separate VF BAR updates from standard BAR updates
      PCI: Update BARs using property bits appropriate for type
      PCI: Ignore BAR updates on virtual functions
      PCI: Do any VF BAR updates before enabling the BARs
      PCI: Support INTx masking on ConnectX-4 with firmware x.14.1100+
      PCI: Convert Mellanox broken INTx quirks to be for listed devices only
      PCI: Convert broken INTx masking quirks from HEADER to FINAL
      net/mlx4_core: Use device ID defines
      PCI: Add Mellanox device IDs

commit 286c2378aaccc7343ebf17ec6cd86567659caf70
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Nov 28 16:51:19 2016 -0600

    PCI: Remove pci_resource_bar() and pci_iov_resource_bar()
    
    pci_std_update_resource() only deals with standard BARs, so we don't have
    to worry about the complications of VF BARs in an SR-IOV capability.
    
    Compute the BAR address inline and remove pci_resource_bar().  That makes
    pci_iov_resource_bar() unused, so remove that as well.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Gavin Shan <gwshan@linux.vnet.ibm.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 631eac2bed78..ec3f16d13307 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -4827,36 +4827,6 @@ int pci_select_bars(struct pci_dev *dev, unsigned long flags)
 }
 EXPORT_SYMBOL(pci_select_bars);
 
-/**
- * pci_resource_bar - get position of the BAR associated with a resource
- * @dev: the PCI device
- * @resno: the resource number
- * @type: the BAR type to be filled in
- *
- * Returns BAR position in config space, or 0 if the BAR is invalid.
- */
-int pci_resource_bar(struct pci_dev *dev, int resno, enum pci_bar_type *type)
-{
-	int reg;
-
-	if (resno < PCI_ROM_RESOURCE) {
-		*type = pci_bar_unknown;
-		return PCI_BASE_ADDRESS_0 + 4 * resno;
-	} else if (resno == PCI_ROM_RESOURCE) {
-		*type = pci_bar_mem32;
-		return dev->rom_base_reg;
-	} else if (resno < PCI_BRIDGE_RESOURCES) {
-		/* device specific resource */
-		*type = pci_bar_unknown;
-		reg = pci_iov_resource_bar(dev, resno);
-		if (reg)
-			return reg;
-	}
-
-	dev_err(&dev->dev, "BAR %d: invalid resource\n", resno);
-	return 0;
-}
-
 /* Some architectures require additional programming to enable VGA */
 static arch_set_vga_state_t arch_set_vga_state;
 

commit 63880b230a4af502c56dde3d4588634c70c66006
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Nov 28 11:19:27 2016 -0600

    PCI: Ignore BAR updates on virtual functions
    
    VF BARs are read-only zero, so updating VF BARs will not have any effect.
    See the SR-IOV spec r1.1, sec 3.4.1.11.
    
    We already ignore these updates because of 70675e0b6a1a ("PCI: Don't try to
    restore VF BARs"); this merely restructures it slightly to make it easier
    to split updates for standard and SR-IOV BARs.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Gavin Shan <gwshan@linux.vnet.ibm.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index ba34907538f6..631eac2bed78 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -564,10 +564,6 @@ static void pci_restore_bars(struct pci_dev *dev)
 {
 	int i;
 
-	/* Per SR-IOV spec 3.4.1.11, VF BARs are RO zero */
-	if (dev->is_virtfn)
-		return;
-
 	for (i = 0; i < PCI_BRIDGE_RESOURCES; i++)
 		pci_update_resource(dev, i);
 }

commit 68db9bc814362e7f24371c27d12a4f34477d9356
Author: Lukas Wunner <lukas@wunner.de>
Date:   Fri Oct 28 10:52:06 2016 +0200

    PCI: pciehp: Add runtime PM support for PCIe hotplug ports
    
    Linux 4.8 added support for runtime suspending PCIe ports to D3hot with
    commit 006d44e49a25 ("PCI: Add runtime PM support for PCIe ports"), but
    excluded hotplug ports.  Those are now afforded runtime PM by the present
    commit.
    
    Hotplug ports require a few extra considerations:
    
    - The configuration space of the port remains accessible in D3hot, so all
      the functions to read or modify the Slot Status and Slot Control
      registers need not be modified.  Even turning on slot power doesn't seem
      to require the port to be in D0, at least the PCIe spec doesn't say so
      and I confirmed that by testing with a Thunderbolt controller.
    
    - However D0 is required to access devices on the secondary bus.  This
      happens in pciehp_check_link_status() and pciehp_configure_device() (both
      called from board_added()) and in pciehp_unconfigure_device() (called
      from remove_board()), so acquire a runtime PM ref for their invocation.
    
    - The hotplug port stays active as long as it has active children.  If all
      hotplugged devices below the port runtime suspend, the port is allowed to
      runtime suspend as well.  Plug and unplug detection continues to work in
      D3hot.
    
    - Hotplug interrupts are delivered in-band, so while the hotplug port
      itself is allowed to go to D3hot, its parent ports must stay in D0 for
      interrupts to come through.  Add a corresponding restriction to
      pci_dev_check_d3cold().
    
    - Runtime PM may only be allowed if the hotplug port is handled natively by
      the OS.  On ACPI systems, the port may alternatively be handled by the
      firmware and things break if the OS puts the port into D3 behind the
      firmware's back:  E.g. Thunderbolt hotplug ports on non-Macs are handled
      by Intel's firmware in System Management Mode and the firmware is known
      to access devices on the port's secondary bus without checking first if
      the port is in D0: https://bugzilla.kernel.org/show_bug.cgi?id=53811
    
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    CC: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index d86351a2fe6e..1eb622cc8645 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2245,13 +2245,10 @@ bool pci_bridge_d3_possible(struct pci_dev *bridge)
 			return false;
 
 		/*
-		 * Hotplug interrupts cannot be delivered if the link is down,
-		 * so parents of a hotplug port must stay awake. In addition,
-		 * hotplug ports handled by firmware in System Management Mode
+		 * Hotplug ports handled by firmware in System Management Mode
 		 * may not be put into D3 by the OS (Thunderbolt on non-Macs).
-		 * For simplicity, disallow in general for now.
 		 */
-		if (bridge->is_hotplug_bridge)
+		if (bridge->is_hotplug_bridge && !pciehp_is_native(bridge))
 			return false;
 
 		if (pci_bridge_d3_force)
@@ -2283,7 +2280,10 @@ static int pci_dev_check_d3cold(struct pci_dev *dev, void *data)
 	     !pci_pme_capable(dev, PCI_D3cold)) ||
 
 	    /* If it is a bridge it must be allowed to go to D3. */
-	    !pci_power_manageable(dev))
+	    !pci_power_manageable(dev) ||
+
+	    /* Hotplug interrupts cannot be delivered if the link is down. */
+	    dev->is_hotplug_bridge)
 
 		*d3cold_ok = false;
 

commit 718a0609ae263b291848ecd0fa88bcf15ad49280
Author: Lukas Wunner <lukas@wunner.de>
Date:   Fri Oct 28 10:52:06 2016 +0200

    PCI: Unfold conditions to block runtime PM on PCIe ports
    
    The conditions to block D3 on parent ports are currently condensed into a
    single expression in pci_dev_check_d3cold().  Upcoming commits will add
    further conditions for hotplug ports, making this expression fairly large
    and impenetrable.  Unfold the conditions to maintain readability when they
    are amended.
    
    No functional change intended.
    
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    CC: Mika Westerberg <mika.westerberg@linux.intel.com>
    CC: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index a40ba0225265..d86351a2fe6e 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2274,19 +2274,20 @@ bool pci_bridge_d3_possible(struct pci_dev *bridge)
 static int pci_dev_check_d3cold(struct pci_dev *dev, void *data)
 {
 	bool *d3cold_ok = data;
-	bool no_d3cold;
 
-	/*
-	 * The device needs to be allowed to go D3cold and if it is wake
-	 * capable to do so from D3cold.
-	 */
-	no_d3cold = dev->no_d3cold || !dev->d3cold_allowed ||
-		(device_may_wakeup(&dev->dev) && !pci_pme_capable(dev, PCI_D3cold)) ||
-		!pci_power_manageable(dev);
+	if (/* The device needs to be allowed to go D3cold ... */
+	    dev->no_d3cold || !dev->d3cold_allowed ||
+
+	    /* ... and if it is wakeup capable to do so from D3cold. */
+	    (device_may_wakeup(&dev->dev) &&
+	     !pci_pme_capable(dev, PCI_D3cold)) ||
+
+	    /* If it is a bridge it must be allowed to go to D3. */
+	    !pci_power_manageable(dev))
 
-	*d3cold_ok = !no_d3cold;
+		*d3cold_ok = false;
 
-	return no_d3cold;
+	return !*d3cold_ok;
 }
 
 /*

commit 97a90aee5dab33aea0cd3f6802b3661990496262
Author: Lukas Wunner <lukas@wunner.de>
Date:   Fri Oct 28 10:52:06 2016 +0200

    PCI: Consolidate conditions to allow runtime PM on PCIe ports
    
    The conditions to allow runtime PM on PCIe ports are currently spread
    across two different files:  The condition relating to hotplug ports is
    located in portdrv_pci.c whereas all other conditions are located in pci.c.
    
    Consolidate all conditions in a single place in pci.c, thus making it
    easier to follow the logic and amend conditions down the road.
    
    Note that the condition relating to hotplug ports is inserted *before* the
    condition relating to the "pcie_port_pm=force" command line option, so
    runtime PM is not afforded to hotplug ports even if this option is given.
    That's exactly how the code behaved up until now.  If this is not desired,
    the ordering of the conditions can simply be reversed.
    
    No functional change intended.
    
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 720f7e27c3a8..a40ba0225265 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2243,6 +2243,17 @@ bool pci_bridge_d3_possible(struct pci_dev *bridge)
 	case PCI_EXP_TYPE_DOWNSTREAM:
 		if (pci_bridge_d3_disable)
 			return false;
+
+		/*
+		 * Hotplug interrupts cannot be delivered if the link is down,
+		 * so parents of a hotplug port must stay awake. In addition,
+		 * hotplug ports handled by firmware in System Management Mode
+		 * may not be put into D3 by the OS (Thunderbolt on non-Macs).
+		 * For simplicity, disallow in general for now.
+		 */
+		if (bridge->is_hotplug_bridge)
+			return false;
+
 		if (pci_bridge_d3_force)
 			return true;
 

commit c6a6330706148e7d5265c3dd658d25843c83390f
Author: Lukas Wunner <lukas@wunner.de>
Date:   Fri Oct 28 10:52:06 2016 +0200

    PCI: Activate runtime PM on a PCIe port only if it can suspend
    
    Currently pcie_portdrv_probe() activates runtime PM on a PCIe port even
    if it will never actually suspend because the BIOS is too old or the
    "pcie_port_pm=off" option was specified on the kernel command line.
    
    A few CPU cycles can be saved by not activating runtime PM at all in these
    cases, because rpm_idle() and rpm_suspend() will bail out right at the
    beginning when calling rpm_check_suspend_allowed(), instead of carrying out
    various locking and assignments, invoking rpm_callback(), getting back
    -EBUSY and rolling everything back.
    
    The conditions checked in pci_bridge_d3_possible() are all static, they
    never change during uptime of the system, hence it's safe to call this to
    determine if runtime PM should be activated.
    
    No functional change intended.
    
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 4a7f6f54d669..720f7e27c3a8 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2230,7 +2230,7 @@ void pci_config_pm_runtime_put(struct pci_dev *pdev)
  * This function checks if it is possible to move the bridge to D3.
  * Currently we only allow D3 for recent enough PCIe ports.
  */
-static bool pci_bridge_d3_possible(struct pci_dev *bridge)
+bool pci_bridge_d3_possible(struct pci_dev *bridge)
 {
 	unsigned int year;
 

commit e8559b7100324494acbde6e26bcdc6a5a5b4a4ed
Author: Lukas Wunner <lukas@wunner.de>
Date:   Fri Oct 28 10:52:06 2016 +0200

    PCI: Speed up algorithm in pci_bridge_d3_update()
    
    After a device has been added, removed or had its D3cold attributes
    changed, we recheck whether its parent bridge may runtime suspend to D3hot
    with pci_bridge_d3_update().
    
    The most naive algorithm would be to iterate over the bridge's children and
    check if any of them are blocking D3.
    
    The function already tries to be a bit smarter than that by first checking
    the device that was changed.  If this device already blocks D3 on the
    bridge, then walking over all the other children can be skipped.  A
    drawback of this approach is that if the device is *not* blocking D3, it
    will be checked a second time by pci_walk_bus().  But that's cheap and is
    outweighed by the performance gain of potentially skipping pci_walk_bus()
    altogether.
    
    The algorithm can be optimized further by taking into account if D3 is
    currently allowed for the bridge, as shown in the following truth table:
    
    (a)  remove &&  bridge_d3:  D3 is currently allowed for the bridge and
                                removing one of its children won't change
                                that.  No action necessary.
    (b)  remove && !bridge_d3:  D3 may now be allowed for the bridge if the
                                removed child was the only one blocking it.
                                Check all its siblings to verify that.
    (c) !remove &&  bridge_d3:  D3 may now be disallowed but this can only
                                be caused by the added/changed child, not
                                any of its siblings.  Check only that single
                                device.
    (d) !remove && !bridge_d3:  D3 may now be allowed for the bridge if the
                                changed child was the only one blocking it.
                                Check all its siblings to verify that.
                                By checking beforehand if the changed child
                                is blocking D3, we may be able to skip
                                checking its siblings.
    
    Currently we do not special-case option (a) and in case of option (c) we
    gratuitously call pci_walk_bus().  Speed up the algorithm by adding these
    optimizations.  Reword the comments a bit in an attempt to improve clarity.
    
    No functional change intended.
    
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 8200874ef5fc..4a7f6f54d669 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2297,20 +2297,32 @@ void pci_bridge_d3_update(struct pci_dev *dev)
 		return;
 
 	/*
-	 * If the device is removed we do not care about its D3cold
-	 * capabilities.
+	 * If D3 is currently allowed for the bridge, removing one of its
+	 * children won't change that.
+	 */
+	if (remove && bridge->bridge_d3)
+		return;
+
+	/*
+	 * If D3 is currently allowed for the bridge and a child is added or
+	 * changed, disallowance of D3 can only be caused by that child, so
+	 * we only need to check that single device, not any of its siblings.
+	 *
+	 * If D3 is currently not allowed for the bridge, checking the device
+	 * first may allow us to skip checking its siblings.
 	 */
 	if (!remove)
 		pci_dev_check_d3cold(dev, &d3cold_ok);
 
-	if (d3cold_ok) {
-		/*
-		 * We need to go through all children to find out if all of
-		 * them can still go to D3cold.
-		 */
+	/*
+	 * If D3 is currently not allowed for the bridge, this may be caused
+	 * either by the device being changed/removed or any of its siblings,
+	 * so we need to go through all children to find out if one of them
+	 * continues to block D3.
+	 */
+	if (d3cold_ok && !bridge->bridge_d3)
 		pci_walk_bus(bridge->subordinate, pci_dev_check_d3cold,
 			     &d3cold_ok);
-	}
 
 	if (bridge->bridge_d3 != d3cold_ok) {
 		bridge->bridge_d3 = d3cold_ok;

commit 1ed276a7b9d84626e5243fc54863440c74a4100a
Author: Lukas Wunner <lukas@wunner.de>
Date:   Fri Oct 28 10:52:06 2016 +0200

    PCI: Autosense device removal in pci_bridge_d3_update()
    
    The algorithm to update the flag indicating whether a bridge may go to D3
    makes a few optimizations based on whether the update was caused by the
    removal of a device on the one hand, versus the addition of a device or the
    change of its D3cold flags on the other hand.
    
    The information whether the update pertains to a removal is currently
    passed in by the caller, but the function may as well determine that itself
    by examining the device in question, thereby allowing for a considerable
    simplification and reduction of the code.
    
    Out of several options to determine removal, I've chosen the function
    device_is_registered() because it's cheap:  It merely returns the
    dev->kobj.state_in_sysfs flag.  That flag is set through device_add() when
    the root bus is scanned and cleared through device_remove().  The call to
    pci_bridge_d3_update() happens after each of these calls, respectively, so
    the ordering is correct.
    
    No functional change intended.
    
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 5d6f2970fd6f..8200874ef5fc 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2281,14 +2281,14 @@ static int pci_dev_check_d3cold(struct pci_dev *dev, void *data)
 /*
  * pci_bridge_d3_update - Update bridge D3 capabilities
  * @dev: PCI device which is changed
- * @remove: Is the device being removed
  *
  * Update upstream bridge PM capabilities accordingly depending on if the
  * device PM configuration was changed or the device is being removed.  The
  * change is also propagated upstream.
  */
-static void pci_bridge_d3_update(struct pci_dev *dev, bool remove)
+void pci_bridge_d3_update(struct pci_dev *dev)
 {
+	bool remove = !device_is_registered(&dev->dev);
 	struct pci_dev *bridge;
 	bool d3cold_ok = true;
 
@@ -2315,35 +2315,10 @@ static void pci_bridge_d3_update(struct pci_dev *dev, bool remove)
 	if (bridge->bridge_d3 != d3cold_ok) {
 		bridge->bridge_d3 = d3cold_ok;
 		/* Propagate change to upstream bridges */
-		pci_bridge_d3_update(bridge, false);
+		pci_bridge_d3_update(bridge);
 	}
 }
 
-/**
- * pci_bridge_d3_device_changed - Update bridge D3 capabilities on change
- * @dev: PCI device that was changed
- *
- * If a device is added or its PM configuration, such as is it allowed to
- * enter D3cold, is changed this function updates upstream bridge PM
- * capabilities accordingly.
- */
-void pci_bridge_d3_device_changed(struct pci_dev *dev)
-{
-	pci_bridge_d3_update(dev, false);
-}
-
-/**
- * pci_bridge_d3_device_removed - Update bridge D3 capabilities on remove
- * @dev: PCI device being removed
- *
- * Function updates upstream bridge PM capabilities based on other devices
- * still left on the bus.
- */
-void pci_bridge_d3_device_removed(struct pci_dev *dev)
-{
-	pci_bridge_d3_update(dev, true);
-}
-
 /**
  * pci_d3cold_enable - Enable D3cold for device
  * @dev: PCI device to handle
@@ -2356,7 +2331,7 @@ void pci_d3cold_enable(struct pci_dev *dev)
 {
 	if (dev->no_d3cold) {
 		dev->no_d3cold = false;
-		pci_bridge_d3_device_changed(dev);
+		pci_bridge_d3_update(dev);
 	}
 }
 EXPORT_SYMBOL_GPL(pci_d3cold_enable);
@@ -2373,7 +2348,7 @@ void pci_d3cold_disable(struct pci_dev *dev)
 {
 	if (!dev->no_d3cold) {
 		dev->no_d3cold = true;
-		pci_bridge_d3_device_changed(dev);
+		pci_bridge_d3_update(dev);
 	}
 }
 EXPORT_SYMBOL_GPL(pci_d3cold_disable);

commit 738a7edbfc7b623e276686dead046c9f3aae6b2e
Author: Lukas Wunner <lukas@wunner.de>
Date:   Fri Oct 28 10:52:06 2016 +0200

    PCI: Don't acquire ref on parent in pci_bridge_d3_update()
    
    This function is always called with an existing pci_dev struct, which
    holds a reference on the pci_bus struct it resides on, which in turn
    holds a reference on pci_bus->bridge, which is the pci_dev's parent.
    
    Hence there's no need to acquire an additional ref on the parent.
    
    More specifically, the pci_dev exists until pci_destroy_dev() drops the
    final reference on it, so all calls to pci_bridge_d3_update() must be
    finished before that.  It is arguably the caller's responsibility to ensure
    that it doesn't call pci_bridge_d3_update() with a pci_dev that might
    suddenly disappear, but in any case the existing callers are all safe:
    
    - The call in pci_destroy_dev() happens before the call to put_device().
    - The call in pci_bus_add_device() is synchronized with pci_destroy_dev()
      using pci_lock_rescan_remove().
    - The calls to pci_d3cold_disable() from the xhci and nouveau drivers
      are safe because a ref on the pci_dev is held as long as it's bound to
      a driver.
    - The calls to pci_d3cold_enable() / pci_d3cold_disable() when modifying
      the sysfs "d3cold_allowed" entry are also safe because kernfs_drain()
      waits for existing sysfs users to finish before removing the entry,
      and pci_destroy_dev() is called way after that.
    
    No functional change intended.
    
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index eda6a7cf0e54..5d6f2970fd6f 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2296,7 +2296,6 @@ static void pci_bridge_d3_update(struct pci_dev *dev, bool remove)
 	if (!bridge || !pci_bridge_d3_possible(bridge))
 		return;
 
-	pci_dev_get(bridge);
 	/*
 	 * If the device is removed we do not care about its D3cold
 	 * capabilities.
@@ -2318,8 +2317,6 @@ static void pci_bridge_d3_update(struct pci_dev *dev, bool remove)
 		/* Propagate change to upstream bridges */
 		pci_bridge_d3_update(bridge, false);
 	}
-
-	pci_dev_put(bridge);
 }
 
 /**

commit 6496ebd7edf446fccf8266a1a70ffcb64252593e
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Oct 21 16:45:38 2016 -0400

    PCI: Check for PME in targeted sleep state
    
    One some systems, the firmware does not allow certain PCI devices to be put
    in deep D-states.  This can cause problems for wakeup signalling, if the
    device does not support PME# in the deepest allowed suspend state.  For
    example, Pierre reports that on his system, ACPI does not permit his xHCI
    host controller to go into D3 during runtime suspend -- but D3 is the only
    state in which the controller can generate PME# signals.  As a result, the
    controller goes into runtime suspend but never wakes up, so it doesn't work
    properly.  USB devices plugged into the controller are never detected.
    
    If the device relies on PME# for wakeup signals but is not capable of
    generating PME# in the target state, the PCI core should accurately report
    that it cannot do wakeup from runtime suspend.  This patch modifies the
    pci_dev_run_wake() routine to add this check.
    
    Reported-by: Pierre de Villemereuil <flyos@mailoo.org>
    Tested-by: Pierre de Villemereuil <flyos@mailoo.org>
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    CC: stable@vger.kernel.org
    CC: Lukas Wunner <lukas@wunner.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index ba34907538f6..eda6a7cf0e54 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2106,6 +2106,10 @@ bool pci_dev_run_wake(struct pci_dev *dev)
 	if (!dev->pme_support)
 		return false;
 
+	/* PME-capable in principle, but not from the intended sleep state */
+	if (!pci_pme_capable(dev, pci_target_state(dev)))
+		return false;
+
 	while (bus->parent) {
 		struct pci_dev *bridge = bus->self;
 

commit e6e3d8f8f4f06caf25004c749bb2ba84f18c7d39
Merge: fbbea3899014 bdf530984d10
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Oct 7 11:46:37 2016 -0700

    Merge tag 'pci-v4.9-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI updates from Bjorn Helgaas:
     "Summary of PCI changes for the v4.9 merge window:
    
      Enumeration:
       - microblaze: Add multidomain support for procfs (Bharat Kumar Gogada)
    
      Resource management:
       - Ignore requested alignment for PROBE_ONLY and fixed resources (Yongji Xie)
       - Ignore requested alignment for VF BARs (Yongji Xie)
    
      PCI device hotplug:
       - Make core explicitly non-modular (Paul Gortmaker)
    
      PCIe native device hotplug:
       - Rename pcie_isr() locals for clarity (Bjorn Helgaas)
       - Return IRQ_NONE when we can't read interrupt status (Bjorn Helgaas)
       - Remove unnecessary guard (Bjorn Helgaas)
       - Clean up dmesg "Slot(%s)" messages (Bjorn Helgaas)
       - Remove useless pciehp_get_latch_status() calls (Bjorn Helgaas)
       - Clear attention LED on device add (Keith Busch)
       - Allow exclusive userspace control of indicators (Keith Busch)
       - Process all hotplug events before looking for new ones (Mayurkumar Patel)
       - Don't re-read Slot Status when queuing hotplug event (Mayurkumar Patel)
       - Don't re-read Slot Status when handling surprise event (Mayurkumar Patel)
       - Make explicitly non-modular (Paul Gortmaker)
    
      Power management:
       - Afford direct-complete to devices with non-standard PM (Lukas Wunner)
       - Query platform firmware for device power state (Lukas Wunner)
       - Recognize D3cold in pci_update_current_state() (Lukas Wunner)
       - Avoid unnecessary resume after direct-complete (Lukas Wunner)
       - Make explicitly non-modular (Paul Gortmaker)
    
      Virtualization:
       - Mark Atheros AR9580 to avoid bus reset (Maik Broemme)
       - Check for pci_setup_device() failure in pci_iov_add_virtfn() (Po Liu)
    
      MSI:
       - Enable PCI_MSI_IRQ_DOMAIN support for ARC (Joao Pinto)
    
      AER:
       - Remove aerdriver.nosourceid kernel parameter (Bjorn Helgaas)
       - Remove aerdriver.forceload kernel parameter (Bjorn Helgaas)
       - Fix aer_probe() kernel-doc comment (Cao jin)
       - Add bus flag to skip source ID matching (Jon Derrick)
       - Avoid memory allocation in interrupt handling path (Jon Derrick)
       - Cache capability position (Keith Busch)
       - Make explicitly non-modular (Paul Gortmaker)
       - Remove duplicate AER severity translation (Tyler Baicar)
       - Send correct severity to calculate AER severity (Tyler Baicar)
    
      Precision Time Measurement:
       - Add Precision Time Measurement (PTM) support (Jonathan Yong)
       - Add PTM clock granularity information (Bjorn Helgaas)
       - Add pci_enable_ptm() for drivers to enable PTM on endpoints (Bjorn Helgaas)
    
      Generic host bridge driver:
       - Fix pci_remap_iospace() failure path (Lorenzo Pieralisi)
       - Make explicitly non-modular (Paul Gortmaker)
    
      Altera host bridge driver:
       - Remove redundant platform_get_resource() return value check (Bjorn Helgaas)
       - Poll for link training status after retraining the link (Ley Foon Tan)
       - Rework config accessors for use without a struct pci_bus (Ley Foon Tan)
       - Move retrain from fixup to altera_pcie_host_init() (Ley Foon Tan)
       - Make MSI explicitly non-modular (Paul Gortmaker)
       - Make explicitly non-modular (Paul Gortmaker)
       - Relax device number checking to allow SR-IOV (Po Liu)
    
      ARM Versatile host bridge driver:
       - Fix pci_remap_iospace() failure path (Lorenzo Pieralisi)
    
      Axis ARTPEC-6 host bridge driver:
       - Drop __init from artpec6_add_pcie_port() (Niklas Cassel)
    
      Freescale i.MX6 host bridge driver:
       - Make explicitly non-modular (Paul Gortmaker)
    
      Intel VMD host bridge driver:
       - Add quirk for AER to ignore source ID (Jon Derrick)
       - Allocate IRQ lists with correct MSI-X count (Jon Derrick)
       - Convert to use pci_alloc_irq_vectors() API (Jon Derrick)
       - Eliminate vmd_vector member from list type (Jon Derrick)
       - Eliminate index member from IRQ list (Jon Derrick)
       - Synchronize with RCU freeing MSI IRQ descs (Keith Busch)
       - Request userspace control of PCIe hotplug indicators (Keith Busch)
       - Move VMD driver to drivers/pci/host (Keith Busch)
    
      Marvell Aardvark host bridge driver:
       - Fix pci_remap_iospace() failure path (Lorenzo Pieralisi)
       - Remove redundant dev_err call in advk_pcie_probe() (Wei Yongjun)
    
      Microsoft Hyper-V host bridge driver:
       - Use zero-length array in struct pci_packet (Dexuan Cui)
       - Use pci_function_description[0] in struct definitions (Dexuan Cui)
       - Remove the unused 'wrk' in struct hv_pcibus_device (Dexuan Cui)
       - Handle vmbus_sendpacket() failure in hv_compose_msi_msg() (Dexuan Cui)
       - Handle hv_pci_generic_compl() error case (Dexuan Cui)
       - Use list_move_tail() instead of list_del() + list_add_tail() (Wei Yongjun)
    
      NVIDIA Tegra host bridge driver:
       - Fix pci_remap_iospace() failure path (Lorenzo Pieralisi)
       - Remove redundant _data suffix (Thierry Reding)
       - Use of_device_get_match_data() (Thierry Reding)
    
      Qualcomm host bridge driver:
       - Make explicitly non-modular (Paul Gortmaker)
    
      Renesas R-Car host bridge driver:
       - Consolidate register space lookup and ioremap (Bjorn Helgaas)
       - Don't disable/unprepare clocks on prepare/enable failure (Geert Uytterhoeven)
       - Add multi-MSI support (Grigory Kletsko)
       - Fix pci_remap_iospace() failure path (Lorenzo Pieralisi)
       - Fix some checkpatch warnings (Sergei Shtylyov)
       - Try increasing PCIe link speed to 5 GT/s at boot (Sergei Shtylyov)
    
      Rockchip host bridge driver:
       - Add DT bindings for Rockchip PCIe controller (Shawn Lin)
       - Add Rockchip PCIe controller support (Shawn Lin)
       - Improve the deassert sequence of four reset pins (Shawn Lin)
       - Fix wrong transmitted FTS count (Shawn Lin)
       - Increase the Max Credit update interval (Rajat Jain)
    
      Samsung Exynos host bridge driver:
       - Make explicitly non-modular (Paul Gortmaker)
    
      ST Microelectronics SPEAr13xx host bridge driver:
       - Make explicitly non-modular (Paul Gortmaker)
    
      Synopsys DesignWare host bridge driver:
       - Return data directly from dw_pcie_readl_rc() (Bjorn Helgaas)
       - Exchange viewport of `MEMORYs' and `CFGs/IOs' (Dong Bo)
       - Check LTSSM training bit before deciding link is up (Jisheng Zhang)
       - Move link wait definitions to .c file (Joao Pinto)
       - Wait for iATU enable (Joao Pinto)
       - Add iATU Unroll feature (Joao Pinto)
       - Fix pci_remap_iospace() failure path (Lorenzo Pieralisi)
       - Make explicitly non-modular (Paul Gortmaker)
       - Relax device number checking to allow SR-IOV (Po Liu)
       - Keep viewport fixed for IO transaction if num_viewport > 2 (Pratyush Anand)
       - Remove redundant platform_get_resource() return value check (Wei Yongjun)
    
      TI DRA7xx host bridge driver:
       - Make explicitly non-modular (Paul Gortmaker)
    
      TI Keystone host bridge driver:
       - Propagate request_irq() failure (Wei Yongjun)
    
      Xilinx AXI host bridge driver:
       - Keep both legacy and MSI interrupt domain references (Bharat Kumar Gogada)
       - Clear interrupt register for invalid interrupt (Bharat Kumar Gogada)
       - Clear correct MSI set bit (Bharat Kumar Gogada)
       - Dispose of MSI virtual IRQ (Bharat Kumar Gogada)
       - Make explicitly non-modular (Paul Gortmaker)
       - Relax device number checking to allow SR-IOV (Po Liu)
    
      Xilinx NWL host bridge driver:
       - Expand error logging (Bharat Kumar Gogada)
       - Enable all MSI interrupts using MSI mask (Bharat Kumar Gogada)
       - Make explicitly non-modular (Paul Gortmaker)
    
      Miscellaneous:
       - Drop CONFIG_KEXEC_CORE ifdeffery (Lukas Wunner)
       - portdrv: Make explicitly non-modular (Paul Gortmaker)
       - Make DPC explicitly non-modular (Paul Gortmaker)"
    
    * tag 'pci-v4.9-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (105 commits)
      x86/PCI: VMD: Move VMD driver to drivers/pci/host
      PCI: rockchip: Fix wrong transmitted FTS count
      PCI: rockchip: Improve the deassert sequence of four reset pins
      PCI: rockchip: Increase the Max Credit update interval
      PCI: rcar: Try increasing PCIe link speed to 5 GT/s at boot
      PCI/AER: Fix aer_probe() kernel-doc comment
      PCI: Ignore requested alignment for VF BARs
      PCI: Ignore requested alignment for PROBE_ONLY and fixed resources
      PCI: Avoid unnecessary resume after direct-complete
      PCI: Recognize D3cold in pci_update_current_state()
      PCI: Query platform firmware for device power state
      PCI: Afford direct-complete to devices with non-standard PM
      PCI/AER: Cache capability position
      PCI/AER: Avoid memory allocation in interrupt handling path
      x86/PCI: VMD: Request userspace control of PCIe hotplug indicators
      PCI: pciehp: Allow exclusive userspace control of indicators
      ACPI / APEI: Send correct severity to calculate AER severity
      PCI/AER: Remove duplicate AER severity translation
      x86/PCI: VMD: Synchronize with RCU freeing MSI IRQ descs
      x86/PCI: VMD: Eliminate index member from IRQ list
      ...

commit e15194d2a726b7201878d17ee87fa80d89aaabf4
Merge: 3f4f35678fb8 62d9a78f32d9
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Oct 3 09:43:21 2016 -0500

    Merge branch 'pci/resource' into next
    
    * pci/resource:
      PCI: Ignore requested alignment for VF BARs
      PCI: Ignore requested alignment for PROBE_ONLY and fixed resources

commit 62d9a78f32d9a1b0f6fdae70751deeae6335e74b
Author: Yongji Xie <xyjxie@linux.vnet.ibm.com>
Date:   Tue Sep 13 17:00:32 2016 +0800

    PCI: Ignore requested alignment for VF BARs
    
    Resource allocation for VFs is done via the VF BARx registers in the PF's
    SR-IOV Capability, and the BARs in the VFs themselves are read-only zeros
    (see SR-IOV spec r1.1, secs 3.3.14 and 3.4.1.11).
    
    Even though the actual VF BARs are read-only zeros, the VF dev->resource[]
    structs describe the space allocated for the VF (this is a piece of the
    space described by the VF BARx register in the PF's SR-IOV capability).
    
    It's meaningless to request additional alignment for a VF: the VF BAR
    alignment is completely determined by the alignment of the VF BARx in the
    PF and the size of the VF BAR.
    
    Ignore the user's alignment requests for VF devices.
    
    Signed-off-by: Yongji Xie <xyjxie@linux.vnet.ibm.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index ed9447aee863..b5b83331da26 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -5049,6 +5049,15 @@ void pci_reassigndev_resource_alignment(struct pci_dev *dev)
 	resource_size_t align, size;
 	u16 command;
 
+	/*
+	 * VF BARs are read-only zero according to SR-IOV spec r1.1, sec
+	 * 3.4.1.11.  Their resources are allocated from the space
+	 * described by the VF BARx register in the PF's SR-IOV capability.
+	 * We can't influence their alignment here.
+	 */
+	if (dev->is_virtfn)
+		return;
+
 	/* check if specified PCI is target device to reassign */
 	align = pci_specified_resource_alignment(dev);
 	if (!align)

commit f0b99f70e92dcdc4fecf5cf7ce2f6857ddd82c65
Author: Yongji Xie <xyjxie@linux.vnet.ibm.com>
Date:   Tue Sep 13 17:00:31 2016 +0800

    PCI: Ignore requested alignment for PROBE_ONLY and fixed resources
    
    Users may request additional alignment of PCI resources, e.g., to align
    BARs on page boundaries so they can be shared with guests via VFIO.  This
    of course may require reallocation if firmware has already assigned the
    BARs with smaller alignments.
    
    If the platform has requested PCI_PROBE_ONLY, we should never change any
    PCI BARs, so we can't provide any additional alignment.  Also, if a BAR is
    marked as IORESOURCE_PCI_FIXED, e.g., for PCI Enhanced Allocation or if the
    firmware depends on the current BAR value, we can't change the alignment.
    
    In these cases, log a message and ignore the user's alignment requests.
    
    [bhelgaas: changelog, use goto to simplify PCI_PROBE_ONLY check]
    Signed-off-by: Yongji Xie <xyjxie@linux.vnet.ibm.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index aab9d5115a5f..ed9447aee863 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -4959,6 +4959,13 @@ static resource_size_t pci_specified_resource_alignment(struct pci_dev *dev)
 
 	spin_lock(&resource_alignment_lock);
 	p = resource_alignment_param;
+	if (!*p)
+		goto out;
+	if (pci_has_flag(PCI_PROBE_ONLY)) {
+		pr_info_once("PCI: Ignoring requested alignments (PCI_PROBE_ONLY)\n");
+		goto out;
+	}
+
 	while (*p) {
 		count = 0;
 		if (sscanf(p, "%d%n", &align_order, &count) == 1 &&
@@ -5023,6 +5030,7 @@ static resource_size_t pci_specified_resource_alignment(struct pci_dev *dev)
 		}
 		p++;
 	}
+out:
 	spin_unlock(&resource_alignment_lock);
 	return align;
 }
@@ -5063,6 +5071,12 @@ void pci_reassigndev_resource_alignment(struct pci_dev *dev)
 		r = &dev->resource[i];
 		if (!(r->flags & IORESOURCE_MEM))
 			continue;
+		if (r->flags & IORESOURCE_PCI_FIXED) {
+			dev_info(&dev->dev, "Ignoring requested alignment for BAR%d: %pR\n",
+				i, r);
+			continue;
+		}
+
 		size = resource_size(r);
 		if (size < align) {
 			size = align;

commit a6a64026c0cd1a76a0c8ab1c05a421aa4821887b
Author: Lukas Wunner <lukas@wunner.de>
Date:   Sun Sep 18 05:39:20 2016 +0200

    PCI: Recognize D3cold in pci_update_current_state()
    
    Whenever a device is resumed or its power state is changed using the
    platform, its new power state is read from the PM Control & Status Register
    and cached in pci_dev->current_state by calling pci_update_current_state().
    
    If the device is in D3cold, reading from config space typically results in
    a fabricated "all ones" response.  But if it's in D3hot, the two bits
    representing the power state in the PMCSR are *also* set to 1.  Thus D3hot
    and D3cold are not discernible by just reading the PMCSR.
    
    To account for this, pci_update_current_state() uses two workarounds:
    
    - When transitioning to D3cold using pci_platform_power_transition(), the
      new power state is set blindly by pci_update_current_state(), i.e.
      without verifying that the device actually *is* in D3cold.  This is
      achieved by setting the "state" argument to PCI_D3cold.  The "state"
      argument was originally intended to convey the new state in case the
      device doesn't have the PM capability.  It is *also* used to convey the
      device state if the PM capability is present and the new state is D3cold,
      but this was never explained in the kerneldoc.
    
    - Once the current_state is set to D3cold, further invocations of
      pci_update_current_state() will blindly assume that the device is still
      in D3cold and leave the current_state unmodified.  To get out of this
      impasse, the current_state has to be set directly, typically by calling
      pci_raw_set_power_state() or pci_enable_device().
    
    It would be desirable if pci_update_current_state() could reliably detect
    D3cold by itself.  That would allow us to do away with these workarounds,
    and it would allow for a smarter, more energy conserving runtime resume
    strategy after system sleep:  Currently devices which utilize
    direct_complete are mandatorily runtime resumed in their ->complete stage.
    This can be avoided if their power state after system sleep is the same as
    before, but it requires a mechanism to detect the power state reliably.
    
    We've just gained the ability to query the platform firmware for its
    opinion on the device's power state.  On platforms conforming to ACPI 4.0
    or newer, this allows recognition of D3cold.  Pre-4.0 platforms lack _PR3
    and therefore the deepest power state that will ever be reported is D3hot,
    even though the device may actually be in D3cold.  To detect D3cold in
    those cases, accessibility of the vendor ID in config space is probed using
    pci_device_is_present().  This also works for devices which are not
    platform-power-manageable at all, but can be suspended to D3cold using a
    nonstandard mechanism (e.g. some hybrid graphics laptops or Thunderbolt on
    the Mac).
    
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 2e18e9adcc15..b2be8957a290 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -707,26 +707,25 @@ static int pci_raw_set_power_state(struct pci_dev *dev, pci_power_t state)
 }
 
 /**
- * pci_update_current_state - Read PCI power state of given device from its
- *                            PCI PM registers and cache it
+ * pci_update_current_state - Read power state of given device and cache it
  * @dev: PCI device to handle.
  * @state: State to cache in case the device doesn't have the PM capability
+ *
+ * The power state is read from the PMCSR register, which however is
+ * inaccessible in D3cold.  The platform firmware is therefore queried first
+ * to detect accessibility of the register.  In case the platform firmware
+ * reports an incorrect state or the device isn't power manageable by the
+ * platform at all, we try to detect D3cold by testing accessibility of the
+ * vendor ID in config space.
  */
 void pci_update_current_state(struct pci_dev *dev, pci_power_t state)
 {
-	if (dev->pm_cap) {
+	if (platform_pci_get_power_state(dev) == PCI_D3cold ||
+	    !pci_device_is_present(dev)) {
+		dev->current_state = PCI_D3cold;
+	} else if (dev->pm_cap) {
 		u16 pmcsr;
 
-		/*
-		 * Configuration space is not accessible for device in
-		 * D3cold, so just keep or set D3cold for safety
-		 */
-		if (dev->current_state == PCI_D3cold)
-			return;
-		if (state == PCI_D3cold) {
-			dev->current_state = PCI_D3cold;
-			return;
-		}
 		pci_read_config_word(dev, dev->pm_cap + PCI_PM_CTRL, &pmcsr);
 		dev->current_state = (pmcsr & PCI_PM_CTRL_STATE_MASK);
 	} else {

commit cc7cc02bada84f0d707aa5b6d2ef8728a2e1f911
Author: Lukas Wunner <lukas@wunner.de>
Date:   Sun Sep 18 05:39:20 2016 +0200

    PCI: Query platform firmware for device power state
    
    Usually the most accurate way to determine a PCI device's power state is to
    read its PM Control & Status Register.  There are two cases however when
    this is not an option:  If the device doesn't have the PM capability at
    all, or if it is in D3cold (in which case its config space is
    inaccessible).
    
    In both cases, we can alternatively query the platform firmware for its
    opinion on the device's power state.  To facilitate this, augment struct
    pci_platform_pm_ops with a ->get_power callback and implement it for
    acpi_pci_platform_pm (the only pci_platform_pm_ops existing so far).
    
    It is used by a forthcoming commit to let pci_update_current_state()
    recognize D3cold.
    
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 2f818c3e6571..2e18e9adcc15 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -552,8 +552,9 @@ static const struct pci_platform_pm_ops *pci_platform_pm;
 
 int pci_set_platform_pm(const struct pci_platform_pm_ops *ops)
 {
-	if (!ops->is_manageable || !ops->set_state || !ops->choose_state ||
-	    !ops->sleep_wake || !ops->run_wake || !ops->need_resume)
+	if (!ops->is_manageable || !ops->set_state  || !ops->get_state ||
+	    !ops->choose_state  || !ops->sleep_wake || !ops->run_wake  ||
+	    !ops->need_resume)
 		return -EINVAL;
 	pci_platform_pm = ops;
 	return 0;
@@ -570,6 +571,11 @@ static inline int platform_pci_set_power_state(struct pci_dev *dev,
 	return pci_platform_pm ? pci_platform_pm->set_state(dev, t) : -ENOSYS;
 }
 
+static inline pci_power_t platform_pci_get_power_state(struct pci_dev *dev)
+{
+	return pci_platform_pm ? pci_platform_pm->get_state(dev) : PCI_UNKNOWN;
+}
+
 static inline pci_power_t platform_pci_choose_state(struct pci_dev *dev)
 {
 	return pci_platform_pm ?

commit 4132a577a0a7e75b938d2ae49c7a16b358f60661
Author: Lukas Wunner <lukas@wunner.de>
Date:   Sun Sep 18 05:39:20 2016 +0200

    PCI: Afford direct-complete to devices with non-standard PM
    
    There are devices not power-manageable by the platform, but still able to
    runtime suspend to D3cold with a non-standard mechanism.  One example is
    laptop hybrid graphics where the discrete GPU and its built-in HDA
    controller are power-managed either with a _DSM (AMD PowerXpress, Nvidia
    Optimus) or a separate gmux controller (MacBook Pro).  Another example is
    Thunderbolt on Macs which is power-managed with custom ACPI methods.
    
    When putting the system to sleep, we currently handle such devices
    improperly by transitioning them from D3cold to D3hot (the default power
    state defined at the top of pci_target_state()).  This wastes energy and
    prolongs the suspend sequence (powering up the Thunderbolt controller takes
    2 seconds).
    
    Avoid that by assuming that a non-standard PM mechanism is at work if the
    device is not platform-power-manageable but currently in D3cold.
    
    If the device is wakeup enabled, we might still have to wake it up from
    D3cold if PME cannot be signaled from that power state.
    
    The check for devices without PM capability comes before the check for
    D3cold since such devices could in theory also be powered down by
    non-standard means and should then be afforded direct-complete as well.
    
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index aab9d5115a5f..2f818c3e6571 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1959,9 +1959,22 @@ static pci_power_t pci_target_state(struct pci_dev *dev)
 		default:
 			target_state = state;
 		}
-	} else if (!dev->pm_cap) {
+
+		return target_state;
+	}
+
+	if (!dev->pm_cap)
 		target_state = PCI_D0;
-	} else if (device_may_wakeup(&dev->dev)) {
+
+	/*
+	 * If the device is in D3cold even though it's not power-manageable by
+	 * the platform, it may have been powered down by non-standard means.
+	 * Best to let it slumber.
+	 */
+	if (dev->current_state == PCI_D3cold)
+		target_state = PCI_D3cold;
+
+	if (device_may_wakeup(&dev->dev)) {
 		/*
 		 * Find the deepest state from which the device can generate
 		 * wake-up events, make it the target state and enable device

commit afd29f9017a271fb048b69275975c5451fd0e674
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Thu Sep 15 11:07:03 2016 +0300

    PCI: Add pci_find_resource()
    
    Add a new helper function pci_find_resource() that can be used to find out
    whether a given resource (for example from a child device) is contained
    within given PCI device's standard resources.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index aab9d5115a5f..415956c5c593 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -479,6 +479,30 @@ struct resource *pci_find_parent_resource(const struct pci_dev *dev,
 }
 EXPORT_SYMBOL(pci_find_parent_resource);
 
+/**
+ * pci_find_resource - Return matching PCI device resource
+ * @dev: PCI device to query
+ * @res: Resource to look for
+ *
+ * Goes over standard PCI resources (BARs) and checks if the given resource
+ * is partially or fully contained in any of them. In that case the
+ * matching resource is returned, %NULL otherwise.
+ */
+struct resource *pci_find_resource(struct pci_dev *dev, struct resource *res)
+{
+	int i;
+
+	for (i = 0; i < PCI_ROM_RESOURCE; i++) {
+		struct resource *r = &dev->resource[i];
+
+		if (r->start && resource_contains(r, res))
+			return r;
+	}
+
+	return NULL;
+}
+EXPORT_SYMBOL(pci_find_resource);
+
 /**
  * pci_find_pcie_root_port - return PCIe Root Port
  * @dev: PCI device to query

commit c8d0267efdb4ab16cd0ed6e0218e8c164006de48
Merge: affe8a2abd0d 9454c23852ca
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Aug 2 17:12:29 2016 -0400

    Merge tag 'pci-v4.8-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI updates from Bjorn Helgaas:
     "Highlights:
    
       - ARM64 support for ACPI host bridges
    
       - new drivers for Axis ARTPEC-6 and Marvell Aardvark
    
       - new pci_alloc_irq_vectors() interface for MSI-X, MSI, legacy INTx
    
       - pci_resource_to_user() cleanup (more to come)
    
      Detailed summary:
    
      Enumeration:
       - Move ecam.h to linux/include/pci-ecam.h (Jayachandran C)
       - Add parent device field to ECAM struct pci_config_window (Jayachandran C)
       - Add generic MCFG table handling (Tomasz Nowicki)
       - Refactor pci_bus_assign_domain_nr() for CONFIG_PCI_DOMAINS_GENERIC (Tomasz Nowicki)
       - Factor DT-specific pci_bus_find_domain_nr() code out (Tomasz Nowicki)
    
      Resource management:
       - Add devm_request_pci_bus_resources() (Bjorn Helgaas)
       - Unify pci_resource_to_user() declarations (Bjorn Helgaas)
       - Implement pci_resource_to_user() with pcibios_resource_to_bus() (microblaze, powerpc, sparc) (Bjorn Helgaas)
       - Request host bridge window resources (designware, iproc, rcar, xgene, xilinx, xilinx-nwl) (Bjorn Helgaas)
       - Make PCI I/O space optional on ARM32 (Bjorn Helgaas)
       - Ignore write combining when mapping I/O port space (Bjorn Helgaas)
       - Claim bus resources on MIPS PCI_PROBE_ONLY set-ups (Bjorn Helgaas)
       - Remove unicore32 pci=firmware command line parameter handling (Bjorn Helgaas)
       - Support I/O resources when parsing host bridge resources (Jayachandran C)
       - Add helpers to request/release memory and I/O regions (Johannes Thumshirn)
       - Use pci_(request|release)_mem_regions (NVMe, lpfc, GenWQE, ethernet/intel, alx) (Johannes Thumshirn)
       - Extend pci=resource_alignment to specify device/vendor IDs (Koehrer Mathias (ETAS/ESW5))
       - Add generic pci_bus_claim_resources() (Lorenzo Pieralisi)
       - Claim bus resources on ARM32 PCI_PROBE_ONLY set-ups (Lorenzo Pieralisi)
       - Remove ARM32 and ARM64 arch-specific pcibios_enable_device() (Lorenzo Pieralisi)
       - Add pci_unmap_iospace() to unmap I/O resources (Sinan Kaya)
       - Remove powerpc __pci_mmap_set_pgprot() (Yinghai Lu)
    
      PCI device hotplug:
       - Allow additional bus numbers for hotplug bridges (Keith Busch)
       - Ignore interrupts during D3cold (Lukas Wunner)
    
      Power management:
       - Enforce type casting for pci_power_t (Andy Shevchenko)
       - Don't clear d3cold_allowed for PCIe ports (Mika Westerberg)
       - Put PCIe ports into D3 during suspend (Mika Westerberg)
       - Power on bridges before scanning new devices (Mika Westerberg)
       - Runtime resume bridge before rescan (Mika Westerberg)
       - Add runtime PM support for PCIe ports (Mika Westerberg)
       - Remove redundant check of pcie_set_clkpm (Shawn Lin)
    
      Virtualization:
       - Add function 1 DMA alias quirk for Marvell 88SE9182 (Aaron Sierra)
       - Add DMA alias quirk for Adaptec 3805 (Alex Williamson)
       - Mark Atheros AR9485 and QCA9882 to avoid bus reset (Chris Blake)
       - Add ACS quirk for Solarflare SFC9220 (Edward Cree)
    
      MSI:
       - Fix PCI_MSI dependencies (Arnd Bergmann)
       - Add pci_msix_desc_addr() helper (Christoph Hellwig)
       - Switch msix_program_entries() to use pci_msix_desc_addr() (Christoph Hellwig)
       - Make the "entries" argument to pci_enable_msix() optional (Christoph Hellwig)
       - Provide sensible IRQ vector alloc/free routines (Christoph Hellwig)
       - Spread interrupt vectors in pci_alloc_irq_vectors() (Christoph Hellwig)
    
      Error Handling:
       - Bind DPC to Root Ports as well as Downstream Ports (Keith Busch)
       - Remove DPC tristate module option (Keith Busch)
       - Convert Downstream Port Containment driver to use devm_* functions (Mika Westerberg)
    
      Generic host bridge driver:
       - Select IRQ_DOMAIN (Arnd Bergmann)
       - Claim bus resources on PCI_PROBE_ONLY set-ups (Lorenzo Pieralisi)
    
      ACPI host bridge driver:
       - Add ARM64 acpi_pci_bus_find_domain_nr() (Tomasz Nowicki)
       - Add ARM64 ACPI support for legacy IRQs parsing and consolidation with DT code (Tomasz Nowicki)
       - Implement ARM64 AML accessors for PCI_Config region (Tomasz Nowicki)
       - Support ARM64 ACPI-based PCI host controller (Tomasz Nowicki)
    
      Altera host bridge driver:
       - Check link status before retrain link (Ley Foon Tan)
       - Poll for link up status after retraining the link (Ley Foon Tan)
    
      Axis ARTPEC-6 host bridge driver:
       - Add PCI_MSI_IRQ_DOMAIN dependency (Arnd Bergmann)
       - Add DT binding for Axis ARTPEC-6 PCIe controller (Niklas Cassel)
       - Add Axis ARTPEC-6 PCIe controller driver (Niklas Cassel)
    
      Intel VMD host bridge driver:
       - Use lock save/restore in interrupt enable path (Jon Derrick)
       - Select device dma ops to override (Keith Busch)
       - Initialize list item in IRQ disable (Keith Busch)
       - Use x86_vector_domain as parent domain (Keith Busch)
       - Separate MSI and MSI-X vector sharing (Keith Busch)
    
      Marvell Aardvark host bridge driver:
       - Add DT binding for the Aardvark PCIe controller (Thomas Petazzoni)
       - Add Aardvark PCI host controller driver (Thomas Petazzoni)
       - Add Aardvark PCIe support for Armada 3700 (Thomas Petazzoni)
    
      Microsoft Hyper-V host bridge driver:
       - Fix interrupt cleanup path (Cathy Avery)
       - Don't leak buffer in hv_pci_onchannelcallback() (Vitaly Kuznetsov)
       - Handle all pending messages in hv_pci_onchannelcallback() (Vitaly Kuznetsov)
    
      NVIDIA Tegra host bridge driver:
       - Program PADS_REFCLK_CFG* always, not just on legacy SoCs (Stephen Warren)
       - Program PADS_REFCLK_CFG* registers with per-SoC values (Stephen Warren)
       - Use lower-case hex consistently for register definitions (Thierry Reding)
       - Use generic pci_remap_iospace() rather than ARM32-specific one (Thierry Reding)
       - Stop setting pcibios_min_mem (Thierry Reding)
    
      Renesas R-Car host bridge driver:
       - Drop gen2 dummy I/O port region (Bjorn Helgaas)
    
      TI DRA7xx host bridge driver:
       - Fix return value in case of error (Christophe JAILLET)
    
      Xilinx AXI host bridge driver:
       - Fix return value in case of error (Christophe JAILLET)
    
      Miscellaneous:
       - Make bus_attr_resource_alignment static (Ben Dooks)
       - Include <asm/dma.h> for isa_dma_bridge_buggy (Ben Dooks)
       - MAINTAINERS: Add file patterns for PCI device tree bindings (Geert Uytterhoeven)
       - Make host bridge drivers explicitly non-modular (Paul Gortmaker)"
    
    * tag 'pci-v4.8-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (125 commits)
      PCI: xgene: Make explicitly non-modular
      PCI: thunder-pem: Make explicitly non-modular
      PCI: thunder-ecam: Make explicitly non-modular
      PCI: tegra: Make explicitly non-modular
      PCI: rcar-gen2: Make explicitly non-modular
      PCI: rcar: Make explicitly non-modular
      PCI: mvebu: Make explicitly non-modular
      PCI: layerscape: Make explicitly non-modular
      PCI: keystone: Make explicitly non-modular
      PCI: hisi: Make explicitly non-modular
      PCI: generic: Make explicitly non-modular
      PCI: designware-plat: Make it explicitly non-modular
      PCI: artpec6: Make explicitly non-modular
      PCI: armada8k: Make explicitly non-modular
      PCI: artpec: Add PCI_MSI_IRQ_DOMAIN dependency
      PCI: Add ACS quirk for Solarflare SFC9220
      arm64: dts: marvell: Add Aardvark PCIe support for Armada 3700
      PCI: aardvark: Add Aardvark PCI host controller driver
      dt-bindings: add DT binding for the Aardvark PCIe controller
      PCI: tegra: Program PADS_REFCLK_CFG* registers with per-SoC values
      ...

commit 3efc7023787f8a6ddc50fa96707614677a568466
Merge: a00c74c1664e ab2b750cad02
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Aug 1 12:23:44 2016 -0500

    Merge branch 'pci/resource' into next
    
    * pci/resource:
      unicore32/PCI: Remove pci=firmware command line parameter handling
      ARM/PCI: Remove arch-specific pcibios_enable_device()
      ARM64/PCI: Remove arch-specific pcibios_enable_device()
      MIPS/PCI: Claim bus resources on PCI_PROBE_ONLY set-ups
      ARM/PCI: Claim bus resources on PCI_PROBE_ONLY set-ups
      PCI: generic: Claim bus resources on PCI_PROBE_ONLY set-ups
      PCI: Add generic pci_bus_claim_resources()
      alx: Use pci_(request|release)_mem_regions
      ethernet/intel: Use pci_(request|release)_mem_regions
      GenWQE: Use pci_(request|release)_mem_regions
      lpfc: Use pci_(request|release)_mem_regions
      NVMe: Use pci_(request|release)_mem_regions
      PCI: Add helpers to request/release memory and I/O regions
      PCI: Extending pci=resource_alignment to specify device/vendor IDs
      sparc/PCI: Implement pci_resource_to_user() with pcibios_resource_to_bus()
      powerpc/pci: Implement pci_resource_to_user() with pcibios_resource_to_bus()
      microblaze/PCI: Implement pci_resource_to_user() with pcibios_resource_to_bus()
      PCI: Unify pci_resource_to_user() declarations
      microblaze/PCI: Remove useless __pci_mmap_set_pgprot()
      powerpc/pci: Remove __pci_mmap_set_pgprot()
      PCI: Ignore write combining when mapping I/O port space

commit a00c74c1664e6de4ad671c7c921a06ef164622c0
Merge: c5cb85b25837 a6c1c6f3547b a4959d8c1eaa e16b46605960 2a2aca316aed 3ee803641e76 ed91de7e14fb 9fad4012db45
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Aug 1 12:23:31 2016 -0500

    Merge branches 'pci/aspm', 'pci/dpc', 'pci/hotplug', 'pci/misc', 'pci/msi', 'pci/pm' and 'pci/virtualization' into next
    
    * pci/aspm:
      PCI/ASPM: Remove redundant check of pcie_set_clkpm
    
    * pci/dpc:
      PCI: Remove DPC tristate module option
      PCI: Bind DPC to Root Ports as well as Downstream Ports
      PCI: Fix whitespace in struct dpc_dev
      PCI: Convert Downstream Port Containment driver to use devm_* functions
    
    * pci/hotplug:
      PCI: Allow additional bus numbers for hotplug bridges
    
    * pci/misc:
      PCI: Include <asm/dma.h> for isa_dma_bridge_buggy
      PCI: Make bus_attr_resource_alignment static
      MAINTAINERS: Add file patterns for PCI device tree bindings
      PCI: Fix comment typo
    
    * pci/msi:
      PCI/MSI: irqchip: Fix PCI_MSI dependencies
    
    * pci/pm:
      PCI: pciehp: Ignore interrupts during D3cold
      PCI: Document connection between pci_power_t and hardware PM capability
      PCI: Add runtime PM support for PCIe ports
      ACPI / hotplug / PCI: Runtime resume bridge before rescan
      PCI: Power on bridges before scanning new devices
      PCI: Put PCIe ports into D3 during suspend
      PCI: Don't clear d3cold_allowed for PCIe ports
      PCI / PM: Enforce type casting for pci_power_t
    
    * pci/virtualization:
      PCI: Add ACS quirk for Solarflare SFC9220
      PCI: Add DMA alias quirk for Adaptec 3805
      PCI: Mark Atheros AR9485 and QCA9882 to avoid bus reset
      PCI: Add function 1 DMA alias quirk for Marvell 88SE9182

commit e16b46605960bd071a3e26f316e0bb600ae91e37
Author: Keith Busch <keith.busch@intel.com>
Date:   Thu Jul 21 21:40:28 2016 -0600

    PCI: Allow additional bus numbers for hotplug bridges
    
    A user may hot add a switch requiring more than one bus to enumerate.  This
    previously required a system reboot if BIOS did not sufficiently pad the
    bus resource, which they frequently don't do.
    
    Add a kernel parameter so a user can specify the minimum number of bus
    numbers to reserve for a hotplug bridge's subordinate buses so rebooting
    won't be necessary.
    
    The default is 1, which is equivalent to previous behavior.
    
    Signed-off-by: Keith Busch <keith.busch@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index c8b4dbdd1bdd..f18ea90cf91a 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -81,6 +81,9 @@ unsigned long pci_cardbus_mem_size = DEFAULT_CARDBUS_MEM_SIZE;
 unsigned long pci_hotplug_io_size  = DEFAULT_HOTPLUG_IO_SIZE;
 unsigned long pci_hotplug_mem_size = DEFAULT_HOTPLUG_MEM_SIZE;
 
+#define DEFAULT_HOTPLUG_BUS_SIZE	1
+unsigned long pci_hotplug_bus_size = DEFAULT_HOTPLUG_BUS_SIZE;
+
 enum pcie_bus_config_types pcie_bus_config = PCIE_BUS_DEFAULT;
 
 /*
@@ -5021,6 +5024,11 @@ static int __init pci_setup(char *str)
 				pci_hotplug_io_size = memparse(str + 9, &str);
 			} else if (!strncmp(str, "hpmemsize=", 10)) {
 				pci_hotplug_mem_size = memparse(str + 10, &str);
+			} else if (!strncmp(str, "hpbussize=", 10)) {
+				pci_hotplug_bus_size =
+					simple_strtoul(str + 10, &str, 0);
+				if (pci_hotplug_bus_size > 0xff)
+					pci_hotplug_bus_size = DEFAULT_HOTPLUG_BUS_SIZE;
 			} else if (!strncmp(str, "pcie_bus_tune_off", 17)) {
 				pcie_bus_config = PCIE_BUS_TUNE_OFF;
 			} else if (!strncmp(str, "pcie_bus_safe", 13)) {

commit 6ec39cf5cd6f77e3ff9ff1da75b758a47f939888
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Mon Jun 6 17:25:33 2016 +0300

    PCI / PM: check all fields in pci_set_platform_pm()
    
    When assign new PCI platform PM operations check for all mandatory fields to
    prevent NULL pointer dereference.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index c8b4dbdd1bdd..badbddc683f0 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -530,8 +530,8 @@ static const struct pci_platform_pm_ops *pci_platform_pm;
 
 int pci_set_platform_pm(const struct pci_platform_pm_ops *ops)
 {
-	if (!ops->is_manageable || !ops->set_state || !ops->choose_state
-	    || !ops->sleep_wake)
+	if (!ops->is_manageable || !ops->set_state || !ops->choose_state ||
+	    !ops->sleep_wake || !ops->run_wake || !ops->need_resume)
 		return -EINVAL;
 	pci_platform_pm = ops;
 	return 0;

commit 2a2aca316aedae815cc3d7e9ba0b30ec5d8a5edf
Author: Ben Dooks <ben.dooks@codethink.co.uk>
Date:   Fri Jun 17 16:05:13 2016 +0100

    PCI: Include <asm/dma.h> for isa_dma_bridge_buggy
    
    At least on arm, <asm/dma.h> does not get included when building
    drivers/pci/pci.o.  This causes the following build warning which can be
    fixed by including <asm/dma.h>:
    
      drivers/pci/pci.c:37:5: warning: symbol 'isa_dma_bridge_buggy' was not declared. Should it be static?
    
    Signed-off-by: Ben Dooks <ben.dooks@codethink.co.uk>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 9add28516a66..86b538d6a2a5 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -26,6 +26,7 @@
 #include <linux/pm_runtime.h>
 #include <linux/pci_hotplug.h>
 #include <asm/setup.h>
+#include <asm/dma.h>
 #include <linux/aer.h>
 #include "pci.h"
 

commit 644a544fd9bcd65f524768b85ab22f62ed08e107
Author: Koehrer Mathias (ETAS/ESW5) <mathias.koehrer@etas.com>
Date:   Tue Jun 7 14:24:17 2016 +0000

    PCI: Extending pci=resource_alignment to specify device/vendor IDs
    
    Some uio-based PCI drivers, e.g., uio_cif do not work if the assigned PCI
    memory resources are not page aligned.
    
    By using the kernel option "pci=resource_alignment" it is possible to force
    single PCI boards to use page alignment for their memory resources.
    However, this is fairly cumbersome if several of these boards are in use
    as the specification of the cards has to be done via PCI bus/slot/function
    number which might change, e.g., by adding another board.
    
    Extend the kernel option "pci=resource_alignment" to allow specification of
    relevant devices via PCI device/vendor (and subdevice/subvendor) IDs.  The
    specification of the devices via device/vendor is indicated by a leading
    string "pci:" as argument to "pci=resource_alignment".  The format of the
    specification is pci:<vendor>:<device>[:<subvendor>:<subdevice>]
    
    Signed-off-by: Mathias Koehrer <mathias.koehrer@etas.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index c8b4dbdd1bdd..78de36f1b012 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -4755,6 +4755,7 @@ static DEFINE_SPINLOCK(resource_alignment_lock);
 static resource_size_t pci_specified_resource_alignment(struct pci_dev *dev)
 {
 	int seg, bus, slot, func, align_order, count;
+	unsigned short vendor, device, subsystem_vendor, subsystem_device;
 	resource_size_t align = 0;
 	char *p;
 
@@ -4768,28 +4769,55 @@ static resource_size_t pci_specified_resource_alignment(struct pci_dev *dev)
 		} else {
 			align_order = -1;
 		}
-		if (sscanf(p, "%x:%x:%x.%x%n",
-			&seg, &bus, &slot, &func, &count) != 4) {
-			seg = 0;
-			if (sscanf(p, "%x:%x.%x%n",
-					&bus, &slot, &func, &count) != 3) {
-				/* Invalid format */
-				printk(KERN_ERR "PCI: Can't parse resource_alignment parameter: %s\n",
-					p);
+		if (strncmp(p, "pci:", 4) == 0) {
+			/* PCI vendor/device (subvendor/subdevice) ids are specified */
+			p += 4;
+			if (sscanf(p, "%hx:%hx:%hx:%hx%n",
+				&vendor, &device, &subsystem_vendor, &subsystem_device, &count) != 4) {
+				if (sscanf(p, "%hx:%hx%n", &vendor, &device, &count) != 2) {
+					printk(KERN_ERR "PCI: Can't parse resource_alignment parameter: pci:%s\n",
+						p);
+					break;
+				}
+				subsystem_vendor = subsystem_device = 0;
+			}
+			p += count;
+			if ((!vendor || (vendor == dev->vendor)) &&
+				(!device || (device == dev->device)) &&
+				(!subsystem_vendor || (subsystem_vendor == dev->subsystem_vendor)) &&
+				(!subsystem_device || (subsystem_device == dev->subsystem_device))) {
+				if (align_order == -1)
+					align = PAGE_SIZE;
+				else
+					align = 1 << align_order;
+				/* Found */
 				break;
 			}
 		}
-		p += count;
-		if (seg == pci_domain_nr(dev->bus) &&
-			bus == dev->bus->number &&
-			slot == PCI_SLOT(dev->devfn) &&
-			func == PCI_FUNC(dev->devfn)) {
-			if (align_order == -1)
-				align = PAGE_SIZE;
-			else
-				align = 1 << align_order;
-			/* Found */
-			break;
+		else {
+			if (sscanf(p, "%x:%x:%x.%x%n",
+				&seg, &bus, &slot, &func, &count) != 4) {
+				seg = 0;
+				if (sscanf(p, "%x:%x.%x%n",
+						&bus, &slot, &func, &count) != 3) {
+					/* Invalid format */
+					printk(KERN_ERR "PCI: Can't parse resource_alignment parameter: %s\n",
+						p);
+					break;
+				}
+			}
+			p += count;
+			if (seg == pci_domain_nr(dev->bus) &&
+				bus == dev->bus->number &&
+				slot == PCI_SLOT(dev->devfn) &&
+				func == PCI_FUNC(dev->devfn)) {
+				if (align_order == -1)
+					align = PAGE_SIZE;
+				else
+					align = 1 << align_order;
+				/* Found */
+				break;
+			}
 		}
 		if (*p != ';' && *p != ',') {
 			/* End of param or invalid format */

commit 9d26d3a8f1b0c442339a235f9508bdad8af91043
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Thu Jun 2 11:17:12 2016 +0300

    PCI: Put PCIe ports into D3 during suspend
    
    Currently the Linux PCI core does not touch power state of PCI bridges and
    PCIe ports when system suspend is entered.  Leaving them in D0 consumes
    power unnecessarily and may prevent the CPU from entering deeper C-states.
    
    With recent PCIe hardware we can power down the ports to save power given
    that we take into account few restrictions:
    
      - The PCIe port hardware is recent enough, starting from 2015.
    
      - Devices connected to PCIe ports are effectively in D3cold once the port
        is transitioned to D3 (the config space is not accessible anymore and
        the link may be powered down).
    
      - Devices behind the PCIe port need to be allowed to transition to D3cold
        and back.  There is a way both drivers and userspace can forbid this.
    
      - If the device behind the PCIe port is capable of waking the system it
        needs to be able to do so from D3cold.
    
    This patch adds a new flag to struct pci_device called 'bridge_d3'.  This
    flag is set and cleared by the PCI core whenever there is a change in power
    management state of any of the devices behind the PCIe port.  When system
    later on is suspended we only need to check this flag and if it is true
    transition the port to D3 otherwise we leave it in D0.
    
    Also provide override mechanism via command line parameter
    "pcie_port_pm=[off|force]" that can be used to disable or enable the
    feature regardless of the BIOS manufacturing date.
    
    Tested-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index c8b4dbdd1bdd..9ff7183e25a2 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -9,6 +9,7 @@
 
 #include <linux/kernel.h>
 #include <linux/delay.h>
+#include <linux/dmi.h>
 #include <linux/init.h>
 #include <linux/of.h>
 #include <linux/of_pci.h>
@@ -101,6 +102,21 @@ unsigned int pcibios_max_latency = 255;
 /* If set, the PCIe ARI capability will not be used. */
 static bool pcie_ari_disabled;
 
+/* Disable bridge_d3 for all PCIe ports */
+static bool pci_bridge_d3_disable;
+/* Force bridge_d3 for all PCIe ports */
+static bool pci_bridge_d3_force;
+
+static int __init pcie_port_pm_setup(char *str)
+{
+	if (!strcmp(str, "off"))
+		pci_bridge_d3_disable = true;
+	else if (!strcmp(str, "force"))
+		pci_bridge_d3_force = true;
+	return 1;
+}
+__setup("pcie_port_pm=", pcie_port_pm_setup);
+
 /**
  * pci_bus_max_busnr - returns maximum PCI bus number of given bus' children
  * @bus: pointer to PCI bus structure to search
@@ -2155,6 +2171,164 @@ void pci_config_pm_runtime_put(struct pci_dev *pdev)
 		pm_runtime_put_sync(parent);
 }
 
+/**
+ * pci_bridge_d3_possible - Is it possible to put the bridge into D3
+ * @bridge: Bridge to check
+ *
+ * This function checks if it is possible to move the bridge to D3.
+ * Currently we only allow D3 for recent enough PCIe ports.
+ */
+static bool pci_bridge_d3_possible(struct pci_dev *bridge)
+{
+	unsigned int year;
+
+	if (!pci_is_pcie(bridge))
+		return false;
+
+	switch (pci_pcie_type(bridge)) {
+	case PCI_EXP_TYPE_ROOT_PORT:
+	case PCI_EXP_TYPE_UPSTREAM:
+	case PCI_EXP_TYPE_DOWNSTREAM:
+		if (pci_bridge_d3_disable)
+			return false;
+		if (pci_bridge_d3_force)
+			return true;
+
+		/*
+		 * It should be safe to put PCIe ports from 2015 or newer
+		 * to D3.
+		 */
+		if (dmi_get_date(DMI_BIOS_DATE, &year, NULL, NULL) &&
+		    year >= 2015) {
+			return true;
+		}
+		break;
+	}
+
+	return false;
+}
+
+static int pci_dev_check_d3cold(struct pci_dev *dev, void *data)
+{
+	bool *d3cold_ok = data;
+	bool no_d3cold;
+
+	/*
+	 * The device needs to be allowed to go D3cold and if it is wake
+	 * capable to do so from D3cold.
+	 */
+	no_d3cold = dev->no_d3cold || !dev->d3cold_allowed ||
+		(device_may_wakeup(&dev->dev) && !pci_pme_capable(dev, PCI_D3cold)) ||
+		!pci_power_manageable(dev);
+
+	*d3cold_ok = !no_d3cold;
+
+	return no_d3cold;
+}
+
+/*
+ * pci_bridge_d3_update - Update bridge D3 capabilities
+ * @dev: PCI device which is changed
+ * @remove: Is the device being removed
+ *
+ * Update upstream bridge PM capabilities accordingly depending on if the
+ * device PM configuration was changed or the device is being removed.  The
+ * change is also propagated upstream.
+ */
+static void pci_bridge_d3_update(struct pci_dev *dev, bool remove)
+{
+	struct pci_dev *bridge;
+	bool d3cold_ok = true;
+
+	bridge = pci_upstream_bridge(dev);
+	if (!bridge || !pci_bridge_d3_possible(bridge))
+		return;
+
+	pci_dev_get(bridge);
+	/*
+	 * If the device is removed we do not care about its D3cold
+	 * capabilities.
+	 */
+	if (!remove)
+		pci_dev_check_d3cold(dev, &d3cold_ok);
+
+	if (d3cold_ok) {
+		/*
+		 * We need to go through all children to find out if all of
+		 * them can still go to D3cold.
+		 */
+		pci_walk_bus(bridge->subordinate, pci_dev_check_d3cold,
+			     &d3cold_ok);
+	}
+
+	if (bridge->bridge_d3 != d3cold_ok) {
+		bridge->bridge_d3 = d3cold_ok;
+		/* Propagate change to upstream bridges */
+		pci_bridge_d3_update(bridge, false);
+	}
+
+	pci_dev_put(bridge);
+}
+
+/**
+ * pci_bridge_d3_device_changed - Update bridge D3 capabilities on change
+ * @dev: PCI device that was changed
+ *
+ * If a device is added or its PM configuration, such as is it allowed to
+ * enter D3cold, is changed this function updates upstream bridge PM
+ * capabilities accordingly.
+ */
+void pci_bridge_d3_device_changed(struct pci_dev *dev)
+{
+	pci_bridge_d3_update(dev, false);
+}
+
+/**
+ * pci_bridge_d3_device_removed - Update bridge D3 capabilities on remove
+ * @dev: PCI device being removed
+ *
+ * Function updates upstream bridge PM capabilities based on other devices
+ * still left on the bus.
+ */
+void pci_bridge_d3_device_removed(struct pci_dev *dev)
+{
+	pci_bridge_d3_update(dev, true);
+}
+
+/**
+ * pci_d3cold_enable - Enable D3cold for device
+ * @dev: PCI device to handle
+ *
+ * This function can be used in drivers to enable D3cold from the device
+ * they handle.  It also updates upstream PCI bridge PM capabilities
+ * accordingly.
+ */
+void pci_d3cold_enable(struct pci_dev *dev)
+{
+	if (dev->no_d3cold) {
+		dev->no_d3cold = false;
+		pci_bridge_d3_device_changed(dev);
+	}
+}
+EXPORT_SYMBOL_GPL(pci_d3cold_enable);
+
+/**
+ * pci_d3cold_disable - Disable D3cold for device
+ * @dev: PCI device to handle
+ *
+ * This function can be used in drivers to disable D3cold from the device
+ * they handle.  It also updates upstream PCI bridge PM capabilities
+ * accordingly.
+ */
+void pci_d3cold_disable(struct pci_dev *dev)
+{
+	if (!dev->no_d3cold) {
+		dev->no_d3cold = true;
+		pci_bridge_d3_device_changed(dev);
+	}
+}
+EXPORT_SYMBOL_GPL(pci_d3cold_disable);
+
 /**
  * pci_pm_init - Initialize PM functions of given PCI device
  * @dev: PCI device to handle.
@@ -2189,6 +2363,7 @@ void pci_pm_init(struct pci_dev *dev)
 	dev->pm_cap = pm;
 	dev->d3_delay = PCI_PM_D3_WAIT;
 	dev->d3cold_delay = PCI_PM_D3COLD_WAIT;
+	dev->bridge_d3 = pci_bridge_d3_possible(dev);
 	dev->d3cold_allowed = true;
 
 	dev->d1_support = false;

commit 21751a9a4ed4219c11e4073afecb9a876d1107ea
Author: Ben Dooks <ben.dooks@codethink.co.uk>
Date:   Thu Jun 9 11:42:13 2016 +0100

    PCI: Make bus_attr_resource_alignment static
    
    The symbol bus_attr_resource_alignment is not exported or declared
    elsewhere, so make it static to fix the following warning:
    
      drivers/pci/pci.c:4900:1: warning: symbol 'bus_attr_resource_alignment' was not declared. Should it be static?
    
    Signed-off-by: Ben Dooks <ben.dooks@codethink.co.uk>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index c8b4dbdd1bdd..9add28516a66 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -4897,7 +4897,7 @@ static ssize_t pci_resource_alignment_store(struct bus_type *bus,
 	return pci_set_resource_alignment_param(buf, count);
 }
 
-BUS_ATTR(resource_alignment, 0644, pci_resource_alignment_show,
+static BUS_ATTR(resource_alignment, 0644, pci_resource_alignment_show,
 					pci_resource_alignment_store);
 
 static int __init pci_resource_alignment_sysfs_init(void)

commit 2ab51ddeca2fc32a7040d8560415be3366fa9ba7
Author: Tomasz Nowicki <tn@semihalf.com>
Date:   Fri Jun 10 15:36:26 2016 -0500

    ARM64: PCI: Add acpi_pci_bus_find_domain_nr()
    
    Extend pci_bus_find_domain_nr() so it can find the domain from either:
    
      - ACPI, via the new acpi_pci_bus_find_domain_nr() interface, or
      - DT, via of_pci_bus_find_domain_nr()
    
    Note that this is only used for CONFIG_PCI_DOMAINS_GENERIC=y, so it does
    not affect x86 or ia64.
    
    [bhelgaas: changelog]
    Signed-off-by: Tomasz Nowicki <tn@semihalf.com>
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 97f7cd4a7e86..4834ceeca0d2 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -7,6 +7,7 @@
  *	Copyright 1997 -- 2000 Martin Mares <mj@ucw.cz>
  */
 
+#include <linux/acpi.h>
 #include <linux/kernel.h>
 #include <linux/delay.h>
 #include <linux/init.h>
@@ -4990,7 +4991,8 @@ static int of_pci_bus_find_domain_nr(struct device *parent)
 
 int pci_bus_find_domain_nr(struct pci_bus *bus, struct device *parent)
 {
-	return of_pci_bus_find_domain_nr(parent);
+	return acpi_disabled ? of_pci_bus_find_domain_nr(parent) :
+			       acpi_pci_bus_find_domain_nr(bus);
 }
 #endif
 #endif

commit 1a4f93f7112fd92383534f4c23d7b24fd4f8833c
Author: Tomasz Nowicki <tn@semihalf.com>
Date:   Fri Jun 10 21:55:15 2016 +0200

    PCI: Factor DT-specific pci_bus_find_domain_nr() code out
    
    pci_bus_find_domain_nr() retrieves the host bridge domain number in a
    DT-specific way.  Rename it to of_pci_bus_find_domain_nr() to reflect that,
    so we can add a corresponding function for ACPI.
    
    [bhelgaas: changelog]
    Signed-off-by: Tomasz Nowicki <tn@semihalf.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index b9a783385eae..97f7cd4a7e86 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -4941,7 +4941,7 @@ int pci_get_new_domain_nr(void)
 }
 
 #ifdef CONFIG_PCI_DOMAINS_GENERIC
-int pci_bus_find_domain_nr(struct pci_bus *bus, struct device *parent)
+static int of_pci_bus_find_domain_nr(struct device *parent)
 {
 	static int use_dt_domains = -1;
 	int domain = -1;
@@ -4987,6 +4987,11 @@ int pci_bus_find_domain_nr(struct pci_bus *bus, struct device *parent)
 
 	return domain;
 }
+
+int pci_bus_find_domain_nr(struct pci_bus *bus, struct device *parent)
+{
+	return of_pci_bus_find_domain_nr(parent);
+}
 #endif
 #endif
 

commit 9c7cb891ecfea3b88e4fa255afeec0da84ea6a86
Author: Tomasz Nowicki <tn@semihalf.com>
Date:   Fri Jun 10 21:55:14 2016 +0200

    PCI: Refactor pci_bus_assign_domain_nr() for CONFIG_PCI_DOMAINS_GENERIC
    
    Instead of assigning bus->domain_nr inside pci_bus_assign_domain_nr(),
    return the domain and let the caller do the assignment.  Rename
    pci_bus_assign_domain_nr() to pci_bus_find_domain_nr() to reflect this.
    
    No functional change intended.
    
    [bhelgaas: changelog]
    Signed-off-by: Tomasz Nowicki <tn@semihalf.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index eb431b5c3685..b9a783385eae 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -4941,7 +4941,7 @@ int pci_get_new_domain_nr(void)
 }
 
 #ifdef CONFIG_PCI_DOMAINS_GENERIC
-void pci_bus_assign_domain_nr(struct pci_bus *bus, struct device *parent)
+int pci_bus_find_domain_nr(struct pci_bus *bus, struct device *parent)
 {
 	static int use_dt_domains = -1;
 	int domain = -1;
@@ -4985,7 +4985,7 @@ void pci_bus_assign_domain_nr(struct pci_bus *bus, struct device *parent)
 		domain = -1;
 	}
 
-	bus->domain_nr = domain;
+	return domain;
 }
 #endif
 #endif

commit 4d3f13845957a87729a324cce8509fad8826ef52
Author: Sinan Kaya <okaya@codeaurora.org>
Date:   Fri Jun 10 21:55:11 2016 +0200

    PCI: Add pci_unmap_iospace() to unmap I/O resources
    
    Add pci_unmap_iospace() to undo what pci_remap_iospace() did.
    
    This is needed to support hotplug removal of host bridges that use
    pci_remap_iospace().
    
    [bhelgaas: changelog]
    Signed-off-by: Sinan Kaya <okaya@codeaurora.org>
    Signed-off-by: Tomasz Nowicki <tn@semihalf.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index c8b4dbdd1bdd..eb431b5c3685 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -25,6 +25,7 @@
 #include <linux/device.h>
 #include <linux/pm_runtime.h>
 #include <linux/pci_hotplug.h>
+#include <linux/vmalloc.h>
 #include <asm/setup.h>
 #include <linux/aer.h>
 #include "pci.h"
@@ -3165,6 +3166,23 @@ int __weak pci_remap_iospace(const struct resource *res, phys_addr_t phys_addr)
 #endif
 }
 
+/**
+ *	pci_unmap_iospace - Unmap the memory mapped I/O space
+ *	@res: resource to be unmapped
+ *
+ *	Unmap the CPU virtual address @res from virtual address space.
+ *	Only architectures that have memory mapped IO functions defined
+ *	(and the PCI_IOBASE value defined) should call this function.
+ */
+void pci_unmap_iospace(struct resource *res)
+{
+#if defined(PCI_IOBASE) && defined(CONFIG_MMU)
+	unsigned long vaddr = (unsigned long)PCI_IOBASE + res->start;
+
+	unmap_kernel_range(vaddr, resource_size(res));
+#endif
+}
+
 static void __pci_set_master(struct pci_dev *dev, bool enable)
 {
 	u16 old_cmd, cmd;

commit e257ef55ce51d7ec399193ee85acda8b8759d930
Merge: 45604e68ed7a c5076cfe7689 bdd74440d9e8
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue May 17 14:35:46 2016 -0500

    Merge branches 'pci/arm64' and 'pci/host-hv' into next
    
    * pci/arm64:
      PCI, of: Move PCI I/O space management to PCI core code
      PCI: generic, thunder: Use generic ECAM API
      PCI: Provide common functions for ECAM mapping
    
    * pci/host-hv:
      PCI: hv: Add explicit barriers to config space access

commit 45604e68ed7acf23e6c4cbac9930c61df19220c8
Merge: d9322d226f91 f8415222837b ad67b437f187
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue May 17 14:35:38 2016 -0500

    Merge branches 'pci/hotplug' and 'pci/resource' into next
    
    * pci/hotplug:
      PCI: Use cached copy of PCI_EXP_SLTCAP_HPC bit
    
    * pci/resource:
      PCI: Disable all BAR sizing for devices with non-compliant BARs
      x86/PCI: Mark Broadwell-EP Home Agent 1 as having non-compliant BARs
      PCI: Identify Enhanced Allocation (EA) BAR Equivalent resources in sysfs

commit 92efb1bd9bcbdf83cc0e6cfead752d0c82f63677
Author: Alex Williamson <alex.williamson@redhat.com>
Date:   Mon May 16 15:12:02 2016 -0500

    PCI: Identify Enhanced Allocation (EA) BAR Equivalent resources in sysfs
    
    Resource flags are exposed to userspace via the sysfs "resource" file.
    lspci reads the sysfs file to determine resource properties.
    
    Add a "BAR Equivalent Indicator" flag so lspci can distinguish between
    [virtual] and [enhanced] resources.
    
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
    Signed-off-by: Sean O. Stalley <sean.stalley@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 25e0327d4429..7b008c7cac35 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2228,7 +2228,7 @@ void pci_pm_init(struct pci_dev *dev)
 
 static unsigned long pci_ea_flags(struct pci_dev *dev, u8 prop)
 {
-	unsigned long flags = IORESOURCE_PCI_FIXED;
+	unsigned long flags = IORESOURCE_PCI_FIXED | IORESOURCE_PCI_EA_BEI;
 
 	switch (prop) {
 	case PCI_EA_P_MEM:

commit c5076cfe768998e9d395bc8486b29b18b0f99fd9
Author: Tomasz Nowicki <tn@semihalf.com>
Date:   Wed May 11 17:34:51 2016 -0500

    PCI, of: Move PCI I/O space management to PCI core code
    
    No functional changes in this patch.
    
    PCI I/O space mapping code does not depend on OF; therefore it can be moved
    to PCI core code.  This way we will be able to use it, e.g., in ACPI PCI
    code.
    
    Suggested-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Signed-off-by: Tomasz Nowicki <tn@semihalf.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    CC: Arnd Bergmann <arnd@arndb.de>
    CC: Liviu Dudau <Liviu.Dudau@arm.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 25e0327d4429..bc0c914b8afc 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -3021,6 +3021,121 @@ int pci_request_regions_exclusive(struct pci_dev *pdev, const char *res_name)
 }
 EXPORT_SYMBOL(pci_request_regions_exclusive);
 
+#ifdef PCI_IOBASE
+struct io_range {
+	struct list_head list;
+	phys_addr_t start;
+	resource_size_t size;
+};
+
+static LIST_HEAD(io_range_list);
+static DEFINE_SPINLOCK(io_range_lock);
+#endif
+
+/*
+ * Record the PCI IO range (expressed as CPU physical address + size).
+ * Return a negative value if an error has occured, zero otherwise
+ */
+int __weak pci_register_io_range(phys_addr_t addr, resource_size_t size)
+{
+	int err = 0;
+
+#ifdef PCI_IOBASE
+	struct io_range *range;
+	resource_size_t allocated_size = 0;
+
+	/* check if the range hasn't been previously recorded */
+	spin_lock(&io_range_lock);
+	list_for_each_entry(range, &io_range_list, list) {
+		if (addr >= range->start && addr + size <= range->start + size) {
+			/* range already registered, bail out */
+			goto end_register;
+		}
+		allocated_size += range->size;
+	}
+
+	/* range not registed yet, check for available space */
+	if (allocated_size + size - 1 > IO_SPACE_LIMIT) {
+		/* if it's too big check if 64K space can be reserved */
+		if (allocated_size + SZ_64K - 1 > IO_SPACE_LIMIT) {
+			err = -E2BIG;
+			goto end_register;
+		}
+
+		size = SZ_64K;
+		pr_warn("Requested IO range too big, new size set to 64K\n");
+	}
+
+	/* add the range to the list */
+	range = kzalloc(sizeof(*range), GFP_ATOMIC);
+	if (!range) {
+		err = -ENOMEM;
+		goto end_register;
+	}
+
+	range->start = addr;
+	range->size = size;
+
+	list_add_tail(&range->list, &io_range_list);
+
+end_register:
+	spin_unlock(&io_range_lock);
+#endif
+
+	return err;
+}
+
+phys_addr_t pci_pio_to_address(unsigned long pio)
+{
+	phys_addr_t address = (phys_addr_t)OF_BAD_ADDR;
+
+#ifdef PCI_IOBASE
+	struct io_range *range;
+	resource_size_t allocated_size = 0;
+
+	if (pio > IO_SPACE_LIMIT)
+		return address;
+
+	spin_lock(&io_range_lock);
+	list_for_each_entry(range, &io_range_list, list) {
+		if (pio >= allocated_size && pio < allocated_size + range->size) {
+			address = range->start + pio - allocated_size;
+			break;
+		}
+		allocated_size += range->size;
+	}
+	spin_unlock(&io_range_lock);
+#endif
+
+	return address;
+}
+
+unsigned long __weak pci_address_to_pio(phys_addr_t address)
+{
+#ifdef PCI_IOBASE
+	struct io_range *res;
+	resource_size_t offset = 0;
+	unsigned long addr = -1;
+
+	spin_lock(&io_range_lock);
+	list_for_each_entry(res, &io_range_list, list) {
+		if (address >= res->start && address < res->start + res->size) {
+			addr = address - res->start + offset;
+			break;
+		}
+		offset += res->size;
+	}
+	spin_unlock(&io_range_lock);
+
+	return addr;
+#else
+	if (address > IO_SPACE_LIMIT)
+		return (unsigned long)-1;
+
+	return (unsigned long) address;
+#endif
+}
+
 /**
  *	pci_remap_iospace - Remap the memory mapped I/O space
  *	@res: Resource describing the I/O space

commit 7f768544c2421c399c0909ad9d5a9f916cd96de3
Merge: 9735a22799b9 35a6ae07c663 4d88d5a7bf92 dcbb408ac5a2 b1a928cdb477 19bf4d4f909d 1bf2bf229b64
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Apr 25 14:35:26 2016 -0500

    Merge branches 'pci/enumeration', 'pci/hotplug', 'pci/misc', 'pci/ntb', 'pci/thunderbolt' and 'pci/virtualization' into next
    
    * pci/enumeration:
      x86/PCI: Refine PCI support check in pcibios_init()
    
    * pci/hotplug:
      PCI: acpiphp_ibm: Avoid uninitialized variable reference
    
    * pci/misc:
      PCI: Fix spelling errors
    
    * pci/ntb:
      PCI: Add DMA alias quirk for mic_x200_dma
      PCI: Add support for multiple DMA aliases
      PCI: Move informational printk to pci_add_dma_alias()
      PCI: Add pci_add_dma_alias() to abstract implementation
    
    * pci/thunderbolt:
      thunderbolt: Support 1st gen Light Ridge controller
      thunderbolt: Fix typos and magic number
      PCI: Add Intel Thunderbolt device IDs
    
    * pci/virtualization:
      PCI: Work around Intel Sunrise Point PCH incorrect ACS capability
      PCI: Reverse standard ACS vs device-specific ACS enabling
      PCI: Mark Intel i40e NIC INTx masking as broken

commit c1d61c9bb163e696bf06850bcabbd26386554489
Author: Alex Williamson <alex.williamson@redhat.com>
Date:   Thu Mar 31 16:34:32 2016 -0600

    PCI: Reverse standard ACS vs device-specific ACS enabling
    
    The original thought was that if a device implemented ACS, then surely
    we want to use that... well, it turns out that devices can make an ACS
    capability so broken that we still need to fall back to quirks.
    
    Reverse the order of ACS enabling to give quirks first shot at it.
    
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 25e0327d4429..c98c4e2aed3c 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2547,7 +2547,7 @@ void pci_request_acs(void)
  * pci_std_enable_acs - enable ACS on devices using standard ACS capabilites
  * @dev: the PCI device
  */
-static int pci_std_enable_acs(struct pci_dev *dev)
+static void pci_std_enable_acs(struct pci_dev *dev)
 {
 	int pos;
 	u16 cap;
@@ -2555,7 +2555,7 @@ static int pci_std_enable_acs(struct pci_dev *dev)
 
 	pos = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ACS);
 	if (!pos)
-		return -ENODEV;
+		return;
 
 	pci_read_config_word(dev, pos + PCI_ACS_CAP, &cap);
 	pci_read_config_word(dev, pos + PCI_ACS_CTRL, &ctrl);
@@ -2573,8 +2573,6 @@ static int pci_std_enable_acs(struct pci_dev *dev)
 	ctrl |= (cap & PCI_ACS_UF);
 
 	pci_write_config_word(dev, pos + PCI_ACS_CTRL, ctrl);
-
-	return 0;
 }
 
 /**
@@ -2586,10 +2584,10 @@ void pci_enable_acs(struct pci_dev *dev)
 	if (!pci_acs_enable)
 		return;
 
-	if (!pci_std_enable_acs(dev))
+	if (!pci_dev_specific_enable_acs(dev))
 		return;
 
-	pci_dev_specific_enable_acs(dev);
+	pci_std_enable_acs(dev);
 }
 
 static bool pci_acs_flags_enabled(struct pci_dev *pdev, u16 acs_flags)

commit 338c3149a221527e202ee26b1e35f76c965bb6c0
Author: Jacek Lawrynowicz <jacek.lawrynowicz@intel.com>
Date:   Thu Mar 3 15:38:02 2016 +0100

    PCI: Add support for multiple DMA aliases
    
    Solve IOMMU support issues with PCIe non-transparent bridges that use
    Requester ID look-up tables (RID-LUT), e.g., the PEX8733.
    
    The NTB connects devices in two independent PCI domains.  Devices separated
    by the NTB are not able to discover each other.  A PCI packet being
    forwared from one domain to another has to have its RID modified so it
    appears on correct bus and completions are forwarded back to the original
    domain through the NTB.  The RID is translated using a preprogrammed table
    (LUT) and the PCI packet propagates upstream away from the NTB.  If the
    destination system has IOMMU enabled, the packet will be discarded because
    the new RID is unknown to the IOMMU.  Adding a DMA alias for the new RID
    allows IOMMU to properly recognize the packet.
    
    Each device behind the NTB has a unique RID assigned in the RID-LUT.  The
    current DMA alias implementation supports only a single alias, so it's not
    possible to support mutiple devices behind the NTB when IOMMU is enabled.
    
    Enable all possible aliases on a given bus (256) that are stored in a
    bitset.  Alias devfn is directly translated to a bit number.  The bitset is
    not allocated for devices that have no need for DMA aliases.
    
    More details can be found in the following article:
    http://www.plxtech.com/files/pdf/technical/expresslane/RTC_Enabling%20MulitHostSystemDesigns.pdf
    
    Signed-off-by: Jacek Lawrynowicz <jacek.lawrynowicz@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Alex Williamson <alex.williamson@redhat.com>
    Acked-by: David Woodhouse <David.Woodhouse@intel.com>
    Acked-by: Joerg Roedel <jroedel@suse.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index c82ebd0f6982..0b90c2186f1c 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -4588,12 +4588,27 @@ int pci_set_vga_state(struct pci_dev *dev, bool decode,
  */
 void pci_add_dma_alias(struct pci_dev *dev, u8 devfn)
 {
-	dev->dma_alias_devfn = devfn;
-	dev->dev_flags |= PCI_DEV_FLAGS_DMA_ALIAS_DEVFN;
+	if (!dev->dma_alias_mask)
+		dev->dma_alias_mask = kcalloc(BITS_TO_LONGS(U8_MAX),
+					      sizeof(long), GFP_KERNEL);
+	if (!dev->dma_alias_mask) {
+		dev_warn(&dev->dev, "Unable to allocate DMA alias mask\n");
+		return;
+	}
+
+	set_bit(devfn, dev->dma_alias_mask);
 	dev_info(&dev->dev, "Enabling fixed DMA alias to %02x.%d\n",
 		 PCI_SLOT(devfn), PCI_FUNC(devfn));
 }
 
+bool pci_devs_are_dma_aliases(struct pci_dev *dev1, struct pci_dev *dev2)
+{
+	return (dev1->dma_alias_mask &&
+		test_bit(dev2->devfn, dev1->dma_alias_mask)) ||
+	       (dev2->dma_alias_mask &&
+		test_bit(dev1->devfn, dev2->dma_alias_mask));
+}
+
 bool pci_device_is_present(struct pci_dev *pdev)
 {
 	u32 v;

commit 48c830809ce6e143781172c03a9794cb66802b31
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Feb 24 13:43:54 2016 -0600

    PCI: Move informational printk to pci_add_dma_alias()
    
    One of the quirks that adds DMA aliases logs an informational message in
    dmesg.  Move that to pci_add_dma_alias() so all users log the message
    consistently.  No functional change intended (except extra message).
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Alex Williamson <alex.williamson@redhat.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 1162118d1093..c82ebd0f6982 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -4590,6 +4590,8 @@ void pci_add_dma_alias(struct pci_dev *dev, u8 devfn)
 {
 	dev->dma_alias_devfn = devfn;
 	dev->dev_flags |= PCI_DEV_FLAGS_DMA_ALIAS_DEVFN;
+	dev_info(&dev->dev, "Enabling fixed DMA alias to %02x.%d\n",
+		 PCI_SLOT(devfn), PCI_FUNC(devfn));
 }
 
 bool pci_device_is_present(struct pci_dev *pdev)

commit f0af9593372abfde34460aa1250e670cc535a7d8
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Feb 24 13:43:45 2016 -0600

    PCI: Add pci_add_dma_alias() to abstract implementation
    
    Add a pci_add_dma_alias() interface to encapsulate the details of adding an
    alias.  No functional change intended.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Alex Williamson <alex.williamson@redhat.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 25e0327d4429..1162118d1093 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -4578,6 +4578,20 @@ int pci_set_vga_state(struct pci_dev *dev, bool decode,
 	return 0;
 }
 
+/**
+ * pci_add_dma_alias - Add a DMA devfn alias for a device
+ * @dev: the PCI device for which alias is added
+ * @devfn: alias slot and function
+ *
+ * This helper encodes 8-bit devfn as bit number in dma_alias_mask.
+ * It should be called early, preferably as PCI fixup header quirk.
+ */
+void pci_add_dma_alias(struct pci_dev *dev, u8 devfn)
+{
+	dev->dma_alias_devfn = devfn;
+	dev->dev_flags |= PCI_DEV_FLAGS_DMA_ALIAS_DEVFN;
+}
+
 bool pci_device_is_present(struct pci_dev *pdev)
 {
 	u32 v;

commit dcbb408ac5a2803ba44ca2fae8bf53eb5d4082f3
Author: Colin Ian King <colin.king@canonical.com>
Date:   Tue Apr 5 12:12:45 2016 -0500

    PCI: Fix spelling errors
    
    Fix spelling of "initalization".
    
    [bhelgaas: also fix pci/pci.c]
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 25e0327d4429..e3d6b33fd596 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2389,7 +2389,7 @@ static int pci_ea_read(struct pci_dev *dev, int offset)
 	return offset + ent_size;
 }
 
-/* Enhanced Allocation Initalization */
+/* Enhanced Allocation Initialization */
 void pci_ea_init(struct pci_dev *dev)
 {
 	int ea;

commit 63e30271b04c712c684c07567401b61b10d094d4
Merge: 277edbabf6fe 6e6f498b039a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Mar 16 14:45:55 2016 -0700

    Merge tag 'pci-v4.6-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI updates from Bjorn Helgaas:
     "PCI changes for v4.6:
    
      Enumeration:
       - Disable IO/MEM decoding for devices with non-compliant BARs (Bjorn Helgaas)
       - Mark Broadwell-EP Home Agent & PCU as having non-compliant BARs (Bjorn Helgaas
    
      Resource management:
       - Mark shadow copy of VGA ROM as IORESOURCE_PCI_FIXED (Bjorn Helgaas)
       - Don't assign or reassign immutable resources (Bjorn Helgaas)
       - Don't enable/disable ROM BAR if we're using a RAM shadow copy (Bjorn Helgaas)
       - Set ROM shadow location in arch code, not in PCI core (Bjorn Helgaas)
       - Remove arch-specific IORESOURCE_ROM_SHADOW size from sysfs (Bjorn Helgaas)
       - ia64: Use ioremap() instead of open-coded equivalent (Bjorn Helgaas)
       - ia64: Keep CPU physical (not virtual) addresses in shadow ROM resource (Bjorn Helgaas)
       - MIPS: Keep CPU physical (not virtual) addresses in shadow ROM resource (Bjorn Helgaas)
       - Remove unused IORESOURCE_ROM_COPY and IORESOURCE_ROM_BIOS_COPY (Bjorn Helgaas)
       - Don't leak memory if sysfs_create_bin_file() fails (Bjorn Helgaas)
       - rcar: Remove PCI_PROBE_ONLY handling (Lorenzo Pieralisi)
       - designware: Remove PCI_PROBE_ONLY handling (Lorenzo Pieralisi)
    
      Virtualization:
       - Wait for up to 1000ms after FLR reset (Alex Williamson)
       - Support SR-IOV on any function type (Kelly Zytaruk)
       - Add ACS quirk for all Cavium devices (Manish Jaggi)
    
      AER:
       - Rename pci_ops_aer to aer_inj_pci_ops (Bjorn Helgaas)
       - Restore pci_ops pointer while calling original pci_ops (David Daney)
       - Fix aer_inject error codes (Jean Delvare)
       - Use dev_warn() in aer_inject (Jean Delvare)
       - Log actual error causes in aer_inject (Jean Delvare)
       - Log aer_inject error injections (Jean Delvare)
    
      VPD:
       - Prevent VPD access for buggy devices (Babu Moger)
       - Move pci_read_vpd() and pci_write_vpd() close to other VPD code (Bjorn Helgaas)
       - Move pci_vpd_release() from header file to pci/access.c (Bjorn Helgaas)
       - Remove struct pci_vpd_ops.release function pointer (Bjorn Helgaas)
       - Rename VPD symbols to remove unnecessary "pci22" (Bjorn Helgaas)
       - Fold struct pci_vpd_pci22 into struct pci_vpd (Bjorn Helgaas)
       - Sleep rather than busy-wait for VPD access completion (Bjorn Helgaas)
       - Update VPD definitions (Hannes Reinecke)
       - Allow access to VPD attributes with size 0 (Hannes Reinecke)
       - Determine actual VPD size on first access (Hannes Reinecke)
    
      Generic host bridge driver:
       - Move structure definitions to separate header file (David Daney)
       - Add pci_host_common_probe(), based on gen_pci_probe() (David Daney)
       - Expose pci_host_common_probe() for use by other drivers (David Daney)
    
      Altera host bridge driver:
       - Fix altera_pcie_link_is_up() (Ley Foon Tan)
    
      Cavium ThunderX host bridge driver:
       - Add PCIe host driver for ThunderX processors (David Daney)
       - Add driver for ThunderX-pass{1,2} on-chip devices (David Daney)
    
      Freescale i.MX6 host bridge driver:
       - Add DT bindings to configure PHY Tx driver settings (Justin Waters)
       - Move imx6_pcie_reset_phy() near other PHY handling functions (Lucas Stach)
       - Move PHY reset into imx6_pcie_establish_link() (Lucas Stach)
       - Remove broken Gen2 workaround (Lucas Stach)
       - Move link up check into imx6_pcie_wait_for_link() (Lucas Stach)
    
      Freescale Layerscape host bridge driver:
       - Add "fsl,ls2085a-pcie" compatible ID (Yang Shi)
    
      Intel VMD host bridge driver:
       - Attach VMD resources to parent domain's resource tree (Jon Derrick)
       - Set bus resource start to 0 (Keith Busch)
    
      Microsoft Hyper-V host bridge driver:
       - Add fwnode_handle to x86 pci_sysdata (Jake Oshins)
       - Look up IRQ domain by fwnode_handle (Jake Oshins)
       - Add paravirtual PCI front-end for Microsoft Hyper-V VMs (Jake Oshins)
    
      NVIDIA Tegra host bridge driver:
       - Add pci_ops.{add,remove}_bus() callbacks (Thierry Reding)
       - Implement ->{add,remove}_bus() callbacks (Thierry Reding)
       - Remove unused struct tegra_pcie.num_ports field (Thierry Reding)
       - Track bus -> CPU mapping (Thierry Reding)
       - Remove misleading PHYS_OFFSET (Thierry Reding)
    
      Renesas R-Car host bridge driver:
       - Depend on ARCH_RENESAS, not ARCH_SHMOBILE (Simon Horman)
    
      Synopsys DesignWare host bridge driver:
       - ARC: Add PCI support (Joao Pinto)
       - Add generic dw_pcie_wait_for_link() (Joao Pinto)
       - Add default link up check if sub-driver doesn't override (Joao Pinto)
       - Add driver for prototyping kits based on ARC SDP (Joao Pinto)
    
      TI Keystone host bridge driver:
       - Defer probing if devm_phy_get() returns -EPROBE_DEFER (Shawn Lin)
    
      Xilinx AXI host bridge driver:
       - Use of_pci_get_host_bridge_resources() to parse DT (Bharat Kumar Gogada)
       - Remove dependency on ARM-specific struct hw_pci (Bharat Kumar Gogada)
       - Don't call pci_fixup_irqs() on Microblaze (Bharat Kumar Gogada)
       - Update Zynq binding with Microblaze node (Bharat Kumar Gogada)
       - microblaze: Support generic Xilinx AXI PCIe Host Bridge IP driver (Bharat Kumar Gogada)
    
      Xilinx NWL host bridge driver:
       - Add support for Xilinx NWL PCIe Host Controller (Bharat Kumar Gogada)
    
      Miscellaneous:
       - Check device_attach() return value always (Bjorn Helgaas)
       - Move pci_set_flags() from asm-generic/pci-bridge.h to linux/pci.h (Bjorn Helgaas)
       - Remove includes of empty asm-generic/pci-bridge.h (Bjorn Helgaas)
       - ARM64: Remove generated include of asm-generic/pci-bridge.h (Bjorn Helgaas)
       - Remove empty asm-generic/pci-bridge.h (Bjorn Helgaas)
       - Remove includes of asm/pci-bridge.h (Bjorn Helgaas)
       - Consolidate PCI DMA constants and interfaces in linux/pci-dma-compat.h (Bjorn Helgaas)
       - unicore32: Remove unused HAVE_ARCH_PCI_SET_DMA_MASK definition (Bjorn Helgaas)
       - Cleanup pci/pcie/Kconfig whitespace (Andreas Ziegler)
       - Include pci/hotplug Kconfig directly from pci/Kconfig (Bjorn Helgaas)
       - Include pci/pcie/Kconfig directly from pci/Kconfig (Bogicevic Sasa)
       - frv: Remove stray pci_{alloc,free}_consistent() declaration (Christoph Hellwig)
       - Move pci_dma_* helpers to common code (Christoph Hellwig)
       - Add PCI_CLASS_SERIAL_USB_DEVICE definition (Heikki Krogerus)
       - Add QEMU top-level IDs for (sub)vendor & device (Robin H. Johnson)
       - Fix broken URL for Dell biosdevname (Naga Venkata Sai Indubhaskar Jupudi)"
    
    * tag 'pci-v4.6-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (94 commits)
      PCI: Add PCI_CLASS_SERIAL_USB_DEVICE definition
      PCI: designware: Add driver for prototyping kits based on ARC SDP
      PCI: designware: Add default link up check if sub-driver doesn't override
      PCI: designware: Add generic dw_pcie_wait_for_link()
      PCI: Cleanup pci/pcie/Kconfig whitespace
      PCI: Simplify pci_create_attr() control flow
      PCI: Don't leak memory if sysfs_create_bin_file() fails
      PCI: Simplify sysfs ROM cleanup
      PCI: Remove unused IORESOURCE_ROM_COPY and IORESOURCE_ROM_BIOS_COPY
      MIPS: Loongson 3: Keep CPU physical (not virtual) addresses in shadow ROM resource
      MIPS: Loongson 3: Use temporary struct resource * to avoid repetition
      ia64/PCI: Keep CPU physical (not virtual) addresses in shadow ROM resource
      ia64/PCI: Use ioremap() instead of open-coded equivalent
      ia64/PCI: Use temporary struct resource * to avoid repetition
      PCI: Clean up pci_map_rom() whitespace
      PCI: Remove arch-specific IORESOURCE_ROM_SHADOW size from sysfs
      PCI: thunder: Add driver for ThunderX-pass{1,2} on-chip devices
      PCI: thunder: Add PCIe host driver for ThunderX processors
      PCI: generic: Expose pci_host_common_probe() for use by other drivers
      PCI: generic: Add pci_host_common_probe(), based on gen_pci_probe()
      ...

commit 18e5e6913b1ae5c6f60390945d4c8446f5c40c89
Merge: a314966fad61 8e47e15e917f 6ca7227b3e24 cc73176cc91b 7b78f48a0443 5adecf817dd6 7c20078a8197
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Mar 15 08:55:02 2016 -0500

    Merge branches 'pci/aer', 'pci/enumeration', 'pci/kconfig', 'pci/misc', 'pci/virtualization' and 'pci/vpd' into next
    
    * pci/aer:
      PCI/AER: Log aer_inject error injections
      PCI/AER: Log actual error causes in aer_inject
      PCI/AER: Use dev_warn() in aer_inject
      PCI/AER: Fix aer_inject error codes
    
    * pci/enumeration:
      PCI: Fix broken URL for Dell biosdevname
    
    * pci/kconfig:
      PCI: Cleanup pci/pcie/Kconfig whitespace
      PCI: Include pci/hotplug Kconfig directly from pci/Kconfig
      PCI: Include pci/pcie/Kconfig directly from pci/Kconfig
    
    * pci/misc:
      PCI: Add PCI_CLASS_SERIAL_USB_DEVICE definition
      PCI: Add QEMU top-level IDs for (sub)vendor & device
      unicore32: Remove unused HAVE_ARCH_PCI_SET_DMA_MASK definition
      PCI: Consolidate PCI DMA constants and interfaces in linux/pci-dma-compat.h
      PCI: Move pci_dma_* helpers to common code
      frv/PCI: Remove stray pci_{alloc,free}_consistent() declaration
    
    * pci/virtualization:
      PCI: Wait for up to 1000ms after FLR reset
      PCI: Support SR-IOV on any function type
    
    * pci/vpd:
      PCI: Prevent VPD access for buggy devices
      PCI: Sleep rather than busy-wait for VPD access completion
      PCI: Fold struct pci_vpd_pci22 into struct pci_vpd
      PCI: Rename VPD symbols to remove unnecessary "pci22"
      PCI: Remove struct pci_vpd_ops.release function pointer
      PCI: Move pci_vpd_release() from header file to pci/access.c
      PCI: Move pci_read_vpd() and pci_write_vpd() close to other VPD code
      PCI: Determine actual VPD size on first access
      PCI: Use bitfield instead of bool for struct pci_vpd_pci22.busy
      PCI: Allow access to VPD attributes with size 0
      PCI: Update VPD definitions

commit 5adecf817dd630529d6565a242141db2df3239f7
Author: Alex Williamson <alex.williamson@redhat.com>
Date:   Mon Feb 22 13:05:48 2016 -0700

    PCI: Wait for up to 1000ms after FLR reset
    
    Some devices take longer than the spec indicates to return from FLR reset,
    a notable case of this is Intel integrated graphics (IGD), which can often
    take an additional 300ms powering down an attached LCD panel as part of the
    FLR.  Allow devices up to 1000ms, testing every 100ms whether the second
    dword of config space is read as -1.
    
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 602eb4223510..123408e5a1d6 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -3414,6 +3414,29 @@ int pci_wait_for_pending_transaction(struct pci_dev *dev)
 }
 EXPORT_SYMBOL(pci_wait_for_pending_transaction);
 
+/*
+ * We should only need to wait 100ms after FLR, but some devices take longer.
+ * Wait for up to 1000ms for config space to return something other than -1.
+ * Intel IGD requires this when an LCD panel is attached.  We read the 2nd
+ * dword because VFs don't implement the 1st dword.
+ */
+static void pci_flr_wait(struct pci_dev *dev)
+{
+	int i = 0;
+	u32 id;
+
+	do {
+		msleep(100);
+		pci_read_config_dword(dev, PCI_COMMAND, &id);
+	} while (i++ < 10 && id == ~0);
+
+	if (id == ~0)
+		dev_warn(&dev->dev, "Failed to return from FLR\n");
+	else if (i > 1)
+		dev_info(&dev->dev, "Required additional %dms to return from FLR\n",
+			 (i - 1) * 100);
+}
+
 static int pcie_flr(struct pci_dev *dev, int probe)
 {
 	u32 cap;
@@ -3429,7 +3452,7 @@ static int pcie_flr(struct pci_dev *dev, int probe)
 		dev_err(&dev->dev, "timed out waiting for pending transaction; performing function level reset anyway\n");
 
 	pcie_capability_set_word(dev, PCI_EXP_DEVCTL, PCI_EXP_DEVCTL_BCR_FLR);
-	msleep(100);
+	pci_flr_wait(dev);
 	return 0;
 }
 
@@ -3459,7 +3482,7 @@ static int pci_af_flr(struct pci_dev *dev, int probe)
 		dev_err(&dev->dev, "timed out waiting for pending transaction; performing AF function level reset anyway\n");
 
 	pci_write_config_byte(dev, pos + PCI_AF_CTRL, PCI_AF_CTRL_FLR);
-	msleep(100);
+	pci_flr_wait(dev);
 	return 0;
 }
 

commit 54c6e2dd00c313d0add58e5befe62fe6f286d03b
Author: Krzysztof =?utf-8?Q?Ha=C5=82asa?= <khalasa@piap.pl>
Date:   Tue Mar 1 07:07:18 2016 +0100

    PCI: Allow a NULL "parent" pointer in pci_bus_assign_domain_nr()
    
    pci_create_root_bus() passes a "parent" pointer to
    pci_bus_assign_domain_nr().  When CONFIG_PCI_DOMAINS_GENERIC is defined,
    pci_bus_assign_domain_nr() dereferences that pointer.  Many callers of
    pci_create_root_bus() supply a NULL "parent" pointer, which leads to a NULL
    pointer dereference error.
    
    7c674700098c ("PCI: Move domain assignment from arm64 to generic code")
    moved the "parent" dereference from arm64 to generic code.  Only arm64 used
    that code (because only arm64 defined CONFIG_PCI_DOMAINS_GENERIC), and it
    always supplied a valid "parent" pointer.  Other arches supplied NULL
    "parent" pointers but didn't defined CONFIG_PCI_DOMAINS_GENERIC, so they
    used a no-op version of pci_bus_assign_domain_nr().
    
    8c7d14746abc ("ARM/PCI: Move to generic PCI domains") defined
    CONFIG_PCI_DOMAINS_GENERIC on ARM, and many ARM platforms use
    pci_common_init(), which supplies a NULL "parent" pointer.
    These platforms (cns3xxx, dove, footbridge, iop13xx, etc.) crash
    with a NULL pointer dereference like this while probing PCI:
    
      Unable to handle kernel NULL pointer dereference at virtual address 000000a4
      PC is at pci_bus_assign_domain_nr+0x10/0x84
      LR is at pci_create_root_bus+0x48/0x2e4
      Kernel panic - not syncing: Attempted to kill init!
    
    [bhelgaas: changelog, add "Reported:" and "Fixes:" tags]
    Reported: http://forum.doozan.com/read.php?2,17868,22070,quote=1
    Fixes: 8c7d14746abc ("ARM/PCI: Move to generic PCI domains")
    Fixes: 7c674700098c ("PCI: Move domain assignment from arm64 to generic code")
    Signed-off-by: Krzysztof Hałasa <khalasa@piap.pl>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    CC: stable@vger.kernel.org      # v4.0+

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 602eb4223510..f89db3af0607 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -4772,8 +4772,10 @@ int pci_get_new_domain_nr(void)
 void pci_bus_assign_domain_nr(struct pci_bus *bus, struct device *parent)
 {
 	static int use_dt_domains = -1;
-	int domain = of_get_pci_domain_nr(parent->of_node);
+	int domain = -1;
 
+	if (parent)
+		domain = of_get_pci_domain_nr(parent->of_node);
 	/*
 	 * Check DT domain and use_dt_domains values.
 	 *

commit fe537670eab767157eecc50538bd28e8d9b0ce9f
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Mar 7 11:39:16 2016 -0600

    PCI: Consolidate PCI DMA constants and interfaces in linux/pci-dma-compat.h
    
    Christoph added a generic include/linux/pci-dma-compat.h, so now there's
    one place with most of the PCI DMA interfaces.  Move more PCI DMA-related
    things there:
    
      - The PCI_DMA_* direction constants from linux/pci.h
      - The pci_set_dma_max_seg_size() and pci_set_dma_seg_boundary()
        CONFIG_PCI implementations from drivers/pci/pci.c
      - The pci_set_dma_max_seg_size() and pci_set_dma_seg_boundary()
        !CONFIG_PCI stubs from linux/pci.h
      - The pci_set_dma_mask() and pci_set_consistent_dma_mask()
        !CONFIG_PCI stubs from linux/pci.h
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 64c0a1215f84..0a9c8db51c08 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -3385,18 +3385,6 @@ bool pci_check_and_unmask_intx(struct pci_dev *dev)
 }
 EXPORT_SYMBOL_GPL(pci_check_and_unmask_intx);
 
-int pci_set_dma_max_seg_size(struct pci_dev *dev, unsigned int size)
-{
-	return dma_set_max_seg_size(&dev->dev, size);
-}
-EXPORT_SYMBOL(pci_set_dma_max_seg_size);
-
-int pci_set_dma_seg_boundary(struct pci_dev *dev, unsigned long mask)
-{
-	return dma_set_seg_boundary(&dev->dev, mask);
-}
-EXPORT_SYMBOL(pci_set_dma_seg_boundary);
-
 /**
  * pci_wait_for_pending_transaction - waits for pending transaction
  * @dev: the PCI device to operate on

commit 5bd28338d681dcbde2c4bee4ebea0c4e0dfcd9e4
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Feb 5 14:57:54 2016 -0600

    PCI: Remove includes of empty asm-generic/pci-bridge.h
    
    include/asm-generic/pci-bridge.h is now empty, so remove every #include of
    it.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Will Deacon <will.deacon@arm.com> (arm64)

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 602eb4223510..64c0a1215f84 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -25,7 +25,6 @@
 #include <linux/device.h>
 #include <linux/pm_runtime.h>
 #include <linux/pci_hotplug.h>
-#include <asm-generic/pci-bridge.h>
 #include <asm/setup.h>
 #include <linux/aer.h>
 #include "pci.h"

commit d43421565bf0510d35e6a39ebf96586ad486f3aa
Merge: 859e76254490 9662e32c810a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jan 21 11:52:16 2016 -0800

    Merge tag 'pci-v4.5-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI updates from Bjorn Helgaas:
     "PCI changes for the v4.5 merge window:
    
      Enumeration:
       - Simplify config space size computation (Bjorn Helgaas)
       - Avoid iterating through ROM outside the resource window (Edward O'Callaghan)
       - Support PCIe devices with short cfg_size (Jason S. McMullan)
       - Add Netronome vendor and device IDs (Jason S. McMullan)
       - Limit config space size for Netronome NFP6000 family (Jason S. McMullan)
       - Add Netronome NFP4000 PF device ID (Simon Horman)
       - Limit config space size for Netronome NFP4000 (Simon Horman)
       - Print warnings for all invalid expansion ROM headers (Vladis Dronov)
    
      Resource management:
       - Fix minimum allocation address overwrite (Christoph Biedl)
    
      PCI device hotplug:
       - acpiphp_ibm: Fix null dereferences on null ibm_slot (Colin Ian King)
       - pciehp: Always protect pciehp_disable_slot() with hotplug mutex (Guenter Roeck)
       - shpchp: Constify hpc_ops structure (Julia Lawall)
       - ibmphp: Remove unneeded NULL test (Julia Lawall)
    
      Power management:
       - Make ASPM sysfs link_state_store() consistent with link_state_show() (Andy Lutomirski)
    
      Virtualization
       - Add function 1 DMA alias quirk for Lite-On/Plextor M6e/Marvell 88SS9183 (Tim Sander)
    
      MSI:
       - Remove empty pci_msi_init_pci_dev() (Bjorn Helgaas)
       - Mark PCIe/PCI (MSI) IRQ cascade handlers as IRQF_NO_THREAD (Grygorii Strashko)
       - Initialize MSI capability for all architectures (Guilherme G. Piccoli)
       - Relax msi_domain_alloc() to support parentless MSI irqdomains (Liu Jiang)
    
      ARM Versatile host bridge driver:
       - Remove unused pci_sys_data structures (Lorenzo Pieralisi)
    
      Broadcom iProc host bridge driver:
       - Hide CONFIG_PCIE_IPROC (Arnd Bergmann)
       - Do not use 0x in front of %pap (Dmitry V. Krivenok)
       - Update iProc PCIe device tree binding (Ray Jui)
       - Add PAXC interface support (Ray Jui)
       - Add iProc PCIe MSI device tree binding (Ray Jui)
       - Add iProc PCIe MSI support (Ray Jui)
    
      Freescale i.MX6 host bridge driver:
       - Use gpio_set_value_cansleep() (Fabio Estevam)
       - Add support for active-low reset GPIO (Petr Štetiar)
    
      HiSilicon host bridge driver:
       - Add support for HiSilicon Hip06 PCIe host controllers (Gabriele Paoloni)
    
      Intel VMD host bridge driver:
       - Export irq_domain_set_info() for module use (Keith Busch)
       - x86/PCI: Allow DMA ops specific to a PCI domain (Keith Busch)
       - Use 32 bit PCI domain numbers (Keith Busch)
       - Add driver for Intel Volume Management Device (VMD) (Keith Busch)
    
      Qualcomm host bridge driver:
       - Document PCIe devicetree bindings (Stanimir Varbanov)
       - Add Qualcomm PCIe controller driver (Stanimir Varbanov)
       - dts: apq8064: add PCIe devicetree node (Stanimir Varbanov)
       - dts: ifc6410: enable PCIe DT node for this board (Stanimir Varbanov)
    
      Renesas R-Car host bridge driver:
       - Add support for R-Car H3 to pcie-rcar (Harunobu Kurokawa)
       - Allow DT to override default window settings (Phil Edworthy)
       - Convert to DT resource parsing API (Phil Edworthy)
       - Revert "PCI: rcar: Build pcie-rcar.c only on ARM" (Phil Edworthy)
       - Remove unused pci_sys_data struct from pcie-rcar (Phil Edworthy)
       - Add runtime PM support to pcie-rcar (Phil Edworthy)
       - Add Gen2 PHY setup to pcie-rcar (Phil Edworthy)
       - Add gen2 fallback compatibility string for pci-rcar-gen2 (Simon Horman)
       - Add gen2 fallback compatibility string for pcie-rcar (Simon Horman)
    
      Synopsys DesignWare host bridge driver:
       - Simplify control flow (Bjorn Helgaas)
       - Make config accessor override checking symmetric (Bjorn Helgaas)
       - Ensure ATU is enabled before IO/conf space accesses (Stanimir Varbanov)
    
      Miscellaneous:
       - Add of_pci_get_host_bridge_resources() stub (Arnd Bergmann)
       - Check for PCI_HEADER_TYPE_BRIDGE equality, not bitmask (Bjorn Helgaas)
       - Fix all whitespace issues (Bogicevic Sasa)
       - x86/PCI: Simplify pci_bios_{read,write} (Geliang Tang)
       - Use to_pci_dev() instead of open-coding it (Geliang Tang)
       - Use kobj_to_dev() instead of open-coding it (Geliang Tang)
       - Use list_for_each_entry() to simplify code (Geliang Tang)
       - Fix typos in <linux/msi.h> (Thomas Petazzoni)
       - x86/PCI: Clarify AMD Fam10h config access restrictions comment (Tomasz Nowicki)"
    
    * tag 'pci-v4.5-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (58 commits)
      PCI: Add function 1 DMA alias quirk for Lite-On/Plextor M6e/Marvell 88SS9183
      PCI: Limit config space size for Netronome NFP4000
      PCI: Add Netronome NFP4000 PF device ID
      x86/PCI: Add driver for Intel Volume Management Device (VMD)
      PCI/AER: Use 32 bit PCI domain numbers
      x86/PCI: Allow DMA ops specific to a PCI domain
      irqdomain: Export irq_domain_set_info() for module use
      PCI: host: Add of_pci_get_host_bridge_resources() stub
      genirq/MSI: Relax msi_domain_alloc() to support parentless MSI irqdomains
      PCI: rcar: Add Gen2 PHY setup to pcie-rcar
      PCI: rcar: Add runtime PM support to pcie-rcar
      PCI: designware: Make config accessor override checking symmetric
      PCI: ibmphp: Remove unneeded NULL test
      ARM: dts: ifc6410: enable PCIe DT node for this board
      ARM: dts: apq8064: add PCIe devicetree node
      PCI: hotplug: Use list_for_each_entry() to simplify code
      PCI: rcar: Remove unused pci_sys_data struct from pcie-rcar
      PCI: hisi: Add support for HiSilicon Hip06 PCIe host controllers
      PCI: Avoid iterating through memory outside the resource window
      PCI: acpiphp_ibm: Fix null dereferences on null ibm_slot
      ...

commit f3d2f1655b543e2e8aaeaac0e1f6250c09fe1692
Author: Geliang Tang <geliangtang@163.com>
Date:   Fri Jan 8 12:05:39 2016 -0600

    PCI: Use to_pci_dev() instead of open-coding it
    
    Use to_pci_dev() instead of open-coding it.
    
    Signed-off-by: Geliang Tang <geliangtang@163.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index db2e22707678..49e3715477d1 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1417,7 +1417,7 @@ struct pci_devres {
 
 static void pcim_release(struct device *gendev, void *res)
 {
-	struct pci_dev *dev = container_of(gendev, struct pci_dev, dev);
+	struct pci_dev *dev = to_pci_dev(gendev);
 	struct pci_devres *this = res;
 	int i;
 

commit ff3ce480e8b59fbc0f459476fe1b5451464592a5
Author: Bogicevic Sasa <brutallesale@gmail.com>
Date:   Sun Dec 27 13:21:11 2015 -0800

    PCI: Fix all whitespace issues
    
    Fix all whitespace issues (missing or needed whitespace) in all files in
    drivers/pci.  Code is compiled with allyesconfig before and after code
    changes and objects are recorded and checked with objdiff and they are not
    changed after this commit.
    
    Signed-off-by: Bogicevic Sasa <brutallesale@gmail.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 314db8c1047a..db2e22707678 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1534,7 +1534,7 @@ void __weak pcibios_release_device(struct pci_dev *dev) {}
  * is the default implementation. Architecture implementations can
  * override this.
  */
-void __weak pcibios_disable_device (struct pci_dev *dev) {}
+void __weak pcibios_disable_device(struct pci_dev *dev) {}
 
 /**
  * pcibios_penalize_isa_irq - penalize an ISA IRQ

commit 299f2ffed329c1a2ea8d6e90f0df26b885d16e08
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Sun Dec 6 17:33:45 2015 +0100

    PCI / PM: constify pci_platform_pm_ops structure
    
    The pci_platform_pm_ops structure is never modified, so declare it as
    const.
    
    Done with the help of Coccinelle.
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 314db8c1047a..d1a7105b9276 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -527,9 +527,9 @@ static void pci_restore_bars(struct pci_dev *dev)
 		pci_update_resource(dev, i);
 }
 
-static struct pci_platform_pm_ops *pci_platform_pm;
+static const struct pci_platform_pm_ops *pci_platform_pm;
 
-int pci_set_platform_pm(struct pci_platform_pm_ops *ops)
+int pci_set_platform_pm(const struct pci_platform_pm_ops *ops)
 {
 	if (!ops->is_manageable || !ops->set_state || !ops->choose_state
 	    || !ops->sleep_wake)

commit 3c87b791880a2e0dad281c6494b94968d412bfa3
Merge: 0280d1a099da 7225107e1582
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Nov 6 11:29:53 2015 -0800

    Merge tag 'pci-v4.4-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI updates from Bjorn Helgaas:
     "Resource management:
       - Add support for Enhanced Allocation devices (Sean O. Stalley)
       - Add Enhanced Allocation register entries (Sean O. Stalley)
       - Handle IORESOURCE_PCI_FIXED when sizing resources (David Daney)
       - Handle IORESOURCE_PCI_FIXED when assigning resources (David Daney)
       - Handle Enhanced Allocation capability for SR-IOV devices (David Daney)
       - Clear IORESOURCE_UNSET when reverting to firmware-assigned address (Bjorn Helgaas)
       - Make Enhanced Allocation bitmasks more obvious (Bjorn Helgaas)
       - Expand Enhanced Allocation BAR output (Bjorn Helgaas)
       - Add of_pci_check_probe_only to parse "linux,pci-probe-only" (Marc Zyngier)
       - Fix lookup of linux,pci-probe-only property (Marc Zyngier)
       - Add sparc mem64 resource parsing for root bus (Yinghai Lu)
    
      PCI device hotplug:
       - pciehp: Queue power work requests in dedicated function (Guenter Roeck)
    
      Driver binding:
       - Add builtin_pci_driver() to avoid registration boilerplate (Paul Gortmaker)
    
      Virtualization:
       - Set SR-IOV NumVFs to zero after enumeration (Alexander Duyck)
       - Remove redundant validation of SR-IOV offset/stride registers (Alexander Duyck)
       - Remove VFs in reverse order if virtfn_add() fails (Alexander Duyck)
       - Reorder pcibios_sriov_disable() (Alexander Duyck)
       - Wait 1 second between disabling VFs and clearing NumVFs (Alexander Duyck)
       - Fix sriov_enable() error path for pcibios_enable_sriov() failures (Alexander Duyck)
       - Enable SR-IOV ARI Capable Hierarchy before reading TotalVFs (Ben Shelton)
       - Don't try to restore VF BARs (Wei Yang)
    
      MSI:
       - Don't alloc pcibios-irq when MSI is enabled (Joerg Roedel)
       - Add msi_controller setup_irqs() method for special multivector setup (Lucas Stach)
       - Export all remapped MSIs to sysfs attributes (Romain Bezut)
       - Disable MSI on SiS 761 (Ondrej Zary)
    
      AER:
       - Clear error status registers during enumeration and restore (Taku Izumi)
    
      Generic host bridge driver:
       - Fix lookup of linux,pci-probe-only property (Marc Zyngier)
       - Allow multiple hosts with different map_bus() methods (David Daney)
       - Pass starting bus number to pci_scan_root_bus() (David Daney)
       - Fix address window calculation for non-zero starting bus (David Daney)
    
      Altera host bridge driver:
       - Add msi.h to ARM Kbuild (Ley Foon Tan)
       - Add Altera PCIe host controller driver (Ley Foon Tan)
       - Add Altera PCIe MSI driver (Ley Foon Tan)
    
      APM X-Gene host bridge driver:
       - Remove msi_controller assignment (Duc Dang)
    
      Broadcom iProc host bridge driver:
       - Fix header comment "Corporation" misspelling (Florian Fainelli)
       - Fix code comment to match code (Ray Jui)
       - Remove unused struct iproc_pcie.irqs[] (Ray Jui)
       - Call pci_fixup_irqs() for ARM64 as well as ARM (Ray Jui)
       - Fix PCIe reset logic (Ray Jui)
       - Improve link detection logic (Ray Jui)
       - Update PCIe device tree bindings (Ray Jui)
       - Add outbound mapping support (Ray Jui)
    
      Freescale i.MX6 host bridge driver:
       - Return real error code from imx6_add_pcie_port() (Fabio Estevam)
       - Add PCIE_PHY_RX_ASIC_OUT_VALID definition (Fabio Estevam)
    
      Freescale Layerscape host bridge driver:
       - Remove ls_pcie_establish_link() (Minghuan Lian)
       - Ignore PCIe controllers in Endpoint mode (Minghuan Lian)
       - Factor out SCFG related function (Minghuan Lian)
       - Update ls_add_pcie_port() (Minghuan Lian)
       - Remove unused fields from struct ls_pcie (Minghuan Lian)
       - Add support for LS1043a and LS2080a (Minghuan Lian)
       - Add ls_pcie_msi_host_init() (Minghuan Lian)
    
      HiSilicon host bridge driver:
       - Add HiSilicon SoC Hip05 PCIe driver (Zhou Wang)
    
      Marvell MVEBU host bridge driver:
       - Return zero for reserved or unimplemented config space (Russell King)
       - Use exact config access size; don't read/modify/write (Russell King)
       - Use of_get_available_child_count() (Russell King)
       - Use for_each_available_child_of_node() to walk child nodes (Russell King)
       - Report full node name when reporting a DT error (Russell King)
       - Use port->name rather than "PCIe%d.%d" (Russell King)
       - Move port parsing and resource claiming to  separate function (Russell King)
       - Fix memory leaks and refcount leaks (Russell King)
       - Split port parsing and resource claiming from  port setup (Russell King)
       - Use gpio_set_value_cansleep() (Russell King)
       - Use devm_kcalloc() to allocate an array (Russell King)
       - Use gpio_desc to carry around gpio (Russell King)
       - Improve clock/reset handling (Russell King)
       - Add PCI Express root complex capability block (Russell King)
       - Remove code restricting accesses to slot 0 (Russell King)
    
      NVIDIA Tegra host bridge driver:
       - Wrap static pgprot_t initializer with __pgprot() (Ard Biesheuvel)
    
      Renesas R-Car host bridge driver:
       - Build pci-rcar-gen2.c only on ARM (Geert Uytterhoeven)
       - Build pcie-rcar.c only on ARM (Geert Uytterhoeven)
       - Make PCI aware of the I/O resources (Phil Edworthy)
       - Remove dependency on ARM-specific struct hw_pci (Phil Edworthy)
       - Set root bus nr to that provided in DT (Phil Edworthy)
       - Fix I/O offset for multiple host bridges (Phil Edworthy)
    
      ST Microelectronics SPEAr13xx host bridge driver:
       - Fix dw_pcie_cfg_read/write() usage (Gabriele Paoloni)
    
      Synopsys DesignWare host bridge driver:
       - Make "clocks" and "clock-names" optional DT properties (Bhupesh Sharma)
       - Use exact access size in dw_pcie_cfg_read() (Gabriele Paoloni)
       - Simplify dw_pcie_cfg_read/write() interfaces (Gabriele Paoloni)
       - Require config accesses to be naturally aligned (Gabriele Paoloni)
       - Make "num-lanes" an optional DT property (Gabriele Paoloni)
       - Move calculation of bus addresses to DRA7xx (Gabriele Paoloni)
       - Replace ARM pci_sys_data->align_resource with global function pointer (Gabriele Paoloni)
       - Factor out MSI msg setup (Lucas Stach)
       - Implement multivector MSI IRQ setup (Lucas Stach)
       - Make get_msi_addr() return phys_addr_t, not u32 (Lucas Stach)
       - Set up high part of MSI target address (Lucas Stach)
       - Fix PORT_LOGIC_LINK_WIDTH_MASK (Zhou Wang)
       - Revert "PCI: designware: Program ATU with untranslated address" (Zhou Wang)
       - Use of_pci_get_host_bridge_resources() to parse DT (Zhou Wang)
       - Make driver arch-agnostic (Zhou Wang)
    
      Miscellaneous:
       - Make x86 pci_subsys_init() static (Alexander Kuleshov)
       - Turn off Request Attributes to avoid Chelsio T5 Completion erratum (Hariprasad Shenai)"
    
    * tag 'pci-v4.4-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (94 commits)
      PCI: altera: Add Altera PCIe MSI driver
      PCI: hisi: Add HiSilicon SoC Hip05 PCIe driver
      PCI: layerscape: Add ls_pcie_msi_host_init()
      PCI: layerscape: Add support for LS1043a and LS2080a
      PCI: layerscape: Remove unused fields from struct ls_pcie
      PCI: layerscape: Update ls_add_pcie_port()
      PCI: layerscape: Factor out SCFG related function
      PCI: layerscape: Ignore PCIe controllers in Endpoint mode
      PCI: layerscape: Remove ls_pcie_establish_link()
      PCI: designware: Make "clocks" and "clock-names" optional DT properties
      PCI: designware: Make driver arch-agnostic
      ARM/PCI: Replace pci_sys_data->align_resource with global function pointer
      PCI: designware: Use of_pci_get_host_bridge_resources() to parse DT
      Revert "PCI: designware: Program ATU with untranslated address"
      PCI: designware: Move calculation of bus addresses to DRA7xx
      PCI: designware: Make "num-lanes" an optional DT property
      PCI: designware: Require config accesses to be naturally aligned
      PCI: designware: Simplify dw_pcie_cfg_read/write() interfaces
      PCI: designware: Use exact access size in dw_pcie_cfg_read()
      PCI: spear: Fix dw_pcie_cfg_read/write() usage
      ...

commit 1f9a30ec2a4acee9a4d664e7405c7eb26a7c4b5e
Merge: 6ff33f3902c3 b07461a8e45b bee67756eb4a c56d4450eb68 8affb487d4a4 af86fa4001ca c23b613507b8
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Nov 2 15:57:03 2015 -0600

    Merge branches 'pci/aer', 'pci/hotplug', 'pci/misc', 'pci/msi', 'pci/resource' and 'pci/virtualization' into next
    
    * pci/aer:
      PCI/AER: Clear error status registers during enumeration and restore
    
    * pci/hotplug:
      PCI: pciehp: Queue power work requests in dedicated function
    
    * pci/misc:
      PCI: Turn off Request Attributes to avoid Chelsio T5 Completion erratum
      x86/PCI: Make pci_subsys_init() static
      PCI: Add builtin_pci_driver() to avoid registration boilerplate
      PCI: Remove unnecessary "if" statement
    
    * pci/msi:
      x86/PCI: Don't alloc pcibios-irq when MSI is enabled
      PCI/MSI: Export all remapped MSIs to sysfs attributes
      PCI: Disable MSI on SiS 761
    
    * pci/resource:
      sparc/PCI: Add mem64 resource parsing for root bus
      PCI: Expand Enhanced Allocation BAR output
      PCI: Make Enhanced Allocation bitmasks more obvious
      PCI: Handle Enhanced Allocation capability for SR-IOV devices
      PCI: Add support for Enhanced Allocation devices
      PCI: Add Enhanced Allocation register entries
      PCI: Handle IORESOURCE_PCI_FIXED when assigning resources
      PCI: Handle IORESOURCE_PCI_FIXED when sizing resources
      PCI: Clear IORESOURCE_UNSET when reverting to firmware-assigned address
    
    * pci/virtualization:
      PCI: Fix sriov_enable() error path for pcibios_enable_sriov() failures
      PCI: Wait 1 second between disabling VFs and clearing NumVFs
      PCI: Reorder pcibios_sriov_disable()
      PCI: Remove VFs in reverse order if virtfn_add() fails
      PCI: Remove redundant validation of SR-IOV offset/stride registers
      PCI: Set SR-IOV NumVFs to zero after enumeration
      PCI: Enable SR-IOV ARI Capable Hierarchy before reading TotalVFs
      PCI: Don't try to restore VF BARs

commit 597becb4adb7d57b8e9d857a68f764ce96a141b8
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Oct 29 17:35:40 2015 -0500

    PCI: Expand Enhanced Allocation BAR output
    
    An Enhanced Allocation Capability entry with BEI 0 fills in
    dev->resource[0] just like a real BAR 0 would, but non-EA experts might not
    connect "EA - BEI 0" with BAR 0.
    
    Decode the EA jargon a little bit, e.g., change this:
    
      pci 0002:01:00.0: EA - BEI  0, Prop 0x00: [mem 0x84300000-0x84303fff]
    
    to this:
    
      pci 0002:01:00.0: BAR 0: [mem 0x84300000-0x84303fff] (from Enhanced Allocation, properties 0x00)
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index e8330b68cecd..3a1454e6dd4a 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2293,8 +2293,20 @@ static int pci_ea_read(struct pci_dev *dev, int offset)
 	res->start = start;
 	res->end = end;
 	res->flags = flags;
-	dev_printk(KERN_DEBUG, &dev->dev, "EA - BEI %2u, Prop 0x%02x: %pR\n",
-		   bei, prop, res);
+
+	if (bei <= PCI_EA_BEI_BAR5)
+		dev_printk(KERN_DEBUG, &dev->dev, "BAR %d: %pR (from Enhanced Allocation, properties %#02x)\n",
+			   bei, res, prop);
+	else if (bei == PCI_EA_BEI_ROM)
+		dev_printk(KERN_DEBUG, &dev->dev, "ROM: %pR (from Enhanced Allocation, properties %#02x)\n",
+			   res, prop);
+	else if (bei >= PCI_EA_BEI_VF_BAR0 && bei <= PCI_EA_BEI_VF_BAR5)
+		dev_printk(KERN_DEBUG, &dev->dev, "VF BAR %d: %pR (from Enhanced Allocation, properties %#02x)\n",
+			   bei - PCI_EA_BEI_VF_BAR0, res, prop);
+	else
+		dev_printk(KERN_DEBUG, &dev->dev, "BEI %d res: %pR (from Enhanced Allocation, properties %#02x)\n",
+			   bei, res, prop);
+
 out:
 	return offset + ent_size;
 }

commit 26635112d4d057c9ea38f6284423a30a41a09240
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Oct 29 17:35:40 2015 -0500

    PCI: Make Enhanced Allocation bitmasks more obvious
    
    Expand bitmask #defines completely.  This puts the shift in the code
    instead of in the #define, but it makes it more obvious in the header file
    how fields in the register are laid out.
    
    No functional change.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 364f98b30130..e8330b68cecd 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2195,7 +2195,7 @@ static int pci_ea_read(struct pci_dev *dev, int offset)
 	int ent_size, ent_offset = offset;
 	resource_size_t start, end;
 	unsigned long flags;
-	u32 dw0, base, max_offset;
+	u32 dw0, bei, base, max_offset;
 	u8 prop;
 	bool support_64 = (sizeof(resource_size_t) >= 8);
 
@@ -2208,20 +2208,21 @@ static int pci_ea_read(struct pci_dev *dev, int offset)
 	if (!(dw0 & PCI_EA_ENABLE)) /* Entry not enabled */
 		goto out;
 
-	prop = PCI_EA_PP(dw0);
+	bei = (dw0 & PCI_EA_BEI) >> 4;
+	prop = (dw0 & PCI_EA_PP) >> 8;
+
 	/*
 	 * If the Property is in the reserved range, try the Secondary
 	 * Property instead.
 	 */
 	if (prop > PCI_EA_P_BRIDGE_IO && prop < PCI_EA_P_MEM_RESERVED)
-		prop = PCI_EA_SP(dw0);
+		prop = (dw0 & PCI_EA_SP) >> 16;
 	if (prop > PCI_EA_P_BRIDGE_IO)
 		goto out;
 
-	res = pci_ea_get_resource(dev, PCI_EA_BEI(dw0), prop);
+	res = pci_ea_get_resource(dev, bei, prop);
 	if (!res) {
-		dev_err(&dev->dev, "Unsupported EA entry BEI: %u\n",
-			PCI_EA_BEI(dw0));
+		dev_err(&dev->dev, "Unsupported EA entry BEI: %u\n", bei);
 		goto out;
 	}
 
@@ -2293,7 +2294,7 @@ static int pci_ea_read(struct pci_dev *dev, int offset)
 	res->end = end;
 	res->flags = flags;
 	dev_printk(KERN_DEBUG, &dev->dev, "EA - BEI %2u, Prop 0x%02x: %pR\n",
-		   PCI_EA_BEI(dw0), prop, res);
+		   bei, prop, res);
 out:
 	return offset + ent_size;
 }

commit 111839917fccf4f74d50ad937321acc6a07eb9c3
Author: David Daney <david.daney@cavium.com>
Date:   Thu Oct 29 17:35:40 2015 -0500

    PCI: Handle Enhanced Allocation capability for SR-IOV devices
    
    SR-IOV BARs can be specified via EA entries.  Extend the EA parser to
    extract the SRIOV BAR resources, and modify sriov_init() to use resources
    previously obtained via EA.
    
    Signed-off-by: David Daney <david.daney@cavium.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Sean O. Stalley <sean.stalley@intel.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 8d796c02ee90..364f98b30130 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2176,6 +2176,12 @@ static struct resource *pci_ea_get_resource(struct pci_dev *dev, u8 bei,
 {
 	if (bei <= PCI_EA_BEI_BAR5 && prop <= PCI_EA_P_IO)
 		return &dev->resource[bei];
+#ifdef CONFIG_PCI_IOV
+	else if (bei >= PCI_EA_BEI_VF_BAR0 && bei <= PCI_EA_BEI_VF_BAR5 &&
+		 (prop == PCI_EA_P_VF_MEM || prop == PCI_EA_P_VF_MEM_PREFETCH))
+		return &dev->resource[PCI_IOV_RESOURCES +
+				      bei - PCI_EA_BEI_VF_BAR0];
+#endif
 	else if (bei == PCI_EA_BEI_ROM)
 		return &dev->resource[PCI_ROM_RESOURCE];
 	else

commit 938174e59f83354251a75a2b90171e0ffdf6f1d7
Author: Sean O. Stalley <sean.stalley@intel.com>
Date:   Thu Oct 29 17:35:39 2015 -0500

    PCI: Add support for Enhanced Allocation devices
    
    Add support for devices using Enhanced Allocation entries instead of BARs.
    This allows the kernel to parse the EA Extended Capability structure in PCI
    config space and claim the BAR-equivalent resources.
    
    See https://pcisig.com/sites/default/files/specification_documents/ECN_Enhanced_Allocation_23_Oct_2014_Final.pdf
    
    [bhelgaas: add spec URL, s/pci_ea_set_flags/pci_ea_flags/, consolidate
    declarations, print unknown property in hex to match spec]
    Signed-off-by: Sean O. Stalley <sean.stalley@intel.com>
    [david.daney@cavium.com: Add more support/checking for Entry Properties,
    allow EA behind bridges, rewrite some error messages.]
    Signed-off-by: David Daney <david.daney@cavium.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 6a9a1116f1eb..8d796c02ee90 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2148,6 +2148,179 @@ void pci_pm_init(struct pci_dev *dev)
 	}
 }
 
+static unsigned long pci_ea_flags(struct pci_dev *dev, u8 prop)
+{
+	unsigned long flags = IORESOURCE_PCI_FIXED;
+
+	switch (prop) {
+	case PCI_EA_P_MEM:
+	case PCI_EA_P_VF_MEM:
+		flags |= IORESOURCE_MEM;
+		break;
+	case PCI_EA_P_MEM_PREFETCH:
+	case PCI_EA_P_VF_MEM_PREFETCH:
+		flags |= IORESOURCE_MEM | IORESOURCE_PREFETCH;
+		break;
+	case PCI_EA_P_IO:
+		flags |= IORESOURCE_IO;
+		break;
+	default:
+		return 0;
+	}
+
+	return flags;
+}
+
+static struct resource *pci_ea_get_resource(struct pci_dev *dev, u8 bei,
+					    u8 prop)
+{
+	if (bei <= PCI_EA_BEI_BAR5 && prop <= PCI_EA_P_IO)
+		return &dev->resource[bei];
+	else if (bei == PCI_EA_BEI_ROM)
+		return &dev->resource[PCI_ROM_RESOURCE];
+	else
+		return NULL;
+}
+
+/* Read an Enhanced Allocation (EA) entry */
+static int pci_ea_read(struct pci_dev *dev, int offset)
+{
+	struct resource *res;
+	int ent_size, ent_offset = offset;
+	resource_size_t start, end;
+	unsigned long flags;
+	u32 dw0, base, max_offset;
+	u8 prop;
+	bool support_64 = (sizeof(resource_size_t) >= 8);
+
+	pci_read_config_dword(dev, ent_offset, &dw0);
+	ent_offset += 4;
+
+	/* Entry size field indicates DWORDs after 1st */
+	ent_size = ((dw0 & PCI_EA_ES) + 1) << 2;
+
+	if (!(dw0 & PCI_EA_ENABLE)) /* Entry not enabled */
+		goto out;
+
+	prop = PCI_EA_PP(dw0);
+	/*
+	 * If the Property is in the reserved range, try the Secondary
+	 * Property instead.
+	 */
+	if (prop > PCI_EA_P_BRIDGE_IO && prop < PCI_EA_P_MEM_RESERVED)
+		prop = PCI_EA_SP(dw0);
+	if (prop > PCI_EA_P_BRIDGE_IO)
+		goto out;
+
+	res = pci_ea_get_resource(dev, PCI_EA_BEI(dw0), prop);
+	if (!res) {
+		dev_err(&dev->dev, "Unsupported EA entry BEI: %u\n",
+			PCI_EA_BEI(dw0));
+		goto out;
+	}
+
+	flags = pci_ea_flags(dev, prop);
+	if (!flags) {
+		dev_err(&dev->dev, "Unsupported EA properties: %#x\n", prop);
+		goto out;
+	}
+
+	/* Read Base */
+	pci_read_config_dword(dev, ent_offset, &base);
+	start = (base & PCI_EA_FIELD_MASK);
+	ent_offset += 4;
+
+	/* Read MaxOffset */
+	pci_read_config_dword(dev, ent_offset, &max_offset);
+	ent_offset += 4;
+
+	/* Read Base MSBs (if 64-bit entry) */
+	if (base & PCI_EA_IS_64) {
+		u32 base_upper;
+
+		pci_read_config_dword(dev, ent_offset, &base_upper);
+		ent_offset += 4;
+
+		flags |= IORESOURCE_MEM_64;
+
+		/* entry starts above 32-bit boundary, can't use */
+		if (!support_64 && base_upper)
+			goto out;
+
+		if (support_64)
+			start |= ((u64)base_upper << 32);
+	}
+
+	end = start + (max_offset | 0x03);
+
+	/* Read MaxOffset MSBs (if 64-bit entry) */
+	if (max_offset & PCI_EA_IS_64) {
+		u32 max_offset_upper;
+
+		pci_read_config_dword(dev, ent_offset, &max_offset_upper);
+		ent_offset += 4;
+
+		flags |= IORESOURCE_MEM_64;
+
+		/* entry too big, can't use */
+		if (!support_64 && max_offset_upper)
+			goto out;
+
+		if (support_64)
+			end += ((u64)max_offset_upper << 32);
+	}
+
+	if (end < start) {
+		dev_err(&dev->dev, "EA Entry crosses address boundary\n");
+		goto out;
+	}
+
+	if (ent_size != ent_offset - offset) {
+		dev_err(&dev->dev,
+			"EA Entry Size (%d) does not match length read (%d)\n",
+			ent_size, ent_offset - offset);
+		goto out;
+	}
+
+	res->name = pci_name(dev);
+	res->start = start;
+	res->end = end;
+	res->flags = flags;
+	dev_printk(KERN_DEBUG, &dev->dev, "EA - BEI %2u, Prop 0x%02x: %pR\n",
+		   PCI_EA_BEI(dw0), prop, res);
+out:
+	return offset + ent_size;
+}
+
+/* Enhanced Allocation Initalization */
+void pci_ea_init(struct pci_dev *dev)
+{
+	int ea;
+	u8 num_ent;
+	int offset;
+	int i;
+
+	/* find PCI EA capability in list */
+	ea = pci_find_capability(dev, PCI_CAP_ID_EA);
+	if (!ea)
+		return;
+
+	/* determine the number of entries */
+	pci_bus_read_config_byte(dev->bus, dev->devfn, ea + PCI_EA_NUM_ENT,
+					&num_ent);
+	num_ent &= PCI_EA_NUM_ENT_MASK;
+
+	offset = ea + PCI_EA_FIRST_ENT;
+
+	/* Skip DWORD 2 for type 1 functions */
+	if (dev->hdr_type == PCI_HEADER_TYPE_BRIDGE)
+		offset += 4;
+
+	/* parse each EA entry */
+	for (i = 0; i < num_ent; ++i)
+		offset = pci_ea_read(dev, offset);
+}
+
 static void pci_add_saved_cap(struct pci_dev *pci_dev,
 	struct pci_cap_saved_state *new_cap)
 {

commit c56d4450eb6886225a5a0bb231ad2cea9f03284a
Author: Hariprasad Shenai <hariprasad@chelsio.com>
Date:   Sun Oct 18 19:55:04 2015 +0530

    PCI: Turn off Request Attributes to avoid Chelsio T5 Completion erratum
    
    The Chelsio T5 has a PCIe compliance erratum that causes Malformed TLP or
    Unexpected Completion errors in some systems, which may cause device access
    timeouts.
    
    Per PCIe r3.0, sec 2.2.9, "Completion headers must supply the same values
    for the Attribute as were supplied in the header of the corresponding
    Request, except as explicitly allowed when IDO is used."
    
    Instead of copying the Attributes from the Request to the Completion, the
    T5 always generates Completions with zero Attributes.  The receiver of a
    Completion whose Attributes don't match the Request may accept it (which
    itself seems non-compliant based on sec 2.3.2), or it may handle it as a
    Malformed TLP or an Unexpected Completion, which will probably lead to a
    device access timeout.
    
    Work around this by disabling "Relaxed Ordering" and "No Snoop" in the Root
    Port so it always generate Requests with zero Attributes.
    
    This does affect all other devices which are downstream of that Root Port,
    but these are performance optimizations that should not make a functional
    difference.
    
    Note that Configuration Space accesses are never supposed to have TLP
    Attributes, so we're safe waiting till after any Configuration Space
    accesses to do the Root Port "fixup".
    
    Based on original work by Casey Leedom <leedom@chelsio.com>
    
    [bhelgaas: changelog, comments, rename to pci_find_pcie_root_port(), rework
    to use pci_upstream_bridge() and check for Root Port device type, edit
    diagnostics to clarify intent and devices affected]
    Signed-off-by: Hariprasad Shenai <hariprasad@chelsio.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 6a9a1116f1eb..09b4a35e21a8 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -457,6 +457,30 @@ struct resource *pci_find_parent_resource(const struct pci_dev *dev,
 }
 EXPORT_SYMBOL(pci_find_parent_resource);
 
+/**
+ * pci_find_pcie_root_port - return PCIe Root Port
+ * @dev: PCI device to query
+ *
+ * Traverse up the parent chain and return the PCIe Root Port PCI Device
+ * for a given PCI Device.
+ */
+struct pci_dev *pci_find_pcie_root_port(struct pci_dev *dev)
+{
+	struct pci_dev *bridge, *highest_pcie_bridge = NULL;
+
+	bridge = pci_upstream_bridge(dev);
+	while (bridge && pci_is_pcie(bridge)) {
+		highest_pcie_bridge = bridge;
+		bridge = pci_upstream_bridge(bridge);
+	}
+
+	if (pci_pcie_type(highest_pcie_bridge) != PCI_EXP_TYPE_ROOT_PORT)
+		return NULL;
+
+	return highest_pcie_bridge;
+}
+EXPORT_SYMBOL(pci_find_pcie_root_port);
+
 /**
  * pci_wait_for_pending - wait for @mask bit(s) to clear in status word @pos
  * @dev: the PCI device to operate on

commit 2cef548adf58e9a58a411948b98edb9a3980dbe6
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Sep 30 01:10:24 2015 +0200

    PCI / PM: Avoid resuming more devices during system suspend
    
    Commit bac2a909a096 (PCI / PM: Avoid resuming PCI devices during
    system suspend) introduced a mechanism by which some PCI devices that
    were runtime-suspended at the system suspend time might be left in
    that state for the duration of the system suspend-resume cycle.
    However, it overlooked devices that were marked as capable of waking
    up the system just because PME support was detected in their PCI
    config space.
    
    Namely, in that case, device_can_wakeup(dev) returns 'true' for the
    device and if the device is not configured for system wakeup,
    device_may_wakeup(dev) returns 'false' and it will be resumed during
    system suspend even though configuring it for system wakeup may not
    really make sense at all.
    
    To avoid this problem, simply disable PME for PCI devices that have
    not been configured for system wakeup and are runtime-suspended at
    the system suspend time for the duration of the suspend-resume cycle.
    
    If the device is in D3cold, its config space is not available and it
    shouldn't be written to, but that's only possible if the device
    has platform PM support and the platform code is responsible for
    checking whether or not the device's configuration is suitable for
    system suspend in that case.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 6a9a1116f1eb..78693fc5dbe9 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1710,15 +1710,7 @@ static void pci_pme_list_scan(struct work_struct *work)
 	mutex_unlock(&pci_pme_list_mutex);
 }
 
-/**
- * pci_pme_active - enable or disable PCI device's PME# function
- * @dev: PCI device to handle.
- * @enable: 'true' to enable PME# generation; 'false' to disable it.
- *
- * The caller must verify that the device is capable of generating PME# before
- * calling this function with @enable equal to 'true'.
- */
-void pci_pme_active(struct pci_dev *dev, bool enable)
+static void __pci_pme_active(struct pci_dev *dev, bool enable)
 {
 	u16 pmcsr;
 
@@ -1732,6 +1724,19 @@ void pci_pme_active(struct pci_dev *dev, bool enable)
 		pmcsr &= ~PCI_PM_CTRL_PME_ENABLE;
 
 	pci_write_config_word(dev, dev->pm_cap + PCI_PM_CTRL, pmcsr);
+}
+
+/**
+ * pci_pme_active - enable or disable PCI device's PME# function
+ * @dev: PCI device to handle.
+ * @enable: 'true' to enable PME# generation; 'false' to disable it.
+ *
+ * The caller must verify that the device is capable of generating PME# before
+ * calling this function with @enable equal to 'true'.
+ */
+void pci_pme_active(struct pci_dev *dev, bool enable)
+{
+	__pci_pme_active(dev, enable);
 
 	/*
 	 * PCI (as opposed to PCIe) PME requires that the device have
@@ -2032,17 +2037,60 @@ EXPORT_SYMBOL_GPL(pci_dev_run_wake);
  * reconfigured due to wakeup settings difference between system and runtime
  * suspend and the current power state of it is suitable for the upcoming
  * (system) transition.
+ *
+ * If the device is not configured for system wakeup, disable PME for it before
+ * returning 'true' to prevent it from waking up the system unnecessarily.
  */
 bool pci_dev_keep_suspended(struct pci_dev *pci_dev)
 {
 	struct device *dev = &pci_dev->dev;
 
 	if (!pm_runtime_suspended(dev)
-	    || (device_can_wakeup(dev) && !device_may_wakeup(dev))
+	    || pci_target_state(pci_dev) != pci_dev->current_state
 	    || platform_pci_need_resume(pci_dev))
 		return false;
 
-	return pci_target_state(pci_dev) == pci_dev->current_state;
+	/*
+	 * At this point the device is good to go unless it's been configured
+	 * to generate PME at the runtime suspend time, but it is not supposed
+	 * to wake up the system.  In that case, simply disable PME for it
+	 * (it will have to be re-enabled on exit from system resume).
+	 *
+	 * If the device's power state is D3cold and the platform check above
+	 * hasn't triggered, the device's configuration is suitable and we don't
+	 * need to manipulate it at all.
+	 */
+	spin_lock_irq(&dev->power.lock);
+
+	if (pm_runtime_suspended(dev) && pci_dev->current_state < PCI_D3cold &&
+	    !device_may_wakeup(dev))
+		__pci_pme_active(pci_dev, false);
+
+	spin_unlock_irq(&dev->power.lock);
+	return true;
+}
+
+/**
+ * pci_dev_complete_resume - Finalize resume from system sleep for a device.
+ * @pci_dev: Device to handle.
+ *
+ * If the device is runtime suspended and wakeup-capable, enable PME for it as
+ * it might have been disabled during the prepare phase of system suspend if
+ * the device was not configured for system wakeup.
+ */
+void pci_dev_complete_resume(struct pci_dev *pci_dev)
+{
+	struct device *dev = &pci_dev->dev;
+
+	if (!pci_dev_run_wake(pci_dev))
+		return;
+
+	spin_lock_irq(&dev->power.lock);
+
+	if (pm_runtime_suspended(dev) && pci_dev->current_state < PCI_D3cold)
+		__pci_pme_active(pci_dev, true);
+
+	spin_unlock_irq(&dev->power.lock);
 }
 
 void pci_config_pm_runtime_get(struct pci_dev *pdev)

commit b07461a8e45b7a62ef7fb46e4f6ada66f63406a8
Author: Taku Izumi <izumi.taku@jp.fujitsu.com>
Date:   Thu Sep 17 10:09:37 2015 -0500

    PCI/AER: Clear error status registers during enumeration and restore
    
    AER errors might be recorded when powering-on devices.  These errors can be
    ignored, so firmware usually clears them before the OS enumerates devices.
    However, firmware is not involved when devices are added via hotplug, so
    the OS may discover power-up errors that should be ignored.  The same may
    happen when powering up devices when resuming after suspend.
    
    Clear the AER error status registers during enumeration and resume.
    
    [bhelgaas: changelog, remove repetitive comments]
    Signed-off-by: Taku Izumi <izumi.taku@jp.fujitsu.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 6a9a1116f1eb..62ecf45a4230 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -27,6 +27,7 @@
 #include <linux/pci_hotplug.h>
 #include <asm-generic/pci-bridge.h>
 #include <asm/setup.h>
+#include <linux/aer.h>
 #include "pci.h"
 
 const char *pci_power_names[] = {
@@ -1099,6 +1100,8 @@ void pci_restore_state(struct pci_dev *dev)
 	pci_restore_ats_state(dev);
 	pci_restore_vc_state(dev);
 
+	pci_cleanup_aer_error_status_regs(dev);
+
 	pci_restore_config_space(dev);
 
 	pci_restore_pcix_state(dev);

commit 70675e0b6a1ae20f8e93f9fc083d28034ad38948
Author: Wei Yang <weiyang@linux.vnet.ibm.com>
Date:   Wed Jul 29 16:52:58 2015 +0800

    PCI: Don't try to restore VF BARs
    
    VF BARs are read-only zero, so updating VF BARs will not have any effect.
    See the SR-IOV spec r1.1, sec 3.4.1.11.
    
    Don't update VF BARs in pci_restore_bars().
    
    This avoids spurious "BAR %d: error updating" messages that we see when
    doing vfio pass-through after 6eb7018705de ("vfio-pci: Move idle devices to
    D3hot power state").
    
    [bhelgaas: changelog, fix whitespace]
    Signed-off-by: Wei Yang <weiyang@linux.vnet.ibm.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 6a9a1116f1eb..1cfb47a9a9ff 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -484,7 +484,7 @@ int pci_wait_for_pending(struct pci_dev *dev, int pos, u16 mask)
 }
 
 /**
- * pci_restore_bars - restore a devices BAR values (e.g. after wake-up)
+ * pci_restore_bars - restore a device's BAR values (e.g. after wake-up)
  * @dev: PCI device to have its BARs restored
  *
  * Restore the BAR values for a given device, so as to make it
@@ -494,6 +494,10 @@ static void pci_restore_bars(struct pci_dev *dev)
 {
 	int i;
 
+	/* Per SR-IOV spec 3.4.1.11, VF BARs are RO zero */
+	if (dev->is_virtfn)
+		return;
+
 	for (i = 0; i < PCI_BRIDGE_RESOURCES; i++)
 		pci_update_resource(dev, i);
 }

commit 25525bea46e7d5bc1f82cbc12de2f27b9c346a92
Merge: 2962156d5cc0 2baa891e42d8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Sep 1 10:07:40 2015 -0700

    Merge branch 'x86-mm-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull x86 mm updates from Ingo Molnar:
     "The dominant change in this cycle was the continued work to isolate
      kernel drivers from MTRR legacies: this tree gets rid of all kernel
      internal driver interfaces to MTRRs (mostly by rewriting it to proper
      PAT interfaces), the only access left is the /proc/mtrr ABI.
    
      This work was done by Luis R Rodriguez.
    
      There's also some related PCI interface additions for which I've
      Cc:-ed Bjorn"
    
    * 'x86-mm-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (21 commits)
      x86/mm/mtrr: Remove kernel internal MTRR interfaces: unexport mtrr_add() and mtrr_del()
      s390/io: Add pci_iomap_wc() and pci_iomap_wc_range()
      drivers/dma/iop-adma: Use dma_alloc_writecombine() kernel-style
      drivers/video/fbdev/vt8623fb: Use arch_phys_wc_add() and pci_iomap_wc()
      drivers/video/fbdev/s3fb: Use arch_phys_wc_add() and pci_iomap_wc()
      drivers/video/fbdev/arkfb.c: Use arch_phys_wc_add() and pci_iomap_wc()
      PCI: Add pci_iomap_wc() variants
      drivers/video/fbdev/gxt4500: Use pci_ioremap_wc_bar() to map framebuffer
      drivers/video/fbdev/kyrofb: Use arch_phys_wc_add() and pci_ioremap_wc_bar()
      drivers/video/fbdev/i740fb: Use arch_phys_wc_add() and pci_ioremap_wc_bar()
      PCI: Add pci_ioremap_wc_bar()
      x86/mm: Make kernel/check.c explicitly non-modular
      x86/mm/pat: Make mm/pageattr[-test].c explicitly non-modular
      x86/mm/pat: Add comments to cachemode translation tables
      arch/*/io.h: Add ioremap_uc() to all architectures
      drivers/video/fbdev/atyfb: Use arch_phys_wc_add() and ioremap_wc()
      drivers/video/fbdev/atyfb: Replace MTRR UC hole with strong UC
      drivers/video/fbdev/atyfb: Clarify ioremap() base and length used
      drivers/video/fbdev/atyfb: Carve out framebuffer length fudging into a helper
      x86/mm, asm-generic: Add IOMMU ioremap_uc() variant default
      ...

commit 9ca678d1dff610f7df6ac9b31fd9152c4426f815
Merge: 2fc32c92593d 27d868b5e6cf 91f15fb30c77
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Aug 28 15:53:08 2015 -0500

    Merge branches 'pci/enumeration' and 'pci/misc' into next
    
    * pci/enumeration:
      PCI: Set MPS to match upstream bridge
      PCI: Move MPS configuration check to pci_configure_device()
      PCI: Drop references acquired by of_parse_phandle()
      PCI/MSI: Remove unused pcibios_msi_controller() hook
      ARM/PCI: Remove msi_controller from struct pci_sys_data
      ARM/PCI, designware, xilinx: Use pci_scan_root_bus_msi()
      PCI: Add pci_scan_root_bus_msi()
      ARM/PCI: Replace panic with WARN messages on failures
      PCI: generic: Add arm64 support
      PCI: Build setup-irq.o for arm64
      PCI: generic: Remove dependency on ARM-specific struct hw_pci
      ARM/PCI: Set MPS before pci_bus_add_devices()
    
    * pci/misc:
      PCI: Disable async suspend/resume for JMicron multi-function SATA/AHCI

commit c43996f4001de629af4a4d6713782e883677e5b9
Author: Luis R. Rodriguez <mcgrof@suse.com>
Date:   Mon Aug 24 12:13:23 2015 -0700

    PCI: Add pci_ioremap_wc_bar()
    
    This lets drivers take advantage of PAT when available. It
    should help with the transition of converting video drivers over
    to ioremap_wc() to help with the goal of eventually using
    _PAGE_CACHE_UC over _PAGE_CACHE_UC_MINUS on x86 on
    ioremap_nocache(), see:
    
      de33c442ed2a ("x86 PAT: fix performance drop for glx, use UC minus for ioremap(), ioremap_nocache() and pci_mmap_page_range()")
    
    Signed-off-by: Luis R. Rodriguez <mcgrof@suse.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Cc: <syrjala@sci.fi>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Antonino Daplas <adaplas@gmail.com>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
    Cc: Dave Airlie <airlied@redhat.com>
    Cc: Davidlohr Bueso <dbueso@suse.de>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Jean-Christophe Plagniol-Villard <plagnioj@jcrosoft.com>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mel Gorman <mgorman@suse.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Suresh Siddha <sbsiddha@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Cc: Toshi Kani <toshi.kani@hp.com>
    Cc: Ville Syrjälä <syrjala@sci.fi>
    Cc: Vlastimil Babka <vbabka@suse.cz>
    Cc: airlied@linux.ie
    Cc: benh@kernel.crashing.org
    Cc: dan.j.williams@intel.com
    Cc: konrad.wilk@oracle.com
    Cc: linux-fbdev@vger.kernel.org
    Cc: linux-pci@vger.kernel.org
    Cc: mst@redhat.com
    Cc: vinod.koul@intel.com
    Cc: xen-devel@lists.xensource.com
    Link: http://lkml.kernel.org/r/1440443613-13696-2-git-send-email-mcgrof@do-not-panic.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 0008c950452c..fdae37b473f8 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -138,6 +138,20 @@ void __iomem *pci_ioremap_bar(struct pci_dev *pdev, int bar)
 	return ioremap_nocache(res->start, resource_size(res));
 }
 EXPORT_SYMBOL_GPL(pci_ioremap_bar);
+
+void __iomem *pci_ioremap_wc_bar(struct pci_dev *pdev, int bar)
+{
+	/*
+	 * Make sure the BAR is actually a memory resource, not an IO resource
+	 */
+	if (!(pci_resource_flags(pdev, bar) & IORESOURCE_MEM)) {
+		WARN_ON(1);
+		return NULL;
+	}
+	return ioremap_wc(pci_resource_start(pdev, bar),
+			  pci_resource_len(pdev, bar));
+}
+EXPORT_SYMBOL_GPL(pci_ioremap_wc_bar);
 #endif
 
 #define PCI_FIND_CAP_TTL	48

commit 27d868b5e6cfaee4fec66b388e4085ff94050fa7
Author: Keith Busch <keith.busch@intel.com>
Date:   Mon Aug 24 08:48:16 2015 -0500

    PCI: Set MPS to match upstream bridge
    
    Firmware typically configures the PCIe fabric with a consistent Max Payload
    Size setting based on the devices present at boot.  A hot-added device
    typically has the power-on default MPS setting (128 bytes), which may not
    match the fabric.
    
    The previous Linux default, in the absence of any "pci=pcie_bus_*" options,
    was PCIE_BUS_TUNE_OFF, in which we never touch MPS, even for hot-added
    devices.
    
    Add a new default setting, PCIE_BUS_DEFAULT, in which we make sure every
    device's MPS setting matches the upstream bridge.  This makes it more
    likely that a hot-added device will work in a system with optimized MPS
    configuration.
    
    Note that if we hot-add a device that only supports 128-byte MPS, it still
    likely won't work because we don't reconfigure the rest of the fabric.
    Booting with "pci=pcie_bus_peer2peer" is a workaround for this because it
    sets MPS to 128 for everything.
    
    [bhelgaas: changelog, new default, rework for pci_configure_device() path]
    Tested-by: Keith Busch <keith.busch@intel.com>
    Tested-by: Jordan Hargrave <jharg93@gmail.com>
    Signed-off-by: Keith Busch <keith.busch@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 0008c950452c..b96b4ccc2819 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -81,7 +81,7 @@ unsigned long pci_cardbus_mem_size = DEFAULT_CARDBUS_MEM_SIZE;
 unsigned long pci_hotplug_io_size  = DEFAULT_HOTPLUG_IO_SIZE;
 unsigned long pci_hotplug_mem_size = DEFAULT_HOTPLUG_MEM_SIZE;
 
-enum pcie_bus_config_types pcie_bus_config = PCIE_BUS_TUNE_OFF;
+enum pcie_bus_config_types pcie_bus_config = PCIE_BUS_DEFAULT;
 
 /*
  * The default CLS is used if arch didn't set CLS explicitly and not

commit 5a4f3cf0d1f02884c0a64488d22b3bb4bce31b44
Merge: cd66d5c3df7c 5f2269916b0e 24b390aad293 dff22d2054b5 ccbc175aad81
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Aug 4 20:54:05 2015 -0500

    Merge branches 'pci/irq', 'pci/misc', 'pci/resource' and 'pci/virtualization' into next
    
    * pci/irq:
      PCI/MSI: Free legacy IRQ when enabling MSI/MSI-X
      PCI: Add helpers to manage pci_dev->irq and pci_dev->irq_managed
      PCI, x86: Implement pcibios_alloc_irq() and pcibios_free_irq()
      PCI: Add pcibios_alloc_irq() and pcibios_free_irq()
    
    * pci/misc:
      PCI: Remove unused "pci_probe" flags
      PCI: Add VPD function 0 quirk for Intel Ethernet devices
      PCI: Add dev_flags bit to access VPD through function 0
      PCI / ACPI: Fix pci_acpi_optimize_delay() comment
      PCI: Remove a broken link in quirks.c
      PCI: Remove useless redundant code
      PCI: Simplify pci_find_(ext_)capability() return value checks
      PCI: Move PCI_FIND_CAP_TTL to pci.h and use it in quirks
      PCI: Add pcie_downstream_port() (true for Root and Switch Downstream Ports)
      PCI: Fix pcie_port_device_resume() comment
      PCI: Shift PCI_CLASS_NOT_DEFINED consistently with other classes
      PCI: Revert aeb30016fec3 ("PCI: add Intel USB specific reset method")
      PCI: Fix TI816X class code quirk
      PCI: Fix generic NCR 53c810 class code quirk
      PCI: Use PCI_CLASS_SERIAL_USB instead of bare number
      PCI: Add quirk for Intersil/Techwell TW686[4589] AV capture cards
      PCI: Remove Intel Cherrytrail D3 delays
    
    * pci/resource:
      PCI: Call pci_read_bridge_bases() from core instead of arch code
    
    * pci/virtualization:
      PCI: Restore ACS configuration as part of pci_restore_state()

commit ccbc175aad819e1d4b6af6246b12d55b13d97815
Author: Alexander Duyck <alexander.h.duyck@redhat.com>
Date:   Tue Jul 7 12:24:35 2015 -0700

    PCI: Restore ACS configuration as part of pci_restore_state()
    
    Previously we did not restore ACS state after a PCIe reset.  This meant
    that we could not reassign interfaces after a system suspend because the
    D0->D3 transition disabled ACS, and we didn't restore it when going back to
    D0.
    
    Restore ACS configuration in pci_restore_state().
    
    [bhelgaas: changelog]
    Signed-off-by: Alexander Duyck <alexander.h.duyck@redhat.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    CC: Allen Kay <allen.m.kay@intel.com>
    CC: Chris Wright <chris@sous-sol.org>
    CC: Alex Williamson <alex.williamson@redhat.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 0008c950452c..9bd9526f3388 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1092,6 +1092,9 @@ void pci_restore_state(struct pci_dev *dev)
 
 	pci_restore_pcix_state(dev);
 	pci_restore_msi_state(dev);
+
+	/* Restore ACS and IOV configuration state */
+	pci_enable_acs(dev);
 	pci_restore_iov_state(dev);
 
 	dev->state_saved = false;

commit aaed816fde8501ed86bb62c4d7f7b137969afc7e
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Jul 14 16:41:19 2015 -0500

    PCI: Remove useless redundant code
    
    Remove redundant code from __pci_bus_find_cap_start().  No functional
    change.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 29b560591d54..359b954670e6 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -195,8 +195,6 @@ static int __pci_bus_find_cap_start(struct pci_bus *bus,
 		return PCI_CAPABILITY_LIST;
 	case PCI_HEADER_TYPE_CARDBUS:
 		return PCI_CB_CAPABILITY_LIST;
-	default:
-		return 0;
 	}
 
 	return 0;

commit 0a1a9b49427f13b6e12366eb8f06b8094ab61447
Author: Wei Yang <weiyang@linux.vnet.ibm.com>
Date:   Tue Jun 30 09:16:44 2015 +0800

    PCI: Simplify pci_find_(ext_)capability() return value checks
    
    The return value of the pci_find_(ext_)capability() is either zero or the
    position of a capability.  It is never negative.
    
    This patch consolidates the form of check from (pos <= 0) to (!pos).
    
    Signed-off-by: Wei Yang <weiyang@linux.vnet.ibm.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 66bd80e7ec12..29b560591d54 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -971,7 +971,7 @@ static int pci_save_pcix_state(struct pci_dev *dev)
 	struct pci_cap_saved_state *save_state;
 
 	pos = pci_find_capability(dev, PCI_CAP_ID_PCIX);
-	if (pos <= 0)
+	if (!pos)
 		return 0;
 
 	save_state = pci_find_saved_cap(dev, PCI_CAP_ID_PCIX);
@@ -994,7 +994,7 @@ static void pci_restore_pcix_state(struct pci_dev *dev)
 
 	save_state = pci_find_saved_cap(dev, PCI_CAP_ID_PCIX);
 	pos = pci_find_capability(dev, PCI_CAP_ID_PCIX);
-	if (!save_state || pos <= 0)
+	if (!save_state || !pos)
 		return;
 	cap = (u16 *)&save_state->cap.data[0];
 
@@ -2158,7 +2158,7 @@ static int _pci_add_cap_save_buffer(struct pci_dev *dev, u16 cap,
 	else
 		pos = pci_find_capability(dev, cap);
 
-	if (pos <= 0)
+	if (!pos)
 		return 0;
 
 	save_state = kzalloc(sizeof(*save_state) + size, GFP_KERNEL);

commit fff905f32966109d513ae17afc6fe39f1c76bb67
Author: Wei Yang <weiyang@linux.vnet.ibm.com>
Date:   Tue Jun 30 09:16:41 2015 +0800

    PCI: Move PCI_FIND_CAP_TTL to pci.h and use it in quirks
    
    Some quirks search for a HyperTransport capability and use a hard-coded TTL
    value of 48 to avoid an infinite loop.
    
    Move the definition of PCI_FIND_CAP_TTL to pci.h and use it instead of the
    hard-coded TTL values.
    
    [bhelgaas: changelog]
    Signed-off-by: Wei Yang <weiyang@linux.vnet.ibm.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 0008c950452c..66bd80e7ec12 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -140,7 +140,6 @@ void __iomem *pci_ioremap_bar(struct pci_dev *pdev, int bar)
 EXPORT_SYMBOL_GPL(pci_ioremap_bar);
 #endif
 
-#define PCI_FIND_CAP_TTL	48
 
 static int __pci_find_next_cap_ttl(struct pci_bus *bus, unsigned int devfn,
 				   u8 pos, int cap, int *ttl)

commit 0ff9b9bad66730e8347cb3350c8d3d1b88a21f13
Merge: 5ebe6afaf005 0c0cbb6c5a04 c0300089fd2d a5dd4b4b0570 01d72a951888 c6201cd8513d 3a9ad0b4fdcd 917bfd93d3c9
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Jun 12 15:26:45 2015 -0500

    Merge branches 'pci/aspm', 'pci/enumeration', 'pci/hotplug', 'pci/misc', 'pci/msi', 'pci/resource' and 'pci/virtualization' into next
    
    * pci/aspm:
      PCI/ASPM: Simplify Clock Power Management setting
      PCI: Use dev->has_secondary_link to find downstream PCIe links
      PCI/ASPM: Use dev->has_secondary_link to find downstream links
      PCI: Add dev->has_secondary_link to track downstream PCIe links
      PCI/ASPM: Remove redundant PCIe port type checking
      PCI/ASPM: Drop __pci_disable_link_state() useless "force" parameter
    
    * pci/enumeration:
      PCI: Remove unused pci_scan_bus_parented()
      xen/pcifront: Don't use deprecated function pci_scan_bus_parented()
      PCI: designware: Use pci_scan_root_bus() for simplicity
      PCI: tegra: Remove tegra_pcie_scan_bus()
      PCI: mvebu: Remove mvebu_pcie_scan_bus()
    
    * pci/hotplug:
      PCI: pciehp: Wait for hotplug command completion where necessary
      PCI: Propagate the "ignore hotplug" setting to parent
      ACPI / hotplug / PCI: Check ignore_hotplug for all downstream devices
      PCI: pciehp: Drop pointless label from pciehp_probe()
      PCI: pciehp: Drop pointless ACPI-based "slot detection" check
    
    * pci/misc:
      PCI: Remove unused pci_dma_burst_advice()
      PCI: Remove unused pcibios_select_root() (again)
      PCI: Remove unnecessary #includes of <asm/pci.h>
      PCI: Include <linux/pci.h>, not <asm/pci.h>
    
    * pci/msi:
      PCI/MSI: Remove unused pci_msi_off()
      PCI/MSI: Drop pci_msi_off() calls from quirks
      ntb: Drop pci_msi_off() call during probe
      virtio_pci: drop pci_msi_off() call during probe
      PCI/MSI: Disable MSI at enumeration even if kernel doesn't support MSI
      PCI/MSI: Export pci_msi_set_enable(), pci_msix_clear_and_set_ctrl()
      PCI/MSI: Rename msi_set_enable(), msix_clear_and_set_ctrl()
    
    * pci/resource:
      PCI: Add pci_bus_addr_t
    
    * pci/virtualization:
      ACPI / PCI: Account for ARI in _PRT lookups
      PCI: Move pci_ari_enabled() to global header
      PCI: Add function 1 DMA alias quirk for Marvell 9120
      PCI: Add ACS quirks for Intel 9-series PCH root ports

commit 0824965140fff1bf640a987dc790d1594a8e0699
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Apr 13 16:23:36 2015 +0200

    PCI: Propagate the "ignore hotplug" setting to parent
    
    Refine the mechanism introduced by commit f244d8b623da ("ACPIPHP / radeon /
    nouveau: Fix VGA switcheroo problem related to hotplug") to propagate the
    ignore_hotplug setting of the device to its parent bridge in case hotplug
    notifications related to the graphics adapter switching are given for the
    bridge rather than for the device itself (they need to be ignored in both
    cases).
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=61891
    Link: https://bugs.freedesktop.org/show_bug.cgi?id=88927
    Fixes: b440bde74f04 ("PCI: Add pci_ignore_hotplug() to ignore hotplug events for a device")
    Reported-and-tested-by: tiagdtd-lava <tiagdtd-lava@yahoo.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    CC: stable@vger.kernel.org      # v3.17+

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index acc4b6ef78c4..c44393f26fd3 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -4324,6 +4324,17 @@ bool pci_device_is_present(struct pci_dev *pdev)
 }
 EXPORT_SYMBOL_GPL(pci_device_is_present);
 
+void pci_ignore_hotplug(struct pci_dev *dev)
+{
+	struct pci_dev *bridge = dev->bus->self;
+
+	dev->ignore_hotplug = 1;
+	/* Propagate the "ignore hotplug" setting to the parent bridge. */
+	if (bridge)
+		bridge->ignore_hotplug = 1;
+}
+EXPORT_SYMBOL_GPL(pci_ignore_hotplug);
+
 #define RESOURCE_ALIGNMENT_PARAM_SIZE COMMAND_LINE_SIZE
 static char resource_alignment_param[RESOURCE_ALIGNMENT_PARAM_SIZE] = {0};
 static DEFINE_SPINLOCK(resource_alignment_lock);

commit c6201cd8513db2db54b248a862672849ed9ccb82
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu May 7 09:52:22 2015 -0500

    PCI/MSI: Remove unused pci_msi_off()
    
    pci_msi_off() is unused, so remove it.
    
    Removes the exported symbol pci_msi_off().
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index acc4b6ef78c4..687af7264406 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -3101,39 +3101,6 @@ bool pci_check_and_unmask_intx(struct pci_dev *dev)
 }
 EXPORT_SYMBOL_GPL(pci_check_and_unmask_intx);
 
-/**
- * pci_msi_off - disables any MSI or MSI-X capabilities
- * @dev: the PCI device to operate on
- *
- * If you want to use MSI, see pci_enable_msi() and friends.
- * This is a lower-level primitive that allows us to disable
- * MSI operation at the device level.
- */
-void pci_msi_off(struct pci_dev *dev)
-{
-	int pos;
-	u16 control;
-
-	/*
-	 * This looks like it could go in msi.c, but we need it even when
-	 * CONFIG_PCI_MSI=n.  For the same reason, we can't use
-	 * dev->msi_cap or dev->msix_cap here.
-	 */
-	pos = pci_find_capability(dev, PCI_CAP_ID_MSI);
-	if (pos) {
-		pci_read_config_word(dev, pos + PCI_MSI_FLAGS, &control);
-		control &= ~PCI_MSI_FLAGS_ENABLE;
-		pci_write_config_word(dev, pos + PCI_MSI_FLAGS, control);
-	}
-	pos = pci_find_capability(dev, PCI_CAP_ID_MSIX);
-	if (pos) {
-		pci_read_config_word(dev, pos + PCI_MSIX_FLAGS, &control);
-		control &= ~PCI_MSIX_FLAGS_ENABLE;
-		pci_write_config_word(dev, pos + PCI_MSIX_FLAGS, control);
-	}
-}
-EXPORT_SYMBOL_GPL(pci_msi_off);
-
 int pci_set_dma_max_seg_size(struct pci_dev *dev, unsigned int size)
 {
 	return dma_set_max_seg_size(&dev->dev, size);

commit 5468d5a64bf1e002e5081fa280186d0eba09fa0e
Merge: 4dd1f57956ad 55db3208f238
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Apr 10 08:27:18 2015 -0500

    Merge branch 'pci/misc' into next
    
    * pci/misc:
      PCI: Read capability list as dwords, not bytes
      PCI: Don't clear ASPM bits when the FADT declares it's unsupported
      PCI: Clarify policy for vendor IDs in pci.txt
      PCI/ACPI: Optimize device state transition delays
      PCI: Export pci_find_host_bridge() for use inside PCI core
      PCI: Make a shareable UUID for PCI firmware ACPI _DSM
      PCI: Fix typo in Thunderbolt kernel message

commit 4dd1f57956ada782fd80b1c11c30a9595d6caafc
Merge: 8e795840e4d8 01d06a9a4c28 1fb37a8178da f76ea574d615 e3dc17a53f96 ab14d45ea58e 7a27db23a3f6 873581698d39
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Apr 10 08:26:54 2015 -0500

    Merge branches 'pci/host-exynos', 'pci/host-iproc', 'pci/host-keystone', 'pci/host-layerscape', 'pci/host-mvebu', 'pci/host-rcar' and 'pci/host-versatile' into next
    
    * pci/host-exynos:
      PCI: exynos: Fix INTx enablement statement termination error
    
    * pci/host-iproc:
      PCI: iproc: Add Broadcom iProc PCIe support
      PCI: iproc: Add DT docs for Broadcom iProc PCIe driver
      PCI: Export symbols required for loadable host driver modules
    
    * pci/host-keystone:
      PCI: keystone: Don't dereference possible NULL pointer
    
    * pci/host-layerscape:
      PCI: layerscape: Simplify platform_get_resource_byname() failure checking
    
    * pci/host-mvebu:
      PCI: mvebu: Add suspend/resume support
    
    * pci/host-rcar:
      PCI: rcar: Verify that mem_res is 64K-aligned
      PCI: rcar: Change PCIEPARL and PCIEPARH to PCIEPALR and PCIEPAUR
      PCI: rcar: Write zeroes to reserved PCIEPARL bits
      PCI: rcar: Fix position of MSI enable bit
    
    * pci/host-versatile:
      PCI: versatile: Check for devm_ioremap_resource() failures

commit 55db3208f238ee776f1f747734051723d8a3c13e
Author: Sean O. Stalley <sean.stalley@intel.com>
Date:   Thu Apr 2 14:10:19 2015 -0700

    PCI: Read capability list as dwords, not bytes
    
    Reading both the capability ID and "next" pointer at the same time lets us
    parse the list with half the number of config reads.
    
    Signed-off-by: Sean O. Stalley <sean.stalley@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 81f06e8dcc04..3c84cc6bc75a 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -145,19 +145,22 @@ static int __pci_find_next_cap_ttl(struct pci_bus *bus, unsigned int devfn,
 				   u8 pos, int cap, int *ttl)
 {
 	u8 id;
+	u16 ent;
+
+	pci_bus_read_config_byte(bus, devfn, pos, &pos);
 
 	while ((*ttl)--) {
-		pci_bus_read_config_byte(bus, devfn, pos, &pos);
 		if (pos < 0x40)
 			break;
 		pos &= ~3;
-		pci_bus_read_config_byte(bus, devfn, pos + PCI_CAP_LIST_ID,
-					 &id);
+		pci_bus_read_config_word(bus, devfn, pos, &ent);
+
+		id = ent & 0xff;
 		if (id == 0xff)
 			break;
 		if (id == cap)
 			return pos;
-		pos += PCI_CAP_LIST_NEXT;
+		pos = (ent >> 8);
 	}
 	return 0;
 }

commit e6b29deafad3ce020dcf873a27a95c0cb9966c5b
Author: Ray Jui <rjui@broadcom.com>
Date:   Wed Apr 8 11:21:33 2015 -0700

    PCI: Export symbols required for loadable host driver modules
    
    Export the following symbols so they can be referenced by a PCI host bridge
    driver compiled as a kernel loadable module:
    
      pci_common_swizzle
      pci_create_root_bus
      pci_stop_root_bus
      pci_remove_root_bus
      pci_assign_unassigned_bus_resources
      pci_fixup_irqs
    
    Signed-off-by: Ray Jui <rjui@broadcom.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 81f06e8dcc04..14e7f3c40793 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2492,6 +2492,7 @@ u8 pci_common_swizzle(struct pci_dev *dev, u8 *pinp)
 	*pinp = pin;
 	return PCI_SLOT(dev->devfn);
 }
+EXPORT_SYMBOL_GPL(pci_common_swizzle);
 
 /**
  *	pci_release_region - Release a PCI bar

commit 646c0282df04265f77ebd5ad3beae671e59acd5b
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Mar 12 12:30:15 2015 -0500

    PCI: Fail pci_ioremap_bar() on unassigned resources
    
    Make pci_ioremap_bar() fail if we're trying to map a BAR that hasn't been
    assigned.
    
    Normally pci_enable_device() will fail if a BAR hasn't been assigned, but a
    driver can successfully call pci_enable_device_io() even if a memory BAR
    hasn't been assigned.  That driver should not be able to use
    pci_ioremap_bar() to map that unassigned memory BAR.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index a6d191ad9743..28df200bc54c 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -131,7 +131,7 @@ void __iomem *pci_ioremap_bar(struct pci_dev *pdev, int bar)
 	/*
 	 * Make sure the BAR is actually a memory resource, not an IO resource
 	 */
-	if (!(res->flags & IORESOURCE_MEM)) {
+	if (res->flags & IORESOURCE_UNSET || !(res->flags & IORESOURCE_MEM)) {
 		dev_warn(&pdev->dev, "can't ioremap BAR %d: %pR\n", bar, res);
 		return NULL;
 	}

commit 1f7bf3bfb5d60c87dcaa708fd9eabbec93f15830
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Mar 12 12:30:11 2015 -0500

    PCI: Show driver, BAR#, and resource on pci_ioremap_bar() failure
    
    Use dev_warn() to complain about a pci_ioremap_bar() failure so we can
    include the driver name, BAR number, and the resource itself.  We could use
    dev_WARN() to also get the backtrace as we did previously, but I think
    that's more information than we need.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 81f06e8dcc04..a6d191ad9743 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -126,15 +126,16 @@ EXPORT_SYMBOL_GPL(pci_bus_max_busnr);
 #ifdef CONFIG_HAS_IOMEM
 void __iomem *pci_ioremap_bar(struct pci_dev *pdev, int bar)
 {
+	struct resource *res = &pdev->resource[bar];
+
 	/*
 	 * Make sure the BAR is actually a memory resource, not an IO resource
 	 */
-	if (!(pci_resource_flags(pdev, bar) & IORESOURCE_MEM)) {
-		WARN_ON(1);
+	if (!(res->flags & IORESOURCE_MEM)) {
+		dev_warn(&pdev->dev, "can't ioremap BAR %d: %pR\n", bar, res);
 		return NULL;
 	}
-	return ioremap_nocache(pci_resource_start(pdev, bar),
-				     pci_resource_len(pdev, bar));
+	return ioremap_nocache(res->start, resource_size(res));
 }
 EXPORT_SYMBOL_GPL(pci_ioremap_bar);
 #endif

commit 872912352c5be930e9568e5f3b6d73107d9f278d
Merge: c08f8467939e b5e82233cab4
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Feb 10 15:09:41 2015 -0800

    Merge tag 'pm+acpi-3.20-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull ACPI and power management updates from Rafael Wysocki:
     "We have a few new features this time, including a new SFI-based
      cpufreq driver, a new devfreq driver for Tegra Activity Monitor, a new
      devfreq class for providing its governors with raw utilization data
      and a new ACPI driver for AMD SoCs.
    
      Still, the majority of changes here are reworks of existing code to
      make it more straightforward or to prepare it for implementing new
      features on top of it.  The primary example is the rework of ACPI
      resources handling from Jiang Liu, Thomas Gleixner and Lv Zheng with
      support for IOAPIC hotplug implemented on top of it, but there is
      quite a number of changes of this kind in the cpufreq core, ACPICA,
      ACPI EC driver, ACPI processor driver and the generic power domains
      core code too.
    
      The most active developer is Viresh Kumar with his cpufreq changes.
    
      Specifics:
    
       - Rework of the core ACPI resources parsing code to fix issues in it
         and make using resource offsets more convenient and consolidation
         of some resource-handing code in a couple of places that have grown
         analagous data structures and code to cover the the same gap in the
         core (Jiang Liu, Thomas Gleixner, Lv Zheng).
    
       - ACPI-based IOAPIC hotplug support on top of the resources handling
         rework (Jiang Liu, Yinghai Lu).
    
       - ACPICA update to upstream release 20150204 including an interrupt
         handling rework that allows drivers to install raw handlers for
         ACPI GPEs which then become entirely responsible for the given GPE
         and the ACPICA core code won't touch it (Lv Zheng, David E Box,
         Octavian Purdila).
    
       - ACPI EC driver rework to fix several concurrency issues and other
         problems related to events handling on top of the ACPICA's new
         support for raw GPE handlers (Lv Zheng).
    
       - New ACPI driver for AMD SoCs analogous to the LPSS (Low-Power
         Subsystem) driver for Intel chips (Ken Xue).
    
       - Two minor fixes of the ACPI LPSS driver (Heikki Krogerus, Jarkko
         Nikula).
    
       - Two new blacklist entries for machines (Samsung 730U3E/740U3E and
         510R) where the native backlight interface doesn't work correctly
         while the ACPI one does (Hans de Goede).
    
       - Rework of the ACPI processor driver's handling of idle states to
         make the code more straightforward and less bloated overall (Rafael
         J Wysocki).
    
       - Assorted minor fixes related to ACPI and SFI (Andreas Ruprecht,
         Andy Shevchenko, Hanjun Guo, Jan Beulich, Rafael J Wysocki, Yaowei
         Bai).
    
       - PCI core power management modification to avoid resuming (some)
         runtime-suspended devices during system suspend if they are in the
         right states already (Rafael J Wysocki).
    
       - New SFI-based cpufreq driver for Intel platforms using SFI
         (Srinidhi Kasagar).
    
       - cpufreq core fixes, cleanups and simplifications (Viresh Kumar,
         Doug Anderson, Wolfram Sang).
    
       - SkyLake CPU support and other updates for the intel_pstate driver
         (Kristen Carlson Accardi, Srinivas Pandruvada).
    
       - cpufreq-dt driver cleanup (Markus Elfring).
    
       - Init fix for the ARM big.LITTLE cpuidle driver (Sudeep Holla).
    
       - Generic power domains core code fixes and cleanups (Ulf Hansson).
    
       - Operating Performance Points (OPP) core code cleanups and kernel
         documentation update (Nishanth Menon).
    
       - New dabugfs interface to make the list of PM QoS constraints
         available to user space (Nishanth Menon).
    
       - New devfreq driver for Tegra Activity Monitor (Tomeu Vizoso).
    
       - New devfreq class (devfreq_event) to provide raw utilization data
         to devfreq governors (Chanwoo Choi).
    
       - Assorted minor fixes and cleanups related to power management
         (Andreas Ruprecht, Krzysztof Kozlowski, Rickard Strandqvist, Pavel
         Machek, Todd E Brandt, Wonhong Kwon).
    
       - turbostat updates (Len Brown) and cpupower Makefile improvement
         (Sriram Raghunathan)"
    
    * tag 'pm+acpi-3.20-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (151 commits)
      tools/power turbostat: relax dependency on APERF_MSR
      tools/power turbostat: relax dependency on invariant TSC
      Merge branch 'pci/host-generic' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci into acpi-resources
      tools/power turbostat: decode MSR_*_PERF_LIMIT_REASONS
      tools/power turbostat: relax dependency on root permission
      ACPI / video: Add disable_native_backlight quirk for Samsung 510R
      ACPI / PM: Remove unneeded nested #ifdef
      USB / PM: Remove unneeded #ifdef and associated dead code
      intel_pstate: provide option to only use intel_pstate with HWP
      ACPI / EC: Add GPE reference counting debugging messages
      ACPI / EC: Add query flushing support
      ACPI / EC: Refine command storm prevention support
      ACPI / EC: Add command flushing support.
      ACPI / EC: Introduce STARTED/STOPPED flags to replace BLOCKED flag
      ACPI: add AMD ACPI2Platform device support for x86 system
      ACPI / table: remove duplicate NULL check for the handler of acpi_table_parse()
      ACPI / EC: Update revision due to raw handler mode.
      ACPI / EC: Reduce ec_poll() by referencing the last register access timestamp.
      ACPI / EC: Fix several GPE handling issues by deploying ACPI_GPE_DISPATCH_RAW_HANDLER mode.
      ACPICA: Events: Enable APIs to allow interrupt/polling adaptive request based GPE handling model
      ...

commit 2f8c42f31c9352c9ab9e70616342d585d3c2b735
Merge: 8fbcf5ecb336 bac2a909a096 39909b711442
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Feb 10 16:07:10 2015 +0100

    Merge branches 'pm-pci' and 'pm-cpuidle'
    
    * pm-pci:
      PCI / PM: Avoid resuming PCI devices during system suspend
    
    * pm-cpuidle:
      drivers: cpuidle: Don't initialize big.LITTLE driver if MCPM is unavailable

commit 341f3a2bcfa25462b55ec72939fd21692fa0d7c9
Merge: e315110657e7 145b3fe579db a93b506e265a 16b036af31e1 78e883585db4
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Jan 27 15:34:20 2015 -0600

    Merge branches 'pci/enumeration', 'pci/hotplug', 'pci/resource' and 'pci/virtualization' into next
    
    * pci/enumeration:
      PCI: Generate uppercase hex for modalias var in uevent
    
    * pci/hotplug:
      PCI: pciehp: Handle surprise add even if surprise removal isn't supported
    
    * pci/resource:
      PCI: Fix infinite loop with ROM image of size 0
    
    * pci/virtualization:
      PCI: Add Wellsburg (X99) to Intel PCH root port ACS quirk
      PCI: Add DMA alias quirk for Adaptec 3405
      PCI: Add ACS quirk for Emulex NICs
      PCI: Mark AMD/ATI VGA devices that don't reset on D3hot->D0 transition
      PCI: Add flag for devices that don't reset on D3hot->D0 transition
      PCI: Mark Atheros AR93xx to avoid bus reset
      PCI: Add flag for devices where we can't use bus reset

commit bac2a909a096c9110525c18cbb8ce73c660d5f71
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Jan 21 02:17:42 2015 +0100

    PCI / PM: Avoid resuming PCI devices during system suspend
    
    Commit f25c0ae2b4c4 (ACPI / PM: Avoid resuming devices in ACPI PM
    domain during system suspend) modified the ACPI PM domain's system
    suspend callbacks to allow devices attached to it to be left in the
    runtime-suspended state during system suspend so as to optimize
    the suspend process.
    
    This was based on the general mechanism introduced by commit
    aae4518b3124 (PM / sleep: Mechanism to avoid resuming runtime-suspended
    devices unnecessarily).
    
    Extend that approach to PCI devices by modifying the PCI bus type's
    ->prepare callback to return 1 for devices that are runtime-suspended
    when it is being executed and that are in a suitable power state and
    need not be resumed going forward.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index cab05f31223f..7a671abceccc 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -521,6 +521,11 @@ static inline int platform_pci_run_wake(struct pci_dev *dev, bool enable)
 			pci_platform_pm->run_wake(dev, enable) : -ENODEV;
 }
 
+static inline bool platform_pci_need_resume(struct pci_dev *dev)
+{
+	return pci_platform_pm ? pci_platform_pm->need_resume(dev) : false;
+}
+
 /**
  * pci_raw_set_power_state - Use PCI PM registers to set the power state of
  *                           given PCI device
@@ -1999,6 +2004,27 @@ bool pci_dev_run_wake(struct pci_dev *dev)
 }
 EXPORT_SYMBOL_GPL(pci_dev_run_wake);
 
+/**
+ * pci_dev_keep_suspended - Check if the device can stay in the suspended state.
+ * @pci_dev: Device to check.
+ *
+ * Return 'true' if the device is runtime-suspended, it doesn't have to be
+ * reconfigured due to wakeup settings difference between system and runtime
+ * suspend and the current power state of it is suitable for the upcoming
+ * (system) transition.
+ */
+bool pci_dev_keep_suspended(struct pci_dev *pci_dev)
+{
+	struct device *dev = &pci_dev->dev;
+
+	if (!pm_runtime_suspended(dev)
+	    || (device_can_wakeup(dev) && !device_may_wakeup(dev))
+	    || platform_pci_need_resume(pci_dev))
+		return false;
+
+	return pci_target_state(pci_dev) == pci_dev->current_state;
+}
+
 void pci_config_pm_runtime_get(struct pci_dev *pdev)
 {
 	struct device *dev = &pdev->dev;

commit 51e537387990dc1f00752103f314fd135cb94bc6
Author: Alex Williamson <alex.williamson@redhat.com>
Date:   Fri Nov 21 11:24:08 2014 -0700

    PCI: Add flag for devices that don't reset on D3hot->D0 transition
    
    Per the PCI Power Management spec r1.2, sec 3.2.4, a device that advertises
    No_Soft_Reset == 0 in the PMCSR register (reported by lspci as "NoSoftRst-")
    should perform an internal reset when transitioning from D3hot to D0 via
    software control.  Configuration context is lost and the device requires a
    full reinitialization sequence.
    
    Unfortunately the definition of "internal reset", beyond the application of
    the configuration context, is largely left to the interpretation of the
    specific device.  Some devices don't seem to perform an "internal reset"
    even if they report No_Soft_Reset == 0.
    
    We still need to honor the PCI specification and restore PCI config context
    in the event that we do a PM reset, so we don't cache and modify the
    PCI_PM_CTRL_NO_SOFT_RESET bit for the device, but for interfaces where the
    intention is to reset the device, like pci_reset_function(), we need a
    mechanism to flag that PM reset (a D3hot->D0 transition) doesn't perform
    any significant "internal reset" of the device.
    
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index e9d4fd861ba1..422bc0179e90 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -3197,7 +3197,7 @@ static int pci_pm_reset(struct pci_dev *dev, int probe)
 {
 	u16 csr;
 
-	if (!dev->pm_cap)
+	if (!dev->pm_cap || dev->dev_flags & PCI_DEV_FLAGS_NO_PM_RESET)
 		return -ENOTTY;
 
 	pci_read_config_word(dev, dev->pm_cap + PCI_PM_CTRL, &csr);

commit f331a859e0ee5a898c1f47596eddad4c4f02d657
Author: Alex Williamson <alex.williamson@redhat.com>
Date:   Thu Jan 15 18:16:04 2015 -0600

    PCI: Add flag for devices where we can't use bus reset
    
    Enable a mechanism for devices to quirk that they do not behave when
    doing a PCI bus reset.  We require a modest level of spec compliant
    behavior in order to do a reset, for instance the device should come
    out of reset without throwing errors and PCI config space should be
    accessible after reset.  This is too much to ask for some devices.
    
    Link: http://lkml.kernel.org/r/20140923210318.498dacbd@dualc.maya.org
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    CC: stable@vger.kernel.org      # v3.14+

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index cab05f31223f..e9d4fd861ba1 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -3271,7 +3271,8 @@ static int pci_parent_bus_reset(struct pci_dev *dev, int probe)
 {
 	struct pci_dev *pdev;
 
-	if (pci_is_root_bus(dev->bus) || dev->subordinate || !dev->bus->self)
+	if (pci_is_root_bus(dev->bus) || dev->subordinate ||
+	    !dev->bus->self || dev->dev_flags & PCI_DEV_FLAGS_NO_BUS_RESET)
 		return -ENOTTY;
 
 	list_for_each_entry(pdev, &dev->bus->devices, bus_list)
@@ -3305,7 +3306,8 @@ static int pci_dev_reset_slot_function(struct pci_dev *dev, int probe)
 {
 	struct pci_dev *pdev;
 
-	if (dev->subordinate || !dev->slot)
+	if (dev->subordinate || !dev->slot ||
+	    dev->dev_flags & PCI_DEV_FLAGS_NO_BUS_RESET)
 		return -ENOTTY;
 
 	list_for_each_entry(pdev, &dev->bus->devices, bus_list)
@@ -3557,6 +3559,20 @@ int pci_try_reset_function(struct pci_dev *dev)
 }
 EXPORT_SYMBOL_GPL(pci_try_reset_function);
 
+/* Do any devices on or below this bus prevent a bus reset? */
+static bool pci_bus_resetable(struct pci_bus *bus)
+{
+	struct pci_dev *dev;
+
+	list_for_each_entry(dev, &bus->devices, bus_list) {
+		if (dev->dev_flags & PCI_DEV_FLAGS_NO_BUS_RESET ||
+		    (dev->subordinate && !pci_bus_resetable(dev->subordinate)))
+			return false;
+	}
+
+	return true;
+}
+
 /* Lock devices from the top of the tree down */
 static void pci_bus_lock(struct pci_bus *bus)
 {
@@ -3607,6 +3623,22 @@ static int pci_bus_trylock(struct pci_bus *bus)
 	return 0;
 }
 
+/* Do any devices on or below this slot prevent a bus reset? */
+static bool pci_slot_resetable(struct pci_slot *slot)
+{
+	struct pci_dev *dev;
+
+	list_for_each_entry(dev, &slot->bus->devices, bus_list) {
+		if (!dev->slot || dev->slot != slot)
+			continue;
+		if (dev->dev_flags & PCI_DEV_FLAGS_NO_BUS_RESET ||
+		    (dev->subordinate && !pci_bus_resetable(dev->subordinate)))
+			return false;
+	}
+
+	return true;
+}
+
 /* Lock devices from the top of the tree down */
 static void pci_slot_lock(struct pci_slot *slot)
 {
@@ -3728,7 +3760,7 @@ static int pci_slot_reset(struct pci_slot *slot, int probe)
 {
 	int rc;
 
-	if (!slot)
+	if (!slot || !pci_slot_resetable(slot))
 		return -ENOTTY;
 
 	if (!probe)
@@ -3820,7 +3852,7 @@ EXPORT_SYMBOL_GPL(pci_try_reset_slot);
 
 static int pci_bus_reset(struct pci_bus *bus, int probe)
 {
-	if (!bus->self)
+	if (!bus->self || !pci_bus_resetable(bus))
 		return -ENOTTY;
 
 	if (probe)

commit 7c674700098c87b305b99652e3c694c4ef195866
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Sat Dec 27 18:19:12 2014 -0700

    PCI: Move domain assignment from arm64 to generic code
    
    The current logic in arm64 pci_bus_assign_domain_nr() is flawed in that
    depending on the host controller configuration for a platform and the
    initialization sequence, core code may end up allocating PCI domain numbers
    from both DT and the generic domain counter, which would result in PCI
    domain allocation aliases/errors.
    
    Fix the logic behind the PCI domain number assignment and move the
    resulting code to the PCI core so the same domain allocation logic is used
    on all platforms that select CONFIG_PCI_DOMAINS_GENERIC.
    
    [bhelgaas: tidy changelog]
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Liviu Dudau <Liviu.Dudau@arm.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    CC: Rob Herring <robh+dt@kernel.org>
    CC: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index cab05f31223f..c419554d0b4b 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -10,6 +10,8 @@
 #include <linux/kernel.h>
 #include <linux/delay.h>
 #include <linux/init.h>
+#include <linux/of.h>
+#include <linux/of_pci.h>
 #include <linux/pci.h>
 #include <linux/pm.h>
 #include <linux/slab.h>
@@ -4439,6 +4441,53 @@ int pci_get_new_domain_nr(void)
 {
 	return atomic_inc_return(&__domain_nr);
 }
+
+#ifdef CONFIG_PCI_DOMAINS_GENERIC
+void pci_bus_assign_domain_nr(struct pci_bus *bus, struct device *parent)
+{
+	static int use_dt_domains = -1;
+	int domain = of_get_pci_domain_nr(parent->of_node);
+
+	/*
+	 * Check DT domain and use_dt_domains values.
+	 *
+	 * If DT domain property is valid (domain >= 0) and
+	 * use_dt_domains != 0, the DT assignment is valid since this means
+	 * we have not previously allocated a domain number by using
+	 * pci_get_new_domain_nr(); we should also update use_dt_domains to
+	 * 1, to indicate that we have just assigned a domain number from
+	 * DT.
+	 *
+	 * If DT domain property value is not valid (ie domain < 0), and we
+	 * have not previously assigned a domain number from DT
+	 * (use_dt_domains != 1) we should assign a domain number by
+	 * using the:
+	 *
+	 * pci_get_new_domain_nr()
+	 *
+	 * API and update the use_dt_domains value to keep track of method we
+	 * are using to assign domain numbers (use_dt_domains = 0).
+	 *
+	 * All other combinations imply we have a platform that is trying
+	 * to mix domain numbers obtained from DT and pci_get_new_domain_nr(),
+	 * which is a recipe for domain mishandling and it is prevented by
+	 * invalidating the domain value (domain = -1) and printing a
+	 * corresponding error.
+	 */
+	if (domain >= 0 && use_dt_domains) {
+		use_dt_domains = 1;
+	} else if (domain < 0 && use_dt_domains != 1) {
+		use_dt_domains = 0;
+		domain = pci_get_new_domain_nr();
+	} else {
+		dev_err(parent, "Node %s has inconsistent \"linux,pci-domain\" property in DT\n",
+			parent->of_node->full_name);
+		domain = -1;
+	}
+
+	bus->domain_nr = domain;
+}
+#endif
 #endif
 
 /**

commit 9d050966e2eb37a643ac15904b6a8fda7fcfabe9
Merge: c0222ac08666 4ef8e3f35048
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Dec 11 18:15:33 2014 -0800

    Merge tag 'stable/for-linus-3.19-rc0-tag' of git://git.kernel.org/pub/scm/linux/kernel/git/xen/tip
    
    Pull xen features and fixes from David Vrabel:
    
     - Fully support non-coherent devices on ARM by introducing the
       mechanisms to request the hypervisor to perform the required cache
       maintainance operations.
    
     - A number of pciback bug fixes and cleanups.  Notably a deadlock fix
       if a PCI device was manually uunbound and a fix for incorrectly
       restoring state after a function reset.
    
     - In x86 PVHVM guests, use the APIC for interrupts if this has been
       virtualized by the hardware.  This reduces the number of interrupt-
       related VM exits on such hardware.
    
    * tag 'stable/for-linus-3.19-rc0-tag' of git://git.kernel.org/pub/scm/linux/kernel/git/xen/tip: (26 commits)
      Revert "swiotlb-xen: pass dev_addr to swiotlb_tbl_unmap_single"
      xen/pci: Use APIC directly when APIC virtualization hardware is available
      xen/pci: Defer initialization of MSI ops on HVM guests
      xen-pciback: drop SR-IOV VFs when PF driver unloads
      xen/pciback: Restore configuration space when detaching from a guest.
      PCI: Expose pci_load_saved_state for public consumption.
      xen/pciback: Remove tons of dereferences
      xen/pciback: Print out the domain owning the device.
      xen/pciback: Include the domain id if removing the device whilst still in use
      driver core: Provide an wrapper around the mutex to do lockdep warnings
      xen/pciback: Don't deadlock when unbinding.
      swiotlb-xen: pass dev_addr to swiotlb_tbl_unmap_single
      swiotlb-xen: call xen_dma_sync_single_for_device when appropriate
      swiotlb-xen: remove BUG_ON in xen_bus_to_phys
      swiotlb-xen: pass dev_addr to xen_dma_unmap_page and xen_dma_sync_single_for_cpu
      xen/arm: introduce GNTTABOP_cache_flush
      xen/arm/arm64: introduce xen_arch_need_swiotlb
      xen/arm/arm64: merge xen/mm32.c into xen/mm.c
      xen/arm: use hypercall to flush caches in map_page
      xen: add a dma_addr_t dev_addr argument to xen_dma_map_page
      ...

commit 98d9b271250bd83337e3ed66d63e7deefcda8712
Author: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
Date:   Wed Dec 3 16:40:31 2014 -0500

    PCI: Expose pci_load_saved_state for public consumption.
    
    We have the pci_load_and_free_saved_state, and pci_store_saved_state
    but are missing the functionality to just load the state
    multiple times in the PCI device without having to free/save
    the state.
    
    This patch makes it possible to use this function.
    
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: David Vrabel <david.vrabel@citrix.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 625a4ace10b4..f00a9d63fd7d 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1142,8 +1142,8 @@ EXPORT_SYMBOL_GPL(pci_store_saved_state);
  * @dev: PCI device that we're dealing with
  * @state: Saved state returned from pci_store_saved_state()
  */
-static int pci_load_saved_state(struct pci_dev *dev,
-				struct pci_saved_state *state)
+int pci_load_saved_state(struct pci_dev *dev,
+			 struct pci_saved_state *state)
 {
 	struct pci_cap_saved_data *cap;
 
@@ -1171,6 +1171,7 @@ static int pci_load_saved_state(struct pci_dev *dev,
 	dev->state_saved = true;
 	return 0;
 }
+EXPORT_SYMBOL_GPL(pci_load_saved_state);
 
 /**
  * pci_load_and_free_saved_state - Reload the save state pointed to by state,

commit 18e88beceb1838cfa7cc1a9abf16f5b419e11fdd
Merge: 35437e3d9b41 26ff46c6f23b a4acded086c4 bb383e283b2c 63692df103e9 23cf1d006f1a
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Nov 19 15:10:33 2014 -0700

    Merge branches 'pci/enumeration', 'pci/hotplug', 'pci/misc', 'pci/numa' and 'pci/virtualization' into next
    
    * pci/enumeration:
      PCI: Remove fixed parameter in pci_iov_resource_bar()
      PCI: Add informational printk for invalid BARs
      PCI: Shrink decoding-disabled window while sizing BARs
      PCI: Restore detection of read-only BARs
    
    * pci/hotplug:
      PCI: Remove unused and broken to_hotplug_slot()
    
    * pci/misc:
      PCI: Make FLR and AF FLR reset warning messages different
      PCI: Simplify if-return sequences
      PCI: Delete unnecessary NULL pointer checks
    
    * pci/numa:
      PCI: Allow numa_node override via sysfs
    
    * pci/virtualization:
      xen/pcifront: Process failure for pcifront_(re)scan_root()

commit 26ff46c6f23bb1497aaa1364a5c73a109493b653
Author: Myron Stowe <myron.stowe@redhat.com>
Date:   Tue Nov 11 08:04:50 2014 -0700

    PCI: Remove fixed parameter in pci_iov_resource_bar()
    
    pci_iov_resource_bar() always sets its 'pci_bar_type' parameter to
    'pci_bar_unknown'.  Drop the parameter and just use 'pci_bar_unknown'
    directly in the callers.
    
    No functional change intended.
    
    Signed-off-by: Myron Stowe <myron.stowe@redhat.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    CC: Chris Wright <chrisw@sous-sol.org>
    CC: Yu Zhao <yuzhao@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 625a4ace10b4..7bf246595c63 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -4180,7 +4180,8 @@ int pci_resource_bar(struct pci_dev *dev, int resno, enum pci_bar_type *type)
 		return dev->rom_base_reg;
 	} else if (resno < PCI_BRIDGE_RESOURCES) {
 		/* device specific resource */
-		reg = pci_iov_resource_bar(dev, resno, type);
+		*type = pci_bar_unknown;
+		reg = pci_iov_resource_bar(dev, resno);
 		if (reg)
 			return reg;
 	}

commit bb383e283b2c2dca8eb5152a1a2477efcc469431
Author: Gavin Shan <gwshan@linux.vnet.ibm.com>
Date:   Wed Nov 12 13:41:51 2014 +1100

    PCI: Make FLR and AF FLR reset warning messages different
    
    We have same warning message for FLR and AF FLR and users can't know which
    type of resets the PCI device is taking when there are pending
    transactions.  Print different messages for FLR and AF FLR cases.
    
    [bhelgaas: make code structure parallel, add "anyway" to suggest risk]
    Signed-off-by: Gavin Shan <gwshan@linux.vnet.ibm.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 9a5871f530a7..e8b3627e5474 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -3140,12 +3140,10 @@ static int pcie_flr(struct pci_dev *dev, int probe)
 		return 0;
 
 	if (!pci_wait_for_pending_transaction(dev))
-		dev_err(&dev->dev, "transaction is not cleared; proceeding with reset anyway\n");
+		dev_err(&dev->dev, "timed out waiting for pending transaction; performing function level reset anyway\n");
 
 	pcie_capability_set_word(dev, PCI_EXP_DEVCTL, PCI_EXP_DEVCTL_BCR_FLR);
-
 	msleep(100);
-
 	return 0;
 }
 
@@ -3170,16 +3168,12 @@ static int pci_af_flr(struct pci_dev *dev, int probe)
 	 * is used, so we use the conrol offset rather than status and shift
 	 * the test bit to match.
 	 */
-	if (pci_wait_for_pending(dev, pos + PCI_AF_CTRL,
+	if (!pci_wait_for_pending(dev, pos + PCI_AF_CTRL,
 				 PCI_AF_STATUS_TP << 8))
-		goto clear;
+		dev_err(&dev->dev, "timed out waiting for pending transaction; performing AF function level reset anyway\n");
 
-	dev_err(&dev->dev, "transaction is not cleared; proceeding with reset anyway\n");
-
-clear:
 	pci_write_config_byte(dev, pos + PCI_AF_CTRL, PCI_AF_CTRL_FLR);
 	msleep(100);
-
 	return 0;
 }
 

commit 754834b9caae8d1380f66a5f0337547e9361094d
Author: Quentin Lambert <lambert.quentin@gmail.com>
Date:   Thu Nov 6 17:45:55 2014 +0100

    PCI: Simplify if-return sequences
    
    Simplify a trivial if-return sequence.  Possibly combine with a preceding
    function call.
    
    Generated by: scripts/coccinelle/misc/simple_return.cocci
    
    Signed-off-by: Quentin Lambert <lambert.quentin@gmail.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 625a4ace10b4..9a5871f530a7 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1012,11 +1012,7 @@ int pci_save_state(struct pci_dev *dev)
 	if (i != 0)
 		return i;
 
-	i = pci_save_vc_state(dev);
-	if (i != 0)
-		return i;
-
-	return 0;
+	return pci_save_vc_state(dev);
 }
 EXPORT_SYMBOL(pci_save_state);
 

commit 07a7cbd3b815ea77b44d4d5bb4260b37d03a358d
Merge: cc0cb67adb97 d1e6dc91b532
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Oct 1 12:31:23 2014 -0600

    Merge branch 'pci/host-generic' into next
    
    * pci/host-generic:
      arm64: Add architectural support for PCI
      PCI: Add pci_remap_iospace() to map bus I/O resources
      of/pci: Add support for parsing PCI host bridge resources from DT
      of/pci: Add pci_get_new_domain_nr() and of_get_pci_domain_nr()
      PCI: Add generic domain handling
      of/pci: Fix the conversion of IO ranges into IO resources
      of/pci: Move of_pci_range_to_resource() to of/address.c
      ARM: Define PCI_IOBASE as the base of virtual PCI IO space
      of/pci: Add pci_register_io_range() and pci_pio_to_address()
      asm-generic/io.h: Fix ioport_map() for !CONFIG_GENERIC_IOMAP
    
    Conflicts:
            drivers/pci/host/pci-tegra.c

commit 8b921acfeffdb0b45085da862fc301a2d25ed2cf
Author: Liviu Dudau <Liviu.Dudau@arm.com>
Date:   Mon Sep 29 15:29:30 2014 +0100

    PCI: Add pci_remap_iospace() to map bus I/O resources
    
    Add pci_remap_iospace() to map bus I/O resources into the CPU virtual
    address space.  Architectures with special needs may provide their own
    version, but most should be able to use this one.
    
    This function is useful for PCI host bridge drivers that need to map the
    PCI I/O resources into virtual memory space.
    
    [bhelgaas: phys_addr description, drop temporary "err" variable]
    Signed-off-by: Liviu Dudau <Liviu.Dudau@arm.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rob Herring <robh@kernel.org>
    Reviewed-by: Catalin Marinas <catalin.marinas@arm.com>
    CC: Arnd Bergmann <arnd@arndb.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index d36f35ff6c5d..6e994fc077f4 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2704,6 +2704,37 @@ int pci_request_regions_exclusive(struct pci_dev *pdev, const char *res_name)
 }
 EXPORT_SYMBOL(pci_request_regions_exclusive);
 
+/**
+ *	pci_remap_iospace - Remap the memory mapped I/O space
+ *	@res: Resource describing the I/O space
+ *	@phys_addr: physical address of range to be mapped
+ *
+ *	Remap the memory mapped I/O space described by the @res
+ *	and the CPU physical address @phys_addr into virtual address space.
+ *	Only architectures that have memory mapped IO functions defined
+ *	(and the PCI_IOBASE value defined) should call this function.
+ */
+int __weak pci_remap_iospace(const struct resource *res, phys_addr_t phys_addr)
+{
+#if defined(PCI_IOBASE) && defined(CONFIG_MMU)
+	unsigned long vaddr = (unsigned long)PCI_IOBASE + res->start;
+
+	if (!(res->flags & IORESOURCE_IO))
+		return -EINVAL;
+
+	if (res->end > IO_SPACE_LIMIT)
+		return -EINVAL;
+
+	return ioremap_page_range(vaddr, vaddr + resource_size(res), phys_addr,
+				  pgprot_device(PAGE_KERNEL));
+#else
+	/* this architecture does not have memory mapped I/O space,
+	   so this function should never be called */
+	WARN_ONCE(1, "This architecture does not support memory mapped I/O\n");
+	return -ENODEV;
+#endif
+}
+
 static void __pci_set_master(struct pci_dev *dev, bool enable)
 {
 	u16 old_cmd, cmd;

commit 41e5c0f81d3e676d671d96a0a1fafb27abfbd9d7
Author: Liviu Dudau <Liviu.Dudau@arm.com>
Date:   Mon Sep 29 15:29:27 2014 +0100

    of/pci: Add pci_get_new_domain_nr() and of_get_pci_domain_nr()
    
    Add pci_get_new_domain_nr() to allocate a new domain number and
    of_get_pci_domain_nr() to retrieve the PCI domain number of a given device
    from DT.  Host bridge drivers or architecture-specific code can choose to
    implement their PCI domain number policy using these two functions.
    
    Using of_get_pci_domain_nr() guarantees a stable PCI domain number on every
    boot provided that all host bridge controllers are assigned a number in the
    device tree using "linux,pci-domain" property.  Mixing use of
    pci_get_new_domain_nr() and of_get_pci_domain_nr() is not recommended as it
    can lead to potentially conflicting domain numbers being assigned to root
    buses behind different host bridges.
    
    Signed-off-by: Liviu Dudau <Liviu.Dudau@arm.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    CC: Arnd Bergmann <arnd@arndb.de>
    CC: Grant Likely <grant.likely@linaro.org>
    CC: Rob Herring <robh+dt@kernel.org>
    CC: Catalin Marinas <catalin.marinas@arm.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 2c9ac70254e2..d36f35ff6c5d 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -4406,6 +4406,15 @@ static void pci_no_domains(void)
 #endif
 }
 
+#ifdef CONFIG_PCI_DOMAINS
+static atomic_t __domain_nr = ATOMIC_INIT(-1);
+
+int pci_get_new_domain_nr(void)
+{
+	return atomic_inc_return(&__domain_nr);
+}
+#endif
+
 /**
  * pci_ext_cfg_avail - can we access extended PCI config space?
  *

commit c0ed74e9d026af7b4f79bc29aaac37aac5b6e0a4
Merge: b1bf29577870 89ec3dcf17fd 89b51cb5c3b0 2f4096e311ef
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Sep 25 13:52:02 2014 -0600

    Merge branches 'pci/enumeration', 'pci/virtualization' and 'pci/cleanup' into next
    
    * pci/enumeration:
      PCI: Generate uppercase hex for modalias interface class
    
    * pci/virtualization:
      PCI: Add ACS quirk for Solarflare SFC9120 & SFC9140
      PCI: Remove unused pci_get_dma_source()
      PCI: Remove unused pci_find_upstream_pcie_bridge()
    
    * pci/cleanup:
      PCI: Remove assignment from complicated "if" conditions
      PCI: Remove assignment from "if" conditions
      PCI: Remove unnecessary curly braces
      PCI: Add space before open parenthesis

commit 79e50e72986c9fcb06d707ce587cfd24fefa33e3
Author: Quentin Lambert <lambert.quentin@gmail.com>
Date:   Sun Sep 7 20:03:32 2014 +0200

    PCI: Remove assignment from "if" conditions
    
    The following Coccinelle semantic patch was used to find and correct cases
    of assignments in "if" conditions:
    
    @@
    expression var, expr;
    statement S;
    @@
    
    + var = expr;
      if(
    - (var = expr)
    + var
      ) S
    
    Signed-off-by: Quentin Lambert <lambert.quentin@gmail.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 2c9ac70254e2..8b63a5b11fc6 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1003,12 +1003,19 @@ int pci_save_state(struct pci_dev *dev)
 	for (i = 0; i < 16; i++)
 		pci_read_config_dword(dev, i * 4, &dev->saved_config_space[i]);
 	dev->state_saved = true;
-	if ((i = pci_save_pcie_state(dev)) != 0)
+
+	i = pci_save_pcie_state(dev);
+	if (i != 0)
 		return i;
-	if ((i = pci_save_pcix_state(dev)) != 0)
+
+	i = pci_save_pcix_state(dev);
+	if (i != 0)
 		return i;
-	if ((i = pci_save_vc_state(dev)) != 0)
+
+	i = pci_save_vc_state(dev);
+	if (i != 0)
 		return i;
+
 	return 0;
 }
 EXPORT_SYMBOL(pci_save_state);

commit 385321e2c65a5c4812ef64f46c248c9b8ef66b90
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Jul 21 03:18:24 2014 +0200

    PCI/PM: Allow PCI devices to be put into D3cold during system suspend
    
    Commit 448bd857d48e ("PCI/PM: add PCIe runtime D3cold support") added a
    check to prevent PCI devices from being put into D3cold during system
    suspend without giving any particular reason.
    
    Also the check isn't really necessary, because acpi_pci_set_power_state()
    maps PCI_D3hot to ACPI_STATE_D3_COLD anyway.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 2c9ac70254e2..87680bc4c985 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1907,10 +1907,6 @@ int pci_prepare_to_sleep(struct pci_dev *dev)
 	if (target_state == PCI_POWER_ERROR)
 		return -EIO;
 
-	/* D3cold during system suspend/hibernate is not supported */
-	if (target_state > PCI_D3hot)
-		target_state = PCI_D3hot;
-
 	pci_enable_wake(dev, target_state, device_may_wakeup(&dev->dev));
 
 	error = pci_set_power_state(dev, target_state);

commit f74ad8df4e74db550e5a2372cc1f025e56e1d523
Merge: 19583ca584d6 792688fde431
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Aug 4 09:29:37 2014 -0700

    Merge tag 'pci-v3.17-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI updates from Bjorn Helgaas:
     "I'll be on vacation until Aug 11, and I suspect the merge window will
      open before then, so I'm sending this to you early.  There are more
      things I'd like to get into v3.17, so I hope to send another pull
      request soon after I return.
    
      The most notable pieces here are:
    
       - Support BARs up to 128GB (up from 8GB)
       - Fix SR-IOV resource assignment when we fail to expand a resource
       - Rework pciehp to handle a common hardware erratum
       - Cleanup MSI
       - Fix NIC renaming issue
       - Fix VGA default device issue on EFI systems
       - Fix ASPM configuration (previously we didn't enable it as expected)
    
      Alex Williamson has graciously agreed to take care of any major issues
      with this if you take it before I return.
    
      Details:
    
      Resource management
        - Support BAR sizes up to 128GB (Yinghai Lu)
        - Keep original resource if we fail to expand it (Guo Chao)
        - Return conventional error values from pci_revert_fw_address() (Bjorn Helgaas)
        - Tidy resource assignment messages (Bjorn Helgaas)
        - Don't exclude low BIOS area for non-PCI cards (Christoph Schulz)
    
      PCI device hotplug
        - Prevent NULL dereference during pciehp probe (Andreas Noever)
        - Make pciehp pcie_wait_cmd() self-contained (Bjorn Helgaas)
        - Wait for pciehp hotplug command completion lazily (Bjorn Helgaas)
        - Compute pciehp timeout from hotplug command start time (Bjorn Helgaas)
        - Remove pciehp assumptions about which commands cause completion events (Bjorn Helgaas)
        - Clear pciehp Data Link Layer State Changed during init (Myron Stowe)
        - Remove pciehp struct controller.no_cmd_complete (Rajat Jain)
        - Remove cpqphp unnecessary null test (Fabian Frederick)
        - Remove "invalid IRQ" warning for hot-added PCIe ports (Jiang Liu)
    
      IOMMU
        - Add DMA alias quirk for Intel 82801 bridge (Alex Williamson)
    
      MSI
        - Add internal msix_clear_and_set_ctrl() (Yijing Wang)
        - Remove unused msi_enabled_mask() (Yijing Wang)
        - Cache Multiple Message Capable in struct msi_desc (Yijing Wang)
        - Add msi_setup_entry() to clean up initialization (Yijing Wang)
        - Remove unused msi_remove_pci_irq_vectors() (Yijing Wang)
        - Retrieve first MSI IRQ from msi_desc rather than pci_dev (Yijing Wang)
        - Remove unused list access in __pci_restore_msix_state() (Yijing Wang)
        - Use irq_get_msi_desc() to simplify code (Yijing Wang)
    
      Generic host bridge driver
        - Fix GPL v2 license string typo (Bjorn Helgaas)
    
      Marvell MVEBU
        - Fix GPL v2 license string typo (Thierry Reding)
    
      NVIDIA Tegra
        - Use correct initial HW settings (Phil Edworthy)
        - Remove rcar_pcie_setup_window() resource argument (Phil Edworthy)
        - Fix GPL v2 license string typo (Thierry Reding)
    
      Renesas R-Car
        - Remove redundant config accessor register checks (Sergei Shtylyov)
        - Fix GPL v2 license string typo (Bjorn Helgaas)
    
      Virtualization
        - Factor secondary bus reset logic (Gavin Shan)
        - Remove duplicate powerpc reset logic (Gavin Shan)
    
      Miscellaneous
        - Rework default VGA detection for EFI (Bruno Prémont)
        - Fix sysfs "acpi_index" and "label" errors for NIC renaming (Simone Gotti)
        - Configure ASPM at pci_enable_device()-time (Vidya Sagar)
        - Add include/linux/pci_ids.h include guard (Rasmus Villemoes)"
    
    * tag 'pci-v3.17-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (38 commits)
      PCI/MSI: Use irq_get_msi_desc() to simplify code
      PCI/MSI: Remove unused list access in __pci_restore_msix_state()
      PCI/MSI: Retrieve first MSI IRQ from msi_desc rather than pci_dev
      PCI/MSI: Remove unused function msi_remove_pci_irq_vectors()
      PCI/MSI: Add msi_setup_entry() to clean up MSI initialization
      PCI: Configure ASPM when enabling device
      x86: don't exclude low BIOS area when allocating address space for non-PCI cards
      PCI: generic: Fix GPL v2 license string typo
      PCI: rcar: Fix GPL v2 license string typo
      PCI: tegra: Fix GPL v2 license string typo
      PCI: mvebu: Fix GPL v2 license string typo
      PCI: Add include guard to include/linux/pci_ids.h
      x86, ia64: Move EFI_FB vga_default_device() initialization to pci_vga_fixup()
      PCI: Tidy resource assignment messages
      PCI: Return conventional error values from pci_revert_fw_address()
      PCI: Cleanup control flow
      PCI: Support BAR sizes up to 128GB
      PCI: cpqphp: Remove unnecessary null test before debugfs_remove()
      PCI: pciehp: Clear Data Link Layer State Changed during init
      PCI: Add bridge DMA alias quirk for Intel 82801 bridge
      ...

commit 792688fde431b4fdb2cf10a6f7589a8176b6b14a
Merge: 1d0df48692af eed6542dd53f 505d8655f710 68947eb17503 d975cb5703c3 e11ece5a5e42 1f6ae47ecff7 64da465e9841 21dd5a43d00c
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Jul 16 17:09:47 2014 -0600

    Merge branches 'pci/host-generic', 'pci/host-mvebu', 'pci/host-rcar', 'pci/host-tegra', 'pci/msi', 'pci/misc', 'pci/resource' and 'pci/virtualization' into next
    
    * pci/host-generic:
      PCI: generic: Fix GPL v2 license string typo
    
    * pci/host-mvebu:
      PCI: mvebu: Fix GPL v2 license string typo
    
    * pci/host-rcar:
      PCI: rcar: Fix GPL v2 license string typo
    
    * pci/host-tegra:
      PCI: tegra: Fix GPL v2 license string typo
    
    * pci/msi:
      PCI/MSI: Use irq_get_msi_desc() to simplify code
      PCI/MSI: Remove unused list access in __pci_restore_msix_state()
      PCI/MSI: Retrieve first MSI IRQ from msi_desc rather than pci_dev
      PCI/MSI: Remove unused function msi_remove_pci_irq_vectors()
      PCI/MSI: Add msi_setup_entry() to clean up MSI initialization
    
    * pci/misc:
      PCI: Configure ASPM when enabling device
      x86: don't exclude low BIOS area when allocating address space for non-PCI cards
      PCI: Add include guard to include/linux/pci_ids.h
      x86, ia64: Move EFI_FB vga_default_device() initialization to pci_vga_fixup()
    
    * pci/resource:
      PCI: Tidy resource assignment messages
      PCI: Return conventional error values from pci_revert_fw_address()
      PCI: Cleanup control flow
      PCI: Support BAR sizes up to 128GB
      PCI: Keep original resource if we fail to expand it
    
    * pci/virtualization:
      powerpc/pci: Remove duplicate logic
      PCI: Make resetting secondary bus logic common

commit 1f6ae47ecff7f23da73417e068018b311f3b5583
Author: Vidya Sagar <sagar.tv@gmail.com>
Date:   Wed Jul 16 15:33:42 2014 +0530

    PCI: Configure ASPM when enabling device
    
    We can't do ASPM configuration at enumeration-time because enabling it
    makes some defective hardware unresponsive, even if ASPM is disabled later
    (see 41cd766b0659 ("PCI: Don't enable aspm before drivers have had a chance
    to veto it").  Therefore, we have to do it after a driver claims the
    device.
    
    We previously configured ASPM in pci_set_power_state(), but that's not a
    very good place because it's not really related to setting the PCI device
    power state, and doing it there means:
    
      - We incorrectly skipped ASPM config when setting a device that's
        already in D0 to D0.
    
      - We unnecessarily configured ASPM when setting a device to a low-power
        state (the ASPM feature only applies when the device is in D0).
    
      - We unnecessarily configured ASPM when called from a .resume() method
        (ASPM configuration needs to be restored during resume, but
        pci_restore_pcie_state() should already do this).
    
    Move ASPM configuration from pci_set_power_state() to
    do_pci_enable_device() so we do it when a driver enables a device.
    
    [bhelgaas: changelog]
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=79621
    Fixes: db288c9c5f9d ("PCI / PM: restore the original behavior of pci_set_power_state()")
    Suggested-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Vidya Sagar <sagar.tv@gmail.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    CC: stable@vger.kernel.org      # v3.6+

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 63a54a340863..75fabd1f72bc 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -839,12 +839,6 @@ int pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 
 	if (!__pci_complete_power_transition(dev, state))
 		error = 0;
-	/*
-	 * When aspm_policy is "powersave" this call ensures
-	 * that ASPM is configured.
-	 */
-	if (!error && dev->bus->self)
-		pcie_aspm_powersave_config_link(dev->bus->self);
 
 	return error;
 }
@@ -1195,12 +1189,18 @@ int __weak pcibios_enable_device(struct pci_dev *dev, int bars)
 static int do_pci_enable_device(struct pci_dev *dev, int bars)
 {
 	int err;
+	struct pci_dev *bridge;
 	u16 cmd;
 	u8 pin;
 
 	err = pci_set_power_state(dev, PCI_D0);
 	if (err < 0 && err != -EIO)
 		return err;
+
+	bridge = pci_upstream_bridge(dev);
+	if (bridge)
+		pcie_aspm_powersave_config_link(bridge);
+
 	err = pcibios_enable_device(dev, bars);
 	if (err < 0)
 		return err;

commit 9e33002fd1791bcab626b19301670484c1cb6d50
Author: Gavin Shan <gwshan@linux.vnet.ibm.com>
Date:   Thu Jun 19 17:22:44 2014 +1000

    PCI: Make resetting secondary bus logic common
    
    Commit d92a208d086 ("powerpc/pci: Mask linkDown on resetting PCI bus")
    implemented same logic (resetting PCI secondary bus by bridge's config
    register PCI_BRIDGE_CTL_BUS_RESET) in PCI core and arch-dependent code.  To
    avoid the duplication, move the logic to pci_reset_secondary_bus().
    
    That commit did not declare the pcibios_reset_secondary_bus() interface in
    linux/include/pci.h.  Add the declaration.
    
    No functional change.
    
    Signed-off-by: Gavin Shan <gwshan@linux.vnet.ibm.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 63a54a340863..758f1d88f28d 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -3193,7 +3193,7 @@ static int pci_pm_reset(struct pci_dev *dev, int probe)
 	return 0;
 }
 
-void __weak pcibios_reset_secondary_bus(struct pci_dev *dev)
+void pci_reset_secondary_bus(struct pci_dev *dev)
 {
 	u16 ctrl;
 
@@ -3219,6 +3219,11 @@ void __weak pcibios_reset_secondary_bus(struct pci_dev *dev)
 	ssleep(1);
 }
 
+void __weak pcibios_reset_secondary_bus(struct pci_dev *dev)
+{
+	pci_reset_secondary_bus(dev);
+}
+
 /**
  * pci_reset_bridge_secondary_bus - Reset the secondary bus on a PCI bridge.
  * @dev: Bridge device

commit d066c946a866268c14a120b33e7226e899981998
Author: Alex Williamson <alex.williamson@redhat.com>
Date:   Tue Jun 17 15:40:13 2014 -0600

    PCI: Fix unaligned access in AF transaction pending test
    
    pci_wait_for_pending() uses word access, so we shouldn't be passing
    an offset that is only byte aligned.  Use the control register offset
    instead, shifting the mask to match.
    
    Fixes: d0b4cc4e3270 ("PCI: Wrong register used to check pending traffic")
    Fixes: 157e876ffe0b ("PCI: Add pci_wait_for_pending() (refactor pci_wait_for_pending_transaction())
    Reported-by: Ben Hutchings <ben@decadent.org.uk>
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Gavin Shan <gwshan@linux.vnet.ibm.com>
    CC: stable@vger.kernel.org      # v3.14+

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 63a54a340863..1c8592b0e146 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -3135,8 +3135,13 @@ static int pci_af_flr(struct pci_dev *dev, int probe)
 	if (probe)
 		return 0;
 
-	/* Wait for Transaction Pending bit clean */
-	if (pci_wait_for_pending(dev, pos + PCI_AF_STATUS, PCI_AF_STATUS_TP))
+	/*
+	 * Wait for Transaction Pending bit to clear.  A word-aligned test
+	 * is used, so we use the conrol offset rather than status and shift
+	 * the test bit to match.
+	 */
+	if (pci_wait_for_pending(dev, pos + PCI_AF_CTRL,
+				 PCI_AF_STATUS_TP << 8))
 		goto clear;
 
 	dev_err(&dev->dev, "transaction is not cleared; proceeding with reset anyway\n");

commit 7550cfab3d4053b54f16e2fe337affde71d1eb51
Merge: 19c1940feab7 38a6148248e1
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jun 12 13:20:24 2014 -0700

    Merge tag 'pci-v3.16-changes-2' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull more PCI updates from Bjorn Helgaas:
     "Here are some more things I'd like to see in v3.16-rc1:
    
       - DMA alias iterator, part of some work to fix IOMMU issues
       - MVEBU, Tegra, DesignWare changes that I forgot to include before
       - Some whitespace code cleanup
    
      Details:
    
      IOMMU
        - Add DMA alias iterator (Alex Williamson)
        - Add DMA alias quirks for ASMedia, ITE, Tundra bridges (Alex Williamson)
        - Add DMA alias quirks for Marvell, Ricoh devices (Alex Williamson)
        - Add DMA alias quirk for HighPoint devices (Jérôme Carretero)
    
      MSI
        - Fix leak in free_msi_irqs() (Alexei Starovoitov)
    
      Marvell MVEBU
        - Remove unnecessary use of 'conf_lock' spinlock (Andrew Murray)
        - Avoid setting an undefined window size (Jason Gunthorpe)
        - Allow several windows with the same target/attribute (Thomas Petazzoni)
        - Split PCIe BARs into multiple MBus windows when needed (Thomas Petazzoni)
        - Fix off-by-one in the computed size of the mbus windows (Willy Tarreau)
    
      NVIDIA Tegra
        - Use new OF interrupt mapping when possible (Lucas Stach)
    
      Synopsys DesignWare
        - Remove unnecessary use of 'conf_lock' spinlock (Andrew Murray)
        - Use new OF interrupt mapping when possible (Lucas Stach)
        - Split Exynos and i.MX bindings (Lucas Stach)
        - Fix comment for setting number of lanes (Mohit Kumar)
        - Fix iATU programming for cfg1, io and mem viewport (Mohit Kumar)
    
      Miscellaneous
        - EXPORT_SYMBOL cleanup (Ryan Desfosses)
        - Whitespace cleanup (Ryan Desfosses)
        - Merge multi-line quoted strings (Ryan Desfosses)"
    
    * tag 'pci-v3.16-changes-2' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (21 commits)
      PCI: Add function 1 DMA alias quirk for HighPoint RocketRaid 642L
      PCI/MSI: Fix memory leak in free_msi_irqs()
      PCI: Merge multi-line quoted strings
      PCI: Whitespace cleanup
      PCI: Move EXPORT_SYMBOL so it immediately follows function/variable
      PCI: Add bridge DMA alias quirk for ITE bridge
      PCI: designware: Split Exynos and i.MX bindings
      PCI: Add bridge DMA alias quirk for ASMedia and Tundra bridges
      PCI: Add support for PCIe-to-PCI bridge DMA alias quirks
      PCI: Add function 1 DMA alias quirk for Marvell devices
      PCI: Add function 0 DMA alias quirk for Ricoh devices
      PCI: Add support for DMA alias quirks
      PCI: Convert pci_dev_flags definitions to bit shifts
      PCI: Add DMA alias iterator
      PCI: mvebu: Use '%pa' for printing 'phys_addr_t' type
      PCI: mvebu: Remove unnecessary use of 'conf_lock' spinlock
      PCI: designware: Remove unnecessary use of 'conf_lock' spinlock
      PCI: designware: Use new OF interrupt mapping when possible
      PCI: designware: Fix iATU programming for cfg1, io and mem viewport
      PCI: designware: Fix comment for setting number of lanes
      ...

commit 227f06470502c4fea3d93df1f12a77e3e37f6263
Author: Ryan Desfosses <ryan@desfo.org>
Date:   Fri Apr 18 20:13:50 2014 -0400

    PCI: Merge multi-line quoted strings
    
    Merge quoted strings that are broken across lines into a single entity.
    The compiler merges them anyway, but checkpatch complains about it, and
    merging them makes it easier to grep for strings.
    
    No functional change.
    
    [bhelgaas: changelog, do the same for everything under drivers/pci]
    Signed-off-by: Ryan Desfosses <ryan@desfo.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 952b4b489d0f..0a271a100986 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -555,8 +555,8 @@ static int pci_raw_set_power_state(struct pci_dev *dev, pci_power_t state)
 	 */
 	if (state != PCI_D0 && dev->current_state <= PCI_D3cold
 	    && dev->current_state > state) {
-		dev_err(&dev->dev, "invalid power transition "
-			"(from state %d to %d)\n", dev->current_state, state);
+		dev_err(&dev->dev, "invalid power transition (from state %d to %d)\n",
+			dev->current_state, state);
 		return -EINVAL;
 	}
 
@@ -603,8 +603,8 @@ static int pci_raw_set_power_state(struct pci_dev *dev, pci_power_t state)
 	pci_read_config_word(dev, dev->pm_cap + PCI_PM_CTRL, &pmcsr);
 	dev->current_state = (pmcsr & PCI_PM_CTRL_STATE_MASK);
 	if (dev->current_state != state && printk_ratelimit())
-		dev_info(&dev->dev, "Refused to change power state, "
-			"currently in D%d\n", dev->current_state);
+		dev_info(&dev->dev, "Refused to change power state, currently in D%d\n",
+			 dev->current_state);
 
 	/*
 	 * According to section 5.4.1 of the "PCI BUS POWER MANAGEMENT
@@ -1029,8 +1029,8 @@ static void pci_restore_config_dword(struct pci_dev *pdev, int offset,
 		return;
 
 	for (;;) {
-		dev_dbg(&pdev->dev, "restoring config space at offset "
-			"%#x (was %#x, writing %#x)\n", offset, val, saved_val);
+		dev_dbg(&pdev->dev, "restoring config space at offset %#x (was %#x, writing %#x)\n",
+			offset, val, saved_val);
 		pci_write_config_dword(pdev, offset, saved_val);
 		if (retry-- <= 0)
 			return;
@@ -2815,8 +2815,8 @@ int pci_set_cacheline_size(struct pci_dev *dev)
 	if (cacheline_size == pci_cache_line_size)
 		return 0;
 
-	dev_printk(KERN_DEBUG, &dev->dev, "cache line size of %d is not "
-		   "supported\n", pci_cache_line_size << 2);
+	dev_printk(KERN_DEBUG, &dev->dev, "cache line size of %d is not supported\n",
+		   pci_cache_line_size << 2);
 
 	return -EINVAL;
 }
@@ -2952,8 +2952,8 @@ bool pci_intx_mask_supported(struct pci_dev *dev)
 	 * go ahead and check it.
 	 */
 	if ((new ^ orig) & ~PCI_COMMAND_INTX_DISABLE) {
-		dev_err(&dev->dev, "Command register changed from "
-			"0x%x to 0x%x: driver or hardware bug?\n", orig, new);
+		dev_err(&dev->dev, "Command register changed from 0x%x to 0x%x: driver or hardware bug?\n",
+			orig, new);
 	} else if ((new ^ orig) & PCI_COMMAND_INTX_DISABLE) {
 		mask_supported = true;
 		pci_write_config_word(dev, PCI_COMMAND, orig);
@@ -3138,8 +3138,7 @@ static int pci_af_flr(struct pci_dev *dev, int probe)
 	if (pci_wait_for_pending(dev, PCI_AF_STATUS, PCI_AF_STATUS_TP))
 		goto clear;
 
-	dev_err(&dev->dev, "transaction is not cleared; "
-			"proceeding with reset anyway\n");
+	dev_err(&dev->dev, "transaction is not cleared; proceeding with reset anyway\n");
 
 clear:
 	pci_write_config_byte(dev, pos + PCI_AF_CTRL, PCI_AF_CTRL_FLR);

commit 3c78bc61f5ef3bc87e7f94f67ec737d2273f120b
Author: Ryan Desfosses <ryan@desfo.org>
Date:   Fri Apr 18 20:13:49 2014 -0400

    PCI: Whitespace cleanup
    
    Fix various whitespace errors.
    
    No functional change.
    
    [bhelgaas: fix other similar problems]
    Signed-off-by: Ryan Desfosses <ryan@desfo.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 51ec8b481280..952b4b489d0f 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -106,7 +106,7 @@ static bool pcie_ari_disabled;
  * Given a PCI bus, returns the highest PCI bus number present in the set
  * including the given PCI bus and its list of child PCI buses.
  */
-unsigned char pci_bus_max_busnr(struct pci_bus* bus)
+unsigned char pci_bus_max_busnr(struct pci_bus *bus)
 {
 	struct pci_bus *tmp;
 	unsigned char max, n;
@@ -114,7 +114,7 @@ unsigned char pci_bus_max_busnr(struct pci_bus* bus)
 	max = bus->busn_res.end;
 	list_for_each_entry(tmp, &bus->children, node) {
 		n = pci_bus_max_busnr(tmp);
-		if(n > max)
+		if (n > max)
 			max = n;
 	}
 	return max;
@@ -405,8 +405,8 @@ EXPORT_SYMBOL_GPL(pci_find_ht_capability);
  *  For given resource region of given device, return the resource
  *  region of parent bus the given region is contained in.
  */
-struct resource *
-pci_find_parent_resource(const struct pci_dev *dev, struct resource *res)
+struct resource *pci_find_parent_resource(const struct pci_dev *dev,
+					  struct resource *res)
 {
 	const struct pci_bus *bus = dev->bus;
 	struct resource *r;
@@ -473,8 +473,7 @@ int pci_wait_for_pending(struct pci_dev *dev, int pos, u16 mask)
  * Restore the BAR values for a given device, so as to make it
  * accessible by its driver.
  */
-static void
-pci_restore_bars(struct pci_dev *dev)
+static void pci_restore_bars(struct pci_dev *dev)
 {
 	int i;
 
@@ -499,7 +498,7 @@ static inline bool platform_pci_power_manageable(struct pci_dev *dev)
 }
 
 static inline int platform_pci_set_power_state(struct pci_dev *dev,
-                                                pci_power_t t)
+					       pci_power_t t)
 {
 	return pci_platform_pm ? pci_platform_pm->set_state(dev, t) : -ENOSYS;
 }
@@ -888,12 +887,10 @@ pci_power_t pci_choose_state(struct pci_dev *dev, pm_message_t state)
 	}
 	return PCI_D0;
 }
-
 EXPORT_SYMBOL(pci_choose_state);
 
 #define PCI_EXP_SAVE_REGS	7
 
-
 static struct pci_cap_saved_state *_pci_find_saved_cap(struct pci_dev *pci_dev,
 						       u16 cap, bool extended)
 {
@@ -1005,8 +1002,7 @@ static void pci_restore_pcix_state(struct pci_dev *dev)
  * pci_save_state - save the PCI configuration space of a device before suspending
  * @dev: - PCI device that we're dealing with
  */
-int
-pci_save_state(struct pci_dev *dev)
+int pci_save_state(struct pci_dev *dev)
 {
 	int i;
 	/* XXX: 100% dword access ok here? */
@@ -1381,7 +1377,7 @@ static void pcim_release(struct device *gendev, void *res)
 		pci_disable_device(dev);
 }
 
-static struct pci_devres * get_pci_dr(struct pci_dev *pdev)
+static struct pci_devres *get_pci_dr(struct pci_dev *pdev)
 {
 	struct pci_devres *dr, *new_dr;
 
@@ -1395,7 +1391,7 @@ static struct pci_devres * get_pci_dr(struct pci_dev *pdev)
 	return devres_get(&pdev->dev, new_dr, NULL, NULL);
 }
 
-static struct pci_devres * find_pci_dr(struct pci_dev *pdev)
+static struct pci_devres *find_pci_dr(struct pci_dev *pdev)
 {
 	if (pci_is_managed(pdev))
 		return devres_find(&pdev->dev, pcim_release, NULL, NULL);
@@ -1455,7 +1451,7 @@ EXPORT_SYMBOL(pcim_pin_device);
  * devices are added. This is the default implementation. Architecture
  * implementations can override this.
  */
-int __weak pcibios_add_device (struct pci_dev *dev)
+int __weak pcibios_add_device(struct pci_dev *dev)
 {
 	return 0;
 }
@@ -1527,8 +1523,7 @@ void pci_disable_enabled_device(struct pci_dev *dev)
  * Note we don't actually disable the device until all callers of
  * pci_enable_device() have called pci_disable_device().
  */
-void
-pci_disable_device(struct pci_dev *dev)
+void pci_disable_device(struct pci_dev *dev)
 {
 	struct pci_devres *dr;
 
@@ -2434,8 +2429,7 @@ u8 pci_swizzle_interrupt_pin(const struct pci_dev *dev, u8 pin)
 	return (((pin - 1) + slot) % 4) + 1;
 }
 
-int
-pci_get_interrupt_pin(struct pci_dev *dev, struct pci_dev **bridge)
+int pci_get_interrupt_pin(struct pci_dev *dev, struct pci_dev **bridge)
 {
 	u8 pin;
 
@@ -2518,8 +2512,8 @@ EXPORT_SYMBOL(pci_release_region);
  *	Returns 0 on success, or %EBUSY on error.  A warning
  *	message is also printed on failure.
  */
-static int __pci_request_region(struct pci_dev *pdev, int bar, const char *res_name,
-									int exclusive)
+static int __pci_request_region(struct pci_dev *pdev, int bar,
+				const char *res_name, int exclusive)
 {
 	struct pci_devres *dr;
 
@@ -2530,8 +2524,7 @@ static int __pci_request_region(struct pci_dev *pdev, int bar, const char *res_n
 		if (!request_region(pci_resource_start(pdev, bar),
 			    pci_resource_len(pdev, bar), res_name))
 			goto err_out;
-	}
-	else if (pci_resource_flags(pdev, bar) & IORESOURCE_MEM) {
+	} else if (pci_resource_flags(pdev, bar) & IORESOURCE_MEM) {
 		if (!__request_mem_region(pci_resource_start(pdev, bar),
 					pci_resource_len(pdev, bar), res_name,
 					exclusive))
@@ -2588,7 +2581,8 @@ EXPORT_SYMBOL(pci_request_region);
  *	explicitly not allowed to map the resource via /dev/mem or
  *	sysfs.
  */
-int pci_request_region_exclusive(struct pci_dev *pdev, int bar, const char *res_name)
+int pci_request_region_exclusive(struct pci_dev *pdev, int bar,
+				 const char *res_name)
 {
 	return __pci_request_region(pdev, bar, res_name, IORESOURCE_EXCLUSIVE);
 }
@@ -2613,7 +2607,7 @@ void pci_release_selected_regions(struct pci_dev *pdev, int bars)
 EXPORT_SYMBOL(pci_release_selected_regions);
 
 static int __pci_request_selected_regions(struct pci_dev *pdev, int bars,
-				 const char *res_name, int excl)
+					  const char *res_name, int excl)
 {
 	int i;
 
@@ -2624,7 +2618,7 @@ static int __pci_request_selected_regions(struct pci_dev *pdev, int bars,
 	return 0;
 
 err_out:
-	while(--i >= 0)
+	while (--i >= 0)
 		if (bars & (1 << i))
 			pci_release_region(pdev, i);
 
@@ -2645,8 +2639,8 @@ int pci_request_selected_regions(struct pci_dev *pdev, int bars,
 }
 EXPORT_SYMBOL(pci_request_selected_regions);
 
-int pci_request_selected_regions_exclusive(struct pci_dev *pdev,
-				 int bars, const char *res_name)
+int pci_request_selected_regions_exclusive(struct pci_dev *pdev, int bars,
+					   const char *res_name)
 {
 	return __pci_request_selected_regions(pdev, bars, res_name,
 			IORESOURCE_EXCLUSIVE);
@@ -2836,8 +2830,7 @@ EXPORT_SYMBOL_GPL(pci_set_cacheline_size);
  *
  * RETURNS: An appropriate -ERRNO error value on error, or zero for success.
  */
-int
-pci_set_mwi(struct pci_dev *dev)
+int pci_set_mwi(struct pci_dev *dev)
 {
 #ifdef PCI_DISABLE_MWI
 	return 0;
@@ -2850,7 +2843,7 @@ pci_set_mwi(struct pci_dev *dev)
 		return rc;
 
 	pci_read_config_word(dev, PCI_COMMAND, &cmd);
-	if (! (cmd & PCI_COMMAND_INVALIDATE)) {
+	if (!(cmd & PCI_COMMAND_INVALIDATE)) {
 		dev_dbg(&dev->dev, "enabling Mem-Wr-Inval\n");
 		cmd |= PCI_COMMAND_INVALIDATE;
 		pci_write_config_word(dev, PCI_COMMAND, cmd);
@@ -2885,8 +2878,7 @@ EXPORT_SYMBOL(pci_try_set_mwi);
  *
  * Disables PCI Memory-Write-Invalidate transaction on the device
  */
-void
-pci_clear_mwi(struct pci_dev *dev)
+void pci_clear_mwi(struct pci_dev *dev)
 {
 #ifndef PCI_DISABLE_MWI
 	u16 cmd;
@@ -2907,18 +2899,16 @@ EXPORT_SYMBOL(pci_clear_mwi);
  *
  * Enables/disables PCI INTx for device dev
  */
-void
-pci_intx(struct pci_dev *pdev, int enable)
+void pci_intx(struct pci_dev *pdev, int enable)
 {
 	u16 pci_command, new;
 
 	pci_read_config_word(pdev, PCI_COMMAND, &pci_command);
 
-	if (enable) {
+	if (enable)
 		new = pci_command & ~PCI_COMMAND_INTX_DISABLE;
-	} else {
+	else
 		new = pci_command | PCI_COMMAND_INTX_DISABLE;
-	}
 
 	if (new != pci_command) {
 		struct pci_devres *dr;
@@ -4159,7 +4149,7 @@ void __init pci_register_set_vga_state(arch_set_vga_state_t func)
 }
 
 static int pci_set_vga_state_arch(struct pci_dev *dev, bool decode,
-		      unsigned int command_bits, u32 flags)
+				  unsigned int command_bits, u32 flags)
 {
 	if (arch_set_vga_state)
 		return arch_set_vga_state(dev, decode, command_bits,
@@ -4271,11 +4261,10 @@ static resource_size_t pci_specified_resource_alignment(struct pci_dev *dev)
 			bus == dev->bus->number &&
 			slot == PCI_SLOT(dev->devfn) &&
 			func == PCI_FUNC(dev->devfn)) {
-			if (align_order == -1) {
+			if (align_order == -1)
 				align = PAGE_SIZE;
-			} else {
+			else
 				align = 1 << align_order;
-			}
 			/* Found */
 			break;
 		}
@@ -4393,7 +4382,6 @@ static int __init pci_resource_alignment_sysfs_init(void)
 	return bus_create_file(&pci_bus_type,
 					&bus_attr_resource_alignment);
 }
-
 late_initcall(pci_resource_alignment_sysfs_init);
 
 static void pci_no_domains(void)

commit c5aec4c76af1a2d89ee2f2d4d5463b2ad2d85de5
Merge: 2937f5efa575 0c0a3e5a100b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jun 10 18:54:22 2014 -0700

    Merge branch 'next' of git://git.kernel.org/pub/scm/linux/kernel/git/benh/powerpc
    
    Pull powerpc updates from Ben Herrenschmidt:
     "Here is the bulk of the powerpc changes for this merge window.  It got
      a bit delayed in part because I wasn't paying attention, and in part
      because I discovered I had a core PCI change without a PCI maintainer
      ack in it.  Bjorn eventually agreed it was ok to merge it though we'll
      probably improve it later and I didn't want to rebase to add his ack.
    
      There is going to be a bit more next week, essentially fixes that I
      still want to sort through and test.
    
      The biggest item this time is the support to build the ppc64 LE kernel
      with our new v2 ABI.  We previously supported v2 userspace but the
      kernel itself was a tougher nut to crack.  This is now sorted mostly
      thanks to Anton and Rusty.
    
      We also have a fairly big series from Cedric that add support for
      64-bit LE zImage boot wrapper.  This was made harder by the fact that
      traditionally our zImage wrapper was always 32-bit, but our new LE
      toolchains don't really support 32-bit anymore (it's somewhat there
      but not really "supported") so we didn't want to rely on it.  This
      meant more churn that just endian fixes.
    
      This brings some more LE bits as well, such as the ability to run in
      LE mode without a hypervisor (ie. under OPAL firmware) by doing the
      right OPAL call to reinitialize the CPU to take HV interrupts in the
      right mode and the usual pile of endian fixes.
    
      There's another series from Gavin adding EEH improvements (one day we
      *will* have a release with less than 20 EEH patches, I promise!).
    
      Another highlight is the support for the "Split core" functionality on
      P8 by Michael.  This allows a P8 core to be split into "sub cores" of
      4 threads which allows the subcores to run different guests under KVM
      (the HW still doesn't support a partition per thread).
    
      And then the usual misc bits and fixes ..."
    
    [ Further delayed by gmail deciding that BenH is a dirty spammer.
      Google knows.  ]
    
    * 'next' of git://git.kernel.org/pub/scm/linux/kernel/git/benh/powerpc: (155 commits)
      powerpc/powernv: Add missing include to LPC code
      selftests/powerpc: Test the THP bug we fixed in the previous commit
      powerpc/mm: Check paca psize is up to date for huge mappings
      powerpc/powernv: Pass buffer size to OPAL validate flash call
      powerpc/pseries: hcall functions are exported to modules, need _GLOBAL_TOC()
      powerpc: Exported functions __clear_user and copy_page use r2 so need _GLOBAL_TOC()
      powerpc/powernv: Set memory_block_size_bytes to 256MB
      powerpc: Allow ppc_md platform hook to override memory_block_size_bytes
      powerpc/powernv: Fix endian issues in memory error handling code
      powerpc/eeh: Skip eeh sysfs when eeh is disabled
      powerpc: 64bit sendfile is capped at 2GB
      powerpc/powernv: Provide debugfs access to the LPC bus via OPAL
      powerpc/serial: Use saner flags when creating legacy ports
      powerpc: Add cpu family documentation
      powerpc/xmon: Fix up xmon format strings
      powerpc/powernv: Add calls to support little endian host
      powerpc: Document sysfs DSCR interface
      powerpc: Fix regression of per-CPU DSCR setting
      powerpc: Split __SYSFS_SPRSETUP macro
      arch: powerpc/fadump: Cleaning up inconsistent NULL checks
      ...

commit b7fe943421396b61b9f7a97c2554ed999e0f3658
Author: Ryan Desfosses <ryan@desfo.org>
Date:   Fri Apr 25 14:32:25 2014 -0600

    PCI: Move EXPORT_SYMBOL so it immediately follows function/variable
    
    Move EXPORT_SYMBOL so it immediately follows the function or variable.
    
    No functional change.
    
    [bhelgaas: squash similar changes, fix hotplug, probe, rom, search, too]
    Signed-off-by: Ryan Desfosses <ryan@desfo.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index fd958c8ebd83..51ec8b481280 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -226,6 +226,7 @@ int pci_find_capability(struct pci_dev *dev, int cap)
 
 	return pos;
 }
+EXPORT_SYMBOL(pci_find_capability);
 
 /**
  * pci_bus_find_capability - query for devices' capabilities
@@ -253,6 +254,7 @@ int pci_bus_find_capability(struct pci_bus *bus, unsigned int devfn, int cap)
 
 	return pos;
 }
+EXPORT_SYMBOL(pci_bus_find_capability);
 
 /**
  * pci_find_next_ext_capability - Find an extended capability
@@ -436,6 +438,7 @@ pci_find_parent_resource(const struct pci_dev *dev, struct resource *res)
 	}
 	return NULL;
 }
+EXPORT_SYMBOL(pci_find_parent_resource);
 
 /**
  * pci_wait_for_pending - wait for @mask bit(s) to clear in status word @pos
@@ -846,6 +849,7 @@ int pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 
 	return error;
 }
+EXPORT_SYMBOL(pci_set_power_state);
 
 /**
  * pci_choose_state - Choose the power state of a PCI device
@@ -1017,6 +1021,7 @@ pci_save_state(struct pci_dev *dev)
 		return i;
 	return 0;
 }
+EXPORT_SYMBOL(pci_save_state);
 
 static void pci_restore_config_dword(struct pci_dev *pdev, int offset,
 				     u32 saved_val, int retry)
@@ -1087,6 +1092,7 @@ void pci_restore_state(struct pci_dev *dev)
 
 	dev->state_saved = false;
 }
+EXPORT_SYMBOL(pci_restore_state);
 
 struct pci_saved_state {
 	u32 config_space[16];
@@ -1231,6 +1237,7 @@ int pci_reenable_device(struct pci_dev *dev)
 		return do_pci_enable_device(dev, (1 << PCI_NUM_RESOURCES) - 1);
 	return 0;
 }
+EXPORT_SYMBOL(pci_reenable_device);
 
 static void pci_enable_bridge(struct pci_dev *dev)
 {
@@ -1305,6 +1312,7 @@ int pci_enable_device_io(struct pci_dev *dev)
 {
 	return pci_enable_device_flags(dev, IORESOURCE_IO);
 }
+EXPORT_SYMBOL(pci_enable_device_io);
 
 /**
  * pci_enable_device_mem - Initialize a device for use with Memory space
@@ -1318,6 +1326,7 @@ int pci_enable_device_mem(struct pci_dev *dev)
 {
 	return pci_enable_device_flags(dev, IORESOURCE_MEM);
 }
+EXPORT_SYMBOL(pci_enable_device_mem);
 
 /**
  * pci_enable_device - Initialize device before it's used by a driver.
@@ -1334,6 +1343,7 @@ int pci_enable_device(struct pci_dev *dev)
 {
 	return pci_enable_device_flags(dev, IORESOURCE_MEM | IORESOURCE_IO);
 }
+EXPORT_SYMBOL(pci_enable_device);
 
 /*
  * Managed PCI resources.  This manages device on/off, intx/msi/msix
@@ -1416,6 +1426,7 @@ int pcim_enable_device(struct pci_dev *pdev)
 	}
 	return rc;
 }
+EXPORT_SYMBOL(pcim_enable_device);
 
 /**
  * pcim_pin_device - Pin managed PCI device
@@ -1434,6 +1445,7 @@ void pcim_pin_device(struct pci_dev *pdev)
 	if (dr)
 		dr->pinned = 1;
 }
+EXPORT_SYMBOL(pcim_pin_device);
 
 /*
  * pcibios_add_device - provide arch specific hooks when adding device dev
@@ -1534,6 +1546,7 @@ pci_disable_device(struct pci_dev *dev)
 
 	dev->is_busmaster = 0;
 }
+EXPORT_SYMBOL(pci_disable_device);
 
 /**
  * pcibios_set_pcie_reset_state - set reset state for device dev
@@ -1562,6 +1575,7 @@ int pci_set_pcie_reset_state(struct pci_dev *dev, enum pcie_reset_state state)
 {
 	return pcibios_set_pcie_reset_state(dev, state);
 }
+EXPORT_SYMBOL_GPL(pci_set_pcie_reset_state);
 
 /**
  * pci_check_pme_status - Check if given device has generated PME.
@@ -1641,6 +1655,7 @@ bool pci_pme_capable(struct pci_dev *dev, pci_power_t state)
 
 	return !!(dev->pme_support & (1 << state));
 }
+EXPORT_SYMBOL(pci_pme_capable);
 
 static void pci_pme_list_scan(struct work_struct *work)
 {
@@ -1745,6 +1760,7 @@ void pci_pme_active(struct pci_dev *dev, bool enable)
 
 	dev_dbg(&dev->dev, "PME# %s\n", enable ? "enabled" : "disabled");
 }
+EXPORT_SYMBOL(pci_pme_active);
 
 /**
  * __pci_enable_wake - enable PCI device as wakeup event source
@@ -1830,6 +1846,7 @@ int pci_wake_from_d3(struct pci_dev *dev, bool enable)
 			pci_enable_wake(dev, PCI_D3cold, enable) :
 			pci_enable_wake(dev, PCI_D3hot, enable);
 }
+EXPORT_SYMBOL(pci_wake_from_d3);
 
 /**
  * pci_target_state - find an appropriate low power state for a given PCI dev
@@ -1908,6 +1925,7 @@ int pci_prepare_to_sleep(struct pci_dev *dev)
 
 	return error;
 }
+EXPORT_SYMBOL(pci_prepare_to_sleep);
 
 /**
  * pci_back_from_sleep - turn PCI device on during system-wide transition into working state
@@ -1920,6 +1938,7 @@ int pci_back_from_sleep(struct pci_dev *dev)
 	pci_enable_wake(dev, PCI_D0, false);
 	return pci_set_power_state(dev, PCI_D0);
 }
+EXPORT_SYMBOL(pci_back_from_sleep);
 
 /**
  * pci_finish_runtime_suspend - Carry out PCI-specific part of runtime suspend.
@@ -2478,6 +2497,7 @@ void pci_release_region(struct pci_dev *pdev, int bar)
 	if (dr)
 		dr->region_mask &= ~(1 << bar);
 }
+EXPORT_SYMBOL(pci_release_region);
 
 /**
  *	__pci_request_region - Reserved PCI I/O and memory resource
@@ -2548,6 +2568,7 @@ int pci_request_region(struct pci_dev *pdev, int bar, const char *res_name)
 {
 	return __pci_request_region(pdev, bar, res_name, 0);
 }
+EXPORT_SYMBOL(pci_request_region);
 
 /**
  *	pci_request_region_exclusive - Reserved PCI I/O and memory resource
@@ -2571,6 +2592,8 @@ int pci_request_region_exclusive(struct pci_dev *pdev, int bar, const char *res_
 {
 	return __pci_request_region(pdev, bar, res_name, IORESOURCE_EXCLUSIVE);
 }
+EXPORT_SYMBOL(pci_request_region_exclusive);
+
 /**
  * pci_release_selected_regions - Release selected PCI I/O and memory resources
  * @pdev: PCI device whose resources were previously reserved
@@ -2587,6 +2610,7 @@ void pci_release_selected_regions(struct pci_dev *pdev, int bars)
 		if (bars & (1 << i))
 			pci_release_region(pdev, i);
 }
+EXPORT_SYMBOL(pci_release_selected_regions);
 
 static int __pci_request_selected_regions(struct pci_dev *pdev, int bars,
 				 const char *res_name, int excl)
@@ -2619,6 +2643,7 @@ int pci_request_selected_regions(struct pci_dev *pdev, int bars,
 {
 	return __pci_request_selected_regions(pdev, bars, res_name, 0);
 }
+EXPORT_SYMBOL(pci_request_selected_regions);
 
 int pci_request_selected_regions_exclusive(struct pci_dev *pdev,
 				 int bars, const char *res_name)
@@ -2626,6 +2651,7 @@ int pci_request_selected_regions_exclusive(struct pci_dev *pdev,
 	return __pci_request_selected_regions(pdev, bars, res_name,
 			IORESOURCE_EXCLUSIVE);
 }
+EXPORT_SYMBOL(pci_request_selected_regions_exclusive);
 
 /**
  *	pci_release_regions - Release reserved PCI I/O and memory resources
@@ -2640,6 +2666,7 @@ void pci_release_regions(struct pci_dev *pdev)
 {
 	pci_release_selected_regions(pdev, (1 << 6) - 1);
 }
+EXPORT_SYMBOL(pci_release_regions);
 
 /**
  *	pci_request_regions - Reserved PCI I/O and memory resources
@@ -2658,6 +2685,7 @@ int pci_request_regions(struct pci_dev *pdev, const char *res_name)
 {
 	return pci_request_selected_regions(pdev, ((1 << 6) - 1), res_name);
 }
+EXPORT_SYMBOL(pci_request_regions);
 
 /**
  *	pci_request_regions_exclusive - Reserved PCI I/O and memory resources
@@ -2680,6 +2708,7 @@ int pci_request_regions_exclusive(struct pci_dev *pdev, const char *res_name)
 	return pci_request_selected_regions_exclusive(pdev,
 					((1 << 6) - 1), res_name);
 }
+EXPORT_SYMBOL(pci_request_regions_exclusive);
 
 static void __pci_set_master(struct pci_dev *dev, bool enable)
 {
@@ -2749,6 +2778,7 @@ void pci_set_master(struct pci_dev *dev)
 	__pci_set_master(dev, true);
 	pcibios_set_master(dev);
 }
+EXPORT_SYMBOL(pci_set_master);
 
 /**
  * pci_clear_master - disables bus-mastering for device dev
@@ -2758,6 +2788,7 @@ void pci_clear_master(struct pci_dev *dev)
 {
 	__pci_set_master(dev, false);
 }
+EXPORT_SYMBOL(pci_clear_master);
 
 /**
  * pci_set_cacheline_size - ensure the CACHE_LINE_SIZE register is programmed
@@ -2797,23 +2828,6 @@ int pci_set_cacheline_size(struct pci_dev *dev)
 }
 EXPORT_SYMBOL_GPL(pci_set_cacheline_size);
 
-#ifdef PCI_DISABLE_MWI
-int pci_set_mwi(struct pci_dev *dev)
-{
-	return 0;
-}
-
-int pci_try_set_mwi(struct pci_dev *dev)
-{
-	return 0;
-}
-
-void pci_clear_mwi(struct pci_dev *dev)
-{
-}
-
-#else
-
 /**
  * pci_set_mwi - enables memory-write-invalidate PCI transaction
  * @dev: the PCI device for which MWI is enabled
@@ -2825,6 +2839,9 @@ void pci_clear_mwi(struct pci_dev *dev)
 int
 pci_set_mwi(struct pci_dev *dev)
 {
+#ifdef PCI_DISABLE_MWI
+	return 0;
+#else
 	int rc;
 	u16 cmd;
 
@@ -2838,9 +2855,10 @@ pci_set_mwi(struct pci_dev *dev)
 		cmd |= PCI_COMMAND_INVALIDATE;
 		pci_write_config_word(dev, PCI_COMMAND, cmd);
 	}
-
 	return 0;
+#endif
 }
+EXPORT_SYMBOL(pci_set_mwi);
 
 /**
  * pci_try_set_mwi - enables memory-write-invalidate PCI transaction
@@ -2853,9 +2871,13 @@ pci_set_mwi(struct pci_dev *dev)
  */
 int pci_try_set_mwi(struct pci_dev *dev)
 {
-	int rc = pci_set_mwi(dev);
-	return rc;
+#ifdef PCI_DISABLE_MWI
+	return 0;
+#else
+	return pci_set_mwi(dev);
+#endif
 }
+EXPORT_SYMBOL(pci_try_set_mwi);
 
 /**
  * pci_clear_mwi - disables Memory-Write-Invalidate for device dev
@@ -2866,6 +2888,7 @@ int pci_try_set_mwi(struct pci_dev *dev)
 void
 pci_clear_mwi(struct pci_dev *dev)
 {
+#ifndef PCI_DISABLE_MWI
 	u16 cmd;
 
 	pci_read_config_word(dev, PCI_COMMAND, &cmd);
@@ -2873,8 +2896,9 @@ pci_clear_mwi(struct pci_dev *dev)
 		cmd &= ~PCI_COMMAND_INVALIDATE;
 		pci_write_config_word(dev, PCI_COMMAND, cmd);
 	}
+#endif
 }
-#endif /* ! PCI_DISABLE_MWI */
+EXPORT_SYMBOL(pci_clear_mwi);
 
 /**
  * pci_intx - enables/disables PCI INTx for device dev
@@ -2908,6 +2932,7 @@ pci_intx(struct pci_dev *pdev, int enable)
 		}
 	}
 }
+EXPORT_SYMBOL_GPL(pci_intx);
 
 /**
  * pci_intx_mask_supported - probe for INTx masking support
@@ -4094,6 +4119,7 @@ int pci_select_bars(struct pci_dev *dev, unsigned long flags)
 			bars |= (1 << i);
 	return bars;
 }
+EXPORT_SYMBOL(pci_select_bars);
 
 /**
  * pci_resource_bar - get position of the BAR associated with a resource
@@ -4446,41 +4472,3 @@ static int __init pci_setup(char *str)
 	return 0;
 }
 early_param("pci", pci_setup);
-
-EXPORT_SYMBOL(pci_reenable_device);
-EXPORT_SYMBOL(pci_enable_device_io);
-EXPORT_SYMBOL(pci_enable_device_mem);
-EXPORT_SYMBOL(pci_enable_device);
-EXPORT_SYMBOL(pcim_enable_device);
-EXPORT_SYMBOL(pcim_pin_device);
-EXPORT_SYMBOL(pci_disable_device);
-EXPORT_SYMBOL(pci_find_capability);
-EXPORT_SYMBOL(pci_bus_find_capability);
-EXPORT_SYMBOL(pci_release_regions);
-EXPORT_SYMBOL(pci_request_regions);
-EXPORT_SYMBOL(pci_request_regions_exclusive);
-EXPORT_SYMBOL(pci_release_region);
-EXPORT_SYMBOL(pci_request_region);
-EXPORT_SYMBOL(pci_request_region_exclusive);
-EXPORT_SYMBOL(pci_release_selected_regions);
-EXPORT_SYMBOL(pci_request_selected_regions);
-EXPORT_SYMBOL(pci_request_selected_regions_exclusive);
-EXPORT_SYMBOL(pci_set_master);
-EXPORT_SYMBOL(pci_clear_master);
-EXPORT_SYMBOL(pci_set_mwi);
-EXPORT_SYMBOL(pci_try_set_mwi);
-EXPORT_SYMBOL(pci_clear_mwi);
-EXPORT_SYMBOL_GPL(pci_intx);
-EXPORT_SYMBOL(pci_assign_resource);
-EXPORT_SYMBOL(pci_find_parent_resource);
-EXPORT_SYMBOL(pci_select_bars);
-
-EXPORT_SYMBOL(pci_set_power_state);
-EXPORT_SYMBOL(pci_save_state);
-EXPORT_SYMBOL(pci_restore_state);
-EXPORT_SYMBOL(pci_pme_capable);
-EXPORT_SYMBOL(pci_pme_active);
-EXPORT_SYMBOL(pci_wake_from_d3);
-EXPORT_SYMBOL(pci_prepare_to_sleep);
-EXPORT_SYMBOL(pci_back_from_sleep);
-EXPORT_SYMBOL_GPL(pci_set_pcie_reset_state);

commit 1aacb90eaaac057c10fd746e189553e04cfeb291
Merge: b05d59dfceae 31789538e3ba
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jun 4 08:50:34 2014 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial into next
    
    Pull trivial tree changes from Jiri Kosina:
     "Usual pile of patches from trivial tree that make the world go round"
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial: (23 commits)
      staging: go7007: remove reference to CONFIG_KMOD
      aic7xxx: Remove obsolete preprocessor define
      of: dma: doc fixes
      doc: fix incorrect formula to calculate CommitLimit value
      doc: Note need of bc in the kernel build from 3.10 onwards
      mm: Fix printk typo in dmapool.c
      modpost: Fix comment typo "Modules.symvers"
      Kconfig.debug: Grammar s/addition/additional/
      wimax: Spelling s/than/that/, wording s/destinatary/recipient/
      aic7xxx: Spelling s/termnation/termination/
      arm64: mm: Remove superfluous "the" in comment
      of: Spelling s/anonymouns/anonymous/
      dma: imx-sdma: Spelling s/determnine/determine/
      ath10k: Improve grammar in comments
      ath6kl: Spelling s/determnine/determine/
      of: Improve grammar for of_alias_get_id() documentation
      drm/exynos: Spelling s/contro/control/
      radio-bcm2048.c: fix wrong overflow check
      doc: printk-formats: do not mention casts for u64/s64
      doc: spelling error changes
      ...

commit 425553209b387fa2125df09d01a2d1c1724bd205
Merge: 681a28954862 617b4157a5c8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jun 2 12:15:19 2014 -0700

    Merge tag 'pci-v3.16-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci into next
    
    Pull PCI changes from Bjorn Helgaas:
     "Enumeration
        - Notify driver before and after device reset (Keith Busch)
        - Use reset notification in NVMe (Keith Busch)
    
      NUMA
        - Warn if we have to guess host bridge node information (Myron Stowe)
        - Work around AMD Fam15h BIOSes that fail to provide _PXM (Suravee
          Suthikulpanit)
        - Clean up and mark early_root_info_init() as deprecated (Suravee
          Suthikulpanit)
    
      Driver binding
        - Add "driver_override" for force specific binding (Alex Williamson)
        - Fail "new_id" addition for devices we already know about (Bandan
          Das)
    
      Resource management
        - Support BAR sizes up to 8GB (Nikhil Rao, Alan Cox)
        - Don't move IORESOURCE_PCI_FIXED resources (Bjorn Helgaas)
        - Mark SBx00 HPET BAR as IORESOURCE_PCI_FIXED (Bjorn Helgaas)
        - Fail safely if we can't handle BARs larger than 4GB (Bjorn Helgaas)
        - Reject BAR above 4GB if dma_addr_t is too small (Bjorn Helgaas)
        - Don't convert BAR address to resource if dma_addr_t is too small
          (Bjorn Helgaas)
        - Don't set BAR to zero if dma_addr_t is too small (Bjorn Helgaas)
        - Don't print anything while decoding is disabled (Bjorn Helgaas)
        - Don't add disabled subtractive decode bus resources (Bjorn Helgaas)
        - Add resource allocation comments (Bjorn Helgaas)
        - Restrict 64-bit prefetchable bridge windows to 64-bit resources
          (Yinghai Lu)
        - Assign i82875p_edac PCI resources before adding device (Yinghai Lu)
    
      PCI device hotplug
        - Remove unnecessary "dev->bus" test (Bjorn Helgaas)
        - Use PCI_EXP_SLTCAP_PSN define (Bjorn Helgaas)
        - Fix rphahp endianess issues (Laurent Dufour)
        - Acknowledge spurious "cmd completed" event (Rajat Jain)
        - Allow hotplug service drivers to operate in polling mode (Rajat Jain)
        - Fix cpqphp possible NULL dereference (Rickard Strandqvist)
    
      MSI
        - Replace pci_enable_msi_block() by pci_enable_msi_exact()
          (Alexander Gordeev)
        - Replace pci_enable_msix() by pci_enable_msix_exact() (Alexander Gordeev)
        - Simplify populate_msi_sysfs() (Jan Beulich)
    
      Virtualization
        - Add Intel Patsburg (X79) root port ACS quirk (Alex Williamson)
        - Mark RTL8110SC INTx masking as broken (Alex Williamson)
    
      Generic host bridge driver
        - Add generic PCI host controller driver (Will Deacon)
    
      Freescale i.MX6
        - Use new clock names (Lucas Stach)
        - Drop old IRQ mapping (Lucas Stach)
        - Remove optional (and unused) IRQs (Lucas Stach)
        - Add support for MSI (Lucas Stach)
        - Fix imx6_add_pcie_port() section mismatch warning (Sachin Kamat)
    
      Renesas R-Car
        - Add gen2 device tree support (Ben Dooks)
        - Use new OF interrupt mapping when possible (Lucas Stach)
        - Add PCIe driver (Phil Edworthy)
        - Add PCIe MSI support (Phil Edworthy)
        - Add PCIe device tree bindings (Phil Edworthy)
    
      Samsung Exynos
        - Remove unnecessary OOM messages (Jingoo Han)
        - Fix add_pcie_port() section mismatch warning (Sachin Kamat)
    
      Synopsys DesignWare
        - Make MSI ISR shared IRQ aware (Lucas Stach)
    
      Miscellaneous
        - Check for broken config space aliasing (Alex Williamson)
        - Update email address (Ben Hutchings)
        - Fix Broadcom CNB20LE unintended sign extension (Bjorn Helgaas)
        - Fix incorrect vgaarb conditional in WARN_ON() (Bjorn Helgaas)
        - Remove unnecessary __ref annotations (Bjorn Helgaas)
        - Add arch/x86/kernel/quirks.c to MAINTAINERS PCI file patterns
          (Bjorn Helgaas)
        - Fix use of uninitialized MPS value (Bjorn Helgaas)
        - Tidy x86/gart messages (Bjorn Helgaas)
        - Fix return value from pci_user_{read,write}_config_*() (Gavin Shan)
        - Turn pcibios_penalize_isa_irq() into a weak function (Hanjun Guo)
        - Remove unused serial device IDs (Jean Delvare)
        - Use designated initialization in PCI_VDEVICE (Mark Rustad)
        - Fix powerpc NULL dereference in pci_root_buses traversal (Mike Qiu)
        - Configure MPS on ARM (Murali Karicheri)
        - Remove unnecessary includes of <linux/init.h> (Paul Gortmaker)
        - Move Open Firmware devspec attribute to PCI common code (Sebastian Ott)
        - Use pdev->dev.groups for attribute creation on s390 (Sebastian Ott)
        - Remove pcibios_add_platform_entries() (Sebastian Ott)
        - Add new ID for Intel GPU "spurious interrupt" quirk (Thomas Jarosch)
        - Rename pci_is_bridge() to pci_has_subordinate() (Yijing Wang)
        - Add and use new pci_is_bridge() interface (Yijing Wang)
        - Make pci_bus_add_device() void (Yijing Wang)
    
      DMA API
        - Clarify physical/bus address distinction in docs (Bjorn Helgaas)
        - Fix typos in docs (Emilio López)
        - Update dma_pool_create ()and dma_pool_alloc() descriptions (Gioh Kim)
        - Change dma_declare_coherent_memory() CPU address to phys_addr_t
          (Bjorn Helgaas)
        - Pass GAPSPCI_DMA_BASE CPU & bus address to dma_declare_coherent_memory()
          (Bjorn Helgaas)"
    
    * tag 'pci-v3.16-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (92 commits)
      MAINTAINERS: Add generic PCI host controller driver
      PCI: generic: Add generic PCI host controller driver
      PCI: imx6: Add support for MSI
      PCI: designware: Make MSI ISR shared IRQ aware
      PCI: imx6: Remove optional (and unused) IRQs
      PCI: imx6: Drop old IRQ mapping
      PCI: imx6: Use new clock names
      i82875p_edac: Assign PCI resources before adding device
      ARM/PCI: Call pcie_bus_configure_settings() to set MPS
      PCI: imx6: Fix imx6_add_pcie_port() section mismatch warning
      PCI: Make pci_bus_add_device() void
      PCI: exynos: Fix add_pcie_port() section mismatch warning
      PCI: Introduce new device binding path using pci_dev.driver_override
      PCI: rcar: Add gen2 device tree support
      PCI: cpqphp: Fix possible null pointer dereference
      PCI: rcar: Add R-Car PCIe device tree bindings
      PCI: rcar: Add MSI support for PCIe
      PCI: rcar: Add Renesas R-Car PCIe driver
      PCI: Fix return value from pci_user_{read,write}_config_*()
      PCI: exynos: Remove unnecessary OOM messages
      ...

commit fdaf36bd360fe1e74b34262ad705ef39d52c12de
Merge: d1a2523d2adc d97ffe236894
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed May 28 16:21:25 2014 -0600

    Merge branch 'pci/misc' into next
    
    * pci/misc:
      PCI: Fix return value from pci_user_{read,write}_config_*()
      PCI: Turn pcibios_penalize_isa_irq() into a weak function
      PCI: Test for std config alias when testing extended config space

commit d1a2523d2adc0b6910dbc2a9aed44c4217134db1
Merge: 79d458bf4743 cab9a128dad0 56604faed112 782a985d7af2
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed May 28 16:21:07 2014 -0600

    Merge branches 'pci/hotplug', 'pci/pci_is_bridge' and 'pci/virtualization' into next
    
    * pci/hotplug:
      PCI: cpqphp: Fix possible null pointer dereference
      NVMe: Implement PCIe reset notification callback
      PCI: Notify driver before and after device reset
    
    * pci/pci_is_bridge:
      pcmcia: Use pci_is_bridge() to simplify code
      PCI: pciehp: Use pci_is_bridge() to simplify code
      PCI: acpiphp: Use pci_is_bridge() to simplify code
      PCI: cpcihp: Use pci_is_bridge() to simplify code
      PCI: shpchp: Use pci_is_bridge() to simplify code
      PCI: rpaphp: Use pci_is_bridge() to simplify code
      sparc/PCI: Use pci_is_bridge() to simplify code
      powerpc/PCI: Use pci_is_bridge() to simplify code
      ia64/PCI: Use pci_is_bridge() to simplify code
      x86/PCI: Use pci_is_bridge() to simplify code
      PCI: Use pci_is_bridge() to simplify code
      PCI: Add new pci_is_bridge() interface
      PCI: Rename pci_is_bridge() to pci_has_subordinate()
    
    * pci/virtualization:
      PCI: Introduce new device binding path using pci_dev.driver_override
    
    Conflicts:
            drivers/pci/pci-sysfs.c

commit a43ae58c848cfbadaba81c8d63202b4487f922a0
Author: Hanjun Guo <hanjun.guo@linaro.org>
Date:   Tue May 6 11:29:52 2014 +0800

    PCI: Turn pcibios_penalize_isa_irq() into a weak function
    
    pcibios_penalize_isa_irq() is only implemented by x86 now, and legacy ISA
    is not used by some architectures.  Make pcibios_penalize_isa_irq() a
    __weak function to simplify the code.  This removes the need for new
    platforms to add stub implementations of pcibios_penalize_isa_irq().
    
    [bhelgaas: changelog, comments]
    Signed-off-by: Hanjun Guo <hanjun.guo@linaro.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 39012831867e..11f24912523c 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1468,6 +1468,17 @@ void __weak pcibios_release_device(struct pci_dev *dev) {}
  */
 void __weak pcibios_disable_device (struct pci_dev *dev) {}
 
+/**
+ * pcibios_penalize_isa_irq - penalize an ISA IRQ
+ * @irq: ISA IRQ to penalize
+ * @active: IRQ active or not
+ *
+ * Permits the platform to provide architecture-specific functionality when
+ * penalizing ISA IRQs. This is the default implementation. Architecture
+ * implementations can override this.
+ */
+void __weak pcibios_penalize_isa_irq(int irq, int active) {}
+
 static void do_pci_disable_device(struct pci_dev *dev)
 {
 	u16 pci_command;

commit 3ebe7f9f7e4a4fd1f6461ecd01ff2961317a483a
Author: Keith Busch <keith.busch@intel.com>
Date:   Fri May 2 10:40:42 2014 -0600

    PCI: Notify driver before and after device reset
    
    Notify a PCI device driver when its device's access is about to be disabled
    for an impending reset attempt, then after the attempt completes and device
    access is restored.  The notification is via the pci_error_handlers
    interface.
    
    Signed-off-by: Keith Busch <keith.busch@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 7325d43bf030..43d87b26ec5b 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -3305,8 +3305,27 @@ static void pci_dev_unlock(struct pci_dev *dev)
 	pci_cfg_access_unlock(dev);
 }
 
+/**
+ * pci_reset_notify - notify device driver of reset
+ * @dev: device to be notified of reset
+ * @prepare: 'true' if device is about to be reset; 'false' if reset attempt
+ *           completed
+ *
+ * Must be called prior to device access being disabled and after device
+ * access is restored.
+ */
+static void pci_reset_notify(struct pci_dev *dev, bool prepare)
+{
+	const struct pci_error_handlers *err_handler =
+			dev->driver ? dev->driver->err_handler : NULL;
+	if (err_handler && err_handler->reset_notify)
+		err_handler->reset_notify(dev, prepare);
+}
+
 static void pci_dev_save_and_disable(struct pci_dev *dev)
 {
+	pci_reset_notify(dev, true);
+
 	/*
 	 * Wake-up device prior to save.  PM registers default to D0 after
 	 * reset and a simple register restore doesn't reliably return
@@ -3328,6 +3347,7 @@ static void pci_dev_save_and_disable(struct pci_dev *dev)
 static void pci_dev_restore(struct pci_dev *dev)
 {
 	pci_restore_state(dev);
+	pci_reset_notify(dev, false);
 }
 
 static int pci_dev_reset(struct pci_dev *dev, int probe)
@@ -3344,6 +3364,7 @@ static int pci_dev_reset(struct pci_dev *dev, int probe)
 
 	return rc;
 }
+
 /**
  * __pci_reset_function - reset a PCI device function
  * @dev: PCI device to reset

commit d0b4cc4e32705ff00d90d32da7783c266c702c04
Author: Gavin Shan <gwshan@linux.vnet.ibm.com>
Date:   Mon May 19 13:06:46 2014 +1000

    PCI: Wrong register used to check pending traffic
    
    The incorrect register offset is passed to pci_wait_for_pending(), which is
    caused by commit 157e876ffe ("PCI: Add pci_wait_for_pending() (refactor
    pci_wait_for_pending_transaction())").
    
    Fixes: 157e876ffe ("PCI: Add pci_wait_for_pending() (refactor pci_wait_for_pending_transaction())
    Signed-off-by: Gavin Shan <gwshan@linux.vnet.ibm.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Alex Williamson <alex.williamson@gmail.com>
    CC: stable@vger.kernel.org      # v3.14+

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 7325d43bf030..759475ef6ff3 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -3067,7 +3067,8 @@ int pci_wait_for_pending_transaction(struct pci_dev *dev)
 	if (!pci_is_pcie(dev))
 		return 1;
 
-	return pci_wait_for_pending(dev, PCI_EXP_DEVSTA, PCI_EXP_DEVSTA_TRPND);
+	return pci_wait_for_pending(dev, pci_pcie_cap(dev) + PCI_EXP_DEVSTA,
+				    PCI_EXP_DEVSTA_TRPND);
 }
 EXPORT_SYMBOL(pci_wait_for_pending_transaction);
 
@@ -3109,7 +3110,7 @@ static int pci_af_flr(struct pci_dev *dev, int probe)
 		return 0;
 
 	/* Wait for Transaction Pending bit clean */
-	if (pci_wait_for_pending(dev, PCI_AF_STATUS, PCI_AF_STATUS_TP))
+	if (pci_wait_for_pending(dev, pos + PCI_AF_STATUS, PCI_AF_STATUS_TP))
 		goto clear;
 
 	dev_err(&dev->dev, "transaction is not cleared; "

commit 07656d83085dfd3d5eff5d588a6f50c35c853ee0
Author: Ryan Desfosses <ryan@desfo.org>
Date:   Fri Apr 11 01:01:53 2014 -0400

    pci: change "foo* bar" to "foo *bar"
    
    change made to resolve following checkpatch message:
        drivers/pci/pci.c:109: ERROR: "foo* bar" should be "foo *bar"
    branch: Linux 3.14-rc8
    
    Signed-off-by: Ryan Desfosses <ryan@desfo.org>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 7325d43bf030..9b26c192f327 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -106,7 +106,7 @@ static bool pcie_ari_disabled;
  * Given a PCI bus, returns the highest PCI bus number present in the set
  * including the given PCI bus and its list of child PCI buses.
  */
-unsigned char pci_bus_max_busnr(struct pci_bus* bus)
+unsigned char pci_bus_max_busnr(struct pci_bus *bus)
 {
 	struct pci_bus *tmp;
 	unsigned char max, n;
@@ -1371,7 +1371,7 @@ static void pcim_release(struct device *gendev, void *res)
 		pci_disable_device(dev);
 }
 
-static struct pci_devres * get_pci_dr(struct pci_dev *pdev)
+static struct pci_devres *get_pci_dr(struct pci_dev *pdev)
 {
 	struct pci_devres *dr, *new_dr;
 
@@ -1385,7 +1385,7 @@ static struct pci_devres * get_pci_dr(struct pci_dev *pdev)
 	return devres_get(&pdev->dev, new_dr, NULL, NULL);
 }
 
-static struct pci_devres * find_pci_dr(struct pci_dev *pdev)
+static struct pci_devres *find_pci_dr(struct pci_dev *pdev)
 {
 	if (pci_is_managed(pdev))
 		return devres_find(&pdev->dev, pcim_release, NULL, NULL);

commit d92a208d086063ecc785b4588f74ab42268cbc4b
Author: Gavin Shan <gwshan@linux.vnet.ibm.com>
Date:   Thu Apr 24 18:00:24 2014 +1000

    powerpc/pci: Mask linkDown on resetting PCI bus
    
    The problem was initially reported by Wendy who tried pass through
    IPR adapter, which was connected to PHB root port directly, to KVM
    based guest. When doing that, pci_reset_bridge_secondary_bus() was
    called by VFIO driver and linkDown was detected by the root port.
    That caused all PEs to be frozen.
    
    The patch fixes the issue by routing the reset for the secondary bus
    of root port to underly firmware. For that, one more weak function
    pci_reset_secondary_bus() is introduced so that the individual platforms
    can override that and do specific reset for bridge's secondary bus.
    
    Reported-by: Wendy Xiong <wenxiong@linux.vnet.ibm.com>
    Signed-off-by: Gavin Shan <gwshan@linux.vnet.ibm.com>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 7325d43bf030..633382d227f4 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -3167,14 +3167,7 @@ static int pci_pm_reset(struct pci_dev *dev, int probe)
 	return 0;
 }
 
-/**
- * pci_reset_bridge_secondary_bus - Reset the secondary bus on a PCI bridge.
- * @dev: Bridge device
- *
- * Use the bridge control register to assert reset on the secondary bus.
- * Devices on the secondary bus are left in power-on state.
- */
-void pci_reset_bridge_secondary_bus(struct pci_dev *dev)
+void __weak pcibios_reset_secondary_bus(struct pci_dev *dev)
 {
 	u16 ctrl;
 
@@ -3199,6 +3192,18 @@ void pci_reset_bridge_secondary_bus(struct pci_dev *dev)
 	 */
 	ssleep(1);
 }
+
+/**
+ * pci_reset_bridge_secondary_bus - Reset the secondary bus on a PCI bridge.
+ * @dev: Bridge device
+ *
+ * Use the bridge control register to assert reset on the secondary bus.
+ * Devices on the secondary bus are left in power-on state.
+ */
+void pci_reset_bridge_secondary_bus(struct pci_dev *dev)
+{
+	pcibios_reset_secondary_bus(dev);
+}
 EXPORT_SYMBOL_GPL(pci_reset_bridge_secondary_bus);
 
 static int pci_parent_bus_reset(struct pci_dev *dev, int probe)

commit 67ebd8140dc8923c65451fa0f6a8eee003c4dcd3
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Sat Apr 5 15:14:22 2014 -0600

    PCI: Fix incorrect vgaarb conditional in WARN_ON()
    
    3448a19da479 "vgaarb: use bridges to control VGA routing where possible"
    added the "flags & PCI_VGA_STATE_CHANGE_DECODES" condition to an existing
    WARN_ON(), but used bitwise AND (&) instead of logical AND (&&), so the
    condition is never true.  Replace with logical AND.
    
    Found by Coverity (CID 142811).
    
    Fixes: 3448a19da479 "vgaarb: use bridges to control VGA routing where possible"
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>
    Acked-by: David Airlie <airlied@redhat.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 7325d43bf030..39012831867e 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -4125,7 +4125,7 @@ int pci_set_vga_state(struct pci_dev *dev, bool decode,
 	u16 cmd;
 	int rc;
 
-	WARN_ON((flags & PCI_VGA_STATE_CHANGE_DECODES) & (command_bits & ~(PCI_COMMAND_IO|PCI_COMMAND_MEMORY)));
+	WARN_ON((flags & PCI_VGA_STATE_CHANGE_DECODES) && (command_bits & ~(PCI_COMMAND_IO|PCI_COMMAND_MEMORY)));
 
 	/* ARCH specific VGA enables */
 	rc = pci_set_vga_state_arch(dev, decode, command_bits, flags);

commit 30723cbf6f7aec2ab4810bdc4bf12c5749a09e33
Merge: 91b4adc983d8 f2e6027b816d
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Mar 19 15:11:19 2014 -0600

    Merge branch 'pci/resource' into next
    
    * pci/resource: (26 commits)
      Revert "[PATCH] Insert GART region into resource map"
      PCI: Log IDE resource quirk in dmesg
      PCI: Change pci_bus_alloc_resource() type_mask to unsigned long
      PCI: Check all IORESOURCE_TYPE_BITS in pci_bus_alloc_from_region()
      resources: Set type in __request_region()
      PCI: Don't check resource_size() in pci_bus_alloc_resource()
      s390/PCI: Use generic pci_enable_resources()
      tile PCI RC: Use default pcibios_enable_device()
      sparc/PCI: Use default pcibios_enable_device() (Leon only)
      sh/PCI: Use default pcibios_enable_device()
      microblaze/PCI: Use default pcibios_enable_device()
      alpha/PCI: Use default pcibios_enable_device()
      PCI: Add "weak" generic pcibios_enable_device() implementation
      PCI: Don't enable decoding if BAR hasn't been assigned an address
      PCI: Mark 64-bit resource as IORESOURCE_UNSET if we only support 32-bit
      PCI: Don't try to claim IORESOURCE_UNSET resources
      PCI: Check IORESOURCE_UNSET before updating BAR
      PCI: Don't clear IORESOURCE_UNSET when updating BAR
      PCI: Mark resources as IORESOURCE_UNSET if we can't assign them
      PCI: Remove pci_find_parent_resource() use for allocation
      ...

commit 91b4adc983d8e9975bc677c2b8395631edf7b92d
Merge: 2c0503f202f5 866d54177b4e
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Mar 19 15:11:03 2014 -0600

    Merge branch 'pci/misc' into next
    
    * pci/misc:
      PCI: Enable INTx in pci_reenable_device() only when MSI/MSI-X not enabled

commit 8a9d56097c142d0716234eb1cf7c8150c6dc1588
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Feb 26 11:26:00 2014 -0700

    PCI: Add "weak" generic pcibios_enable_device() implementation
    
    Many architectures implement pcibios_enable_device() the same way, so
    provide a default implementation in the core.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index dc9ce62be7aa..c3ce3d61091c 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1185,6 +1185,11 @@ int pci_load_and_free_saved_state(struct pci_dev *dev,
 }
 EXPORT_SYMBOL_GPL(pci_load_and_free_saved_state);
 
+int __weak pcibios_enable_device(struct pci_dev *dev, int bars)
+{
+	return pci_enable_resources(dev, bars);
+}
+
 static int do_pci_enable_device(struct pci_dev *dev, int bars)
 {
 	int err;

commit 866d54177b4e671cd52bed1fb487d140d7b691f5
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Mar 7 16:06:05 2014 -0700

    PCI: Enable INTx in pci_reenable_device() only when MSI/MSI-X not enabled
    
    Andreas reported that after 1f42db786b14 ("PCI: Enable INTx if BIOS left
    them disabled"), pciehp surprise removal stopped working.
    
    This happens because pci_reenable_device() on the hotplug bridge (used in
    the pciehp_configure_device() path) clears the Interrupt Disable bit, which
    apparently breaks the bridge's MSI hotplug event reporting.
    
    Previously we cleared the Interrupt Disable bit in do_pci_enable_device(),
    which is used by both pci_enable_device() and pci_reenable_device().  But
    we use pci_reenable_device() after the driver may have enabled MSI or
    MSI-X, and we *set* Interrupt Disable as part of enabling MSI/MSI-X.
    
    This patch clears Interrupt Disable only when MSI/MSI-X has not been
    enabled.
    
    Fixes: 1f42db786b14 PCI: Enable INTx if BIOS left them disabled
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=71691
    Reported-and-tested-by: Andreas Noever <andreas.noever@gmail.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    CC: stable@vger.kernel.org
    CC: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 8dc3e701ec57..79fc89c6c3f3 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1192,6 +1192,9 @@ static int do_pci_enable_device(struct pci_dev *dev, int bars)
 		return err;
 	pci_fixup_device(pci_fixup_enable, dev);
 
+	if (dev->msi_enabled || dev->msix_enabled)
+		return 0;
+
 	pci_read_config_byte(dev, PCI_INTERRUPT_PIN, &pin);
 	if (pin) {
 		pci_read_config_word(dev, PCI_COMMAND, &cmd);

commit bd064f0a231af336218838474ea45a64f1672190
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Feb 26 11:25:58 2014 -0700

    PCI: Mark resources as IORESOURCE_UNSET if we can't assign them
    
    When assigning addresses to resources, mark them with IORESOURCE_UNSET
    before we start and clear IORESOURCE_UNSET if assignment is successful.
    That means that if we print the resource during assignment, we will show
    the size, not a meaningless address.
    
    Also, clear IORESOURCE_UNSET if we do assign an address, so we print the
    address when it is valid.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 99293fa40db9..dc9ce62be7aa 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -4244,6 +4244,7 @@ void pci_reassigndev_resource_alignment(struct pci_dev *dev)
 				"Rounding up size of resource #%d to %#llx.\n",
 				i, (unsigned long long)size);
 		}
+		r->flags |= IORESOURCE_UNSET;
 		r->end = size - 1;
 		r->start = 0;
 	}
@@ -4257,6 +4258,7 @@ void pci_reassigndev_resource_alignment(struct pci_dev *dev)
 			r = &dev->resource[i];
 			if (!(r->flags & IORESOURCE_MEM))
 				continue;
+			r->flags |= IORESOURCE_UNSET;
 			r->end = resource_size(r) - 1;
 			r->start = 0;
 		}

commit f44116ae881868ab72274df1eff48fdbde9898af
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Feb 26 11:25:58 2014 -0700

    PCI: Remove pci_find_parent_resource() use for allocation
    
    If the resource hasn't been allocated yet, pci_find_parent_resource() is
    documented as returning the region "where it should be allocated from."
    This is impossible in general because there may be several candidates: a
    prefetchable BAR can be put in either a prefetchable or non-prefetchable
    window, a transparent bridge may have overlapping positively- and
    subtractively-decoded windows, and a root bus may have several windows of
    the same type.
    
    Allocation should be done by pci_bus_alloc_resource(), which iterates
    through all bus resources and looks for the best match, e.g., one with the
    desired prefetchability attributes, and falls back to less-desired
    possibilities.
    
    The only valid use of pci_find_parent_resource() is to find the parent of
    an already-allocated resource so we can claim it via request_resource(),
    and all we need for that is a bus region of the correct type that contains
    the resource.
    
    Note that like 8c8def26bfaa ("PCI: allow matching of prefetchable resources
    to non-prefetchable windows"), this depends on pci_bus_for_each_resource()
    iterating through positively-decoded regions before subtractively-decoded
    ones.  We prefer not to return a subtractively-decoded region because
    requesting from it will likely conflict with the overlapping positively-
    decoded window (see Launchpad report below).
    
    Link: https://bugs.launchpad.net/ubuntu/+source/linux/+bug/424142
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    CC: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 1febe90831b4..99293fa40db9 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -401,33 +401,40 @@ EXPORT_SYMBOL_GPL(pci_find_ht_capability);
  * @res: child resource record for which parent is sought
  *
  *  For given resource region of given device, return the resource
- *  region of parent bus the given region is contained in or where
- *  it should be allocated from.
+ *  region of parent bus the given region is contained in.
  */
 struct resource *
 pci_find_parent_resource(const struct pci_dev *dev, struct resource *res)
 {
 	const struct pci_bus *bus = dev->bus;
+	struct resource *r;
 	int i;
-	struct resource *best = NULL, *r;
 
 	pci_bus_for_each_resource(bus, r, i) {
 		if (!r)
 			continue;
-		if (res->start && !(res->start >= r->start && res->end <= r->end))
-			continue;	/* Not contained */
-		if ((res->flags ^ r->flags) & (IORESOURCE_IO | IORESOURCE_MEM))
-			continue;	/* Wrong type */
-		if (!((res->flags ^ r->flags) & IORESOURCE_PREFETCH))
-			return r;	/* Exact match */
-		/* We can't insert a non-prefetch resource inside a prefetchable parent .. */
-		if (r->flags & IORESOURCE_PREFETCH)
-			continue;
-		/* .. but we can put a prefetchable resource inside a non-prefetchable one */
-		if (!best)
-			best = r;
+		if (res->start && resource_contains(r, res)) {
+
+			/*
+			 * If the window is prefetchable but the BAR is
+			 * not, the allocator made a mistake.
+			 */
+			if (r->flags & IORESOURCE_PREFETCH &&
+			    !(res->flags & IORESOURCE_PREFETCH))
+				return NULL;
+
+			/*
+			 * If we're below a transparent bridge, there may
+			 * be both a positively-decoded aperture and a
+			 * subtractively-decoded region that contain the BAR.
+			 * We want the positively-decoded one, so this depends
+			 * on pci_bus_for_each_resource() giving us those
+			 * first.
+			 */
+			return r;
+		}
 	}
-	return best;
+	return NULL;
 }
 
 /**

commit 94a5f850aead02f02f350d401a43c4bf9a9fbf3a
Merge: ec5130ba7907 1e2571a78138
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Feb 18 17:02:04 2014 -0700

    Merge branch 'pci/misc' into next
    
    * pci/misc:
      PCI: Enable INTx if BIOS left them disabled
      ia64/PCI: Set IORESOURCE_ROM_SHADOW only for the default VGA device
      x86/PCI: Set IORESOURCE_ROM_SHADOW only for the default VGA device
      PCI: Update outdated comment for pcibios_bus_report_status()
      PCI: Cleanup per-arch list of object files
      PCI: cpqphp: Fix hex vs decimal typo in cpqhpc_probe()
      x86/PCI: Fix function definition whitespace
      x86/PCI: Reword comments
      x86/PCI: Remove unnecessary local variable initialization
      PCI: Remove unnecessary list_empty(&pci_pme_list) check

commit 1e2571a78138361f74afeb4c5df859b9536b2d8e
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Jan 29 16:13:51 2014 -0700

    PCI: Enable INTx if BIOS left them disabled
    
    Some firmware leaves the Interrupt Disable bit set even if the device uses
    INTx interrupts.  Clear Interrupt Disable so we get those interrupts.
    
    Based on the report mentioned below, if the user selects the "EHCI only"
    option in the Intel Baytrail BIOS, the EHCI device is handed off to the OS
    with the PCI_COMMAND_INTX_DISABLE bit set.
    
    Link: http://lkml.kernel.org/r/20140114181721.GC12126@xanatos
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=70601
    Reported-by: Chris Cheng <chris.cheng@atrustcorp.com>
    Reported-and-tested-by: Jamie Chen <jamie.chen@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    CC: stable@vger.kernel.org
    CC: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 52e10e1181d0..8dc3e701ec57 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1181,6 +1181,8 @@ EXPORT_SYMBOL_GPL(pci_load_and_free_saved_state);
 static int do_pci_enable_device(struct pci_dev *dev, int bars)
 {
 	int err;
+	u16 cmd;
+	u8 pin;
 
 	err = pci_set_power_state(dev, PCI_D0);
 	if (err < 0 && err != -EIO)
@@ -1190,6 +1192,14 @@ static int do_pci_enable_device(struct pci_dev *dev, int bars)
 		return err;
 	pci_fixup_device(pci_fixup_enable, dev);
 
+	pci_read_config_byte(dev, PCI_INTERRUPT_PIN, &pin);
+	if (pin) {
+		pci_read_config_word(dev, PCI_COMMAND, &cmd);
+		if (cmd & PCI_COMMAND_INTX_DISABLE)
+			pci_write_config_word(dev, PCI_COMMAND,
+					      cmd & ~PCI_COMMAND_INTX_DISABLE);
+	}
+
 	return 0;
 }
 

commit 6354647f55b9848dc9aaa091e2f762ca1a3eb085
Merge: c128856b48b1 94e6a9b93064
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Feb 18 14:33:46 2014 -0700

    Merge branch 'pci/list-for-each-entry' into next
    
    * pci/list-for-each-entry:
      PCI: Remove pci_bus_b() and use list_for_each_entry() directly
      pcmcia: Use list_for_each_entry() for bus traversal
      powerpc/PCI: Use list_for_each_entry() for bus traversal
      drm: Use list_for_each_entry() for bus traversal
      ARM/PCI: Use list_for_each_entry() for bus traversal
      ACPI / hotplug / PCI: Use list_for_each_entry() for bus traversal

commit 94e6a9b93064b49024b8701d2d81fcb4a821fa09
Author: Yijing Wang <wangyijing@huawei.com>
Date:   Thu Feb 13 21:14:03 2014 +0800

    PCI: Remove pci_bus_b() and use list_for_each_entry() directly
    
    Replace list_for_each() with list_for_each_entry(), which means we no
    longer need pci_bus_b() and can remove it.
    
    Signed-off-by: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 1febe90831b4..6f5ed88ca126 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -108,12 +108,12 @@ static bool pcie_ari_disabled;
  */
 unsigned char pci_bus_max_busnr(struct pci_bus* bus)
 {
-	struct list_head *tmp;
+	struct pci_bus *tmp;
 	unsigned char max, n;
 
 	max = bus->busn_res.end;
-	list_for_each(tmp, &bus->children) {
-		n = pci_bus_max_busnr(pci_bus_b(tmp));
+	list_for_each_entry(tmp, &bus->children, node) {
+		n = pci_bus_max_busnr(tmp);
 		if(n > max)
 			max = n;
 	}

commit 2c74424470a0f98df8d6540642aff96d1a0b94b3
Author: Alex Williamson <alex.williamson@redhat.com>
Date:   Mon Feb 3 14:27:33 2014 -0700

    PCI: Add device-specific PCI ACS enable
    
    Some devices support PCI ACS-like features, but don't report it using the
    standard PCIe capabilities.  We already provide hooks for device-specific
    testing of ACS, but not for device-specific enabling of ACS.  This provides
    that setup hook.
    
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 1febe90831b4..b89502ff3139 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2180,21 +2180,18 @@ void pci_request_acs(void)
 }
 
 /**
- * pci_enable_acs - enable ACS if hardware support it
+ * pci_std_enable_acs - enable ACS on devices using standard ACS capabilites
  * @dev: the PCI device
  */
-void pci_enable_acs(struct pci_dev *dev)
+static int pci_std_enable_acs(struct pci_dev *dev)
 {
 	int pos;
 	u16 cap;
 	u16 ctrl;
 
-	if (!pci_acs_enable)
-		return;
-
 	pos = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ACS);
 	if (!pos)
-		return;
+		return -ENODEV;
 
 	pci_read_config_word(dev, pos + PCI_ACS_CAP, &cap);
 	pci_read_config_word(dev, pos + PCI_ACS_CTRL, &ctrl);
@@ -2212,6 +2209,23 @@ void pci_enable_acs(struct pci_dev *dev)
 	ctrl |= (cap & PCI_ACS_UF);
 
 	pci_write_config_word(dev, pos + PCI_ACS_CTRL, ctrl);
+
+	return 0;
+}
+
+/**
+ * pci_enable_acs - enable ACS if hardware support it
+ * @dev: the PCI device
+ */
+void pci_enable_acs(struct pci_dev *dev)
+{
+	if (!pci_acs_enable)
+		return;
+
+	if (!pci_std_enable_acs(dev))
+		return;
+
+	pci_dev_specific_enable_acs(dev);
 }
 
 static bool pci_acs_flags_enabled(struct pci_dev *pdev, u16 acs_flags)

commit ce300008023fc4ddb561c48bf7e157c8e6279f46
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Jan 24 09:51:06 2014 -0700

    PCI: Remove unnecessary list_empty(&pci_pme_list) check
    
    list_for_each_entry() handles empty lists just fine, so there's no need to
    check whether the list is empty first.
    
    No functional change.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rjw@rjwysocki.net>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 1febe90831b4..52e10e1181d0 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1611,29 +1611,27 @@ static void pci_pme_list_scan(struct work_struct *work)
 	struct pci_pme_device *pme_dev, *n;
 
 	mutex_lock(&pci_pme_list_mutex);
-	if (!list_empty(&pci_pme_list)) {
-		list_for_each_entry_safe(pme_dev, n, &pci_pme_list, list) {
-			if (pme_dev->dev->pme_poll) {
-				struct pci_dev *bridge;
-
-				bridge = pme_dev->dev->bus->self;
-				/*
-				 * If bridge is in low power state, the
-				 * configuration space of subordinate devices
-				 * may be not accessible
-				 */
-				if (bridge && bridge->current_state != PCI_D0)
-					continue;
-				pci_pme_wakeup(pme_dev->dev, NULL);
-			} else {
-				list_del(&pme_dev->list);
-				kfree(pme_dev);
-			}
+	list_for_each_entry_safe(pme_dev, n, &pci_pme_list, list) {
+		if (pme_dev->dev->pme_poll) {
+			struct pci_dev *bridge;
+
+			bridge = pme_dev->dev->bus->self;
+			/*
+			 * If bridge is in low power state, the
+			 * configuration space of subordinate devices
+			 * may be not accessible
+			 */
+			if (bridge && bridge->current_state != PCI_D0)
+				continue;
+			pci_pme_wakeup(pme_dev->dev, NULL);
+		} else {
+			list_del(&pme_dev->list);
+			kfree(pme_dev);
 		}
-		if (!list_empty(&pci_pme_list))
-			schedule_delayed_work(&pci_pme_work,
-					      msecs_to_jiffies(PME_TIMEOUT));
 	}
+	if (!list_empty(&pci_pme_list))
+		schedule_delayed_work(&pci_pme_work,
+				      msecs_to_jiffies(PME_TIMEOUT));
 	mutex_unlock(&pci_pme_list_mutex);
 }
 

commit e1ba84597c9012b9f9075aac283ac7537d7561ba
Merge: 60eaa0190f6b cef09b808e58
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jan 22 16:39:28 2014 -0800

    Merge tag 'pci-v3.14-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI updates from Bjorn Helgaas:
     "PCI changes for the v3.14 merge window:
    
      Resource management
        - Change pci_bus_region addresses to dma_addr_t (Bjorn Helgaas)
        - Support 64-bit AGP BARs (Bjorn Helgaas, Yinghai Lu)
        - Add pci_bus_address() to get bus address of a BAR (Bjorn Helgaas)
        - Use pci_resource_start() for CPU address of AGP BARs (Bjorn Helgaas)
        - Enforce bus address limits in resource allocation (Yinghai Lu)
        - Allocate 64-bit BARs above 4G when possible (Yinghai Lu)
        - Convert pcibios_resource_to_bus() to take pci_bus, not pci_dev (Yinghai Lu)
    
      PCI device hotplug
        - Major rescan/remove locking update (Rafael J. Wysocki)
        - Make ioapic builtin only (not modular) (Yinghai Lu)
        - Fix release/free issues (Yinghai Lu)
        - Clean up pciehp (Bjorn Helgaas)
        - Announce pciehp slot info during enumeration (Bjorn Helgaas)
    
      MSI
        - Add pci_msi_vec_count(), pci_msix_vec_count() (Alexander Gordeev)
        - Add pci_enable_msi_range(), pci_enable_msix_range() (Alexander Gordeev)
        - Deprecate "tri-state" interfaces: fail/success/fail+info (Alexander Gordeev)
        - Export MSI mode using attributes, not kobjects (Greg Kroah-Hartman)
        - Drop "irq" param from *_restore_msi_irqs() (DuanZhenzhong)
    
      SR-IOV
        - Clear NumVFs when disabling SR-IOV in sriov_init() (ethan.zhao)
    
      Virtualization
        - Add support for save/restore of extended capabilities (Alex Williamson)
        - Add Virtual Channel to save/restore support (Alex Williamson)
        - Never treat a VF as a multifunction device (Alex Williamson)
        - Add pci_try_reset_function(), et al (Alex Williamson)
    
      AER
        - Ignore non-PCIe error sources (Betty Dall)
        - Support ACPI HEST error sources for domains other than 0 (Betty Dall)
        - Consolidate HEST error source parsers (Bjorn Helgaas)
        - Add a TLP header print helper (Borislav Petkov)
    
      Freescale i.MX6
        - Remove unnecessary code (Fabio Estevam)
        - Make reset-gpio optional (Marek Vasut)
        - Report "link up" only after link training completes (Marek Vasut)
        - Start link in Gen1 before negotiating for Gen2 mode (Marek Vasut)
        - Fix PCIe startup code (Richard Zhu)
    
      Marvell MVEBU
        - Remove duplicate of_clk_get_by_name() call (Andrew Lunn)
        - Drop writes to bridge Secondary Status register (Jason Gunthorpe)
        - Obey bridge PCI_COMMAND_MEM and PCI_COMMAND_IO bits (Jason Gunthorpe)
        - Support a bridge with no IO port window (Jason Gunthorpe)
        - Use max_t() instead of max(resource_size_t,) (Jingoo Han)
        - Remove redundant of_match_ptr (Sachin Kamat)
        - Call pci_ioremap_io() at startup instead of dynamically (Thomas Petazzoni)
    
      NVIDIA Tegra
        - Disable Gen2 for Tegra20 and Tegra30 (Eric Brower)
    
      Renesas R-Car
        - Add runtime PM support (Valentine Barshak)
        - Fix rcar_pci_probe() return value check (Wei Yongjun)
    
      Synopsys DesignWare
        - Fix crash in dw_msi_teardown_irq() (Bjørn Erik Nilsen)
        - Remove redundant call to pci_write_config_word() (Bjørn Erik Nilsen)
        - Fix missing MSI IRQs (Harro Haan)
        - Add dw_pcie prefix before cfg_read/write (Pratyush Anand)
        - Fix I/O transfers by using CPU (not realio) address (Pratyush Anand)
        - Whitespace cleanup (Jingoo Han)
    
      EISA
        - Call put_device() if device_register() fails (Levente Kurusa)
        - Revert EISA initialization breakage ((Bjorn Helgaas)
    
      Miscellaneous
        - Remove unused code, including PCIe 3.0 interfaces (Stephen Hemminger)
        - Prevent bus conflicts while checking for bridge apertures (Bjorn Helgaas)
        - Stop clearing bridge Secondary Status when setting up I/O aperture (Bjorn Helgaas)
        - Use dev_is_pci() to identify PCI devices (Yijing Wang)
        - Deprecate DEFINE_PCI_DEVICE_TABLE (Joe Perches)
        - Update documentation 00-INDEX (Erik Ekman)"
    
    * tag 'pci-v3.14-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (119 commits)
      Revert "EISA: Initialize device before its resources"
      Revert "EISA: Log device resources in dmesg"
      vfio-pci: Use pci "try" reset interface
      PCI: Check parent kobject in pci_destroy_dev()
      xen/pcifront: Use global PCI rescan-remove locking
      powerpc/eeh: Use global PCI rescan-remove locking
      PCI: Fix pci_check_and_unmask_intx() comment typos
      PCI: Add pci_try_reset_function(), pci_try_reset_slot(), pci_try_reset_bus()
      MPT / PCI: Use pci_stop_and_remove_bus_device_locked()
      platform / x86: Use global PCI rescan-remove locking
      PCI: hotplug: Use global PCI rescan-remove locking
      pcmcia: Use global PCI rescan-remove locking
      ACPI / hotplug / PCI: Use global PCI rescan-remove locking
      ACPI / PCI: Use global PCI rescan-remove locking in PCI root hotplug
      PCI: Add global pci_lock_rescan_remove()
      PCI: Cleanup pci.h whitespace
      PCI: Reorder so actual code comes before stubs
      PCI/AER: Support ACPI HEST AER error sources for PCI domains other than 0
      ACPICA: Add helper macros to extract bus/segment numbers from HEST table.
      PCI: Make local functions static
      ...

commit 6e2d98dc1af49a6736cd9c54e2e44b5d5234d242
Merge: 40304618468c 890ed578df82
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Jan 15 10:53:35 2014 -0700

    Merge branch 'pci/reset' into next
    
    * pci/reset:
      vfio-pci: Use pci "try" reset interface
      PCI: Add pci_try_reset_function(), pci_try_reset_slot(), pci_try_reset_bus()

commit 1255dfbb0c77c7a26fec10a5c101b075c3641965
Merge: a870614a5371 ebd50b939c33
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Jan 15 10:52:41 2014 -0700

    Merge branch 'pci/misc' into next
    
    * pci/misc:
      PCI: Fix pci_check_and_unmask_intx() comment typos
      PCI: Never treat a VF as a multifunction device

commit ebd50b939c33c692a4914e66bf06a99b21ffa483
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Jan 14 17:10:39 2014 -0700

    PCI: Fix pci_check_and_unmask_intx() comment typos
    
    Fix typos in pci_check_and_unmask_intx() function comment.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 33120d156668..4f89a99e2de3 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -3138,7 +3138,7 @@ bool pci_check_and_mask_intx(struct pci_dev *dev)
 EXPORT_SYMBOL_GPL(pci_check_and_mask_intx);
 
 /**
- * pci_check_and_mask_intx - unmask INTx of no interrupt is pending
+ * pci_check_and_unmask_intx - unmask INTx if no interrupt is pending
  * @dev: the PCI device to operate on
  *
  * Check if the device dev has its INTx line asserted, unmask it if not

commit 61cf16d8bd38c3dc52033ea75d5b1f8368514a17
Author: Alex Williamson <alex.williamson@redhat.com>
Date:   Mon Dec 16 15:14:31 2013 -0700

    PCI: Add pci_try_reset_function(), pci_try_reset_slot(), pci_try_reset_bus()
    
    When doing a function/slot/bus reset PCI grabs the device_lock for each
    device to block things like suspend and driver probes, but call paths exist
    where this lock may already be held.  This creates an opportunity for
    deadlock.  For instance, vfio allows userspace to issue resets so long as
    it owns the device(s).  If a driver unbind .remove callback races with
    userspace issuing a reset, we have a deadlock as userspace gets stuck
    waiting on device_lock while another thread has device_lock and waits for
    .remove to complete.  To resolve this, we can make a version of the reset
    interfaces which use trylock.  With this, we can safely attempt a reset and
    return error to userspace if there is contention.
    
    [bhelgaas: the deadlock happens when A (userspace) has a file descriptor for
    the device, and B waits in this path:
    
      driver_detach
        device_lock                     # take device_lock
        __device_release_driver
          pci_device_remove             # pci_bus_type.remove
            vfio_pci_remove             # pci_driver .remove
              vfio_del_group_dev
                wait_event(vfio.release_q, !vfio_dev_present)   # wait (holding device_lock)
    
    Now B is stuck until A gives up the file descriptor.  If A tries to acquire
    device_lock for any reason, we deadlock because A is waiting for B to release
    the lock, and B is waiting for A to release the file descriptor.]
    
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 1cbd590cf1d1..8386367814ee 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -3250,6 +3250,18 @@ static void pci_dev_lock(struct pci_dev *dev)
 	device_lock(&dev->dev);
 }
 
+/* Return 1 on successful lock, 0 on contention */
+static int pci_dev_trylock(struct pci_dev *dev)
+{
+	if (pci_cfg_access_trylock(dev)) {
+		if (device_trylock(&dev->dev))
+			return 1;
+		pci_cfg_access_unlock(dev);
+	}
+
+	return 0;
+}
+
 static void pci_dev_unlock(struct pci_dev *dev)
 {
 	device_unlock(&dev->dev);
@@ -3393,6 +3405,34 @@ int pci_reset_function(struct pci_dev *dev)
 }
 EXPORT_SYMBOL_GPL(pci_reset_function);
 
+/**
+ * pci_try_reset_function - quiesce and reset a PCI device function
+ * @dev: PCI device to reset
+ *
+ * Same as above, except return -EAGAIN if unable to lock device.
+ */
+int pci_try_reset_function(struct pci_dev *dev)
+{
+	int rc;
+
+	rc = pci_dev_reset(dev, 1);
+	if (rc)
+		return rc;
+
+	pci_dev_save_and_disable(dev);
+
+	if (pci_dev_trylock(dev)) {
+		rc = __pci_dev_reset(dev, 0);
+		pci_dev_unlock(dev);
+	} else
+		rc = -EAGAIN;
+
+	pci_dev_restore(dev);
+
+	return rc;
+}
+EXPORT_SYMBOL_GPL(pci_try_reset_function);
+
 /* Lock devices from the top of the tree down */
 static void pci_bus_lock(struct pci_bus *bus)
 {
@@ -3417,6 +3457,32 @@ static void pci_bus_unlock(struct pci_bus *bus)
 	}
 }
 
+/* Return 1 on successful lock, 0 on contention */
+static int pci_bus_trylock(struct pci_bus *bus)
+{
+	struct pci_dev *dev;
+
+	list_for_each_entry(dev, &bus->devices, bus_list) {
+		if (!pci_dev_trylock(dev))
+			goto unlock;
+		if (dev->subordinate) {
+			if (!pci_bus_trylock(dev->subordinate)) {
+				pci_dev_unlock(dev);
+				goto unlock;
+			}
+		}
+	}
+	return 1;
+
+unlock:
+	list_for_each_entry_continue_reverse(dev, &bus->devices, bus_list) {
+		if (dev->subordinate)
+			pci_bus_unlock(dev->subordinate);
+		pci_dev_unlock(dev);
+	}
+	return 0;
+}
+
 /* Lock devices from the top of the tree down */
 static void pci_slot_lock(struct pci_slot *slot)
 {
@@ -3445,6 +3511,37 @@ static void pci_slot_unlock(struct pci_slot *slot)
 	}
 }
 
+/* Return 1 on successful lock, 0 on contention */
+static int pci_slot_trylock(struct pci_slot *slot)
+{
+	struct pci_dev *dev;
+
+	list_for_each_entry(dev, &slot->bus->devices, bus_list) {
+		if (!dev->slot || dev->slot != slot)
+			continue;
+		if (!pci_dev_trylock(dev))
+			goto unlock;
+		if (dev->subordinate) {
+			if (!pci_bus_trylock(dev->subordinate)) {
+				pci_dev_unlock(dev);
+				goto unlock;
+			}
+		}
+	}
+	return 1;
+
+unlock:
+	list_for_each_entry_continue_reverse(dev,
+					     &slot->bus->devices, bus_list) {
+		if (!dev->slot || dev->slot != slot)
+			continue;
+		if (dev->subordinate)
+			pci_bus_unlock(dev->subordinate);
+		pci_dev_unlock(dev);
+	}
+	return 0;
+}
+
 /* Save and disable devices from the top of the tree down */
 static void pci_bus_save_and_disable(struct pci_bus *bus)
 {
@@ -3568,6 +3665,35 @@ int pci_reset_slot(struct pci_slot *slot)
 }
 EXPORT_SYMBOL_GPL(pci_reset_slot);
 
+/**
+ * pci_try_reset_slot - Try to reset a PCI slot
+ * @slot: PCI slot to reset
+ *
+ * Same as above except return -EAGAIN if the slot cannot be locked
+ */
+int pci_try_reset_slot(struct pci_slot *slot)
+{
+	int rc;
+
+	rc = pci_slot_reset(slot, 1);
+	if (rc)
+		return rc;
+
+	pci_slot_save_and_disable(slot);
+
+	if (pci_slot_trylock(slot)) {
+		might_sleep();
+		rc = pci_reset_hotplug_slot(slot->hotplug, 0);
+		pci_slot_unlock(slot);
+	} else
+		rc = -EAGAIN;
+
+	pci_slot_restore(slot);
+
+	return rc;
+}
+EXPORT_SYMBOL_GPL(pci_try_reset_slot);
+
 static int pci_bus_reset(struct pci_bus *bus, int probe)
 {
 	if (!bus->self)
@@ -3626,6 +3752,35 @@ int pci_reset_bus(struct pci_bus *bus)
 }
 EXPORT_SYMBOL_GPL(pci_reset_bus);
 
+/**
+ * pci_try_reset_bus - Try to reset a PCI bus
+ * @bus: top level PCI bus to reset
+ *
+ * Same as above except return -EAGAIN if the bus cannot be locked
+ */
+int pci_try_reset_bus(struct pci_bus *bus)
+{
+	int rc;
+
+	rc = pci_bus_reset(bus, 1);
+	if (rc)
+		return rc;
+
+	pci_bus_save_and_disable(bus);
+
+	if (pci_bus_trylock(bus)) {
+		might_sleep();
+		pci_reset_bridge_secondary_bus(bus->self);
+		pci_bus_unlock(bus);
+	} else
+		rc = -EAGAIN;
+
+	pci_bus_restore(bus);
+
+	return rc;
+}
+EXPORT_SYMBOL_GPL(pci_try_reset_bus);
+
 /**
  * pcix_get_max_mmrbc - get PCI-X maximum designed memory read byte count
  * @dev: PCI device to query

commit 597db6f38c4bcb90406d4e2f56446ba5a5dc20c6
Merge: 6b9bd1e3ee8f 0b950f0f3c67
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Jan 13 16:47:08 2014 -0700

    Merge branch 'pci/dead-code' into next
    
    * pci/dead-code:
      PCI: Make local functions static
      PCI: Remove unused alloc_pci_dev()
      PCI: Remove unused pci_renumber_slot()
      PCI: Remove unused pcie_aspm_enabled()
      PCI: Remove unused pci_vpd_truncate()
      PCI: Remove unused ID-Based Ordering support
      PCI: Remove unused Optimized Buffer Flush/Fill support
      PCI: Remove unused Latency Tolerance Reporting support
      PCI: Removed unused parts of Page Request Interface support
    
    Conflicts:
            drivers/pci/pci.c
            include/linux/pci.h

commit 0b950f0f3c67e42f18c655a3ab3e36ea192635bb
Author: Stephen Hemminger <stephen@networkplumber.org>
Date:   Fri Jan 10 17:14:48 2014 -0700

    PCI: Make local functions static
    
    Using 'make namespacecheck' identify code which should be declared static.
    Checked for users in other driver/archs as well.  Compile tested only.
    
    This stops exporting the following interfaces to modules:
    
        pci_target_state()
        pci_load_saved_state()
    
    [bhelgaas: retained pci_find_next_ext_capability() and pci_cfg_space_size()]
    Signed-off-by: Stephen Hemminger <stephen@networkplumber.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 6db2f1a441e9..9ea31080870f 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -656,6 +656,28 @@ static int pci_platform_power_transition(struct pci_dev *dev, pci_power_t state)
 	return error;
 }
 
+/**
+ * pci_wakeup - Wake up a PCI device
+ * @pci_dev: Device to handle.
+ * @ign: ignored parameter
+ */
+static int pci_wakeup(struct pci_dev *pci_dev, void *ign)
+{
+	pci_wakeup_event(pci_dev);
+	pm_request_resume(&pci_dev->dev);
+	return 0;
+}
+
+/**
+ * pci_wakeup_bus - Walk given bus and wake up devices on it
+ * @bus: Top bus of the subtree to walk.
+ */
+static void pci_wakeup_bus(struct pci_bus *bus)
+{
+	if (bus)
+		pci_walk_bus(bus, pci_wakeup, NULL);
+}
+
 /**
  * __pci_start_power_transition - Start power transition of a PCI device
  * @dev: PCI device to handle.
@@ -835,8 +857,8 @@ EXPORT_SYMBOL(pci_choose_state);
 #define PCI_EXP_SAVE_REGS	7
 
 
-static struct pci_cap_saved_state *pci_find_saved_cap(
-	struct pci_dev *pci_dev, char cap)
+static struct pci_cap_saved_state *pci_find_saved_cap(struct pci_dev *pci_dev,
+						      char cap)
 {
 	struct pci_cap_saved_state *tmp;
 
@@ -1071,7 +1093,8 @@ EXPORT_SYMBOL_GPL(pci_store_saved_state);
  * @dev: PCI device that we're dealing with
  * @state: Saved state returned from pci_store_saved_state()
  */
-int pci_load_saved_state(struct pci_dev *dev, struct pci_saved_state *state)
+static int pci_load_saved_state(struct pci_dev *dev,
+				struct pci_saved_state *state)
 {
 	struct pci_cap_saved_data *cap;
 
@@ -1099,7 +1122,6 @@ int pci_load_saved_state(struct pci_dev *dev, struct pci_saved_state *state)
 	dev->state_saved = true;
 	return 0;
 }
-EXPORT_SYMBOL_GPL(pci_load_saved_state);
 
 /**
  * pci_load_and_free_saved_state - Reload the save state pointed to by state,
@@ -1531,27 +1553,6 @@ void pci_pme_wakeup_bus(struct pci_bus *bus)
 		pci_walk_bus(bus, pci_pme_wakeup, (void *)true);
 }
 
-/**
- * pci_wakeup - Wake up a PCI device
- * @pci_dev: Device to handle.
- * @ign: ignored parameter
- */
-static int pci_wakeup(struct pci_dev *pci_dev, void *ign)
-{
-	pci_wakeup_event(pci_dev);
-	pm_request_resume(&pci_dev->dev);
-	return 0;
-}
-
-/**
- * pci_wakeup_bus - Walk given bus and wake up devices on it
- * @bus: Top bus of the subtree to walk.
- */
-void pci_wakeup_bus(struct pci_bus *bus)
-{
-	if (bus)
-		pci_walk_bus(bus, pci_wakeup, NULL);
-}
 
 /**
  * pci_pme_capable - check the capability of PCI device to generate PME#
@@ -1765,7 +1766,7 @@ int pci_wake_from_d3(struct pci_dev *dev, bool enable)
  * If the platform can't manage @dev, return the deepest state from which it
  * can generate wake events, based on any available PME info.
  */
-pci_power_t pci_target_state(struct pci_dev *dev)
+static pci_power_t pci_target_state(struct pci_dev *dev)
 {
 	pci_power_t target_state = PCI_D3hot;
 
@@ -4206,7 +4207,6 @@ EXPORT_SYMBOL(pci_restore_state);
 EXPORT_SYMBOL(pci_pme_capable);
 EXPORT_SYMBOL(pci_pme_active);
 EXPORT_SYMBOL(pci_wake_from_d3);
-EXPORT_SYMBOL(pci_target_state);
 EXPORT_SYMBOL(pci_prepare_to_sleep);
 EXPORT_SYMBOL(pci_back_from_sleep);
 EXPORT_SYMBOL_GPL(pci_set_pcie_reset_state);

commit 7c2dd2d7cfabdb37875c5e481a0c3cc5962bb0b6
Author: Stephen Hemminger <stephen@networkplumber.org>
Date:   Fri Jan 10 14:01:11 2014 -0700

    PCI: Remove unused ID-Based Ordering support
    
    My philosophy is unused code is dead code.  And dead code is subject to bit
    rot and is a likely source of bugs.  Use it or lose it.
    
    This reverts b48d4425b602 ("PCI: add ID-based ordering enable/disable
    support"), removing these interfaces:
    
        pci_enable_ido()
        pci_disable_ido()
    
    [bhelgaas: split to separate patch, also remove prototypes from pci.h]
    Signed-off-by: Stephen Hemminger <stephen@networkplumber.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    CC: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 84a24d16778f..6db2f1a441e9 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2110,46 +2110,6 @@ void pci_configure_ari(struct pci_dev *dev)
 	}
 }
 
-/**
- * pci_enable_ido - enable ID-based Ordering on a device
- * @dev: the PCI device
- * @type: which types of IDO to enable
- *
- * Enable ID-based ordering on @dev.  @type can contain the bits
- * %PCI_EXP_IDO_REQUEST and/or %PCI_EXP_IDO_COMPLETION to indicate
- * which types of transactions are allowed to be re-ordered.
- */
-void pci_enable_ido(struct pci_dev *dev, unsigned long type)
-{
-	u16 ctrl = 0;
-
-	if (type & PCI_EXP_IDO_REQUEST)
-		ctrl |= PCI_EXP_DEVCTL2_IDO_REQ_EN;
-	if (type & PCI_EXP_IDO_COMPLETION)
-		ctrl |= PCI_EXP_DEVCTL2_IDO_CMP_EN;
-	if (ctrl)
-		pcie_capability_set_word(dev, PCI_EXP_DEVCTL2, ctrl);
-}
-EXPORT_SYMBOL(pci_enable_ido);
-
-/**
- * pci_disable_ido - disable ID-based ordering on a device
- * @dev: the PCI device
- * @type: which types of IDO to disable
- */
-void pci_disable_ido(struct pci_dev *dev, unsigned long type)
-{
-	u16 ctrl = 0;
-
-	if (type & PCI_EXP_IDO_REQUEST)
-		ctrl |= PCI_EXP_DEVCTL2_IDO_REQ_EN;
-	if (type & PCI_EXP_IDO_COMPLETION)
-		ctrl |= PCI_EXP_DEVCTL2_IDO_CMP_EN;
-	if (ctrl)
-		pcie_capability_clear_word(dev, PCI_EXP_DEVCTL2, ctrl);
-}
-EXPORT_SYMBOL(pci_disable_ido);
-
 static int pci_acs_enable;
 
 /**

commit ecc8635608342a05ded722f0e30e6ccd682f84a6
Author: Stephen Hemminger <stephen@networkplumber.org>
Date:   Fri Jan 10 14:01:05 2014 -0700

    PCI: Remove unused Optimized Buffer Flush/Fill support
    
    My philosophy is unused code is dead code.  And dead code is subject to bit
    rot and is a likely source of bugs.  Use it or lose it.
    
    This reverts 48a92a8179b3 ("PCI: add OBFF enable/disable support"),
    removing these interfaces:
    
        pci_enable_obff()
        pci_disable_obff()
    
    [bhelgaas: split to separate patch, also remove prototypes from pci.h]
    Signed-off-by: Stephen Hemminger <stephen@networkplumber.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    CC: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 020f672deabb..84a24d16778f 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2150,79 +2150,6 @@ void pci_disable_ido(struct pci_dev *dev, unsigned long type)
 }
 EXPORT_SYMBOL(pci_disable_ido);
 
-/**
- * pci_enable_obff - enable optimized buffer flush/fill
- * @dev: PCI device
- * @type: type of signaling to use
- *
- * Try to enable @type OBFF signaling on @dev.  It will try using WAKE#
- * signaling if possible, falling back to message signaling only if
- * WAKE# isn't supported.  @type should indicate whether the PCIe link
- * be brought out of L0s or L1 to send the message.  It should be either
- * %PCI_EXP_OBFF_SIGNAL_ALWAYS or %PCI_OBFF_SIGNAL_L0.
- *
- * If your device can benefit from receiving all messages, even at the
- * power cost of bringing the link back up from a low power state, use
- * %PCI_EXP_OBFF_SIGNAL_ALWAYS.  Otherwise, use %PCI_OBFF_SIGNAL_L0 (the
- * preferred type).
- *
- * RETURNS:
- * Zero on success, appropriate error number on failure.
- */
-int pci_enable_obff(struct pci_dev *dev, enum pci_obff_signal_type type)
-{
-	u32 cap;
-	u16 ctrl;
-	int ret;
-
-	pcie_capability_read_dword(dev, PCI_EXP_DEVCAP2, &cap);
-	if (!(cap & PCI_EXP_DEVCAP2_OBFF_MASK))
-		return -ENOTSUPP; /* no OBFF support at all */
-
-	/* Make sure the topology supports OBFF as well */
-	if (dev->bus->self) {
-		ret = pci_enable_obff(dev->bus->self, type);
-		if (ret)
-			return ret;
-	}
-
-	pcie_capability_read_word(dev, PCI_EXP_DEVCTL2, &ctrl);
-	if (cap & PCI_EXP_DEVCAP2_OBFF_WAKE)
-		ctrl |= PCI_EXP_DEVCTL2_OBFF_WAKE_EN;
-	else {
-		switch (type) {
-		case PCI_EXP_OBFF_SIGNAL_L0:
-			if (!(ctrl & PCI_EXP_DEVCTL2_OBFF_WAKE_EN))
-				ctrl |= PCI_EXP_DEVCTL2_OBFF_MSGA_EN;
-			break;
-		case PCI_EXP_OBFF_SIGNAL_ALWAYS:
-			ctrl &= ~PCI_EXP_DEVCTL2_OBFF_WAKE_EN;
-			ctrl |= PCI_EXP_DEVCTL2_OBFF_MSGB_EN;
-			break;
-		default:
-			WARN(1, "bad OBFF signal type\n");
-			return -ENOTSUPP;
-		}
-	}
-	pcie_capability_write_word(dev, PCI_EXP_DEVCTL2, ctrl);
-
-	return 0;
-}
-EXPORT_SYMBOL(pci_enable_obff);
-
-/**
- * pci_disable_obff - disable optimized buffer flush/fill
- * @dev: PCI device
- *
- * Disable OBFF on @dev.
- */
-void pci_disable_obff(struct pci_dev *dev)
-{
-	pcie_capability_clear_word(dev, PCI_EXP_DEVCTL2,
-				   PCI_EXP_DEVCTL2_OBFF_WAKE_EN);
-}
-EXPORT_SYMBOL(pci_disable_obff);
-
 static int pci_acs_enable;
 
 /**

commit 3ea8197e1371abd68aef289cad97feb764281642
Author: Stephen Hemminger <stephen@networkplumber.org>
Date:   Fri Jan 10 14:00:57 2014 -0700

    PCI: Remove unused Latency Tolerance Reporting support
    
    My philosophy is unused code is dead code.  And dead code is subject to bit
    rot and is a likely source of bugs.  Use it or lose it.
    
    This reverts 51c2e0a7e5bc ("PCI: add latency tolerance reporting
    enable/disable support"), removing these interfaces:
    
        pci_enable_ltr()
        pci_disable_ltr()
        pci_set_ltr()
    
    [bhelgaas: split to separate patch, also remove prototypes from pci.h]
    Signed-off-by: Stephen Hemminger <stephen@networkplumber.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    CC: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 33120d156668..020f672deabb 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2223,129 +2223,6 @@ void pci_disable_obff(struct pci_dev *dev)
 }
 EXPORT_SYMBOL(pci_disable_obff);
 
-/**
- * pci_ltr_supported - check whether a device supports LTR
- * @dev: PCI device
- *
- * RETURNS:
- * True if @dev supports latency tolerance reporting, false otherwise.
- */
-static bool pci_ltr_supported(struct pci_dev *dev)
-{
-	u32 cap;
-
-	pcie_capability_read_dword(dev, PCI_EXP_DEVCAP2, &cap);
-
-	return cap & PCI_EXP_DEVCAP2_LTR;
-}
-
-/**
- * pci_enable_ltr - enable latency tolerance reporting
- * @dev: PCI device
- *
- * Enable LTR on @dev if possible, which means enabling it first on
- * upstream ports.
- *
- * RETURNS:
- * Zero on success, errno on failure.
- */
-int pci_enable_ltr(struct pci_dev *dev)
-{
-	int ret;
-
-	/* Only primary function can enable/disable LTR */
-	if (PCI_FUNC(dev->devfn) != 0)
-		return -EINVAL;
-
-	if (!pci_ltr_supported(dev))
-		return -ENOTSUPP;
-
-	/* Enable upstream ports first */
-	if (dev->bus->self) {
-		ret = pci_enable_ltr(dev->bus->self);
-		if (ret)
-			return ret;
-	}
-
-	return pcie_capability_set_word(dev, PCI_EXP_DEVCTL2,
-					PCI_EXP_DEVCTL2_LTR_EN);
-}
-EXPORT_SYMBOL(pci_enable_ltr);
-
-/**
- * pci_disable_ltr - disable latency tolerance reporting
- * @dev: PCI device
- */
-void pci_disable_ltr(struct pci_dev *dev)
-{
-	/* Only primary function can enable/disable LTR */
-	if (PCI_FUNC(dev->devfn) != 0)
-		return;
-
-	if (!pci_ltr_supported(dev))
-		return;
-
-	pcie_capability_clear_word(dev, PCI_EXP_DEVCTL2,
-				   PCI_EXP_DEVCTL2_LTR_EN);
-}
-EXPORT_SYMBOL(pci_disable_ltr);
-
-static int __pci_ltr_scale(int *val)
-{
-	int scale = 0;
-
-	while (*val > 1023) {
-		*val = (*val + 31) / 32;
-		scale++;
-	}
-	return scale;
-}
-
-/**
- * pci_set_ltr - set LTR latency values
- * @dev: PCI device
- * @snoop_lat_ns: snoop latency in nanoseconds
- * @nosnoop_lat_ns: nosnoop latency in nanoseconds
- *
- * Figure out the scale and set the LTR values accordingly.
- */
-int pci_set_ltr(struct pci_dev *dev, int snoop_lat_ns, int nosnoop_lat_ns)
-{
-	int pos, ret, snoop_scale, nosnoop_scale;
-	u16 val;
-
-	if (!pci_ltr_supported(dev))
-		return -ENOTSUPP;
-
-	snoop_scale = __pci_ltr_scale(&snoop_lat_ns);
-	nosnoop_scale = __pci_ltr_scale(&nosnoop_lat_ns);
-
-	if (snoop_lat_ns > PCI_LTR_VALUE_MASK ||
-	    nosnoop_lat_ns > PCI_LTR_VALUE_MASK)
-		return -EINVAL;
-
-	if ((snoop_scale > (PCI_LTR_SCALE_MASK >> PCI_LTR_SCALE_SHIFT)) ||
-	    (nosnoop_scale > (PCI_LTR_SCALE_MASK >> PCI_LTR_SCALE_SHIFT)))
-		return -EINVAL;
-
-	pos = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_LTR);
-	if (!pos)
-		return -ENOTSUPP;
-
-	val = (snoop_scale << PCI_LTR_SCALE_SHIFT) | snoop_lat_ns;
-	ret = pci_write_config_word(dev, pos + PCI_LTR_MAX_SNOOP_LAT, val);
-	if (ret != 4)
-		return -EIO;
-
-	val = (nosnoop_scale << PCI_LTR_SCALE_SHIFT) | nosnoop_lat_ns;
-	ret = pci_write_config_word(dev, pos + PCI_LTR_MAX_NOSNOOP_LAT, val);
-	if (ret != 4)
-		return -EIO;
-
-	return 0;
-}
-EXPORT_SYMBOL(pci_set_ltr);
-
 static int pci_acs_enable;
 
 /**

commit 425c1b223dac456d00a61fd6b451b6d1cf00d065
Author: Alex Williamson <alex.williamson@redhat.com>
Date:   Tue Dec 17 16:43:51 2013 -0700

    PCI: Add Virtual Channel to save/restore support
    
    While we don't really have any infrastructure for making use of VC
    support, the system BIOS can configure the topology to non-default
    VC values prior to boot.  This may be due to silicon bugs, desire to
    reserve traffic classes, or perhaps just BIOS bugs.  When we reset
    devices, the VC configuration may return to default values, which can
    be incompatible with devices upstream.  For instance, Nvidia GRID
    cards provide a PCIe switch and some number of GPUs, all supporting
    VC.  The power-on default for VC is to support TC0-7 across VC0,
    however some platforms will only enable TC0/VC0 mapping across the
    topology.  When we do a secondary bus reset on the downstream switch
    port, the GPU is reset to a TC0-7/VC0 mapping while the opposite end
    of the link only enables TC0/VC0.  If the GPU attempts to use TC1-7,
    it fails.
    
    This patch attempts to provide complete support for VC save/restore,
    even beyond the minimally required use case above.  This includes
    save/restore and reload of the arbitration table, save/restore and
    reload of the port arbitration tables, and re-enabling of the
    channels for VC, VC9, and MFVC capabilities.
    
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 8f2be7ec705c..508e560b7d2a 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -984,6 +984,8 @@ pci_save_state(struct pci_dev *dev)
 		return i;
 	if ((i = pci_save_pcix_state(dev)) != 0)
 		return i;
+	if ((i = pci_save_vc_state(dev)) != 0)
+		return i;
 	return 0;
 }
 
@@ -1046,6 +1048,7 @@ void pci_restore_state(struct pci_dev *dev)
 	/* PCI Express register must be restored first */
 	pci_restore_pcie_state(dev);
 	pci_restore_ats_state(dev);
+	pci_restore_vc_state(dev);
 
 	pci_restore_config_space(dev);
 
@@ -2118,6 +2121,8 @@ void pci_allocate_cap_save_buffers(struct pci_dev *dev)
 	if (error)
 		dev_err(&dev->dev,
 			"unable to preallocate PCI-X save buffer\n");
+
+	pci_allocate_vc_save_buffers(dev);
 }
 
 void pci_free_cap_save_buffers(struct pci_dev *dev)

commit fd0f7f73ca96bb0f8723b5e59759ad43bab88954
Author: Alex Williamson <alex.williamson@redhat.com>
Date:   Tue Dec 17 16:43:45 2013 -0700

    PCI: Add support for save/restore of extended capabilities
    
    Current save/restore is specific to standard capabilities.
    
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index bb257b975a8f..8f2be7ec705c 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -861,18 +861,28 @@ EXPORT_SYMBOL(pci_choose_state);
 #define PCI_EXP_SAVE_REGS	7
 
 
-static struct pci_cap_saved_state *pci_find_saved_cap(
-	struct pci_dev *pci_dev, char cap)
+static struct pci_cap_saved_state *_pci_find_saved_cap(struct pci_dev *pci_dev,
+						       u16 cap, bool extended)
 {
 	struct pci_cap_saved_state *tmp;
 
 	hlist_for_each_entry(tmp, &pci_dev->saved_cap_space, next) {
-		if (tmp->cap.cap_nr == cap)
+		if (tmp->cap.cap_extended == extended && tmp->cap.cap_nr == cap)
 			return tmp;
 	}
 	return NULL;
 }
 
+struct pci_cap_saved_state *pci_find_saved_cap(struct pci_dev *dev, char cap)
+{
+	return _pci_find_saved_cap(dev, cap, false);
+}
+
+struct pci_cap_saved_state *pci_find_saved_ext_cap(struct pci_dev *dev, u16 cap)
+{
+	return _pci_find_saved_cap(dev, cap, true);
+}
+
 static int pci_save_pcie_state(struct pci_dev *dev)
 {
 	int i = 0;
@@ -1113,7 +1123,7 @@ int pci_load_saved_state(struct pci_dev *dev, struct pci_saved_state *state)
 	while (cap->size) {
 		struct pci_cap_saved_state *tmp;
 
-		tmp = pci_find_saved_cap(dev, cap->cap_nr);
+		tmp = _pci_find_saved_cap(dev, cap->cap_nr, cap->cap_extended);
 		if (!tmp || tmp->cap.size != cap->size)
 			return -EINVAL;
 
@@ -2047,18 +2057,24 @@ static void pci_add_saved_cap(struct pci_dev *pci_dev,
 }
 
 /**
- * pci_add_cap_save_buffer - allocate buffer for saving given capability registers
+ * _pci_add_cap_save_buffer - allocate buffer for saving given
+ *                            capability registers
  * @dev: the PCI device
  * @cap: the capability to allocate the buffer for
+ * @extended: Standard or Extended capability ID
  * @size: requested size of the buffer
  */
-static int pci_add_cap_save_buffer(
-	struct pci_dev *dev, char cap, unsigned int size)
+static int _pci_add_cap_save_buffer(struct pci_dev *dev, u16 cap,
+				    bool extended, unsigned int size)
 {
 	int pos;
 	struct pci_cap_saved_state *save_state;
 
-	pos = pci_find_capability(dev, cap);
+	if (extended)
+		pos = pci_find_ext_capability(dev, cap);
+	else
+		pos = pci_find_capability(dev, cap);
+
 	if (pos <= 0)
 		return 0;
 
@@ -2067,12 +2083,23 @@ static int pci_add_cap_save_buffer(
 		return -ENOMEM;
 
 	save_state->cap.cap_nr = cap;
+	save_state->cap.cap_extended = extended;
 	save_state->cap.size = size;
 	pci_add_saved_cap(dev, save_state);
 
 	return 0;
 }
 
+int pci_add_cap_save_buffer(struct pci_dev *dev, char cap, unsigned int size)
+{
+	return _pci_add_cap_save_buffer(dev, cap, false, size);
+}
+
+int pci_add_ext_cap_save_buffer(struct pci_dev *dev, u16 cap, unsigned int size)
+{
+	return _pci_add_cap_save_buffer(dev, cap, true, size);
+}
+
 /**
  * pci_allocate_cap_save_buffers - allocate buffers for saving capabilities
  * @dev: the PCI device

commit 157e876ffe0b28821a0d82d8ac944fe7363bbe87
Author: Alex Williamson <alex.williamson@redhat.com>
Date:   Tue Dec 17 16:43:39 2013 -0700

    PCI: Add pci_wait_for_pending() (refactor pci_wait_for_pending_transaction())
    
    We currently have two instance of this loop which waits for a pending bit
    to clear in a status dword.  Generalize the function for future users.
    
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 33120d156668..bb257b975a8f 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -430,6 +430,32 @@ pci_find_parent_resource(const struct pci_dev *dev, struct resource *res)
 	return best;
 }
 
+/**
+ * pci_wait_for_pending - wait for @mask bit(s) to clear in status word @pos
+ * @dev: the PCI device to operate on
+ * @pos: config space offset of status word
+ * @mask: mask of bit(s) to care about in status word
+ *
+ * Return 1 when mask bit(s) in status word clear, 0 otherwise.
+ */
+int pci_wait_for_pending(struct pci_dev *dev, int pos, u16 mask)
+{
+	int i;
+
+	/* Wait for Transaction Pending bit clean */
+	for (i = 0; i < 4; i++) {
+		u16 status;
+		if (i)
+			msleep((1 << (i - 1)) * 100);
+
+		pci_read_config_word(dev, pos, &status);
+		if (!(status & mask))
+			return 1;
+	}
+
+	return 0;
+}
+
 /**
  * pci_restore_bars - restore a devices BAR values (e.g. after wake-up)
  * @dev: PCI device to have its BARs restored
@@ -3204,20 +3230,10 @@ EXPORT_SYMBOL(pci_set_dma_seg_boundary);
  */
 int pci_wait_for_pending_transaction(struct pci_dev *dev)
 {
-	int i;
-	u16 status;
-
-	/* Wait for Transaction Pending bit clean */
-	for (i = 0; i < 4; i++) {
-		if (i)
-			msleep((1 << (i - 1)) * 100);
-
-		pcie_capability_read_word(dev, PCI_EXP_DEVSTA, &status);
-		if (!(status & PCI_EXP_DEVSTA_TRPND))
-			return 1;
-	}
+	if (!pci_is_pcie(dev))
+		return 1;
 
-	return 0;
+	return pci_wait_for_pending(dev, PCI_EXP_DEVSTA, PCI_EXP_DEVSTA_TRPND);
 }
 EXPORT_SYMBOL(pci_wait_for_pending_transaction);
 
@@ -3244,10 +3260,8 @@ static int pcie_flr(struct pci_dev *dev, int probe)
 
 static int pci_af_flr(struct pci_dev *dev, int probe)
 {
-	int i;
 	int pos;
 	u8 cap;
-	u8 status;
 
 	pos = pci_find_capability(dev, PCI_CAP_ID_AF);
 	if (!pos)
@@ -3261,14 +3275,8 @@ static int pci_af_flr(struct pci_dev *dev, int probe)
 		return 0;
 
 	/* Wait for Transaction Pending bit clean */
-	for (i = 0; i < 4; i++) {
-		if (i)
-			msleep((1 << (i - 1)) * 100);
-
-		pci_read_config_byte(dev, pos + PCI_AF_STATUS, &status);
-		if (!(status & PCI_AF_STATUS_TP))
-			goto clear;
-	}
+	if (pci_wait_for_pending(dev, PCI_AF_STATUS, PCI_AF_STATUS_TP))
+		goto clear;
 
 	dev_err(&dev->dev, "transaction is not cleared; "
 			"proceeding with reset anyway\n");

commit 8496e85c20e7836b3dec97780e40f420a3ae2801
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Dec 1 02:34:37 2013 +0100

    PCI / tg3: Give up chip reset and carrier loss handling if PCI device is not present
    
    Modify tg3_chip_reset() and tg3_close() to check if the PCI network
    adapter device is accessible at all in order to skip poking it or
    trying to handle a carrier loss in vain when that's not the case.
    Introduce a special PCI helper function pci_device_is_present()
    for this purpose.
    
    Of course, this uncovers the lack of the appropriate RTNL locking
    in tg3_suspend() and tg3_resume(), so add that locking in there
    too.
    
    These changes prevent tg3 from burning a CPU at 100% load level for
    solid several seconds after the Thunderbolt link is disconnected from
    a Matrox DS1 docking station.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Michael Chan <mchan@broadcom.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 33120d156668..07369f32e8bb 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -4165,6 +4165,14 @@ int pci_set_vga_state(struct pci_dev *dev, bool decode,
 	return 0;
 }
 
+bool pci_device_is_present(struct pci_dev *pdev)
+{
+	u32 v;
+
+	return pci_bus_read_dev_vendor_id(pdev->bus, pdev->devfn, &v, 0);
+}
+EXPORT_SYMBOL_GPL(pci_device_is_present);
+
 #define RESOURCE_ALIGNMENT_PARAM_SIZE COMMAND_LINE_SIZE
 static char resource_alignment_param[RESOURCE_ALIGNMENT_PARAM_SIZE] = {0};
 static DEFINE_SPINLOCK(resource_alignment_lock);

commit f7625980f5820edd1a73536e1a03bcbc1f889fec
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Nov 14 11:28:18 2013 -0700

    PCI: Fix whitespace, capitalization, and spelling errors
    
    Fix whitespace, capitalization, and spelling errors.  No functional change.
    I know "busses" is not an error, but "buses" was more common, so I used it
    consistently.
    
    Signed-off-by: Marta Rybczynska <rybczynska@gmail.com> (pci_reset_bridge_secondary_bus())
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index b127fbda6fc8..33120d156668 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -198,7 +198,7 @@ static int __pci_bus_find_cap_start(struct pci_bus *bus,
 }
 
 /**
- * pci_find_capability - query for devices' capabilities 
+ * pci_find_capability - query for devices' capabilities
  * @dev: PCI device to query
  * @cap: capability code
  *
@@ -207,12 +207,12 @@ static int __pci_bus_find_cap_start(struct pci_bus *bus,
  * device's PCI configuration space or 0 in case the device does not
  * support it.  Possible values for @cap:
  *
- *  %PCI_CAP_ID_PM           Power Management 
- *  %PCI_CAP_ID_AGP          Accelerated Graphics Port 
- *  %PCI_CAP_ID_VPD          Vital Product Data 
- *  %PCI_CAP_ID_SLOTID       Slot Identification 
+ *  %PCI_CAP_ID_PM           Power Management
+ *  %PCI_CAP_ID_AGP          Accelerated Graphics Port
+ *  %PCI_CAP_ID_VPD          Vital Product Data
+ *  %PCI_CAP_ID_SLOTID       Slot Identification
  *  %PCI_CAP_ID_MSI          Message Signalled Interrupts
- *  %PCI_CAP_ID_CHSWP        CompactPCI HotSwap 
+ *  %PCI_CAP_ID_CHSWP        CompactPCI HotSwap
  *  %PCI_CAP_ID_PCIX         PCI-X
  *  %PCI_CAP_ID_EXP          PCI Express
  */
@@ -228,13 +228,13 @@ int pci_find_capability(struct pci_dev *dev, int cap)
 }
 
 /**
- * pci_bus_find_capability - query for devices' capabilities 
+ * pci_bus_find_capability - query for devices' capabilities
  * @bus:   the PCI bus to query
  * @devfn: PCI device to query
  * @cap:   capability code
  *
  * Like pci_find_capability() but works for pci devices that do not have a
- * pci_dev structure set up yet. 
+ * pci_dev structure set up yet.
  *
  * Returns the address of the requested capability structure within the
  * device's PCI configuration space or 0 in case the device does not
@@ -515,7 +515,7 @@ static int pci_raw_set_power_state(struct pci_dev *dev, pci_power_t state)
 		return -EINVAL;
 
 	/* Validate current state:
-	 * Can enter D0 from any state, but if we can only go deeper 
+	 * Can enter D0 from any state, but if we can only go deeper
 	 * to sleep if we're already in a low power state
 	 */
 	if (state != PCI_D0 && dev->current_state <= PCI_D3cold
@@ -998,7 +998,7 @@ static void pci_restore_config_space(struct pci_dev *pdev)
 	}
 }
 
-/** 
+/**
  * pci_restore_state - Restore the saved state of a PCI device
  * @dev: - PCI device that we're dealing with
  */
@@ -1030,7 +1030,7 @@ struct pci_saved_state {
  *			   the device saved state.
  * @dev: PCI device that we're dealing with
  *
- * Rerturn NULL if no state or error.
+ * Return NULL if no state or error.
  */
 struct pci_saved_state *pci_store_saved_state(struct pci_dev *dev)
 {
@@ -1880,7 +1880,7 @@ int pci_finish_runtime_suspend(struct pci_dev *dev)
  * pci_dev_run_wake - Check if device can generate run-time wake-up events.
  * @dev: Device to check.
  *
- * Return true if the device itself is cabable of generating wake-up events
+ * Return true if the device itself is capable of generating wake-up events
  * (through the platform or using the native PCIe PME) or if the device supports
  * PME and one of its upstream bridges can generate wake-up events.
  */
@@ -2447,7 +2447,7 @@ bool pci_acs_enabled(struct pci_dev *pdev, u16 acs_flags)
 	switch (pci_pcie_type(pdev)) {
 	/*
 	 * PCI/X-to-PCIe bridges are not specifically mentioned by the spec,
-	 * but since their primary inteface is PCI/X, we conservatively
+	 * but since their primary interface is PCI/X, we conservatively
 	 * handle them as we would a non-PCIe device.
 	 */
 	case PCI_EXP_TYPE_PCIE_BRIDGE:
@@ -2471,7 +2471,7 @@ bool pci_acs_enabled(struct pci_dev *pdev, u16 acs_flags)
 	/*
 	 * PCIe 3.0, 6.12.1.2 specifies ACS capabilities that should be
 	 * implemented by the remaining PCIe types to indicate peer-to-peer
-	 * capabilities, but only when they are part of a multifunciton
+	 * capabilities, but only when they are part of a multifunction
 	 * device.  The footnote for section 6.12 indicates the specific
 	 * PCIe types included here.
 	 */
@@ -2486,7 +2486,7 @@ bool pci_acs_enabled(struct pci_dev *pdev, u16 acs_flags)
 	}
 
 	/*
-	 * PCIe 3.0, 6.12.1.3 specifies no ACS capabilties are applicable
+	 * PCIe 3.0, 6.12.1.3 specifies no ACS capabilities are applicable
 	 * to single function devices with the exception of downstream ports.
 	 */
 	return true;
@@ -2622,7 +2622,7 @@ void pci_release_region(struct pci_dev *pdev, int bar)
  *
  *	If @exclusive is set, then the region is marked so that userspace
  *	is explicitly not allowed to map the resource via /dev/mem or
- * 	sysfs MMIO access.
+ *	sysfs MMIO access.
  *
  *	Returns 0 on success, or %EBUSY on error.  A warning
  *	message is also printed on failure.
@@ -2634,7 +2634,7 @@ static int __pci_request_region(struct pci_dev *pdev, int bar, const char *res_n
 
 	if (pci_resource_len(pdev, bar) == 0)
 		return 0;
-		
+
 	if (pci_resource_flags(pdev, bar) & IORESOURCE_IO) {
 		if (!request_region(pci_resource_start(pdev, bar),
 			    pci_resource_len(pdev, bar), res_name))
@@ -2694,7 +2694,7 @@ int pci_request_region(struct pci_dev *pdev, int bar, const char *res_name)
  *
  *	The key difference that _exclusive makes it that userspace is
  *	explicitly not allowed to map the resource via /dev/mem or
- * 	sysfs.
+ *	sysfs.
  */
 int pci_request_region_exclusive(struct pci_dev *pdev, int bar, const char *res_name)
 {
@@ -2799,7 +2799,7 @@ int pci_request_regions(struct pci_dev *pdev, const char *res_name)
  *	successfully.
  *
  *	pci_request_regions_exclusive() will mark the region so that
- * 	/dev/mem and the sysfs MMIO access will not be allowed.
+ *	/dev/mem and the sysfs MMIO access will not be allowed.
  *
  *	Returns 0 on success, or %EBUSY on error.  A warning
  *	message is also printed on failure.
@@ -2967,7 +2967,7 @@ pci_set_mwi(struct pci_dev *dev)
 		cmd |= PCI_COMMAND_INVALIDATE;
 		pci_write_config_word(dev, PCI_COMMAND, cmd);
 	}
-	
+
 	return 0;
 }
 
@@ -3292,7 +3292,7 @@ static int pci_af_flr(struct pci_dev *dev, int probe)
  *
  * NOTE: This causes the caller to sleep for twice the device power transition
  * cooldown period, which for the D0->D3hot and D3hot->D0 transitions is 10 ms
- * by devault (i.e. unless the @dev's d3_delay field has a different value).
+ * by default (i.e. unless the @dev's d3_delay field has a different value).
  * Moreover, only devices in D0 can be reset by this function.
  */
 static int pci_pm_reset(struct pci_dev *dev, int probe)
@@ -3341,7 +3341,7 @@ void pci_reset_bridge_secondary_bus(struct pci_dev *dev)
 	pci_write_config_word(dev, PCI_BRIDGE_CONTROL, ctrl);
 	/*
 	 * PCI spec v3.0 7.6.4.2 requires minimum Trst of 1ms.  Double
-	 * this to 2ms to ensure that we meet the minium requirement.
+	 * this to 2ms to ensure that we meet the minimum requirement.
 	 */
 	msleep(2);
 
@@ -3998,7 +3998,7 @@ int pcie_set_mps(struct pci_dev *dev, int mps)
 		return -EINVAL;
 
 	v = ffs(mps) - 8;
-	if (v > dev->pcie_mpss) 
+	if (v > dev->pcie_mpss)
 		return -EINVAL;
 	v <<= 5;
 

commit eaaeb1cb33310dea6c3fa45d8bfc63e5a1d0a846
Merge: c245f2422031 79272138bd5c
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Nov 7 15:02:04 2013 -0700

    Merge branch 'pci/misc' into next
    
    * pci/misc:
      PCI: Enable upstream bridges even for VFs on virtual buses
      PCI: Add pci_upstream_bridge()
      PCI: Add x86_msi.msi_mask_irq() and msix_mask_irq()

commit 79272138bd5c35edb9be5ae7b473a2741751a706
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Nov 6 10:00:51 2013 -0700

    PCI: Enable upstream bridges even for VFs on virtual buses
    
    Previously we enabled the upstream PCI-to-PCI bridge only when
    "dev->bus->self != NULL".  In the case of a VF on a virtual bus, where
    "bus->self == NULL", we didn't enable the upstream bridge.
    
    This fixes that by enabling the upstream bridge of the PF corresponding to
    the VF.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index ac40f90cfd5f..d3ed931c0770 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1148,12 +1148,12 @@ int pci_reenable_device(struct pci_dev *dev)
 
 static void pci_enable_bridge(struct pci_dev *dev)
 {
+	struct pci_dev *bridge;
 	int retval;
 
-	if (!dev)
-		return;
-
-	pci_enable_bridge(dev->bus->self);
+	bridge = pci_upstream_bridge(dev);
+	if (bridge)
+		pci_enable_bridge(bridge);
 
 	if (pci_is_enabled(dev)) {
 		if (!dev->is_busmaster)
@@ -1170,6 +1170,7 @@ static void pci_enable_bridge(struct pci_dev *dev)
 
 static int pci_enable_device_flags(struct pci_dev *dev, unsigned long flags)
 {
+	struct pci_dev *bridge;
 	int err;
 	int i, bars = 0;
 
@@ -1188,7 +1189,9 @@ static int pci_enable_device_flags(struct pci_dev *dev, unsigned long flags)
 	if (atomic_inc_return(&dev->enable_cnt) > 1)
 		return 0;		/* already enabled */
 
-	pci_enable_bridge(dev->bus->self);
+	bridge = pci_upstream_bridge(dev);
+	if (bridge)
+		pci_enable_bridge(bridge);
 
 	/* only skip sriov related */
 	for (i = 0; i <= PCI_ROM_RESOURCE; i++)

commit c245f2422031fec447e4d9e35fb0ef0fd5e42ab9
Merge: 589a1b076ff9 f92d74c1f5af
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Nov 6 16:26:48 2013 -0700

    Merge branch 'pci/misc' into next
    
    * pci/misc:
      PCI: Warn on driver probe return value greater than zero
      PCI: Drop warning about drivers that don't use pci_set_master()
      PCI: Workaround missing pci_set_master in pci drivers
      PCI: Update pcie_ports 'auto' behavior for non-ACPI platforms

commit fbeeb822f6f45cadf154d7b7cff1c13537cd799d
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Nov 5 13:34:51 2013 -0700

    PCI: Drop warning about drivers that don't use pci_set_master()
    
    f41f064cf4 ("PCI: Workaround missing pci_set_master in pci drivers") made
    pci_enable_bridge() turn on bus mastering if the driver hadn't done so
    already.  It also added a warning in this case.  But there's no reason to
    warn about it unless it's actually a problem to enable bus mastering here.
    
    This patch drops the warning because I'm not aware of any such problem.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    CC: Paul Bolle <pebolle@tiscali.nl>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 7a92d81c28e0..ac40f90cfd5f 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1156,10 +1156,8 @@ static void pci_enable_bridge(struct pci_dev *dev)
 	pci_enable_bridge(dev->bus->self);
 
 	if (pci_is_enabled(dev)) {
-		if (!dev->is_busmaster) {
-			dev_warn(&dev->dev, "driver skip pci_set_master, fix it!\n");
+		if (!dev->is_busmaster)
 			pci_set_master(dev);
-		}
 		return;
 	}
 

commit cf3e1feba7f906f233790f1806592730a88f584d
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Tue Nov 5 13:34:38 2013 -0700

    PCI: Workaround missing pci_set_master in pci drivers
    
    Ben Herrenschmidt found that commit 928bea964827 ("PCI: Delay enabling
    bridges until they're needed") breaks PCI in some powerpc environments.
    
    The reason is that the PCIe port driver will call pci_enable_device() on
    the bridge, so the device is enabled, but skips pci_set_master because
    pcie_port_auto and no acpi on powerpc.
    
    Because of that, pci_enable_bridge() later on (called as a result of the
    child device driver doing pci_enable_device) will see the bridge as
    already enabled and will not call pci_set_master() on it.
    
    Fixed by add checking in pci_enable_bridge, and call pci_set_master
    if driver skip that.
    
    That will make the code more robot and wade off problem for missing
    pci_set_master in drivers.
    
    Reported-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 36cc8d5ae8b2..7a92d81c28e0 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1155,8 +1155,14 @@ static void pci_enable_bridge(struct pci_dev *dev)
 
 	pci_enable_bridge(dev->bus->self);
 
-	if (pci_is_enabled(dev))
+	if (pci_is_enabled(dev)) {
+		if (!dev->is_busmaster) {
+			dev_warn(&dev->dev, "driver skip pci_set_master, fix it!\n");
+			pci_set_master(dev);
+		}
 		return;
+	}
+
 	retval = pci_enable_device(dev);
 	if (retval)
 		dev_err(&dev->dev, "Error enabling bridge (%d), continuing\n",

commit 33de1b8bf6e11a3bc69faf2f7ffb3692c723bdf5
Merge: cc17a67c0762 0394cb192db4
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Oct 31 14:12:40 2013 -0600

    Merge branch 'pci/misc' into next
    
    * pci/misc:
      PCI: Report pci_pme_active() kmalloc failure
      mn10300/PCI: Remove useless pcibios_last_bus
      frv/PCI: Remove pcibios_last_bus
      PCI: Fail MSI/MSI-X initialization if device is not in PCI_D0
      x86/PCI: Coalesce multiple overlapping host bridge windows
      MAINTAINERS: Add arch/x86/pci to PCI file patterns
      PCI/PM: Remove pci_pm_complete()
      PCI: Add pci_dev_show_local_cpu() to simplify code
      mn10300/PCI: Remove unused pci_mem_start
      cris/PCI: Remove unused pci_mem_start
      PCI: Make pci_dev_pm_ops static
    
    Conflicts:
            drivers/pci/pci-sysfs.c

commit cc17a67c0762a6030b43e98d775a12a99e5ff247
Merge: 4efc52a9c22d c11592fea049
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Oct 31 14:05:13 2013 -0600

    Merge branch 'pci/yijing-mps-v1' into next
    
    * pci/yijing-mps-v1:
      drm/radeon: use pcie_get_readrq() and pcie_set_readrq() to simplify code
      staging: et131x: Use pci_dev->pcie_mpss and pcie_set_readrq() to simplify code
      IB/qib: Drop qib_tune_pcie_caps() and qib_tune_pcie_coalesce() return values
      IB/qib: Use pcie_set_mps() and pcie_get_mps() to simplify code
      IB/qib: Use pci_is_root_bus() to check whether it is a root bus
      tile/PCI: use cached pci_dev->pcie_mpss to simplify code
      PCI: Export pcie_set_mps() and pcie_get_mps()

commit 0394cb192db4397753046775a8caa736397737b5
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Oct 16 12:32:53 2013 -0600

    PCI: Report pci_pme_active() kmalloc failure
    
    Previously, if kmalloc() failed, we claimed "PME# enabled" in dmesg,
    even though we didn't add the device to the pci_pme_list.  This prints
    a more correct warning.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index ad7fc72a40a0..36cc8d5ae8b2 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1638,8 +1638,10 @@ void pci_pme_active(struct pci_dev *dev, bool enable)
 		if (enable) {
 			pme_dev = kmalloc(sizeof(struct pci_pme_device),
 					  GFP_KERNEL);
-			if (!pme_dev)
-				goto out;
+			if (!pme_dev) {
+				dev_warn(&dev->dev, "can't enable PME#\n");
+				return;
+			}
 			pme_dev->dev = dev;
 			mutex_lock(&pci_pme_list_mutex);
 			list_add(&pme_dev->list, &pci_pme_list);
@@ -1660,7 +1662,6 @@ void pci_pme_active(struct pci_dev *dev, bool enable)
 		}
 	}
 
-out:
 	dev_dbg(&dev->dev, "PME# %s\n", enable ? "enabled" : "disabled");
 }
 

commit a006482b67a96c16dfefc558e36863c51e1829bf
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Sep 23 15:25:26 2013 -0600

    PCI: Drop "setting latency timer" messages
    
    This message isn't useful any more, so drop it.
    
    Reference: https://bugzilla.kernel.org/show_bug.cgi?id=60636
    Reported-by: Oleksil Shevchuk <alxchk@gmail.com>
    Reference: http://lkml.kernel.org/r/CALCETrWkr53ZjqdN3t7rTTfr=+ZKZXJoYsuBcwPf0kN_33GfAw@mail.gmail.com
    Reported-by: Andy Lutomirski <luto@amacapital.net>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index e8ccf6c0f08a..ad7fc72a40a0 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2854,7 +2854,7 @@ void __weak pcibios_set_master(struct pci_dev *dev)
 		lat = pcibios_max_latency;
 	else
 		return;
-	dev_printk(KERN_DEBUG, &dev->dev, "setting latency timer to %d\n", lat);
+
 	pci_write_config_byte(dev, PCI_LATENCY_TIMER, lat);
 }
 

commit f1c66c4678ad223bda0dcd261e4048f009234f85
Author: Yijing Wang <wangyijing@huawei.com>
Date:   Tue Sep 24 12:08:06 2013 -0600

    PCI: Export pcie_set_mps() and pcie_get_mps()
    
    Export pcie_get_mps() and pcie_set_mps() functions so drivers can use
    them to simplify code.
    
    Signed-off-by: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index e8ccf6c0f08a..8c812464f259 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -3972,6 +3972,7 @@ int pcie_get_mps(struct pci_dev *dev)
 
 	return 128 << ((ctl & PCI_EXP_DEVCTL_PAYLOAD) >> 5);
 }
+EXPORT_SYMBOL(pcie_get_mps);
 
 /**
  * pcie_set_mps - set PCI Express maximum payload size
@@ -3996,6 +3997,7 @@ int pcie_set_mps(struct pci_dev *dev, int mps)
 	return pcie_capability_clear_and_set_word(dev, PCI_EXP_DEVCTL,
 						  PCI_EXP_DEVCTL_PAYLOAD, v);
 }
+EXPORT_SYMBOL(pcie_set_mps);
 
 /**
  * pcie_get_minimum_link - determine minimum link settings of a PCI device

commit cc998ff8811530be521f6b316f37ab7676a07938
Merge: 57d730924d5c 0d40f75bdab2
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Sep 5 14:54:29 2013 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net-next
    
    Pull networking changes from David Miller:
     "Noteworthy changes this time around:
    
       1) Multicast rejoin support for team driver, from Jiri Pirko.
    
       2) Centralize and simplify TCP RTT measurement handling in order to
          reduce the impact of bad RTO seeding from SYN/ACKs.  Also, when
          both timestamps and local RTT measurements are available prefer
          the later because there are broken middleware devices which
          scramble the timestamp.
    
          From Yuchung Cheng.
    
       3) Add TCP_NOTSENT_LOWAT socket option to limit the amount of kernel
          memory consumed to queue up unsend user data.  From Eric Dumazet.
    
       4) Add a "physical port ID" abstraction for network devices, from
          Jiri Pirko.
    
       5) Add a "suppress" operation to influence fib_rules lookups, from
          Stefan Tomanek.
    
       6) Add a networking development FAQ, from Paul Gortmaker.
    
       7) Extend the information provided by tcp_probe and add ipv6 support,
          from Daniel Borkmann.
    
       8) Use RCU locking more extensively in openvswitch data paths, from
          Pravin B Shelar.
    
       9) Add SCTP support to openvswitch, from Joe Stringer.
    
      10) Add EF10 chip support to SFC driver, from Ben Hutchings.
    
      11) Add new SYNPROXY netfilter target, from Patrick McHardy.
    
      12) Compute a rate approximation for sending in TCP sockets, and use
          this to more intelligently coalesce TSO frames.  Furthermore, add
          a new packet scheduler which takes advantage of this estimate when
          available.  From Eric Dumazet.
    
      13) Allow AF_PACKET fanouts with random selection, from Daniel
          Borkmann.
    
      14) Add ipv6 support to vxlan driver, from Cong Wang"
    
    Resolved conflicts as per discussion.
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/davem/net-next: (1218 commits)
      openvswitch: Fix alignment of struct sw_flow_key.
      netfilter: Fix build errors with xt_socket.c
      tcp: Add missing braces to do_tcp_setsockopt
      caif: Add missing braces to multiline if in cfctrl_linkup_request
      bnx2x: Add missing braces in bnx2x:bnx2x_link_initialize
      vxlan: Fix kernel panic on device delete.
      net: mvneta: implement ->ndo_do_ioctl() to support PHY ioctls
      net: mvneta: properly disable HW PHY polling and ensure adjust_link() works
      icplus: Use netif_running to determine device state
      ethernet/arc/arc_emac: Fix huge delays in large file copies
      tuntap: orphan frags before trying to set tx timestamp
      tuntap: purge socket error queue on detach
      qlcnic: use standard NAPI weights
      ipv6:introduce function to find route for redirect
      bnx2x: VF RSS support - VF side
      bnx2x: VF RSS support - PF side
      vxlan: Notify drivers for listening UDP port changes
      net: usbnet: update addr_assign_type if appropriate
      driver/net: enic: update enic maintainers and driver
      driver/net: enic: Exposing symbols for Cisco's low latency driver
      ...

commit 2e8b5f621dbe29425906852c6079afb6b28720cb
Merge: 07f2daad094b fed245151249
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Aug 28 20:55:41 2013 -0600

    Merge branch 'pci/misc' into next
    
    * pci/misc:
      PCI: Remove pcie_cap_has_devctl()
      PCI: Support PCIe Capability Slot registers only for ports with slots
      PCI: Remove PCIe Capability version checks
      PCI: Allow PCIe Capability link-related register access for switches
      PCI: Add offsets of PCIe capability registers
      PCI: Tidy bitmasks and spacing of PCIe capability definitions
      PCI: Remove obsolete comment reference to pci_pcie_cap2()
      PCI: Clarify PCI_EXP_TYPE_PCI_BRIDGE comment
      PCI: Rename PCIe capability definitions to follow convention
      PCI: Disable decoding for BAR sizing only when it was actually enabled
      PCI: Add comment about needing pci_msi_off() even when CONFIG_PCI_MSI=n
      PCI: Add pcibios_pm_ops for optional arch-specific hibernate functionality

commit d2ab1fa68c61f01b28ab0859a972c892d81f5d32
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Aug 27 11:11:10 2013 -0600

    PCI: Rename PCIe capability definitions to follow convention
    
    All other PCIe capability register fields include "PCI_EXP" + <reg-name> +
    <field-name>.  This renames PCI_EXP_OBFF_MASK, PCI_EXP_IDO_REQ_EN,
    PCI_EXP_LTR_EN, and related fields using the same convention.
    No functional change.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Samuel Ortiz <sameo@linux.intel.com>  # for MFD driver

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 42e5f86e2387..3d5d45cdc4dd 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2095,9 +2095,9 @@ void pci_enable_ido(struct pci_dev *dev, unsigned long type)
 	u16 ctrl = 0;
 
 	if (type & PCI_EXP_IDO_REQUEST)
-		ctrl |= PCI_EXP_IDO_REQ_EN;
+		ctrl |= PCI_EXP_DEVCTL2_IDO_REQ_EN;
 	if (type & PCI_EXP_IDO_COMPLETION)
-		ctrl |= PCI_EXP_IDO_CMP_EN;
+		ctrl |= PCI_EXP_DEVCTL2_IDO_CMP_EN;
 	if (ctrl)
 		pcie_capability_set_word(dev, PCI_EXP_DEVCTL2, ctrl);
 }
@@ -2113,9 +2113,9 @@ void pci_disable_ido(struct pci_dev *dev, unsigned long type)
 	u16 ctrl = 0;
 
 	if (type & PCI_EXP_IDO_REQUEST)
-		ctrl |= PCI_EXP_IDO_REQ_EN;
+		ctrl |= PCI_EXP_DEVCTL2_IDO_REQ_EN;
 	if (type & PCI_EXP_IDO_COMPLETION)
-		ctrl |= PCI_EXP_IDO_CMP_EN;
+		ctrl |= PCI_EXP_DEVCTL2_IDO_CMP_EN;
 	if (ctrl)
 		pcie_capability_clear_word(dev, PCI_EXP_DEVCTL2, ctrl);
 }
@@ -2147,7 +2147,7 @@ int pci_enable_obff(struct pci_dev *dev, enum pci_obff_signal_type type)
 	int ret;
 
 	pcie_capability_read_dword(dev, PCI_EXP_DEVCAP2, &cap);
-	if (!(cap & PCI_EXP_OBFF_MASK))
+	if (!(cap & PCI_EXP_DEVCAP2_OBFF_MASK))
 		return -ENOTSUPP; /* no OBFF support at all */
 
 	/* Make sure the topology supports OBFF as well */
@@ -2158,17 +2158,17 @@ int pci_enable_obff(struct pci_dev *dev, enum pci_obff_signal_type type)
 	}
 
 	pcie_capability_read_word(dev, PCI_EXP_DEVCTL2, &ctrl);
-	if (cap & PCI_EXP_OBFF_WAKE)
-		ctrl |= PCI_EXP_OBFF_WAKE_EN;
+	if (cap & PCI_EXP_DEVCAP2_OBFF_WAKE)
+		ctrl |= PCI_EXP_DEVCTL2_OBFF_WAKE_EN;
 	else {
 		switch (type) {
 		case PCI_EXP_OBFF_SIGNAL_L0:
-			if (!(ctrl & PCI_EXP_OBFF_WAKE_EN))
-				ctrl |= PCI_EXP_OBFF_MSGA_EN;
+			if (!(ctrl & PCI_EXP_DEVCTL2_OBFF_WAKE_EN))
+				ctrl |= PCI_EXP_DEVCTL2_OBFF_MSGA_EN;
 			break;
 		case PCI_EXP_OBFF_SIGNAL_ALWAYS:
-			ctrl &= ~PCI_EXP_OBFF_WAKE_EN;
-			ctrl |= PCI_EXP_OBFF_MSGB_EN;
+			ctrl &= ~PCI_EXP_DEVCTL2_OBFF_WAKE_EN;
+			ctrl |= PCI_EXP_DEVCTL2_OBFF_MSGB_EN;
 			break;
 		default:
 			WARN(1, "bad OBFF signal type\n");
@@ -2189,7 +2189,8 @@ EXPORT_SYMBOL(pci_enable_obff);
  */
 void pci_disable_obff(struct pci_dev *dev)
 {
-	pcie_capability_clear_word(dev, PCI_EXP_DEVCTL2, PCI_EXP_OBFF_WAKE_EN);
+	pcie_capability_clear_word(dev, PCI_EXP_DEVCTL2,
+				   PCI_EXP_DEVCTL2_OBFF_WAKE_EN);
 }
 EXPORT_SYMBOL(pci_disable_obff);
 
@@ -2237,7 +2238,8 @@ int pci_enable_ltr(struct pci_dev *dev)
 			return ret;
 	}
 
-	return pcie_capability_set_word(dev, PCI_EXP_DEVCTL2, PCI_EXP_LTR_EN);
+	return pcie_capability_set_word(dev, PCI_EXP_DEVCTL2,
+					PCI_EXP_DEVCTL2_LTR_EN);
 }
 EXPORT_SYMBOL(pci_enable_ltr);
 
@@ -2254,7 +2256,8 @@ void pci_disable_ltr(struct pci_dev *dev)
 	if (!pci_ltr_supported(dev))
 		return;
 
-	pcie_capability_clear_word(dev, PCI_EXP_DEVCTL2, PCI_EXP_LTR_EN);
+	pcie_capability_clear_word(dev, PCI_EXP_DEVCTL2,
+				   PCI_EXP_DEVCTL2_LTR_EN);
 }
 EXPORT_SYMBOL(pci_disable_ltr);
 

commit 07f2daad094bc9e9770143cd2d619de24d84bb3e
Merge: 1193725f543c 5895af79158a
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Aug 26 15:40:34 2013 -0600

    Merge branch 'pci/yijing-mps-v8' into next
    
    * pci/yijing-mps-v8:
      PCI: Warn if unsafe MPS settings detected
      PCI: Fix MPS peer-to-peer DMA comment syntax
      PCI: Don't restrict MPS for slots below Root Ports
      PCI: Simplify MPS test for Downstream Port
      PCI: Remove unnecessary check for pcie_get_mps() failure
      PCI: Simplify pcie_bus_configure_settings() interface
      PCI: Drop "PCI-E" prefix from Max Payload Size message

commit 1193725f543c92a77c73769bc2fbe48c53275f53
Merge: 7d8c4a2c5ae6 39772038ea93
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Aug 26 15:40:03 2013 -0600

    Merge branch 'pci/yinghai-assign-unassigned-v6' into next
    
    * pci/yinghai-assign-unassigned-v6:
      PCI: Assign resources for hot-added host bridge more aggressively
      PCI: Move resource reallocation code to non-__init
      PCI: Delay enabling bridges until they're needed
      PCI: Assign resources on a per-bus basis
      PCI: Enable unassigned resource reallocation on per-bus basis
      PCI: Turn on reallocation for unassigned resources with host bridge offset
      PCI: Look for unassigned resources on per-bus basis
      PCI: Drop temporary variable in pci_assign_unassigned_resources()

commit da27f4b3ec77a04672345381cbfeeb841d427327
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Aug 22 14:45:21 2013 -0600

    PCI: Add comment about needing pci_msi_off() even when CONFIG_PCI_MSI=n
    
    Per f5f2b13129 ("msi: sanely support hardware level msi disabling"), we
    want pci_msi_off() to work even if MSI support is not compiled into the
    kernel, and there are existing callers that use it when CONFIG_PCI_MSI=n.
    This adds a comment to that effect.
    
    No functional change.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 69dcd32e0fe8..42e5f86e2387 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -3059,18 +3059,23 @@ bool pci_check_and_unmask_intx(struct pci_dev *dev)
 EXPORT_SYMBOL_GPL(pci_check_and_unmask_intx);
 
 /**
- * pci_msi_off - disables any msi or msix capabilities
+ * pci_msi_off - disables any MSI or MSI-X capabilities
  * @dev: the PCI device to operate on
  *
- * If you want to use msi see pci_enable_msi and friends.
- * This is a lower level primitive that allows us to disable
- * msi operation at the device level.
+ * If you want to use MSI, see pci_enable_msi() and friends.
+ * This is a lower-level primitive that allows us to disable
+ * MSI operation at the device level.
  */
 void pci_msi_off(struct pci_dev *dev)
 {
 	int pos;
 	u16 control;
 
+	/*
+	 * This looks like it could go in msi.c, but we need it even when
+	 * CONFIG_PCI_MSI=n.  For the same reason, we can't use
+	 * dev->msi_cap or dev->msix_cap here.
+	 */
 	pos = pci_find_capability(dev, PCI_CAP_ID_MSI);
 	if (pos) {
 		pci_read_config_word(dev, pos + PCI_MSI_FLAGS, &control);

commit f67577118d1154154cf3c1d96f870c4da13846b4
Author: Yijing Wang <wangyijing@huawei.com>
Date:   Thu Aug 22 11:24:45 2013 +0800

    PCI: Remove unnecessary check for pcie_get_mps() failure
    
    After 59875ae489 ("PCI/core: Use PCI Express Capability accessors"),
    pcie_get_mps() never returns an error, so don't bother to check for it.
    
    No functional change.
    
    [bhelgaas: changelog, fix pcie_get_mps() doc]
    Signed-off-by: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index e37fea6e178d..5bb97ee2307e 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -3525,8 +3525,6 @@ int pcie_set_readrq(struct pci_dev *dev, int rq)
 	if (pcie_bus_config == PCIE_BUS_PERFORMANCE) {
 		int mps = pcie_get_mps(dev);
 
-		if (mps < 0)
-			return mps;
 		if (mps < rq)
 			rq = mps;
 	}
@@ -3543,7 +3541,6 @@ EXPORT_SYMBOL(pcie_set_readrq);
  * @dev: PCI device to query
  *
  * Returns maximum payload size in bytes
- *    or appropriate error value.
  */
 int pcie_get_mps(struct pci_dev *dev)
 {

commit 7d8c4a2c5ae6d76f1142fb052d698b3c40ce518c
Merge: 63ef41811b86 9a3d2b9beefd
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Aug 15 14:41:33 2013 -0600

    Merge branch 'pci/aw-reset-v5' into next
    
    * pci/aw-reset-v5:
      PCI: Add pci_probe_reset_slot() and pci_probe_reset_bus()
      PCI: Remove aer_do_secondary_bus_reset()
      PCI: Tune secondary bus reset timing
      PCI: Wake-up devices before saving config space for reset
      PCI: Add pci_reset_slot() and pci_reset_bus()
      PCI: Split out pci_dev lock/unlock and save/restore
      PCI: Add slot reset option to pci_dev_reset()
      PCI: pciehp: Add reset_slot() method
      PCI: Add hotplug_slot_ops.reset_slot()
      PCI: Add pci_reset_bridge_secondary_bus()

commit 9a3d2b9beefd5b07c1d8f70ded01b88f203ee304
Author: Alex Williamson <alex.williamson@redhat.com>
Date:   Wed Aug 14 14:06:05 2013 -0600

    PCI: Add pci_probe_reset_slot() and pci_probe_reset_bus()
    
    Users of pci_reset_bus() and pci_reset_slot() need a way to probe
    whether the bus or slot supports reset.  Add trivial helper functions
    and export them as vfio-pci will make use of these.
    
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index ea5e70486174..7f89372483dd 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -3609,6 +3609,18 @@ static int pci_slot_reset(struct pci_slot *slot, int probe)
 	return rc;
 }
 
+/**
+ * pci_probe_reset_slot - probe whether a PCI slot can be reset
+ * @slot: PCI slot to probe
+ *
+ * Return 0 if slot can be reset, negative if a slot reset is not supported.
+ */
+int pci_probe_reset_slot(struct pci_slot *slot)
+{
+	return pci_slot_reset(slot, 1);
+}
+EXPORT_SYMBOL_GPL(pci_probe_reset_slot);
+
 /**
  * pci_reset_slot - reset a PCI slot
  * @slot: PCI slot to reset
@@ -3661,6 +3673,18 @@ static int pci_bus_reset(struct pci_bus *bus, int probe)
 	return 0;
 }
 
+/**
+ * pci_probe_reset_bus - probe whether a PCI bus can be reset
+ * @bus: PCI bus to probe
+ *
+ * Return 0 if bus can be reset, negative if a bus reset is not supported.
+ */
+int pci_probe_reset_bus(struct pci_bus *bus)
+{
+	return pci_bus_reset(bus, 1);
+}
+EXPORT_SYMBOL_GPL(pci_probe_reset_bus);
+
 /**
  * pci_reset_bus - reset a PCI bus
  * @bus: top level PCI bus to reset

commit de0c548c33429cc78fd47a3c190c6d00b0e4e441
Author: Alex Williamson <alex.williamson@redhat.com>
Date:   Thu Aug 8 14:10:13 2013 -0600

    PCI: Tune secondary bus reset timing
    
    The PCI spec indicates that with stable power, reset needs to be
    asserted for a minimum of 1ms (Trst).  We should be able to assume
    stable power for a Hot Reset, but we add another millisecond as
    a fudge factor to make sure the reset is seen on the bus for at least
    a full 1ms.
    
    After reset is de-asserted we must wait for devices to complete
    initialization.  The specs refer to this as "recovery time" (Trhfa).
    For PCI this is 2^25 clock cycles or 2^26 for PCI-X.  For minimum
    bus speeds, both of those come to 1s.  PCIe "softens" this
    requirement with the Configuration Request Retry Status (CRS)
    completion status.  Theoretically we could use CRS to shorten the
    wait time.  We don't make use of that here, using a fixed 1s delay
    to allow devices to re-initialize.
    
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index deb7fa9cc638..ea5e70486174 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -3230,11 +3230,23 @@ void pci_reset_bridge_secondary_bus(struct pci_dev *dev)
 	pci_read_config_word(dev, PCI_BRIDGE_CONTROL, &ctrl);
 	ctrl |= PCI_BRIDGE_CTL_BUS_RESET;
 	pci_write_config_word(dev, PCI_BRIDGE_CONTROL, ctrl);
-	msleep(100);
+	/*
+	 * PCI spec v3.0 7.6.4.2 requires minimum Trst of 1ms.  Double
+	 * this to 2ms to ensure that we meet the minium requirement.
+	 */
+	msleep(2);
 
 	ctrl &= ~PCI_BRIDGE_CTL_BUS_RESET;
 	pci_write_config_word(dev, PCI_BRIDGE_CONTROL, ctrl);
-	msleep(100);
+
+	/*
+	 * Trhfa for conventional PCI is 2^25 clock cycles.
+	 * Assuming a minimum 33MHz clock this results in a 1s
+	 * delay before we can consider subordinate devices to
+	 * be re-initialized.  PCIe has some ways to shorten this,
+	 * but we don't make use of them yet.
+	 */
+	ssleep(1);
 }
 EXPORT_SYMBOL_GPL(pci_reset_bridge_secondary_bus);
 

commit a6cbaadea0af9b4aa6eee2882f2aa761ab91a4f8
Author: Alex Williamson <alex.williamson@redhat.com>
Date:   Thu Aug 8 14:10:02 2013 -0600

    PCI: Wake-up devices before saving config space for reset
    
    Devices come out of reset in D0.  Restoring a device to a different
    post-reset state takes more smarts than our simple config space
    restore, which can leave devices in an inconsistent state.  For
    example, if a device is reset in D3, but the restore doesn't
    successfully return the device to D3, then the actual state of the
    device and dev->current_state are contradictory.  Put everything
    in D0 going into the reset, then we don't need to do anything
    special on the way out.
    
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 12fccc24925c..deb7fa9cc638 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -3332,6 +3332,13 @@ static void pci_dev_unlock(struct pci_dev *dev)
 
 static void pci_dev_save_and_disable(struct pci_dev *dev)
 {
+	/*
+	 * Wake-up device prior to save.  PM registers default to D0 after
+	 * reset and a simple register restore doesn't reliably return
+	 * to a non-D0 state anyway.
+	 */
+	pci_set_power_state(dev, PCI_D0);
+
 	pci_save_state(dev);
 	/*
 	 * Disable the device by clearing the Command register, except for

commit 090a3c5322e900f468b3205b76d0837003ad57b2
Author: Alex Williamson <alex.williamson@redhat.com>
Date:   Thu Aug 8 14:09:55 2013 -0600

    PCI: Add pci_reset_slot() and pci_reset_bus()
    
    Sometimes pci_reset_function() is not sufficient.  We have cases where
    devices do not support any kind of reset, but there might be multiple
    functions on the bus preventing pci_reset_function() from doing a
    secondary bus reset.  We also have cases where a device will advertise
    that it supports a PM reset, but really does nothing on D3hot->D0
    (graphics cards are notorious for this).  These devices often also
    have more than one function, so even blacklisting PM reset for them
    wouldn't allow a secondary bus reset through pci_reset_function().
    
    If a driver supports multiple devices it should have the ability to
    induce a bus reset when it needs to.  This patch provides that ability
    through pci_reset_slot() and pci_reset_bus().  It's the caller's
    responsibility when using these interfaces to understand that all of
    the devices in or below the slot (or on or below the bus) will be
    reset and therefore should be under control of the caller.  PCI state
    of all the affected devices is saved and restored around these resets,
    but internal state of all of the affected devices is reset (which
    should be the intention).
    
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index d48d9febc241..12fccc24925c 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -3460,6 +3460,215 @@ int pci_reset_function(struct pci_dev *dev)
 }
 EXPORT_SYMBOL_GPL(pci_reset_function);
 
+/* Lock devices from the top of the tree down */
+static void pci_bus_lock(struct pci_bus *bus)
+{
+	struct pci_dev *dev;
+
+	list_for_each_entry(dev, &bus->devices, bus_list) {
+		pci_dev_lock(dev);
+		if (dev->subordinate)
+			pci_bus_lock(dev->subordinate);
+	}
+}
+
+/* Unlock devices from the bottom of the tree up */
+static void pci_bus_unlock(struct pci_bus *bus)
+{
+	struct pci_dev *dev;
+
+	list_for_each_entry(dev, &bus->devices, bus_list) {
+		if (dev->subordinate)
+			pci_bus_unlock(dev->subordinate);
+		pci_dev_unlock(dev);
+	}
+}
+
+/* Lock devices from the top of the tree down */
+static void pci_slot_lock(struct pci_slot *slot)
+{
+	struct pci_dev *dev;
+
+	list_for_each_entry(dev, &slot->bus->devices, bus_list) {
+		if (!dev->slot || dev->slot != slot)
+			continue;
+		pci_dev_lock(dev);
+		if (dev->subordinate)
+			pci_bus_lock(dev->subordinate);
+	}
+}
+
+/* Unlock devices from the bottom of the tree up */
+static void pci_slot_unlock(struct pci_slot *slot)
+{
+	struct pci_dev *dev;
+
+	list_for_each_entry(dev, &slot->bus->devices, bus_list) {
+		if (!dev->slot || dev->slot != slot)
+			continue;
+		if (dev->subordinate)
+			pci_bus_unlock(dev->subordinate);
+		pci_dev_unlock(dev);
+	}
+}
+
+/* Save and disable devices from the top of the tree down */
+static void pci_bus_save_and_disable(struct pci_bus *bus)
+{
+	struct pci_dev *dev;
+
+	list_for_each_entry(dev, &bus->devices, bus_list) {
+		pci_dev_save_and_disable(dev);
+		if (dev->subordinate)
+			pci_bus_save_and_disable(dev->subordinate);
+	}
+}
+
+/*
+ * Restore devices from top of the tree down - parent bridges need to be
+ * restored before we can get to subordinate devices.
+ */
+static void pci_bus_restore(struct pci_bus *bus)
+{
+	struct pci_dev *dev;
+
+	list_for_each_entry(dev, &bus->devices, bus_list) {
+		pci_dev_restore(dev);
+		if (dev->subordinate)
+			pci_bus_restore(dev->subordinate);
+	}
+}
+
+/* Save and disable devices from the top of the tree down */
+static void pci_slot_save_and_disable(struct pci_slot *slot)
+{
+	struct pci_dev *dev;
+
+	list_for_each_entry(dev, &slot->bus->devices, bus_list) {
+		if (!dev->slot || dev->slot != slot)
+			continue;
+		pci_dev_save_and_disable(dev);
+		if (dev->subordinate)
+			pci_bus_save_and_disable(dev->subordinate);
+	}
+}
+
+/*
+ * Restore devices from top of the tree down - parent bridges need to be
+ * restored before we can get to subordinate devices.
+ */
+static void pci_slot_restore(struct pci_slot *slot)
+{
+	struct pci_dev *dev;
+
+	list_for_each_entry(dev, &slot->bus->devices, bus_list) {
+		if (!dev->slot || dev->slot != slot)
+			continue;
+		pci_dev_restore(dev);
+		if (dev->subordinate)
+			pci_bus_restore(dev->subordinate);
+	}
+}
+
+static int pci_slot_reset(struct pci_slot *slot, int probe)
+{
+	int rc;
+
+	if (!slot)
+		return -ENOTTY;
+
+	if (!probe)
+		pci_slot_lock(slot);
+
+	might_sleep();
+
+	rc = pci_reset_hotplug_slot(slot->hotplug, probe);
+
+	if (!probe)
+		pci_slot_unlock(slot);
+
+	return rc;
+}
+
+/**
+ * pci_reset_slot - reset a PCI slot
+ * @slot: PCI slot to reset
+ *
+ * A PCI bus may host multiple slots, each slot may support a reset mechanism
+ * independent of other slots.  For instance, some slots may support slot power
+ * control.  In the case of a 1:1 bus to slot architecture, this function may
+ * wrap the bus reset to avoid spurious slot related events such as hotplug.
+ * Generally a slot reset should be attempted before a bus reset.  All of the
+ * function of the slot and any subordinate buses behind the slot are reset
+ * through this function.  PCI config space of all devices in the slot and
+ * behind the slot is saved before and restored after reset.
+ *
+ * Return 0 on success, non-zero on error.
+ */
+int pci_reset_slot(struct pci_slot *slot)
+{
+	int rc;
+
+	rc = pci_slot_reset(slot, 1);
+	if (rc)
+		return rc;
+
+	pci_slot_save_and_disable(slot);
+
+	rc = pci_slot_reset(slot, 0);
+
+	pci_slot_restore(slot);
+
+	return rc;
+}
+EXPORT_SYMBOL_GPL(pci_reset_slot);
+
+static int pci_bus_reset(struct pci_bus *bus, int probe)
+{
+	if (!bus->self)
+		return -ENOTTY;
+
+	if (probe)
+		return 0;
+
+	pci_bus_lock(bus);
+
+	might_sleep();
+
+	pci_reset_bridge_secondary_bus(bus->self);
+
+	pci_bus_unlock(bus);
+
+	return 0;
+}
+
+/**
+ * pci_reset_bus - reset a PCI bus
+ * @bus: top level PCI bus to reset
+ *
+ * Do a bus reset on the given bus and any subordinate buses, saving
+ * and restoring state of all devices.
+ *
+ * Return 0 on success, non-zero on error.
+ */
+int pci_reset_bus(struct pci_bus *bus)
+{
+	int rc;
+
+	rc = pci_bus_reset(bus, 1);
+	if (rc)
+		return rc;
+
+	pci_bus_save_and_disable(bus);
+
+	rc = pci_bus_reset(bus, 0);
+
+	pci_bus_restore(bus);
+
+	return rc;
+}
+EXPORT_SYMBOL_GPL(pci_reset_bus);
+
 /**
  * pcix_get_max_mmrbc - get PCI-X maximum designed memory read byte count
  * @dev: PCI device to query

commit 77cb985ad4acbe66a92ead1bb826deffa47dd33f
Author: Alex Williamson <alex.williamson@redhat.com>
Date:   Thu Aug 8 14:09:49 2013 -0600

    PCI: Split out pci_dev lock/unlock and save/restore
    
    Only cosmetic code changes to existing paths.  Expand the comment in
    the new pci_dev_save_and_disable() function since there's a lot
    hidden in that Command register write.
    
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 9407aabc77a3..d48d9febc241 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -3317,22 +3317,49 @@ static int __pci_dev_reset(struct pci_dev *dev, int probe)
 	return rc;
 }
 
+static void pci_dev_lock(struct pci_dev *dev)
+{
+	pci_cfg_access_lock(dev);
+	/* block PM suspend, driver probe, etc. */
+	device_lock(&dev->dev);
+}
+
+static void pci_dev_unlock(struct pci_dev *dev)
+{
+	device_unlock(&dev->dev);
+	pci_cfg_access_unlock(dev);
+}
+
+static void pci_dev_save_and_disable(struct pci_dev *dev)
+{
+	pci_save_state(dev);
+	/*
+	 * Disable the device by clearing the Command register, except for
+	 * INTx-disable which is set.  This not only disables MMIO and I/O port
+	 * BARs, but also prevents the device from being Bus Master, preventing
+	 * DMA from the device including MSI/MSI-X interrupts.  For PCI 2.3
+	 * compliant devices, INTx-disable prevents legacy interrupts.
+	 */
+	pci_write_config_word(dev, PCI_COMMAND, PCI_COMMAND_INTX_DISABLE);
+}
+
+static void pci_dev_restore(struct pci_dev *dev)
+{
+	pci_restore_state(dev);
+}
+
 static int pci_dev_reset(struct pci_dev *dev, int probe)
 {
 	int rc;
 
-	if (!probe) {
-		pci_cfg_access_lock(dev);
-		/* block PM suspend, driver probe, etc. */
-		device_lock(&dev->dev);
-	}
+	if (!probe)
+		pci_dev_lock(dev);
 
 	rc = __pci_dev_reset(dev, probe);
 
-	if (!probe) {
-		device_unlock(&dev->dev);
-		pci_cfg_access_unlock(dev);
-	}
+	if (!probe)
+		pci_dev_unlock(dev);
+
 	return rc;
 }
 /**
@@ -3423,17 +3450,11 @@ int pci_reset_function(struct pci_dev *dev)
 	if (rc)
 		return rc;
 
-	pci_save_state(dev);
-
-	/*
-	 * both INTx and MSI are disabled after the Interrupt Disable bit
-	 * is set and the Bus Master bit is cleared.
-	 */
-	pci_write_config_word(dev, PCI_COMMAND, PCI_COMMAND_INTX_DISABLE);
+	pci_dev_save_and_disable(dev);
 
 	rc = pci_dev_reset(dev, 0);
 
-	pci_restore_state(dev);
+	pci_dev_restore(dev);
 
 	return rc;
 }

commit 608c388122c72e1bf11ba8113434eb3d0c40c32d
Author: Alex Williamson <alex.williamson@redhat.com>
Date:   Thu Aug 8 14:09:43 2013 -0600

    PCI: Add slot reset option to pci_dev_reset()
    
    If the hotplug controller provides a way to reset a slot, use that
    before a direct parent bus reset.  Like the bus reset option, this is
    only available when a single pci_dev occupies the slot.
    
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index d46860898e1f..9407aabc77a3 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -22,6 +22,7 @@
 #include <linux/interrupt.h>
 #include <linux/device.h>
 #include <linux/pm_runtime.h>
+#include <linux/pci_hotplug.h>
 #include <asm-generic/pci-bridge.h>
 #include <asm/setup.h>
 #include "pci.h"
@@ -3256,6 +3257,35 @@ static int pci_parent_bus_reset(struct pci_dev *dev, int probe)
 	return 0;
 }
 
+static int pci_reset_hotplug_slot(struct hotplug_slot *hotplug, int probe)
+{
+	int rc = -ENOTTY;
+
+	if (!hotplug || !try_module_get(hotplug->ops->owner))
+		return rc;
+
+	if (hotplug->ops->reset_slot)
+		rc = hotplug->ops->reset_slot(hotplug, probe);
+
+	module_put(hotplug->ops->owner);
+
+	return rc;
+}
+
+static int pci_dev_reset_slot_function(struct pci_dev *dev, int probe)
+{
+	struct pci_dev *pdev;
+
+	if (dev->subordinate || !dev->slot)
+		return -ENOTTY;
+
+	list_for_each_entry(pdev, &dev->bus->devices, bus_list)
+		if (pdev != dev && pdev->slot == dev->slot)
+			return -ENOTTY;
+
+	return pci_reset_hotplug_slot(dev->slot->hotplug, probe);
+}
+
 static int __pci_dev_reset(struct pci_dev *dev, int probe)
 {
 	int rc;
@@ -3278,6 +3308,10 @@ static int __pci_dev_reset(struct pci_dev *dev, int probe)
 	if (rc != -ENOTTY)
 		goto done;
 
+	rc = pci_dev_reset_slot_function(dev, probe);
+	if (rc != -ENOTTY)
+		goto done;
+
 	rc = pci_parent_bus_reset(dev, probe);
 done:
 	return rc;

commit 63ef41811b86432101b4627ff07c9671f93a483f
Merge: df99d6a4e9a3 4d708ab0c885
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Aug 12 15:07:03 2013 -0600

    Merge branch 'pci/vipul-chelsio-reset-v2' into next
    
    * pci/vipul-chelsio-reset-v2:
      PCI: Use pci_wait_for_pending_transaction() instead of for loop
      bnx2x: Use pci_wait_for_pending_transaction() instead of for loop
      PCI: Chelsio quirk: Enable Bus Master during Function-Level Reset
      PCI: Add pci_wait_for_pending_transaction()

commit 3775a209d38aa3a0c7ed89a7d0f529e0230f280e
Author: Casey Leedom <leedom@chelsio.com>
Date:   Tue Aug 6 15:48:36 2013 +0530

    PCI: Add pci_wait_for_pending_transaction()
    
    New routine to avoid duplication of code to wait for pending PCI
    transactions to complete.
    
    Signed-off-by: Casey Leedom <leedom@chelsio.com>
    Signed-off-by: Vipul Pandya <vipul@chelsio.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index e37fea6e178d..10ab64e8878e 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -3098,19 +3098,17 @@ int pci_set_dma_seg_boundary(struct pci_dev *dev, unsigned long mask)
 }
 EXPORT_SYMBOL(pci_set_dma_seg_boundary);
 
-static int pcie_flr(struct pci_dev *dev, int probe)
+/**
+ * pci_wait_for_pending_transaction - waits for pending transaction
+ * @dev: the PCI device to operate on
+ *
+ * Return 0 if transaction is pending 1 otherwise.
+ */
+int pci_wait_for_pending_transaction(struct pci_dev *dev)
 {
 	int i;
-	u32 cap;
 	u16 status;
 
-	pcie_capability_read_dword(dev, PCI_EXP_DEVCAP, &cap);
-	if (!(cap & PCI_EXP_DEVCAP_FLR))
-		return -ENOTTY;
-
-	if (probe)
-		return 0;
-
 	/* Wait for Transaction Pending bit clean */
 	for (i = 0; i < 4; i++) {
 		if (i)
@@ -3118,13 +3116,27 @@ static int pcie_flr(struct pci_dev *dev, int probe)
 
 		pcie_capability_read_word(dev, PCI_EXP_DEVSTA, &status);
 		if (!(status & PCI_EXP_DEVSTA_TRPND))
-			goto clear;
+			return 1;
 	}
 
-	dev_err(&dev->dev, "transaction is not cleared; "
-			"proceeding with reset anyway\n");
+	return 0;
+}
+EXPORT_SYMBOL(pci_wait_for_pending_transaction);
+
+static int pcie_flr(struct pci_dev *dev, int probe)
+{
+	u32 cap;
+
+	pcie_capability_read_dword(dev, PCI_EXP_DEVCAP, &cap);
+	if (!(cap & PCI_EXP_DEVCAP_FLR))
+		return -ENOTTY;
+
+	if (probe)
+		return 0;
+
+	if (!pci_wait_for_pending_transaction(dev))
+		dev_err(&dev->dev, "transaction is not cleared; proceeding with reset anyway\n");
 
-clear:
 	pcie_capability_set_word(dev, PCI_EXP_DEVCTL, PCI_EXP_DEVCTL_BCR_FLR);
 
 	msleep(100);

commit 64e8674fbe6bc848333a9b7e19f8cc019dde9eab
Author: Alex Williamson <alex.williamson@redhat.com>
Date:   Thu Aug 8 14:09:24 2013 -0600

    PCI: Add pci_reset_bridge_secondary_bus()
    
    Move the secondary bus reset code from pci_parent_bus_reset() into its own
    function.  Export it as we'll later be calling it from hotplug controllers
    and elsewhere.
    
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index e37fea6e178d..d46860898e1f 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -3215,9 +3215,30 @@ static int pci_pm_reset(struct pci_dev *dev, int probe)
 	return 0;
 }
 
-static int pci_parent_bus_reset(struct pci_dev *dev, int probe)
+/**
+ * pci_reset_bridge_secondary_bus - Reset the secondary bus on a PCI bridge.
+ * @dev: Bridge device
+ *
+ * Use the bridge control register to assert reset on the secondary bus.
+ * Devices on the secondary bus are left in power-on state.
+ */
+void pci_reset_bridge_secondary_bus(struct pci_dev *dev)
 {
 	u16 ctrl;
+
+	pci_read_config_word(dev, PCI_BRIDGE_CONTROL, &ctrl);
+	ctrl |= PCI_BRIDGE_CTL_BUS_RESET;
+	pci_write_config_word(dev, PCI_BRIDGE_CONTROL, ctrl);
+	msleep(100);
+
+	ctrl &= ~PCI_BRIDGE_CTL_BUS_RESET;
+	pci_write_config_word(dev, PCI_BRIDGE_CONTROL, ctrl);
+	msleep(100);
+}
+EXPORT_SYMBOL_GPL(pci_reset_bridge_secondary_bus);
+
+static int pci_parent_bus_reset(struct pci_dev *dev, int probe)
+{
 	struct pci_dev *pdev;
 
 	if (pci_is_root_bus(dev->bus) || dev->subordinate || !dev->bus->self)
@@ -3230,14 +3251,7 @@ static int pci_parent_bus_reset(struct pci_dev *dev, int probe)
 	if (probe)
 		return 0;
 
-	pci_read_config_word(dev->bus->self, PCI_BRIDGE_CONTROL, &ctrl);
-	ctrl |= PCI_BRIDGE_CTL_BUS_RESET;
-	pci_write_config_word(dev->bus->self, PCI_BRIDGE_CONTROL, ctrl);
-	msleep(100);
-
-	ctrl &= ~PCI_BRIDGE_CTL_BUS_RESET;
-	pci_write_config_word(dev->bus->self, PCI_BRIDGE_CONTROL, ctrl);
-	msleep(100);
+	pci_reset_bridge_secondary_bus(dev->bus->self);
 
 	return 0;
 }

commit cbe2bb4f2bc14876ab9e1729933a7453ded250d1
Merge: 28fa60a83034 ce1be10bf6dc
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Aug 1 11:03:52 2013 -0600

    Merge branch 'pci/misc' into next
    
    * pci/misc:
      PCI: Fix comment typo for pci_add_cap_save_buffer()
      PCI: Return -ENOSYS for SR-IOV operations on non-SR-IOV devices
      PCI: Update NumVFs register when disabling SR-IOV
      x86/PCI: MMCONFIG: Check earlier for MMCONFIG region at address zero
      PCI: Convert class code to use dev_groups
      frv/PCI: Mark pcibios_fixup_bus() as non-init
      x86/pci/mrst: Cleanup checkpatch.pl warnings
      PCI: Rename "PCI Express support" kconfig title
      PCI: Fix comment typo in iov.c

commit ce1be10bf6dc8406ae773f0ac6265585a4154d37
Author: Yijing Wang <wangyijing@huawei.com>
Date:   Thu Aug 1 21:05:27 2013 +0800

    PCI: Fix comment typo for pci_add_cap_save_buffer()
    
    Fix trivial comment typo for pci_add_cap_save_buffer().
    
    Signed-off-by: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index e37fea6e178d..69dcd32e0fe8 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1992,7 +1992,7 @@ static void pci_add_saved_cap(struct pci_dev *pci_dev,
 }
 
 /**
- * pci_add_save_buffer - allocate buffer for saving given capability registers
+ * pci_add_cap_save_buffer - allocate buffer for saving given capability registers
  * @dev: the PCI device
  * @cap: the capability to allocate the buffer for
  * @size: requested size of the buffer

commit 81377c8d3563e7aec5c8baaaacacb48034f430a0
Author: Jacob Keller <jacob.e.keller@intel.com>
Date:   Wed Jul 31 06:53:26 2013 +0000

    PCI: Add function to obtain minimum link width and speed
    
    A PCI Express device can potentially report a link width and speed which it will
    not properly fulfill due to being plugged into a slower link higher in the
    chain. This function walks up the PCI bus chain and calculates the minimum link
    width and speed of this entire chain. This can be useful to enable a device to
    determine if it has enough bandwidth for optimum functionality.
    
    Signed-off-by: Jacob Keller <jacob.e.keller@intel.com>
    Tested-by: Phil Schmitt <phillip.j.schmitt@intel.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index e37fea6e178d..c71e78c46705 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -3578,6 +3578,49 @@ int pcie_set_mps(struct pci_dev *dev, int mps)
 						  PCI_EXP_DEVCTL_PAYLOAD, v);
 }
 
+/**
+ * pcie_get_minimum_link - determine minimum link settings of a PCI device
+ * @dev: PCI device to query
+ * @speed: storage for minimum speed
+ * @width: storage for minimum width
+ *
+ * This function will walk up the PCI device chain and determine the minimum
+ * link width and speed of the device.
+ */
+int pcie_get_minimum_link(struct pci_dev *dev, enum pci_bus_speed *speed,
+			  enum pcie_link_width *width)
+{
+	int ret;
+
+	*speed = PCI_SPEED_UNKNOWN;
+	*width = PCIE_LNK_WIDTH_UNKNOWN;
+
+	while (dev) {
+		u16 lnksta;
+		enum pci_bus_speed next_speed;
+		enum pcie_link_width next_width;
+
+		ret = pcie_capability_read_word(dev, PCI_EXP_LNKSTA, &lnksta);
+		if (ret)
+			return ret;
+
+		next_speed = pcie_link_speed[lnksta & PCI_EXP_LNKSTA_CLS];
+		next_width = (lnksta & PCI_EXP_LNKSTA_NLW) >>
+			PCI_EXP_LNKSTA_NLW_SHIFT;
+
+		if (next_speed < *speed)
+			*speed = next_speed;
+
+		if (next_width < *width)
+			*width = next_width;
+
+		dev = dev->bus->self;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(pcie_get_minimum_link);
+
 /**
  * pci_select_bars - Make BAR mask from the type of resource
  * @dev: the PCI device for which BAR mask is made

commit 928bea964827d7824b548c1f8e06eccbbc4d0d7d
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Mon Jul 22 14:37:17 2013 -0700

    PCI: Delay enabling bridges until they're needed
    
    We currently enable PCI bridges after scanning a bus and assigning
    resources.  This is often done in arch code.
    
    This patch changes this so we don't enable a bridge until necessary, i.e.,
    until we enable a PCI device behind the bridge.  We do this in the generic
    pci_enable_device() path, so this also removes the arch-specific code to
    enable bridges.
    
    [bhelgaas: changelog]
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index e37fea6e178d..44a1a8a0ad7b 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1145,6 +1145,24 @@ int pci_reenable_device(struct pci_dev *dev)
 	return 0;
 }
 
+static void pci_enable_bridge(struct pci_dev *dev)
+{
+	int retval;
+
+	if (!dev)
+		return;
+
+	pci_enable_bridge(dev->bus->self);
+
+	if (pci_is_enabled(dev))
+		return;
+	retval = pci_enable_device(dev);
+	if (retval)
+		dev_err(&dev->dev, "Error enabling bridge (%d), continuing\n",
+			retval);
+	pci_set_master(dev);
+}
+
 static int pci_enable_device_flags(struct pci_dev *dev, unsigned long flags)
 {
 	int err;
@@ -1165,6 +1183,8 @@ static int pci_enable_device_flags(struct pci_dev *dev, unsigned long flags)
 	if (atomic_inc_return(&dev->enable_cnt) > 1)
 		return 0;		/* already enabled */
 
+	pci_enable_bridge(dev->bus->self);
+
 	/* only skip sriov related */
 	for (i = 0; i <= PCI_ROM_RESOURCE; i++)
 		if (dev->resource[i].flags & flags)

commit 83db7e0bdb70a9bb93cd000fefc3fbac3394f516
Author: Alex Williamson <alex.williamson@redhat.com>
Date:   Thu Jun 27 16:39:54 2013 -0600

    PCI: Differentiate ACS controllable from enabled
    
    We currently misinterpret that in order for an ACS feature to be
    enabled it must be set in the control field.  In reality, this means
    that the feature is not only enabled, but controllable.  Many of the
    ACS capability bits are not required if the device behaves by default
    in the way specified when both the capability and control bit are set
    and does not support or allow the alternate mode.  We therefore need
    to check the capabilities and mask out flags that are enabled but not
    controllable.  Egress control seems to be the only flag which is
    purely optional.
    
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Donald Dutile <ddutile@redhat.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 3c1ff63aa56d..a599a6bbdf37 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2362,12 +2362,20 @@ void pci_enable_acs(struct pci_dev *dev)
 static bool pci_acs_flags_enabled(struct pci_dev *pdev, u16 acs_flags)
 {
 	int pos;
-	u16 ctrl;
+	u16 cap, ctrl;
 
 	pos = pci_find_ext_capability(pdev, PCI_EXT_CAP_ID_ACS);
 	if (!pos)
 		return false;
 
+	/*
+	 * Except for egress control, capabilities are either required
+	 * or only required if controllable.  Features missing from the
+	 * capability field can therefore be assumed as hard-wired enabled.
+	 */
+	pci_read_config_word(pdev, pos + PCI_ACS_CAP, &cap);
+	acs_flags &= (cap | PCI_ACS_EC);
+
 	pci_read_config_word(pdev, pos + PCI_ACS_CTRL, &ctrl);
 	return (ctrl & acs_flags) == acs_flags;
 }
@@ -2442,9 +2450,6 @@ bool pci_acs_enabled(struct pci_dev *pdev, u16 acs_flags)
 		if (!pdev->multifunction)
 			break;
 
-		acs_flags &= (PCI_ACS_RR | PCI_ACS_CR |
-			      PCI_ACS_EC | PCI_ACS_DT);
-
 		return pci_acs_flags_enabled(pdev, acs_flags);
 	}
 

commit 0a67119fce8e0246ce7c448e3db12afd57857ac0
Author: Alex Williamson <alex.williamson@redhat.com>
Date:   Thu Jun 27 16:39:48 2013 -0600

    PCI: Check all ACS features for multifunction downstream ports
    
    The multifunction ACS rules do not apply to downstream ports.  Those
    should be tested regardless of whether they are single function or
    multifunction.  The PCIe spec also fully specifies which PCIe types
    are subject to the multifunction rules and excludes event collectors
    and PCIe-to-PCI bridges entirely.  Document each rule to the section
    of the PCIe spec and provide overall documentation of the function.
    
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Donald Dutile <ddutile@redhat.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index e37fea6e178d..3c1ff63aa56d 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2359,6 +2359,19 @@ void pci_enable_acs(struct pci_dev *dev)
 	pci_write_config_word(dev, pos + PCI_ACS_CTRL, ctrl);
 }
 
+static bool pci_acs_flags_enabled(struct pci_dev *pdev, u16 acs_flags)
+{
+	int pos;
+	u16 ctrl;
+
+	pos = pci_find_ext_capability(pdev, PCI_EXT_CAP_ID_ACS);
+	if (!pos)
+		return false;
+
+	pci_read_config_word(pdev, pos + PCI_ACS_CTRL, &ctrl);
+	return (ctrl & acs_flags) == acs_flags;
+}
+
 /**
  * pci_acs_enabled - test ACS against required flags for a given device
  * @pdev: device to test
@@ -2366,36 +2379,79 @@ void pci_enable_acs(struct pci_dev *dev)
  *
  * Return true if the device supports the provided flags.  Automatically
  * filters out flags that are not implemented on multifunction devices.
+ *
+ * Note that this interface checks the effective ACS capabilities of the
+ * device rather than the actual capabilities.  For instance, most single
+ * function endpoints are not required to support ACS because they have no
+ * opportunity for peer-to-peer access.  We therefore return 'true'
+ * regardless of whether the device exposes an ACS capability.  This makes
+ * it much easier for callers of this function to ignore the actual type
+ * or topology of the device when testing ACS support.
  */
 bool pci_acs_enabled(struct pci_dev *pdev, u16 acs_flags)
 {
-	int pos, ret;
-	u16 ctrl;
+	int ret;
 
 	ret = pci_dev_specific_acs_enabled(pdev, acs_flags);
 	if (ret >= 0)
 		return ret > 0;
 
+	/*
+	 * Conventional PCI and PCI-X devices never support ACS, either
+	 * effectively or actually.  The shared bus topology implies that
+	 * any device on the bus can receive or snoop DMA.
+	 */
 	if (!pci_is_pcie(pdev))
 		return false;
 
-	/* Filter out flags not applicable to multifunction */
-	if (pdev->multifunction)
+	switch (pci_pcie_type(pdev)) {
+	/*
+	 * PCI/X-to-PCIe bridges are not specifically mentioned by the spec,
+	 * but since their primary inteface is PCI/X, we conservatively
+	 * handle them as we would a non-PCIe device.
+	 */
+	case PCI_EXP_TYPE_PCIE_BRIDGE:
+	/*
+	 * PCIe 3.0, 6.12.1 excludes ACS on these devices.  "ACS is never
+	 * applicable... must never implement an ACS Extended Capability...".
+	 * This seems arbitrary, but we take a conservative interpretation
+	 * of this statement.
+	 */
+	case PCI_EXP_TYPE_PCI_BRIDGE:
+	case PCI_EXP_TYPE_RC_EC:
+		return false;
+	/*
+	 * PCIe 3.0, 6.12.1.1 specifies that downstream and root ports should
+	 * implement ACS in order to indicate their peer-to-peer capabilities,
+	 * regardless of whether they are single- or multi-function devices.
+	 */
+	case PCI_EXP_TYPE_DOWNSTREAM:
+	case PCI_EXP_TYPE_ROOT_PORT:
+		return pci_acs_flags_enabled(pdev, acs_flags);
+	/*
+	 * PCIe 3.0, 6.12.1.2 specifies ACS capabilities that should be
+	 * implemented by the remaining PCIe types to indicate peer-to-peer
+	 * capabilities, but only when they are part of a multifunciton
+	 * device.  The footnote for section 6.12 indicates the specific
+	 * PCIe types included here.
+	 */
+	case PCI_EXP_TYPE_ENDPOINT:
+	case PCI_EXP_TYPE_UPSTREAM:
+	case PCI_EXP_TYPE_LEG_END:
+	case PCI_EXP_TYPE_RC_END:
+		if (!pdev->multifunction)
+			break;
+
 		acs_flags &= (PCI_ACS_RR | PCI_ACS_CR |
 			      PCI_ACS_EC | PCI_ACS_DT);
 
-	if (pci_pcie_type(pdev) == PCI_EXP_TYPE_DOWNSTREAM ||
-	    pci_pcie_type(pdev) == PCI_EXP_TYPE_ROOT_PORT ||
-	    pdev->multifunction) {
-		pos = pci_find_ext_capability(pdev, PCI_EXT_CAP_ID_ACS);
-		if (!pos)
-			return false;
-
-		pci_read_config_word(pdev, pos + PCI_ACS_CTRL, &ctrl);
-		if ((ctrl & acs_flags) != acs_flags)
-			return false;
+		return pci_acs_flags_enabled(pdev, acs_flags);
 	}
 
+	/*
+	 * PCIe 3.0, 6.12.1.3 specifies no ACS capabilties are applicable
+	 * to single function devices with the exception of downstream ports.
+	 */
 	return true;
 }
 

commit 728cdb7582a230234795619036d887d7f52bce1e
Author: Yijing Wang <wangyijing@huawei.com>
Date:   Tue Jun 18 16:22:14 2013 +0800

    PCI: Use pdev->pm_cap instead of pci_find_capability(..,PCI_CAP_ID_PM)
    
    PCI PM cap register offset has been saved in pci_pm_init(),
    so we can use pdev->pm_cap instead of using pci_find_capability(..)
    here.
    
    Signed-off-by: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 709791b70ca0..e37fea6e178d 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -805,7 +805,7 @@ pci_power_t pci_choose_state(struct pci_dev *dev, pm_message_t state)
 {
 	pci_power_t ret;
 
-	if (!pci_find_capability(dev, PCI_CAP_ID_PM))
+	if (!dev->pm_cap)
 		return PCI_D0;
 
 	ret = platform_pci_choose_state(dev);

commit 6ae32c539c0412ca789fb6041be45eeabf78431c
Author: Sebastian Ott <sebott@linux.vnet.ibm.com>
Date:   Tue Jun 4 19:18:14 2013 +0200

    PCI: Add pcibios_release_device()
    
    Platforms may want to provide architecture-specific functionality when
    a PCI device is released.  Add a pcibios_release_device() call that
    architectures can override to do so.
    
    Signed-off-by: Sebastian Ott <sebott@linux.vnet.ibm.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index e5f4e55d407d..709791b70ca0 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1334,6 +1334,16 @@ int __weak pcibios_add_device (struct pci_dev *dev)
 	return 0;
 }
 
+/**
+ * pcibios_release_device - provide arch specific hooks when releasing device dev
+ * @dev: the PCI device being released
+ *
+ * Permits the platform to provide architecture specific functionality when
+ * devices are released. This is the default implementation. Architecture
+ * implementations can override this.
+ */
+void __weak pcibios_release_device(struct pci_dev *dev) {}
+
 /**
  * pcibios_disable_device - disable arch specific PCI resources for device dev
  * @dev: the PCI device to disable

commit bb5c2de268f0d01fb3bb7683037d9b2bebcba3d5
Author: Wang Sheng-Hui <shhuiw@gmail.com>
Date:   Tue May 28 11:17:41 2013 +0800

    PCI: Fix INTC comment typo for pci_swizzle_interrupt_pin()
    
    The INTx pin should be INIT[ABCD].  Fix the typo "3=INTC".
    
    Signed-off-by: Wang Sheng-Hui <shhuiw@gmail.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index a899d8bb190d..e5f4e55d407d 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2421,7 +2421,7 @@ bool pci_acs_path_enabled(struct pci_dev *start,
 /**
  * pci_swizzle_interrupt_pin - swizzle INTx for device behind bridge
  * @dev: the PCI device
- * @pin: the INTx pin (1=INTA, 2=INTB, 3=INTD, 4=INTD)
+ * @pin: the INTx pin (1=INTA, 2=INTB, 3=INTC, 4=INTD)
  *
  * Perform INTx swizzling for a device behind one level of bridge.  This is
  * required by section 9.1 of the PCI-to-PCI bridge specification for devices

commit 42c34707f9d24ef159cce87e4353babcf2b417a6
Merge: 723ec4d06cb2 ffaddbe8f925
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Apr 17 10:43:16 2013 -0600

    Merge branch 'pci/rafael-pm' into next
    
    * pci/rafael-pm:
      PCI/PM: Make pci_pme_active() ignore devices without PME support
      PCI/PM: Fix fallback to PCI_D0 in pci_platform_power_transition()

commit ffaddbe8f925a4f41eecb31e7fe69a9bdb6e2e59
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Apr 10 10:32:51 2013 +0000

    PCI/PM: Make pci_pme_active() ignore devices without PME support
    
    Make pci_pme_active() ignore devices without PME support, so that
    it doesn't print the "PME enabled" or "PME disabled" debug messages
    for devices that don't support PME.
    
    So that pci_pme_active() doesn't have to check pm_cap in addition
    to pme_support, make pci_pm_init() clear pme_support upfront to
    make sure that it will be 0 for pm_cap equal to 0.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index fc9bd81e8e3b..a5e0e5f4953c 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1571,7 +1571,7 @@ void pci_pme_active(struct pci_dev *dev, bool enable)
 {
 	u16 pmcsr;
 
-	if (!dev->pm_cap)
+	if (!dev->pme_support)
 		return;
 
 	pci_read_config_word(dev, dev->pm_cap + PCI_PM_CTRL, &pmcsr);
@@ -1920,6 +1920,7 @@ void pci_pm_init(struct pci_dev *dev)
 	dev->wakeup_prepared = false;
 
 	dev->pm_cap = 0;
+	dev->pme_support = 0;
 
 	/* find PCI PM capability in list */
 	pm = pci_find_capability(dev, PCI_CAP_ID_PM);
@@ -1971,8 +1972,6 @@ void pci_pm_init(struct pci_dev *dev)
 		device_set_wakeup_capable(&dev->dev, true);
 		/* Disable the PME# generation functionality */
 		pci_pme_active(dev, false);
-	} else {
-		dev->pme_support = 0;
 	}
 }
 

commit 769ba7212f2059ca9fe0c73371e3d415c8c1c529
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Apr 12 13:58:17 2013 +0000

    PCI/PM: Fix fallback to PCI_D0 in pci_platform_power_transition()
    
    Commit b51306c (PCI: Set device power state to PCI_D0 for device
    without native PM support) modified pci_platform_power_transition()
    by adding code causing dev->current_state for devices that don't
    support native PCI PM but are power-manageable by the platform to be
    changed to PCI_D0 regardless of the value returned by the preceding
    platform_pci_set_power_state().  In particular, that also is done
    if the platform_pci_set_power_state() has been successful, which
    causes the correct power state of the device set by
    pci_update_current_state() in that case to be overwritten by PCI_D0.
    
    Fix that mistake by making the fallback to PCI_D0 only happen if
    the platform_pci_set_power_state() has returned an error.
    
    [bhelgaas: folded in Yinghai's simplification, added URL & stable info]
    Reference: http://lkml.kernel.org/r/27806FC4E5928A408B78E88BBC67A2306F466BBA@ORSMSX101.amr.corp.intel.com
    Reported-by: Chris J. Benenati <chris.j.benenati@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>
    Cc: <stable@vger.kernel.org>    # v3.2+

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index b099e0025d2b..fc9bd81e8e3b 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -646,15 +646,11 @@ static int pci_platform_power_transition(struct pci_dev *dev, pci_power_t state)
 		error = platform_pci_set_power_state(dev, state);
 		if (!error)
 			pci_update_current_state(dev, state);
-		/* Fall back to PCI_D0 if native PM is not supported */
-		if (!dev->pm_cap)
-			dev->current_state = PCI_D0;
-	} else {
+	} else
 		error = -ENODEV;
-		/* Fall back to PCI_D0 if native PM is not supported */
-		if (!dev->pm_cap)
-			dev->current_state = PCI_D0;
-	}
+
+	if (error && !dev->pm_cap) /* Fall back to PCI_D0 */
+		dev->current_state = PCI_D0;
 
 	return error;
 }

commit 9738abedd6721926dfb25fe6912be207b7168d03
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Apr 12 11:20:03 2013 -0600

    PCI: Make local functions/structs static
    
    This fixes "no previous prototype" warnings found via "make W=1".
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index b099e0025d2b..f0ef3997ed3b 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2619,7 +2619,7 @@ void pci_release_selected_regions(struct pci_dev *pdev, int bars)
 			pci_release_region(pdev, i);
 }
 
-int __pci_request_selected_regions(struct pci_dev *pdev, int bars,
+static int __pci_request_selected_regions(struct pci_dev *pdev, int bars,
 				 const char *res_name, int excl)
 {
 	int i;
@@ -3699,7 +3699,7 @@ static DEFINE_SPINLOCK(resource_alignment_lock);
  * RETURNS: Resource alignment if it is specified.
  *          Zero if it is not specified.
  */
-resource_size_t pci_specified_resource_alignment(struct pci_dev *dev)
+static resource_size_t pci_specified_resource_alignment(struct pci_dev *dev)
 {
 	int seg, bus, slot, func, align_order, count;
 	resource_size_t align = 0;
@@ -3812,7 +3812,7 @@ void pci_reassigndev_resource_alignment(struct pci_dev *dev)
 	}
 }
 
-ssize_t pci_set_resource_alignment_param(const char *buf, size_t count)
+static ssize_t pci_set_resource_alignment_param(const char *buf, size_t count)
 {
 	if (count > RESOURCE_ALIGNMENT_PARAM_SIZE - 1)
 		count = RESOURCE_ALIGNMENT_PARAM_SIZE - 1;
@@ -3823,7 +3823,7 @@ ssize_t pci_set_resource_alignment_param(const char *buf, size_t count)
 	return count;
 }
 
-ssize_t pci_get_resource_alignment_param(char *buf, size_t size)
+static ssize_t pci_get_resource_alignment_param(char *buf, size_t size)
 {
 	size_t count;
 	spin_lock(&resource_alignment_lock);

commit b67bfe0d42cac56c512dd5da4b1b347a23f4b70a
Author: Sasha Levin <sasha.levin@oracle.com>
Date:   Wed Feb 27 17:06:00 2013 -0800

    hlist: drop the node parameter from iterators
    
    I'm not sure why, but the hlist for each entry iterators were conceived
    
            list_for_each_entry(pos, head, member)
    
    The hlist ones were greedy and wanted an extra parameter:
    
            hlist_for_each_entry(tpos, pos, head, member)
    
    Why did they need an extra pos parameter? I'm not quite sure. Not only
    they don't really need it, it also prevents the iterator from looking
    exactly like the list iterator, which is unfortunate.
    
    Besides the semantic patch, there was some manual work required:
    
     - Fix up the actual hlist iterators in linux/list.h
     - Fix up the declaration of other iterators based on the hlist ones.
     - A very small amount of places were using the 'node' parameter, this
     was modified to use 'obj->member' instead.
     - Coccinelle didn't handle the hlist_for_each_entry_safe iterator
     properly, so those had to be fixed up manually.
    
    The semantic patch which is mostly the work of Peter Senna Tschudin is here:
    
    @@
    iterator name hlist_for_each_entry, hlist_for_each_entry_continue, hlist_for_each_entry_from, hlist_for_each_entry_rcu, hlist_for_each_entry_rcu_bh, hlist_for_each_entry_continue_rcu_bh, for_each_busy_worker, ax25_uid_for_each, ax25_for_each, inet_bind_bucket_for_each, sctp_for_each_hentry, sk_for_each, sk_for_each_rcu, sk_for_each_from, sk_for_each_safe, sk_for_each_bound, hlist_for_each_entry_safe, hlist_for_each_entry_continue_rcu, nr_neigh_for_each, nr_neigh_for_each_safe, nr_node_for_each, nr_node_for_each_safe, for_each_gfn_indirect_valid_sp, for_each_gfn_sp, for_each_host;
    
    type T;
    expression a,c,d,e;
    identifier b;
    statement S;
    @@
    
    -T b;
        <+... when != b
    (
    hlist_for_each_entry(a,
    - b,
    c, d) S
    |
    hlist_for_each_entry_continue(a,
    - b,
    c) S
    |
    hlist_for_each_entry_from(a,
    - b,
    c) S
    |
    hlist_for_each_entry_rcu(a,
    - b,
    c, d) S
    |
    hlist_for_each_entry_rcu_bh(a,
    - b,
    c, d) S
    |
    hlist_for_each_entry_continue_rcu_bh(a,
    - b,
    c) S
    |
    for_each_busy_worker(a, c,
    - b,
    d) S
    |
    ax25_uid_for_each(a,
    - b,
    c) S
    |
    ax25_for_each(a,
    - b,
    c) S
    |
    inet_bind_bucket_for_each(a,
    - b,
    c) S
    |
    sctp_for_each_hentry(a,
    - b,
    c) S
    |
    sk_for_each(a,
    - b,
    c) S
    |
    sk_for_each_rcu(a,
    - b,
    c) S
    |
    sk_for_each_from
    -(a, b)
    +(a)
    S
    + sk_for_each_from(a) S
    |
    sk_for_each_safe(a,
    - b,
    c, d) S
    |
    sk_for_each_bound(a,
    - b,
    c) S
    |
    hlist_for_each_entry_safe(a,
    - b,
    c, d, e) S
    |
    hlist_for_each_entry_continue_rcu(a,
    - b,
    c) S
    |
    nr_neigh_for_each(a,
    - b,
    c) S
    |
    nr_neigh_for_each_safe(a,
    - b,
    c, d) S
    |
    nr_node_for_each(a,
    - b,
    c) S
    |
    nr_node_for_each_safe(a,
    - b,
    c, d) S
    |
    - for_each_gfn_sp(a, c, d, b) S
    + for_each_gfn_sp(a, c, d) S
    |
    - for_each_gfn_indirect_valid_sp(a, c, d, b) S
    + for_each_gfn_indirect_valid_sp(a, c, d) S
    |
    for_each_host(a,
    - b,
    c) S
    |
    for_each_host_safe(a,
    - b,
    c, d) S
    |
    for_each_mesh_entry(a,
    - b,
    c, d) S
    )
        ...+>
    
    [akpm@linux-foundation.org: drop bogus change from net/ipv4/raw.c]
    [akpm@linux-foundation.org: drop bogus hunk from net/ipv6/raw.c]
    [akpm@linux-foundation.org: checkpatch fixes]
    [akpm@linux-foundation.org: fix warnings]
    [akpm@linux-foudnation.org: redo intrusive kvm changes]
    Tested-by: Peter Senna Tschudin <peter.senna@gmail.com>
    Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Signed-off-by: Sasha Levin <sasha.levin@oracle.com>
    Cc: Wu Fengguang <fengguang.wu@intel.com>
    Cc: Marcelo Tosatti <mtosatti@redhat.com>
    Cc: Gleb Natapov <gleb@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 924e4665bd57..b099e0025d2b 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -842,9 +842,8 @@ static struct pci_cap_saved_state *pci_find_saved_cap(
 	struct pci_dev *pci_dev, char cap)
 {
 	struct pci_cap_saved_state *tmp;
-	struct hlist_node *pos;
 
-	hlist_for_each_entry(tmp, pos, &pci_dev->saved_cap_space, next) {
+	hlist_for_each_entry(tmp, &pci_dev->saved_cap_space, next) {
 		if (tmp->cap.cap_nr == cap)
 			return tmp;
 	}
@@ -1041,7 +1040,6 @@ struct pci_saved_state *pci_store_saved_state(struct pci_dev *dev)
 	struct pci_saved_state *state;
 	struct pci_cap_saved_state *tmp;
 	struct pci_cap_saved_data *cap;
-	struct hlist_node *pos;
 	size_t size;
 
 	if (!dev->state_saved)
@@ -1049,7 +1047,7 @@ struct pci_saved_state *pci_store_saved_state(struct pci_dev *dev)
 
 	size = sizeof(*state) + sizeof(struct pci_cap_saved_data);
 
-	hlist_for_each_entry(tmp, pos, &dev->saved_cap_space, next)
+	hlist_for_each_entry(tmp, &dev->saved_cap_space, next)
 		size += sizeof(struct pci_cap_saved_data) + tmp->cap.size;
 
 	state = kzalloc(size, GFP_KERNEL);
@@ -1060,7 +1058,7 @@ struct pci_saved_state *pci_store_saved_state(struct pci_dev *dev)
 	       sizeof(state->config_space));
 
 	cap = state->cap;
-	hlist_for_each_entry(tmp, pos, &dev->saved_cap_space, next) {
+	hlist_for_each_entry(tmp, &dev->saved_cap_space, next) {
 		size_t len = sizeof(struct pci_cap_saved_data) + tmp->cap.size;
 		memcpy(cap, &tmp->cap, len);
 		cap = (struct pci_cap_saved_data *)((u8 *)cap + len);
@@ -2038,9 +2036,9 @@ void pci_allocate_cap_save_buffers(struct pci_dev *dev)
 void pci_free_cap_save_buffers(struct pci_dev *dev)
 {
 	struct pci_cap_saved_state *tmp;
-	struct hlist_node *pos, *n;
+	struct hlist_node *n;
 
-	hlist_for_each_entry_safe(tmp, pos, n, &dev->saved_cap_space, next)
+	hlist_for_each_entry_safe(tmp, n, &dev->saved_cap_space, next)
 		kfree(tmp);
 }
 

commit 20f24208f631141bafe57ce5bcc8f2e7f3c41aae
Merge: f2dfcde4ccd1 82fee4d67ab8
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Feb 12 13:42:36 2013 -0700

    Merge branch 'pci/konstantin-runtime-pm' into next
    
    * pci/konstantin-runtime-pm:
      PCI/PM: Clear state_saved during suspend
      PCI: Use atomic_inc_return() rather than atomic_add_return()
      PCI: Catch attempts to disable already-disabled devices
      PCI: Disable Bus Master unconditionally in pci_device_shutdown()

commit cc7ba39bab126339d6d525ada07dea5633d71521
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Feb 11 16:47:01 2013 -0700

    PCI: Use atomic_inc_return() rather than atomic_add_return()
    
    No functional change; just use atomic_inc_return() rather than the
    general-purpose atomic_add_return().
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 29a09b705f04..c746b04afd6a 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1174,7 +1174,7 @@ static int __pci_enable_device_flags(struct pci_dev *dev,
 		dev->current_state = (pmcsr & PCI_PM_CTRL_STATE_MASK);
 	}
 
-	if (atomic_add_return(1, &dev->enable_cnt) > 1)
+	if (atomic_inc_return(&dev->enable_cnt) > 1)
 		return 0;		/* already enabled */
 
 	/* only skip sriov related */
@@ -1404,7 +1404,7 @@ pci_disable_device(struct pci_dev *dev)
 	dev_WARN_ONCE(&dev->dev, atomic_read(&dev->enable_cnt) <= 0,
 		      "disabling already-disabled device");
 
-	if (atomic_sub_return(1, &dev->enable_cnt) != 0)
+	if (atomic_dec_return(&dev->enable_cnt) != 0)
 		return;
 
 	do_pci_disable_device(dev);

commit fd6dceab017e6be6c158dc56ec6dacf817f21a5b
Author: Konstantin Khlebnikov <khlebnikov@openvz.org>
Date:   Mon Feb 4 15:56:01 2013 +0400

    PCI: Catch attempts to disable already-disabled devices
    
    Warn when disabling a device that has already been disabled.
    
    [bhelgaas: message wording]
    Signed-off-by: Konstantin Khlebnikov <khlebnikov@openvz.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 5cb5820fae40..29a09b705f04 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1401,6 +1401,9 @@ pci_disable_device(struct pci_dev *dev)
 	if (dr)
 		dr->enabled = 0;
 
+	dev_WARN_ONCE(&dev->dev, atomic_read(&dev->enable_cnt) <= 0,
+		      "disabling already-disabled device");
+
 	if (atomic_sub_return(1, &dev->enable_cnt) != 0)
 		return;
 

commit f2dfcde4ccd101fa3ba8f6c27273a0e359ea9c9c
Merge: ecb87e6609d3 775c739e0b08
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Sat Feb 2 14:35:57 2013 -0700

    Merge branch 'pci/misc' into next
    
    * pci/misc:
      PCI: pciehp: Drop suspend/resume ENTRY messages
      PCI: Document MPS parameters pci=pcie_bus_safe, pci=pcie_bus_perf, etc
      PCI: Document hpiosize= and hpmemsize= resource reservation parameters
      PCI: Use PCI Express Capability accessor
      PCI: Introduce accessor to retrieve PCIe Capabilities Register
      PCI: Kill pci_is_reassigndev()

commit 14b5cb37cc6172a54ce920c61784f44422ae306d
Merge: 708b59bfe1d1 fcbed0bcb216
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Sat Jan 26 17:27:36 2013 -0700

    Merge branch 'pci/yijing-ari' into next
    
    * pci/yijing-ari:
      PCI: shpchp: Iterate over all devices in slot, not functions 0-7
      PCI: sgihp: Iterate over all devices in slot, not functions 0-7
      PCI: cpcihp: Iterate over all devices in slot, not functions 0-7
      PCI: pciehp: Iterate over all devices in slot, not functions 0-7
      PCI: Consolidate "next-function" functions
      PCI: Rename pci_enable_ari() to pci_configure_ari()
      PCI: Enable ARI if dev and upstream bridge support it; disable otherwise

commit 31ab247623c541d56b39a0b792cdfe4e94dd2a45
Author: Yijing Wang <wangyijing@huawei.com>
Date:   Tue Jan 15 11:12:17 2013 +0800

    PCI: Rename pci_enable_ari() to pci_configure_ari()
    
    pci_enable_ari() now supports enabling or disabling ARI forwarding.  So
    rename pci_enable_ari() to pci_configure_ari() for easy understanding.
    
    No functional change.
    
    [bhelgaas: changelog]
    Signed-off-by: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 8b47f70b7d8f..66eefefbe0c5 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2067,13 +2067,13 @@ void pci_free_cap_save_buffers(struct pci_dev *dev)
 }
 
 /**
- * pci_enable_ari - enable ARI forwarding if hardware support it
+ * pci_configure_ari - enable or disable ARI forwarding
  * @dev: the PCI device
  *
  * If @dev and its upstream bridge both support ARI, enable ARI in the
  * bridge.  Otherwise, disable ARI in the bridge.
  */
-void pci_enable_ari(struct pci_dev *dev)
+void pci_configure_ari(struct pci_dev *dev)
 {
 	u32 cap;
 	struct pci_dev *bridge;

commit 10c463a7a3b96285133c37e230781a1274abbd31
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Sun Mar 18 22:46:26 2012 -0700

    PCI: Kill pci_is_reassigndev()
    
    pci_reassigndev_resource_alignment() is the only user of
    pci_is_reassigndev().  If we just use pci_specified_resource_alignment()
    directly, we only need to call it once instead of twice, and we can get
    rid of pci_is_reassigndev() altogether.  No functional change.
    
    [bhelgaas: changelog]
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index a2f30394c091..11c36654c95d 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -3765,18 +3765,6 @@ resource_size_t pci_specified_resource_alignment(struct pci_dev *dev)
 	return align;
 }
 
-/**
- * pci_is_reassigndev - check if specified PCI is target device to reassign
- * @dev: the PCI device to check
- *
- * RETURNS: non-zero for PCI device is a target device to reassign,
- *          or zero is not.
- */
-int pci_is_reassigndev(struct pci_dev *dev)
-{
-	return (pci_specified_resource_alignment(dev) != 0);
-}
-
 /*
  * This function disables memory decoding and releases memory resources
  * of the device specified by kernel's boot parameter 'pci=resource_alignment='.
@@ -3791,7 +3779,9 @@ void pci_reassigndev_resource_alignment(struct pci_dev *dev)
 	resource_size_t align, size;
 	u16 command;
 
-	if (!pci_is_reassigndev(dev))
+	/* check if specified PCI is target device to reassign */
+	align = pci_specified_resource_alignment(dev);
+	if (!align)
 		return;
 
 	if (dev->hdr_type == PCI_HEADER_TYPE_NORMAL &&
@@ -3807,7 +3797,6 @@ void pci_reassigndev_resource_alignment(struct pci_dev *dev)
 	command &= ~PCI_COMMAND_MEMORY;
 	pci_write_config_word(dev, PCI_COMMAND, command);
 
-	align = pci_specified_resource_alignment(dev);
 	for (i = 0; i < PCI_BRIDGE_RESOURCES; i++) {
 		r = &dev->resource[i];
 		if (!(r->flags & IORESOURCE_MEM))

commit b0cc6020e1cc62f1253215f189611b34be4a83c7
Author: Yijing Wang <wangyijing@huawei.com>
Date:   Tue Jan 15 11:12:16 2013 +0800

    PCI: Enable ARI if dev and upstream bridge support it; disable otherwise
    
    Currently, we enable ARI in a device's upstream bridge if the bridge and
    the device support it.  But we never disable ARI, even if the device is
    removed and replaced with a device that doesn't support ARI.
    
    This means that if we hot-remove an ARI device and replace it with a
    non-ARI multi-function device, we find only function 0 of the new device
    because the upstream bridge still has ARI enabled, and next_ari_fn()
    only returns function 0 for the new non-ARI device.
    
    This patch disables ARI in the upstream bridge if the device doesn't
    support ARI.  See the PCIe spec, r3.0, sec 6.13.
    
    [bhelgaas: changelog, function comment]
    Signed-off-by: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Jiang Liu <jiang.liu@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 5cb5820fae40..8b47f70b7d8f 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2069,6 +2069,9 @@ void pci_free_cap_save_buffers(struct pci_dev *dev)
 /**
  * pci_enable_ari - enable ARI forwarding if hardware support it
  * @dev: the PCI device
+ *
+ * If @dev and its upstream bridge both support ARI, enable ARI in the
+ * bridge.  Otherwise, disable ARI in the bridge.
  */
 void pci_enable_ari(struct pci_dev *dev)
 {
@@ -2078,9 +2081,6 @@ void pci_enable_ari(struct pci_dev *dev)
 	if (pcie_ari_disabled || !pci_is_pcie(dev) || dev->devfn)
 		return;
 
-	if (!pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ARI))
-		return;
-
 	bridge = dev->bus->self;
 	if (!bridge)
 		return;
@@ -2089,8 +2089,15 @@ void pci_enable_ari(struct pci_dev *dev)
 	if (!(cap & PCI_EXP_DEVCAP2_ARI))
 		return;
 
-	pcie_capability_set_word(bridge, PCI_EXP_DEVCTL2, PCI_EXP_DEVCTL2_ARI);
-	bridge->ari_enabled = 1;
+	if (pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ARI)) {
+		pcie_capability_set_word(bridge, PCI_EXP_DEVCTL2,
+					 PCI_EXP_DEVCTL2_ARI);
+		bridge->ari_enabled = 1;
+	} else {
+		pcie_capability_clear_word(bridge, PCI_EXP_DEVCTL2,
+					   PCI_EXP_DEVCTL2_ARI);
+		bridge->ari_enabled = 0;
+	}
 }
 
 /**

commit b7040469de97d361120836b4140941a08d06f56f
Merge: e84813c0cba2 295a7f6235bf
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Jan 10 11:19:22 2013 -0700

    Merge branch 'pci/yinghai-survey-resources+acpi-scan' into next
    
    * pci/yinghai-survey-resources+acpi-scan:
      ACPI / scan: Treat power resources in a special way
      ACPI: Remove unused struct acpi_pci_root.id member
      ACPI: Drop ACPI device .bind() and .unbind() callbacks
      ACPI / PCI: Move the _PRT setup and cleanup code to pci-acpi.c
      ACPI / PCI: Rework the setup and cleanup of device wakeup
      ACPI: Add .setup() and .cleanup() callbacks to struct acpi_bus_type
      ACPI: Make acpi_bus_scan() and acpi_bus_add() take only one argument
      ACPI: Replace ACPI device add_type field with a match_driver flag
      ACPI: Drop the second argument of acpi_bus_scan()
      ACPI: Remove the arguments of acpi_bus_add() that are not used
      ACPI: Remove acpi_start_single_object() and acpi_bus_start()
      ACPI / PCI: Fold acpi_pci_root_start() into acpi_pci_root_add()
      ACPI: Change the ordering of acpi_bus_check_add()
      ACPI: Replace struct acpi_bus_ops with enum type
      ACPI: Reduce the usage of struct acpi_bus_ops
      ACPI: Make acpi_bus_add() and acpi_bus_start() visibly different
      ACPI: Change the ordering of PCI root bridge driver registrarion
      ACPI: Separate adding ACPI device objects from probing ACPI drivers

commit b4b4fbba46a7a638878e58f303317e7904edfa13
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Jan 4 12:12:55 2013 -0700

    PCI: Drop "__" prefix on __pci_enable_device_flags()
    
    Drop the useless "__" prefix on __pci_enable_device_flags().
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index d574fbdbf4b0..a2f30394c091 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1156,8 +1156,7 @@ int pci_reenable_device(struct pci_dev *dev)
 	return 0;
 }
 
-static int __pci_enable_device_flags(struct pci_dev *dev,
-				     unsigned long flags)
+static int pci_enable_device_flags(struct pci_dev *dev, unsigned long flags)
 {
 	int err;
 	int i, bars = 0;
@@ -1201,7 +1200,7 @@ static int __pci_enable_device_flags(struct pci_dev *dev,
  */
 int pci_enable_device_io(struct pci_dev *dev)
 {
-	return __pci_enable_device_flags(dev, IORESOURCE_IO);
+	return pci_enable_device_flags(dev, IORESOURCE_IO);
 }
 
 /**
@@ -1214,7 +1213,7 @@ int pci_enable_device_io(struct pci_dev *dev)
  */
 int pci_enable_device_mem(struct pci_dev *dev)
 {
-	return __pci_enable_device_flags(dev, IORESOURCE_MEM);
+	return pci_enable_device_flags(dev, IORESOURCE_MEM);
 }
 
 /**
@@ -1230,7 +1229,7 @@ int pci_enable_device_mem(struct pci_dev *dev)
  */
 int pci_enable_device(struct pci_dev *dev)
 {
-	return __pci_enable_device_flags(dev, IORESOURCE_MEM | IORESOURCE_IO);
+	return pci_enable_device_flags(dev, IORESOURCE_MEM | IORESOURCE_IO);
 }
 
 /*

commit f7ffe19a6fab14df70bd0acca9a4836aa80b15f5
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Jan 4 12:13:15 2013 -0700

    PCI: Use "unsigned long" for __pci_enable_device_flags to match ioport.h
    
    __pci_enable_device_flags() takes values like IORESOURCE_IO and
    IORESOURCE_MEM, which are values for struct resource.flags, which is
    "unsigned long", not "resource_size_t".
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 5cb5820fae40..d574fbdbf4b0 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1157,7 +1157,7 @@ int pci_reenable_device(struct pci_dev *dev)
 }
 
 static int __pci_enable_device_flags(struct pci_dev *dev,
-				     resource_size_t flags)
+				     unsigned long flags)
 {
 	int err;
 	int i, bars = 0;

commit d2e5f0c16ad60a7208fd371233e63b73c990ece2
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Dec 23 00:02:44 2012 +0100

    ACPI / PCI: Rework the setup and cleanup of device wakeup
    
    Currently, the ACPI wakeup capability of PCI devices is set up
    in two different places, partially in acpi_pci_bind() where
    runtime wakeup is initialized and partially in
    platform_pci_wakeup_init(), where system wakeup is initialized.
    The cleanup is only done in acpi_pci_unbind() and it only covers
    runtime wakeup.
    
    Use the new .setup() and .cleanup() callbacks in struct acpi_bus_type
    to consolidate that code and do the setup and the cleanup each in one
    place.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>
    Acked-by: Toshi Kani <toshi.kani@hp.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 5cb5820fae40..0c4f641b7be1 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -450,7 +450,7 @@ static struct pci_platform_pm_ops *pci_platform_pm;
 int pci_set_platform_pm(struct pci_platform_pm_ops *ops)
 {
 	if (!ops->is_manageable || !ops->set_state || !ops->choose_state
-	    || !ops->sleep_wake || !ops->can_wakeup)
+	    || !ops->sleep_wake)
 		return -EINVAL;
 	pci_platform_pm = ops;
 	return 0;
@@ -473,11 +473,6 @@ static inline pci_power_t platform_pci_choose_state(struct pci_dev *dev)
 			pci_platform_pm->choose_state(dev) : PCI_POWER_ERROR;
 }
 
-static inline bool platform_pci_can_wakeup(struct pci_dev *dev)
-{
-	return pci_platform_pm ? pci_platform_pm->can_wakeup(dev) : false;
-}
-
 static inline int platform_pci_sleep_wake(struct pci_dev *dev, bool enable)
 {
 	return pci_platform_pm ?
@@ -1985,25 +1980,6 @@ void pci_pm_init(struct pci_dev *dev)
 	}
 }
 
-/**
- * platform_pci_wakeup_init - init platform wakeup if present
- * @dev: PCI device
- *
- * Some devices don't have PCI PM caps but can still generate wakeup
- * events through platform methods (like ACPI events).  If @dev supports
- * platform wakeup events, set the device flag to indicate as much.  This
- * may be redundant if the device also supports PCI PM caps, but double
- * initialization should be safe in that case.
- */
-void platform_pci_wakeup_init(struct pci_dev *dev)
-{
-	if (!platform_pci_can_wakeup(dev))
-		return;
-
-	device_set_wakeup_capable(&dev->dev, true);
-	platform_pci_sleep_wake(dev, false);
-}
-
 static void pci_add_saved_cap(struct pci_dev *pci_dev,
 	struct pci_cap_saved_state *new_cap)
 {

commit 193c0d682525987db59ac3a24531a77e4947aa95
Merge: 8b0cab14951f 1cb73f8c479e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Dec 13 12:14:47 2012 -0800

    Merge tag 'for-3.8' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI update from Bjorn Helgaas:
     "Host bridge hotplug:
       - Untangle _PRT from struct pci_bus (Bjorn Helgaas)
       - Request _OSC control before scanning root bus (Taku Izumi)
       - Assign resources when adding host bridge (Yinghai Lu)
       - Remove root bus when removing host bridge (Yinghai Lu)
       - Remove _PRT during hot remove (Yinghai Lu)
    
      SRIOV
        - Add sysfs knobs to control numVFs (Don Dutile)
    
      Power management
       - Notify devices when power resource turned on (Huang Ying)
    
      Bug fixes
       - Work around broken _SEG on HP xw9300 (Bjorn Helgaas)
       - Keep runtime PM enabled for unbound PCI devices (Huang Ying)
       - Fix Optimus dual-GPU runtime D3 suspend issue (Dave Airlie)
       - Fix xen frontend shutdown issue (David Vrabel)
       - Work around PLX PCI 9050 BAR alignment erratum (Ian Abbott)
    
      Miscellaneous
       - Add GPL license for drivers/pci/ioapic (Andrew Cooks)
       - Add standard PCI-X, PCIe ASPM register #defines (Bjorn Helgaas)
       - NumaChip remote PCI support (Daniel Blueman)
       - Fix PCIe Link Capabilities Supported Link Speed definition (Jingoo
         Han)
       - Convert dev_printk() to dev_info(), etc (Joe Perches)
       - Add support for non PCI BAR ROM data (Matthew Garrett)
       - Add x86 support for host bridge translation offset (Mike Yoknis)
       - Report success only when every driver supports AER (Vijay
         Pandarathil)"
    
    Fix up trivial conflicts.
    
    * tag 'for-3.8' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (48 commits)
      PCI: Use phys_addr_t for physical ROM address
      x86/PCI: Add NumaChip remote PCI support
      ath9k: Use standard #defines for PCIe Capability ASPM fields
      iwlwifi: Use standard #defines for PCIe Capability ASPM fields
      iwlwifi: collapse wrapper for pcie_capability_read_word()
      iwlegacy: Use standard #defines for PCIe Capability ASPM fields
      iwlegacy: collapse wrapper for pcie_capability_read_word()
      cxgb3: Use standard #defines for PCIe Capability ASPM fields
      PCI: Add standard PCIe Capability Link ASPM field names
      PCI/portdrv: Use PCI Express Capability accessors
      PCI: Use standard PCIe Capability Link register field names
      x86: Use PCI setup data
      PCI: Add support for non-BAR ROMs
      PCI: Add pcibios_add_device
      EFI: Stash ROMs if they're not in the PCI BAR
      PCI: Add and use standard PCI-X Capability register names
      PCI/PM: Keep runtime PM enabled for unbound PCI devices
      xen-pcifront: Handle backend CLOSED without CLOSING
      PCI: SRIOV control and status via sysfs (documentation)
      PCI/AER: Report success only when every device has AER-aware driver
      ...

commit 72e1e868ca8f14ef34c95e0e8b73f64b6acf5934
Merge: edb1daab8e91 f9a37be0f02a
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Dec 6 14:37:32 2012 -0700

    Merge branch 'pci/mjg-pci-roms-from-efi' into next
    
    * pci/mjg-pci-roms-from-efi:
      x86: Use PCI setup data
      PCI: Add support for non-BAR ROMs
      PCI: Add pcibios_add_device
      EFI: Stash ROMs if they're not in the PCI BAR

commit eca0d4676d8e29c209ddce0c0c1755472ffc70a6
Author: Matthew Garrett <mjg@redhat.com>
Date:   Wed Dec 5 14:33:27 2012 -0700

    PCI: Add pcibios_add_device
    
    Platforms may want to provide architecture-specific functionality during
    PCI enumeration. Add a pcibios_add_device() call that architectures can
    override to do so.
    
    Signed-off-by: Matthew Garrett <mjg@redhat.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Tested-by: Seth Forshee <seth.forshee@canonical.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 54858838f098..fa0ddd51a216 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1333,6 +1333,19 @@ void pcim_pin_device(struct pci_dev *pdev)
 		dr->pinned = 1;
 }
 
+/*
+ * pcibios_add_device - provide arch specific hooks when adding device dev
+ * @dev: the PCI device being added
+ *
+ * Permits the platform to provide architecture specific functionality when
+ * devices are added. This is the default implementation. Architecture
+ * implementations can override this.
+ */
+int __weak pcibios_add_device (struct pci_dev *dev)
+{
+	return 0;
+}
+
 /**
  * pcibios_disable_device - disable arch specific PCI resources for device dev
  * @dev: the PCI device to disable

commit edb1daab8e91338b7e2a6c41faec695891ccda35
Merge: be5cd530bd23 967577b06241
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Dec 4 16:13:03 2012 -0700

    Merge branch 'pci/huang-d3cold-fixes' into next
    
    * pci/huang-d3cold-fixes:
      PCI/PM: Keep runtime PM enabled for unbound PCI devices

commit 967577b062417b4e4b8e27b711220f4124f5153a
Author: Huang Ying <ying.huang@intel.com>
Date:   Tue Nov 20 16:08:22 2012 +0800

    PCI/PM: Keep runtime PM enabled for unbound PCI devices
    
    For unbound PCI devices, what we need is:
    
     - Always in D0 state, because some devices do not work again after
       being put into D3 by the PCI bus.
    
     - In SUSPENDED state if allowed, so that the parent devices can still
       be put into low power state.
    
    To satisfy these requirements, the runtime PM for the unbound PCI
    devices are disabled and set to SUSPENDED state.  One issue of this
    solution is that the PCI devices will be put into SUSPENDED state even
    if the SUSPENDED state is forbidden via the sysfs interface
    (.../power/control) of the device.  This is not an issue for most
    devices, because most PCI devices are not used at all if unbound.
    But there are exceptions.  For example, unbound VGA card can be used
    for display, but suspending its parents makes it stop working.
    
    To fix the issue, we keep the runtime PM enabled when the PCI devices
    are unbound.  But the runtime PM callbacks will do nothing if the PCI
    devices are unbound.  This way, we can put the PCI devices into
    SUSPENDED state without putting the PCI devices into D3 state.
    
    Reference: https://bugzilla.kernel.org/show_bug.cgi?id=48201
    Signed-off-by: Huang Ying <ying.huang@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    CC: stable@vger.kernel.org          # v3.6+

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index aabf64798bda..8e06adb9898f 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1900,6 +1900,8 @@ void pci_pm_init(struct pci_dev *dev)
 	u16 pmc;
 
 	pm_runtime_forbid(&dev->dev);
+	pm_runtime_set_active(&dev->dev);
+	pm_runtime_enable(&dev->dev);
 	device_enable_async_suspend(&dev->dev);
 	dev->wakeup_prepared = false;
 

commit 15856ad50bf5ea02a5ee22399c036d49e7e1124d
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Wed Nov 21 15:35:00 2012 -0500

    PCI: Remove __dev* markings
    
    CONFIG_HOTPLUG is going away as an option so __devexit_p, __devint,
    __devinitdata, __devinitconst, and _devexit are no longer needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index aabf64798bda..bdf66b500f22 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -86,7 +86,7 @@ enum pcie_bus_config_types pcie_bus_config = PCIE_BUS_TUNE_OFF;
  * the dfl or actual value as it sees fit.  Don't forget this is
  * measured in 32-bit words, not bytes.
  */
-u8 pci_dfl_cache_line_size __devinitdata = L1_CACHE_BYTES >> 2;
+u8 pci_dfl_cache_line_size = L1_CACHE_BYTES >> 2;
 u8 pci_cache_line_size;
 
 /*
@@ -3857,7 +3857,7 @@ static int __init pci_resource_alignment_sysfs_init(void)
 
 late_initcall(pci_resource_alignment_sysfs_init);
 
-static void __devinit pci_no_domains(void)
+static void pci_no_domains(void)
 {
 #ifdef CONFIG_PCI_DOMAINS
 	pci_domains_supported = 0;

commit d3fe3988fb24e5ed13b2243b789a652882d3b26c
Merge: 7db78a9c864d ff8e59bc4ec3
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Nov 26 13:00:57 2012 -0700

    Merge branch 'for-linus' into next
    
    * for-linus:
      PCI/portdrv: Don't create hotplug slots unless port supports hotplug
      PCI/PM: Fix proc config reg access for D3cold and bridge suspending
      PCI/PM: Resume device before shutdown
      PCI/PM: Fix deadlock when unbinding device if parent in D3cold

commit 05508270064efd674e8f2a047911dcd7776aaae0
Merge: fa20f6f240e1 8c33f51df406
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Nov 9 10:00:07 2012 -0700

    Merge branch 'pci/taku-prt-cleanup' into next
    
    * pci/taku-prt-cleanup:
      PCI/ACPI: Request _OSC control before scanning PCI root bus
      PCI: Don't pass pci_dev to pci_ext_cfg_avail()
      PCI/ACPI: Add _PRT interrupt routing info before enumerating devices
      ACPI: Pass segment/bus to _PRT add/del so they don't depend on pci_bus

commit 6e965e0d0e1d102c261326b06338d3385ea55f97
Author: Huang Ying <ying.huang@intel.com>
Date:   Fri Oct 26 13:07:51 2012 +0800

    PCI/PM: Add comments for PME poll support for PCIe
    
    There are comments on why PME poll support is necessary for PCI
    devices, but not for PCIe devices.  That may lead to misunderstanding
    that PME poll is only necessary for PCI devices.  So add comments
    related to PCIe PME poll to make it more clear.
    
    The content of comments comes from the changelog of commit:
    
    379021d5c0899fcf9410cae4ca7a59a5a94ca769
    
    Signed-off-by: Huang Ying <ying.huang@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 54858838f098..485cfa9af2ef 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1578,15 +1578,25 @@ void pci_pme_active(struct pci_dev *dev, bool enable)
 
 	pci_write_config_word(dev, dev->pm_cap + PCI_PM_CTRL, pmcsr);
 
-	/* PCI (as opposed to PCIe) PME requires that the device have
-	   its PME# line hooked up correctly. Not all hardware vendors
-	   do this, so the PME never gets delivered and the device
-	   remains asleep. The easiest way around this is to
-	   periodically walk the list of suspended devices and check
-	   whether any have their PME flag set. The assumption is that
-	   we'll wake up often enough anyway that this won't be a huge
-	   hit, and the power savings from the devices will still be a
-	   win. */
+	/*
+	 * PCI (as opposed to PCIe) PME requires that the device have
+	 * its PME# line hooked up correctly. Not all hardware vendors
+	 * do this, so the PME never gets delivered and the device
+	 * remains asleep. The easiest way around this is to
+	 * periodically walk the list of suspended devices and check
+	 * whether any have their PME flag set. The assumption is that
+	 * we'll wake up often enough anyway that this won't be a huge
+	 * hit, and the power savings from the devices will still be a
+	 * win.
+	 *
+	 * Although PCIe uses in-band PME message instead of PME# line
+	 * to report PME, PME does not work for some PCIe devices in
+	 * reality.  For example, there are devices that set their PME
+	 * status bits, but don't really bother to send a PME message;
+	 * there are PCI Express Root Ports that don't bother to
+	 * trigger interrupts when they receive PME messages from the
+	 * devices below.  So PME poll is used for PCIe devices too.
+	 */
 
 	if (dev->pme_poll) {
 		struct pci_pme_device *pme_dev;

commit 642c92da36ae0bed3c31fdd408411ab95f4e326b
Author: Taku Izumi <izumi.taku@jp.fujitsu.com>
Date:   Tue Oct 30 15:26:18 2012 +0900

    PCI: Don't pass pci_dev to pci_ext_cfg_avail()
    
    pci_ext_cfg_avail() doesn't use the "struct pci_dev *" passed to
    it, and there's no requirement that a host bridge even be represented
    by a pci_dev.  This drops the pci_ext_cfg_avail() parameter.
    
    [bhelgaas: changelog]
    Signed-off-by: Taku Izumi <izumi.taku@jp.fujitsu.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 54858838f098..01b68bfa2321 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -3833,14 +3833,13 @@ static void __devinit pci_no_domains(void)
 }
 
 /**
- * pci_ext_cfg_enabled - can we access extended PCI config space?
- * @dev: The PCI device of the root bridge.
+ * pci_ext_cfg_avail - can we access extended PCI config space?
  *
  * Returns 1 if we can access PCI extended config space (offsets
  * greater than 0xff). This is the default implementation. Architecture
  * implementations can override this.
  */
-int __weak pci_ext_cfg_avail(struct pci_dev *dev)
+int __weak pci_ext_cfg_avail(void)
 {
 	return 1;
 }

commit b3c32c4f9565f93407921c0d8a4458042eb8998e
Author: Huang Ying <ying.huang@intel.com>
Date:   Thu Oct 25 09:36:03 2012 +0800

    PCI/PM: Fix proc config reg access for D3cold and bridge suspending
    
    In https://bugzilla.kernel.org/show_bug.cgi?id=48981
    Peter reported that /proc/bus/pci/??/??.? does not work for 3.6.
    This is because the device configuration space registers are
    not accessible if the corresponding parent bridge is suspended or
    the device is put into D3cold state.
    
    This is the same as /sys/bus/pci/devices/0000:??:??.?/config access
    issue.  So the function used to solve sysfs issue is used to solve
    this issue.
    
    This patch moves pci_config_pm_runtime_get()/_put() from pci/pci-sysfs.c
    to pci/pci.c and makes them extern so they can be used by both the
    sysfs and proc paths.
    
    [bhelgaas: changelog, references, reporters]
    Reference: https://bugzilla.kernel.org/show_bug.cgi?id=48981
    Reference: https://bugzilla.kernel.org/show_bug.cgi?id=49031
    Reported-by: Forrest Loomis <cybercyst@gmail.com>
    Reported-by: Peter <lekensteyn@gmail.com>
    Reported-by: Micael Dias <kam1kaz3@gmail.com>
    Signed-off-by: Huang Ying <ying.huang@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    CC: stable@vger.kernel.org              # v3.6+

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 54858838f098..aabf64798bda 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1858,6 +1858,38 @@ bool pci_dev_run_wake(struct pci_dev *dev)
 }
 EXPORT_SYMBOL_GPL(pci_dev_run_wake);
 
+void pci_config_pm_runtime_get(struct pci_dev *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device *parent = dev->parent;
+
+	if (parent)
+		pm_runtime_get_sync(parent);
+	pm_runtime_get_noresume(dev);
+	/*
+	 * pdev->current_state is set to PCI_D3cold during suspending,
+	 * so wait until suspending completes
+	 */
+	pm_runtime_barrier(dev);
+	/*
+	 * Only need to resume devices in D3cold, because config
+	 * registers are still accessible for devices suspended but
+	 * not in D3cold.
+	 */
+	if (pdev->current_state == PCI_D3cold)
+		pm_runtime_resume(dev);
+}
+
+void pci_config_pm_runtime_put(struct pci_dev *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device *parent = dev->parent;
+
+	pm_runtime_put(dev);
+	if (parent)
+		pm_runtime_put_sync(parent);
+}
+
 /**
  * pci_pm_init - Initialize PM functions of given PCI device
  * @dev: PCI device to handle.

commit 6dabee73d46bfafb8c588b21b14606914de97ee6
Merge: 78890b5989d9 769ae543dc8d
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Sep 13 09:08:02 2012 -0600

    Merge branch 'pci/trivial' into next
    
    * pci/trivial:
      PCI: Drop duplicate const in DECLARE_PCI_FIXUP_SECTION
      PCI: Drop bogus default from ARCH_SUPPORTS_MSI
      PCI: cpqphp: Remove unreachable path
      PCI: Remove bus number resource debug messages
      PCI/AER: Print completion message at KERN_INFO to match starting message
      PCI: Fix drivers/pci/pci.c kernel-doc warnings

commit 78890b5989d96ddce989cde929c45ceeded0fcaf
Merge: 1959ec5f82ac 55d512e245bc
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Sep 13 08:41:01 2012 -0600

    Merge commit 'v3.6-rc5' into next
    
    * commit 'v3.6-rc5': (1098 commits)
      Linux 3.6-rc5
      HID: tpkbd: work even if the new Lenovo Keyboard driver is not configured
      Remove user-triggerable BUG from mpol_to_str
      xen/pciback: Fix proper FLR steps.
      uml: fix compile error in deliver_alarm()
      dj: memory scribble in logi_dj
      Fix order of arguments to compat_put_time[spec|val]
      xen: Use correct masking in xen_swiotlb_alloc_coherent.
      xen: fix logical error in tlb flushing
      xen/p2m: Fix one-off error in checking the P2M tree directory.
      powerpc: Don't use __put_user() in patch_instruction
      powerpc: Make sure IPI handlers see data written by IPI senders
      powerpc: Restore correct DSCR in context switch
      powerpc: Fix DSCR inheritance in copy_thread()
      powerpc: Keep thread.dscr and thread.dscr_inherit in sync
      powerpc: Update DSCR on all CPUs when writing sysfs dscr_default
      powerpc/powernv: Always go into nap mode when CPU is offline
      powerpc: Give hypervisor decrementer interrupts their own handler
      powerpc/vphn: Fix arch_update_cpu_topology() return value
      ARM: gemini: fix the gemini build
      ...
    
    Conflicts:
            drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c
            drivers/rapidio/devices/tsi721.c

commit a28afda8cc6a45b2c5a4f98cf8fcddd877597701
Merge: e1c171b86baa defb9446fe41
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Aug 23 18:32:36 2012 -0600

    Merge branch 'pci/bjorn-find-next-ext-cap' into next
    
    * pci/bjorn-find-next-ext-cap:
      PCI: Add Vendor-Specific Extended Capability header info
      PCI: Add pci_find_next_ext_capability()
    
    Conflicts:
            drivers/pci/pci.c

commit 59875ae489609b2267548dc85160c5f0f0c6f9d4
Author: Jiang Liu <jiang.liu@huawei.com>
Date:   Tue Jul 24 17:20:06 2012 +0800

    PCI/core: Use PCI Express Capability accessors
    
    Use PCI Express Capability access functions to simplify core.
    
    Signed-off-by: Jiang Liu <jiang.liu@huawei.com>
    Signed-off-by: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 28eb55b77ee9..fac08f508d09 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -253,38 +253,6 @@ int pci_bus_find_capability(struct pci_bus *bus, unsigned int devfn, int cap)
 	return pos;
 }
 
-/**
- * pci_pcie_cap2 - query for devices' PCI_CAP_ID_EXP v2 capability structure
- * @dev: PCI device to check
- *
- * Like pci_pcie_cap() but also checks that the PCIe capability version is
- * >= 2.  Note that v1 capability structures could be sparse in that not
- * all register fields were required.  v2 requires the entire structure to
- * be present size wise, while still allowing for non-implemented registers
- * to exist but they must be hardwired to 0.
- *
- * Due to the differences in the versions of capability structures, one
- * must be careful not to try and access non-existant registers that may
- * exist in early versions - v1 - of Express devices.
- *
- * Returns the offset of the PCIe capability structure as long as the
- * capability version is >= 2; otherwise 0 is returned.
- */
-static int pci_pcie_cap2(struct pci_dev *dev)
-{
-	u16 flags;
-	int pos;
-
-	pos = pci_pcie_cap(dev);
-	if (pos) {
-		pci_read_config_word(dev, pos + PCI_EXP_FLAGS, &flags);
-		if ((flags & PCI_EXP_FLAGS_VERS) < 2)
-			pos = 0;
-	}
-
-	return pos;
-}
-
 /**
  * pci_find_ext_capability - Find an extended capability
  * @dev: PCI device to query
@@ -854,21 +822,6 @@ EXPORT_SYMBOL(pci_choose_state);
 
 #define PCI_EXP_SAVE_REGS	7
 
-#define pcie_cap_has_devctl(type, flags)	1
-#define pcie_cap_has_lnkctl(type, flags)		\
-		((flags & PCI_EXP_FLAGS_VERS) > 1 ||	\
-		 (type == PCI_EXP_TYPE_ROOT_PORT ||	\
-		  type == PCI_EXP_TYPE_ENDPOINT ||	\
-		  type == PCI_EXP_TYPE_LEG_END))
-#define pcie_cap_has_sltctl(type, flags)		\
-		((flags & PCI_EXP_FLAGS_VERS) > 1 ||	\
-		 ((type == PCI_EXP_TYPE_ROOT_PORT) ||	\
-		  (type == PCI_EXP_TYPE_DOWNSTREAM &&	\
-		   (flags & PCI_EXP_FLAGS_SLOT))))
-#define pcie_cap_has_rtctl(type, flags)			\
-		((flags & PCI_EXP_FLAGS_VERS) > 1 ||	\
-		 (type == PCI_EXP_TYPE_ROOT_PORT ||	\
-		  type == PCI_EXP_TYPE_RC_EC))
 
 static struct pci_cap_saved_state *pci_find_saved_cap(
 	struct pci_dev *pci_dev, char cap)
@@ -885,13 +838,11 @@ static struct pci_cap_saved_state *pci_find_saved_cap(
 
 static int pci_save_pcie_state(struct pci_dev *dev)
 {
-	int type, pos, i = 0;
+	int i = 0;
 	struct pci_cap_saved_state *save_state;
 	u16 *cap;
-	u16 flags;
 
-	pos = pci_pcie_cap(dev);
-	if (!pos)
+	if (!pci_is_pcie(dev))
 		return 0;
 
 	save_state = pci_find_saved_cap(dev, PCI_CAP_ID_EXP);
@@ -899,62 +850,37 @@ static int pci_save_pcie_state(struct pci_dev *dev)
 		dev_err(&dev->dev, "buffer not found in %s\n", __func__);
 		return -ENOMEM;
 	}
-	cap = (u16 *)&save_state->cap.data[0];
-
-	pci_read_config_word(dev, pos + PCI_EXP_FLAGS, &flags);
-
-	type = pci_pcie_type(dev);
-	if (pcie_cap_has_devctl(type, flags))
-		pci_read_config_word(dev, pos + PCI_EXP_DEVCTL, &cap[i++]);
-	if (pcie_cap_has_lnkctl(type, flags))
-		pci_read_config_word(dev, pos + PCI_EXP_LNKCTL, &cap[i++]);
-	if (pcie_cap_has_sltctl(type, flags))
-		pci_read_config_word(dev, pos + PCI_EXP_SLTCTL, &cap[i++]);
-	if (pcie_cap_has_rtctl(type, flags))
-		pci_read_config_word(dev, pos + PCI_EXP_RTCTL, &cap[i++]);
 
-	pos = pci_pcie_cap2(dev);
-	if (!pos)
-		return 0;
+	cap = (u16 *)&save_state->cap.data[0];
+	pcie_capability_read_word(dev, PCI_EXP_DEVCTL, &cap[i++]);
+	pcie_capability_read_word(dev, PCI_EXP_LNKCTL, &cap[i++]);
+	pcie_capability_read_word(dev, PCI_EXP_SLTCTL, &cap[i++]);
+	pcie_capability_read_word(dev, PCI_EXP_RTCTL,  &cap[i++]);
+	pcie_capability_read_word(dev, PCI_EXP_DEVCTL2, &cap[i++]);
+	pcie_capability_read_word(dev, PCI_EXP_LNKCTL2, &cap[i++]);
+	pcie_capability_read_word(dev, PCI_EXP_SLTCTL2, &cap[i++]);
 
-	pci_read_config_word(dev, pos + PCI_EXP_DEVCTL2, &cap[i++]);
-	pci_read_config_word(dev, pos + PCI_EXP_LNKCTL2, &cap[i++]);
-	pci_read_config_word(dev, pos + PCI_EXP_SLTCTL2, &cap[i++]);
 	return 0;
 }
 
 static void pci_restore_pcie_state(struct pci_dev *dev)
 {
-	int i = 0, pos, type;
+	int i = 0;
 	struct pci_cap_saved_state *save_state;
 	u16 *cap;
-	u16 flags;
 
 	save_state = pci_find_saved_cap(dev, PCI_CAP_ID_EXP);
-	pos = pci_find_capability(dev, PCI_CAP_ID_EXP);
-	if (!save_state || pos <= 0)
-		return;
-	cap = (u16 *)&save_state->cap.data[0];
-
-	pci_read_config_word(dev, pos + PCI_EXP_FLAGS, &flags);
-
-	type = pci_pcie_type(dev);
-	if (pcie_cap_has_devctl(type, flags))
-		pci_write_config_word(dev, pos + PCI_EXP_DEVCTL, cap[i++]);
-	if (pcie_cap_has_lnkctl(type, flags))
-		pci_write_config_word(dev, pos + PCI_EXP_LNKCTL, cap[i++]);
-	if (pcie_cap_has_sltctl(type, flags))
-		pci_write_config_word(dev, pos + PCI_EXP_SLTCTL, cap[i++]);
-	if (pcie_cap_has_rtctl(type, flags))
-		pci_write_config_word(dev, pos + PCI_EXP_RTCTL, cap[i++]);
-
-	pos = pci_pcie_cap2(dev);
-	if (!pos)
+	if (!save_state)
 		return;
 
-	pci_write_config_word(dev, pos + PCI_EXP_DEVCTL2, cap[i++]);
-	pci_write_config_word(dev, pos + PCI_EXP_LNKCTL2, cap[i++]);
-	pci_write_config_word(dev, pos + PCI_EXP_SLTCTL2, cap[i++]);
+	cap = (u16 *)&save_state->cap.data[0];
+	pcie_capability_write_word(dev, PCI_EXP_DEVCTL, cap[i++]);
+	pcie_capability_write_word(dev, PCI_EXP_LNKCTL, cap[i++]);
+	pcie_capability_write_word(dev, PCI_EXP_SLTCTL, cap[i++]);
+	pcie_capability_write_word(dev, PCI_EXP_RTCTL, cap[i++]);
+	pcie_capability_write_word(dev, PCI_EXP_DEVCTL2, cap[i++]);
+	pcie_capability_write_word(dev, PCI_EXP_LNKCTL2, cap[i++]);
+	pcie_capability_write_word(dev, PCI_EXP_SLTCTL2, cap[i++]);
 }
 
 
@@ -2068,35 +1994,24 @@ void pci_free_cap_save_buffers(struct pci_dev *dev)
  */
 void pci_enable_ari(struct pci_dev *dev)
 {
-	int pos;
 	u32 cap;
-	u16 ctrl;
 	struct pci_dev *bridge;
 
 	if (pcie_ari_disabled || !pci_is_pcie(dev) || dev->devfn)
 		return;
 
-	pos = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ARI);
-	if (!pos)
+	if (!pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ARI))
 		return;
 
 	bridge = dev->bus->self;
 	if (!bridge)
 		return;
 
-	/* ARI is a PCIe cap v2 feature */
-	pos = pci_pcie_cap2(bridge);
-	if (!pos)
-		return;
-
-	pci_read_config_dword(bridge, pos + PCI_EXP_DEVCAP2, &cap);
+	pcie_capability_read_dword(bridge, PCI_EXP_DEVCAP2, &cap);
 	if (!(cap & PCI_EXP_DEVCAP2_ARI))
 		return;
 
-	pci_read_config_word(bridge, pos + PCI_EXP_DEVCTL2, &ctrl);
-	ctrl |= PCI_EXP_DEVCTL2_ARI;
-	pci_write_config_word(bridge, pos + PCI_EXP_DEVCTL2, ctrl);
-
+	pcie_capability_set_word(bridge, PCI_EXP_DEVCTL2, PCI_EXP_DEVCTL2_ARI);
 	bridge->ari_enabled = 1;
 }
 
@@ -2111,20 +2026,14 @@ void pci_enable_ari(struct pci_dev *dev)
  */
 void pci_enable_ido(struct pci_dev *dev, unsigned long type)
 {
-	int pos;
-	u16 ctrl;
+	u16 ctrl = 0;
 
-	/* ID-based Ordering is a PCIe cap v2 feature */
-	pos = pci_pcie_cap2(dev);
-	if (!pos)
-		return;
-
-	pci_read_config_word(dev, pos + PCI_EXP_DEVCTL2, &ctrl);
 	if (type & PCI_EXP_IDO_REQUEST)
 		ctrl |= PCI_EXP_IDO_REQ_EN;
 	if (type & PCI_EXP_IDO_COMPLETION)
 		ctrl |= PCI_EXP_IDO_CMP_EN;
-	pci_write_config_word(dev, pos + PCI_EXP_DEVCTL2, ctrl);
+	if (ctrl)
+		pcie_capability_set_word(dev, PCI_EXP_DEVCTL2, ctrl);
 }
 EXPORT_SYMBOL(pci_enable_ido);
 
@@ -2135,20 +2044,14 @@ EXPORT_SYMBOL(pci_enable_ido);
  */
 void pci_disable_ido(struct pci_dev *dev, unsigned long type)
 {
-	int pos;
-	u16 ctrl;
+	u16 ctrl = 0;
 
-	/* ID-based Ordering is a PCIe cap v2 feature */
-	pos = pci_pcie_cap2(dev);
-	if (!pos)
-		return;
-
-	pci_read_config_word(dev, pos + PCI_EXP_DEVCTL2, &ctrl);
 	if (type & PCI_EXP_IDO_REQUEST)
-		ctrl &= ~PCI_EXP_IDO_REQ_EN;
+		ctrl |= PCI_EXP_IDO_REQ_EN;
 	if (type & PCI_EXP_IDO_COMPLETION)
-		ctrl &= ~PCI_EXP_IDO_CMP_EN;
-	pci_write_config_word(dev, pos + PCI_EXP_DEVCTL2, ctrl);
+		ctrl |= PCI_EXP_IDO_CMP_EN;
+	if (ctrl)
+		pcie_capability_clear_word(dev, PCI_EXP_DEVCTL2, ctrl);
 }
 EXPORT_SYMBOL(pci_disable_ido);
 
@@ -2173,17 +2076,11 @@ EXPORT_SYMBOL(pci_disable_ido);
  */
 int pci_enable_obff(struct pci_dev *dev, enum pci_obff_signal_type type)
 {
-	int pos;
 	u32 cap;
 	u16 ctrl;
 	int ret;
 
-	/* OBFF is a PCIe cap v2 feature */
-	pos = pci_pcie_cap2(dev);
-	if (!pos)
-		return -ENOTSUPP;
-
-	pci_read_config_dword(dev, pos + PCI_EXP_DEVCAP2, &cap);
+	pcie_capability_read_dword(dev, PCI_EXP_DEVCAP2, &cap);
 	if (!(cap & PCI_EXP_OBFF_MASK))
 		return -ENOTSUPP; /* no OBFF support at all */
 
@@ -2194,7 +2091,7 @@ int pci_enable_obff(struct pci_dev *dev, enum pci_obff_signal_type type)
 			return ret;
 	}
 
-	pci_read_config_word(dev, pos + PCI_EXP_DEVCTL2, &ctrl);
+	pcie_capability_read_word(dev, PCI_EXP_DEVCTL2, &ctrl);
 	if (cap & PCI_EXP_OBFF_WAKE)
 		ctrl |= PCI_EXP_OBFF_WAKE_EN;
 	else {
@@ -2212,7 +2109,7 @@ int pci_enable_obff(struct pci_dev *dev, enum pci_obff_signal_type type)
 			return -ENOTSUPP;
 		}
 	}
-	pci_write_config_word(dev, pos + PCI_EXP_DEVCTL2, ctrl);
+	pcie_capability_write_word(dev, PCI_EXP_DEVCTL2, ctrl);
 
 	return 0;
 }
@@ -2226,17 +2123,7 @@ EXPORT_SYMBOL(pci_enable_obff);
  */
 void pci_disable_obff(struct pci_dev *dev)
 {
-	int pos;
-	u16 ctrl;
-
-	/* OBFF is a PCIe cap v2 feature */
-	pos = pci_pcie_cap2(dev);
-	if (!pos)
-		return;
-
-	pci_read_config_word(dev, pos + PCI_EXP_DEVCTL2, &ctrl);
-	ctrl &= ~PCI_EXP_OBFF_WAKE_EN;
-	pci_write_config_word(dev, pos + PCI_EXP_DEVCTL2, ctrl);
+	pcie_capability_clear_word(dev, PCI_EXP_DEVCTL2, PCI_EXP_OBFF_WAKE_EN);
 }
 EXPORT_SYMBOL(pci_disable_obff);
 
@@ -2249,15 +2136,9 @@ EXPORT_SYMBOL(pci_disable_obff);
  */
 static bool pci_ltr_supported(struct pci_dev *dev)
 {
-	int pos;
 	u32 cap;
 
-	/* LTR is a PCIe cap v2 feature */
-	pos = pci_pcie_cap2(dev);
-	if (!pos)
-		return false;
-
-	pci_read_config_dword(dev, pos + PCI_EXP_DEVCAP2, &cap);
+	pcie_capability_read_dword(dev, PCI_EXP_DEVCAP2, &cap);
 
 	return cap & PCI_EXP_DEVCAP2_LTR;
 }
@@ -2274,22 +2155,15 @@ static bool pci_ltr_supported(struct pci_dev *dev)
  */
 int pci_enable_ltr(struct pci_dev *dev)
 {
-	int pos;
-	u16 ctrl;
 	int ret;
 
-	if (!pci_ltr_supported(dev))
-		return -ENOTSUPP;
-
-	/* LTR is a PCIe cap v2 feature */
-	pos = pci_pcie_cap2(dev);
-	if (!pos)
-		return -ENOTSUPP;
-
 	/* Only primary function can enable/disable LTR */
 	if (PCI_FUNC(dev->devfn) != 0)
 		return -EINVAL;
 
+	if (!pci_ltr_supported(dev))
+		return -ENOTSUPP;
+
 	/* Enable upstream ports first */
 	if (dev->bus->self) {
 		ret = pci_enable_ltr(dev->bus->self);
@@ -2297,11 +2171,7 @@ int pci_enable_ltr(struct pci_dev *dev)
 			return ret;
 	}
 
-	pci_read_config_word(dev, pos + PCI_EXP_DEVCTL2, &ctrl);
-	ctrl |= PCI_EXP_LTR_EN;
-	pci_write_config_word(dev, pos + PCI_EXP_DEVCTL2, ctrl);
-
-	return 0;
+	return pcie_capability_set_word(dev, PCI_EXP_DEVCTL2, PCI_EXP_LTR_EN);
 }
 EXPORT_SYMBOL(pci_enable_ltr);
 
@@ -2311,24 +2181,14 @@ EXPORT_SYMBOL(pci_enable_ltr);
  */
 void pci_disable_ltr(struct pci_dev *dev)
 {
-	int pos;
-	u16 ctrl;
-
-	if (!pci_ltr_supported(dev))
-		return;
-
-	/* LTR is a PCIe cap v2 feature */
-	pos = pci_pcie_cap2(dev);
-	if (!pos)
-		return;
-
 	/* Only primary function can enable/disable LTR */
 	if (PCI_FUNC(dev->devfn) != 0)
 		return;
 
-	pci_read_config_word(dev, pos + PCI_EXP_DEVCTL2, &ctrl);
-	ctrl &= ~PCI_EXP_LTR_EN;
-	pci_write_config_word(dev, pos + PCI_EXP_DEVCTL2, ctrl);
+	if (!pci_ltr_supported(dev))
+		return;
+
+	pcie_capability_clear_word(dev, PCI_EXP_DEVCTL2, PCI_EXP_LTR_EN);
 }
 EXPORT_SYMBOL(pci_disable_ltr);
 
@@ -2411,9 +2271,6 @@ void pci_enable_acs(struct pci_dev *dev)
 	if (!pci_acs_enable)
 		return;
 
-	if (!pci_is_pcie(dev))
-		return;
-
 	pos = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ACS);
 	if (!pos)
 		return;
@@ -3178,15 +3035,10 @@ EXPORT_SYMBOL(pci_set_dma_seg_boundary);
 static int pcie_flr(struct pci_dev *dev, int probe)
 {
 	int i;
-	int pos;
 	u32 cap;
-	u16 status, control;
-
-	pos = pci_pcie_cap(dev);
-	if (!pos)
-		return -ENOTTY;
+	u16 status;
 
-	pci_read_config_dword(dev, pos + PCI_EXP_DEVCAP, &cap);
+	pcie_capability_read_dword(dev, PCI_EXP_DEVCAP, &cap);
 	if (!(cap & PCI_EXP_DEVCAP_FLR))
 		return -ENOTTY;
 
@@ -3198,7 +3050,7 @@ static int pcie_flr(struct pci_dev *dev, int probe)
 		if (i)
 			msleep((1 << (i - 1)) * 100);
 
-		pci_read_config_word(dev, pos + PCI_EXP_DEVSTA, &status);
+		pcie_capability_read_word(dev, PCI_EXP_DEVSTA, &status);
 		if (!(status & PCI_EXP_DEVSTA_TRPND))
 			goto clear;
 	}
@@ -3207,9 +3059,7 @@ static int pcie_flr(struct pci_dev *dev, int probe)
 			"proceeding with reset anyway\n");
 
 clear:
-	pci_read_config_word(dev, pos + PCI_EXP_DEVCTL, &control);
-	control |= PCI_EXP_DEVCTL_BCR_FLR;
-	pci_write_config_word(dev, pos + PCI_EXP_DEVCTL, control);
+	pcie_capability_set_word(dev, PCI_EXP_DEVCTL, PCI_EXP_DEVCTL_BCR_FLR);
 
 	msleep(100);
 
@@ -3577,18 +3427,11 @@ EXPORT_SYMBOL(pcix_set_mmrbc);
  */
 int pcie_get_readrq(struct pci_dev *dev)
 {
-	int ret, cap;
 	u16 ctl;
 
-	cap = pci_pcie_cap(dev);
-	if (!cap)
-		return -EINVAL;
-
-	ret = pci_read_config_word(dev, cap + PCI_EXP_DEVCTL, &ctl);
-	if (!ret)
-		ret = 128 << ((ctl & PCI_EXP_DEVCTL_READRQ) >> 12);
+	pcie_capability_read_word(dev, PCI_EXP_DEVCTL, &ctl);
 
-	return ret;
+	return 128 << ((ctl & PCI_EXP_DEVCTL_READRQ) >> 12);
 }
 EXPORT_SYMBOL(pcie_get_readrq);
 
@@ -3602,19 +3445,11 @@ EXPORT_SYMBOL(pcie_get_readrq);
  */
 int pcie_set_readrq(struct pci_dev *dev, int rq)
 {
-	int cap, err = -EINVAL;
-	u16 ctl, v;
+	u16 v;
 
 	if (rq < 128 || rq > 4096 || !is_power_of_2(rq))
-		goto out;
-
-	cap = pci_pcie_cap(dev);
-	if (!cap)
-		goto out;
+		return -EINVAL;
 
-	err = pci_read_config_word(dev, cap + PCI_EXP_DEVCTL, &ctl);
-	if (err)
-		goto out;
 	/*
 	 * If using the "performance" PCIe config, we clamp the
 	 * read rq size to the max packet size to prevent the
@@ -3632,14 +3467,8 @@ int pcie_set_readrq(struct pci_dev *dev, int rq)
 
 	v = (ffs(rq) - 8) << 12;
 
-	if ((ctl & PCI_EXP_DEVCTL_READRQ) != v) {
-		ctl &= ~PCI_EXP_DEVCTL_READRQ;
-		ctl |= v;
-		err = pci_write_config_word(dev, cap + PCI_EXP_DEVCTL, ctl);
-	}
-
-out:
-	return err;
+	return pcie_capability_clear_and_set_word(dev, PCI_EXP_DEVCTL,
+						  PCI_EXP_DEVCTL_READRQ, v);
 }
 EXPORT_SYMBOL(pcie_set_readrq);
 
@@ -3652,18 +3481,11 @@ EXPORT_SYMBOL(pcie_set_readrq);
  */
 int pcie_get_mps(struct pci_dev *dev)
 {
-	int ret, cap;
 	u16 ctl;
 
-	cap = pci_pcie_cap(dev);
-	if (!cap)
-		return -EINVAL;
-
-	ret = pci_read_config_word(dev, cap + PCI_EXP_DEVCTL, &ctl);
-	if (!ret)
-		ret = 128 << ((ctl & PCI_EXP_DEVCTL_PAYLOAD) >> 5);
+	pcie_capability_read_word(dev, PCI_EXP_DEVCTL, &ctl);
 
-	return ret;
+	return 128 << ((ctl & PCI_EXP_DEVCTL_PAYLOAD) >> 5);
 }
 
 /**
@@ -3676,32 +3498,18 @@ int pcie_get_mps(struct pci_dev *dev)
  */
 int pcie_set_mps(struct pci_dev *dev, int mps)
 {
-	int cap, err = -EINVAL;
-	u16 ctl, v;
+	u16 v;
 
 	if (mps < 128 || mps > 4096 || !is_power_of_2(mps))
-		goto out;
+		return -EINVAL;
 
 	v = ffs(mps) - 8;
 	if (v > dev->pcie_mpss) 
-		goto out;
+		return -EINVAL;
 	v <<= 5;
 
-	cap = pci_pcie_cap(dev);
-	if (!cap)
-		goto out;
-
-	err = pci_read_config_word(dev, cap + PCI_EXP_DEVCTL, &ctl);
-	if (err)
-		goto out;
-
-	if ((ctl & PCI_EXP_DEVCTL_PAYLOAD) != v) {
-		ctl &= ~PCI_EXP_DEVCTL_PAYLOAD;
-		ctl |= v;
-		err = pci_write_config_word(dev, cap + PCI_EXP_DEVCTL, ctl);
-	}
-out:
-	return err;
+	return pcie_capability_clear_and_set_word(dev, PCI_EXP_DEVCTL,
+						  PCI_EXP_DEVCTL_PAYLOAD, v);
 }
 
 /**

commit 62f87c0e31d646d5501edf4f7feb07d0ad689d80
Author: Yijing Wang <wangyijing@huawei.com>
Date:   Tue Jul 24 17:20:03 2012 +0800

    PCI: Introduce pci_pcie_type(dev) to replace pci_dev->pcie_type
    
    Introduce an inline function pci_pcie_type(dev) to extract PCIe
    device type from pci_dev->pcie_flags_reg field, and prepare for
    removing pci_dev->pcie_type.
    
    Signed-off-by: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Jiang Liu <jiang.liu@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index f3ea977a5b1b..28eb55b77ee9 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -885,7 +885,7 @@ static struct pci_cap_saved_state *pci_find_saved_cap(
 
 static int pci_save_pcie_state(struct pci_dev *dev)
 {
-	int pos, i = 0;
+	int type, pos, i = 0;
 	struct pci_cap_saved_state *save_state;
 	u16 *cap;
 	u16 flags;
@@ -903,13 +903,14 @@ static int pci_save_pcie_state(struct pci_dev *dev)
 
 	pci_read_config_word(dev, pos + PCI_EXP_FLAGS, &flags);
 
-	if (pcie_cap_has_devctl(dev->pcie_type, flags))
+	type = pci_pcie_type(dev);
+	if (pcie_cap_has_devctl(type, flags))
 		pci_read_config_word(dev, pos + PCI_EXP_DEVCTL, &cap[i++]);
-	if (pcie_cap_has_lnkctl(dev->pcie_type, flags))
+	if (pcie_cap_has_lnkctl(type, flags))
 		pci_read_config_word(dev, pos + PCI_EXP_LNKCTL, &cap[i++]);
-	if (pcie_cap_has_sltctl(dev->pcie_type, flags))
+	if (pcie_cap_has_sltctl(type, flags))
 		pci_read_config_word(dev, pos + PCI_EXP_SLTCTL, &cap[i++]);
-	if (pcie_cap_has_rtctl(dev->pcie_type, flags))
+	if (pcie_cap_has_rtctl(type, flags))
 		pci_read_config_word(dev, pos + PCI_EXP_RTCTL, &cap[i++]);
 
 	pos = pci_pcie_cap2(dev);
@@ -924,7 +925,7 @@ static int pci_save_pcie_state(struct pci_dev *dev)
 
 static void pci_restore_pcie_state(struct pci_dev *dev)
 {
-	int i = 0, pos;
+	int i = 0, pos, type;
 	struct pci_cap_saved_state *save_state;
 	u16 *cap;
 	u16 flags;
@@ -937,13 +938,14 @@ static void pci_restore_pcie_state(struct pci_dev *dev)
 
 	pci_read_config_word(dev, pos + PCI_EXP_FLAGS, &flags);
 
-	if (pcie_cap_has_devctl(dev->pcie_type, flags))
+	type = pci_pcie_type(dev);
+	if (pcie_cap_has_devctl(type, flags))
 		pci_write_config_word(dev, pos + PCI_EXP_DEVCTL, cap[i++]);
-	if (pcie_cap_has_lnkctl(dev->pcie_type, flags))
+	if (pcie_cap_has_lnkctl(type, flags))
 		pci_write_config_word(dev, pos + PCI_EXP_LNKCTL, cap[i++]);
-	if (pcie_cap_has_sltctl(dev->pcie_type, flags))
+	if (pcie_cap_has_sltctl(type, flags))
 		pci_write_config_word(dev, pos + PCI_EXP_SLTCTL, cap[i++]);
-	if (pcie_cap_has_rtctl(dev->pcie_type, flags))
+	if (pcie_cap_has_rtctl(type, flags))
 		pci_write_config_word(dev, pos + PCI_EXP_RTCTL, cap[i++]);
 
 	pos = pci_pcie_cap2(dev);
@@ -2459,8 +2461,8 @@ bool pci_acs_enabled(struct pci_dev *pdev, u16 acs_flags)
 		acs_flags &= (PCI_ACS_RR | PCI_ACS_CR |
 			      PCI_ACS_EC | PCI_ACS_DT);
 
-	if (pdev->pcie_type == PCI_EXP_TYPE_DOWNSTREAM ||
-	    pdev->pcie_type == PCI_EXP_TYPE_ROOT_PORT ||
+	if (pci_pcie_type(pdev) == PCI_EXP_TYPE_DOWNSTREAM ||
+	    pci_pcie_type(pdev) == PCI_EXP_TYPE_ROOT_PORT ||
 	    pdev->multifunction) {
 		pos = pci_find_ext_capability(pdev, PCI_EXT_CAP_ID_ACS);
 		if (!pos)

commit 44a9a36f6be43636ac2342c06d9feb60db77826a
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Jul 13 14:24:59 2012 -0600

    PCI: Add pci_find_next_ext_capability()
    
    Some extended capabilities, e.g., the vendor-specific capability, can
    occur several times.  The existing pci_find_ext_capability() only finds
    the first occurrence.  This adds pci_find_next_ext_capability(), which
    can iterate through all of them.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index f3ea977a5b1b..d34415ba0f64 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -286,20 +286,17 @@ static int pci_pcie_cap2(struct pci_dev *dev)
 }
 
 /**
- * pci_find_ext_capability - Find an extended capability
+ * pci_find_next_ext_capability - Find an extended capability
  * @dev: PCI device to query
+ * @start: address at which to start looking (0 to start at beginning of list)
  * @cap: capability code
  *
- * Returns the address of the requested extended capability structure
+ * Returns the address of the next matching extended capability structure
  * within the device's PCI configuration space or 0 if the device does
- * not support it.  Possible values for @cap:
- *
- *  %PCI_EXT_CAP_ID_ERR		Advanced Error Reporting
- *  %PCI_EXT_CAP_ID_VC		Virtual Channel
- *  %PCI_EXT_CAP_ID_DSN		Device Serial Number
- *  %PCI_EXT_CAP_ID_PWR		Power Budgeting
+ * not support it.  Some capabilities can occur several times, e.g., the
+ * vendor-specific capability, and this provides a way to find them all.
  */
-int pci_find_ext_capability(struct pci_dev *dev, int cap)
+int pci_find_next_ext_capability(struct pci_dev *dev, int start, int cap)
 {
 	u32 header;
 	int ttl;
@@ -311,6 +308,9 @@ int pci_find_ext_capability(struct pci_dev *dev, int cap)
 	if (dev->cfg_size <= PCI_CFG_SPACE_SIZE)
 		return 0;
 
+	if (start)
+		pos = start;
+
 	if (pci_read_config_dword(dev, pos, &header) != PCIBIOS_SUCCESSFUL)
 		return 0;
 
@@ -322,7 +322,7 @@ int pci_find_ext_capability(struct pci_dev *dev, int cap)
 		return 0;
 
 	while (ttl-- > 0) {
-		if (PCI_EXT_CAP_ID(header) == cap)
+		if (PCI_EXT_CAP_ID(header) == cap && pos != start)
 			return pos;
 
 		pos = PCI_EXT_CAP_NEXT(header);
@@ -335,6 +335,26 @@ int pci_find_ext_capability(struct pci_dev *dev, int cap)
 
 	return 0;
 }
+EXPORT_SYMBOL_GPL(pci_find_next_ext_capability);
+
+/**
+ * pci_find_ext_capability - Find an extended capability
+ * @dev: PCI device to query
+ * @cap: capability code
+ *
+ * Returns the address of the requested extended capability structure
+ * within the device's PCI configuration space or 0 if the device does
+ * not support it.  Possible values for @cap:
+ *
+ *  %PCI_EXT_CAP_ID_ERR		Advanced Error Reporting
+ *  %PCI_EXT_CAP_ID_VC		Virtual Channel
+ *  %PCI_EXT_CAP_ID_DSN		Device Serial Number
+ *  %PCI_EXT_CAP_ID_PWR		Power Budgeting
+ */
+int pci_find_ext_capability(struct pci_dev *dev, int cap)
+{
+	return pci_find_next_ext_capability(dev, 0, cap);
+}
 EXPORT_SYMBOL_GPL(pci_find_ext_capability);
 
 static int __pci_find_next_ht_cap(struct pci_dev *dev, int pos, int ht_cap)

commit ceaf5b5f03c8474064852dfa1a402905cf536fcf
Author: Randy Dunlap <rdunlap@xenotime.net>
Date:   Sat Aug 18 17:37:53 2012 -0700

    PCI: Fix drivers/pci/pci.c kernel-doc warnings
    
    Fix kernel-doc warnings in drivers/pci/pci.c:
    
    Warning(drivers/pci/pci.c:1550): No description found for parameter 'pci_dev'
    Warning(drivers/pci/pci.c:1550): Excess function parameter 'dev' description in 'pci_wakeup'
    
    Signed-off-by: Randy Dunlap <rdunlap@xenotime.net>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index f3ea977a5b1b..7adc6608b291 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1543,7 +1543,7 @@ void pci_pme_wakeup_bus(struct pci_bus *bus)
 
 /**
  * pci_wakeup - Wake up a PCI device
- * @dev: Device to handle.
+ * @pci_dev: Device to handle.
  * @ign: ignored parameter
  */
 static int pci_wakeup(struct pci_dev *pci_dev, void *ign)

commit 4f9c1397e2e80e52b17ec4e39760caa807bd15c7
Author: Huang Ying <ying.huang@intel.com>
Date:   Wed Aug 8 09:07:38 2012 +0800

    PCI/PM: Enable D3/D3cold by default for most devices
    
    This patch fixes the following bug:
    
    http://marc.info/?l=linux-usb&m=134318961120825&w=2
    
    Originally, device lower power states include D1, D2, D3.  After that,
    D3 is further divided into D3hot and D3cold.  To support both scenario
    safely, original D3 is mapped to D3cold.
    
    When adding D3cold support, because worry about some device may have
    broken D3cold support, D3cold is disabled by default.  This disable D3
    on original platform too.  But some original platform may only have
    working D3, but no working D1, D2.  The root cause of the above bug is
    it too.
    
    To deal with this, this patch enables D3/D3cold by default for most
    devices.  This restores the original behavior.  For some devices that
    suspected to have broken D3cold support, such as PCIe port, D3cold is
    disabled by default.
    
    Reported-by: Bjorn Mork <bjorn@mork.no>
    Signed-off-by: Huang Ying <ying.huang@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index f3ea977a5b1b..ab4bf5a4c2f1 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1941,6 +1941,7 @@ void pci_pm_init(struct pci_dev *dev)
 	dev->pm_cap = pm;
 	dev->d3_delay = PCI_PM_D3_WAIT;
 	dev->d3cold_delay = PCI_PM_D3COLD_WAIT;
+	dev->d3cold_allowed = true;
 
 	dev->d1_support = false;
 	dev->d2_support = false;

commit a7711ba1090a5fa1caa6e07182ac4e8e1c0da695
Merge: 85a00dd391d2 db288c9c5f9d
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Jul 5 16:29:52 2012 -0600

    Merge branch 'pci/rafael-pci_set_power_state-rebase' into next
    
    * pci/rafael-pci_set_power_state-rebase:
      PCI / PM: restore the original behavior of pci_set_power_state()

commit 85a00dd391d2de1e177c5ad8db5672428934ac20
Merge: 35e7f73c32ad 29e8d7bff2f5
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Jul 5 15:31:05 2012 -0600

    Merge branch 'pci/myron-pcibios_setup' into next
    
    * pci/myron-pcibios_setup:
      xtensa/PCI: factor out pcibios_setup()
      x86/PCI: adjust section annotations for pcibios_setup()
      unicore32/PCI: adjust section annotations for pcibios_setup()
      tile/PCI: factor out pcibios_setup()
      sparc/PCI: factor out pcibios_setup()
      sh/PCI: adjust section annotations for pcibios_setup()
      sh/PCI: factor out pcibios_setup()
      powerpc/PCI: factor out pcibios_setup()
      parisc/PCI: factor out pcibios_setup()
      MIPS/PCI: adjust section annotations for pcibios_setup()
      MIPS/PCI: factor out pcibios_setup()
      microblaze/PCI: factor out pcibios_setup()
      ia64/PCI: factor out pcibios_setup()
      cris/PCI: factor out pcibios_setup()
      alpha/PCI: factor out pcibios_setup()
      PCI: pull pcibios_setup() up into core

commit db288c9c5f9db45610dab3940377625132b4af41
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Jul 5 15:20:00 2012 -0600

    PCI / PM: restore the original behavior of pci_set_power_state()
    
    Commit cc2893b6 (PCI: Ensure we re-enable devices on resume)
    addressed the problem with USB not being powered after resume on
    recent Lenovo machines, but it did that in a suboptimal way.
    Namely, it should have changed the relevant code paths only,
    which are pci_pm_resume_noirq() and pci_pm_restore_noirq() supposed
    to restore the device's power and standard configuration registers
    after system resume from suspend or hibernation.  Instead, however,
    it modified pci_set_power_state() which is executed in several
    other situations too.  That resulted in some undesirable effects,
    like attempting to change a device's power state in the same way
    multiple times in a row (up to as many as 4 times in a row in the
    snd_hda_intel driver).
    
    Fix the bug addressed by commit cc2893b6 in an alternative way,
    by forcibly powering up all devices in pci_pm_default_resume_early(),
    which is called by pci_pm_resume_noirq() and pci_pm_restore_noirq()
    to restore the device's power and standard configuration registers,
    and modifying pci_pm_runtime_resume() to avoid the forcible power-up
    if not necessary.  Then, revert the changes made by commit cc2893b6
    to make the confusion introduced by it go away.
    
    Acked-by: Matthew Garrett <mjg@redhat.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 8effb9b23eec..acae2705e7f6 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -672,6 +672,19 @@ void pci_update_current_state(struct pci_dev *dev, pci_power_t state)
 	}
 }
 
+/**
+ * pci_power_up - Put the given device into D0 forcibly
+ * @dev: PCI device to power up
+ */
+void pci_power_up(struct pci_dev *dev)
+{
+	if (platform_pci_power_manageable(dev))
+		platform_pci_set_power_state(dev, PCI_D0);
+
+	pci_raw_set_power_state(dev, PCI_D0);
+	pci_update_current_state(dev, PCI_D0);
+}
+
 /**
  * pci_platform_power_transition - Use platform to change device power state
  * @dev: PCI device to handle.
@@ -762,7 +775,7 @@ int __pci_complete_power_transition(struct pci_dev *dev, pci_power_t state)
 {
 	int ret;
 
-	if (state < PCI_D0)
+	if (state <= PCI_D0)
 		return -EINVAL;
 	ret = pci_platform_power_transition(dev, state);
 	/* Power off the bridge may power off the whole hierarchy */
@@ -804,6 +817,10 @@ int pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 		 */
 		return 0;
 
+	/* Check if we're already there */
+	if (dev->current_state == state)
+		return 0;
+
 	__pci_start_power_transition(dev, state);
 
 	/* This device is quirked not to be put into D3, so

commit 2b6f2c3520124e8bad4bffa71f5b98e602b9cf03
Author: Myron Stowe <myron.stowe@redhat.com>
Date:   Mon Jun 25 21:30:57 2012 -0600

    PCI: pull pcibios_setup() up into core
    
    Currently, all of the architectures implement their own pcibios_setup()
    routine.  Most of the implementations do nothing so this patch introduces
    a generic (__weak) routine in the core that can be used by all
    architectures as a default.  If necessary, it can be overridden by
    architecture-specific code.
    
    Signed-off-by: Myron Stowe <myron.stowe@redhat.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 447e83472c01..c87d518acace 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2665,6 +2665,18 @@ static void __pci_set_master(struct pci_dev *dev, bool enable)
 	dev->is_busmaster = enable;
 }
 
+/**
+ * pcibios_setup - process "pci=" kernel boot arguments
+ * @str: string used to pass in "pci=" kernel boot arguments
+ *
+ * Process kernel boot arguments.  This is the default implementation.
+ * Architecture specific implementations can override this as necessary.
+ */
+char * __weak __init pcibios_setup(char *str)
+{
+	return str;
+}
+
 /**
  * pcibios_set_master - enable PCI bus-mastering for device dev
  * @dev: the PCI device to enable

commit 35e7f73c32ad44a931d918d04e317a7fb0c63e6e
Merge: e5028b52e46e 448bd857d48e
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Sat Jun 23 11:59:43 2012 -0600

    Merge branch 'topic/huang-d3cold-v7' into next
    
    * topic/huang-d3cold-v7:
      PCI/PM: add PCIe runtime D3cold support
      PCI: do not call pci_set_power_state with PCI_D3cold
      PCI/PM: add runtime PM support to PCIe port
      ACPI/PM: specify lowest allowed state for device sleep state

commit 448bd857d48e69b33ef323739dc6d8ca20d4cda7
Author: Huang Ying <ying.huang@intel.com>
Date:   Sat Jun 23 10:23:51 2012 +0800

    PCI/PM: add PCIe runtime D3cold support
    
    This patch adds runtime D3cold support and corresponding ACPI platform
    support.  This patch only enables runtime D3cold support; it does not
    enable D3cold support during system suspend/hibernate.
    
    D3cold is the deepest power saving state for a PCIe device, where its main
    power is removed.  While it is in D3cold, you can't access the device at
    all, not even its configuration space (which is still accessible in D3hot).
    Therefore the PCI PM registers can not be used to transition into/out of
    the D3cold state; that must be done by platform logic such as ACPI _PR3.
    
    To support wakeup from D3cold, a system may provide auxiliary power, which
    allows a device to request wakeup using a Beacon or the sideband WAKE#
    signal.  WAKE# is usually connected to platform logic such as ACPI GPE.
    This is quite different from other power saving states, where devices
    request wakeup via a PME message on the PCIe link.
    
    Some devices, such as those in plug-in slots, have no direct platform
    logic.  For example, there is usually no ACPI _PR3 for them.  D3cold
    support for these devices can be done via the PCIe Downstream Port leading
    to the device.  When the PCIe port is powered on/off, the device is powered
    on/off too.  Wakeup events from the device will be notified to the
    corresponding PCIe port.
    
    For more information about PCIe D3cold and corresponding ACPI support,
    please refer to:
    
    - PCI Express Base Specification Revision 2.0
    - Advanced Configuration and Power Interface Specification Revision 5.0
    
    [bhelgaas: changelog]
    Reviewed-by: Rafael J. Wysocki <rjw@sisk.pl>
    Originally-by: Zheng Yan <zheng.z.yan@intel.com>
    Signed-off-by: Huang Ying <ying.huang@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 9eae64b17954..8effb9b23eec 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -622,7 +622,8 @@ static int pci_raw_set_power_state(struct pci_dev *dev, pci_power_t state)
 		dev_info(&dev->dev, "Refused to change power state, "
 			"currently in D%d\n", dev->current_state);
 
-	/* According to section 5.4.1 of the "PCI BUS POWER MANAGEMENT
+	/*
+	 * According to section 5.4.1 of the "PCI BUS POWER MANAGEMENT
 	 * INTERFACE SPECIFICATION, REV. 1.2", a device transitioning
 	 * from D3hot to D0 _may_ perform an internal reset, thereby
 	 * going to "D0 Uninitialized" rather than "D0 Initialized".
@@ -654,6 +655,16 @@ void pci_update_current_state(struct pci_dev *dev, pci_power_t state)
 	if (dev->pm_cap) {
 		u16 pmcsr;
 
+		/*
+		 * Configuration space is not accessible for device in
+		 * D3cold, so just keep or set D3cold for safety
+		 */
+		if (dev->current_state == PCI_D3cold)
+			return;
+		if (state == PCI_D3cold) {
+			dev->current_state = PCI_D3cold;
+			return;
+		}
 		pci_read_config_word(dev, dev->pm_cap + PCI_PM_CTRL, &pmcsr);
 		dev->current_state = (pmcsr & PCI_PM_CTRL_STATE_MASK);
 	} else {
@@ -694,8 +705,50 @@ static int pci_platform_power_transition(struct pci_dev *dev, pci_power_t state)
  */
 static void __pci_start_power_transition(struct pci_dev *dev, pci_power_t state)
 {
-	if (state == PCI_D0)
+	if (state == PCI_D0) {
 		pci_platform_power_transition(dev, PCI_D0);
+		/*
+		 * Mandatory power management transition delays, see
+		 * PCI Express Base Specification Revision 2.0 Section
+		 * 6.6.1: Conventional Reset.  Do not delay for
+		 * devices powered on/off by corresponding bridge,
+		 * because have already delayed for the bridge.
+		 */
+		if (dev->runtime_d3cold) {
+			msleep(dev->d3cold_delay);
+			/*
+			 * When powering on a bridge from D3cold, the
+			 * whole hierarchy may be powered on into
+			 * D0uninitialized state, resume them to give
+			 * them a chance to suspend again
+			 */
+			pci_wakeup_bus(dev->subordinate);
+		}
+	}
+}
+
+/**
+ * __pci_dev_set_current_state - Set current state of a PCI device
+ * @dev: Device to handle
+ * @data: pointer to state to be set
+ */
+static int __pci_dev_set_current_state(struct pci_dev *dev, void *data)
+{
+	pci_power_t state = *(pci_power_t *)data;
+
+	dev->current_state = state;
+	return 0;
+}
+
+/**
+ * __pci_bus_set_current_state - Walk given bus and set current state of devices
+ * @bus: Top bus of the subtree to walk.
+ * @state: state to be set
+ */
+static void __pci_bus_set_current_state(struct pci_bus *bus, pci_power_t state)
+{
+	if (bus)
+		pci_walk_bus(bus, __pci_dev_set_current_state, &state);
 }
 
 /**
@@ -707,8 +760,15 @@ static void __pci_start_power_transition(struct pci_dev *dev, pci_power_t state)
  */
 int __pci_complete_power_transition(struct pci_dev *dev, pci_power_t state)
 {
-	return state >= PCI_D0 ?
-			pci_platform_power_transition(dev, state) : -EINVAL;
+	int ret;
+
+	if (state < PCI_D0)
+		return -EINVAL;
+	ret = pci_platform_power_transition(dev, state);
+	/* Power off the bridge may power off the whole hierarchy */
+	if (!ret && state == PCI_D3cold)
+		__pci_bus_set_current_state(dev->subordinate, PCI_D3cold);
+	return ret;
 }
 EXPORT_SYMBOL_GPL(__pci_complete_power_transition);
 
@@ -732,8 +792,8 @@ int pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 	int error;
 
 	/* bound the state we're entering */
-	if (state > PCI_D3hot)
-		state = PCI_D3hot;
+	if (state > PCI_D3cold)
+		state = PCI_D3cold;
 	else if (state < PCI_D0)
 		state = PCI_D0;
 	else if ((state == PCI_D1 || state == PCI_D2) && pci_no_d1d2(dev))
@@ -748,10 +808,15 @@ int pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 
 	/* This device is quirked not to be put into D3, so
 	   don't put it in D3 */
-	if (state == PCI_D3hot && (dev->dev_flags & PCI_DEV_FLAGS_NO_D3))
+	if (state >= PCI_D3hot && (dev->dev_flags & PCI_DEV_FLAGS_NO_D3))
 		return 0;
 
-	error = pci_raw_set_power_state(dev, state);
+	/*
+	 * To put device in D3cold, we put device into D3hot in native
+	 * way, then put device into D3cold with platform ops
+	 */
+	error = pci_raw_set_power_state(dev, state > PCI_D3hot ?
+					PCI_D3hot : state);
 
 	if (!__pci_complete_power_transition(dev, state))
 		error = 0;
@@ -1497,6 +1562,28 @@ void pci_pme_wakeup_bus(struct pci_bus *bus)
 		pci_walk_bus(bus, pci_pme_wakeup, (void *)true);
 }
 
+/**
+ * pci_wakeup - Wake up a PCI device
+ * @dev: Device to handle.
+ * @ign: ignored parameter
+ */
+static int pci_wakeup(struct pci_dev *pci_dev, void *ign)
+{
+	pci_wakeup_event(pci_dev);
+	pm_request_resume(&pci_dev->dev);
+	return 0;
+}
+
+/**
+ * pci_wakeup_bus - Walk given bus and wake up devices on it
+ * @bus: Top bus of the subtree to walk.
+ */
+void pci_wakeup_bus(struct pci_bus *bus)
+{
+	if (bus)
+		pci_walk_bus(bus, pci_wakeup, NULL);
+}
+
 /**
  * pci_pme_capable - check the capability of PCI device to generate PME#
  * @dev: PCI device to handle.
@@ -1754,6 +1841,10 @@ int pci_prepare_to_sleep(struct pci_dev *dev)
 	if (target_state == PCI_POWER_ERROR)
 		return -EIO;
 
+	/* D3cold during system suspend/hibernate is not supported */
+	if (target_state > PCI_D3hot)
+		target_state = PCI_D3hot;
+
 	pci_enable_wake(dev, target_state, device_may_wakeup(&dev->dev));
 
 	error = pci_set_power_state(dev, target_state);
@@ -1791,12 +1882,16 @@ int pci_finish_runtime_suspend(struct pci_dev *dev)
 	if (target_state == PCI_POWER_ERROR)
 		return -EIO;
 
+	dev->runtime_d3cold = target_state == PCI_D3cold;
+
 	__pci_enable_wake(dev, target_state, true, pci_dev_run_wake(dev));
 
 	error = pci_set_power_state(dev, target_state);
 
-	if (error)
+	if (error) {
 		__pci_enable_wake(dev, target_state, true, false);
+		dev->runtime_d3cold = false;
+	}
 
 	return error;
 }
@@ -1866,6 +1961,7 @@ void pci_pm_init(struct pci_dev *dev)
 
 	dev->pm_cap = pm;
 	dev->d3_delay = PCI_PM_D3_WAIT;
+	dev->d3cold_delay = PCI_PM_D3COLD_WAIT;
 
 	dev->d1_support = false;
 	dev->d2_support = false;

commit 71a83bd727cc31c5fe960c3758cb396267ff710e
Author: Zheng Yan <zheng.z.yan@intel.com>
Date:   Sat Jun 23 10:23:49 2012 +0800

    PCI/PM: add runtime PM support to PCIe port
    
    This patch adds runtime PM support to PCIe port.  This is needed by
    PCIe D3cold support, where PCIe device without ACPI node may be
    powered on/off by PCIe port.
    
    Because runtime suspend is broken for some chipsets, a black list is
    used to disable runtime PM support for these chipsets.
    
    Reviewed-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Zheng Yan <zheng.z.yan@intel.com>
    Signed-off-by: Huang Ying <ying.huang@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 447e83472c01..9eae64b17954 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1518,6 +1518,16 @@ static void pci_pme_list_scan(struct work_struct *work)
 	if (!list_empty(&pci_pme_list)) {
 		list_for_each_entry_safe(pme_dev, n, &pci_pme_list, list) {
 			if (pme_dev->dev->pme_poll) {
+				struct pci_dev *bridge;
+
+				bridge = pme_dev->dev->bus->self;
+				/*
+				 * If bridge is in low power state, the
+				 * configuration space of subordinate devices
+				 * may be not accessible
+				 */
+				if (bridge && bridge->current_state != PCI_D0)
+					continue;
 				pci_pme_wakeup(pme_dev->dev, NULL);
 			} else {
 				list_del(&pme_dev->list);

commit 0f6662a49bf1b5a163ed4e6321c382d2390c817b
Merge: 1693c4276d76 809a3bf9f34c
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Jun 22 15:32:50 2012 -0600

    Merge branch 'topic/bjorn-trivial' into next
    
    * topic/bjorn-trivial:
      PCI: remove useless pcix_set_mmrbc() dev->bus check
      PCI: acpiphp: check whether _ADR evaluation succeeded
      PCI: shpchp: remove dead code
      PCI: fix P2P bridge I/O port window sign extension
      PCI: fix upstream P2P bridge checks when enabling OBFF and LTR
      PCI: use __weak consistently
      PCI: cleanup assign_requested_resources_sorted() kernel-doc warning
      sparc/PCI: remove unused pcibios_assign_resource() definition

commit 809a3bf9f34cb6d0c0383b31b3495fa1ed3508a6
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Jun 20 16:41:16 2012 -0600

    PCI: remove useless pcix_set_mmrbc() dev->bus check
    
    For a valid pci_dev, dev->bus != NULL always, so remove this
    unnecessary test.
    
    Found by Coverity (CID 101680).
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index b9e93cf1eb40..7f1310e58534 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -3395,8 +3395,7 @@ int pcix_set_mmrbc(struct pci_dev *dev, int mmrbc)
 
 	o = (cmd & PCI_X_CMD_MAX_READ) >> 2;
 	if (o != v) {
-		if (v > o && dev->bus &&
-		   (dev->bus->bus_flags & PCI_BUS_FLAGS_NO_MMRBC))
+		if (v > o && (dev->bus->bus_flags & PCI_BUS_FLAGS_NO_MMRBC))
 			return -EIO;
 
 		cmd &= ~PCI_X_CMD_MAX_READ;

commit 8291550f8479fde2cee571d1b367e6918819f189
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Jun 19 07:35:34 2012 -0600

    PCI: fix upstream P2P bridge checks when enabling OBFF and LTR
    
    pci_enable_obff() and pci_enable_ltr() incorrectly check "dev->bus" instead
    of "dev->bus->self" to determine whether the upstream device is a P2P
    bridge or a host bridge.  For devices on the root bus, the upstream device
    is a host bridge, "dev->bus != NULL" and "dev->bus->self == NULL", and we
    panic with a null pointer dereference.
    
    These functions should previously have panicked when called on devices
    supporting OBFF or LTR, so they should be regarded as untested.
    
    Found by Coverity (CID 143038 and CID 143039).
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 8f4a5ea543fc..b9e93cf1eb40 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2108,7 +2108,7 @@ int pci_enable_obff(struct pci_dev *dev, enum pci_obff_signal_type type)
 		return -ENOTSUPP; /* no OBFF support at all */
 
 	/* Make sure the topology supports OBFF as well */
-	if (dev->bus) {
+	if (dev->bus->self) {
 		ret = pci_enable_obff(dev->bus->self, type);
 		if (ret)
 			return ret;
@@ -2215,7 +2215,7 @@ int pci_enable_ltr(struct pci_dev *dev)
 		return -EINVAL;
 
 	/* Enable upstream ports first */
-	if (dev->bus) {
+	if (dev->bus->self) {
 		ret = pci_enable_ltr(dev->bus->self);
 		if (ret)
 			return ret;

commit d6d88c832eaea6c6947ddf7b664601930a9f8a14
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Jun 19 06:54:49 2012 -0600

    PCI: use __weak consistently
    
    Use "__weak" instead of the gcc-specific "__attribute__ ((weak))"
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 447e83472c01..8f4a5ea543fc 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1349,7 +1349,7 @@ void pcim_pin_device(struct pci_dev *pdev)
  * is the default implementation. Architecture implementations can
  * override this.
  */
-void __attribute__ ((weak)) pcibios_disable_device (struct pci_dev *dev) {}
+void __weak pcibios_disable_device (struct pci_dev *dev) {}
 
 static void do_pci_disable_device(struct pci_dev *dev)
 {
@@ -1413,8 +1413,8 @@ pci_disable_device(struct pci_dev *dev)
  * Sets the PCIe reset state for the device. This is the default
  * implementation. Architecture implementations can override this.
  */
-int __attribute__ ((weak)) pcibios_set_pcie_reset_state(struct pci_dev *dev,
-							enum pcie_reset_state state)
+int __weak pcibios_set_pcie_reset_state(struct pci_dev *dev,
+					enum pcie_reset_state state)
 {
 	return -EINVAL;
 }
@@ -3851,7 +3851,7 @@ static void __devinit pci_no_domains(void)
  * greater than 0xff). This is the default implementation. Architecture
  * implementations can override this.
  */
-int __attribute__ ((weak)) pci_ext_cfg_avail(struct pci_dev *dev)
+int __weak pci_ext_cfg_avail(struct pci_dev *dev)
 {
 	return 1;
 }

commit 140217ae3fbabc7b718b5595fd251ce2afcb3bc1
Merge: e822a007047f 0bdb3b213ac6
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Jun 18 12:14:16 2012 -0600

    Merge branch 'topic/jan-intx-masking' into next
    
    * topic/jan-intx-masking:
      PCI: add Ralink RT2800 broken INTx masking quirk
      PCI: add Chelsio T310 10GbE NIC broken INTx masking quirk
      PCI: add infrastructure for devices with broken INTx masking

commit 47fcb6da65e9e74f71f4ec68f1245fc600bec711
Merge: cc2fa3fa320d 9cb604ed45a3
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Jun 18 12:10:39 2012 -0600

    Merge branch 'topic/stowe-cap-cleanup' into next
    
    * topic/stowe-cap-cleanup:
      PCI: remove redundant capabilities checking in pci_{save, restore}_pcie_state
      PCI: add pci_pcie_cap2() check for PCIe feature capabilities >= v2
      PCI: remove redundant checking in PCI Express capability routines
      PCI: make pci_ltr_supported() static

commit fbebb9fd22581b6422d60669c4ff86ce99d6cdba
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Sat Jun 16 14:40:22 2012 -0600

    PCI: add infrastructure for devices with broken INTx masking
    
    pci_intx_mask_supported() assumes INTx masking is supported if the
    PCI_COMMAND_INTX_DISABLE bit is writable.  But when that bit is set,
    some devices don't actually mask INTx or update PCI_STATUS_INTERRUPT
    as we expect.
    
    This patch adds a way for quirks to identify these broken devices.
    
    [bhelgaas: split out from Chelsio quirk addition]
    Signed-off-by: Jan Kiszka <jan.kiszka@siemens.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 447e83472c01..9ae517a68360 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2876,6 +2876,9 @@ bool pci_intx_mask_supported(struct pci_dev *dev)
 	bool mask_supported = false;
 	u16 orig, new;
 
+	if (dev->broken_intx_masking)
+		return false;
+
 	pci_cfg_access_lock(dev);
 
 	pci_read_config_word(dev, PCI_COMMAND, &orig);

commit cc2fa3fa320d5f40a12713c104bbe5d3da4636e4
Merge: 10c480933d0a a0dee2ed0cdc
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Jun 13 17:04:54 2012 -0600

    Merge branch 'topic/alex-vfio-prep' into next
    
    * topic/alex-vfio-prep:
      PCI: misc pci_reg additions
      PCI: create common pcibios_err_to_errno
      PCI: export pci_user functions for use by other drivers
      PCI: add ACS validation utility
      PCI: add PCI DMA source ID quirk

commit 10c480933d0ad2ea27630cbaa723a5d33dbece00
Merge: a187177ae047 505cf30b7f4e
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Jun 13 17:04:51 2012 -0600

    Merge branch 'topic/bjorn-remove-unused' into next
    
    * topic/bjorn-remove-unused:
      PCI/AER: use pci_is_pcie() instead of obsolete pci_dev.is_pcie
      PCI: remove pci_max_busnr() (was already commented out)
      PCI: remove pci_bus_find_ext_capability() (unused)

commit b918c62e086b2130a7bae44110ca516ef10bfe5a
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Thu May 17 18:51:11 2012 -0700

    PCI: replace struct pci_bus secondary/subordinate with busn_res
    
    Replace the struct pci_bus secondary/subordinate members with the
    struct resource busn_res.  Later we'll build a resource tree of these
    bus numbers.
    
    [bhelgaas: changelog]
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 447e83472c01..aeda6e9c245c 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -110,7 +110,7 @@ unsigned char pci_bus_max_busnr(struct pci_bus* bus)
 	struct list_head *tmp;
 	unsigned char max, n;
 
-	max = bus->subordinate;
+	max = bus->busn_res.end;
 	list_for_each(tmp, &bus->children) {
 		n = pci_bus_max_busnr(pci_bus_b(tmp));
 		if(n > max)

commit ad805758c0eb25bce7b2e3b298d63dc62a1bc71c
Author: Alex Williamson <alex.williamson@redhat.com>
Date:   Mon Jun 11 05:27:07 2012 +0000

    PCI: add ACS validation utility
    
    In a PCI environment, transactions aren't always required to reach
    the root bus before being re-routed.  Intermediate switches between
    an endpoint and the root bus can redirect DMA back downstream before
    things like IOMMUs have a chance to intervene.  Legacy PCI is always
    susceptible to this as it operates on a shared bus.  PCIe added a
    new capability to describe and control this behavior, Access Control
    Services, or ACS.
    
    The utility function pci_acs_enabled() allows us to test the ACS
    capabilities of an individual devices against a set of flags while
    pci_acs_path_enabled() tests a complete path from a given downstream
    device up to the specified upstream device.  We also include the
    ability to add device specific tests as it's likely we'll see
    devices that do not implement ACS, but want to indicate support
    for various capabilities in this space.
    
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 447e83472c01..1ccf7d49f522 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2359,6 +2359,75 @@ void pci_enable_acs(struct pci_dev *dev)
 	pci_write_config_word(dev, pos + PCI_ACS_CTRL, ctrl);
 }
 
+/**
+ * pci_acs_enabled - test ACS against required flags for a given device
+ * @pdev: device to test
+ * @acs_flags: required PCI ACS flags
+ *
+ * Return true if the device supports the provided flags.  Automatically
+ * filters out flags that are not implemented on multifunction devices.
+ */
+bool pci_acs_enabled(struct pci_dev *pdev, u16 acs_flags)
+{
+	int pos, ret;
+	u16 ctrl;
+
+	ret = pci_dev_specific_acs_enabled(pdev, acs_flags);
+	if (ret >= 0)
+		return ret > 0;
+
+	if (!pci_is_pcie(pdev))
+		return false;
+
+	/* Filter out flags not applicable to multifunction */
+	if (pdev->multifunction)
+		acs_flags &= (PCI_ACS_RR | PCI_ACS_CR |
+			      PCI_ACS_EC | PCI_ACS_DT);
+
+	if (pdev->pcie_type == PCI_EXP_TYPE_DOWNSTREAM ||
+	    pdev->pcie_type == PCI_EXP_TYPE_ROOT_PORT ||
+	    pdev->multifunction) {
+		pos = pci_find_ext_capability(pdev, PCI_EXT_CAP_ID_ACS);
+		if (!pos)
+			return false;
+
+		pci_read_config_word(pdev, pos + PCI_ACS_CTRL, &ctrl);
+		if ((ctrl & acs_flags) != acs_flags)
+			return false;
+	}
+
+	return true;
+}
+
+/**
+ * pci_acs_path_enable - test ACS flags from start to end in a hierarchy
+ * @start: starting downstream device
+ * @end: ending upstream device or NULL to search to the root bus
+ * @acs_flags: required flags
+ *
+ * Walk up a device tree from start to end testing PCI ACS support.  If
+ * any step along the way does not support the required flags, return false.
+ */
+bool pci_acs_path_enabled(struct pci_dev *start,
+			  struct pci_dev *end, u16 acs_flags)
+{
+	struct pci_dev *pdev, *parent = start;
+
+	do {
+		pdev = parent;
+
+		if (!pci_acs_enabled(pdev, acs_flags))
+			return false;
+
+		if (pci_is_root_bus(pdev->bus))
+			return (end == NULL);
+
+		parent = pdev->bus->self;
+	} while (pdev != end);
+
+	return true;
+}
+
 /**
  * pci_swizzle_interrupt_pin - swizzle INTx for device behind bridge
  * @dev: the PCI device

commit 9cb604ed45a31419bab3877472691a5da15a3c47
Author: Myron Stowe <myron.stowe@redhat.com>
Date:   Fri Jun 1 15:16:43 2012 -0600

    PCI: remove redundant capabilities checking in pci_{save, restore}_pcie_state
    
    Unlike PCI Express v1's Capabilities Structure, v2's requires the entire
    structure to be implemented.  In v2 structures, register fields that
    are not implemented are present but hardwired to 0x0.  These may
    include: Link Capabilities, Status, and Control; Slot Capabilities,
    Status, and Control; Root Capabilities, Status, and Control; and all of
    the '2' (Device, Link, and Slot) Capabilities, Status, and Control
    registers.
    
    This patch removes the redundant capability checks corresponding to the
    Link 2's and Slot 2's, Capabilities, Status, and Control registers as they
    will be present if Device Capabilities 2's registers are (which explains
    why the macros for each of the three are identical).
    
    Signed-off-by: Myron Stowe <myron.stowe@redhat.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 985df63aa59f..fe26df7cf5cd 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -854,12 +854,6 @@ EXPORT_SYMBOL(pci_choose_state);
 		((flags & PCI_EXP_FLAGS_VERS) > 1 ||	\
 		 (type == PCI_EXP_TYPE_ROOT_PORT ||	\
 		  type == PCI_EXP_TYPE_RC_EC))
-#define pcie_cap_has_devctl2(type, flags)		\
-		((flags & PCI_EXP_FLAGS_VERS) > 1)
-#define pcie_cap_has_lnkctl2(type, flags)		\
-		((flags & PCI_EXP_FLAGS_VERS) > 1)
-#define pcie_cap_has_sltctl2(type, flags)		\
-		((flags & PCI_EXP_FLAGS_VERS) > 1)
 
 static struct pci_cap_saved_state *pci_find_saved_cap(
 	struct pci_dev *pci_dev, char cap)
@@ -902,13 +896,14 @@ static int pci_save_pcie_state(struct pci_dev *dev)
 		pci_read_config_word(dev, pos + PCI_EXP_SLTCTL, &cap[i++]);
 	if (pcie_cap_has_rtctl(dev->pcie_type, flags))
 		pci_read_config_word(dev, pos + PCI_EXP_RTCTL, &cap[i++]);
-	if (pcie_cap_has_devctl2(dev->pcie_type, flags))
-		pci_read_config_word(dev, pos + PCI_EXP_DEVCTL2, &cap[i++]);
-	if (pcie_cap_has_lnkctl2(dev->pcie_type, flags))
-		pci_read_config_word(dev, pos + PCI_EXP_LNKCTL2, &cap[i++]);
-	if (pcie_cap_has_sltctl2(dev->pcie_type, flags))
-		pci_read_config_word(dev, pos + PCI_EXP_SLTCTL2, &cap[i++]);
 
+	pos = pci_pcie_cap2(dev);
+	if (!pos)
+		return 0;
+
+	pci_read_config_word(dev, pos + PCI_EXP_DEVCTL2, &cap[i++]);
+	pci_read_config_word(dev, pos + PCI_EXP_LNKCTL2, &cap[i++]);
+	pci_read_config_word(dev, pos + PCI_EXP_SLTCTL2, &cap[i++]);
 	return 0;
 }
 
@@ -935,12 +930,14 @@ static void pci_restore_pcie_state(struct pci_dev *dev)
 		pci_write_config_word(dev, pos + PCI_EXP_SLTCTL, cap[i++]);
 	if (pcie_cap_has_rtctl(dev->pcie_type, flags))
 		pci_write_config_word(dev, pos + PCI_EXP_RTCTL, cap[i++]);
-	if (pcie_cap_has_devctl2(dev->pcie_type, flags))
-		pci_write_config_word(dev, pos + PCI_EXP_DEVCTL2, cap[i++]);
-	if (pcie_cap_has_lnkctl2(dev->pcie_type, flags))
-		pci_write_config_word(dev, pos + PCI_EXP_LNKCTL2, cap[i++]);
-	if (pcie_cap_has_sltctl2(dev->pcie_type, flags))
-		pci_write_config_word(dev, pos + PCI_EXP_SLTCTL2, cap[i++]);
+
+	pos = pci_pcie_cap2(dev);
+	if (!pos)
+		return;
+
+	pci_write_config_word(dev, pos + PCI_EXP_DEVCTL2, cap[i++]);
+	pci_write_config_word(dev, pos + PCI_EXP_LNKCTL2, cap[i++]);
+	pci_write_config_word(dev, pos + PCI_EXP_SLTCTL2, cap[i++]);
 }
 
 

commit c463b8cb9350cf1230cefe467a1cf279140a5437
Author: Myron Stowe <myron.stowe@redhat.com>
Date:   Fri Jun 1 15:16:37 2012 -0600

    PCI: add pci_pcie_cap2() check for PCIe feature capabilities >= v2
    
    This patch resolves potential issues when accessing PCI Express
    Capability structures.  The makeup of the capability varies
    substantially between v1 and v2:
    
        Version 1 of the PCI Express Capability (defined by PCI Express
        1.0 and 1.1 base) neither requires the endpoint to implement the
        entire PCIe capability structure nor specifies default values of
        registers that are not implemented by the device.
    
        Version 2 of the PCI Express Capability (defined by PCIe 1.1
        Capability Structure Expansion ECN, PCIe 2.0, 2.1, and 3.0) added
        additional registers to the structure and requires all registers
        to be either implemented or hardwired to 0.
    
    Due to the differences in the capability structures, code dealing with
    capability features must be careful not to access the additional
    registers introduced with v2 unless the device is specifically known to
    be a v2 capable device.  Otherwise, attempts to access non-existant
    registers will occur.  This is a subtle issue that is hard to track down
    when it occurs (and it has - see commit 864d296cf94).
    
    To try and help mitigate such occurrences, this patch introduces
    pci_pcie_cap2() which is similar to pci_pcie_cap() but also checks
    that the PCIe capability version is >= 2.  pci_pcie_cap2() should be
    used for qualifying PCIe capability features introduced after v1.
    
    Suggested by Don Dutile.
    
    Acked-by: Donald Dutile <ddutile@redhat.com>
    Signed-off-by: Myron Stowe <myron.stowe@redhat.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 766bb13bb0a3..985df63aa59f 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -277,6 +277,38 @@ int pci_bus_find_capability(struct pci_bus *bus, unsigned int devfn, int cap)
 	return pos;
 }
 
+/**
+ * pci_pcie_cap2 - query for devices' PCI_CAP_ID_EXP v2 capability structure
+ * @dev: PCI device to check
+ *
+ * Like pci_pcie_cap() but also checks that the PCIe capability version is
+ * >= 2.  Note that v1 capability structures could be sparse in that not
+ * all register fields were required.  v2 requires the entire structure to
+ * be present size wise, while still allowing for non-implemented registers
+ * to exist but they must be hardwired to 0.
+ *
+ * Due to the differences in the versions of capability structures, one
+ * must be careful not to try and access non-existant registers that may
+ * exist in early versions - v1 - of Express devices.
+ *
+ * Returns the offset of the PCIe capability structure as long as the
+ * capability version is >= 2; otherwise 0 is returned.
+ */
+static int pci_pcie_cap2(struct pci_dev *dev)
+{
+	u16 flags;
+	int pos;
+
+	pos = pci_pcie_cap(dev);
+	if (pos) {
+		pci_read_config_word(dev, pos + PCI_EXP_FLAGS, &flags);
+		if ((flags & PCI_EXP_FLAGS_VERS) < 2)
+			pos = 0;
+	}
+
+	return pos;
+}
+
 /**
  * pci_find_ext_capability - Find an extended capability
  * @dev: PCI device to query
@@ -1983,7 +2015,7 @@ void pci_enable_ari(struct pci_dev *dev)
 {
 	int pos;
 	u32 cap;
-	u16 flags, ctrl;
+	u16 ctrl;
 	struct pci_dev *bridge;
 
 	if (pcie_ari_disabled || !pci_is_pcie(dev) || dev->devfn)
@@ -1997,15 +2029,11 @@ void pci_enable_ari(struct pci_dev *dev)
 	if (!bridge)
 		return;
 
-	pos = pci_pcie_cap(bridge);
+	/* ARI is a PCIe cap v2 feature */
+	pos = pci_pcie_cap2(bridge);
 	if (!pos)
 		return;
 
-	/* ARI is a PCIe v2 feature */
-	pci_read_config_word(bridge, pos + PCI_EXP_FLAGS, &flags);
-	if ((flags & PCI_EXP_FLAGS_VERS) < 2)
-		return;
-
 	pci_read_config_dword(bridge, pos + PCI_EXP_DEVCAP2, &cap);
 	if (!(cap & PCI_EXP_DEVCAP2_ARI))
 		return;
@@ -2018,7 +2046,7 @@ void pci_enable_ari(struct pci_dev *dev)
 }
 
 /**
- * pci_enable_ido - enable ID-based ordering on a device
+ * pci_enable_ido - enable ID-based Ordering on a device
  * @dev: the PCI device
  * @type: which types of IDO to enable
  *
@@ -2031,7 +2059,8 @@ void pci_enable_ido(struct pci_dev *dev, unsigned long type)
 	int pos;
 	u16 ctrl;
 
-	pos = pci_pcie_cap(dev);
+	/* ID-based Ordering is a PCIe cap v2 feature */
+	pos = pci_pcie_cap2(dev);
 	if (!pos)
 		return;
 
@@ -2054,7 +2083,8 @@ void pci_disable_ido(struct pci_dev *dev, unsigned long type)
 	int pos;
 	u16 ctrl;
 
-	pos = pci_pcie_cap(dev);
+	/* ID-based Ordering is a PCIe cap v2 feature */
+	pos = pci_pcie_cap2(dev);
 	if (!pos)
 		return;
 
@@ -2093,7 +2123,8 @@ int pci_enable_obff(struct pci_dev *dev, enum pci_obff_signal_type type)
 	u16 ctrl;
 	int ret;
 
-	pos = pci_pcie_cap(dev);
+	/* OBFF is a PCIe cap v2 feature */
+	pos = pci_pcie_cap2(dev);
 	if (!pos)
 		return -ENOTSUPP;
 
@@ -2143,7 +2174,8 @@ void pci_disable_obff(struct pci_dev *dev)
 	int pos;
 	u16 ctrl;
 
-	pos = pci_pcie_cap(dev);
+	/* OBFF is a PCIe cap v2 feature */
+	pos = pci_pcie_cap2(dev);
 	if (!pos)
 		return;
 
@@ -2165,7 +2197,8 @@ static bool pci_ltr_supported(struct pci_dev *dev)
 	int pos;
 	u32 cap;
 
-	pos = pci_pcie_cap(dev);
+	/* LTR is a PCIe cap v2 feature */
+	pos = pci_pcie_cap2(dev);
 	if (!pos)
 		return false;
 
@@ -2193,7 +2226,8 @@ int pci_enable_ltr(struct pci_dev *dev)
 	if (!pci_ltr_supported(dev))
 		return -ENOTSUPP;
 
-	pos = pci_pcie_cap(dev);
+	/* LTR is a PCIe cap v2 feature */
+	pos = pci_pcie_cap2(dev);
 	if (!pos)
 		return -ENOTSUPP;
 
@@ -2228,7 +2262,8 @@ void pci_disable_ltr(struct pci_dev *dev)
 	if (!pci_ltr_supported(dev))
 		return;
 
-	pos = pci_pcie_cap(dev);
+	/* LTR is a PCIe cap v2 feature */
+	pos = pci_pcie_cap2(dev);
 	if (!pos)
 		return;
 

commit cb97ae3485955401d637bd269b0d24d3cd3fd3ec
Author: Myron Stowe <myron.stowe@redhat.com>
Date:   Fri Jun 1 15:16:31 2012 -0600

    PCI: remove redundant checking in PCI Express capability routines
    
    There are a number of redundant pci_is_pcie() checks in various PCI
    Express capabilities related routines like the following:
    
        if (!pci_is_pcie(dev))
            return false;
    
        pos = pci_pcie_cap(dev);
        if (!pos)
            return false;
    
    The current pci_is_pcie() implementation is merely:
    
        static inline bool pci_is_pcie(struct pci_dev *dev)
        {
            return !!pci_pcie_cap(dev);
        }
    
    so we can just drop the pci_is_pcie() test in such cases.
    
    Acked-by: Donald Dutile <ddutile@redhat.com>
    Signed-off-by: Myron Stowe <myron.stowe@redhat.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 847e0c35cdb7..766bb13bb0a3 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1994,7 +1994,7 @@ void pci_enable_ari(struct pci_dev *dev)
 		return;
 
 	bridge = dev->bus->self;
-	if (!bridge || !pci_is_pcie(bridge))
+	if (!bridge)
 		return;
 
 	pos = pci_pcie_cap(bridge);
@@ -2054,9 +2054,6 @@ void pci_disable_ido(struct pci_dev *dev, unsigned long type)
 	int pos;
 	u16 ctrl;
 
-	if (!pci_is_pcie(dev))
-		return;
-
 	pos = pci_pcie_cap(dev);
 	if (!pos)
 		return;
@@ -2096,9 +2093,6 @@ int pci_enable_obff(struct pci_dev *dev, enum pci_obff_signal_type type)
 	u16 ctrl;
 	int ret;
 
-	if (!pci_is_pcie(dev))
-		return -ENOTSUPP;
-
 	pos = pci_pcie_cap(dev);
 	if (!pos)
 		return -ENOTSUPP;
@@ -2149,9 +2143,6 @@ void pci_disable_obff(struct pci_dev *dev)
 	int pos;
 	u16 ctrl;
 
-	if (!pci_is_pcie(dev))
-		return;
-
 	pos = pci_pcie_cap(dev);
 	if (!pos)
 		return;
@@ -2174,9 +2165,6 @@ static bool pci_ltr_supported(struct pci_dev *dev)
 	int pos;
 	u32 cap;
 
-	if (!pci_is_pcie(dev))
-		return false;
-
 	pos = pci_pcie_cap(dev);
 	if (!pos)
 		return false;

commit c32823f82b42abc1f08b365085862fd1d57c0b61
Author: Myron Stowe <myron.stowe@redhat.com>
Date:   Fri Jun 1 15:16:25 2012 -0600

    PCI: make pci_ltr_supported() static
    
    The PCI Express Latency Tolerance Reporting (LTR) feature's
    pci_ltr_supported() routine is currently only used within
    drivers/pci/pci.c so make it static.
    
    Acked-by: Donald Dutile <ddutile@redhat.com>
    Signed-off-by: Myron Stowe <myron.stowe@redhat.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 447e83472c01..847e0c35cdb7 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2169,7 +2169,7 @@ EXPORT_SYMBOL(pci_disable_obff);
  * RETURNS:
  * True if @dev supports latency tolerance reporting, false otherwise.
  */
-bool pci_ltr_supported(struct pci_dev *dev)
+static bool pci_ltr_supported(struct pci_dev *dev)
 {
 	int pos;
 	u32 cap;
@@ -2185,7 +2185,6 @@ bool pci_ltr_supported(struct pci_dev *dev)
 
 	return cap & PCI_EXP_DEVCAP2_LTR;
 }
-EXPORT_SYMBOL(pci_ltr_supported);
 
 /**
  * pci_enable_ltr - enable latency tolerance reporting

commit 533b6608b73669309becd90f11f939b60bb221be
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri May 18 16:52:34 2012 -0600

    PCI: remove pci_max_busnr() (was already commented out)
    
    pci_max_busnr() has been commented out for years (since 54c762fe62), and
    this patch removes it completely.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index de9386da2eb2..2cc53acad26a 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -136,30 +136,6 @@ void __iomem *pci_ioremap_bar(struct pci_dev *pdev, int bar)
 EXPORT_SYMBOL_GPL(pci_ioremap_bar);
 #endif
 
-#if 0
-/**
- * pci_max_busnr - returns maximum PCI bus number
- *
- * Returns the highest PCI bus number present in the system global list of
- * PCI buses.
- */
-unsigned char __devinit
-pci_max_busnr(void)
-{
-	struct pci_bus *bus = NULL;
-	unsigned char max, n;
-
-	max = 0;
-	while ((bus = pci_find_next_bus(bus)) != NULL) {
-		n = pci_bus_max_busnr(bus);
-		if(n > max)
-			max = n;
-	}
-	return max;
-}
-
-#endif  /*  0  */
-
 #define PCI_FIND_CAP_TTL	48
 
 static int __pci_find_next_cap_ttl(struct pci_bus *bus, unsigned int devfn,

commit 109cdbc223f6e2d6c80f8371f22415b50c18a366
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri May 18 16:52:19 2012 -0600

    PCI: remove pci_bus_find_ext_capability() (unused)
    
    pci_bus_find_ext_capability() is unused, and this patch removes it.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 447e83472c01..de9386da2eb2 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -329,49 +329,6 @@ int pci_find_ext_capability(struct pci_dev *dev, int cap)
 }
 EXPORT_SYMBOL_GPL(pci_find_ext_capability);
 
-/**
- * pci_bus_find_ext_capability - find an extended capability
- * @bus:   the PCI bus to query
- * @devfn: PCI device to query
- * @cap:   capability code
- *
- * Like pci_find_ext_capability() but works for pci devices that do not have a
- * pci_dev structure set up yet.
- *
- * Returns the address of the requested capability structure within the
- * device's PCI configuration space or 0 in case the device does not
- * support it.
- */
-int pci_bus_find_ext_capability(struct pci_bus *bus, unsigned int devfn,
-				int cap)
-{
-	u32 header;
-	int ttl;
-	int pos = PCI_CFG_SPACE_SIZE;
-
-	/* minimum 8 bytes per capability */
-	ttl = (PCI_CFG_SPACE_EXP_SIZE - PCI_CFG_SPACE_SIZE) / 8;
-
-	if (!pci_bus_read_config_dword(bus, devfn, pos, &header))
-		return 0;
-	if (header == 0xffffffff || header == 0)
-		return 0;
-
-	while (ttl-- > 0) {
-		if (PCI_EXT_CAP_ID(header) == cap)
-			return pos;
-
-		pos = PCI_EXT_CAP_NEXT(header);
-		if (pos < PCI_CFG_SPACE_SIZE)
-			break;
-
-		if (!pci_bus_read_config_dword(bus, devfn, pos, &header))
-			break;
-	}
-
-	return 0;
-}
-
 static int __pci_find_next_ht_cap(struct pci_dev *dev, int pos, int ht_cap)
 {
 	int rc, ttl = PCI_FIND_CAP_TTL;

commit 7e5b2db77b05746613516599c916a8cc2e321077
Merge: 227d1e4319ff c819baf31f5f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue May 29 18:27:19 2012 -0700

    Merge branch 'upstream' of git://git.linux-mips.org/pub/scm/ralf/upstream-linus
    
    Pull MIPS updates from Ralf Baechle:
     "The whole series has been sitting in -next for quite a while with no
      complaints.  The last change to the series was before the weekend the
      removal of an SPI patch which Grant - even though previously acked by
      himself - appeared to raise objections.  So I removed it until the
      situation is clarified.  Other than that all the patches have the acks
      from their respective maintainers, all MIPS and x86 defconfigs are
      building fine and I'm not aware of any problems introduced by this
      series.
    
      Among the key features for this patch series is a sizable patchset for
      Lantiq which among other things introduces support for Lantiq's
      flagship product, the FALCON SOC.  It also means that the opensource
      developers behind this patchset have overtaken Lantiq's competing
      inhouse development team that was working behind closed doors.
    
      Less noteworthy the ath79 patchset which adds support for a few more
      chip variants, cleanups and fixes.  Finally the usual dose of tweaking
      of generic code."
    
    Fix up trivial conflicts in arch/mips/lantiq/xway/gpio_{ebu,stp}.c where
    printk spelling fixes clashed with file move and eventual removal of the
    printk.
    
    * 'upstream' of git://git.linux-mips.org/pub/scm/ralf/upstream-linus: (81 commits)
      MIPS: lantiq: remove orphaned code
      MIPS: Remove all -Wall and almost all -Werror usage from arch/mips.
      MIPS: lantiq: implement support for FALCON soc
      MTD: MIPS: lantiq: verify that the NOR interface is available on falcon soc
      MTD: MIPS: lantiq: implement OF support
      watchdog: MIPS: lantiq: implement OF support and minor fixes
      SERIAL: MIPS: lantiq: implement OF support
      GPIO: MIPS: lantiq: convert gpio-stp-xway to OF
      GPIO: MIPS: lantiq: convert gpio-mm-lantiq to OF and of_mm_gpio
      GPIO: MIPS: lantiq: move gpio-stp and gpio-ebu to the subsystem folder
      MIPS: pci: convert lantiq driver to OF
      MIPS: lantiq: convert dma to platform driver
      MIPS: lantiq: implement support for clkdev api
      MIPS: lantiq: drop ltq_gpio_request() and gpio_to_irq()
      OF: MIPS: lantiq: implement irq_domain support
      OF: MIPS: lantiq: implement OF support
      MIPS: lantiq: drop mips_machine support
      OF: PCI: const usage needed by MIPS
      MIPS: Cavium: Remove smp_reserve_lock.
      MIPS: Move cache setup to setup_arch().
      ...

commit 3df425f316fb5c5e90236ff22b6e6616b3516af0
Author: John Crispin <blogic@openwrt.org>
Date:   Thu Apr 12 17:33:07 2012 +0200

    OF: PCI: const usage needed by MIPS
    
    On MIPS we want to call of_irq_map_pci from inside
    
    arch/mips/include/asm/pci.h:extern int pcibios_map_irq(
                                    const struct pci_dev *dev, u8 slot, u8 pin);
    For this to work we need to change several functions to const usage.
    
    Signed-off-by: John Crispin <blogic@openwrt.org>
    Cc: linux-pci@vger.kernel.org
    Cc: devicetree-discuss@lists.ozlabs.org
    Cc: linux-mips@linux-mips.org
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Grant Likely <grant.likely@secretlab.ca>
    Patchwork: https://patchwork.linux-mips.org/patch/3710/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 111569ccab43..8b91fe741f6a 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2369,7 +2369,7 @@ void pci_enable_acs(struct pci_dev *dev)
  * number is always 0 (see the Implementation Note in section 2.2.8.1 of
  * the PCI Express Base Specification, Revision 2.1)
  */
-u8 pci_swizzle_interrupt_pin(struct pci_dev *dev, u8 pin)
+u8 pci_swizzle_interrupt_pin(const struct pci_dev *dev, u8 pin)
 {
 	int slot;
 

commit 0cbaa57d828aa0a067e06d3c6d795b12ae9fb776
Merge: 99662dd1ce05 284f5f9dbac1
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon May 7 09:23:27 2012 -0600

    Merge branch 'topic/stratus' into next

commit 977f857ca566a1e68045fcbb7cfc9c4acb077cf0
Author: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
Date:   Tue Apr 24 13:15:18 2012 -0600

    PCI: move mutex locking out of pci_dev_reset function
    
    The intent of git commit 6fbf9e7a90862988c278462d85ce9684605a52b2
    "PCI: Introduce __pci_reset_function_locked to be used when holding
    device_lock." was to have a non-locking function that would call
    pci_dev_reset function.
    
    But it fell short of that by just probing and not actually reseting
    the device. To make that work we need a way to move the lock
    around device_lock to not be in pci_dev_reset (as the caller of
    __pci_reset_function_locked already holds said lock). We do this by
    renaming pci_dev_reset to __pci_dev_reset and bubbling said mutex out
    of __pci_dev_reset to pci_dev_reset (a wrapper around __pci_dev_reset).
    The __pci_reset_function_locked  can now call __pci_dev_reset without
    having to worry about the dead-lock.
    
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 111569ccab43..9e31c0ab650e 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -3164,18 +3164,12 @@ static int pci_parent_bus_reset(struct pci_dev *dev, int probe)
 	return 0;
 }
 
-static int pci_dev_reset(struct pci_dev *dev, int probe)
+static int __pci_dev_reset(struct pci_dev *dev, int probe)
 {
 	int rc;
 
 	might_sleep();
 
-	if (!probe) {
-		pci_cfg_access_lock(dev);
-		/* block PM suspend, driver probe, etc. */
-		device_lock(&dev->dev);
-	}
-
 	rc = pci_dev_specific_reset(dev, probe);
 	if (rc != -ENOTTY)
 		goto done;
@@ -3194,14 +3188,27 @@ static int pci_dev_reset(struct pci_dev *dev, int probe)
 
 	rc = pci_parent_bus_reset(dev, probe);
 done:
+	return rc;
+}
+
+static int pci_dev_reset(struct pci_dev *dev, int probe)
+{
+	int rc;
+
+	if (!probe) {
+		pci_cfg_access_lock(dev);
+		/* block PM suspend, driver probe, etc. */
+		device_lock(&dev->dev);
+	}
+
+	rc = __pci_dev_reset(dev, probe);
+
 	if (!probe) {
 		device_unlock(&dev->dev);
 		pci_cfg_access_unlock(dev);
 	}
-
 	return rc;
 }
-
 /**
  * __pci_reset_function - reset a PCI device function
  * @dev: PCI device to reset
@@ -3246,7 +3253,7 @@ EXPORT_SYMBOL_GPL(__pci_reset_function);
  */
 int __pci_reset_function_locked(struct pci_dev *dev)
 {
-	return pci_dev_reset(dev, 1);
+	return __pci_dev_reset(dev, 0);
 }
 EXPORT_SYMBOL_GPL(__pci_reset_function_locked);
 

commit 284f5f9dbac170b054c1e386ef92cbf654e91bba
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Apr 30 15:21:02 2012 -0600

    PCI: work around Stratus ftServer broken PCIe hierarchy
    
    A PCIe downstream port is a P2P bridge.  Its secondary interface is
    a link that should lead only to device 0 (unless ARI is enabled)[1], so
    we don't probe for non-zero device numbers.
    
    Some Stratus ftServer systems have a PCIe downstream port (02:00.0) that
    leads to both an upstream port (03:00.0) and a downstream port (03:01.0),
    and 03:01.0 has important devices below it:
    
      [0000:02]-+-00.0-[03-3c]--+-00.0-[04-09]--...
                                \-01.0-[0a-0d]--+-[USB]
                                                +-[NIC]
                                                +-...
    
    Previously, we didn't enumerate device 03:01.0, so USB and the network
    didn't work.  This patch adds a DMI quirk to scan all device numbers,
    not just 0, below a downstream port.
    
    Based on a patch by Prarit Bhargava.
    
    [1] PCIe spec r3.0, sec 7.3.1
    
    CC: Myron Stowe <mstowe@redhat.com>
    CC: Don Dutile <ddutile@redhat.com>
    CC: James Paradis <james.paradis@stratus.com>
    CC: Matthew Wilcox <matthew.r.wilcox@intel.com>
    CC: Jesse Barnes <jbarnes@virtuousgeek.org>
    CC: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 111569ccab43..8e6c38817036 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -22,6 +22,7 @@
 #include <linux/interrupt.h>
 #include <linux/device.h>
 #include <linux/pm_runtime.h>
+#include <asm-generic/pci-bridge.h>
 #include <asm/setup.h>
 #include "pci.h"
 
@@ -3893,6 +3894,8 @@ static int __init pci_setup(char *str)
 				pcie_bus_config = PCIE_BUS_PERFORMANCE;
 			} else if (!strncmp(str, "pcie_bus_peer2peer", 18)) {
 				pcie_bus_config = PCIE_BUS_PEER2PEER;
+			} else if (!strncmp(str, "pcie_scan_all", 13)) {
+				pci_add_flags(PCI_SCAN_ALL_PCIE_DEVS);
 			} else {
 				printk(KERN_ERR "PCI: Unknown option `%s'\n",
 						str);

commit a6cb9ee7cabe68002c3f2ab07224ea27d2617cf1
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Apr 16 23:07:50 2012 +0200

    PCI: Retry BARs restoration for Type 0 headers only
    
    Some shortcomings introduced into pci_restore_state() by commit
    26f41062f28d ("PCI: check for pci bar restore completion and retry")
    have been fixed by recent commit ebfc5b802fa76 ("PCI: Fix regression in
    pci_restore_state(), v3"), but that commit treats all PCI devices as
    those with Type 0 configuration headers.
    
    That is not entirely correct, because Type 1 and Type 2 headers have
    different layouts.  In particular, the area occupied by BARs in Type 0
    config headers contains the secondary status register in Type 1 ones and
    it doesn't make sense to retry the restoration of that register even if
    the value read back from it after a write is not the same as the written
    one (it very well may be different).
    
    For this reason, make pci_restore_state() only retry the restoration
    of BARs for Type 0 config headers.  This effectively makes it behave
    as before commit 26f41062f28d for all header types except for Type 0.
    
    Tested-by: Mikko Vinni <mmvinni@yahoo.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index d20f1334792b..111569ccab43 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -991,8 +991,8 @@ static void pci_restore_config_dword(struct pci_dev *pdev, int offset,
 	}
 }
 
-static void pci_restore_config_space(struct pci_dev *pdev, int start, int end,
-				     int retry)
+static void pci_restore_config_space_range(struct pci_dev *pdev,
+					   int start, int end, int retry)
 {
 	int index;
 
@@ -1002,6 +1002,18 @@ static void pci_restore_config_space(struct pci_dev *pdev, int start, int end,
 					 retry);
 }
 
+static void pci_restore_config_space(struct pci_dev *pdev)
+{
+	if (pdev->hdr_type == PCI_HEADER_TYPE_NORMAL) {
+		pci_restore_config_space_range(pdev, 10, 15, 0);
+		/* Restore BARs before the command register. */
+		pci_restore_config_space_range(pdev, 4, 9, 10);
+		pci_restore_config_space_range(pdev, 0, 3, 0);
+	} else {
+		pci_restore_config_space_range(pdev, 0, 15, 0);
+	}
+}
+
 /** 
  * pci_restore_state - Restore the saved state of a PCI device
  * @dev: - PCI device that we're dealing with
@@ -1015,13 +1027,7 @@ void pci_restore_state(struct pci_dev *dev)
 	pci_restore_pcie_state(dev);
 	pci_restore_ats_state(dev);
 
-	pci_restore_config_space(dev, 10, 15, 0);
-	/*
-	 * The Base Address register should be programmed before the command
-	 * register(s)
-	 */
-	pci_restore_config_space(dev, 4, 9, 10);
-	pci_restore_config_space(dev, 0, 3, 0);
+	pci_restore_config_space(dev);
 
 	pci_restore_pcix_state(dev);
 	pci_restore_msi_state(dev);

commit ebfc5b802fa76baeb4371311ff9fc27a2258d90d
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Apr 15 21:40:40 2012 +0200

    PCI: Fix regression in pci_restore_state(), v3
    
    Commit 26f41062f28d ("PCI: check for pci bar restore completion and
    retry") attempted to address problems with PCI BAR restoration on
    systems where FLR had not been completed before pci_restore_state() was
    called, but it did that in an utterly wrong way.
    
    First off, instead of retrying the writes for the BAR registers only, it
    did that for all of the PCI config space of the device, including the
    status register (whose value after the write quite obviously need not be
    the same as the written one).  Second, it added arbitrary delay to
    pci_restore_state() even for systems where the PCI config space
    restoration was successful at first attempt.  Finally, the mdelay(10) it
    added to every iteration of the writing loop was way too much of a delay
    for any reasonable device.
    
    All of this actually caused resume failures for some devices on Mikko's
    system.
    
    To fix the regression, make pci_restore_state() only retry the writes
    for BAR registers and only wait if the first read from the register
    doesn't return the written value.  Additionaly, make it wait for 1 ms,
    instead of 10 ms, after every failing attempt to write into config
    space.
    
    Reported-by: Mikko Vinni <mmvinni@yahoo.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 815674415267..d20f1334792b 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -967,16 +967,47 @@ pci_save_state(struct pci_dev *dev)
 	return 0;
 }
 
+static void pci_restore_config_dword(struct pci_dev *pdev, int offset,
+				     u32 saved_val, int retry)
+{
+	u32 val;
+
+	pci_read_config_dword(pdev, offset, &val);
+	if (val == saved_val)
+		return;
+
+	for (;;) {
+		dev_dbg(&pdev->dev, "restoring config space at offset "
+			"%#x (was %#x, writing %#x)\n", offset, val, saved_val);
+		pci_write_config_dword(pdev, offset, saved_val);
+		if (retry-- <= 0)
+			return;
+
+		pci_read_config_dword(pdev, offset, &val);
+		if (val == saved_val)
+			return;
+
+		mdelay(1);
+	}
+}
+
+static void pci_restore_config_space(struct pci_dev *pdev, int start, int end,
+				     int retry)
+{
+	int index;
+
+	for (index = end; index >= start; index--)
+		pci_restore_config_dword(pdev, 4 * index,
+					 pdev->saved_config_space[index],
+					 retry);
+}
+
 /** 
  * pci_restore_state - Restore the saved state of a PCI device
  * @dev: - PCI device that we're dealing with
  */
 void pci_restore_state(struct pci_dev *dev)
 {
-	int i;
-	u32 val;
-	int tries;
-
 	if (!dev->state_saved)
 		return;
 
@@ -984,24 +1015,14 @@ void pci_restore_state(struct pci_dev *dev)
 	pci_restore_pcie_state(dev);
 	pci_restore_ats_state(dev);
 
+	pci_restore_config_space(dev, 10, 15, 0);
 	/*
 	 * The Base Address register should be programmed before the command
 	 * register(s)
 	 */
-	for (i = 15; i >= 0; i--) {
-		pci_read_config_dword(dev, i * 4, &val);
-		tries = 10;		
-		while (tries && val != dev->saved_config_space[i]) {
-			dev_dbg(&dev->dev, "restoring config "
-				"space at offset %#x (was %#x, writing %#x)\n",
-				i, val, (int)dev->saved_config_space[i]);
-			pci_write_config_dword(dev,i * 4,
-				dev->saved_config_space[i]);
-			pci_read_config_dword(dev, i * 4, &val);
-			mdelay(10);
-			tries--;
-		}
-	}
+	pci_restore_config_space(dev, 4, 9, 10);
+	pci_restore_config_space(dev, 0, 3, 0);
+
 	pci_restore_pcix_state(dev);
 	pci_restore_msi_state(dev);
 	pci_restore_iov_state(dev);

commit 6748dcc269e52925993e0d68447858b41b88b4be
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Mar 1 00:06:33 2012 +0100

    PCI / PCIe: Introduce command line option to disable ARI
    
    There are PCIe devices on the market that report ARI support but
    then fail to initialize correctly when ARI is actually used.  This
    leads to situations in which kernels 2.6.34 and newer fail to handle
    systems where the previous kernels worked without any apparent
    problems.  Unfortunately, it is currently unknown how many such
    devices are there.
    
    For this reason, introduce a new kernel command line option,
    pci=noari, allowing users to disable PCIe ARI altogether if they
    see problems with PCIe device initialization.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index b832f0fece97..815674415267 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -94,6 +94,9 @@ u8 pci_cache_line_size;
  */
 unsigned int pcibios_max_latency = 255;
 
+/* If set, the PCIe ARI capability will not be used. */
+static bool pcie_ari_disabled;
+
 /**
  * pci_bus_max_busnr - returns maximum PCI bus number of given bus' children
  * @bus: pointer to PCI bus structure to search
@@ -1955,7 +1958,7 @@ void pci_enable_ari(struct pci_dev *dev)
 	u16 flags, ctrl;
 	struct pci_dev *bridge;
 
-	if (!pci_is_pcie(dev) || dev->devfn)
+	if (pcie_ari_disabled || !pci_is_pcie(dev) || dev->devfn)
 		return;
 
 	pos = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ARI);
@@ -3840,6 +3843,8 @@ static int __init pci_setup(char *str)
 				pci_realloc_get_opt("on");
 			} else if (!strcmp(str, "nodomains")) {
 				pci_no_domains();
+			} else if (!strncmp(str, "noari", 5)) {
+				pcie_ari_disabled = true;
 			} else if (!strncmp(str, "cbiosize=", 9)) {
 				pci_cardbus_io_size = memparse(str + 9, &str);
 			} else if (!strncmp(str, "cbmemsize=", 10)) {

commit 2069ecfbe14ebd71a6f98e8a00724e9adf4fe4ee
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Wed Feb 15 21:40:31 2012 -0800

    PCI: Move "pci reassigndev resource alignment" out of quirks.c
    
    This isn't really a quirk; calling it directly from pci_add_device makes
    more sense.
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index e9f9dc183cfc..b832f0fece97 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -3694,6 +3694,68 @@ int pci_is_reassigndev(struct pci_dev *dev)
 	return (pci_specified_resource_alignment(dev) != 0);
 }
 
+/*
+ * This function disables memory decoding and releases memory resources
+ * of the device specified by kernel's boot parameter 'pci=resource_alignment='.
+ * It also rounds up size to specified alignment.
+ * Later on, the kernel will assign page-aligned memory resource back
+ * to the device.
+ */
+void pci_reassigndev_resource_alignment(struct pci_dev *dev)
+{
+	int i;
+	struct resource *r;
+	resource_size_t align, size;
+	u16 command;
+
+	if (!pci_is_reassigndev(dev))
+		return;
+
+	if (dev->hdr_type == PCI_HEADER_TYPE_NORMAL &&
+	    (dev->class >> 8) == PCI_CLASS_BRIDGE_HOST) {
+		dev_warn(&dev->dev,
+			"Can't reassign resources to host bridge.\n");
+		return;
+	}
+
+	dev_info(&dev->dev,
+		"Disabling memory decoding and releasing memory resources.\n");
+	pci_read_config_word(dev, PCI_COMMAND, &command);
+	command &= ~PCI_COMMAND_MEMORY;
+	pci_write_config_word(dev, PCI_COMMAND, command);
+
+	align = pci_specified_resource_alignment(dev);
+	for (i = 0; i < PCI_BRIDGE_RESOURCES; i++) {
+		r = &dev->resource[i];
+		if (!(r->flags & IORESOURCE_MEM))
+			continue;
+		size = resource_size(r);
+		if (size < align) {
+			size = align;
+			dev_info(&dev->dev,
+				"Rounding up size of resource #%d to %#llx.\n",
+				i, (unsigned long long)size);
+		}
+		r->end = size - 1;
+		r->start = 0;
+	}
+	/* Need to disable bridge's resource window,
+	 * to enable the kernel to reassign new resource
+	 * window later on.
+	 */
+	if (dev->hdr_type == PCI_HEADER_TYPE_BRIDGE &&
+	    (dev->class >> 8) == PCI_CLASS_BRIDGE_PCI) {
+		for (i = PCI_BRIDGE_RESOURCES; i < PCI_NUM_RESOURCES; i++) {
+			r = &dev->resource[i];
+			if (!(r->flags & IORESOURCE_MEM))
+				continue;
+			r->end = resource_size(r) - 1;
+			r->start = 0;
+		}
+		pci_disable_bridge_window(dev);
+	}
+}
+
 ssize_t pci_set_resource_alignment_param(const char *buf, size_t count)
 {
 	if (count > RESOURCE_ALIGNMENT_PARAM_SIZE - 1)

commit b55438fdd5173a367659a7e200acea6c9f77b8cb
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Thu Feb 23 19:23:30 2012 -0800

    PCI: prepare pci=realloc for multiple options
    
    Let the user could enable and disable with pci=realloc=on or pci=realloc=off
    
    Also
    1. move variable and functions near the place they are used.
    2. change macro to function
    3. change related functions and variable to static and _init
    4. update parameter description accordingly.
    
    This will let us add a config option to control default behavior, and
    still allow the user to turn off automatic reallocation if it fails on
    their platform until a permanent solution is found.
    
    -v2: still honor pci=realloc, and treat it as pci=realloc=on
         also use enum instead of ...
    -v3: update kernel-paramenters.txt according to Jesse.
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Acked-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 8f30736dbf3f..e9f9dc183cfc 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -3772,8 +3772,10 @@ static int __init pci_setup(char *str)
 				pci_no_msi();
 			} else if (!strcmp(str, "noaer")) {
 				pci_no_aer();
+			} else if (!strncmp(str, "realloc=", 8)) {
+				pci_realloc_get_opt(str + 8);
 			} else if (!strncmp(str, "realloc", 7)) {
-				pci_realloc();
+				pci_realloc_get_opt("on");
 			} else if (!strcmp(str, "nodomains")) {
 				pci_no_domains();
 			} else if (!strncmp(str, "cbiosize=", 9)) {

commit 34a4876e3071ddebf3c98c99ba01c14b059a1361
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Sat Feb 11 00:18:41 2012 -0800

    PCI: move pci_find_saved_cap out of linux/pci.h
    
    Only one user in driver/pci/pci.c, so we don't need to put it in global
    pci.h
    
    Reviewed-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index e7dfcd447571..8f30736dbf3f 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -825,6 +825,19 @@ EXPORT_SYMBOL(pci_choose_state);
 #define pcie_cap_has_sltctl2(type, flags)		\
 		((flags & PCI_EXP_FLAGS_VERS) > 1)
 
+static struct pci_cap_saved_state *pci_find_saved_cap(
+	struct pci_dev *pci_dev, char cap)
+{
+	struct pci_cap_saved_state *tmp;
+	struct hlist_node *pos;
+
+	hlist_for_each_entry(tmp, pos, &pci_dev->saved_cap_space, next) {
+		if (tmp->cap.cap_nr == cap)
+			return tmp;
+	}
+	return NULL;
+}
+
 static int pci_save_pcie_state(struct pci_dev *dev)
 {
 	int pos, i = 0;
@@ -1869,6 +1882,12 @@ void platform_pci_wakeup_init(struct pci_dev *dev)
 	platform_pci_sleep_wake(dev, false);
 }
 
+static void pci_add_saved_cap(struct pci_dev *pci_dev,
+	struct pci_cap_saved_state *new_cap)
+{
+	hlist_add_head(&new_cap->next, &pci_dev->saved_cap_space);
+}
+
 /**
  * pci_add_save_buffer - allocate buffer for saving given capability registers
  * @dev: the PCI device

commit f796841e49fe086176e27ed0e1f3f7a1123a4a6b
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Sat Feb 11 00:18:30 2012 -0800

    PCI: fix memleak for pci dev removing during hotplug
    
    unreferenced object 0xffff880276d17700 (size 64):
      comm "swapper/0", pid 1, jiffies 4294897182 (age 3976.028s)
      hex dump (first 32 bytes):
        00 00 00 00 00 00 00 00 18 f9 de 76 02 88 ff ff  ...........v....
        10 00 00 00 0e 00 00 00 0f 28 40 00 00 00 00 00  .........(@.....
      backtrace:
        [<ffffffff81c8aede>] kmemleak_alloc+0x26/0x43
        [<ffffffff811385f0>] __kmalloc+0x121/0x183
        [<ffffffff813cf821>] pci_add_cap_save_buffer+0x35/0x7c
        [<ffffffff813d12b7>] pci_allocate_cap_save_buffers+0x1d/0x65
        [<ffffffff813cdb52>] pci_device_add+0x92/0xf1
        [<ffffffff81c8afe6>] pci_scan_single_device+0x9f/0xa1
        [<ffffffff813cdbd2>] pci_scan_slot.part.20+0x21/0x106
        [<ffffffff813cdce2>] pci_scan_slot+0x2b/0x35
        [<ffffffff81c8dae4>] __pci_scan_child_bus+0x51/0x107
        [<ffffffff81c8d75b>] pci_scan_bridge+0x376/0x6ae
        [<ffffffff81c8db60>] __pci_scan_child_bus+0xcd/0x107
        [<ffffffff81c8dbab>] pci_scan_child_bus+0x11/0x2a
        [<ffffffff81cca58c>] pci_acpi_scan_root+0x18b/0x21c
        [<ffffffff81c916be>] acpi_pci_root_add+0x1e1/0x42a
        [<ffffffff81406210>] acpi_device_probe+0x50/0x190
        [<ffffffff814a0227>] really_probe+0x99/0x126
    
    Need to free saved_buffer for capabilities.
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 9c89447e7b21..e7dfcd447571 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1916,6 +1916,15 @@ void pci_allocate_cap_save_buffers(struct pci_dev *dev)
 			"unable to preallocate PCI-X save buffer\n");
 }
 
+void pci_free_cap_save_buffers(struct pci_dev *dev)
+{
+	struct pci_cap_saved_state *tmp;
+	struct hlist_node *pos, *n;
+
+	hlist_for_each_entry_safe(tmp, pos, n, &dev->saved_cap_space, next)
+		kfree(tmp);
+}
+
 /**
  * pci_enable_ari - enable ARI forwarding if hardware support it
  * @dev: the PCI device

commit 26f41062f28de65e11d3cf353e52d0be73442be1
Author: Kay, Allen M <allen.m.kay@intel.com>
Date:   Thu Jan 26 10:25:53 2012 -0800

    PCI: check for pci bar restore completion and retry
    
    On some OEM systems, pci_restore_state() is called while FLR has not yet
    completed.  As a result, PCI BAR register restore is not successful.  This fix
    reads back the restored value and compares it with saved value and re-tries 10
    times before giving up.
    
    Signed-off-by: Jean Guyader <jean.guyader@eu.citrix.com>
    Signed-off-by: Eric Chanudet <eric.chanudet@citrix.com>
    Signed-off-by: Allen Kay <allen.m.kay@intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 053670e09e2b..9c89447e7b21 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -959,6 +959,7 @@ void pci_restore_state(struct pci_dev *dev)
 {
 	int i;
 	u32 val;
+	int tries;
 
 	if (!dev->state_saved)
 		return;
@@ -973,12 +974,16 @@ void pci_restore_state(struct pci_dev *dev)
 	 */
 	for (i = 15; i >= 0; i--) {
 		pci_read_config_dword(dev, i * 4, &val);
-		if (val != dev->saved_config_space[i]) {
+		tries = 10;		
+		while (tries && val != dev->saved_config_space[i]) {
 			dev_dbg(&dev->dev, "restoring config "
 				"space at offset %#x (was %#x, writing %#x)\n",
 				i, val, (int)dev->saved_config_space[i]);
 			pci_write_config_dword(dev,i * 4,
 				dev->saved_config_space[i]);
+			pci_read_config_dword(dev, i * 4, &val);
+			mdelay(10);
+			tries--;
 		}
 	}
 	pci_restore_pcix_state(dev);

commit 6fbf9e7a90862988c278462d85ce9684605a52b2
Author: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
Date:   Thu Jan 12 12:06:46 2012 -0500

    PCI: Introduce __pci_reset_function_locked to be used when holding device_lock.
    
    The use case of this is when a driver wants to call FLR when a device
    is attached to it using the SysFS "bind" or "unbind" functionality.
    
    The call chain when a user does "bind" looks as so:
    
     echo "0000:01.07.0" > /sys/bus/pci/drivers/XXXX/bind
    
    and ends up calling:
      driver_bind:
        device_lock(dev);  <=== TAKES LOCK
        XXXX_probe:
             .. pci_enable_device()
             ...__pci_reset_function(), which calls
                     pci_dev_reset(dev, 0):
                            if (!0) {
                                    device_lock(dev) <==== DEADLOCK
    
    The __pci_reset_function_locked function allows the the drivers
    'probe' function to call the "pci_reset_function" while still holding
    the driver mutex lock.
    
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index af295bb21d62..053670e09e2b 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -3162,6 +3162,31 @@ int __pci_reset_function(struct pci_dev *dev)
 }
 EXPORT_SYMBOL_GPL(__pci_reset_function);
 
+/**
+ * __pci_reset_function_locked - reset a PCI device function while holding
+ * the @dev mutex lock.
+ * @dev: PCI device to reset
+ *
+ * Some devices allow an individual function to be reset without affecting
+ * other functions in the same device.  The PCI device must be responsive
+ * to PCI config space in order to use this function.
+ *
+ * The device function is presumed to be unused and the caller is holding
+ * the device mutex lock when this function is called.
+ * Resetting the device will make the contents of PCI configuration space
+ * random, so any caller of this must be prepared to reinitialise the
+ * device including MSI, bus mastering, BARs, decoding IO and memory spaces,
+ * etc.
+ *
+ * Returns 0 if the device function was successfully reset or negative if the
+ * device doesn't support resetting a single function.
+ */
+int __pci_reset_function_locked(struct pci_dev *dev)
+{
+	return pci_dev_reset(dev, 1);
+}
+EXPORT_SYMBOL_GPL(__pci_reset_function_locked);
+
 /**
  * pci_probe_reset_function - check whether the device can be safely reset
  * @dev: PCI device to reset

commit 6e9292c588894bd39eb2d093013f0aee558ddf0e
Author: Randy Dunlap <rdunlap@xenotime.net>
Date:   Sat Jan 21 11:02:35 2012 -0800

    kernel-doc: fix new warnings in pci
    
    Fix new kernel-doc warnings:
    
    Warning(drivers/pci/pci.c:2811): No description found for parameter 'dev'
    Warning(drivers/pci/pci.c:2811): Excess function parameter 'pdev' description in 'pci_intx_mask_supported'
    Warning(drivers/pci/pci.c:2894): No description found for parameter 'dev'
    Warning(drivers/pci/pci.c:2894): Excess function parameter 'pdev' description in 'pci_check_and_mask_intx'
    Warning(drivers/pci/pci.c:2908): No description found for parameter 'dev'
    Warning(drivers/pci/pci.c:2908): Excess function parameter 'pdev' description in 'pci_check_and_unmask_intx'
    
    Signed-off-by: Randy Dunlap <rdunlap@xenotime.net>
    Cc: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 97fff785e97e..af295bb21d62 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2802,7 +2802,7 @@ pci_intx(struct pci_dev *pdev, int enable)
 
 /**
  * pci_intx_mask_supported - probe for INTx masking support
- * @pdev: the PCI device to operate on
+ * @dev: the PCI device to operate on
  *
  * Check if the device dev support INTx masking via the config space
  * command word.
@@ -2884,7 +2884,7 @@ static bool pci_check_and_set_intx_mask(struct pci_dev *dev, bool mask)
 
 /**
  * pci_check_and_mask_intx - mask INTx on pending interrupt
- * @pdev: the PCI device to operate on
+ * @dev: the PCI device to operate on
  *
  * Check if the device dev has its INTx line asserted, mask it and
  * return true in that case. False is returned if not interrupt was
@@ -2898,7 +2898,7 @@ EXPORT_SYMBOL_GPL(pci_check_and_mask_intx);
 
 /**
  * pci_check_and_mask_intx - unmask INTx of no interrupt is pending
- * @pdev: the PCI device to operate on
+ * @dev: the PCI device to operate on
  *
  * Check if the device dev has its INTx line asserted, unmask it if not
  * and return true. False is returned and the mask remains active if

commit 1900ca132f53c3d51e6e6b94ea8912530223c63a
Author: Hao, Xudong <xudong.hao@intel.com>
Date:   Sat Dec 17 21:24:40 2011 +0800

    PCI: Enable ATS at the device state restore
    
    During S3 or S4 resume or PCI reset, ATS regs aren't restored correctly.
    This patch enables ATS at the device state restore if PCI device has ATS
    capability.
    
    Signed-off-by: Xudong Hao <xudong.hao@intel.com>
    Signed-off-by: Xiantao Zhang <xiantao.zhang@intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 54343aa5b30a..97fff785e97e 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -965,6 +965,7 @@ void pci_restore_state(struct pci_dev *dev)
 
 	/* PCI Express register must be restored first */
 	pci_restore_pcie_state(dev);
+	pci_restore_ats_state(dev);
 
 	/*
 	 * The Base Address register should be programmed before the command

commit 85b8582d7ca516030efb84d94fa29a73c1d9a125
Author: Vincent Palatin <vpalatin@chromium.org>
Date:   Mon Dec 5 11:51:18 2011 -0800

    PCI/PM/Runtime: make PCI traces quieter
    
    When the runtime PM is activated on PCI, if a device switches state
    frequently (e.g. an EHCI controller with autosuspending USB devices
    connected) the PCI configuration traces might be very verbose in the
    kernel log.  Let's guard those traces with DEBUG condition.
    
    Acked-by: "Rafael J. Wysocki" <rjw@sisk.pl>
    Signed-off-by: Vincent Palatin <vpalatin@chromium.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 5c5adef85bd7..54343aa5b30a 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -973,7 +973,7 @@ void pci_restore_state(struct pci_dev *dev)
 	for (i = 15; i >= 0; i--) {
 		pci_read_config_dword(dev, i * 4, &val);
 		if (val != dev->saved_config_space[i]) {
-			dev_printk(KERN_DEBUG, &dev->dev, "restoring config "
+			dev_dbg(&dev->dev, "restoring config "
 				"space at offset %#x (was %#x, writing %#x)\n",
 				i, val, (int)dev->saved_config_space[i]);
 			pci_write_config_dword(dev,i * 4,
@@ -1542,8 +1542,7 @@ void pci_pme_active(struct pci_dev *dev, bool enable)
 	}
 
 out:
-	dev_printk(KERN_DEBUG, &dev->dev, "PME# %s\n",
-			enable ? "enabled" : "disabled");
+	dev_dbg(&dev->dev, "PME# %s\n", enable ? "enabled" : "disabled");
 }
 
 /**

commit f676678f8952d5e2bfc03903dba410c856ae3f3d
Author: Myron Stowe <mstowe@redhat.com>
Date:   Fri Oct 28 15:49:20 2011 -0600

    PCI: latency timer doesn't apply to PCIe
    
    The latency timer is read-only and hardwired to zero for all PCIe
    devices, both Type 0 and Type 1, so don't bother trying to update it
    and cluttering the dmesg log with meaningless "setting latency timer
    to 64" messages.
    
    Signed-off-by: Myron Stowe <myron.stowe@redhat.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index f9abe84cf5e0..5c5adef85bd7 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2613,6 +2613,10 @@ void __weak pcibios_set_master(struct pci_dev *dev)
 {
 	u8 lat;
 
+	/* The latency timer doesn't apply to PCIe (either Type 0 or Type 1) */
+	if (pci_is_pcie(dev))
+		return;
+
 	pci_read_config_byte(dev, PCI_LATENCY_TIMER, &lat);
 	if (lat < 16)
 		lat = (64 <= pcibios_max_latency) ? 64 : pcibios_max_latency;

commit 96c5590058d7fded14f43af2ab521436cecf3125
Author: Myron Stowe <mstowe@redhat.com>
Date:   Fri Oct 28 15:48:38 2011 -0600

    PCI: Pull PCI 'latency timer' setup up into the core
    
    The 'latency timer' of PCI devices, both Type 0 and Type 1,
    is setup in architecture-specific code [see: 'pcibios_set_master()'].
    There are two approaches being taken by all the architectures - check
    if the 'latency timer' is currently set between 16 and 255 and if not
    bring it within bounds, or, do nothing (and then there is the
    gratuitously different PA-RISC implementation).
    
    There is nothing architecture-specific about PCI's 'latency timer' so
    this patch pulls its setup functionality up into the PCI core by
    creating a generic 'pcibios_set_master()' function using the '__weak'
    attribute which can be used by all architectures as a default which,
    if necessary, can then be over-ridden by architecture-specific code.
    
    No functional change.
    
    Signed-off-by: Myron Stowe <myron.stowe@redhat.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 924193ef4fe1..f9abe84cf5e0 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -88,6 +88,12 @@ enum pcie_bus_config_types pcie_bus_config = PCIE_BUS_TUNE_OFF;
 u8 pci_dfl_cache_line_size __devinitdata = L1_CACHE_BYTES >> 2;
 u8 pci_cache_line_size;
 
+/*
+ * If we set up a device for bus mastering, we need to check the latency
+ * timer as certain BIOSes forget to set it properly.
+ */
+unsigned int pcibios_max_latency = 255;
+
 /**
  * pci_bus_max_busnr - returns maximum PCI bus number of given bus' children
  * @bus: pointer to PCI bus structure to search
@@ -2595,6 +2601,29 @@ static void __pci_set_master(struct pci_dev *dev, bool enable)
 	dev->is_busmaster = enable;
 }
 
+/**
+ * pcibios_set_master - enable PCI bus-mastering for device dev
+ * @dev: the PCI device to enable
+ *
+ * Enables PCI bus-mastering for the device.  This is the default
+ * implementation.  Architecture specific implementations can override
+ * this if necessary.
+ */
+void __weak pcibios_set_master(struct pci_dev *dev)
+{
+	u8 lat;
+
+	pci_read_config_byte(dev, PCI_LATENCY_TIMER, &lat);
+	if (lat < 16)
+		lat = (64 <= pcibios_max_latency) ? 64 : pcibios_max_latency;
+	else if (lat > pcibios_max_latency)
+		lat = pcibios_max_latency;
+	else
+		return;
+	dev_printk(KERN_DEBUG, &dev->dev, "setting latency timer to %d\n", lat);
+	pci_write_config_byte(dev, PCI_LATENCY_TIMER, lat);
+}
+
 /**
  * pci_set_master - enables bus-mastering for device dev
  * @dev: the PCI device to enable

commit a2e27787f893621c5a6b865acf6b7766f8671328
Author: Jan Kiszka <jan.kiszka@siemens.com>
Date:   Fri Nov 4 09:46:00 2011 +0100

    PCI: Introduce INTx check & mask API
    
    These new PCI services allow to probe for 2.3-compliant INTx masking
    support and then use the feature from PCI interrupt handlers. The
    services are properly synchronized with concurrent config space access
    via sysfs or on device reset.
    
    This enables generic PCI device drivers like uio_pci_generic or KVM's
    device assignment to implement the necessary kernel-side IRQ handling
    without any knowledge about device-specific interrupt status and control
    registers.
    
    Acked-by: Michael S. Tsirkin <mst@redhat.com>
    Signed-off-by: Jan Kiszka <jan.kiszka@siemens.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index c3cca7cdc6e5..924193ef4fe1 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2767,6 +2767,116 @@ pci_intx(struct pci_dev *pdev, int enable)
 	}
 }
 
+/**
+ * pci_intx_mask_supported - probe for INTx masking support
+ * @pdev: the PCI device to operate on
+ *
+ * Check if the device dev support INTx masking via the config space
+ * command word.
+ */
+bool pci_intx_mask_supported(struct pci_dev *dev)
+{
+	bool mask_supported = false;
+	u16 orig, new;
+
+	pci_cfg_access_lock(dev);
+
+	pci_read_config_word(dev, PCI_COMMAND, &orig);
+	pci_write_config_word(dev, PCI_COMMAND,
+			      orig ^ PCI_COMMAND_INTX_DISABLE);
+	pci_read_config_word(dev, PCI_COMMAND, &new);
+
+	/*
+	 * There's no way to protect against hardware bugs or detect them
+	 * reliably, but as long as we know what the value should be, let's
+	 * go ahead and check it.
+	 */
+	if ((new ^ orig) & ~PCI_COMMAND_INTX_DISABLE) {
+		dev_err(&dev->dev, "Command register changed from "
+			"0x%x to 0x%x: driver or hardware bug?\n", orig, new);
+	} else if ((new ^ orig) & PCI_COMMAND_INTX_DISABLE) {
+		mask_supported = true;
+		pci_write_config_word(dev, PCI_COMMAND, orig);
+	}
+
+	pci_cfg_access_unlock(dev);
+	return mask_supported;
+}
+EXPORT_SYMBOL_GPL(pci_intx_mask_supported);
+
+static bool pci_check_and_set_intx_mask(struct pci_dev *dev, bool mask)
+{
+	struct pci_bus *bus = dev->bus;
+	bool mask_updated = true;
+	u32 cmd_status_dword;
+	u16 origcmd, newcmd;
+	unsigned long flags;
+	bool irq_pending;
+
+	/*
+	 * We do a single dword read to retrieve both command and status.
+	 * Document assumptions that make this possible.
+	 */
+	BUILD_BUG_ON(PCI_COMMAND % 4);
+	BUILD_BUG_ON(PCI_COMMAND + 2 != PCI_STATUS);
+
+	raw_spin_lock_irqsave(&pci_lock, flags);
+
+	bus->ops->read(bus, dev->devfn, PCI_COMMAND, 4, &cmd_status_dword);
+
+	irq_pending = (cmd_status_dword >> 16) & PCI_STATUS_INTERRUPT;
+
+	/*
+	 * Check interrupt status register to see whether our device
+	 * triggered the interrupt (when masking) or the next IRQ is
+	 * already pending (when unmasking).
+	 */
+	if (mask != irq_pending) {
+		mask_updated = false;
+		goto done;
+	}
+
+	origcmd = cmd_status_dword;
+	newcmd = origcmd & ~PCI_COMMAND_INTX_DISABLE;
+	if (mask)
+		newcmd |= PCI_COMMAND_INTX_DISABLE;
+	if (newcmd != origcmd)
+		bus->ops->write(bus, dev->devfn, PCI_COMMAND, 2, newcmd);
+
+done:
+	raw_spin_unlock_irqrestore(&pci_lock, flags);
+
+	return mask_updated;
+}
+
+/**
+ * pci_check_and_mask_intx - mask INTx on pending interrupt
+ * @pdev: the PCI device to operate on
+ *
+ * Check if the device dev has its INTx line asserted, mask it and
+ * return true in that case. False is returned if not interrupt was
+ * pending.
+ */
+bool pci_check_and_mask_intx(struct pci_dev *dev)
+{
+	return pci_check_and_set_intx_mask(dev, true);
+}
+EXPORT_SYMBOL_GPL(pci_check_and_mask_intx);
+
+/**
+ * pci_check_and_mask_intx - unmask INTx of no interrupt is pending
+ * @pdev: the PCI device to operate on
+ *
+ * Check if the device dev has its INTx line asserted, unmask it if not
+ * and return true. False is returned and the mask remains active if
+ * there was still an interrupt pending.
+ */
+bool pci_check_and_unmask_intx(struct pci_dev *dev)
+{
+	return pci_check_and_set_intx_mask(dev, false);
+}
+EXPORT_SYMBOL_GPL(pci_check_and_unmask_intx);
+
 /**
  * pci_msi_off - disables any msi or msix capabilities
  * @dev: the PCI device to operate on

commit fb51ccbf217c1c994607b6519c7d85250928553d
Author: Jan Kiszka <jan.kiszka@siemens.com>
Date:   Fri Nov 4 09:45:59 2011 +0100

    PCI: Rework config space blocking services
    
    pci_block_user_cfg_access was designed for the use case that a single
    context, the IPR driver, temporarily delays user space accesses to the
    config space via sysfs. This assumption became invalid by the time
    pci_dev_reset was added as locking instance. Today, if you run two loops
    in parallel that reset the same device via sysfs, you end up with a
    kernel BUG as pci_block_user_cfg_access detect the broken assumption.
    
    This reworks the pci_block_user_cfg_access to a sleeping service
    pci_cfg_access_lock and an atomic-compatible variant called
    pci_cfg_access_trylock. The former not only blocks user space access as
    before but also waits if access was already locked. The latter service
    just returns false in this case, allowing the caller to resolve the
    conflict instead of raising a BUG.
    
    Adaptions of the ipr driver were originally written by Brian King.
    
    Acked-by: Brian King <brking@linux.vnet.ibm.com>
    Acked-by: Michael S. Tsirkin <mst@redhat.com>
    Signed-off-by: Jan Kiszka <jan.kiszka@siemens.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 6d4a5319148d..c3cca7cdc6e5 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2965,7 +2965,7 @@ static int pci_dev_reset(struct pci_dev *dev, int probe)
 	might_sleep();
 
 	if (!probe) {
-		pci_block_user_cfg_access(dev);
+		pci_cfg_access_lock(dev);
 		/* block PM suspend, driver probe, etc. */
 		device_lock(&dev->dev);
 	}
@@ -2990,7 +2990,7 @@ static int pci_dev_reset(struct pci_dev *dev, int probe)
 done:
 	if (!probe) {
 		device_unlock(&dev->dev);
-		pci_unblock_user_cfg_access(dev);
+		pci_cfg_access_unlock(dev);
 	}
 
 	return rc;

commit 497f16f21a04060098c0da6ed522fbcafb90c0db
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Sat Dec 17 18:33:37 2011 -0800

    pci: Fix hotplug of Express Module with pci bridges
    
    I noticed that hotplug of one setup does not work with recent change in
    pci tree.
    
    After checking the bridge conf setup, I noticed that the bridges get
    assigned but do not get enabled.
    
    The reason is the following commit, while simply ignores bridge
    resources when enabling a pci device:
    
    | commit bbef98ab0f019f1b0c25c1acdf1683c68933d41b
    | Author: Ram Pai <linuxram@us.ibm.com>
    | Date:   Sun Nov 6 10:33:10 2011 +0800
    |
    |    PCI: defer enablement of SRIOV BARS
    |...
    |    NOTE: Note, there is subtle change in the pci_enable_device() API.  Any
    |    driver that depends on SRIOV BARS to be enabled in pci_enable_device()
    |    can fail.
    
    Put back bridge resource and ROM resource checking to fix the problem.
    
    That should fix regression like BIOS does not assign correct resource to
    bridge.
    
    Discussion can be found at:
            http://www.spinics.net/lists/linux-pci/msg12874.html
    
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Acked-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index faccb8937706..6d4a5319148d 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1129,7 +1129,11 @@ static int __pci_enable_device_flags(struct pci_dev *dev,
 	if (atomic_add_return(1, &dev->enable_cnt) > 1)
 		return 0;		/* already enabled */
 
-	for (i = 0; i < PCI_ROM_RESOURCE; i++)
+	/* only skip sriov related */
+	for (i = 0; i <= PCI_ROM_RESOURCE; i++)
+		if (dev->resource[i].flags & flags)
+			bars |= (1 << i);
+	for (i = PCI_BRIDGE_RESOURCES; i < DEVICE_COUNT_RESOURCE; i++)
 		if (dev->resource[i].flags & flags)
 			bars |= (1 << i);
 

commit b51306c63449d7f06ffa689036ba49eb46e898b5
Author: Ajaykumar Hotchandani <ajaykumar.hotchandani@oracle.com>
Date:   Mon Dec 12 13:57:36 2011 +0530

    PCI: Set device power state to PCI_D0 for device without native PM support
    
    During test of one IB card with guest VM, found that, msi is not
    initialized properly.
    
    It turns out __write_msi_msg will do nothing if device current_state is
    not PCI_D0.  And, that pci device does not have pm_cap in guest VM.
    
    There is an error in setting of power state to PCI_D0 in
    pci_enable_device(), but error is not returned for this.  Following is
    code flow:
    
    pci_enable_device() -->   __pci_enable_device_flags() -->
    do_pci_enable_device() -->   pci_set_power_state() -->
    __pci_start_power_transition()
    
    We have following condition inside __pci_start_power_transition():
             if (platform_pci_power_manageable(dev)) {
                     error = platform_pci_set_power_state(dev, state);
                     if (!error)
                             pci_update_current_state(dev, state);
             } else {
                     error = -ENODEV;
                     /* Fall back to PCI_D0 if native PM is not supported */
                     if (!dev->pm_cap)
                             dev->current_state = PCI_D0;
             }
    
    Here, from platform_pci_set_power_state(), acpi_pci_set_power_state() is
    getting called and that is failing with ENODEV because of following
    condition:
    
             if (!handle || ACPI_SUCCESS(acpi_get_handle(handle, "_EJ0",&tmp)))
                     return -ENODEV;
    
    Because of that, pci_update_current_state() is not getting called.
    
    With this patch, if device power state can not be set via
    platform_pci_set_power_state and that device does not have native pm
    support, then PCI device power state will be set to PCI_D0.
    
    -v2: This also reverts 47e9037ac16637cd7f12b8790ea7ce6680e42168, as it's
         not needed after this change.
    
    Acked-by: "Rafael J. Wysocki" <rjw@sisk.pl>
    Signed-off-by: Ajaykumar Hotchandani<ajaykumar.hotchandani@oracle.com>
    Signed-off-by: Yinghai Lu<yinghai.lu@oracle.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 4788413f43d7..faccb8937706 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -664,6 +664,9 @@ static int pci_platform_power_transition(struct pci_dev *dev, pci_power_t state)
 		error = platform_pci_set_power_state(dev, state);
 		if (!error)
 			pci_update_current_state(dev, state);
+		/* Fall back to PCI_D0 if native PM is not supported */
+		if (!dev->pm_cap)
+			dev->current_state = PCI_D0;
 	} else {
 		error = -ENODEV;
 		/* Fall back to PCI_D0 if native PM is not supported */

commit bbef98ab0f019f1b0c25c1acdf1683c68933d41b
Author: Ram Pai <linuxram@us.ibm.com>
Date:   Sun Nov 6 10:33:10 2011 +0800

    PCI: defer enablement of SRIOV BARS
    
    All the PCI BARs of a device are enabled when the device is enabled
    using pci_enable_device().  This unnecessarily enables SRIOV BARs of the
    device.
    
    On some platforms, which do not support SRIOV as yet, the
    pci_enable_device() fails to enable the device if its SRIOV BARs are not
    allocated resources correctly.
    
    The following patch fixes the above problem. The SRIOV BARs are now
    enabled when IOV capability of the device is enabled in sriov_enable().
    
    NOTE: Note, there is subtle change in the pci_enable_device() API.  Any
    driver that depends on SRIOV BARS to be enabled in pci_enable_device()
    can fail.
    
    The patch has been touch tested on power and x86 platform.
    
    Tested-by: Michael Wang <wangyun@linux.vnet.ibm.com>
    Signed-off-by: Ram Pai <linuxram@us.ibm.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 6f45a73c6e9f..4788413f43d7 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1126,7 +1126,7 @@ static int __pci_enable_device_flags(struct pci_dev *dev,
 	if (atomic_add_return(1, &dev->enable_cnt) > 1)
 		return 0;		/* already enabled */
 
-	for (i = 0; i < DEVICE_COUNT_RESOURCE; i++)
+	for (i = 0; i < PCI_ROM_RESOURCE; i++)
 		if (dev->resource[i].flags & flags)
 			bars |= (1 << i);
 

commit a1c473aa11e61bc871be16279c9bf976acf22504
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Fri Oct 14 14:56:15 2011 -0500

    pci: Clamp pcie_set_readrq() when using "performance" settings
    
    When configuring the PCIe settings for "performance", we allow parents
    to have a larger Max Payload Size than children and rely on children
    Max Read Request Size to not be larger than their own MPS to avoid
    having the host bridge generate responses they can't cope with.
    
    However, various drivers in Linux call pci_set_readrq() with arbitrary
    values, assuming this to be a simple performance tweak. This breaks
    under our "performance" configuration.
    
    Fix that by making sure the value programmed by pcie_set_readrq() is
    never larger than the configured MPS for that device.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Jon Mason <mason@myri.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 7cd417e94058..6f45a73c6e9f 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -3202,8 +3202,6 @@ int pcie_set_readrq(struct pci_dev *dev, int rq)
 	if (rq < 128 || rq > 4096 || !is_power_of_2(rq))
 		goto out;
 
-	v = (ffs(rq) - 8) << 12;
-
 	cap = pci_pcie_cap(dev);
 	if (!cap)
 		goto out;
@@ -3211,6 +3209,22 @@ int pcie_set_readrq(struct pci_dev *dev, int rq)
 	err = pci_read_config_word(dev, cap + PCI_EXP_DEVCTL, &ctl);
 	if (err)
 		goto out;
+	/*
+	 * If using the "performance" PCIe config, we clamp the
+	 * read rq size to the max packet size to prevent the
+	 * host bridge generating requests larger than we can
+	 * cope with
+	 */
+	if (pcie_bus_config == PCIE_BUS_PERFORMANCE) {
+		int mps = pcie_get_mps(dev);
+
+		if (mps < 0)
+			return mps;
+		if (mps < rq)
+			rq = mps;
+	}
+
+	v = (ffs(rq) - 8) << 12;
 
 	if ((ctl & PCI_EXP_DEVCTL_READRQ) != v) {
 		ctl &= ~PCI_EXP_DEVCTL_READRQ;

commit 379021d5c0899fcf9410cae4ca7a59a5a94ca769
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Oct 3 23:16:33 2011 +0200

    PCI / PM: Extend PME polling to all PCI devices
    
    The land of PCI power management is a land of sorrow and ugliness,
    especially in the area of signaling events by devices.  There are
    devices that set their PME Status bits, but don't really bother
    to send a PME message or assert PME#.  There are hardware vendors
    who don't connect PME# lines to the system core logic (they know
    who they are).  There are PCI Express Root Ports that don't bother
    to trigger interrupts when they receive PME messages from the devices
    below.  There are ACPI BIOSes that forget to provide _PRW methods for
    devices capable of signaling wakeup.  Finally, there are BIOSes that
    do provide _PRW methods for such devices, but then don't bother to
    call Notify() for those devices from the corresponding _Lxx/_Exx
    GPE-handling methods.  In all of these cases the kernel doesn't have
    a chance to receive a proper notification that it should wake up a
    device, so devices stay in low-power states forever.  Worse yet, in
    some cases they continuously send PME Messages that are silently
    ignored, because the kernel simply doesn't know that it should clear
    the device's PME Status bit.
    
    This problem was first observed for "parallel" (non-Express) PCI
    devices on add-on cards and Matthew Garrett addressed it by adding
    code that polls PME Status bits of such devices, if they are enabled
    to signal PME, to the kernel.  Recently, however, it has turned out
    that PCI Express devices are also affected by this issue and that it
    is not limited to add-on devices, so it seems necessary to extend
    the PME polling to all PCI devices, including PCI Express and planar
    ones.  Still, it would be wasteful to poll the PME Status bits of
    devices that are known to receive proper PME notifications, so make
    the kernel (1) poll the PME Status bits of all PCI and PCIe devices
    enabled to signal PME and (2) disable the PME Status polling for
    devices for which correct PME notifications are received.
    
    Tested-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index e9651f0a8817..7cd417e94058 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1407,13 +1407,16 @@ bool pci_check_pme_status(struct pci_dev *dev)
 /**
  * pci_pme_wakeup - Wake up a PCI device if its PME Status bit is set.
  * @dev: Device to handle.
- * @ign: Ignored.
+ * @pme_poll_reset: Whether or not to reset the device's pme_poll flag.
  *
  * Check if @dev has generated PME and queue a resume request for it in that
  * case.
  */
-static int pci_pme_wakeup(struct pci_dev *dev, void *ign)
+static int pci_pme_wakeup(struct pci_dev *dev, void *pme_poll_reset)
 {
+	if (pme_poll_reset && dev->pme_poll)
+		dev->pme_poll = false;
+
 	if (pci_check_pme_status(dev)) {
 		pci_wakeup_event(dev);
 		pm_request_resume(&dev->dev);
@@ -1428,7 +1431,7 @@ static int pci_pme_wakeup(struct pci_dev *dev, void *ign)
 void pci_pme_wakeup_bus(struct pci_bus *bus)
 {
 	if (bus)
-		pci_walk_bus(bus, pci_pme_wakeup, NULL);
+		pci_walk_bus(bus, pci_pme_wakeup, (void *)true);
 }
 
 /**
@@ -1446,30 +1449,25 @@ bool pci_pme_capable(struct pci_dev *dev, pci_power_t state)
 
 static void pci_pme_list_scan(struct work_struct *work)
 {
-	struct pci_pme_device *pme_dev;
+	struct pci_pme_device *pme_dev, *n;
 
 	mutex_lock(&pci_pme_list_mutex);
 	if (!list_empty(&pci_pme_list)) {
-		list_for_each_entry(pme_dev, &pci_pme_list, list)
-			pci_pme_wakeup(pme_dev->dev, NULL);
-		schedule_delayed_work(&pci_pme_work, msecs_to_jiffies(PME_TIMEOUT));
+		list_for_each_entry_safe(pme_dev, n, &pci_pme_list, list) {
+			if (pme_dev->dev->pme_poll) {
+				pci_pme_wakeup(pme_dev->dev, NULL);
+			} else {
+				list_del(&pme_dev->list);
+				kfree(pme_dev);
+			}
+		}
+		if (!list_empty(&pci_pme_list))
+			schedule_delayed_work(&pci_pme_work,
+					      msecs_to_jiffies(PME_TIMEOUT));
 	}
 	mutex_unlock(&pci_pme_list_mutex);
 }
 
-/**
- * pci_external_pme - is a device an external PCI PME source?
- * @dev: PCI device to check
- *
- */
-
-static bool pci_external_pme(struct pci_dev *dev)
-{
-	if (pci_is_pcie(dev) || dev->bus->number == 0)
-		return false;
-	return true;
-}
-
 /**
  * pci_pme_active - enable or disable PCI device's PME# function
  * @dev: PCI device to handle.
@@ -1503,7 +1501,7 @@ void pci_pme_active(struct pci_dev *dev, bool enable)
 	   hit, and the power savings from the devices will still be a
 	   win. */
 
-	if (pci_external_pme(dev)) {
+	if (dev->pme_poll) {
 		struct pci_pme_device *pme_dev;
 		if (enable) {
 			pme_dev = kmalloc(sizeof(struct pci_pme_device),
@@ -1821,6 +1819,7 @@ void pci_pm_init(struct pci_dev *dev)
 			 (pmc & PCI_PM_CAP_PME_D3) ? " D3hot" : "",
 			 (pmc & PCI_PM_CAP_PME_D3cold) ? " D3cold" : "");
 		dev->pme_support = pmc >> PCI_PM_CAP_PME_SHIFT;
+		dev->pme_poll = true;
 		/*
 		 * Make device's PM flags reflect the wake-up capability, but
 		 * let the user space enable it to wake up the system as needed.

commit 5f39e6705faade2e89d119958a8c51b9b6e2c53c
Author: Jon Mason <mason@myri.com>
Date:   Mon Oct 3 09:50:20 2011 -0500

    PCI: Disable MPS configuration by default
    
    Add the ability to disable PCI-E MPS turning and using the BIOS
    configured MPS defaults.  Due to the number of issues recently
    discovered on some x86 chipsets, make this the default behavior.
    
    Also, add the option for peer to peer DMA MPS configuration.  Peer to
    peer DMA is outside the scope of this patch, but MPS configuration could
    prevent it from working by having the MPS on one root port different
    than the MPS on another.  To work around this, simply make the system
    wide MPS the smallest possible value (128B).
    
    Signed-off-by: Jon Mason <mason@myri.com>
    Acked-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 4e84fd4a4312..e9651f0a8817 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -77,7 +77,7 @@ unsigned long pci_cardbus_mem_size = DEFAULT_CARDBUS_MEM_SIZE;
 unsigned long pci_hotplug_io_size  = DEFAULT_HOTPLUG_IO_SIZE;
 unsigned long pci_hotplug_mem_size = DEFAULT_HOTPLUG_MEM_SIZE;
 
-enum pcie_bus_config_types pcie_bus_config = PCIE_BUS_SAFE;
+enum pcie_bus_config_types pcie_bus_config = PCIE_BUS_TUNE_OFF;
 
 /*
  * The default CLS is used if arch didn't set CLS explicitly and not
@@ -3568,10 +3568,14 @@ static int __init pci_setup(char *str)
 				pci_hotplug_io_size = memparse(str + 9, &str);
 			} else if (!strncmp(str, "hpmemsize=", 10)) {
 				pci_hotplug_mem_size = memparse(str + 10, &str);
+			} else if (!strncmp(str, "pcie_bus_tune_off", 17)) {
+				pcie_bus_config = PCIE_BUS_TUNE_OFF;
 			} else if (!strncmp(str, "pcie_bus_safe", 13)) {
 				pcie_bus_config = PCIE_BUS_SAFE;
 			} else if (!strncmp(str, "pcie_bus_perf", 13)) {
 				pcie_bus_config = PCIE_BUS_PERFORMANCE;
+			} else if (!strncmp(str, "pcie_bus_peer2peer", 18)) {
+				pcie_bus_config = PCIE_BUS_PEER2PEER;
 			} else {
 				printk(KERN_ERR "PCI: Unknown option `%s'\n",
 						str);

commit ed2888e906b56769b4ffabb9c577190438aa68b8
Author: Jon Mason <mason@myri.com>
Date:   Thu Sep 8 16:41:18 2011 -0500

    PCI: Remove MRRS modification from MPS setting code
    
    Modifying the Maximum Read Request Size to 0 (value of 128Bytes) has
    massive negative ramifications on some devices.  Without knowing which
    devices have this issue, do not modify from the default value when
    walking the PCI-E bus in pcie_bus_safe mode.  Also, make pcie_bus_safe
    the default procedure.
    
    Tested-by: Sven Schnelle <svens@stackframe.org>
    Tested-by: Simon Kirby <sim@hostway.ca>
    Tested-by: Stephen M. Cameron <scameron@beardog.cce.hp.com>
    Reported-and-tested-by: Eric Dumazet <eric.dumazet@gmail.com>
    Reported-and-tested-by: Niels Ole Salscheider <niels_ole@salscheider-online.de>
    References: https://bugzilla.kernel.org/show_bug.cgi?id=42162
    Signed-off-by: Jon Mason <mason@myri.com>
    Acked-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 0ce67423a0a3..4e84fd4a4312 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -77,7 +77,7 @@ unsigned long pci_cardbus_mem_size = DEFAULT_CARDBUS_MEM_SIZE;
 unsigned long pci_hotplug_io_size  = DEFAULT_HOTPLUG_IO_SIZE;
 unsigned long pci_hotplug_mem_size = DEFAULT_HOTPLUG_MEM_SIZE;
 
-enum pcie_bus_config_types pcie_bus_config = PCIE_BUS_PERFORMANCE;
+enum pcie_bus_config_types pcie_bus_config = PCIE_BUS_SAFE;
 
 /*
  * The default CLS is used if arch didn't set CLS explicitly and not

commit 47c08f3107270e5a439bc0106a308f7c48c9621d
Author: Randy Dunlap <rdunlap@xenotime.net>
Date:   Sat Aug 20 11:49:43 2011 -0700

    pci: fix new kernel-doc warning in pci.c
    
    Fix new kernel-doc warning in pci.c:
    
      Warning(drivers/pci/pci.c:3259): No description found for parameter 'mps'
      Warning(drivers/pci/pci.c:3259): Excess function parameter 'rq' description in 'pcie_set_mps'
    
    Signed-off-by: Randy Dunlap <rdunlap@xenotime.net>
    Cc: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 466fad6e6ee2..0ce67423a0a3 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -3250,7 +3250,7 @@ int pcie_get_mps(struct pci_dev *dev)
 /**
  * pcie_set_mps - set PCI Express maximum payload size
  * @dev: PCI device to query
- * @rq: maximum payload size in bytes
+ * @mps: maximum payload size in bytes
  *    valid values are 128, 256, 512, 1024, 2048, 4096
  *
  * If possible sets maximum payload size

commit b03e7495a862b028294f59fc87286d6d78ee7fa1
Author: Jon Mason <mason@myri.com>
Date:   Wed Jul 20 15:20:54 2011 -0500

    PCI: Set PCI-E Max Payload Size on fabric
    
    On a given PCI-E fabric, each device, bridge, and root port can have a
    different PCI-E maximum payload size.  There is a sizable performance
    boost for having the largest possible maximum payload size on each PCI-E
    device.  However, if improperly configured, fatal bus errors can occur.
    Thus, it is important to ensure that PCI-E payloads sends by a device
    are never larger than the MPS setting of all devices on the way to the
    destination.
    
    This can be achieved two ways:
    
    - A conservative approach is to use the smallest common denominator of
      the entire tree below a root complex for every device on that fabric.
    
    This means for example that having a 128 bytes MPS USB controller on one
    leg of a switch will dramatically reduce performances of a video card or
    10GE adapter on another leg of that same switch.
    
    It also means that any hierarchy supporting hotplug slots (including
    expresscard or thunderbolt I suppose, dbl check that) will have to be
    entirely clamped to 128 bytes since we cannot predict what will be
    plugged into those slots, and we cannot change the MPS on a "live"
    system.
    
    - A more optimal way is possible, if it falls within a couple of
      constraints:
    * The top-level host bridge will never generate packets larger than the
      smallest TLP (or if it can be controlled independently from its MPS at
      least)
    * The device will never generate packets larger than MPS (which can be
      configured via MRRS)
    * No support of direct PCI-E <-> PCI-E transfers between devices without
      some additional code to specifically deal with that case
    
    Then we can use an approach that basically ignores downstream requests
    and focuses exclusively on upstream requests. In that case, all we need
    to care about is that a device MPS is no larger than its parent MPS,
    which allows us to keep all switches/bridges to the max MPS supported by
    their parent and eventually the PHB.
    
    In this case, your USB controller would no longer "starve" your 10GE
    Ethernet and your hotplug slots won't affect your global MPS.
    Additionally, the hotplugged devices themselves can be configured to a
    larger MPS up to the value configured in the hotplug bridge.
    
    To choose between the two available options, two PCI kernel boot args
    have been added to the PCI calls.  "pcie_bus_safe" will provide the
    former behavior, while "pcie_bus_perf" will perform the latter behavior.
    By default, the latter behavior is used.
    
    NOTE: due to the location of the enablement, each arch will need to add
    calls to this function.  This patch only enables x86.
    
    This patch includes a number of changes recommended by Benjamin
    Herrenschmidt.
    
    Tested-by: Jordan_Hargrave@dell.com
    Signed-off-by: Jon Mason <mason@myri.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 08a95b369d85..466fad6e6ee2 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -77,6 +77,8 @@ unsigned long pci_cardbus_mem_size = DEFAULT_CARDBUS_MEM_SIZE;
 unsigned long pci_hotplug_io_size  = DEFAULT_HOTPLUG_IO_SIZE;
 unsigned long pci_hotplug_mem_size = DEFAULT_HOTPLUG_MEM_SIZE;
 
+enum pcie_bus_config_types pcie_bus_config = PCIE_BUS_PERFORMANCE;
+
 /*
  * The default CLS is used if arch didn't set CLS explicitly and not
  * all pci devices agree on the same value.  Arch can override either
@@ -3222,6 +3224,67 @@ int pcie_set_readrq(struct pci_dev *dev, int rq)
 }
 EXPORT_SYMBOL(pcie_set_readrq);
 
+/**
+ * pcie_get_mps - get PCI Express maximum payload size
+ * @dev: PCI device to query
+ *
+ * Returns maximum payload size in bytes
+ *    or appropriate error value.
+ */
+int pcie_get_mps(struct pci_dev *dev)
+{
+	int ret, cap;
+	u16 ctl;
+
+	cap = pci_pcie_cap(dev);
+	if (!cap)
+		return -EINVAL;
+
+	ret = pci_read_config_word(dev, cap + PCI_EXP_DEVCTL, &ctl);
+	if (!ret)
+		ret = 128 << ((ctl & PCI_EXP_DEVCTL_PAYLOAD) >> 5);
+
+	return ret;
+}
+
+/**
+ * pcie_set_mps - set PCI Express maximum payload size
+ * @dev: PCI device to query
+ * @rq: maximum payload size in bytes
+ *    valid values are 128, 256, 512, 1024, 2048, 4096
+ *
+ * If possible sets maximum payload size
+ */
+int pcie_set_mps(struct pci_dev *dev, int mps)
+{
+	int cap, err = -EINVAL;
+	u16 ctl, v;
+
+	if (mps < 128 || mps > 4096 || !is_power_of_2(mps))
+		goto out;
+
+	v = ffs(mps) - 8;
+	if (v > dev->pcie_mpss) 
+		goto out;
+	v <<= 5;
+
+	cap = pci_pcie_cap(dev);
+	if (!cap)
+		goto out;
+
+	err = pci_read_config_word(dev, cap + PCI_EXP_DEVCTL, &ctl);
+	if (err)
+		goto out;
+
+	if ((ctl & PCI_EXP_DEVCTL_PAYLOAD) != v) {
+		ctl &= ~PCI_EXP_DEVCTL_PAYLOAD;
+		ctl |= v;
+		err = pci_write_config_word(dev, cap + PCI_EXP_DEVCTL, ctl);
+	}
+out:
+	return err;
+}
+
 /**
  * pci_select_bars - Make BAR mask from the type of resource
  * @dev: the PCI device for which BAR mask is made
@@ -3505,6 +3568,10 @@ static int __init pci_setup(char *str)
 				pci_hotplug_io_size = memparse(str + 9, &str);
 			} else if (!strncmp(str, "hpmemsize=", 10)) {
 				pci_hotplug_mem_size = memparse(str + 10, &str);
+			} else if (!strncmp(str, "pcie_bus_safe", 13)) {
+				pcie_bus_config = PCIE_BUS_SAFE;
+			} else if (!strncmp(str, "pcie_bus_perf", 13)) {
+				pcie_bus_config = PCIE_BUS_PERFORMANCE;
 			} else {
 				printk(KERN_ERR "PCI: Unknown option `%s'\n",
 						str);

commit c9b378c7cbf623649e4ca64f955f2afd12ef01b2
Author: Jon Mason <jdmason@kudzu.us>
Date:   Tue Jun 28 18:26:25 2011 -0500

    PCI: correct pcie_set_readrq write size
    
    When setting the PCI-E MRRS, pcie_set_readrq queries the current
    settings via a pci_read_config_word call but writes the modified result
    via a pci_write_config_dword.  This results in writing 16 more bits than
    were queried.
    
    Also, the function description comment is slightly incorrect.
    
    Signed-off-by: Jon Mason <jdmason@kudzu.us>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index d549bbc93cdd..08a95b369d85 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -3191,7 +3191,7 @@ EXPORT_SYMBOL(pcie_get_readrq);
  * @rq: maximum memory read count in bytes
  *    valid values are 128, 256, 512, 1024, 2048, 4096
  *
- * If possible sets maximum read byte count
+ * If possible sets maximum memory read request in bytes
  */
 int pcie_set_readrq(struct pci_dev *dev, int rq)
 {
@@ -3214,7 +3214,7 @@ int pcie_set_readrq(struct pci_dev *dev, int rq)
 	if ((ctl & PCI_EXP_DEVCTL_READRQ) != v) {
 		ctl &= ~PCI_EXP_DEVCTL_READRQ;
 		ctl |= v;
-		err = pci_write_config_dword(dev, cap + PCI_EXP_DEVCTL, ctl);
+		err = pci_write_config_word(dev, cap + PCI_EXP_DEVCTL, ctl);
 	}
 
 out:

commit 864d296cf948aef0fa32b81407541572583f7572
Author: Chris Wright <chrisw@sous-sol.org>
Date:   Wed Jul 13 10:14:33 2011 -0700

    PCI: ARI is a PCIe v2 feature
    
    The function pci_enable_ari() may mistakenly set the downstream port
    of a v1 PCIe switch in ARI Forwarding mode.  This is a PCIe v2 feature,
    and with an SR-IOV device on that switch port believing the switch above
    is ARI capable it may attempt to use functions 8-255, translating into
    invalid (non-zero) device numbers for that bus.  This has been seen
    to cause Completion Timeouts and general misbehaviour including hangs
    and panics.
    
    Cc: stable@kernel.org
    Acked-by: Don Dutile <ddutile@redhat.com>
    Tested-by: Don Dutile <ddutile@redhat.com>
    Signed-off-by: Chris Wright <chrisw@sous-sol.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 692671b11667..d549bbc93cdd 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1905,7 +1905,7 @@ void pci_enable_ari(struct pci_dev *dev)
 {
 	int pos;
 	u32 cap;
-	u16 ctrl;
+	u16 flags, ctrl;
 	struct pci_dev *bridge;
 
 	if (!pci_is_pcie(dev) || dev->devfn)
@@ -1923,6 +1923,11 @@ void pci_enable_ari(struct pci_dev *dev)
 	if (!pos)
 		return;
 
+	/* ARI is a PCIe v2 feature */
+	pci_read_config_word(bridge, pos + PCI_EXP_FLAGS, &flags);
+	if ((flags & PCI_EXP_FLAGS_VERS) < 2)
+		return;
+
 	pci_read_config_dword(bridge, pos + PCI_EXP_DEVCAP2, &cap);
 	if (!(cap & PCI_EXP_DEVCAP2_ARI))
 		return;

commit f483d3923dc3a6394c483e28ccb3fe700bdf399e
Author: Ram Pai <linuxram@us.ibm.com>
Date:   Thu Jul 7 11:19:10 2011 -0700

    PCI: conditional resource-reallocation through kernel parameter pci=realloc
    
    Multiple attempts to dynamically reallocate pci resources have
    unfortunately lead to regressions. Though we continue to fix the
    regressions and fine tune the dynamic-reallocation behavior, we have not
    reached a acceptable state yet.
    
    This patch provides a interim solution. It disables dynamic reallocation
    by default, but adds the ability to enable it through pci=realloc kernel
    command line parameter.
    
    Tested-by: Oliver Hartkopp <socketcan@hartkopp.net>
    Signed-off-by: Ram Pai <linuxram@us.ibm.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 2c5b9b991279..692671b11667 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -3483,6 +3483,8 @@ static int __init pci_setup(char *str)
 				pci_no_msi();
 			} else if (!strcmp(str, "noaer")) {
 				pci_no_aer();
+			} else if (!strncmp(str, "realloc", 7)) {
+				pci_realloc();
 			} else if (!strcmp(str, "nodomains")) {
 				pci_no_domains();
 			} else if (!strncmp(str, "cbiosize=", 9)) {

commit 12f1ba5a7dac4caf8b4e6ccd6453f0a095e74c7c
Merge: 143e859d05d0 6e33a852a37d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jun 24 08:36:16 2011 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jbarnes/pci-2.6
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jbarnes/pci-2.6:
      x86/PCI/ACPI: fix type mismatch
      PCI: fix new kernel-doc warning
      PCI: Fix warning in drivers/pci/probe.c on sparc64

commit 7ad35cf288fd63a19bf50e490440a992de808b2b
Author: Dave Airlie <airlied@redhat.com>
Date:   Wed May 25 14:00:49 2011 +1000

    x86/uv/x2apic: update for change in pci bridge handling.
    
    When I added 3448a19da479b6bd1e28e2a2be9fa16c6a6feb39
    I forgot about the special uv handling code for this, so this
    patch fixes it up.
    
    Acked-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Acked-by: Ingo Molnar
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 56098b3e17c0..5f10c23dff94 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -3271,11 +3271,11 @@ void __init pci_register_set_vga_state(arch_set_vga_state_t func)
 }
 
 static int pci_set_vga_state_arch(struct pci_dev *dev, bool decode,
-		      unsigned int command_bits, bool change_bridge)
+		      unsigned int command_bits, u32 flags)
 {
 	if (arch_set_vga_state)
 		return arch_set_vga_state(dev, decode, command_bits,
-						change_bridge);
+						flags);
 	return 0;
 }
 

commit 3f37d6229ca309f96b163b943ff982f4697630cd
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Wed May 25 19:21:25 2011 -0700

    PCI: fix new kernel-doc warning
    
    Fix pci.c kernel-doc warnings:
    
    Warning(drivers/pci/pci.c:3292): No description found for parameter 'flags'
    Warning(drivers/pci/pci.c:3292): Excess function parameter 'change_bridge_flags' description in 'pci_set_vga_state'
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 56098b3e17c0..e43a7bbeb28f 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -3284,7 +3284,7 @@ static int pci_set_vga_state_arch(struct pci_dev *dev, bool decode,
  * @dev: the PCI device
  * @decode: true = enable decoding, false = disable decoding
  * @command_bits: PCI_COMMAND_IO and/or PCI_COMMAND_MEMORY
- * @change_bridge_flags: traverse ancestors and change bridges
+ * @flags: traverse ancestors and change bridges
  * CHANGE_BRIDGE_ONLY / CHANGE_BRIDGE
  */
 int pci_set_vga_state(struct pci_dev *dev, bool decode,

commit 98b98d316349e9a028e632629fe813d07fa5afdd
Merge: 0d66cba1ac3a 931474c4c306
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue May 24 12:06:40 2011 -0700

    Merge branch 'drm-core-next' of git://git.kernel.org/pub/scm/linux/kernel/git/airlied/drm-2.6
    
    * 'drm-core-next' of git://git.kernel.org/pub/scm/linux/kernel/git/airlied/drm-2.6: (169 commits)
      drivers/gpu/drm/radeon/atom.c: fix warning
      drm/radeon/kms: bump kms version number
      drm/radeon/kms: properly set num banks for fusion asics
      drm/radeon/kms/atom: move dig phy init out of modesetting
      drm/radeon/kms/cayman: fix typo in register mask
      drm/radeon/kms: fix typo in spread spectrum code
      drm/radeon/kms: fix tile_config value reported to userspace on cayman.
      drm/radeon/kms: fix incorrect comparison in cayman setup code.
      drm/radeon/kms: add wait idle ioctl for eg->cayman
      drm/radeon/cayman: setup hdp to invalidate and flush when asked
      drm/radeon/evergreen/btc/fusion: setup hdp to invalidate and flush when asked
      agp/uninorth: Fix lockups with radeon KMS and >1x.
      drm/radeon/kms: the SS_Id field in the LCD table if for LVDS only
      drm/radeon/kms: properly set the CLK_REF bit for DCE3 devices
      drm/radeon/kms: fixup eDP connector handling
      drm/radeon/kms: bail early for eDP in hotplug callback
      drm/radeon/kms: simplify hotplug handler logic
      drm/radeon/kms: rewrite DP handling
      drm/radeon/kms/atom: add support for setting DP panel mode
      drm/radeon/kms: atombios.h updates for DP panel mode
      ...

commit ffbdd3f7931fb7cb7e36d00d16303ec433be5145
Author: Alex Williamson <alex.williamson@redhat.com>
Date:   Tue May 10 10:02:27 2011 -0600

    PCI: Add interfaces to store and load the device saved state
    
    For KVM device assignment, we'd like to save off the state of a device
    prior to passing it to the guest and restore it later.  We also want
    to allow pci_reset_funciton() to be called while the device is owned
    by the guest.  This however overwrites and invalidates the struct pci_dev
    buffers, so we can't just manually call save and restore.  Add generic
    interfaces for the saved state to be stored and reloaded back into
    struct pci_dev at a later time.
    
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index d6e5b8ea9194..22c9b27fdd8d 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -976,6 +976,104 @@ void pci_restore_state(struct pci_dev *dev)
 	dev->state_saved = false;
 }
 
+struct pci_saved_state {
+	u32 config_space[16];
+	struct pci_cap_saved_data cap[0];
+};
+
+/**
+ * pci_store_saved_state - Allocate and return an opaque struct containing
+ *			   the device saved state.
+ * @dev: PCI device that we're dealing with
+ *
+ * Rerturn NULL if no state or error.
+ */
+struct pci_saved_state *pci_store_saved_state(struct pci_dev *dev)
+{
+	struct pci_saved_state *state;
+	struct pci_cap_saved_state *tmp;
+	struct pci_cap_saved_data *cap;
+	struct hlist_node *pos;
+	size_t size;
+
+	if (!dev->state_saved)
+		return NULL;
+
+	size = sizeof(*state) + sizeof(struct pci_cap_saved_data);
+
+	hlist_for_each_entry(tmp, pos, &dev->saved_cap_space, next)
+		size += sizeof(struct pci_cap_saved_data) + tmp->cap.size;
+
+	state = kzalloc(size, GFP_KERNEL);
+	if (!state)
+		return NULL;
+
+	memcpy(state->config_space, dev->saved_config_space,
+	       sizeof(state->config_space));
+
+	cap = state->cap;
+	hlist_for_each_entry(tmp, pos, &dev->saved_cap_space, next) {
+		size_t len = sizeof(struct pci_cap_saved_data) + tmp->cap.size;
+		memcpy(cap, &tmp->cap, len);
+		cap = (struct pci_cap_saved_data *)((u8 *)cap + len);
+	}
+	/* Empty cap_save terminates list */
+
+	return state;
+}
+EXPORT_SYMBOL_GPL(pci_store_saved_state);
+
+/**
+ * pci_load_saved_state - Reload the provided save state into struct pci_dev.
+ * @dev: PCI device that we're dealing with
+ * @state: Saved state returned from pci_store_saved_state()
+ */
+int pci_load_saved_state(struct pci_dev *dev, struct pci_saved_state *state)
+{
+	struct pci_cap_saved_data *cap;
+
+	dev->state_saved = false;
+
+	if (!state)
+		return 0;
+
+	memcpy(dev->saved_config_space, state->config_space,
+	       sizeof(state->config_space));
+
+	cap = state->cap;
+	while (cap->size) {
+		struct pci_cap_saved_state *tmp;
+
+		tmp = pci_find_saved_cap(dev, cap->cap_nr);
+		if (!tmp || tmp->cap.size != cap->size)
+			return -EINVAL;
+
+		memcpy(tmp->cap.data, cap->data, tmp->cap.size);
+		cap = (struct pci_cap_saved_data *)((u8 *)cap +
+		       sizeof(struct pci_cap_saved_data) + cap->size);
+	}
+
+	dev->state_saved = true;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(pci_load_saved_state);
+
+/**
+ * pci_load_and_free_saved_state - Reload the save state pointed to by state,
+ *				   and free the memory allocated for it.
+ * @dev: PCI device that we're dealing with
+ * @state: Pointer to saved state returned from pci_store_saved_state()
+ */
+int pci_load_and_free_saved_state(struct pci_dev *dev,
+				  struct pci_saved_state **state)
+{
+	int ret = pci_load_saved_state(dev, *state);
+	kfree(*state);
+	*state = NULL;
+	return ret;
+}
+EXPORT_SYMBOL_GPL(pci_load_and_free_saved_state);
+
 static int do_pci_enable_device(struct pci_dev *dev, int bars)
 {
 	int err;

commit 24a4742f0be6226eb0106fbb17caf4d711d1ad43
Author: Alex Williamson <alex.williamson@redhat.com>
Date:   Tue May 10 10:02:11 2011 -0600

    PCI: Track the size of each saved capability data area
    
    This will allow us to store and load it later.
    
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 53302cbdb94c..d6e5b8ea9194 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -830,7 +830,7 @@ static int pci_save_pcie_state(struct pci_dev *dev)
 		dev_err(&dev->dev, "buffer not found in %s\n", __func__);
 		return -ENOMEM;
 	}
-	cap = (u16 *)&save_state->data[0];
+	cap = (u16 *)&save_state->cap.data[0];
 
 	pci_read_config_word(dev, pos + PCI_EXP_FLAGS, &flags);
 
@@ -863,7 +863,7 @@ static void pci_restore_pcie_state(struct pci_dev *dev)
 	pos = pci_find_capability(dev, PCI_CAP_ID_EXP);
 	if (!save_state || pos <= 0)
 		return;
-	cap = (u16 *)&save_state->data[0];
+	cap = (u16 *)&save_state->cap.data[0];
 
 	pci_read_config_word(dev, pos + PCI_EXP_FLAGS, &flags);
 
@@ -899,7 +899,8 @@ static int pci_save_pcix_state(struct pci_dev *dev)
 		return -ENOMEM;
 	}
 
-	pci_read_config_word(dev, pos + PCI_X_CMD, (u16 *)save_state->data);
+	pci_read_config_word(dev, pos + PCI_X_CMD,
+			     (u16 *)save_state->cap.data);
 
 	return 0;
 }
@@ -914,7 +915,7 @@ static void pci_restore_pcix_state(struct pci_dev *dev)
 	pos = pci_find_capability(dev, PCI_CAP_ID_PCIX);
 	if (!save_state || pos <= 0)
 		return;
-	cap = (u16 *)&save_state->data[0];
+	cap = (u16 *)&save_state->cap.data[0];
 
 	pci_write_config_word(dev, pos + PCI_X_CMD, cap[i++]);
 }
@@ -1771,7 +1772,8 @@ static int pci_add_cap_save_buffer(
 	if (!save_state)
 		return -ENOMEM;
 
-	save_state->cap_nr = cap;
+	save_state->cap.cap_nr = cap;
+	save_state->cap.size = size;
 	pci_add_saved_cap(dev, save_state);
 
 	return 0;

commit 51c2e0a7e5bc7ed1384cc68cfb95e702571500c9
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Fri Jan 14 08:53:04 2011 -0800

    PCI: add latency tolerance reporting enable/disable support
    
    Latency tolerance reporting allows devices to send messages to the root
    complex indicating their latency tolerance for snooped & unsnooped
    memory transactions.  Add support for enabling & disabling this
    feature, along with a routine to set the max latencies a device should
    send upstream.
    
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 01e4cab2e5cb..53302cbdb94c 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1979,6 +1979,155 @@ void pci_disable_obff(struct pci_dev *dev)
 }
 EXPORT_SYMBOL(pci_disable_obff);
 
+/**
+ * pci_ltr_supported - check whether a device supports LTR
+ * @dev: PCI device
+ *
+ * RETURNS:
+ * True if @dev supports latency tolerance reporting, false otherwise.
+ */
+bool pci_ltr_supported(struct pci_dev *dev)
+{
+	int pos;
+	u32 cap;
+
+	if (!pci_is_pcie(dev))
+		return false;
+
+	pos = pci_pcie_cap(dev);
+	if (!pos)
+		return false;
+
+	pci_read_config_dword(dev, pos + PCI_EXP_DEVCAP2, &cap);
+
+	return cap & PCI_EXP_DEVCAP2_LTR;
+}
+EXPORT_SYMBOL(pci_ltr_supported);
+
+/**
+ * pci_enable_ltr - enable latency tolerance reporting
+ * @dev: PCI device
+ *
+ * Enable LTR on @dev if possible, which means enabling it first on
+ * upstream ports.
+ *
+ * RETURNS:
+ * Zero on success, errno on failure.
+ */
+int pci_enable_ltr(struct pci_dev *dev)
+{
+	int pos;
+	u16 ctrl;
+	int ret;
+
+	if (!pci_ltr_supported(dev))
+		return -ENOTSUPP;
+
+	pos = pci_pcie_cap(dev);
+	if (!pos)
+		return -ENOTSUPP;
+
+	/* Only primary function can enable/disable LTR */
+	if (PCI_FUNC(dev->devfn) != 0)
+		return -EINVAL;
+
+	/* Enable upstream ports first */
+	if (dev->bus) {
+		ret = pci_enable_ltr(dev->bus->self);
+		if (ret)
+			return ret;
+	}
+
+	pci_read_config_word(dev, pos + PCI_EXP_DEVCTL2, &ctrl);
+	ctrl |= PCI_EXP_LTR_EN;
+	pci_write_config_word(dev, pos + PCI_EXP_DEVCTL2, ctrl);
+
+	return 0;
+}
+EXPORT_SYMBOL(pci_enable_ltr);
+
+/**
+ * pci_disable_ltr - disable latency tolerance reporting
+ * @dev: PCI device
+ */
+void pci_disable_ltr(struct pci_dev *dev)
+{
+	int pos;
+	u16 ctrl;
+
+	if (!pci_ltr_supported(dev))
+		return;
+
+	pos = pci_pcie_cap(dev);
+	if (!pos)
+		return;
+
+	/* Only primary function can enable/disable LTR */
+	if (PCI_FUNC(dev->devfn) != 0)
+		return;
+
+	pci_read_config_word(dev, pos + PCI_EXP_DEVCTL2, &ctrl);
+	ctrl &= ~PCI_EXP_LTR_EN;
+	pci_write_config_word(dev, pos + PCI_EXP_DEVCTL2, ctrl);
+}
+EXPORT_SYMBOL(pci_disable_ltr);
+
+static int __pci_ltr_scale(int *val)
+{
+	int scale = 0;
+
+	while (*val > 1023) {
+		*val = (*val + 31) / 32;
+		scale++;
+	}
+	return scale;
+}
+
+/**
+ * pci_set_ltr - set LTR latency values
+ * @dev: PCI device
+ * @snoop_lat_ns: snoop latency in nanoseconds
+ * @nosnoop_lat_ns: nosnoop latency in nanoseconds
+ *
+ * Figure out the scale and set the LTR values accordingly.
+ */
+int pci_set_ltr(struct pci_dev *dev, int snoop_lat_ns, int nosnoop_lat_ns)
+{
+	int pos, ret, snoop_scale, nosnoop_scale;
+	u16 val;
+
+	if (!pci_ltr_supported(dev))
+		return -ENOTSUPP;
+
+	snoop_scale = __pci_ltr_scale(&snoop_lat_ns);
+	nosnoop_scale = __pci_ltr_scale(&nosnoop_lat_ns);
+
+	if (snoop_lat_ns > PCI_LTR_VALUE_MASK ||
+	    nosnoop_lat_ns > PCI_LTR_VALUE_MASK)
+		return -EINVAL;
+
+	if ((snoop_scale > (PCI_LTR_SCALE_MASK >> PCI_LTR_SCALE_SHIFT)) ||
+	    (nosnoop_scale > (PCI_LTR_SCALE_MASK >> PCI_LTR_SCALE_SHIFT)))
+		return -EINVAL;
+
+	pos = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_LTR);
+	if (!pos)
+		return -ENOTSUPP;
+
+	val = (snoop_scale << PCI_LTR_SCALE_SHIFT) | snoop_lat_ns;
+	ret = pci_write_config_word(dev, pos + PCI_LTR_MAX_SNOOP_LAT, val);
+	if (ret != 4)
+		return -EIO;
+
+	val = (nosnoop_scale << PCI_LTR_SCALE_SHIFT) | nosnoop_lat_ns;
+	ret = pci_write_config_word(dev, pos + PCI_LTR_MAX_NOSNOOP_LAT, val);
+	if (ret != 4)
+		return -EIO;
+
+	return 0;
+}
+EXPORT_SYMBOL(pci_set_ltr);
+
 static int pci_acs_enable;
 
 /**

commit 48a92a8179b3e677fac07db7bd109e68f020468c
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Mon Jan 10 12:46:36 2011 -0800

    PCI: add OBFF enable/disable support
    
    OBFF (optimized buffer flush/fill), where supported, can help improve
    energy efficiency by giving devices information about when interrupts
    and other activity will have a reduced power impact.  It requires
    support from both the device and system (i.e. not only does the device
    need to respond to OBFF messages, but the platform must be capable of
    generating and routing them to the end point).
    
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index d0182bed7acc..01e4cab2e5cb 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1887,6 +1887,98 @@ void pci_disable_ido(struct pci_dev *dev, unsigned long type)
 }
 EXPORT_SYMBOL(pci_disable_ido);
 
+/**
+ * pci_enable_obff - enable optimized buffer flush/fill
+ * @dev: PCI device
+ * @type: type of signaling to use
+ *
+ * Try to enable @type OBFF signaling on @dev.  It will try using WAKE#
+ * signaling if possible, falling back to message signaling only if
+ * WAKE# isn't supported.  @type should indicate whether the PCIe link
+ * be brought out of L0s or L1 to send the message.  It should be either
+ * %PCI_EXP_OBFF_SIGNAL_ALWAYS or %PCI_OBFF_SIGNAL_L0.
+ *
+ * If your device can benefit from receiving all messages, even at the
+ * power cost of bringing the link back up from a low power state, use
+ * %PCI_EXP_OBFF_SIGNAL_ALWAYS.  Otherwise, use %PCI_OBFF_SIGNAL_L0 (the
+ * preferred type).
+ *
+ * RETURNS:
+ * Zero on success, appropriate error number on failure.
+ */
+int pci_enable_obff(struct pci_dev *dev, enum pci_obff_signal_type type)
+{
+	int pos;
+	u32 cap;
+	u16 ctrl;
+	int ret;
+
+	if (!pci_is_pcie(dev))
+		return -ENOTSUPP;
+
+	pos = pci_pcie_cap(dev);
+	if (!pos)
+		return -ENOTSUPP;
+
+	pci_read_config_dword(dev, pos + PCI_EXP_DEVCAP2, &cap);
+	if (!(cap & PCI_EXP_OBFF_MASK))
+		return -ENOTSUPP; /* no OBFF support at all */
+
+	/* Make sure the topology supports OBFF as well */
+	if (dev->bus) {
+		ret = pci_enable_obff(dev->bus->self, type);
+		if (ret)
+			return ret;
+	}
+
+	pci_read_config_word(dev, pos + PCI_EXP_DEVCTL2, &ctrl);
+	if (cap & PCI_EXP_OBFF_WAKE)
+		ctrl |= PCI_EXP_OBFF_WAKE_EN;
+	else {
+		switch (type) {
+		case PCI_EXP_OBFF_SIGNAL_L0:
+			if (!(ctrl & PCI_EXP_OBFF_WAKE_EN))
+				ctrl |= PCI_EXP_OBFF_MSGA_EN;
+			break;
+		case PCI_EXP_OBFF_SIGNAL_ALWAYS:
+			ctrl &= ~PCI_EXP_OBFF_WAKE_EN;
+			ctrl |= PCI_EXP_OBFF_MSGB_EN;
+			break;
+		default:
+			WARN(1, "bad OBFF signal type\n");
+			return -ENOTSUPP;
+		}
+	}
+	pci_write_config_word(dev, pos + PCI_EXP_DEVCTL2, ctrl);
+
+	return 0;
+}
+EXPORT_SYMBOL(pci_enable_obff);
+
+/**
+ * pci_disable_obff - disable optimized buffer flush/fill
+ * @dev: PCI device
+ *
+ * Disable OBFF on @dev.
+ */
+void pci_disable_obff(struct pci_dev *dev)
+{
+	int pos;
+	u16 ctrl;
+
+	if (!pci_is_pcie(dev))
+		return;
+
+	pos = pci_pcie_cap(dev);
+	if (!pos)
+		return;
+
+	pci_read_config_word(dev, pos + PCI_EXP_DEVCTL2, &ctrl);
+	ctrl &= ~PCI_EXP_OBFF_WAKE_EN;
+	pci_write_config_word(dev, pos + PCI_EXP_DEVCTL2, ctrl);
+}
+EXPORT_SYMBOL(pci_disable_obff);
+
 static int pci_acs_enable;
 
 /**

commit b48d4425b602f5f4978299474743dbea130d940d
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Tue Oct 19 13:07:57 2010 -0700

    PCI: add ID-based ordering enable/disable support
    
    Add support to allow drivers to enable/disable ID-based ordering.  Where
    supported, ID-based ordering can significantly improve the latency of
    individual requests by preventing them from queueing up behind unrelated
    traffic.
    
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 44d1c7c3876b..d0182bed7acc 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1834,6 +1834,59 @@ void pci_enable_ari(struct pci_dev *dev)
 	bridge->ari_enabled = 1;
 }
 
+/**
+ * pci_enable_ido - enable ID-based ordering on a device
+ * @dev: the PCI device
+ * @type: which types of IDO to enable
+ *
+ * Enable ID-based ordering on @dev.  @type can contain the bits
+ * %PCI_EXP_IDO_REQUEST and/or %PCI_EXP_IDO_COMPLETION to indicate
+ * which types of transactions are allowed to be re-ordered.
+ */
+void pci_enable_ido(struct pci_dev *dev, unsigned long type)
+{
+	int pos;
+	u16 ctrl;
+
+	pos = pci_pcie_cap(dev);
+	if (!pos)
+		return;
+
+	pci_read_config_word(dev, pos + PCI_EXP_DEVCTL2, &ctrl);
+	if (type & PCI_EXP_IDO_REQUEST)
+		ctrl |= PCI_EXP_IDO_REQ_EN;
+	if (type & PCI_EXP_IDO_COMPLETION)
+		ctrl |= PCI_EXP_IDO_CMP_EN;
+	pci_write_config_word(dev, pos + PCI_EXP_DEVCTL2, ctrl);
+}
+EXPORT_SYMBOL(pci_enable_ido);
+
+/**
+ * pci_disable_ido - disable ID-based ordering on a device
+ * @dev: the PCI device
+ * @type: which types of IDO to disable
+ */
+void pci_disable_ido(struct pci_dev *dev, unsigned long type)
+{
+	int pos;
+	u16 ctrl;
+
+	if (!pci_is_pcie(dev))
+		return;
+
+	pos = pci_pcie_cap(dev);
+	if (!pos)
+		return;
+
+	pci_read_config_word(dev, pos + PCI_EXP_DEVCTL2, &ctrl);
+	if (type & PCI_EXP_IDO_REQUEST)
+		ctrl &= ~PCI_EXP_IDO_REQ_EN;
+	if (type & PCI_EXP_IDO_COMPLETION)
+		ctrl &= ~PCI_EXP_IDO_CMP_EN;
+	pci_write_config_word(dev, pos + PCI_EXP_DEVCTL2, ctrl);
+}
+EXPORT_SYMBOL(pci_disable_ido);
+
 static int pci_acs_enable;
 
 /**

commit 83d74e036b94ffbf871667eede5ef02993709452
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sat Mar 5 21:48:44 2011 +0100

    PCI/PM: Add kerneldoc description of pci_pm_reset()
    
    The pci_pm_reset() function is not a very nice interface due to its
    limitations and conditional behavior (e.g. it doesn't affect devices
    in low-power states), but it cannot be simply dropped, because
    existing device drivers may depend on it.  However, its behavior and
    limitations should be well documented, so add an appropriate
    kerneldoc comment to it.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 2472e7177b4b..44d1c7c3876b 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2479,6 +2479,21 @@ static int pci_af_flr(struct pci_dev *dev, int probe)
 	return 0;
 }
 
+/**
+ * pci_pm_reset - Put device into PCI_D3 and back into PCI_D0.
+ * @dev: Device to reset.
+ * @probe: If set, only check if the device can be reset this way.
+ *
+ * If @dev supports native PCI PM and its PCI_PM_CTRL_NO_SOFT_RESET flag is
+ * unset, it will be reinitialized internally when going from PCI_D3hot to
+ * PCI_D0.  If that's the case and the device is not in a low-power state
+ * already, force it into PCI_D3hot and back to PCI_D0, causing it to be reset.
+ *
+ * NOTE: This causes the caller to sleep for twice the device power transition
+ * cooldown period, which for the D0->D3hot and D3hot->D0 transitions is 10 ms
+ * by devault (i.e. unless the @dev's d3_delay field has a different value).
+ * Moreover, only devices in D0 can be reset by this function.
+ */
 static int pci_pm_reset(struct pci_dev *dev, int probe)
 {
 	u16 csr;

commit 3448a19da479b6bd1e28e2a2be9fa16c6a6feb39
Author: Dave Airlie <airlied@redhat.com>
Date:   Tue Jun 1 15:32:24 2010 +1000

    vgaarb: use bridges to control VGA routing where possible.
    
    So in a lot of modern systems, a GPU will always be below a parent bridge that won't share with any other GPUs. This means VGA arbitration on those GPUs can be controlled by using the bridge routing instead of io/mem decodes.
    
    The problem is locating which GPUs share which upstream bridges. This patch attempts to identify all the GPUs which can be controlled via bridges, and ones that can't. This patch endeavours to work out the bridge sharing semantics.
    
    When disabling GPUs via a bridge, it doesn't do irq callbacks or touch the io/mem decodes for the gpu.
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 2472e7177b4b..a339237f4f96 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2875,31 +2875,34 @@ static int pci_set_vga_state_arch(struct pci_dev *dev, bool decode,
  * @dev: the PCI device
  * @decode: true = enable decoding, false = disable decoding
  * @command_bits: PCI_COMMAND_IO and/or PCI_COMMAND_MEMORY
- * @change_bridge: traverse ancestors and change bridges
+ * @change_bridge_flags: traverse ancestors and change bridges
+ * CHANGE_BRIDGE_ONLY / CHANGE_BRIDGE
  */
 int pci_set_vga_state(struct pci_dev *dev, bool decode,
-		      unsigned int command_bits, bool change_bridge)
+		      unsigned int command_bits, u32 flags)
 {
 	struct pci_bus *bus;
 	struct pci_dev *bridge;
 	u16 cmd;
 	int rc;
 
-	WARN_ON(command_bits & ~(PCI_COMMAND_IO|PCI_COMMAND_MEMORY));
+	WARN_ON((flags & PCI_VGA_STATE_CHANGE_DECODES) & (command_bits & ~(PCI_COMMAND_IO|PCI_COMMAND_MEMORY)));
 
 	/* ARCH specific VGA enables */
-	rc = pci_set_vga_state_arch(dev, decode, command_bits, change_bridge);
+	rc = pci_set_vga_state_arch(dev, decode, command_bits, flags);
 	if (rc)
 		return rc;
 
-	pci_read_config_word(dev, PCI_COMMAND, &cmd);
-	if (decode == true)
-		cmd |= command_bits;
-	else
-		cmd &= ~command_bits;
-	pci_write_config_word(dev, PCI_COMMAND, cmd);
+	if (flags & PCI_VGA_STATE_CHANGE_DECODES) {
+		pci_read_config_word(dev, PCI_COMMAND, &cmd);
+		if (decode == true)
+			cmd |= command_bits;
+		else
+			cmd &= ~command_bits;
+		pci_write_config_word(dev, PCI_COMMAND, cmd);
+	}
 
-	if (change_bridge == false)
+	if (!(flags & PCI_VGA_STATE_CHANGE_BRIDGE))
 		return 0;
 
 	bus = dev->bus;

commit 1a680b7c325882188865f05b9a88d32f75f26495
Author: Naga Chumbalkar <nagananda.chumbalkar@hp.com>
Date:   Mon Mar 21 03:29:08 2011 +0000

    PCI: PCIe links may not get configured for ASPM under POWERSAVE mode
    
    v3 -> v2: Moved ASPM enabling logic to pci_set_power_state()
    v2 -> v1: Preserved the logic in pci_raw_set_power_state()
            : Added ASPM enabling logic after scanning Root Bridge
            : http://marc.info/?l=linux-pci&m=130046996216391&w=2
    v1      : http://marc.info/?l=linux-pci&m=130013164703283&w=2
    
    The assumption made in commit 41cd766b065970ff6f6c89dd1cf55fa706c84a3d
    (PCI: Don't enable aspm before drivers have had a chance to veto it) that
    pci_enable_device() will result in re-configuring ASPM when aspm_policy is
    POWERSAVE is no longer valid.  This is due to commit
    97c145f7c87453cec90e91238fba5fe2c1561b32 (PCI: read current power state
    at enable time) which resets dev->current_state to D0. Due to this the
    call to pcie_aspm_pm_state_change() is never made. Note the equality check
    (below) that returns early:
    ./drivers/pci/pci.c: pci_raw_set_pci_power_state()
    546         /* Check if we're already there */
    547         if (dev->current_state == state)
    548                 return 0;
    
    Therefore OSPM never configures the PCIe links for ASPM to turn them "on".
    
    Fix it by configuring ASPM from the pci_enable_device() code path. This
    also allows a driver such as the e1000e networking driver a chance to
    disable ASPM (L0s, L1), if need be, prior to enabling the device. A
    driver may perform this action if the device is known to mis-behave
    wrt ASPM.
    
    Signed-off-by: Naga Chumbalkar <nagananda.chumbalkar@hp.com>
    Acked-by: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Matthew Garrett <mjg59@srcf.ucam.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index b714d787bddd..2472e7177b4b 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -740,6 +740,12 @@ int pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 
 	if (!__pci_complete_power_transition(dev, state))
 		error = 0;
+	/*
+	 * When aspm_policy is "powersave" this call ensures
+	 * that ASPM is configured.
+	 */
+	if (!error && dev->bus->self)
+		pcie_aspm_powersave_config_link(dev->bus->self);
 
 	return error;
 }

commit 0f953bf6b4efa0daddb7c418130a9bd3ee97f7ed
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Dec 29 13:22:08 2010 +0100

    PCI/PM: Report wakeup events before resuming devices
    
    Make wakeup events be reported by the PCI subsystem before attempting to
    resume devices or queuing up runtime resume requests for them, because
    wakeup events should be reported as soon as they have been detected.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index bf7ad2c09955..b714d787bddd 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1308,8 +1308,8 @@ bool pci_check_pme_status(struct pci_dev *dev)
 static int pci_pme_wakeup(struct pci_dev *dev, void *ign)
 {
 	if (pci_check_pme_status(dev)) {
-		pm_request_resume(&dev->dev);
 		pci_wakeup_event(dev);
+		pm_request_resume(&dev->dev);
 	}
 	return 0;
 }

commit b6e335aeeb114dccb07eaa09e8b62ff9510cf745
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Dec 29 13:21:23 2010 +0100

    PCI/PM: Use pm_wakeup_event() directly for reporting wakeup events
    
    After recent changes related to wakeup events pm_wakeup_event()
    automatically checks if the given device is configured to signal wakeup,
    so pci_wakeup_event() may be a static inline function calling
    pm_wakeup_event() directly.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 6762dcae90ab..bf7ad2c09955 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1297,22 +1297,6 @@ bool pci_check_pme_status(struct pci_dev *dev)
 	return ret;
 }
 
-/*
- * Time to wait before the system can be put into a sleep state after reporting
- * a wakeup event signaled by a PCI device.
- */
-#define PCI_WAKEUP_COOLDOWN	100
-
-/**
- * pci_wakeup_event - Report a wakeup event related to a given PCI device.
- * @dev: Device to report the wakeup event for.
- */
-void pci_wakeup_event(struct pci_dev *dev)
-{
-	if (device_may_wakeup(&dev->dev))
-		pm_wakeup_event(&dev->dev, PCI_WAKEUP_COOLDOWN);
-}
-
 /**
  * pci_pme_wakeup - Wake up a PCI device if its PME Status bit is set.
  * @dev: Device to handle.

commit 1d3c16a818e992c199844954d95c17fd7ce6cbba
Author: Jon Mason <jon.mason@exar.com>
Date:   Tue Nov 30 17:43:26 2010 -0600

    PCI: make pci_restore_state return void
    
    pci_restore_state only ever returns 0, thus there is no benefit in
    having it return any value.  Also, a large majority of the callers do
    not check the return code of pci_restore_state.  Make the
    pci_restore_state a void return and avoid the overhead.
    
    Acked-by: Mauro Carvalho Chehab <mchehab@redhat.com>
    Signed-off-by: Jon Mason <jon.mason@exar.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 710c8a29be0d..6762dcae90ab 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -937,14 +937,13 @@ pci_save_state(struct pci_dev *dev)
  * pci_restore_state - Restore the saved state of a PCI device
  * @dev: - PCI device that we're dealing with
  */
-int 
-pci_restore_state(struct pci_dev *dev)
+void pci_restore_state(struct pci_dev *dev)
 {
 	int i;
 	u32 val;
 
 	if (!dev->state_saved)
-		return 0;
+		return;
 
 	/* PCI Express register must be restored first */
 	pci_restore_pcie_state(dev);
@@ -968,8 +967,6 @@ pci_restore_state(struct pci_dev *dev)
 	pci_restore_iov_state(dev);
 
 	dev->state_saved = false;
-
-	return 0;
 }
 
 static int do_pci_enable_device(struct pci_dev *dev, int bars)

commit 97c145f7c87453cec90e91238fba5fe2c1561b32
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Fri Nov 5 15:16:36 2010 -0400

    PCI: read current power state at enable time
    
    When we enable a PCI device, we avoid doing a lot of the initial setup
    work if the device's enable count is non-zero.  If we don't fetch the
    power state though, we may later fail to set up MSI due to the unknown
    status.  So pick it up before we short circuit the rest due to a
    pre-existing enable or mismatched enable/disable pair (as happens with
    VGA devices, which are special in a special way).
    
    Tested-by: Jesse Brandeburg <jesse.brandeburg@gmail.com>
    Reported-by: Dave Airlie <airlied@linux.ie>
    Tested-by: Dave Airlie <airlied@linux.ie>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index e98c8104297b..710c8a29be0d 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1007,6 +1007,18 @@ static int __pci_enable_device_flags(struct pci_dev *dev,
 	int err;
 	int i, bars = 0;
 
+	/*
+	 * Power state could be unknown at this point, either due to a fresh
+	 * boot or a device removal call.  So get the current power state
+	 * so that things like MSI message writing will behave as expected
+	 * (e.g. if the device really is in D0 at enable time).
+	 */
+	if (dev->pm_cap) {
+		u16 pmcsr;
+		pci_read_config_word(dev, dev->pm_cap + PCI_PM_CTRL, &pmcsr);
+		dev->current_state = (pmcsr & PCI_PM_CTRL_STATE_MASK);
+	}
+
 	if (atomic_add_return(1, &dev->enable_cnt) > 1)
 		return 0;		/* already enabled */
 

commit df17e62e5bff60aeefd0e81165c62f9e46f33217
Author: Matthew Garrett <mjg@redhat.com>
Date:   Mon Oct 4 14:22:29 2010 -0400

    PCI: Add support for polling PME state on suspended legacy PCI devices
    
    Not all hardware vendors hook up the PME line for legacy PCI devices,
    meaning that wakeup events get lost. The only way around this is to poll
    the devices to see if their state has changed, so add support for doing
    that on legacy PCI devices that aren't part of the core chipset.
    
    Acked-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index cc232c016ef9..e98c8104297b 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -38,6 +38,19 @@ EXPORT_SYMBOL(pci_pci_problems);
 
 unsigned int pci_pm_d3_delay;
 
+static void pci_pme_list_scan(struct work_struct *work);
+
+static LIST_HEAD(pci_pme_list);
+static DEFINE_MUTEX(pci_pme_list_mutex);
+static DECLARE_DELAYED_WORK(pci_pme_work, pci_pme_list_scan);
+
+struct pci_pme_device {
+	struct list_head list;
+	struct pci_dev *dev;
+};
+
+#define PME_TIMEOUT 1000 /* How long between PME checks */
+
 static void pci_dev_d3_sleep(struct pci_dev *dev)
 {
 	unsigned int delay = dev->d3_delay;
@@ -1331,6 +1344,32 @@ bool pci_pme_capable(struct pci_dev *dev, pci_power_t state)
 	return !!(dev->pme_support & (1 << state));
 }
 
+static void pci_pme_list_scan(struct work_struct *work)
+{
+	struct pci_pme_device *pme_dev;
+
+	mutex_lock(&pci_pme_list_mutex);
+	if (!list_empty(&pci_pme_list)) {
+		list_for_each_entry(pme_dev, &pci_pme_list, list)
+			pci_pme_wakeup(pme_dev->dev, NULL);
+		schedule_delayed_work(&pci_pme_work, msecs_to_jiffies(PME_TIMEOUT));
+	}
+	mutex_unlock(&pci_pme_list_mutex);
+}
+
+/**
+ * pci_external_pme - is a device an external PCI PME source?
+ * @dev: PCI device to check
+ *
+ */
+
+static bool pci_external_pme(struct pci_dev *dev)
+{
+	if (pci_is_pcie(dev) || dev->bus->number == 0)
+		return false;
+	return true;
+}
+
 /**
  * pci_pme_active - enable or disable PCI device's PME# function
  * @dev: PCI device to handle.
@@ -1354,6 +1393,44 @@ void pci_pme_active(struct pci_dev *dev, bool enable)
 
 	pci_write_config_word(dev, dev->pm_cap + PCI_PM_CTRL, pmcsr);
 
+	/* PCI (as opposed to PCIe) PME requires that the device have
+	   its PME# line hooked up correctly. Not all hardware vendors
+	   do this, so the PME never gets delivered and the device
+	   remains asleep. The easiest way around this is to
+	   periodically walk the list of suspended devices and check
+	   whether any have their PME flag set. The assumption is that
+	   we'll wake up often enough anyway that this won't be a huge
+	   hit, and the power savings from the devices will still be a
+	   win. */
+
+	if (pci_external_pme(dev)) {
+		struct pci_pme_device *pme_dev;
+		if (enable) {
+			pme_dev = kmalloc(sizeof(struct pci_pme_device),
+					  GFP_KERNEL);
+			if (!pme_dev)
+				goto out;
+			pme_dev->dev = dev;
+			mutex_lock(&pci_pme_list_mutex);
+			list_add(&pme_dev->list, &pci_pme_list);
+			if (list_is_singular(&pci_pme_list))
+				schedule_delayed_work(&pci_pme_work,
+						      msecs_to_jiffies(PME_TIMEOUT));
+			mutex_unlock(&pci_pme_list_mutex);
+		} else {
+			mutex_lock(&pci_pme_list_mutex);
+			list_for_each_entry(pme_dev, &pci_pme_list, list) {
+				if (pme_dev->dev == dev) {
+					list_del(&pme_dev->list);
+					kfree(pme_dev);
+					break;
+				}
+			}
+			mutex_unlock(&pci_pme_list_mutex);
+		}
+	}
+
+out:
 	dev_printk(KERN_DEBUG, &dev->dev, "PME# %s\n",
 			enable ? "enabled" : "disabled");
 }

commit 93e75faba3982767d425323aec5726282d3ad7a2
Author: Julia Lawall <julia@diku.dk>
Date:   Thu Aug 5 22:23:16 2010 +0200

    PCI: Adjust confusing if indentation in pcie_get_readrq
    
    Indent the branch of an if.
    
    The semantic match that finds this problem is as follows:
    (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @r disable braces4@
    position p1,p2;
    statement S1,S2;
    @@
    
    (
    if (...) { ... }
    |
    if (...) S1@p1 S2@p2
    )
    
    @script:python@
    p1 << r.p1;
    p2 << r.p2;
    @@
    
    if (p1[0].column == p2[0].column):
      cocci.print_main("branch",p1)
      cocci.print_secs("after",p2)
    // </smpl>
    
    Signed-off-by: Julia Lawall <julia@diku.dk>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 7fa3cbd742c5..cc232c016ef9 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2689,7 +2689,7 @@ int pcie_get_readrq(struct pci_dev *dev)
 
 	ret = pci_read_config_word(dev, cap + PCI_EXP_DEVCTL, &ctl);
 	if (!ret)
-	ret = 128 << ((ctl & PCI_EXP_DEVCTL_READRQ) >> 12);
+		ret = 128 << ((ctl & PCI_EXP_DEVCTL_READRQ) >> 12);
 
 	return ret;
 }

commit 1cfd2bda8c486ae0e7a8005354758ebb68172bca
Merge: b57bdda58cda 763e9db9994e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Aug 6 11:44:36 2010 -0700

    Merge branch 'linux-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jbarnes/pci-2.6
    
    * 'linux-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jbarnes/pci-2.6: (30 commits)
      PCI: update for owner removal from struct device_attribute
      PCI: Fix warnings when CONFIG_DMI unset
      PCI: Do not run NVidia quirks related to MSI with MSI disabled
      x86/PCI: use for_each_pci_dev()
      PCI: use for_each_pci_dev()
      PCI: MSI: Restore read_msi_msg_desc(); add get_cached_msi_msg_desc()
      PCI: export SMBIOS provided firmware instance and label to sysfs
      PCI: Allow read/write access to sysfs I/O port resources
      x86/PCI: use host bridge _CRS info on ASRock ALiveSATA2-GLAN
      PCI: remove unused HAVE_ARCH_PCI_SET_DMA_MAX_SEGMENT_{SIZE|BOUNDARY}
      PCI: disable mmio during bar sizing
      PCI: MSI: Remove unsafe and unnecessary hardware access
      PCI: Default PCIe ASPM control to on and require !EMBEDDED to disable
      PCI: kernel oops on access to pci proc file while hot-removal
      PCI: pci-sysfs: remove casts from void*
      ACPI: Disable ASPM if the platform won't provide _OSC control for PCIe
      PCI hotplug: make sure child bridges are enabled at hotplug time
      PCI hotplug: shpchp: Removed check for hotplug of display devices
      PCI hotplug: pciehp: Fixed return value sign for pciehp_unconfigure_device
      PCI: Don't enable aspm before drivers have had a chance to veto it
      ...

commit bfb51cd01661136bae1dd00c32d504cff6a9f924
Author: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
Date:   Mon Jul 12 15:59:11 2010 +0900

    PCI: remove unused HAVE_ARCH_PCI_SET_DMA_MAX_SEGMENT_{SIZE|BOUNDARY}
    
    In 2.6.34, we transformed the PCI DMA API into the generic device
    mode. The PCI DMA API is just the wrapper of the DMA API.
    
    So we don't need HAVE_ARCH_PCI_SET_DMA_MAX_SEGMENT_SIZE or
    HAVE_ARCH_PCI_SET_DMA_SEGMENT_BOUNDARY (which enable architectures to
    have the own implementations). Both haven't been used anyway.
    
    Signed-off-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 740fb4ea9669..9afad0faa9b6 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2294,21 +2294,17 @@ void pci_msi_off(struct pci_dev *dev)
 }
 EXPORT_SYMBOL_GPL(pci_msi_off);
 
-#ifndef HAVE_ARCH_PCI_SET_DMA_MAX_SEGMENT_SIZE
 int pci_set_dma_max_seg_size(struct pci_dev *dev, unsigned int size)
 {
 	return dma_set_max_seg_size(&dev->dev, size);
 }
 EXPORT_SYMBOL(pci_set_dma_max_seg_size);
-#endif
 
-#ifndef HAVE_ARCH_PCI_SET_DMA_SEGMENT_BOUNDARY
 int pci_set_dma_seg_boundary(struct pci_dev *dev, unsigned long mask)
 {
 	return dma_set_seg_boundary(&dev->dev, mask);
 }
 EXPORT_SYMBOL(pci_set_dma_seg_boundary);
-#endif
 
 static int pcie_flr(struct pci_dev *dev, int probe)
 {

commit c125e96f044427f38d106fab7bc5e4a5e6a18262
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Jul 5 22:43:53 2010 +0200

    PM: Make it possible to avoid races between wakeup and system sleep
    
    One of the arguments during the suspend blockers discussion was that
    the mainline kernel didn't contain any mechanisms making it possible
    to avoid races between wakeup and system suspend.
    
    Generally, there are two problems in that area.  First, if a wakeup
    event occurs exactly when /sys/power/state is being written to, it
    may be delivered to user space right before the freezer kicks in, so
    the user space consumer of the event may not be able to process it
    before the system is suspended.  Second, if a wakeup event occurs
    after user space has been frozen, it is not generally guaranteed that
    the ongoing transition of the system into a sleep state will be
    aborted.
    
    To address these issues introduce a new global sysfs attribute,
    /sys/power/wakeup_count, associated with a running counter of wakeup
    events and three helper functions, pm_stay_awake(), pm_relax(), and
    pm_wakeup_event(), that may be used by kernel subsystems to control
    the behavior of this attribute and to request the PM core to abort
    system transitions into a sleep state already in progress.
    
    The /sys/power/wakeup_count file may be read from or written to by
    user space.  Reads will always succeed (unless interrupted by a
    signal) and return the current value of the wakeup events counter.
    Writes, however, will only succeed if the written number is equal to
    the current value of the wakeup events counter.  If a write is
    successful, it will cause the kernel to save the current value of the
    wakeup events counter and to abort the subsequent system transition
    into a sleep state if any wakeup events are reported after the write
    has returned.
    
    [The assumption is that before writing to /sys/power/state user space
    will first read from /sys/power/wakeup_count.  Next, user space
    consumers of wakeup events will have a chance to acknowledge or
    veto the upcoming system transition to a sleep state.  Finally, if
    the transition is allowed to proceed, /sys/power/wakeup_count will
    be written to and if that succeeds, /sys/power/state will be written
    to as well.  Still, if any wakeup events are reported to the PM core
    by kernel subsystems after that point, the transition will be
    aborted.]
    
    Additionally, put a wakeup events counter into struct dev_pm_info and
    make these per-device wakeup event counters available via sysfs,
    so that it's possible to check the activity of various wakeup event
    sources within the kernel.
    
    To illustrate how subsystems can use pm_wakeup_event(), make the
    low-level PCI runtime PM wakeup-handling code use it.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Acked-by: markgross <markgross@thegnar.org>
    Reviewed-by: Alan Stern <stern@rowland.harvard.edu>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 740fb4ea9669..130ed1daf0f8 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1275,6 +1275,22 @@ bool pci_check_pme_status(struct pci_dev *dev)
 	return ret;
 }
 
+/*
+ * Time to wait before the system can be put into a sleep state after reporting
+ * a wakeup event signaled by a PCI device.
+ */
+#define PCI_WAKEUP_COOLDOWN	100
+
+/**
+ * pci_wakeup_event - Report a wakeup event related to a given PCI device.
+ * @dev: Device to report the wakeup event for.
+ */
+void pci_wakeup_event(struct pci_dev *dev)
+{
+	if (device_may_wakeup(&dev->dev))
+		pm_wakeup_event(&dev->dev, PCI_WAKEUP_COOLDOWN);
+}
+
 /**
  * pci_pme_wakeup - Wake up a PCI device if its PME Status bit is set.
  * @dev: Device to handle.
@@ -1285,8 +1301,10 @@ bool pci_check_pme_status(struct pci_dev *dev)
  */
 static int pci_pme_wakeup(struct pci_dev *dev, void *ign)
 {
-	if (pci_check_pme_status(dev))
+	if (pci_check_pme_status(dev)) {
 		pm_request_resume(&dev->dev);
+		pci_wakeup_event(dev);
+	}
 	return 0;
 }
 

commit b03214d559471359e2a85ae256686381d0672f29
Author: Michael S. Tsirkin <mst@redhat.com>
Date:   Wed Jun 23 22:49:06 2010 -0600

    virtio-pci: disable msi at startup
    
    virtio-pci resets the device at startup by writing to the status
    register, but this does not clear the pci config space,
    specifically msi enable status which affects register
    layout.
    
    This breaks things like kdump when they try to use e.g. virtio-blk.
    
    Fix by forcing msi off at startup. Since pci.c already has
    a routine to do this, we export and use it instead of duplicating code.
    
    Signed-off-by: Michael S. Tsirkin <mst@redhat.com>
    Tested-by: Vivek Goyal <vgoyal@redhat.com>
    Acked-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Cc: linux-pci@vger.kernel.org
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Cc: stable@kernel.org

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 60f30e7f1c8c..740fb4ea9669 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2292,6 +2292,7 @@ void pci_msi_off(struct pci_dev *dev)
 		pci_write_config_word(dev, pos + PCI_MSIX_FLAGS, control);
 	}
 }
+EXPORT_SYMBOL_GPL(pci_msi_off);
 
 #ifndef HAVE_ARCH_PCI_SET_DMA_MAX_SEGMENT_SIZE
 int pci_set_dma_max_seg_size(struct pci_dev *dev, unsigned int size)

commit 6109e2ce2600e2db26cd0424bb9c6ed019723288
Merge: 0961d6581c87 ac81860ea073
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri May 21 18:58:52 2010 -0700

    Merge branch 'linux-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jbarnes/pci-2.6
    
    * 'linux-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jbarnes/pci-2.6: (36 commits)
      PCI: hotplug: pciehp: Removed check for hotplug of display devices
      PCI: read memory ranges out of Broadcom CNB20LE host bridge
      PCI: Allow manual resource allocation for PCI hotplug bridges
      x86/PCI: make ACPI MCFG reserved error messages ACPI specific
      PCI hotplug: Use kmemdup
      PM/PCI: Update PCI power management documentation
      PCI: output FW warning in pci_read/write_vpd
      PCI: fix typos pci_device_dis/enable to pci_dis/enable_device in comments
      PCI quirks: disable msi on AMD rs4xx internal gfx bridges
      PCI: Disable MSI for MCP55 on P5N32-E SLI
      x86/PCI: irq and pci_ids patch for additional Intel Cougar Point DeviceIDs
      PCI: aerdrv: trivial cleanup for aerdrv_core.c
      PCI: aerdrv: trivial cleanup for aerdrv.c
      PCI: aerdrv: introduce default_downstream_reset_link
      PCI: aerdrv: rework find_aer_service
      PCI: aerdrv: remove is_downstream
      PCI: aerdrv: remove magical ROOT_ERR_STATUS_MASKS
      PCI: aerdrv: redefine PCI_ERR_ROOT_*_SRC
      PCI: aerdrv: rework do_recovery
      PCI: aerdrv: rework get_e_source()
      ...

commit f39d01be4c59a61a08d0cb53f615e7016b85d339
Merge: 54291263519a 7db82437cfca
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu May 20 09:20:59 2010 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial: (44 commits)
      vlynq: make whole Kconfig-menu dependant on architecture
      add descriptive comment for TIF_MEMDIE task flag declaration.
      EEPROM: max6875: Header file cleanup
      EEPROM: 93cx6: Header file cleanup
      EEPROM: Header file cleanup
      agp: use NULL instead of 0 when pointer is needed
      rtc-v3020: make bitfield unsigned
      PCI: make bitfield unsigned
      jbd2: use NULL instead of 0 when pointer is needed
      cciss: fix shadows sparse warning
      doc: inode uses a mutex instead of a semaphore.
      uml: i386: Avoid redefinition of NR_syscalls
      fix "seperate" typos in comments
      cocbalt_lcdfb: correct sections
      doc: Change urls for sparse
      Powerpc: wii: Fix typo in comment
      i2o: cleanup some exit paths
      Documentation/: it's -> its where appropriate
      UML: Fix compiler warning due to missing task_struct declaration
      UML: add kernel.h include to signal.c
      ...

commit ee6583f6e8f8dad4a53985dbabcd7c242d66a6b6
Author: Roman Fietze <roman.fietze@telemotive.de>
Date:   Tue May 18 14:45:47 2010 +0200

    PCI: fix typos pci_device_dis/enable to pci_dis/enable_device in comments
    
    This fixes all occurrences of pci_enable_device and pci_disable_device
    in all comments. There are no code changes involved.
    
    Signed-off-by: Roman Fietze <roman.fietze@telemotive.de>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 60fcb6f02c91..264c3f6b8476 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1193,7 +1193,7 @@ void pci_disable_enabled_device(struct pci_dev *dev)
  * anymore.  This only involves disabling PCI bus-mastering, if active.
  *
  * Note we don't actually disable the device until all callers of
- * pci_device_enable() have called pci_device_disable().
+ * pci_enable_device() have called pci_disable_device().
  */
 void
 pci_disable_device(struct pci_dev *dev)

commit 52b265a12768b9a72679bec825eb82c784116464
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Mar 8 16:48:49 2010 -0500

    PCI: clearing wakeup flags not needed
    
    This patch (as1353) removes a couple of unnecessary assignments from
    the PCI core.  The should_wakeup flag is naturally initialized to 0;
    there's no need to clear it.
    
    Acked-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 37499127c801..60fcb6f02c91 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1631,7 +1631,6 @@ void pci_pm_init(struct pci_dev *dev)
 		 * let the user space enable it to wake up the system as needed.
 		 */
 		device_set_wakeup_capable(&dev->dev, true);
-		device_set_wakeup_enable(&dev->dev, false);
 		/* Disable the PME# generation functionality */
 		pci_pme_active(dev, false);
 	} else {
@@ -1655,7 +1654,6 @@ void platform_pci_wakeup_init(struct pci_dev *dev)
 		return;
 
 	device_set_wakeup_capable(&dev->dev, true);
-	device_set_wakeup_enable(&dev->dev, false);
 	platform_pci_sleep_wake(dev, false);
 }
 

commit 6c9468e9eb1252eaefd94ce7f06e1be9b0b641b1
Merge: 4cb3ca7cd7e2 c81eddb0e372
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Fri Apr 23 02:08:44 2010 +0200

    Merge branch 'master' into for-next

commit cc2893b6af5265baa1d68b17b136cffca9e40cfa
Author: Matthew Garrett <mjg@redhat.com>
Date:   Thu Apr 22 09:30:51 2010 -0400

    PCI: Ensure we re-enable devices on resume
    
    If the firmware puts a device back into D0 state at resume time, we'll
    update its state in resume_noirq and thus skip the platform resume code.
    Calling that code twice should be safe and we ought to avoid getting to
    that point anyway, so remove the check and also allow the platform pci
    code to be called for D0.
    
    Fixes USB not being powered after resume on recent Lenovo machines.
    
    Acked-by: Alex Chiang <achiang@canonical.com>
    Acked-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Matthew Garrett <mjg@redhat.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 5ea587e59e48..37499127c801 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -679,7 +679,7 @@ static void __pci_start_power_transition(struct pci_dev *dev, pci_power_t state)
  */
 int __pci_complete_power_transition(struct pci_dev *dev, pci_power_t state)
 {
-	return state > PCI_D0 ?
+	return state >= PCI_D0 ?
 			pci_platform_power_transition(dev, state) : -EINVAL;
 }
 EXPORT_SYMBOL_GPL(__pci_complete_power_transition);
@@ -716,10 +716,6 @@ int pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 		 */
 		return 0;
 
-	/* Check if we're already there */
-	if (dev->current_state == state)
-		return 0;
-
 	__pci_start_power_transition(dev, state);
 
 	/* This device is quirked not to be put into D3, so

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 1531f3a49879..5ea587e59e48 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -12,6 +12,7 @@
 #include <linux/init.h>
 #include <linux/pci.h>
 #include <linux/pm.h>
+#include <linux/slab.h>
 #include <linux/module.h>
 #include <linux/spinlock.h>
 #include <linux/string.h>

commit 7c9e2b1c4784c6e574f69dbd904b2822f2e04d6e
Author: Dean Nelson <dnelson@redhat.com>
Date:   Tue Mar 9 22:26:55 2010 -0500

    PCI: cleanup error return for pcix get and set mmrbc functions
    
    pcix_get_mmrbc() returns the maximum memory read byte count (mmrbc), if
    successful, or an appropriate error value, if not.
    
    Distinguishing errors from correct values and understanding the meaning of an
    error can be somewhat confusing in that:
    
            correct values: 512, 1024, 2048, 4096
            errors: -EINVAL                         -22
                    PCIBIOS_FUNC_NOT_SUPPORTED      0x81
                    PCIBIOS_BAD_VENDOR_ID           0x83
                    PCIBIOS_DEVICE_NOT_FOUND        0x86
                    PCIBIOS_BAD_REGISTER_NUMBER     0x87
                    PCIBIOS_SET_FAILED              0x88
                    PCIBIOS_BUFFER_TOO_SMALL        0x89
    
    The PCIBIOS_ errors are returned from the PCI functions generated by the
    PCI_OP_READ() and PCI_OP_WRITE() macros.
    
    In a similar manner, pcix_set_mmrbc() also returns the PCIBIOS_ error values
    returned from pci_read_config_[word|dword]() and pci_write_config_word().
    
    Following pcix_get_max_mmrbc()'s example, the following patch simply returns
    -EINVAL for all PCIBIOS_ errors encountered by pcix_get_mmrbc(), and -EINVAL
    or -EIO for those encountered by pcix_set_mmrbc().
    
    This simplification was chosen in light of the fact that none of the current
    callers of these functions are interested in the specific type of error
    encountered. In the future, should this change, one could simply create a
    function that maps each PCIBIOS_ error to a corresponding unique errno value,
    which could be called by pcix_get_max_mmrbc(), pcix_get_mmrbc(), and
    pcix_set_mmrbc().
    
    Additionally, this patch eliminates some unnecessary variables.
    
    Cc: stable@kernel.org
    Signed-off-by: Dean Nelson <dnelson@redhat.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 5c80b59c5931..1531f3a49879 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2576,15 +2576,14 @@ EXPORT_SYMBOL_GPL(pci_reset_function);
  */
 int pcix_get_max_mmrbc(struct pci_dev *dev)
 {
-	int err, cap;
+	int cap;
 	u32 stat;
 
 	cap = pci_find_capability(dev, PCI_CAP_ID_PCIX);
 	if (!cap)
 		return -EINVAL;
 
-	err = pci_read_config_dword(dev, cap + PCI_X_STATUS, &stat);
-	if (err)
+	if (pci_read_config_dword(dev, cap + PCI_X_STATUS, &stat))
 		return -EINVAL;
 
 	return 512 << ((stat & PCI_X_STATUS_MAX_READ) >> 21);
@@ -2600,18 +2599,17 @@ EXPORT_SYMBOL(pcix_get_max_mmrbc);
  */
 int pcix_get_mmrbc(struct pci_dev *dev)
 {
-	int ret, cap;
+	int cap;
 	u16 cmd;
 
 	cap = pci_find_capability(dev, PCI_CAP_ID_PCIX);
 	if (!cap)
 		return -EINVAL;
 
-	ret = pci_read_config_word(dev, cap + PCI_X_CMD, &cmd);
-	if (!ret)
-		ret = 512 << ((cmd & PCI_X_CMD_MAX_READ) >> 2);
+	if (pci_read_config_word(dev, cap + PCI_X_CMD, &cmd))
+		return -EINVAL;
 
-	return ret;
+	return 512 << ((cmd & PCI_X_CMD_MAX_READ) >> 2);
 }
 EXPORT_SYMBOL(pcix_get_mmrbc);
 
@@ -2626,29 +2624,27 @@ EXPORT_SYMBOL(pcix_get_mmrbc);
  */
 int pcix_set_mmrbc(struct pci_dev *dev, int mmrbc)
 {
-	int cap, err = -EINVAL;
+	int cap;
 	u32 stat, v, o;
 	u16 cmd;
 
 	if (mmrbc < 512 || mmrbc > 4096 || !is_power_of_2(mmrbc))
-		goto out;
+		return -EINVAL;
 
 	v = ffs(mmrbc) - 10;
 
 	cap = pci_find_capability(dev, PCI_CAP_ID_PCIX);
 	if (!cap)
-		goto out;
+		return -EINVAL;
 
-	err = pci_read_config_dword(dev, cap + PCI_X_STATUS, &stat);
-	if (err)
-		goto out;
+	if (pci_read_config_dword(dev, cap + PCI_X_STATUS, &stat))
+		return -EINVAL;
 
 	if (v > (stat & PCI_X_STATUS_MAX_READ) >> 21)
 		return -E2BIG;
 
-	err = pci_read_config_word(dev, cap + PCI_X_CMD, &cmd);
-	if (err)
-		goto out;
+	if (pci_read_config_word(dev, cap + PCI_X_CMD, &cmd))
+		return -EINVAL;
 
 	o = (cmd & PCI_X_CMD_MAX_READ) >> 2;
 	if (o != v) {
@@ -2658,10 +2654,10 @@ int pcix_set_mmrbc(struct pci_dev *dev, int mmrbc)
 
 		cmd &= ~PCI_X_CMD_MAX_READ;
 		cmd |= v << 2;
-		err = pci_write_config_word(dev, cap + PCI_X_CMD, cmd);
+		if (pci_write_config_word(dev, cap + PCI_X_CMD, cmd))
+			return -EIO;
 	}
-out:
-	return err;
+	return 0;
 }
 EXPORT_SYMBOL(pcix_set_mmrbc);
 

commit bdc2bda7c4dd253026cc1fce45fc939304749029
Author: Dean Nelson <dnelson@redhat.com>
Date:   Tue Mar 9 22:26:48 2010 -0500

    PCI: fix access of PCI_X_CMD by pcix get and set mmrbc functions
    
    An e1000 driver on a system with a PCI-X bus was always being returned
    a value of 135 from both pcix_get_mmrbc() and pcix_set_mmrbc(). This
    value reflects an error return of PCIBIOS_BAD_REGISTER_NUMBER from
    pci_bus_read_config_dword(,, cap + PCI_X_CMD,).
    
    This is because for a dword, the following portion of the PCI_OP_READ()
    macro:
    
            if (PCI_##size##_BAD) return PCIBIOS_BAD_REGISTER_NUMBER;
    
    expands to:
    
            if (pos & 3) return PCIBIOS_BAD_REGISTER_NUMBER;
    
    And is always true for 'cap + PCI_X_CMD', which is 0xe4 + 2 = 0xe6. ('cap' is
    the result of calling pci_find_capability(, PCI_CAP_ID_PCIX).)
    
    The same problem exists for pci_bus_write_config_dword(,, cap + PCI_X_CMD,).
    In both cases, instead of calling _dword(), _word() should be called.
    
    Cc: stable@kernel.org
    Signed-off-by: Dean Nelson <dnelson@redhat.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 9af986085d09..5c80b59c5931 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2601,13 +2601,13 @@ EXPORT_SYMBOL(pcix_get_max_mmrbc);
 int pcix_get_mmrbc(struct pci_dev *dev)
 {
 	int ret, cap;
-	u32 cmd;
+	u16 cmd;
 
 	cap = pci_find_capability(dev, PCI_CAP_ID_PCIX);
 	if (!cap)
 		return -EINVAL;
 
-	ret = pci_read_config_dword(dev, cap + PCI_X_CMD, &cmd);
+	ret = pci_read_config_word(dev, cap + PCI_X_CMD, &cmd);
 	if (!ret)
 		ret = 512 << ((cmd & PCI_X_CMD_MAX_READ) >> 2);
 
@@ -2627,7 +2627,8 @@ EXPORT_SYMBOL(pcix_get_mmrbc);
 int pcix_set_mmrbc(struct pci_dev *dev, int mmrbc)
 {
 	int cap, err = -EINVAL;
-	u32 stat, cmd, v, o;
+	u32 stat, v, o;
+	u16 cmd;
 
 	if (mmrbc < 512 || mmrbc > 4096 || !is_power_of_2(mmrbc))
 		goto out;
@@ -2645,7 +2646,7 @@ int pcix_set_mmrbc(struct pci_dev *dev, int mmrbc)
 	if (v > (stat & PCI_X_STATUS_MAX_READ) >> 21)
 		return -E2BIG;
 
-	err = pci_read_config_dword(dev, cap + PCI_X_CMD, &cmd);
+	err = pci_read_config_word(dev, cap + PCI_X_CMD, &cmd);
 	if (err)
 		goto out;
 
@@ -2657,7 +2658,7 @@ int pcix_set_mmrbc(struct pci_dev *dev, int mmrbc)
 
 		cmd &= ~PCI_X_CMD_MAX_READ;
 		cmd |= v << 2;
-		err = pci_write_config_dword(dev, cap + PCI_X_CMD, cmd);
+		err = pci_write_config_word(dev, cap + PCI_X_CMD, cmd);
 	}
 out:
 	return err;

commit ded1d8f29b4d315a2093cafc3ee17ac870a87972
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Thu Mar 11 14:08:33 2010 -0800

    PCI: kill off pci_register_set_vga_state() symbol export.
    
    When pci_register_set_vga_state() was made __init, the EXPORT_SYMBOL() was
    retained, which now leaves us with a section mismatch.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>
    Cc: Mike Travis <travis@sgi.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index ed9eb68fd940..9af986085d09 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -3023,7 +3023,6 @@ EXPORT_SYMBOL(pcim_pin_device);
 EXPORT_SYMBOL(pci_disable_device);
 EXPORT_SYMBOL(pci_find_capability);
 EXPORT_SYMBOL(pci_bus_find_capability);
-EXPORT_SYMBOL(pci_register_set_vga_state);
 EXPORT_SYMBOL(pci_release_regions);
 EXPORT_SYMBOL(pci_request_regions);
 EXPORT_SYMBOL(pci_request_regions_exclusive);

commit 25daeb550b69e89aff59bc6a84218a12b5203531
Author: Dean Nelson <dnelson@redhat.com>
Date:   Tue Mar 9 22:26:40 2010 -0500

    PCI: fix return value from pcix_get_max_mmrbc()
    
    For the PCI_X_STATUS register, pcix_get_max_mmrbc() is returning an incorrect
    value, which is based on:
    
            (stat & PCI_X_STATUS_MAX_READ) >> 12
    
    Valid return values are 512, 1024, 2048, 4096, which correspond to a 'stat'
    (masked and right shifted by 21) of 0, 1, 2, 3, respectively.
    
    A right shift by 11 would generate the correct return value when 'stat' (masked
    and right shifted by 21) has a value of 1 or 2. But for a value of 0 or 3 it's
    not possible to generate the correct return value by only right shifting.
    
    Fix is based on pcix_get_mmrbc()'s similar dealings with the PCI_X_CMD register.
    
    Cc: stable@kernel.org
    Signed-off-by: Dean Nelson <dnelson@redhat.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index cb1dd5f4988c..ed9eb68fd940 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2587,7 +2587,7 @@ int pcix_get_max_mmrbc(struct pci_dev *dev)
 	if (err)
 		return -EINVAL;
 
-	return (stat & PCI_X_STATUS_MAX_READ) >> 12;
+	return 512 << ((stat & PCI_X_STATUS_MAX_READ) >> 21);
 }
 EXPORT_SYMBOL(pcix_get_max_mmrbc);
 

commit 88393161210493e317ae391696ee8ef463cb3c23
Author: Thomas Weber <swirl@gmx.li>
Date:   Tue Mar 16 11:47:56 2010 +0100

    Fix typos in comments
    
    [Ss]ytem => [Ss]ystem
    udpate => update
    paramters => parameters
    orginal => original
    
    Signed-off-by: Thomas Weber <swirl@gmx.li>
    Acked-by: Randy Dunlap <rdunlap@xenotime.net>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index cb1dd5f4988c..ddd55dc927f7 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1506,7 +1506,7 @@ int pci_prepare_to_sleep(struct pci_dev *dev)
  * pci_back_from_sleep - turn PCI device on during system-wide transition into working state
  * @dev: Device to handle.
  *
- * Disable device's sytem wake-up capability and put it into D0.
+ * Disable device's system wake-up capability and put it into D0.
  */
 int pci_back_from_sleep(struct pci_dev *dev)
 {

commit 5f3cd1e0bb452c31a306a3e764514ea2eaf7d2e0
Author: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
Date:   Wed Mar 10 15:23:41 2010 -0800

    dma-mapping: pci: move pci_set_dma_mask and pci_set_consistent_dma_mask to pci-dma-compat.h
    
    We can use pci-dma-compat.h to implement pci_set_dma_mask and
    pci_set_consistent_dma_mask as we do with the other PCI DMA API.
    
    We can remove HAVE_ARCH_PCI_SET_DMA_MASK too.
    
    Signed-off-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Cc: Jesse Barnes <jbarnes@virtuousgeek.org>
    Cc: Greg KH <greg@kroah.com>
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 929fd3932032..cb1dd5f4988c 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2298,32 +2298,6 @@ void pci_msi_off(struct pci_dev *dev)
 	}
 }
 
-#ifndef HAVE_ARCH_PCI_SET_DMA_MASK
-/*
- * These can be overridden by arch-specific implementations
- */
-int
-pci_set_dma_mask(struct pci_dev *dev, u64 mask)
-{
-	int ret = dma_set_mask(&dev->dev, mask);
-	if (ret)
-		return ret;
-	dev_dbg(&dev->dev, "using %dbit DMA mask\n", fls64(mask));
-	return 0;
-}
-
-int
-pci_set_consistent_dma_mask(struct pci_dev *dev, u64 mask)
-{
-	int ret = dma_set_coherent_mask(&dev->dev, mask);
-	if (ret)
-		return ret;
-
-	dev_dbg(&dev->dev, "using %dbit consistent DMA mask\n", fls64(mask));
-	return 0;
-}
-#endif
-
 #ifndef HAVE_ARCH_PCI_SET_DMA_MAX_SEGMENT_SIZE
 int pci_set_dma_max_seg_size(struct pci_dev *dev, unsigned int size)
 {
@@ -3065,8 +3039,6 @@ EXPORT_SYMBOL(pci_set_mwi);
 EXPORT_SYMBOL(pci_try_set_mwi);
 EXPORT_SYMBOL(pci_clear_mwi);
 EXPORT_SYMBOL_GPL(pci_intx);
-EXPORT_SYMBOL(pci_set_dma_mask);
-EXPORT_SYMBOL(pci_set_consistent_dma_mask);
 EXPORT_SYMBOL(pci_assign_resource);
 EXPORT_SYMBOL(pci_find_parent_resource);
 EXPORT_SYMBOL(pci_select_bars);

commit 6a1961f49ee8d7339ea2454443dfc0460e0b2748
Author: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
Date:   Wed Mar 10 15:23:39 2010 -0800

    dma-mapping: dma-mapping.h: add dma_set_coherent_mask
    
    dma_set_coherent_mask corresponds to pci_set_consistent_dma_mask.  This is
    necessary to move to the generic device model DMA API from the PCI bus
    specific API in the long term.
    
    dma_set_coherent_mask works in the exact same way that
    pci_set_consistent_dma_mask does.  So this patch also changes
    pci_set_consistent_dma_mask to call dma_set_coherent_mask.
    
    Signed-off-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Cc: James Bottomley <James.Bottomley@suse.de>
    Cc: David S. Miller <davem@davemloft.net>
    Cc: Jesse Barnes <jbarnes@virtuousgeek.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Greg KH <greg@kroah.com>
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index b2d23d1b0d41..929fd3932032 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2315,12 +2315,11 @@ pci_set_dma_mask(struct pci_dev *dev, u64 mask)
 int
 pci_set_consistent_dma_mask(struct pci_dev *dev, u64 mask)
 {
-	if (!pci_dma_supported(dev, mask))
-		return -EIO;
+	int ret = dma_set_coherent_mask(&dev->dev, mask);
+	if (ret)
+		return ret;
 
-	dev->dev.coherent_dma_mask = mask;
 	dev_dbg(&dev->dev, "using %dbit consistent DMA mask\n", fls64(mask));
-
 	return 0;
 }
 #endif

commit e3c4bccabaf3e5c13f4b307c7737cbe8d0cecd02
Author: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
Date:   Wed Mar 10 15:23:38 2010 -0800

    dma-mapping: pci: convert pci_set_dma_mask to call dma_set_mask
    
    This changes pci_set_dma_mask to call the generic DMA API, dma_set_mask.
    
    pci_set_dma_mask (in drivers/pci/pci.c) does the same things that
    dma_set_mask does on all the architectures that use pci_set_dma_mask;
    calls dma_supprted and sets dev->dma_mask.  So we safely change
    pci_set_dma_mask to simply call dma_set_mask.
    
    Signed-off-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Cc: James Bottomley <James.Bottomley@suse.de>
    Cc: David S. Miller <davem@davemloft.net>
    Cc: Jesse Barnes <jbarnes@virtuousgeek.org>
    Acked-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Greg KH <greg@kroah.com>
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index fdcf01af6762..b2d23d1b0d41 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2305,15 +2305,13 @@ void pci_msi_off(struct pci_dev *dev)
 int
 pci_set_dma_mask(struct pci_dev *dev, u64 mask)
 {
-	if (!pci_dma_supported(dev, mask))
-		return -EIO;
-
-	dev->dma_mask = mask;
+	int ret = dma_set_mask(&dev->dev, mask);
+	if (ret)
+		return ret;
 	dev_dbg(&dev->dev, "using %dbit DMA mask\n", fls64(mask));
-
 	return 0;
 }
-    
+
 int
 pci_set_consistent_dma_mask(struct pci_dev *dev, u64 mask)
 {

commit 522dba7134d6b2e5821d3457f7941ec34f668e6d
Merge: 51d0f6d1f503 bb910a7040e9
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Mar 8 16:10:29 2010 -0800

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jbarnes/pci-2.6
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jbarnes/pci-2.6:
      PCI/PM Runtime: Make runtime PM of PCI devices inactive by default

commit 8e9394ce2412254ec69fd2a4f3e44a66eade2297
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed Feb 17 10:57:05 2010 -0800

    Driver core: create lock/unlock functions for struct device
    
    In the future, we are going to be changing the lock type for struct
    device (once we get the lockdep infrastructure properly worked out)  To
    make that changeover easier, and to possibly burry the lock in a
    different part of struct device, let's create some functions to lock and
    unlock a device so that no out-of-core code needs to be changed in the
    future.
    
    This patch creates the device_lock/unlock/trylock() functions, and
    converts all in-tree users to them.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Jean Delvare <khali@linux-fr.org>
    Cc: Dave Young <hidave.darkstar@gmail.com>
    Cc: Ming Lei <tom.leiming@gmail.com>
    Cc: Jiri Kosina <jkosina@suse.cz>
    Cc: Phil Carmody <ext-phil.2.carmody@nokia.com>
    Cc: Arjan van de Ven <arjan@linux.intel.com>
    Cc: Cornelia Huck <cornelia.huck@de.ibm.com>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: Len Brown <len.brown@intel.com>
    Cc: Magnus Damm <damm@igel.co.jp>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Randy Dunlap <randy.dunlap@oracle.com>
    Cc: Stefan Richter <stefanr@s5r6.in-berlin.de>
    Cc: David Brownell <dbrownell@users.sourceforge.net>
    Cc: Vegard Nossum <vegard.nossum@gmail.com>
    Cc: Jesse Barnes <jbarnes@virtuousgeek.org>
    Cc: Alex Chiang <achiang@hp.com>
    Cc: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Andrew Patterson <andrew.patterson@hp.com>
    Cc: Yu Zhao <yu.zhao@intel.com>
    Cc: Dominik Brodowski <linux@dominikbrodowski.net>
    Cc: Samuel Ortiz <sameo@linux.intel.com>
    Cc: Wolfram Sang <w.sang@pengutronix.de>
    Cc: CHENG Renquan <rqcheng@smu.edu.sg>
    Cc: Oliver Neukum <oliver@neukum.org>
    Cc: Frans Pop <elendil@planet.nl>
    Cc: David Vrabel <david.vrabel@csr.com>
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Cc: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 77b493b3d97b..897fa5ccdb78 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2486,7 +2486,7 @@ static int pci_dev_reset(struct pci_dev *dev, int probe)
 	if (!probe) {
 		pci_block_user_cfg_access(dev);
 		/* block PM suspend, driver probe, etc. */
-		down(&dev->dev.sem);
+		device_lock(&dev->dev);
 	}
 
 	rc = pci_dev_specific_reset(dev, probe);
@@ -2508,7 +2508,7 @@ static int pci_dev_reset(struct pci_dev *dev, int probe)
 	rc = pci_parent_bus_reset(dev, probe);
 done:
 	if (!probe) {
-		up(&dev->dev.sem);
+		device_unlock(&dev->dev);
 		pci_unblock_user_cfg_access(dev);
 	}
 

commit 322aafa6645a48c3b7837ca7385f126ab78127fd
Merge: dd04265b028c c7bbf52aa4fa
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Mar 7 15:59:39 2010 -0800

    Merge branch 'x86-mrst-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'x86-mrst-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip: (30 commits)
      x86, mrst: Fix whitespace breakage in apb_timer.c
      x86, mrst: Fix APB timer per cpu clockevent
      x86, mrst: Remove X86_MRST dependency on PCI_IOAPIC
      x86, olpc: Use pci subarch init for OLPC
      x86, pci: Add arch_init to x86_init abstraction
      x86, mrst: Add Kconfig dependencies for Moorestown
      x86, pci: Exclude Moorestown PCI code if CONFIG_X86_MRST=n
      x86, numaq: Make CONFIG_X86_NUMAQ depend on CONFIG_PCI
      x86, pci: Add sanity check for PCI fixed bar probing
      x86, legacy_irq: Remove duplicate vector assigment
      x86, legacy_irq: Remove left over nr_legacy_irqs
      x86, mrst: Platform clock setup code
      x86, apbt: Moorestown APB system timer driver
      x86, mrst: Add vrtc platform data setup code
      x86, mrst: Add platform timer info parsing code
      x86, mrst: Fill in PCI functions in x86_init layer
      x86, mrst: Add dummy legacy pic to platform setup
      x86/PCI: Moorestown PCI support
      x86, ioapic: Add dummy ioapic functions
      x86, ioapic: Early enable ioapic for timer irq
      ...
    
    Fixed up semantic conflict of new clocksources due to commit
    17622339af25 ("clocksource: add argument to resume callback").

commit bb910a7040e90a0ca3d3e8245d6d5c128a5d1287
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sat Feb 27 21:37:37 2010 +0100

    PCI/PM Runtime: Make runtime PM of PCI devices inactive by default
    
    Make the run-time power management of PCI devices be inactive by
    default by calling pm_runtime_forbid() for each PCI device during its
    initialization.  This setting may be overriden by the user space with
    the help of the /sys/devices/.../power/control interface.
    
    That's necessary to avoid breakage on systems where ACPI-based
    wake-up is known to fail for some devices.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 5b548aee9cbc..6e100ae7f5b5 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1540,8 +1540,10 @@ void pci_pm_init(struct pci_dev *dev)
 	int pm;
 	u16 pmc;
 
+	pm_runtime_forbid(&dev->dev);
 	device_enable_async_suspend(&dev->dev);
 	dev->wakeup_prepared = false;
+
 	dev->pm_cap = 0;
 
 	/* find PCI PM capability in list */

commit c7e15899d07c9813c1aa96b21699d2d9c8314c4b
Merge: f6a0b5cd34d6 78c06176466c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Feb 28 10:59:18 2010 -0800

    Merge branch 'x86-pci-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'x86-pci-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      x86: Enable NMI on all cpus on UV
      vgaarb: Add user selectability of the number of GPUS in a system
      vgaarb: Fix VGA arbiter to accept PCI domains other than 0
      x86, uv: Update UV arch to target Legacy VGA I/O correctly.
      pci: Update pci_set_vga_state() to call arch functions

commit a1e4d72cd3024999bfb6703092ea271438805c89
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Feb 8 19:16:33 2010 +0100

    PM: Allow PCI devices to suspend/resume asynchronously
    
    Set power.async_suspend for all PCI devices and PCIe port services,
    so that they can be suspended and resumed in parallel with other
    devices they don't depend on in a known way (i.e. devices which are
    not their parents or children).
    
    This only affects the "regular" suspend and resume stages, which
    means in particular that the restoration of the PCI devices' standard
    configuration registers during resume will still be carried out
    synchronously (at the "early" resume stage).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index f4a2738bf0bf..2b9ac9e594af 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1540,6 +1540,7 @@ void pci_pm_init(struct pci_dev *dev)
 	int pm;
 	u16 pmc;
 
+	device_enable_async_suspend(&dev->dev);
 	dev->wakeup_prepared = false;
 	dev->pm_cap = 0;
 

commit 89a74ecccd1f78e51faf6287e5c0e93a92ac096e
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Feb 23 10:24:31 2010 -0700

    PCI: add pci_bus_for_each_resource(), remove direct bus->resource[] refs
    
    No functional change; this converts loops that iterate from 0 to
    PCI_BUS_NUM_RESOURCES through pci_bus resource[] table to use the
    pci_bus_for_each_resource() iterator instead.
    
    This doesn't change the way resources are stored; it merely removes
    dependencies on the fact that they're in a table.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index d62a5de81672..f4a2738bf0bf 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -386,10 +386,9 @@ pci_find_parent_resource(const struct pci_dev *dev, struct resource *res)
 {
 	const struct pci_bus *bus = dev->bus;
 	int i;
-	struct resource *best = NULL;
+	struct resource *best = NULL, *r;
 
-	for(i = 0; i < PCI_BUS_NUM_RESOURCES; i++) {
-		struct resource *r = bus->resource[i];
+	pci_bus_for_each_resource(bus, r, i) {
 		if (!r)
 			continue;
 		if (res->start && !(res->start >= r->start && res->end <= r->end))

commit 6cbf82148ff286ec22a55be6836c3a5bffc489c1
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Feb 17 23:44:58 2010 +0100

    PCI PM: Run-time callbacks for PCI bus type
    
    Introduce run-time PM callbacks for the PCI bus type.  Make the new
    callbacks work in analogy with the existing system sleep PM
    callbacks, so that the drivers already converted to struct dev_pm_ops
    can use their suspend and resume routines for run-time PM without
    modifications.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index df55a2f351b3..d62a5de81672 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1302,9 +1302,10 @@ void pci_pme_active(struct pci_dev *dev, bool enable)
 }
 
 /**
- * pci_enable_wake - enable PCI device as wakeup event source
+ * __pci_enable_wake - enable PCI device as wakeup event source
  * @dev: PCI device affected
  * @state: PCI state from which device will issue wakeup events
+ * @runtime: True if the events are to be generated at run time
  * @enable: True to enable event generation; false to disable
  *
  * This enables the device as a wakeup event source, or disables it.
@@ -1320,11 +1321,12 @@ void pci_pme_active(struct pci_dev *dev, bool enable)
  * Error code depending on the platform is returned if both the platform and
  * the native mechanism fail to enable the generation of wake-up events
  */
-int pci_enable_wake(struct pci_dev *dev, pci_power_t state, bool enable)
+int __pci_enable_wake(struct pci_dev *dev, pci_power_t state,
+		      bool runtime, bool enable)
 {
 	int ret = 0;
 
-	if (enable && !device_may_wakeup(&dev->dev))
+	if (enable && !runtime && !device_may_wakeup(&dev->dev))
 		return -EINVAL;
 
 	/* Don't do the same thing twice in a row for one device. */
@@ -1344,19 +1346,24 @@ int pci_enable_wake(struct pci_dev *dev, pci_power_t state, bool enable)
 			pci_pme_active(dev, true);
 		else
 			ret = 1;
-		error = platform_pci_sleep_wake(dev, true);
+		error = runtime ? platform_pci_run_wake(dev, true) :
+					platform_pci_sleep_wake(dev, true);
 		if (ret)
 			ret = error;
 		if (!ret)
 			dev->wakeup_prepared = true;
 	} else {
-		platform_pci_sleep_wake(dev, false);
+		if (runtime)
+			platform_pci_run_wake(dev, false);
+		else
+			platform_pci_sleep_wake(dev, false);
 		pci_pme_active(dev, false);
 		dev->wakeup_prepared = false;
 	}
 
 	return ret;
 }
+EXPORT_SYMBOL(__pci_enable_wake);
 
 /**
  * pci_wake_from_d3 - enable/disable device to wake up from D3_hot or D3_cold
@@ -1465,6 +1472,31 @@ int pci_back_from_sleep(struct pci_dev *dev)
 	return pci_set_power_state(dev, PCI_D0);
 }
 
+/**
+ * pci_finish_runtime_suspend - Carry out PCI-specific part of runtime suspend.
+ * @dev: PCI device being suspended.
+ *
+ * Prepare @dev to generate wake-up events at run time and put it into a low
+ * power state.
+ */
+int pci_finish_runtime_suspend(struct pci_dev *dev)
+{
+	pci_power_t target_state = pci_target_state(dev);
+	int error;
+
+	if (target_state == PCI_POWER_ERROR)
+		return -EIO;
+
+	__pci_enable_wake(dev, target_state, true, pci_dev_run_wake(dev));
+
+	error = pci_set_power_state(dev, target_state);
+
+	if (error)
+		__pci_enable_wake(dev, target_state, true, false);
+
+	return error;
+}
+
 /**
  * pci_dev_run_wake - Check if device can generate run-time wake-up events.
  * @dev: Device to check.
@@ -2978,7 +3010,6 @@ EXPORT_SYMBOL(pci_save_state);
 EXPORT_SYMBOL(pci_restore_state);
 EXPORT_SYMBOL(pci_pme_capable);
 EXPORT_SYMBOL(pci_pme_active);
-EXPORT_SYMBOL(pci_enable_wake);
 EXPORT_SYMBOL(pci_wake_from_d3);
 EXPORT_SYMBOL(pci_target_state);
 EXPORT_SYMBOL(pci_prepare_to_sleep);

commit b67ea76172d4b1922c4b3c46c8ea8e9fec1ff38c
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Feb 17 23:44:09 2010 +0100

    PCI / ACPI / PM: Platform support for PCI PME wake-up
    
    Although the majority of PCI devices can generate PMEs that in
    principle may be used to wake up devices suspended at run time,
    platform support is generally necessary to convert PMEs into wake-up
    events that can be delivered to the kernel.  If ACPI is used for this
    purpose, PME signals generated by a PCI device will trigger the ACPI
    GPE associated with the device to generate an ACPI wake-up event that
    we can set up a handler for, provided that everything is configured
    correctly.
    
    Unfortunately, the subset of PCI devices that have GPEs associated
    with them is quite limited.  The devices without dedicated GPEs have
    to rely on the GPEs associated with other devices (in the majority of
    cases their upstream bridges and, possibly, the root bridge) to
    generate ACPI wake-up events in response to PME signals from them.
    
    Add ACPI platform support for PCI PME wake-up:
    o Add a framework making is possible to use ACPI system notify
      handlers for run-time PM.
    o Add new PCI platform callback ->run_wake() to struct
      pci_platform_pm_ops allowing us to enable/disable the platform to
      generate wake-up events for given device.  Implemet this callback
      for the ACPI platform.
    o Define ACPI wake-up handlers for PCI devices and PCI root buses and
      make the PCI-ACPI binding code register wake-up notifiers for all
      PCI devices present in the ACPI tables.
    o Add function pci_dev_run_wake() which can be used by PCI drivers to
      check if given device is capable of generating wake-up events at
      run time.
    
    Developed in cooperation with Matthew Garrett <mjg@redhat.com>.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 5723446544fd..df55a2f351b3 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -20,6 +20,7 @@
 #include <linux/pm_wakeup.h>
 #include <linux/interrupt.h>
 #include <linux/device.h>
+#include <linux/pm_runtime.h>
 #include <asm/setup.h>
 #include "pci.h"
 
@@ -462,6 +463,12 @@ static inline int platform_pci_sleep_wake(struct pci_dev *dev, bool enable)
 			pci_platform_pm->sleep_wake(dev, enable) : -ENODEV;
 }
 
+static inline int platform_pci_run_wake(struct pci_dev *dev, bool enable)
+{
+	return pci_platform_pm ?
+			pci_platform_pm->run_wake(dev, enable) : -ENODEV;
+}
+
 /**
  * pci_raw_set_power_state - Use PCI PM registers to set the power state of
  *                           given PCI device
@@ -1229,6 +1236,31 @@ bool pci_check_pme_status(struct pci_dev *dev)
 	return ret;
 }
 
+/**
+ * pci_pme_wakeup - Wake up a PCI device if its PME Status bit is set.
+ * @dev: Device to handle.
+ * @ign: Ignored.
+ *
+ * Check if @dev has generated PME and queue a resume request for it in that
+ * case.
+ */
+static int pci_pme_wakeup(struct pci_dev *dev, void *ign)
+{
+	if (pci_check_pme_status(dev))
+		pm_request_resume(&dev->dev);
+	return 0;
+}
+
+/**
+ * pci_pme_wakeup_bus - Walk given bus and wake up devices on it, if necessary.
+ * @bus: Top bus of the subtree to walk.
+ */
+void pci_pme_wakeup_bus(struct pci_bus *bus)
+{
+	if (bus)
+		pci_walk_bus(bus, pci_pme_wakeup, NULL);
+}
+
 /**
  * pci_pme_capable - check the capability of PCI device to generate PME#
  * @dev: PCI device to handle.
@@ -1433,6 +1465,41 @@ int pci_back_from_sleep(struct pci_dev *dev)
 	return pci_set_power_state(dev, PCI_D0);
 }
 
+/**
+ * pci_dev_run_wake - Check if device can generate run-time wake-up events.
+ * @dev: Device to check.
+ *
+ * Return true if the device itself is cabable of generating wake-up events
+ * (through the platform or using the native PCIe PME) or if the device supports
+ * PME and one of its upstream bridges can generate wake-up events.
+ */
+bool pci_dev_run_wake(struct pci_dev *dev)
+{
+	struct pci_bus *bus = dev->bus;
+
+	if (device_run_wake(&dev->dev))
+		return true;
+
+	if (!dev->pme_support)
+		return false;
+
+	while (bus->parent) {
+		struct pci_dev *bridge = bus->self;
+
+		if (device_run_wake(&bridge->dev))
+			return true;
+
+		bus = bus->parent;
+	}
+
+	/* We have reached the root bus. */
+	if (bus->bridge)
+		return device_run_wake(bus->bridge);
+
+	return false;
+}
+EXPORT_SYMBOL_GPL(pci_dev_run_wake);
+
 /**
  * pci_pm_init - Initialize PM functions of given PCI device
  * @dev: PCI device to handle.

commit 58ff463396ad00828e922d50998787e97fd32512
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Feb 17 23:36:58 2010 +0100

    PCI PM: Add function for checking PME status of devices
    
    Add function pci_check_pme_status() that will check the PME status
    bit of given device and clear it along with the PME enable bit.  It
    will be necessary for PCI run-time power management.
    
    Based on a patch from Shaohua Li <shaohua.li@intel.com>
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 1f9be53c39ba..5723446544fd 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1194,6 +1194,41 @@ int pci_set_pcie_reset_state(struct pci_dev *dev, enum pcie_reset_state state)
 	return pcibios_set_pcie_reset_state(dev, state);
 }
 
+/**
+ * pci_check_pme_status - Check if given device has generated PME.
+ * @dev: Device to check.
+ *
+ * Check the PME status of the device and if set, clear it and clear PME enable
+ * (if set).  Return 'true' if PME status and PME enable were both set or
+ * 'false' otherwise.
+ */
+bool pci_check_pme_status(struct pci_dev *dev)
+{
+	int pmcsr_pos;
+	u16 pmcsr;
+	bool ret = false;
+
+	if (!dev->pm_cap)
+		return false;
+
+	pmcsr_pos = dev->pm_cap + PCI_PM_CTRL;
+	pci_read_config_word(dev, pmcsr_pos, &pmcsr);
+	if (!(pmcsr & PCI_PM_CTRL_PME_STATUS))
+		return false;
+
+	/* Clear PME status. */
+	pmcsr |= PCI_PM_CTRL_PME_STATUS;
+	if (pmcsr & PCI_PM_CTRL_PME_ENABLE) {
+		/* Disable PME to avoid interrupt flood. */
+		pmcsr &= ~PCI_PM_CTRL_PME_ENABLE;
+		ret = true;
+	}
+
+	pci_write_config_word(dev, pmcsr_pos, pmcsr);
+
+	return ret;
+}
+
 /**
  * pci_pme_capable - check the capability of PCI device to generate PME#
  * @dev: PCI device to handle.

commit 93177a748ba0d4f3d3e51c8e6c785773bf6a70df
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sat Jan 2 22:57:24 2010 +0100

    PCI: Clean up build for CONFIG_PCI_QUIRKS unset
    
    Currently, drivers/pci/quirks.c is built unconditionally, but if
    CONFIG_PCI_QUIRKS is unset, the only things actually built in this
    file are definitions of global variables and empty functions (due to
    the #ifdef CONFIG_PCI_QUIRKS embracing all of the code inside the
    file).  This is not particularly nice and if someone overlooks
    the #ifdef CONFIG_PCI_QUIRKS, build errors are introduced.
    
    To clean that up, move the definitions of the global variables in
    quirks.c that are always built to pci.c, move the definitions of
    the empty functions (compiled when CONFIG_PCI_QUIRKS is unset) to
    headers (additionally make these functions static inline) and modify
    drivers/pci/Makefile so that quirks.c is only built if
    CONFIG_PCI_QUIRKS is set.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 315fea47e784..1f9be53c39ba 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -19,7 +19,6 @@
 #include <linux/pci-aspm.h>
 #include <linux/pm_wakeup.h>
 #include <linux/interrupt.h>
-#include <asm/dma.h>	/* isa_dma_bridge_buggy */
 #include <linux/device.h>
 #include <asm/setup.h>
 #include "pci.h"
@@ -29,6 +28,12 @@ const char *pci_power_names[] = {
 };
 EXPORT_SYMBOL_GPL(pci_power_names);
 
+int isa_dma_bridge_buggy;
+EXPORT_SYMBOL(isa_dma_bridge_buggy);
+
+int pci_pci_problems;
+EXPORT_SYMBOL(pci_pci_problems);
+
 unsigned int pci_pm_d3_delay;
 
 static void pci_dev_d3_sleep(struct pci_dev *dev)

commit cf4c43dd439b90a1a876b3f836ebe745abb9a269
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Wed Jul 15 13:13:00 2009 -0700

    PCI: Add pci_bus_find_ext_capability
    
    For use by code that needs to walk extended capability lists before
    pci_dev structures are set up.
    
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    LKML-Reference: <43F901BD926A4E43B106BF17856F07559FB80CFD@orsmsx508.amr.corp.intel.com>
    Signed-off-by: Jacob Pan <jacob.jun.pan@intel.com>
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 315fea47e784..aad62af2b4c6 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -297,6 +297,49 @@ int pci_find_ext_capability(struct pci_dev *dev, int cap)
 }
 EXPORT_SYMBOL_GPL(pci_find_ext_capability);
 
+/**
+ * pci_bus_find_ext_capability - find an extended capability
+ * @bus:   the PCI bus to query
+ * @devfn: PCI device to query
+ * @cap:   capability code
+ *
+ * Like pci_find_ext_capability() but works for pci devices that do not have a
+ * pci_dev structure set up yet.
+ *
+ * Returns the address of the requested capability structure within the
+ * device's PCI configuration space or 0 in case the device does not
+ * support it.
+ */
+int pci_bus_find_ext_capability(struct pci_bus *bus, unsigned int devfn,
+				int cap)
+{
+	u32 header;
+	int ttl;
+	int pos = PCI_CFG_SPACE_SIZE;
+
+	/* minimum 8 bytes per capability */
+	ttl = (PCI_CFG_SPACE_EXP_SIZE - PCI_CFG_SPACE_SIZE) / 8;
+
+	if (!pci_bus_read_config_dword(bus, devfn, pos, &header))
+		return 0;
+	if (header == 0xffffffff || header == 0)
+		return 0;
+
+	while (ttl-- > 0) {
+		if (PCI_EXT_CAP_ID(header) == cap)
+			return pos;
+
+		pos = PCI_EXT_CAP_NEXT(header);
+		if (pos < PCI_CFG_SPACE_SIZE)
+			break;
+
+		if (!pci_bus_read_config_dword(bus, devfn, pos, &header))
+			break;
+	}
+
+	return 0;
+}
+
 static int __pci_find_next_ht_cap(struct pci_dev *dev, int pos, int ht_cap)
 {
 	int rc, ttl = PCI_FIND_CAP_TTL;

commit 95a8b6efc5d07103583f706c8a5889437d537939
Author: Mike Travis <travis@sgi.com>
Date:   Tue Feb 2 14:38:13 2010 -0800

    pci: Update pci_set_vga_state() to call arch functions
    
    Update pci_set_vga_state to call arch dependent functions to enable Legacy
    VGA I/O transactions to be redirected to correct target.
    
    [akpm@linux-foundation.org: make pci_register_set_vga_state() __init]
    Signed-off-by: Mike Travis <travis@sgi.com>
    LKML-Reference: <201002022238.o12McE1J018723@imap1.linux-foundation.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Robin Holt <holt@sgi.com>
    Cc: Jack Steiner <steiner@sgi.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Jesse Barnes <jbarnes@virtuousgeek.org>
    Cc: David Airlie <airlied@linux.ie>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 315fea47e784..ac2a576133f9 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2615,6 +2615,23 @@ int pci_resource_bar(struct pci_dev *dev, int resno, enum pci_bar_type *type)
 	return 0;
 }
 
+/* Some architectures require additional programming to enable VGA */
+static arch_set_vga_state_t arch_set_vga_state;
+
+void __init pci_register_set_vga_state(arch_set_vga_state_t func)
+{
+	arch_set_vga_state = func;	/* NULL disables */
+}
+
+static int pci_set_vga_state_arch(struct pci_dev *dev, bool decode,
+		      unsigned int command_bits, bool change_bridge)
+{
+	if (arch_set_vga_state)
+		return arch_set_vga_state(dev, decode, command_bits,
+						change_bridge);
+	return 0;
+}
+
 /**
  * pci_set_vga_state - set VGA decode state on device and parents if requested
  * @dev: the PCI device
@@ -2628,9 +2645,15 @@ int pci_set_vga_state(struct pci_dev *dev, bool decode,
 	struct pci_bus *bus;
 	struct pci_dev *bridge;
 	u16 cmd;
+	int rc;
 
 	WARN_ON(command_bits & ~(PCI_COMMAND_IO|PCI_COMMAND_MEMORY));
 
+	/* ARCH specific VGA enables */
+	rc = pci_set_vga_state_arch(dev, decode, command_bits, change_bridge);
+	if (rc)
+		return rc;
+
 	pci_read_config_word(dev, PCI_COMMAND, &cmd);
 	if (decode == true)
 		cmd |= command_bits;
@@ -2845,6 +2868,7 @@ EXPORT_SYMBOL(pcim_pin_device);
 EXPORT_SYMBOL(pci_disable_device);
 EXPORT_SYMBOL(pci_find_capability);
 EXPORT_SYMBOL(pci_bus_find_capability);
+EXPORT_SYMBOL(pci_register_set_vga_state);
 EXPORT_SYMBOL(pci_release_regions);
 EXPORT_SYMBOL(pci_request_regions);
 EXPORT_SYMBOL(pci_request_regions_exclusive);
@@ -2877,4 +2901,3 @@ EXPORT_SYMBOL(pci_target_state);
 EXPORT_SYMBOL(pci_prepare_to_sleep);
 EXPORT_SYMBOL(pci_back_from_sleep);
 EXPORT_SYMBOL_GPL(pci_set_pcie_reset_state);
-

commit 1ae861e652b5457e7fa98ccbc55abea1e207916e
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Dec 31 12:15:54 2009 +0100

    PCI/PM: Use per-device D3 delays
    
    It turns out that some PCI devices require extra delays when changing
    power state from D3 to D0 (and the other way around).  Although this
    is against the PCI specification, we can handle it quite easily by
    allowing drivers to define arbitrary D3 delays for devices known to
    require extra time for switching power states.
    
    Introduce additional field d3_delay in struct pci_dev and use it to
    store the value of the device's D0->D3 delay, in miliseconds.  Make
    the PCI PM core code use the per-device d3_delay unless
    pci_pm_d3_delay is greater (in which case the latter is used).
    [This also allows the driver to specify d3_delay shorter than the
     10 ms required by the PCI standard if the device is known to be able
     to handle that.]
    
    Make the sky2 driver set d3_delay to 150 for devices handled by it.
    
    Fixes http://bugzilla.kernel.org/show_bug.cgi?id=14730 which is a
    listed regression from 2.6.30.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 0906599ebfde..315fea47e784 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -29,7 +29,17 @@ const char *pci_power_names[] = {
 };
 EXPORT_SYMBOL_GPL(pci_power_names);
 
-unsigned int pci_pm_d3_delay = PCI_PM_D3_WAIT;
+unsigned int pci_pm_d3_delay;
+
+static void pci_dev_d3_sleep(struct pci_dev *dev)
+{
+	unsigned int delay = dev->d3_delay;
+
+	if (delay < pci_pm_d3_delay)
+		delay = pci_pm_d3_delay;
+
+	msleep(delay);
+}
 
 #ifdef CONFIG_PCI_DOMAINS
 int pci_domains_supported = 1;
@@ -522,7 +532,7 @@ static int pci_raw_set_power_state(struct pci_dev *dev, pci_power_t state)
 	/* Mandatory power management transition delays */
 	/* see PCI PM 1.1 5.6.1 table 18 */
 	if (state == PCI_D3hot || dev->current_state == PCI_D3hot)
-		msleep(pci_pm_d3_delay);
+		pci_dev_d3_sleep(dev);
 	else if (state == PCI_D2 || dev->current_state == PCI_D2)
 		udelay(PCI_PM_D2_DELAY);
 
@@ -1409,6 +1419,7 @@ void pci_pm_init(struct pci_dev *dev)
 	}
 
 	dev->pm_cap = pm;
+	dev->d3_delay = PCI_PM_D3_WAIT;
 
 	dev->d1_support = false;
 	dev->d2_support = false;
@@ -2247,12 +2258,12 @@ static int pci_pm_reset(struct pci_dev *dev, int probe)
 	csr &= ~PCI_PM_CTRL_STATE_MASK;
 	csr |= PCI_D3hot;
 	pci_write_config_word(dev, dev->pm_cap + PCI_PM_CTRL, csr);
-	msleep(pci_pm_d3_delay);
+	pci_dev_d3_sleep(dev);
 
 	csr &= ~PCI_PM_CTRL_STATE_MASK;
 	csr |= PCI_D0;
 	pci_write_config_word(dev, dev->pm_cap + PCI_PM_CTRL, csr);
-	msleep(pci_pm_d3_delay);
+	pci_dev_d3_sleep(dev);
 
 	return 0;
 }

commit 5b889bf237fca383b5807ad69fde3ad1e2287e42
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Dec 31 19:06:35 2009 +0100

    PCI: Fix build if quirks are not enabled
    
    After commit b9c3b266411d27f1a6466c19d146d08db576bfea ("PCI: support
    device-specific reset methods") the kernel build is broken if
    CONFIG_PCI_QUIRKS is unset.
    
    Fix this by moving pci_dev_specific_reset() to drivers/pci/quirks.c and
    providing an empty replacement for !CONFIG_PCI_QUIRKS builds.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Reported-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 864e703cf737..0906599ebfde 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2284,21 +2284,6 @@ static int pci_parent_bus_reset(struct pci_dev *dev, int probe)
 	return 0;
 }
 
-static int pci_dev_specific_reset(struct pci_dev *dev, int probe)
-{
-	struct pci_dev_reset_methods *i;
-
-	for (i = pci_dev_reset_methods; i->reset; i++) {
-		if ((i->vendor == dev->vendor ||
-		     i->vendor == (u16)PCI_ANY_ID) &&
-		    (i->device == dev->device ||
-		     i->device == (u16)PCI_ANY_ID))
-			return i->reset(dev, probe);
-	}
-
-	return -ENOTTY;
-}
-
 static int pci_dev_reset(struct pci_dev *dev, int probe)
 {
 	int rc;

commit 2d1c861871d767153538a77c498752b36d4bb4b8
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Wed Dec 9 17:52:13 2009 +1100

    PCI/cardbus: Add a fixup hook and fix powerpc
    
    The cardbus code creates PCI devices without ever going through the
    necessary fixup bits and pieces that normal PCI devices go through.
    
    There's in fact a commented out call to pcibios_fixup_bus() in there,
    it's commented because ... it doesn't work.
    
    I could make pcibios_fixup_bus() do the right thing on powerpc easily
    but I felt it cleaner instead to provide a specific hook pci_fixup_cardbus
    for which a weak empty implementation is provided by the PCI core.
    
    This fixes cardbus on powerbooks and probably all other PowerPC
    platforms which was broken completely for ever on some platforms and
    since 2.6.31 on others such as PowerBooks when we made the DMA ops
    mandatory (since those are setup by the fixups).
    
    Acked-by: Dominik Brodowski <linux@dominikbrodowski.net>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index d50522bf16b1..864e703cf737 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2798,6 +2798,11 @@ int __attribute__ ((weak)) pci_ext_cfg_avail(struct pci_dev *dev)
 	return 1;
 }
 
+void __weak pci_fixup_cardbus(struct pci_bus *bus)
+{
+}
+EXPORT_SYMBOL(pci_fixup_cardbus);
+
 static int __init pci_setup(char *str)
 {
 	while (str) {

commit 45e829ea412760d2404d7dfc42528df46aedbf62
Author: Stefan Assmann <sassmann@redhat.com>
Date:   Thu Dec 3 06:49:24 2009 -0500

    PCI: change PCI nomenclature in drivers/pci/ (comment changes)
    
    Changing occurrences of variants of PCI-X and PCIe to the PCI-SIG
    terms listed in the "Trademark and Logo Usage Guidelines".
    http://www.pcisig.com/developers/procedures/logos/Trademark_and_Logo_Usage_Guidelines_updated_112206.pdf
    
    Patch is limited to drivers/pci/ and changes concern comments only.
    
    Signed-off-by: Stefan Assmann <sassmann@redhat.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 6011d064e89d..d50522bf16b1 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1153,11 +1153,11 @@ pci_disable_device(struct pci_dev *dev)
 
 /**
  * pcibios_set_pcie_reset_state - set reset state for device dev
- * @dev: the PCI-E device reset
+ * @dev: the PCIe device reset
  * @state: Reset state to enter into
  *
  *
- * Sets the PCI-E reset state for the device. This is the default
+ * Sets the PCIe reset state for the device. This is the default
  * implementation. Architecture implementations can override this.
  */
 int __attribute__ ((weak)) pcibios_set_pcie_reset_state(struct pci_dev *dev,
@@ -1168,7 +1168,7 @@ int __attribute__ ((weak)) pcibios_set_pcie_reset_state(struct pci_dev *dev,
 
 /**
  * pci_set_pcie_reset_state - set reset state for device dev
- * @dev: the PCI-E device reset
+ * @dev: the PCIe device reset
  * @state: Reset state to enter into
  *
  *

commit b9c3b266411d27f1a6466c19d146d08db576bfea
Author: Dexuan Cui <dexuan.cui@intel.com>
Date:   Mon Dec 7 13:03:21 2009 +0800

    PCI: support device-specific reset methods
    
    Add a new type of quirk for resetting devices at pci_dev_reset time.
    This is necessary to handle device with nonstandard reset procedures,
    especially useful for guest drivers.
    
    Signed-off-by: Yu Zhao <yu.zhao@intel.com>
    Signed-off-by: Dexuan Cui <dexuan.cui@intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 0bc27e059019..6011d064e89d 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2284,6 +2284,21 @@ static int pci_parent_bus_reset(struct pci_dev *dev, int probe)
 	return 0;
 }
 
+static int pci_dev_specific_reset(struct pci_dev *dev, int probe)
+{
+	struct pci_dev_reset_methods *i;
+
+	for (i = pci_dev_reset_methods; i->reset; i++) {
+		if ((i->vendor == dev->vendor ||
+		     i->vendor == (u16)PCI_ANY_ID) &&
+		    (i->device == dev->device ||
+		     i->device == (u16)PCI_ANY_ID))
+			return i->reset(dev, probe);
+	}
+
+	return -ENOTTY;
+}
+
 static int pci_dev_reset(struct pci_dev *dev, int probe)
 {
 	int rc;
@@ -2296,6 +2311,10 @@ static int pci_dev_reset(struct pci_dev *dev, int probe)
 		down(&dev->dev.sem);
 	}
 
+	rc = pci_dev_specific_reset(dev, probe);
+	if (rc != -ENOTTY)
+		goto done;
+
 	rc = pcie_flr(dev, probe);
 	if (rc != -ENOTTY)
 		goto done;

commit 9e0b5b2c447ad0caa075a5cfef86def62e1782ff
Author: Kleber Sacilotto de Souza <klebers@linux.vnet.ibm.com>
Date:   Wed Nov 25 00:55:51 2009 -0200

    PCI: fix coding style issue in pci_save_state()
    
    Remove a stray space in pci_save_state().
    
    Signed-off-by: Kleber Sacilotto de Souza <klebers@linux.vnet.ibm.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index cd9b375f49d5..0bc27e059019 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -850,7 +850,7 @@ pci_save_state(struct pci_dev *dev)
 	int i;
 	/* XXX: 100% dword access ok here? */
 	for (i = 0; i < 16; i++)
-		pci_read_config_dword(dev, i * 4,&dev->saved_config_space[i]);
+		pci_read_config_dword(dev, i * 4, &dev->saved_config_space[i]);
 	dev->state_saved = true;
 	if ((i = pci_save_pcie_state(dev)) != 0)
 		return i;

commit 5d990b627537e59a3a2f039ff588a4750e9c1a6a
Author: Chris Wright <chrisw@sous-sol.org>
Date:   Fri Dec 4 12:15:21 2009 -0800

    PCI: add pci_request_acs
    
    Commit ae21ee65e8bc228416bbcc8a1da01c56a847a60c "PCI: acs p2p upsteram
    forwarding enabling" doesn't actually enable ACS.
    
    Add a function to pci core to allow an IOMMU to request that ACS
    be enabled.  The existing mechanism of using iommu_found() in the pci
    core to know when ACS should be enabled doesn't actually work due to
    initialization order;  iommu has only been detected not initialized.
    
    Have Intel and AMD IOMMUs request ACS, and Xen does as well during early
    init of dom0.
    
    Cc: Allen Kay <allen.m.kay@intel.com>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: Jeremy Fitzhardinge <jeremy@goop.org>
    Cc: Joerg Roedel <joerg.roedel@amd.com>
    Signed-off-by: Chris Wright <chrisw@sous-sol.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 6af212c509c5..cd9b375f49d5 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1550,6 +1550,16 @@ void pci_enable_ari(struct pci_dev *dev)
 	bridge->ari_enabled = 1;
 }
 
+static int pci_acs_enable;
+
+/**
+ * pci_request_acs - ask for ACS to be enabled if supported
+ */
+void pci_request_acs(void)
+{
+	pci_acs_enable = 1;
+}
+
 /**
  * pci_enable_acs - enable ACS if hardware support it
  * @dev: the PCI device
@@ -1560,6 +1570,9 @@ void pci_enable_acs(struct pci_dev *dev)
 	u16 cap;
 	u16 ctrl;
 
+	if (!pci_acs_enable)
+		return;
+
 	if (!pci_is_pcie(dev))
 		return;
 

commit 04b55c4732780381410e52db0e9bfb7661f2b4b3
Author: Shmulik Ravid <shmulikr@broadcom.com>
Date:   Thu Dec 3 22:27:51 2009 +0200

    PCI: read-modify-write the pcie device control register when initiating pcie flr
    
    The pcie_flr routine writes the device control register with the FLR bit
    set clearing all other fields for the FLR duration. Among other fields,
    the Max_Payload_Size is also cleared which can cause errors if there are
    transactions lurking in the HW pipeline. The patch replaces the blank
    write with read-modify-write of the control register keeping the other
    fields intact.
    
    Signed-off-by: Shmulik Ravid <shmulikr@broadcom.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index be91a09c74a5..6af212c509c5 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2140,7 +2140,7 @@ static int pcie_flr(struct pci_dev *dev, int probe)
 	int i;
 	int pos;
 	u32 cap;
-	u16 status;
+	u16 status, control;
 
 	pos = pci_pcie_cap(dev);
 	if (!pos)
@@ -2167,8 +2167,10 @@ static int pcie_flr(struct pci_dev *dev, int probe)
 			"proceeding with reset anyway\n");
 
 clear:
-	pci_write_config_word(dev, pos + PCI_EXP_DEVCTL,
-				PCI_EXP_DEVCTL_BCR_FLR);
+	pci_read_config_word(dev, pos + PCI_EXP_DEVCTL, &control);
+	control |= PCI_EXP_DEVCTL_BCR_FLR;
+	pci_write_config_word(dev, pos + PCI_EXP_DEVCTL, control);
+
 	msleep(100);
 
 	return 0;

commit c6a415761c59adabb53699c84e5cb42868d97c67
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Wed Nov 25 16:28:50 2009 -0800

    PCI: add debug output for DMA mask info
    
    This allows us to find out what DMA mask is used for each PCI device at boot
    time; useful for debugging.
    
    After the patch:
    ehci_hcd 0000:00:02.1: using 31bit consistent DMA mask
    e1000 0000:0b:01.0: using 64bit DMA mask
    e1000 0000:0b:01.0: using 64bit consistent DMA mask
    e1000e 0000:04:00.0: using 64bit DMA mask
    e1000e 0000:04:00.0: using 64bit consistent DMA mask
    ixgb 0000:0c:01.0: using 64bit DMA mask
    ixgb 0000:0c:01.0: using 64bit consistent DMA mask
    aacraid 0000:86:00.0: using 32bit DMA mask
    aacraid 0000:86:00.0: using 32bit consistent DMA mask
    aacraid 0000:86:00.0: using 64bit DMA mask
    aacraid 0000:86:00.0: using 64bit consistent DMA mask
    qla2xxx 0000:0c:02.0: using 64bit consistent DMA mask
    qla2xxx 0000:0c:02.1: using 64bit consistent DMA mask
    lpfc 0000:06:00.0: using 64bit DMA mask
    lpfc 0000:06:00.1: using 64bit DMA mask
    pata_amd 0000:00:06.0: using 32bit DMA mask
    pata_amd 0000:00:06.0: using 32bit consistent DMA mask
    mptsas 0000:0c:04.0: using 64bit DMA mask
    mptsas 0000:0c:04.0: using 64bit consistent DMA mask
    
    forcedeth 0000:00:08.0: using 39bit DMA mask
    forcedeth 0000:00:08.0: using 39bit consistent DMA mask
    niu 0000:02:00.0: using 44bit DMA mask
    niu 0000:02:00.0: using 44bit consistent DMA mask
    sata_nv 0000:00:05.0: using 32bit DMA mask
    sata_nv 0000:00:05.0: using 32bit consistent DMA mask
    ib_mthca 0000:03:00.0: using 64bit DMA mask
    ib_mthca 0000:03:00.0: using 64bit consistent DMA mask
    
    Reviewed-by: Grant Grundler <grundler@google.com>
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 453d6ba6811e..be91a09c74a5 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2101,6 +2101,7 @@ pci_set_dma_mask(struct pci_dev *dev, u64 mask)
 		return -EIO;
 
 	dev->dma_mask = mask;
+	dev_dbg(&dev->dev, "using %dbit DMA mask\n", fls64(mask));
 
 	return 0;
 }
@@ -2112,6 +2113,7 @@ pci_set_consistent_dma_mask(struct pci_dev *dev, u64 mask)
 		return -EIO;
 
 	dev->dev.coherent_dma_mask = mask;
+	dev_dbg(&dev->dev, "using %dbit consistent DMA mask\n", fls64(mask));
 
 	return 0;
 }

commit 5f4d91a1228ac85c75b099efd36fff1a3407335c
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Wed Nov 11 14:36:17 2009 +0900

    PCI: use pci_is_pcie() in pci core
    
    Change for PCI core to use pci_is_pcie() instead of checking
    pci_dev->is_pcie.
    
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index bbc82f08d1c1..453d6ba6811e 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1524,7 +1524,7 @@ void pci_enable_ari(struct pci_dev *dev)
 	u16 ctrl;
 	struct pci_dev *bridge;
 
-	if (!dev->is_pcie || dev->devfn)
+	if (!pci_is_pcie(dev) || dev->devfn)
 		return;
 
 	pos = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ARI);
@@ -1532,7 +1532,7 @@ void pci_enable_ari(struct pci_dev *dev)
 		return;
 
 	bridge = dev->bus->self;
-	if (!bridge || !bridge->is_pcie)
+	if (!bridge || !pci_is_pcie(bridge))
 		return;
 
 	pos = pci_pcie_cap(bridge);
@@ -1560,7 +1560,7 @@ void pci_enable_acs(struct pci_dev *dev)
 	u16 cap;
 	u16 ctrl;
 
-	if (!dev->is_pcie)
+	if (!pci_is_pcie(dev))
 		return;
 
 	pos = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ACS);

commit 06a1cbafb253c4c60d6a54a994887f5fbceabcc0
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Wed Nov 11 14:30:56 2009 +0900

    PCI: use pci_pcie_cap() in pci core
    
    Use pcie_cap() instead of pci_find_capability() to get PCIe capability
    offset in PCI core code. This avoids unnecessary search in PCI
    configuration space.
    
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index e3145f020271..bbc82f08d1c1 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -741,8 +741,8 @@ static int pci_save_pcie_state(struct pci_dev *dev)
 	u16 *cap;
 	u16 flags;
 
-	pos = pci_find_capability(dev, PCI_CAP_ID_EXP);
-	if (pos <= 0)
+	pos = pci_pcie_cap(dev);
+	if (!pos)
 		return 0;
 
 	save_state = pci_find_saved_cap(dev, PCI_CAP_ID_EXP);
@@ -1535,7 +1535,7 @@ void pci_enable_ari(struct pci_dev *dev)
 	if (!bridge || !bridge->is_pcie)
 		return;
 
-	pos = pci_find_capability(bridge, PCI_CAP_ID_EXP);
+	pos = pci_pcie_cap(bridge);
 	if (!pos)
 		return;
 
@@ -2140,7 +2140,7 @@ static int pcie_flr(struct pci_dev *dev, int probe)
 	u32 cap;
 	u16 status;
 
-	pos = pci_find_capability(dev, PCI_CAP_ID_EXP);
+	pos = pci_pcie_cap(dev);
 	if (!pos)
 		return -ENOTTY;
 
@@ -2489,7 +2489,7 @@ int pcie_get_readrq(struct pci_dev *dev)
 	int ret, cap;
 	u16 ctl;
 
-	cap = pci_find_capability(dev, PCI_CAP_ID_EXP);
+	cap = pci_pcie_cap(dev);
 	if (!cap)
 		return -EINVAL;
 
@@ -2519,7 +2519,7 @@ int pcie_set_readrq(struct pci_dev *dev, int rq)
 
 	v = (ffs(rq) - 8) << 12;
 
-	cap = pci_find_capability(dev, PCI_CAP_ID_EXP);
+	cap = pci_pcie_cap(dev);
 	if (!cap)
 		goto out;
 

commit 8c8def26bfaa704db67d515da3eb92cf26067548
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Nov 9 12:04:32 2009 -0800

    PCI: allow matching of prefetchable resources to non-prefetchable windows
    
    I'm not entirely sure it needs to go into 32, but it's probably the right
    thing to do. Another way of explaining the patch is:
    
     - we currently pick the _first_ exactly matching bus resource entry, but
       the _last_ inexactly matching one. Normally first/last shouldn't
       matter, but bus resource entries aren't actually all created equal: in
       a transparent bus, the last resources will be the parent resources,
       which we should generally try to avoid unless we have no choice. So
       "first matching" is the thing we should always aim for.
    
     - the patch is a bit bigger than it needs to be, because I simplified the
       logic at the same time. It used to be a fairly incomprehensible
    
            if ((res->flags & IORESOURCE_PREFETCH) && !(r->flags & IORESOURCE_PREFETCH))
                    best = r;       /* Approximating prefetchable by non-prefetchable */
    
       and technically, all the patch did was to make that complex choice be
       even more complex (it basically added a "&& !best" to say that if we
       already gound a non-prefetchable window for the prefetchable resource,
       then we won't override an earlier one with that later one: remember
       "first matching").
    
     - So instead of that complex one with three separate conditionals in one,
       I split it up a bit, and am taking advantage of the fact that we
       already handled the exact case, so if 'res->flags' has the PREFETCH
       bit, then we already know that 'r->flags' will _not_ have it. So the
       simplified code drops the redundant test, and does the new '!best' test
       separately. It also uses 'continue' as a way to ignore the bus
       resource we know doesn't work (ie a prefetchable bus resource is _not_
       acceptable for anything but an exact match), so it turns into:
    
            /* We can't insert a non-prefetch resource inside a prefetchable parent .. */
            if (r->flags & IORESOURCE_PREFETCH)
                    continue;
            /* .. but we can put a prefetchable resource inside a non-prefetchable one */
            if (!best)
                    best = r;
    
       instead. With the comments, it's now six lines instead of two, but it's
       conceptually simpler, and I _could_ have written it as two lines:
    
            if ((res->flags & IORESOURCE_PREFETCH) && !best)
                    best = r;       /* Approximating prefetchable by non-prefetchable */
    
       but I thought that was too damn subtle.
    
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index f36b46806513..e3145f020271 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -382,8 +382,12 @@ pci_find_parent_resource(const struct pci_dev *dev, struct resource *res)
 			continue;	/* Wrong type */
 		if (!((res->flags ^ r->flags) & IORESOURCE_PREFETCH))
 			return r;	/* Exact match */
-		if ((res->flags & IORESOURCE_PREFETCH) && !(r->flags & IORESOURCE_PREFETCH))
-			best = r;	/* Approximating prefetchable by non-prefetchable */
+		/* We can't insert a non-prefetch resource inside a prefetchable parent .. */
+		if (r->flags & IORESOURCE_PREFETCH)
+			continue;
+		/* .. but we can put a prefetchable resource inside a non-prefetchable one */
+		if (!best)
+			best = r;
 	}
 	return best;
 }

commit e9d1e4921d5b62a80ed02851639249e2548d24f1
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Nov 6 22:41:23 2009 +0000

    PCI: Replace old style lock initializer
    
    SPIN_LOCK_UNLOCKED is deprecated. Use DEFINE_SPINLOCK instead.
    
    Make the lock static while at it.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index f88de099ef43..f36b46806513 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2625,7 +2625,7 @@ int pci_set_vga_state(struct pci_dev *dev, bool decode,
 
 #define RESOURCE_ALIGNMENT_PARAM_SIZE COMMAND_LINE_SIZE
 static char resource_alignment_param[RESOURCE_ALIGNMENT_PARAM_SIZE] = {0};
-spinlock_t resource_alignment_lock = SPIN_LOCK_UNLOCKED;
+static DEFINE_SPINLOCK(resource_alignment_lock);
 
 /**
  * pci_specified_resource_alignment - get resource alignment specified by user.

commit 865df576e8fc70daf297b53e61a4fbefc719d065
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Wed Nov 4 10:32:57 2009 -0700

    PCI: improve discovery/configuration messages
    
    This makes PCI resource management messages more consistent and adds a few
    new messages to aid debugging.
    
    Whenever we assign resources to a device, update a BAR, or change a
    bridge aperture, it's worth noting it.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 930eadf4670f..f88de099ef43 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2575,7 +2575,7 @@ int pci_resource_bar(struct pci_dev *dev, int resno, enum pci_bar_type *type)
 			return reg;
 	}
 
-	dev_err(&dev->dev, "BAR: invalid resource #%d\n", resno);
+	dev_err(&dev->dev, "BAR %d: invalid resource\n", resno);
 	return 0;
 }
 

commit 10c3d71d42f341775d96187eedd3e50eb34939d0
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Wed Nov 4 10:32:42 2009 -0700

    PCI: make PME# messages KERN_DEBUG
    
    Messages about PME# being supported and enabled/disabled are probably
    useful for debug, but maybe don't need to be on the console.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index f0da1676d2be..930eadf4670f 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1211,7 +1211,7 @@ void pci_pme_active(struct pci_dev *dev, bool enable)
 
 	pci_write_config_word(dev, dev->pm_cap + PCI_PM_CTRL, pmcsr);
 
-	dev_printk(KERN_INFO, &dev->dev, "PME# %s\n",
+	dev_printk(KERN_DEBUG, &dev->dev, "PME# %s\n",
 			enable ? "enabled" : "disabled");
 }
 
@@ -1422,7 +1422,8 @@ void pci_pm_init(struct pci_dev *dev)
 
 	pmc &= PCI_PM_CAP_PME_MASK;
 	if (pmc) {
-		dev_info(&dev->dev, "PME# supported from%s%s%s%s%s\n",
+		dev_printk(KERN_DEBUG, &dev->dev,
+			 "PME# supported from%s%s%s%s%s\n",
 			 (pmc & PCI_PM_CAP_PME_D0) ? " D0" : "",
 			 (pmc & PCI_PM_CAP_PME_D1) ? " D1" : "",
 			 (pmc & PCI_PM_CAP_PME_D2) ? " D2" : "",

commit c7dabef8a2c59e6a3de9d66fc35fb6a43ef7172d
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Oct 27 13:26:47 2009 -0600

    vsprintf: use %pR, %pr instead of %pRt, %pRf
    
    Jesse accidentally applied v1 [1] of the patchset instead of v2 [2].  This
    is the diff between v1 and v2.
    
    The changes in this patch are:
        - tidied vsprintf stack buffer to shrink and compute size more
          accurately
        - use %pR for decoding and %pr for "raw" (with type and flags) instead
          of adding %pRt and %pRf
    
    [1] http://lkml.org/lkml/2009/10/6/491
    [2] http://lkml.org/lkml/2009/10/13/441
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 557218222826..f0da1676d2be 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1713,7 +1713,7 @@ static int __pci_request_region(struct pci_dev *pdev, int bar, const char *res_n
 	return 0;
 
 err_out:
-	dev_warn(&pdev->dev, "BAR %d: can't reserve %pRt\n", bar,
+	dev_warn(&pdev->dev, "BAR %d: can't reserve %pR\n", bar,
 		 &pdev->resource[bar]);
 	return -EBUSY;
 }

commit ae21ee65e8bc228416bbcc8a1da01c56a847a60c
Author: Allen Kay <allen.m.kay@intel.com>
Date:   Wed Oct 7 10:27:17 2009 -0700

    PCI: acs p2p upsteram forwarding enabling
    
    Note: dom0 checking in v4 has been separated out into 2/2.
    
    This patch enables P2P upstream forwarding in ACS capable PCIe switches.
    It solves two potential problems in virtualization environment where a PCIe
    device is assigned to a guest domain using a HW iommu such as VT-d:
    
    1) Unintentional failure caused by guest physical address programmed
       into the device's DMA that happens to match the memory address range
       of other downstream ports in the same PCIe switch.  This causes the PCI
       transaction to go to the matching downstream port instead of go to the
       root complex to get translated by VT-d as it should be.
    
    2) Malicious guest software intentionally attacks another downstream
       PCIe device by programming the DMA address into the assigned device
       that matches memory address range of the downstream PCIe port.
    
    We are in process of implementing device filtering software in KVM/XEN
    management software to allow device assignment of PCIe devices behind a PCIe
    switch only if it has ACS capability and with the P2P upstream forwarding bits
    enabled.  This patch is intended to work for both KVM and Xen environments.
    
    Signed-off-by: Allen Kay <allen.m.kay@intel.com>
    Reviewed-by: Mathew Wilcox <willy@linux.intel.com>
    Reviewed-by: Chris Wright <chris@sous-sol.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 4859669f0ab5..557218222826 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1545,6 +1545,41 @@ void pci_enable_ari(struct pci_dev *dev)
 	bridge->ari_enabled = 1;
 }
 
+/**
+ * pci_enable_acs - enable ACS if hardware support it
+ * @dev: the PCI device
+ */
+void pci_enable_acs(struct pci_dev *dev)
+{
+	int pos;
+	u16 cap;
+	u16 ctrl;
+
+	if (!dev->is_pcie)
+		return;
+
+	pos = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ACS);
+	if (!pos)
+		return;
+
+	pci_read_config_word(dev, pos + PCI_ACS_CAP, &cap);
+	pci_read_config_word(dev, pos + PCI_ACS_CTRL, &ctrl);
+
+	/* Source Validation */
+	ctrl |= (cap & PCI_ACS_SV);
+
+	/* P2P Request Redirect */
+	ctrl |= (cap & PCI_ACS_RR);
+
+	/* P2P Completion Redirect */
+	ctrl |= (cap & PCI_ACS_CR);
+
+	/* Upstream Forwarding */
+	ctrl |= (cap & PCI_ACS_UF);
+
+	pci_write_config_word(dev, pos + PCI_ACS_CTRL, ctrl);
+}
+
 /**
  * pci_swizzle_interrupt_pin - swizzle INTx for device behind bridge
  * @dev: the PCI device

commit a369c791e881503a6253dafc0d0ad5e41e5557e5
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Oct 6 15:33:44 2009 -0600

    PCI: print resources consistently with %pRt
    
    This uses %pRt to print additional resource information (type, size,
    prefetchability, etc.) consistently.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 3f8d971ac36e..4859669f0ab5 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1678,9 +1678,7 @@ static int __pci_request_region(struct pci_dev *pdev, int bar, const char *res_n
 	return 0;
 
 err_out:
-	dev_warn(&pdev->dev, "BAR %d: can't reserve %s region %pR\n",
-		 bar,
-		 pci_resource_flags(pdev, bar) & IORESOURCE_IO ? "I/O" : "mem",
+	dev_warn(&pdev->dev, "BAR %d: can't reserve %pRt\n", bar,
 		 &pdev->resource[bar]);
 	return -EBUSY;
 }

commit 98e724c791924c0dfc5b1dcf053ed3841cc89c78
Author: Tejun Heo <tj@kernel.org>
Date:   Thu Oct 8 18:59:53 2009 +0900

    PCI: pci_dfl_cache_line_size is __devinitdata
    
    pci_dfl_cache_line_size is marked as __initdata but referenced by
    pci_init() which is __devinit.  Make it __devinitdata instead of
    __initdata.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Reported-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index d1afbae5b1fb..3f8d971ac36e 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -53,7 +53,7 @@ unsigned long pci_hotplug_mem_size = DEFAULT_HOTPLUG_MEM_SIZE;
  * the dfl or actual value as it sees fit.  Don't forget this is
  * measured in 32-bit words, not bytes.
  */
-u8 pci_dfl_cache_line_size __initdata = L1_CACHE_BYTES >> 2;
+u8 pci_dfl_cache_line_size __devinitdata = L1_CACHE_BYTES >> 2;
 u8 pci_cache_line_size;
 
 /**

commit 15ea76d407d560f985224b65fe59c9db01692a0d
Author: Tejun Heo <tj@kernel.org>
Date:   Tue Sep 22 17:34:48 2009 +0900

    pccard: configure CLS on attach
    
    For non hotplug PCI devices, the system firmware usually configures
    CLS correctly.  For pccard devices system firmware can't do it and
    Linux PCI layer doesn't do it either.  Unfortunately this leads to
    poor performance for certain devices (sata_sil).  Unless MWI, which
    requires separate configuration, is to be used, CLS doesn't affect
    correctness, so the configuration should be harmless.
    
    This patch makes pci_set_cacheline_size() always built and export it
    and make pccard call it during attach.
    
    Please note that some other PCI hotplug drivers (shpchp and pciehp)
    also configure CLS on hotplug.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Daniel Ritz <daniel.ritz@gmx.ch>
    Cc: Dominik Brodowski <linux@dominikbrodowski.net>
    Cc: Greg KH <greg@kroah.com>
    Cc: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Cc: Axel Birndt <towerlexa@gmx.de>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 01337b7a215f..d1afbae5b1fb 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1875,23 +1875,6 @@ void pci_clear_master(struct pci_dev *dev)
 	__pci_set_master(dev, false);
 }
 
-#ifdef PCI_DISABLE_MWI
-int pci_set_mwi(struct pci_dev *dev)
-{
-	return 0;
-}
-
-int pci_try_set_mwi(struct pci_dev *dev)
-{
-	return 0;
-}
-
-void pci_clear_mwi(struct pci_dev *dev)
-{
-}
-
-#else
-
 /**
  * pci_set_cacheline_size - ensure the CACHE_LINE_SIZE register is programmed
  * @dev: the PCI device for which MWI is to be enabled
@@ -1902,13 +1885,12 @@ void pci_clear_mwi(struct pci_dev *dev)
  *
  * RETURNS: An appropriate -ERRNO error value on error, or zero for success.
  */
-static int
-pci_set_cacheline_size(struct pci_dev *dev)
+int pci_set_cacheline_size(struct pci_dev *dev)
 {
 	u8 cacheline_size;
 
 	if (!pci_cache_line_size)
-		return -EINVAL;		/* The system doesn't support MWI. */
+		return -EINVAL;
 
 	/* Validate current setting: the PCI_CACHE_LINE_SIZE must be
 	   equal to or multiple of the right value. */
@@ -1929,6 +1911,24 @@ pci_set_cacheline_size(struct pci_dev *dev)
 
 	return -EINVAL;
 }
+EXPORT_SYMBOL_GPL(pci_set_cacheline_size);
+
+#ifdef PCI_DISABLE_MWI
+int pci_set_mwi(struct pci_dev *dev)
+{
+	return 0;
+}
+
+int pci_try_set_mwi(struct pci_dev *dev)
+{
+	return 0;
+}
+
+void pci_clear_mwi(struct pci_dev *dev)
+{
+}
+
+#else
 
 /**
  * pci_set_mwi - enables memory-write-invalidate PCI transaction

commit 4c0eec7a86303ce6e3edf7825d0ef1d414e76767
Author: Tejun Heo <tj@kernel.org>
Date:   Tue Sep 22 17:34:17 2009 +0900

    sparc64/PCI: drop PCI_CACHE_LINE_BYTES
    
    sparc64 is now the only user of PCI_CACHE_LINE_BYTES.  Drop it and set
    pci_dfl_cache_line_size from pcibios_init() instead and drop
    PCI_CACHE_LINE_BYTES handling from generic pci code.
    
    Orignally-From: David Miller <davem@davemloft.net>
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 1f9a7a03847b..01337b7a215f 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -47,17 +47,13 @@ unsigned long pci_cardbus_mem_size = DEFAULT_CARDBUS_MEM_SIZE;
 unsigned long pci_hotplug_io_size  = DEFAULT_HOTPLUG_IO_SIZE;
 unsigned long pci_hotplug_mem_size = DEFAULT_HOTPLUG_MEM_SIZE;
 
-#ifndef PCI_CACHE_LINE_BYTES
-#define PCI_CACHE_LINE_BYTES L1_CACHE_BYTES
-#endif
-
 /*
  * The default CLS is used if arch didn't set CLS explicitly and not
  * all pci devices agree on the same value.  Arch can override either
  * the dfl or actual value as it sees fit.  Don't forget this is
  * measured in 32-bit words, not bytes.
  */
-u8 pci_dfl_cache_line_size __initdata = PCI_CACHE_LINE_BYTES >> 2;
+u8 pci_dfl_cache_line_size __initdata = L1_CACHE_BYTES >> 2;
 u8 pci_cache_line_size;
 
 /**

commit ac1aa47b131416a6ff37eb1005a0a1d2541aad6c
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Mon Oct 26 13:20:44 2009 -0700

    PCI: determine CLS more intelligently
    
    Till now, CLS has been determined either by arch code or as
    L1_CACHE_BYTES.  Only x86 and ia64 set CLS explicitly and x86 doesn't
    always get it right.  On most configurations, the chance is that
    firmware configures the correct value during boot.
    
    This patch makes pci_init() determine CLS by looking at what firmware
    has configured.  It scans all devices and if all non-zero values
    agree, the value is used.  If none is configured or there is a
    disagreement, pci_dfl_cache_line_size is used.  arch can set the dfl
    value (via PCI_CACHE_LINE_BYTES or pci_dfl_cache_line_size) or
    override the actual one.
    
    ia64, x86 and sparc64 updated to set the default cls instead of the
    actual one.
    
    While at it, declare pci_cache_line_size and pci_dfl_cache_line_size
    in pci.h and drop private declarations from arch code.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Acked-by: David Miller <davem@davemloft.net>
    Acked-by: Greg KH <gregkh@suse.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 4e4c295a049f..1f9a7a03847b 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -47,6 +47,19 @@ unsigned long pci_cardbus_mem_size = DEFAULT_CARDBUS_MEM_SIZE;
 unsigned long pci_hotplug_io_size  = DEFAULT_HOTPLUG_IO_SIZE;
 unsigned long pci_hotplug_mem_size = DEFAULT_HOTPLUG_MEM_SIZE;
 
+#ifndef PCI_CACHE_LINE_BYTES
+#define PCI_CACHE_LINE_BYTES L1_CACHE_BYTES
+#endif
+
+/*
+ * The default CLS is used if arch didn't set CLS explicitly and not
+ * all pci devices agree on the same value.  Arch can override either
+ * the dfl or actual value as it sees fit.  Don't forget this is
+ * measured in 32-bit words, not bytes.
+ */
+u8 pci_dfl_cache_line_size __initdata = PCI_CACHE_LINE_BYTES >> 2;
+u8 pci_cache_line_size;
+
 /**
  * pci_bus_max_busnr - returns maximum PCI bus number of given bus' children
  * @bus: pointer to PCI bus structure to search
@@ -1883,14 +1896,6 @@ void pci_clear_mwi(struct pci_dev *dev)
 
 #else
 
-#ifndef PCI_CACHE_LINE_BYTES
-#define PCI_CACHE_LINE_BYTES L1_CACHE_BYTES
-#endif
-
-/* This can be overridden by arch code. */
-/* Don't forget this is measured in 32-bit words, not bytes */
-u8 pci_cache_line_size = PCI_CACHE_LINE_BYTES / 4;
-
 /**
  * pci_set_cacheline_size - ensure the CACHE_LINE_SIZE register is programmed
  * @dev: the PCI device for which MWI is to be enabled

commit 80fa680d22c11912a0be84b8139422eba1327322
Merge: 2caa731819a6 9a821b231644
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Oct 13 10:04:40 2009 -0700

    Merge git://git.infradead.org/~dwmw2/iommu-2.6.32
    
    * git://git.infradead.org/~dwmw2/iommu-2.6.32:
      x86: Move pci_iommu_init to rootfs_initcall()
      Run pci_apply_final_quirks() sooner.
      Mark pci_apply_final_quirks() __init rather than __devinit
      Rename pci_init() to pci_apply_final_quirks(), move it to quirks.c
      intel-iommu: Yet another BIOS workaround: Isoch DMAR unit with no TLB space
      intel-iommu: Decode (and ignore) RHSA entries
      intel-iommu: Make "Unknown DMAR structure" message more informative

commit 8d86fb2c80ec376b35ae64ac858d406ae1d42a3f
Author: David Woodhouse <David.Woodhouse@intel.com>
Date:   Mon Oct 12 12:48:43 2009 +0100

    Rename pci_init() to pci_apply_final_quirks(), move it to quirks.c
    
    This function may have done more in the past, but all it does now is
    apply the PCI_FIXUP_FINAL quirks. So name it sensibly and put it where
    it belongs.
    
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 6edecff0b419..2b575cfb4b09 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2719,17 +2719,6 @@ int __attribute__ ((weak)) pci_ext_cfg_avail(struct pci_dev *dev)
 	return 1;
 }
 
-static int __devinit pci_init(void)
-{
-	struct pci_dev *dev = NULL;
-
-	while ((dev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, dev)) != NULL) {
-		pci_fixup_device(pci_fixup_final, dev);
-	}
-
-	return 0;
-}
-
 static int __init pci_setup(char *str)
 {
 	while (str) {
@@ -2767,8 +2756,6 @@ static int __init pci_setup(char *str)
 }
 early_param("pci", pci_setup);
 
-device_initcall(pci_init);
-
 EXPORT_SYMBOL(pci_reenable_device);
 EXPORT_SYMBOL(pci_enable_device_io);
 EXPORT_SYMBOL(pci_enable_device_mem);

commit 19eea630f7c56038dd80fe2f6910c78655bf29c8
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Thu Sep 17 15:28:22 2009 -0700

    PCI: pci.c: fix kernel-doc notation
    
    Fix kernel-doc notation (& warnings) in pci/pci.c.
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 6e1da5aa7bb9..3835871f4832 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2546,10 +2546,10 @@ int pci_resource_bar(struct pci_dev *dev, int resno, enum pci_bar_type *type)
 
 /**
  * pci_set_vga_state - set VGA decode state on device and parents if requested
- * @dev the PCI device
- * @decode - true = enable decoding, false = disable decoding
- * @command_bits PCI_COMMAND_IO and/or PCI_COMMAND_MEMORY
- * @change_bridge - traverse ancestors and change bridges
+ * @dev: the PCI device
+ * @decode: true = enable decoding, false = disable decoding
+ * @command_bits: PCI_COMMAND_IO and/or PCI_COMMAND_MEMORY
+ * @change_bridge: traverse ancestors and change bridges
  */
 int pci_set_vga_state(struct pci_dev *dev, bool decode,
 		      unsigned int command_bits, bool change_bridge)

commit e13cdbd71fe12c4e191b737c4a3dbfdb4b2de03b
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Oct 5 00:48:40 2009 +0200

    PCI PM: Read device power state from register after updating it
    
    After attempting to change the power state of a PCI device
    pci_raw_set_power_state() doesn't check if the value it wrote into
    the device's PCI_PM_CTRL register has been stored in there, but
    unconditionally modifies the device's current_state field to reflect
    the change.  This may cause problems to happen if the power state of
    the device hasn't been changed in fact, because it will make the PCI
    PM core make a wrong assumption.
    
    To prevent such situations from happening modify
    pci_raw_set_power_state() so that it reads the device's PCI_PM_CTRL
    register after writing into it and uses the value read from the
    register to update the device's current_state field.  Also make it
    print a message saying that the device refused to change its power
    state as requested (returning an error code in such cases would cause
    suspend regressions to appear on some systems, where device drivers'
    suspend routines return error codes if pci_set_power_state() fails).
    
    Reviewed-by: Alex Chiang <achiang@hp.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 6edecff0b419..6e1da5aa7bb9 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -513,7 +513,11 @@ static int pci_raw_set_power_state(struct pci_dev *dev, pci_power_t state)
 	else if (state == PCI_D2 || dev->current_state == PCI_D2)
 		udelay(PCI_PM_D2_DELAY);
 
-	dev->current_state = state;
+	pci_read_config_word(dev, dev->pm_cap + PCI_PM_CTRL, &pmcsr);
+	dev->current_state = (pmcsr & PCI_PM_CTRL_STATE_MASK);
+	if (dev->current_state != state && printk_ratelimit())
+		dev_info(&dev->dev, "Refused to change power state, "
+			"currently in D%d\n", dev->current_state);
 
 	/* According to section 5.4.1 of the "PCI BUS POWER MANAGEMENT
 	 * INTERFACE SPECIFICATION, REV. 1.2", a device transitioning

commit 4b77b0a2ba27d64f58f16d8d4d48d8319dda36ff
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Sep 9 23:49:59 2009 +0200

    PCI: Clear saved_state after the state has been restored
    
    Some PCI devices fail if their standard configuration registers are
    restored twice in a row.  Prevent this from happening by making
    pci_restore_state() clear the saved_state flag of the device right
    after the device's standard configuration registers have been
    populated with the previously saved values.
    
    Simplify PCI PM callbacks by removing the direct clearing of
    state_saved from them, as it shouldn't be necessary any more (except
    in pci_pm_thaw(), where it has to be cleared, so that the values saved
    during the "freeze" phase of hibernation are not used later by mistake).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index dcdfb2212ca3..6edecff0b419 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -854,6 +854,7 @@ pci_restore_state(struct pci_dev *dev)
 
 	if (!dev->state_saved)
 		return 0;
+
 	/* PCI Express register must be restored first */
 	pci_restore_pcie_state(dev);
 
@@ -875,6 +876,8 @@ pci_restore_state(struct pci_dev *dev)
 	pci_restore_msi_state(dev);
 	pci_restore_iov_state(dev);
 
+	dev->state_saved = false;
+
 	return 0;
 }
 

commit e80bb09d2c73d76a2a4cd79e4a83802dd901c642
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Sep 8 23:14:49 2009 +0200

    PCI PM: Introduce device flag wakeup_prepared
    
    Introduce a new PCI device flag, wakeup_prepared, to prevent PCI
    wake-up preparation code from being executed twice in a row for the
    same device and for the same purpose.
    
    Reviewed-by: Matthew Garrett <mjg59@srcf.ucam.org>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 84a6d6d30c5a..dcdfb2212ca3 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1225,6 +1225,10 @@ int pci_enable_wake(struct pci_dev *dev, pci_power_t state, bool enable)
 	if (enable && !device_may_wakeup(&dev->dev))
 		return -EINVAL;
 
+	/* Don't do the same thing twice in a row for one device. */
+	if (!!enable == !!dev->wakeup_prepared)
+		return 0;
+
 	/*
 	 * According to "PCI System Architecture" 4th ed. by Tom Shanley & Don
 	 * Anderson we should be doing PME# wake enable followed by ACPI wake
@@ -1241,9 +1245,12 @@ int pci_enable_wake(struct pci_dev *dev, pci_power_t state, bool enable)
 		error = platform_pci_sleep_wake(dev, true);
 		if (ret)
 			ret = error;
+		if (!ret)
+			dev->wakeup_prepared = true;
 	} else {
 		platform_pci_sleep_wake(dev, false);
 		pci_pme_active(dev, false);
+		dev->wakeup_prepared = false;
 	}
 
 	return ret;
@@ -1365,6 +1372,7 @@ void pci_pm_init(struct pci_dev *dev)
 	int pm;
 	u16 pmc;
 
+	dev->wakeup_prepared = false;
 	dev->pm_cap = 0;
 
 	/* find PCI PM capability in list */

commit 5bcc2fb4e8157d829a38093b98e23329ac8acff7
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Sep 8 23:12:59 2009 +0200

    PCI PM: Simplify PCI wake-up code
    
    Rework the PCI wake-up code so that it's easier to read without
    changing the functionality.
    
    Reviewed-by: Matthew Garrett <mjg59@srcf.ucam.org>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 8c663d628d03..84a6d6d30c5a 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1220,8 +1220,7 @@ void pci_pme_active(struct pci_dev *dev, bool enable)
  */
 int pci_enable_wake(struct pci_dev *dev, pci_power_t state, bool enable)
 {
-	int error = 0;
-	bool pme_done = false;
+	int ret = 0;
 
 	if (enable && !device_may_wakeup(&dev->dev))
 		return -EINVAL;
@@ -1232,18 +1231,22 @@ int pci_enable_wake(struct pci_dev *dev, pci_power_t state, bool enable)
 	 * enable.  To disable wake-up we call the platform first, for symmetry.
 	 */
 
-	if (!enable && platform_pci_can_wakeup(dev))
-		error = platform_pci_sleep_wake(dev, false);
-
-	if (!enable || pci_pme_capable(dev, state)) {
-		pci_pme_active(dev, enable);
-		pme_done = true;
-	}
+	if (enable) {
+		int error;
 
-	if (enable && platform_pci_can_wakeup(dev))
+		if (pci_pme_capable(dev, state))
+			pci_pme_active(dev, true);
+		else
+			ret = 1;
 		error = platform_pci_sleep_wake(dev, true);
+		if (ret)
+			ret = error;
+	} else {
+		platform_pci_sleep_wake(dev, false);
+		pci_pme_active(dev, false);
+	}
 
-	return pme_done ? 0 : error;
+	return ret;
 }
 
 /**

commit 28760489a3f1e136c5ae8581c0fa8f63511f2f4c
Author: Eric W. Biederman <ebiederm@aristanetworks.com>
Date:   Wed Sep 9 14:09:24 2009 -0700

    PCI: pcie: Ensure hotplug ports have a minimum number of resources
    
    In general a BIOS may goof or we may hotplug in a hotplug controller.
    In either case the kernel needs to reserve resources for plugging
    in more devices in the future instead of creating a minimal resource
    assignment.
    
    We already do this for cardbus bridges I am just adding a variant
    for pcie bridges.
    
    v2: Make testing for pcie hotplug bridges based on a flag.
    
        So far we only set the flag for pcie but a header_quirk
        could easily be added for the non-standard pci hotplug
        bridges.
    
    Signed-off-by: Eric W. Biederman <ebiederm@aristanetworks.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index bd993351db45..8c663d628d03 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -41,6 +41,12 @@ int pci_domains_supported = 1;
 unsigned long pci_cardbus_io_size = DEFAULT_CARDBUS_IO_SIZE;
 unsigned long pci_cardbus_mem_size = DEFAULT_CARDBUS_MEM_SIZE;
 
+#define DEFAULT_HOTPLUG_IO_SIZE		(256)
+#define DEFAULT_HOTPLUG_MEM_SIZE	(2*1024*1024)
+/* pci=hpmemsize=nnM,hpiosize=nn can override this */
+unsigned long pci_hotplug_io_size  = DEFAULT_HOTPLUG_IO_SIZE;
+unsigned long pci_hotplug_mem_size = DEFAULT_HOTPLUG_MEM_SIZE;
+
 /**
  * pci_bus_max_busnr - returns maximum PCI bus number of given bus' children
  * @bus: pointer to PCI bus structure to search
@@ -2732,6 +2738,10 @@ static int __init pci_setup(char *str)
 							strlen(str + 19));
 			} else if (!strncmp(str, "ecrc=", 5)) {
 				pcie_ecrc_get_policy(str + 5);
+			} else if (!strncmp(str, "hpiosize=", 9)) {
+				pci_hotplug_io_size = memparse(str + 9, &str);
+			} else if (!strncmp(str, "hpmemsize=", 10)) {
+				pci_hotplug_mem_size = memparse(str + 10, &str);
 			} else {
 				printk(KERN_ERR "PCI: Unknown option `%s'\n",
 						str);

commit deb2d2ecd43dfc51efe71eed7128fda514da96c6
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Tue Aug 11 15:52:06 2009 +1000

    PCI/GPU: implement VGA arbitration on Linux
    
    Background:
    Graphic devices are accessed through ranges in I/O or memory space. While most
    modern devices allow relocation of such ranges, some "Legacy" VGA devices
    implemented on PCI will typically have the same "hard-decoded" addresses as
    they did on ISA. For more details see "PCI Bus Binding to IEEE Std 1275-1994
    Standard for Boot (Initialization Configuration) Firmware Revision 2.1"
    Section 7, Legacy Devices.
    
    The Resource Access Control (RAC) module inside the X server currently does
    the task of arbitration when more than one legacy device co-exists on the same
    machine. But the problem happens when these devices are trying to be accessed
    by different userspace clients (e.g. two server in parallel). Their address
    assignments conflict. Therefore an arbitration scheme _outside_ of the X
    server is needed to control the sharing of these resources. This document
    introduces the operation of the VGA arbiter implemented for Linux kernel.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Tiago Vignatti <tiago.vignatti@nokia.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 7d55039ffa05..bd993351db45 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2520,6 +2520,50 @@ int pci_resource_bar(struct pci_dev *dev, int resno, enum pci_bar_type *type)
 	return 0;
 }
 
+/**
+ * pci_set_vga_state - set VGA decode state on device and parents if requested
+ * @dev the PCI device
+ * @decode - true = enable decoding, false = disable decoding
+ * @command_bits PCI_COMMAND_IO and/or PCI_COMMAND_MEMORY
+ * @change_bridge - traverse ancestors and change bridges
+ */
+int pci_set_vga_state(struct pci_dev *dev, bool decode,
+		      unsigned int command_bits, bool change_bridge)
+{
+	struct pci_bus *bus;
+	struct pci_dev *bridge;
+	u16 cmd;
+
+	WARN_ON(command_bits & ~(PCI_COMMAND_IO|PCI_COMMAND_MEMORY));
+
+	pci_read_config_word(dev, PCI_COMMAND, &cmd);
+	if (decode == true)
+		cmd |= command_bits;
+	else
+		cmd &= ~command_bits;
+	pci_write_config_word(dev, PCI_COMMAND, cmd);
+
+	if (change_bridge == false)
+		return 0;
+
+	bus = dev->bus;
+	while (bus) {
+		bridge = bus->self;
+		if (bridge) {
+			pci_read_config_word(bridge, PCI_BRIDGE_CONTROL,
+					     &cmd);
+			if (decode == true)
+				cmd |= PCI_BRIDGE_CTL_VGA;
+			else
+				cmd &= ~PCI_BRIDGE_CTL_VGA;
+			pci_write_config_word(bridge, PCI_BRIDGE_CONTROL,
+					      cmd);
+		}
+		bus = bus->parent;
+	}
+	return 0;
+}
+
 #define RESOURCE_ALIGNMENT_PARAM_SIZE COMMAND_LINE_SIZE
 static char resource_alignment_param[RESOURCE_ALIGNMENT_PARAM_SIZE] = {0};
 spinlock_t resource_alignment_lock = SPIN_LOCK_UNLOCKED;

commit 711d57796f5ce2d02d6e62c9034afbb16aedda31
Author: Michael S. Tsirkin <mst@redhat.com>
Date:   Mon Jul 27 23:37:48 2009 +0300

    PCI: expose function reset capability in sysfs
    
    Some devices allow an individual function to be reset without affecting
    other functions in the same device: that's what pci_reset_function does.
    For devices that have this support, expose reset attribite in sysfs.
    
    This is useful e.g. for virtualization, where a qemu userspace
    process wants to reset the device when the guest is reset,
    to emulate machine reboot as closely as possible.
    
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Michael S. Tsirkin <mst@redhat.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 7b70312181d7..7d55039ffa05 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2261,6 +2261,22 @@ int __pci_reset_function(struct pci_dev *dev)
 }
 EXPORT_SYMBOL_GPL(__pci_reset_function);
 
+/**
+ * pci_probe_reset_function - check whether the device can be safely reset
+ * @dev: PCI device to reset
+ *
+ * Some devices allow an individual function to be reset without affecting
+ * other functions in the same device.  The PCI device must be responsive
+ * to PCI config space in order to use this function.
+ *
+ * Returns 0 if the device function can be reset or negative if the
+ * device doesn't support resetting a single function.
+ */
+int pci_probe_reset_function(struct pci_dev *dev)
+{
+	return pci_dev_reset(dev, 1);
+}
+
 /**
  * pci_reset_function - quiesce and reset a PCI device function
  * @dev: PCI device to reset

commit c82f63e411f1b58427c103bd95af2863b1c96dd1
Author: Alek Du <alek.du@intel.com>
Date:   Sat Aug 8 08:46:19 2009 +0800

    PCI: check saved state before restore
    
    Without the check, the config space may be filled with zeros. Though
    the driver should try to avoid call restoring before saving, but the
    pci layer also should check this.
    
    Also removes the existing check in pci_restore_standard_config, since
    it's superfluous with the new check in restore_state.
    
    Acked-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Alek Du <alek.du@intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index dbd0f947f497..7b70312181d7 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -846,6 +846,8 @@ pci_restore_state(struct pci_dev *dev)
 	int i;
 	u32 val;
 
+	if (!dev->state_saved)
+		return 0;
 	/* PCI Express register must be restored first */
 	pci_restore_pcie_state(dev);
 

commit 46b952a3c3a94afa339bd4961a4f3d1482436599
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Wed Jul 1 14:24:30 2009 -0700

    PCI: Fix IRQ swizzling for ARI-enabled devices
    
    For many purposes, including interrupt-swizzling, devices with ARI
    enabled behave as if they have one device (number 0) and 256 functions.
    This probably hasn't bitten us in practice because all ARI devices I've
    seen are also IOV devices, and IOV devices are required to use MSI.
    This isn't guaranteed, and there are legitimate reasons to use ARI
    without IOV, and hence potentially use pin-based interrupts.
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index d5d6f5667d83..dbd0f947f497 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1517,11 +1517,20 @@ void pci_enable_ari(struct pci_dev *dev)
  *
  * Perform INTx swizzling for a device behind one level of bridge.  This is
  * required by section 9.1 of the PCI-to-PCI bridge specification for devices
- * behind bridges on add-in cards.
+ * behind bridges on add-in cards.  For devices with ARI enabled, the slot
+ * number is always 0 (see the Implementation Note in section 2.2.8.1 of
+ * the PCI Express Base Specification, Revision 2.1)
  */
 u8 pci_swizzle_interrupt_pin(struct pci_dev *dev, u8 pin)
 {
-	return (((pin - 1) + PCI_SLOT(dev->devfn)) % 4) + 1;
+	int slot;
+
+	if (pci_ari_enabled(dev->bus))
+		slot = 0;
+	else
+		slot = PCI_SLOT(dev->devfn);
+
+	return (((pin - 1) + slot) % 4) + 1;
 }
 
 int

commit 654b75e044119bf8e7d773bce41ea039281bbfbe
Author: Yu Zhao <yu.zhao@intel.com>
Date:   Fri Jun 26 14:04:46 2009 +0800

    PCI: check if bus has a proper bridge device before triggering SBR
    
    For devices attached to the root bus, we can't trigger Secondary Bus
    Reset because there is no bridge device associated with the bus. So
    need to check bus->self again NULL first before using it.
    
    Reviewed-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Yu Zhao <yu.zhao@intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 6c93af5ced18..d5d6f5667d83 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2171,7 +2171,7 @@ static int pci_parent_bus_reset(struct pci_dev *dev, int probe)
 	u16 ctrl;
 	struct pci_dev *pdev;
 
-	if (dev->subordinate)
+	if (pci_is_root_bus(dev->bus) || dev->subordinate || !dev->bus->self)
 		return -ENOTTY;
 
 	list_for_each_entry(pdev, &dev->bus->devices, bus_list)

commit 59ef7a83f1127038a433464597df02e2dc9540e7
Merge: 5165aece0efa 2af5066f664c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jun 22 11:59:51 2009 -0700

    Merge branch 'linux-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jbarnes/pci-2.6
    
    * 'linux-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jbarnes/pci-2.6: (74 commits)
      PCI: make msi_free_irqs() to use msix_mask_irq() instead of open coded write
      PCI: Fix the NIU MSI-X problem in a better way
      PCI ASPM: remove get_root_port_link
      PCI ASPM: cleanup pcie_aspm_sanity_check
      PCI ASPM: remove has_switch field
      PCI ASPM: cleanup calc_Lx_latency
      PCI ASPM: cleanup pcie_aspm_get_cap_device
      PCI ASPM: cleanup clkpm checks
      PCI ASPM: cleanup __pcie_aspm_check_state_one
      PCI ASPM: cleanup initialization
      PCI ASPM: cleanup change input argument of aspm functions
      PCI ASPM: cleanup misc in struct pcie_link_state
      PCI ASPM: cleanup clkpm state in struct pcie_link_state
      PCI ASPM: cleanup latency field in struct pcie_link_state
      PCI ASPM: cleanup aspm state field in struct pcie_link_state
      PCI ASPM: fix typo in struct pcie_link_state
      PCI: drivers/pci/slot.c should depend on CONFIG_SYSFS
      PCI: remove redundant __msi_set_enable()
      PCI PM: consistently use type bool for wake enable variable
      x86/ACPI: Correct maximum allowed _CRS returned resources and warn if exceeded
      ...

commit 7d9a73f6dcf4390d256bf19330c81e91523a26d5
Author: Frans Pop <elendil@planet.nl>
Date:   Wed Jun 17 00:16:15 2009 +0200

    PCI PM: consistently use type bool for wake enable variable
    
    Other functions use type bool, so use that for pci_enable_wake as well.
    
    Signed-off-by: Frans Pop <elendil@planet.nl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 7b59fd7c9575..ccc0a0ccbef9 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1205,7 +1205,7 @@ void pci_pme_active(struct pci_dev *dev, bool enable)
  * Error code depending on the platform is returned if both the platform and
  * the native mechanism fail to enable the generation of wake-up events
  */
-int pci_enable_wake(struct pci_dev *dev, pci_power_t state, int enable)
+int pci_enable_wake(struct pci_dev *dev, pci_power_t state, bool enable)
 {
 	int error = 0;
 	bool pme_done = false;

commit d2abdf62882d982c58e7a6b09ecdcfcc28075e2e
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Jun 14 21:25:02 2009 +0200

    PCI PM: Fix handling of devices without PM support by pci_target_state()
    
    If a PCI device is not power-manageable either by the platform, or
    with the help of the native PCI PM interface, pci_target_state() will
    return either PCI_D3hot, or PCI_POWER_ERROR for it, depending on
    whether or not the device is configured to wake up the system.  Alas,
    none of these return values is correct, because each of them causes
    pci_prepare_to_sleep() to return error code, although it should
    complete successfully in such a case.
    
    Fix this problem by making pci_target_state() always return PCI_D0
    for devices that cannot be power managed.
    
    Cc: stable@kernel.org
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index c56a4a0355a8..7b59fd7c9575 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1284,15 +1284,14 @@ pci_power_t pci_target_state(struct pci_dev *dev)
 		default:
 			target_state = state;
 		}
+	} else if (!dev->pm_cap) {
+		target_state = PCI_D0;
 	} else if (device_may_wakeup(&dev->dev)) {
 		/*
 		 * Find the deepest state from which the device can generate
 		 * wake-up events, make it the target state and enable device
 		 * to generate PME#.
 		 */
-		if (!dev->pm_cap)
-			return PCI_POWER_ERROR;
-
 		if (dev->pme_support) {
 			while (target_state
 			      && !(dev->pme_support & (1 << target_state)))

commit c12ff1df5f114484e3d8abd028769a624cc3399f
Author: Yu Zhao <yu.zhao@intel.com>
Date:   Sat Jun 13 15:52:15 2009 +0800

    PCI: support Secondary Bus Reset
    
    PCI-to-PCI Bridge 1.2 specifies that the Secondary Bus Reset bit can
    force the assertion of RST# on the secondary interface, which can be
    used to reset all devices including subordinates under this bus. This
    can be used to reset a function if this function is the only device
    under this bus.
    
    Reviewed-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Yu Zhao <yu.zhao@intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 2e58acc66a8c..c56a4a0355a8 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2162,6 +2162,33 @@ static int pci_pm_reset(struct pci_dev *dev, int probe)
 	return 0;
 }
 
+static int pci_parent_bus_reset(struct pci_dev *dev, int probe)
+{
+	u16 ctrl;
+	struct pci_dev *pdev;
+
+	if (dev->subordinate)
+		return -ENOTTY;
+
+	list_for_each_entry(pdev, &dev->bus->devices, bus_list)
+		if (pdev != dev)
+			return -ENOTTY;
+
+	if (probe)
+		return 0;
+
+	pci_read_config_word(dev->bus->self, PCI_BRIDGE_CONTROL, &ctrl);
+	ctrl |= PCI_BRIDGE_CTL_BUS_RESET;
+	pci_write_config_word(dev->bus->self, PCI_BRIDGE_CONTROL, ctrl);
+	msleep(100);
+
+	ctrl &= ~PCI_BRIDGE_CTL_BUS_RESET;
+	pci_write_config_word(dev->bus->self, PCI_BRIDGE_CONTROL, ctrl);
+	msleep(100);
+
+	return 0;
+}
+
 static int pci_dev_reset(struct pci_dev *dev, int probe)
 {
 	int rc;
@@ -2183,6 +2210,10 @@ static int pci_dev_reset(struct pci_dev *dev, int probe)
 		goto done;
 
 	rc = pci_pm_reset(dev, probe);
+	if (rc != -ENOTTY)
+		goto done;
+
+	rc = pci_parent_bus_reset(dev, probe);
 done:
 	if (!probe) {
 		up(&dev->dev.sem);

commit f85876ba82281f15bc4da11e41b94243a8b2b5b4
Author: Yu Zhao <yu.zhao@intel.com>
Date:   Sat Jun 13 15:52:14 2009 +0800

    PCI: support PM D0hot->D3 transition reset
    
    PCI PM 1.2 specifies that the device will perform an internal reset upon
    transitioning from D3hot to D0 when the NO_SOFT_RESET bit is clear. This
    method can be used to reset a function if neither PCIe FLR nor PCI AF FLR
    are supported.
    
    Reviewed-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Yu Zhao <yu.zhao@intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 6a052ada3fe8..2e58acc66a8c 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2132,6 +2132,36 @@ static int pci_af_flr(struct pci_dev *dev, int probe)
 	return 0;
 }
 
+static int pci_pm_reset(struct pci_dev *dev, int probe)
+{
+	u16 csr;
+
+	if (!dev->pm_cap)
+		return -ENOTTY;
+
+	pci_read_config_word(dev, dev->pm_cap + PCI_PM_CTRL, &csr);
+	if (csr & PCI_PM_CTRL_NO_SOFT_RESET)
+		return -ENOTTY;
+
+	if (probe)
+		return 0;
+
+	if (dev->current_state != PCI_D0)
+		return -EINVAL;
+
+	csr &= ~PCI_PM_CTRL_STATE_MASK;
+	csr |= PCI_D3hot;
+	pci_write_config_word(dev, dev->pm_cap + PCI_PM_CTRL, csr);
+	msleep(pci_pm_d3_delay);
+
+	csr &= ~PCI_PM_CTRL_STATE_MASK;
+	csr |= PCI_D0;
+	pci_write_config_word(dev, dev->pm_cap + PCI_PM_CTRL, csr);
+	msleep(pci_pm_d3_delay);
+
+	return 0;
+}
+
 static int pci_dev_reset(struct pci_dev *dev, int probe)
 {
 	int rc;
@@ -2149,6 +2179,10 @@ static int pci_dev_reset(struct pci_dev *dev, int probe)
 		goto done;
 
 	rc = pci_af_flr(dev, probe);
+	if (rc != -ENOTTY)
+		goto done;
+
+	rc = pci_pm_reset(dev, probe);
 done:
 	if (!probe) {
 		up(&dev->dev.sem);

commit 8c1c699fec9e9021bf6ff0285dee086bb27aec90
Author: Yu Zhao <yu.zhao@intel.com>
Date:   Sat Jun 13 15:52:13 2009 +0800

    PCI: cleanup Function Level Reset
    
    This patch enhances the FLR functions:
      1) remove disable_irq() so the shared IRQ won't be disabled.
      2) replace the 1s wait with 100, 200 and 400ms wait intervals
         for the Pending Transaction.
      3) replace mdelay() with msleep().
      4) add might_sleep().
      5) lock the device to prevent PM suspend from accessing the CSRs
         during the reset.
      6) coding style fixes.
    
    Reviewed-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Yu Zhao <yu.zhao@intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 8ea911e55722..6a052ada3fe8 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2055,111 +2055,112 @@ int pci_set_dma_seg_boundary(struct pci_dev *dev, unsigned long mask)
 EXPORT_SYMBOL(pci_set_dma_seg_boundary);
 #endif
 
-static int __pcie_flr(struct pci_dev *dev, int probe)
+static int pcie_flr(struct pci_dev *dev, int probe)
 {
-	u16 status;
+	int i;
+	int pos;
 	u32 cap;
-	int exppos = pci_find_capability(dev, PCI_CAP_ID_EXP);
+	u16 status;
 
-	if (!exppos)
+	pos = pci_find_capability(dev, PCI_CAP_ID_EXP);
+	if (!pos)
 		return -ENOTTY;
-	pci_read_config_dword(dev, exppos + PCI_EXP_DEVCAP, &cap);
+
+	pci_read_config_dword(dev, pos + PCI_EXP_DEVCAP, &cap);
 	if (!(cap & PCI_EXP_DEVCAP_FLR))
 		return -ENOTTY;
 
 	if (probe)
 		return 0;
 
-	pci_block_user_cfg_access(dev);
-
 	/* Wait for Transaction Pending bit clean */
-	pci_read_config_word(dev, exppos + PCI_EXP_DEVSTA, &status);
-	if (!(status & PCI_EXP_DEVSTA_TRPND))
-		goto transaction_done;
+	for (i = 0; i < 4; i++) {
+		if (i)
+			msleep((1 << (i - 1)) * 100);
 
-	msleep(100);
-	pci_read_config_word(dev, exppos + PCI_EXP_DEVSTA, &status);
-	if (!(status & PCI_EXP_DEVSTA_TRPND))
-		goto transaction_done;
-
-	dev_info(&dev->dev, "Busy after 100ms while trying to reset; "
-			"sleeping for 1 second\n");
-	ssleep(1);
-	pci_read_config_word(dev, exppos + PCI_EXP_DEVSTA, &status);
-	if (status & PCI_EXP_DEVSTA_TRPND)
-		dev_info(&dev->dev, "Still busy after 1s; "
-				"proceeding with reset anyway\n");
-
-transaction_done:
-	pci_write_config_word(dev, exppos + PCI_EXP_DEVCTL,
+		pci_read_config_word(dev, pos + PCI_EXP_DEVSTA, &status);
+		if (!(status & PCI_EXP_DEVSTA_TRPND))
+			goto clear;
+	}
+
+	dev_err(&dev->dev, "transaction is not cleared; "
+			"proceeding with reset anyway\n");
+
+clear:
+	pci_write_config_word(dev, pos + PCI_EXP_DEVCTL,
 				PCI_EXP_DEVCTL_BCR_FLR);
-	mdelay(100);
+	msleep(100);
 
-	pci_unblock_user_cfg_access(dev);
 	return 0;
 }
 
-static int __pci_af_flr(struct pci_dev *dev, int probe)
+static int pci_af_flr(struct pci_dev *dev, int probe)
 {
-	int cappos = pci_find_capability(dev, PCI_CAP_ID_AF);
-	u8 status;
+	int i;
+	int pos;
 	u8 cap;
+	u8 status;
 
-	if (!cappos)
+	pos = pci_find_capability(dev, PCI_CAP_ID_AF);
+	if (!pos)
 		return -ENOTTY;
-	pci_read_config_byte(dev, cappos + PCI_AF_CAP, &cap);
+
+	pci_read_config_byte(dev, pos + PCI_AF_CAP, &cap);
 	if (!(cap & PCI_AF_CAP_TP) || !(cap & PCI_AF_CAP_FLR))
 		return -ENOTTY;
 
 	if (probe)
 		return 0;
 
-	pci_block_user_cfg_access(dev);
-
 	/* Wait for Transaction Pending bit clean */
-	pci_read_config_byte(dev, cappos + PCI_AF_STATUS, &status);
-	if (!(status & PCI_AF_STATUS_TP))
-		goto transaction_done;
+	for (i = 0; i < 4; i++) {
+		if (i)
+			msleep((1 << (i - 1)) * 100);
+
+		pci_read_config_byte(dev, pos + PCI_AF_STATUS, &status);
+		if (!(status & PCI_AF_STATUS_TP))
+			goto clear;
+	}
+
+	dev_err(&dev->dev, "transaction is not cleared; "
+			"proceeding with reset anyway\n");
 
+clear:
+	pci_write_config_byte(dev, pos + PCI_AF_CTRL, PCI_AF_CTRL_FLR);
 	msleep(100);
-	pci_read_config_byte(dev, cappos + PCI_AF_STATUS, &status);
-	if (!(status & PCI_AF_STATUS_TP))
-		goto transaction_done;
-
-	dev_info(&dev->dev, "Busy after 100ms while trying to"
-			" reset; sleeping for 1 second\n");
-	ssleep(1);
-	pci_read_config_byte(dev, cappos + PCI_AF_STATUS, &status);
-	if (status & PCI_AF_STATUS_TP)
-		dev_info(&dev->dev, "Still busy after 1s; "
-				"proceeding with reset anyway\n");
-
-transaction_done:
-	pci_write_config_byte(dev, cappos + PCI_AF_CTRL, PCI_AF_CTRL_FLR);
-	mdelay(100);
-
-	pci_unblock_user_cfg_access(dev);
+
 	return 0;
 }
 
-static int __pci_reset_function(struct pci_dev *pdev, int probe)
+static int pci_dev_reset(struct pci_dev *dev, int probe)
 {
-	int res;
+	int rc;
+
+	might_sleep();
+
+	if (!probe) {
+		pci_block_user_cfg_access(dev);
+		/* block PM suspend, driver probe, etc. */
+		down(&dev->dev.sem);
+	}
 
-	res = __pcie_flr(pdev, probe);
-	if (res != -ENOTTY)
-		return res;
+	rc = pcie_flr(dev, probe);
+	if (rc != -ENOTTY)
+		goto done;
 
-	res = __pci_af_flr(pdev, probe);
-	if (res != -ENOTTY)
-		return res;
+	rc = pci_af_flr(dev, probe);
+done:
+	if (!probe) {
+		up(&dev->dev.sem);
+		pci_unblock_user_cfg_access(dev);
+	}
 
-	return res;
+	return rc;
 }
 
 /**
- * pci_execute_reset_function() - Reset a PCI device function
- * @dev: Device function to reset
+ * __pci_reset_function - reset a PCI device function
+ * @dev: PCI device to reset
  *
  * Some devices allow an individual function to be reset without affecting
  * other functions in the same device.  The PCI device must be responsive
@@ -2171,18 +2172,18 @@ static int __pci_reset_function(struct pci_dev *pdev, int probe)
  * device including MSI, bus mastering, BARs, decoding IO and memory spaces,
  * etc.
  *
- * Returns 0 if the device function was successfully reset or -ENOTTY if the
+ * Returns 0 if the device function was successfully reset or negative if the
  * device doesn't support resetting a single function.
  */
-int pci_execute_reset_function(struct pci_dev *dev)
+int __pci_reset_function(struct pci_dev *dev)
 {
-	return __pci_reset_function(dev, 0);
+	return pci_dev_reset(dev, 0);
 }
-EXPORT_SYMBOL_GPL(pci_execute_reset_function);
+EXPORT_SYMBOL_GPL(__pci_reset_function);
 
 /**
- * pci_reset_function() - quiesce and reset a PCI device function
- * @dev: Device function to reset
+ * pci_reset_function - quiesce and reset a PCI device function
+ * @dev: PCI device to reset
  *
  * Some devices allow an individual function to be reset without affecting
  * other functions in the same device.  The PCI device must be responsive
@@ -2190,32 +2191,33 @@ EXPORT_SYMBOL_GPL(pci_execute_reset_function);
  *
  * This function does not just reset the PCI portion of a device, but
  * clears all the state associated with the device.  This function differs
- * from pci_execute_reset_function in that it saves and restores device state
+ * from __pci_reset_function in that it saves and restores device state
  * over the reset.
  *
- * Returns 0 if the device function was successfully reset or -ENOTTY if the
+ * Returns 0 if the device function was successfully reset or negative if the
  * device doesn't support resetting a single function.
  */
 int pci_reset_function(struct pci_dev *dev)
 {
-	int r = __pci_reset_function(dev, 1);
+	int rc;
 
-	if (r < 0)
-		return r;
+	rc = pci_dev_reset(dev, 1);
+	if (rc)
+		return rc;
 
-	if (!dev->msi_enabled && !dev->msix_enabled && dev->irq != 0)
-		disable_irq(dev->irq);
 	pci_save_state(dev);
 
+	/*
+	 * both INTx and MSI are disabled after the Interrupt Disable bit
+	 * is set and the Bus Master bit is cleared.
+	 */
 	pci_write_config_word(dev, PCI_COMMAND, PCI_COMMAND_INTX_DISABLE);
 
-	r = pci_execute_reset_function(dev);
+	rc = pci_dev_reset(dev, 0);
 
 	pci_restore_state(dev);
-	if (!dev->msi_enabled && !dev->msix_enabled && dev->irq != 0)
-		enable_irq(dev->irq);
 
-	return r;
+	return rc;
 }
 EXPORT_SYMBOL_GPL(pci_reset_function);
 

commit 1eb3948716f68bdb71509d0175765295f1aca23d
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Tue May 26 16:08:36 2009 +0900

    PCI: use pci_is_root_bus() in pci_common_swizzle()
    
    Use pci_is_root_bus() in pci_common_swizzle() for checking if the pci
    bus is root, for code consistency.
    
    Reviewed-by: Alex Chiang <achiang@hp.com>
    Reviewed-by: Grant Grundler <grundler@parisc-linux.org>
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 70b3b44a8b6c..8ea911e55722 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1549,7 +1549,7 @@ u8 pci_common_swizzle(struct pci_dev *dev, u8 *pinp)
 {
 	u8 pin = *pinp;
 
-	while (dev->bus->parent) {
+	while (!pci_is_root_bus(dev->bus)) {
 		pin = pci_swizzle_interrupt_pin(dev, pin);
 		dev = dev->bus->self;
 	}

commit 8784fd4d497171882319e4b513f5a5949fc8ab43
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Tue May 26 16:07:33 2009 +0900

    PCI: use pci_is_root_bus() in pci_get_interrupt_pin()
    
    Use pci_is_root_bus() in pci_get_interrupt_pin() for checking if the
    pci bus is root, for code consistency.
    
    Reviewed-by: Alex Chiang <achiang@hp.com>
    Reviewed-by: Grant Grundler <grundler@parisc-linux.org>
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 56fb18d2cb52..70b3b44a8b6c 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1529,7 +1529,7 @@ pci_get_interrupt_pin(struct pci_dev *dev, struct pci_dev **bridge)
 	if (!pin)
 		return -1;
 
-	while (dev->bus->parent) {
+	while (!pci_is_root_bus(dev->bus)) {
 		pin = pci_swizzle_interrupt_pin(dev, pin);
 		dev = dev->bus->self;
 	}

commit 00240c3839d843ccf07abd52806f421f7b87bbdc
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Apr 27 13:33:16 2009 -0400

    PCI: add power-state name strings
    
    This patch (as1235) adds an array of PCI power-state names, together
    with a simple inline accessor routine.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 1a91bf9687af..07bbb9b3b93f 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -24,6 +24,11 @@
 #include <asm/setup.h>
 #include "pci.h"
 
+const char *pci_power_names[] = {
+	"error", "D0", "D1", "D2", "D3hot", "D3cold", "unknown",
+};
+EXPORT_SYMBOL_GPL(pci_power_names);
+
 unsigned int pci_pm_d3_delay = PCI_PM_D3_WAIT;
 
 #ifdef CONFIG_PCI_DOMAINS

commit 43c16408842b0eeb367c23a6fa540ce69f99e347
Author: Andrew Patterson <andrew.patterson@hp.com>
Date:   Wed Apr 22 16:52:09 2009 -0600

    PCI: Add support for turning PCIe ECRC on or off
    
    Adds support for PCI Express transaction layer end-to-end CRC checking
    (ECRC).  This patch will enable/disable ECRC checking by setting/clearing
    the ECRC Check Enable and/or ECRC Generation Enable bits for devices that
    support ECRC.
    
    The ECRC setting is controlled by the "pci=ecrc=<policy>" command-line
    option. If this option is not set or is set to 'bios", the enable and
    generation bits are left in whatever state that firmware/BIOS set them to.
    The "off" setting turns them off, and the "on" option turns them on (if the
    device supports it).
    
    Turning ECRC on or off can be a data integrity versus performance
    tradeoff.  In theory, turning it on will catch more data errors, turning
    it off means possibly better performance since CRC does not need to be
    calculated by the PCIe hardware and packet sizes are reduced.
    
    Signed-off-by: Andrew Patterson <andrew.patterson@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 761557688b18..56fb18d2cb52 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2588,6 +2588,8 @@ static int __init pci_setup(char *str)
 			} else if (!strncmp(str, "resource_alignment=", 19)) {
 				pci_set_resource_alignment_param(str + 19,
 							strlen(str + 19));
+			} else if (!strncmp(str, "ecrc=", 5)) {
+				pcie_ecrc_get_policy(str + 5);
 			} else {
 				printk(KERN_ERR "PCI: Unknown option `%s'\n",
 						str);

commit f62795f1e892ca9269849fa83de97621da7e02c0
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon May 18 22:51:12 2009 +0200

    PCI PM: Follow PCI_PM_CTRL_NO_SOFT_RESET during transitions from D3
    
    According to the PCI PM specification (PCI Bus Power Management
    Interface Specification, Rev. 1.2, Section 5.4.1) we are supposed to
    reinitialize devices that have PCI_PM_CTRL_NO_SOFT_RESET clear during
    all transitions from PCI_D3hot to PCI_D0, but we only do it if the
    device's current_state field is equal to PCI_UNKNOWN.
    
    This may lead to problems if a device with PCI_PM_CTRL_NO_SOFT_RESET
    unset is put into PCI_D3hot at run time by its driver and
    pci_set_power_state() is used to put it back into PCI_D0, because in
    that case the device will remain uninitialized after
    pci_set_power_state() has returned.  Prevent that from happening by
    modifying pci_raw_set_power_state() to reinitialize devices with
    PCI_PM_CTRL_NO_SOFT_RESET unset during all transitions from D3 to D0.
    
    Cc: stable@kernel.org
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 1a91bf9687af..761557688b18 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -480,6 +480,8 @@ static int pci_raw_set_power_state(struct pci_dev *dev, pci_power_t state)
 		pmcsr &= ~PCI_PM_CTRL_STATE_MASK;
 		pmcsr |= state;
 		break;
+	case PCI_D3hot:
+	case PCI_D3cold:
 	case PCI_UNKNOWN: /* Boot-up */
 		if ((pmcsr & PCI_PM_CTRL_STATE_MASK) == PCI_D3hot
 		 && !(pmcsr & PCI_PM_CTRL_NO_SOFT_RESET))

commit b3bad72e494fb2ff0c81be4ca2ddb94adf6a47c2
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun May 17 20:17:06 2009 +0200

    PCI PM: Fix initialization and kexec breakage for some devices
    
    Recent PCI PM changes introduced a bug that causes some devices to be
    mishandled after kexec and during early initialization.  The failure
    scenario in the kexec case is the following:
    
    * Assume a PCI device is not power-manageable by the platform and has
      PCI_PM_CTRL_NO_SOFT_RESET set in PMCSR.
    * The device is put into D3 before kexec (using the native PCI PM).
    * After kexec, pci_setup_device() sets the device's power state to
      PCI_UNKNOWN.
    * pci_set_power_state(dev, PCI_D0) is called by the device's driver.
    * __pci_start_power_transition(dev, PCI_D0) is called and since the
      device is not power-manageable by the platform, it causes
      pci_update_current_state(dev, PCI_D0) to be called.  As a result
      the device's current_state field is updated to PCI_D3, in
      accordance with the contents of its PCI PM registers.
    * pci_raw_set_power_state() is called and it changes the device power
      state to D0.  *However*, it should also call pci_restore_bars() to
      reinitialize the device, but it doesn't, because the device's
      current_state field has been modified earlier.
    
    To prevent this from happening, modify pci_platform_power_transition()
    so that it doesn't use pci_update_current_state() to update the
    current_state field for devices that aren't power-manageable by the
    platform.  Instead, this field should be updated directly for devices
    that don't support the native PCI PM.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 34bf0fdf5047..1a91bf9687af 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -557,7 +557,8 @@ static int pci_platform_power_transition(struct pci_dev *dev, pci_power_t state)
 	} else {
 		error = -ENODEV;
 		/* Fall back to PCI_D0 if native PM is not supported */
-		pci_update_current_state(dev, PCI_D0);
+		if (!dev->pm_cap)
+			dev->current_state = PCI_D0;
 	}
 
 	return error;

commit 1b6b8ce2ac372ea1f2065b89228ede105eb68dc5
Author: Yu Zhao <yu.zhao@intel.com>
Date:   Thu Apr 9 14:57:39 2009 +0800

    PCI: only save/restore existent registers in the PCIe capability
    
    PCIe 1.1 base neither requires the endpoint to implement the entire
    PCIe capability structure nor specifies default values of registers
    that are not implemented by the device. So we only save and restore
    registers that must be implemented by different device types if the
    device PCIe capability version is 1.
    
    PCIe 1.1 Capability Structure Expansion ECN and PCIe 2.0 requires
    all registers in the PCIe capability to be either implemented or
    hardwired to 0. Their PCIe capability version is 2.
    
    Signed-off-by: Yu Zhao <yu.zhao@intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 16fd0d4c3166..34bf0fdf5047 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -681,11 +681,34 @@ EXPORT_SYMBOL(pci_choose_state);
 
 #define PCI_EXP_SAVE_REGS	7
 
+#define pcie_cap_has_devctl(type, flags)	1
+#define pcie_cap_has_lnkctl(type, flags)		\
+		((flags & PCI_EXP_FLAGS_VERS) > 1 ||	\
+		 (type == PCI_EXP_TYPE_ROOT_PORT ||	\
+		  type == PCI_EXP_TYPE_ENDPOINT ||	\
+		  type == PCI_EXP_TYPE_LEG_END))
+#define pcie_cap_has_sltctl(type, flags)		\
+		((flags & PCI_EXP_FLAGS_VERS) > 1 ||	\
+		 ((type == PCI_EXP_TYPE_ROOT_PORT) ||	\
+		  (type == PCI_EXP_TYPE_DOWNSTREAM &&	\
+		   (flags & PCI_EXP_FLAGS_SLOT))))
+#define pcie_cap_has_rtctl(type, flags)			\
+		((flags & PCI_EXP_FLAGS_VERS) > 1 ||	\
+		 (type == PCI_EXP_TYPE_ROOT_PORT ||	\
+		  type == PCI_EXP_TYPE_RC_EC))
+#define pcie_cap_has_devctl2(type, flags)		\
+		((flags & PCI_EXP_FLAGS_VERS) > 1)
+#define pcie_cap_has_lnkctl2(type, flags)		\
+		((flags & PCI_EXP_FLAGS_VERS) > 1)
+#define pcie_cap_has_sltctl2(type, flags)		\
+		((flags & PCI_EXP_FLAGS_VERS) > 1)
+
 static int pci_save_pcie_state(struct pci_dev *dev)
 {
 	int pos, i = 0;
 	struct pci_cap_saved_state *save_state;
 	u16 *cap;
+	u16 flags;
 
 	pos = pci_find_capability(dev, PCI_CAP_ID_EXP);
 	if (pos <= 0)
@@ -698,13 +721,22 @@ static int pci_save_pcie_state(struct pci_dev *dev)
 	}
 	cap = (u16 *)&save_state->data[0];
 
-	pci_read_config_word(dev, pos + PCI_EXP_DEVCTL, &cap[i++]);
-	pci_read_config_word(dev, pos + PCI_EXP_LNKCTL, &cap[i++]);
-	pci_read_config_word(dev, pos + PCI_EXP_SLTCTL, &cap[i++]);
-	pci_read_config_word(dev, pos + PCI_EXP_RTCTL, &cap[i++]);
-	pci_read_config_word(dev, pos + PCI_EXP_DEVCTL2, &cap[i++]);
-	pci_read_config_word(dev, pos + PCI_EXP_LNKCTL2, &cap[i++]);
-	pci_read_config_word(dev, pos + PCI_EXP_SLTCTL2, &cap[i++]);
+	pci_read_config_word(dev, pos + PCI_EXP_FLAGS, &flags);
+
+	if (pcie_cap_has_devctl(dev->pcie_type, flags))
+		pci_read_config_word(dev, pos + PCI_EXP_DEVCTL, &cap[i++]);
+	if (pcie_cap_has_lnkctl(dev->pcie_type, flags))
+		pci_read_config_word(dev, pos + PCI_EXP_LNKCTL, &cap[i++]);
+	if (pcie_cap_has_sltctl(dev->pcie_type, flags))
+		pci_read_config_word(dev, pos + PCI_EXP_SLTCTL, &cap[i++]);
+	if (pcie_cap_has_rtctl(dev->pcie_type, flags))
+		pci_read_config_word(dev, pos + PCI_EXP_RTCTL, &cap[i++]);
+	if (pcie_cap_has_devctl2(dev->pcie_type, flags))
+		pci_read_config_word(dev, pos + PCI_EXP_DEVCTL2, &cap[i++]);
+	if (pcie_cap_has_lnkctl2(dev->pcie_type, flags))
+		pci_read_config_word(dev, pos + PCI_EXP_LNKCTL2, &cap[i++]);
+	if (pcie_cap_has_sltctl2(dev->pcie_type, flags))
+		pci_read_config_word(dev, pos + PCI_EXP_SLTCTL2, &cap[i++]);
 
 	return 0;
 }
@@ -714,6 +746,7 @@ static void pci_restore_pcie_state(struct pci_dev *dev)
 	int i = 0, pos;
 	struct pci_cap_saved_state *save_state;
 	u16 *cap;
+	u16 flags;
 
 	save_state = pci_find_saved_cap(dev, PCI_CAP_ID_EXP);
 	pos = pci_find_capability(dev, PCI_CAP_ID_EXP);
@@ -721,13 +754,22 @@ static void pci_restore_pcie_state(struct pci_dev *dev)
 		return;
 	cap = (u16 *)&save_state->data[0];
 
-	pci_write_config_word(dev, pos + PCI_EXP_DEVCTL, cap[i++]);
-	pci_write_config_word(dev, pos + PCI_EXP_LNKCTL, cap[i++]);
-	pci_write_config_word(dev, pos + PCI_EXP_SLTCTL, cap[i++]);
-	pci_write_config_word(dev, pos + PCI_EXP_RTCTL, cap[i++]);
-	pci_write_config_word(dev, pos + PCI_EXP_DEVCTL2, cap[i++]);
-	pci_write_config_word(dev, pos + PCI_EXP_LNKCTL2, cap[i++]);
-	pci_write_config_word(dev, pos + PCI_EXP_SLTCTL2, cap[i++]);
+	pci_read_config_word(dev, pos + PCI_EXP_FLAGS, &flags);
+
+	if (pcie_cap_has_devctl(dev->pcie_type, flags))
+		pci_write_config_word(dev, pos + PCI_EXP_DEVCTL, cap[i++]);
+	if (pcie_cap_has_lnkctl(dev->pcie_type, flags))
+		pci_write_config_word(dev, pos + PCI_EXP_LNKCTL, cap[i++]);
+	if (pcie_cap_has_sltctl(dev->pcie_type, flags))
+		pci_write_config_word(dev, pos + PCI_EXP_SLTCTL, cap[i++]);
+	if (pcie_cap_has_rtctl(dev->pcie_type, flags))
+		pci_write_config_word(dev, pos + PCI_EXP_RTCTL, cap[i++]);
+	if (pcie_cap_has_devctl2(dev->pcie_type, flags))
+		pci_write_config_word(dev, pos + PCI_EXP_DEVCTL2, cap[i++]);
+	if (pcie_cap_has_lnkctl2(dev->pcie_type, flags))
+		pci_write_config_word(dev, pos + PCI_EXP_LNKCTL2, cap[i++]);
+	if (pcie_cap_has_sltctl2(dev->pcie_type, flags))
+		pci_write_config_word(dev, pos + PCI_EXP_SLTCTL2, cap[i++]);
 }
 
 

commit 296ccb086dfb89b5b8d73ef08c795ffdff12a597
Author: Yuji Shimada <shimada-yxb@necst.nec.co.jp>
Date:   Fri Apr 3 16:41:46 2009 +0900

    PCI: Setup disabled bridges even if buses are added
    
    This patch sets up disabled bridges even if buses have already been
    added.
    
    pci_assign_unassigned_resources is called after buses are added.
    pci_assign_unassigned_resources calls pci_bus_assign_resources.
    pci_bus_assign_resources calls pci_setup_bridge to configure BARs of
    bridges.
    
    Currently pci_setup_bridge returns immediately if the bus have already
    been added. So pci_assign_unassigned_resources can't configure BARs of
    bridges that were added in a disabled state; this patch fixes the issue.
    
    On logical hot-add, we need to prevent the kernel from re-initializing
    bridges that have already been initialized. To achieve this,
    pci_setup_bridge returns immediately if the bridge have already been
    enabled.
    
    We don't need to check whether the specified bus is a root bus or not.
    pci_setup_bridge is not called on a root bus, because a root bus does
    not have a bridge.
    
    The patch adds a new helper function, pci_is_enabled. I made the
    function name similar to pci_is_managed. The codes which use
    enable_cnt directly are changed to use pci_is_enabled.
    
    Acked-by: Alex Chiang <achiang@hp.com>
    Signed-off-by: Yuji Shimada <shimada-yxb@necst.nec.co.jp>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 445fb6f7ea3f..16fd0d4c3166 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -844,7 +844,7 @@ static int do_pci_enable_device(struct pci_dev *dev, int bars)
  */
 int pci_reenable_device(struct pci_dev *dev)
 {
-	if (atomic_read(&dev->enable_cnt))
+	if (pci_is_enabled(dev))
 		return do_pci_enable_device(dev, (1 << PCI_NUM_RESOURCES) - 1);
 	return 0;
 }
@@ -1042,7 +1042,7 @@ static void do_pci_disable_device(struct pci_dev *dev)
  */
 void pci_disable_enabled_device(struct pci_dev *dev)
 {
-	if (atomic_read(&dev->enable_cnt))
+	if (pci_is_enabled(dev))
 		do_pci_disable_device(dev);
 }
 

commit 811158b147a503fbdf9773224004ffd32002d1fe
Merge: 4e76c5ccd5ac b26e0ed4936b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Apr 3 15:24:35 2009 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial: (28 commits)
      trivial: Update my email address
      trivial: NULL noise: drivers/mtd/tests/mtd_*test.c
      trivial: NULL noise: drivers/media/dvb/frontends/drx397xD_fw.h
      trivial: Fix misspelling of "Celsius".
      trivial: remove unused variable 'path' in alloc_file()
      trivial: fix a pdlfush -> pdflush typo in comment
      trivial: jbd header comment typo fix for JBD_PARANOID_IOFAIL
      trivial: wusb: Storage class should be before const qualifier
      trivial: drivers/char/bsr.c: Storage class should be before const qualifier
      trivial: h8300: Storage class should be before const qualifier
      trivial: fix where cgroup documentation is not correctly referred to
      trivial: Give the right path in Documentation example
      trivial: MTD: remove EOL from MODULE_DESCRIPTION
      trivial: Fix typo in bio_split()'s documentation
      trivial: PWM: fix of #endif comment
      trivial: fix typos/grammar errors in Kconfig texts
      trivial: Fix misspelling of firmware
      trivial: cgroups: documentation typo and spelling corrections
      trivial: Update contact info for Jochen Hein
      trivial: fix typo "resgister" -> "register"
      ...

commit e76e5b2c663ac74ae6a542ac20795c625e36a5cd
Merge: 32527bc0e4b4 eeafda70bf28
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Apr 1 09:47:12 2009 -0700

    Merge branch 'linux-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jbarnes/pci-2.6
    
    * 'linux-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jbarnes/pci-2.6: (88 commits)
      PCI: fix HT MSI mapping fix
      PCI: don't enable too much HT MSI mapping
      x86/PCI: make pci=lastbus=255 work when acpi is on
      PCI: save and restore PCIe 2.0 registers
      PCI: update fakephp for bus_id removal
      PCI: fix kernel oops on bridge removal
      PCI: fix conflict between SR-IOV and config space sizing
      powerpc/PCI: include pci.h in powerpc MSI implementation
      PCI Hotplug: schedule fakephp for feature removal
      PCI Hotplug: rename legacy_fakephp to fakephp
      PCI Hotplug: restore fakephp interface with complete reimplementation
      PCI: Introduce /sys/bus/pci/devices/.../rescan
      PCI: Introduce /sys/bus/pci/devices/.../remove
      PCI: Introduce /sys/bus/pci/rescan
      PCI: Introduce pci_rescan_bus()
      PCI: do not enable bridges more than once
      PCI: do not initialize bridges more than once
      PCI: always scan child buses
      PCI: pci_scan_slot() returns newly found devices
      PCI: don't scan existing devices
      ...
    
    Fix trivial append-only conflict in Documentation/feature-removal-schedule.txt

commit 8efb8c76fcdccf5050c0ea059dac392789baaff2
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Mar 30 21:46:27 2009 +0200

    PCI PM: Make pci_prepare_to_sleep() disable wake-up if needed
    
    If the device is not supposed to wake up the system, ie. when
    device_may_wakeup(&dev->dev) returns 'false', pci_prepare_to_sleep()
    should pass 'false' to pci_enable_wake() so that it calls the
    platform to disable the wake-up capability of the device.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index de54fd643baf..0195066251e5 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1263,7 +1263,7 @@ int pci_prepare_to_sleep(struct pci_dev *dev)
 	if (target_state == PCI_POWER_ERROR)
 		return -EIO;
 
-	pci_enable_wake(dev, target_state, true);
+	pci_enable_wake(dev, target_state, device_may_wakeup(&dev->dev));
 
 	error = pci_set_power_state(dev, target_state);
 

commit 0e5dd46b761195356065a30611f265adec286d0d
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Mar 26 22:51:40 2009 +0100

    PCI PM: Introduce __pci_[start|complete]_power_transition() (rev. 2)
    
    The radeonfb driver needs to program the device's PMCSR directly due
    to some quirky hardware it has to handle (see
    http://bugzilla.kernel.org/show_bug.cgi?id=12846 for details) and
    after doing that it needs to call the platform (usually ACPI) to
    finish the power transition of the device.  Currently it uses
    pci_set_power_state() for this purpose, however making a specific
    assumption about the internal behavior of this function, which has
    changed recently so that this assumption is no longer satisfied.
    For this reason, introduce __pci_complete_power_transition() that may
    be called by the radeonfb driver to complete the power transition of
    the device.  For symmetry, introduce __pci_start_power_transition().
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 979ceb1d37e8..de54fd643baf 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -539,6 +539,53 @@ void pci_update_current_state(struct pci_dev *dev, pci_power_t state)
 	}
 }
 
+/**
+ * pci_platform_power_transition - Use platform to change device power state
+ * @dev: PCI device to handle.
+ * @state: State to put the device into.
+ */
+static int pci_platform_power_transition(struct pci_dev *dev, pci_power_t state)
+{
+	int error;
+
+	if (platform_pci_power_manageable(dev)) {
+		error = platform_pci_set_power_state(dev, state);
+		if (!error)
+			pci_update_current_state(dev, state);
+	} else {
+		error = -ENODEV;
+		/* Fall back to PCI_D0 if native PM is not supported */
+		pci_update_current_state(dev, PCI_D0);
+	}
+
+	return error;
+}
+
+/**
+ * __pci_start_power_transition - Start power transition of a PCI device
+ * @dev: PCI device to handle.
+ * @state: State to put the device into.
+ */
+static void __pci_start_power_transition(struct pci_dev *dev, pci_power_t state)
+{
+	if (state == PCI_D0)
+		pci_platform_power_transition(dev, PCI_D0);
+}
+
+/**
+ * __pci_complete_power_transition - Complete power transition of a PCI device
+ * @dev: PCI device to handle.
+ * @state: State to put the device into.
+ *
+ * This function should not be called directly by device drivers.
+ */
+int __pci_complete_power_transition(struct pci_dev *dev, pci_power_t state)
+{
+	return state > PCI_D0 ?
+			pci_platform_power_transition(dev, state) : -EINVAL;
+}
+EXPORT_SYMBOL_GPL(__pci_complete_power_transition);
+
 /**
  * pci_set_power_state - Set the power state of a PCI device
  * @dev: PCI device to handle.
@@ -575,16 +622,8 @@ int pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 	if (dev->current_state == state)
 		return 0;
 
-	if (state == PCI_D0) {
-		/*
-		 * Allow the platform to change the state, for example via ACPI
-		 * _PR0, _PS0 and some such, but do not trust it.
-		 */
-		int ret = platform_pci_power_manageable(dev) ?
-			platform_pci_set_power_state(dev, PCI_D0) : 0;
-		if (!ret)
-			pci_update_current_state(dev, PCI_D0);
-	}
+	__pci_start_power_transition(dev, state);
+
 	/* This device is quirked not to be put into D3, so
 	   don't put it in D3 */
 	if (state == PCI_D3hot && (dev->dev_flags & PCI_DEV_FLAGS_NO_D3))
@@ -592,14 +631,8 @@ int pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 
 	error = pci_raw_set_power_state(dev, state);
 
-	if (state > PCI_D0 && platform_pci_power_manageable(dev)) {
-		/* Allow the platform to finalize the transition */
-		int ret = platform_pci_set_power_state(dev, state);
-		if (!ret) {
-			pci_update_current_state(dev, state);
-			error = 0;
-		}
-	}
+	if (!__pci_complete_power_transition(dev, state))
+		error = 0;
 
 	return error;
 }

commit 4a865905f685eaefaedf6ade362323dc52aa703b
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Mar 16 22:40:36 2009 +0100

    PCI PM: Make pci_set_power_state() handle devices with no PM support
    
    There is a problem with PCI devices without any PM support (either
    native or through the platform) that pci_set_power_state() always
    returns error code for them, even if they are being put into D0.
    However, such devices are always in D0, so pci_set_power_state()
    should return success when attempting to put such a device into D0.
    It also should update the current_state field for these devices as
    appropriate.  This modification is necessary so that the standard
    configuration registers of these devices are successfully restored by
    pci_restore_standard_config() during the "early" phase of resume.
    
    In addition, pci_set_power_state() should check the value of
    current_state before calling the platform to change the power state
    of the device to avoid doing that unnecessarily.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Ingo Molnar <mingo@elte.hu>
    Acked-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index a4ecc2f15126..979ceb1d37e8 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -439,6 +439,10 @@ static int pci_raw_set_power_state(struct pci_dev *dev, pci_power_t state)
 	u16 pmcsr;
 	bool need_restore = false;
 
+	/* Check if we're already there */
+	if (dev->current_state == state)
+		return 0;
+
 	if (!dev->pm_cap)
 		return -EIO;
 
@@ -449,10 +453,7 @@ static int pci_raw_set_power_state(struct pci_dev *dev, pci_power_t state)
 	 * Can enter D0 from any state, but if we can only go deeper 
 	 * to sleep if we're already in a low power state
 	 */
-	if (dev->current_state == state) {
-		/* we're already there */
-		return 0;
-	} else if (state != PCI_D0 && dev->current_state <= PCI_D3cold
+	if (state != PCI_D0 && dev->current_state <= PCI_D3cold
 	    && dev->current_state > state) {
 		dev_err(&dev->dev, "invalid power transition "
 			"(from state %d to %d)\n", dev->current_state, state);
@@ -570,12 +571,17 @@ int pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 		 */
 		return 0;
 
-	if (state == PCI_D0 && platform_pci_power_manageable(dev)) {
+	/* Check if we're already there */
+	if (dev->current_state == state)
+		return 0;
+
+	if (state == PCI_D0) {
 		/*
 		 * Allow the platform to change the state, for example via ACPI
 		 * _PR0, _PS0 and some such, but do not trust it.
 		 */
-		int ret = platform_pci_set_power_state(dev, PCI_D0);
+		int ret = platform_pci_power_manageable(dev) ?
+			platform_pci_set_power_state(dev, PCI_D0) : 0;
 		if (!ret)
 			pci_update_current_state(dev, PCI_D0);
 	}

commit 0128a89cf75124500b5b69f0c3c7b7c5aa60676f
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Mar 16 22:40:18 2009 +0100

    PCI PM: Move pci_restore_standard_config to pci-driver.c
    
    Move pci_restore_standard_config() from pci.c to pci-driver.c and
    make it static.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Ingo Molnar <mingo@elte.hu>
    Acked-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 3acb1da296d5..a4ecc2f15126 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1373,27 +1373,6 @@ void pci_allocate_cap_save_buffers(struct pci_dev *dev)
 			"unable to preallocate PCI-X save buffer\n");
 }
 
-/**
- * pci_restore_standard_config - restore standard config registers of PCI device
- * @dev: PCI device to handle
- *
- * This function assumes that the device's configuration space is accessible.
- * If the device needs to be powered up, the function will wait for it to
- * change the state.
- */
-int pci_restore_standard_config(struct pci_dev *dev)
-{
-	pci_update_current_state(dev, PCI_UNKNOWN);
-
-	if (dev->current_state != PCI_D0) {
-		int error = pci_set_power_state(dev, PCI_D0);
-		if (error)
-			return error;
-	}
-
-	return dev->state_saved ? pci_restore_state(dev) : 0;
-}
-
 /**
  * pci_enable_ari - enable ARI forwarding if hardware support it
  * @dev: the PCI device

commit f00a20ef46b1795c495869163a9a7333f899713a
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Mar 16 22:40:08 2009 +0100

    PCI PM: Use pci_set_power_state during early resume
    
    Once we have allowed timer interrupts to be enabled during the early
    phase of resuming devices, we are now able to use the generic
    pci_set_power_state() to put PCI devices into D0 at that time.  Then,
    the platform-specific PM code will have a chance to handle devices
    that don't implement the native PCI PM or that require some
    additional, platform-specific operations to be carried out to power
    them up.  Also, by doing this we can simplify the code quite a bit.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Ingo Molnar <mingo@elte.hu>
    Acked-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 6d6120007af4..3acb1da296d5 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -426,7 +426,6 @@ static inline int platform_pci_sleep_wake(struct pci_dev *dev, bool enable)
  *                           given PCI device
  * @dev: PCI device to handle.
  * @state: PCI power state (D0, D1, D2, D3hot) to put the device into.
- * @wait: If 'true', wait for the device to change its power state
  *
  * RETURN VALUE:
  * -EINVAL if the requested state is invalid.
@@ -435,8 +434,7 @@ static inline int platform_pci_sleep_wake(struct pci_dev *dev, bool enable)
  * 0 if device already is in the requested state.
  * 0 if device's power state has been successfully changed.
  */
-static int
-pci_raw_set_power_state(struct pci_dev *dev, pci_power_t state, bool wait)
+static int pci_raw_set_power_state(struct pci_dev *dev, pci_power_t state)
 {
 	u16 pmcsr;
 	bool need_restore = false;
@@ -481,10 +479,8 @@ pci_raw_set_power_state(struct pci_dev *dev, pci_power_t state, bool wait)
 		break;
 	case PCI_UNKNOWN: /* Boot-up */
 		if ((pmcsr & PCI_PM_CTRL_STATE_MASK) == PCI_D3hot
-		 && !(pmcsr & PCI_PM_CTRL_NO_SOFT_RESET)) {
+		 && !(pmcsr & PCI_PM_CTRL_NO_SOFT_RESET))
 			need_restore = true;
-			wait = true;
-		}
 		/* Fall-through: force to D0 */
 	default:
 		pmcsr = 0;
@@ -494,9 +490,6 @@ pci_raw_set_power_state(struct pci_dev *dev, pci_power_t state, bool wait)
 	/* enter specified state */
 	pci_write_config_word(dev, dev->pm_cap + PCI_PM_CTRL, pmcsr);
 
-	if (!wait)
-		return 0;
-
 	/* Mandatory power management transition delays */
 	/* see PCI PM 1.1 5.6.1 table 18 */
 	if (state == PCI_D3hot || dev->current_state == PCI_D3hot)
@@ -521,7 +514,7 @@ pci_raw_set_power_state(struct pci_dev *dev, pci_power_t state, bool wait)
 	if (need_restore)
 		pci_restore_bars(dev);
 
-	if (wait && dev->bus->self)
+	if (dev->bus->self)
 		pcie_aspm_pm_state_change(dev->bus->self);
 
 	return 0;
@@ -591,7 +584,7 @@ int pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 	if (state == PCI_D3hot && (dev->dev_flags & PCI_DEV_FLAGS_NO_D3))
 		return 0;
 
-	error = pci_raw_set_power_state(dev, state, true);
+	error = pci_raw_set_power_state(dev, state);
 
 	if (state > PCI_D0 && platform_pci_power_manageable(dev)) {
 		/* Allow the platform to finalize the transition */
@@ -1390,37 +1383,14 @@ void pci_allocate_cap_save_buffers(struct pci_dev *dev)
  */
 int pci_restore_standard_config(struct pci_dev *dev)
 {
-	pci_power_t prev_state;
-	int error;
-
-	pci_update_current_state(dev, PCI_D0);
-
-	prev_state = dev->current_state;
-	if (prev_state == PCI_D0)
-		goto Restore;
-
-	error = pci_raw_set_power_state(dev, PCI_D0, false);
-	if (error)
-		return error;
+	pci_update_current_state(dev, PCI_UNKNOWN);
 
-	/*
-	 * This assumes that we won't get a bus in B2 or B3 from the BIOS, but
-	 * we've made this assumption forever and it appears to be universally
-	 * satisfied.
-	 */
-	switch(prev_state) {
-	case PCI_D3cold:
-	case PCI_D3hot:
-		mdelay(pci_pm_d3_delay);
-		break;
-	case PCI_D2:
-		udelay(PCI_PM_D2_DELAY);
-		break;
+	if (dev->current_state != PCI_D0) {
+		int error = pci_set_power_state(dev, PCI_D0);
+		if (error)
+			return error;
 	}
 
-	pci_update_current_state(dev, PCI_D0);
-
- Restore:
 	return dev->state_saved ? pci_restore_state(dev) : 0;
 }
 

commit 877d03105d04b2c13e241130277fa69c8d2564f0
Author: Nick Andrew <nick@nick-andrew.net>
Date:   Mon Jan 26 11:06:57 2009 +0100

    trivial: Fix misspelling of firmware
    
    Fix misspelling of firmware.
    
    Signed-off-by: Nick Andrew <nick@nick-andrew.net>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 6d6120007af4..dab33a21d49a 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -550,7 +550,7 @@ void pci_update_current_state(struct pci_dev *dev, pci_power_t state)
  * @dev: PCI device to handle.
  * @state: PCI power state (D0, D1, D2, D3hot) to put the device into.
  *
- * Transition a device to a new power state, using the platform formware and/or
+ * Transition a device to a new power state, using the platform firmware and/or
  * the device's PCI PM registers.
  *
  * RETURN VALUE:

commit 898585172fa729513d8636257b44bd1cfd279096
Author: Yu Zhao <yu.zhao@intel.com>
Date:   Mon Feb 16 02:55:47 2009 +0800

    PCI: save and restore PCIe 2.0 registers
    
    PCIe 2.0 defines several new registers (Device Control 2, Link Control 2,
    and Slot Control 2). Save and retore them in pci_save_pcie_state() and
    pci_restore_pcie_state().
    
    Signed-off-by: Yu Zhao <yu.zhao@intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 676bbcbc272b..59569b8cf1d5 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -647,6 +647,8 @@ pci_power_t pci_choose_state(struct pci_dev *dev, pm_message_t state)
 
 EXPORT_SYMBOL(pci_choose_state);
 
+#define PCI_EXP_SAVE_REGS	7
+
 static int pci_save_pcie_state(struct pci_dev *dev)
 {
 	int pos, i = 0;
@@ -668,6 +670,9 @@ static int pci_save_pcie_state(struct pci_dev *dev)
 	pci_read_config_word(dev, pos + PCI_EXP_LNKCTL, &cap[i++]);
 	pci_read_config_word(dev, pos + PCI_EXP_SLTCTL, &cap[i++]);
 	pci_read_config_word(dev, pos + PCI_EXP_RTCTL, &cap[i++]);
+	pci_read_config_word(dev, pos + PCI_EXP_DEVCTL2, &cap[i++]);
+	pci_read_config_word(dev, pos + PCI_EXP_LNKCTL2, &cap[i++]);
+	pci_read_config_word(dev, pos + PCI_EXP_SLTCTL2, &cap[i++]);
 
 	return 0;
 }
@@ -688,6 +693,9 @@ static void pci_restore_pcie_state(struct pci_dev *dev)
 	pci_write_config_word(dev, pos + PCI_EXP_LNKCTL, cap[i++]);
 	pci_write_config_word(dev, pos + PCI_EXP_SLTCTL, cap[i++]);
 	pci_write_config_word(dev, pos + PCI_EXP_RTCTL, cap[i++]);
+	pci_write_config_word(dev, pos + PCI_EXP_DEVCTL2, cap[i++]);
+	pci_write_config_word(dev, pos + PCI_EXP_LNKCTL2, cap[i++]);
+	pci_write_config_word(dev, pos + PCI_EXP_SLTCTL2, cap[i++]);
 }
 
 
@@ -1372,7 +1380,8 @@ void pci_allocate_cap_save_buffers(struct pci_dev *dev)
 {
 	int error;
 
-	error = pci_add_cap_save_buffer(dev, PCI_CAP_ID_EXP, 4 * sizeof(u16));
+	error = pci_add_cap_save_buffer(dev, PCI_CAP_ID_EXP,
+					PCI_EXP_SAVE_REGS * sizeof(u16));
 	if (error)
 		dev_err(&dev->dev,
 			"unable to preallocate PCI Express save buffer\n");

commit 8c5cdb6adc6688b9b8fd82ea4a5cf4674dabad79
Author: Yu Zhao <yu.zhao@intel.com>
Date:   Fri Mar 20 11:25:12 2009 +0800

    PCI: restore saved SR-IOV state
    
    Restore the volatile registers in the SR-IOV capability after the
    D3->D0 transition.
    
    Reviewed-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: Yu Zhao <yu.zhao@intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 2b3201ec2b05..676bbcbc272b 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -775,6 +775,7 @@ pci_restore_state(struct pci_dev *dev)
 	}
 	pci_restore_pcix_state(dev);
 	pci_restore_msi_state(dev);
+	pci_restore_iov_state(dev);
 
 	return 0;
 }

commit d1b054da8f599905f3c18a218961dcf17f9d5f13
Author: Yu Zhao <yu.zhao@intel.com>
Date:   Fri Mar 20 11:25:11 2009 +0800

    PCI: initialize and release SR-IOV capability
    
    If a device has the SR-IOV capability, initialize it (set the ARI
    Capable Hierarchy in the lowest numbered PF if necessary; calculate
    the System Page Size for the VF MMIO, probe the VF Offset, Stride
    and BARs). A lock for the VF bus allocation is also initialized if
    a PF is the lowest numbered PF.
    
    Reviewed-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: Yu Zhao <yu.zhao@intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index a35a8b2ba631..2b3201ec2b05 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2360,12 +2360,19 @@ int pci_select_bars(struct pci_dev *dev, unsigned long flags)
  */
 int pci_resource_bar(struct pci_dev *dev, int resno, enum pci_bar_type *type)
 {
+	int reg;
+
 	if (resno < PCI_ROM_RESOURCE) {
 		*type = pci_bar_unknown;
 		return PCI_BASE_ADDRESS_0 + 4 * resno;
 	} else if (resno == PCI_ROM_RESOURCE) {
 		*type = pci_bar_mem32;
 		return dev->rom_base_reg;
+	} else if (resno < PCI_BRIDGE_RESOURCES) {
+		/* device specific resource */
+		reg = pci_iov_resource_bar(dev, resno, type);
+		if (reg)
+			return reg;
 	}
 
 	dev_err(&dev->dev, "BAR: invalid resource #%d\n", resno);

commit 32a9a682bef2f6fce7026bd94d1ce20028b0e52d
Author: Yuji Shimada <shimada-yxb@necst.nec.co.jp>
Date:   Mon Mar 16 17:13:39 2009 +0900

    PCI: allow assignment of memory resources with a specified alignment
    
    This patch allows memory resources to be assigned with a specified
    alignment at boot-time or run-time. The patch is useful when we use PCI
    pass-through, because page-aligned memory resources are required to
    securely share PCI resources with guest drivers.
    
    If you want to assign the resource at boot time, please set
    "pci=resource_alignment=" boot parameter.
    
    This is format of "pci=resource_alignment=" boot parameter:
    
            [<order of align>@][<domain>:]<bus>:<slot>.<func>[; ...]
                    Specifies alignment and device to reassign
                    aligned memory resources.
                    If <order of align> is not specified, PAGE_SIZE is
                    used as alignment.
                    PCI-PCI bridge can be specified, if resource
                    windows need to be expanded.
    
    This is example:
    
            pci=resource_alignment=20@07:00.0;18@0f:00.0;00:1d.7
    
    If you want to assign the resource at run-time, please set
    "/sys/bus/pci/resource_alignment" file, and hot-remove the device and
    hot-add the device.  For this purpose, fakephp or PCI hotplug interfaces
    can be used.
    
    The format of "/sys/bus/pci/resource_alignment" file is the same with
    boot parameter. You can use "," instead of ";".
    
    For example:
    
            # cd /sys/bus/pci
            # echo -n 20@12:00.0 > resource_alignment
            # echo 1 > devices/0000:12:00.0/remove
            # echo 1 > rescan
    
    Reviewed-by: Alex Chiang <achiang@hp.com>
    Reviewed-by: Yu Zhao <yu.zhao@intel.com>
    Signed-off-by: Yuji Shimada <shimada-yxb@necst.nec.co.jp>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 8310dc2f943b..a35a8b2ba631 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -20,6 +20,8 @@
 #include <linux/pm_wakeup.h>
 #include <linux/interrupt.h>
 #include <asm/dma.h>	/* isa_dma_bridge_buggy */
+#include <linux/device.h>
+#include <asm/setup.h>
 #include "pci.h"
 
 unsigned int pci_pm_d3_delay = PCI_PM_D3_WAIT;
@@ -2370,6 +2372,121 @@ int pci_resource_bar(struct pci_dev *dev, int resno, enum pci_bar_type *type)
 	return 0;
 }
 
+#define RESOURCE_ALIGNMENT_PARAM_SIZE COMMAND_LINE_SIZE
+static char resource_alignment_param[RESOURCE_ALIGNMENT_PARAM_SIZE] = {0};
+spinlock_t resource_alignment_lock = SPIN_LOCK_UNLOCKED;
+
+/**
+ * pci_specified_resource_alignment - get resource alignment specified by user.
+ * @dev: the PCI device to get
+ *
+ * RETURNS: Resource alignment if it is specified.
+ *          Zero if it is not specified.
+ */
+resource_size_t pci_specified_resource_alignment(struct pci_dev *dev)
+{
+	int seg, bus, slot, func, align_order, count;
+	resource_size_t align = 0;
+	char *p;
+
+	spin_lock(&resource_alignment_lock);
+	p = resource_alignment_param;
+	while (*p) {
+		count = 0;
+		if (sscanf(p, "%d%n", &align_order, &count) == 1 &&
+							p[count] == '@') {
+			p += count + 1;
+		} else {
+			align_order = -1;
+		}
+		if (sscanf(p, "%x:%x:%x.%x%n",
+			&seg, &bus, &slot, &func, &count) != 4) {
+			seg = 0;
+			if (sscanf(p, "%x:%x.%x%n",
+					&bus, &slot, &func, &count) != 3) {
+				/* Invalid format */
+				printk(KERN_ERR "PCI: Can't parse resource_alignment parameter: %s\n",
+					p);
+				break;
+			}
+		}
+		p += count;
+		if (seg == pci_domain_nr(dev->bus) &&
+			bus == dev->bus->number &&
+			slot == PCI_SLOT(dev->devfn) &&
+			func == PCI_FUNC(dev->devfn)) {
+			if (align_order == -1) {
+				align = PAGE_SIZE;
+			} else {
+				align = 1 << align_order;
+			}
+			/* Found */
+			break;
+		}
+		if (*p != ';' && *p != ',') {
+			/* End of param or invalid format */
+			break;
+		}
+		p++;
+	}
+	spin_unlock(&resource_alignment_lock);
+	return align;
+}
+
+/**
+ * pci_is_reassigndev - check if specified PCI is target device to reassign
+ * @dev: the PCI device to check
+ *
+ * RETURNS: non-zero for PCI device is a target device to reassign,
+ *          or zero is not.
+ */
+int pci_is_reassigndev(struct pci_dev *dev)
+{
+	return (pci_specified_resource_alignment(dev) != 0);
+}
+
+ssize_t pci_set_resource_alignment_param(const char *buf, size_t count)
+{
+	if (count > RESOURCE_ALIGNMENT_PARAM_SIZE - 1)
+		count = RESOURCE_ALIGNMENT_PARAM_SIZE - 1;
+	spin_lock(&resource_alignment_lock);
+	strncpy(resource_alignment_param, buf, count);
+	resource_alignment_param[count] = '\0';
+	spin_unlock(&resource_alignment_lock);
+	return count;
+}
+
+ssize_t pci_get_resource_alignment_param(char *buf, size_t size)
+{
+	size_t count;
+	spin_lock(&resource_alignment_lock);
+	count = snprintf(buf, size, "%s", resource_alignment_param);
+	spin_unlock(&resource_alignment_lock);
+	return count;
+}
+
+static ssize_t pci_resource_alignment_show(struct bus_type *bus, char *buf)
+{
+	return pci_get_resource_alignment_param(buf, PAGE_SIZE);
+}
+
+static ssize_t pci_resource_alignment_store(struct bus_type *bus,
+					const char *buf, size_t count)
+{
+	return pci_set_resource_alignment_param(buf, count);
+}
+
+BUS_ATTR(resource_alignment, 0644, pci_resource_alignment_show,
+					pci_resource_alignment_store);
+
+static int __init pci_resource_alignment_sysfs_init(void)
+{
+	return bus_create_file(&pci_bus_type,
+					&bus_attr_resource_alignment);
+}
+
+late_initcall(pci_resource_alignment_sysfs_init);
+
 static void __devinit pci_no_domains(void)
 {
 #ifdef CONFIG_PCI_DOMAINS
@@ -2418,6 +2535,9 @@ static int __init pci_setup(char *str)
 				pci_cardbus_io_size = memparse(str + 9, &str);
 			} else if (!strncmp(str, "cbmemsize=", 10)) {
 				pci_cardbus_mem_size = memparse(str + 10, &str);
+			} else if (!strncmp(str, "resource_alignment=", 19)) {
+				pci_set_resource_alignment_param(str + 19,
+							strlen(str + 19));
 			} else {
 				printk(KERN_ERR "PCI: Unknown option `%s'\n",
 						str);

commit c74d724462d1845535667f4d3f720e02e3432e53
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Tue Feb 17 14:16:13 2009 +0900

    PCI: fix wrong assumption in pci_common_swizzle
    
    Current pci_common_swizzle() seems to have a assumption that
    pci_bus->self is NULL on the pci root bus. But it might not be true on
    some platforms. Because of this wrong assumption, pci_common_swizzle()
    might cause endless loop. We must check pci_bus->parent instead.
    
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 0cfed9e28ea1..8310dc2f943b 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1504,7 +1504,7 @@ u8 pci_common_swizzle(struct pci_dev *dev, u8 *pinp)
 {
 	u8 pin = *pinp;
 
-	while (dev->bus->self) {
+	while (dev->bus->parent) {
 		pin = pci_swizzle_interrupt_pin(dev, pin);
 		dev = dev->bus->self;
 	}

commit c2a3072e010943ac749794622f26b3ef54de25be
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Tue Feb 17 14:15:45 2009 +0900

    PCI: fix wrong assumption in pci_get_interrupt_pin
    
    Current pci_get_interrupt_pin() seems to have an assumption that
    pci_bus->self is NULL on the root pci bus. But it might not be true on
    some platforms. Because of this wrong assumption, current
    pci_get_interrupt_pin() might cause endless loop. We must check
    pci_bus->parent instead.
    
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 0b3e20f1b6f7..0cfed9e28ea1 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1484,7 +1484,7 @@ pci_get_interrupt_pin(struct pci_dev *dev, struct pci_dev **bridge)
 	if (!pin)
 		return -1;
 
-	while (dev->bus->self) {
+	while (dev->bus->parent) {
 		pin = pci_swizzle_interrupt_pin(dev, pin);
 		dev = dev->bus->self;
 	}

commit 5fe5db05f64d0d10b563b1c13b58e4a52b190686
Author: Sheng Yang <sheng@linux.intel.com>
Date:   Mon Feb 9 14:53:47 2009 +0800

    PCI: Speed up device reset function
    
    For all devices need to do function level reset, currently we need wait for
    at least 200ms, which can be too long if we have lots of devices...
    
    The patch checked pending bit before msleep() to skip some unnecessary
    sleeping interval.
    
    Signed-off-by: Sheng Yang <sheng@linux.intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 5737b8a9a732..0b3e20f1b6f7 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2028,18 +2028,24 @@ static int __pcie_flr(struct pci_dev *dev, int probe)
 	pci_block_user_cfg_access(dev);
 
 	/* Wait for Transaction Pending bit clean */
+	pci_read_config_word(dev, exppos + PCI_EXP_DEVSTA, &status);
+	if (!(status & PCI_EXP_DEVSTA_TRPND))
+		goto transaction_done;
+
 	msleep(100);
 	pci_read_config_word(dev, exppos + PCI_EXP_DEVSTA, &status);
-	if (status & PCI_EXP_DEVSTA_TRPND) {
-		dev_info(&dev->dev, "Busy after 100ms while trying to reset; "
+	if (!(status & PCI_EXP_DEVSTA_TRPND))
+		goto transaction_done;
+
+	dev_info(&dev->dev, "Busy after 100ms while trying to reset; "
 			"sleeping for 1 second\n");
-		ssleep(1);
-		pci_read_config_word(dev, exppos + PCI_EXP_DEVSTA, &status);
-		if (status & PCI_EXP_DEVSTA_TRPND)
-			dev_info(&dev->dev, "Still busy after 1s; "
+	ssleep(1);
+	pci_read_config_word(dev, exppos + PCI_EXP_DEVSTA, &status);
+	if (status & PCI_EXP_DEVSTA_TRPND)
+		dev_info(&dev->dev, "Still busy after 1s; "
 				"proceeding with reset anyway\n");
-	}
 
+transaction_done:
 	pci_write_config_word(dev, exppos + PCI_EXP_DEVCTL,
 				PCI_EXP_DEVCTL_BCR_FLR);
 	mdelay(100);
@@ -2066,18 +2072,24 @@ static int __pci_af_flr(struct pci_dev *dev, int probe)
 	pci_block_user_cfg_access(dev);
 
 	/* Wait for Transaction Pending bit clean */
+	pci_read_config_byte(dev, cappos + PCI_AF_STATUS, &status);
+	if (!(status & PCI_AF_STATUS_TP))
+		goto transaction_done;
+
 	msleep(100);
 	pci_read_config_byte(dev, cappos + PCI_AF_STATUS, &status);
-	if (status & PCI_AF_STATUS_TP) {
-		dev_info(&dev->dev, "Busy after 100ms while trying to"
-				" reset; sleeping for 1 second\n");
-		ssleep(1);
-		pci_read_config_byte(dev,
-				cappos + PCI_AF_STATUS, &status);
-		if (status & PCI_AF_STATUS_TP)
-			dev_info(&dev->dev, "Still busy after 1s; "
-					"proceeding with reset anyway\n");
-	}
+	if (!(status & PCI_AF_STATUS_TP))
+		goto transaction_done;
+
+	dev_info(&dev->dev, "Busy after 100ms while trying to"
+			" reset; sleeping for 1 second\n");
+	ssleep(1);
+	pci_read_config_byte(dev, cappos + PCI_AF_STATUS, &status);
+	if (status & PCI_AF_STATUS_TP)
+		dev_info(&dev->dev, "Still busy after 1s; "
+				"proceeding with reset anyway\n");
+
+transaction_done:
 	pci_write_config_byte(dev, cappos + PCI_AF_CTRL, PCI_AF_CTRL_FLR);
 	mdelay(100);
 

commit e496b617b40f2abf6d49803f56aa1344ce1b9177
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Wed Jan 7 16:22:37 2009 -0800

    PCI: __FUNCTION__ is gcc-specific, use __func__
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 6d6120007af4..5737b8a9a732 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -657,7 +657,7 @@ static int pci_save_pcie_state(struct pci_dev *dev)
 
 	save_state = pci_find_saved_cap(dev, PCI_CAP_ID_EXP);
 	if (!save_state) {
-		dev_err(&dev->dev, "buffer not found in %s\n", __FUNCTION__);
+		dev_err(&dev->dev, "buffer not found in %s\n", __func__);
 		return -ENOMEM;
 	}
 	cap = (u16 *)&save_state->data[0];
@@ -700,7 +700,7 @@ static int pci_save_pcix_state(struct pci_dev *dev)
 
 	save_state = pci_find_saved_cap(dev, PCI_CAP_ID_PCIX);
 	if (!save_state) {
-		dev_err(&dev->dev, "buffer not found in %s\n", __FUNCTION__);
+		dev_err(&dev->dev, "buffer not found in %s\n", __func__);
 		return -ENOMEM;
 	}
 

commit f5ddcac435b6c6133a9c137c345abef53b93cf55
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Fri Jan 9 17:03:20 2009 -0800

    PCI: fix missing kernel-doc and typos
    
    Fix pci kernel-doc parameter missing notation, correct
    function name, and fix typo:
    
    Warning(linux-2.6.28-git10//drivers/pci/pci.c:1511): No description found for parameter 'exclusive'
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index e3efe6b19ee7..6d6120007af4 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1540,16 +1540,21 @@ void pci_release_region(struct pci_dev *pdev, int bar)
 }
 
 /**
- *	pci_request_region - Reserved PCI I/O and memory resource
+ *	__pci_request_region - Reserved PCI I/O and memory resource
  *	@pdev: PCI device whose resources are to be reserved
  *	@bar: BAR to be reserved
  *	@res_name: Name to be associated with resource.
+ *	@exclusive: whether the region access is exclusive or not
  *
  *	Mark the PCI region associated with PCI device @pdev BR @bar as
  *	being reserved by owner @res_name.  Do not access any
  *	address inside the PCI regions unless this call returns
  *	successfully.
  *
+ *	If @exclusive is set, then the region is marked so that userspace
+ *	is explicitly not allowed to map the resource via /dev/mem or
+ * 	sysfs MMIO access.
+ *
  *	Returns 0 on success, or %EBUSY on error.  A warning
  *	message is also printed on failure.
  */
@@ -1588,12 +1593,12 @@ static int __pci_request_region(struct pci_dev *pdev, int bar, const char *res_n
 }
 
 /**
- *	pci_request_region - Reserved PCI I/O and memory resource
+ *	pci_request_region - Reserve PCI I/O and memory resource
  *	@pdev: PCI device whose resources are to be reserved
  *	@bar: BAR to be reserved
- *	@res_name: Name to be associated with resource.
+ *	@res_name: Name to be associated with resource
  *
- *	Mark the PCI region associated with PCI device @pdev BR @bar as
+ *	Mark the PCI region associated with PCI device @pdev BAR @bar as
  *	being reserved by owner @res_name.  Do not access any
  *	address inside the PCI regions unless this call returns
  *	successfully.

commit 49c968111aee4a463d3247937b63efa63a65f378
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Feb 4 02:02:15 2009 +0100

    PCI PM: Read power state from device after trying to change it on resume
    
    pci_restore_standard_config() unconditionally changes current_state
    to PCI_D0 after attempting to change the device's power state, but
    it should rather read the actual current power state from the
    device.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 87c904233bf5..e3efe6b19ee7 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1418,7 +1418,7 @@ int pci_restore_standard_config(struct pci_dev *dev)
 		break;
 	}
 
-	dev->current_state = PCI_D0;
+	pci_update_current_state(dev, PCI_D0);
 
  Restore:
 	return dev->state_saved ? pci_restore_state(dev) : 0;

commit 144a76bc885ef4852601c66595326e59f12877f8
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Feb 4 01:57:22 2009 +0100

    PCI PM: Check if the state has been saved before trying to restore it
    
    Check if the standard configuration registers of a PCI device have
    been saved during suspend before trying to restore them during
    resume.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Reported-By: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 48807556b47a..87c904233bf5 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1421,7 +1421,7 @@ int pci_restore_standard_config(struct pci_dev *dev)
 	dev->current_state = PCI_D0;
 
  Restore:
-	return pci_restore_state(dev);
+	return dev->state_saved ? pci_restore_state(dev) : 0;
 }
 
 /**

commit 476e7faefc43f106a90b5c96166c59b75de19d30
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Jan 22 23:39:57 2009 +0100

    PCI PM: Do not wait for buses in B2 or B3 during resume
    
    pci_restore_standard_config() adds extra delay for PCI buses in
    low power states (B2 or B3), but this is only correct for buses in
    B2, because the buses in B3 are reset when they are put back into
    B0.  Thus we should wait for such buses to settle after the reset,
    but it's not a good idea to wait that long (1.1 s) with interrupts
    off.
    
    On the other hand, we have never waited for buses in B2 and B3
    during resume and it seems reasonable to go back to this well
    tested behaviour.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index f0aa3d533839..48807556b47a 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1403,19 +1403,19 @@ int pci_restore_standard_config(struct pci_dev *dev)
 	if (error)
 		return error;
 
-	if (pci_is_bridge(dev)) {
-		if (prev_state > PCI_D1)
-			mdelay(PCI_PM_BUS_WAIT);
-	} else {
-		switch(prev_state) {
-		case PCI_D3cold:
-		case PCI_D3hot:
-			mdelay(pci_pm_d3_delay);
-			break;
-		case PCI_D2:
-			udelay(PCI_PM_D2_DELAY);
-			break;
-		}
+	/*
+	 * This assumes that we won't get a bus in B2 or B3 from the BIOS, but
+	 * we've made this assumption forever and it appears to be universally
+	 * satisfied.
+	 */
+	switch(prev_state) {
+	case PCI_D3cold:
+	case PCI_D3hot:
+		mdelay(pci_pm_d3_delay);
+		break;
+	case PCI_D2:
+		udelay(PCI_PM_D2_DELAY);
+		break;
 	}
 
 	dev->current_state = PCI_D0;

commit 48f67f54a53bb68619a63c3f38cf7f502ed74b1d
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Jan 22 23:38:31 2009 +0100

    PCI PM: Power up devices before restoring their state
    
    Devices that have MSI-X enabled before suspend to RAM or hibernation
    and that are in a low power state during resume will not be handled
    correctly by pci_restore_standard_config().  Namely, it first calls
    pci_restore_state() which calls pci_restore_msi_state(), which in turn
    executes __pci_restore_msix_state() that accesses the device's memory
    space to restore the contents of the MSI-X table.  However, if the
    device is in a low power state at this point, it's memory space is
    not accessible.
    
    The easiest way to fix this potential problem is to make
    pci_restore_standard_config() call pci_restore_state() after
    it has put the device into the full power state, D0.  Fortunately,
    all of this is done with interrupts off, so the change of ordering
    should not cause any trouble.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 17bd9325a245..f0aa3d533839 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1393,12 +1393,11 @@ int pci_restore_standard_config(struct pci_dev *dev)
 	pci_power_t prev_state;
 	int error;
 
-	pci_restore_state(dev);
 	pci_update_current_state(dev, PCI_D0);
 
 	prev_state = dev->current_state;
 	if (prev_state == PCI_D0)
-		return 0;
+		goto Restore;
 
 	error = pci_raw_set_power_state(dev, PCI_D0, false);
 	if (error)
@@ -1421,7 +1420,8 @@ int pci_restore_standard_config(struct pci_dev *dev)
 
 	dev->current_state = PCI_D0;
 
-	return 0;
+ Restore:
+	return pci_restore_state(dev);
 }
 
 /**

commit aa8c6c93747f7b55fa11e1624fec8ca33763a805
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri Jan 16 21:54:43 2009 +0100

    PCI PM: Restore standard config registers of all devices early
    
    There is a problem in our handling of suspend-resume of PCI devices that
    many of them have their standard config registers restored with
    interrupts enabled and they are put into the full power state with
    interrupts enabled as well.  This may lead to the following scenario:
      * an interrupt vector is shared between two or more devices
      * one device is resumed earlier and generates an interrupt
      * the interrupt handler of another device tries to handle it and
        attempts to access the device the config space of which hasn't been
        restored yet and/or which still is in a low power state
      * the system crashes as a result
    
    To prevent this from happening we should restore the standard
    configuration registers of all devices with interrupts disabled and we
    should put them into the D0 power state right after that.
    Unfortunately, this cannot be done using the existing
    pci_set_power_state(), because it can sleep.  Also, to do it we have to
    make sure that the config spaces of all devices were actually saved
    during suspend.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index e491fdedf705..17bd9325a245 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -22,7 +22,7 @@
 #include <asm/dma.h>	/* isa_dma_bridge_buggy */
 #include "pci.h"
 
-unsigned int pci_pm_d3_delay = 10;
+unsigned int pci_pm_d3_delay = PCI_PM_D3_WAIT;
 
 #ifdef CONFIG_PCI_DOMAINS
 int pci_domains_supported = 1;
@@ -426,6 +426,7 @@ static inline int platform_pci_sleep_wake(struct pci_dev *dev, bool enable)
  *                           given PCI device
  * @dev: PCI device to handle.
  * @state: PCI power state (D0, D1, D2, D3hot) to put the device into.
+ * @wait: If 'true', wait for the device to change its power state
  *
  * RETURN VALUE:
  * -EINVAL if the requested state is invalid.
@@ -435,7 +436,7 @@ static inline int platform_pci_sleep_wake(struct pci_dev *dev, bool enable)
  * 0 if device's power state has been successfully changed.
  */
 static int
-pci_raw_set_power_state(struct pci_dev *dev, pci_power_t state)
+pci_raw_set_power_state(struct pci_dev *dev, pci_power_t state, bool wait)
 {
 	u16 pmcsr;
 	bool need_restore = false;
@@ -480,8 +481,10 @@ pci_raw_set_power_state(struct pci_dev *dev, pci_power_t state)
 		break;
 	case PCI_UNKNOWN: /* Boot-up */
 		if ((pmcsr & PCI_PM_CTRL_STATE_MASK) == PCI_D3hot
-		 && !(pmcsr & PCI_PM_CTRL_NO_SOFT_RESET))
+		 && !(pmcsr & PCI_PM_CTRL_NO_SOFT_RESET)) {
 			need_restore = true;
+			wait = true;
+		}
 		/* Fall-through: force to D0 */
 	default:
 		pmcsr = 0;
@@ -491,12 +494,15 @@ pci_raw_set_power_state(struct pci_dev *dev, pci_power_t state)
 	/* enter specified state */
 	pci_write_config_word(dev, dev->pm_cap + PCI_PM_CTRL, pmcsr);
 
+	if (!wait)
+		return 0;
+
 	/* Mandatory power management transition delays */
 	/* see PCI PM 1.1 5.6.1 table 18 */
 	if (state == PCI_D3hot || dev->current_state == PCI_D3hot)
 		msleep(pci_pm_d3_delay);
 	else if (state == PCI_D2 || dev->current_state == PCI_D2)
-		udelay(200);
+		udelay(PCI_PM_D2_DELAY);
 
 	dev->current_state = state;
 
@@ -515,7 +521,7 @@ pci_raw_set_power_state(struct pci_dev *dev, pci_power_t state)
 	if (need_restore)
 		pci_restore_bars(dev);
 
-	if (dev->bus->self)
+	if (wait && dev->bus->self)
 		pcie_aspm_pm_state_change(dev->bus->self);
 
 	return 0;
@@ -585,7 +591,7 @@ int pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 	if (state == PCI_D3hot && (dev->dev_flags & PCI_DEV_FLAGS_NO_D3))
 		return 0;
 
-	error = pci_raw_set_power_state(dev, state);
+	error = pci_raw_set_power_state(dev, state, true);
 
 	if (state > PCI_D0 && platform_pci_power_manageable(dev)) {
 		/* Allow the platform to finalize the transition */
@@ -730,6 +736,7 @@ pci_save_state(struct pci_dev *dev)
 	/* XXX: 100% dword access ok here? */
 	for (i = 0; i < 16; i++)
 		pci_read_config_dword(dev, i * 4,&dev->saved_config_space[i]);
+	dev->state_saved = true;
 	if ((i = pci_save_pcie_state(dev)) != 0)
 		return i;
 	if ((i = pci_save_pcix_state(dev)) != 0)
@@ -1373,6 +1380,50 @@ void pci_allocate_cap_save_buffers(struct pci_dev *dev)
 			"unable to preallocate PCI-X save buffer\n");
 }
 
+/**
+ * pci_restore_standard_config - restore standard config registers of PCI device
+ * @dev: PCI device to handle
+ *
+ * This function assumes that the device's configuration space is accessible.
+ * If the device needs to be powered up, the function will wait for it to
+ * change the state.
+ */
+int pci_restore_standard_config(struct pci_dev *dev)
+{
+	pci_power_t prev_state;
+	int error;
+
+	pci_restore_state(dev);
+	pci_update_current_state(dev, PCI_D0);
+
+	prev_state = dev->current_state;
+	if (prev_state == PCI_D0)
+		return 0;
+
+	error = pci_raw_set_power_state(dev, PCI_D0, false);
+	if (error)
+		return error;
+
+	if (pci_is_bridge(dev)) {
+		if (prev_state > PCI_D1)
+			mdelay(PCI_PM_BUS_WAIT);
+	} else {
+		switch(prev_state) {
+		case PCI_D3cold:
+		case PCI_D3hot:
+			mdelay(pci_pm_d3_delay);
+			break;
+		case PCI_D2:
+			udelay(PCI_PM_D2_DELAY);
+			break;
+		}
+	}
+
+	dev->current_state = PCI_D0;
+
+	return 0;
+}
+
 /**
  * pci_enable_ari - enable ARI forwarding if hardware support it
  * @dev: the PCI device

commit 50246dd41ccbcb47beb06d6c1d9355f6b7137a11
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jan 16 08:14:51 2009 -0800

    Revert "PCI PM: Register power state of devices during initialization"
    
    This reverts commit 98e6e286d7b01deb7453b717aa38ebb69d6cefc0, as Yinghai
    Lu reports that it breaks kexec with at least the e1000 and e1000e
    drivers.  The reason is that the shutdown sequence puts the hardware
    into D3 sleep, and the commit causes us to claim that it then is in D0
    (running) state just because we don't understand the PM capabilities.
    
    Which then later makes "pci_set_power_state()" not do anything, and the
    device never wakes up properly and just returns 0xff to everything.
    
    Reported-by: Yinghai Lu <yinghai@kernel.org>
    Acked-by: From: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Jesse Barnes <jesse.barnes@intel.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index c12f6c790698..e491fdedf705 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1260,15 +1260,14 @@ void pci_pm_init(struct pci_dev *dev)
 	/* find PCI PM capability in list */
 	pm = pci_find_capability(dev, PCI_CAP_ID_PM);
 	if (!pm)
-		goto Exit;
-
+		return;
 	/* Check device's ability to generate PME# */
 	pci_read_config_word(dev, pm + PCI_PM_PMC, &pmc);
 
 	if ((pmc & PCI_PM_CAP_VER_MASK) > 3) {
 		dev_err(&dev->dev, "unsupported PM cap regs version (%u)\n",
 			pmc & PCI_PM_CAP_VER_MASK);
-		goto Exit;
+		return;
 	}
 
 	dev->pm_cap = pm;
@@ -1307,9 +1306,6 @@ void pci_pm_init(struct pci_dev *dev)
 	} else {
 		dev->pme_support = 0;
 	}
-
- Exit:
-	pci_update_current_state(dev, PCI_D0);
 }
 
 /**

commit 98e6e286d7b01deb7453b717aa38ebb69d6cefc0
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Jan 7 13:10:35 2009 +0100

    PCI PM: Register power state of devices during initialization
    
    Use the observation that the power state of a PCI device can be
    loaded into its pci_dev structure as soon as pci_pm_init() is run for
    it and make that happen.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@suse.cz>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index e491fdedf705..c12f6c790698 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1260,14 +1260,15 @@ void pci_pm_init(struct pci_dev *dev)
 	/* find PCI PM capability in list */
 	pm = pci_find_capability(dev, PCI_CAP_ID_PM);
 	if (!pm)
-		return;
+		goto Exit;
+
 	/* Check device's ability to generate PME# */
 	pci_read_config_word(dev, pm + PCI_PM_PMC, &pmc);
 
 	if ((pmc & PCI_PM_CAP_VER_MASK) > 3) {
 		dev_err(&dev->dev, "unsupported PM cap regs version (%u)\n",
 			pmc & PCI_PM_CAP_VER_MASK);
-		return;
+		goto Exit;
 	}
 
 	dev->pm_cap = pm;
@@ -1306,6 +1307,9 @@ void pci_pm_init(struct pci_dev *dev)
 	} else {
 		dev->pme_support = 0;
 	}
+
+ Exit:
+	pci_update_current_state(dev, PCI_D0);
 }
 
 /**

commit 734104292ff77dc71fe626b4ebd91b314547ca1b
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Jan 7 13:07:15 2009 +0100

    PCI PM: Avoid touching devices behind bridges in unknown state
    
    It generally is better to avoid accessing devices behind bridges that
    may not be in the D0 power state, because in that case the bridges'
    secondary buses may not be accessible.  For this reason, during the
    early phase of resume (ie. with interrupts disabled), before
    restoring the standard config registers of a device, check the power
    state of the bridge the device is behind and postpone the restoration
    of the device's config space, as well as any other operations that
    would involve accessing the device, if that state is not D0.
    
    In such cases the restoration of the device's config space will be
    retried during the "normal" phase of resume (ie. with interrupts
    enabled), so that the bridge can be put into D0 before that happens.
    
    Also, save standard configuration registers of PCI devices during the
    "normal" phase of suspend (ie. with interrupts enabled), so that the
    bridges the devices are behind can be put into low power states (we
    don't put bridges into low power states at the moment, but we may
    want to do it in the future and it seems reasonable to design for
    that).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 6e309c8b47df..e491fdedf705 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -527,7 +527,7 @@ pci_raw_set_power_state(struct pci_dev *dev, pci_power_t state)
  * @dev: PCI device to handle.
  * @state: State to cache in case the device doesn't have the PM capability
  */
-static void pci_update_current_state(struct pci_dev *dev, pci_power_t state)
+void pci_update_current_state(struct pci_dev *dev, pci_power_t state)
 {
 	if (dev->pm_cap) {
 		u16 pmcsr;

commit fa58d305d9925b01830e535896a7227a868a9e15
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Jan 7 13:03:42 2009 +0100

    PCI PM: Add suspend counterpart of pci_reenable_device
    
    PCI devices without drivers are not disabled during suspend and
    hibernation, but they are enabled during resume, with the help of
    pci_reenable_device(), so there is an unbalanced execution of
    pcibios_enable_device() in the resume code path.
    
    To correct this introduce function pci_disable_enabled_device()
    that will disable the argument device, if it is enabled when the
    function is being run, without updating the device's pci_dev
    structure and use it in the suspend code path to balance the
    pci_reenable_device() executed during resume.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@suse.cz>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index f3fd55df67db..6e309c8b47df 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -970,6 +970,32 @@ void pcim_pin_device(struct pci_dev *pdev)
  */
 void __attribute__ ((weak)) pcibios_disable_device (struct pci_dev *dev) {}
 
+static void do_pci_disable_device(struct pci_dev *dev)
+{
+	u16 pci_command;
+
+	pci_read_config_word(dev, PCI_COMMAND, &pci_command);
+	if (pci_command & PCI_COMMAND_MASTER) {
+		pci_command &= ~PCI_COMMAND_MASTER;
+		pci_write_config_word(dev, PCI_COMMAND, pci_command);
+	}
+
+	pcibios_disable_device(dev);
+}
+
+/**
+ * pci_disable_enabled_device - Disable device without updating enable_cnt
+ * @dev: PCI device to disable
+ *
+ * NOTE: This function is a backend of PCI power management routines and is
+ * not supposed to be called drivers.
+ */
+void pci_disable_enabled_device(struct pci_dev *dev)
+{
+	if (atomic_read(&dev->enable_cnt))
+		do_pci_disable_device(dev);
+}
+
 /**
  * pci_disable_device - Disable PCI device after use
  * @dev: PCI device to be disabled
@@ -984,7 +1010,6 @@ void
 pci_disable_device(struct pci_dev *dev)
 {
 	struct pci_devres *dr;
-	u16 pci_command;
 
 	dr = find_pci_dr(dev);
 	if (dr)
@@ -993,14 +1018,9 @@ pci_disable_device(struct pci_dev *dev)
 	if (atomic_sub_return(1, &dev->enable_cnt) != 0)
 		return;
 
-	pci_read_config_word(dev, PCI_COMMAND, &pci_command);
-	if (pci_command & PCI_COMMAND_MASTER) {
-		pci_command &= ~PCI_COMMAND_MASTER;
-		pci_write_config_word(dev, PCI_COMMAND, pci_command);
-	}
-	dev->is_busmaster = 0;
+	do_pci_disable_device(dev);
 
-	pcibios_disable_device(dev);
+	dev->is_busmaster = 0;
 }
 
 /**

commit 6a479079c07211bf348ac8a79754f26bea258f26
Author: Ben Hutchings <bhutchings@solarflare.com>
Date:   Tue Dec 23 03:08:29 2008 +0000

    PCI: Add pci_clear_master() as opposite of pci_set_master()
    
    During an online device reset it may be useful to disable bus-mastering.
    pci_disable_device() does that, and far more besides, so is not suitable
    for an online reset.
    
    Add pci_clear_master() which does just this.
    
    Signed-off-by: Ben Hutchings <bhutchings@solarflare.com>
    Reviewed-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index c824dc8d617c..f3fd55df67db 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1667,6 +1667,22 @@ int pci_request_regions_exclusive(struct pci_dev *pdev, const char *res_name)
 					((1 << 6) - 1), res_name);
 }
 
+static void __pci_set_master(struct pci_dev *dev, bool enable)
+{
+	u16 old_cmd, cmd;
+
+	pci_read_config_word(dev, PCI_COMMAND, &old_cmd);
+	if (enable)
+		cmd = old_cmd | PCI_COMMAND_MASTER;
+	else
+		cmd = old_cmd & ~PCI_COMMAND_MASTER;
+	if (cmd != old_cmd) {
+		dev_dbg(&dev->dev, "%s bus mastering\n",
+			enable ? "enabling" : "disabling");
+		pci_write_config_word(dev, PCI_COMMAND, cmd);
+	}
+	dev->is_busmaster = enable;
+}
 
 /**
  * pci_set_master - enables bus-mastering for device dev
@@ -1675,21 +1691,21 @@ int pci_request_regions_exclusive(struct pci_dev *pdev, const char *res_name)
  * Enables bus-mastering on the device and calls pcibios_set_master()
  * to do the needed arch specific settings.
  */
-void
-pci_set_master(struct pci_dev *dev)
+void pci_set_master(struct pci_dev *dev)
 {
-	u16 cmd;
-
-	pci_read_config_word(dev, PCI_COMMAND, &cmd);
-	if (! (cmd & PCI_COMMAND_MASTER)) {
-		dev_dbg(&dev->dev, "enabling bus mastering\n");
-		cmd |= PCI_COMMAND_MASTER;
-		pci_write_config_word(dev, PCI_COMMAND, cmd);
-	}
-	dev->is_busmaster = 1;
+	__pci_set_master(dev, true);
 	pcibios_set_master(dev);
 }
 
+/**
+ * pci_clear_master - disables bus-mastering for device dev
+ * @dev: the PCI device to disable
+ */
+void pci_clear_master(struct pci_dev *dev)
+{
+	__pci_set_master(dev, false);
+}
+
 #ifdef PCI_DISABLE_MWI
 int pci_set_mwi(struct pci_dev *dev)
 {
@@ -2346,6 +2362,7 @@ EXPORT_SYMBOL(pci_release_selected_regions);
 EXPORT_SYMBOL(pci_request_selected_regions);
 EXPORT_SYMBOL(pci_request_selected_regions_exclusive);
 EXPORT_SYMBOL(pci_set_master);
+EXPORT_SYMBOL(pci_clear_master);
 EXPORT_SYMBOL(pci_set_mwi);
 EXPORT_SYMBOL(pci_try_set_mwi);
 EXPORT_SYMBOL(pci_clear_mwi);

commit 68feac87de15edfc2c700d2d81b814288c93d003
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Dec 16 21:36:55 2008 -0700

    PCI: add pci_common_swizzle() for INTx swizzling
    
    This patch adds pci_common_swizzle(), which swizzles INTx values all the
    way up to a root bridge.
    
    This common implementation can replace several architecture-specific
    ones.  This should someday be combined with pci_get_interrupt_pin(),
    but I left it separate for now to make reviewing easier.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 9d2aa6366fd0..c824dc8d617c 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1421,6 +1421,26 @@ pci_get_interrupt_pin(struct pci_dev *dev, struct pci_dev **bridge)
 	return pin;
 }
 
+/**
+ * pci_common_swizzle - swizzle INTx all the way to root bridge
+ * @dev: the PCI device
+ * @pinp: pointer to the INTx pin value (1=INTA, 2=INTB, 3=INTD, 4=INTD)
+ *
+ * Perform INTx swizzling for a device.  This traverses through all PCI-to-PCI
+ * bridges all the way up to a PCI root bus.
+ */
+u8 pci_common_swizzle(struct pci_dev *dev, u8 *pinp)
+{
+	u8 pin = *pinp;
+
+	while (dev->bus->self) {
+		pin = pci_swizzle_interrupt_pin(dev, pin);
+		dev = dev->bus->self;
+	}
+	*pinp = pin;
+	return PCI_SLOT(dev->devfn);
+}
+
 /**
  *	pci_release_region - Release a PCI bar
  *	@pdev: PCI device whose resources were previously reserved by pci_request_region

commit f06fc0b6f8a6846e0ad48aee7b0f282b4fb5dcdc
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sat Dec 27 16:30:52 2008 +0100

    PCI PM: Fix pci_update_current_state
    
    Currently, PCI devices without the PM capability that are power
    manageable by the platform (eg. ACPI) are not handled correctly
    by pci_set_power_state(), because their current_state field is not
    updated to reflect the new power state of the device.  Fix this by
    making pci_update_current_state() accept additional argument
    representing the power state of the device as set by the platform.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 1b807330e500..9d2aa6366fd0 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -525,14 +525,17 @@ pci_raw_set_power_state(struct pci_dev *dev, pci_power_t state)
  * pci_update_current_state - Read PCI power state of given device from its
  *                            PCI PM registers and cache it
  * @dev: PCI device to handle.
+ * @state: State to cache in case the device doesn't have the PM capability
  */
-static void pci_update_current_state(struct pci_dev *dev)
+static void pci_update_current_state(struct pci_dev *dev, pci_power_t state)
 {
 	if (dev->pm_cap) {
 		u16 pmcsr;
 
 		pci_read_config_word(dev, dev->pm_cap + PCI_PM_CTRL, &pmcsr);
 		dev->current_state = (pmcsr & PCI_PM_CTRL_STATE_MASK);
+	} else {
+		dev->current_state = state;
 	}
 }
 
@@ -575,7 +578,7 @@ int pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 		 */
 		int ret = platform_pci_set_power_state(dev, PCI_D0);
 		if (!ret)
-			pci_update_current_state(dev);
+			pci_update_current_state(dev, PCI_D0);
 	}
 	/* This device is quirked not to be put into D3, so
 	   don't put it in D3 */
@@ -588,7 +591,7 @@ int pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 		/* Allow the platform to finalize the transition */
 		int ret = platform_pci_set_power_state(dev, state);
 		if (!ret) {
-			pci_update_current_state(dev);
+			pci_update_current_state(dev, state);
 			error = 0;
 		}
 	}

commit eb9c39d031bbcfd4005bd7e0337c3fd3909c1bf7
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Wed Dec 17 12:10:05 2008 -0800

    PCI: set device wakeup capable flag if platform support is present
    
    When PCI devices are initialized, we check whether they support PCI PM
    caps and set the device can_wakeup flag if so.  However, some devices
    may have platform provided wakeup events rather than PCI PME signals, so
    we need to set can_wakeup in that case too.  Doing so should allow
    wakeups from many more devices, especially on cost constrained systems.
    
    Reported-by: Alan Stern <stern@rowland.harvard.edu>
    Tested-by: Joseph Chan <JosephChan@via.com.tw>
    Acked-by: "Rafael J. Wysocki" <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 7e9c0f3936dd..1b807330e500 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1285,6 +1285,26 @@ void pci_pm_init(struct pci_dev *dev)
 	}
 }
 
+/**
+ * platform_pci_wakeup_init - init platform wakeup if present
+ * @dev: PCI device
+ *
+ * Some devices don't have PCI PM caps but can still generate wakeup
+ * events through platform methods (like ACPI events).  If @dev supports
+ * platform wakeup events, set the device flag to indicate as much.  This
+ * may be redundant if the device also supports PCI PM caps, but double
+ * initialization should be safe in that case.
+ */
+void platform_pci_wakeup_init(struct pci_dev *dev)
+{
+	if (!platform_pci_can_wakeup(dev))
+		return;
+
+	device_set_wakeup_capable(&dev->dev, true);
+	device_set_wakeup_enable(&dev->dev, false);
+	platform_pci_sleep_wake(dev, false);
+}
+
 /**
  * pci_add_save_buffer - allocate buffer for saving given capability registers
  * @dev: the PCI device

commit 613e7ed6f72b1a115f7ece8ce1b66cf095de1348
Author: Yu Zhao <yu.zhao@intel.com>
Date:   Sat Nov 22 02:41:27 2008 +0800

    PCI: add a new function to map BAR offsets
    
    Add a function to map a given resource number to a corresponding
    register so drivers can get the offset and type of device specific BARs.
    
    Signed-off-by: Yu Zhao <yu.zhao@intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index deeab19d7d10..7e9c0f3936dd 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2201,6 +2201,28 @@ int pci_select_bars(struct pci_dev *dev, unsigned long flags)
 	return bars;
 }
 
+/**
+ * pci_resource_bar - get position of the BAR associated with a resource
+ * @dev: the PCI device
+ * @resno: the resource number
+ * @type: the BAR type to be filled in
+ *
+ * Returns BAR position in config space, or 0 if the BAR is invalid.
+ */
+int pci_resource_bar(struct pci_dev *dev, int resno, enum pci_bar_type *type)
+{
+	if (resno < PCI_ROM_RESOURCE) {
+		*type = pci_bar_unknown;
+		return PCI_BASE_ADDRESS_0 + 4 * resno;
+	} else if (resno == PCI_ROM_RESOURCE) {
+		*type = pci_bar_mem32;
+		return dev->rom_base_reg;
+	}
+
+	dev_err(&dev->dev, "BAR: invalid resource #%d\n", resno);
+	return 0;
+}
+
 static void __devinit pci_no_domains(void)
 {
 #ifdef CONFIG_PCI_DOMAINS

commit bc5f5a8277cb353161454b6704b3186ebcf3a2a3
Author: Yu Zhao <yu.zhao@intel.com>
Date:   Sat Nov 22 02:40:00 2008 +0800

    PCI: remove unnecessary condition check in pci_restore_bars()
    
    Remove the unnecessary number of resources condition checks because
    the pci_update_resource() will check availability of the resources.
    
    Signed-off-by: Yu Zhao <yu.zhao@intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index c3ef2e78fc58..deeab19d7d10 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -376,24 +376,9 @@ pci_find_parent_resource(const struct pci_dev *dev, struct resource *res)
 static void
 pci_restore_bars(struct pci_dev *dev)
 {
-	int i, numres;
-
-	switch (dev->hdr_type) {
-	case PCI_HEADER_TYPE_NORMAL:
-		numres = 6;
-		break;
-	case PCI_HEADER_TYPE_BRIDGE:
-		numres = 2;
-		break;
-	case PCI_HEADER_TYPE_CARDBUS:
-		numres = 1;
-		break;
-	default:
-		/* Should never get here, but just in case... */
-		return;
-	}
+	int i;
 
-	for (i = 0; i < numres; i++)
+	for (i = 0; i < PCI_BRIDGE_RESOURCES; i++)
 		pci_update_resource(dev, i);
 }
 

commit 14add80b5120966fe0659d61815b9e9b4b68fdc5
Author: Yu Zhao <yu.zhao@intel.com>
Date:   Sat Nov 22 02:38:52 2008 +0800

    PCI: remove unnecessary arg of pci_update_resource()
    
    This cleanup removes unnecessary argument 'struct resource *res' in
    pci_update_resource(), so it takes same arguments as other companion
    functions (pci_assign_resource(), etc.).
    
    Signed-off-by: Yu Zhao <yu.zhao@intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 9354dd63f035..c3ef2e78fc58 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -393,8 +393,8 @@ pci_restore_bars(struct pci_dev *dev)
 		return;
 	}
 
-	for (i = 0; i < numres; i ++)
-		pci_update_resource(dev, &dev->resource[i], i);
+	for (i = 0; i < numres; i++)
+		pci_update_resource(dev, i);
 }
 
 static struct pci_platform_pm_ops *pci_platform_pm;

commit 1684f5ddd4c0c754f52c78eaa2c5c69ad09fb18c
Author: Andrew Morton <akpm@linux-foundation.org>
Date:   Mon Dec 1 14:30:30 2008 -0800

    PCI: uninline pci_ioremap_bar()
    
    It's too large to be inlined.
    
    Acked-by: Arjan van de Ven <arjan@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 1fb7cff4cdae..9354dd63f035 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -56,6 +56,22 @@ unsigned char pci_bus_max_busnr(struct pci_bus* bus)
 }
 EXPORT_SYMBOL_GPL(pci_bus_max_busnr);
 
+#ifdef CONFIG_HAS_IOMEM
+void __iomem *pci_ioremap_bar(struct pci_dev *pdev, int bar)
+{
+	/*
+	 * Make sure the BAR is actually a memory resource, not an IO resource
+	 */
+	if (!(pci_resource_flags(pdev, bar) & IORESOURCE_MEM)) {
+		WARN_ON(1);
+		return NULL;
+	}
+	return ioremap_nocache(pci_resource_start(pdev, bar),
+				     pci_resource_len(pdev, bar));
+}
+EXPORT_SYMBOL_GPL(pci_ioremap_bar);
+#endif
+
 #if 0
 /**
  * pci_max_busnr - returns maximum PCI bus number

commit bebd590ca27e80ffe3129ab4f0a3124f0a340f43
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Dec 16 14:06:58 2008 -0500

    PCI: fix incorrect error return in pci_enable_wake
    
    This patch (as1186) fixes a minor mistake in pci_enable_wake().  When
    the routine is asked to disable remote wakeup, it should not return an
    error merely because the device is not allowed to do wakeups!
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index d4d71fae6233..1fb7cff4cdae 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1091,7 +1091,7 @@ int pci_enable_wake(struct pci_dev *dev, pci_power_t state, int enable)
 	int error = 0;
 	bool pme_done = false;
 
-	if (!device_may_wakeup(&dev->dev))
+	if (enable && !device_may_wakeup(&dev->dev))
 		return -EINVAL;
 
 	/*

commit 57c2cf71c12318b72ebaa5720d210476b6bac4d4
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Thu Dec 11 11:24:23 2008 -0700

    PCI: add pci_swizzle_interrupt_pin()
    
    This patch adds pci_swizzle_interrupt_pin(), which implements the
    INTx swizzling algorithm specified in Table 9-1 of the "PCI-to-PCI
    Bridge Architecture Specification," revision 1.2.
    
    There are many architecture-specific implementations of this
    swizzle that can be replaced by this common one.
    
    Reviewed-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index bd52ca4c2893..d4d71fae6233 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1366,6 +1366,20 @@ void pci_enable_ari(struct pci_dev *dev)
 	bridge->ari_enabled = 1;
 }
 
+/**
+ * pci_swizzle_interrupt_pin - swizzle INTx for device behind bridge
+ * @dev: the PCI device
+ * @pin: the INTx pin (1=INTA, 2=INTB, 3=INTD, 4=INTD)
+ *
+ * Perform INTx swizzling for a device behind one level of bridge.  This is
+ * required by section 9.1 of the PCI-to-PCI bridge specification for devices
+ * behind bridges on add-in cards.
+ */
+u8 pci_swizzle_interrupt_pin(struct pci_dev *dev, u8 pin)
+{
+	return (((pin - 1) + PCI_SLOT(dev->devfn)) % 4) + 1;
+}
+
 int
 pci_get_interrupt_pin(struct pci_dev *dev, struct pci_dev **bridge)
 {
@@ -1376,7 +1390,7 @@ pci_get_interrupt_pin(struct pci_dev *dev, struct pci_dev **bridge)
 		return -1;
 
 	while (dev->bus->self) {
-		pin = (((pin - 1) + PCI_SLOT(dev->devfn)) % 4) + 1;
+		pin = pci_swizzle_interrupt_pin(dev, pin);
 		dev = dev->bus->self;
 	}
 	*bridge = dev;

commit 878f2e50fd1cfea575cdca5bf019c2175dc64131
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Dec 9 16:11:46 2008 -0700

    PCI: use config space encoding in pci_get_interrupt_pin()
    
    This patch makes pci_get_interrupt_pin() return values encoded
    the same way as the "Interrupt Pin" value in PCI config space,
    i.e., 1=INTA, ..., 4=INTD.
    
    pirq_bios_set() is the only in-tree caller of pci_get_interrupt_pin()
    and pci_get_interrupt_pin() is not exported.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: hpa@zytor.com
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 3222f9022707..bd52ca4c2893 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1374,9 +1374,9 @@ pci_get_interrupt_pin(struct pci_dev *dev, struct pci_dev **bridge)
 	pin = dev->pin;
 	if (!pin)
 		return -1;
-	pin--;
+
 	while (dev->bus->self) {
-		pin = (pin + PCI_SLOT(dev->devfn)) % 4;
+		pin = (((pin - 1) + PCI_SLOT(dev->devfn)) % 4) + 1;
 		dev = dev->bus->self;
 	}
 	*bridge = dev;

commit 63f4898ace2788a89ed685672aab092e1c3e50e6
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Dec 7 22:02:58 2008 +0100

    PCI: handle PCI state saving with interrupts disabled
    
    Since interrupts will soon be disabled at PCI resume time, we need to
    pre-allocate memory to save/restore PCI config space (or use GFP_ATOMIC,
    but this is safer).
    
    Reported-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: "Rafael J. Wysocki" <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 47663dc0daf7..3222f9022707 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -640,19 +640,14 @@ static int pci_save_pcie_state(struct pci_dev *dev)
 	int pos, i = 0;
 	struct pci_cap_saved_state *save_state;
 	u16 *cap;
-	int found = 0;
 
 	pos = pci_find_capability(dev, PCI_CAP_ID_EXP);
 	if (pos <= 0)
 		return 0;
 
 	save_state = pci_find_saved_cap(dev, PCI_CAP_ID_EXP);
-	if (!save_state)
-		save_state = kzalloc(sizeof(*save_state) + sizeof(u16) * 4, GFP_KERNEL);
-	else
-		found = 1;
 	if (!save_state) {
-		dev_err(&dev->dev, "out of memory in pci_save_pcie_state\n");
+		dev_err(&dev->dev, "buffer not found in %s\n", __FUNCTION__);
 		return -ENOMEM;
 	}
 	cap = (u16 *)&save_state->data[0];
@@ -661,9 +656,7 @@ static int pci_save_pcie_state(struct pci_dev *dev)
 	pci_read_config_word(dev, pos + PCI_EXP_LNKCTL, &cap[i++]);
 	pci_read_config_word(dev, pos + PCI_EXP_SLTCTL, &cap[i++]);
 	pci_read_config_word(dev, pos + PCI_EXP_RTCTL, &cap[i++]);
-	save_state->cap_nr = PCI_CAP_ID_EXP;
-	if (!found)
-		pci_add_saved_cap(dev, save_state);
+
 	return 0;
 }
 
@@ -688,30 +681,21 @@ static void pci_restore_pcie_state(struct pci_dev *dev)
 
 static int pci_save_pcix_state(struct pci_dev *dev)
 {
-	int pos, i = 0;
+	int pos;
 	struct pci_cap_saved_state *save_state;
-	u16 *cap;
-	int found = 0;
 
 	pos = pci_find_capability(dev, PCI_CAP_ID_PCIX);
 	if (pos <= 0)
 		return 0;
 
 	save_state = pci_find_saved_cap(dev, PCI_CAP_ID_PCIX);
-	if (!save_state)
-		save_state = kzalloc(sizeof(*save_state) + sizeof(u16), GFP_KERNEL);
-	else
-		found = 1;
 	if (!save_state) {
-		dev_err(&dev->dev, "out of memory in pci_save_pcie_state\n");
+		dev_err(&dev->dev, "buffer not found in %s\n", __FUNCTION__);
 		return -ENOMEM;
 	}
-	cap = (u16 *)&save_state->data[0];
 
-	pci_read_config_word(dev, pos + PCI_X_CMD, &cap[i++]);
-	save_state->cap_nr = PCI_CAP_ID_PCIX;
-	if (!found)
-		pci_add_saved_cap(dev, save_state);
+	pci_read_config_word(dev, pos + PCI_X_CMD, (u16 *)save_state->data);
+
 	return 0;
 }
 
@@ -1300,6 +1284,51 @@ void pci_pm_init(struct pci_dev *dev)
 	}
 }
 
+/**
+ * pci_add_save_buffer - allocate buffer for saving given capability registers
+ * @dev: the PCI device
+ * @cap: the capability to allocate the buffer for
+ * @size: requested size of the buffer
+ */
+static int pci_add_cap_save_buffer(
+	struct pci_dev *dev, char cap, unsigned int size)
+{
+	int pos;
+	struct pci_cap_saved_state *save_state;
+
+	pos = pci_find_capability(dev, cap);
+	if (pos <= 0)
+		return 0;
+
+	save_state = kzalloc(sizeof(*save_state) + size, GFP_KERNEL);
+	if (!save_state)
+		return -ENOMEM;
+
+	save_state->cap_nr = cap;
+	pci_add_saved_cap(dev, save_state);
+
+	return 0;
+}
+
+/**
+ * pci_allocate_cap_save_buffers - allocate buffers for saving capabilities
+ * @dev: the PCI device
+ */
+void pci_allocate_cap_save_buffers(struct pci_dev *dev)
+{
+	int error;
+
+	error = pci_add_cap_save_buffer(dev, PCI_CAP_ID_EXP, 4 * sizeof(u16));
+	if (error)
+		dev_err(&dev->dev,
+			"unable to preallocate PCI Express save buffer\n");
+
+	error = pci_add_cap_save_buffer(dev, PCI_CAP_ID_PCIX, sizeof(u16));
+	if (error)
+		dev_err(&dev->dev,
+			"unable to preallocate PCI-X save buffer\n");
+}
+
 /**
  * pci_enable_ari - enable ARI forwarding if hardware support it
  * @dev: the PCI device

commit e8de1481fd7126ee9e93d6889da6f00c05e1e019
Author: Arjan van de Ven <arjan@linux.intel.com>
Date:   Wed Oct 22 19:55:31 2008 -0700

    resource: allow MMIO exclusivity for device drivers
    
    Device drivers that use pci_request_regions() (and similar APIs) have a
    reasonable expectation that they are the only ones accessing their device.
    As part of the e1000e hunt, we were afraid that some userland (X or some
    bootsplash stuff) was mapping the MMIO region that the driver thought it
    had exclusively via /dev/mem or via various sysfs resource mappings.
    
    This patch adds the option for device drivers to cause their reserved
    regions to the "banned from /dev/mem use" list, so now both kernel memory
    and device-exclusive MMIO regions are banned.
    NOTE: This is only active when CONFIG_STRICT_DEVMEM is set.
    
    In addition to the config option, a kernel parameter iomem=relaxed is
    provided for the cases where developers want to diagnose, in the field,
    drivers issues from userspace.
    
    Reviewed-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 2cfa41e367a7..47663dc0daf7 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1395,7 +1395,8 @@ void pci_release_region(struct pci_dev *pdev, int bar)
  *	Returns 0 on success, or %EBUSY on error.  A warning
  *	message is also printed on failure.
  */
-int pci_request_region(struct pci_dev *pdev, int bar, const char *res_name)
+static int __pci_request_region(struct pci_dev *pdev, int bar, const char *res_name,
+									int exclusive)
 {
 	struct pci_devres *dr;
 
@@ -1408,8 +1409,9 @@ int pci_request_region(struct pci_dev *pdev, int bar, const char *res_name)
 			goto err_out;
 	}
 	else if (pci_resource_flags(pdev, bar) & IORESOURCE_MEM) {
-		if (!request_mem_region(pci_resource_start(pdev, bar),
-				        pci_resource_len(pdev, bar), res_name))
+		if (!__request_mem_region(pci_resource_start(pdev, bar),
+					pci_resource_len(pdev, bar), res_name,
+					exclusive))
 			goto err_out;
 	}
 
@@ -1427,6 +1429,47 @@ int pci_request_region(struct pci_dev *pdev, int bar, const char *res_name)
 	return -EBUSY;
 }
 
+/**
+ *	pci_request_region - Reserved PCI I/O and memory resource
+ *	@pdev: PCI device whose resources are to be reserved
+ *	@bar: BAR to be reserved
+ *	@res_name: Name to be associated with resource.
+ *
+ *	Mark the PCI region associated with PCI device @pdev BR @bar as
+ *	being reserved by owner @res_name.  Do not access any
+ *	address inside the PCI regions unless this call returns
+ *	successfully.
+ *
+ *	Returns 0 on success, or %EBUSY on error.  A warning
+ *	message is also printed on failure.
+ */
+int pci_request_region(struct pci_dev *pdev, int bar, const char *res_name)
+{
+	return __pci_request_region(pdev, bar, res_name, 0);
+}
+
+/**
+ *	pci_request_region_exclusive - Reserved PCI I/O and memory resource
+ *	@pdev: PCI device whose resources are to be reserved
+ *	@bar: BAR to be reserved
+ *	@res_name: Name to be associated with resource.
+ *
+ *	Mark the PCI region associated with PCI device @pdev BR @bar as
+ *	being reserved by owner @res_name.  Do not access any
+ *	address inside the PCI regions unless this call returns
+ *	successfully.
+ *
+ *	Returns 0 on success, or %EBUSY on error.  A warning
+ *	message is also printed on failure.
+ *
+ *	The key difference that _exclusive makes it that userspace is
+ *	explicitly not allowed to map the resource via /dev/mem or
+ * 	sysfs.
+ */
+int pci_request_region_exclusive(struct pci_dev *pdev, int bar, const char *res_name)
+{
+	return __pci_request_region(pdev, bar, res_name, IORESOURCE_EXCLUSIVE);
+}
 /**
  * pci_release_selected_regions - Release selected PCI I/O and memory resources
  * @pdev: PCI device whose resources were previously reserved
@@ -1444,20 +1487,14 @@ void pci_release_selected_regions(struct pci_dev *pdev, int bars)
 			pci_release_region(pdev, i);
 }
 
-/**
- * pci_request_selected_regions - Reserve selected PCI I/O and memory resources
- * @pdev: PCI device whose resources are to be reserved
- * @bars: Bitmask of BARs to be requested
- * @res_name: Name to be associated with resource
- */
-int pci_request_selected_regions(struct pci_dev *pdev, int bars,
-				 const char *res_name)
+int __pci_request_selected_regions(struct pci_dev *pdev, int bars,
+				 const char *res_name, int excl)
 {
 	int i;
 
 	for (i = 0; i < 6; i++)
 		if (bars & (1 << i))
-			if(pci_request_region(pdev, i, res_name))
+			if (__pci_request_region(pdev, i, res_name, excl))
 				goto err_out;
 	return 0;
 
@@ -1469,6 +1506,26 @@ int pci_request_selected_regions(struct pci_dev *pdev, int bars,
 	return -EBUSY;
 }
 
+
+/**
+ * pci_request_selected_regions - Reserve selected PCI I/O and memory resources
+ * @pdev: PCI device whose resources are to be reserved
+ * @bars: Bitmask of BARs to be requested
+ * @res_name: Name to be associated with resource
+ */
+int pci_request_selected_regions(struct pci_dev *pdev, int bars,
+				 const char *res_name)
+{
+	return __pci_request_selected_regions(pdev, bars, res_name, 0);
+}
+
+int pci_request_selected_regions_exclusive(struct pci_dev *pdev,
+				 int bars, const char *res_name)
+{
+	return __pci_request_selected_regions(pdev, bars, res_name,
+			IORESOURCE_EXCLUSIVE);
+}
+
 /**
  *	pci_release_regions - Release reserved PCI I/O and memory resources
  *	@pdev: PCI device whose resources were previously reserved by pci_request_regions
@@ -1501,6 +1558,29 @@ int pci_request_regions(struct pci_dev *pdev, const char *res_name)
 	return pci_request_selected_regions(pdev, ((1 << 6) - 1), res_name);
 }
 
+/**
+ *	pci_request_regions_exclusive - Reserved PCI I/O and memory resources
+ *	@pdev: PCI device whose resources are to be reserved
+ *	@res_name: Name to be associated with resource.
+ *
+ *	Mark all PCI regions associated with PCI device @pdev as
+ *	being reserved by owner @res_name.  Do not access any
+ *	address inside the PCI regions unless this call returns
+ *	successfully.
+ *
+ *	pci_request_regions_exclusive() will mark the region so that
+ * 	/dev/mem and the sysfs MMIO access will not be allowed.
+ *
+ *	Returns 0 on success, or %EBUSY on error.  A warning
+ *	message is also printed on failure.
+ */
+int pci_request_regions_exclusive(struct pci_dev *pdev, const char *res_name)
+{
+	return pci_request_selected_regions_exclusive(pdev,
+					((1 << 6) - 1), res_name);
+}
+
+
 /**
  * pci_set_master - enables bus-mastering for device dev
  * @dev: the PCI device to enable
@@ -2149,10 +2229,13 @@ EXPORT_SYMBOL(pci_find_capability);
 EXPORT_SYMBOL(pci_bus_find_capability);
 EXPORT_SYMBOL(pci_release_regions);
 EXPORT_SYMBOL(pci_request_regions);
+EXPORT_SYMBOL(pci_request_regions_exclusive);
 EXPORT_SYMBOL(pci_release_region);
 EXPORT_SYMBOL(pci_request_region);
+EXPORT_SYMBOL(pci_request_region_exclusive);
 EXPORT_SYMBOL(pci_release_selected_regions);
 EXPORT_SYMBOL(pci_request_selected_regions);
+EXPORT_SYMBOL(pci_request_selected_regions_exclusive);
 EXPORT_SYMBOL(pci_set_master);
 EXPORT_SYMBOL(pci_set_mwi);
 EXPORT_SYMBOL(pci_try_set_mwi);

commit 07ae95f988a34465bdcb384bfa73c03424fe2312
Author: Andrew Patterson <andrew.patterson@hp.com>
Date:   Mon Nov 10 15:31:05 2008 -0700

    ACPI/PCI: PCI MSI _OSC support capabilities called when root bridge added
    
    The _OSC capability OSC_MSI_SUPPORT is set when the root bridge is added
    with pci_acpi_osc_support(), so we no longer need to do it in the PCI
    MSI driver.  Also adds the function pci_msi_enabled, which returns true
    if pci=nomsi is not on the kernel command-line.
    
    Signed-off-by: Andrew Patterson <andrew.patterson@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 48fa860276d4..2cfa41e367a7 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2105,8 +2105,6 @@ static int __devinit pci_init(void)
 		pci_fixup_device(pci_fixup_final, dev);
 	}
 
-	msi_init();
-
 	return 0;
 }
 

commit 0ef5f8f6159e44b4faa997be08d1a3bcbf44ad08
Author: Andrew Patterson <andrew.patterson@hp.com>
Date:   Mon Nov 10 15:30:50 2008 -0700

    ACPI/PCI: PCI extended config _OSC support called when root bridge added
    
    The _OSC capability OSC_EXT_PCI_CONFIG_SUPPORT is set when the root
    bridge is added with pci_acpi_osc_support() if we can access PCI
    extended config space.
    
    This adds the function pci_ext_cfg_avail which returns true if we can
    access PCI extended config space (offset greater than 0xff). It
    currently only returns false if arch=x86 and raw_pci_ext_ops is not set
    (which might happen if pci=nommcfg is set on the kernel command-line).
    
    Signed-off-by: Andrew Patterson <andrew.patterson@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 3c2fa2fdc9cd..48fa860276d4 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2084,6 +2084,19 @@ static void __devinit pci_no_domains(void)
 #endif
 }
 
+/**
+ * pci_ext_cfg_enabled - can we access extended PCI config space?
+ * @dev: The PCI device of the root bridge.
+ *
+ * Returns 1 if we can access PCI extended config space (offsets
+ * greater than 0xff). This is the default implementation. Architecture
+ * implementations can override this.
+ */
+int __attribute__ ((weak)) pci_ext_cfg_avail(struct pci_dev *dev)
+{
+	return 1;
+}
+
 static int __devinit pci_init(void)
 {
 	struct pci_dev *dev = NULL;

commit 1ca887970a3971a22e4875b7c6ad5ae3ce49f61a
Author: Sheng Yang <sheng@linux.intel.com>
Date:   Tue Nov 11 17:17:48 2008 +0800

    PCI: Extend pci_reset_function() to support PCI Advanced Features
    
    Some PCI devices implement PCI Advanced Features, which means they
    support Function Level Reset(FLR).  Implement support for that in
    pci_reset_function.
    
    Signed-off-by: Sheng Yang <sheng@linux.intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 62978f644a92..3c2fa2fdc9cd 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1789,6 +1789,43 @@ static int __pcie_flr(struct pci_dev *dev, int probe)
 	return 0;
 }
 
+static int __pci_af_flr(struct pci_dev *dev, int probe)
+{
+	int cappos = pci_find_capability(dev, PCI_CAP_ID_AF);
+	u8 status;
+	u8 cap;
+
+	if (!cappos)
+		return -ENOTTY;
+	pci_read_config_byte(dev, cappos + PCI_AF_CAP, &cap);
+	if (!(cap & PCI_AF_CAP_TP) || !(cap & PCI_AF_CAP_FLR))
+		return -ENOTTY;
+
+	if (probe)
+		return 0;
+
+	pci_block_user_cfg_access(dev);
+
+	/* Wait for Transaction Pending bit clean */
+	msleep(100);
+	pci_read_config_byte(dev, cappos + PCI_AF_STATUS, &status);
+	if (status & PCI_AF_STATUS_TP) {
+		dev_info(&dev->dev, "Busy after 100ms while trying to"
+				" reset; sleeping for 1 second\n");
+		ssleep(1);
+		pci_read_config_byte(dev,
+				cappos + PCI_AF_STATUS, &status);
+		if (status & PCI_AF_STATUS_TP)
+			dev_info(&dev->dev, "Still busy after 1s; "
+					"proceeding with reset anyway\n");
+	}
+	pci_write_config_byte(dev, cappos + PCI_AF_CTRL, PCI_AF_CTRL_FLR);
+	mdelay(100);
+
+	pci_unblock_user_cfg_access(dev);
+	return 0;
+}
+
 static int __pci_reset_function(struct pci_dev *pdev, int probe)
 {
 	int res;
@@ -1797,6 +1834,10 @@ static int __pci_reset_function(struct pci_dev *pdev, int probe)
 	if (res != -ENOTTY)
 		return res;
 
+	res = __pci_af_flr(pdev, probe);
+	if (res != -ENOTTY)
+		return res;
+
 	return res;
 }
 

commit d91cdc745524a1b1ff537712a62803b8413c12d6
Author: Sheng Yang <sheng@linux.intel.com>
Date:   Tue Nov 11 17:17:47 2008 +0800

    PCI: Refactor pci_reset_function()
    
    Separate out function level reset so that pci_reset_function can be more
    easily extended.
    
    Signed-off-by: Sheng Yang <sheng@linux.intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 061d1ee0046a..62978f644a92 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1751,24 +1751,7 @@ int pci_set_dma_seg_boundary(struct pci_dev *dev, unsigned long mask)
 EXPORT_SYMBOL(pci_set_dma_seg_boundary);
 #endif
 
-/**
- * pci_execute_reset_function() - Reset a PCI device function
- * @dev: Device function to reset
- *
- * Some devices allow an individual function to be reset without affecting
- * other functions in the same device.  The PCI device must be responsive
- * to PCI config space in order to use this function.
- *
- * The device function is presumed to be unused when this function is called.
- * Resetting the device will make the contents of PCI configuration space
- * random, so any caller of this must be prepared to reinitialise the
- * device including MSI, bus mastering, BARs, decoding IO and memory spaces,
- * etc.
- *
- * Returns 0 if the device function was successfully reset or -ENOTTY if the
- * device doesn't support resetting a single function.
- */
-int pci_execute_reset_function(struct pci_dev *dev)
+static int __pcie_flr(struct pci_dev *dev, int probe)
 {
 	u16 status;
 	u32 cap;
@@ -1780,6 +1763,9 @@ int pci_execute_reset_function(struct pci_dev *dev)
 	if (!(cap & PCI_EXP_DEVCAP_FLR))
 		return -ENOTTY;
 
+	if (probe)
+		return 0;
+
 	pci_block_user_cfg_access(dev);
 
 	/* Wait for Transaction Pending bit clean */
@@ -1802,6 +1788,39 @@ int pci_execute_reset_function(struct pci_dev *dev)
 	pci_unblock_user_cfg_access(dev);
 	return 0;
 }
+
+static int __pci_reset_function(struct pci_dev *pdev, int probe)
+{
+	int res;
+
+	res = __pcie_flr(pdev, probe);
+	if (res != -ENOTTY)
+		return res;
+
+	return res;
+}
+
+/**
+ * pci_execute_reset_function() - Reset a PCI device function
+ * @dev: Device function to reset
+ *
+ * Some devices allow an individual function to be reset without affecting
+ * other functions in the same device.  The PCI device must be responsive
+ * to PCI config space in order to use this function.
+ *
+ * The device function is presumed to be unused when this function is called.
+ * Resetting the device will make the contents of PCI configuration space
+ * random, so any caller of this must be prepared to reinitialise the
+ * device including MSI, bus mastering, BARs, decoding IO and memory spaces,
+ * etc.
+ *
+ * Returns 0 if the device function was successfully reset or -ENOTTY if the
+ * device doesn't support resetting a single function.
+ */
+int pci_execute_reset_function(struct pci_dev *dev)
+{
+	return __pci_reset_function(dev, 0);
+}
 EXPORT_SYMBOL_GPL(pci_execute_reset_function);
 
 /**
@@ -1822,15 +1841,10 @@ EXPORT_SYMBOL_GPL(pci_execute_reset_function);
  */
 int pci_reset_function(struct pci_dev *dev)
 {
-	u32 cap;
-	int exppos = pci_find_capability(dev, PCI_CAP_ID_EXP);
-	int r;
+	int r = __pci_reset_function(dev, 1);
 
-	if (!exppos)
-		return -ENOTTY;
-	pci_read_config_dword(dev, exppos + PCI_EXP_DEVCAP, &cap);
-	if (!(cap & PCI_EXP_DEVCAP_FLR))
-		return -ENOTTY;
+	if (r < 0)
+		return r;
 
 	if (!dev->msi_enabled && !dev->msix_enabled && dev->irq != 0)
 		disable_irq(dev->irq);

commit ad04d31e5fb6b25308e6cdea6baa07d41871a3e0
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Sat Nov 22 17:37:14 2008 +0000

    pci_setup() is init, not devinit
    
    for fsck sake, it's used only when parsing kernel command line...
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 28af496b441e..061d1ee0046a 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2042,7 +2042,7 @@ static int __devinit pci_init(void)
 	return 0;
 }
 
-static int __devinit pci_setup(char *str)
+static int __init pci_setup(char *str)
 {
 	while (str) {
 		char *k = strchr(str, ',');

commit 1df8fb3d5f078f9cab901b6106ef2c9b74eef7df
Author: Sheng Yang <sheng@linux.intel.com>
Date:   Tue Nov 11 17:17:45 2008 +0800

    PCI: Fix disable IRQ 0 in pci_reset_function()
    
    Before initialization, dev->irq may be zero. Make sure we don't disable
    it at reset time in that case.
    
    Reviewed-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: Sheng Yang <sheng@linux.intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 21f2ac639cab..28af496b441e 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1832,7 +1832,7 @@ int pci_reset_function(struct pci_dev *dev)
 	if (!(cap & PCI_EXP_DEVCAP_FLR))
 		return -ENOTTY;
 
-	if (!dev->msi_enabled && !dev->msix_enabled)
+	if (!dev->msi_enabled && !dev->msix_enabled && dev->irq != 0)
 		disable_irq(dev->irq);
 	pci_save_state(dev);
 
@@ -1841,7 +1841,7 @@ int pci_reset_function(struct pci_dev *dev)
 	r = pci_execute_reset_function(dev);
 
 	pci_restore_state(dev);
-	if (!dev->msi_enabled && !dev->msix_enabled)
+	if (!dev->msi_enabled && !dev->msix_enabled && dev->irq != 0)
 		enable_irq(dev->irq);
 
 	return r;

commit 8113587c2d14d3be2414190845b2e2617c0aa33b
Author: Zhao, Yu <yu.zhao@intel.com>
Date:   Thu Oct 23 13:15:39 2008 +0800

    PCI: fix ARI code to be compatible with mixed ARI/non-ARI systems
    
    The original ARI support code has a compatibility problem with non-ARI
    devices.  If a device doesn't support ARI, turning on ARI forwarding on
    its upper level bridge will cause undefined behavior.
    
    This fix turns on ARI forwarding only when the subordinate devices
    support it.
    
    Tested-by: Suresh Siddha <suresh.b.siddha@intel.com>
    Signed-off-by: Yu Zhao <yu.zhao@intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 533aeb5fcbe4..21f2ac639cab 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1309,27 +1309,32 @@ void pci_enable_ari(struct pci_dev *dev)
 	int pos;
 	u32 cap;
 	u16 ctrl;
+	struct pci_dev *bridge;
 
-	if (!dev->is_pcie)
+	if (!dev->is_pcie || dev->devfn)
 		return;
 
-	if (dev->pcie_type != PCI_EXP_TYPE_ROOT_PORT &&
-	    dev->pcie_type != PCI_EXP_TYPE_DOWNSTREAM)
+	pos = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ARI);
+	if (!pos)
 		return;
 
-	pos = pci_find_capability(dev, PCI_CAP_ID_EXP);
+	bridge = dev->bus->self;
+	if (!bridge || !bridge->is_pcie)
+		return;
+
+	pos = pci_find_capability(bridge, PCI_CAP_ID_EXP);
 	if (!pos)
 		return;
 
-	pci_read_config_dword(dev, pos + PCI_EXP_DEVCAP2, &cap);
+	pci_read_config_dword(bridge, pos + PCI_EXP_DEVCAP2, &cap);
 	if (!(cap & PCI_EXP_DEVCAP2_ARI))
 		return;
 
-	pci_read_config_word(dev, pos + PCI_EXP_DEVCTL2, &ctrl);
+	pci_read_config_word(bridge, pos + PCI_EXP_DEVCTL2, &ctrl);
 	ctrl |= PCI_EXP_DEVCTL2_ARI;
-	pci_write_config_word(dev, pos + PCI_EXP_DEVCTL2, ctrl);
+	pci_write_config_word(bridge, pos + PCI_EXP_DEVCTL2, ctrl);
 
-	dev->ari_enabled = 1;
+	bridge->ari_enabled = 1;
 }
 
 int

commit 8dd7f8036c123296fc4214f9d8810eb485570422
Author: Sheng Yang <sheng@linux.intel.com>
Date:   Tue Oct 21 17:38:25 2008 +0800

    PCI: add support for function level reset
    
    Sometimes, it's necessary to enable software's ability to quiesce and
    reset endpoint hardware with function-level granularity, so provide
    support for it.
    
    The patch implement Function Level Reset(FLR) feature following PCI-e
    spec. And this is the first step. We would add more generic method, like
    D0/D3, to allow more devices support this function.
    
    The patch contains two functions. pcie_reset_function() is the new
    driver API, and, contains some action to quiesce a device.  The other
    function is a helper:  pcie_execute_reset_function() just executes the
    reset for a particular device function.
    
    Current the usage model is in KVM. Function reset is necessary for
    assigning device to a guest, or moving it between partitions.
    
    For Function Level Reset(FLR), please refer to PCI Express spec chapter
    6.6.2.
    
    Signed-off-by: Sheng Yang <sheng@linux.intel.com>
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index aee73cf251b6..533aeb5fcbe4 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -18,6 +18,7 @@
 #include <linux/log2.h>
 #include <linux/pci-aspm.h>
 #include <linux/pm_wakeup.h>
+#include <linux/interrupt.h>
 #include <asm/dma.h>	/* isa_dma_bridge_buggy */
 #include "pci.h"
 
@@ -1745,6 +1746,103 @@ int pci_set_dma_seg_boundary(struct pci_dev *dev, unsigned long mask)
 EXPORT_SYMBOL(pci_set_dma_seg_boundary);
 #endif
 
+/**
+ * pci_execute_reset_function() - Reset a PCI device function
+ * @dev: Device function to reset
+ *
+ * Some devices allow an individual function to be reset without affecting
+ * other functions in the same device.  The PCI device must be responsive
+ * to PCI config space in order to use this function.
+ *
+ * The device function is presumed to be unused when this function is called.
+ * Resetting the device will make the contents of PCI configuration space
+ * random, so any caller of this must be prepared to reinitialise the
+ * device including MSI, bus mastering, BARs, decoding IO and memory spaces,
+ * etc.
+ *
+ * Returns 0 if the device function was successfully reset or -ENOTTY if the
+ * device doesn't support resetting a single function.
+ */
+int pci_execute_reset_function(struct pci_dev *dev)
+{
+	u16 status;
+	u32 cap;
+	int exppos = pci_find_capability(dev, PCI_CAP_ID_EXP);
+
+	if (!exppos)
+		return -ENOTTY;
+	pci_read_config_dword(dev, exppos + PCI_EXP_DEVCAP, &cap);
+	if (!(cap & PCI_EXP_DEVCAP_FLR))
+		return -ENOTTY;
+
+	pci_block_user_cfg_access(dev);
+
+	/* Wait for Transaction Pending bit clean */
+	msleep(100);
+	pci_read_config_word(dev, exppos + PCI_EXP_DEVSTA, &status);
+	if (status & PCI_EXP_DEVSTA_TRPND) {
+		dev_info(&dev->dev, "Busy after 100ms while trying to reset; "
+			"sleeping for 1 second\n");
+		ssleep(1);
+		pci_read_config_word(dev, exppos + PCI_EXP_DEVSTA, &status);
+		if (status & PCI_EXP_DEVSTA_TRPND)
+			dev_info(&dev->dev, "Still busy after 1s; "
+				"proceeding with reset anyway\n");
+	}
+
+	pci_write_config_word(dev, exppos + PCI_EXP_DEVCTL,
+				PCI_EXP_DEVCTL_BCR_FLR);
+	mdelay(100);
+
+	pci_unblock_user_cfg_access(dev);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(pci_execute_reset_function);
+
+/**
+ * pci_reset_function() - quiesce and reset a PCI device function
+ * @dev: Device function to reset
+ *
+ * Some devices allow an individual function to be reset without affecting
+ * other functions in the same device.  The PCI device must be responsive
+ * to PCI config space in order to use this function.
+ *
+ * This function does not just reset the PCI portion of a device, but
+ * clears all the state associated with the device.  This function differs
+ * from pci_execute_reset_function in that it saves and restores device state
+ * over the reset.
+ *
+ * Returns 0 if the device function was successfully reset or -ENOTTY if the
+ * device doesn't support resetting a single function.
+ */
+int pci_reset_function(struct pci_dev *dev)
+{
+	u32 cap;
+	int exppos = pci_find_capability(dev, PCI_CAP_ID_EXP);
+	int r;
+
+	if (!exppos)
+		return -ENOTTY;
+	pci_read_config_dword(dev, exppos + PCI_EXP_DEVCAP, &cap);
+	if (!(cap & PCI_EXP_DEVCAP_FLR))
+		return -ENOTTY;
+
+	if (!dev->msi_enabled && !dev->msix_enabled)
+		disable_irq(dev->irq);
+	pci_save_state(dev);
+
+	pci_write_config_word(dev, PCI_COMMAND, PCI_COMMAND_INTX_DISABLE);
+
+	r = pci_execute_reset_function(dev);
+
+	pci_restore_state(dev);
+	if (!dev->msi_enabled && !dev->msix_enabled)
+		enable_irq(dev->irq);
+
+	return r;
+}
+EXPORT_SYMBOL_GPL(pci_reset_function);
+
 /**
  * pcix_get_max_mmrbc - get PCI-X maximum designed memory read byte count
  * @dev: PCI device to query

commit d389fec6a2aec1ea7d47833f36a0413a619c8c12
Author: Taku Izumi <izumi.taku@jp.fujitsu.com>
Date:   Fri Oct 17 13:52:51 2008 +0900

    ACPI/PCI: Set support bit for MSI in support field of _OSC
    
    Currently linux doesn't have any code to set the "MSI supported" bit in
    Support Fireld of _OSC. This patch adds the code for that.
    
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Taku Izumi <izumi.taku@jp.fujitsu.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 4db261e13e69..aee73cf251b6 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1933,6 +1933,9 @@ static int __devinit pci_init(void)
 	while ((dev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, dev)) != NULL) {
 		pci_fixup_device(pci_fixup_final, dev);
 	}
+
+	msi_init();
+
 	return 0;
 }
 

commit 58c3a727cb73b75a9104d295f096cca12959a5a5
Author: Yu Zhao <yu.zhao@intel.com>
Date:   Tue Oct 14 14:02:53 2008 +0800

    PCI: support PCIe ARI capability
    
    This patch adds support for PCI Express Alternative Routing-ID
    Interpretation (ARI) capability.
    
    The ARI capability extends the Function Number field of the PCI Express
    Endpoint by reusing the Device Number which is otherwise hardwired to 0.
    With ARI, an Endpoint can have up to 256 functions.
    
    Signed-off-by: Yu Zhao <yu.zhao@intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 553ca6657955..4db261e13e69 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1299,6 +1299,38 @@ void pci_pm_init(struct pci_dev *dev)
 	}
 }
 
+/**
+ * pci_enable_ari - enable ARI forwarding if hardware support it
+ * @dev: the PCI device
+ */
+void pci_enable_ari(struct pci_dev *dev)
+{
+	int pos;
+	u32 cap;
+	u16 ctrl;
+
+	if (!dev->is_pcie)
+		return;
+
+	if (dev->pcie_type != PCI_EXP_TYPE_ROOT_PORT &&
+	    dev->pcie_type != PCI_EXP_TYPE_DOWNSTREAM)
+		return;
+
+	pos = pci_find_capability(dev, PCI_CAP_ID_EXP);
+	if (!pos)
+		return;
+
+	pci_read_config_dword(dev, pos + PCI_EXP_DEVCAP2, &cap);
+	if (!(cap & PCI_EXP_DEVCAP2_ARI))
+		return;
+
+	pci_read_config_word(dev, pos + PCI_EXP_DEVCTL2, &ctrl);
+	ctrl |= PCI_EXP_DEVCTL2_ARI;
+	pci_write_config_word(dev, pos + PCI_EXP_DEVCTL2, ctrl);
+
+	dev->ari_enabled = 1;
+}
+
 int
 pci_get_interrupt_pin(struct pci_dev *dev, struct pci_dev **bridge)
 {

commit 557848c3c03ad1d1e66cb3b5b06698e3a9ebc33c
Author: Zhao, Yu <yu.zhao@intel.com>
Date:   Mon Oct 13 19:18:07 2008 +0800

    PCI: replace cfg space size (256/4096) by macros.
    
    This is a cleanup that changes all PCI configuration space size
    representations to the macros (PCI_CFG_SPACE_SIZE and
    PCI_CFG_SPACE_EXP_SIZE). And the macros are also moved from
    drivers/pci/probe.c to drivers/pci/pci.h.
    
    Signed-off-by: Yu Zhao <yu.zhao@intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 09dc893c81db..553ca6657955 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -213,10 +213,13 @@ int pci_bus_find_capability(struct pci_bus *bus, unsigned int devfn, int cap)
 int pci_find_ext_capability(struct pci_dev *dev, int cap)
 {
 	u32 header;
-	int ttl = 480; /* 3840 bytes, minimum 8 bytes per capability */
-	int pos = 0x100;
+	int ttl;
+	int pos = PCI_CFG_SPACE_SIZE;
 
-	if (dev->cfg_size <= 256)
+	/* minimum 8 bytes per capability */
+	ttl = (PCI_CFG_SPACE_EXP_SIZE - PCI_CFG_SPACE_SIZE) / 8;
+
+	if (dev->cfg_size <= PCI_CFG_SPACE_SIZE)
 		return 0;
 
 	if (pci_read_config_dword(dev, pos, &header) != PCIBIOS_SUCCESSFUL)
@@ -234,7 +237,7 @@ int pci_find_ext_capability(struct pci_dev *dev, int cap)
 			return pos;
 
 		pos = PCI_EXT_CAP_NEXT(header);
-		if (pos < 0x100)
+		if (pos < PCI_CFG_SPACE_SIZE)
 			break;
 
 		if (pci_read_config_dword(dev, pos, &header) != PCIBIOS_SUCCESSFUL)

commit ec84f1268fcf16c4a852fdb38b3a541748644918
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Tue Sep 23 11:43:34 2008 -0700

    PCI: fix -Wakpm warnings in pci_pm_init debug output
    
    Checkpatch would have complained about this but neither Bjorn nor myself
    ran it prior to pushing.  Fixup the issues Andrew pointed out.
    
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index e1a17b85447b..09dc893c81db 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1270,8 +1270,8 @@ void pci_pm_init(struct pci_dev *dev)
 
 		if (dev->d1_support || dev->d2_support)
 			dev_printk(KERN_DEBUG, &dev->dev, "supports%s%s\n",
-				   dev->d1_support ? " D1": "",
-				   dev->d2_support ? " D2": "");
+				   dev->d1_support ? " D1" : "",
+				   dev->d2_support ? " D2" : "");
 	}
 
 	pmc &= PCI_PM_CAP_PME_MASK;

commit c9ed77eeba8ec2541a40918210bcc676acacd43a
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Fri Aug 22 09:37:02 2008 -0600

    PCI: tidy PME support messages
    
    This patch changes these two messages:
    
        pci 0000:00:03.0: supports D1
        pci 0000:00:03.0: supports D2
    
    to this:
    
        pci 0000:00:03.0: supports D1 D2
    
    It also trivially converts a "dev_printk(KERN_INFO, ...)" to
    "dev_info(...)".
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 2797112c9400..e1a17b85447b 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1263,25 +1263,25 @@ void pci_pm_init(struct pci_dev *dev)
 	dev->d1_support = false;
 	dev->d2_support = false;
 	if (!pci_no_d1d2(dev)) {
-		if (pmc & PCI_PM_CAP_D1) {
-			dev_printk(KERN_DEBUG, &dev->dev, "supports D1\n");
+		if (pmc & PCI_PM_CAP_D1)
 			dev->d1_support = true;
-		}
-		if (pmc & PCI_PM_CAP_D2) {
-			dev_printk(KERN_DEBUG, &dev->dev, "supports D2\n");
+		if (pmc & PCI_PM_CAP_D2)
 			dev->d2_support = true;
-		}
+
+		if (dev->d1_support || dev->d2_support)
+			dev_printk(KERN_DEBUG, &dev->dev, "supports%s%s\n",
+				   dev->d1_support ? " D1": "",
+				   dev->d2_support ? " D2": "");
 	}
 
 	pmc &= PCI_PM_CAP_PME_MASK;
 	if (pmc) {
-		dev_printk(KERN_INFO, &dev->dev,
-			"PME# supported from%s%s%s%s%s\n",
-			(pmc & PCI_PM_CAP_PME_D0) ? " D0" : "",
-			(pmc & PCI_PM_CAP_PME_D1) ? " D1" : "",
-			(pmc & PCI_PM_CAP_PME_D2) ? " D2" : "",
-			(pmc & PCI_PM_CAP_PME_D3) ? " D3hot" : "",
-			(pmc & PCI_PM_CAP_PME_D3cold) ? " D3cold" : "");
+		dev_info(&dev->dev, "PME# supported from%s%s%s%s%s\n",
+			 (pmc & PCI_PM_CAP_PME_D0) ? " D0" : "",
+			 (pmc & PCI_PM_CAP_PME_D1) ? " D1" : "",
+			 (pmc & PCI_PM_CAP_PME_D2) ? " D2" : "",
+			 (pmc & PCI_PM_CAP_PME_D3) ? " D3hot" : "",
+			 (pmc & PCI_PM_CAP_PME_D3cold) ? " D3cold" : "");
 		dev->pme_support = pmc >> PCI_PM_CAP_PME_SHIFT;
 		/*
 		 * Make device's PM flags reflect the wake-up capability, but

commit 0235c4fc7fc6f621dc0dd89eba102ad5aa373390
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Aug 18 21:38:00 2008 +0200

    PCI PM: Introduce function pci_wake_from_d3
    
    Many device drivers use the following sequence of statements to enable
    the device to wake up the system while being in the D3_hot or D3_cold
    low power state:
    
            pci_enable_wake(pdev, PCI_D3hot, 1);
            pci_enable_wake(pdev, PCI_D3cold, 1);
    
    However, the second call is not necessary if the first one succeeds (the
    ordering of the statements above doesn't matter here) and it may even be
    harmful, because we are not supposed to enable PME# after the wake-up
    power has been enabled for the device.
    
    To allow drivers to overcome this problem, introduce function
    pci_wake_from_d3() that will enable the device to wake up the system
    from any of D3_hot and D3_cold as long as the wake-up from at least one
    of them is supported.
    
    Acked-by: Pavel Machek <pavel@suse.cz>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index dbe9f39f4436..2797112c9400 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1126,6 +1126,27 @@ int pci_enable_wake(struct pci_dev *dev, pci_power_t state, int enable)
 	return pme_done ? 0 : error;
 }
 
+/**
+ * pci_wake_from_d3 - enable/disable device to wake up from D3_hot or D3_cold
+ * @dev: PCI device to prepare
+ * @enable: True to enable wake-up event generation; false to disable
+ *
+ * Many drivers want the device to wake up the system from D3_hot or D3_cold
+ * and this function allows them to set that up cleanly - pci_enable_wake()
+ * should not be called twice in a row to enable wake-up due to PCI PM vs ACPI
+ * ordering constraints.
+ *
+ * This function only returns error code if the device is not capable of
+ * generating PME# from both D3_hot and D3_cold, and the platform is unable to
+ * enable wake-up power for it.
+ */
+int pci_wake_from_d3(struct pci_dev *dev, bool enable)
+{
+	return pci_pme_capable(dev, PCI_D3cold) ?
+			pci_enable_wake(dev, PCI_D3cold, enable) :
+			pci_enable_wake(dev, PCI_D3hot, enable);
+}
+
 /**
  * pci_target_state - find an appropriate low power state for a given PCI dev
  * @dev: PCI device
@@ -1942,6 +1963,7 @@ EXPORT_SYMBOL(pci_restore_state);
 EXPORT_SYMBOL(pci_pme_capable);
 EXPORT_SYMBOL(pci_pme_active);
 EXPORT_SYMBOL(pci_enable_wake);
+EXPORT_SYMBOL(pci_wake_from_d3);
 EXPORT_SYMBOL(pci_target_state);
 EXPORT_SYMBOL(pci_prepare_to_sleep);
 EXPORT_SYMBOL(pci_back_from_sleep);

commit 096e6f673dc02a6394dc9a7d8f8735c6978f5b91
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Mon Oct 20 15:07:37 2008 +1100

    pci: Use new %pR to print resource ranges
    
    This converts things in drivers/pci to use %pR to printout the
    content of a struct resource instead of hand-casted %llx or
    other variants.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index c9884bba22de..dbe9f39f4436 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1358,11 +1358,10 @@ int pci_request_region(struct pci_dev *pdev, int bar, const char *res_name)
 	return 0;
 
 err_out:
-	dev_warn(&pdev->dev, "BAR %d: can't reserve %s region [%#llx-%#llx]\n",
+	dev_warn(&pdev->dev, "BAR %d: can't reserve %s region %pR\n",
 		 bar,
 		 pci_resource_flags(pdev, bar) & IORESOURCE_IO ? "I/O" : "mem",
-		 (unsigned long long)pci_resource_start(pdev, bar),
-		 (unsigned long long)pci_resource_end(pdev, bar));
+		 &pdev->resource[bar]);
 	return -EBUSY;
 }
 

commit 5a6c9b60b4cc15b22d3102b0033e5cb842125456
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri Aug 8 00:14:24 2008 +0200

    PCI PM: Export pci_pme_active to drivers
    
    Export pci_pme_active() to drivers, so that they can clear the
    PME_status bit and disable PME# for their devices without involving
    ACPI.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 0a3d856833fc..c9884bba22de 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1060,7 +1060,7 @@ bool pci_pme_capable(struct pci_dev *dev, pci_power_t state)
  * The caller must verify that the device is capable of generating PME# before
  * calling this function with @enable equal to 'true'.
  */
-static void pci_pme_active(struct pci_dev *dev, bool enable)
+void pci_pme_active(struct pci_dev *dev, bool enable)
 {
 	u16 pmcsr;
 
@@ -1941,6 +1941,7 @@ EXPORT_SYMBOL(pci_set_power_state);
 EXPORT_SYMBOL(pci_save_state);
 EXPORT_SYMBOL(pci_restore_state);
 EXPORT_SYMBOL(pci_pme_capable);
+EXPORT_SYMBOL(pci_pme_active);
 EXPORT_SYMBOL(pci_enable_wake);
 EXPORT_SYMBOL(pci_target_state);
 EXPORT_SYMBOL(pci_prepare_to_sleep);

commit 979b1791e5b8f8b556faeec4c48339e7ed63af9f
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Thu Jul 24 17:18:38 2008 +0100

    PCI: add D3 power state avoidance quirk
    
    Libata has some hacks to deal with certain controllers going silly in D3
    state. The right way to handle this is to keep a PCI device flag for
    such devices. That can then be generalised for no ATA devices with power
    problems.
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index c95f77d65718..0a3d856833fc 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -572,6 +572,10 @@ int pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 		if (!ret)
 			pci_update_current_state(dev);
 	}
+	/* This device is quirked not to be put into D3, so
+	   don't put it in D3 */
+	if (state == PCI_D3hot && (dev->dev_flags & PCI_DEV_FLAGS_NO_D3))
+		return 0;
 
 	error = pci_raw_set_power_state(dev, state);
 

commit 37139074233a5bbec54ae01ab580e5788a248cc3
Author: Jesse Barnes <jbarnes@hobbes.lan>
Date:   Mon Jul 28 11:49:26 2008 -0700

    PCI: document pci_target_state
    
    The empty kdoc was causing warnings, so provide some actual documentation.
    
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index e9c356236d27..c95f77d65718 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1123,6 +1123,12 @@ int pci_enable_wake(struct pci_dev *dev, pci_power_t state, int enable)
 }
 
 /**
+ * pci_target_state - find an appropriate low power state for a given PCI dev
+ * @dev: PCI device
+ *
+ * Use underlying platform code to find a supported low power state for @dev.
+ * If the platform can't manage @dev, return the deepest state from which it
+ * can generate wake events, based on any available PME info.
  */
 pci_power_t pci_target_state(struct pci_dev *dev)
 {

commit e5899e1b7d73e67de758a32174a859cc2586c0b9
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sat Jul 19 14:39:24 2008 +0200

    PCI PM: make more PCI PM core functionality available to drivers
    
    Make more PCI PM core functionality available to drivers
    
    * Export pci_pme_capable() so that it can be called directly by
      drivers (for example, tg3 needs that).
    
    * Move the state choosing part of pci_prepare_to_sleep() to a
      separate function, pci_target_state(), that can be called directly
      by drivers (for example, tg3 needs that).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index d00f0e0d8453..e9c356236d27 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1040,7 +1040,7 @@ int pci_set_pcie_reset_state(struct pci_dev *dev, enum pcie_reset_state state)
  * @dev: PCI device to handle.
  * @state: PCI state from which device will issue PME#.
  */
-static bool pci_pme_capable(struct pci_dev *dev, pci_power_t state)
+bool pci_pme_capable(struct pci_dev *dev, pci_power_t state)
 {
 	if (!dev->pm_cap)
 		return false;
@@ -1123,17 +1123,10 @@ int pci_enable_wake(struct pci_dev *dev, pci_power_t state, int enable)
 }
 
 /**
- * pci_prepare_to_sleep - prepare PCI device for system-wide transition into a sleep state
- * @dev: Device to handle.
- *
- * Choose the power state appropriate for the device depending on whether
- * it can wake up the system and/or is power manageable by the platform
- * (PCI_D3hot is the default) and put the device into that state.
  */
-int pci_prepare_to_sleep(struct pci_dev *dev)
+pci_power_t pci_target_state(struct pci_dev *dev)
 {
 	pci_power_t target_state = PCI_D3hot;
-	int error;
 
 	if (platform_pci_power_manageable(dev)) {
 		/*
@@ -1160,7 +1153,7 @@ int pci_prepare_to_sleep(struct pci_dev *dev)
 		 * to generate PME#.
 		 */
 		if (!dev->pm_cap)
-			return -EIO;
+			return PCI_POWER_ERROR;
 
 		if (dev->pme_support) {
 			while (target_state
@@ -1169,6 +1162,25 @@ int pci_prepare_to_sleep(struct pci_dev *dev)
 		}
 	}
 
+	return target_state;
+}
+
+/**
+ * pci_prepare_to_sleep - prepare PCI device for system-wide transition into a sleep state
+ * @dev: Device to handle.
+ *
+ * Choose the power state appropriate for the device depending on whether
+ * it can wake up the system and/or is power manageable by the platform
+ * (PCI_D3hot is the default) and put the device into that state.
+ */
+int pci_prepare_to_sleep(struct pci_dev *dev)
+{
+	pci_power_t target_state = pci_target_state(dev);
+	int error;
+
+	if (target_state == PCI_POWER_ERROR)
+		return -EIO;
+
 	pci_enable_wake(dev, target_state, true);
 
 	error = pci_set_power_state(dev, target_state);
@@ -1918,7 +1930,9 @@ EXPORT_SYMBOL(pci_select_bars);
 EXPORT_SYMBOL(pci_set_power_state);
 EXPORT_SYMBOL(pci_save_state);
 EXPORT_SYMBOL(pci_restore_state);
+EXPORT_SYMBOL(pci_pme_capable);
 EXPORT_SYMBOL(pci_enable_wake);
+EXPORT_SYMBOL(pci_target_state);
 EXPORT_SYMBOL(pci_prepare_to_sleep);
 EXPORT_SYMBOL(pci_back_from_sleep);
 EXPORT_SYMBOL_GPL(pci_set_pcie_reset_state);

commit 443bd1c4ddab9d2144f4c9b85e0abccf2d93423f
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Mon Jul 21 09:27:18 2008 -0700

    pci kernel-doc fatal error
    
    Fix kernel-doc comments so that they don't produce errors.
    Also cut some extraneous copy-paste text.
    
    Error(linhead//drivers/pci/pci.c:1133): duplicate section name 'Description'
    Error(linhead//drivers/pci/pci.c:1189): duplicate section name 'Description'
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 44a46c92b721..d00f0e0d8453 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1123,8 +1123,7 @@ int pci_enable_wake(struct pci_dev *dev, pci_power_t state, int enable)
 }
 
 /**
- * pci_prepare_to_sleep - prepare PCI device for system-wide transition into
- *                        a sleep state
+ * pci_prepare_to_sleep - prepare PCI device for system-wide transition into a sleep state
  * @dev: Device to handle.
  *
  * Choose the power state appropriate for the device depending on whether
@@ -1181,8 +1180,7 @@ int pci_prepare_to_sleep(struct pci_dev *dev)
 }
 
 /**
- * pci_back_from_sleep - turn PCI device on during system-wide transition into
- *                       the working state a sleep state
+ * pci_back_from_sleep - turn PCI device on during system-wide transition into working state
  * @dev: Device to handle.
  *
  * Disable device's sytem wake-up capability and put it into D0.

commit c300bd2fb583afb6d68804afd38bc90b31310d95
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Thu Jul 10 02:16:44 2008 +0200

    PCI: include linux/pm_wakeup.h for device_set_wakeup_capable
    
    drivers/pci/pci.c needs pm_wakeup.h since it uses device_set_wakup_capable().
    The latter also needs to be stubbed out for !CONFIG_PM.
    
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index ace518116cc5..44a46c92b721 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -17,6 +17,7 @@
 #include <linux/string.h>
 #include <linux/log2.h>
 #include <linux/pci-aspm.h>
+#include <linux/pm_wakeup.h>
 #include <asm/dma.h>	/* isa_dma_bridge_buggy */
 #include "pci.h"
 

commit c157dfa3e4aea5775389f2f4d53c040bc8813af1
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Jul 13 22:45:06 2008 +0200

    PCI PM: Fix pci_prepare_to_sleep
    
    The recently introduced pci_prepare_to_sleep() needs the following fix,
    because there are systems which are not power manageable by ACPI (ie.
    ACPI doesn't provide methods to put the device into low power states and
    back), but require ACPI hooks to be executed for wake-up to work.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index e632a58ba5d0..ace518116cc5 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1152,7 +1152,6 @@ int pci_prepare_to_sleep(struct pci_dev *dev)
 				break;
 		default:
 			target_state = state;
-			pci_enable_wake(dev, target_state, true);
 		}
 	} else if (device_may_wakeup(&dev->dev)) {
 		/*
@@ -1167,10 +1166,11 @@ int pci_prepare_to_sleep(struct pci_dev *dev)
 			while (target_state
 			      && !(dev->pme_support & (1 << target_state)))
 				target_state--;
-			pci_pme_active(dev, true);
 		}
 	}
 
+	pci_enable_wake(dev, target_state, true);
+
 	error = pci_set_power_state(dev, target_state);
 
 	if (error)

commit 337001b6c42938f49a880b1b8306c3ed771a7e61
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Jul 7 03:36:24 2008 +0200

    PCI: Simplify PCI device PM code
    
    If the offset of PCI device's PM capability in its configuration space,
    the mask of states that the device supports PME# from and the D1 and D2
    support bits are cached in the corresponding struct pci_dev, the PCI
    device PM code can be simplified quite a bit.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 1b0ec45e9934..e632a58ba5d0 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -419,7 +419,6 @@ static inline int platform_pci_sleep_wake(struct pci_dev *dev, bool enable)
  * pci_raw_set_power_state - Use PCI PM registers to set the power state of
  *                           given PCI device
  * @dev: PCI device to handle.
- * @pm: PCI PM capability offset of the device.
  * @state: PCI power state (D0, D1, D2, D3hot) to put the device into.
  *
  * RETURN VALUE:
@@ -430,12 +429,12 @@ static inline int platform_pci_sleep_wake(struct pci_dev *dev, bool enable)
  * 0 if device's power state has been successfully changed.
  */
 static int
-pci_raw_set_power_state(struct pci_dev *dev, int pm, pci_power_t state)
+pci_raw_set_power_state(struct pci_dev *dev, pci_power_t state)
 {
-	u16 pmcsr, pmc;
+	u16 pmcsr;
 	bool need_restore = false;
 
-	if (!pm)
+	if (!dev->pm_cap)
 		return -EIO;
 
 	if (state < PCI_D0 || state > PCI_D3hot)
@@ -455,20 +454,12 @@ pci_raw_set_power_state(struct pci_dev *dev, int pm, pci_power_t state)
 		return -EINVAL;
 	}
 
-	pci_read_config_word(dev, pm + PCI_PM_PMC, &pmc);
-
-	if ((pmc & PCI_PM_CAP_VER_MASK) > 3) {
-		dev_err(&dev->dev, "unsupported PM cap regs version (%u)\n",
-			pmc & PCI_PM_CAP_VER_MASK);
-		return -EIO;
-	}
-
 	/* check if this device supports the desired state */
-	if ((state == PCI_D1 && !(pmc & PCI_PM_CAP_D1))
-	   || (state == PCI_D2 && !(pmc & PCI_PM_CAP_D2)))
+	if ((state == PCI_D1 && !dev->d1_support)
+	   || (state == PCI_D2 && !dev->d2_support))
 		return -EIO;
 
-	pci_read_config_word(dev, pm + PCI_PM_CTRL, &pmcsr);
+	pci_read_config_word(dev, dev->pm_cap + PCI_PM_CTRL, &pmcsr);
 
 	/* If we're (effectively) in D3, force entire word to 0.
 	 * This doesn't affect PME_Status, disables PME_En, and
@@ -492,7 +483,7 @@ pci_raw_set_power_state(struct pci_dev *dev, int pm, pci_power_t state)
 	}
 
 	/* enter specified state */
-	pci_write_config_word(dev, pm + PCI_PM_CTRL, pmcsr);
+	pci_write_config_word(dev, dev->pm_cap + PCI_PM_CTRL, pmcsr);
 
 	/* Mandatory power management transition delays */
 	/* see PCI PM 1.1 5.6.1 table 18 */
@@ -528,14 +519,13 @@ pci_raw_set_power_state(struct pci_dev *dev, int pm, pci_power_t state)
  * pci_update_current_state - Read PCI power state of given device from its
  *                            PCI PM registers and cache it
  * @dev: PCI device to handle.
- * @pm: PCI PM capability offset of the device.
  */
-static void pci_update_current_state(struct pci_dev *dev, int pm)
+static void pci_update_current_state(struct pci_dev *dev)
 {
-	if (pm) {
+	if (dev->pm_cap) {
 		u16 pmcsr;
 
-		pci_read_config_word(dev, pm + PCI_PM_CTRL, &pmcsr);
+		pci_read_config_word(dev, dev->pm_cap + PCI_PM_CTRL, &pmcsr);
 		dev->current_state = (pmcsr & PCI_PM_CTRL_STATE_MASK);
 	}
 }
@@ -557,7 +547,7 @@ static void pci_update_current_state(struct pci_dev *dev, int pm)
  */
 int pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 {
-	int pm, error;
+	int error;
 
 	/* bound the state we're entering */
 	if (state > PCI_D3hot)
@@ -572,9 +562,6 @@ int pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 		 */
 		return 0;
 
-	/* Find PCI PM capability in the list */
-	pm = pci_find_capability(dev, PCI_CAP_ID_PM);
-
 	if (state == PCI_D0 && platform_pci_power_manageable(dev)) {
 		/*
 		 * Allow the platform to change the state, for example via ACPI
@@ -582,16 +569,16 @@ int pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 		 */
 		int ret = platform_pci_set_power_state(dev, PCI_D0);
 		if (!ret)
-			pci_update_current_state(dev, pm);
+			pci_update_current_state(dev);
 	}
 
-	error = pci_raw_set_power_state(dev, pm, state);
+	error = pci_raw_set_power_state(dev, state);
 
 	if (state > PCI_D0 && platform_pci_power_manageable(dev)) {
 		/* Allow the platform to finalize the transition */
 		int ret = platform_pci_set_power_state(dev, state);
 		if (!ret) {
-			pci_update_current_state(dev, pm);
+			pci_update_current_state(dev);
 			error = 0;
 		}
 	}
@@ -1050,48 +1037,38 @@ int pci_set_pcie_reset_state(struct pci_dev *dev, enum pcie_reset_state state)
 /**
  * pci_pme_capable - check the capability of PCI device to generate PME#
  * @dev: PCI device to handle.
- * @pm: PCI PM capability offset of the device.
  * @state: PCI state from which device will issue PME#.
  */
-static bool pci_pme_capable(struct pci_dev *dev, int pm, pci_power_t state)
+static bool pci_pme_capable(struct pci_dev *dev, pci_power_t state)
 {
-	u16 pmc;
-
-	if (!pm)
+	if (!dev->pm_cap)
 		return false;
 
-	/* Check device's ability to generate PME# from given state */
-	pci_read_config_word(dev, pm + PCI_PM_PMC, &pmc);
-
-	pmc &= PCI_PM_CAP_PME_MASK;
-	pmc >>= ffs(PCI_PM_CAP_PME_MASK) - 1;   /* First bit of mask */
-
-	return !!(pmc & (1 << state));
+	return !!(dev->pme_support & (1 << state));
 }
 
 /**
  * pci_pme_active - enable or disable PCI device's PME# function
  * @dev: PCI device to handle.
- * @pm: PCI PM capability offset of the device.
  * @enable: 'true' to enable PME# generation; 'false' to disable it.
  *
  * The caller must verify that the device is capable of generating PME# before
  * calling this function with @enable equal to 'true'.
  */
-static void pci_pme_active(struct pci_dev *dev, int pm, bool enable)
+static void pci_pme_active(struct pci_dev *dev, bool enable)
 {
 	u16 pmcsr;
 
-	if (!pm)
+	if (!dev->pm_cap)
 		return;
 
-	pci_read_config_word(dev, pm + PCI_PM_CTRL, &pmcsr);
+	pci_read_config_word(dev, dev->pm_cap + PCI_PM_CTRL, &pmcsr);
 	/* Clear PME_Status by writing 1 to it and enable PME# */
 	pmcsr |= PCI_PM_CTRL_PME_STATUS | PCI_PM_CTRL_PME_ENABLE;
 	if (!enable)
 		pmcsr &= ~PCI_PM_CTRL_PME_ENABLE;
 
-	pci_write_config_word(dev, pm + PCI_PM_CTRL, pmcsr);
+	pci_write_config_word(dev, dev->pm_cap + PCI_PM_CTRL, pmcsr);
 
 	dev_printk(KERN_INFO, &dev->dev, "PME# %s\n",
 			enable ? "enabled" : "disabled");
@@ -1118,7 +1095,6 @@ static void pci_pme_active(struct pci_dev *dev, int pm, bool enable)
  */
 int pci_enable_wake(struct pci_dev *dev, pci_power_t state, int enable)
 {
-	int pm;
 	int error = 0;
 	bool pme_done = false;
 
@@ -1134,9 +1110,8 @@ int pci_enable_wake(struct pci_dev *dev, pci_power_t state, int enable)
 	if (!enable && platform_pci_can_wakeup(dev))
 		error = platform_pci_sleep_wake(dev, false);
 
-	pm = pci_find_capability(dev, PCI_CAP_ID_PM);
-	if (!enable || pci_pme_capable(dev, pm, state)) {
-		pci_pme_active(dev, pm, enable);
+	if (!enable || pci_pme_capable(dev, state)) {
+		pci_pme_active(dev, enable);
 		pme_done = true;
 	}
 
@@ -1158,7 +1133,6 @@ int pci_enable_wake(struct pci_dev *dev, pci_power_t state, int enable)
 int pci_prepare_to_sleep(struct pci_dev *dev)
 {
 	pci_power_t target_state = PCI_D3hot;
-	int pm = pci_find_capability(dev, PCI_CAP_ID_PM);
 	int error;
 
 	if (platform_pci_power_manageable(dev)) {
@@ -1186,23 +1160,14 @@ int pci_prepare_to_sleep(struct pci_dev *dev)
 		 * wake-up events, make it the target state and enable device
 		 * to generate PME#.
 		 */
-		u16 pmc;
-
-		if (!pm)
+		if (!dev->pm_cap)
 			return -EIO;
 
-		pci_read_config_word(dev, pm + PCI_PM_PMC, &pmc);
-		if (pmc & PCI_PM_CAP_PME_MASK) {
-			if (!(pmc & PCI_PM_CAP_PME_D3)) {
-				/* Device cannot generate PME# from D3_hot */
-				if (pmc & PCI_PM_CAP_PME_D2)
-					target_state = PCI_D2;
-				else if (pmc & PCI_PM_CAP_PME_D1)
-					target_state = PCI_D1;
-				else
-					target_state = PCI_D0;
-			}
-			pci_pme_active(dev, pm, true);
+		if (dev->pme_support) {
+			while (target_state
+			      && !(dev->pme_support & (1 << target_state)))
+				target_state--;
+			pci_pme_active(dev, true);
 		}
 	}
 
@@ -1236,6 +1201,8 @@ void pci_pm_init(struct pci_dev *dev)
 	int pm;
 	u16 pmc;
 
+	dev->pm_cap = 0;
+
 	/* find PCI PM capability in list */
 	pm = pci_find_capability(dev, PCI_CAP_ID_PM);
 	if (!pm)
@@ -1249,7 +1216,23 @@ void pci_pm_init(struct pci_dev *dev)
 		return;
 	}
 
-	if (pmc & PCI_PM_CAP_PME_MASK) {
+	dev->pm_cap = pm;
+
+	dev->d1_support = false;
+	dev->d2_support = false;
+	if (!pci_no_d1d2(dev)) {
+		if (pmc & PCI_PM_CAP_D1) {
+			dev_printk(KERN_DEBUG, &dev->dev, "supports D1\n");
+			dev->d1_support = true;
+		}
+		if (pmc & PCI_PM_CAP_D2) {
+			dev_printk(KERN_DEBUG, &dev->dev, "supports D2\n");
+			dev->d2_support = true;
+		}
+	}
+
+	pmc &= PCI_PM_CAP_PME_MASK;
+	if (pmc) {
 		dev_printk(KERN_INFO, &dev->dev,
 			"PME# supported from%s%s%s%s%s\n",
 			(pmc & PCI_PM_CAP_PME_D0) ? " D0" : "",
@@ -1257,6 +1240,7 @@ void pci_pm_init(struct pci_dev *dev)
 			(pmc & PCI_PM_CAP_PME_D2) ? " D2" : "",
 			(pmc & PCI_PM_CAP_PME_D3) ? " D3hot" : "",
 			(pmc & PCI_PM_CAP_PME_D3cold) ? " D3cold" : "");
+		dev->pme_support = pmc >> PCI_PM_CAP_PME_SHIFT;
 		/*
 		 * Make device's PM flags reflect the wake-up capability, but
 		 * let the user space enable it to wake up the system as needed.
@@ -1264,7 +1248,9 @@ void pci_pm_init(struct pci_dev *dev)
 		device_set_wakeup_capable(&dev->dev, true);
 		device_set_wakeup_enable(&dev->dev, false);
 		/* Disable the PME# generation functionality */
-		pci_pme_active(dev, pm, false);
+		pci_pme_active(dev, false);
+	} else {
+		dev->pme_support = 0;
 	}
 }
 

commit 404cc2d8ce41ed4031958fba8e633767e8a2e028
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Jul 7 03:35:26 2008 +0200

    PCI PM: Introduce pci_prepare_to_sleep and pci_back_from_sleep
    
    Introduce functions pci_prepare_to_sleep() and pci_back_from_sleep(),
    to be used by the PCI drivers that want to place their devices into
    the lowest power state appropiate for them (PCI_D3hot, if the device
    is not supposed to wake up the system, or the deepest state from
    which the wake-up is possible, otherwise) while the system is being
    prepared to go into a sleeping state and to put them back into D0
    during the subsequent transition to the working state.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index a6b1b6f96abc..1b0ec45e9934 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1146,6 +1146,87 @@ int pci_enable_wake(struct pci_dev *dev, pci_power_t state, int enable)
 	return pme_done ? 0 : error;
 }
 
+/**
+ * pci_prepare_to_sleep - prepare PCI device for system-wide transition into
+ *                        a sleep state
+ * @dev: Device to handle.
+ *
+ * Choose the power state appropriate for the device depending on whether
+ * it can wake up the system and/or is power manageable by the platform
+ * (PCI_D3hot is the default) and put the device into that state.
+ */
+int pci_prepare_to_sleep(struct pci_dev *dev)
+{
+	pci_power_t target_state = PCI_D3hot;
+	int pm = pci_find_capability(dev, PCI_CAP_ID_PM);
+	int error;
+
+	if (platform_pci_power_manageable(dev)) {
+		/*
+		 * Call the platform to choose the target state of the device
+		 * and enable wake-up from this state if supported.
+		 */
+		pci_power_t state = platform_pci_choose_state(dev);
+
+		switch (state) {
+		case PCI_POWER_ERROR:
+		case PCI_UNKNOWN:
+			break;
+		case PCI_D1:
+		case PCI_D2:
+			if (pci_no_d1d2(dev))
+				break;
+		default:
+			target_state = state;
+			pci_enable_wake(dev, target_state, true);
+		}
+	} else if (device_may_wakeup(&dev->dev)) {
+		/*
+		 * Find the deepest state from which the device can generate
+		 * wake-up events, make it the target state and enable device
+		 * to generate PME#.
+		 */
+		u16 pmc;
+
+		if (!pm)
+			return -EIO;
+
+		pci_read_config_word(dev, pm + PCI_PM_PMC, &pmc);
+		if (pmc & PCI_PM_CAP_PME_MASK) {
+			if (!(pmc & PCI_PM_CAP_PME_D3)) {
+				/* Device cannot generate PME# from D3_hot */
+				if (pmc & PCI_PM_CAP_PME_D2)
+					target_state = PCI_D2;
+				else if (pmc & PCI_PM_CAP_PME_D1)
+					target_state = PCI_D1;
+				else
+					target_state = PCI_D0;
+			}
+			pci_pme_active(dev, pm, true);
+		}
+	}
+
+	error = pci_set_power_state(dev, target_state);
+
+	if (error)
+		pci_enable_wake(dev, target_state, false);
+
+	return error;
+}
+
+/**
+ * pci_back_from_sleep - turn PCI device on during system-wide transition into
+ *                       the working state a sleep state
+ * @dev: Device to handle.
+ *
+ * Disable device's sytem wake-up capability and put it into D0.
+ */
+int pci_back_from_sleep(struct pci_dev *dev)
+{
+	pci_enable_wake(dev, PCI_D0, false);
+	return pci_set_power_state(dev, PCI_D0);
+}
+
 /**
  * pci_pm_init - Initialize PM functions of given PCI device
  * @dev: PCI device to handle.
@@ -1853,5 +1934,7 @@ EXPORT_SYMBOL(pci_set_power_state);
 EXPORT_SYMBOL(pci_save_state);
 EXPORT_SYMBOL(pci_restore_state);
 EXPORT_SYMBOL(pci_enable_wake);
+EXPORT_SYMBOL(pci_prepare_to_sleep);
+EXPORT_SYMBOL(pci_back_from_sleep);
 EXPORT_SYMBOL_GPL(pci_set_pcie_reset_state);
 

commit eb9d0fe40e313c0a74115ef456a2e43a6c8da72f
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Jul 7 03:34:48 2008 +0200

    PCI ACPI: Rework PCI handling of wake-up
    
    * Introduce function acpi_pm_device_sleep_wake() for enabling and
      disabling the system wake-up capability of devices that are power
      manageable by ACPI.
    
    * Introduce function acpi_bus_can_wakeup() allowing other (dependent)
      subsystems to check if ACPI is able to enable the system wake-up
      capability of given device.
    
    * Introduce callback .sleep_wake() in struct pci_platform_pm_ops and
      for the ACPI PCI 'driver' make it use acpi_pm_device_sleep_wake().
    
    * Introduce callback .can_wakeup() in struct pci_platform_pm_ops and
      for the ACPI 'driver' make it use acpi_bus_can_wakeup().
    
    * Move the PME# handlig code out of pci_enable_wake() and split it
      into two functions, pci_pme_capable() and pci_pme_active(),
      allowing the caller to check if given device is capable of
      generating PME# from given power state and to enable/disable the
      device's PME# functionality, respectively.
    
    * Modify pci_enable_wake() to use the new ACPI callbacks and the new
      PME#-related functions.
    
    * Drop the generic .platform_enable_wakeup() callback that is not
      used any more.
    
    * Introduce device_set_wakeup_capable() that will set the
      power.can_wakeup flag of given device.
    
    * Rework PCI device PM initialization so that, if given device is
      capable of generating wake-up events, either natively through the
      PME# mechanism, or with the help of the platform, its
      power.can_wakeup flag is set and its power.should_wakeup flag is
      unset as appropriate.
    
    * Make ACPI set the power.can_wakeup flag for devices found to be
      wake-up capable by it.
    
    * Make the ACPI wake-up code enable/disable GPEs for devices that
      have the wakeup.flags.prepared flag set (which means that their
      wake-up power has been enabled).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 20e28077b96d..a6b1b6f96abc 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -380,7 +380,8 @@ static struct pci_platform_pm_ops *pci_platform_pm;
 
 int pci_set_platform_pm(struct pci_platform_pm_ops *ops)
 {
-	if (!ops->is_manageable || !ops->set_state || !ops->choose_state)
+	if (!ops->is_manageable || !ops->set_state || !ops->choose_state
+	    || !ops->sleep_wake || !ops->can_wakeup)
 		return -EINVAL;
 	pci_platform_pm = ops;
 	return 0;
@@ -403,6 +404,17 @@ static inline pci_power_t platform_pci_choose_state(struct pci_dev *dev)
 			pci_platform_pm->choose_state(dev) : PCI_POWER_ERROR;
 }
 
+static inline bool platform_pci_can_wakeup(struct pci_dev *dev)
+{
+	return pci_platform_pm ? pci_platform_pm->can_wakeup(dev) : false;
+}
+
+static inline int platform_pci_sleep_wake(struct pci_dev *dev, bool enable)
+{
+	return pci_platform_pm ?
+			pci_platform_pm->sleep_wake(dev, enable) : -ENODEV;
+}
+
 /**
  * pci_raw_set_power_state - Use PCI PM registers to set the power state of
  *                           given PCI device
@@ -1035,6 +1047,56 @@ int pci_set_pcie_reset_state(struct pci_dev *dev, enum pcie_reset_state state)
 	return pcibios_set_pcie_reset_state(dev, state);
 }
 
+/**
+ * pci_pme_capable - check the capability of PCI device to generate PME#
+ * @dev: PCI device to handle.
+ * @pm: PCI PM capability offset of the device.
+ * @state: PCI state from which device will issue PME#.
+ */
+static bool pci_pme_capable(struct pci_dev *dev, int pm, pci_power_t state)
+{
+	u16 pmc;
+
+	if (!pm)
+		return false;
+
+	/* Check device's ability to generate PME# from given state */
+	pci_read_config_word(dev, pm + PCI_PM_PMC, &pmc);
+
+	pmc &= PCI_PM_CAP_PME_MASK;
+	pmc >>= ffs(PCI_PM_CAP_PME_MASK) - 1;   /* First bit of mask */
+
+	return !!(pmc & (1 << state));
+}
+
+/**
+ * pci_pme_active - enable or disable PCI device's PME# function
+ * @dev: PCI device to handle.
+ * @pm: PCI PM capability offset of the device.
+ * @enable: 'true' to enable PME# generation; 'false' to disable it.
+ *
+ * The caller must verify that the device is capable of generating PME# before
+ * calling this function with @enable equal to 'true'.
+ */
+static void pci_pme_active(struct pci_dev *dev, int pm, bool enable)
+{
+	u16 pmcsr;
+
+	if (!pm)
+		return;
+
+	pci_read_config_word(dev, pm + PCI_PM_CTRL, &pmcsr);
+	/* Clear PME_Status by writing 1 to it and enable PME# */
+	pmcsr |= PCI_PM_CTRL_PME_STATUS | PCI_PM_CTRL_PME_ENABLE;
+	if (!enable)
+		pmcsr &= ~PCI_PM_CTRL_PME_ENABLE;
+
+	pci_write_config_word(dev, pm + PCI_PM_CTRL, pmcsr);
+
+	dev_printk(KERN_INFO, &dev->dev, "PME# %s\n",
+			enable ? "enabled" : "disabled");
+}
+
 /**
  * pci_enable_wake - enable PCI device as wakeup event source
  * @dev: PCI device affected
@@ -1046,66 +1108,83 @@ int pci_set_pcie_reset_state(struct pci_dev *dev, enum pcie_reset_state state)
  * called automatically by this routine.
  *
  * Devices with legacy power management (no standard PCI PM capabilities)
- * always require such platform hooks.  Depending on the platform, devices
- * supporting the standard PCI PME# signal may require such platform hooks;
- * they always update bits in config space to allow PME# generation.
+ * always require such platform hooks.
  *
- * -EIO is returned if the device can't ever be a wakeup event source.
- * -EINVAL is returned if the device can't generate wakeup events from
- * the specified PCI state.  Returns zero if the operation is successful.
+ * RETURN VALUE:
+ * 0 is returned on success
+ * -EINVAL is returned if device is not supposed to wake up the system
+ * Error code depending on the platform is returned if both the platform and
+ * the native mechanism fail to enable the generation of wake-up events
  */
 int pci_enable_wake(struct pci_dev *dev, pci_power_t state, int enable)
 {
 	int pm;
-	int status;
-	u16 value;
-
-	/* Note that drivers should verify device_may_wakeup(&dev->dev)
-	 * before calling this function.  Platform code should report
-	 * errors when drivers try to enable wakeup on devices that
-	 * can't issue wakeups, or on which wakeups were disabled by
-	 * userspace updating the /sys/devices.../power/wakeup file.
-	 */
+	int error = 0;
+	bool pme_done = false;
 
-	status = call_platform_enable_wakeup(&dev->dev, enable);
-
-	/* find PCI PM capability in list */
-	pm = pci_find_capability(dev, PCI_CAP_ID_PM);
+	if (!device_may_wakeup(&dev->dev))
+		return -EINVAL;
 
-	/* If device doesn't support PM Capabilities, but caller wants to
-	 * disable wake events, it's a NOP.  Otherwise fail unless the
-	 * platform hooks handled this legacy device already.
+	/*
+	 * According to "PCI System Architecture" 4th ed. by Tom Shanley & Don
+	 * Anderson we should be doing PME# wake enable followed by ACPI wake
+	 * enable.  To disable wake-up we call the platform first, for symmetry.
 	 */
-	if (!pm)
-		return enable ? status : 0;
 
-	/* Check device's ability to generate PME# */
-	pci_read_config_word(dev,pm+PCI_PM_PMC,&value);
+	if (!enable && platform_pci_can_wakeup(dev))
+		error = platform_pci_sleep_wake(dev, false);
 
-	value &= PCI_PM_CAP_PME_MASK;
-	value >>= ffs(PCI_PM_CAP_PME_MASK) - 1;   /* First bit of mask */
-
-	/* Check if it can generate PME# from requested state. */
-	if (!value || !(value & (1 << state))) {
-		/* if it can't, revert what the platform hook changed,
-		 * always reporting the base "EINVAL, can't PME#" error
-		 */
-		if (enable)
-			call_platform_enable_wakeup(&dev->dev, 0);
-		return enable ? -EINVAL : 0;
+	pm = pci_find_capability(dev, PCI_CAP_ID_PM);
+	if (!enable || pci_pme_capable(dev, pm, state)) {
+		pci_pme_active(dev, pm, enable);
+		pme_done = true;
 	}
 
-	pci_read_config_word(dev, pm + PCI_PM_CTRL, &value);
+	if (enable && platform_pci_can_wakeup(dev))
+		error = platform_pci_sleep_wake(dev, true);
 
-	/* Clear PME_Status by writing 1 to it and enable PME# */
-	value |= PCI_PM_CTRL_PME_STATUS | PCI_PM_CTRL_PME_ENABLE;
+	return pme_done ? 0 : error;
+}
 
-	if (!enable)
-		value &= ~PCI_PM_CTRL_PME_ENABLE;
+/**
+ * pci_pm_init - Initialize PM functions of given PCI device
+ * @dev: PCI device to handle.
+ */
+void pci_pm_init(struct pci_dev *dev)
+{
+	int pm;
+	u16 pmc;
 
-	pci_write_config_word(dev, pm + PCI_PM_CTRL, value);
+	/* find PCI PM capability in list */
+	pm = pci_find_capability(dev, PCI_CAP_ID_PM);
+	if (!pm)
+		return;
+	/* Check device's ability to generate PME# */
+	pci_read_config_word(dev, pm + PCI_PM_PMC, &pmc);
 
-	return 0;
+	if ((pmc & PCI_PM_CAP_VER_MASK) > 3) {
+		dev_err(&dev->dev, "unsupported PM cap regs version (%u)\n",
+			pmc & PCI_PM_CAP_VER_MASK);
+		return;
+	}
+
+	if (pmc & PCI_PM_CAP_PME_MASK) {
+		dev_printk(KERN_INFO, &dev->dev,
+			"PME# supported from%s%s%s%s%s\n",
+			(pmc & PCI_PM_CAP_PME_D0) ? " D0" : "",
+			(pmc & PCI_PM_CAP_PME_D1) ? " D1" : "",
+			(pmc & PCI_PM_CAP_PME_D2) ? " D2" : "",
+			(pmc & PCI_PM_CAP_PME_D3) ? " D3hot" : "",
+			(pmc & PCI_PM_CAP_PME_D3cold) ? " D3cold" : "");
+		/*
+		 * Make device's PM flags reflect the wake-up capability, but
+		 * let the user space enable it to wake up the system as needed.
+		 */
+		device_set_wakeup_capable(&dev->dev, true);
+		device_set_wakeup_enable(&dev->dev, false);
+		/* Disable the PME# generation functionality */
+		pci_pme_active(dev, pm, false);
+	}
 }
 
 int

commit 44e4e66eeae5338b3ca0b28f8352e60bf18d5ba8
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Jul 7 03:32:52 2008 +0200

    PCI: rework pci_set_power_state function to call platform first
    
    Rework pci_set_power_state() so that the platform callback is
    invoked before the native mechanism, if necessary.  Also, make
    the function check if the device is power manageable by the
    platform before invoking the platform callback.
    
    This may matter if the device dependent on additional power
    resources controlled by the platform is being put into D0, in which
    case those power resources must be turned on before we attempt to
    handle the device itself.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@suse.cz>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index f8074525267c..20e28077b96d 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -404,67 +404,56 @@ static inline pci_power_t platform_pci_choose_state(struct pci_dev *dev)
 }
 
 /**
- * pci_set_power_state - Set the power state of a PCI device
- * @dev: PCI device to be suspended
- * @state: PCI power state (D0, D1, D2, D3hot, D3cold) we're entering
+ * pci_raw_set_power_state - Use PCI PM registers to set the power state of
+ *                           given PCI device
+ * @dev: PCI device to handle.
+ * @pm: PCI PM capability offset of the device.
+ * @state: PCI power state (D0, D1, D2, D3hot) to put the device into.
  *
- * Transition a device to a new power state, using the Power Management 
- * Capabilities in the device's config space.
- *
- * RETURN VALUE: 
- * -EINVAL if trying to enter a lower state than we're already in.
- * 0 if we're already in the requested state.
- * -EIO if device does not support PCI PM.
- * 0 if we can successfully change the power state.
+ * RETURN VALUE:
+ * -EINVAL if the requested state is invalid.
+ * -EIO if device does not support PCI PM or its PM capabilities register has a
+ * wrong version, or device doesn't support the requested state.
+ * 0 if device already is in the requested state.
+ * 0 if device's power state has been successfully changed.
  */
-int
-pci_set_power_state(struct pci_dev *dev, pci_power_t state)
+static int
+pci_raw_set_power_state(struct pci_dev *dev, int pm, pci_power_t state)
 {
-	int pm, need_restore = 0;
 	u16 pmcsr, pmc;
+	bool need_restore = false;
 
-	/* bound the state we're entering */
-	if (state > PCI_D3hot)
-		state = PCI_D3hot;
-
-	/*
-	 * If the device or the parent bridge can't support PCI PM, ignore
-	 * the request if we're doing anything besides putting it into D0
-	 * (which would only happen on boot).
-	 */
-	if ((state == PCI_D1 || state == PCI_D2) && pci_no_d1d2(dev))
-		return 0;
-
-	/* find PCI PM capability in list */
-	pm = pci_find_capability(dev, PCI_CAP_ID_PM);
-
-	/* abort if the device doesn't support PM capabilities */
 	if (!pm)
 		return -EIO;
 
+	if (state < PCI_D0 || state > PCI_D3hot)
+		return -EINVAL;
+
 	/* Validate current state:
 	 * Can enter D0 from any state, but if we can only go deeper 
 	 * to sleep if we're already in a low power state
 	 */
-	if (state != PCI_D0 && dev->current_state > state) {
+	if (dev->current_state == state) {
+		/* we're already there */
+		return 0;
+	} else if (state != PCI_D0 && dev->current_state <= PCI_D3cold
+	    && dev->current_state > state) {
 		dev_err(&dev->dev, "invalid power transition "
 			"(from state %d to %d)\n", dev->current_state, state);
 		return -EINVAL;
-	} else if (dev->current_state == state)
-		return 0;        /* we're already there */
+	}
 
+	pci_read_config_word(dev, pm + PCI_PM_PMC, &pmc);
 
-	pci_read_config_word(dev,pm + PCI_PM_PMC,&pmc);
 	if ((pmc & PCI_PM_CAP_VER_MASK) > 3) {
-		dev_printk(KERN_DEBUG, &dev->dev, "unsupported PM cap regs "
-			   "version (%u)\n", pmc & PCI_PM_CAP_VER_MASK);
+		dev_err(&dev->dev, "unsupported PM cap regs version (%u)\n",
+			pmc & PCI_PM_CAP_VER_MASK);
 		return -EIO;
 	}
 
 	/* check if this device supports the desired state */
-	if (state == PCI_D1 && !(pmc & PCI_PM_CAP_D1))
-		return -EIO;
-	else if (state == PCI_D2 && !(pmc & PCI_PM_CAP_D2))
+	if ((state == PCI_D1 && !(pmc & PCI_PM_CAP_D1))
+	   || (state == PCI_D2 && !(pmc & PCI_PM_CAP_D2)))
 		return -EIO;
 
 	pci_read_config_word(dev, pm + PCI_PM_CTRL, &pmcsr);
@@ -483,7 +472,7 @@ pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 	case PCI_UNKNOWN: /* Boot-up */
 		if ((pmcsr & PCI_PM_CTRL_STATE_MASK) == PCI_D3hot
 		 && !(pmcsr & PCI_PM_CTRL_NO_SOFT_RESET))
-			need_restore = 1;
+			need_restore = true;
 		/* Fall-through: force to D0 */
 	default:
 		pmcsr = 0;
@@ -500,12 +489,6 @@ pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 	else if (state == PCI_D2 || dev->current_state == PCI_D2)
 		udelay(200);
 
-	/*
-	 * Give firmware a chance to be called, such as ACPI _PRx, _PSx
-	 * Firmware method after native method ?
-	 */
-	platform_pci_set_power_state(dev, state);
-
 	dev->current_state = state;
 
 	/* According to section 5.4.1 of the "PCI BUS POWER MANAGEMENT
@@ -529,6 +512,81 @@ pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 	return 0;
 }
 
+/**
+ * pci_update_current_state - Read PCI power state of given device from its
+ *                            PCI PM registers and cache it
+ * @dev: PCI device to handle.
+ * @pm: PCI PM capability offset of the device.
+ */
+static void pci_update_current_state(struct pci_dev *dev, int pm)
+{
+	if (pm) {
+		u16 pmcsr;
+
+		pci_read_config_word(dev, pm + PCI_PM_CTRL, &pmcsr);
+		dev->current_state = (pmcsr & PCI_PM_CTRL_STATE_MASK);
+	}
+}
+
+/**
+ * pci_set_power_state - Set the power state of a PCI device
+ * @dev: PCI device to handle.
+ * @state: PCI power state (D0, D1, D2, D3hot) to put the device into.
+ *
+ * Transition a device to a new power state, using the platform formware and/or
+ * the device's PCI PM registers.
+ *
+ * RETURN VALUE:
+ * -EINVAL if the requested state is invalid.
+ * -EIO if device does not support PCI PM or its PM capabilities register has a
+ * wrong version, or device doesn't support the requested state.
+ * 0 if device already is in the requested state.
+ * 0 if device's power state has been successfully changed.
+ */
+int pci_set_power_state(struct pci_dev *dev, pci_power_t state)
+{
+	int pm, error;
+
+	/* bound the state we're entering */
+	if (state > PCI_D3hot)
+		state = PCI_D3hot;
+	else if (state < PCI_D0)
+		state = PCI_D0;
+	else if ((state == PCI_D1 || state == PCI_D2) && pci_no_d1d2(dev))
+		/*
+		 * If the device or the parent bridge do not support PCI PM,
+		 * ignore the request if we're doing anything other than putting
+		 * it into D0 (which would only happen on boot).
+		 */
+		return 0;
+
+	/* Find PCI PM capability in the list */
+	pm = pci_find_capability(dev, PCI_CAP_ID_PM);
+
+	if (state == PCI_D0 && platform_pci_power_manageable(dev)) {
+		/*
+		 * Allow the platform to change the state, for example via ACPI
+		 * _PR0, _PS0 and some such, but do not trust it.
+		 */
+		int ret = platform_pci_set_power_state(dev, PCI_D0);
+		if (!ret)
+			pci_update_current_state(dev, pm);
+	}
+
+	error = pci_raw_set_power_state(dev, pm, state);
+
+	if (state > PCI_D0 && platform_pci_power_manageable(dev)) {
+		/* Allow the platform to finalize the transition */
+		int ret = platform_pci_set_power_state(dev, state);
+		if (!ret) {
+			pci_update_current_state(dev, pm);
+			error = 0;
+		}
+	}
+
+	return error;
+}
+
 /**
  * pci_choose_state - Choose the power state of a PCI device
  * @dev: PCI device to be suspended

commit 961d9120fa6f078492a1c762dd91f2c097e56c83
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Jul 7 03:32:02 2008 +0200

    PCI: Introduce platform_pci_power_manageable function
    
    Introduce function pointer platform_pci_power_manageable to be used
    by the platform-related code to point to a function allowing us to
    check if given device is power manageable by the platform.
    
    Introduce acpi_pci_power_manageable() playing that role for ACPI.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 8e8ecc1da93d..f8074525267c 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -376,7 +376,32 @@ pci_restore_bars(struct pci_dev *dev)
 		pci_update_resource(dev, &dev->resource[i], i);
 }
 
-int (*platform_pci_set_power_state)(struct pci_dev *dev, pci_power_t t);
+static struct pci_platform_pm_ops *pci_platform_pm;
+
+int pci_set_platform_pm(struct pci_platform_pm_ops *ops)
+{
+	if (!ops->is_manageable || !ops->set_state || !ops->choose_state)
+		return -EINVAL;
+	pci_platform_pm = ops;
+	return 0;
+}
+
+static inline bool platform_pci_power_manageable(struct pci_dev *dev)
+{
+	return pci_platform_pm ? pci_platform_pm->is_manageable(dev) : false;
+}
+
+static inline int platform_pci_set_power_state(struct pci_dev *dev,
+                                                pci_power_t t)
+{
+	return pci_platform_pm ? pci_platform_pm->set_state(dev, t) : -ENOSYS;
+}
+
+static inline pci_power_t platform_pci_choose_state(struct pci_dev *dev)
+{
+	return pci_platform_pm ?
+			pci_platform_pm->choose_state(dev) : PCI_POWER_ERROR;
+}
 
 /**
  * pci_set_power_state - Set the power state of a PCI device
@@ -479,8 +504,7 @@ pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 	 * Give firmware a chance to be called, such as ACPI _PRx, _PSx
 	 * Firmware method after native method ?
 	 */
-	if (platform_pci_set_power_state)
-		platform_pci_set_power_state(dev, state);
+	platform_pci_set_power_state(dev, state);
 
 	dev->current_state = state;
 
@@ -505,8 +529,6 @@ pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 	return 0;
 }
 
-pci_power_t (*platform_pci_choose_state)(struct pci_dev *dev);
- 
 /**
  * pci_choose_state - Choose the power state of a PCI device
  * @dev: PCI device to be suspended
@@ -524,11 +546,9 @@ pci_power_t pci_choose_state(struct pci_dev *dev, pm_message_t state)
 	if (!pci_find_capability(dev, PCI_CAP_ID_PM))
 		return PCI_D0;
 
-	if (platform_pci_choose_state) {
-		ret = platform_pci_choose_state(dev);
-		if (ret != PCI_POWER_ERROR)
-			return ret;
-	}
+	ret = platform_pci_choose_state(dev);
+	if (ret != PCI_POWER_ERROR)
+		return ret;
 
 	switch (state.event) {
 	case PM_EVENT_ON:

commit e4ec7a00ed30429030112e5591cf3138645727c2
Author: Jesse Barnes <jbarnes@hobbes.(none)>
Date:   Wed Jun 25 16:12:25 2008 -0700

    PCI: correct resource number in debug output
    
    If pci_request_region fails, make the warning include the resource number,
    not the resource number + 1.

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 8b755a7fb4ef..8e8ecc1da93d 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1114,10 +1114,10 @@ int pci_request_region(struct pci_dev *pdev, int bar, const char *res_name)
 
 err_out:
 	dev_warn(&pdev->dev, "BAR %d: can't reserve %s region [%#llx-%#llx]\n",
-		bar + 1, /* PCI BAR # */
-		pci_resource_flags(pdev, bar) & IORESOURCE_IO ? "I/O" : "mem",
-		(unsigned long long)pci_resource_start(pdev, bar),
-		(unsigned long long)pci_resource_end(pdev, bar));
+		 bar,
+		 pci_resource_flags(pdev, bar) & IORESOURCE_IO ? "I/O" : "mem",
+		 (unsigned long long)pci_resource_start(pdev, bar),
+		 (unsigned long long)pci_resource_end(pdev, bar));
 	return -EBUSY;
 }
 

commit 80ccba1186d48fa728dc4b1456cc07ffb07da501
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Fri Jun 13 10:52:11 2008 -0600

    PCI: use dev_printk when possible
    
    Convert printks to use dev_printk().
    
    I converted pr_debug() to dev_dbg().  Both use KERN_DEBUG and are enabled
    only when DEBUG is defined.
    
    I converted printk(KERN_DEBUG) to dev_printk(KERN_DEBUG), not to dev_dbg(),
    because dev_dbg() is only enabled when DEBUG is defined.
    
    I converted DBG(KERN_INFO) (only in setup-bus.c) to dev_info().  The DBG()
    name makes it sound like debug, but it's been enabled forever, so dev_info()
    preserves the previous behavior.
    
    I tried to make the resource assignment formats more consistent, e.g.,
      "BAR %d: got res [%#llx-%#llx] bus [%#llx-%#llx] flags %#lx\n"
    instead of sometimes using "start-end" and sometimes using "size@start".
    I'm not attached to one or the other; I'd just like them consistent.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 7869f8f75c9e..8b755a7fb4ef 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -422,8 +422,8 @@ pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 	 * to sleep if we're already in a low power state
 	 */
 	if (state != PCI_D0 && dev->current_state > state) {
-		printk(KERN_ERR "%s(): %s: state=%d, current state=%d\n",
-			__func__, pci_name(dev), state, dev->current_state);
+		dev_err(&dev->dev, "invalid power transition "
+			"(from state %d to %d)\n", dev->current_state, state);
 		return -EINVAL;
 	} else if (dev->current_state == state)
 		return 0;        /* we're already there */
@@ -431,9 +431,8 @@ pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 
 	pci_read_config_word(dev,pm + PCI_PM_PMC,&pmc);
 	if ((pmc & PCI_PM_CAP_VER_MASK) > 3) {
-		printk(KERN_DEBUG
-		       "PCI: %s has unsupported PM cap regs version (%u)\n",
-		       pci_name(dev), pmc & PCI_PM_CAP_VER_MASK);
+		dev_printk(KERN_DEBUG, &dev->dev, "unsupported PM cap regs "
+			   "version (%u)\n", pmc & PCI_PM_CAP_VER_MASK);
 		return -EIO;
 	}
 
@@ -541,7 +540,8 @@ pci_power_t pci_choose_state(struct pci_dev *dev, pm_message_t state)
 	case PM_EVENT_HIBERNATE:
 		return PCI_D3hot;
 	default:
-		printk("Unrecognized suspend event %d\n", state.event);
+		dev_info(&dev->dev, "unrecognized suspend event %d\n",
+			 state.event);
 		BUG();
 	}
 	return PCI_D0;
@@ -566,7 +566,7 @@ static int pci_save_pcie_state(struct pci_dev *dev)
 	else
 		found = 1;
 	if (!save_state) {
-		dev_err(&dev->dev, "Out of memory in pci_save_pcie_state\n");
+		dev_err(&dev->dev, "out of memory in pci_save_pcie_state\n");
 		return -ENOMEM;
 	}
 	cap = (u16 *)&save_state->data[0];
@@ -617,7 +617,7 @@ static int pci_save_pcix_state(struct pci_dev *dev)
 	else
 		found = 1;
 	if (!save_state) {
-		dev_err(&dev->dev, "Out of memory in pci_save_pcie_state\n");
+		dev_err(&dev->dev, "out of memory in pci_save_pcie_state\n");
 		return -ENOMEM;
 	}
 	cap = (u16 *)&save_state->data[0];
@@ -683,10 +683,9 @@ pci_restore_state(struct pci_dev *dev)
 	for (i = 15; i >= 0; i--) {
 		pci_read_config_dword(dev, i * 4, &val);
 		if (val != dev->saved_config_space[i]) {
-			printk(KERN_DEBUG "PM: Writing back config space on "
-				"device %s at offset %x (was %x, writing %x)\n",
-				pci_name(dev), i,
-				val, (int)dev->saved_config_space[i]);
+			dev_printk(KERN_DEBUG, &dev->dev, "restoring config "
+				"space at offset %#x (was %#x, writing %#x)\n",
+				i, val, (int)dev->saved_config_space[i]);
 			pci_write_config_dword(dev,i * 4,
 				dev->saved_config_space[i]);
 		}
@@ -1114,13 +1113,11 @@ int pci_request_region(struct pci_dev *pdev, int bar, const char *res_name)
 	return 0;
 
 err_out:
-	printk (KERN_WARNING "PCI: Unable to reserve %s region #%d:%llx@%llx "
-		"for device %s\n",
-		pci_resource_flags(pdev, bar) & IORESOURCE_IO ? "I/O" : "mem",
+	dev_warn(&pdev->dev, "BAR %d: can't reserve %s region [%#llx-%#llx]\n",
 		bar + 1, /* PCI BAR # */
-		(unsigned long long)pci_resource_len(pdev, bar),
+		pci_resource_flags(pdev, bar) & IORESOURCE_IO ? "I/O" : "mem",
 		(unsigned long long)pci_resource_start(pdev, bar),
-		pci_name(pdev));
+		(unsigned long long)pci_resource_end(pdev, bar));
 	return -EBUSY;
 }
 
@@ -1212,7 +1209,7 @@ pci_set_master(struct pci_dev *dev)
 
 	pci_read_config_word(dev, PCI_COMMAND, &cmd);
 	if (! (cmd & PCI_COMMAND_MASTER)) {
-		pr_debug("PCI: Enabling bus mastering for device %s\n", pci_name(dev));
+		dev_dbg(&dev->dev, "enabling bus mastering\n");
 		cmd |= PCI_COMMAND_MASTER;
 		pci_write_config_word(dev, PCI_COMMAND, cmd);
 	}
@@ -1277,8 +1274,8 @@ pci_set_cacheline_size(struct pci_dev *dev)
 	if (cacheline_size == pci_cache_line_size)
 		return 0;
 
-	printk(KERN_DEBUG "PCI: cache line size of %d is not supported "
-	       "by device %s\n", pci_cache_line_size << 2, pci_name(dev));
+	dev_printk(KERN_DEBUG, &dev->dev, "cache line size of %d is not "
+		   "supported\n", pci_cache_line_size << 2);
 
 	return -EINVAL;
 }
@@ -1303,8 +1300,7 @@ pci_set_mwi(struct pci_dev *dev)
 
 	pci_read_config_word(dev, PCI_COMMAND, &cmd);
 	if (! (cmd & PCI_COMMAND_INVALIDATE)) {
-		pr_debug("PCI: Enabling Mem-Wr-Inval for device %s\n",
-			pci_name(dev));
+		dev_dbg(&dev->dev, "enabling Mem-Wr-Inval\n");
 		cmd |= PCI_COMMAND_INVALIDATE;
 		pci_write_config_word(dev, PCI_COMMAND, cmd);
 	}

commit 53eb2fbeb9e68e1a9a23945de8450999c46270ce
Merge: 8344b568f5bd 0e6859d49ff1
Author: Jesse Barnes <jbarnes@hobbes.lan>
Date:   Thu Jun 12 12:06:58 2008 -0700

    Merge branch 'suspend' of git://git.kernel.org/pub/scm/linux/kernel/git/lenb/linux-acpi-2.6 into linux-next

commit 8d2bdf49481b27096e242119e73abe9348c1019b
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Jun 5 01:16:37 2008 +0200

    PCI ACPI: Drop the second argument of platform_pci_choose_state
    
    Since the second argument of acpi_pci_choose_state() and
    platform_pci_choose_state() is never used, remove it.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@suse.cz>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index e4548ab2a93c..75c60239cadd 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -508,7 +508,7 @@ pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 	return 0;
 }
 
-pci_power_t (*platform_pci_choose_state)(struct pci_dev *dev, pm_message_t state);
+pci_power_t (*platform_pci_choose_state)(struct pci_dev *dev);
  
 /**
  * pci_choose_state - Choose the power state of a PCI device
@@ -528,7 +528,7 @@ pci_power_t pci_choose_state(struct pci_dev *dev, pm_message_t state)
 		return PCI_D0;
 
 	if (platform_pci_choose_state) {
-		ret = platform_pci_choose_state(dev, state);
+		ret = platform_pci_choose_state(dev);
 		if (ret != PCI_POWER_ERROR)
 			return ret;
 	}

commit cf35e4ad57b4c39a4c74921e20e48ec0dbeb14f4
Author: Adrian Bunk <bunk@kernel.org>
Date:   Tue May 20 01:02:06 2008 +0300

    PCI: remove CVS keywords
    
    This patch removes CVS keywords that weren't updated for a long time
    from comments.
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index e4548ab2a93c..15beaf48407f 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1,6 +1,4 @@
 /*
- *	$Id: pci.c,v 1.91 1999/01/21 13:34:01 davem Exp $
- *
  *	PCI Bus Services, see include/linux/pci.h for further explanation.
  *
  *	Copyright 1993 -- 1997 Drew Eckhardt, Frederic Potter,

commit 66bef8c059015ba2b36bb5759080336feb01e680
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Mon Mar 3 19:09:46 2008 -0800

    PCI: replace remaining __FUNCTION__ occurrences
    
    __FUNCTION__ is gcc-specific, use __func__
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index f331feb4eb8d..e4548ab2a93c 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -425,7 +425,7 @@ pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 	 */
 	if (state != PCI_D0 && dev->current_state > state) {
 		printk(KERN_ERR "%s(): %s: state=%d, current state=%d\n",
-			__FUNCTION__, pci_name(dev), state, dev->current_state);
+			__func__, pci_name(dev), state, dev->current_state);
 		return -EINVAL;
 	} else if (dev->current_state == state)
 		return 0;        /* we're already there */

commit 7d715a6c1ae5785d00fb9a876b5abdfc43abc44b
Author: Shaohua Li <shaohua.li@intel.com>
Date:   Mon Feb 25 09:46:41 2008 +0800

    PCI: add PCI Express ASPM support
    
    PCI Express ASPM defines a protocol for PCI Express components in the D0
    state to reduce Link power by placing their Links into a low power state
    and instructing the other end of the Link to do likewise. This
    capability allows hardware-autonomous, dynamic Link power reduction
    beyond what is achievable by software-only controlled power management.
    However, The device should be configured by software appropriately.
    Enabling ASPM will save power, but will introduce device latency.
    
    This patch adds ASPM support in Linux. It introduces a global policy for
    ASPM, a sysfs file /sys/module/pcie_aspm/parameters/policy can control
    it. The interface can be used as a boot option too. Currently we have
    below setting:
            -default, BIOS default setting
            -powersave, highest power saving mode, enable all available ASPM
    state and clock power management
            -performance, highest performance, disable ASPM and clock power
    management
    By default, the 'default' policy is used currently.
    
    In my test, power difference between powersave mode and performance mode
    is about 1.3w in a system with 3 PCIE links.
    
    Note: some devices might not work well with aspm, either because chipset
    issue or device issue. The patch provide API (pci_disable_link_state),
    driver can disable ASPM for specific device.
    
    Signed-off-by: Shaohua Li <shaohua.li@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index a4445b7210bf..f331feb4eb8d 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -18,6 +18,7 @@
 #include <linux/spinlock.h>
 #include <linux/string.h>
 #include <linux/log2.h>
+#include <linux/pci-aspm.h>
 #include <asm/dma.h>	/* isa_dma_bridge_buggy */
 #include "pci.h"
 
@@ -501,6 +502,9 @@ pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 	if (need_restore)
 		pci_restore_bars(dev);
 
+	if (dev->bus->self)
+		pcie_aspm_pm_state_change(dev->bus->self);
+
 	return 0;
 }
 

commit 49741c4d01554c2630cea02cfdf236b17062a912
Author: Andrew Morton <akpm@linux-foundation.org>
Date:   Mon Mar 17 14:21:18 2008 -0700

    PCI: revert "pcie: utilize pcie transaction pending bit"
    
    Revert as it is reported to cause problems for people.
    
    commit 4348a2dc49f9baecd34a9b0904245488c6189398
    Author: Shaohua Li <shaohua.li@intel.com>
    Date:   Wed Oct 24 10:45:08 2007 +0800
    
        pcie: utilize pcie transaction pending bit
    
        PCIE has a mechanism to wait for Non-Posted request to complete. I think
        pci_disable_device is a good place to do this.
    
        Signed-off-by: Shaohua Li <shaohua.li@intel.com>
        Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    
    Due to the regression reported at
    http://bugzilla.kernel.org/show_bug.cgi?id=10065
    
    Cc: Shaohua Li <shaohua.li@intel.com>
    Cc: Soeren Sonnenburg <kernel@nn7.de>
    Cc: "Rafael J. Wysocki" <rjw@sisk.pl>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 183fddaa38b7..a4445b7210bf 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -314,24 +314,6 @@ int pci_find_ht_capability(struct pci_dev *dev, int ht_cap)
 }
 EXPORT_SYMBOL_GPL(pci_find_ht_capability);
 
-void pcie_wait_pending_transaction(struct pci_dev *dev)
-{
-	int pos;
-	u16 reg16;
-
-	pos = pci_find_capability(dev, PCI_CAP_ID_EXP);
-	if (!pos)
-		return;
-	while (1) {
-		pci_read_config_word(dev, pos + PCI_EXP_DEVSTA, &reg16);
-		if (!(reg16 & PCI_EXP_DEVSTA_TRPND))
-			break;
-		cpu_relax();
-	}
-
-}
-EXPORT_SYMBOL_GPL(pcie_wait_pending_transaction);
-
 /**
  * pci_find_parent_resource - return resource region of parent bus of given region
  * @dev: PCI device structure contains resources to be searched
@@ -936,9 +918,6 @@ pci_disable_device(struct pci_dev *dev)
 	if (atomic_sub_return(1, &dev->enable_cnt) != 0)
 		return;
 
-	/* Wait for all transactions are finished before disabling the device */
-	pcie_wait_pending_transaction(dev);
-
 	pci_read_config_word(dev, PCI_COMMAND, &pci_command);
 	if (pci_command & PCI_COMMAND_MASTER) {
 		pci_command &= ~PCI_COMMAND_MASTER;

commit 3a2d5b700132f35401f1d9e22fe3c2cab02c2549
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sat Feb 23 19:13:25 2008 +0100

    PM: Introduce PM_EVENT_HIBERNATE callback state
    
    During the last step of hibernation in the "platform" mode (with the
    help of ACPI) we use the suspend code, including the devices'
    ->suspend() methods, to prepare the system for entering the ACPI S4
    system sleep state.
    
    But at least for some devices the operations performed by the
    ->suspend() callback in that case must be different from its operations
    during regular suspend.
    
    For this reason, introduce the new PM event type PM_EVENT_HIBERNATE and
    pass it to the device drivers' ->suspend() methods during the last phase
    of hibernation, so that they can distinguish this case and handle it as
    appropriate.  Modify the drivers that handle PM_EVENT_SUSPEND in a
    special way and need to handle PM_EVENT_HIBERNATE in the same way.
    
    These changes are necessary to fix a hibernation regression related
    to the i915 driver (ref. http://lkml.org/lkml/2008/2/22/488).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Tested-by: Jeff Chua <jeff.chua.linux@gmail.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index ae3df46eaabf..183fddaa38b7 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -554,6 +554,7 @@ pci_power_t pci_choose_state(struct pci_dev *dev, pm_message_t state)
 	case PM_EVENT_PRETHAW:
 		/* REVISIT both freeze and pre-thaw "should" use D0 */
 	case PM_EVENT_SUSPEND:
+	case PM_EVENT_HIBERNATE:
 		return PCI_D3hot;
 	default:
 		printk("Unrecognized suspend event %d\n", state.event);

commit 59fc67dedb46c29442989e52af39da67aea52512
Author: FUJITA Tomonori <tomof@acm.org>
Date:   Mon Feb 4 22:28:14 2008 -0800

    iommu sg merging: PCI: add dma segment boundary support
    
    This adds PCI's accessor for segment_boundary_mask in device_dma_parameters.
    
    The default segment_boundary is set to 0xffffffff, same to the block layer's
    default value (and the scsi mid layer uses the same value).
    
    Signed-off-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Cc: James Bottomley <James.Bottomley@steeleye.com>
    Cc: Jens Axboe <jens.axboe@oracle.com>
    Cc: Greg KH <greg@kroah.com>
    Cc: Jeff Garzik <jeff@garzik.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index be97090ddf32..ae3df46eaabf 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1459,6 +1459,14 @@ int pci_set_dma_max_seg_size(struct pci_dev *dev, unsigned int size)
 EXPORT_SYMBOL(pci_set_dma_max_seg_size);
 #endif
 
+#ifndef HAVE_ARCH_PCI_SET_DMA_SEGMENT_BOUNDARY
+int pci_set_dma_seg_boundary(struct pci_dev *dev, unsigned long mask)
+{
+	return dma_set_seg_boundary(&dev->dev, mask);
+}
+EXPORT_SYMBOL(pci_set_dma_seg_boundary);
+#endif
+
 /**
  * pcix_get_max_mmrbc - get PCI-X maximum designed memory read byte count
  * @dev: PCI device to query

commit 4d57cdfacaa1c207bf4c071f89835e0368766a50
Author: FUJITA Tomonori <tomof@acm.org>
Date:   Mon Feb 4 22:27:55 2008 -0800

    iommu sg merging: PCI: add device_dma_parameters support
    
    This adds struct device_dma_parameters in struct pci_dev and properly
    sets up a pointer in struct device.
    
    The default max_segment_size is set to 64K, same to the block layer's
    default value.
    
    Signed-off-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Mostly-acked-by: Jeff Garzik <jeff@garzik.org>
    Cc: James Bottomley <James.Bottomley@steeleye.com>
    Acked-by: Jens Axboe <jens.axboe@oracle.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 04aac7782468..be97090ddf32 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1451,6 +1451,14 @@ pci_set_consistent_dma_mask(struct pci_dev *dev, u64 mask)
 }
 #endif
 
+#ifndef HAVE_ARCH_PCI_SET_DMA_MAX_SEGMENT_SIZE
+int pci_set_dma_max_seg_size(struct pci_dev *dev, unsigned int size)
+{
+	return dma_set_max_seg_size(&dev->dev, size);
+}
+EXPORT_SYMBOL(pci_set_dma_max_seg_size);
+#endif
+
 /**
  * pcix_get_max_mmrbc - get PCI-X maximum designed memory read byte count
  * @dev: PCI device to query

commit cc3a1378b4dd45d3e78dd4aeb10641b06a87d614
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Sat Feb 2 11:32:01 2008 -0800

    Revert "PCI: PCIE ASPM support"
    
    This reverts commit 6c723d5bd89f03fc3ef627d50f89ade054d2ee3b.
    
    It caused build errors on non-x86 platforms, config file confusion, and
    even some boot errors on some x86-64 boxes.  All around, not quite ready
    for prime-time :(
    
    Cc: Shaohua Li <shaohua.li@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index b3e9294e4a0e..04aac7782468 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -18,7 +18,6 @@
 #include <linux/spinlock.h>
 #include <linux/string.h>
 #include <linux/log2.h>
-#include <linux/aspm.h>
 #include <asm/dma.h>	/* isa_dma_bridge_buggy */
 #include "pci.h"
 
@@ -520,9 +519,6 @@ pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 	if (need_restore)
 		pci_restore_bars(dev);
 
-	if (dev->bus->self)
-		pcie_aspm_pm_state_change(dev->bus->self);
-
 	return 0;
 }
 

commit 215e871aaa3d94540121a3809d80d0c5e5686e4f
Merge: b6cf160c4b78 fd7d1ced29e5
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Feb 2 14:29:33 2008 +1100

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/pci-2.6
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/pci-2.6: (64 commits)
      PCI: make pci_bus a struct device
      PCI: fix codingstyle issues in include/linux/pci.h
      PCI: fix codingstyle issues in drivers/pci/pci.h
      PCI: PCIE ASPM support
      PCI: Fix fakephp deadlock
      PCI: modify SB700 SATA MSI quirk
      PCI: Run ACPI _OSC method on root bridges only
      PCI ACPI: AER driver should only register PCIe devices with _OSC
      PCI ACPI: Added a function to register _OSC with only PCIe devices.
      PCI: constify function pointer tables
      PCI: Convert drivers/pci/proc.c to use unlocked_ioctl
      pciehp: block new requests from the device before power off
      pciehp: workaround against Bad DLLP during power off
      pciehp: wait for 1000ms before LED operation after power off
      PCI: Remove pci_enable_device_bars() from documentation
      PCI: Remove pci_enable_device_bars()
      PCI: Remove users of pci_enable_device_bars()
      PCI: Add pci_enable_device_{io,mem} intefaces
      PCI: avoid save the same type of cap multiple times
      PCI: correctly initialize a structure for pcie_save_pcix_state()
      ...

commit 6c723d5bd89f03fc3ef627d50f89ade054d2ee3b
Author: Shaohua Li <shaohua.li@intel.com>
Date:   Thu Jan 24 10:21:57 2008 +0800

    PCI: PCIE ASPM support
    
    PCI Express ASPM defines a protocol for PCI Express components in the D0
    state to reduce Link power by placing their Links into a low power state
    and instructing the other end of the Link to do likewise. This
    capability allows hardware-autonomous, dynamic Link power reduction
    beyond what is achievable by software-only controlled power management.
    However, The device should be configured by software appropriately.
    Enabling ASPM will save power, but will introduce device latency.
    
    This patch adds ASPM support in Linux. It introduces a global policy for
    ASPM, a sysfs file /sys/module/pcie_aspm/parameters/policy can control
    it. The interface can be used as a boot option too. Currently we have
    below setting:
            -default, BIOS default setting
            -powersave, highest power saving mode, enable all available ASPM
    state
    and clock power management
            -performance, highest performance, disable ASPM and clock power
    management
    By default, the 'default' policy is used currently.
    
    In my test, power difference between powersave mode and performance mode
    is about 1.3w in a system with 3 PCIE links.
    
    Signed-off-by: Shaohua Li <shaohua.li@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 35f78f1628fc..1f1693161956 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -18,6 +18,7 @@
 #include <linux/spinlock.h>
 #include <linux/string.h>
 #include <linux/log2.h>
+#include <linux/aspm.h>
 #include <asm/dma.h>	/* isa_dma_bridge_buggy */
 #include "pci.h"
 
@@ -519,6 +520,9 @@ pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 	if (need_restore)
 		pci_restore_bars(dev);
 
+	if (dev->bus->self)
+		pcie_aspm_pm_state_change(dev->bus->self);
+
 	return 0;
 }
 

commit 7cbe5b6005f80de33a205d3052cdc89aacaac07c
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Thu Dec 20 15:28:10 2007 +1100

    PCI: Remove pci_enable_device_bars()
    
    Now that all in-tree users are gone, this removes pci_enable_device_bars()
    completely.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 5027e4d08b48..35f78f1628fc 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -741,29 +741,6 @@ int pci_reenable_device(struct pci_dev *dev)
 	return 0;
 }
 
-/**
- * pci_enable_device_bars - Initialize some of a device for use
- * @dev: PCI device to be initialized
- * @bars: bitmask of BAR's that must be configured
- *
- *  Initialize device before it's used by a driver. Ask low-level code
- *  to enable selected I/O and memory resources. Wake up the device if it
- *  was suspended. Beware, this function can fail.
- */
-int
-pci_enable_device_bars(struct pci_dev *dev, int bars)
-{
-	int err;
-
-	if (atomic_add_return(1, &dev->enable_cnt) > 1)
-		return 0;		/* already enabled */
-
-	err = do_pci_enable_device(dev, bars);
-	if (err < 0)
-		atomic_dec(&dev->enable_cnt);
-	return err;
-}
-
 static int __pci_enable_device_flags(struct pci_dev *dev,
 				     resource_size_t flags)
 {
@@ -1695,7 +1672,6 @@ early_param("pci", pci_setup);
 device_initcall(pci_init);
 
 EXPORT_SYMBOL(pci_reenable_device);
-EXPORT_SYMBOL(pci_enable_device_bars);
 EXPORT_SYMBOL(pci_enable_device_io);
 EXPORT_SYMBOL(pci_enable_device_mem);
 EXPORT_SYMBOL(pci_enable_device);

commit b718989da7cf1f77ed5665dba0d2c73bd9dfe2d7
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Thu Dec 20 15:28:08 2007 +1100

    PCI: Add pci_enable_device_{io,mem} intefaces
    
    The pci_enable_device_bars() interface isn't well suited to PCI
    because you can't actually enable/disable BARs individually on
    a device. So for example, if a device has 2 memory BARs 0 and 1,
    and one of them (let's say 1) has not been successfully allocated
    by the firmware or the kernel, then enabling memory decoding
    shouldn't be permitted for the entire device since it will decode
    whatever random address is still in that BAR 1.
    
    So a device must be either fully enabled for IO, for Memory, or
    for both. Not on a per-BAR basis.
    
    This provides two new functions, pci_enable_device_io() and
    pci_enable_device_mem() to replace pci_enable_device_bars(). The
    implementation internally builds a BAR mask in order to be able
    to use existing arch infrastructure.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Acked-by: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 7248e9fb12bd..5027e4d08b48 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -764,6 +764,51 @@ pci_enable_device_bars(struct pci_dev *dev, int bars)
 	return err;
 }
 
+static int __pci_enable_device_flags(struct pci_dev *dev,
+				     resource_size_t flags)
+{
+	int err;
+	int i, bars = 0;
+
+	if (atomic_add_return(1, &dev->enable_cnt) > 1)
+		return 0;		/* already enabled */
+
+	for (i = 0; i < DEVICE_COUNT_RESOURCE; i++)
+		if (dev->resource[i].flags & flags)
+			bars |= (1 << i);
+
+	err = do_pci_enable_device(dev, bars);
+	if (err < 0)
+		atomic_dec(&dev->enable_cnt);
+	return err;
+}
+
+/**
+ * pci_enable_device_io - Initialize a device for use with IO space
+ * @dev: PCI device to be initialized
+ *
+ *  Initialize device before it's used by a driver. Ask low-level code
+ *  to enable I/O resources. Wake up the device if it was suspended.
+ *  Beware, this function can fail.
+ */
+int pci_enable_device_io(struct pci_dev *dev)
+{
+	return __pci_enable_device_flags(dev, IORESOURCE_IO);
+}
+
+/**
+ * pci_enable_device_mem - Initialize a device for use with Memory space
+ * @dev: PCI device to be initialized
+ *
+ *  Initialize device before it's used by a driver. Ask low-level code
+ *  to enable Memory resources. Wake up the device if it was suspended.
+ *  Beware, this function can fail.
+ */
+int pci_enable_device_mem(struct pci_dev *dev)
+{
+	return __pci_enable_device_flags(dev, IORESOURCE_MEM);
+}
+
 /**
  * pci_enable_device - Initialize device before it's used by a driver.
  * @dev: PCI device to be initialized
@@ -777,7 +822,7 @@ pci_enable_device_bars(struct pci_dev *dev, int bars)
  */
 int pci_enable_device(struct pci_dev *dev)
 {
-	return pci_enable_device_bars(dev, (1 << PCI_NUM_RESOURCES) - 1);
+	return __pci_enable_device_flags(dev, IORESOURCE_MEM | IORESOURCE_IO);
 }
 
 /*
@@ -1651,6 +1696,8 @@ device_initcall(pci_init);
 
 EXPORT_SYMBOL(pci_reenable_device);
 EXPORT_SYMBOL(pci_enable_device_bars);
+EXPORT_SYMBOL(pci_enable_device_io);
+EXPORT_SYMBOL(pci_enable_device_mem);
 EXPORT_SYMBOL(pci_enable_device);
 EXPORT_SYMBOL(pcim_enable_device);
 EXPORT_SYMBOL(pcim_pin_device);

commit 017fc480cc8cc0594dc250951d78e814667ae4c2
Author: Shaohua Li <shaohua.li@intel.com>
Date:   Tue Dec 18 09:57:09 2007 +0800

    PCI: avoid save the same type of cap multiple times
    
    Avoid adding the same type of cap multiple times, otherwise we will see dead loop.
    
    Signed-off-by: Shaohua Li <shaohua.li@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 342857c555de..7248e9fb12bd 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -569,6 +569,7 @@ static int pci_save_pcie_state(struct pci_dev *dev)
 	int pos, i = 0;
 	struct pci_cap_saved_state *save_state;
 	u16 *cap;
+	int found = 0;
 
 	pos = pci_find_capability(dev, PCI_CAP_ID_EXP);
 	if (pos <= 0)
@@ -577,6 +578,8 @@ static int pci_save_pcie_state(struct pci_dev *dev)
 	save_state = pci_find_saved_cap(dev, PCI_CAP_ID_EXP);
 	if (!save_state)
 		save_state = kzalloc(sizeof(*save_state) + sizeof(u16) * 4, GFP_KERNEL);
+	else
+		found = 1;
 	if (!save_state) {
 		dev_err(&dev->dev, "Out of memory in pci_save_pcie_state\n");
 		return -ENOMEM;
@@ -588,7 +591,8 @@ static int pci_save_pcie_state(struct pci_dev *dev)
 	pci_read_config_word(dev, pos + PCI_EXP_SLTCTL, &cap[i++]);
 	pci_read_config_word(dev, pos + PCI_EXP_RTCTL, &cap[i++]);
 	save_state->cap_nr = PCI_CAP_ID_EXP;
-	pci_add_saved_cap(dev, save_state);
+	if (!found)
+		pci_add_saved_cap(dev, save_state);
 	return 0;
 }
 
@@ -616,6 +620,7 @@ static int pci_save_pcix_state(struct pci_dev *dev)
 	int pos, i = 0;
 	struct pci_cap_saved_state *save_state;
 	u16 *cap;
+	int found = 0;
 
 	pos = pci_find_capability(dev, PCI_CAP_ID_PCIX);
 	if (pos <= 0)
@@ -624,6 +629,8 @@ static int pci_save_pcix_state(struct pci_dev *dev)
 	save_state = pci_find_saved_cap(dev, PCI_CAP_ID_PCIX);
 	if (!save_state)
 		save_state = kzalloc(sizeof(*save_state) + sizeof(u16), GFP_KERNEL);
+	else
+		found = 1;
 	if (!save_state) {
 		dev_err(&dev->dev, "Out of memory in pci_save_pcie_state\n");
 		return -ENOMEM;
@@ -632,7 +639,8 @@ static int pci_save_pcix_state(struct pci_dev *dev)
 
 	pci_read_config_word(dev, pos + PCI_X_CMD, &cap[i++]);
 	save_state->cap_nr = PCI_CAP_ID_PCIX;
-	pci_add_saved_cap(dev, save_state);
+	if (!found)
+		pci_add_saved_cap(dev, save_state);
 	return 0;
 }
 

commit ec0a3a27fbb5792980b8c3ce4a93bc2ee93d0b35
Author: Shaohua Li <shaohua.li@intel.com>
Date:   Tue Dec 18 09:56:56 2007 +0800

    PCI: correctly initialize a structure for pcie_save_pcix_state()
    
    save_state->cap_nr should be correctly set, otherwise we can't find the
    saved cap at resume.
    
    Signed-off-by: Shaohua Li <shaohua.li@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index b01ed9a5ab43..342857c555de 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -587,6 +587,7 @@ static int pci_save_pcie_state(struct pci_dev *dev)
 	pci_read_config_word(dev, pos + PCI_EXP_LNKCTL, &cap[i++]);
 	pci_read_config_word(dev, pos + PCI_EXP_SLTCTL, &cap[i++]);
 	pci_read_config_word(dev, pos + PCI_EXP_RTCTL, &cap[i++]);
+	save_state->cap_nr = PCI_CAP_ID_EXP;
 	pci_add_saved_cap(dev, save_state);
 	return 0;
 }
@@ -630,6 +631,7 @@ static int pci_save_pcix_state(struct pci_dev *dev)
 	cap = (u16 *)&save_state->data[0];
 
 	pci_read_config_word(dev, pos + PCI_X_CMD, &cap[i++]);
+	save_state->cap_nr = PCI_CAP_ID_PCIX;
 	pci_add_saved_cap(dev, save_state);
 	return 0;
 }

commit f34303de9e0263b389a215483adddc7d918cf8c8
Author: Shaohua Li <shaohua.li@intel.com>
Date:   Tue Dec 18 09:56:47 2007 +0800

    PCI: fix typo in pci_save_pcix_state
    
    pci_save/store_state has multiple bugs, which will cause cap can't be
    saved/restored correctly. Below 3 patches fix them.
    
    
    fix the typo in pci_save_pcix_state
    
    Signed-off-by: Shaohua Li <shaohua.li@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index d30e802d9a1a..b01ed9a5ab43 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -620,7 +620,7 @@ static int pci_save_pcix_state(struct pci_dev *dev)
 	if (pos <= 0)
 		return 0;
 
-	save_state = pci_find_saved_cap(dev, PCI_CAP_ID_EXP);
+	save_state = pci_find_saved_cap(dev, PCI_CAP_ID_PCIX);
 	if (!save_state)
 		save_state = kzalloc(sizeof(*save_state) + sizeof(u16), GFP_KERNEL);
 	if (!save_state) {

commit 4348a2dc49f9baecd34a9b0904245488c6189398
Author: Shaohua Li <shaohua.li@intel.com>
Date:   Wed Oct 24 10:45:08 2007 +0800

    pcie: utilize pcie transaction pending bit
    
    PCIE has a mechanism to wait for Non-Posted request to complete. I think
    pci_disable_device is a good place to do this.
    
    Signed-off-by: Shaohua Li <shaohua.li@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 089184bc327d..d30e802d9a1a 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -314,6 +314,24 @@ int pci_find_ht_capability(struct pci_dev *dev, int ht_cap)
 }
 EXPORT_SYMBOL_GPL(pci_find_ht_capability);
 
+void pcie_wait_pending_transaction(struct pci_dev *dev)
+{
+	int pos;
+	u16 reg16;
+
+	pos = pci_find_capability(dev, PCI_CAP_ID_EXP);
+	if (!pos)
+		return;
+	while (1) {
+		pci_read_config_word(dev, pos + PCI_EXP_DEVSTA, &reg16);
+		if (!(reg16 & PCI_EXP_DEVSTA_TRPND))
+			break;
+		cpu_relax();
+	}
+
+}
+EXPORT_SYMBOL_GPL(pcie_wait_pending_transaction);
+
 /**
  * pci_find_parent_resource - return resource region of parent bus of given region
  * @dev: PCI device structure contains resources to be searched
@@ -884,6 +902,9 @@ pci_disable_device(struct pci_dev *dev)
 	if (atomic_sub_return(1, &dev->enable_cnt) != 0)
 		return;
 
+	/* Wait for all transactions are finished before disabling the device */
+	pcie_wait_pending_transaction(dev);
+
 	pci_read_config_word(dev, PCI_COMMAND, &pci_command);
 	if (pci_command & PCI_COMMAND_MASTER) {
 		pci_command &= ~PCI_COMMAND_MASTER;

commit ad668599f263988eaac74354349d64e3c0990a77
Author: Adrian Bunk <bunk@kernel.org>
Date:   Sat Oct 27 03:06:22 2007 +0200

    PCI: make pci_restore_bars() static
    
    This patch makes the needlessly global pci_restore_bars() static.
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 71d561fda0a2..089184bc327d 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -353,7 +353,7 @@ pci_find_parent_resource(const struct pci_dev *dev, struct resource *res)
  * Restore the BAR values for a given device, so as to make it
  * accessible by its driver.
  */
-void
+static void
 pci_restore_bars(struct pci_dev *dev)
 {
 	int i, numres;
@@ -1618,7 +1618,6 @@ early_param("pci", pci_setup);
 
 device_initcall(pci_init);
 
-EXPORT_SYMBOL_GPL(pci_restore_bars);
 EXPORT_SYMBOL(pci_reenable_device);
 EXPORT_SYMBOL(pci_enable_device_bars);
 EXPORT_SYMBOL(pci_enable_device);

commit b95d58eaf20eb33c245a2172ec4ecf46bd832309
Author: Tejun Heo <htejun@gmail.com>
Date:   Wed Jan 30 18:20:04 2008 +0900

    pci: allow multiple calls to pcim_enable_device()
    
    There's no reason not to allow multiple calls to pcim_enable_device().
    Calls after the first one can simply be noop.  All PCI resources will
    be released when the initial pcim_enable_device() resource is
    released.
    
    This allows more flexibility to managed PCI users.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 71d561fda0a2..7d4ce906d207 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -823,7 +823,8 @@ int pcim_enable_device(struct pci_dev *pdev)
 	dr = get_pci_dr(pdev);
 	if (unlikely(!dr))
 		return -ENOMEM;
-	WARN_ON(!!dr->enabled);
+	if (dr->enabled)
+		return 0;
 
 	rc = pci_enable_device(pdev);
 	if (!rc) {

commit b4482a4b2e2ff5ed96d8d16d72e83e75064062c5
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Sun Oct 14 19:35:40 2007 +0100

    more trivial signedness fixes in drivers
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 728b3c863d87..71d561fda0a2 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -658,7 +658,7 @@ int
 pci_restore_state(struct pci_dev *dev)
 {
 	int i;
-	int val;
+	u32 val;
 
 	/* PCI Express register must be restored first */
 	pci_restore_pcie_state(dev);

commit 32a2eea795643929a43cbbba00d8c4a176b309bf
Author: Jeff Garzik <jeff@garzik.org>
Date:   Thu Oct 11 16:57:27 2007 -0400

    PCI: Add 'nodomains' boot option, and pci_domains_supported global
    
    * Introduce pci_domains_supported global, hardcoded to zero if
      !CONFIG_PCI_DOMAINS.
    
    * Introduce 'nodomains' boot option, which clears pci_domains_supported
      on platforms that enable it by default (x86, x86-64, and others when
      they are converted to use this).
    
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>
    Cc: Andi Kleen <ak@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 2dd5c282fabe..728b3c863d87 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -23,6 +23,10 @@
 
 unsigned int pci_pm_d3_delay = 10;
 
+#ifdef CONFIG_PCI_DOMAINS
+int pci_domains_supported = 1;
+#endif
+
 #define DEFAULT_CARDBUS_IO_SIZE		(256)
 #define DEFAULT_CARDBUS_MEM_SIZE	(64*1024*1024)
 /* pci=cbmemsize=nnM,cbiosize=nn can override this */
@@ -1567,6 +1571,13 @@ int pci_select_bars(struct pci_dev *dev, unsigned long flags)
 	return bars;
 }
 
+static void __devinit pci_no_domains(void)
+{
+#ifdef CONFIG_PCI_DOMAINS
+	pci_domains_supported = 0;
+#endif
+}
+
 static int __devinit pci_init(void)
 {
 	struct pci_dev *dev = NULL;
@@ -1588,6 +1599,8 @@ static int __devinit pci_setup(char *str)
 				pci_no_msi();
 			} else if (!strcmp(str, "noaer")) {
 				pci_no_aer();
+			} else if (!strcmp(str, "nodomains")) {
+				pci_no_domains();
 			} else if (!strncmp(str, "cbiosize=", 9)) {
 				pci_cardbus_io_size = memparse(str + 9, &str);
 			} else if (!strncmp(str, "cbmemsize=", 10)) {

commit 7f785763660e75c9eddaddea3d618696af4ae3a2
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Fri Oct 5 13:17:58 2007 -0700

    pci: implement "pci=noaer"
    
    For cases in which CONFIG_PCIEAER=y (such as distro kernels), allow users
    to disable PCIE Advanced Error Reporting by using "pci=noaer" on the
    kernel command line.
    
    This can be used to work around hardware or (kernel) software problems.
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 19a64a36ecab..2dd5c282fabe 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1586,6 +1586,8 @@ static int __devinit pci_setup(char *str)
 		if (*str && (str = pcibios_setup(str)) && *str) {
 			if (!strcmp(str, "nomsi")) {
 				pci_no_msi();
+			} else if (!strcmp(str, "noaer")) {
+				pci_no_aer();
 			} else if (!strncmp(str, "cbiosize=", 9)) {
 				pci_cardbus_io_size = memparse(str + 9, &str);
 			} else if (!strncmp(str, "cbmemsize=", 10)) {

commit 229f5afded86bf3819b7b67e57c62813ca0648a7
Author: vignesh babu <vignesh.babu@wipro.com>
Date:   Mon Aug 13 18:23:14 2007 +0530

    PCI: is_power_of_2 in drivers/pci/pci.c
    
    Replacing n & (n - 1) for power of 2 check by is_power_of_2(n)
    
    Signed-off-by: vignesh babu <vignesh.babu@wipro.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 37c00f6fd801..19a64a36ecab 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -17,6 +17,7 @@
 #include <linux/module.h>
 #include <linux/spinlock.h>
 #include <linux/string.h>
+#include <linux/log2.h>
 #include <asm/dma.h>	/* isa_dma_bridge_buggy */
 #include "pci.h"
 
@@ -1454,7 +1455,7 @@ int pcix_set_mmrbc(struct pci_dev *dev, int mmrbc)
 	int cap, err = -EINVAL;
 	u32 stat, cmd, v, o;
 
-	if (mmrbc < 512 || mmrbc > 4096 || (mmrbc & (mmrbc-1)))
+	if (mmrbc < 512 || mmrbc > 4096 || !is_power_of_2(mmrbc))
 		goto out;
 
 	v = ffs(mmrbc) - 10;
@@ -1526,7 +1527,7 @@ int pcie_set_readrq(struct pci_dev *dev, int rq)
 	int cap, err = -EINVAL;
 	u16 ctl, v;
 
-	if (rq < 128 || rq > 4096 || (rq & (rq-1)))
+	if (rq < 128 || rq > 4096 || !is_power_of_2(rq))
 		goto out;
 
 	v = (ffs(rq) - 8) << 12;

commit 0b62e13b5c9b4871641973e024cc9dd440b5bb58
Author: Tejun Heo <htejun@gmail.com>
Date:   Fri Jul 27 14:43:35 2007 +0900

    pci: rename __pci_reenable_device() to pci_reenable_device()
    
    Rename __pci_reenable_device() to pci_reenable_device().
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 1ee9cd9c86e2..37c00f6fd801 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -695,14 +695,13 @@ static int do_pci_enable_device(struct pci_dev *dev, int bars)
 }
 
 /**
- * __pci_reenable_device - Resume abandoned device
+ * pci_reenable_device - Resume abandoned device
  * @dev: PCI device to be resumed
  *
  *  Note this function is a backend of pci_default_resume and is not supposed
  *  to be called by normal code, write proper resume handler and use it instead.
  */
-int
-__pci_reenable_device(struct pci_dev *dev)
+int pci_reenable_device(struct pci_dev *dev)
 {
 	if (atomic_read(&dev->enable_cnt))
 		return do_pci_enable_device(dev, (1 << PCI_NUM_RESOURCES) - 1);
@@ -1604,7 +1603,7 @@ early_param("pci", pci_setup);
 device_initcall(pci_init);
 
 EXPORT_SYMBOL_GPL(pci_restore_bars);
-EXPORT_SYMBOL(__pci_reenable_device);
+EXPORT_SYMBOL(pci_reenable_device);
 EXPORT_SYMBOL(pci_enable_device_bars);
 EXPORT_SYMBOL(pci_enable_device);
 EXPORT_SYMBOL(pcim_enable_device);

commit 42e61f4adbf18c7b0218b91d32fd6ee1f978d82c
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Mon Jul 23 21:42:11 2007 -0700

    kernel-doc fixes for PCI and drivers/base/
    
    Fix undocumented function parameters in PCI and drivers/base.
    
    Warning(linux-2.6.23-rc1//drivers/pci/pci.c:1526): No description found for parameter 'rq'
    Warning(linux-2.6.23-rc1//drivers/base/firmware_class.c:245): No description found for parameter 'bin_attr'
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index fba319d6fcc8..1ee9cd9c86e2 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1517,7 +1517,7 @@ EXPORT_SYMBOL(pcie_get_readrq);
 /**
  * pcie_set_readrq - set PCI Express maximum memory read request
  * @dev: PCI device to query
- * @count: maximum memory read count in bytes
+ * @rq: maximum memory read count in bytes
  *    valid values are 128, 256, 512, 1024, 2048, 4096
  *
  * If possible sets maximum read byte count

commit a4fb2122f1fc4a22bd6a5b8a195b952c2d31c54d
Merge: bc72450aebe7 323ef30af3a0
Author: Linus Torvalds <torvalds@woody.linux-foundation.org>
Date:   Wed Jul 25 11:28:00 2007 -0700

    Merge branch 'release' of git://git.kernel.org/pub/scm/linux/kernel/git/lenb/linux-acpi-2.6
    
    * 'release' of git://git.kernel.org/pub/scm/linux/kernel/git/lenb/linux-acpi-2.6:
      ACPI: Kconfig: remove CONFIG_ACPI_SLEEP from source
      ACPI: quiet ACPI Exceptions due to no _PTC or _TSS
      ACPI: Remove references to ACPI_STATE_S2 from acpi_pm_enter
      ACPI: Kconfig: always enable CONFIG_ACPI_SLEEP on X86
      ACPI: Kconfig: fold /proc/acpi/sleep under CONFIG_ACPI_PROCFS
      ACPI: Kconfig: CONFIG_ACPI_PROCFS now defaults to N
      ACPI: autoload modules - Create __mod_acpi_device_table symbol for all ACPI drivers
      ACPI: autoload modules - Create ACPI alias interface
      ACPI: autoload modules - ACPICA modifications
      ACPI: asus-laptop: Fix failure exits
      ACPI: fix oops due to typo in new throttling code
      ACPI: ignore _PSx method for hotplugable PCI devices
      ACPI: Use ACPI methods to select PCI device suspend state
      ACPI, PNP: hook ACPI D-state to PNP suspend/resume
      ACPI: Add acpi_pm_device_sleep_state helper routine
      ACPI: Implement the set_target() callback from pm_ops

commit f0a664bbd1839fbe9f57564983f39bfc6c6f931d
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Jul 10 15:36:05 2007 +0900

    PCI: export __pci_reenable_device()
    
    Some odd ACPI implementations choke if certain controller is disabled
    when ACPI suspend is invoked but we still need to make sure the PCI
    device is enabled during resume.  Simply using pci_enable_device()
    unbalances device enable count.  Export __pci_reenable_device().
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 03fd59e80fef..c95485398687 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1604,6 +1604,7 @@ early_param("pci", pci_setup);
 device_initcall(pci_init);
 
 EXPORT_SYMBOL_GPL(pci_restore_bars);
+EXPORT_SYMBOL(__pci_reenable_device);
 EXPORT_SYMBOL(pci_enable_device_bars);
 EXPORT_SYMBOL(pci_enable_device);
 EXPORT_SYMBOL(pcim_enable_device);

commit ab826ca4cf2fe8ebcfd21189ca8bfeb47ca88359
Author: Shaohua Li <shaohua.li@intel.com>
Date:   Fri Jul 20 10:03:22 2007 +0800

    ACPI: Use ACPI methods to select PCI device suspend state
    
    applied after Rafel's 'PM: Update global suspend and hibernation
    operations framework' patch set
    
    Signed-off-by: Shaohua Li<shaohua.li@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 03fd59e80fef..1458fd69e670 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -499,7 +499,7 @@ pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 	return 0;
 }
 
-int (*platform_pci_choose_state)(struct pci_dev *dev, pm_message_t state);
+pci_power_t (*platform_pci_choose_state)(struct pci_dev *dev, pm_message_t state);
  
 /**
  * pci_choose_state - Choose the power state of a PCI device
@@ -513,15 +513,15 @@ int (*platform_pci_choose_state)(struct pci_dev *dev, pm_message_t state);
 
 pci_power_t pci_choose_state(struct pci_dev *dev, pm_message_t state)
 {
-	int ret;
+	pci_power_t ret;
 
 	if (!pci_find_capability(dev, PCI_CAP_ID_PM))
 		return PCI_D0;
 
 	if (platform_pci_choose_state) {
 		ret = platform_pci_choose_state(dev, state);
-		if (ret >= 0)
-			state.event = ret;
+		if (ret != PCI_POWER_ERROR)
+			return ret;
 	}
 
 	switch (state.event) {

commit cca03dec2f0eb8f3c4578e067d2b20a366b940db
Author: Andrew Lunn <andrew.lunn@ascom.ch>
Date:   Mon Jul 9 11:55:58 2007 -0700

    PCI: pci_set_power_state(): check for PM capabilities earlier
    
    Check for PCI_CAP_ID_PM before checking the device state.  Apparently fixes
    some log spam via the 3c59x driver.
    
    Signed-off-by: Andrew Lunn <andrew.lunn@ascom.ch>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 35fa30aa3065..03fd59e80fef 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -406,6 +406,13 @@ pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 	if ((state == PCI_D1 || state == PCI_D2) && pci_no_d1d2(dev))
 		return 0;
 
+	/* find PCI PM capability in list */
+	pm = pci_find_capability(dev, PCI_CAP_ID_PM);
+
+	/* abort if the device doesn't support PM capabilities */
+	if (!pm)
+		return -EIO;
+
 	/* Validate current state:
 	 * Can enter D0 from any state, but if we can only go deeper 
 	 * to sleep if we're already in a low power state
@@ -418,13 +425,6 @@ pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 		return 0;        /* we're already there */
 
 
-	/* find PCI PM capability in list */
-	pm = pci_find_capability(dev, PCI_CAP_ID_PM);
-	
-	/* abort if the device doesn't support PM capabilities */
-	if (!pm)
-		return -EIO; 
-
 	pci_read_config_word(dev,pm + PCI_PM_PMC,&pmc);
 	if ((pmc & PCI_PM_CAP_VER_MASK) > 3) {
 		printk(KERN_DEBUG

commit 694625c0b322905d6892fad873029f764cd4823f
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Mon Jul 9 11:55:54 2007 -0700

    PCI: add pci_try_set_mwi
    
    As suggested by Andrew, add pci_try_set_mwi(), which does not require
    return-value checking.
    
    - add pci_try_set_mwi() without __must_check
    - make it return 0 on success, errno if the "try" failed or error
    - review callers
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index d9fc1bd1f3e8..35fa30aa3065 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1186,6 +1186,11 @@ int pci_set_mwi(struct pci_dev *dev)
 	return 0;
 }
 
+int pci_try_set_mwi(struct pci_dev *dev)
+{
+	return 0;
+}
+
 void pci_clear_mwi(struct pci_dev *dev)
 {
 }
@@ -1242,9 +1247,7 @@ pci_set_cacheline_size(struct pci_dev *dev)
  * pci_set_mwi - enables memory-write-invalidate PCI transaction
  * @dev: the PCI device for which MWI is enabled
  *
- * Enables the Memory-Write-Invalidate transaction in %PCI_COMMAND,
- * and then calls @pcibios_set_mwi to do the needed arch specific
- * operations or a generic mwi-prep function.
+ * Enables the Memory-Write-Invalidate transaction in %PCI_COMMAND.
  *
  * RETURNS: An appropriate -ERRNO error value on error, or zero for success.
  */
@@ -1260,7 +1263,8 @@ pci_set_mwi(struct pci_dev *dev)
 
 	pci_read_config_word(dev, PCI_COMMAND, &cmd);
 	if (! (cmd & PCI_COMMAND_INVALIDATE)) {
-		pr_debug("PCI: Enabling Mem-Wr-Inval for device %s\n", pci_name(dev));
+		pr_debug("PCI: Enabling Mem-Wr-Inval for device %s\n",
+			pci_name(dev));
 		cmd |= PCI_COMMAND_INVALIDATE;
 		pci_write_config_word(dev, PCI_COMMAND, cmd);
 	}
@@ -1268,6 +1272,21 @@ pci_set_mwi(struct pci_dev *dev)
 	return 0;
 }
 
+/**
+ * pci_try_set_mwi - enables memory-write-invalidate PCI transaction
+ * @dev: the PCI device for which MWI is enabled
+ *
+ * Enables the Memory-Write-Invalidate transaction in %PCI_COMMAND.
+ * Callers are not required to check the return value.
+ *
+ * RETURNS: An appropriate -ERRNO error value on error, or zero for success.
+ */
+int pci_try_set_mwi(struct pci_dev *dev)
+{
+	int rc = pci_set_mwi(dev);
+	return rc;
+}
+
 /**
  * pci_clear_mwi - disables Memory-Write-Invalidate for device dev
  * @dev: the PCI device to disable
@@ -1600,6 +1619,7 @@ EXPORT_SYMBOL(pci_release_selected_regions);
 EXPORT_SYMBOL(pci_request_selected_regions);
 EXPORT_SYMBOL(pci_set_master);
 EXPORT_SYMBOL(pci_set_mwi);
+EXPORT_SYMBOL(pci_try_set_mwi);
 EXPORT_SYMBOL(pci_clear_mwi);
 EXPORT_SYMBOL_GPL(pci_intx);
 EXPORT_SYMBOL(pci_set_dma_mask);

commit b7b095c154c50ee753832bbf78e8690c492fc8f6
Author: Andrew Morton <akpm@linux-foundation.org>
Date:   Mon Jul 9 11:55:50 2007 -0700

    PCI: pci-x-pci-express-read-control-interfaces cleanups
    
    - remove unneeded local
    
    - 80-col fix
    
    Cc: Peter Oruba <peter.oruba@amd.com>
    Cc: Roland Dreier <rolandd@cisco.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 1bb879959a20..d9fc1bd1f3e8 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1383,7 +1383,7 @@ pci_set_consistent_dma_mask(struct pci_dev *dev, u64 mask)
  */
 int pcix_get_max_mmrbc(struct pci_dev *dev)
 {
-	int ret, err, cap;
+	int err, cap;
 	u32 stat;
 
 	cap = pci_find_capability(dev, PCI_CAP_ID_PCIX);
@@ -1394,9 +1394,7 @@ int pcix_get_max_mmrbc(struct pci_dev *dev)
 	if (err)
 		return -EINVAL;
 
-	ret = (stat & PCI_X_STATUS_MAX_READ) >> 12;
-
-	return ret;
+	return (stat & PCI_X_STATUS_MAX_READ) >> 12;
 }
 EXPORT_SYMBOL(pcix_get_max_mmrbc);
 

commit d556ad4bbe75faf17b239e151a9f003322b2e851
Author: Peter Oruba <peter.oruba@amd.com>
Date:   Tue May 15 13:59:13 2007 +0200

    PCI: add PCI-X/PCI-Express read control interfaces
    
    This patch introduces an interface to read and write PCI-X / PCI-Express
    maximum read byte count values from PCI config space. There is a second
    function that returns the maximum _designed_ read byte count, which marks the
    maximum value for a device, since some drivers try to set MMRBC to the
    highest allowed value and rely on such a function.
    
    Based on patch set by Stephen Hemminger <shemminger@linux-foundation.org>
    
    Cc: Stephen Hemminger <shemminger@linux-foundation.org>
    Signed-off-by: Peter Oruba <peter.oruba@amd.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index fd47ac0c4730..1bb879959a20 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1374,6 +1374,166 @@ pci_set_consistent_dma_mask(struct pci_dev *dev, u64 mask)
 }
 #endif
 
+/**
+ * pcix_get_max_mmrbc - get PCI-X maximum designed memory read byte count
+ * @dev: PCI device to query
+ *
+ * Returns mmrbc: maximum designed memory read count in bytes
+ *    or appropriate error value.
+ */
+int pcix_get_max_mmrbc(struct pci_dev *dev)
+{
+	int ret, err, cap;
+	u32 stat;
+
+	cap = pci_find_capability(dev, PCI_CAP_ID_PCIX);
+	if (!cap)
+		return -EINVAL;
+
+	err = pci_read_config_dword(dev, cap + PCI_X_STATUS, &stat);
+	if (err)
+		return -EINVAL;
+
+	ret = (stat & PCI_X_STATUS_MAX_READ) >> 12;
+
+	return ret;
+}
+EXPORT_SYMBOL(pcix_get_max_mmrbc);
+
+/**
+ * pcix_get_mmrbc - get PCI-X maximum memory read byte count
+ * @dev: PCI device to query
+ *
+ * Returns mmrbc: maximum memory read count in bytes
+ *    or appropriate error value.
+ */
+int pcix_get_mmrbc(struct pci_dev *dev)
+{
+	int ret, cap;
+	u32 cmd;
+
+	cap = pci_find_capability(dev, PCI_CAP_ID_PCIX);
+	if (!cap)
+		return -EINVAL;
+
+	ret = pci_read_config_dword(dev, cap + PCI_X_CMD, &cmd);
+	if (!ret)
+		ret = 512 << ((cmd & PCI_X_CMD_MAX_READ) >> 2);
+
+	return ret;
+}
+EXPORT_SYMBOL(pcix_get_mmrbc);
+
+/**
+ * pcix_set_mmrbc - set PCI-X maximum memory read byte count
+ * @dev: PCI device to query
+ * @mmrbc: maximum memory read count in bytes
+ *    valid values are 512, 1024, 2048, 4096
+ *
+ * If possible sets maximum memory read byte count, some bridges have erratas
+ * that prevent this.
+ */
+int pcix_set_mmrbc(struct pci_dev *dev, int mmrbc)
+{
+	int cap, err = -EINVAL;
+	u32 stat, cmd, v, o;
+
+	if (mmrbc < 512 || mmrbc > 4096 || (mmrbc & (mmrbc-1)))
+		goto out;
+
+	v = ffs(mmrbc) - 10;
+
+	cap = pci_find_capability(dev, PCI_CAP_ID_PCIX);
+	if (!cap)
+		goto out;
+
+	err = pci_read_config_dword(dev, cap + PCI_X_STATUS, &stat);
+	if (err)
+		goto out;
+
+	if (v > (stat & PCI_X_STATUS_MAX_READ) >> 21)
+		return -E2BIG;
+
+	err = pci_read_config_dword(dev, cap + PCI_X_CMD, &cmd);
+	if (err)
+		goto out;
+
+	o = (cmd & PCI_X_CMD_MAX_READ) >> 2;
+	if (o != v) {
+		if (v > o && dev->bus &&
+		   (dev->bus->bus_flags & PCI_BUS_FLAGS_NO_MMRBC))
+			return -EIO;
+
+		cmd &= ~PCI_X_CMD_MAX_READ;
+		cmd |= v << 2;
+		err = pci_write_config_dword(dev, cap + PCI_X_CMD, cmd);
+	}
+out:
+	return err;
+}
+EXPORT_SYMBOL(pcix_set_mmrbc);
+
+/**
+ * pcie_get_readrq - get PCI Express read request size
+ * @dev: PCI device to query
+ *
+ * Returns maximum memory read request in bytes
+ *    or appropriate error value.
+ */
+int pcie_get_readrq(struct pci_dev *dev)
+{
+	int ret, cap;
+	u16 ctl;
+
+	cap = pci_find_capability(dev, PCI_CAP_ID_EXP);
+	if (!cap)
+		return -EINVAL;
+
+	ret = pci_read_config_word(dev, cap + PCI_EXP_DEVCTL, &ctl);
+	if (!ret)
+	ret = 128 << ((ctl & PCI_EXP_DEVCTL_READRQ) >> 12);
+
+	return ret;
+}
+EXPORT_SYMBOL(pcie_get_readrq);
+
+/**
+ * pcie_set_readrq - set PCI Express maximum memory read request
+ * @dev: PCI device to query
+ * @count: maximum memory read count in bytes
+ *    valid values are 128, 256, 512, 1024, 2048, 4096
+ *
+ * If possible sets maximum read byte count
+ */
+int pcie_set_readrq(struct pci_dev *dev, int rq)
+{
+	int cap, err = -EINVAL;
+	u16 ctl, v;
+
+	if (rq < 128 || rq > 4096 || (rq & (rq-1)))
+		goto out;
+
+	v = (ffs(rq) - 8) << 12;
+
+	cap = pci_find_capability(dev, PCI_CAP_ID_EXP);
+	if (!cap)
+		goto out;
+
+	err = pci_read_config_word(dev, cap + PCI_EXP_DEVCTL, &ctl);
+	if (err)
+		goto out;
+
+	if ((ctl & PCI_EXP_DEVCTL_READRQ) != v) {
+		ctl &= ~PCI_EXP_DEVCTL_READRQ;
+		ctl |= v;
+		err = pci_write_config_dword(dev, cap + PCI_EXP_DEVCTL, ctl);
+	}
+
+out:
+	return err;
+}
+EXPORT_SYMBOL(pcie_set_readrq);
+
 /**
  * pci_select_bars - Make BAR mask from the type of resource
  * @dev: the PCI device for which BAR mask is made

commit 96bde06a2df1b363206d3cdef53134b84ff37813
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Mon Mar 26 21:53:30 2007 -0800

    pci: do not mark exported functions as __devinit
    
    Functions marked __devinit will be removed after kernel init.  But being
    exported they are potentially called by a module much later.
    
    So the safer choice seems to be to keep the function even in the non
    CONFIG_HOTPLUG case.
    
    This silence the follwoing section mismatch warnings:
    WARNING: drivers/built-in.o - Section mismatch: reference to .init.text:pci_bus_add_device from __ksymtab_gpl between '__ksymtab_pci_bus_add_device' (at offset 0x20) and '__ksymtab_pci_walk_bus'
    WARNING: drivers/built-in.o - Section mismatch: reference to .init.text:pci_create_bus from __ksymtab_gpl between '__ksymtab_pci_create_bus' (at offset 0x40) and '__ksymtab_pci_stop_bus_device'
    WARNING: drivers/built-in.o - Section mismatch: reference to .init.text:pci_bus_max_busnr from __ksymtab_gpl between '__ksymtab_pci_bus_max_busnr' (at offset 0xc0) and '__ksymtab_pci_assign_resource_fixed'
    WARNING: drivers/built-in.o - Section mismatch: reference to .init.text:pci_claim_resource from __ksymtab_gpl between '__ksymtab_pci_claim_resource' (at offset 0xe0) and '__ksymtab_pcie_port_bus_type'
    WARNING: drivers/built-in.o - Section mismatch: reference to .init.text:pci_bus_add_devices from __ksymtab between '__ksymtab_pci_bus_add_devices' (at offset 0x70) and '__ksymtab_pci_bus_alloc_resource'
    WARNING: drivers/built-in.o - Section mismatch: reference to .init.text:pci_scan_bus_parented from __ksymtab between '__ksymtab_pci_scan_bus_parented' (at offset 0x90) and '__ksymtab_pci_root_buses'
    WARNING: drivers/built-in.o - Section mismatch: reference to .init.text:pci_bus_assign_resources from __ksymtab between '__ksymtab_pci_bus_assign_resources' (at offset 0x4d0) and '__ksymtab_pci_bus_size_bridges'
    WARNING: drivers/built-in.o - Section mismatch: reference to .init.text:pci_bus_size_bridges from __ksymtab between '__ksymtab_pci_bus_size_bridges' (at offset 0x4e0) and '__ksymtab_pci_setup_cardbus'
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 7bd8a725bea2..fd47ac0c4730 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -35,8 +35,7 @@ unsigned long pci_cardbus_mem_size = DEFAULT_CARDBUS_MEM_SIZE;
  * Given a PCI bus, returns the highest PCI bus number present in the set
  * including the given PCI bus and its list of child PCI buses.
  */
-unsigned char __devinit
-pci_bus_max_busnr(struct pci_bus* bus)
+unsigned char pci_bus_max_busnr(struct pci_bus* bus)
 {
 	struct list_head *tmp;
 	unsigned char max, n;

commit 8d7d86e9bd377e5779bf3c8da03b27d823c039b4
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Fri Mar 16 19:55:52 2007 -0700

    PCI: kernel-doc fix
    
    Warning(linux-2621-rc3g7/drivers/pci/pci.c:1283): No description found for parameter 'dev'
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 2086cd1b5e0e..7bd8a725bea2 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1323,7 +1323,7 @@ pci_intx(struct pci_dev *pdev, int enable)
 
 /**
  * pci_msi_off - disables any msi or msix capabilities
- * @pdev: the PCI device to operate on
+ * @dev: the PCI device to operate on
  *
  * If you want to use msi see pci_enable_msi and friends.
  * This is a lower level primitive that allows us to disable

commit f7bdd12d234d9064bd0aa1b5610508959120a9b4
Author: Brian King <brking@linux.vnet.ibm.com>
Date:   Fri Apr 6 16:39:36 2007 -0500

    pci: New PCI-E reset API
    
    Adds a new API which can be used to issue various types
    of PCI-E reset, including PCI-E warm reset and PCI-E hot reset.
    This is needed for an ipr PCI-E adapter which does not properly
    implement BIST. Running BIST on this adapter results in PCI-E
    errors. The only reliable reset mechanism that exists on this
    hardware is PCI Fundamental reset (warm reset). Since driving
    this type of reset is architecture unique, this provides the
    necessary hooks for architectures to add this support.
    
    Signed-off-by: Brian King <brking@linux.vnet.ibm.com>
    Acked-by: Linas Vepstas <linas@austin.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 2a458279327a..2086cd1b5e0e 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -891,6 +891,34 @@ pci_disable_device(struct pci_dev *dev)
 	pcibios_disable_device(dev);
 }
 
+/**
+ * pcibios_set_pcie_reset_state - set reset state for device dev
+ * @dev: the PCI-E device reset
+ * @state: Reset state to enter into
+ *
+ *
+ * Sets the PCI-E reset state for the device. This is the default
+ * implementation. Architecture implementations can override this.
+ */
+int __attribute__ ((weak)) pcibios_set_pcie_reset_state(struct pci_dev *dev,
+							enum pcie_reset_state state)
+{
+	return -EINVAL;
+}
+
+/**
+ * pci_set_pcie_reset_state - set reset state for device dev
+ * @dev: the PCI-E device reset
+ * @state: Reset state to enter into
+ *
+ *
+ * Sets the PCI reset state for the device.
+ */
+int pci_set_pcie_reset_state(struct pci_dev *dev, enum pcie_reset_state state)
+{
+	return pcibios_set_pcie_reset_state(dev, state);
+}
+
 /**
  * pci_enable_wake - enable PCI device as wakeup event source
  * @dev: PCI device affected
@@ -1427,4 +1455,5 @@ EXPORT_SYMBOL(pci_set_power_state);
 EXPORT_SYMBOL(pci_save_state);
 EXPORT_SYMBOL(pci_restore_state);
 EXPORT_SYMBOL(pci_enable_wake);
+EXPORT_SYMBOL_GPL(pci_set_pcie_reset_state);
 

commit 075c1771526c85849ed22298d048bc07e400aee5
Author: David Brownell <david-b@pacbell.net>
Date:   Thu Apr 26 00:12:06 2007 -0700

    define platform wakeup hook, use in pci_enable_wake()
    
    This defines a platform hook to enable/disable a device as a wakeup event
    source.  It's initially for use with ACPI, but more generally it could be used
    whenever enable_irq_wake()/disable_irq_wake() don't suffice.
    
    The hook is called -- if available -- inside pci_enable_wake(); and the
    semantics of that call are enhanced so that support for PCI PME# is no longer
    needed.  It can now work for devices with "legacy PCI PM", when platform
    support allows it.  (That support would use some board-specific signal for for
    the same purpose as PME#.)
    
    [akpm@linux-foundation.org: Make it compile with CONFIG_PM=n]
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Cc: Len Brown <lenb@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index d3eab057b2d3..2a458279327a 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -13,6 +13,7 @@
 #include <linux/delay.h>
 #include <linux/init.h>
 #include <linux/pci.h>
+#include <linux/pm.h>
 #include <linux/module.h>
 #include <linux/spinlock.h>
 #include <linux/string.h>
@@ -891,31 +892,48 @@ pci_disable_device(struct pci_dev *dev)
 }
 
 /**
- * pci_enable_wake - enable device to generate PME# when suspended
- * @dev: - PCI device to operate on
- * @state: - Current state of device.
- * @enable: - Flag to enable or disable generation
- * 
- * Set the bits in the device's PM Capabilities to generate PME# when
- * the system is suspended. 
+ * pci_enable_wake - enable PCI device as wakeup event source
+ * @dev: PCI device affected
+ * @state: PCI state from which device will issue wakeup events
+ * @enable: True to enable event generation; false to disable
  *
- * -EIO is returned if device doesn't have PM Capabilities. 
- * -EINVAL is returned if device supports it, but can't generate wake events.
- * 0 if operation is successful.
- * 
+ * This enables the device as a wakeup event source, or disables it.
+ * When such events involves platform-specific hooks, those hooks are
+ * called automatically by this routine.
+ *
+ * Devices with legacy power management (no standard PCI PM capabilities)
+ * always require such platform hooks.  Depending on the platform, devices
+ * supporting the standard PCI PME# signal may require such platform hooks;
+ * they always update bits in config space to allow PME# generation.
+ *
+ * -EIO is returned if the device can't ever be a wakeup event source.
+ * -EINVAL is returned if the device can't generate wakeup events from
+ * the specified PCI state.  Returns zero if the operation is successful.
  */
 int pci_enable_wake(struct pci_dev *dev, pci_power_t state, int enable)
 {
 	int pm;
+	int status;
 	u16 value;
 
+	/* Note that drivers should verify device_may_wakeup(&dev->dev)
+	 * before calling this function.  Platform code should report
+	 * errors when drivers try to enable wakeup on devices that
+	 * can't issue wakeups, or on which wakeups were disabled by
+	 * userspace updating the /sys/devices.../power/wakeup file.
+	 */
+
+	status = call_platform_enable_wakeup(&dev->dev, enable);
+
 	/* find PCI PM capability in list */
 	pm = pci_find_capability(dev, PCI_CAP_ID_PM);
 
-	/* If device doesn't support PM Capabilities, but request is to disable
-	 * wake events, it's a nop; otherwise fail */
-	if (!pm) 
-		return enable ? -EIO : 0; 
+	/* If device doesn't support PM Capabilities, but caller wants to
+	 * disable wake events, it's a NOP.  Otherwise fail unless the
+	 * platform hooks handled this legacy device already.
+	 */
+	if (!pm)
+		return enable ? status : 0;
 
 	/* Check device's ability to generate PME# */
 	pci_read_config_word(dev,pm+PCI_PM_PMC,&value);
@@ -924,8 +942,14 @@ int pci_enable_wake(struct pci_dev *dev, pci_power_t state, int enable)
 	value >>= ffs(PCI_PM_CAP_PME_MASK) - 1;   /* First bit of mask */
 
 	/* Check if it can generate PME# from requested state. */
-	if (!value || !(value & (1 << state))) 
+	if (!value || !(value & (1 << state))) {
+		/* if it can't, revert what the platform hook changed,
+		 * always reporting the base "EINVAL, can't PME#" error
+		 */
+		if (enable)
+			call_platform_enable_wakeup(&dev->dev, 0);
 		return enable ? -EINVAL : 0;
+	}
 
 	pci_read_config_word(dev, pm + PCI_PM_CTRL, &value);
 
@@ -936,7 +960,7 @@ int pci_enable_wake(struct pci_dev *dev, pci_power_t state, int enable)
 		value &= ~PCI_PM_CTRL_PME_ENABLE;
 
 	pci_write_config_word(dev, pm + PCI_PM_CTRL, value);
-	
+
 	return 0;
 }
 

commit 9f35575dfc172f0a93fb464761883c8f49599b7a
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Thu Mar 8 13:06:13 2007 -0700

    [PATCH] pci: Repair pci_save/restore_state so we can restore one save many times.
    
    Because we do not reserve space for the pci-x and pci-e state in struct
    pci dev we need to dynamically allocate it.  However because we need
    to support restore being called multiple times after a single save
    it is never safe to free the buffers we have allocated to hold the
    state.
    
    So this patch modifies the save routines to first check to see
    if we have already allocated a state buffer before allocating
    a new one.  Then the restore routines are modified to not free
    the state after restoring it.  Simple and it fixes some subtle
    error path handling bugs, that are hard to test for.
    
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    Acked-by: Auke Kok <auke-jan.h.kok@intel.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 6048c0c637a0..d3eab057b2d3 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -551,7 +551,9 @@ static int pci_save_pcie_state(struct pci_dev *dev)
 	if (pos <= 0)
 		return 0;
 
-	save_state = kzalloc(sizeof(*save_state) + sizeof(u16) * 4, GFP_KERNEL);
+	save_state = pci_find_saved_cap(dev, PCI_CAP_ID_EXP);
+	if (!save_state)
+		save_state = kzalloc(sizeof(*save_state) + sizeof(u16) * 4, GFP_KERNEL);
 	if (!save_state) {
 		dev_err(&dev->dev, "Out of memory in pci_save_pcie_state\n");
 		return -ENOMEM;
@@ -582,8 +584,6 @@ static void pci_restore_pcie_state(struct pci_dev *dev)
 	pci_write_config_word(dev, pos + PCI_EXP_LNKCTL, cap[i++]);
 	pci_write_config_word(dev, pos + PCI_EXP_SLTCTL, cap[i++]);
 	pci_write_config_word(dev, pos + PCI_EXP_RTCTL, cap[i++]);
-	pci_remove_saved_cap(save_state);
-	kfree(save_state);
 }
 
 
@@ -597,7 +597,9 @@ static int pci_save_pcix_state(struct pci_dev *dev)
 	if (pos <= 0)
 		return 0;
 
-	save_state = kzalloc(sizeof(*save_state) + sizeof(u16), GFP_KERNEL);
+	save_state = pci_find_saved_cap(dev, PCI_CAP_ID_EXP);
+	if (!save_state)
+		save_state = kzalloc(sizeof(*save_state) + sizeof(u16), GFP_KERNEL);
 	if (!save_state) {
 		dev_err(&dev->dev, "Out of memory in pci_save_pcie_state\n");
 		return -ENOMEM;
@@ -622,8 +624,6 @@ static void pci_restore_pcix_state(struct pci_dev *dev)
 	cap = (u16 *)&save_state->data[0];
 
 	pci_write_config_word(dev, pos + PCI_X_CMD, cap[i++]);
-	pci_remove_saved_cap(save_state);
-	kfree(save_state);
 }
 
 

commit 392ee1e6dd901db6c4504617476f6442ed91f72d
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Thu Mar 8 13:04:57 2007 -0700

    [PATCH] msi: Safer state caching.
    
    There are two ways pci_save_state and pci_restore_state are used.  As
    helper functions during suspend/resume, and as helper functions around
    a hardware reset event.  When used as helper functions around a hardware
    reset event there is no reason to believe the calls will be paired, nor
    is there a good reason to believe that if we restore the msi state from
    before the reset that it will match the current msi state.  Since arch
    code may change the msi message without going through the driver, drivers
    currently do not have enough information to even know when to call
    pci_save_state to ensure they will have msi state in sync with the other
    kernel irq reception data structures.
    
    It turns out the solution is straight forward, cache the state in the
    existing msi data structures (not the magic pci saved things) and
    have the msi code update the cached state each time we write to the hardware.
    This means we never need to read the hardware to figure out what the hardware
    state should be.
    
    By modifying the caching in this manner we get to remove our save_state
    routines and only need to provide restore_state routines.
    
    The only fields that were at all tricky to regenerate were the msi and msi-x
    control registers and the way we regenerate them currently is a bit dependent
    upon assumptions on how we use the allow msi registers to be configured and used
    making the code a little bit brittle.  If we ever change what cases we allow
    or how we configure the msi bits we can address the fragility then.
    
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    Acked-by: Auke Kok <auke-jan.h.kok@intel.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index a32db0628157..6048c0c637a0 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -638,8 +638,6 @@ pci_save_state(struct pci_dev *dev)
 	/* XXX: 100% dword access ok here? */
 	for (i = 0; i < 16; i++)
 		pci_read_config_dword(dev, i * 4,&dev->saved_config_space[i]);
-	if ((i = pci_save_msi_state(dev)) != 0)
-		return i;
 	if ((i = pci_save_pcie_state(dev)) != 0)
 		return i;
 	if ((i = pci_save_pcix_state(dev)) != 0)

commit 7f375f325feacd8a628e00e0d53390a4f6d8abc2
Author: Tejun Heo <htejun@gmail.com>
Date:   Sun Feb 25 04:36:01 2007 -0800

    PCI: allow multiple calls to pcim_pin_device()
    
    Sanity check in pcim_pin_device() was too restrictive in that it didn't
    allow multiple calls to the function, which is against the devres
    philosohpy of fire-and-forget.  Track pinned status separately and allow
    pinning multiple times.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Acked-by: Ian McDonald <ian.mcdonald@jandi.co.nz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index df495300ce3d..a32db0628157 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -757,7 +757,8 @@ int pci_enable_device(struct pci_dev *dev)
  * when a device is enabled using managed PCI device enable interface.
  */
 struct pci_devres {
-	unsigned int disable:1;
+	unsigned int enabled:1;
+	unsigned int pinned:1;
 	unsigned int orig_intx:1;
 	unsigned int restore_intx:1;
 	u32 region_mask;
@@ -781,7 +782,7 @@ static void pcim_release(struct device *gendev, void *res)
 	if (this->restore_intx)
 		pci_intx(dev, this->orig_intx);
 
-	if (this->disable)
+	if (this->enabled && !this->pinned)
 		pci_disable_device(dev);
 }
 
@@ -820,12 +821,12 @@ int pcim_enable_device(struct pci_dev *pdev)
 	dr = get_pci_dr(pdev);
 	if (unlikely(!dr))
 		return -ENOMEM;
-	WARN_ON(!!dr->disable);
+	WARN_ON(!!dr->enabled);
 
 	rc = pci_enable_device(pdev);
 	if (!rc) {
 		pdev->is_managed = 1;
-		dr->disable = 1;
+		dr->enabled = 1;
 	}
 	return rc;
 }
@@ -843,9 +844,9 @@ void pcim_pin_device(struct pci_dev *pdev)
 	struct pci_devres *dr;
 
 	dr = find_pci_dr(pdev);
-	WARN_ON(!dr || !dr->disable);
+	WARN_ON(!dr || !dr->enabled);
 	if (dr)
-		dr->disable = 0;
+		dr->pinned = 1;
 }
 
 /**
@@ -876,7 +877,7 @@ pci_disable_device(struct pci_dev *dev)
 
 	dr = find_pci_dr(dev);
 	if (dr)
-		dr->disable = 0;
+		dr->enabled = 0;
 
 	if (atomic_sub_return(1, &dev->enable_cnt) != 0)
 		return;

commit f5f2b13129a6541debf8851bae843cbbf48298b7
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Mon Mar 5 00:30:07 2007 -0800

    [PATCH] msi: sanely support hardware level msi disabling
    
    In some cases when we are not using msi we need a way to ensure that the
    hardware does not have an msi capability enabled.  Currently the code has been
    calling disable_msi_mode to try and achieve that.  However disable_msi_mode
    has several other side effects and is only available when msi support is
    compiled in so it isn't really appropriate.
    
    Instead this patch implements pci_msi_off which disables all msi and msix
    capabilities unconditionally with no additional side effects.
    
    pci_disable_device was redundantly clearing the bus master enable flag and
    clearing the msi enable bit.  A device that is not allowed to perform bus
    mastering operations cannot generate intx or msi interrupt messages as those
    are essentially a special case of dma, and require bus mastering.  So the call
    in pci_disable_device to disable msi capabilities was redundant.
    
    quirk_pcie_pxh also called disable_msi_mode and is updated to use pci_msi_off.
    
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>
    Cc: Michael Ellerman <michael@ellerman.id.au>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Greg KH <greg@kroah.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 1e74e1ee8bd8..df495300ce3d 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -881,13 +881,6 @@ pci_disable_device(struct pci_dev *dev)
 	if (atomic_sub_return(1, &dev->enable_cnt) != 0)
 		return;
 
-	if (dev->msi_enabled)
-		disable_msi_mode(dev, pci_find_capability(dev, PCI_CAP_ID_MSI),
-			PCI_CAP_ID_MSI);
-	if (dev->msix_enabled)
-		disable_msi_mode(dev, pci_find_capability(dev, PCI_CAP_ID_MSI),
-			PCI_CAP_ID_MSIX);
-
 	pci_read_config_word(dev, PCI_COMMAND, &pci_command);
 	if (pci_command & PCI_COMMAND_MASTER) {
 		pci_command &= ~PCI_COMMAND_MASTER;
@@ -1277,6 +1270,33 @@ pci_intx(struct pci_dev *pdev, int enable)
 	}
 }
 
+/**
+ * pci_msi_off - disables any msi or msix capabilities
+ * @pdev: the PCI device to operate on
+ *
+ * If you want to use msi see pci_enable_msi and friends.
+ * This is a lower level primitive that allows us to disable
+ * msi operation at the device level.
+ */
+void pci_msi_off(struct pci_dev *dev)
+{
+	int pos;
+	u16 control;
+
+	pos = pci_find_capability(dev, PCI_CAP_ID_MSI);
+	if (pos) {
+		pci_read_config_word(dev, pos + PCI_MSI_FLAGS, &control);
+		control &= ~PCI_MSI_FLAGS_ENABLE;
+		pci_write_config_word(dev, pos + PCI_MSI_FLAGS, control);
+	}
+	pos = pci_find_capability(dev, PCI_CAP_ID_MSIX);
+	if (pos) {
+		pci_read_config_word(dev, pos + PCI_MSIX_FLAGS, &control);
+		control &= ~PCI_MSIX_FLAGS_ENABLE;
+		pci_write_config_word(dev, pos + PCI_MSIX_FLAGS, control);
+	}
+}
+
 #ifndef HAVE_ARCH_PCI_SET_DMA_MASK
 /*
  * These can be overridden by arch-specific implementations

commit 4516a618a76eae6eb1b37259ad49f39b7b7f33d8
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Mon Feb 5 16:36:06 2007 -0800

    PCI: Make CARDBUS_MEM_SIZE and CARDBUS_IO_SIZE boot options
    
    CARDBUS_MEM_SIZE was increased to 64MB on 2.6.20-rc2, but larger size might
    result in allocation failure for the reserving itself on some platforms
    (for example typical 32bit MIPS).  Make it (and CARDBUS_IO_SIZE too)
    customizable by "pci=" option for such platforms.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Cc: Daniel Ritz <daniel.ritz@gmx.ch>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
    Cc: Dominik Brodowski <linux@dominikbrodowski.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index a7b869e24650..1e74e1ee8bd8 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -21,6 +21,12 @@
 
 unsigned int pci_pm_d3_delay = 10;
 
+#define DEFAULT_CARDBUS_IO_SIZE		(256)
+#define DEFAULT_CARDBUS_MEM_SIZE	(64*1024*1024)
+/* pci=cbmemsize=nnM,cbiosize=nn can override this */
+unsigned long pci_cardbus_io_size = DEFAULT_CARDBUS_IO_SIZE;
+unsigned long pci_cardbus_mem_size = DEFAULT_CARDBUS_MEM_SIZE;
+
 /**
  * pci_bus_max_busnr - returns maximum PCI bus number of given bus' children
  * @bus: pointer to PCI bus structure to search
@@ -1333,6 +1339,10 @@ static int __devinit pci_setup(char *str)
 		if (*str && (str = pcibios_setup(str)) && *str) {
 			if (!strcmp(str, "nomsi")) {
 				pci_no_msi();
+			} else if (!strncmp(str, "cbiosize=", 9)) {
+				pci_cardbus_io_size = memparse(str + 9, &str);
+			} else if (!strncmp(str, "cbmemsize=", 10)) {
+				pci_cardbus_mem_size = memparse(str + 10, &str);
 			} else {
 				printk(KERN_ERR "PCI: Unknown option `%s'\n",
 						str);

commit f95d882d81ee731be2a4a3b34f86810e29b68836
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Sat Feb 10 14:41:56 2007 -0800

    PCI/sysfs/kobject kernel-doc fixes
    
    Fix kernel-doc warnings in PCI, sysfs, and kobject files.
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 8b44cff2c176..a7b869e24650 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1300,7 +1300,7 @@ pci_set_consistent_dma_mask(struct pci_dev *dev, u64 mask)
 
 /**
  * pci_select_bars - Make BAR mask from the type of resource
- * @pdev: the PCI device for which BAR mask is made
+ * @dev: the PCI device for which BAR mask is made
  * @flags: resource type mask to be selected
  *
  * This helper routine makes bar mask from the type of resource.

commit 9ac7849e35f705830f7b016ff272b0ff1f7ff759
Author: Tejun Heo <htejun@gmail.com>
Date:   Sat Jan 20 16:00:26 2007 +0900

    devres: device resource management
    
    Implement device resource management, in short, devres.  A device
    driver can allocate arbirary size of devres data which is associated
    with a release function.  On driver detach, release function is
    invoked on the devres data, then, devres data is freed.
    
    devreses are typed by associated release functions.  Some devreses are
    better represented by single instance of the type while others need
    multiple instances sharing the same release function.  Both usages are
    supported.
    
    devreses can be grouped using devres group such that a device driver
    can easily release acquired resources halfway through initialization
    or selectively release resources (e.g. resources for port 1 out of 4
    ports).
    
    This patch adds devres core including documentation and the following
    managed interfaces.
    
    * alloc/free    : devm_kzalloc(), devm_kzfree()
    * IO region     : devm_request_region(), devm_release_region()
    * IRQ           : devm_request_irq(), devm_free_irq()
    * DMA           : dmam_alloc_coherent(), dmam_free_coherent(),
                      dmam_declare_coherent_memory(), dmam_pool_create(),
                      dmam_pool_destroy()
    * PCI           : pcim_enable_device(), pcim_pin_device(), pci_is_managed()
    * iomap         : devm_ioport_map(), devm_ioport_unmap(), devm_ioremap(),
                      devm_ioremap_nocache(), devm_iounmap(), pcim_iomap_table(),
                      pcim_iomap(), pcim_iounmap()
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 84c757ba0664..8b44cff2c176 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -744,6 +744,104 @@ int pci_enable_device(struct pci_dev *dev)
 	return pci_enable_device_bars(dev, (1 << PCI_NUM_RESOURCES) - 1);
 }
 
+/*
+ * Managed PCI resources.  This manages device on/off, intx/msi/msix
+ * on/off and BAR regions.  pci_dev itself records msi/msix status, so
+ * there's no need to track it separately.  pci_devres is initialized
+ * when a device is enabled using managed PCI device enable interface.
+ */
+struct pci_devres {
+	unsigned int disable:1;
+	unsigned int orig_intx:1;
+	unsigned int restore_intx:1;
+	u32 region_mask;
+};
+
+static void pcim_release(struct device *gendev, void *res)
+{
+	struct pci_dev *dev = container_of(gendev, struct pci_dev, dev);
+	struct pci_devres *this = res;
+	int i;
+
+	if (dev->msi_enabled)
+		pci_disable_msi(dev);
+	if (dev->msix_enabled)
+		pci_disable_msix(dev);
+
+	for (i = 0; i < DEVICE_COUNT_RESOURCE; i++)
+		if (this->region_mask & (1 << i))
+			pci_release_region(dev, i);
+
+	if (this->restore_intx)
+		pci_intx(dev, this->orig_intx);
+
+	if (this->disable)
+		pci_disable_device(dev);
+}
+
+static struct pci_devres * get_pci_dr(struct pci_dev *pdev)
+{
+	struct pci_devres *dr, *new_dr;
+
+	dr = devres_find(&pdev->dev, pcim_release, NULL, NULL);
+	if (dr)
+		return dr;
+
+	new_dr = devres_alloc(pcim_release, sizeof(*new_dr), GFP_KERNEL);
+	if (!new_dr)
+		return NULL;
+	return devres_get(&pdev->dev, new_dr, NULL, NULL);
+}
+
+static struct pci_devres * find_pci_dr(struct pci_dev *pdev)
+{
+	if (pci_is_managed(pdev))
+		return devres_find(&pdev->dev, pcim_release, NULL, NULL);
+	return NULL;
+}
+
+/**
+ * pcim_enable_device - Managed pci_enable_device()
+ * @pdev: PCI device to be initialized
+ *
+ * Managed pci_enable_device().
+ */
+int pcim_enable_device(struct pci_dev *pdev)
+{
+	struct pci_devres *dr;
+	int rc;
+
+	dr = get_pci_dr(pdev);
+	if (unlikely(!dr))
+		return -ENOMEM;
+	WARN_ON(!!dr->disable);
+
+	rc = pci_enable_device(pdev);
+	if (!rc) {
+		pdev->is_managed = 1;
+		dr->disable = 1;
+	}
+	return rc;
+}
+
+/**
+ * pcim_pin_device - Pin managed PCI device
+ * @pdev: PCI device to pin
+ *
+ * Pin managed PCI device @pdev.  Pinned device won't be disabled on
+ * driver detach.  @pdev must have been enabled with
+ * pcim_enable_device().
+ */
+void pcim_pin_device(struct pci_dev *pdev)
+{
+	struct pci_devres *dr;
+
+	dr = find_pci_dr(pdev);
+	WARN_ON(!dr || !dr->disable);
+	if (dr)
+		dr->disable = 0;
+}
+
 /**
  * pcibios_disable_device - disable arch specific PCI resources for device dev
  * @dev: the PCI device to disable
@@ -767,8 +865,13 @@ void __attribute__ ((weak)) pcibios_disable_device (struct pci_dev *dev) {}
 void
 pci_disable_device(struct pci_dev *dev)
 {
+	struct pci_devres *dr;
 	u16 pci_command;
 
+	dr = find_pci_dr(dev);
+	if (dr)
+		dr->disable = 0;
+
 	if (atomic_sub_return(1, &dev->enable_cnt) != 0)
 		return;
 
@@ -867,6 +970,8 @@ pci_get_interrupt_pin(struct pci_dev *dev, struct pci_dev **bridge)
  */
 void pci_release_region(struct pci_dev *pdev, int bar)
 {
+	struct pci_devres *dr;
+
 	if (pci_resource_len(pdev, bar) == 0)
 		return;
 	if (pci_resource_flags(pdev, bar) & IORESOURCE_IO)
@@ -875,6 +980,10 @@ void pci_release_region(struct pci_dev *pdev, int bar)
 	else if (pci_resource_flags(pdev, bar) & IORESOURCE_MEM)
 		release_mem_region(pci_resource_start(pdev, bar),
 				pci_resource_len(pdev, bar));
+
+	dr = find_pci_dr(pdev);
+	if (dr)
+		dr->region_mask &= ~(1 << bar);
 }
 
 /**
@@ -893,6 +1002,8 @@ void pci_release_region(struct pci_dev *pdev, int bar)
  */
 int pci_request_region(struct pci_dev *pdev, int bar, const char *res_name)
 {
+	struct pci_devres *dr;
+
 	if (pci_resource_len(pdev, bar) == 0)
 		return 0;
 		
@@ -906,7 +1017,11 @@ int pci_request_region(struct pci_dev *pdev, int bar, const char *res_name)
 				        pci_resource_len(pdev, bar), res_name))
 			goto err_out;
 	}
-	
+
+	dr = find_pci_dr(pdev);
+	if (dr)
+		dr->region_mask |= 1 << bar;
+
 	return 0;
 
 err_out:
@@ -1144,7 +1259,15 @@ pci_intx(struct pci_dev *pdev, int enable)
 	}
 
 	if (new != pci_command) {
+		struct pci_devres *dr;
+
 		pci_write_config_word(pdev, PCI_COMMAND, new);
+
+		dr = find_pci_dr(pdev);
+		if (dr && !dr->restore_intx) {
+			dr->restore_intx = 1;
+			dr->orig_intx = !enable;
+		}
 	}
 }
 
@@ -1226,6 +1349,8 @@ device_initcall(pci_init);
 EXPORT_SYMBOL_GPL(pci_restore_bars);
 EXPORT_SYMBOL(pci_enable_device_bars);
 EXPORT_SYMBOL(pci_enable_device);
+EXPORT_SYMBOL(pcim_enable_device);
+EXPORT_SYMBOL(pcim_pin_device);
 EXPORT_SYMBOL(pci_disable_device);
 EXPORT_SYMBOL(pci_find_capability);
 EXPORT_SYMBOL(pci_bus_find_capability);

commit 8fed4b65236c44d090bd62f2d14938ae791e0260
Author: Michael Ellerman <michael@ellerman.id.au>
Date:   Thu Jan 25 19:34:08 2007 +1100

    MSI: Combine pci_(save|restore)_msi/msix_state
    
    The PCI save/restore code doesn't need to care about MSI vs MSI-X, all
    it really wants is to say "save/restore all MSI(-X) info for this device".
    
    This is borne out in the code, we call the MSI and MSI-X save routines
    side by side, and similarly with the restore routines.
    
    So combine the MSI/MSI-X routines into pci_save_msi_state() and
    pci_restore_msi_state(). It is up to those routines to decide what state
    needs to be saved.
    
    Signed-off-by: Michael Ellerman <michael@ellerman.id.au>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 7ae709024456..84c757ba0664 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -634,8 +634,6 @@ pci_save_state(struct pci_dev *dev)
 		pci_read_config_dword(dev, i * 4,&dev->saved_config_space[i]);
 	if ((i = pci_save_msi_state(dev)) != 0)
 		return i;
-	if ((i = pci_save_msix_state(dev)) != 0)
-		return i;
 	if ((i = pci_save_pcie_state(dev)) != 0)
 		return i;
 	if ((i = pci_save_pcix_state(dev)) != 0)
@@ -673,7 +671,7 @@ pci_restore_state(struct pci_dev *dev)
 	}
 	pci_restore_pcix_state(dev);
 	pci_restore_msi_state(dev);
-	pci_restore_msix_state(dev);
+
 	return 0;
 }
 

commit e36c455c2f5fee08fed395e94c7ab156cd159360
Author: Pavel Machek <pavel@ucw.cz>
Date:   Tue Jan 16 12:17:13 2007 +0100

    PCI: power management: remove noise on non-manageable hw
    
    Return early from pci_set_power_state() if hardware does not support
    power management. This way, we do not generate noise in the logs.
    
    Signed-off-by: Pavel Machek <pavel@suse.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index e91dcc05b790..7ae709024456 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -392,6 +392,14 @@ pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 	if (state > PCI_D3hot)
 		state = PCI_D3hot;
 
+	/*
+	 * If the device or the parent bridge can't support PCI PM, ignore
+	 * the request if we're doing anything besides putting it into D0
+	 * (which would only happen on boot).
+	 */
+	if ((state == PCI_D1 || state == PCI_D2) && pci_no_d1d2(dev))
+		return 0;
+
 	/* Validate current state:
 	 * Can enter D0 from any state, but if we can only go deeper 
 	 * to sleep if we're already in a low power state
@@ -403,13 +411,6 @@ pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 	} else if (dev->current_state == state)
 		return 0;        /* we're already there */
 
-	/*
-	 * If the device or the parent bridge can't support PCI PM, ignore
-	 * the request if we're doing anything besides putting it into D0
-	 * (which would only happen on boot).
-	 */
-	if ((state == PCI_D1 || state == PCI_D2) && pci_no_d1d2(dev))
-		return 0;
 
 	/* find PCI PM capability in list */
 	pm = pci_find_capability(dev, PCI_CAP_ID_PM);

commit 8255cf35d503db7c1b26ae53b6b7f23ada82316f
Author: Adrian Bunk <bunk@stusta.de>
Date:   Sat Jan 6 21:48:41 2007 +0100

    PCI: make isa_bridge Alpha-only
    
    Since isa_bridge is neither assigned any value !NULL nor used on !Alpha,
    there's no reason for providing it.
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index caeeacc7b070..e91dcc05b790 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1224,12 +1224,6 @@ early_param("pci", pci_setup);
 
 device_initcall(pci_init);
 
-#if defined(CONFIG_ISA) || defined(CONFIG_EISA)
-/* FIXME: Some boxes have multiple ISA bridges! */
-struct pci_dev *isa_bridge;
-EXPORT_SYMBOL(isa_bridge);
-#endif
-
 EXPORT_SYMBOL_GPL(pci_restore_bars);
 EXPORT_SYMBOL(pci_enable_device_bars);
 EXPORT_SYMBOL(pci_enable_device);

commit c30ca1db39cecade07143112ecfac09ec6b08e3f
Author: Adrian Bunk <bunk@stusta.de>
Date:   Tue Dec 19 05:13:15 2006 +0100

    PCI: quirks.c: cleanup
    
    This patch contains the following cleanups:
    - move all EXPORT_SYMBOL's directly below the code they are exporting
    - move all DECLARE_PCI_FIXUP_*'s directly below the functions they
      are calling
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 599978631a46..caeeacc7b070 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1257,7 +1257,3 @@ EXPORT_SYMBOL(pci_save_state);
 EXPORT_SYMBOL(pci_restore_state);
 EXPORT_SYMBOL(pci_enable_wake);
 
-/* Quirk info */
-
-EXPORT_SYMBOL(isa_dma_bridge_buggy);
-EXPORT_SYMBOL(pci_pci_problems);

commit c87deff776feacd05a7411097e8c8c57e549e638
Author: Hidetoshi Seto <seto.hidetoshi@jp.fujitsu.com>
Date:   Mon Dec 18 10:31:06 2006 +0900

    PCI : Add selected_regions funcs
    
    This patch adds the following changes into generic PCI code especially
    for PCI legacy I/O port free drivers.
    
         - Added new pci_request_selected_regions() and
           pci_release_selected_regions() for PCI legacy I/O port free
           drivers in order to request/release only the selected regions.
    
         - Added helper routine pci_select_bars() which makes proper mask
           of BARs from the specified resource type. This would be very
           helpful for users of pci_enable_device_bars().
    
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Hidetoshi Seto <seto.hidetoshi@jp.fujitsu.com>
    Cc: Inaky Perez-Gonzalez <inaky@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 287b685aaa5c..599978631a46 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -921,6 +921,47 @@ int pci_request_region(struct pci_dev *pdev, int bar, const char *res_name)
 	return -EBUSY;
 }
 
+/**
+ * pci_release_selected_regions - Release selected PCI I/O and memory resources
+ * @pdev: PCI device whose resources were previously reserved
+ * @bars: Bitmask of BARs to be released
+ *
+ * Release selected PCI I/O and memory resources previously reserved.
+ * Call this function only after all use of the PCI regions has ceased.
+ */
+void pci_release_selected_regions(struct pci_dev *pdev, int bars)
+{
+	int i;
+
+	for (i = 0; i < 6; i++)
+		if (bars & (1 << i))
+			pci_release_region(pdev, i);
+}
+
+/**
+ * pci_request_selected_regions - Reserve selected PCI I/O and memory resources
+ * @pdev: PCI device whose resources are to be reserved
+ * @bars: Bitmask of BARs to be requested
+ * @res_name: Name to be associated with resource
+ */
+int pci_request_selected_regions(struct pci_dev *pdev, int bars,
+				 const char *res_name)
+{
+	int i;
+
+	for (i = 0; i < 6; i++)
+		if (bars & (1 << i))
+			if(pci_request_region(pdev, i, res_name))
+				goto err_out;
+	return 0;
+
+err_out:
+	while(--i >= 0)
+		if (bars & (1 << i))
+			pci_release_region(pdev, i);
+
+	return -EBUSY;
+}
 
 /**
  *	pci_release_regions - Release reserved PCI I/O and memory resources
@@ -933,10 +974,7 @@ int pci_request_region(struct pci_dev *pdev, int bar, const char *res_name)
 
 void pci_release_regions(struct pci_dev *pdev)
 {
-	int i;
-	
-	for (i = 0; i < 6; i++)
-		pci_release_region(pdev, i);
+	pci_release_selected_regions(pdev, (1 << 6) - 1);
 }
 
 /**
@@ -954,18 +992,7 @@ void pci_release_regions(struct pci_dev *pdev)
  */
 int pci_request_regions(struct pci_dev *pdev, const char *res_name)
 {
-	int i;
-	
-	for (i = 0; i < 6; i++)
-		if(pci_request_region(pdev, i, res_name))
-			goto err_out;
-	return 0;
-
-err_out:
-	while(--i >= 0)
-		pci_release_region(pdev, i);
-		
-	return -EBUSY;
+	return pci_request_selected_regions(pdev, ((1 << 6) - 1), res_name);
 }
 
 /**
@@ -1148,7 +1175,23 @@ pci_set_consistent_dma_mask(struct pci_dev *dev, u64 mask)
 	return 0;
 }
 #endif
-     
+
+/**
+ * pci_select_bars - Make BAR mask from the type of resource
+ * @pdev: the PCI device for which BAR mask is made
+ * @flags: resource type mask to be selected
+ *
+ * This helper routine makes bar mask from the type of resource.
+ */
+int pci_select_bars(struct pci_dev *dev, unsigned long flags)
+{
+	int i, bars = 0;
+	for (i = 0; i < PCI_NUM_RESOURCES; i++)
+		if (pci_resource_flags(dev, i) & flags)
+			bars |= (1 << i);
+	return bars;
+}
+
 static int __devinit pci_init(void)
 {
 	struct pci_dev *dev = NULL;
@@ -1197,6 +1240,8 @@ EXPORT_SYMBOL(pci_release_regions);
 EXPORT_SYMBOL(pci_request_regions);
 EXPORT_SYMBOL(pci_release_region);
 EXPORT_SYMBOL(pci_request_region);
+EXPORT_SYMBOL(pci_release_selected_regions);
+EXPORT_SYMBOL(pci_request_selected_regions);
 EXPORT_SYMBOL(pci_set_master);
 EXPORT_SYMBOL(pci_set_mwi);
 EXPORT_SYMBOL(pci_clear_mwi);
@@ -1205,6 +1250,7 @@ EXPORT_SYMBOL(pci_set_dma_mask);
 EXPORT_SYMBOL(pci_set_consistent_dma_mask);
 EXPORT_SYMBOL(pci_assign_resource);
 EXPORT_SYMBOL(pci_find_parent_resource);
+EXPORT_SYMBOL(pci_select_bars);
 
 EXPORT_SYMBOL(pci_set_power_state);
 EXPORT_SYMBOL(pci_save_state);

commit 38cc13022ed3cea949722d5a6f49025da82c9fd0
Author: Hidetoshi Seto <seto.hidetoshi@jp.fujitsu.com>
Date:   Mon Dec 18 10:30:00 2006 +0900

    PCI : add extremely specialized __pci_reenable_device for default resume
    
    Original patch was posted as "PCI : Move pci_fixup_device and is_enabled".
    This 3 of 3 patches does:
    
      - add __pci_reenable_device
        (recover former change of 1st patch)
    
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Hidetoshi Seto <seto.hidetoshi@jp.fujitsu.com>
    Cc: Inaky Perez-Gonzalez <inaky@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 212acd2e1a84..287b685aaa5c 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -676,6 +676,36 @@ pci_restore_state(struct pci_dev *dev)
 	return 0;
 }
 
+static int do_pci_enable_device(struct pci_dev *dev, int bars)
+{
+	int err;
+
+	err = pci_set_power_state(dev, PCI_D0);
+	if (err < 0 && err != -EIO)
+		return err;
+	err = pcibios_enable_device(dev, bars);
+	if (err < 0)
+		return err;
+	pci_fixup_device(pci_fixup_enable, dev);
+
+	return 0;
+}
+
+/**
+ * __pci_reenable_device - Resume abandoned device
+ * @dev: PCI device to be resumed
+ *
+ *  Note this function is a backend of pci_default_resume and is not supposed
+ *  to be called by normal code, write proper resume handler and use it instead.
+ */
+int
+__pci_reenable_device(struct pci_dev *dev)
+{
+	if (atomic_read(&dev->enable_cnt))
+		return do_pci_enable_device(dev, (1 << PCI_NUM_RESOURCES) - 1);
+	return 0;
+}
+
 /**
  * pci_enable_device_bars - Initialize some of a device for use
  * @dev: PCI device to be initialized
@@ -693,16 +723,9 @@ pci_enable_device_bars(struct pci_dev *dev, int bars)
 	if (atomic_add_return(1, &dev->enable_cnt) > 1)
 		return 0;		/* already enabled */
 
-	err = pci_set_power_state(dev, PCI_D0);
-	if (err < 0 && err != -EIO)
-		goto err_out;
-	err = pcibios_enable_device(dev, bars);
+	err = do_pci_enable_device(dev, bars);
 	if (err < 0)
-		goto err_out;
-	pci_fixup_device(pci_fixup_enable, dev);
-
-err_out:
-	atomic_dec(&dev->enable_cnt);
+		atomic_dec(&dev->enable_cnt);
 	return err;
 }
 

commit 9fb625c3cc3731097a142ecae79a0369fb854c2d
Author: Hidetoshi Seto <seto.hidetoshi@jp.fujitsu.com>
Date:   Mon Dec 18 10:28:43 2006 +0900

    PCI : Move pci_fixup_device and is_enabled (originally intended change)
    
    Original patch was posted as "PCI : Move pci_fixup_device and is_enabled".
    This 2 of 3 patches does:
    
      - Move pci_fixup_device and enable_cnt
        (originally intended change)
    
      - relocate pci_fixup_device
        (recover latter change of 1st patch)
    
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Hidetoshi Seto <seto.hidetoshi@jp.fujitsu.com>
    Cc: Inaky Perez-Gonzalez <inaky@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index d20d3983bbd6..212acd2e1a84 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -682,22 +682,28 @@ pci_restore_state(struct pci_dev *dev)
  * @bars: bitmask of BAR's that must be configured
  *
  *  Initialize device before it's used by a driver. Ask low-level code
- *  to enable selected I/O and memory resources. Wake up the device if it 
+ *  to enable selected I/O and memory resources. Wake up the device if it
  *  was suspended. Beware, this function can fail.
  */
- 
 int
 pci_enable_device_bars(struct pci_dev *dev, int bars)
 {
 	int err;
 
+	if (atomic_add_return(1, &dev->enable_cnt) > 1)
+		return 0;		/* already enabled */
+
 	err = pci_set_power_state(dev, PCI_D0);
 	if (err < 0 && err != -EIO)
-		return err;
+		goto err_out;
 	err = pcibios_enable_device(dev, bars);
 	if (err < 0)
-		return err;
-	return 0;
+		goto err_out;
+	pci_fixup_device(pci_fixup_enable, dev);
+
+err_out:
+	atomic_dec(&dev->enable_cnt);
+	return err;
 }
 
 /**
@@ -713,13 +719,7 @@ pci_enable_device_bars(struct pci_dev *dev, int bars)
  */
 int pci_enable_device(struct pci_dev *dev)
 {
-	int result;
-	if (atomic_add_return(1, &dev->enable_cnt) > 1)
-		return 0;		/* already enabled */
-	result = __pci_enable_device(dev);
-	if (result < 0)
-		atomic_dec(&dev->enable_cnt);
-	return result;
+	return pci_enable_device_bars(dev, (1 << PCI_NUM_RESOURCES) - 1);
 }
 
 /**

commit 924b08f3ff12eb0e8ecd9e9a9b6a5b884a495c23
Author: Hidetoshi Seto <seto.hidetoshi@jp.fujitsu.com>
Date:   Mon Dec 18 10:27:45 2006 +0900

    PCI : remove too specialized __pci_enable_device for default resume
    
    Original patch was posted as "PCI : Move pci_fixup_device and is_enabled".
    This 1 of 3 patches does:
    
      - reverts small part of Inaky's patch
        (remove __pci_enable_device)
        This change will be recovered by 3rd patch.
    
      - temporarily remove pci_fixup_device.
        This change will be recovered by 2nd patch.
    
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Hidetoshi Seto <seto.hidetoshi@jp.fujitsu.com>
    Cc: Inaky Perez-Gonzalez <inaky@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 206c834d263a..d20d3983bbd6 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -700,29 +700,6 @@ pci_enable_device_bars(struct pci_dev *dev, int bars)
 	return 0;
 }
 
-/**
- * __pci_enable_device - Initialize device before it's used by a driver.
- * @dev: PCI device to be initialized
- *
- *  Initialize device before it's used by a driver. Ask low-level code
- *  to enable I/O and memory. Wake up the device if it was suspended.
- *  Beware, this function can fail.
- *
- * Note this function is a backend and is not supposed to be called by
- * normal code, use pci_enable_device() instead.
- */
-int
-__pci_enable_device(struct pci_dev *dev)
-{
-	int err;
-
-	err = pci_enable_device_bars(dev, (1 << PCI_NUM_RESOURCES) - 1);
-	if (err)
-		return err;
-	pci_fixup_device(pci_fixup_enable, dev);
-	return 0;
-}
-
 /**
  * pci_enable_device - Initialize device before it's used by a driver.
  * @dev: PCI device to be initialized

commit 47a4d5be7c50b2e9b905abbe2b97dc87051c5a44
Author: Brice Goglin <brice@myri.com>
Date:   Wed Jan 10 23:15:29 2007 -0800

    [PATCH] increment pos before looking for the next cap in __pci_find_next_ht_cap
    
    While testing 2.6.20-rc3 on a machine with some CK804 chipsets, we noticed
    that quirk_nvidia_ck804_msi_ht_cap() was not detecting HT MSI capabilities
    anymore.  It is actually caused by the MSI mapping on the root chipset
    being the 2nd HT capability in the chain.  pci_find_ht_capability() does
    not seem to find anything but the first HT cap correctly, because it
    forgets to increment the position before looking for the next cap.  The
    following patch seems to fix it.
    
    At least, this proves that having a ttl is good idea since the machine
    would have been stucked in an infinite loop if we didn't have a ttl :)
    
    We have to pass pos + PCI_CAP_LIST_NEXT to __pci_find_next_cap_ttl to
    get the next HT cap instead of the same one again.
    
    Signed-off-by: Brice Goglin <brice@myri.com>
    Signed-off-by: Andrew J. Gallatin <gallatin@myri.com>
    Cc: Greg KH <greg@kroah.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 6bfb942428e4..206c834d263a 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -254,7 +254,8 @@ static int __pci_find_next_ht_cap(struct pci_dev *dev, int pos, int ht_cap)
 		if ((cap & mask) == ht_cap)
 			return pos;
 
-		pos = __pci_find_next_cap_ttl(dev->bus, dev->devfn, pos,
+		pos = __pci_find_next_cap_ttl(dev->bus, dev->devfn,
+					      pos + PCI_CAP_LIST_NEXT,
 					      PCI_CAP_ID_HT, &ttl);
 	}
 

commit 687d5fe3dc33794efb500f42164a0588e2647914
Author: Michael Ellerman <michael@ellerman.id.au>
Date:   Wed Nov 22 18:26:18 2006 +1100

    PCI: Add pci_find_ht_capability() for finding Hypertransport capabilities
    
    There are already several places in the kernel that want to search a PCI
    device for a given Hypertransport capability. Although this is possible
    using pci_find_capability() etc., it makes sense to encapsulate that
    logic in a helper - pci_find_ht_capability().
    
    To cater for searching exhaustively for a capability, we also provide
    pci_find_next_ht_capability().
    
    We also need to cater for the fact that the HT capability fields may be
    either 3 or 5 bits wide. pci_find_ht_capability() deals with this for you,
    but callers using the #defines directly must handle that themselves.
    
    Signed-off-by: Michael Ellerman <michael@ellerman.id.au>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 4627a51d1d6c..6bfb942428e4 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -68,12 +68,14 @@ pci_max_busnr(void)
 
 #endif  /*  0  */
 
-static int __pci_find_next_cap(struct pci_bus *bus, unsigned int devfn, u8 pos, int cap)
+#define PCI_FIND_CAP_TTL	48
+
+static int __pci_find_next_cap_ttl(struct pci_bus *bus, unsigned int devfn,
+				   u8 pos, int cap, int *ttl)
 {
 	u8 id;
-	int ttl = 48;
 
-	while (ttl--) {
+	while ((*ttl)--) {
 		pci_bus_read_config_byte(bus, devfn, pos, &pos);
 		if (pos < 0x40)
 			break;
@@ -89,6 +91,14 @@ static int __pci_find_next_cap(struct pci_bus *bus, unsigned int devfn, u8 pos,
 	return 0;
 }
 
+static int __pci_find_next_cap(struct pci_bus *bus, unsigned int devfn,
+			       u8 pos, int cap)
+{
+	int ttl = PCI_FIND_CAP_TTL;
+
+	return __pci_find_next_cap_ttl(bus, devfn, pos, cap, &ttl);
+}
+
 int pci_find_next_capability(struct pci_dev *dev, u8 pos, int cap)
 {
 	return __pci_find_next_cap(dev->bus, dev->devfn,
@@ -224,6 +234,74 @@ int pci_find_ext_capability(struct pci_dev *dev, int cap)
 }
 EXPORT_SYMBOL_GPL(pci_find_ext_capability);
 
+static int __pci_find_next_ht_cap(struct pci_dev *dev, int pos, int ht_cap)
+{
+	int rc, ttl = PCI_FIND_CAP_TTL;
+	u8 cap, mask;
+
+	if (ht_cap == HT_CAPTYPE_SLAVE || ht_cap == HT_CAPTYPE_HOST)
+		mask = HT_3BIT_CAP_MASK;
+	else
+		mask = HT_5BIT_CAP_MASK;
+
+	pos = __pci_find_next_cap_ttl(dev->bus, dev->devfn, pos,
+				      PCI_CAP_ID_HT, &ttl);
+	while (pos) {
+		rc = pci_read_config_byte(dev, pos + 3, &cap);
+		if (rc != PCIBIOS_SUCCESSFUL)
+			return 0;
+
+		if ((cap & mask) == ht_cap)
+			return pos;
+
+		pos = __pci_find_next_cap_ttl(dev->bus, dev->devfn, pos,
+					      PCI_CAP_ID_HT, &ttl);
+	}
+
+	return 0;
+}
+/**
+ * pci_find_next_ht_capability - query a device's Hypertransport capabilities
+ * @dev: PCI device to query
+ * @pos: Position from which to continue searching
+ * @ht_cap: Hypertransport capability code
+ *
+ * To be used in conjunction with pci_find_ht_capability() to search for
+ * all capabilities matching @ht_cap. @pos should always be a value returned
+ * from pci_find_ht_capability().
+ *
+ * NB. To be 100% safe against broken PCI devices, the caller should take
+ * steps to avoid an infinite loop.
+ */
+int pci_find_next_ht_capability(struct pci_dev *dev, int pos, int ht_cap)
+{
+	return __pci_find_next_ht_cap(dev, pos + PCI_CAP_LIST_NEXT, ht_cap);
+}
+EXPORT_SYMBOL_GPL(pci_find_next_ht_capability);
+
+/**
+ * pci_find_ht_capability - query a device's Hypertransport capabilities
+ * @dev: PCI device to query
+ * @ht_cap: Hypertransport capability code
+ *
+ * Tell if a device supports a given Hypertransport capability.
+ * Returns an address within the device's PCI configuration space
+ * or 0 in case the device does not support the request capability.
+ * The address points to the PCI capability, of type PCI_CAP_ID_HT,
+ * which has a Hypertransport capability matching @ht_cap.
+ */
+int pci_find_ht_capability(struct pci_dev *dev, int ht_cap)
+{
+	int pos;
+
+	pos = __pci_bus_find_cap_start(dev->bus, dev->devfn, dev->hdr_type);
+	if (pos)
+		pos = __pci_find_next_ht_cap(dev, pos, ht_cap);
+
+	return pos;
+}
+EXPORT_SYMBOL_GPL(pci_find_ht_capability);
+
 /**
  * pci_find_parent_resource - return resource region of parent bus of given region
  * @dev: PCI device structure contains resources to be searched

commit d3bac118fb27a365d5e9f54f4a078eb9b42f968f
Author: Michael Ellerman <michael@ellerman.id.au>
Date:   Wed Nov 22 18:26:16 2006 +1100

    PCI: Create __pci_bus_find_cap_start() from __pci_bus_find_cap()
    
    The current implementation of __pci_bus_find_cap() does two things,
    first it determines the start of the capability chain for the device,
    and then it trys to find the requested capability.
    
    Split these out, so that we can use the two parts independantly in
    a subsequent patch. Externally visible behaviour should be unchanged.
    
    Signed-off-by: Michael Ellerman <michael@ellerman.id.au>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 5a14b73cf3a1..4627a51d1d6c 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -96,10 +96,10 @@ int pci_find_next_capability(struct pci_dev *dev, u8 pos, int cap)
 }
 EXPORT_SYMBOL_GPL(pci_find_next_capability);
 
-static int __pci_bus_find_cap(struct pci_bus *bus, unsigned int devfn, u8 hdr_type, int cap)
+static int __pci_bus_find_cap_start(struct pci_bus *bus,
+				    unsigned int devfn, u8 hdr_type)
 {
 	u16 status;
-	u8 pos;
 
 	pci_bus_read_config_word(bus, devfn, PCI_STATUS, &status);
 	if (!(status & PCI_STATUS_CAP_LIST))
@@ -108,15 +108,14 @@ static int __pci_bus_find_cap(struct pci_bus *bus, unsigned int devfn, u8 hdr_ty
 	switch (hdr_type) {
 	case PCI_HEADER_TYPE_NORMAL:
 	case PCI_HEADER_TYPE_BRIDGE:
-		pos = PCI_CAPABILITY_LIST;
-		break;
+		return PCI_CAPABILITY_LIST;
 	case PCI_HEADER_TYPE_CARDBUS:
-		pos = PCI_CB_CAPABILITY_LIST;
-		break;
+		return PCI_CB_CAPABILITY_LIST;
 	default:
 		return 0;
 	}
-	return __pci_find_next_cap(bus, devfn, pos, cap);
+
+	return 0;
 }
 
 /**
@@ -140,7 +139,13 @@ static int __pci_bus_find_cap(struct pci_bus *bus, unsigned int devfn, u8 hdr_ty
  */
 int pci_find_capability(struct pci_dev *dev, int cap)
 {
-	return __pci_bus_find_cap(dev->bus, dev->devfn, dev->hdr_type, cap);
+	int pos;
+
+	pos = __pci_bus_find_cap_start(dev->bus, dev->devfn, dev->hdr_type);
+	if (pos)
+		pos = __pci_find_next_cap(dev->bus, dev->devfn, pos, cap);
+
+	return pos;
 }
 
 /**
@@ -158,11 +163,16 @@ int pci_find_capability(struct pci_dev *dev, int cap)
  */
 int pci_bus_find_capability(struct pci_bus *bus, unsigned int devfn, int cap)
 {
+	int pos;
 	u8 hdr_type;
 
 	pci_bus_read_config_byte(bus, devfn, PCI_HEADER_TYPE, &hdr_type);
 
-	return __pci_bus_find_cap(bus, devfn, hdr_type & 0x7f, cap);
+	pos = __pci_bus_find_cap_start(bus, devfn, hdr_type & 0x7f);
+	if (pos)
+		pos = __pci_find_next_cap(bus, devfn, pos, cap);
+
+	return pos;
 }
 
 /**

commit bae94d02371c402408a4edfb95e71e88dbd3e973
Author: Inaky Perez-Gonzalez <inaky@linux.intel.com>
Date:   Wed Nov 22 12:40:31 2006 -0800

    PCI: switch pci_{enable,disable}_device() to be nestable
    
    Changes the pci_{enable,disable}_device() functions to work in a
    nested basis, so that eg, three calls to enable_device() require three
    calls to disable_device().
    
    The reason for this is to simplify PCI drivers for
    multi-interface/capability devices. These are devices that cram more
    than one interface in a single function. A relevant example of that is
    the Wireless [USB] Host Controller Interface (similar to EHCI) [see
    http://www.intel.com/technology/comms/wusb/whci.htm].
    
    In these kind of devices, multiple interfaces are accessed through a
    single bar and IRQ line. For that, the drivers map only the smallest
    area of the bar to access their register banks and use shared IRQ
    handlers.
    
    However, because the order at which those drivers load cannot be known
    ahead of time, the sequence in which the calls to pci_enable_device()
    and pci_disable_device() cannot be predicted. Thus:
    
    1. driverA     starts     pci_enable_device()
    2. driverB     starts     pci_enable_device()
    3. driverA     shutdown   pci_disable_device()
    4. driverB     shutdown   pci_disable_device()
    
    between steps 3 and 4, driver B would loose access to it's device,
    even if it didn't intend to.
    
    By using this modification, the device won't be disabled until all the
    callers to enable() have called disable().
    
    This is implemented by replacing 'struct pci_dev->is_enabled' from a
    bitfield to an atomic use count. Each caller to enable increments it,
    each caller to disable decrements it. When the count increments from 0
    to 1, __pci_enable_device() is called to actually enable the
    device. When it drops to zero, pci_disable_device() actually does the
    disabling.
    
    We keep the backend __pci_enable_device() for pci_default_resume() to
    use and also change the sysfs method implementation, so that userspace
    enabling/disabling the device doesn't disable it one time too much.
    
    Signed-off-by: Inaky Perez-Gonzalez <inaky@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 427991741cf3..5a14b73cf3a1 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -612,29 +612,50 @@ pci_enable_device_bars(struct pci_dev *dev, int bars)
 }
 
 /**
- * pci_enable_device - Initialize device before it's used by a driver.
+ * __pci_enable_device - Initialize device before it's used by a driver.
  * @dev: PCI device to be initialized
  *
  *  Initialize device before it's used by a driver. Ask low-level code
  *  to enable I/O and memory. Wake up the device if it was suspended.
  *  Beware, this function can fail.
+ *
+ * Note this function is a backend and is not supposed to be called by
+ * normal code, use pci_enable_device() instead.
  */
 int
-pci_enable_device(struct pci_dev *dev)
+__pci_enable_device(struct pci_dev *dev)
 {
 	int err;
 
-	if (dev->is_enabled)
-		return 0;
-
 	err = pci_enable_device_bars(dev, (1 << PCI_NUM_RESOURCES) - 1);
 	if (err)
 		return err;
 	pci_fixup_device(pci_fixup_enable, dev);
-	dev->is_enabled = 1;
 	return 0;
 }
 
+/**
+ * pci_enable_device - Initialize device before it's used by a driver.
+ * @dev: PCI device to be initialized
+ *
+ *  Initialize device before it's used by a driver. Ask low-level code
+ *  to enable I/O and memory. Wake up the device if it was suspended.
+ *  Beware, this function can fail.
+ *
+ *  Note we don't actually enable the device many times if we call
+ *  this function repeatedly (we just increment the count).
+ */
+int pci_enable_device(struct pci_dev *dev)
+{
+	int result;
+	if (atomic_add_return(1, &dev->enable_cnt) > 1)
+		return 0;		/* already enabled */
+	result = __pci_enable_device(dev);
+	if (result < 0)
+		atomic_dec(&dev->enable_cnt);
+	return result;
+}
+
 /**
  * pcibios_disable_device - disable arch specific PCI resources for device dev
  * @dev: the PCI device to disable
@@ -651,12 +672,18 @@ void __attribute__ ((weak)) pcibios_disable_device (struct pci_dev *dev) {}
  *
  * Signal to the system that the PCI device is not in use by the system
  * anymore.  This only involves disabling PCI bus-mastering, if active.
+ *
+ * Note we don't actually disable the device until all callers of
+ * pci_device_enable() have called pci_device_disable().
  */
 void
 pci_disable_device(struct pci_dev *dev)
 {
 	u16 pci_command;
 
+	if (atomic_sub_return(1, &dev->enable_cnt) != 0)
+		return;
+
 	if (dev->msi_enabled)
 		disable_msi_mode(dev, pci_find_capability(dev, PCI_CAP_ID_MSI),
 			PCI_CAP_ID_MSI);
@@ -672,7 +699,6 @@ pci_disable_device(struct pci_dev *dev)
 	dev->is_busmaster = 0;
 
 	pcibios_disable_device(dev);
-	dev->is_enabled = 0;
 }
 
 /**

commit edb2d97eb57b7a21c9256260562de6a65dda86cc
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Tue Oct 10 08:01:21 2006 -0600

    PCI: Replace HAVE_ARCH_PCI_MWI with PCI_DISABLE_MWI
    
    pSeries is the only architecture left using HAVE_ARCH_PCI_MWI and it's
    really inappropriate for its needs.  It really wants to disable MWI
    altogether.  So here are a pair of stub implementations for pci_set_mwi
    and pci_clear_mwi.
    
    Also rename pci_generic_prep_mwi to pci_set_cacheline_size since that
    better reflects what it does.
    
    Signed-off-by: Matthew Wilcox <matthew@wil.cx>
    Cc: Paul Mackerras <paulus@samba.org>
    Acked-by: Jeff Garzik <jeff@garzik.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index bc88c30a418b..427991741cf3 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -875,7 +875,17 @@ pci_set_master(struct pci_dev *dev)
 	pcibios_set_master(dev);
 }
 
-#ifndef HAVE_ARCH_PCI_MWI
+#ifdef PCI_DISABLE_MWI
+int pci_set_mwi(struct pci_dev *dev)
+{
+	return 0;
+}
+
+void pci_clear_mwi(struct pci_dev *dev)
+{
+}
+
+#else
 
 #ifndef PCI_CACHE_LINE_BYTES
 #define PCI_CACHE_LINE_BYTES L1_CACHE_BYTES
@@ -886,17 +896,17 @@ pci_set_master(struct pci_dev *dev)
 u8 pci_cache_line_size = PCI_CACHE_LINE_BYTES / 4;
 
 /**
- * pci_generic_prep_mwi - helper function for pci_set_mwi
- * @dev: the PCI device for which MWI is enabled
+ * pci_set_cacheline_size - ensure the CACHE_LINE_SIZE register is programmed
+ * @dev: the PCI device for which MWI is to be enabled
  *
- * Helper function for generic implementation of pcibios_prep_mwi
- * function.  Originally copied from drivers/net/acenic.c.
+ * Helper function for pci_set_mwi.
+ * Originally copied from drivers/net/acenic.c.
  * Copyright 1998-2001 by Jes Sorensen, <jes@trained-monkey.org>.
  *
  * RETURNS: An appropriate -ERRNO error value on error, or zero for success.
  */
 static int
-pci_generic_prep_mwi(struct pci_dev *dev)
+pci_set_cacheline_size(struct pci_dev *dev)
 {
 	u8 cacheline_size;
 
@@ -922,7 +932,6 @@ pci_generic_prep_mwi(struct pci_dev *dev)
 
 	return -EINVAL;
 }
-#endif /* !HAVE_ARCH_PCI_MWI */
 
 /**
  * pci_set_mwi - enables memory-write-invalidate PCI transaction
@@ -940,12 +949,7 @@ pci_set_mwi(struct pci_dev *dev)
 	int rc;
 	u16 cmd;
 
-#ifdef HAVE_ARCH_PCI_MWI
-	rc = pcibios_prep_mwi(dev);
-#else
-	rc = pci_generic_prep_mwi(dev);
-#endif
-
+	rc = pci_set_cacheline_size(dev);
 	if (rc)
 		return rc;
 
@@ -976,6 +980,7 @@ pci_clear_mwi(struct pci_dev *dev)
 		pci_write_config_word(dev, PCI_COMMAND, cmd);
 	}
 }
+#endif /* ! PCI_DISABLE_MWI */
 
 /**
  * pci_intx - enables/disables PCI INTx for device dev

commit ebf5a24829def5d066922ceebde61dd57fdc6b1e
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Tue Oct 10 08:01:20 2006 -0600

    PCI: Use pci_generic_prep_mwi on sparc64
    
    The setting of the CACHE_LINE_SIZE register in sparc64's pci
    initialisation code isn't quite adequate as the device may have
    incompatible requirements.  The generic code tests for this, so switch
    sparc64 over to using it.
    
    Since sparc64 has different L1 cache line size and PCI cache line size,
    it would need to override the generic code like i386 and ia64 do.  We
    know what the cache line size is at compile time though, so introduce a
    new optional constant PCI_CACHE_LINE_BYTES.
    
    Signed-off-by: Matthew Wilcox <matthew@wil.cx>
    Signed-off-by: David Miller <davem@davemloft.net>
    Acked-by: Jeff Garzik <jeff@garzik.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 0eaf381ae93e..bc88c30a418b 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -876,8 +876,14 @@ pci_set_master(struct pci_dev *dev)
 }
 
 #ifndef HAVE_ARCH_PCI_MWI
+
+#ifndef PCI_CACHE_LINE_BYTES
+#define PCI_CACHE_LINE_BYTES L1_CACHE_BYTES
+#endif
+
 /* This can be overridden by arch code. */
-u8 pci_cache_line_size = L1_CACHE_BYTES >> 2;
+/* Don't forget this is measured in 32-bit words, not bytes */
+u8 pci_cache_line_size = PCI_CACHE_LINE_BYTES / 4;
 
 /**
  * pci_generic_prep_mwi - helper function for pci_set_mwi

commit cc692a5f1e9816671b77da77c6d6c463156ba1c7
Author: Stephen Hemminger <shemminger@osdl.org>
Date:   Wed Nov 8 16:17:15 2006 -0800

    PCI: save/restore PCI-X state
    
    Shouldn't PCI-X state be saved/restored?  No device really needs this
    right now. qla24xx (fc HBA) and mthca (infiniband) don't do suspend,
    and sky2 resets its tweaks when links are brought up.
    
    Signed-off-by: Stephen Hemminger <shemminger@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index a544997399b3..0eaf381ae93e 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -490,6 +490,47 @@ static void pci_restore_pcie_state(struct pci_dev *dev)
 	kfree(save_state);
 }
 
+
+static int pci_save_pcix_state(struct pci_dev *dev)
+{
+	int pos, i = 0;
+	struct pci_cap_saved_state *save_state;
+	u16 *cap;
+
+	pos = pci_find_capability(dev, PCI_CAP_ID_PCIX);
+	if (pos <= 0)
+		return 0;
+
+	save_state = kzalloc(sizeof(*save_state) + sizeof(u16), GFP_KERNEL);
+	if (!save_state) {
+		dev_err(&dev->dev, "Out of memory in pci_save_pcie_state\n");
+		return -ENOMEM;
+	}
+	cap = (u16 *)&save_state->data[0];
+
+	pci_read_config_word(dev, pos + PCI_X_CMD, &cap[i++]);
+	pci_add_saved_cap(dev, save_state);
+	return 0;
+}
+
+static void pci_restore_pcix_state(struct pci_dev *dev)
+{
+	int i = 0, pos;
+	struct pci_cap_saved_state *save_state;
+	u16 *cap;
+
+	save_state = pci_find_saved_cap(dev, PCI_CAP_ID_PCIX);
+	pos = pci_find_capability(dev, PCI_CAP_ID_PCIX);
+	if (!save_state || pos <= 0)
+		return;
+	cap = (u16 *)&save_state->data[0];
+
+	pci_write_config_word(dev, pos + PCI_X_CMD, cap[i++]);
+	pci_remove_saved_cap(save_state);
+	kfree(save_state);
+}
+
+
 /**
  * pci_save_state - save the PCI configuration space of a device before suspending
  * @dev: - PCI device that we're dealing with
@@ -507,6 +548,8 @@ pci_save_state(struct pci_dev *dev)
 		return i;
 	if ((i = pci_save_pcie_state(dev)) != 0)
 		return i;
+	if ((i = pci_save_pcix_state(dev)) != 0)
+		return i;
 	return 0;
 }
 
@@ -538,6 +581,7 @@ pci_restore_state(struct pci_dev *dev)
 				dev->saved_config_space[i]);
 		}
 	}
+	pci_restore_pcix_state(dev);
 	pci_restore_msi_state(dev);
 	pci_restore_msix_state(dev);
 	return 0;

commit b56a5a23bfecd9cac9187164a9d5f22d287c48b9
Author: Michael S. Tsirkin <mst@mellanox.co.il>
Date:   Mon Aug 21 16:22:22 2006 +0300

    PCI: Restore PCI Express capability registers after PM event
    
    Restore PCI Express capability registers after PM event.
    This includes maxumum MTU for PCI express and other vital data.
    
    Signed-off-by: Michael S. Tsirkin <mst@mellanox.co.il>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 590f4e6f505d..a544997399b3 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -445,6 +445,51 @@ pci_power_t pci_choose_state(struct pci_dev *dev, pm_message_t state)
 
 EXPORT_SYMBOL(pci_choose_state);
 
+static int pci_save_pcie_state(struct pci_dev *dev)
+{
+	int pos, i = 0;
+	struct pci_cap_saved_state *save_state;
+	u16 *cap;
+
+	pos = pci_find_capability(dev, PCI_CAP_ID_EXP);
+	if (pos <= 0)
+		return 0;
+
+	save_state = kzalloc(sizeof(*save_state) + sizeof(u16) * 4, GFP_KERNEL);
+	if (!save_state) {
+		dev_err(&dev->dev, "Out of memory in pci_save_pcie_state\n");
+		return -ENOMEM;
+	}
+	cap = (u16 *)&save_state->data[0];
+
+	pci_read_config_word(dev, pos + PCI_EXP_DEVCTL, &cap[i++]);
+	pci_read_config_word(dev, pos + PCI_EXP_LNKCTL, &cap[i++]);
+	pci_read_config_word(dev, pos + PCI_EXP_SLTCTL, &cap[i++]);
+	pci_read_config_word(dev, pos + PCI_EXP_RTCTL, &cap[i++]);
+	pci_add_saved_cap(dev, save_state);
+	return 0;
+}
+
+static void pci_restore_pcie_state(struct pci_dev *dev)
+{
+	int i = 0, pos;
+	struct pci_cap_saved_state *save_state;
+	u16 *cap;
+
+	save_state = pci_find_saved_cap(dev, PCI_CAP_ID_EXP);
+	pos = pci_find_capability(dev, PCI_CAP_ID_EXP);
+	if (!save_state || pos <= 0)
+		return;
+	cap = (u16 *)&save_state->data[0];
+
+	pci_write_config_word(dev, pos + PCI_EXP_DEVCTL, cap[i++]);
+	pci_write_config_word(dev, pos + PCI_EXP_LNKCTL, cap[i++]);
+	pci_write_config_word(dev, pos + PCI_EXP_SLTCTL, cap[i++]);
+	pci_write_config_word(dev, pos + PCI_EXP_RTCTL, cap[i++]);
+	pci_remove_saved_cap(save_state);
+	kfree(save_state);
+}
+
 /**
  * pci_save_state - save the PCI configuration space of a device before suspending
  * @dev: - PCI device that we're dealing with
@@ -460,6 +505,8 @@ pci_save_state(struct pci_dev *dev)
 		return i;
 	if ((i = pci_save_msix_state(dev)) != 0)
 		return i;
+	if ((i = pci_save_pcie_state(dev)) != 0)
+		return i;
 	return 0;
 }
 
@@ -473,6 +520,9 @@ pci_restore_state(struct pci_dev *dev)
 	int i;
 	int val;
 
+	/* PCI Express register must be restored first */
+	pci_restore_pcie_state(dev);
+
 	/*
 	 * The Base Address register should be programmed before the command
 	 * register(s)

commit b278240839e20fa9384ea430df463b367b90e04e
Merge: dd77a4ee0f39 3f75f42d7733
Author: Linus Torvalds <torvalds@g5.osdl.org>
Date:   Tue Sep 26 13:07:55 2006 -0700

    Merge branch 'for-linus' of git://one.firstfloor.org/home/andi/git/linux-2.6
    
    * 'for-linus' of git://one.firstfloor.org/home/andi/git/linux-2.6: (225 commits)
      [PATCH] Don't set calgary iommu as default y
      [PATCH] i386/x86-64: New Intel feature flags
      [PATCH] x86: Add a cumulative thermal throttle event counter.
      [PATCH] i386: Make the jiffies compares use the 64bit safe macros.
      [PATCH] x86: Refactor thermal throttle processing
      [PATCH] Add 64bit jiffies compares (for use with get_jiffies_64)
      [PATCH] Fix unwinder warning in traps.c
      [PATCH] x86: Allow disabling early pci scans with pci=noearly or disallowing conf1
      [PATCH] x86: Move direct PCI scanning functions out of line
      [PATCH] i386/x86-64: Make all early PCI scans dependent on CONFIG_PCI
      [PATCH] Don't leak NT bit into next task
      [PATCH] i386/x86-64: Work around gcc bug with noreturn functions in unwinder
      [PATCH] Fix some broken white space in ia32_signal.c
      [PATCH] Initialize argument registers for 32bit signal handlers.
      [PATCH] Remove all traces of signal number conversion
      [PATCH] Don't synchronize time reading on single core AMD systems
      [PATCH] Remove outdated comment in x86-64 mmconfig code
      [PATCH] Use string instructions for Core2 copy/clear
      [PATCH] x86: - restore i8259A eoi status on resume
      [PATCH] i386: Split multi-line printk in oops output.
      ...

commit 0637a70a5db98182d9ad3d6ae1ee30acf20afde9
Author: Andi Kleen <ak@suse.de>
Date:   Tue Sep 26 10:52:41 2006 +0200

    [PATCH] x86: Allow disabling early pci scans with pci=noearly or disallowing conf1
    
    Some buggy systems can machine check when config space accesses
    happen for some non existent devices.  i386/x86-64 do some early
    device scans that might trigger this. Allow pci=noearly to disable
    this. Also when type 1 is disabling also don't do any early
    accesses which are always type1.
    
    This moves the pci= configuration parsing to be a early parameter.
    I don't think this can break anything because it only changes
    a single global that is only used by PCI.
    
    Cc: gregkh@suse.de
    Cc: Trammell Hudson <hudson@osresearch.net>
    
    Signed-off-by: Andi Kleen <ak@suse.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 9f79dd6d51ab..684deb6b03aa 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -953,13 +953,12 @@ static int __devinit pci_setup(char *str)
 		}
 		str = k;
 	}
-	return 1;
+	return 0;
 }
+early_param("pci", pci_setup);
 
 device_initcall(pci_init);
 
-__setup("pci=", pci_setup);
-
 #if defined(CONFIG_ISA) || defined(CONFIG_EISA)
 /* FIXME: Some boxes have multiple ISA bridges! */
 struct pci_dev *isa_bridge;

commit b887d2e63c8857149ef59eb6e05adfaa018b8ebf
Author: David Brownell <david-b@pacbell.net>
Date:   Mon Aug 14 23:11:05 2006 -0700

    PM: PCI and IDE handle PM_EVENT_PRETHAW
    
    Convert some framework code to handle the new PRETHAW message.
    
      - IDE just treats it like a FREEZE.
    
      - The pci_choose_state() thingie still doesn't use PCI_D0 when it gets a
        FREEZE (and now PRETHAW) event, which seems rather buglike but wasn't
        something to change with this patch.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Cc: "Rafael J. Wysocki" <rjw@sisk.pl>
    Cc: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 9f79dd6d51ab..8ab027886034 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -432,10 +432,12 @@ pci_power_t pci_choose_state(struct pci_dev *dev, pm_message_t state)
 	case PM_EVENT_ON:
 		return PCI_D0;
 	case PM_EVENT_FREEZE:
+	case PM_EVENT_PRETHAW:
+		/* REVISIT both freeze and pre-thaw "should" use D0 */
 	case PM_EVENT_SUSPEND:
 		return PCI_D3hot;
 	default:
-		printk("They asked me for state %d\n", state.event);
+		printk("Unrecognized suspend event %d\n", state.event);
 		BUG();
 	}
 	return PCI_D0;

commit ffadcc2ff42ecedf71ea67d9051ff028927aed08
Author: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
Date:   Wed Jul 12 08:59:00 2006 -0700

    [PATCH] PCI: PCIE power management quirk
    
    When changing power states from D0->DX and then from DX->D0, some
    Intel PCIE chipsets will cause a device reset to occur.  This will
    cause problems for any D State other than D3, since any state
    information that the driver will expect to be present coming from
    a D1 or D2 state will have been cleared.  This patch addes a
    flag to the pci_dev structure to indicate that devices should
    not use states D1 or D2, and will set that flag for the affected
    chipsets.  This patch also modifies pci_set_power_state() so that
    when a device driver tries to set the power state on
    a device that is downstream from an affected chipset, or on one
    of the affected devices it only allows state changes to or
    from D0 & D3.  In addition, this patch allows the delay time
    between D3->D0 to be changed via a quirk.  These chipsets also
    need additional time to change states beyond the normal 10ms.
    
    Signed-off-by: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index cf57d7de3765..9f79dd6d51ab 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -19,6 +19,7 @@
 #include <asm/dma.h>	/* isa_dma_bridge_buggy */
 #include "pci.h"
 
+unsigned int pci_pm_d3_delay = 10;
 
 /**
  * pci_bus_max_busnr - returns maximum PCI bus number of given bus' children
@@ -313,6 +314,14 @@ pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 	} else if (dev->current_state == state)
 		return 0;        /* we're already there */
 
+	/*
+	 * If the device or the parent bridge can't support PCI PM, ignore
+	 * the request if we're doing anything besides putting it into D0
+	 * (which would only happen on boot).
+	 */
+	if ((state == PCI_D1 || state == PCI_D2) && pci_no_d1d2(dev))
+		return 0;
+
 	/* find PCI PM capability in list */
 	pm = pci_find_capability(dev, PCI_CAP_ID_PM);
 	
@@ -363,7 +372,7 @@ pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 	/* Mandatory power management transition delays */
 	/* see PCI PM 1.1 5.6.1 table 18 */
 	if (state == PCI_D3hot || dev->current_state == PCI_D3hot)
-		msleep(10);
+		msleep(pci_pm_d3_delay);
 	else if (state == PCI_D2 || dev->current_state == PCI_D2)
 		udelay(200);
 

commit 1396a8c3f7cec9f5e0d00bd089be21fc468f0f1c
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Jun 12 15:14:29 2006 -0700

    [PATCH] 64bit resource: fix up printks for resources in pci core and hotplug drivers
    
    This is needed if we wish to change the size of the resource structures.
    
    Based on an original patch from Vivek Goyal <vgoyal@in.ibm.com>
    
    Cc: Vivek Goyal <vgoyal@in.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 23d3b17c8cad..cf57d7de3765 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -691,10 +691,12 @@ int pci_request_region(struct pci_dev *pdev, int bar, const char *res_name)
 	return 0;
 
 err_out:
-	printk (KERN_WARNING "PCI: Unable to reserve %s region #%d:%lx@%lx for device %s\n",
+	printk (KERN_WARNING "PCI: Unable to reserve %s region #%d:%llx@%llx "
+		"for device %s\n",
 		pci_resource_flags(pdev, bar) & IORESOURCE_IO ? "I/O" : "mem",
 		bar + 1, /* PCI BAR # */
-		pci_resource_len(pdev, bar), pci_resource_start(pdev, bar),
+		(unsigned long long)pci_resource_len(pdev, bar),
+		(unsigned long long)pci_resource_start(pdev, bar),
 		pci_name(pdev));
 	return -EBUSY;
 }

commit d6e05edc59ecd79e8badf440c0d295a979bdfa3e
Author: Andreas Mohr <andi@lisas.de>
Date:   Mon Jun 26 18:35:02 2006 +0200

    spelling fixes
    
    acquired (aquired)
    contiguous (contigious)
    successful (succesful, succesfull)
    surprise (suprise)
    whether (weather)
    some other misspellings
    
    Signed-off-by: Andreas Mohr <andi@lisas.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index d408a3c30426..23d3b17c8cad 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -369,7 +369,7 @@ pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 
 	/*
 	 * Give firmware a chance to be called, such as ACPI _PRx, _PSx
-	 * Firmware method after natice method ?
+	 * Firmware method after native method ?
 	 */
 	if (platform_pci_set_power_state)
 		platform_pci_set_power_state(dev, state);

commit 99dc804d9bcc2c53f4c20c291bf4e185312a1a0c
Author: Shaohua Li <shaohua.li@intel.com>
Date:   Fri May 26 10:58:27 2006 +0800

    [PATCH] PCI: disable msi mode in pci_disable_device
    
    Brice said the pci_save_msi_state breaks his driver in his special usage
    (not in suspend/resume), as pci_save_msi_state will disable msi mode. In
    his usage, pci_save_state will be called at runtime, and later (after
    the device operates for some time and has an error) pci_restore_state
    will be called.
    In another hand, suspend/resume needs disable msi mode, as device should
    stop working completely. This patch try to workaround this issue.
    Drivers are expected call pci_disable_device in suspend time after
    pci_save_state.
    
    Signed-off-by: Shaohua Li <shaohua.li@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index aa480370ef10..d408a3c30426 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -551,7 +551,14 @@ void
 pci_disable_device(struct pci_dev *dev)
 {
 	u16 pci_command;
-	
+
+	if (dev->msi_enabled)
+		disable_msi_mode(dev, pci_find_capability(dev, PCI_CAP_ID_MSI),
+			PCI_CAP_ID_MSI);
+	if (dev->msix_enabled)
+		disable_msi_mode(dev, pci_find_capability(dev, PCI_CAP_ID_MSI),
+			PCI_CAP_ID_MSIX);
+
 	pci_read_config_word(dev, PCI_COMMAND, &pci_command);
 	if (pci_command & PCI_COMMAND_MASTER) {
 		pci_command &= ~PCI_COMMAND_MASTER;

commit a1e022b3aeacf633a6c8e8f0eb04d9c9e44b4fcd
Author: Kristen Accardi <kristen.c.accardi@intel.com>
Date:   Fri Apr 28 11:37:38 2006 -0700

    [PATCH] PCI: don't enable device if already enabled
    
    If a device is already enabled, don't bother reenabling it.
    
    Signed-off-by: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
    Acked-By: Arjan van de Ven <arjan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index fde41cc14734..aa480370ef10 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -517,7 +517,12 @@ pci_enable_device_bars(struct pci_dev *dev, int bars)
 int
 pci_enable_device(struct pci_dev *dev)
 {
-	int err = pci_enable_device_bars(dev, (1 << PCI_NUM_RESOURCES) - 1);
+	int err;
+
+	if (dev->is_enabled)
+		return 0;
+
+	err = pci_enable_device_bars(dev, (1 << PCI_NUM_RESOURCES) - 1);
 	if (err)
 		return err;
 	pci_fixup_device(pci_fixup_enable, dev);

commit b5ed7639c9f502898af4109e778f5613dacbfd9c
Merge: 0638dec01e89 eb35cf60e462
Author: Jeff Garzik <jeff@garzik.org>
Date:   Tue Jun 13 20:29:04 2006 -0400

    Merge branch 'master' into upstream

commit 8b8c8d280ab2d18fe6e42d671f60d4ffed451cdc
Author: Yu, Luming <luming.yu@intel.com>
Date:   Tue Apr 25 00:00:34 2006 -0700

    [PATCH] PCI: reverse pci config space restore order
    
    According to Intel ICH spec, there are several rules that Base Address
    should be programmed before IOSE  (PCICMD register ) enabled.
    
    For example ICH7:
    
    12.1.3  SATA : the base address register for the bus master register
                   should be programmed before this bit is set.
    
    11.1.3:  PCICMD (USB): The base address register for USB should be
                           programmed before this bit is set.
    ....
    
    To make sure kernel code follow this rule , and prevent unnecessary
    confusion. I proposal this patch.
    
    Signed-off-by: Luming Yu <luming.yu@intel.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index d2520451f36b..12286275b1c8 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -463,7 +463,11 @@ pci_restore_state(struct pci_dev *dev)
 	int i;
 	int val;
 
-	for (i = 0; i < 16; i++) {
+	/*
+	 * The Base Address register should be programmed before the command
+	 * register(s)
+	 */
+	for (i = 15; i >= 0; i--) {
 		pci_read_config_dword(dev, i * 4, &val);
 		if (val != dev->saved_config_space[i]) {
 			printk(KERN_DEBUG "PM: Writing back config space on "

commit 04d9c1a1100b6bdeffa7e1bfc30080bdac28e183
Author: Dave Jones <davej@redhat.com>
Date:   Tue Apr 18 21:06:51 2006 -0700

    [PATCH] PCI: Improve PCI config space writeback
    
    At least one laptop blew up on resume from suspend with a black screen due
    to a lack of this patch.  By only writing back config space that is
    different, we minimise the possibility of accidents like this.
    
    Signed-off-by: Dave Jones <davej@redhat.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 2329f941a0dc..d2520451f36b 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -461,9 +461,19 @@ int
 pci_restore_state(struct pci_dev *dev)
 {
 	int i;
-
-	for (i = 0; i < 16; i++)
-		pci_write_config_dword(dev,i * 4, dev->saved_config_space[i]);
+	int val;
+
+	for (i = 0; i < 16; i++) {
+		pci_read_config_dword(dev, i * 4, &val);
+		if (val != dev->saved_config_space[i]) {
+			printk(KERN_DEBUG "PM: Writing back config space on "
+				"device %s at offset %x (was %x, writing %x)\n",
+				pci_name(dev), i,
+				val, (int)dev->saved_config_space[i]);
+			pci_write_config_dword(dev,i * 4,
+				dev->saved_config_space[i]);
+		}
+	}
 	pci_restore_msi_state(dev);
 	pci_restore_msix_state(dev);
 	return 0;

commit 3a720d726a6aa0a7cd9190f694587adf7bafdf4f
Author: Brice Goglin <brice@myri.com>
Date:   Tue May 23 06:10:01 2006 -0400

    [PATCH] Revive pci_find_ext_capability
    
    This patch revives pci_find_ext_capability (has been disabled a couple month
    ago since it was not used anywhere. See http://lkml.org/lkml/2006/1/20/247).
    It will now be used by the myri10ge driver.
    
    Signed-off-by: Brice Goglin <brice@myri.com>
    Signed-off-by: Andrew J. Gallatin <gallatin@myri.com>
    
     drivers/pci/pci.c   |    3 +--
     include/linux/pci.h |    2 ++
     2 files changed, 3 insertions(+), 2 deletions(-)
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 2329f941a0dc..8d107c6c2c70 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -164,7 +164,6 @@ int pci_bus_find_capability(struct pci_bus *bus, unsigned int devfn, int cap)
 	return __pci_bus_find_cap(bus, devfn, hdr_type & 0x7f, cap);
 }
 
-#if 0
 /**
  * pci_find_ext_capability - Find an extended capability
  * @dev: PCI device to query
@@ -212,7 +211,7 @@ int pci_find_ext_capability(struct pci_dev *dev, int cap)
 
 	return 0;
 }
-#endif  /*  0  */
+EXPORT_SYMBOL_GPL(pci_find_ext_capability);
 
 /**
  * pci_find_parent_resource - return resource region of parent bus of given region

commit bcdc084257352902103aca85c65ddbbba8f74732
Merge: 754a264c4217 78a596b4490e
Author: Linus Torvalds <torvalds@g5.osdl.org>
Date:   Fri Apr 14 17:08:18 2006 -0700

    Merge master.kernel.org:/pub/scm/linux/kernel/git/gregkh/pci-2.6
    
    * master.kernel.org:/pub/scm/linux/kernel/git/gregkh/pci-2.6: (169 commits)
      commit 78a596b4490e17b9990d87b9d468ef5bb70daa10
      Author: Adrian Bunk <bunk@stusta.de>
      Date:   Fri Mar 31 01:38:12 2006 -0800
    
          [PATCH] remove kernel/power/pm.c:pm_unregister()
    
          Since the last user is removed in -mm, we can now remove this long deprecated
          function.
    
          Signed-off-by: Adrian Bunk <bunk@stusta.de>
          Cc: Pavel Machek <pavel@ucw.cz>
          Signed-off-by: Andrew Morton <akpm@osdl.org>
          Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    
      commit 21440d313358043b0ce5e43b00ff3c9b35a8616c
      Author: David Brownell <david-b@pacbell.net>
      Date:   Sat Apr 1 10:21:52 2006 -0800
    
          [PATCH] dma doc updates
    
      ...

commit 41017f0cac925e4a6bcf3359b75e5538112d4216
Author: Shaohua Li <shaohua.li@intel.com>
Date:   Wed Feb 8 17:11:38 2006 +0800

    [PATCH] PCI: MSI(X) save/restore for suspend/resume
    
    Add MSI(X) configure sapce save/restore in generic PCI helper.
    
    Signed-off-by: Shaohua Li <shaohua.li@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index bea1ad1ad5ba..69a617d21824 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -444,6 +444,10 @@ pci_save_state(struct pci_dev *dev)
 	/* XXX: 100% dword access ok here? */
 	for (i = 0; i < 16; i++)
 		pci_read_config_dword(dev, i * 4,&dev->saved_config_space[i]);
+	if ((i = pci_save_msi_state(dev)) != 0)
+		return i;
+	if ((i = pci_save_msix_state(dev)) != 0)
+		return i;
 	return 0;
 }
 
@@ -458,6 +462,8 @@ pci_restore_state(struct pci_dev *dev)
 
 	for (i = 0; i < 16; i++)
 		pci_write_config_dword(dev,i * 4, dev->saved_config_space[i]);
+	pci_restore_msi_state(dev);
+	pci_restore_msix_state(dev);
 	return 0;
 }
 

commit 026694920579590c73b5c56705d543568ed5ad41
Author: Andrew Morton <akpm@osdl.org>
Date:   Thu Mar 23 01:38:34 2006 -0800

    [PATCH] pm: print name of failed suspend function
    
    Print more diagnostic info to help identify the source of power management
    suspend failures.
    
    Example:
    
    usb_hcd_pci_suspend(): pci_set_power_state+0x0/0x1af() returns -22
    pci_device_suspend(): usb_hcd_pci_suspend+0x0/0x11b() returns -22
    suspend_device(): pci_device_suspend+0x0/0x34() returns -22
    
    Work-in-progress.  It needs lots more suspend_report_result() calls sprinkled
    everywhere.
    
    Cc: Patrick Mochel <mochel@digitalimplant.org>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: Nigel Cunningham <nigel@suspend2.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index bea1ad1ad5ba..042fa5265cf6 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -307,9 +307,11 @@ pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 	 * Can enter D0 from any state, but if we can only go deeper 
 	 * to sleep if we're already in a low power state
 	 */
-	if (state != PCI_D0 && dev->current_state > state)
+	if (state != PCI_D0 && dev->current_state > state) {
+		printk(KERN_ERR "%s(): %s: state=%d, current state=%d\n",
+			__FUNCTION__, pci_name(dev), state, dev->current_state);
 		return -EINVAL;
-	else if (dev->current_state == state) 
+	} else if (dev->current_state == state)
 		return 0;        /* we're already there */
 
 	/* find PCI PM capability in list */

commit 3c990e9219ea0b0aee588473ce6c8a66cdee3ff5
Author: Jeff Garzik <jeff@garzik.org>
Date:   Sat Mar 4 21:52:42 2006 -0500

    [PATCH] PCI: fix pci_request_region[s] arg
    
        Add missing 'const' to pci_request_region[s] 'res_name' arg,
        since we pass it directly to __request_region(), whose 'name' arg
        is also const.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 03af23238939..bea1ad1ad5ba 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -639,7 +639,7 @@ void pci_release_region(struct pci_dev *pdev, int bar)
  *	Returns 0 on success, or %EBUSY on error.  A warning
  *	message is also printed on failure.
  */
-int pci_request_region(struct pci_dev *pdev, int bar, char *res_name)
+int pci_request_region(struct pci_dev *pdev, int bar, const char *res_name)
 {
 	if (pci_resource_len(pdev, bar) == 0)
 		return 0;
@@ -697,7 +697,7 @@ void pci_release_regions(struct pci_dev *pdev)
  *	Returns 0 on success, or %EBUSY on error.  A warning
  *	message is also printed on failure.
  */
-int pci_request_regions(struct pci_dev *pdev, char *res_name)
+int pci_request_regions(struct pci_dev *pdev, const char *res_name)
 {
 	int i;
 	

commit 309e57df7b766172ba137a8cbd909f88dd76e8e9
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Sun Mar 5 22:33:34 2006 -0700

    [PATCH] PCI: Provide a boot parameter to disable MSI
    
    Several drivers are starting to grow options to disable MSI.  However,
    it's often a host chipset issue, not something which individual drivers
    should handle.  So we add the pci=nomsi kernel parameter to allow the user
    to disable MSI modes for systems we haven't added to the quirk list yet.
    
    Signed-off-by: Matthew Wilcox <matthew@wil.cx>
    Signed-off-by: Randy Dunlap <rdunlap@xenotime.net>
    Acked-by: Jeff Garzik <jeff@garzik.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 0bf6d254426b..03af23238939 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -900,8 +900,12 @@ static int __devinit pci_setup(char *str)
 		if (k)
 			*k++ = 0;
 		if (*str && (str = pcibios_setup(str)) && *str) {
-			/* PCI layer options should be handled here */
-			printk(KERN_ERR "PCI: Unknown option `%s'\n", str);
+			if (!strcmp(str, "nomsi")) {
+				pci_no_msi();
+			} else {
+				printk(KERN_ERR "PCI: Unknown option `%s'\n",
+						str);
+			}
 		}
 		str = k;
 	}

commit b82db5cedf78bfeb4a1c8a28ae284dc671d26eb3
Author: Kristen Accardi <kristen.c.accardi@intel.com>
Date:   Tue Jan 17 16:56:56 2006 -0800

    [PATCH] PCI: return max reserved busnr
    
    Change the semantics of this call to return the max reserved
    bus number instead of just the max assigned bus number.
    
    Signed-off-by: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index e17cd49d6244..0bf6d254426b 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -19,7 +19,6 @@
 #include <asm/dma.h>	/* isa_dma_bridge_buggy */
 #include "pci.h"
 
-#if 0
 
 /**
  * pci_bus_max_busnr - returns maximum PCI bus number of given bus' children
@@ -34,7 +33,7 @@ pci_bus_max_busnr(struct pci_bus* bus)
 	struct list_head *tmp;
 	unsigned char max, n;
 
-	max = bus->number;
+	max = bus->subordinate;
 	list_for_each(tmp, &bus->children) {
 		n = pci_bus_max_busnr(pci_bus_b(tmp));
 		if(n > max)
@@ -42,7 +41,9 @@ pci_bus_max_busnr(struct pci_bus* bus)
 	}
 	return max;
 }
+EXPORT_SYMBOL_GPL(pci_bus_max_busnr);
 
+#if 0
 /**
  * pci_max_busnr - returns maximum PCI bus number
  *

commit b64c05e7de6071694dd6840eac9724a006ee19f8
Author: Grant Grundler <grundler@parisc-linux.org>
Date:   Sat Jan 14 00:34:53 2006 -0700

    [PATCH] PCI: clean up msi.c a bit
    
    Clean up: move assignments outside of if() statements.
    AFAICT, no functional change. Easier to read/understand.
    
    Depends on "[PATCH 1/3] msi vector targeting abstractions"
    by Mark Maule <maule@sgi.com>.
    I expect one hunk to fail if applied against 2.6.15.
    
    This is essentially Joe Perches' patch.
    I've cleaned up the one instance added by Mark's patch.
    
    Signed-off-by: Grant Grundler <grundler@parisc-linux.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index d2d187916643..e17cd49d6244 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -495,9 +495,8 @@ pci_enable_device_bars(struct pci_dev *dev, int bars)
 int
 pci_enable_device(struct pci_dev *dev)
 {
-	int err;
-
-	if ((err = pci_enable_device_bars(dev, (1 << PCI_NUM_RESOURCES) - 1)))
+	int err = pci_enable_device_bars(dev, (1 << PCI_NUM_RESOURCES) - 1);
+	if (err)
 		return err;
 	pci_fixup_device(pci_fixup_enable, dev);
 	dev->is_enabled = 1;

commit f8d65713332cf6306889a3036142a17e01e3447e
Author: Adrian Bunk <bunk@stusta.de>
Date:   Fri Jan 6 03:25:37 2006 +0100

    [PATCH] PCI: drivers/pci/pci.c: #if 0 pci_find_ext_capability()
    
    This patch #if 0's the unused global function pci_find_ext_capability().
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index d2a633efa10a..d2d187916643 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -163,6 +163,7 @@ int pci_bus_find_capability(struct pci_bus *bus, unsigned int devfn, int cap)
 	return __pci_bus_find_cap(bus, devfn, hdr_type & 0x7f, cap);
 }
 
+#if 0
 /**
  * pci_find_ext_capability - Find an extended capability
  * @dev: PCI device to query
@@ -210,6 +211,7 @@ int pci_find_ext_capability(struct pci_dev *dev, int cap)
 
 	return 0;
 }
+#endif  /*  0  */
 
 /**
  * pci_find_parent_resource - return resource region of parent bus of given region

commit 54c762fe62d9ff0982f38e80cbec9c59104311e9
Author: Adrian Bunk <bunk@stusta.de>
Date:   Thu Dec 22 01:08:52 2005 +0100

    [PATCH] PCI: drivers/pci: some cleanups
    
    This patch contains the following cleanups:
    - hotplug/pciehp_core.c: make the needlessly global hpdriver_context
                             static
    - #if 0 the following unused functions:
      - pci.c: pci_bus_max_busnr()
      - pci.c: pci_max_busnr()
      - proc.c: pci_proc_attach_bus()
      - remove.c: pci_remove_device_safe
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 81b9b8d9bceb..d2a633efa10a 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -19,6 +19,7 @@
 #include <asm/dma.h>	/* isa_dma_bridge_buggy */
 #include "pci.h"
 
+#if 0
 
 /**
  * pci_bus_max_busnr - returns maximum PCI bus number of given bus' children
@@ -63,6 +64,8 @@ pci_max_busnr(void)
 	return max;
 }
 
+#endif  /*  0  */
+
 static int __pci_find_next_cap(struct pci_bus *bus, unsigned int devfn, u8 pos, int cap)
 {
 	u8 id;
@@ -917,8 +920,6 @@ EXPORT_SYMBOL_GPL(pci_restore_bars);
 EXPORT_SYMBOL(pci_enable_device_bars);
 EXPORT_SYMBOL(pci_enable_device);
 EXPORT_SYMBOL(pci_disable_device);
-EXPORT_SYMBOL(pci_max_busnr);
-EXPORT_SYMBOL(pci_bus_max_busnr);
 EXPORT_SYMBOL(pci_find_capability);
 EXPORT_SYMBOL(pci_bus_find_capability);
 EXPORT_SYMBOL(pci_release_regions);

commit 514d207db1fa3c3d2bd7990ebed8d81cebc7875b
Author: Kristen Accardi <kristen.c.accardi@intel.com>
Date:   Wed Nov 2 16:24:39 2005 -0800

    [PATCH] pci: use pin stored in pci_dev
    
    Use the stored value of the interrupt pin rather than try to read
    the config again.
    
    Signed-off-by: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 8e287a828d5d..81b9b8d9bceb 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -587,7 +587,7 @@ pci_get_interrupt_pin(struct pci_dev *dev, struct pci_dev **bridge)
 {
 	u8 pin;
 
-	pci_read_config_byte(dev, PCI_INTERRUPT_PIN, &pin);
+	pin = dev->pin;
 	if (!pin)
 		return -1;
 	pin--;

commit 24a4e377068d15424cd6a921d41352f295548037
Author: Roland Dreier <rolandd@cisco.com>
Date:   Fri Oct 28 17:35:34 2005 -0700

    [PATCH] PCI: add pci_find_next_capability()
    
    Some devices have more than one capability of the same type.  For
    example, the PCI header for the PathScale InfiniPath looks like:
    
            04:01.0 InfiniBand: Unknown device 1fc1:000d (rev 02)
                    Subsystem: Unknown device 1fc1:000d
                    Flags: bus master, fast devsel, latency 0, IRQ 193
                    Memory at fea00000 (64-bit, non-prefetchable) [size=2M]
                    Capabilities: [c0] HyperTransport: Slave or Primary Interface
                    Capabilities: [f8] HyperTransport: Interrupt Discovery and Configuration
    
    There are _two_ HyperTransport capabilities, and the PathScale driver
    wants to look at both of them.
    
    The current pci_find_capability() API doesn't work for this, since it
    only allows us to get to the first capability of a given type.  The
    patch below introduces a new pci_find_next_capability(), which can be
    used in a loop like
    
            for (pos = pci_find_capability(pdev, <ID>);
                 pos;
                 pos = pci_find_next_capability(pdev, pos, <ID>)) {
                    /* ... */
            }
    
    Signed-off-by: Roland Dreier <rolandd@cisco.com>
    Signed-off-by: Matthew Wilcox <matthew@wil.cx>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index e74d75843047..8e287a828d5d 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -63,11 +63,38 @@ pci_max_busnr(void)
 	return max;
 }
 
+static int __pci_find_next_cap(struct pci_bus *bus, unsigned int devfn, u8 pos, int cap)
+{
+	u8 id;
+	int ttl = 48;
+
+	while (ttl--) {
+		pci_bus_read_config_byte(bus, devfn, pos, &pos);
+		if (pos < 0x40)
+			break;
+		pos &= ~3;
+		pci_bus_read_config_byte(bus, devfn, pos + PCI_CAP_LIST_ID,
+					 &id);
+		if (id == 0xff)
+			break;
+		if (id == cap)
+			return pos;
+		pos += PCI_CAP_LIST_NEXT;
+	}
+	return 0;
+}
+
+int pci_find_next_capability(struct pci_dev *dev, u8 pos, int cap)
+{
+	return __pci_find_next_cap(dev->bus, dev->devfn,
+				   pos + PCI_CAP_LIST_NEXT, cap);
+}
+EXPORT_SYMBOL_GPL(pci_find_next_capability);
+
 static int __pci_bus_find_cap(struct pci_bus *bus, unsigned int devfn, u8 hdr_type, int cap)
 {
 	u16 status;
-	u8 pos, id;
-	int ttl = 48;
+	u8 pos;
 
 	pci_bus_read_config_word(bus, devfn, PCI_STATUS, &status);
 	if (!(status & PCI_STATUS_CAP_LIST))
@@ -76,24 +103,15 @@ static int __pci_bus_find_cap(struct pci_bus *bus, unsigned int devfn, u8 hdr_ty
 	switch (hdr_type) {
 	case PCI_HEADER_TYPE_NORMAL:
 	case PCI_HEADER_TYPE_BRIDGE:
-		pci_bus_read_config_byte(bus, devfn, PCI_CAPABILITY_LIST, &pos);
+		pos = PCI_CAPABILITY_LIST;
 		break;
 	case PCI_HEADER_TYPE_CARDBUS:
-		pci_bus_read_config_byte(bus, devfn, PCI_CB_CAPABILITY_LIST, &pos);
+		pos = PCI_CB_CAPABILITY_LIST;
 		break;
 	default:
 		return 0;
 	}
-	while (ttl-- && pos >= 0x40) {
-		pos &= ~3;
-		pci_bus_read_config_byte(bus, devfn, pos + PCI_CAP_LIST_ID, &id);
-		if (id == 0xff)
-			break;
-		if (id == cap)
-			return pos;
-		pci_bus_read_config_byte(bus, devfn, pos + PCI_CAP_LIST_NEXT, &pos);
-	}
-	return 0;
+	return __pci_find_next_cap(bus, devfn, pos, cap);
 }
 
 /**

commit 4e57b6817880946a3a78d5d8cad1ace363f7e449
Author: Tim Schmielau <tim@physik3.uni-rostock.de>
Date:   Sun Oct 30 15:03:48 2005 -0800

    [PATCH] fix missing includes
    
    I recently picked up my older work to remove unnecessary #includes of
    sched.h, starting from a patch by Dave Jones to not include sched.h
    from module.h. This reduces the number of indirect includes of sched.h
    by ~300. Another ~400 pointless direct includes can be removed after
    this disentangling (patch to follow later).
    However, quite a few indirect includes need to be fixed up for this.
    
    In order to feed the patches through -mm with as little disturbance as
    possible, I've split out the fixes I accumulated up to now (complete for
    i386 and x86_64, more archs to follow later) and post them before the real
    patch.  This way this large part of the patch is kept simple with only
    adding #includes, and all hunks are independent of each other.  So if any
    hunk rejects or gets in the way of other patches, just drop it.  My scripts
    will pick it up again in the next round.
    
    Signed-off-by: Tim Schmielau <tim@physik3.uni-rostock.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 61b855c99e39..e74d75843047 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -15,6 +15,7 @@
 #include <linux/pci.h>
 #include <linux/module.h>
 #include <linux/spinlock.h>
+#include <linux/string.h>
 #include <asm/dma.h>	/* isa_dma_bridge_buggy */
 #include "pci.h"
 

commit 8f7020d36374dda9366fee1343f8eacfe8f5e641
Author: Randy Dunlap <rdunlap@xenotime.net>
Date:   Sun Oct 23 11:57:38 2005 -0700

    [PATCH] kernel-doc: PCI fixes
    
    PCI: add descriptions for missing function parameters.
    Eliminate all kernel-doc warnings here.
    
    Signed-off-by: Randy Dunlap <rdunlap@xenotime.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 39bdb938521d..61b855c99e39 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -252,6 +252,8 @@ pci_restore_bars(struct pci_dev *dev)
 		pci_update_resource(dev, &dev->resource[i], i);
 }
 
+int (*platform_pci_set_power_state)(struct pci_dev *dev, pci_power_t t);
+
 /**
  * pci_set_power_state - Set the power state of a PCI device
  * @dev: PCI device to be suspended
@@ -266,7 +268,6 @@ pci_restore_bars(struct pci_dev *dev)
  * -EIO if device does not support PCI PM.
  * 0 if we can successfully change the power state.
  */
-int (*platform_pci_set_power_state)(struct pci_dev *dev, pci_power_t t);
 int
 pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 {
@@ -808,8 +809,8 @@ pci_clear_mwi(struct pci_dev *dev)
 
 /**
  * pci_intx - enables/disables PCI INTx for device dev
- * @dev: the PCI device to operate on
- * @enable: boolean
+ * @pdev: the PCI device to operate on
+ * @enable: boolean: whether to enable or disable PCI INTx
  *
  * Enables/disables PCI INTx for device dev
  */

commit d3535fbbce0eef8faa8de30d187fc83b11b858ef
Author: John W. Linville <linville@tuxdriver.com>
Date:   Wed Sep 28 17:50:51 2005 -0400

    [PATCH] pci: cleanup need_restore switch statement
    
    Cleanup the need_restore switch statement in
    pci_set_power_state(). This makes it more safe by explicitly handling
    all the PCI power states instead of handling them as the default
    case. It also reads a little better IMHO.
    
    Signed-off-by: John W. Linville <linville@tuxdriver.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 259d247b7551..39bdb938521d 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -314,19 +314,19 @@ pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 	 * sets PowerState to 0.
 	 */
 	switch (dev->current_state) {
+	case PCI_D0:
+	case PCI_D1:
+	case PCI_D2:
+		pmcsr &= ~PCI_PM_CTRL_STATE_MASK;
+		pmcsr |= state;
+		break;
 	case PCI_UNKNOWN: /* Boot-up */
 		if ((pmcsr & PCI_PM_CTRL_STATE_MASK) == PCI_D3hot
 		 && !(pmcsr & PCI_PM_CTRL_NO_SOFT_RESET))
 			need_restore = 1;
 		/* Fall-through: force to D0 */
-	case PCI_D3hot:
-	case PCI_D3cold:
-	case PCI_POWER_ERROR:
-		pmcsr = 0;
-		break;
 	default:
-		pmcsr &= ~PCI_PM_CTRL_STATE_MASK;
-		pmcsr |= state;
+		pmcsr = 0;
 		break;
 	}
 

commit 32a3658533c6f4c6bf370dd730213e802464ef9b
Author: John W. Linville <linville@tuxdriver.com>
Date:   Wed Sep 14 09:52:42 2005 -0400

    [PATCH] pci: only call pci_restore_bars at boot
    
    Certain (SGI?) ia64 boxes object to having their PCI BARs
    restored unless absolutely necessary. This patch restricts calling
    pci_restore_bars from pci_set_power_state unless the current state
    is PCI_UNKNOWN, the actual (i.e. physical) state of the device is
    PCI_D3hot, and the device indicates that it will lose its configuration
    when transitioning to PCI_D0.
    
    Signed-off-by: John W. Linville <linville@tuxdriver.com>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 992db89adce7..259d247b7551 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -309,17 +309,25 @@ pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 
 	pci_read_config_word(dev, pm + PCI_PM_CTRL, &pmcsr);
 
-	/* If we're in D3, force entire word to 0.
+	/* If we're (effectively) in D3, force entire word to 0.
 	 * This doesn't affect PME_Status, disables PME_En, and
 	 * sets PowerState to 0.
 	 */
-	if (dev->current_state >= PCI_D3hot) {
-		if (!(pmcsr & PCI_PM_CTRL_NO_SOFT_RESET))
+	switch (dev->current_state) {
+	case PCI_UNKNOWN: /* Boot-up */
+		if ((pmcsr & PCI_PM_CTRL_STATE_MASK) == PCI_D3hot
+		 && !(pmcsr & PCI_PM_CTRL_NO_SOFT_RESET))
 			need_restore = 1;
+		/* Fall-through: force to D0 */
+	case PCI_D3hot:
+	case PCI_D3cold:
+	case PCI_POWER_ERROR:
 		pmcsr = 0;
-	} else {
+		break;
+	default:
 		pmcsr &= ~PCI_PM_CTRL_STATE_MASK;
 		pmcsr |= state;
+		break;
 	}
 
 	/* enter specified state */

commit 2fd9d74b35efa9823f1f7d34cb421e2b9eee9650
Author: Brett M Russ <russb@emc.com>
Date:   Fri Sep 9 10:02:22 2005 -0700

    [PATCH] PCI: PCI/libata INTx bug fix
    
    Previous INTx cleanup patch had a bug that was not caught.  I found
    this last night during testing and can confirm that it is now 100%
    working.
    
    Signed-off-by: Brett Russ <russb@emc.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    Acked-by: Jeff Garzik <jgarzik@pobox.com>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index ccff633a3948..992db89adce7 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -819,7 +819,7 @@ pci_intx(struct pci_dev *pdev, int enable)
 	}
 
 	if (new != pci_command) {
-		pci_write_config_word(pdev, PCI_COMMAND, pci_command);
+		pci_write_config_word(pdev, PCI_COMMAND, new);
 	}
 }
 

commit a04ce0ffcaf561994ecf382cd3caad75556dc499
Author: Brett M Russ <russb@emc.com>
Date:   Mon Aug 15 15:23:41 2005 -0400

    [PATCH] PCI/libata INTx cleanup
    
    Simple cleanup to eliminate X copies of the pci_enable_intx() function
    in libata.  Moved ahci.c's pci_intx() to pci.c and use it throughout
    libata and msi.c.
    
    Signed-off-by: Brett Russ <russb@emc.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index e179af3186f5..ccff633a3948 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -798,6 +798,31 @@ pci_clear_mwi(struct pci_dev *dev)
 	}
 }
 
+/**
+ * pci_intx - enables/disables PCI INTx for device dev
+ * @dev: the PCI device to operate on
+ * @enable: boolean
+ *
+ * Enables/disables PCI INTx for device dev
+ */
+void
+pci_intx(struct pci_dev *pdev, int enable)
+{
+	u16 pci_command, new;
+
+	pci_read_config_word(pdev, PCI_COMMAND, &pci_command);
+
+	if (enable) {
+		new = pci_command & ~PCI_COMMAND_INTX_DISABLE;
+	} else {
+		new = pci_command | PCI_COMMAND_INTX_DISABLE;
+	}
+
+	if (new != pci_command) {
+		pci_write_config_word(pdev, PCI_COMMAND, pci_command);
+	}
+}
+
 #ifndef HAVE_ARCH_PCI_SET_DMA_MASK
 /*
  * These can be overridden by arch-specific implementations
@@ -875,6 +900,7 @@ EXPORT_SYMBOL(pci_request_region);
 EXPORT_SYMBOL(pci_set_master);
 EXPORT_SYMBOL(pci_set_mwi);
 EXPORT_SYMBOL(pci_clear_mwi);
+EXPORT_SYMBOL_GPL(pci_intx);
 EXPORT_SYMBOL(pci_set_dma_mask);
 EXPORT_SYMBOL(pci_set_consistent_dma_mask);
 EXPORT_SYMBOL(pci_assign_resource);

commit 3fe9d19f9e86a55679f5f2b38ec0a43a1a510cee
Author: Daniel Ritz <daniel.ritz@gmx.ch>
Date:   Wed Aug 17 15:32:19 2005 -0700

    [PATCH] PCI: Support PCM PM CAP version 3
    
    - support PCI PM CAP version 3 (as defined in PCI PM Interface Spec v1.2)
    
    - pci/probe.c sets the PM state initially to 4 which is D3cold.  add a
      PCI_UNKNOWN
    
    - minor cleanups
    
    Signed-off-by: Daniel Ritz <daniel.ritz@gmx.ch>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 3dcb83d7eb25..e179af3186f5 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -294,7 +294,7 @@ pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 		return -EIO; 
 
 	pci_read_config_word(dev,pm + PCI_PM_PMC,&pmc);
-	if ((pmc & PCI_PM_CAP_VER_MASK) > 2) {
+	if ((pmc & PCI_PM_CAP_VER_MASK) > 3) {
 		printk(KERN_DEBUG
 		       "PCI: %s has unsupported PM cap regs version (%u)\n",
 		       pci_name(dev), pmc & PCI_PM_CAP_VER_MASK);
@@ -302,12 +302,10 @@ pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 	}
 
 	/* check if this device supports the desired state */
-	if (state == PCI_D1 || state == PCI_D2) {
-		if (state == PCI_D1 && !(pmc & PCI_PM_CAP_D1))
-			return -EIO;
-		else if (state == PCI_D2 && !(pmc & PCI_PM_CAP_D2))
-			return -EIO;
-	}
+	if (state == PCI_D1 && !(pmc & PCI_PM_CAP_D1))
+		return -EIO;
+	else if (state == PCI_D2 && !(pmc & PCI_PM_CAP_D2))
+		return -EIO;
 
 	pci_read_config_word(dev, pm + PCI_PM_CTRL, &pmcsr);
 

commit 11f3859b1e85dd408756c72e228cfb5aa7230c87
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Aug 10 15:18:44 2005 -0400

    [PATCH] PCI: Fix regression in pci_enable_device_bars
    
    This patch (as552) fixes yet another small problem recently added.  If an
    attempt to put a PCI device back into D0 fails because the device doesn't
    support PCI PM, it shouldn't count as error.  Without this patch the UHCI
    controllers on my Intel motherboard don't work.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index afee2de3f323..3dcb83d7eb25 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -445,7 +445,7 @@ pci_enable_device_bars(struct pci_dev *dev, int bars)
 	int err;
 
 	err = pci_set_power_state(dev, PCI_D0);
-	if (err)
+	if (err < 0 && err != -EIO)
 		return err;
 	err = pcibios_enable_device(dev, bars);
 	if (err < 0)

commit 95a629657dbe28e44a312c47815b3dc3f1ce0970
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Jul 28 11:37:33 2005 -0700

    [PATCH] PCI: start paying attention to a lot of pci function return values
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 93ec158d06c1..afee2de3f323 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -444,8 +444,11 @@ pci_enable_device_bars(struct pci_dev *dev, int bars)
 {
 	int err;
 
-	pci_set_power_state(dev, PCI_D0);
-	if ((err = pcibios_enable_device(dev, bars)) < 0)
+	err = pci_set_power_state(dev, PCI_D0);
+	if (err)
+		return err;
+	err = pcibios_enable_device(dev, bars);
+	if (err < 0)
 		return err;
 	return 0;
 }

commit 064b53dbcc977dbf2753a67c2b8fc1c061d74f21
Author: John W. Linville <linville@tuxdriver.com>
Date:   Wed Jul 27 10:19:44 2005 -0400

    [PATCH] PCI: restore BAR values after D3hot->D0 for devices that need it
    
    Some PCI devices (e.g. 3c905B, 3c556B) lose all configuration
    (including BARs) when transitioning from D3hot->D0.  This leaves such
    a device in an inaccessible state.  The patch below causes the BARs
    to be restored when enabling such a device, so that its driver will
    be able to access it.
    
    The patch also adds pci_restore_bars as a new global symbol, and adds a
    correpsonding EXPORT_SYMBOL_GPL for that.
    
    Some firmware (e.g. Thinkpad T21) leaves devices in D3hot after a
    (re)boot.  Most drivers call pci_enable_device very early, so devices
    left in D3hot that lose configuration during the D3hot->D0 transition
    will be inaccessible to their drivers.
    
    Drivers could be modified to account for this, but it would
    be difficult to know which drivers need modification.  This is
    especially true since often many devices are covered by the same
    driver.  It likely would be necessary to replicate code across dozens
    of drivers.
    
    The patch below should trigger only when transitioning from D3hot->D0
    (or at boot), and only for devices that have the "no soft reset" bit
    cleared in the PM control register.  I believe it is safe to include
    this patch as part of the PCI infrastructure.
    
    The cleanest implementation of pci_restore_bars was to call
    pci_update_resource.  Unfortunately, that does not currently exist
    for the sparc64 architecture.  The patch below includes a null
    implemenation of pci_update_resource for sparc64.
    
    Some have expressed interest in making general use of the the
    pci_restore_bars function, so that has been exported to GPL licensed
    modules.
    
    Signed-off-by: John W. Linville <linville@tuxdriver.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index c62d2f043397..93ec158d06c1 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -221,6 +221,37 @@ pci_find_parent_resource(const struct pci_dev *dev, struct resource *res)
 	return best;
 }
 
+/**
+ * pci_restore_bars - restore a devices BAR values (e.g. after wake-up)
+ * @dev: PCI device to have its BARs restored
+ *
+ * Restore the BAR values for a given device, so as to make it
+ * accessible by its driver.
+ */
+void
+pci_restore_bars(struct pci_dev *dev)
+{
+	int i, numres;
+
+	switch (dev->hdr_type) {
+	case PCI_HEADER_TYPE_NORMAL:
+		numres = 6;
+		break;
+	case PCI_HEADER_TYPE_BRIDGE:
+		numres = 2;
+		break;
+	case PCI_HEADER_TYPE_CARDBUS:
+		numres = 1;
+		break;
+	default:
+		/* Should never get here, but just in case... */
+		return;
+	}
+
+	for (i = 0; i < numres; i ++)
+		pci_update_resource(dev, &dev->resource[i], i);
+}
+
 /**
  * pci_set_power_state - Set the power state of a PCI device
  * @dev: PCI device to be suspended
@@ -239,7 +270,7 @@ int (*platform_pci_set_power_state)(struct pci_dev *dev, pci_power_t t);
 int
 pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 {
-	int pm;
+	int pm, need_restore = 0;
 	u16 pmcsr, pmc;
 
 	/* bound the state we're entering */
@@ -278,14 +309,17 @@ pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 			return -EIO;
 	}
 
+	pci_read_config_word(dev, pm + PCI_PM_CTRL, &pmcsr);
+
 	/* If we're in D3, force entire word to 0.
 	 * This doesn't affect PME_Status, disables PME_En, and
 	 * sets PowerState to 0.
 	 */
-	if (dev->current_state >= PCI_D3hot)
+	if (dev->current_state >= PCI_D3hot) {
+		if (!(pmcsr & PCI_PM_CTRL_NO_SOFT_RESET))
+			need_restore = 1;
 		pmcsr = 0;
-	else {
-		pci_read_config_word(dev, pm + PCI_PM_CTRL, &pmcsr);
+	} else {
 		pmcsr &= ~PCI_PM_CTRL_STATE_MASK;
 		pmcsr |= state;
 	}
@@ -308,6 +342,22 @@ pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 		platform_pci_set_power_state(dev, state);
 
 	dev->current_state = state;
+
+	/* According to section 5.4.1 of the "PCI BUS POWER MANAGEMENT
+	 * INTERFACE SPECIFICATION, REV. 1.2", a device transitioning
+	 * from D3hot to D0 _may_ perform an internal reset, thereby
+	 * going to "D0 Uninitialized" rather than "D0 Initialized".
+	 * For example, at least some versions of the 3c905B and the
+	 * 3c556B exhibit this behaviour.
+	 *
+	 * At least some laptop BIOSen (e.g. the Thinkpad T21) leave
+	 * devices in a D3hot state at boot.  Consequently, we need to
+	 * restore at least the BARs so that the device will be
+	 * accessible to its driver.
+	 */
+	if (need_restore)
+		pci_restore_bars(dev);
+
 	return 0;
 }
 
@@ -809,6 +859,7 @@ struct pci_dev *isa_bridge;
 EXPORT_SYMBOL(isa_bridge);
 #endif
 
+EXPORT_SYMBOL_GPL(pci_restore_bars);
 EXPORT_SYMBOL(pci_enable_device_bars);
 EXPORT_SYMBOL(pci_enable_device);
 EXPORT_SYMBOL(pci_disable_device);

commit ca078bae813dd46c0f9b102fdfb4a3384641ff48
Author: Pavel Machek <pavel@ucw.cz>
Date:   Sat Sep 3 15:56:57 2005 -0700

    [PATCH] swsusp: switch pm_message_t to struct
    
    This adds type-checking to pm_message_t, so that people can't confuse it
    with int or u32.  It also allows us to fix "disk yoyo" during suspend (disk
    spinning down/up/down).
    
    [We've tried that before; since that cpufreq problems were fixed and I've
    tried make allyes config and fixed resulting damage.]
    
    Signed-off-by: Pavel Machek <pavel@suse.cz>
    Signed-off-by: Alexander Nyberg <alexn@telia.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 1b34fc56067e..c62d2f043397 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -333,13 +333,17 @@ pci_power_t pci_choose_state(struct pci_dev *dev, pm_message_t state)
 	if (platform_pci_choose_state) {
 		ret = platform_pci_choose_state(dev, state);
 		if (ret >= 0)
-			state = ret;
+			state.event = ret;
 	}
- 	switch (state) {
-	case 0: return PCI_D0;
-	case 3: return PCI_D3hot;
+
+	switch (state.event) {
+	case PM_EVENT_ON:
+		return PCI_D0;
+	case PM_EVENT_FREEZE:
+	case PM_EVENT_SUSPEND:
+		return PCI_D3hot;
 	default:
-		printk("They asked me for state %d\n", state);
+		printk("They asked me for state %d\n", state.event);
 		BUG();
 	}
 	return PCI_D0;

commit dc836b5b6fcde95f750a4790d8200fabaf563dc9
Author: Linus Torvalds <torvalds@g5.osdl.org>
Date:   Mon Aug 8 18:46:09 2005 -0700

    Revert "[PATCH] PCI: restore BAR values..."
    
    Revert commit fec59a711eef002d4ef9eb8de09dd0a26986eb77, which is
    breaking sparc64 that doesn't have a working pci_update_resource.
    
    We'll re-do this after 2.6.13 when we'll do it all properly.

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 65ea7d25f691..1b34fc56067e 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -221,37 +221,6 @@ pci_find_parent_resource(const struct pci_dev *dev, struct resource *res)
 	return best;
 }
 
-/**
- * pci_restore_bars - restore a devices BAR values (e.g. after wake-up)
- * @dev: PCI device to have its BARs restored
- *
- * Restore the BAR values for a given device, so as to make it
- * accessible by its driver.
- */
-void
-pci_restore_bars(struct pci_dev *dev)
-{
-	int i, numres;
-
-	switch (dev->hdr_type) {
-	case PCI_HEADER_TYPE_NORMAL:
-		numres = 6;
-		break;
-	case PCI_HEADER_TYPE_BRIDGE:
-		numres = 2;
-		break;
-	case PCI_HEADER_TYPE_CARDBUS:
-		numres = 1;
-		break;
-	default:
-		/* Should never get here, but just in case... */
-		return;
-	}
-
-	for (i = 0; i < numres; i ++)
-		pci_update_resource(dev, &dev->resource[i], i);
-}
-
 /**
  * pci_set_power_state - Set the power state of a PCI device
  * @dev: PCI device to be suspended
@@ -270,7 +239,7 @@ int (*platform_pci_set_power_state)(struct pci_dev *dev, pci_power_t t);
 int
 pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 {
-	int pm, need_restore = 0;
+	int pm;
 	u16 pmcsr, pmc;
 
 	/* bound the state we're entering */
@@ -309,17 +278,14 @@ pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 			return -EIO;
 	}
 
-	pci_read_config_word(dev, pm + PCI_PM_CTRL, &pmcsr);
-
 	/* If we're in D3, force entire word to 0.
 	 * This doesn't affect PME_Status, disables PME_En, and
 	 * sets PowerState to 0.
 	 */
-	if (dev->current_state >= PCI_D3hot) {
-		if (!(pmcsr & PCI_PM_CTRL_NO_SOFT_RESET))
-			need_restore = 1;
+	if (dev->current_state >= PCI_D3hot)
 		pmcsr = 0;
-	} else {
+	else {
+		pci_read_config_word(dev, pm + PCI_PM_CTRL, &pmcsr);
 		pmcsr &= ~PCI_PM_CTRL_STATE_MASK;
 		pmcsr |= state;
 	}
@@ -342,22 +308,6 @@ pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 		platform_pci_set_power_state(dev, state);
 
 	dev->current_state = state;
-
-	/* According to section 5.4.1 of the "PCI BUS POWER MANAGEMENT
-	 * INTERFACE SPECIFICATION, REV. 1.2", a device transitioning
-	 * from D3hot to D0 _may_ perform an internal reset, thereby
-	 * going to "D0 Uninitialized" rather than "D0 Initialized".
-	 * For example, at least some versions of the 3c905B and the
-	 * 3c556B exhibit this behaviour.
-	 *
-	 * At least some laptop BIOSen (e.g. the Thinkpad T21) leave
-	 * devices in a D3hot state at boot.  Consequently, we need to
-	 * restore at least the BARs so that the device will be
-	 * accessible to its driver.
-	 */
-	if (need_restore)
-		pci_restore_bars(dev);
-
 	return 0;
 }
 
@@ -855,7 +805,6 @@ struct pci_dev *isa_bridge;
 EXPORT_SYMBOL(isa_bridge);
 #endif
 
-EXPORT_SYMBOL_GPL(pci_restore_bars);
 EXPORT_SYMBOL(pci_enable_device_bars);
 EXPORT_SYMBOL(pci_enable_device);
 EXPORT_SYMBOL(pci_disable_device);

commit fec59a711eef002d4ef9eb8de09dd0a26986eb77
Author: John W. Linville <linville@tuxdriver.com>
Date:   Thu Aug 4 18:06:10 2005 -0700

    [PATCH] PCI: restore BAR values after D3hot->D0 for devices that need it
    
    Some PCI devices (e.g. 3c905B, 3c556B) lose all configuration
    (including BARs) when transitioning from D3hot->D0.  This leaves such
    a device in an inaccessible state.  The patch below causes the BARs
    to be restored when enabling such a device, so that its driver will
    be able to access it.
    
    The patch also adds pci_restore_bars as a new global symbol, and adds a
    correpsonding EXPORT_SYMBOL_GPL for that.
    
    Some firmware (e.g. Thinkpad T21) leaves devices in D3hot after a
    (re)boot.  Most drivers call pci_enable_device very early, so devices
    left in D3hot that lose configuration during the D3hot->D0 transition
    will be inaccessible to their drivers.
    
    Drivers could be modified to account for this, but it would
    be difficult to know which drivers need modification.  This is
    especially true since often many devices are covered by the same
    driver.  It likely would be necessary to replicate code across dozens
    of drivers.
    
    The patch below should trigger only when transitioning from D3hot->D0
    (or at boot), and only for devices that have the "no soft reset" bit
    cleared in the PM control register.  I believe it is safe to include
    this patch as part of the PCI infrastructure.
    
    The cleanest implementation of pci_restore_bars was to call
    pci_update_resource.  Unfortunately, that does not currently exist
    for the sparc64 architecture.  The patch below includes a null
    implemenation of pci_update_resource for sparc64.
    
    Some have expressed interest in making general use of the the
    pci_restore_bars function, so that has been exported to GPL licensed
    modules.
    
    Signed-off-by: John W. Linville <linville@tuxdriver.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 1b34fc56067e..65ea7d25f691 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -221,6 +221,37 @@ pci_find_parent_resource(const struct pci_dev *dev, struct resource *res)
 	return best;
 }
 
+/**
+ * pci_restore_bars - restore a devices BAR values (e.g. after wake-up)
+ * @dev: PCI device to have its BARs restored
+ *
+ * Restore the BAR values for a given device, so as to make it
+ * accessible by its driver.
+ */
+void
+pci_restore_bars(struct pci_dev *dev)
+{
+	int i, numres;
+
+	switch (dev->hdr_type) {
+	case PCI_HEADER_TYPE_NORMAL:
+		numres = 6;
+		break;
+	case PCI_HEADER_TYPE_BRIDGE:
+		numres = 2;
+		break;
+	case PCI_HEADER_TYPE_CARDBUS:
+		numres = 1;
+		break;
+	default:
+		/* Should never get here, but just in case... */
+		return;
+	}
+
+	for (i = 0; i < numres; i ++)
+		pci_update_resource(dev, &dev->resource[i], i);
+}
+
 /**
  * pci_set_power_state - Set the power state of a PCI device
  * @dev: PCI device to be suspended
@@ -239,7 +270,7 @@ int (*platform_pci_set_power_state)(struct pci_dev *dev, pci_power_t t);
 int
 pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 {
-	int pm;
+	int pm, need_restore = 0;
 	u16 pmcsr, pmc;
 
 	/* bound the state we're entering */
@@ -278,14 +309,17 @@ pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 			return -EIO;
 	}
 
+	pci_read_config_word(dev, pm + PCI_PM_CTRL, &pmcsr);
+
 	/* If we're in D3, force entire word to 0.
 	 * This doesn't affect PME_Status, disables PME_En, and
 	 * sets PowerState to 0.
 	 */
-	if (dev->current_state >= PCI_D3hot)
+	if (dev->current_state >= PCI_D3hot) {
+		if (!(pmcsr & PCI_PM_CTRL_NO_SOFT_RESET))
+			need_restore = 1;
 		pmcsr = 0;
-	else {
-		pci_read_config_word(dev, pm + PCI_PM_CTRL, &pmcsr);
+	} else {
 		pmcsr &= ~PCI_PM_CTRL_STATE_MASK;
 		pmcsr |= state;
 	}
@@ -308,6 +342,22 @@ pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 		platform_pci_set_power_state(dev, state);
 
 	dev->current_state = state;
+
+	/* According to section 5.4.1 of the "PCI BUS POWER MANAGEMENT
+	 * INTERFACE SPECIFICATION, REV. 1.2", a device transitioning
+	 * from D3hot to D0 _may_ perform an internal reset, thereby
+	 * going to "D0 Uninitialized" rather than "D0 Initialized".
+	 * For example, at least some versions of the 3c905B and the
+	 * 3c556B exhibit this behaviour.
+	 *
+	 * At least some laptop BIOSen (e.g. the Thinkpad T21) leave
+	 * devices in a D3hot state at boot.  Consequently, we need to
+	 * restore at least the BARs so that the device will be
+	 * accessible to its driver.
+	 */
+	if (need_restore)
+		pci_restore_bars(dev);
+
 	return 0;
 }
 
@@ -805,6 +855,7 @@ struct pci_dev *isa_bridge;
 EXPORT_SYMBOL(isa_bridge);
 #endif
 
+EXPORT_SYMBOL_GPL(pci_restore_bars);
 EXPORT_SYMBOL(pci_enable_device_bars);
 EXPORT_SYMBOL(pci_enable_device);
 EXPORT_SYMBOL(pci_disable_device);

commit 5028770a42e7bc4d15791a44c28f0ad539323807
Merge: 9f02d6b7b43d d8683a0cb5d0
Author: Len Brown <len.brown@intel.com>
Date:   Tue Jul 12 17:21:56 2005 -0400

    [ACPI] merge acpi-2.6.12 branch into latest Linux 2.6.13-rc...
    
    Signed-off-by: Len Brown <len.brown@intel.com>

commit f165b10f4a9aac7fee9b11a125de20a1712be128
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed Mar 30 21:23:19 2005 -0500

    cleanup: remove unnecessary initializer on static pointers
    
    Suggested-by: Greg KH <greg@kroah.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index a1c66e8ea5f2..bdfca32b44a1 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -235,7 +235,7 @@ pci_find_parent_resource(const struct pci_dev *dev, struct resource *res)
  * -EIO if device does not support PCI PM.
  * 0 if we can successfully change the power state.
  */
-int (*platform_pci_set_power_state)(struct pci_dev *dev, pci_power_t t) = NULL;
+int (*platform_pci_set_power_state)(struct pci_dev *dev, pci_power_t t);
 int
 pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 {
@@ -311,7 +311,7 @@ pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 	return 0;
 }
 
-int (*platform_pci_choose_state)(struct pci_dev *dev, pm_message_t state) = NULL;
+int (*platform_pci_choose_state)(struct pci_dev *dev, pm_message_t state);
  
 /**
  * pci_choose_state - Choose the power state of a PCI device

commit b913100d7304ea9596d8d85ab5f3ae04bd2b0ddb
Author: David Shaohua Li <shaohua.li@intel.com>
Date:   Sat Mar 19 00:16:18 2005 -0500

    [ACPI] pci_set_power_state() now calls
            platform_pci_set_power_state()
                    and ACPI can answer
    
    http://bugzilla.kernel.org/show_bug.cgi?id=4277
    
    Signed-off-by: David Shaohua Li <shaohua.li@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 5af941807785..a1c66e8ea5f2 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -235,7 +235,7 @@ pci_find_parent_resource(const struct pci_dev *dev, struct resource *res)
  * -EIO if device does not support PCI PM.
  * 0 if we can successfully change the power state.
  */
-
+int (*platform_pci_set_power_state)(struct pci_dev *dev, pci_power_t t) = NULL;
 int
 pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 {
@@ -299,8 +299,15 @@ pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 		msleep(10);
 	else if (state == PCI_D2 || dev->current_state == PCI_D2)
 		udelay(200);
-	dev->current_state = state;
 
+	/*
+	 * Give firmware a chance to be called, such as ACPI _PRx, _PSx
+	 * Firmware method after natice method ?
+	 */
+	if (platform_pci_set_power_state)
+		platform_pci_set_power_state(dev, state);
+
+	dev->current_state = state;
 	return 0;
 }
 

commit 0f64474b8f7f1f7f3af5b24ef997baa35f923509
Author: David Shaohua Li <shaohua.li@intel.com>
Date:   Sat Mar 19 00:15:48 2005 -0500

    [ACPI] PCI can now get suspend state from firmware
    
    pci_choose_state() can now call
            platform_pci_choose_state()
                    and ACPI can answer
    
    http://bugzilla.kernel.org/show_bug.cgi?id=4277
    
    Signed-off-by: David Shaohua Li <shaohua.li@intel.com>
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index f04b9ffe4153..5af941807785 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -304,6 +304,8 @@ pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 	return 0;
 }
 
+int (*platform_pci_choose_state)(struct pci_dev *dev, pm_message_t state) = NULL;
+ 
 /**
  * pci_choose_state - Choose the power state of a PCI device
  * @dev: PCI device to be suspended
@@ -316,10 +318,17 @@ pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 
 pci_power_t pci_choose_state(struct pci_dev *dev, pm_message_t state)
 {
+	int ret;
+
 	if (!pci_find_capability(dev, PCI_CAP_ID_PM))
 		return PCI_D0;
 
-	switch (state) {
+	if (platform_pci_choose_state) {
+		ret = platform_pci_choose_state(dev, state);
+		if (ret >= 0)
+			state = ret;
+	}
+ 	switch (state) {
 	case 0: return PCI_D0;
 	case 3: return PCI_D3hot;
 	default:

commit 5848f23d811acc1cb6c19a12e1341e0640a85d0e
Author: John W. Linville <linville@tuxdriver.com>
Date:   Fri Jul 1 14:07:28 2005 -0400

    [PATCH] pci: cleanup argument comments for pci_{save,restore}_state
    
    The buffer arguments have been removed from pci_{save,restore}_state.
    The comment blocks for those functions should reflect that.
    
    Signed-off-by: John W. Linville <linville@tuxdriver.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index f04b9ffe4153..d382bdb7b560 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -334,10 +334,6 @@ EXPORT_SYMBOL(pci_choose_state);
 /**
  * pci_save_state - save the PCI configuration space of a device before suspending
  * @dev: - PCI device that we're dealing with
- * @buffer: - buffer to hold config space context
- *
- * @buffer must be large enough to hold the entire PCI 2.2 config space 
- * (>= 64 bytes).
  */
 int
 pci_save_state(struct pci_dev *dev)
@@ -352,8 +348,6 @@ pci_save_state(struct pci_dev *dev)
 /** 
  * pci_restore_state - Restore the saved state of a PCI device
  * @dev: - PCI device that we're dealing with
- * @buffer: - saved PCI config space
- *
  */
 int 
 pci_restore_state(struct pci_dev *dev)

commit 9171078ab5a0bbb516029cfc61378e0350a7b30d
Author: Adrian Bunk <bunk@stusta.de>
Date:   Sun May 1 15:53:08 2005 +0200

    [PATCH] PCI: drivers/pci/pci.c: remove pci_dac_set_dma_mask
    
    pci_dac_set_dma_mask is currently completely unused.
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 88cbe5b5b3f3..f04b9ffe4153 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -748,17 +748,6 @@ pci_set_dma_mask(struct pci_dev *dev, u64 mask)
 	return 0;
 }
     
-int
-pci_dac_set_dma_mask(struct pci_dev *dev, u64 mask)
-{
-	if (!pci_dac_dma_supported(dev, mask))
-		return -EIO;
-
-	dev->dma_mask = mask;
-
-	return 0;
-}
-
 int
 pci_set_consistent_dma_mask(struct pci_dev *dev, u64 mask)
 {
@@ -821,7 +810,6 @@ EXPORT_SYMBOL(pci_set_master);
 EXPORT_SYMBOL(pci_set_mwi);
 EXPORT_SYMBOL(pci_clear_mwi);
 EXPORT_SYMBOL(pci_set_dma_mask);
-EXPORT_SYMBOL(pci_dac_set_dma_mask);
 EXPORT_SYMBOL(pci_set_consistent_dma_mask);
 EXPORT_SYMBOL(pci_assign_resource);
 EXPORT_SYMBOL(pci_find_parent_resource);

commit bc56b9e01190b9f1ad6b7c5c694b61bfe34c7aa5
Author: Greg KH <gregkh@suse.de>
Date:   Fri Apr 8 14:53:31 2005 +0900

    [PATCH] PCI: Clean up a lot of sparse "Should it be static?" warnings.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index fc8cc6c53778..88cbe5b5b3f3 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -16,6 +16,7 @@
 #include <linux/module.h>
 #include <linux/spinlock.h>
 #include <asm/dma.h>	/* isa_dma_bridge_buggy */
+#include "pci.h"
 
 
 /**

commit ceb43744cd48a20212e2179e0c7ff2f450a3c97e
Author: Kenji Kaneshige <kaneshige.kenji@soft.fujitsu.com>
Date:   Fri Apr 8 14:53:31 2005 +0900

    [PATCH] PCI: 'is_enabled' flag should be set/cleared when the device is actually enabled/disabled
    
    I think 'is_enabled' flag in pci_dev structure should be set/cleared
    when the device actually enabled/disabled. Especially about
    pci_enable_device(), it can be failed. By this change, we will also
    get the possibility of refering 'is_enabled' flag from the functions
    called through pci_enable_device()/pci_disable_device().
    
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index bfbff8335268..fc8cc6c53778 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -398,10 +398,10 @@ pci_enable_device(struct pci_dev *dev)
 {
 	int err;
 
-	dev->is_enabled = 1;
 	if ((err = pci_enable_device_bars(dev, (1 << PCI_NUM_RESOURCES) - 1)))
 		return err;
 	pci_fixup_device(pci_fixup_enable, dev);
+	dev->is_enabled = 1;
 	return 0;
 }
 
@@ -427,16 +427,15 @@ pci_disable_device(struct pci_dev *dev)
 {
 	u16 pci_command;
 	
-	dev->is_enabled = 0;
-	dev->is_busmaster = 0;
-
 	pci_read_config_word(dev, PCI_COMMAND, &pci_command);
 	if (pci_command & PCI_COMMAND_MASTER) {
 		pci_command &= ~PCI_COMMAND_MASTER;
 		pci_write_config_word(dev, PCI_COMMAND, pci_command);
 	}
+	dev->is_busmaster = 0;
 
 	pcibios_disable_device(dev);
+	dev->is_enabled = 0;
 }
 
 /**

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
new file mode 100644
index 000000000000..bfbff8335268
--- /dev/null
+++ b/drivers/pci/pci.c
@@ -0,0 +1,837 @@
+/*
+ *	$Id: pci.c,v 1.91 1999/01/21 13:34:01 davem Exp $
+ *
+ *	PCI Bus Services, see include/linux/pci.h for further explanation.
+ *
+ *	Copyright 1993 -- 1997 Drew Eckhardt, Frederic Potter,
+ *	David Mosberger-Tang
+ *
+ *	Copyright 1997 -- 2000 Martin Mares <mj@ucw.cz>
+ */
+
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/module.h>
+#include <linux/spinlock.h>
+#include <asm/dma.h>	/* isa_dma_bridge_buggy */
+
+
+/**
+ * pci_bus_max_busnr - returns maximum PCI bus number of given bus' children
+ * @bus: pointer to PCI bus structure to search
+ *
+ * Given a PCI bus, returns the highest PCI bus number present in the set
+ * including the given PCI bus and its list of child PCI buses.
+ */
+unsigned char __devinit
+pci_bus_max_busnr(struct pci_bus* bus)
+{
+	struct list_head *tmp;
+	unsigned char max, n;
+
+	max = bus->number;
+	list_for_each(tmp, &bus->children) {
+		n = pci_bus_max_busnr(pci_bus_b(tmp));
+		if(n > max)
+			max = n;
+	}
+	return max;
+}
+
+/**
+ * pci_max_busnr - returns maximum PCI bus number
+ *
+ * Returns the highest PCI bus number present in the system global list of
+ * PCI buses.
+ */
+unsigned char __devinit
+pci_max_busnr(void)
+{
+	struct pci_bus *bus = NULL;
+	unsigned char max, n;
+
+	max = 0;
+	while ((bus = pci_find_next_bus(bus)) != NULL) {
+		n = pci_bus_max_busnr(bus);
+		if(n > max)
+			max = n;
+	}
+	return max;
+}
+
+static int __pci_bus_find_cap(struct pci_bus *bus, unsigned int devfn, u8 hdr_type, int cap)
+{
+	u16 status;
+	u8 pos, id;
+	int ttl = 48;
+
+	pci_bus_read_config_word(bus, devfn, PCI_STATUS, &status);
+	if (!(status & PCI_STATUS_CAP_LIST))
+		return 0;
+
+	switch (hdr_type) {
+	case PCI_HEADER_TYPE_NORMAL:
+	case PCI_HEADER_TYPE_BRIDGE:
+		pci_bus_read_config_byte(bus, devfn, PCI_CAPABILITY_LIST, &pos);
+		break;
+	case PCI_HEADER_TYPE_CARDBUS:
+		pci_bus_read_config_byte(bus, devfn, PCI_CB_CAPABILITY_LIST, &pos);
+		break;
+	default:
+		return 0;
+	}
+	while (ttl-- && pos >= 0x40) {
+		pos &= ~3;
+		pci_bus_read_config_byte(bus, devfn, pos + PCI_CAP_LIST_ID, &id);
+		if (id == 0xff)
+			break;
+		if (id == cap)
+			return pos;
+		pci_bus_read_config_byte(bus, devfn, pos + PCI_CAP_LIST_NEXT, &pos);
+	}
+	return 0;
+}
+
+/**
+ * pci_find_capability - query for devices' capabilities 
+ * @dev: PCI device to query
+ * @cap: capability code
+ *
+ * Tell if a device supports a given PCI capability.
+ * Returns the address of the requested capability structure within the
+ * device's PCI configuration space or 0 in case the device does not
+ * support it.  Possible values for @cap:
+ *
+ *  %PCI_CAP_ID_PM           Power Management 
+ *  %PCI_CAP_ID_AGP          Accelerated Graphics Port 
+ *  %PCI_CAP_ID_VPD          Vital Product Data 
+ *  %PCI_CAP_ID_SLOTID       Slot Identification 
+ *  %PCI_CAP_ID_MSI          Message Signalled Interrupts
+ *  %PCI_CAP_ID_CHSWP        CompactPCI HotSwap 
+ *  %PCI_CAP_ID_PCIX         PCI-X
+ *  %PCI_CAP_ID_EXP          PCI Express
+ */
+int pci_find_capability(struct pci_dev *dev, int cap)
+{
+	return __pci_bus_find_cap(dev->bus, dev->devfn, dev->hdr_type, cap);
+}
+
+/**
+ * pci_bus_find_capability - query for devices' capabilities 
+ * @bus:   the PCI bus to query
+ * @devfn: PCI device to query
+ * @cap:   capability code
+ *
+ * Like pci_find_capability() but works for pci devices that do not have a
+ * pci_dev structure set up yet. 
+ *
+ * Returns the address of the requested capability structure within the
+ * device's PCI configuration space or 0 in case the device does not
+ * support it.
+ */
+int pci_bus_find_capability(struct pci_bus *bus, unsigned int devfn, int cap)
+{
+	u8 hdr_type;
+
+	pci_bus_read_config_byte(bus, devfn, PCI_HEADER_TYPE, &hdr_type);
+
+	return __pci_bus_find_cap(bus, devfn, hdr_type & 0x7f, cap);
+}
+
+/**
+ * pci_find_ext_capability - Find an extended capability
+ * @dev: PCI device to query
+ * @cap: capability code
+ *
+ * Returns the address of the requested extended capability structure
+ * within the device's PCI configuration space or 0 if the device does
+ * not support it.  Possible values for @cap:
+ *
+ *  %PCI_EXT_CAP_ID_ERR		Advanced Error Reporting
+ *  %PCI_EXT_CAP_ID_VC		Virtual Channel
+ *  %PCI_EXT_CAP_ID_DSN		Device Serial Number
+ *  %PCI_EXT_CAP_ID_PWR		Power Budgeting
+ */
+int pci_find_ext_capability(struct pci_dev *dev, int cap)
+{
+	u32 header;
+	int ttl = 480; /* 3840 bytes, minimum 8 bytes per capability */
+	int pos = 0x100;
+
+	if (dev->cfg_size <= 256)
+		return 0;
+
+	if (pci_read_config_dword(dev, pos, &header) != PCIBIOS_SUCCESSFUL)
+		return 0;
+
+	/*
+	 * If we have no capabilities, this is indicated by cap ID,
+	 * cap version and next pointer all being 0.
+	 */
+	if (header == 0)
+		return 0;
+
+	while (ttl-- > 0) {
+		if (PCI_EXT_CAP_ID(header) == cap)
+			return pos;
+
+		pos = PCI_EXT_CAP_NEXT(header);
+		if (pos < 0x100)
+			break;
+
+		if (pci_read_config_dword(dev, pos, &header) != PCIBIOS_SUCCESSFUL)
+			break;
+	}
+
+	return 0;
+}
+
+/**
+ * pci_find_parent_resource - return resource region of parent bus of given region
+ * @dev: PCI device structure contains resources to be searched
+ * @res: child resource record for which parent is sought
+ *
+ *  For given resource region of given device, return the resource
+ *  region of parent bus the given region is contained in or where
+ *  it should be allocated from.
+ */
+struct resource *
+pci_find_parent_resource(const struct pci_dev *dev, struct resource *res)
+{
+	const struct pci_bus *bus = dev->bus;
+	int i;
+	struct resource *best = NULL;
+
+	for(i = 0; i < PCI_BUS_NUM_RESOURCES; i++) {
+		struct resource *r = bus->resource[i];
+		if (!r)
+			continue;
+		if (res->start && !(res->start >= r->start && res->end <= r->end))
+			continue;	/* Not contained */
+		if ((res->flags ^ r->flags) & (IORESOURCE_IO | IORESOURCE_MEM))
+			continue;	/* Wrong type */
+		if (!((res->flags ^ r->flags) & IORESOURCE_PREFETCH))
+			return r;	/* Exact match */
+		if ((res->flags & IORESOURCE_PREFETCH) && !(r->flags & IORESOURCE_PREFETCH))
+			best = r;	/* Approximating prefetchable by non-prefetchable */
+	}
+	return best;
+}
+
+/**
+ * pci_set_power_state - Set the power state of a PCI device
+ * @dev: PCI device to be suspended
+ * @state: PCI power state (D0, D1, D2, D3hot, D3cold) we're entering
+ *
+ * Transition a device to a new power state, using the Power Management 
+ * Capabilities in the device's config space.
+ *
+ * RETURN VALUE: 
+ * -EINVAL if trying to enter a lower state than we're already in.
+ * 0 if we're already in the requested state.
+ * -EIO if device does not support PCI PM.
+ * 0 if we can successfully change the power state.
+ */
+
+int
+pci_set_power_state(struct pci_dev *dev, pci_power_t state)
+{
+	int pm;
+	u16 pmcsr, pmc;
+
+	/* bound the state we're entering */
+	if (state > PCI_D3hot)
+		state = PCI_D3hot;
+
+	/* Validate current state:
+	 * Can enter D0 from any state, but if we can only go deeper 
+	 * to sleep if we're already in a low power state
+	 */
+	if (state != PCI_D0 && dev->current_state > state)
+		return -EINVAL;
+	else if (dev->current_state == state) 
+		return 0;        /* we're already there */
+
+	/* find PCI PM capability in list */
+	pm = pci_find_capability(dev, PCI_CAP_ID_PM);
+	
+	/* abort if the device doesn't support PM capabilities */
+	if (!pm)
+		return -EIO; 
+
+	pci_read_config_word(dev,pm + PCI_PM_PMC,&pmc);
+	if ((pmc & PCI_PM_CAP_VER_MASK) > 2) {
+		printk(KERN_DEBUG
+		       "PCI: %s has unsupported PM cap regs version (%u)\n",
+		       pci_name(dev), pmc & PCI_PM_CAP_VER_MASK);
+		return -EIO;
+	}
+
+	/* check if this device supports the desired state */
+	if (state == PCI_D1 || state == PCI_D2) {
+		if (state == PCI_D1 && !(pmc & PCI_PM_CAP_D1))
+			return -EIO;
+		else if (state == PCI_D2 && !(pmc & PCI_PM_CAP_D2))
+			return -EIO;
+	}
+
+	/* If we're in D3, force entire word to 0.
+	 * This doesn't affect PME_Status, disables PME_En, and
+	 * sets PowerState to 0.
+	 */
+	if (dev->current_state >= PCI_D3hot)
+		pmcsr = 0;
+	else {
+		pci_read_config_word(dev, pm + PCI_PM_CTRL, &pmcsr);
+		pmcsr &= ~PCI_PM_CTRL_STATE_MASK;
+		pmcsr |= state;
+	}
+
+	/* enter specified state */
+	pci_write_config_word(dev, pm + PCI_PM_CTRL, pmcsr);
+
+	/* Mandatory power management transition delays */
+	/* see PCI PM 1.1 5.6.1 table 18 */
+	if (state == PCI_D3hot || dev->current_state == PCI_D3hot)
+		msleep(10);
+	else if (state == PCI_D2 || dev->current_state == PCI_D2)
+		udelay(200);
+	dev->current_state = state;
+
+	return 0;
+}
+
+/**
+ * pci_choose_state - Choose the power state of a PCI device
+ * @dev: PCI device to be suspended
+ * @state: target sleep state for the whole system. This is the value
+ *	that is passed to suspend() function.
+ *
+ * Returns PCI power state suitable for given device and given system
+ * message.
+ */
+
+pci_power_t pci_choose_state(struct pci_dev *dev, pm_message_t state)
+{
+	if (!pci_find_capability(dev, PCI_CAP_ID_PM))
+		return PCI_D0;
+
+	switch (state) {
+	case 0: return PCI_D0;
+	case 3: return PCI_D3hot;
+	default:
+		printk("They asked me for state %d\n", state);
+		BUG();
+	}
+	return PCI_D0;
+}
+
+EXPORT_SYMBOL(pci_choose_state);
+
+/**
+ * pci_save_state - save the PCI configuration space of a device before suspending
+ * @dev: - PCI device that we're dealing with
+ * @buffer: - buffer to hold config space context
+ *
+ * @buffer must be large enough to hold the entire PCI 2.2 config space 
+ * (>= 64 bytes).
+ */
+int
+pci_save_state(struct pci_dev *dev)
+{
+	int i;
+	/* XXX: 100% dword access ok here? */
+	for (i = 0; i < 16; i++)
+		pci_read_config_dword(dev, i * 4,&dev->saved_config_space[i]);
+	return 0;
+}
+
+/** 
+ * pci_restore_state - Restore the saved state of a PCI device
+ * @dev: - PCI device that we're dealing with
+ * @buffer: - saved PCI config space
+ *
+ */
+int 
+pci_restore_state(struct pci_dev *dev)
+{
+	int i;
+
+	for (i = 0; i < 16; i++)
+		pci_write_config_dword(dev,i * 4, dev->saved_config_space[i]);
+	return 0;
+}
+
+/**
+ * pci_enable_device_bars - Initialize some of a device for use
+ * @dev: PCI device to be initialized
+ * @bars: bitmask of BAR's that must be configured
+ *
+ *  Initialize device before it's used by a driver. Ask low-level code
+ *  to enable selected I/O and memory resources. Wake up the device if it 
+ *  was suspended. Beware, this function can fail.
+ */
+ 
+int
+pci_enable_device_bars(struct pci_dev *dev, int bars)
+{
+	int err;
+
+	pci_set_power_state(dev, PCI_D0);
+	if ((err = pcibios_enable_device(dev, bars)) < 0)
+		return err;
+	return 0;
+}
+
+/**
+ * pci_enable_device - Initialize device before it's used by a driver.
+ * @dev: PCI device to be initialized
+ *
+ *  Initialize device before it's used by a driver. Ask low-level code
+ *  to enable I/O and memory. Wake up the device if it was suspended.
+ *  Beware, this function can fail.
+ */
+int
+pci_enable_device(struct pci_dev *dev)
+{
+	int err;
+
+	dev->is_enabled = 1;
+	if ((err = pci_enable_device_bars(dev, (1 << PCI_NUM_RESOURCES) - 1)))
+		return err;
+	pci_fixup_device(pci_fixup_enable, dev);
+	return 0;
+}
+
+/**
+ * pcibios_disable_device - disable arch specific PCI resources for device dev
+ * @dev: the PCI device to disable
+ *
+ * Disables architecture specific PCI resources for the device. This
+ * is the default implementation. Architecture implementations can
+ * override this.
+ */
+void __attribute__ ((weak)) pcibios_disable_device (struct pci_dev *dev) {}
+
+/**
+ * pci_disable_device - Disable PCI device after use
+ * @dev: PCI device to be disabled
+ *
+ * Signal to the system that the PCI device is not in use by the system
+ * anymore.  This only involves disabling PCI bus-mastering, if active.
+ */
+void
+pci_disable_device(struct pci_dev *dev)
+{
+	u16 pci_command;
+	
+	dev->is_enabled = 0;
+	dev->is_busmaster = 0;
+
+	pci_read_config_word(dev, PCI_COMMAND, &pci_command);
+	if (pci_command & PCI_COMMAND_MASTER) {
+		pci_command &= ~PCI_COMMAND_MASTER;
+		pci_write_config_word(dev, PCI_COMMAND, pci_command);
+	}
+
+	pcibios_disable_device(dev);
+}
+
+/**
+ * pci_enable_wake - enable device to generate PME# when suspended
+ * @dev: - PCI device to operate on
+ * @state: - Current state of device.
+ * @enable: - Flag to enable or disable generation
+ * 
+ * Set the bits in the device's PM Capabilities to generate PME# when
+ * the system is suspended. 
+ *
+ * -EIO is returned if device doesn't have PM Capabilities. 
+ * -EINVAL is returned if device supports it, but can't generate wake events.
+ * 0 if operation is successful.
+ * 
+ */
+int pci_enable_wake(struct pci_dev *dev, pci_power_t state, int enable)
+{
+	int pm;
+	u16 value;
+
+	/* find PCI PM capability in list */
+	pm = pci_find_capability(dev, PCI_CAP_ID_PM);
+
+	/* If device doesn't support PM Capabilities, but request is to disable
+	 * wake events, it's a nop; otherwise fail */
+	if (!pm) 
+		return enable ? -EIO : 0; 
+
+	/* Check device's ability to generate PME# */
+	pci_read_config_word(dev,pm+PCI_PM_PMC,&value);
+
+	value &= PCI_PM_CAP_PME_MASK;
+	value >>= ffs(PCI_PM_CAP_PME_MASK) - 1;   /* First bit of mask */
+
+	/* Check if it can generate PME# from requested state. */
+	if (!value || !(value & (1 << state))) 
+		return enable ? -EINVAL : 0;
+
+	pci_read_config_word(dev, pm + PCI_PM_CTRL, &value);
+
+	/* Clear PME_Status by writing 1 to it and enable PME# */
+	value |= PCI_PM_CTRL_PME_STATUS | PCI_PM_CTRL_PME_ENABLE;
+
+	if (!enable)
+		value &= ~PCI_PM_CTRL_PME_ENABLE;
+
+	pci_write_config_word(dev, pm + PCI_PM_CTRL, value);
+	
+	return 0;
+}
+
+int
+pci_get_interrupt_pin(struct pci_dev *dev, struct pci_dev **bridge)
+{
+	u8 pin;
+
+	pci_read_config_byte(dev, PCI_INTERRUPT_PIN, &pin);
+	if (!pin)
+		return -1;
+	pin--;
+	while (dev->bus->self) {
+		pin = (pin + PCI_SLOT(dev->devfn)) % 4;
+		dev = dev->bus->self;
+	}
+	*bridge = dev;
+	return pin;
+}
+
+/**
+ *	pci_release_region - Release a PCI bar
+ *	@pdev: PCI device whose resources were previously reserved by pci_request_region
+ *	@bar: BAR to release
+ *
+ *	Releases the PCI I/O and memory resources previously reserved by a
+ *	successful call to pci_request_region.  Call this function only
+ *	after all use of the PCI regions has ceased.
+ */
+void pci_release_region(struct pci_dev *pdev, int bar)
+{
+	if (pci_resource_len(pdev, bar) == 0)
+		return;
+	if (pci_resource_flags(pdev, bar) & IORESOURCE_IO)
+		release_region(pci_resource_start(pdev, bar),
+				pci_resource_len(pdev, bar));
+	else if (pci_resource_flags(pdev, bar) & IORESOURCE_MEM)
+		release_mem_region(pci_resource_start(pdev, bar),
+				pci_resource_len(pdev, bar));
+}
+
+/**
+ *	pci_request_region - Reserved PCI I/O and memory resource
+ *	@pdev: PCI device whose resources are to be reserved
+ *	@bar: BAR to be reserved
+ *	@res_name: Name to be associated with resource.
+ *
+ *	Mark the PCI region associated with PCI device @pdev BR @bar as
+ *	being reserved by owner @res_name.  Do not access any
+ *	address inside the PCI regions unless this call returns
+ *	successfully.
+ *
+ *	Returns 0 on success, or %EBUSY on error.  A warning
+ *	message is also printed on failure.
+ */
+int pci_request_region(struct pci_dev *pdev, int bar, char *res_name)
+{
+	if (pci_resource_len(pdev, bar) == 0)
+		return 0;
+		
+	if (pci_resource_flags(pdev, bar) & IORESOURCE_IO) {
+		if (!request_region(pci_resource_start(pdev, bar),
+			    pci_resource_len(pdev, bar), res_name))
+			goto err_out;
+	}
+	else if (pci_resource_flags(pdev, bar) & IORESOURCE_MEM) {
+		if (!request_mem_region(pci_resource_start(pdev, bar),
+				        pci_resource_len(pdev, bar), res_name))
+			goto err_out;
+	}
+	
+	return 0;
+
+err_out:
+	printk (KERN_WARNING "PCI: Unable to reserve %s region #%d:%lx@%lx for device %s\n",
+		pci_resource_flags(pdev, bar) & IORESOURCE_IO ? "I/O" : "mem",
+		bar + 1, /* PCI BAR # */
+		pci_resource_len(pdev, bar), pci_resource_start(pdev, bar),
+		pci_name(pdev));
+	return -EBUSY;
+}
+
+
+/**
+ *	pci_release_regions - Release reserved PCI I/O and memory resources
+ *	@pdev: PCI device whose resources were previously reserved by pci_request_regions
+ *
+ *	Releases all PCI I/O and memory resources previously reserved by a
+ *	successful call to pci_request_regions.  Call this function only
+ *	after all use of the PCI regions has ceased.
+ */
+
+void pci_release_regions(struct pci_dev *pdev)
+{
+	int i;
+	
+	for (i = 0; i < 6; i++)
+		pci_release_region(pdev, i);
+}
+
+/**
+ *	pci_request_regions - Reserved PCI I/O and memory resources
+ *	@pdev: PCI device whose resources are to be reserved
+ *	@res_name: Name to be associated with resource.
+ *
+ *	Mark all PCI regions associated with PCI device @pdev as
+ *	being reserved by owner @res_name.  Do not access any
+ *	address inside the PCI regions unless this call returns
+ *	successfully.
+ *
+ *	Returns 0 on success, or %EBUSY on error.  A warning
+ *	message is also printed on failure.
+ */
+int pci_request_regions(struct pci_dev *pdev, char *res_name)
+{
+	int i;
+	
+	for (i = 0; i < 6; i++)
+		if(pci_request_region(pdev, i, res_name))
+			goto err_out;
+	return 0;
+
+err_out:
+	while(--i >= 0)
+		pci_release_region(pdev, i);
+		
+	return -EBUSY;
+}
+
+/**
+ * pci_set_master - enables bus-mastering for device dev
+ * @dev: the PCI device to enable
+ *
+ * Enables bus-mastering on the device and calls pcibios_set_master()
+ * to do the needed arch specific settings.
+ */
+void
+pci_set_master(struct pci_dev *dev)
+{
+	u16 cmd;
+
+	pci_read_config_word(dev, PCI_COMMAND, &cmd);
+	if (! (cmd & PCI_COMMAND_MASTER)) {
+		pr_debug("PCI: Enabling bus mastering for device %s\n", pci_name(dev));
+		cmd |= PCI_COMMAND_MASTER;
+		pci_write_config_word(dev, PCI_COMMAND, cmd);
+	}
+	dev->is_busmaster = 1;
+	pcibios_set_master(dev);
+}
+
+#ifndef HAVE_ARCH_PCI_MWI
+/* This can be overridden by arch code. */
+u8 pci_cache_line_size = L1_CACHE_BYTES >> 2;
+
+/**
+ * pci_generic_prep_mwi - helper function for pci_set_mwi
+ * @dev: the PCI device for which MWI is enabled
+ *
+ * Helper function for generic implementation of pcibios_prep_mwi
+ * function.  Originally copied from drivers/net/acenic.c.
+ * Copyright 1998-2001 by Jes Sorensen, <jes@trained-monkey.org>.
+ *
+ * RETURNS: An appropriate -ERRNO error value on error, or zero for success.
+ */
+static int
+pci_generic_prep_mwi(struct pci_dev *dev)
+{
+	u8 cacheline_size;
+
+	if (!pci_cache_line_size)
+		return -EINVAL;		/* The system doesn't support MWI. */
+
+	/* Validate current setting: the PCI_CACHE_LINE_SIZE must be
+	   equal to or multiple of the right value. */
+	pci_read_config_byte(dev, PCI_CACHE_LINE_SIZE, &cacheline_size);
+	if (cacheline_size >= pci_cache_line_size &&
+	    (cacheline_size % pci_cache_line_size) == 0)
+		return 0;
+
+	/* Write the correct value. */
+	pci_write_config_byte(dev, PCI_CACHE_LINE_SIZE, pci_cache_line_size);
+	/* Read it back. */
+	pci_read_config_byte(dev, PCI_CACHE_LINE_SIZE, &cacheline_size);
+	if (cacheline_size == pci_cache_line_size)
+		return 0;
+
+	printk(KERN_DEBUG "PCI: cache line size of %d is not supported "
+	       "by device %s\n", pci_cache_line_size << 2, pci_name(dev));
+
+	return -EINVAL;
+}
+#endif /* !HAVE_ARCH_PCI_MWI */
+
+/**
+ * pci_set_mwi - enables memory-write-invalidate PCI transaction
+ * @dev: the PCI device for which MWI is enabled
+ *
+ * Enables the Memory-Write-Invalidate transaction in %PCI_COMMAND,
+ * and then calls @pcibios_set_mwi to do the needed arch specific
+ * operations or a generic mwi-prep function.
+ *
+ * RETURNS: An appropriate -ERRNO error value on error, or zero for success.
+ */
+int
+pci_set_mwi(struct pci_dev *dev)
+{
+	int rc;
+	u16 cmd;
+
+#ifdef HAVE_ARCH_PCI_MWI
+	rc = pcibios_prep_mwi(dev);
+#else
+	rc = pci_generic_prep_mwi(dev);
+#endif
+
+	if (rc)
+		return rc;
+
+	pci_read_config_word(dev, PCI_COMMAND, &cmd);
+	if (! (cmd & PCI_COMMAND_INVALIDATE)) {
+		pr_debug("PCI: Enabling Mem-Wr-Inval for device %s\n", pci_name(dev));
+		cmd |= PCI_COMMAND_INVALIDATE;
+		pci_write_config_word(dev, PCI_COMMAND, cmd);
+	}
+	
+	return 0;
+}
+
+/**
+ * pci_clear_mwi - disables Memory-Write-Invalidate for device dev
+ * @dev: the PCI device to disable
+ *
+ * Disables PCI Memory-Write-Invalidate transaction on the device
+ */
+void
+pci_clear_mwi(struct pci_dev *dev)
+{
+	u16 cmd;
+
+	pci_read_config_word(dev, PCI_COMMAND, &cmd);
+	if (cmd & PCI_COMMAND_INVALIDATE) {
+		cmd &= ~PCI_COMMAND_INVALIDATE;
+		pci_write_config_word(dev, PCI_COMMAND, cmd);
+	}
+}
+
+#ifndef HAVE_ARCH_PCI_SET_DMA_MASK
+/*
+ * These can be overridden by arch-specific implementations
+ */
+int
+pci_set_dma_mask(struct pci_dev *dev, u64 mask)
+{
+	if (!pci_dma_supported(dev, mask))
+		return -EIO;
+
+	dev->dma_mask = mask;
+
+	return 0;
+}
+    
+int
+pci_dac_set_dma_mask(struct pci_dev *dev, u64 mask)
+{
+	if (!pci_dac_dma_supported(dev, mask))
+		return -EIO;
+
+	dev->dma_mask = mask;
+
+	return 0;
+}
+
+int
+pci_set_consistent_dma_mask(struct pci_dev *dev, u64 mask)
+{
+	if (!pci_dma_supported(dev, mask))
+		return -EIO;
+
+	dev->dev.coherent_dma_mask = mask;
+
+	return 0;
+}
+#endif
+     
+static int __devinit pci_init(void)
+{
+	struct pci_dev *dev = NULL;
+
+	while ((dev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, dev)) != NULL) {
+		pci_fixup_device(pci_fixup_final, dev);
+	}
+	return 0;
+}
+
+static int __devinit pci_setup(char *str)
+{
+	while (str) {
+		char *k = strchr(str, ',');
+		if (k)
+			*k++ = 0;
+		if (*str && (str = pcibios_setup(str)) && *str) {
+			/* PCI layer options should be handled here */
+			printk(KERN_ERR "PCI: Unknown option `%s'\n", str);
+		}
+		str = k;
+	}
+	return 1;
+}
+
+device_initcall(pci_init);
+
+__setup("pci=", pci_setup);
+
+#if defined(CONFIG_ISA) || defined(CONFIG_EISA)
+/* FIXME: Some boxes have multiple ISA bridges! */
+struct pci_dev *isa_bridge;
+EXPORT_SYMBOL(isa_bridge);
+#endif
+
+EXPORT_SYMBOL(pci_enable_device_bars);
+EXPORT_SYMBOL(pci_enable_device);
+EXPORT_SYMBOL(pci_disable_device);
+EXPORT_SYMBOL(pci_max_busnr);
+EXPORT_SYMBOL(pci_bus_max_busnr);
+EXPORT_SYMBOL(pci_find_capability);
+EXPORT_SYMBOL(pci_bus_find_capability);
+EXPORT_SYMBOL(pci_release_regions);
+EXPORT_SYMBOL(pci_request_regions);
+EXPORT_SYMBOL(pci_release_region);
+EXPORT_SYMBOL(pci_request_region);
+EXPORT_SYMBOL(pci_set_master);
+EXPORT_SYMBOL(pci_set_mwi);
+EXPORT_SYMBOL(pci_clear_mwi);
+EXPORT_SYMBOL(pci_set_dma_mask);
+EXPORT_SYMBOL(pci_dac_set_dma_mask);
+EXPORT_SYMBOL(pci_set_consistent_dma_mask);
+EXPORT_SYMBOL(pci_assign_resource);
+EXPORT_SYMBOL(pci_find_parent_resource);
+
+EXPORT_SYMBOL(pci_set_power_state);
+EXPORT_SYMBOL(pci_save_state);
+EXPORT_SYMBOL(pci_restore_state);
+EXPORT_SYMBOL(pci_enable_wake);
+
+/* Quirk info */
+
+EXPORT_SYMBOL(isa_dma_bridge_buggy);
+EXPORT_SYMBOL(pci_pci_problems);
