commit e07515563d010d8b32967634e8dc2fdc732c1aa6
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Apr 18 18:53:01 2020 +0200

    PM: sleep: core: Rename DPM_FLAG_NEVER_SKIP
    
    Rename DPM_FLAG_NEVER_SKIP to DPM_FLAG_NO_DIRECT_COMPLETE which
    matches its purpose more closely.
    
    No functional impact.
    
    Suggested-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com> # for PCI parts
    Acked-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index 160d67c59310..3acf151ae015 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -115,7 +115,7 @@ static int pcie_portdrv_probe(struct pci_dev *dev,
 
 	pci_save_state(dev);
 
-	dev_pm_set_driver_flags(&dev->dev, DPM_FLAG_NEVER_SKIP |
+	dev_pm_set_driver_flags(&dev->dev, DPM_FLAG_NO_DIRECT_COMPLETE |
 					   DPM_FLAG_SMART_SUSPEND);
 
 	if (pci_bridge_d3_possible(dev)) {

commit 35a0b2378c199d4f26e458b2ca38ea56aaf2d9b8
Author: Olof Johansson <olof@lixom.net>
Date:   Wed Oct 23 12:22:05 2019 -0700

    PCI/DPC: Add "pcie_ports=dpc-native" to allow DPC without AER control
    
    Prior to eed85ff4c0da7 ("PCI/DPC: Enable DPC only if AER is available"),
    Linux handled DPC events regardless of whether firmware had granted it
    ownership of AER or DPC, e.g., via _OSC.
    
    PCIe r5.0, sec 6.2.10, recommends that the OS link control of DPC to
    control of AER, so after eed85ff4c0da7, Linux handles DPC events only if it
    has control of AER.
    
    On platforms that do not grant OS control of AER via _OSC, Linux DPC
    handling worked before eed85ff4c0da7 but not after.
    
    To make Linux DPC handling work on those platforms the same way they did
    before, add a "pcie_ports=dpc-native" kernel parameter that makes Linux
    handle DPC events regardless of whether it has control of AER.
    
    [bhelgaas: commit log, move pcie_ports_dpc_native to drivers/pci/]
    Link: https://lore.kernel.org/r/20191023192205.97024-1-olof@lixom.net
    Signed-off-by: Olof Johansson <olof@lixom.net>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index 0a87091a0800..160d67c59310 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -29,12 +29,20 @@ bool pcie_ports_disabled;
  */
 bool pcie_ports_native;
 
+/*
+ * If the user specified "pcie_ports=dpc-native", use the Linux DPC PCIe
+ * service even if the platform hasn't given us permission.
+ */
+bool pcie_ports_dpc_native;
+
 static int __init pcie_port_setup(char *str)
 {
 	if (!strncmp(str, "compat", 6))
 		pcie_ports_disabled = true;
 	else if (!strncmp(str, "native", 6))
 		pcie_ports_native = true;
+	else if (!strncmp(str, "dpc-native", 10))
+		pcie_ports_dpc_native = true;
 
 	return 1;
 }

commit e8303bb7a75c113388badcc49b2a84b4121c1b3e
Author: Alexandru Gagniuc <mr.nuke.me@gmail.com>
Date:   Wed Feb 27 14:58:17 2019 -0600

    PCI/LINK: Report degraded links via link bandwidth notification
    
    A warning is generated when a PCIe device is probed with a degraded link,
    but there was no similar mechanism to warn when the link becomes degraded
    after probing.  The Link Bandwidth Notification provides this mechanism.
    
    Use the Link Bandwidth Management Interrupt to detect bandwidth changes,
    and rescan the bandwidth, looking for the weakest point.  This is the same
    logic used in probe().
    
    Signed-off-by: Alexandru Gagniuc <mr.nuke.me@gmail.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Lukas Wunner <lukas@wunner.de>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index 99d2abe88d0b..0a87091a0800 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -240,6 +240,7 @@ static void __init pcie_init_services(void)
 	pcie_pme_init();
 	pcie_dpc_init();
 	pcie_hp_init();
+	pcie_bandwidth_notification_init();
 }
 
 static int __init pcie_portdrv_init(void)

commit f0cfecea8d1e8e0cd5d5053f9452b3a450f49eb5
Author: Honghui Zhang <honghui.zhang@mediatek.com>
Date:   Thu Feb 14 13:21:17 2019 +0800

    PCI/portdrv: Support PCIe services on subtractive decode bridges
    
    The Class Code for subtractive decode PCI-to-PCI bridge is 060401h; add an
    entry to make portdrv support this type of bridge.  This allows use of PCIe
    services on subtractive decode ports.
    
    Signed-off-by: Honghui Zhang <honghui.zhang@mediatek.com>
    [bhelgaas: add braces surrounding entry]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index a289e734b9a4..99d2abe88d0b 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -185,6 +185,8 @@ static void pcie_portdrv_err_resume(struct pci_dev *dev)
 static const struct pci_device_id port_pci_ids[] = {
 	/* handle any PCI-Express port */
 	{ PCI_DEVICE_CLASS(((PCI_CLASS_BRIDGE_PCI << 8) | 0x00), ~0) },
+	/* subtractive decode PCI-to-PCI bridge, class type is 060401h */
+	{ PCI_DEVICE_CLASS(((PCI_CLASS_BRIDGE_PCI << 8) | 0x01), ~0) },
 	{ },
 };
 

commit c89f7f98c971e0cabc819b6c0fe6bf509287b7e0
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Feb 15 13:49:18 2019 -0600

    PCI/portdrv: Use conventional Device ID table formatting
    
    The pci_device_id table was technically correct, but unusually formatted,
    which made adding entries error-prone.  Change the format so it's obvious
    how to add entries.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index 0acca3596807..a289e734b9a4 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -182,10 +182,10 @@ static void pcie_portdrv_err_resume(struct pci_dev *dev)
 /*
  * LINUX Device Driver Model
  */
-static const struct pci_device_id port_pci_ids[] = { {
+static const struct pci_device_id port_pci_ids[] = {
 	/* handle any PCI-Express port */
-	PCI_DEVICE_CLASS(((PCI_CLASS_BRIDGE_PCI << 8) | 0x00), ~0),
-	}, { /* end: all zeroes */ }
+	{ PCI_DEVICE_CLASS(((PCI_CLASS_BRIDGE_PCI << 8) | 0x00), ~0) },
+	{ },
 };
 
 static const struct pci_error_handlers pcie_portdrv_err_handler = {

commit 94c7993fb5bd1e3c20f67a2d24ba05bbdc938340
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Thu Sep 27 16:41:48 2018 -0500

    PCI/portdrv: Add runtime PM hooks for port service drivers
    
    When PCIe port is runtime suspended/resumed some extra steps might be
    needed to be executed from the port service driver side. For instance we
    may need to disable PCIe hotplug interrupt to prevent it from triggering
    immediately when PCIe link to the downstream component goes down.
    
    To make the above possible add optional ->runtime_suspend() and
    ->runtime_resume() callbacks to struct pcie_port_service_driver and call
    them for each port service in runtime suspend/resume callbacks of portdrv.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    [bhelgaas: adjust "slot->state" for 5790a9c78e78 ("PCI: pciehp: Unify
    controller and slot structs")]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index a1379151c565..0acca3596807 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -45,12 +45,10 @@ __setup("pcie_ports=", pcie_port_setup);
 #ifdef CONFIG_PM
 static int pcie_port_runtime_suspend(struct device *dev)
 {
-	return to_pci_dev(dev)->bridge_d3 ? 0 : -EBUSY;
-}
+	if (!to_pci_dev(dev)->bridge_d3)
+		return -EBUSY;
 
-static int pcie_port_runtime_resume(struct device *dev)
-{
-	return 0;
+	return pcie_port_device_runtime_suspend(dev);
 }
 
 static int pcie_port_runtime_idle(struct device *dev)
@@ -73,7 +71,7 @@ static const struct dev_pm_ops pcie_portdrv_pm_ops = {
 	.restore_noirq	= pcie_port_device_resume_noirq,
 	.restore	= pcie_port_device_resume,
 	.runtime_suspend = pcie_port_runtime_suspend,
-	.runtime_resume	= pcie_port_runtime_resume,
+	.runtime_resume	= pcie_port_device_runtime_resume,
 	.runtime_idle	= pcie_port_runtime_idle,
 };
 

commit 52be9464aa7edeeda35f7faecb162412ddb47e94
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Thu Sep 27 16:41:47 2018 -0500

    PCI/portdrv: Resume upon exit from system suspend if left runtime suspended
    
    Currently we try to keep PCIe ports runtime suspended over system suspend
    if possible. This mostly happens when entering suspend-to-idle because
    there is no need to re-configure wake settings.
    
    This causes problems if the parent port goes into D3cold and it gets
    resumed upon exit from system suspend. This may happen for example if the
    port is part of PCIe switch and the same switch is connected to a PCIe
    endpoint that needs to be resumed. The way exit from D3cold works according
    PCIe 4.0 spec 5.3.1.4.2 is that power is restored and cold reset is
    signaled. After this the device is in D0unitialized state keeping PME
    context if it supports wake from D3cold.
    
    The problem occurs when a PCIe hotplug port is left suspended and the
    parent port goes into D3cold and back to D0: the port keeps its PME context
    but since everything else is reset back to defaults (D0unitialized) it is
    not set to detect hotplug events anymore.
    
    For this reason change the PCIe portdrv power management logic so that it
    is fine to keep the port runtime suspended over system suspend but it needs
    to be resumed upon exit to make sure it gets properly re-initialized.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index 17256733fa43..a1379151c565 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -109,8 +109,8 @@ static int pcie_portdrv_probe(struct pci_dev *dev,
 
 	pci_save_state(dev);
 
-	dev_pm_set_driver_flags(&dev->dev, DPM_FLAG_SMART_SUSPEND |
-					   DPM_FLAG_LEAVE_SUSPENDED);
+	dev_pm_set_driver_flags(&dev->dev, DPM_FLAG_NEVER_SKIP |
+					   DPM_FLAG_SMART_SUSPEND);
 
 	if (pci_bridge_d3_possible(dev)) {
 		/*

commit 874b3251113a1e2cbe79c24994dc03fe4fe4b99b
Author: Keith Busch <keith.busch@intel.com>
Date:   Thu Sep 20 10:27:07 2018 -0600

    PCI: portdrv: Restore PCI config state on slot reset
    
    The port's config space may be cleared after a link reset, which wipes out
    the bridge's bus and memory windows.  Restore the config space that was
    saved during probe so we can access downstream devices.
    
    Signed-off-by: Keith Busch <keith.busch@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Sinan Kaya <okaya@kernel.org>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index 23a5a0c2c3fe..17256733fa43 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -146,6 +146,13 @@ static pci_ers_result_t pcie_portdrv_error_detected(struct pci_dev *dev,
 	return PCI_ERS_RESULT_CAN_RECOVER;
 }
 
+static pci_ers_result_t pcie_portdrv_slot_reset(struct pci_dev *dev)
+{
+	pci_restore_state(dev);
+	pci_save_state(dev);
+	return PCI_ERS_RESULT_RECOVERED;
+}
+
 static pci_ers_result_t pcie_portdrv_mmio_enabled(struct pci_dev *dev)
 {
 	return PCI_ERS_RESULT_RECOVERED;
@@ -185,6 +192,7 @@ static const struct pci_device_id port_pci_ids[] = { {
 
 static const struct pci_error_handlers pcie_portdrv_err_handler = {
 	.error_detected = pcie_portdrv_error_detected,
+	.slot_reset = pcie_portdrv_slot_reset,
 	.mmio_enabled = pcie_portdrv_mmio_enabled,
 	.resume = pcie_portdrv_err_resume,
 };

commit c29de84149aba5f74e87b6491c13ac7203c12f55
Author: Keith Busch <keith.busch@intel.com>
Date:   Thu Sep 20 10:27:06 2018 -0600

    PCI: portdrv: Initialize service drivers directly
    
    The PCI port driver saves the PCI state after initializing the device with
    the applicable service devices.  This was, however, before the service
    drivers were even registered because PCI probe happens before the
    device_initcall initialized those service drivers.  The config space state
    that the services set up were not being saved.  The end result would cause
    PCI devices to not react to events that the drivers think they did if the
    PCI state ever needed to be restored.
    
    Fix this by changing the service drivers from using the init calls to
    having the portdrv driver calling the services directly.  This will get the
    state saved as desired, while making the relationship between the port
    driver and the services under it more explicit in the code.
    
    Signed-off-by: Keith Busch <keith.busch@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Sinan Kaya <okaya@kernel.org>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index eef22dc29140..23a5a0c2c3fe 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -226,11 +226,20 @@ static const struct dmi_system_id pcie_portdrv_dmi_table[] __initconst = {
 	 {}
 };
 
+static void __init pcie_init_services(void)
+{
+	pcie_aer_init();
+	pcie_pme_init();
+	pcie_dpc_init();
+	pcie_hp_init();
+}
+
 static int __init pcie_portdrv_init(void)
 {
 	if (pcie_ports_disabled)
 		return -EACCES;
 
+	pcie_init_services();
 	dmi_check_system(pcie_portdrv_dmi_table);
 
 	return pci_register_driver(&pcie_portdriver);

commit c0638a455382e01e42bf66d8d41e4b703f1550a5
Merge: a8bcb5e5966c 4e6a13356f1c
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Aug 15 14:58:52 2018 -0500

    Merge branch 'pci/hotplug'
    
      - Simplify SHPC existence/permission checks (Bjorn Helgaas)
    
      - Remove hotplug sample skeleton driver (Lukas Wunner)
    
      - Convert pciehp to threaded IRQ handling (Lukas Wunner)
    
      - Improve pciehp tolerance of missed events and initially unstable links
        (Lukas Wunner)
    
      - Clear spurious pciehp events on resume (Lukas Wunner)
    
      - Add pciehp runtime PM support, including for Thunderbolt controllers
        (Lukas Wunner)
    
      - Support interrupts from pciehp bridges in D3hot (Lukas Wunner)
    
    * pci/hotplug:
      PCI: pciehp: Deduplicate presence check on probe & resume
      PCI: pciehp: Avoid implicit fallthroughs in switch statements
      PCI: Whitelist Thunderbolt ports for runtime D3
      PCI: Whitelist native hotplug ports for runtime D3
      PCI: sysfs: Resume to D0 on function reset
      PCI: pciehp: Resume parent to D0 on config space access
      PCI: pciehp: Resume to D0 on enable/disable
      PCI: pciehp: Support interrupts sent from D3hot
      PCI: pciehp: Obey compulsory command delay after resume
      PCI: pciehp: Clear spurious events earlier on resume
      PCI: portdrv: Deduplicate PM callback iterator
      PCI: pciehp: Avoid slot access during reset
      PCI: pciehp: Always enable occupied slot on probe
      PCI: pciehp: Become resilient to missed events
      PCI: pciehp: Tolerate initially unstable link
      PCI: pciehp: Declare pciehp_enable/disable_slot() static
      PCI: pciehp: Drop enable/disable lock
      PCI: pciehp: Enable/disable exclusively from IRQ thread
      PCI: pciehp: Track enable/disable status
      PCI: pciehp: Publish to user space last on probe
      PCI: hotplug: Demidlayer registration with the core
      PCI: pciehp: Drop slot workqueue
      PCI: pciehp: Handle events synchronously
      PCI: pciehp: Stop blinking on slot enable failure
      PCI: pciehp: Convert to threaded polling
      PCI: pciehp: Convert to threaded IRQ
      PCI: pciehp: Document struct slot and struct controller
      PCI: pciehp: Declare pciehp_unconfigure_device() void
      PCI: pciehp: Drop unnecessary NULL pointer check
      PCI: pciehp: Fix unprotected list iteration in IRQ handler
      PCI: pciehp: Fix use-after-free on unplug
      PCI: hotplug: Don't leak pci_slot on registration failure
      PCI: hotplug: Delete skeleton driver
      PCI: shpchp: Separate existence of SHPC and permission to use it

commit 7903782460ee1813d6779c968b28d0ac71b9b3ae
Author: Lukas Wunner <lukas@wunner.de>
Date:   Thu Jul 19 17:27:53 2018 -0500

    PCI: pciehp: Clear spurious events earlier on resume
    
    Thunderbolt hotplug ports that were occupied before system sleep resume
    with their downstream link in "off" state.  Only after the Thunderbolt
    controller has reestablished the PCIe tunnels does the link go up.
    As a result, a spurious Presence Detect Changed and/or Data Link Layer
    State Changed event occurs.
    
    The events are not immediately acted upon because tunnel reestablishment
    happens in the ->resume_noirq phase, when interrupts are still disabled.
    Also, notification of events may initially be disabled in the Slot
    Control register when coming out of system sleep and is reenabled in the
    ->resume_noirq phase through:
    
      pci_pm_resume_noirq()
        pci_pm_default_resume_early()
          pci_restore_state()
            pci_restore_pcie_state()
    
    It is not guaranteed that the events are acted upon at all:  PCIe r4.0,
    sec 6.7.3.4 says that "a port may optionally send an MSI when there are
    hot-plug events that occur while interrupt generation is disabled, and
    interrupt generation is subsequently enabled."  Note the "optionally".
    
    If an MSI is sent, pciehp will gratuitously turn the slot off and back
    on once the ->resume_early phase has commenced.
    
    If an MSI is not sent, the extant, unacknowledged events in the Slot
    Status register will prevent future notification of presence or link
    changes.
    
    Commit 13c65840feab ("PCI: pciehp: Clear Presence Detect and Data Link
    Layer Status Changed on resume") fixed the latter by clearing the events
    in the ->resume phase.  Move this to the ->resume_noirq phase to also
    fix the gratuitous disable/enablement of the slot.
    
    The commit further restored the Slot Control register in the ->resume
    phase, but that's dispensable because as shown above it's already been
    done in the ->resume_noirq phase.
    
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index 973f1b80a038..5e0f02c68faa 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -76,10 +76,12 @@ static int pcie_port_runtime_idle(struct device *dev)
 
 static const struct dev_pm_ops pcie_portdrv_pm_ops = {
 	.suspend	= pcie_port_device_suspend,
+	.resume_noirq	= pcie_port_device_resume_noirq,
 	.resume		= pcie_port_device_resume,
 	.freeze		= pcie_port_device_suspend,
 	.thaw		= pcie_port_device_resume,
 	.poweroff	= pcie_port_device_suspend,
+	.restore_noirq	= pcie_port_device_resume_noirq,
 	.restore	= pcie_port_device_resume,
 	.runtime_suspend = pcie_port_runtime_suspend,
 	.runtime_resume	= pcie_port_runtime_resume,

commit 89e1f5cb1ecc1cd509a196f4e79d12a1e39410b6
Author: Oza Pawandeep <poza@codeaurora.org>
Date:   Thu Jul 19 17:58:10 2018 -0500

    PCI/portdrv: Remove pcie_portdrv_err_handler.slot_reset
    
    The pci_error_handlers.slot_reset() callback is only used for non-bridge
    devices (see broadcast_error_message()).  Since portdrv only binds to
    bridges, we don't need pcie_portdrv_slot_reset(), so remove it.
    
    Signed-off-by: Oza Pawandeep <poza@codeaurora.org>
    [bhelgaas: changelog, remove pcie_portdrv_slot_reset() completely]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index 973f1b80a038..b78840f54a9b 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -42,17 +42,6 @@ __setup("pcie_ports=", pcie_port_setup);
 
 /* global data */
 
-static int pcie_portdrv_restore_config(struct pci_dev *dev)
-{
-	int retval;
-
-	retval = pci_enable_device(dev);
-	if (retval)
-		return retval;
-	pci_set_master(dev);
-	return 0;
-}
-
 #ifdef CONFIG_PM
 static int pcie_port_runtime_suspend(struct device *dev)
 {
@@ -160,19 +149,6 @@ static pci_ers_result_t pcie_portdrv_mmio_enabled(struct pci_dev *dev)
 	return PCI_ERS_RESULT_RECOVERED;
 }
 
-static pci_ers_result_t pcie_portdrv_slot_reset(struct pci_dev *dev)
-{
-	/* If fatal, restore cfg space for possible link reset at upstream */
-	if (dev->error_state == pci_channel_io_frozen) {
-		dev->state_saved = true;
-		pci_restore_state(dev);
-		pcie_portdrv_restore_config(dev);
-		pci_enable_pcie_error_reporting(dev);
-	}
-
-	return PCI_ERS_RESULT_RECOVERED;
-}
-
 static int resume_iter(struct device *device, void *data)
 {
 	struct pcie_device *pcie_device;
@@ -208,7 +184,6 @@ static const struct pci_device_id port_pci_ids[] = { {
 static const struct pci_error_handlers pcie_portdrv_err_handler = {
 	.error_detected = pcie_portdrv_error_detected,
 	.mmio_enabled = pcie_portdrv_mmio_enabled,
-	.slot_reset = pcie_portdrv_slot_reset,
 	.resume = pcie_portdrv_err_resume,
 };
 

commit 64ae499cf2eece26bc395184aa2c9a18aa49d199
Merge: ac30aa596996 e02602bd7625
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Apr 4 13:27:58 2018 -0500

    Merge branch 'pci/portdrv'
    
      - move pcieport_if.h to drivers/pci/pcie/ to encapsulate it (Frederick
        Lawler)
    
      - merge pcieport_if.h into portdrv.h (Bjorn Helgaas)
    
      - move workaround for BIOS PME issue from portdrv to PCI core (Bjorn
        Helgaas)
    
      - completely disable portdrv with "pcie_ports=compat" (Bjorn Helgaas)
    
      - remove portdrv link order dependency (Bjorn Helgaas)
    
      - remove support for unused VC portdrv service (Bjorn Helgaas)
    
      - simplify portdrv feature permission checking (Bjorn Helgaas)
    
      - remove "pcie_hp=nomsi" parameter (use "pci=nomsi" instead) (Bjorn
        Helgaas)
    
      - remove unnecessary "pcie_ports=auto" parameter (Bjorn Helgaas)
    
      - use cached AER capability offset (Frederick Lawler)
    
      - don't enable DPC if BIOS hasn't granted AER control (Mika Westerberg)
    
      - rename pcie-dpc.c to dpc.c (Bjorn Helgaas)
    
    * pci/portdrv:
      PCI/DPC: Rename from pcie-dpc.c to dpc.c
      PCI/DPC: Do not enable DPC if AER control is not allowed by the BIOS
      PCI/AER: Use cached AER Capability offset
      PCI/portdrv: Rename and reverse sense of pcie_ports_auto
      PCI/portdrv: Encapsulate pcie_ports_auto inside the port driver
      PCI/portdrv: Remove unnecessary "pcie_ports=auto" parameter
      PCI/portdrv: Remove "pcie_hp=nomsi" kernel parameter
      PCI/portdrv: Remove unnecessary include of <linux/pci-aspm.h>
      PCI/portdrv: Simplify PCIe feature permission checking
      PCI/portdrv: Remove unused PCIE_PORT_SERVICE_VC
      PCI/portdrv: Remove pcie_port_bus_type link order dependency
      PCI/portdrv: Disable port driver in compat mode
      PCI/PM: Clear PCIe PME Status bit for Root Complex Event Collectors
      PCI/PM: Clear PCIe PME Status bit in core, not PCIe port driver
      PCI/PM: Move pcie_clear_root_pme_status() to core
      PCI/portdrv: Merge pcieport_if.h into portdrv.h
      PCI/portdrv: Move pcieport_if.h to drivers/pci/pcie/
    
    Conflicts:
            drivers/pci/pcie/Makefile
            drivers/pci/pcie/portdrv.h

commit d850882b726f6db01b0792151e72e69b234aa461
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Mar 9 11:21:30 2018 -0600

    PCI/portdrv: Rename and reverse sense of pcie_ports_auto
    
    The platform may restrict the OS's use of PCIe services, e.g., via the ACPI
    _OSC method.  The user may use "pcie_ports=native" to force the port driver
    to use PCIe services even if the platform asked us not to.
    
    The "pcie_ports=native" parameter determines the setting of
    pcie_ports_auto.  Rename this to pcie_ports_native and reverse the
    sense to simplify the code.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index 8b62192342ac..8e4260d25941 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -25,19 +25,18 @@
 bool pcie_ports_disabled;
 
 /*
- * If this switch is set, ACPI _OSC will be used to determine whether or not to
- * enable PCIe port native services.
+ * If the user specified "pcie_ports=native", use the PCIe services regardless
+ * of whether the platform has given us permission.  On ACPI systems, this
+ * means we ignore _OSC.
  */
-bool pcie_ports_auto = true;
+bool pcie_ports_native;
 
 static int __init pcie_port_setup(char *str)
 {
-	if (!strncmp(str, "compat", 6)) {
+	if (!strncmp(str, "compat", 6))
 		pcie_ports_disabled = true;
-	} else if (!strncmp(str, "native", 6)) {
-		pcie_ports_disabled = false;
-		pcie_ports_auto = false;
-	}
+	else if (!strncmp(str, "native", 6))
+		pcie_ports_native = true;
 
 	return 1;
 }

commit 4c0fd7648d880d98add62552cffdf993bde65cf8
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Mar 9 11:21:28 2018 -0600

    PCI/portdrv: Remove unnecessary "pcie_ports=auto" parameter
    
    The "pcie_ports=auto" parameter set pcie_ports_disabled and pcie_ports_auto
    to their compiled-in defaults, so specifying the parameter is the same as
    not using it at all.
    
    Remove the "pcie_ports=auto" parameter and update the documentation.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index 1997d9f2743e..8b62192342ac 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -37,9 +37,6 @@ static int __init pcie_port_setup(char *str)
 	} else if (!strncmp(str, "native", 6)) {
 		pcie_ports_disabled = false;
 		pcie_ports_auto = false;
-	} else if (!strncmp(str, "auto", 4)) {
-		pcie_ports_disabled = false;
-		pcie_ports_auto = true;
 	}
 
 	return 1;

commit 1b64cb87cf0013cdd04b7e1665072a00f92b830f
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Mar 9 11:21:26 2018 -0600

    PCI/portdrv: Remove unnecessary include of <linux/pci-aspm.h>
    
    portdrv_pci.c doesn't use anything from <linux/pci-aspm.h>.  Remove the
    include of it.  No functional change intended.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index 127321e17184..1997d9f2743e 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -17,7 +17,6 @@
 #include <linux/init.h>
 #include <linux/aer.h>
 #include <linux/dmi.h>
-#include <linux/pci-aspm.h>
 
 #include "../pci.h"
 #include "portdrv.h"

commit c6c889d932bb49d95273711a790d16f814cb213b
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Mar 9 11:06:56 2018 -0600

    PCI/portdrv: Remove pcie_port_bus_type link order dependency
    
    The pcie_port_bus_type must be registered before drivers that depend on it
    can be registered.  Those drivers include:
    
      pcied_init()                # PCIe native hotplug driver
      aer_service_init()          # AER driver
      dpc_service_init()          # DPC driver
      pcie_pme_service_init()     # PME driver
    
    Previously we registered pcie_port_bus_type from pcie_portdrv_init(), a
    device_initcall.  The callers of pcie_port_service_register() (above) are
    also device_initcalls.  This is fragile because the device_initcall
    ordering depends on link order, which is not explicit.
    
    Register pcie_port_bus_type from pci_driver_init() along with pci_bus_type.
    This removes the link order dependency between portdrv and the pciehp, AER,
    DPC, and PCIe PME drivers.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index 5d9d5305ebef..127321e17184 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -258,22 +258,11 @@ static const struct dmi_system_id pcie_portdrv_dmi_table[] __initconst = {
 
 static int __init pcie_portdrv_init(void)
 {
-	int retval;
-
 	if (pcie_ports_disabled)
 		return -EACCES;
 
 	dmi_check_system(pcie_portdrv_dmi_table);
 
-	retval = pcie_port_bus_register();
-	if (retval) {
-		printk(KERN_WARNING "PCIE: bus_register error: %d\n", retval);
-		goto out;
-	}
-	retval = pci_register_driver(&pcie_portdriver);
-	if (retval)
-		pcie_port_bus_unregister();
- out:
-	return retval;
+	return pci_register_driver(&pcie_portdriver);
 }
 device_initcall(pcie_portdrv_init);

commit 79a011194b23302dc43f265ed4237054877768ff
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Mar 9 11:06:56 2018 -0600

    PCI/portdrv: Disable port driver in compat mode
    
    The "pcie_ports=compat" kernel parameter sets pcie_ports_disabled, which is
    intended to disable the PCIe port driver.  But even when it was disabled,
    we registered pcie_portdriver so we could work around a BIOS PME issue (see
    fe31e69740ed ("PCI/PCIe: Clear Root PME Status bits early during system
    resume")).
    
    Registering the driver meant that the pcie_portdrv_probe() path called
    pci_enable_device(), pci_save_state(), pm_runtime_set_autosuspend_delay(),
    pm_runtime_use_autosuspend(), etc., even when the driver was disabled.
    
    We've since moved the BIOS PME workaround from the port driver to the core,
    so stop registering the PCIe port driver in compat mode.
    
    This means "pcie_ports=compat" will now be basically the same as turning
    off CONFIG_PCIEPORTBUS completely.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index ec9e936c2a5b..5d9d5305ebef 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -261,7 +261,7 @@ static int __init pcie_portdrv_init(void)
 	int retval;
 
 	if (pcie_ports_disabled)
-		return pci_register_driver(&pcie_portdriver);
+		return -EACCES;
 
 	dmi_check_system(pcie_portdrv_dmi_table);
 

commit df62ab5e0f75608919df7442654b0fab78246b7b
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Mar 9 16:36:33 2018 -0600

    PCI: Tidy comments
    
    Remove pointless comments that tell us the file name, remove blank line
    comments, follow multi-line comment conventions.  No functional change
    intended.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index fb1c1bb87316..06d9445997ff 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -1,9 +1,7 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * File:	portdrv_pci.c
  * Purpose:	PCI Express Port Bus Driver
  * Author:	Tom Nguyen <tom.l.nguyen@intel.com>
- * Version:	v1.0
  *
  * Copyright (C) 2004 Intel
  * Copyright (C) Tom Long Nguyen (tom.l.nguyen@intel.com)

commit a39bd851dccfdcb89db3d9a6b03283aaf15f310c
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Mar 9 11:06:54 2018 -0600

    PCI/PM: Clear PCIe PME Status bit in core, not PCIe port driver
    
    fe31e69740ed ("PCI/PCIe: Clear Root PME Status bits early during system
    resume") added a .resume_noirq() callback to the PCIe port driver to clear
    the PME Status bit during resume to work around a BIOS issue.
    
    The BIOS evidently enabled PME interrupts for ACPI-based runtime wakeups
    but did not clear the PME Status bit during resume, which meant PMEs after
    resume did not trigger interrupts because PME Status did not transition
    from cleared to set.
    
    The fix was in the PCIe port driver, so it worked when CONFIG_PCIEPORTBUS
    was set.  But I think we *always* want the fix because the platform may use
    PME interrupts even if Linux is built without the PCIe port driver.
    
    Move the fix from the port driver to the PCI core so we can work around
    this "PME doesn't work after waking from a sleep state" issue regardless of
    CONFIG_PCIEPORTBUS.
    
    [bhelgaas: folded in warning fix from Arnd Bergmann <arnd@arndb.de>:
    https://lkml.kernel.org/r/20180328134747.2062348-1-arnd@arndb.de]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index d6f10a97d400..ec9e936c2a5b 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -61,20 +61,6 @@ static int pcie_portdrv_restore_config(struct pci_dev *dev)
 }
 
 #ifdef CONFIG_PM
-static int pcie_port_resume_noirq(struct device *dev)
-{
-	struct pci_dev *pdev = to_pci_dev(dev);
-
-	/*
-	 * Some BIOSes forget to clear Root PME Status bits after system wakeup
-	 * which breaks ACPI-based runtime wakeup on PCI Express, so clear those
-	 * bits now just in case (shouldn't hurt).
-	 */
-	if (pci_pcie_type(pdev) == PCI_EXP_TYPE_ROOT_PORT)
-		pcie_clear_root_pme_status(pdev);
-	return 0;
-}
-
 static int pcie_port_runtime_suspend(struct device *dev)
 {
 	return to_pci_dev(dev)->bridge_d3 ? 0 : -EBUSY;
@@ -102,7 +88,6 @@ static const struct dev_pm_ops pcie_portdrv_pm_ops = {
 	.thaw		= pcie_port_device_resume,
 	.poweroff	= pcie_port_device_suspend,
 	.restore	= pcie_port_device_resume,
-	.resume_noirq	= pcie_port_resume_noirq,
 	.runtime_suspend = pcie_port_runtime_suspend,
 	.runtime_resume	= pcie_port_runtime_resume,
 	.runtime_idle	= pcie_port_runtime_idle,

commit dcb0453d71e361d4718bb566d99e6ae498284419
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Mar 9 11:06:53 2018 -0600

    PCI/PM: Move pcie_clear_root_pme_status() to core
    
    Move pcie_clear_root_pme_status() from the port driver to the PCI core so
    it will be available even when the port driver isn't present.  No
    functional change intended.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index 977bd3cca2e5..d6f10a97d400 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -49,15 +49,6 @@ __setup("pcie_ports=", pcie_port_setup);
 
 /* global data */
 
-/**
- * pcie_clear_root_pme_status - Clear root port PME interrupt status.
- * @dev: PCIe root port or event collector.
- */
-void pcie_clear_root_pme_status(struct pci_dev *dev)
-{
-	pcie_capability_set_dword(dev, PCI_EXP_RTSTA, PCI_EXP_RTSTA_PME);
-}
-
 static int pcie_portdrv_restore_config(struct pci_dev *dev)
 {
 	int retval;

commit ef7942603e35e300e6967fa7c17ebc17a0c00f59
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Mar 9 11:42:01 2018 -0600

    PCI/portdrv: Merge pcieport_if.h into portdrv.h
    
    pcieport_if.h contained the interfaces to register port service driver,
    e.g., pcie_port_service_register().  portdrv.h contained internal data
    structures of the port driver.
    
    I don't think it's worth keeping those files separate, since both headers
    and their users are all inside the PCI core.
    
    Merge pcieport_if.h directly in drivers/pci/pcie/portdrv.h and update the
    users to include that instead.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index 13dbe846a1d1..977bd3cca2e5 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -19,7 +19,6 @@
 #include <linux/dmi.h>
 #include <linux/pci-aspm.h>
 
-#include "pcieport_if.h"
 #include "../pci.h"
 #include "portdrv.h"
 

commit c37e627f9565368ed7bd1f3cf59a2d223ddba85a
Author: Frederick Lawler <fred@fredlawl.com>
Date:   Tue Feb 13 21:52:18 2018 -0600

    PCI/portdrv: Move pcieport_if.h to drivers/pci/pcie/
    
    Move pcieport_if.h from include/linux to drivers/pci/pcie/pcieport_if.h
    because the interfaces there are only used by the PCI core.
    
    Replace all uses of #include<linux/pcieport_if.h> with relative paths to
    the new file location, e.g., #include "../pcieport_if.h"
    
    Signed-off-by: Frederick Lawler <fred@fredlawl.com>
    Signed-off-by: Bjorn Helgaas <helgaas@kernel.org>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index fb1c1bb87316..13dbe846a1d1 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -15,11 +15,11 @@
 #include <linux/pm.h>
 #include <linux/pm_runtime.h>
 #include <linux/init.h>
-#include <linux/pcieport_if.h>
 #include <linux/aer.h>
 #include <linux/dmi.h>
 #include <linux/pci-aspm.h>
 
+#include "pcieport_if.h"
 #include "../pci.h"
 #include "portdrv.h"
 

commit 877b3729ca03b00800b99ac0c076e9456ef3ae6b
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Jan 3 01:38:27 2018 +0100

    PCI / PM: Use SMART_SUSPEND and LEAVE_SUSPENDED flags for PCIe ports
    
    Make the PCIe port driver set DPM_FLAG_SMART_SUSPEND and
    DPM_FLAG_LEAVE_SUSPENDED for the devices handled by it to benefit
    from the opportunistic optimizations in the PCI layer enabled by
    these flags.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index ffbf4e723527..fb1c1bb87316 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -150,6 +150,9 @@ static int pcie_portdrv_probe(struct pci_dev *dev,
 
 	pci_save_state(dev);
 
+	dev_pm_set_driver_flags(&dev->dev, DPM_FLAG_SMART_SUSPEND |
+					   DPM_FLAG_LEAVE_SUSPENDED);
+
 	if (pci_bridge_d3_possible(dev)) {
 		/*
 		 * Keep the port resumed 100ms to make sure things like

commit 1b6115fbe3b3db746d7baa11399dd617fc75e1c4
Merge: ad0835a93008 91f3140fdef6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Nov 15 15:01:28 2017 -0800

    Merge tag 'pci-v4.15-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI updates from Bjorn Helgaas:
    
      - detach driver before tearing down procfs/sysfs (Alex Williamson)
    
      - disable PCIe services during shutdown (Sinan Kaya)
    
      - fix ASPM oops on systems with no Root Ports (Ard Biesheuvel)
    
      - fix ASPM LTR_L1.2_THRESHOLD programming (Bjorn Helgaas)
    
      - fix ASPM Common_Mode_Restore_Time computation (Bjorn Helgaas)
    
      - fix portdrv MSI/MSI-X vector allocation (Dongdong Liu, Bjorn
        Helgaas)
    
      - report non-fatal AER errors only to the affected endpoint (Gabriele
        Paoloni)
    
      - distribute bus numbers, MMIO, and I/O space among hotplug bridges to
        allow more devices to be hot-added (Mika Westerberg)
    
      - fix pciehp races during initialization and surprise link down (Mika
        Westerberg)
    
      - handle surprise-removed devices in PME handling (Qiang)
    
      - support resizable BARs for large graphics devices (Christian König)
    
      - expose SR-IOV offset, stride, and VF device ID via sysfs (Filippo
        Sironi)
    
      - create SR-IOV virtfn/physfn sysfs links before attaching driver
        (Stuart Hayes)
    
      - fix SR-IOV "ARI Capable Hierarchy" restore issue (Tony Nguyen)
    
      - enforce Kconfig IOV/REALLOC dependency (Sascha El-Sharkawy)
    
      - avoid slot reset if bridge itself is broken (Jan Glauber)
    
      - clean up pci_reset_function() path (Jan H. Schönherr)
    
      - make pci_map_rom() fail if the option ROM is invalid (Changbin Du)
    
      - convert timers to timer_setup() (Kees Cook)
    
      - move PCI_QUIRKS to PCI bus Kconfig menu (Randy Dunlap)
    
      - constify pci_dev_type and intel_mid_pci_ops (Bhumika Goyal)
    
      - remove unnecessary pci_dev, pci_bus, resource, pcibios_set_master()
        declarations (Bjorn Helgaas)
    
      - fix endpoint framework overflows and BUG()s (Dan Carpenter)
    
      - fix endpoint framework issues (Kishon Vijay Abraham I)
    
      - avoid broken Cavium CN8xxx bus reset behavior (David Daney)
    
      - extend Cavium ACS capability quirks (Vadim Lomovtsev)
    
      - support Synopsys DesignWare RC in ECAM mode (Ard Biesheuvel)
    
      - turn off dra7xx clocks cleanly on shutdown (Keerthy)
    
      - fix Faraday probe error path (Wei Yongjun)
    
      - support HiSilicon STB SoC PCIe host controller (Jianguo Sun)
    
      - fix Hyper-V interrupt affinity issue (Dexuan Cui)
    
      - remove useless ACPI warning for Hyper-V pass-through devices (Vitaly
        Kuznetsov)
    
      - support multiple MSI on iProc (Sandor Bodo-Merle)
    
      - support Layerscape LS1012a and LS1046a PCIe host controllers (Hou
        Zhiqiang)
    
      - fix Layerscape default error response (Minghuan Lian)
    
      - support MSI on Tango host controller (Marc Gonzalez)
    
      - support Tegra186 PCIe host controller (Manikanta Maddireddy)
    
      - use generic accessors on Tegra when possible (Thierry Reding)
    
      - support V3 Semiconductor PCI host controller (Linus Walleij)
    
    * tag 'pci-v4.15-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (85 commits)
      PCI/ASPM: Add L1 Substates definitions
      PCI/ASPM: Reformat ASPM register definitions
      PCI/ASPM: Use correct capability pointer to program LTR_L1.2_THRESHOLD
      PCI/ASPM: Account for downstream device's Port Common_Mode_Restore_Time
      PCI: xgene: Rename xgene_pcie_probe_bridge() to xgene_pcie_probe()
      PCI: xilinx: Rename xilinx_pcie_link_is_up() to xilinx_pcie_link_up()
      PCI: altera: Rename altera_pcie_link_is_up() to altera_pcie_link_up()
      PCI: Fix kernel-doc build warning
      PCI: Fail pci_map_rom() if the option ROM is invalid
      PCI: Move pci_map_rom() error path
      PCI: Move PCI_QUIRKS to the PCI bus menu
      alpha/PCI: Make pdev_save_srm_config() static
      PCI: Remove unused declarations
      PCI: Remove redundant pci_dev, pci_bus, resource declarations
      PCI: Remove redundant pcibios_set_master() declarations
      PCI/PME: Handle invalid data when reading Root Status
      PCI: hv: Use effective affinity mask
      PCI: pciehp: Do not clear Presence Detect Changed during initialization
      PCI: pciehp: Fix race condition handling surprise link down
      PCI: Distribute available resources to hotplug-capable bridges
      ...

commit cc27b735ad3a75574a6ab1a66ed6b09385e77e5e
Author: Sinan Kaya <okaya@codeaurora.org>
Date:   Wed Oct 25 15:01:02 2017 -0400

    PCI/portdrv: Turn off PCIe services during shutdown
    
    Some of the PCIe services such as AER are being left enabled during
    shutdown. This might cause spurious AER errors while SOC is being powered
    down.
    
    Clean up the PCIe services gracefully during shutdown to clear these false
    positives.
    
    Signed-off-by: Sinan Kaya <okaya@codeaurora.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index 083276e03c38..b350d12b39e3 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -246,6 +246,7 @@ static struct pci_driver pcie_portdriver = {
 
 	.probe		= pcie_portdrv_probe,
 	.remove		= pcie_portdrv_remove,
+	.shutdown	= pcie_portdrv_remove,
 
 	.err_handler	= &pcie_portdrv_err_handler,
 

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index 083276e03c38..68c389c7b975 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * File:	portdrv_pci.c
  * Purpose:	PCI Express Port Bus Driver

commit 6faadbbb7f9da70ce484f98f72223c20125a1009
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Sep 14 11:59:30 2017 +0200

    dmi: Mark all struct dmi_system_id instances const
    
    ... and __initconst if applicable.
    
    Based on similar work for an older kernel in the Grsecurity patch.
    
    [JD: fix toshiba-wmi build]
    [JD: add htcpen]
    [JD: move __initconst where checkscript wants it]
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jean Delvare <jdelvare@suse.de>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index be635f017756..083276e03c38 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -260,7 +260,7 @@ static int __init dmi_pcie_pme_disable_msi(const struct dmi_system_id *d)
 	return 0;
 }
 
-static struct dmi_system_id __initdata pcie_portdrv_dmi_table[] = {
+static const struct dmi_system_id pcie_portdrv_dmi_table[] __initconst = {
 	/*
 	 * Boxes that should not use MSI for PCIe PME signaling.
 	 */

commit c5dc3c69f17a7e77359f10c342d1816390bc8846
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Jun 19 20:04:58 2017 +0200

    PCI/portdrv: Move error handler methods to struct pcie_port_service_driver
    
    Move the error handler methods to struct pcie_port_service_driver and avoid
    the detour through the mostly unused pci_error_handlers structure.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index 8aa3f14bc87d..be635f017756 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -21,7 +21,6 @@
 
 #include "../pci.h"
 #include "portdrv.h"
-#include "aer/aerdrv.h"
 
 /* If this switch is set, PCIe port native services should not be enabled. */
 bool pcie_ports_disabled;
@@ -177,108 +176,20 @@ static void pcie_portdrv_remove(struct pci_dev *dev)
 	pcie_port_device_remove(dev);
 }
 
-static int error_detected_iter(struct device *device, void *data)
-{
-	struct pcie_device *pcie_device;
-	struct pcie_port_service_driver *driver;
-	struct aer_broadcast_data *result_data;
-	pci_ers_result_t status;
-
-	result_data = (struct aer_broadcast_data *) data;
-
-	if (device->bus == &pcie_port_bus_type && device->driver) {
-		driver = to_service_driver(device->driver);
-		if (!driver ||
-			!driver->err_handler ||
-			!driver->err_handler->error_detected)
-			return 0;
-
-		pcie_device = to_pcie_device(device);
-
-		/* Forward error detected message to service drivers */
-		status = driver->err_handler->error_detected(
-			pcie_device->port,
-			result_data->state);
-		result_data->result =
-			merge_result(result_data->result, status);
-	}
-
-	return 0;
-}
-
 static pci_ers_result_t pcie_portdrv_error_detected(struct pci_dev *dev,
 					enum pci_channel_state error)
 {
-	struct aer_broadcast_data data = {error, PCI_ERS_RESULT_CAN_RECOVER};
-
-	/* get true return value from &data */
-	device_for_each_child(&dev->dev, &data, error_detected_iter);
-	return data.result;
-}
-
-static int mmio_enabled_iter(struct device *device, void *data)
-{
-	struct pcie_device *pcie_device;
-	struct pcie_port_service_driver *driver;
-	pci_ers_result_t status, *result;
-
-	result = (pci_ers_result_t *) data;
-
-	if (device->bus == &pcie_port_bus_type && device->driver) {
-		driver = to_service_driver(device->driver);
-		if (driver &&
-			driver->err_handler &&
-			driver->err_handler->mmio_enabled) {
-			pcie_device = to_pcie_device(device);
-
-			/* Forward error message to service drivers */
-			status = driver->err_handler->mmio_enabled(
-					pcie_device->port);
-			*result = merge_result(*result, status);
-		}
-	}
-
-	return 0;
+	/* Root Port has no impact. Always recovers. */
+	return PCI_ERS_RESULT_CAN_RECOVER;
 }
 
 static pci_ers_result_t pcie_portdrv_mmio_enabled(struct pci_dev *dev)
 {
-	pci_ers_result_t status = PCI_ERS_RESULT_RECOVERED;
-
-	/* get true return value from &status */
-	device_for_each_child(&dev->dev, &status, mmio_enabled_iter);
-	return status;
-}
-
-static int slot_reset_iter(struct device *device, void *data)
-{
-	struct pcie_device *pcie_device;
-	struct pcie_port_service_driver *driver;
-	pci_ers_result_t status, *result;
-
-	result = (pci_ers_result_t *) data;
-
-	if (device->bus == &pcie_port_bus_type && device->driver) {
-		driver = to_service_driver(device->driver);
-		if (driver &&
-			driver->err_handler &&
-			driver->err_handler->slot_reset) {
-			pcie_device = to_pcie_device(device);
-
-			/* Forward error message to service drivers */
-			status = driver->err_handler->slot_reset(
-					pcie_device->port);
-			*result = merge_result(*result, status);
-		}
-	}
-
-	return 0;
+	return PCI_ERS_RESULT_RECOVERED;
 }
 
 static pci_ers_result_t pcie_portdrv_slot_reset(struct pci_dev *dev)
 {
-	pci_ers_result_t status = PCI_ERS_RESULT_RECOVERED;
-
 	/* If fatal, restore cfg space for possible link reset at upstream */
 	if (dev->error_state == pci_channel_io_frozen) {
 		dev->state_saved = true;
@@ -287,9 +198,7 @@ static pci_ers_result_t pcie_portdrv_slot_reset(struct pci_dev *dev)
 		pci_enable_pcie_error_reporting(dev);
 	}
 
-	/* get true return value from &status */
-	device_for_each_child(&dev->dev, &status, slot_reset_iter);
-	return status;
+	return PCI_ERS_RESULT_RECOVERED;
 }
 
 static int resume_iter(struct device *device, void *data)
@@ -299,13 +208,11 @@ static int resume_iter(struct device *device, void *data)
 
 	if (device->bus == &pcie_port_bus_type && device->driver) {
 		driver = to_service_driver(device->driver);
-		if (driver &&
-			driver->err_handler &&
-			driver->err_handler->resume) {
+		if (driver && driver->error_resume) {
 			pcie_device = to_pcie_device(device);
 
 			/* Forward error message to service drivers */
-			driver->err_handler->resume(pcie_device->port);
+			driver->error_resume(pcie_device->port);
 		}
 	}
 

commit 97a90aee5dab33aea0cd3f6802b3661990496262
Author: Lukas Wunner <lukas@wunner.de>
Date:   Fri Oct 28 10:52:06 2016 +0200

    PCI: Consolidate conditions to allow runtime PM on PCIe ports
    
    The conditions to allow runtime PM on PCIe ports are currently spread
    across two different files:  The condition relating to hotplug ports is
    located in portdrv_pci.c whereas all other conditions are located in pci.c.
    
    Consolidate all conditions in a single place in pci.c, thus making it
    easier to follow the logic and amend conditions down the road.
    
    Note that the condition relating to hotplug ports is inserted *before* the
    condition relating to the "pcie_port_pm=force" command line option, so
    runtime PM is not afforded to hotplug ports even if this option is given.
    That's exactly how the code behaved up until now.  If this is not desired,
    the ordering of the conditions can simply be reversed.
    
    No functional change intended.
    
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index 1ae712cb22ec..8aa3f14bc87d 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -150,15 +150,7 @@ static int pcie_portdrv_probe(struct pci_dev *dev,
 
 	pci_save_state(dev);
 
-	/*
-	 * Prevent runtime PM if the port is advertising support for PCIe
-	 * hotplug.  Otherwise the BIOS hotplug SMI code might not be able
-	 * to enumerate devices behind this port properly (the port is
-	 * powered down preventing all config space accesses to the
-	 * subordinate devices).  We can't be sure for native PCIe hotplug
-	 * either so prevent that as well.
-	 */
-	if (pci_bridge_d3_possible(dev) && !dev->is_hotplug_bridge) {
+	if (pci_bridge_d3_possible(dev)) {
 		/*
 		 * Keep the port resumed 100ms to make sure things like
 		 * config space accesses from userspace (lspci) will not
@@ -176,7 +168,7 @@ static int pcie_portdrv_probe(struct pci_dev *dev,
 
 static void pcie_portdrv_remove(struct pci_dev *dev)
 {
-	if (pci_bridge_d3_possible(dev) && !dev->is_hotplug_bridge) {
+	if (pci_bridge_d3_possible(dev)) {
 		pm_runtime_forbid(&dev->dev);
 		pm_runtime_get_noresume(&dev->dev);
 		pm_runtime_dont_use_autosuspend(&dev->dev);

commit c6a6330706148e7d5265c3dd658d25843c83390f
Author: Lukas Wunner <lukas@wunner.de>
Date:   Fri Oct 28 10:52:06 2016 +0200

    PCI: Activate runtime PM on a PCIe port only if it can suspend
    
    Currently pcie_portdrv_probe() activates runtime PM on a PCIe port even
    if it will never actually suspend because the BIOS is too old or the
    "pcie_port_pm=off" option was specified on the kernel command line.
    
    A few CPU cycles can be saved by not activating runtime PM at all in these
    cases, because rpm_idle() and rpm_suspend() will bail out right at the
    beginning when calling rpm_check_suspend_allowed(), instead of carrying out
    various locking and assignments, invoking rpm_callback(), getting back
    -EBUSY and rolling everything back.
    
    The conditions checked in pci_bridge_d3_possible() are all static, they
    never change during uptime of the system, hence it's safe to call this to
    determine if runtime PM should be activated.
    
    No functional change intended.
    
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index 79327cc14e7d..1ae712cb22ec 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -19,6 +19,7 @@
 #include <linux/dmi.h>
 #include <linux/pci-aspm.h>
 
+#include "../pci.h"
 #include "portdrv.h"
 #include "aer/aerdrv.h"
 
@@ -157,7 +158,7 @@ static int pcie_portdrv_probe(struct pci_dev *dev,
 	 * subordinate devices).  We can't be sure for native PCIe hotplug
 	 * either so prevent that as well.
 	 */
-	if (!dev->is_hotplug_bridge) {
+	if (pci_bridge_d3_possible(dev) && !dev->is_hotplug_bridge) {
 		/*
 		 * Keep the port resumed 100ms to make sure things like
 		 * config space accesses from userspace (lspci) will not
@@ -175,7 +176,7 @@ static int pcie_portdrv_probe(struct pci_dev *dev,
 
 static void pcie_portdrv_remove(struct pci_dev *dev)
 {
-	if (!dev->is_hotplug_bridge) {
+	if (pci_bridge_d3_possible(dev) && !dev->is_hotplug_bridge) {
 		pm_runtime_forbid(&dev->dev);
 		pm_runtime_get_noresume(&dev->dev);
 		pm_runtime_dont_use_autosuspend(&dev->dev);

commit a7dadf45aedd414191222368a700534d2a652197
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Mon Aug 22 17:59:44 2016 -0400

    PCI: portdrv: Make explicitly non-modular
    
    This code is not being built as a module by anyone:
    
      pcieportdrv-y               := portdrv_core.o portdrv_pci.o portdrv_bus.o
      obj-$(CONFIG_PCIEPORTBUS)   += pcieportdrv.o
    
      drivers/pci/pcie/Kconfig:config PCIEPORTBUS
      drivers/pci/pcie/Kconfig:  bool "PCI Express Port Bus support"
    
    Remove uses of MODULE_DESCRIPTION(), MODULE_AUTHOR(), MODULE_LICENSE(),
    etc., so that when reading the driver there is no doubt it is builtin-only.
    The information is preserved in comments at the top of the file.
    
    Note that for non-modular code, MODULE_DEVICE_TABLE is a no-op and
    module_init() translates to device_initcall().
    
    [bhelgaas: changelog, remove unused DRIVER_* macros]
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    CC: Tom Long Nguyen <tom.l.nguyen@intel.com>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index 70d7ad8c6d17..79327cc14e7d 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -1,12 +1,13 @@
 /*
  * File:	portdrv_pci.c
  * Purpose:	PCI Express Port Bus Driver
+ * Author:	Tom Nguyen <tom.l.nguyen@intel.com>
+ * Version:	v1.0
  *
  * Copyright (C) 2004 Intel
  * Copyright (C) Tom Long Nguyen (tom.l.nguyen@intel.com)
  */
 
-#include <linux/module.h>
 #include <linux/pci.h>
 #include <linux/kernel.h>
 #include <linux/errno.h>
@@ -21,16 +22,6 @@
 #include "portdrv.h"
 #include "aer/aerdrv.h"
 
-/*
- * Version Information
- */
-#define DRIVER_VERSION "v1.0"
-#define DRIVER_AUTHOR "tom.l.nguyen@intel.com"
-#define DRIVER_DESC "PCIe Port Bus Driver"
-MODULE_AUTHOR(DRIVER_AUTHOR);
-MODULE_DESCRIPTION(DRIVER_DESC);
-MODULE_LICENSE("GPL");
-
 /* If this switch is set, PCIe port native services should not be enabled. */
 bool pcie_ports_disabled;
 
@@ -341,7 +332,6 @@ static const struct pci_device_id port_pci_ids[] = { {
 	PCI_DEVICE_CLASS(((PCI_CLASS_BRIDGE_PCI << 8) | 0x00), ~0),
 	}, { /* end: all zeroes */ }
 };
-MODULE_DEVICE_TABLE(pci, port_pci_ids);
 
 static const struct pci_error_handlers pcie_portdrv_err_handler = {
 	.error_detected = pcie_portdrv_error_detected,
@@ -406,5 +396,4 @@ static int __init pcie_portdrv_init(void)
  out:
 	return retval;
 }
-
-module_init(pcie_portdrv_init);
+device_initcall(pcie_portdrv_init);

commit 006d44e49a259b39947366728d65a873a19aadc0
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Thu Jun 2 11:17:15 2016 +0300

    PCI: Add runtime PM support for PCIe ports
    
    Add back runtime PM support for PCIe ports that was removed by
    fe9a743a2601 ("PCI/PM: Drop unused runtime PM support code for PCIe
    ports").
    
    We cannot enable it automatically for all ports since there have been
    problems previously [1].  In summary suspended PCIe ports were not able
    to deal with ACPI-based hotplug reliably.  One reason why this might happen
    is the fact that when a PCIe port is powered down, config space access to
    the devices behind the port is not possible.  If the BIOS hotplug SMI
    handler assumes the port is always in D0 it will not be able to find the
    hotplugged devices.  To be on the safe side only enable runtime PM if the
    port does not claim to support hotplug.
    
    For PCIe ports not using hotplug, we enable and allow runtime PM
    automatically.  Since 'bridge_d3' can be changed any time we check this in
    driver ->runtime_idle() and ->runtime_suspend() and only allow runtime
    suspend if the flag is still set.  Use autosuspend with default of 100ms
    idle time to prevent the port from repeatedly suspending and resuming on
    continuous configuration space access of devices behind the port.
    
    The actual power transition to D3 and back is handled in the PCI core.
    
    Idea to automatically unblock (allow) runtime PM for PCIe ports came from
    Dave Airlie.
    
    [1] https://bugzilla.kernel.org/show_bug.cgi?id=53811
    
    This includes a fix for lockdep issue reported by Valdis Kletnieks.
    
    Tested-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index 6c6bb03392ea..70d7ad8c6d17 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -93,6 +93,26 @@ static int pcie_port_resume_noirq(struct device *dev)
 	return 0;
 }
 
+static int pcie_port_runtime_suspend(struct device *dev)
+{
+	return to_pci_dev(dev)->bridge_d3 ? 0 : -EBUSY;
+}
+
+static int pcie_port_runtime_resume(struct device *dev)
+{
+	return 0;
+}
+
+static int pcie_port_runtime_idle(struct device *dev)
+{
+	/*
+	 * Assume the PCI core has set bridge_d3 whenever it thinks the port
+	 * should be good to go to D3.  Everything else, including moving
+	 * the port to D3, is handled by the PCI core.
+	 */
+	return to_pci_dev(dev)->bridge_d3 ? 0 : -EBUSY;
+}
+
 static const struct dev_pm_ops pcie_portdrv_pm_ops = {
 	.suspend	= pcie_port_device_suspend,
 	.resume		= pcie_port_device_resume,
@@ -101,6 +121,9 @@ static const struct dev_pm_ops pcie_portdrv_pm_ops = {
 	.poweroff	= pcie_port_device_suspend,
 	.restore	= pcie_port_device_resume,
 	.resume_noirq	= pcie_port_resume_noirq,
+	.runtime_suspend = pcie_port_runtime_suspend,
+	.runtime_resume	= pcie_port_runtime_resume,
+	.runtime_idle	= pcie_port_runtime_idle,
 };
 
 #define PCIE_PORTDRV_PM_OPS	(&pcie_portdrv_pm_ops)
@@ -134,11 +157,39 @@ static int pcie_portdrv_probe(struct pci_dev *dev,
 		return status;
 
 	pci_save_state(dev);
+
+	/*
+	 * Prevent runtime PM if the port is advertising support for PCIe
+	 * hotplug.  Otherwise the BIOS hotplug SMI code might not be able
+	 * to enumerate devices behind this port properly (the port is
+	 * powered down preventing all config space accesses to the
+	 * subordinate devices).  We can't be sure for native PCIe hotplug
+	 * either so prevent that as well.
+	 */
+	if (!dev->is_hotplug_bridge) {
+		/*
+		 * Keep the port resumed 100ms to make sure things like
+		 * config space accesses from userspace (lspci) will not
+		 * cause the port to repeatedly suspend and resume.
+		 */
+		pm_runtime_set_autosuspend_delay(&dev->dev, 100);
+		pm_runtime_use_autosuspend(&dev->dev);
+		pm_runtime_mark_last_busy(&dev->dev);
+		pm_runtime_put_autosuspend(&dev->dev);
+		pm_runtime_allow(&dev->dev);
+	}
+
 	return 0;
 }
 
 static void pcie_portdrv_remove(struct pci_dev *dev)
 {
+	if (!dev->is_hotplug_bridge) {
+		pm_runtime_forbid(&dev->dev);
+		pm_runtime_get_noresume(&dev->dev);
+		pm_runtime_dont_use_autosuspend(&dev->dev);
+	}
+
 	pcie_port_device_remove(dev);
 }
 

commit 43f7f88b9362e1f26603b45932069bbd6e15a1e1
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Thu Jun 2 11:17:11 2016 +0300

    PCI: Don't clear d3cold_allowed for PCIe ports
    
    The PCI core skips bridges and ports when the system is suspended.  The PCI
    core checks return value of pci_has_subordinate() in pci_pm_suspend_noirq()
    to skip all devices where it is non-zero (which means PCI bridges and PCIe
    ports).
    
    Since PCIe ports are never suspended in the first place, there is no need
    to set d3cold_allowed for them.
    
    Tested-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index be35da2e105e..6c6bb03392ea 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -134,11 +134,6 @@ static int pcie_portdrv_probe(struct pci_dev *dev,
 		return status;
 
 	pci_save_state(dev);
-	/*
-	 * D3cold may not work properly on some PCIe port, so disable
-	 * it by default.
-	 */
-	dev->d3cold_allowed = false;
 	return 0;
 }
 

commit fe9a743a2601c846279e8dbbb382d5a9b6b900ff
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Jul 21 02:02:23 2014 +0200

    PCI/PM: Drop unused runtime PM support code for PCIe ports
    
    Since commit de7d5f729c72 ("PCI/PM: Disable runtime PM of PCIe ports") the
    runtime PM support code for PCIe ports in portdrv_pci.c has never been
    used, so drop it entirely.
    
    If we are to support runtime PM of PCIe ports, it will have to be done in a
    different way most likely anyway.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index 2ccc9b926ea7..be35da2e105e 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -93,77 +93,6 @@ static int pcie_port_resume_noirq(struct device *dev)
 	return 0;
 }
 
-#ifdef CONFIG_PM_RUNTIME
-struct d3cold_info {
-	bool no_d3cold;
-	unsigned int d3cold_delay;
-};
-
-static int pci_dev_d3cold_info(struct pci_dev *pdev, void *data)
-{
-	struct d3cold_info *info = data;
-
-	info->d3cold_delay = max_t(unsigned int, pdev->d3cold_delay,
-				   info->d3cold_delay);
-	if (pdev->no_d3cold)
-		info->no_d3cold = true;
-	return 0;
-}
-
-static int pcie_port_runtime_suspend(struct device *dev)
-{
-	struct pci_dev *pdev = to_pci_dev(dev);
-	struct d3cold_info d3cold_info = {
-		.no_d3cold	= false,
-		.d3cold_delay	= PCI_PM_D3_WAIT,
-	};
-
-	/*
-	 * If any subordinate device disable D3cold, we should not put
-	 * the port into D3cold.  The D3cold delay of port should be
-	 * the max of that of all subordinate devices.
-	 */
-	pci_walk_bus(pdev->subordinate, pci_dev_d3cold_info, &d3cold_info);
-	pdev->no_d3cold = d3cold_info.no_d3cold;
-	pdev->d3cold_delay = d3cold_info.d3cold_delay;
-	return 0;
-}
-
-static int pcie_port_runtime_resume(struct device *dev)
-{
-	return 0;
-}
-
-static int pci_dev_pme_poll(struct pci_dev *pdev, void *data)
-{
-	bool *pme_poll = data;
-
-	if (pdev->pme_poll)
-		*pme_poll = true;
-	return 0;
-}
-
-static int pcie_port_runtime_idle(struct device *dev)
-{
-	struct pci_dev *pdev = to_pci_dev(dev);
-	bool pme_poll = false;
-
-	/*
-	 * If any subordinate device needs pme poll, we should keep
-	 * the port in D0, because we need port in D0 to poll it.
-	 */
-	pci_walk_bus(pdev->subordinate, pci_dev_pme_poll, &pme_poll);
-	/* Delay for a short while to prevent too frequent suspend/resume */
-	if (!pme_poll)
-		pm_schedule_suspend(dev, 10);
-	return -EBUSY;
-}
-#else
-#define pcie_port_runtime_suspend	NULL
-#define pcie_port_runtime_resume	NULL
-#define pcie_port_runtime_idle		NULL
-#endif
-
 static const struct dev_pm_ops pcie_portdrv_pm_ops = {
 	.suspend	= pcie_port_device_suspend,
 	.resume		= pcie_port_device_resume,
@@ -172,9 +101,6 @@ static const struct dev_pm_ops pcie_portdrv_pm_ops = {
 	.poweroff	= pcie_port_device_suspend,
 	.restore	= pcie_port_device_resume,
 	.resume_noirq	= pcie_port_resume_noirq,
-	.runtime_suspend = pcie_port_runtime_suspend,
-	.runtime_resume = pcie_port_runtime_resume,
-	.runtime_idle	= pcie_port_runtime_idle,
 };
 
 #define PCIE_PORTDRV_PM_OPS	(&pcie_portdrv_pm_ops)

commit 7f105d311869d80895c169ba90ebebded93b3867
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Wed Jun 18 13:56:21 2014 +0800

    PCI/portdrv: Remove warning about invalid IRQ for hot-added PCIe ports
    
    For hot-added PCIe ports on x86 platforms, we always warned about an
    invalid IRQ, e.g.,
    
      pci 0000:00:00.0: device [8086:0e0b] has invalid IRQ; check vendor BIOS
    
    This was because we check pci_dev->irq before actually allocating the IRQ
    for the device, which happens in this path:
    
      pcie_port_device_register
        pci_enable_device
          pci_enable_device_flags
            do_pci_enable_device
              pcibios_enable_device    (on x86)
                pcibios_enable_irq
    
    This warning message isn't generated for PCIe ports present at boot time
    because x86 arch code has called acpi_pci_irq_enable() in pci_acpi_init()
    for each PCI device for safety.
    
    [bhelgaas: changelog]
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index 80887eaa0668..2ccc9b926ea7 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -203,10 +203,6 @@ static int pcie_portdrv_probe(struct pci_dev *dev,
 	     (pci_pcie_type(dev) != PCI_EXP_TYPE_DOWNSTREAM)))
 		return -ENODEV;
 
-	if (!dev->irq && dev->pin) {
-		dev_warn(&dev->dev, "device [%04x:%04x] has invalid IRQ; check vendor BIOS\n",
-			 dev->vendor, dev->device);
-	}
 	status = pcie_port_device_register(dev);
 	if (status)
 		return status;

commit 227f06470502c4fea3d93df1f12a77e3e37f6263
Author: Ryan Desfosses <ryan@desfo.org>
Date:   Fri Apr 18 20:13:50 2014 -0400

    PCI: Merge multi-line quoted strings
    
    Merge quoted strings that are broken across lines into a single entity.
    The compiler merges them anyway, but checkpatch complains about it, and
    merging them makes it easier to grep for strings.
    
    No functional change.
    
    [bhelgaas: changelog, do the same for everything under drivers/pci]
    Signed-off-by: Ryan Desfosses <ryan@desfo.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index 0d8fdc48e642..80887eaa0668 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -204,8 +204,8 @@ static int pcie_portdrv_probe(struct pci_dev *dev,
 		return -ENODEV;
 
 	if (!dev->irq && dev->pin) {
-		dev_warn(&dev->dev, "device [%04x:%04x] has invalid IRQ; "
-			 "check vendor BIOS\n", dev->vendor, dev->device);
+		dev_warn(&dev->dev, "device [%04x:%04x] has invalid IRQ; check vendor BIOS\n",
+			 dev->vendor, dev->device);
 	}
 	status = pcie_port_device_register(dev);
 	if (status)
@@ -397,7 +397,7 @@ static struct pci_driver pcie_portdriver = {
 static int __init dmi_pcie_pme_disable_msi(const struct dmi_system_id *d)
 {
 	pr_notice("%s detected: will not use MSI for PCIe PME signaling\n",
-			d->ident);
+		  d->ident);
 	pcie_pme_disable_msi();
 	return 0;
 }

commit e7cc5cf74544d97d7b69e2701595037474db1f96
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Mon Nov 18 17:02:45 2013 -0700

    PCI: Remove duplicate pci_disable_device() from pcie_portdrv_remove()
    
    The pcie_portdrv .probe() method calls pci_enable_device() once, in
    pcie_port_device_register(), but the .remove() method calls
    pci_disable_device() twice, in pcie_port_device_remove() and in
    pcie_portdrv_remove().
    
    That causes a "disabling already-disabled device" warning when removing a
    PCIe port device.  This happens all the time when removing Thunderbolt
    devices, but is also easy to reproduce with, e.g.,
    "echo 0000:00:1c.3 > /sys/bus/pci/drivers/pcieport/unbind"
    
    This patch removes the disable from pcie_portdrv_remove().
    
    [bhelgaas: changelog, tag for stable]
    Reported-by: David Bulkow <David.Bulkow@stratus.com>
    Reported-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    CC: stable@vger.kernel.org      # v2.6.32+

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index cd1e57e51aa7..0d8fdc48e642 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -223,7 +223,6 @@ static int pcie_portdrv_probe(struct pci_dev *dev,
 static void pcie_portdrv_remove(struct pci_dev *dev)
 {
 	pcie_port_device_remove(dev);
-	pci_disable_device(dev);
 }
 
 static int error_detected_iter(struct device *device, void *data)

commit f7625980f5820edd1a73536e1a03bcbc1f889fec
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Nov 14 11:28:18 2013 -0700

    PCI: Fix whitespace, capitalization, and spelling errors
    
    Fix whitespace, capitalization, and spelling errors.  No functional change.
    I know "busses" is not an error, but "buses" was more common, so I used it
    consistently.
    
    Signed-off-by: Marta Rybczynska <rybczynska@gmail.com> (pci_reset_bridge_secondary_bus())
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index 696caed5fdf5..cd1e57e51aa7 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -390,9 +390,9 @@ static struct pci_driver pcie_portdriver = {
 	.probe		= pcie_portdrv_probe,
 	.remove		= pcie_portdrv_remove,
 
-	.err_handler 	= &pcie_portdrv_err_handler,
+	.err_handler	= &pcie_portdrv_err_handler,
 
-	.driver.pm 	= PCIE_PORTDRV_PM_OPS,
+	.driver.pm	= PCIE_PORTDRV_PM_OPS,
 };
 
 static int __init dmi_pcie_pme_disable_msi(const struct dmi_system_id *d)
@@ -412,7 +412,7 @@ static struct dmi_system_id __initdata pcie_portdrv_dmi_table[] = {
 	 .ident = "MSI Wind U-100",
 	 .matches = {
 		     DMI_MATCH(DMI_SYS_VENDOR,
-		     		"MICRO-STAR INTERNATIONAL CO., LTD"),
+				"MICRO-STAR INTERNATIONAL CO., LTD"),
 		     DMI_MATCH(DMI_PRODUCT_NAME, "U-100"),
 		     },
 	 },

commit 96a3e8af5a54c324535472ca946215d5bafe6539
Merge: a87451052fb9 d4f09c5d7fba
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Apr 29 09:30:25 2013 -0700

    Merge tag 'pci-v3.10-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI updates from Bjorn Helgaas:
     "PCI changes for the v3.10 merge window:
    
      PCI device hotplug
       - Remove ACPI PCI subdrivers (Jiang Liu, Myron Stowe)
       - Make acpiphp builtin only, not modular (Jiang Liu)
       - Add acpiphp mutual exclusion (Jiang Liu)
    
      Power management
       - Skip "PME enabled/disabled" messages when not supported (Rafael
         Wysocki)
       - Fix fallback to PCI_D0 (Rafael Wysocki)
    
      Miscellaneous
       - Factor quirk_io_region (Yinghai Lu)
       - Cache MSI capability offsets & cleanup (Gavin Shan, Bjorn Helgaas)
       - Clean up EISA resource initialization and logging (Bjorn Helgaas)
       - Fix prototype warnings (Andy Shevchenko, Bjorn Helgaas)
       - MIPS: Initialize of_node before scanning bus (Gabor Juhos)
       - Fix pcibios_get_phb_of_node() declaration "weak" annotation (Gabor
         Juhos)
       - Add MSI INTX_DISABLE quirks for AR8161/AR8162/etc (Xiong Huang)
       - Fix aer_inject return values (Prarit Bhargava)
       - Remove PME/ACPI dependency (Andrew Murray)
       - Use shared PCI_BUS_NUM() and PCI_DEVID() (Shuah Khan)"
    
    * tag 'pci-v3.10-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (63 commits)
      vfio-pci: Use cached MSI/MSI-X capabilities
      vfio-pci: Use PCI_MSIX_TABLE_BIR, not PCI_MSIX_FLAGS_BIRMASK
      PCI: Remove "extern" from function declarations
      PCI: Use PCI_MSIX_TABLE_BIR, not PCI_MSIX_FLAGS_BIRMASK
      PCI: Drop msi_mask_reg() and remove drivers/pci/msi.h
      PCI: Use msix_table_size() directly, drop multi_msix_capable()
      PCI: Drop msix_table_offset_reg() and msix_pba_offset_reg() macros
      PCI: Drop is_64bit_address() and is_mask_bit_support() macros
      PCI: Drop msi_data_reg() macro
      PCI: Drop msi_lower_address_reg() and msi_upper_address_reg() macros
      PCI: Drop msi_control_reg() macro and use PCI_MSI_FLAGS directly
      PCI: Use cached MSI/MSI-X offsets from dev, not from msi_desc
      PCI: Clean up MSI/MSI-X capability #defines
      PCI: Use cached MSI-X cap while enabling MSI-X
      PCI: Use cached MSI cap while enabling MSI interrupts
      PCI: Remove MSI/MSI-X cap check in pci_msi_check_device()
      PCI: Cache MSI/MSI-X capability offsets in struct pci_dev
      PCI: Use u8, not int, for PM capability offset
      [SCSI] megaraid_sas: Use correct #define for MSI-X capability
      PCI: Remove "extern" from function declarations
      ...

commit b638d7e7b849ad402aaecfe7edb599687b5eb3a8
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Apr 12 11:18:01 2013 -0600

    PCI: Remove unused variables
    
    This fixes "set but not used" warnings found via "make W=1".
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index 08c243ab034e..0efba0539cc9 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -272,11 +272,9 @@ static pci_ers_result_t pcie_portdrv_error_detected(struct pci_dev *dev,
 					enum pci_channel_state error)
 {
 	struct aer_broadcast_data data = {error, PCI_ERS_RESULT_CAN_RECOVER};
-	int ret;
-
-	/* can not fail */
-	ret = device_for_each_child(&dev->dev, &data, error_detected_iter);
 
+	/* get true return value from &data */
+	device_for_each_child(&dev->dev, &data, error_detected_iter);
 	return data.result;
 }
 
@@ -308,10 +306,9 @@ static int mmio_enabled_iter(struct device *device, void *data)
 static pci_ers_result_t pcie_portdrv_mmio_enabled(struct pci_dev *dev)
 {
 	pci_ers_result_t status = PCI_ERS_RESULT_RECOVERED;
-	int retval;
 
 	/* get true return value from &status */
-	retval = device_for_each_child(&dev->dev, &status, mmio_enabled_iter);
+	device_for_each_child(&dev->dev, &status, mmio_enabled_iter);
 	return status;
 }
 
@@ -343,7 +340,6 @@ static int slot_reset_iter(struct device *device, void *data)
 static pci_ers_result_t pcie_portdrv_slot_reset(struct pci_dev *dev)
 {
 	pci_ers_result_t status = PCI_ERS_RESULT_RECOVERED;
-	int retval;
 
 	/* If fatal, restore cfg space for possible link reset at upstream */
 	if (dev->error_state == pci_channel_io_frozen) {
@@ -354,8 +350,7 @@ static pci_ers_result_t pcie_portdrv_slot_reset(struct pci_dev *dev)
 	}
 
 	/* get true return value from &status */
-	retval = device_for_each_child(&dev->dev, &status, slot_reset_iter);
-
+	device_for_each_child(&dev->dev, &status, slot_reset_iter);
 	return status;
 }
 
@@ -381,9 +376,7 @@ static int resume_iter(struct device *device, void *data)
 
 static void pcie_portdrv_err_resume(struct pci_dev *dev)
 {
-	int retval;
-	/* nothing to do with error value, if it ever happens */
-	retval = device_for_each_child(&dev->dev, NULL, resume_iter);
+	device_for_each_child(&dev->dev, NULL, resume_iter);
 }
 
 /*

commit de7d5f729c72638f41d7c17487bccb1c570ff144
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Mar 30 23:38:02 2013 +0100

    PCI/PM: Disable runtime PM of PCIe ports
    
    The runtime PM of PCIe ports turns out to be quite fragile, as in
    some cases things work while in some other cases they don't and we
    don't seem to have a good way to determine whether or not they are
    going to work in advance.
    
    For this reason, avoid enabling runtime PM for PCIe ports by
    keeping their runtime PM reference counters always above 0 for the
    time being.
    
    When a PCIe port is suspended, it can no longer report events like
    hotplug, so hotplug below the port may not work, as in the bug
    report below.
    
    [bhelgaas: changelog, stable]
    Reference: https://bugzilla.kernel.org/show_bug.cgi?id=53811
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    CC: stable@vger.kernel.org      # v3.6+

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index 08c243ab034e..ed4d09498337 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -184,14 +184,6 @@ static const struct dev_pm_ops pcie_portdrv_pm_ops = {
 #define PCIE_PORTDRV_PM_OPS	NULL
 #endif /* !PM */
 
-/*
- * PCIe port runtime suspend is broken for some chipsets, so use a
- * black list to disable runtime PM for these chipsets.
- */
-static const struct pci_device_id port_runtime_pm_black_list[] = {
-	{ /* end: all zeroes */ }
-};
-
 /*
  * pcie_portdrv_probe - Probe PCI-Express port devices
  * @dev: PCI-Express port device being probed
@@ -225,16 +217,11 @@ static int pcie_portdrv_probe(struct pci_dev *dev,
 	 * it by default.
 	 */
 	dev->d3cold_allowed = false;
-	if (!pci_match_id(port_runtime_pm_black_list, dev))
-		pm_runtime_put_noidle(&dev->dev);
-
 	return 0;
 }
 
 static void pcie_portdrv_remove(struct pci_dev *dev)
 {
-	if (!pci_match_id(port_runtime_pm_black_list, dev))
-		pm_runtime_get_noresume(&dev->dev);
 	pcie_port_device_remove(dev);
 	pci_disable_device(dev);
 }

commit c733b77475707cc3980542c86ee0ad5c841d544c
Author: Huang Ying <ying.huang@intel.com>
Date:   Wed Dec 26 10:39:23 2012 -0700

    PCI/PM: Do not suspend port if any subordinate device needs PME polling
    
    Ulrich reported that his USB3 cardreader does not work reliably when
    connected to the USB3 port.  It turns out that USB3 controller failed to
    awaken when plugging in the USB3 cardreader.  Further experiments found
    that the USB3 host controller can only be awakened via polling, not via PME
    interrupt.  But if the PCIe port to which the USB3 host controller is
    connected is suspended, we cannot poll the controller because its config
    space is not accessible when the PCIe port is in a low power state.
    
    To solve the issue, the PCIe port will not be suspended if any subordinate
    device needs PME polling.
    
    [bhelgaas: use bool consistently rather than mixing int/bool]
    Reference: http://lkml.kernel.org/r/50841CCC.9030809@uli-eckhardt.de
    Reported-by: Ulrich Eckhardt <usb@uli-eckhardt.de>
    Tested-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Huang Ying <ying.huang@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    CC: stable@vger.kernel.org      # v3.6+

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index d4824cb78b49..08c243ab034e 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -134,10 +134,28 @@ static int pcie_port_runtime_resume(struct device *dev)
 	return 0;
 }
 
+static int pci_dev_pme_poll(struct pci_dev *pdev, void *data)
+{
+	bool *pme_poll = data;
+
+	if (pdev->pme_poll)
+		*pme_poll = true;
+	return 0;
+}
+
 static int pcie_port_runtime_idle(struct device *dev)
 {
+	struct pci_dev *pdev = to_pci_dev(dev);
+	bool pme_poll = false;
+
+	/*
+	 * If any subordinate device needs pme poll, we should keep
+	 * the port in D0, because we need port in D0 to poll it.
+	 */
+	pci_walk_bus(pdev->subordinate, pci_dev_pme_poll, &pme_poll);
 	/* Delay for a short while to prevent too frequent suspend/resume */
-	pm_schedule_suspend(dev, 10);
+	if (!pme_poll)
+		pm_schedule_suspend(dev, 10);
 	return -EBUSY;
 }
 #else

commit 15856ad50bf5ea02a5ee22399c036d49e7e1124d
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Wed Nov 21 15:35:00 2012 -0500

    PCI: Remove __dev* markings
    
    CONFIG_HOTPLUG is going away as an option so __devexit_p, __devint,
    __devinitdata, __devinitconst, and _devexit are no longer needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index 0761d90ca279..d4824cb78b49 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -182,7 +182,7 @@ static const struct pci_device_id port_runtime_pm_black_list[] = {
  * this port device.
  *
  */
-static int __devinit pcie_portdrv_probe(struct pci_dev *dev,
+static int pcie_portdrv_probe(struct pci_dev *dev,
 					const struct pci_device_id *id)
 {
 	int status;

commit 78890b5989d96ddce989cde929c45ceeded0fcaf
Merge: 1959ec5f82ac 55d512e245bc
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Sep 13 08:41:01 2012 -0600

    Merge commit 'v3.6-rc5' into next
    
    * commit 'v3.6-rc5': (1098 commits)
      Linux 3.6-rc5
      HID: tpkbd: work even if the new Lenovo Keyboard driver is not configured
      Remove user-triggerable BUG from mpol_to_str
      xen/pciback: Fix proper FLR steps.
      uml: fix compile error in deliver_alarm()
      dj: memory scribble in logi_dj
      Fix order of arguments to compat_put_time[spec|val]
      xen: Use correct masking in xen_swiotlb_alloc_coherent.
      xen: fix logical error in tlb flushing
      xen/p2m: Fix one-off error in checking the P2M tree directory.
      powerpc: Don't use __put_user() in patch_instruction
      powerpc: Make sure IPI handlers see data written by IPI senders
      powerpc: Restore correct DSCR in context switch
      powerpc: Fix DSCR inheritance in copy_thread()
      powerpc: Keep thread.dscr and thread.dscr_inherit in sync
      powerpc: Update DSCR on all CPUs when writing sysfs dscr_default
      powerpc/powernv: Always go into nap mode when CPU is offline
      powerpc: Give hypervisor decrementer interrupts their own handler
      powerpc/vphn: Fix arch_update_cpu_topology() return value
      ARM: gemini: fix the gemini build
      ...
    
    Conflicts:
            drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c
            drivers/rapidio/devices/tsi721.c

commit 1959ec5f82acbdf91425b41600f119ebecb5f6a8
Merge: a63ab613ff48 1d3520357df9
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Sep 12 13:54:10 2012 -0600

    Merge branch 'pci/stephen-const' into next
    
    * pci/stephen-const:
      make drivers with pci error handlers const
      scsi: make pci error handlers const
      netdev: make pci_error_handlers const
      PCI: Make pci_error_handlers const

commit 494530284f16298050ab99f54b7b12dd7d1418a1
Author: Stephen Hemminger <shemminger@vyatta.com>
Date:   Fri Sep 7 09:33:14 2012 -0700

    PCI: Make pci_error_handlers const
    
    Since pci_error_handlers is just a function table make it const.
    
    Signed-off-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Linas Vepstas <linasvepstas@gmail.com>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index 3a7eefcb270a..943443510089 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -371,11 +371,11 @@ static const struct pci_device_id port_pci_ids[] = { {
 };
 MODULE_DEVICE_TABLE(pci, port_pci_ids);
 
-static struct pci_error_handlers pcie_portdrv_err_handler = {
-		.error_detected = pcie_portdrv_error_detected,
-		.mmio_enabled = pcie_portdrv_mmio_enabled,
-		.slot_reset = pcie_portdrv_slot_reset,
-		.resume = pcie_portdrv_err_resume,
+static const struct pci_error_handlers pcie_portdrv_err_handler = {
+	.error_detected = pcie_portdrv_error_detected,
+	.mmio_enabled = pcie_portdrv_mmio_enabled,
+	.slot_reset = pcie_portdrv_slot_reset,
+	.resume = pcie_portdrv_err_resume,
 };
 
 static struct pci_driver pcie_portdriver = {

commit 2dcfaf85cd0ced6dcfd4bf0012354b3fd2ed1f38
Author: Jiang Liu <jiang.liu@huawei.com>
Date:   Tue Jul 24 17:20:08 2012 +0800

    PCI/portdrv: Use PCI Express Capability accessors
    
    Use PCI Express Capability access functions to simplify portdrv.
    
    Signed-off-by: Jiang Liu <jiang.liu@huawei.com>
    Signed-off-by: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index 24d1463e688b..2360330e48f1 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -64,14 +64,7 @@ __setup("pcie_ports=", pcie_port_setup);
  */
 void pcie_clear_root_pme_status(struct pci_dev *dev)
 {
-	int rtsta_pos;
-	u32 rtsta;
-
-	rtsta_pos = pci_pcie_cap(dev) + PCI_EXP_RTSTA;
-
-	pci_read_config_dword(dev, rtsta_pos, &rtsta);
-	rtsta |= PCI_EXP_RTSTA_PME;
-	pci_write_config_dword(dev, rtsta_pos, rtsta);
+	pcie_capability_set_dword(dev, PCI_EXP_RTSTA, PCI_EXP_RTSTA_PME);
 }
 
 static int pcie_portdrv_restore_config(struct pci_dev *dev)

commit 62f87c0e31d646d5501edf4f7feb07d0ad689d80
Author: Yijing Wang <wangyijing@huawei.com>
Date:   Tue Jul 24 17:20:03 2012 +0800

    PCI: Introduce pci_pcie_type(dev) to replace pci_dev->pcie_type
    
    Introduce an inline function pci_pcie_type(dev) to extract PCIe
    device type from pci_dev->pcie_flags_reg field, and prepare for
    removing pci_dev->pcie_type.
    
    Signed-off-by: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Jiang Liu <jiang.liu@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index 3a7eefcb270a..24d1463e688b 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -95,7 +95,7 @@ static int pcie_port_resume_noirq(struct device *dev)
 	 * which breaks ACPI-based runtime wakeup on PCI Express, so clear those
 	 * bits now just in case (shouldn't hurt).
 	 */
-	if(pdev->pcie_type == PCI_EXP_TYPE_ROOT_PORT)
+	if (pci_pcie_type(pdev) == PCI_EXP_TYPE_ROOT_PORT)
 		pcie_clear_root_pme_status(pdev);
 	return 0;
 }
@@ -186,9 +186,9 @@ static int __devinit pcie_portdrv_probe(struct pci_dev *dev,
 	int status;
 
 	if (!pci_is_pcie(dev) ||
-	    ((dev->pcie_type != PCI_EXP_TYPE_ROOT_PORT) &&
-	     (dev->pcie_type != PCI_EXP_TYPE_UPSTREAM) &&
-	     (dev->pcie_type != PCI_EXP_TYPE_DOWNSTREAM)))
+	    ((pci_pcie_type(dev) != PCI_EXP_TYPE_ROOT_PORT) &&
+	     (pci_pcie_type(dev) != PCI_EXP_TYPE_UPSTREAM) &&
+	     (pci_pcie_type(dev) != PCI_EXP_TYPE_DOWNSTREAM)))
 		return -ENODEV;
 
 	if (!dev->irq && dev->pin) {

commit 3d8387efe1ad9eb5bfe8a2e58cdbd1b88b247eef
Author: Huang Ying <ying.huang@intel.com>
Date:   Wed Aug 15 09:43:03 2012 +0800

    PCI/PM: Fix config reg access for D3cold and bridge suspending
    
    This patch fixes the following bug:
    
    http://marc.info/?l=linux-pci&m=134338059022620&w=2
    
    Where lspci does not work properly if a device and the corresponding
    parent bridge (such as PCIe port) is suspended.  This is because the
    device configuration space registers will be not accessible if the
    corresponding parent bridge is suspended or the device is put into
    D3cold state.
    
    To solve the issue, the bridge/PCIe port connected to the device is
    put into active state before read/write configuration space registers.
    If the device is in D3cold state, it will be put into active state
    too.
    
    To avoid resume/suspend PCIe port for each configuration register
    read/write, a small delay is added before the PCIe port to go
    suspended.
    
    Reported-by: Bjorn Mork <bjorn@mork.no>
    Signed-off-by: Huang Ying <ying.huang@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index 62f5a76c8f80..e76b44777dbf 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -140,9 +140,17 @@ static int pcie_port_runtime_resume(struct device *dev)
 {
 	return 0;
 }
+
+static int pcie_port_runtime_idle(struct device *dev)
+{
+	/* Delay for a short while to prevent too frequent suspend/resume */
+	pm_schedule_suspend(dev, 10);
+	return -EBUSY;
+}
 #else
 #define pcie_port_runtime_suspend	NULL
 #define pcie_port_runtime_resume	NULL
+#define pcie_port_runtime_idle		NULL
 #endif
 
 static const struct dev_pm_ops pcie_portdrv_pm_ops = {
@@ -155,6 +163,7 @@ static const struct dev_pm_ops pcie_portdrv_pm_ops = {
 	.resume_noirq	= pcie_port_resume_noirq,
 	.runtime_suspend = pcie_port_runtime_suspend,
 	.runtime_resume = pcie_port_runtime_resume,
+	.runtime_idle	= pcie_port_runtime_idle,
 };
 
 #define PCIE_PORTDRV_PM_OPS	(&pcie_portdrv_pm_ops)

commit 4f9c1397e2e80e52b17ec4e39760caa807bd15c7
Author: Huang Ying <ying.huang@intel.com>
Date:   Wed Aug 8 09:07:38 2012 +0800

    PCI/PM: Enable D3/D3cold by default for most devices
    
    This patch fixes the following bug:
    
    http://marc.info/?l=linux-usb&m=134318961120825&w=2
    
    Originally, device lower power states include D1, D2, D3.  After that,
    D3 is further divided into D3hot and D3cold.  To support both scenario
    safely, original D3 is mapped to D3cold.
    
    When adding D3cold support, because worry about some device may have
    broken D3cold support, D3cold is disabled by default.  This disable D3
    on original platform too.  But some original platform may only have
    working D3, but no working D1, D2.  The root cause of the above bug is
    it too.
    
    To deal with this, this patch enables D3/D3cold by default for most
    devices.  This restores the original behavior.  For some devices that
    suspected to have broken D3cold support, such as PCIe port, D3cold is
    disabled by default.
    
    Reported-by: Bjorn Mork <bjorn@mork.no>
    Signed-off-by: Huang Ying <ying.huang@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index 3a7eefcb270a..62f5a76c8f80 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -200,6 +200,11 @@ static int __devinit pcie_portdrv_probe(struct pci_dev *dev,
 		return status;
 
 	pci_save_state(dev);
+	/*
+	 * D3cold may not work properly on some PCIe port, so disable
+	 * it by default.
+	 */
+	dev->d3cold_allowed = false;
 	if (!pci_match_id(port_runtime_pm_black_list, dev))
 		pm_runtime_put_noidle(&dev->dev);
 

commit 448bd857d48e69b33ef323739dc6d8ca20d4cda7
Author: Huang Ying <ying.huang@intel.com>
Date:   Sat Jun 23 10:23:51 2012 +0800

    PCI/PM: add PCIe runtime D3cold support
    
    This patch adds runtime D3cold support and corresponding ACPI platform
    support.  This patch only enables runtime D3cold support; it does not
    enable D3cold support during system suspend/hibernate.
    
    D3cold is the deepest power saving state for a PCIe device, where its main
    power is removed.  While it is in D3cold, you can't access the device at
    all, not even its configuration space (which is still accessible in D3hot).
    Therefore the PCI PM registers can not be used to transition into/out of
    the D3cold state; that must be done by platform logic such as ACPI _PR3.
    
    To support wakeup from D3cold, a system may provide auxiliary power, which
    allows a device to request wakeup using a Beacon or the sideband WAKE#
    signal.  WAKE# is usually connected to platform logic such as ACPI GPE.
    This is quite different from other power saving states, where devices
    request wakeup via a PME message on the PCIe link.
    
    Some devices, such as those in plug-in slots, have no direct platform
    logic.  For example, there is usually no ACPI _PR3 for them.  D3cold
    support for these devices can be done via the PCIe Downstream Port leading
    to the device.  When the PCIe port is powered on/off, the device is powered
    on/off too.  Wakeup events from the device will be notified to the
    corresponding PCIe port.
    
    For more information about PCIe D3cold and corresponding ACPI support,
    please refer to:
    
    - PCI Express Base Specification Revision 2.0
    - Advanced Configuration and Power Interface Specification Revision 5.0
    
    [bhelgaas: changelog]
    Reviewed-by: Rafael J. Wysocki <rjw@sisk.pl>
    Originally-by: Zheng Yan <zheng.z.yan@intel.com>
    Signed-off-by: Huang Ying <ying.huang@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index 7c576b9aa01d..3a7eefcb270a 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -101,12 +101,48 @@ static int pcie_port_resume_noirq(struct device *dev)
 }
 
 #ifdef CONFIG_PM_RUNTIME
-static int pcie_port_runtime_pm(struct device *dev)
+struct d3cold_info {
+	bool no_d3cold;
+	unsigned int d3cold_delay;
+};
+
+static int pci_dev_d3cold_info(struct pci_dev *pdev, void *data)
+{
+	struct d3cold_info *info = data;
+
+	info->d3cold_delay = max_t(unsigned int, pdev->d3cold_delay,
+				   info->d3cold_delay);
+	if (pdev->no_d3cold)
+		info->no_d3cold = true;
+	return 0;
+}
+
+static int pcie_port_runtime_suspend(struct device *dev)
+{
+	struct pci_dev *pdev = to_pci_dev(dev);
+	struct d3cold_info d3cold_info = {
+		.no_d3cold	= false,
+		.d3cold_delay	= PCI_PM_D3_WAIT,
+	};
+
+	/*
+	 * If any subordinate device disable D3cold, we should not put
+	 * the port into D3cold.  The D3cold delay of port should be
+	 * the max of that of all subordinate devices.
+	 */
+	pci_walk_bus(pdev->subordinate, pci_dev_d3cold_info, &d3cold_info);
+	pdev->no_d3cold = d3cold_info.no_d3cold;
+	pdev->d3cold_delay = d3cold_info.d3cold_delay;
+	return 0;
+}
+
+static int pcie_port_runtime_resume(struct device *dev)
 {
 	return 0;
 }
 #else
-#define pcie_port_runtime_pm	NULL
+#define pcie_port_runtime_suspend	NULL
+#define pcie_port_runtime_resume	NULL
 #endif
 
 static const struct dev_pm_ops pcie_portdrv_pm_ops = {
@@ -117,8 +153,8 @@ static const struct dev_pm_ops pcie_portdrv_pm_ops = {
 	.poweroff	= pcie_port_device_suspend,
 	.restore	= pcie_port_device_resume,
 	.resume_noirq	= pcie_port_resume_noirq,
-	.runtime_suspend = pcie_port_runtime_pm,
-	.runtime_resume = pcie_port_runtime_pm,
+	.runtime_suspend = pcie_port_runtime_suspend,
+	.runtime_resume = pcie_port_runtime_resume,
 };
 
 #define PCIE_PORTDRV_PM_OPS	(&pcie_portdrv_pm_ops)

commit 71a83bd727cc31c5fe960c3758cb396267ff710e
Author: Zheng Yan <zheng.z.yan@intel.com>
Date:   Sat Jun 23 10:23:49 2012 +0800

    PCI/PM: add runtime PM support to PCIe port
    
    This patch adds runtime PM support to PCIe port.  This is needed by
    PCIe D3cold support, where PCIe device without ACPI node may be
    powered on/off by PCIe port.
    
    Because runtime suspend is broken for some chipsets, a black list is
    used to disable runtime PM support for these chipsets.
    
    Reviewed-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Zheng Yan <zheng.z.yan@intel.com>
    Signed-off-by: Huang Ying <ying.huang@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index e0610bda1dea..7c576b9aa01d 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -11,6 +11,7 @@
 #include <linux/kernel.h>
 #include <linux/errno.h>
 #include <linux/pm.h>
+#include <linux/pm_runtime.h>
 #include <linux/init.h>
 #include <linux/pcieport_if.h>
 #include <linux/aer.h>
@@ -99,6 +100,15 @@ static int pcie_port_resume_noirq(struct device *dev)
 	return 0;
 }
 
+#ifdef CONFIG_PM_RUNTIME
+static int pcie_port_runtime_pm(struct device *dev)
+{
+	return 0;
+}
+#else
+#define pcie_port_runtime_pm	NULL
+#endif
+
 static const struct dev_pm_ops pcie_portdrv_pm_ops = {
 	.suspend	= pcie_port_device_suspend,
 	.resume		= pcie_port_device_resume,
@@ -107,6 +117,8 @@ static const struct dev_pm_ops pcie_portdrv_pm_ops = {
 	.poweroff	= pcie_port_device_suspend,
 	.restore	= pcie_port_device_resume,
 	.resume_noirq	= pcie_port_resume_noirq,
+	.runtime_suspend = pcie_port_runtime_pm,
+	.runtime_resume = pcie_port_runtime_pm,
 };
 
 #define PCIE_PORTDRV_PM_OPS	(&pcie_portdrv_pm_ops)
@@ -116,6 +128,14 @@ static const struct dev_pm_ops pcie_portdrv_pm_ops = {
 #define PCIE_PORTDRV_PM_OPS	NULL
 #endif /* !PM */
 
+/*
+ * PCIe port runtime suspend is broken for some chipsets, so use a
+ * black list to disable runtime PM for these chipsets.
+ */
+static const struct pci_device_id port_runtime_pm_black_list[] = {
+	{ /* end: all zeroes */ }
+};
+
 /*
  * pcie_portdrv_probe - Probe PCI-Express port devices
  * @dev: PCI-Express port device being probed
@@ -144,12 +164,16 @@ static int __devinit pcie_portdrv_probe(struct pci_dev *dev,
 		return status;
 
 	pci_save_state(dev);
+	if (!pci_match_id(port_runtime_pm_black_list, dev))
+		pm_runtime_put_noidle(&dev->dev);
 
 	return 0;
 }
 
 static void pcie_portdrv_remove(struct pci_dev *dev)
 {
+	if (!pci_match_id(port_runtime_pm_black_list, dev))
+		pm_runtime_get_noresume(&dev->dev);
 	pcie_port_device_remove(dev);
 	pci_disable_device(dev);
 }

commit fe31e69740eddc7316071ed5165fed6703c8cd12
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Dec 19 15:57:16 2010 +0100

    PCI/PCIe: Clear Root PME Status bits early during system resume
    
    I noticed that PCI Express PMEs don't work on my Toshiba Portege R500
    after the system has been woken up from a sleep state by a PME
    (through Wake-on-LAN).  After some investigation it turned out that
    the BIOS didn't clear the Root PME Status bit in the root port that
    received the wakeup PME and since the Requester ID was also set in
    the port's Root Status register, any subsequent PMEs didn't trigger
    interrupts.
    
    This problem can be avoided by clearing the Root PME Status bits in
    all PCI Express root ports during early resume.  For this purpose,
    add an early resume routine to the PCIe port driver and make this
    driver be always registered, even if pci_ports_disable is set (in
    which case the driver's only function is to provide the early
    resume callback).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index f9033e190fb6..e0610bda1dea 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -57,6 +57,22 @@ __setup("pcie_ports=", pcie_port_setup);
 
 /* global data */
 
+/**
+ * pcie_clear_root_pme_status - Clear root port PME interrupt status.
+ * @dev: PCIe root port or event collector.
+ */
+void pcie_clear_root_pme_status(struct pci_dev *dev)
+{
+	int rtsta_pos;
+	u32 rtsta;
+
+	rtsta_pos = pci_pcie_cap(dev) + PCI_EXP_RTSTA;
+
+	pci_read_config_dword(dev, rtsta_pos, &rtsta);
+	rtsta |= PCI_EXP_RTSTA_PME;
+	pci_write_config_dword(dev, rtsta_pos, rtsta);
+}
+
 static int pcie_portdrv_restore_config(struct pci_dev *dev)
 {
 	int retval;
@@ -69,6 +85,20 @@ static int pcie_portdrv_restore_config(struct pci_dev *dev)
 }
 
 #ifdef CONFIG_PM
+static int pcie_port_resume_noirq(struct device *dev)
+{
+	struct pci_dev *pdev = to_pci_dev(dev);
+
+	/*
+	 * Some BIOSes forget to clear Root PME Status bits after system wakeup
+	 * which breaks ACPI-based runtime wakeup on PCI Express, so clear those
+	 * bits now just in case (shouldn't hurt).
+	 */
+	if(pdev->pcie_type == PCI_EXP_TYPE_ROOT_PORT)
+		pcie_clear_root_pme_status(pdev);
+	return 0;
+}
+
 static const struct dev_pm_ops pcie_portdrv_pm_ops = {
 	.suspend	= pcie_port_device_suspend,
 	.resume		= pcie_port_device_resume,
@@ -76,6 +106,7 @@ static const struct dev_pm_ops pcie_portdrv_pm_ops = {
 	.thaw		= pcie_port_device_resume,
 	.poweroff	= pcie_port_device_suspend,
 	.restore	= pcie_port_device_resume,
+	.resume_noirq	= pcie_port_resume_noirq,
 };
 
 #define PCIE_PORTDRV_PM_OPS	(&pcie_portdrv_pm_ops)
@@ -327,10 +358,8 @@ static int __init pcie_portdrv_init(void)
 {
 	int retval;
 
-	if (pcie_ports_disabled) {
-		pcie_no_aspm();
-		return -EACCES;
-	}
+	if (pcie_ports_disabled)
+		return pci_register_driver(&pcie_portdriver);
 
 	dmi_check_system(pcie_portdrv_dmi_table);
 

commit a9d2a6df11f5b9dc19ad4147374e8b67c4438158
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Sat Aug 21 01:59:10 2010 +0200

    PCI: PCIe: Remove the port driver module exit routine
    
    The PCIe port driver's module exit routine is never used, so drop it.
    
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Reviewed-by: Hidetoshi Seto <seto.hidetoshi@jp.fujitsu.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index 8f1338d1c53f..f9033e190fb6 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -346,11 +346,4 @@ static int __init pcie_portdrv_init(void)
 	return retval;
 }
 
-static void __exit pcie_portdrv_exit(void)
-{
-	pci_unregister_driver(&pcie_portdriver);
-	pcie_port_bus_unregister();
-}
-
 module_init(pcie_portdrv_init);
-module_exit(pcie_portdrv_exit);

commit 28eb5f274a305bf3a13b2c80c4804d4515d05c64
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sat Aug 21 22:02:38 2010 +0200

    PCI: PCIe: Ask BIOS for control of all native services at once
    
    After commit 852972acff8f10f3a15679be2059bb94916cba5d (ACPI: Disable
    ASPM if the platform won't provide _OSC control for PCIe) control of
    the PCIe Capability Structure is unconditionally requested by
    acpi_pci_root_add(), which in principle may cause problems to
    happen in two ways.  First, the BIOS may refuse to give control of
    the PCIe Capability Structure if it is not asked for any of the
    _OSC features depending on it at the same time.  Second, the BIOS may
    assume that control of the _OSC features depending on the PCIe
    Capability Structure will be requested in the future and may behave
    incorrectly if that doesn't happen.  For this reason, control of
    the PCIe Capability Structure should always be requested along with
    control of any other _OSC features that may depend on it (ie. PCIe
    native PME, PCIe native hot-plug, PCIe AER).
    
    Rework the PCIe port driver so that (1) it checks which native PCIe
    port services can be enabled, according to the BIOS, and (2) it
    requests control of all these services simultaneously.  In
    particular, this causes pcie_portdrv_probe() to fail if the BIOS
    refuses to grant control of the PCIe Capability Structure, which
    means that no native PCIe port services can be enabled for the PCIe
    Root Complex the given port belongs to.  If that happens, ASPM is
    disabled to avoid problems with mishandling it by the part of the
    PCIe hierarchy for which control of the PCIe Capability Structure
    has not been received.
    
    Make it possible to override this behavior using 'pcie_ports=native'
    (use the PCIe native services regardless of the BIOS response to the
    control request), or 'pcie_ports=compat' (do not use the PCIe native
    services at all).
    
    Accordingly, rework the existing PCIe port service drivers so that
    they don't request control of the services directly.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index a04392da6ce1..8f1338d1c53f 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -15,6 +15,7 @@
 #include <linux/pcieport_if.h>
 #include <linux/aer.h>
 #include <linux/dmi.h>
+#include <linux/pci-aspm.h>
 
 #include "portdrv.h"
 #include "aer/aerdrv.h"
@@ -32,10 +33,23 @@ MODULE_LICENSE("GPL");
 /* If this switch is set, PCIe port native services should not be enabled. */
 bool pcie_ports_disabled;
 
+/*
+ * If this switch is set, ACPI _OSC will be used to determine whether or not to
+ * enable PCIe port native services.
+ */
+bool pcie_ports_auto = true;
+
 static int __init pcie_port_setup(char *str)
 {
-	if (!strncmp(str, "compat", 6))
+	if (!strncmp(str, "compat", 6)) {
 		pcie_ports_disabled = true;
+	} else if (!strncmp(str, "native", 6)) {
+		pcie_ports_disabled = false;
+		pcie_ports_auto = false;
+	} else if (!strncmp(str, "auto", 4)) {
+		pcie_ports_disabled = false;
+		pcie_ports_auto = true;
+	}
 
 	return 1;
 }
@@ -313,8 +327,10 @@ static int __init pcie_portdrv_init(void)
 {
 	int retval;
 
-	if (pcie_ports_disabled)
+	if (pcie_ports_disabled) {
+		pcie_no_aspm();
 		return -EACCES;
+	}
 
 	dmi_check_system(pcie_portdrv_dmi_table);
 

commit 79dd9182db2072d63ccf160bb9a3463b1c952723
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sat Aug 21 01:51:44 2010 +0200

    PCI: PCIe: Introduce commad line switch for disabling port services
    
    Introduce kernel command line switch pcie_ports= allowing one to
    disable all of the native PCIe port services, so that PCIe ports
    are treated like PCI-to-PCI bridges.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index 3debed25e46b..a04392da6ce1 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -29,6 +29,18 @@ MODULE_AUTHOR(DRIVER_AUTHOR);
 MODULE_DESCRIPTION(DRIVER_DESC);
 MODULE_LICENSE("GPL");
 
+/* If this switch is set, PCIe port native services should not be enabled. */
+bool pcie_ports_disabled;
+
+static int __init pcie_port_setup(char *str)
+{
+	if (!strncmp(str, "compat", 6))
+		pcie_ports_disabled = true;
+
+	return 1;
+}
+__setup("pcie_ports=", pcie_port_setup);
+
 /* global data */
 
 static int pcie_portdrv_restore_config(struct pci_dev *dev)
@@ -301,6 +313,9 @@ static int __init pcie_portdrv_init(void)
 {
 	int retval;
 
+	if (pcie_ports_disabled)
+		return -EACCES;
+
 	dmi_check_system(pcie_portdrv_dmi_table);
 
 	retval = pcie_port_bus_register();

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index 127e8f169d9c..3debed25e46b 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -12,7 +12,6 @@
 #include <linux/errno.h>
 #include <linux/pm.h>
 #include <linux/init.h>
-#include <linux/slab.h>
 #include <linux/pcieport_if.h>
 #include <linux/aer.h>
 #include <linux/dmi.h>

commit c39fae1416d59fd565606793f090cebe3720d50d
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Feb 17 23:40:07 2010 +0100

    PCI PM: Make it possible to force using INTx for PCIe PME signaling
    
    Apparently, some machines may have problems with PCI run-time power
    management if MSIs are used for the native PCIe PME signaling.  In
    particular, on the MSI Wind U-100 PCIe PME interrupts are not
    generated by a PCIe root port after a resume from suspend to RAM, if
    the system wake-up was triggered by a PME from the device attached to
    this port.  [It doesn't help to free the interrupt on suspend and
    request it back on resume, even if that is done along with disabling
    the MSI and re-enabling it, respectively.]  However, if INTx
    interrupts are used for this purpose on the same machine, everything
    works just fine.
    
    For this reason, add a kernel command line switch allowing one to
    request that MSIs be not used for the native PCIe PME signaling,
    introduce a DMI table allowing us to blacklist machines that need
    this switch to be set by default and put the MSI Wind U-100 into this
    table.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index 13c8972886e6..127e8f169d9c 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -15,6 +15,7 @@
 #include <linux/slab.h>
 #include <linux/pcieport_if.h>
 #include <linux/aer.h>
+#include <linux/dmi.h>
 
 #include "portdrv.h"
 #include "aer/aerdrv.h"
@@ -273,10 +274,36 @@ static struct pci_driver pcie_portdriver = {
 	.driver.pm 	= PCIE_PORTDRV_PM_OPS,
 };
 
+static int __init dmi_pcie_pme_disable_msi(const struct dmi_system_id *d)
+{
+	pr_notice("%s detected: will not use MSI for PCIe PME signaling\n",
+			d->ident);
+	pcie_pme_disable_msi();
+	return 0;
+}
+
+static struct dmi_system_id __initdata pcie_portdrv_dmi_table[] = {
+	/*
+	 * Boxes that should not use MSI for PCIe PME signaling.
+	 */
+	{
+	 .callback = dmi_pcie_pme_disable_msi,
+	 .ident = "MSI Wind U-100",
+	 .matches = {
+		     DMI_MATCH(DMI_SYS_VENDOR,
+		     		"MICRO-STAR INTERNATIONAL CO., LTD"),
+		     DMI_MATCH(DMI_PRODUCT_NAME, "U-100"),
+		     },
+	 },
+	 {}
+};
+
 static int __init pcie_portdrv_init(void)
 {
 	int retval;
 
+	dmi_check_system(pcie_portdrv_dmi_table);
+
 	retval = pcie_port_bus_register();
 	if (retval) {
 		printk(KERN_WARNING "PCIE: bus_register error: %d\n", retval);

commit 40da4186a53e59d801130156ecb89fc5830ff227
Author: Hidetoshi Seto <seto.hidetoshi@jp.fujitsu.com>
Date:   Tue Dec 15 11:38:04 2009 +0900

    PCI: pcie portdrv: style cleanup
    
    No change in logic.
    
    Before:
      drivers/pci/pcie/portdrv_core.c:
        total: 7 errors, 2 warnings, 508 lines checked
      drivers/pci/pcie/portdrv_pci.c:
        total: 4 errors, 2 warnings, 300 lines checked
    
    After:
      drivers/pci/pcie/portdrv_core.c:
        total: 0 errors, 0 warnings, 506 lines checked
      drivers/pci/pcie/portdrv_pci.c:
        total: 0 errors, 0 warnings, 299 lines checked
    
    Signed-off-by: Hidetoshi Seto <seto.hidetoshi@jp.fujitsu.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index 34d65172a4d7..13c8972886e6 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -63,7 +63,7 @@ static const struct dev_pm_ops pcie_portdrv_pm_ops = {
  * pcie_portdrv_probe - Probe PCI-Express port devices
  * @dev: PCI-Express port device being probed
  *
- * If detected invokes the pcie_port_device_register() method for 
+ * If detected invokes the pcie_port_device_register() method for
  * this port device.
  *
  */
@@ -78,7 +78,7 @@ static int __devinit pcie_portdrv_probe(struct pci_dev *dev,
 	     (dev->pcie_type != PCI_EXP_TYPE_DOWNSTREAM)))
 		return -ENODEV;
 
-        if (!dev->irq && dev->pin) {
+	if (!dev->irq && dev->pin) {
 		dev_warn(&dev->dev, "device [%04x:%04x] has invalid IRQ; "
 			 "check vendor BIOS\n", dev->vendor, dev->device);
 	}
@@ -91,7 +91,7 @@ static int __devinit pcie_portdrv_probe(struct pci_dev *dev,
 	return 0;
 }
 
-static void pcie_portdrv_remove (struct pci_dev *dev)
+static void pcie_portdrv_remove(struct pci_dev *dev)
 {
 	pcie_port_device_remove(dev);
 	pci_disable_device(dev);
@@ -129,14 +129,13 @@ static int error_detected_iter(struct device *device, void *data)
 static pci_ers_result_t pcie_portdrv_error_detected(struct pci_dev *dev,
 					enum pci_channel_state error)
 {
-	struct aer_broadcast_data result_data =
-			{error, PCI_ERS_RESULT_CAN_RECOVER};
-	int retval;
+	struct aer_broadcast_data data = {error, PCI_ERS_RESULT_CAN_RECOVER};
+	int ret;
 
 	/* can not fail */
-	retval = device_for_each_child(&dev->dev, &result_data, error_detected_iter);
+	ret = device_for_each_child(&dev->dev, &data, error_detected_iter);
 
-	return result_data.result;
+	return data.result;
 }
 
 static int mmio_enabled_iter(struct device *device, void *data)
@@ -290,7 +289,7 @@ static int __init pcie_portdrv_init(void)
 	return retval;
 }
 
-static void __exit pcie_portdrv_exit(void) 
+static void __exit pcie_portdrv_exit(void)
 {
 	pci_unregister_driver(&pcie_portdriver);
 	pcie_port_bus_unregister();

commit 7e8af37a9a71b479f58d2fd5f0ddaa6780c51f11
Author: Stefan Assmann <sassmann@redhat.com>
Date:   Thu Dec 3 18:00:10 2009 +0100

    PCI: change PCI nomenclature in drivers/pci/ (non-comment changes)
    
    Changing occurrences of variants of PCI-X and PCIe to the PCI-SIG
    terms listed in the "Trademark and Logo Usage Guidelines".
    http://www.pcisig.com/developers/procedures/logos/Trademark_and_Logo_Usage_Guidelines_updated_112206.pdf
    
    Patch is limited to drivers/pci/ and changes concern non-comment parts or
    anything that might be visible to the user.
    
    Signed-off-by: Stefan Assmann <sassmann@redhat.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index a49452e2aed9..34d65172a4d7 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -24,7 +24,7 @@
  */
 #define DRIVER_VERSION "v1.0"
 #define DRIVER_AUTHOR "tom.l.nguyen@intel.com"
-#define DRIVER_DESC "PCIE Port Bus Driver"
+#define DRIVER_DESC "PCIe Port Bus Driver"
 MODULE_AUTHOR(DRIVER_AUTHOR);
 MODULE_DESCRIPTION(DRIVER_DESC);
 MODULE_LICENSE("GPL");

commit 471452104b8520337ae2fb48c4e61cd4896e025d
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Mon Dec 14 18:00:08 2009 -0800

    const: constify remaining dev_pm_ops
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index ce52ea34fee5..a49452e2aed9 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -43,7 +43,7 @@ static int pcie_portdrv_restore_config(struct pci_dev *dev)
 }
 
 #ifdef CONFIG_PM
-static struct dev_pm_ops pcie_portdrv_pm_ops = {
+static const struct dev_pm_ops pcie_portdrv_pm_ops = {
 	.suspend	= pcie_port_device_suspend,
 	.resume		= pcie_port_device_resume,
 	.freeze		= pcie_port_device_suspend,

commit 898294c97500b1cdff6edce52fd34e024eb070ec
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Wed Nov 25 21:00:53 2009 +0900

    PCI: portdrv: remove redundant pcie_port_device_probe
    
    We don't need pcie_port_device_probe() because we can get pci
    device/port type using pci_is_pcie() and 'pcie_type' fields in struct
    pci_dev. Remove pcie_port_device_probe().
    
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index f635e476d632..ce52ea34fee5 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -67,14 +67,16 @@ static struct dev_pm_ops pcie_portdrv_pm_ops = {
  * this port device.
  *
  */
-static int __devinit pcie_portdrv_probe (struct pci_dev *dev, 
-				const struct pci_device_id *id )
+static int __devinit pcie_portdrv_probe(struct pci_dev *dev,
+					const struct pci_device_id *id)
 {
-	int			status;
+	int status;
 
-	status = pcie_port_device_probe(dev);
-	if (status)
-		return status;
+	if (!pci_is_pcie(dev) ||
+	    ((dev->pcie_type != PCI_EXP_TYPE_ROOT_PORT) &&
+	     (dev->pcie_type != PCI_EXP_TYPE_UPSTREAM) &&
+	     (dev->pcie_type != PCI_EXP_TYPE_DOWNSTREAM)))
+		return -ENODEV;
 
         if (!dev->irq && dev->pin) {
 		dev_warn(&dev->dev, "device [%04x:%04x] has invalid IRQ; "

commit e3fb20f9c8783d6e27cf84389a9606e410733eef
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Oct 5 16:47:34 2009 -0600

    PCI: PCIe portdrv: remove "-driver" from driver name
    
    No need to include "-driver" in the driver name.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    CC: Tom Long Nguyen <tom.l.nguyen@intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index 6df5c984a791..f635e476d632 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -30,7 +30,6 @@ MODULE_DESCRIPTION(DRIVER_DESC);
 MODULE_LICENSE("GPL");
 
 /* global data */
-static const char device_name[] = "pcieport-driver";
 
 static int pcie_portdrv_restore_config(struct pci_dev *dev)
 {
@@ -262,7 +261,7 @@ static struct pci_error_handlers pcie_portdrv_err_handler = {
 };
 
 static struct pci_driver pcie_portdriver = {
-	.name		= (char *)device_name,
+	.name		= "pcieport",
 	.id_table	= &port_pci_ids[0],
 
 	.probe		= pcie_portdrv_probe,

commit e9d8288871efa0d98a1d1d1f17976b5b00a0234d
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Sep 14 22:25:11 2009 +0200

    PCI / PCIe portdrv: Fix pcie_portdrv_slot_reset()
    
    After commit c82f63e411f1b58427c103bd95af2863b1c96dd1
    (PCI: check saved state before restore) pcie_portdrv_slot_reset()
    may not work correctly if dev->error_state is equal to
    pci_channel_io_frozen, because dev->state_saved need not be set at
    that time.  Fix this issue by setting dev->state_saved before
    pci_restore_state() is called in pcie_portdrv_slot_reset().
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index 091ce70051e0..6df5c984a791 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -205,6 +205,7 @@ static pci_ers_result_t pcie_portdrv_slot_reset(struct pci_dev *dev)
 
 	/* If fatal, restore cfg space for possible link reset at upstream */
 	if (dev->error_state == pci_channel_io_frozen) {
+		dev->state_saved = true;
 		pci_restore_state(dev);
 		pcie_portdrv_restore_config(dev);
 		pci_enable_pcie_error_reporting(dev);

commit 029091df01116aff8dea89ce96a0a2534401803a
Author: Zhang, Yanmin <yanmin_zhang@linux.intel.com>
Date:   Thu Apr 30 14:48:29 2009 +0800

    PCI: Fix pci-e port driver slot_reset bad default return value
    
    When an upstream port reports an AER error to root port, kernel
    starts error recovery procedures. The default return value of
    function pcie_portdrv_slot_reset is PCI_ERS_RESULT_NONE. If all
    port service drivers of the downstream port under the upstream
    port have no slot_reset method in pci_error_handlers, AER recovery
    would stop without resume. Below patch against 2.6.30-rc3 fixes it.
    
    Signed-off-by: Zhang Yanmin <yanmin.zhang@linux.intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index b924e2463f85..091ce70051e0 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -200,7 +200,7 @@ static int slot_reset_iter(struct device *device, void *data)
 
 static pci_ers_result_t pcie_portdrv_slot_reset(struct pci_dev *dev)
 {
-	pci_ers_result_t status = PCI_ERS_RESULT_NONE;
+	pci_ers_result_t status = PCI_ERS_RESULT_RECOVERED;
 	int retval;
 
 	/* If fatal, restore cfg space for possible link reset at upstream */

commit 9efb5fe1b80a45130ba659ba755f24534c83301b
Author: Alex Chiang <achiang@hp.com>
Date:   Mon Mar 9 12:08:15 2009 -0600

    PCI: PCIe portdrv: eliminate double kfree in remove path
    
    Commit 55633af3 (PCIe portdrv: Use driver data to simplify code)
    added a kfree of the driver private data in pcie_port_device_remove
    but forgot to remove the old kfree from pcie_portdrv_remove.
    
    Acked-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Alex Chiang <achiang@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index a61f4930d676..b924e2463f85 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -94,7 +94,6 @@ static void pcie_portdrv_remove (struct pci_dev *dev)
 {
 	pcie_port_device_remove(dev);
 	pci_disable_device(dev);
-	kfree(pci_get_drvdata(dev));
 }
 
 static int error_detected_iter(struct device *device, void *data)

commit 3a3c244c9a355105bc193fde873c73727bf87192
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Feb 15 22:32:48 2009 +0100

    PCI: PCIe portdrv: Implement pm object
    
    Implement pm object for the PCI Express port driver in order to use
    the new power management framework and reduce the code size.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index 94d0e2af9bad..a61f4930d676 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -44,21 +44,21 @@ static int pcie_portdrv_restore_config(struct pci_dev *dev)
 }
 
 #ifdef CONFIG_PM
-static int pcie_portdrv_suspend(struct pci_dev *dev, pm_message_t state)
-{
-	return pcie_port_device_suspend(dev, state);
+static struct dev_pm_ops pcie_portdrv_pm_ops = {
+	.suspend	= pcie_port_device_suspend,
+	.resume		= pcie_port_device_resume,
+	.freeze		= pcie_port_device_suspend,
+	.thaw		= pcie_port_device_resume,
+	.poweroff	= pcie_port_device_suspend,
+	.restore	= pcie_port_device_resume,
+};
 
-}
+#define PCIE_PORTDRV_PM_OPS	(&pcie_portdrv_pm_ops)
 
-static int pcie_portdrv_resume(struct pci_dev *dev)
-{
-	pci_set_master(dev);
-	return pcie_port_device_resume(dev);
-}
-#else
-#define pcie_portdrv_suspend NULL
-#define pcie_portdrv_resume NULL
-#endif
+#else /* !PM */
+
+#define PCIE_PORTDRV_PM_OPS	NULL
+#endif /* !PM */
 
 /*
  * pcie_portdrv_probe - Probe PCI-Express port devices
@@ -268,10 +268,9 @@ static struct pci_driver pcie_portdriver = {
 	.probe		= pcie_portdrv_probe,
 	.remove		= pcie_portdrv_remove,
 
-	.suspend	= pcie_portdrv_suspend,
-	.resume		= pcie_portdrv_resume,
-
 	.err_handler 	= &pcie_portdrv_err_handler,
+
+	.driver.pm 	= PCIE_PORTDRV_PM_OPS,
 };
 
 static int __init pcie_portdrv_init(void)

commit 87d2e2ecf6026efa64b01f7f71802b20da736d35
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Jan 13 14:43:07 2009 +0100

    PCI: PCIe portdrv: Remove unnecessary function
    
    The function pcie_portdrv_save_config() in portdrv_pci.c is not
    necessary.  Remove it.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index d17611f390bd..94d0e2af9bad 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -32,11 +32,6 @@ MODULE_LICENSE("GPL");
 /* global data */
 static const char device_name[] = "pcieport-driver";
 
-static int pcie_portdrv_save_config(struct pci_dev *dev)
-{
-	return pci_save_state(dev);
-}
-
 static int pcie_portdrv_restore_config(struct pci_dev *dev)
 {
 	int retval;
@@ -90,7 +85,7 @@ static int __devinit pcie_portdrv_probe (struct pci_dev *dev,
 	if (status)
 		return status;
 
-	pcie_portdrv_save_config(dev);
+	pci_save_state(dev);
 
 	return 0;
 }

commit f118c0c3cff4fed39bde1863f9d59850719645cc
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Jan 13 14:42:01 2009 +0100

    PCI: PCIe portdrv: Do not enable port device before setting up interrupts
    
    The PCI Express port driver calls pci_enable_device() before setting
    up interrupts, which is wrong, because if there is an interrupt pin
    configured for the port, pci_enable_device() will likely set up an
    interrupt link for it.  However, this shouldn't be done if either
    MSI or MSI-X interrupt mode is chosen for the port.
    
    The solution is to call pci_enable_device() after setting up
    interrupts, because in that case the interrupt link won't be set up
    if MSI or MSI-X are enabled.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index 5ea566e20b37..d17611f390bd 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -82,18 +82,13 @@ static int __devinit pcie_portdrv_probe (struct pci_dev *dev,
 	if (status)
 		return status;
 
-	if (pci_enable_device(dev) < 0) 
-		return -ENODEV;
-	
-	pci_set_master(dev);
         if (!dev->irq && dev->pin) {
 		dev_warn(&dev->dev, "device [%04x:%04x] has invalid IRQ; "
 			 "check vendor BIOS\n", dev->vendor, dev->device);
 	}
-	if (pcie_port_device_register(dev)) {
-		pci_disable_device(dev);
-		return -ENOMEM;
-	}
+	status = pcie_port_device_register(dev);
+	if (status)
+		return status;
 
 	pcie_portdrv_save_config(dev);
 

commit d89987193631bf23d1735c55d13a06d4b8d0e9bd
Author: Alex Chiang <achiang@hp.com>
Date:   Sat Mar 7 19:35:47 2009 -0700

    PCIe: portdrv: call pci_disable_device during remove
    
    The PCIe port driver calls pci_enable_device() during probe but
    never calls pci_disable_device() during remove.
    
    Cc: stable@kernel.org
    Signed-off-by: Alex Chiang <achiang@hp.com>
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index 248b4db91552..5ea566e20b37 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -103,6 +103,7 @@ static int __devinit pcie_portdrv_probe (struct pci_dev *dev,
 static void pcie_portdrv_remove (struct pci_dev *dev)
 {
 	pcie_port_device_remove(dev);
+	pci_disable_device(dev);
 	kfree(pci_get_drvdata(dev));
 }
 

commit 1f9f13c8d59c1d8da1a602b71d1ab96d1d37d69e
Author: Andrew Patterson <andrew.patterson@hp.com>
Date:   Fri Feb 20 16:04:59 2009 -0700

    PCI: Enable PCIe AER only after checking firmware support
    
    The PCIe port driver currently sets the PCIe AER error reporting bits for
    any root or switch port without first checking to see if firmware will grant
    control. This patch moves setting these bits to the AER service driver
    aer_enable_port routine.  The bits are then set for the root port and any
    downstream switch ports after the check for firmware support (aer_osc_setup)
    is made. The patch also unsets the bits in a similar fashion when the AER
    service driver is unloaded.
    
    Reviewed-by: Alex Chiang <achiang@hp.com>
    Signed-off-by: Andrew Patterson <andrew.patterson@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@hobbes.lan>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index f9b874eaeb9f..248b4db91552 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -97,8 +97,6 @@ static int __devinit pcie_portdrv_probe (struct pci_dev *dev,
 
 	pcie_portdrv_save_config(dev);
 
-	pci_enable_pcie_error_reporting(dev);
-
 	return 0;
 }
 

commit 27be54a65c89c4b4aa9b25fc6fba31ffd01a08ca
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Feb 4 02:00:11 2009 +0100

    PCI: PCIe portdrv: Simplify suspend and resume
    
    Simplify suspend and resume of the PCI Express port driver.  It no
    longer needs to save and restore the standard configuration space of the
    device; this is now done by the PCI PM core layer.
    
    This patch is reported to fix the regression tracked as
    http://bugzilla.kernel.org/show_bug.cgi?id=12598
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Reported-and-tested-by: Parag Warudkar <parag.lkml@gmail.com>
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index 99a914a027f8..f9b874eaeb9f 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -55,25 +55,13 @@ static int pcie_portdrv_suspend(struct pci_dev *dev, pm_message_t state)
 
 }
 
-static int pcie_portdrv_suspend_late(struct pci_dev *dev, pm_message_t state)
-{
-	return pci_save_state(dev);
-}
-
-static int pcie_portdrv_resume_early(struct pci_dev *dev)
-{
-	return pci_restore_state(dev);
-}
-
 static int pcie_portdrv_resume(struct pci_dev *dev)
 {
-	pcie_portdrv_restore_config(dev);
+	pci_set_master(dev);
 	return pcie_port_device_resume(dev);
 }
 #else
 #define pcie_portdrv_suspend NULL
-#define pcie_portdrv_suspend_late NULL
-#define pcie_portdrv_resume_early NULL
 #define pcie_portdrv_resume NULL
 #endif
 
@@ -292,8 +280,6 @@ static struct pci_driver pcie_portdriver = {
 	.remove		= pcie_portdrv_remove,
 
 	.suspend	= pcie_portdrv_suspend,
-	.suspend_late	= pcie_portdrv_suspend_late,
-	.resume_early	= pcie_portdrv_resume_early,
 	.resume		= pcie_portdrv_resume,
 
 	.err_handler 	= &pcie_portdrv_err_handler,

commit a79d682f789730dfabaebbb507c87a90c0671a62
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sat Dec 27 16:28:58 2008 +0100

    PCI PM: Split PCI Express port suspend-resume
    
    Suspend-resume of PCI Express ports has recently been moved into
    _suspend_late() and _resume_early() callbacks, but some functions
    executed from there should not be called with interrupts disabled,
    eg. pci_enable_device().  For this reason, split the suspend-resume
    of PCI Express ports into parts to be executed with interrupts
    disabled and with interrupts enabled.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index 0549fe2bdac9..99a914a027f8 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -41,7 +41,6 @@ static int pcie_portdrv_restore_config(struct pci_dev *dev)
 {
 	int retval;
 
-	pci_restore_state(dev);
 	retval = pci_enable_device(dev);
 	if (retval)
 		return retval;
@@ -50,23 +49,32 @@ static int pcie_portdrv_restore_config(struct pci_dev *dev)
 }
 
 #ifdef CONFIG_PM
-static int pcie_portdrv_suspend_late(struct pci_dev *dev, pm_message_t state)
+static int pcie_portdrv_suspend(struct pci_dev *dev, pm_message_t state)
 {
-	int ret = pcie_port_device_suspend(dev, state);
+	return pcie_port_device_suspend(dev, state);
 
-	if (!ret)
-		ret = pcie_portdrv_save_config(dev);
-	return ret;
+}
+
+static int pcie_portdrv_suspend_late(struct pci_dev *dev, pm_message_t state)
+{
+	return pci_save_state(dev);
 }
 
 static int pcie_portdrv_resume_early(struct pci_dev *dev)
+{
+	return pci_restore_state(dev);
+}
+
+static int pcie_portdrv_resume(struct pci_dev *dev)
 {
 	pcie_portdrv_restore_config(dev);
 	return pcie_port_device_resume(dev);
 }
 #else
+#define pcie_portdrv_suspend NULL
 #define pcie_portdrv_suspend_late NULL
 #define pcie_portdrv_resume_early NULL
+#define pcie_portdrv_resume NULL
 #endif
 
 /*
@@ -221,6 +229,7 @@ static pci_ers_result_t pcie_portdrv_slot_reset(struct pci_dev *dev)
 
 	/* If fatal, restore cfg space for possible link reset at upstream */
 	if (dev->error_state == pci_channel_io_frozen) {
+		pci_restore_state(dev);
 		pcie_portdrv_restore_config(dev);
 		pci_enable_pcie_error_reporting(dev);
 	}
@@ -282,8 +291,10 @@ static struct pci_driver pcie_portdriver = {
 	.probe		= pcie_portdrv_probe,
 	.remove		= pcie_portdrv_remove,
 
+	.suspend	= pcie_portdrv_suspend,
 	.suspend_late	= pcie_portdrv_suspend_late,
 	.resume_early	= pcie_portdrv_resume_early,
+	.resume		= pcie_portdrv_resume,
 
 	.err_handler 	= &pcie_portdrv_err_handler,
 };

commit 90d25f246ddefbb743764f8d45ae97e545a6ee86
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sat Dec 6 15:07:59 2008 +0100

    PCI: Suspend and resume PCI Express ports with interrupts disabled
    
    I don't see why the suspend and resume of PCI Express ports should be
    handled with interrupts enabled and it may even lead to problems in
    some situations.  For this reason, move the suspending and resuming
    of PCI Express ports into ->suspend_late() and ->resume_early()
    callbacks executed with interrupts disabled.
    
    This patch addresses the regression from 2.6.26 tracked as
    http://bugzilla.kernel.org/show_bug.cgi?id=12121 .
    
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index 584422da8d8b..0549fe2bdac9 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -50,7 +50,7 @@ static int pcie_portdrv_restore_config(struct pci_dev *dev)
 }
 
 #ifdef CONFIG_PM
-static int pcie_portdrv_suspend(struct pci_dev *dev, pm_message_t state)
+static int pcie_portdrv_suspend_late(struct pci_dev *dev, pm_message_t state)
 {
 	int ret = pcie_port_device_suspend(dev, state);
 
@@ -59,14 +59,14 @@ static int pcie_portdrv_suspend(struct pci_dev *dev, pm_message_t state)
 	return ret;
 }
 
-static int pcie_portdrv_resume(struct pci_dev *dev)
+static int pcie_portdrv_resume_early(struct pci_dev *dev)
 {
 	pcie_portdrv_restore_config(dev);
 	return pcie_port_device_resume(dev);
 }
 #else
-#define pcie_portdrv_suspend NULL
-#define pcie_portdrv_resume NULL
+#define pcie_portdrv_suspend_late NULL
+#define pcie_portdrv_resume_early NULL
 #endif
 
 /*
@@ -282,8 +282,8 @@ static struct pci_driver pcie_portdriver = {
 	.probe		= pcie_portdrv_probe,
 	.remove		= pcie_portdrv_remove,
 
-	.suspend	= pcie_portdrv_suspend,
-	.resume		= pcie_portdrv_resume,
+	.suspend_late	= pcie_portdrv_suspend_late,
+	.resume_early	= pcie_portdrv_resume_early,
 
 	.err_handler 	= &pcie_portdrv_err_handler,
 };

commit 34a2e15e95fce6d6f4d30162f53a0ceb25d5bbaf
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Mon Aug 25 15:45:20 2008 -0600

    PCI: follow lspci device/vendor style
    
    Use "[%04x:%04x]" for PCI vendor/device IDs to follow the format
    used by lspci(8).
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index 367c9c20000d..584422da8d8b 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -91,7 +91,7 @@ static int __devinit pcie_portdrv_probe (struct pci_dev *dev,
 	
 	pci_set_master(dev);
         if (!dev->irq && dev->pin) {
-		dev_warn(&dev->dev, "device [%04x/%04x] has invalid IRQ; "
+		dev_warn(&dev->dev, "device [%04x:%04x] has invalid IRQ; "
 			 "check vendor BIOS\n", dev->vendor, dev->device);
 	}
 	if (pcie_port_device_register(dev)) {

commit 34438ba602f9b8904aafe7559046ea68e99e88a0
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Fri Jun 13 10:52:13 2008 -0600

    PCIE: port driver: use dev_printk when possible
    
    Convert printks to use dev_printk().
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index 51d163238d93..367c9c20000d 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -91,9 +91,8 @@ static int __devinit pcie_portdrv_probe (struct pci_dev *dev,
 	
 	pci_set_master(dev);
         if (!dev->irq && dev->pin) {
-		printk(KERN_WARNING 
-		"%s->Dev[%04x:%04x] has invalid IRQ. Check vendor BIOS\n", 
-		__func__, dev->vendor, dev->device);
+		dev_warn(&dev->dev, "device [%04x/%04x] has invalid IRQ; "
+			 "check vendor BIOS\n", dev->vendor, dev->device);
 	}
 	if (pcie_port_device_register(dev)) {
 		pci_disable_device(dev);

commit 66bef8c059015ba2b36bb5759080336feb01e680
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Mon Mar 3 19:09:46 2008 -0800

    PCI: replace remaining __FUNCTION__ occurrences
    
    __FUNCTION__ is gcc-specific, use __func__
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index 26057f98f72e..51d163238d93 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -93,7 +93,7 @@ static int __devinit pcie_portdrv_probe (struct pci_dev *dev,
         if (!dev->irq && dev->pin) {
 		printk(KERN_WARNING 
 		"%s->Dev[%04x:%04x] has invalid IRQ. Check vendor BIOS\n", 
-		__FUNCTION__, dev->vendor, dev->device);
+		__func__, dev->vendor, dev->device);
 	}
 	if (pcie_port_device_register(dev)) {
 		pci_disable_device(dev);

commit bf164410d08dc83df416e3a6a43ab29bf88890ed
Author: Linas Vepstas <linas@austin.ibm.com>
Date:   Fri Nov 2 15:14:28 2007 -0500

    PCI: pcie portdriver: initialize returned value
    
    The pcie protdrv status can be returned uninitialized,
    if there are no children under a device. This leads to
    bad responses downstream. Fix this.
    
    Signed-off-by: Linas Vepstas <linas@austin.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index df383645e366..26057f98f72e 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -217,7 +217,7 @@ static int slot_reset_iter(struct device *device, void *data)
 
 static pci_ers_result_t pcie_portdrv_slot_reset(struct pci_dev *dev)
 {
-	pci_ers_result_t status;
+	pci_ers_result_t status = PCI_ERS_RESULT_NONE;
 	int retval;
 
 	/* If fatal, restore cfg space for possible link reset at upstream */

commit bf5b4ba3d9f37d41d940a92822b534561abf4f4c
Author: Prarit Bhargava <prarit@redhat.com>
Date:   Fri Mar 23 12:15:05 2007 -0400

    PCI: Fix warning message in PCIE port driver
    
    PCIE error output should conform to vendor_id:device_id.
    
    Signed-off-by: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index 0be5a0b30725..df383645e366 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -93,7 +93,7 @@ static int __devinit pcie_portdrv_probe (struct pci_dev *dev,
         if (!dev->irq && dev->pin) {
 		printk(KERN_WARNING 
 		"%s->Dev[%04x:%04x] has invalid IRQ. Check vendor BIOS\n", 
-		__FUNCTION__, dev->device, dev->vendor);
+		__FUNCTION__, dev->vendor, dev->device);
 	}
 	if (pcie_port_device_register(dev)) {
 		pci_disable_device(dev);

commit 3603a6a37c5f5c6a2b109fdb48c9456f08aebdd8
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Tue Feb 27 10:19:17 2007 +0100

    pcie: fix section mismatch warning
    
    Fix following section mismatch warning (when compiled with CONFIG_HOTPLUG=n):
    WARNING: drivers/pci/built-in.o - Section mismatch: reference to .init.text:pcie_portdrv_probe from .data between 'pcie_portdrv' (at offset 0xe40) and 'pcie_portdrv_err_handler'
    
    This warning was fixed by renaming pcie_portdrv to pcie_portdriver so we pass
    the whitelist.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index f17e7ed2b2a5..0be5a0b30725 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -276,7 +276,7 @@ static struct pci_error_handlers pcie_portdrv_err_handler = {
 		.resume = pcie_portdrv_err_resume,
 };
 
-static struct pci_driver pcie_portdrv = {
+static struct pci_driver pcie_portdriver = {
 	.name		= (char *)device_name,
 	.id_table	= &port_pci_ids[0],
 
@@ -298,7 +298,7 @@ static int __init pcie_portdrv_init(void)
 		printk(KERN_WARNING "PCIE: bus_register error: %d\n", retval);
 		goto out;
 	}
-	retval = pci_register_driver(&pcie_portdrv);
+	retval = pci_register_driver(&pcie_portdriver);
 	if (retval)
 		pcie_port_bus_unregister();
  out:
@@ -307,7 +307,7 @@ static int __init pcie_portdrv_init(void)
 
 static void __exit pcie_portdrv_exit(void) 
 {
-	pci_unregister_driver(&pcie_portdrv);
+	pci_unregister_driver(&pcie_portdriver);
 	pcie_port_bus_unregister();
 }
 

commit 83e42bcdd3be31a0df8b1a8d2d3fa1a65e43815c
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Wed Dec 6 22:07:30 2006 +0900

    PCI: pcieport-driver: remove invalid warning message
    
    The following warning message should not be displayed for devices
    which don't use an interrupt pin.
    
        pcie_portdrv_probe->Dev[XXXX:XXXX] has invalid IRQ. Check vendor BIOS
    
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index b4da7954611e..f17e7ed2b2a5 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -90,7 +90,7 @@ static int __devinit pcie_portdrv_probe (struct pci_dev *dev,
 		return -ENODEV;
 	
 	pci_set_master(dev);
-        if (!dev->irq) {
+        if (!dev->irq && dev->pin) {
 		printk(KERN_WARNING 
 		"%s->Dev[%04x:%04x] has invalid IRQ. Check vendor BIOS\n", 
 		__FUNCTION__, dev->device, dev->vendor);

commit 0bed208efcb25bed4dc2026488a4417aa68e7c92
Author: Zhang, Yanmin <yanmin_zhang@linux.intel.com>
Date:   Thu Sep 28 14:35:59 2006 +0800

    PCI: fix pcie_portdrv_restore_config undefined without CONFIG_PM error
    
    On Thu, 2006-09-28 at 03:42, Olaf Hering wrote:
    > PCI-Express AER implemetation: pcie_portdrv error handler
    >
    > This patch breaks if CONFIG_PM is not enabled,
    > pcie_portdrv_restore_config() will be undefined.
    I move the definition of pcie_portdrv_restore_config
    out of CONFIG_PM.
    
    Below patch is against 2.6.18-mm1. Could you try it?
    
    Signed-off-by: Zhang Yanmin <yanmin.zhang@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index 037690e08f5f..b4da7954611e 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -37,7 +37,6 @@ static int pcie_portdrv_save_config(struct pci_dev *dev)
 	return pci_save_state(dev);
 }
 
-#ifdef CONFIG_PM
 static int pcie_portdrv_restore_config(struct pci_dev *dev)
 {
 	int retval;
@@ -50,6 +49,7 @@ static int pcie_portdrv_restore_config(struct pci_dev *dev)
 	return 0;
 }
 
+#ifdef CONFIG_PM
 static int pcie_portdrv_suspend(struct pci_dev *dev, pm_message_t state)
 {
 	int ret = pcie_port_device_suspend(dev, state);

commit b19441af185559118e8247382ea4f2f76ebffc6d
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Aug 28 11:43:25 2006 -0700

    PCI: fix __must_check warnings
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index e4a2429986f0..037690e08f5f 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -147,8 +147,10 @@ static pci_ers_result_t pcie_portdrv_error_detected(struct pci_dev *dev,
 {
 	struct aer_broadcast_data result_data =
 			{error, PCI_ERS_RESULT_CAN_RECOVER};
+	int retval;
 
-	device_for_each_child(&dev->dev, &result_data, error_detected_iter);
+	/* can not fail */
+	retval = device_for_each_child(&dev->dev, &result_data, error_detected_iter);
 
 	return result_data.result;
 }
@@ -181,8 +183,10 @@ static int mmio_enabled_iter(struct device *device, void *data)
 static pci_ers_result_t pcie_portdrv_mmio_enabled(struct pci_dev *dev)
 {
 	pci_ers_result_t status = PCI_ERS_RESULT_RECOVERED;
+	int retval;
 
-	device_for_each_child(&dev->dev, &status, mmio_enabled_iter);
+	/* get true return value from &status */
+	retval = device_for_each_child(&dev->dev, &status, mmio_enabled_iter);
 	return status;
 }
 
@@ -214,6 +218,7 @@ static int slot_reset_iter(struct device *device, void *data)
 static pci_ers_result_t pcie_portdrv_slot_reset(struct pci_dev *dev)
 {
 	pci_ers_result_t status;
+	int retval;
 
 	/* If fatal, restore cfg space for possible link reset at upstream */
 	if (dev->error_state == pci_channel_io_frozen) {
@@ -221,7 +226,8 @@ static pci_ers_result_t pcie_portdrv_slot_reset(struct pci_dev *dev)
 		pci_enable_pcie_error_reporting(dev);
 	}
 
-	device_for_each_child(&dev->dev, &status, slot_reset_iter);
+	/* get true return value from &status */
+	retval = device_for_each_child(&dev->dev, &status, slot_reset_iter);
 
 	return status;
 }
@@ -248,7 +254,9 @@ static int resume_iter(struct device *device, void *data)
 
 static void pcie_portdrv_err_resume(struct pci_dev *dev)
 {
-	device_for_each_child(&dev->dev, NULL, resume_iter);
+	int retval;
+	/* nothing to do with error value, if it ever happens */
+	retval = device_for_each_child(&dev->dev, NULL, resume_iter);
 }
 
 /*

commit 4bf3392e0bf55e5aabbd7bbdbc52cc58eb63f837
Author: Zhang, Yanmin <yanmin.zhang@intel.com>
Date:   Mon Jul 31 15:26:16 2006 +0800

    PCI-Express AER implemetation: pcie_portdrv error handler
    
    Patch 4 implements error handlers for pcie_portdrv.
    
    Signed-off-by: Zhang Yanmin <yanmin.zhang@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index 3284199ce396..e4a2429986f0 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -14,8 +14,10 @@
 #include <linux/init.h>
 #include <linux/slab.h>
 #include <linux/pcieport_if.h>
+#include <linux/aer.h>
 
 #include "portdrv.h"
+#include "aer/aerdrv.h"
 
 /*
  * Version Information
@@ -30,6 +32,43 @@ MODULE_LICENSE("GPL");
 /* global data */
 static const char device_name[] = "pcieport-driver";
 
+static int pcie_portdrv_save_config(struct pci_dev *dev)
+{
+	return pci_save_state(dev);
+}
+
+#ifdef CONFIG_PM
+static int pcie_portdrv_restore_config(struct pci_dev *dev)
+{
+	int retval;
+
+	pci_restore_state(dev);
+	retval = pci_enable_device(dev);
+	if (retval)
+		return retval;
+	pci_set_master(dev);
+	return 0;
+}
+
+static int pcie_portdrv_suspend(struct pci_dev *dev, pm_message_t state)
+{
+	int ret = pcie_port_device_suspend(dev, state);
+
+	if (!ret)
+		ret = pcie_portdrv_save_config(dev);
+	return ret;
+}
+
+static int pcie_portdrv_resume(struct pci_dev *dev)
+{
+	pcie_portdrv_restore_config(dev);
+	return pcie_port_device_resume(dev);
+}
+#else
+#define pcie_portdrv_suspend NULL
+#define pcie_portdrv_resume NULL
+#endif
+
 /*
  * pcie_portdrv_probe - Probe PCI-Express port devices
  * @dev: PCI-Express port device being probed
@@ -61,6 +100,10 @@ static int __devinit pcie_portdrv_probe (struct pci_dev *dev,
 		return -ENOMEM;
 	}
 
+	pcie_portdrv_save_config(dev);
+
+	pci_enable_pcie_error_reporting(dev);
+
 	return 0;
 }
 
@@ -70,39 +113,143 @@ static void pcie_portdrv_remove (struct pci_dev *dev)
 	kfree(pci_get_drvdata(dev));
 }
 
-#ifdef CONFIG_PM
-static int pcie_portdrv_save_config(struct pci_dev *dev)
+static int error_detected_iter(struct device *device, void *data)
 {
-	return pci_save_state(dev);
+	struct pcie_device *pcie_device;
+	struct pcie_port_service_driver *driver;
+	struct aer_broadcast_data *result_data;
+	pci_ers_result_t status;
+
+	result_data = (struct aer_broadcast_data *) data;
+
+	if (device->bus == &pcie_port_bus_type && device->driver) {
+		driver = to_service_driver(device->driver);
+		if (!driver ||
+			!driver->err_handler ||
+			!driver->err_handler->error_detected)
+			return 0;
+
+		pcie_device = to_pcie_device(device);
+
+		/* Forward error detected message to service drivers */
+		status = driver->err_handler->error_detected(
+			pcie_device->port,
+			result_data->state);
+		result_data->result =
+			merge_result(result_data->result, status);
+	}
+
+	return 0;
 }
 
-static int pcie_portdrv_restore_config(struct pci_dev *dev)
+static pci_ers_result_t pcie_portdrv_error_detected(struct pci_dev *dev,
+					enum pci_channel_state error)
 {
-	int retval;
+	struct aer_broadcast_data result_data =
+			{error, PCI_ERS_RESULT_CAN_RECOVER};
+
+	device_for_each_child(&dev->dev, &result_data, error_detected_iter);
+
+	return result_data.result;
+}
+
+static int mmio_enabled_iter(struct device *device, void *data)
+{
+	struct pcie_device *pcie_device;
+	struct pcie_port_service_driver *driver;
+	pci_ers_result_t status, *result;
+
+	result = (pci_ers_result_t *) data;
+
+	if (device->bus == &pcie_port_bus_type && device->driver) {
+		driver = to_service_driver(device->driver);
+		if (driver &&
+			driver->err_handler &&
+			driver->err_handler->mmio_enabled) {
+			pcie_device = to_pcie_device(device);
+
+			/* Forward error message to service drivers */
+			status = driver->err_handler->mmio_enabled(
+					pcie_device->port);
+			*result = merge_result(*result, status);
+		}
+	}
 
-	pci_restore_state(dev);
-	retval = pci_enable_device(dev);
-	if (retval)
-		return retval;
-	pci_set_master(dev);
 	return 0;
 }
 
-static int pcie_portdrv_suspend (struct pci_dev *dev, pm_message_t state)
+static pci_ers_result_t pcie_portdrv_mmio_enabled(struct pci_dev *dev)
 {
-	int ret = pcie_port_device_suspend(dev, state);
+	pci_ers_result_t status = PCI_ERS_RESULT_RECOVERED;
 
-	if (!ret)
-		ret = pcie_portdrv_save_config(dev);
-	return ret;
+	device_for_each_child(&dev->dev, &status, mmio_enabled_iter);
+	return status;
 }
 
-static int pcie_portdrv_resume (struct pci_dev *dev)
+static int slot_reset_iter(struct device *device, void *data)
 {
-	pcie_portdrv_restore_config(dev);
-	return pcie_port_device_resume(dev);
+	struct pcie_device *pcie_device;
+	struct pcie_port_service_driver *driver;
+	pci_ers_result_t status, *result;
+
+	result = (pci_ers_result_t *) data;
+
+	if (device->bus == &pcie_port_bus_type && device->driver) {
+		driver = to_service_driver(device->driver);
+		if (driver &&
+			driver->err_handler &&
+			driver->err_handler->slot_reset) {
+			pcie_device = to_pcie_device(device);
+
+			/* Forward error message to service drivers */
+			status = driver->err_handler->slot_reset(
+					pcie_device->port);
+			*result = merge_result(*result, status);
+		}
+	}
+
+	return 0;
+}
+
+static pci_ers_result_t pcie_portdrv_slot_reset(struct pci_dev *dev)
+{
+	pci_ers_result_t status;
+
+	/* If fatal, restore cfg space for possible link reset at upstream */
+	if (dev->error_state == pci_channel_io_frozen) {
+		pcie_portdrv_restore_config(dev);
+		pci_enable_pcie_error_reporting(dev);
+	}
+
+	device_for_each_child(&dev->dev, &status, slot_reset_iter);
+
+	return status;
+}
+
+static int resume_iter(struct device *device, void *data)
+{
+	struct pcie_device *pcie_device;
+	struct pcie_port_service_driver *driver;
+
+	if (device->bus == &pcie_port_bus_type && device->driver) {
+		driver = to_service_driver(device->driver);
+		if (driver &&
+			driver->err_handler &&
+			driver->err_handler->resume) {
+			pcie_device = to_pcie_device(device);
+
+			/* Forward error message to service drivers */
+			driver->err_handler->resume(pcie_device->port);
+		}
+	}
+
+	return 0;
+}
+
+static void pcie_portdrv_err_resume(struct pci_dev *dev)
+{
+	device_for_each_child(&dev->dev, NULL, resume_iter);
 }
-#endif
 
 /*
  * LINUX Device Driver Model
@@ -114,6 +261,13 @@ static const struct pci_device_id port_pci_ids[] = { {
 };
 MODULE_DEVICE_TABLE(pci, port_pci_ids);
 
+static struct pci_error_handlers pcie_portdrv_err_handler = {
+		.error_detected = pcie_portdrv_error_detected,
+		.mmio_enabled = pcie_portdrv_mmio_enabled,
+		.slot_reset = pcie_portdrv_slot_reset,
+		.resume = pcie_portdrv_err_resume,
+};
+
 static struct pci_driver pcie_portdrv = {
 	.name		= (char *)device_name,
 	.id_table	= &port_pci_ids[0],
@@ -121,10 +275,10 @@ static struct pci_driver pcie_portdrv = {
 	.probe		= pcie_portdrv_probe,
 	.remove		= pcie_portdrv_remove,
 
-#ifdef	CONFIG_PM
 	.suspend	= pcie_portdrv_suspend,
 	.resume		= pcie_portdrv_resume,
-#endif	/* PM */
+
+	.err_handler 	= &pcie_portdrv_err_handler,
 };
 
 static int __init pcie_portdrv_init(void)

commit 20d516602c022997feb24a9f1a806fc986b9e4e8
Author: Randy Dunlap <rdunlap@xenotime.net>
Date:   Sat Jul 8 22:58:25 2006 -0700

    PCIE: check and return bus_register errors
    
    Have pcie_port_bus_register() notice and return errors.
    Mark it __must_check so that its caller(s) must check its return value.
    
    Signed-off-by: Randy Dunlap <rdunlap@xenotime.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index 478d0d28f7ad..3284199ce396 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -129,12 +129,17 @@ static struct pci_driver pcie_portdrv = {
 
 static int __init pcie_portdrv_init(void)
 {
-	int retval = 0;
+	int retval;
 
-	pcie_port_bus_register();
+	retval = pcie_port_bus_register();
+	if (retval) {
+		printk(KERN_WARNING "PCIE: bus_register error: %d\n", retval);
+		goto out;
+	}
 	retval = pci_register_driver(&pcie_portdrv);
 	if (retval)
 		pcie_port_bus_unregister();
+ out:
 	return retval;
 }
 

commit e4fd1f4a6e05335d464fe003c164fea850a3b3f3
Author: Randy Dunlap <rdunlap@xenotime.net>
Date:   Thu Jul 6 21:36:01 2006 -0700

    PCIE: cleanup on probe error
    
    If pcie_portdrv_probe() fails but it had already called
    pci_enable_device(), then call pci_disable_device() when
    returning error.
    
    Is there some reason that this isn't being done?
    or was it just missed?
    
    Signed-off-by: Randy Dunlap <rdunlap@xenotime.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index d0a37976faa6..478d0d28f7ad 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -56,8 +56,10 @@ static int __devinit pcie_portdrv_probe (struct pci_dev *dev,
 		"%s->Dev[%04x:%04x] has invalid IRQ. Check vendor BIOS\n", 
 		__FUNCTION__, dev->device, dev->vendor);
 	}
-	if (pcie_port_device_register(dev)) 
+	if (pcie_port_device_register(dev)) {
+		pci_disable_device(dev);
 		return -ENOMEM;
+	}
 
 	return 0;
 }

commit 60854838596906ebae7f32e4de921e150e669b60
Author: Henrik Kretzschmar <henne@nachtwindheim.de>
Date:   Thu Jul 6 18:05:51 2006 +0400

    pcie: fix warnings when CONFIG_PM=n
    
    Signed-off-by: Henrik Kretzschmar <henne@nachtwindheim.de>
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index 50bfc1b2f3bf..d0a37976faa6 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -30,23 +30,6 @@ MODULE_LICENSE("GPL");
 /* global data */
 static const char device_name[] = "pcieport-driver";
 
-static int pcie_portdrv_save_config(struct pci_dev *dev)
-{
-	return pci_save_state(dev);
-}
-
-static int pcie_portdrv_restore_config(struct pci_dev *dev)
-{
-	int retval;
-
-	pci_restore_state(dev);
-	retval = pci_enable_device(dev);
-	if (retval)
-		return retval;
-	pci_set_master(dev);
-	return 0;
-}
-
 /*
  * pcie_portdrv_probe - Probe PCI-Express port devices
  * @dev: PCI-Express port device being probed
@@ -86,6 +69,23 @@ static void pcie_portdrv_remove (struct pci_dev *dev)
 }
 
 #ifdef CONFIG_PM
+static int pcie_portdrv_save_config(struct pci_dev *dev)
+{
+	return pci_save_state(dev);
+}
+
+static int pcie_portdrv_restore_config(struct pci_dev *dev)
+{
+	int retval;
+
+	pci_restore_state(dev);
+	retval = pci_enable_device(dev);
+	if (retval)
+		return retval;
+	pci_set_master(dev);
+	return 0;
+}
+
 static int pcie_portdrv_suspend (struct pci_dev *dev, pm_message_t state)
 {
 	int ret = pcie_port_device_suspend(dev, state);

commit 75cde0e25787c1af341a128b350c36df24e5397d
Author: Shaohua Li <shaohua.li@intel.com>
Date:   Wed Feb 8 17:11:40 2006 +0800

    [PATCH] PCI: remove msi save/restore code in specific driver
    
    Remove pcie port driver's msi save/restore code.
    
    Signed-off-by: Shaohua Li <shaohua.li@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index 02260141dc81..50bfc1b2f3bf 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -30,75 +30,16 @@ MODULE_LICENSE("GPL");
 /* global data */
 static const char device_name[] = "pcieport-driver";
 
-static void pci_save_msi_state(struct pci_dev *dev)
+static int pcie_portdrv_save_config(struct pci_dev *dev)
 {
-	struct pcie_port_device_ext *p_ext = pci_get_drvdata(dev);
-	int i = 0, pos;
-	u16 control;
-
-   	if ((pos = pci_find_capability(dev, PCI_CAP_ID_MSI)) <= 0)
-		return;
-
-	pci_read_config_dword(dev, pos, &p_ext->saved_msi_config_space[i++]);
-	control = p_ext->saved_msi_config_space[0] >> 16;
-	pci_read_config_dword(dev, pos + PCI_MSI_ADDRESS_LO,
-		&p_ext->saved_msi_config_space[i++]);
-	if (control & PCI_MSI_FLAGS_64BIT) {
-		pci_read_config_dword(dev, pos + PCI_MSI_ADDRESS_HI,
-			&p_ext->saved_msi_config_space[i++]);
-		pci_read_config_dword(dev, pos + PCI_MSI_DATA_64,
-			&p_ext->saved_msi_config_space[i++]);
-	} else
-		pci_read_config_dword(dev, pos + PCI_MSI_DATA_32,
-			&p_ext->saved_msi_config_space[i++]);
-	if (control & PCI_MSI_FLAGS_MASKBIT)
-		pci_read_config_dword(dev, pos + PCI_MSI_MASK_BIT,
-			&p_ext->saved_msi_config_space[i++]);
-}
-
-static void pci_restore_msi_state(struct pci_dev *dev)
-{
-	struct pcie_port_device_ext *p_ext = pci_get_drvdata(dev);
-	int i = 0, pos;
-	u16 control;
-
-   	if ((pos = pci_find_capability(dev, PCI_CAP_ID_MSI)) <= 0)
-		return;
-
-	control = p_ext->saved_msi_config_space[i++] >> 16;
-	pci_write_config_word(dev, pos + PCI_MSI_FLAGS, control);
-	pci_write_config_dword(dev, pos + PCI_MSI_ADDRESS_LO,
-		p_ext->saved_msi_config_space[i++]);
-	if (control & PCI_MSI_FLAGS_64BIT) {
-		pci_write_config_dword(dev, pos + PCI_MSI_ADDRESS_HI,
-			p_ext->saved_msi_config_space[i++]);
-		pci_write_config_dword(dev, pos + PCI_MSI_DATA_64,
-			p_ext->saved_msi_config_space[i++]);
-	} else
-		pci_write_config_dword(dev, pos + PCI_MSI_DATA_32,
-			p_ext->saved_msi_config_space[i++]);
-	if (control & PCI_MSI_FLAGS_MASKBIT)
-		pci_write_config_dword(dev, pos + PCI_MSI_MASK_BIT,
-			p_ext->saved_msi_config_space[i++]);
-}
-
-static void pcie_portdrv_save_config(struct pci_dev *dev)
-{
-	struct pcie_port_device_ext *p_ext = pci_get_drvdata(dev);
-
-	pci_save_state(dev);
-	if (p_ext->interrupt_mode == PCIE_PORT_MSI_MODE)
-		pci_save_msi_state(dev);
+	return pci_save_state(dev);
 }
 
 static int pcie_portdrv_restore_config(struct pci_dev *dev)
 {
-	struct pcie_port_device_ext *p_ext = pci_get_drvdata(dev);
 	int retval;
 
 	pci_restore_state(dev);
-	if (p_ext->interrupt_mode == PCIE_PORT_MSI_MODE)
-		pci_restore_msi_state(dev);
 	retval = pci_enable_device(dev);
 	if (retval)
 		return retval;
@@ -149,7 +90,8 @@ static int pcie_portdrv_suspend (struct pci_dev *dev, pm_message_t state)
 {
 	int ret = pcie_port_device_suspend(dev, state);
 
-	pcie_portdrv_save_config(dev);
+	if (!ret)
+		ret = pcie_portdrv_save_config(dev);
 	return ret;
 }
 

commit 4e57b6817880946a3a78d5d8cad1ace363f7e449
Author: Tim Schmielau <tim@physik3.uni-rostock.de>
Date:   Sun Oct 30 15:03:48 2005 -0800

    [PATCH] fix missing includes
    
    I recently picked up my older work to remove unnecessary #includes of
    sched.h, starting from a patch by Dave Jones to not include sched.h
    from module.h. This reduces the number of indirect includes of sched.h
    by ~300. Another ~400 pointless direct includes can be removed after
    this disentangling (patch to follow later).
    However, quite a few indirect includes need to be fixed up for this.
    
    In order to feed the patches through -mm with as little disturbance as
    possible, I've split out the fixes I accumulated up to now (complete for
    i386 and x86_64, more archs to follow later) and post them before the real
    patch.  This way this large part of the patch is kept simple with only
    adding #includes, and all hunks are independent of each other.  So if any
    hunk rejects or gets in the way of other patches, just drop it.  My scripts
    will pick it up again in the next round.
    
    Signed-off-by: Tim Schmielau <tim@physik3.uni-rostock.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index 3c565ce7f77b..02260141dc81 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -12,6 +12,7 @@
 #include <linux/errno.h>
 #include <linux/pm.h>
 #include <linux/init.h>
+#include <linux/slab.h>
 #include <linux/pcieport_if.h>
 
 #include "portdrv.h"

commit 95a629657dbe28e44a312c47815b3dc3f1ce0970
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Jul 28 11:37:33 2005 -0700

    [PATCH] PCI: start paying attention to a lot of pci function return values
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index 30bac7ed7c16..3c565ce7f77b 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -90,15 +90,19 @@ static void pcie_portdrv_save_config(struct pci_dev *dev)
 		pci_save_msi_state(dev);
 }
 
-static void pcie_portdrv_restore_config(struct pci_dev *dev)
+static int pcie_portdrv_restore_config(struct pci_dev *dev)
 {
 	struct pcie_port_device_ext *p_ext = pci_get_drvdata(dev);
+	int retval;
 
 	pci_restore_state(dev);
 	if (p_ext->interrupt_mode == PCIE_PORT_MSI_MODE)
 		pci_restore_msi_state(dev);
-	pci_enable_device(dev);
+	retval = pci_enable_device(dev);
+	if (retval)
+		return retval;
 	pci_set_master(dev);
+	return 0;
 }
 
 /*

commit 5823d100ae260d022b4dd5ec9cc0b85f0bf0d646
Author: long <tlnguyen@snoqualmie.dp.intel.com>
Date:   Wed Jun 22 09:09:54 2005 -0700

    [PATCH] PCI: acpi tg3 ethernet not coming back properly after S3 suspendon DellM70
    
    This patch, is based on kernel 2.6.12, provides a fix for PCIe
    port bus driver suspend/resume.
    
    Signed-off-by: T. Long Nguyen <tom.l.nguyen@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index e9095ee508e3..30bac7ed7c16 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -29,6 +29,78 @@ MODULE_LICENSE("GPL");
 /* global data */
 static const char device_name[] = "pcieport-driver";
 
+static void pci_save_msi_state(struct pci_dev *dev)
+{
+	struct pcie_port_device_ext *p_ext = pci_get_drvdata(dev);
+	int i = 0, pos;
+	u16 control;
+
+   	if ((pos = pci_find_capability(dev, PCI_CAP_ID_MSI)) <= 0)
+		return;
+
+	pci_read_config_dword(dev, pos, &p_ext->saved_msi_config_space[i++]);
+	control = p_ext->saved_msi_config_space[0] >> 16;
+	pci_read_config_dword(dev, pos + PCI_MSI_ADDRESS_LO,
+		&p_ext->saved_msi_config_space[i++]);
+	if (control & PCI_MSI_FLAGS_64BIT) {
+		pci_read_config_dword(dev, pos + PCI_MSI_ADDRESS_HI,
+			&p_ext->saved_msi_config_space[i++]);
+		pci_read_config_dword(dev, pos + PCI_MSI_DATA_64,
+			&p_ext->saved_msi_config_space[i++]);
+	} else
+		pci_read_config_dword(dev, pos + PCI_MSI_DATA_32,
+			&p_ext->saved_msi_config_space[i++]);
+	if (control & PCI_MSI_FLAGS_MASKBIT)
+		pci_read_config_dword(dev, pos + PCI_MSI_MASK_BIT,
+			&p_ext->saved_msi_config_space[i++]);
+}
+
+static void pci_restore_msi_state(struct pci_dev *dev)
+{
+	struct pcie_port_device_ext *p_ext = pci_get_drvdata(dev);
+	int i = 0, pos;
+	u16 control;
+
+   	if ((pos = pci_find_capability(dev, PCI_CAP_ID_MSI)) <= 0)
+		return;
+
+	control = p_ext->saved_msi_config_space[i++] >> 16;
+	pci_write_config_word(dev, pos + PCI_MSI_FLAGS, control);
+	pci_write_config_dword(dev, pos + PCI_MSI_ADDRESS_LO,
+		p_ext->saved_msi_config_space[i++]);
+	if (control & PCI_MSI_FLAGS_64BIT) {
+		pci_write_config_dword(dev, pos + PCI_MSI_ADDRESS_HI,
+			p_ext->saved_msi_config_space[i++]);
+		pci_write_config_dword(dev, pos + PCI_MSI_DATA_64,
+			p_ext->saved_msi_config_space[i++]);
+	} else
+		pci_write_config_dword(dev, pos + PCI_MSI_DATA_32,
+			p_ext->saved_msi_config_space[i++]);
+	if (control & PCI_MSI_FLAGS_MASKBIT)
+		pci_write_config_dword(dev, pos + PCI_MSI_MASK_BIT,
+			p_ext->saved_msi_config_space[i++]);
+}
+
+static void pcie_portdrv_save_config(struct pci_dev *dev)
+{
+	struct pcie_port_device_ext *p_ext = pci_get_drvdata(dev);
+
+	pci_save_state(dev);
+	if (p_ext->interrupt_mode == PCIE_PORT_MSI_MODE)
+		pci_save_msi_state(dev);
+}
+
+static void pcie_portdrv_restore_config(struct pci_dev *dev)
+{
+	struct pcie_port_device_ext *p_ext = pci_get_drvdata(dev);
+
+	pci_restore_state(dev);
+	if (p_ext->interrupt_mode == PCIE_PORT_MSI_MODE)
+		pci_restore_msi_state(dev);
+	pci_enable_device(dev);
+	pci_set_master(dev);
+}
+
 /*
  * pcie_portdrv_probe - Probe PCI-Express port devices
  * @dev: PCI-Express port device being probed
@@ -64,16 +136,21 @@ static int __devinit pcie_portdrv_probe (struct pci_dev *dev,
 static void pcie_portdrv_remove (struct pci_dev *dev)
 {
 	pcie_port_device_remove(dev);
+	kfree(pci_get_drvdata(dev));
 }
 
 #ifdef CONFIG_PM
 static int pcie_portdrv_suspend (struct pci_dev *dev, pm_message_t state)
 {
-	return pcie_port_device_suspend(dev, state);
+	int ret = pcie_port_device_suspend(dev, state);
+
+	pcie_portdrv_save_config(dev);
+	return ret;
 }
 
 static int pcie_portdrv_resume (struct pci_dev *dev)
 {
+	pcie_portdrv_restore_config(dev);
 	return pcie_port_device_resume(dev);
 }
 #endif

commit 7f4927c1b505eb4e679ab506bf7626af6258e6b6
Author: Pavel Machek <pavel@ucw.cz>
Date:   Sat Apr 16 15:25:33 2005 -0700

    [PATCH] fix u32 vs. pm_message_t in PCI, PCIE
    
    This fixes drivers/pci (mostly pcie stuff).
    
    Signed-off-by: Pavel Machek <pavel@suse.cz>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
index 3184843c3649..e9095ee508e3 100644
--- a/drivers/pci/pcie/portdrv_pci.c
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -67,7 +67,7 @@ static void pcie_portdrv_remove (struct pci_dev *dev)
 }
 
 #ifdef CONFIG_PM
-static int pcie_portdrv_suspend (struct pci_dev *dev, u32 state)
+static int pcie_portdrv_suspend (struct pci_dev *dev, pm_message_t state)
 {
 	return pcie_port_device_suspend(dev, state);
 }

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/pci/pcie/portdrv_pci.c b/drivers/pci/pcie/portdrv_pci.c
new file mode 100644
index 000000000000..3184843c3649
--- /dev/null
+++ b/drivers/pci/pcie/portdrv_pci.c
@@ -0,0 +1,122 @@
+/*
+ * File:	portdrv_pci.c
+ * Purpose:	PCI Express Port Bus Driver
+ *
+ * Copyright (C) 2004 Intel
+ * Copyright (C) Tom Long Nguyen (tom.l.nguyen@intel.com)
+ */
+
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/pm.h>
+#include <linux/init.h>
+#include <linux/pcieport_if.h>
+
+#include "portdrv.h"
+
+/*
+ * Version Information
+ */
+#define DRIVER_VERSION "v1.0"
+#define DRIVER_AUTHOR "tom.l.nguyen@intel.com"
+#define DRIVER_DESC "PCIE Port Bus Driver"
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_LICENSE("GPL");
+
+/* global data */
+static const char device_name[] = "pcieport-driver";
+
+/*
+ * pcie_portdrv_probe - Probe PCI-Express port devices
+ * @dev: PCI-Express port device being probed
+ *
+ * If detected invokes the pcie_port_device_register() method for 
+ * this port device.
+ *
+ */
+static int __devinit pcie_portdrv_probe (struct pci_dev *dev, 
+				const struct pci_device_id *id )
+{
+	int			status;
+
+	status = pcie_port_device_probe(dev);
+	if (status)
+		return status;
+
+	if (pci_enable_device(dev) < 0) 
+		return -ENODEV;
+	
+	pci_set_master(dev);
+        if (!dev->irq) {
+		printk(KERN_WARNING 
+		"%s->Dev[%04x:%04x] has invalid IRQ. Check vendor BIOS\n", 
+		__FUNCTION__, dev->device, dev->vendor);
+	}
+	if (pcie_port_device_register(dev)) 
+		return -ENOMEM;
+
+	return 0;
+}
+
+static void pcie_portdrv_remove (struct pci_dev *dev)
+{
+	pcie_port_device_remove(dev);
+}
+
+#ifdef CONFIG_PM
+static int pcie_portdrv_suspend (struct pci_dev *dev, u32 state)
+{
+	return pcie_port_device_suspend(dev, state);
+}
+
+static int pcie_portdrv_resume (struct pci_dev *dev)
+{
+	return pcie_port_device_resume(dev);
+}
+#endif
+
+/*
+ * LINUX Device Driver Model
+ */
+static const struct pci_device_id port_pci_ids[] = { {
+	/* handle any PCI-Express port */
+	PCI_DEVICE_CLASS(((PCI_CLASS_BRIDGE_PCI << 8) | 0x00), ~0),
+	}, { /* end: all zeroes */ }
+};
+MODULE_DEVICE_TABLE(pci, port_pci_ids);
+
+static struct pci_driver pcie_portdrv = {
+	.name		= (char *)device_name,
+	.id_table	= &port_pci_ids[0],
+
+	.probe		= pcie_portdrv_probe,
+	.remove		= pcie_portdrv_remove,
+
+#ifdef	CONFIG_PM
+	.suspend	= pcie_portdrv_suspend,
+	.resume		= pcie_portdrv_resume,
+#endif	/* PM */
+};
+
+static int __init pcie_portdrv_init(void)
+{
+	int retval = 0;
+
+	pcie_port_bus_register();
+	retval = pci_register_driver(&pcie_portdrv);
+	if (retval)
+		pcie_port_bus_unregister();
+	return retval;
+}
+
+static void __exit pcie_portdrv_exit(void) 
+{
+	pci_unregister_driver(&pcie_portdrv);
+	pcie_port_bus_unregister();
+}
+
+module_init(pcie_portdrv_init);
+module_exit(pcie_portdrv_exit);
