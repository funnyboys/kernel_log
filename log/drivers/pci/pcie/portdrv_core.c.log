commit b6cf1a42f916af0b056079c37fc5fa7bf8e4b2e2
Author: Kuppuswamy Sathyanarayanan <sathyanarayanan.kuppuswamy@linux.intel.com>
Date:   Mon Mar 23 17:26:02 2020 -0700

    PCI/ERR: Remove service dependency in pcie_do_recovery()
    
    Previously we passed the PCIe service type parameter to pcie_do_recovery(),
    where reset_link() looked up the underlying pci_port_service_driver and its
    .reset_link() function pointer. Instead of using this roundabout way, we
    can just pass the driver-specific .reset_link() callback function when
    calling pcie_do_recovery() function.
    
    This allows us to call pcie_do_recovery() from code that is not a PCIe port
    service driver, e.g., Error Disconnect Recover (EDR) support.
    
    Remove pcie_port_find_service() and pcie_port_service_driver.reset_link
    since they are now unused.
    
    Link: https://lore.kernel.org/r/60e02b87b526cdf2930400059d98704bf0a147d1.1585000084.git.sathyanarayanan.kuppuswamy@linux.intel.com
    Signed-off-by: Kuppuswamy Sathyanarayanan <sathyanarayanan.kuppuswamy@linux.intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index 5075cb9e850c..50a9522ab07d 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -458,27 +458,6 @@ static int find_service_iter(struct device *device, void *data)
 	return 0;
 }
 
-/**
- * pcie_port_find_service - find the service driver
- * @dev: PCI Express port the service is associated with
- * @service: Service to find
- *
- * Find PCI Express port service driver associated with given service
- */
-struct pcie_port_service_driver *pcie_port_find_service(struct pci_dev *dev,
-							u32 service)
-{
-	struct pcie_port_service_driver *drv;
-	struct portdrv_service_data pdrvs;
-
-	pdrvs.drv = NULL;
-	pdrvs.service = service;
-	device_for_each_child(&dev->dev, &pdrvs, find_service_iter);
-
-	drv = pdrvs.drv;
-	return drv;
-}
-
 /**
  * pcie_port_find_device - find the struct device
  * @dev: PCI Express port the service is associated with

commit 35a0b2378c199d4f26e458b2ca38ea56aaf2d9b8
Author: Olof Johansson <olof@lixom.net>
Date:   Wed Oct 23 12:22:05 2019 -0700

    PCI/DPC: Add "pcie_ports=dpc-native" to allow DPC without AER control
    
    Prior to eed85ff4c0da7 ("PCI/DPC: Enable DPC only if AER is available"),
    Linux handled DPC events regardless of whether firmware had granted it
    ownership of AER or DPC, e.g., via _OSC.
    
    PCIe r5.0, sec 6.2.10, recommends that the OS link control of DPC to
    control of AER, so after eed85ff4c0da7, Linux handles DPC events only if it
    has control of AER.
    
    On platforms that do not grant OS control of AER via _OSC, Linux DPC
    handling worked before eed85ff4c0da7 but not after.
    
    To make Linux DPC handling work on those platforms the same way they did
    before, add a "pcie_ports=dpc-native" kernel parameter that makes Linux
    handle DPC events regardless of whether it has control of AER.
    
    [bhelgaas: commit log, move pcie_ports_dpc_native to drivers/pci/]
    Link: https://lore.kernel.org/r/20191023192205.97024-1-olof@lixom.net
    Signed-off-by: Olof Johansson <olof@lixom.net>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index 1b330129089f..5075cb9e850c 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -250,8 +250,13 @@ static int get_port_device_capability(struct pci_dev *dev)
 		pcie_pme_interrupt_enable(dev, false);
 	}
 
+	/*
+	 * With dpc-native, allow Linux to use DPC even if it doesn't have
+	 * permission to use AER.
+	 */
 	if (pci_find_ext_capability(dev, PCI_EXT_CAP_ID_DPC) &&
-	    pci_aer_available() && services & PCIE_PORT_SERVICE_AER)
+	    pci_aer_available() &&
+	    (pcie_ports_dpc_native || (services & PCIE_PORT_SERVICE_AER)))
 		services |= PCIE_PORT_SERVICE_DPC;
 
 	if (pci_pcie_type(dev) == PCI_EXP_TYPE_DOWNSTREAM ||

commit 0617bdede5114a0002298b12cd0ca2b0cfd0395d
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Wed Aug 7 13:57:18 2019 +0300

    Revert "PCI: Add missing link delays required by the PCIe spec"
    
    Commit c2bf1fc212f7 ("PCI: Add missing link delays required by the PCIe
    spec") turned out causing issues with some systems either by making them
    unresponsive or slowing down runtime and system wide resume of PCIe
    devices. While root cause for the unresponsiveness is still under
    investigation given the amount of issues reported better to revert it
    for now.
    
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=204413
    Link: https://lore.kernel.org/linux-pci/SL2P216MB01878BBCD75F21D882AEEA2880C60@SL2P216MB0187.KORP216.PROD.OUTLOOK.COM/
    Link: https://lore.kernel.org/linux-pci/2857501d-c167-547d-c57d-d5d24ea1f1dc@molgen.mpg.de/
    Reported-by: Matthias Andree <matthias.andree@gmx.de>
    Reported-by: Paul Menzel <pmenzel@molgen.mpg.de>
    Reported-by: Nicholas Johnson <nicholas.johnson-opensource@outlook.com.au>
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index 308c3e0c4a34..1b330129089f 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -9,7 +9,6 @@
 #include <linux/module.h>
 #include <linux/pci.h>
 #include <linux/kernel.h>
-#include <linux/delay.h>
 #include <linux/errno.h>
 #include <linux/pm.h>
 #include <linux/pm_runtime.h>
@@ -379,67 +378,6 @@ static int pm_iter(struct device *dev, void *data)
 	return 0;
 }
 
-static int get_downstream_delay(struct pci_bus *bus)
-{
-	struct pci_dev *pdev;
-	int min_delay = 100;
-	int max_delay = 0;
-
-	list_for_each_entry(pdev, &bus->devices, bus_list) {
-		if (!pdev->imm_ready)
-			min_delay = 0;
-		else if (pdev->d3cold_delay < min_delay)
-			min_delay = pdev->d3cold_delay;
-		if (pdev->d3cold_delay > max_delay)
-			max_delay = pdev->d3cold_delay;
-	}
-
-	return max(min_delay, max_delay);
-}
-
-/*
- * wait_for_downstream_link - Wait for downstream link to establish
- * @pdev: PCIe port whose downstream link is waited
- *
- * Handle delays according to PCIe 4.0 section 6.6.1 before configuration
- * access to the downstream component is permitted.
- *
- * This blocks PCI core resume of the hierarchy below this port until the
- * link is trained. Should be called before resuming port services to
- * prevent pciehp from starting to tear-down the hierarchy too soon.
- */
-static void wait_for_downstream_link(struct pci_dev *pdev)
-{
-	int delay;
-
-	if (pci_pcie_type(pdev) != PCI_EXP_TYPE_ROOT_PORT &&
-	    pci_pcie_type(pdev) != PCI_EXP_TYPE_DOWNSTREAM)
-		return;
-
-	if (pci_dev_is_disconnected(pdev))
-		return;
-
-	if (!pdev->subordinate || list_empty(&pdev->subordinate->devices) ||
-	    !pdev->bridge_d3)
-		return;
-
-	delay = get_downstream_delay(pdev->subordinate);
-	if (!delay)
-		return;
-
-	dev_dbg(&pdev->dev, "waiting downstream link for %d ms\n", delay);
-
-	/*
-	 * If downstream port does not support speeds greater than 5 GT/s
-	 * need to wait 100ms. For higher speeds (gen3) we need to wait
-	 * first for the data link layer to become active.
-	 */
-	if (pcie_get_speed_cap(pdev) <= PCIE_SPEED_5_0GT)
-		msleep(delay);
-	else
-		pcie_wait_for_link_delay(pdev, true, delay);
-}
-
 /**
  * pcie_port_device_suspend - suspend port services associated with a PCIe port
  * @dev: PCI Express port to handle
@@ -453,8 +391,6 @@ int pcie_port_device_suspend(struct device *dev)
 int pcie_port_device_resume_noirq(struct device *dev)
 {
 	size_t off = offsetof(struct pcie_port_service_driver, resume_noirq);
-
-	wait_for_downstream_link(to_pci_dev(dev));
 	return device_for_each_child(dev, &off, pm_iter);
 }
 
@@ -485,8 +421,6 @@ int pcie_port_device_runtime_suspend(struct device *dev)
 int pcie_port_device_runtime_resume(struct device *dev)
 {
 	size_t off = offsetof(struct pcie_port_service_driver, runtime_resume);
-
-	wait_for_downstream_link(to_pci_dev(dev));
 	return device_for_each_child(dev, &off, pm_iter);
 }
 #endif /* PM */

commit c2bf1fc212f7e6f25ace1af8f0b3ac061ea48ba5
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Wed Jun 12 13:57:38 2019 +0300

    PCI: Add missing link delays required by the PCIe spec
    
    Currently Linux does not follow PCIe spec regarding the required delays
    after reset. A concrete example is a Thunderbolt add-in-card that
    consists of a PCIe switch and two PCIe endpoints:
    
      +-1b.0-[01-6b]----00.0-[02-6b]--+-00.0-[03]----00.0 TBT controller
                                      +-01.0-[04-36]-- DS hotplug port
                                      +-02.0-[37]----00.0 xHCI controller
                                      \-04.0-[38-6b]-- DS hotplug port
    
    The root port (1b.0) and the PCIe switch downstream ports are all PCIe
    gen3 so they support 8GT/s link speeds.
    
    We wait for the PCIe hierarchy to enter D3cold (runtime):
    
      pcieport 0000:00:1b.0: power state changed by ACPI to D3cold
    
    When it wakes up from D3cold, according to the PCIe 4.0 section 5.8 the
    PCIe switch is put to reset and its power is re-applied. This means that
    we must follow the rules in PCIe 4.0 section 6.6.1.
    
    For the PCIe gen3 ports we are dealing with here, the following applies:
    
      With a Downstream Port that supports Link speeds greater than 5.0
      GT/s, software must wait a minimum of 100 ms after Link training
      completes before sending a Configuration Request to the device
      immediately below that Port. Software can determine when Link training
      completes by polling the Data Link Layer Link Active bit or by setting
      up an associated interrupt (see Section 6.7.3.3).
    
    Translating this into the above topology we would need to do this (DLLLA
    stands for Data Link Layer Link Active):
    
      pcieport 0000:00:1b.0: wait for 100ms after DLLLA is set before access to 0000:01:00.0
      pcieport 0000:02:00.0: wait for 100ms after DLLLA is set before access to 0000:03:00.0
      pcieport 0000:02:02.0: wait for 100ms after DLLLA is set before access to 0000:37:00.0
    
    I've instrumented the kernel with additional logging so we can see the
    actual delays the kernel performs:
    
      pcieport 0000:00:1b.0: power state changed by ACPI to D0
      pcieport 0000:00:1b.0: waiting for D3cold delay of 100 ms
      pcieport 0000:00:1b.0: waking up bus
      pcieport 0000:00:1b.0: waiting for D3hot delay of 10 ms
      pcieport 0000:00:1b.0: restoring config space at offset 0x2c (was 0x60, writing 0x60)
      ...
      pcieport 0000:00:1b.0: PME# disabled
      pcieport 0000:01:00.0: restoring config space at offset 0x3c (was 0x1ff, writing 0x201ff)
      ...
      pcieport 0000:01:00.0: PME# disabled
      pcieport 0000:02:00.0: restoring config space at offset 0x3c (was 0x1ff, writing 0x201ff)
      ...
      pcieport 0000:02:00.0: PME# disabled
      pcieport 0000:02:01.0: restoring config space at offset 0x3c (was 0x1ff, writing 0x201ff)
      ...
      pcieport 0000:02:01.0: restoring config space at offset 0x4 (was 0x100000, writing 0x100407)
      pcieport 0000:02:01.0: PME# disabled
      pcieport 0000:02:02.0: restoring config space at offset 0x3c (was 0x1ff, writing 0x201ff)
      ...
      pcieport 0000:02:02.0: PME# disabled
      pcieport 0000:02:04.0: restoring config space at offset 0x3c (was 0x1ff, writing 0x201ff)
      ...
      pcieport 0000:02:04.0: PME# disabled
      pcieport 0000:02:01.0: PME# enabled
      pcieport 0000:02:01.0: waiting for D3hot delay of 10 ms
      pcieport 0000:02:04.0: PME# enabled
      pcieport 0000:02:04.0: waiting for D3hot delay of 10 ms
      thunderbolt 0000:03:00.0: restoring config space at offset 0x14 (was 0x0, writing 0x8a040000)
      ...
      thunderbolt 0000:03:00.0: PME# disabled
      xhci_hcd 0000:37:00.0: restoring config space at offset 0x10 (was 0x0, writing 0x73f00000)
      ...
      xhci_hcd 0000:37:00.0: PME# disabled
    
    For the switch upstream port (01:00.0) we wait for 100ms but not taking
    into account the DLLLA requirement. We then wait 10ms for D3hot -> D0
    transition of the root port and the two downstream hotplug ports. This
    means that we deviate from what the spec requires.
    
    Performing the same check for system sleep (s2idle) transitions we can
    see following when resuming from s2idle:
    
      pcieport 0000:00:1b.0: power state changed by ACPI to D0
      pcieport 0000:00:1b.0: restoring config space at offset 0x2c (was 0x60, writing 0x60)
      ...
      pcieport 0000:01:00.0: restoring config space at offset 0x3c (was 0x1ff, writing 0x201ff)
      ...
      pcieport 0000:02:02.0: restoring config space at offset 0x3c (was 0x1ff, writing 0x201ff)
      pcieport 0000:02:02.0: restoring config space at offset 0x2c (was 0x0, writing 0x0)
      pcieport 0000:02:01.0: restoring config space at offset 0x3c (was 0x1ff, writing 0x201ff)
      pcieport 0000:02:04.0: restoring config space at offset 0x3c (was 0x1ff, writing 0x201ff)
      pcieport 0000:02:02.0: restoring config space at offset 0x28 (was 0x0, writing 0x0)
      pcieport 0000:02:00.0: restoring config space at offset 0x3c (was 0x1ff, writing 0x201ff)
      pcieport 0000:02:02.0: restoring config space at offset 0x24 (was 0x10001, writing 0x1fff1)
      pcieport 0000:02:01.0: restoring config space at offset 0x2c (was 0x0, writing 0x60)
      pcieport 0000:02:02.0: restoring config space at offset 0x20 (was 0x0, writing 0x73f073f0)
      pcieport 0000:02:04.0: restoring config space at offset 0x2c (was 0x0, writing 0x60)
      pcieport 0000:02:01.0: restoring config space at offset 0x28 (was 0x0, writing 0x60)
      pcieport 0000:02:00.0: restoring config space at offset 0x2c (was 0x0, writing 0x0)
      pcieport 0000:02:02.0: restoring config space at offset 0x1c (was 0x101, writing 0x1f1)
      pcieport 0000:02:04.0: restoring config space at offset 0x28 (was 0x0, writing 0x60)
      pcieport 0000:02:01.0: restoring config space at offset 0x24 (was 0x10001, writing 0x1ff10001)
      pcieport 0000:02:00.0: restoring config space at offset 0x28 (was 0x0, writing 0x0)
      pcieport 0000:02:02.0: restoring config space at offset 0x18 (was 0x0, writing 0x373702)
      pcieport 0000:02:04.0: restoring config space at offset 0x24 (was 0x10001, writing 0x49f12001)
      pcieport 0000:02:01.0: restoring config space at offset 0x20 (was 0x0, writing 0x73e05c00)
      pcieport 0000:02:00.0: restoring config space at offset 0x24 (was 0x10001, writing 0x1fff1)
      pcieport 0000:02:04.0: restoring config space at offset 0x20 (was 0x0, writing 0x89f07400)
      pcieport 0000:02:01.0: restoring config space at offset 0x1c (was 0x101, writing 0x5151)
      pcieport 0000:02:00.0: restoring config space at offset 0x20 (was 0x0, writing 0x8a008a00)
      pcieport 0000:02:02.0: restoring config space at offset 0xc (was 0x10000, writing 0x10020)
      pcieport 0000:02:04.0: restoring config space at offset 0x1c (was 0x101, writing 0x6161)
      pcieport 0000:02:01.0: restoring config space at offset 0x18 (was 0x0, writing 0x360402)
      pcieport 0000:02:00.0: restoring config space at offset 0x1c (was 0x101, writing 0x1f1)
      pcieport 0000:02:04.0: restoring config space at offset 0x18 (was 0x0, writing 0x6b3802)
      pcieport 0000:02:02.0: restoring config space at offset 0x4 (was 0x100000, writing 0x100407)
      pcieport 0000:02:00.0: restoring config space at offset 0x18 (was 0x0, writing 0x30302)
      pcieport 0000:02:01.0: restoring config space at offset 0xc (was 0x10000, writing 0x10020)
      pcieport 0000:02:04.0: restoring config space at offset 0xc (was 0x10000, writing 0x10020)
      pcieport 0000:02:00.0: restoring config space at offset 0xc (was 0x10000, writing 0x10020)
      pcieport 0000:02:01.0: restoring config space at offset 0x4 (was 0x100000, writing 0x100407)
      pcieport 0000:02:04.0: restoring config space at offset 0x4 (was 0x100000, writing 0x100407)
      pcieport 0000:02:00.0: restoring config space at offset 0x4 (was 0x100000, writing 0x100407)
      xhci_hcd 0000:37:00.0: restoring config space at offset 0x10 (was 0x0, writing 0x73f00000)
      ...
      thunderbolt 0000:03:00.0: restoring config space at offset 0x14 (was 0x0, writing 0x8a040000)
    
    This is even worse. None of the mandatory delays are performed. If this
    would be S3 instead of s2idle then according to PCI FW spec 3.2 section
    4.6.8.  there is a specific _DSM that allows the OS to skip the delays
    but this platform does not provide the _DSM and does not go to S3 anyway
    so no firmware is involved that could already handle these delays.
    
    In this particular Intel Coffee Lake platform these delays are not
    actually needed because there is an additional delay as part of the ACPI
    power resource that is used to turn on power to the hierarchy but since
    that additional delay is not required by any of standards (PCIe, ACPI)
    it is not present in the Intel Ice Lake, for example where missing the
    mandatory delays causes pciehp to start tearing down the stack too early
    (links are not yet trained).
    
    For this reason, change the PCIe portdrv PM resume hooks so that they
    perform the mandatory delays before the downstream component gets
    resumed. We perform the delays before port services are resumed because
    otherwise pciehp might find that the link is not up (even if it is just
    training) and tears-down the hierarchy.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index 1b330129089f..308c3e0c4a34 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -9,6 +9,7 @@
 #include <linux/module.h>
 #include <linux/pci.h>
 #include <linux/kernel.h>
+#include <linux/delay.h>
 #include <linux/errno.h>
 #include <linux/pm.h>
 #include <linux/pm_runtime.h>
@@ -378,6 +379,67 @@ static int pm_iter(struct device *dev, void *data)
 	return 0;
 }
 
+static int get_downstream_delay(struct pci_bus *bus)
+{
+	struct pci_dev *pdev;
+	int min_delay = 100;
+	int max_delay = 0;
+
+	list_for_each_entry(pdev, &bus->devices, bus_list) {
+		if (!pdev->imm_ready)
+			min_delay = 0;
+		else if (pdev->d3cold_delay < min_delay)
+			min_delay = pdev->d3cold_delay;
+		if (pdev->d3cold_delay > max_delay)
+			max_delay = pdev->d3cold_delay;
+	}
+
+	return max(min_delay, max_delay);
+}
+
+/*
+ * wait_for_downstream_link - Wait for downstream link to establish
+ * @pdev: PCIe port whose downstream link is waited
+ *
+ * Handle delays according to PCIe 4.0 section 6.6.1 before configuration
+ * access to the downstream component is permitted.
+ *
+ * This blocks PCI core resume of the hierarchy below this port until the
+ * link is trained. Should be called before resuming port services to
+ * prevent pciehp from starting to tear-down the hierarchy too soon.
+ */
+static void wait_for_downstream_link(struct pci_dev *pdev)
+{
+	int delay;
+
+	if (pci_pcie_type(pdev) != PCI_EXP_TYPE_ROOT_PORT &&
+	    pci_pcie_type(pdev) != PCI_EXP_TYPE_DOWNSTREAM)
+		return;
+
+	if (pci_dev_is_disconnected(pdev))
+		return;
+
+	if (!pdev->subordinate || list_empty(&pdev->subordinate->devices) ||
+	    !pdev->bridge_d3)
+		return;
+
+	delay = get_downstream_delay(pdev->subordinate);
+	if (!delay)
+		return;
+
+	dev_dbg(&pdev->dev, "waiting downstream link for %d ms\n", delay);
+
+	/*
+	 * If downstream port does not support speeds greater than 5 GT/s
+	 * need to wait 100ms. For higher speeds (gen3) we need to wait
+	 * first for the data link layer to become active.
+	 */
+	if (pcie_get_speed_cap(pdev) <= PCIE_SPEED_5_0GT)
+		msleep(delay);
+	else
+		pcie_wait_for_link_delay(pdev, true, delay);
+}
+
 /**
  * pcie_port_device_suspend - suspend port services associated with a PCIe port
  * @dev: PCI Express port to handle
@@ -391,6 +453,8 @@ int pcie_port_device_suspend(struct device *dev)
 int pcie_port_device_resume_noirq(struct device *dev)
 {
 	size_t off = offsetof(struct pcie_port_service_driver, resume_noirq);
+
+	wait_for_downstream_link(to_pci_dev(dev));
 	return device_for_each_child(dev, &off, pm_iter);
 }
 
@@ -421,6 +485,8 @@ int pcie_port_device_runtime_suspend(struct device *dev)
 int pcie_port_device_runtime_resume(struct device *dev)
 {
 	size_t off = offsetof(struct pcie_port_service_driver, runtime_resume);
+
+	wait_for_downstream_link(to_pci_dev(dev));
 	return device_for_each_child(dev, &off, pm_iter);
 }
 #endif /* PM */

commit 15d2aba7c602cd9005b20ff011b670547b3882c4
Author: Alex Williamson <alex.williamson@redhat.com>
Date:   Mon Apr 22 16:43:30 2019 -0600

    PCI/portdrv: Use shared MSI/MSI-X vector for Bandwidth Management
    
    The Interrupt Message Number in the PCIe Capabilities register (PCIe r4.0,
    sec 7.5.3.2) indicates which MSI/MSI-X vector is shared by interrupts
    related to the PCIe Capability, including Link Bandwidth Management and
    Link Autonomous Bandwidth Interrupts (Link Control, 7.5.3.7), Command
    Completed and Hot-Plug Interrupts (Slot Control, 7.5.3.10), and the PME
    Interrupt (Root Control, 7.5.3.12).
    
    pcie_message_numbers() checked whether we want to enable PME or Hot-Plug
    interrupts but neglected to check for Link Bandwidth Management, so if we
    only wanted the Bandwidth Management interrupts, it decided we didn't need
    any vectors at all.  Then pcie_port_enable_irq_vec() tried to reallocate
    zero vectors, which failed, resulting in fallback to INTx.
    
    On some systems, e.g., an X79-based workstation, that INTx seems broken or
    not handled correctly, so we got spurious IRQ16 interrupts for Bandwidth
    Management events.
    
    Change pcie_message_numbers() so that if we want Link Bandwidth Management
    interrupts, we use the shared MSI/MSI-X vector from the PCIe Capabilities
    register.
    
    Fixes: e8303bb7a75c ("PCI/LINK: Report degraded links via link bandwidth notification")
    Link: https://lore.kernel.org/lkml/155597243666.19387.1205950870601742062.stgit@gimli.home
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
    [bhelgaas: changelog]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index 7d04f9d087a6..1b330129089f 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -55,7 +55,8 @@ static int pcie_message_numbers(struct pci_dev *dev, int mask,
 	 * 7.8.2, 7.10.10, 7.31.2.
 	 */
 
-	if (mask & (PCIE_PORT_SERVICE_PME | PCIE_PORT_SERVICE_HP)) {
+	if (mask & (PCIE_PORT_SERVICE_PME | PCIE_PORT_SERVICE_HP |
+		    PCIE_PORT_SERVICE_BWNOTIF)) {
 		pcie_capability_read_word(dev, PCI_EXP_FLAGS, &reg16);
 		*pme = (reg16 & PCI_EXP_FLAGS_IRQ) >> 9;
 		nvec = *pme + 1;

commit e8303bb7a75c113388badcc49b2a84b4121c1b3e
Author: Alexandru Gagniuc <mr.nuke.me@gmail.com>
Date:   Wed Feb 27 14:58:17 2019 -0600

    PCI/LINK: Report degraded links via link bandwidth notification
    
    A warning is generated when a PCIe device is probed with a degraded link,
    but there was no similar mechanism to warn when the link becomes degraded
    after probing.  The Link Bandwidth Notification provides this mechanism.
    
    Use the Link Bandwidth Management Interrupt to detect bandwidth changes,
    and rescan the bandwidth, looking for the weakest point.  This is the same
    logic used in probe().
    
    Signed-off-by: Alexandru Gagniuc <mr.nuke.me@gmail.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Lukas Wunner <lukas@wunner.de>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index f458ac9cb70c..7d04f9d087a6 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -99,7 +99,7 @@ static int pcie_message_numbers(struct pci_dev *dev, int mask,
  */
 static int pcie_port_enable_irq_vec(struct pci_dev *dev, int *irqs, int mask)
 {
-	int nr_entries, nvec;
+	int nr_entries, nvec, pcie_irq;
 	u32 pme = 0, aer = 0, dpc = 0;
 
 	/* Allocate the maximum possible number of MSI/MSI-X vectors */
@@ -135,10 +135,13 @@ static int pcie_port_enable_irq_vec(struct pci_dev *dev, int *irqs, int mask)
 			return nr_entries;
 	}
 
-	/* PME and hotplug share an MSI/MSI-X vector */
-	if (mask & (PCIE_PORT_SERVICE_PME | PCIE_PORT_SERVICE_HP)) {
-		irqs[PCIE_PORT_SERVICE_PME_SHIFT] = pci_irq_vector(dev, pme);
-		irqs[PCIE_PORT_SERVICE_HP_SHIFT] = pci_irq_vector(dev, pme);
+	/* PME, hotplug and bandwidth notification share an MSI/MSI-X vector */
+	if (mask & (PCIE_PORT_SERVICE_PME | PCIE_PORT_SERVICE_HP |
+		    PCIE_PORT_SERVICE_BWNOTIF)) {
+		pcie_irq = pci_irq_vector(dev, pme);
+		irqs[PCIE_PORT_SERVICE_PME_SHIFT] = pcie_irq;
+		irqs[PCIE_PORT_SERVICE_HP_SHIFT] = pcie_irq;
+		irqs[PCIE_PORT_SERVICE_BWNOTIF_SHIFT] = pcie_irq;
 	}
 
 	if (mask & PCIE_PORT_SERVICE_AER)
@@ -250,6 +253,10 @@ static int get_port_device_capability(struct pci_dev *dev)
 	    pci_aer_available() && services & PCIE_PORT_SERVICE_AER)
 		services |= PCIE_PORT_SERVICE_DPC;
 
+	if (pci_pcie_type(dev) == PCI_EXP_TYPE_DOWNSTREAM ||
+	    pci_pcie_type(dev) == PCI_EXP_TYPE_ROOT_PORT)
+		services |= PCIE_PORT_SERVICE_BWNOTIF;
+
 	return services;
 }
 

commit 0e98db259fd8760fde556e640b447dadeceefc96
Author: Keith Busch <keith.busch@intel.com>
Date:   Thu Oct 11 12:34:10 2018 -0600

    PCI/AER: Reuse existing pcie_port_find_device() interface
    
    The port services driver already provides a method to find the pcie_device
    for a service.  Export that function, use it from the aer_inject module,
    and remove the duplicate functionality.
    
    Signed-off-by: Keith Busch <keith.busch@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index 6542c48c7f59..f458ac9cb70c 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -486,6 +486,7 @@ struct device *pcie_port_find_device(struct pci_dev *dev,
 	device = pdrvs.dev;
 	return device;
 }
+EXPORT_SYMBOL_GPL(pcie_port_find_device);
 
 /**
  * pcie_port_device_remove - unregister PCI Express port service devices

commit 94c7993fb5bd1e3c20f67a2d24ba05bbdc938340
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Thu Sep 27 16:41:48 2018 -0500

    PCI/portdrv: Add runtime PM hooks for port service drivers
    
    When PCIe port is runtime suspended/resumed some extra steps might be
    needed to be executed from the port service driver side. For instance we
    may need to disable PCIe hotplug interrupt to prevent it from triggering
    immediately when PCIe link to the downstream component goes down.
    
    To make the above possible add optional ->runtime_suspend() and
    ->runtime_resume() callbacks to struct pcie_port_service_driver and call
    them for each port service in runtime suspend/resume callbacks of portdrv.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    [bhelgaas: adjust "slot->state" for 5790a9c78e78 ("PCI: pciehp: Unify
    controller and slot structs")]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index 7c37d815229e..6542c48c7f59 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -395,6 +395,26 @@ int pcie_port_device_resume(struct device *dev)
 	size_t off = offsetof(struct pcie_port_service_driver, resume);
 	return device_for_each_child(dev, &off, pm_iter);
 }
+
+/**
+ * pcie_port_device_runtime_suspend - runtime suspend port services
+ * @dev: PCI Express port to handle
+ */
+int pcie_port_device_runtime_suspend(struct device *dev)
+{
+	size_t off = offsetof(struct pcie_port_service_driver, runtime_suspend);
+	return device_for_each_child(dev, &off, pm_iter);
+}
+
+/**
+ * pcie_port_device_runtime_resume - runtime resume port services
+ * @dev: PCI Express port to handle
+ */
+int pcie_port_device_runtime_resume(struct device *dev)
+{
+	size_t off = offsetof(struct pcie_port_service_driver, runtime_resume);
+	return device_for_each_child(dev, &off, pm_iter);
+}
 #endif /* PM */
 
 static int remove_iter(struct device *dev, void *data)

commit 7903782460ee1813d6779c968b28d0ac71b9b3ae
Author: Lukas Wunner <lukas@wunner.de>
Date:   Thu Jul 19 17:27:53 2018 -0500

    PCI: pciehp: Clear spurious events earlier on resume
    
    Thunderbolt hotplug ports that were occupied before system sleep resume
    with their downstream link in "off" state.  Only after the Thunderbolt
    controller has reestablished the PCIe tunnels does the link go up.
    As a result, a spurious Presence Detect Changed and/or Data Link Layer
    State Changed event occurs.
    
    The events are not immediately acted upon because tunnel reestablishment
    happens in the ->resume_noirq phase, when interrupts are still disabled.
    Also, notification of events may initially be disabled in the Slot
    Control register when coming out of system sleep and is reenabled in the
    ->resume_noirq phase through:
    
      pci_pm_resume_noirq()
        pci_pm_default_resume_early()
          pci_restore_state()
            pci_restore_pcie_state()
    
    It is not guaranteed that the events are acted upon at all:  PCIe r4.0,
    sec 6.7.3.4 says that "a port may optionally send an MSI when there are
    hot-plug events that occur while interrupt generation is disabled, and
    interrupt generation is subsequently enabled."  Note the "optionally".
    
    If an MSI is sent, pciehp will gratuitously turn the slot off and back
    on once the ->resume_early phase has commenced.
    
    If an MSI is not sent, the extant, unacknowledged events in the Slot
    Status register will prevent future notification of presence or link
    changes.
    
    Commit 13c65840feab ("PCI: pciehp: Clear Presence Detect and Data Link
    Layer Status Changed on resume") fixed the latter by clearing the events
    in the ->resume phase.  Move this to the ->resume_noirq phase to also
    fix the gratuitous disable/enablement of the slot.
    
    The commit further restored the Slot Control register in the ->resume
    phase, but that's dispensable because as shown above it's already been
    done in the ->resume_noirq phase.
    
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index 13a248575a14..7c37d815229e 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -380,6 +380,12 @@ int pcie_port_device_suspend(struct device *dev)
 	return device_for_each_child(dev, &off, pm_iter);
 }
 
+int pcie_port_device_resume_noirq(struct device *dev)
+{
+	size_t off = offsetof(struct pcie_port_service_driver, resume_noirq);
+	return device_for_each_child(dev, &off, pm_iter);
+}
+
 /**
  * pcie_port_device_resume - resume port services associated with a PCIe port
  * @dev: PCI Express port to handle

commit 6ccb127ba6dff251b75fa72e8c7777eaf12d9675
Author: Lukas Wunner <lukas@wunner.de>
Date:   Thu Jul 19 17:27:52 2018 -0500

    PCI: portdrv: Deduplicate PM callback iterator
    
    Replace suspend_iter() and resume_iter() with a single function pm_iter()
    to allow addition of port service callbacks for further power management
    phases without having to add another iterator each time.
    
    No functional change intended.
    
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index e0261ad4bcdd..13a248575a14 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -353,14 +353,19 @@ int pcie_port_device_register(struct pci_dev *dev)
 }
 
 #ifdef CONFIG_PM
-static int suspend_iter(struct device *dev, void *data)
+typedef int (*pcie_pm_callback_t)(struct pcie_device *);
+
+static int pm_iter(struct device *dev, void *data)
 {
 	struct pcie_port_service_driver *service_driver;
+	size_t offset = *(size_t *)data;
+	pcie_pm_callback_t cb;
 
 	if ((dev->bus == &pcie_port_bus_type) && dev->driver) {
 		service_driver = to_service_driver(dev->driver);
-		if (service_driver->suspend)
-			service_driver->suspend(to_pcie_device(dev));
+		cb = *(pcie_pm_callback_t *)((void *)service_driver + offset);
+		if (cb)
+			return cb(to_pcie_device(dev));
 	}
 	return 0;
 }
@@ -371,20 +376,8 @@ static int suspend_iter(struct device *dev, void *data)
  */
 int pcie_port_device_suspend(struct device *dev)
 {
-	return device_for_each_child(dev, NULL, suspend_iter);
-}
-
-static int resume_iter(struct device *dev, void *data)
-{
-	struct pcie_port_service_driver *service_driver;
-
-	if ((dev->bus == &pcie_port_bus_type) &&
-	    (dev->driver)) {
-		service_driver = to_service_driver(dev->driver);
-		if (service_driver->resume)
-			service_driver->resume(to_pcie_device(dev));
-	}
-	return 0;
+	size_t off = offsetof(struct pcie_port_service_driver, suspend);
+	return device_for_each_child(dev, &off, pm_iter);
 }
 
 /**
@@ -393,7 +386,8 @@ static int resume_iter(struct device *dev, void *data)
  */
 int pcie_port_device_resume(struct device *dev)
 {
-	return device_for_each_child(dev, NULL, resume_iter);
+	size_t off = offsetof(struct pcie_port_service_driver, resume);
+	return device_for_each_child(dev, &off, pm_iter);
 }
 #endif /* PM */
 

commit f64c14641028d4cbe52a753482ecf7334ec39724
Merge: 5e3165d1a813 e412d63d6025
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Jun 6 16:10:10 2018 -0500

    Merge branch 'pci/hotplug'
    
      - fix use-before-set error in ibmphp (Dan Carpenter)
    
      - fix pciehp timeouts caused by Command Completed errata (Bjorn Helgaas)
    
      - fix refcounting in pnv_php hotplug (Julia Lawall)
    
      - clear pciehp Presence Detect and Data Link Layer Status Changed on
        resume so we don't miss hotplug events (Mika Westerberg)
    
      - only request pciehp control if we support it, so platform can use ACPI
        hotplug otherwise (Mika Westerberg)
    
      - convert SHPC to be builtin only (Mika Westerberg)
    
      - request SHPC control via _OSC if we support it (Mika Westerberg)
    
      - simplify SHPC handoff from firmware (Mika Westerberg)
    
    * pci/hotplug:
      PCI: Improve "partially hidden behind bridge" log message
      PCI: Improve pci_scan_bridge() and pci_scan_bridge_extend() doc
      PCI: Move resource distribution for single bridge outside loop
      PCI: Account for all bridges on bus when distributing bus numbers
      ACPI / hotplug / PCI: Drop unnecessary parentheses
      ACPI / hotplug / PCI: Mark stale PCI devices disconnected
      ACPI / hotplug / PCI: Don't scan bridges managed by native hotplug
      PCI: hotplug: Add hotplug_is_native()
      PCI: shpchp: Add shpchp_is_native()
      PCI: shpchp: Fix AMD POGO identification
      PCI: shpchp: Use dev_printk() for OSHP-related messages
      PCI: shpchp: Remove get_hp_hw_control_from_firmware() wrapper
      PCI: shpchp: Remove acpi_get_hp_hw_control_from_firmware() flags
      PCI: shpchp: Rely on previous _OSC results
      PCI: shpchp: Request SHPC control via _OSC when adding host bridge
      PCI: shpchp: Convert SHPC to be builtin only
      PCI: pciehp: Make pciehp_is_native() stricter
      PCI: pciehp: Rename host->native_hotplug to host->native_pcie_hotplug
      PCI: pciehp: Request control of native hotplug only if supported
      PCI: pciehp: Clear Presence Detect and Data Link Layer Status Changed on resume
      PCI: pnv_php: Add missing of_node_put()
      PCI: pciehp: Add quirk for Command Completed errata
      PCI: Add Qualcomm vendor ID
      PCI: ibmphp: Fix use-before-set in get_max_bus_speed()
    
    # Conflicts:
    #       drivers/acpi/pci_root.c

commit e76d596aef0caa7296e42e29a0a81bc4155807df
Author: Oza Pawandeep <poza@codeaurora.org>
Date:   Thu May 17 16:44:17 2018 -0500

    PCI/portdrv: Add generic pcie_port_find_device()
    
    Add generic pcie_port_find_device() routine.
    
    Signed-off-by: Oza Pawandeep <poza@codeaurora.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Keith Busch <keith.busch@intel.com>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index 62468d2f2056..a9c581df7a62 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -21,6 +21,7 @@
 
 struct portdrv_service_data {
 	struct pcie_port_service_driver *drv;
+	struct device *dev;
 	u32 service;
 };
 
@@ -416,6 +417,7 @@ static int find_service_iter(struct device *device, void *data)
 		service_driver = to_service_driver(device->driver);
 		if (service_driver->service == service) {
 			pdrvs->drv = service_driver;
+			pdrvs->dev = device;
 			return 1;
 		}
 	}
@@ -444,6 +446,27 @@ struct pcie_port_service_driver *pcie_port_find_service(struct pci_dev *dev,
 	return drv;
 }
 
+/**
+ * pcie_port_find_device - find the struct device
+ * @dev: PCI Express port the service is associated with
+ * @service: For the service to find
+ *
+ * Find the struct device associated with given service on a pci_dev
+ */
+struct device *pcie_port_find_device(struct pci_dev *dev,
+				      u32 service)
+{
+	struct device *device;
+	struct portdrv_service_data pdrvs;
+
+	pdrvs.dev = NULL;
+	pdrvs.service = service;
+	device_for_each_child(&dev->dev, &pdrvs, find_service_iter);
+
+	device = pdrvs.dev;
+	return device;
+}
+
 /**
  * pcie_port_device_remove - unregister PCI Express port service devices
  * @dev: PCI Express port the service devices to unregister are associated with

commit 9310f0dc1c6430ca9e370a8341bea9f5dc85f40b
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Wed May 23 17:22:19 2018 -0500

    PCI: pciehp: Rename host->native_hotplug to host->native_pcie_hotplug
    
    Rename host->native_hotplug to host->native_pcie_hotplug to make room for a
    similar flag for SHPC hotplug.
    
    Suggested-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    [bhelgaas: split to separate patch]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index c9c0663db282..6cb30aec2452 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -199,7 +199,7 @@ static int get_port_device_capability(struct pci_dev *dev)
 	int services = 0;
 
 	if (dev->is_hotplug_bridge &&
-	    (pcie_ports_native || host->native_hotplug)) {
+	    (pcie_ports_native || host->native_pcie_hotplug)) {
 		services |= PCIE_PORT_SERVICE_HP;
 
 		/*

commit f252d0621a1102a66aa833f09531a3baec261288
Author: Oza Pawandeep <poza@codeaurora.org>
Date:   Thu May 17 16:44:16 2018 -0500

    PCI/portdrv: Add generic pcie_port_find_service()
    
    Add generic pcie_port_find_service() routine.
    
    Signed-off-by: Oza Pawandeep <poza@codeaurora.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Keith Busch <keith.busch@intel.com>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index c9c0663db282..62468d2f2056 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -19,6 +19,11 @@
 #include "../pci.h"
 #include "portdrv.h"
 
+struct portdrv_service_data {
+	struct pcie_port_service_driver *drv;
+	u32 service;
+};
+
 /**
  * release_pcie_device - free PCI Express port service device structure
  * @dev: Port service device to release
@@ -398,6 +403,47 @@ static int remove_iter(struct device *dev, void *data)
 	return 0;
 }
 
+static int find_service_iter(struct device *device, void *data)
+{
+	struct pcie_port_service_driver *service_driver;
+	struct portdrv_service_data *pdrvs;
+	u32 service;
+
+	pdrvs = (struct portdrv_service_data *) data;
+	service = pdrvs->service;
+
+	if (device->bus == &pcie_port_bus_type && device->driver) {
+		service_driver = to_service_driver(device->driver);
+		if (service_driver->service == service) {
+			pdrvs->drv = service_driver;
+			return 1;
+		}
+	}
+
+	return 0;
+}
+
+/**
+ * pcie_port_find_service - find the service driver
+ * @dev: PCI Express port the service is associated with
+ * @service: Service to find
+ *
+ * Find PCI Express port service driver associated with given service
+ */
+struct pcie_port_service_driver *pcie_port_find_service(struct pci_dev *dev,
+							u32 service)
+{
+	struct pcie_port_service_driver *drv;
+	struct portdrv_service_data pdrvs;
+
+	pdrvs.drv = NULL;
+	pdrvs.service = service;
+	device_for_each_child(&dev->dev, &pdrvs, find_service_iter);
+
+	drv = pdrvs.drv;
+	return drv;
+}
+
 /**
  * pcie_port_device_remove - unregister PCI Express port service devices
  * @dev: PCI Express port the service devices to unregister are associated with

commit 64ae499cf2eece26bc395184aa2c9a18aa49d199
Merge: ac30aa596996 e02602bd7625
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Apr 4 13:27:58 2018 -0500

    Merge branch 'pci/portdrv'
    
      - move pcieport_if.h to drivers/pci/pcie/ to encapsulate it (Frederick
        Lawler)
    
      - merge pcieport_if.h into portdrv.h (Bjorn Helgaas)
    
      - move workaround for BIOS PME issue from portdrv to PCI core (Bjorn
        Helgaas)
    
      - completely disable portdrv with "pcie_ports=compat" (Bjorn Helgaas)
    
      - remove portdrv link order dependency (Bjorn Helgaas)
    
      - remove support for unused VC portdrv service (Bjorn Helgaas)
    
      - simplify portdrv feature permission checking (Bjorn Helgaas)
    
      - remove "pcie_hp=nomsi" parameter (use "pci=nomsi" instead) (Bjorn
        Helgaas)
    
      - remove unnecessary "pcie_ports=auto" parameter (Bjorn Helgaas)
    
      - use cached AER capability offset (Frederick Lawler)
    
      - don't enable DPC if BIOS hasn't granted AER control (Mika Westerberg)
    
      - rename pcie-dpc.c to dpc.c (Bjorn Helgaas)
    
    * pci/portdrv:
      PCI/DPC: Rename from pcie-dpc.c to dpc.c
      PCI/DPC: Do not enable DPC if AER control is not allowed by the BIOS
      PCI/AER: Use cached AER Capability offset
      PCI/portdrv: Rename and reverse sense of pcie_ports_auto
      PCI/portdrv: Encapsulate pcie_ports_auto inside the port driver
      PCI/portdrv: Remove unnecessary "pcie_ports=auto" parameter
      PCI/portdrv: Remove "pcie_hp=nomsi" kernel parameter
      PCI/portdrv: Remove unnecessary include of <linux/pci-aspm.h>
      PCI/portdrv: Simplify PCIe feature permission checking
      PCI/portdrv: Remove unused PCIE_PORT_SERVICE_VC
      PCI/portdrv: Remove pcie_port_bus_type link order dependency
      PCI/portdrv: Disable port driver in compat mode
      PCI/PM: Clear PCIe PME Status bit for Root Complex Event Collectors
      PCI/PM: Clear PCIe PME Status bit in core, not PCIe port driver
      PCI/PM: Move pcie_clear_root_pme_status() to core
      PCI/portdrv: Merge pcieport_if.h into portdrv.h
      PCI/portdrv: Move pcieport_if.h to drivers/pci/pcie/
    
    Conflicts:
            drivers/pci/pcie/Makefile
            drivers/pci/pcie/portdrv.h

commit 4e5fad429bd179a41fa8b222463397e8cc806cd1
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Tue Mar 27 13:48:35 2018 +0300

    PCI/DPC: Do not enable DPC if AER control is not allowed by the BIOS
    
    Commit eed85ff4c0da ("PCI/DPC: Enable DPC only if AER is available") made
    DPC control dependent whether AER is enabled in the OS.  However, it does
    not take into account situations where BIOS has not given OS control of
    AER:
    
      acpi PNP0A08:00: _OSC: OS supports [ExtendedConfig ASPM ClockPM Segments MSI]
      acpi PNP0A08:00: _OSC: platform does not support [AER]
      acpi PNP0A08:00: _OSC: OS now controls [PCIeHotplug PME PCIeCapability]
    
    I think here it is better not to enable DPC even if the capability is
    available because then it would be against what "Determination of DPC
    Control" note in PCIe 4.0 sec 6.1.10 recommends.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Bjorn Helgaas <helgaas@kernel.org>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index 099ef7ac615b..4ba4d05a5e4c 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -242,7 +242,7 @@ static int get_port_device_capability(struct pci_dev *dev)
 	}
 
 	if (pci_find_ext_capability(dev, PCI_EXT_CAP_ID_DPC) &&
-	    pci_aer_available())
+	    pci_aer_available() && services & PCIE_PORT_SERVICE_AER)
 		services |= PCIE_PORT_SERVICE_DPC;
 
 	return services;

commit f0553ba08a19031726f120448eedc3aff1599c23
Author: Frederick Lawler <fred@fredlawl.com>
Date:   Thu Mar 22 16:20:55 2018 -0500

    PCI/AER: Use cached AER Capability offset
    
    Replace pci_find_ext_capability(..., PCI_EXT_CAP_ID_ERR) calls with
    pci_dev->aer_cap.
    
    pci_dev->aer_cap is initialized in pci_init_capabilities(), which happens
    before any of these users of the AER Capability.
    
    Signed-off-by: Frederick Lawler <fred@fredlawl.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index 6890aea4a550..099ef7ac615b 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -40,7 +40,7 @@ static void release_pcie_device(struct device *dev)
 static int pcie_message_numbers(struct pci_dev *dev, int mask,
 				u32 *pme, u32 *aer, u32 *dpc)
 {
-	u32 nvec = 0, pos, reg32;
+	u32 nvec = 0, pos;
 	u16 reg16;
 
 	/*
@@ -56,8 +56,11 @@ static int pcie_message_numbers(struct pci_dev *dev, int mask,
 		nvec = *pme + 1;
 	}
 
+#ifdef CONFIG_PCIEAER
 	if (mask & PCIE_PORT_SERVICE_AER) {
-		pos = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ERR);
+		u32 reg32;
+
+		pos = dev->aer_cap;
 		if (pos) {
 			pci_read_config_dword(dev, pos + PCI_ERR_ROOT_STATUS,
 					      &reg32);
@@ -65,6 +68,7 @@ static int pcie_message_numbers(struct pci_dev *dev, int mask,
 			nvec = max(nvec, *aer + 1);
 		}
 	}
+#endif
 
 	if (mask & PCIE_PORT_SERVICE_DPC) {
 		pos = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_DPC);
@@ -207,8 +211,9 @@ static int get_port_device_capability(struct pci_dev *dev)
 			  PCI_EXP_SLTCTL_CCIE | PCI_EXP_SLTCTL_HPIE);
 	}
 
-	if (pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ERR) &&
-	    pci_aer_available() && (pcie_ports_native || host->native_aer)) {
+#ifdef CONFIG_PCIEAER
+	if (dev->aer_cap && pci_aer_available() &&
+	    (pcie_ports_native || host->native_aer)) {
 		services |= PCIE_PORT_SERVICE_AER;
 
 		/*
@@ -217,6 +222,7 @@ static int get_port_device_capability(struct pci_dev *dev)
 		 */
 		pci_disable_pcie_error_reporting(dev);
 	}
+#endif
 
 	/*
 	 * Root ports are capable of generating PME too.  Root Complex

commit d850882b726f6db01b0792151e72e69b234aa461
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Mar 9 11:21:30 2018 -0600

    PCI/portdrv: Rename and reverse sense of pcie_ports_auto
    
    The platform may restrict the OS's use of PCIe services, e.g., via the ACPI
    _OSC method.  The user may use "pcie_ports=native" to force the port driver
    to use PCIe services even if the platform asked us not to.
    
    The "pcie_ports=native" parameter determines the setting of
    pcie_ports_auto.  Rename this to pcie_ports_native and reverse the
    sense to simplify the code.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index 6ed67cbf6148..6890aea4a550 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -193,17 +193,10 @@ static int pcie_init_service_irqs(struct pci_dev *dev, int *irqs, int mask)
 static int get_port_device_capability(struct pci_dev *dev)
 {
 	struct pci_host_bridge *host = pci_find_host_bridge(dev->bus);
-	bool native;
 	int services = 0;
 
-	/*
-	 * If the user specified "pcie_ports=native", use the PCIe services
-	 * regardless of whether the platform has given us permission.  On
-	 * ACPI systems, this means we ignore _OSC.
-	 */
-	native = !pcie_ports_auto;
-
-	if (dev->is_hotplug_bridge && (native || host->native_hotplug)) {
+	if (dev->is_hotplug_bridge &&
+	    (pcie_ports_native || host->native_hotplug)) {
 		services |= PCIE_PORT_SERVICE_HP;
 
 		/*
@@ -215,7 +208,7 @@ static int get_port_device_capability(struct pci_dev *dev)
 	}
 
 	if (pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ERR) &&
-	    pci_aer_available() && (native || host->native_aer)) {
+	    pci_aer_available() && (pcie_ports_native || host->native_aer)) {
 		services |= PCIE_PORT_SERVICE_AER;
 
 		/*
@@ -231,7 +224,7 @@ static int get_port_device_capability(struct pci_dev *dev)
 	 * those yet.
 	 */
 	if (pci_pcie_type(dev) == PCI_EXP_TYPE_ROOT_PORT &&
-	    (native || host->native_pme)) {
+	    (pcie_ports_native || host->native_pme)) {
 		services |= PCIE_PORT_SERVICE_PME;
 
 		/*

commit 1e447c57ae367c030e7b424f55a91470ae7604ca
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Mar 9 11:21:27 2018 -0600

    PCI/portdrv: Remove "pcie_hp=nomsi" kernel parameter
    
    7570a333d8b0 ("PCI: Add pcie_hp=nomsi to disable MSI/MSI-X for pciehp
    driver") added the "pcie_hp=nomsi" kernel parameter to work around this
    error on shutdown:
    
      irq 16: nobody cared (try booting with the "irqpoll" option)
      Pid: 1081, comm: reboot Not tainted 3.2.0 #1
      ...
      Disabling IRQ #16
    
    This happened on an unspecified system (possibly involving the Integrated
    Device Technology, Inc. Device 807f bridge) where "an un-wanted interrupt
    is generated when PCI driver switches from MSI/MSI-X to INTx while shutting
    down the device."
    
    The implication was that the device was buggy, but it is normal for a
    device to use INTx after MSI/MSI-X have been disabled.  The only problem
    was that the driver was still attached and it wasn't prepared for INTx
    interrupts.  Prarit Bhargava fixed this issue with fda78d7a0ead ("PCI/MSI:
    Stop disabling MSI/MSI-X in pci_device_shutdown()").
    
    There is no automated way to set this parameter, so it's not very useful
    for distributions or end users.  It's really only useful for debugging, and
    we have "pci=nomsi" for that purpose.
    
    Revert 7570a333d8b0 to remove the "pcie_hp=nomsi" parameter.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    CC: MUNEDA Takahiro <muneda.takahiro@jp.fujitsu.com>
    CC: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    CC: Prarit Bhargava <prarit@redhat.com>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index 5c25761cd05e..6ed67cbf6148 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -20,17 +20,6 @@
 #include "../pci.h"
 #include "portdrv.h"
 
-bool pciehp_msi_disabled;
-
-static int __init pciehp_setup(char *str)
-{
-	if (!strncmp(str, "nomsi", 5))
-		pciehp_msi_disabled = true;
-
-	return 1;
-}
-__setup("pcie_hp=", pciehp_setup);
-
 /**
  * release_pcie_device - free PCI Express port service device structure
  * @dev: Port service device to release
@@ -168,16 +157,13 @@ static int pcie_init_service_irqs(struct pci_dev *dev, int *irqs, int mask)
 		irqs[i] = -1;
 
 	/*
-	 * If we support PME or hotplug, but we can't use MSI/MSI-X for
-	 * them, we have to fall back to INTx or other interrupts, e.g., a
-	 * system shared interrupt.
+	 * If we support PME but can't use MSI/MSI-X for it, we have to
+	 * fall back to INTx or other interrupts, e.g., a system shared
+	 * interrupt.
 	 */
 	if ((mask & PCIE_PORT_SERVICE_PME) && pcie_pme_no_msi())
 		goto legacy_irq;
 
-	if ((mask & PCIE_PORT_SERVICE_HP) && pciehp_no_msi())
-		goto legacy_irq;
-
 	/* Try to use MSI-X or MSI if supported */
 	if (pcie_port_enable_irq_vec(dev, irqs, mask) == 0)
 		return 0;

commit 02bfeb484230dfd073148a17253aeb1717ce769c
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Mar 9 11:21:25 2018 -0600

    PCI/portdrv: Simplify PCIe feature permission checking
    
    Some PCIe features (AER, DPC, hotplug, PME) can be managed by either the
    platform firmware or the OS, so the host bridge driver may have to request
    permission from the platform before using them.  On ACPI systems, this is
    done by negotiate_os_control() in acpi_pci_root_add().
    
    The PCIe port driver later uses pcie_port_platform_notify() and
    pcie_port_acpi_setup() to figure out whether it can use these features.
    But all we need is a single bit for each service, so these interfaces are
    needlessly complicated.
    
    Simplify this by adding bits in the struct pci_host_bridge to show when the
    OS has permission to use each feature:
    
      + unsigned int native_aer:1;       /* OS may use PCIe AER */
      + unsigned int native_hotplug:1;   /* OS may use PCIe hotplug */
      + unsigned int native_pme:1;       /* OS may use PCIe PME */
    
    These are set when we create a host bridge, and the host bridge driver can
    clear the bits corresponding to any feature the platform doesn't want us to
    use.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index bf851da97947..5c25761cd05e 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -206,19 +206,20 @@ static int pcie_init_service_irqs(struct pci_dev *dev, int *irqs, int mask)
  */
 static int get_port_device_capability(struct pci_dev *dev)
 {
+	struct pci_host_bridge *host = pci_find_host_bridge(dev->bus);
+	bool native;
 	int services = 0;
-	int cap_mask = 0;
 
-	cap_mask = PCIE_PORT_SERVICE_PME | PCIE_PORT_SERVICE_HP;
-	if (pci_aer_available())
-		cap_mask |= PCIE_PORT_SERVICE_AER | PCIE_PORT_SERVICE_DPC;
-
-	if (pcie_ports_auto)
-		pcie_port_platform_notify(dev, &cap_mask);
+	/*
+	 * If the user specified "pcie_ports=native", use the PCIe services
+	 * regardless of whether the platform has given us permission.  On
+	 * ACPI systems, this means we ignore _OSC.
+	 */
+	native = !pcie_ports_auto;
 
-	/* Hot-Plug Capable */
-	if ((cap_mask & PCIE_PORT_SERVICE_HP) && dev->is_hotplug_bridge) {
+	if (dev->is_hotplug_bridge && (native || host->native_hotplug)) {
 		services |= PCIE_PORT_SERVICE_HP;
+
 		/*
 		 * Disable hot-plug interrupts in case they have been enabled
 		 * by the BIOS and the hot-plug service driver is not loaded.
@@ -226,20 +227,27 @@ static int get_port_device_capability(struct pci_dev *dev)
 		pcie_capability_clear_word(dev, PCI_EXP_SLTCTL,
 			  PCI_EXP_SLTCTL_CCIE | PCI_EXP_SLTCTL_HPIE);
 	}
-	/* AER capable */
-	if ((cap_mask & PCIE_PORT_SERVICE_AER)
-	    && pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ERR)) {
+
+	if (pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ERR) &&
+	    pci_aer_available() && (native || host->native_aer)) {
 		services |= PCIE_PORT_SERVICE_AER;
+
 		/*
 		 * Disable AER on this port in case it's been enabled by the
 		 * BIOS (the AER service driver will enable it when necessary).
 		 */
 		pci_disable_pcie_error_reporting(dev);
 	}
-	/* Root ports are capable of generating PME too */
-	if ((cap_mask & PCIE_PORT_SERVICE_PME)
-	    && pci_pcie_type(dev) == PCI_EXP_TYPE_ROOT_PORT) {
+
+	/*
+	 * Root ports are capable of generating PME too.  Root Complex
+	 * Event Collectors can also generate PMEs, but we don't handle
+	 * those yet.
+	 */
+	if (pci_pcie_type(dev) == PCI_EXP_TYPE_ROOT_PORT &&
+	    (native || host->native_pme)) {
 		services |= PCIE_PORT_SERVICE_PME;
+
 		/*
 		 * Disable PME interrupt on this port in case it's been enabled
 		 * by the BIOS (the PME service driver will enable it when
@@ -247,7 +255,9 @@ static int get_port_device_capability(struct pci_dev *dev)
 		 */
 		pcie_pme_interrupt_enable(dev, false);
 	}
-	if (pci_find_ext_capability(dev, PCI_EXT_CAP_ID_DPC))
+
+	if (pci_find_ext_capability(dev, PCI_EXT_CAP_ID_DPC) &&
+	    pci_aer_available())
 		services |= PCIE_PORT_SERVICE_DPC;
 
 	return services;

commit 168f3ae595d6a6cee8321633f29273a7dd4fc83e
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Mar 9 11:21:24 2018 -0600

    PCI/portdrv: Remove unused PCIE_PORT_SERVICE_VC
    
    No driver registers for PCIE_PORT_SERVICE_VC, so remove it.
    
    This removes the VC "service" files from /sys/bus/pci_express/devices,
    e.g., 0000:07:00.0:pcie108, 0000:08:04.0:pcie208 (all the files that
    contained "8" as the last digit of the "pcieXXX" part).  The port driver
    created these files for PCIe port devices that have a VC Capability.
    
    Since this reduces PCIE_PORT_DEVICE_MAXSERVICES and moves DPC down into the
    spot where VC used to be, the DPC sysfs files will now be named "pcieXX8".
    I don't think there's anything useful userspace can do with those files, so
    I hope nobody cares about these filenames.
    
    There is no VC driver that calls pcie_port_service_register(), so there
    never was a /sys/bus/pci_express/drivers/vc directory.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index 9a41751db332..bf851da97947 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -188,10 +188,8 @@ static int pcie_init_service_irqs(struct pci_dev *dev, int *irqs, int mask)
 	if (ret < 0)
 		return -ENODEV;
 
-	for (i = 0; i < PCIE_PORT_DEVICE_MAXSERVICES; i++) {
-		if (i != PCIE_PORT_SERVICE_VC_SHIFT)
-			irqs[i] = pci_irq_vector(dev, 0);
-	}
+	for (i = 0; i < PCIE_PORT_DEVICE_MAXSERVICES; i++)
+		irqs[i] = pci_irq_vector(dev, 0);
 
 	return 0;
 }
@@ -211,8 +209,7 @@ static int get_port_device_capability(struct pci_dev *dev)
 	int services = 0;
 	int cap_mask = 0;
 
-	cap_mask = PCIE_PORT_SERVICE_PME | PCIE_PORT_SERVICE_HP
-			| PCIE_PORT_SERVICE_VC;
+	cap_mask = PCIE_PORT_SERVICE_PME | PCIE_PORT_SERVICE_HP;
 	if (pci_aer_available())
 		cap_mask |= PCIE_PORT_SERVICE_AER | PCIE_PORT_SERVICE_DPC;
 
@@ -239,9 +236,6 @@ static int get_port_device_capability(struct pci_dev *dev)
 		 */
 		pci_disable_pcie_error_reporting(dev);
 	}
-	/* VC support */
-	if (pci_find_ext_capability(dev, PCI_EXT_CAP_ID_VC))
-		services |= PCIE_PORT_SERVICE_VC;
 	/* Root ports are capable of generating PME too */
 	if ((cap_mask & PCIE_PORT_SERVICE_PME)
 	    && pci_pcie_type(dev) == PCI_EXP_TYPE_ROOT_PORT) {
@@ -331,7 +325,7 @@ int pcie_port_device_register(struct pci_dev *dev)
 	 */
 	status = pcie_init_service_irqs(dev, irqs, capabilities);
 	if (status) {
-		capabilities &= PCIE_PORT_SERVICE_VC | PCIE_PORT_SERVICE_HP;
+		capabilities &= PCIE_PORT_SERVICE_HP;
 		if (!capabilities)
 			goto error_disable;
 	}

commit 79a011194b23302dc43f265ed4237054877768ff
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Mar 9 11:06:56 2018 -0600

    PCI/portdrv: Disable port driver in compat mode
    
    The "pcie_ports=compat" kernel parameter sets pcie_ports_disabled, which is
    intended to disable the PCIe port driver.  But even when it was disabled,
    we registered pcie_portdriver so we could work around a BIOS PME issue (see
    fe31e69740ed ("PCI/PCIe: Clear Root PME Status bits early during system
    resume")).
    
    Registering the driver meant that the pcie_portdrv_probe() path called
    pci_enable_device(), pci_save_state(), pm_runtime_set_autosuspend_delay(),
    pm_runtime_use_autosuspend(), etc., even when the driver was disabled.
    
    We've since moved the BIOS PME workaround from the port driver to the core,
    so stop registering the PCIe port driver in compat mode.
    
    This means "pcie_ports=compat" will now be basically the same as turning
    off CONFIG_PCIEPORTBUS completely.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index 4268b2fc2c7a..9a41751db332 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -211,9 +211,6 @@ static int get_port_device_capability(struct pci_dev *dev)
 	int services = 0;
 	int cap_mask = 0;
 
-	if (pcie_ports_disabled)
-		return 0;
-
 	cap_mask = PCIE_PORT_SERVICE_PME | PCIE_PORT_SERVICE_HP
 			| PCIE_PORT_SERVICE_VC;
 	if (pci_aer_available())

commit df62ab5e0f75608919df7442654b0fab78246b7b
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Mar 9 16:36:33 2018 -0600

    PCI: Tidy comments
    
    Remove pointless comments that tell us the file name, remove blank line
    comments, follow multi-line comment conventions.  No functional change
    intended.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index ef3bad4ad010..07833e5cde36 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -1,6 +1,5 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * File:	portdrv_core.c
  * Purpose:	PCI Express Port Bus Driver's Core Functions
  *
  * Copyright (C) 2004 Intel

commit ef7942603e35e300e6967fa7c17ebc17a0c00f59
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Mar 9 11:42:01 2018 -0600

    PCI/portdrv: Merge pcieport_if.h into portdrv.h
    
    pcieport_if.h contained the interfaces to register port service driver,
    e.g., pcie_port_service_register().  portdrv.h contained internal data
    structures of the port driver.
    
    I don't think it's worth keeping those files separate, since both headers
    and their users are all inside the PCI core.
    
    Merge pcieport_if.h directly in drivers/pci/pcie/portdrv.h and update the
    users to include that instead.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index bab9cb71130f..4268b2fc2c7a 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -17,7 +17,6 @@
 #include <linux/slab.h>
 #include <linux/aer.h>
 
-#include "pcieport_if.h"
 #include "../pci.h"
 #include "portdrv.h"
 

commit c37e627f9565368ed7bd1f3cf59a2d223ddba85a
Author: Frederick Lawler <fred@fredlawl.com>
Date:   Tue Feb 13 21:52:18 2018 -0600

    PCI/portdrv: Move pcieport_if.h to drivers/pci/pcie/
    
    Move pcieport_if.h from include/linux to drivers/pci/pcie/pcieport_if.h
    because the interfaces there are only used by the PCI core.
    
    Replace all uses of #include<linux/pcieport_if.h> with relative paths to
    the new file location, e.g., #include "../pcieport_if.h"
    
    Signed-off-by: Frederick Lawler <fred@fredlawl.com>
    Signed-off-by: Bjorn Helgaas <helgaas@kernel.org>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index ef3bad4ad010..bab9cb71130f 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -15,9 +15,9 @@
 #include <linux/pm_runtime.h>
 #include <linux/string.h>
 #include <linux/slab.h>
-#include <linux/pcieport_if.h>
 #include <linux/aer.h>
 
+#include "pcieport_if.h"
 #include "../pci.h"
 #include "portdrv.h"
 

commit eed85ff4c0da72640dcf7c0737c5a08bca2958e7
Author: Keith Busch <keith.busch@intel.com>
Date:   Wed Jan 24 17:03:18 2018 -0600

    PCI/DPC: Enable DPC only if AER is available
    
    The "Determination of DPC Control" implementation note in PCIe r4.0, sec
    6.1.10, recommends the operating system always link DPC control to the
    control of AER, as the two functionalities are strongly connected.
    
    To avoid conflicts over whether platform firmware or the OS controls DPC,
    enable DPC only if AER is enabled in the OS, and the device's error
    handling does not have firmware-first AER handling.
    
    Signed-off-by: Keith Busch <keith.busch@intel.com>
    Signed-off-by: Bjorn Helgaas <helgaas@kernel.org>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index a59210350c44..ef3bad4ad010 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -216,9 +216,9 @@ static int get_port_device_capability(struct pci_dev *dev)
 		return 0;
 
 	cap_mask = PCIE_PORT_SERVICE_PME | PCIE_PORT_SERVICE_HP
-			| PCIE_PORT_SERVICE_VC | PCIE_PORT_SERVICE_DPC;
+			| PCIE_PORT_SERVICE_VC;
 	if (pci_aer_available())
-		cap_mask |= PCIE_PORT_SERVICE_AER;
+		cap_mask |= PCIE_PORT_SERVICE_AER | PCIE_PORT_SERVICE_DPC;
 
 	if (pcie_ports_auto)
 		pcie_port_platform_notify(dev, &cap_mask);

commit 1b6115fbe3b3db746d7baa11399dd617fc75e1c4
Merge: ad0835a93008 91f3140fdef6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Nov 15 15:01:28 2017 -0800

    Merge tag 'pci-v4.15-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI updates from Bjorn Helgaas:
    
      - detach driver before tearing down procfs/sysfs (Alex Williamson)
    
      - disable PCIe services during shutdown (Sinan Kaya)
    
      - fix ASPM oops on systems with no Root Ports (Ard Biesheuvel)
    
      - fix ASPM LTR_L1.2_THRESHOLD programming (Bjorn Helgaas)
    
      - fix ASPM Common_Mode_Restore_Time computation (Bjorn Helgaas)
    
      - fix portdrv MSI/MSI-X vector allocation (Dongdong Liu, Bjorn
        Helgaas)
    
      - report non-fatal AER errors only to the affected endpoint (Gabriele
        Paoloni)
    
      - distribute bus numbers, MMIO, and I/O space among hotplug bridges to
        allow more devices to be hot-added (Mika Westerberg)
    
      - fix pciehp races during initialization and surprise link down (Mika
        Westerberg)
    
      - handle surprise-removed devices in PME handling (Qiang)
    
      - support resizable BARs for large graphics devices (Christian König)
    
      - expose SR-IOV offset, stride, and VF device ID via sysfs (Filippo
        Sironi)
    
      - create SR-IOV virtfn/physfn sysfs links before attaching driver
        (Stuart Hayes)
    
      - fix SR-IOV "ARI Capable Hierarchy" restore issue (Tony Nguyen)
    
      - enforce Kconfig IOV/REALLOC dependency (Sascha El-Sharkawy)
    
      - avoid slot reset if bridge itself is broken (Jan Glauber)
    
      - clean up pci_reset_function() path (Jan H. Schönherr)
    
      - make pci_map_rom() fail if the option ROM is invalid (Changbin Du)
    
      - convert timers to timer_setup() (Kees Cook)
    
      - move PCI_QUIRKS to PCI bus Kconfig menu (Randy Dunlap)
    
      - constify pci_dev_type and intel_mid_pci_ops (Bhumika Goyal)
    
      - remove unnecessary pci_dev, pci_bus, resource, pcibios_set_master()
        declarations (Bjorn Helgaas)
    
      - fix endpoint framework overflows and BUG()s (Dan Carpenter)
    
      - fix endpoint framework issues (Kishon Vijay Abraham I)
    
      - avoid broken Cavium CN8xxx bus reset behavior (David Daney)
    
      - extend Cavium ACS capability quirks (Vadim Lomovtsev)
    
      - support Synopsys DesignWare RC in ECAM mode (Ard Biesheuvel)
    
      - turn off dra7xx clocks cleanly on shutdown (Keerthy)
    
      - fix Faraday probe error path (Wei Yongjun)
    
      - support HiSilicon STB SoC PCIe host controller (Jianguo Sun)
    
      - fix Hyper-V interrupt affinity issue (Dexuan Cui)
    
      - remove useless ACPI warning for Hyper-V pass-through devices (Vitaly
        Kuznetsov)
    
      - support multiple MSI on iProc (Sandor Bodo-Merle)
    
      - support Layerscape LS1012a and LS1046a PCIe host controllers (Hou
        Zhiqiang)
    
      - fix Layerscape default error response (Minghuan Lian)
    
      - support MSI on Tango host controller (Marc Gonzalez)
    
      - support Tegra186 PCIe host controller (Manikanta Maddireddy)
    
      - use generic accessors on Tegra when possible (Thierry Reding)
    
      - support V3 Semiconductor PCI host controller (Linus Walleij)
    
    * tag 'pci-v4.15-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (85 commits)
      PCI/ASPM: Add L1 Substates definitions
      PCI/ASPM: Reformat ASPM register definitions
      PCI/ASPM: Use correct capability pointer to program LTR_L1.2_THRESHOLD
      PCI/ASPM: Account for downstream device's Port Common_Mode_Restore_Time
      PCI: xgene: Rename xgene_pcie_probe_bridge() to xgene_pcie_probe()
      PCI: xilinx: Rename xilinx_pcie_link_is_up() to xilinx_pcie_link_up()
      PCI: altera: Rename altera_pcie_link_is_up() to altera_pcie_link_up()
      PCI: Fix kernel-doc build warning
      PCI: Fail pci_map_rom() if the option ROM is invalid
      PCI: Move pci_map_rom() error path
      PCI: Move PCI_QUIRKS to the PCI bus menu
      alpha/PCI: Make pdev_save_srm_config() static
      PCI: Remove unused declarations
      PCI: Remove redundant pci_dev, pci_bus, resource declarations
      PCI: Remove redundant pcibios_set_master() declarations
      PCI/PME: Handle invalid data when reading Root Status
      PCI: hv: Use effective affinity mask
      PCI: pciehp: Do not clear Presence Detect Changed during initialization
      PCI: pciehp: Fix race condition handling surprise link down
      PCI: Distribute available resources to hotplug-capable bridges
      ...

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index 313a21df1692..ebc9d45bd731 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * File:	portdrv_core.c
  * Purpose:	PCI Express Port Bus Driver's Core Functions

commit a579ba49a9e27bfc1d5cb69b0ea3781d8df46b5b
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Oct 20 08:57:16 2017 -0500

    PCI/portdrv: Compute MSI/MSI-X IRQ vectors after final allocation
    
    When setting up portdrv MSI/MSI-X interrupts, we previously allocated the
    maximum possible number of vectors, read the Interrupt Message Numbers for
    each service, saved the IRQ for each, freed the vectors, and finally used
    the largest Message Number to reallocate only as many vectors as we need.
    
    The problem is that freeing the vectors invalidates their IRQs, so the
    saved IRQ numbers may now be invalid, which can result in errors like
    this:
    
      pcie_pme: probe of 0000:00:00.0:pcie001 failed with error -22
      pciehp 0000:00:00.0:pcie004: Cannot get irq 20 for the hotplug controller
      aer: probe of 0000:00:00.0:pcie002 failed with error -22
      dpc 0000:00:00.0:pcie010: request IRQ22 failed: -22
    
    Change the setup so we save the Interrupt Message Numbers (not the IRQs)
    before we free the original setup, then use the Message Numbers to compute
    the IRQs (via pci_irq_vector()) *after* we reallocate the vectors.
    
    This should always be safe for MSI-X because the Message Numbers are fixed.
    For MSI, the hardware is allowed to change Message Numbers when we update
    the MSI Multiple Message Enable field when reallocating the vectors, but
    since we allocate enough vectors to accommodate the largest Message Number
    we found, that's unlikely.  See PCIe r3.1, sec 7.8.2, 7.10.10, 7.31.2.
    
    Fixes: 3674cc49da9a ("PCI/portdrv: Use pci_irq_alloc_vectors()")
    Based-on-patch-by: Dongdong Liu <liudongdong3@huawei.com>
    Tested-by: Dongdong Liu <liudongdong3@huawei.com>  # HiSilicon hip08
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index 102f5c5fcfe0..3cd5eb48644a 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -117,6 +117,26 @@ static int pcie_port_enable_irq_vec(struct pci_dev *dev, int *irqs, int mask)
 		return -EIO;
 	}
 
+	/*
+	 * If we allocated more than we need, free them and reallocate fewer.
+	 *
+	 * Reallocating may change the specific vectors we get, so
+	 * pci_irq_vector() must be done *after* the reallocation.
+	 *
+	 * If we're using MSI, hardware is *allowed* to change the Interrupt
+	 * Message Numbers when we free and reallocate the vectors, but we
+	 * assume it won't because we allocate enough vectors for the
+	 * biggest Message Number we found.
+	 */
+	if (nvec != nr_entries) {
+		pci_free_irq_vectors(dev);
+
+		nr_entries = pci_alloc_irq_vectors(dev, nvec, nvec,
+				PCI_IRQ_MSIX | PCI_IRQ_MSI);
+		if (nr_entries < 0)
+			return nr_entries;
+	}
+
 	/* PME and hotplug share an MSI/MSI-X vector */
 	if (mask & (PCIE_PORT_SERVICE_PME | PCIE_PORT_SERVICE_HP)) {
 		irqs[PCIE_PORT_SERVICE_PME_SHIFT] = pci_irq_vector(dev, pme);
@@ -129,16 +149,6 @@ static int pcie_port_enable_irq_vec(struct pci_dev *dev, int *irqs, int mask)
 	if (mask & PCIE_PORT_SERVICE_DPC)
 		irqs[PCIE_PORT_SERVICE_DPC_SHIFT] = pci_irq_vector(dev, dpc);
 
-	/* If we allocated more than we need, free them and allocate fewer */
-	if (nvec != nr_entries) {
-		pci_free_irq_vectors(dev);
-
-		nr_entries = pci_alloc_irq_vectors(dev, nvec, nvec,
-				PCI_IRQ_MSIX | PCI_IRQ_MSI);
-		if (nr_entries < 0)
-			return nr_entries;
-	}
-
 	return 0;
 }
 

commit 3321eafd2a79f15126ebaa82f1b5d7fce89c02cb
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Oct 20 08:48:06 2017 -0500

    PCI/portdrv: Factor out Interrupt Message Number lookup
    
    Factor out Interrupt Message Number lookup from the MSI/MSI-X interrupt
    setup.  One side effect is that we only have to check once to see if we
    have enough vectors for all the services.  No functional change intended.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index accd16082348..102f5c5fcfe0 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -43,6 +43,53 @@ static void release_pcie_device(struct device *dev)
 	kfree(to_pcie_device(dev));
 }
 
+/*
+ * Fill in *pme, *aer, *dpc with the relevant Interrupt Message Numbers if
+ * services are enabled in "mask".  Return the number of MSI/MSI-X vectors
+ * required to accommodate the largest Message Number.
+ */
+static int pcie_message_numbers(struct pci_dev *dev, int mask,
+				u32 *pme, u32 *aer, u32 *dpc)
+{
+	u32 nvec = 0, pos, reg32;
+	u16 reg16;
+
+	/*
+	 * The Interrupt Message Number indicates which vector is used, i.e.,
+	 * the MSI-X table entry or the MSI offset between the base Message
+	 * Data and the generated interrupt message.  See PCIe r3.1, sec
+	 * 7.8.2, 7.10.10, 7.31.2.
+	 */
+
+	if (mask & (PCIE_PORT_SERVICE_PME | PCIE_PORT_SERVICE_HP)) {
+		pcie_capability_read_word(dev, PCI_EXP_FLAGS, &reg16);
+		*pme = (reg16 & PCI_EXP_FLAGS_IRQ) >> 9;
+		nvec = *pme + 1;
+	}
+
+	if (mask & PCIE_PORT_SERVICE_AER) {
+		pos = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ERR);
+		if (pos) {
+			pci_read_config_dword(dev, pos + PCI_ERR_ROOT_STATUS,
+					      &reg32);
+			*aer = (reg32 & PCI_ERR_ROOT_AER_IRQ) >> 27;
+			nvec = max(nvec, *aer + 1);
+		}
+	}
+
+	if (mask & PCIE_PORT_SERVICE_DPC) {
+		pos = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_DPC);
+		if (pos) {
+			pci_read_config_word(dev, pos + PCI_EXP_DPC_CAP,
+					     &reg16);
+			*dpc = reg16 & PCI_EXP_DPC_IRQ;
+			nvec = max(nvec, *dpc + 1);
+		}
+	}
+
+	return nvec;
+}
+
 /**
  * pcie_port_enable_irq_vec - try to set up MSI-X or MSI as interrupt mode
  * for given port
@@ -54,7 +101,8 @@ static void release_pcie_device(struct device *dev)
  */
 static int pcie_port_enable_irq_vec(struct pci_dev *dev, int *irqs, int mask)
 {
-	int nr_entries, entry, nvec = 0;
+	int nr_entries, nvec;
+	u32 pme = 0, aer = 0, dpc = 0;
 
 	/* Allocate the maximum possible number of MSI/MSI-X vectors */
 	nr_entries = pci_alloc_irq_vectors(dev, 1, PCIE_PORT_MAX_MSI_ENTRIES,
@@ -62,54 +110,24 @@ static int pcie_port_enable_irq_vec(struct pci_dev *dev, int *irqs, int mask)
 	if (nr_entries < 0)
 		return nr_entries;
 
-	/*
-	 * The Interrupt Message Number indicates which vector is used, i.e.,
-	 * the MSI-X table entry or the MSI offset between the base Message
-	 * Data and the generated interrupt message.  See PCIe r3.1, sec
-	 * 7.8.2, 7.10.10, 7.31.2.
-	 */
-	if (mask & (PCIE_PORT_SERVICE_PME | PCIE_PORT_SERVICE_HP)) {
-		u16 reg16;
-
-		pcie_capability_read_word(dev, PCI_EXP_FLAGS, &reg16);
-		entry = (reg16 & PCI_EXP_FLAGS_IRQ) >> 9;
-		if (entry >= nr_entries)
-			goto out_free_irqs;
-
-		/* PME and hotplug share an MSI/MSI-X vector */
-		irqs[PCIE_PORT_SERVICE_PME_SHIFT] = pci_irq_vector(dev, entry);
-		irqs[PCIE_PORT_SERVICE_HP_SHIFT] = pci_irq_vector(dev, entry);
-
-		nvec = max(nvec, entry + 1);
+	/* See how many and which Interrupt Message Numbers we actually use */
+	nvec = pcie_message_numbers(dev, mask, &pme, &aer, &dpc);
+	if (nvec > nr_entries) {
+		pci_free_irq_vectors(dev);
+		return -EIO;
 	}
 
-	if (mask & PCIE_PORT_SERVICE_AER) {
-		u32 reg32, pos;
-
-		pos = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ERR);
-		pci_read_config_dword(dev, pos + PCI_ERR_ROOT_STATUS, &reg32);
-		entry = (reg32 & PCI_ERR_ROOT_AER_IRQ) >> 27;
-		if (entry >= nr_entries)
-			goto out_free_irqs;
-
-		irqs[PCIE_PORT_SERVICE_AER_SHIFT] = pci_irq_vector(dev, entry);
-
-		nvec = max(nvec, entry + 1);
+	/* PME and hotplug share an MSI/MSI-X vector */
+	if (mask & (PCIE_PORT_SERVICE_PME | PCIE_PORT_SERVICE_HP)) {
+		irqs[PCIE_PORT_SERVICE_PME_SHIFT] = pci_irq_vector(dev, pme);
+		irqs[PCIE_PORT_SERVICE_HP_SHIFT] = pci_irq_vector(dev, pme);
 	}
 
-	if (mask & PCIE_PORT_SERVICE_DPC) {
-		u16 reg16, pos;
-
-		pos = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_DPC);
-		pci_read_config_word(dev, pos + PCI_EXP_DPC_CAP, &reg16);
-		entry = reg16 & PCI_EXP_DPC_IRQ;
-		if (entry >= nr_entries)
-			goto out_free_irqs;
-
-		irqs[PCIE_PORT_SERVICE_DPC_SHIFT] = pci_irq_vector(dev, entry);
+	if (mask & PCIE_PORT_SERVICE_AER)
+		irqs[PCIE_PORT_SERVICE_AER_SHIFT] = pci_irq_vector(dev, aer);
 
-		nvec = max(nvec, entry + 1);
-	}
+	if (mask & PCIE_PORT_SERVICE_DPC)
+		irqs[PCIE_PORT_SERVICE_DPC_SHIFT] = pci_irq_vector(dev, dpc);
 
 	/* If we allocated more than we need, free them and allocate fewer */
 	if (nvec != nr_entries) {
@@ -122,10 +140,6 @@ static int pcie_port_enable_irq_vec(struct pci_dev *dev, int *irqs, int mask)
 	}
 
 	return 0;
-
-out_free_irqs:
-	pci_free_irq_vectors(dev);
-	return -EIO;
 }
 
 /**

commit b8acfd7c0f88c49dc0089cd40e02040187160f6a
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Oct 19 16:09:26 2017 -0500

    PCI/portdrv: Consolidate comments
    
    Consolidate some repetitive comments so we can see the code better.  No
    functional change.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index 72fcbe5567dd..accd16082348 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -56,40 +56,27 @@ static int pcie_port_enable_irq_vec(struct pci_dev *dev, int *irqs, int mask)
 {
 	int nr_entries, entry, nvec = 0;
 
-	/*
-	 * Allocate as many entries as the port wants, so that we can check
-	 * which of them will be useful.  Moreover, if nr_entries is correctly
-	 * equal to the number of entries this port actually uses, we'll happily
-	 * go through without any tricks.
-	 */
+	/* Allocate the maximum possible number of MSI/MSI-X vectors */
 	nr_entries = pci_alloc_irq_vectors(dev, 1, PCIE_PORT_MAX_MSI_ENTRIES,
 			PCI_IRQ_MSIX | PCI_IRQ_MSI);
 	if (nr_entries < 0)
 		return nr_entries;
 
+	/*
+	 * The Interrupt Message Number indicates which vector is used, i.e.,
+	 * the MSI-X table entry or the MSI offset between the base Message
+	 * Data and the generated interrupt message.  See PCIe r3.1, sec
+	 * 7.8.2, 7.10.10, 7.31.2.
+	 */
 	if (mask & (PCIE_PORT_SERVICE_PME | PCIE_PORT_SERVICE_HP)) {
 		u16 reg16;
 
-		/*
-		 * Per PCIe r3.1, sec 6.1.6, "PME and Hot-Plug Event
-		 * interrupts (when both are implemented) always share the
-		 * same MSI or MSI-X vector, as indicated by the Interrupt
-		 * Message Number field in the PCI Express Capabilities
-		 * register".
-		 *
-		 * Per sec 7.8.2, "For MSI, the [Interrupt Message Number]
-		 * indicates the offset between the base Message Data and
-		 * the interrupt message that is generated."
-		 *
-		 * "For MSI-X, the [Interrupt Message Number] indicates
-		 * which MSI-X Table entry is used to generate the
-		 * interrupt message."
-		 */
 		pcie_capability_read_word(dev, PCI_EXP_FLAGS, &reg16);
 		entry = (reg16 & PCI_EXP_FLAGS_IRQ) >> 9;
 		if (entry >= nr_entries)
 			goto out_free_irqs;
 
+		/* PME and hotplug share an MSI/MSI-X vector */
 		irqs[PCIE_PORT_SERVICE_PME_SHIFT] = pci_irq_vector(dev, entry);
 		irqs[PCIE_PORT_SERVICE_HP_SHIFT] = pci_irq_vector(dev, entry);
 
@@ -99,19 +86,6 @@ static int pcie_port_enable_irq_vec(struct pci_dev *dev, int *irqs, int mask)
 	if (mask & PCIE_PORT_SERVICE_AER) {
 		u32 reg32, pos;
 
-		/*
-		 * Per PCIe r3.1, sec 7.10.10, the Advanced Error Interrupt
-		 * Message Number in the Root Error Status register
-		 * indicates which MSI/MSI-X vector is used for AER.
-		 *
-		 * "For MSI, the [Advanced Error Interrupt Message Number]
-		 * indicates the offset between the base Message Data and
-		 * the interrupt message that is generated."
-		 *
-		 * "For MSI-X, the [Advanced Error Interrupt Message
-		 * Number] indicates which MSI-X Table entry is used to
-		 * generate the interrupt message."
-		 */
 		pos = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ERR);
 		pci_read_config_dword(dev, pos + PCI_ERR_ROOT_STATUS, &reg32);
 		entry = (reg32 & PCI_ERR_ROOT_AER_IRQ) >> 27;
@@ -126,19 +100,6 @@ static int pcie_port_enable_irq_vec(struct pci_dev *dev, int *irqs, int mask)
 	if (mask & PCIE_PORT_SERVICE_DPC) {
 		u16 reg16, pos;
 
-		/*
-		 * Per PCIe r4.0 (v0.9), sec 7.9.15.2, the DPC Interrupt
-		 * Message Number in the DPC Capability register indicates
-		 * which MSI/MSI-X vector is used for DPC.
-		 *
-		 * "For MSI, the [DPC Interrupt Message Number] indicates
-		 * the offset between the base Message Data and the
-		 * interrupt message that is generated."
-		 *
-		 * "For MSI-X, the [DPC Interrupt Message Number] indicates
-		 * which MSI-X Table entry is used to generate the
-		 * interrupt message."
-		 */
 		pos = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_DPC);
 		pci_read_config_word(dev, pos + PCI_EXP_DPC_CAP, &reg16);
 		entry = reg16 & PCI_EXP_DPC_IRQ;
@@ -150,16 +111,10 @@ static int pcie_port_enable_irq_vec(struct pci_dev *dev, int *irqs, int mask)
 		nvec = max(nvec, entry + 1);
 	}
 
-	/*
-	 * If nvec is equal to the allocated number of entries, we can just use
-	 * what we have.  Otherwise, the port has some extra entries not for the
-	 * services we know and we need to work around that.
-	 */
+	/* If we allocated more than we need, free them and allocate fewer */
 	if (nvec != nr_entries) {
-		/* Drop the temporary MSI-X setup */
 		pci_free_irq_vectors(dev);
 
-		/* Now allocate the MSI-X vectors for real */
 		nr_entries = pci_alloc_irq_vectors(dev, nvec, nvec,
 				PCI_IRQ_MSIX | PCI_IRQ_MSI);
 		if (nr_entries < 0)

commit 7c950b9e53732f574e3a46d37c62f1f33d0b218c
Author: Dongdong Liu <liudongdong3@huawei.com>
Date:   Wed Oct 11 18:52:58 2017 +0800

    PCI/portdrv: Add #defines for AER and DPC Interrupt Message Number masks
    
    In the AER case, the mask isn't strictly necessary because there are no
    higher-order bits above the Interrupt Message Number, but using a #define
    will make it possible to grep for it.
    
    Suggested-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Dongdong Liu <liudongdong3@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index 313a21df1692..72fcbe5567dd 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -114,7 +114,7 @@ static int pcie_port_enable_irq_vec(struct pci_dev *dev, int *irqs, int mask)
 		 */
 		pos = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ERR);
 		pci_read_config_dword(dev, pos + PCI_ERR_ROOT_STATUS, &reg32);
-		entry = reg32 >> 27;
+		entry = (reg32 & PCI_ERR_ROOT_AER_IRQ) >> 27;
 		if (entry >= nr_entries)
 			goto out_free_irqs;
 
@@ -141,7 +141,7 @@ static int pcie_port_enable_irq_vec(struct pci_dev *dev, int *irqs, int mask)
 		 */
 		pos = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_DPC);
 		pci_read_config_word(dev, pos + PCI_EXP_DPC_CAP, &reg16);
-		entry = reg16 & 0x1f;
+		entry = reg16 & PCI_EXP_DPC_IRQ;
 		if (entry >= nr_entries)
 			goto out_free_irqs;
 

commit ae6dc7deac2a8639595437af3df5fade878a1601
Author: Gabriele Paoloni <gabriele.paoloni@huawei.com>
Date:   Tue May 23 15:23:59 2017 +0100

    PCI/portdrv: Allocate MSI/MSI-X vector for Downstream Port Containment
    
    Currently pcie_port_enable_irq_vec() only allocates MSI/MSI-X vectors for
    PME, hotplug, and AER.
    
    The Downstream Port Containment feature also supports MSI/MSI-X interrupts,
    so allocate a vector for it, too.
    
    Signed-off-by: Liudongdong <liudongdong3@huawei.com>
    Signed-off-by: Gabriele Paoloni <gabriele.paoloni@huawei.com>
    [bhelgaas: changelog, comment]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index e00b5da07fef..313a21df1692 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -123,6 +123,33 @@ static int pcie_port_enable_irq_vec(struct pci_dev *dev, int *irqs, int mask)
 		nvec = max(nvec, entry + 1);
 	}
 
+	if (mask & PCIE_PORT_SERVICE_DPC) {
+		u16 reg16, pos;
+
+		/*
+		 * Per PCIe r4.0 (v0.9), sec 7.9.15.2, the DPC Interrupt
+		 * Message Number in the DPC Capability register indicates
+		 * which MSI/MSI-X vector is used for DPC.
+		 *
+		 * "For MSI, the [DPC Interrupt Message Number] indicates
+		 * the offset between the base Message Data and the
+		 * interrupt message that is generated."
+		 *
+		 * "For MSI-X, the [DPC Interrupt Message Number] indicates
+		 * which MSI-X Table entry is used to generate the
+		 * interrupt message."
+		 */
+		pos = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_DPC);
+		pci_read_config_word(dev, pos + PCI_EXP_DPC_CAP, &reg16);
+		entry = reg16 & 0x1f;
+		if (entry >= nr_entries)
+			goto out_free_irqs;
+
+		irqs[PCIE_PORT_SERVICE_DPC_SHIFT] = pci_irq_vector(dev, entry);
+
+		nvec = max(nvec, entry + 1);
+	}
+
 	/*
 	 * If nvec is equal to the allocated number of entries, we can just use
 	 * what we have.  Otherwise, the port has some extra entries not for the

commit a1d5f18cafe6b81696e60ca4901709d2f807362c
Author: Gabriele Paoloni <gabriele.paoloni@huawei.com>
Date:   Tue May 23 15:23:58 2017 +0100

    PCI/portdrv: Support multiple interrupts for MSI as well as MSI-X
    
    Root Ports can generate several different interrupts using either MSI or
    MSI-X, but we only support that for MSI-X.  Ports that support MSI but not
    MSI-X are currently limited to sharing a single interrupt.
    
    Rename pcie_port_enable_msix() to pcie_port_enable_irq_vec() and extend it
    to support multiple interrupts using either MSI-X (preferred) or MSI.
    
    Signed-off-by: Gabriele Paoloni <gabriele.paoloni@huawei.com>
    [bhelgaas: changelog, reword comments, simplify PME/hotplug no-MSI logic]
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index cea504f6f478..e00b5da07fef 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -44,14 +44,15 @@ static void release_pcie_device(struct device *dev)
 }
 
 /**
- * pcie_port_enable_msix - try to set up MSI-X as interrupt mode for given port
+ * pcie_port_enable_irq_vec - try to set up MSI-X or MSI as interrupt mode
+ * for given port
  * @dev: PCI Express port to handle
  * @irqs: Array of interrupt vectors to populate
  * @mask: Bitmask of port capabilities returned by get_port_device_capability()
  *
  * Return value: 0 on success, error code on failure
  */
-static int pcie_port_enable_msix(struct pci_dev *dev, int *irqs, int mask)
+static int pcie_port_enable_irq_vec(struct pci_dev *dev, int *irqs, int mask)
 {
 	int nr_entries, entry, nvec = 0;
 
@@ -61,8 +62,8 @@ static int pcie_port_enable_msix(struct pci_dev *dev, int *irqs, int mask)
 	 * equal to the number of entries this port actually uses, we'll happily
 	 * go through without any tricks.
 	 */
-	nr_entries = pci_alloc_irq_vectors(dev, 1, PCIE_PORT_MAX_MSIX_ENTRIES,
-			PCI_IRQ_MSIX);
+	nr_entries = pci_alloc_irq_vectors(dev, 1, PCIE_PORT_MAX_MSI_ENTRIES,
+			PCI_IRQ_MSIX | PCI_IRQ_MSI);
 	if (nr_entries < 0)
 		return nr_entries;
 
@@ -70,14 +71,19 @@ static int pcie_port_enable_msix(struct pci_dev *dev, int *irqs, int mask)
 		u16 reg16;
 
 		/*
-		 * The code below follows the PCI Express Base Specification 2.0
-		 * stating in Section 6.1.6 that "PME and Hot-Plug Event
-		 * interrupts (when both are implemented) always share the same
-		 * MSI or MSI-X vector, as indicated by the Interrupt Message
-		 * Number field in the PCI Express Capabilities register", where
-		 * according to Section 7.8.2 of the specification "For MSI-X,
-		 * the value in this field indicates which MSI-X Table entry is
-		 * used to generate the interrupt message."
+		 * Per PCIe r3.1, sec 6.1.6, "PME and Hot-Plug Event
+		 * interrupts (when both are implemented) always share the
+		 * same MSI or MSI-X vector, as indicated by the Interrupt
+		 * Message Number field in the PCI Express Capabilities
+		 * register".
+		 *
+		 * Per sec 7.8.2, "For MSI, the [Interrupt Message Number]
+		 * indicates the offset between the base Message Data and
+		 * the interrupt message that is generated."
+		 *
+		 * "For MSI-X, the [Interrupt Message Number] indicates
+		 * which MSI-X Table entry is used to generate the
+		 * interrupt message."
 		 */
 		pcie_capability_read_word(dev, PCI_EXP_FLAGS, &reg16);
 		entry = (reg16 & PCI_EXP_FLAGS_IRQ) >> 9;
@@ -94,13 +100,17 @@ static int pcie_port_enable_msix(struct pci_dev *dev, int *irqs, int mask)
 		u32 reg32, pos;
 
 		/*
-		 * The code below follows Section 7.10.10 of the PCI Express
-		 * Base Specification 2.0 stating that bits 31-27 of the Root
-		 * Error Status Register contain a value indicating which of the
-		 * MSI/MSI-X vectors assigned to the port is going to be used
-		 * for AER, where "For MSI-X, the value in this register
-		 * indicates which MSI-X Table entry is used to generate the
-		 * interrupt message."
+		 * Per PCIe r3.1, sec 7.10.10, the Advanced Error Interrupt
+		 * Message Number in the Root Error Status register
+		 * indicates which MSI/MSI-X vector is used for AER.
+		 *
+		 * "For MSI, the [Advanced Error Interrupt Message Number]
+		 * indicates the offset between the base Message Data and
+		 * the interrupt message that is generated."
+		 *
+		 * "For MSI-X, the [Advanced Error Interrupt Message
+		 * Number] indicates which MSI-X Table entry is used to
+		 * generate the interrupt message."
 		 */
 		pos = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ERR);
 		pci_read_config_dword(dev, pos + PCI_ERR_ROOT_STATUS, &reg32);
@@ -124,7 +134,7 @@ static int pcie_port_enable_msix(struct pci_dev *dev, int *irqs, int mask)
 
 		/* Now allocate the MSI-X vectors for real */
 		nr_entries = pci_alloc_irq_vectors(dev, nvec, nvec,
-				PCI_IRQ_MSIX);
+				PCI_IRQ_MSIX | PCI_IRQ_MSI);
 		if (nr_entries < 0)
 			return nr_entries;
 	}
@@ -146,26 +156,29 @@ static int pcie_port_enable_msix(struct pci_dev *dev, int *irqs, int mask)
  */
 static int pcie_init_service_irqs(struct pci_dev *dev, int *irqs, int mask)
 {
-	unsigned flags = PCI_IRQ_LEGACY | PCI_IRQ_MSI;
 	int ret, i;
 
 	for (i = 0; i < PCIE_PORT_DEVICE_MAXSERVICES; i++)
 		irqs[i] = -1;
 
 	/*
-	 * If MSI cannot be used for PCIe PME or hotplug, we have to use
-	 * INTx or other interrupts, e.g. system shared interrupt.
+	 * If we support PME or hotplug, but we can't use MSI/MSI-X for
+	 * them, we have to fall back to INTx or other interrupts, e.g., a
+	 * system shared interrupt.
 	 */
-	if (((mask & PCIE_PORT_SERVICE_PME) && pcie_pme_no_msi()) ||
-	    ((mask & PCIE_PORT_SERVICE_HP) && pciehp_no_msi())) {
-		flags &= ~PCI_IRQ_MSI;
-	} else {
-		/* Try to use MSI-X if supported */
-		if (!pcie_port_enable_msix(dev, irqs, mask))
-			return 0;
-	}
+	if ((mask & PCIE_PORT_SERVICE_PME) && pcie_pme_no_msi())
+		goto legacy_irq;
+
+	if ((mask & PCIE_PORT_SERVICE_HP) && pciehp_no_msi())
+		goto legacy_irq;
+
+	/* Try to use MSI-X or MSI if supported */
+	if (pcie_port_enable_irq_vec(dev, irqs, mask) == 0)
+		return 0;
 
-	ret = pci_alloc_irq_vectors(dev, 1, 1, flags);
+legacy_irq:
+	/* fall back to legacy IRQ */
+	ret = pci_alloc_irq_vectors(dev, 1, 1, PCI_IRQ_LEGACY);
 	if (ret < 0)
 		return -ENODEV;
 

commit 3674cc49da9a8fc55bf1dec2ab03a66c77f2dcdf
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Feb 1 14:41:43 2017 +0100

    PCI/portdrv: Use pci_irq_alloc_vectors()
    
    Use pci_irq_alloc_vectors() and greatly simplify the code by managing the
    vector number for the subservices directly.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index 9698289f105c..cea504f6f478 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -43,53 +43,17 @@ static void release_pcie_device(struct device *dev)
 	kfree(to_pcie_device(dev));
 }
 
-/**
- * pcie_port_msix_add_entry - add entry to given array of MSI-X entries
- * @entries: Array of MSI-X entries
- * @new_entry: Index of the entry to add to the array
- * @nr_entries: Number of entries already in the array
- *
- * Return value: Position of the added entry in the array
- */
-static int pcie_port_msix_add_entry(
-	struct msix_entry *entries, int new_entry, int nr_entries)
-{
-	int j;
-
-	for (j = 0; j < nr_entries; j++)
-		if (entries[j].entry == new_entry)
-			return j;
-
-	entries[j].entry = new_entry;
-	return j;
-}
-
 /**
  * pcie_port_enable_msix - try to set up MSI-X as interrupt mode for given port
  * @dev: PCI Express port to handle
- * @vectors: Array of interrupt vectors to populate
+ * @irqs: Array of interrupt vectors to populate
  * @mask: Bitmask of port capabilities returned by get_port_device_capability()
  *
  * Return value: 0 on success, error code on failure
  */
-static int pcie_port_enable_msix(struct pci_dev *dev, int *vectors, int mask)
+static int pcie_port_enable_msix(struct pci_dev *dev, int *irqs, int mask)
 {
-	struct msix_entry *msix_entries;
-	int idx[PCIE_PORT_DEVICE_MAXSERVICES];
-	int nr_entries, status, pos, i, nvec;
-	u16 reg16;
-	u32 reg32;
-
-	nr_entries = pci_msix_vec_count(dev);
-	if (nr_entries < 0)
-		return nr_entries;
-	BUG_ON(!nr_entries);
-	if (nr_entries > PCIE_PORT_MAX_MSIX_ENTRIES)
-		nr_entries = PCIE_PORT_MAX_MSIX_ENTRIES;
-
-	msix_entries = kzalloc(sizeof(*msix_entries) * nr_entries, GFP_KERNEL);
-	if (!msix_entries)
-		return -ENOMEM;
+	int nr_entries, entry, nvec = 0;
 
 	/*
 	 * Allocate as many entries as the port wants, so that we can check
@@ -97,20 +61,13 @@ static int pcie_port_enable_msix(struct pci_dev *dev, int *vectors, int mask)
 	 * equal to the number of entries this port actually uses, we'll happily
 	 * go through without any tricks.
 	 */
-	for (i = 0; i < nr_entries; i++)
-		msix_entries[i].entry = i;
-
-	status = pci_enable_msix_exact(dev, msix_entries, nr_entries);
-	if (status)
-		goto Exit;
-
-	for (i = 0; i < PCIE_PORT_DEVICE_MAXSERVICES; i++)
-		idx[i] = -1;
-	status = -EIO;
-	nvec = 0;
+	nr_entries = pci_alloc_irq_vectors(dev, 1, PCIE_PORT_MAX_MSIX_ENTRIES,
+			PCI_IRQ_MSIX);
+	if (nr_entries < 0)
+		return nr_entries;
 
 	if (mask & (PCIE_PORT_SERVICE_PME | PCIE_PORT_SERVICE_HP)) {
-		int entry;
+		u16 reg16;
 
 		/*
 		 * The code below follows the PCI Express Base Specification 2.0
@@ -125,18 +82,16 @@ static int pcie_port_enable_msix(struct pci_dev *dev, int *vectors, int mask)
 		pcie_capability_read_word(dev, PCI_EXP_FLAGS, &reg16);
 		entry = (reg16 & PCI_EXP_FLAGS_IRQ) >> 9;
 		if (entry >= nr_entries)
-			goto Error;
+			goto out_free_irqs;
 
-		i = pcie_port_msix_add_entry(msix_entries, entry, nvec);
-		if (i == nvec)
-			nvec++;
+		irqs[PCIE_PORT_SERVICE_PME_SHIFT] = pci_irq_vector(dev, entry);
+		irqs[PCIE_PORT_SERVICE_HP_SHIFT] = pci_irq_vector(dev, entry);
 
-		idx[PCIE_PORT_SERVICE_PME_SHIFT] = i;
-		idx[PCIE_PORT_SERVICE_HP_SHIFT] = i;
+		nvec = max(nvec, entry + 1);
 	}
 
 	if (mask & PCIE_PORT_SERVICE_AER) {
-		int entry;
+		u32 reg32, pos;
 
 		/*
 		 * The code below follows Section 7.10.10 of the PCI Express
@@ -151,13 +106,11 @@ static int pcie_port_enable_msix(struct pci_dev *dev, int *vectors, int mask)
 		pci_read_config_dword(dev, pos + PCI_ERR_ROOT_STATUS, &reg32);
 		entry = reg32 >> 27;
 		if (entry >= nr_entries)
-			goto Error;
+			goto out_free_irqs;
 
-		i = pcie_port_msix_add_entry(msix_entries, entry, nvec);
-		if (i == nvec)
-			nvec++;
+		irqs[PCIE_PORT_SERVICE_AER_SHIFT] = pci_irq_vector(dev, entry);
 
-		idx[PCIE_PORT_SERVICE_AER_SHIFT] = i;
+		nvec = max(nvec, entry + 1);
 	}
 
 	/*
@@ -165,41 +118,39 @@ static int pcie_port_enable_msix(struct pci_dev *dev, int *vectors, int mask)
 	 * what we have.  Otherwise, the port has some extra entries not for the
 	 * services we know and we need to work around that.
 	 */
-	if (nvec == nr_entries) {
-		status = 0;
-	} else {
+	if (nvec != nr_entries) {
 		/* Drop the temporary MSI-X setup */
-		pci_disable_msix(dev);
+		pci_free_irq_vectors(dev);
 
 		/* Now allocate the MSI-X vectors for real */
-		status = pci_enable_msix_exact(dev, msix_entries, nvec);
-		if (status)
-			goto Exit;
+		nr_entries = pci_alloc_irq_vectors(dev, nvec, nvec,
+				PCI_IRQ_MSIX);
+		if (nr_entries < 0)
+			return nr_entries;
 	}
 
-	for (i = 0; i < PCIE_PORT_DEVICE_MAXSERVICES; i++)
-		vectors[i] = idx[i] >= 0 ? msix_entries[idx[i]].vector : -1;
-
- Exit:
-	kfree(msix_entries);
-	return status;
+	return 0;
 
- Error:
-	pci_disable_msix(dev);
-	goto Exit;
+out_free_irqs:
+	pci_free_irq_vectors(dev);
+	return -EIO;
 }
 
 /**
- * init_service_irqs - initialize irqs for PCI Express port services
+ * pcie_init_service_irqs - initialize irqs for PCI Express port services
  * @dev: PCI Express port to handle
  * @irqs: Array of irqs to populate
  * @mask: Bitmask of port capabilities returned by get_port_device_capability()
  *
  * Return value: Interrupt mode associated with the port
  */
-static int init_service_irqs(struct pci_dev *dev, int *irqs, int mask)
+static int pcie_init_service_irqs(struct pci_dev *dev, int *irqs, int mask)
 {
-	int i, irq = -1;
+	unsigned flags = PCI_IRQ_LEGACY | PCI_IRQ_MSI;
+	int ret, i;
+
+	for (i = 0; i < PCIE_PORT_DEVICE_MAXSERVICES; i++)
+		irqs[i] = -1;
 
 	/*
 	 * If MSI cannot be used for PCIe PME or hotplug, we have to use
@@ -207,41 +158,25 @@ static int init_service_irqs(struct pci_dev *dev, int *irqs, int mask)
 	 */
 	if (((mask & PCIE_PORT_SERVICE_PME) && pcie_pme_no_msi()) ||
 	    ((mask & PCIE_PORT_SERVICE_HP) && pciehp_no_msi())) {
-		if (dev->irq)
-			irq = dev->irq;
-		goto no_msi;
+		flags &= ~PCI_IRQ_MSI;
+	} else {
+		/* Try to use MSI-X if supported */
+		if (!pcie_port_enable_msix(dev, irqs, mask))
+			return 0;
 	}
 
-	/* Try to use MSI-X if supported */
-	if (!pcie_port_enable_msix(dev, irqs, mask))
-		return 0;
-
-	/*
-	 * We're not going to use MSI-X, so try MSI and fall back to INTx.
-	 * If neither MSI/MSI-X nor INTx available, try other interrupt.  On
-	 * some platforms, root port doesn't support MSI/MSI-X/INTx in RC mode.
-	 */
-	if (!pci_enable_msi(dev) || dev->irq)
-		irq = dev->irq;
+	ret = pci_alloc_irq_vectors(dev, 1, 1, flags);
+	if (ret < 0)
+		return -ENODEV;
 
- no_msi:
-	for (i = 0; i < PCIE_PORT_DEVICE_MAXSERVICES; i++)
-		irqs[i] = irq;
-	irqs[PCIE_PORT_SERVICE_VC_SHIFT] = -1;
+	for (i = 0; i < PCIE_PORT_DEVICE_MAXSERVICES; i++) {
+		if (i != PCIE_PORT_SERVICE_VC_SHIFT)
+			irqs[i] = pci_irq_vector(dev, 0);
+	}
 
-	if (irq < 0)
-		return -ENODEV;
 	return 0;
 }
 
-static void cleanup_service_irqs(struct pci_dev *dev)
-{
-	if (dev->msix_enabled)
-		pci_disable_msix(dev);
-	else if (dev->msi_enabled)
-		pci_disable_msi(dev);
-}
-
 /**
  * get_port_device_capability - discover capabilities of a PCI Express port
  * @dev: PCI Express port to examine
@@ -378,7 +313,7 @@ int pcie_port_device_register(struct pci_dev *dev)
 	 * that can be used in the absence of irqs.  Allow them to determine
 	 * if that is to be used.
 	 */
-	status = init_service_irqs(dev, irqs, capabilities);
+	status = pcie_init_service_irqs(dev, irqs, capabilities);
 	if (status) {
 		capabilities &= PCIE_PORT_SERVICE_VC | PCIE_PORT_SERVICE_HP;
 		if (!capabilities)
@@ -401,7 +336,7 @@ int pcie_port_device_register(struct pci_dev *dev)
 	return 0;
 
 error_cleanup_irqs:
-	cleanup_service_irqs(dev);
+	pci_free_irq_vectors(dev);
 error_disable:
 	pci_disable_device(dev);
 	return status;
@@ -469,7 +404,7 @@ static int remove_iter(struct device *dev, void *data)
 void pcie_port_device_remove(struct pci_dev *dev)
 {
 	device_for_each_child(&dev->dev, NULL, remove_iter);
-	cleanup_service_irqs(dev);
+	pci_free_irq_vectors(dev);
 	pci_disable_device(dev);
 }
 

commit 98892fae40ed03ddf6f3bff847993e9d9dd8946a
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Nov 15 07:54:19 2016 -0600

    PCI: Remove service driver load/unload messages
    
    Remove the "service driver %s loaded" and unloaded messages.  All service
    drivers already log something in their probe functions, where they can log
    more useful details.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index e9270b4026f3..9698289f105c 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -499,7 +499,6 @@ static int pcie_port_probe_service(struct device *dev)
 	if (status)
 		return status;
 
-	dev_printk(KERN_DEBUG, dev, "service driver %s loaded\n", driver->name);
 	get_device(dev);
 	return 0;
 }
@@ -524,8 +523,6 @@ static int pcie_port_remove_service(struct device *dev)
 	pciedev = to_pcie_device(dev);
 	driver = to_service_driver(dev->driver);
 	if (driver && driver->remove) {
-		dev_printk(KERN_DEBUG, dev, "unloading service driver %s\n",
-			driver->name);
 		driver->remove(pciedev);
 		put_device(dev);
 	}

commit 006d44e49a259b39947366728d65a873a19aadc0
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Thu Jun 2 11:17:15 2016 +0300

    PCI: Add runtime PM support for PCIe ports
    
    Add back runtime PM support for PCIe ports that was removed by
    fe9a743a2601 ("PCI/PM: Drop unused runtime PM support code for PCIe
    ports").
    
    We cannot enable it automatically for all ports since there have been
    problems previously [1].  In summary suspended PCIe ports were not able
    to deal with ACPI-based hotplug reliably.  One reason why this might happen
    is the fact that when a PCIe port is powered down, config space access to
    the devices behind the port is not possible.  If the BIOS hotplug SMI
    handler assumes the port is always in D0 it will not be able to find the
    hotplugged devices.  To be on the safe side only enable runtime PM if the
    port does not claim to support hotplug.
    
    For PCIe ports not using hotplug, we enable and allow runtime PM
    automatically.  Since 'bridge_d3' can be changed any time we check this in
    driver ->runtime_idle() and ->runtime_suspend() and only allow runtime
    suspend if the flag is still set.  Use autosuspend with default of 100ms
    idle time to prevent the port from repeatedly suspending and resuming on
    continuous configuration space access of devices behind the port.
    
    The actual power transition to D3 and back is handled in the PCI core.
    
    Idea to automatically unblock (allow) runtime PM for PCIe ports came from
    Dave Airlie.
    
    [1] https://bugzilla.kernel.org/show_bug.cgi?id=53811
    
    This includes a fix for lockdep issue reported by Valdis Kletnieks.
    
    Tested-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index 32d4d0a3d20e..e9270b4026f3 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -11,6 +11,7 @@
 #include <linux/kernel.h>
 #include <linux/errno.h>
 #include <linux/pm.h>
+#include <linux/pm_runtime.h>
 #include <linux/string.h>
 #include <linux/slab.h>
 #include <linux/pcieport_if.h>
@@ -342,6 +343,8 @@ static int pcie_device_init(struct pci_dev *pdev, int service, int irq)
 		return retval;
 	}
 
+	pm_runtime_no_callbacks(device);
+
 	return 0;
 }
 

commit 45604e68ed7acf23e6c4cbac9930c61df19220c8
Merge: d9322d226f91 f8415222837b ad67b437f187
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue May 17 14:35:38 2016 -0500

    Merge branches 'pci/hotplug' and 'pci/resource' into next
    
    * pci/hotplug:
      PCI: Use cached copy of PCI_EXP_SLTCAP_HPC bit
    
    * pci/resource:
      PCI: Disable all BAR sizing for devices with non-compliant BARs
      x86/PCI: Mark Broadwell-EP Home Agent 1 as having non-compliant BARs
      PCI: Identify Enhanced Allocation (EA) BAR Equivalent resources in sysfs

commit f8415222837b651902661f12f5760169690f6696
Author: Lukas Wunner <lukas@wunner.de>
Date:   Wed May 4 16:58:11 2016 -0500

    PCI: Use cached copy of PCI_EXP_SLTCAP_HPC bit
    
    We cache the PCI_EXP_SLTCAP_HPC bit in pci_dev->is_hotplug_bridge on device
    probe, so there's no need to read it again on allocation of port service
    devices.
    
    No functional change intended.
    
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index 88122dc2e1b1..847f4fdca50c 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -254,7 +254,6 @@ static void cleanup_service_irqs(struct pci_dev *dev)
 static int get_port_device_capability(struct pci_dev *dev)
 {
 	int services = 0;
-	u32 reg32;
 	int cap_mask = 0;
 	int err;
 
@@ -273,19 +272,14 @@ static int get_port_device_capability(struct pci_dev *dev)
 	}
 
 	/* Hot-Plug Capable */
-	if ((cap_mask & PCIE_PORT_SERVICE_HP) &&
-	    pcie_caps_reg(dev) & PCI_EXP_FLAGS_SLOT) {
-		pcie_capability_read_dword(dev, PCI_EXP_SLTCAP, &reg32);
-		if (reg32 & PCI_EXP_SLTCAP_HPC) {
-			services |= PCIE_PORT_SERVICE_HP;
-			/*
-			 * Disable hot-plug interrupts in case they have been
-			 * enabled by the BIOS and the hot-plug service driver
-			 * is not loaded.
-			 */
-			pcie_capability_clear_word(dev, PCI_EXP_SLTCTL,
-				PCI_EXP_SLTCTL_CCIE | PCI_EXP_SLTCTL_HPIE);
-		}
+	if ((cap_mask & PCIE_PORT_SERVICE_HP) && dev->is_hotplug_bridge) {
+		services |= PCIE_PORT_SERVICE_HP;
+		/*
+		 * Disable hot-plug interrupts in case they have been enabled
+		 * by the BIOS and the hot-plug service driver is not loaded.
+		 */
+		pcie_capability_clear_word(dev, PCI_EXP_SLTCTL,
+			  PCI_EXP_SLTCTL_CCIE | PCI_EXP_SLTCTL_HPIE);
 	}
 	/* AER capable */
 	if ((cap_mask & PCIE_PORT_SERVICE_AER)

commit d9322d226f91ad95825ab68f3e5cfeda7b9c4553
Merge: 58f8b094e96f 26e515713342 c20e128030ca 2ffa9a5d76a7
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue May 3 11:49:21 2016 -0500

    Merge branches 'pci/dpc', 'pci/resource' and 'pci/thunderbolt' into next
    
    * pci/dpc:
      PCI: Add Downstream Port Containment driver
      PCI: Add Downstream Port Containment portdrv service type
      PCI: Widen portdrv service type from 4 bits to 8 bits
    
    * pci/resource:
      alpha/PCI: Call iomem_is_exclusive() for IORESOURCE_MEM, but not IORESOURCE_IO
      PCI: Supply CPU physical address (not bus address) to iomem_is_exclusive()
    
    * pci/thunderbolt:
      thunderbolt: Fix double free of drom buffer

commit 10126ac14d36e74b2705802dc915b0b18463a51f
Author: Keith Busch <keith.busch@intel.com>
Date:   Mon May 2 15:10:31 2016 -0500

    PCI: Add Downstream Port Containment portdrv service type
    
    Add the Downstream Port Containment (PCIE_PORT_SERVICE_DPC) portdrv service
    type, available if the device has the DPC extended capability.
    
    [bhelgaas: split to separate patch, changelog]
    Signed-off-by: Keith Busch <keith.busch@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index 94d3b82415c1..2ab0f424a378 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -262,7 +262,7 @@ static int get_port_device_capability(struct pci_dev *dev)
 		return 0;
 
 	cap_mask = PCIE_PORT_SERVICE_PME | PCIE_PORT_SERVICE_HP
-			| PCIE_PORT_SERVICE_VC;
+			| PCIE_PORT_SERVICE_VC | PCIE_PORT_SERVICE_DPC;
 	if (pci_aer_available())
 		cap_mask |= PCIE_PORT_SERVICE_AER;
 
@@ -311,6 +311,8 @@ static int get_port_device_capability(struct pci_dev *dev)
 		 */
 		pcie_pme_interrupt_enable(dev, false);
 	}
+	if (pci_find_ext_capability(dev, PCI_EXT_CAP_ID_DPC))
+		services |= PCIE_PORT_SERVICE_DPC;
 
 	return services;
 }

commit 6d81417da8720b393f670de9cce03a3642ea9a30
Author: Keith Busch <keith.busch@intel.com>
Date:   Tue May 3 09:58:11 2016 -0500

    PCI: Widen portdrv service type from 4 bits to 8 bits
    
    The names of port service devices previously used one nibble to encode the
    port type and another nibble to encode the service type.  We're about to
    add a fifth service type, so change device names to use one *byte* to
    encode the service type.
    
    For example, a hotplug port service on a downstream bridge was previously
    called "pcie24" and is now called "pcie204".  The "2" encodes the device
    type (PCI_EXP_TYPE_DOWNSTREAM - 4), and the "4" (now "04") encodes the
    service (PCIE_PORT_SERVICE_HP).
    
    Based on Lukas Wunner's patch:
    https://github.com/l1k/linux/commit/b688d6e4873ab082e5916b1a993bc1d38c6f4178
    
    [bhelgaas: split to separate patch, expand changelog]
    Based-on-patch-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Keith Busch <keith.busch@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index 88122dc2e1b1..94d3b82415c1 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -338,7 +338,7 @@ static int pcie_device_init(struct pci_dev *pdev, int service, int irq)
 	device = &pcie->device;
 	device->bus = &pcie_port_bus_type;
 	device->release = release_pcie_device;	/* callback to free pcie dev */
-	dev_set_name(device, "%s:pcie%02x",
+	dev_set_name(device, "%s:pcie%03x",
 		     pci_name(pdev),
 		     get_descriptor_id(pci_pcie_type(pdev), service));
 	device->parent = &pdev->dev;

commit 88a97da1eab7587036d8bc937d6bc874b8210df1
Author: Jon Derrick <jonathan.derrick@intel.com>
Date:   Fri Apr 8 11:35:51 2016 -0600

    PCI: Remove return values from pcie_port_platform_notify() and relatives
    
    Now that pcie_port_acpi_setup() always returns 0, make it and its callers
    void functions and stop checking the return values.
    
    [bhelgaas: changelog]
    Signed-off-by: Jon Derrick <jonathan.derrick@intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index 88122dc2e1b1..de7a85bc8016 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -256,7 +256,6 @@ static int get_port_device_capability(struct pci_dev *dev)
 	int services = 0;
 	u32 reg32;
 	int cap_mask = 0;
-	int err;
 
 	if (pcie_ports_disabled)
 		return 0;
@@ -266,11 +265,8 @@ static int get_port_device_capability(struct pci_dev *dev)
 	if (pci_aer_available())
 		cap_mask |= PCIE_PORT_SERVICE_AER;
 
-	if (pcie_ports_auto) {
-		err = pcie_port_platform_notify(dev, &cap_mask);
-		if (err)
-			return 0;
-	}
+	if (pcie_ports_auto)
+		pcie_port_platform_notify(dev, &cap_mask);
 
 	/* Hot-Plug Capable */
 	if ((cap_mask & PCIE_PORT_SERVICE_HP) &&

commit e7f6c6d02cc3fa7f78153919900561bd1dce02a3
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Jun 24 16:03:23 2015 -0500

    PCI: Fix pcie_port_device_resume() comment
    
    The function comment claimed this was pcie_port_device_suspend(), but it's
    really pcie_port_device_resume().  Perils of cut and paste.
    
    Use the correct function name in the comment.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index 2f0ce668a775..88122dc2e1b1 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -448,7 +448,7 @@ static int resume_iter(struct device *dev, void *data)
 }
 
 /**
- * pcie_port_device_suspend - resume port services associated with a PCIe port
+ * pcie_port_device_resume - resume port services associated with a PCIe port
  * @dev: PCI Express port to handle
  */
 int pcie_port_device_resume(struct device *dev)

commit 518a6a34f645897ec3440e5cbcf53ced3493ee1c
Merge: c9eaa447e77e 761ce53330a4 a30d0108b09a 1a30fd0dba77 1e358f94c005
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Apr 29 17:43:58 2014 -0600

    Merge branches 'pci/hotplug', 'pci/msi', 'pci/virtualization' and 'pci/misc' into next
    
    * pci/hotplug:
      PCI: rphahp: Fix endianess issues
      PCI: Allow hotplug service drivers to operate in polling mode
      PCI: pciehp: Acknowledge spurious "cmd completed" event
      PCI: pciehp: Use PCI_EXP_SLTCAP_PSN define
      PCI: hotplug: Remove unnecessary "dev->bus" test
    
    * pci/msi:
      GenWQE: Use pci_enable_msi_exact() instead of pci_enable_msi_block()
      PCI/MSI: Simplify populate_msi_sysfs()
      PCI/portdrv: Use pci_enable_msix_exact() instead of pci_enable_msix()
    
    * pci/virtualization:
      PCI: Add Patsburg (X79) to Intel PCH root port ACS quirk
    
    * pci/misc:
      PCI: Fix use of uninitialized MPS value
      PCI: Remove dead code
      MAINTAINERS: Add arch/x86/kernel/quirks.c to PCI file patterns
      PCI: Remove unnecessary __ref annotations
      PCI: Fail new_id for vendor/device values already built into driver
      PCI: Add new ID for Intel GPU "spurious interrupt" quirk
      PCI: Update my email address
      PCI: Fix incorrect vgaarb conditional in WARN_ON()
      PCI: Use designated initialization in PCI_VDEVICE
      PCI: Remove old serial device IDs
      PCI: Remove unnecessary includes of <linux/init.h>
      powerpc/PCI: Fix NULL dereference in sys_pciconfig_iobase() list traversal

commit 374a91404314cef882b27b293dd34d89e2a3c0b6
Author: Rajat Jain <rajatxjain@gmail.com>
Date:   Mon Mar 31 16:51:23 2014 -0700

    PCI: Allow hotplug service drivers to operate in polling mode
    
    Today the PCIe port bus driver disables the Hot-plug service if the port
    device does not have the capability to generate interrupts.  However, a
    user must be able to use the "pciehp_poll_mode" parameter to use the pciehp
    in polling method in such a case.  Today it is not possible.
    
    This patch allows a hotplug service driver to decide whether or not it
    would like to continue in the absence of interrupts.
    
    Signed-off-by: Rajat Jain <rajatxjain@gmail.com>
    Signed-off-by: Rajat Jain <rajatjain@juniper.net>
    Signed-off-by: Guenter Roeck <groeck@juniper.net>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index 986f8eadfd39..f6503add2f35 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -379,10 +379,13 @@ int pcie_port_device_register(struct pci_dev *dev)
 	/*
 	 * Initialize service irqs. Don't use service devices that
 	 * require interrupts if there is no way to generate them.
+	 * However, some drivers may have a polling mode (e.g. pciehp_poll_mode)
+	 * that can be used in the absence of irqs.  Allow them to determine
+	 * if that is to be used.
 	 */
 	status = init_service_irqs(dev, irqs, capabilities);
 	if (status) {
-		capabilities &= PCIE_PORT_SERVICE_VC;
+		capabilities &= PCIE_PORT_SERVICE_VC | PCIE_PORT_SERVICE_HP;
 		if (!capabilities)
 			goto error_disable;
 	}

commit 9ada07b1100a9c7d3107c47673664194574b02a0
Author: Alexander Gordeev <agordeev@redhat.com>
Date:   Thu Mar 6 21:11:22 2014 +0100

    PCI/portdrv: Use pci_enable_msix_exact() instead of pci_enable_msix()
    
    As result of deprecation of MSI-X/MSI enablement functions
    pci_enable_msix() and pci_enable_msi_block() all drivers using these two
    interfaces need to be updated to use the new pci_enable_msi_range()  or
    pci_enable_msi_exact() and pci_enable_msix_range() or
    pci_enable_msix_exact() interfaces.
    
    Signed-off-by: Alexander Gordeev <agordeev@redhat.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index 986f8eadfd39..0b1efb2760d1 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -99,7 +99,7 @@ static int pcie_port_enable_msix(struct pci_dev *dev, int *vectors, int mask)
 	for (i = 0; i < nr_entries; i++)
 		msix_entries[i].entry = i;
 
-	status = pci_enable_msix(dev, msix_entries, nr_entries);
+	status = pci_enable_msix_exact(dev, msix_entries, nr_entries);
 	if (status)
 		goto Exit;
 
@@ -171,7 +171,7 @@ static int pcie_port_enable_msix(struct pci_dev *dev, int *vectors, int mask)
 		pci_disable_msix(dev);
 
 		/* Now allocate the MSI-X vectors for real */
-		status = pci_enable_msix(dev, msix_entries, nvec);
+		status = pci_enable_msix_exact(dev, msix_entries, nvec);
 		if (status)
 			goto Exit;
 	}

commit 04f982beb900f37bc216d63c9dbc5bdddb4a3d3a
Merge: ccb126545448 302a2523c277
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Jan 7 17:34:39 2014 -0700

    Merge branch 'pci/msi' into next
    
    * pci/msi:
      PCI/MSI: Add pci_enable_msi_range() and pci_enable_msix_range()
      PCI/MSI: Add pci_msix_vec_count()
      PCI/MSI: Remove pci_enable_msi_block_auto()
      PCI/MSI: Add pci_msi_vec_count()

commit ff1aa430a2fa43189e89c7ddd559f0bee2298288
Author: Alexander Gordeev <agordeev@redhat.com>
Date:   Mon Dec 30 08:28:15 2013 +0100

    PCI/MSI: Add pci_msix_vec_count()
    
    This creates an MSI-X counterpart for pci_msi_vec_count().  Device drivers
    can use this function to obtain maximum number of MSI-X interrupts the
    device supports and use that number in a subsequent call to
    pci_enable_msix().
    
    pci_msix_vec_count() supersedes pci_msix_table_size() and returns a
    negative errno if device does not support MSI-X interrupts.  After this
    update, callers must always check the returned value.
    
    The only user of pci_msix_table_size() was the PCI-Express port driver,
    which is also updated by this change.
    
    Signed-off-by: Alexander Gordeev <agordeev@redhat.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index 0b6e76604068..4ab719826dd7 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -79,9 +79,10 @@ static int pcie_port_enable_msix(struct pci_dev *dev, int *vectors, int mask)
 	u16 reg16;
 	u32 reg32;
 
-	nr_entries = pci_msix_table_size(dev);
-	if (!nr_entries)
-		return -EINVAL;
+	nr_entries = pci_msix_vec_count(dev);
+	if (nr_entries < 0)
+		return nr_entries;
+	BUG_ON(!nr_entries);
 	if (nr_entries > PCIE_PORT_MAX_MSIX_ENTRIES)
 		nr_entries = PCIE_PORT_MAX_MSIX_ENTRIES;
 

commit f72e11123ba122c4ed8fcee52ab57cf3fbe81178
Merge: 9dc1d43ff951 e75f34ce6633
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Dec 20 12:41:18 2013 -0700

    Merge branch 'pci/deletion' into next
    
    * pci/deletion:
      PCI/portdrv: Remove extra get_device()/put_device() for pcie_device
      PCI/portdrv: Add put_device() after device_register() failure
      PCI/portdrv: Cleanup error paths

commit e75f34ce6633549486a044d64b2a79240d4113a8
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Dec 19 14:24:13 2013 -0700

    PCI/portdrv: Remove extra get_device()/put_device() for pcie_device
    
    Previously pcie_device_init() called get_device() if device_register() for
    the new pcie_device succeeded, and remove_iter() called put_device() when
    removing before unregistering the device.
    
    But device_register() already increments the reference count in
    device_add(), so we don't need to do it again here.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index 9811eea53511..6a6e54909335 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -349,7 +349,6 @@ static int pcie_device_init(struct pci_dev *pdev, int service, int irq)
 		return retval;
 	}
 
-	get_device(device);
 	return 0;
 }
 
@@ -456,10 +455,8 @@ int pcie_port_device_resume(struct device *dev)
 
 static int remove_iter(struct device *dev, void *data)
 {
-	if (dev->bus == &pcie_port_bus_type) {
-		put_device(dev);
+	if (dev->bus == &pcie_port_bus_type)
 		device_unregister(dev);
-	}
 	return 0;
 }
 

commit f39862058e1f278e0495cd9ea57de571e74aa1fe
Author: Levente Kurusa <levex@linux.com>
Date:   Thu Dec 19 14:22:35 2013 -0700

    PCI/portdrv: Add put_device() after device_register() failure
    
    This is required so that we give up the last reference to the device.
    Removed the kfree() as put_device will result in release_pcie_device()
    being called and hence the container of the device will be kfree'd.
    
    [bhelgaas: fix conflict after my previous cleanup]
    Signed-off-by: Levente Kurusa <levex@linux.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index fc86d323fecc..9811eea53511 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -345,7 +345,7 @@ static int pcie_device_init(struct pci_dev *pdev, int service, int irq)
 
 	retval = device_register(device);
 	if (retval) {
-		kfree(pcie);
+		put_device(device);
 		return retval;
 	}
 

commit 8f3acca9acec1503f6b374faef2d1013cbf502af
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Dec 19 14:20:09 2013 -0700

    PCI/portdrv: Cleanup error paths
    
    Make the straightline path the normal no-error path.  Check for errors and
    return them directly, instead of checking for success and putting the
    normal path in an "if" body.
    
    No functional change.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index 0b6e76604068..fc86d323fecc 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -344,11 +344,13 @@ static int pcie_device_init(struct pci_dev *pdev, int service, int irq)
 	device_enable_async_suspend(device);
 
 	retval = device_register(device);
-	if (retval)
+	if (retval) {
 		kfree(pcie);
-	else
-		get_device(device);
-	return retval;
+		return retval;
+	}
+
+	get_device(device);
+	return 0;
 }
 
 /**
@@ -498,12 +500,12 @@ static int pcie_port_probe_service(struct device *dev)
 
 	pciedev = to_pcie_device(dev);
 	status = driver->probe(pciedev);
-	if (!status) {
-		dev_printk(KERN_DEBUG, dev, "service driver %s loaded\n",
-			driver->name);
-		get_device(dev);
-	}
-	return status;
+	if (status)
+		return status;
+
+	dev_printk(KERN_DEBUG, dev, "service driver %s loaded\n", driver->name);
+	get_device(dev);
+	return 0;
 }
 
 /**

commit 6f825b73e249a2b46f0349d1f86adfbb3ea703e0
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Tue Nov 12 20:07:17 2013 +0100

    PCI/portdrv: Remove superfluous name cast
    
    device_driver.name is "const char *"
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index 0b6e76604068..ce9d9ae17bfd 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -554,7 +554,7 @@ int pcie_port_service_register(struct pcie_port_service_driver *new)
 	if (pcie_ports_disabled)
 		return -ENODEV;
 
-	new->driver.name = (char *)new->name;
+	new->driver.name = new->name;
 	new->driver.bus = &pcie_port_bus_type;
 	new->driver.probe = pcie_port_probe_service;
 	new->driver.remove = pcie_port_remove_service;

commit f7625980f5820edd1a73536e1a03bcbc1f889fec
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Nov 14 11:28:18 2013 -0700

    PCI: Fix whitespace, capitalization, and spelling errors
    
    Fix whitespace, capitalization, and spelling errors.  No functional change.
    I know "busses" is not an error, but "buses" was more common, so I used it
    consistently.
    
    Signed-off-by: Marta Rybczynska <rybczynska@gmail.com> (pci_reset_bridge_secondary_bus())
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index 08d131f7815b..0b6e76604068 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -46,7 +46,7 @@ static void release_pcie_device(struct device *dev)
  * pcie_port_msix_add_entry - add entry to given array of MSI-X entries
  * @entries: Array of MSI-X entries
  * @new_entry: Index of the entry to add to the array
- * @nr_entries: Number of entries aleady in the array
+ * @nr_entries: Number of entries already in the array
  *
  * Return value: Position of the added entry in the array
  */

commit 6b87e700cd65120b70aaa097a8f4e7f22f1945ee
Author: Andrew Murray <amurray@embedded-bits.co.uk>
Date:   Sat Oct 26 18:23:25 2013 +0100

    PCI: Update pcie_ports 'auto' behavior for non-ACPI platforms
    
    The pcie_ports parameter, which defaults to 'auto', allows a user
    to specify if PCIe port services are disabled ('compat'), always
    enabled ('native'), or only used when allowed by the BIOS
    ('auto').
    
    Where CONFIG_ACPI isn't enabled, as is often the case for non
    x86/ia64 platforms, the 'auto' behavior results in that of
    'compat'. Thus in order to use port services on these platforms
    'pcie_ports=native' must be added to the kernel command line.
    
    This patch results in the 'native' behavior being followed where
    'auto' is selected and ACPI is not enabled.
    
    Signed-off-by: Andrew Murray <amurray@embedded-bits.co.uk>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index 31063ac30992..08d131f7815b 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -260,13 +260,14 @@ static int get_port_device_capability(struct pci_dev *dev)
 	if (pcie_ports_disabled)
 		return 0;
 
-	err = pcie_port_platform_notify(dev, &cap_mask);
-	if (!pcie_ports_auto) {
-		cap_mask = PCIE_PORT_SERVICE_PME | PCIE_PORT_SERVICE_HP
-				| PCIE_PORT_SERVICE_VC;
-		if (pci_aer_available())
-			cap_mask |= PCIE_PORT_SERVICE_AER;
-	} else if (err) {
+	cap_mask = PCIE_PORT_SERVICE_PME | PCIE_PORT_SERVICE_HP
+			| PCIE_PORT_SERVICE_VC;
+	if (pci_aer_available())
+		cap_mask |= PCIE_PORT_SERVICE_AER;
+
+	if (pcie_ports_auto) {
+		err = pcie_port_platform_notify(dev, &cap_mask);
+		if (err)
 			return 0;
 	}
 

commit 1c531d82ee1a220ae7132ba0eb31edaf186b56d1
Author: Myron Stowe <myron.stowe@redhat.com>
Date:   Fri Jan 25 17:55:45 2013 -0700

    PCI: Use PCI Express Capability accessor
    
    Use PCI Express Capability access functions to simplify device
    Capabilities Register usages.
    
    Signed-off-by: Myron Stowe <myron.stowe@redhat.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index b42133afca98..31063ac30992 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -272,7 +272,7 @@ static int get_port_device_capability(struct pci_dev *dev)
 
 	/* Hot-Plug Capable */
 	if ((cap_mask & PCIE_PORT_SERVICE_HP) &&
-	    dev->pcie_flags_reg & PCI_EXP_FLAGS_SLOT) {
+	    pcie_caps_reg(dev) & PCI_EXP_FLAGS_SLOT) {
 		pcie_capability_read_dword(dev, PCI_EXP_SLTCAP, &reg32);
 		if (reg32 & PCI_EXP_SLTCAP_HPC) {
 			services |= PCIE_PORT_SERVICE_HP;

commit 27e1c8ee0170e80f6426c35d54f3b5cd9dadb25b
Merge: 72e1e868ca8f a875621ec153
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Dec 7 12:11:52 2012 -0700

    Merge branch 'pci/bjorn-pcie-cap' into next
    
    * pci/bjorn-pcie-cap:
      ath9k: Use standard #defines for PCIe Capability ASPM fields
      iwlwifi: Use standard #defines for PCIe Capability ASPM fields
      iwlwifi: collapse wrapper for pcie_capability_read_word()
      iwlegacy: Use standard #defines for PCIe Capability ASPM fields
      iwlegacy: collapse wrapper for pcie_capability_read_word()
      cxgb3: Use standard #defines for PCIe Capability ASPM fields
      PCI: Add standard PCIe Capability Link ASPM field names
      PCI/portdrv: Use PCI Express Capability accessors
      PCI: Use standard PCIe Capability Link register field names
      PCI: Add and use standard PCI-X Capability register names

commit 33e8b34fdd5640f3aa1597710352349cbc823374
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Wed Dec 5 13:51:18 2012 -0700

    PCI/portdrv: Use PCI Express Capability accessors
    
    Use PCI Express Capability access functions to simplify portdrv.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index d03a7a39b2d8..70d3555903ae 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -120,8 +120,7 @@ static int pcie_port_enable_msix(struct pci_dev *dev, int *vectors, int mask)
 		 * the value in this field indicates which MSI-X Table entry is
 		 * used to generate the interrupt message."
 		 */
-		pos = pci_pcie_cap(dev);
-		pci_read_config_word(dev, pos + PCI_EXP_FLAGS, &reg16);
+		pcie_capability_read_word(dev, PCI_EXP_FLAGS, &reg16);
 		entry = (reg16 & PCI_EXP_FLAGS_IRQ) >> 9;
 		if (entry >= nr_entries)
 			goto Error;

commit ff8e59bc4ec3f31789a47dce9b6fe44bd7bc5fcc
Author: Taku Izumi <izumi.taku@jp.fujitsu.com>
Date:   Wed Oct 31 09:51:48 2012 +0900

    PCI/portdrv: Don't create hotplug slots unless port supports hotplug
    
    Commit 2dcfaf85 mistakenly dropped the "flags & PCI_EXP_FLAGS_SLOT" test,
    so now we create hotplug slots even for PCIe port devices that don't
    support hotplug.  This patch fixes this problem.
    
    [bhelgaas: changelog]
    Signed-off-by: Taku Izumi <izumi.taku@jp.fujitsu.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>
    Reviewed-by: Jiang Liu <jiang.liu@huawei.com>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index d03a7a39b2d8..ed129b414624 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -272,7 +272,8 @@ static int get_port_device_capability(struct pci_dev *dev)
 	}
 
 	/* Hot-Plug Capable */
-	if (cap_mask & PCIE_PORT_SERVICE_HP) {
+	if ((cap_mask & PCIE_PORT_SERVICE_HP) &&
+	    dev->pcie_flags_reg & PCI_EXP_FLAGS_SLOT) {
 		pcie_capability_read_dword(dev, PCI_EXP_SLTCAP, &reg32);
 		if (reg32 & PCI_EXP_SLTCAP_HPC) {
 			services |= PCIE_PORT_SERVICE_HP;

commit a690a4cbf09f70723f9721ca96ab8b2b472b3391
Merge: 5aaa71cf12f9 e237d83fdf03
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Sep 10 16:35:40 2012 -0600

    Merge branch 'pci/shengzhou-irq' into next
    
    * pci/shengzhou-irq:
      PCI: Use dev->irq instead of dev->pin to enable non MSI/INTx interrupt

commit e237d83fdf0313d26af46f41b69b3b87d62669c0
Author: Shengzhou Liu <Shengzhou.Liu@freescale.com>
Date:   Wed Jul 18 14:06:54 2012 +0800

    PCI: Use dev->irq instead of dev->pin to enable non MSI/INTx interrupt
    
    On some platforms, root port has neither MSI/MSI-X nor INTx interrupt
    generated in RC mode. In this case, we have to use other interrupt, e.g.,
    system shared interrupt, for port service IRQ to have AER, Hot-plug, etc.,
    services work.
    
    Signed-off-by: Shengzhou Liu <Shengzhou.Liu@freescale.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index 75915b30ad19..eaa39fb448c4 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -200,10 +200,13 @@ static int init_service_irqs(struct pci_dev *dev, int *irqs, int mask)
 {
 	int i, irq = -1;
 
-	/* We have to use INTx if MSI cannot be used for PCIe PME or pciehp. */
+	/*
+	 * If MSI cannot be used for PCIe PME or hotplug, we have to use
+	 * INTx or other interrupts, e.g. system shared interrupt.
+	 */
 	if (((mask & PCIE_PORT_SERVICE_PME) && pcie_pme_no_msi()) ||
 	    ((mask & PCIE_PORT_SERVICE_HP) && pciehp_no_msi())) {
-		if (dev->pin)
+		if (dev->irq)
 			irq = dev->irq;
 		goto no_msi;
 	}
@@ -212,8 +215,12 @@ static int init_service_irqs(struct pci_dev *dev, int *irqs, int mask)
 	if (!pcie_port_enable_msix(dev, irqs, mask))
 		return 0;
 
-	/* We're not going to use MSI-X, so try MSI and fall back to INTx */
-	if (!pci_enable_msi(dev) || dev->pin)
+	/*
+	 * We're not going to use MSI-X, so try MSI and fall back to INTx.
+	 * If neither MSI/MSI-X nor INTx available, try other interrupt.  On
+	 * some platforms, root port doesn't support MSI/MSI-X/INTx in RC mode.
+	 */
+	if (!pci_enable_msi(dev) || dev->irq)
 		irq = dev->irq;
 
  no_msi:

commit 2dcfaf85cd0ced6dcfd4bf0012354b3fd2ed1f38
Author: Jiang Liu <jiang.liu@huawei.com>
Date:   Tue Jul 24 17:20:08 2012 +0800

    PCI/portdrv: Use PCI Express Capability accessors
    
    Use PCI Express Capability access functions to simplify portdrv.
    
    Signed-off-by: Jiang Liu <jiang.liu@huawei.com>
    Signed-off-by: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index bf320a9419f4..aede99171e90 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -246,8 +246,7 @@ static void cleanup_service_irqs(struct pci_dev *dev)
  */
 static int get_port_device_capability(struct pci_dev *dev)
 {
-	int services = 0, pos;
-	u16 reg16;
+	int services = 0;
 	u32 reg32;
 	int cap_mask = 0;
 	int err;
@@ -265,11 +264,9 @@ static int get_port_device_capability(struct pci_dev *dev)
 			return 0;
 	}
 
-	pos = pci_pcie_cap(dev);
-	pci_read_config_word(dev, pos + PCI_EXP_FLAGS, &reg16);
 	/* Hot-Plug Capable */
-	if ((cap_mask & PCIE_PORT_SERVICE_HP) && (reg16 & PCI_EXP_FLAGS_SLOT)) {
-		pci_read_config_dword(dev, pos + PCI_EXP_SLTCAP, &reg32);
+	if (cap_mask & PCIE_PORT_SERVICE_HP) {
+		pcie_capability_read_dword(dev, PCI_EXP_SLTCAP, &reg32);
 		if (reg32 & PCI_EXP_SLTCAP_HPC) {
 			services |= PCIE_PORT_SERVICE_HP;
 			/*
@@ -277,10 +274,8 @@ static int get_port_device_capability(struct pci_dev *dev)
 			 * enabled by the BIOS and the hot-plug service driver
 			 * is not loaded.
 			 */
-			pos += PCI_EXP_SLTCTL;
-			pci_read_config_word(dev, pos, &reg16);
-			reg16 &= ~(PCI_EXP_SLTCTL_CCIE | PCI_EXP_SLTCTL_HPIE);
-			pci_write_config_word(dev, pos, reg16);
+			pcie_capability_clear_word(dev, PCI_EXP_SLTCTL,
+				PCI_EXP_SLTCTL_CCIE | PCI_EXP_SLTCTL_HPIE);
 		}
 	}
 	/* AER capable */

commit 62f87c0e31d646d5501edf4f7feb07d0ad689d80
Author: Yijing Wang <wangyijing@huawei.com>
Date:   Tue Jul 24 17:20:03 2012 +0800

    PCI: Introduce pci_pcie_type(dev) to replace pci_dev->pcie_type
    
    Introduce an inline function pci_pcie_type(dev) to extract PCIe
    device type from pci_dev->pcie_flags_reg field, and prepare for
    removing pci_dev->pcie_type.
    
    Signed-off-by: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Jiang Liu <jiang.liu@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index 75915b30ad19..bf320a9419f4 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -298,7 +298,7 @@ static int get_port_device_capability(struct pci_dev *dev)
 		services |= PCIE_PORT_SERVICE_VC;
 	/* Root ports are capable of generating PME too */
 	if ((cap_mask & PCIE_PORT_SERVICE_PME)
-	    && dev->pcie_type == PCI_EXP_TYPE_ROOT_PORT) {
+	    && pci_pcie_type(dev) == PCI_EXP_TYPE_ROOT_PORT) {
 		services |= PCIE_PORT_SERVICE_PME;
 		/*
 		 * Disable PME interrupt on this port in case it's been enabled
@@ -336,7 +336,7 @@ static int pcie_device_init(struct pci_dev *pdev, int service, int irq)
 	device->release = release_pcie_device;	/* callback to free pcie dev */
 	dev_set_name(device, "%s:pcie%02x",
 		     pci_name(pdev),
-		     get_descriptor_id(pdev->pcie_type, service));
+		     get_descriptor_id(pci_pcie_type(pdev), service));
 	device->parent = &pdev->dev;
 	device_enable_async_suspend(device);
 

commit 1267b3a325f00291e847ea4a001ccabe5d5516f2
Author: Chunhe Lan <Chunhe.Lan@freescale.com>
Date:   Wed Mar 7 15:16:26 2012 +0800

    PCI: fix uninitialized variable 'cap_mask'
    
    Get rid of these:
    
    drivers/pci/pcie/portdrv_core.c: In function 'pcie_port_device_register':
    drivers/pci/pcie/portdrv_core.c:275:16: warning: 'cap_mask' may be used
    uninitialized in this function [-Wuninitialized]
    drivers/pci/pcie/portdrv_core.c:240:6: note: 'cap_mask' was declared here
    
    In some cases, 'cap_mask' may be not set in pcie_port_platform_notify,
    holding a garbage value.
    
    Signed-off-by: Chunhe Lan <Chunhe.Lan@freescale.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index 2f589a54f9bd..75915b30ad19 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -249,7 +249,7 @@ static int get_port_device_capability(struct pci_dev *dev)
 	int services = 0, pos;
 	u16 reg16;
 	u32 reg32;
-	int cap_mask;
+	int cap_mask = 0;
 	int err;
 
 	if (pcie_ports_disabled)

commit 7570a333d8b00e7fd4b05d898e353000a70210ce
Author: MUNEDA Takahiro <muneda.takahiro@jp.fujitsu.com>
Date:   Thu Feb 2 11:09:22 2012 -0500

    PCI: Add pcie_hp=nomsi to disable MSI/MSI-X for pciehp driver
    
    Add a parameter to avoid using MSI/MSI-X for PCIe native hotplug; it's
    known to be buggy on some platforms.
    
    In my environment, while shutting down, following stack trace is shown
    sometimes.
    
      irq 16: nobody cared (try booting with the "irqpoll" option)
      Pid: 1081, comm: reboot Not tainted 3.2.0 #1
      Call Trace:
       <IRQ>  [<ffffffff810cec1d>] __report_bad_irq+0x3d/0xe0
       [<ffffffff810cee1c>] note_interrupt+0x15c/0x210
       [<ffffffff810cc485>] handle_irq_event_percpu+0xb5/0x210
       [<ffffffff810cc621>] handle_irq_event+0x41/0x70
       [<ffffffff810cf675>] handle_fasteoi_irq+0x55/0xc0
       [<ffffffff81015356>] handle_irq+0x46/0xb0
       [<ffffffff814fbe9d>] do_IRQ+0x5d/0xe0
       [<ffffffff814f146e>] common_interrupt+0x6e/0x6e
       [<ffffffff8106b040>] ? __do_softirq+0x60/0x210
       [<ffffffff8108aeb1>] ? hrtimer_interrupt+0x151/0x240
       [<ffffffff814fb5ec>] call_softirq+0x1c/0x30
       [<ffffffff810152d5>] do_softirq+0x65/0xa0
       [<ffffffff8106ae9d>] irq_exit+0xbd/0xe0
       [<ffffffff814fbf8e>] smp_apic_timer_interrupt+0x6e/0x99
       [<ffffffff814f9e5e>] apic_timer_interrupt+0x6e/0x80
       <EOI>  [<ffffffff814f0fb1>] ? _raw_spin_unlock_irqrestore+0x11/0x20
       [<ffffffff812629fc>] pci_bus_write_config_word+0x6c/0x80
       [<ffffffff81266fc2>] pci_intx+0x52/0xa0
       [<ffffffff8127de3d>] pci_intx_for_msi+0x1d/0x30
      [<ffffffff8127e4fb>] pci_msi_shutdown+0x7b/0x110
       [<ffffffff81269d34>] pci_device_shutdown+0x34/0x50
       [<ffffffff81326c4f>] device_shutdown+0x2f/0x140
       [<ffffffff8107b981>] kernel_restart_prepare+0x31/0x40
       [<ffffffff8107b9e6>] kernel_restart+0x16/0x60
       [<ffffffff8107bbfd>] sys_reboot+0x1ad/0x220
       [<ffffffff814f4b90>] ? do_page_fault+0x1e0/0x460
       [<ffffffff811942d0>] ? __sync_filesystem+0x90/0x90
       [<ffffffff8105c9aa>] ? __cond_resched+0x2a/0x40
       [<ffffffff814ef090>] ? _cond_resched+0x30/0x40
       [<ffffffff81169e17>] ? iterate_supers+0xb7/0xd0
       [<ffffffff814f9382>] system_call_fastpath+0x16/0x1b
      handlers:
      [<ffffffff8138a0f0>] usb_hcd_irq
      [<ffffffff8138a0f0>] usb_hcd_irq
      [<ffffffff8138a0f0>] usb_hcd_irq
      Disabling IRQ #16
    
    An un-wanted interrupt is generated when PCI driver switches from
    MSI/MSI-X to INTx while shutting down the device.  The interrupt does
    not happen if MSI/MSI-X is not used on the device.
    I confirmed that this problem does not happen if pcie_hp=nomsi was
    specified and hotplug operation worked fine as usual.
    
    v2: Automatically disable MSI/MSI-X against following device:
        PCI bridge: Integrated Device Technology, Inc. Device 807f (rev 02)
    v3: Based on the review comment, combile the if statements.
    v4: Removed module parameter.
        Move some code to build pciehp as a module.
        Move device specific code to driver/pci/quirks.c.
    v5: Drop a device specific code until getting a vendor statement.
    
    Reviewed-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: MUNEDA Takahiro <muneda.takahiro@jp.fujitsu.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index 595654a1a6a6..2f589a54f9bd 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -19,6 +19,17 @@
 #include "../pci.h"
 #include "portdrv.h"
 
+bool pciehp_msi_disabled;
+
+static int __init pciehp_setup(char *str)
+{
+	if (!strncmp(str, "nomsi", 5))
+		pciehp_msi_disabled = true;
+
+	return 1;
+}
+__setup("pcie_hp=", pciehp_setup);
+
 /**
  * release_pcie_device - free PCI Express port service device structure
  * @dev: Port service device to release
@@ -189,8 +200,9 @@ static int init_service_irqs(struct pci_dev *dev, int *irqs, int mask)
 {
 	int i, irq = -1;
 
-	/* We have to use INTx if MSI cannot be used for PCIe PME. */
-	if ((mask & PCIE_PORT_SERVICE_PME) && pcie_pme_no_msi()) {
+	/* We have to use INTx if MSI cannot be used for PCIe PME or pciehp. */
+	if (((mask & PCIE_PORT_SERVICE_PME) && pcie_pme_no_msi()) ||
+	    ((mask & PCIE_PORT_SERVICE_HP) && pciehp_no_msi())) {
 		if (dev->pin)
 			irq = dev->irq;
 		goto no_msi;

commit eca67315e0e0d5fd91264d79c88694006dbc7d31
Author: Naga Chumbalkar <nagananda.chumbalkar@hp.com>
Date:   Mon Mar 21 03:29:20 2011 +0000

    PCI: Disable ASPM when _OSC control is not granted for PCIe services
    
    v3 -> v2: Added text to describe the problem
    v2 -> v1: Split this patch from v1
    v1      : Part of: http://marc.info/?l=linux-pci&m=130042212003242&w=2
    
    Disable ASPM when no _OSC control for PCIe services is granted
    by the BIOS. This is to protect systems with a buggy BIOS that
    did not set the ACPI FADT "ASPM Controls" bit even though the
    underlying HW can't do ASPM.
    
    To turn "on" ASPM the minimum the BIOS needs to do:
    1. Clear the ACPI FADT "ASPM Controls" bit.
    2. Support _OSC appropriately
    
    There is no _OSC Control bit for ASPM. However, we expect the BIOS to
    support _OSC for a Root Bridge that originates a PCIe hierarchy. If this
    is not the case - we are better off not enabling ASPM on that server.
    
    Commit 852972acff8f10f3a15679be2059bb94916cba5d (ACPI: Disable ASPM if the
    Platform won't provide _OSC control for PCIe) describes the above scenario.
    To quote verbatim from there:
    [The PCI SIG documentation for the _OSC OS/firmware handshaking interface
    states:
    
    "If the _OSC control method is absent from the scope of a host bridge
    device, then the operating system must not enable or attempt to use any
    features defined in this section for the hierarchy originated by the host
    bridge."
    
    The obvious interpretation of this is that the OS should not attempt to use
    PCIe hotplug, PME or AER - however, the specification also notes that an
    _OSC method is *required* for PCIe hierarchies, and experimental validation
    with An Alternative OS indicates that it doesn't use any PCIe functionality
    if the _OSC method is missing. That arguably means we shouldn't be using
    MSI or extended config space, but right now our problems seem to be limited
    to vendors being surprised when ASPM gets enabled on machines when other
    OSs refuse to do so. So, for now, let's just disable ASPM if the _OSC
    method doesn't exist or refuses to hand over PCIe capability control.]
    
    Signed-off-by: Naga Chumbalkar <nagananda.chumbalkar@hp.com>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Matthew Garrett <mjg59@srcf.ucam.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index 5130d0d22390..595654a1a6a6 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -15,7 +15,6 @@
 #include <linux/slab.h>
 #include <linux/pcieport_if.h>
 #include <linux/aer.h>
-#include <linux/pci-aspm.h>
 
 #include "../pci.h"
 #include "portdrv.h"
@@ -356,10 +355,8 @@ int pcie_port_device_register(struct pci_dev *dev)
 
 	/* Get and check PCI Express port services */
 	capabilities = get_port_device_capability(dev);
-	if (!capabilities) {
-		pcie_no_aspm();
+	if (!capabilities)
 		return 0;
-	}
 
 	pci_set_master(dev);
 	/*

commit fe31e69740eddc7316071ed5165fed6703c8cd12
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Dec 19 15:57:16 2010 +0100

    PCI/PCIe: Clear Root PME Status bits early during system resume
    
    I noticed that PCI Express PMEs don't work on my Toshiba Portege R500
    after the system has been woken up from a sleep state by a PME
    (through Wake-on-LAN).  After some investigation it turned out that
    the BIOS didn't clear the Root PME Status bit in the root port that
    received the wakeup PME and since the Requester ID was also set in
    the port's Root Status register, any subsequent PMEs didn't trigger
    interrupts.
    
    This problem can be avoided by clearing the Root PME Status bits in
    all PCI Express root ports during early resume.  For this purpose,
    add an early resume routine to the PCIe port driver and make this
    driver be always registered, even if pci_ports_disable is set (in
    which case the driver's only function is to provide the early
    resume callback).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index a9c222d79ebc..5130d0d22390 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -241,17 +241,17 @@ static int get_port_device_capability(struct pci_dev *dev)
 	int cap_mask;
 	int err;
 
+	if (pcie_ports_disabled)
+		return 0;
+
 	err = pcie_port_platform_notify(dev, &cap_mask);
-	if (pcie_ports_auto) {
-		if (err) {
-			pcie_no_aspm();
-			return 0;
-		}
-	} else {
+	if (!pcie_ports_auto) {
 		cap_mask = PCIE_PORT_SERVICE_PME | PCIE_PORT_SERVICE_HP
 				| PCIE_PORT_SERVICE_VC;
 		if (pci_aer_available())
 			cap_mask |= PCIE_PORT_SERVICE_AER;
+	} else if (err) {
+			return 0;
 	}
 
 	pos = pci_pcie_cap(dev);
@@ -349,15 +349,18 @@ int pcie_port_device_register(struct pci_dev *dev)
 	int status, capabilities, i, nr_service;
 	int irqs[PCIE_PORT_DEVICE_MAXSERVICES];
 
-	/* Get and check PCI Express port services */
-	capabilities = get_port_device_capability(dev);
-	if (!capabilities)
-		return -ENODEV;
-
 	/* Enable PCI Express port device */
 	status = pci_enable_device(dev);
 	if (status)
 		return status;
+
+	/* Get and check PCI Express port services */
+	capabilities = get_port_device_capability(dev);
+	if (!capabilities) {
+		pcie_no_aspm();
+		return 0;
+	}
+
 	pci_set_master(dev);
 	/*
 	 * Initialize service irqs. Don't use service devices that

commit 2bd50dd800b52245294cfceb56be62020cdc7515
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sat Aug 21 01:57:39 2010 +0200

    PCI: PCIe: Disable PCIe port services during port initialization
    
    In principle PCIe port services may be enabled by the BIOS, so it's
    better to disable them during port initialization to avoid spurious
    events from being generated.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Reviewed-by: Hidetoshi Seto <seto.hidetoshi@jp.fujitsu.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index d0245c83b621..a9c222d79ebc 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -259,20 +259,43 @@ static int get_port_device_capability(struct pci_dev *dev)
 	/* Hot-Plug Capable */
 	if ((cap_mask & PCIE_PORT_SERVICE_HP) && (reg16 & PCI_EXP_FLAGS_SLOT)) {
 		pci_read_config_dword(dev, pos + PCI_EXP_SLTCAP, &reg32);
-		if (reg32 & PCI_EXP_SLTCAP_HPC)
+		if (reg32 & PCI_EXP_SLTCAP_HPC) {
 			services |= PCIE_PORT_SERVICE_HP;
+			/*
+			 * Disable hot-plug interrupts in case they have been
+			 * enabled by the BIOS and the hot-plug service driver
+			 * is not loaded.
+			 */
+			pos += PCI_EXP_SLTCTL;
+			pci_read_config_word(dev, pos, &reg16);
+			reg16 &= ~(PCI_EXP_SLTCTL_CCIE | PCI_EXP_SLTCTL_HPIE);
+			pci_write_config_word(dev, pos, reg16);
+		}
 	}
 	/* AER capable */
 	if ((cap_mask & PCIE_PORT_SERVICE_AER)
-	    && pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ERR))
+	    && pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ERR)) {
 		services |= PCIE_PORT_SERVICE_AER;
+		/*
+		 * Disable AER on this port in case it's been enabled by the
+		 * BIOS (the AER service driver will enable it when necessary).
+		 */
+		pci_disable_pcie_error_reporting(dev);
+	}
 	/* VC support */
 	if (pci_find_ext_capability(dev, PCI_EXT_CAP_ID_VC))
 		services |= PCIE_PORT_SERVICE_VC;
 	/* Root ports are capable of generating PME too */
 	if ((cap_mask & PCIE_PORT_SERVICE_PME)
-	    && dev->pcie_type == PCI_EXP_TYPE_ROOT_PORT)
+	    && dev->pcie_type == PCI_EXP_TYPE_ROOT_PORT) {
 		services |= PCIE_PORT_SERVICE_PME;
+		/*
+		 * Disable PME interrupt on this port in case it's been enabled
+		 * by the BIOS (the PME service driver will enable it when
+		 * necessary).
+		 */
+		pcie_pme_interrupt_enable(dev, false);
+	}
 
 	return services;
 }

commit 28eb5f274a305bf3a13b2c80c4804d4515d05c64
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sat Aug 21 22:02:38 2010 +0200

    PCI: PCIe: Ask BIOS for control of all native services at once
    
    After commit 852972acff8f10f3a15679be2059bb94916cba5d (ACPI: Disable
    ASPM if the platform won't provide _OSC control for PCIe) control of
    the PCIe Capability Structure is unconditionally requested by
    acpi_pci_root_add(), which in principle may cause problems to
    happen in two ways.  First, the BIOS may refuse to give control of
    the PCIe Capability Structure if it is not asked for any of the
    _OSC features depending on it at the same time.  Second, the BIOS may
    assume that control of the _OSC features depending on the PCIe
    Capability Structure will be requested in the future and may behave
    incorrectly if that doesn't happen.  For this reason, control of
    the PCIe Capability Structure should always be requested along with
    control of any other _OSC features that may depend on it (ie. PCIe
    native PME, PCIe native hot-plug, PCIe AER).
    
    Rework the PCIe port driver so that (1) it checks which native PCIe
    port services can be enabled, according to the BIOS, and (2) it
    requests control of all these services simultaneously.  In
    particular, this causes pcie_portdrv_probe() to fail if the BIOS
    refuses to grant control of the PCIe Capability Structure, which
    means that no native PCIe port services can be enabled for the PCIe
    Root Complex the given port belongs to.  If that happens, ASPM is
    disabled to avoid problems with mishandling it by the part of the
    PCIe hierarchy for which control of the PCIe Capability Structure
    has not been received.
    
    Make it possible to override this behavior using 'pcie_ports=native'
    (use the PCIe native services regardless of the BIOS response to the
    control request), or 'pcie_ports=compat' (do not use the PCIe native
    services at all).
    
    Accordingly, rework the existing PCIe port service drivers so that
    they don't request control of the services directly.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index 2bf2fe510e15..d0245c83b621 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -14,6 +14,8 @@
 #include <linux/string.h>
 #include <linux/slab.h>
 #include <linux/pcieport_if.h>
+#include <linux/aer.h>
+#include <linux/pci-aspm.h>
 
 #include "../pci.h"
 #include "portdrv.h"
@@ -236,23 +238,40 @@ static int get_port_device_capability(struct pci_dev *dev)
 	int services = 0, pos;
 	u16 reg16;
 	u32 reg32;
+	int cap_mask;
+	int err;
+
+	err = pcie_port_platform_notify(dev, &cap_mask);
+	if (pcie_ports_auto) {
+		if (err) {
+			pcie_no_aspm();
+			return 0;
+		}
+	} else {
+		cap_mask = PCIE_PORT_SERVICE_PME | PCIE_PORT_SERVICE_HP
+				| PCIE_PORT_SERVICE_VC;
+		if (pci_aer_available())
+			cap_mask |= PCIE_PORT_SERVICE_AER;
+	}
 
 	pos = pci_pcie_cap(dev);
 	pci_read_config_word(dev, pos + PCI_EXP_FLAGS, &reg16);
 	/* Hot-Plug Capable */
-	if (reg16 & PCI_EXP_FLAGS_SLOT) {
+	if ((cap_mask & PCIE_PORT_SERVICE_HP) && (reg16 & PCI_EXP_FLAGS_SLOT)) {
 		pci_read_config_dword(dev, pos + PCI_EXP_SLTCAP, &reg32);
 		if (reg32 & PCI_EXP_SLTCAP_HPC)
 			services |= PCIE_PORT_SERVICE_HP;
 	}
 	/* AER capable */
-	if (pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ERR))
+	if ((cap_mask & PCIE_PORT_SERVICE_AER)
+	    && pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ERR))
 		services |= PCIE_PORT_SERVICE_AER;
 	/* VC support */
 	if (pci_find_ext_capability(dev, PCI_EXT_CAP_ID_VC))
 		services |= PCIE_PORT_SERVICE_VC;
 	/* Root ports are capable of generating PME too */
-	if (dev->pcie_type == PCI_EXP_TYPE_ROOT_PORT)
+	if ((cap_mask & PCIE_PORT_SERVICE_PME)
+	    && dev->pcie_type == PCI_EXP_TYPE_ROOT_PORT)
 		services |= PCIE_PORT_SERVICE_PME;
 
 	return services;

commit 79dd9182db2072d63ccf160bb9a3463b1c952723
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sat Aug 21 01:51:44 2010 +0200

    PCI: PCIe: Introduce commad line switch for disabling port services
    
    Introduce kernel command line switch pcie_ports= allowing one to
    disable all of the native PCIe port services, so that PCIe ports
    are treated like PCI-to-PCI bridges.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index e73effbe402c..2bf2fe510e15 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -494,6 +494,9 @@ static void pcie_port_shutdown_service(struct device *dev) {}
  */
 int pcie_port_service_register(struct pcie_port_service_driver *new)
 {
+	if (pcie_ports_disabled)
+		return -ENODEV;
+
 	new->driver.name = (char *)new->name;
 	new->driver.bus = &pcie_port_bus_type;
 	new->driver.probe = pcie_port_probe_service;

commit a1e4d72cd3024999bfb6703092ea271438805c89
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Feb 8 19:16:33 2010 +0100

    PM: Allow PCI devices to suspend/resume asynchronously
    
    Set power.async_suspend for all PCI devices and PCIe port services,
    so that they can be suspended and resumed in parallel with other
    devices they don't depend on in a known way (i.e. devices which are
    not their parents or children).
    
    This only affects the "regular" suspend and resume stages, which
    means in particular that the restoration of the PCI devices' standard
    configuration registers during resume will still be carried out
    synchronously (at the "early" resume stage).
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index 0d34ff415399..e73effbe402c 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -285,6 +285,7 @@ static int pcie_device_init(struct pci_dev *pdev, int service, int irq)
 		     pci_name(pdev),
 		     get_descriptor_id(pdev->pcie_type, service));
 	device->parent = &pdev->dev;
+	device_enable_async_suspend(device);
 
 	retval = device_register(device);
 	if (retval)

commit c39fae1416d59fd565606793f090cebe3720d50d
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Feb 17 23:40:07 2010 +0100

    PCI PM: Make it possible to force using INTx for PCIe PME signaling
    
    Apparently, some machines may have problems with PCI run-time power
    management if MSIs are used for the native PCIe PME signaling.  In
    particular, on the MSI Wind U-100 PCIe PME interrupts are not
    generated by a PCIe root port after a resume from suspend to RAM, if
    the system wake-up was triggered by a PME from the device attached to
    this port.  [It doesn't help to free the interrupt on suspend and
    request it back on resume, even if that is done along with disabling
    the MSI and re-enabling it, respectively.]  However, if INTx
    interrupts are used for this purpose on the same machine, everything
    works just fine.
    
    For this reason, add a kernel command line switch allowing one to
    request that MSIs be not used for the native PCIe PME signaling,
    introduce a DMI table allowing us to blacklist machines that need
    this switch to be set by default and put the MSI Wind U-100 into this
    table.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index b174188ac121..0d34ff415399 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -186,16 +186,24 @@ static int pcie_port_enable_msix(struct pci_dev *dev, int *vectors, int mask)
  */
 static int init_service_irqs(struct pci_dev *dev, int *irqs, int mask)
 {
-	int i, irq;
+	int i, irq = -1;
+
+	/* We have to use INTx if MSI cannot be used for PCIe PME. */
+	if ((mask & PCIE_PORT_SERVICE_PME) && pcie_pme_no_msi()) {
+		if (dev->pin)
+			irq = dev->irq;
+		goto no_msi;
+	}
 
 	/* Try to use MSI-X if supported */
 	if (!pcie_port_enable_msix(dev, irqs, mask))
 		return 0;
+
 	/* We're not going to use MSI-X, so try MSI and fall back to INTx */
-	irq = -1;
 	if (!pci_enable_msi(dev) || dev->pin)
 		irq = dev->irq;
 
+ no_msi:
 	for (i = 0; i < PCIE_PORT_DEVICE_MAXSERVICES; i++)
 		irqs[i] = irq;
 	irqs[PCIE_PORT_SERVICE_VC_SHIFT] = -1;

commit 40da4186a53e59d801130156ecb89fc5830ff227
Author: Hidetoshi Seto <seto.hidetoshi@jp.fujitsu.com>
Date:   Tue Dec 15 11:38:04 2009 +0900

    PCI: pcie portdrv: style cleanup
    
    No change in logic.
    
    Before:
      drivers/pci/pcie/portdrv_core.c:
        total: 7 errors, 2 warnings, 508 lines checked
      drivers/pci/pcie/portdrv_pci.c:
        total: 4 errors, 2 warnings, 300 lines checked
    
    After:
      drivers/pci/pcie/portdrv_core.c:
        total: 0 errors, 0 warnings, 506 lines checked
      drivers/pci/pcie/portdrv_pci.c:
        total: 0 errors, 0 warnings, 299 lines checked
    
    Signed-off-by: Hidetoshi Seto <seto.hidetoshi@jp.fujitsu.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index 413262eb95b7..b174188ac121 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -27,7 +27,7 @@
  */
 static void release_pcie_device(struct device *dev)
 {
-	kfree(to_pcie_device(dev));			
+	kfree(to_pcie_device(dev));
 }
 
 /**
@@ -346,12 +346,11 @@ static int suspend_iter(struct device *dev, void *data)
 {
 	struct pcie_port_service_driver *service_driver;
 
- 	if ((dev->bus == &pcie_port_bus_type) &&
- 	    (dev->driver)) {
- 		service_driver = to_service_driver(dev->driver);
- 		if (service_driver->suspend)
- 			service_driver->suspend(to_pcie_device(dev));
-  	}
+	if ((dev->bus == &pcie_port_bus_type) && dev->driver) {
+		service_driver = to_service_driver(dev->driver);
+		if (service_driver->suspend)
+			service_driver->suspend(to_pcie_device(dev));
+	}
 	return 0;
 }
 
@@ -494,6 +493,7 @@ int pcie_port_service_register(struct pcie_port_service_driver *new)
 
 	return driver_register(&new->driver);
 }
+EXPORT_SYMBOL(pcie_port_service_register);
 
 /**
  * pcie_port_service_unregister - unregister PCI Express port service driver
@@ -503,6 +503,4 @@ void pcie_port_service_unregister(struct pcie_port_service_driver *drv)
 {
 	driver_unregister(&drv->driver);
 }
-
-EXPORT_SYMBOL(pcie_port_service_register);
 EXPORT_SYMBOL(pcie_port_service_unregister);

commit f9f45604edcf87ac86a9d68ca54106c5fb743719
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Wed Nov 25 21:06:51 2009 +0900

    PCI: portdrv: remove redundant definitions
    
    Remove unnecessary definitions from portdrv.h and use generic
    definitions instead.
    
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index 9318b96bb255..413262eb95b7 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -109,8 +109,8 @@ static int pcie_port_enable_msix(struct pci_dev *dev, int *vectors, int mask)
 		 * used to generate the interrupt message."
 		 */
 		pos = pci_pcie_cap(dev);
-		pci_read_config_word(dev, pos + PCIE_CAPABILITIES_REG, &reg16);
-		entry = (reg16 >> 9) & PCIE_PORT_MSI_VECTOR_MASK;
+		pci_read_config_word(dev, pos + PCI_EXP_FLAGS, &reg16);
+		entry = (reg16 & PCI_EXP_FLAGS_IRQ) >> 9;
 		if (entry >= nr_entries)
 			goto Error;
 
@@ -230,12 +230,11 @@ static int get_port_device_capability(struct pci_dev *dev)
 	u32 reg32;
 
 	pos = pci_pcie_cap(dev);
-	pci_read_config_word(dev, pos + PCIE_CAPABILITIES_REG, &reg16);
+	pci_read_config_word(dev, pos + PCI_EXP_FLAGS, &reg16);
 	/* Hot-Plug Capable */
-	if (reg16 & PORT_TO_SLOT_MASK) {
-		pci_read_config_dword(dev, 
-			pos + PCIE_SLOT_CAPABILITIES_REG, &reg32);
-		if (reg32 & SLOT_HP_CAPABLE_MASK)
+	if (reg16 & PCI_EXP_FLAGS_SLOT) {
+		pci_read_config_dword(dev, pos + PCI_EXP_SLTCAP, &reg32);
+		if (reg32 & PCI_EXP_SLTCAP_HPC)
 			services |= PCIE_PORT_SERVICE_HP;
 	}
 	/* AER capable */

commit 694f88ef7ada0d99e304f687ba92e268a594358b
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Wed Nov 25 21:06:15 2009 +0900

    PCI: portdrv: remove unnecessary struct pcie_port_data
    
    Remove 'port_type' field in struct pcie_port_data(), because we can
    get port type information from struct pci_dev. With this change, this
    patch also does followings:
    
     - Remove struct pcie_port_data because it no longer has any field.
     - Remove portdrv private definitions about port type (PCIE_RC_PORT,
       PCIE_SW_UPSTREAM_PORT and PCIE_SW_DOWNSTREAM_PORT), and use generic
       definitions instead.
    
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index 758e3d339287..9318b96bb255 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -296,7 +296,6 @@ static int pcie_device_init(struct pci_dev *pdev, int service, int irq)
  */
 int pcie_port_device_register(struct pci_dev *dev)
 {
-	struct pcie_port_data *port_data;
 	int status, capabilities, i, nr_service;
 	int irqs[PCIE_PORT_DEVICE_MAXSERVICES];
 
@@ -305,17 +304,10 @@ int pcie_port_device_register(struct pci_dev *dev)
 	if (!capabilities)
 		return -ENODEV;
 
-	/* Allocate driver data for port device */
-	port_data = kzalloc(sizeof(*port_data), GFP_KERNEL);
-	if (!port_data)
-		return -ENOMEM;
-	port_data->port_type = dev->pcie_type;
-	pci_set_drvdata(dev, port_data);
-
 	/* Enable PCI Express port device */
 	status = pci_enable_device(dev);
 	if (status)
-		goto error_kfree;
+		return status;
 	pci_set_master(dev);
 	/*
 	 * Initialize service irqs. Don't use service devices that
@@ -347,8 +339,6 @@ int pcie_port_device_register(struct pci_dev *dev)
 	cleanup_service_irqs(dev);
 error_disable:
 	pci_disable_device(dev);
-error_kfree:
-	kfree(port_data);
 	return status;
 }
 
@@ -416,12 +406,9 @@ static int remove_iter(struct device *dev, void *data)
  */
 void pcie_port_device_remove(struct pci_dev *dev)
 {
-	struct pcie_port_data *port_data = pci_get_drvdata(dev);
-
 	device_for_each_child(&dev->dev, NULL, remove_iter);
 	cleanup_service_irqs(dev);
 	pci_disable_device(dev);
-	kfree(port_data);
 }
 
 /**

commit 40717c39b1e6c064f48a263a27e58642221e8661
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Wed Nov 25 21:05:35 2009 +0900

    PCI: portdrv: minor cleanup for pcie_port_device_register
    
    Minor cleanups for pcie_port_device_register().
    
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index 82a27f93d38b..758e3d339287 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -297,13 +297,15 @@ static int pcie_device_init(struct pci_dev *pdev, int service, int irq)
 int pcie_port_device_register(struct pci_dev *dev)
 {
 	struct pcie_port_data *port_data;
-	int status, capabilities, i, nr_serv;
+	int status, capabilities, i, nr_service;
 	int irqs[PCIE_PORT_DEVICE_MAXSERVICES];
 
+	/* Get and check PCI Express port services */
 	capabilities = get_port_device_capability(dev);
 	if (!capabilities)
 		return -ENODEV;
 
+	/* Allocate driver data for port device */
 	port_data = kzalloc(sizeof(*port_data), GFP_KERNEL);
 	if (!port_data)
 		return -ENOMEM;
@@ -315,7 +317,6 @@ int pcie_port_device_register(struct pci_dev *dev)
 	if (status)
 		goto error_kfree;
 	pci_set_master(dev);
-
 	/*
 	 * Initialize service irqs. Don't use service devices that
 	 * require interrupts if there is no way to generate them.
@@ -328,20 +329,18 @@ int pcie_port_device_register(struct pci_dev *dev)
 	}
 
 	/* Allocate child services if any */
-	for (i = 0, nr_serv = 0; i < PCIE_PORT_DEVICE_MAXSERVICES; i++) {
+	status = -ENODEV;
+	nr_service = 0;
+	for (i = 0; i < PCIE_PORT_DEVICE_MAXSERVICES; i++) {
 		int service = 1 << i;
-
 		if (!(capabilities & service))
 			continue;
-
-		status = pcie_device_init(dev, service, irqs[i]);
-		if (!status)
-			nr_serv++;
+		if (!pcie_device_init(dev, service, irqs[i]))
+			nr_service++;
 	}
-	if (!nr_serv) {
-		status = -ENODEV;
+	if (!nr_service)
 		goto error_cleanup_irqs;
-	}
+
 	return 0;
 
 error_cleanup_irqs:

commit fbb5de70bbe13ecbebb04226dd6d52b1258dc247
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Wed Nov 25 21:05:01 2009 +0900

    PCI: portdrv: add missing irq cleanup
    
    Add missing service irqs cleanup in the error code path of
    pcie_port_device_register().
    
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index a2ac618a95be..82a27f93d38b 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -205,6 +205,14 @@ static int init_service_irqs(struct pci_dev *dev, int *irqs, int mask)
 	return 0;
 }
 
+static void cleanup_service_irqs(struct pci_dev *dev)
+{
+	if (dev->msix_enabled)
+		pci_disable_msix(dev);
+	else if (dev->msi_enabled)
+		pci_disable_msi(dev);
+}
+
 /**
  * get_port_device_capability - discover capabilities of a PCI Express port
  * @dev: PCI Express port to examine
@@ -332,10 +340,12 @@ int pcie_port_device_register(struct pci_dev *dev)
 	}
 	if (!nr_serv) {
 		status = -ENODEV;
-		goto error_disable;
+		goto error_cleanup_irqs;
 	}
 	return 0;
 
+error_cleanup_irqs:
+	cleanup_service_irqs(dev);
 error_disable:
 	pci_disable_device(dev);
 error_kfree:
@@ -410,12 +420,7 @@ void pcie_port_device_remove(struct pci_dev *dev)
 	struct pcie_port_data *port_data = pci_get_drvdata(dev);
 
 	device_for_each_child(&dev->dev, NULL, remove_iter);
-
-	if (dev->msix_enabled)
-		pci_disable_msix(dev);
-	else if (dev->msi_enabled)
-		pci_disable_msi(dev);
-
+	cleanup_service_irqs(dev);
 	pci_disable_device(dev);
 	kfree(port_data);
 }

commit 1ce5e83063bf388a2c9fa1e3d4d3122146ad305d
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Wed Nov 25 21:04:30 2009 +0900

    PCI: portdrv: enable device before irq initialization
    
    Call pci_enable_device() before initializing service irqs, because
    legacy interrupt is initialized in pci_enable_device() on some
    architectures.
    
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index d208dc2d62fd..a2ac618a95be 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -302,6 +302,12 @@ int pcie_port_device_register(struct pci_dev *dev)
 	port_data->port_type = dev->pcie_type;
 	pci_set_drvdata(dev, port_data);
 
+	/* Enable PCI Express port device */
+	status = pci_enable_device(dev);
+	if (status)
+		goto error_kfree;
+	pci_set_master(dev);
+
 	/*
 	 * Initialize service irqs. Don't use service devices that
 	 * require interrupts if there is no way to generate them.
@@ -310,14 +316,9 @@ int pcie_port_device_register(struct pci_dev *dev)
 	if (status) {
 		capabilities &= PCIE_PORT_SERVICE_VC;
 		if (!capabilities)
-			goto Error;
+			goto error_disable;
 	}
 
-	status = pci_enable_device(dev);
-	if (status)
-		goto Error;
-	pci_set_master(dev);
-
 	/* Allocate child services if any */
 	for (i = 0, nr_serv = 0; i < PCIE_PORT_DEVICE_MAXSERVICES; i++) {
 		int service = 1 << i;
@@ -330,14 +331,14 @@ int pcie_port_device_register(struct pci_dev *dev)
 			nr_serv++;
 	}
 	if (!nr_serv) {
-		pci_disable_device(dev);
 		status = -ENODEV;
-		goto Error;
+		goto error_disable;
 	}
-
 	return 0;
 
- Error:
+error_disable:
+	pci_disable_device(dev);
+error_kfree:
 	kfree(port_data);
 	return status;
 }

commit dc5351784eb36f1fec4efa88e01581be72c0b711
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Wed Nov 25 21:04:00 2009 +0900

    PCI: portdrv: cleanup service irqs initialization
    
    This patch cleans up the service irqs initialization as follows:
    
     - Remove 'irq_mode' field in pcie_port_data and related definitions,
       which is not needed because we can get the same information from
       'is_msix', 'is_msi' and 'pin' fields in struct pci_dev.
    
     - Change the name of 'vectors' argument of assign_interrupt_mode() to
       'irqs' because it holds irq numbers actually. People might confuse
       it with CPU vector or MSI/MSI-X vector.
    
     - Change function name assign_interrupt_mode() to init_service_irqs()
       becasuse we no longer have 'irq_mode' data structure, and new name
       is more straightforward (IMO).
    
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index 52c4e6fd6fd4..d208dc2d62fd 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -177,37 +177,32 @@ static int pcie_port_enable_msix(struct pci_dev *dev, int *vectors, int mask)
 }
 
 /**
- * assign_interrupt_mode - choose interrupt mode for PCI Express port services
- *                         (INTx, MSI-X, MSI) and set up vectors
+ * init_service_irqs - initialize irqs for PCI Express port services
  * @dev: PCI Express port to handle
- * @vectors: Array of interrupt vectors to populate
+ * @irqs: Array of irqs to populate
  * @mask: Bitmask of port capabilities returned by get_port_device_capability()
  *
  * Return value: Interrupt mode associated with the port
  */
-static int assign_interrupt_mode(struct pci_dev *dev, int *vectors, int mask)
+static int init_service_irqs(struct pci_dev *dev, int *irqs, int mask)
 {
-	int irq, interrupt_mode = PCIE_PORT_NO_IRQ;
-	int i;
+	int i, irq;
 
 	/* Try to use MSI-X if supported */
-	if (!pcie_port_enable_msix(dev, vectors, mask))
-		return PCIE_PORT_MSIX_MODE;
-
+	if (!pcie_port_enable_msix(dev, irqs, mask))
+		return 0;
 	/* We're not going to use MSI-X, so try MSI and fall back to INTx */
-	if (!pci_enable_msi(dev))
-		interrupt_mode = PCIE_PORT_MSI_MODE;
+	irq = -1;
+	if (!pci_enable_msi(dev) || dev->pin)
+		irq = dev->irq;
 
-	if (interrupt_mode == PCIE_PORT_NO_IRQ && dev->pin)
-		interrupt_mode = PCIE_PORT_INTx_MODE;
-
-	irq = interrupt_mode != PCIE_PORT_NO_IRQ ? dev->irq : -1;
 	for (i = 0; i < PCIE_PORT_DEVICE_MAXSERVICES; i++)
-		vectors[i] = irq;
-
-	vectors[PCIE_PORT_SERVICE_VC_SHIFT] = -1;
+		irqs[i] = irq;
+	irqs[PCIE_PORT_SERVICE_VC_SHIFT] = -1;
 
-	return interrupt_mode;
+	if (irq < 0)
+		return -ENODEV;
+	return 0;
 }
 
 /**
@@ -294,8 +289,8 @@ static int pcie_device_init(struct pci_dev *pdev, int service, int irq)
 int pcie_port_device_register(struct pci_dev *dev)
 {
 	struct pcie_port_data *port_data;
-	int status, capabilities, irq_mode, i, nr_serv;
-	int vectors[PCIE_PORT_DEVICE_MAXSERVICES];
+	int status, capabilities, i, nr_serv;
+	int irqs[PCIE_PORT_DEVICE_MAXSERVICES];
 
 	capabilities = get_port_device_capability(dev);
 	if (!capabilities)
@@ -304,23 +299,19 @@ int pcie_port_device_register(struct pci_dev *dev)
 	port_data = kzalloc(sizeof(*port_data), GFP_KERNEL);
 	if (!port_data)
 		return -ENOMEM;
-	pci_set_drvdata(dev, port_data);
-
 	port_data->port_type = dev->pcie_type;
+	pci_set_drvdata(dev, port_data);
 
-	irq_mode = assign_interrupt_mode(dev, vectors, capabilities);
-	if (irq_mode == PCIE_PORT_NO_IRQ) {
-		/*
-		 * Don't use service devices that require interrupts if there is
-		 * no way to generate them.
-		 */
-		if (!(capabilities & PCIE_PORT_SERVICE_VC)) {
-			status = -ENODEV;
+	/*
+	 * Initialize service irqs. Don't use service devices that
+	 * require interrupts if there is no way to generate them.
+	 */
+	status = init_service_irqs(dev, irqs, capabilities);
+	if (status) {
+		capabilities &= PCIE_PORT_SERVICE_VC;
+		if (!capabilities)
 			goto Error;
-		}
-		capabilities = PCIE_PORT_SERVICE_VC;
 	}
-	port_data->port_irq_mode = irq_mode;
 
 	status = pci_enable_device(dev);
 	if (status)
@@ -334,7 +325,7 @@ int pcie_port_device_register(struct pci_dev *dev)
 		if (!(capabilities & service))
 			continue;
 
-		status = pcie_device_init(dev, service, vectors[i]);
+		status = pcie_device_init(dev, service, irqs[i]);
 		if (!status)
 			nr_serv++;
 	}
@@ -418,17 +409,13 @@ void pcie_port_device_remove(struct pci_dev *dev)
 	struct pcie_port_data *port_data = pci_get_drvdata(dev);
 
 	device_for_each_child(&dev->dev, NULL, remove_iter);
-	pci_disable_device(dev);
 
-	switch (port_data->port_irq_mode) {
-	case PCIE_PORT_MSIX_MODE:
+	if (dev->msix_enabled)
 		pci_disable_msix(dev);
-		break;
-	case PCIE_PORT_MSI_MODE:
+	else if (dev->msi_enabled)
 		pci_disable_msi(dev);
-		break;
-	}
 
+	pci_disable_device(dev);
 	kfree(port_data);
 }
 

commit d013598d9a46befebdfd37195829ce411e4878ea
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Wed Nov 25 21:03:27 2009 +0900

    PCI: portdrv: check capabilities first
    
    Move capability check capability to the beginning of
    pcie_port_device_register() prevents redundant execution path.
    
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index 079bbc3ed4f8..52c4e6fd6fd4 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -297,6 +297,10 @@ int pcie_port_device_register(struct pci_dev *dev)
 	int status, capabilities, irq_mode, i, nr_serv;
 	int vectors[PCIE_PORT_DEVICE_MAXSERVICES];
 
+	capabilities = get_port_device_capability(dev);
+	if (!capabilities)
+		return -ENODEV;
+
 	port_data = kzalloc(sizeof(*port_data), GFP_KERNEL);
 	if (!port_data)
 		return -ENOMEM;
@@ -304,8 +308,6 @@ int pcie_port_device_register(struct pci_dev *dev)
 
 	port_data->port_type = dev->pcie_type;
 
-	capabilities = get_port_device_capability(dev);
-
 	irq_mode = assign_interrupt_mode(dev, vectors, capabilities);
 	if (irq_mode == PCIE_PORT_NO_IRQ) {
 		/*

commit 9e5d0b16dada536dfe2f1e893b6ad0225ff8a2c9
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Wed Nov 25 21:02:51 2009 +0900

    PCI: portdrv: move PME capability check
    
    No reason to check PME capability outside get_port_device_capability().
    Do it in get_port_device_capability().
    
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index 42b21eec15f0..079bbc3ed4f8 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -241,6 +241,9 @@ static int get_port_device_capability(struct pci_dev *dev)
 	/* VC support */
 	if (pci_find_ext_capability(dev, PCI_EXT_CAP_ID_VC))
 		services |= PCIE_PORT_SERVICE_VC;
+	/* Root ports are capable of generating PME too */
+	if (dev->pcie_type == PCI_EXP_TYPE_ROOT_PORT)
+		services |= PCIE_PORT_SERVICE_PME;
 
 	return services;
 }
@@ -302,9 +305,6 @@ int pcie_port_device_register(struct pci_dev *dev)
 	port_data->port_type = dev->pcie_type;
 
 	capabilities = get_port_device_capability(dev);
-	/* Root ports are capable of generating PME too */
-	if (port_data->port_type == PCIE_RC_PORT)
-		capabilities |= PCIE_PORT_SERVICE_PME;
 
 	irq_mode = assign_interrupt_mode(dev, vectors, capabilities);
 	if (irq_mode == PCIE_PORT_NO_IRQ) {

commit 2dd60e96b4d52bccd2dd585e776a3449d7b34b8f
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Wed Nov 25 21:02:13 2009 +0900

    PCI: portdrv: remove redundant pcie type calculation
    
    PCIe port type is already stored in 'pcie_type' field of struct
    pci_dev. So we don't need to get it from pci configuration space.
    
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index 7ea37c075d7e..42b21eec15f0 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -291,19 +291,15 @@ static int pcie_device_init(struct pci_dev *pdev, int service, int irq)
 int pcie_port_device_register(struct pci_dev *dev)
 {
 	struct pcie_port_data *port_data;
-	int status, capabilities, irq_mode, i, nr_serv, pos;
+	int status, capabilities, irq_mode, i, nr_serv;
 	int vectors[PCIE_PORT_DEVICE_MAXSERVICES];
-	u16 reg16;
 
 	port_data = kzalloc(sizeof(*port_data), GFP_KERNEL);
 	if (!port_data)
 		return -ENOMEM;
 	pci_set_drvdata(dev, port_data);
 
-	/* Get port type */
-	pos = pci_pcie_cap(dev);
-	pci_read_config_word(dev, pos + PCIE_CAPABILITIES_REG, &reg16);
-	port_data->port_type = (reg16 >> 4) & PORT_TYPE_MASK;
+	port_data->port_type = dev->pcie_type;
 
 	capabilities = get_port_device_capability(dev);
 	/* Root ports are capable of generating PME too */

commit 52a0f24beabe9e89223e367c65a0156dff17265c
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Wed Nov 25 21:01:28 2009 +0900

    PCI: portdrv: cleanup pcie_device registration
    
    In the current port bus driver implementation, pcie_device allocation,
    initialization and registration are done in separated functions. Doing
    those in one function make the code simple and easier to read.
    
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index a0376f80bc5e..7ea37c075d7e 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -246,54 +246,39 @@ static int get_port_device_capability(struct pci_dev *dev)
 }
 
 /**
- * pcie_device_init - initialize PCI Express port service device
- * @dev: Port service device to initialize
- * @parent: PCI Express port to associate the service device with
- * @port_type: Type of the port
- * @service_type: Type of service to associate with the service device
+ * pcie_device_init - allocate and initialize PCI Express port service device
+ * @pdev: PCI Express port to associate the service device with
+ * @service: Type of service to associate with the service device
  * @irq: Interrupt vector to associate with the service device
  */
-static void pcie_device_init(struct pci_dev *parent, struct pcie_device *dev, 
-	int service_type, int irq)
+static int pcie_device_init(struct pci_dev *pdev, int service, int irq)
 {
-	struct pcie_port_data *port_data = pci_get_drvdata(parent);
+	int retval;
+	struct pcie_device *pcie;
 	struct device *device;
-	int port_type = port_data->port_type;
 
-	dev->port = parent;
-	dev->irq = irq;
-	dev->service = service_type;
+	pcie = kzalloc(sizeof(*pcie), GFP_KERNEL);
+	if (!pcie)
+		return -ENOMEM;
+	pcie->port = pdev;
+	pcie->irq = irq;
+	pcie->service = service;
 
 	/* Initialize generic device interface */
-	device = &dev->device;
-	memset(device, 0, sizeof(struct device));
+	device = &pcie->device;
 	device->bus = &pcie_port_bus_type;
-	device->driver = NULL;
-	dev_set_drvdata(device, NULL);
 	device->release = release_pcie_device;	/* callback to free pcie dev */
 	dev_set_name(device, "%s:pcie%02x",
-		 pci_name(parent), get_descriptor_id(port_type, service_type));
-	device->parent = &parent->dev;
-}
-
-/**
- * alloc_pcie_device - allocate PCI Express port service device structure
- * @parent: PCI Express port to associate the service device with
- * @port_type: Type of the port
- * @service_type: Type of service to associate with the service device
- * @irq: Interrupt vector to associate with the service device
- */
-static struct pcie_device* alloc_pcie_device(struct pci_dev *parent,
-	int service_type, int irq)
-{
-	struct pcie_device *device;
-
-	device = kzalloc(sizeof(struct pcie_device), GFP_KERNEL);
-	if (!device)
-		return NULL;
-
-	pcie_device_init(parent, device, service_type, irq);
-	return device;
+		     pci_name(pdev),
+		     get_descriptor_id(pdev->pcie_type, service));
+	device->parent = &pdev->dev;
+
+	retval = device_register(device);
+	if (retval)
+		kfree(pcie);
+	else
+		get_device(device);
+	return retval;
 }
 
 /**
@@ -346,24 +331,14 @@ int pcie_port_device_register(struct pci_dev *dev)
 
 	/* Allocate child services if any */
 	for (i = 0, nr_serv = 0; i < PCIE_PORT_DEVICE_MAXSERVICES; i++) {
-		struct pcie_device *child;
 		int service = 1 << i;
 
 		if (!(capabilities & service))
 			continue;
 
-		child = alloc_pcie_device(dev, service, vectors[i]);
-		if (!child)
-			continue;
-
-		status = device_register(&child->device);
-		if (status) {
-			kfree(child);
-			continue;
-		}
-
-		get_device(&child->device);
-		nr_serv++;
+		status = pcie_device_init(dev, service, vectors[i]);
+		if (!status)
+			nr_serv++;
 	}
 	if (!nr_serv) {
 		pci_disable_device(dev);

commit 898294c97500b1cdff6edce52fd34e024eb070ec
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Wed Nov 25 21:00:53 2009 +0900

    PCI: portdrv: remove redundant pcie_port_device_probe
    
    We don't need pcie_port_device_probe() because we can get pci
    device/port type using pci_is_pcie() and 'pcie_type' fields in struct
    pci_dev. Remove pcie_port_device_probe().
    
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index ce99c7121372..a0376f80bc5e 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -296,28 +296,6 @@ static struct pcie_device* alloc_pcie_device(struct pci_dev *parent,
 	return device;
 }
 
-/**
- * pcie_port_device_probe - check if device is a PCI Express port
- * @dev: Device to check
- */
-int pcie_port_device_probe(struct pci_dev *dev)
-{
-	int pos, type;
-	u16 reg;
-
-	pos = pci_pcie_cap(dev);
-	if (!pos)
-		return -ENODEV;
-
-	pci_read_config_word(dev, pos + PCIE_CAPABILITIES_REG, &reg);
-	type = (reg >> 4) & PORT_TYPE_MASK;
-	if (	type == PCIE_RC_PORT || type == PCIE_SW_UPSTREAM_PORT ||
-		type == PCIE_SW_DOWNSTREAM_PORT )
-		return 0;
-
-	return -ENODEV;
-}
-
 /**
  * pcie_port_device_register - register PCI Express port
  * @dev: PCI Express port to register

commit dba90dfe48e2e00e79a15c95940730b6926ee176
Author: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
Date:   Wed Nov 11 14:32:42 2009 +0900

    PCIe port bus: use pci_pcie_cap()
    
    Use pci_pcie_cap() instead of pci_find_capability() to get PCIe capability
    offset in PCI Express Port Bus driver. This avoids unnecessary serarch
    in PCI configuration space.
    
    Signed-off-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index 52f84fca9f7d..ce99c7121372 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -108,7 +108,7 @@ static int pcie_port_enable_msix(struct pci_dev *dev, int *vectors, int mask)
 		 * the value in this field indicates which MSI-X Table entry is
 		 * used to generate the interrupt message."
 		 */
-		pos = pci_find_capability(dev, PCI_CAP_ID_EXP);
+		pos = pci_pcie_cap(dev);
 		pci_read_config_word(dev, pos + PCIE_CAPABILITIES_REG, &reg16);
 		entry = (reg16 >> 9) & PCIE_PORT_MSI_VECTOR_MASK;
 		if (entry >= nr_entries)
@@ -226,7 +226,7 @@ static int get_port_device_capability(struct pci_dev *dev)
 	u16 reg16;
 	u32 reg32;
 
-	pos = pci_find_capability(dev, PCI_CAP_ID_EXP);
+	pos = pci_pcie_cap(dev);
 	pci_read_config_word(dev, pos + PCIE_CAPABILITIES_REG, &reg16);
 	/* Hot-Plug Capable */
 	if (reg16 & PORT_TO_SLOT_MASK) {
@@ -305,7 +305,8 @@ int pcie_port_device_probe(struct pci_dev *dev)
 	int pos, type;
 	u16 reg;
 
-	if (!(pos = pci_find_capability(dev, PCI_CAP_ID_EXP)))
+	pos = pci_pcie_cap(dev);
+	if (!pos)
 		return -ENODEV;
 
 	pci_read_config_word(dev, pos + PCIE_CAPABILITIES_REG, &reg);
@@ -327,7 +328,7 @@ int pcie_port_device_probe(struct pci_dev *dev)
 int pcie_port_device_register(struct pci_dev *dev)
 {
 	struct pcie_port_data *port_data;
-	int status, capabilities, irq_mode, i, nr_serv;
+	int status, capabilities, irq_mode, i, nr_serv, pos;
 	int vectors[PCIE_PORT_DEVICE_MAXSERVICES];
 	u16 reg16;
 
@@ -337,9 +338,8 @@ int pcie_port_device_register(struct pci_dev *dev)
 	pci_set_drvdata(dev, port_data);
 
 	/* Get port type */
-	pci_read_config_word(dev,
-		pci_find_capability(dev, PCI_CAP_ID_EXP) +
-		PCIE_CAPABILITIES_REG, &reg16);
+	pos = pci_pcie_cap(dev);
+	pci_read_config_word(dev, pos + PCIE_CAPABILITIES_REG, &reg16);
 	port_data->port_type = (reg16 >> 4) & PORT_TYPE_MASK;
 
 	capabilities = get_port_device_capability(dev);

commit 9965976a38f66fc170fc0528b3115bf1a8a58b0a
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Fri Sep 11 08:46:07 2009 -0700

    PCI: pcie portdrv: remove unused variable
    
    Remove unused port_data variable left over from the MCH hotplug quirk
    cleanup.
    
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index af9bca3139e7..52f84fca9f7d 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -187,7 +187,6 @@ static int pcie_port_enable_msix(struct pci_dev *dev, int *vectors, int mask)
  */
 static int assign_interrupt_mode(struct pci_dev *dev, int *vectors, int mask)
 {
-	struct pcie_port_data *port_data = pci_get_drvdata(dev);
 	int irq, interrupt_mode = PCIE_PORT_NO_IRQ;
 	int i;
 

commit 0ba379ec0fb182a87b8891c5754abbcd9c035b4f
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Sun Sep 6 21:48:35 2009 -0700

    PCI: Simplify hotplug mch quirk.
    
    There is a very old quirk for the intel E7502 E7320 and E7525 memory
    controller hubs that disables usage of msi interrupts on pcie hotplug
    bridges of those devices, and disables changing the affinity of irqs.
    
    Today all we have to do to disable msi on a specific device is to set
    dev->no_msi, which is much more straightforward than the previous
    logic.
    
    The re-running of this fixup after pci hotplug happens below these
    devices is totally bogus.  All of the state we change is pure software
    state and we don't change the hardware at all.  Which means hotplug on
    the lower devices doesn't have a chance to change this state.  So we
    can safely remove the special case from the pciehp driver and the pcie
    portdriver.
    
    I suspect the special case was someone's expermental debug code that
    slipped in. Certainly it isn't mentioned in commit
    6fb8880a61510295aece04a542767161f624dffe aka BKrev:
    41966101LJ_ogfOU0m2aE6teZfQnuQ where the code first appears.
    
    Reviewed-by: Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com>
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index 13ffdc35ea0e..af9bca3139e7 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -191,10 +191,6 @@ static int assign_interrupt_mode(struct pci_dev *dev, int *vectors, int mask)
 	int irq, interrupt_mode = PCIE_PORT_NO_IRQ;
 	int i;
 
-	/* Check MSI quirk */
-	if (port_data->port_type == PCIE_RC_PORT && pcie_mch_quirk)
-		goto Fallback;
-
 	/* Try to use MSI-X if supported */
 	if (!pcie_port_enable_msix(dev, vectors, mask))
 		return PCIE_PORT_MSIX_MODE;
@@ -203,7 +199,6 @@ static int assign_interrupt_mode(struct pci_dev *dev, int *vectors, int mask)
 	if (!pci_enable_msi(dev))
 		interrupt_mode = PCIE_PORT_MSI_MODE;
 
- Fallback:
 	if (interrupt_mode == PCIE_PORT_NO_IRQ && dev->pin)
 		interrupt_mode = PCIE_PORT_INTx_MODE;
 

commit 8952f593ea66bff4a30f9e641dc6c79832ca64cf
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Apr 30 14:43:31 2009 -0700

    PCIE: remove driver_data direct access of struct device
    
    In the near future, the driver core is going to not allow direct access
    to the driver_data pointer in struct device.  Instead, the functions
    dev_get_drvdata() and dev_set_drvdata() should be used.  These functions
    have been around since the beginning, so are backwards compatible with
    all older kernel versions.
    
    
    Cc: linux-pci@vger.kernel.org
    Cc: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index e39982503863..13ffdc35ea0e 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -275,7 +275,7 @@ static void pcie_device_init(struct pci_dev *parent, struct pcie_device *dev,
 	memset(device, 0, sizeof(struct device));
 	device->bus = &pcie_port_bus_type;
 	device->driver = NULL;
-	device->driver_data = NULL;
+	dev_set_drvdata(device, NULL);
 	device->release = release_pcie_device;	/* callback to free pcie dev */
 	dev_set_name(device, "%s:pcie%02x",
 		 pci_name(parent), get_descriptor_id(port_type, service_type));

commit 745be2e700cdddd5da4e402854a484242c3628df
Author: Alex Chiang <achiang@hp.com>
Date:   Sat Mar 7 21:46:49 2009 -0700

    PCIe: portdrv: call pci_disable_device during remove
    
    The PCIe port driver calls pci_enable_device when registering
    ports, but never calls pci_disable_device during removal.
    
    Acked-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Alex Chiang <achiang@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index 5a5bfe7cdf5f..e39982503863 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -473,6 +473,7 @@ void pcie_port_device_remove(struct pci_dev *dev)
 	struct pcie_port_data *port_data = pci_get_drvdata(dev);
 
 	device_for_each_child(&dev->dev, NULL, remove_iter);
+	pci_disable_device(dev);
 
 	switch (port_data->port_irq_mode) {
 	case PCIE_PORT_MSIX_MODE:

commit 3a3c244c9a355105bc193fde873c73727bf87192
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Feb 15 22:32:48 2009 +0100

    PCI: PCIe portdrv: Implement pm object
    
    Implement pm object for the PCI Express port driver in order to use
    the new power management framework and reduce the code size.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index 569af0015fce..5a5bfe7cdf5f 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -410,13 +410,12 @@ int pcie_port_device_register(struct pci_dev *dev)
 static int suspend_iter(struct device *dev, void *data)
 {
 	struct pcie_port_service_driver *service_driver;
-	pm_message_t state = * (pm_message_t *) data;
 
  	if ((dev->bus == &pcie_port_bus_type) &&
  	    (dev->driver)) {
  		service_driver = to_service_driver(dev->driver);
  		if (service_driver->suspend)
- 			service_driver->suspend(to_pcie_device(dev), state);
+ 			service_driver->suspend(to_pcie_device(dev));
   	}
 	return 0;
 }
@@ -424,11 +423,10 @@ static int suspend_iter(struct device *dev, void *data)
 /**
  * pcie_port_device_suspend - suspend port services associated with a PCIe port
  * @dev: PCI Express port to handle
- * @state: Representation of system power management transition in progress
  */
-int pcie_port_device_suspend(struct pci_dev *dev, pm_message_t state)
+int pcie_port_device_suspend(struct device *dev)
 {
-	return device_for_each_child(&dev->dev, &state, suspend_iter);
+	return device_for_each_child(dev, NULL, suspend_iter);
 }
 
 static int resume_iter(struct device *dev, void *data)
@@ -448,11 +446,11 @@ static int resume_iter(struct device *dev, void *data)
  * pcie_port_device_suspend - resume port services associated with a PCIe port
  * @dev: PCI Express port to handle
  */
-int pcie_port_device_resume(struct pci_dev *dev)
+int pcie_port_device_resume(struct device *dev)
 {
-	return device_for_each_child(&dev->dev, NULL, resume_iter);
+	return device_for_each_child(dev, NULL, resume_iter);
 }
-#endif
+#endif /* PM */
 
 static int remove_iter(struct device *dev, void *data)
 {

commit ae40582e9959cdb7bfe4b918be8e3d19f9511798
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Fri Feb 20 20:16:07 2009 -0800

    PCI: pcie_portdriver: fix pcie_port_device_remove
    
    pcie_port_device_remove currently calls the remove method of port
    drivers twice.  Ouch!
    
    We are calling device_for_each_child multiple times for no apparent
    reason.
    
    So make it simple. Place put_device and device_unregister into
    remove_iter, and throw out the rest.  Only call device_for_each_child
    once.
    
    The code is simpler and actually works!
    
    Signed-off-by: Eric W. Biederman <ebiederm@aristanetworks.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index 3aea92a92928..569af0015fce 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -456,16 +456,9 @@ int pcie_port_device_resume(struct pci_dev *dev)
 
 static int remove_iter(struct device *dev, void *data)
 {
-	struct pcie_port_service_driver *service_driver;
-
 	if (dev->bus == &pcie_port_bus_type) {
-		if (dev->driver) {
-			service_driver = to_service_driver(dev->driver);
-			if (service_driver->remove)
-				service_driver->remove(to_pcie_device(dev));
-		}
-		*(unsigned long*)data = (unsigned long)dev;
-		return 1;
+		put_device(dev);
+		device_unregister(dev);
 	}
 	return 0;
 }
@@ -480,18 +473,8 @@ static int remove_iter(struct device *dev, void *data)
 void pcie_port_device_remove(struct pci_dev *dev)
 {
 	struct pcie_port_data *port_data = pci_get_drvdata(dev);
-	int status;
-
-	do {
-		unsigned long device_addr;
 
-		status = device_for_each_child(&dev->dev, &device_addr, remove_iter);
-		if (status) {
-			struct device *device = (struct device*)device_addr;
-			put_device(device);
-			device_unregister(device);
-		}
-	} while (status);
+	device_for_each_child(&dev->dev, NULL, remove_iter);
 
 	switch (port_data->port_irq_mode) {
 	case PCIE_PORT_MSIX_MODE:

commit b43d451385ef833e0696032aac2629da04d46c59
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sat Jan 24 00:23:22 2009 +0100

    PCI/PCIe portdrv: Fix allocation of interrupts
    
    If MSI-X interrupt mode is used by the PCI Express port driver, too
    many vectors are allocated and it is not ensured that the right
    vectors will be used for the right services.  Namely, the PCI Express
    specification states that both PCI Express native PME and PCI Express
    hotplug will always use the same MSI or MSI-X message for signalling
    interrupts, which implies that the same vector will be used by both
    of them.  Also, the VC service does not use interrupts at all.
    Moreover, is not clear which of the vectors allocated by
    pci_enable_msix() in the current code will be used for PME and
    hotplug and which of them will be used for AER if all of these
    services are configured.
    
    For these reasons, rework the allocation of interrupts for PCI
    Express ports so that if MSI-X are enabled, the right vectors will be
    used for the right purposes.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Reviewed-by: Hidetoshi Seto <seto.hidetoshi@jp.fujitsu.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index 843d9e30dd3b..3aea92a92928 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -30,6 +30,152 @@ static void release_pcie_device(struct device *dev)
 	kfree(to_pcie_device(dev));			
 }
 
+/**
+ * pcie_port_msix_add_entry - add entry to given array of MSI-X entries
+ * @entries: Array of MSI-X entries
+ * @new_entry: Index of the entry to add to the array
+ * @nr_entries: Number of entries aleady in the array
+ *
+ * Return value: Position of the added entry in the array
+ */
+static int pcie_port_msix_add_entry(
+	struct msix_entry *entries, int new_entry, int nr_entries)
+{
+	int j;
+
+	for (j = 0; j < nr_entries; j++)
+		if (entries[j].entry == new_entry)
+			return j;
+
+	entries[j].entry = new_entry;
+	return j;
+}
+
+/**
+ * pcie_port_enable_msix - try to set up MSI-X as interrupt mode for given port
+ * @dev: PCI Express port to handle
+ * @vectors: Array of interrupt vectors to populate
+ * @mask: Bitmask of port capabilities returned by get_port_device_capability()
+ *
+ * Return value: 0 on success, error code on failure
+ */
+static int pcie_port_enable_msix(struct pci_dev *dev, int *vectors, int mask)
+{
+	struct msix_entry *msix_entries;
+	int idx[PCIE_PORT_DEVICE_MAXSERVICES];
+	int nr_entries, status, pos, i, nvec;
+	u16 reg16;
+	u32 reg32;
+
+	nr_entries = pci_msix_table_size(dev);
+	if (!nr_entries)
+		return -EINVAL;
+	if (nr_entries > PCIE_PORT_MAX_MSIX_ENTRIES)
+		nr_entries = PCIE_PORT_MAX_MSIX_ENTRIES;
+
+	msix_entries = kzalloc(sizeof(*msix_entries) * nr_entries, GFP_KERNEL);
+	if (!msix_entries)
+		return -ENOMEM;
+
+	/*
+	 * Allocate as many entries as the port wants, so that we can check
+	 * which of them will be useful.  Moreover, if nr_entries is correctly
+	 * equal to the number of entries this port actually uses, we'll happily
+	 * go through without any tricks.
+	 */
+	for (i = 0; i < nr_entries; i++)
+		msix_entries[i].entry = i;
+
+	status = pci_enable_msix(dev, msix_entries, nr_entries);
+	if (status)
+		goto Exit;
+
+	for (i = 0; i < PCIE_PORT_DEVICE_MAXSERVICES; i++)
+		idx[i] = -1;
+	status = -EIO;
+	nvec = 0;
+
+	if (mask & (PCIE_PORT_SERVICE_PME | PCIE_PORT_SERVICE_HP)) {
+		int entry;
+
+		/*
+		 * The code below follows the PCI Express Base Specification 2.0
+		 * stating in Section 6.1.6 that "PME and Hot-Plug Event
+		 * interrupts (when both are implemented) always share the same
+		 * MSI or MSI-X vector, as indicated by the Interrupt Message
+		 * Number field in the PCI Express Capabilities register", where
+		 * according to Section 7.8.2 of the specification "For MSI-X,
+		 * the value in this field indicates which MSI-X Table entry is
+		 * used to generate the interrupt message."
+		 */
+		pos = pci_find_capability(dev, PCI_CAP_ID_EXP);
+		pci_read_config_word(dev, pos + PCIE_CAPABILITIES_REG, &reg16);
+		entry = (reg16 >> 9) & PCIE_PORT_MSI_VECTOR_MASK;
+		if (entry >= nr_entries)
+			goto Error;
+
+		i = pcie_port_msix_add_entry(msix_entries, entry, nvec);
+		if (i == nvec)
+			nvec++;
+
+		idx[PCIE_PORT_SERVICE_PME_SHIFT] = i;
+		idx[PCIE_PORT_SERVICE_HP_SHIFT] = i;
+	}
+
+	if (mask & PCIE_PORT_SERVICE_AER) {
+		int entry;
+
+		/*
+		 * The code below follows Section 7.10.10 of the PCI Express
+		 * Base Specification 2.0 stating that bits 31-27 of the Root
+		 * Error Status Register contain a value indicating which of the
+		 * MSI/MSI-X vectors assigned to the port is going to be used
+		 * for AER, where "For MSI-X, the value in this register
+		 * indicates which MSI-X Table entry is used to generate the
+		 * interrupt message."
+		 */
+		pos = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ERR);
+		pci_read_config_dword(dev, pos + PCI_ERR_ROOT_STATUS, &reg32);
+		entry = reg32 >> 27;
+		if (entry >= nr_entries)
+			goto Error;
+
+		i = pcie_port_msix_add_entry(msix_entries, entry, nvec);
+		if (i == nvec)
+			nvec++;
+
+		idx[PCIE_PORT_SERVICE_AER_SHIFT] = i;
+	}
+
+	/*
+	 * If nvec is equal to the allocated number of entries, we can just use
+	 * what we have.  Otherwise, the port has some extra entries not for the
+	 * services we know and we need to work around that.
+	 */
+	if (nvec == nr_entries) {
+		status = 0;
+	} else {
+		/* Drop the temporary MSI-X setup */
+		pci_disable_msix(dev);
+
+		/* Now allocate the MSI-X vectors for real */
+		status = pci_enable_msix(dev, msix_entries, nvec);
+		if (status)
+			goto Exit;
+	}
+
+	for (i = 0; i < PCIE_PORT_DEVICE_MAXSERVICES; i++)
+		vectors[i] = idx[i] >= 0 ? msix_entries[idx[i]].vector : -1;
+
+ Exit:
+	kfree(msix_entries);
+	return status;
+
+ Error:
+	pci_disable_msix(dev);
+	goto Exit;
+}
+
 /**
  * assign_interrupt_mode - choose interrupt mode for PCI Express port services
  *                         (INTx, MSI-X, MSI) and set up vectors
@@ -42,49 +188,31 @@ static void release_pcie_device(struct device *dev)
 static int assign_interrupt_mode(struct pci_dev *dev, int *vectors, int mask)
 {
 	struct pcie_port_data *port_data = pci_get_drvdata(dev);
-	int i, pos, nvec, status = -EINVAL;
-	int interrupt_mode = PCIE_PORT_NO_IRQ;
-
-	/* Set INTx as default */
-	for (i = 0, nvec = 0; i < PCIE_PORT_DEVICE_MAXSERVICES; i++) {
-		if (mask & (1 << i)) 
-			nvec++;
-		vectors[i] = dev->irq;
-	}
-	if (dev->pin)
-		interrupt_mode = PCIE_PORT_INTx_MODE;
+	int irq, interrupt_mode = PCIE_PORT_NO_IRQ;
+	int i;
 
 	/* Check MSI quirk */
 	if (port_data->port_type == PCIE_RC_PORT && pcie_mch_quirk)
-		return interrupt_mode;
+		goto Fallback;
+
+	/* Try to use MSI-X if supported */
+	if (!pcie_port_enable_msix(dev, vectors, mask))
+		return PCIE_PORT_MSIX_MODE;
+
+	/* We're not going to use MSI-X, so try MSI and fall back to INTx */
+	if (!pci_enable_msi(dev))
+		interrupt_mode = PCIE_PORT_MSI_MODE;
+
+ Fallback:
+	if (interrupt_mode == PCIE_PORT_NO_IRQ && dev->pin)
+		interrupt_mode = PCIE_PORT_INTx_MODE;
+
+	irq = interrupt_mode != PCIE_PORT_NO_IRQ ? dev->irq : -1;
+	for (i = 0; i < PCIE_PORT_DEVICE_MAXSERVICES; i++)
+		vectors[i] = irq;
+
+	vectors[PCIE_PORT_SERVICE_VC_SHIFT] = -1;
 
-	/* Select MSI-X over MSI if supported */		
-	pos = pci_find_capability(dev, PCI_CAP_ID_MSIX);
-	if (pos) {
-		struct msix_entry msix_entries[PCIE_PORT_DEVICE_MAXSERVICES] = 
-			{{0, 0}, {0, 1}, {0, 2}, {0, 3}};
-		status = pci_enable_msix(dev, msix_entries, nvec);
-		if (!status) {
-			int j = 0;
-
-			interrupt_mode = PCIE_PORT_MSIX_MODE;
-			for (i = 0; i < PCIE_PORT_DEVICE_MAXSERVICES; i++) {
-				if (mask & (1 << i)) 
-					vectors[i] = msix_entries[j++].vector;
-			}
-		}
-	} 
-	if (status) {
-		pos = pci_find_capability(dev, PCI_CAP_ID_MSI);
-		if (pos) {
-			status = pci_enable_msi(dev);
-			if (!status) {
-				interrupt_mode = PCIE_PORT_MSI_MODE;
-				for (i = 0;i < PCIE_PORT_DEVICE_MAXSERVICES;i++)
-					vectors[i] = dev->irq;
-			}
-		}
-	} 
 	return interrupt_mode;
 }
 

commit 22106368c999246c414610dcaacd485e741605b1
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Jan 13 14:46:46 2009 +0100

    PCI: PCIe portdrv: Remove struct pcie_port_service_id
    
    The PCI Express port driver uses 'struct pcie_port_service_id' for
    matching port service devices and drivers, but this structure
    contains fields that duplicate information from the port device
    itself (vendor, device, subvendor, subdevice) and fields that are not
    used by any existing port service driver (class, class_mask,
    drvier_data).  Also, both existing port service drivers (AER and
    PCIe HP) don't even use the vendor and device fields for device
    matching.  Therefore 'struct pcie_port_service_id' can be removed
    altogether and the only useful members of it (port_type, service) can
    be introduced directly into the port service device and port service
    driver structures.  That simplifies the code quite a bit and reduces
    its size.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index 682524b0c93a..843d9e30dd3b 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -140,10 +140,7 @@ static void pcie_device_init(struct pci_dev *parent, struct pcie_device *dev,
 
 	dev->port = parent;
 	dev->irq = irq;
-	dev->id.vendor = parent->vendor;
-	dev->id.device = parent->device;
-	dev->id.port_type = port_type;
-	dev->id.service_type = service_type;
+	dev->service = service_type;
 
 	/* Initialize generic device interface */
 	device = &dev->device;

commit 0516c8bcd25293f438573101c439ce25a18916ad
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Jan 13 14:44:19 2009 +0100

    PCI: PCIe portdrv: Simplily probe callback of service drivers
    
    The second argument of the ->probe() callback in
    struct pcie_port_service_driver is unnecessary and never used.
    Remove it.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index 91ecbc43155f..682524b0c93a 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -402,7 +402,7 @@ static int pcie_port_probe_service(struct device *dev)
 		return -ENODEV;
 
 	pciedev = to_pcie_device(dev);
-	status = driver->probe(pciedev, driver->id_table);
+	status = driver->probe(pciedev);
 	if (!status) {
 		dev_printk(KERN_DEBUG, dev, "service driver %s loaded\n",
 			driver->name);

commit f118c0c3cff4fed39bde1863f9d59850719645cc
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Jan 13 14:42:01 2009 +0100

    PCI: PCIe portdrv: Do not enable port device before setting up interrupts
    
    The PCI Express port driver calls pci_enable_device() before setting
    up interrupts, which is wrong, because if there is an interrupt pin
    configured for the port, pci_enable_device() will likely set up an
    interrupt link for it.  However, this shouldn't be done if either
    MSI or MSI-X interrupt mode is chosen for the port.
    
    The solution is to call pci_enable_device() after setting up
    interrupts, because in that case the interrupt link won't be set up
    if MSI or MSI-X are enabled.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index 265eba033a4a..91ecbc43155f 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -208,7 +208,7 @@ int pcie_port_device_probe(struct pci_dev *dev)
 int pcie_port_device_register(struct pci_dev *dev)
 {
 	struct pcie_port_data *port_data;
-	int status, capabilities, irq_mode, i;
+	int status, capabilities, irq_mode, i, nr_serv;
 	int vectors[PCIE_PORT_DEVICE_MAXSERVICES];
 	u16 reg16;
 
@@ -229,24 +229,32 @@ int pcie_port_device_register(struct pci_dev *dev)
 		capabilities |= PCIE_PORT_SERVICE_PME;
 
 	irq_mode = assign_interrupt_mode(dev, vectors, capabilities);
+	if (irq_mode == PCIE_PORT_NO_IRQ) {
+		/*
+		 * Don't use service devices that require interrupts if there is
+		 * no way to generate them.
+		 */
+		if (!(capabilities & PCIE_PORT_SERVICE_VC)) {
+			status = -ENODEV;
+			goto Error;
+		}
+		capabilities = PCIE_PORT_SERVICE_VC;
+	}
 	port_data->port_irq_mode = irq_mode;
 
+	status = pci_enable_device(dev);
+	if (status)
+		goto Error;
+	pci_set_master(dev);
+
 	/* Allocate child services if any */
-	for (i = 0; i < PCIE_PORT_DEVICE_MAXSERVICES; i++) {
+	for (i = 0, nr_serv = 0; i < PCIE_PORT_DEVICE_MAXSERVICES; i++) {
 		struct pcie_device *child;
 		int service = 1 << i;
 
 		if (!(capabilities & service))
 			continue;
 
-		/*
-		 * Don't use service devices that require interrupts if there is
-		 * no way to generate them.
-		 */
-		if (irq_mode == PCIE_PORT_NO_IRQ
-		    && service != PCIE_PORT_SERVICE_VC)
-			continue;
-
 		child = alloc_pcie_device(dev, service, vectors[i]);
 		if (!child)
 			continue;
@@ -258,9 +266,19 @@ int pcie_port_device_register(struct pci_dev *dev)
 		}
 
 		get_device(&child->device);
+		nr_serv++;
+	}
+	if (!nr_serv) {
+		pci_disable_device(dev);
+		status = -ENODEV;
+		goto Error;
 	}
 
 	return 0;
+
+ Error:
+	kfree(port_data);
+	return status;
 }
 
 #ifdef CONFIG_PM

commit 90e9cd50f7feeddc911325c8a8c1b7e1fccc6599
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Jan 13 14:39:39 2009 +0100

    PCI: PCIe portdrv: Aviod using service devices with wrong interrupts
    
    The PCI Express port driver should not attempt to register service
    devices that require the ability to generate interrupts if generating
    interrupts is not possible.  Namely, if the port has no interrupt pin
    configured and we cannot set up MSI or MSI-X for it, there is no way
    it can generate interrupts and in such a case the port services that
    rely on interrupts (PME, PCIe HP, AER) should not be enabled for it.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index 273e97619bce..265eba033a4a 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -43,7 +43,7 @@ static int assign_interrupt_mode(struct pci_dev *dev, int *vectors, int mask)
 {
 	struct pcie_port_data *port_data = pci_get_drvdata(dev);
 	int i, pos, nvec, status = -EINVAL;
-	int interrupt_mode = PCIE_PORT_INTx_MODE;
+	int interrupt_mode = PCIE_PORT_NO_IRQ;
 
 	/* Set INTx as default */
 	for (i = 0, nvec = 0; i < PCIE_PORT_DEVICE_MAXSERVICES; i++) {
@@ -51,7 +51,9 @@ static int assign_interrupt_mode(struct pci_dev *dev, int *vectors, int mask)
 			nvec++;
 		vectors[i] = dev->irq;
 	}
-	
+	if (dev->pin)
+		interrupt_mode = PCIE_PORT_INTx_MODE;
+
 	/* Check MSI quirk */
 	if (port_data->port_type == PCIE_RC_PORT && pcie_mch_quirk)
 		return interrupt_mode;
@@ -141,7 +143,7 @@ static void pcie_device_init(struct pci_dev *parent, struct pcie_device *dev,
 	dev->id.vendor = parent->vendor;
 	dev->id.device = parent->device;
 	dev->id.port_type = port_type;
-	dev->id.service_type = (1 << service_type);
+	dev->id.service_type = service_type;
 
 	/* Initialize generic device interface */
 	device = &dev->device;
@@ -232,19 +234,32 @@ int pcie_port_device_register(struct pci_dev *dev)
 	/* Allocate child services if any */
 	for (i = 0; i < PCIE_PORT_DEVICE_MAXSERVICES; i++) {
 		struct pcie_device *child;
+		int service = 1 << i;
 
-		if (capabilities & (1 << i)) {
-			child = alloc_pcie_device(dev, i, vectors[i]);
-			if (child) {
-				status = device_register(&child->device);
-				if (status) {
-					kfree(child);
-					continue;
-				}
-				get_device(&child->device);
-			}
+		if (!(capabilities & service))
+			continue;
+
+		/*
+		 * Don't use service devices that require interrupts if there is
+		 * no way to generate them.
+		 */
+		if (irq_mode == PCIE_PORT_NO_IRQ
+		    && service != PCIE_PORT_SERVICE_VC)
+			continue;
+
+		child = alloc_pcie_device(dev, service, vectors[i]);
+		if (!child)
+			continue;
+
+		status = device_register(&child->device);
+		if (status) {
+			kfree(child);
+			continue;
 		}
+
+		get_device(&child->device);
 	}
+
 	return 0;
 }
 

commit 1bf83e558cb29d163f4bc6decbc3800ecf4db195
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Jan 13 14:38:34 2009 +0100

    PCI: PCIe portdrv: Use driver data to simplify code
    
    PCI Express port driver extension, as defined by struct
    pcie_port_device_ext in portdrv.h, is allocated and initialized, but
    never used (it also is never freed).  Extend it to hold the PCI Express
    port type as well as the port interrupt mode, change its name and use it
    to simplify the code in portdrv_core.c .
    
    Additionally, remove the redundant interrupt_mode member of struct
    pcie_device defined in include/linux/pcieport_if.h .
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index 8b3f8c18032f..273e97619bce 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -15,10 +15,9 @@
 #include <linux/slab.h>
 #include <linux/pcieport_if.h>
 
+#include "../pci.h"
 #include "portdrv.h"
 
-extern int pcie_mch_quirk;	/* MSI-quirk Indicator */
-
 /**
  * release_pcie_device - free PCI Express port service device structure
  * @dev: Port service device to release
@@ -31,28 +30,6 @@ static void release_pcie_device(struct device *dev)
 	kfree(to_pcie_device(dev));			
 }
 
-static int is_msi_quirked(struct pci_dev *dev)
-{
-	int port_type, quirk = 0;
-	u16 reg16;
-
-	pci_read_config_word(dev, 
-		pci_find_capability(dev, PCI_CAP_ID_EXP) + 
-		PCIE_CAPABILITIES_REG, &reg16);
-	port_type = (reg16 >> 4) & PORT_TYPE_MASK;
-	switch(port_type) {
-	case PCIE_RC_PORT:
-		if (pcie_mch_quirk == 1)
-			quirk = 1;
-		break;
-	case PCIE_SW_UPSTREAM_PORT:
-	case PCIE_SW_DOWNSTREAM_PORT:
-	default:
-		break;	
-	}
-	return quirk;
-}
-
 /**
  * assign_interrupt_mode - choose interrupt mode for PCI Express port services
  *                         (INTx, MSI-X, MSI) and set up vectors
@@ -64,6 +41,7 @@ static int is_msi_quirked(struct pci_dev *dev)
  */
 static int assign_interrupt_mode(struct pci_dev *dev, int *vectors, int mask)
 {
+	struct pcie_port_data *port_data = pci_get_drvdata(dev);
 	int i, pos, nvec, status = -EINVAL;
 	int interrupt_mode = PCIE_PORT_INTx_MODE;
 
@@ -75,7 +53,7 @@ static int assign_interrupt_mode(struct pci_dev *dev, int *vectors, int mask)
 	}
 	
 	/* Check MSI quirk */
-	if (is_msi_quirked(dev))
+	if (port_data->port_type == PCIE_RC_PORT && pcie_mch_quirk)
 		return interrupt_mode;
 
 	/* Select MSI-X over MSI if supported */		
@@ -132,13 +110,11 @@ static int get_port_device_capability(struct pci_dev *dev)
 			pos + PCIE_SLOT_CAPABILITIES_REG, &reg32);
 		if (reg32 & SLOT_HP_CAPABLE_MASK)
 			services |= PCIE_PORT_SERVICE_HP;
-	} 
-	/* PME Capable - root port capability */
-	if (((reg16 >> 4) & PORT_TYPE_MASK) == PCIE_RC_PORT)
-		services |= PCIE_PORT_SERVICE_PME;
-
+	}
+	/* AER capable */
 	if (pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ERR))
 		services |= PCIE_PORT_SERVICE_AER;
+	/* VC support */
 	if (pci_find_ext_capability(dev, PCI_EXT_CAP_ID_VC))
 		services |= PCIE_PORT_SERVICE_VC;
 
@@ -152,15 +128,15 @@ static int get_port_device_capability(struct pci_dev *dev)
  * @port_type: Type of the port
  * @service_type: Type of service to associate with the service device
  * @irq: Interrupt vector to associate with the service device
- * @irq_mode: Interrupt mode of the service (INTx, MSI-X, MSI)
  */
 static void pcie_device_init(struct pci_dev *parent, struct pcie_device *dev, 
-	int port_type, int service_type, int irq, int irq_mode)
+	int service_type, int irq)
 {
+	struct pcie_port_data *port_data = pci_get_drvdata(parent);
 	struct device *device;
+	int port_type = port_data->port_type;
 
 	dev->port = parent;
-	dev->interrupt_mode = irq_mode;
 	dev->irq = irq;
 	dev->id.vendor = parent->vendor;
 	dev->id.device = parent->device;
@@ -185,10 +161,9 @@ static void pcie_device_init(struct pci_dev *parent, struct pcie_device *dev,
  * @port_type: Type of the port
  * @service_type: Type of service to associate with the service device
  * @irq: Interrupt vector to associate with the service device
- * @irq_mode: Interrupt mode of the service (INTx, MSI-X, MSI)
  */
 static struct pcie_device* alloc_pcie_device(struct pci_dev *parent,
-	int port_type, int service_type, int irq, int irq_mode)
+	int service_type, int irq)
 {
 	struct pcie_device *device;
 
@@ -196,7 +171,7 @@ static struct pcie_device* alloc_pcie_device(struct pci_dev *parent,
 	if (!device)
 		return NULL;
 
-	pcie_device_init(parent, device, port_type, service_type, irq,irq_mode);
+	pcie_device_init(parent, device, service_type, irq);
 	return device;
 }
 
@@ -230,39 +205,36 @@ int pcie_port_device_probe(struct pci_dev *dev)
  */
 int pcie_port_device_register(struct pci_dev *dev)
 {
-	struct pcie_port_device_ext *p_ext;
-	int status, type, capabilities, irq_mode, i;
+	struct pcie_port_data *port_data;
+	int status, capabilities, irq_mode, i;
 	int vectors[PCIE_PORT_DEVICE_MAXSERVICES];
 	u16 reg16;
 
-	/* Allocate port device extension */
-	if (!(p_ext = kmalloc(sizeof(struct pcie_port_device_ext), GFP_KERNEL)))
+	port_data = kzalloc(sizeof(*port_data), GFP_KERNEL);
+	if (!port_data)
 		return -ENOMEM;
-
-	pci_set_drvdata(dev, p_ext);
+	pci_set_drvdata(dev, port_data);
 
 	/* Get port type */
 	pci_read_config_word(dev,
 		pci_find_capability(dev, PCI_CAP_ID_EXP) +
 		PCIE_CAPABILITIES_REG, &reg16);
-	type = (reg16 >> 4) & PORT_TYPE_MASK;
+	port_data->port_type = (reg16 >> 4) & PORT_TYPE_MASK;
 
-	/* Now get port services */
 	capabilities = get_port_device_capability(dev);
+	/* Root ports are capable of generating PME too */
+	if (port_data->port_type == PCIE_RC_PORT)
+		capabilities |= PCIE_PORT_SERVICE_PME;
+
 	irq_mode = assign_interrupt_mode(dev, vectors, capabilities);
-	p_ext->interrupt_mode = irq_mode;
+	port_data->port_irq_mode = irq_mode;
 
 	/* Allocate child services if any */
 	for (i = 0; i < PCIE_PORT_DEVICE_MAXSERVICES; i++) {
 		struct pcie_device *child;
 
 		if (capabilities & (1 << i)) {
-			child = alloc_pcie_device(
-				dev, 		/* parent */
-				type,		/* port type */
-				i,		/* service type */
-				vectors[i],	/* irq */
-				irq_mode	/* interrupt mode */);
+			child = alloc_pcie_device(dev, i, vectors[i]);
 			if (child) {
 				status = device_register(&child->device);
 				if (status) {
@@ -349,25 +321,30 @@ static int remove_iter(struct device *dev, void *data)
  */
 void pcie_port_device_remove(struct pci_dev *dev)
 {
-	struct device *device;
-	unsigned long device_addr;
-	int interrupt_mode = PCIE_PORT_INTx_MODE;
+	struct pcie_port_data *port_data = pci_get_drvdata(dev);
 	int status;
 
 	do {
+		unsigned long device_addr;
+
 		status = device_for_each_child(&dev->dev, &device_addr, remove_iter);
 		if (status) {
-			device = (struct device*)device_addr;
-			interrupt_mode = (to_pcie_device(device))->interrupt_mode;
+			struct device *device = (struct device*)device_addr;
 			put_device(device);
 			device_unregister(device);
 		}
 	} while (status);
-	/* Switch to INTx by default if MSI enabled */
-	if (interrupt_mode == PCIE_PORT_MSIX_MODE)
+
+	switch (port_data->port_irq_mode) {
+	case PCIE_PORT_MSIX_MODE:
 		pci_disable_msix(dev);
-	else if (interrupt_mode == PCIE_PORT_MSI_MODE)
+		break;
+	case PCIE_PORT_MSI_MODE:
 		pci_disable_msi(dev);
+		break;
+	}
+
+	kfree(port_data);
 }
 
 /**

commit d9347371c538544a7309d5b6475ec011d98d40e6
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Jan 1 19:53:32 2009 +0100

    PCI: PCIe portdrv: Add kerneldoc comments to remining core funtions
    
    Add kerneldoc comments to the reamining functions in
    drivers/pci/pcie/portdrv_core.c .
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index a0d51e3f34f4..8b3f8c18032f 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -370,6 +370,14 @@ void pcie_port_device_remove(struct pci_dev *dev)
 		pci_disable_msi(dev);
 }
 
+/**
+ * pcie_port_probe_service - probe driver for given PCI Express port service
+ * @dev: PCI Express port service device to probe against
+ *
+ * If PCI Express port service driver is registered with
+ * pcie_port_service_register(), this function will be called by the driver core
+ * whenever match is found between the driver and a port service device.
+ */
 static int pcie_port_probe_service(struct device *dev)
 {
 	struct pcie_device *pciedev;
@@ -393,6 +401,15 @@ static int pcie_port_probe_service(struct device *dev)
 	return status;
 }
 
+/**
+ * pcie_port_remove_service - detach driver from given PCI Express port service
+ * @dev: PCI Express port service device to handle
+ *
+ * If PCI Express port service driver is registered with
+ * pcie_port_service_register(), this function will be called by the driver core
+ * when device_unregister() is called for the port service device associated
+ * with the driver.
+ */
 static int pcie_port_remove_service(struct device *dev)
 {
 	struct pcie_device *pciedev;
@@ -412,8 +429,21 @@ static int pcie_port_remove_service(struct device *dev)
 	return 0;
 }
 
+/**
+ * pcie_port_shutdown_service - shut down given PCI Express port service
+ * @dev: PCI Express port service device to handle
+ *
+ * If PCI Express port service driver is registered with
+ * pcie_port_service_register(), this function will be called by the driver core
+ * when device_shutdown() is called for the port service device associated
+ * with the driver.
+ */
 static void pcie_port_shutdown_service(struct device *dev) {}
 
+/**
+ * pcie_port_service_register - register PCI Express port service driver
+ * @new: PCI Express port service driver to register
+ */
 int pcie_port_service_register(struct pcie_port_service_driver *new)
 {
 	new->driver.name = (char *)new->name;
@@ -425,6 +455,10 @@ int pcie_port_service_register(struct pcie_port_service_driver *new)
 	return driver_register(&new->driver);
 }
 
+/**
+ * pcie_port_service_unregister - unregister PCI Express port service driver
+ * @drv: PCI Express port service driver to unregister
+ */
 void pcie_port_service_unregister(struct pcie_port_service_driver *drv)
 {
 	driver_unregister(&drv->driver);

commit fa6c993736cb8cc18af86b8d17b608efa7882ab5
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Jan 1 19:52:12 2009 +0100

    PCI: PCIe portdrv: Rearrange code so that related things are together
    
    Rearrange code in drivers/pci/pcie/portdrv_bus.c and
    drivers/pci/pcie/portdrv_core.c so that related functions and data
    structures are closer together.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index 6ca5a40cc61c..a0d51e3f34f4 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -19,50 +19,6 @@
 
 extern int pcie_mch_quirk;	/* MSI-quirk Indicator */
 
-static int pcie_port_probe_service(struct device *dev)
-{
-	struct pcie_device *pciedev;
-	struct pcie_port_service_driver *driver;
-	int status;
-
-	if (!dev || !dev->driver)
-		return -ENODEV;
-
- 	driver = to_service_driver(dev->driver);
-	if (!driver || !driver->probe)
-		return -ENODEV;
-
-	pciedev = to_pcie_device(dev);
-	status = driver->probe(pciedev, driver->id_table);
-	if (!status) {
-		dev_printk(KERN_DEBUG, dev, "service driver %s loaded\n",
-			driver->name);
-		get_device(dev);
-	}
-	return status;
-}
-
-static int pcie_port_remove_service(struct device *dev)
-{
-	struct pcie_device *pciedev;
-	struct pcie_port_service_driver *driver;
-
-	if (!dev || !dev->driver)
-		return 0;
-
-	pciedev = to_pcie_device(dev);
- 	driver = to_service_driver(dev->driver);
-	if (driver && driver->remove) { 
-		dev_printk(KERN_DEBUG, dev, "unloading service driver %s\n",
-			driver->name);
-		driver->remove(pciedev);
-		put_device(dev);
-	}
-	return 0;
-}
-
-static void pcie_port_shutdown_service(struct device *dev) {}
-
 /**
  * release_pcie_device - free PCI Express port service device structure
  * @dev: Port service device to release
@@ -414,16 +370,50 @@ void pcie_port_device_remove(struct pci_dev *dev)
 		pci_disable_msi(dev);
 }
 
-int pcie_port_bus_register(void)
+static int pcie_port_probe_service(struct device *dev)
 {
-	return bus_register(&pcie_port_bus_type);
+	struct pcie_device *pciedev;
+	struct pcie_port_service_driver *driver;
+	int status;
+
+	if (!dev || !dev->driver)
+		return -ENODEV;
+
+	driver = to_service_driver(dev->driver);
+	if (!driver || !driver->probe)
+		return -ENODEV;
+
+	pciedev = to_pcie_device(dev);
+	status = driver->probe(pciedev, driver->id_table);
+	if (!status) {
+		dev_printk(KERN_DEBUG, dev, "service driver %s loaded\n",
+			driver->name);
+		get_device(dev);
+	}
+	return status;
 }
 
-void pcie_port_bus_unregister(void)
+static int pcie_port_remove_service(struct device *dev)
 {
-	bus_unregister(&pcie_port_bus_type);
+	struct pcie_device *pciedev;
+	struct pcie_port_service_driver *driver;
+
+	if (!dev || !dev->driver)
+		return 0;
+
+	pciedev = to_pcie_device(dev);
+	driver = to_service_driver(dev->driver);
+	if (driver && driver->remove) {
+		dev_printk(KERN_DEBUG, dev, "unloading service driver %s\n",
+			driver->name);
+		driver->remove(pciedev);
+		put_device(dev);
+	}
+	return 0;
 }
 
+static void pcie_port_shutdown_service(struct device *dev) {}
+
 int pcie_port_service_register(struct pcie_port_service_driver *new)
 {
 	new->driver.name = (char *)new->name;
@@ -435,9 +425,9 @@ int pcie_port_service_register(struct pcie_port_service_driver *new)
 	return driver_register(&new->driver);
 }
 
-void pcie_port_service_unregister(struct pcie_port_service_driver *new)
+void pcie_port_service_unregister(struct pcie_port_service_driver *drv)
 {
-	driver_unregister(&new->driver);
+	driver_unregister(&drv->driver);
 }
 
 EXPORT_SYMBOL(pcie_port_service_register);

commit e7ae88486670f3904f187d0fff9dcf469bcdd8ba
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Jan 1 19:51:15 2009 +0100

    PCI: PCIe portdrv: Fix suspend and resume of PCI Express port services
    
    There is a problem with the suspend and resume of PCI Express port
    service devices that the ->suspend() and ->resume() routines of each
    service device are called twice in each suspend-resume cycle, which
    is obviously wrong.
    
    The scenario is that first, the PCI Express port driver calls
    suspend and resume routines of each port service driver from its
    pcie_portdrv_suspend() and pcie_portdrv_resume() callbacks,
    respectively (which is correct), and second, the pcie_port_bus_type
    driver calls them from its ->suspend() and ->resume() callbacks
    (which is not correct, because it doesn't happen at the right time).
    
    The solution is to remove the ->suspend() and ->resume() callbacks
    from pcie_port_bus_type and the associated functions.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index 8f09b353d2af..6ca5a40cc61c 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -63,37 +63,6 @@ static int pcie_port_remove_service(struct device *dev)
 
 static void pcie_port_shutdown_service(struct device *dev) {}
 
-static int pcie_port_suspend_service(struct device *dev, pm_message_t state)
-{
-	struct pcie_device *pciedev;
-	struct pcie_port_service_driver *driver;
-
-	if (!dev || !dev->driver)
-		return 0;
-
-	pciedev = to_pcie_device(dev);
- 	driver = to_service_driver(dev->driver);
-	if (driver && driver->suspend)
-		driver->suspend(pciedev, state);
-	return 0;
-}
-
-static int pcie_port_resume_service(struct device *dev)
-{
-	struct pcie_device *pciedev;
-	struct pcie_port_service_driver *driver;
-
-	if (!dev || !dev->driver)
-		return 0;
-
-	pciedev = to_pcie_device(dev);
- 	driver = to_service_driver(dev->driver);
-
-	if (driver && driver->resume)
-		driver->resume(pciedev);
-	return 0;
-}
-
 /**
  * release_pcie_device - free PCI Express port service device structure
  * @dev: Port service device to release
@@ -462,8 +431,6 @@ int pcie_port_service_register(struct pcie_port_service_driver *new)
 	new->driver.probe = pcie_port_probe_service;
 	new->driver.remove = pcie_port_remove_service;
 	new->driver.shutdown = pcie_port_shutdown_service;
-	new->driver.suspend = pcie_port_suspend_service;
-	new->driver.resume = pcie_port_resume_service;
 
 	return driver_register(&new->driver);
 }

commit facf6d1627a33badbbc154524c4a2c73c51bdc99
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Thu Jan 1 19:48:55 2009 +0100

    PCI: PCIe portdrv: Add kerneldoc comments to some core functions
    
    Add kerneldoc comments to some functions in
    drivers/pci/pcie/portdrv_core.c, since the code in there is not
    easy to follow without any additional description.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index 6a9f83ccaff4..8f09b353d2af 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -94,12 +94,12 @@ static int pcie_port_resume_service(struct device *dev)
 	return 0;
 }
 
-/*
- * release_pcie_device
- *	
- *	Being invoked automatically when device is being removed 
- *	in response to device_unregister(dev) call.
- *	Release all resources being claimed.
+/**
+ * release_pcie_device - free PCI Express port service device structure
+ * @dev: Port service device to release
+ *
+ * Invoked automatically when device is being removed in response to
+ * device_unregister(dev).  Release all resources being claimed.
  */
 static void release_pcie_device(struct device *dev)
 {
@@ -127,7 +127,16 @@ static int is_msi_quirked(struct pci_dev *dev)
 	}
 	return quirk;
 }
-	
+
+/**
+ * assign_interrupt_mode - choose interrupt mode for PCI Express port services
+ *                         (INTx, MSI-X, MSI) and set up vectors
+ * @dev: PCI Express port to handle
+ * @vectors: Array of interrupt vectors to populate
+ * @mask: Bitmask of port capabilities returned by get_port_device_capability()
+ *
+ * Return value: Interrupt mode associated with the port
+ */
 static int assign_interrupt_mode(struct pci_dev *dev, int *vectors, int mask)
 {
 	int i, pos, nvec, status = -EINVAL;
@@ -174,6 +183,16 @@ static int assign_interrupt_mode(struct pci_dev *dev, int *vectors, int mask)
 	return interrupt_mode;
 }
 
+/**
+ * get_port_device_capability - discover capabilities of a PCI Express port
+ * @dev: PCI Express port to examine
+ *
+ * The capabilities are read from the port's PCI Express configuration registers
+ * as described in PCI Express Base Specification 1.0a sections 7.8.2, 7.8.9 and
+ * 7.9 - 7.11.
+ *
+ * Return value: Bitmask of discovered port capabilities
+ */
 static int get_port_device_capability(struct pci_dev *dev)
 {
 	int services = 0, pos;
@@ -201,6 +220,15 @@ static int get_port_device_capability(struct pci_dev *dev)
 	return services;
 }
 
+/**
+ * pcie_device_init - initialize PCI Express port service device
+ * @dev: Port service device to initialize
+ * @parent: PCI Express port to associate the service device with
+ * @port_type: Type of the port
+ * @service_type: Type of service to associate with the service device
+ * @irq: Interrupt vector to associate with the service device
+ * @irq_mode: Interrupt mode of the service (INTx, MSI-X, MSI)
+ */
 static void pcie_device_init(struct pci_dev *parent, struct pcie_device *dev, 
 	int port_type, int service_type, int irq, int irq_mode)
 {
@@ -226,6 +254,14 @@ static void pcie_device_init(struct pci_dev *parent, struct pcie_device *dev,
 	device->parent = &parent->dev;
 }
 
+/**
+ * alloc_pcie_device - allocate PCI Express port service device structure
+ * @parent: PCI Express port to associate the service device with
+ * @port_type: Type of the port
+ * @service_type: Type of service to associate with the service device
+ * @irq: Interrupt vector to associate with the service device
+ * @irq_mode: Interrupt mode of the service (INTx, MSI-X, MSI)
+ */
 static struct pcie_device* alloc_pcie_device(struct pci_dev *parent,
 	int port_type, int service_type, int irq, int irq_mode)
 {
@@ -239,6 +275,10 @@ static struct pcie_device* alloc_pcie_device(struct pci_dev *parent,
 	return device;
 }
 
+/**
+ * pcie_port_device_probe - check if device is a PCI Express port
+ * @dev: Device to check
+ */
 int pcie_port_device_probe(struct pci_dev *dev)
 {
 	int pos, type;
@@ -256,6 +296,13 @@ int pcie_port_device_probe(struct pci_dev *dev)
 	return -ENODEV;
 }
 
+/**
+ * pcie_port_device_register - register PCI Express port
+ * @dev: PCI Express port to register
+ *
+ * Allocate the port extension structure and register services associated with
+ * the port.
+ */
 int pcie_port_device_register(struct pci_dev *dev)
 {
 	struct pcie_port_device_ext *p_ext;
@@ -319,6 +366,11 @@ static int suspend_iter(struct device *dev, void *data)
 	return 0;
 }
 
+/**
+ * pcie_port_device_suspend - suspend port services associated with a PCIe port
+ * @dev: PCI Express port to handle
+ * @state: Representation of system power management transition in progress
+ */
 int pcie_port_device_suspend(struct pci_dev *dev, pm_message_t state)
 {
 	return device_for_each_child(&dev->dev, &state, suspend_iter);
@@ -337,6 +389,10 @@ static int resume_iter(struct device *dev, void *data)
 	return 0;
 }
 
+/**
+ * pcie_port_device_suspend - resume port services associated with a PCIe port
+ * @dev: PCI Express port to handle
+ */
 int pcie_port_device_resume(struct pci_dev *dev)
 {
 	return device_for_each_child(&dev->dev, NULL, resume_iter);
@@ -359,6 +415,13 @@ static int remove_iter(struct device *dev, void *data)
 	return 0;
 }
 
+/**
+ * pcie_port_device_remove - unregister PCI Express port service devices
+ * @dev: PCI Express port the service devices to unregister are associated with
+ *
+ * Remove PCI Express port service devices associated with given port and
+ * disable MSI-X or MSI for the port.
+ */
 void pcie_port_device_remove(struct pci_dev *dev)
 {
 	struct device *device;

commit 0e331bf1c44401a5b6d7b778dd1f254724132dff
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Wed Dec 10 13:00:21 2008 -0700

    PCI: pcie port driver: remove extra printks
    
    These printks don't contain enough information to be useful.  I think it
    would be more useful to have a message when a service driver binds to a
    root port.  That could contain the service type, the interrupt mode and
    IRQ, etc.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index 75f501ab6468..6a9f83ccaff4 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -103,7 +103,6 @@ static int pcie_port_resume_service(struct device *dev)
  */
 static void release_pcie_device(struct device *dev)
 {
-	dev_printk(KERN_DEBUG, dev, "free port service\n");
 	kfree(to_pcie_device(dev));			
 }
 
@@ -150,7 +149,6 @@ static int assign_interrupt_mode(struct pci_dev *dev, int *vectors, int mask)
 	if (pos) {
 		struct msix_entry msix_entries[PCIE_PORT_DEVICE_MAXSERVICES] = 
 			{{0, 0}, {0, 1}, {0, 2}, {0, 3}};
-		dev_info(&dev->dev, "found MSI-X capability\n");
 		status = pci_enable_msix(dev, msix_entries, nvec);
 		if (!status) {
 			int j = 0;
@@ -165,7 +163,6 @@ static int assign_interrupt_mode(struct pci_dev *dev, int *vectors, int mask)
 	if (status) {
 		pos = pci_find_capability(dev, PCI_CAP_ID_MSI);
 		if (pos) {
-			dev_info(&dev->dev, "found MSI capability\n");
 			status = pci_enable_msi(dev);
 			if (!status) {
 				interrupt_mode = PCIE_PORT_MSI_MODE;
@@ -239,7 +236,6 @@ static struct pcie_device* alloc_pcie_device(struct pci_dev *parent,
 		return NULL;
 
 	pcie_device_init(parent, device, port_type, service_type, irq,irq_mode);
-	dev_printk(KERN_DEBUG, &device->device, "allocate port service\n");
 	return device;
 }
 

commit 1a9271331ab663f3c7cda78d86b884f2ea86d4d7
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Thu Oct 30 02:17:49 2008 +0100

    PCI: struct device - replace bus_id with dev_name(), dev_set_name()
    
    This patch is part of a larger patch series which will remove
    the "char bus_id[20]" name string from struct device. The device
    name is managed in the kobject anyway, and without any size
    limitation, and just needlessly copied into "struct device".
    
    To set and read the device name dev_name(dev) and dev_set_name(dev)
    must be used. If your code uses static kobjects, which it shouldn't
    do, "const char *init_name" can be used to statically provide the
    name the registered device should have. At registration time, the
    init_name field is cleared, to enforce the use of dev_name(dev) to
    access the device name at a later time.
    
    We need to get rid of all occurrences of bus_id in the entire tree
    to be able to enable the new interface. Please apply this patch,
    and possibly convert any remaining remaining occurrences of bus_id.
    
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-Off-By: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index 2e091e014829..75f501ab6468 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -224,7 +224,7 @@ static void pcie_device_init(struct pci_dev *parent, struct pcie_device *dev,
 	device->driver = NULL;
 	device->driver_data = NULL;
 	device->release = release_pcie_device;	/* callback to free pcie dev */
-	snprintf(device->bus_id, sizeof(device->bus_id), "%s:pcie%02x",
+	dev_set_name(device, "%s:pcie%02x",
 		 pci_name(parent), get_descriptor_id(port_type, service_type));
 	device->parent = &parent->dev;
 }

commit 0927678f55c9a50c296f7e6dae85e87b8236e155
Author: Jesse Barnes <jbarnes@virtuousgeek.org>
Date:   Sat Oct 18 17:33:19 2008 -0700

    PCI: use pci_find_ext_capability everywhere
    
    Remove some open coded (and buggy) versions of pci_find_ext_capability
    in favor of the real routine in the PCI core.
    
    Tested-by: Tomasz Czernecki <czernecki@gmail.com>
    Acked-by: Andrew Vasquez <andrew.vasquez@qlogic.com>
    Reviewed-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index 890f0d2b370a..2e091e014829 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -195,24 +195,11 @@ static int get_port_device_capability(struct pci_dev *dev)
 	/* PME Capable - root port capability */
 	if (((reg16 >> 4) & PORT_TYPE_MASK) == PCIE_RC_PORT)
 		services |= PCIE_PORT_SERVICE_PME;
-	
-	pos = PCI_CFG_SPACE_SIZE;
-	while (pos) {
-		pci_read_config_dword(dev, pos, &reg32);
-		switch (reg32 & 0xffff) {
-		case PCI_EXT_CAP_ID_ERR:
-			services |= PCIE_PORT_SERVICE_AER;
-			pos = reg32 >> 20;
-			break;
-		case PCI_EXT_CAP_ID_VC:
-			services |= PCIE_PORT_SERVICE_VC;
-			pos = reg32 >> 20;
-			break;
-		default:
-			pos = 0;
-			break;
-		}
-	}
+
+	if (pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ERR))
+		services |= PCIE_PORT_SERVICE_AER;
+	if (pci_find_ext_capability(dev, PCI_EXT_CAP_ID_VC))
+		services |= PCIE_PORT_SERVICE_VC;
 
 	return services;
 }

commit 34438ba602f9b8904aafe7559046ea68e99e88a0
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Fri Jun 13 10:52:13 2008 -0600

    PCIE: port driver: use dev_printk when possible
    
    Convert printks to use dev_printk().
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index fb0abfa508dc..890f0d2b370a 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -23,20 +23,20 @@ static int pcie_port_probe_service(struct device *dev)
 {
 	struct pcie_device *pciedev;
 	struct pcie_port_service_driver *driver;
-	int status = -ENODEV;
+	int status;
 
 	if (!dev || !dev->driver)
-		return status;
+		return -ENODEV;
 
  	driver = to_service_driver(dev->driver);
 	if (!driver || !driver->probe)
-		return status;
+		return -ENODEV;
 
 	pciedev = to_pcie_device(dev);
 	status = driver->probe(pciedev, driver->id_table);
 	if (!status) {
-		printk(KERN_DEBUG "Load service driver %s on pcie device %s\n",
-			driver->name, dev->bus_id);
+		dev_printk(KERN_DEBUG, dev, "service driver %s loaded\n",
+			driver->name);
 		get_device(dev);
 	}
 	return status;
@@ -53,8 +53,8 @@ static int pcie_port_remove_service(struct device *dev)
 	pciedev = to_pcie_device(dev);
  	driver = to_service_driver(dev->driver);
 	if (driver && driver->remove) { 
-		printk(KERN_DEBUG "Unload service driver %s on pcie device %s\n",
-			driver->name, dev->bus_id);
+		dev_printk(KERN_DEBUG, dev, "unloading service driver %s\n",
+			driver->name);
 		driver->remove(pciedev);
 		put_device(dev);
 	}
@@ -103,7 +103,7 @@ static int pcie_port_resume_service(struct device *dev)
  */
 static void release_pcie_device(struct device *dev)
 {
-	printk(KERN_DEBUG "Free Port Service[%s]\n", dev->bus_id);
+	dev_printk(KERN_DEBUG, dev, "free port service\n");
 	kfree(to_pcie_device(dev));			
 }
 
@@ -150,7 +150,7 @@ static int assign_interrupt_mode(struct pci_dev *dev, int *vectors, int mask)
 	if (pos) {
 		struct msix_entry msix_entries[PCIE_PORT_DEVICE_MAXSERVICES] = 
 			{{0, 0}, {0, 1}, {0, 2}, {0, 3}};
-		printk("%s Found MSIX capability\n", __func__);
+		dev_info(&dev->dev, "found MSI-X capability\n");
 		status = pci_enable_msix(dev, msix_entries, nvec);
 		if (!status) {
 			int j = 0;
@@ -165,7 +165,7 @@ static int assign_interrupt_mode(struct pci_dev *dev, int *vectors, int mask)
 	if (status) {
 		pos = pci_find_capability(dev, PCI_CAP_ID_MSI);
 		if (pos) {
-			printk("%s Found MSI capability\n", __func__);
+			dev_info(&dev->dev, "found MSI capability\n");
 			status = pci_enable_msi(dev);
 			if (!status) {
 				interrupt_mode = PCIE_PORT_MSI_MODE;
@@ -252,7 +252,7 @@ static struct pcie_device* alloc_pcie_device(struct pci_dev *parent,
 		return NULL;
 
 	pcie_device_init(parent, device, port_type, service_type, irq,irq_mode);
-	printk(KERN_DEBUG "Allocate Port Service[%s]\n", device->device.bus_id);
+	dev_printk(KERN_DEBUG, &device->device, "allocate port service\n");
 	return device;
 }
 

commit 66bef8c059015ba2b36bb5759080336feb01e680
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Mon Mar 3 19:09:46 2008 -0800

    PCI: replace remaining __FUNCTION__ occurrences
    
    __FUNCTION__ is gcc-specific, use __func__
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index 23d9eb073296..fb0abfa508dc 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -150,7 +150,7 @@ static int assign_interrupt_mode(struct pci_dev *dev, int *vectors, int mask)
 	if (pos) {
 		struct msix_entry msix_entries[PCIE_PORT_DEVICE_MAXSERVICES] = 
 			{{0, 0}, {0, 1}, {0, 2}, {0, 3}};
-		printk("%s Found MSIX capability\n", __FUNCTION__);
+		printk("%s Found MSIX capability\n", __func__);
 		status = pci_enable_msix(dev, msix_entries, nvec);
 		if (!status) {
 			int j = 0;
@@ -165,7 +165,7 @@ static int assign_interrupt_mode(struct pci_dev *dev, int *vectors, int mask)
 	if (status) {
 		pos = pci_find_capability(dev, PCI_CAP_ID_MSI);
 		if (pos) {
-			printk("%s Found MSI capability\n", __FUNCTION__);
+			printk("%s Found MSI capability\n", __func__);
 			status = pci_enable_msi(dev);
 			if (!status) {
 				interrupt_mode = PCIE_PORT_MSI_MODE;

commit 39ec4561b3a9ccccbdab1dd88a045342be22f27b
Author: Shaohua Li <shaohua.li@intel.com>
Date:   Wed Oct 24 10:43:23 2007 +0800

    pcie port driver: correctly detect native PME feature
    
    Native PME is capability of root port or root complex event collector.
    It's not determined by PCI PME capability.
    
    Signed-off-by: Shaohua Li <shaohua.li@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index b20a9b81dae2..23d9eb073296 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -192,9 +192,8 @@ static int get_port_device_capability(struct pci_dev *dev)
 		if (reg32 & SLOT_HP_CAPABLE_MASK)
 			services |= PCIE_PORT_SERVICE_HP;
 	} 
-	/* PME Capable */
-	pos = pci_find_capability(dev, PCI_CAP_ID_PME);
-	if (pos) 
+	/* PME Capable - root port capability */
+	if (((reg16 >> 4) & PORT_TYPE_MASK) == PCIE_RC_PORT)
 		services |= PCIE_PORT_SERVICE_PME;
 	
 	pos = PCI_CFG_SPACE_SIZE;

commit 3ec6a8d02efd54a66640bd85afa8c162647b56c3
Author: Andrew Morton <akpm@osdl.org>
Date:   Mon Sep 25 16:52:20 2006 -0700

    PCI: pcie-check-and-return-bus_register-errors fix
    
    __must_check goes on the declaration, not the definition.
    
    Cc: "Randy.Dunlap" <rdunlap@xenotime.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index bd6615b4d40e..b20a9b81dae2 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -6,7 +6,6 @@
  * Copyright (C) Tom Long Nguyen (tom.l.nguyen@intel.com)
  */
 
-#include <linux/compiler.h>
 #include <linux/module.h>
 #include <linux/pci.h>
 #include <linux/kernel.h>
@@ -401,7 +400,7 @@ void pcie_port_device_remove(struct pci_dev *dev)
 		pci_disable_msi(dev);
 }
 
-int __must_check pcie_port_bus_register(void)
+int pcie_port_bus_register(void)
 {
 	return bus_register(&pcie_port_bus_type);
 }

commit b19441af185559118e8247382ea4f2f76ebffc6d
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Aug 28 11:43:25 2006 -0700

    PCI: fix __must_check warnings
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index cf9e810b4bf8..bd6615b4d40e 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -340,8 +340,7 @@ static int suspend_iter(struct device *dev, void *data)
 
 int pcie_port_device_suspend(struct pci_dev *dev, pm_message_t state)
 {
-	device_for_each_child(&dev->dev, &state, suspend_iter);
-	return 0;
+	return device_for_each_child(&dev->dev, &state, suspend_iter);
 }
 
 static int resume_iter(struct device *dev, void *data)
@@ -359,8 +358,7 @@ static int resume_iter(struct device *dev, void *data)
 
 int pcie_port_device_resume(struct pci_dev *dev)
 {
-	device_for_each_child(&dev->dev, NULL, resume_iter);
-	return 0;
+	return device_for_each_child(&dev->dev, NULL, resume_iter);
 }
 #endif
 

commit 20d516602c022997feb24a9f1a806fc986b9e4e8
Author: Randy Dunlap <rdunlap@xenotime.net>
Date:   Sat Jul 8 22:58:25 2006 -0700

    PCIE: check and return bus_register errors
    
    Have pcie_port_bus_register() notice and return errors.
    Mark it __must_check so that its caller(s) must check its return value.
    
    Signed-off-by: Randy Dunlap <rdunlap@xenotime.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index 55c662267868..cf9e810b4bf8 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -6,6 +6,7 @@
  * Copyright (C) Tom Long Nguyen (tom.l.nguyen@intel.com)
  */
 
+#include <linux/compiler.h>
 #include <linux/module.h>
 #include <linux/pci.h>
 #include <linux/kernel.h>
@@ -402,9 +403,9 @@ void pcie_port_device_remove(struct pci_dev *dev)
 		pci_disable_msi(dev);
 }
 
-void pcie_port_bus_register(void)
+int __must_check pcie_port_bus_register(void)
 {
-	bus_register(&pcie_port_bus_type);
+	return bus_register(&pcie_port_bus_type);
 }
 
 void pcie_port_bus_unregister(void)

commit f5afe8064f3087bead8fea7e32547c2a3ada5fd0
Author: Eric Sesterhenn <snakebyte@gmx.de>
Date:   Tue Feb 28 15:34:49 2006 +0100

    [PATCH] PCI: kzalloc() conversion in drivers/pci
    
    this patch converts drivers/pci to kzalloc usage.
    Compile tested with allyes config.
    
    Signed-off-by: Eric Sesterhenn <snakebyte@gmx.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index e4e5f1e8d816..55c662267868 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -248,11 +248,10 @@ static struct pcie_device* alloc_pcie_device(struct pci_dev *parent,
 {
 	struct pcie_device *device;
 
-	device = kmalloc(sizeof(struct pcie_device), GFP_KERNEL);
+	device = kzalloc(sizeof(struct pcie_device), GFP_KERNEL);
 	if (!device)
 		return NULL;
 
-	memset(device, 0, sizeof(struct pcie_device));
 	pcie_device_init(parent, device, port_type, service_type, irq,irq_mode);
 	printk(KERN_DEBUG "Allocate Port Service[%s]\n", device->device.bus_id);
 	return device;

commit 8c9ad508c8737ca46a4c55b1062d159b86f7cee2
Author: Sergey Vlasov <vsu@altlinux.ru>
Date:   Mon Nov 14 20:30:50 2005 +0300

    [PATCH] PCIE: make bus_id for PCI Express devices unique
    
    The bus_id string must be unique for all devices of that bus in the
    system, not just for devices with the same parent - otherwise multiple
    symlinks with identical names appear in /sys/bus/pci_express/devices.
    
    Signed-off-by: Sergey Vlasov <vsu@altlinux.ru>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index 467a4ceccf10..e4e5f1e8d816 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -238,8 +238,8 @@ static void pcie_device_init(struct pci_dev *parent, struct pcie_device *dev,
 	device->driver = NULL;
 	device->driver_data = NULL;
 	device->release = release_pcie_device;	/* callback to free pcie dev */
-	sprintf(&device->bus_id[0], "pcie%02x",
-		get_descriptor_id(port_type, service_type));
+	snprintf(device->bus_id, sizeof(device->bus_id), "%s:pcie%02x",
+		 pci_name(parent), get_descriptor_id(port_type, service_type));
 	device->parent = &parent->dev;
 }
 

commit 4e57b6817880946a3a78d5d8cad1ace363f7e449
Author: Tim Schmielau <tim@physik3.uni-rostock.de>
Date:   Sun Oct 30 15:03:48 2005 -0800

    [PATCH] fix missing includes
    
    I recently picked up my older work to remove unnecessary #includes of
    sched.h, starting from a patch by Dave Jones to not include sched.h
    from module.h. This reduces the number of indirect includes of sched.h
    by ~300. Another ~400 pointless direct includes can be removed after
    this disentangling (patch to follow later).
    However, quite a few indirect includes need to be fixed up for this.
    
    In order to feed the patches through -mm with as little disturbance as
    possible, I've split out the fixes I accumulated up to now (complete for
    i386 and x86_64, more archs to follow later) and post them before the real
    patch.  This way this large part of the patch is kept simple with only
    adding #includes, and all hunks are independent of each other.  So if any
    hunk rejects or gets in the way of other patches, just drop it.  My scripts
    will pick it up again in the next round.
    
    Signed-off-by: Tim Schmielau <tim@physik3.uni-rostock.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index 14f05d22bb70..467a4ceccf10 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -11,6 +11,8 @@
 #include <linux/kernel.h>
 #include <linux/errno.h>
 #include <linux/pm.h>
+#include <linux/string.h>
+#include <linux/slab.h>
 #include <linux/pcieport_if.h>
 
 #include "portdrv.h"

commit 9480e307cd88ef09ec9294c7d97ebec18e6d2221
Author: Russell King <rmk@arm.linux.org.uk>
Date:   Fri Oct 28 09:52:56 2005 -0700

    [PATCH] DRIVER MODEL: Get rid of the obsolete tri-level suspend/resume callbacks
    
    In PM v1, all devices were called at SUSPEND_DISABLE level.  Then
    all devices were called at SUSPEND_SAVE_STATE level, and finally
    SUSPEND_POWER_DOWN level.  However, with PM v2, to maintain
    compatibility for platform devices, I arranged for the PM v2
    suspend/resume callbacks to call the old PM v1 suspend/resume
    callbacks three times with each level in order so that existing
    drivers continued to work.
    
    Since this is obsolete infrastructure which is no longer necessary,
    we can remove it.  Here's an (untested) patch to do exactly that.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index 393e0cee91a9..14f05d22bb70 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -61,7 +61,7 @@ static int pcie_port_remove_service(struct device *dev)
 
 static void pcie_port_shutdown_service(struct device *dev) {}
 
-static int pcie_port_suspend_service(struct device *dev, pm_message_t state, u32 level)
+static int pcie_port_suspend_service(struct device *dev, pm_message_t state)
 {
 	struct pcie_device *pciedev;
 	struct pcie_port_service_driver *driver;
@@ -76,7 +76,7 @@ static int pcie_port_suspend_service(struct device *dev, pm_message_t state, u32
 	return 0;
 }
 
-static int pcie_port_resume_service(struct device *dev, u32 level)
+static int pcie_port_resume_service(struct device *dev)
 {
 	struct pcie_device *pciedev;
 	struct pcie_port_service_driver *driver;

commit 2a569579be87b5ba61f9b6c54fd5f9f307c53962
Author: Pavel Machek <pavel@ucw.cz>
Date:   Thu Jul 7 17:56:40 2005 -0700

    [PATCH] pm: more u32 vs. pm_message_t fixes
    
    Few more u32 vs. pm_message_t fixes.
    
    Signed-off-by: Pavel Machek <pavel@suse.cz>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index 4db69982876e..393e0cee91a9 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -325,7 +325,7 @@ int pcie_port_device_register(struct pci_dev *dev)
 static int suspend_iter(struct device *dev, void *data)
 {
 	struct pcie_port_service_driver *service_driver;
-	u32 state = (u32)data;
+	pm_message_t state = * (pm_message_t *) data;
 
  	if ((dev->bus == &pcie_port_bus_type) &&
  	    (dev->driver)) {
@@ -336,9 +336,9 @@ static int suspend_iter(struct device *dev, void *data)
 	return 0;
 }
 
-int pcie_port_device_suspend(struct pci_dev *dev, u32 state)
+int pcie_port_device_suspend(struct pci_dev *dev, pm_message_t state)
 {
-	device_for_each_child(&dev->dev, (void *)state, suspend_iter);
+	device_for_each_child(&dev->dev, &state, suspend_iter);
 	return 0;
 }
 

commit 5823d100ae260d022b4dd5ec9cc0b85f0bf0d646
Author: long <tlnguyen@snoqualmie.dp.intel.com>
Date:   Wed Jun 22 09:09:54 2005 -0700

    [PATCH] PCI: acpi tg3 ethernet not coming back properly after S3 suspendon DellM70
    
    This patch, is based on kernel 2.6.12, provides a fix for PCIe
    port bus driver suspend/resume.
    
    Signed-off-by: T. Long Nguyen <tom.l.nguyen@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index f5c5f10a3d2f..4db69982876e 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -275,10 +275,17 @@ int pcie_port_device_probe(struct pci_dev *dev)
 
 int pcie_port_device_register(struct pci_dev *dev)
 {
+	struct pcie_port_device_ext *p_ext;
 	int status, type, capabilities, irq_mode, i;
 	int vectors[PCIE_PORT_DEVICE_MAXSERVICES];
 	u16 reg16;
 
+	/* Allocate port device extension */
+	if (!(p_ext = kmalloc(sizeof(struct pcie_port_device_ext), GFP_KERNEL)))
+		return -ENOMEM;
+
+	pci_set_drvdata(dev, p_ext);
+
 	/* Get port type */
 	pci_read_config_word(dev,
 		pci_find_capability(dev, PCI_CAP_ID_EXP) +
@@ -288,6 +295,7 @@ int pcie_port_device_register(struct pci_dev *dev)
 	/* Now get port services */
 	capabilities = get_port_device_capability(dev);
 	irq_mode = assign_interrupt_mode(dev, vectors, capabilities);
+	p_ext->interrupt_mode = irq_mode;
 
 	/* Allocate child services if any */
 	for (i = 0; i < PCIE_PORT_DEVICE_MAXSERVICES; i++) {

commit d0e2b4a0a9dd3eed71b56c47268bf4e40cff6d0f
Author: long <tlnguyen@snoqualmie.dp.intel.com>
Date:   Tue Mar 29 13:36:43 2005 -0800

    [PATCH] use device_for_each_child() to properly access child devices.
    
    On Friday, March 25, 2005 8:47 PM Greg KH wrote:
    >Here's a fix for pci express.  For some reason I don't think they are
    >using the driver model properly here, but I could be wrong...
    
    Thanks for making the changes. However, changes in functions:
    void pcie_port_device_remove(struct pci_dev *dev) and
    static int remove_iter(struct device *dev, void *data)
    are not correct. Please use the patch, which is based on kernel
    2.6.12-rc1, below for a fix for these.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index 576285765e98..f5c5f10a3d2f 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -232,19 +232,16 @@ static void pcie_device_init(struct pci_dev *parent, struct pcie_device *dev,
 	/* Initialize generic device interface */
 	device = &dev->device;
 	memset(device, 0, sizeof(struct device));
-	INIT_LIST_HEAD(&device->node);
-	INIT_LIST_HEAD(&device->children);
-	INIT_LIST_HEAD(&device->bus_list);
 	device->bus = &pcie_port_bus_type;
 	device->driver = NULL;
-	device->driver_data = NULL; 
+	device->driver_data = NULL;
 	device->release = release_pcie_device;	/* callback to free pcie dev */
-	sprintf(&device->bus_id[0], "pcie%02x", 
+	sprintf(&device->bus_id[0], "pcie%02x",
 		get_descriptor_id(port_type, service_type));
 	device->parent = &parent->dev;
 }
 
-static struct pcie_device* alloc_pcie_device(struct pci_dev *parent, 
+static struct pcie_device* alloc_pcie_device(struct pci_dev *parent,
 	int port_type, int service_type, int irq, int irq_mode)
 {
 	struct pcie_device *device;
@@ -270,9 +267,9 @@ int pcie_port_device_probe(struct pci_dev *dev)
 	pci_read_config_word(dev, pos + PCIE_CAPABILITIES_REG, &reg);
 	type = (reg >> 4) & PORT_TYPE_MASK;
 	if (	type == PCIE_RC_PORT || type == PCIE_SW_UPSTREAM_PORT ||
-		type == PCIE_SW_DOWNSTREAM_PORT )  
+		type == PCIE_SW_DOWNSTREAM_PORT )
 		return 0;
- 
+
 	return -ENODEV;
 }
 
@@ -283,8 +280,8 @@ int pcie_port_device_register(struct pci_dev *dev)
 	u16 reg16;
 
 	/* Get port type */
-	pci_read_config_word(dev, 
-		pci_find_capability(dev, PCI_CAP_ID_EXP) + 
+	pci_read_config_word(dev,
+		pci_find_capability(dev, PCI_CAP_ID_EXP) +
 		PCIE_CAPABILITIES_REG, &reg16);
 	type = (reg16 >> 4) & PORT_TYPE_MASK;
 
@@ -299,11 +296,11 @@ int pcie_port_device_register(struct pci_dev *dev)
 		if (capabilities & (1 << i)) {
 			child = alloc_pcie_device(
 				dev, 		/* parent */
-				type,		/* port type */ 
+				type,		/* port type */
 				i,		/* service type */
 				vectors[i],	/* irq */
 				irq_mode	/* interrupt mode */);
-			if (child) { 
+			if (child) {
 				status = device_register(&child->device);
 				if (status) {
 					kfree(child);
@@ -317,84 +314,78 @@ int pcie_port_device_register(struct pci_dev *dev)
 }
 
 #ifdef CONFIG_PM
-int pcie_port_device_suspend(struct pci_dev *dev, pm_message_t state)
+static int suspend_iter(struct device *dev, void *data)
 {
-	struct list_head 		*head, *tmp;
-	struct device 			*parent, *child;
-	struct device_driver 		*driver;
 	struct pcie_port_service_driver *service_driver;
+	u32 state = (u32)data;
+
+ 	if ((dev->bus == &pcie_port_bus_type) &&
+ 	    (dev->driver)) {
+ 		service_driver = to_service_driver(dev->driver);
+ 		if (service_driver->suspend)
+ 			service_driver->suspend(to_pcie_device(dev), state);
+  	}
+	return 0;
+}
 
-	parent = &dev->dev;
-	head = &parent->children;
-	tmp = head->next;
-	while (head != tmp) {
-		child = container_of(tmp, struct device, node);
-		tmp = tmp->next;
-		if (child->bus != &pcie_port_bus_type)
-			continue;
-		driver = child->driver;
-		if (!driver)
-			continue;
-		service_driver = to_service_driver(driver);
-		if (service_driver->suspend)  
-			service_driver->suspend(to_pcie_device(child), state);
-	}
-	return 0; 
+int pcie_port_device_suspend(struct pci_dev *dev, u32 state)
+{
+	device_for_each_child(&dev->dev, (void *)state, suspend_iter);
+	return 0;
 }
 
-int pcie_port_device_resume(struct pci_dev *dev) 
-{ 
-	struct list_head 		*head, *tmp;
-	struct device 			*parent, *child;
-	struct device_driver 		*driver;
+static int resume_iter(struct device *dev, void *data)
+{
 	struct pcie_port_service_driver *service_driver;
 
-	parent = &dev->dev;
-	head = &parent->children;
-	tmp = head->next;
-	while (head != tmp) {
-		child = container_of(tmp, struct device, node);
-		tmp = tmp->next;
-		if (child->bus != &pcie_port_bus_type)
-			continue;
-		driver = child->driver;
-		if (!driver)
-			continue;
-		service_driver = to_service_driver(driver);
-		if (service_driver->resume)  
-			service_driver->resume(to_pcie_device(child));
+	if ((dev->bus == &pcie_port_bus_type) &&
+	    (dev->driver)) {
+		service_driver = to_service_driver(dev->driver);
+		if (service_driver->resume)
+			service_driver->resume(to_pcie_device(dev));
 	}
-	return 0; 
+	return 0;
+}
 
+int pcie_port_device_resume(struct pci_dev *dev)
+{
+	device_for_each_child(&dev->dev, NULL, resume_iter);
+	return 0;
 }
 #endif
 
-void pcie_port_device_remove(struct pci_dev *dev)
+static int remove_iter(struct device *dev, void *data)
 {
-	struct list_head 		*head, *tmp;
-	struct device 			*parent, *child;
-	struct device_driver 		*driver;
 	struct pcie_port_service_driver *service_driver;
-	int interrupt_mode = PCIE_PORT_INTx_MODE;
 
-	parent = &dev->dev;
-	head = &parent->children;
-	tmp = head->next;
-	while (head != tmp) {
-		child = container_of(tmp, struct device, node);
-		tmp = tmp->next;
-		if (child->bus != &pcie_port_bus_type)
-			continue;
-		driver = child->driver;
-		if (driver) { 
-			service_driver = to_service_driver(driver);
-			if (service_driver->remove)  
-				service_driver->remove(to_pcie_device(child));
+	if (dev->bus == &pcie_port_bus_type) {
+		if (dev->driver) {
+			service_driver = to_service_driver(dev->driver);
+			if (service_driver->remove)
+				service_driver->remove(to_pcie_device(dev));
 		}
-		interrupt_mode = (to_pcie_device(child))->interrupt_mode;
-		put_device(child);
-		device_unregister(child);
+		*(unsigned long*)data = (unsigned long)dev;
+		return 1;
 	}
+	return 0;
+}
+
+void pcie_port_device_remove(struct pci_dev *dev)
+{
+	struct device *device;
+	unsigned long device_addr;
+	int interrupt_mode = PCIE_PORT_INTx_MODE;
+	int status;
+
+	do {
+		status = device_for_each_child(&dev->dev, &device_addr, remove_iter);
+		if (status) {
+			device = (struct device*)device_addr;
+			interrupt_mode = (to_pcie_device(device))->interrupt_mode;
+			put_device(device);
+			device_unregister(device);
+		}
+	} while (status);
 	/* Switch to INTx by default if MSI enabled */
 	if (interrupt_mode == PCIE_PORT_MSIX_MODE)
 		pci_disable_msix(dev);
@@ -423,7 +414,7 @@ int pcie_port_service_register(struct pcie_port_service_driver *new)
 	new->driver.resume = pcie_port_resume_service;
 
 	return driver_register(&new->driver);
-} 
+}
 
 void pcie_port_service_unregister(struct pcie_port_service_driver *new)
 {

commit 7f4927c1b505eb4e679ab506bf7626af6258e6b6
Author: Pavel Machek <pavel@ucw.cz>
Date:   Sat Apr 16 15:25:33 2005 -0700

    [PATCH] fix u32 vs. pm_message_t in PCI, PCIE
    
    This fixes drivers/pci (mostly pcie stuff).
    
    Signed-off-by: Pavel Machek <pavel@suse.cz>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
index 127f64f85dc5..576285765e98 100644
--- a/drivers/pci/pcie/portdrv_core.c
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -61,7 +61,7 @@ static int pcie_port_remove_service(struct device *dev)
 
 static void pcie_port_shutdown_service(struct device *dev) {}
 
-static int pcie_port_suspend_service(struct device *dev, u32 state, u32 level)
+static int pcie_port_suspend_service(struct device *dev, pm_message_t state, u32 level)
 {
 	struct pcie_device *pciedev;
 	struct pcie_port_service_driver *driver;
@@ -76,7 +76,7 @@ static int pcie_port_suspend_service(struct device *dev, u32 state, u32 level)
 	return 0;
 }
 
-static int pcie_port_resume_service(struct device *dev, u32 state)
+static int pcie_port_resume_service(struct device *dev, u32 level)
 {
 	struct pcie_device *pciedev;
 	struct pcie_port_service_driver *driver;
@@ -317,7 +317,7 @@ int pcie_port_device_register(struct pci_dev *dev)
 }
 
 #ifdef CONFIG_PM
-int pcie_port_device_suspend(struct pci_dev *dev, u32 state)
+int pcie_port_device_suspend(struct pci_dev *dev, pm_message_t state)
 {
 	struct list_head 		*head, *tmp;
 	struct device 			*parent, *child;

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/pci/pcie/portdrv_core.c b/drivers/pci/pcie/portdrv_core.c
new file mode 100644
index 000000000000..127f64f85dc5
--- /dev/null
+++ b/drivers/pci/pcie/portdrv_core.c
@@ -0,0 +1,434 @@
+/*
+ * File:	portdrv_core.c
+ * Purpose:	PCI Express Port Bus Driver's Core Functions
+ *
+ * Copyright (C) 2004 Intel
+ * Copyright (C) Tom Long Nguyen (tom.l.nguyen@intel.com)
+ */
+
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/pm.h>
+#include <linux/pcieport_if.h>
+
+#include "portdrv.h"
+
+extern int pcie_mch_quirk;	/* MSI-quirk Indicator */
+
+static int pcie_port_probe_service(struct device *dev)
+{
+	struct pcie_device *pciedev;
+	struct pcie_port_service_driver *driver;
+	int status = -ENODEV;
+
+	if (!dev || !dev->driver)
+		return status;
+
+ 	driver = to_service_driver(dev->driver);
+	if (!driver || !driver->probe)
+		return status;
+
+	pciedev = to_pcie_device(dev);
+	status = driver->probe(pciedev, driver->id_table);
+	if (!status) {
+		printk(KERN_DEBUG "Load service driver %s on pcie device %s\n",
+			driver->name, dev->bus_id);
+		get_device(dev);
+	}
+	return status;
+}
+
+static int pcie_port_remove_service(struct device *dev)
+{
+	struct pcie_device *pciedev;
+	struct pcie_port_service_driver *driver;
+
+	if (!dev || !dev->driver)
+		return 0;
+
+	pciedev = to_pcie_device(dev);
+ 	driver = to_service_driver(dev->driver);
+	if (driver && driver->remove) { 
+		printk(KERN_DEBUG "Unload service driver %s on pcie device %s\n",
+			driver->name, dev->bus_id);
+		driver->remove(pciedev);
+		put_device(dev);
+	}
+	return 0;
+}
+
+static void pcie_port_shutdown_service(struct device *dev) {}
+
+static int pcie_port_suspend_service(struct device *dev, u32 state, u32 level)
+{
+	struct pcie_device *pciedev;
+	struct pcie_port_service_driver *driver;
+
+	if (!dev || !dev->driver)
+		return 0;
+
+	pciedev = to_pcie_device(dev);
+ 	driver = to_service_driver(dev->driver);
+	if (driver && driver->suspend)
+		driver->suspend(pciedev, state);
+	return 0;
+}
+
+static int pcie_port_resume_service(struct device *dev, u32 state)
+{
+	struct pcie_device *pciedev;
+	struct pcie_port_service_driver *driver;
+
+	if (!dev || !dev->driver)
+		return 0;
+
+	pciedev = to_pcie_device(dev);
+ 	driver = to_service_driver(dev->driver);
+
+	if (driver && driver->resume)
+		driver->resume(pciedev);
+	return 0;
+}
+
+/*
+ * release_pcie_device
+ *	
+ *	Being invoked automatically when device is being removed 
+ *	in response to device_unregister(dev) call.
+ *	Release all resources being claimed.
+ */
+static void release_pcie_device(struct device *dev)
+{
+	printk(KERN_DEBUG "Free Port Service[%s]\n", dev->bus_id);
+	kfree(to_pcie_device(dev));			
+}
+
+static int is_msi_quirked(struct pci_dev *dev)
+{
+	int port_type, quirk = 0;
+	u16 reg16;
+
+	pci_read_config_word(dev, 
+		pci_find_capability(dev, PCI_CAP_ID_EXP) + 
+		PCIE_CAPABILITIES_REG, &reg16);
+	port_type = (reg16 >> 4) & PORT_TYPE_MASK;
+	switch(port_type) {
+	case PCIE_RC_PORT:
+		if (pcie_mch_quirk == 1)
+			quirk = 1;
+		break;
+	case PCIE_SW_UPSTREAM_PORT:
+	case PCIE_SW_DOWNSTREAM_PORT:
+	default:
+		break;	
+	}
+	return quirk;
+}
+	
+static int assign_interrupt_mode(struct pci_dev *dev, int *vectors, int mask)
+{
+	int i, pos, nvec, status = -EINVAL;
+	int interrupt_mode = PCIE_PORT_INTx_MODE;
+
+	/* Set INTx as default */
+	for (i = 0, nvec = 0; i < PCIE_PORT_DEVICE_MAXSERVICES; i++) {
+		if (mask & (1 << i)) 
+			nvec++;
+		vectors[i] = dev->irq;
+	}
+	
+	/* Check MSI quirk */
+	if (is_msi_quirked(dev))
+		return interrupt_mode;
+
+	/* Select MSI-X over MSI if supported */		
+	pos = pci_find_capability(dev, PCI_CAP_ID_MSIX);
+	if (pos) {
+		struct msix_entry msix_entries[PCIE_PORT_DEVICE_MAXSERVICES] = 
+			{{0, 0}, {0, 1}, {0, 2}, {0, 3}};
+		printk("%s Found MSIX capability\n", __FUNCTION__);
+		status = pci_enable_msix(dev, msix_entries, nvec);
+		if (!status) {
+			int j = 0;
+
+			interrupt_mode = PCIE_PORT_MSIX_MODE;
+			for (i = 0; i < PCIE_PORT_DEVICE_MAXSERVICES; i++) {
+				if (mask & (1 << i)) 
+					vectors[i] = msix_entries[j++].vector;
+			}
+		}
+	} 
+	if (status) {
+		pos = pci_find_capability(dev, PCI_CAP_ID_MSI);
+		if (pos) {
+			printk("%s Found MSI capability\n", __FUNCTION__);
+			status = pci_enable_msi(dev);
+			if (!status) {
+				interrupt_mode = PCIE_PORT_MSI_MODE;
+				for (i = 0;i < PCIE_PORT_DEVICE_MAXSERVICES;i++)
+					vectors[i] = dev->irq;
+			}
+		}
+	} 
+	return interrupt_mode;
+}
+
+static int get_port_device_capability(struct pci_dev *dev)
+{
+	int services = 0, pos;
+	u16 reg16;
+	u32 reg32;
+
+	pos = pci_find_capability(dev, PCI_CAP_ID_EXP);
+	pci_read_config_word(dev, pos + PCIE_CAPABILITIES_REG, &reg16);
+	/* Hot-Plug Capable */
+	if (reg16 & PORT_TO_SLOT_MASK) {
+		pci_read_config_dword(dev, 
+			pos + PCIE_SLOT_CAPABILITIES_REG, &reg32);
+		if (reg32 & SLOT_HP_CAPABLE_MASK)
+			services |= PCIE_PORT_SERVICE_HP;
+	} 
+	/* PME Capable */
+	pos = pci_find_capability(dev, PCI_CAP_ID_PME);
+	if (pos) 
+		services |= PCIE_PORT_SERVICE_PME;
+	
+	pos = PCI_CFG_SPACE_SIZE;
+	while (pos) {
+		pci_read_config_dword(dev, pos, &reg32);
+		switch (reg32 & 0xffff) {
+		case PCI_EXT_CAP_ID_ERR:
+			services |= PCIE_PORT_SERVICE_AER;
+			pos = reg32 >> 20;
+			break;
+		case PCI_EXT_CAP_ID_VC:
+			services |= PCIE_PORT_SERVICE_VC;
+			pos = reg32 >> 20;
+			break;
+		default:
+			pos = 0;
+			break;
+		}
+	}
+
+	return services;
+}
+
+static void pcie_device_init(struct pci_dev *parent, struct pcie_device *dev, 
+	int port_type, int service_type, int irq, int irq_mode)
+{
+	struct device *device;
+
+	dev->port = parent;
+	dev->interrupt_mode = irq_mode;
+	dev->irq = irq;
+	dev->id.vendor = parent->vendor;
+	dev->id.device = parent->device;
+	dev->id.port_type = port_type;
+	dev->id.service_type = (1 << service_type);
+
+	/* Initialize generic device interface */
+	device = &dev->device;
+	memset(device, 0, sizeof(struct device));
+	INIT_LIST_HEAD(&device->node);
+	INIT_LIST_HEAD(&device->children);
+	INIT_LIST_HEAD(&device->bus_list);
+	device->bus = &pcie_port_bus_type;
+	device->driver = NULL;
+	device->driver_data = NULL; 
+	device->release = release_pcie_device;	/* callback to free pcie dev */
+	sprintf(&device->bus_id[0], "pcie%02x", 
+		get_descriptor_id(port_type, service_type));
+	device->parent = &parent->dev;
+}
+
+static struct pcie_device* alloc_pcie_device(struct pci_dev *parent, 
+	int port_type, int service_type, int irq, int irq_mode)
+{
+	struct pcie_device *device;
+
+	device = kmalloc(sizeof(struct pcie_device), GFP_KERNEL);
+	if (!device)
+		return NULL;
+
+	memset(device, 0, sizeof(struct pcie_device));
+	pcie_device_init(parent, device, port_type, service_type, irq,irq_mode);
+	printk(KERN_DEBUG "Allocate Port Service[%s]\n", device->device.bus_id);
+	return device;
+}
+
+int pcie_port_device_probe(struct pci_dev *dev)
+{
+	int pos, type;
+	u16 reg;
+
+	if (!(pos = pci_find_capability(dev, PCI_CAP_ID_EXP)))
+		return -ENODEV;
+
+	pci_read_config_word(dev, pos + PCIE_CAPABILITIES_REG, &reg);
+	type = (reg >> 4) & PORT_TYPE_MASK;
+	if (	type == PCIE_RC_PORT || type == PCIE_SW_UPSTREAM_PORT ||
+		type == PCIE_SW_DOWNSTREAM_PORT )  
+		return 0;
+ 
+	return -ENODEV;
+}
+
+int pcie_port_device_register(struct pci_dev *dev)
+{
+	int status, type, capabilities, irq_mode, i;
+	int vectors[PCIE_PORT_DEVICE_MAXSERVICES];
+	u16 reg16;
+
+	/* Get port type */
+	pci_read_config_word(dev, 
+		pci_find_capability(dev, PCI_CAP_ID_EXP) + 
+		PCIE_CAPABILITIES_REG, &reg16);
+	type = (reg16 >> 4) & PORT_TYPE_MASK;
+
+	/* Now get port services */
+	capabilities = get_port_device_capability(dev);
+	irq_mode = assign_interrupt_mode(dev, vectors, capabilities);
+
+	/* Allocate child services if any */
+	for (i = 0; i < PCIE_PORT_DEVICE_MAXSERVICES; i++) {
+		struct pcie_device *child;
+
+		if (capabilities & (1 << i)) {
+			child = alloc_pcie_device(
+				dev, 		/* parent */
+				type,		/* port type */ 
+				i,		/* service type */
+				vectors[i],	/* irq */
+				irq_mode	/* interrupt mode */);
+			if (child) { 
+				status = device_register(&child->device);
+				if (status) {
+					kfree(child);
+					continue;
+				}
+				get_device(&child->device);
+			}
+		}
+	}
+	return 0;
+}
+
+#ifdef CONFIG_PM
+int pcie_port_device_suspend(struct pci_dev *dev, u32 state)
+{
+	struct list_head 		*head, *tmp;
+	struct device 			*parent, *child;
+	struct device_driver 		*driver;
+	struct pcie_port_service_driver *service_driver;
+
+	parent = &dev->dev;
+	head = &parent->children;
+	tmp = head->next;
+	while (head != tmp) {
+		child = container_of(tmp, struct device, node);
+		tmp = tmp->next;
+		if (child->bus != &pcie_port_bus_type)
+			continue;
+		driver = child->driver;
+		if (!driver)
+			continue;
+		service_driver = to_service_driver(driver);
+		if (service_driver->suspend)  
+			service_driver->suspend(to_pcie_device(child), state);
+	}
+	return 0; 
+}
+
+int pcie_port_device_resume(struct pci_dev *dev) 
+{ 
+	struct list_head 		*head, *tmp;
+	struct device 			*parent, *child;
+	struct device_driver 		*driver;
+	struct pcie_port_service_driver *service_driver;
+
+	parent = &dev->dev;
+	head = &parent->children;
+	tmp = head->next;
+	while (head != tmp) {
+		child = container_of(tmp, struct device, node);
+		tmp = tmp->next;
+		if (child->bus != &pcie_port_bus_type)
+			continue;
+		driver = child->driver;
+		if (!driver)
+			continue;
+		service_driver = to_service_driver(driver);
+		if (service_driver->resume)  
+			service_driver->resume(to_pcie_device(child));
+	}
+	return 0; 
+
+}
+#endif
+
+void pcie_port_device_remove(struct pci_dev *dev)
+{
+	struct list_head 		*head, *tmp;
+	struct device 			*parent, *child;
+	struct device_driver 		*driver;
+	struct pcie_port_service_driver *service_driver;
+	int interrupt_mode = PCIE_PORT_INTx_MODE;
+
+	parent = &dev->dev;
+	head = &parent->children;
+	tmp = head->next;
+	while (head != tmp) {
+		child = container_of(tmp, struct device, node);
+		tmp = tmp->next;
+		if (child->bus != &pcie_port_bus_type)
+			continue;
+		driver = child->driver;
+		if (driver) { 
+			service_driver = to_service_driver(driver);
+			if (service_driver->remove)  
+				service_driver->remove(to_pcie_device(child));
+		}
+		interrupt_mode = (to_pcie_device(child))->interrupt_mode;
+		put_device(child);
+		device_unregister(child);
+	}
+	/* Switch to INTx by default if MSI enabled */
+	if (interrupt_mode == PCIE_PORT_MSIX_MODE)
+		pci_disable_msix(dev);
+	else if (interrupt_mode == PCIE_PORT_MSI_MODE)
+		pci_disable_msi(dev);
+}
+
+void pcie_port_bus_register(void)
+{
+	bus_register(&pcie_port_bus_type);
+}
+
+void pcie_port_bus_unregister(void)
+{
+	bus_unregister(&pcie_port_bus_type);
+}
+
+int pcie_port_service_register(struct pcie_port_service_driver *new)
+{
+	new->driver.name = (char *)new->name;
+	new->driver.bus = &pcie_port_bus_type;
+	new->driver.probe = pcie_port_probe_service;
+	new->driver.remove = pcie_port_remove_service;
+	new->driver.shutdown = pcie_port_shutdown_service;
+	new->driver.suspend = pcie_port_suspend_service;
+	new->driver.resume = pcie_port_resume_service;
+
+	return driver_register(&new->driver);
+} 
+
+void pcie_port_service_unregister(struct pcie_port_service_driver *new)
+{
+	driver_unregister(&new->driver);
+}
+
+EXPORT_SYMBOL(pcie_port_service_register);
+EXPORT_SYMBOL(pcie_port_service_unregister);
