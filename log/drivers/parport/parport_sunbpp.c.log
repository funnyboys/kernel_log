commit decf26f6ec25dac868782dc1751623a87d147831
Author: Joe Perches <joe@perches.com>
Date:   Fri Apr 3 14:43:16 2020 +0100

    parport: Convert printk(KERN_<LEVEL> to pr_<level>(
    
    Use the more common kernel style.
    
    Miscellanea:
    
    o Coalesce formats
    o Realign arguments
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Reviewed-by: Randy Dunlap <rdunlap@infradead.org>
    Signed-off-by: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
    Link: https://lore.kernel.org/r/20200403134325.11523-2-sudipm.mukherjee@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/parport/parport_sunbpp.c b/drivers/parport/parport_sunbpp.c
index d5a669b60c27..e840c1b5ab90 100644
--- a/drivers/parport/parport_sunbpp.c
+++ b/drivers/parport/parport_sunbpp.c
@@ -314,7 +314,7 @@ static int bpp_probe(struct platform_device *op)
 	value_tcr &= ~P_TCR_DIR;
 	sbus_writeb(value_tcr, &regs->p_tcr);
 
-	printk(KERN_INFO "%s: sunbpp at 0x%lx\n", p->name, p->base);
+	pr_info("%s: sunbpp at 0x%lx\n", p->name, p->base);
 
 	dev_set_drvdata(&op->dev, p);
 

commit 09c434b8a0047c69e48499de0107de312901e798
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 13:08:20 2019 +0100

    treewide: Add SPDX license identifier for more missed files
    
    Add SPDX license identifiers to all files which:
    
     - Have no license information of any form
    
     - Have MODULE_LICENCE("GPL*") inside which was used in the initial
       scan/conversion to ignore the file
    
    These files fall under the project license, GPL v2 only. The resulting SPDX
    license identifier is:
    
      GPL-2.0-only
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/parport/parport_sunbpp.c b/drivers/parport/parport_sunbpp.c
index 8de329546b82..d5a669b60c27 100644
--- a/drivers/parport/parport_sunbpp.c
+++ b/drivers/parport/parport_sunbpp.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /* parport_sunbpp.c: Parallel-port routines for SBUS
  * 
  * Author: Derrick J. Brashear <shadow@dementia.org>

commit faa1a47388b33623e4d504c23569188907b039a0
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Thu Jul 12 22:29:55 2018 +0100

    parport: sunbpp: fix error return code
    
    Return an error code on failure.  Change leading spaces to tab on the
    first if.
    
    Problem found using Coccinelle.
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Signed-off-by: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/parport/parport_sunbpp.c b/drivers/parport/parport_sunbpp.c
index 01cf1c1a841a..8de329546b82 100644
--- a/drivers/parport/parport_sunbpp.c
+++ b/drivers/parport/parport_sunbpp.c
@@ -286,12 +286,16 @@ static int bpp_probe(struct platform_device *op)
 
 	ops = kmemdup(&parport_sunbpp_ops, sizeof(struct parport_operations),
 		      GFP_KERNEL);
-        if (!ops)
+	if (!ops) {
+		err = -ENOMEM;
 		goto out_unmap;
+	}
 
 	dprintk(("register_port\n"));
-	if (!(p = parport_register_port((unsigned long)base, irq, dma, ops)))
+	if (!(p = parport_register_port((unsigned long)base, irq, dma, ops))) {
+		err = -ENOMEM;
 		goto out_free_ops;
+	}
 
 	p->size = size;
 	p->dev = &op->dev;

commit 2422f7e4d1138a740f228bd4983815bf3b3254e4
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Mon Oct 20 16:21:20 2014 +0200

    parport: drop owner assignment from platform_drivers
    
    A platform_driver does not need to set an owner, it will be populated by the
    driver core.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/parport/parport_sunbpp.c b/drivers/parport/parport_sunbpp.c
index dffd6d0bd15b..01cf1c1a841a 100644
--- a/drivers/parport/parport_sunbpp.c
+++ b/drivers/parport/parport_sunbpp.c
@@ -362,7 +362,6 @@ MODULE_DEVICE_TABLE(of, bpp_match);
 static struct platform_driver bpp_sbus_driver = {
 	.driver = {
 		.name = "bpp",
-		.owner = THIS_MODULE,
 		.of_match_table = bpp_match,
 	},
 	.probe		= bpp_probe,

commit 2451a84839187cd9d150ff1bfac4f5febbcce7a6
Author: Silviu-Mihai Popescu <silviupopescu1990@gmail.com>
Date:   Mon Mar 11 18:39:22 2013 +0200

    parport: use kmemdup instead of kmalloc + memcpy
    
    This replaces calls to kmalloc followed by memcpy with a single call to
    kmemdup. This was found via make coccicheck.
    
    Signed-off-by: Silviu-Mihai Popescu <silviupopescu1990@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/parport/parport_sunbpp.c b/drivers/parport/parport_sunbpp.c
index 5c4b6a1db6ca..dffd6d0bd15b 100644
--- a/drivers/parport/parport_sunbpp.c
+++ b/drivers/parport/parport_sunbpp.c
@@ -284,12 +284,11 @@ static int bpp_probe(struct platform_device *op)
 	size = resource_size(&op->resource[0]);
 	dma = PARPORT_DMA_NONE;
 
-	ops = kmalloc(sizeof(struct parport_operations), GFP_KERNEL);
+	ops = kmemdup(&parport_sunbpp_ops, sizeof(struct parport_operations),
+		      GFP_KERNEL);
         if (!ops)
 		goto out_unmap;
 
-        memcpy (ops, &parport_sunbpp_ops, sizeof(struct parport_operations));
-
 	dprintk(("register_port\n"));
 	if (!(p = parport_register_port((unsigned long)base, irq, dma, ops)))
 		goto out_free_ops;

commit 312facaf924edd4db6b81e3a1518adf56c9cd8bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Dec 21 13:23:14 2012 -0800

    Drivers: parport: remove __dev* attributes.
    
    CONFIG_HOTPLUG is going away as an option.  As a result, the __dev*
    markings need to be removed.
    
    This change removes the use of __devinit, __devexit_p, __devinitdata,
    and __devexit from these drivers.
    
    Based on patches originally written by Bill Pemberton, but redone by me
    in order to handle some of the coding style issues better, by hand.
    
    Cc: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Matt Porter <mporter@ti.com>
    Cc: Kay Sievers <kay@vrfy.org>
    Cc: Gianluca Anzolin <gianluca@sottospazio.it>
    Cc: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/parport/parport_sunbpp.c b/drivers/parport/parport_sunbpp.c
index 983a2d2df659..5c4b6a1db6ca 100644
--- a/drivers/parport/parport_sunbpp.c
+++ b/drivers/parport/parport_sunbpp.c
@@ -265,7 +265,7 @@ static struct parport_operations parport_sunbpp_ops =
 	.owner		= THIS_MODULE,
 };
 
-static int __devinit bpp_probe(struct platform_device *op)
+static int bpp_probe(struct platform_device *op)
 {
 	struct parport_operations *ops;
 	struct bpp_regs __iomem *regs;
@@ -330,7 +330,7 @@ static int __devinit bpp_probe(struct platform_device *op)
 	return err;
 }
 
-static int __devexit bpp_remove(struct platform_device *op)
+static int bpp_remove(struct platform_device *op)
 {
 	struct parport *p = dev_get_drvdata(&op->dev);
 	struct parport_operations *ops = p->ops;
@@ -367,7 +367,7 @@ static struct platform_driver bpp_sbus_driver = {
 		.of_match_table = bpp_match,
 	},
 	.probe		= bpp_probe,
-	.remove		= __devexit_p(bpp_remove),
+	.remove		= bpp_remove,
 };
 
 module_platform_driver(bpp_sbus_driver);

commit 991214386dee8a3cd9adc743778f472ac8a12bbc
Author: Matt Porter <mporter@ti.com>
Date:   Fri Apr 20 11:28:25 2012 -0400

    parport: remove unused dead code from lowlevel drivers
    
    This unused code has been untouched for over 7 years and must
    go.
    
    Signed-off-by: Matt Porter <mporter@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/parport/parport_sunbpp.c b/drivers/parport/parport_sunbpp.c
index 9390a534a2b2..983a2d2df659 100644
--- a/drivers/parport/parport_sunbpp.c
+++ b/drivers/parport/parport_sunbpp.c
@@ -82,27 +82,6 @@ static unsigned char parport_sunbpp_read_data(struct parport *p)
 	return sbus_readb(&regs->p_dr);
 }
 
-#if 0
-static void control_pc_to_sunbpp(struct parport *p, unsigned char status)
-{
-	struct bpp_regs __iomem *regs = (struct bpp_regs __iomem *)p->base;
-	unsigned char value_tcr = sbus_readb(&regs->p_tcr);
-	unsigned char value_or = sbus_readb(&regs->p_or);
-
-	if (status & PARPORT_CONTROL_STROBE) 
-		value_tcr |= P_TCR_DS;
-	if (status & PARPORT_CONTROL_AUTOFD) 
-		value_or |= P_OR_AFXN;
-	if (status & PARPORT_CONTROL_INIT) 
-		value_or |= P_OR_INIT;
-	if (status & PARPORT_CONTROL_SELECT) 
-		value_or |= P_OR_SLCT_IN;
-
-	sbus_writeb(value_or, &regs->p_or);
-	sbus_writeb(value_tcr, &regs->p_tcr);
-}
-#endif
-
 static unsigned char status_sunbpp_to_pc(struct parport *p)
 {
 	struct bpp_regs __iomem *regs = (struct bpp_regs __iomem *)p->base;

commit 782ee87702fbd0a175da64a8e71e029b19ef97bf
Author: Axel Lin <axel.lin@gmail.com>
Date:   Sun Nov 27 12:43:49 2011 +0800

    parport: convert drivers/parport/* to use module_platform_driver()
    
    This patch converts the drivers in drivers/parport/* to use the
    module_platform_driver() macro which makes the code smaller and a bit
    simpler.
    
    Cc: Ben Dooks <ben@simtec.co.uk>
    Cc: Derrick J. Brashear <shadow@dementia.org>
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/parport/parport_sunbpp.c b/drivers/parport/parport_sunbpp.c
index 910c5a26e347..9390a534a2b2 100644
--- a/drivers/parport/parport_sunbpp.c
+++ b/drivers/parport/parport_sunbpp.c
@@ -391,21 +391,10 @@ static struct platform_driver bpp_sbus_driver = {
 	.remove		= __devexit_p(bpp_remove),
 };
 
-static int __init parport_sunbpp_init(void)
-{
-	return platform_driver_register(&bpp_sbus_driver);
-}
-
-static void __exit parport_sunbpp_exit(void)
-{
-	platform_driver_unregister(&bpp_sbus_driver);
-}
+module_platform_driver(bpp_sbus_driver);
 
 MODULE_AUTHOR("Derrick J Brashear");
 MODULE_DESCRIPTION("Parport Driver for Sparc bidirectional Port");
 MODULE_SUPPORTED_DEVICE("Sparc Bidirectional Parallel Port");
 MODULE_VERSION("2.0");
 MODULE_LICENSE("GPL");
-
-module_init(parport_sunbpp_init)
-module_exit(parport_sunbpp_exit)

commit 4ebb24f707187196937607c60810d42f7112d7aa
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Tue Feb 22 20:01:33 2011 -0700

    dt/sparc: Eliminate users of of_platform_{,un}register_driver
    
    Get rid of old users of of_platform_driver in arch/sparc.  Most
    of_platform_driver users can be converted to use the platform_bus
    directly.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/parport/parport_sunbpp.c b/drivers/parport/parport_sunbpp.c
index 55ba118f1cf1..910c5a26e347 100644
--- a/drivers/parport/parport_sunbpp.c
+++ b/drivers/parport/parport_sunbpp.c
@@ -286,7 +286,7 @@ static struct parport_operations parport_sunbpp_ops =
 	.owner		= THIS_MODULE,
 };
 
-static int __devinit bpp_probe(struct platform_device *op, const struct of_device_id *match)
+static int __devinit bpp_probe(struct platform_device *op)
 {
 	struct parport_operations *ops;
 	struct bpp_regs __iomem *regs;
@@ -381,7 +381,7 @@ static const struct of_device_id bpp_match[] = {
 
 MODULE_DEVICE_TABLE(of, bpp_match);
 
-static struct of_platform_driver bpp_sbus_driver = {
+static struct platform_driver bpp_sbus_driver = {
 	.driver = {
 		.name = "bpp",
 		.owner = THIS_MODULE,
@@ -393,12 +393,12 @@ static struct of_platform_driver bpp_sbus_driver = {
 
 static int __init parport_sunbpp_init(void)
 {
-	return of_register_platform_driver(&bpp_sbus_driver);
+	return platform_driver_register(&bpp_sbus_driver);
 }
 
 static void __exit parport_sunbpp_exit(void)
 {
-	of_unregister_platform_driver(&bpp_sbus_driver);
+	platform_driver_unregister(&bpp_sbus_driver);
 }
 
 MODULE_AUTHOR("Derrick J Brashear");

commit 2dc11581376829303b98eadb2de253bee065a56a
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Fri Aug 6 09:25:50 2010 -0600

    of/device: Replace struct of_device with struct platform_device
    
    of_device is just an alias for platform_device, so remove it entirely.  Also
    replace to_of_device() with to_platform_device() and update comment blocks.
    
    This patch was initially generated from the following semantic patch, and then
    edited by hand to pick up the bits that coccinelle didn't catch.
    
    @@
    @@
    -struct of_device
    +struct platform_device
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Reviewed-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/parport/parport_sunbpp.c b/drivers/parport/parport_sunbpp.c
index 210a6441a066..55ba118f1cf1 100644
--- a/drivers/parport/parport_sunbpp.c
+++ b/drivers/parport/parport_sunbpp.c
@@ -286,7 +286,7 @@ static struct parport_operations parport_sunbpp_ops =
 	.owner		= THIS_MODULE,
 };
 
-static int __devinit bpp_probe(struct of_device *op, const struct of_device_id *match)
+static int __devinit bpp_probe(struct platform_device *op, const struct of_device_id *match)
 {
 	struct parport_operations *ops;
 	struct bpp_regs __iomem *regs;
@@ -351,7 +351,7 @@ static int __devinit bpp_probe(struct of_device *op, const struct of_device_id *
 	return err;
 }
 
-static int __devexit bpp_remove(struct of_device *op)
+static int __devexit bpp_remove(struct platform_device *op)
 {
 	struct parport *p = dev_get_drvdata(&op->dev);
 	struct parport_operations *ops = p->ops;

commit 1ab1d63a85cee2545272f63a7644e9f855cb65d0
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Thu Jun 24 15:14:37 2010 -0600

    of/platform: remove all of_bus_type and of_platform_bus_type references
    
    Both of_bus_type and of_platform_bus_type are just #define aliases
    for the platform bus.  This patch removes all references to them and
    switches to the of_register_platform_driver()/of_unregister_platform_driver()
    API for registering.
    
    Subsequent patches will convert each user of of_register_platform_driver()
    into plain platform_drivers without the of_platform_driver shim.  At which
    point the of_register_platform_driver()/of_unregister_platform_driver()
    functions can be removed.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Acked-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/parport/parport_sunbpp.c b/drivers/parport/parport_sunbpp.c
index 3cdfe96e8999..210a6441a066 100644
--- a/drivers/parport/parport_sunbpp.c
+++ b/drivers/parport/parport_sunbpp.c
@@ -393,12 +393,12 @@ static struct of_platform_driver bpp_sbus_driver = {
 
 static int __init parport_sunbpp_init(void)
 {
-	return of_register_driver(&bpp_sbus_driver, &of_bus_type);
+	return of_register_platform_driver(&bpp_sbus_driver);
 }
 
 static void __exit parport_sunbpp_exit(void)
 {
-	of_unregister_driver(&bpp_sbus_driver);
+	of_unregister_platform_driver(&bpp_sbus_driver);
 }
 
 MODULE_AUTHOR("Derrick J Brashear");

commit 1636f8ac2b08410df4766449f7c86b912443cd99
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Fri Jun 18 11:09:58 2010 -0600

    sparc/of: Move of_device fields into struct pdev_archdata
    
    This patch moves SPARC architecture specific data members out of
    struct of_device and into the pdev_archdata structure.  The reason
    for this change is to unify the struct of_device definition amongst
    all the architectures.  It also remvoes the .sysdata, .slot, .portid
    and .clock_freq properties because they aren't actually used by
    anything.
    
    A subsequent patch will replace struct of_device entirely with struct
    platform_device and the of_platform support code will share common
    routines with the platform bus (but the bus instances themselves can
    remain separate).
    
    This patch also adds 'struct resources *resource' and num_resources
    to match the fields defined in struct platform_device.  After this
    change, 'struct platform_device' can be used as a drop-in replacement
    for 'struct of_platform'.
    
    This change is in preparation for merging the of_platform_bus_type
    with the platform_bus_type.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Acked-by: David S. Miller <davem@davemloft.net>
    Cc: Stephen Rothwell <sfr@canb.auug.org.au>

diff --git a/drivers/parport/parport_sunbpp.c b/drivers/parport/parport_sunbpp.c
index 9a5b4b894161..3cdfe96e8999 100644
--- a/drivers/parport/parport_sunbpp.c
+++ b/drivers/parport/parport_sunbpp.c
@@ -295,7 +295,7 @@ static int __devinit bpp_probe(struct of_device *op, const struct of_device_id *
 	void __iomem *base;
 	struct parport *p;
 
-	irq = op->irqs[0];
+	irq = op->archdata.irqs[0];
 	base = of_ioremap(&op->resource[0], 0,
 			  resource_size(&op->resource[0]),
 			  "sunbpp");

commit 4018294b53d1dae026880e45f174c1cc63b5d435
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Tue Apr 13 16:13:02 2010 -0700

    of: Remove duplicate fields from of_platform_driver
    
    .name, .match_table and .owner are duplicated in both of_platform_driver
    and device_driver.  This patch is a removes the extra copies from struct
    of_platform_driver and converts all users to the device_driver members.
    
    This patch is a pretty mechanical change.  The usage model doesn't change
    and if any drivers have been missed, or if anything has been fixed up
    incorrectly, then it will fail with a compile time error, and the fixup
    will be trivial.  This patch looks big and scary because it touches so
    many files, but it should be pretty safe.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Acked-by: Sean MacLennan <smaclennan@pikatech.com>

diff --git a/drivers/parport/parport_sunbpp.c b/drivers/parport/parport_sunbpp.c
index 065f229580d5..9a5b4b894161 100644
--- a/drivers/parport/parport_sunbpp.c
+++ b/drivers/parport/parport_sunbpp.c
@@ -382,8 +382,11 @@ static const struct of_device_id bpp_match[] = {
 MODULE_DEVICE_TABLE(of, bpp_match);
 
 static struct of_platform_driver bpp_sbus_driver = {
-	.name		= "bpp",
-	.match_table	= bpp_match,
+	.driver = {
+		.name = "bpp",
+		.owner = THIS_MODULE,
+		.of_match_table = bpp_match,
+	},
 	.probe		= bpp_probe,
 	.remove		= __devexit_p(bpp_remove),
 };

commit fd098316ef533e8441576f020ead4beab93154ce
Author: David S. Miller <davem@davemloft.net>
Date:   Sun Aug 31 01:23:17 2008 -0700

    sparc: Annotate of_device_id arrays with const or __initdata.
    
    As suggested by Stephen Rothwell.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/parport/parport_sunbpp.c b/drivers/parport/parport_sunbpp.c
index e4f00c6dfe09..065f229580d5 100644
--- a/drivers/parport/parport_sunbpp.c
+++ b/drivers/parport/parport_sunbpp.c
@@ -372,7 +372,7 @@ static int __devexit bpp_remove(struct of_device *op)
 	return 0;
 }
 
-static struct of_device_id bpp_match[] = {
+static const struct of_device_id bpp_match[] = {
 	{
 		.name = "SUNW,bpp",
 	},

commit 27167e0e63a9c53477a7de1c55888bd660c3f9a6
Author: David S. Miller <davem@davemloft.net>
Date:   Wed Aug 27 00:17:50 2008 -0700

    parport_sunbpp: Convert to pure OF driver.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/parport/parport_sunbpp.c b/drivers/parport/parport_sunbpp.c
index 9d595aa91e46..e4f00c6dfe09 100644
--- a/drivers/parport/parport_sunbpp.c
+++ b/drivers/parport/parport_sunbpp.c
@@ -26,6 +26,8 @@
 #include <linux/kernel.h>
 #include <linux/slab.h>
 #include <linux/init.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
 
 #include <linux/parport.h>
 
@@ -34,7 +36,6 @@
 
 #include <asm/io.h>
 #include <asm/oplib.h>           /* OpenProm Library */
-#include <asm/sbus.h>
 #include <asm/dma.h>             /* BPP uses LSI 64854 for DMA */
 #include <asm/irq.h>
 #include <asm/sunbpp.h>
@@ -285,38 +286,37 @@ static struct parport_operations parport_sunbpp_ops =
 	.owner		= THIS_MODULE,
 };
 
-static int __devinit init_one_port(struct sbus_dev *sdev)
+static int __devinit bpp_probe(struct of_device *op, const struct of_device_id *match)
 {
-	struct parport *p;
-	/* at least in theory there may be a "we don't dma" case */
 	struct parport_operations *ops;
-	void __iomem *base;
-	int irq, dma, err = 0, size;
 	struct bpp_regs __iomem *regs;
+	int irq, dma, err = 0, size;
 	unsigned char value_tcr;
+	void __iomem *base;
+	struct parport *p;
 
-	irq = sdev->irqs[0];
-	base = sbus_ioremap(&sdev->resource[0], 0,
-			    sdev->reg_addrs[0].reg_size, 
-			    "sunbpp");
+	irq = op->irqs[0];
+	base = of_ioremap(&op->resource[0], 0,
+			  resource_size(&op->resource[0]),
+			  "sunbpp");
 	if (!base)
 		return -ENODEV;
 
-	size = sdev->reg_addrs[0].reg_size;
+	size = resource_size(&op->resource[0]);
 	dma = PARPORT_DMA_NONE;
 
 	ops = kmalloc(sizeof(struct parport_operations), GFP_KERNEL);
         if (!ops)
 		goto out_unmap;
 
-        memcpy (ops, &parport_sunbpp_ops, sizeof (struct parport_operations));
+        memcpy (ops, &parport_sunbpp_ops, sizeof(struct parport_operations));
 
 	dprintk(("register_port\n"));
 	if (!(p = parport_register_port((unsigned long)base, irq, dma, ops)))
 		goto out_free_ops;
 
 	p->size = size;
-	p->dev = &sdev->ofdev.dev;
+	p->dev = &op->dev;
 
 	if ((err = request_irq(p->irq, parport_irq_handler,
 			       IRQF_SHARED, p->name, p)) != 0) {
@@ -333,7 +333,7 @@ static int __devinit init_one_port(struct sbus_dev *sdev)
 
 	printk(KERN_INFO "%s: sunbpp at 0x%lx\n", p->name, p->base);
 
-	dev_set_drvdata(&sdev->ofdev.dev, p);
+	dev_set_drvdata(&op->dev, p);
 
 	parport_announce_port(p);
 
@@ -346,21 +346,14 @@ static int __devinit init_one_port(struct sbus_dev *sdev)
 	kfree(ops);
 
 out_unmap:
-	sbus_iounmap(base, size);
+	of_iounmap(&op->resource[0], base, size);
 
 	return err;
 }
 
-static int __devinit bpp_probe(struct of_device *dev, const struct of_device_id *match)
-{
-	struct sbus_dev *sdev = to_sbus_device(&dev->dev);
-
-	return init_one_port(sdev);
-}
-
-static int __devexit bpp_remove(struct of_device *dev)
+static int __devexit bpp_remove(struct of_device *op)
 {
-	struct parport *p = dev_get_drvdata(&dev->dev);
+	struct parport *p = dev_get_drvdata(&op->dev);
 	struct parport_operations *ops = p->ops;
 
 	parport_remove_port(p);
@@ -370,11 +363,11 @@ static int __devexit bpp_remove(struct of_device *dev)
 		free_irq(p->irq, p);
 	}
 
-	sbus_iounmap((void __iomem *) p->base, p->size);
+	of_iounmap(&op->resource[0], (void __iomem *) p->base, p->size);
 	parport_put_port(p);
 	kfree(ops);
 
-	dev_set_drvdata(&dev->dev, NULL);
+	dev_set_drvdata(&op->dev, NULL);
 
 	return 0;
 }
@@ -397,7 +390,7 @@ static struct of_platform_driver bpp_sbus_driver = {
 
 static int __init parport_sunbpp_init(void)
 {
-	return of_register_driver(&bpp_sbus_driver, &sbus_bus_type);
+	return of_register_driver(&bpp_sbus_driver, &of_bus_type);
 }
 
 static void __exit parport_sunbpp_exit(void)

commit 3f2e40df0e1d7694224c3083b0bebd129039a40a
Author: Jeff Garzik <jeff@garzik.org>
Date:   Fri Oct 19 01:42:14 2007 -0400

    [PARPORT] Consolidate code copies into a single generic irq handler
    
    Several arches used the exact same code for their parport irq handling.
    Make that code generic, in parport_irq_handler().
    
    Also, s/__inline__/inline/ in include/linux/parport.h.
    
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/parport/parport_sunbpp.c b/drivers/parport/parport_sunbpp.c
index d27019c2f860..9d595aa91e46 100644
--- a/drivers/parport/parport_sunbpp.c
+++ b/drivers/parport/parport_sunbpp.c
@@ -46,12 +46,6 @@
 #define dprintk(x)
 #endif
 
-static irqreturn_t parport_sunbpp_interrupt(int irq, void *dev_id)
-{
-	parport_generic_irq(irq, (struct parport *) dev_id);
-	return IRQ_HANDLED;
-}
-
 static void parport_sunbpp_disable_irq(struct parport *p)
 {
 	struct bpp_regs __iomem *regs = (struct bpp_regs __iomem *)p->base;
@@ -324,7 +318,7 @@ static int __devinit init_one_port(struct sbus_dev *sdev)
 	p->size = size;
 	p->dev = &sdev->ofdev.dev;
 
-	if ((err = request_irq(p->irq, parport_sunbpp_interrupt,
+	if ((err = request_irq(p->irq, parport_irq_handler,
 			       IRQF_SHARED, p->name, p)) != 0) {
 		goto out_put_port;
 	}

commit c15a3837d2aa30e3ea41aed49d80abed355ab6bd
Author: David Brownell <david-b@pacbell.net>
Date:   Tue May 8 00:27:35 2007 -0700

    parport->dev driver model support
    
    Currently a parport_driver can't get a handle on the device node for the
    underlying parport (PNPACPI, PCI, etc).  That prevents correct placement of
    sysfs child nodes, which can affect things like power management.
    
    This patch adds a field to "struct parport" pointing to that device node, and
    updates non-legacy port drivers to initialize that device pointer.  That field
    replaces the analagous PCI-only support in parport_pc.
    
    [akpm@linux-foundation.org: fix powerpc build]
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/parport/parport_sunbpp.c b/drivers/parport/parport_sunbpp.c
index 400bb90084cf..d27019c2f860 100644
--- a/drivers/parport/parport_sunbpp.c
+++ b/drivers/parport/parport_sunbpp.c
@@ -322,6 +322,7 @@ static int __devinit init_one_port(struct sbus_dev *sdev)
 		goto out_free_ops;
 
 	p->size = size;
+	p->dev = &sdev->ofdev.dev;
 
 	if ((err = request_irq(p->irq, parport_sunbpp_interrupt,
 			       IRQF_SHARED, p->name, p)) != 0) {

commit 5a68b2e346f043820e2ba0cde57cc75b4561c124
Author: David S. Miller <davem@sunset.davemloft.net>
Date:   Mon Apr 23 23:33:17 2007 -0700

    [PARPORT] SUNBPP: Fix OOPS when debugging is enabled.
    
    The debugging code would dereference __iomem pointers instead
    of going through sbus_{read,write}{b,w,l}().
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/parport/parport_sunbpp.c b/drivers/parport/parport_sunbpp.c
index 9793533276ec..400bb90084cf 100644
--- a/drivers/parport/parport_sunbpp.c
+++ b/drivers/parport/parport_sunbpp.c
@@ -126,7 +126,7 @@ static unsigned char status_sunbpp_to_pc(struct parport *p)
 	if (!(value_tcr & P_TCR_BUSY))
 		bits |= PARPORT_STATUS_BUSY;
 
-	dprintk((KERN_DEBUG "tcr 0x%x ir 0x%x\n", regs->p_tcr, regs->p_ir));
+	dprintk((KERN_DEBUG "tcr 0x%x ir 0x%x\n", value_tcr, value_ir));
 	dprintk((KERN_DEBUG "read status 0x%x\n", bits));
 	return bits;
 }
@@ -147,7 +147,7 @@ static unsigned char control_sunbpp_to_pc(struct parport *p)
 	if (value_or & P_OR_SLCT_IN)
 		bits |= PARPORT_CONTROL_SELECT;
 
-	dprintk((KERN_DEBUG "tcr 0x%x or 0x%x\n", regs->p_tcr, regs->p_or));
+	dprintk((KERN_DEBUG "tcr 0x%x or 0x%x\n", value_tcr, value_or));
 	dprintk((KERN_DEBUG "read control 0x%x\n", bits));
 	return bits;
 }
@@ -165,7 +165,8 @@ static unsigned char parport_sunbpp_frob_control(struct parport *p,
 	unsigned char value_tcr = sbus_readb(&regs->p_tcr);
 	unsigned char value_or = sbus_readb(&regs->p_or);
 
-	dprintk((KERN_DEBUG "frob1: tcr 0x%x or 0x%x\n", regs->p_tcr, regs->p_or));
+	dprintk((KERN_DEBUG "frob1: tcr 0x%x or 0x%x\n",
+		 value_tcr, value_or));
 	if (mask & PARPORT_CONTROL_STROBE) {
 		if (val & PARPORT_CONTROL_STROBE) {
 			value_tcr &= ~P_TCR_DS;
@@ -197,7 +198,8 @@ static unsigned char parport_sunbpp_frob_control(struct parport *p,
 
 	sbus_writeb(value_or, &regs->p_or);
 	sbus_writeb(value_tcr, &regs->p_tcr);
-	dprintk((KERN_DEBUG "frob2: tcr 0x%x or 0x%x\n", regs->p_tcr, regs->p_or));
+	dprintk((KERN_DEBUG "frob2: tcr 0x%x or 0x%x\n",
+		 value_tcr, value_or));
 	return parport_sunbpp_read_control(p);
 }
 

commit 0d84438d98777b0f9425d39121c42f47a06878ca
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Sun Oct 8 14:30:44 2006 +0100

    [PATCH] sparc32 pt_regs fixes
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/parport/parport_sunbpp.c b/drivers/parport/parport_sunbpp.c
index d758c90c86af..9793533276ec 100644
--- a/drivers/parport/parport_sunbpp.c
+++ b/drivers/parport/parport_sunbpp.c
@@ -48,7 +48,7 @@
 
 static irqreturn_t parport_sunbpp_interrupt(int irq, void *dev_id)
 {
-	parport_generic_irq(irq, (struct parport *) dev_id, regs);
+	parport_generic_irq(irq, (struct parport *) dev_id);
 	return IRQ_HANDLED;
 }
 

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/drivers/parport/parport_sunbpp.c b/drivers/parport/parport_sunbpp.c
index fac333b279bf..d758c90c86af 100644
--- a/drivers/parport/parport_sunbpp.c
+++ b/drivers/parport/parport_sunbpp.c
@@ -46,7 +46,7 @@
 #define dprintk(x)
 #endif
 
-static irqreturn_t parport_sunbpp_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t parport_sunbpp_interrupt(int irq, void *dev_id)
 {
 	parport_generic_irq(irq, (struct parport *) dev_id, regs);
 	return IRQ_HANDLED;

commit dace145374b8e39aeb920304c358ab5e220341ab
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jul 1 19:29:38 2006 -0700

    [PATCH] irq-flags: misc drivers: Use the new IRQF_ constants
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/parport/parport_sunbpp.c b/drivers/parport/parport_sunbpp.c
index 7c43c5392bed..fac333b279bf 100644
--- a/drivers/parport/parport_sunbpp.c
+++ b/drivers/parport/parport_sunbpp.c
@@ -322,7 +322,7 @@ static int __devinit init_one_port(struct sbus_dev *sdev)
 	p->size = size;
 
 	if ((err = request_irq(p->irq, parport_sunbpp_interrupt,
-			       SA_SHIRQ, p->name, p)) != 0) {
+			       IRQF_SHARED, p->name, p)) != 0) {
 		goto out_put_port;
 	}
 

commit 09ec431476aa6efca436faf1e1aaadb4fa283972
Author: David S. Miller <davem@sunset.davemloft.net>
Date:   Sun Jun 25 00:04:43 2006 -0700

    [PARPORT] sunbpp: Fix typo.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/parport/parport_sunbpp.c b/drivers/parport/parport_sunbpp.c
index 69a4bbd4cbee..7c43c5392bed 100644
--- a/drivers/parport/parport_sunbpp.c
+++ b/drivers/parport/parport_sunbpp.c
@@ -389,7 +389,7 @@ static struct of_device_id bpp_match[] = {
 	{},
 };
 
-MODULE_DEVICE_TABLE(of, qec_sbus_match);
+MODULE_DEVICE_TABLE(of, bpp_match);
 
 static struct of_platform_driver bpp_sbus_driver = {
 	.name		= "bpp",

commit 4f62d158a32d9f470377a7bd6dcb797b42afe5f3
Author: David S. Miller <davem@sunset.davemloft.net>
Date:   Fri Jun 23 22:22:13 2006 -0700

    [PARPORT] sunbpp: Convert to new SBUS device framework.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/parport/parport_sunbpp.c b/drivers/parport/parport_sunbpp.c
index 36a1556e64c7..69a4bbd4cbee 100644
--- a/drivers/parport/parport_sunbpp.c
+++ b/drivers/parport/parport_sunbpp.c
@@ -1,5 +1,4 @@
-/* $Id: parport_sunbpp.c,v 1.12 2001/05/26 03:01:42 davem Exp $
- * Parallel-port routines for Sun architecture
+/* parport_sunbpp.c: Parallel-port routines for SBUS
  * 
  * Author: Derrick J. Brashear <shadow@dementia.org>
  *
@@ -14,6 +13,9 @@
  *          Gus Baldauf (gbaldauf@ix.netcom.com)
  *          Peter Zaitcev
  *          Tom Dyas
+ *
+ * Updated to new SBUS device framework: David S. Miller <davem@davemloft.net>
+ * 
  */
 
 #include <linux/string.h>
@@ -287,14 +289,7 @@ static struct parport_operations parport_sunbpp_ops =
 	.owner		= THIS_MODULE,
 };
 
-typedef struct {
-	struct list_head list;
-	struct parport *port;
-} Node;
-/* no locks, everything's serialized */
-static LIST_HEAD(port_list);
-
-static int __init init_one_port(struct sbus_dev *sdev)
+static int __devinit init_one_port(struct sbus_dev *sdev)
 {
 	struct parport *p;
 	/* at least in theory there may be a "we don't dma" case */
@@ -303,109 +298,120 @@ static int __init init_one_port(struct sbus_dev *sdev)
 	int irq, dma, err = 0, size;
 	struct bpp_regs __iomem *regs;
 	unsigned char value_tcr;
-	Node *node;
-
-	dprintk((KERN_DEBUG "init_one_port(%p): ranges, alloc_io, ", sdev));
-	node = kmalloc(sizeof(Node), GFP_KERNEL);
-	if (!node)
-		goto out0;
 
 	irq = sdev->irqs[0];
 	base = sbus_ioremap(&sdev->resource[0], 0,
 			    sdev->reg_addrs[0].reg_size, 
 			    "sunbpp");
 	if (!base)
-		goto out1;
+		return -ENODEV;
 
 	size = sdev->reg_addrs[0].reg_size;
 	dma = PARPORT_DMA_NONE;
 
-	dprintk(("alloc(ppops), "));
-	ops = kmalloc (sizeof (struct parport_operations), GFP_KERNEL);
+	ops = kmalloc(sizeof(struct parport_operations), GFP_KERNEL);
         if (!ops)
-		goto out2;
+		goto out_unmap;
 
         memcpy (ops, &parport_sunbpp_ops, sizeof (struct parport_operations));
 
 	dprintk(("register_port\n"));
 	if (!(p = parport_register_port((unsigned long)base, irq, dma, ops)))
-		goto out3;
+		goto out_free_ops;
 
 	p->size = size;
 
-	dprintk((KERN_DEBUG "init_one_port: request_irq(%08x:%p:%x:%s:%p) ",
-		p->irq, parport_sunbpp_interrupt, SA_SHIRQ, p->name, p));
 	if ((err = request_irq(p->irq, parport_sunbpp_interrupt,
 			       SA_SHIRQ, p->name, p)) != 0) {
-		dprintk(("ERROR %d\n", err));
-		goto out4;
+		goto out_put_port;
 	}
-	dprintk(("OK\n"));
+
 	parport_sunbpp_enable_irq(p);
 
 	regs = (struct bpp_regs __iomem *)p->base;
-	dprintk((KERN_DEBUG "forward\n"));
+
 	value_tcr = sbus_readb(&regs->p_tcr);
 	value_tcr &= ~P_TCR_DIR;
 	sbus_writeb(value_tcr, &regs->p_tcr);
 
 	printk(KERN_INFO "%s: sunbpp at 0x%lx\n", p->name, p->base);
-	node->port = p;
-	list_add(&node->list, &port_list);
-	parport_announce_port (p);
 
-	return 1;
+	dev_set_drvdata(&sdev->ofdev.dev, p);
+
+	parport_announce_port(p);
+
+	return 0;
 
-out4:
+out_put_port:
 	parport_put_port(p);
-out3:
+
+out_free_ops:
 	kfree(ops);
-out2:
+
+out_unmap:
 	sbus_iounmap(base, size);
-out1:
-	kfree(node);
-out0:
+
 	return err;
 }
 
-static int __init parport_sunbpp_init(void)
+static int __devinit bpp_probe(struct of_device *dev, const struct of_device_id *match)
 {
-        struct sbus_bus *sbus;
-        struct sbus_dev *sdev;
-	int count = 0;
-
-	for_each_sbus(sbus) {
-		for_each_sbusdev(sdev, sbus) {
-			if (!strcmp(sdev->prom_name, "SUNW,bpp"))
-				count += init_one_port(sdev);
-		}
+	struct sbus_dev *sdev = to_sbus_device(&dev->dev);
+
+	return init_one_port(sdev);
+}
+
+static int __devexit bpp_remove(struct of_device *dev)
+{
+	struct parport *p = dev_get_drvdata(&dev->dev);
+	struct parport_operations *ops = p->ops;
+
+	parport_remove_port(p);
+
+	if (p->irq != PARPORT_IRQ_NONE) {
+		parport_sunbpp_disable_irq(p);
+		free_irq(p->irq, p);
 	}
-	return count ? 0 : -ENODEV;
+
+	sbus_iounmap((void __iomem *) p->base, p->size);
+	parport_put_port(p);
+	kfree(ops);
+
+	dev_set_drvdata(&dev->dev, NULL);
+
+	return 0;
+}
+
+static struct of_device_id bpp_match[] = {
+	{
+		.name = "SUNW,bpp",
+	},
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, qec_sbus_match);
+
+static struct of_platform_driver bpp_sbus_driver = {
+	.name		= "bpp",
+	.match_table	= bpp_match,
+	.probe		= bpp_probe,
+	.remove		= __devexit_p(bpp_remove),
+};
+
+static int __init parport_sunbpp_init(void)
+{
+	return of_register_driver(&bpp_sbus_driver, &sbus_bus_type);
 }
 
 static void __exit parport_sunbpp_exit(void)
 {
-	while (!list_empty(&port_list)) {
-		Node *node = list_entry(port_list.next, Node, list);
-		struct parport *p = node->port;
-		struct parport_operations *ops = p->ops;
-		parport_remove_port(p);
-
-		if (p->irq != PARPORT_IRQ_NONE) {
-			parport_sunbpp_disable_irq(p);
-			free_irq(p->irq, p);
-		}
-		sbus_iounmap((void __iomem *)p->base, p->size);
-		parport_put_port(p);
-		kfree (ops);
-		list_del(&node->list);
-		kfree (node);
-	}
+	of_unregister_driver(&bpp_sbus_driver);
 }
 
 MODULE_AUTHOR("Derrick J Brashear");
 MODULE_DESCRIPTION("Parport Driver for Sparc bidirectional Port");
 MODULE_SUPPORTED_DEVICE("Sparc Bidirectional Parallel Port");
+MODULE_VERSION("2.0");
 MODULE_LICENSE("GPL");
 
 module_init(parport_sunbpp_init)

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/parport/parport_sunbpp.c b/drivers/parport/parport_sunbpp.c
new file mode 100644
index 000000000000..36a1556e64c7
--- /dev/null
+++ b/drivers/parport/parport_sunbpp.c
@@ -0,0 +1,412 @@
+/* $Id: parport_sunbpp.c,v 1.12 2001/05/26 03:01:42 davem Exp $
+ * Parallel-port routines for Sun architecture
+ * 
+ * Author: Derrick J. Brashear <shadow@dementia.org>
+ *
+ * based on work by:
+ *          Phil Blundell <philb@gnu.org>
+ *          Tim Waugh <tim@cyberelk.demon.co.uk>
+ *	    Jose Renau <renau@acm.org>
+ *          David Campbell <campbell@tirian.che.curtin.edu.au>
+ *          Grant Guenther <grant@torque.net>
+ *          Eddie C. Dost <ecd@skynet.be>
+ *          Stephen Williams (steve@icarus.com)
+ *          Gus Baldauf (gbaldauf@ix.netcom.com)
+ *          Peter Zaitcev
+ *          Tom Dyas
+ */
+
+#include <linux/string.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/ioport.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+
+#include <linux/parport.h>
+
+#include <asm/ptrace.h>
+#include <linux/interrupt.h>
+
+#include <asm/io.h>
+#include <asm/oplib.h>           /* OpenProm Library */
+#include <asm/sbus.h>
+#include <asm/dma.h>             /* BPP uses LSI 64854 for DMA */
+#include <asm/irq.h>
+#include <asm/sunbpp.h>
+
+#undef __SUNBPP_DEBUG
+#ifdef __SUNBPP_DEBUG
+#define dprintk(x) printk x
+#else
+#define dprintk(x)
+#endif
+
+static irqreturn_t parport_sunbpp_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	parport_generic_irq(irq, (struct parport *) dev_id, regs);
+	return IRQ_HANDLED;
+}
+
+static void parport_sunbpp_disable_irq(struct parport *p)
+{
+	struct bpp_regs __iomem *regs = (struct bpp_regs __iomem *)p->base;
+	u32 tmp;
+
+	tmp = sbus_readl(&regs->p_csr);
+	tmp &= ~DMA_INT_ENAB;
+	sbus_writel(tmp, &regs->p_csr);
+}
+
+static void parport_sunbpp_enable_irq(struct parport *p)
+{
+	struct bpp_regs __iomem *regs = (struct bpp_regs __iomem *)p->base;
+	u32 tmp;
+
+	tmp = sbus_readl(&regs->p_csr);
+	tmp |= DMA_INT_ENAB;
+	sbus_writel(tmp, &regs->p_csr);
+}
+
+static void parport_sunbpp_write_data(struct parport *p, unsigned char d)
+{
+	struct bpp_regs __iomem *regs = (struct bpp_regs __iomem *)p->base;
+
+	sbus_writeb(d, &regs->p_dr);
+	dprintk((KERN_DEBUG "wrote 0x%x\n", d));
+}
+
+static unsigned char parport_sunbpp_read_data(struct parport *p)
+{
+	struct bpp_regs __iomem *regs = (struct bpp_regs __iomem *)p->base;
+
+	return sbus_readb(&regs->p_dr);
+}
+
+#if 0
+static void control_pc_to_sunbpp(struct parport *p, unsigned char status)
+{
+	struct bpp_regs __iomem *regs = (struct bpp_regs __iomem *)p->base;
+	unsigned char value_tcr = sbus_readb(&regs->p_tcr);
+	unsigned char value_or = sbus_readb(&regs->p_or);
+
+	if (status & PARPORT_CONTROL_STROBE) 
+		value_tcr |= P_TCR_DS;
+	if (status & PARPORT_CONTROL_AUTOFD) 
+		value_or |= P_OR_AFXN;
+	if (status & PARPORT_CONTROL_INIT) 
+		value_or |= P_OR_INIT;
+	if (status & PARPORT_CONTROL_SELECT) 
+		value_or |= P_OR_SLCT_IN;
+
+	sbus_writeb(value_or, &regs->p_or);
+	sbus_writeb(value_tcr, &regs->p_tcr);
+}
+#endif
+
+static unsigned char status_sunbpp_to_pc(struct parport *p)
+{
+	struct bpp_regs __iomem *regs = (struct bpp_regs __iomem *)p->base;
+	unsigned char bits = 0;
+	unsigned char value_tcr = sbus_readb(&regs->p_tcr);
+	unsigned char value_ir = sbus_readb(&regs->p_ir);
+
+	if (!(value_ir & P_IR_ERR))
+		bits |= PARPORT_STATUS_ERROR;
+	if (!(value_ir & P_IR_SLCT))
+		bits |= PARPORT_STATUS_SELECT;
+	if (!(value_ir & P_IR_PE))
+		bits |= PARPORT_STATUS_PAPEROUT;
+	if (value_tcr & P_TCR_ACK)
+		bits |= PARPORT_STATUS_ACK;
+	if (!(value_tcr & P_TCR_BUSY))
+		bits |= PARPORT_STATUS_BUSY;
+
+	dprintk((KERN_DEBUG "tcr 0x%x ir 0x%x\n", regs->p_tcr, regs->p_ir));
+	dprintk((KERN_DEBUG "read status 0x%x\n", bits));
+	return bits;
+}
+
+static unsigned char control_sunbpp_to_pc(struct parport *p)
+{
+	struct bpp_regs __iomem *regs = (struct bpp_regs __iomem *)p->base;
+	unsigned char bits = 0;
+	unsigned char value_tcr = sbus_readb(&regs->p_tcr);
+	unsigned char value_or = sbus_readb(&regs->p_or);
+
+	if (!(value_tcr & P_TCR_DS))
+		bits |= PARPORT_CONTROL_STROBE;
+	if (!(value_or & P_OR_AFXN))
+		bits |= PARPORT_CONTROL_AUTOFD;
+	if (!(value_or & P_OR_INIT))
+		bits |= PARPORT_CONTROL_INIT;
+	if (value_or & P_OR_SLCT_IN)
+		bits |= PARPORT_CONTROL_SELECT;
+
+	dprintk((KERN_DEBUG "tcr 0x%x or 0x%x\n", regs->p_tcr, regs->p_or));
+	dprintk((KERN_DEBUG "read control 0x%x\n", bits));
+	return bits;
+}
+
+static unsigned char parport_sunbpp_read_control(struct parport *p)
+{
+	return control_sunbpp_to_pc(p);
+}
+
+static unsigned char parport_sunbpp_frob_control(struct parport *p,
+						 unsigned char mask,
+						 unsigned char val)
+{
+	struct bpp_regs __iomem *regs = (struct bpp_regs __iomem *)p->base;
+	unsigned char value_tcr = sbus_readb(&regs->p_tcr);
+	unsigned char value_or = sbus_readb(&regs->p_or);
+
+	dprintk((KERN_DEBUG "frob1: tcr 0x%x or 0x%x\n", regs->p_tcr, regs->p_or));
+	if (mask & PARPORT_CONTROL_STROBE) {
+		if (val & PARPORT_CONTROL_STROBE) {
+			value_tcr &= ~P_TCR_DS;
+		} else {
+			value_tcr |= P_TCR_DS;
+		}
+	}
+	if (mask & PARPORT_CONTROL_AUTOFD) {
+		if (val & PARPORT_CONTROL_AUTOFD) {
+			value_or &= ~P_OR_AFXN;
+		} else {
+			value_or |= P_OR_AFXN;
+		}
+	}
+	if (mask & PARPORT_CONTROL_INIT) {
+		if (val & PARPORT_CONTROL_INIT) {
+			value_or &= ~P_OR_INIT;
+		} else {
+			value_or |= P_OR_INIT;
+		}
+	}
+	if (mask & PARPORT_CONTROL_SELECT) {
+		if (val & PARPORT_CONTROL_SELECT) {
+			value_or |= P_OR_SLCT_IN;
+		} else {
+			value_or &= ~P_OR_SLCT_IN;
+		}
+	}
+
+	sbus_writeb(value_or, &regs->p_or);
+	sbus_writeb(value_tcr, &regs->p_tcr);
+	dprintk((KERN_DEBUG "frob2: tcr 0x%x or 0x%x\n", regs->p_tcr, regs->p_or));
+	return parport_sunbpp_read_control(p);
+}
+
+static void parport_sunbpp_write_control(struct parport *p, unsigned char d)
+{
+	const unsigned char wm = (PARPORT_CONTROL_STROBE |
+				  PARPORT_CONTROL_AUTOFD |
+				  PARPORT_CONTROL_INIT |
+				  PARPORT_CONTROL_SELECT);
+
+	parport_sunbpp_frob_control (p, wm, d & wm);
+}
+
+static unsigned char parport_sunbpp_read_status(struct parport *p)
+{
+	return status_sunbpp_to_pc(p);
+}
+
+static void parport_sunbpp_data_forward (struct parport *p)
+{
+	struct bpp_regs __iomem *regs = (struct bpp_regs __iomem *)p->base;
+	unsigned char value_tcr = sbus_readb(&regs->p_tcr);
+
+	dprintk((KERN_DEBUG "forward\n"));
+	value_tcr &= ~P_TCR_DIR;
+	sbus_writeb(value_tcr, &regs->p_tcr);
+}
+
+static void parport_sunbpp_data_reverse (struct parport *p)
+{
+	struct bpp_regs __iomem *regs = (struct bpp_regs __iomem *)p->base;
+	u8 val = sbus_readb(&regs->p_tcr);
+
+	dprintk((KERN_DEBUG "reverse\n"));
+	val |= P_TCR_DIR;
+	sbus_writeb(val, &regs->p_tcr);
+}
+
+static void parport_sunbpp_init_state(struct pardevice *dev, struct parport_state *s)
+{
+	s->u.pc.ctr = 0xc;
+	s->u.pc.ecr = 0x0;
+}
+
+static void parport_sunbpp_save_state(struct parport *p, struct parport_state *s)
+{
+	s->u.pc.ctr = parport_sunbpp_read_control(p);
+}
+
+static void parport_sunbpp_restore_state(struct parport *p, struct parport_state *s)
+{
+	parport_sunbpp_write_control(p, s->u.pc.ctr);
+}
+
+static struct parport_operations parport_sunbpp_ops = 
+{
+	.write_data	= parport_sunbpp_write_data,
+	.read_data	= parport_sunbpp_read_data,
+
+	.write_control	= parport_sunbpp_write_control,
+	.read_control	= parport_sunbpp_read_control,
+	.frob_control	= parport_sunbpp_frob_control,
+
+	.read_status	= parport_sunbpp_read_status,
+
+	.enable_irq	= parport_sunbpp_enable_irq,
+	.disable_irq	= parport_sunbpp_disable_irq,
+
+	.data_forward	= parport_sunbpp_data_forward,
+	.data_reverse	= parport_sunbpp_data_reverse,
+
+	.init_state	= parport_sunbpp_init_state,
+	.save_state	= parport_sunbpp_save_state,
+	.restore_state	= parport_sunbpp_restore_state,
+
+	.epp_write_data	= parport_ieee1284_epp_write_data,
+	.epp_read_data	= parport_ieee1284_epp_read_data,
+	.epp_write_addr	= parport_ieee1284_epp_write_addr,
+	.epp_read_addr	= parport_ieee1284_epp_read_addr,
+
+	.ecp_write_data	= parport_ieee1284_ecp_write_data,
+	.ecp_read_data	= parport_ieee1284_ecp_read_data,
+	.ecp_write_addr	= parport_ieee1284_ecp_write_addr,
+
+	.compat_write_data	= parport_ieee1284_write_compat,
+	.nibble_read_data	= parport_ieee1284_read_nibble,
+	.byte_read_data		= parport_ieee1284_read_byte,
+
+	.owner		= THIS_MODULE,
+};
+
+typedef struct {
+	struct list_head list;
+	struct parport *port;
+} Node;
+/* no locks, everything's serialized */
+static LIST_HEAD(port_list);
+
+static int __init init_one_port(struct sbus_dev *sdev)
+{
+	struct parport *p;
+	/* at least in theory there may be a "we don't dma" case */
+	struct parport_operations *ops;
+	void __iomem *base;
+	int irq, dma, err = 0, size;
+	struct bpp_regs __iomem *regs;
+	unsigned char value_tcr;
+	Node *node;
+
+	dprintk((KERN_DEBUG "init_one_port(%p): ranges, alloc_io, ", sdev));
+	node = kmalloc(sizeof(Node), GFP_KERNEL);
+	if (!node)
+		goto out0;
+
+	irq = sdev->irqs[0];
+	base = sbus_ioremap(&sdev->resource[0], 0,
+			    sdev->reg_addrs[0].reg_size, 
+			    "sunbpp");
+	if (!base)
+		goto out1;
+
+	size = sdev->reg_addrs[0].reg_size;
+	dma = PARPORT_DMA_NONE;
+
+	dprintk(("alloc(ppops), "));
+	ops = kmalloc (sizeof (struct parport_operations), GFP_KERNEL);
+        if (!ops)
+		goto out2;
+
+        memcpy (ops, &parport_sunbpp_ops, sizeof (struct parport_operations));
+
+	dprintk(("register_port\n"));
+	if (!(p = parport_register_port((unsigned long)base, irq, dma, ops)))
+		goto out3;
+
+	p->size = size;
+
+	dprintk((KERN_DEBUG "init_one_port: request_irq(%08x:%p:%x:%s:%p) ",
+		p->irq, parport_sunbpp_interrupt, SA_SHIRQ, p->name, p));
+	if ((err = request_irq(p->irq, parport_sunbpp_interrupt,
+			       SA_SHIRQ, p->name, p)) != 0) {
+		dprintk(("ERROR %d\n", err));
+		goto out4;
+	}
+	dprintk(("OK\n"));
+	parport_sunbpp_enable_irq(p);
+
+	regs = (struct bpp_regs __iomem *)p->base;
+	dprintk((KERN_DEBUG "forward\n"));
+	value_tcr = sbus_readb(&regs->p_tcr);
+	value_tcr &= ~P_TCR_DIR;
+	sbus_writeb(value_tcr, &regs->p_tcr);
+
+	printk(KERN_INFO "%s: sunbpp at 0x%lx\n", p->name, p->base);
+	node->port = p;
+	list_add(&node->list, &port_list);
+	parport_announce_port (p);
+
+	return 1;
+
+out4:
+	parport_put_port(p);
+out3:
+	kfree(ops);
+out2:
+	sbus_iounmap(base, size);
+out1:
+	kfree(node);
+out0:
+	return err;
+}
+
+static int __init parport_sunbpp_init(void)
+{
+        struct sbus_bus *sbus;
+        struct sbus_dev *sdev;
+	int count = 0;
+
+	for_each_sbus(sbus) {
+		for_each_sbusdev(sdev, sbus) {
+			if (!strcmp(sdev->prom_name, "SUNW,bpp"))
+				count += init_one_port(sdev);
+		}
+	}
+	return count ? 0 : -ENODEV;
+}
+
+static void __exit parport_sunbpp_exit(void)
+{
+	while (!list_empty(&port_list)) {
+		Node *node = list_entry(port_list.next, Node, list);
+		struct parport *p = node->port;
+		struct parport_operations *ops = p->ops;
+		parport_remove_port(p);
+
+		if (p->irq != PARPORT_IRQ_NONE) {
+			parport_sunbpp_disable_irq(p);
+			free_irq(p->irq, p);
+		}
+		sbus_iounmap((void __iomem *)p->base, p->size);
+		parport_put_port(p);
+		kfree (ops);
+		list_del(&node->list);
+		kfree (node);
+	}
+}
+
+MODULE_AUTHOR("Derrick J Brashear");
+MODULE_DESCRIPTION("Parport Driver for Sparc bidirectional Port");
+MODULE_SUPPORTED_DEVICE("Sparc Bidirectional Parallel Port");
+MODULE_LICENSE("GPL");
+
+module_init(parport_sunbpp_init)
+module_exit(parport_sunbpp_exit)
