commit decf26f6ec25dac868782dc1751623a87d147831
Author: Joe Perches <joe@perches.com>
Date:   Fri Apr 3 14:43:16 2020 +0100

    parport: Convert printk(KERN_<LEVEL> to pr_<level>(
    
    Use the more common kernel style.
    
    Miscellanea:
    
    o Coalesce formats
    o Realign arguments
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Reviewed-by: Randy Dunlap <rdunlap@infradead.org>
    Signed-off-by: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
    Link: https://lore.kernel.org/r/20200403134325.11523-2-sudipm.mukherjee@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/parport/ieee1284.c b/drivers/parport/ieee1284.c
index ba562bcd4b80..f28d6a3c5a68 100644
--- a/drivers/parport/ieee1284.c
+++ b/drivers/parport/ieee1284.c
@@ -319,7 +319,7 @@ int parport_negotiate (struct parport *port, int mode)
 #ifndef CONFIG_PARPORT_1284
 	if (mode == IEEE1284_MODE_COMPAT)
 		return 0;
-	printk (KERN_ERR "parport: IEEE1284 not supported in this kernel\n");
+	pr_err("parport: IEEE1284 not supported in this kernel\n");
 	return -1;
 #else
 	int m = mode & ~IEEE1284_ADDR;
@@ -674,7 +674,7 @@ ssize_t parport_write (struct parport *port, const void *buffer, size_t len)
 ssize_t parport_read (struct parport *port, void *buffer, size_t len)
 {
 #ifndef CONFIG_PARPORT_1284
-	printk (KERN_ERR "parport: IEEE1284 not supported in this kernel\n");
+	pr_err("parport: IEEE1284 not supported in this kernel\n");
 	return -ENODEV;
 #else
 	int mode = port->physport->ieee1284.mode;

commit d98ce9fef73d74fa8b1301a9da3fb95ae0a1536f
Author: Joe Perches <joe@perches.com>
Date:   Fri Apr 3 14:43:15 2020 +0100

    parport: fix if-statement empty body warnings
    
    Eliminate warnings by using pr_debug which is the more typical
    kernel debugging style and also enable dynamic_debug on these
    outputs.
    
    Miscellaneous:
    
    o A few messages were logged at KERN_INFO when enabled, now KERN_DEBUG
    o Convert %d/%d to %zd/%zu to avoid compilation warnings
    
    Original-patch-by: Randy Dunlap <rdunlap@infradead.org>
    Signed-off-by: Joe Perches <joe@perches.com>
    Acked-by: Randy Dunlap <rdunlap@infradead.org>
    Signed-off-by: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
    Link: https://lore.kernel.org/r/20200403134325.11523-1-sudipm.mukherjee@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/parport/ieee1284.c b/drivers/parport/ieee1284.c
index 90fb73575495..ba562bcd4b80 100644
--- a/drivers/parport/ieee1284.c
+++ b/drivers/parport/ieee1284.c
@@ -31,12 +31,6 @@
 #undef DEBUG /* Don't want a garbled console */
 #endif
 
-#ifdef DEBUG
-#define DPRINTK(stuff...) printk (stuff)
-#else
-#define DPRINTK(stuff...)
-#endif
-
 /* Make parport_wait_peripheral wake up.
  * It will be useful to call this from an interrupt handler. */
 static void parport_ieee1284_wakeup (struct parport *port)
@@ -258,12 +252,11 @@ static void parport_ieee1284_terminate (struct parport *port)
 						     PARPORT_STATUS_PAPEROUT,
 						     PARPORT_STATUS_PAPEROUT);
 			if (r)
-				DPRINTK (KERN_INFO "%s: Timeout at event 49\n",
+				pr_debug("%s: Timeout at event 49\n",
 					 port->name);
 
 			parport_data_forward (port);
-			DPRINTK (KERN_DEBUG "%s: ECP direction: forward\n",
-				 port->name);
+			pr_debug("%s: ECP direction: forward\n", port->name);
 			port->ieee1284.phase = IEEE1284_PH_FWD_IDLE;
 		}
 
@@ -281,8 +274,7 @@ static void parport_ieee1284_terminate (struct parport *port)
 		/* Event 24: nAck goes low */
 		r = parport_wait_peripheral (port, PARPORT_STATUS_ACK, 0);
 		if (r)
-			DPRINTK (KERN_INFO "%s: Timeout at event 24\n",
-				 port->name);
+			pr_debug("%s: Timeout at event 24\n", port->name);
 
 		/* Event 25: Set nAutoFd low */
 		parport_frob_control (port,
@@ -294,8 +286,7 @@ static void parport_ieee1284_terminate (struct parport *port)
 					     PARPORT_STATUS_ACK, 
 					     PARPORT_STATUS_ACK);
 		if (r)
-			DPRINTK (KERN_INFO "%s: Timeout at event 27\n",
-				 port->name);
+			pr_debug("%s: Timeout at event 27\n", port->name);
 
 		/* Event 29: Set nAutoFd high */
 		parport_frob_control (port, PARPORT_CONTROL_AUTOFD, 0);
@@ -304,8 +295,7 @@ static void parport_ieee1284_terminate (struct parport *port)
 	port->ieee1284.mode = IEEE1284_MODE_COMPAT;
 	port->ieee1284.phase = IEEE1284_PH_FWD_IDLE;
 
-	DPRINTK (KERN_DEBUG "%s: In compatibility (forward idle) mode\n",
-		 port->name);
+	pr_debug("%s: In compatibility (forward idle) mode\n", port->name);
 }		
 #endif /* IEEE1284 support */
 
@@ -406,8 +396,7 @@ int parport_negotiate (struct parport *port, int mode)
 				      PARPORT_CONTROL_SELECT
 				      | PARPORT_CONTROL_AUTOFD,
 				      PARPORT_CONTROL_SELECT);
-		DPRINTK (KERN_DEBUG
-			 "%s: Peripheral not IEEE1284 compliant (0x%02X)\n",
+		pr_debug("%s: Peripheral not IEEE1284 compliant (0x%02X)\n",
 			 port->name, parport_read_status (port));
 		port->ieee1284.phase = IEEE1284_PH_FWD_IDLE;
 		return -1; /* Not IEEE1284 compliant */
@@ -430,8 +419,7 @@ int parport_negotiate (struct parport *port, int mode)
 				     PARPORT_STATUS_ACK,
 				     PARPORT_STATUS_ACK)) {
 		/* This shouldn't really happen with a compliant device. */
-		DPRINTK (KERN_DEBUG
-			 "%s: Mode 0x%02x not supported? (0x%02x)\n",
+		pr_debug("%s: Mode 0x%02x not supported? (0x%02x)\n",
 			 port->name, mode, port->ops->read_status (port));
 		parport_ieee1284_terminate (port);
 		return 1;
@@ -442,7 +430,7 @@ int parport_negotiate (struct parport *port, int mode)
 	/* xflag should be high for all modes other than nibble (0). */
 	if (mode && !xflag) {
 		/* Mode not supported. */
-		DPRINTK (KERN_DEBUG "%s: Mode 0x%02x rejected by peripheral\n",
+		pr_debug("%s: Mode 0x%02x rejected by peripheral\n",
 			 port->name, mode);
 		parport_ieee1284_terminate (port);
 		return 1;
@@ -463,9 +451,7 @@ int parport_negotiate (struct parport *port, int mode)
 		/* Event 52: nAck goes low */
 		if (parport_wait_peripheral (port, PARPORT_STATUS_ACK, 0)) {
 			/* This peripheral is _very_ slow. */
-			DPRINTK (KERN_DEBUG
-				 "%s: Event 52 didn't happen\n",
-				 port->name);
+			pr_debug("%s: Event 52 didn't happen\n", port->name);
 			parport_ieee1284_terminate (port);
 			return 1;
 		}
@@ -481,10 +467,9 @@ int parport_negotiate (struct parport *port, int mode)
 					     PARPORT_STATUS_ACK)) {
 			/* This shouldn't really happen with a compliant
 			 * device. */
-			DPRINTK (KERN_DEBUG
-				 "%s: Mode 0x%02x not supported? (0x%02x)\n",
+			pr_debug("%s: Mode 0x%02x not supported? (0x%02x)\n",
 				 port->name, mode,
-				 port->ops->read_status (port));
+				 port->ops->read_status(port));
 			parport_ieee1284_terminate (port);
 			return 1;
 		}
@@ -495,8 +480,8 @@ int parport_negotiate (struct parport *port, int mode)
 		/* xflag should be high. */
 		if (!xflag) {
 			/* Extended mode not supported. */
-			DPRINTK (KERN_DEBUG "%s: Extended mode 0x%02x not "
-				 "supported\n", port->name, mode);
+			pr_debug("%s: Extended mode 0x%02x not supported\n",
+				 port->name, mode);
 			parport_ieee1284_terminate (port);
 			return 1;
 		}
@@ -505,7 +490,7 @@ int parport_negotiate (struct parport *port, int mode)
 	}
 
 	/* Mode is supported */
-	DPRINTK (KERN_DEBUG "%s: In mode 0x%02x\n", port->name, mode);
+	pr_debug("%s: In mode 0x%02x\n", port->name, mode);
 	port->ieee1284.mode = mode;
 
 	/* But ECP is special */
@@ -522,13 +507,11 @@ int parport_negotiate (struct parport *port, int mode)
 					     PARPORT_STATUS_PAPEROUT,
 					     PARPORT_STATUS_PAPEROUT);
 		if (r) {
-			DPRINTK (KERN_INFO "%s: Timeout at event 31\n",
-				port->name);
+			pr_debug("%s: Timeout at event 31\n", port->name);
 		}
 
 		port->ieee1284.phase = IEEE1284_PH_FWD_IDLE;
-		DPRINTK (KERN_DEBUG "%s: ECP direction: forward\n",
-			 port->name);
+		pr_debug("%s: ECP direction: forward\n", port->name);
 	} else switch (mode) {
 	case IEEE1284_MODE_NIBBLE:
 	case IEEE1284_MODE_BYTE:
@@ -573,7 +556,7 @@ void parport_ieee1284_interrupt (void *handle)
 	if (port->ieee1284.phase == IEEE1284_PH_REV_IDLE) {
 		/* An interrupt in this phase means that data
 		 * is now available. */
-		DPRINTK (KERN_DEBUG "%s: Data available\n", port->name);
+		pr_debug("%s: Data available\n", port->name);
 		parport_ieee1284_ack_data_avail (port);
 	}
 #endif /* IEEE1284 support */
@@ -617,13 +600,12 @@ ssize_t parport_write (struct parport *port, const void *buffer, size_t len)
 		parport_negotiate (port, IEEE1284_MODE_COMPAT);
 		/* fall through */
 	case IEEE1284_MODE_COMPAT:
-		DPRINTK (KERN_DEBUG "%s: Using compatibility mode\n",
-			 port->name);
+		pr_debug("%s: Using compatibility mode\n", port->name);
 		fn = port->ops->compat_write_data;
 		break;
 
 	case IEEE1284_MODE_EPP:
-		DPRINTK (KERN_DEBUG "%s: Using EPP mode\n", port->name);
+		pr_debug("%s: Using EPP mode\n", port->name);
 		if (addr) {
 			fn = port->ops->epp_write_addr;
 		} else {
@@ -631,8 +613,7 @@ ssize_t parport_write (struct parport *port, const void *buffer, size_t len)
 		}
 		break;
 	case IEEE1284_MODE_EPPSWE:
-		DPRINTK (KERN_DEBUG "%s: Using software-emulated EPP mode\n",
-			port->name);
+		pr_debug("%s: Using software-emulated EPP mode\n", port->name);
 		if (addr) {
 			fn = parport_ieee1284_epp_write_addr;
 		} else {
@@ -641,7 +622,7 @@ ssize_t parport_write (struct parport *port, const void *buffer, size_t len)
 		break;
 	case IEEE1284_MODE_ECP:
 	case IEEE1284_MODE_ECPRLE:
-		DPRINTK (KERN_DEBUG "%s: Using ECP mode\n", port->name);
+		pr_debug("%s: Using ECP mode\n", port->name);
 		if (addr) {
 			fn = port->ops->ecp_write_addr;
 		} else {
@@ -650,8 +631,7 @@ ssize_t parport_write (struct parport *port, const void *buffer, size_t len)
 		break;
 
 	case IEEE1284_MODE_ECPSWE:
-		DPRINTK (KERN_DEBUG "%s: Using software-emulated ECP mode\n",
-			 port->name);
+		pr_debug("%s: Using software-emulated ECP mode\n", port->name);
 		/* The caller has specified that it must be emulated,
 		 * even if we have ECP hardware! */
 		if (addr) {
@@ -662,13 +642,13 @@ ssize_t parport_write (struct parport *port, const void *buffer, size_t len)
 		break;
 
 	default:
-		DPRINTK (KERN_DEBUG "%s: Unknown mode 0x%02x\n", port->name,
-			port->ieee1284.mode);
+		pr_debug("%s: Unknown mode 0x%02x\n",
+			 port->name, port->ieee1284.mode);
 		return -ENOSYS;
 	}
 
 	retval = (*fn) (port, buffer, len, 0);
-	DPRINTK (KERN_DEBUG "%s: wrote %d/%d bytes\n", port->name, retval, len);
+	pr_debug("%s: wrote %zd/%zu bytes\n", port->name, retval, len);
 	return retval;
 #endif /* IEEE1284 support */
 }
@@ -715,7 +695,7 @@ ssize_t parport_read (struct parport *port, void *buffer, size_t len)
 		if ((port->physport->modes & PARPORT_MODE_TRISTATE) &&
 		    !parport_negotiate (port, IEEE1284_MODE_BYTE)) {
 			/* got into BYTE mode OK */
-			DPRINTK (KERN_DEBUG "%s: Using byte mode\n", port->name);
+			pr_debug("%s: Using byte mode\n", port->name);
 			fn = port->ops->byte_read_data;
 			break;
 		}
@@ -724,17 +704,17 @@ ssize_t parport_read (struct parport *port, void *buffer, size_t len)
 		}
 		/* fall through - to NIBBLE */
 	case IEEE1284_MODE_NIBBLE:
-		DPRINTK (KERN_DEBUG "%s: Using nibble mode\n", port->name);
+		pr_debug("%s: Using nibble mode\n", port->name);
 		fn = port->ops->nibble_read_data;
 		break;
 
 	case IEEE1284_MODE_BYTE:
-		DPRINTK (KERN_DEBUG "%s: Using byte mode\n", port->name);
+		pr_debug("%s: Using byte mode\n", port->name);
 		fn = port->ops->byte_read_data;
 		break;
 
 	case IEEE1284_MODE_EPP:
-		DPRINTK (KERN_DEBUG "%s: Using EPP mode\n", port->name);
+		pr_debug("%s: Using EPP mode\n", port->name);
 		if (addr) {
 			fn = port->ops->epp_read_addr;
 		} else {
@@ -742,8 +722,7 @@ ssize_t parport_read (struct parport *port, void *buffer, size_t len)
 		}
 		break;
 	case IEEE1284_MODE_EPPSWE:
-		DPRINTK (KERN_DEBUG "%s: Using software-emulated EPP mode\n",
-			port->name);
+		pr_debug("%s: Using software-emulated EPP mode\n", port->name);
 		if (addr) {
 			fn = parport_ieee1284_epp_read_addr;
 		} else {
@@ -752,19 +731,18 @@ ssize_t parport_read (struct parport *port, void *buffer, size_t len)
 		break;
 	case IEEE1284_MODE_ECP:
 	case IEEE1284_MODE_ECPRLE:
-		DPRINTK (KERN_DEBUG "%s: Using ECP mode\n", port->name);
+		pr_debug("%s: Using ECP mode\n", port->name);
 		fn = port->ops->ecp_read_data;
 		break;
 
 	case IEEE1284_MODE_ECPSWE:
-		DPRINTK (KERN_DEBUG "%s: Using software-emulated ECP mode\n",
-			 port->name);
+		pr_debug("%s: Using software-emulated ECP mode\n", port->name);
 		fn = parport_ieee1284_ecp_read_data;
 		break;
 
 	default:
-		DPRINTK (KERN_DEBUG "%s: Unknown mode 0x%02x\n", port->name,
-			 port->physport->ieee1284.mode);
+		pr_debug("%s: Unknown mode 0x%02x\n",
+			 port->name, port->physport->ieee1284.mode);
 		return -ENOSYS;
 	}
 

commit b0a69f05b9633a593c14d7837ae6b299851d5539
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Fri Mar 29 15:20:44 2019 +0000

    parport: ieee1284: mark expected switch fall-through
    
    In preparation to enabling -Wimplicit-fallthrough, mark switch
    cases where we are expecting to fall through.
    
    This patch fixes the following warning:
    
    drivers/parport/ieee1284.c: In function ‘parport_read’:
    drivers/parport/ieee1284.c:722:6: warning: this statement may fall through [-Wimplicit-fallthrough=]
       if (parport_negotiate (port, IEEE1284_MODE_NIBBLE)) {
          ^
    drivers/parport/ieee1284.c:726:2: note: here
      case IEEE1284_MODE_NIBBLE:
      ^~~~
    
    Warning level 3 was used: -Wimplicit-fallthrough=3
    
    Notice that, in this particular case, the code comment is modified
    in accordance with what GCC is expecting to find.
    
    This patch is part of the ongoing efforts to enable
    -Wimplicit-fallthrough.
    
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Signed-off-by: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/parport/ieee1284.c b/drivers/parport/ieee1284.c
index f12b9da69255..90fb73575495 100644
--- a/drivers/parport/ieee1284.c
+++ b/drivers/parport/ieee1284.c
@@ -722,7 +722,7 @@ ssize_t parport_read (struct parport *port, void *buffer, size_t len)
 		if (parport_negotiate (port, IEEE1284_MODE_NIBBLE)) {
 			return -EIO;
 		}
-		/* fall through to NIBBLE */
+		/* fall through - to NIBBLE */
 	case IEEE1284_MODE_NIBBLE:
 		DPRINTK (KERN_DEBUG "%s: Using nibble mode\n", port->name);
 		fn = port->ops->nibble_read_data;

commit 34bcfdac8c92cc7971254ba5856afd12047c50b2
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Thu Jul 12 22:29:56 2018 +0100

    parport: ieee1284: mark expected switch fall-throughs
    
    In preparation to enabling -Wimplicit-fallthrough, mark switch cases
    where we are expecting to fall through.
    
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Signed-off-by: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/parport/ieee1284.c b/drivers/parport/ieee1284.c
index 2d1a5c737c6e..f12b9da69255 100644
--- a/drivers/parport/ieee1284.c
+++ b/drivers/parport/ieee1284.c
@@ -267,7 +267,7 @@ static void parport_ieee1284_terminate (struct parport *port)
 			port->ieee1284.phase = IEEE1284_PH_FWD_IDLE;
 		}
 
-		/* fall-though.. */
+		/* fall through */
 
 	default:
 		/* Terminate from all other modes. */
@@ -615,6 +615,7 @@ ssize_t parport_write (struct parport *port, const void *buffer, size_t len)
 	case IEEE1284_MODE_NIBBLE:
 	case IEEE1284_MODE_BYTE:
 		parport_negotiate (port, IEEE1284_MODE_COMPAT);
+		/* fall through */
 	case IEEE1284_MODE_COMPAT:
 		DPRINTK (KERN_DEBUG "%s: Using compatibility mode\n",
 			 port->name);

commit 9c6c273aa4248c60569de6ef7e7e9c7bed3cd32e
Author: Kees Cook <keescook@chromium.org>
Date:   Wed Oct 4 16:26:57 2017 -0700

    timer: Remove init_timer_on_stack() in favor of timer_setup_on_stack()
    
    Remove uses of init_timer_on_stack() with open-coded function and data
    assignments that could be expressed using timer_setup_on_stack(). Several
    were removed from the stack entirely since there was a one-to-one mapping
    of parent structure to timer, those are switched to using timer_setup()
    instead. All related callbacks were adjusted to use from_timer().
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-mips@linux-mips.org
    Cc: Petr Mladek <pmladek@suse.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Sebastian Reichel <sre@kernel.org>
    Cc: Kalle Valo <kvalo@qca.qualcomm.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: Wim Van Sebroeck <wim@iguana.be>
    Cc: linux1394-devel@lists.sourceforge.net
    Cc: Chris Metcalf <cmetcalf@mellanox.com>
    Cc: linux-s390@vger.kernel.org
    Cc: linux-wireless@vger.kernel.org
    Cc: "James E.J. Bottomley" <jejb@linux.vnet.ibm.com>
    Cc: linux-scsi@vger.kernel.org
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Ursula Braun <ubraun@linux.vnet.ibm.com>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Viresh Kumar <viresh.kumar@linaro.org>
    Cc: Harish Patil <harish.patil@cavium.com>
    Cc: Stephen Boyd <sboyd@codeaurora.org>
    Cc: Michael Reed <mdr@sgi.com>
    Cc: Manish Chopra <manish.chopra@cavium.com>
    Cc: Len Brown <len.brown@intel.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: linux-pm@vger.kernel.org
    Cc: Lai Jiangshan <jiangshanlai@gmail.com>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Julian Wiedmann <jwi@linux.vnet.ibm.com>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Mark Gross <mark.gross@intel.com>
    Cc: linux-watchdog@vger.kernel.org
    Cc: "Martin K. Petersen" <martin.petersen@oracle.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Stefan Richter <stefanr@s5r6.in-berlin.de>
    Cc: Guenter Roeck <linux@roeck-us.net>
    Cc: netdev@vger.kernel.org
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: linuxppc-dev@lists.ozlabs.org
    Cc: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
    Link: https://lkml.kernel.org/r/1507159627-127660-4-git-send-email-keescook@chromium.org

diff --git a/drivers/parport/ieee1284.c b/drivers/parport/ieee1284.c
index 74cc6dd982d2..2d1a5c737c6e 100644
--- a/drivers/parport/ieee1284.c
+++ b/drivers/parport/ieee1284.c
@@ -44,10 +44,11 @@ static void parport_ieee1284_wakeup (struct parport *port)
 	up (&port->physport->ieee1284.irq);
 }
 
-static struct parport *port_from_cookie[PARPORT_MAX];
-static void timeout_waiting_on_port (unsigned long cookie)
+static void timeout_waiting_on_port (struct timer_list *t)
 {
-	parport_ieee1284_wakeup (port_from_cookie[cookie % PARPORT_MAX]);
+	struct parport *port = from_timer(port, t, timer);
+
+	parport_ieee1284_wakeup (port);
 }
 
 /**
@@ -69,27 +70,19 @@ static void timeout_waiting_on_port (unsigned long cookie)
 int parport_wait_event (struct parport *port, signed long timeout)
 {
 	int ret;
-	struct timer_list timer;
 
 	if (!port->physport->cad->timeout)
 		/* Zero timeout is special, and we can't down() the
 		   semaphore. */
 		return 1;
 
-	init_timer_on_stack(&timer);
-	timer.expires = jiffies + timeout;
-	timer.function = timeout_waiting_on_port;
-	port_from_cookie[port->number % PARPORT_MAX] = port;
-	timer.data = port->number;
-
-	add_timer (&timer);
+	timer_setup(&port->timer, timeout_waiting_on_port, 0);
+	mod_timer(&port->timer, jiffies + timeout);
 	ret = down_interruptible (&port->physport->ieee1284.irq);
-	if (!del_timer_sync(&timer) && !ret)
+	if (!del_timer_sync(&port->timer) && !ret)
 		/* Timed out. */
 		ret = 1;
 
-	destroy_timer_on_stack(&timer);
-
 	return ret;
 }
 

commit 174cd4b1e5fbd0d74c68cf3a74f5bd4923485512
Author: Ingo Molnar <mingo@kernel.org>
Date:   Thu Feb 2 19:15:33 2017 +0100

    sched/headers: Prepare to move signal wakeup & sigpending methods from <linux/sched.h> into <linux/sched/signal.h>
    
    Fix up affected files that include this signal functionality via sched.h.
    
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/parport/ieee1284.c b/drivers/parport/ieee1284.c
index f9fd4b33a546..74cc6dd982d2 100644
--- a/drivers/parport/ieee1284.c
+++ b/drivers/parport/ieee1284.c
@@ -23,7 +23,7 @@
 #include <linux/kernel.h>
 #include <linux/interrupt.h>
 #include <linux/timer.h>
-#include <linux/sched.h>
+#include <linux/sched/signal.h>
 
 #undef DEBUG /* undef me for production */
 

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/drivers/parport/ieee1284.c b/drivers/parport/ieee1284.c
index 8901ecf6e037..f9fd4b33a546 100644
--- a/drivers/parport/ieee1284.c
+++ b/drivers/parport/ieee1284.c
@@ -355,7 +355,7 @@ int parport_negotiate (struct parport *port, int mode)
 		return 0;
 	}
 
-	/* Go to compability forward idle mode */
+	/* Go to compatibility forward idle mode */
 	if (port->ieee1284.mode != IEEE1284_MODE_COMPAT)
 		parport_ieee1284_terminate (port);
 

commit f59abb161c955b68fd3d473368420c5919733e09
Author: Michael Buesch <mb@bu3sch.de>
Date:   Tue Jan 6 14:43:14 2009 -0800

    parport: ieee1284: use del_timer_sync() in parport_wait_event()
    
    Use del_timer_sync() instead of del_timer() to make sure the timer won't
    be running when we return from parport_wait_event(), because this would
    crash due to destruction of timer_list.
    
    This is untested and just based on a code review.  Just think about the
    following sequence of events:
    
    - add_timer()
    
    - down_interruptible() is interrupted by a signal.
    
    - we enter the timer callback handler on another CPU.
    
    - del_timer(), but the timer callback is still running.
    
    - eturn from parport_wait_even, which destroys the automatic variable
      "timer" while the callback is running on another CPU.
    
    [akpm@linux-foundation.org: coding-style fixes]
    Signed-off-by: Michael Buesch <mb@bu3sch.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/parport/ieee1284.c b/drivers/parport/ieee1284.c
index ac2a805ac7ea..8901ecf6e037 100644
--- a/drivers/parport/ieee1284.c
+++ b/drivers/parport/ieee1284.c
@@ -84,7 +84,7 @@ int parport_wait_event (struct parport *port, signed long timeout)
 
 	add_timer (&timer);
 	ret = down_interruptible (&port->physport->ieee1284.irq);
-	if (!del_timer (&timer) && !ret)
+	if (!del_timer_sync(&timer) && !ret)
 		/* Timed out. */
 		ret = 1;
 

commit 612de10db06c0704a66bbe7fd13990cb1c2cb958
Author: Adrian Bunk <bunk@kernel.org>
Date:   Wed Oct 15 22:04:33 2008 -0700

    parport: remove CVS keywords
    
    Remove CVS keywords that weren't updated for a long time from comments.
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/parport/ieee1284.c b/drivers/parport/ieee1284.c
index e97059415ab4..ac2a805ac7ea 100644
--- a/drivers/parport/ieee1284.c
+++ b/drivers/parport/ieee1284.c
@@ -1,4 +1,4 @@
-/* $Id: parport_ieee1284.c,v 1.4 1997/10/19 21:37:21 philip Exp $
+/*
  * IEEE-1284 implementation for parport.
  *
  * Authors: Phil Blundell <philb@gnu.org>

commit d99a0344aefbfe991147472d46a6ee1c1a0043de
Author: Andre Haupt <andre@bitwigglers.org>
Date:   Fri Jul 25 19:44:55 2008 -0700

    parport: remove superfluous local variable
    
    Signed-off-by: Andre Haupt <andre@bitwigglers.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/parport/ieee1284.c b/drivers/parport/ieee1284.c
index 0338b0912674..e97059415ab4 100644
--- a/drivers/parport/ieee1284.c
+++ b/drivers/parport/ieee1284.c
@@ -199,8 +199,6 @@ int parport_wait_peripheral(struct parport *port,
 	/* 40ms of slow polling. */
 	deadline = jiffies + msecs_to_jiffies(40);
 	while (time_before (jiffies, deadline)) {
-		int ret;
-
 		if (signal_pending (current))
 			return -EINTR;
 

commit c6f3a97f86a5c97be0ca255976110bb9c3cfe669
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Apr 30 00:55:03 2008 -0700

    debugobjects: add timer specific object debugging code
    
    Add calls to the generic object debugging infrastructure and provide fixup
    functions which allow to keep the system alive when recoverable problems have
    been detected by the object debugging core code.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Ingo Molnar <mingo@elte.hu>
    Cc: Greg KH <greg@kroah.com>
    Cc: Randy Dunlap <randy.dunlap@oracle.com>
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/parport/ieee1284.c b/drivers/parport/ieee1284.c
index 54a6ef72906e..0338b0912674 100644
--- a/drivers/parport/ieee1284.c
+++ b/drivers/parport/ieee1284.c
@@ -76,7 +76,7 @@ int parport_wait_event (struct parport *port, signed long timeout)
 		   semaphore. */
 		return 1;
 
-	init_timer (&timer);
+	init_timer_on_stack(&timer);
 	timer.expires = jiffies + timeout;
 	timer.function = timeout_waiting_on_port;
 	port_from_cookie[port->number % PARPORT_MAX] = port;
@@ -88,6 +88,8 @@ int parport_wait_event (struct parport *port, signed long timeout)
 		/* Timed out. */
 		ret = 1;
 
+	destroy_timer_on_stack(&timer);
+
 	return ret;
 }
 

commit f230d1010ad0dcd71d9ca8ea6864afac49c5aa9b
Author: Jeff Garzik <jeff@garzik.org>
Date:   Fri Oct 19 01:56:02 2007 -0400

    [PARPORT] Kill useful 'irq' arg from parport_{generic_irq,ieee1284_interrupt}
    
    parport_ieee1284_interrupt() was not using its first arg at all.
    Delete.
    
    parport_generic_irq()'s second arg makes its first arg completely
    redundant.  Delete, and use port->irq in the one place where we actually
    need it.
    
    Also, s/__inline__/inline/ to make the code look nicer.
    
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/parport/ieee1284.c b/drivers/parport/ieee1284.c
index 5accaa7bde31..54a6ef72906e 100644
--- a/drivers/parport/ieee1284.c
+++ b/drivers/parport/ieee1284.c
@@ -571,7 +571,7 @@ static int parport_ieee1284_ack_data_avail (struct parport *port)
 #endif /* IEEE1284 support */
 
 /* Handle an interrupt. */
-void parport_ieee1284_interrupt (int which, void *handle)
+void parport_ieee1284_interrupt (void *handle)
 {
 	struct parport *port = handle;
 	parport_ieee1284_wakeup (port);

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/drivers/parport/ieee1284.c b/drivers/parport/ieee1284.c
index 7ff09f0f858f..5accaa7bde31 100644
--- a/drivers/parport/ieee1284.c
+++ b/drivers/parport/ieee1284.c
@@ -571,7 +571,7 @@ static int parport_ieee1284_ack_data_avail (struct parport *port)
 #endif /* IEEE1284 support */
 
 /* Handle an interrupt. */
-void parport_ieee1284_interrupt (int which, void *handle, struct pt_regs *regs)
+void parport_ieee1284_interrupt (int which, void *handle)
 {
 	struct parport *port = handle;
 	parport_ieee1284_wakeup (port);

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jörn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jörn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/drivers/parport/ieee1284.c b/drivers/parport/ieee1284.c
index 690b239ad3a7..7ff09f0f858f 100644
--- a/drivers/parport/ieee1284.c
+++ b/drivers/parport/ieee1284.c
@@ -16,7 +16,6 @@
  * Various hacks, Fred Barnes <frmb2@ukc.ac.uk>, 04/2000
  */
 
-#include <linux/config.h>
 #include <linux/module.h>
 #include <linux/threads.h>
 #include <linux/parport.h>

commit 0ef3b49cc24963a11125971b8deaa8b46209d113
Author: Arnaud Giersch <arnaud.giersch@free.fr>
Date:   Fri Feb 3 03:04:21 2006 -0800

    [PATCH] parport: fix documentation
    
    Fix documentation to actually match the code.
    
    Signed-off-by: Arnaud Giersch <arnaud.giersch@free.fr>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/parport/ieee1284.c b/drivers/parport/ieee1284.c
index 5b887ba5aaf9..690b239ad3a7 100644
--- a/drivers/parport/ieee1284.c
+++ b/drivers/parport/ieee1284.c
@@ -61,10 +61,10 @@ static void timeout_waiting_on_port (unsigned long cookie)
  *	set to zero, it returns immediately.
  *
  *	If an interrupt occurs before the timeout period elapses, this
- *	function returns one immediately.  If it times out, it returns
- *	a value greater than zero.  An error code less than zero
- *	indicates an error (most likely a pending signal), and the
- *	calling code should finish what it's doing as soon as it can.
+ *	function returns zero immediately.  If it times out, it returns
+ *	one.  An error code less than zero indicates an error (most
+ *	likely a pending signal), and the calling code should finish
+ *	what it's doing as soon as it can.
  */
 
 int parport_wait_event (struct parport *port, signed long timeout)
@@ -110,7 +110,7 @@ int parport_wait_event (struct parport *port, signed long timeout)
  *
  *	If the status lines take on the desired values before the
  *	timeout period elapses, parport_poll_peripheral() returns zero
- *	immediately.  A zero return value greater than zero indicates
+ *	immediately.  A return value greater than zero indicates
  *	a timeout.  An error code (less than zero) indicates an error,
  *	most likely a signal that arrived, and the caller should
  *	finish what it is doing as soon as possible.

commit 7b4ccf8db4c1dc343ad5d6ed19240bbc3b5f945f
Author: Nishanth Aravamudan <nacc@us.ibm.com>
Date:   Sat Sep 10 00:27:31 2005 -0700

    [PATCH] parport: fix-up schedule_timeout() usage
    
    Use schedule_timeout_interruptible() instead of
    set_current_state()/schedule_timeout() to reduce kernel size.  Also use
    human-time to jiffies units conversion functions rather than direct HZ
    division to avoid rounding issues.
    
    Signed-off-by: Nishanth Aravamudan <nacc@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/parport/ieee1284.c b/drivers/parport/ieee1284.c
index 694bae162fed..5b887ba5aaf9 100644
--- a/drivers/parport/ieee1284.c
+++ b/drivers/parport/ieee1284.c
@@ -196,7 +196,7 @@ int parport_wait_peripheral(struct parport *port,
 		return 1;
 
 	/* 40ms of slow polling. */
-	deadline = jiffies + (HZ + 24) / 25;
+	deadline = jiffies + msecs_to_jiffies(40);
 	while (time_before (jiffies, deadline)) {
 		int ret;
 
@@ -205,7 +205,7 @@ int parport_wait_peripheral(struct parport *port,
 
 		/* Wait for 10ms (or until an interrupt occurs if
 		 * the handler is set) */
-		if ((ret = parport_wait_event (port, (HZ + 99) / 100)) < 0)
+		if ((ret = parport_wait_event (port, msecs_to_jiffies(10))) < 0)
 			return ret;
 
 		status = parport_read_status (port);
@@ -216,8 +216,7 @@ int parport_wait_peripheral(struct parport *port,
 			/* parport_wait_event didn't time out, but the
 			 * peripheral wasn't actually ready either.
 			 * Wait for another 10ms. */
-			__set_current_state (TASK_INTERRUPTIBLE);
-			schedule_timeout ((HZ+ 99) / 100);
+			schedule_timeout_interruptible(msecs_to_jiffies(10));
 		}
 	}
 

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/parport/ieee1284.c b/drivers/parport/ieee1284.c
new file mode 100644
index 000000000000..694bae162fed
--- /dev/null
+++ b/drivers/parport/ieee1284.c
@@ -0,0 +1,819 @@
+/* $Id: parport_ieee1284.c,v 1.4 1997/10/19 21:37:21 philip Exp $
+ * IEEE-1284 implementation for parport.
+ *
+ * Authors: Phil Blundell <philb@gnu.org>
+ *          Carsten Gross <carsten@sol.wohnheim.uni-ulm.de>
+ *	    Jose Renau <renau@acm.org>
+ *          Tim Waugh <tim@cyberelk.demon.co.uk> (largely rewritten)
+ *
+ * This file is responsible for IEEE 1284 negotiation, and for handing
+ * read/write requests to low-level drivers.
+ *
+ * Any part of this program may be used in documents licensed under
+ * the GNU Free Documentation License, Version 1.1 or any later version
+ * published by the Free Software Foundation.
+ *
+ * Various hacks, Fred Barnes <frmb2@ukc.ac.uk>, 04/2000
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/threads.h>
+#include <linux/parport.h>
+#include <linux/delay.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/timer.h>
+#include <linux/sched.h>
+
+#undef DEBUG /* undef me for production */
+
+#ifdef CONFIG_LP_CONSOLE
+#undef DEBUG /* Don't want a garbled console */
+#endif
+
+#ifdef DEBUG
+#define DPRINTK(stuff...) printk (stuff)
+#else
+#define DPRINTK(stuff...)
+#endif
+
+/* Make parport_wait_peripheral wake up.
+ * It will be useful to call this from an interrupt handler. */
+static void parport_ieee1284_wakeup (struct parport *port)
+{
+	up (&port->physport->ieee1284.irq);
+}
+
+static struct parport *port_from_cookie[PARPORT_MAX];
+static void timeout_waiting_on_port (unsigned long cookie)
+{
+	parport_ieee1284_wakeup (port_from_cookie[cookie % PARPORT_MAX]);
+}
+
+/**
+ *	parport_wait_event - wait for an event on a parallel port
+ *	@port: port to wait on
+ *	@timeout: time to wait (in jiffies)
+ *
+ *	This function waits for up to @timeout jiffies for an
+ *	interrupt to occur on a parallel port.  If the port timeout is
+ *	set to zero, it returns immediately.
+ *
+ *	If an interrupt occurs before the timeout period elapses, this
+ *	function returns one immediately.  If it times out, it returns
+ *	a value greater than zero.  An error code less than zero
+ *	indicates an error (most likely a pending signal), and the
+ *	calling code should finish what it's doing as soon as it can.
+ */
+
+int parport_wait_event (struct parport *port, signed long timeout)
+{
+	int ret;
+	struct timer_list timer;
+
+	if (!port->physport->cad->timeout)
+		/* Zero timeout is special, and we can't down() the
+		   semaphore. */
+		return 1;
+
+	init_timer (&timer);
+	timer.expires = jiffies + timeout;
+	timer.function = timeout_waiting_on_port;
+	port_from_cookie[port->number % PARPORT_MAX] = port;
+	timer.data = port->number;
+
+	add_timer (&timer);
+	ret = down_interruptible (&port->physport->ieee1284.irq);
+	if (!del_timer (&timer) && !ret)
+		/* Timed out. */
+		ret = 1;
+
+	return ret;
+}
+
+/**
+ *	parport_poll_peripheral - poll status lines
+ *	@port: port to watch
+ *	@mask: status lines to watch
+ *	@result: desired values of chosen status lines
+ *	@usec: timeout
+ *
+ *	This function busy-waits until the masked status lines have
+ *	the desired values, or until the timeout period elapses.  The
+ *	@mask and @result parameters are bitmasks, with the bits
+ *	defined by the constants in parport.h: %PARPORT_STATUS_BUSY,
+ *	and so on.
+ *
+ *	This function does not call schedule(); instead it busy-waits
+ *	using udelay().  It currently has a resolution of 5usec.
+ *
+ *	If the status lines take on the desired values before the
+ *	timeout period elapses, parport_poll_peripheral() returns zero
+ *	immediately.  A zero return value greater than zero indicates
+ *	a timeout.  An error code (less than zero) indicates an error,
+ *	most likely a signal that arrived, and the caller should
+ *	finish what it is doing as soon as possible.
+*/
+
+int parport_poll_peripheral(struct parport *port,
+			    unsigned char mask,
+			    unsigned char result,
+			    int usec)
+{
+	/* Zero return code is success, >0 is timeout. */
+	int count = usec / 5 + 2;
+	int i;
+	unsigned char status;
+	for (i = 0; i < count; i++) {
+		status = parport_read_status (port);
+		if ((status & mask) == result)
+			return 0;
+		if (signal_pending (current))
+			return -EINTR;
+		if (need_resched())
+			break;
+		if (i >= 2)
+			udelay (5);
+	}
+
+	return 1;
+}
+
+/**
+ *	parport_wait_peripheral - wait for status lines to change in 35ms
+ *	@port: port to watch
+ *	@mask: status lines to watch
+ *	@result: desired values of chosen status lines
+ *
+ *	This function waits until the masked status lines have the
+ *	desired values, or until 35ms have elapsed (see IEEE 1284-1994
+ *	page 24 to 25 for why this value in particular is hardcoded).
+ *	The @mask and @result parameters are bitmasks, with the bits
+ *	defined by the constants in parport.h: %PARPORT_STATUS_BUSY,
+ *	and so on.
+ *
+ *	The port is polled quickly to start off with, in anticipation
+ *	of a fast response from the peripheral.  This fast polling
+ *	time is configurable (using /proc), and defaults to 500usec.
+ *	If the timeout for this port (see parport_set_timeout()) is
+ *	zero, the fast polling time is 35ms, and this function does
+ *	not call schedule().
+ *
+ *	If the timeout for this port is non-zero, after the fast
+ *	polling fails it uses parport_wait_event() to wait for up to
+ *	10ms, waking up if an interrupt occurs.
+ */
+
+int parport_wait_peripheral(struct parport *port,
+			    unsigned char mask, 
+			    unsigned char result)
+{
+	int ret;
+	int usec;
+	unsigned long deadline;
+	unsigned char status;
+
+	usec = port->physport->spintime; /* usecs of fast polling */
+	if (!port->physport->cad->timeout)
+		/* A zero timeout is "special": busy wait for the
+		   entire 35ms. */
+		usec = 35000;
+
+	/* Fast polling.
+	 *
+	 * This should be adjustable.
+	 * How about making a note (in the device structure) of how long
+	 * it takes, so we know for next time?
+	 */
+	ret = parport_poll_peripheral (port, mask, result, usec);
+	if (ret != 1)
+		return ret;
+
+	if (!port->physport->cad->timeout)
+		/* We may be in an interrupt handler, so we can't poll
+		 * slowly anyway. */
+		return 1;
+
+	/* 40ms of slow polling. */
+	deadline = jiffies + (HZ + 24) / 25;
+	while (time_before (jiffies, deadline)) {
+		int ret;
+
+		if (signal_pending (current))
+			return -EINTR;
+
+		/* Wait for 10ms (or until an interrupt occurs if
+		 * the handler is set) */
+		if ((ret = parport_wait_event (port, (HZ + 99) / 100)) < 0)
+			return ret;
+
+		status = parport_read_status (port);
+		if ((status & mask) == result)
+			return 0;
+
+		if (!ret) {
+			/* parport_wait_event didn't time out, but the
+			 * peripheral wasn't actually ready either.
+			 * Wait for another 10ms. */
+			__set_current_state (TASK_INTERRUPTIBLE);
+			schedule_timeout ((HZ+ 99) / 100);
+		}
+	}
+
+	return 1;
+}
+
+#ifdef CONFIG_PARPORT_1284
+/* Terminate a negotiated mode. */
+static void parport_ieee1284_terminate (struct parport *port)
+{
+	int r;
+	port = port->physport;
+
+	/* EPP terminates differently. */
+	switch (port->ieee1284.mode) {
+	case IEEE1284_MODE_EPP:
+	case IEEE1284_MODE_EPPSL:
+	case IEEE1284_MODE_EPPSWE:
+		/* Terminate from EPP mode. */
+
+		/* Event 68: Set nInit low */
+		parport_frob_control (port, PARPORT_CONTROL_INIT, 0);
+		udelay (50);
+
+		/* Event 69: Set nInit high, nSelectIn low */
+		parport_frob_control (port,
+				      PARPORT_CONTROL_SELECT
+				      | PARPORT_CONTROL_INIT,
+				      PARPORT_CONTROL_SELECT
+				      | PARPORT_CONTROL_INIT);
+		break;
+
+	case IEEE1284_MODE_ECP:
+	case IEEE1284_MODE_ECPRLE:
+	case IEEE1284_MODE_ECPSWE:
+		/* In ECP we can only terminate from fwd idle phase. */
+		if (port->ieee1284.phase != IEEE1284_PH_FWD_IDLE) {
+			/* Event 47: Set nInit high */
+			parport_frob_control (port,
+					      PARPORT_CONTROL_INIT
+					      | PARPORT_CONTROL_AUTOFD,
+					      PARPORT_CONTROL_INIT
+					      | PARPORT_CONTROL_AUTOFD);
+
+			/* Event 49: PError goes high */
+			r = parport_wait_peripheral (port,
+						     PARPORT_STATUS_PAPEROUT,
+						     PARPORT_STATUS_PAPEROUT);
+			if (r)
+				DPRINTK (KERN_INFO "%s: Timeout at event 49\n",
+					 port->name);
+
+			parport_data_forward (port);
+			DPRINTK (KERN_DEBUG "%s: ECP direction: forward\n",
+				 port->name);
+			port->ieee1284.phase = IEEE1284_PH_FWD_IDLE;
+		}
+
+		/* fall-though.. */
+
+	default:
+		/* Terminate from all other modes. */
+
+		/* Event 22: Set nSelectIn low, nAutoFd high */
+		parport_frob_control (port,
+				      PARPORT_CONTROL_SELECT
+				      | PARPORT_CONTROL_AUTOFD,
+				      PARPORT_CONTROL_SELECT);
+
+		/* Event 24: nAck goes low */
+		r = parport_wait_peripheral (port, PARPORT_STATUS_ACK, 0);
+		if (r)
+			DPRINTK (KERN_INFO "%s: Timeout at event 24\n",
+				 port->name);
+
+		/* Event 25: Set nAutoFd low */
+		parport_frob_control (port,
+				      PARPORT_CONTROL_AUTOFD,
+				      PARPORT_CONTROL_AUTOFD);
+
+		/* Event 27: nAck goes high */
+		r = parport_wait_peripheral (port,
+					     PARPORT_STATUS_ACK, 
+					     PARPORT_STATUS_ACK);
+		if (r)
+			DPRINTK (KERN_INFO "%s: Timeout at event 27\n",
+				 port->name);
+
+		/* Event 29: Set nAutoFd high */
+		parport_frob_control (port, PARPORT_CONTROL_AUTOFD, 0);
+	}
+
+	port->ieee1284.mode = IEEE1284_MODE_COMPAT;
+	port->ieee1284.phase = IEEE1284_PH_FWD_IDLE;
+
+	DPRINTK (KERN_DEBUG "%s: In compatibility (forward idle) mode\n",
+		 port->name);
+}		
+#endif /* IEEE1284 support */
+
+/**
+ *	parport_negotiate - negotiate an IEEE 1284 mode
+ *	@port: port to use
+ *	@mode: mode to negotiate to
+ *
+ *	Use this to negotiate to a particular IEEE 1284 transfer mode.
+ *	The @mode parameter should be one of the constants in
+ *	parport.h starting %IEEE1284_MODE_xxx.
+ *
+ *	The return value is 0 if the peripheral has accepted the
+ *	negotiation to the mode specified, -1 if the peripheral is not
+ *	IEEE 1284 compliant (or not present), or 1 if the peripheral
+ *	has rejected the negotiation.
+ */
+
+int parport_negotiate (struct parport *port, int mode)
+{
+#ifndef CONFIG_PARPORT_1284
+	if (mode == IEEE1284_MODE_COMPAT)
+		return 0;
+	printk (KERN_ERR "parport: IEEE1284 not supported in this kernel\n");
+	return -1;
+#else
+	int m = mode & ~IEEE1284_ADDR;
+	int r;
+	unsigned char xflag;
+
+	port = port->physport;
+
+	/* Is there anything to do? */
+	if (port->ieee1284.mode == mode)
+		return 0;
+
+	/* Is the difference just an address-or-not bit? */
+	if ((port->ieee1284.mode & ~IEEE1284_ADDR) == (mode & ~IEEE1284_ADDR)){
+		port->ieee1284.mode = mode;
+		return 0;
+	}
+
+	/* Go to compability forward idle mode */
+	if (port->ieee1284.mode != IEEE1284_MODE_COMPAT)
+		parport_ieee1284_terminate (port);
+
+	if (mode == IEEE1284_MODE_COMPAT)
+		/* Compatibility mode: no negotiation. */
+		return 0; 
+
+	switch (mode) {
+	case IEEE1284_MODE_ECPSWE:
+		m = IEEE1284_MODE_ECP;
+		break;
+	case IEEE1284_MODE_EPPSL:
+	case IEEE1284_MODE_EPPSWE:
+		m = IEEE1284_MODE_EPP;
+		break;
+	case IEEE1284_MODE_BECP:
+		return -ENOSYS; /* FIXME (implement BECP) */
+	}
+
+	if (mode & IEEE1284_EXT_LINK)
+		m = 1<<7; /* request extensibility link */
+
+	port->ieee1284.phase = IEEE1284_PH_NEGOTIATION;
+
+	/* Start off with nStrobe and nAutoFd high, and nSelectIn low */
+	parport_frob_control (port,
+			      PARPORT_CONTROL_STROBE
+			      | PARPORT_CONTROL_AUTOFD
+			      | PARPORT_CONTROL_SELECT,
+			      PARPORT_CONTROL_SELECT);
+	udelay(1);
+
+	/* Event 0: Set data */
+	parport_data_forward (port);
+	parport_write_data (port, m);
+	udelay (400); /* Shouldn't need to wait this long. */
+
+	/* Event 1: Set nSelectIn high, nAutoFd low */
+	parport_frob_control (port,
+			      PARPORT_CONTROL_SELECT
+			      | PARPORT_CONTROL_AUTOFD,
+			      PARPORT_CONTROL_AUTOFD);
+
+	/* Event 2: PError, Select, nFault go high, nAck goes low */
+	if (parport_wait_peripheral (port,
+				     PARPORT_STATUS_ERROR
+				     | PARPORT_STATUS_SELECT
+				     | PARPORT_STATUS_PAPEROUT
+				     | PARPORT_STATUS_ACK,
+				     PARPORT_STATUS_ERROR
+				     | PARPORT_STATUS_SELECT
+				     | PARPORT_STATUS_PAPEROUT)) {
+		/* Timeout */
+		parport_frob_control (port,
+				      PARPORT_CONTROL_SELECT
+				      | PARPORT_CONTROL_AUTOFD,
+				      PARPORT_CONTROL_SELECT);
+		DPRINTK (KERN_DEBUG
+			 "%s: Peripheral not IEEE1284 compliant (0x%02X)\n",
+			 port->name, parport_read_status (port));
+		port->ieee1284.phase = IEEE1284_PH_FWD_IDLE;
+		return -1; /* Not IEEE1284 compliant */
+	}
+
+	/* Event 3: Set nStrobe low */
+	parport_frob_control (port,
+			      PARPORT_CONTROL_STROBE,
+			      PARPORT_CONTROL_STROBE);
+
+	/* Event 4: Set nStrobe and nAutoFd high */
+	udelay (5);
+	parport_frob_control (port,
+			      PARPORT_CONTROL_STROBE
+			      | PARPORT_CONTROL_AUTOFD,
+			      0);
+
+	/* Event 6: nAck goes high */
+	if (parport_wait_peripheral (port,
+				     PARPORT_STATUS_ACK,
+				     PARPORT_STATUS_ACK)) {
+		/* This shouldn't really happen with a compliant device. */
+		DPRINTK (KERN_DEBUG
+			 "%s: Mode 0x%02x not supported? (0x%02x)\n",
+			 port->name, mode, port->ops->read_status (port));
+		parport_ieee1284_terminate (port);
+		return 1;
+	}
+
+	xflag = parport_read_status (port) & PARPORT_STATUS_SELECT;
+
+	/* xflag should be high for all modes other than nibble (0). */
+	if (mode && !xflag) {
+		/* Mode not supported. */
+		DPRINTK (KERN_DEBUG "%s: Mode 0x%02x rejected by peripheral\n",
+			 port->name, mode);
+		parport_ieee1284_terminate (port);
+		return 1;
+	}
+
+	/* More to do if we've requested extensibility link. */
+	if (mode & IEEE1284_EXT_LINK) {
+		m = mode & 0x7f;
+		udelay (1);
+		parport_write_data (port, m);
+		udelay (1);
+
+		/* Event 51: Set nStrobe low */
+		parport_frob_control (port,
+				      PARPORT_CONTROL_STROBE,
+				      PARPORT_CONTROL_STROBE);
+
+		/* Event 52: nAck goes low */
+		if (parport_wait_peripheral (port, PARPORT_STATUS_ACK, 0)) {
+			/* This peripheral is _very_ slow. */
+			DPRINTK (KERN_DEBUG
+				 "%s: Event 52 didn't happen\n",
+				 port->name);
+			parport_ieee1284_terminate (port);
+			return 1;
+		}
+
+		/* Event 53: Set nStrobe high */
+		parport_frob_control (port,
+				      PARPORT_CONTROL_STROBE,
+				      0);
+
+		/* Event 55: nAck goes high */
+		if (parport_wait_peripheral (port,
+					     PARPORT_STATUS_ACK,
+					     PARPORT_STATUS_ACK)) {
+			/* This shouldn't really happen with a compliant
+			 * device. */
+			DPRINTK (KERN_DEBUG
+				 "%s: Mode 0x%02x not supported? (0x%02x)\n",
+				 port->name, mode,
+				 port->ops->read_status (port));
+			parport_ieee1284_terminate (port);
+			return 1;
+		}
+
+		/* Event 54: Peripheral sets XFlag to reflect support */
+		xflag = parport_read_status (port) & PARPORT_STATUS_SELECT;
+
+		/* xflag should be high. */
+		if (!xflag) {
+			/* Extended mode not supported. */
+			DPRINTK (KERN_DEBUG "%s: Extended mode 0x%02x not "
+				 "supported\n", port->name, mode);
+			parport_ieee1284_terminate (port);
+			return 1;
+		}
+
+		/* Any further setup is left to the caller. */
+	}
+
+	/* Mode is supported */
+	DPRINTK (KERN_DEBUG "%s: In mode 0x%02x\n", port->name, mode);
+	port->ieee1284.mode = mode;
+
+	/* But ECP is special */
+	if (!(mode & IEEE1284_EXT_LINK) && (m & IEEE1284_MODE_ECP)) {
+		port->ieee1284.phase = IEEE1284_PH_ECP_SETUP;
+
+		/* Event 30: Set nAutoFd low */
+		parport_frob_control (port,
+				      PARPORT_CONTROL_AUTOFD,
+				      PARPORT_CONTROL_AUTOFD);
+
+		/* Event 31: PError goes high. */
+		r = parport_wait_peripheral (port,
+					     PARPORT_STATUS_PAPEROUT,
+					     PARPORT_STATUS_PAPEROUT);
+		if (r) {
+			DPRINTK (KERN_INFO "%s: Timeout at event 31\n",
+				port->name);
+		}
+
+		port->ieee1284.phase = IEEE1284_PH_FWD_IDLE;
+		DPRINTK (KERN_DEBUG "%s: ECP direction: forward\n",
+			 port->name);
+	} else switch (mode) {
+	case IEEE1284_MODE_NIBBLE:
+	case IEEE1284_MODE_BYTE:
+		port->ieee1284.phase = IEEE1284_PH_REV_IDLE;
+		break;
+	default:
+		port->ieee1284.phase = IEEE1284_PH_FWD_IDLE;
+	}
+
+
+	return 0;
+#endif /* IEEE1284 support */
+}
+
+/* Acknowledge that the peripheral has data available.
+ * Events 18-20, in order to get from Reverse Idle phase
+ * to Host Busy Data Available.
+ * This will most likely be called from an interrupt.
+ * Returns zero if data was available.
+ */
+#ifdef CONFIG_PARPORT_1284
+static int parport_ieee1284_ack_data_avail (struct parport *port)
+{
+	if (parport_read_status (port) & PARPORT_STATUS_ERROR)
+		/* Event 18 didn't happen. */
+		return -1;
+
+	/* Event 20: nAutoFd goes high. */
+	port->ops->frob_control (port, PARPORT_CONTROL_AUTOFD, 0);
+	port->ieee1284.phase = IEEE1284_PH_HBUSY_DAVAIL;
+	return 0;
+}
+#endif /* IEEE1284 support */
+
+/* Handle an interrupt. */
+void parport_ieee1284_interrupt (int which, void *handle, struct pt_regs *regs)
+{
+	struct parport *port = handle;
+	parport_ieee1284_wakeup (port);
+
+#ifdef CONFIG_PARPORT_1284
+	if (port->ieee1284.phase == IEEE1284_PH_REV_IDLE) {
+		/* An interrupt in this phase means that data
+		 * is now available. */
+		DPRINTK (KERN_DEBUG "%s: Data available\n", port->name);
+		parport_ieee1284_ack_data_avail (port);
+	}
+#endif /* IEEE1284 support */
+}
+
+/**
+ *	parport_write - write a block of data to a parallel port
+ *	@port: port to write to
+ *	@buffer: data buffer (in kernel space)
+ *	@len: number of bytes of data to transfer
+ *
+ *	This will write up to @len bytes of @buffer to the port
+ *	specified, using the IEEE 1284 transfer mode most recently
+ *	negotiated to (using parport_negotiate()), as long as that
+ *	mode supports forward transfers (host to peripheral).
+ *
+ *	It is the caller's responsibility to ensure that the first
+ *	@len bytes of @buffer are valid.
+ *
+ *	This function returns the number of bytes transferred (if zero
+ *	or positive), or else an error code.
+ */
+
+ssize_t parport_write (struct parport *port, const void *buffer, size_t len)
+{
+#ifndef CONFIG_PARPORT_1284
+	return port->ops->compat_write_data (port, buffer, len, 0);
+#else
+	ssize_t retval;
+	int mode = port->ieee1284.mode;
+	int addr = mode & IEEE1284_ADDR;
+	size_t (*fn) (struct parport *, const void *, size_t, int);
+
+	/* Ignore the device-ID-request bit and the address bit. */
+	mode &= ~(IEEE1284_DEVICEID | IEEE1284_ADDR);
+
+	/* Use the mode we're in. */
+	switch (mode) {
+	case IEEE1284_MODE_NIBBLE:
+	case IEEE1284_MODE_BYTE:
+		parport_negotiate (port, IEEE1284_MODE_COMPAT);
+	case IEEE1284_MODE_COMPAT:
+		DPRINTK (KERN_DEBUG "%s: Using compatibility mode\n",
+			 port->name);
+		fn = port->ops->compat_write_data;
+		break;
+
+	case IEEE1284_MODE_EPP:
+		DPRINTK (KERN_DEBUG "%s: Using EPP mode\n", port->name);
+		if (addr) {
+			fn = port->ops->epp_write_addr;
+		} else {
+			fn = port->ops->epp_write_data;
+		}
+		break;
+	case IEEE1284_MODE_EPPSWE:
+		DPRINTK (KERN_DEBUG "%s: Using software-emulated EPP mode\n",
+			port->name);
+		if (addr) {
+			fn = parport_ieee1284_epp_write_addr;
+		} else {
+			fn = parport_ieee1284_epp_write_data;
+		}
+		break;
+	case IEEE1284_MODE_ECP:
+	case IEEE1284_MODE_ECPRLE:
+		DPRINTK (KERN_DEBUG "%s: Using ECP mode\n", port->name);
+		if (addr) {
+			fn = port->ops->ecp_write_addr;
+		} else {
+			fn = port->ops->ecp_write_data;
+		}
+		break;
+
+	case IEEE1284_MODE_ECPSWE:
+		DPRINTK (KERN_DEBUG "%s: Using software-emulated ECP mode\n",
+			 port->name);
+		/* The caller has specified that it must be emulated,
+		 * even if we have ECP hardware! */
+		if (addr) {
+			fn = parport_ieee1284_ecp_write_addr;
+		} else {
+			fn = parport_ieee1284_ecp_write_data;
+		}
+		break;
+
+	default:
+		DPRINTK (KERN_DEBUG "%s: Unknown mode 0x%02x\n", port->name,
+			port->ieee1284.mode);
+		return -ENOSYS;
+	}
+
+	retval = (*fn) (port, buffer, len, 0);
+	DPRINTK (KERN_DEBUG "%s: wrote %d/%d bytes\n", port->name, retval, len);
+	return retval;
+#endif /* IEEE1284 support */
+}
+
+/**
+ *	parport_read - read a block of data from a parallel port
+ *	@port: port to read from
+ *	@buffer: data buffer (in kernel space)
+ *	@len: number of bytes of data to transfer
+ *
+ *	This will read up to @len bytes of @buffer to the port
+ *	specified, using the IEEE 1284 transfer mode most recently
+ *	negotiated to (using parport_negotiate()), as long as that
+ *	mode supports reverse transfers (peripheral to host).
+ *
+ *	It is the caller's responsibility to ensure that the first
+ *	@len bytes of @buffer are available to write to.
+ *
+ *	This function returns the number of bytes transferred (if zero
+ *	or positive), or else an error code.
+ */
+
+ssize_t parport_read (struct parport *port, void *buffer, size_t len)
+{
+#ifndef CONFIG_PARPORT_1284
+	printk (KERN_ERR "parport: IEEE1284 not supported in this kernel\n");
+	return -ENODEV;
+#else
+	int mode = port->physport->ieee1284.mode;
+	int addr = mode & IEEE1284_ADDR;
+	size_t (*fn) (struct parport *, void *, size_t, int);
+
+	/* Ignore the device-ID-request bit and the address bit. */
+	mode &= ~(IEEE1284_DEVICEID | IEEE1284_ADDR);
+
+	/* Use the mode we're in. */
+	switch (mode) {
+	case IEEE1284_MODE_COMPAT:
+		/* if we can tri-state use BYTE mode instead of NIBBLE mode,
+		 * if that fails, revert to NIBBLE mode -- ought to store somewhere
+		 * the device's ability to do BYTE mode reverse transfers, so we don't
+		 * end up needlessly calling negotiate(BYTE) repeately..  (fb)
+		 */
+		if ((port->physport->modes & PARPORT_MODE_TRISTATE) &&
+		    !parport_negotiate (port, IEEE1284_MODE_BYTE)) {
+			/* got into BYTE mode OK */
+			DPRINTK (KERN_DEBUG "%s: Using byte mode\n", port->name);
+			fn = port->ops->byte_read_data;
+			break;
+		}
+		if (parport_negotiate (port, IEEE1284_MODE_NIBBLE)) {
+			return -EIO;
+		}
+		/* fall through to NIBBLE */
+	case IEEE1284_MODE_NIBBLE:
+		DPRINTK (KERN_DEBUG "%s: Using nibble mode\n", port->name);
+		fn = port->ops->nibble_read_data;
+		break;
+
+	case IEEE1284_MODE_BYTE:
+		DPRINTK (KERN_DEBUG "%s: Using byte mode\n", port->name);
+		fn = port->ops->byte_read_data;
+		break;
+
+	case IEEE1284_MODE_EPP:
+		DPRINTK (KERN_DEBUG "%s: Using EPP mode\n", port->name);
+		if (addr) {
+			fn = port->ops->epp_read_addr;
+		} else {
+			fn = port->ops->epp_read_data;
+		}
+		break;
+	case IEEE1284_MODE_EPPSWE:
+		DPRINTK (KERN_DEBUG "%s: Using software-emulated EPP mode\n",
+			port->name);
+		if (addr) {
+			fn = parport_ieee1284_epp_read_addr;
+		} else {
+			fn = parport_ieee1284_epp_read_data;
+		}
+		break;
+	case IEEE1284_MODE_ECP:
+	case IEEE1284_MODE_ECPRLE:
+		DPRINTK (KERN_DEBUG "%s: Using ECP mode\n", port->name);
+		fn = port->ops->ecp_read_data;
+		break;
+
+	case IEEE1284_MODE_ECPSWE:
+		DPRINTK (KERN_DEBUG "%s: Using software-emulated ECP mode\n",
+			 port->name);
+		fn = parport_ieee1284_ecp_read_data;
+		break;
+
+	default:
+		DPRINTK (KERN_DEBUG "%s: Unknown mode 0x%02x\n", port->name,
+			 port->physport->ieee1284.mode);
+		return -ENOSYS;
+	}
+
+	return (*fn) (port, buffer, len, 0);
+#endif /* IEEE1284 support */
+}
+
+/**
+ *	parport_set_timeout - set the inactivity timeout for a device
+ *	@dev: device on a port
+ *	@inactivity: inactivity timeout (in jiffies)
+ *
+ *	This sets the inactivity timeout for a particular device on a
+ *	port.  This affects functions like parport_wait_peripheral().
+ *	The special value 0 means not to call schedule() while dealing
+ *	with this device.
+ *
+ *	The return value is the previous inactivity timeout.
+ *
+ *	Any callers of parport_wait_event() for this device are woken
+ *	up.
+ */
+
+long parport_set_timeout (struct pardevice *dev, long inactivity)
+{
+	long int old = dev->timeout;
+
+	dev->timeout = inactivity;
+
+	if (dev->port->physport->cad == dev)
+		parport_ieee1284_wakeup (dev->port);
+
+	return old;
+}
+
+/* Exported symbols for modules. */
+
+EXPORT_SYMBOL(parport_negotiate);
+EXPORT_SYMBOL(parport_write);
+EXPORT_SYMBOL(parport_read);
+EXPORT_SYMBOL(parport_wait_peripheral);
+EXPORT_SYMBOL(parport_wait_event);
+EXPORT_SYMBOL(parport_set_timeout);
+EXPORT_SYMBOL(parport_ieee1284_interrupt);
