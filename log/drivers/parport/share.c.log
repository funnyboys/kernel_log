commit 3275158fa52ad2a795f7f52ba4565ea92660c296
Author: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
Date:   Fri Apr 3 14:43:25 2020 +0100

    parport: remove use of devmodel
    
    Now that all the drivers using parallel port has been converted to use
    device model, there is no driver left which has devmodel as false.
    Remove the part of the code which expects devmodel can be false.
    
    Signed-off-by: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
    Link: https://lore.kernel.org/r/20200403134325.11523-11-sudipm.mukherjee@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/parport/share.c b/drivers/parport/share.c
index 661f623b3129..7fec4fefe151 100644
--- a/drivers/parport/share.c
+++ b/drivers/parport/share.c
@@ -278,46 +278,32 @@ static int port_detect(struct device *dev, void *dev_drv)
 int __parport_register_driver(struct parport_driver *drv, struct module *owner,
 			      const char *mod_name)
 {
-	if (drv->devmodel) {
-		/* using device model */
-		int ret;
-
-		/* initialize common driver fields */
-		drv->driver.name = drv->name;
-		drv->driver.bus = &parport_bus_type;
-		drv->driver.owner = owner;
-		drv->driver.mod_name = mod_name;
-		ret = driver_register(&drv->driver);
-		if (ret)
-			return ret;
+	/* using device model */
+	int ret;
 
-		/*
-		 * check if bus has any parallel port registered, if
-		 * none is found then load the lowlevel driver.
-		 */
-		ret = bus_for_each_dev(&parport_bus_type, NULL, NULL,
-				       port_detect);
-		if (!ret)
-			get_lowlevel_driver();
-
-		mutex_lock(&registration_lock);
-		if (drv->match_port)
-			bus_for_each_dev(&parport_bus_type, NULL, drv,
-					 port_check);
-		mutex_unlock(&registration_lock);
-	} else {
-		struct parport *port;
-
-		drv->devmodel = false;
-
-		if (list_empty(&portlist))
-			get_lowlevel_driver();
-		mutex_lock(&registration_lock);
-		list_for_each_entry(port, &portlist, list)
-			drv->attach(port);
-		list_add(&drv->list, &drivers);
-		mutex_unlock(&registration_lock);
-	}
+	/* initialize common driver fields */
+	drv->driver.name = drv->name;
+	drv->driver.bus = &parport_bus_type;
+	drv->driver.owner = owner;
+	drv->driver.mod_name = mod_name;
+	ret = driver_register(&drv->driver);
+	if (ret)
+		return ret;
+
+	/*
+	 * check if bus has any parallel port registered, if
+	 * none is found then load the lowlevel driver.
+	 */
+	ret = bus_for_each_dev(&parport_bus_type, NULL, NULL,
+			       port_detect);
+	if (!ret)
+		get_lowlevel_driver();
+
+	mutex_lock(&registration_lock);
+	if (drv->match_port)
+		bus_for_each_dev(&parport_bus_type, NULL, drv,
+				 port_check);
+	mutex_unlock(&registration_lock);
 
 	return 0;
 }
@@ -352,17 +338,9 @@ static int port_detach(struct device *dev, void *_drv)
 
 void parport_unregister_driver(struct parport_driver *drv)
 {
-	struct parport *port;
-
 	mutex_lock(&registration_lock);
-	if (drv->devmodel) {
-		bus_for_each_dev(&parport_bus_type, NULL, drv, port_detach);
-		driver_unregister(&drv->driver);
-	} else {
-		list_del_init(&drv->list);
-		list_for_each_entry(port, &portlist, list)
-			drv->detach(port);
-	}
+	bus_for_each_dev(&parport_bus_type, NULL, drv, port_detach);
+	driver_unregister(&drv->driver);
 	mutex_unlock(&registration_lock);
 }
 EXPORT_SYMBOL(parport_unregister_driver);
@@ -915,10 +893,7 @@ void parport_unregister_device(struct pardevice *dev)
 	spin_unlock_irq(&port->waitlist_lock);
 
 	kfree(dev->state);
-	if (dev->devmodel)
-		device_unregister(&dev->dev);
-	else
-		kfree(dev);
+	device_unregister(&dev->dev);
 
 	module_put(port->ops->owner);
 	parport_put_port(port);

commit bae9defb06a781083844cafd0a359f423cd98388
Author: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
Date:   Fri Apr 3 14:43:24 2020 +0100

    parport: remove unused parport_register_device()
    
    All the drivers that are using parallel port has been converted to use
    the new device model api, and parport_register_device() is no longer
    used.
    
    Signed-off-by: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
    Link: https://lore.kernel.org/r/20200403134325.11523-10-sudipm.mukherjee@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/parport/share.c b/drivers/parport/share.c
index ee2892a935d6..661f623b3129 100644
--- a/drivers/parport/share.c
+++ b/drivers/parport/share.c
@@ -641,198 +641,6 @@ void parport_remove_port(struct parport *port)
 }
 EXPORT_SYMBOL(parport_remove_port);
 
-/**
- *	parport_register_device - register a device on a parallel port
- *	@port: port to which the device is attached
- *	@name: a name to refer to the device
- *	@pf: preemption callback
- *	@kf: kick callback (wake-up)
- *	@irq_func: interrupt handler
- *	@flags: registration flags
- *	@handle: data for callback functions
- *
- *	This function, called by parallel port device drivers,
- *	declares that a device is connected to a port, and tells the
- *	system all it needs to know.
- *
- *	The @name is allocated by the caller and must not be
- *	deallocated until the caller calls @parport_unregister_device
- *	for that device.
- *
- *	The preemption callback function, @pf, is called when this
- *	device driver has claimed access to the port but another
- *	device driver wants to use it.  It is given @handle as its
- *	parameter, and should return zero if it is willing for the
- *	system to release the port to another driver on its behalf.
- *	If it wants to keep control of the port it should return
- *	non-zero, and no action will be taken.  It is good manners for
- *	the driver to try to release the port at the earliest
- *	opportunity after its preemption callback rejects a preemption
- *	attempt.  Note that if a preemption callback is happy for
- *	preemption to go ahead, there is no need to release the port;
- *	it is done automatically.  This function may not block, as it
- *	may be called from interrupt context.  If the device driver
- *	does not support preemption, @pf can be %NULL.
- *
- *	The wake-up ("kick") callback function, @kf, is called when
- *	the port is available to be claimed for exclusive access; that
- *	is, parport_claim() is guaranteed to succeed when called from
- *	inside the wake-up callback function.  If the driver wants to
- *	claim the port it should do so; otherwise, it need not take
- *	any action.  This function may not block, as it may be called
- *	from interrupt context.  If the device driver does not want to
- *	be explicitly invited to claim the port in this way, @kf can
- *	be %NULL.
- *
- *	The interrupt handler, @irq_func, is called when an interrupt
- *	arrives from the parallel port.  Note that if a device driver
- *	wants to use interrupts it should use parport_enable_irq(),
- *	and can also check the irq member of the parport structure
- *	representing the port.
- *
- *	The parallel port (lowlevel) driver is the one that has called
- *	request_irq() and whose interrupt handler is called first.
- *	This handler does whatever needs to be done to the hardware to
- *	acknowledge the interrupt (for PC-style ports there is nothing
- *	special to be done).  It then tells the IEEE 1284 code about
- *	the interrupt, which may involve reacting to an IEEE 1284
- *	event depending on the current IEEE 1284 phase.  After this,
- *	it calls @irq_func.  Needless to say, @irq_func will be called
- *	from interrupt context, and may not block.
- *
- *	The %PARPORT_DEV_EXCL flag is for preventing port sharing, and
- *	so should only be used when sharing the port with other device
- *	drivers is impossible and would lead to incorrect behaviour.
- *	Use it sparingly!  Normally, @flags will be zero.
- *
- *	This function returns a pointer to a structure that represents
- *	the device on the port, or %NULL if there is not enough memory
- *	to allocate space for that structure.
- **/
-
-struct pardevice *
-parport_register_device(struct parport *port, const char *name,
-			int (*pf)(void *), void (*kf)(void *),
-			void (*irq_func)(void *),
-			int flags, void *handle)
-{
-	struct pardevice *tmp;
-
-	if (port->physport->flags & PARPORT_FLAG_EXCL) {
-		/* An exclusive device is registered. */
-		printk(KERN_DEBUG "%s: no more devices allowed\n", port->name);
-		return NULL;
-	}
-
-	if (flags & PARPORT_DEV_LURK) {
-		if (!pf || !kf) {
-			pr_info("%s: refused to register lurking device (%s) without callbacks\n",
-				port->name, name);
-			return NULL;
-		}
-	}
-
-	if (flags & PARPORT_DEV_EXCL) {
-		if (port->physport->devices) {
-			/*
-			 * If a device is already registered and this new
-			 * device wants exclusive access, then no need to
-			 * continue as we can not grant exclusive access to
-			 * this device.
-			 */
-			pr_err("%s: cannot grant exclusive access for device %s\n",
-			       port->name, name);
-			return NULL;
-		}
-	}
-
-	/*
-	 * We up our own module reference count, and that of the port
-	 * on which a device is to be registered, to ensure that
-	 * neither of us gets unloaded while we sleep in (e.g.)
-	 * kmalloc.
-	 */
-	if (!try_module_get(port->ops->owner))
-		return NULL;
-
-	parport_get_port(port);
-
-	tmp = kmalloc(sizeof(struct pardevice), GFP_KERNEL);
-	if (!tmp)
-		goto out;
-
-	tmp->state = kmalloc(sizeof(struct parport_state), GFP_KERNEL);
-	if (!tmp->state)
-		goto out_free_pardevice;
-
-	tmp->name = name;
-	tmp->port = port;
-	tmp->daisy = -1;
-	tmp->preempt = pf;
-	tmp->wakeup = kf;
-	tmp->private = handle;
-	tmp->flags = flags;
-	tmp->irq_func = irq_func;
-	tmp->waiting = 0;
-	tmp->timeout = 5 * HZ;
-	tmp->devmodel = false;
-
-	/* Chain this onto the list */
-	tmp->prev = NULL;
-	/*
-	 * This function must not run from an irq handler so we don' t need
-	 * to clear irq on the local CPU. -arca
-	 */
-	spin_lock(&port->physport->pardevice_lock);
-
-	if (flags & PARPORT_DEV_EXCL) {
-		if (port->physport->devices) {
-			spin_unlock(&port->physport->pardevice_lock);
-			printk(KERN_DEBUG "%s: cannot grant exclusive access for device %s\n",
-			       port->name, name);
-			goto out_free_all;
-		}
-		port->flags |= PARPORT_FLAG_EXCL;
-	}
-
-	tmp->next = port->physport->devices;
-	wmb(); /*
-		* Make sure that tmp->next is written before it's
-		* added to the list; see comments marked 'no locking
-		* required'
-		*/
-	if (port->physport->devices)
-		port->physport->devices->prev = tmp;
-	port->physport->devices = tmp;
-	spin_unlock(&port->physport->pardevice_lock);
-
-	init_waitqueue_head(&tmp->wait_q);
-	tmp->timeslice = parport_default_timeslice;
-	tmp->waitnext = tmp->waitprev = NULL;
-
-	/*
-	 * This has to be run as last thing since init_state may need other
-	 * pardevice fields. -arca
-	 */
-	port->ops->init_state(tmp, tmp->state);
-	if (!test_and_set_bit(PARPORT_DEVPROC_REGISTERED, &port->devflags)) {
-		port->proc_device = tmp;
-		parport_device_proc_register(tmp);
-	}
-	return tmp;
-
- out_free_all:
-	kfree(tmp->state);
- out_free_pardevice:
-	kfree(tmp);
- out:
-	parport_put_port(port);
-	module_put(port->ops->owner);
-
-	return NULL;
-}
-EXPORT_SYMBOL(parport_register_device);
-
 static void free_pardevice(struct device *dev)
 {
 	struct pardevice *par_dev = to_pardevice(dev);

commit 6824f0ce38cb4b903a3cbf00dd528861f6c2ea7c
Author: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
Date:   Fri Apr 3 14:43:23 2020 +0100

    parport: Add comments for parport_register_dev_model()
    
    In preparation to remove parport_register_device(), copy the comments
    to parport_register_dev_model() and modify the parameters according to
    what parport_register_dev_model() has.
    
    Signed-off-by: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
    Link: https://lore.kernel.org/r/20200403134325.11523-9-sudipm.mukherjee@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/parport/share.c b/drivers/parport/share.c
index 3169feebdc19..ee2892a935d6 100644
--- a/drivers/parport/share.c
+++ b/drivers/parport/share.c
@@ -841,6 +841,68 @@ static void free_pardevice(struct device *dev)
 	kfree(par_dev);
 }
 
+/**
+ *	parport_register_dev_model - register a device on a parallel port
+ *	@port: port to which the device is attached
+ *	@name: a name to refer to the device
+ *	@par_dev_cb: struct containing callbacks
+ *	@id: device number to be given to the device
+ *
+ *	This function, called by parallel port device drivers,
+ *	declares that a device is connected to a port, and tells the
+ *	system all it needs to know.
+ *
+ *	The struct pardev_cb contains pointer to callbacks. preemption
+ *	callback function, @preempt, is called when this device driver
+ *	has claimed access to the port but another device driver wants
+ *	to use it.  It is given, @private, as its parameter, and should
+ *	return zero if it is willing for the system to release the port
+ *	to another driver on its behalf. If it wants to keep control of
+ *	the port it should return non-zero, and no action will be taken.
+ *	It is good manners for the driver to try to release the port at
+ *	the earliest opportunity after its preemption callback rejects a
+ *	preemption attempt. Note that if a preemption callback is happy
+ *	for preemption to go ahead, there is no need to release the
+ *	port; it is done automatically. This function may not block, as
+ *	it may be called from interrupt context. If the device driver
+ *	does not support preemption, @preempt can be %NULL.
+ *
+ *	The wake-up ("kick") callback function, @wakeup, is called when
+ *	the port is available to be claimed for exclusive access; that
+ *	is, parport_claim() is guaranteed to succeed when called from
+ *	inside the wake-up callback function.  If the driver wants to
+ *	claim the port it should do so; otherwise, it need not take
+ *	any action.  This function may not block, as it may be called
+ *	from interrupt context.  If the device driver does not want to
+ *	be explicitly invited to claim the port in this way, @wakeup can
+ *	be %NULL.
+ *
+ *	The interrupt handler, @irq_func, is called when an interrupt
+ *	arrives from the parallel port.  Note that if a device driver
+ *	wants to use interrupts it should use parport_enable_irq(),
+ *	and can also check the irq member of the parport structure
+ *	representing the port.
+ *
+ *	The parallel port (lowlevel) driver is the one that has called
+ *	request_irq() and whose interrupt handler is called first.
+ *	This handler does whatever needs to be done to the hardware to
+ *	acknowledge the interrupt (for PC-style ports there is nothing
+ *	special to be done).  It then tells the IEEE 1284 code about
+ *	the interrupt, which may involve reacting to an IEEE 1284
+ *	event depending on the current IEEE 1284 phase.  After this,
+ *	it calls @irq_func.  Needless to say, @irq_func will be called
+ *	from interrupt context, and may not block.
+ *
+ *	The %PARPORT_DEV_EXCL flag is for preventing port sharing, and
+ *	so should only be used when sharing the port with other device
+ *	drivers is impossible and would lead to incorrect behaviour.
+ *	Use it sparingly!  Normally, @flags will be zero.
+ *
+ *	This function returns a pointer to a structure that represents
+ *	the device on the port, or %NULL if there is not enough memory
+ *	to allocate space for that structure.
+ **/
+
 struct pardevice *
 parport_register_dev_model(struct parport *port, const char *name,
 			   const struct pardev_cb *par_dev_cb, int id)

commit aa3d6e7c49e3b480aa9db0e9924736726a6f75aa
Author: Joe Perches <joe@perches.com>
Date:   Fri Apr 3 14:43:17 2020 +0100

    parport: Use more comon logging styles
    
    Some of the logging can be poorly formatted because of unexpected
    line breaks given printks without KERN_CONT that should be pr_cont.
    
    Miscellanea:
    
    o Remove unnecessary spaces between function name and open parenthesis
    o Convert bare printks to pr_<level> where appropriate
    o Convert embedded function names to use %s, __func__
    o Coalesce formats
    o Realign arguments
    o Use do {} while (0) in a macro and not a bare if
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Reviewed-by: Randy Dunlap <rdunlap@infradead.org>
    Signed-off-by: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
    Link: https://lore.kernel.org/r/20200403134325.11523-3-sudipm.mukherjee@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/parport/share.c b/drivers/parport/share.c
index b0f4513251ee..3169feebdc19 100644
--- a/drivers/parport/share.c
+++ b/drivers/parport/share.c
@@ -720,8 +720,7 @@ parport_register_device(struct parport *port, const char *name,
 
 	if (port->physport->flags & PARPORT_FLAG_EXCL) {
 		/* An exclusive device is registered. */
-		printk(KERN_DEBUG "%s: no more devices allowed\n",
-			port->name);
+		printk(KERN_DEBUG "%s: no more devices allowed\n", port->name);
 		return NULL;
 	}
 
@@ -789,9 +788,8 @@ parport_register_device(struct parport *port, const char *name,
 	if (flags & PARPORT_DEV_EXCL) {
 		if (port->physport->devices) {
 			spin_unlock(&port->physport->pardevice_lock);
-			printk(KERN_DEBUG
-				"%s: cannot grant exclusive access for device %s\n",
-				port->name, name);
+			printk(KERN_DEBUG "%s: cannot grant exclusive access for device %s\n",
+			       port->name, name);
 			goto out_free_all;
 		}
 		port->flags |= PARPORT_FLAG_EXCL;
@@ -1259,7 +1257,8 @@ int parport_claim_or_block(struct pardevice *dev)
 	r = parport_claim(dev);
 	if (r == -EAGAIN) {
 #ifdef PARPORT_DEBUG_SHARING
-		printk(KERN_DEBUG "%s: parport_claim() returned -EAGAIN\n", dev->name);
+		printk(KERN_DEBUG "%s: parport_claim() returned -EAGAIN\n",
+		       dev->name);
 #endif
 		/*
 		 * FIXME!!! Use the proper locking for dev->waiting,
@@ -1292,7 +1291,7 @@ int parport_claim_or_block(struct pardevice *dev)
 		if (dev->port->physport->cad != dev)
 			printk(KERN_DEBUG "%s: exiting parport_claim_or_block but %s owns port!\n",
 			       dev->name, dev->port->physport->cad ?
-			       dev->port->physport->cad->name:"nobody");
+			       dev->port->physport->cad->name : "nobody");
 #endif
 	}
 	dev->waiting = 0;

commit decf26f6ec25dac868782dc1751623a87d147831
Author: Joe Perches <joe@perches.com>
Date:   Fri Apr 3 14:43:16 2020 +0100

    parport: Convert printk(KERN_<LEVEL> to pr_<level>(
    
    Use the more common kernel style.
    
    Miscellanea:
    
    o Coalesce formats
    o Realign arguments
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Reviewed-by: Randy Dunlap <rdunlap@infradead.org>
    Signed-off-by: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
    Link: https://lore.kernel.org/r/20200403134325.11523-2-sudipm.mukherjee@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/parport/share.c b/drivers/parport/share.c
index d6920ebeabcd..b0f4513251ee 100644
--- a/drivers/parport/share.c
+++ b/drivers/parport/share.c
@@ -554,8 +554,8 @@ void parport_announce_port(struct parport *port)
 #endif
 
 	if (!port->dev)
-		printk(KERN_WARNING "%s: fix this legacy no-device port driver!\n",
-		       port->name);
+		pr_warn("%s: fix this legacy no-device port driver!\n",
+			port->name);
 
 	parport_proc_register(port);
 	mutex_lock(&registration_lock);
@@ -727,7 +727,8 @@ parport_register_device(struct parport *port, const char *name,
 
 	if (flags & PARPORT_DEV_LURK) {
 		if (!pf || !kf) {
-			printk(KERN_INFO "%s: refused to register lurking device (%s) without callbacks\n", port->name, name);
+			pr_info("%s: refused to register lurking device (%s) without callbacks\n",
+				port->name, name);
 			return NULL;
 		}
 	}
@@ -996,7 +997,7 @@ void parport_unregister_device(struct pardevice *dev)
 
 #ifdef PARPORT_PARANOID
 	if (!dev) {
-		printk(KERN_ERR "parport_unregister_device: passed NULL\n");
+		pr_err("%s: passed NULL\n", __func__);
 		return;
 	}
 #endif
@@ -1137,8 +1138,7 @@ int parport_claim(struct pardevice *dev)
 	unsigned long flags;
 
 	if (port->cad == dev) {
-		printk(KERN_INFO "%s: %s already owner\n",
-		       dev->port->name,dev->name);
+		pr_info("%s: %s already owner\n", dev->port->name, dev->name);
 		return 0;
 	}
 
@@ -1158,9 +1158,8 @@ int parport_claim(struct pardevice *dev)
 			 * I think we'll actually deadlock rather than
 			 * get here, but just in case..
 			 */
-			printk(KERN_WARNING
-			       "%s: %s released port when preempted!\n",
-			       port->name, oldcad->name);
+			pr_warn("%s: %s released port when preempted!\n",
+				port->name, oldcad->name);
 			if (port->cad)
 				goto blocked;
 		}
@@ -1320,8 +1319,8 @@ void parport_release(struct pardevice *dev)
 	write_lock_irqsave(&port->cad_lock, flags);
 	if (port->cad != dev) {
 		write_unlock_irqrestore(&port->cad_lock, flags);
-		printk(KERN_WARNING "%s: %s tried to release parport when not owner\n",
-		       port->name, dev->name);
+		pr_warn("%s: %s tried to release parport when not owner\n",
+			port->name, dev->name);
 		return;
 	}
 
@@ -1361,7 +1360,8 @@ void parport_release(struct pardevice *dev)
 			if (dev->port->cad) /* racy but no matter */
 				return;
 		} else {
-			printk(KERN_ERR "%s: don't know how to wake %s\n", port->name, pd->name);
+			pr_err("%s: don't know how to wake %s\n",
+			       port->name, pd->name);
 		}
 	}
 

commit 231ec2f24dad18d021b361045bbd618ba62a274e
Author: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
Date:   Wed Oct 16 15:45:39 2019 +0100

    parport: load lowlevel driver if ports not found
    
    Usually all the distro will load the parport low level driver as part
    of their initialization. But we can get into a situation where all the
    parallel port drivers are built as module and we unload all the modules
    at a later time. Then if we just do "modprobe parport" it will only
    load the parport module and will not load the low level driver which
    will actually register the ports. So, check the bus if there is any
    parport registered, if not, load the low level driver.
    
    We can get into the above situation with all distro but only Suse has
    setup the alias for "parport_lowlevel" and so it only works in Suse.
    Users of Debian based distro will need to load the lowlevel module
    manually.
    
    Signed-off-by: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
    Link: https://lore.kernel.org/r/20191016144540.18810-3-sudipm.mukherjee@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/parport/share.c b/drivers/parport/share.c
index 96538b7975e5..d6920ebeabcd 100644
--- a/drivers/parport/share.c
+++ b/drivers/parport/share.c
@@ -230,6 +230,18 @@ static int port_check(struct device *dev, void *dev_drv)
 	return 0;
 }
 
+/*
+ * Iterates through all the devices connected to the bus and return 1
+ * if the device is a parallel port.
+ */
+
+static int port_detect(struct device *dev, void *dev_drv)
+{
+	if (is_parport(dev))
+		return 1;
+	return 0;
+}
+
 /**
  *	parport_register_driver - register a parallel port device driver
  *	@drv: structure describing the driver
@@ -279,6 +291,15 @@ int __parport_register_driver(struct parport_driver *drv, struct module *owner,
 		if (ret)
 			return ret;
 
+		/*
+		 * check if bus has any parallel port registered, if
+		 * none is found then load the lowlevel driver.
+		 */
+		ret = bus_for_each_dev(&parport_bus_type, NULL, NULL,
+				       port_detect);
+		if (!ret)
+			get_lowlevel_driver();
+
 		mutex_lock(&registration_lock);
 		if (drv->match_port)
 			bus_for_each_dev(&parport_bus_type, NULL, drv,

commit e962cd9cf9cfb1f5db6bbad6a6470e5ccf56e290
Author: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
Date:   Wed Oct 16 15:45:38 2019 +0100

    parport: do not check portlist when using device-model
    
    We do not need to maintain a list of ports when we are using the
    device-model. The base layer is going to maintain the list for us and
    we can get the list of ports just using bus_for_each_dev().
    
    Signed-off-by: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
    Link: https://lore.kernel.org/r/20191016144540.18810-2-sudipm.mukherjee@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/parport/share.c b/drivers/parport/share.c
index 7b4ee33c1935..96538b7975e5 100644
--- a/drivers/parport/share.c
+++ b/drivers/parport/share.c
@@ -266,9 +266,6 @@ static int port_check(struct device *dev, void *dev_drv)
 int __parport_register_driver(struct parport_driver *drv, struct module *owner,
 			      const char *mod_name)
 {
-	if (list_empty(&portlist))
-		get_lowlevel_driver();
-
 	if (drv->devmodel) {
 		/* using device model */
 		int ret;
@@ -292,6 +289,8 @@ int __parport_register_driver(struct parport_driver *drv, struct module *owner,
 
 		drv->devmodel = false;
 
+		if (list_empty(&portlist))
+			get_lowlevel_driver();
 		mutex_lock(&registration_lock);
 		list_for_each_entry(port, &portlist, list)
 			drv->attach(port);

commit 1c7ebeabc9e5ee12e42075a597de40fdb9059530
Author: YueHaibing <yuehaibing@huawei.com>
Date:   Tue May 14 23:24:37 2019 +0800

    parport: Fix mem leak in parport_register_dev_model
    
    BUG: memory leak
    unreferenced object 0xffff8881df48cda0 (size 16):
      comm "syz-executor.0", pid 5077, jiffies 4295994670 (age 22.280s)
      hex dump (first 16 bytes):
        00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
      backtrace:
        [<00000000d2d0d5fe>] parport_register_dev_model+0x141/0x6e0 [parport]
        [<00000000782f6dab>] 0xffffffffc15d1196
        [<00000000d2ca6ae4>] platform_drv_probe+0x7e/0x100
        [<00000000628c2a94>] really_probe+0x342/0x4d0
        [<000000006874f5da>] driver_probe_device+0x8c/0x170
        [<00000000424de37a>] __device_attach_driver+0xda/0x100
        [<000000002acab09a>] bus_for_each_drv+0xfe/0x170
        [<000000003d9e5f31>] __device_attach+0x190/0x230
        [<0000000035d32f80>] bus_probe_device+0x123/0x140
        [<00000000a05ba627>] device_add+0x7cc/0xce0
        [<000000003f7560bf>] platform_device_add+0x230/0x3c0
        [<000000002a0be07d>] 0xffffffffc15d0949
        [<000000007361d8d2>] port_check+0x3b/0x50 [parport]
        [<000000004d67200f>] bus_for_each_dev+0x115/0x180
        [<000000003ccfd11c>] __parport_register_driver+0x1f0/0x210 [parport]
        [<00000000987f06fc>] 0xffffffffc15d803e
    
    After commit 4e5a74f1db8d ("parport: Revert "parport: fix
    memory leak""), free_pardevice do not free par_dev->state,
    we should free it in error path of parport_register_dev_model
    before return.
    
    Reported-by: Hulk Robot <hulkci@huawei.com>
    Fixes: 4e5a74f1db8d ("parport: Revert "parport: fix memory leak"")
    Signed-off-by: YueHaibing <yuehaibing@huawei.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/parport/share.c b/drivers/parport/share.c
index 5dc53d420ca8..7b4ee33c1935 100644
--- a/drivers/parport/share.c
+++ b/drivers/parport/share.c
@@ -895,6 +895,7 @@ parport_register_dev_model(struct parport *port, const char *name,
 	par_dev->devmodel = true;
 	ret = device_register(&par_dev->dev);
 	if (ret) {
+		kfree(par_dev->state);
 		put_device(&par_dev->dev);
 		goto err_put_port;
 	}
@@ -912,6 +913,7 @@ parport_register_dev_model(struct parport *port, const char *name,
 			spin_unlock(&port->physport->pardevice_lock);
 			pr_debug("%s: cannot grant exclusive access for device %s\n",
 				 port->name, name);
+			kfree(par_dev->state);
 			device_unregister(&par_dev->dev);
 			goto err_put_port;
 		}

commit a3ac7917b73070010c05b4485b8582a6c9cd69b6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Mar 25 14:49:00 2019 -0700

    Revert "parport: daisy: use new parport device model"
    
    This reverts commit 1aec4211204d9463d1fd209eb50453de16254599.
    
    Steven Rostedt reports that it causes a hang at bootup and bisected it
    to this commit.
    
    The troigger is apparently a module alias for "parport_lowlevel" that
    points to "parport_pc", which causes a hang with
    
        modprobe -q -- parport_lowlevel
    
    blocking forever with a backtrace like this:
    
        wait_for_completion_killable+0x1c/0x28
        call_usermodehelper_exec+0xa7/0x108
        __request_module+0x351/0x3d8
        get_lowlevel_driver+0x28/0x41 [parport]
        __parport_register_driver+0x39/0x1f4 [parport]
        daisy_drv_init+0x31/0x4f [parport]
        parport_bus_init+0x5d/0x7b [parport]
        parport_default_proc_register+0x26/0x1000 [parport]
        do_one_initcall+0xc2/0x1e0
        do_init_module+0x50/0x1d4
        load_module+0x1c2e/0x21b3
        sys_init_module+0xef/0x117
    
    Supid says:
     "Due to the new device model daisy driver will now try to find the
      parallel ports while trying to register its driver so that it can bind
      with them. Now, since daisy driver is loaded while parport bus is
      initialising the list of parport is still empty and it tries to load
      the lowlevel driver, which has an alias set to parport_pc, now causes
      a deadlock"
    
    But I don't think the daisy driver should be loaded by the parport
    initialization in the first place, so let's revert the whole change.
    
    If the daisy driver can just initialize separately on its own (like a
    driver should), instead of hooking into the parport init sequence
    directly, this issue probably would go away.
    
    Reported-and-bisected-by: Steven Rostedt (VMware) <rostedt@goodmis.org>
    Reported-by: Michal Kubecek <mkubecek@suse.cz>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/parport/share.c b/drivers/parport/share.c
index 0171b8dbcdcd..5dc53d420ca8 100644
--- a/drivers/parport/share.c
+++ b/drivers/parport/share.c
@@ -137,19 +137,11 @@ static struct bus_type parport_bus_type = {
 
 int parport_bus_init(void)
 {
-	int retval;
-
-	retval = bus_register(&parport_bus_type);
-	if (retval)
-		return retval;
-	daisy_drv_init();
-
-	return 0;
+	return bus_register(&parport_bus_type);
 }
 
 void parport_bus_exit(void)
 {
-	daisy_drv_exit();
 	bus_unregister(&parport_bus_type);
 }
 

commit 1aec4211204d9463d1fd209eb50453de16254599
Author: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
Date:   Wed Feb 13 08:47:06 2019 +0000

    parport: daisy: use new parport device model
    
    Modify parport daisy driver to use the new parallel port device model.
    
    Signed-off-by: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/parport/share.c b/drivers/parport/share.c
index 5dc53d420ca8..0171b8dbcdcd 100644
--- a/drivers/parport/share.c
+++ b/drivers/parport/share.c
@@ -137,11 +137,19 @@ static struct bus_type parport_bus_type = {
 
 int parport_bus_init(void)
 {
-	return bus_register(&parport_bus_type);
+	int retval;
+
+	retval = bus_register(&parport_bus_type);
+	if (retval)
+		return retval;
+	daisy_drv_init();
+
+	return 0;
 }
 
 void parport_bus_exit(void)
 {
+	daisy_drv_exit();
 	bus_unregister(&parport_bus_type);
 }
 

commit 03270c6ac6207fc55bbf9d20d195029dca210c79
Author: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
Date:   Mon Mar 6 23:23:42 2017 +0000

    parport: fix attempt to write duplicate procfiles
    
    Usually every parallel port will have a single pardev registered with
    it. But ppdev driver is an exception. This userspace parallel port
    driver allows to create multiple parrallel port devices for a single
    parallel port. And as a result we were having a nice warning like:
    "sysctl table check failed:
    /dev/parport/parport0/devices/ppdev0/timeslice Sysctl already exists"
    
    Use the same logic as used in parport_register_device() and register
    the proc files only once for each parallel port.
    
    Fixes: 6fa45a226897 ("parport: add device-model to parport subsystem")
    Cc: stable <stable@vger.kernel.org> # v4.4+
    Bugzilla: https://bugzilla.redhat.com/show_bug.cgi?id=1414656
    Bugzilla: https://bugs.archlinux.org/task/52322
    Tested-by: James Feeney <james@nurealm.net>
    Signed-off-by: Sudip Mukherjee <sudip.mukherjee@codethink.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/parport/share.c b/drivers/parport/share.c
index bc090daa850a..5dc53d420ca8 100644
--- a/drivers/parport/share.c
+++ b/drivers/parport/share.c
@@ -939,8 +939,10 @@ parport_register_dev_model(struct parport *port, const char *name,
 	 * pardevice fields. -arca
 	 */
 	port->ops->init_state(par_dev, par_dev->state);
-	port->proc_device = par_dev;
-	parport_device_proc_register(par_dev);
+	if (!test_and_set_bit(PARPORT_DEVPROC_REGISTERED, &port->devflags)) {
+		port->proc_device = par_dev;
+		parport_device_proc_register(par_dev);
+	}
 
 	return par_dev;
 

commit 174cd4b1e5fbd0d74c68cf3a74f5bd4923485512
Author: Ingo Molnar <mingo@kernel.org>
Date:   Thu Feb 2 19:15:33 2017 +0100

    sched/headers: Prepare to move signal wakeup & sigpending methods from <linux/sched.h> into <linux/sched/signal.h>
    
    Fix up affected files that include this signal functionality via sched.h.
    
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/parport/share.c b/drivers/parport/share.c
index 3308427ed9f7..bc090daa850a 100644
--- a/drivers/parport/share.c
+++ b/drivers/parport/share.c
@@ -27,7 +27,7 @@
 #include <linux/ioport.h>
 #include <linux/kernel.h>
 #include <linux/slab.h>
-#include <linux/sched.h>
+#include <linux/sched/signal.h>
 #include <linux/kmod.h>
 #include <linux/device.h>
 

commit e0a7f1f04cd9bb13df7503ba7156ff0a37c9f460
Author: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
Date:   Wed Oct 28 14:41:40 2015 +0530

    parport: avoid assignment in if
    
    It is not an usual practise to assign some value to a variable in the if
    test condition.
    
    Signed-off-by: Sudip Mukherjee <sudip@vectorindia.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/parport/share.c b/drivers/parport/share.c
index b68f19480dcf..3308427ed9f7 100644
--- a/drivers/parport/share.c
+++ b/drivers/parport/share.c
@@ -1120,7 +1120,8 @@ int parport_claim(struct pardevice *dev)
 
 	/* Preempt any current device */
 	write_lock_irqsave(&port->cad_lock, flags);
-	if ((oldcad = port->cad) != NULL) {
+	oldcad = port->cad;
+	if (oldcad) {
 		if (oldcad->preempt) {
 			if (oldcad->preempt(oldcad->private))
 				goto blocked;

commit e732b93c3276548bfa903d79c2083b2c8dc552af
Author: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
Date:   Wed Oct 28 14:41:39 2015 +0530

    parport: remove unneeded space
    
    checkpatch complains that space is prohibited between function name and
    open parenthesis '('.
    
    Signed-off-by: Sudip Mukherjee <sudip@vectorindia.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/parport/share.c b/drivers/parport/share.c
index ccd7df458ebc..b68f19480dcf 100644
--- a/drivers/parport/share.c
+++ b/drivers/parport/share.c
@@ -54,16 +54,16 @@ static LIST_HEAD(drivers);
 static DEFINE_MUTEX(registration_lock);
 
 /* What you can do to a port that's gone away.. */
-static void dead_write_lines (struct parport *p, unsigned char b){}
-static unsigned char dead_read_lines (struct parport *p) { return 0; }
-static unsigned char dead_frob_lines (struct parport *p, unsigned char b,
+static void dead_write_lines(struct parport *p, unsigned char b){}
+static unsigned char dead_read_lines(struct parport *p) { return 0; }
+static unsigned char dead_frob_lines(struct parport *p, unsigned char b,
 			     unsigned char c) { return 0; }
-static void dead_onearg (struct parport *p){}
-static void dead_initstate (struct pardevice *d, struct parport_state *s) { }
-static void dead_state (struct parport *p, struct parport_state *s) { }
-static size_t dead_write (struct parport *p, const void *b, size_t l, int f)
+static void dead_onearg(struct parport *p){}
+static void dead_initstate(struct pardevice *d, struct parport_state *s) { }
+static void dead_state(struct parport *p, struct parport_state *s) { }
+static size_t dead_write(struct parport *p, const void *b, size_t l, int f)
 { return 0; }
-static size_t dead_read (struct parport *p, void *b, size_t l, int f)
+static size_t dead_read(struct parport *p, void *b, size_t l, int f)
 { return 0; }
 static struct parport_operations dead_ops = {
 	.write_data	= dead_write_lines,	/* data */
@@ -194,7 +194,7 @@ static void detach_driver_chain(struct parport *port)
 	struct parport_driver *drv;
 	/* caller has exclusive registration_lock */
 	list_for_each_entry(drv, &drivers, list)
-		drv->detach (port);
+		drv->detach(port);
 
 	/*
 	 * call the detach function of the drivers registered in
@@ -205,13 +205,13 @@ static void detach_driver_chain(struct parport *port)
 }
 
 /* Ask kmod for some lowlevel drivers. */
-static void get_lowlevel_driver (void)
+static void get_lowlevel_driver(void)
 {
 	/*
 	 * There is no actual module called this: you should set
 	 * up an alias for modutils.
 	 */
-	request_module ("parport_lowlevel");
+	request_module("parport_lowlevel");
 }
 
 /*
@@ -267,7 +267,7 @@ int __parport_register_driver(struct parport_driver *drv, struct module *owner,
 			      const char *mod_name)
 {
 	if (list_empty(&portlist))
-		get_lowlevel_driver ();
+		get_lowlevel_driver();
 
 	if (drv->devmodel) {
 		/* using device model */
@@ -330,7 +330,7 @@ static int port_detach(struct device *dev, void *_drv)
  *	finished by the time this function returns.
  **/
 
-void parport_unregister_driver (struct parport_driver *drv)
+void parport_unregister_driver(struct parport_driver *drv)
 {
 	struct parport *port;
 
@@ -375,7 +375,7 @@ static void free_port(struct device *dev)
  *	until the matching parport_put_port() call.
  **/
 
-struct parport *parport_get_port (struct parport *port)
+struct parport *parport_get_port(struct parport *port)
 {
 	struct device *dev = get_device(&port->bus_dev);
 
@@ -398,7 +398,7 @@ EXPORT_SYMBOL(parport_del_port);
  *	zero (port is no longer used), free_port is called.
  **/
 
-void parport_put_port (struct parport *port)
+void parport_put_port(struct parport *port)
 {
 	put_device(&port->bus_dev);
 }
@@ -458,7 +458,7 @@ struct parport *parport_register_port(unsigned long base, int irq, int dma,
 	tmp->flags = 0;
 	tmp->ops = ops;
 	tmp->physport = tmp;
-	memset (tmp->probe_info, 0, 5 * sizeof (struct parport_device_info));
+	memset(tmp->probe_info, 0, 5 * sizeof(struct parport_device_info));
 	rwlock_init(&tmp->cad_lock);
 	spin_lock_init(&tmp->waitlist_lock);
 	spin_lock_init(&tmp->pardevice_lock);
@@ -466,7 +466,7 @@ struct parport *parport_register_port(unsigned long base, int irq, int dma,
 	tmp->ieee1284.phase = IEEE1284_PH_FWD_IDLE;
 	sema_init(&tmp->ieee1284.irq, 0);
 	tmp->spintime = parport_default_spintime;
-	atomic_set (&tmp->ref_count, 1);
+	atomic_set(&tmp->ref_count, 1);
 	INIT_LIST_HEAD(&tmp->full_list);
 
 	name = kmalloc(15, GFP_KERNEL);
@@ -524,7 +524,7 @@ EXPORT_SYMBOL(parport_register_port);
  *	functions will be called, with @port as the parameter.
  **/
 
-void parport_announce_port (struct parport *port)
+void parport_announce_port(struct parport *port)
 {
 	int i;
 
@@ -549,7 +549,7 @@ void parport_announce_port (struct parport *port)
 	spin_unlock_irq(&parportlist_lock);
 
 	/* Let drivers know that new port(s) has arrived. */
-	attach_driver_chain (port);
+	attach_driver_chain(port);
 	for (i = 1; i < 3; i++) {
 		struct parport *slave = port->slaves[i-1];
 		if (slave)
@@ -585,7 +585,7 @@ void parport_remove_port(struct parport *port)
 	mutex_lock(&registration_lock);
 
 	/* Spread the word. */
-	detach_driver_chain (port);
+	detach_driver_chain(port);
 
 #ifdef CONFIG_PARPORT_1284
 	/* Forget the IEEE1284.3 topology of the port. */
@@ -700,7 +700,7 @@ parport_register_device(struct parport *port, const char *name,
 
 	if (port->physport->flags & PARPORT_FLAG_EXCL) {
 		/* An exclusive device is registered. */
-		printk (KERN_DEBUG "%s: no more devices allowed\n",
+		printk(KERN_DEBUG "%s: no more devices allowed\n",
 			port->name);
 		return NULL;
 	}
@@ -735,7 +735,7 @@ parport_register_device(struct parport *port, const char *name,
 	if (!try_module_get(port->ops->owner))
 		return NULL;
 
-	parport_get_port (port);
+	parport_get_port(port);
 
 	tmp = kmalloc(sizeof(struct pardevice), GFP_KERNEL);
 	if (!tmp)
@@ -767,8 +767,8 @@ parport_register_device(struct parport *port, const char *name,
 
 	if (flags & PARPORT_DEV_EXCL) {
 		if (port->physport->devices) {
-			spin_unlock (&port->physport->pardevice_lock);
-			printk (KERN_DEBUG
+			spin_unlock(&port->physport->pardevice_lock);
+			printk(KERN_DEBUG
 				"%s: cannot grant exclusive access for device %s\n",
 				port->name, name);
 			goto out_free_all;
@@ -807,7 +807,7 @@ parport_register_device(struct parport *port, const char *name,
  out_free_pardevice:
 	kfree(tmp);
  out:
-	parport_put_port (port);
+	parport_put_port(port);
 	module_put(port->ops->owner);
 
 	return NULL;
@@ -988,7 +988,7 @@ void parport_unregister_device(struct pardevice *dev)
 	if (port->cad == dev) {
 		printk(KERN_DEBUG "%s: %s forgot to release port\n",
 		       port->name, dev->name);
-		parport_release (dev);
+		parport_release(dev);
 	}
 
 	spin_lock(&port->pardevice_lock);
@@ -1028,7 +1028,7 @@ void parport_unregister_device(struct pardevice *dev)
 		kfree(dev);
 
 	module_put(port->ops->owner);
-	parport_put_port (port);
+	parport_put_port(port);
 }
 EXPORT_SYMBOL(parport_unregister_device);
 
@@ -1044,21 +1044,21 @@ EXPORT_SYMBOL(parport_unregister_device);
  *	gives you, use parport_put_port().
  */
 
-struct parport *parport_find_number (int number)
+struct parport *parport_find_number(int number)
 {
 	struct parport *port, *result = NULL;
 
 	if (list_empty(&portlist))
-		get_lowlevel_driver ();
+		get_lowlevel_driver();
 
-	spin_lock (&parportlist_lock);
+	spin_lock(&parportlist_lock);
 	list_for_each_entry(port, &portlist, list) {
 		if (port->number == number) {
-			result = parport_get_port (port);
+			result = parport_get_port(port);
 			break;
 		}
 	}
-	spin_unlock (&parportlist_lock);
+	spin_unlock(&parportlist_lock);
 	return result;
 }
 EXPORT_SYMBOL(parport_find_number);
@@ -1075,21 +1075,21 @@ EXPORT_SYMBOL(parport_find_number);
  *	gives you, use parport_put_port().
  */
 
-struct parport *parport_find_base (unsigned long base)
+struct parport *parport_find_base(unsigned long base)
 {
 	struct parport *port, *result = NULL;
 
 	if (list_empty(&portlist))
-		get_lowlevel_driver ();
+		get_lowlevel_driver();
 
-	spin_lock (&parportlist_lock);
+	spin_lock(&parportlist_lock);
 	list_for_each_entry(port, &portlist, list) {
 		if (port->base == base) {
-			result = parport_get_port (port);
+			result = parport_get_port(port);
 			break;
 		}
 	}
-	spin_unlock (&parportlist_lock);
+	spin_unlock(&parportlist_lock);
 	return result;
 }
 EXPORT_SYMBOL(parport_find_base);
@@ -1119,7 +1119,7 @@ int parport_claim(struct pardevice *dev)
 	}
 
 	/* Preempt any current device */
-	write_lock_irqsave (&port->cad_lock, flags);
+	write_lock_irqsave(&port->cad_lock, flags);
 	if ((oldcad = port->cad) != NULL) {
 		if (oldcad->preempt) {
 			if (oldcad->preempt(oldcad->private))
@@ -1146,7 +1146,7 @@ int parport_claim(struct pardevice *dev)
 		dev->waiting = 0;
 
 		/* Take ourselves out of the wait list again.  */
-		spin_lock_irq (&port->waitlist_lock);
+		spin_lock_irq(&port->waitlist_lock);
 		if (dev->waitprev)
 			dev->waitprev->waitnext = dev->waitnext;
 		else
@@ -1155,7 +1155,7 @@ int parport_claim(struct pardevice *dev)
 			dev->waitnext->waitprev = dev->waitprev;
 		else
 			port->waittail = dev->waitprev;
-		spin_unlock_irq (&port->waitlist_lock);
+		spin_unlock_irq(&port->waitlist_lock);
 		dev->waitprev = dev->waitnext = NULL;
 	}
 
@@ -1172,7 +1172,7 @@ int parport_claim(struct pardevice *dev)
 	/* If it's a daisy chain device, select it. */
 	if (dev->daisy >= 0) {
 		/* This could be lazier. */
-		if (!parport_daisy_select (port, dev->daisy,
+		if (!parport_daisy_select(port, dev->daisy,
 					   IEEE1284_MODE_COMPAT))
 			port->daisy = dev->daisy;
 	}
@@ -1193,7 +1193,7 @@ int parport_claim(struct pardevice *dev)
 
 	/* The cad_lock is still held for writing here */
 	if (dev->waiting & 2 || dev->wakeup) {
-		spin_lock (&port->waitlist_lock);
+		spin_lock(&port->waitlist_lock);
 		if (test_and_set_bit(0, &dev->waiting) == 0) {
 			/* First add ourselves to the end of the wait list. */
 			dev->waitnext = NULL;
@@ -1204,9 +1204,9 @@ int parport_claim(struct pardevice *dev)
 			} else
 				port->waithead = port->waittail = dev;
 		}
-		spin_unlock (&port->waitlist_lock);
+		spin_unlock(&port->waitlist_lock);
 	}
-	write_unlock_irqrestore (&port->cad_lock, flags);
+	write_unlock_irqrestore(&port->cad_lock, flags);
 	return -EAGAIN;
 }
 EXPORT_SYMBOL(parport_claim);
@@ -1253,7 +1253,7 @@ int parport_claim_or_block(struct pardevice *dev)
 		if (dev->waiting) {
 			wait_event_interruptible(dev->wait_q,
 						 !dev->waiting);
-			if (signal_pending (current))
+			if (signal_pending(current))
 				return -EINTR;
 			r = 1;
 		} else {
@@ -1294,7 +1294,7 @@ void parport_release(struct pardevice *dev)
 	/* Make sure that dev is the current device */
 	write_lock_irqsave(&port->cad_lock, flags);
 	if (port->cad != dev) {
-		write_unlock_irqrestore (&port->cad_lock, flags);
+		write_unlock_irqrestore(&port->cad_lock, flags);
 		printk(KERN_WARNING "%s: %s tried to release parport when not owner\n",
 		       port->name, dev->name);
 		return;
@@ -1309,7 +1309,7 @@ void parport_release(struct pardevice *dev)
 
 	/* If this is a daisy device, deselect it. */
 	if (dev->daisy >= 0) {
-		parport_daisy_deselect_all (port);
+		parport_daisy_deselect_all(port);
 		port->daisy = -1;
 	}
 #endif

commit b95b9d6cdecabfd99e074d6fda51dc962fd2a1cf
Author: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
Date:   Wed Oct 28 14:41:38 2015 +0530

    parport: change style of NULL comparison
    
    checkpatch was complaining about NULL comparisons.
    
    Signed-off-by: Sudip Mukherjee <sudip@vectorindia.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/parport/share.c b/drivers/parport/share.c
index 441333bd4839..ccd7df458ebc 100644
--- a/drivers/parport/share.c
+++ b/drivers/parport/share.c
@@ -738,11 +738,11 @@ parport_register_device(struct parport *port, const char *name,
 	parport_get_port (port);
 
 	tmp = kmalloc(sizeof(struct pardevice), GFP_KERNEL);
-	if (tmp == NULL)
+	if (!tmp)
 		goto out;
 
 	tmp->state = kmalloc(sizeof(struct parport_state), GFP_KERNEL);
-	if (tmp->state == NULL)
+	if (!tmp->state)
 		goto out_free_pardevice;
 
 	tmp->name = name;
@@ -971,7 +971,7 @@ void parport_unregister_device(struct pardevice *dev)
 	struct parport *port;
 
 #ifdef PARPORT_PARANOID
-	if (dev == NULL) {
+	if (!dev) {
 		printk(KERN_ERR "parport_unregister_device: passed NULL\n");
 		return;
 	}
@@ -1345,7 +1345,7 @@ void parport_release(struct pardevice *dev)
 	 * interested in being woken up. (Note: no locking required)
 	 */
 	/* !!! LOCKING IS NEEDED HERE */
-	for (pd = port->devices; (port->cad == NULL) && pd; pd = pd->next) {
+	for (pd = port->devices; !port->cad && pd; pd = pd->next) {
 		if (pd->wakeup && pd != dev)
 			pd->wakeup(pd->private);
 	}

commit 47ec57ec0e52839b92066567e6eb02fb1e60e603
Author: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
Date:   Wed Oct 28 14:41:37 2015 +0530

    parport: remove unnecessary out of memory message
    
    If kmalloc() or kzalloc() fails we will get sufficient messages in the logs,
    no need to print these extra messages.
    
    Signed-off-by: Sudip Mukherjee <sudip@vectorindia.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/parport/share.c b/drivers/parport/share.c
index 5dbd6f434a91..441333bd4839 100644
--- a/drivers/parport/share.c
+++ b/drivers/parport/share.c
@@ -444,10 +444,8 @@ struct parport *parport_register_port(unsigned long base, int irq, int dma,
 	int ret;
 
 	tmp = kzalloc(sizeof(struct parport), GFP_KERNEL);
-	if (!tmp) {
-		printk(KERN_WARNING "parport: memory squeeze\n");
+	if (!tmp)
 		return NULL;
-	}
 
 	/* Init our structure */
 	tmp->base = base;
@@ -473,7 +471,6 @@ struct parport *parport_register_port(unsigned long base, int irq, int dma,
 
 	name = kmalloc(15, GFP_KERNEL);
 	if (!name) {
-		printk(KERN_ERR "parport: memory squeeze\n");
 		kfree(tmp);
 		return NULL;
 	}
@@ -741,16 +738,12 @@ parport_register_device(struct parport *port, const char *name,
 	parport_get_port (port);
 
 	tmp = kmalloc(sizeof(struct pardevice), GFP_KERNEL);
-	if (tmp == NULL) {
-		printk(KERN_WARNING "%s: memory squeeze, couldn't register %s.\n", port->name, name);
+	if (tmp == NULL)
 		goto out;
-	}
 
 	tmp->state = kmalloc(sizeof(struct parport_state), GFP_KERNEL);
-	if (tmp->state == NULL) {
-		printk(KERN_WARNING "%s: memory squeeze, couldn't register %s.\n", port->name, name);
+	if (tmp->state == NULL)
 		goto out_free_pardevice;
-	}
 
 	tmp->name = name;
 	tmp->port = port;

commit 13efa75d4e5d467f685bd54df310919ae4dc8eac
Author: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
Date:   Wed Oct 28 14:41:36 2015 +0530

    parport: remove braces
    
    checkpatch was complaining about braces for single statement block.
    
    Signed-off-by: Sudip Mukherjee <sudip@vectorindia.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/parport/share.c b/drivers/parport/share.c
index dcad902f04a4..5dbd6f434a91 100644
--- a/drivers/parport/share.c
+++ b/drivers/parport/share.c
@@ -735,9 +735,8 @@ parport_register_device(struct parport *port, const char *name,
 	 * neither of us gets unloaded while we sleep in (e.g.)
 	 * kmalloc.
 	 */
-	if (!try_module_get(port->ops->owner)) {
+	if (!try_module_get(port->ops->owner))
 		return NULL;
-	}
 
 	parport_get_port (port);
 
@@ -1261,9 +1260,8 @@ int parport_claim_or_block(struct pardevice *dev)
 		if (dev->waiting) {
 			wait_event_interruptible(dev->wait_q,
 						 !dev->waiting);
-			if (signal_pending (current)) {
+			if (signal_pending (current))
 				return -EINTR;
-			}
 			r = 1;
 		} else {
 			r = 0;

commit a162188f9ca940b84a9ea61d88b50a8f408e0c0c
Author: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
Date:   Wed Oct 28 14:41:35 2015 +0530

    parport: quoted strings should not be split
    
    user visible strings should not be split as that affects the ability to
    grep.
    
    Signed-off-by: Sudip Mukherjee <sudip@vectorindia.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/parport/share.c b/drivers/parport/share.c
index 388c138304c1..dcad902f04a4 100644
--- a/drivers/parport/share.c
+++ b/drivers/parport/share.c
@@ -537,9 +537,8 @@ void parport_announce_port (struct parport *port)
 #endif
 
 	if (!port->dev)
-		printk(KERN_WARNING "%s: fix this legacy "
-				"no-device port driver!\n",
-				port->name);
+		printk(KERN_WARNING "%s: fix this legacy no-device port driver!\n",
+		       port->name);
 
 	parport_proc_register(port);
 	mutex_lock(&registration_lock);
@@ -778,8 +777,8 @@ parport_register_device(struct parport *port, const char *name,
 		if (port->physport->devices) {
 			spin_unlock (&port->physport->pardevice_lock);
 			printk (KERN_DEBUG
-				"%s: cannot grant exclusive access for "
-				"device %s\n", port->name, name);
+				"%s: cannot grant exclusive access for device %s\n",
+				port->name, name);
 			goto out_free_all;
 		}
 		port->flags |= PARPORT_FLAG_EXCL;
@@ -1276,9 +1275,8 @@ int parport_claim_or_block(struct pardevice *dev)
 
 #ifdef PARPORT_DEBUG_SHARING
 		if (dev->port->physport->cad != dev)
-			printk(KERN_DEBUG "%s: exiting parport_claim_or_block "
-			       "but %s owns port!\n", dev->name,
-			       dev->port->physport->cad ?
+			printk(KERN_DEBUG "%s: exiting parport_claim_or_block but %s owns port!\n",
+			       dev->name, dev->port->physport->cad ?
 			       dev->port->physport->cad->name:"nobody");
 #endif
 	}
@@ -1306,8 +1304,8 @@ void parport_release(struct pardevice *dev)
 	write_lock_irqsave(&port->cad_lock, flags);
 	if (port->cad != dev) {
 		write_unlock_irqrestore (&port->cad_lock, flags);
-		printk(KERN_WARNING "%s: %s tried to release parport "
-		       "when not owner\n", port->name, dev->name);
+		printk(KERN_WARNING "%s: %s tried to release parport when not owner\n",
+		       port->name, dev->name);
 		return;
 	}
 

commit b075e6f0510e12b38dbbb66141c5188e8c11ab8b
Author: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
Date:   Wed Oct 28 14:41:34 2015 +0530

    parport: code indent should use tabs
    
    Code should be indented using tabs and not by space.
    
    Signed-off-by: Sudip Mukherjee <sudip@vectorindia.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/parport/share.c b/drivers/parport/share.c
index 840c73063a6a..388c138304c1 100644
--- a/drivers/parport/share.c
+++ b/drivers/parport/share.c
@@ -455,7 +455,7 @@ struct parport *parport_register_port(unsigned long base, int irq, int dma,
 	tmp->dma = dma;
 	tmp->muxport = tmp->daisy = tmp->muxsel = -1;
 	tmp->modes = 0;
- 	INIT_LIST_HEAD(&tmp->list);
+	INIT_LIST_HEAD(&tmp->list);
 	tmp->devices = tmp->cad = NULL;
 	tmp->flags = 0;
 	tmp->ops = ops;

commit 7b7a0a30c985145bf4474639d832c94cd63059fa
Author: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
Date:   Wed Oct 28 14:41:33 2015 +0530

    parport: fix coding style
    
    The multi-line comments were not according to the kernel coding style.
    
    Signed-off-by: Sudip Mukherjee <sudip@vectorindia.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/parport/share.c b/drivers/parport/share.c
index d85e566548b1..840c73063a6a 100644
--- a/drivers/parport/share.c
+++ b/drivers/parport/share.c
@@ -207,8 +207,10 @@ static void detach_driver_chain(struct parport *port)
 /* Ask kmod for some lowlevel drivers. */
 static void get_lowlevel_driver (void)
 {
-	/* There is no actual module called this: you should set
-	 * up an alias for modutils. */
+	/*
+	 * There is no actual module called this: you should set
+	 * up an alias for modutils.
+	 */
 	request_module ("parport_lowlevel");
 }
 
@@ -728,11 +730,12 @@ parport_register_device(struct parport *port, const char *name,
 		}
 	}
 
-	/* We up our own module reference count, and that of the port
-           on which a device is to be registered, to ensure that
-           neither of us gets unloaded while we sleep in (e.g.)
-           kmalloc.
-         */
+	/*
+	 * We up our own module reference count, and that of the port
+	 * on which a device is to be registered, to ensure that
+	 * neither of us gets unloaded while we sleep in (e.g.)
+	 * kmalloc.
+	 */
 	if (!try_module_get(port->ops->owner)) {
 		return NULL;
 	}
@@ -783,9 +786,11 @@ parport_register_device(struct parport *port, const char *name,
 	}
 
 	tmp->next = port->physport->devices;
-	wmb(); /* Make sure that tmp->next is written before it's
-                  added to the list; see comments marked 'no locking
-                  required' */
+	wmb(); /*
+		* Make sure that tmp->next is written before it's
+		* added to the list; see comments marked 'no locking
+		* required'
+		*/
 	if (port->physport->devices)
 		port->physport->devices->prev = tmp;
 	port->physport->devices = tmp;
@@ -1008,8 +1013,10 @@ void parport_unregister_device(struct pardevice *dev)
 
 	spin_unlock(&port->pardevice_lock);
 
-	/* Make sure we haven't left any pointers around in the wait
-	 * list. */
+	/*
+	 * Make sure we haven't left any pointers around in the wait
+	 * list.
+	 */
 	spin_lock_irq(&port->waitlist_lock);
 	if (dev->waitprev || dev->waitnext || port->waithead == dev) {
 		if (dev->waitprev)
@@ -1131,8 +1138,10 @@ int parport_claim(struct pardevice *dev)
 			goto blocked;
 
 		if (port->cad != oldcad) {
-			/* I think we'll actually deadlock rather than
-                           get here, but just in case.. */
+			/*
+			 * I think we'll actually deadlock rather than
+			 * get here, but just in case..
+			 */
 			printk(KERN_WARNING
 			       "%s: %s released port when preempted!\n",
 			       port->name, oldcad->name);
@@ -1185,9 +1194,11 @@ int parport_claim(struct pardevice *dev)
 	return 0;
 
 blocked:
-	/* If this is the first time we tried to claim the port, register an
-	   interest.  This is only allowed for devices sleeping in
-	   parport_claim_or_block(), or those with a wakeup function.  */
+	/*
+	 * If this is the first time we tried to claim the port, register an
+	 * interest.  This is only allowed for devices sleeping in
+	 * parport_claim_or_block(), or those with a wakeup function.
+	 */
 
 	/* The cad_lock is still held for writing here */
 	if (dev->waiting & 2 || dev->wakeup) {
@@ -1223,8 +1234,10 @@ int parport_claim_or_block(struct pardevice *dev)
 {
 	int r;
 
-	/* Signal to parport_claim() that we can wait even without a
-	   wakeup function.  */
+	/*
+	 * Signal to parport_claim() that we can wait even without a
+	 * wakeup function.
+	 */
 	dev->waiting = 2;
 
 	/* Try to claim the port.  If this fails, we need to sleep.  */
@@ -1242,8 +1255,10 @@ int parport_claim_or_block(struct pardevice *dev)
 		 * See also parport_release()
 		 */
 
-		/* If dev->waiting is clear now, an interrupt
-		   gave us the port and we would deadlock if we slept.  */
+		/*
+		 * If dev->waiting is clear now, an interrupt
+		 * gave us the port and we would deadlock if we slept.
+		 */
 		if (dev->waiting) {
 			wait_event_interruptible(dev->wait_q,
 						 !dev->waiting);
@@ -1316,8 +1331,10 @@ void parport_release(struct pardevice *dev)
 	/* Save control registers */
 	port->ops->save_state(port, dev->state);
 
-	/* If anybody is waiting, find out who's been there longest and
-	   then wake them up. (Note: no locking required) */
+	/*
+	 * If anybody is waiting, find out who's been there longest and
+	 * then wake them up. (Note: no locking required)
+	 */
 	/* !!! LOCKING IS NEEDED HERE */
 	for (pd = port->waithead; pd; pd = pd->waitnext) {
 		if (pd->waiting & 2) { /* sleeping in claim_or_block */
@@ -1334,8 +1351,10 @@ void parport_release(struct pardevice *dev)
 		}
 	}
 
-	/* Nobody was waiting, so walk the list to see if anyone is
-	   interested in being woken up. (Note: no locking required) */
+	/*
+	 * Nobody was waiting, so walk the list to see if anyone is
+	 * interested in being woken up. (Note: no locking required)
+	 */
 	/* !!! LOCKING IS NEEDED HERE */
 	for (pd = port->devices; (port->cad == NULL) && pd; pd = pd->next) {
 		if (pd->wakeup && pd != dev)

commit 27c6db2655502978c670bd15a1639066ff13c78c
Author: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
Date:   Wed Oct 28 14:41:32 2015 +0530

    parport: EXPORT_SYMBOL should follow function
    
    All symbols were exported at the end of the file but they are supposed
    to be exported just after the function. And checkpatch was complaining
    about it.
    
    Signed-off-by: Sudip Mukherjee <sudip@vectorindia.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/parport/share.c b/drivers/parport/share.c
index b7fcb7fdb44a..d85e566548b1 100644
--- a/drivers/parport/share.c
+++ b/drivers/parport/share.c
@@ -343,6 +343,7 @@ void parport_unregister_driver (struct parport_driver *drv)
 	}
 	mutex_unlock(&registration_lock);
 }
+EXPORT_SYMBOL(parport_unregister_driver);
 
 static void free_port(struct device *dev)
 {
@@ -378,6 +379,7 @@ struct parport *parport_get_port (struct parport *port)
 
 	return to_parport_dev(dev);
 }
+EXPORT_SYMBOL(parport_get_port);
 
 void parport_del_port(struct parport *port)
 {
@@ -398,6 +400,7 @@ void parport_put_port (struct parport *port)
 {
 	put_device(&port->bus_dev);
 }
+EXPORT_SYMBOL(parport_put_port);
 
 /**
  *	parport_register_port - register a parallel port
@@ -508,6 +511,7 @@ struct parport *parport_register_port(unsigned long base, int irq, int dma,
 
 	return tmp;
 }
+EXPORT_SYMBOL(parport_register_port);
 
 /**
  *	parport_announce_port - tell device drivers about a parallel port
@@ -555,6 +559,7 @@ void parport_announce_port (struct parport *port)
 	}
 	mutex_unlock(&registration_lock);
 }
+EXPORT_SYMBOL(parport_announce_port);
 
 /**
  *	parport_remove_port - deregister a parallel port
@@ -616,6 +621,7 @@ void parport_remove_port(struct parport *port)
 			parport_put_port(slave);
 	}
 }
+EXPORT_SYMBOL(parport_remove_port);
 
 /**
  *	parport_register_device - register a device on a parallel port
@@ -810,6 +816,7 @@ parport_register_device(struct parport *port, const char *name,
 
 	return NULL;
 }
+EXPORT_SYMBOL(parport_register_device);
 
 static void free_pardevice(struct device *dev)
 {
@@ -1025,6 +1032,7 @@ void parport_unregister_device(struct pardevice *dev)
 	module_put(port->ops->owner);
 	parport_put_port (port);
 }
+EXPORT_SYMBOL(parport_unregister_device);
 
 /**
  *	parport_find_number - find a parallel port by number
@@ -1055,6 +1063,7 @@ struct parport *parport_find_number (int number)
 	spin_unlock (&parportlist_lock);
 	return result;
 }
+EXPORT_SYMBOL(parport_find_number);
 
 /**
  *	parport_find_base - find a parallel port by base address
@@ -1085,6 +1094,7 @@ struct parport *parport_find_base (unsigned long base)
 	spin_unlock (&parportlist_lock);
 	return result;
 }
+EXPORT_SYMBOL(parport_find_base);
 
 /**
  *	parport_claim - claim access to a parallel port device
@@ -1197,6 +1207,7 @@ int parport_claim(struct pardevice *dev)
 	write_unlock_irqrestore (&port->cad_lock, flags);
 	return -EAGAIN;
 }
+EXPORT_SYMBOL(parport_claim);
 
 /**
  *	parport_claim_or_block - claim access to a parallel port device
@@ -1259,6 +1270,7 @@ int parport_claim_or_block(struct pardevice *dev)
 	dev->waiting = 0;
 	return r;
 }
+EXPORT_SYMBOL(parport_claim_or_block);
 
 /**
  *	parport_release - give up access to a parallel port device
@@ -1330,6 +1342,7 @@ void parport_release(struct pardevice *dev)
 			pd->wakeup(pd->private);
 	}
 }
+EXPORT_SYMBOL(parport_release);
 
 irqreturn_t parport_irq_handler(int irq, void *dev_id)
 {
@@ -1339,22 +1352,6 @@ irqreturn_t parport_irq_handler(int irq, void *dev_id)
 
 	return IRQ_HANDLED;
 }
-
-/* Exported symbols for modules. */
-
-EXPORT_SYMBOL(parport_claim);
-EXPORT_SYMBOL(parport_claim_or_block);
-EXPORT_SYMBOL(parport_release);
-EXPORT_SYMBOL(parport_register_port);
-EXPORT_SYMBOL(parport_announce_port);
-EXPORT_SYMBOL(parport_remove_port);
-EXPORT_SYMBOL(parport_unregister_driver);
-EXPORT_SYMBOL(parport_register_device);
-EXPORT_SYMBOL(parport_unregister_device);
-EXPORT_SYMBOL(parport_get_port);
-EXPORT_SYMBOL(parport_put_port);
-EXPORT_SYMBOL(parport_find_number);
-EXPORT_SYMBOL(parport_find_base);
 EXPORT_SYMBOL(parport_irq_handler);
 
 MODULE_LICENSE("GPL");

commit 657e24d35479b3edd84706db082f5e18a2270631
Author: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
Date:   Wed Oct 28 14:41:31 2015 +0530

    parport: remove trailing white space
    
    Trailing white space is not accepted in kernel coding style. Remove
    them.
    
    Signed-off-by: Sudip Mukherjee <sudip@vectorindia.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/parport/share.c b/drivers/parport/share.c
index 89316965904f..b7fcb7fdb44a 100644
--- a/drivers/parport/share.c
+++ b/drivers/parport/share.c
@@ -1,6 +1,6 @@
 /*
  * Parallel-port resource manager code.
- * 
+ *
  * Authors: David Campbell <campbell@tirian.che.curtin.edu.au>
  *          Tim Waugh <tim@cyberelk.demon.co.uk>
  *          Jose Renau <renau@acm.org>
@@ -93,7 +93,7 @@ static struct parport_operations dead_ops = {
 	.ecp_write_data	= dead_write,		/* ecp */
 	.ecp_read_data	= dead_read,
 	.ecp_write_addr	= dead_write,
- 
+
 	.compat_write_data	= dead_write,	/* compat */
 	.nibble_read_data	= dead_read,	/* nibble */
 	.byte_read_data		= dead_read,	/* byte */
@@ -689,7 +689,7 @@ void parport_remove_port(struct parport *port)
 struct pardevice *
 parport_register_device(struct parport *port, const char *name,
 			int (*pf)(void *), void (*kf)(void *),
-			void (*irq_func)(void *), 
+			void (*irq_func)(void *),
 			int flags, void *handle)
 {
 	struct pardevice *tmp;
@@ -730,7 +730,7 @@ parport_register_device(struct parport *port, const char *name,
 	if (!try_module_get(port->ops->owner)) {
 		return NULL;
 	}
-		
+
 	parport_get_port (port);
 
 	tmp = kmalloc(sizeof(struct pardevice), GFP_KERNEL);

commit e952736586098063fcb734550429b8a81a2c5d25
Author: Geliang Tang <geliangtang@163.com>
Date:   Wed Oct 28 14:41:30 2015 +0530

    parport: fix a trivial typo
    
    s/regsiter/register/
    
    Signed-off-by: Geliang Tang <geliangtang@163.com>
    Signed-off-by: Sudip Mukherjee <sudip@vectorindia.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/parport/share.c b/drivers/parport/share.c
index 5ce5ef211bdb..89316965904f 100644
--- a/drivers/parport/share.c
+++ b/drivers/parport/share.c
@@ -148,7 +148,7 @@ void parport_bus_exit(void)
 /*
  * iterates through all the drivers registered with the bus and sends the port
  * details to the match_port callback of the driver, so that the driver can
- * know about the new port that just regsitered with the bus and decide if it
+ * know about the new port that just registered with the bus and decide if it
  * wants to use this new port.
  */
 static int driver_check(struct device_driver *dev_drv, void *_port)

commit 4e5a74f1db8d6bea48306126fd445e2720f07a95
Author: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
Date:   Sat Jul 25 13:19:40 2015 +0530

    parport: Revert "parport: fix memory leak"
    
    This reverts commit 23c405912b88 ("parport: fix memory leak")
    
    par_dev->state was already being removed in parport_unregister_device().
    
    Reported-by: Ying Huang <ying.huang@intel.com>
    Signed-off-by: Sudip Mukherjee <sudip@vectorindia.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/parport/share.c b/drivers/parport/share.c
index c02b5f27798b..5ce5ef211bdb 100644
--- a/drivers/parport/share.c
+++ b/drivers/parport/share.c
@@ -816,7 +816,6 @@ static void free_pardevice(struct device *dev)
 	struct pardevice *par_dev = to_pardevice(dev);
 
 	kfree(par_dev->name);
-	kfree(par_dev->state);
 	kfree(par_dev);
 }
 

commit 68d35c7b3b1aa686e3039eb2626bf5e3ea8dbe81
Author: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
Date:   Mon Jun 15 20:05:51 2015 +0530

    parport: fix freeing freed memory
    
    After the reference count becomes 0 when put_device() is called, it will
    execute the release callback where we are freeing all the allocated
    memory associated with the device. So if we just continue on the error
    path then we are again freeing devname and trying to dereference par_dev
    which has already been free-ed in the release callback.
    
    Signed-off-by: Sudip Mukherjee <sudip@vectorindia.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/parport/share.c b/drivers/parport/share.c
index 1efec44e03aa..c02b5f27798b 100644
--- a/drivers/parport/share.c
+++ b/drivers/parport/share.c
@@ -892,8 +892,10 @@ parport_register_dev_model(struct parport *port, const char *name,
 	par_dev->dev.release = free_pardevice;
 	par_dev->devmodel = true;
 	ret = device_register(&par_dev->dev);
-	if (ret)
-		goto err_put_dev;
+	if (ret) {
+		put_device(&par_dev->dev);
+		goto err_put_port;
+	}
 
 	/* Chain this onto the list */
 	par_dev->prev = NULL;
@@ -940,8 +942,6 @@ parport_register_dev_model(struct parport *port, const char *name,
 
 	return par_dev;
 
-err_put_dev:
-	put_device(&par_dev->dev);
 err_free_devname:
 	kfree(devname);
 err_free_par_dev:

commit 23c405912b881e3ca516554efde852c2ad550b31
Author: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
Date:   Mon Jun 15 20:05:50 2015 +0530

    parport: fix memory leak
    
    After the reference count becomes 0 when put_device() is called, it will
    execute the release callback where we are freeing all the allocated
    memory associated with the device. We missed freeing par_dev->state.
    
    Signed-off-by: Sudip Mukherjee <sudip@vectorindia.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/parport/share.c b/drivers/parport/share.c
index d8079e37a606..1efec44e03aa 100644
--- a/drivers/parport/share.c
+++ b/drivers/parport/share.c
@@ -816,6 +816,7 @@ static void free_pardevice(struct device *dev)
 	struct pardevice *par_dev = to_pardevice(dev);
 
 	kfree(par_dev->name);
+	kfree(par_dev->state);
 	kfree(par_dev);
 }
 

commit cabea695875e3a07313c205a9753c7416126dfa2
Author: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
Date:   Mon Jun 15 20:05:49 2015 +0530

    parport: fix error handling
    
    After registering the device if exclusive access fails for any reason
    then we need to unregister the device to remove all references.
    
    Signed-off-by: Sudip Mukherjee <sudip@vectorindia.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/parport/share.c b/drivers/parport/share.c
index 8067f54ce050..d8079e37a606 100644
--- a/drivers/parport/share.c
+++ b/drivers/parport/share.c
@@ -907,7 +907,8 @@ parport_register_dev_model(struct parport *port, const char *name,
 			spin_unlock(&port->physport->pardevice_lock);
 			pr_debug("%s: cannot grant exclusive access for device %s\n",
 				 port->name, name);
-			goto err_put_dev;
+			device_unregister(&par_dev->dev);
+			goto err_put_port;
 		}
 		port->flags |= PARPORT_FLAG_EXCL;
 	}

commit 50566ac87065b9ade71aef5e69d23e06a0664db9
Author: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
Date:   Fri Jun 12 15:20:20 2015 +0530

    parport: check exclusive access before register
    
    As of now we were starting the registration process and after the device
    is registered we were checking if the device can be used by the
    parport. Now lets check it first so that we do not need to go through
    the registration process only to fail at the end.
    The original exclusive access check at the end is still there so that we
    do not get any surprises if two different process registers its device
    with same parport and with exclusive access at the same time.
    
    Signed-off-by: Sudip Mukherjee <sudip@vectorindia.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/parport/share.c b/drivers/parport/share.c
index 697c6d7bf0fe..8067f54ce050 100644
--- a/drivers/parport/share.c
+++ b/drivers/parport/share.c
@@ -708,6 +708,20 @@ parport_register_device(struct parport *port, const char *name,
 		}
 	}
 
+	if (flags & PARPORT_DEV_EXCL) {
+		if (port->physport->devices) {
+			/*
+			 * If a device is already registered and this new
+			 * device wants exclusive access, then no need to
+			 * continue as we can not grant exclusive access to
+			 * this device.
+			 */
+			pr_err("%s: cannot grant exclusive access for device %s\n",
+			       port->name, name);
+			return NULL;
+		}
+	}
+
 	/* We up our own module reference count, and that of the port
            on which a device is to be registered, to ensure that
            neither of us gets unloaded while we sleep in (e.g.)
@@ -827,6 +841,20 @@ parport_register_dev_model(struct parport *port, const char *name,
 		}
 	}
 
+	if (par_dev_cb->flags & PARPORT_DEV_EXCL) {
+		if (port->physport->devices) {
+			/*
+			 * If a device is already registered and this new
+			 * device wants exclusive access, then no need to
+			 * continue as we can not grant exclusive access to
+			 * this device.
+			 */
+			pr_err("%s: cannot grant exclusive access for device %s\n",
+			       port->name, name);
+			return NULL;
+		}
+	}
+
 	if (!try_module_get(port->ops->owner))
 		return NULL;
 

commit 6fa45a22689722dac9f0e90c0931d4b34b334ede
Author: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
Date:   Wed May 20 20:56:57 2015 +0530

    parport: add device-model to parport subsystem
    
    parport subsystem starts using the device-model. Drivers using the
    device-model has to define devmodel as true and should register the
    device with parport using parport_register_dev_model().
    
    Tested-by: Jean Delvare <jdelvare@suse.de>
    Tested-by: Alan Cox <gnomes@lxorguk.ukuu.org.uk>
    Signed-off-by: Sudip Mukherjee <sudip@vectorindia.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/parport/share.c b/drivers/parport/share.c
index 3fa66244ce32..697c6d7bf0fe 100644
--- a/drivers/parport/share.c
+++ b/drivers/parport/share.c
@@ -29,6 +29,7 @@
 #include <linux/slab.h>
 #include <linux/sched.h>
 #include <linux/kmod.h>
+#include <linux/device.h>
 
 #include <linux/spinlock.h>
 #include <linux/mutex.h>
@@ -100,13 +101,91 @@ static struct parport_operations dead_ops = {
 	.owner		= NULL,
 };
 
+static struct device_type parport_device_type = {
+	.name = "parport",
+};
+
+static int is_parport(struct device *dev)
+{
+	return dev->type == &parport_device_type;
+}
+
+static int parport_probe(struct device *dev)
+{
+	struct parport_driver *drv;
+
+	if (is_parport(dev))
+		return -ENODEV;
+
+	drv = to_parport_driver(dev->driver);
+	if (!drv->probe) {
+		/* if driver has not defined a custom probe */
+		struct pardevice *par_dev = to_pardevice(dev);
+
+		if (strcmp(par_dev->name, drv->name))
+			return -ENODEV;
+		return 0;
+	}
+	/* if driver defined its own probe */
+	return drv->probe(to_pardevice(dev));
+}
+
+static struct bus_type parport_bus_type = {
+	.name = "parport",
+	.probe = parport_probe,
+};
+
+int parport_bus_init(void)
+{
+	return bus_register(&parport_bus_type);
+}
+
+void parport_bus_exit(void)
+{
+	bus_unregister(&parport_bus_type);
+}
+
+/*
+ * iterates through all the drivers registered with the bus and sends the port
+ * details to the match_port callback of the driver, so that the driver can
+ * know about the new port that just regsitered with the bus and decide if it
+ * wants to use this new port.
+ */
+static int driver_check(struct device_driver *dev_drv, void *_port)
+{
+	struct parport *port = _port;
+	struct parport_driver *drv = to_parport_driver(dev_drv);
+
+	if (drv->match_port)
+		drv->match_port(port);
+	return 0;
+}
+
 /* Call attach(port) for each registered driver. */
 static void attach_driver_chain(struct parport *port)
 {
 	/* caller has exclusive registration_lock */
 	struct parport_driver *drv;
+
 	list_for_each_entry(drv, &drivers, list)
 		drv->attach(port);
+
+	/*
+	 * call the driver_check function of the drivers registered in
+	 * new device model
+	 */
+
+	bus_for_each_drv(&parport_bus_type, NULL, port, driver_check);
+}
+
+static int driver_detach(struct device_driver *_drv, void *_port)
+{
+	struct parport *port = _port;
+	struct parport_driver *drv = to_parport_driver(_drv);
+
+	if (drv->detach)
+		drv->detach(port);
+	return 0;
 }
 
 /* Call detach(port) for each registered driver. */
@@ -116,6 +195,13 @@ static void detach_driver_chain(struct parport *port)
 	/* caller has exclusive registration_lock */
 	list_for_each_entry(drv, &drivers, list)
 		drv->detach (port);
+
+	/*
+	 * call the detach function of the drivers registered in
+	 * new device model
+	 */
+
+	bus_for_each_drv(&parport_bus_type, NULL, port, driver_detach);
 }
 
 /* Ask kmod for some lowlevel drivers. */
@@ -126,17 +212,39 @@ static void get_lowlevel_driver (void)
 	request_module ("parport_lowlevel");
 }
 
+/*
+ * iterates through all the devices connected to the bus and sends the device
+ * details to the match_port callback of the driver, so that the driver can
+ * know what are all the ports that are connected to the bus and choose the
+ * port to which it wants to register its device.
+ */
+static int port_check(struct device *dev, void *dev_drv)
+{
+	struct parport_driver *drv = dev_drv;
+
+	/* only send ports, do not send other devices connected to bus */
+	if (is_parport(dev))
+		drv->match_port(to_parport_dev(dev));
+	return 0;
+}
+
 /**
  *	parport_register_driver - register a parallel port device driver
  *	@drv: structure describing the driver
+ *	@owner: owner module of drv
+ *	@mod_name: module name string
  *
  *	This can be called by a parallel port device driver in order
  *	to receive notifications about ports being found in the
  *	system, as well as ports no longer available.
  *
+ *	If devmodel is true then the new device model is used
+ *	for registration.
+ *
  *	The @drv structure is allocated by the caller and must not be
  *	deallocated until after calling parport_unregister_driver().
  *
+ *	If using the non device model:
  *	The driver's attach() function may block.  The port that
  *	attach() is given will be valid for the duration of the
  *	callback, but if the driver wants to take a copy of the
@@ -148,21 +256,57 @@ static void get_lowlevel_driver (void)
  *	callback, but if the driver wants to take a copy of the
  *	pointer it must call parport_get_port() to do so.
  *
- *	Returns 0 on success.  Currently it always succeeds.
+ *
+ *	Returns 0 on success. The non device model will always succeeds.
+ *	but the new device model can fail and will return the error code.
  **/
 
-int parport_register_driver (struct parport_driver *drv)
+int __parport_register_driver(struct parport_driver *drv, struct module *owner,
+			      const char *mod_name)
 {
-	struct parport *port;
-
 	if (list_empty(&portlist))
 		get_lowlevel_driver ();
 
-	mutex_lock(&registration_lock);
-	list_for_each_entry(port, &portlist, list)
-		drv->attach(port);
-	list_add(&drv->list, &drivers);
-	mutex_unlock(&registration_lock);
+	if (drv->devmodel) {
+		/* using device model */
+		int ret;
+
+		/* initialize common driver fields */
+		drv->driver.name = drv->name;
+		drv->driver.bus = &parport_bus_type;
+		drv->driver.owner = owner;
+		drv->driver.mod_name = mod_name;
+		ret = driver_register(&drv->driver);
+		if (ret)
+			return ret;
+
+		mutex_lock(&registration_lock);
+		if (drv->match_port)
+			bus_for_each_dev(&parport_bus_type, NULL, drv,
+					 port_check);
+		mutex_unlock(&registration_lock);
+	} else {
+		struct parport *port;
+
+		drv->devmodel = false;
+
+		mutex_lock(&registration_lock);
+		list_for_each_entry(port, &portlist, list)
+			drv->attach(port);
+		list_add(&drv->list, &drivers);
+		mutex_unlock(&registration_lock);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(__parport_register_driver);
+
+static int port_detach(struct device *dev, void *_drv)
+{
+	struct parport_driver *drv = _drv;
+
+	if (is_parport(dev) && drv->detach)
+		drv->detach(to_parport_dev(dev));
 
 	return 0;
 }
@@ -189,15 +333,22 @@ void parport_unregister_driver (struct parport_driver *drv)
 	struct parport *port;
 
 	mutex_lock(&registration_lock);
-	list_del_init(&drv->list);
-	list_for_each_entry(port, &portlist, list)
-		drv->detach(port);
+	if (drv->devmodel) {
+		bus_for_each_dev(&parport_bus_type, NULL, drv, port_detach);
+		driver_unregister(&drv->driver);
+	} else {
+		list_del_init(&drv->list);
+		list_for_each_entry(port, &portlist, list)
+			drv->detach(port);
+	}
 	mutex_unlock(&registration_lock);
 }
 
-static void free_port (struct parport *port)
+static void free_port(struct device *dev)
 {
 	int d;
+	struct parport *port = to_parport_dev(dev);
+
 	spin_lock(&full_list_lock);
 	list_del(&port->full_list);
 	spin_unlock(&full_list_lock);
@@ -223,25 +374,29 @@ static void free_port (struct parport *port)
 
 struct parport *parport_get_port (struct parport *port)
 {
-	atomic_inc (&port->ref_count);
-	return port;
+	struct device *dev = get_device(&port->bus_dev);
+
+	return to_parport_dev(dev);
+}
+
+void parport_del_port(struct parport *port)
+{
+	device_unregister(&port->bus_dev);
 }
+EXPORT_SYMBOL(parport_del_port);
 
 /**
  *	parport_put_port - decrement a port's reference count
  *	@port: the port
  *
  *	This should be called once for each call to parport_get_port(),
- *	once the port is no longer needed.
+ *	once the port is no longer needed. When the reference count reaches
+ *	zero (port is no longer used), free_port is called.
  **/
 
 void parport_put_port (struct parport *port)
 {
-	if (atomic_dec_and_test (&port->ref_count))
-		/* Can destroy it now. */
-		free_port (port);
-
-	return;
+	put_device(&port->bus_dev);
 }
 
 /**
@@ -281,6 +436,7 @@ struct parport *parport_register_port(unsigned long base, int irq, int dma,
 	int num;
 	int device;
 	char *name;
+	int ret;
 
 	tmp = kzalloc(sizeof(struct parport), GFP_KERNEL);
 	if (!tmp) {
@@ -333,6 +489,10 @@ struct parport *parport_register_port(unsigned long base, int irq, int dma,
 	 */
 	sprintf(name, "parport%d", tmp->portnum = tmp->number);
 	tmp->name = name;
+	tmp->bus_dev.bus = &parport_bus_type;
+	tmp->bus_dev.release = free_port;
+	dev_set_name(&tmp->bus_dev, name);
+	tmp->bus_dev.type = &parport_device_type;
 
 	for (device = 0; device < 5; device++)
 		/* assume the worst */
@@ -340,6 +500,12 @@ struct parport *parport_register_port(unsigned long base, int irq, int dma,
 
 	tmp->waithead = tmp->waittail = NULL;
 
+	ret = device_register(&tmp->bus_dev);
+	if (ret) {
+		put_device(&tmp->bus_dev);
+		return NULL;
+	}
+
 	return tmp;
 }
 
@@ -575,6 +741,7 @@ parport_register_device(struct parport *port, const char *name,
 	tmp->irq_func = irq_func;
 	tmp->waiting = 0;
 	tmp->timeout = 5 * HZ;
+	tmp->devmodel = false;
 
 	/* Chain this onto the list */
 	tmp->prev = NULL;
@@ -630,6 +797,136 @@ parport_register_device(struct parport *port, const char *name,
 	return NULL;
 }
 
+static void free_pardevice(struct device *dev)
+{
+	struct pardevice *par_dev = to_pardevice(dev);
+
+	kfree(par_dev->name);
+	kfree(par_dev);
+}
+
+struct pardevice *
+parport_register_dev_model(struct parport *port, const char *name,
+			   const struct pardev_cb *par_dev_cb, int id)
+{
+	struct pardevice *par_dev;
+	int ret;
+	char *devname;
+
+	if (port->physport->flags & PARPORT_FLAG_EXCL) {
+		/* An exclusive device is registered. */
+		pr_err("%s: no more devices allowed\n", port->name);
+		return NULL;
+	}
+
+	if (par_dev_cb->flags & PARPORT_DEV_LURK) {
+		if (!par_dev_cb->preempt || !par_dev_cb->wakeup) {
+			pr_info("%s: refused to register lurking device (%s) without callbacks\n",
+				port->name, name);
+			return NULL;
+		}
+	}
+
+	if (!try_module_get(port->ops->owner))
+		return NULL;
+
+	parport_get_port(port);
+
+	par_dev = kzalloc(sizeof(*par_dev), GFP_KERNEL);
+	if (!par_dev)
+		goto err_put_port;
+
+	par_dev->state = kzalloc(sizeof(*par_dev->state), GFP_KERNEL);
+	if (!par_dev->state)
+		goto err_put_par_dev;
+
+	devname = kstrdup(name, GFP_KERNEL);
+	if (!devname)
+		goto err_free_par_dev;
+
+	par_dev->name = devname;
+	par_dev->port = port;
+	par_dev->daisy = -1;
+	par_dev->preempt = par_dev_cb->preempt;
+	par_dev->wakeup = par_dev_cb->wakeup;
+	par_dev->private = par_dev_cb->private;
+	par_dev->flags = par_dev_cb->flags;
+	par_dev->irq_func = par_dev_cb->irq_func;
+	par_dev->waiting = 0;
+	par_dev->timeout = 5 * HZ;
+
+	par_dev->dev.parent = &port->bus_dev;
+	par_dev->dev.bus = &parport_bus_type;
+	ret = dev_set_name(&par_dev->dev, "%s.%d", devname, id);
+	if (ret)
+		goto err_free_devname;
+	par_dev->dev.release = free_pardevice;
+	par_dev->devmodel = true;
+	ret = device_register(&par_dev->dev);
+	if (ret)
+		goto err_put_dev;
+
+	/* Chain this onto the list */
+	par_dev->prev = NULL;
+	/*
+	 * This function must not run from an irq handler so we don' t need
+	 * to clear irq on the local CPU. -arca
+	 */
+	spin_lock(&port->physport->pardevice_lock);
+
+	if (par_dev_cb->flags & PARPORT_DEV_EXCL) {
+		if (port->physport->devices) {
+			spin_unlock(&port->physport->pardevice_lock);
+			pr_debug("%s: cannot grant exclusive access for device %s\n",
+				 port->name, name);
+			goto err_put_dev;
+		}
+		port->flags |= PARPORT_FLAG_EXCL;
+	}
+
+	par_dev->next = port->physport->devices;
+	wmb();	/*
+		 * Make sure that tmp->next is written before it's
+		 * added to the list; see comments marked 'no locking
+		 * required'
+		 */
+	if (port->physport->devices)
+		port->physport->devices->prev = par_dev;
+	port->physport->devices = par_dev;
+	spin_unlock(&port->physport->pardevice_lock);
+
+	init_waitqueue_head(&par_dev->wait_q);
+	par_dev->timeslice = parport_default_timeslice;
+	par_dev->waitnext = NULL;
+	par_dev->waitprev = NULL;
+
+	/*
+	 * This has to be run as last thing since init_state may need other
+	 * pardevice fields. -arca
+	 */
+	port->ops->init_state(par_dev, par_dev->state);
+	port->proc_device = par_dev;
+	parport_device_proc_register(par_dev);
+
+	return par_dev;
+
+err_put_dev:
+	put_device(&par_dev->dev);
+err_free_devname:
+	kfree(devname);
+err_free_par_dev:
+	kfree(par_dev->state);
+err_put_par_dev:
+	if (!par_dev->devmodel)
+		kfree(par_dev);
+err_put_port:
+	parport_put_port(port);
+	module_put(port->ops->owner);
+
+	return NULL;
+}
+EXPORT_SYMBOL(parport_register_dev_model);
+
 /**
  *	parport_unregister_device - deregister a device on a parallel port
  *	@dev: pointer to structure representing device
@@ -691,7 +988,10 @@ void parport_unregister_device(struct pardevice *dev)
 	spin_unlock_irq(&port->waitlist_lock);
 
 	kfree(dev->state);
-	kfree(dev);
+	if (dev->devmodel)
+		device_unregister(&dev->dev);
+	else
+		kfree(dev);
 
 	module_put(port->ops->owner);
 	parport_put_port (port);
@@ -1019,7 +1319,6 @@ EXPORT_SYMBOL(parport_release);
 EXPORT_SYMBOL(parport_register_port);
 EXPORT_SYMBOL(parport_announce_port);
 EXPORT_SYMBOL(parport_remove_port);
-EXPORT_SYMBOL(parport_register_driver);
 EXPORT_SYMBOL(parport_unregister_driver);
 EXPORT_SYMBOL(parport_register_device);
 EXPORT_SYMBOL(parport_unregister_device);

commit 76ae0536ddc0aa576f2aac11f0f82d0fd60b522c
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Feb 26 12:01:49 2014 +0100

    parport: fix interruptible_sleep_on race
    
    The interruptible_sleep_on function is can still lead to the
    deadlock mentioned in the comment above the caller, and we want
    to remove it soon, so replace it now with the race-free
    wait_event_interruptible.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Cc: Andrew Morton <akpm@osdl.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/parport/share.c b/drivers/parport/share.c
index 6a83ee1e9178..3fa66244ce32 100644
--- a/drivers/parport/share.c
+++ b/drivers/parport/share.c
@@ -905,7 +905,8 @@ int parport_claim_or_block(struct pardevice *dev)
 		/* If dev->waiting is clear now, an interrupt
 		   gave us the port and we would deadlock if we slept.  */
 		if (dev->waiting) {
-			interruptible_sleep_on (&dev->wait_q);
+			wait_event_interruptible(dev->wait_q,
+						 !dev->waiting);
 			if (signal_pending (current)) {
 				return -EINTR;
 			}

commit c32df4e182e5bf40edde45da247318986d3cbf91
Author: Alexandru Gheorghiu <gheorghiuandru@gmail.com>
Date:   Wed Jul 3 15:09:09 2013 -0700

    drivers/parport/share.c: use kzalloc
    
    Replaced calls to kmalloc and memset with kzalloc.
    Patch found using coccinelle.
    
    Signed-off-by: Alexandru Gheorghiu <gheorghiuandru@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/parport/share.c b/drivers/parport/share.c
index a848e02e6be3..6a83ee1e9178 100644
--- a/drivers/parport/share.c
+++ b/drivers/parport/share.c
@@ -282,14 +282,13 @@ struct parport *parport_register_port(unsigned long base, int irq, int dma,
 	int device;
 	char *name;
 
-	tmp = kmalloc(sizeof(struct parport), GFP_KERNEL);
+	tmp = kzalloc(sizeof(struct parport), GFP_KERNEL);
 	if (!tmp) {
 		printk(KERN_WARNING "parport: memory squeeze\n");
 		return NULL;
 	}
 
 	/* Init our structure */
- 	memset(tmp, 0, sizeof(struct parport));
 	tmp->base = base;
 	tmp->irq = irq;
 	tmp->dma = dma;

commit cbeb4b7ad5346516d2ee726395eb5722b25a0a01
Author: Alexander Gordeev <lasaine@lvk.cs.msu.su>
Date:   Tue Jan 25 15:07:16 2011 -0800

    parport: make lockdep happy with waitlist_lock
    
    parport_unregister_device() should never be used when interrupts are
    enabled in hardware and irq handler is registered so there is no need to
    disable interrupts when using waitlist_lock.  But there is no way to
    explain this subtle semantics to lockdep analyzer.
    
    So disable interrupts here too to simplify things.  The price is
    negligible.
    
    Signed-off-by: Alexander Gordeev <lasaine@lvk.cs.msu.su>
    Cc: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/parport/share.c b/drivers/parport/share.c
index a2d9d1e59260..a848e02e6be3 100644
--- a/drivers/parport/share.c
+++ b/drivers/parport/share.c
@@ -678,7 +678,7 @@ void parport_unregister_device(struct pardevice *dev)
 
 	/* Make sure we haven't left any pointers around in the wait
 	 * list. */
-	spin_lock (&port->waitlist_lock);
+	spin_lock_irq(&port->waitlist_lock);
 	if (dev->waitprev || dev->waitnext || port->waithead == dev) {
 		if (dev->waitprev)
 			dev->waitprev->waitnext = dev->waitnext;
@@ -689,7 +689,7 @@ void parport_unregister_device(struct pardevice *dev)
 		else
 			port->waittail = dev->waitprev;
 	}
-	spin_unlock (&port->waitlist_lock);
+	spin_unlock_irq(&port->waitlist_lock);
 
 	kfree(dev->state);
 	kfree(dev);

commit a529f1505b6facfd0078dcb18a444976c1985962
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Sep 7 14:32:34 2010 +0000

    parport: Semaphore cleanup
    
    Get rid of init_MUTEX[_LOCKED]() and use sema_init() instead.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Cc: Christoph Hellwig <hch@infradead.org>
    LKML-Reference: <20100907125055.743613774@linutronix.de>

diff --git a/drivers/parport/share.c b/drivers/parport/share.c
index dffa5d4fb298..a2d9d1e59260 100644
--- a/drivers/parport/share.c
+++ b/drivers/parport/share.c
@@ -306,7 +306,7 @@ struct parport *parport_register_port(unsigned long base, int irq, int dma,
 	spin_lock_init(&tmp->pardevice_lock);
 	tmp->ieee1284.mode = IEEE1284_MODE_COMPAT;
 	tmp->ieee1284.phase = IEEE1284_PH_FWD_IDLE;
-	init_MUTEX_LOCKED (&tmp->ieee1284.irq); /* actually a semaphore at 0 */
+	sema_init(&tmp->ieee1284.irq, 0);
 	tmp->spintime = parport_default_spintime;
 	atomic_set (&tmp->ref_count, 1);
 	INIT_LIST_HEAD(&tmp->full_list);

commit 05ad709d04799125ed85dd816fdb558258102172
Author: Alan Cox <alan@etchedpixels.co.uk>
Date:   Tue Jun 2 16:58:10 2009 +0100

    parport: quickfix the proc registration bug
    
    Ideally we should have a directory of drivers and a link to the 'active'
    driver. For now just show the first device which is effectively the existing
    semantics without a warning.
    
    This is an update on the original buggy patch that I then forgot to
    resubmit. Confusingly it was proposed by Red Hat, written by Etched Pixels
    fixed and submitted by Intel ...
    
    Resolves-Bug: http://bugzilla.kernel.org/show_bug.cgi?id=9749
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/parport/share.c b/drivers/parport/share.c
index 0ebca450ed29..dffa5d4fb298 100644
--- a/drivers/parport/share.c
+++ b/drivers/parport/share.c
@@ -614,7 +614,10 @@ parport_register_device(struct parport *port, const char *name,
 	 * pardevice fields. -arca
 	 */
 	port->ops->init_state(tmp, tmp->state);
-	parport_device_proc_register(tmp);
+	if (!test_and_set_bit(PARPORT_DEVPROC_REGISTERED, &port->devflags)) {
+		port->proc_device = tmp;
+		parport_device_proc_register(tmp);
+	}
 	return tmp;
 
  out_free_all:
@@ -646,10 +649,14 @@ void parport_unregister_device(struct pardevice *dev)
 	}
 #endif
 
-	parport_device_proc_unregister(dev);
-
 	port = dev->port->physport;
 
+	if (port->proc_device == dev) {
+		port->proc_device = NULL;
+		clear_bit(PARPORT_DEVPROC_REGISTERED, &port->devflags);
+		parport_device_proc_unregister(dev);
+	}
+
 	if (port->cad == dev) {
 		printk(KERN_DEBUG "%s: %s forgot to release port\n",
 		       port->name, dev->name);

commit 612de10db06c0704a66bbe7fd13990cb1c2cb958
Author: Adrian Bunk <bunk@kernel.org>
Date:   Wed Oct 15 22:04:33 2008 -0700

    parport: remove CVS keywords
    
    Remove CVS keywords that weren't updated for a long time from comments.
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/parport/share.c b/drivers/parport/share.c
index a8a62bbbb576..0ebca450ed29 100644
--- a/drivers/parport/share.c
+++ b/drivers/parport/share.c
@@ -1,4 +1,4 @@
-/* $Id: parport_share.c,v 1.15 1998/01/11 12:06:17 philip Exp $
+/*
  * Parallel-port resource manager code.
  * 
  * Authors: David Campbell <campbell@tirian.che.curtin.edu.au>

commit 5712cb3d81566893c3b14e24075cf48ec5c35d00
Author: Jeff Garzik <jeff@garzik.org>
Date:   Fri Oct 19 02:54:26 2007 -0400

    [PARPORT] Remove unused 'irq' argument from parport irq functions
    
    None of the drivers with a struct pardevice's ->irq_func() hook ever
    used the 'irq' argument passed to it, so remove it.
    
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/parport/share.c b/drivers/parport/share.c
index d0b353cf14ac..a8a62bbbb576 100644
--- a/drivers/parport/share.c
+++ b/drivers/parport/share.c
@@ -524,7 +524,7 @@ void parport_remove_port(struct parport *port)
 struct pardevice *
 parport_register_device(struct parport *port, const char *name,
 			int (*pf)(void *), void (*kf)(void *),
-			void (*irq_func)(int, void *), 
+			void (*irq_func)(void *), 
 			int flags, void *handle)
 {
 	struct pardevice *tmp;

commit f230d1010ad0dcd71d9ca8ea6864afac49c5aa9b
Author: Jeff Garzik <jeff@garzik.org>
Date:   Fri Oct 19 01:56:02 2007 -0400

    [PARPORT] Kill useful 'irq' arg from parport_{generic_irq,ieee1284_interrupt}
    
    parport_ieee1284_interrupt() was not using its first arg at all.
    Delete.
    
    parport_generic_irq()'s second arg makes its first arg completely
    redundant.  Delete, and use port->irq in the one place where we actually
    need it.
    
    Also, s/__inline__/inline/ to make the code look nicer.
    
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/parport/share.c b/drivers/parport/share.c
index 414c52a5883a..d0b353cf14ac 100644
--- a/drivers/parport/share.c
+++ b/drivers/parport/share.c
@@ -999,7 +999,7 @@ irqreturn_t parport_irq_handler(int irq, void *dev_id)
 {
 	struct parport *port = dev_id;
 
-	parport_generic_irq(irq, port);
+	parport_generic_irq(port);
 
 	return IRQ_HANDLED;
 }

commit 3f2e40df0e1d7694224c3083b0bebd129039a40a
Author: Jeff Garzik <jeff@garzik.org>
Date:   Fri Oct 19 01:42:14 2007 -0400

    [PARPORT] Consolidate code copies into a single generic irq handler
    
    Several arches used the exact same code for their parport irq handling.
    Make that code generic, in parport_irq_handler().
    
    Also, s/__inline__/inline/ in include/linux/parport.h.
    
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/parport/share.c b/drivers/parport/share.c
index cd66442acfee..414c52a5883a 100644
--- a/drivers/parport/share.c
+++ b/drivers/parport/share.c
@@ -995,6 +995,15 @@ void parport_release(struct pardevice *dev)
 	}
 }
 
+irqreturn_t parport_irq_handler(int irq, void *dev_id)
+{
+	struct parport *port = dev_id;
+
+	parport_generic_irq(irq, port);
+
+	return IRQ_HANDLED;
+}
+
 /* Exported symbols for modules. */
 
 EXPORT_SYMBOL(parport_claim);
@@ -1011,5 +1020,6 @@ EXPORT_SYMBOL(parport_get_port);
 EXPORT_SYMBOL(parport_put_port);
 EXPORT_SYMBOL(parport_find_number);
 EXPORT_SYMBOL(parport_find_base);
+EXPORT_SYMBOL(parport_irq_handler);
 
 MODULE_LICENSE("GPL");

commit c15a3837d2aa30e3ea41aed49d80abed355ab6bd
Author: David Brownell <david-b@pacbell.net>
Date:   Tue May 8 00:27:35 2007 -0700

    parport->dev driver model support
    
    Currently a parport_driver can't get a handle on the device node for the
    underlying parport (PNPACPI, PCI, etc).  That prevents correct placement of
    sysfs child nodes, which can affect things like power management.
    
    This patch adds a field to "struct parport" pointing to that device node, and
    updates non-legacy port drivers to initialize that device pointer.  That field
    replaces the analagous PCI-only support in parport_pc.
    
    [akpm@linux-foundation.org: fix powerpc build]
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/parport/share.c b/drivers/parport/share.c
index fd9129e424f9..cd66442acfee 100644
--- a/drivers/parport/share.c
+++ b/drivers/parport/share.c
@@ -365,6 +365,11 @@ void parport_announce_port (struct parport *port)
 	parport_daisy_init(port);
 #endif
 
+	if (!port->dev)
+		printk(KERN_WARNING "%s: fix this legacy "
+				"no-device port driver!\n",
+				port->name);
+
 	parport_proc_register(port);
 	mutex_lock(&registration_lock);
 	spin_lock_irq(&parportlist_lock);

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/drivers/parport/share.c b/drivers/parport/share.c
index 94dc506b83d1..fd9129e424f9 100644
--- a/drivers/parport/share.c
+++ b/drivers/parport/share.c
@@ -519,7 +519,7 @@ void parport_remove_port(struct parport *port)
 struct pardevice *
 parport_register_device(struct parport *port, const char *name,
 			int (*pf)(void *), void (*kf)(void *),
-			void (*irq_func)(int, void *, struct pt_regs *), 
+			void (*irq_func)(int, void *), 
 			int flags, void *handle)
 {
 	struct pardevice *tmp;

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jrn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jrn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/drivers/parport/share.c b/drivers/parport/share.c
index 2cb22c8d3357..94dc506b83d1 100644
--- a/drivers/parport/share.c
+++ b/drivers/parport/share.c
@@ -17,7 +17,6 @@
 
 #undef PARPORT_DEBUG_SHARING		/* undef for production */
 
-#include <linux/config.h>
 #include <linux/module.h>
 #include <linux/string.h>
 #include <linux/threads.h>

commit 7d469722779c9fe0b415163e8fe837440f9c70dc
Author: Randy Dunlap <rdunlap@xenotime.net>
Date:   Sun Jun 25 05:49:29 2006 -0700

    [PATCH] parport: add to kernel-doc
    
    Add parport interfaces to kernel-doc template.  Small doc.  cleanups in 2
    parport source files.
    
    Signed-off-by: Randy Dunlap <rdunlap@xenotime.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/parport/share.c b/drivers/parport/share.c
index bbbfd79adbaf..2cb22c8d3357 100644
--- a/drivers/parport/share.c
+++ b/drivers/parport/share.c
@@ -218,7 +218,7 @@ static void free_port (struct parport *port)
  *	parport_get_port - increment a port's reference count
  *	@port: the port
  *
- *	This ensure's that a struct parport pointer remains valid
+ *	This ensures that a struct parport pointer remains valid
  *	until the matching parport_put_port() call.
  **/
 

commit 14cc3e2b633bb64063698980974df4535368e98f
Author: Ingo Molnar <mingo@elte.hu>
Date:   Sun Mar 26 01:37:14 2006 -0800

    [PATCH] sem2mutex: misc static one-file mutexes
    
    Semaphore to mutex conversion.
    
    The conversion was generated via scripts, and the result was validated
    automatically via a script as well.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Cc: Dave Jones <davej@codemonkey.org.uk>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Jens Axboe <axboe@suse.de>
    Cc: Neil Brown <neilb@cse.unsw.edu.au>
    Acked-by: Alasdair G Kergon <agk@redhat.com>
    Cc: Greg KH <greg@kroah.com>
    Cc: Dominik Brodowski <linux@dominikbrodowski.net>
    Cc: Adam Belay <ambx1@neo.rr.com>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/parport/share.c b/drivers/parport/share.c
index ea62bed6bc83..bbbfd79adbaf 100644
--- a/drivers/parport/share.c
+++ b/drivers/parport/share.c
@@ -32,6 +32,7 @@
 #include <linux/kmod.h>
 
 #include <linux/spinlock.h>
+#include <linux/mutex.h>
 #include <asm/irq.h>
 
 #undef PARPORT_PARANOID
@@ -50,7 +51,7 @@ static DEFINE_SPINLOCK(full_list_lock);
 
 static LIST_HEAD(drivers);
 
-static DECLARE_MUTEX(registration_lock);
+static DEFINE_MUTEX(registration_lock);
 
 /* What you can do to a port that's gone away.. */
 static void dead_write_lines (struct parport *p, unsigned char b){}
@@ -158,11 +159,11 @@ int parport_register_driver (struct parport_driver *drv)
 	if (list_empty(&portlist))
 		get_lowlevel_driver ();
 
-	down(&registration_lock);
+	mutex_lock(&registration_lock);
 	list_for_each_entry(port, &portlist, list)
 		drv->attach(port);
 	list_add(&drv->list, &drivers);
-	up(&registration_lock);
+	mutex_unlock(&registration_lock);
 
 	return 0;
 }
@@ -188,11 +189,11 @@ void parport_unregister_driver (struct parport_driver *drv)
 {
 	struct parport *port;
 
-	down(&registration_lock);
+	mutex_lock(&registration_lock);
 	list_del_init(&drv->list);
 	list_for_each_entry(port, &portlist, list)
 		drv->detach(port);
-	up(&registration_lock);
+	mutex_unlock(&registration_lock);
 }
 
 static void free_port (struct parport *port)
@@ -366,7 +367,7 @@ void parport_announce_port (struct parport *port)
 #endif
 
 	parport_proc_register(port);
-	down(&registration_lock);
+	mutex_lock(&registration_lock);
 	spin_lock_irq(&parportlist_lock);
 	list_add_tail(&port->list, &portlist);
 	for (i = 1; i < 3; i++) {
@@ -383,7 +384,7 @@ void parport_announce_port (struct parport *port)
 		if (slave)
 			attach_driver_chain(slave);
 	}
-	up(&registration_lock);
+	mutex_unlock(&registration_lock);
 }
 
 /**
@@ -409,7 +410,7 @@ void parport_remove_port(struct parport *port)
 {
 	int i;
 
-	down(&registration_lock);
+	mutex_lock(&registration_lock);
 
 	/* Spread the word. */
 	detach_driver_chain (port);
@@ -436,7 +437,7 @@ void parport_remove_port(struct parport *port)
 	}
 	spin_unlock(&parportlist_lock);
 
-	up(&registration_lock);
+	mutex_unlock(&registration_lock);
 
 	parport_proc_unregister(port);
 

commit 94b82095d0f5d6a72a0c619f54645727ebf66642
Author: Marko Kohtala <marko.kohtala@gmail.com>
Date:   Fri Jan 6 00:19:51 2006 -0800

    [PATCH] parport: export parport_get_port()
    
    Help external ppSCSI driver by exporting parport_get_port to match the
    parport_put_port.
    
    Signed-off-by: Marko Kohtala <marko.kohtala@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/parport/share.c b/drivers/parport/share.c
index 9cb3ab156b09..ea62bed6bc83 100644
--- a/drivers/parport/share.c
+++ b/drivers/parport/share.c
@@ -1002,6 +1002,7 @@ EXPORT_SYMBOL(parport_register_driver);
 EXPORT_SYMBOL(parport_unregister_driver);
 EXPORT_SYMBOL(parport_register_device);
 EXPORT_SYMBOL(parport_unregister_device);
+EXPORT_SYMBOL(parport_get_port);
 EXPORT_SYMBOL(parport_put_port);
 EXPORT_SYMBOL(parport_find_number);
 EXPORT_SYMBOL(parport_find_base);

commit 6044ec8882c726e325017bd948aa0cd94ad33abc
Author: Jesper Juhl <jesper.juhl@gmail.com>
Date:   Mon Nov 7 01:01:32 2005 -0800

    [PATCH] kfree cleanup: misc remaining drivers
    
    This is the remaining misc drivers/ part of the big kfree cleanup patch.
    
    Remove pointless checks for NULL prior to calling kfree() in misc files in
    drivers/.
    
    Signed-off-by: Jesper Juhl <jesper.juhl@gmail.com>
    Acked-by: Aristeu Sergio Rozanski Filho <aris@cathedrallabs.org>
    Acked-by: Roland Dreier <rolandd@cisco.com>
    Acked-by: Pierre Ossman <drzeus@drzeus.cx>
    Acked-by: Jean Delvare <khali@linux-fr.org>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Acked-by: Len Brown <len.brown@intel.com>
    Acked-by: "Antonino A. Daplas" <adaplas@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/parport/share.c b/drivers/parport/share.c
index ae7becf7efa5..9cb3ab156b09 100644
--- a/drivers/parport/share.c
+++ b/drivers/parport/share.c
@@ -202,16 +202,11 @@ static void free_port (struct parport *port)
 	list_del(&port->full_list);
 	spin_unlock(&full_list_lock);
 	for (d = 0; d < 5; d++) {
-		if (port->probe_info[d].class_name)
-			kfree (port->probe_info[d].class_name);
-		if (port->probe_info[d].mfr)
-			kfree (port->probe_info[d].mfr);
-		if (port->probe_info[d].model)
-			kfree (port->probe_info[d].model);
-		if (port->probe_info[d].cmdset)
-			kfree (port->probe_info[d].cmdset);
-		if (port->probe_info[d].description)
-			kfree (port->probe_info[d].description);
+		kfree(port->probe_info[d].class_name);
+		kfree(port->probe_info[d].mfr);
+		kfree(port->probe_info[d].model);
+		kfree(port->probe_info[d].cmdset);
+		kfree(port->probe_info[d].description);
 	}
 
 	kfree(port->name);
@@ -618,9 +613,9 @@ parport_register_device(struct parport *port, const char *name,
 	return tmp;
 
  out_free_all:
-	kfree (tmp->state);
+	kfree(tmp->state);
  out_free_pardevice:
-	kfree (tmp);
+	kfree(tmp);
  out:
 	parport_put_port (port);
 	module_put(port->ops->owner);

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/parport/share.c b/drivers/parport/share.c
new file mode 100644
index 000000000000..ae7becf7efa5
--- /dev/null
+++ b/drivers/parport/share.c
@@ -0,0 +1,1014 @@
+/* $Id: parport_share.c,v 1.15 1998/01/11 12:06:17 philip Exp $
+ * Parallel-port resource manager code.
+ * 
+ * Authors: David Campbell <campbell@tirian.che.curtin.edu.au>
+ *          Tim Waugh <tim@cyberelk.demon.co.uk>
+ *          Jose Renau <renau@acm.org>
+ *          Philip Blundell <philb@gnu.org>
+ *	    Andrea Arcangeli
+ *
+ * based on work by Grant Guenther <grant@torque.net>
+ *          and Philip Blundell
+ *
+ * Any part of this program may be used in documents licensed under
+ * the GNU Free Documentation License, Version 1.1 or any later version
+ * published by the Free Software Foundation.
+ */
+
+#undef PARPORT_DEBUG_SHARING		/* undef for production */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/threads.h>
+#include <linux/parport.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/ioport.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/sched.h>
+#include <linux/kmod.h>
+
+#include <linux/spinlock.h>
+#include <asm/irq.h>
+
+#undef PARPORT_PARANOID
+
+#define PARPORT_DEFAULT_TIMESLICE	(HZ/5)
+
+unsigned long parport_default_timeslice = PARPORT_DEFAULT_TIMESLICE;
+int parport_default_spintime =  DEFAULT_SPIN_TIME;
+
+static LIST_HEAD(portlist);
+static DEFINE_SPINLOCK(parportlist_lock);
+
+/* list of all allocated ports, sorted by ->number */
+static LIST_HEAD(all_ports);
+static DEFINE_SPINLOCK(full_list_lock);
+
+static LIST_HEAD(drivers);
+
+static DECLARE_MUTEX(registration_lock);
+
+/* What you can do to a port that's gone away.. */
+static void dead_write_lines (struct parport *p, unsigned char b){}
+static unsigned char dead_read_lines (struct parport *p) { return 0; }
+static unsigned char dead_frob_lines (struct parport *p, unsigned char b,
+			     unsigned char c) { return 0; }
+static void dead_onearg (struct parport *p){}
+static void dead_initstate (struct pardevice *d, struct parport_state *s) { }
+static void dead_state (struct parport *p, struct parport_state *s) { }
+static size_t dead_write (struct parport *p, const void *b, size_t l, int f)
+{ return 0; }
+static size_t dead_read (struct parport *p, void *b, size_t l, int f)
+{ return 0; }
+static struct parport_operations dead_ops = {
+	.write_data	= dead_write_lines,	/* data */
+	.read_data	= dead_read_lines,
+
+	.write_control	= dead_write_lines,	/* control */
+	.read_control	= dead_read_lines,
+	.frob_control	= dead_frob_lines,
+
+	.read_status	= dead_read_lines,	/* status */
+
+	.enable_irq	= dead_onearg,		/* enable_irq */
+	.disable_irq	= dead_onearg,		/* disable_irq */
+
+	.data_forward	= dead_onearg,		/* data_forward */
+	.data_reverse	= dead_onearg,		/* data_reverse */
+
+	.init_state	= dead_initstate,	/* init_state */
+	.save_state	= dead_state,
+	.restore_state	= dead_state,
+
+	.epp_write_data	= dead_write,		/* epp */
+	.epp_read_data	= dead_read,
+	.epp_write_addr	= dead_write,
+	.epp_read_addr	= dead_read,
+
+	.ecp_write_data	= dead_write,		/* ecp */
+	.ecp_read_data	= dead_read,
+	.ecp_write_addr	= dead_write,
+ 
+	.compat_write_data	= dead_write,	/* compat */
+	.nibble_read_data	= dead_read,	/* nibble */
+	.byte_read_data		= dead_read,	/* byte */
+
+	.owner		= NULL,
+};
+
+/* Call attach(port) for each registered driver. */
+static void attach_driver_chain(struct parport *port)
+{
+	/* caller has exclusive registration_lock */
+	struct parport_driver *drv;
+	list_for_each_entry(drv, &drivers, list)
+		drv->attach(port);
+}
+
+/* Call detach(port) for each registered driver. */
+static void detach_driver_chain(struct parport *port)
+{
+	struct parport_driver *drv;
+	/* caller has exclusive registration_lock */
+	list_for_each_entry(drv, &drivers, list)
+		drv->detach (port);
+}
+
+/* Ask kmod for some lowlevel drivers. */
+static void get_lowlevel_driver (void)
+{
+	/* There is no actual module called this: you should set
+	 * up an alias for modutils. */
+	request_module ("parport_lowlevel");
+}
+
+/**
+ *	parport_register_driver - register a parallel port device driver
+ *	@drv: structure describing the driver
+ *
+ *	This can be called by a parallel port device driver in order
+ *	to receive notifications about ports being found in the
+ *	system, as well as ports no longer available.
+ *
+ *	The @drv structure is allocated by the caller and must not be
+ *	deallocated until after calling parport_unregister_driver().
+ *
+ *	The driver's attach() function may block.  The port that
+ *	attach() is given will be valid for the duration of the
+ *	callback, but if the driver wants to take a copy of the
+ *	pointer it must call parport_get_port() to do so.  Calling
+ *	parport_register_device() on that port will do this for you.
+ *
+ *	The driver's detach() function may block.  The port that
+ *	detach() is given will be valid for the duration of the
+ *	callback, but if the driver wants to take a copy of the
+ *	pointer it must call parport_get_port() to do so.
+ *
+ *	Returns 0 on success.  Currently it always succeeds.
+ **/
+
+int parport_register_driver (struct parport_driver *drv)
+{
+	struct parport *port;
+
+	if (list_empty(&portlist))
+		get_lowlevel_driver ();
+
+	down(&registration_lock);
+	list_for_each_entry(port, &portlist, list)
+		drv->attach(port);
+	list_add(&drv->list, &drivers);
+	up(&registration_lock);
+
+	return 0;
+}
+
+/**
+ *	parport_unregister_driver - deregister a parallel port device driver
+ *	@drv: structure describing the driver that was given to
+ *	      parport_register_driver()
+ *
+ *	This should be called by a parallel port device driver that
+ *	has registered itself using parport_register_driver() when it
+ *	is about to be unloaded.
+ *
+ *	When it returns, the driver's attach() routine will no longer
+ *	be called, and for each port that attach() was called for, the
+ *	detach() routine will have been called.
+ *
+ *	All the driver's attach() and detach() calls are guaranteed to have
+ *	finished by the time this function returns.
+ **/
+
+void parport_unregister_driver (struct parport_driver *drv)
+{
+	struct parport *port;
+
+	down(&registration_lock);
+	list_del_init(&drv->list);
+	list_for_each_entry(port, &portlist, list)
+		drv->detach(port);
+	up(&registration_lock);
+}
+
+static void free_port (struct parport *port)
+{
+	int d;
+	spin_lock(&full_list_lock);
+	list_del(&port->full_list);
+	spin_unlock(&full_list_lock);
+	for (d = 0; d < 5; d++) {
+		if (port->probe_info[d].class_name)
+			kfree (port->probe_info[d].class_name);
+		if (port->probe_info[d].mfr)
+			kfree (port->probe_info[d].mfr);
+		if (port->probe_info[d].model)
+			kfree (port->probe_info[d].model);
+		if (port->probe_info[d].cmdset)
+			kfree (port->probe_info[d].cmdset);
+		if (port->probe_info[d].description)
+			kfree (port->probe_info[d].description);
+	}
+
+	kfree(port->name);
+	kfree(port);
+}
+
+/**
+ *	parport_get_port - increment a port's reference count
+ *	@port: the port
+ *
+ *	This ensure's that a struct parport pointer remains valid
+ *	until the matching parport_put_port() call.
+ **/
+
+struct parport *parport_get_port (struct parport *port)
+{
+	atomic_inc (&port->ref_count);
+	return port;
+}
+
+/**
+ *	parport_put_port - decrement a port's reference count
+ *	@port: the port
+ *
+ *	This should be called once for each call to parport_get_port(),
+ *	once the port is no longer needed.
+ **/
+
+void parport_put_port (struct parport *port)
+{
+	if (atomic_dec_and_test (&port->ref_count))
+		/* Can destroy it now. */
+		free_port (port);
+
+	return;
+}
+
+/**
+ *	parport_register_port - register a parallel port
+ *	@base: base I/O address
+ *	@irq: IRQ line
+ *	@dma: DMA channel
+ *	@ops: pointer to the port driver's port operations structure
+ *
+ *	When a parallel port (lowlevel) driver finds a port that
+ *	should be made available to parallel port device drivers, it
+ *	should call parport_register_port().  The @base, @irq, and
+ *	@dma parameters are for the convenience of port drivers, and
+ *	for ports where they aren't meaningful needn't be set to
+ *	anything special.  They can be altered afterwards by adjusting
+ *	the relevant members of the parport structure that is returned
+ *	and represents the port.  They should not be tampered with
+ *	after calling parport_announce_port, however.
+ *
+ *	If there are parallel port device drivers in the system that
+ *	have registered themselves using parport_register_driver(),
+ *	they are not told about the port at this time; that is done by
+ *	parport_announce_port().
+ *
+ *	The @ops structure is allocated by the caller, and must not be
+ *	deallocated before calling parport_remove_port().
+ *
+ *	If there is no memory to allocate a new parport structure,
+ *	this function will return %NULL.
+ **/
+
+struct parport *parport_register_port(unsigned long base, int irq, int dma,
+				      struct parport_operations *ops)
+{
+	struct list_head *l;
+	struct parport *tmp;
+	int num;
+	int device;
+	char *name;
+
+	tmp = kmalloc(sizeof(struct parport), GFP_KERNEL);
+	if (!tmp) {
+		printk(KERN_WARNING "parport: memory squeeze\n");
+		return NULL;
+	}
+
+	/* Init our structure */
+ 	memset(tmp, 0, sizeof(struct parport));
+	tmp->base = base;
+	tmp->irq = irq;
+	tmp->dma = dma;
+	tmp->muxport = tmp->daisy = tmp->muxsel = -1;
+	tmp->modes = 0;
+ 	INIT_LIST_HEAD(&tmp->list);
+	tmp->devices = tmp->cad = NULL;
+	tmp->flags = 0;
+	tmp->ops = ops;
+	tmp->physport = tmp;
+	memset (tmp->probe_info, 0, 5 * sizeof (struct parport_device_info));
+	rwlock_init(&tmp->cad_lock);
+	spin_lock_init(&tmp->waitlist_lock);
+	spin_lock_init(&tmp->pardevice_lock);
+	tmp->ieee1284.mode = IEEE1284_MODE_COMPAT;
+	tmp->ieee1284.phase = IEEE1284_PH_FWD_IDLE;
+	init_MUTEX_LOCKED (&tmp->ieee1284.irq); /* actually a semaphore at 0 */
+	tmp->spintime = parport_default_spintime;
+	atomic_set (&tmp->ref_count, 1);
+	INIT_LIST_HEAD(&tmp->full_list);
+
+	name = kmalloc(15, GFP_KERNEL);
+	if (!name) {
+		printk(KERN_ERR "parport: memory squeeze\n");
+		kfree(tmp);
+		return NULL;
+	}
+	/* Search for the lowest free parport number. */
+
+	spin_lock(&full_list_lock);
+	for (l = all_ports.next, num = 0; l != &all_ports; l = l->next, num++) {
+		struct parport *p = list_entry(l, struct parport, full_list);
+		if (p->number != num)
+			break;
+	}
+	tmp->portnum = tmp->number = num;
+	list_add_tail(&tmp->full_list, l);
+	spin_unlock(&full_list_lock);
+
+	/*
+	 * Now that the portnum is known finish doing the Init.
+	 */
+	sprintf(name, "parport%d", tmp->portnum = tmp->number);
+	tmp->name = name;
+
+	for (device = 0; device < 5; device++)
+		/* assume the worst */
+		tmp->probe_info[device].class = PARPORT_CLASS_LEGACY;
+
+	tmp->waithead = tmp->waittail = NULL;
+
+	return tmp;
+}
+
+/**
+ *	parport_announce_port - tell device drivers about a parallel port
+ *	@port: parallel port to announce
+ *
+ *	After a port driver has registered a parallel port with
+ *	parport_register_port, and performed any necessary
+ *	initialisation or adjustments, it should call
+ *	parport_announce_port() in order to notify all device drivers
+ *	that have called parport_register_driver().  Their attach()
+ *	functions will be called, with @port as the parameter.
+ **/
+
+void parport_announce_port (struct parport *port)
+{
+	int i;
+
+#ifdef CONFIG_PARPORT_1284
+	/* Analyse the IEEE1284.3 topology of the port. */
+	parport_daisy_init(port);
+#endif
+
+	parport_proc_register(port);
+	down(&registration_lock);
+	spin_lock_irq(&parportlist_lock);
+	list_add_tail(&port->list, &portlist);
+	for (i = 1; i < 3; i++) {
+		struct parport *slave = port->slaves[i-1];
+		if (slave)
+			list_add_tail(&slave->list, &portlist);
+	}
+	spin_unlock_irq(&parportlist_lock);
+
+	/* Let drivers know that new port(s) has arrived. */
+	attach_driver_chain (port);
+	for (i = 1; i < 3; i++) {
+		struct parport *slave = port->slaves[i-1];
+		if (slave)
+			attach_driver_chain(slave);
+	}
+	up(&registration_lock);
+}
+
+/**
+ *	parport_remove_port - deregister a parallel port
+ *	@port: parallel port to deregister
+ *
+ *	When a parallel port driver is forcibly unloaded, or a
+ *	parallel port becomes inaccessible, the port driver must call
+ *	this function in order to deal with device drivers that still
+ *	want to use it.
+ *
+ *	The parport structure associated with the port has its
+ *	operations structure replaced with one containing 'null'
+ *	operations that return errors or just don't do anything.
+ *
+ *	Any drivers that have registered themselves using
+ *	parport_register_driver() are notified that the port is no
+ *	longer accessible by having their detach() routines called
+ *	with @port as the parameter.
+ **/
+
+void parport_remove_port(struct parport *port)
+{
+	int i;
+
+	down(&registration_lock);
+
+	/* Spread the word. */
+	detach_driver_chain (port);
+
+#ifdef CONFIG_PARPORT_1284
+	/* Forget the IEEE1284.3 topology of the port. */
+	parport_daisy_fini(port);
+	for (i = 1; i < 3; i++) {
+		struct parport *slave = port->slaves[i-1];
+		if (!slave)
+			continue;
+		detach_driver_chain(slave);
+		parport_daisy_fini(slave);
+	}
+#endif
+
+	port->ops = &dead_ops;
+	spin_lock(&parportlist_lock);
+	list_del_init(&port->list);
+	for (i = 1; i < 3; i++) {
+		struct parport *slave = port->slaves[i-1];
+		if (slave)
+			list_del_init(&slave->list);
+	}
+	spin_unlock(&parportlist_lock);
+
+	up(&registration_lock);
+
+	parport_proc_unregister(port);
+
+	for (i = 1; i < 3; i++) {
+		struct parport *slave = port->slaves[i-1];
+		if (slave)
+			parport_put_port(slave);
+	}
+}
+
+/**
+ *	parport_register_device - register a device on a parallel port
+ *	@port: port to which the device is attached
+ *	@name: a name to refer to the device
+ *	@pf: preemption callback
+ *	@kf: kick callback (wake-up)
+ *	@irq_func: interrupt handler
+ *	@flags: registration flags
+ *	@handle: data for callback functions
+ *
+ *	This function, called by parallel port device drivers,
+ *	declares that a device is connected to a port, and tells the
+ *	system all it needs to know.
+ *
+ *	The @name is allocated by the caller and must not be
+ *	deallocated until the caller calls @parport_unregister_device
+ *	for that device.
+ *
+ *	The preemption callback function, @pf, is called when this
+ *	device driver has claimed access to the port but another
+ *	device driver wants to use it.  It is given @handle as its
+ *	parameter, and should return zero if it is willing for the
+ *	system to release the port to another driver on its behalf.
+ *	If it wants to keep control of the port it should return
+ *	non-zero, and no action will be taken.  It is good manners for
+ *	the driver to try to release the port at the earliest
+ *	opportunity after its preemption callback rejects a preemption
+ *	attempt.  Note that if a preemption callback is happy for
+ *	preemption to go ahead, there is no need to release the port;
+ *	it is done automatically.  This function may not block, as it
+ *	may be called from interrupt context.  If the device driver
+ *	does not support preemption, @pf can be %NULL.
+ *
+ *	The wake-up ("kick") callback function, @kf, is called when
+ *	the port is available to be claimed for exclusive access; that
+ *	is, parport_claim() is guaranteed to succeed when called from
+ *	inside the wake-up callback function.  If the driver wants to
+ *	claim the port it should do so; otherwise, it need not take
+ *	any action.  This function may not block, as it may be called
+ *	from interrupt context.  If the device driver does not want to
+ *	be explicitly invited to claim the port in this way, @kf can
+ *	be %NULL.
+ *
+ *	The interrupt handler, @irq_func, is called when an interrupt
+ *	arrives from the parallel port.  Note that if a device driver
+ *	wants to use interrupts it should use parport_enable_irq(),
+ *	and can also check the irq member of the parport structure
+ *	representing the port.
+ *
+ *	The parallel port (lowlevel) driver is the one that has called
+ *	request_irq() and whose interrupt handler is called first.
+ *	This handler does whatever needs to be done to the hardware to
+ *	acknowledge the interrupt (for PC-style ports there is nothing
+ *	special to be done).  It then tells the IEEE 1284 code about
+ *	the interrupt, which may involve reacting to an IEEE 1284
+ *	event depending on the current IEEE 1284 phase.  After this,
+ *	it calls @irq_func.  Needless to say, @irq_func will be called
+ *	from interrupt context, and may not block.
+ *
+ *	The %PARPORT_DEV_EXCL flag is for preventing port sharing, and
+ *	so should only be used when sharing the port with other device
+ *	drivers is impossible and would lead to incorrect behaviour.
+ *	Use it sparingly!  Normally, @flags will be zero.
+ *
+ *	This function returns a pointer to a structure that represents
+ *	the device on the port, or %NULL if there is not enough memory
+ *	to allocate space for that structure.
+ **/
+
+struct pardevice *
+parport_register_device(struct parport *port, const char *name,
+			int (*pf)(void *), void (*kf)(void *),
+			void (*irq_func)(int, void *, struct pt_regs *), 
+			int flags, void *handle)
+{
+	struct pardevice *tmp;
+
+	if (port->physport->flags & PARPORT_FLAG_EXCL) {
+		/* An exclusive device is registered. */
+		printk (KERN_DEBUG "%s: no more devices allowed\n",
+			port->name);
+		return NULL;
+	}
+
+	if (flags & PARPORT_DEV_LURK) {
+		if (!pf || !kf) {
+			printk(KERN_INFO "%s: refused to register lurking device (%s) without callbacks\n", port->name, name);
+			return NULL;
+		}
+	}
+
+	/* We up our own module reference count, and that of the port
+           on which a device is to be registered, to ensure that
+           neither of us gets unloaded while we sleep in (e.g.)
+           kmalloc.
+         */
+	if (!try_module_get(port->ops->owner)) {
+		return NULL;
+	}
+		
+	parport_get_port (port);
+
+	tmp = kmalloc(sizeof(struct pardevice), GFP_KERNEL);
+	if (tmp == NULL) {
+		printk(KERN_WARNING "%s: memory squeeze, couldn't register %s.\n", port->name, name);
+		goto out;
+	}
+
+	tmp->state = kmalloc(sizeof(struct parport_state), GFP_KERNEL);
+	if (tmp->state == NULL) {
+		printk(KERN_WARNING "%s: memory squeeze, couldn't register %s.\n", port->name, name);
+		goto out_free_pardevice;
+	}
+
+	tmp->name = name;
+	tmp->port = port;
+	tmp->daisy = -1;
+	tmp->preempt = pf;
+	tmp->wakeup = kf;
+	tmp->private = handle;
+	tmp->flags = flags;
+	tmp->irq_func = irq_func;
+	tmp->waiting = 0;
+	tmp->timeout = 5 * HZ;
+
+	/* Chain this onto the list */
+	tmp->prev = NULL;
+	/*
+	 * This function must not run from an irq handler so we don' t need
+	 * to clear irq on the local CPU. -arca
+	 */
+	spin_lock(&port->physport->pardevice_lock);
+
+	if (flags & PARPORT_DEV_EXCL) {
+		if (port->physport->devices) {
+			spin_unlock (&port->physport->pardevice_lock);
+			printk (KERN_DEBUG
+				"%s: cannot grant exclusive access for "
+				"device %s\n", port->name, name);
+			goto out_free_all;
+		}
+		port->flags |= PARPORT_FLAG_EXCL;
+	}
+
+	tmp->next = port->physport->devices;
+	wmb(); /* Make sure that tmp->next is written before it's
+                  added to the list; see comments marked 'no locking
+                  required' */
+	if (port->physport->devices)
+		port->physport->devices->prev = tmp;
+	port->physport->devices = tmp;
+	spin_unlock(&port->physport->pardevice_lock);
+
+	init_waitqueue_head(&tmp->wait_q);
+	tmp->timeslice = parport_default_timeslice;
+	tmp->waitnext = tmp->waitprev = NULL;
+
+	/*
+	 * This has to be run as last thing since init_state may need other
+	 * pardevice fields. -arca
+	 */
+	port->ops->init_state(tmp, tmp->state);
+	parport_device_proc_register(tmp);
+	return tmp;
+
+ out_free_all:
+	kfree (tmp->state);
+ out_free_pardevice:
+	kfree (tmp);
+ out:
+	parport_put_port (port);
+	module_put(port->ops->owner);
+
+	return NULL;
+}
+
+/**
+ *	parport_unregister_device - deregister a device on a parallel port
+ *	@dev: pointer to structure representing device
+ *
+ *	This undoes the effect of parport_register_device().
+ **/
+
+void parport_unregister_device(struct pardevice *dev)
+{
+	struct parport *port;
+
+#ifdef PARPORT_PARANOID
+	if (dev == NULL) {
+		printk(KERN_ERR "parport_unregister_device: passed NULL\n");
+		return;
+	}
+#endif
+
+	parport_device_proc_unregister(dev);
+
+	port = dev->port->physport;
+
+	if (port->cad == dev) {
+		printk(KERN_DEBUG "%s: %s forgot to release port\n",
+		       port->name, dev->name);
+		parport_release (dev);
+	}
+
+	spin_lock(&port->pardevice_lock);
+	if (dev->next)
+		dev->next->prev = dev->prev;
+	if (dev->prev)
+		dev->prev->next = dev->next;
+	else
+		port->devices = dev->next;
+
+	if (dev->flags & PARPORT_DEV_EXCL)
+		port->flags &= ~PARPORT_FLAG_EXCL;
+
+	spin_unlock(&port->pardevice_lock);
+
+	/* Make sure we haven't left any pointers around in the wait
+	 * list. */
+	spin_lock (&port->waitlist_lock);
+	if (dev->waitprev || dev->waitnext || port->waithead == dev) {
+		if (dev->waitprev)
+			dev->waitprev->waitnext = dev->waitnext;
+		else
+			port->waithead = dev->waitnext;
+		if (dev->waitnext)
+			dev->waitnext->waitprev = dev->waitprev;
+		else
+			port->waittail = dev->waitprev;
+	}
+	spin_unlock (&port->waitlist_lock);
+
+	kfree(dev->state);
+	kfree(dev);
+
+	module_put(port->ops->owner);
+	parport_put_port (port);
+}
+
+/**
+ *	parport_find_number - find a parallel port by number
+ *	@number: parallel port number
+ *
+ *	This returns the parallel port with the specified number, or
+ *	%NULL if there is none.
+ *
+ *	There is an implicit parport_get_port() done already; to throw
+ *	away the reference to the port that parport_find_number()
+ *	gives you, use parport_put_port().
+ */
+
+struct parport *parport_find_number (int number)
+{
+	struct parport *port, *result = NULL;
+
+	if (list_empty(&portlist))
+		get_lowlevel_driver ();
+
+	spin_lock (&parportlist_lock);
+	list_for_each_entry(port, &portlist, list) {
+		if (port->number == number) {
+			result = parport_get_port (port);
+			break;
+		}
+	}
+	spin_unlock (&parportlist_lock);
+	return result;
+}
+
+/**
+ *	parport_find_base - find a parallel port by base address
+ *	@base: base I/O address
+ *
+ *	This returns the parallel port with the specified base
+ *	address, or %NULL if there is none.
+ *
+ *	There is an implicit parport_get_port() done already; to throw
+ *	away the reference to the port that parport_find_base()
+ *	gives you, use parport_put_port().
+ */
+
+struct parport *parport_find_base (unsigned long base)
+{
+	struct parport *port, *result = NULL;
+
+	if (list_empty(&portlist))
+		get_lowlevel_driver ();
+
+	spin_lock (&parportlist_lock);
+	list_for_each_entry(port, &portlist, list) {
+		if (port->base == base) {
+			result = parport_get_port (port);
+			break;
+		}
+	}
+	spin_unlock (&parportlist_lock);
+	return result;
+}
+
+/**
+ *	parport_claim - claim access to a parallel port device
+ *	@dev: pointer to structure representing a device on the port
+ *
+ *	This function will not block and so can be used from interrupt
+ *	context.  If parport_claim() succeeds in claiming access to
+ *	the port it returns zero and the port is available to use.  It
+ *	may fail (returning non-zero) if the port is in use by another
+ *	driver and that driver is not willing to relinquish control of
+ *	the port.
+ **/
+
+int parport_claim(struct pardevice *dev)
+{
+	struct pardevice *oldcad;
+	struct parport *port = dev->port->physport;
+	unsigned long flags;
+
+	if (port->cad == dev) {
+		printk(KERN_INFO "%s: %s already owner\n",
+		       dev->port->name,dev->name);
+		return 0;
+	}
+
+	/* Preempt any current device */
+	write_lock_irqsave (&port->cad_lock, flags);
+	if ((oldcad = port->cad) != NULL) {
+		if (oldcad->preempt) {
+			if (oldcad->preempt(oldcad->private))
+				goto blocked;
+			port->ops->save_state(port, dev->state);
+		} else
+			goto blocked;
+
+		if (port->cad != oldcad) {
+			/* I think we'll actually deadlock rather than
+                           get here, but just in case.. */
+			printk(KERN_WARNING
+			       "%s: %s released port when preempted!\n",
+			       port->name, oldcad->name);
+			if (port->cad)
+				goto blocked;
+		}
+	}
+
+	/* Can't fail from now on, so mark ourselves as no longer waiting.  */
+	if (dev->waiting & 1) {
+		dev->waiting = 0;
+
+		/* Take ourselves out of the wait list again.  */
+		spin_lock_irq (&port->waitlist_lock);
+		if (dev->waitprev)
+			dev->waitprev->waitnext = dev->waitnext;
+		else
+			port->waithead = dev->waitnext;
+		if (dev->waitnext)
+			dev->waitnext->waitprev = dev->waitprev;
+		else
+			port->waittail = dev->waitprev;
+		spin_unlock_irq (&port->waitlist_lock);
+		dev->waitprev = dev->waitnext = NULL;
+	}
+
+	/* Now we do the change of devices */
+	port->cad = dev;
+
+#ifdef CONFIG_PARPORT_1284
+	/* If it's a mux port, select it. */
+	if (dev->port->muxport >= 0) {
+		/* FIXME */
+		port->muxsel = dev->port->muxport;
+	}
+
+	/* If it's a daisy chain device, select it. */
+	if (dev->daisy >= 0) {
+		/* This could be lazier. */
+		if (!parport_daisy_select (port, dev->daisy,
+					   IEEE1284_MODE_COMPAT))
+			port->daisy = dev->daisy;
+	}
+#endif /* IEEE1284.3 support */
+
+	/* Restore control registers */
+	port->ops->restore_state(port, dev->state);
+	write_unlock_irqrestore(&port->cad_lock, flags);
+	dev->time = jiffies;
+	return 0;
+
+blocked:
+	/* If this is the first time we tried to claim the port, register an
+	   interest.  This is only allowed for devices sleeping in
+	   parport_claim_or_block(), or those with a wakeup function.  */
+
+	/* The cad_lock is still held for writing here */
+	if (dev->waiting & 2 || dev->wakeup) {
+		spin_lock (&port->waitlist_lock);
+		if (test_and_set_bit(0, &dev->waiting) == 0) {
+			/* First add ourselves to the end of the wait list. */
+			dev->waitnext = NULL;
+			dev->waitprev = port->waittail;
+			if (port->waittail) {
+				port->waittail->waitnext = dev;
+				port->waittail = dev;
+			} else
+				port->waithead = port->waittail = dev;
+		}
+		spin_unlock (&port->waitlist_lock);
+	}
+	write_unlock_irqrestore (&port->cad_lock, flags);
+	return -EAGAIN;
+}
+
+/**
+ *	parport_claim_or_block - claim access to a parallel port device
+ *	@dev: pointer to structure representing a device on the port
+ *
+ *	This behaves like parport_claim(), but will block if necessary
+ *	to wait for the port to be free.  A return value of 1
+ *	indicates that it slept; 0 means that it succeeded without
+ *	needing to sleep.  A negative error code indicates failure.
+ **/
+
+int parport_claim_or_block(struct pardevice *dev)
+{
+	int r;
+
+	/* Signal to parport_claim() that we can wait even without a
+	   wakeup function.  */
+	dev->waiting = 2;
+
+	/* Try to claim the port.  If this fails, we need to sleep.  */
+	r = parport_claim(dev);
+	if (r == -EAGAIN) {
+#ifdef PARPORT_DEBUG_SHARING
+		printk(KERN_DEBUG "%s: parport_claim() returned -EAGAIN\n", dev->name);
+#endif
+		/*
+		 * FIXME!!! Use the proper locking for dev->waiting,
+		 * and make this use the "wait_event_interruptible()"
+		 * interfaces. The cli/sti that used to be here
+		 * did nothing.
+		 *
+		 * See also parport_release()
+		 */
+
+		/* If dev->waiting is clear now, an interrupt
+		   gave us the port and we would deadlock if we slept.  */
+		if (dev->waiting) {
+			interruptible_sleep_on (&dev->wait_q);
+			if (signal_pending (current)) {
+				return -EINTR;
+			}
+			r = 1;
+		} else {
+			r = 0;
+#ifdef PARPORT_DEBUG_SHARING
+			printk(KERN_DEBUG "%s: didn't sleep in parport_claim_or_block()\n",
+			       dev->name);
+#endif
+		}
+
+#ifdef PARPORT_DEBUG_SHARING
+		if (dev->port->physport->cad != dev)
+			printk(KERN_DEBUG "%s: exiting parport_claim_or_block "
+			       "but %s owns port!\n", dev->name,
+			       dev->port->physport->cad ?
+			       dev->port->physport->cad->name:"nobody");
+#endif
+	}
+	dev->waiting = 0;
+	return r;
+}
+
+/**
+ *	parport_release - give up access to a parallel port device
+ *	@dev: pointer to structure representing parallel port device
+ *
+ *	This function cannot fail, but it should not be called without
+ *	the port claimed.  Similarly, if the port is already claimed
+ *	you should not try claiming it again.
+ **/
+
+void parport_release(struct pardevice *dev)
+{
+	struct parport *port = dev->port->physport;
+	struct pardevice *pd;
+	unsigned long flags;
+
+	/* Make sure that dev is the current device */
+	write_lock_irqsave(&port->cad_lock, flags);
+	if (port->cad != dev) {
+		write_unlock_irqrestore (&port->cad_lock, flags);
+		printk(KERN_WARNING "%s: %s tried to release parport "
+		       "when not owner\n", port->name, dev->name);
+		return;
+	}
+
+#ifdef CONFIG_PARPORT_1284
+	/* If this is on a mux port, deselect it. */
+	if (dev->port->muxport >= 0) {
+		/* FIXME */
+		port->muxsel = -1;
+	}
+
+	/* If this is a daisy device, deselect it. */
+	if (dev->daisy >= 0) {
+		parport_daisy_deselect_all (port);
+		port->daisy = -1;
+	}
+#endif
+
+	port->cad = NULL;
+	write_unlock_irqrestore(&port->cad_lock, flags);
+
+	/* Save control registers */
+	port->ops->save_state(port, dev->state);
+
+	/* If anybody is waiting, find out who's been there longest and
+	   then wake them up. (Note: no locking required) */
+	/* !!! LOCKING IS NEEDED HERE */
+	for (pd = port->waithead; pd; pd = pd->waitnext) {
+		if (pd->waiting & 2) { /* sleeping in claim_or_block */
+			parport_claim(pd);
+			if (waitqueue_active(&pd->wait_q))
+				wake_up_interruptible(&pd->wait_q);
+			return;
+		} else if (pd->wakeup) {
+			pd->wakeup(pd->private);
+			if (dev->port->cad) /* racy but no matter */
+				return;
+		} else {
+			printk(KERN_ERR "%s: don't know how to wake %s\n", port->name, pd->name);
+		}
+	}
+
+	/* Nobody was waiting, so walk the list to see if anyone is
+	   interested in being woken up. (Note: no locking required) */
+	/* !!! LOCKING IS NEEDED HERE */
+	for (pd = port->devices; (port->cad == NULL) && pd; pd = pd->next) {
+		if (pd->wakeup && pd != dev)
+			pd->wakeup(pd->private);
+	}
+}
+
+/* Exported symbols for modules. */
+
+EXPORT_SYMBOL(parport_claim);
+EXPORT_SYMBOL(parport_claim_or_block);
+EXPORT_SYMBOL(parport_release);
+EXPORT_SYMBOL(parport_register_port);
+EXPORT_SYMBOL(parport_announce_port);
+EXPORT_SYMBOL(parport_remove_port);
+EXPORT_SYMBOL(parport_register_driver);
+EXPORT_SYMBOL(parport_unregister_driver);
+EXPORT_SYMBOL(parport_register_device);
+EXPORT_SYMBOL(parport_unregister_device);
+EXPORT_SYMBOL(parport_put_port);
+EXPORT_SYMBOL(parport_find_number);
+EXPORT_SYMBOL(parport_find_base);
+
+MODULE_LICENSE("GPL");
