commit 88c5cbdef8d2ec6f94701c0bacb9f90c8a7a8cd5
Author: Joe Perches <joe@perches.com>
Date:   Fri Apr 3 14:43:18 2020 +0100

    parport: daisy: Convert DPRINTK to pr_debug
    
    Use a more common logging style.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Reviewed-by: Randy Dunlap <rdunlap@infradead.org>
    Signed-off-by: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
    Link: https://lore.kernel.org/r/20200403134325.11523-4-sudipm.mukherjee@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/parport/daisy.c b/drivers/parport/daisy.c
index f87cc802167e..6d78ec3a762f 100644
--- a/drivers/parport/daisy.c
+++ b/drivers/parport/daisy.c
@@ -30,12 +30,6 @@
 
 #undef DEBUG
 
-#ifdef DEBUG
-#define DPRINTK(stuff...) printk(stuff)
-#else
-#define DPRINTK(stuff...)
-#endif
-
 static struct daisydev {
 	struct daisydev *next;
 	struct parport *port;
@@ -321,8 +315,7 @@ static int cpp_daisy(struct parport *port, int cmd)
 		  | PARPORT_STATUS_PAPEROUT
 		  | PARPORT_STATUS_SELECT
 		  | PARPORT_STATUS_ERROR)) {
-		DPRINTK(KERN_DEBUG "%s: cpp_daisy: aa5500ff(%02x)\n",
-			 port->name, s);
+		pr_debug("%s: cpp_daisy: aa5500ff(%02x)\n", port->name, s);
 		return -ENXIO;
 	}
 
@@ -332,8 +325,7 @@ static int cpp_daisy(struct parport *port, int cmd)
 					  | PARPORT_STATUS_SELECT
 					  | PARPORT_STATUS_ERROR);
 	if (s != (PARPORT_STATUS_SELECT | PARPORT_STATUS_ERROR)) {
-		DPRINTK(KERN_DEBUG "%s: cpp_daisy: aa5500ff87(%02x)\n",
-			 port->name, s);
+		pr_debug("%s: cpp_daisy: aa5500ff87(%02x)\n", port->name, s);
 		return -ENXIO;
 	}
 
@@ -368,7 +360,7 @@ static int cpp_mux(struct parport *port, int cmd)
 
 	s = parport_read_status(port);
 	if (!(s & PARPORT_STATUS_ACK)) {
-		DPRINTK(KERN_DEBUG "%s: cpp_mux: aa55f00f52ad%02x(%02x)\n",
+		pr_debug("%s: cpp_mux: aa55f00f52ad%02x(%02x)\n",
 			 port->name, cmd, s);
 		return -EIO;
 	}
@@ -454,8 +446,7 @@ static int assign_addrs(struct parport *port)
 		  | PARPORT_STATUS_PAPEROUT
 		  | PARPORT_STATUS_SELECT
 		  | PARPORT_STATUS_ERROR)) {
-		DPRINTK(KERN_DEBUG "%s: assign_addrs: aa5500ff(%02x)\n",
-			 port->name, s);
+		pr_debug("%s: assign_addrs: aa5500ff(%02x)\n", port->name, s);
 		return 0;
 	}
 
@@ -465,8 +456,7 @@ static int assign_addrs(struct parport *port)
 					  | PARPORT_STATUS_SELECT
 					  | PARPORT_STATUS_ERROR);
 	if (s != (PARPORT_STATUS_SELECT | PARPORT_STATUS_ERROR)) {
-		DPRINTK(KERN_DEBUG "%s: assign_addrs: aa5500ff87(%02x)\n",
-			 port->name, s);
+		pr_debug("%s: assign_addrs: aa5500ff87(%02x)\n", port->name, s);
 		return 0;
 	}
 
@@ -503,8 +493,7 @@ static int assign_addrs(struct parport *port)
 
 	parport_write_data(port, 0xff); udelay(2);
 	detected = numdevs - thisdev;
-	DPRINTK(KERN_DEBUG "%s: Found %d daisy-chained devices\n", port->name,
-		 detected);
+	pr_debug("%s: Found %d daisy-chained devices\n", port->name, detected);
 
 	/* Ask the new devices to introduce themselves. */
 	deviceid = kmalloc(1024, GFP_KERNEL);

commit decf26f6ec25dac868782dc1751623a87d147831
Author: Joe Perches <joe@perches.com>
Date:   Fri Apr 3 14:43:16 2020 +0100

    parport: Convert printk(KERN_<LEVEL> to pr_<level>(
    
    Use the more common kernel style.
    
    Miscellanea:
    
    o Coalesce formats
    o Realign arguments
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Reviewed-by: Randy Dunlap <rdunlap@infradead.org>
    Signed-off-by: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
    Link: https://lore.kernel.org/r/20200403134325.11523-2-sudipm.mukherjee@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/parport/daisy.c b/drivers/parport/daisy.c
index 3b00e2c8e2e9..f87cc802167e 100644
--- a/drivers/parport/daisy.c
+++ b/drivers/parport/daisy.c
@@ -145,8 +145,7 @@ int parport_daisy_init(struct parport *port)
 	    ((num_ports = num_mux_ports(port)) == 2 || num_ports == 4)) {
 		/* Leave original as port zero. */
 		port->muxport = 0;
-		printk(KERN_INFO
-			"%s: 1st (default) port of %d-way multiplexor\n",
+		pr_info("%s: 1st (default) port of %d-way multiplexor\n",
 			port->name, num_ports);
 		for (i = 1; i < num_ports; i++) {
 			/* Clone the port. */
@@ -159,8 +158,7 @@ int parport_daisy_init(struct parport *port)
 				continue;
 			}
 
-			printk(KERN_INFO
-				"%s: %d%s port of %d-way multiplexor on %s\n",
+			pr_info("%s: %d%s port of %d-way multiplexor on %s\n",
 				extra->name, i + 1, th[i + 1], num_ports,
 				port->name);
 

commit 60f8a59ddcdc7fb7c17180ba10d9c49bc91156c7
Author: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
Date:   Wed Oct 16 15:45:40 2019 +0100

    parport: daisy: use new parport device model
    
    Modify parport daisy driver to use the new parallel port device model.
    
    Last attempt was '1aec4211204d ("parport: daisy: use new parport device
    model")' which failed as daisy was also trying to load the low level
    driver and that resulted in a deadlock.
    
    Cc: Michal Kubecek <mkubecek@suse.cz>
    Signed-off-by: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
    Tested-by: Steven Rostedt (VMware) <rostedt@goodmis.org>
    Link: https://lore.kernel.org/r/20191016144540.18810-4-sudipm.mukherjee@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/parport/daisy.c b/drivers/parport/daisy.c
index 5484a46dafda..3b00e2c8e2e9 100644
--- a/drivers/parport/daisy.c
+++ b/drivers/parport/daisy.c
@@ -45,6 +45,7 @@ static struct daisydev {
 static DEFINE_SPINLOCK(topology_lock);
 
 static int numdevs;
+static bool daisy_init_done;
 
 /* Forward-declaration of lower-level functions. */
 static int mux_present(struct parport *port);
@@ -87,6 +88,24 @@ static struct parport *clone_parport(struct parport *real, int muxport)
 	return extra;
 }
 
+static int daisy_drv_probe(struct pardevice *par_dev)
+{
+	struct device_driver *drv = par_dev->dev.driver;
+
+	if (strcmp(drv->name, "daisy_drv"))
+		return -ENODEV;
+	if (strcmp(par_dev->name, daisy_dev_name))
+		return -ENODEV;
+
+	return 0;
+}
+
+static struct parport_driver daisy_driver = {
+	.name = "daisy_drv",
+	.probe = daisy_drv_probe,
+	.devmodel = true,
+};
+
 /* Discover the IEEE1284.3 topology on a port -- muxes and daisy chains.
  * Return value is number of devices actually detected. */
 int parport_daisy_init(struct parport *port)
@@ -98,6 +117,23 @@ int parport_daisy_init(struct parport *port)
 	int i;
 	int last_try = 0;
 
+	if (!daisy_init_done) {
+		/*
+		 * flag should be marked true first as
+		 * parport_register_driver() might try to load the low
+		 * level driver which will lead to announcing new ports
+		 * and which will again come back here at
+		 * parport_daisy_init()
+		 */
+		daisy_init_done = true;
+		i = parport_register_driver(&daisy_driver);
+		if (i) {
+			pr_err("daisy registration failed\n");
+			daisy_init_done = false;
+			return i;
+		}
+	}
+
 again:
 	/* Because this is called before any other devices exist,
 	 * we don't have to claim exclusive access.  */
@@ -213,10 +249,12 @@ void parport_daisy_fini(struct parport *port)
 struct pardevice *parport_open(int devnum, const char *name)
 {
 	struct daisydev *p = topology;
+	struct pardev_cb par_cb;
 	struct parport *port;
 	struct pardevice *dev;
 	int daisy;
 
+	memset(&par_cb, 0, sizeof(par_cb));
 	spin_lock(&topology_lock);
 	while (p && p->devnum != devnum)
 		p = p->next;
@@ -230,7 +268,7 @@ struct pardevice *parport_open(int devnum, const char *name)
 	port = parport_get_port(p->port);
 	spin_unlock(&topology_lock);
 
-	dev = parport_register_device(port, name, NULL, NULL, NULL, 0, NULL);
+	dev = parport_register_dev_model(port, name, &par_cb, devnum);
 	parport_put_port(port);
 	if (!dev)
 		return NULL;

commit a3ac7917b73070010c05b4485b8582a6c9cd69b6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Mar 25 14:49:00 2019 -0700

    Revert "parport: daisy: use new parport device model"
    
    This reverts commit 1aec4211204d9463d1fd209eb50453de16254599.
    
    Steven Rostedt reports that it causes a hang at bootup and bisected it
    to this commit.
    
    The troigger is apparently a module alias for "parport_lowlevel" that
    points to "parport_pc", which causes a hang with
    
        modprobe -q -- parport_lowlevel
    
    blocking forever with a backtrace like this:
    
        wait_for_completion_killable+0x1c/0x28
        call_usermodehelper_exec+0xa7/0x108
        __request_module+0x351/0x3d8
        get_lowlevel_driver+0x28/0x41 [parport]
        __parport_register_driver+0x39/0x1f4 [parport]
        daisy_drv_init+0x31/0x4f [parport]
        parport_bus_init+0x5d/0x7b [parport]
        parport_default_proc_register+0x26/0x1000 [parport]
        do_one_initcall+0xc2/0x1e0
        do_init_module+0x50/0x1d4
        load_module+0x1c2e/0x21b3
        sys_init_module+0xef/0x117
    
    Supid says:
     "Due to the new device model daisy driver will now try to find the
      parallel ports while trying to register its driver so that it can bind
      with them. Now, since daisy driver is loaded while parport bus is
      initialising the list of parport is still empty and it tries to load
      the lowlevel driver, which has an alias set to parport_pc, now causes
      a deadlock"
    
    But I don't think the daisy driver should be loaded by the parport
    initialization in the first place, so let's revert the whole change.
    
    If the daisy driver can just initialize separately on its own (like a
    driver should), instead of hooking into the parport init sequence
    directly, this issue probably would go away.
    
    Reported-and-bisected-by: Steven Rostedt (VMware) <rostedt@goodmis.org>
    Reported-by: Michal Kubecek <mkubecek@suse.cz>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/parport/daisy.c b/drivers/parport/daisy.c
index 56dd83a45e55..5484a46dafda 100644
--- a/drivers/parport/daisy.c
+++ b/drivers/parport/daisy.c
@@ -213,12 +213,10 @@ void parport_daisy_fini(struct parport *port)
 struct pardevice *parport_open(int devnum, const char *name)
 {
 	struct daisydev *p = topology;
-	struct pardev_cb par_cb;
 	struct parport *port;
 	struct pardevice *dev;
 	int daisy;
 
-	memset(&par_cb, 0, sizeof(par_cb));
 	spin_lock(&topology_lock);
 	while (p && p->devnum != devnum)
 		p = p->next;
@@ -232,7 +230,7 @@ struct pardevice *parport_open(int devnum, const char *name)
 	port = parport_get_port(p->port);
 	spin_unlock(&topology_lock);
 
-	dev = parport_register_dev_model(port, name, &par_cb, devnum);
+	dev = parport_register_device(port, name, NULL, NULL, NULL, 0, NULL);
 	parport_put_port(port);
 	if (!dev)
 		return NULL;
@@ -482,31 +480,3 @@ static int assign_addrs(struct parport *port)
 	kfree(deviceid);
 	return detected;
 }
-
-static int daisy_drv_probe(struct pardevice *par_dev)
-{
-	struct device_driver *drv = par_dev->dev.driver;
-
-	if (strcmp(drv->name, "daisy_drv"))
-		return -ENODEV;
-	if (strcmp(par_dev->name, daisy_dev_name))
-		return -ENODEV;
-
-	return 0;
-}
-
-static struct parport_driver daisy_driver = {
-	.name = "daisy_drv",
-	.probe = daisy_drv_probe,
-	.devmodel = true,
-};
-
-int daisy_drv_init(void)
-{
-	return parport_register_driver(&daisy_driver);
-}
-
-void daisy_drv_exit(void)
-{
-	parport_unregister_driver(&daisy_driver);
-}

commit 1aec4211204d9463d1fd209eb50453de16254599
Author: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
Date:   Wed Feb 13 08:47:06 2019 +0000

    parport: daisy: use new parport device model
    
    Modify parport daisy driver to use the new parallel port device model.
    
    Signed-off-by: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/parport/daisy.c b/drivers/parport/daisy.c
index 5484a46dafda..56dd83a45e55 100644
--- a/drivers/parport/daisy.c
+++ b/drivers/parport/daisy.c
@@ -213,10 +213,12 @@ void parport_daisy_fini(struct parport *port)
 struct pardevice *parport_open(int devnum, const char *name)
 {
 	struct daisydev *p = topology;
+	struct pardev_cb par_cb;
 	struct parport *port;
 	struct pardevice *dev;
 	int daisy;
 
+	memset(&par_cb, 0, sizeof(par_cb));
 	spin_lock(&topology_lock);
 	while (p && p->devnum != devnum)
 		p = p->next;
@@ -230,7 +232,7 @@ struct pardevice *parport_open(int devnum, const char *name)
 	port = parport_get_port(p->port);
 	spin_unlock(&topology_lock);
 
-	dev = parport_register_device(port, name, NULL, NULL, NULL, 0, NULL);
+	dev = parport_register_dev_model(port, name, &par_cb, devnum);
 	parport_put_port(port);
 	if (!dev)
 		return NULL;
@@ -480,3 +482,31 @@ static int assign_addrs(struct parport *port)
 	kfree(deviceid);
 	return detected;
 }
+
+static int daisy_drv_probe(struct pardevice *par_dev)
+{
+	struct device_driver *drv = par_dev->dev.driver;
+
+	if (strcmp(drv->name, "daisy_drv"))
+		return -ENODEV;
+	if (strcmp(par_dev->name, daisy_dev_name))
+		return -ENODEV;
+
+	return 0;
+}
+
+static struct parport_driver daisy_driver = {
+	.name = "daisy_drv",
+	.probe = daisy_drv_probe,
+	.devmodel = true,
+};
+
+int daisy_drv_init(void)
+{
+	return parport_register_driver(&daisy_driver);
+}
+
+void daisy_drv_exit(void)
+{
+	parport_unregister_driver(&daisy_driver);
+}

commit df4c756e5f6bf08bd7bc63bbfd7fa921a855f241
Author: Carlos Palminha <CARLOS.PALMINHA@synopsys.com>
Date:   Sat Aug 12 22:45:49 2017 +0100

    parport: cleanup statics initialization to NULL or 0
    
    based on checkpatch, cleanup the "do not initialise statics to" 0 or NULL.
    
    Signed-off-by: Carlos Palminha <palminha@synopsys.com>
    Signed-off-by: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/parport/daisy.c b/drivers/parport/daisy.c
index 46eb15fb57ff..5484a46dafda 100644
--- a/drivers/parport/daisy.c
+++ b/drivers/parport/daisy.c
@@ -44,7 +44,7 @@ static struct daisydev {
 } *topology = NULL;
 static DEFINE_SPINLOCK(topology_lock);
 
-static int numdevs = 0;
+static int numdevs;
 
 /* Forward-declaration of lower-level functions. */
 static int mux_present(struct parport *port);

commit 174cd4b1e5fbd0d74c68cf3a74f5bd4923485512
Author: Ingo Molnar <mingo@kernel.org>
Date:   Thu Feb 2 19:15:33 2017 +0100

    sched/headers: Prepare to move signal wakeup & sigpending methods from <linux/sched.h> into <linux/sched/signal.h>
    
    Fix up affected files that include this signal functionality via sched.h.
    
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/parport/daisy.c b/drivers/parport/daisy.c
index d998d0ed2bec..46eb15fb57ff 100644
--- a/drivers/parport/daisy.c
+++ b/drivers/parport/daisy.c
@@ -23,7 +23,7 @@
 #include <linux/parport.h>
 #include <linux/delay.h>
 #include <linux/slab.h>
-#include <linux/sched.h>
+#include <linux/sched/signal.h>
 
 #include <asm/current.h>
 #include <linux/uaccess.h>

commit 7c0f6ba682b9c7632072ffbedf8d328c8f3c42ba
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Dec 24 11:46:01 2016 -0800

    Replace <asm/uaccess.h> with <linux/uaccess.h> globally
    
    This was entirely automated, using the script by Al:
    
      PATT='^[[:blank:]]*#[[:blank:]]*include[[:blank:]]*<asm/uaccess.h>'
      sed -i -e "s!$PATT!#include <linux/uaccess.h>!" \
            $(git grep -l "$PATT"|grep -v ^include/linux/uaccess.h)
    
    to do the replacement at the end of the merge window.
    
    Requested-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/parport/daisy.c b/drivers/parport/daisy.c
index 5bed17f68ef4..d998d0ed2bec 100644
--- a/drivers/parport/daisy.c
+++ b/drivers/parport/daisy.c
@@ -26,7 +26,7 @@
 #include <linux/sched.h>
 
 #include <asm/current.h>
-#include <asm/uaccess.h>
+#include <linux/uaccess.h>
 
 #undef DEBUG
 

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/parport/daisy.c b/drivers/parport/daisy.c
index 3c8f06c3a5a0..5bed17f68ef4 100644
--- a/drivers/parport/daisy.c
+++ b/drivers/parport/daisy.c
@@ -22,6 +22,7 @@
 #include <linux/module.h>
 #include <linux/parport.h>
 #include <linux/delay.h>
+#include <linux/slab.h>
 #include <linux/sched.h>
 
 #include <asm/current.h>

commit 5712cb3d81566893c3b14e24075cf48ec5c35d00
Author: Jeff Garzik <jeff@garzik.org>
Date:   Fri Oct 19 02:54:26 2007 -0400

    [PARPORT] Remove unused 'irq' argument from parport irq functions
    
    None of the drivers with a struct pardevice's ->irq_func() hook ever
    used the 'irq' argument passed to it, so remove it.
    
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/parport/daisy.c b/drivers/parport/daisy.c
index 5bbff2028f8f..3c8f06c3a5a0 100644
--- a/drivers/parport/daisy.c
+++ b/drivers/parport/daisy.c
@@ -199,11 +199,6 @@ void parport_daisy_fini(struct parport *port)
  *	parport_open - find a device by canonical device number
  *	@devnum: canonical device number
  *	@name: name to associate with the device
- *	@pf: preemption callback
- *	@kf: kick callback
- *	@irqf: interrupt handler
- *	@flags: registration flags
- *	@handle: driver data
  *
  *	This function is similar to parport_register_device(), except
  *	that it locates a device by its number rather than by the port
@@ -214,10 +209,7 @@ void parport_daisy_fini(struct parport *port)
  *	for parport_register_device().
  **/
 
-struct pardevice *parport_open(int devnum, const char *name,
-				int (*pf) (void *), void (*kf) (void *),
-				void (*irqf) (int, void *),
-				int flags, void *handle)
+struct pardevice *parport_open(int devnum, const char *name)
 {
 	struct daisydev *p = topology;
 	struct parport *port;
@@ -237,8 +229,7 @@ struct pardevice *parport_open(int devnum, const char *name,
 	port = parport_get_port(p->port);
 	spin_unlock(&topology_lock);
 
-	dev = parport_register_device(port, name, pf, kf,
-				       irqf, flags, handle);
+	dev = parport_register_device(port, name, NULL, NULL, NULL, 0, NULL);
 	parport_put_port(port);
 	if (!dev)
 		return NULL;

commit 25398a158d86b993fa5bf36f5a6752134b584d60
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Thu Oct 18 03:05:30 2007 -0700

    sysctl: parport remove binary paths
    
    The sysctl binary paths don't look as if they even code work, .data is not
    filled in, and all of the proc_handlers look at extra1 and there is not
    strategy routine.
    
    So just kill the binary paths.
    
    In addition this patch removes the setting of extra1 on directories.  It
    doesn't look like the parport code ever examines it, and it's bad sysctl form.
    
    [bunk@kernel.org: remove parport_device_num()]
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/parport/daisy.c b/drivers/parport/daisy.c
index ff9f34453530..5bbff2028f8f 100644
--- a/drivers/parport/daisy.c
+++ b/drivers/parport/daisy.c
@@ -275,35 +275,6 @@ void parport_close(struct pardevice *dev)
 	parport_unregister_device(dev);
 }
 
-/**
- *	parport_device_num - convert device coordinates
- *	@parport: parallel port number
- *	@mux: multiplexor port number (-1 for no multiplexor)
- *	@daisy: daisy chain address (-1 for no daisy chain address)
- *
- *	This tries to locate a device on the given parallel port,
- *	multiplexor port and daisy chain address, and returns its
- *	device number or %-ENXIO if no device with those coordinates
- *	exists.
- **/
-
-int parport_device_num(int parport, int mux, int daisy)
-{
-	int res = -ENXIO;
-	struct daisydev *dev;
-
-	spin_lock(&topology_lock);
-	dev = topology;
-	while (dev && dev->port->portnum != parport &&
-	       dev->port->muxport != mux && dev->daisy != daisy)
-		dev = dev->next;
-	if (dev)
-		res = dev->devnum;
-	spin_unlock(&topology_lock);
-
-	return res;
-}
-
 /* Send a daisy-chain-style CPP command packet. */
 static int cpp_daisy(struct parport *port, int cmd)
 {

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/drivers/parport/daisy.c b/drivers/parport/daisy.c
index 83ee095ec6e2..ff9f34453530 100644
--- a/drivers/parport/daisy.c
+++ b/drivers/parport/daisy.c
@@ -216,7 +216,7 @@ void parport_daisy_fini(struct parport *port)
 
 struct pardevice *parport_open(int devnum, const char *name,
 				int (*pf) (void *), void (*kf) (void *),
-				void (*irqf) (int, void *, struct pt_regs *),
+				void (*irqf) (int, void *),
 				int flags, void *handle)
 {
 	struct daisydev *p = topology;

commit d32ccc431b2247535ce1114d7e31cc136c89262a
Author: Matthew Martin <lihnucks@gmail.com>
Date:   Tue Oct 3 23:25:14 2006 +0200

    parport: Remove space in function calls
    
    This removes the space in function calls in drivers/parport/daisy.c
    
    Signed-off-by: Matthew Martin <lihnucks@gmail.com>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/drivers/parport/daisy.c b/drivers/parport/daisy.c
index fd41e28101ea..83ee095ec6e2 100644
--- a/drivers/parport/daisy.c
+++ b/drivers/parport/daisy.c
@@ -30,7 +30,7 @@
 #undef DEBUG
 
 #ifdef DEBUG
-#define DPRINTK(stuff...) printk (stuff)
+#define DPRINTK(stuff...) printk(stuff)
 #else
 #define DPRINTK(stuff...)
 #endif
@@ -46,16 +46,16 @@ static DEFINE_SPINLOCK(topology_lock);
 static int numdevs = 0;
 
 /* Forward-declaration of lower-level functions. */
-static int mux_present (struct parport *port);
-static int num_mux_ports (struct parport *port);
-static int select_port (struct parport *port);
-static int assign_addrs (struct parport *port);
+static int mux_present(struct parport *port);
+static int num_mux_ports(struct parport *port);
+static int select_port(struct parport *port);
+static int assign_addrs(struct parport *port);
 
 /* Add a device to the discovered topology. */
-static void add_dev (int devnum, struct parport *port, int daisy)
+static void add_dev(int devnum, struct parport *port, int daisy)
 {
 	struct daisydev *newdev, **p;
-	newdev = kmalloc (sizeof (struct daisydev), GFP_KERNEL);
+	newdev = kmalloc(sizeof(struct daisydev), GFP_KERNEL);
 	if (newdev) {
 		newdev->port = port;
 		newdev->daisy = daisy;
@@ -70,9 +70,9 @@ static void add_dev (int devnum, struct parport *port, int daisy)
 }
 
 /* Clone a parport (actually, make an alias). */
-static struct parport *clone_parport (struct parport *real, int muxport)
+static struct parport *clone_parport(struct parport *real, int muxport)
 {
-	struct parport *extra = parport_register_port (real->base,
+	struct parport *extra = parport_register_port(real->base,
 						       real->irq,
 						       real->dma,
 						       real->ops);
@@ -88,7 +88,7 @@ static struct parport *clone_parport (struct parport *real, int muxport)
 
 /* Discover the IEEE1284.3 topology on a port -- muxes and daisy chains.
  * Return value is number of devices actually detected. */
-int parport_daisy_init (struct parport *port)
+int parport_daisy_init(struct parport *port)
 {
 	int detected = 0;
 	char *deviceid;
@@ -103,26 +103,26 @@ int parport_daisy_init (struct parport *port)
 
 	/* If mux present on normal port, need to create new
 	 * parports for each extra port. */
-	if (port->muxport < 0 && mux_present (port) &&
+	if (port->muxport < 0 && mux_present(port) &&
 	    /* don't be fooled: a mux must have 2 or 4 ports. */
-	    ((num_ports = num_mux_ports (port)) == 2 || num_ports == 4)) {
+	    ((num_ports = num_mux_ports(port)) == 2 || num_ports == 4)) {
 		/* Leave original as port zero. */
 		port->muxport = 0;
-		printk (KERN_INFO
+		printk(KERN_INFO
 			"%s: 1st (default) port of %d-way multiplexor\n",
 			port->name, num_ports);
 		for (i = 1; i < num_ports; i++) {
 			/* Clone the port. */
-			struct parport *extra = clone_parport (port, i);
+			struct parport *extra = clone_parport(port, i);
 			if (!extra) {
-				if (signal_pending (current))
+				if (signal_pending(current))
 					break;
 
-				schedule ();
+				schedule();
 				continue;
 			}
 
-			printk (KERN_INFO
+			printk(KERN_INFO
 				"%s: %d%s port of %d-way multiplexor on %s\n",
 				extra->name, i + 1, th[i + 1], num_ports,
 				port->name);
@@ -135,34 +135,34 @@ int parport_daisy_init (struct parport *port)
 	}
 
 	if (port->muxport >= 0)
-		select_port (port);
+		select_port(port);
 
-	parport_daisy_deselect_all (port);
-	detected += assign_addrs (port);
+	parport_daisy_deselect_all(port);
+	detected += assign_addrs(port);
 
 	/* Count the potential legacy device at the end. */
-	add_dev (numdevs++, port, -1);
+	add_dev(numdevs++, port, -1);
 
 	/* Find out the legacy device's IEEE 1284 device ID. */
-	deviceid = kmalloc (1024, GFP_KERNEL);
+	deviceid = kmalloc(1024, GFP_KERNEL);
 	if (deviceid) {
-		if (parport_device_id (numdevs - 1, deviceid, 1024) > 2)
+		if (parport_device_id(numdevs - 1, deviceid, 1024) > 2)
 			detected++;
 
-		kfree (deviceid);
+		kfree(deviceid);
 	}
 
 	if (!detected && !last_try) {
 		/* No devices were detected.  Perhaps they are in some
                    funny state; let's try to reset them and see if
                    they wake up. */
-		parport_daisy_fini (port);
-		parport_write_control (port, PARPORT_CONTROL_SELECT);
-		udelay (50);
-		parport_write_control (port,
+		parport_daisy_fini(port);
+		parport_write_control(port, PARPORT_CONTROL_SELECT);
+		udelay(50);
+		parport_write_control(port,
 				       PARPORT_CONTROL_SELECT |
 				       PARPORT_CONTROL_INIT);
-		udelay (50);
+		udelay(50);
 		last_try = 1;
 		goto again;
 	}
@@ -171,7 +171,7 @@ int parport_daisy_init (struct parport *port)
 }
 
 /* Forget about devices on a physical port. */
-void parport_daisy_fini (struct parport *port)
+void parport_daisy_fini(struct parport *port)
 {
 	struct daisydev **p;
 
@@ -214,7 +214,7 @@ void parport_daisy_fini (struct parport *port)
  *	for parport_register_device().
  **/
 
-struct pardevice *parport_open (int devnum, const char *name,
+struct pardevice *parport_open(int devnum, const char *name,
 				int (*pf) (void *), void (*kf) (void *),
 				void (*irqf) (int, void *, struct pt_regs *),
 				int flags, void *handle)
@@ -237,7 +237,7 @@ struct pardevice *parport_open (int devnum, const char *name,
 	port = parport_get_port(p->port);
 	spin_unlock(&topology_lock);
 
-	dev = parport_register_device (port, name, pf, kf,
+	dev = parport_register_device(port, name, pf, kf,
 				       irqf, flags, handle);
 	parport_put_port(port);
 	if (!dev)
@@ -248,13 +248,13 @@ struct pardevice *parport_open (int devnum, const char *name,
 	/* Check that there really is a device to select. */
 	if (daisy >= 0) {
 		int selected;
-		parport_claim_or_block (dev);
+		parport_claim_or_block(dev);
 		selected = port->daisy;
-		parport_release (dev);
+		parport_release(dev);
 
 		if (selected != daisy) {
 			/* No corresponding device. */
-			parport_unregister_device (dev);
+			parport_unregister_device(dev);
 			return NULL;
 		}
 	}
@@ -270,9 +270,9 @@ struct pardevice *parport_open (int devnum, const char *name,
  *	parport_register_device().
  **/
 
-void parport_close (struct pardevice *dev)
+void parport_close(struct pardevice *dev)
 {
-	parport_unregister_device (dev);
+	parport_unregister_device(dev);
 }
 
 /**
@@ -287,7 +287,7 @@ void parport_close (struct pardevice *dev)
  *	exists.
  **/
 
-int parport_device_num (int parport, int mux, int daisy)
+int parport_device_num(int parport, int mux, int daisy)
 {
 	int res = -ENXIO;
 	struct daisydev *dev;
@@ -305,16 +305,16 @@ int parport_device_num (int parport, int mux, int daisy)
 }
 
 /* Send a daisy-chain-style CPP command packet. */
-static int cpp_daisy (struct parport *port, int cmd)
+static int cpp_daisy(struct parport *port, int cmd)
 {
 	unsigned char s;
 
-	parport_data_forward (port);
-	parport_write_data (port, 0xaa); udelay (2);
-	parport_write_data (port, 0x55); udelay (2);
-	parport_write_data (port, 0x00); udelay (2);
-	parport_write_data (port, 0xff); udelay (2);
-	s = parport_read_status (port) & (PARPORT_STATUS_BUSY
+	parport_data_forward(port);
+	parport_write_data(port, 0xaa); udelay(2);
+	parport_write_data(port, 0x55); udelay(2);
+	parport_write_data(port, 0x00); udelay(2);
+	parport_write_data(port, 0xff); udelay(2);
+	s = parport_read_status(port) & (PARPORT_STATUS_BUSY
 					  | PARPORT_STATUS_PAPEROUT
 					  | PARPORT_STATUS_SELECT
 					  | PARPORT_STATUS_ERROR);
@@ -322,54 +322,54 @@ static int cpp_daisy (struct parport *port, int cmd)
 		  | PARPORT_STATUS_PAPEROUT
 		  | PARPORT_STATUS_SELECT
 		  | PARPORT_STATUS_ERROR)) {
-		DPRINTK (KERN_DEBUG "%s: cpp_daisy: aa5500ff(%02x)\n",
+		DPRINTK(KERN_DEBUG "%s: cpp_daisy: aa5500ff(%02x)\n",
 			 port->name, s);
 		return -ENXIO;
 	}
 
-	parport_write_data (port, 0x87); udelay (2);
-	s = parport_read_status (port) & (PARPORT_STATUS_BUSY
+	parport_write_data(port, 0x87); udelay(2);
+	s = parport_read_status(port) & (PARPORT_STATUS_BUSY
 					  | PARPORT_STATUS_PAPEROUT
 					  | PARPORT_STATUS_SELECT
 					  | PARPORT_STATUS_ERROR);
 	if (s != (PARPORT_STATUS_SELECT | PARPORT_STATUS_ERROR)) {
-		DPRINTK (KERN_DEBUG "%s: cpp_daisy: aa5500ff87(%02x)\n",
+		DPRINTK(KERN_DEBUG "%s: cpp_daisy: aa5500ff87(%02x)\n",
 			 port->name, s);
 		return -ENXIO;
 	}
 
-	parport_write_data (port, 0x78); udelay (2);
-	parport_write_data (port, cmd); udelay (2);
-	parport_frob_control (port,
+	parport_write_data(port, 0x78); udelay(2);
+	parport_write_data(port, cmd); udelay(2);
+	parport_frob_control(port,
 			      PARPORT_CONTROL_STROBE,
 			      PARPORT_CONTROL_STROBE);
-	udelay (1);
-	s = parport_read_status (port);
-	parport_frob_control (port, PARPORT_CONTROL_STROBE, 0);
-	udelay (1);
-	parport_write_data (port, 0xff); udelay (2);
+	udelay(1);
+	s = parport_read_status(port);
+	parport_frob_control(port, PARPORT_CONTROL_STROBE, 0);
+	udelay(1);
+	parport_write_data(port, 0xff); udelay(2);
 
 	return s;
 }
 
 /* Send a mux-style CPP command packet. */
-static int cpp_mux (struct parport *port, int cmd)
+static int cpp_mux(struct parport *port, int cmd)
 {
 	unsigned char s;
 	int rc;
 
-	parport_data_forward (port);
-	parport_write_data (port, 0xaa); udelay (2);
-	parport_write_data (port, 0x55); udelay (2);
-	parport_write_data (port, 0xf0); udelay (2);
-	parport_write_data (port, 0x0f); udelay (2);
-	parport_write_data (port, 0x52); udelay (2);
-	parport_write_data (port, 0xad); udelay (2);
-	parport_write_data (port, cmd); udelay (2);
+	parport_data_forward(port);
+	parport_write_data(port, 0xaa); udelay(2);
+	parport_write_data(port, 0x55); udelay(2);
+	parport_write_data(port, 0xf0); udelay(2);
+	parport_write_data(port, 0x0f); udelay(2);
+	parport_write_data(port, 0x52); udelay(2);
+	parport_write_data(port, 0xad); udelay(2);
+	parport_write_data(port, cmd); udelay(2);
 
-	s = parport_read_status (port);
+	s = parport_read_status(port);
 	if (!(s & PARPORT_STATUS_ACK)) {
-		DPRINTK (KERN_DEBUG "%s: cpp_mux: aa55f00f52ad%02x(%02x)\n",
+		DPRINTK(KERN_DEBUG "%s: cpp_mux: aa55f00f52ad%02x(%02x)\n",
 			 port->name, cmd, s);
 		return -EIO;
 	}
@@ -382,12 +382,12 @@ static int cpp_mux (struct parport *port, int cmd)
 	return rc;
 }
 
-void parport_daisy_deselect_all (struct parport *port)
+void parport_daisy_deselect_all(struct parport *port)
 {
-	cpp_daisy (port, 0x30);
+	cpp_daisy(port, 0x30);
 }
 
-int parport_daisy_select (struct parport *port, int daisy, int mode)
+int parport_daisy_select(struct parport *port, int daisy, int mode)
 {
 	switch (mode)
 	{
@@ -395,14 +395,14 @@ int parport_daisy_select (struct parport *port, int daisy, int mode)
 		case IEEE1284_MODE_EPP:
 		case IEEE1284_MODE_EPPSL:
 		case IEEE1284_MODE_EPPSWE:
-			return !(cpp_daisy (port, 0x20 + daisy) &
+			return !(cpp_daisy(port, 0x20 + daisy) &
 				 PARPORT_STATUS_ERROR);
 
 		// For these modes we should switch to ECP mode:
 		case IEEE1284_MODE_ECP:
 		case IEEE1284_MODE_ECPRLE:
 		case IEEE1284_MODE_ECPSWE: 
-			return !(cpp_daisy (port, 0xd0 + daisy) &
+			return !(cpp_daisy(port, 0xd0 + daisy) &
 				 PARPORT_STATUS_ERROR);
 
 		// Nothing was told for BECP in Daisy chain specification.
@@ -413,28 +413,28 @@ int parport_daisy_select (struct parport *port, int daisy, int mode)
 		case IEEE1284_MODE_BYTE:
 		case IEEE1284_MODE_COMPAT:
 		default:
-			return !(cpp_daisy (port, 0xe0 + daisy) &
+			return !(cpp_daisy(port, 0xe0 + daisy) &
 				 PARPORT_STATUS_ERROR);
 	}
 }
 
-static int mux_present (struct parport *port)
+static int mux_present(struct parport *port)
 {
-	return cpp_mux (port, 0x51) == 3;
+	return cpp_mux(port, 0x51) == 3;
 }
 
-static int num_mux_ports (struct parport *port)
+static int num_mux_ports(struct parport *port)
 {
-	return cpp_mux (port, 0x58);
+	return cpp_mux(port, 0x58);
 }
 
-static int select_port (struct parport *port)
+static int select_port(struct parport *port)
 {
 	int muxport = port->muxport;
-	return cpp_mux (port, 0x60 + muxport) == muxport;
+	return cpp_mux(port, 0x60 + muxport) == muxport;
 }
 
-static int assign_addrs (struct parport *port)
+static int assign_addrs(struct parport *port)
 {
 	unsigned char s;
 	unsigned char daisy;
@@ -442,12 +442,12 @@ static int assign_addrs (struct parport *port)
 	int detected;
 	char *deviceid;
 
-	parport_data_forward (port);
-	parport_write_data (port, 0xaa); udelay (2);
-	parport_write_data (port, 0x55); udelay (2);
-	parport_write_data (port, 0x00); udelay (2);
-	parport_write_data (port, 0xff); udelay (2);
-	s = parport_read_status (port) & (PARPORT_STATUS_BUSY
+	parport_data_forward(port);
+	parport_write_data(port, 0xaa); udelay(2);
+	parport_write_data(port, 0x55); udelay(2);
+	parport_write_data(port, 0x00); udelay(2);
+	parport_write_data(port, 0xff); udelay(2);
+	s = parport_read_status(port) & (PARPORT_STATUS_BUSY
 					  | PARPORT_STATUS_PAPEROUT
 					  | PARPORT_STATUS_SELECT
 					  | PARPORT_STATUS_ERROR);
@@ -455,40 +455,40 @@ static int assign_addrs (struct parport *port)
 		  | PARPORT_STATUS_PAPEROUT
 		  | PARPORT_STATUS_SELECT
 		  | PARPORT_STATUS_ERROR)) {
-		DPRINTK (KERN_DEBUG "%s: assign_addrs: aa5500ff(%02x)\n",
+		DPRINTK(KERN_DEBUG "%s: assign_addrs: aa5500ff(%02x)\n",
 			 port->name, s);
 		return 0;
 	}
 
-	parport_write_data (port, 0x87); udelay (2);
-	s = parport_read_status (port) & (PARPORT_STATUS_BUSY
+	parport_write_data(port, 0x87); udelay(2);
+	s = parport_read_status(port) & (PARPORT_STATUS_BUSY
 					  | PARPORT_STATUS_PAPEROUT
 					  | PARPORT_STATUS_SELECT
 					  | PARPORT_STATUS_ERROR);
 	if (s != (PARPORT_STATUS_SELECT | PARPORT_STATUS_ERROR)) {
-		DPRINTK (KERN_DEBUG "%s: assign_addrs: aa5500ff87(%02x)\n",
+		DPRINTK(KERN_DEBUG "%s: assign_addrs: aa5500ff87(%02x)\n",
 			 port->name, s);
 		return 0;
 	}
 
-	parport_write_data (port, 0x78); udelay (2);
-	s = parport_read_status (port);
+	parport_write_data(port, 0x78); udelay(2);
+	s = parport_read_status(port);
 
 	for (daisy = 0;
 	     (s & (PARPORT_STATUS_PAPEROUT|PARPORT_STATUS_SELECT))
 		     == (PARPORT_STATUS_PAPEROUT|PARPORT_STATUS_SELECT)
 		     && daisy < 4;
 	     ++daisy) {
-		parport_write_data (port, daisy);
-		udelay (2);
-		parport_frob_control (port,
+		parport_write_data(port, daisy);
+		udelay(2);
+		parport_frob_control(port,
 				      PARPORT_CONTROL_STROBE,
 				      PARPORT_CONTROL_STROBE);
-		udelay (1);
-		parport_frob_control (port, PARPORT_CONTROL_STROBE, 0);
-		udelay (1);
+		udelay(1);
+		parport_frob_control(port, PARPORT_CONTROL_STROBE, 0);
+		udelay(1);
 
-		add_dev (numdevs++, port, daisy);
+		add_dev(numdevs++, port, daisy);
 
 		/* See if this device thought it was the last in the
 		 * chain. */
@@ -499,21 +499,21 @@ static int assign_addrs (struct parport *port)
 		   last_dev from next device or if last_dev does not
 		   work status lines from some non-daisy chain
 		   device. */
-		s = parport_read_status (port);
+		s = parport_read_status(port);
 	}
 
-	parport_write_data (port, 0xff); udelay (2);
+	parport_write_data(port, 0xff); udelay(2);
 	detected = numdevs - thisdev;
-	DPRINTK (KERN_DEBUG "%s: Found %d daisy-chained devices\n", port->name,
+	DPRINTK(KERN_DEBUG "%s: Found %d daisy-chained devices\n", port->name,
 		 detected);
 
 	/* Ask the new devices to introduce themselves. */
-	deviceid = kmalloc (1024, GFP_KERNEL);
+	deviceid = kmalloc(1024, GFP_KERNEL);
 	if (!deviceid) return 0;
 
 	for (daisy = 0; thisdev < numdevs; thisdev++, daisy++)
-		parport_device_id (thisdev, deviceid, 1024);
+		parport_device_id(thisdev, deviceid, 1024);
 
-	kfree (deviceid);
+	kfree(deviceid);
 	return detected;
 }

commit 7d469722779c9fe0b415163e8fe837440f9c70dc
Author: Randy Dunlap <rdunlap@xenotime.net>
Date:   Sun Jun 25 05:49:29 2006 -0700

    [PATCH] parport: add to kernel-doc
    
    Add parport interfaces to kernel-doc template.  Small doc.  cleanups in 2
    parport source files.
    
    Signed-off-by: Randy Dunlap <rdunlap@xenotime.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/parport/daisy.c b/drivers/parport/daisy.c
index 9ee67321b630..fd41e28101ea 100644
--- a/drivers/parport/daisy.c
+++ b/drivers/parport/daisy.c
@@ -283,7 +283,7 @@ void parport_close (struct pardevice *dev)
  *
  *	This tries to locate a device on the given parallel port,
  *	multiplexor port and daisy chain address, and returns its
- *	device number or -NXIO if no device with those coordinates
+ *	device number or %-ENXIO if no device with those coordinates
  *	exists.
  **/
 

commit b44d3bdd6fcf6233b381bf5bd0893ed235f497a9
Author: Marko Kohtala <marko.kohtala@gmail.com>
Date:   Fri Jan 6 00:19:47 2006 -0800

    [PATCH] parport: use complete slab buffer
    
    Use the complete slab buffer that is allocated by kmalloc.
    
    Signed-off-by: Marko Kohtala <marko.kohtala@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/parport/daisy.c b/drivers/parport/daisy.c
index 9109a40fc8c0..9ee67321b630 100644
--- a/drivers/parport/daisy.c
+++ b/drivers/parport/daisy.c
@@ -144,9 +144,9 @@ int parport_daisy_init (struct parport *port)
 	add_dev (numdevs++, port, -1);
 
 	/* Find out the legacy device's IEEE 1284 device ID. */
-	deviceid = kmalloc (1000, GFP_KERNEL);
+	deviceid = kmalloc (1024, GFP_KERNEL);
 	if (deviceid) {
-		if (parport_device_id (numdevs - 1, deviceid, 1000) > 2)
+		if (parport_device_id (numdevs - 1, deviceid, 1024) > 2)
 			detected++;
 
 		kfree (deviceid);
@@ -508,11 +508,11 @@ static int assign_addrs (struct parport *port)
 		 detected);
 
 	/* Ask the new devices to introduce themselves. */
-	deviceid = kmalloc (1000, GFP_KERNEL);
+	deviceid = kmalloc (1024, GFP_KERNEL);
 	if (!deviceid) return 0;
 
 	for (daisy = 0; thisdev < numdevs; thisdev++, daisy++)
-		parport_device_id (thisdev, deviceid, 1000);
+		parport_device_id (thisdev, deviceid, 1024);
 
 	kfree (deviceid);
 	return detected;

commit 7c9cc3be1094b267a2da2e0016cbd6ced663da6d
Author: Marko Kohtala <marko.kohtala@gmail.com>
Date:   Fri Jan 6 00:19:46 2006 -0800

    [PATCH] parport: parport_daisy_select return value fix
    
    parport_daisy_select returned wrong status that is read at wrong time
    during daisy command execution.
    
    Signed-off-by: Marko Kohtala <marko.kohtala@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/parport/daisy.c b/drivers/parport/daisy.c
index 37dc17933518..9109a40fc8c0 100644
--- a/drivers/parport/daisy.c
+++ b/drivers/parport/daisy.c
@@ -344,9 +344,9 @@ static int cpp_daisy (struct parport *port, int cmd)
 			      PARPORT_CONTROL_STROBE,
 			      PARPORT_CONTROL_STROBE);
 	udelay (1);
+	s = parport_read_status (port);
 	parport_frob_control (port, PARPORT_CONTROL_STROBE, 0);
 	udelay (1);
-	s = parport_read_status (port);
 	parport_write_data (port, 0xff); udelay (2);
 
 	return s;
@@ -395,15 +395,15 @@ int parport_daisy_select (struct parport *port, int daisy, int mode)
 		case IEEE1284_MODE_EPP:
 		case IEEE1284_MODE_EPPSL:
 		case IEEE1284_MODE_EPPSWE:
-			return (cpp_daisy (port, 0x20 + daisy) &
-				PARPORT_STATUS_ERROR);
+			return !(cpp_daisy (port, 0x20 + daisy) &
+				 PARPORT_STATUS_ERROR);
 
 		// For these modes we should switch to ECP mode:
 		case IEEE1284_MODE_ECP:
 		case IEEE1284_MODE_ECPRLE:
 		case IEEE1284_MODE_ECPSWE: 
-			return (cpp_daisy (port, 0xd0 + daisy) &
-				PARPORT_STATUS_ERROR);
+			return !(cpp_daisy (port, 0xd0 + daisy) &
+				 PARPORT_STATUS_ERROR);
 
 		// Nothing was told for BECP in Daisy chain specification.
 		// May be it's wise to use ECP?
@@ -413,8 +413,8 @@ int parport_daisy_select (struct parport *port, int daisy, int mode)
 		case IEEE1284_MODE_BYTE:
 		case IEEE1284_MODE_COMPAT:
 		default:
-			return (cpp_daisy (port, 0xe0 + daisy) &
-				PARPORT_STATUS_ERROR);
+			return !(cpp_daisy (port, 0xe0 + daisy) &
+				 PARPORT_STATUS_ERROR);
 	}
 }
 

commit c29a75ed0d94fae64b59345ea96e52424ae9c6a2
Author: Marko Kohtala <marko.kohtala@gmail.com>
Date:   Fri Jan 6 00:19:46 2006 -0800

    [PATCH] parport: daisy chain device id reading fix
    
    Device ID reading from daisy chain devices failed because the daisy
    device could not be opened.
    
    Signed-off-by: Marko Kohtala <marko.kohtala@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/parport/daisy.c b/drivers/parport/daisy.c
index 6915114b9536..37dc17933518 100644
--- a/drivers/parport/daisy.c
+++ b/drivers/parport/daisy.c
@@ -252,7 +252,7 @@ struct pardevice *parport_open (int devnum, const char *name,
 		selected = port->daisy;
 		parport_release (dev);
 
-		if (selected != port->daisy) {
+		if (selected != daisy) {
 			/* No corresponding device. */
 			parport_unregister_device (dev);
 			return NULL;

commit 310c8c324f988625a2880deab67607bf4e5aeb8a
Author: Marko Kohtala <marko.kohtala@gmail.com>
Date:   Fri Jan 6 00:19:45 2006 -0800

    [PATCH] parport: daisy chain end detection fix
    
    Daisy chain end detection failed at least with older daisy chain devices that
    do not implement the last device signal.
    
    Signed-off-by: Marko Kohtala <marko.kohtala@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/parport/daisy.c b/drivers/parport/daisy.c
index 075c7eb5c85d..6915114b9536 100644
--- a/drivers/parport/daisy.c
+++ b/drivers/parport/daisy.c
@@ -436,7 +436,7 @@ static int select_port (struct parport *port)
 
 static int assign_addrs (struct parport *port)
 {
-	unsigned char s, last_dev;
+	unsigned char s;
 	unsigned char daisy;
 	int thisdev = numdevs;
 	int detected;
@@ -472,10 +472,13 @@ static int assign_addrs (struct parport *port)
 	}
 
 	parport_write_data (port, 0x78); udelay (2);
-	last_dev = 0; /* We've just been speaking to a device, so we
-			 know there must be at least _one_ out there. */
+	s = parport_read_status (port);
 
-	for (daisy = 0; daisy < 4; daisy++) {
+	for (daisy = 0;
+	     (s & (PARPORT_STATUS_PAPEROUT|PARPORT_STATUS_SELECT))
+		     == (PARPORT_STATUS_PAPEROUT|PARPORT_STATUS_SELECT)
+		     && daisy < 4;
+	     ++daisy) {
 		parport_write_data (port, daisy);
 		udelay (2);
 		parport_frob_control (port,
@@ -485,14 +488,18 @@ static int assign_addrs (struct parport *port)
 		parport_frob_control (port, PARPORT_CONTROL_STROBE, 0);
 		udelay (1);
 
-		if (last_dev)
-			/* No more devices. */
-			break;
+		add_dev (numdevs++, port, daisy);
 
-		last_dev = !(parport_read_status (port)
-			     & PARPORT_STATUS_BUSY);
+		/* See if this device thought it was the last in the
+		 * chain. */
+		if (!(s & PARPORT_STATUS_BUSY))
+			break;
 
-		add_dev (numdevs++, port, daisy);
+		/* We are seeing pass through status now. We see
+		   last_dev from next device or if last_dev does not
+		   work status lines from some non-daisy chain
+		   device. */
+		s = parport_read_status (port);
 	}
 
 	parport_write_data (port, 0xff); udelay (2);

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/parport/daisy.c b/drivers/parport/daisy.c
new file mode 100644
index 000000000000..075c7eb5c85d
--- /dev/null
+++ b/drivers/parport/daisy.c
@@ -0,0 +1,512 @@
+/*
+ * IEEE 1284.3 Parallel port daisy chain and multiplexor code
+ * 
+ * Copyright (C) 1999, 2000  Tim Waugh <tim@cyberelk.demon.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * ??-12-1998: Initial implementation.
+ * 31-01-1999: Make port-cloning transparent.
+ * 13-02-1999: Move DeviceID technique from parport_probe.
+ * 13-03-1999: Get DeviceID from non-IEEE 1284.3 devices too.
+ * 22-02-2000: Count devices that are actually detected.
+ *
+ * Any part of this program may be used in documents licensed under
+ * the GNU Free Documentation License, Version 1.1 or any later version
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/parport.h>
+#include <linux/delay.h>
+#include <linux/sched.h>
+
+#include <asm/current.h>
+#include <asm/uaccess.h>
+
+#undef DEBUG
+
+#ifdef DEBUG
+#define DPRINTK(stuff...) printk (stuff)
+#else
+#define DPRINTK(stuff...)
+#endif
+
+static struct daisydev {
+	struct daisydev *next;
+	struct parport *port;
+	int daisy;
+	int devnum;
+} *topology = NULL;
+static DEFINE_SPINLOCK(topology_lock);
+
+static int numdevs = 0;
+
+/* Forward-declaration of lower-level functions. */
+static int mux_present (struct parport *port);
+static int num_mux_ports (struct parport *port);
+static int select_port (struct parport *port);
+static int assign_addrs (struct parport *port);
+
+/* Add a device to the discovered topology. */
+static void add_dev (int devnum, struct parport *port, int daisy)
+{
+	struct daisydev *newdev, **p;
+	newdev = kmalloc (sizeof (struct daisydev), GFP_KERNEL);
+	if (newdev) {
+		newdev->port = port;
+		newdev->daisy = daisy;
+		newdev->devnum = devnum;
+		spin_lock(&topology_lock);
+		for (p = &topology; *p && (*p)->devnum<devnum; p = &(*p)->next)
+			;
+		newdev->next = *p;
+		*p = newdev;
+		spin_unlock(&topology_lock);
+	}
+}
+
+/* Clone a parport (actually, make an alias). */
+static struct parport *clone_parport (struct parport *real, int muxport)
+{
+	struct parport *extra = parport_register_port (real->base,
+						       real->irq,
+						       real->dma,
+						       real->ops);
+	if (extra) {
+		extra->portnum = real->portnum;
+		extra->physport = real;
+		extra->muxport = muxport;
+		real->slaves[muxport-1] = extra;
+	}
+
+	return extra;
+}
+
+/* Discover the IEEE1284.3 topology on a port -- muxes and daisy chains.
+ * Return value is number of devices actually detected. */
+int parport_daisy_init (struct parport *port)
+{
+	int detected = 0;
+	char *deviceid;
+	static const char *th[] = { /*0*/"th", "st", "nd", "rd", "th" };
+	int num_ports;
+	int i;
+	int last_try = 0;
+
+again:
+	/* Because this is called before any other devices exist,
+	 * we don't have to claim exclusive access.  */
+
+	/* If mux present on normal port, need to create new
+	 * parports for each extra port. */
+	if (port->muxport < 0 && mux_present (port) &&
+	    /* don't be fooled: a mux must have 2 or 4 ports. */
+	    ((num_ports = num_mux_ports (port)) == 2 || num_ports == 4)) {
+		/* Leave original as port zero. */
+		port->muxport = 0;
+		printk (KERN_INFO
+			"%s: 1st (default) port of %d-way multiplexor\n",
+			port->name, num_ports);
+		for (i = 1; i < num_ports; i++) {
+			/* Clone the port. */
+			struct parport *extra = clone_parport (port, i);
+			if (!extra) {
+				if (signal_pending (current))
+					break;
+
+				schedule ();
+				continue;
+			}
+
+			printk (KERN_INFO
+				"%s: %d%s port of %d-way multiplexor on %s\n",
+				extra->name, i + 1, th[i + 1], num_ports,
+				port->name);
+
+			/* Analyse that port too.  We won't recurse
+			   forever because of the 'port->muxport < 0'
+			   test above. */
+			parport_daisy_init(extra);
+		}
+	}
+
+	if (port->muxport >= 0)
+		select_port (port);
+
+	parport_daisy_deselect_all (port);
+	detected += assign_addrs (port);
+
+	/* Count the potential legacy device at the end. */
+	add_dev (numdevs++, port, -1);
+
+	/* Find out the legacy device's IEEE 1284 device ID. */
+	deviceid = kmalloc (1000, GFP_KERNEL);
+	if (deviceid) {
+		if (parport_device_id (numdevs - 1, deviceid, 1000) > 2)
+			detected++;
+
+		kfree (deviceid);
+	}
+
+	if (!detected && !last_try) {
+		/* No devices were detected.  Perhaps they are in some
+                   funny state; let's try to reset them and see if
+                   they wake up. */
+		parport_daisy_fini (port);
+		parport_write_control (port, PARPORT_CONTROL_SELECT);
+		udelay (50);
+		parport_write_control (port,
+				       PARPORT_CONTROL_SELECT |
+				       PARPORT_CONTROL_INIT);
+		udelay (50);
+		last_try = 1;
+		goto again;
+	}
+
+	return detected;
+}
+
+/* Forget about devices on a physical port. */
+void parport_daisy_fini (struct parport *port)
+{
+	struct daisydev **p;
+
+	spin_lock(&topology_lock);
+	p = &topology;
+	while (*p) {
+		struct daisydev *dev = *p;
+		if (dev->port != port) {
+			p = &dev->next;
+			continue;
+		}
+		*p = dev->next;
+		kfree(dev);
+	}
+
+	/* Gaps in the numbering could be handled better.  How should
+           someone enumerate through all IEEE1284.3 devices in the
+           topology?. */
+	if (!topology) numdevs = 0;
+	spin_unlock(&topology_lock);
+	return;
+}
+
+/**
+ *	parport_open - find a device by canonical device number
+ *	@devnum: canonical device number
+ *	@name: name to associate with the device
+ *	@pf: preemption callback
+ *	@kf: kick callback
+ *	@irqf: interrupt handler
+ *	@flags: registration flags
+ *	@handle: driver data
+ *
+ *	This function is similar to parport_register_device(), except
+ *	that it locates a device by its number rather than by the port
+ *	it is attached to.
+ *
+ *	All parameters except for @devnum are the same as for
+ *	parport_register_device().  The return value is the same as
+ *	for parport_register_device().
+ **/
+
+struct pardevice *parport_open (int devnum, const char *name,
+				int (*pf) (void *), void (*kf) (void *),
+				void (*irqf) (int, void *, struct pt_regs *),
+				int flags, void *handle)
+{
+	struct daisydev *p = topology;
+	struct parport *port;
+	struct pardevice *dev;
+	int daisy;
+
+	spin_lock(&topology_lock);
+	while (p && p->devnum != devnum)
+		p = p->next;
+
+	if (!p) {
+		spin_unlock(&topology_lock);
+		return NULL;
+	}
+
+	daisy = p->daisy;
+	port = parport_get_port(p->port);
+	spin_unlock(&topology_lock);
+
+	dev = parport_register_device (port, name, pf, kf,
+				       irqf, flags, handle);
+	parport_put_port(port);
+	if (!dev)
+		return NULL;
+
+	dev->daisy = daisy;
+
+	/* Check that there really is a device to select. */
+	if (daisy >= 0) {
+		int selected;
+		parport_claim_or_block (dev);
+		selected = port->daisy;
+		parport_release (dev);
+
+		if (selected != port->daisy) {
+			/* No corresponding device. */
+			parport_unregister_device (dev);
+			return NULL;
+		}
+	}
+
+	return dev;
+}
+
+/**
+ *	parport_close - close a device opened with parport_open()
+ *	@dev: device to close
+ *
+ *	This is to parport_open() as parport_unregister_device() is to
+ *	parport_register_device().
+ **/
+
+void parport_close (struct pardevice *dev)
+{
+	parport_unregister_device (dev);
+}
+
+/**
+ *	parport_device_num - convert device coordinates
+ *	@parport: parallel port number
+ *	@mux: multiplexor port number (-1 for no multiplexor)
+ *	@daisy: daisy chain address (-1 for no daisy chain address)
+ *
+ *	This tries to locate a device on the given parallel port,
+ *	multiplexor port and daisy chain address, and returns its
+ *	device number or -NXIO if no device with those coordinates
+ *	exists.
+ **/
+
+int parport_device_num (int parport, int mux, int daisy)
+{
+	int res = -ENXIO;
+	struct daisydev *dev;
+
+	spin_lock(&topology_lock);
+	dev = topology;
+	while (dev && dev->port->portnum != parport &&
+	       dev->port->muxport != mux && dev->daisy != daisy)
+		dev = dev->next;
+	if (dev)
+		res = dev->devnum;
+	spin_unlock(&topology_lock);
+
+	return res;
+}
+
+/* Send a daisy-chain-style CPP command packet. */
+static int cpp_daisy (struct parport *port, int cmd)
+{
+	unsigned char s;
+
+	parport_data_forward (port);
+	parport_write_data (port, 0xaa); udelay (2);
+	parport_write_data (port, 0x55); udelay (2);
+	parport_write_data (port, 0x00); udelay (2);
+	parport_write_data (port, 0xff); udelay (2);
+	s = parport_read_status (port) & (PARPORT_STATUS_BUSY
+					  | PARPORT_STATUS_PAPEROUT
+					  | PARPORT_STATUS_SELECT
+					  | PARPORT_STATUS_ERROR);
+	if (s != (PARPORT_STATUS_BUSY
+		  | PARPORT_STATUS_PAPEROUT
+		  | PARPORT_STATUS_SELECT
+		  | PARPORT_STATUS_ERROR)) {
+		DPRINTK (KERN_DEBUG "%s: cpp_daisy: aa5500ff(%02x)\n",
+			 port->name, s);
+		return -ENXIO;
+	}
+
+	parport_write_data (port, 0x87); udelay (2);
+	s = parport_read_status (port) & (PARPORT_STATUS_BUSY
+					  | PARPORT_STATUS_PAPEROUT
+					  | PARPORT_STATUS_SELECT
+					  | PARPORT_STATUS_ERROR);
+	if (s != (PARPORT_STATUS_SELECT | PARPORT_STATUS_ERROR)) {
+		DPRINTK (KERN_DEBUG "%s: cpp_daisy: aa5500ff87(%02x)\n",
+			 port->name, s);
+		return -ENXIO;
+	}
+
+	parport_write_data (port, 0x78); udelay (2);
+	parport_write_data (port, cmd); udelay (2);
+	parport_frob_control (port,
+			      PARPORT_CONTROL_STROBE,
+			      PARPORT_CONTROL_STROBE);
+	udelay (1);
+	parport_frob_control (port, PARPORT_CONTROL_STROBE, 0);
+	udelay (1);
+	s = parport_read_status (port);
+	parport_write_data (port, 0xff); udelay (2);
+
+	return s;
+}
+
+/* Send a mux-style CPP command packet. */
+static int cpp_mux (struct parport *port, int cmd)
+{
+	unsigned char s;
+	int rc;
+
+	parport_data_forward (port);
+	parport_write_data (port, 0xaa); udelay (2);
+	parport_write_data (port, 0x55); udelay (2);
+	parport_write_data (port, 0xf0); udelay (2);
+	parport_write_data (port, 0x0f); udelay (2);
+	parport_write_data (port, 0x52); udelay (2);
+	parport_write_data (port, 0xad); udelay (2);
+	parport_write_data (port, cmd); udelay (2);
+
+	s = parport_read_status (port);
+	if (!(s & PARPORT_STATUS_ACK)) {
+		DPRINTK (KERN_DEBUG "%s: cpp_mux: aa55f00f52ad%02x(%02x)\n",
+			 port->name, cmd, s);
+		return -EIO;
+	}
+
+	rc = (((s & PARPORT_STATUS_SELECT   ? 1 : 0) << 0) |
+	      ((s & PARPORT_STATUS_PAPEROUT ? 1 : 0) << 1) |
+	      ((s & PARPORT_STATUS_BUSY     ? 0 : 1) << 2) |
+	      ((s & PARPORT_STATUS_ERROR    ? 0 : 1) << 3));
+
+	return rc;
+}
+
+void parport_daisy_deselect_all (struct parport *port)
+{
+	cpp_daisy (port, 0x30);
+}
+
+int parport_daisy_select (struct parport *port, int daisy, int mode)
+{
+	switch (mode)
+	{
+		// For these modes we should switch to EPP mode:
+		case IEEE1284_MODE_EPP:
+		case IEEE1284_MODE_EPPSL:
+		case IEEE1284_MODE_EPPSWE:
+			return (cpp_daisy (port, 0x20 + daisy) &
+				PARPORT_STATUS_ERROR);
+
+		// For these modes we should switch to ECP mode:
+		case IEEE1284_MODE_ECP:
+		case IEEE1284_MODE_ECPRLE:
+		case IEEE1284_MODE_ECPSWE: 
+			return (cpp_daisy (port, 0xd0 + daisy) &
+				PARPORT_STATUS_ERROR);
+
+		// Nothing was told for BECP in Daisy chain specification.
+		// May be it's wise to use ECP?
+		case IEEE1284_MODE_BECP:
+		// Others use compat mode
+		case IEEE1284_MODE_NIBBLE:
+		case IEEE1284_MODE_BYTE:
+		case IEEE1284_MODE_COMPAT:
+		default:
+			return (cpp_daisy (port, 0xe0 + daisy) &
+				PARPORT_STATUS_ERROR);
+	}
+}
+
+static int mux_present (struct parport *port)
+{
+	return cpp_mux (port, 0x51) == 3;
+}
+
+static int num_mux_ports (struct parport *port)
+{
+	return cpp_mux (port, 0x58);
+}
+
+static int select_port (struct parport *port)
+{
+	int muxport = port->muxport;
+	return cpp_mux (port, 0x60 + muxport) == muxport;
+}
+
+static int assign_addrs (struct parport *port)
+{
+	unsigned char s, last_dev;
+	unsigned char daisy;
+	int thisdev = numdevs;
+	int detected;
+	char *deviceid;
+
+	parport_data_forward (port);
+	parport_write_data (port, 0xaa); udelay (2);
+	parport_write_data (port, 0x55); udelay (2);
+	parport_write_data (port, 0x00); udelay (2);
+	parport_write_data (port, 0xff); udelay (2);
+	s = parport_read_status (port) & (PARPORT_STATUS_BUSY
+					  | PARPORT_STATUS_PAPEROUT
+					  | PARPORT_STATUS_SELECT
+					  | PARPORT_STATUS_ERROR);
+	if (s != (PARPORT_STATUS_BUSY
+		  | PARPORT_STATUS_PAPEROUT
+		  | PARPORT_STATUS_SELECT
+		  | PARPORT_STATUS_ERROR)) {
+		DPRINTK (KERN_DEBUG "%s: assign_addrs: aa5500ff(%02x)\n",
+			 port->name, s);
+		return 0;
+	}
+
+	parport_write_data (port, 0x87); udelay (2);
+	s = parport_read_status (port) & (PARPORT_STATUS_BUSY
+					  | PARPORT_STATUS_PAPEROUT
+					  | PARPORT_STATUS_SELECT
+					  | PARPORT_STATUS_ERROR);
+	if (s != (PARPORT_STATUS_SELECT | PARPORT_STATUS_ERROR)) {
+		DPRINTK (KERN_DEBUG "%s: assign_addrs: aa5500ff87(%02x)\n",
+			 port->name, s);
+		return 0;
+	}
+
+	parport_write_data (port, 0x78); udelay (2);
+	last_dev = 0; /* We've just been speaking to a device, so we
+			 know there must be at least _one_ out there. */
+
+	for (daisy = 0; daisy < 4; daisy++) {
+		parport_write_data (port, daisy);
+		udelay (2);
+		parport_frob_control (port,
+				      PARPORT_CONTROL_STROBE,
+				      PARPORT_CONTROL_STROBE);
+		udelay (1);
+		parport_frob_control (port, PARPORT_CONTROL_STROBE, 0);
+		udelay (1);
+
+		if (last_dev)
+			/* No more devices. */
+			break;
+
+		last_dev = !(parport_read_status (port)
+			     & PARPORT_STATUS_BUSY);
+
+		add_dev (numdevs++, port, daisy);
+	}
+
+	parport_write_data (port, 0xff); udelay (2);
+	detected = numdevs - thisdev;
+	DPRINTK (KERN_DEBUG "%s: Found %d daisy-chained devices\n", port->name,
+		 detected);
+
+	/* Ask the new devices to introduce themselves. */
+	deviceid = kmalloc (1000, GFP_KERNEL);
+	if (!deviceid) return 0;
+
+	for (daisy = 0; thisdev < numdevs; thisdev++, daisy++)
+		parport_device_id (thisdev, deviceid, 1000);
+
+	kfree (deviceid);
+	return detected;
+}
