commit 7d411afe8444060454a53b1f9b70ee78b3e75ef1
Author: zhong jiang <zhongjiang@huawei.com>
Date:   Wed Dec 18 00:38:22 2019 +0530

    dma-heap: Make the symbol 'dma_heap_ioctl_cmds' static
    
    Fix the following sparse warning.
    
    drivers/dma-buf/dma-heap.c:109:14: warning: symbol 'dma_heap_ioctl_cmds'
    was not declared. Should it be static?
    
    Acked-by: Andrew F. Davis <afd@ti.com>
    Acked-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: zhong jiang <zhongjiang@huawei.com>
    Signed-off-by: Sumit Semwal <sumit.semwal@linaro.org>
     [sumits: rebased over IOCTL rename patches]
    Link: https://patchwork.freedesktop.org/patch/msgid/20191217190822.1969-1-sumit.semwal@linaro.org

diff --git a/drivers/dma-buf/dma-heap.c b/drivers/dma-buf/dma-heap.c
index 1886aee46131..afd22c9dbdcf 100644
--- a/drivers/dma-buf/dma-heap.c
+++ b/drivers/dma-buf/dma-heap.c
@@ -106,7 +106,7 @@ static long dma_heap_ioctl_allocate(struct file *file, void *data)
 	return 0;
 }
 
-unsigned int dma_heap_ioctl_cmds[] = {
+static unsigned int dma_heap_ioctl_cmds[] = {
 	DMA_HEAP_IOCTL_ALLOC,
 };
 

commit f9d3b2c600075d1f79efcd5cdb1718c2f554c0f9
Author: Colin Ian King <colin.king@canonical.com>
Date:   Mon Dec 16 16:10:59 2019 +0000

    dma-buf: fix resource leak on -ENOTTY error return path
    
    The -ENOTTY error return path does not free the allocated
    kdata as it returns directly. Fix this by returning via the
    error handling label err.
    
    Addresses-Coverity: ("Resource leak")
    Fixes: c02a81fba74f ("dma-buf: Add dma-buf heaps framework")
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Acked-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Sumit Semwal <sumit.semwal@linaro.org>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191216161059.269492-1-colin.king@canonical.com

diff --git a/drivers/dma-buf/dma-heap.c b/drivers/dma-buf/dma-heap.c
index a24721496114..1886aee46131 100644
--- a/drivers/dma-buf/dma-heap.c
+++ b/drivers/dma-buf/dma-heap.c
@@ -157,7 +157,8 @@ static long dma_heap_ioctl(struct file *file, unsigned int ucmd,
 		ret = dma_heap_ioctl_allocate(file, kdata);
 		break;
 	default:
-		return -ENOTTY;
+		ret = -ENOTTY;
+		goto err;
 	}
 
 	if (copy_to_user((void __user *)arg, kdata, out_size) != 0)

commit b3b4346544b571c96d46be615b9db69a601ce4c8
Author: Andrew F. Davis <afd@ti.com>
Date:   Mon Dec 16 08:34:04 2019 -0500

    dma-buf: heaps: Use _IOCTL_ for userspace IOCTL identifier
    
    This is more consistent with the DMA and DRM frameworks convention. This
    patch is only a name change, no logic is changed.
    
    Signed-off-by: Andrew F. Davis <afd@ti.com>
    Acked-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Sumit Semwal <sumit.semwal@linaro.org>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191216133405.1001-2-afd@ti.com

diff --git a/drivers/dma-buf/dma-heap.c b/drivers/dma-buf/dma-heap.c
index 4f04d104ae61..a24721496114 100644
--- a/drivers/dma-buf/dma-heap.c
+++ b/drivers/dma-buf/dma-heap.c
@@ -107,7 +107,7 @@ static long dma_heap_ioctl_allocate(struct file *file, void *data)
 }
 
 unsigned int dma_heap_ioctl_cmds[] = {
-	DMA_HEAP_IOC_ALLOC,
+	DMA_HEAP_IOCTL_ALLOC,
 };
 
 static long dma_heap_ioctl(struct file *file, unsigned int ucmd,
@@ -153,7 +153,7 @@ static long dma_heap_ioctl(struct file *file, unsigned int ucmd,
 		memset(kdata + in_size, 0, ksize - in_size);
 
 	switch (kcmd) {
-	case DMA_HEAP_IOC_ALLOC:
+	case DMA_HEAP_IOCTL_ALLOC:
 		ret = dma_heap_ioctl_allocate(file, kdata);
 		break;
 	default:

commit c02a81fba74fe3488ad6b08bfb5a1329005418f8
Author: Andrew F. Davis <afd@ti.com>
Date:   Tue Dec 3 17:26:37 2019 +0000

    dma-buf: Add dma-buf heaps framework
    
    This framework allows a unified userspace interface for dma-buf
    exporters, allowing userland to allocate specific types of memory
    for use in dma-buf sharing.
    
    Each heap is given its own device node, which a user can allocate
    a dma-buf fd from using the DMA_HEAP_IOC_ALLOC.
    
    This code is an evoluiton of the Android ION implementation,
    and a big thanks is due to its authors/maintainers over time
    for their effort:
      Rebecca Schultz Zavin, Colin Cross, Benjamin Gaignard,
      Laura Abbott, and many other contributors!
    
    Cc: Laura Abbott <labbott@redhat.com>
    Cc: Benjamin Gaignard <benjamin.gaignard@linaro.org>
    Cc: Sumit Semwal <sumit.semwal@linaro.org>
    Cc: Liam Mark <lmark@codeaurora.org>
    Cc: Pratik Patel <pratikp@codeaurora.org>
    Cc: Brian Starkey <Brian.Starkey@arm.com>
    Cc: Vincent Donnefort <Vincent.Donnefort@arm.com>
    Cc: Sudipto Paul <Sudipto.Paul@arm.com>
    Cc: Andrew F. Davis <afd@ti.com>
    Cc: Christoph Hellwig <hch@infradead.org>
    Cc: Chenbo Feng <fengc@google.com>
    Cc: Alistair Strachan <astrachan@google.com>
    Cc: Hridya Valsaraju <hridya@google.com>
    Cc: Sandeep Patil <sspatil@google.com>
    Cc: Hillf Danton <hdanton@sina.com>
    Cc: Dave Airlie <airlied@gmail.com>
    Cc: dri-devel@lists.freedesktop.org
    Reviewed-by: Brian Starkey <brian.starkey@arm.com>
    Acked-by: Sandeep Patil <sspatil@android.com>
    Signed-off-by: Andrew F. Davis <afd@ti.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Sumit Semwal <sumit.semwal@linaro.org>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191203172641.66642-2-john.stultz@linaro.org

diff --git a/drivers/dma-buf/dma-heap.c b/drivers/dma-buf/dma-heap.c
new file mode 100644
index 000000000000..4f04d104ae61
--- /dev/null
+++ b/drivers/dma-buf/dma-heap.c
@@ -0,0 +1,297 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Framework for userspace DMA-BUF allocations
+ *
+ * Copyright (C) 2011 Google, Inc.
+ * Copyright (C) 2019 Linaro Ltd.
+ */
+
+#include <linux/cdev.h>
+#include <linux/debugfs.h>
+#include <linux/device.h>
+#include <linux/dma-buf.h>
+#include <linux/err.h>
+#include <linux/xarray.h>
+#include <linux/list.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/syscalls.h>
+#include <linux/dma-heap.h>
+#include <uapi/linux/dma-heap.h>
+
+#define DEVNAME "dma_heap"
+
+#define NUM_HEAP_MINORS 128
+
+/**
+ * struct dma_heap - represents a dmabuf heap in the system
+ * @name:		used for debugging/device-node name
+ * @ops:		ops struct for this heap
+ * @heap_devt		heap device node
+ * @list		list head connecting to list of heaps
+ * @heap_cdev		heap char device
+ *
+ * Represents a heap of memory from which buffers can be made.
+ */
+struct dma_heap {
+	const char *name;
+	const struct dma_heap_ops *ops;
+	void *priv;
+	dev_t heap_devt;
+	struct list_head list;
+	struct cdev heap_cdev;
+};
+
+static LIST_HEAD(heap_list);
+static DEFINE_MUTEX(heap_list_lock);
+static dev_t dma_heap_devt;
+static struct class *dma_heap_class;
+static DEFINE_XARRAY_ALLOC(dma_heap_minors);
+
+static int dma_heap_buffer_alloc(struct dma_heap *heap, size_t len,
+				 unsigned int fd_flags,
+				 unsigned int heap_flags)
+{
+	/*
+	 * Allocations from all heaps have to begin
+	 * and end on page boundaries.
+	 */
+	len = PAGE_ALIGN(len);
+	if (!len)
+		return -EINVAL;
+
+	return heap->ops->allocate(heap, len, fd_flags, heap_flags);
+}
+
+static int dma_heap_open(struct inode *inode, struct file *file)
+{
+	struct dma_heap *heap;
+
+	heap = xa_load(&dma_heap_minors, iminor(inode));
+	if (!heap) {
+		pr_err("dma_heap: minor %d unknown.\n", iminor(inode));
+		return -ENODEV;
+	}
+
+	/* instance data as context */
+	file->private_data = heap;
+	nonseekable_open(inode, file);
+
+	return 0;
+}
+
+static long dma_heap_ioctl_allocate(struct file *file, void *data)
+{
+	struct dma_heap_allocation_data *heap_allocation = data;
+	struct dma_heap *heap = file->private_data;
+	int fd;
+
+	if (heap_allocation->fd)
+		return -EINVAL;
+
+	if (heap_allocation->fd_flags & ~DMA_HEAP_VALID_FD_FLAGS)
+		return -EINVAL;
+
+	if (heap_allocation->heap_flags & ~DMA_HEAP_VALID_HEAP_FLAGS)
+		return -EINVAL;
+
+	fd = dma_heap_buffer_alloc(heap, heap_allocation->len,
+				   heap_allocation->fd_flags,
+				   heap_allocation->heap_flags);
+	if (fd < 0)
+		return fd;
+
+	heap_allocation->fd = fd;
+
+	return 0;
+}
+
+unsigned int dma_heap_ioctl_cmds[] = {
+	DMA_HEAP_IOC_ALLOC,
+};
+
+static long dma_heap_ioctl(struct file *file, unsigned int ucmd,
+			   unsigned long arg)
+{
+	char stack_kdata[128];
+	char *kdata = stack_kdata;
+	unsigned int kcmd;
+	unsigned int in_size, out_size, drv_size, ksize;
+	int nr = _IOC_NR(ucmd);
+	int ret = 0;
+
+	if (nr >= ARRAY_SIZE(dma_heap_ioctl_cmds))
+		return -EINVAL;
+
+	/* Get the kernel ioctl cmd that matches */
+	kcmd = dma_heap_ioctl_cmds[nr];
+
+	/* Figure out the delta between user cmd size and kernel cmd size */
+	drv_size = _IOC_SIZE(kcmd);
+	out_size = _IOC_SIZE(ucmd);
+	in_size = out_size;
+	if ((ucmd & kcmd & IOC_IN) == 0)
+		in_size = 0;
+	if ((ucmd & kcmd & IOC_OUT) == 0)
+		out_size = 0;
+	ksize = max(max(in_size, out_size), drv_size);
+
+	/* If necessary, allocate buffer for ioctl argument */
+	if (ksize > sizeof(stack_kdata)) {
+		kdata = kmalloc(ksize, GFP_KERNEL);
+		if (!kdata)
+			return -ENOMEM;
+	}
+
+	if (copy_from_user(kdata, (void __user *)arg, in_size) != 0) {
+		ret = -EFAULT;
+		goto err;
+	}
+
+	/* zero out any difference between the kernel/user structure size */
+	if (ksize > in_size)
+		memset(kdata + in_size, 0, ksize - in_size);
+
+	switch (kcmd) {
+	case DMA_HEAP_IOC_ALLOC:
+		ret = dma_heap_ioctl_allocate(file, kdata);
+		break;
+	default:
+		return -ENOTTY;
+	}
+
+	if (copy_to_user((void __user *)arg, kdata, out_size) != 0)
+		ret = -EFAULT;
+err:
+	if (kdata != stack_kdata)
+		kfree(kdata);
+	return ret;
+}
+
+static const struct file_operations dma_heap_fops = {
+	.owner          = THIS_MODULE,
+	.open		= dma_heap_open,
+	.unlocked_ioctl = dma_heap_ioctl,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl	= dma_heap_ioctl,
+#endif
+};
+
+/**
+ * dma_heap_get_drvdata() - get per-subdriver data for the heap
+ * @heap: DMA-Heap to retrieve private data for
+ *
+ * Returns:
+ * The per-subdriver data for the heap.
+ */
+void *dma_heap_get_drvdata(struct dma_heap *heap)
+{
+	return heap->priv;
+}
+
+struct dma_heap *dma_heap_add(const struct dma_heap_export_info *exp_info)
+{
+	struct dma_heap *heap, *h, *err_ret;
+	struct device *dev_ret;
+	unsigned int minor;
+	int ret;
+
+	if (!exp_info->name || !strcmp(exp_info->name, "")) {
+		pr_err("dma_heap: Cannot add heap without a name\n");
+		return ERR_PTR(-EINVAL);
+	}
+
+	if (!exp_info->ops || !exp_info->ops->allocate) {
+		pr_err("dma_heap: Cannot add heap with invalid ops struct\n");
+		return ERR_PTR(-EINVAL);
+	}
+
+	/* check the name is unique */
+	mutex_lock(&heap_list_lock);
+	list_for_each_entry(h, &heap_list, list) {
+		if (!strcmp(h->name, exp_info->name)) {
+			mutex_unlock(&heap_list_lock);
+			pr_err("dma_heap: Already registered heap named %s\n",
+			       exp_info->name);
+			return ERR_PTR(-EINVAL);
+		}
+	}
+	mutex_unlock(&heap_list_lock);
+
+	heap = kzalloc(sizeof(*heap), GFP_KERNEL);
+	if (!heap)
+		return ERR_PTR(-ENOMEM);
+
+	heap->name = exp_info->name;
+	heap->ops = exp_info->ops;
+	heap->priv = exp_info->priv;
+
+	/* Find unused minor number */
+	ret = xa_alloc(&dma_heap_minors, &minor, heap,
+		       XA_LIMIT(0, NUM_HEAP_MINORS - 1), GFP_KERNEL);
+	if (ret < 0) {
+		pr_err("dma_heap: Unable to get minor number for heap\n");
+		err_ret = ERR_PTR(ret);
+		goto err0;
+	}
+
+	/* Create device */
+	heap->heap_devt = MKDEV(MAJOR(dma_heap_devt), minor);
+
+	cdev_init(&heap->heap_cdev, &dma_heap_fops);
+	ret = cdev_add(&heap->heap_cdev, heap->heap_devt, 1);
+	if (ret < 0) {
+		pr_err("dma_heap: Unable to add char device\n");
+		err_ret = ERR_PTR(ret);
+		goto err1;
+	}
+
+	dev_ret = device_create(dma_heap_class,
+				NULL,
+				heap->heap_devt,
+				NULL,
+				heap->name);
+	if (IS_ERR(dev_ret)) {
+		pr_err("dma_heap: Unable to create device\n");
+		err_ret = ERR_CAST(dev_ret);
+		goto err2;
+	}
+	/* Add heap to the list */
+	mutex_lock(&heap_list_lock);
+	list_add(&heap->list, &heap_list);
+	mutex_unlock(&heap_list_lock);
+
+	return heap;
+
+err2:
+	cdev_del(&heap->heap_cdev);
+err1:
+	xa_erase(&dma_heap_minors, minor);
+err0:
+	kfree(heap);
+	return err_ret;
+}
+
+static char *dma_heap_devnode(struct device *dev, umode_t *mode)
+{
+	return kasprintf(GFP_KERNEL, "dma_heap/%s", dev_name(dev));
+}
+
+static int dma_heap_init(void)
+{
+	int ret;
+
+	ret = alloc_chrdev_region(&dma_heap_devt, 0, NUM_HEAP_MINORS, DEVNAME);
+	if (ret)
+		return ret;
+
+	dma_heap_class = class_create(THIS_MODULE, DEVNAME);
+	if (IS_ERR(dma_heap_class)) {
+		unregister_chrdev_region(dma_heap_devt, NUM_HEAP_MINORS);
+		return PTR_ERR(dma_heap_class);
+	}
+	dma_heap_class->devnode = dma_heap_devnode;
+
+	return 0;
+}
+subsys_initcall(dma_heap_init);

commit fae7d7d5f374eadbb0b5dd31b39162e7176e9c3d
Author: Sean Paul <seanpaul@chromium.org>
Date:   Wed Oct 30 16:29:54 2019 -0400

    Revert "dma-buf: Add dma-buf heaps framework"
    
    This reverts commit a69b0e855d3fd278ff6f09a23e1edf929538e304.
    
    This patchset doesn't meet the UAPI requirements set out in [1] for the DRM
    subsystem. Once the userspace component is reviewed and ready for merge
    we can try again.
    
    [1]- https://01.org/linuxgraphics/gfx-docs/drm/gpu/drm-uapi.html#open-source-userspace-requirements
    
    Fixes: a69b0e855d3f ("dma-buf: Add dma-buf heaps framework")
    Cc: Laura Abbott <labbott@redhat.com>
    Cc: Benjamin Gaignard <benjamin.gaignard@linaro.org>
    Cc: Sumit Semwal <sumit.semwal@linaro.org>
    Cc: Liam Mark <lmark@codeaurora.org>
    Cc: Pratik Patel <pratikp@codeaurora.org>
    Cc: Brian Starkey <Brian.Starkey@arm.com>
    Cc: Vincent Donnefort <Vincent.Donnefort@arm.com>
    Cc: Sudipto Paul <Sudipto.Paul@arm.com>
    Cc: Andrew F. Davis <afd@ti.com>
    Cc: Christoph Hellwig <hch@infradead.org>
    Cc: Chenbo Feng <fengc@google.com>
    Cc: Alistair Strachan <astrachan@google.com>
    Cc: Hridya Valsaraju <hridya@google.com>
    Cc: Hillf Danton <hdanton@sina.com>
    Cc: dri-devel@lists.freedesktop.org
    Cc: Brian Starkey <brian.starkey@arm.com>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Rob Herring <robh@kernel.org>
    Cc: Jonathan Cameron <Jonathan.Cameron@huawei.com>
    Cc: "Paul E. McKenney" <paulmck@linux.ibm.com>
    Cc: Sean Paul <seanpaul@chromium.org>
    Cc: "Andrew F. Davis" <afd@ti.com>
    Cc: linux-media@vger.kernel.org
    Cc: linaro-mm-sig@lists.linaro.org
    Acked-by: David Airlie <airlied@linux.ie>
    Signed-off-by: Sean Paul <sean@poorly.run>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191030203003.101156-6-sean@poorly.run

diff --git a/drivers/dma-buf/dma-heap.c b/drivers/dma-buf/dma-heap.c
deleted file mode 100644
index 9a41b73e54b4..000000000000
--- a/drivers/dma-buf/dma-heap.c
+++ /dev/null
@@ -1,269 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Framework for userspace DMA-BUF allocations
- *
- * Copyright (C) 2011 Google, Inc.
- * Copyright (C) 2019 Linaro Ltd.
- */
-
-#include <linux/cdev.h>
-#include <linux/debugfs.h>
-#include <linux/device.h>
-#include <linux/dma-buf.h>
-#include <linux/err.h>
-#include <linux/xarray.h>
-#include <linux/list.h>
-#include <linux/slab.h>
-#include <linux/uaccess.h>
-#include <linux/syscalls.h>
-#include <linux/dma-heap.h>
-#include <uapi/linux/dma-heap.h>
-
-#define DEVNAME "dma_heap"
-
-#define NUM_HEAP_MINORS 128
-
-/**
- * struct dma_heap - represents a dmabuf heap in the system
- * @name:		used for debugging/device-node name
- * @ops:		ops struct for this heap
- * @minor		minor number of this heap device
- * @heap_devt		heap device node
- * @heap_cdev		heap char device
- *
- * Represents a heap of memory from which buffers can be made.
- */
-struct dma_heap {
-	const char *name;
-	const struct dma_heap_ops *ops;
-	void *priv;
-	unsigned int minor;
-	dev_t heap_devt;
-	struct list_head list;
-	struct cdev heap_cdev;
-};
-
-static LIST_HEAD(heap_list);
-static DEFINE_MUTEX(heap_list_lock);
-static dev_t dma_heap_devt;
-static struct class *dma_heap_class;
-static DEFINE_XARRAY_ALLOC(dma_heap_minors);
-
-static int dma_heap_buffer_alloc(struct dma_heap *heap, size_t len,
-				 unsigned int fd_flags,
-				 unsigned int heap_flags)
-{
-	/*
-	 * Allocations from all heaps have to begin
-	 * and end on page boundaries.
-	 */
-	len = PAGE_ALIGN(len);
-	if (!len)
-		return -EINVAL;
-
-	return heap->ops->allocate(heap, len, fd_flags, heap_flags);
-}
-
-static int dma_heap_open(struct inode *inode, struct file *file)
-{
-	struct dma_heap *heap;
-
-	heap = xa_load(&dma_heap_minors, iminor(inode));
-	if (!heap) {
-		pr_err("dma_heap: minor %d unknown.\n", iminor(inode));
-		return -ENODEV;
-	}
-
-	/* instance data as context */
-	file->private_data = heap;
-	nonseekable_open(inode, file);
-
-	return 0;
-}
-
-static long dma_heap_ioctl_allocate(struct file *file, unsigned long arg)
-{
-	struct dma_heap_allocation_data heap_allocation;
-	struct dma_heap *heap = file->private_data;
-	int fd;
-
-	if (copy_from_user(&heap_allocation, (void __user *)arg,
-			   sizeof(heap_allocation)))
-		return -EFAULT;
-
-	if (heap_allocation.fd ||
-	    heap_allocation.reserved0 ||
-	    heap_allocation.reserved1) {
-		pr_warn_once("dma_heap: ioctl data not valid\n");
-		return -EINVAL;
-	}
-
-	if (heap_allocation.fd_flags & ~DMA_HEAP_VALID_FD_FLAGS) {
-		pr_warn_once("dma_heap: fd_flags has invalid or unsupported flags set\n");
-		return -EINVAL;
-	}
-
-	if (heap_allocation.heap_flags & ~DMA_HEAP_VALID_HEAP_FLAGS) {
-		pr_warn_once("dma_heap: heap flags has invalid or unsupported flags set\n");
-		return -EINVAL;
-	}
-
-	fd = dma_heap_buffer_alloc(heap, heap_allocation.len,
-				   heap_allocation.fd_flags,
-				   heap_allocation.heap_flags);
-	if (fd < 0)
-		return fd;
-
-	heap_allocation.fd = fd;
-
-	if (copy_to_user((void __user *)arg, &heap_allocation,
-			 sizeof(heap_allocation))) {
-		ksys_close(fd);
-		return -EFAULT;
-	}
-
-	return 0;
-}
-
-static long dma_heap_ioctl(struct file *file, unsigned int cmd,
-			   unsigned long arg)
-{
-	int ret = 0;
-
-	switch (cmd) {
-	case DMA_HEAP_IOC_ALLOC:
-		ret = dma_heap_ioctl_allocate(file, arg);
-		break;
-	default:
-		return -ENOTTY;
-	}
-
-	return ret;
-}
-
-static const struct file_operations dma_heap_fops = {
-	.owner          = THIS_MODULE,
-	.open		= dma_heap_open,
-	.unlocked_ioctl = dma_heap_ioctl,
-#ifdef CONFIG_COMPAT
-	.compat_ioctl	= dma_heap_ioctl,
-#endif
-};
-
-/**
- * dma_heap_get_drvdata() - get per-subdriver data for the heap
- * @heap: DMA-Heap to retrieve private data for
- *
- * Returns:
- * The per-subdriver data for the heap.
- */
-void *dma_heap_get_drvdata(struct dma_heap *heap)
-{
-	return heap->priv;
-}
-
-struct dma_heap *dma_heap_add(const struct dma_heap_export_info *exp_info)
-{
-	struct dma_heap *heap, *h, *err_ret;
-	struct device *dev_ret;
-	int ret;
-
-	if (!exp_info->name || !strcmp(exp_info->name, "")) {
-		pr_err("dma_heap: Cannot add heap without a name\n");
-		return ERR_PTR(-EINVAL);
-	}
-
-	if (!exp_info->ops || !exp_info->ops->allocate) {
-		pr_err("dma_heap: Cannot add heap with invalid ops struct\n");
-		return ERR_PTR(-EINVAL);
-	}
-
-	/* check the name is unique */
-	mutex_lock(&heap_list_lock);
-	list_for_each_entry(h, &heap_list, list) {
-		if (!strcmp(h->name, exp_info->name)) {
-			mutex_unlock(&heap_list_lock);
-			pr_err("dma_heap: Already registered heap named %s\n",
-			       exp_info->name);
-			return ERR_PTR(-EINVAL);
-		}
-	}
-	mutex_unlock(&heap_list_lock);
-
-	heap = kzalloc(sizeof(*heap), GFP_KERNEL);
-	if (!heap)
-		return ERR_PTR(-ENOMEM);
-
-	heap->name = exp_info->name;
-	heap->ops = exp_info->ops;
-	heap->priv = exp_info->priv;
-
-	/* Find unused minor number */
-	ret = xa_alloc(&dma_heap_minors, &heap->minor, heap,
-		       XA_LIMIT(0, NUM_HEAP_MINORS - 1), GFP_KERNEL);
-	if (ret < 0) {
-		pr_err("dma_heap: Unable to get minor number for heap\n");
-		err_ret = ERR_PTR(ret);
-		goto err0;
-	}
-
-	/* Create device */
-	heap->heap_devt = MKDEV(MAJOR(dma_heap_devt), heap->minor);
-
-	cdev_init(&heap->heap_cdev, &dma_heap_fops);
-	ret = cdev_add(&heap->heap_cdev, heap->heap_devt, 1);
-	if (ret < 0) {
-		pr_err("dma_heap: Unable to add char device\n");
-		err_ret = ERR_PTR(ret);
-		goto err1;
-	}
-
-	dev_ret = device_create(dma_heap_class,
-				NULL,
-				heap->heap_devt,
-				NULL,
-				heap->name);
-	if (IS_ERR(dev_ret)) {
-		pr_err("dma_heap: Unable to create device\n");
-		err_ret = ERR_CAST(dev_ret);
-		goto err2;
-	}
-	/* Add heap to the list */
-	mutex_lock(&heap_list_lock);
-	list_add(&heap->list, &heap_list);
-	mutex_unlock(&heap_list_lock);
-
-	return heap;
-
-err2:
-	cdev_del(&heap->heap_cdev);
-err1:
-	xa_erase(&dma_heap_minors, heap->minor);
-err0:
-	kfree(heap);
-	return err_ret;
-}
-
-static char *dma_heap_devnode(struct device *dev, umode_t *mode)
-{
-	return kasprintf(GFP_KERNEL, "dma_heap/%s", dev_name(dev));
-}
-
-static int dma_heap_init(void)
-{
-	int ret;
-
-	ret = alloc_chrdev_region(&dma_heap_devt, 0, NUM_HEAP_MINORS, DEVNAME);
-	if (ret)
-		return ret;
-
-	dma_heap_class = class_create(THIS_MODULE, DEVNAME);
-	if (IS_ERR(dma_heap_class)) {
-		unregister_chrdev_region(dma_heap_devt, NUM_HEAP_MINORS);
-		return PTR_ERR(dma_heap_class);
-	}
-	dma_heap_class->devnode = dma_heap_devnode;
-
-	return 0;
-}
-subsys_initcall(dma_heap_init);

commit a69b0e855d3fd278ff6f09a23e1edf929538e304
Author: Andrew F. Davis <afd@ti.com>
Date:   Mon Oct 21 19:03:06 2019 +0000

    dma-buf: Add dma-buf heaps framework
    
    This framework allows a unified userspace interface for dma-buf
    exporters, allowing userland to allocate specific types of memory
    for use in dma-buf sharing.
    
    Each heap is given its own device node, which a user can allocate
    a dma-buf fd from using the DMA_HEAP_IOC_ALLOC.
    
    This code is an evoluiton of the Android ION implementation,
    and a big thanks is due to its authors/maintainers over time
    for their effort:
      Rebecca Schultz Zavin, Colin Cross, Benjamin Gaignard,
      Laura Abbott, and many other contributors!
    
    Cc: Laura Abbott <labbott@redhat.com>
    Cc: Benjamin Gaignard <benjamin.gaignard@linaro.org>
    Cc: Sumit Semwal <sumit.semwal@linaro.org>
    Cc: Liam Mark <lmark@codeaurora.org>
    Cc: Pratik Patel <pratikp@codeaurora.org>
    Cc: Brian Starkey <Brian.Starkey@arm.com>
    Cc: Vincent Donnefort <Vincent.Donnefort@arm.com>
    Cc: Sudipto Paul <Sudipto.Paul@arm.com>
    Cc: Andrew F. Davis <afd@ti.com>
    Cc: Christoph Hellwig <hch@infradead.org>
    Cc: Chenbo Feng <fengc@google.com>
    Cc: Alistair Strachan <astrachan@google.com>
    Cc: Hridya Valsaraju <hridya@google.com>
    Cc: Hillf Danton <hdanton@sina.com>
    Cc: dri-devel@lists.freedesktop.org
    Reviewed-by: Benjamin Gaignard <benjamin.gaignard@linaro.org>
    Reviewed-by: Brian Starkey <brian.starkey@arm.com>
    Acked-by: Laura Abbott <labbott@redhat.com>
    Tested-by: Ayan Kumar Halder <ayan.halder@arm.com>
    Signed-off-by: Andrew F. Davis <afd@ti.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Sumit Semwal <sumit.semwal@linaro.org>
    Link: https://patchwork.freedesktop.org/patch/msgid/20191021190310.85221-2-john.stultz@linaro.org

diff --git a/drivers/dma-buf/dma-heap.c b/drivers/dma-buf/dma-heap.c
new file mode 100644
index 000000000000..9a41b73e54b4
--- /dev/null
+++ b/drivers/dma-buf/dma-heap.c
@@ -0,0 +1,269 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Framework for userspace DMA-BUF allocations
+ *
+ * Copyright (C) 2011 Google, Inc.
+ * Copyright (C) 2019 Linaro Ltd.
+ */
+
+#include <linux/cdev.h>
+#include <linux/debugfs.h>
+#include <linux/device.h>
+#include <linux/dma-buf.h>
+#include <linux/err.h>
+#include <linux/xarray.h>
+#include <linux/list.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/syscalls.h>
+#include <linux/dma-heap.h>
+#include <uapi/linux/dma-heap.h>
+
+#define DEVNAME "dma_heap"
+
+#define NUM_HEAP_MINORS 128
+
+/**
+ * struct dma_heap - represents a dmabuf heap in the system
+ * @name:		used for debugging/device-node name
+ * @ops:		ops struct for this heap
+ * @minor		minor number of this heap device
+ * @heap_devt		heap device node
+ * @heap_cdev		heap char device
+ *
+ * Represents a heap of memory from which buffers can be made.
+ */
+struct dma_heap {
+	const char *name;
+	const struct dma_heap_ops *ops;
+	void *priv;
+	unsigned int minor;
+	dev_t heap_devt;
+	struct list_head list;
+	struct cdev heap_cdev;
+};
+
+static LIST_HEAD(heap_list);
+static DEFINE_MUTEX(heap_list_lock);
+static dev_t dma_heap_devt;
+static struct class *dma_heap_class;
+static DEFINE_XARRAY_ALLOC(dma_heap_minors);
+
+static int dma_heap_buffer_alloc(struct dma_heap *heap, size_t len,
+				 unsigned int fd_flags,
+				 unsigned int heap_flags)
+{
+	/*
+	 * Allocations from all heaps have to begin
+	 * and end on page boundaries.
+	 */
+	len = PAGE_ALIGN(len);
+	if (!len)
+		return -EINVAL;
+
+	return heap->ops->allocate(heap, len, fd_flags, heap_flags);
+}
+
+static int dma_heap_open(struct inode *inode, struct file *file)
+{
+	struct dma_heap *heap;
+
+	heap = xa_load(&dma_heap_minors, iminor(inode));
+	if (!heap) {
+		pr_err("dma_heap: minor %d unknown.\n", iminor(inode));
+		return -ENODEV;
+	}
+
+	/* instance data as context */
+	file->private_data = heap;
+	nonseekable_open(inode, file);
+
+	return 0;
+}
+
+static long dma_heap_ioctl_allocate(struct file *file, unsigned long arg)
+{
+	struct dma_heap_allocation_data heap_allocation;
+	struct dma_heap *heap = file->private_data;
+	int fd;
+
+	if (copy_from_user(&heap_allocation, (void __user *)arg,
+			   sizeof(heap_allocation)))
+		return -EFAULT;
+
+	if (heap_allocation.fd ||
+	    heap_allocation.reserved0 ||
+	    heap_allocation.reserved1) {
+		pr_warn_once("dma_heap: ioctl data not valid\n");
+		return -EINVAL;
+	}
+
+	if (heap_allocation.fd_flags & ~DMA_HEAP_VALID_FD_FLAGS) {
+		pr_warn_once("dma_heap: fd_flags has invalid or unsupported flags set\n");
+		return -EINVAL;
+	}
+
+	if (heap_allocation.heap_flags & ~DMA_HEAP_VALID_HEAP_FLAGS) {
+		pr_warn_once("dma_heap: heap flags has invalid or unsupported flags set\n");
+		return -EINVAL;
+	}
+
+	fd = dma_heap_buffer_alloc(heap, heap_allocation.len,
+				   heap_allocation.fd_flags,
+				   heap_allocation.heap_flags);
+	if (fd < 0)
+		return fd;
+
+	heap_allocation.fd = fd;
+
+	if (copy_to_user((void __user *)arg, &heap_allocation,
+			 sizeof(heap_allocation))) {
+		ksys_close(fd);
+		return -EFAULT;
+	}
+
+	return 0;
+}
+
+static long dma_heap_ioctl(struct file *file, unsigned int cmd,
+			   unsigned long arg)
+{
+	int ret = 0;
+
+	switch (cmd) {
+	case DMA_HEAP_IOC_ALLOC:
+		ret = dma_heap_ioctl_allocate(file, arg);
+		break;
+	default:
+		return -ENOTTY;
+	}
+
+	return ret;
+}
+
+static const struct file_operations dma_heap_fops = {
+	.owner          = THIS_MODULE,
+	.open		= dma_heap_open,
+	.unlocked_ioctl = dma_heap_ioctl,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl	= dma_heap_ioctl,
+#endif
+};
+
+/**
+ * dma_heap_get_drvdata() - get per-subdriver data for the heap
+ * @heap: DMA-Heap to retrieve private data for
+ *
+ * Returns:
+ * The per-subdriver data for the heap.
+ */
+void *dma_heap_get_drvdata(struct dma_heap *heap)
+{
+	return heap->priv;
+}
+
+struct dma_heap *dma_heap_add(const struct dma_heap_export_info *exp_info)
+{
+	struct dma_heap *heap, *h, *err_ret;
+	struct device *dev_ret;
+	int ret;
+
+	if (!exp_info->name || !strcmp(exp_info->name, "")) {
+		pr_err("dma_heap: Cannot add heap without a name\n");
+		return ERR_PTR(-EINVAL);
+	}
+
+	if (!exp_info->ops || !exp_info->ops->allocate) {
+		pr_err("dma_heap: Cannot add heap with invalid ops struct\n");
+		return ERR_PTR(-EINVAL);
+	}
+
+	/* check the name is unique */
+	mutex_lock(&heap_list_lock);
+	list_for_each_entry(h, &heap_list, list) {
+		if (!strcmp(h->name, exp_info->name)) {
+			mutex_unlock(&heap_list_lock);
+			pr_err("dma_heap: Already registered heap named %s\n",
+			       exp_info->name);
+			return ERR_PTR(-EINVAL);
+		}
+	}
+	mutex_unlock(&heap_list_lock);
+
+	heap = kzalloc(sizeof(*heap), GFP_KERNEL);
+	if (!heap)
+		return ERR_PTR(-ENOMEM);
+
+	heap->name = exp_info->name;
+	heap->ops = exp_info->ops;
+	heap->priv = exp_info->priv;
+
+	/* Find unused minor number */
+	ret = xa_alloc(&dma_heap_minors, &heap->minor, heap,
+		       XA_LIMIT(0, NUM_HEAP_MINORS - 1), GFP_KERNEL);
+	if (ret < 0) {
+		pr_err("dma_heap: Unable to get minor number for heap\n");
+		err_ret = ERR_PTR(ret);
+		goto err0;
+	}
+
+	/* Create device */
+	heap->heap_devt = MKDEV(MAJOR(dma_heap_devt), heap->minor);
+
+	cdev_init(&heap->heap_cdev, &dma_heap_fops);
+	ret = cdev_add(&heap->heap_cdev, heap->heap_devt, 1);
+	if (ret < 0) {
+		pr_err("dma_heap: Unable to add char device\n");
+		err_ret = ERR_PTR(ret);
+		goto err1;
+	}
+
+	dev_ret = device_create(dma_heap_class,
+				NULL,
+				heap->heap_devt,
+				NULL,
+				heap->name);
+	if (IS_ERR(dev_ret)) {
+		pr_err("dma_heap: Unable to create device\n");
+		err_ret = ERR_CAST(dev_ret);
+		goto err2;
+	}
+	/* Add heap to the list */
+	mutex_lock(&heap_list_lock);
+	list_add(&heap->list, &heap_list);
+	mutex_unlock(&heap_list_lock);
+
+	return heap;
+
+err2:
+	cdev_del(&heap->heap_cdev);
+err1:
+	xa_erase(&dma_heap_minors, heap->minor);
+err0:
+	kfree(heap);
+	return err_ret;
+}
+
+static char *dma_heap_devnode(struct device *dev, umode_t *mode)
+{
+	return kasprintf(GFP_KERNEL, "dma_heap/%s", dev_name(dev));
+}
+
+static int dma_heap_init(void)
+{
+	int ret;
+
+	ret = alloc_chrdev_region(&dma_heap_devt, 0, NUM_HEAP_MINORS, DEVNAME);
+	if (ret)
+		return ret;
+
+	dma_heap_class = class_create(THIS_MODULE, DEVNAME);
+	if (IS_ERR(dma_heap_class)) {
+		unregister_chrdev_region(dma_heap_devt, NUM_HEAP_MINORS);
+		return PTR_ERR(dma_heap_class);
+	}
+	dma_heap_class->devnode = dma_heap_devnode;
+
+	return 0;
+}
+subsys_initcall(dma_heap_init);
