commit cb596aee8842c87605ea1a9062af2ab435a742d4
Author: Tomer Tayar <ttayar@habana.ai>
Date:   Thu Oct 3 15:22:36 2019 +0000

    habanalabs: Add a new H/W queue type
    
    This patch adds a support for a new H/W queue type.
    This type of queue is for DMA and compute engines jobs, for which
    completion notification are sent by H/W.
    Command buffer for this queue can be created either through the CB
    IOCTL and using the retrieved CB handle, or by preparing a buffer on the
    host or device SRAM/DRAM, and using the device address to that buffer.
    The patch includes the handling of the 2 options, as well as the
    initialization of the H/W queue and its jobs scheduling.
    
    Signed-off-by: Tomer Tayar <ttayar@habana.ai>
    Reviewed-by: Oded Gabbay <oded.gabbay@gmail.com>
    Signed-off-by: Oded Gabbay <oded.gabbay@gmail.com>

diff --git a/drivers/misc/habanalabs/include/qman_if.h b/drivers/misc/habanalabs/include/qman_if.h
index bf59bbe27fdc..0fdb49188ed7 100644
--- a/drivers/misc/habanalabs/include/qman_if.h
+++ b/drivers/misc/habanalabs/include/qman_if.h
@@ -23,6 +23,8 @@ struct hl_bd {
 #define HL_BD_SIZE			sizeof(struct hl_bd)
 
 /*
+ * S/W CTL FIELDS.
+ *
  * BD_CTL_REPEAT_VALID tells the CP whether the repeat field in the BD CTL is
  * valid. 1 means the repeat field is valid, 0 means not-valid,
  * i.e. repeat == 1
@@ -33,6 +35,16 @@ struct hl_bd {
 #define BD_CTL_SHADOW_INDEX_SHIFT	0
 #define BD_CTL_SHADOW_INDEX_MASK	0x00000FFF
 
+/*
+ * H/W CTL FIELDS
+ */
+
+#define BD_CTL_COMP_OFFSET_SHIFT	16
+#define BD_CTL_COMP_OFFSET_MASK		0x00FF0000
+
+#define BD_CTL_COMP_DATA_SHIFT		0
+#define BD_CTL_COMP_DATA_MASK		0x0000FFFF
+
 /*
  * COMPLETION QUEUE
  */

commit 9494a8dd8d22cbff8ce358aaa223fffe1b070cb0
Author: Oded Gabbay <oded.gabbay@gmail.com>
Date:   Sat Feb 16 00:39:17 2019 +0200

    habanalabs: add h/w queues module
    
    This patch adds the H/W queues module and the code to initialize Goya's
    various compute and DMA engines and their queues.
    
    Goya has 5 DMA channels, 8 TPC engines and a single MME engine. For each
    channel/engine, there is a H/W queue logic which is used to pass commands
    from the user to the H/W. That logic is called QMAN.
    
    There are two types of QMANs: external and internal. The DMA QMANs are
    considered external while the TPC and MME QMANs are considered internal.
    For each external queue there is a completion queue, which is located on
    the Host memory.
    
    The differences between external and internal QMANs are:
    
    1. The location of the queue's memory. External QMANs are located on the
       Host memory while internal QMANs are located on the on-chip memory.
    
    2. The external QMAN write an entry to a completion queue and sends an
       MSI-X interrupt upon completion of a command buffer that was given to
       it. The internal QMAN doesn't do that.
    
    Reviewed-by: Mike Rapoport <rppt@linux.ibm.com>
    Signed-off-by: Oded Gabbay <oded.gabbay@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/habanalabs/include/qman_if.h b/drivers/misc/habanalabs/include/qman_if.h
new file mode 100644
index 000000000000..bf59bbe27fdc
--- /dev/null
+++ b/drivers/misc/habanalabs/include/qman_if.h
@@ -0,0 +1,56 @@
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * Copyright 2016-2018 HabanaLabs, Ltd.
+ * All Rights Reserved.
+ *
+ */
+
+#ifndef QMAN_IF_H
+#define QMAN_IF_H
+
+#include <linux/types.h>
+
+/*
+ * PRIMARY QUEUE
+ */
+
+struct hl_bd {
+	__le64	ptr;
+	__le32	len;
+	__le32	ctl;
+};
+
+#define HL_BD_SIZE			sizeof(struct hl_bd)
+
+/*
+ * BD_CTL_REPEAT_VALID tells the CP whether the repeat field in the BD CTL is
+ * valid. 1 means the repeat field is valid, 0 means not-valid,
+ * i.e. repeat == 1
+ */
+#define BD_CTL_REPEAT_VALID_SHIFT	24
+#define BD_CTL_REPEAT_VALID_MASK	0x01000000
+
+#define BD_CTL_SHADOW_INDEX_SHIFT	0
+#define BD_CTL_SHADOW_INDEX_MASK	0x00000FFF
+
+/*
+ * COMPLETION QUEUE
+ */
+
+struct hl_cq_entry {
+	__le32	data;
+};
+
+#define HL_CQ_ENTRY_SIZE		sizeof(struct hl_cq_entry)
+
+#define CQ_ENTRY_READY_SHIFT			31
+#define CQ_ENTRY_READY_MASK			0x80000000
+
+#define CQ_ENTRY_SHADOW_INDEX_VALID_SHIFT	30
+#define CQ_ENTRY_SHADOW_INDEX_VALID_MASK	0x40000000
+
+#define CQ_ENTRY_SHADOW_INDEX_SHIFT		BD_CTL_SHADOW_INDEX_SHIFT
+#define CQ_ENTRY_SHADOW_INDEX_MASK		BD_CTL_SHADOW_INDEX_MASK
+
+
+#endif /* QMAN_IF_H */
