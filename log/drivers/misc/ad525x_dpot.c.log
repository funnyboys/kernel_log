commit 80503b23b23b5b2228d8750b786eb182f2fa28d2
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri May 24 12:04:09 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 149
    
    Based on 1 normalized pattern(s):
    
      licensed under the gpl 2 or later
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 82 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190524100845.150836982@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/ad525x_dpot.c b/drivers/misc/ad525x_dpot.c
index 1f6d008e0036..ccce3226a571 100644
--- a/drivers/misc/ad525x_dpot.c
+++ b/drivers/misc/ad525x_dpot.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * ad525x_dpot: Driver for the Analog Devices digital potentiometers
  * Copyright (c) 2009-2010 Analog Devices, Inc.
@@ -65,8 +66,6 @@
  *
  * derived from ad5252.c
  * Copyright (c) 2006-2011 Michael Hennerich <michael.hennerich@analog.com>
- *
- * Licensed under the GPL-2 or later.
  */
 
 #include <linux/module.h>

commit 068ad41ec565357f4c37e52d4026c896bdeaec56
Author: Colin Ian King <colin.king@canonical.com>
Date:   Fri Dec 21 22:39:44 2018 +0000

    drivers: misc: ad525x_dpot: clean indentation issue, remove tabs
    
    There is a hunk of code in a case statement that is indented one level
    too deeply, fix this by removing extra tabs. Also remove one empty line.
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/ad525x_dpot.c b/drivers/misc/ad525x_dpot.c
index a0afadefcc49..1f6d008e0036 100644
--- a/drivers/misc/ad525x_dpot.c
+++ b/drivers/misc/ad525x_dpot.c
@@ -202,22 +202,20 @@ static s32 dpot_read_i2c(struct dpot_data *dpot, u8 reg)
 		return dpot_read_r8d8(dpot, ctrl);
 	case DPOT_UID(AD5272_ID):
 	case DPOT_UID(AD5274_ID):
-			dpot_write_r8d8(dpot,
+		dpot_write_r8d8(dpot,
 				(DPOT_AD5270_1_2_4_READ_RDAC << 2), 0);
 
-			value = dpot_read_r8d16(dpot,
-				DPOT_AD5270_1_2_4_RDAC << 2);
-
-			if (value < 0)
-				return value;
-			/*
-			 * AD5272/AD5274 returns high byte first, however
-			 * underling smbus expects low byte first.
-			 */
-			value = swab16(value);
+		value = dpot_read_r8d16(dpot, DPOT_AD5270_1_2_4_RDAC << 2);
+		if (value < 0)
+			return value;
+		/*
+		 * AD5272/AD5274 returns high byte first, however
+		 * underling smbus expects low byte first.
+		 */
+		value = swab16(value);
 
-			if (dpot->uid == DPOT_UID(AD5274_ID))
-				value = value >> 2;
+		if (dpot->uid == DPOT_UID(AD5274_ID))
+			value = value >> 2;
 		return value;
 	default:
 		if ((reg & DPOT_REG_TOL) || (dpot->max_pos > 256))

commit dbd71398bdd44a54734eff6610ee04371047cecc
Author: Michael Hennerich <michael.hennerich@analog.com>
Date:   Tue Aug 14 13:30:18 2018 +0200

    drivers: misc: ad525x_dpot: Update MODULE AUTHOR email address
    
    no functional changes
    
    Signed-off-by: Michael Hennerich <michael.hennerich@analog.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/ad525x_dpot.c b/drivers/misc/ad525x_dpot.c
index bc591b7168db..a0afadefcc49 100644
--- a/drivers/misc/ad525x_dpot.c
+++ b/drivers/misc/ad525x_dpot.c
@@ -1,7 +1,7 @@
 /*
  * ad525x_dpot: Driver for the Analog Devices digital potentiometers
  * Copyright (c) 2009-2010 Analog Devices, Inc.
- * Author: Michael Hennerich <hennerich@blackfin.uclinux.org>
+ * Author: Michael Hennerich <michael.hennerich@analog.com>
  *
  * DEVID		#Wipers		#Positions	Resistor Options (kOhm)
  * AD5258		1		64		1, 10, 50, 100
@@ -64,7 +64,7 @@
  * Author: Chris Verges <chrisv@cyberswitching.com>
  *
  * derived from ad5252.c
- * Copyright (c) 2006-2011 Michael Hennerich <hennerich@blackfin.uclinux.org>
+ * Copyright (c) 2006-2011 Michael Hennerich <michael.hennerich@analog.com>
  *
  * Licensed under the GPL-2 or later.
  */
@@ -760,6 +760,6 @@ EXPORT_SYMBOL(ad_dpot_remove);
 
 
 MODULE_AUTHOR("Chris Verges <chrisv@cyberswitching.com>, "
-	      "Michael Hennerich <hennerich@blackfin.uclinux.org>");
+	      "Michael Hennerich <michael.hennerich@analog.com>");
 MODULE_DESCRIPTION("Digital potentiometer driver");
 MODULE_LICENSE("GPL");

commit 12eaa7a1f33cc4e231a847bd0e515a5d1552e30a
Author: Dhaval Shah <dhaval.shah@softnautics.com>
Date:   Fri Dec 8 13:43:05 2017 +0530

    misc: ad525x_dpot: macros should not use a trailing semicolon
    
    Resolved all the macros should not use a trailing semicolon
    checkpatch warnings. Issue found by checkpatch.
    
    Signed-off-by: Dhaval Shah <dhaval.shah@softnautics.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/ad525x_dpot.c b/drivers/misc/ad525x_dpot.c
index 577f5e76c8a8..bc591b7168db 100644
--- a/drivers/misc/ad525x_dpot.c
+++ b/drivers/misc/ad525x_dpot.c
@@ -515,11 +515,11 @@ set_##_name(struct device *dev, \
 #define DPOT_DEVICE_SHOW_SET(name, reg) \
 DPOT_DEVICE_SHOW(name, reg) \
 DPOT_DEVICE_SET(name, reg) \
-static DEVICE_ATTR(name, S_IWUSR | S_IRUGO, show_##name, set_##name);
+static DEVICE_ATTR(name, S_IWUSR | S_IRUGO, show_##name, set_##name)
 
 #define DPOT_DEVICE_SHOW_ONLY(name, reg) \
 DPOT_DEVICE_SHOW(name, reg) \
-static DEVICE_ATTR(name, S_IWUSR | S_IRUGO, show_##name, NULL);
+static DEVICE_ATTR(name, S_IWUSR | S_IRUGO, show_##name, NULL)
 
 DPOT_DEVICE_SHOW_SET(rdac0, DPOT_ADDR_RDAC | DPOT_RDAC0);
 DPOT_DEVICE_SHOW_SET(eeprom0, DPOT_ADDR_EEPROM | DPOT_RDAC0);
@@ -616,7 +616,7 @@ set_##_name(struct device *dev, \
 { \
 	return sysfs_do_cmd(dev, attr, buf, count, _cmd); \
 } \
-static DEVICE_ATTR(_name, S_IWUSR | S_IRUGO, NULL, set_##_name);
+static DEVICE_ATTR(_name, S_IWUSR | S_IRUGO, NULL, set_##_name)
 
 DPOT_DEVICE_DO_CMD(inc_all, DPOT_INC_ALL);
 DPOT_DEVICE_DO_CMD(dec_all, DPOT_DEC_ALL);

commit dcaf7689d6e2f23dd3286edc6463e1f4499a0f80
Author: Dhaval Shah <dhaval.shah@softnautics.com>
Date:   Fri Dec 8 13:43:04 2017 +0530

    misc: ad525x_dpot: please, no space before tabs
    
    Resolved the please, no space beofore tabs checkpatch
    warning. Issue found by checkpatch.
    
    Signed-off-by: Dhaval Shah <dhaval.shah@softnautics.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/ad525x_dpot.c b/drivers/misc/ad525x_dpot.c
index 1c6b55655f52..577f5e76c8a8 100644
--- a/drivers/misc/ad525x_dpot.c
+++ b/drivers/misc/ad525x_dpot.c
@@ -3,7 +3,7 @@
  * Copyright (c) 2009-2010 Analog Devices, Inc.
  * Author: Michael Hennerich <hennerich@blackfin.uclinux.org>
  *
- * DEVID		#Wipers		#Positions 	Resistor Options (kOhm)
+ * DEVID		#Wipers		#Positions	Resistor Options (kOhm)
  * AD5258		1		64		1, 10, 50, 100
  * AD5259		1		256		5, 10, 50, 100
  * AD5251		2		64		1, 10, 50, 100

commit d06d101ba8a2afda2cfb72ce72d3c26150611a6b
Author: Dhaval Shah <dhaval.shah@softnautics.com>
Date:   Fri Dec 8 13:43:03 2017 +0530

    misc: ad525x_dpot: Prefer 'unsigned int' to bare use of 'unsigned'
    
    Resolved all the Prefer 'unsigned int' to bare use of 'unsigned'
    checkpatch warnings. Issue found by checkpatch.
    
    Signed-off-by: Dhaval Shah <dhaval.shah@softnautics.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/ad525x_dpot.c b/drivers/misc/ad525x_dpot.c
index fe1672747bc1..1c6b55655f52 100644
--- a/drivers/misc/ad525x_dpot.c
+++ b/drivers/misc/ad525x_dpot.c
@@ -84,12 +84,12 @@
 struct dpot_data {
 	struct ad_dpot_bus_data	bdata;
 	struct mutex update_lock;
-	unsigned rdac_mask;
-	unsigned max_pos;
+	unsigned int rdac_mask;
+	unsigned int max_pos;
 	unsigned long devid;
-	unsigned uid;
-	unsigned feat;
-	unsigned wipers;
+	unsigned int uid;
+	unsigned int feat;
+	unsigned int wipers;
 	u16 rdac_cache[MAX_RDACS];
 	DECLARE_BITMAP(otp_en_mask, MAX_RDACS);
 };
@@ -126,7 +126,7 @@ static inline int dpot_write_r8d16(struct dpot_data *dpot, u8 reg, u16 val)
 
 static s32 dpot_read_spi(struct dpot_data *dpot, u8 reg)
 {
-	unsigned ctrl = 0;
+	unsigned int ctrl = 0;
 	int value;
 
 	if (!(reg & (DPOT_ADDR_EEPROM | DPOT_ADDR_CMD))) {
@@ -175,7 +175,7 @@ static s32 dpot_read_spi(struct dpot_data *dpot, u8 reg)
 static s32 dpot_read_i2c(struct dpot_data *dpot, u8 reg)
 {
 	int value;
-	unsigned ctrl = 0;
+	unsigned int ctrl = 0;
 
 	switch (dpot->uid) {
 	case DPOT_UID(AD5246_ID):
@@ -238,7 +238,7 @@ static s32 dpot_read(struct dpot_data *dpot, u8 reg)
 
 static s32 dpot_write_spi(struct dpot_data *dpot, u8 reg, u16 value)
 {
-	unsigned val = 0;
+	unsigned int val = 0;
 
 	if (!(reg & (DPOT_ADDR_EEPROM | DPOT_ADDR_CMD | DPOT_ADDR_OTP))) {
 		if (dpot->feat & F_RDACS_WONLY)
@@ -328,7 +328,7 @@ static s32 dpot_write_spi(struct dpot_data *dpot, u8 reg, u16 value)
 static s32 dpot_write_i2c(struct dpot_data *dpot, u8 reg, u16 value)
 {
 	/* Only write the instruction byte for certain commands */
-	unsigned tmp = 0, ctrl = 0;
+	unsigned int tmp = 0, ctrl = 0;
 
 	switch (dpot->uid) {
 	case DPOT_UID(AD5246_ID):
@@ -636,7 +636,7 @@ static const struct attribute_group ad525x_group_commands = {
 };
 
 static int ad_dpot_add_files(struct device *dev,
-		unsigned features, unsigned rdac)
+		unsigned int features, unsigned int rdac)
 {
 	int err = sysfs_create_file(&dev->kobj,
 		dpot_attrib_wipers[rdac]);
@@ -661,7 +661,7 @@ static int ad_dpot_add_files(struct device *dev,
 }
 
 static inline void ad_dpot_remove_files(struct device *dev,
-		unsigned features, unsigned rdac)
+		unsigned int features, unsigned int rdac)
 {
 	sysfs_remove_file(&dev->kobj,
 		dpot_attrib_wipers[rdac]);

commit 1bb850a1b7f68b66361e658e334f9fdf8231f17d
Author: Dan Bogdan Nechita <dan.bogdan.nechita@gmail.com>
Date:   Tue Feb 23 11:48:45 2016 +0200

    misc: ad525x_dpot: Fix the enabling of the "otpXen" attributes
    
    Currently writing the attributes with "echo" will result in comparing:
    "enabled\n" with "enabled\0" and attribute is always set to false.
    
    Use the sysfs_streq() instead because it treats both NUL and
    new-line-then-NUL as equivalent string terminations.
    
    Signed-off-by: Dan Bogdan Nechita <dan.bogdan.nechita@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/ad525x_dpot.c b/drivers/misc/ad525x_dpot.c
index f1a0b99f5a9a..fe1672747bc1 100644
--- a/drivers/misc/ad525x_dpot.c
+++ b/drivers/misc/ad525x_dpot.c
@@ -452,7 +452,7 @@ static ssize_t sysfs_set_reg(struct device *dev,
 	int err;
 
 	if (reg & DPOT_ADDR_OTP_EN) {
-		if (!strncmp(buf, "enabled", sizeof("enabled")))
+		if (sysfs_streq(buf, "enabled"))
 			set_bit(DPOT_RDAC_MASK & reg, data->otp_en_mask);
 		else
 			clear_bit(DPOT_RDAC_MASK & reg, data->otp_en_mask);

commit f3df53e4d70b5736368a8fe8aa1bb70c1cb1f577
Author: Michael Hennerich <michael.hennerich@analog.com>
Date:   Mon Feb 22 10:20:24 2016 +0100

    drivers/misc/ad525x_dpot: AD5274 fix RDAC read back errors
    
    Fix RDAC read back errors caused by a typo. Value must shift by 2.
    
    Fixes: a4bd394956f2 ("drivers/misc/ad525x_dpot.c: new features")
    Signed-off-by: Michael Hennerich <michael.hennerich@analog.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/ad525x_dpot.c b/drivers/misc/ad525x_dpot.c
index 15e88078ba1e..f1a0b99f5a9a 100644
--- a/drivers/misc/ad525x_dpot.c
+++ b/drivers/misc/ad525x_dpot.c
@@ -216,7 +216,7 @@ static s32 dpot_read_i2c(struct dpot_data *dpot, u8 reg)
 			 */
 			value = swab16(value);
 
-			if (dpot->uid == DPOT_UID(AD5271_ID))
+			if (dpot->uid == DPOT_UID(AD5274_ID))
 				value = value >> 2;
 		return value;
 	default:

commit 3d494bba92c4665ab34056bf86a14e02b0e1db22
Author: Mohammad Jamal <md.jamalmohiuddin@gmail.com>
Date:   Thu Dec 18 07:17:13 2014 +0530

    ad525x_dpot:Remove break after return
    
    This patch removes the break statements present after return
    
    Signed-off-by: Mohammad Jamal <md.jamalmohiuddin@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/ad525x_dpot.c b/drivers/misc/ad525x_dpot.c
index 32f907245409..15e88078ba1e 100644
--- a/drivers/misc/ad525x_dpot.c
+++ b/drivers/misc/ad525x_dpot.c
@@ -334,7 +334,6 @@ static s32 dpot_write_i2c(struct dpot_data *dpot, u8 reg, u16 value)
 	case DPOT_UID(AD5246_ID):
 	case DPOT_UID(AD5247_ID):
 		return dpot_write_d8(dpot, value);
-		break;
 
 	case DPOT_UID(AD5245_ID):
 	case DPOT_UID(AD5241_ID):
@@ -346,7 +345,6 @@ static s32 dpot_write_i2c(struct dpot_data *dpot, u8 reg, u16 value)
 		ctrl = ((reg & DPOT_RDAC_MASK) == DPOT_RDAC0) ?
 			0 : DPOT_AD5282_RDAC_AB;
 		return dpot_write_r8d8(dpot, ctrl, value);
-		break;
 	case DPOT_UID(AD5171_ID):
 	case DPOT_UID(AD5273_ID):
 		if (reg & DPOT_ADDR_OTP) {
@@ -356,7 +354,6 @@ static s32 dpot_write_i2c(struct dpot_data *dpot, u8 reg, u16 value)
 			ctrl = DPOT_AD5273_FUSE;
 		}
 		return dpot_write_r8d8(dpot, ctrl, value);
-		break;
 	case DPOT_UID(AD5172_ID):
 	case DPOT_UID(AD5173_ID):
 		ctrl = ((reg & DPOT_RDAC_MASK) == DPOT_RDAC0) ?
@@ -368,7 +365,6 @@ static s32 dpot_write_i2c(struct dpot_data *dpot, u8 reg, u16 value)
 			ctrl |= DPOT_AD5170_2_3_FUSE;
 		}
 		return dpot_write_r8d8(dpot, ctrl, value);
-		break;
 	case DPOT_UID(AD5170_ID):
 		if (reg & DPOT_ADDR_OTP) {
 			tmp = dpot_read_r8d16(dpot, tmp);
@@ -377,7 +373,6 @@ static s32 dpot_write_i2c(struct dpot_data *dpot, u8 reg, u16 value)
 			ctrl = DPOT_AD5170_2_3_FUSE;
 		}
 		return dpot_write_r8d8(dpot, ctrl, value);
-		break;
 	case DPOT_UID(AD5272_ID):
 	case DPOT_UID(AD5274_ID):
 		dpot_write_r8d8(dpot, DPOT_AD5270_1_2_4_CTRLREG << 2,
@@ -392,7 +387,6 @@ static s32 dpot_write_i2c(struct dpot_data *dpot, u8 reg, u16 value)
 
 		return dpot_write_r8d8(dpot, (DPOT_AD5270_1_2_4_RDAC << 2) |
 				       (value >> 8), value & 0xFF);
-		break;
 	default:
 		if (reg & DPOT_ADDR_CMD)
 			return dpot_write_d8(dpot, reg);

commit 1558455582623b67492f630d11b94d5e4c506e5f
Author: Mohammad Jamal <md.jamalmohiuddin@gmail.com>
Date:   Thu Dec 18 07:16:26 2014 +0530

    ad525x_dpot: Add a blank line after declaration
    
    Added a blank line after declaration to fix the warning of checkpatch.pl
    
    Signed-off-by: Mohammad Jamal <md.jamalmohiuddin@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/ad525x_dpot.c b/drivers/misc/ad525x_dpot.c
index a43053daad0e..32f907245409 100644
--- a/drivers/misc/ad525x_dpot.c
+++ b/drivers/misc/ad525x_dpot.c
@@ -176,6 +176,7 @@ static s32 dpot_read_i2c(struct dpot_data *dpot, u8 reg)
 {
 	int value;
 	unsigned ctrl = 0;
+
 	switch (dpot->uid) {
 	case DPOT_UID(AD5246_ID):
 	case DPOT_UID(AD5247_ID):

commit e2527ec3690bc820e5b4288577f79945f4a22d77
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Tue Jan 21 16:23:07 2014 -0500

    drivers/misc: delete non-required instances of include <linux/init.h>
    
    None of these files are actually using any __init type directives
    and hence don't need to include <linux/init.h>.  Most are just a
    left over from __devinit and __cpuinit removal, or simply due to
    code getting copied from one driver to the next.
    
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/ad525x_dpot.c b/drivers/misc/ad525x_dpot.c
index d3eee113baeb..a43053daad0e 100644
--- a/drivers/misc/ad525x_dpot.c
+++ b/drivers/misc/ad525x_dpot.c
@@ -72,7 +72,6 @@
 #include <linux/module.h>
 #include <linux/device.h>
 #include <linux/kernel.h>
-#include <linux/init.h>
 #include <linux/delay.h>
 #include <linux/slab.h>
 

commit 1bdd2c45ccc2b1801e3b114fe6fd008439c6c5a9
Author: Rashika Kheria <rashika.kheria@gmail.com>
Date:   Fri Dec 13 12:27:10 2013 +0530

    drivers: misc: Mark functions as static in ad525x_dpot.c
    
    This patch marks the function ad_dpot_add_files() and
    ad_dpot_remove_files() as static in ad525x_dpot.c because they are not
    used outside this file.
    
    Thus, it also eliminates the following warnings in ad525x_dpot.c:
    drivers/misc/ad525x_dpot.c:644:5: warning: no previous prototype for ‘ad_dpot_add_files’ [-Wmissing-prototypes]
    drivers/misc/ad525x_dpot.c:669:13: warning: no previous prototype for ‘ad_dpot_remove_files’ [-Wmissing-prototypes]
    
    Signed-off-by: Rashika Kheria <rashika.kheria@gmail.com>
    Reviewed-by: Josh Triplett <josh@joshtriplett.org>
    Acked-by: Michael Hennerich <michael.hennerich@analog.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/ad525x_dpot.c b/drivers/misc/ad525x_dpot.c
index 0daadcf1ed7a..d3eee113baeb 100644
--- a/drivers/misc/ad525x_dpot.c
+++ b/drivers/misc/ad525x_dpot.c
@@ -641,7 +641,7 @@ static const struct attribute_group ad525x_group_commands = {
 	.attrs = ad525x_attributes_commands,
 };
 
-int ad_dpot_add_files(struct device *dev,
+static int ad_dpot_add_files(struct device *dev,
 		unsigned features, unsigned rdac)
 {
 	int err = sysfs_create_file(&dev->kobj,
@@ -666,7 +666,7 @@ int ad_dpot_add_files(struct device *dev,
 	return err;
 }
 
-inline void ad_dpot_remove_files(struct device *dev,
+static inline void ad_dpot_remove_files(struct device *dev,
 		unsigned features, unsigned rdac)
 {
 	sysfs_remove_file(&dev->kobj,

commit f7b41276b6b07f47c5f5212fa244385b0e3aaa30
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Tue Jun 4 13:15:16 2013 +0900

    misc: replace strict_strtoul() with kstrtoul()
    
    The usage of strict_strtoul() is not preferred, because
    strict_strtoul() is obsolete. Thus, kstrtoul() should be
    used.
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/ad525x_dpot.c b/drivers/misc/ad525x_dpot.c
index 8f99e8e3f0ac..0daadcf1ed7a 100644
--- a/drivers/misc/ad525x_dpot.c
+++ b/drivers/misc/ad525x_dpot.c
@@ -470,7 +470,7 @@ static ssize_t sysfs_set_reg(struct device *dev,
 		!test_bit(DPOT_RDAC_MASK & reg, data->otp_en_mask))
 		return -EPERM;
 
-	err = strict_strtoul(buf, 10, &value);
+	err = kstrtoul(buf, 10, &value);
 	if (err)
 		return err;
 

commit 80c8ae289266529445fad030fabf5fcf01ccda0d
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:23:05 2012 -0500

    misc: remove use of __devinit
    
    CONFIG_HOTPLUG is going away as an option so __devinit is no longer
    needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Cc: "Michał Mirosław" <mirq-linux@rere.qmqm.pl>
    Cc: Eric Piel <eric.piel@tremplin-utc.net>
    Cc: Jiri Slaby <jirislaby@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/ad525x_dpot.c b/drivers/misc/ad525x_dpot.c
index 6938f1be664d..8f99e8e3f0ac 100644
--- a/drivers/misc/ad525x_dpot.c
+++ b/drivers/misc/ad525x_dpot.c
@@ -641,7 +641,7 @@ static const struct attribute_group ad525x_group_commands = {
 	.attrs = ad525x_attributes_commands,
 };
 
-__devinit int ad_dpot_add_files(struct device *dev,
+int ad_dpot_add_files(struct device *dev,
 		unsigned features, unsigned rdac)
 {
 	int err = sysfs_create_file(&dev->kobj,
@@ -685,7 +685,7 @@ inline void ad_dpot_remove_files(struct device *dev,
 	}
 }
 
-int __devinit ad_dpot_probe(struct device *dev,
+int ad_dpot_probe(struct device *dev,
 		struct ad_dpot_bus_data *bdata, unsigned long devid,
 			    const char *name)
 {

commit 0ed0d579cb19e00acda762bad0d526477833c4e7
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Sat Apr 14 10:25:04 2012 -0600

    misc: do not mark exported functions __devexit
    
    No symbol can be exported when the section is discarded - the only
    solution I could think of is not to mark symbols as __devexit
    when they are exported.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Mathieu Poirier <mathieu.poirier@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/ad525x_dpot.c b/drivers/misc/ad525x_dpot.c
index 1d1d42615915..6938f1be664d 100644
--- a/drivers/misc/ad525x_dpot.c
+++ b/drivers/misc/ad525x_dpot.c
@@ -749,7 +749,7 @@ int __devinit ad_dpot_probe(struct device *dev,
 }
 EXPORT_SYMBOL(ad_dpot_probe);
 
-__devexit int ad_dpot_remove(struct device *dev)
+int ad_dpot_remove(struct device *dev)
 {
 	struct dpot_data *data = dev_get_drvdata(dev);
 	int i;

commit 7f3379de9cd91e52c40a48b8c01ebdb2d2eec5cf
Author: Michael Hennerich <michael.hennerich@analog.com>
Date:   Fri Nov 18 11:05:11 2011 +0100

    misc: ad525x_dpot: Add support for SPI module device table matching
    
    Passing device name via platform data, is a leftover from times where
    SPI module device table matching was not existent.
    
    * Add id_table and remove old mechanism.
    (To my knowledge no intree boards affected)
    * Miscellaneous other cleanup.
    
    Signed-off-by: Michael Hennerich <michael.hennerich@analog.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/misc/ad525x_dpot.c b/drivers/misc/ad525x_dpot.c
index 7cb911028d09..1d1d42615915 100644
--- a/drivers/misc/ad525x_dpot.c
+++ b/drivers/misc/ad525x_dpot.c
@@ -64,7 +64,7 @@
  * Author: Chris Verges <chrisv@cyberswitching.com>
  *
  * derived from ad5252.c
- * Copyright (c) 2006 Michael Hennerich <hennerich@blackfin.uclinux.org>
+ * Copyright (c) 2006-2011 Michael Hennerich <hennerich@blackfin.uclinux.org>
  *
  * Licensed under the GPL-2 or later.
  */
@@ -76,8 +76,6 @@
 #include <linux/delay.h>
 #include <linux/slab.h>
 
-#define DRIVER_VERSION			"0.2"
-
 #include "ad525x_dpot.h"
 
 /*
@@ -687,8 +685,9 @@ inline void ad_dpot_remove_files(struct device *dev,
 	}
 }
 
-__devinit int ad_dpot_probe(struct device *dev,
-		struct ad_dpot_bus_data *bdata, const struct ad_dpot_id *id)
+int __devinit ad_dpot_probe(struct device *dev,
+		struct ad_dpot_bus_data *bdata, unsigned long devid,
+			    const char *name)
 {
 
 	struct dpot_data *data;
@@ -704,13 +703,13 @@ __devinit int ad_dpot_probe(struct device *dev,
 	mutex_init(&data->update_lock);
 
 	data->bdata = *bdata;
-	data->devid = id->devid;
+	data->devid = devid;
 
-	data->max_pos = 1 << DPOT_MAX_POS(data->devid);
+	data->max_pos = 1 << DPOT_MAX_POS(devid);
 	data->rdac_mask = data->max_pos - 1;
-	data->feat = DPOT_FEAT(data->devid);
-	data->uid = DPOT_UID(data->devid);
-	data->wipers = DPOT_WIPERS(data->devid);
+	data->feat = DPOT_FEAT(devid);
+	data->uid = DPOT_UID(devid);
+	data->wipers = DPOT_WIPERS(devid);
 
 	for (i = DPOT_RDAC0; i < MAX_RDACS; i++)
 		if (data->wipers & (1 << i)) {
@@ -731,7 +730,7 @@ __devinit int ad_dpot_probe(struct device *dev,
 	}
 
 	dev_info(dev, "%s %d-Position Digital Potentiometer registered\n",
-		 id->name, data->max_pos);
+		 name, data->max_pos);
 
 	return 0;
 
@@ -745,7 +744,7 @@ __devinit int ad_dpot_probe(struct device *dev,
 	dev_set_drvdata(dev, NULL);
 exit:
 	dev_err(dev, "failed to create client for %s ID 0x%lX\n",
-			id->name, id->devid);
+		name, devid);
 	return err;
 }
 EXPORT_SYMBOL(ad_dpot_probe);
@@ -770,4 +769,3 @@ MODULE_AUTHOR("Chris Verges <chrisv@cyberswitching.com>, "
 	      "Michael Hennerich <hennerich@blackfin.uclinux.org>");
 MODULE_DESCRIPTION("Digital potentiometer driver");
 MODULE_LICENSE("GPL");
-MODULE_VERSION(DRIVER_VERSION);

commit a4bd394956f20d0bfc0ca6ecfac2af4150da274a
Author: Michael Hennerich <michael.hennerich@analog.com>
Date:   Tue Oct 26 14:22:36 2010 -0700

    drivers/misc/ad525x_dpot.c: new features
    
    Add support for AD5270, AD5271, AD5272, AD5274 digital potentiometers.
    Add 20-TP feature for AD5291 and AD5292 parts, and update feature list.
    AD5291 rdac read back must be shifted by two.
    
    Signed-off-by: Michael Hennerich <michael.hennerich@analog.com>
    Cc: Mike Frysinger <vapier@gentoo.org>
    Cc: Chris Verges <chrisv@cyberswitching.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/misc/ad525x_dpot.c b/drivers/misc/ad525x_dpot.c
index 9698c7546911..7cb911028d09 100644
--- a/drivers/misc/ad525x_dpot.c
+++ b/drivers/misc/ad525x_dpot.c
@@ -29,9 +29,9 @@
  * AD5262		2		256		20, 50, 200
  * AD5263		4		256		20, 50, 200
  * AD5290		1		256		10, 50, 100
- * AD5291		1		256		20
- * AD5292		1		1024		20
- * AD5293		1		1024		20
+ * AD5291		1		256		20, 50, 100  (20-TP)
+ * AD5292		1		1024		20, 50, 100  (20-TP)
+ * AD5293		1		1024		20, 50, 100
  * AD7376		1		128		10, 50, 100, 1M
  * AD8400		1		256		1, 10, 50, 100
  * AD8402		2		256		1, 10, 50, 100
@@ -52,6 +52,10 @@
  * AD5170		1		256		2.5, 10, 50, 100 (OTP)
  * AD5172		2		256		2.5, 10, 50, 100 (OTP)
  * AD5173		2		256		2.5, 10, 50, 100 (OTP)
+ * AD5270		1		1024		20, 50, 100 (50-TP)
+ * AD5271		1		256		20, 50, 100 (50-TP)
+ * AD5272		1		1024		20, 50, 100 (50-TP)
+ * AD5274		1		256		20, 50, 100 (50-TP)
  *
  * See Documentation/misc-devices/ad525x_dpot.txt for more info.
  *
@@ -126,18 +130,38 @@ static inline int dpot_write_r8d16(struct dpot_data *dpot, u8 reg, u16 val)
 static s32 dpot_read_spi(struct dpot_data *dpot, u8 reg)
 {
 	unsigned ctrl = 0;
+	int value;
 
 	if (!(reg & (DPOT_ADDR_EEPROM | DPOT_ADDR_CMD))) {
 
 		if (dpot->feat & F_RDACS_WONLY)
 			return dpot->rdac_cache[reg & DPOT_RDAC_MASK];
-
 		if (dpot->uid == DPOT_UID(AD5291_ID) ||
 			dpot->uid == DPOT_UID(AD5292_ID) ||
-			dpot->uid == DPOT_UID(AD5293_ID))
-			return dpot_read_r8d8(dpot,
+			dpot->uid == DPOT_UID(AD5293_ID)) {
+
+			value = dpot_read_r8d8(dpot,
 				DPOT_AD5291_READ_RDAC << 2);
 
+			if (dpot->uid == DPOT_UID(AD5291_ID))
+				value = value >> 2;
+
+			return value;
+		} else if (dpot->uid == DPOT_UID(AD5270_ID) ||
+			dpot->uid == DPOT_UID(AD5271_ID)) {
+
+			value = dpot_read_r8d8(dpot,
+				DPOT_AD5270_1_2_4_READ_RDAC << 2);
+
+			if (value < 0)
+				return value;
+
+			if (dpot->uid == DPOT_UID(AD5271_ID))
+				value = value >> 2;
+
+			return value;
+		}
+
 		ctrl = DPOT_SPI_READ_RDAC;
 	} else if (reg & DPOT_ADDR_EEPROM) {
 		ctrl = DPOT_SPI_READ_EEPROM;
@@ -153,6 +177,7 @@ static s32 dpot_read_spi(struct dpot_data *dpot, u8 reg)
 
 static s32 dpot_read_i2c(struct dpot_data *dpot, u8 reg)
 {
+	int value;
 	unsigned ctrl = 0;
 	switch (dpot->uid) {
 	case DPOT_UID(AD5246_ID):
@@ -177,6 +202,25 @@ static s32 dpot_read_i2c(struct dpot_data *dpot, u8 reg)
 		ctrl = ((reg & DPOT_RDAC_MASK) == DPOT_RDAC0) ?
 			0 : DPOT_AD5172_3_A0;
 		return dpot_read_r8d8(dpot, ctrl);
+	case DPOT_UID(AD5272_ID):
+	case DPOT_UID(AD5274_ID):
+			dpot_write_r8d8(dpot,
+				(DPOT_AD5270_1_2_4_READ_RDAC << 2), 0);
+
+			value = dpot_read_r8d16(dpot,
+				DPOT_AD5270_1_2_4_RDAC << 2);
+
+			if (value < 0)
+				return value;
+			/*
+			 * AD5272/AD5274 returns high byte first, however
+			 * underling smbus expects low byte first.
+			 */
+			value = swab16(value);
+
+			if (dpot->uid == DPOT_UID(AD5271_ID))
+				value = value >> 2;
+		return value;
 	default:
 		if ((reg & DPOT_REG_TOL) || (dpot->max_pos > 256))
 			return dpot_read_r8d16(dpot, (reg & 0xF8) |
@@ -198,7 +242,7 @@ static s32 dpot_write_spi(struct dpot_data *dpot, u8 reg, u16 value)
 {
 	unsigned val = 0;
 
-	if (!(reg & (DPOT_ADDR_EEPROM | DPOT_ADDR_CMD))) {
+	if (!(reg & (DPOT_ADDR_EEPROM | DPOT_ADDR_CMD | DPOT_ADDR_OTP))) {
 		if (dpot->feat & F_RDACS_WONLY)
 			dpot->rdac_cache[reg & DPOT_RDAC_MASK] = value;
 
@@ -219,11 +263,30 @@ static s32 dpot_write_spi(struct dpot_data *dpot, u8 reg, u16 value)
 		} else {
 			if (dpot->uid == DPOT_UID(AD5291_ID) ||
 				dpot->uid == DPOT_UID(AD5292_ID) ||
-				dpot->uid == DPOT_UID(AD5293_ID))
+				dpot->uid == DPOT_UID(AD5293_ID)) {
+
+				dpot_write_r8d8(dpot, DPOT_AD5291_CTRLREG << 2,
+						DPOT_AD5291_UNLOCK_CMD);
+
+				if (dpot->uid == DPOT_UID(AD5291_ID))
+					value = value << 2;
+
 				return dpot_write_r8d8(dpot,
 					(DPOT_AD5291_RDAC << 2) |
 					(value >> 8), value & 0xFF);
+			} else if (dpot->uid == DPOT_UID(AD5270_ID) ||
+				dpot->uid == DPOT_UID(AD5271_ID)) {
+				dpot_write_r8d8(dpot,
+						DPOT_AD5270_1_2_4_CTRLREG << 2,
+						DPOT_AD5270_1_2_4_UNLOCK_CMD);
+
+				if (dpot->uid == DPOT_UID(AD5271_ID))
+					value = value << 2;
 
+				return dpot_write_r8d8(dpot,
+					(DPOT_AD5270_1_2_4_RDAC << 2) |
+					(value >> 8), value & 0xFF);
+			}
 			val = DPOT_SPI_RDAC | (reg & DPOT_RDAC_MASK);
 		}
 	} else if (reg & DPOT_ADDR_EEPROM) {
@@ -243,6 +306,16 @@ static s32 dpot_write_spi(struct dpot_data *dpot, u8 reg, u16 value)
 			val = DPOT_SPI_INC_ALL;
 			break;
 		}
+	} else if (reg & DPOT_ADDR_OTP) {
+		if (dpot->uid == DPOT_UID(AD5291_ID) ||
+			dpot->uid == DPOT_UID(AD5292_ID)) {
+			return dpot_write_r8d8(dpot,
+				DPOT_AD5291_STORE_XTPM << 2, 0);
+		} else if (dpot->uid == DPOT_UID(AD5270_ID) ||
+			dpot->uid == DPOT_UID(AD5271_ID)) {
+			return dpot_write_r8d8(dpot,
+				DPOT_AD5270_1_2_4_STORE_XTPM << 2, 0);
+		}
 	} else
 		BUG();
 
@@ -303,10 +376,25 @@ static s32 dpot_write_i2c(struct dpot_data *dpot, u8 reg, u16 value)
 			tmp = dpot_read_r8d16(dpot, tmp);
 			if (tmp >> 14) /* Ready to Program? */
 				return -EFAULT;
-			ctrl = DPOT_AD5270_2_3_FUSE;
+			ctrl = DPOT_AD5170_2_3_FUSE;
 		}
 		return dpot_write_r8d8(dpot, ctrl, value);
 		break;
+	case DPOT_UID(AD5272_ID):
+	case DPOT_UID(AD5274_ID):
+		dpot_write_r8d8(dpot, DPOT_AD5270_1_2_4_CTRLREG << 2,
+				DPOT_AD5270_1_2_4_UNLOCK_CMD);
+
+		if (reg & DPOT_ADDR_OTP)
+			return dpot_write_r8d8(dpot,
+					DPOT_AD5270_1_2_4_STORE_XTPM << 2, 0);
+
+		if (dpot->uid == DPOT_UID(AD5274_ID))
+			value = value << 2;
+
+		return dpot_write_r8d8(dpot, (DPOT_AD5270_1_2_4_RDAC << 2) |
+				       (value >> 8), value & 0xFF);
+		break;
 	default:
 		if (reg & DPOT_ADDR_CMD)
 			return dpot_write_d8(dpot, reg);
@@ -320,7 +408,6 @@ static s32 dpot_write_i2c(struct dpot_data *dpot, u8 reg, u16 value)
 	}
 }
 
-
 static s32 dpot_write(struct dpot_data *dpot, u8 reg, u16 value)
 {
 	if (dpot->feat & F_SPI)

commit 5f400cf40fc703673aa791966ffb1c628c1ff45a
Author: Michael Hennerich <michael.hennerich@analog.com>
Date:   Tue Oct 26 14:22:35 2010 -0700

    drivers/misc/ad525x_dpot.c: fix part name typos in defines
    
    There is no runtime effect by this change.  It frees up namespace for
    defines erroneously used.  This is required to actually support devices
    requiring the namespace, added with "drivers/misc/ad525x_dpot.c: new
    features".
    
    All defines touched have the same value defined, after the change.
    
    Signed-off-by: Michael Hennerich <michael.hennerich@analog.com>
    Cc: Mike Frysinger <vapier@gentoo.org>
    Cc: Chris Verges <chrisv@cyberswitching.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/misc/ad525x_dpot.c b/drivers/misc/ad525x_dpot.c
index 5e6fa8449e8b..9698c7546911 100644
--- a/drivers/misc/ad525x_dpot.c
+++ b/drivers/misc/ad525x_dpot.c
@@ -166,7 +166,7 @@ static s32 dpot_read_i2c(struct dpot_data *dpot, u8 reg)
 	case DPOT_UID(AD5280_ID):
 	case DPOT_UID(AD5282_ID):
 		ctrl = ((reg & DPOT_RDAC_MASK) == DPOT_RDAC0) ?
-			0 : DPOT_AD5291_RDAC_AB;
+			0 : DPOT_AD5282_RDAC_AB;
 		return dpot_read_r8d8(dpot, ctrl);
 	case DPOT_UID(AD5170_ID):
 	case DPOT_UID(AD5171_ID):
@@ -175,7 +175,7 @@ static s32 dpot_read_i2c(struct dpot_data *dpot, u8 reg)
 	case DPOT_UID(AD5172_ID):
 	case DPOT_UID(AD5173_ID):
 		ctrl = ((reg & DPOT_RDAC_MASK) == DPOT_RDAC0) ?
-			0 : DPOT_AD5272_3_A0;
+			0 : DPOT_AD5172_3_A0;
 		return dpot_read_r8d8(dpot, ctrl);
 	default:
 		if ((reg & DPOT_REG_TOL) || (dpot->max_pos > 256))
@@ -273,7 +273,7 @@ static s32 dpot_write_i2c(struct dpot_data *dpot, u8 reg, u16 value)
 	case DPOT_UID(AD5280_ID):
 	case DPOT_UID(AD5282_ID):
 		ctrl = ((reg & DPOT_RDAC_MASK) == DPOT_RDAC0) ?
-			0 : DPOT_AD5291_RDAC_AB;
+			0 : DPOT_AD5282_RDAC_AB;
 		return dpot_write_r8d8(dpot, ctrl, value);
 		break;
 	case DPOT_UID(AD5171_ID):
@@ -289,12 +289,12 @@ static s32 dpot_write_i2c(struct dpot_data *dpot, u8 reg, u16 value)
 	case DPOT_UID(AD5172_ID):
 	case DPOT_UID(AD5173_ID):
 		ctrl = ((reg & DPOT_RDAC_MASK) == DPOT_RDAC0) ?
-			0 : DPOT_AD5272_3_A0;
+			0 : DPOT_AD5172_3_A0;
 		if (reg & DPOT_ADDR_OTP) {
 			tmp = dpot_read_r8d16(dpot, ctrl);
 			if (tmp >> 14) /* Ready to Program? */
 				return -EFAULT;
-			ctrl |= DPOT_AD5270_2_3_FUSE;
+			ctrl |= DPOT_AD5170_2_3_FUSE;
 		}
 		return dpot_write_r8d8(dpot, ctrl, value);
 		break;

commit 59592d0ccc0000d74ea5fc2a59e3ec0c9ef1fb13
Author: Michael Hennerich <michael.hennerich@analog.com>
Date:   Mon May 24 14:33:16 2010 -0700

    ad525x_dpot: add support for one time programmable pots
    
    New parts supported:
            AD5170, AD5171, AD5172, AD5173, AD5273
    
    Signed-off-by: Michael Hennerich <michael.hennerich@analog.com>
    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/misc/ad525x_dpot.c b/drivers/misc/ad525x_dpot.c
index 255ba4b5e355..5e6fa8449e8b 100644
--- a/drivers/misc/ad525x_dpot.c
+++ b/drivers/misc/ad525x_dpot.c
@@ -47,6 +47,11 @@
  * AD5280		1		256		20, 50, 200
  * AD5282		2		256		20, 50, 200
  * ADN2860		3		512		25, 250
+ * AD5273		1		64		1, 10, 50, 100 (OTP)
+ * AD5171		1		64		5, 10, 50, 100 (OTP)
+ * AD5170		1		256		2.5, 10, 50, 100 (OTP)
+ * AD5172		2		256		2.5, 10, 50, 100 (OTP)
+ * AD5173		2		256		2.5, 10, 50, 100 (OTP)
  *
  * See Documentation/misc-devices/ad525x_dpot.txt for more info.
  *
@@ -84,7 +89,8 @@ struct dpot_data {
 	unsigned uid;
 	unsigned feat;
 	unsigned wipers;
-	u16 rdac_cache[8];
+	u16 rdac_cache[MAX_RDACS];
+	DECLARE_BITMAP(otp_en_mask, MAX_RDACS);
 };
 
 static inline int dpot_read_d8(struct dpot_data *dpot)
@@ -162,6 +168,15 @@ static s32 dpot_read_i2c(struct dpot_data *dpot, u8 reg)
 		ctrl = ((reg & DPOT_RDAC_MASK) == DPOT_RDAC0) ?
 			0 : DPOT_AD5291_RDAC_AB;
 		return dpot_read_r8d8(dpot, ctrl);
+	case DPOT_UID(AD5170_ID):
+	case DPOT_UID(AD5171_ID):
+	case DPOT_UID(AD5273_ID):
+			return dpot_read_d8(dpot);
+	case DPOT_UID(AD5172_ID):
+	case DPOT_UID(AD5173_ID):
+		ctrl = ((reg & DPOT_RDAC_MASK) == DPOT_RDAC0) ?
+			0 : DPOT_AD5272_3_A0;
+		return dpot_read_r8d8(dpot, ctrl);
 	default:
 		if ((reg & DPOT_REG_TOL) || (dpot->max_pos > 256))
 			return dpot_read_r8d16(dpot, (reg & 0xF8) |
@@ -242,7 +257,7 @@ static s32 dpot_write_spi(struct dpot_data *dpot, u8 reg, u16 value)
 static s32 dpot_write_i2c(struct dpot_data *dpot, u8 reg, u16 value)
 {
 	/* Only write the instruction byte for certain commands */
-	unsigned ctrl = 0;
+	unsigned tmp = 0, ctrl = 0;
 
 	switch (dpot->uid) {
 	case DPOT_UID(AD5246_ID):
@@ -261,6 +276,37 @@ static s32 dpot_write_i2c(struct dpot_data *dpot, u8 reg, u16 value)
 			0 : DPOT_AD5291_RDAC_AB;
 		return dpot_write_r8d8(dpot, ctrl, value);
 		break;
+	case DPOT_UID(AD5171_ID):
+	case DPOT_UID(AD5273_ID):
+		if (reg & DPOT_ADDR_OTP) {
+			tmp = dpot_read_d8(dpot);
+			if (tmp >> 6) /* Ready to Program? */
+				return -EFAULT;
+			ctrl = DPOT_AD5273_FUSE;
+		}
+		return dpot_write_r8d8(dpot, ctrl, value);
+		break;
+	case DPOT_UID(AD5172_ID):
+	case DPOT_UID(AD5173_ID):
+		ctrl = ((reg & DPOT_RDAC_MASK) == DPOT_RDAC0) ?
+			0 : DPOT_AD5272_3_A0;
+		if (reg & DPOT_ADDR_OTP) {
+			tmp = dpot_read_r8d16(dpot, ctrl);
+			if (tmp >> 14) /* Ready to Program? */
+				return -EFAULT;
+			ctrl |= DPOT_AD5270_2_3_FUSE;
+		}
+		return dpot_write_r8d8(dpot, ctrl, value);
+		break;
+	case DPOT_UID(AD5170_ID):
+		if (reg & DPOT_ADDR_OTP) {
+			tmp = dpot_read_r8d16(dpot, tmp);
+			if (tmp >> 14) /* Ready to Program? */
+				return -EFAULT;
+			ctrl = DPOT_AD5270_2_3_FUSE;
+		}
+		return dpot_write_r8d8(dpot, ctrl, value);
+		break;
 	default:
 		if (reg & DPOT_ADDR_CMD)
 			return dpot_write_d8(dpot, reg);
@@ -292,6 +338,12 @@ static ssize_t sysfs_show_reg(struct device *dev,
 	struct dpot_data *data = dev_get_drvdata(dev);
 	s32 value;
 
+	if (reg & DPOT_ADDR_OTP_EN)
+		return sprintf(buf, "%s\n",
+			test_bit(DPOT_RDAC_MASK & reg, data->otp_en_mask) ?
+			"enabled" : "disabled");
+
+
 	mutex_lock(&data->update_lock);
 	value = dpot_read(data, reg);
 	mutex_unlock(&data->update_lock);
@@ -320,6 +372,19 @@ static ssize_t sysfs_set_reg(struct device *dev,
 	unsigned long value;
 	int err;
 
+	if (reg & DPOT_ADDR_OTP_EN) {
+		if (!strncmp(buf, "enabled", sizeof("enabled")))
+			set_bit(DPOT_RDAC_MASK & reg, data->otp_en_mask);
+		else
+			clear_bit(DPOT_RDAC_MASK & reg, data->otp_en_mask);
+
+		return count;
+	}
+
+	if ((reg & DPOT_ADDR_OTP) &&
+		!test_bit(DPOT_RDAC_MASK & reg, data->otp_en_mask))
+		return -EPERM;
+
 	err = strict_strtoul(buf, 10, &value);
 	if (err)
 		return err;
@@ -331,6 +396,8 @@ static ssize_t sysfs_set_reg(struct device *dev,
 	dpot_write(data, reg, value);
 	if (reg & DPOT_ADDR_EEPROM)
 		msleep(26);	/* Sleep while the EEPROM updates */
+	else if (reg & DPOT_ADDR_OTP)
+		msleep(400);	/* Sleep while the OTP updates */
 	mutex_unlock(&data->update_lock);
 
 	return count;
@@ -378,26 +445,38 @@ static DEVICE_ATTR(name, S_IWUSR | S_IRUGO, show_##name, NULL);
 DPOT_DEVICE_SHOW_SET(rdac0, DPOT_ADDR_RDAC | DPOT_RDAC0);
 DPOT_DEVICE_SHOW_SET(eeprom0, DPOT_ADDR_EEPROM | DPOT_RDAC0);
 DPOT_DEVICE_SHOW_ONLY(tolerance0, DPOT_ADDR_EEPROM | DPOT_TOL_RDAC0);
+DPOT_DEVICE_SHOW_SET(otp0, DPOT_ADDR_OTP | DPOT_RDAC0);
+DPOT_DEVICE_SHOW_SET(otp0en, DPOT_ADDR_OTP_EN | DPOT_RDAC0);
 
 DPOT_DEVICE_SHOW_SET(rdac1, DPOT_ADDR_RDAC | DPOT_RDAC1);
 DPOT_DEVICE_SHOW_SET(eeprom1, DPOT_ADDR_EEPROM | DPOT_RDAC1);
 DPOT_DEVICE_SHOW_ONLY(tolerance1, DPOT_ADDR_EEPROM | DPOT_TOL_RDAC1);
+DPOT_DEVICE_SHOW_SET(otp1, DPOT_ADDR_OTP | DPOT_RDAC1);
+DPOT_DEVICE_SHOW_SET(otp1en, DPOT_ADDR_OTP_EN | DPOT_RDAC1);
 
 DPOT_DEVICE_SHOW_SET(rdac2, DPOT_ADDR_RDAC | DPOT_RDAC2);
 DPOT_DEVICE_SHOW_SET(eeprom2, DPOT_ADDR_EEPROM | DPOT_RDAC2);
 DPOT_DEVICE_SHOW_ONLY(tolerance2, DPOT_ADDR_EEPROM | DPOT_TOL_RDAC2);
+DPOT_DEVICE_SHOW_SET(otp2, DPOT_ADDR_OTP | DPOT_RDAC2);
+DPOT_DEVICE_SHOW_SET(otp2en, DPOT_ADDR_OTP_EN | DPOT_RDAC2);
 
 DPOT_DEVICE_SHOW_SET(rdac3, DPOT_ADDR_RDAC | DPOT_RDAC3);
 DPOT_DEVICE_SHOW_SET(eeprom3, DPOT_ADDR_EEPROM | DPOT_RDAC3);
 DPOT_DEVICE_SHOW_ONLY(tolerance3, DPOT_ADDR_EEPROM | DPOT_TOL_RDAC3);
+DPOT_DEVICE_SHOW_SET(otp3, DPOT_ADDR_OTP | DPOT_RDAC3);
+DPOT_DEVICE_SHOW_SET(otp3en, DPOT_ADDR_OTP_EN | DPOT_RDAC3);
 
 DPOT_DEVICE_SHOW_SET(rdac4, DPOT_ADDR_RDAC | DPOT_RDAC4);
 DPOT_DEVICE_SHOW_SET(eeprom4, DPOT_ADDR_EEPROM | DPOT_RDAC4);
 DPOT_DEVICE_SHOW_ONLY(tolerance4, DPOT_ADDR_EEPROM | DPOT_TOL_RDAC4);
+DPOT_DEVICE_SHOW_SET(otp4, DPOT_ADDR_OTP | DPOT_RDAC4);
+DPOT_DEVICE_SHOW_SET(otp4en, DPOT_ADDR_OTP_EN | DPOT_RDAC4);
 
 DPOT_DEVICE_SHOW_SET(rdac5, DPOT_ADDR_RDAC | DPOT_RDAC5);
 DPOT_DEVICE_SHOW_SET(eeprom5, DPOT_ADDR_EEPROM | DPOT_RDAC5);
 DPOT_DEVICE_SHOW_ONLY(tolerance5, DPOT_ADDR_EEPROM | DPOT_TOL_RDAC5);
+DPOT_DEVICE_SHOW_SET(otp5, DPOT_ADDR_OTP | DPOT_RDAC5);
+DPOT_DEVICE_SHOW_SET(otp5en, DPOT_ADDR_OTP_EN | DPOT_RDAC5);
 
 static const struct attribute *dpot_attrib_wipers[] = {
 	&dev_attr_rdac0.attr,
@@ -419,6 +498,26 @@ static const struct attribute *dpot_attrib_eeprom[] = {
 	NULL
 };
 
+static const struct attribute *dpot_attrib_otp[] = {
+	&dev_attr_otp0.attr,
+	&dev_attr_otp1.attr,
+	&dev_attr_otp2.attr,
+	&dev_attr_otp3.attr,
+	&dev_attr_otp4.attr,
+	&dev_attr_otp5.attr,
+	NULL
+};
+
+static const struct attribute *dpot_attrib_otp_en[] = {
+	&dev_attr_otp0en.attr,
+	&dev_attr_otp1en.attr,
+	&dev_attr_otp2en.attr,
+	&dev_attr_otp3en.attr,
+	&dev_attr_otp4en.attr,
+	&dev_attr_otp5en.attr,
+	NULL
+};
+
 static const struct attribute *dpot_attrib_tolerance[] = {
 	&dev_attr_tolerance0.attr,
 	&dev_attr_tolerance1.attr,
@@ -468,6 +567,12 @@ __devinit int ad_dpot_add_files(struct device *dev,
 	if (features & F_CMD_TOL)
 		err |= sysfs_create_file(&dev->kobj,
 			dpot_attrib_tolerance[rdac]);
+	if (features & F_CMD_OTP) {
+		err |= sysfs_create_file(&dev->kobj,
+			dpot_attrib_otp_en[rdac]);
+		err |= sysfs_create_file(&dev->kobj,
+			dpot_attrib_otp[rdac]);
+	}
 
 	if (err)
 		dev_err(dev, "failed to register sysfs hooks for RDAC%d\n",
@@ -487,6 +592,12 @@ inline void ad_dpot_remove_files(struct device *dev,
 	if (features & F_CMD_TOL)
 		sysfs_remove_file(&dev->kobj,
 			dpot_attrib_tolerance[rdac]);
+	if (features & F_CMD_OTP) {
+		sysfs_remove_file(&dev->kobj,
+			dpot_attrib_otp_en[rdac]);
+		sysfs_remove_file(&dev->kobj,
+			dpot_attrib_otp[rdac]);
+	}
 }
 
 __devinit int ad_dpot_probe(struct device *dev,
@@ -514,7 +625,7 @@ __devinit int ad_dpot_probe(struct device *dev,
 	data->uid = DPOT_UID(data->devid);
 	data->wipers = DPOT_WIPERS(data->devid);
 
-	for (i = DPOT_RDAC0; i <= DPOT_RDAC5; i++)
+	for (i = DPOT_RDAC0; i < MAX_RDACS; i++)
 		if (data->wipers & (1 << i)) {
 			err = ad_dpot_add_files(dev, data->feat, i);
 			if (err)
@@ -538,7 +649,7 @@ __devinit int ad_dpot_probe(struct device *dev,
 	return 0;
 
 exit_remove_files:
-	for (i = DPOT_RDAC0; i <= DPOT_RDAC5; i++)
+	for (i = DPOT_RDAC0; i < MAX_RDACS; i++)
 		if (data->wipers & (1 << i))
 			ad_dpot_remove_files(dev, data->feat, i);
 
@@ -557,7 +668,7 @@ __devexit int ad_dpot_remove(struct device *dev)
 	struct dpot_data *data = dev_get_drvdata(dev);
 	int i;
 
-	for (i = DPOT_RDAC0; i <= DPOT_RDAC5; i++)
+	for (i = DPOT_RDAC0; i < MAX_RDACS; i++)
 		if (data->wipers & (1 << i))
 			ad_dpot_remove_files(dev, data->feat, i);
 

commit c74cba610c9559e72377fd9725a3d329581aa256
Author: Michael Hennerich <michael.hennerich@analog.com>
Date:   Mon May 24 14:33:15 2010 -0700

    ad525x_dpot: add support for ADN2860 and AD528x pots
    
    New parts supported:
            AD5280, AD5282, ADN2860
    
    Signed-off-by: Michael Hennerich <michael.hennerich@analog.com>
    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/misc/ad525x_dpot.c b/drivers/misc/ad525x_dpot.c
index 35a4c4b343d4..255ba4b5e355 100644
--- a/drivers/misc/ad525x_dpot.c
+++ b/drivers/misc/ad525x_dpot.c
@@ -44,6 +44,9 @@
  * AD5243		2		256		2.5, 10, 50, 100
  * AD5248		2		256		2.5, 10, 50, 100
  * AD5242		2		256		20, 50, 200
+ * AD5280		1		256		20, 50, 200
+ * AD5282		2		256		20, 50, 200
+ * ADN2860		3		512		25, 250
  *
  * See Documentation/misc-devices/ad525x_dpot.txt for more info.
  *
@@ -154,6 +157,8 @@ static s32 dpot_read_i2c(struct dpot_data *dpot, u8 reg)
 	case DPOT_UID(AD5242_ID):
 	case DPOT_UID(AD5243_ID):
 	case DPOT_UID(AD5248_ID):
+	case DPOT_UID(AD5280_ID):
+	case DPOT_UID(AD5282_ID):
 		ctrl = ((reg & DPOT_RDAC_MASK) == DPOT_RDAC0) ?
 			0 : DPOT_AD5291_RDAC_AB;
 		return dpot_read_r8d8(dpot, ctrl);
@@ -250,21 +255,22 @@ static s32 dpot_write_i2c(struct dpot_data *dpot, u8 reg, u16 value)
 	case DPOT_UID(AD5242_ID):
 	case DPOT_UID(AD5243_ID):
 	case DPOT_UID(AD5248_ID):
-		ctrl = ((reg & DPOT_RDAC_MASK) == DPOT_RDAC0) ? 0 : DPOT_AD5291_RDAC_AB;
+	case DPOT_UID(AD5280_ID):
+	case DPOT_UID(AD5282_ID):
+		ctrl = ((reg & DPOT_RDAC_MASK) == DPOT_RDAC0) ?
+			0 : DPOT_AD5291_RDAC_AB;
 		return dpot_write_r8d8(dpot, ctrl, value);
 		break;
-
-
 	default:
-	if (reg & DPOT_ADDR_CMD)
-		return dpot_write_d8(dpot, reg);
+		if (reg & DPOT_ADDR_CMD)
+			return dpot_write_d8(dpot, reg);
 
-	if (dpot->max_pos > 256)
-		return dpot_write_r8d16(dpot, (reg & 0xF8) |
-					((reg & 0x7) << 1), value);
-	else
-		/* All other registers require instruction + data bytes */
-		return dpot_write_r8d8(dpot, reg, value);
+		if (dpot->max_pos > 256)
+			return dpot_write_r8d16(dpot, (reg & 0xF8) |
+						((reg & 0x7) << 1), value);
+		else
+			/* All other registers require instruction + data bytes */
+			return dpot_write_r8d8(dpot, reg, value);
 	}
 }
 

commit e3ae68476ce0636554b5d95a33777f80ba407dc0
Author: Michael Hennerich <michael.hennerich@analog.com>
Date:   Mon May 24 14:33:15 2010 -0700

    ad525x_dpot: add support for AD524x pots
    
    New parts supported:
            AD5241, AD5242, AD5243, AD5245, AD5246, AD5247, AD5248
    
    Signed-off-by: Michael Hennerich <michael.hennerich@analog.com>
    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/misc/ad525x_dpot.c b/drivers/misc/ad525x_dpot.c
index a41c2de0eae8..35a4c4b343d4 100644
--- a/drivers/misc/ad525x_dpot.c
+++ b/drivers/misc/ad525x_dpot.c
@@ -37,6 +37,13 @@
  * AD8402		2		256		1, 10, 50, 100
  * AD8403		4		256		1, 10, 50, 100
  * ADN2850		3		512		25, 250
+ * AD5241		1		256		10, 100, 1M
+ * AD5246		1		128		5, 10, 50, 100
+ * AD5247		1		128		5, 10, 50, 100
+ * AD5245		1		256		5, 10, 50, 100
+ * AD5243		2		256		2.5, 10, 50, 100
+ * AD5248		2		256		2.5, 10, 50, 100
+ * AD5242		2		256		20, 50, 200
  *
  * See Documentation/misc-devices/ad525x_dpot.txt for more info.
  *
@@ -107,118 +114,169 @@ static inline int dpot_write_r8d16(struct dpot_data *dpot, u8 reg, u16 val)
 	return dpot->bdata.bops->write_r8d16(dpot->bdata.client, reg, val);
 }
 
-static s32 dpot_read(struct dpot_data *dpot, u8 reg)
+static s32 dpot_read_spi(struct dpot_data *dpot, u8 reg)
 {
-	unsigned val = 0;
+	unsigned ctrl = 0;
 
-	if (dpot->feat & F_SPI) {
-		if (!(reg & (DPOT_ADDR_EEPROM | DPOT_ADDR_CMD))) {
+	if (!(reg & (DPOT_ADDR_EEPROM | DPOT_ADDR_CMD))) {
 
-			if (dpot->feat & F_RDACS_WONLY)
-				return dpot->rdac_cache[reg & DPOT_RDAC_MASK];
+		if (dpot->feat & F_RDACS_WONLY)
+			return dpot->rdac_cache[reg & DPOT_RDAC_MASK];
 
-			if (dpot->uid == DPOT_UID(AD5291_ID) ||
-				dpot->uid == DPOT_UID(AD5292_ID) ||
-				dpot->uid == DPOT_UID(AD5293_ID))
-				return dpot_read_r8d8(dpot,
-					DPOT_AD5291_READ_RDAC << 2);
+		if (dpot->uid == DPOT_UID(AD5291_ID) ||
+			dpot->uid == DPOT_UID(AD5292_ID) ||
+			dpot->uid == DPOT_UID(AD5293_ID))
+			return dpot_read_r8d8(dpot,
+				DPOT_AD5291_READ_RDAC << 2);
 
-			val = DPOT_SPI_READ_RDAC;
-		} else if (reg & DPOT_ADDR_EEPROM) {
-			val = DPOT_SPI_READ_EEPROM;
-		}
+		ctrl = DPOT_SPI_READ_RDAC;
+	} else if (reg & DPOT_ADDR_EEPROM) {
+		ctrl = DPOT_SPI_READ_EEPROM;
+	}
 
-		if (dpot->feat & F_SPI_16BIT)
-			return dpot_read_r8d8(dpot, val);
-		else if (dpot->feat & F_SPI_24BIT)
-			return dpot_read_r8d16(dpot, val);
+	if (dpot->feat & F_SPI_16BIT)
+		return dpot_read_r8d8(dpot, ctrl);
+	else if (dpot->feat & F_SPI_24BIT)
+		return dpot_read_r8d16(dpot, ctrl);
 
-	} else { /* I2C */
+	return -EFAULT;
+}
 
+static s32 dpot_read_i2c(struct dpot_data *dpot, u8 reg)
+{
+	unsigned ctrl = 0;
+	switch (dpot->uid) {
+	case DPOT_UID(AD5246_ID):
+	case DPOT_UID(AD5247_ID):
+		return dpot_read_d8(dpot);
+	case DPOT_UID(AD5245_ID):
+	case DPOT_UID(AD5241_ID):
+	case DPOT_UID(AD5242_ID):
+	case DPOT_UID(AD5243_ID):
+	case DPOT_UID(AD5248_ID):
+		ctrl = ((reg & DPOT_RDAC_MASK) == DPOT_RDAC0) ?
+			0 : DPOT_AD5291_RDAC_AB;
+		return dpot_read_r8d8(dpot, ctrl);
+	default:
 		if ((reg & DPOT_REG_TOL) || (dpot->max_pos > 256))
 			return dpot_read_r8d16(dpot, (reg & 0xF8) |
 					((reg & 0x7) << 1));
 		else
 			return dpot_read_r8d8(dpot, reg);
-
 	}
-	return -EFAULT;
 }
 
-static s32 dpot_write(struct dpot_data *dpot, u8 reg, u16 value)
+static s32 dpot_read(struct dpot_data *dpot, u8 reg)
+{
+	if (dpot->feat & F_SPI)
+		return dpot_read_spi(dpot, reg);
+	else
+		return dpot_read_i2c(dpot, reg);
+}
+
+static s32 dpot_write_spi(struct dpot_data *dpot, u8 reg, u16 value)
 {
 	unsigned val = 0;
 
-	if (dpot->feat & F_SPI) {
-		if (!(reg & (DPOT_ADDR_EEPROM | DPOT_ADDR_CMD))) {
-			if (dpot->feat & F_RDACS_WONLY)
-				dpot->rdac_cache[reg & DPOT_RDAC_MASK] = value;
-
-			if (dpot->feat & F_AD_APPDATA) {
-				if (dpot->feat & F_SPI_8BIT) {
-					val = ((reg & DPOT_RDAC_MASK) <<
-						DPOT_MAX_POS(dpot->devid)) |
-						value;
-					return dpot_write_d8(dpot, val);
-				} else if (dpot->feat & F_SPI_16BIT) {
-					val = ((reg & DPOT_RDAC_MASK) <<
-						DPOT_MAX_POS(dpot->devid)) |
-						value;
-					return dpot_write_r8d8(dpot, val >> 8,
-						val & 0xFF);
-				} else
-					BUG();
-			} else {
-				if (dpot->uid == DPOT_UID(AD5291_ID) ||
-					dpot->uid == DPOT_UID(AD5292_ID) ||
-					dpot->uid == DPOT_UID(AD5293_ID))
-					return dpot_write_r8d8(dpot,
-						(DPOT_AD5291_RDAC << 2) |
-						(value >> 8), value & 0xFF);
-
-				val = DPOT_SPI_RDAC | (reg & DPOT_RDAC_MASK);
-			}
-		} else if (reg & DPOT_ADDR_EEPROM) {
-			val = DPOT_SPI_EEPROM | (reg & DPOT_RDAC_MASK);
-		} else if (reg & DPOT_ADDR_CMD) {
-			switch (reg) {
-			case DPOT_DEC_ALL_6DB:
-				val = DPOT_SPI_DEC_ALL_6DB;
-				break;
-			case DPOT_INC_ALL_6DB:
-				val = DPOT_SPI_INC_ALL_6DB;
-				break;
-			case DPOT_DEC_ALL:
-				val = DPOT_SPI_DEC_ALL;
-				break;
-			case DPOT_INC_ALL:
-				val = DPOT_SPI_INC_ALL;
-				break;
-			}
-		} else
-			BUG();
-
-		if (dpot->feat & F_SPI_16BIT)
-			return dpot_write_r8d8(dpot, val, value);
-		else if (dpot->feat & F_SPI_24BIT)
-			return dpot_write_r8d16(dpot, val, value);
-	} else {
-		/* Only write the instruction byte for certain commands */
-		if (reg & DPOT_ADDR_CMD)
-			return dpot_write_d8(dpot, reg);
-
-		if (dpot->max_pos > 256)
-			return dpot_write_r8d16(dpot, (reg & 0xF8) |
-						((reg & 0x7) << 1), value);
-		else
-			/* All other registers require instruction + data bytes */
-			return dpot_write_r8d8(dpot, reg, value);
+	if (!(reg & (DPOT_ADDR_EEPROM | DPOT_ADDR_CMD))) {
+		if (dpot->feat & F_RDACS_WONLY)
+			dpot->rdac_cache[reg & DPOT_RDAC_MASK] = value;
+
+		if (dpot->feat & F_AD_APPDATA) {
+			if (dpot->feat & F_SPI_8BIT) {
+				val = ((reg & DPOT_RDAC_MASK) <<
+					DPOT_MAX_POS(dpot->devid)) |
+					value;
+				return dpot_write_d8(dpot, val);
+			} else if (dpot->feat & F_SPI_16BIT) {
+				val = ((reg & DPOT_RDAC_MASK) <<
+					DPOT_MAX_POS(dpot->devid)) |
+					value;
+				return dpot_write_r8d8(dpot, val >> 8,
+					val & 0xFF);
+			} else
+				BUG();
+		} else {
+			if (dpot->uid == DPOT_UID(AD5291_ID) ||
+				dpot->uid == DPOT_UID(AD5292_ID) ||
+				dpot->uid == DPOT_UID(AD5293_ID))
+				return dpot_write_r8d8(dpot,
+					(DPOT_AD5291_RDAC << 2) |
+					(value >> 8), value & 0xFF);
 
-	}
+			val = DPOT_SPI_RDAC | (reg & DPOT_RDAC_MASK);
+		}
+	} else if (reg & DPOT_ADDR_EEPROM) {
+		val = DPOT_SPI_EEPROM | (reg & DPOT_RDAC_MASK);
+	} else if (reg & DPOT_ADDR_CMD) {
+		switch (reg) {
+		case DPOT_DEC_ALL_6DB:
+			val = DPOT_SPI_DEC_ALL_6DB;
+			break;
+		case DPOT_INC_ALL_6DB:
+			val = DPOT_SPI_INC_ALL_6DB;
+			break;
+		case DPOT_DEC_ALL:
+			val = DPOT_SPI_DEC_ALL;
+			break;
+		case DPOT_INC_ALL:
+			val = DPOT_SPI_INC_ALL;
+			break;
+		}
+	} else
+		BUG();
+
+	if (dpot->feat & F_SPI_16BIT)
+		return dpot_write_r8d8(dpot, val, value);
+	else if (dpot->feat & F_SPI_24BIT)
+		return dpot_write_r8d16(dpot, val, value);
 
 	return -EFAULT;
 }
 
+static s32 dpot_write_i2c(struct dpot_data *dpot, u8 reg, u16 value)
+{
+	/* Only write the instruction byte for certain commands */
+	unsigned ctrl = 0;
+
+	switch (dpot->uid) {
+	case DPOT_UID(AD5246_ID):
+	case DPOT_UID(AD5247_ID):
+		return dpot_write_d8(dpot, value);
+		break;
+
+	case DPOT_UID(AD5245_ID):
+	case DPOT_UID(AD5241_ID):
+	case DPOT_UID(AD5242_ID):
+	case DPOT_UID(AD5243_ID):
+	case DPOT_UID(AD5248_ID):
+		ctrl = ((reg & DPOT_RDAC_MASK) == DPOT_RDAC0) ? 0 : DPOT_AD5291_RDAC_AB;
+		return dpot_write_r8d8(dpot, ctrl, value);
+		break;
+
+
+	default:
+	if (reg & DPOT_ADDR_CMD)
+		return dpot_write_d8(dpot, reg);
+
+	if (dpot->max_pos > 256)
+		return dpot_write_r8d16(dpot, (reg & 0xF8) |
+					((reg & 0x7) << 1), value);
+	else
+		/* All other registers require instruction + data bytes */
+		return dpot_write_r8d8(dpot, reg, value);
+	}
+}
+
+
+static s32 dpot_write(struct dpot_data *dpot, u8 reg, u16 value)
+{
+	if (dpot->feat & F_SPI)
+		return dpot_write_spi(dpot, reg, value);
+	else
+		return dpot_write_i2c(dpot, reg, value);
+}
+
 /* sysfs functions */
 
 static ssize_t sysfs_show_reg(struct device *dev,

commit 6c536e4ce8edd61fdc4ab68e19ae164a54fc958f
Author: Michael Hennerich <michael.hennerich@analog.com>
Date:   Mon May 24 14:33:14 2010 -0700

    ad525x_dpot: add support for SPI parts
    
    Split the bus logic out into separate files so that we can handle I2C and
    SPI busses independently.  The new SPI bus logic brings in support for a
    lot more parts:
    
            AD5160, AD5161, AD5162, AD5165, AD5200, AD5201, AD5203,
            AD5204, AD5206, AD5207, AD5231, AD5232, AD5233, AD5235,
            AD5260, AD5262, AD5263, AD5290, AD5291, AD5292, AD5293,
            AD7376, AD8400, AD8402, AD8403, ADN2850
    
    [randy.dunlap@oracle.com: fix ad525X_dpot build]
    Signed-off-by: Michael Hennerich <michael.hennerich@analog.com>
    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/misc/ad525x_dpot.c b/drivers/misc/ad525x_dpot.c
index ce92088bf0b8..a41c2de0eae8 100644
--- a/drivers/misc/ad525x_dpot.c
+++ b/drivers/misc/ad525x_dpot.c
@@ -1,6 +1,6 @@
 /*
- * ad525x_dpot: Driver for the Analog Devices AD525x digital potentiometers
- * Copyright (c) 2009 Analog Devices, Inc.
+ * ad525x_dpot: Driver for the Analog Devices digital potentiometers
+ * Copyright (c) 2009-2010 Analog Devices, Inc.
  * Author: Michael Hennerich <hennerich@blackfin.uclinux.org>
  *
  * DEVID		#Wipers		#Positions 	Resistor Options (kOhm)
@@ -11,6 +11,32 @@
  * AD5255		3		512		25, 250
  * AD5253		4		64		1, 10, 50, 100
  * AD5254		4		256		1, 10, 50, 100
+ * AD5160		1		256		5, 10, 50, 100
+ * AD5161		1		256		5, 10, 50, 100
+ * AD5162		2		256		2.5, 10, 50, 100
+ * AD5165		1		256		100
+ * AD5200		1		256		10, 50
+ * AD5201		1		33		10, 50
+ * AD5203		4		64		10, 100
+ * AD5204		4		256		10, 50, 100
+ * AD5206		6		256		10, 50, 100
+ * AD5207		2		256		10, 50, 100
+ * AD5231		1		1024		10, 50, 100
+ * AD5232		2		256		10, 50, 100
+ * AD5233		4		64		10, 50, 100
+ * AD5235		2		1024		25, 250
+ * AD5260		1		256		20, 50, 200
+ * AD5262		2		256		20, 50, 200
+ * AD5263		4		256		20, 50, 200
+ * AD5290		1		256		10, 50, 100
+ * AD5291		1		256		20
+ * AD5292		1		1024		20
+ * AD5293		1		1024		20
+ * AD7376		1		128		10, 50, 100, 1M
+ * AD8400		1		256		1, 10, 50, 100
+ * AD8402		2		256		1, 10, 50, 100
+ * AD8403		4		256		1, 10, 50, 100
+ * ADN2850		3		512		25, 250
  *
  * See Documentation/misc-devices/ad525x_dpot.txt for more info.
  *
@@ -28,77 +54,182 @@
 #include <linux/device.h>
 #include <linux/kernel.h>
 #include <linux/init.h>
-#include <linux/slab.h>
-#include <linux/i2c.h>
 #include <linux/delay.h>
+#include <linux/slab.h>
 
-#define DRIVER_NAME			"ad525x_dpot"
-#define DRIVER_VERSION			"0.1"
-
-enum dpot_devid {
-	AD5258_ID,
-	AD5259_ID,
-	AD5251_ID,
-	AD5252_ID,
-	AD5253_ID,
-	AD5254_ID,
-	AD5255_ID,
-};
+#define DRIVER_VERSION			"0.2"
 
-#define AD5258_MAX_POSITION		64
-#define AD5259_MAX_POSITION		256
-#define AD5251_MAX_POSITION		64
-#define AD5252_MAX_POSITION		256
-#define AD5253_MAX_POSITION		64
-#define AD5254_MAX_POSITION		256
-#define AD5255_MAX_POSITION		512
-
-#define AD525X_RDAC0		0
-#define AD525X_RDAC1		1
-#define AD525X_RDAC2		2
-#define AD525X_RDAC3		3
-
-#define AD525X_REG_TOL		0x18
-#define AD525X_TOL_RDAC0	(AD525X_REG_TOL | AD525X_RDAC0)
-#define AD525X_TOL_RDAC1	(AD525X_REG_TOL | AD525X_RDAC1)
-#define AD525X_TOL_RDAC2	(AD525X_REG_TOL | AD525X_RDAC2)
-#define AD525X_TOL_RDAC3	(AD525X_REG_TOL | AD525X_RDAC3)
-
-/* RDAC-to-EEPROM Interface Commands */
-#define AD525X_I2C_RDAC		(0x00 << 5)
-#define AD525X_I2C_EEPROM	(0x01 << 5)
-#define AD525X_I2C_CMD		(0x80)
-
-#define AD525X_DEC_ALL_6DB	(AD525X_I2C_CMD | (0x4 << 3))
-#define AD525X_INC_ALL_6DB	(AD525X_I2C_CMD | (0x9 << 3))
-#define AD525X_DEC_ALL		(AD525X_I2C_CMD | (0x6 << 3))
-#define AD525X_INC_ALL		(AD525X_I2C_CMD | (0xB << 3))
-
-static s32 ad525x_read(struct i2c_client *client, u8 reg);
-static s32 ad525x_write(struct i2c_client *client, u8 reg, u16 value);
+#include "ad525x_dpot.h"
 
 /*
  * Client data (each client gets its own)
  */
 
 struct dpot_data {
+	struct ad_dpot_bus_data	bdata;
 	struct mutex update_lock;
 	unsigned rdac_mask;
 	unsigned max_pos;
-	unsigned devid;
+	unsigned long devid;
+	unsigned uid;
+	unsigned feat;
+	unsigned wipers;
+	u16 rdac_cache[8];
 };
 
+static inline int dpot_read_d8(struct dpot_data *dpot)
+{
+	return dpot->bdata.bops->read_d8(dpot->bdata.client);
+}
+
+static inline int dpot_read_r8d8(struct dpot_data *dpot, u8 reg)
+{
+	return dpot->bdata.bops->read_r8d8(dpot->bdata.client, reg);
+}
+
+static inline int dpot_read_r8d16(struct dpot_data *dpot, u8 reg)
+{
+	return dpot->bdata.bops->read_r8d16(dpot->bdata.client, reg);
+}
+
+static inline int dpot_write_d8(struct dpot_data *dpot, u8 val)
+{
+	return dpot->bdata.bops->write_d8(dpot->bdata.client, val);
+}
+
+static inline int dpot_write_r8d8(struct dpot_data *dpot, u8 reg, u16 val)
+{
+	return dpot->bdata.bops->write_r8d8(dpot->bdata.client, reg, val);
+}
+
+static inline int dpot_write_r8d16(struct dpot_data *dpot, u8 reg, u16 val)
+{
+	return dpot->bdata.bops->write_r8d16(dpot->bdata.client, reg, val);
+}
+
+static s32 dpot_read(struct dpot_data *dpot, u8 reg)
+{
+	unsigned val = 0;
+
+	if (dpot->feat & F_SPI) {
+		if (!(reg & (DPOT_ADDR_EEPROM | DPOT_ADDR_CMD))) {
+
+			if (dpot->feat & F_RDACS_WONLY)
+				return dpot->rdac_cache[reg & DPOT_RDAC_MASK];
+
+			if (dpot->uid == DPOT_UID(AD5291_ID) ||
+				dpot->uid == DPOT_UID(AD5292_ID) ||
+				dpot->uid == DPOT_UID(AD5293_ID))
+				return dpot_read_r8d8(dpot,
+					DPOT_AD5291_READ_RDAC << 2);
+
+			val = DPOT_SPI_READ_RDAC;
+		} else if (reg & DPOT_ADDR_EEPROM) {
+			val = DPOT_SPI_READ_EEPROM;
+		}
+
+		if (dpot->feat & F_SPI_16BIT)
+			return dpot_read_r8d8(dpot, val);
+		else if (dpot->feat & F_SPI_24BIT)
+			return dpot_read_r8d16(dpot, val);
+
+	} else { /* I2C */
+
+		if ((reg & DPOT_REG_TOL) || (dpot->max_pos > 256))
+			return dpot_read_r8d16(dpot, (reg & 0xF8) |
+					((reg & 0x7) << 1));
+		else
+			return dpot_read_r8d8(dpot, reg);
+
+	}
+	return -EFAULT;
+}
+
+static s32 dpot_write(struct dpot_data *dpot, u8 reg, u16 value)
+{
+	unsigned val = 0;
+
+	if (dpot->feat & F_SPI) {
+		if (!(reg & (DPOT_ADDR_EEPROM | DPOT_ADDR_CMD))) {
+			if (dpot->feat & F_RDACS_WONLY)
+				dpot->rdac_cache[reg & DPOT_RDAC_MASK] = value;
+
+			if (dpot->feat & F_AD_APPDATA) {
+				if (dpot->feat & F_SPI_8BIT) {
+					val = ((reg & DPOT_RDAC_MASK) <<
+						DPOT_MAX_POS(dpot->devid)) |
+						value;
+					return dpot_write_d8(dpot, val);
+				} else if (dpot->feat & F_SPI_16BIT) {
+					val = ((reg & DPOT_RDAC_MASK) <<
+						DPOT_MAX_POS(dpot->devid)) |
+						value;
+					return dpot_write_r8d8(dpot, val >> 8,
+						val & 0xFF);
+				} else
+					BUG();
+			} else {
+				if (dpot->uid == DPOT_UID(AD5291_ID) ||
+					dpot->uid == DPOT_UID(AD5292_ID) ||
+					dpot->uid == DPOT_UID(AD5293_ID))
+					return dpot_write_r8d8(dpot,
+						(DPOT_AD5291_RDAC << 2) |
+						(value >> 8), value & 0xFF);
+
+				val = DPOT_SPI_RDAC | (reg & DPOT_RDAC_MASK);
+			}
+		} else if (reg & DPOT_ADDR_EEPROM) {
+			val = DPOT_SPI_EEPROM | (reg & DPOT_RDAC_MASK);
+		} else if (reg & DPOT_ADDR_CMD) {
+			switch (reg) {
+			case DPOT_DEC_ALL_6DB:
+				val = DPOT_SPI_DEC_ALL_6DB;
+				break;
+			case DPOT_INC_ALL_6DB:
+				val = DPOT_SPI_INC_ALL_6DB;
+				break;
+			case DPOT_DEC_ALL:
+				val = DPOT_SPI_DEC_ALL;
+				break;
+			case DPOT_INC_ALL:
+				val = DPOT_SPI_INC_ALL;
+				break;
+			}
+		} else
+			BUG();
+
+		if (dpot->feat & F_SPI_16BIT)
+			return dpot_write_r8d8(dpot, val, value);
+		else if (dpot->feat & F_SPI_24BIT)
+			return dpot_write_r8d16(dpot, val, value);
+	} else {
+		/* Only write the instruction byte for certain commands */
+		if (reg & DPOT_ADDR_CMD)
+			return dpot_write_d8(dpot, reg);
+
+		if (dpot->max_pos > 256)
+			return dpot_write_r8d16(dpot, (reg & 0xF8) |
+						((reg & 0x7) << 1), value);
+		else
+			/* All other registers require instruction + data bytes */
+			return dpot_write_r8d8(dpot, reg, value);
+
+	}
+
+	return -EFAULT;
+}
+
 /* sysfs functions */
 
 static ssize_t sysfs_show_reg(struct device *dev,
-			      struct device_attribute *attr, char *buf, u32 reg)
+			      struct device_attribute *attr,
+			      char *buf, u32 reg)
 {
-	struct i2c_client *client = to_i2c_client(dev);
-	struct dpot_data *data = i2c_get_clientdata(client);
+	struct dpot_data *data = dev_get_drvdata(dev);
 	s32 value;
 
 	mutex_lock(&data->update_lock);
-	value = ad525x_read(client, reg);
+	value = dpot_read(data, reg);
 	mutex_unlock(&data->update_lock);
 
 	if (value < 0)
@@ -111,7 +242,7 @@ static ssize_t sysfs_show_reg(struct device *dev,
 	 * datasheet (Rev. A) for more details.
 	 */
 
-	if (reg & AD525X_REG_TOL)
+	if (reg & DPOT_REG_TOL)
 		return sprintf(buf, "0x%04x\n", value & 0xFFFF);
 	else
 		return sprintf(buf, "%u\n", value & data->rdac_mask);
@@ -121,8 +252,7 @@ static ssize_t sysfs_set_reg(struct device *dev,
 			     struct device_attribute *attr,
 			     const char *buf, size_t count, u32 reg)
 {
-	struct i2c_client *client = to_i2c_client(dev);
-	struct dpot_data *data = i2c_get_clientdata(client);
+	struct dpot_data *data = dev_get_drvdata(dev);
 	unsigned long value;
 	int err;
 
@@ -134,8 +264,8 @@ static ssize_t sysfs_set_reg(struct device *dev,
 		value = data->rdac_mask;
 
 	mutex_lock(&data->update_lock);
-	ad525x_write(client, reg, value);
-	if (reg & AD525X_I2C_EEPROM)
+	dpot_write(data, reg, value);
+	if (reg & DPOT_ADDR_EEPROM)
 		msleep(26);	/* Sleep while the EEPROM updates */
 	mutex_unlock(&data->update_lock);
 
@@ -146,11 +276,10 @@ static ssize_t sysfs_do_cmd(struct device *dev,
 			    struct device_attribute *attr,
 			    const char *buf, size_t count, u32 reg)
 {
-	struct i2c_client *client = to_i2c_client(dev);
-	struct dpot_data *data = i2c_get_clientdata(client);
+	struct dpot_data *data = dev_get_drvdata(dev);
 
 	mutex_lock(&data->update_lock);
-	ad525x_write(client, reg, 0);
+	dpot_write(data, reg, 0);
 	mutex_unlock(&data->update_lock);
 
 	return count;
@@ -182,51 +311,58 @@ static DEVICE_ATTR(name, S_IWUSR | S_IRUGO, show_##name, set_##name);
 DPOT_DEVICE_SHOW(name, reg) \
 static DEVICE_ATTR(name, S_IWUSR | S_IRUGO, show_##name, NULL);
 
-DPOT_DEVICE_SHOW_SET(rdac0, AD525X_I2C_RDAC | AD525X_RDAC0);
-DPOT_DEVICE_SHOW_SET(eeprom0, AD525X_I2C_EEPROM | AD525X_RDAC0);
-DPOT_DEVICE_SHOW_ONLY(tolerance0, AD525X_I2C_EEPROM | AD525X_TOL_RDAC0);
-
-DPOT_DEVICE_SHOW_SET(rdac1, AD525X_I2C_RDAC | AD525X_RDAC1);
-DPOT_DEVICE_SHOW_SET(eeprom1, AD525X_I2C_EEPROM | AD525X_RDAC1);
-DPOT_DEVICE_SHOW_ONLY(tolerance1, AD525X_I2C_EEPROM | AD525X_TOL_RDAC1);
-
-DPOT_DEVICE_SHOW_SET(rdac2, AD525X_I2C_RDAC | AD525X_RDAC2);
-DPOT_DEVICE_SHOW_SET(eeprom2, AD525X_I2C_EEPROM | AD525X_RDAC2);
-DPOT_DEVICE_SHOW_ONLY(tolerance2, AD525X_I2C_EEPROM | AD525X_TOL_RDAC2);
-
-DPOT_DEVICE_SHOW_SET(rdac3, AD525X_I2C_RDAC | AD525X_RDAC3);
-DPOT_DEVICE_SHOW_SET(eeprom3, AD525X_I2C_EEPROM | AD525X_RDAC3);
-DPOT_DEVICE_SHOW_ONLY(tolerance3, AD525X_I2C_EEPROM | AD525X_TOL_RDAC3);
-
-static struct attribute *ad525x_attributes_wipers[4][4] = {
-	{
-		&dev_attr_rdac0.attr,
-		&dev_attr_eeprom0.attr,
-		&dev_attr_tolerance0.attr,
-		NULL
-	}, {
-		&dev_attr_rdac1.attr,
-		&dev_attr_eeprom1.attr,
-		&dev_attr_tolerance1.attr,
-		NULL
-	}, {
-		&dev_attr_rdac2.attr,
-		&dev_attr_eeprom2.attr,
-		&dev_attr_tolerance2.attr,
-		NULL
-	}, {
-		&dev_attr_rdac3.attr,
-		&dev_attr_eeprom3.attr,
-		&dev_attr_tolerance3.attr,
-		NULL
-	}
+DPOT_DEVICE_SHOW_SET(rdac0, DPOT_ADDR_RDAC | DPOT_RDAC0);
+DPOT_DEVICE_SHOW_SET(eeprom0, DPOT_ADDR_EEPROM | DPOT_RDAC0);
+DPOT_DEVICE_SHOW_ONLY(tolerance0, DPOT_ADDR_EEPROM | DPOT_TOL_RDAC0);
+
+DPOT_DEVICE_SHOW_SET(rdac1, DPOT_ADDR_RDAC | DPOT_RDAC1);
+DPOT_DEVICE_SHOW_SET(eeprom1, DPOT_ADDR_EEPROM | DPOT_RDAC1);
+DPOT_DEVICE_SHOW_ONLY(tolerance1, DPOT_ADDR_EEPROM | DPOT_TOL_RDAC1);
+
+DPOT_DEVICE_SHOW_SET(rdac2, DPOT_ADDR_RDAC | DPOT_RDAC2);
+DPOT_DEVICE_SHOW_SET(eeprom2, DPOT_ADDR_EEPROM | DPOT_RDAC2);
+DPOT_DEVICE_SHOW_ONLY(tolerance2, DPOT_ADDR_EEPROM | DPOT_TOL_RDAC2);
+
+DPOT_DEVICE_SHOW_SET(rdac3, DPOT_ADDR_RDAC | DPOT_RDAC3);
+DPOT_DEVICE_SHOW_SET(eeprom3, DPOT_ADDR_EEPROM | DPOT_RDAC3);
+DPOT_DEVICE_SHOW_ONLY(tolerance3, DPOT_ADDR_EEPROM | DPOT_TOL_RDAC3);
+
+DPOT_DEVICE_SHOW_SET(rdac4, DPOT_ADDR_RDAC | DPOT_RDAC4);
+DPOT_DEVICE_SHOW_SET(eeprom4, DPOT_ADDR_EEPROM | DPOT_RDAC4);
+DPOT_DEVICE_SHOW_ONLY(tolerance4, DPOT_ADDR_EEPROM | DPOT_TOL_RDAC4);
+
+DPOT_DEVICE_SHOW_SET(rdac5, DPOT_ADDR_RDAC | DPOT_RDAC5);
+DPOT_DEVICE_SHOW_SET(eeprom5, DPOT_ADDR_EEPROM | DPOT_RDAC5);
+DPOT_DEVICE_SHOW_ONLY(tolerance5, DPOT_ADDR_EEPROM | DPOT_TOL_RDAC5);
+
+static const struct attribute *dpot_attrib_wipers[] = {
+	&dev_attr_rdac0.attr,
+	&dev_attr_rdac1.attr,
+	&dev_attr_rdac2.attr,
+	&dev_attr_rdac3.attr,
+	&dev_attr_rdac4.attr,
+	&dev_attr_rdac5.attr,
+	NULL
+};
+
+static const struct attribute *dpot_attrib_eeprom[] = {
+	&dev_attr_eeprom0.attr,
+	&dev_attr_eeprom1.attr,
+	&dev_attr_eeprom2.attr,
+	&dev_attr_eeprom3.attr,
+	&dev_attr_eeprom4.attr,
+	&dev_attr_eeprom5.attr,
+	NULL
 };
 
-static const struct attribute_group ad525x_group_wipers[] = {
-	{.attrs = ad525x_attributes_wipers[AD525X_RDAC0]},
-	{.attrs = ad525x_attributes_wipers[AD525X_RDAC1]},
-	{.attrs = ad525x_attributes_wipers[AD525X_RDAC2]},
-	{.attrs = ad525x_attributes_wipers[AD525X_RDAC3]},
+static const struct attribute *dpot_attrib_tolerance[] = {
+	&dev_attr_tolerance0.attr,
+	&dev_attr_tolerance1.attr,
+	&dev_attr_tolerance2.attr,
+	&dev_attr_tolerance3.attr,
+	&dev_attr_tolerance4.attr,
+	&dev_attr_tolerance5.attr,
+	NULL
 };
 
 /* ------------------------------------------------------------------------- */
@@ -240,10 +376,10 @@ set_##_name(struct device *dev, \
 } \
 static DEVICE_ATTR(_name, S_IWUSR | S_IRUGO, NULL, set_##_name);
 
-DPOT_DEVICE_DO_CMD(inc_all, AD525X_INC_ALL);
-DPOT_DEVICE_DO_CMD(dec_all, AD525X_DEC_ALL);
-DPOT_DEVICE_DO_CMD(inc_all_6db, AD525X_INC_ALL_6DB);
-DPOT_DEVICE_DO_CMD(dec_all_6db, AD525X_DEC_ALL_6DB);
+DPOT_DEVICE_DO_CMD(inc_all, DPOT_INC_ALL);
+DPOT_DEVICE_DO_CMD(dec_all, DPOT_DEC_ALL);
+DPOT_DEVICE_DO_CMD(inc_all_6db, DPOT_INC_ALL_6DB);
+DPOT_DEVICE_DO_CMD(dec_all_6db, DPOT_DEC_ALL_6DB);
 
 static struct attribute *ad525x_attributes_commands[] = {
 	&dev_attr_inc_all.attr,
@@ -257,74 +393,44 @@ static const struct attribute_group ad525x_group_commands = {
 	.attrs = ad525x_attributes_commands,
 };
 
-/* ------------------------------------------------------------------------- */
-
-/* i2c device functions */
-
-/**
- * ad525x_read - return the value contained in the specified register
- * on the AD5258 device.
- * @client: value returned from i2c_new_device()
- * @reg: the register to read
- *
- * If the tolerance register is specified, 2 bytes are returned.
- * Otherwise, 1 byte is returned.  A negative value indicates an error
- * occurred while reading the register.
- */
-static s32 ad525x_read(struct i2c_client *client, u8 reg)
+__devinit int ad_dpot_add_files(struct device *dev,
+		unsigned features, unsigned rdac)
 {
-	struct dpot_data *data = i2c_get_clientdata(client);
+	int err = sysfs_create_file(&dev->kobj,
+		dpot_attrib_wipers[rdac]);
+	if (features & F_CMD_EEP)
+		err |= sysfs_create_file(&dev->kobj,
+			dpot_attrib_eeprom[rdac]);
+	if (features & F_CMD_TOL)
+		err |= sysfs_create_file(&dev->kobj,
+			dpot_attrib_tolerance[rdac]);
 
-	if ((reg & AD525X_REG_TOL) || (data->max_pos > 256))
-		return i2c_smbus_read_word_data(client, (reg & 0xF8) |
-						((reg & 0x7) << 1));
-	else
-		return i2c_smbus_read_byte_data(client, reg);
+	if (err)
+		dev_err(dev, "failed to register sysfs hooks for RDAC%d\n",
+			rdac);
+
+	return err;
 }
 
-/**
- * ad525x_write - store the given value in the specified register on
- * the AD5258 device.
- * @client: value returned from i2c_new_device()
- * @reg: the register to write
- * @value: the byte to store in the register
- *
- * For certain instructions that do not require a data byte, "NULL"
- * should be specified for the "value" parameter.  These instructions
- * include NOP, RESTORE_FROM_EEPROM, and STORE_TO_EEPROM.
- *
- * A negative return value indicates an error occurred while reading
- * the register.
- */
-static s32 ad525x_write(struct i2c_client *client, u8 reg, u16 value)
+inline void ad_dpot_remove_files(struct device *dev,
+		unsigned features, unsigned rdac)
 {
-	struct dpot_data *data = i2c_get_clientdata(client);
-
-	/* Only write the instruction byte for certain commands */
-	if (reg & AD525X_I2C_CMD)
-		return i2c_smbus_write_byte(client, reg);
-
-	if (data->max_pos > 256)
-		return i2c_smbus_write_word_data(client, (reg & 0xF8) |
-						((reg & 0x7) << 1), value);
-	else
-		/* All other registers require instruction + data bytes */
-		return i2c_smbus_write_byte_data(client, reg, value);
+	sysfs_remove_file(&dev->kobj,
+		dpot_attrib_wipers[rdac]);
+	if (features & F_CMD_EEP)
+		sysfs_remove_file(&dev->kobj,
+			dpot_attrib_eeprom[rdac]);
+	if (features & F_CMD_TOL)
+		sysfs_remove_file(&dev->kobj,
+			dpot_attrib_tolerance[rdac]);
 }
 
-static int ad525x_probe(struct i2c_client *client,
-			const struct i2c_device_id *id)
+__devinit int ad_dpot_probe(struct device *dev,
+		struct ad_dpot_bus_data *bdata, const struct ad_dpot_id *id)
 {
-	struct device *dev = &client->dev;
-	struct dpot_data *data;
-	int err = 0;
-
-	dev_dbg(dev, "%s\n", __func__);
 
-	if (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE)) {
-		dev_err(dev, "missing I2C functionality for this driver\n");
-		goto exit;
-	}
+	struct dpot_data *data;
+	int i, err = 0;
 
 	data = kzalloc(sizeof(struct dpot_data), GFP_KERNEL);
 	if (!data) {
@@ -332,183 +438,74 @@ static int ad525x_probe(struct i2c_client *client,
 		goto exit;
 	}
 
-	i2c_set_clientdata(client, data);
+	dev_set_drvdata(dev, data);
 	mutex_init(&data->update_lock);
 
-	switch (id->driver_data) {
-	case AD5258_ID:
-		data->max_pos = AD5258_MAX_POSITION;
-		err = sysfs_create_group(&dev->kobj,
-				       &ad525x_group_wipers[AD525X_RDAC0]);
-		break;
-	case AD5259_ID:
-		data->max_pos = AD5259_MAX_POSITION;
-		err = sysfs_create_group(&dev->kobj,
-				       &ad525x_group_wipers[AD525X_RDAC0]);
-		break;
-	case AD5251_ID:
-		data->max_pos = AD5251_MAX_POSITION;
-		err = sysfs_create_group(&dev->kobj,
-				       &ad525x_group_wipers[AD525X_RDAC1]);
-		err |= sysfs_create_group(&dev->kobj,
-				       &ad525x_group_wipers[AD525X_RDAC3]);
-		err |= sysfs_create_group(&dev->kobj, &ad525x_group_commands);
-		break;
-	case AD5252_ID:
-		data->max_pos = AD5252_MAX_POSITION;
-		err = sysfs_create_group(&dev->kobj,
-				       &ad525x_group_wipers[AD525X_RDAC1]);
-		err |= sysfs_create_group(&dev->kobj,
-				       &ad525x_group_wipers[AD525X_RDAC3]);
-		err |= sysfs_create_group(&dev->kobj, &ad525x_group_commands);
-		break;
-	case AD5253_ID:
-		data->max_pos = AD5253_MAX_POSITION;
-		err = sysfs_create_group(&dev->kobj,
-				       &ad525x_group_wipers[AD525X_RDAC0]);
-		err |= sysfs_create_group(&dev->kobj,
-				       &ad525x_group_wipers[AD525X_RDAC1]);
-		err |= sysfs_create_group(&dev->kobj,
-				       &ad525x_group_wipers[AD525X_RDAC2]);
-		err |= sysfs_create_group(&dev->kobj,
-				       &ad525x_group_wipers[AD525X_RDAC3]);
-		err |= sysfs_create_group(&dev->kobj, &ad525x_group_commands);
-		break;
-	case AD5254_ID:
-		data->max_pos = AD5254_MAX_POSITION;
-		err = sysfs_create_group(&dev->kobj,
-				       &ad525x_group_wipers[AD525X_RDAC0]);
-		err |= sysfs_create_group(&dev->kobj,
-				       &ad525x_group_wipers[AD525X_RDAC1]);
-		err |= sysfs_create_group(&dev->kobj,
-				       &ad525x_group_wipers[AD525X_RDAC2]);
-		err |= sysfs_create_group(&dev->kobj,
-				       &ad525x_group_wipers[AD525X_RDAC3]);
-		err |= sysfs_create_group(&dev->kobj, &ad525x_group_commands);
-		break;
-	case AD5255_ID:
-		data->max_pos = AD5255_MAX_POSITION;
-		err = sysfs_create_group(&dev->kobj,
-				       &ad525x_group_wipers[AD525X_RDAC0]);
-		err |= sysfs_create_group(&dev->kobj,
-				       &ad525x_group_wipers[AD525X_RDAC1]);
-		err |= sysfs_create_group(&dev->kobj,
-				       &ad525x_group_wipers[AD525X_RDAC2]);
-		err |= sysfs_create_group(&dev->kobj, &ad525x_group_commands);
-		break;
-	default:
-		err = -ENODEV;
-		goto exit_free;
-	}
+	data->bdata = *bdata;
+	data->devid = id->devid;
+
+	data->max_pos = 1 << DPOT_MAX_POS(data->devid);
+	data->rdac_mask = data->max_pos - 1;
+	data->feat = DPOT_FEAT(data->devid);
+	data->uid = DPOT_UID(data->devid);
+	data->wipers = DPOT_WIPERS(data->devid);
+
+	for (i = DPOT_RDAC0; i <= DPOT_RDAC5; i++)
+		if (data->wipers & (1 << i)) {
+			err = ad_dpot_add_files(dev, data->feat, i);
+			if (err)
+				goto exit_remove_files;
+			/* power-up midscale */
+			if (data->feat & F_RDACS_WONLY)
+				data->rdac_cache[i] = data->max_pos / 2;
+		}
+
+	if (data->feat & F_CMD_INC)
+		err = sysfs_create_group(&dev->kobj, &ad525x_group_commands);
 
 	if (err) {
 		dev_err(dev, "failed to register sysfs hooks\n");
 		goto exit_free;
 	}
 
-	data->devid = id->driver_data;
-	data->rdac_mask = data->max_pos - 1;
-
 	dev_info(dev, "%s %d-Position Digital Potentiometer registered\n",
 		 id->name, data->max_pos);
 
 	return 0;
 
+exit_remove_files:
+	for (i = DPOT_RDAC0; i <= DPOT_RDAC5; i++)
+		if (data->wipers & (1 << i))
+			ad_dpot_remove_files(dev, data->feat, i);
+
 exit_free:
 	kfree(data);
-	i2c_set_clientdata(client, NULL);
+	dev_set_drvdata(dev, NULL);
 exit:
-	dev_err(dev, "failed to create client\n");
+	dev_err(dev, "failed to create client for %s ID 0x%lX\n",
+			id->name, id->devid);
 	return err;
 }
+EXPORT_SYMBOL(ad_dpot_probe);
 
-static int __devexit ad525x_remove(struct i2c_client *client)
+__devexit int ad_dpot_remove(struct device *dev)
 {
-	struct dpot_data *data = i2c_get_clientdata(client);
-	struct device *dev = &client->dev;
-
-	switch (data->devid) {
-	case AD5258_ID:
-	case AD5259_ID:
-		sysfs_remove_group(&dev->kobj,
-				   &ad525x_group_wipers[AD525X_RDAC0]);
-		break;
-	case AD5251_ID:
-	case AD5252_ID:
-		sysfs_remove_group(&dev->kobj,
-				   &ad525x_group_wipers[AD525X_RDAC1]);
-		sysfs_remove_group(&dev->kobj,
-				   &ad525x_group_wipers[AD525X_RDAC3]);
-		sysfs_remove_group(&dev->kobj, &ad525x_group_commands);
-		break;
-	case AD5253_ID:
-	case AD5254_ID:
-		sysfs_remove_group(&dev->kobj,
-				   &ad525x_group_wipers[AD525X_RDAC0]);
-		sysfs_remove_group(&dev->kobj,
-				   &ad525x_group_wipers[AD525X_RDAC1]);
-		sysfs_remove_group(&dev->kobj,
-				   &ad525x_group_wipers[AD525X_RDAC2]);
-		sysfs_remove_group(&dev->kobj,
-				   &ad525x_group_wipers[AD525X_RDAC3]);
-		sysfs_remove_group(&dev->kobj, &ad525x_group_commands);
-		break;
-	case AD5255_ID:
-		sysfs_remove_group(&dev->kobj,
-				   &ad525x_group_wipers[AD525X_RDAC0]);
-		sysfs_remove_group(&dev->kobj,
-				   &ad525x_group_wipers[AD525X_RDAC1]);
-		sysfs_remove_group(&dev->kobj,
-				   &ad525x_group_wipers[AD525X_RDAC2]);
-		sysfs_remove_group(&dev->kobj, &ad525x_group_commands);
-		break;
-	}
+	struct dpot_data *data = dev_get_drvdata(dev);
+	int i;
+
+	for (i = DPOT_RDAC0; i <= DPOT_RDAC5; i++)
+		if (data->wipers & (1 << i))
+			ad_dpot_remove_files(dev, data->feat, i);
 
-	i2c_set_clientdata(client, NULL);
 	kfree(data);
 
 	return 0;
 }
+EXPORT_SYMBOL(ad_dpot_remove);
 
-static const struct i2c_device_id ad525x_idtable[] = {
-	{"ad5258", AD5258_ID},
-	{"ad5259", AD5259_ID},
-	{"ad5251", AD5251_ID},
-	{"ad5252", AD5252_ID},
-	{"ad5253", AD5253_ID},
-	{"ad5254", AD5254_ID},
-	{"ad5255", AD5255_ID},
-	{}
-};
-
-MODULE_DEVICE_TABLE(i2c, ad525x_idtable);
-
-static struct i2c_driver ad525x_driver = {
-	.driver = {
-		   .owner = THIS_MODULE,
-		   .name = DRIVER_NAME,
-		   },
-	.id_table = ad525x_idtable,
-	.probe = ad525x_probe,
-	.remove = __devexit_p(ad525x_remove),
-};
-
-static int __init ad525x_init(void)
-{
-	return i2c_add_driver(&ad525x_driver);
-}
-
-module_init(ad525x_init);
-
-static void __exit ad525x_exit(void)
-{
-	i2c_del_driver(&ad525x_driver);
-}
-
-module_exit(ad525x_exit);
 
 MODULE_AUTHOR("Chris Verges <chrisv@cyberswitching.com>, "
-	      "Michael Hennerich <hennerich@blackfin.uclinux.org>, ");
-MODULE_DESCRIPTION("AD5258/9 digital potentiometer driver");
+	      "Michael Hennerich <hennerich@blackfin.uclinux.org>");
+MODULE_DESCRIPTION("Digital potentiometer driver");
 MODULE_LICENSE("GPL");
 MODULE_VERSION(DRIVER_VERSION);

commit 0c53b9fbcca8870e4f4b248f4ed5fdadd43a01b6
Author: Michael Hennerich <michael.hennerich@analog.com>
Date:   Mon May 24 14:33:13 2010 -0700

    ad525x_dpot: extend write argument to 16bits
    
    The possible output data is 16bits, not 8bits, so don't truncate it.
    
    Signed-off-by: Michael Hennerich <michael.hennerich@analog.com>
    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/misc/ad525x_dpot.c b/drivers/misc/ad525x_dpot.c
index e6b274b5dbd6..ce92088bf0b8 100644
--- a/drivers/misc/ad525x_dpot.c
+++ b/drivers/misc/ad525x_dpot.c
@@ -75,7 +75,7 @@ enum dpot_devid {
 #define AD525X_INC_ALL		(AD525X_I2C_CMD | (0xB << 3))
 
 static s32 ad525x_read(struct i2c_client *client, u8 reg);
-static s32 ad525x_write(struct i2c_client *client, u8 reg, u8 value);
+static s32 ad525x_write(struct i2c_client *client, u8 reg, u16 value);
 
 /*
  * Client data (each client gets its own)
@@ -296,7 +296,7 @@ static s32 ad525x_read(struct i2c_client *client, u8 reg)
  * A negative return value indicates an error occurred while reading
  * the register.
  */
-static s32 ad525x_write(struct i2c_client *client, u8 reg, u8 value)
+static s32 ad525x_write(struct i2c_client *client, u8 reg, u16 value)
 {
 	struct dpot_data *data = i2c_get_clientdata(client);
 

commit 0993dbedf2cc2f5fd0701fa3b27afdd303536b87
Author: Michael Hennerich <michael.hennerich@analog.com>
Date:   Mon May 24 14:33:13 2010 -0700

    ad525x_dpot: simplify duplicated sysfs defines
    
    Macro away the duplication to make maintenance easier.
    
    Signed-off-by: Michael Hennerich <michael.hennerich@analog.com>
    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/misc/ad525x_dpot.c b/drivers/misc/ad525x_dpot.c
index 30a59f2bacd2..e6b274b5dbd6 100644
--- a/drivers/misc/ad525x_dpot.c
+++ b/drivers/misc/ad525x_dpot.c
@@ -158,175 +158,45 @@ static ssize_t sysfs_do_cmd(struct device *dev,
 
 /* ------------------------------------------------------------------------- */
 
-static ssize_t show_rdac0(struct device *dev,
-			  struct device_attribute *attr, char *buf)
-{
-	return sysfs_show_reg(dev, attr, buf, AD525X_I2C_RDAC | AD525X_RDAC0);
-}
-
-static ssize_t set_rdac0(struct device *dev,
-			 struct device_attribute *attr,
-			 const char *buf, size_t count)
-{
-	return sysfs_set_reg(dev, attr, buf, count,
-			     AD525X_I2C_RDAC | AD525X_RDAC0);
-}
-
-static DEVICE_ATTR(rdac0, S_IWUSR | S_IRUGO, show_rdac0, set_rdac0);
-
-static ssize_t show_eeprom0(struct device *dev,
-			    struct device_attribute *attr, char *buf)
-{
-	return sysfs_show_reg(dev, attr, buf, AD525X_I2C_EEPROM | AD525X_RDAC0);
-}
-
-static ssize_t set_eeprom0(struct device *dev,
-			   struct device_attribute *attr,
-			   const char *buf, size_t count)
-{
-	return sysfs_set_reg(dev, attr, buf, count,
-			     AD525X_I2C_EEPROM | AD525X_RDAC0);
-}
-
-static DEVICE_ATTR(eeprom0, S_IWUSR | S_IRUGO, show_eeprom0, set_eeprom0);
-
-static ssize_t show_tolerance0(struct device *dev,
-			       struct device_attribute *attr, char *buf)
-{
-	return sysfs_show_reg(dev, attr, buf,
-			      AD525X_I2C_EEPROM | AD525X_TOL_RDAC0);
-}
-
-static DEVICE_ATTR(tolerance0, S_IRUGO, show_tolerance0, NULL);
-
-/* ------------------------------------------------------------------------- */
-
-static ssize_t show_rdac1(struct device *dev,
-			  struct device_attribute *attr, char *buf)
-{
-	return sysfs_show_reg(dev, attr, buf, AD525X_I2C_RDAC | AD525X_RDAC1);
+#define DPOT_DEVICE_SHOW(_name, _reg) static ssize_t \
+show_##_name(struct device *dev, \
+			  struct device_attribute *attr, char *buf) \
+{ \
+	return sysfs_show_reg(dev, attr, buf, _reg); \
 }
 
-static ssize_t set_rdac1(struct device *dev,
-			 struct device_attribute *attr,
-			 const char *buf, size_t count)
-{
-	return sysfs_set_reg(dev, attr, buf, count,
-			     AD525X_I2C_RDAC | AD525X_RDAC1);
+#define DPOT_DEVICE_SET(_name, _reg) static ssize_t \
+set_##_name(struct device *dev, \
+			 struct device_attribute *attr, \
+			 const char *buf, size_t count) \
+{ \
+	return sysfs_set_reg(dev, attr, buf, count, _reg); \
 }
 
-static DEVICE_ATTR(rdac1, S_IWUSR | S_IRUGO, show_rdac1, set_rdac1);
+#define DPOT_DEVICE_SHOW_SET(name, reg) \
+DPOT_DEVICE_SHOW(name, reg) \
+DPOT_DEVICE_SET(name, reg) \
+static DEVICE_ATTR(name, S_IWUSR | S_IRUGO, show_##name, set_##name);
 
-static ssize_t show_eeprom1(struct device *dev,
-			    struct device_attribute *attr, char *buf)
-{
-	return sysfs_show_reg(dev, attr, buf, AD525X_I2C_EEPROM | AD525X_RDAC1);
-}
+#define DPOT_DEVICE_SHOW_ONLY(name, reg) \
+DPOT_DEVICE_SHOW(name, reg) \
+static DEVICE_ATTR(name, S_IWUSR | S_IRUGO, show_##name, NULL);
 
-static ssize_t set_eeprom1(struct device *dev,
-			   struct device_attribute *attr,
-			   const char *buf, size_t count)
-{
-	return sysfs_set_reg(dev, attr, buf, count,
-			     AD525X_I2C_EEPROM | AD525X_RDAC1);
-}
+DPOT_DEVICE_SHOW_SET(rdac0, AD525X_I2C_RDAC | AD525X_RDAC0);
+DPOT_DEVICE_SHOW_SET(eeprom0, AD525X_I2C_EEPROM | AD525X_RDAC0);
+DPOT_DEVICE_SHOW_ONLY(tolerance0, AD525X_I2C_EEPROM | AD525X_TOL_RDAC0);
 
-static DEVICE_ATTR(eeprom1, S_IWUSR | S_IRUGO, show_eeprom1, set_eeprom1);
+DPOT_DEVICE_SHOW_SET(rdac1, AD525X_I2C_RDAC | AD525X_RDAC1);
+DPOT_DEVICE_SHOW_SET(eeprom1, AD525X_I2C_EEPROM | AD525X_RDAC1);
+DPOT_DEVICE_SHOW_ONLY(tolerance1, AD525X_I2C_EEPROM | AD525X_TOL_RDAC1);
 
-static ssize_t show_tolerance1(struct device *dev,
-			       struct device_attribute *attr, char *buf)
-{
-	return sysfs_show_reg(dev, attr, buf,
-			      AD525X_I2C_EEPROM | AD525X_TOL_RDAC1);
-}
-
-static DEVICE_ATTR(tolerance1, S_IRUGO, show_tolerance1, NULL);
+DPOT_DEVICE_SHOW_SET(rdac2, AD525X_I2C_RDAC | AD525X_RDAC2);
+DPOT_DEVICE_SHOW_SET(eeprom2, AD525X_I2C_EEPROM | AD525X_RDAC2);
+DPOT_DEVICE_SHOW_ONLY(tolerance2, AD525X_I2C_EEPROM | AD525X_TOL_RDAC2);
 
-/* ------------------------------------------------------------------------- */
-
-static ssize_t show_rdac2(struct device *dev,
-			  struct device_attribute *attr, char *buf)
-{
-	return sysfs_show_reg(dev, attr, buf, AD525X_I2C_RDAC | AD525X_RDAC2);
-}
-
-static ssize_t set_rdac2(struct device *dev,
-			 struct device_attribute *attr,
-			 const char *buf, size_t count)
-{
-	return sysfs_set_reg(dev, attr, buf, count,
-			     AD525X_I2C_RDAC | AD525X_RDAC2);
-}
-
-static DEVICE_ATTR(rdac2, S_IWUSR | S_IRUGO, show_rdac2, set_rdac2);
-
-static ssize_t show_eeprom2(struct device *dev,
-			    struct device_attribute *attr, char *buf)
-{
-	return sysfs_show_reg(dev, attr, buf, AD525X_I2C_EEPROM | AD525X_RDAC2);
-}
-
-static ssize_t set_eeprom2(struct device *dev,
-			   struct device_attribute *attr,
-			   const char *buf, size_t count)
-{
-	return sysfs_set_reg(dev, attr, buf, count,
-			     AD525X_I2C_EEPROM | AD525X_RDAC2);
-}
-
-static DEVICE_ATTR(eeprom2, S_IWUSR | S_IRUGO, show_eeprom2, set_eeprom2);
-
-static ssize_t show_tolerance2(struct device *dev,
-			       struct device_attribute *attr, char *buf)
-{
-	return sysfs_show_reg(dev, attr, buf,
-			      AD525X_I2C_EEPROM | AD525X_TOL_RDAC2);
-}
-
-static DEVICE_ATTR(tolerance2, S_IRUGO, show_tolerance2, NULL);
-
-/* ------------------------------------------------------------------------- */
-
-static ssize_t show_rdac3(struct device *dev,
-			  struct device_attribute *attr, char *buf)
-{
-	return sysfs_show_reg(dev, attr, buf, AD525X_I2C_RDAC | AD525X_RDAC3);
-}
-
-static ssize_t set_rdac3(struct device *dev,
-			 struct device_attribute *attr,
-			 const char *buf, size_t count)
-{
-	return sysfs_set_reg(dev, attr, buf, count,
-			     AD525X_I2C_RDAC | AD525X_RDAC3);
-}
-
-static DEVICE_ATTR(rdac3, S_IWUSR | S_IRUGO, show_rdac3, set_rdac3);
-
-static ssize_t show_eeprom3(struct device *dev,
-			    struct device_attribute *attr, char *buf)
-{
-	return sysfs_show_reg(dev, attr, buf, AD525X_I2C_EEPROM | AD525X_RDAC3);
-}
-
-static ssize_t set_eeprom3(struct device *dev,
-			   struct device_attribute *attr,
-			   const char *buf, size_t count)
-{
-	return sysfs_set_reg(dev, attr, buf, count,
-			     AD525X_I2C_EEPROM | AD525X_RDAC3);
-}
-
-static DEVICE_ATTR(eeprom3, S_IWUSR | S_IRUGO, show_eeprom3, set_eeprom3);
-
-static ssize_t show_tolerance3(struct device *dev,
-			       struct device_attribute *attr, char *buf)
-{
-	return sysfs_show_reg(dev, attr, buf,
-			      AD525X_I2C_EEPROM | AD525X_TOL_RDAC3);
-}
-
-static DEVICE_ATTR(tolerance3, S_IRUGO, show_tolerance3, NULL);
+DPOT_DEVICE_SHOW_SET(rdac3, AD525X_I2C_RDAC | AD525X_RDAC3);
+DPOT_DEVICE_SHOW_SET(eeprom3, AD525X_I2C_EEPROM | AD525X_RDAC3);
+DPOT_DEVICE_SHOW_ONLY(tolerance3, AD525X_I2C_EEPROM | AD525X_TOL_RDAC3);
 
 static struct attribute *ad525x_attributes_wipers[4][4] = {
 	{
@@ -361,41 +231,19 @@ static const struct attribute_group ad525x_group_wipers[] = {
 
 /* ------------------------------------------------------------------------- */
 
-static ssize_t set_inc_all(struct device *dev,
-			   struct device_attribute *attr,
-			   const char *buf, size_t count)
-{
-	return sysfs_do_cmd(dev, attr, buf, count, AD525X_INC_ALL);
-}
-
-static DEVICE_ATTR(inc_all, S_IWUSR, NULL, set_inc_all);
-
-static ssize_t set_dec_all(struct device *dev,
-			   struct device_attribute *attr,
-			   const char *buf, size_t count)
-{
-	return sysfs_do_cmd(dev, attr, buf, count, AD525X_DEC_ALL);
-}
-
-static DEVICE_ATTR(dec_all, S_IWUSR, NULL, set_dec_all);
-
-static ssize_t set_inc_all_6db(struct device *dev,
-			       struct device_attribute *attr,
-			       const char *buf, size_t count)
-{
-	return sysfs_do_cmd(dev, attr, buf, count, AD525X_INC_ALL_6DB);
-}
-
-static DEVICE_ATTR(inc_all_6db, S_IWUSR, NULL, set_inc_all_6db);
-
-static ssize_t set_dec_all_6db(struct device *dev,
-			       struct device_attribute *attr,
-			       const char *buf, size_t count)
-{
-	return sysfs_do_cmd(dev, attr, buf, count, AD525X_DEC_ALL_6DB);
-}
-
-static DEVICE_ATTR(dec_all_6db, S_IWUSR, NULL, set_dec_all_6db);
+#define DPOT_DEVICE_DO_CMD(_name, _cmd) static ssize_t \
+set_##_name(struct device *dev, \
+			 struct device_attribute *attr, \
+			 const char *buf, size_t count) \
+{ \
+	return sysfs_do_cmd(dev, attr, buf, count, _cmd); \
+} \
+static DEVICE_ATTR(_name, S_IWUSR | S_IRUGO, NULL, set_##_name);
+
+DPOT_DEVICE_DO_CMD(inc_all, AD525X_INC_ALL);
+DPOT_DEVICE_DO_CMD(dec_all, AD525X_DEC_ALL);
+DPOT_DEVICE_DO_CMD(inc_all_6db, AD525X_INC_ALL_6DB);
+DPOT_DEVICE_DO_CMD(dec_all_6db, AD525X_DEC_ALL_6DB);
 
 static struct attribute *ad525x_attributes_commands[] = {
 	&dev_attr_inc_all.attr,

commit 4eb174bee6f8623fed1af0072f1bebfc3b513a52
Author: Michael Hennerich <michael.hennerich@analog.com>
Date:   Mon Dec 14 18:00:15 2009 -0800

    ad525x_dpot: new driver for AD525x digital potentiometers
    
    This driver supports the non-volatile digital potentiometers via I2C:
    AD5258, AD5259, AD5251, AD5252, AD5253, AD5254, and AD5255
    
    It provides a sysfs interface to each device for reading/writing which
    is documented in Documentation/misc-devices/ad525x_dpot.txt.
    
    Signed-off-by: Michael Hennerich <michael.hennerich@analog.com>
    Signed-off-by: Chris Verges <chrisv@cyberswitching.com>
    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
    Cc: Jean Delvare <khali@linux-fr.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/misc/ad525x_dpot.c b/drivers/misc/ad525x_dpot.c
new file mode 100644
index 000000000000..30a59f2bacd2
--- /dev/null
+++ b/drivers/misc/ad525x_dpot.c
@@ -0,0 +1,666 @@
+/*
+ * ad525x_dpot: Driver for the Analog Devices AD525x digital potentiometers
+ * Copyright (c) 2009 Analog Devices, Inc.
+ * Author: Michael Hennerich <hennerich@blackfin.uclinux.org>
+ *
+ * DEVID		#Wipers		#Positions 	Resistor Options (kOhm)
+ * AD5258		1		64		1, 10, 50, 100
+ * AD5259		1		256		5, 10, 50, 100
+ * AD5251		2		64		1, 10, 50, 100
+ * AD5252		2		256		1, 10, 50, 100
+ * AD5255		3		512		25, 250
+ * AD5253		4		64		1, 10, 50, 100
+ * AD5254		4		256		1, 10, 50, 100
+ *
+ * See Documentation/misc-devices/ad525x_dpot.txt for more info.
+ *
+ * derived from ad5258.c
+ * Copyright (c) 2009 Cyber Switching, Inc.
+ * Author: Chris Verges <chrisv@cyberswitching.com>
+ *
+ * derived from ad5252.c
+ * Copyright (c) 2006 Michael Hennerich <hennerich@blackfin.uclinux.org>
+ *
+ * Licensed under the GPL-2 or later.
+ */
+
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+
+#define DRIVER_NAME			"ad525x_dpot"
+#define DRIVER_VERSION			"0.1"
+
+enum dpot_devid {
+	AD5258_ID,
+	AD5259_ID,
+	AD5251_ID,
+	AD5252_ID,
+	AD5253_ID,
+	AD5254_ID,
+	AD5255_ID,
+};
+
+#define AD5258_MAX_POSITION		64
+#define AD5259_MAX_POSITION		256
+#define AD5251_MAX_POSITION		64
+#define AD5252_MAX_POSITION		256
+#define AD5253_MAX_POSITION		64
+#define AD5254_MAX_POSITION		256
+#define AD5255_MAX_POSITION		512
+
+#define AD525X_RDAC0		0
+#define AD525X_RDAC1		1
+#define AD525X_RDAC2		2
+#define AD525X_RDAC3		3
+
+#define AD525X_REG_TOL		0x18
+#define AD525X_TOL_RDAC0	(AD525X_REG_TOL | AD525X_RDAC0)
+#define AD525X_TOL_RDAC1	(AD525X_REG_TOL | AD525X_RDAC1)
+#define AD525X_TOL_RDAC2	(AD525X_REG_TOL | AD525X_RDAC2)
+#define AD525X_TOL_RDAC3	(AD525X_REG_TOL | AD525X_RDAC3)
+
+/* RDAC-to-EEPROM Interface Commands */
+#define AD525X_I2C_RDAC		(0x00 << 5)
+#define AD525X_I2C_EEPROM	(0x01 << 5)
+#define AD525X_I2C_CMD		(0x80)
+
+#define AD525X_DEC_ALL_6DB	(AD525X_I2C_CMD | (0x4 << 3))
+#define AD525X_INC_ALL_6DB	(AD525X_I2C_CMD | (0x9 << 3))
+#define AD525X_DEC_ALL		(AD525X_I2C_CMD | (0x6 << 3))
+#define AD525X_INC_ALL		(AD525X_I2C_CMD | (0xB << 3))
+
+static s32 ad525x_read(struct i2c_client *client, u8 reg);
+static s32 ad525x_write(struct i2c_client *client, u8 reg, u8 value);
+
+/*
+ * Client data (each client gets its own)
+ */
+
+struct dpot_data {
+	struct mutex update_lock;
+	unsigned rdac_mask;
+	unsigned max_pos;
+	unsigned devid;
+};
+
+/* sysfs functions */
+
+static ssize_t sysfs_show_reg(struct device *dev,
+			      struct device_attribute *attr, char *buf, u32 reg)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct dpot_data *data = i2c_get_clientdata(client);
+	s32 value;
+
+	mutex_lock(&data->update_lock);
+	value = ad525x_read(client, reg);
+	mutex_unlock(&data->update_lock);
+
+	if (value < 0)
+		return -EINVAL;
+	/*
+	 * Let someone else deal with converting this ...
+	 * the tolerance is a two-byte value where the MSB
+	 * is a sign + integer value, and the LSB is a
+	 * decimal value.  See page 18 of the AD5258
+	 * datasheet (Rev. A) for more details.
+	 */
+
+	if (reg & AD525X_REG_TOL)
+		return sprintf(buf, "0x%04x\n", value & 0xFFFF);
+	else
+		return sprintf(buf, "%u\n", value & data->rdac_mask);
+}
+
+static ssize_t sysfs_set_reg(struct device *dev,
+			     struct device_attribute *attr,
+			     const char *buf, size_t count, u32 reg)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct dpot_data *data = i2c_get_clientdata(client);
+	unsigned long value;
+	int err;
+
+	err = strict_strtoul(buf, 10, &value);
+	if (err)
+		return err;
+
+	if (value > data->rdac_mask)
+		value = data->rdac_mask;
+
+	mutex_lock(&data->update_lock);
+	ad525x_write(client, reg, value);
+	if (reg & AD525X_I2C_EEPROM)
+		msleep(26);	/* Sleep while the EEPROM updates */
+	mutex_unlock(&data->update_lock);
+
+	return count;
+}
+
+static ssize_t sysfs_do_cmd(struct device *dev,
+			    struct device_attribute *attr,
+			    const char *buf, size_t count, u32 reg)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct dpot_data *data = i2c_get_clientdata(client);
+
+	mutex_lock(&data->update_lock);
+	ad525x_write(client, reg, 0);
+	mutex_unlock(&data->update_lock);
+
+	return count;
+}
+
+/* ------------------------------------------------------------------------- */
+
+static ssize_t show_rdac0(struct device *dev,
+			  struct device_attribute *attr, char *buf)
+{
+	return sysfs_show_reg(dev, attr, buf, AD525X_I2C_RDAC | AD525X_RDAC0);
+}
+
+static ssize_t set_rdac0(struct device *dev,
+			 struct device_attribute *attr,
+			 const char *buf, size_t count)
+{
+	return sysfs_set_reg(dev, attr, buf, count,
+			     AD525X_I2C_RDAC | AD525X_RDAC0);
+}
+
+static DEVICE_ATTR(rdac0, S_IWUSR | S_IRUGO, show_rdac0, set_rdac0);
+
+static ssize_t show_eeprom0(struct device *dev,
+			    struct device_attribute *attr, char *buf)
+{
+	return sysfs_show_reg(dev, attr, buf, AD525X_I2C_EEPROM | AD525X_RDAC0);
+}
+
+static ssize_t set_eeprom0(struct device *dev,
+			   struct device_attribute *attr,
+			   const char *buf, size_t count)
+{
+	return sysfs_set_reg(dev, attr, buf, count,
+			     AD525X_I2C_EEPROM | AD525X_RDAC0);
+}
+
+static DEVICE_ATTR(eeprom0, S_IWUSR | S_IRUGO, show_eeprom0, set_eeprom0);
+
+static ssize_t show_tolerance0(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	return sysfs_show_reg(dev, attr, buf,
+			      AD525X_I2C_EEPROM | AD525X_TOL_RDAC0);
+}
+
+static DEVICE_ATTR(tolerance0, S_IRUGO, show_tolerance0, NULL);
+
+/* ------------------------------------------------------------------------- */
+
+static ssize_t show_rdac1(struct device *dev,
+			  struct device_attribute *attr, char *buf)
+{
+	return sysfs_show_reg(dev, attr, buf, AD525X_I2C_RDAC | AD525X_RDAC1);
+}
+
+static ssize_t set_rdac1(struct device *dev,
+			 struct device_attribute *attr,
+			 const char *buf, size_t count)
+{
+	return sysfs_set_reg(dev, attr, buf, count,
+			     AD525X_I2C_RDAC | AD525X_RDAC1);
+}
+
+static DEVICE_ATTR(rdac1, S_IWUSR | S_IRUGO, show_rdac1, set_rdac1);
+
+static ssize_t show_eeprom1(struct device *dev,
+			    struct device_attribute *attr, char *buf)
+{
+	return sysfs_show_reg(dev, attr, buf, AD525X_I2C_EEPROM | AD525X_RDAC1);
+}
+
+static ssize_t set_eeprom1(struct device *dev,
+			   struct device_attribute *attr,
+			   const char *buf, size_t count)
+{
+	return sysfs_set_reg(dev, attr, buf, count,
+			     AD525X_I2C_EEPROM | AD525X_RDAC1);
+}
+
+static DEVICE_ATTR(eeprom1, S_IWUSR | S_IRUGO, show_eeprom1, set_eeprom1);
+
+static ssize_t show_tolerance1(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	return sysfs_show_reg(dev, attr, buf,
+			      AD525X_I2C_EEPROM | AD525X_TOL_RDAC1);
+}
+
+static DEVICE_ATTR(tolerance1, S_IRUGO, show_tolerance1, NULL);
+
+/* ------------------------------------------------------------------------- */
+
+static ssize_t show_rdac2(struct device *dev,
+			  struct device_attribute *attr, char *buf)
+{
+	return sysfs_show_reg(dev, attr, buf, AD525X_I2C_RDAC | AD525X_RDAC2);
+}
+
+static ssize_t set_rdac2(struct device *dev,
+			 struct device_attribute *attr,
+			 const char *buf, size_t count)
+{
+	return sysfs_set_reg(dev, attr, buf, count,
+			     AD525X_I2C_RDAC | AD525X_RDAC2);
+}
+
+static DEVICE_ATTR(rdac2, S_IWUSR | S_IRUGO, show_rdac2, set_rdac2);
+
+static ssize_t show_eeprom2(struct device *dev,
+			    struct device_attribute *attr, char *buf)
+{
+	return sysfs_show_reg(dev, attr, buf, AD525X_I2C_EEPROM | AD525X_RDAC2);
+}
+
+static ssize_t set_eeprom2(struct device *dev,
+			   struct device_attribute *attr,
+			   const char *buf, size_t count)
+{
+	return sysfs_set_reg(dev, attr, buf, count,
+			     AD525X_I2C_EEPROM | AD525X_RDAC2);
+}
+
+static DEVICE_ATTR(eeprom2, S_IWUSR | S_IRUGO, show_eeprom2, set_eeprom2);
+
+static ssize_t show_tolerance2(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	return sysfs_show_reg(dev, attr, buf,
+			      AD525X_I2C_EEPROM | AD525X_TOL_RDAC2);
+}
+
+static DEVICE_ATTR(tolerance2, S_IRUGO, show_tolerance2, NULL);
+
+/* ------------------------------------------------------------------------- */
+
+static ssize_t show_rdac3(struct device *dev,
+			  struct device_attribute *attr, char *buf)
+{
+	return sysfs_show_reg(dev, attr, buf, AD525X_I2C_RDAC | AD525X_RDAC3);
+}
+
+static ssize_t set_rdac3(struct device *dev,
+			 struct device_attribute *attr,
+			 const char *buf, size_t count)
+{
+	return sysfs_set_reg(dev, attr, buf, count,
+			     AD525X_I2C_RDAC | AD525X_RDAC3);
+}
+
+static DEVICE_ATTR(rdac3, S_IWUSR | S_IRUGO, show_rdac3, set_rdac3);
+
+static ssize_t show_eeprom3(struct device *dev,
+			    struct device_attribute *attr, char *buf)
+{
+	return sysfs_show_reg(dev, attr, buf, AD525X_I2C_EEPROM | AD525X_RDAC3);
+}
+
+static ssize_t set_eeprom3(struct device *dev,
+			   struct device_attribute *attr,
+			   const char *buf, size_t count)
+{
+	return sysfs_set_reg(dev, attr, buf, count,
+			     AD525X_I2C_EEPROM | AD525X_RDAC3);
+}
+
+static DEVICE_ATTR(eeprom3, S_IWUSR | S_IRUGO, show_eeprom3, set_eeprom3);
+
+static ssize_t show_tolerance3(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	return sysfs_show_reg(dev, attr, buf,
+			      AD525X_I2C_EEPROM | AD525X_TOL_RDAC3);
+}
+
+static DEVICE_ATTR(tolerance3, S_IRUGO, show_tolerance3, NULL);
+
+static struct attribute *ad525x_attributes_wipers[4][4] = {
+	{
+		&dev_attr_rdac0.attr,
+		&dev_attr_eeprom0.attr,
+		&dev_attr_tolerance0.attr,
+		NULL
+	}, {
+		&dev_attr_rdac1.attr,
+		&dev_attr_eeprom1.attr,
+		&dev_attr_tolerance1.attr,
+		NULL
+	}, {
+		&dev_attr_rdac2.attr,
+		&dev_attr_eeprom2.attr,
+		&dev_attr_tolerance2.attr,
+		NULL
+	}, {
+		&dev_attr_rdac3.attr,
+		&dev_attr_eeprom3.attr,
+		&dev_attr_tolerance3.attr,
+		NULL
+	}
+};
+
+static const struct attribute_group ad525x_group_wipers[] = {
+	{.attrs = ad525x_attributes_wipers[AD525X_RDAC0]},
+	{.attrs = ad525x_attributes_wipers[AD525X_RDAC1]},
+	{.attrs = ad525x_attributes_wipers[AD525X_RDAC2]},
+	{.attrs = ad525x_attributes_wipers[AD525X_RDAC3]},
+};
+
+/* ------------------------------------------------------------------------- */
+
+static ssize_t set_inc_all(struct device *dev,
+			   struct device_attribute *attr,
+			   const char *buf, size_t count)
+{
+	return sysfs_do_cmd(dev, attr, buf, count, AD525X_INC_ALL);
+}
+
+static DEVICE_ATTR(inc_all, S_IWUSR, NULL, set_inc_all);
+
+static ssize_t set_dec_all(struct device *dev,
+			   struct device_attribute *attr,
+			   const char *buf, size_t count)
+{
+	return sysfs_do_cmd(dev, attr, buf, count, AD525X_DEC_ALL);
+}
+
+static DEVICE_ATTR(dec_all, S_IWUSR, NULL, set_dec_all);
+
+static ssize_t set_inc_all_6db(struct device *dev,
+			       struct device_attribute *attr,
+			       const char *buf, size_t count)
+{
+	return sysfs_do_cmd(dev, attr, buf, count, AD525X_INC_ALL_6DB);
+}
+
+static DEVICE_ATTR(inc_all_6db, S_IWUSR, NULL, set_inc_all_6db);
+
+static ssize_t set_dec_all_6db(struct device *dev,
+			       struct device_attribute *attr,
+			       const char *buf, size_t count)
+{
+	return sysfs_do_cmd(dev, attr, buf, count, AD525X_DEC_ALL_6DB);
+}
+
+static DEVICE_ATTR(dec_all_6db, S_IWUSR, NULL, set_dec_all_6db);
+
+static struct attribute *ad525x_attributes_commands[] = {
+	&dev_attr_inc_all.attr,
+	&dev_attr_dec_all.attr,
+	&dev_attr_inc_all_6db.attr,
+	&dev_attr_dec_all_6db.attr,
+	NULL
+};
+
+static const struct attribute_group ad525x_group_commands = {
+	.attrs = ad525x_attributes_commands,
+};
+
+/* ------------------------------------------------------------------------- */
+
+/* i2c device functions */
+
+/**
+ * ad525x_read - return the value contained in the specified register
+ * on the AD5258 device.
+ * @client: value returned from i2c_new_device()
+ * @reg: the register to read
+ *
+ * If the tolerance register is specified, 2 bytes are returned.
+ * Otherwise, 1 byte is returned.  A negative value indicates an error
+ * occurred while reading the register.
+ */
+static s32 ad525x_read(struct i2c_client *client, u8 reg)
+{
+	struct dpot_data *data = i2c_get_clientdata(client);
+
+	if ((reg & AD525X_REG_TOL) || (data->max_pos > 256))
+		return i2c_smbus_read_word_data(client, (reg & 0xF8) |
+						((reg & 0x7) << 1));
+	else
+		return i2c_smbus_read_byte_data(client, reg);
+}
+
+/**
+ * ad525x_write - store the given value in the specified register on
+ * the AD5258 device.
+ * @client: value returned from i2c_new_device()
+ * @reg: the register to write
+ * @value: the byte to store in the register
+ *
+ * For certain instructions that do not require a data byte, "NULL"
+ * should be specified for the "value" parameter.  These instructions
+ * include NOP, RESTORE_FROM_EEPROM, and STORE_TO_EEPROM.
+ *
+ * A negative return value indicates an error occurred while reading
+ * the register.
+ */
+static s32 ad525x_write(struct i2c_client *client, u8 reg, u8 value)
+{
+	struct dpot_data *data = i2c_get_clientdata(client);
+
+	/* Only write the instruction byte for certain commands */
+	if (reg & AD525X_I2C_CMD)
+		return i2c_smbus_write_byte(client, reg);
+
+	if (data->max_pos > 256)
+		return i2c_smbus_write_word_data(client, (reg & 0xF8) |
+						((reg & 0x7) << 1), value);
+	else
+		/* All other registers require instruction + data bytes */
+		return i2c_smbus_write_byte_data(client, reg, value);
+}
+
+static int ad525x_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	struct device *dev = &client->dev;
+	struct dpot_data *data;
+	int err = 0;
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE)) {
+		dev_err(dev, "missing I2C functionality for this driver\n");
+		goto exit;
+	}
+
+	data = kzalloc(sizeof(struct dpot_data), GFP_KERNEL);
+	if (!data) {
+		err = -ENOMEM;
+		goto exit;
+	}
+
+	i2c_set_clientdata(client, data);
+	mutex_init(&data->update_lock);
+
+	switch (id->driver_data) {
+	case AD5258_ID:
+		data->max_pos = AD5258_MAX_POSITION;
+		err = sysfs_create_group(&dev->kobj,
+				       &ad525x_group_wipers[AD525X_RDAC0]);
+		break;
+	case AD5259_ID:
+		data->max_pos = AD5259_MAX_POSITION;
+		err = sysfs_create_group(&dev->kobj,
+				       &ad525x_group_wipers[AD525X_RDAC0]);
+		break;
+	case AD5251_ID:
+		data->max_pos = AD5251_MAX_POSITION;
+		err = sysfs_create_group(&dev->kobj,
+				       &ad525x_group_wipers[AD525X_RDAC1]);
+		err |= sysfs_create_group(&dev->kobj,
+				       &ad525x_group_wipers[AD525X_RDAC3]);
+		err |= sysfs_create_group(&dev->kobj, &ad525x_group_commands);
+		break;
+	case AD5252_ID:
+		data->max_pos = AD5252_MAX_POSITION;
+		err = sysfs_create_group(&dev->kobj,
+				       &ad525x_group_wipers[AD525X_RDAC1]);
+		err |= sysfs_create_group(&dev->kobj,
+				       &ad525x_group_wipers[AD525X_RDAC3]);
+		err |= sysfs_create_group(&dev->kobj, &ad525x_group_commands);
+		break;
+	case AD5253_ID:
+		data->max_pos = AD5253_MAX_POSITION;
+		err = sysfs_create_group(&dev->kobj,
+				       &ad525x_group_wipers[AD525X_RDAC0]);
+		err |= sysfs_create_group(&dev->kobj,
+				       &ad525x_group_wipers[AD525X_RDAC1]);
+		err |= sysfs_create_group(&dev->kobj,
+				       &ad525x_group_wipers[AD525X_RDAC2]);
+		err |= sysfs_create_group(&dev->kobj,
+				       &ad525x_group_wipers[AD525X_RDAC3]);
+		err |= sysfs_create_group(&dev->kobj, &ad525x_group_commands);
+		break;
+	case AD5254_ID:
+		data->max_pos = AD5254_MAX_POSITION;
+		err = sysfs_create_group(&dev->kobj,
+				       &ad525x_group_wipers[AD525X_RDAC0]);
+		err |= sysfs_create_group(&dev->kobj,
+				       &ad525x_group_wipers[AD525X_RDAC1]);
+		err |= sysfs_create_group(&dev->kobj,
+				       &ad525x_group_wipers[AD525X_RDAC2]);
+		err |= sysfs_create_group(&dev->kobj,
+				       &ad525x_group_wipers[AD525X_RDAC3]);
+		err |= sysfs_create_group(&dev->kobj, &ad525x_group_commands);
+		break;
+	case AD5255_ID:
+		data->max_pos = AD5255_MAX_POSITION;
+		err = sysfs_create_group(&dev->kobj,
+				       &ad525x_group_wipers[AD525X_RDAC0]);
+		err |= sysfs_create_group(&dev->kobj,
+				       &ad525x_group_wipers[AD525X_RDAC1]);
+		err |= sysfs_create_group(&dev->kobj,
+				       &ad525x_group_wipers[AD525X_RDAC2]);
+		err |= sysfs_create_group(&dev->kobj, &ad525x_group_commands);
+		break;
+	default:
+		err = -ENODEV;
+		goto exit_free;
+	}
+
+	if (err) {
+		dev_err(dev, "failed to register sysfs hooks\n");
+		goto exit_free;
+	}
+
+	data->devid = id->driver_data;
+	data->rdac_mask = data->max_pos - 1;
+
+	dev_info(dev, "%s %d-Position Digital Potentiometer registered\n",
+		 id->name, data->max_pos);
+
+	return 0;
+
+exit_free:
+	kfree(data);
+	i2c_set_clientdata(client, NULL);
+exit:
+	dev_err(dev, "failed to create client\n");
+	return err;
+}
+
+static int __devexit ad525x_remove(struct i2c_client *client)
+{
+	struct dpot_data *data = i2c_get_clientdata(client);
+	struct device *dev = &client->dev;
+
+	switch (data->devid) {
+	case AD5258_ID:
+	case AD5259_ID:
+		sysfs_remove_group(&dev->kobj,
+				   &ad525x_group_wipers[AD525X_RDAC0]);
+		break;
+	case AD5251_ID:
+	case AD5252_ID:
+		sysfs_remove_group(&dev->kobj,
+				   &ad525x_group_wipers[AD525X_RDAC1]);
+		sysfs_remove_group(&dev->kobj,
+				   &ad525x_group_wipers[AD525X_RDAC3]);
+		sysfs_remove_group(&dev->kobj, &ad525x_group_commands);
+		break;
+	case AD5253_ID:
+	case AD5254_ID:
+		sysfs_remove_group(&dev->kobj,
+				   &ad525x_group_wipers[AD525X_RDAC0]);
+		sysfs_remove_group(&dev->kobj,
+				   &ad525x_group_wipers[AD525X_RDAC1]);
+		sysfs_remove_group(&dev->kobj,
+				   &ad525x_group_wipers[AD525X_RDAC2]);
+		sysfs_remove_group(&dev->kobj,
+				   &ad525x_group_wipers[AD525X_RDAC3]);
+		sysfs_remove_group(&dev->kobj, &ad525x_group_commands);
+		break;
+	case AD5255_ID:
+		sysfs_remove_group(&dev->kobj,
+				   &ad525x_group_wipers[AD525X_RDAC0]);
+		sysfs_remove_group(&dev->kobj,
+				   &ad525x_group_wipers[AD525X_RDAC1]);
+		sysfs_remove_group(&dev->kobj,
+				   &ad525x_group_wipers[AD525X_RDAC2]);
+		sysfs_remove_group(&dev->kobj, &ad525x_group_commands);
+		break;
+	}
+
+	i2c_set_clientdata(client, NULL);
+	kfree(data);
+
+	return 0;
+}
+
+static const struct i2c_device_id ad525x_idtable[] = {
+	{"ad5258", AD5258_ID},
+	{"ad5259", AD5259_ID},
+	{"ad5251", AD5251_ID},
+	{"ad5252", AD5252_ID},
+	{"ad5253", AD5253_ID},
+	{"ad5254", AD5254_ID},
+	{"ad5255", AD5255_ID},
+	{}
+};
+
+MODULE_DEVICE_TABLE(i2c, ad525x_idtable);
+
+static struct i2c_driver ad525x_driver = {
+	.driver = {
+		   .owner = THIS_MODULE,
+		   .name = DRIVER_NAME,
+		   },
+	.id_table = ad525x_idtable,
+	.probe = ad525x_probe,
+	.remove = __devexit_p(ad525x_remove),
+};
+
+static int __init ad525x_init(void)
+{
+	return i2c_add_driver(&ad525x_driver);
+}
+
+module_init(ad525x_init);
+
+static void __exit ad525x_exit(void)
+{
+	i2c_del_driver(&ad525x_driver);
+}
+
+module_exit(ad525x_exit);
+
+MODULE_AUTHOR("Chris Verges <chrisv@cyberswitching.com>, "
+	      "Michael Hennerich <hennerich@blackfin.uclinux.org>, ");
+MODULE_DESCRIPTION("AD5258/9 digital potentiometer driver");
+MODULE_LICENSE("GPL");
+MODULE_VERSION(DRIVER_VERSION);
