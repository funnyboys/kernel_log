commit e852c2c251ed9c23ae6e3efebc5ec49adb504207
Author: Alexander Usyskin <alexander.usyskin@intel.com>
Date:   Mon Jun 29 01:53:59 2020 +0300

    mei: bus: don't clean driver pointer
    
    It's not needed to set driver to NULL in mei_cl_device_remove()
    which is bus_type remove() handler as this is done anyway
    in __device_release_driver().
    
    Actually this is causing an endless loop in driver_detach()
    on ubuntu patched kernel, while removing (rmmod) the mei_hdcp module.
    The reason list_empty(&drv->p->klist_devices.k_list) is always not-empty.
    as the check is always true in  __device_release_driver()
            if (dev->driver != drv)
                    return;
    
    The non upstream patch is causing this behavior, titled:
    'vfio -- release device lock before userspace requests'
    
    Nevertheless the fix is correct also for the upstream.
    
    Link: https://patchwork.ozlabs.org/project/ubuntu-kernel/patch/20180912085046.3401-2-apw@canonical.com/
    Cc: <stable@vger.kernel.org>
    Cc: Andy Whitcroft <apw@canonical.com>
    Signed-off-by: Alexander Usyskin <alexander.usyskin@intel.com>
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Link: https://lore.kernel.org/r/20200628225359.2185929-1-tomas.winkler@intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 8d468e0a950a..f476dbc7252b 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -745,9 +745,8 @@ static int mei_cl_device_remove(struct device *dev)
 
 	mei_cl_bus_module_put(cldev);
 	module_put(THIS_MODULE);
-	dev->driver = NULL;
-	return ret;
 
+	return ret;
 }
 
 static ssize_t name_show(struct device *dev, struct device_attribute *a,

commit 49ef431defcc03be0d9bf80e1b3945a1c914868c
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Tue Nov 26 14:30:02 2019 +0200

    mei: bus: use simple sprintf for sysfs
    
    Replace scnprintf with simple sprintf for sysfs files.
    it is implicitly known that the buffer is big enough
    for the variables to fit in.
    
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Link: https://lore.kernel.org/r/20191126123002.4835-1-tomas.winkler@intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index a0a495c95e3c..8d468e0a950a 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -765,7 +765,7 @@ static ssize_t uuid_show(struct device *dev, struct device_attribute *a,
 	struct mei_cl_device *cldev = to_mei_cl_device(dev);
 	const uuid_le *uuid = mei_me_cl_uuid(cldev->me_cl);
 
-	return scnprintf(buf, PAGE_SIZE, "%pUl", uuid);
+	return sprintf(buf, "%pUl", uuid);
 }
 static DEVICE_ATTR_RO(uuid);
 
@@ -775,7 +775,7 @@ static ssize_t version_show(struct device *dev, struct device_attribute *a,
 	struct mei_cl_device *cldev = to_mei_cl_device(dev);
 	u8 version = mei_me_cl_ver(cldev->me_cl);
 
-	return scnprintf(buf, PAGE_SIZE, "%02X", version);
+	return sprintf(buf, "%02X", version);
 }
 static DEVICE_ATTR_RO(version);
 
@@ -797,7 +797,7 @@ static ssize_t max_conn_show(struct device *dev, struct device_attribute *a,
 	struct mei_cl_device *cldev = to_mei_cl_device(dev);
 	u8 maxconn = mei_me_cl_max_conn(cldev->me_cl);
 
-	return scnprintf(buf, PAGE_SIZE, "%d", maxconn);
+	return sprintf(buf, "%d", maxconn);
 }
 static DEVICE_ATTR_RO(max_conn);
 
@@ -807,7 +807,7 @@ static ssize_t fixed_show(struct device *dev, struct device_attribute *a,
 	struct mei_cl_device *cldev = to_mei_cl_device(dev);
 	u8 fixed = mei_me_cl_fixed(cldev->me_cl);
 
-	return scnprintf(buf, PAGE_SIZE, "%d", fixed);
+	return sprintf(buf, "%d", fixed);
 }
 static DEVICE_ATTR_RO(fixed);
 
@@ -817,7 +817,7 @@ static ssize_t max_len_show(struct device *dev, struct device_attribute *a,
 	struct mei_cl_device *cldev = to_mei_cl_device(dev);
 	u32 maxlen = mei_me_cl_max_len(cldev->me_cl);
 
-	return scnprintf(buf, PAGE_SIZE, "%u", maxlen);
+	return sprintf(buf, "%u", maxlen);
 }
 static DEVICE_ATTR_RO(max_len);
 

commit 64498695dd800bcb494d96b94f99356ece91ea90
Author: Alexander Usyskin <alexander.usyskin@intel.com>
Date:   Sat Nov 16 16:21:36 2019 +0200

    mei: bus: add more client attributes to sysfs
    
    Export more client attributes via sysfs that are usually obtained
    upon connection. In some cases, for example a monitoring application
    may wish to know the attributes without actually performing the connection.
    Added attributes:
    max number of connections, fixed address, max message length.
    
    Signed-off-by: Alexander Usyskin <alexander.usyskin@intel.com>
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Link: https://lore.kernel.org/r/20191116142136.17535-1-tomas.winkler@intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 53bb394ccba6..a0a495c95e3c 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -791,11 +791,44 @@ static ssize_t modalias_show(struct device *dev, struct device_attribute *a,
 }
 static DEVICE_ATTR_RO(modalias);
 
+static ssize_t max_conn_show(struct device *dev, struct device_attribute *a,
+			     char *buf)
+{
+	struct mei_cl_device *cldev = to_mei_cl_device(dev);
+	u8 maxconn = mei_me_cl_max_conn(cldev->me_cl);
+
+	return scnprintf(buf, PAGE_SIZE, "%d", maxconn);
+}
+static DEVICE_ATTR_RO(max_conn);
+
+static ssize_t fixed_show(struct device *dev, struct device_attribute *a,
+			  char *buf)
+{
+	struct mei_cl_device *cldev = to_mei_cl_device(dev);
+	u8 fixed = mei_me_cl_fixed(cldev->me_cl);
+
+	return scnprintf(buf, PAGE_SIZE, "%d", fixed);
+}
+static DEVICE_ATTR_RO(fixed);
+
+static ssize_t max_len_show(struct device *dev, struct device_attribute *a,
+			    char *buf)
+{
+	struct mei_cl_device *cldev = to_mei_cl_device(dev);
+	u32 maxlen = mei_me_cl_max_len(cldev->me_cl);
+
+	return scnprintf(buf, PAGE_SIZE, "%u", maxlen);
+}
+static DEVICE_ATTR_RO(max_len);
+
 static struct attribute *mei_cldev_attrs[] = {
 	&dev_attr_name.attr,
 	&dev_attr_uuid.attr,
 	&dev_attr_version.attr,
 	&dev_attr_modalias.attr,
+	&dev_attr_max_conn.attr,
+	&dev_attr_fixed.attr,
+	&dev_attr_max_len.attr,
 	NULL,
 };
 ATTRIBUTE_GROUPS(mei_cldev);

commit 7a2b9e6ec84588b0be65cc0ae45a65bac431496b
Author: Alexander Usyskin <alexander.usyskin@intel.com>
Date:   Tue Nov 5 17:05:13 2019 +0200

    mei: bus: prefix device names on bus with the bus name
    
    Add parent device name to the name of devices on bus to avoid
    device names collisions for same client UUID available
    from different MEI heads. Namely this prevents sysfs collision under
    /sys/bus/mei/device/
    
    In the device part leave just UUID other parameters that are
    required for device matching are not required here and are
    just bloating the name.
    
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Alexander Usyskin <alexander.usyskin@intel.com>
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Link: https://lore.kernel.org/r/20191105150514.14010-1-tomas.winkler@intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 985bd4fd3328..53bb394ccba6 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -873,15 +873,16 @@ static const struct device_type mei_cl_device_type = {
 
 /**
  * mei_cl_bus_set_name - set device name for me client device
+ *  <controller>-<client device>
+ *  Example: 0000:00:16.0-55213584-9a29-4916-badf-0fb7ed682aeb
  *
  * @cldev: me client device
  */
 static inline void mei_cl_bus_set_name(struct mei_cl_device *cldev)
 {
-	dev_set_name(&cldev->dev, "mei:%s:%pUl:%02X",
-		     cldev->name,
-		     mei_me_cl_uuid(cldev->me_cl),
-		     mei_me_cl_ver(cldev->me_cl));
+	dev_set_name(&cldev->dev, "%s-%pUl",
+		     dev_name(cldev->bus->dev),
+		     mei_me_cl_uuid(cldev->me_cl));
 }
 
 /**

commit 1e55b609b983f99290d210bf6578cb1a2eb905d2
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Tue Mar 12 00:10:44 2019 +0200

    mei: adjust the copyright notice in the files.
    
    Use unified version of the copyright notice in the files
    Update copyright years according the year the files
    were touched, except this patch and SPDX conversions.
    
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index e6788fbd611c..985bd4fd3328 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -1,7 +1,7 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
+ * Copyright (c) 2012-2019, Intel Corporation. All rights reserved.
  * Intel Management Engine Interface (Intel MEI) Linux driver
- * Copyright (c) 2012-2013, Intel Corporation.
  */
 
 #include <linux/module.h>

commit 9fff0425aab086c10b29ce50d440afde7d31a740
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Tue Mar 12 00:10:41 2019 +0200

    mei: convert to SPDX license tags
    
    Replace boiler plate licenses texts with the SPDX license
    identifiers in the mei files header.
    
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 65bec998eb6e..e6788fbd611c 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -1,16 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Intel Management Engine Interface (Intel MEI) Linux driver
  * Copyright (c) 2012-2013, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
  */
 
 #include <linux/module.h>

commit b5958faa34e2f99f3475ad89c52d98dfea079d33
Author: Alexander Usyskin <alexander.usyskin@intel.com>
Date:   Mon Feb 25 11:09:28 2019 +0200

    mei: bus: move hw module get/put to probe/release
    
    Fix unbalanced module reference counting during internal reset, which
    prevents the drivers unloading.
    Tracking mei_me/txe modules on mei client bus via
    mei_cldev_enable/disable is error prone due to possible internal
    reset flow, where clients are disconnected underneath.
    Moving reference counting to probe and release of mei bus client
    driver solves this issue in simplest way, as each client provides only
    a single connection to a client bus driver.
    
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Alexander Usyskin <alexander.usyskin@intel.com>
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index e5456faf00e6..65bec998eb6e 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -540,17 +540,9 @@ int mei_cldev_enable(struct mei_cl_device *cldev)
 		goto out;
 	}
 
-	if (!mei_cl_bus_module_get(cldev)) {
-		dev_err(&cldev->dev, "get hw module failed");
-		ret = -ENODEV;
-		goto out;
-	}
-
 	ret = mei_cl_connect(cl, cldev->me_cl, NULL);
-	if (ret < 0) {
+	if (ret < 0)
 		dev_err(&cldev->dev, "cannot connect\n");
-		mei_cl_bus_module_put(cldev);
-	}
 
 out:
 	mutex_unlock(&bus->device_lock);
@@ -613,7 +605,6 @@ int mei_cldev_disable(struct mei_cl_device *cldev)
 	if (err < 0)
 		dev_err(bus->dev, "Could not disconnect from the ME client\n");
 
-	mei_cl_bus_module_put(cldev);
 out:
 	/* Flush queues and remove any pending read */
 	mei_cl_flush_queues(cl, NULL);
@@ -724,9 +715,16 @@ static int mei_cl_device_probe(struct device *dev)
 	if (!id)
 		return -ENODEV;
 
+	if (!mei_cl_bus_module_get(cldev)) {
+		dev_err(&cldev->dev, "get hw module failed");
+		return -ENODEV;
+	}
+
 	ret = cldrv->probe(cldev, id);
-	if (ret)
+	if (ret) {
+		mei_cl_bus_module_put(cldev);
 		return ret;
+	}
 
 	__module_get(THIS_MODULE);
 	return 0;
@@ -754,6 +752,7 @@ static int mei_cl_device_remove(struct device *dev)
 
 	mei_cldev_unregister_callbacks(cldev);
 
+	mei_cl_bus_module_put(cldev);
 	module_put(THIS_MODULE);
 	dev->driver = NULL;
 	return ret;

commit 32ea33a044842ae6c5fc7e33426e0a7bd50f8801
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Sat Feb 9 18:42:05 2019 +0200

    mei: bus: export to_mei_cl_device for mei client devices drivers
    
    Export to_mei_cl_device macro, as it is needed also
    in the mei client drivers.
    
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index fc3872fe7b25..e5456faf00e6 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -28,7 +28,6 @@
 #include "client.h"
 
 #define to_mei_cl_driver(d) container_of(d, struct mei_cl_driver, driver)
-#define to_mei_cl_device(d) container_of(d, struct mei_cl_device, dev)
 
 /**
  * __mei_cl_send - internal client send (write)

commit 34f1166afd67f9f48a08c52f36180048908506a4
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Mon Aug 27 22:40:16 2018 +0300

    mei: bus: need to unlink client before freeing
    
    In case a client fails to connect in mei_cldev_enable(), the
    caller won't call the mei_cldev_disable leaving the client
    in a linked stated. Upon driver unload the client structure
    will be freed in  mei_cl_bus_dev_release(), leaving a stale pointer
    on a fail_list.  This will eventually end up in crash
    during power down flow in mei_cl_set_disonnected().
    
    RIP:  mei_cl_set_disconnected+0x5/0x260[mei]
    Call trace:
    mei_cl_all_disconnect+0x22/0x30
    mei_reset+0x194/0x250
    __synchronize_hardirq+0x43/0x50
    _cond_resched+0x15/0x30
    mei_me_intr_clear+0x20/0x100
    mei_stop+0x76/0xb0
    mei_me_shutdown+0x3f/0x80
    pci_device_shutdown+0x34/0x60
    kernel_restart+0x0e/0x30
    
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=200455
    Fixes: 'c110cdb17148 ("mei: bus: make a client pointer always available")'
    Cc: <stable@vger.kernel.org> 4.10+
    Tested-by: Georg Müller <georgmueller@gmx.net>
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 13c6c9a2248a..fc3872fe7b25 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -521,17 +521,15 @@ int mei_cldev_enable(struct mei_cl_device *cldev)
 
 	cl = cldev->cl;
 
+	mutex_lock(&bus->device_lock);
 	if (cl->state == MEI_FILE_UNINITIALIZED) {
-		mutex_lock(&bus->device_lock);
 		ret = mei_cl_link(cl);
-		mutex_unlock(&bus->device_lock);
 		if (ret)
-			return ret;
+			goto out;
 		/* update pointers */
 		cl->cldev = cldev;
 	}
 
-	mutex_lock(&bus->device_lock);
 	if (mei_cl_is_connected(cl)) {
 		ret = 0;
 		goto out;
@@ -875,12 +873,13 @@ static void mei_cl_bus_dev_release(struct device *dev)
 
 	mei_me_cl_put(cldev->me_cl);
 	mei_dev_bus_put(cldev->bus);
+	mei_cl_unlink(cldev->cl);
 	kfree(cldev->cl);
 	kfree(cldev);
 }
 
 static const struct device_type mei_cl_device_type = {
-	.release	= mei_cl_bus_dev_release,
+	.release = mei_cl_bus_dev_release,
 };
 
 /**

commit 69bf5313035926b0b6a6578de4f3168a8f5c19b8
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Mon Aug 27 22:40:15 2018 +0300

    mei: bus: fix hw module get/put balance
    
    In case the device is not connected it doesn't 'get'
    hw module and hence should not 'put' it on disable.
    
    Cc: <stable@vger.kernel.org> 4.16+
    Fixes:'commit 257355a44b99 ("mei: make module referencing local to the bus.c")'
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=200455
    Tested-by: Georg Müller <georgmueller@gmx.net>
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 7bba62a72921..13c6c9a2248a 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -616,9 +616,8 @@ int mei_cldev_disable(struct mei_cl_device *cldev)
 	if (err < 0)
 		dev_err(bus->dev, "Could not disconnect from the ME client\n");
 
-out:
 	mei_cl_bus_module_put(cldev);
-
+out:
 	/* Flush queues and remove any pending read */
 	mei_cl_flush_queues(cl, NULL);
 	mei_cl_unlink(cl);

commit 9a7c0b69b6e765c655133ef530876aea3da71d58
Author: Alexander Usyskin <alexander.usyskin@intel.com>
Date:   Mon Jun 25 00:11:40 2018 +0300

    mei: add optional timeout to internal bus recv
    
    Add optional timeout to internal bus recv function to
    enable break out of internal flows in case of no answer from FW.
    
    Signed-off-by: Alexander Usyskin <alexander.usyskin@intel.com>
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index b1133739fb4b..7bba62a72921 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -116,11 +116,12 @@ ssize_t __mei_cl_send(struct mei_cl *cl, u8 *buf, size_t length,
  * @buf: buffer to receive
  * @length: buffer length
  * @mode: io mode
+ * @timeout: recv timeout, 0 for infinite timeout
  *
  * Return: read size in bytes of < 0 on error
  */
 ssize_t __mei_cl_recv(struct mei_cl *cl, u8 *buf, size_t length,
-		      unsigned int mode)
+		      unsigned int mode, unsigned long timeout)
 {
 	struct mei_device *bus;
 	struct mei_cl_cb *cb;
@@ -158,13 +159,28 @@ ssize_t __mei_cl_recv(struct mei_cl *cl, u8 *buf, size_t length,
 
 		mutex_unlock(&bus->device_lock);
 
-		if (wait_event_interruptible(cl->rx_wait,
-				(!list_empty(&cl->rd_completed)) ||
-				(!mei_cl_is_connected(cl)))) {
-
-			if (signal_pending(current))
-				return -EINTR;
-			return -ERESTARTSYS;
+		if (timeout) {
+			rets = wait_event_interruptible_timeout
+					(cl->rx_wait,
+					(!list_empty(&cl->rd_completed)) ||
+					(!mei_cl_is_connected(cl)),
+					msecs_to_jiffies(timeout));
+			if (rets == 0)
+				return -ETIME;
+			if (rets < 0) {
+				if (signal_pending(current))
+					return -EINTR;
+				return -ERESTARTSYS;
+			}
+		} else {
+			if (wait_event_interruptible
+					(cl->rx_wait,
+					(!list_empty(&cl->rd_completed)) ||
+					(!mei_cl_is_connected(cl)))) {
+				if (signal_pending(current))
+					return -EINTR;
+				return -ERESTARTSYS;
+			}
 		}
 
 		mutex_lock(&bus->device_lock);
@@ -231,7 +247,7 @@ ssize_t mei_cldev_recv_nonblock(struct mei_cl_device *cldev, u8 *buf,
 {
 	struct mei_cl *cl = cldev->cl;
 
-	return __mei_cl_recv(cl, buf, length, MEI_CL_IO_RX_NONBLOCK);
+	return __mei_cl_recv(cl, buf, length, MEI_CL_IO_RX_NONBLOCK, 0);
 }
 EXPORT_SYMBOL_GPL(mei_cldev_recv_nonblock);
 
@@ -248,7 +264,7 @@ ssize_t mei_cldev_recv(struct mei_cl_device *cldev, u8 *buf, size_t length)
 {
 	struct mei_cl *cl = cldev->cl;
 
-	return __mei_cl_recv(cl, buf, length, 0);
+	return __mei_cl_recv(cl, buf, length, 0, 0);
 }
 EXPORT_SYMBOL_GPL(mei_cldev_recv);
 

commit af336cabe08363ba8493e7d7e5d070353eb30caa
Author: Alexander Usyskin <alexander.usyskin@intel.com>
Date:   Sun Feb 25 20:07:05 2018 +0200

    mei: limit the number of queued writes
    
    Limit the number of queued writes per client.
    Writes above this threshold are blocked till place
    in the transmit queue is available.
    The limit is configurable via sysfs and defaults to 50.
    The implementation should provide blocking I/O behavior.
    Prior to this change one would end up in the hands of OOM.
    
    Signed-off-by: Alexander Usyskin <alexander.usyskin@intel.com>
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 1dacc820bd7f..b1133739fb4b 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -74,6 +74,23 @@ ssize_t __mei_cl_send(struct mei_cl *cl, u8 *buf, size_t length,
 		goto out;
 	}
 
+	while (cl->tx_cb_queued >= bus->tx_queue_limit) {
+		mutex_unlock(&bus->device_lock);
+		rets = wait_event_interruptible(cl->tx_wait,
+				cl->writing_state == MEI_WRITE_COMPLETE ||
+				(!mei_cl_is_connected(cl)));
+		mutex_lock(&bus->device_lock);
+		if (rets) {
+			if (signal_pending(current))
+				rets = -EINTR;
+			goto out;
+		}
+		if (!mei_cl_is_connected(cl)) {
+			rets = -ENODEV;
+			goto out;
+		}
+	}
+
 	cb = mei_cl_alloc_cb(cl, length, MEI_FOP_WRITE, NULL);
 	if (!cb) {
 		rets = -ENOMEM;

commit 257355a44b9929e55d6fd47bfff66971dc4de948
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Sun Feb 25 20:07:04 2018 +0200

    mei: make module referencing local to the bus.c
    
    Module reference counting is relevant only to the
    mei client devices. Make the implementation clean
    and move it to bus.c
    
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 772d02922529..1dacc820bd7f 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -449,6 +449,29 @@ bool mei_cldev_enabled(struct mei_cl_device *cldev)
 }
 EXPORT_SYMBOL_GPL(mei_cldev_enabled);
 
+/**
+ * mei_cl_bus_module_get - acquire module of the underlying
+ *    hw driver.
+ *
+ * @cldev: mei client device
+ *
+ * Return: true on success; false if the module was removed.
+ */
+static bool mei_cl_bus_module_get(struct mei_cl_device *cldev)
+{
+	return try_module_get(cldev->bus->dev->driver->owner);
+}
+
+/**
+ * mei_cl_bus_module_put -  release the underlying hw module.
+ *
+ * @cldev: mei client device
+ */
+static void mei_cl_bus_module_put(struct mei_cl_device *cldev)
+{
+	module_put(cldev->bus->dev->driver->owner);
+}
+
 /**
  * mei_cldev_enable - enable me client device
  *     create connection with me client
@@ -487,9 +510,17 @@ int mei_cldev_enable(struct mei_cl_device *cldev)
 		goto out;
 	}
 
+	if (!mei_cl_bus_module_get(cldev)) {
+		dev_err(&cldev->dev, "get hw module failed");
+		ret = -ENODEV;
+		goto out;
+	}
+
 	ret = mei_cl_connect(cl, cldev->me_cl, NULL);
-	if (ret < 0)
+	if (ret < 0) {
 		dev_err(&cldev->dev, "cannot connect\n");
+		mei_cl_bus_module_put(cldev);
+	}
 
 out:
 	mutex_unlock(&bus->device_lock);
@@ -553,6 +584,8 @@ int mei_cldev_disable(struct mei_cl_device *cldev)
 		dev_err(bus->dev, "Could not disconnect from the ME client\n");
 
 out:
+	mei_cl_bus_module_put(cldev);
+
 	/* Flush queues and remove any pending read */
 	mei_cl_flush_queues(cl, NULL);
 	mei_cl_unlink(cl);
@@ -562,37 +595,6 @@ int mei_cldev_disable(struct mei_cl_device *cldev)
 }
 EXPORT_SYMBOL_GPL(mei_cldev_disable);
 
-/**
- * mei_cl_bus_module_get - acquire module of the underlying
- *    hw module.
- *
- * @cl: host client
- *
- * Return: true on success; false if the module was removed.
- */
-bool mei_cl_bus_module_get(struct mei_cl *cl)
-{
-	struct mei_cl_device *cldev = cl->cldev;
-
-	if (!cldev)
-		return true;
-
-	return try_module_get(cldev->bus->dev->driver->owner);
-}
-
-/**
- * mei_cl_bus_module_put -  release the underlying hw module.
- *
- * @cl: host client
- */
-void mei_cl_bus_module_put(struct mei_cl *cl)
-{
-	struct mei_cl_device *cldev = cl->cldev;
-
-	if (cldev)
-		module_put(cldev->bus->dev->driver->owner);
-}
-
 /**
  * mei_cl_device_find - find matching entry in the driver id table
  *

commit 7ae079aca59f560d2a44b65d45dffdefed6bd17a
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Wed Feb 14 14:03:29 2018 +0200

    mei: set device client to the disconnected state upon suspend.
    
    This fixes regression introduced by
    commit 8d52af6795c0 ("mei: speed up the power down flow")
    
    In mei_cldev_disable during device power down flow, such as
    suspend or system power off, it jumps over disconnecting function
    to speed up the power down process, however, because the client is
    unlinked from the file_list (mei_cl_unlink) mei_cl_set_disconnected
    is not called from mei_cl_all_disconnect leaving resource leaking.
    The most visible is reference counter on underlying HW module is
    not decreased preventing to remove modules after suspend/resume cycles.
    
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Fixes: 8d52af6795c0 ("mei: speed up the power down flow")
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 3e5eabdae8d9..772d02922529 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -548,12 +548,6 @@ int mei_cldev_disable(struct mei_cl_device *cldev)
 		goto out;
 	}
 
-	if (bus->dev_state == MEI_DEV_POWER_DOWN) {
-		dev_dbg(bus->dev, "Device is powering down, don't bother with disconnection\n");
-		err = 0;
-		goto out;
-	}
-
 	err = mei_cl_disconnect(cl);
 	if (err < 0)
 		dev_err(bus->dev, "Could not disconnect from the ME client\n");

commit 8a943bd283ecbaaab26b184717bd2395af1da1e4
Author: Colin Ian King <colin.king@canonical.com>
Date:   Sat Dec 16 23:44:24 2017 +0000

    mei: fix spelling mistake: "botther" -> "bother"
    
    Trivial fix to spelling mistake in dev_dbg debug message. Also
    add in a missing comma.
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 2a5146bdecf1..3e5eabdae8d9 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -549,7 +549,7 @@ int mei_cldev_disable(struct mei_cl_device *cldev)
 	}
 
 	if (bus->dev_state == MEI_DEV_POWER_DOWN) {
-		dev_dbg(bus->dev, "Device is powering down don't botther with disconnection\n");
+		dev_dbg(bus->dev, "Device is powering down, don't bother with disconnection\n");
 		err = 0;
 		goto out;
 	}

commit 8d52af6795c0480a20272159103976a893603fde
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Tue Dec 12 13:27:06 2017 +0200

    mei: speed up the power down flow
    
    When mei driver is powering down due to suspend or shutdown
    it will iterate over the mei client bus and disconnect
    each client device attached in turn.
    The power down flow consist of the link rest, which causes all clients
    get disconnected at once, hence the individual disconnection
    can be omitted and significantly reduce power down flow.
    
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 1ac10cb64d6e..2a5146bdecf1 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -543,14 +543,20 @@ int mei_cldev_disable(struct mei_cl_device *cldev)
 	mutex_lock(&bus->device_lock);
 
 	if (!mei_cl_is_connected(cl)) {
-		dev_dbg(bus->dev, "Already disconnected");
+		dev_dbg(bus->dev, "Already disconnected\n");
+		err = 0;
+		goto out;
+	}
+
+	if (bus->dev_state == MEI_DEV_POWER_DOWN) {
+		dev_dbg(bus->dev, "Device is powering down don't botther with disconnection\n");
 		err = 0;
 		goto out;
 	}
 
 	err = mei_cl_disconnect(cl);
 	if (err < 0)
-		dev_err(bus->dev, "Could not disconnect from the ME client");
+		dev_err(bus->dev, "Could not disconnect from the ME client\n");
 
 out:
 	/* Flush queues and remove any pending read */

commit b8d01b7fbaa3b9d5887ec6c6fea36fb57bbc4d6b
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Sat Aug 19 13:52:16 2017 +0530

    mei: make device_type const
    
    Make this const as it is only stored in the type field of a device
    structure, which is const.
    Done using Coccinelle.
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 40c79089e548..1ac10cb64d6e 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -845,7 +845,7 @@ static void mei_cl_bus_dev_release(struct device *dev)
 	kfree(cldev);
 }
 
-static struct device_type mei_cl_device_type = {
+static const struct device_type mei_cl_device_type = {
 	.release	= mei_cl_bus_dev_release,
 };
 

commit 069a0f32c9ca75ec7f02146711ec1f5840a68cbf
Merge: aca4e68acf3a 32c1431eea48
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Jun 12 08:18:10 2017 +0200

    Merge 4.12-rc5 into char-misc-next
    
    We want the char/misc driver fixes in here as well.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 6f9193ec044a8f72d8b6ae94a5c4ab6e8b0f00ca
Author: Pratyush Anand <panand@redhat.com>
Date:   Mon May 29 22:08:24 2017 +0300

    mei: make sysfs modalias format similar as uevent modalias
    
    modprobe is not able to resolve sysfs modalias for mei devices.
    
     # cat
    /sys/class/watchdog/watchdog0/device/watchdog/watchdog0/device/modalias
    mei::05b79a6f-4628-4d7f-899d-a91514cb32ab:
     # modprobe --set-version 4.9.6-200.fc25.x86_64 -R
    mei::05b79a6f-4628-4d7f-899d-a91514cb32ab:
    modprobe: FATAL: Module mei::05b79a6f-4628-4d7f-899d-a91514cb32ab: not
    found in directory /lib/modules/4.9.6-200.fc25.x86_64
     # cat /lib/modules/4.9.6-200.fc25.x86_64/modules.alias | grep
    05b79a6f-4628-4d7f-899d-a91514cb32ab
    alias mei:*:05b79a6f-4628-4d7f-899d-a91514cb32ab:*:* mei_wdt
    
    commit b26864cad1c9 ("mei: bus: add client protocol
    version to the device alias"), however sysfs modalias
    is still in formmat mei:S:uuid:*.
    
    This patch equates format of uevent and sysfs modalias so that modprobe
    is able to resolve the aliases.
    
    Cc: <stable@vger.kernel.org> 4.7+
    Fixes: commit b26864cad1c9 ("mei: bus: add client protocol version to the device alias")
    Signed-off-by: Pratyush Anand <panand@redhat.com>
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index d1928fdd0f43..07aad8576334 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -763,8 +763,10 @@ static ssize_t modalias_show(struct device *dev, struct device_attribute *a,
 {
 	struct mei_cl_device *cldev = to_mei_cl_device(dev);
 	const uuid_le *uuid = mei_me_cl_uuid(cldev->me_cl);
+	u8 version = mei_me_cl_ver(cldev->me_cl);
 
-	return scnprintf(buf, PAGE_SIZE, "mei:%s:%pUl:", cldev->name, uuid);
+	return scnprintf(buf, PAGE_SIZE, "mei:%s:%pUl:%02X:",
+			 cldev->name, uuid, version);
 }
 static DEVICE_ATTR_RO(modalias);
 

commit 8bb2d27f837d72f247bfa341a5ccf2d54d2b7d2d
Author: Alexander Usyskin <alexander.usyskin@intel.com>
Date:   Sun Apr 30 13:12:10 2017 +0300

    mei: make mei_cl_bus_rescan static
    
    mei_cl_bus_rescan is used only in bus.c,
    so make it local to the file and mark static.
    
    Signed-off-by: Alexander Usyskin <alexander.usyskin@intel.com>
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index d1928fdd0f43..42078e6be47f 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -1038,7 +1038,7 @@ static void mei_cl_bus_dev_init(struct mei_device *bus,
  *
  * @bus: mei device
  */
-void mei_cl_bus_rescan(struct mei_device *bus)
+static void mei_cl_bus_rescan(struct mei_device *bus)
 {
 	struct mei_cl_device *cldev, *n;
 	struct mei_me_client *me_cl;

commit 394a77d0bb63756871750400068d8b0c3582fba7
Author: Alexander Usyskin <alexander.usyskin@intel.com>
Date:   Mon Mar 20 15:04:03 2017 +0200

    mei: drop amthif internal client
    
    AMTHIF has special support in the mei drive, it handles multiplexing
    multiple user space connection above single me client connection.
    Since there is no additional addressing information there is a strict
    requirement on the traffic order on each connection and on the "read
    after write" order within the connection. This creates a lot of
    complexity mostly because the other client types do not necessarily fall
    under the same restriction.    After carefully studying the use of the
    AMTHIF client, we came to conclusion that the multiplexing is not really
    utilized by any application and we may safely remove that support and
    significantly simplify the driver.
    
    Signed-off-by: Alexander Usyskin <alexander.usyskin@intel.com>
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index df5f78ae3d25..d1928fdd0f43 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -1076,12 +1076,6 @@ void mei_cl_bus_rescan_work(struct work_struct *work)
 {
 	struct mei_device *bus =
 		container_of(work, struct mei_device, bus_rescan_work);
-	struct mei_me_client *me_cl;
-
-	me_cl = mei_me_cl_by_uuid(bus, &mei_amthif_guid);
-	if (me_cl)
-		mei_amthif_host_init(bus, me_cl);
-	mei_me_cl_put(me_cl);
 
 	mei_cl_bus_rescan(bus);
 }

commit 174cd4b1e5fbd0d74c68cf3a74f5bd4923485512
Author: Ingo Molnar <mingo@kernel.org>
Date:   Thu Feb 2 19:15:33 2017 +0100

    sched/headers: Prepare to move signal wakeup & sigpending methods from <linux/sched.h> into <linux/sched/signal.h>
    
    Fix up affected files that include this signal functionality via sched.h.
    
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index cb3e9e0ca049..df5f78ae3d25 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -16,7 +16,7 @@
 #include <linux/module.h>
 #include <linux/device.h>
 #include <linux/kernel.h>
-#include <linux/sched.h>
+#include <linux/sched/signal.h>
 #include <linux/init.h>
 #include <linux/errno.h>
 #include <linux/slab.h>

commit 57080e88240a46c62cf7538de009545eb03d2568
Author: Alexander Usyskin <alexander.usyskin@intel.com>
Date:   Fri Jan 27 16:32:40 2017 +0200

    mei: bus: unregister callbacks upon me client disable call
    
    Stop and unregister receive and notification callbacks
    from the disable function, to allow its later re-enablement.
    
    Signed-off-by: Alexander Usyskin <alexander.usyskin@intel.com>
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index b67f15b53067..cb3e9e0ca049 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -498,6 +498,25 @@ int mei_cldev_enable(struct mei_cl_device *cldev)
 }
 EXPORT_SYMBOL_GPL(mei_cldev_enable);
 
+/**
+ * mei_cldev_unregister_callbacks - internal wrapper for unregistering
+ *  callbacks.
+ *
+ * @cldev: client device
+ */
+static void mei_cldev_unregister_callbacks(struct mei_cl_device *cldev)
+{
+	if (cldev->rx_cb) {
+		cancel_work_sync(&cldev->rx_work);
+		cldev->rx_cb = NULL;
+	}
+
+	if (cldev->notif_cb) {
+		cancel_work_sync(&cldev->notif_work);
+		cldev->notif_cb = NULL;
+	}
+}
+
 /**
  * mei_cldev_disable - disable me client device
  *     disconnect form the me client
@@ -519,6 +538,8 @@ int mei_cldev_disable(struct mei_cl_device *cldev)
 
 	bus = cldev->bus;
 
+	mei_cldev_unregister_callbacks(cldev);
+
 	mutex_lock(&bus->device_lock);
 
 	if (!mei_cl_is_connected(cl)) {
@@ -700,14 +721,7 @@ static int mei_cl_device_remove(struct device *dev)
 	if (cldrv->remove)
 		ret = cldrv->remove(cldev);
 
-	if (cldev->rx_cb) {
-		cancel_work_sync(&cldev->rx_work);
-		cldev->rx_cb = NULL;
-	}
-	if (cldev->notif_cb) {
-		cancel_work_sync(&cldev->notif_work);
-		cldev->notif_cb = NULL;
-	}
+	mei_cldev_unregister_callbacks(cldev);
 
 	module_put(THIS_MODULE);
 	dev->driver = NULL;

commit 5d88246090c5e9b178eb05bcfb52bbaad2ae48f3
Author: Alexander Usyskin <alexander.usyskin@intel.com>
Date:   Fri Jan 27 16:32:39 2017 +0200

    mei: bus: prevent hardware module unload if device on bus is active
    
    The hardware module should not be unloaded if the bus
    has active devices.
    Get get_/put_ bus parent module upon client device
    connection/disconnection, to prevent the hardware managing
    module to disappear underneath.
    
    Signed-off-by: Alexander Usyskin <alexander.usyskin@intel.com>
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 3bb1f1500f6b..b67f15b53067 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -541,6 +541,37 @@ int mei_cldev_disable(struct mei_cl_device *cldev)
 }
 EXPORT_SYMBOL_GPL(mei_cldev_disable);
 
+/**
+ * mei_cl_bus_module_get - acquire module of the underlying
+ *    hw module.
+ *
+ * @cl: host client
+ *
+ * Return: true on success; false if the module was removed.
+ */
+bool mei_cl_bus_module_get(struct mei_cl *cl)
+{
+	struct mei_cl_device *cldev = cl->cldev;
+
+	if (!cldev)
+		return true;
+
+	return try_module_get(cldev->bus->dev->driver->owner);
+}
+
+/**
+ * mei_cl_bus_module_put -  release the underlying hw module.
+ *
+ * @cl: host client
+ */
+void mei_cl_bus_module_put(struct mei_cl *cl)
+{
+	struct mei_cl_device *cldev = cl->cldev;
+
+	if (cldev)
+		module_put(cldev->bus->dev->driver->owner);
+}
+
 /**
  * mei_cl_device_find - find matching entry in the driver id table
  *

commit 9ecb839f16a353e71175981a098842fda4ddc7f1
Author: Alexander Usyskin <alexander.usyskin@intel.com>
Date:   Fri Jan 27 16:32:38 2017 +0200

    mei: bus: cancel and disable callback after release call
    
    A driver on the mei bus may rely on the availability
    of the receive callback during driver remove() call, e.g. mei_wdt.
    Move callbacks dismantling after the remove() call to unblock that scenario.
    
    Signed-off-by: Alexander Usyskin <alexander.usyskin@intel.com>
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 2d9c5dd06e42..3bb1f1500f6b 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -665,6 +665,10 @@ static int mei_cl_device_remove(struct device *dev)
 	if (!cldev || !dev->driver)
 		return 0;
 
+	cldrv = to_mei_cl_driver(dev->driver);
+	if (cldrv->remove)
+		ret = cldrv->remove(cldev);
+
 	if (cldev->rx_cb) {
 		cancel_work_sync(&cldev->rx_work);
 		cldev->rx_cb = NULL;
@@ -674,10 +678,6 @@ static int mei_cl_device_remove(struct device *dev)
 		cldev->notif_cb = NULL;
 	}
 
-	cldrv = to_mei_cl_driver(dev->driver);
-	if (cldrv->remove)
-		ret = cldrv->remove(cldev);
-
 	module_put(THIS_MODULE);
 	dev->driver = NULL;
 	return ret;

commit 5026c9cb0744a9cd40242743ca91a5d712f468c6
Author: Alexander Usyskin <alexander.usyskin@intel.com>
Date:   Wed Dec 14 17:56:51 2016 +0200

    mei: bus: fix mei_cldev_enable KDoc
    
    Adjust function name in KDoc.
    
    Fixes: d49dc5e76fc9 (mei: bus: use mei_cldev_ prefix for the API functions)
    Signed-off-by: Alexander Usyskin <alexander.usyskin@intel.com>
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 0037153c80a6..2d9c5dd06e42 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -450,7 +450,7 @@ bool mei_cldev_enabled(struct mei_cl_device *cldev)
 EXPORT_SYMBOL_GPL(mei_cldev_enabled);
 
 /**
- * mei_cldev_enable_device - enable me client device
+ * mei_cldev_enable - enable me client device
  *     create connection with me client
  *
  * @cldev: me client device

commit 076802d0061520bc646ee121fe0f34fce6c55a93
Author: Alexander Usyskin <alexander.usyskin@intel.com>
Date:   Sat Dec 3 00:15:25 2016 +0200

    mei: bus: enable non-blocking RX
    
    Enable non-blocking receive for drivers on mei bus, this allows checking
    for data availability by mei client drivers. This is most effective for
    fixed address clients, that lacks flow control.
    
    This function adds new API function mei_cldev_recv_nonblock(), it
    retuns -EGAIN if function will block.
    
    Signed-off-by: Alexander Usyskin <alexander.usyskin@intel.com>
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 2fd254ecde2f..0037153c80a6 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -98,15 +98,18 @@ ssize_t __mei_cl_send(struct mei_cl *cl, u8 *buf, size_t length,
  * @cl: host client
  * @buf: buffer to receive
  * @length: buffer length
+ * @mode: io mode
  *
  * Return: read size in bytes of < 0 on error
  */
-ssize_t __mei_cl_recv(struct mei_cl *cl, u8 *buf, size_t length)
+ssize_t __mei_cl_recv(struct mei_cl *cl, u8 *buf, size_t length,
+		      unsigned int mode)
 {
 	struct mei_device *bus;
 	struct mei_cl_cb *cb;
 	size_t r_length;
 	ssize_t rets;
+	bool nonblock = !!(mode & MEI_CL_IO_RX_NONBLOCK);
 
 	if (WARN_ON(!cl || !cl->dev))
 		return -ENODEV;
@@ -127,6 +130,11 @@ ssize_t __mei_cl_recv(struct mei_cl *cl, u8 *buf, size_t length)
 	if (rets && rets != -EBUSY)
 		goto out;
 
+	if (nonblock) {
+		rets = -EAGAIN;
+		goto out;
+	}
+
 	/* wait on event only if there is no other waiter */
 	/* synchronized under device mutex */
 	if (!waitqueue_active(&cl->rx_wait)) {
@@ -191,6 +199,25 @@ ssize_t mei_cldev_send(struct mei_cl_device *cldev, u8 *buf, size_t length)
 }
 EXPORT_SYMBOL_GPL(mei_cldev_send);
 
+/**
+ * mei_cldev_recv_nonblock - non block client receive (read)
+ *
+ * @cldev: me client device
+ * @buf: buffer to receive
+ * @length: buffer length
+ *
+ * Return: read size in bytes of < 0 on error
+ *         -EAGAIN if function will block.
+ */
+ssize_t mei_cldev_recv_nonblock(struct mei_cl_device *cldev, u8 *buf,
+				size_t length)
+{
+	struct mei_cl *cl = cldev->cl;
+
+	return __mei_cl_recv(cl, buf, length, MEI_CL_IO_RX_NONBLOCK);
+}
+EXPORT_SYMBOL_GPL(mei_cldev_recv_nonblock);
+
 /**
  * mei_cldev_recv - client receive (read)
  *
@@ -204,7 +231,7 @@ ssize_t mei_cldev_recv(struct mei_cl_device *cldev, u8 *buf, size_t length)
 {
 	struct mei_cl *cl = cldev->cl;
 
-	return __mei_cl_recv(cl, buf, length);
+	return __mei_cl_recv(cl, buf, length, 0);
 }
 EXPORT_SYMBOL_GPL(mei_cldev_recv);
 

commit 7c7a6077f5c7a35fc03a7f452875d8440dd1bc8d
Author: Alexander Usyskin <alexander.usyskin@intel.com>
Date:   Wed Nov 16 22:51:29 2016 +0200

    mei: bus: split RX and async notification callbacks
    
    Split callbacks for RX and async notification events on mei bus to
    eliminate synchronization problems and to open way for RX optimizations.
    
    Signed-off-by: Alexander Usyskin <alexander.usyskin@intel.com>
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 483587f60249..2fd254ecde2f 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -209,31 +209,40 @@ ssize_t mei_cldev_recv(struct mei_cl_device *cldev, u8 *buf, size_t length)
 EXPORT_SYMBOL_GPL(mei_cldev_recv);
 
 /**
- * mei_cl_bus_event_work  - dispatch rx event for a bus device
- *    and schedule new work
+ * mei_cl_bus_rx_work - dispatch rx event for a bus device
  *
  * @work: work
  */
-static void mei_cl_bus_event_work(struct work_struct *work)
+static void mei_cl_bus_rx_work(struct work_struct *work)
 {
 	struct mei_cl_device *cldev;
 	struct mei_device *bus;
 
-	cldev = container_of(work, struct mei_cl_device, event_work);
+	cldev = container_of(work, struct mei_cl_device, rx_work);
 
 	bus = cldev->bus;
 
-	if (cldev->event_cb)
-		cldev->event_cb(cldev, cldev->events);
+	if (cldev->rx_cb)
+		cldev->rx_cb(cldev);
 
-	cldev->events = 0;
+	mutex_lock(&bus->device_lock);
+	mei_cl_read_start(cldev->cl, mei_cl_mtu(cldev->cl), NULL);
+	mutex_unlock(&bus->device_lock);
+}
 
-	/* Prepare for the next read */
-	if (cldev->events_mask & BIT(MEI_CL_EVENT_RX)) {
-		mutex_lock(&bus->device_lock);
-		mei_cl_read_start(cldev->cl, mei_cl_mtu(cldev->cl), NULL);
-		mutex_unlock(&bus->device_lock);
-	}
+/**
+ * mei_cl_bus_notif_work - dispatch FW notif event for a bus device
+ *
+ * @work: work
+ */
+static void mei_cl_bus_notif_work(struct work_struct *work)
+{
+	struct mei_cl_device *cldev;
+
+	cldev = container_of(work, struct mei_cl_device, notif_work);
+
+	if (cldev->notif_cb)
+		cldev->notif_cb(cldev);
 }
 
 /**
@@ -248,18 +257,13 @@ bool mei_cl_bus_notify_event(struct mei_cl *cl)
 {
 	struct mei_cl_device *cldev = cl->cldev;
 
-	if (!cldev || !cldev->event_cb)
-		return false;
-
-	if (!(cldev->events_mask & BIT(MEI_CL_EVENT_NOTIF)))
+	if (!cldev || !cldev->notif_cb)
 		return false;
 
 	if (!cl->notify_ev)
 		return false;
 
-	set_bit(MEI_CL_EVENT_NOTIF, &cldev->events);
-
-	schedule_work(&cldev->event_work);
+	schedule_work(&cldev->notif_work);
 
 	cl->notify_ev = false;
 
@@ -267,7 +271,7 @@ bool mei_cl_bus_notify_event(struct mei_cl *cl)
 }
 
 /**
- * mei_cl_bus_rx_event  - schedule rx event
+ * mei_cl_bus_rx_event - schedule rx event
  *
  * @cl: host client
  *
@@ -278,64 +282,81 @@ bool mei_cl_bus_rx_event(struct mei_cl *cl)
 {
 	struct mei_cl_device *cldev = cl->cldev;
 
-	if (!cldev || !cldev->event_cb)
-		return false;
-
-	if (!(cldev->events_mask & BIT(MEI_CL_EVENT_RX)))
+	if (!cldev || !cldev->rx_cb)
 		return false;
 
-	set_bit(MEI_CL_EVENT_RX, &cldev->events);
-
-	schedule_work(&cldev->event_work);
+	schedule_work(&cldev->rx_work);
 
 	return true;
 }
 
 /**
- * mei_cldev_register_event_cb - register event callback
+ * mei_cldev_register_rx_cb - register Rx event callback
  *
  * @cldev: me client devices
- * @event_cb: callback function
- * @events_mask: requested events bitmask
+ * @rx_cb: callback function
  *
  * Return: 0 on success
  *         -EALREADY if an callback is already registered
  *         <0 on other errors
  */
-int mei_cldev_register_event_cb(struct mei_cl_device *cldev,
-				unsigned long events_mask,
-				mei_cldev_event_cb_t event_cb)
+int mei_cldev_register_rx_cb(struct mei_cl_device *cldev, mei_cldev_cb_t rx_cb)
 {
 	struct mei_device *bus = cldev->bus;
 	int ret;
 
-	if (cldev->event_cb)
+	if (!rx_cb)
+		return -EINVAL;
+	if (cldev->rx_cb)
 		return -EALREADY;
 
-	cldev->events = 0;
-	cldev->events_mask = events_mask;
-	cldev->event_cb = event_cb;
-	INIT_WORK(&cldev->event_work, mei_cl_bus_event_work);
+	cldev->rx_cb = rx_cb;
+	INIT_WORK(&cldev->rx_work, mei_cl_bus_rx_work);
 
-	if (cldev->events_mask & BIT(MEI_CL_EVENT_RX)) {
-		mutex_lock(&bus->device_lock);
-		ret = mei_cl_read_start(cldev->cl, mei_cl_mtu(cldev->cl), NULL);
-		mutex_unlock(&bus->device_lock);
-		if (ret && ret != -EBUSY)
-			return ret;
-	}
+	mutex_lock(&bus->device_lock);
+	ret = mei_cl_read_start(cldev->cl, mei_cl_mtu(cldev->cl), NULL);
+	mutex_unlock(&bus->device_lock);
+	if (ret && ret != -EBUSY)
+		return ret;
 
-	if (cldev->events_mask & BIT(MEI_CL_EVENT_NOTIF)) {
-		mutex_lock(&bus->device_lock);
-		ret = mei_cl_notify_request(cldev->cl, NULL, event_cb ? 1 : 0);
-		mutex_unlock(&bus->device_lock);
-		if (ret)
-			return ret;
-	}
+	return 0;
+}
+EXPORT_SYMBOL_GPL(mei_cldev_register_rx_cb);
+
+/**
+ * mei_cldev_register_notif_cb - register FW notification event callback
+ *
+ * @cldev: me client devices
+ * @notif_cb: callback function
+ *
+ * Return: 0 on success
+ *         -EALREADY if an callback is already registered
+ *         <0 on other errors
+ */
+int mei_cldev_register_notif_cb(struct mei_cl_device *cldev,
+				mei_cldev_cb_t notif_cb)
+{
+	struct mei_device *bus = cldev->bus;
+	int ret;
+
+	if (!notif_cb)
+		return -EINVAL;
+
+	if (cldev->notif_cb)
+		return -EALREADY;
+
+	cldev->notif_cb = notif_cb;
+	INIT_WORK(&cldev->notif_work, mei_cl_bus_notif_work);
+
+	mutex_lock(&bus->device_lock);
+	ret = mei_cl_notify_request(cldev->cl, NULL, 1);
+	mutex_unlock(&bus->device_lock);
+	if (ret)
+		return ret;
 
 	return 0;
 }
-EXPORT_SYMBOL_GPL(mei_cldev_register_event_cb);
+EXPORT_SYMBOL_GPL(mei_cldev_register_notif_cb);
 
 /**
  * mei_cldev_get_drvdata - driver data getter
@@ -471,8 +492,6 @@ int mei_cldev_disable(struct mei_cl_device *cldev)
 
 	bus = cldev->bus;
 
-	cldev->event_cb = NULL;
-
 	mutex_lock(&bus->device_lock);
 
 	if (!mei_cl_is_connected(cl)) {
@@ -619,9 +638,13 @@ static int mei_cl_device_remove(struct device *dev)
 	if (!cldev || !dev->driver)
 		return 0;
 
-	if (cldev->event_cb) {
-		cldev->event_cb = NULL;
-		cancel_work_sync(&cldev->event_work);
+	if (cldev->rx_cb) {
+		cancel_work_sync(&cldev->rx_work);
+		cldev->rx_cb = NULL;
+	}
+	if (cldev->notif_cb) {
+		cancel_work_sync(&cldev->notif_work);
+		cldev->notif_cb = NULL;
 	}
 
 	cldrv = to_mei_cl_driver(dev->driver);

commit c110cdb171488c60295d49fda16634cfec58ae28
Author: Alexander Usyskin <alexander.usyskin@intel.com>
Date:   Wed Nov 16 22:51:28 2016 +0200

    mei: bus: make a client pointer always available
    
    Change life time of the client pointer, allocate it upon client device
    creation and free it upon device destruction, instead of upon
    connection and disconnection.
    This helps to eliminate racy NULL checks in the bus code.
    
    Signed-off-by: Alexander Usyskin <alexander.usyskin@intel.com>
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 7c075e9b25e5..483587f60249 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -187,9 +187,6 @@ ssize_t mei_cldev_send(struct mei_cl_device *cldev, u8 *buf, size_t length)
 {
 	struct mei_cl *cl = cldev->cl;
 
-	if (cl == NULL)
-		return -ENODEV;
-
 	return __mei_cl_send(cl, buf, length, MEI_CL_IO_TX_BLOCKING);
 }
 EXPORT_SYMBOL_GPL(mei_cldev_send);
@@ -207,9 +204,6 @@ ssize_t mei_cldev_recv(struct mei_cl_device *cldev, u8 *buf, size_t length)
 {
 	struct mei_cl *cl = cldev->cl;
 
-	if (cl == NULL)
-		return -ENODEV;
-
 	return __mei_cl_recv(cl, buf, length);
 }
 EXPORT_SYMBOL_GPL(mei_cldev_recv);
@@ -403,7 +397,7 @@ EXPORT_SYMBOL_GPL(mei_cldev_ver);
  */
 bool mei_cldev_enabled(struct mei_cl_device *cldev)
 {
-	return cldev->cl && mei_cl_is_connected(cldev->cl);
+	return mei_cl_is_connected(cldev->cl);
 }
 EXPORT_SYMBOL_GPL(mei_cldev_enabled);
 
@@ -423,14 +417,13 @@ int mei_cldev_enable(struct mei_cl_device *cldev)
 
 	cl = cldev->cl;
 
-	if (!cl) {
+	if (cl->state == MEI_FILE_UNINITIALIZED) {
 		mutex_lock(&bus->device_lock);
-		cl = mei_cl_alloc_linked(bus);
+		ret = mei_cl_link(cl);
 		mutex_unlock(&bus->device_lock);
-		if (IS_ERR(cl))
-			return PTR_ERR(cl);
+		if (ret)
+			return ret;
 		/* update pointers */
-		cldev->cl = cl;
 		cl->cldev = cldev;
 	}
 
@@ -471,7 +464,7 @@ int mei_cldev_disable(struct mei_cl_device *cldev)
 	struct mei_cl *cl;
 	int err;
 
-	if (!cldev || !cldev->cl)
+	if (!cldev)
 		return -ENODEV;
 
 	cl = cldev->cl;
@@ -497,9 +490,6 @@ int mei_cldev_disable(struct mei_cl_device *cldev)
 	mei_cl_flush_queues(cl, NULL);
 	mei_cl_unlink(cl);
 
-	kfree(cl);
-	cldev->cl = NULL;
-
 	mutex_unlock(&bus->device_lock);
 	return err;
 }
@@ -754,6 +744,7 @@ static void mei_cl_bus_dev_release(struct device *dev)
 
 	mei_me_cl_put(cldev->me_cl);
 	mei_dev_bus_put(cldev->bus);
+	kfree(cldev->cl);
 	kfree(cldev);
 }
 
@@ -786,17 +777,25 @@ static struct mei_cl_device *mei_cl_bus_dev_alloc(struct mei_device *bus,
 						  struct mei_me_client *me_cl)
 {
 	struct mei_cl_device *cldev;
+	struct mei_cl *cl;
 
 	cldev = kzalloc(sizeof(struct mei_cl_device), GFP_KERNEL);
 	if (!cldev)
 		return NULL;
 
+	cl = mei_cl_allocate(bus);
+	if (!cl) {
+		kfree(cldev);
+		return NULL;
+	}
+
 	device_initialize(&cldev->dev);
 	cldev->dev.parent = bus->dev;
 	cldev->dev.bus    = &mei_cl_bus_type;
 	cldev->dev.type   = &mei_cl_device_type;
 	cldev->bus        = mei_dev_bus_get(bus);
 	cldev->me_cl      = mei_me_cl_get(me_cl);
+	cldev->cl         = cl;
 	mei_cl_bus_set_name(cldev);
 	cldev->is_added   = 0;
 	INIT_LIST_HEAD(&cldev->bus_list);

commit e0cb6b2f878d210441e8ed232e98454ccc7fd812
Author: Alexander Usyskin <alexander.usyskin@intel.com>
Date:   Tue Nov 8 18:26:08 2016 +0200

    mei: enable to set the internal flag for client write
    
    Prepare the client write functions to set the internal flag in message
    header. Carry both blocking and internal modes inside the transmit cb,
    and call internal bus function  __mei_cl_send() with send mode bit mask.
    The Internal flag should be added only on messages generated by the
    driver.
    
    Signed-off-by: Alexander Usyskin <alexander.usyskin@intel.com>
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 8a1e813a548d..7c075e9b25e5 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -36,12 +36,12 @@
  * @cl: host client
  * @buf: buffer to send
  * @length: buffer length
- * @blocking: wait for write completion
+ * @mode: sending mode
  *
  * Return: written size bytes or < 0 on error
  */
 ssize_t __mei_cl_send(struct mei_cl *cl, u8 *buf, size_t length,
-			bool blocking)
+		      unsigned int mode)
 {
 	struct mei_device *bus;
 	struct mei_cl_cb *cb;
@@ -80,9 +80,11 @@ ssize_t __mei_cl_send(struct mei_cl *cl, u8 *buf, size_t length,
 		goto out;
 	}
 
+	cb->internal = !!(mode & MEI_CL_IO_TX_INTERNAL);
+	cb->blocking = !!(mode & MEI_CL_IO_TX_BLOCKING);
 	memcpy(cb->buf.data, buf, length);
 
-	rets = mei_cl_write(cl, cb, blocking);
+	rets = mei_cl_write(cl, cb);
 
 out:
 	mutex_unlock(&bus->device_lock);
@@ -188,7 +190,7 @@ ssize_t mei_cldev_send(struct mei_cl_device *cldev, u8 *buf, size_t length)
 	if (cl == NULL)
 		return -ENODEV;
 
-	return __mei_cl_send(cl, buf, length, 1);
+	return __mei_cl_send(cl, buf, length, MEI_CL_IO_TX_BLOCKING);
 }
 EXPORT_SYMBOL_GPL(mei_cldev_send);
 

commit d882039e7617a654161cf03db444e13a2e2554db
Author: Alexander Usyskin <alexander.usyskin@intel.com>
Date:   Sun Oct 30 01:42:19 2016 +0200

    mei: bus: demote error to debug level upon disconnect
    
    A mei client driver on the mei client bus can call disconnect function on
    already internal disconnected client.  A client can disconnect internally,
    for example, during link reset or upon FW request. Those are legitimate
    flows and we should not log an error message, hence we demote
    'Already disconnected' message to the debug level.
    
    Signed-off-by: Alexander Usyskin <alexander.usyskin@intel.com>
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 89a694ca624c..8a1e813a548d 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -481,7 +481,7 @@ int mei_cldev_disable(struct mei_cl_device *cldev)
 	mutex_lock(&bus->device_lock);
 
 	if (!mei_cl_is_connected(cl)) {
-		dev_err(bus->dev, "Already disconnected");
+		dev_dbg(bus->dev, "Already disconnected");
 		err = 0;
 		goto out;
 	}

commit 1e4edb3fe93ff9f7b678a8f1b8d9df717edf6ad9
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Wed Oct 19 16:33:31 2016 +0300

    mei: bus: remove rx callback context
    
    The callback context is redunant as all the information can be
    retrived from the device struture of its private data.
    
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 8cac7ef9ad0d..89a694ca624c 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -228,7 +228,7 @@ static void mei_cl_bus_event_work(struct work_struct *work)
 	bus = cldev->bus;
 
 	if (cldev->event_cb)
-		cldev->event_cb(cldev, cldev->events, cldev->event_context);
+		cldev->event_cb(cldev, cldev->events);
 
 	cldev->events = 0;
 
@@ -301,7 +301,6 @@ bool mei_cl_bus_rx_event(struct mei_cl *cl)
  * @cldev: me client devices
  * @event_cb: callback function
  * @events_mask: requested events bitmask
- * @context: driver context data
  *
  * Return: 0 on success
  *         -EALREADY if an callback is already registered
@@ -309,7 +308,7 @@ bool mei_cl_bus_rx_event(struct mei_cl *cl)
  */
 int mei_cldev_register_event_cb(struct mei_cl_device *cldev,
 				unsigned long events_mask,
-				mei_cldev_event_cb_t event_cb, void *context)
+				mei_cldev_event_cb_t event_cb)
 {
 	struct mei_device *bus = cldev->bus;
 	int ret;
@@ -320,7 +319,6 @@ int mei_cldev_register_event_cb(struct mei_cl_device *cldev,
 	cldev->events = 0;
 	cldev->events_mask = events_mask;
 	cldev->event_cb = event_cb;
-	cldev->event_context = context;
 	INIT_WORK(&cldev->event_work, mei_cl_bus_event_work);
 
 	if (cldev->events_mask & BIT(MEI_CL_EVENT_RX)) {

commit e728ae271f4cf71218ec06a6daf61b79466cb466
Author: Alexander Usyskin <alexander.usyskin@intel.com>
Date:   Tue Jul 26 01:06:09 2016 +0300

    mei: amthif: fix deadlock in initialization during a reset
    
    The device lock was unnecessary obtained in bus rescan work before the
    amthif client search.  That causes incorrect lock ordering and task
    hang:
    ...
    [88004.613213] INFO: task kworker/1:14:21832 blocked for more than 120 seconds.
    ...
    [88004.645934] Workqueue: events mei_cl_bus_rescan_work
    ...
    
    The correct lock order is
     cl_bus_lock
      device_lock
       me_clients_rwsem
    
    Move device_lock into amthif init function that called
    after me_clients_rwsem is released.
    
    This fixes regression introduced by commit:
    commit 025fb792bac3 ("mei: split amthif client init from end of clients enumeration")
    
    Cc: <stable@vger.kernel.org> # 4.6+
    Signed-off-by: Alexander Usyskin <alexander.usyskin@intel.com>
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index cdf13f6d2697..8cac7ef9ad0d 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -984,12 +984,10 @@ void mei_cl_bus_rescan_work(struct work_struct *work)
 		container_of(work, struct mei_device, bus_rescan_work);
 	struct mei_me_client *me_cl;
 
-	mutex_lock(&bus->device_lock);
 	me_cl = mei_me_cl_by_uuid(bus, &mei_amthif_guid);
 	if (me_cl)
 		mei_amthif_host_init(bus, me_cl);
 	mei_me_cl_put(me_cl);
-	mutex_unlock(&bus->device_lock);
 
 	mei_cl_bus_rescan(bus);
 }

commit 3030dc056459439d756d81a920e135893076a348
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Tue Jul 26 01:06:05 2016 +0300

    mei: add wrapper for queuing control commands.
    
    Enclose the boiler plate code of allocating a control/hbm command cb
    and enqueueing it onto ctrl_wr.list in a convenient wrapper
    mei_cl_enqueue_ctrl_wr_cb().
    
    This is a preparatory patch for enabling consecutive reads.
    
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 9c404dc8eada..cdf13f6d2697 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -235,7 +235,7 @@ static void mei_cl_bus_event_work(struct work_struct *work)
 	/* Prepare for the next read */
 	if (cldev->events_mask & BIT(MEI_CL_EVENT_RX)) {
 		mutex_lock(&bus->device_lock);
-		mei_cl_read_start(cldev->cl, 0, NULL);
+		mei_cl_read_start(cldev->cl, mei_cl_mtu(cldev->cl), NULL);
 		mutex_unlock(&bus->device_lock);
 	}
 }
@@ -325,7 +325,7 @@ int mei_cldev_register_event_cb(struct mei_cl_device *cldev,
 
 	if (cldev->events_mask & BIT(MEI_CL_EVENT_RX)) {
 		mutex_lock(&bus->device_lock);
-		ret = mei_cl_read_start(cldev->cl, 0, NULL);
+		ret = mei_cl_read_start(cldev->cl, mei_cl_mtu(cldev->cl), NULL);
 		mutex_unlock(&bus->device_lock);
 		if (ret && ret != -EBUSY)
 			return ret;

commit 2d4d5481e2d6f93b25fcfb13a9f20bbfbf54266a
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Thu Jun 23 00:25:31 2016 +0300

    mei: fix return value on disconnection
    
    Correct errno on client disconnection is -ENODEV not -EBUSY
    
    Cc: <stable@vger.kernel.org> #4.3+
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Alexander Usyskin <alexander.usyskin@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 63411ddfb83d..9c404dc8eada 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -143,7 +143,7 @@ ssize_t __mei_cl_recv(struct mei_cl *cl, u8 *buf, size_t length)
 		mutex_lock(&bus->device_lock);
 
 		if (!mei_cl_is_connected(cl)) {
-			rets = -EBUSY;
+			rets = -ENODEV;
 			goto out;
 		}
 	}

commit 1eb5bd4d83f566e5ea8521b6020d0cfcb8f1c3ef
Author: Alexander Usyskin <alexander.usyskin@intel.com>
Date:   Thu Jun 16 17:58:54 2016 +0300

    mei: drop read complete queue emptiness check
    
    In the course of the read flow we want to wait for read completion only
    if the read queue is empty.
    However the calling list_empty(&cl->rd_completed) is a duplication as the
    same check was performed by mei_cl_read_cb() and the waiting is skipped
    if it returns not NULL.
    
    Signed-off-by: Alexander Usyskin <alexander.usyskin@intel.com>
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 1f33fea9299f..63411ddfb83d 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -126,7 +126,8 @@ ssize_t __mei_cl_recv(struct mei_cl *cl, u8 *buf, size_t length)
 		goto out;
 
 	/* wait on event only if there is no other waiter */
-	if (list_empty(&cl->rd_completed) && !waitqueue_active(&cl->rx_wait)) {
+	/* synchronized under device mutex */
+	if (!waitqueue_active(&cl->rx_wait)) {
 
 		mutex_unlock(&bus->device_lock);
 

commit bc46b45a421a64a0895dd41a34d3d2086e1ac7f6
Author: Alexander Usyskin <alexander.usyskin@intel.com>
Date:   Tue May 3 18:54:21 2016 -0400

    mei: bus: call mei_cl_read_start under device lock
    
    Ensure that mei_cl_read_start is called under the device lock
    also in the bus layer. The function updates global ctrl_wr_list
    which should be locked.
    
    Cc: <stable@vger.kernel.org> #4.4+
    Signed-off-by: Alexander Usyskin <alexander.usyskin@intel.com>
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index bc13f5f35a19..1f33fea9299f 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -220,17 +220,23 @@ EXPORT_SYMBOL_GPL(mei_cldev_recv);
 static void mei_cl_bus_event_work(struct work_struct *work)
 {
 	struct mei_cl_device *cldev;
+	struct mei_device *bus;
 
 	cldev = container_of(work, struct mei_cl_device, event_work);
 
+	bus = cldev->bus;
+
 	if (cldev->event_cb)
 		cldev->event_cb(cldev, cldev->events, cldev->event_context);
 
 	cldev->events = 0;
 
 	/* Prepare for the next read */
-	if (cldev->events_mask & BIT(MEI_CL_EVENT_RX))
+	if (cldev->events_mask & BIT(MEI_CL_EVENT_RX)) {
+		mutex_lock(&bus->device_lock);
 		mei_cl_read_start(cldev->cl, 0, NULL);
+		mutex_unlock(&bus->device_lock);
+	}
 }
 
 /**
@@ -304,6 +310,7 @@ int mei_cldev_register_event_cb(struct mei_cl_device *cldev,
 				unsigned long events_mask,
 				mei_cldev_event_cb_t event_cb, void *context)
 {
+	struct mei_device *bus = cldev->bus;
 	int ret;
 
 	if (cldev->event_cb)
@@ -316,15 +323,17 @@ int mei_cldev_register_event_cb(struct mei_cl_device *cldev,
 	INIT_WORK(&cldev->event_work, mei_cl_bus_event_work);
 
 	if (cldev->events_mask & BIT(MEI_CL_EVENT_RX)) {
+		mutex_lock(&bus->device_lock);
 		ret = mei_cl_read_start(cldev->cl, 0, NULL);
+		mutex_unlock(&bus->device_lock);
 		if (ret && ret != -EBUSY)
 			return ret;
 	}
 
 	if (cldev->events_mask & BIT(MEI_CL_EVENT_NOTIF)) {
-		mutex_lock(&cldev->cl->dev->device_lock);
+		mutex_lock(&bus->device_lock);
 		ret = mei_cl_notify_request(cldev->cl, NULL, event_cb ? 1 : 0);
-		mutex_unlock(&cldev->cl->dev->device_lock);
+		mutex_unlock(&bus->device_lock);
 		if (ret)
 			return ret;
 	}

commit b9c79543efcd0235d2fc1485c31ec9e9584f3ad7
Author: Alexey Khoroshilov <khoroshilov@ispras.ru>
Date:   Fri Apr 1 23:53:01 2016 +0300

    mei: do not pin module if cldrv->probe() failed
    
    If cldrv->probe() failed in mei_cl_device_probe(),
    the mei module is left pinned.
    
    The patch moves __module_get(THIS_MODULE) after cldrv->probe().
    
    Found by Linux Driver Verification project (linuxtesting.org).
    
    Signed-off-by: Alexey Khoroshilov <khoroshilov@ispras.ru>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 04dc05150898..bc13f5f35a19 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -580,6 +580,7 @@ static int mei_cl_device_probe(struct device *dev)
 	struct mei_cl_device *cldev;
 	struct mei_cl_driver *cldrv;
 	const struct mei_cl_device_id *id;
+	int ret;
 
 	cldev = to_mei_cl_device(dev);
 	cldrv = to_mei_cl_driver(dev->driver);
@@ -594,9 +595,12 @@ static int mei_cl_device_probe(struct device *dev)
 	if (!id)
 		return -ENODEV;
 
-	__module_get(THIS_MODULE);
+	ret = cldrv->probe(cldev, id);
+	if (ret)
+		return ret;
 
-	return cldrv->probe(cldev, id);
+	__module_get(THIS_MODULE);
+	return 0;
 }
 
 /**

commit 423de92f56bdfc3e68503af31e6ec041d59a6a25
Author: Rasmus Villemoes <linux@rasmusvillemoes.dk>
Date:   Thu Mar 24 10:38:04 2016 +0200

    mei: bus: use scnprintf in *_show
    
    There's no reason to duplicate the logic provided by scnprintf().
    
    Signed-off-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 5d5996e39a67..04dc05150898 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -634,11 +634,8 @@ static ssize_t name_show(struct device *dev, struct device_attribute *a,
 			     char *buf)
 {
 	struct mei_cl_device *cldev = to_mei_cl_device(dev);
-	size_t len;
 
-	len = snprintf(buf, PAGE_SIZE, "%s", cldev->name);
-
-	return (len >= PAGE_SIZE) ? (PAGE_SIZE - 1) : len;
+	return scnprintf(buf, PAGE_SIZE, "%s", cldev->name);
 }
 static DEVICE_ATTR_RO(name);
 
@@ -647,11 +644,8 @@ static ssize_t uuid_show(struct device *dev, struct device_attribute *a,
 {
 	struct mei_cl_device *cldev = to_mei_cl_device(dev);
 	const uuid_le *uuid = mei_me_cl_uuid(cldev->me_cl);
-	size_t len;
-
-	len = snprintf(buf, PAGE_SIZE, "%pUl", uuid);
 
-	return (len >= PAGE_SIZE) ? (PAGE_SIZE - 1) : len;
+	return scnprintf(buf, PAGE_SIZE, "%pUl", uuid);
 }
 static DEVICE_ATTR_RO(uuid);
 
@@ -660,11 +654,8 @@ static ssize_t version_show(struct device *dev, struct device_attribute *a,
 {
 	struct mei_cl_device *cldev = to_mei_cl_device(dev);
 	u8 version = mei_me_cl_ver(cldev->me_cl);
-	size_t len;
-
-	len = snprintf(buf, PAGE_SIZE, "%02X", version);
 
-	return (len >= PAGE_SIZE) ? (PAGE_SIZE - 1) : len;
+	return scnprintf(buf, PAGE_SIZE, "%02X", version);
 }
 static DEVICE_ATTR_RO(version);
 
@@ -673,10 +664,8 @@ static ssize_t modalias_show(struct device *dev, struct device_attribute *a,
 {
 	struct mei_cl_device *cldev = to_mei_cl_device(dev);
 	const uuid_le *uuid = mei_me_cl_uuid(cldev->me_cl);
-	size_t len;
 
-	len = snprintf(buf, PAGE_SIZE, "mei:%s:%pUl:", cldev->name, uuid);
-	return (len >= PAGE_SIZE) ? (PAGE_SIZE - 1) : len;
+	return scnprintf(buf, PAGE_SIZE, "mei:%s:%pUl:", cldev->name, uuid);
 }
 static DEVICE_ATTR_RO(modalias);
 

commit 6cbb097fd3903fd6b419303ee8dc7f72b47d06f0
Author: Alexander Usyskin <alexander.usyskin@intel.com>
Date:   Wed Feb 10 23:57:26 2016 +0200

    mei: fix double freeing of a cb during link reset
    
    Fix double freeing of the cb that can happen if link reset kicks  in the
    middle of blocked write from a device on the cl bus.
    
    Free cb inside mei_cl_write function on failure and drop cb free
    operation from callers, during a link reset the mei_cl_write function
    returns with an error,  but the caller doesn't know if the cb was
    already queued or not so it doesn't know if the cb will be freed upon
    queue reclaim or it has to free it itself.
    
    Signed-off-by: Alexander Usyskin <alexander.usyskin@intel.com>
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index f4cf43b47c7a..5d5996e39a67 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -44,7 +44,7 @@ ssize_t __mei_cl_send(struct mei_cl *cl, u8 *buf, size_t length,
 			bool blocking)
 {
 	struct mei_device *bus;
-	struct mei_cl_cb *cb = NULL;
+	struct mei_cl_cb *cb;
 	ssize_t rets;
 
 	if (WARN_ON(!cl || !cl->dev))
@@ -86,8 +86,6 @@ ssize_t __mei_cl_send(struct mei_cl *cl, u8 *buf, size_t length,
 
 out:
 	mutex_unlock(&bus->device_lock);
-	if (rets < 0)
-		mei_io_cb_free(cb);
 
 	return rets;
 }

commit 025fb792bac33632c19fe12265ba1f6108921300
Author: Alexander Usyskin <alexander.usyskin@intel.com>
Date:   Sun Feb 7 23:35:43 2016 +0200

    mei: split amthif client init from end of clients enumeration
    
    The amthif FW client can appear after the end of client enumeration.
    Amthif host client initialization is done now at FW client discovery
    time.
    
    Signed-off-by: Alexander Usyskin <alexander.usyskin@intel.com>
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 951d32265040..f4cf43b47c7a 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -981,6 +981,14 @@ void mei_cl_bus_rescan_work(struct work_struct *work)
 {
 	struct mei_device *bus =
 		container_of(work, struct mei_device, bus_rescan_work);
+	struct mei_me_client *me_cl;
+
+	mutex_lock(&bus->device_lock);
+	me_cl = mei_me_cl_by_uuid(bus, &mei_amthif_guid);
+	if (me_cl)
+		mei_amthif_host_init(bus, me_cl);
+	mei_me_cl_put(me_cl);
+	mutex_unlock(&bus->device_lock);
 
 	mei_cl_bus_rescan(bus);
 }

commit a816a00ece63d16ade7e9c0ca8b5a7e4c5ea2453
Author: Alexander Usyskin <alexander.usyskin@intel.com>
Date:   Sun Feb 7 23:35:41 2016 +0200

    mei: bus: run rescan on me_clients list change
    
    Since clients can be now added and removed during runtime
    we need to run bus rescan whenever me_clients list is modified.
    
    Signed-off-by: Alexander Usyskin <alexander.usyskin@intel.com>
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index bc18e5519da6..951d32265040 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -977,6 +977,14 @@ void mei_cl_bus_rescan(struct mei_device *bus)
 	dev_dbg(bus->dev, "rescan end");
 }
 
+void mei_cl_bus_rescan_work(struct work_struct *work)
+{
+	struct mei_device *bus =
+		container_of(work, struct mei_device, bus_rescan_work);
+
+	mei_cl_bus_rescan(bus);
+}
+
 int __mei_cldev_driver_register(struct mei_cl_driver *cldrv,
 				struct module *owner)
 {

commit 7851e008703e2f7073802e560293213e93dcdde6
Author: Alexander Usyskin <alexander.usyskin@intel.com>
Date:   Sun Feb 7 23:35:40 2016 +0200

    mei: drop reserved host client ids
    
    The reserved host clients can be obsoleted now, a portion of the
    platforms is shipped without iAMT enabled, where the reservation is not
    relevant and for platforms with iAMT dynamic allocation is sufficient.
    Dropping reserved ids makes enumeration more flexible and generic
    
    Signed-off-by: Alexander Usyskin <alexander.usyskin@intel.com>
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 83b084558ee5..bc18e5519da6 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -417,7 +417,7 @@ int mei_cldev_enable(struct mei_cl_device *cldev)
 
 	if (!cl) {
 		mutex_lock(&bus->device_lock);
-		cl = mei_cl_alloc_linked(bus, MEI_HOST_CLIENT_ID_ANY);
+		cl = mei_cl_alloc_linked(bus);
 		mutex_unlock(&bus->device_lock);
 		if (IS_ERR(cl))
 			return PTR_ERR(cl);

commit 15c13dfcad883a1e76b714480fb27be96247fd82
Author: Alexander Usyskin <alexander.usyskin@intel.com>
Date:   Sun Feb 7 23:35:32 2016 +0200

    mei: bus: check if the device is enabled before data transfer
    
    The bus data transfer interface was missing the check if the device is
    in enabled state, this may lead to stack corruption during link reset.
    
    Cc: <stable@vger.kernel.org> #4.0
    Signed-off-by: Alexander Usyskin <alexander.usyskin@intel.com>
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 990f4f65c35e..83b084558ee5 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -53,6 +53,11 @@ ssize_t __mei_cl_send(struct mei_cl *cl, u8 *buf, size_t length,
 	bus = cl->dev;
 
 	mutex_lock(&bus->device_lock);
+	if (bus->dev_state != MEI_DEV_ENABLED) {
+		rets = -ENODEV;
+		goto out;
+	}
+
 	if (!mei_cl_is_connected(cl)) {
 		rets = -ENODEV;
 		goto out;
@@ -109,6 +114,10 @@ ssize_t __mei_cl_recv(struct mei_cl *cl, u8 *buf, size_t length)
 	bus = cl->dev;
 
 	mutex_lock(&bus->device_lock);
+	if (bus->dev_state != MEI_DEV_ENABLED) {
+		rets = -ENODEV;
+		goto out;
+	}
 
 	cb = mei_cl_read_cb(cl, NULL);
 	if (cb)

commit 850f8940a6a38563ff401073fd845414ab49c5ed
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Sun Feb 7 23:35:31 2016 +0200

    mei: bus: fix notification event delivery
    
    Call wake_up cl->ev_wait only in case there is no bus client registered
    to the event notification.
    Second, since we don't have exclusive waiter wake_up_interruptible_all
    is not used correctly here.
    
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index a40d8e24ecda..990f4f65c35e 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -230,25 +230,30 @@ static void mei_cl_bus_event_work(struct work_struct *work)
  * mei_cl_bus_notify_event - schedule notify cb on bus client
  *
  * @cl: host client
+ *
+ * Return: true if event was scheduled
+ *         false if the client is not waiting for event
  */
-void mei_cl_bus_notify_event(struct mei_cl *cl)
+bool mei_cl_bus_notify_event(struct mei_cl *cl)
 {
 	struct mei_cl_device *cldev = cl->cldev;
 
 	if (!cldev || !cldev->event_cb)
-		return;
+		return false;
 
 	if (!(cldev->events_mask & BIT(MEI_CL_EVENT_NOTIF)))
-		return;
+		return false;
 
 	if (!cl->notify_ev)
-		return;
+		return false;
 
 	set_bit(MEI_CL_EVENT_NOTIF, &cldev->events);
 
 	schedule_work(&cldev->event_work);
 
 	cl->notify_ev = false;
+
+	return true;
 }
 
 /**

commit a1f9ae2bd264e3aed95aacd0102bd22a0422b8d1
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Sun Feb 7 23:35:30 2016 +0200

    mei: bus: fix RX event scheduling
    
    In this particular case this more correct and safer to check if the RX
    event is set in the event mask rather than query waitqueue_active
    Since the check is already performed in the mei_cl_bus_rx_event
    function,  it is just required to check for its return value.
    Second, since we don't have exclusive waiter wake_up_interruptible_all
    is not used correctly here.
    
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 0b05aa938799..a40d8e24ecda 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -252,23 +252,28 @@ void mei_cl_bus_notify_event(struct mei_cl *cl)
 }
 
 /**
- * mei_cl_bus_rx_event  - schedule rx evenet
+ * mei_cl_bus_rx_event  - schedule rx event
  *
  * @cl: host client
+ *
+ * Return: true if event was scheduled
+ *         false if the client is not waiting for event
  */
-void mei_cl_bus_rx_event(struct mei_cl *cl)
+bool mei_cl_bus_rx_event(struct mei_cl *cl)
 {
 	struct mei_cl_device *cldev = cl->cldev;
 
 	if (!cldev || !cldev->event_cb)
-		return;
+		return false;
 
 	if (!(cldev->events_mask & BIT(MEI_CL_EVENT_RX)))
-		return;
+		return false;
 
 	set_bit(MEI_CL_EVENT_RX, &cldev->events);
 
 	schedule_work(&cldev->event_work);
+
+	return true;
 }
 
 /**

commit 213dd193fab8288e2b0b96dc93f974ec33ba2298
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Wed Oct 28 14:34:35 2015 +0200

    mei: bus: set the device name before running fixup
    
    The mei bus fixup use dev_xxx services for printing
    to kernel log so we need to setup the device name
    prior to running fixup hooks.
    
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 46403e48be4f..0b05aa938799 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -741,6 +741,19 @@ static struct device_type mei_cl_device_type = {
 	.release	= mei_cl_bus_dev_release,
 };
 
+/**
+ * mei_cl_bus_set_name - set device name for me client device
+ *
+ * @cldev: me client device
+ */
+static inline void mei_cl_bus_set_name(struct mei_cl_device *cldev)
+{
+	dev_set_name(&cldev->dev, "mei:%s:%pUl:%02X",
+		     cldev->name,
+		     mei_me_cl_uuid(cldev->me_cl),
+		     mei_me_cl_ver(cldev->me_cl));
+}
+
 /**
  * mei_cl_bus_dev_alloc - initialize and allocate mei client device
  *
@@ -764,6 +777,7 @@ static struct mei_cl_device *mei_cl_bus_dev_alloc(struct mei_device *bus,
 	cldev->dev.type   = &mei_cl_device_type;
 	cldev->bus        = mei_dev_bus_get(bus);
 	cldev->me_cl      = mei_me_cl_get(me_cl);
+	mei_cl_bus_set_name(cldev);
 	cldev->is_added   = 0;
 	INIT_LIST_HEAD(&cldev->bus_list);
 
@@ -785,11 +799,9 @@ static bool mei_cl_bus_dev_setup(struct mei_device *bus,
 	cldev->do_match = 1;
 	mei_cl_bus_dev_fixup(cldev);
 
+	/* the device name can change during fix up */
 	if (cldev->do_match)
-		dev_set_name(&cldev->dev, "mei:%s:%pUl:%02X",
-			     cldev->name,
-			     mei_me_cl_uuid(cldev->me_cl),
-			     mei_me_cl_ver(cldev->me_cl));
+		mei_cl_bus_set_name(cldev);
 
 	return cldev->do_match == 1;
 }

commit 2da55cfd603d1c08dd1a396f943d6205eca47227
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Wed Oct 28 14:34:34 2015 +0200

    mei: bus: use correct lock ordering
    
    The correct lock order is
      cl_bus_lock
        device_lock
          me_clients_rwsem
    
    This order was violated in bus rescan and remove routines
    when me_client_rwsem was locked before cl_bus_lock.
    
    Chain exists of:
    [    4.321653]   &dev->device_lock --> &dev->me_clients_rwsem -->
    &dev->cl_bus_lock
    [    4.321653]
    [    4.321679]  Possible unsafe locking scenario:
    [    4.321679]
    [    4.321693]        CPU0                    CPU1
    [    4.321701]        ----                    ----
    [    4.321709]   lock(&dev->cl_bus_lock);
    [    4.321720]
    lock(&dev->me_clients_rwsem);
    [    4.321733]                                lock(&dev->cl_bus_lock);
    [    4.321745]   lock(&dev->device_lock);
    [    4.321755]
    [    4.321755]  *** DEADLOCK ***
    [    4.321755]
    
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 160e084ae800..46403e48be4f 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -830,17 +830,20 @@ static void mei_cl_bus_dev_stop(struct mei_cl_device *cldev)
  * mei_cl_bus_dev_destroy - destroy me client devices object
  *
  * @cldev: me client device
+ *
+ * Locking: called under "dev->cl_bus_lock" lock
  */
 static void mei_cl_bus_dev_destroy(struct mei_cl_device *cldev)
 {
+
+	WARN_ON(!mutex_is_locked(&cldev->bus->cl_bus_lock));
+
 	if (!cldev->is_added)
 		return;
 
 	device_del(&cldev->dev);
 
-	mutex_lock(&cldev->bus->cl_bus_lock);
 	list_del_init(&cldev->bus_list);
-	mutex_unlock(&cldev->bus->cl_bus_lock);
 
 	cldev->is_added = 0;
 	put_device(&cldev->dev);
@@ -866,8 +869,10 @@ void mei_cl_bus_remove_devices(struct mei_device *bus)
 {
 	struct mei_cl_device *cldev, *next;
 
+	mutex_lock(&bus->cl_bus_lock);
 	list_for_each_entry_safe(cldev, next, &bus->device_list, bus_list)
 		mei_cl_bus_remove_device(cldev);
+	mutex_unlock(&bus->cl_bus_lock);
 }
 
 
@@ -877,12 +882,16 @@ void mei_cl_bus_remove_devices(struct mei_device *bus)
  *
  * @bus: mei device
  * @me_cl: me client
+ *
+ * Locking: called under "dev->cl_bus_lock" lock
  */
 static void mei_cl_bus_dev_init(struct mei_device *bus,
 				struct mei_me_client *me_cl)
 {
 	struct mei_cl_device *cldev;
 
+	WARN_ON(!mutex_is_locked(&bus->cl_bus_lock));
+
 	dev_dbg(bus->dev, "initializing %pUl", mei_me_cl_uuid(me_cl));
 
 	if (me_cl->bus_added)
@@ -892,10 +901,8 @@ static void mei_cl_bus_dev_init(struct mei_device *bus,
 	if (!cldev)
 		return;
 
-	mutex_lock(&cldev->bus->cl_bus_lock);
 	me_cl->bus_added = true;
 	list_add_tail(&cldev->bus_list, &bus->device_list);
-	mutex_unlock(&cldev->bus->cl_bus_lock);
 
 }
 
@@ -910,12 +917,13 @@ void mei_cl_bus_rescan(struct mei_device *bus)
 	struct mei_cl_device *cldev, *n;
 	struct mei_me_client *me_cl;
 
+	mutex_lock(&bus->cl_bus_lock);
+
 	down_read(&bus->me_clients_rwsem);
 	list_for_each_entry(me_cl, &bus->me_clients, list)
 		mei_cl_bus_dev_init(bus, me_cl);
 	up_read(&bus->me_clients_rwsem);
 
-	mutex_lock(&bus->cl_bus_lock);
 	list_for_each_entry_safe(cldev, n, &bus->device_list, bus_list) {
 
 		if (!mei_me_cl_is_active(cldev->me_cl)) {

commit df7f5447d7b56c08684c7d285621e15e5c3c06b7
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Tue Oct 13 15:02:40 2015 +0300

    mei: bus: fix c&p issue in the kdoc
    
    s/send/receive/
    The buffer in the receive function is
    not used for sending
    
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 832085207a7f..160e084ae800 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -91,7 +91,7 @@ ssize_t __mei_cl_send(struct mei_cl *cl, u8 *buf, size_t length,
  * __mei_cl_recv - internal client receive (read)
  *
  * @cl: host client
- * @buf: buffer to send
+ * @buf: buffer to receive
  * @length: buffer length
  *
  * Return: read size in bytes of < 0 on error
@@ -188,7 +188,7 @@ EXPORT_SYMBOL_GPL(mei_cldev_send);
  * mei_cldev_recv - client receive (read)
  *
  * @cldev: me client device
- * @buf: buffer to send
+ * @buf: buffer to receive
  * @length: buffer length
  *
  * Return: read size in bytes of < 0 on error

commit ae48d74dfcb55d508404135ce2807d59e93bd46f
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Thu Sep 10 10:18:06 2015 +0300

    mei: bus: use mei_cl_bus_ prefix consistently
    
    Use mei_cl_bus_ for internal bus function consistently.
    
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 0406e7201fe4..832085207a7f 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -725,7 +725,7 @@ static void mei_dev_bus_put(struct mei_device *bus)
 		put_device(bus->dev);
 }
 
-static void mei_cl_dev_release(struct device *dev)
+static void mei_cl_bus_dev_release(struct device *dev)
 {
 	struct mei_cl_device *cldev = to_mei_cl_device(dev);
 
@@ -738,19 +738,19 @@ static void mei_cl_dev_release(struct device *dev)
 }
 
 static struct device_type mei_cl_device_type = {
-	.release	= mei_cl_dev_release,
+	.release	= mei_cl_bus_dev_release,
 };
 
 /**
- * mei_cl_dev_alloc - initialize and allocate mei client device
+ * mei_cl_bus_dev_alloc - initialize and allocate mei client device
  *
  * @bus: mei device
  * @me_cl: me client
  *
  * Return: allocated device structur or NULL on allocation failure
  */
-static struct mei_cl_device *mei_cl_dev_alloc(struct mei_device *bus,
-					      struct mei_me_client *me_cl)
+static struct mei_cl_device *mei_cl_bus_dev_alloc(struct mei_device *bus,
+						  struct mei_me_client *me_cl)
 {
 	struct mei_cl_device *cldev;
 
@@ -779,11 +779,11 @@ static struct mei_cl_device *mei_cl_dev_alloc(struct mei_device *bus,
  *
  * Return: true if the device is eligible for enumeration
  */
-static bool mei_cl_dev_setup(struct mei_device *bus,
-			     struct mei_cl_device *cldev)
+static bool mei_cl_bus_dev_setup(struct mei_device *bus,
+				 struct mei_cl_device *cldev)
 {
 	cldev->do_match = 1;
-	mei_cl_dev_fixup(cldev);
+	mei_cl_bus_dev_fixup(cldev);
 
 	if (cldev->do_match)
 		dev_set_name(&cldev->dev, "mei:%s:%pUl:%02X",
@@ -872,13 +872,14 @@ void mei_cl_bus_remove_devices(struct mei_device *bus)
 
 
 /**
- * mei_cl_dev_init - allocate and initializes an mei client devices
+ * mei_cl_bus_dev_init - allocate and initializes an mei client devices
  *     based on me client
  *
  * @bus: mei device
  * @me_cl: me client
  */
-static void mei_cl_dev_init(struct mei_device *bus, struct mei_me_client *me_cl)
+static void mei_cl_bus_dev_init(struct mei_device *bus,
+				struct mei_me_client *me_cl)
 {
 	struct mei_cl_device *cldev;
 
@@ -887,7 +888,7 @@ static void mei_cl_dev_init(struct mei_device *bus, struct mei_me_client *me_cl)
 	if (me_cl->bus_added)
 		return;
 
-	cldev = mei_cl_dev_alloc(bus, me_cl);
+	cldev = mei_cl_bus_dev_alloc(bus, me_cl);
 	if (!cldev)
 		return;
 
@@ -911,7 +912,7 @@ void mei_cl_bus_rescan(struct mei_device *bus)
 
 	down_read(&bus->me_clients_rwsem);
 	list_for_each_entry(me_cl, &bus->me_clients, list)
-		mei_cl_dev_init(bus, me_cl);
+		mei_cl_bus_dev_init(bus, me_cl);
 	up_read(&bus->me_clients_rwsem);
 
 	mutex_lock(&bus->cl_bus_lock);
@@ -925,7 +926,7 @@ void mei_cl_bus_rescan(struct mei_device *bus)
 		if (cldev->is_added)
 			continue;
 
-		if (mei_cl_dev_setup(bus, cldev))
+		if (mei_cl_bus_dev_setup(bus, cldev))
 			mei_cl_bus_dev_add(cldev);
 		else {
 			list_del_init(&cldev->bus_list);

commit d49dc5e76fc917e5dfef76cb56fe3b3868deed5d
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Thu Sep 10 10:18:05 2015 +0300

    mei: bus: use mei_cldev_ prefix for the API functions
    
    Use mei_cldev_ prefix for all mei client bus api functions
    in order to resolve prefix conflict with functions that handle
    client function and are defined in client.c
    
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 4edf71acfed6..0406e7201fe4 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -165,7 +165,7 @@ ssize_t __mei_cl_recv(struct mei_cl *cl, u8 *buf, size_t length)
 }
 
 /**
- * mei_cl_send - me device send  (write)
+ * mei_cldev_send - me device send  (write)
  *
  * @cldev: me client device
  * @buf: buffer to send
@@ -173,7 +173,7 @@ ssize_t __mei_cl_recv(struct mei_cl *cl, u8 *buf, size_t length)
  *
  * Return: written size in bytes or < 0 on error
  */
-ssize_t mei_cl_send(struct mei_cl_device *cldev, u8 *buf, size_t length)
+ssize_t mei_cldev_send(struct mei_cl_device *cldev, u8 *buf, size_t length)
 {
 	struct mei_cl *cl = cldev->cl;
 
@@ -182,10 +182,10 @@ ssize_t mei_cl_send(struct mei_cl_device *cldev, u8 *buf, size_t length)
 
 	return __mei_cl_send(cl, buf, length, 1);
 }
-EXPORT_SYMBOL_GPL(mei_cl_send);
+EXPORT_SYMBOL_GPL(mei_cldev_send);
 
 /**
- * mei_cl_recv - client receive (read)
+ * mei_cldev_recv - client receive (read)
  *
  * @cldev: me client device
  * @buf: buffer to send
@@ -193,7 +193,7 @@ EXPORT_SYMBOL_GPL(mei_cl_send);
  *
  * Return: read size in bytes of < 0 on error
  */
-ssize_t mei_cl_recv(struct mei_cl_device *cldev, u8 *buf, size_t length)
+ssize_t mei_cldev_recv(struct mei_cl_device *cldev, u8 *buf, size_t length)
 {
 	struct mei_cl *cl = cldev->cl;
 
@@ -202,15 +202,15 @@ ssize_t mei_cl_recv(struct mei_cl_device *cldev, u8 *buf, size_t length)
 
 	return __mei_cl_recv(cl, buf, length);
 }
-EXPORT_SYMBOL_GPL(mei_cl_recv);
+EXPORT_SYMBOL_GPL(mei_cldev_recv);
 
 /**
- * mei_bus_event_work  - dispatch rx event for a bus device
+ * mei_cl_bus_event_work  - dispatch rx event for a bus device
  *    and schedule new work
  *
  * @work: work
  */
-static void mei_bus_event_work(struct work_struct *work)
+static void mei_cl_bus_event_work(struct work_struct *work)
 {
 	struct mei_cl_device *cldev;
 
@@ -272,7 +272,7 @@ void mei_cl_bus_rx_event(struct mei_cl *cl)
 }
 
 /**
- * mei_cl_register_event_cb - register event callback
+ * mei_cldev_register_event_cb - register event callback
  *
  * @cldev: me client devices
  * @event_cb: callback function
@@ -283,9 +283,9 @@ void mei_cl_bus_rx_event(struct mei_cl *cl)
  *         -EALREADY if an callback is already registered
  *         <0 on other errors
  */
-int mei_cl_register_event_cb(struct mei_cl_device *cldev,
-			  unsigned long events_mask,
-			  mei_cl_event_cb_t event_cb, void *context)
+int mei_cldev_register_event_cb(struct mei_cl_device *cldev,
+				unsigned long events_mask,
+				mei_cldev_event_cb_t event_cb, void *context)
 {
 	int ret;
 
@@ -296,7 +296,7 @@ int mei_cl_register_event_cb(struct mei_cl_device *cldev,
 	cldev->events_mask = events_mask;
 	cldev->event_cb = event_cb;
 	cldev->event_context = context;
-	INIT_WORK(&cldev->event_work, mei_bus_event_work);
+	INIT_WORK(&cldev->event_work, mei_cl_bus_event_work);
 
 	if (cldev->events_mask & BIT(MEI_CL_EVENT_RX)) {
 		ret = mei_cl_read_start(cldev->cl, 0, NULL);
@@ -314,32 +314,32 @@ int mei_cl_register_event_cb(struct mei_cl_device *cldev,
 
 	return 0;
 }
-EXPORT_SYMBOL_GPL(mei_cl_register_event_cb);
+EXPORT_SYMBOL_GPL(mei_cldev_register_event_cb);
 
 /**
- * mei_cl_get_drvdata - driver data getter
+ * mei_cldev_get_drvdata - driver data getter
  *
  * @cldev: mei client device
  *
  * Return: driver private data
  */
-void *mei_cl_get_drvdata(const struct mei_cl_device *cldev)
+void *mei_cldev_get_drvdata(const struct mei_cl_device *cldev)
 {
 	return dev_get_drvdata(&cldev->dev);
 }
-EXPORT_SYMBOL_GPL(mei_cl_get_drvdata);
+EXPORT_SYMBOL_GPL(mei_cldev_get_drvdata);
 
 /**
- * mei_cl_set_drvdata - driver data setter
+ * mei_cldev_set_drvdata - driver data setter
  *
  * @cldev: mei client device
  * @data: data to store
  */
-void mei_cl_set_drvdata(struct mei_cl_device *cldev, void *data)
+void mei_cldev_set_drvdata(struct mei_cl_device *cldev, void *data)
 {
 	dev_set_drvdata(&cldev->dev, data);
 }
-EXPORT_SYMBOL_GPL(mei_cl_set_drvdata);
+EXPORT_SYMBOL_GPL(mei_cldev_set_drvdata);
 
 /**
  * mei_cldev_uuid - return uuid of the underlying me client
@@ -381,14 +381,14 @@ bool mei_cldev_enabled(struct mei_cl_device *cldev)
 EXPORT_SYMBOL_GPL(mei_cldev_enabled);
 
 /**
- * mei_cl_enable_device - enable me client device
+ * mei_cldev_enable_device - enable me client device
  *     create connection with me client
  *
  * @cldev: me client device
  *
  * Return: 0 on success and < 0 on error
  */
-int mei_cl_enable_device(struct mei_cl_device *cldev)
+int mei_cldev_enable(struct mei_cl_device *cldev)
 {
 	struct mei_device *bus = cldev->bus;
 	struct mei_cl *cl;
@@ -428,17 +428,17 @@ int mei_cl_enable_device(struct mei_cl_device *cldev)
 
 	return ret;
 }
-EXPORT_SYMBOL_GPL(mei_cl_enable_device);
+EXPORT_SYMBOL_GPL(mei_cldev_enable);
 
 /**
- * mei_cl_disable_device - disable me client device
+ * mei_cldev_disable - disable me client device
  *     disconnect form the me client
  *
  * @cldev: me client device
  *
  * Return: 0 on success and < 0 on error
  */
-int mei_cl_disable_device(struct mei_cl_device *cldev)
+int mei_cldev_disable(struct mei_cl_device *cldev)
 {
 	struct mei_device *bus;
 	struct mei_cl *cl;
@@ -476,7 +476,7 @@ int mei_cl_disable_device(struct mei_cl_device *cldev)
 	mutex_unlock(&bus->device_lock);
 	return err;
 }
-EXPORT_SYMBOL_GPL(mei_cl_disable_device);
+EXPORT_SYMBOL_GPL(mei_cldev_disable);
 
 /**
  * mei_cl_device_find - find matching entry in the driver id table
@@ -663,14 +663,14 @@ static ssize_t modalias_show(struct device *dev, struct device_attribute *a,
 }
 static DEVICE_ATTR_RO(modalias);
 
-static struct attribute *mei_cl_dev_attrs[] = {
+static struct attribute *mei_cldev_attrs[] = {
 	&dev_attr_name.attr,
 	&dev_attr_uuid.attr,
 	&dev_attr_version.attr,
 	&dev_attr_modalias.attr,
 	NULL,
 };
-ATTRIBUTE_GROUPS(mei_cl_dev);
+ATTRIBUTE_GROUPS(mei_cldev);
 
 /**
  * mei_cl_device_uevent - me client bus uevent handler
@@ -704,7 +704,7 @@ static int mei_cl_device_uevent(struct device *dev, struct kobj_uevent_env *env)
 
 static struct bus_type mei_cl_bus_type = {
 	.name		= "mei",
-	.dev_groups	= mei_cl_dev_groups,
+	.dev_groups	= mei_cldev_groups,
 	.match		= mei_cl_device_match,
 	.probe		= mei_cl_device_probe,
 	.remove		= mei_cl_device_remove,
@@ -937,7 +937,8 @@ void mei_cl_bus_rescan(struct mei_device *bus)
 	dev_dbg(bus->dev, "rescan end");
 }
 
-int __mei_cl_driver_register(struct mei_cl_driver *cldrv, struct module *owner)
+int __mei_cldev_driver_register(struct mei_cl_driver *cldrv,
+				struct module *owner)
 {
 	int err;
 
@@ -953,15 +954,15 @@ int __mei_cl_driver_register(struct mei_cl_driver *cldrv, struct module *owner)
 
 	return 0;
 }
-EXPORT_SYMBOL_GPL(__mei_cl_driver_register);
+EXPORT_SYMBOL_GPL(__mei_cldev_driver_register);
 
-void mei_cl_driver_unregister(struct mei_cl_driver *cldrv)
+void mei_cldev_driver_unregister(struct mei_cl_driver *cldrv)
 {
 	driver_unregister(&cldrv->driver);
 
 	pr_debug("mei: driver [%s] unregistered\n", cldrv->driver.name);
 }
-EXPORT_SYMBOL_GPL(mei_cl_driver_unregister);
+EXPORT_SYMBOL_GPL(mei_cldev_driver_unregister);
 
 
 int __init mei_cl_bus_init(void)

commit 01a14edeaf0456c28e2b9af3afdc0807ec6c20bd
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Thu Sep 10 10:18:03 2015 +0300

    mei: bus: export mei_cldev_enabled function
    
    Let me client device driver query of the device is connected
    and hence enabled.
    
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 53525ca50337..4edf71acfed6 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -367,6 +367,19 @@ u8 mei_cldev_ver(const struct mei_cl_device *cldev)
 }
 EXPORT_SYMBOL_GPL(mei_cldev_ver);
 
+/**
+ * mei_cldev_enabled - check whether the device is enabled
+ *
+ * @cldev: mei client device
+ *
+ * Return: true if me client is initialized and connected
+ */
+bool mei_cldev_enabled(struct mei_cl_device *cldev)
+{
+	return cldev->cl && mei_cl_is_connected(cldev->cl);
+}
+EXPORT_SYMBOL_GPL(mei_cldev_enabled);
+
 /**
  * mei_cl_enable_device - enable me client device
  *     create connection with me client

commit baeacd0376975bee0fdf6378e1c24587ab0b6ad4
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Thu Sep 10 10:18:02 2015 +0300

    mei: bus: export uuid and protocol version to mei_cl bus drivers
    
    Export the uuid and the protocol version of the underlying me client
    for me client bus drivers usage.
    
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 38bc4380ad08..53525ca50337 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -341,6 +341,32 @@ void mei_cl_set_drvdata(struct mei_cl_device *cldev, void *data)
 }
 EXPORT_SYMBOL_GPL(mei_cl_set_drvdata);
 
+/**
+ * mei_cldev_uuid - return uuid of the underlying me client
+ *
+ * @cldev: mei client device
+ *
+ * Return: me client uuid
+ */
+const uuid_le *mei_cldev_uuid(const struct mei_cl_device *cldev)
+{
+	return mei_me_cl_uuid(cldev->me_cl);
+}
+EXPORT_SYMBOL_GPL(mei_cldev_uuid);
+
+/**
+ * mei_cldev_ver - return protocol version of the underlying me client
+ *
+ * @cldev: mei client device
+ *
+ * Return: me client protocol version
+ */
+u8 mei_cldev_ver(const struct mei_cl_device *cldev)
+{
+	return mei_me_cl_ver(cldev->me_cl);
+}
+EXPORT_SYMBOL_GPL(mei_cldev_ver);
+
 /**
  * mei_cl_enable_device - enable me client device
  *     create connection with me client

commit b26864cad1c9f66f4966726ba7bc81d2b9b8f990
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Thu Sep 10 10:18:01 2015 +0300

    mei: bus: add client protocol version to the device alias
    
    The device alias now looks like mei:S:uuid:N:*
    In that way we can bind different drivers to clients with
    different protocol versions if required.
    
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index d92017fa1630..38bc4380ad08 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -453,17 +453,26 @@ struct mei_cl_device_id *mei_cl_device_find(struct mei_cl_device *cldev,
 {
 	const struct mei_cl_device_id *id;
 	const uuid_le *uuid;
+	u8 version;
+	bool match;
 
 	uuid = mei_me_cl_uuid(cldev->me_cl);
+	version = mei_me_cl_ver(cldev->me_cl);
 
 	id = cldrv->id_table;
 	while (uuid_le_cmp(NULL_UUID_LE, id->uuid)) {
 		if (!uuid_le_cmp(*uuid, id->uuid)) {
+			match = true;
 
-			if (!cldev->name[0])
-				return id;
+			if (cldev->name[0])
+				if (strncmp(cldev->name, id->name,
+					    sizeof(id->name)))
+					match = false;
 
-			if (!strncmp(cldev->name, id->name, sizeof(id->name)))
+			if (id->version != MEI_CL_VERSION_ANY)
+				if (id->version != version)
+					match = false;
+			if (match)
 				return id;
 		}
 
@@ -647,7 +656,8 @@ static int mei_cl_device_uevent(struct device *dev, struct kobj_uevent_env *env)
 	if (add_uevent_var(env, "MEI_CL_NAME=%s", cldev->name))
 		return -ENOMEM;
 
-	if (add_uevent_var(env, "MODALIAS=mei:%s:%pUl:", cldev->name, uuid))
+	if (add_uevent_var(env, "MODALIAS=mei:%s:%pUl:%02X:",
+			   cldev->name, uuid, version))
 		return -ENOMEM;
 
 	return 0;
@@ -737,8 +747,10 @@ static bool mei_cl_dev_setup(struct mei_device *bus,
 	mei_cl_dev_fixup(cldev);
 
 	if (cldev->do_match)
-		dev_set_name(&cldev->dev, "mei:%s:%pUl",
-			     cldev->name, mei_me_cl_uuid(cldev->me_cl));
+		dev_set_name(&cldev->dev, "mei:%s:%pUl:%02X",
+			     cldev->name,
+			     mei_me_cl_uuid(cldev->me_cl),
+			     mei_me_cl_ver(cldev->me_cl));
 
 	return cldev->do_match == 1;
 }
@@ -754,7 +766,9 @@ static int mei_cl_bus_dev_add(struct mei_cl_device *cldev)
 {
 	int ret;
 
-	dev_dbg(cldev->bus->dev, "adding %pUL\n", mei_me_cl_uuid(cldev->me_cl));
+	dev_dbg(cldev->bus->dev, "adding %pUL:%02X\n",
+		mei_me_cl_uuid(cldev->me_cl),
+		mei_me_cl_ver(cldev->me_cl));
 	ret = device_add(&cldev->dev);
 	if (!ret)
 		cldev->is_added = 1;

commit 40b7320ee413d0d1cc89c32c2a757fda56d27708
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Thu Sep 10 10:18:00 2015 +0300

    mei: bus: export client protocol version
    
    export me client protocol version to sysfs and uevent
    
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index e294f70741a0..d92017fa1630 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -590,6 +590,19 @@ static ssize_t uuid_show(struct device *dev, struct device_attribute *a,
 }
 static DEVICE_ATTR_RO(uuid);
 
+static ssize_t version_show(struct device *dev, struct device_attribute *a,
+			     char *buf)
+{
+	struct mei_cl_device *cldev = to_mei_cl_device(dev);
+	u8 version = mei_me_cl_ver(cldev->me_cl);
+	size_t len;
+
+	len = snprintf(buf, PAGE_SIZE, "%02X", version);
+
+	return (len >= PAGE_SIZE) ? (PAGE_SIZE - 1) : len;
+}
+static DEVICE_ATTR_RO(version);
+
 static ssize_t modalias_show(struct device *dev, struct device_attribute *a,
 			     char *buf)
 {
@@ -605,6 +618,7 @@ static DEVICE_ATTR_RO(modalias);
 static struct attribute *mei_cl_dev_attrs[] = {
 	&dev_attr_name.attr,
 	&dev_attr_uuid.attr,
+	&dev_attr_version.attr,
 	&dev_attr_modalias.attr,
 	NULL,
 };
@@ -622,6 +636,10 @@ static int mei_cl_device_uevent(struct device *dev, struct kobj_uevent_env *env)
 {
 	struct mei_cl_device *cldev = to_mei_cl_device(dev);
 	const uuid_le *uuid = mei_me_cl_uuid(cldev->me_cl);
+	u8 version = mei_me_cl_ver(cldev->me_cl);
+
+	if (add_uevent_var(env, "MEI_CL_VERSION=%d", version))
+		return -ENOMEM;
 
 	if (add_uevent_var(env, "MEI_CL_UUID=%pUl", uuid))
 		return -ENOMEM;

commit 59796edcf21c7c19d58a223001f9ed13746c51c2
Author: Prarit Bhargava <prarit@redhat.com>
Date:   Thu Sep 10 10:17:59 2015 +0300

    mei: make modules.alias UUID information easier to read
    
    scripts/mod/file2alias.c:add_uuid()  convert UUID into a single string
    which does not conform to the standard little endian UUID formatting.
    This patch changes add_uuid() to output same format as %pUL and modifies
    the mei driver to match the change.
    
    Signed-off-by: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index eef1c6b46ad8..e294f70741a0 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -597,9 +597,7 @@ static ssize_t modalias_show(struct device *dev, struct device_attribute *a,
 	const uuid_le *uuid = mei_me_cl_uuid(cldev->me_cl);
 	size_t len;
 
-	len = snprintf(buf, PAGE_SIZE, "mei:%s:" MEI_CL_UUID_FMT ":",
-		cldev->name, MEI_CL_UUID_ARGS(uuid->b));
-
+	len = snprintf(buf, PAGE_SIZE, "mei:%s:%pUl:", cldev->name, uuid);
 	return (len >= PAGE_SIZE) ? (PAGE_SIZE - 1) : len;
 }
 static DEVICE_ATTR_RO(modalias);
@@ -631,8 +629,7 @@ static int mei_cl_device_uevent(struct device *dev, struct kobj_uevent_env *env)
 	if (add_uevent_var(env, "MEI_CL_NAME=%s", cldev->name))
 		return -ENOMEM;
 
-	if (add_uevent_var(env, "MODALIAS=mei:%s:" MEI_CL_UUID_FMT ":",
-		cldev->name, MEI_CL_UUID_ARGS(uuid->b)))
+	if (add_uevent_var(env, "MODALIAS=mei:%s:%pUl:", cldev->name, uuid))
 		return -ENOMEM;
 
 	return 0;

commit bb2ef9c39db2e3c2562b4e439b2b00dc42e2c026
Author: Alexander Usyskin <alexander.usyskin@intel.com>
Date:   Sun Jul 26 09:54:23 2015 +0300

    mei: bus: add and call callback on notify event
    
    Enable drivers on mei client bus to subscribe
    to asynchronous event notifications.
    Introduce events_mask to the existing callback infrastructure
    so it is possible to handle both RX and event notification.
    
    Signed-off-by: Alexander Usyskin <alexander.usyskin@intel.com>
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 3ab08e522fb8..eef1c6b46ad8 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -222,7 +222,33 @@ static void mei_bus_event_work(struct work_struct *work)
 	cldev->events = 0;
 
 	/* Prepare for the next read */
-	mei_cl_read_start(cldev->cl, 0, NULL);
+	if (cldev->events_mask & BIT(MEI_CL_EVENT_RX))
+		mei_cl_read_start(cldev->cl, 0, NULL);
+}
+
+/**
+ * mei_cl_bus_notify_event - schedule notify cb on bus client
+ *
+ * @cl: host client
+ */
+void mei_cl_bus_notify_event(struct mei_cl *cl)
+{
+	struct mei_cl_device *cldev = cl->cldev;
+
+	if (!cldev || !cldev->event_cb)
+		return;
+
+	if (!(cldev->events_mask & BIT(MEI_CL_EVENT_NOTIF)))
+		return;
+
+	if (!cl->notify_ev)
+		return;
+
+	set_bit(MEI_CL_EVENT_NOTIF, &cldev->events);
+
+	schedule_work(&cldev->event_work);
+
+	cl->notify_ev = false;
 }
 
 /**
@@ -237,6 +263,9 @@ void mei_cl_bus_rx_event(struct mei_cl *cl)
 	if (!cldev || !cldev->event_cb)
 		return;
 
+	if (!(cldev->events_mask & BIT(MEI_CL_EVENT_RX)))
+		return;
+
 	set_bit(MEI_CL_EVENT_RX, &cldev->events);
 
 	schedule_work(&cldev->event_work);
@@ -247,6 +276,7 @@ void mei_cl_bus_rx_event(struct mei_cl *cl)
  *
  * @cldev: me client devices
  * @event_cb: callback function
+ * @events_mask: requested events bitmask
  * @context: driver context data
  *
  * Return: 0 on success
@@ -254,6 +284,7 @@ void mei_cl_bus_rx_event(struct mei_cl *cl)
  *         <0 on other errors
  */
 int mei_cl_register_event_cb(struct mei_cl_device *cldev,
+			  unsigned long events_mask,
 			  mei_cl_event_cb_t event_cb, void *context)
 {
 	int ret;
@@ -262,13 +293,24 @@ int mei_cl_register_event_cb(struct mei_cl_device *cldev,
 		return -EALREADY;
 
 	cldev->events = 0;
+	cldev->events_mask = events_mask;
 	cldev->event_cb = event_cb;
 	cldev->event_context = context;
 	INIT_WORK(&cldev->event_work, mei_bus_event_work);
 
-	ret = mei_cl_read_start(cldev->cl, 0, NULL);
-	if (ret && ret != -EBUSY)
-		return ret;
+	if (cldev->events_mask & BIT(MEI_CL_EVENT_RX)) {
+		ret = mei_cl_read_start(cldev->cl, 0, NULL);
+		if (ret && ret != -EBUSY)
+			return ret;
+	}
+
+	if (cldev->events_mask & BIT(MEI_CL_EVENT_NOTIF)) {
+		mutex_lock(&cldev->cl->dev->device_lock);
+		ret = mei_cl_notify_request(cldev->cl, NULL, event_cb ? 1 : 0);
+		mutex_unlock(&cldev->cl->dev->device_lock);
+		if (ret)
+			return ret;
+	}
 
 	return 0;
 }

commit 6009595a66e460af0b170d736398c49395cb4499
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Thu Jul 23 15:08:47 2015 +0300

    mei: bus: link client devices instead of host clients
    
    MEI bus was designed around nfc and was hard to extend.
    Instead of the hard coded way of adding the devices on the mei bus
    we scan the whole me client list and create a device for each
    eligible me client (mei_cl_bus_rescan); currently we support
    only clients with single connection and fixed address clients.
    NFC radio name detection is run as a fixup routine
    
    The patch replaces handling the device list based on struct me_cl
    to device list based on me_cl_devices. The creating a connection
    is pushed from the device creation time to device enablement.
    
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 7e51700515f4..3ab08e522fb8 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -309,34 +309,43 @@ EXPORT_SYMBOL_GPL(mei_cl_set_drvdata);
  */
 int mei_cl_enable_device(struct mei_cl_device *cldev)
 {
-	int err;
-	struct mei_device *bus;
-	struct mei_cl *cl = cldev->cl;
+	struct mei_device *bus = cldev->bus;
+	struct mei_cl *cl;
+	int ret;
 
-	if (cl == NULL)
-		return -ENODEV;
+	cl = cldev->cl;
 
-	bus = cl->dev;
+	if (!cl) {
+		mutex_lock(&bus->device_lock);
+		cl = mei_cl_alloc_linked(bus, MEI_HOST_CLIENT_ID_ANY);
+		mutex_unlock(&bus->device_lock);
+		if (IS_ERR(cl))
+			return PTR_ERR(cl);
+		/* update pointers */
+		cldev->cl = cl;
+		cl->cldev = cldev;
+	}
 
 	mutex_lock(&bus->device_lock);
-
 	if (mei_cl_is_connected(cl)) {
-		mutex_unlock(&bus->device_lock);
-		dev_warn(bus->dev, "Already connected");
-		return -EBUSY;
+		ret = 0;
+		goto out;
 	}
 
-	err = mei_cl_connect(cl, cldev->me_cl, NULL);
-	if (err < 0) {
-		mutex_unlock(&bus->device_lock);
-		dev_err(bus->dev, "Could not connect to the ME client");
-
-		return err;
+	if (!mei_me_cl_is_active(cldev->me_cl)) {
+		dev_err(&cldev->dev, "me client is not active\n");
+		ret = -ENOTTY;
+		goto out;
 	}
 
+	ret = mei_cl_connect(cl, cldev->me_cl, NULL);
+	if (ret < 0)
+		dev_err(&cldev->dev, "cannot connect\n");
+
+out:
 	mutex_unlock(&bus->device_lock);
 
-	return 0;
+	return ret;
 }
 EXPORT_SYMBOL_GPL(mei_cl_enable_device);
 
@@ -350,14 +359,16 @@ EXPORT_SYMBOL_GPL(mei_cl_enable_device);
  */
 int mei_cl_disable_device(struct mei_cl_device *cldev)
 {
-	int err;
 	struct mei_device *bus;
-	struct mei_cl *cl = cldev->cl;
+	struct mei_cl *cl;
+	int err;
 
-	if (cl == NULL)
+	if (!cldev || !cldev->cl)
 		return -ENODEV;
 
-	bus = cl->dev;
+	cl = cldev->cl;
+
+	bus = cldev->bus;
 
 	cldev->event_cb = NULL;
 
@@ -370,18 +381,19 @@ int mei_cl_disable_device(struct mei_cl_device *cldev)
 	}
 
 	err = mei_cl_disconnect(cl);
-	if (err < 0) {
+	if (err < 0)
 		dev_err(bus->dev, "Could not disconnect from the ME client");
-		goto out;
-	}
 
+out:
 	/* Flush queues and remove any pending read */
 	mei_cl_flush_queues(cl, NULL);
+	mei_cl_unlink(cl);
+
+	kfree(cl);
+	cldev->cl = NULL;
 
-out:
 	mutex_unlock(&bus->device_lock);
 	return err;
-
 }
 EXPORT_SYMBOL_GPL(mei_cl_disable_device);
 
@@ -623,20 +635,6 @@ static struct device_type mei_cl_device_type = {
 	.release	= mei_cl_dev_release,
 };
 
-struct mei_cl *mei_cl_bus_find_cl_by_uuid(struct mei_device *bus,
-					 uuid_le uuid)
-{
-	struct mei_cl *cl;
-
-	list_for_each_entry(cl, &bus->device_list, device_link) {
-		if (cl->cldev && cl->cldev->me_cl &&
-		    !uuid_le_cmp(uuid, *mei_me_cl_uuid(cl->cldev->me_cl)))
-			return cl;
-	}
-
-	return NULL;
-}
-
 /**
  * mei_cl_dev_alloc - initialize and allocate mei client device
  *
@@ -707,45 +705,127 @@ static int mei_cl_bus_dev_add(struct mei_cl_device *cldev)
 	return ret;
 }
 
-struct mei_cl_device *mei_cl_add_device(struct mei_device *bus,
-					struct mei_me_client *me_cl,
-					struct mei_cl *cl,
-					const char *name)
+/**
+ * mei_cl_bus_dev_stop - stop the driver
+ *
+ * @cldev: me client device
+ */
+static void mei_cl_bus_dev_stop(struct mei_cl_device *cldev)
+{
+	if (cldev->is_added)
+		device_release_driver(&cldev->dev);
+}
+
+/**
+ * mei_cl_bus_dev_destroy - destroy me client devices object
+ *
+ * @cldev: me client device
+ */
+static void mei_cl_bus_dev_destroy(struct mei_cl_device *cldev)
+{
+	if (!cldev->is_added)
+		return;
+
+	device_del(&cldev->dev);
+
+	mutex_lock(&cldev->bus->cl_bus_lock);
+	list_del_init(&cldev->bus_list);
+	mutex_unlock(&cldev->bus->cl_bus_lock);
+
+	cldev->is_added = 0;
+	put_device(&cldev->dev);
+}
+
+/**
+ * mei_cl_bus_remove_device - remove a devices form the bus
+ *
+ * @cldev: me client device
+ */
+static void mei_cl_bus_remove_device(struct mei_cl_device *cldev)
+{
+	mei_cl_bus_dev_stop(cldev);
+	mei_cl_bus_dev_destroy(cldev);
+}
+
+/**
+ * mei_cl_bus_remove_devices - remove all devices form the bus
+ *
+ * @bus: mei device
+ */
+void mei_cl_bus_remove_devices(struct mei_device *bus)
+{
+	struct mei_cl_device *cldev, *next;
+
+	list_for_each_entry_safe(cldev, next, &bus->device_list, bus_list)
+		mei_cl_bus_remove_device(cldev);
+}
+
+
+/**
+ * mei_cl_dev_init - allocate and initializes an mei client devices
+ *     based on me client
+ *
+ * @bus: mei device
+ * @me_cl: me client
+ */
+static void mei_cl_dev_init(struct mei_device *bus, struct mei_me_client *me_cl)
 {
 	struct mei_cl_device *cldev;
-	int status;
+
+	dev_dbg(bus->dev, "initializing %pUl", mei_me_cl_uuid(me_cl));
+
+	if (me_cl->bus_added)
+		return;
 
 	cldev = mei_cl_dev_alloc(bus, me_cl);
 	if (!cldev)
-		return NULL;
+		return;
 
-	cldev->cl = cl;
-	strlcpy(cldev->name, name, sizeof(cldev->name));
+	mutex_lock(&cldev->bus->cl_bus_lock);
+	me_cl->bus_added = true;
+	list_add_tail(&cldev->bus_list, &bus->device_list);
+	mutex_unlock(&cldev->bus->cl_bus_lock);
 
-	mei_cl_dev_setup(bus, cldev);
+}
 
-	status = mei_cl_bus_dev_add(cldev);
-	if (status) {
-		dev_err(bus->dev, "Failed to register MEI device\n");
-		mei_me_cl_put(cldev->me_cl);
-		mei_dev_bus_put(bus);
-		kfree(cldev);
-		return NULL;
-	}
+/**
+ * mei_cl_bus_rescan - scan me clients list and add create
+ *    devices for eligible clients
+ *
+ * @bus: mei device
+ */
+void mei_cl_bus_rescan(struct mei_device *bus)
+{
+	struct mei_cl_device *cldev, *n;
+	struct mei_me_client *me_cl;
 
-	cl->cldev = cldev;
+	down_read(&bus->me_clients_rwsem);
+	list_for_each_entry(me_cl, &bus->me_clients, list)
+		mei_cl_dev_init(bus, me_cl);
+	up_read(&bus->me_clients_rwsem);
 
-	dev_dbg(&cldev->dev, "client %s registered\n", name);
+	mutex_lock(&bus->cl_bus_lock);
+	list_for_each_entry_safe(cldev, n, &bus->device_list, bus_list) {
 
-	return cldev;
-}
-EXPORT_SYMBOL_GPL(mei_cl_add_device);
+		if (!mei_me_cl_is_active(cldev->me_cl)) {
+			mei_cl_bus_remove_device(cldev);
+			continue;
+		}
 
-void mei_cl_remove_device(struct mei_cl_device *cldev)
-{
-	device_unregister(&cldev->dev);
+		if (cldev->is_added)
+			continue;
+
+		if (mei_cl_dev_setup(bus, cldev))
+			mei_cl_bus_dev_add(cldev);
+		else {
+			list_del_init(&cldev->bus_list);
+			put_device(&cldev->dev);
+		}
+	}
+	mutex_unlock(&bus->cl_bus_lock);
+
+	dev_dbg(bus->dev, "rescan end");
 }
-EXPORT_SYMBOL_GPL(mei_cl_remove_device);
 
 int __mei_cl_driver_register(struct mei_cl_driver *cldrv, struct module *owner)
 {
@@ -773,6 +853,7 @@ void mei_cl_driver_unregister(struct mei_cl_driver *cldrv)
 }
 EXPORT_SYMBOL_GPL(mei_cl_driver_unregister);
 
+
 int __init mei_cl_bus_init(void)
 {
 	return bus_register(&mei_cl_bus_type);

commit b39910c2e0ac7c3d0e2f1999b04308c771b1d8fc
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Thu Jul 23 15:08:46 2015 +0300

    mei: bus: simplify how we build nfc bus name
    
    Remove the dependency on struct ndev from the nfc device
    name creation function so it is possible to use it
    in a fixup routine
    
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 68b7756bf384..7e51700515f4 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -710,7 +710,7 @@ static int mei_cl_bus_dev_add(struct mei_cl_device *cldev)
 struct mei_cl_device *mei_cl_add_device(struct mei_device *bus,
 					struct mei_me_client *me_cl,
 					struct mei_cl *cl,
-					char *name)
+					const char *name)
 {
 	struct mei_cl_device *cldev;
 	int status;

commit 71ce789115f878a07e4a6c43d6006cea6aee1078
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Thu Jul 23 15:08:43 2015 +0300

    mei: bus: enable running fixup routines before device registration
    
    Split the device registration into allocation and device struct
    initialization, device setup, and the final device registration.
    This why it is possible to run fixups and quirks during the setup stage
    on an initialized device. Each fixup routine effects do_match flag.
    If the flag is set to false at the end the device won't be
    registered on the bus.
    
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 34b14dda050c..68b7756bf384 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -436,6 +436,9 @@ static int mei_cl_device_match(struct device *dev, struct device_driver *drv)
 	if (!cldev)
 		return 0;
 
+	if (!cldev->do_match)
+		return 0;
+
 	if (!cldrv || !cldrv->id_table)
 		return 0;
 
@@ -634,6 +637,76 @@ struct mei_cl *mei_cl_bus_find_cl_by_uuid(struct mei_device *bus,
 	return NULL;
 }
 
+/**
+ * mei_cl_dev_alloc - initialize and allocate mei client device
+ *
+ * @bus: mei device
+ * @me_cl: me client
+ *
+ * Return: allocated device structur or NULL on allocation failure
+ */
+static struct mei_cl_device *mei_cl_dev_alloc(struct mei_device *bus,
+					      struct mei_me_client *me_cl)
+{
+	struct mei_cl_device *cldev;
+
+	cldev = kzalloc(sizeof(struct mei_cl_device), GFP_KERNEL);
+	if (!cldev)
+		return NULL;
+
+	device_initialize(&cldev->dev);
+	cldev->dev.parent = bus->dev;
+	cldev->dev.bus    = &mei_cl_bus_type;
+	cldev->dev.type   = &mei_cl_device_type;
+	cldev->bus        = mei_dev_bus_get(bus);
+	cldev->me_cl      = mei_me_cl_get(me_cl);
+	cldev->is_added   = 0;
+	INIT_LIST_HEAD(&cldev->bus_list);
+
+	return cldev;
+}
+
+/**
+ * mei_cl_dev_setup - setup me client device
+ *    run fix up routines and set the device name
+ *
+ * @bus: mei device
+ * @cldev: me client device
+ *
+ * Return: true if the device is eligible for enumeration
+ */
+static bool mei_cl_dev_setup(struct mei_device *bus,
+			     struct mei_cl_device *cldev)
+{
+	cldev->do_match = 1;
+	mei_cl_dev_fixup(cldev);
+
+	if (cldev->do_match)
+		dev_set_name(&cldev->dev, "mei:%s:%pUl",
+			     cldev->name, mei_me_cl_uuid(cldev->me_cl));
+
+	return cldev->do_match == 1;
+}
+
+/**
+ * mei_cl_bus_dev_add - add me client devices
+ *
+ * @cldev: me client device
+ *
+ * Return: 0 on success; < 0 on failre
+ */
+static int mei_cl_bus_dev_add(struct mei_cl_device *cldev)
+{
+	int ret;
+
+	dev_dbg(cldev->bus->dev, "adding %pUL\n", mei_me_cl_uuid(cldev->me_cl));
+	ret = device_add(&cldev->dev);
+	if (!ret)
+		cldev->is_added = 1;
+
+	return ret;
+}
+
 struct mei_cl_device *mei_cl_add_device(struct mei_device *bus,
 					struct mei_me_client *me_cl,
 					struct mei_cl *cl,
@@ -642,28 +715,16 @@ struct mei_cl_device *mei_cl_add_device(struct mei_device *bus,
 	struct mei_cl_device *cldev;
 	int status;
 
-	cldev = kzalloc(sizeof(struct mei_cl_device), GFP_KERNEL);
+	cldev = mei_cl_dev_alloc(bus, me_cl);
 	if (!cldev)
 		return NULL;
 
-	cldev->me_cl = mei_me_cl_get(me_cl);
-	if (!cldev->me_cl) {
-		kfree(cldev);
-		return NULL;
-	}
-
 	cldev->cl = cl;
-	cldev->dev.parent = bus->dev;
-	cldev->dev.bus = &mei_cl_bus_type;
-	cldev->dev.type = &mei_cl_device_type;
-	cldev->bus      = mei_dev_bus_get(bus);
-	INIT_LIST_HEAD(&cldev->bus_list);
-
 	strlcpy(cldev->name, name, sizeof(cldev->name));
 
-	dev_set_name(&cldev->dev, "mei:%s:%pUl", name, mei_me_cl_uuid(me_cl));
+	mei_cl_dev_setup(bus, cldev);
 
-	status = device_register(&cldev->dev);
+	status = mei_cl_bus_dev_add(cldev);
 	if (status) {
 		dev_err(bus->dev, "Failed to register MEI device\n");
 		mei_me_cl_put(cldev->me_cl);

commit 0ff0a8d853039aa60bba3ca3e04e4fb74584a736
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Thu Jul 23 15:08:42 2015 +0300

    mei: bus: add me client device list infrastructure
    
    Instead of holding the list of host clients (me_cl)
    we want to keep the list me client devices (mei_cl_device)
    This way we can create host to me client connection only when needed.
    Add list head to mei_cl_device and cl_bus_lock
    Add bus_added flag to the me client (mei_me_client) to track if
    the appropriate mei_cl_device was already created and is_added
    flag to mei_cl_device to track if it was already added to the device
    list across the bus rescans
    
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 963731eb4383..34b14dda050c 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -657,6 +657,7 @@ struct mei_cl_device *mei_cl_add_device(struct mei_device *bus,
 	cldev->dev.bus = &mei_cl_bus_type;
 	cldev->dev.type = &mei_cl_device_type;
 	cldev->bus      = mei_dev_bus_get(bus);
+	INIT_LIST_HEAD(&cldev->bus_list);
 
 	strlcpy(cldev->name, name, sizeof(cldev->name));
 

commit 512f64d9f7467597388ffbd5a21589ee3f375d8b
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Thu Jul 23 15:08:41 2015 +0300

    mei: bus: add reference to bus device in struct mei_cl_client
    
    Add reference to the bus device (mei_device) for easier access.
    To ensures that referencing cldev->bus is valid during cldev life time
    we increase the bus ref counter on a client device creation and drop it
    on the device release.
    
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 1d9ce9c491cf..963731eb4383 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -590,6 +590,20 @@ static struct bus_type mei_cl_bus_type = {
 	.uevent		= mei_cl_device_uevent,
 };
 
+static struct mei_device *mei_dev_bus_get(struct mei_device *bus)
+{
+	if (bus)
+		get_device(bus->dev);
+
+	return bus;
+}
+
+static void mei_dev_bus_put(struct mei_device *bus)
+{
+	if (bus)
+		put_device(bus->dev);
+}
+
 static void mei_cl_dev_release(struct device *dev)
 {
 	struct mei_cl_device *cldev = to_mei_cl_device(dev);
@@ -598,6 +612,7 @@ static void mei_cl_dev_release(struct device *dev)
 		return;
 
 	mei_me_cl_put(cldev->me_cl);
+	mei_dev_bus_put(cldev->bus);
 	kfree(cldev);
 }
 
@@ -641,6 +656,7 @@ struct mei_cl_device *mei_cl_add_device(struct mei_device *bus,
 	cldev->dev.parent = bus->dev;
 	cldev->dev.bus = &mei_cl_bus_type;
 	cldev->dev.type = &mei_cl_device_type;
+	cldev->bus      = mei_dev_bus_get(bus);
 
 	strlcpy(cldev->name, name, sizeof(cldev->name));
 
@@ -650,6 +666,7 @@ struct mei_cl_device *mei_cl_add_device(struct mei_device *bus,
 	if (status) {
 		dev_err(bus->dev, "Failed to register MEI device\n");
 		mei_me_cl_put(cldev->me_cl);
+		mei_dev_bus_put(bus);
 		kfree(cldev);
 		return NULL;
 	}

commit feb8cd0fe7d63fd259c28f8a52fc88745717c9ec
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Thu Jul 23 15:08:40 2015 +0300

    mei: bus: revamp probe and remove functions
    
    Instead of generating device id on the fly during probing we
    find the matching id entry on the device id table.
    Get bus the module reference counter so it cannot
    be unloaded after the driver has bounded to the client
    device
    
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 4955a0908d04..1d9ce9c491cf 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -446,30 +446,49 @@ static int mei_cl_device_match(struct device *dev, struct device_driver *drv)
 	return 0;
 }
 
+/**
+ * mei_cl_device_probe - bus probe function
+ *
+ * @dev: device
+ *
+ * Return:  0 on success; < 0 otherwise
+ */
 static int mei_cl_device_probe(struct device *dev)
 {
-	struct mei_cl_device *cldev = to_mei_cl_device(dev);
+	struct mei_cl_device *cldev;
 	struct mei_cl_driver *cldrv;
-	struct mei_cl_device_id id;
+	const struct mei_cl_device_id *id;
+
+	cldev = to_mei_cl_device(dev);
+	cldrv = to_mei_cl_driver(dev->driver);
 
 	if (!cldev)
 		return 0;
 
-	cldrv = to_mei_cl_driver(dev->driver);
 	if (!cldrv || !cldrv->probe)
 		return -ENODEV;
 
-	dev_dbg(dev, "Device probe\n");
+	id = mei_cl_device_find(cldev, cldrv);
+	if (!id)
+		return -ENODEV;
 
-	strlcpy(id.name, cldev->name, sizeof(id.name));
+	__module_get(THIS_MODULE);
 
-	return cldrv->probe(cldev, &id);
+	return cldrv->probe(cldev, id);
 }
 
+/**
+ * mei_cl_device_remove - remove device from the bus
+ *
+ * @dev: device
+ *
+ * Return:  0 on success; < 0 otherwise
+ */
 static int mei_cl_device_remove(struct device *dev)
 {
 	struct mei_cl_device *cldev = to_mei_cl_device(dev);
 	struct mei_cl_driver *cldrv;
+	int ret = 0;
 
 	if (!cldev || !dev->driver)
 		return 0;
@@ -480,13 +499,13 @@ static int mei_cl_device_remove(struct device *dev)
 	}
 
 	cldrv = to_mei_cl_driver(dev->driver);
-	if (!cldrv->remove) {
-		dev->driver = NULL;
+	if (cldrv->remove)
+		ret = cldrv->remove(cldev);
 
-		return 0;
-	}
+	module_put(THIS_MODULE);
+	dev->driver = NULL;
+	return ret;
 
-	return cldrv->remove(cldev);
 }
 
 static ssize_t name_show(struct device *dev, struct device_attribute *a,

commit 688a9cce0c8e9116038586ae1cd6adabb10fa5aa
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Thu Jul 23 15:08:39 2015 +0300

    mei: bus: revamp device matching
    
    mei_cl_device_match now calls mei_cl_device_find that returns
    the matching device id in the device id table.
    We will utilize the mei_cl_device_find during probing
    to locate the matching entry.
    
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index aba7688d1ddd..4955a0908d04 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -385,39 +385,64 @@ int mei_cl_disable_device(struct mei_cl_device *cldev)
 }
 EXPORT_SYMBOL_GPL(mei_cl_disable_device);
 
-static int mei_cl_device_match(struct device *dev, struct device_driver *drv)
+/**
+ * mei_cl_device_find - find matching entry in the driver id table
+ *
+ * @cldev: me client device
+ * @cldrv: me client driver
+ *
+ * Return: id on success; NULL if no id is matching
+ */
+static const
+struct mei_cl_device_id *mei_cl_device_find(struct mei_cl_device *cldev,
+					    struct mei_cl_driver *cldrv)
 {
-	struct mei_cl_device *cldev = to_mei_cl_device(dev);
-	struct mei_cl_driver *cldrv = to_mei_cl_driver(drv);
 	const struct mei_cl_device_id *id;
 	const uuid_le *uuid;
-	const char *name;
-
-	if (!cldev)
-		return 0;
 
 	uuid = mei_me_cl_uuid(cldev->me_cl);
-	name = cldev->name;
-
-	if (!cldrv || !cldrv->id_table)
-		return 0;
 
 	id = cldrv->id_table;
-
 	while (uuid_le_cmp(NULL_UUID_LE, id->uuid)) {
-
 		if (!uuid_le_cmp(*uuid, id->uuid)) {
-			if (id->name[0]) {
-				if (!strncmp(name, id->name, sizeof(id->name)))
-					return 1;
-			} else {
-				return 1;
-			}
+
+			if (!cldev->name[0])
+				return id;
+
+			if (!strncmp(cldev->name, id->name, sizeof(id->name)))
+				return id;
 		}
 
 		id++;
 	}
 
+	return NULL;
+}
+
+/**
+ * mei_cl_device_match  - device match function
+ *
+ * @dev: device
+ * @drv: driver
+ *
+ * Return:  1 if matching device was found 0 otherwise
+ */
+static int mei_cl_device_match(struct device *dev, struct device_driver *drv)
+{
+	struct mei_cl_device *cldev = to_mei_cl_device(dev);
+	struct mei_cl_driver *cldrv = to_mei_cl_driver(drv);
+	const struct mei_cl_device_id *found_id;
+
+	if (!cldev)
+		return 0;
+
+	if (!cldrv || !cldrv->id_table)
+		return 0;
+
+	found_id = mei_cl_device_find(cldev, cldrv);
+	if (found_id)
+		return 1;
+
 	return 0;
 }
 

commit 48168f4561f479403dbd38379dc8793488a22a6a
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Thu Jul 23 15:08:38 2015 +0300

    mei: bus: report if event registration failed
    
    If event registeration has failed, the caller should know
    about it.
    
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 257e200b5343..aba7688d1ddd 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -256,6 +256,8 @@ void mei_cl_bus_rx_event(struct mei_cl *cl)
 int mei_cl_register_event_cb(struct mei_cl_device *cldev,
 			  mei_cl_event_cb_t event_cb, void *context)
 {
+	int ret;
+
 	if (cldev->event_cb)
 		return -EALREADY;
 
@@ -264,7 +266,9 @@ int mei_cl_register_event_cb(struct mei_cl_device *cldev,
 	cldev->event_context = context;
 	INIT_WORK(&cldev->event_work, mei_bus_event_work);
 
-	mei_cl_read_start(cldev->cl, 0, NULL);
+	ret = mei_cl_read_start(cldev->cl, 0, NULL);
+	if (ret && ret != -EBUSY)
+		return ret;
 
 	return 0;
 }

commit 7e280ab694e2885ee300de9cf5e7047c68230148
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Thu Jul 23 15:08:37 2015 +0300

    mei: bus: don't enable events implicitly in device enable
    
    Do not enable events implicitly in mei_cl_enable_device, it should be
    done explicitly using mei_cl_register_event_cb so the events
    are enabled only when needed.
    The NFC drivers has been already using it that way so no need for
    further changes just remove the code from mei_cl_enable_device.
    
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index bec213b92550..257e200b5343 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -332,9 +332,6 @@ int mei_cl_enable_device(struct mei_cl_device *cldev)
 
 	mutex_unlock(&bus->device_lock);
 
-	if (cldev->event_cb)
-		mei_cl_read_start(cldev->cl, 0, NULL);
-
 	return 0;
 }
 EXPORT_SYMBOL_GPL(mei_cl_enable_device);

commit 38d3c00d3f312989e50aaf6f4a4b490b4e1e4c37
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Thu Jul 23 15:08:36 2015 +0300

    mei: bus: rename uevent handler to mei_cl_device_uevent
    
    Rename mei_cl_uevent to mei_cl_device_uevent to match
    the naming convention of mei_cl_bus_type functions
    
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 6ea8a408f477..bec213b92550 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -510,7 +510,15 @@ static struct attribute *mei_cl_dev_attrs[] = {
 };
 ATTRIBUTE_GROUPS(mei_cl_dev);
 
-static int mei_cl_uevent(struct device *dev, struct kobj_uevent_env *env)
+/**
+ * mei_cl_device_uevent - me client bus uevent handler
+ *
+ * @dev: device
+ * @env: uevent kobject
+ *
+ * Return: 0 on success -ENOMEM on when add_uevent_var fails
+ */
+static int mei_cl_device_uevent(struct device *dev, struct kobj_uevent_env *env)
 {
 	struct mei_cl_device *cldev = to_mei_cl_device(dev);
 	const uuid_le *uuid = mei_me_cl_uuid(cldev->me_cl);
@@ -534,7 +542,7 @@ static struct bus_type mei_cl_bus_type = {
 	.match		= mei_cl_device_match,
 	.probe		= mei_cl_device_probe,
 	.remove		= mei_cl_device_remove,
-	.uevent		= mei_cl_uevent,
+	.uevent		= mei_cl_device_uevent,
 };
 
 static void mei_cl_dev_release(struct device *dev)

commit 6238299774377b12c3e24507b100b2687eb5ea32
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Thu Jul 23 15:08:35 2015 +0300

    mei: bus: move driver api functions at the start of the file
    
    To make the file more organize move mei client driver api
    to the start of the file and add Kdoc.
    
    There are no functional changes in this patch.
    
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 18c37af22f07..6ea8a408f477 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -30,527 +30,616 @@
 #define to_mei_cl_driver(d) container_of(d, struct mei_cl_driver, driver)
 #define to_mei_cl_device(d) container_of(d, struct mei_cl_device, dev)
 
-static int mei_cl_device_match(struct device *dev, struct device_driver *drv)
+/**
+ * __mei_cl_send - internal client send (write)
+ *
+ * @cl: host client
+ * @buf: buffer to send
+ * @length: buffer length
+ * @blocking: wait for write completion
+ *
+ * Return: written size bytes or < 0 on error
+ */
+ssize_t __mei_cl_send(struct mei_cl *cl, u8 *buf, size_t length,
+			bool blocking)
 {
-	struct mei_cl_device *cldev = to_mei_cl_device(dev);
-	struct mei_cl_driver *cldrv = to_mei_cl_driver(drv);
-	const struct mei_cl_device_id *id;
-	const uuid_le *uuid;
-	const char *name;
-
-	if (!cldev)
-		return 0;
+	struct mei_device *bus;
+	struct mei_cl_cb *cb = NULL;
+	ssize_t rets;
 
-	uuid = mei_me_cl_uuid(cldev->me_cl);
-	name = cldev->name;
+	if (WARN_ON(!cl || !cl->dev))
+		return -ENODEV;
 
-	if (!cldrv || !cldrv->id_table)
-		return 0;
+	bus = cl->dev;
 
-	id = cldrv->id_table;
+	mutex_lock(&bus->device_lock);
+	if (!mei_cl_is_connected(cl)) {
+		rets = -ENODEV;
+		goto out;
+	}
 
-	while (uuid_le_cmp(NULL_UUID_LE, id->uuid)) {
+	/* Check if we have an ME client device */
+	if (!mei_me_cl_is_active(cl->me_cl)) {
+		rets = -ENOTTY;
+		goto out;
+	}
 
-		if (!uuid_le_cmp(*uuid, id->uuid)) {
-			if (id->name[0]) {
-				if (!strncmp(name, id->name, sizeof(id->name)))
-					return 1;
-			} else {
-				return 1;
-			}
-		}
+	if (length > mei_cl_mtu(cl)) {
+		rets = -EFBIG;
+		goto out;
+	}
 
-		id++;
+	cb = mei_cl_alloc_cb(cl, length, MEI_FOP_WRITE, NULL);
+	if (!cb) {
+		rets = -ENOMEM;
+		goto out;
 	}
 
-	return 0;
+	memcpy(cb->buf.data, buf, length);
+
+	rets = mei_cl_write(cl, cb, blocking);
+
+out:
+	mutex_unlock(&bus->device_lock);
+	if (rets < 0)
+		mei_io_cb_free(cb);
+
+	return rets;
 }
 
-static int mei_cl_device_probe(struct device *dev)
+/**
+ * __mei_cl_recv - internal client receive (read)
+ *
+ * @cl: host client
+ * @buf: buffer to send
+ * @length: buffer length
+ *
+ * Return: read size in bytes of < 0 on error
+ */
+ssize_t __mei_cl_recv(struct mei_cl *cl, u8 *buf, size_t length)
 {
-	struct mei_cl_device *cldev = to_mei_cl_device(dev);
-	struct mei_cl_driver *cldrv;
-	struct mei_cl_device_id id;
-
-	if (!cldev)
-		return 0;
+	struct mei_device *bus;
+	struct mei_cl_cb *cb;
+	size_t r_length;
+	ssize_t rets;
 
-	cldrv = to_mei_cl_driver(dev->driver);
-	if (!cldrv || !cldrv->probe)
+	if (WARN_ON(!cl || !cl->dev))
 		return -ENODEV;
 
-	dev_dbg(dev, "Device probe\n");
+	bus = cl->dev;
 
-	strlcpy(id.name, cldev->name, sizeof(id.name));
+	mutex_lock(&bus->device_lock);
 
-	return cldrv->probe(cldev, &id);
-}
+	cb = mei_cl_read_cb(cl, NULL);
+	if (cb)
+		goto copy;
 
-static int mei_cl_device_remove(struct device *dev)
-{
-	struct mei_cl_device *cldev = to_mei_cl_device(dev);
-	struct mei_cl_driver *cldrv;
+	rets = mei_cl_read_start(cl, length, NULL);
+	if (rets && rets != -EBUSY)
+		goto out;
 
-	if (!cldev || !dev->driver)
-		return 0;
+	/* wait on event only if there is no other waiter */
+	if (list_empty(&cl->rd_completed) && !waitqueue_active(&cl->rx_wait)) {
 
-	if (cldev->event_cb) {
-		cldev->event_cb = NULL;
-		cancel_work_sync(&cldev->event_work);
-	}
+		mutex_unlock(&bus->device_lock);
 
-	cldrv = to_mei_cl_driver(dev->driver);
-	if (!cldrv->remove) {
-		dev->driver = NULL;
+		if (wait_event_interruptible(cl->rx_wait,
+				(!list_empty(&cl->rd_completed)) ||
+				(!mei_cl_is_connected(cl)))) {
 
-		return 0;
+			if (signal_pending(current))
+				return -EINTR;
+			return -ERESTARTSYS;
+		}
+
+		mutex_lock(&bus->device_lock);
+
+		if (!mei_cl_is_connected(cl)) {
+			rets = -EBUSY;
+			goto out;
+		}
 	}
 
-	return cldrv->remove(cldev);
-}
+	cb = mei_cl_read_cb(cl, NULL);
+	if (!cb) {
+		rets = 0;
+		goto out;
+	}
 
-static ssize_t name_show(struct device *dev, struct device_attribute *a,
-			     char *buf)
-{
-	struct mei_cl_device *cldev = to_mei_cl_device(dev);
-	size_t len;
+copy:
+	if (cb->status) {
+		rets = cb->status;
+		goto free;
+	}
 
-	len = snprintf(buf, PAGE_SIZE, "%s", cldev->name);
+	r_length = min_t(size_t, length, cb->buf_idx);
+	memcpy(buf, cb->buf.data, r_length);
+	rets = r_length;
 
-	return (len >= PAGE_SIZE) ? (PAGE_SIZE - 1) : len;
+free:
+	mei_io_cb_free(cb);
+out:
+	mutex_unlock(&bus->device_lock);
+
+	return rets;
 }
-static DEVICE_ATTR_RO(name);
 
-static ssize_t uuid_show(struct device *dev, struct device_attribute *a,
-			     char *buf)
+/**
+ * mei_cl_send - me device send  (write)
+ *
+ * @cldev: me client device
+ * @buf: buffer to send
+ * @length: buffer length
+ *
+ * Return: written size in bytes or < 0 on error
+ */
+ssize_t mei_cl_send(struct mei_cl_device *cldev, u8 *buf, size_t length)
 {
-	struct mei_cl_device *cldev = to_mei_cl_device(dev);
-	const uuid_le *uuid = mei_me_cl_uuid(cldev->me_cl);
-	size_t len;
+	struct mei_cl *cl = cldev->cl;
 
-	len = snprintf(buf, PAGE_SIZE, "%pUl", uuid);
+	if (cl == NULL)
+		return -ENODEV;
 
-	return (len >= PAGE_SIZE) ? (PAGE_SIZE - 1) : len;
+	return __mei_cl_send(cl, buf, length, 1);
 }
-static DEVICE_ATTR_RO(uuid);
+EXPORT_SYMBOL_GPL(mei_cl_send);
 
-static ssize_t modalias_show(struct device *dev, struct device_attribute *a,
-			     char *buf)
+/**
+ * mei_cl_recv - client receive (read)
+ *
+ * @cldev: me client device
+ * @buf: buffer to send
+ * @length: buffer length
+ *
+ * Return: read size in bytes of < 0 on error
+ */
+ssize_t mei_cl_recv(struct mei_cl_device *cldev, u8 *buf, size_t length)
 {
-	struct mei_cl_device *cldev = to_mei_cl_device(dev);
-	const uuid_le *uuid = mei_me_cl_uuid(cldev->me_cl);
-	size_t len;
+	struct mei_cl *cl = cldev->cl;
 
-	len = snprintf(buf, PAGE_SIZE, "mei:%s:" MEI_CL_UUID_FMT ":",
-		cldev->name, MEI_CL_UUID_ARGS(uuid->b));
+	if (cl == NULL)
+		return -ENODEV;
 
-	return (len >= PAGE_SIZE) ? (PAGE_SIZE - 1) : len;
+	return __mei_cl_recv(cl, buf, length);
 }
-static DEVICE_ATTR_RO(modalias);
-
-static struct attribute *mei_cl_dev_attrs[] = {
-	&dev_attr_name.attr,
-	&dev_attr_uuid.attr,
-	&dev_attr_modalias.attr,
-	NULL,
-};
-ATTRIBUTE_GROUPS(mei_cl_dev);
+EXPORT_SYMBOL_GPL(mei_cl_recv);
 
-static int mei_cl_uevent(struct device *dev, struct kobj_uevent_env *env)
+/**
+ * mei_bus_event_work  - dispatch rx event for a bus device
+ *    and schedule new work
+ *
+ * @work: work
+ */
+static void mei_bus_event_work(struct work_struct *work)
 {
-	struct mei_cl_device *cldev = to_mei_cl_device(dev);
-	const uuid_le *uuid = mei_me_cl_uuid(cldev->me_cl);
+	struct mei_cl_device *cldev;
 
-	if (add_uevent_var(env, "MEI_CL_UUID=%pUl", uuid))
-		return -ENOMEM;
+	cldev = container_of(work, struct mei_cl_device, event_work);
 
-	if (add_uevent_var(env, "MEI_CL_NAME=%s", cldev->name))
-		return -ENOMEM;
+	if (cldev->event_cb)
+		cldev->event_cb(cldev, cldev->events, cldev->event_context);
 
-	if (add_uevent_var(env, "MODALIAS=mei:%s:" MEI_CL_UUID_FMT ":",
-		cldev->name, MEI_CL_UUID_ARGS(uuid->b)))
-		return -ENOMEM;
+	cldev->events = 0;
 
-	return 0;
+	/* Prepare for the next read */
+	mei_cl_read_start(cldev->cl, 0, NULL);
 }
 
-static struct bus_type mei_cl_bus_type = {
-	.name		= "mei",
-	.dev_groups	= mei_cl_dev_groups,
-	.match		= mei_cl_device_match,
-	.probe		= mei_cl_device_probe,
-	.remove		= mei_cl_device_remove,
-	.uevent		= mei_cl_uevent,
-};
-
-static void mei_cl_dev_release(struct device *dev)
+/**
+ * mei_cl_bus_rx_event  - schedule rx evenet
+ *
+ * @cl: host client
+ */
+void mei_cl_bus_rx_event(struct mei_cl *cl)
 {
-	struct mei_cl_device *cldev = to_mei_cl_device(dev);
+	struct mei_cl_device *cldev = cl->cldev;
 
-	if (!cldev)
+	if (!cldev || !cldev->event_cb)
 		return;
 
-	mei_me_cl_put(cldev->me_cl);
-	kfree(cldev);
-}
-
-static struct device_type mei_cl_device_type = {
-	.release	= mei_cl_dev_release,
-};
-
-struct mei_cl *mei_cl_bus_find_cl_by_uuid(struct mei_device *bus,
-					 uuid_le uuid)
-{
-	struct mei_cl *cl;
-
-	list_for_each_entry(cl, &bus->device_list, device_link) {
-		if (cl->cldev && cl->cldev->me_cl &&
-		    !uuid_le_cmp(uuid, *mei_me_cl_uuid(cl->cldev->me_cl)))
-			return cl;
-	}
+	set_bit(MEI_CL_EVENT_RX, &cldev->events);
 
-	return NULL;
+	schedule_work(&cldev->event_work);
 }
 
-struct mei_cl_device *mei_cl_add_device(struct mei_device *bus,
-					struct mei_me_client *me_cl,
-					struct mei_cl *cl,
-					char *name)
+/**
+ * mei_cl_register_event_cb - register event callback
+ *
+ * @cldev: me client devices
+ * @event_cb: callback function
+ * @context: driver context data
+ *
+ * Return: 0 on success
+ *         -EALREADY if an callback is already registered
+ *         <0 on other errors
+ */
+int mei_cl_register_event_cb(struct mei_cl_device *cldev,
+			  mei_cl_event_cb_t event_cb, void *context)
 {
-	struct mei_cl_device *cldev;
-	int status;
-
-	cldev = kzalloc(sizeof(struct mei_cl_device), GFP_KERNEL);
-	if (!cldev)
-		return NULL;
-
-	cldev->me_cl = mei_me_cl_get(me_cl);
-	if (!cldev->me_cl) {
-		kfree(cldev);
-		return NULL;
-	}
-
-	cldev->cl = cl;
-	cldev->dev.parent = bus->dev;
-	cldev->dev.bus = &mei_cl_bus_type;
-	cldev->dev.type = &mei_cl_device_type;
-
-	strlcpy(cldev->name, name, sizeof(cldev->name));
-
-	dev_set_name(&cldev->dev, "mei:%s:%pUl", name, mei_me_cl_uuid(me_cl));
+	if (cldev->event_cb)
+		return -EALREADY;
 
-	status = device_register(&cldev->dev);
-	if (status) {
-		dev_err(bus->dev, "Failed to register MEI device\n");
-		mei_me_cl_put(cldev->me_cl);
-		kfree(cldev);
-		return NULL;
-	}
+	cldev->events = 0;
+	cldev->event_cb = event_cb;
+	cldev->event_context = context;
+	INIT_WORK(&cldev->event_work, mei_bus_event_work);
 
-	cl->cldev = cldev;
+	mei_cl_read_start(cldev->cl, 0, NULL);
 
-	dev_dbg(&cldev->dev, "client %s registered\n", name);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(mei_cl_register_event_cb);
 
-	return cldev;
+/**
+ * mei_cl_get_drvdata - driver data getter
+ *
+ * @cldev: mei client device
+ *
+ * Return: driver private data
+ */
+void *mei_cl_get_drvdata(const struct mei_cl_device *cldev)
+{
+	return dev_get_drvdata(&cldev->dev);
 }
-EXPORT_SYMBOL_GPL(mei_cl_add_device);
+EXPORT_SYMBOL_GPL(mei_cl_get_drvdata);
 
-void mei_cl_remove_device(struct mei_cl_device *cldev)
+/**
+ * mei_cl_set_drvdata - driver data setter
+ *
+ * @cldev: mei client device
+ * @data: data to store
+ */
+void mei_cl_set_drvdata(struct mei_cl_device *cldev, void *data)
 {
-	device_unregister(&cldev->dev);
+	dev_set_drvdata(&cldev->dev, data);
 }
-EXPORT_SYMBOL_GPL(mei_cl_remove_device);
+EXPORT_SYMBOL_GPL(mei_cl_set_drvdata);
 
-int __mei_cl_driver_register(struct mei_cl_driver *cldrv, struct module *owner)
+/**
+ * mei_cl_enable_device - enable me client device
+ *     create connection with me client
+ *
+ * @cldev: me client device
+ *
+ * Return: 0 on success and < 0 on error
+ */
+int mei_cl_enable_device(struct mei_cl_device *cldev)
 {
 	int err;
+	struct mei_device *bus;
+	struct mei_cl *cl = cldev->cl;
 
-	cldrv->driver.name = cldrv->name;
-	cldrv->driver.owner = owner;
-	cldrv->driver.bus = &mei_cl_bus_type;
+	if (cl == NULL)
+		return -ENODEV;
 
-	err = driver_register(&cldrv->driver);
-	if (err)
-		return err;
+	bus = cl->dev;
 
-	pr_debug("mei: driver [%s] registered\n", cldrv->driver.name);
+	mutex_lock(&bus->device_lock);
 
-	return 0;
-}
-EXPORT_SYMBOL_GPL(__mei_cl_driver_register);
+	if (mei_cl_is_connected(cl)) {
+		mutex_unlock(&bus->device_lock);
+		dev_warn(bus->dev, "Already connected");
+		return -EBUSY;
+	}
 
-void mei_cl_driver_unregister(struct mei_cl_driver *cldrv)
-{
-	driver_unregister(&cldrv->driver);
+	err = mei_cl_connect(cl, cldev->me_cl, NULL);
+	if (err < 0) {
+		mutex_unlock(&bus->device_lock);
+		dev_err(bus->dev, "Could not connect to the ME client");
 
-	pr_debug("mei: driver [%s] unregistered\n", cldrv->driver.name);
+		return err;
+	}
+
+	mutex_unlock(&bus->device_lock);
+
+	if (cldev->event_cb)
+		mei_cl_read_start(cldev->cl, 0, NULL);
+
+	return 0;
 }
-EXPORT_SYMBOL_GPL(mei_cl_driver_unregister);
+EXPORT_SYMBOL_GPL(mei_cl_enable_device);
 
-ssize_t __mei_cl_send(struct mei_cl *cl, u8 *buf, size_t length,
-			bool blocking)
+/**
+ * mei_cl_disable_device - disable me client device
+ *     disconnect form the me client
+ *
+ * @cldev: me client device
+ *
+ * Return: 0 on success and < 0 on error
+ */
+int mei_cl_disable_device(struct mei_cl_device *cldev)
 {
+	int err;
 	struct mei_device *bus;
-	struct mei_cl_cb *cb = NULL;
-	ssize_t rets;
+	struct mei_cl *cl = cldev->cl;
 
-	if (WARN_ON(!cl || !cl->dev))
+	if (cl == NULL)
 		return -ENODEV;
 
 	bus = cl->dev;
 
-	mutex_lock(&bus->device_lock);
-	if (!mei_cl_is_connected(cl)) {
-		rets = -ENODEV;
-		goto out;
-	}
+	cldev->event_cb = NULL;
 
-	/* Check if we have an ME client device */
-	if (!mei_me_cl_is_active(cl->me_cl)) {
-		rets = -ENOTTY;
-		goto out;
-	}
+	mutex_lock(&bus->device_lock);
 
-	if (length > mei_cl_mtu(cl)) {
-		rets = -EFBIG;
+	if (!mei_cl_is_connected(cl)) {
+		dev_err(bus->dev, "Already disconnected");
+		err = 0;
 		goto out;
 	}
 
-	cb = mei_cl_alloc_cb(cl, length, MEI_FOP_WRITE, NULL);
-	if (!cb) {
-		rets = -ENOMEM;
+	err = mei_cl_disconnect(cl);
+	if (err < 0) {
+		dev_err(bus->dev, "Could not disconnect from the ME client");
 		goto out;
 	}
 
-	memcpy(cb->buf.data, buf, length);
-
-	rets = mei_cl_write(cl, cb, blocking);
+	/* Flush queues and remove any pending read */
+	mei_cl_flush_queues(cl, NULL);
 
 out:
 	mutex_unlock(&bus->device_lock);
-	if (rets < 0)
-		mei_io_cb_free(cb);
+	return err;
 
-	return rets;
 }
+EXPORT_SYMBOL_GPL(mei_cl_disable_device);
 
-ssize_t __mei_cl_recv(struct mei_cl *cl, u8 *buf, size_t length)
+static int mei_cl_device_match(struct device *dev, struct device_driver *drv)
 {
-	struct mei_device *bus;
-	struct mei_cl_cb *cb;
-	size_t r_length;
-	ssize_t rets;
+	struct mei_cl_device *cldev = to_mei_cl_device(dev);
+	struct mei_cl_driver *cldrv = to_mei_cl_driver(drv);
+	const struct mei_cl_device_id *id;
+	const uuid_le *uuid;
+	const char *name;
 
-	if (WARN_ON(!cl || !cl->dev))
-		return -ENODEV;
+	if (!cldev)
+		return 0;
 
-	bus = cl->dev;
+	uuid = mei_me_cl_uuid(cldev->me_cl);
+	name = cldev->name;
 
-	mutex_lock(&bus->device_lock);
+	if (!cldrv || !cldrv->id_table)
+		return 0;
 
-	cb = mei_cl_read_cb(cl, NULL);
-	if (cb)
-		goto copy;
+	id = cldrv->id_table;
 
-	rets = mei_cl_read_start(cl, length, NULL);
-	if (rets && rets != -EBUSY)
-		goto out;
+	while (uuid_le_cmp(NULL_UUID_LE, id->uuid)) {
 
-	if (list_empty(&cl->rd_completed) && !waitqueue_active(&cl->rx_wait)) {
+		if (!uuid_le_cmp(*uuid, id->uuid)) {
+			if (id->name[0]) {
+				if (!strncmp(name, id->name, sizeof(id->name)))
+					return 1;
+			} else {
+				return 1;
+			}
+		}
 
-		mutex_unlock(&bus->device_lock);
+		id++;
+	}
 
-		if (wait_event_interruptible(cl->rx_wait,
-				(!list_empty(&cl->rd_completed)) ||
-				(!mei_cl_is_connected(cl)))) {
+	return 0;
+}
 
-			if (signal_pending(current))
-				return -EINTR;
-			return -ERESTARTSYS;
-		}
+static int mei_cl_device_probe(struct device *dev)
+{
+	struct mei_cl_device *cldev = to_mei_cl_device(dev);
+	struct mei_cl_driver *cldrv;
+	struct mei_cl_device_id id;
 
-		mutex_lock(&bus->device_lock);
+	if (!cldev)
+		return 0;
 
-		if (!mei_cl_is_connected(cl)) {
-			rets = -EBUSY;
-			goto out;
-		}
-	}
+	cldrv = to_mei_cl_driver(dev->driver);
+	if (!cldrv || !cldrv->probe)
+		return -ENODEV;
+
+	dev_dbg(dev, "Device probe\n");
+
+	strlcpy(id.name, cldev->name, sizeof(id.name));
+
+	return cldrv->probe(cldev, &id);
+}
 
-	cb = mei_cl_read_cb(cl, NULL);
-	if (!cb) {
-		rets = 0;
-		goto out;
-	}
+static int mei_cl_device_remove(struct device *dev)
+{
+	struct mei_cl_device *cldev = to_mei_cl_device(dev);
+	struct mei_cl_driver *cldrv;
 
-copy:
-	if (cb->status) {
-		rets = cb->status;
-		goto free;
+	if (!cldev || !dev->driver)
+		return 0;
+
+	if (cldev->event_cb) {
+		cldev->event_cb = NULL;
+		cancel_work_sync(&cldev->event_work);
 	}
 
-	r_length = min_t(size_t, length, cb->buf_idx);
-	memcpy(buf, cb->buf.data, r_length);
-	rets = r_length;
+	cldrv = to_mei_cl_driver(dev->driver);
+	if (!cldrv->remove) {
+		dev->driver = NULL;
 
-free:
-	mei_io_cb_free(cb);
-out:
-	mutex_unlock(&bus->device_lock);
+		return 0;
+	}
 
-	return rets;
+	return cldrv->remove(cldev);
 }
 
-ssize_t mei_cl_send(struct mei_cl_device *cldev, u8 *buf, size_t length)
+static ssize_t name_show(struct device *dev, struct device_attribute *a,
+			     char *buf)
 {
-	struct mei_cl *cl = cldev->cl;
+	struct mei_cl_device *cldev = to_mei_cl_device(dev);
+	size_t len;
 
-	if (cl == NULL)
-		return -ENODEV;
+	len = snprintf(buf, PAGE_SIZE, "%s", cldev->name);
 
-	return __mei_cl_send(cl, buf, length, 1);
+	return (len >= PAGE_SIZE) ? (PAGE_SIZE - 1) : len;
 }
-EXPORT_SYMBOL_GPL(mei_cl_send);
+static DEVICE_ATTR_RO(name);
 
-ssize_t mei_cl_recv(struct mei_cl_device *cldev, u8 *buf, size_t length)
+static ssize_t uuid_show(struct device *dev, struct device_attribute *a,
+			     char *buf)
 {
-	struct mei_cl *cl = cldev->cl;
+	struct mei_cl_device *cldev = to_mei_cl_device(dev);
+	const uuid_le *uuid = mei_me_cl_uuid(cldev->me_cl);
+	size_t len;
 
-	if (cl == NULL)
-		return -ENODEV;
+	len = snprintf(buf, PAGE_SIZE, "%pUl", uuid);
 
-	return __mei_cl_recv(cl, buf, length);
+	return (len >= PAGE_SIZE) ? (PAGE_SIZE - 1) : len;
 }
-EXPORT_SYMBOL_GPL(mei_cl_recv);
+static DEVICE_ATTR_RO(uuid);
 
-static void mei_bus_event_work(struct work_struct *work)
+static ssize_t modalias_show(struct device *dev, struct device_attribute *a,
+			     char *buf)
 {
-	struct mei_cl_device *cldev;
-
-	cldev = container_of(work, struct mei_cl_device, event_work);
-
-	if (cldev->event_cb)
-		cldev->event_cb(cldev, cldev->events, cldev->event_context);
+	struct mei_cl_device *cldev = to_mei_cl_device(dev);
+	const uuid_le *uuid = mei_me_cl_uuid(cldev->me_cl);
+	size_t len;
 
-	cldev->events = 0;
+	len = snprintf(buf, PAGE_SIZE, "mei:%s:" MEI_CL_UUID_FMT ":",
+		cldev->name, MEI_CL_UUID_ARGS(uuid->b));
 
-	/* Prepare for the next read */
-	mei_cl_read_start(cldev->cl, 0, NULL);
+	return (len >= PAGE_SIZE) ? (PAGE_SIZE - 1) : len;
 }
+static DEVICE_ATTR_RO(modalias);
 
-int mei_cl_register_event_cb(struct mei_cl_device *cldev,
-			  mei_cl_event_cb_t event_cb, void *context)
+static struct attribute *mei_cl_dev_attrs[] = {
+	&dev_attr_name.attr,
+	&dev_attr_uuid.attr,
+	&dev_attr_modalias.attr,
+	NULL,
+};
+ATTRIBUTE_GROUPS(mei_cl_dev);
+
+static int mei_cl_uevent(struct device *dev, struct kobj_uevent_env *env)
 {
-	if (cldev->event_cb)
-		return -EALREADY;
+	struct mei_cl_device *cldev = to_mei_cl_device(dev);
+	const uuid_le *uuid = mei_me_cl_uuid(cldev->me_cl);
 
-	cldev->events = 0;
-	cldev->event_cb = event_cb;
-	cldev->event_context = context;
-	INIT_WORK(&cldev->event_work, mei_bus_event_work);
+	if (add_uevent_var(env, "MEI_CL_UUID=%pUl", uuid))
+		return -ENOMEM;
 
-	mei_cl_read_start(cldev->cl, 0, NULL);
+	if (add_uevent_var(env, "MEI_CL_NAME=%s", cldev->name))
+		return -ENOMEM;
+
+	if (add_uevent_var(env, "MODALIAS=mei:%s:" MEI_CL_UUID_FMT ":",
+		cldev->name, MEI_CL_UUID_ARGS(uuid->b)))
+		return -ENOMEM;
 
 	return 0;
 }
-EXPORT_SYMBOL_GPL(mei_cl_register_event_cb);
 
-void *mei_cl_get_drvdata(const struct mei_cl_device *cldev)
+static struct bus_type mei_cl_bus_type = {
+	.name		= "mei",
+	.dev_groups	= mei_cl_dev_groups,
+	.match		= mei_cl_device_match,
+	.probe		= mei_cl_device_probe,
+	.remove		= mei_cl_device_remove,
+	.uevent		= mei_cl_uevent,
+};
+
+static void mei_cl_dev_release(struct device *dev)
 {
-	return dev_get_drvdata(&cldev->dev);
+	struct mei_cl_device *cldev = to_mei_cl_device(dev);
+
+	if (!cldev)
+		return;
+
+	mei_me_cl_put(cldev->me_cl);
+	kfree(cldev);
 }
-EXPORT_SYMBOL_GPL(mei_cl_get_drvdata);
 
-void mei_cl_set_drvdata(struct mei_cl_device *cldev, void *data)
+static struct device_type mei_cl_device_type = {
+	.release	= mei_cl_dev_release,
+};
+
+struct mei_cl *mei_cl_bus_find_cl_by_uuid(struct mei_device *bus,
+					 uuid_le uuid)
 {
-	dev_set_drvdata(&cldev->dev, data);
+	struct mei_cl *cl;
+
+	list_for_each_entry(cl, &bus->device_list, device_link) {
+		if (cl->cldev && cl->cldev->me_cl &&
+		    !uuid_le_cmp(uuid, *mei_me_cl_uuid(cl->cldev->me_cl)))
+			return cl;
+	}
+
+	return NULL;
 }
-EXPORT_SYMBOL_GPL(mei_cl_set_drvdata);
 
-int mei_cl_enable_device(struct mei_cl_device *cldev)
+struct mei_cl_device *mei_cl_add_device(struct mei_device *bus,
+					struct mei_me_client *me_cl,
+					struct mei_cl *cl,
+					char *name)
 {
-	int err;
-	struct mei_device *bus;
-	struct mei_cl *cl = cldev->cl;
+	struct mei_cl_device *cldev;
+	int status;
 
-	if (cl == NULL)
-		return -ENODEV;
+	cldev = kzalloc(sizeof(struct mei_cl_device), GFP_KERNEL);
+	if (!cldev)
+		return NULL;
 
-	bus = cl->dev;
+	cldev->me_cl = mei_me_cl_get(me_cl);
+	if (!cldev->me_cl) {
+		kfree(cldev);
+		return NULL;
+	}
 
-	mutex_lock(&bus->device_lock);
+	cldev->cl = cl;
+	cldev->dev.parent = bus->dev;
+	cldev->dev.bus = &mei_cl_bus_type;
+	cldev->dev.type = &mei_cl_device_type;
 
-	if (mei_cl_is_connected(cl)) {
-		mutex_unlock(&bus->device_lock);
-		dev_warn(bus->dev, "Already connected");
-		return -EBUSY;
-	}
+	strlcpy(cldev->name, name, sizeof(cldev->name));
 
-	err = mei_cl_connect(cl, cldev->me_cl, NULL);
-	if (err < 0) {
-		mutex_unlock(&bus->device_lock);
-		dev_err(bus->dev, "Could not connect to the ME client");
+	dev_set_name(&cldev->dev, "mei:%s:%pUl", name, mei_me_cl_uuid(me_cl));
 
-		return err;
+	status = device_register(&cldev->dev);
+	if (status) {
+		dev_err(bus->dev, "Failed to register MEI device\n");
+		mei_me_cl_put(cldev->me_cl);
+		kfree(cldev);
+		return NULL;
 	}
 
-	mutex_unlock(&bus->device_lock);
+	cl->cldev = cldev;
 
-	if (cldev->event_cb)
-		mei_cl_read_start(cldev->cl, 0, NULL);
+	dev_dbg(&cldev->dev, "client %s registered\n", name);
 
-	return 0;
+	return cldev;
 }
-EXPORT_SYMBOL_GPL(mei_cl_enable_device);
+EXPORT_SYMBOL_GPL(mei_cl_add_device);
 
-int mei_cl_disable_device(struct mei_cl_device *cldev)
+void mei_cl_remove_device(struct mei_cl_device *cldev)
 {
-	int err;
-	struct mei_device *bus;
-	struct mei_cl *cl = cldev->cl;
-
-	if (cl == NULL)
-		return -ENODEV;
-
-	bus = cl->dev;
-
-	cldev->event_cb = NULL;
-
-	mutex_lock(&bus->device_lock);
+	device_unregister(&cldev->dev);
+}
+EXPORT_SYMBOL_GPL(mei_cl_remove_device);
 
-	if (!mei_cl_is_connected(cl)) {
-		dev_err(bus->dev, "Already disconnected");
-		err = 0;
-		goto out;
-	}
+int __mei_cl_driver_register(struct mei_cl_driver *cldrv, struct module *owner)
+{
+	int err;
 
-	err = mei_cl_disconnect(cl);
-	if (err < 0) {
-		dev_err(bus->dev, "Could not disconnect from the ME client");
-		goto out;
-	}
+	cldrv->driver.name = cldrv->name;
+	cldrv->driver.owner = owner;
+	cldrv->driver.bus = &mei_cl_bus_type;
 
-	/* Flush queues and remove any pending read */
-	mei_cl_flush_queues(cl, NULL);
+	err = driver_register(&cldrv->driver);
+	if (err)
+		return err;
 
-out:
-	mutex_unlock(&bus->device_lock);
-	return err;
+	pr_debug("mei: driver [%s] registered\n", cldrv->driver.name);
 
+	return 0;
 }
-EXPORT_SYMBOL_GPL(mei_cl_disable_device);
+EXPORT_SYMBOL_GPL(__mei_cl_driver_register);
 
-void mei_cl_bus_rx_event(struct mei_cl *cl)
+void mei_cl_driver_unregister(struct mei_cl_driver *cldrv)
 {
-	struct mei_cl_device *cldev = cl->cldev;
-
-	if (!cldev || !cldev->event_cb)
-		return;
-
-	set_bit(MEI_CL_EVENT_RX, &cldev->events);
+	driver_unregister(&cldrv->driver);
 
-	schedule_work(&cldev->event_work);
+	pr_debug("mei: driver [%s] unregistered\n", cldrv->driver.name);
 }
+EXPORT_SYMBOL_GPL(mei_cl_driver_unregister);
 
 int __init mei_cl_bus_init(void)
 {

commit b37719c31f8448ba36abc218a96663b4a6c66eb6
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Thu Jul 23 15:08:33 2015 +0300

    mei: bus: fix drivers and devices names confusion
    
    In the mei bus layer there is use of different variables
    of driver and device types with no clear naming convention.
    There are generic struct device and struct driver,
    then mei_cl_{device, driver}, and finally mei_device which
    in this context serves as a bus device.
    
    The patch sets following naming convention:
    
    the variables of type struct device remains dev
    the variables of type struct driver remains drv
    the variables of type struct mei_cl_device are now cldev
    the variables of type struct mei_cl_driver are now cldrv
    the variables of type struct mei_device are now bus, in bus
    layer context
    
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 458aa5a09c52..18c37af22f07 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -32,22 +32,22 @@
 
 static int mei_cl_device_match(struct device *dev, struct device_driver *drv)
 {
-	struct mei_cl_device *device = to_mei_cl_device(dev);
-	struct mei_cl_driver *driver = to_mei_cl_driver(drv);
+	struct mei_cl_device *cldev = to_mei_cl_device(dev);
+	struct mei_cl_driver *cldrv = to_mei_cl_driver(drv);
 	const struct mei_cl_device_id *id;
 	const uuid_le *uuid;
 	const char *name;
 
-	if (!device)
+	if (!cldev)
 		return 0;
 
-	uuid = mei_me_cl_uuid(device->me_cl);
-	name = device->name;
+	uuid = mei_me_cl_uuid(cldev->me_cl);
+	name = cldev->name;
 
-	if (!driver || !driver->id_table)
+	if (!cldrv || !cldrv->id_table)
 		return 0;
 
-	id = driver->id_table;
+	id = cldrv->id_table;
 
 	while (uuid_le_cmp(NULL_UUID_LE, id->uuid)) {
 
@@ -68,54 +68,54 @@ static int mei_cl_device_match(struct device *dev, struct device_driver *drv)
 
 static int mei_cl_device_probe(struct device *dev)
 {
-	struct mei_cl_device *device = to_mei_cl_device(dev);
-	struct mei_cl_driver *driver;
+	struct mei_cl_device *cldev = to_mei_cl_device(dev);
+	struct mei_cl_driver *cldrv;
 	struct mei_cl_device_id id;
 
-	if (!device)
+	if (!cldev)
 		return 0;
 
-	driver = to_mei_cl_driver(dev->driver);
-	if (!driver || !driver->probe)
+	cldrv = to_mei_cl_driver(dev->driver);
+	if (!cldrv || !cldrv->probe)
 		return -ENODEV;
 
 	dev_dbg(dev, "Device probe\n");
 
-	strlcpy(id.name, device->name, sizeof(id.name));
+	strlcpy(id.name, cldev->name, sizeof(id.name));
 
-	return driver->probe(device, &id);
+	return cldrv->probe(cldev, &id);
 }
 
 static int mei_cl_device_remove(struct device *dev)
 {
-	struct mei_cl_device *device = to_mei_cl_device(dev);
-	struct mei_cl_driver *driver;
+	struct mei_cl_device *cldev = to_mei_cl_device(dev);
+	struct mei_cl_driver *cldrv;
 
-	if (!device || !dev->driver)
+	if (!cldev || !dev->driver)
 		return 0;
 
-	if (device->event_cb) {
-		device->event_cb = NULL;
-		cancel_work_sync(&device->event_work);
+	if (cldev->event_cb) {
+		cldev->event_cb = NULL;
+		cancel_work_sync(&cldev->event_work);
 	}
 
-	driver = to_mei_cl_driver(dev->driver);
-	if (!driver->remove) {
+	cldrv = to_mei_cl_driver(dev->driver);
+	if (!cldrv->remove) {
 		dev->driver = NULL;
 
 		return 0;
 	}
 
-	return driver->remove(device);
+	return cldrv->remove(cldev);
 }
 
 static ssize_t name_show(struct device *dev, struct device_attribute *a,
 			     char *buf)
 {
-	struct mei_cl_device *device = to_mei_cl_device(dev);
+	struct mei_cl_device *cldev = to_mei_cl_device(dev);
 	size_t len;
 
-	len = snprintf(buf, PAGE_SIZE, "%s", device->name);
+	len = snprintf(buf, PAGE_SIZE, "%s", cldev->name);
 
 	return (len >= PAGE_SIZE) ? (PAGE_SIZE - 1) : len;
 }
@@ -124,8 +124,8 @@ static DEVICE_ATTR_RO(name);
 static ssize_t uuid_show(struct device *dev, struct device_attribute *a,
 			     char *buf)
 {
-	struct mei_cl_device *device = to_mei_cl_device(dev);
-	const uuid_le *uuid = mei_me_cl_uuid(device->me_cl);
+	struct mei_cl_device *cldev = to_mei_cl_device(dev);
+	const uuid_le *uuid = mei_me_cl_uuid(cldev->me_cl);
 	size_t len;
 
 	len = snprintf(buf, PAGE_SIZE, "%pUl", uuid);
@@ -137,12 +137,12 @@ static DEVICE_ATTR_RO(uuid);
 static ssize_t modalias_show(struct device *dev, struct device_attribute *a,
 			     char *buf)
 {
-	struct mei_cl_device *device = to_mei_cl_device(dev);
-	const uuid_le *uuid = mei_me_cl_uuid(device->me_cl);
+	struct mei_cl_device *cldev = to_mei_cl_device(dev);
+	const uuid_le *uuid = mei_me_cl_uuid(cldev->me_cl);
 	size_t len;
 
 	len = snprintf(buf, PAGE_SIZE, "mei:%s:" MEI_CL_UUID_FMT ":",
-		device->name, MEI_CL_UUID_ARGS(uuid->b));
+		cldev->name, MEI_CL_UUID_ARGS(uuid->b));
 
 	return (len >= PAGE_SIZE) ? (PAGE_SIZE - 1) : len;
 }
@@ -158,17 +158,17 @@ ATTRIBUTE_GROUPS(mei_cl_dev);
 
 static int mei_cl_uevent(struct device *dev, struct kobj_uevent_env *env)
 {
-	struct mei_cl_device *device = to_mei_cl_device(dev);
-	const uuid_le *uuid = mei_me_cl_uuid(device->me_cl);
+	struct mei_cl_device *cldev = to_mei_cl_device(dev);
+	const uuid_le *uuid = mei_me_cl_uuid(cldev->me_cl);
 
 	if (add_uevent_var(env, "MEI_CL_UUID=%pUl", uuid))
 		return -ENOMEM;
 
-	if (add_uevent_var(env, "MEI_CL_NAME=%s", device->name))
+	if (add_uevent_var(env, "MEI_CL_NAME=%s", cldev->name))
 		return -ENOMEM;
 
 	if (add_uevent_var(env, "MODALIAS=mei:%s:" MEI_CL_UUID_FMT ":",
-		device->name, MEI_CL_UUID_ARGS(uuid->b)))
+		cldev->name, MEI_CL_UUID_ARGS(uuid->b)))
 		return -ENOMEM;
 
 	return 0;
@@ -185,121 +185,121 @@ static struct bus_type mei_cl_bus_type = {
 
 static void mei_cl_dev_release(struct device *dev)
 {
-	struct mei_cl_device *device = to_mei_cl_device(dev);
+	struct mei_cl_device *cldev = to_mei_cl_device(dev);
 
-	if (!device)
+	if (!cldev)
 		return;
 
-	mei_me_cl_put(device->me_cl);
-	kfree(device);
+	mei_me_cl_put(cldev->me_cl);
+	kfree(cldev);
 }
 
 static struct device_type mei_cl_device_type = {
 	.release	= mei_cl_dev_release,
 };
 
-struct mei_cl *mei_cl_bus_find_cl_by_uuid(struct mei_device *dev,
+struct mei_cl *mei_cl_bus_find_cl_by_uuid(struct mei_device *bus,
 					 uuid_le uuid)
 {
 	struct mei_cl *cl;
 
-	list_for_each_entry(cl, &dev->device_list, device_link) {
-		if (cl->device && cl->device->me_cl &&
-		    !uuid_le_cmp(uuid, *mei_me_cl_uuid(cl->device->me_cl)))
+	list_for_each_entry(cl, &bus->device_list, device_link) {
+		if (cl->cldev && cl->cldev->me_cl &&
+		    !uuid_le_cmp(uuid, *mei_me_cl_uuid(cl->cldev->me_cl)))
 			return cl;
 	}
 
 	return NULL;
 }
 
-struct mei_cl_device *mei_cl_add_device(struct mei_device *dev,
+struct mei_cl_device *mei_cl_add_device(struct mei_device *bus,
 					struct mei_me_client *me_cl,
 					struct mei_cl *cl,
 					char *name)
 {
-	struct mei_cl_device *device;
+	struct mei_cl_device *cldev;
 	int status;
 
-	device = kzalloc(sizeof(struct mei_cl_device), GFP_KERNEL);
-	if (!device)
+	cldev = kzalloc(sizeof(struct mei_cl_device), GFP_KERNEL);
+	if (!cldev)
 		return NULL;
 
-	device->me_cl = mei_me_cl_get(me_cl);
-	if (!device->me_cl) {
-		kfree(device);
+	cldev->me_cl = mei_me_cl_get(me_cl);
+	if (!cldev->me_cl) {
+		kfree(cldev);
 		return NULL;
 	}
 
-	device->cl = cl;
-	device->dev.parent = dev->dev;
-	device->dev.bus = &mei_cl_bus_type;
-	device->dev.type = &mei_cl_device_type;
+	cldev->cl = cl;
+	cldev->dev.parent = bus->dev;
+	cldev->dev.bus = &mei_cl_bus_type;
+	cldev->dev.type = &mei_cl_device_type;
 
-	strlcpy(device->name, name, sizeof(device->name));
+	strlcpy(cldev->name, name, sizeof(cldev->name));
 
-	dev_set_name(&device->dev, "mei:%s:%pUl", name, mei_me_cl_uuid(me_cl));
+	dev_set_name(&cldev->dev, "mei:%s:%pUl", name, mei_me_cl_uuid(me_cl));
 
-	status = device_register(&device->dev);
+	status = device_register(&cldev->dev);
 	if (status) {
-		dev_err(dev->dev, "Failed to register MEI device\n");
-		mei_me_cl_put(device->me_cl);
-		kfree(device);
+		dev_err(bus->dev, "Failed to register MEI device\n");
+		mei_me_cl_put(cldev->me_cl);
+		kfree(cldev);
 		return NULL;
 	}
 
-	cl->device = device;
+	cl->cldev = cldev;
 
-	dev_dbg(&device->dev, "client %s registered\n", name);
+	dev_dbg(&cldev->dev, "client %s registered\n", name);
 
-	return device;
+	return cldev;
 }
 EXPORT_SYMBOL_GPL(mei_cl_add_device);
 
-void mei_cl_remove_device(struct mei_cl_device *device)
+void mei_cl_remove_device(struct mei_cl_device *cldev)
 {
-	device_unregister(&device->dev);
+	device_unregister(&cldev->dev);
 }
 EXPORT_SYMBOL_GPL(mei_cl_remove_device);
 
-int __mei_cl_driver_register(struct mei_cl_driver *driver, struct module *owner)
+int __mei_cl_driver_register(struct mei_cl_driver *cldrv, struct module *owner)
 {
 	int err;
 
-	driver->driver.name = driver->name;
-	driver->driver.owner = owner;
-	driver->driver.bus = &mei_cl_bus_type;
+	cldrv->driver.name = cldrv->name;
+	cldrv->driver.owner = owner;
+	cldrv->driver.bus = &mei_cl_bus_type;
 
-	err = driver_register(&driver->driver);
+	err = driver_register(&cldrv->driver);
 	if (err)
 		return err;
 
-	pr_debug("mei: driver [%s] registered\n", driver->driver.name);
+	pr_debug("mei: driver [%s] registered\n", cldrv->driver.name);
 
 	return 0;
 }
 EXPORT_SYMBOL_GPL(__mei_cl_driver_register);
 
-void mei_cl_driver_unregister(struct mei_cl_driver *driver)
+void mei_cl_driver_unregister(struct mei_cl_driver *cldrv)
 {
-	driver_unregister(&driver->driver);
+	driver_unregister(&cldrv->driver);
 
-	pr_debug("mei: driver [%s] unregistered\n", driver->driver.name);
+	pr_debug("mei: driver [%s] unregistered\n", cldrv->driver.name);
 }
 EXPORT_SYMBOL_GPL(mei_cl_driver_unregister);
 
 ssize_t __mei_cl_send(struct mei_cl *cl, u8 *buf, size_t length,
 			bool blocking)
 {
-	struct mei_device *dev;
+	struct mei_device *bus;
 	struct mei_cl_cb *cb = NULL;
 	ssize_t rets;
 
 	if (WARN_ON(!cl || !cl->dev))
 		return -ENODEV;
 
-	dev = cl->dev;
+	bus = cl->dev;
 
-	mutex_lock(&dev->device_lock);
+	mutex_lock(&bus->device_lock);
 	if (!mei_cl_is_connected(cl)) {
 		rets = -ENODEV;
 		goto out;
@@ -327,7 +327,7 @@ ssize_t __mei_cl_send(struct mei_cl *cl, u8 *buf, size_t length,
 	rets = mei_cl_write(cl, cb, blocking);
 
 out:
-	mutex_unlock(&dev->device_lock);
+	mutex_unlock(&bus->device_lock);
 	if (rets < 0)
 		mei_io_cb_free(cb);
 
@@ -336,7 +336,7 @@ ssize_t __mei_cl_send(struct mei_cl *cl, u8 *buf, size_t length,
 
 ssize_t __mei_cl_recv(struct mei_cl *cl, u8 *buf, size_t length)
 {
-	struct mei_device *dev;
+	struct mei_device *bus;
 	struct mei_cl_cb *cb;
 	size_t r_length;
 	ssize_t rets;
@@ -344,9 +344,9 @@ ssize_t __mei_cl_recv(struct mei_cl *cl, u8 *buf, size_t length)
 	if (WARN_ON(!cl || !cl->dev))
 		return -ENODEV;
 
-	dev = cl->dev;
+	bus = cl->dev;
 
-	mutex_lock(&dev->device_lock);
+	mutex_lock(&bus->device_lock);
 
 	cb = mei_cl_read_cb(cl, NULL);
 	if (cb)
@@ -358,7 +358,7 @@ ssize_t __mei_cl_recv(struct mei_cl *cl, u8 *buf, size_t length)
 
 	if (list_empty(&cl->rd_completed) && !waitqueue_active(&cl->rx_wait)) {
 
-		mutex_unlock(&dev->device_lock);
+		mutex_unlock(&bus->device_lock);
 
 		if (wait_event_interruptible(cl->rx_wait,
 				(!list_empty(&cl->rd_completed)) ||
@@ -369,7 +369,7 @@ ssize_t __mei_cl_recv(struct mei_cl *cl, u8 *buf, size_t length)
 			return -ERESTARTSYS;
 		}
 
-		mutex_lock(&dev->device_lock);
+		mutex_lock(&bus->device_lock);
 
 		if (!mei_cl_is_connected(cl)) {
 			rets = -EBUSY;
@@ -396,14 +396,14 @@ ssize_t __mei_cl_recv(struct mei_cl *cl, u8 *buf, size_t length)
 free:
 	mei_io_cb_free(cb);
 out:
-	mutex_unlock(&dev->device_lock);
+	mutex_unlock(&bus->device_lock);
 
 	return rets;
 }
 
-ssize_t mei_cl_send(struct mei_cl_device *device, u8 *buf, size_t length)
+ssize_t mei_cl_send(struct mei_cl_device *cldev, u8 *buf, size_t length)
 {
-	struct mei_cl *cl = device->cl;
+	struct mei_cl *cl = cldev->cl;
 
 	if (cl == NULL)
 		return -ENODEV;
@@ -412,9 +412,9 @@ ssize_t mei_cl_send(struct mei_cl_device *device, u8 *buf, size_t length)
 }
 EXPORT_SYMBOL_GPL(mei_cl_send);
 
-ssize_t mei_cl_recv(struct mei_cl_device *device, u8 *buf, size_t length)
+ssize_t mei_cl_recv(struct mei_cl_device *cldev, u8 *buf, size_t length)
 {
-	struct mei_cl *cl = device->cl;
+	struct mei_cl *cl = cldev->cl;
 
 	if (cl == NULL)
 		return -ENODEV;
@@ -425,108 +425,108 @@ EXPORT_SYMBOL_GPL(mei_cl_recv);
 
 static void mei_bus_event_work(struct work_struct *work)
 {
-	struct mei_cl_device *device;
+	struct mei_cl_device *cldev;
 
-	device = container_of(work, struct mei_cl_device, event_work);
+	cldev = container_of(work, struct mei_cl_device, event_work);
 
-	if (device->event_cb)
-		device->event_cb(device, device->events, device->event_context);
+	if (cldev->event_cb)
+		cldev->event_cb(cldev, cldev->events, cldev->event_context);
 
-	device->events = 0;
+	cldev->events = 0;
 
 	/* Prepare for the next read */
-	mei_cl_read_start(device->cl, 0, NULL);
+	mei_cl_read_start(cldev->cl, 0, NULL);
 }
 
-int mei_cl_register_event_cb(struct mei_cl_device *device,
+int mei_cl_register_event_cb(struct mei_cl_device *cldev,
 			  mei_cl_event_cb_t event_cb, void *context)
 {
-	if (device->event_cb)
+	if (cldev->event_cb)
 		return -EALREADY;
 
-	device->events = 0;
-	device->event_cb = event_cb;
-	device->event_context = context;
-	INIT_WORK(&device->event_work, mei_bus_event_work);
+	cldev->events = 0;
+	cldev->event_cb = event_cb;
+	cldev->event_context = context;
+	INIT_WORK(&cldev->event_work, mei_bus_event_work);
 
-	mei_cl_read_start(device->cl, 0, NULL);
+	mei_cl_read_start(cldev->cl, 0, NULL);
 
 	return 0;
 }
 EXPORT_SYMBOL_GPL(mei_cl_register_event_cb);
 
-void *mei_cl_get_drvdata(const struct mei_cl_device *device)
+void *mei_cl_get_drvdata(const struct mei_cl_device *cldev)
 {
-	return dev_get_drvdata(&device->dev);
+	return dev_get_drvdata(&cldev->dev);
 }
 EXPORT_SYMBOL_GPL(mei_cl_get_drvdata);
 
-void mei_cl_set_drvdata(struct mei_cl_device *device, void *data)
+void mei_cl_set_drvdata(struct mei_cl_device *cldev, void *data)
 {
-	dev_set_drvdata(&device->dev, data);
+	dev_set_drvdata(&cldev->dev, data);
 }
 EXPORT_SYMBOL_GPL(mei_cl_set_drvdata);
 
-int mei_cl_enable_device(struct mei_cl_device *device)
+int mei_cl_enable_device(struct mei_cl_device *cldev)
 {
 	int err;
-	struct mei_device *dev;
-	struct mei_cl *cl = device->cl;
+	struct mei_device *bus;
+	struct mei_cl *cl = cldev->cl;
 
 	if (cl == NULL)
 		return -ENODEV;
 
-	dev = cl->dev;
+	bus = cl->dev;
 
-	mutex_lock(&dev->device_lock);
+	mutex_lock(&bus->device_lock);
 
 	if (mei_cl_is_connected(cl)) {
-		mutex_unlock(&dev->device_lock);
-		dev_warn(dev->dev, "Already connected");
+		mutex_unlock(&bus->device_lock);
+		dev_warn(bus->dev, "Already connected");
 		return -EBUSY;
 	}
 
-	err = mei_cl_connect(cl, device->me_cl, NULL);
+	err = mei_cl_connect(cl, cldev->me_cl, NULL);
 	if (err < 0) {
-		mutex_unlock(&dev->device_lock);
-		dev_err(dev->dev, "Could not connect to the ME client");
+		mutex_unlock(&bus->device_lock);
+		dev_err(bus->dev, "Could not connect to the ME client");
 
 		return err;
 	}
 
-	mutex_unlock(&dev->device_lock);
+	mutex_unlock(&bus->device_lock);
 
-	if (device->event_cb)
-		mei_cl_read_start(device->cl, 0, NULL);
+	if (cldev->event_cb)
+		mei_cl_read_start(cldev->cl, 0, NULL);
 
 	return 0;
 }
 EXPORT_SYMBOL_GPL(mei_cl_enable_device);
 
-int mei_cl_disable_device(struct mei_cl_device *device)
+int mei_cl_disable_device(struct mei_cl_device *cldev)
 {
 	int err;
-	struct mei_device *dev;
-	struct mei_cl *cl = device->cl;
+	struct mei_device *bus;
+	struct mei_cl *cl = cldev->cl;
 
 	if (cl == NULL)
 		return -ENODEV;
 
-	dev = cl->dev;
+	bus = cl->dev;
 
-	device->event_cb = NULL;
+	cldev->event_cb = NULL;
 
-	mutex_lock(&dev->device_lock);
+	mutex_lock(&bus->device_lock);
 
 	if (!mei_cl_is_connected(cl)) {
-		dev_err(dev->dev, "Already disconnected");
+		dev_err(bus->dev, "Already disconnected");
 		err = 0;
 		goto out;
 	}
 
 	err = mei_cl_disconnect(cl);
 	if (err < 0) {
-		dev_err(dev->dev, "Could not disconnect from the ME client");
+		dev_err(bus->dev, "Could not disconnect from the ME client");
 		goto out;
 	}
 
@@ -534,7 +534,7 @@ int mei_cl_disable_device(struct mei_cl_device *device)
 	mei_cl_flush_queues(cl, NULL);
 
 out:
-	mutex_unlock(&dev->device_lock);
+	mutex_unlock(&bus->device_lock);
 	return err;
 
 }
@@ -542,14 +542,14 @@ EXPORT_SYMBOL_GPL(mei_cl_disable_device);
 
 void mei_cl_bus_rx_event(struct mei_cl *cl)
 {
-	struct mei_cl_device *device = cl->device;
+	struct mei_cl_device *cldev = cl->cldev;
 
-	if (!device || !device->event_cb)
+	if (!cldev || !cldev->event_cb)
 		return;
 
-	set_bit(MEI_CL_EVENT_RX, &device->events);
+	set_bit(MEI_CL_EVENT_RX, &cldev->events);
 
-	schedule_work(&device->event_work);
+	schedule_work(&cldev->event_work);
 }
 
 int __init mei_cl_bus_init(void)

commit 4f273959b850569253299987eee611927f048de7
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Wed Jul 8 00:22:03 2015 +0300

    mei: nfc: fix deadlock on shutdown/suspend path
    
    In function mei_nfc_host_exit mei_cl_remove_device cannot be called
    under the device mutex as device removing flow invokes the device driver
    remove handler that calls in turn to mei_cl_disable_device which
    naturally acquires the device mutex.
    
    Also remove mei_cl_bus_remove_devices which has the same issue, but is
    never executed as currently the only device on the mei client bus is NFC
    and a new device cannot be easily added till the bus revamp is
    completed.
    
    This fixes regression caused by commit be9b720a0ccb ("mei_phy: move all
    nfc logic from mei driver to nfc")
    
    Prior to this change the nfc driver remove handler called to no-op
    disable function while actual nfc device was disabled directly from the
    mei driver.
    
    Reported-by: Linus Torvalds <torvalds@linux-foundation.org>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Samuel Ortiz <sameo@linux.intel.com>
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 357b6ae4d207..458aa5a09c52 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -552,22 +552,6 @@ void mei_cl_bus_rx_event(struct mei_cl *cl)
 	schedule_work(&device->event_work);
 }
 
-void mei_cl_bus_remove_devices(struct mei_device *dev)
-{
-	struct mei_cl *cl, *next;
-
-	mutex_lock(&dev->device_lock);
-	list_for_each_entry_safe(cl, next, &dev->device_list, device_link) {
-		if (cl->device)
-			mei_cl_remove_device(cl->device);
-
-		list_del(&cl->device_link);
-		mei_cl_unlink(cl);
-		kfree(cl);
-	}
-	mutex_unlock(&dev->device_lock);
-}
-
 int __init mei_cl_bus_init(void)
 {
 	return bus_register(&mei_cl_bus_type);

commit b144ce2d37619e05afdb0a15676500d76a64b1be
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed May 27 17:17:27 2015 -0700

    mei: fix up uuid matching
    
    A previous commit, c93b76b34b4d ("mei: bus: report also uuid in module
    alias") caused a build error as I missed applying a needed patch to add
    some macros to uapi/linux/uuid.h.  Instead of those additional macros,
    change the mei code to use the existing uuid structure directly.
    
    Fixes: c93b76b34b4d
    Cc: Tomas Winkler <tomas.winkler@intel.com>
    Cc: Samuel Ortiz <sameo@linux.intel.com>
    Reported-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index de8fd089a8a4..357b6ae4d207 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -30,11 +30,6 @@
 #define to_mei_cl_driver(d) container_of(d, struct mei_cl_driver, driver)
 #define to_mei_cl_device(d) container_of(d, struct mei_cl_device, dev)
 
-static inline uuid_le uuid_le_cast(const __u8 uuid[16])
-{
-	return *(uuid_le *)uuid;
-}
-
 static int mei_cl_device_match(struct device *dev, struct device_driver *drv)
 {
 	struct mei_cl_device *device = to_mei_cl_device(dev);
@@ -54,9 +49,9 @@ static int mei_cl_device_match(struct device *dev, struct device_driver *drv)
 
 	id = driver->id_table;
 
-	while (uuid_le_cmp(NULL_UUID_LE, uuid_le_cast(id->uuid))) {
+	while (uuid_le_cmp(NULL_UUID_LE, id->uuid)) {
 
-		if (!uuid_le_cmp(*uuid, uuid_le_cast(id->uuid))) {
+		if (!uuid_le_cmp(*uuid, id->uuid)) {
 			if (id->name[0]) {
 				if (!strncmp(name, id->name, sizeof(id->name)))
 					return 1;

commit be9b720a0ccba096d669bc86634f900b82b9bf71
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Thu May 7 15:54:04 2015 +0300

    NFC: mei_phy: move all nfc logic from mei driver to nfc
    
    move nfc logic to mei_phy module, we prefer as much as
    possible not to deal with a particualr client protocol
    in the mei generic infrasutcutre
    
    Cc: Samuel Ortiz <sameo@linux.intel.com>
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index e76d94aa6e12..de8fd089a8a4 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -220,8 +220,7 @@ struct mei_cl *mei_cl_bus_find_cl_by_uuid(struct mei_device *dev,
 struct mei_cl_device *mei_cl_add_device(struct mei_device *dev,
 					struct mei_me_client *me_cl,
 					struct mei_cl *cl,
-					char *name,
-					struct mei_cl_ops *ops)
+					char *name)
 {
 	struct mei_cl_device *device;
 	int status;
@@ -235,9 +234,8 @@ struct mei_cl_device *mei_cl_add_device(struct mei_device *dev,
 		kfree(device);
 		return NULL;
 	}
-	device->cl = cl;
-	device->ops = ops;
 
+	device->cl = cl;
 	device->dev.parent = dev->dev;
 	device->dev.bus = &mei_cl_bus_type;
 	device->dev.type = &mei_cl_device_type;
@@ -294,7 +292,7 @@ void mei_cl_driver_unregister(struct mei_cl_driver *driver)
 }
 EXPORT_SYMBOL_GPL(mei_cl_driver_unregister);
 
-static ssize_t ___mei_cl_send(struct mei_cl *cl, u8 *buf, size_t length,
+ssize_t __mei_cl_send(struct mei_cl *cl, u8 *buf, size_t length,
 			bool blocking)
 {
 	struct mei_device *dev;
@@ -408,16 +406,6 @@ ssize_t __mei_cl_recv(struct mei_cl *cl, u8 *buf, size_t length)
 	return rets;
 }
 
-inline ssize_t __mei_cl_async_send(struct mei_cl *cl, u8 *buf, size_t length)
-{
-	return ___mei_cl_send(cl, buf, length, 0);
-}
-
-inline ssize_t __mei_cl_send(struct mei_cl *cl, u8 *buf, size_t length)
-{
-	return ___mei_cl_send(cl, buf, length, 1);
-}
-
 ssize_t mei_cl_send(struct mei_cl_device *device, u8 *buf, size_t length)
 {
 	struct mei_cl *cl = device->cl;
@@ -425,23 +413,17 @@ ssize_t mei_cl_send(struct mei_cl_device *device, u8 *buf, size_t length)
 	if (cl == NULL)
 		return -ENODEV;
 
-	if (device->ops && device->ops->send)
-		return device->ops->send(device, buf, length);
-
-	return __mei_cl_send(cl, buf, length);
+	return __mei_cl_send(cl, buf, length, 1);
 }
 EXPORT_SYMBOL_GPL(mei_cl_send);
 
 ssize_t mei_cl_recv(struct mei_cl_device *device, u8 *buf, size_t length)
 {
-	struct mei_cl *cl =  device->cl;
+	struct mei_cl *cl = device->cl;
 
 	if (cl == NULL)
 		return -ENODEV;
 
-	if (device->ops && device->ops->recv)
-		return device->ops->recv(device, buf, length);
-
 	return __mei_cl_recv(cl, buf, length);
 }
 EXPORT_SYMBOL_GPL(mei_cl_recv);
@@ -522,10 +504,7 @@ int mei_cl_enable_device(struct mei_cl_device *device)
 	if (device->event_cb)
 		mei_cl_read_start(device->cl, 0, NULL);
 
-	if (!device->ops || !device->ops->enable)
-		return 0;
-
-	return device->ops->enable(device);
+	return 0;
 }
 EXPORT_SYMBOL_GPL(mei_cl_enable_device);
 
@@ -540,9 +519,6 @@ int mei_cl_disable_device(struct mei_cl_device *device)
 
 	dev = cl->dev;
 
-	if (device->ops && device->ops->disable)
-		device->ops->disable(device);
-
 	device->event_cb = NULL;
 
 	mutex_lock(&dev->device_lock);

commit 007d64eb2232b91aa86b51abc1742936807e0bd4
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Thu May 7 15:54:03 2015 +0300

    mei: bus: add name and uuid into device attributes
    
    Export name and uuid via sysfs and uevent
    
    Cc: linux-api@vger.kernel.org
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 17b00baa53b1..e76d94aa6e12 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -114,6 +114,31 @@ static int mei_cl_device_remove(struct device *dev)
 	return driver->remove(device);
 }
 
+static ssize_t name_show(struct device *dev, struct device_attribute *a,
+			     char *buf)
+{
+	struct mei_cl_device *device = to_mei_cl_device(dev);
+	size_t len;
+
+	len = snprintf(buf, PAGE_SIZE, "%s", device->name);
+
+	return (len >= PAGE_SIZE) ? (PAGE_SIZE - 1) : len;
+}
+static DEVICE_ATTR_RO(name);
+
+static ssize_t uuid_show(struct device *dev, struct device_attribute *a,
+			     char *buf)
+{
+	struct mei_cl_device *device = to_mei_cl_device(dev);
+	const uuid_le *uuid = mei_me_cl_uuid(device->me_cl);
+	size_t len;
+
+	len = snprintf(buf, PAGE_SIZE, "%pUl", uuid);
+
+	return (len >= PAGE_SIZE) ? (PAGE_SIZE - 1) : len;
+}
+static DEVICE_ATTR_RO(uuid);
+
 static ssize_t modalias_show(struct device *dev, struct device_attribute *a,
 			     char *buf)
 {
@@ -129,6 +154,8 @@ static ssize_t modalias_show(struct device *dev, struct device_attribute *a,
 static DEVICE_ATTR_RO(modalias);
 
 static struct attribute *mei_cl_dev_attrs[] = {
+	&dev_attr_name.attr,
+	&dev_attr_uuid.attr,
 	&dev_attr_modalias.attr,
 	NULL,
 };
@@ -139,6 +166,12 @@ static int mei_cl_uevent(struct device *dev, struct kobj_uevent_env *env)
 	struct mei_cl_device *device = to_mei_cl_device(dev);
 	const uuid_le *uuid = mei_me_cl_uuid(device->me_cl);
 
+	if (add_uevent_var(env, "MEI_CL_UUID=%pUl", uuid))
+		return -ENOMEM;
+
+	if (add_uevent_var(env, "MEI_CL_NAME=%s", device->name))
+		return -ENOMEM;
+
 	if (add_uevent_var(env, "MODALIAS=mei:%s:" MEI_CL_UUID_FMT ":",
 		device->name, MEI_CL_UUID_ARGS(uuid->b)))
 		return -ENOMEM;

commit c93b76b34b4d8dbe8e3443eb27e49ac60034342b
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Thu May 7 15:54:02 2015 +0300

    mei: bus: report also uuid in module alias
    
    In order to automate modules matching add device uuid
    which is reported in client enumeration, keep also
    the name that is needed in for nfc distinguishing radio vendor
    
    Report mei:name:uuid
    
    Cc: linux-api@vger.kernel.org
    Cc: Samuel Ortiz <sameo@linux.intel.com>
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 1101d6efaf27..17b00baa53b1 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -30,23 +30,40 @@
 #define to_mei_cl_driver(d) container_of(d, struct mei_cl_driver, driver)
 #define to_mei_cl_device(d) container_of(d, struct mei_cl_device, dev)
 
+static inline uuid_le uuid_le_cast(const __u8 uuid[16])
+{
+	return *(uuid_le *)uuid;
+}
+
 static int mei_cl_device_match(struct device *dev, struct device_driver *drv)
 {
 	struct mei_cl_device *device = to_mei_cl_device(dev);
 	struct mei_cl_driver *driver = to_mei_cl_driver(drv);
 	const struct mei_cl_device_id *id;
+	const uuid_le *uuid;
+	const char *name;
 
 	if (!device)
 		return 0;
 
+	uuid = mei_me_cl_uuid(device->me_cl);
+	name = device->name;
+
 	if (!driver || !driver->id_table)
 		return 0;
 
 	id = driver->id_table;
 
-	while (id->name[0]) {
-		if (!strncmp(dev_name(dev), id->name, sizeof(id->name)))
-			return 1;
+	while (uuid_le_cmp(NULL_UUID_LE, uuid_le_cast(id->uuid))) {
+
+		if (!uuid_le_cmp(*uuid, uuid_le_cast(id->uuid))) {
+			if (id->name[0]) {
+				if (!strncmp(name, id->name, sizeof(id->name)))
+					return 1;
+			} else {
+				return 1;
+			}
+		}
 
 		id++;
 	}
@@ -69,7 +86,7 @@ static int mei_cl_device_probe(struct device *dev)
 
 	dev_dbg(dev, "Device probe\n");
 
-	strlcpy(id.name, dev_name(dev), sizeof(id.name));
+	strlcpy(id.name, device->name, sizeof(id.name));
 
 	return driver->probe(device, &id);
 }
@@ -100,9 +117,12 @@ static int mei_cl_device_remove(struct device *dev)
 static ssize_t modalias_show(struct device *dev, struct device_attribute *a,
 			     char *buf)
 {
-	int len;
+	struct mei_cl_device *device = to_mei_cl_device(dev);
+	const uuid_le *uuid = mei_me_cl_uuid(device->me_cl);
+	size_t len;
 
-	len = snprintf(buf, PAGE_SIZE, "mei:%s\n", dev_name(dev));
+	len = snprintf(buf, PAGE_SIZE, "mei:%s:" MEI_CL_UUID_FMT ":",
+		device->name, MEI_CL_UUID_ARGS(uuid->b));
 
 	return (len >= PAGE_SIZE) ? (PAGE_SIZE - 1) : len;
 }
@@ -116,7 +136,11 @@ ATTRIBUTE_GROUPS(mei_cl_dev);
 
 static int mei_cl_uevent(struct device *dev, struct kobj_uevent_env *env)
 {
-	if (add_uevent_var(env, "MODALIAS=mei:%s", dev_name(dev)))
+	struct mei_cl_device *device = to_mei_cl_device(dev);
+	const uuid_le *uuid = mei_me_cl_uuid(device->me_cl);
+
+	if (add_uevent_var(env, "MODALIAS=mei:%s:" MEI_CL_UUID_FMT ":",
+		device->name, MEI_CL_UUID_ARGS(uuid->b)))
 		return -ENOMEM;
 
 	return 0;
@@ -185,7 +209,9 @@ struct mei_cl_device *mei_cl_add_device(struct mei_device *dev,
 	device->dev.bus = &mei_cl_bus_type;
 	device->dev.type = &mei_cl_device_type;
 
-	dev_set_name(&device->dev, "%s", name);
+	strlcpy(device->name, name, sizeof(device->name));
+
+	dev_set_name(&device->dev, "mei:%s:%pUl", name, mei_me_cl_uuid(me_cl));
 
 	status = device_register(&device->dev);
 	if (status) {

commit d49ed64a6e3f73975b7eb570c4ea8f37e87d7e5d
Author: Alexander Usyskin <alexander.usyskin@intel.com>
Date:   Mon May 4 09:43:54 2015 +0300

    mei: add a reference from the host client to the me client
    
    Keep a pointer to associated me client in the host client object to
    eliminate me client searches. Check if the me client is active in the
    firmware by checking if its is linked on the me clients list
    Add accessors for the me client properties from host client.
    
    Signed-off-by: Alexander Usyskin <alexander.usyskin@intel.com>
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 00b0cb2075fb..1101d6efaf27 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -133,7 +133,13 @@ static struct bus_type mei_cl_bus_type = {
 
 static void mei_cl_dev_release(struct device *dev)
 {
-	kfree(to_mei_cl_device(dev));
+	struct mei_cl_device *device = to_mei_cl_device(dev);
+
+	if (!device)
+		return;
+
+	mei_me_cl_put(device->me_cl);
+	kfree(device);
 }
 
 static struct device_type mei_cl_device_type = {
@@ -141,33 +147,37 @@ static struct device_type mei_cl_device_type = {
 };
 
 struct mei_cl *mei_cl_bus_find_cl_by_uuid(struct mei_device *dev,
-						uuid_le uuid)
+					 uuid_le uuid)
 {
 	struct mei_cl *cl;
 
 	list_for_each_entry(cl, &dev->device_list, device_link) {
-		if (!uuid_le_cmp(uuid, cl->cl_uuid))
+		if (cl->device && cl->device->me_cl &&
+		    !uuid_le_cmp(uuid, *mei_me_cl_uuid(cl->device->me_cl)))
 			return cl;
 	}
 
 	return NULL;
 }
+
 struct mei_cl_device *mei_cl_add_device(struct mei_device *dev,
-					uuid_le uuid, char *name,
+					struct mei_me_client *me_cl,
+					struct mei_cl *cl,
+					char *name,
 					struct mei_cl_ops *ops)
 {
 	struct mei_cl_device *device;
-	struct mei_cl *cl;
 	int status;
 
-	cl = mei_cl_bus_find_cl_by_uuid(dev, uuid);
-	if (cl == NULL)
-		return NULL;
-
 	device = kzalloc(sizeof(struct mei_cl_device), GFP_KERNEL);
 	if (!device)
 		return NULL;
 
+	device->me_cl = mei_me_cl_get(me_cl);
+	if (!device->me_cl) {
+		kfree(device);
+		return NULL;
+	}
 	device->cl = cl;
 	device->ops = ops;
 
@@ -180,6 +190,7 @@ struct mei_cl_device *mei_cl_add_device(struct mei_device *dev,
 	status = device_register(&device->dev);
 	if (status) {
 		dev_err(dev->dev, "Failed to register MEI device\n");
+		mei_me_cl_put(device->me_cl);
 		kfree(device);
 		return NULL;
 	}
@@ -228,7 +239,6 @@ static ssize_t ___mei_cl_send(struct mei_cl *cl, u8 *buf, size_t length,
 			bool blocking)
 {
 	struct mei_device *dev;
-	struct mei_me_client *me_cl = NULL;
 	struct mei_cl_cb *cb = NULL;
 	ssize_t rets;
 
@@ -244,13 +254,12 @@ static ssize_t ___mei_cl_send(struct mei_cl *cl, u8 *buf, size_t length,
 	}
 
 	/* Check if we have an ME client device */
-	me_cl = mei_me_cl_by_uuid_id(dev, &cl->cl_uuid, cl->me_client_id);
-	if (!me_cl) {
+	if (!mei_me_cl_is_active(cl->me_cl)) {
 		rets = -ENOTTY;
 		goto out;
 	}
 
-	if (length > me_cl->props.max_msg_length) {
+	if (length > mei_cl_mtu(cl)) {
 		rets = -EFBIG;
 		goto out;
 	}
@@ -266,7 +275,6 @@ static ssize_t ___mei_cl_send(struct mei_cl *cl, u8 *buf, size_t length,
 	rets = mei_cl_write(cl, cb, blocking);
 
 out:
-	mei_me_cl_put(me_cl);
 	mutex_unlock(&dev->device_lock);
 	if (rets < 0)
 		mei_io_cb_free(cb);
@@ -442,7 +450,7 @@ int mei_cl_enable_device(struct mei_cl_device *device)
 		return -EBUSY;
 	}
 
-	err = mei_cl_connect(cl, NULL);
+	err = mei_cl_connect(cl, device->me_cl, NULL);
 	if (err < 0) {
 		mutex_unlock(&dev->device_lock);
 		dev_err(dev->dev, "Could not connect to the ME client");

commit 0c53357ca4b3a03aafc211de663e84dba7c628e2
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Mon May 4 09:43:53 2015 +0300

    mei: revamp client connection
    
    Simplify connect state machine by changing the logic around
    Connection request in progress - only check if we have a callback in
    relevant queue.
    Extract common code into mei_cl_send_connect() function
    
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Alexander Usyskin <alexander.usyskin@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 873c1b6e45e8..00b0cb2075fb 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -436,6 +436,12 @@ int mei_cl_enable_device(struct mei_cl_device *device)
 
 	mutex_lock(&dev->device_lock);
 
+	if (mei_cl_is_connected(cl)) {
+		mutex_unlock(&dev->device_lock);
+		dev_warn(dev->dev, "Already connected");
+		return -EBUSY;
+	}
+
 	err = mei_cl_connect(cl, NULL);
 	if (err < 0) {
 		mutex_unlock(&dev->device_lock);

commit 3c66618295ca5fb0fde32e60e5f26557a5fcad5e
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Mon May 4 09:43:52 2015 +0300

    mei: revamp client disconnection flow
    
    Split disconnected state into two parts first reception disconnect
    response from the firmware and second actually setting of disconnected
    state.  Book keeping data are needed for processing and after firmware
    disconnected the client and are cleaned when setting the disconnected
    state in mei_cl_set_disconneted() function.
    Add mei_cl_send_disconnect to reduce code duplication.
    
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Alexander Usyskin <alexander.usyskin@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 4cf38c39878a..873c1b6e45e8 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -480,8 +480,6 @@ int mei_cl_disable_device(struct mei_cl_device *device)
 		goto out;
 	}
 
-	cl->state = MEI_FILE_DISCONNECTING;
-
 	err = mei_cl_disconnect(cl);
 	if (err < 0) {
 		dev_err(dev->dev, "Could not disconnect from the ME client");

commit 6a84d63d22a0ac79ab422b69ef2b4d75002c5641
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Fri Mar 27 00:27:59 2015 +0200

    mei: replace check for connection instead of transitioning
    
    The function mei_cl_is_transitioning is just opposite
    of mei_cl_is_connected. What we actually wanted to
    check is if we lost connection so we can discard
    the check for transition and check for 'not connected'
    
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index b724a67696fc..4cf38c39878a 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -302,7 +302,7 @@ ssize_t __mei_cl_recv(struct mei_cl *cl, u8 *buf, size_t length)
 
 		if (wait_event_interruptible(cl->rx_wait,
 				(!list_empty(&cl->rd_completed)) ||
-				mei_cl_is_transitioning(cl))) {
+				(!mei_cl_is_connected(cl)))) {
 
 			if (signal_pending(current))
 				return -EINTR;
@@ -311,7 +311,7 @@ ssize_t __mei_cl_recv(struct mei_cl *cl, u8 *buf, size_t length)
 
 		mutex_lock(&dev->device_lock);
 
-		if (mei_cl_is_transitioning(cl)) {
+		if (!mei_cl_is_connected(cl)) {
 			rets = -EBUSY;
 			goto out;
 		}

commit f3de9b635d93a3d268adda428e1df94091506a42
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Fri Mar 27 00:27:58 2015 +0200

    mei: use mei_cl_is_connected consistently
    
    Replace open coded check for cl->state !=/== MEI_FILE_CONNECTED
    with mei_cl_is_connected function.
    
    Note that cl->state != MEI_FILE_CONNECTED is not the same
    as cl->state == MEI_FILE_DISCONNECTED
    
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 45896f95fed1..b724a67696fc 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -238,7 +238,7 @@ static ssize_t ___mei_cl_send(struct mei_cl *cl, u8 *buf, size_t length,
 	dev = cl->dev;
 
 	mutex_lock(&dev->device_lock);
-	if (cl->state != MEI_FILE_CONNECTED) {
+	if (!mei_cl_is_connected(cl)) {
 		rets = -ENODEV;
 		goto out;
 	}
@@ -474,7 +474,7 @@ int mei_cl_disable_device(struct mei_cl_device *device)
 
 	mutex_lock(&dev->device_lock);
 
-	if (cl->state != MEI_FILE_CONNECTED) {
+	if (!mei_cl_is_connected(cl)) {
 		dev_err(dev->dev, "Already disconnected");
 		err = 0;
 		goto out;

commit b3de8e3719e582f3182bb504295e4a8e43c8c96f
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Tue Feb 10 10:39:47 2015 +0200

    mei: bus: call device disable handler prior to disconnection
    
    call device's disable handler prior to disconnection
    so it can possibly close the communication with fw client
    in graceful way
    
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 17ca7e20fb6a..45896f95fed1 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -467,37 +467,34 @@ int mei_cl_disable_device(struct mei_cl_device *device)
 
 	dev = cl->dev;
 
+	if (device->ops && device->ops->disable)
+		device->ops->disable(device);
+
+	device->event_cb = NULL;
+
 	mutex_lock(&dev->device_lock);
 
 	if (cl->state != MEI_FILE_CONNECTED) {
-		mutex_unlock(&dev->device_lock);
 		dev_err(dev->dev, "Already disconnected");
-
-		return 0;
+		err = 0;
+		goto out;
 	}
 
 	cl->state = MEI_FILE_DISCONNECTING;
 
 	err = mei_cl_disconnect(cl);
 	if (err < 0) {
-		mutex_unlock(&dev->device_lock);
-		dev_err(dev->dev,
-			"Could not disconnect from the ME client");
-
-		return err;
+		dev_err(dev->dev, "Could not disconnect from the ME client");
+		goto out;
 	}
 
 	/* Flush queues and remove any pending read */
 	mei_cl_flush_queues(cl, NULL);
 
-	device->event_cb = NULL;
-
+out:
 	mutex_unlock(&dev->device_lock);
+	return err;
 
-	if (!device->ops || !device->ops->disable)
-		return 0;
-
-	return device->ops->disable(device);
 }
 EXPORT_SYMBOL_GPL(mei_cl_disable_device);
 

commit a9bed61053af13c0768f82c9d1c8793515dd067c
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Tue Feb 10 10:39:46 2015 +0200

    mei: allow read concurrency
    
    Replace clunky read state machine with read stack
    implemented as per client read list, this is important
    mostly for mei drivers with unsolicited reads
    
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index b5385372693d..17ca7e20fb6a 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -288,19 +288,20 @@ ssize_t __mei_cl_recv(struct mei_cl *cl, u8 *buf, size_t length)
 
 	mutex_lock(&dev->device_lock);
 
-	if (!cl->read_cb) {
-		rets = mei_cl_read_start(cl, length, NULL);
-		if (rets < 0)
-			goto out;
-	}
+	cb = mei_cl_read_cb(cl, NULL);
+	if (cb)
+		goto copy;
+
+	rets = mei_cl_read_start(cl, length, NULL);
+	if (rets && rets != -EBUSY)
+		goto out;
 
-	if (cl->reading_state != MEI_READ_COMPLETE &&
-	    !waitqueue_active(&cl->rx_wait)) {
+	if (list_empty(&cl->rd_completed) && !waitqueue_active(&cl->rx_wait)) {
 
 		mutex_unlock(&dev->device_lock);
 
 		if (wait_event_interruptible(cl->rx_wait,
-				cl->reading_state == MEI_READ_COMPLETE  ||
+				(!list_empty(&cl->rd_completed)) ||
 				mei_cl_is_transitioning(cl))) {
 
 			if (signal_pending(current))
@@ -309,15 +310,20 @@ ssize_t __mei_cl_recv(struct mei_cl *cl, u8 *buf, size_t length)
 		}
 
 		mutex_lock(&dev->device_lock);
-	}
 
+		if (mei_cl_is_transitioning(cl)) {
+			rets = -EBUSY;
+			goto out;
+		}
+	}
 
-	if (cl->reading_state != MEI_READ_COMPLETE) {
+	cb = mei_cl_read_cb(cl, NULL);
+	if (!cb) {
 		rets = 0;
 		goto out;
 	}
 
-	cb = cl->read_cb;
+copy:
 	if (cb->status) {
 		rets = cb->status;
 		goto free;
@@ -329,9 +335,6 @@ ssize_t __mei_cl_recv(struct mei_cl *cl, u8 *buf, size_t length)
 
 free:
 	mei_io_cb_free(cb);
-	cl->read_cb = NULL;
-	cl->reading_state = MEI_IDLE;
-
 out:
 	mutex_unlock(&dev->device_lock);
 
@@ -443,7 +446,7 @@ int mei_cl_enable_device(struct mei_cl_device *device)
 
 	mutex_unlock(&dev->device_lock);
 
-	if (device->event_cb && !cl->read_cb)
+	if (device->event_cb)
 		mei_cl_read_start(device->cl, 0, NULL);
 
 	if (!device->ops || !device->ops->enable)
@@ -485,8 +488,7 @@ int mei_cl_disable_device(struct mei_cl_device *device)
 	}
 
 	/* Flush queues and remove any pending read */
-	mei_cl_flush_queues(cl);
-	mei_io_cb_free(cl->read_cb);
+	mei_cl_flush_queues(cl, NULL);
 
 	device->event_cb = NULL;
 

commit 928fa6664b362aad70c16f04483414f60743e15e
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Tue Feb 10 10:39:45 2015 +0200

    mei: simplify io callback disposal
    
    Simplify disposal of io callback by removing the callback
    implicitly from its lookup list inside mei_io_cb_free
    
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 3e6ffed9402a..b5385372693d 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -311,13 +311,13 @@ ssize_t __mei_cl_recv(struct mei_cl *cl, u8 *buf, size_t length)
 		mutex_lock(&dev->device_lock);
 	}
 
-	cb = cl->read_cb;
 
 	if (cl->reading_state != MEI_READ_COMPLETE) {
 		rets = 0;
 		goto out;
 	}
 
+	cb = cl->read_cb;
 	if (cb->status) {
 		rets = cb->status;
 		goto free;
@@ -329,8 +329,8 @@ ssize_t __mei_cl_recv(struct mei_cl *cl, u8 *buf, size_t length)
 
 free:
 	mei_io_cb_free(cb);
-	cl->reading_state = MEI_IDLE;
 	cl->read_cb = NULL;
+	cl->reading_state = MEI_IDLE;
 
 out:
 	mutex_unlock(&dev->device_lock);
@@ -486,23 +486,7 @@ int mei_cl_disable_device(struct mei_cl_device *device)
 
 	/* Flush queues and remove any pending read */
 	mei_cl_flush_queues(cl);
-
-	if (cl->read_cb) {
-		struct mei_cl_cb *cb = NULL;
-
-		cb = mei_cl_find_read_cb(cl);
-		/* Remove entry from read list */
-		if (cb)
-			list_del(&cb->list);
-
-		cb = cl->read_cb;
-		cl->read_cb = NULL;
-
-		if (cb) {
-			mei_io_cb_free(cb);
-			cb = NULL;
-		}
-	}
+	mei_io_cb_free(cl->read_cb);
 
 	device->event_cb = NULL;
 

commit bca67d681c4864b74fa5fae9ee47e562d1e272b1
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Tue Feb 10 10:39:43 2015 +0200

    mei: always initialize the callback with the intended operation type
    
    We set the operation type at initialization time as each cb is used only
    for a single type of operation
    
    As a byproduct we add a convenient wrapper for allocating cb with
    the data buffer.
    
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 36b949a0fddb..3e6ffed9402a 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -255,16 +255,12 @@ static ssize_t ___mei_cl_send(struct mei_cl *cl, u8 *buf, size_t length,
 		goto out;
 	}
 
-	cb = mei_io_cb_init(cl, NULL);
+	cb = mei_cl_alloc_cb(cl, length, MEI_FOP_WRITE, NULL);
 	if (!cb) {
 		rets = -ENOMEM;
 		goto out;
 	}
 
-	rets = mei_io_cb_alloc_buf(cb, length);
-	if (rets < 0)
-		goto out;
-
 	memcpy(cb->buf.data, buf, length);
 
 	rets = mei_cl_write(cl, cb, blocking);
@@ -293,7 +289,7 @@ ssize_t __mei_cl_recv(struct mei_cl *cl, u8 *buf, size_t length)
 	mutex_lock(&dev->device_lock);
 
 	if (!cl->read_cb) {
-		rets = mei_cl_read_start(cl, length);
+		rets = mei_cl_read_start(cl, length, NULL);
 		if (rets < 0)
 			goto out;
 	}
@@ -392,7 +388,7 @@ static void mei_bus_event_work(struct work_struct *work)
 	device->events = 0;
 
 	/* Prepare for the next read */
-	mei_cl_read_start(device->cl, 0);
+	mei_cl_read_start(device->cl, 0, NULL);
 }
 
 int mei_cl_register_event_cb(struct mei_cl_device *device,
@@ -406,7 +402,7 @@ int mei_cl_register_event_cb(struct mei_cl_device *device,
 	device->event_context = context;
 	INIT_WORK(&device->event_work, mei_bus_event_work);
 
-	mei_cl_read_start(device->cl, 0);
+	mei_cl_read_start(device->cl, 0, NULL);
 
 	return 0;
 }
@@ -448,7 +444,7 @@ int mei_cl_enable_device(struct mei_cl_device *device)
 	mutex_unlock(&dev->device_lock);
 
 	if (device->event_cb && !cl->read_cb)
-		mei_cl_read_start(device->cl, 0);
+		mei_cl_read_start(device->cl, 0, NULL);
 
 	if (!device->ops || !device->ops->enable)
 		return 0;

commit 5db7514d9333c920791538c850cfb9dbd19025f7
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Tue Feb 10 10:39:42 2015 +0200

    mei: use only one buffer in callback
    
    The callback structure is used exclusively for reading or writing
    therefore there is no reason to hold both response and request buffers
    in the callback structure
    
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 025626f4467d..36b949a0fddb 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -261,11 +261,11 @@ static ssize_t ___mei_cl_send(struct mei_cl *cl, u8 *buf, size_t length,
 		goto out;
 	}
 
-	rets = mei_io_cb_alloc_req_buf(cb, length);
+	rets = mei_io_cb_alloc_buf(cb, length);
 	if (rets < 0)
 		goto out;
 
-	memcpy(cb->request_buffer.data, buf, length);
+	memcpy(cb->buf.data, buf, length);
 
 	rets = mei_cl_write(cl, cb, blocking);
 
@@ -328,7 +328,7 @@ ssize_t __mei_cl_recv(struct mei_cl *cl, u8 *buf, size_t length)
 	}
 
 	r_length = min_t(size_t, length, cb->buf_idx);
-	memcpy(buf, cb->response_buffer.data, r_length);
+	memcpy(buf, cb->buf.data, r_length);
 	rets = r_length;
 
 free:

commit 3d33ff2457355a9dd3c3178b04ab6669882b306c
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Tue Feb 10 10:39:36 2015 +0200

    mei: fix device reset on mei_cl_irq_read_msg allocation failure
    
    On memory allocation failure mei_cl_irq_read_msg will
    return with error that will cause device reset.
    Instead we should propagate error to caller and
    just clean the read queues.
    
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index be767f4db26a..025626f4467d 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -322,10 +322,16 @@ ssize_t __mei_cl_recv(struct mei_cl *cl, u8 *buf, size_t length)
 		goto out;
 	}
 
+	if (cb->status) {
+		rets = cb->status;
+		goto free;
+	}
+
 	r_length = min_t(size_t, length, cb->buf_idx);
 	memcpy(buf, cb->response_buffer.data, r_length);
 	rets = r_length;
 
+free:
 	mei_io_cb_free(cb);
 	cl->reading_state = MEI_IDLE;
 	cl->read_cb = NULL;

commit 79563db9ddd37908343103debf20da716ccc5ce4
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Sun Jan 11 00:07:16 2015 +0200

    mei: add reference counting for me clients
    
    To support dynamic addition and removal of
    me clients we add reference counter.
    
    Update kdoc with locking requirements.
    
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 31164dd14bd0..be767f4db26a 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -228,8 +228,8 @@ static ssize_t ___mei_cl_send(struct mei_cl *cl, u8 *buf, size_t length,
 			bool blocking)
 {
 	struct mei_device *dev;
-	struct mei_me_client *me_cl;
-	struct mei_cl_cb *cb;
+	struct mei_me_client *me_cl = NULL;
+	struct mei_cl_cb *cb = NULL;
 	ssize_t rets;
 
 	if (WARN_ON(!cl || !cl->dev))
@@ -237,33 +237,40 @@ static ssize_t ___mei_cl_send(struct mei_cl *cl, u8 *buf, size_t length,
 
 	dev = cl->dev;
 
-	if (cl->state != MEI_FILE_CONNECTED)
-		return -ENODEV;
+	mutex_lock(&dev->device_lock);
+	if (cl->state != MEI_FILE_CONNECTED) {
+		rets = -ENODEV;
+		goto out;
+	}
 
 	/* Check if we have an ME client device */
 	me_cl = mei_me_cl_by_uuid_id(dev, &cl->cl_uuid, cl->me_client_id);
-	if (!me_cl)
-		return -ENOTTY;
+	if (!me_cl) {
+		rets = -ENOTTY;
+		goto out;
+	}
 
-	if (length > me_cl->props.max_msg_length)
-		return -EFBIG;
+	if (length > me_cl->props.max_msg_length) {
+		rets = -EFBIG;
+		goto out;
+	}
 
 	cb = mei_io_cb_init(cl, NULL);
-	if (!cb)
-		return -ENOMEM;
+	if (!cb) {
+		rets = -ENOMEM;
+		goto out;
+	}
 
 	rets = mei_io_cb_alloc_req_buf(cb, length);
-	if (rets < 0) {
-		mei_io_cb_free(cb);
-		return rets;
-	}
+	if (rets < 0)
+		goto out;
 
 	memcpy(cb->request_buffer.data, buf, length);
 
-	mutex_lock(&dev->device_lock);
-
 	rets = mei_cl_write(cl, cb, blocking);
 
+out:
+	mei_me_cl_put(me_cl);
 	mutex_unlock(&dev->device_lock);
 	if (rets < 0)
 		mei_io_cb_free(cb);

commit 39db74ce1aa83626a0a70ed2abf29a17598fff49
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Thu Nov 27 14:07:28 2014 +0200

    mei: bus: use ssize_t as the return type for send and receive
    
    Mei bus receive and send function may return either number
    of transmitted bytes or errno.  It is better to use ssize_t
    type for that purpose that mixing size_t with int.
    
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index b3a72bca5242..31164dd14bd0 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -224,13 +224,13 @@ void mei_cl_driver_unregister(struct mei_cl_driver *driver)
 }
 EXPORT_SYMBOL_GPL(mei_cl_driver_unregister);
 
-static int ___mei_cl_send(struct mei_cl *cl, u8 *buf, size_t length,
+static ssize_t ___mei_cl_send(struct mei_cl *cl, u8 *buf, size_t length,
 			bool blocking)
 {
 	struct mei_device *dev;
 	struct mei_me_client *me_cl;
 	struct mei_cl_cb *cb;
-	int rets;
+	ssize_t rets;
 
 	if (WARN_ON(!cl || !cl->dev))
 		return -ENODEV;
@@ -271,12 +271,12 @@ static int ___mei_cl_send(struct mei_cl *cl, u8 *buf, size_t length,
 	return rets;
 }
 
-int __mei_cl_recv(struct mei_cl *cl, u8 *buf, size_t length)
+ssize_t __mei_cl_recv(struct mei_cl *cl, u8 *buf, size_t length)
 {
 	struct mei_device *dev;
 	struct mei_cl_cb *cb;
 	size_t r_length;
-	int err;
+	ssize_t rets;
 
 	if (WARN_ON(!cl || !cl->dev))
 		return -ENODEV;
@@ -286,11 +286,9 @@ int __mei_cl_recv(struct mei_cl *cl, u8 *buf, size_t length)
 	mutex_lock(&dev->device_lock);
 
 	if (!cl->read_cb) {
-		err = mei_cl_read_start(cl, length);
-		if (err < 0) {
-			mutex_unlock(&dev->device_lock);
-			return err;
-		}
+		rets = mei_cl_read_start(cl, length);
+		if (rets < 0)
+			goto out;
 	}
 
 	if (cl->reading_state != MEI_READ_COMPLETE &&
@@ -313,13 +311,13 @@ int __mei_cl_recv(struct mei_cl *cl, u8 *buf, size_t length)
 	cb = cl->read_cb;
 
 	if (cl->reading_state != MEI_READ_COMPLETE) {
-		r_length = 0;
+		rets = 0;
 		goto out;
 	}
 
 	r_length = min_t(size_t, length, cb->buf_idx);
-
 	memcpy(buf, cb->response_buffer.data, r_length);
+	rets = r_length;
 
 	mei_io_cb_free(cb);
 	cl->reading_state = MEI_IDLE;
@@ -328,20 +326,20 @@ int __mei_cl_recv(struct mei_cl *cl, u8 *buf, size_t length)
 out:
 	mutex_unlock(&dev->device_lock);
 
-	return r_length;
+	return rets;
 }
 
-inline int __mei_cl_async_send(struct mei_cl *cl, u8 *buf, size_t length)
+inline ssize_t __mei_cl_async_send(struct mei_cl *cl, u8 *buf, size_t length)
 {
 	return ___mei_cl_send(cl, buf, length, 0);
 }
 
-inline int __mei_cl_send(struct mei_cl *cl, u8 *buf, size_t length)
+inline ssize_t __mei_cl_send(struct mei_cl *cl, u8 *buf, size_t length)
 {
 	return ___mei_cl_send(cl, buf, length, 1);
 }
 
-int mei_cl_send(struct mei_cl_device *device, u8 *buf, size_t length)
+ssize_t mei_cl_send(struct mei_cl_device *device, u8 *buf, size_t length)
 {
 	struct mei_cl *cl = device->cl;
 
@@ -355,7 +353,7 @@ int mei_cl_send(struct mei_cl_device *device, u8 *buf, size_t length)
 }
 EXPORT_SYMBOL_GPL(mei_cl_send);
 
-int mei_cl_recv(struct mei_cl_device *device, u8 *buf, size_t length)
+ssize_t mei_cl_recv(struct mei_cl_device *device, u8 *buf, size_t length)
 {
 	struct mei_cl *cl =  device->cl;
 

commit a176c24dc9a82b3304a31233bfc37e97c42de09b
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Wed Nov 5 18:18:52 2014 +0200

    mei: nfc: clean nfc internal struct on host exit
    
    NFC internal structure cleaning was dropped by commit
    
    commit 487056932d372cc4f6c636f21a928d6667b151d7
    Author: Tomas Winkler <tomas.winkler@intel.com>
    Date:   Mon Feb 17 15:13:19 2014 +0200
    
        mei: Remove all bus devices from the mei_dev list when stopping the MEI
    
        When stopping the MEI, we should remove and potentially unregister
        all bus devices queued on the mei_dev linked list.
    
    We allocate nfc_dev and free it across the reset
    so we do not keep it in dirty state
    
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Alexander Usyskin <alexander.usyskin@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 4d20d60ca38d..b3a72bca5242 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -140,7 +140,7 @@ static struct device_type mei_cl_device_type = {
 	.release	= mei_cl_dev_release,
 };
 
-static struct mei_cl *mei_bus_find_mei_cl_by_uuid(struct mei_device *dev,
+struct mei_cl *mei_cl_bus_find_cl_by_uuid(struct mei_device *dev,
 						uuid_le uuid)
 {
 	struct mei_cl *cl;
@@ -160,7 +160,7 @@ struct mei_cl_device *mei_cl_add_device(struct mei_device *dev,
 	struct mei_cl *cl;
 	int status;
 
-	cl = mei_bus_find_mei_cl_by_uuid(dev, uuid);
+	cl = mei_cl_bus_find_cl_by_uuid(dev, uuid);
 	if (cl == NULL)
 		return NULL;
 

commit 1f180359f42fc6fda4600175c63f2a84f444cc92
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Mon Sep 29 16:31:46 2014 +0300

    mei: remove include to pci header from mei module files
    
    Remove inclusion of linux/pci.h in mei layer
    however we need to include the headers that before
    got included implicitly from linux/pci.h.
    
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 4cc1a66187be..4d20d60ca38d 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -22,7 +22,6 @@
 #include <linux/slab.h>
 #include <linux/mutex.h>
 #include <linux/interrupt.h>
-#include <linux/pci.h>
 #include <linux/mei_cl_bus.h>
 
 #include "mei_dev.h"

commit 2bf94cabb199f73402a5ddefa4a7bf1a82aaeda5
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Mon Sep 29 16:31:42 2014 +0300

    mei: get rid of most of the pci dependencies in mei
    
    For purpose of adding testing HW we would like
    to get rid of pci dependency in generic mei code
    This patch provides only straight forward changes
    FW status and prob quirks need to be handled separately
    
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 1cf3a72f2954..4cc1a66187be 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -172,7 +172,7 @@ struct mei_cl_device *mei_cl_add_device(struct mei_device *dev,
 	device->cl = cl;
 	device->ops = ops;
 
-	device->dev.parent = &dev->pdev->dev;
+	device->dev.parent = dev->dev;
 	device->dev.bus = &mei_cl_bus_type;
 	device->dev.type = &mei_cl_device_type;
 
@@ -180,7 +180,7 @@ struct mei_cl_device *mei_cl_add_device(struct mei_device *dev,
 
 	status = device_register(&device->dev);
 	if (status) {
-		dev_err(&dev->pdev->dev, "Failed to register MEI device\n");
+		dev_err(dev->dev, "Failed to register MEI device\n");
 		kfree(device);
 		return NULL;
 	}
@@ -430,7 +430,7 @@ int mei_cl_enable_device(struct mei_cl_device *device)
 	err = mei_cl_connect(cl, NULL);
 	if (err < 0) {
 		mutex_unlock(&dev->device_lock);
-		dev_err(&dev->pdev->dev, "Could not connect to the ME client");
+		dev_err(dev->dev, "Could not connect to the ME client");
 
 		return err;
 	}
@@ -462,7 +462,7 @@ int mei_cl_disable_device(struct mei_cl_device *device)
 
 	if (cl->state != MEI_FILE_CONNECTED) {
 		mutex_unlock(&dev->device_lock);
-		dev_err(&dev->pdev->dev, "Already disconnected");
+		dev_err(dev->dev, "Already disconnected");
 
 		return 0;
 	}
@@ -472,7 +472,7 @@ int mei_cl_disable_device(struct mei_cl_device *device)
 	err = mei_cl_disconnect(cl);
 	if (err < 0) {
 		mutex_unlock(&dev->device_lock);
-		dev_err(&dev->pdev->dev,
+		dev_err(dev->dev,
 			"Could not disconnect from the ME client");
 
 		return err;

commit cfda2794b5afe7ce64ee9605c64bef0e56a48125
Author: Alexander Usyskin <alexander.usyskin@intel.com>
Date:   Mon Aug 25 16:46:53 2014 +0300

    mei: bus: fix possible boundaries violation
    
    function 'strncpy' will fill whole buffer 'id.name' of fixed size (32)
    with string value and will not leave place for NULL-terminator.
    Possible buffer boundaries violation in following string operations.
    Replace strncpy with strlcpy.
    
    Cc: stable@vger.kernel.org # 3.10+
    Signed-off-by: Alexander Usyskin <alexander.usyskin@intel.com>
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 09dad2df7aae..1cf3a72f2954 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -70,7 +70,7 @@ static int mei_cl_device_probe(struct device *dev)
 
 	dev_dbg(dev, "Device probe\n");
 
-	strncpy(id.name, dev_name(dev), sizeof(id.name));
+	strlcpy(id.name, dev_name(dev), sizeof(id.name));
 
 	return driver->probe(device, &id);
 }

commit d880f3294d0576e79dfab4e2cd5a2eb62fe188f0
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Thu Aug 21 14:29:15 2014 +0300

    mei: add mei_me_cl_by_uuid_id function
    
    When handling dynamic clients there might be a race
    scenario in which two me clients with the same me
    address would be linked in the me clients list,
    therefore we need to search by both uuid and me address.
    
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index c829676c4716..09dad2df7aae 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -147,7 +147,7 @@ static struct mei_cl *mei_bus_find_mei_cl_by_uuid(struct mei_device *dev,
 	struct mei_cl *cl;
 
 	list_for_each_entry(cl, &dev->device_list, device_link) {
-		if (!uuid_le_cmp(uuid, cl->device_uuid))
+		if (!uuid_le_cmp(uuid, cl->cl_uuid))
 			return cl;
 	}
 
@@ -242,7 +242,7 @@ static int ___mei_cl_send(struct mei_cl *cl, u8 *buf, size_t length,
 		return -ENODEV;
 
 	/* Check if we have an ME client device */
-	me_cl = mei_me_cl_by_id(dev, cl->me_client_id);
+	me_cl = mei_me_cl_by_uuid_id(dev, &cl->cl_uuid, cl->me_client_id);
 	if (!me_cl)
 		return -ENOTTY;
 

commit d320832f64666089a06778782e42fac29abd7bf7
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Sun Aug 24 12:08:55 2014 +0300

    mei: me_client lookup function to return me_client object
    
    For support of dynamic addition and removal of me clients
    it is more convenient to use a list instead of static array
    as is use now.
    As the first step of the transition to the new data structure
    we change the lookup function so it returns me client address
    instead of an index.
    
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 0e993ef28b94..c829676c4716 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -229,8 +229,8 @@ static int ___mei_cl_send(struct mei_cl *cl, u8 *buf, size_t length,
 			bool blocking)
 {
 	struct mei_device *dev;
+	struct mei_me_client *me_cl;
 	struct mei_cl_cb *cb;
-	int id;
 	int rets;
 
 	if (WARN_ON(!cl || !cl->dev))
@@ -242,11 +242,11 @@ static int ___mei_cl_send(struct mei_cl *cl, u8 *buf, size_t length,
 		return -ENODEV;
 
 	/* Check if we have an ME client device */
-	id = mei_me_cl_by_id(dev, cl->me_client_id);
-	if (id < 0)
-		return id;
+	me_cl = mei_me_cl_by_id(dev, cl->me_client_id);
+	if (!me_cl)
+		return -ENOTTY;
 
-	if (length > dev->me_clients[id].props.max_msg_length)
+	if (length > me_cl->props.max_msg_length)
 		return -EFBIG;
 
 	cb = mei_io_cb_init(cl, NULL);

commit e4d8270e604c3202131bac607969605ac397b893
Author: Alexander Usyskin <alexander.usyskin@intel.com>
Date:   Sun Apr 27 15:42:21 2014 +0300

    mei: set connecting state just upon connection request is sent to the fw
    
    Adding power gating introduced new waiting state for client also during
    connection attempt, a connection request can be queued for later either due
    device is power gated or due to other on going connection.
    We setting client connection state before start of full connect procedure so
    in both cased the client state will be MEI_FILE_CONNECTING
    which create interlock between the two connection attempts, both
    detecting that another connection is in progress.
    
    The interlock is resolved by moving client to connecting state
    only upon connection request transmission, so the  first
    cb in queue can be processed.
    
    Signed-off-by: Alexander Usyskin <alexander.usyskin@intel.com>
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index d5b9ed4452ef..0e993ef28b94 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -427,8 +427,6 @@ int mei_cl_enable_device(struct mei_cl_device *device)
 
 	mutex_lock(&dev->device_lock);
 
-	cl->state = MEI_FILE_CONNECTING;
-
 	err = mei_cl_connect(cl, NULL);
 	if (err < 0) {
 		mutex_unlock(&dev->device_lock);

commit 86113500c060bccb0f08bdcadcecc0bd267fd25a
Author: Alexander Usyskin <alexander.usyskin@intel.com>
Date:   Mon Mar 31 17:59:24 2014 +0300

    mei: make return values consistent across the driver
    
    Follow-up for bits missed in
    commit 7ca96aa278f8b9983184e318b06a0ed9ad0297b8
    mei: make return values consistent across the driver
    
    Signed-off-by: Alexander Usyskin <alexander.usyskin@intel.com>
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index ddc5ac92a200..d5b9ed4452ef 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -247,7 +247,7 @@ static int ___mei_cl_send(struct mei_cl *cl, u8 *buf, size_t length,
 		return id;
 
 	if (length > dev->me_clients[id].props.max_msg_length)
-		return -EINVAL;
+		return -EFBIG;
 
 	cb = mei_io_cb_init(cl, NULL);
 	if (!cb)

commit 6e4cd27a35622cddbe6c0d6fbeb9da8c232029d1
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Tue Mar 11 14:49:23 2014 +0200

    mei: make me hw headers private to me hw.
    
    Remove includes of me-hw.h and me-hw-regs.h headers from
    the mei generic code.
    The mei layer should not depend on hw specific headers
    
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 463ae51fb708..ddc5ac92a200 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -26,7 +26,6 @@
 #include <linux/mei_cl_bus.h>
 
 #include "mei_dev.h"
-#include "hw-me.h"
 #include "client.h"
 
 #define to_mei_cl_driver(d) container_of(d, struct mei_cl_driver, driver)

commit 31f88f5739e966cb3c524083e2d19b423ece3585
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Mon Feb 17 15:13:25 2014 +0200

    mei: don't of list_for_each_entry_safe when not deleting
    
    We can use simply list_for_each_entry if there is no
    entry removal
    
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index cf4cc0bf2b17..463ae51fb708 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -145,9 +145,9 @@ static struct device_type mei_cl_device_type = {
 static struct mei_cl *mei_bus_find_mei_cl_by_uuid(struct mei_device *dev,
 						uuid_le uuid)
 {
-	struct mei_cl *cl, *next;
+	struct mei_cl *cl;
 
-	list_for_each_entry_safe(cl, next, &dev->device_list, device_link) {
+	list_for_each_entry(cl, &dev->device_list, device_link) {
 		if (!uuid_le_cmp(uuid, cl->device_uuid))
 			return cl;
 	}

commit 487056932d372cc4f6c636f21a928d6667b151d7
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Mon Feb 17 15:13:19 2014 +0200

    mei: Remove all bus devices from the mei_dev list when stopping the MEI
    
    When stopping the MEI, we should remove and potentially unregister
    all bus devices queued on the mei_dev linked list.
    
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 4bc7d620d695..cf4cc0bf2b17 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -524,6 +524,22 @@ void mei_cl_bus_rx_event(struct mei_cl *cl)
 	schedule_work(&device->event_work);
 }
 
+void mei_cl_bus_remove_devices(struct mei_device *dev)
+{
+	struct mei_cl *cl, *next;
+
+	mutex_lock(&dev->device_lock);
+	list_for_each_entry_safe(cl, next, &dev->device_list, device_link) {
+		if (cl->device)
+			mei_cl_remove_device(cl->device);
+
+		list_del(&cl->device_link);
+		mei_cl_unlink(cl);
+		kfree(cl);
+	}
+	mutex_unlock(&dev->device_lock);
+}
+
 int __init mei_cl_bus_init(void)
 {
 	return bus_register(&mei_cl_bus_type);

commit f9350129a09d8f55ba9322fa4327aeb499a91bbd
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Mon Oct 21 22:05:40 2013 +0300

    mei: bus: propagate error code returned by mei_me_cl_by_id
    
    no need to change error code value returned by
    mei_me_cl_by_id, just propagate it on
    
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index cd2033cd7120..4bc7d620d695 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -245,7 +245,7 @@ static int ___mei_cl_send(struct mei_cl *cl, u8 *buf, size_t length,
 	/* Check if we have an ME client device */
 	id = mei_me_cl_by_id(dev, cl->me_client_id);
 	if (id < 0)
-		return -ENODEV;
+		return id;
 
 	if (length > dev->me_clients[id].props.max_msg_length)
 		return -EINVAL;

commit e2b31644e999e8bfe3efce880fb32840299abf41
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Mon Sep 2 13:29:46 2013 +0300

    mei: bus: stop wait for read during cl state transition
    
    Bus layer omitted check for client state transition while waiting
    for read completion
    The client state transition may occur for example as result
    of firmware initiated reset
    
    Add mei_cl_is_transitioning wrapper to reduce the code
    repetition.:
    
    Cc:  <stable@vger.kernel.org> # 3.9+
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 6d0282c08a06..cd2033cd7120 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -297,10 +297,13 @@ int __mei_cl_recv(struct mei_cl *cl, u8 *buf, size_t length)
 
 	if (cl->reading_state != MEI_READ_COMPLETE &&
 	    !waitqueue_active(&cl->rx_wait)) {
+
 		mutex_unlock(&dev->device_lock);
 
 		if (wait_event_interruptible(cl->rx_wait,
-				(MEI_READ_COMPLETE == cl->reading_state))) {
+				cl->reading_state == MEI_READ_COMPLETE  ||
+				mei_cl_is_transitioning(cl))) {
+
 			if (signal_pending(current))
 				return -EINTR;
 			return -ERESTARTSYS;

commit 542a086ac72fb193cbc1b996963a572269e57743
Merge: 1d1fdd95df68 1eeeef153c02
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Sep 3 11:37:15 2013 -0700

    Merge tag 'driver-core-3.12-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core
    
    Pull driver core patches from Greg KH:
     "Here's the big driver core pull request for 3.12-rc1.
    
      Lots of tiny changes here fixing up the way sysfs attributes are
      created, to try to make drivers simpler, and fix a whole class race
      conditions with creations of device attributes after the device was
      announced to userspace.
    
      All the various pieces are acked by the different subsystem
      maintainers"
    
    * tag 'driver-core-3.12-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core: (119 commits)
      firmware loader: fix pending_fw_head list corruption
      drivers/base/memory.c: introduce help macro to_memory_block
      dynamic debug: line queries failing due to uninitialized local variable
      sysfs: sysfs_create_groups returns a value.
      debugfs: provide debugfs_create_x64() when disabled
      rbd: convert bus code to use bus_groups
      firmware: dcdbas: use binary attribute groups
      sysfs: add sysfs_create/remove_groups for when SYSFS is not enabled
      driver core: add #include <linux/sysfs.h> to core files.
      HID: convert bus code to use dev_groups
      Input: serio: convert bus code to use drv_groups
      Input: gameport: convert bus code to use drv_groups
      driver core: firmware: use __ATTR_RW()
      driver core: core: use DEVICE_ATTR_RO
      driver core: bus: use DRIVER_ATTR_WO()
      driver core: create write-only attribute macros for devices and drivers
      sysfs: create __ATTR_WO()
      driver-core: platform: convert bus code to use dev_groups
      workqueue: convert bus code to use dev_groups
      MEI: convert bus code to use dev_groups
      ...

commit 32f389ec5689751bae758c9b3e3982b2acb696c1
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Aug 23 14:24:39 2013 -0700

    MEI: convert bus code to use dev_groups
    
    The dev_attrs field of struct bus_type is going away soon, dev_groups
    should be used instead.  This converts the MEI bus code to use
    the correct field.
    
    Acked-by: Tomas Winkler <tomas.winkler@intel.com>
    Cc: Samuel Ortiz <sameo@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 9ecd49a7be1b..2ce92a6a9b54 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -108,11 +108,13 @@ static ssize_t modalias_show(struct device *dev, struct device_attribute *a,
 
 	return (len >= PAGE_SIZE) ? (PAGE_SIZE - 1) : len;
 }
+static DEVICE_ATTR_RO(modalias);
 
-static struct device_attribute mei_cl_dev_attrs[] = {
-	__ATTR_RO(modalias),
-	__ATTR_NULL,
+static struct attribute *mei_cl_dev_attrs[] = {
+	&dev_attr_modalias.attr,
+	NULL,
 };
+ATTRIBUTE_GROUPS(mei_cl_dev);
 
 static int mei_cl_uevent(struct device *dev, struct kobj_uevent_env *env)
 {
@@ -124,7 +126,7 @@ static int mei_cl_uevent(struct device *dev, struct kobj_uevent_env *env)
 
 static struct bus_type mei_cl_bus_type = {
 	.name		= "mei",
-	.dev_attrs	= mei_cl_dev_attrs,
+	.dev_groups	= mei_cl_dev_groups,
 	.match		= mei_cl_device_match,
 	.probe		= mei_cl_device_probe,
 	.remove		= mei_cl_device_remove,

commit 8b613bb86a3d4a106c9a8f6de3d8a4c3628ea998
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Wed Jul 24 16:22:59 2013 +0300

    mei: bus: do not overflow the device name buffer
    
    1. use strncmp for comparsion strncpy was used for copying
    which may omit the final %NUL terminator
    2. id->name is statically defined so we can use sizeof
    
    Acked-by: Samuel Ortiz <sameo@linux.intel.com>
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 9ecd49a7be1b..a150a42ed4af 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -47,7 +47,7 @@ static int mei_cl_device_match(struct device *dev, struct device_driver *drv)
 	id = driver->id_table;
 
 	while (id->name[0]) {
-		if (!strcmp(dev_name(dev), id->name))
+		if (!strncmp(dev_name(dev), id->name, sizeof(id->name)))
 			return 1;
 
 		id++;
@@ -71,7 +71,7 @@ static int mei_cl_device_probe(struct device *dev)
 
 	dev_dbg(dev, "Device probe\n");
 
-	strncpy(id.name, dev_name(dev), MEI_CL_NAME_SIZE);
+	strncpy(id.name, dev_name(dev), sizeof(id.name));
 
 	return driver->probe(device, &id);
 }

commit bbedf2fc207bbd89c109123caee7cf0497030762
Author: Samuel Ortiz <sameo@linux.intel.com>
Date:   Tue May 21 18:52:09 2013 +0200

    mei: bus: Reset event_cb when disabling a device
    
    After cancelling all reads from the disable hook, we need to reset the
    event_cb pointer as well or else we won't be able to set a new one up
    when re-enabling the device.
    
    Acked-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 1e935eacaa7f..9ecd49a7be1b 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -496,6 +496,8 @@ int mei_cl_disable_device(struct mei_cl_device *device)
 		}
 	}
 
+	device->event_cb = NULL;
+
 	mutex_unlock(&dev->device_lock);
 
 	if (!device->ops || !device->ops->disable)

commit fcb136e1ac5774909e0d85189f721b8dfa800e0f
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Fri Apr 19 22:01:35 2013 +0300

    mei: fix reading large reposnes
    
    While writting to device is limitted to max_msg_length advertized
    in client properites the read can be much longer delivered consequiting chunks.
    
    We use krealloc to enlarge the buffer when needed.
    
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 834ceeb69cbf..1e935eacaa7f 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -286,7 +286,7 @@ int __mei_cl_recv(struct mei_cl *cl, u8 *buf, size_t length)
 	mutex_lock(&dev->device_lock);
 
 	if (!cl->read_cb) {
-		err = mei_cl_read_start(cl);
+		err = mei_cl_read_start(cl, length);
 		if (err < 0) {
 			mutex_unlock(&dev->device_lock);
 			return err;
@@ -378,7 +378,7 @@ static void mei_bus_event_work(struct work_struct *work)
 	device->events = 0;
 
 	/* Prepare for the next read */
-	mei_cl_read_start(device->cl);
+	mei_cl_read_start(device->cl, 0);
 }
 
 int mei_cl_register_event_cb(struct mei_cl_device *device,
@@ -392,7 +392,7 @@ int mei_cl_register_event_cb(struct mei_cl_device *device,
 	device->event_context = context;
 	INIT_WORK(&device->event_work, mei_bus_event_work);
 
-	mei_cl_read_start(device->cl);
+	mei_cl_read_start(device->cl, 0);
 
 	return 0;
 }
@@ -436,7 +436,7 @@ int mei_cl_enable_device(struct mei_cl_device *device)
 	mutex_unlock(&dev->device_lock);
 
 	if (device->event_cb && !cl->read_cb)
-		mei_cl_read_start(device->cl);
+		mei_cl_read_start(device->cl, 0);
 
 	if (!device->ops || !device->ops->enable)
 		return 0;

commit e46980a10a76ec3282dd6832c1974b880acd23d3
Author: Samuel Ortiz <sameo@linux.intel.com>
Date:   Tue Apr 9 01:51:38 2013 +0300

    mei: bus: Add device enabling and disabling API
    
    It should be left to the drivers to enable and disable the device on the
    MEI bus when e.g getting probed.
    For drivers to be able to safely call the enable and disable hooks, the
    mei_cl_ops must be set before it's probed and thus this should happen
    before registering the device on the MEI bus. Hence the mei_cl_add_device()
    prototype change.
    
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 6badfa1110e9..834ceeb69cbf 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -153,7 +153,8 @@ static struct mei_cl *mei_bus_find_mei_cl_by_uuid(struct mei_device *dev,
 	return NULL;
 }
 struct mei_cl_device *mei_cl_add_device(struct mei_device *dev,
-				  uuid_le uuid, char *name)
+					uuid_le uuid, char *name,
+					struct mei_cl_ops *ops)
 {
 	struct mei_cl_device *device;
 	struct mei_cl *cl;
@@ -168,6 +169,7 @@ struct mei_cl_device *mei_cl_add_device(struct mei_device *dev,
 		return NULL;
 
 	device->cl = cl;
+	device->ops = ops;
 
 	device->dev.parent = &dev->pdev->dev;
 	device->dev.bus = &mei_cl_bus_type;
@@ -408,6 +410,101 @@ void mei_cl_set_drvdata(struct mei_cl_device *device, void *data)
 }
 EXPORT_SYMBOL_GPL(mei_cl_set_drvdata);
 
+int mei_cl_enable_device(struct mei_cl_device *device)
+{
+	int err;
+	struct mei_device *dev;
+	struct mei_cl *cl = device->cl;
+
+	if (cl == NULL)
+		return -ENODEV;
+
+	dev = cl->dev;
+
+	mutex_lock(&dev->device_lock);
+
+	cl->state = MEI_FILE_CONNECTING;
+
+	err = mei_cl_connect(cl, NULL);
+	if (err < 0) {
+		mutex_unlock(&dev->device_lock);
+		dev_err(&dev->pdev->dev, "Could not connect to the ME client");
+
+		return err;
+	}
+
+	mutex_unlock(&dev->device_lock);
+
+	if (device->event_cb && !cl->read_cb)
+		mei_cl_read_start(device->cl);
+
+	if (!device->ops || !device->ops->enable)
+		return 0;
+
+	return device->ops->enable(device);
+}
+EXPORT_SYMBOL_GPL(mei_cl_enable_device);
+
+int mei_cl_disable_device(struct mei_cl_device *device)
+{
+	int err;
+	struct mei_device *dev;
+	struct mei_cl *cl = device->cl;
+
+	if (cl == NULL)
+		return -ENODEV;
+
+	dev = cl->dev;
+
+	mutex_lock(&dev->device_lock);
+
+	if (cl->state != MEI_FILE_CONNECTED) {
+		mutex_unlock(&dev->device_lock);
+		dev_err(&dev->pdev->dev, "Already disconnected");
+
+		return 0;
+	}
+
+	cl->state = MEI_FILE_DISCONNECTING;
+
+	err = mei_cl_disconnect(cl);
+	if (err < 0) {
+		mutex_unlock(&dev->device_lock);
+		dev_err(&dev->pdev->dev,
+			"Could not disconnect from the ME client");
+
+		return err;
+	}
+
+	/* Flush queues and remove any pending read */
+	mei_cl_flush_queues(cl);
+
+	if (cl->read_cb) {
+		struct mei_cl_cb *cb = NULL;
+
+		cb = mei_cl_find_read_cb(cl);
+		/* Remove entry from read list */
+		if (cb)
+			list_del(&cb->list);
+
+		cb = cl->read_cb;
+		cl->read_cb = NULL;
+
+		if (cb) {
+			mei_io_cb_free(cb);
+			cb = NULL;
+		}
+	}
+
+	mutex_unlock(&dev->device_lock);
+
+	if (!device->ops || !device->ops->disable)
+		return 0;
+
+	return device->ops->disable(device);
+}
+EXPORT_SYMBOL_GPL(mei_cl_disable_device);
+
 void mei_cl_bus_rx_event(struct mei_cl *cl)
 {
 	struct mei_cl_device *device = cl->device;

commit 4234a6deb5ab04e50cfd6d72761345727bd2de21
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Mon Apr 8 21:56:37 2013 +0300

    mei: add mei_cl_write function
    
    consolidate write code to a specific me client in mei_cl_write function
    the function is called from mei device write handler and from
    mei_cl bus send function
    
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 8dbcb1516dc6..6badfa1110e9 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -226,112 +226,47 @@ static int ___mei_cl_send(struct mei_cl *cl, u8 *buf, size_t length,
 			bool blocking)
 {
 	struct mei_device *dev;
-	struct mei_msg_hdr mei_hdr;
 	struct mei_cl_cb *cb;
-	int me_cl_id, err;
+	int id;
+	int rets;
 
 	if (WARN_ON(!cl || !cl->dev))
 		return -ENODEV;
 
+	dev = cl->dev;
+
 	if (cl->state != MEI_FILE_CONNECTED)
 		return -ENODEV;
 
+	/* Check if we have an ME client device */
+	id = mei_me_cl_by_id(dev, cl->me_client_id);
+	if (id < 0)
+		return -ENODEV;
+
+	if (length > dev->me_clients[id].props.max_msg_length)
+		return -EINVAL;
+
 	cb = mei_io_cb_init(cl, NULL);
 	if (!cb)
 		return -ENOMEM;
 
-	err = mei_io_cb_alloc_req_buf(cb, length);
-	if (err < 0) {
+	rets = mei_io_cb_alloc_req_buf(cb, length);
+	if (rets < 0) {
 		mei_io_cb_free(cb);
-		return err;
+		return rets;
 	}
 
 	memcpy(cb->request_buffer.data, buf, length);
-	cb->fop_type = MEI_FOP_WRITE;
-
-	dev = cl->dev;
 
 	mutex_lock(&dev->device_lock);
 
-	/* Check if we have an ME client device */
-	me_cl_id = mei_me_cl_by_id(dev, cl->me_client_id);
-	if (me_cl_id == dev->me_clients_num) {
-		err = -ENODEV;
-		goto out_err;
-	}
-
-	if (length > dev->me_clients[me_cl_id].props.max_msg_length) {
-		err = -EINVAL;
-		goto out_err;
-	}
-
-	err = mei_cl_flow_ctrl_creds(cl);
-	if (err < 0)
-		goto out_err;
-
-	/* Host buffer is not ready, we queue the request */
-	if (err == 0 || !dev->hbuf_is_ready) {
-		cb->buf_idx = 0;
-		mei_hdr.msg_complete = 0;
-		cl->writing_state = MEI_WRITING;
-
-		goto out;
-	}
-
-	dev->hbuf_is_ready = false;
-
-	/* Check for a maximum length */
-	if (length > mei_hbuf_max_len(dev)) {
-		mei_hdr.length = mei_hbuf_max_len(dev);
-		mei_hdr.msg_complete = 0;
-	} else {
-		mei_hdr.length = length;
-		mei_hdr.msg_complete = 1;
-	}
-
-	mei_hdr.host_addr = cl->host_client_id;
-	mei_hdr.me_addr = cl->me_client_id;
-	mei_hdr.reserved = 0;
-
-	if (mei_write_message(dev, &mei_hdr, buf)) {
-		err = -EIO;
-		goto out_err;
-	}
-
-	cl->writing_state = MEI_WRITING;
-	cb->buf_idx = mei_hdr.length;
-
-out:
-	if (mei_hdr.msg_complete) {
-		if (mei_cl_flow_ctrl_reduce(cl)) {
-			err = -ENODEV;
-			goto out_err;
-		}
-		list_add_tail(&cb->list, &dev->write_waiting_list.list);
-	} else {
-		list_add_tail(&cb->list, &dev->write_list.list);
-	}
+	rets = mei_cl_write(cl, cb, blocking);
 
 	mutex_unlock(&dev->device_lock);
+	if (rets < 0)
+		mei_io_cb_free(cb);
 
-	if (blocking && cl->writing_state != MEI_WRITE_COMPLETE) {
-		if (wait_event_interruptible(cl->tx_wait,
-			cl->writing_state == MEI_WRITE_COMPLETE)) {
-				if (signal_pending(current))
-					err = -EINTR;
-			err = -ERESTARTSYS;
-			mutex_lock(&dev->device_lock);
-			goto out_err;
-		}
-	}
-
-	return mei_hdr.length;
-
-out_err:
-	mutex_unlock(&dev->device_lock);
-	mei_io_cb_free(cb);
-
-	return err;
+	return rets;
 }
 
 int __mei_cl_recv(struct mei_cl *cl, u8 *buf, size_t length)

commit aa6aef216f8aea1a00b56aafc29b8745237a9b62
Author: Samuel Ortiz <sameo@linux.intel.com>
Date:   Wed Mar 27 17:29:59 2013 +0200

    mei: bus: Implement bus driver data setter/getter
    
    MEI drivers should be able to carry their private data around.
    
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 2b4b5b3f639f..8dbcb1516dc6 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -461,6 +461,18 @@ int mei_cl_register_event_cb(struct mei_cl_device *device,
 }
 EXPORT_SYMBOL_GPL(mei_cl_register_event_cb);
 
+void *mei_cl_get_drvdata(const struct mei_cl_device *device)
+{
+	return dev_get_drvdata(&device->dev);
+}
+EXPORT_SYMBOL_GPL(mei_cl_get_drvdata);
+
+void mei_cl_set_drvdata(struct mei_cl_device *device, void *data)
+{
+	dev_set_drvdata(&device->dev, data);
+}
+EXPORT_SYMBOL_GPL(mei_cl_set_drvdata);
+
 void mei_cl_bus_rx_event(struct mei_cl *cl)
 {
 	struct mei_cl_device *device = cl->device;

commit 44d88d919261256e3bd999cde05572c8c4afb642
Author: Samuel Ortiz <sameo@linux.intel.com>
Date:   Wed Mar 27 17:29:58 2013 +0200

    mei: bus: Synchronous API for the data transmission
    
    Define a truly synchronous API for the bus Tx path by putting all pending
    request to the write list and wait for the interrupt tx handler to wake
    us up.
    The ___mei_cl_send() out path is also slightly reworked to make it look more
    like main.c:mei_write().
    
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index c626dc9937eb..2b4b5b3f639f 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -222,7 +222,8 @@ void mei_cl_driver_unregister(struct mei_cl_driver *driver)
 }
 EXPORT_SYMBOL_GPL(mei_cl_driver_unregister);
 
-int __mei_cl_send(struct mei_cl *cl, u8 *buf, size_t length)
+static int ___mei_cl_send(struct mei_cl *cl, u8 *buf, size_t length,
+			bool blocking)
 {
 	struct mei_device *dev;
 	struct mei_msg_hdr mei_hdr;
@@ -273,11 +274,8 @@ int __mei_cl_send(struct mei_cl *cl, u8 *buf, size_t length)
 		cb->buf_idx = 0;
 		mei_hdr.msg_complete = 0;
 		cl->writing_state = MEI_WRITING;
-		list_add_tail(&cb->list, &dev->write_list.list);
-
-		mutex_unlock(&dev->device_lock);
 
-		return length;
+		goto out;
 	}
 
 	dev->hbuf_is_ready = false;
@@ -303,19 +301,30 @@ int __mei_cl_send(struct mei_cl *cl, u8 *buf, size_t length)
 	cl->writing_state = MEI_WRITING;
 	cb->buf_idx = mei_hdr.length;
 
-	if (!mei_hdr.msg_complete) {
-		list_add_tail(&cb->list, &dev->write_list.list);
-	} else {
+out:
+	if (mei_hdr.msg_complete) {
 		if (mei_cl_flow_ctrl_reduce(cl)) {
-			err = -EIO;
+			err = -ENODEV;
 			goto out_err;
 		}
-
 		list_add_tail(&cb->list, &dev->write_waiting_list.list);
+	} else {
+		list_add_tail(&cb->list, &dev->write_list.list);
 	}
 
 	mutex_unlock(&dev->device_lock);
 
+	if (blocking && cl->writing_state != MEI_WRITE_COMPLETE) {
+		if (wait_event_interruptible(cl->tx_wait,
+			cl->writing_state == MEI_WRITE_COMPLETE)) {
+				if (signal_pending(current))
+					err = -EINTR;
+			err = -ERESTARTSYS;
+			mutex_lock(&dev->device_lock);
+			goto out_err;
+		}
+	}
+
 	return mei_hdr.length;
 
 out_err:
@@ -382,6 +391,16 @@ int __mei_cl_recv(struct mei_cl *cl, u8 *buf, size_t length)
 	return r_length;
 }
 
+inline int __mei_cl_async_send(struct mei_cl *cl, u8 *buf, size_t length)
+{
+	return ___mei_cl_send(cl, buf, length, 0);
+}
+
+inline int __mei_cl_send(struct mei_cl *cl, u8 *buf, size_t length)
+{
+	return ___mei_cl_send(cl, buf, length, 1);
+}
+
 int mei_cl_send(struct mei_cl_device *device, u8 *buf, size_t length)
 {
 	struct mei_cl *cl = device->cl;

commit cf3baefba04073237decb1b8a8c114b0b45bfc80
Author: Samuel Ortiz <sameo@linux.intel.com>
Date:   Wed Mar 27 17:29:57 2013 +0200

    mei: bus: Call bus routines from the core code
    
    Register the MEI bus type against the kernel core bus APIs and
    call the bus Rx handler from interrupt.c
    
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 162cd542cac9..c626dc9937eb 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -441,3 +441,25 @@ int mei_cl_register_event_cb(struct mei_cl_device *device,
 	return 0;
 }
 EXPORT_SYMBOL_GPL(mei_cl_register_event_cb);
+
+void mei_cl_bus_rx_event(struct mei_cl *cl)
+{
+	struct mei_cl_device *device = cl->device;
+
+	if (!device || !device->event_cb)
+		return;
+
+	set_bit(MEI_CL_EVENT_RX, &device->events);
+
+	schedule_work(&device->event_work);
+}
+
+int __init mei_cl_bus_init(void)
+{
+	return bus_register(&mei_cl_bus_type);
+}
+
+void __exit mei_cl_bus_exit(void)
+{
+	bus_unregister(&mei_cl_bus_type);
+}

commit a7b71bc043aded9da4cf51f85271e0779161fe22
Author: Samuel Ortiz <sameo@linux.intel.com>
Date:   Wed Mar 27 17:29:56 2013 +0200

    mei: bus: Add bus related structures to mei_cl
    
    We keep track of all MEI devices on the bus through a specific linked list.
    We also have a mei_device instance in the mei_cl structure.
    
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 16c7fff50549..162cd542cac9 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -140,36 +140,53 @@ static struct device_type mei_cl_device_type = {
 	.release	= mei_cl_dev_release,
 };
 
-struct mei_cl_device *mei_cl_add_device(struct mei_device *mei_device,
+static struct mei_cl *mei_bus_find_mei_cl_by_uuid(struct mei_device *dev,
+						uuid_le uuid)
+{
+	struct mei_cl *cl, *next;
+
+	list_for_each_entry_safe(cl, next, &dev->device_list, device_link) {
+		if (!uuid_le_cmp(uuid, cl->device_uuid))
+			return cl;
+	}
+
+	return NULL;
+}
+struct mei_cl_device *mei_cl_add_device(struct mei_device *dev,
 				  uuid_le uuid, char *name)
 {
 	struct mei_cl_device *device;
+	struct mei_cl *cl;
 	int status;
 
+	cl = mei_bus_find_mei_cl_by_uuid(dev, uuid);
+	if (cl == NULL)
+		return NULL;
+
 	device = kzalloc(sizeof(struct mei_cl_device), GFP_KERNEL);
 	if (!device)
 		return NULL;
 
-	device->dev.parent = &mei_device->pdev->dev;
+	device->cl = cl;
+
+	device->dev.parent = &dev->pdev->dev;
 	device->dev.bus = &mei_cl_bus_type;
 	device->dev.type = &mei_cl_device_type;
 
 	dev_set_name(&device->dev, "%s", name);
 
 	status = device_register(&device->dev);
-	if (status)
-		goto out_err;
+	if (status) {
+		dev_err(&dev->pdev->dev, "Failed to register MEI device\n");
+		kfree(device);
+		return NULL;
+	}
+
+	cl->device = device;
 
 	dev_dbg(&device->dev, "client %s registered\n", name);
 
 	return device;
-
-out_err:
-	dev_err(device->dev.parent, "Failed to register MEI client\n");
-
-	kfree(device);
-
-	return NULL;
 }
 EXPORT_SYMBOL_GPL(mei_cl_add_device);
 
@@ -367,9 +384,10 @@ int __mei_cl_recv(struct mei_cl *cl, u8 *buf, size_t length)
 
 int mei_cl_send(struct mei_cl_device *device, u8 *buf, size_t length)
 {
-	struct mei_cl *cl = NULL;
+	struct mei_cl *cl = device->cl;
 
-	/* TODO: hook between mei_bus_client and mei_cl */
+	if (cl == NULL)
+		return -ENODEV;
 
 	if (device->ops && device->ops->send)
 		return device->ops->send(device, buf, length);
@@ -380,9 +398,10 @@ EXPORT_SYMBOL_GPL(mei_cl_send);
 
 int mei_cl_recv(struct mei_cl_device *device, u8 *buf, size_t length)
 {
-	struct mei_cl *cl = NULL;
+	struct mei_cl *cl =  device->cl;
 
-	/* TODO: hook between mei_bus_client and mei_cl */
+	if (cl == NULL)
+		return -ENODEV;
 
 	if (device->ops && device->ops->recv)
 		return device->ops->recv(device, buf, length);

commit 3e8332952dedd2c17bb497e3909e3b6fbac10ce7
Author: Samuel Ortiz <sameo@linux.intel.com>
Date:   Wed Mar 27 17:29:55 2013 +0200

    mei: bus: Initial implementation for I/O routines
    
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index d16b3c3e1b38..16c7fff50549 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -16,6 +16,7 @@
 #include <linux/module.h>
 #include <linux/device.h>
 #include <linux/kernel.h>
+#include <linux/sched.h>
 #include <linux/init.h>
 #include <linux/errno.h>
 #include <linux/slab.h>
@@ -25,6 +26,8 @@
 #include <linux/mei_cl_bus.h>
 
 #include "mei_dev.h"
+#include "hw-me.h"
+#include "client.h"
 
 #define to_mei_cl_driver(d) container_of(d, struct mei_cl_driver, driver)
 #define to_mei_cl_device(d) container_of(d, struct mei_cl_device, dev)
@@ -81,6 +84,11 @@ static int mei_cl_device_remove(struct device *dev)
 	if (!device || !dev->driver)
 		return 0;
 
+	if (device->event_cb) {
+		device->event_cb = NULL;
+		cancel_work_sync(&device->event_work);
+	}
+
 	driver = to_mei_cl_driver(dev->driver);
 	if (!driver->remove) {
 		dev->driver = NULL;
@@ -196,3 +204,221 @@ void mei_cl_driver_unregister(struct mei_cl_driver *driver)
 	pr_debug("mei: driver [%s] unregistered\n", driver->driver.name);
 }
 EXPORT_SYMBOL_GPL(mei_cl_driver_unregister);
+
+int __mei_cl_send(struct mei_cl *cl, u8 *buf, size_t length)
+{
+	struct mei_device *dev;
+	struct mei_msg_hdr mei_hdr;
+	struct mei_cl_cb *cb;
+	int me_cl_id, err;
+
+	if (WARN_ON(!cl || !cl->dev))
+		return -ENODEV;
+
+	if (cl->state != MEI_FILE_CONNECTED)
+		return -ENODEV;
+
+	cb = mei_io_cb_init(cl, NULL);
+	if (!cb)
+		return -ENOMEM;
+
+	err = mei_io_cb_alloc_req_buf(cb, length);
+	if (err < 0) {
+		mei_io_cb_free(cb);
+		return err;
+	}
+
+	memcpy(cb->request_buffer.data, buf, length);
+	cb->fop_type = MEI_FOP_WRITE;
+
+	dev = cl->dev;
+
+	mutex_lock(&dev->device_lock);
+
+	/* Check if we have an ME client device */
+	me_cl_id = mei_me_cl_by_id(dev, cl->me_client_id);
+	if (me_cl_id == dev->me_clients_num) {
+		err = -ENODEV;
+		goto out_err;
+	}
+
+	if (length > dev->me_clients[me_cl_id].props.max_msg_length) {
+		err = -EINVAL;
+		goto out_err;
+	}
+
+	err = mei_cl_flow_ctrl_creds(cl);
+	if (err < 0)
+		goto out_err;
+
+	/* Host buffer is not ready, we queue the request */
+	if (err == 0 || !dev->hbuf_is_ready) {
+		cb->buf_idx = 0;
+		mei_hdr.msg_complete = 0;
+		cl->writing_state = MEI_WRITING;
+		list_add_tail(&cb->list, &dev->write_list.list);
+
+		mutex_unlock(&dev->device_lock);
+
+		return length;
+	}
+
+	dev->hbuf_is_ready = false;
+
+	/* Check for a maximum length */
+	if (length > mei_hbuf_max_len(dev)) {
+		mei_hdr.length = mei_hbuf_max_len(dev);
+		mei_hdr.msg_complete = 0;
+	} else {
+		mei_hdr.length = length;
+		mei_hdr.msg_complete = 1;
+	}
+
+	mei_hdr.host_addr = cl->host_client_id;
+	mei_hdr.me_addr = cl->me_client_id;
+	mei_hdr.reserved = 0;
+
+	if (mei_write_message(dev, &mei_hdr, buf)) {
+		err = -EIO;
+		goto out_err;
+	}
+
+	cl->writing_state = MEI_WRITING;
+	cb->buf_idx = mei_hdr.length;
+
+	if (!mei_hdr.msg_complete) {
+		list_add_tail(&cb->list, &dev->write_list.list);
+	} else {
+		if (mei_cl_flow_ctrl_reduce(cl)) {
+			err = -EIO;
+			goto out_err;
+		}
+
+		list_add_tail(&cb->list, &dev->write_waiting_list.list);
+	}
+
+	mutex_unlock(&dev->device_lock);
+
+	return mei_hdr.length;
+
+out_err:
+	mutex_unlock(&dev->device_lock);
+	mei_io_cb_free(cb);
+
+	return err;
+}
+
+int __mei_cl_recv(struct mei_cl *cl, u8 *buf, size_t length)
+{
+	struct mei_device *dev;
+	struct mei_cl_cb *cb;
+	size_t r_length;
+	int err;
+
+	if (WARN_ON(!cl || !cl->dev))
+		return -ENODEV;
+
+	dev = cl->dev;
+
+	mutex_lock(&dev->device_lock);
+
+	if (!cl->read_cb) {
+		err = mei_cl_read_start(cl);
+		if (err < 0) {
+			mutex_unlock(&dev->device_lock);
+			return err;
+		}
+	}
+
+	if (cl->reading_state != MEI_READ_COMPLETE &&
+	    !waitqueue_active(&cl->rx_wait)) {
+		mutex_unlock(&dev->device_lock);
+
+		if (wait_event_interruptible(cl->rx_wait,
+				(MEI_READ_COMPLETE == cl->reading_state))) {
+			if (signal_pending(current))
+				return -EINTR;
+			return -ERESTARTSYS;
+		}
+
+		mutex_lock(&dev->device_lock);
+	}
+
+	cb = cl->read_cb;
+
+	if (cl->reading_state != MEI_READ_COMPLETE) {
+		r_length = 0;
+		goto out;
+	}
+
+	r_length = min_t(size_t, length, cb->buf_idx);
+
+	memcpy(buf, cb->response_buffer.data, r_length);
+
+	mei_io_cb_free(cb);
+	cl->reading_state = MEI_IDLE;
+	cl->read_cb = NULL;
+
+out:
+	mutex_unlock(&dev->device_lock);
+
+	return r_length;
+}
+
+int mei_cl_send(struct mei_cl_device *device, u8 *buf, size_t length)
+{
+	struct mei_cl *cl = NULL;
+
+	/* TODO: hook between mei_bus_client and mei_cl */
+
+	if (device->ops && device->ops->send)
+		return device->ops->send(device, buf, length);
+
+	return __mei_cl_send(cl, buf, length);
+}
+EXPORT_SYMBOL_GPL(mei_cl_send);
+
+int mei_cl_recv(struct mei_cl_device *device, u8 *buf, size_t length)
+{
+	struct mei_cl *cl = NULL;
+
+	/* TODO: hook between mei_bus_client and mei_cl */
+
+	if (device->ops && device->ops->recv)
+		return device->ops->recv(device, buf, length);
+
+	return __mei_cl_recv(cl, buf, length);
+}
+EXPORT_SYMBOL_GPL(mei_cl_recv);
+
+static void mei_bus_event_work(struct work_struct *work)
+{
+	struct mei_cl_device *device;
+
+	device = container_of(work, struct mei_cl_device, event_work);
+
+	if (device->event_cb)
+		device->event_cb(device, device->events, device->event_context);
+
+	device->events = 0;
+
+	/* Prepare for the next read */
+	mei_cl_read_start(device->cl);
+}
+
+int mei_cl_register_event_cb(struct mei_cl_device *device,
+			  mei_cl_event_cb_t event_cb, void *context)
+{
+	if (device->event_cb)
+		return -EALREADY;
+
+	device->events = 0;
+	device->event_cb = event_cb;
+	device->event_context = context;
+	INIT_WORK(&device->event_work, mei_bus_event_work);
+
+	mei_cl_read_start(device->cl);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(mei_cl_register_event_cb);

commit 333e4ee0781bd0b5938da263c4bb7ab66a0d1b57
Author: Samuel Ortiz <sameo@linux.intel.com>
Date:   Wed Mar 27 17:29:54 2013 +0200

    mei: bus: Implement driver registration
    
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 78c876af2676..d16b3c3e1b38 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -170,3 +170,29 @@ void mei_cl_remove_device(struct mei_cl_device *device)
 	device_unregister(&device->dev);
 }
 EXPORT_SYMBOL_GPL(mei_cl_remove_device);
+
+int __mei_cl_driver_register(struct mei_cl_driver *driver, struct module *owner)
+{
+	int err;
+
+	driver->driver.name = driver->name;
+	driver->driver.owner = owner;
+	driver->driver.bus = &mei_cl_bus_type;
+
+	err = driver_register(&driver->driver);
+	if (err)
+		return err;
+
+	pr_debug("mei: driver [%s] registered\n", driver->driver.name);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(__mei_cl_driver_register);
+
+void mei_cl_driver_unregister(struct mei_cl_driver *driver)
+{
+	driver_unregister(&driver->driver);
+
+	pr_debug("mei: driver [%s] unregistered\n", driver->driver.name);
+}
+EXPORT_SYMBOL_GPL(mei_cl_driver_unregister);

commit e5354107e14755991da82e0d2a4791db92908d9d
Author: Samuel Ortiz <sameo@linux.intel.com>
Date:   Wed Mar 27 17:29:53 2013 +0200

    mei: bus: Initial MEI Client bus type implementation
    
    mei client bus will present some of the mei clients
    as devices for other standard subsystems
    
    Implement the probe, remove, match, device addtion routines, along with
    the sysfs and uevent ones. mei_cl_device_id is also added to
    mod_devicetable.h
    A mei-cleint-bus.txt document describing the rationale and the API usage
    is also added while ABI/testing/sysfs-bus-mei describeis the modalias ABI.
    
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
new file mode 100644
index 000000000000..78c876af2676
--- /dev/null
+++ b/drivers/misc/mei/bus.c
@@ -0,0 +1,172 @@
+/*
+ * Intel Management Engine Interface (Intel MEI) Linux driver
+ * Copyright (c) 2012-2013, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/mutex.h>
+#include <linux/interrupt.h>
+#include <linux/pci.h>
+#include <linux/mei_cl_bus.h>
+
+#include "mei_dev.h"
+
+#define to_mei_cl_driver(d) container_of(d, struct mei_cl_driver, driver)
+#define to_mei_cl_device(d) container_of(d, struct mei_cl_device, dev)
+
+static int mei_cl_device_match(struct device *dev, struct device_driver *drv)
+{
+	struct mei_cl_device *device = to_mei_cl_device(dev);
+	struct mei_cl_driver *driver = to_mei_cl_driver(drv);
+	const struct mei_cl_device_id *id;
+
+	if (!device)
+		return 0;
+
+	if (!driver || !driver->id_table)
+		return 0;
+
+	id = driver->id_table;
+
+	while (id->name[0]) {
+		if (!strcmp(dev_name(dev), id->name))
+			return 1;
+
+		id++;
+	}
+
+	return 0;
+}
+
+static int mei_cl_device_probe(struct device *dev)
+{
+	struct mei_cl_device *device = to_mei_cl_device(dev);
+	struct mei_cl_driver *driver;
+	struct mei_cl_device_id id;
+
+	if (!device)
+		return 0;
+
+	driver = to_mei_cl_driver(dev->driver);
+	if (!driver || !driver->probe)
+		return -ENODEV;
+
+	dev_dbg(dev, "Device probe\n");
+
+	strncpy(id.name, dev_name(dev), MEI_CL_NAME_SIZE);
+
+	return driver->probe(device, &id);
+}
+
+static int mei_cl_device_remove(struct device *dev)
+{
+	struct mei_cl_device *device = to_mei_cl_device(dev);
+	struct mei_cl_driver *driver;
+
+	if (!device || !dev->driver)
+		return 0;
+
+	driver = to_mei_cl_driver(dev->driver);
+	if (!driver->remove) {
+		dev->driver = NULL;
+
+		return 0;
+	}
+
+	return driver->remove(device);
+}
+
+static ssize_t modalias_show(struct device *dev, struct device_attribute *a,
+			     char *buf)
+{
+	int len;
+
+	len = snprintf(buf, PAGE_SIZE, "mei:%s\n", dev_name(dev));
+
+	return (len >= PAGE_SIZE) ? (PAGE_SIZE - 1) : len;
+}
+
+static struct device_attribute mei_cl_dev_attrs[] = {
+	__ATTR_RO(modalias),
+	__ATTR_NULL,
+};
+
+static int mei_cl_uevent(struct device *dev, struct kobj_uevent_env *env)
+{
+	if (add_uevent_var(env, "MODALIAS=mei:%s", dev_name(dev)))
+		return -ENOMEM;
+
+	return 0;
+}
+
+static struct bus_type mei_cl_bus_type = {
+	.name		= "mei",
+	.dev_attrs	= mei_cl_dev_attrs,
+	.match		= mei_cl_device_match,
+	.probe		= mei_cl_device_probe,
+	.remove		= mei_cl_device_remove,
+	.uevent		= mei_cl_uevent,
+};
+
+static void mei_cl_dev_release(struct device *dev)
+{
+	kfree(to_mei_cl_device(dev));
+}
+
+static struct device_type mei_cl_device_type = {
+	.release	= mei_cl_dev_release,
+};
+
+struct mei_cl_device *mei_cl_add_device(struct mei_device *mei_device,
+				  uuid_le uuid, char *name)
+{
+	struct mei_cl_device *device;
+	int status;
+
+	device = kzalloc(sizeof(struct mei_cl_device), GFP_KERNEL);
+	if (!device)
+		return NULL;
+
+	device->dev.parent = &mei_device->pdev->dev;
+	device->dev.bus = &mei_cl_bus_type;
+	device->dev.type = &mei_cl_device_type;
+
+	dev_set_name(&device->dev, "%s", name);
+
+	status = device_register(&device->dev);
+	if (status)
+		goto out_err;
+
+	dev_dbg(&device->dev, "client %s registered\n", name);
+
+	return device;
+
+out_err:
+	dev_err(device->dev.parent, "Failed to register MEI client\n");
+
+	kfree(device);
+
+	return NULL;
+}
+EXPORT_SYMBOL_GPL(mei_cl_add_device);
+
+void mei_cl_remove_device(struct mei_cl_device *device)
+{
+	device_unregister(&device->dev);
+}
+EXPORT_SYMBOL_GPL(mei_cl_remove_device);
