commit 1e8d19d9b0dfcf11b61bac627203a290577e807a
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Thu Dec 12 10:41:03 2019 +0200

    mei: hdcp: bind only with i915 on the same PCH
    
    The mei device and i915 must reside on the same
    PCH in order for HDCP to work. Make the component
    matching function enforce this requirement.
    
                       hdcp
                        |
       i915            mei
        |               |
        +----= PCH =----+
    
    Cc: <stable@vger.kernel.org> v5.0+
    Cc: Ramalingam C <ramalingam.c@intel.com>
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Reviewed-by: Alexander Usyskin <alexander.usyskin@intel.com>
    Link: https://lore.kernel.org/r/20191212084103.2893-1-tomas.winkler@intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/hdcp/mei_hdcp.c b/drivers/misc/mei/hdcp/mei_hdcp.c
index 93027fd96c71..4c596c646ac0 100644
--- a/drivers/misc/mei/hdcp/mei_hdcp.c
+++ b/drivers/misc/mei/hdcp/mei_hdcp.c
@@ -757,11 +757,38 @@ static const struct component_master_ops mei_component_master_ops = {
 	.unbind = mei_component_master_unbind,
 };
 
+/**
+ * mei_hdcp_component_match - compare function for matching mei hdcp.
+ *
+ *    The function checks if the driver is i915, the subcomponent is HDCP
+ *    and the grand parent of hdcp and the parent of i915 are the same
+ *    PCH device.
+ *
+ * @dev: master device
+ * @subcomponent: subcomponent to match (I915_COMPONENT_HDCP)
+ * @data: compare data (mei hdcp device)
+ *
+ * Return:
+ * * 1 - if components match
+ * * 0 - otherwise
+ */
 static int mei_hdcp_component_match(struct device *dev, int subcomponent,
 				    void *data)
 {
-	return !strcmp(dev->driver->name, "i915") &&
-	       subcomponent == I915_COMPONENT_HDCP;
+	struct device *base = data;
+
+	if (strcmp(dev->driver->name, "i915") ||
+	    subcomponent != I915_COMPONENT_HDCP)
+		return 0;
+
+	base = base->parent;
+	if (!base)
+		return 0;
+
+	base = base->parent;
+	dev = dev->parent;
+
+	return (base && dev && dev == base);
 }
 
 static int mei_hdcp_probe(struct mei_cl_device *cldev,
@@ -785,7 +812,7 @@ static int mei_hdcp_probe(struct mei_cl_device *cldev,
 
 	master_match = NULL;
 	component_match_add_typed(&cldev->dev, &master_match,
-				  mei_hdcp_component_match, comp_master);
+				  mei_hdcp_component_match, &cldev->dev);
 	if (IS_ERR_OR_NULL(master_match)) {
 		ret = -ENOMEM;
 		goto err_exit;

commit 2d15cf1b9ae4c623b1a05838317f4c18fd534c9a
Author: Ramalingam C <ramalingam.c@intel.com>
Date:   Wed Aug 28 22:12:14 2019 +0530

    misc/mei/hdcp: Fill transcoder index in port info
    
    For gen12+ platform we need to pass the transcoder info
    as part of the port info into ME FW.
    
    This change fills the payload for ME FW from hdcp_port_data.
    
    v2:
      Doc is enhanced for physical_port and attached_transcoder [Tomas]
    
    Signed-off-by: Ramalingam C <ramalingam.c@intel.com>
    Acked-by: Jani Nikula <jani.nikula@intel.com>
    Reviewed-by: Shashank Sharma <shashank.sharma@intel.com>
    Acked-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Uma Shankar <uma.shankar@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190828164216.405-5-ramalingam.c@intel.com

diff --git a/drivers/misc/mei/hdcp/mei_hdcp.c b/drivers/misc/mei/hdcp/mei_hdcp.c
index 3638c77eba26..93027fd96c71 100644
--- a/drivers/misc/mei/hdcp/mei_hdcp.c
+++ b/drivers/misc/mei/hdcp/mei_hdcp.c
@@ -58,6 +58,7 @@ mei_hdcp_initiate_session(struct device *dev, struct hdcp_port_data *data,
 
 	session_init_in.port.integrated_port_type = data->port_type;
 	session_init_in.port.physical_port = (u8)data->fw_ddi;
+	session_init_in.port.attached_transcoder = (u8)data->fw_tc;
 	session_init_in.protocol = data->protocol;
 
 	byte = mei_cldev_send(cldev, (u8 *)&session_init_in,
@@ -127,6 +128,7 @@ mei_hdcp_verify_receiver_cert_prepare_km(struct device *dev,
 
 	verify_rxcert_in.port.integrated_port_type = data->port_type;
 	verify_rxcert_in.port.physical_port = (u8)data->fw_ddi;
+	verify_rxcert_in.port.attached_transcoder = (u8)data->fw_tc;
 
 	verify_rxcert_in.cert_rx = rx_cert->cert_rx;
 	memcpy(verify_rxcert_in.r_rx, &rx_cert->r_rx, HDCP_2_2_RRX_LEN);
@@ -197,6 +199,7 @@ mei_hdcp_verify_hprime(struct device *dev, struct hdcp_port_data *data,
 
 	send_hprime_in.port.integrated_port_type = data->port_type;
 	send_hprime_in.port.physical_port = (u8)data->fw_ddi;
+	send_hprime_in.port.attached_transcoder = (u8)data->fw_tc;
 
 	memcpy(send_hprime_in.h_prime, rx_hprime->h_prime,
 	       HDCP_2_2_H_PRIME_LEN);
@@ -254,6 +257,7 @@ mei_hdcp_store_pairing_info(struct device *dev, struct hdcp_port_data *data,
 
 	pairing_info_in.port.integrated_port_type = data->port_type;
 	pairing_info_in.port.physical_port = (u8)data->fw_ddi;
+	pairing_info_in.port.attached_transcoder = (u8)data->fw_tc;
 
 	memcpy(pairing_info_in.e_kh_km, pairing_info->e_kh_km,
 	       HDCP_2_2_E_KH_KM_LEN);
@@ -312,6 +316,7 @@ mei_hdcp_initiate_locality_check(struct device *dev,
 
 	lc_init_in.port.integrated_port_type = data->port_type;
 	lc_init_in.port.physical_port = (u8)data->fw_ddi;
+	lc_init_in.port.attached_transcoder = (u8)data->fw_tc;
 
 	byte = mei_cldev_send(cldev, (u8 *)&lc_init_in, sizeof(lc_init_in));
 	if (byte < 0) {
@@ -367,6 +372,7 @@ mei_hdcp_verify_lprime(struct device *dev, struct hdcp_port_data *data,
 
 	verify_lprime_in.port.integrated_port_type = data->port_type;
 	verify_lprime_in.port.physical_port = (u8)data->fw_ddi;
+	verify_lprime_in.port.attached_transcoder = (u8)data->fw_tc;
 
 	memcpy(verify_lprime_in.l_prime, rx_lprime->l_prime,
 	       HDCP_2_2_L_PRIME_LEN);
@@ -424,6 +430,7 @@ static int mei_hdcp_get_session_key(struct device *dev,
 
 	get_skey_in.port.integrated_port_type = data->port_type;
 	get_skey_in.port.physical_port = (u8)data->fw_ddi;
+	get_skey_in.port.attached_transcoder = (u8)data->fw_tc;
 
 	byte = mei_cldev_send(cldev, (u8 *)&get_skey_in, sizeof(get_skey_in));
 	if (byte < 0) {
@@ -488,6 +495,7 @@ mei_hdcp_repeater_check_flow_prepare_ack(struct device *dev,
 
 	verify_repeater_in.port.integrated_port_type = data->port_type;
 	verify_repeater_in.port.physical_port = (u8)data->fw_ddi;
+	verify_repeater_in.port.attached_transcoder = (u8)data->fw_tc;
 
 	memcpy(verify_repeater_in.rx_info, rep_topology->rx_info,
 	       HDCP_2_2_RXINFO_LEN);
@@ -558,6 +566,7 @@ static int mei_hdcp_verify_mprime(struct device *dev,
 
 	verify_mprime_in.port.integrated_port_type = data->port_type;
 	verify_mprime_in.port.physical_port = (u8)data->fw_ddi;
+	verify_mprime_in.port.attached_transcoder = (u8)data->fw_tc;
 
 	memcpy(verify_mprime_in.m_prime, stream_ready->m_prime,
 	       HDCP_2_2_MPRIME_LEN);
@@ -619,6 +628,7 @@ static int mei_hdcp_enable_authentication(struct device *dev,
 
 	enable_auth_in.port.integrated_port_type = data->port_type;
 	enable_auth_in.port.physical_port = (u8)data->fw_ddi;
+	enable_auth_in.port.attached_transcoder = (u8)data->fw_tc;
 	enable_auth_in.stream_type = data->streams[0].stream_type;
 
 	byte = mei_cldev_send(cldev, (u8 *)&enable_auth_in,
@@ -673,6 +683,7 @@ mei_hdcp_close_session(struct device *dev, struct hdcp_port_data *data)
 
 	session_close_in.port.integrated_port_type = data->port_type;
 	session_close_in.port.physical_port = (u8)data->fw_ddi;
+	session_close_in.port.attached_transcoder = (u8)data->fw_tc;
 
 	byte = mei_cldev_send(cldev, (u8 *)&session_close_in,
 			      sizeof(session_close_in));

commit 0dcceb35a13de07d8c28305b69a33b339c7eba0a
Author: Ramalingam C <ramalingam.c@intel.com>
Date:   Wed Aug 28 22:12:11 2019 +0530

    drm/i915: mei_hdcp: I915 sends ddi index as per ME FW
    
    I915 converts it's port value into ddi index defiend by ME FW
    and pass it as a member of hdcp_port_data structure.
    
    Hence expose the enum mei_fw_ddi to I915 through
    i915_mei_interface.h.
    
    v2:
      Copyright years are bumped [Tomas]
    
    Signed-off-by: Ramalingam C <ramalingam.c@intel.com>
    Acked-by: Jani Nikula <jani.nikula@intel.com>
    Reviewed-by: Shashank Sharma <shashank.sharma@intel.com>
    Acked-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Uma Shankar <uma.shankar@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190828164216.405-2-ramalingam.c@intel.com

diff --git a/drivers/misc/mei/hdcp/mei_hdcp.c b/drivers/misc/mei/hdcp/mei_hdcp.c
index c681f6fab342..3638c77eba26 100644
--- a/drivers/misc/mei/hdcp/mei_hdcp.c
+++ b/drivers/misc/mei/hdcp/mei_hdcp.c
@@ -27,18 +27,6 @@
 
 #include "mei_hdcp.h"
 
-static inline u8 mei_get_ddi_index(enum port port)
-{
-	switch (port) {
-	case PORT_A:
-		return MEI_DDI_A;
-	case PORT_B ... PORT_F:
-		return (u8)port;
-	default:
-		return MEI_DDI_INVALID_PORT;
-	}
-}
-
 /**
  * mei_hdcp_initiate_session() - Initiate a Wired HDCP2.2 Tx Session in ME FW
  * @dev: device corresponding to the mei_cl_device
@@ -69,7 +57,7 @@ mei_hdcp_initiate_session(struct device *dev, struct hdcp_port_data *data,
 				WIRED_CMD_BUF_LEN_INITIATE_HDCP2_SESSION_IN;
 
 	session_init_in.port.integrated_port_type = data->port_type;
-	session_init_in.port.physical_port = mei_get_ddi_index(data->port);
+	session_init_in.port.physical_port = (u8)data->fw_ddi;
 	session_init_in.protocol = data->protocol;
 
 	byte = mei_cldev_send(cldev, (u8 *)&session_init_in,
@@ -138,7 +126,7 @@ mei_hdcp_verify_receiver_cert_prepare_km(struct device *dev,
 				WIRED_CMD_BUF_LEN_VERIFY_RECEIVER_CERT_IN;
 
 	verify_rxcert_in.port.integrated_port_type = data->port_type;
-	verify_rxcert_in.port.physical_port = mei_get_ddi_index(data->port);
+	verify_rxcert_in.port.physical_port = (u8)data->fw_ddi;
 
 	verify_rxcert_in.cert_rx = rx_cert->cert_rx;
 	memcpy(verify_rxcert_in.r_rx, &rx_cert->r_rx, HDCP_2_2_RRX_LEN);
@@ -208,7 +196,7 @@ mei_hdcp_verify_hprime(struct device *dev, struct hdcp_port_data *data,
 	send_hprime_in.header.buffer_len = WIRED_CMD_BUF_LEN_AKE_SEND_HPRIME_IN;
 
 	send_hprime_in.port.integrated_port_type = data->port_type;
-	send_hprime_in.port.physical_port = mei_get_ddi_index(data->port);
+	send_hprime_in.port.physical_port = (u8)data->fw_ddi;
 
 	memcpy(send_hprime_in.h_prime, rx_hprime->h_prime,
 	       HDCP_2_2_H_PRIME_LEN);
@@ -265,7 +253,7 @@ mei_hdcp_store_pairing_info(struct device *dev, struct hdcp_port_data *data,
 					WIRED_CMD_BUF_LEN_SEND_PAIRING_INFO_IN;
 
 	pairing_info_in.port.integrated_port_type = data->port_type;
-	pairing_info_in.port.physical_port = mei_get_ddi_index(data->port);
+	pairing_info_in.port.physical_port = (u8)data->fw_ddi;
 
 	memcpy(pairing_info_in.e_kh_km, pairing_info->e_kh_km,
 	       HDCP_2_2_E_KH_KM_LEN);
@@ -323,7 +311,7 @@ mei_hdcp_initiate_locality_check(struct device *dev,
 	lc_init_in.header.buffer_len = WIRED_CMD_BUF_LEN_INIT_LOCALITY_CHECK_IN;
 
 	lc_init_in.port.integrated_port_type = data->port_type;
-	lc_init_in.port.physical_port = mei_get_ddi_index(data->port);
+	lc_init_in.port.physical_port = (u8)data->fw_ddi;
 
 	byte = mei_cldev_send(cldev, (u8 *)&lc_init_in, sizeof(lc_init_in));
 	if (byte < 0) {
@@ -378,7 +366,7 @@ mei_hdcp_verify_lprime(struct device *dev, struct hdcp_port_data *data,
 					WIRED_CMD_BUF_LEN_VALIDATE_LOCALITY_IN;
 
 	verify_lprime_in.port.integrated_port_type = data->port_type;
-	verify_lprime_in.port.physical_port = mei_get_ddi_index(data->port);
+	verify_lprime_in.port.physical_port = (u8)data->fw_ddi;
 
 	memcpy(verify_lprime_in.l_prime, rx_lprime->l_prime,
 	       HDCP_2_2_L_PRIME_LEN);
@@ -435,7 +423,7 @@ static int mei_hdcp_get_session_key(struct device *dev,
 	get_skey_in.header.buffer_len = WIRED_CMD_BUF_LEN_GET_SESSION_KEY_IN;
 
 	get_skey_in.port.integrated_port_type = data->port_type;
-	get_skey_in.port.physical_port = mei_get_ddi_index(data->port);
+	get_skey_in.port.physical_port = (u8)data->fw_ddi;
 
 	byte = mei_cldev_send(cldev, (u8 *)&get_skey_in, sizeof(get_skey_in));
 	if (byte < 0) {
@@ -499,7 +487,7 @@ mei_hdcp_repeater_check_flow_prepare_ack(struct device *dev,
 					WIRED_CMD_BUF_LEN_VERIFY_REPEATER_IN;
 
 	verify_repeater_in.port.integrated_port_type = data->port_type;
-	verify_repeater_in.port.physical_port = mei_get_ddi_index(data->port);
+	verify_repeater_in.port.physical_port = (u8)data->fw_ddi;
 
 	memcpy(verify_repeater_in.rx_info, rep_topology->rx_info,
 	       HDCP_2_2_RXINFO_LEN);
@@ -569,7 +557,7 @@ static int mei_hdcp_verify_mprime(struct device *dev,
 			WIRED_CMD_BUF_LEN_REPEATER_AUTH_STREAM_REQ_MIN_IN;
 
 	verify_mprime_in.port.integrated_port_type = data->port_type;
-	verify_mprime_in.port.physical_port = mei_get_ddi_index(data->port);
+	verify_mprime_in.port.physical_port = (u8)data->fw_ddi;
 
 	memcpy(verify_mprime_in.m_prime, stream_ready->m_prime,
 	       HDCP_2_2_MPRIME_LEN);
@@ -630,7 +618,7 @@ static int mei_hdcp_enable_authentication(struct device *dev,
 	enable_auth_in.header.buffer_len = WIRED_CMD_BUF_LEN_ENABLE_AUTH_IN;
 
 	enable_auth_in.port.integrated_port_type = data->port_type;
-	enable_auth_in.port.physical_port = mei_get_ddi_index(data->port);
+	enable_auth_in.port.physical_port = (u8)data->fw_ddi;
 	enable_auth_in.stream_type = data->streams[0].stream_type;
 
 	byte = mei_cldev_send(cldev, (u8 *)&enable_auth_in,
@@ -684,7 +672,7 @@ mei_hdcp_close_session(struct device *dev, struct hdcp_port_data *data)
 				WIRED_CMD_BUF_LEN_CLOSE_SESSION_IN;
 
 	session_close_in.port.integrated_port_type = data->port_type;
-	session_close_in.port.physical_port = mei_get_ddi_index(data->port);
+	session_close_in.port.physical_port = (u8)data->fw_ddi;
 
 	byte = mei_cldev_send(cldev, (u8 *)&session_close_in,
 			      sizeof(session_close_in));

commit be8454afc50f43016ca8b6130d9673bdd0bd56ec
Merge: fec88ab0af97 3729fe2bc2a0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jul 15 19:04:27 2019 -0700

    Merge tag 'drm-next-2019-07-16' of git://anongit.freedesktop.org/drm/drm
    
    Pull drm updates from Dave Airlie:
     "The biggest thing in this is the AMD Navi GPU support, this again
      contains a bunch of header files that are large. These are the new AMD
      RX5700 GPUs that just recently became available.
    
      New drivers:
       - ST-Ericsson MCDE driver
       - Ingenic JZ47xx SoC
    
      UAPI change:
       - HDR source metadata property
    
      Core:
       - HDR inforframes and EDID parsing
       - drm hdmi infoframe unpacking
       - remove prime sg_table caching into dma-buf
       - New gem vram helpers to reduce driver code
       - Lots of drmP.h removal
       - reservation fencing fix
       - documentation updates
       - drm_fb_helper_connector removed
       - mode name command handler rewrite
    
      fbcon:
       - Remove the fbcon notifiers
    
      ttm:
       - forward progress fixes
    
      dma-buf:
       - make mmap call optional
       - debugfs refcount fixes
       - dma-fence free with pending signals fix
       - each dma-buf gets an inode
    
      Panels:
       - Lots of additional panel bindings
    
      amdgpu:
       - initial navi10 support
       - avoid hw reset
       - HDR metadata support
       - new thermal sensors for vega asics
       - RAS fixes
       - use HMM rather than MMU notifier
       - xgmi topology via kfd
       - SR-IOV fixes
       - driver reload fixes
       - DC use a core bpc attribute
       - Aux fixes for DC
       - Bandwidth calc updates for DC
       - Clock handling refactor
       - kfd VEGAM support
    
      vmwgfx:
       - Coherent memory support changes
    
      i915:
       - HDR Support
       - HDMI i2c link
       - Icelake multi-segmented gamma support
       - GuC firmware update
       - Mule Creek Canyon PCH support for EHL
       - EHL platform updtes
       - move i915.alpha_support to i915.force_probe
       - runtime PM refactoring
       - VBT parsing refactoring
       - DSI fixes
       - struct mutex dependency reduction
       - GEM code reorg
    
      mali-dp:
       - Komeda driver features
    
      msm:
       - dsi vs EPROBE_DEFER fixes
       - msm8998 snapdragon 835 support
       - a540 gpu support
       - mdp5 and dpu interconnect support
    
      exynos:
       - drmP.h removal
    
      tegra:
       - misc fixes
    
      tda998x:
       - audio support improvements
       - pixel repeated mode support
       - quantisation range handling corrections
       - HDMI vendor info fix
    
      armada:
       - interlace support fix
       - overlay/video plane register handling refactor
       - add gamma support
    
      rockchip:
       - RX3328 support
    
      panfrost:
       - expose perf counters via hidden ioctls
    
      vkms:
       - enumerate CRC sources list
    
      ast:
       - rework BO handling
    
      mgag200:
       - rework BO handling
    
      dw-hdmi:
       - suspend/resume support
    
      rcar-du:
       - R8A774A1 Soc Support
       - LVDS dual-link mode support
       - Additional formats
       - Misc fixes
    
      omapdrm:
       - DSI command mode display support
    
      stm
       - fb modifier support
       - runtime PM support
    
      sun4i:
       - use vmap ops
    
      vc4:
       - binner bo binding rework
    
      v3d:
       - compute shader support
       - resync/sync fixes
       - job management refactoring
    
      lima:
       - NULL pointer in irq handler fix
       - scheduler default timeout
    
      virtio:
       - fence seqno support
       - trace events
    
      bochs:
       - misc fixes
    
      tc458767:
       - IRQ/HDP handling
    
      sii902x:
       - HDMI audio support
    
      atmel-hlcdc:
       - misc fixes
    
      meson:
       - zpos support"
    
    * tag 'drm-next-2019-07-16' of git://anongit.freedesktop.org/drm/drm: (1815 commits)
      Revert "Merge branch 'vmwgfx-next' of git://people.freedesktop.org/~thomash/linux into drm-next"
      Revert "mm: adjust apply_to_pfn_range interface for dropped token."
      mm: adjust apply_to_pfn_range interface for dropped token.
      drm/amdgpu/navi10: add uclk activity sensor
      drm/amdgpu: properly guard the generic discovery code
      drm/amdgpu: add missing documentation on new module parameters
      drm/amdgpu: don't invalidate caches in RELEASE_MEM, only do the writeback
      drm/amd/display: avoid 64-bit division
      drm/amdgpu/psp11: simplify the ucode register logic
      drm/amdgpu: properly guard DC support in navi code
      drm/amd/powerplay: vega20: fix uninitialized variable use
      drm/amd/display: dcn20: include linux/delay.h
      amdgpu: make pmu support optional
      drm/amd/powerplay: Zero initialize current_rpm in vega20_get_fan_speed_percent
      drm/amd/powerplay: Zero initialize freq in smu_v11_0_get_current_clk_freq
      drm/amd/powerplay: Use memset to initialize metrics structs
      drm/amdgpu/mes10.1: Fix header guard
      drm/amd/powerplay: add temperature sensor support for navi10
      drm/amdgpu: fix scheduler timeout calc
      drm/amdgpu: Prepare for hmm_range_register API change (v2)
      ...

commit 0475afd2a5dee99defdb7b030c09ba202ea3c64a
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Mon Jun 3 12:14:05 2019 +0300

    mei: docs: add hdcp documentation
    
    1. Add a short ducumentation for MEI HDCP driver,
    and fix DOC comments in drivers/misc/mei/hdcp/mei_hdcp.c
    
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/hdcp/mei_hdcp.c b/drivers/misc/mei/hdcp/mei_hdcp.c
index b07000202d4a..ed816939fb32 100644
--- a/drivers/misc/mei/hdcp/mei_hdcp.c
+++ b/drivers/misc/mei/hdcp/mei_hdcp.c
@@ -2,7 +2,7 @@
 /*
  * Copyright © 2019 Intel Corporation
  *
- * Mei_hdcp.c: HDCP client driver for mei bus
+ * mei_hdcp.c: HDCP client driver for mei bus
  *
  * Author:
  * Ramalingam C <ramalingam.c@intel.com>
@@ -11,12 +11,9 @@
 /**
  * DOC: MEI_HDCP Client Driver
  *
- * This is a client driver to the mei_bus to make the HDCP2.2 services of
- * ME FW available for the interested consumers like I915.
- *
- * This module will act as a translation layer between HDCP protocol
- * implementor(I915) and ME FW by translating HDCP2.2 authentication
- * messages to ME FW command payloads and vice versa.
+ * The mei_hdcp driver acts as a translation layer between HDCP 2.2
+ * protocol  implementer (I915) and ME FW by translating HDCP2.2
+ * negotiation messages to ME FW command payloads and vice versa.
  */
 
 #include <linux/module.h>

commit 14ee642c2ab0a3d8a1ded11fade692d8b77172b9
Merge: 88cd7a2c1b29 c0a74c732568
Author: Dave Airlie <airlied@redhat.com>
Date:   Tue May 28 09:03:58 2019 +1000

    Merge tag 'drm-intel-next-2019-05-24' of git://anongit.freedesktop.org/drm/drm-intel into drm-next
    
    Features:
    - Engine discovery query (Tvrtko)
    - Support for DP YCbCr4:2:0 outputs (Gwan-gyeong)
    - HDCP revocation support, refactoring (Ramalingam)
    - Remove DRM_AUTH from IOCTLs which also have DRM_RENDER_ALLOW (Christian König)
    - Asynchronous display power disabling (Imre)
    - Perma-pin uC firmware and re-enable global reset (Fernando)
    - GTT remapping for display, for bigger fb size and stride (Ville)
    - Enable pipe HDR mode on ICL if only HDR planes are used (Ville)
    - Kconfig to tweak the busyspin durations for i915_wait_request (Chris)
    - Allow multiple user handles to the same VM (Chris)
    - GT/GEM runtime pm improvements using wakerefs (Chris)
    - Gen 4&5 render context support (Chris)
    - Allow userspace to clone contexts on creation (Chris)
    - SINGLE_TIMELINE flags for context creation (Chris)
    - Allow specification of parallel execbuf (Chris)
    
    Refactoring:
    - Header refactoring (Jani)
    - Move GraphicsTechnology files under gt/ (Chris)
    - Sideband code refactoring (Chris)
    
    Fixes:
    - ICL DSI state readout and checker fixes (Vandita)
    - GLK DSI picture corruption fix (Stanislav)
    - HDMI deep color fixes (Clinton, Aditya)
    - Fix driver unbinding from a device in use (Janusz)
    - Fix clock gating with pipe scaling (Radhakrishna)
    - Disable broken FBC on GLK (Daniel Drake)
    - Miscellaneous GuC fixes (Michal)
    - Fix MG PHY DP register programming (Imre)
    - Add missing combo PHY lane power setup (Imre)
    - Workarounds for early ICL VBT issues (Imre)
    - Fix fastset vs. pfit on/off on HSW EDP transcoder (Ville)
    - Add readout and state check for pch_pfit.force_thru (Ville)
    - Miscellaneous display fixes and refactoring (Ville)
    - Display workaround fixes (Ville)
    - Enable audio even if ELD is bogus (Ville)
    - Fix use-after-free in reporting create.size (Chris)
    - Sideband fixes to avoid BYT hard lockups (Chris)
    - Workaround fixes and improvements (Chris)
    
    Maintainer shortcomings:
    - Failure to adequately describe and give credit for all changes (Jani)
    
    Signed-off-by: Dave Airlie <airlied@redhat.com>
    
    From: Jani Nikula <jani.nikula@intel.com>
    Link: https://patchwork.freedesktop.org/patch/msgid/87sgt3n45z.fsf@intel.com

commit 0de655cae416b20ed7876adb480e5c65810274ea
Author: Ramalingam C <ramalingam.c@intel.com>
Date:   Tue May 7 21:57:37 2019 +0530

    drm: generic fn converting be24 to cpu and vice versa
    
    Existing functions for converting a 3bytes(be24) of big endian value
    into u32 of little endian and vice versa are renamed as
    
    s/drm_hdcp2_seq_num_to_u32/drm_hdcp_be24_to_cpu
    s/drm_hdcp2_u32_to_seq_num/drm_hdcp_cpu_to_be24
    
    Signed-off-by: Ramalingam C <ramalingam.c@intel.com>
    Suggested-by: Daniel Vetter <daniel@ffwll.ch>
    cc: Tomas Winkler <tomas.winkler@intel.com>
    Acked-by: Dave Airlie <airlied@gmail.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/20190507162745.25600-4-ramalingam.c@intel.com

diff --git a/drivers/misc/mei/hdcp/mei_hdcp.c b/drivers/misc/mei/hdcp/mei_hdcp.c
index 90b6ae8e9dae..2f192d6d8b54 100644
--- a/drivers/misc/mei/hdcp/mei_hdcp.c
+++ b/drivers/misc/mei/hdcp/mei_hdcp.c
@@ -576,7 +576,7 @@ static int mei_hdcp_verify_mprime(struct device *dev,
 
 	memcpy(verify_mprime_in.m_prime, stream_ready->m_prime,
 	       HDCP_2_2_MPRIME_LEN);
-	drm_hdcp2_u32_to_seq_num(verify_mprime_in.seq_num_m, data->seq_num_m);
+	drm_hdcp_cpu_to_be24(verify_mprime_in.seq_num_m, data->seq_num_m);
 	memcpy(verify_mprime_in.streams, data->streams,
 	       (data->k * sizeof(struct hdcp2_streamid_type)));
 

commit 514c37e320a24507590bd023a554a6671e7fca92
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Tue Mar 12 00:10:43 2019 +0200

    mei/hdcp: Fix SPDX identifiers
    
    1. Remove redundant parentheses around single license
    2. Fix the license to GPL-2.0 and not GPL-2.0+ in mei_hdcp.h
    
    Cc: Ramalingam C <ramalingam.c@intel.com>
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/mei/hdcp/mei_hdcp.c b/drivers/misc/mei/hdcp/mei_hdcp.c
index 90b6ae8e9dae..b07000202d4a 100644
--- a/drivers/misc/mei/hdcp/mei_hdcp.c
+++ b/drivers/misc/mei/hdcp/mei_hdcp.c
@@ -1,4 +1,4 @@
-// SPDX-License-Identifier: (GPL-2.0)
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Copyright © 2019 Intel Corporation
  *

commit fa301ad9fa8f6f738b9c22da3ede7824e3286693
Author: Ramalingam C <ramalingam.c@intel.com>
Date:   Thu Feb 21 23:42:09 2019 +0530

    misc/mei/hdcp: Component framework for I915 Interface
    
    Mei hdcp driver is designed as component slave for the I915 component
    master.
    
    v2: Rebased.
    v3:
      Notifier chain is adopted for cldev state update [Tomas]
    v4:
      Made static dummy functions as inline in mei_hdcp.h
      API for polling client device status
      IS_ENABLED used in header, for config status for mei_hdcp.
    v5:
      Replacing the notifier with component framework. [Daniel]
    v6:
      Rebased on the I915 comp master redesign.
    v7:
      mei_hdcp_component_registered is made static [Uma]
      Need for global static variable mei_cldev is removed.
    v8:
      master comp is added to be matched with i915 subcomponent [daniel]
    v9:
      only comp_master is set and retrieved as driver_data [Daniel]
      Reviewed-by Daniel.
    v10:
      small corrections at probe [Tomas]
    v11:
      bind and unbind logs are made as debug logs [Tomas]
      cldev_enable failure is handled [Tomas]
    
    Signed-off-by: Ramalingam C <ramalingam.c@intel.com>
    Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/1550772730-23280-16-git-send-email-ramalingam.c@intel.com

diff --git a/drivers/misc/mei/hdcp/mei_hdcp.c b/drivers/misc/mei/hdcp/mei_hdcp.c
index deb579ad15e8..90b6ae8e9dae 100644
--- a/drivers/misc/mei/hdcp/mei_hdcp.c
+++ b/drivers/misc/mei/hdcp/mei_hdcp.c
@@ -23,6 +23,7 @@
 #include <linux/slab.h>
 #include <linux/uuid.h>
 #include <linux/mei_cl_bus.h>
+#include <linux/component.h>
 #include <drm/drm_connector.h>
 #include <drm/i915_component.h>
 #include <drm/i915_mei_hdcp_interface.h>
@@ -711,8 +712,7 @@ mei_hdcp_close_session(struct device *dev, struct hdcp_port_data *data)
 	return 0;
 }
 
-static const __attribute__((unused))
-struct i915_hdcp_component_ops mei_hdcp_ops = {
+static const struct i915_hdcp_component_ops mei_hdcp_ops = {
 	.owner = THIS_MODULE,
 	.initiate_hdcp2_session = mei_hdcp_initiate_session,
 	.verify_receiver_cert_prepare_km =
@@ -729,20 +729,100 @@ struct i915_hdcp_component_ops mei_hdcp_ops = {
 	.close_hdcp_session = mei_hdcp_close_session,
 };
 
+static int mei_component_master_bind(struct device *dev)
+{
+	struct mei_cl_device *cldev = to_mei_cl_device(dev);
+	struct i915_hdcp_comp_master *comp_master =
+						mei_cldev_get_drvdata(cldev);
+	int ret;
+
+	dev_dbg(dev, "%s\n", __func__);
+	comp_master->ops = &mei_hdcp_ops;
+	comp_master->mei_dev = dev;
+	ret = component_bind_all(dev, comp_master);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static void mei_component_master_unbind(struct device *dev)
+{
+	struct mei_cl_device *cldev = to_mei_cl_device(dev);
+	struct i915_hdcp_comp_master *comp_master =
+						mei_cldev_get_drvdata(cldev);
+
+	dev_dbg(dev, "%s\n", __func__);
+	component_unbind_all(dev, comp_master);
+}
+
+static const struct component_master_ops mei_component_master_ops = {
+	.bind = mei_component_master_bind,
+	.unbind = mei_component_master_unbind,
+};
+
+static int mei_hdcp_component_match(struct device *dev, int subcomponent,
+				    void *data)
+{
+	return !strcmp(dev->driver->name, "i915") &&
+	       subcomponent == I915_COMPONENT_HDCP;
+}
+
 static int mei_hdcp_probe(struct mei_cl_device *cldev,
 			  const struct mei_cl_device_id *id)
 {
+	struct i915_hdcp_comp_master *comp_master;
+	struct component_match *master_match;
 	int ret;
 
 	ret = mei_cldev_enable(cldev);
-	if (ret < 0)
+	if (ret < 0) {
 		dev_err(&cldev->dev, "mei_cldev_enable Failed. %d\n", ret);
+		goto enable_err_exit;
+	}
+
+	comp_master = kzalloc(sizeof(*comp_master), GFP_KERNEL);
+	if (!comp_master) {
+		ret = -ENOMEM;
+		goto err_exit;
+	}
+
+	master_match = NULL;
+	component_match_add_typed(&cldev->dev, &master_match,
+				  mei_hdcp_component_match, comp_master);
+	if (IS_ERR_OR_NULL(master_match)) {
+		ret = -ENOMEM;
+		goto err_exit;
+	}
+
+	mei_cldev_set_drvdata(cldev, comp_master);
+	ret = component_master_add_with_match(&cldev->dev,
+					      &mei_component_master_ops,
+					      master_match);
+	if (ret < 0) {
+		dev_err(&cldev->dev, "Master comp add failed %d\n", ret);
+		goto err_exit;
+	}
 
+	return 0;
+
+err_exit:
+	mei_cldev_set_drvdata(cldev, NULL);
+	kfree(comp_master);
+	mei_cldev_disable(cldev);
+enable_err_exit:
 	return ret;
 }
 
 static int mei_hdcp_remove(struct mei_cl_device *cldev)
 {
+	struct i915_hdcp_comp_master *comp_master =
+						mei_cldev_get_drvdata(cldev);
+
+	component_master_del(&cldev->dev, &mei_component_master_ops);
+	kfree(comp_master);
+	mei_cldev_set_drvdata(cldev, NULL);
+
 	return mei_cldev_disable(cldev);
 }
 

commit 62c2b3221fa027573f02ca43b7678f95cde62eaf
Author: Ramalingam C <ramalingam.c@intel.com>
Date:   Thu Feb 21 23:42:08 2019 +0530

    misc/mei/hdcp: Closing wired HDCP2.2 Tx Session
    
    Request the ME to terminate the HDCP2.2 session for a port.
    
    On Success, ME FW will mark the intel port as Deauthenticated and
    terminate the wired HDCP2.2 Tx session started due to the cmd
    WIRED_INITIATE_HDCP2_SESSION.
    
    v2: Rebased.
    v3:
      cldev is passed as first parameter [Tomas]
      Redundant comments and cast are removed [Tomas]
    v4:
      %zd for ssize_t [Alexander]
      %s/return -1/return -EIO [Alexander]
      Style and typos fixed [Uma]
    v5:
      Extra line is removed.
    v6:
      Collected the Rb-ed by.
      Rebased.
    v7:
      Adjust to the new mei interface.
      Fix for Kdoc.
    v8:
      K-Doc addition.[Tomas]
    v9:
      renamed func as mei_hdcp_* [Tomas]
      Inline function is defined for DDI index [Tomas]
    v10:
      K-Doc fix. [Tomas]
    v11:
      Rebased.
    
    Signed-off-by: Ramalingam C <ramalingam.c@intel.com>
    Reviewed-by: Uma Shankar <uma.shankar@intel.com>
    Acked-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/1550772730-23280-15-git-send-email-ramalingam.c@intel.com

diff --git a/drivers/misc/mei/hdcp/mei_hdcp.c b/drivers/misc/mei/hdcp/mei_hdcp.c
index 1e8c6f1ee4a5..deb579ad15e8 100644
--- a/drivers/misc/mei/hdcp/mei_hdcp.c
+++ b/drivers/misc/mei/hdcp/mei_hdcp.c
@@ -658,6 +658,59 @@ static int mei_hdcp_enable_authentication(struct device *dev,
 	return 0;
 }
 
+/**
+ * mei_hdcp_close_session() - Close the Wired HDCP Tx session of ME FW per port.
+ * This also disables the authenticated state of the port.
+ * @dev: device corresponding to the mei_cl_device
+ * @data: Intel HW specific hdcp data
+ *
+ * Return: 0 on Success, <0 on Failure
+ */
+static int
+mei_hdcp_close_session(struct device *dev, struct hdcp_port_data *data)
+{
+	struct wired_cmd_close_session_in session_close_in = { { 0 } };
+	struct wired_cmd_close_session_out session_close_out = { { 0 } };
+	struct mei_cl_device *cldev;
+	ssize_t byte;
+
+	if (!dev || !data)
+		return -EINVAL;
+
+	cldev = to_mei_cl_device(dev);
+
+	session_close_in.header.api_version = HDCP_API_VERSION;
+	session_close_in.header.command_id = WIRED_CLOSE_SESSION;
+	session_close_in.header.status = ME_HDCP_STATUS_SUCCESS;
+	session_close_in.header.buffer_len =
+				WIRED_CMD_BUF_LEN_CLOSE_SESSION_IN;
+
+	session_close_in.port.integrated_port_type = data->port_type;
+	session_close_in.port.physical_port = mei_get_ddi_index(data->port);
+
+	byte = mei_cldev_send(cldev, (u8 *)&session_close_in,
+			      sizeof(session_close_in));
+	if (byte < 0) {
+		dev_dbg(dev, "mei_cldev_send failed. %zd\n", byte);
+		return byte;
+	}
+
+	byte = mei_cldev_recv(cldev, (u8 *)&session_close_out,
+			      sizeof(session_close_out));
+	if (byte < 0) {
+		dev_dbg(dev, "mei_cldev_recv failed. %zd\n", byte);
+		return byte;
+	}
+
+	if (session_close_out.header.status != ME_HDCP_STATUS_SUCCESS) {
+		dev_dbg(dev, "Session Close Failed. status: 0x%X\n",
+			session_close_out.header.status);
+		return -EIO;
+	}
+
+	return 0;
+}
+
 static const __attribute__((unused))
 struct i915_hdcp_component_ops mei_hdcp_ops = {
 	.owner = THIS_MODULE,
@@ -673,7 +726,7 @@ struct i915_hdcp_component_ops mei_hdcp_ops = {
 				mei_hdcp_repeater_check_flow_prepare_ack,
 	.verify_mprime = mei_hdcp_verify_mprime,
 	.enable_hdcp_authentication = mei_hdcp_enable_authentication,
-	.close_hdcp_session = NULL,
+	.close_hdcp_session = mei_hdcp_close_session,
 };
 
 static int mei_hdcp_probe(struct mei_cl_device *cldev,

commit 5e23491175eed8f9546491b5512ff62c1ea62dd3
Author: Ramalingam C <ramalingam.c@intel.com>
Date:   Thu Feb 21 23:42:07 2019 +0530

    misc/mei/hdcp: Enabling the HDCP authentication
    
    Request to ME to configure a port as authenticated.
    
    On Success, ME FW will mark the port as authenticated and provides
    HDCP cipher with the encryption keys.
    
    Enabling the Authentication can be requested once all stages of
    HDCP2.2 authentication is completed by interacting with ME FW.
    
    Only after this stage, driver can enable the HDCP encryption for
    the port, through HW registers.
    
    v2: Rebased.
    v3:
      cldev is passed as first parameter [Tomas]
      Redundant comments and cast are removed [Tomas]
    v4:
      %zd for ssize_t [Alexander]
      %s/return -1/return -EIO [Alexander]
      Style and typos fixed [Uma]
    v5: Rebased.
    v6:
      Collected the Rb-ed by.
      Rebased.
    v7:
      Adjust to the new mei interface.
      Fix for Kdoc.
    v8:
      K-Doc addition. [Tomas]
    v9:
      renamed func as mei_hdcp_* [Tomas]
      Inline function is defined for DDI index [Tomas]
    v10:
      K-Doc fix. [Tomas]
    v11:
      Rebased.
    
    Signed-off-by: Ramalingam C <ramalingam.c@intel.com>
    Reviewed-by: Uma Shankar <uma.shankar@intel.com>
    Acked-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/1550772730-23280-14-git-send-email-ramalingam.c@intel.com

diff --git a/drivers/misc/mei/hdcp/mei_hdcp.c b/drivers/misc/mei/hdcp/mei_hdcp.c
index 4bcb1ddeac1c..1e8c6f1ee4a5 100644
--- a/drivers/misc/mei/hdcp/mei_hdcp.c
+++ b/drivers/misc/mei/hdcp/mei_hdcp.c
@@ -605,6 +605,59 @@ static int mei_hdcp_verify_mprime(struct device *dev,
 	return 0;
 }
 
+/**
+ * mei_hdcp_enable_authentication() - Mark a port as authenticated
+ * through ME FW
+ * @dev: device corresponding to the mei_cl_device
+ * @data: Intel HW specific hdcp data
+ *
+ * Return: 0 on Success, <0 on Failure
+ */
+static int mei_hdcp_enable_authentication(struct device *dev,
+					  struct hdcp_port_data *data)
+{
+	struct wired_cmd_enable_auth_in enable_auth_in = { { 0 } };
+	struct wired_cmd_enable_auth_out enable_auth_out = { { 0 } };
+	struct mei_cl_device *cldev;
+	ssize_t byte;
+
+	if (!dev || !data)
+		return -EINVAL;
+
+	cldev = to_mei_cl_device(dev);
+
+	enable_auth_in.header.api_version = HDCP_API_VERSION;
+	enable_auth_in.header.command_id = WIRED_ENABLE_AUTH;
+	enable_auth_in.header.status = ME_HDCP_STATUS_SUCCESS;
+	enable_auth_in.header.buffer_len = WIRED_CMD_BUF_LEN_ENABLE_AUTH_IN;
+
+	enable_auth_in.port.integrated_port_type = data->port_type;
+	enable_auth_in.port.physical_port = mei_get_ddi_index(data->port);
+	enable_auth_in.stream_type = data->streams[0].stream_type;
+
+	byte = mei_cldev_send(cldev, (u8 *)&enable_auth_in,
+			      sizeof(enable_auth_in));
+	if (byte < 0) {
+		dev_dbg(dev, "mei_cldev_send failed. %zd\n", byte);
+		return byte;
+	}
+
+	byte = mei_cldev_recv(cldev, (u8 *)&enable_auth_out,
+			      sizeof(enable_auth_out));
+	if (byte < 0) {
+		dev_dbg(dev, "mei_cldev_recv failed. %zd\n", byte);
+		return byte;
+	}
+
+	if (enable_auth_out.header.status != ME_HDCP_STATUS_SUCCESS) {
+		dev_dbg(dev, "ME cmd 0x%08X failed. status: 0x%X\n",
+			WIRED_ENABLE_AUTH, enable_auth_out.header.status);
+		return -EIO;
+	}
+
+	return 0;
+}
+
 static const __attribute__((unused))
 struct i915_hdcp_component_ops mei_hdcp_ops = {
 	.owner = THIS_MODULE,
@@ -619,7 +672,7 @@ struct i915_hdcp_component_ops mei_hdcp_ops = {
 	.repeater_check_flow_prepare_ack =
 				mei_hdcp_repeater_check_flow_prepare_ack,
 	.verify_mprime = mei_hdcp_verify_mprime,
-	.enable_hdcp_authentication = NULL,
+	.enable_hdcp_authentication = mei_hdcp_enable_authentication,
 	.close_hdcp_session = NULL,
 };
 

commit 0a1af1b5c18d71b3e2eef7f46386c655170d6001
Author: Ramalingam C <ramalingam.c@intel.com>
Date:   Thu Feb 21 23:42:06 2019 +0530

    misc/mei/hdcp: Verify M_prime
    
    Request to ME to verify the M_Prime received from the HDCP sink.
    
    ME FW will calculate the M and compare with M_prime received
    as part of RepeaterAuth_Stream_Ready, which is HDCP2.2 protocol msg.
    
    On successful completion of this stage, downstream propagation of
    the stream management info is completed.
    
    v2: Rebased.
    v3:
      cldev is passed as first parameter [Tomas]
      Redundant comments and cast are removed [Tomas]
    v4:
      %zd for ssize_t [Alexander]
      %s/return -1/return -EIO [Alexander]
      endianness conversion func is moved to drm_hdcp.h [Uma]
    v5: Rebased.
    v6:
      Collected the Rb-ed by.
      Rebasing.
    v7:
      Adjust to the new mei interface.
      Fix for Kdoc.
    v8:
      K-Doc addition. [Tomas]
      drm_hdcp2_u32_to_seq_num() is used for u32 to seq_num.
    v9:
      renamed func as mei_hdcp_* [Tomas]
      Inline function is defined for DDI index [Tomas]
    v10:
      K-Doc fix. [Tomas]
    v11:
      %s/__swab16/cpu_to_be16 [Tomas]
    
    Signed-off-by: Ramalingam C <ramalingam.c@intel.com>
    Reviewed-by: Uma Shankar <uma.shankar@intel.com>
    Acked-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/1550772730-23280-13-git-send-email-ramalingam.c@intel.com

diff --git a/drivers/misc/mei/hdcp/mei_hdcp.c b/drivers/misc/mei/hdcp/mei_hdcp.c
index e541d0d290e3..4bcb1ddeac1c 100644
--- a/drivers/misc/mei/hdcp/mei_hdcp.c
+++ b/drivers/misc/mei/hdcp/mei_hdcp.c
@@ -540,6 +540,71 @@ mei_hdcp_repeater_check_flow_prepare_ack(struct device *dev,
 	return 0;
 }
 
+/**
+ * mei_hdcp_verify_mprime() - Verify mprime.
+ * @dev: device corresponding to the mei_cl_device
+ * @data: Intel HW specific hdcp data
+ * @stream_ready: RepeaterAuth_Stream_Ready msg for ME FW verification.
+ *
+ * Return: 0 on Success, <0 on Failure
+ */
+static int mei_hdcp_verify_mprime(struct device *dev,
+				  struct hdcp_port_data *data,
+				  struct hdcp2_rep_stream_ready *stream_ready)
+{
+	struct wired_cmd_repeater_auth_stream_req_in
+					verify_mprime_in = { { 0 } };
+	struct wired_cmd_repeater_auth_stream_req_out
+					verify_mprime_out = { { 0 } };
+	struct mei_cl_device *cldev;
+	ssize_t byte;
+
+	if (!dev || !stream_ready || !data)
+		return -EINVAL;
+
+	cldev = to_mei_cl_device(dev);
+
+	verify_mprime_in.header.api_version = HDCP_API_VERSION;
+	verify_mprime_in.header.command_id = WIRED_REPEATER_AUTH_STREAM_REQ;
+	verify_mprime_in.header.status = ME_HDCP_STATUS_SUCCESS;
+	verify_mprime_in.header.buffer_len =
+			WIRED_CMD_BUF_LEN_REPEATER_AUTH_STREAM_REQ_MIN_IN;
+
+	verify_mprime_in.port.integrated_port_type = data->port_type;
+	verify_mprime_in.port.physical_port = mei_get_ddi_index(data->port);
+
+	memcpy(verify_mprime_in.m_prime, stream_ready->m_prime,
+	       HDCP_2_2_MPRIME_LEN);
+	drm_hdcp2_u32_to_seq_num(verify_mprime_in.seq_num_m, data->seq_num_m);
+	memcpy(verify_mprime_in.streams, data->streams,
+	       (data->k * sizeof(struct hdcp2_streamid_type)));
+
+	verify_mprime_in.k = cpu_to_be16(data->k);
+
+	byte = mei_cldev_send(cldev, (u8 *)&verify_mprime_in,
+			      sizeof(verify_mprime_in));
+	if (byte < 0) {
+		dev_dbg(dev, "mei_cldev_send failed. %zd\n", byte);
+		return byte;
+	}
+
+	byte = mei_cldev_recv(cldev, (u8 *)&verify_mprime_out,
+			      sizeof(verify_mprime_out));
+	if (byte < 0) {
+		dev_dbg(dev, "mei_cldev_recv failed. %zd\n", byte);
+		return byte;
+	}
+
+	if (verify_mprime_out.header.status != ME_HDCP_STATUS_SUCCESS) {
+		dev_dbg(dev, "ME cmd 0x%08X failed. status: 0x%X\n",
+			WIRED_REPEATER_AUTH_STREAM_REQ,
+			verify_mprime_out.header.status);
+		return -EIO;
+	}
+
+	return 0;
+}
+
 static const __attribute__((unused))
 struct i915_hdcp_component_ops mei_hdcp_ops = {
 	.owner = THIS_MODULE,
@@ -553,7 +618,7 @@ struct i915_hdcp_component_ops mei_hdcp_ops = {
 	.get_session_key = mei_hdcp_get_session_key,
 	.repeater_check_flow_prepare_ack =
 				mei_hdcp_repeater_check_flow_prepare_ack,
-	.verify_mprime = NULL,
+	.verify_mprime = mei_hdcp_verify_mprime,
 	.enable_hdcp_authentication = NULL,
 	.close_hdcp_session = NULL,
 };

commit f46ea842edae2365b69a9dc9d64ef4c9dfaff583
Author: Ramalingam C <ramalingam.c@intel.com>
Date:   Thu Feb 21 23:42:05 2019 +0530

    misc/mei/hdcp: Repeater topology verification and ack
    
    Request ME to verify the downstream topology information received.
    
    ME FW will validate the Repeaters receiver id list and
    downstream topology.
    
    On Success ME FW will provide the Least Significant
    128bits of VPrime, which forms the repeater ack.
    
    v2: Rebased.
    v3:
      cldev is passed as first parameter [Tomas]
      Redundant comments and cast are removed [Tomas]
    v4:
      %zd for ssize_t [Alexander]
      %s/return -1/return -EIO [Alexander]
      Style and typos fixed [Uma]
    v5: Rebased.
    v6: Rebasing.
    v7:
      Adjust to the new mei interface.
      Fix for Kdoc.
    v8:
      K-Doc addition. [Tomas]
    v9:
      renamed func as mei_hdcp_* [Tomas]
      Inline function is defined for DDI index [Tomas]
    v10:
      K-Doc fix. [Tomas]
    v11:
      Rebased.
    
    Signed-off-by: Ramalingam C <ramalingam.c@intel.com>
    Reviewed-by: Uma Shankar <uma.shankar@intel.com>
    Acked-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/1550772730-23280-12-git-send-email-ramalingam.c@intel.com

diff --git a/drivers/misc/mei/hdcp/mei_hdcp.c b/drivers/misc/mei/hdcp/mei_hdcp.c
index 9dc17654ffbc..e541d0d290e3 100644
--- a/drivers/misc/mei/hdcp/mei_hdcp.c
+++ b/drivers/misc/mei/hdcp/mei_hdcp.c
@@ -466,6 +466,80 @@ static int mei_hdcp_get_session_key(struct device *dev,
 	return 0;
 }
 
+/**
+ * mei_hdcp_repeater_check_flow_prepare_ack() - Validate the Downstream topology
+ * and prepare rep_ack.
+ * @dev: device corresponding to the mei_cl_device
+ * @data: Intel HW specific hdcp data
+ * @rep_topology: Receiver ID List to be validated
+ * @rep_send_ack : repeater ack from ME FW.
+ *
+ * Return: 0 on Success, <0 on Failure
+ */
+static int
+mei_hdcp_repeater_check_flow_prepare_ack(struct device *dev,
+					 struct hdcp_port_data *data,
+					 struct hdcp2_rep_send_receiverid_list
+							*rep_topology,
+					 struct hdcp2_rep_send_ack
+							*rep_send_ack)
+{
+	struct wired_cmd_verify_repeater_in verify_repeater_in = { { 0 } };
+	struct wired_cmd_verify_repeater_out verify_repeater_out = { { 0 } };
+	struct mei_cl_device *cldev;
+	ssize_t byte;
+
+	if (!dev || !rep_topology || !rep_send_ack || !data)
+		return -EINVAL;
+
+	cldev = to_mei_cl_device(dev);
+
+	verify_repeater_in.header.api_version = HDCP_API_VERSION;
+	verify_repeater_in.header.command_id = WIRED_VERIFY_REPEATER;
+	verify_repeater_in.header.status = ME_HDCP_STATUS_SUCCESS;
+	verify_repeater_in.header.buffer_len =
+					WIRED_CMD_BUF_LEN_VERIFY_REPEATER_IN;
+
+	verify_repeater_in.port.integrated_port_type = data->port_type;
+	verify_repeater_in.port.physical_port = mei_get_ddi_index(data->port);
+
+	memcpy(verify_repeater_in.rx_info, rep_topology->rx_info,
+	       HDCP_2_2_RXINFO_LEN);
+	memcpy(verify_repeater_in.seq_num_v, rep_topology->seq_num_v,
+	       HDCP_2_2_SEQ_NUM_LEN);
+	memcpy(verify_repeater_in.v_prime, rep_topology->v_prime,
+	       HDCP_2_2_V_PRIME_HALF_LEN);
+	memcpy(verify_repeater_in.receiver_ids, rep_topology->receiver_ids,
+	       HDCP_2_2_RECEIVER_IDS_MAX_LEN);
+
+	byte = mei_cldev_send(cldev, (u8 *)&verify_repeater_in,
+			      sizeof(verify_repeater_in));
+	if (byte < 0) {
+		dev_dbg(dev, "mei_cldev_send failed. %zd\n", byte);
+		return byte;
+	}
+
+	byte = mei_cldev_recv(cldev, (u8 *)&verify_repeater_out,
+			      sizeof(verify_repeater_out));
+	if (byte < 0) {
+		dev_dbg(dev, "mei_cldev_recv failed. %zd\n", byte);
+		return byte;
+	}
+
+	if (verify_repeater_out.header.status != ME_HDCP_STATUS_SUCCESS) {
+		dev_dbg(dev, "ME cmd 0x%08X failed. status: 0x%X\n",
+			WIRED_VERIFY_REPEATER,
+			verify_repeater_out.header.status);
+		return -EIO;
+	}
+
+	memcpy(rep_send_ack->v, verify_repeater_out.v,
+	       HDCP_2_2_V_PRIME_HALF_LEN);
+	rep_send_ack->msg_id = HDCP_2_2_REP_SEND_ACK;
+
+	return 0;
+}
+
 static const __attribute__((unused))
 struct i915_hdcp_component_ops mei_hdcp_ops = {
 	.owner = THIS_MODULE,
@@ -477,7 +551,8 @@ struct i915_hdcp_component_ops mei_hdcp_ops = {
 	.initiate_locality_check = mei_hdcp_initiate_locality_check,
 	.verify_lprime = mei_hdcp_verify_lprime,
 	.get_session_key = mei_hdcp_get_session_key,
-	.repeater_check_flow_prepare_ack = NULL,
+	.repeater_check_flow_prepare_ack =
+				mei_hdcp_repeater_check_flow_prepare_ack,
 	.verify_mprime = NULL,
 	.enable_hdcp_authentication = NULL,
 	.close_hdcp_session = NULL,

commit b491264fcad7a6f38f7ae496c95162c56cc53e2d
Author: Ramalingam C <ramalingam.c@intel.com>
Date:   Thu Feb 21 23:42:04 2019 +0530

    misc/mei/hdcp: Prepare Session Key
    
    Request to ME to prepare the encrypted session key.
    
    On Success, ME provides Encrypted session key. Function populates
    the HDCP2.2 authentication msg SKE_Send_Eks.
    
    v2: Rebased.
    v3:
      cldev is passed as first parameter [Tomas]
      Redundant comments and cast are removed [Tomas]
    v4:
      %zd for ssize_t [Alexander]
      %s/return -1/return -EIO [Alexander]
      Style fixed [Uma]
    v5: Rebased.
    v6:
      Collected the Rb-ed by.
      Rebasing.
    v7:
      Adjust to the new mei interface.
      Fix for Kdoc.
    v8:
      K-Doc addition. [Tomas]
    v9:
      renamed func as mei_hdcp_* [Tomas]
      Inline function is defined for DDI index [Tomas]
    v10:
      K-Doc fix. [Tomas]
    v11:
      Rebased.
    
    Signed-off-by: Ramalingam C <ramalingam.c@intel.com>
    Reviewed-by: Uma Shankar <uma.shankar@intel.com>
    Acked-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/1550772730-23280-11-git-send-email-ramalingam.c@intel.com

diff --git a/drivers/misc/mei/hdcp/mei_hdcp.c b/drivers/misc/mei/hdcp/mei_hdcp.c
index 03f8af257ecc..9dc17654ffbc 100644
--- a/drivers/misc/mei/hdcp/mei_hdcp.c
+++ b/drivers/misc/mei/hdcp/mei_hdcp.c
@@ -409,6 +409,63 @@ mei_hdcp_verify_lprime(struct device *dev, struct hdcp_port_data *data,
 	return 0;
 }
 
+/**
+ * mei_hdcp_get_session_key() - Prepare SKE_Send_Eks.
+ * @dev: device corresponding to the mei_cl_device
+ * @data: Intel HW specific hdcp data
+ * @ske_data: SKE_Send_Eks msg output from ME FW.
+ *
+ * Return: 0 on Success, <0 on Failure
+ */
+static int mei_hdcp_get_session_key(struct device *dev,
+				    struct hdcp_port_data *data,
+				    struct hdcp2_ske_send_eks *ske_data)
+{
+	struct wired_cmd_get_session_key_in get_skey_in = { { 0 } };
+	struct wired_cmd_get_session_key_out get_skey_out = { { 0 } };
+	struct mei_cl_device *cldev;
+	ssize_t byte;
+
+	if (!dev || !data || !ske_data)
+		return -EINVAL;
+
+	cldev = to_mei_cl_device(dev);
+
+	get_skey_in.header.api_version = HDCP_API_VERSION;
+	get_skey_in.header.command_id = WIRED_GET_SESSION_KEY;
+	get_skey_in.header.status = ME_HDCP_STATUS_SUCCESS;
+	get_skey_in.header.buffer_len = WIRED_CMD_BUF_LEN_GET_SESSION_KEY_IN;
+
+	get_skey_in.port.integrated_port_type = data->port_type;
+	get_skey_in.port.physical_port = mei_get_ddi_index(data->port);
+
+	byte = mei_cldev_send(cldev, (u8 *)&get_skey_in, sizeof(get_skey_in));
+	if (byte < 0) {
+		dev_dbg(dev, "mei_cldev_send failed. %zd\n", byte);
+		return byte;
+	}
+
+	byte = mei_cldev_recv(cldev, (u8 *)&get_skey_out, sizeof(get_skey_out));
+
+	if (byte < 0) {
+		dev_dbg(dev, "mei_cldev_recv failed. %zd\n", byte);
+		return byte;
+	}
+
+	if (get_skey_out.header.status != ME_HDCP_STATUS_SUCCESS) {
+		dev_dbg(dev, "ME cmd 0x%08X failed. status: 0x%X\n",
+			WIRED_GET_SESSION_KEY, get_skey_out.header.status);
+		return -EIO;
+	}
+
+	ske_data->msg_id = HDCP_2_2_SKE_SEND_EKS;
+	memcpy(ske_data->e_dkey_ks, get_skey_out.e_dkey_ks,
+	       HDCP_2_2_E_DKEY_KS_LEN);
+	memcpy(ske_data->riv, get_skey_out.r_iv, HDCP_2_2_RIV_LEN);
+
+	return 0;
+}
+
 static const __attribute__((unused))
 struct i915_hdcp_component_ops mei_hdcp_ops = {
 	.owner = THIS_MODULE,
@@ -419,7 +476,7 @@ struct i915_hdcp_component_ops mei_hdcp_ops = {
 	.store_pairing_info = mei_hdcp_store_pairing_info,
 	.initiate_locality_check = mei_hdcp_initiate_locality_check,
 	.verify_lprime = mei_hdcp_verify_lprime,
-	.get_session_key = NULL,
+	.get_session_key = mei_hdcp_get_session_key,
 	.repeater_check_flow_prepare_ack = NULL,
 	.verify_mprime = NULL,
 	.enable_hdcp_authentication = NULL,

commit 45479b67becd29492b5d53e73cba21d32ad5c391
Author: Ramalingam C <ramalingam.c@intel.com>
Date:   Thu Feb 21 23:42:03 2019 +0530

    misc/mei/hdcp: Verify L_prime
    
    Request to ME to verify the LPrime received from HDCP sink.
    
    On Success, ME FW will verify the received Lprime by calculating and
    comparing with L.
    
    This represents the completion of Locality Check.
    
    v2: Rebased.
    v3:
      cldev is passed as first parameter [Tomas]
      Redundant comments and cast are removed [Tomas]
    v4:
      %zd for ssize_t [Alexander]
      %s/return -1/return -EIO [Alexander]
      Style fixed [Uma]
    v5: Rebased.
    v6:
      Collected the Rb-ed by.
      Rebasing.
    v7:
      Adjust to the new mei interface.
      Fix for Kdoc.
    v8:
      K-Doc addition. [Tomas]
      memcpy for const length.
    v9:
      renamed func as mei_hdcp_* [Tomas]
      Inline function is defined for DDI index [Tomas]
    v10:
      K-Doc fix. [Tomas]
    v11:
      Rebased.
    
    Signed-off-by: Ramalingam C <ramalingam.c@intel.com>
    Reviewed-by: Uma Shankar <uma.shankar@intel.com>
    Acked-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/1550772730-23280-10-git-send-email-ramalingam.c@intel.com

diff --git a/drivers/misc/mei/hdcp/mei_hdcp.c b/drivers/misc/mei/hdcp/mei_hdcp.c
index 7c880efe9134..03f8af257ecc 100644
--- a/drivers/misc/mei/hdcp/mei_hdcp.c
+++ b/drivers/misc/mei/hdcp/mei_hdcp.c
@@ -351,6 +351,64 @@ mei_hdcp_initiate_locality_check(struct device *dev,
 	return 0;
 }
 
+/**
+ * mei_hdcp_verify_lprime() - Verify lprime.
+ * @dev: device corresponding to the mei_cl_device
+ * @data: Intel HW specific hdcp data
+ * @rx_lprime: LC_Send_L_prime msg for ME FW verification
+ *
+ * Return: 0 on Success, <0 on Failure
+ */
+static int
+mei_hdcp_verify_lprime(struct device *dev, struct hdcp_port_data *data,
+		       struct hdcp2_lc_send_lprime *rx_lprime)
+{
+	struct wired_cmd_validate_locality_in verify_lprime_in = { { 0 } };
+	struct wired_cmd_validate_locality_out verify_lprime_out = { { 0 } };
+	struct mei_cl_device *cldev;
+	ssize_t byte;
+
+	if (!dev || !data || !rx_lprime)
+		return -EINVAL;
+
+	cldev = to_mei_cl_device(dev);
+
+	verify_lprime_in.header.api_version = HDCP_API_VERSION;
+	verify_lprime_in.header.command_id = WIRED_VALIDATE_LOCALITY;
+	verify_lprime_in.header.status = ME_HDCP_STATUS_SUCCESS;
+	verify_lprime_in.header.buffer_len =
+					WIRED_CMD_BUF_LEN_VALIDATE_LOCALITY_IN;
+
+	verify_lprime_in.port.integrated_port_type = data->port_type;
+	verify_lprime_in.port.physical_port = mei_get_ddi_index(data->port);
+
+	memcpy(verify_lprime_in.l_prime, rx_lprime->l_prime,
+	       HDCP_2_2_L_PRIME_LEN);
+
+	byte = mei_cldev_send(cldev, (u8 *)&verify_lprime_in,
+			      sizeof(verify_lprime_in));
+	if (byte < 0) {
+		dev_dbg(dev, "mei_cldev_send failed. %zd\n", byte);
+		return byte;
+	}
+
+	byte = mei_cldev_recv(cldev, (u8 *)&verify_lprime_out,
+			      sizeof(verify_lprime_out));
+	if (byte < 0) {
+		dev_dbg(dev, "mei_cldev_recv failed. %zd\n", byte);
+		return byte;
+	}
+
+	if (verify_lprime_out.header.status != ME_HDCP_STATUS_SUCCESS) {
+		dev_dbg(dev, "ME cmd 0x%08X failed. status: 0x%X\n",
+			WIRED_VALIDATE_LOCALITY,
+			verify_lprime_out.header.status);
+		return -EIO;
+	}
+
+	return 0;
+}
+
 static const __attribute__((unused))
 struct i915_hdcp_component_ops mei_hdcp_ops = {
 	.owner = THIS_MODULE,
@@ -360,7 +418,7 @@ struct i915_hdcp_component_ops mei_hdcp_ops = {
 	.verify_hprime = mei_hdcp_verify_hprime,
 	.store_pairing_info = mei_hdcp_store_pairing_info,
 	.initiate_locality_check = mei_hdcp_initiate_locality_check,
-	.verify_lprime = NULL,
+	.verify_lprime = mei_hdcp_verify_lprime,
 	.get_session_key = NULL,
 	.repeater_check_flow_prepare_ack = NULL,
 	.verify_mprime = NULL,

commit 682932f3e144a09759facfc5d8fe186760b01f89
Author: Ramalingam C <ramalingam.c@intel.com>
Date:   Thu Feb 21 23:42:02 2019 +0530

    misc/mei/hdcp: Initiate Locality check
    
    Requests ME to start the second stage of HDCP2.2 authentication,
    called Locality Check.
    
    On Success, ME FW will provide LC_Init message to send to hdcp sink.
    
    v2: Rebased.
    v3:
      cldev is passed as first parameter [Tomas]
      Redundant comments and cast are removed [Tomas]
    v4:
      %zd used for ssize_t [Alexander]
      %s/return -1/return -EIO [Alexander]
      Style fixed [Uma]
    v5: Rebased.
    v6:
      Collected the Rb-ed by.
      Rebasing.
    v7:
      Adjust to the new mei interface.
      Fix for Kdoc.
    v8:
      K-Doc addition. [Tomas]
    v9:
      renamed func as mei_hdcp_* [Tomas]
      Inline function is defined for DDI index [Tomas]
    v10:
      K-Doc fix. [Tomas]
    v11:
      Rebased.
    
    Signed-off-by: Ramalingam C <ramalingam.c@intel.com>
    Reviewed-by: Uma Shankar <uma.shankar@intel.com>
    Acked-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/1550772730-23280-9-git-send-email-ramalingam.c@intel.com

diff --git a/drivers/misc/mei/hdcp/mei_hdcp.c b/drivers/misc/mei/hdcp/mei_hdcp.c
index d5fbb2dbba60..7c880efe9134 100644
--- a/drivers/misc/mei/hdcp/mei_hdcp.c
+++ b/drivers/misc/mei/hdcp/mei_hdcp.c
@@ -296,6 +296,61 @@ mei_hdcp_store_pairing_info(struct device *dev, struct hdcp_port_data *data,
 	return 0;
 }
 
+/**
+ * mei_hdcp_initiate_locality_check() - Prepare LC_Init
+ * @dev: device corresponding to the mei_cl_device
+ * @data: Intel HW specific hdcp data
+ * @lc_init_data: LC_Init msg output
+ *
+ * Return: 0 on Success, <0 on Failure
+ */
+static int
+mei_hdcp_initiate_locality_check(struct device *dev,
+				 struct hdcp_port_data *data,
+				 struct hdcp2_lc_init *lc_init_data)
+{
+	struct wired_cmd_init_locality_check_in lc_init_in = { { 0 } };
+	struct wired_cmd_init_locality_check_out lc_init_out = { { 0 } };
+	struct mei_cl_device *cldev;
+	ssize_t byte;
+
+	if (!dev || !data || !lc_init_data)
+		return -EINVAL;
+
+	cldev = to_mei_cl_device(dev);
+
+	lc_init_in.header.api_version = HDCP_API_VERSION;
+	lc_init_in.header.command_id = WIRED_INIT_LOCALITY_CHECK;
+	lc_init_in.header.status = ME_HDCP_STATUS_SUCCESS;
+	lc_init_in.header.buffer_len = WIRED_CMD_BUF_LEN_INIT_LOCALITY_CHECK_IN;
+
+	lc_init_in.port.integrated_port_type = data->port_type;
+	lc_init_in.port.physical_port = mei_get_ddi_index(data->port);
+
+	byte = mei_cldev_send(cldev, (u8 *)&lc_init_in, sizeof(lc_init_in));
+	if (byte < 0) {
+		dev_dbg(dev, "mei_cldev_send failed. %zd\n", byte);
+		return byte;
+	}
+
+	byte = mei_cldev_recv(cldev, (u8 *)&lc_init_out, sizeof(lc_init_out));
+	if (byte < 0) {
+		dev_dbg(dev, "mei_cldev_recv failed. %zd\n", byte);
+		return byte;
+	}
+
+	if (lc_init_out.header.status != ME_HDCP_STATUS_SUCCESS) {
+		dev_dbg(dev, "ME cmd 0x%08X Failed. status: 0x%X\n",
+			WIRED_INIT_LOCALITY_CHECK, lc_init_out.header.status);
+		return -EIO;
+	}
+
+	lc_init_data->msg_id = HDCP_2_2_LC_INIT;
+	memcpy(lc_init_data->r_n, lc_init_out.r_n, HDCP_2_2_RN_LEN);
+
+	return 0;
+}
+
 static const __attribute__((unused))
 struct i915_hdcp_component_ops mei_hdcp_ops = {
 	.owner = THIS_MODULE,
@@ -304,7 +359,7 @@ struct i915_hdcp_component_ops mei_hdcp_ops = {
 				mei_hdcp_verify_receiver_cert_prepare_km,
 	.verify_hprime = mei_hdcp_verify_hprime,
 	.store_pairing_info = mei_hdcp_store_pairing_info,
-	.initiate_locality_check = NULL,
+	.initiate_locality_check = mei_hdcp_initiate_locality_check,
 	.verify_lprime = NULL,
 	.get_session_key = NULL,
 	.repeater_check_flow_prepare_ack = NULL,

commit 6a1a00a30e3a41c8e9a9fc78a6153608f326114d
Author: Ramalingam C <ramalingam.c@intel.com>
Date:   Thu Feb 21 23:42:01 2019 +0530

    misc/mei/hdcp: Store the HDCP Pairing info
    
    Provides Pairing info to ME to store.
    
    Pairing is a process to fast track the subsequent authentication
    with the same HDCP sink.
    
    On Success, received HDCP pairing info is stored in non-volatile
    memory of ME.
    
    v2: Rebased.
    v3:
      cldev is passed as first parameter [Tomas]
      Redundant comments and cast are removed [Tomas]
    v4:
      %zd for ssize_t [Alexander]
      %s/return -1/return -EIO [Alexander]
      Style fixed [Uma]
    v5: Rebased.
    v6:
      Collected the Rb-ed by.
      Rebasing.
    v7:
      Adjust to the new mei interface.
      Fix for Kdoc.
    v8:
      K-Doc addition. [Tomas]
      memcpy for const length.
    v9:
      renamed func as mei_hdcp_* [Tomas]
      Inline function is defined for DDI index [Tomas]
    v10:
      K-Doc fix. [Tomas]
    v11:
      Rebased.
    
    Signed-off-by: Ramalingam C <ramalingam.c@intel.com>
    Reviewed-by: Uma Shankar <uma.shankar@intel.com>
    Acked-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/1550772730-23280-8-git-send-email-ramalingam.c@intel.com

diff --git a/drivers/misc/mei/hdcp/mei_hdcp.c b/drivers/misc/mei/hdcp/mei_hdcp.c
index 37e854d7240e..d5fbb2dbba60 100644
--- a/drivers/misc/mei/hdcp/mei_hdcp.c
+++ b/drivers/misc/mei/hdcp/mei_hdcp.c
@@ -238,6 +238,64 @@ mei_hdcp_verify_hprime(struct device *dev, struct hdcp_port_data *data,
 	return 0;
 }
 
+/**
+ * mei_hdcp_store_pairing_info() - Store pairing info received at ME FW
+ * @dev: device corresponding to the mei_cl_device
+ * @data: Intel HW specific hdcp data
+ * @pairing_info: AKE_Send_Pairing_Info msg input to ME FW
+ *
+ * Return: 0 on Success, <0 on Failure
+ */
+static int
+mei_hdcp_store_pairing_info(struct device *dev, struct hdcp_port_data *data,
+			    struct hdcp2_ake_send_pairing_info *pairing_info)
+{
+	struct wired_cmd_ake_send_pairing_info_in pairing_info_in = { { 0 } };
+	struct wired_cmd_ake_send_pairing_info_out pairing_info_out = { { 0 } };
+	struct mei_cl_device *cldev;
+	ssize_t byte;
+
+	if (!dev || !data || !pairing_info)
+		return -EINVAL;
+
+	cldev = to_mei_cl_device(dev);
+
+	pairing_info_in.header.api_version = HDCP_API_VERSION;
+	pairing_info_in.header.command_id = WIRED_AKE_SEND_PAIRING_INFO;
+	pairing_info_in.header.status = ME_HDCP_STATUS_SUCCESS;
+	pairing_info_in.header.buffer_len =
+					WIRED_CMD_BUF_LEN_SEND_PAIRING_INFO_IN;
+
+	pairing_info_in.port.integrated_port_type = data->port_type;
+	pairing_info_in.port.physical_port = mei_get_ddi_index(data->port);
+
+	memcpy(pairing_info_in.e_kh_km, pairing_info->e_kh_km,
+	       HDCP_2_2_E_KH_KM_LEN);
+
+	byte = mei_cldev_send(cldev, (u8 *)&pairing_info_in,
+			      sizeof(pairing_info_in));
+	if (byte < 0) {
+		dev_dbg(dev, "mei_cldev_send failed. %zd\n", byte);
+		return byte;
+	}
+
+	byte = mei_cldev_recv(cldev, (u8 *)&pairing_info_out,
+			      sizeof(pairing_info_out));
+	if (byte < 0) {
+		dev_dbg(dev, "mei_cldev_recv failed. %zd\n", byte);
+		return byte;
+	}
+
+	if (pairing_info_out.header.status != ME_HDCP_STATUS_SUCCESS) {
+		dev_dbg(dev, "ME cmd 0x%08X failed. Status: 0x%X\n",
+			WIRED_AKE_SEND_PAIRING_INFO,
+			pairing_info_out.header.status);
+		return -EIO;
+	}
+
+	return 0;
+}
+
 static const __attribute__((unused))
 struct i915_hdcp_component_ops mei_hdcp_ops = {
 	.owner = THIS_MODULE,
@@ -245,7 +303,7 @@ struct i915_hdcp_component_ops mei_hdcp_ops = {
 	.verify_receiver_cert_prepare_km =
 				mei_hdcp_verify_receiver_cert_prepare_km,
 	.verify_hprime = mei_hdcp_verify_hprime,
-	.store_pairing_info = NULL,
+	.store_pairing_info = mei_hdcp_store_pairing_info,
 	.initiate_locality_check = NULL,
 	.verify_lprime = NULL,
 	.get_session_key = NULL,

commit a7dcbed2bb041af83ca2f372b1403efe9f5f844e
Author: Ramalingam C <ramalingam.c@intel.com>
Date:   Thu Feb 21 23:42:00 2019 +0530

    misc/mei/hdcp: Verify H_prime
    
    Requests for the verification of AKE_Send_H_prime.
    
    ME will calculate the H and comparing it with received H_Prime.
    The result will be returned as status.
    
    Here AKE_Send_H_prime is a HDCP2.2 Authentication msg.
    
    v2: Rebased.
    v3:
      cldev is passed as first parameter [Tomas]
      Redundant comments and cast are removed [Tomas]
    v4:
      %zd for ssize_t [Alexander]
      %s/return -1/return -EIO [Alexander]
      Styles and typos fixed [Uma]
    v5: Rebased.
    v6:
      Collected the Rb-ed by.
      Rebasing.
    v7:
      Adjust to the new mei interface.
      Fix for Kdoc.
    v8:
      K-Doc Addition [Tomas]
      memcpy for const length.
    v9:
      renamed func as mei_hdcp_* [Tomas]
      Inline function is defined for DDI index [Tomas]
    v10:
      K-Doc fix. [Tomas]
    v11:
      Rebased.
    
    Signed-off-by: Ramalingam C <ramalingam.c@intel.com>
    Reviewed-by: Uma Shankar <uma.shankar@intel.com>
    Acked-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/1550772730-23280-7-git-send-email-ramalingam.c@intel.com

diff --git a/drivers/misc/mei/hdcp/mei_hdcp.c b/drivers/misc/mei/hdcp/mei_hdcp.c
index fc2a5ce8b156..37e854d7240e 100644
--- a/drivers/misc/mei/hdcp/mei_hdcp.c
+++ b/drivers/misc/mei/hdcp/mei_hdcp.c
@@ -182,13 +182,69 @@ mei_hdcp_verify_receiver_cert_prepare_km(struct device *dev,
 	return 0;
 }
 
+/**
+ * mei_hdcp_verify_hprime() - Verify AKE_Send_H_prime at ME FW.
+ * @dev: device corresponding to the mei_cl_device
+ * @data: Intel HW specific hdcp data
+ * @rx_hprime: AKE_Send_H_prime msg for ME FW verification
+ *
+ * Return: 0 on Success, <0 on Failure
+ */
+static int
+mei_hdcp_verify_hprime(struct device *dev, struct hdcp_port_data *data,
+		       struct hdcp2_ake_send_hprime *rx_hprime)
+{
+	struct wired_cmd_ake_send_hprime_in send_hprime_in = { { 0 } };
+	struct wired_cmd_ake_send_hprime_out send_hprime_out = { { 0 } };
+	struct mei_cl_device *cldev;
+	ssize_t byte;
+
+	if (!dev || !data || !rx_hprime)
+		return -EINVAL;
+
+	cldev = to_mei_cl_device(dev);
+
+	send_hprime_in.header.api_version = HDCP_API_VERSION;
+	send_hprime_in.header.command_id = WIRED_AKE_SEND_HPRIME;
+	send_hprime_in.header.status = ME_HDCP_STATUS_SUCCESS;
+	send_hprime_in.header.buffer_len = WIRED_CMD_BUF_LEN_AKE_SEND_HPRIME_IN;
+
+	send_hprime_in.port.integrated_port_type = data->port_type;
+	send_hprime_in.port.physical_port = mei_get_ddi_index(data->port);
+
+	memcpy(send_hprime_in.h_prime, rx_hprime->h_prime,
+	       HDCP_2_2_H_PRIME_LEN);
+
+	byte = mei_cldev_send(cldev, (u8 *)&send_hprime_in,
+			      sizeof(send_hprime_in));
+	if (byte < 0) {
+		dev_dbg(dev, "mei_cldev_send failed. %zd\n", byte);
+		return byte;
+	}
+
+	byte = mei_cldev_recv(cldev, (u8 *)&send_hprime_out,
+			      sizeof(send_hprime_out));
+	if (byte < 0) {
+		dev_dbg(dev, "mei_cldev_recv failed. %zd\n", byte);
+		return byte;
+	}
+
+	if (send_hprime_out.header.status != ME_HDCP_STATUS_SUCCESS) {
+		dev_dbg(dev, "ME cmd 0x%08X Failed. Status: 0x%X\n",
+			WIRED_AKE_SEND_HPRIME, send_hprime_out.header.status);
+		return -EIO;
+	}
+
+	return 0;
+}
+
 static const __attribute__((unused))
 struct i915_hdcp_component_ops mei_hdcp_ops = {
 	.owner = THIS_MODULE,
 	.initiate_hdcp2_session = mei_hdcp_initiate_session,
 	.verify_receiver_cert_prepare_km =
 				mei_hdcp_verify_receiver_cert_prepare_km,
-	.verify_hprime = NULL,
+	.verify_hprime = mei_hdcp_verify_hprime,
 	.store_pairing_info = NULL,
 	.initiate_locality_check = NULL,
 	.verify_lprime = NULL,

commit 39b71c2baa4ff5877f9de47f192db978769f2ac5
Author: Ramalingam C <ramalingam.c@intel.com>
Date:   Thu Feb 21 23:41:59 2019 +0530

    misc/mei/hdcp: Verify Receiver Cert and prepare km
    
    Requests for verification for receiver certification and also the
    preparation for next AKE auth message with km.
    
    On Success ME FW validate the HDCP2.2 receivers certificate and do the
    revocation check on the receiver ID. AKE_Stored_Km will be prepared if
    the receiver is already paired, else AKE_No_Stored_Km will be prepared.
    
    Here AKE_Stored_Km and AKE_No_Stored_Km are HDCP2.2 protocol msgs.
    
    v2: Rebased.
    v3:
      cldev is passed as first parameter [Tomas]
      Redundant comments and cast are removed [Tomas]
    v4:
      %zd is used for ssize_t [Alexander]
      %s/return -1/return -EIO [Alexander]
    v5: Rebased.
    v6:
      Collected the Rb-ed by.
      Rebasing.
    v7:
      Adjust to the new mei interface.
      Fix for Kdoc.
    v8:
      K-Doc Addition. [Tomas]
      memcpy for const length.
    v9:
      renamed func as mei_hdcp_* [Tomas]
      Inline function is defined for DDI index [Tomas]
    v10:
      Fixed the conversion of u8 to bool [Tomas]
      K-Doc fix [Tomas]
    v11:
      Rebased.
    
    Signed-off-by: Ramalingam C <ramalingam.c@intel.com>
    Reviewed-by: Uma Shankar <uma.shankar@intel.com>
    Acked-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/1550772730-23280-6-git-send-email-ramalingam.c@intel.com

diff --git a/drivers/misc/mei/hdcp/mei_hdcp.c b/drivers/misc/mei/hdcp/mei_hdcp.c
index e2587f8e8b94..fc2a5ce8b156 100644
--- a/drivers/misc/mei/hdcp/mei_hdcp.c
+++ b/drivers/misc/mei/hdcp/mei_hdcp.c
@@ -102,11 +102,92 @@ mei_hdcp_initiate_session(struct device *dev, struct hdcp_port_data *data,
 	return 0;
 }
 
+/**
+ * mei_hdcp_verify_receiver_cert_prepare_km() - Verify the Receiver Certificate
+ * AKE_Send_Cert and prepare AKE_Stored_Km/AKE_No_Stored_Km
+ * @dev: device corresponding to the mei_cl_device
+ * @data: Intel HW specific hdcp data
+ * @rx_cert: AKE_Send_Cert for verification
+ * @km_stored: Pairing status flag output
+ * @ek_pub_km: AKE_Stored_Km/AKE_No_Stored_Km output msg
+ * @msg_sz : size of AKE_XXXXX_Km output msg
+ *
+ * Return: 0 on Success, <0 on Failure
+ */
+static int
+mei_hdcp_verify_receiver_cert_prepare_km(struct device *dev,
+					 struct hdcp_port_data *data,
+					 struct hdcp2_ake_send_cert *rx_cert,
+					 bool *km_stored,
+					 struct hdcp2_ake_no_stored_km
+								*ek_pub_km,
+					 size_t *msg_sz)
+{
+	struct wired_cmd_verify_receiver_cert_in verify_rxcert_in = { { 0 } };
+	struct wired_cmd_verify_receiver_cert_out verify_rxcert_out = { { 0 } };
+	struct mei_cl_device *cldev;
+	ssize_t byte;
+
+	if (!dev || !data || !rx_cert || !km_stored || !ek_pub_km || !msg_sz)
+		return -EINVAL;
+
+	cldev = to_mei_cl_device(dev);
+
+	verify_rxcert_in.header.api_version = HDCP_API_VERSION;
+	verify_rxcert_in.header.command_id = WIRED_VERIFY_RECEIVER_CERT;
+	verify_rxcert_in.header.status = ME_HDCP_STATUS_SUCCESS;
+	verify_rxcert_in.header.buffer_len =
+				WIRED_CMD_BUF_LEN_VERIFY_RECEIVER_CERT_IN;
+
+	verify_rxcert_in.port.integrated_port_type = data->port_type;
+	verify_rxcert_in.port.physical_port = mei_get_ddi_index(data->port);
+
+	verify_rxcert_in.cert_rx = rx_cert->cert_rx;
+	memcpy(verify_rxcert_in.r_rx, &rx_cert->r_rx, HDCP_2_2_RRX_LEN);
+	memcpy(verify_rxcert_in.rx_caps, rx_cert->rx_caps, HDCP_2_2_RXCAPS_LEN);
+
+	byte = mei_cldev_send(cldev, (u8 *)&verify_rxcert_in,
+			      sizeof(verify_rxcert_in));
+	if (byte < 0) {
+		dev_dbg(dev, "mei_cldev_send failed: %zd\n", byte);
+		return byte;
+	}
+
+	byte = mei_cldev_recv(cldev, (u8 *)&verify_rxcert_out,
+			      sizeof(verify_rxcert_out));
+	if (byte < 0) {
+		dev_dbg(dev, "mei_cldev_recv failed: %zd\n", byte);
+		return byte;
+	}
+
+	if (verify_rxcert_out.header.status != ME_HDCP_STATUS_SUCCESS) {
+		dev_dbg(dev, "ME cmd 0x%08X Failed. Status: 0x%X\n",
+			WIRED_VERIFY_RECEIVER_CERT,
+			verify_rxcert_out.header.status);
+		return -EIO;
+	}
+
+	*km_stored = !!verify_rxcert_out.km_stored;
+	if (verify_rxcert_out.km_stored) {
+		ek_pub_km->msg_id = HDCP_2_2_AKE_STORED_KM;
+		*msg_sz = sizeof(struct hdcp2_ake_stored_km);
+	} else {
+		ek_pub_km->msg_id = HDCP_2_2_AKE_NO_STORED_KM;
+		*msg_sz = sizeof(struct hdcp2_ake_no_stored_km);
+	}
+
+	memcpy(ek_pub_km->e_kpub_km, &verify_rxcert_out.ekm_buff,
+	       sizeof(verify_rxcert_out.ekm_buff));
+
+	return 0;
+}
+
 static const __attribute__((unused))
 struct i915_hdcp_component_ops mei_hdcp_ops = {
 	.owner = THIS_MODULE,
 	.initiate_hdcp2_session = mei_hdcp_initiate_session,
-	.verify_receiver_cert_prepare_km = NULL,
+	.verify_receiver_cert_prepare_km =
+				mei_hdcp_verify_receiver_cert_prepare_km,
 	.verify_hprime = NULL,
 	.store_pairing_info = NULL,
 	.initiate_locality_check = NULL,

commit a37fb1e4730205ff5aac413a14ad4f34ecec3e0c
Author: Ramalingam C <ramalingam.c@intel.com>
Date:   Thu Feb 21 23:41:58 2019 +0530

    misc/mei/hdcp: Initiate Wired HDCP2.2 Tx Session
    
    Request ME FW to start the HDCP2.2 session for an intel port.
    Prepares payloads for command WIRED_INITIATE_HDCP2_SESSION and sends
    to ME FW.
    
    On Success, ME FW will start a HDCP2.2 session for the port and
    provides the content for HDCP2.2 AKE_Init message.
    
    v2: Rebased.
    v3:
      cldev is add as a separate parameter [Tomas]
      Redundant comment and typecast are removed [Tomas]
    v4:
      %zd is used for size [Alexander]
      %s/return -1/return -EIO [Alexander]
      Spellings in commit msg is fixed [Uma]
    v5: Rebased.
    v6:
      Collected the rb-ed by.
      Realigning the patches in the series.
    v7:
      Adjust to the new mei interface.
      Fix for kdoc.
    v8:
      K-Doc Addition.
      memcpy for const length.
    v9:
      s/mei_hdcp_ddi/mei_fw_ddi
      s/i915_port/mei_i915_port [Tomas]
      renamed func as mei_hdcp_* [Tomas]
      Instead of macro, inline func for ddi index is used. [Tomas]
    v10:
      Switch case for the coversion between i915_port to mei_ddi [Tomas]
      Kernel doc fix.
    v11:
      mei_hdcp_ops is defined as const. [Tomas]
    
    Signed-off-by: Ramalingam C <ramalingam.c@intel.com>
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Reviewed-by: Uma Shankar <uma.shankar@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/1550772730-23280-5-git-send-email-ramalingam.c@intel.com

diff --git a/drivers/misc/mei/hdcp/mei_hdcp.c b/drivers/misc/mei/hdcp/mei_hdcp.c
index 993af6106ddb..e2587f8e8b94 100644
--- a/drivers/misc/mei/hdcp/mei_hdcp.c
+++ b/drivers/misc/mei/hdcp/mei_hdcp.c
@@ -23,6 +23,100 @@
 #include <linux/slab.h>
 #include <linux/uuid.h>
 #include <linux/mei_cl_bus.h>
+#include <drm/drm_connector.h>
+#include <drm/i915_component.h>
+#include <drm/i915_mei_hdcp_interface.h>
+
+#include "mei_hdcp.h"
+
+static inline u8 mei_get_ddi_index(enum port port)
+{
+	switch (port) {
+	case PORT_A:
+		return MEI_DDI_A;
+	case PORT_B ... PORT_F:
+		return (u8)port;
+	default:
+		return MEI_DDI_INVALID_PORT;
+	}
+}
+
+/**
+ * mei_hdcp_initiate_session() - Initiate a Wired HDCP2.2 Tx Session in ME FW
+ * @dev: device corresponding to the mei_cl_device
+ * @data: Intel HW specific hdcp data
+ * @ake_data: AKE_Init msg output.
+ *
+ * Return:  0 on Success, <0 on Failure.
+ */
+static int
+mei_hdcp_initiate_session(struct device *dev, struct hdcp_port_data *data,
+			  struct hdcp2_ake_init *ake_data)
+{
+	struct wired_cmd_initiate_hdcp2_session_in session_init_in = { { 0 } };
+	struct wired_cmd_initiate_hdcp2_session_out
+						session_init_out = { { 0 } };
+	struct mei_cl_device *cldev;
+	ssize_t byte;
+
+	if (!dev || !data || !ake_data)
+		return -EINVAL;
+
+	cldev = to_mei_cl_device(dev);
+
+	session_init_in.header.api_version = HDCP_API_VERSION;
+	session_init_in.header.command_id = WIRED_INITIATE_HDCP2_SESSION;
+	session_init_in.header.status = ME_HDCP_STATUS_SUCCESS;
+	session_init_in.header.buffer_len =
+				WIRED_CMD_BUF_LEN_INITIATE_HDCP2_SESSION_IN;
+
+	session_init_in.port.integrated_port_type = data->port_type;
+	session_init_in.port.physical_port = mei_get_ddi_index(data->port);
+	session_init_in.protocol = data->protocol;
+
+	byte = mei_cldev_send(cldev, (u8 *)&session_init_in,
+			      sizeof(session_init_in));
+	if (byte < 0) {
+		dev_dbg(dev, "mei_cldev_send failed. %zd\n", byte);
+		return byte;
+	}
+
+	byte = mei_cldev_recv(cldev, (u8 *)&session_init_out,
+			      sizeof(session_init_out));
+	if (byte < 0) {
+		dev_dbg(dev, "mei_cldev_recv failed. %zd\n", byte);
+		return byte;
+	}
+
+	if (session_init_out.header.status != ME_HDCP_STATUS_SUCCESS) {
+		dev_dbg(dev, "ME cmd 0x%08X Failed. Status: 0x%X\n",
+			WIRED_INITIATE_HDCP2_SESSION,
+			session_init_out.header.status);
+		return -EIO;
+	}
+
+	ake_data->msg_id = HDCP_2_2_AKE_INIT;
+	ake_data->tx_caps = session_init_out.tx_caps;
+	memcpy(ake_data->r_tx, session_init_out.r_tx, HDCP_2_2_RTX_LEN);
+
+	return 0;
+}
+
+static const __attribute__((unused))
+struct i915_hdcp_component_ops mei_hdcp_ops = {
+	.owner = THIS_MODULE,
+	.initiate_hdcp2_session = mei_hdcp_initiate_session,
+	.verify_receiver_cert_prepare_km = NULL,
+	.verify_hprime = NULL,
+	.store_pairing_info = NULL,
+	.initiate_locality_check = NULL,
+	.verify_lprime = NULL,
+	.get_session_key = NULL,
+	.repeater_check_flow_prepare_ack = NULL,
+	.verify_mprime = NULL,
+	.enable_hdcp_authentication = NULL,
+	.close_hdcp_session = NULL,
+};
 
 static int mei_hdcp_probe(struct mei_cl_device *cldev,
 			  const struct mei_cl_device_id *id)

commit 64e9bbdd9588ad8b74c687a192540ba847895706
Author: Ramalingam C <ramalingam.c@intel.com>
Date:   Thu Feb 21 23:41:56 2019 +0530

    misc/mei/hdcp: Client driver for HDCP application
    
    ME FW contributes a vital role in HDCP2.2 authentication.
    HDCP2.2 driver needs to communicate to ME FW for each step of the
    HDCP2.2 authentication.
    
    ME FW prepare and HDCP2.2 authentication  parameters and encrypt them
    as per spec. With such parameter Driver prepares HDCP2.2 auth messages
    and communicate with HDCP2.2 sink.
    
    Similarly HDCP2.2 sink's response is shared with ME FW for decrypt and
    verification.
    
    Once All the steps of HDCP2.2 authentications are complete on driver's
    request ME FW will configure the port as authenticated and supply the
    HDCP keys to the Gen HW for encryption.
    
    Only after this stage HDCP2.2 driver can start the HDCP2.2 encryption
    for a port.
    
    ME FW is interfaced to kernel through MEI Bus Driver. To obtain the
    HDCP2.2 services from the ME FW through MEI Bus driver MEI Client
    Driver is developed.
    
    v2:
      hdcp files are moved to drivers/misc/mei/hdcp/ [Tomas]
    v3:
      Squashed the Kbuild support [Tomas]
      UUID renamed and Module License is modified [Tomas]
      drv_data is set to null at remove [Tomas]
    v4:
      Module name is changed to "MEI HDCP"
      I915 Selects the MEI_HDCP
    v5:
      Remove redundant text from the License header
      Fix malformed licence
      Removed the drv_data resetting.
    v6:
      K-Doc addition. [Tomas]
    v7:
      %s/UUID_LE/GUID_INIT [Tomas]
      GPL Ver is 2.0 than 2.0+ [Tomas]
    v8:
      Added more info into Kconfig addition [Tomas]
    
    Signed-off-by: Ramalingam C <ramalingam.c@intel.com>
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Acked-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: https://patchwork.freedesktop.org/patch/msgid/1550772730-23280-3-git-send-email-ramalingam.c@intel.com

diff --git a/drivers/misc/mei/hdcp/mei_hdcp.c b/drivers/misc/mei/hdcp/mei_hdcp.c
new file mode 100644
index 000000000000..993af6106ddb
--- /dev/null
+++ b/drivers/misc/mei/hdcp/mei_hdcp.c
@@ -0,0 +1,64 @@
+// SPDX-License-Identifier: (GPL-2.0)
+/*
+ * Copyright © 2019 Intel Corporation
+ *
+ * Mei_hdcp.c: HDCP client driver for mei bus
+ *
+ * Author:
+ * Ramalingam C <ramalingam.c@intel.com>
+ */
+
+/**
+ * DOC: MEI_HDCP Client Driver
+ *
+ * This is a client driver to the mei_bus to make the HDCP2.2 services of
+ * ME FW available for the interested consumers like I915.
+ *
+ * This module will act as a translation layer between HDCP protocol
+ * implementor(I915) and ME FW by translating HDCP2.2 authentication
+ * messages to ME FW command payloads and vice versa.
+ */
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/uuid.h>
+#include <linux/mei_cl_bus.h>
+
+static int mei_hdcp_probe(struct mei_cl_device *cldev,
+			  const struct mei_cl_device_id *id)
+{
+	int ret;
+
+	ret = mei_cldev_enable(cldev);
+	if (ret < 0)
+		dev_err(&cldev->dev, "mei_cldev_enable Failed. %d\n", ret);
+
+	return ret;
+}
+
+static int mei_hdcp_remove(struct mei_cl_device *cldev)
+{
+	return mei_cldev_disable(cldev);
+}
+
+#define MEI_UUID_HDCP GUID_INIT(0xB638AB7E, 0x94E2, 0x4EA2, 0xA5, \
+				0x52, 0xD1, 0xC5, 0x4B, 0x62, 0x7F, 0x04)
+
+static struct mei_cl_device_id mei_hdcp_tbl[] = {
+	{ .uuid = MEI_UUID_HDCP, .version = MEI_CL_VERSION_ANY },
+	{ }
+};
+MODULE_DEVICE_TABLE(mei, mei_hdcp_tbl);
+
+static struct mei_cl_driver mei_hdcp_driver = {
+	.id_table = mei_hdcp_tbl,
+	.name = KBUILD_MODNAME,
+	.probe = mei_hdcp_probe,
+	.remove	= mei_hdcp_remove,
+};
+
+module_mei_cl_driver(mei_hdcp_driver);
+
+MODULE_AUTHOR("Intel Corporation");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("MEI HDCP");
