commit 873e65bc09078e56eaa51af2c9c60da2fad6fdbf
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:15 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 167
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation version 2 of the license this program
      is distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details you should have received a copy of the gnu general
      public license along with this program if not write to the free
      software foundation inc 59 temple place suite 330 boston ma 02111
      1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 83 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070034.021731668@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/apds9802als.c b/drivers/misc/apds9802als.c
index d8ac036f01ab..6fff44b952bd 100644
--- a/drivers/misc/apds9802als.c
+++ b/drivers/misc/apds9802als.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * apds9802als.c - apds9802  ALS Driver
  *
@@ -5,20 +6,7 @@
  *
  *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; version 2 of the License.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
  * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- *
  */
 
 #include <linux/module.h>

commit 006dbb38d7469d7465b4ffcbf5beac961cee70df
Author: Arvind Yadav <arvind.yadav.cs@gmail.com>
Date:   Mon Aug 21 22:13:25 2017 +0530

    misc: apds9802als: constify i2c_device_id
    
    i2c_device_id are not supposed to change at runtime. All functions
    working with i2c_device_id provided by <linux/i2c.h> work with
    const i2c_device_id. So mark the non-const structs as const.
    
    Signed-off-by: Arvind Yadav <arvind.yadav.cs@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/apds9802als.c b/drivers/misc/apds9802als.c
index 05ee771793cd..d8ac036f01ab 100644
--- a/drivers/misc/apds9802als.c
+++ b/drivers/misc/apds9802als.c
@@ -298,7 +298,7 @@ static UNIVERSAL_DEV_PM_OPS(apds9802als_pm_ops, apds9802als_suspend,
 #define APDS9802ALS_PM_OPS NULL
 #endif	/* CONFIG_PM */
 
-static struct i2c_device_id apds9802als_id[] = {
+static const struct i2c_device_id apds9802als_id[] = {
 	{ DRIVER_NAME, 0 },
 	{ }
 };

commit 579e9a307256e550fe918485b828517ea3c5f2fb
Author: Arvind Yadav <arvind.yadav.cs@gmail.com>
Date:   Fri Aug 4 12:07:52 2017 +0530

    misc: apds9802als: constify attribute_group structures.
    
    attribute_group are not supposed to change at runtime. All functions
    working with attribute_group provided by <linux/sysfs.h> work with
    const attribute_group. So mark the non-const structs as const.
    
    Signed-off-by: Arvind Yadav <arvind.yadav.cs@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/apds9802als.c b/drivers/misc/apds9802als.c
index c6cc3dc8ae1f..05ee771793cd 100644
--- a/drivers/misc/apds9802als.c
+++ b/drivers/misc/apds9802als.c
@@ -197,7 +197,7 @@ static struct attribute *mid_att_als[] = {
 	NULL
 };
 
-static struct attribute_group m_als_gr = {
+static const struct attribute_group m_als_gr = {
 	.name = "apds9802als",
 	.attrs = mid_att_als
 };

commit e2527ec3690bc820e5b4288577f79945f4a22d77
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Tue Jan 21 16:23:07 2014 -0500

    drivers/misc: delete non-required instances of include <linux/init.h>
    
    None of these files are actually using any __init type directives
    and hence don't need to include <linux/init.h>.  Most are just a
    left over from __devinit and __cpuinit removal, or simply due to
    code getting copied from one driver to the next.
    
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/apds9802als.c b/drivers/misc/apds9802als.c
index 0c6e037153d2..c6cc3dc8ae1f 100644
--- a/drivers/misc/apds9802als.c
+++ b/drivers/misc/apds9802als.c
@@ -22,7 +22,6 @@
  */
 
 #include <linux/module.h>
-#include <linux/init.h>
 #include <linux/slab.h>
 #include <linux/i2c.h>
 #include <linux/err.h>

commit f7b41276b6b07f47c5f5212fa244385b0e3aaa30
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Tue Jun 4 13:15:16 2013 +0900

    misc: replace strict_strtoul() with kstrtoul()
    
    The usage of strict_strtoul() is not preferred, because
    strict_strtoul() is obsolete. Thus, kstrtoul() should be
    used.
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/apds9802als.c b/drivers/misc/apds9802als.c
index 5b5fd8416b3e..0c6e037153d2 100644
--- a/drivers/misc/apds9802als.c
+++ b/drivers/misc/apds9802als.c
@@ -126,8 +126,9 @@ static ssize_t als_sensing_range_store(struct device *dev,
 	int ret_val;
 	unsigned long val;
 
-	if (strict_strtoul(buf, 10, &val))
-		return -EINVAL;
+	ret_val = kstrtoul(buf, 10, &val);
+	if (ret_val)
+		return ret_val;
 
 	if (val < 4096)
 		val = 1;

commit 1c9354b0973a59a0292ec64e0b4dde7b9462931a
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Thu Apr 11 11:24:39 2013 +0200

    misc: apds9802als: Fix suspend/resume
    
    The apds9802als driver implements runtime pm and at the same time uses the
    legacy pm callbacks for suspend and resume. This does not work since the i2c
    core wont look at the legacy pm callbacks if a driver has the 'pm' field set.
    This patch fixes it by moving over to dev_pm_ops for suspend/resume as well.
    Since both runtime pm and suspend/resume behave the same way this can easily be
    done using the UNIVERSAL_DEV_PM_OPS macro.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Cc: Hong Liu <hong.liu@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/apds9802als.c b/drivers/misc/apds9802als.c
index d648b0893027..5b5fd8416b3e 100644
--- a/drivers/misc/apds9802als.c
+++ b/drivers/misc/apds9802als.c
@@ -272,19 +272,8 @@ static int apds9802als_remove(struct i2c_client *client)
 }
 
 #ifdef CONFIG_PM
-static int apds9802als_suspend(struct i2c_client *client, pm_message_t mesg)
-{
-	als_set_power_state(client, false);
-	return 0;
-}
-
-static int apds9802als_resume(struct i2c_client *client)
-{
-	als_set_default_config(client);
-	return 0;
-}
 
-static int apds9802als_runtime_suspend(struct device *dev)
+static int apds9802als_suspend(struct device *dev)
 {
 	struct i2c_client *client = to_i2c_client(dev);
 
@@ -292,7 +281,7 @@ static int apds9802als_runtime_suspend(struct device *dev)
 	return 0;
 }
 
-static int apds9802als_runtime_resume(struct device *dev)
+static int apds9802als_resume(struct device *dev)
 {
 	struct i2c_client *client = to_i2c_client(dev);
 
@@ -300,16 +289,12 @@ static int apds9802als_runtime_resume(struct device *dev)
 	return 0;
 }
 
-static const struct dev_pm_ops apds9802als_pm_ops = {
-	.runtime_suspend = apds9802als_runtime_suspend,
-	.runtime_resume = apds9802als_runtime_resume,
-};
+static UNIVERSAL_DEV_PM_OPS(apds9802als_pm_ops, apds9802als_suspend,
+	apds9802als_resume, NULL);
 
 #define APDS9802ALS_PM_OPS (&apds9802als_pm_ops)
 
 #else	/* CONFIG_PM */
-#define apds9802als_suspend NULL
-#define apds9802als_resume NULL
 #define APDS9802ALS_PM_OPS NULL
 #endif	/* CONFIG_PM */
 
@@ -327,8 +312,6 @@ static struct i2c_driver apds9802als_driver = {
 	},
 	.probe = apds9802als_probe,
 	.remove = apds9802als_remove,
-	.suspend = apds9802als_suspend,
-	.resume = apds9802als_resume,
 	.id_table = apds9802als_id,
 };
 

commit 486a5c28c2e7d6a80c393ac7d612b77d80447b84
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:26:02 2012 -0500

    misc: remove use of __devexit
    
    CONFIG_HOTPLUG is going away as an option so __devexit is no
    longer needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Cc: "Michał Mirosław" <mirq-linux@rere.qmqm.pl>
    Cc: Wolfram Sang <w.sang@pengutronix.de>
    Cc: Eric Piel <eric.piel@tremplin-utc.net>
    Cc: Jiri Slaby <jirislaby@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/apds9802als.c b/drivers/misc/apds9802als.c
index 0132d15a995c..d648b0893027 100644
--- a/drivers/misc/apds9802als.c
+++ b/drivers/misc/apds9802als.c
@@ -254,7 +254,7 @@ static int apds9802als_probe(struct i2c_client *client,
 	return res;
 }
 
-static int __devexit apds9802als_remove(struct i2c_client *client)
+static int apds9802als_remove(struct i2c_client *client)
 {
 	struct als_data *data = i2c_get_clientdata(client);
 

commit 2d6bed9ca93e98685bc5038d686984fd449cd978
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:21:23 2012 -0500

    drivers/misc: remove use of __devexit_p
    
    CONFIG_HOTPLUG is going away as an option so __devexit_p is no longer
    needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Cc: "Michał Mirosław" <mirq-linux@rere.qmqm.pl>
    Cc: Wolfram Sang <w.sang@pengutronix.de>
    Cc: Eric Piel <eric.piel@tremplin-utc.net>
    Cc: Jiri Slaby <jirislaby@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/apds9802als.c b/drivers/misc/apds9802als.c
index 94923d259910..0132d15a995c 100644
--- a/drivers/misc/apds9802als.c
+++ b/drivers/misc/apds9802als.c
@@ -326,7 +326,7 @@ static struct i2c_driver apds9802als_driver = {
 		.pm = APDS9802ALS_PM_OPS,
 	},
 	.probe = apds9802als_probe,
-	.remove = __devexit_p(apds9802als_remove),
+	.remove = apds9802als_remove,
 	.suspend = apds9802als_suspend,
 	.resume = apds9802als_resume,
 	.id_table = apds9802als_id,

commit 644a9d3b66e6983c2c1f3b24c3006d49b184c871
Author: Axel Lin <axel.lin@ingics.com>
Date:   Fri Nov 16 17:17:50 2012 +0800

    misc: apds9802als: Fix the logic checking timeout in als_wait_for_data_ready()
    
    In the case of timeout waiting for data ready, the retry variable is -1.
    This also fixes a bug: current code returns -ETIMEDOUT if latest retry success
    ( which means retry is 0 when exiting the while loop ).
    
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/apds9802als.c b/drivers/misc/apds9802als.c
index 0314773f6db3..94923d259910 100644
--- a/drivers/misc/apds9802als.c
+++ b/drivers/misc/apds9802als.c
@@ -68,7 +68,7 @@ static int als_wait_for_data_ready(struct device *dev)
 		ret = i2c_smbus_read_byte_data(client, 0x86);
 	} while (!(ret & 0x80) && retry--);
 
-	if (!retry) {
+	if (retry < 0) {
 		dev_warn(dev, "timeout waiting for data ready\n");
 		return -ETIMEDOUT;
 	}

commit a64fe2ed76614d37abb6966a67f4f39d10efba3c
Author: Axel Lin <axel.lin@gmail.com>
Date:   Sun Jan 22 15:36:45 2012 +0800

    MISC: convert drivers/misc/* to use module_i2c_driver()
    
    This patch converts the drivers in drivers/misc/* to use the
    module_i2c_driver() macro which makes the code smaller and a bit
    simpler.
    
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Cc: Michael Hennerich <hennerich@blackfin.uclinux.org>
    Cc: Anantha Narayanan <Anantha.Narayanan@intel.com>
    Cc: Hemanth V <hemanthv@ti.com>
    Cc: Christoph Mair <christoph.mair@gmail.com>
    Cc: Grant Likely <grant.likely@secretlab.ca>
    Cc: Ben Gardner <bgardner@wabtec.com>
    Cc: Minkyu Kang <mk7.kang@samsung.com>
    Cc: Kalhan Trisal <kalhan.trisal@intel.com>
    Cc: Darrick J. Wong <djwong@us.ibm.com>
    Cc: Daniel Mack <zonque@gmail.com>
    Cc: Rodolfo Giometti <giometti@linux.it>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/misc/apds9802als.c b/drivers/misc/apds9802als.c
index 81db7811cf68..0314773f6db3 100644
--- a/drivers/misc/apds9802als.c
+++ b/drivers/misc/apds9802als.c
@@ -332,17 +332,7 @@ static struct i2c_driver apds9802als_driver = {
 	.id_table = apds9802als_id,
 };
 
-static int __init sensor_apds9802als_init(void)
-{
-	return i2c_add_driver(&apds9802als_driver);
-}
-
-static void  __exit sensor_apds9802als_exit(void)
-{
-	i2c_del_driver(&apds9802als_driver);
-}
-module_init(sensor_apds9802als_init);
-module_exit(sensor_apds9802als_exit);
+module_i2c_driver(apds9802als_driver);
 
 MODULE_AUTHOR("Anantha Narayanan <Anantha.Narayanan@intel.com");
 MODULE_DESCRIPTION("Avago apds9802als ALS Driver");

commit 4e6735992392ecd393674119aef9ec7bff9be5b0
Author: Hong Liu <hong.liu@intel.com>
Date:   Tue Mar 22 16:33:59 2011 -0700

    drivers/misc/apds9802als.c: put the device into runtime suspend after resume()/probe() is handled
    
    Put the device into runtime suspend after resume()/probe() is handled by
    the PM core and the device core code.  No need to manually add them in
    each single driver.  And correct the runtime state in remove().
    
    Signed-off-by: Hong Liu <hong.liu@intel.com>
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/misc/apds9802als.c b/drivers/misc/apds9802als.c
index 644d4cd071cc..81db7811cf68 100644
--- a/drivers/misc/apds9802als.c
+++ b/drivers/misc/apds9802als.c
@@ -245,9 +245,8 @@ static int apds9802als_probe(struct i2c_client *client,
 	als_set_default_config(client);
 	mutex_init(&data->mutex);
 
+	pm_runtime_set_active(&client->dev);
 	pm_runtime_enable(&client->dev);
-	pm_runtime_get(&client->dev);
-	pm_runtime_put(&client->dev);
 
 	return res;
 als_error1:
@@ -255,12 +254,19 @@ static int apds9802als_probe(struct i2c_client *client,
 	return res;
 }
 
-static int apds9802als_remove(struct i2c_client *client)
+static int __devexit apds9802als_remove(struct i2c_client *client)
 {
 	struct als_data *data = i2c_get_clientdata(client);
 
+	pm_runtime_get_sync(&client->dev);
+
 	als_set_power_state(client, false);
 	sysfs_remove_group(&client->dev.kobj, &m_als_gr);
+
+	pm_runtime_disable(&client->dev);
+	pm_runtime_set_suspended(&client->dev);
+	pm_runtime_put_noidle(&client->dev);
+
 	kfree(data);
 	return 0;
 }
@@ -275,9 +281,6 @@ static int apds9802als_suspend(struct i2c_client *client, pm_message_t mesg)
 static int apds9802als_resume(struct i2c_client *client)
 {
 	als_set_default_config(client);
-
-	pm_runtime_get(&client->dev);
-	pm_runtime_put(&client->dev);
 	return 0;
 }
 
@@ -323,7 +326,7 @@ static struct i2c_driver apds9802als_driver = {
 		.pm = APDS9802ALS_PM_OPS,
 	},
 	.probe = apds9802als_probe,
-	.remove = apds9802als_remove,
+	.remove = __devexit_p(apds9802als_remove),
 	.suspend = apds9802als_suspend,
 	.resume = apds9802als_resume,
 	.id_table = apds9802als_id,

commit dc6641be0ea8819ef095fdcefc2b695611999a21
Author: Wolfram Sang <w.sang@pengutronix.de>
Date:   Mon Nov 15 22:40:38 2010 +0100

    i2c: Remove obsolete cleanup for clientdata
    
    A few new i2c-drivers came into the kernel which clear the clientdata-pointer
    on exit. This is obsolete meanwhile, so fix it and hope the word will spread.
    
    Signed-off-by: Wolfram Sang <w.sang@pengutronix.de>
    Acked-by: Alan Cox <alan@linux.intel.com>
    Acked-by: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Jean Delvare <khali@linux-fr.org>

diff --git a/drivers/misc/apds9802als.c b/drivers/misc/apds9802als.c
index 0ed09358027e..644d4cd071cc 100644
--- a/drivers/misc/apds9802als.c
+++ b/drivers/misc/apds9802als.c
@@ -251,7 +251,6 @@ static int apds9802als_probe(struct i2c_client *client,
 
 	return res;
 als_error1:
-	i2c_set_clientdata(client, NULL);
 	kfree(data);
 	return res;
 }

commit 1093736b3c34319b8f1825a4423414d9cf397d73
Author: Vasiliy Kulikov <segooon@gmail.com>
Date:   Thu Nov 11 14:05:11 2010 -0800

    drivers/misc/apds9802als.c: fix signedness bug
    
    i2c_smbus_read_byte_data() may return negative error code.  This is not
    seen to als_sensing_range_store() as the result is stored in unsigned int.
    
    Made it signed.
    
    Signed-off-by: Vasiliy Kulikov <segooon@gmail.com>
    Cc: Hong Liu <hong.liu@intel.com>
    Cc: Alan Cox <alan@linux.intel.com>
    Cc: Anantha Narayanan <anantha.narayanan@intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/misc/apds9802als.c b/drivers/misc/apds9802als.c
index f9b91ba8900c..0ed09358027e 100644
--- a/drivers/misc/apds9802als.c
+++ b/drivers/misc/apds9802als.c
@@ -123,7 +123,7 @@ static ssize_t als_sensing_range_store(struct device *dev,
 {
 	struct i2c_client *client = to_i2c_client(dev);
 	struct als_data *data = i2c_get_clientdata(client);
-	unsigned int ret_val;
+	int ret_val;
 	unsigned long val;
 
 	if (strict_strtoul(buf, 10, &val))

commit f0cfec11180973e4f4b2b6909623e47eaaf7ecfe
Author: Hong Liu <hong.liu@intel.com>
Date:   Tue Oct 26 14:22:42 2010 -0700

    drivers/misc/apds9802als.c: add runtime PM support
    
    Update the driver for the needed runtime power features.  Remove the old
    user controlled power functions.
    
    [akpm@linux-foundation.org: put PM code under CONFIG_PM]
    Signed-off-by: Hong Liu <hong.liu@intel.com>
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/misc/apds9802als.c b/drivers/misc/apds9802als.c
index fbe49602f396..f9b91ba8900c 100644
--- a/drivers/misc/apds9802als.c
+++ b/drivers/misc/apds9802als.c
@@ -29,19 +29,16 @@
 #include <linux/delay.h>
 #include <linux/mutex.h>
 #include <linux/sysfs.h>
-#include <linux/hwmon-sysfs.h>
+#include <linux/pm_runtime.h>
 
 #define ALS_MIN_RANGE_VAL 1
 #define ALS_MAX_RANGE_VAL 2
 #define POWER_STA_ENABLE 1
 #define POWER_STA_DISABLE 0
-#define APDS9802ALS_I2C_ADDR 0x29
 
 #define DRIVER_NAME "apds9802als"
 
 struct als_data {
-	struct device *hwmon_dev;
-	bool needresume;
 	struct mutex mutex;
 };
 
@@ -60,29 +57,64 @@ static ssize_t als_sensing_range_show(struct device *dev,
 		return sprintf(buf, "65535\n");
 }
 
+static int als_wait_for_data_ready(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	int ret;
+	int retry = 10;
+
+	do {
+		msleep(30);
+		ret = i2c_smbus_read_byte_data(client, 0x86);
+	} while (!(ret & 0x80) && retry--);
+
+	if (!retry) {
+		dev_warn(dev, "timeout waiting for data ready\n");
+		return -ETIMEDOUT;
+	}
+
+	return 0;
+}
+
 static ssize_t als_lux0_input_data_show(struct device *dev,
 			struct device_attribute *attr, char *buf)
 {
 	struct i2c_client *client = to_i2c_client(dev);
 	struct als_data *data = i2c_get_clientdata(client);
-	unsigned int ret_val;
+	int ret_val;
 	int temp;
 
 	/* Protect against parallel reads */
+	pm_runtime_get_sync(dev);
 	mutex_lock(&data->mutex);
-	temp = i2c_smbus_read_byte_data(client, 0x8C);/*LSB data*/
+
+	/* clear EOC interrupt status */
+	i2c_smbus_write_byte(client, 0x40);
+	/* start measurement */
+	temp = i2c_smbus_read_byte_data(client, 0x81);
+	i2c_smbus_write_byte_data(client, 0x81, temp | 0x08);
+
+	ret_val = als_wait_for_data_ready(dev);
+	if (ret_val < 0)
+		goto failed;
+
+	temp = i2c_smbus_read_byte_data(client, 0x8C); /* LSB data */
 	if (temp < 0) {
 		ret_val = temp;
 		goto failed;
 	}
-	ret_val = i2c_smbus_read_byte_data(client, 0x8D);/*MSB data*/
+	ret_val = i2c_smbus_read_byte_data(client, 0x8D); /* MSB data */
 	if (ret_val < 0)
 		goto failed;
+
 	mutex_unlock(&data->mutex);
-	ret_val = (ret_val << 8) | temp;
-	return sprintf(buf, "%d\n", ret_val);
+	pm_runtime_put_sync(dev);
+
+	temp = (ret_val << 8) | temp;
+	return sprintf(buf, "%d\n", temp);
 failed:
 	mutex_unlock(&data->mutex);
+	pm_runtime_put_sync(dev);
 	return ret_val;
 }
 
@@ -104,9 +136,10 @@ static ssize_t als_sensing_range_store(struct device *dev,
 	else
 		return -ERANGE;
 
+	pm_runtime_get_sync(dev);
+
 	/* Make sure nobody else reads/modifies/writes 0x81 while we
 	   are active */
-
 	mutex_lock(&data->mutex);
 
 	ret_val = i2c_smbus_read_byte_data(client, 0x81);
@@ -116,34 +149,25 @@ static ssize_t als_sensing_range_store(struct device *dev,
 	/* Reset the bits before setting them */
 	ret_val = ret_val & 0xFA;
 
-	if (val == 1) /* Setting the continous measurement up to 4k LUX */
-		ret_val = (ret_val | 0x05);
-	else /* Setting the continous measurement up to 64k LUX*/
-		ret_val = (ret_val | 0x04);
+	if (val == 1) /* Setting detection range up to 4k LUX */
+		ret_val = (ret_val | 0x01);
+	else /* Setting detection range up to 64k LUX*/
+		ret_val = (ret_val | 0x00);
 
 	ret_val = i2c_smbus_write_byte_data(client, 0x81, ret_val);
+
 	if (ret_val >= 0) {
 		/* All OK */
 		mutex_unlock(&data->mutex);
+		pm_runtime_put_sync(dev);
 		return count;
 	}
 fail:
 	mutex_unlock(&data->mutex);
+	pm_runtime_put_sync(dev);
 	return ret_val;
 }
 
-static ssize_t als_power_status_show(struct device *dev,
-			struct device_attribute *attr, char *buf)
-{
-	struct i2c_client *client = to_i2c_client(dev);
-	int ret_val;
-	ret_val = i2c_smbus_read_byte_data(client, 0x80);
-	if (ret_val < 0)
-		return ret_val;
-	ret_val = ret_val & 0x01;
-	return sprintf(buf, "%d\n", ret_val);
-}
-
 static int als_set_power_state(struct i2c_client *client, bool on_off)
 {
 	int ret_val;
@@ -163,39 +187,13 @@ static int als_set_power_state(struct i2c_client *client, bool on_off)
 	return ret_val;
 }
 
-static ssize_t als_power_status_store(struct device *dev,
-		struct device_attribute *attr, const char *buf, size_t count)
-{
-	struct i2c_client *client = to_i2c_client(dev);
-	struct als_data *data = i2c_get_clientdata(client);
-	unsigned long val;
-	int ret_val;
-
-	if (strict_strtoul(buf, 10, &val))
-		return -EINVAL;
-	if (val == POWER_STA_ENABLE) {
-		ret_val = als_set_power_state(client, true);
-		data->needresume = true;
-	} else if (val == POWER_STA_DISABLE) {
-		ret_val = als_set_power_state(client, false);
-		data->needresume = false;
-	} else
-		return -EINVAL;
-	if (ret_val < 0)
-		return ret_val;
-	return count;
-}
-
 static DEVICE_ATTR(lux0_sensor_range, S_IRUGO | S_IWUSR,
 	als_sensing_range_show, als_sensing_range_store);
 static DEVICE_ATTR(lux0_input, S_IRUGO, als_lux0_input_data_show, NULL);
-static DEVICE_ATTR(power_state, S_IRUGO | S_IWUSR,
-	als_power_status_show, als_power_status_store);
 
 static struct attribute *mid_att_als[] = {
 	&dev_attr_lux0_sensor_range.attr,
 	&dev_attr_lux0_input.attr,
-	&dev_attr_power_state.attr,
 	NULL
 };
 
@@ -213,15 +211,21 @@ static int als_set_default_config(struct i2c_client *client)
 		dev_err(&client->dev, "failed default switch on write\n");
 		return ret_val;
 	}
-	/* Continous from 1Lux to 64k Lux */
-	ret_val = i2c_smbus_write_byte_data(client, 0x81, 0x04);
+	/* detection range: 1~64K Lux, maunal measurement */
+	ret_val = i2c_smbus_write_byte_data(client, 0x81, 0x08);
 	if (ret_val < 0)
 		dev_err(&client->dev, "failed default LUX on write\n");
+
+	/*  We always get 0 for the 1st measurement after system power on,
+	 *  so make sure it is finished before user asks for data.
+	 */
+	als_wait_for_data_ready(&client->dev);
+
 	return ret_val;
 }
 
-static int  apds9802als_probe(struct i2c_client *client,
-					const struct i2c_device_id *id)
+static int apds9802als_probe(struct i2c_client *client,
+			     const struct i2c_device_id *id)
 {
 	int res;
 	struct als_data *data;
@@ -237,11 +241,14 @@ static int  apds9802als_probe(struct i2c_client *client,
 		dev_err(&client->dev, "device create file failed\n");
 		goto als_error1;
 	}
-	dev_info(&client->dev,
-		"%s apds9802als: ALS chip found\n", client->name);
+	dev_info(&client->dev, "ALS chip found\n");
 	als_set_default_config(client);
-	data->needresume = true;
 	mutex_init(&data->mutex);
+
+	pm_runtime_enable(&client->dev);
+	pm_runtime_get(&client->dev);
+	pm_runtime_put(&client->dev);
+
 	return res;
 als_error1:
 	i2c_set_clientdata(client, NULL);
@@ -252,11 +259,14 @@ static int  apds9802als_probe(struct i2c_client *client,
 static int apds9802als_remove(struct i2c_client *client)
 {
 	struct als_data *data = i2c_get_clientdata(client);
+
+	als_set_power_state(client, false);
 	sysfs_remove_group(&client->dev.kobj, &m_als_gr);
 	kfree(data);
 	return 0;
 }
 
+#ifdef CONFIG_PM
 static int apds9802als_suspend(struct i2c_client *client, pm_message_t mesg)
 {
 	als_set_power_state(client, false);
@@ -265,13 +275,42 @@ static int apds9802als_suspend(struct i2c_client *client, pm_message_t mesg)
 
 static int apds9802als_resume(struct i2c_client *client)
 {
-	struct als_data *data = i2c_get_clientdata(client);
+	als_set_default_config(client);
 
-	if (data->needresume == true)
-		als_set_power_state(client, true);
+	pm_runtime_get(&client->dev);
+	pm_runtime_put(&client->dev);
 	return 0;
 }
 
+static int apds9802als_runtime_suspend(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+
+	als_set_power_state(client, false);
+	return 0;
+}
+
+static int apds9802als_runtime_resume(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+
+	als_set_power_state(client, true);
+	return 0;
+}
+
+static const struct dev_pm_ops apds9802als_pm_ops = {
+	.runtime_suspend = apds9802als_runtime_suspend,
+	.runtime_resume = apds9802als_runtime_resume,
+};
+
+#define APDS9802ALS_PM_OPS (&apds9802als_pm_ops)
+
+#else	/* CONFIG_PM */
+#define apds9802als_suspend NULL
+#define apds9802als_resume NULL
+#define APDS9802ALS_PM_OPS NULL
+#endif	/* CONFIG_PM */
+
 static struct i2c_device_id apds9802als_id[] = {
 	{ DRIVER_NAME, 0 },
 	{ }
@@ -281,8 +320,8 @@ MODULE_DEVICE_TABLE(i2c, apds9802als_id);
 
 static struct i2c_driver apds9802als_driver = {
 	.driver = {
-	.name = DRIVER_NAME,
-	.owner = THIS_MODULE,
+		.name = DRIVER_NAME,
+		.pm = APDS9802ALS_PM_OPS,
 	},
 	.probe = apds9802als_probe,
 	.remove = apds9802als_remove,

commit 22d96aa59cf120db3584e4c3365554cae77d2441
Author: anantha <anantha.narayanan@intel.com>
Date:   Tue Oct 26 14:22:41 2010 -0700

    drivers/misc/apds9802als.c: ALS drivers for the apds9802als
    
    This adds support for the ADPS9802ALS sensor.
    
    Cleanup by Alan Cox
            - move mutexes to cover more things
            - report I/O errors back to user space
            - report range and values in LUX
    
    Signed-off-by: Anantha Narayanan <anantha.narayanan@intel.com>
    [The 4K and 64K in the hw spec actually means 4095 (12bit) and 65535 (16bit).]
    Signed-off-by: Hong Liu <hong.liu@intel.com>
    [Updated to match the ALS light API interface convention from Samu]
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Acked-by: Jonathan Cameron <jic23@cam.ac.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/misc/apds9802als.c b/drivers/misc/apds9802als.c
new file mode 100644
index 000000000000..fbe49602f396
--- /dev/null
+++ b/drivers/misc/apds9802als.c
@@ -0,0 +1,308 @@
+/*
+ * apds9802als.c - apds9802  ALS Driver
+ *
+ * Copyright (C) 2009 Intel Corp
+ *
+ *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/err.h>
+#include <linux/delay.h>
+#include <linux/mutex.h>
+#include <linux/sysfs.h>
+#include <linux/hwmon-sysfs.h>
+
+#define ALS_MIN_RANGE_VAL 1
+#define ALS_MAX_RANGE_VAL 2
+#define POWER_STA_ENABLE 1
+#define POWER_STA_DISABLE 0
+#define APDS9802ALS_I2C_ADDR 0x29
+
+#define DRIVER_NAME "apds9802als"
+
+struct als_data {
+	struct device *hwmon_dev;
+	bool needresume;
+	struct mutex mutex;
+};
+
+static ssize_t als_sensing_range_show(struct device *dev,
+			struct device_attribute *attr,  char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	int  val;
+
+	val = i2c_smbus_read_byte_data(client, 0x81);
+	if (val < 0)
+		return val;
+	if (val & 1)
+		return sprintf(buf, "4095\n");
+	else
+		return sprintf(buf, "65535\n");
+}
+
+static ssize_t als_lux0_input_data_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct als_data *data = i2c_get_clientdata(client);
+	unsigned int ret_val;
+	int temp;
+
+	/* Protect against parallel reads */
+	mutex_lock(&data->mutex);
+	temp = i2c_smbus_read_byte_data(client, 0x8C);/*LSB data*/
+	if (temp < 0) {
+		ret_val = temp;
+		goto failed;
+	}
+	ret_val = i2c_smbus_read_byte_data(client, 0x8D);/*MSB data*/
+	if (ret_val < 0)
+		goto failed;
+	mutex_unlock(&data->mutex);
+	ret_val = (ret_val << 8) | temp;
+	return sprintf(buf, "%d\n", ret_val);
+failed:
+	mutex_unlock(&data->mutex);
+	return ret_val;
+}
+
+static ssize_t als_sensing_range_store(struct device *dev,
+		struct device_attribute *attr, const  char *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct als_data *data = i2c_get_clientdata(client);
+	unsigned int ret_val;
+	unsigned long val;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+
+	if (val < 4096)
+		val = 1;
+	else if (val < 65536)
+		val = 2;
+	else
+		return -ERANGE;
+
+	/* Make sure nobody else reads/modifies/writes 0x81 while we
+	   are active */
+
+	mutex_lock(&data->mutex);
+
+	ret_val = i2c_smbus_read_byte_data(client, 0x81);
+	if (ret_val < 0)
+		goto fail;
+
+	/* Reset the bits before setting them */
+	ret_val = ret_val & 0xFA;
+
+	if (val == 1) /* Setting the continous measurement up to 4k LUX */
+		ret_val = (ret_val | 0x05);
+	else /* Setting the continous measurement up to 64k LUX*/
+		ret_val = (ret_val | 0x04);
+
+	ret_val = i2c_smbus_write_byte_data(client, 0x81, ret_val);
+	if (ret_val >= 0) {
+		/* All OK */
+		mutex_unlock(&data->mutex);
+		return count;
+	}
+fail:
+	mutex_unlock(&data->mutex);
+	return ret_val;
+}
+
+static ssize_t als_power_status_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	int ret_val;
+	ret_val = i2c_smbus_read_byte_data(client, 0x80);
+	if (ret_val < 0)
+		return ret_val;
+	ret_val = ret_val & 0x01;
+	return sprintf(buf, "%d\n", ret_val);
+}
+
+static int als_set_power_state(struct i2c_client *client, bool on_off)
+{
+	int ret_val;
+	struct als_data *data = i2c_get_clientdata(client);
+
+	mutex_lock(&data->mutex);
+	ret_val = i2c_smbus_read_byte_data(client, 0x80);
+	if (ret_val < 0)
+		goto fail;
+	if (on_off)
+		ret_val = ret_val | 0x01;
+	else
+		ret_val = ret_val & 0xFE;
+	ret_val = i2c_smbus_write_byte_data(client, 0x80, ret_val);
+fail:
+	mutex_unlock(&data->mutex);
+	return ret_val;
+}
+
+static ssize_t als_power_status_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct als_data *data = i2c_get_clientdata(client);
+	unsigned long val;
+	int ret_val;
+
+	if (strict_strtoul(buf, 10, &val))
+		return -EINVAL;
+	if (val == POWER_STA_ENABLE) {
+		ret_val = als_set_power_state(client, true);
+		data->needresume = true;
+	} else if (val == POWER_STA_DISABLE) {
+		ret_val = als_set_power_state(client, false);
+		data->needresume = false;
+	} else
+		return -EINVAL;
+	if (ret_val < 0)
+		return ret_val;
+	return count;
+}
+
+static DEVICE_ATTR(lux0_sensor_range, S_IRUGO | S_IWUSR,
+	als_sensing_range_show, als_sensing_range_store);
+static DEVICE_ATTR(lux0_input, S_IRUGO, als_lux0_input_data_show, NULL);
+static DEVICE_ATTR(power_state, S_IRUGO | S_IWUSR,
+	als_power_status_show, als_power_status_store);
+
+static struct attribute *mid_att_als[] = {
+	&dev_attr_lux0_sensor_range.attr,
+	&dev_attr_lux0_input.attr,
+	&dev_attr_power_state.attr,
+	NULL
+};
+
+static struct attribute_group m_als_gr = {
+	.name = "apds9802als",
+	.attrs = mid_att_als
+};
+
+static int als_set_default_config(struct i2c_client *client)
+{
+	int ret_val;
+	/* Write the command and then switch on */
+	ret_val = i2c_smbus_write_byte_data(client, 0x80, 0x01);
+	if (ret_val < 0) {
+		dev_err(&client->dev, "failed default switch on write\n");
+		return ret_val;
+	}
+	/* Continous from 1Lux to 64k Lux */
+	ret_val = i2c_smbus_write_byte_data(client, 0x81, 0x04);
+	if (ret_val < 0)
+		dev_err(&client->dev, "failed default LUX on write\n");
+	return ret_val;
+}
+
+static int  apds9802als_probe(struct i2c_client *client,
+					const struct i2c_device_id *id)
+{
+	int res;
+	struct als_data *data;
+
+	data = kzalloc(sizeof(struct als_data), GFP_KERNEL);
+	if (data == NULL) {
+		dev_err(&client->dev, "Memory allocation failed\n");
+		return -ENOMEM;
+	}
+	i2c_set_clientdata(client, data);
+	res = sysfs_create_group(&client->dev.kobj, &m_als_gr);
+	if (res) {
+		dev_err(&client->dev, "device create file failed\n");
+		goto als_error1;
+	}
+	dev_info(&client->dev,
+		"%s apds9802als: ALS chip found\n", client->name);
+	als_set_default_config(client);
+	data->needresume = true;
+	mutex_init(&data->mutex);
+	return res;
+als_error1:
+	i2c_set_clientdata(client, NULL);
+	kfree(data);
+	return res;
+}
+
+static int apds9802als_remove(struct i2c_client *client)
+{
+	struct als_data *data = i2c_get_clientdata(client);
+	sysfs_remove_group(&client->dev.kobj, &m_als_gr);
+	kfree(data);
+	return 0;
+}
+
+static int apds9802als_suspend(struct i2c_client *client, pm_message_t mesg)
+{
+	als_set_power_state(client, false);
+	return 0;
+}
+
+static int apds9802als_resume(struct i2c_client *client)
+{
+	struct als_data *data = i2c_get_clientdata(client);
+
+	if (data->needresume == true)
+		als_set_power_state(client, true);
+	return 0;
+}
+
+static struct i2c_device_id apds9802als_id[] = {
+	{ DRIVER_NAME, 0 },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(i2c, apds9802als_id);
+
+static struct i2c_driver apds9802als_driver = {
+	.driver = {
+	.name = DRIVER_NAME,
+	.owner = THIS_MODULE,
+	},
+	.probe = apds9802als_probe,
+	.remove = apds9802als_remove,
+	.suspend = apds9802als_suspend,
+	.resume = apds9802als_resume,
+	.id_table = apds9802als_id,
+};
+
+static int __init sensor_apds9802als_init(void)
+{
+	return i2c_add_driver(&apds9802als_driver);
+}
+
+static void  __exit sensor_apds9802als_exit(void)
+{
+	i2c_del_driver(&apds9802als_driver);
+}
+module_init(sensor_apds9802als_init);
+module_exit(sensor_apds9802als_exit);
+
+MODULE_AUTHOR("Anantha Narayanan <Anantha.Narayanan@intel.com");
+MODULE_DESCRIPTION("Avago apds9802als ALS Driver");
+MODULE_LICENSE("GPL v2");
