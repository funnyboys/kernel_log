commit 2be8ca97d07e1133e81cd3977bd1f94058b65489
Author: Mao Wenan <maowenan@huawei.com>
Date:   Wed Nov 20 16:56:34 2019 +0100

    vsock/vmci: make vmci_vsock_cb_host_called static
    
    When using make C=2 drivers/misc/vmw_vmci/vmci_driver.o
    to compile, below warning can be seen:
    drivers/misc/vmw_vmci/vmci_driver.c:33:6: warning:
    symbol 'vmci_vsock_cb_host_called' was not declared. Should it be static?
    
    This patch make symbol vmci_vsock_cb_host_called static.
    
    Fixes: b1bba80a4376 ("vsock/vmci: register vmci_transport only when VMCI guest/host are active")
    Reported-by: Hulk Robot <hulkci@huawei.com>
    Signed-off-by: Mao Wenan <maowenan@huawei.com>
    Reported-by: kbuild test robot <lkp@intel.com>
    Signed-off-by: Stefano Garzarella <sgarzare@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/misc/vmw_vmci/vmci_driver.c b/drivers/misc/vmw_vmci/vmci_driver.c
index 95fed4664a2d..cbb706dabede 100644
--- a/drivers/misc/vmw_vmci/vmci_driver.c
+++ b/drivers/misc/vmw_vmci/vmci_driver.c
@@ -30,7 +30,7 @@ static bool vmci_host_personality_initialized;
 
 static DEFINE_MUTEX(vmci_vsock_mutex); /* protects vmci_vsock_transport_cb */
 static vmci_vsock_cb vmci_vsock_transport_cb;
-bool vmci_vsock_cb_host_called;
+static bool vmci_vsock_cb_host_called;
 
 /*
  * vmci_get_context_id() - Gets the current context ID.

commit b1bba80a4376aef34de2b57bfb8834bd095703ed
Author: Stefano Garzarella <sgarzare@redhat.com>
Date:   Thu Nov 14 10:57:47 2019 +0100

    vsock/vmci: register vmci_transport only when VMCI guest/host are active
    
    To allow other transports to be loaded with vmci_transport,
    we register the vmci_transport as G2H or H2G only when a VMCI guest
    or host is active.
    
    To do that, this patch adds a callback registered in the vmci driver
    that will be called when the host or guest becomes active.
    This callback will register the vmci_transport in the VSOCK core.
    
    Cc: Jorgen Hansen <jhansen@vmware.com>
    Signed-off-by: Stefano Garzarella <sgarzare@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/misc/vmw_vmci/vmci_driver.c b/drivers/misc/vmw_vmci/vmci_driver.c
index 819e35995d32..95fed4664a2d 100644
--- a/drivers/misc/vmw_vmci/vmci_driver.c
+++ b/drivers/misc/vmw_vmci/vmci_driver.c
@@ -28,6 +28,10 @@ MODULE_PARM_DESC(disable_guest,
 static bool vmci_guest_personality_initialized;
 static bool vmci_host_personality_initialized;
 
+static DEFINE_MUTEX(vmci_vsock_mutex); /* protects vmci_vsock_transport_cb */
+static vmci_vsock_cb vmci_vsock_transport_cb;
+bool vmci_vsock_cb_host_called;
+
 /*
  * vmci_get_context_id() - Gets the current context ID.
  *
@@ -45,6 +49,69 @@ u32 vmci_get_context_id(void)
 }
 EXPORT_SYMBOL_GPL(vmci_get_context_id);
 
+/*
+ * vmci_register_vsock_callback() - Register the VSOCK vmci_transport callback.
+ *
+ * The callback will be called when the first host or guest becomes active,
+ * or if they are already active when this function is called.
+ * To unregister the callback, call this function with NULL parameter.
+ *
+ * Returns 0 on success. -EBUSY if a callback is already registered.
+ */
+int vmci_register_vsock_callback(vmci_vsock_cb callback)
+{
+	int err = 0;
+
+	mutex_lock(&vmci_vsock_mutex);
+
+	if (vmci_vsock_transport_cb && callback) {
+		err = -EBUSY;
+		goto out;
+	}
+
+	vmci_vsock_transport_cb = callback;
+
+	if (!vmci_vsock_transport_cb) {
+		vmci_vsock_cb_host_called = false;
+		goto out;
+	}
+
+	if (vmci_guest_code_active())
+		vmci_vsock_transport_cb(false);
+
+	if (vmci_host_users() > 0) {
+		vmci_vsock_cb_host_called = true;
+		vmci_vsock_transport_cb(true);
+	}
+
+out:
+	mutex_unlock(&vmci_vsock_mutex);
+	return err;
+}
+EXPORT_SYMBOL_GPL(vmci_register_vsock_callback);
+
+void vmci_call_vsock_callback(bool is_host)
+{
+	mutex_lock(&vmci_vsock_mutex);
+
+	if (!vmci_vsock_transport_cb)
+		goto out;
+
+	/* In the host, this function could be called multiple times,
+	 * but we want to register it only once.
+	 */
+	if (is_host) {
+		if (vmci_vsock_cb_host_called)
+			goto out;
+
+		vmci_vsock_cb_host_called = true;
+	}
+
+	vmci_vsock_transport_cb(is_host);
+out:
+	mutex_unlock(&vmci_vsock_mutex);
+}
+
 static int __init vmci_drv_init(void)
 {
 	int vmci_err;

commit 685a6bf8485e6319c4dd070c02491f9163c23083
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 16:57:36 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 321
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation version 2 and no later version this
      program is distributed in the hope that it will be useful but
      without any warranty without even the implied warranty of
      merchantability or fitness for a particular purpose see the gnu
      general public license for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 33 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190530000435.345978407@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/vmw_vmci/vmci_driver.c b/drivers/misc/vmw_vmci/vmci_driver.c
index 003bfba40758..819e35995d32 100644
--- a/drivers/misc/vmw_vmci/vmci_driver.c
+++ b/drivers/misc/vmw_vmci/vmci_driver.c
@@ -1,16 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * VMware VMCI Driver
  *
  * Copyright (C) 2012 VMware, Inc. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation version 2 and no later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * for more details.
  */
 
 #include <linux/vmw_vmci_defs.h>

commit 11924ba5e671d6caef1516923e2bd8c72929a3fe
Author: Jorgen Hansen <jhansen@vmware.com>
Date:   Fri Sep 21 00:31:05 2018 -0700

    VMCI: Resource wildcard match fixed
    
    When adding a VMCI resource, the check for an existing entry
    would ignore that the new entry could be a wildcard. This could
    result in multiple resource entries that would match a given
    handle. One disastrous outcome of this is that the
    refcounting used to ensure that delayed callbacks for VMCI
    datagrams have run before the datagram is destroyed can be
    wrong, since the refcount could be increased on the duplicate
    entry. This in turn leads to a use after free bug. This issue
    was discovered by Hangbin Liu using KASAN and syzkaller.
    
    Fixes: bc63dedb7d46 ("VMCI: resource object implementation")
    Reported-by: Hangbin Liu <liuhangbin@gmail.com>
    Reviewed-by: Adit Ranadive <aditr@vmware.com>
    Reviewed-by: Vishnu Dasa <vdasa@vmware.com>
    Signed-off-by: Jorgen Hansen <jhansen@vmware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/vmw_vmci/vmci_driver.c b/drivers/misc/vmw_vmci/vmci_driver.c
index d7eaf1eb11e7..003bfba40758 100644
--- a/drivers/misc/vmw_vmci/vmci_driver.c
+++ b/drivers/misc/vmw_vmci/vmci_driver.c
@@ -113,5 +113,5 @@ module_exit(vmci_drv_exit);
 
 MODULE_AUTHOR("VMware, Inc.");
 MODULE_DESCRIPTION("VMware Virtual Machine Communication Interface.");
-MODULE_VERSION("1.1.5.0-k");
+MODULE_VERSION("1.1.6.0-k");
 MODULE_LICENSE("GPL v2");

commit eb94cd68abd9b7c92bf70ddc452d65f1a84c46e2
Author: Jorgen Hansen <jhansen@vmware.com>
Date:   Thu Oct 6 04:43:08 2016 -0700

    VMCI: Doorbell create and destroy fixes
    
    This change consists of two changes:
    
    1) If vmci_doorbell_create is called when neither guest nor
       host personality as been initialized, vmci_get_context_id
       will return VMCI_INVALID_ID. In that case, we should fail
       the create call.
    2) In doorbell destroy, we assume that vmci_guest_code_active()
       has the same return value on create and destroy. That may not
       be the case, so we may end up with the wrong refcount.
       Instead, destroy should check explicitly whether the doorbell
       is in the index table as an indicator of whether the guest
       code was active at create time.
    
    Reviewed-by: Adit Ranadive <aditr@vmware.com>
    Signed-off-by: Jorgen Hansen <jhansen@vmware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/vmw_vmci/vmci_driver.c b/drivers/misc/vmw_vmci/vmci_driver.c
index 896be150e28f..d7eaf1eb11e7 100644
--- a/drivers/misc/vmw_vmci/vmci_driver.c
+++ b/drivers/misc/vmw_vmci/vmci_driver.c
@@ -113,5 +113,5 @@ module_exit(vmci_drv_exit);
 
 MODULE_AUTHOR("VMware, Inc.");
 MODULE_DESCRIPTION("VMware Virtual Machine Communication Interface.");
-MODULE_VERSION("1.1.4.0-k");
+MODULE_VERSION("1.1.5.0-k");
 MODULE_LICENSE("GPL v2");

commit f42a0fd13bd281811e7457b28d939c8e8b808868
Author: Jorgen Hansen <jhansen@vmware.com>
Date:   Thu Nov 12 01:29:32 2015 -0800

    VMCI: Use 32bit atomics for queue headers on X86_32
    
    This change restricts the reading and setting of the head and tail
    pointers on 32bit X86 to 32bit for both correctness and
    performance reasons. On uniprocessor X86_32, the atomic64_read
    may be implemented as a non-locked cmpxchg8b. This may result in
    updates to the pointers done by the VMCI device being overwritten.
    On MP systems, there is no such correctness issue, but using 32bit
    atomics avoids the overhead of the locked 64bit operation. All this
    is safe because the queue size on 32bit systems will never exceed
    a 32bit value.
    
    Reviewed-by: Thomas Hellstrom <thellstrom@vmware.com>
    Signed-off-by: Jorgen Hansen <jhansen@vmware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/vmw_vmci/vmci_driver.c b/drivers/misc/vmw_vmci/vmci_driver.c
index b823f9a6e464..896be150e28f 100644
--- a/drivers/misc/vmw_vmci/vmci_driver.c
+++ b/drivers/misc/vmw_vmci/vmci_driver.c
@@ -113,5 +113,5 @@ module_exit(vmci_drv_exit);
 
 MODULE_AUTHOR("VMware, Inc.");
 MODULE_DESCRIPTION("VMware Virtual Machine Communication Interface.");
-MODULE_VERSION("1.1.3.0-k");
+MODULE_VERSION("1.1.4.0-k");
 MODULE_LICENSE("GPL v2");

commit aa6467f190d32b263f7144239c89c63c922d9ff8
Author: Jorgen Hansen <jhansen@vmware.com>
Date:   Mon Mar 2 08:19:11 2015 -0800

    VMCI: Guard against overflow in queue pair allocation
    
    The current maximum size of a queue in a queue pair is 128 MB. If
    we increase that in the future, the queue pair allocation routines
    may run into overflow issues. This change adds additional checks
    to guard against this.
    
    Acked-by: Andy King <acking@vmware.com>
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Jorgen Hansen <jhansen@vmware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/vmw_vmci/vmci_driver.c b/drivers/misc/vmw_vmci/vmci_driver.c
index cf264a1bb149..b823f9a6e464 100644
--- a/drivers/misc/vmw_vmci/vmci_driver.c
+++ b/drivers/misc/vmw_vmci/vmci_driver.c
@@ -113,5 +113,5 @@ module_exit(vmci_drv_exit);
 
 MODULE_AUTHOR("VMware, Inc.");
 MODULE_DESCRIPTION("VMware Virtual Machine Communication Interface.");
-MODULE_VERSION("1.1.2.0-k");
+MODULE_VERSION("1.1.3.0-k");
 MODULE_LICENSE("GPL v2");

commit 74b5c297f5ecbef0ca128fa7b385b43f036a7984
Author: Andy King <acking@vmware.com>
Date:   Thu Feb 19 10:33:56 2015 -0800

    VMCI: Check userland-provided datagram size
    
    Ensure that the size filled in by userland in the datagram header
    matches the size of the buffer passed down in the IOCTL. Note that we
    account for the size of the header itself in the check.
    
    Acked-by: Jorgen Hansen <jhansen@vmware.com>
    Acked-by: Aditya Sarwade <asarwade@vmware.com>
    Signed-off-by: Andy King <acking@vmware.com>
    Reported-by: David Ramos <daramos@stanford.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/vmw_vmci/vmci_driver.c b/drivers/misc/vmw_vmci/vmci_driver.c
index 032d35cf93ca..cf264a1bb149 100644
--- a/drivers/misc/vmw_vmci/vmci_driver.c
+++ b/drivers/misc/vmw_vmci/vmci_driver.c
@@ -113,5 +113,5 @@ module_exit(vmci_drv_exit);
 
 MODULE_AUTHOR("VMware, Inc.");
 MODULE_DESCRIPTION("VMware Virtual Machine Communication Interface.");
-MODULE_VERSION("1.1.1.0-k");
+MODULE_VERSION("1.1.2.0-k");
 MODULE_LICENSE("GPL v2");

commit a1d88436d53a75e950db15834b3d2f8c0c358fdc
Author: Jorgen Hansen <jhansen@vmware.com>
Date:   Wed Jan 14 11:10:19 2015 -0800

    VMCI: Fix two UVA mapping bugs
    
    (this is a resend of this patch. Originally sent last year, but post
     appears to have been lost)
    
    This change fixes two bugs in the VMCI host driver related to mapping
    the notify boolean from user space into kernel space:
    - the actual UVA was rounded up to the next page boundary - resulting
      in memory corruption in the calling process whenever notifications
      would be signalled. This has been fixed by just removing the
      PAGE_ALIGN part, since get_user_pages_fast can figure this out on
      its own
    - the mapped page wasn't stored anywhere, so it wasn't unmapped and
      put back when a VMCI context was destroyed. Fixed this by
      remembering the page.
    
    Acked-by: Andy King <acking@vmware.com>
    Acked-by: Darius Davis <darius@vmware.com>
    Signed-off-by: Jorgen Hansen <jhansen@vmware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/vmw_vmci/vmci_driver.c b/drivers/misc/vmw_vmci/vmci_driver.c
index 3dee7ae123e7..032d35cf93ca 100644
--- a/drivers/misc/vmw_vmci/vmci_driver.c
+++ b/drivers/misc/vmw_vmci/vmci_driver.c
@@ -113,5 +113,5 @@ module_exit(vmci_drv_exit);
 
 MODULE_AUTHOR("VMware, Inc.");
 MODULE_DESCRIPTION("VMware Virtual Machine Communication Interface.");
-MODULE_VERSION("1.1.0.0-k");
+MODULE_VERSION("1.1.1.0-k");
 MODULE_LICENSE("GPL v2");

commit 6d6dfb4f4aa9ee352a199b5379942350bdd26e64
Author: Andy King <acking@vmware.com>
Date:   Fri Aug 23 09:22:14 2013 -0700

    VMCI: Add support for virtual IOMMU
    
    This patch adds support for virtual IOMMU to the vmci module.  We switch
    to DMA consistent mappings for guest queuepair and doorbell pages that
    are passed to the device.  We still allocate each page individually,
    since there's no guarantee that we'll get a contiguous block of physical
    for an entire queuepair (especially since we allow up to 128 MiB!).
    
    Also made the split between guest and host in the kernelIf struct much
    clearer.  Now it's obvious which fields are which.
    
    Acked-by: George Zhang <georgezhang@vmware.com>
    Acked-by: Aditya Sarwade <asarwade@vmware.com>
    Signed-off-by: Andy King <acking@vmware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/vmw_vmci/vmci_driver.c b/drivers/misc/vmw_vmci/vmci_driver.c
index 7b3fce2da6c3..3dee7ae123e7 100644
--- a/drivers/misc/vmw_vmci/vmci_driver.c
+++ b/drivers/misc/vmw_vmci/vmci_driver.c
@@ -113,5 +113,5 @@ module_exit(vmci_drv_exit);
 
 MODULE_AUTHOR("VMware, Inc.");
 MODULE_DESCRIPTION("VMware Virtual Machine Communication Interface.");
-MODULE_VERSION("1.0.0.0-k");
+MODULE_VERSION("1.1.0.0-k");
 MODULE_LICENSE("GPL v2");

commit 197dbaaabd51c170f9b77bd1c401d4ea0361bb7b
Author: George Zhang <georgezhang@vmware.com>
Date:   Tue Jan 8 15:54:10 2013 -0800

    VMCI: device driver implementaton.
    
    VMCI driver code implementes both the host and guest personalities of the VMCI driver.
    
    Signed-off-by: George Zhang <georgezhang@vmware.com>
    Acked-by: Andy king <acking@vmware.com>
    Acked-by: Dmitry Torokhov <dtor@vmware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/vmw_vmci/vmci_driver.c b/drivers/misc/vmw_vmci/vmci_driver.c
new file mode 100644
index 000000000000..7b3fce2da6c3
--- /dev/null
+++ b/drivers/misc/vmw_vmci/vmci_driver.c
@@ -0,0 +1,117 @@
+/*
+ * VMware VMCI Driver
+ *
+ * Copyright (C) 2012 VMware, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation version 2 and no later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ */
+
+#include <linux/vmw_vmci_defs.h>
+#include <linux/vmw_vmci_api.h>
+#include <linux/atomic.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+
+#include "vmci_driver.h"
+#include "vmci_event.h"
+
+static bool vmci_disable_host;
+module_param_named(disable_host, vmci_disable_host, bool, 0);
+MODULE_PARM_DESC(disable_host,
+		 "Disable driver host personality (default=enabled)");
+
+static bool vmci_disable_guest;
+module_param_named(disable_guest, vmci_disable_guest, bool, 0);
+MODULE_PARM_DESC(disable_guest,
+		 "Disable driver guest personality (default=enabled)");
+
+static bool vmci_guest_personality_initialized;
+static bool vmci_host_personality_initialized;
+
+/*
+ * vmci_get_context_id() - Gets the current context ID.
+ *
+ * Returns the current context ID.  Note that since this is accessed only
+ * from code running in the host, this always returns the host context ID.
+ */
+u32 vmci_get_context_id(void)
+{
+	if (vmci_guest_code_active())
+		return vmci_get_vm_context_id();
+	else if (vmci_host_code_active())
+		return VMCI_HOST_CONTEXT_ID;
+
+	return VMCI_INVALID_ID;
+}
+EXPORT_SYMBOL_GPL(vmci_get_context_id);
+
+static int __init vmci_drv_init(void)
+{
+	int vmci_err;
+	int error;
+
+	vmci_err = vmci_event_init();
+	if (vmci_err < VMCI_SUCCESS) {
+		pr_err("Failed to initialize VMCIEvent (result=%d)\n",
+		       vmci_err);
+		return -EINVAL;
+	}
+
+	if (!vmci_disable_guest) {
+		error = vmci_guest_init();
+		if (error) {
+			pr_warn("Failed to initialize guest personality (err=%d)\n",
+				error);
+		} else {
+			vmci_guest_personality_initialized = true;
+			pr_info("Guest personality initialized and is %s\n",
+				vmci_guest_code_active() ?
+				"active" : "inactive");
+		}
+	}
+
+	if (!vmci_disable_host) {
+		error = vmci_host_init();
+		if (error) {
+			pr_warn("Unable to initialize host personality (err=%d)\n",
+				error);
+		} else {
+			vmci_host_personality_initialized = true;
+			pr_info("Initialized host personality\n");
+		}
+	}
+
+	if (!vmci_guest_personality_initialized &&
+	    !vmci_host_personality_initialized) {
+		vmci_event_exit();
+		return -ENODEV;
+	}
+
+	return 0;
+}
+module_init(vmci_drv_init);
+
+static void __exit vmci_drv_exit(void)
+{
+	if (vmci_guest_personality_initialized)
+		vmci_guest_exit();
+
+	if (vmci_host_personality_initialized)
+		vmci_host_exit();
+
+	vmci_event_exit();
+}
+module_exit(vmci_drv_exit);
+
+MODULE_AUTHOR("VMware, Inc.");
+MODULE_DESCRIPTION("VMware Virtual Machine Communication Interface.");
+MODULE_VERSION("1.0.0.0-k");
+MODULE_LICENSE("GPL v2");
