commit 7ed42113ce0379197c44232429e309bcc72424b0
Author: Nishad Kamdar <nishadkamdar@gmail.com>
Date:   Fri Sep 20 21:48:30 2019 +0530

    ocxl: Use the correct style for SPDX License Identifier
    
    This patch corrects the SPDX License Identifier style
    in header files for Open Coherent Accelerator (OCXL) compatible device
    drivers. For C header files Documentation/process/license-rules.rst
    mandates C-like comments (opposed to C source files where
    C++ style should be used)
    
    Changes made by using a script provided by Joe Perches here:
    https://lkml.org/lkml/2019/2/7/46.
    
    Suggested-by: Joe Perches <joe@perches.com>
    Signed-off-by: Nishad Kamdar <nishadkamdar@gmail.com>
    Acked-by: Andrew Donnellan <ajd@linux.ibm.com>
    Link: https://lore.kernel.org/r/20190920161826.GA6894@nishad
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/misc/ocxl/ocxl_internal.h b/drivers/misc/ocxl/ocxl_internal.h
index 97415afd79f3..345bf843a38e 100644
--- a/drivers/misc/ocxl/ocxl_internal.h
+++ b/drivers/misc/ocxl/ocxl_internal.h
@@ -1,4 +1,4 @@
-// SPDX-License-Identifier: GPL-2.0+
+/* SPDX-License-Identifier: GPL-2.0+ */
 // Copyright 2017 IBM Corp.
 #ifndef _OCXL_INTERNAL_H_
 #define _OCXL_INTERNAL_H_

commit 060146614643ddc5978c73ffac0329762b4651c9
Author: Alastair D'Silva <alastair@d-silva.org>
Date:   Wed Mar 27 16:31:35 2019 +1100

    ocxl: move event_fd handling to frontend
    
    Event_fd is only used in the driver frontend, so it does not
    need to exist in the backend code. Relocate it to the frontend
    and provide an opaque mechanism for consumers instead.
    
    Signed-off-by: Alastair D'Silva <alastair@d-silva.org>
    Acked-by: Frederic Barrat <fbarrat@linux.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/drivers/misc/ocxl/ocxl_internal.h b/drivers/misc/ocxl/ocxl_internal.h
index 58969467bd5c..97415afd79f3 100644
--- a/drivers/misc/ocxl/ocxl_internal.h
+++ b/drivers/misc/ocxl/ocxl_internal.h
@@ -139,11 +139,6 @@ void ocxl_sysfs_unregister_afu(struct ocxl_file_info *info);
 
 int ocxl_irq_offset_to_id(struct ocxl_context *ctx, u64 offset);
 u64 ocxl_irq_id_to_offset(struct ocxl_context *ctx, int irq_id);
-int ocxl_afu_irq_alloc(struct ocxl_context *ctx, int *irq_id);
-int ocxl_afu_irq_free(struct ocxl_context *ctx, int irq_id);
 void ocxl_afu_irq_free_all(struct ocxl_context *ctx);
-int ocxl_afu_irq_set_fd(struct ocxl_context *ctx, int irq_id,
-			int eventfd);
-u64 ocxl_afu_irq_get_addr(struct ocxl_context *ctx, int irq_id);
 
 #endif /* _OCXL_INTERNAL_H_ */

commit 2ec3b7ed2ab8e07fdb5f800ff420e94dec75435f
Author: Alastair D'Silva <alastair@d-silva.org>
Date:   Wed Mar 27 16:31:34 2019 +1100

    ocxl: afu_irq only deals with IRQ IDs, not offsets
    
    The use of offsets is required only in the frontend, so alter
    the IRQ API to only work with IRQ IDs in the backend.
    
    Signed-off-by: Alastair D'Silva <alastair@d-silva.org>
    Acked-by: Frederic Barrat <fbarrat@linux.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/drivers/misc/ocxl/ocxl_internal.h b/drivers/misc/ocxl/ocxl_internal.h
index de6c16237742..58969467bd5c 100644
--- a/drivers/misc/ocxl/ocxl_internal.h
+++ b/drivers/misc/ocxl/ocxl_internal.h
@@ -137,11 +137,13 @@ void ocxl_context_detach_all(struct ocxl_afu *afu);
 int ocxl_sysfs_register_afu(struct ocxl_file_info *info);
 void ocxl_sysfs_unregister_afu(struct ocxl_file_info *info);
 
-int ocxl_afu_irq_alloc(struct ocxl_context *ctx, u64 *irq_offset);
-int ocxl_afu_irq_free(struct ocxl_context *ctx, u64 irq_offset);
+int ocxl_irq_offset_to_id(struct ocxl_context *ctx, u64 offset);
+u64 ocxl_irq_id_to_offset(struct ocxl_context *ctx, int irq_id);
+int ocxl_afu_irq_alloc(struct ocxl_context *ctx, int *irq_id);
+int ocxl_afu_irq_free(struct ocxl_context *ctx, int irq_id);
 void ocxl_afu_irq_free_all(struct ocxl_context *ctx);
-int ocxl_afu_irq_set_fd(struct ocxl_context *ctx, u64 irq_offset,
+int ocxl_afu_irq_set_fd(struct ocxl_context *ctx, int irq_id,
 			int eventfd);
-u64 ocxl_afu_irq_get_addr(struct ocxl_context *ctx, u64 irq_offset);
+u64 ocxl_afu_irq_get_addr(struct ocxl_context *ctx, int irq_id);
 
 #endif /* _OCXL_INTERNAL_H_ */

commit b9721d275cc2c5e6c07371239c827e0faf05a6b9
Author: Alastair D'Silva <alastair@d-silva.org>
Date:   Wed Mar 27 16:31:33 2019 +1100

    ocxl: Allow external drivers to use OpenCAPI contexts
    
    Most OpenCAPI operations require a valid context, so
    exposing these functions to external drivers is necessary.
    
    Signed-off-by: Alastair D'Silva <alastair@d-silva.org>
    Reviewed-by: Greg Kurz <groug@kaod.org>
    Acked-by: Frederic Barrat <fbarrat@linux.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/drivers/misc/ocxl/ocxl_internal.h b/drivers/misc/ocxl/ocxl_internal.h
index 53b6c64a1bf0..de6c16237742 100644
--- a/drivers/misc/ocxl/ocxl_internal.h
+++ b/drivers/misc/ocxl/ocxl_internal.h
@@ -130,15 +130,9 @@ int ocxl_config_check_afu_index(struct pci_dev *dev,
  */
 int ocxl_link_update_pe(void *link_handle, int pasid, __u16 tid);
 
-struct ocxl_context *ocxl_context_alloc(void);
-int ocxl_context_init(struct ocxl_context *ctx, struct ocxl_afu *afu,
-			struct address_space *mapping);
-int ocxl_context_attach(struct ocxl_context *ctx, u64 amr);
 int ocxl_context_mmap(struct ocxl_context *ctx,
 			struct vm_area_struct *vma);
-int ocxl_context_detach(struct ocxl_context *ctx);
 void ocxl_context_detach_all(struct ocxl_afu *afu);
-void ocxl_context_free(struct ocxl_context *ctx);
 
 int ocxl_sysfs_register_afu(struct ocxl_file_info *info);
 void ocxl_sysfs_unregister_afu(struct ocxl_file_info *info);

commit 75ca758adbafc81804c39b2c200ecdc819a6c042
Author: Alastair D'Silva <alastair@d-silva.org>
Date:   Wed Mar 27 16:31:32 2019 +1100

    ocxl: Create a clear delineation between ocxl backend & frontend
    
    The OCXL driver contains both frontend code for interacting with userspace,
    as well as backend code for interacting with the hardware.
    
    This patch separates the backend code from the frontend so that it can be
    used by other device drivers that communicate via OpenCAPI.
    
    Relocate dev, cdev & sysfs files to the frontend code to allow external
    drivers to maintain their own devices.
    
    Reference counting on the device in the backend is replaced with kref
    counting.
    
    Move file & sysfs layer initialisation from core.c (backend) to
    pci.c (frontend).
    
    Create an ocxl_function oriented interface for initing devices &
    enumerating AFUs.
    
    Signed-off-by: Alastair D'Silva <alastair@d-silva.org>
    Acked-by: Frederic Barrat <fbarrat@linux.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/drivers/misc/ocxl/ocxl_internal.h b/drivers/misc/ocxl/ocxl_internal.h
index 81086534dab5..53b6c64a1bf0 100644
--- a/drivers/misc/ocxl/ocxl_internal.h
+++ b/drivers/misc/ocxl/ocxl_internal.h
@@ -11,9 +11,6 @@
 #define MAX_IRQ_PER_LINK	2000
 #define MAX_IRQ_PER_CONTEXT	MAX_IRQ_PER_LINK
 
-#define to_ocxl_function(d) container_of(d, struct ocxl_fn, dev)
-#define to_ocxl_afu(d) container_of(d, struct ocxl_afu, dev)
-
 extern struct pci_driver ocxl_pci_driver;
 
 struct ocxl_fn {
@@ -30,11 +27,17 @@ struct ocxl_fn {
 	void *link;
 };
 
+struct ocxl_file_info {
+	struct ocxl_afu *afu;
+	struct device dev;
+	struct cdev cdev;
+	struct bin_attribute attr_global_mmio;
+};
+
 struct ocxl_afu {
+	struct kref kref;
 	struct ocxl_fn *fn;
 	struct list_head list;
-	struct device dev;
-	struct cdev cdev;
 	struct ocxl_afu_config config;
 	int pasid_base;
 	int pasid_count; /* opened contexts */
@@ -48,7 +51,7 @@ struct ocxl_afu {
 	u64 irq_base_offset;
 	void __iomem *global_mmio_ptr;
 	u64 pp_mmio_start;
-	struct bin_attribute attr_global_mmio;
+	void *private;
 };
 
 enum ocxl_context_status {
@@ -91,13 +94,10 @@ struct ocxl_process_element {
 	__be32 software_state;
 };
 
-struct ocxl_afu *ocxl_afu_get(struct ocxl_afu *afu);
-void ocxl_afu_put(struct ocxl_afu *afu);
-
 int ocxl_create_cdev(struct ocxl_afu *afu);
 void ocxl_destroy_cdev(struct ocxl_afu *afu);
-int ocxl_register_afu(struct ocxl_afu *afu);
-void ocxl_unregister_afu(struct ocxl_afu *afu);
+int ocxl_file_register_afu(struct ocxl_afu *afu);
+void ocxl_file_unregister_afu(struct ocxl_afu *afu);
 
 int ocxl_file_init(void);
 void ocxl_file_exit(void);
@@ -140,8 +140,8 @@ int ocxl_context_detach(struct ocxl_context *ctx);
 void ocxl_context_detach_all(struct ocxl_afu *afu);
 void ocxl_context_free(struct ocxl_context *ctx);
 
-int ocxl_sysfs_add_afu(struct ocxl_afu *afu);
-void ocxl_sysfs_remove_afu(struct ocxl_afu *afu);
+int ocxl_sysfs_register_afu(struct ocxl_file_info *info);
+void ocxl_sysfs_unregister_afu(struct ocxl_file_info *info);
 
 int ocxl_afu_irq_alloc(struct ocxl_context *ctx, u64 *irq_offset);
 int ocxl_afu_irq_free(struct ocxl_context *ctx, u64 irq_offset);
@@ -150,9 +150,4 @@ int ocxl_afu_irq_set_fd(struct ocxl_context *ctx, u64 irq_offset,
 			int eventfd);
 u64 ocxl_afu_irq_get_addr(struct ocxl_context *ctx, u64 irq_offset);
 
-struct ocxl_fn *init_function(struct pci_dev *dev);
-void remove_function(struct ocxl_fn *fn);
-int init_afu(struct pci_dev *dev, struct ocxl_fn *fn, u8 afu_idx);
-void remove_afu(struct ocxl_afu *afu);
-
 #endif /* _OCXL_INTERNAL_H_ */

commit 1ba2143606a10f1c2e7308bc7abd940a6381cffd
Author: Alastair D'Silva <alastair@d-silva.org>
Date:   Wed Mar 27 16:31:30 2019 +1100

    ocxl: Split pci.c
    
    In preparation for making core code available for external drivers,
    move the core code out of pci.c and into core.c
    
    Signed-off-by: Alastair D'Silva <alastair@d-silva.org>
    Acked-by: Frederic Barrat <fbarrat@linux.ibm.com>
    Acked-by: Andrew Donnellan <andrew.donnellan@au1.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/drivers/misc/ocxl/ocxl_internal.h b/drivers/misc/ocxl/ocxl_internal.h
index 06fd98c989c8..81086534dab5 100644
--- a/drivers/misc/ocxl/ocxl_internal.h
+++ b/drivers/misc/ocxl/ocxl_internal.h
@@ -150,4 +150,9 @@ int ocxl_afu_irq_set_fd(struct ocxl_context *ctx, u64 irq_offset,
 			int eventfd);
 u64 ocxl_afu_irq_get_addr(struct ocxl_context *ctx, u64 irq_offset);
 
+struct ocxl_fn *init_function(struct pci_dev *dev);
+void remove_function(struct ocxl_fn *fn);
+int init_afu(struct pci_dev *dev, struct ocxl_fn *fn, u8 afu_idx);
+void remove_afu(struct ocxl_afu *afu);
+
 #endif /* _OCXL_INTERNAL_H_ */

commit b696d28283e2e030cdc9ece7a4eb0a93b4c474fd
Author: Alastair D'Silva <alastair@d-silva.org>
Date:   Mon Mar 25 16:34:55 2019 +1100

    ocxl: Remove some unused exported symbols
    
    Remove some unused exported symbols.
    
    Signed-off-by: Alastair D'Silva <alastair@d-silva.org>
    Reviewed-by: Greg Kurz <groug@kaod.org>
    Acked-by: Frederic Barrat <fbarrat@linux.ibm.com>
    Acked-by: Andrew Donnellan <andrew.donnellan@au1.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/drivers/misc/ocxl/ocxl_internal.h b/drivers/misc/ocxl/ocxl_internal.h
index 321b29e77f45..06fd98c989c8 100644
--- a/drivers/misc/ocxl/ocxl_internal.h
+++ b/drivers/misc/ocxl/ocxl_internal.h
@@ -107,6 +107,29 @@ void ocxl_pasid_afu_free(struct ocxl_fn *fn, u32 start, u32 size);
 int ocxl_actag_afu_alloc(struct ocxl_fn *fn, u32 size);
 void ocxl_actag_afu_free(struct ocxl_fn *fn, u32 start, u32 size);
 
+/*
+ * Get the max PASID value that can be used by the function
+ */
+int ocxl_config_get_pasid_info(struct pci_dev *dev, int *count);
+
+/*
+ * Check if an AFU index is valid for the given function.
+ *
+ * AFU indexes can be sparse, so a driver should check all indexes up
+ * to the maximum found in the function description
+ */
+int ocxl_config_check_afu_index(struct pci_dev *dev,
+				struct ocxl_fn_config *fn, int afu_idx);
+
+/**
+ * Update values within a Process Element
+ *
+ * link_handle: the link handle associated with the process element
+ * pasid: the PASID for the AFU context
+ * tid: the new thread id for the process element
+ */
+int ocxl_link_update_pe(void *link_handle, int pasid, __u16 tid);
+
 struct ocxl_context *ocxl_context_alloc(void);
 int ocxl_context_init(struct ocxl_context *ctx, struct ocxl_afu *afu,
 			struct address_space *mapping);

commit 53e3e74530626d708d4822a29a3edd16f7484b4b
Author: Alastair D'Silva <alastair@d-silva.org>
Date:   Mon Mar 25 16:34:54 2019 +1100

    ocxl: Remove superfluous 'extern' from headers
    
    The 'extern' keyword adds no value here.
    
    Signed-off-by: Alastair D'Silva <alastair@d-silva.org>
    Reviewed-by: Greg Kurz <groug@kaod.org>
    Acked-by: Frederic Barrat <fbarrat@linux.ibm.com>
    Acked-by: Andrew Donnellan <andrew.donnellan@au1.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/drivers/misc/ocxl/ocxl_internal.h b/drivers/misc/ocxl/ocxl_internal.h
index a32f2151029f..321b29e77f45 100644
--- a/drivers/misc/ocxl/ocxl_internal.h
+++ b/drivers/misc/ocxl/ocxl_internal.h
@@ -16,7 +16,6 @@
 
 extern struct pci_driver ocxl_pci_driver;
 
-
 struct ocxl_fn {
 	struct device dev;
 	int bar_used[3];
@@ -92,41 +91,40 @@ struct ocxl_process_element {
 	__be32 software_state;
 };
 
+struct ocxl_afu *ocxl_afu_get(struct ocxl_afu *afu);
+void ocxl_afu_put(struct ocxl_afu *afu);
 
-extern struct ocxl_afu *ocxl_afu_get(struct ocxl_afu *afu);
-extern void ocxl_afu_put(struct ocxl_afu *afu);
-
-extern int ocxl_create_cdev(struct ocxl_afu *afu);
-extern void ocxl_destroy_cdev(struct ocxl_afu *afu);
-extern int ocxl_register_afu(struct ocxl_afu *afu);
-extern void ocxl_unregister_afu(struct ocxl_afu *afu);
+int ocxl_create_cdev(struct ocxl_afu *afu);
+void ocxl_destroy_cdev(struct ocxl_afu *afu);
+int ocxl_register_afu(struct ocxl_afu *afu);
+void ocxl_unregister_afu(struct ocxl_afu *afu);
 
-extern int ocxl_file_init(void);
-extern void ocxl_file_exit(void);
+int ocxl_file_init(void);
+void ocxl_file_exit(void);
 
-extern int ocxl_pasid_afu_alloc(struct ocxl_fn *fn, u32 size);
-extern void ocxl_pasid_afu_free(struct ocxl_fn *fn, u32 start, u32 size);
-extern int ocxl_actag_afu_alloc(struct ocxl_fn *fn, u32 size);
-extern void ocxl_actag_afu_free(struct ocxl_fn *fn, u32 start, u32 size);
+int ocxl_pasid_afu_alloc(struct ocxl_fn *fn, u32 size);
+void ocxl_pasid_afu_free(struct ocxl_fn *fn, u32 start, u32 size);
+int ocxl_actag_afu_alloc(struct ocxl_fn *fn, u32 size);
+void ocxl_actag_afu_free(struct ocxl_fn *fn, u32 start, u32 size);
 
-extern struct ocxl_context *ocxl_context_alloc(void);
-extern int ocxl_context_init(struct ocxl_context *ctx, struct ocxl_afu *afu,
+struct ocxl_context *ocxl_context_alloc(void);
+int ocxl_context_init(struct ocxl_context *ctx, struct ocxl_afu *afu,
 			struct address_space *mapping);
-extern int ocxl_context_attach(struct ocxl_context *ctx, u64 amr);
-extern int ocxl_context_mmap(struct ocxl_context *ctx,
+int ocxl_context_attach(struct ocxl_context *ctx, u64 amr);
+int ocxl_context_mmap(struct ocxl_context *ctx,
 			struct vm_area_struct *vma);
-extern int ocxl_context_detach(struct ocxl_context *ctx);
-extern void ocxl_context_detach_all(struct ocxl_afu *afu);
-extern void ocxl_context_free(struct ocxl_context *ctx);
+int ocxl_context_detach(struct ocxl_context *ctx);
+void ocxl_context_detach_all(struct ocxl_afu *afu);
+void ocxl_context_free(struct ocxl_context *ctx);
 
-extern int ocxl_sysfs_add_afu(struct ocxl_afu *afu);
-extern void ocxl_sysfs_remove_afu(struct ocxl_afu *afu);
+int ocxl_sysfs_add_afu(struct ocxl_afu *afu);
+void ocxl_sysfs_remove_afu(struct ocxl_afu *afu);
 
-extern int ocxl_afu_irq_alloc(struct ocxl_context *ctx, u64 *irq_offset);
-extern int ocxl_afu_irq_free(struct ocxl_context *ctx, u64 irq_offset);
-extern void ocxl_afu_irq_free_all(struct ocxl_context *ctx);
-extern int ocxl_afu_irq_set_fd(struct ocxl_context *ctx, u64 irq_offset,
+int ocxl_afu_irq_alloc(struct ocxl_context *ctx, u64 *irq_offset);
+int ocxl_afu_irq_free(struct ocxl_context *ctx, u64 irq_offset);
+void ocxl_afu_irq_free_all(struct ocxl_context *ctx);
+int ocxl_afu_irq_set_fd(struct ocxl_context *ctx, u64 irq_offset,
 			int eventfd);
-extern u64 ocxl_afu_irq_get_addr(struct ocxl_context *ctx, u64 irq_offset);
+u64 ocxl_afu_irq_get_addr(struct ocxl_context *ctx, u64 irq_offset);
 
 #endif /* _OCXL_INTERNAL_H_ */

commit e948e06fc63a1c1e36ec4c8e5c510b881ff19c26
Author: Alastair D'Silva <alastair@d-silva.org>
Date:   Fri May 11 16:13:01 2018 +1000

    ocxl: Expose the thread_id needed for wait on POWER9
    
    In order to successfully issue as_notify, an AFU needs to know the TID
    to notify, which in turn means that this information should be
    available in userspace so it can be communicated to the AFU.
    
    Signed-off-by: Alastair D'Silva <alastair@d-silva.org>
    Acked-by: Andrew Donnellan <andrew.donnellan@au1.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/drivers/misc/ocxl/ocxl_internal.h b/drivers/misc/ocxl/ocxl_internal.h
index 5d421824afd9..a32f2151029f 100644
--- a/drivers/misc/ocxl/ocxl_internal.h
+++ b/drivers/misc/ocxl/ocxl_internal.h
@@ -77,6 +77,7 @@ struct ocxl_context {
 	struct ocxl_xsl_error xsl_error;
 	struct mutex irq_lock;
 	struct idr irq_idr;
+	u16 tidr; // Thread ID used for P9 wait implementation
 };
 
 struct ocxl_process_element {

commit 280b983ce2b8759722d911ea4b5af66e95d84e09
Author: Frederic Barrat <fbarrat@linux.vnet.ibm.com>
Date:   Tue Jan 23 12:31:43 2018 +0100

    ocxl: Add a kernel API for other opencapi drivers
    
    Some of the functions done by the generic driver should also be needed
    by other opencapi drivers: attaching a context to an adapter,
    translation fault handling, AFU interrupt allocation...
    
    So to avoid code duplication, the driver provides a kernel API that
    other drivers can use, similar to calling a in-kernel library.
    
    It is still a bit theoretical, for lack of real hardware, and will
    likely need adjustements down the road. But we used the cxlflash
    driver as a guinea pig.
    
    Signed-off-by: Frederic Barrat <fbarrat@linux.vnet.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/drivers/misc/ocxl/ocxl_internal.h b/drivers/misc/ocxl/ocxl_internal.h
index a89b88ac67eb..5d421824afd9 100644
--- a/drivers/misc/ocxl/ocxl_internal.h
+++ b/drivers/misc/ocxl/ocxl_internal.h
@@ -6,8 +6,8 @@
 #include <linux/pci.h>
 #include <linux/cdev.h>
 #include <linux/list.h>
+#include <misc/ocxl.h>
 
-#define OCXL_AFU_NAME_SZ      (24+1)  /* add 1 for NULL termination */
 #define MAX_IRQ_PER_LINK	2000
 #define MAX_IRQ_PER_CONTEXT	MAX_IRQ_PER_LINK
 
@@ -16,38 +16,6 @@
 
 extern struct pci_driver ocxl_pci_driver;
 
-/*
- * The following 2 structures are a fairly generic way of representing
- * the configuration data for a function and AFU, as read from the
- * configuration space.
- */
-struct ocxl_afu_config {
-	u8 idx;
-	int dvsec_afu_control_pos;
-	char name[OCXL_AFU_NAME_SZ];
-	u8 version_major;
-	u8 version_minor;
-	u8 afuc_type;
-	u8 afum_type;
-	u8 profile;
-	u8 global_mmio_bar;
-	u64 global_mmio_offset;
-	u32 global_mmio_size;
-	u8 pp_mmio_bar;
-	u64 pp_mmio_offset;
-	u32 pp_mmio_stride;
-	u8 log_mem_size;
-	u8 pasid_supported_log;
-	u16 actag_supported;
-};
-
-struct ocxl_fn_config {
-	int dvsec_tl_pos;
-	int dvsec_function_pos;
-	int dvsec_afu_info_pos;
-	s8 max_pasid_log;
-	s8 max_afu_index;
-};
 
 struct ocxl_fn {
 	struct device dev;
@@ -135,43 +103,6 @@ extern void ocxl_unregister_afu(struct ocxl_afu *afu);
 extern int ocxl_file_init(void);
 extern void ocxl_file_exit(void);
 
-extern int ocxl_config_read_function(struct pci_dev *dev,
-				struct ocxl_fn_config *fn);
-
-extern int ocxl_config_check_afu_index(struct pci_dev *dev,
-				struct ocxl_fn_config *fn, int afu_idx);
-extern int ocxl_config_read_afu(struct pci_dev *dev,
-				struct ocxl_fn_config *fn,
-				struct ocxl_afu_config *afu,
-				u8 afu_idx);
-extern int ocxl_config_get_pasid_info(struct pci_dev *dev, int *count);
-extern void ocxl_config_set_afu_pasid(struct pci_dev *dev,
-				int afu_control,
-				int pasid_base, u32 pasid_count_log);
-extern int ocxl_config_get_actag_info(struct pci_dev *dev,
-				u16 *base, u16 *enabled, u16 *supported);
-extern void ocxl_config_set_actag(struct pci_dev *dev, int func_dvsec,
-				u32 tag_first, u32 tag_count);
-extern void ocxl_config_set_afu_actag(struct pci_dev *dev, int afu_control,
-				int actag_base, int actag_count);
-extern void ocxl_config_set_afu_state(struct pci_dev *dev, int afu_control,
-				int enable);
-extern int ocxl_config_set_TL(struct pci_dev *dev, int tl_dvsec);
-extern int ocxl_config_terminate_pasid(struct pci_dev *dev, int afu_control,
-				int pasid);
-
-extern int ocxl_link_setup(struct pci_dev *dev, int PE_mask,
-			void **link_handle);
-extern void ocxl_link_release(struct pci_dev *dev, void *link_handle);
-extern int ocxl_link_add_pe(void *link_handle, int pasid, u32 pidr, u32 tidr,
-		u64 amr, struct mm_struct *mm,
-		void (*xsl_err_cb)(void *data, u64 addr, u64 dsisr),
-		void *xsl_err_data);
-extern int ocxl_link_remove_pe(void *link_handle, int pasid);
-extern int ocxl_link_irq_alloc(void *link_handle, int *hw_irq,
-			u64 *addr);
-extern void ocxl_link_free_irq(void *link_handle, int hw_irq);
-
 extern int ocxl_pasid_afu_alloc(struct ocxl_fn *fn, u32 size);
 extern void ocxl_pasid_afu_free(struct ocxl_fn *fn, u32 start, u32 size);
 extern int ocxl_actag_afu_alloc(struct ocxl_fn *fn, u32 size);

commit aeddad1760aeb206d912b27b230269407efd5b06
Author: Frederic Barrat <fbarrat@linux.vnet.ibm.com>
Date:   Tue Jan 23 12:31:42 2018 +0100

    ocxl: Add AFU interrupt support
    
    Add user APIs through ioctl to allocate, free, and be notified of an
    AFU interrupt.
    
    For opencapi, an AFU can trigger an interrupt on the host by sending a
    specific command targeting a 64-bit object handle. On POWER9, this is
    implemented by mapping a special page in the address space of a
    process and a write to that page will trigger an interrupt.
    
    Signed-off-by: Frederic Barrat <fbarrat@linux.vnet.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/drivers/misc/ocxl/ocxl_internal.h b/drivers/misc/ocxl/ocxl_internal.h
index 04fc160c7bd5..a89b88ac67eb 100644
--- a/drivers/misc/ocxl/ocxl_internal.h
+++ b/drivers/misc/ocxl/ocxl_internal.h
@@ -190,4 +190,11 @@ extern void ocxl_context_free(struct ocxl_context *ctx);
 extern int ocxl_sysfs_add_afu(struct ocxl_afu *afu);
 extern void ocxl_sysfs_remove_afu(struct ocxl_afu *afu);
 
+extern int ocxl_afu_irq_alloc(struct ocxl_context *ctx, u64 *irq_offset);
+extern int ocxl_afu_irq_free(struct ocxl_context *ctx, u64 irq_offset);
+extern void ocxl_afu_irq_free_all(struct ocxl_context *ctx);
+extern int ocxl_afu_irq_set_fd(struct ocxl_context *ctx, u64 irq_offset,
+			int eventfd);
+extern u64 ocxl_afu_irq_get_addr(struct ocxl_context *ctx, u64 irq_offset);
+
 #endif /* _OCXL_INTERNAL_H_ */

commit 5ef3166e8a32d78dfa985a323aa45ed485ff663a
Author: Frederic Barrat <fbarrat@linux.vnet.ibm.com>
Date:   Tue Jan 23 12:31:41 2018 +0100

    ocxl: Driver code for 'generic' opencapi devices
    
    Add an ocxl driver to handle generic opencapi devices. Of course, it's
    not meant to be the only opencapi driver, any device is free to
    implement its own. But if a host application only needs basic services
    like attaching to an opencapi adapter, have translation faults handled
    or allocate AFU interrupts, it should suffice.
    
    The AFU config space must follow the opencapi specification and use
    the expected vendor/device ID to be seen by the generic driver.
    
    The driver exposes the device AFUs as a char device in /dev/ocxl/
    
    Note that the driver currently doesn't handle memory attached to the
    opencapi device.
    
    Signed-off-by: Frederic Barrat <fbarrat@linux.vnet.ibm.com>
    Signed-off-by: Andrew Donnellan <andrew.donnellan@au1.ibm.com>
    Signed-off-by: Alastair D'Silva <alastair@d-silva.org>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/drivers/misc/ocxl/ocxl_internal.h b/drivers/misc/ocxl/ocxl_internal.h
new file mode 100644
index 000000000000..04fc160c7bd5
--- /dev/null
+++ b/drivers/misc/ocxl/ocxl_internal.h
@@ -0,0 +1,193 @@
+// SPDX-License-Identifier: GPL-2.0+
+// Copyright 2017 IBM Corp.
+#ifndef _OCXL_INTERNAL_H_
+#define _OCXL_INTERNAL_H_
+
+#include <linux/pci.h>
+#include <linux/cdev.h>
+#include <linux/list.h>
+
+#define OCXL_AFU_NAME_SZ      (24+1)  /* add 1 for NULL termination */
+#define MAX_IRQ_PER_LINK	2000
+#define MAX_IRQ_PER_CONTEXT	MAX_IRQ_PER_LINK
+
+#define to_ocxl_function(d) container_of(d, struct ocxl_fn, dev)
+#define to_ocxl_afu(d) container_of(d, struct ocxl_afu, dev)
+
+extern struct pci_driver ocxl_pci_driver;
+
+/*
+ * The following 2 structures are a fairly generic way of representing
+ * the configuration data for a function and AFU, as read from the
+ * configuration space.
+ */
+struct ocxl_afu_config {
+	u8 idx;
+	int dvsec_afu_control_pos;
+	char name[OCXL_AFU_NAME_SZ];
+	u8 version_major;
+	u8 version_minor;
+	u8 afuc_type;
+	u8 afum_type;
+	u8 profile;
+	u8 global_mmio_bar;
+	u64 global_mmio_offset;
+	u32 global_mmio_size;
+	u8 pp_mmio_bar;
+	u64 pp_mmio_offset;
+	u32 pp_mmio_stride;
+	u8 log_mem_size;
+	u8 pasid_supported_log;
+	u16 actag_supported;
+};
+
+struct ocxl_fn_config {
+	int dvsec_tl_pos;
+	int dvsec_function_pos;
+	int dvsec_afu_info_pos;
+	s8 max_pasid_log;
+	s8 max_afu_index;
+};
+
+struct ocxl_fn {
+	struct device dev;
+	int bar_used[3];
+	struct ocxl_fn_config config;
+	struct list_head afu_list;
+	int pasid_base;
+	int actag_base;
+	int actag_enabled;
+	int actag_supported;
+	struct list_head pasid_list;
+	struct list_head actag_list;
+	void *link;
+};
+
+struct ocxl_afu {
+	struct ocxl_fn *fn;
+	struct list_head list;
+	struct device dev;
+	struct cdev cdev;
+	struct ocxl_afu_config config;
+	int pasid_base;
+	int pasid_count; /* opened contexts */
+	int pasid_max; /* maximum number of contexts */
+	int actag_base;
+	int actag_enabled;
+	struct mutex contexts_lock;
+	struct idr contexts_idr;
+	struct mutex afu_control_lock;
+	u64 global_mmio_start;
+	u64 irq_base_offset;
+	void __iomem *global_mmio_ptr;
+	u64 pp_mmio_start;
+	struct bin_attribute attr_global_mmio;
+};
+
+enum ocxl_context_status {
+	CLOSED,
+	OPENED,
+	ATTACHED,
+};
+
+// Contains metadata about a translation fault
+struct ocxl_xsl_error {
+	u64 addr; // The address that triggered the fault
+	u64 dsisr; // the value of the dsisr register
+	u64 count; // The number of times this fault has been triggered
+};
+
+struct ocxl_context {
+	struct ocxl_afu *afu;
+	int pasid;
+	struct mutex status_mutex;
+	enum ocxl_context_status status;
+	struct address_space *mapping;
+	struct mutex mapping_lock;
+	wait_queue_head_t events_wq;
+	struct mutex xsl_error_lock;
+	struct ocxl_xsl_error xsl_error;
+	struct mutex irq_lock;
+	struct idr irq_idr;
+};
+
+struct ocxl_process_element {
+	__be64 config_state;
+	__be32 reserved1[11];
+	__be32 lpid;
+	__be32 tid;
+	__be32 pid;
+	__be32 reserved2[10];
+	__be64 amr;
+	__be32 reserved3[3];
+	__be32 software_state;
+};
+
+
+extern struct ocxl_afu *ocxl_afu_get(struct ocxl_afu *afu);
+extern void ocxl_afu_put(struct ocxl_afu *afu);
+
+extern int ocxl_create_cdev(struct ocxl_afu *afu);
+extern void ocxl_destroy_cdev(struct ocxl_afu *afu);
+extern int ocxl_register_afu(struct ocxl_afu *afu);
+extern void ocxl_unregister_afu(struct ocxl_afu *afu);
+
+extern int ocxl_file_init(void);
+extern void ocxl_file_exit(void);
+
+extern int ocxl_config_read_function(struct pci_dev *dev,
+				struct ocxl_fn_config *fn);
+
+extern int ocxl_config_check_afu_index(struct pci_dev *dev,
+				struct ocxl_fn_config *fn, int afu_idx);
+extern int ocxl_config_read_afu(struct pci_dev *dev,
+				struct ocxl_fn_config *fn,
+				struct ocxl_afu_config *afu,
+				u8 afu_idx);
+extern int ocxl_config_get_pasid_info(struct pci_dev *dev, int *count);
+extern void ocxl_config_set_afu_pasid(struct pci_dev *dev,
+				int afu_control,
+				int pasid_base, u32 pasid_count_log);
+extern int ocxl_config_get_actag_info(struct pci_dev *dev,
+				u16 *base, u16 *enabled, u16 *supported);
+extern void ocxl_config_set_actag(struct pci_dev *dev, int func_dvsec,
+				u32 tag_first, u32 tag_count);
+extern void ocxl_config_set_afu_actag(struct pci_dev *dev, int afu_control,
+				int actag_base, int actag_count);
+extern void ocxl_config_set_afu_state(struct pci_dev *dev, int afu_control,
+				int enable);
+extern int ocxl_config_set_TL(struct pci_dev *dev, int tl_dvsec);
+extern int ocxl_config_terminate_pasid(struct pci_dev *dev, int afu_control,
+				int pasid);
+
+extern int ocxl_link_setup(struct pci_dev *dev, int PE_mask,
+			void **link_handle);
+extern void ocxl_link_release(struct pci_dev *dev, void *link_handle);
+extern int ocxl_link_add_pe(void *link_handle, int pasid, u32 pidr, u32 tidr,
+		u64 amr, struct mm_struct *mm,
+		void (*xsl_err_cb)(void *data, u64 addr, u64 dsisr),
+		void *xsl_err_data);
+extern int ocxl_link_remove_pe(void *link_handle, int pasid);
+extern int ocxl_link_irq_alloc(void *link_handle, int *hw_irq,
+			u64 *addr);
+extern void ocxl_link_free_irq(void *link_handle, int hw_irq);
+
+extern int ocxl_pasid_afu_alloc(struct ocxl_fn *fn, u32 size);
+extern void ocxl_pasid_afu_free(struct ocxl_fn *fn, u32 start, u32 size);
+extern int ocxl_actag_afu_alloc(struct ocxl_fn *fn, u32 size);
+extern void ocxl_actag_afu_free(struct ocxl_fn *fn, u32 start, u32 size);
+
+extern struct ocxl_context *ocxl_context_alloc(void);
+extern int ocxl_context_init(struct ocxl_context *ctx, struct ocxl_afu *afu,
+			struct address_space *mapping);
+extern int ocxl_context_attach(struct ocxl_context *ctx, u64 amr);
+extern int ocxl_context_mmap(struct ocxl_context *ctx,
+			struct vm_area_struct *vma);
+extern int ocxl_context_detach(struct ocxl_context *ctx);
+extern void ocxl_context_detach_all(struct ocxl_afu *afu);
+extern void ocxl_context_free(struct ocxl_context *ctx);
+
+extern int ocxl_sysfs_add_afu(struct ocxl_afu *afu);
+extern void ocxl_sysfs_remove_afu(struct ocxl_afu *afu);
+
+#endif /* _OCXL_INTERNAL_H_ */
