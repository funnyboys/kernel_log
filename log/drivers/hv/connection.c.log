commit 8b6a877c060ed6b86878fe66c7c6493a6054cf23
Author: Andrea Parri (Microsoft) <parri.andrea@gmail.com>
Date:   Mon Apr 6 02:15:06 2020 +0200

    Drivers: hv: vmbus: Replace the per-CPU channel lists with a global array of channels
    
    When Hyper-V sends an interrupt to the guest, the guest has to figure
    out which channel the interrupt is associated with.  Hyper-V sets a bit
    in a memory page that is shared with the guest, indicating a particular
    "relid" that the interrupt is associated with.  The current Linux code
    then uses a set of per-CPU linked lists to map a given "relid" to a
    pointer to a channel structure.
    
    This design introduces a synchronization problem if the CPU that Hyper-V
    will interrupt for a certain channel is changed.  If the interrupt comes
    on the "old CPU" and the channel was already moved to the per-CPU list
    of the "new CPU", then the relid -> channel mapping will fail and the
    interrupt is dropped.  Similarly, if the interrupt comes on the new CPU
    but the channel was not moved to the per-CPU list of the new CPU, then
    the mapping will fail and the interrupt is dropped.
    
    Relids are integers ranging from 0 to 2047.  The mapping from relids to
    channel structures can be done by setting up an array with 2048 entries,
    each entry being a pointer to a channel structure (hence total size ~16K
    bytes, which is not a problem).  The array is global, so there are no
    per-CPU linked lists to update.  The array can be searched and updated
    by loading from/storing to the array at the specified index.  With no
    per-CPU data structures, the above mentioned synchronization problem is
    avoided and the relid2channel() function gets simpler.
    
    Suggested-by: Michael Kelley <mikelley@microsoft.com>
    Signed-off-by: Andrea Parri (Microsoft) <parri.andrea@gmail.com>
    Link: https://lore.kernel.org/r/20200406001514.19876-4-parri.andrea@gmail.com
    Reviewed-by: Michael Kelley <mikelley@microsoft.com>
    Signed-off-by: Wei Liu <wei.liu@kernel.org>

diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index f4bd306d2cef..11170d9a2e1a 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -248,6 +248,14 @@ int vmbus_connect(void)
 	pr_info("Vmbus version:%d.%d\n",
 		version >> 16, version & 0xFFFF);
 
+	vmbus_connection.channels = kcalloc(MAX_CHANNEL_RELIDS,
+					    sizeof(struct vmbus_channel *),
+					    GFP_KERNEL);
+	if (vmbus_connection.channels == NULL) {
+		ret = -ENOMEM;
+		goto cleanup;
+	}
+
 	kfree(msginfo);
 	return 0;
 
@@ -295,33 +303,9 @@ void vmbus_disconnect(void)
  */
 struct vmbus_channel *relid2channel(u32 relid)
 {
-	struct vmbus_channel *channel;
-	struct vmbus_channel *found_channel  = NULL;
-	struct list_head *cur, *tmp;
-	struct vmbus_channel *cur_sc;
-
-	BUG_ON(!mutex_is_locked(&vmbus_connection.channel_mutex));
-
-	list_for_each_entry(channel, &vmbus_connection.chn_list, listentry) {
-		if (channel->offermsg.child_relid == relid) {
-			found_channel = channel;
-			break;
-		} else if (!list_empty(&channel->sc_list)) {
-			/*
-			 * Deal with sub-channels.
-			 */
-			list_for_each_safe(cur, tmp, &channel->sc_list) {
-				cur_sc = list_entry(cur, struct vmbus_channel,
-							sc_list);
-				if (cur_sc->offermsg.child_relid == relid) {
-					found_channel = cur_sc;
-					break;
-				}
-			}
-		}
-	}
-
-	return found_channel;
+	if (WARN_ON(relid >= MAX_CHANNEL_RELIDS))
+		return NULL;
+	return READ_ONCE(vmbus_connection.channels[relid]);
 }
 
 /*

commit 8a857c55420f29da4fc131adc22b12d474c48f4c
Author: Andrea Parri (Microsoft) <parri.andrea@gmail.com>
Date:   Mon Apr 6 02:15:04 2020 +0200

    Drivers: hv: vmbus: Always handle the VMBus messages on CPU0
    
    A Linux guest have to pick a "connect CPU" to communicate with the
    Hyper-V host.  This CPU can not be taken offline because Hyper-V does
    not provide a way to change that CPU assignment.
    
    Current code sets the connect CPU to whatever CPU ends up running the
    function vmbus_negotiate_version(), and this will generate problems if
    that CPU is taken offine.
    
    Establish CPU0 as the connect CPU, and add logics to prevents the
    connect CPU from being taken offline.   We could pick some other CPU,
    and we could pick that "other CPU" dynamically if there was a reason to
    do so at some point in the future.  But for now, #defining the connect
    CPU to 0 is the most straightforward and least complex solution.
    
    While on this, add inline comments explaining "why" offer and rescind
    messages should not be handled by a same serialized work queue.
    
    Suggested-by: Dexuan Cui <decui@microsoft.com>
    Signed-off-by: Andrea Parri (Microsoft) <parri.andrea@gmail.com>
    Reviewed-by: Vitaly Kuznetsov <vkuznets@redhat.com>
    Link: https://lore.kernel.org/r/20200406001514.19876-2-parri.andrea@gmail.com
    Reviewed-by: Michael Kelley <mikelley@microsoft.com>
    Signed-off-by: Wei Liu <wei.liu@kernel.org>

diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index 74e77de89b4f..f4bd306d2cef 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -69,7 +69,6 @@ MODULE_PARM_DESC(max_version,
 int vmbus_negotiate_version(struct vmbus_channel_msginfo *msginfo, u32 version)
 {
 	int ret = 0;
-	unsigned int cur_cpu;
 	struct vmbus_channel_initiate_contact *msg;
 	unsigned long flags;
 
@@ -102,24 +101,7 @@ int vmbus_negotiate_version(struct vmbus_channel_msginfo *msginfo, u32 version)
 
 	msg->monitor_page1 = virt_to_phys(vmbus_connection.monitor_pages[0]);
 	msg->monitor_page2 = virt_to_phys(vmbus_connection.monitor_pages[1]);
-	/*
-	 * We want all channel messages to be delivered on CPU 0.
-	 * This has been the behavior pre-win8. This is not
-	 * perf issue and having all channel messages delivered on CPU 0
-	 * would be ok.
-	 * For post win8 hosts, we support receiving channel messagges on
-	 * all the CPUs. This is needed for kexec to work correctly where
-	 * the CPU attempting to connect may not be CPU 0.
-	 */
-	if (version >= VERSION_WIN8_1) {
-		cur_cpu = get_cpu();
-		msg->target_vcpu = hv_cpu_number_to_vp_number(cur_cpu);
-		vmbus_connection.connect_cpu = cur_cpu;
-		put_cpu();
-	} else {
-		msg->target_vcpu = 0;
-		vmbus_connection.connect_cpu = 0;
-	}
+	msg->target_vcpu = hv_cpu_number_to_vp_number(VMBUS_CONNECT_CPU);
 
 	/*
 	 * Add to list before we send the request since we may

commit 53edce00ceb7443b6f4615b5c8ad71671723d8f5
Author: Himadri Pandya <himadrispandya@gmail.com>
Date:   Tue Jul 30 09:49:44 2019 +0000

    Drivers: hv: vmbus: Remove dependencies on guest page size
    
    Hyper-V assumes page size to be 4K. This might not be the case for ARM64
    architecture. Hence use hyper-v page size and page allocation function
    to avoid conflicts between different host and guest page size on ARM64.
    
    Signed-off-by: Himadri Pandya <himadri18.07@gmail.com>
    Reviewed-by: Michael Kelley <mikelley@microsoft.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index e947c39d4cc7..74e77de89b4f 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -208,7 +208,7 @@ int vmbus_connect(void)
 	 * abstraction stuff
 	 */
 	vmbus_connection.int_page =
-	(void *)__get_free_pages(GFP_KERNEL|__GFP_ZERO, 0);
+	(void *)hv_alloc_hyperv_zeroed_page();
 	if (vmbus_connection.int_page == NULL) {
 		ret = -ENOMEM;
 		goto cleanup;
@@ -217,14 +217,14 @@ int vmbus_connect(void)
 	vmbus_connection.recv_int_page = vmbus_connection.int_page;
 	vmbus_connection.send_int_page =
 		(void *)((unsigned long)vmbus_connection.int_page +
-			(PAGE_SIZE >> 1));
+			(HV_HYP_PAGE_SIZE >> 1));
 
 	/*
 	 * Setup the monitor notification facility. The 1st page for
 	 * parent->child and the 2nd page for child->parent
 	 */
-	vmbus_connection.monitor_pages[0] = (void *)__get_free_pages((GFP_KERNEL|__GFP_ZERO), 0);
-	vmbus_connection.monitor_pages[1] = (void *)__get_free_pages((GFP_KERNEL|__GFP_ZERO), 0);
+	vmbus_connection.monitor_pages[0] = (void *)hv_alloc_hyperv_zeroed_page();
+	vmbus_connection.monitor_pages[1] = (void *)hv_alloc_hyperv_zeroed_page();
 	if ((vmbus_connection.monitor_pages[0] == NULL) ||
 	    (vmbus_connection.monitor_pages[1] == NULL)) {
 		ret = -ENOMEM;
@@ -297,12 +297,12 @@ void vmbus_disconnect(void)
 		destroy_workqueue(vmbus_connection.work_queue);
 
 	if (vmbus_connection.int_page) {
-		free_pages((unsigned long)vmbus_connection.int_page, 0);
+		hv_free_hyperv_page((unsigned long)vmbus_connection.int_page);
 		vmbus_connection.int_page = NULL;
 	}
 
-	free_pages((unsigned long)vmbus_connection.monitor_pages[0], 0);
-	free_pages((unsigned long)vmbus_connection.monitor_pages[1], 0);
+	hv_free_hyperv_page((unsigned long)vmbus_connection.monitor_pages[0]);
+	hv_free_hyperv_page((unsigned long)vmbus_connection.monitor_pages[1]);
 	vmbus_connection.monitor_pages[0] = NULL;
 	vmbus_connection.monitor_pages[1] = NULL;
 }

commit af9ca6f9bb16e446a44393a797d0ae74d356a5c7
Author: Branden Bonaby <brandonbonaby94@gmail.com>
Date:   Thu Oct 3 17:01:49 2019 -0400

    drivers: hv: vmbus: Introduce latency testing
    
    Introduce user specified latency in the packet reception path
    By exposing the test parameters as part of the debugfs channel
    attributes. We will control the testing state via these attributes.
    
    Signed-off-by: Branden Bonaby <brandonbonaby94@gmail.com>
    Reviewed-by: Michael Kelley <mikelley@microsoft.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index 0475be4356dd..e947c39d4cc7 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -363,6 +363,7 @@ void vmbus_on_event(unsigned long data)
 
 	trace_vmbus_on_event(channel);
 
+	hv_debug_delay_test(channel, INTERRUPT_DELAY);
 	do {
 		void (*callback_fn)(void *);
 

commit 931cccc967730d43bb6325506baf51c8f83a9a58
Author: Andrea Parri <parri.andrea@gmail.com>
Date:   Tue Oct 15 13:46:46 2019 +0200

    Drivers: hv: vmbus: Add module parameter to cap the VMBus version
    
    Currently, Linux guests negotiate the VMBus version with Hyper-V
    and use the highest available VMBus version they can connect to.
    This has some drawbacks: by using the highest available version,
    certain code paths are never executed and can not be tested when
    the guest runs on the newest host.
    
    Add the module parameter "max_version", to upper-bound the VMBus
    versions guests can negotiate.
    
    Suggested-by: Dexuan Cui <decui@microsoft.com>
    Signed-off-by: Andrea Parri <parri.andrea@gmail.com>
    Reviewed-by: Wei Liu <wei.liu@kernel.org>
    Reviewed-by: Michael Kelley <mikelley@microsoft.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index cadfb34b38d8..0475be4356dd 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -14,6 +14,7 @@
 #include <linux/wait.h>
 #include <linux/delay.h>
 #include <linux/mm.h>
+#include <linux/module.h>
 #include <linux/slab.h>
 #include <linux/vmalloc.h>
 #include <linux/hyperv.h>
@@ -55,6 +56,16 @@ static __u32 vmbus_versions[] = {
 	VERSION_WS2008
 };
 
+/*
+ * Maximal VMBus protocol version guests can negotiate.  Useful to cap the
+ * VMBus version for testing and debugging purpose.
+ */
+static uint max_version = VERSION_WIN10_V5_2;
+
+module_param(max_version, uint, S_IRUGO);
+MODULE_PARM_DESC(max_version,
+		 "Maximal VMBus protocol version which can be negotiated");
+
 int vmbus_negotiate_version(struct vmbus_channel_msginfo *msginfo, u32 version)
 {
 	int ret = 0;
@@ -240,6 +251,8 @@ int vmbus_connect(void)
 			goto cleanup;
 
 		version = vmbus_versions[i];
+		if (version > max_version)
+			continue;
 
 		ret = vmbus_negotiate_version(msginfo, version);
 		if (ret == -ETIMEDOUT)

commit 2d4f49b3e1e3a24ce16dfeeb2235688c8aba57ef
Author: Andrea Parri <parri.andrea@gmail.com>
Date:   Tue Oct 15 13:46:45 2019 +0200

    Drivers: hv: vmbus: Enable VMBus protocol versions 4.1, 5.1 and 5.2
    
    Hyper-V has added VMBus protocol versions 5.1 and 5.2 in recent release
    versions.  Allow Linux guests to negotiate these new protocol versions
    on versions of Hyper-V that support them.  While on this, also allow
    guests to negotiate the VMBus protocol version 4.1 (which was missing).
    
    Signed-off-by: Andrea Parri <parri.andrea@gmail.com>
    Reviewed-by: Wei Liu <wei.liu@kernel.org>
    Reviewed-by: Michael Kelley <mikelley@microsoft.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index 8dc48f53c1ac..cadfb34b38d8 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -44,7 +44,10 @@ EXPORT_SYMBOL_GPL(vmbus_proto_version);
  * Table of VMBus versions listed from newest to oldest.
  */
 static __u32 vmbus_versions[] = {
+	VERSION_WIN10_V5_2,
+	VERSION_WIN10_V5_1,
 	VERSION_WIN10_V5,
+	VERSION_WIN10_V4_1,
 	VERSION_WIN10,
 	VERSION_WIN8_1,
 	VERSION_WIN8,
@@ -68,12 +71,12 @@ int vmbus_negotiate_version(struct vmbus_channel_msginfo *msginfo, u32 version)
 	msg->vmbus_version_requested = version;
 
 	/*
-	 * VMBus protocol 5.0 (VERSION_WIN10_V5) requires that we must use
-	 * VMBUS_MESSAGE_CONNECTION_ID_4 for the Initiate Contact Message,
+	 * VMBus protocol 5.0 (VERSION_WIN10_V5) and higher require that we must
+	 * use VMBUS_MESSAGE_CONNECTION_ID_4 for the Initiate Contact Message,
 	 * and for subsequent messages, we must use the Message Connection ID
 	 * field in the host-returned Version Response Message. And, with
-	 * VERSION_WIN10_V5, we don't use msg->interrupt_page, but we tell
-	 * the host explicitly that we still use VMBUS_MESSAGE_SINT(2) for
+	 * VERSION_WIN10_V5 and higher, we don't use msg->interrupt_page, but we
+	 * tell the host explicitly that we still use VMBUS_MESSAGE_SINT(2) for
 	 * compatibility.
 	 *
 	 * On old hosts, we should always use VMBUS_MESSAGE_CONNECTION_ID (1).
@@ -399,7 +402,7 @@ int vmbus_post_msg(void *buffer, size_t buflen, bool can_sleep)
 		case HV_STATUS_INVALID_CONNECTION_ID:
 			/*
 			 * See vmbus_negotiate_version(): VMBus protocol 5.0
-			 * requires that we must use
+			 * and higher require that we must use
 			 * VMBUS_MESSAGE_CONNECTION_ID_4 for the Initiate
 			 * Contact message, but on old hosts that only
 			 * support VMBus protocol 4.0 or lower, here we get

commit bedc61a922f9dbbe3bfb26ec2745f8cd63b57637
Author: Andrea Parri <parri.andrea@gmail.com>
Date:   Tue Oct 15 13:46:44 2019 +0200

    Drivers: hv: vmbus: Introduce table of VMBus protocol versions
    
    The technique used to get the next VMBus version seems increasisly
    clumsy as the number of VMBus versions increases.  Performance is
    not a concern since this is only done once during system boot; it's
    just that we'll end up with more lines of code than is really needed.
    
    As an alternative, introduce a table with the version numbers listed
    in order (from the most recent to the oldest).  vmbus_connect() loops
    through the versions listed in the table until it gets an accepted
    connection or gets to the end of the table (invalid version).
    
    Suggested-by: Michael Kelley <mikelley@microsoft.com>
    Signed-off-by: Andrea Parri <parri.andrea@gmail.com>
    Reviewed-by: Wei Liu <wei.liu@kernel.org>
    Reviewed-by: Michael Kelley <mikelley@microsoft.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index 6e4c015783ff..8dc48f53c1ac 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -40,29 +40,17 @@ EXPORT_SYMBOL_GPL(vmbus_connection);
 __u32 vmbus_proto_version;
 EXPORT_SYMBOL_GPL(vmbus_proto_version);
 
-static __u32 vmbus_get_next_version(__u32 current_version)
-{
-	switch (current_version) {
-	case (VERSION_WIN7):
-		return VERSION_WS2008;
-
-	case (VERSION_WIN8):
-		return VERSION_WIN7;
-
-	case (VERSION_WIN8_1):
-		return VERSION_WIN8;
-
-	case (VERSION_WIN10):
-		return VERSION_WIN8_1;
-
-	case (VERSION_WIN10_V5):
-		return VERSION_WIN10;
-
-	case (VERSION_WS2008):
-	default:
-		return VERSION_INVAL;
-	}
-}
+/*
+ * Table of VMBus versions listed from newest to oldest.
+ */
+static __u32 vmbus_versions[] = {
+	VERSION_WIN10_V5,
+	VERSION_WIN10,
+	VERSION_WIN8_1,
+	VERSION_WIN8,
+	VERSION_WIN7,
+	VERSION_WS2008
+};
 
 int vmbus_negotiate_version(struct vmbus_channel_msginfo *msginfo, u32 version)
 {
@@ -169,8 +157,8 @@ int vmbus_negotiate_version(struct vmbus_channel_msginfo *msginfo, u32 version)
  */
 int vmbus_connect(void)
 {
-	int ret = 0;
 	struct vmbus_channel_msginfo *msginfo = NULL;
+	int i, ret = 0;
 	__u32 version;
 
 	/* Initialize the vmbus connection */
@@ -244,21 +232,19 @@ int vmbus_connect(void)
 	 * version.
 	 */
 
-	version = VERSION_CURRENT;
+	for (i = 0; ; i++) {
+		if (i == ARRAY_SIZE(vmbus_versions))
+			goto cleanup;
+
+		version = vmbus_versions[i];
 
-	do {
 		ret = vmbus_negotiate_version(msginfo, version);
 		if (ret == -ETIMEDOUT)
 			goto cleanup;
 
 		if (vmbus_connection.conn_state == CONNECTED)
 			break;
-
-		version = vmbus_get_next_version(version);
-	} while (version != VERSION_INVAL);
-
-	if (version == VERSION_INVAL)
-		goto cleanup;
+	}
 
 	vmbus_proto_version = version;
 	pr_info("Vmbus version:%d.%d\n",

commit d8bd2d442bb2688b428ac7164e5dc6d95d4fa65b
Author: Dexuan Cui <decui@microsoft.com>
Date:   Thu Sep 5 23:01:22 2019 +0000

    Drivers: hv: vmbus: Resume after fixing up old primary channels
    
    When the host re-offers the primary channels upon resume, the host only
    guarantees the Instance GUID  doesn't change, so vmbus_bus_suspend()
    should invalidate channel->offermsg.child_relid and figure out the
    number of primary channels that need to be fixed up upon resume.
    
    Upon resume, vmbus_onoffer() finds the old channel structs, and maps
    the new offers to the old channels, and fixes up the old structs,
    and finally the resume callbacks of the VSC drivers will re-open
    the channels.
    
    Signed-off-by: Dexuan Cui <decui@microsoft.com>
    Reviewed-by: Michael Kelley <mikelley@microsoft.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index 99851ea682eb..6e4c015783ff 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -29,6 +29,8 @@ struct vmbus_connection vmbus_connection = {
 
 	.ready_for_suspend_event= COMPLETION_INITIALIZER(
 				  vmbus_connection.ready_for_suspend_event),
+	.ready_for_resume_event	= COMPLETION_INITIALIZER(
+				  vmbus_connection.ready_for_resume_event),
 };
 EXPORT_SYMBOL_GPL(vmbus_connection);
 

commit b307b38962eb0f22d1aa6dcf53cb7d3c2ed5eec7
Author: Dexuan Cui <decui@microsoft.com>
Date:   Thu Sep 5 23:01:21 2019 +0000

    Drivers: hv: vmbus: Suspend after cleaning up hv_sock and sub channels
    
    Before suspend, Linux must make sure all the hv_sock channels have been
    properly cleaned up, because a hv_sock connection can not persist across
    hibernation, and the user-space app must be properly notified of the
    state change of the connection.
    
    Before suspend, Linux also must make sure all the sub-channels have been
    destroyed, i.e. the related channel structs of the sub-channels must be
    properly removed, otherwise they would cause a conflict when the
    sub-channels are recreated upon resume.
    
    Add a counter to track such channels, and vmbus_bus_suspend() should wait
    for the counter to drop to zero.
    
    Signed-off-by: Dexuan Cui <decui@microsoft.com>
    Reviewed-by: Michael Kelley <mikelley@microsoft.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index 806319cd5ccf..99851ea682eb 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -26,6 +26,9 @@
 struct vmbus_connection vmbus_connection = {
 	.conn_state		= DISCONNECTED,
 	.next_gpadl_handle	= ATOMIC_INIT(0xE1E10),
+
+	.ready_for_suspend_event= COMPLETION_INITIALIZER(
+				  vmbus_connection.ready_for_suspend_event),
 };
 EXPORT_SYMBOL_GPL(vmbus_connection);
 

commit f53335e3289f9ac3a6a8faf6c2f819eee508bd39
Author: Dexuan Cui <decui@microsoft.com>
Date:   Thu Sep 5 23:01:19 2019 +0000

    Drivers: hv: vmbus: Suspend/resume the vmbus itself for hibernation
    
    Before Linux enters hibernation, it sends the CHANNELMSG_UNLOAD message to
    the host so all the offers are gone. After hibernation, Linux needs to
    re-negotiate with the host using the same vmbus protocol version (which
    was in use before hibernation), and ask the host to re-offer the vmbus
    devices.
    
    Signed-off-by: Dexuan Cui <decui@microsoft.com>
    Reviewed-by: Michael Kelley <mikelley@microsoft.com>
    Signed-off-by: Sasha Levin <sashal@kernel.org>

diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index 09829e15d4a0..806319cd5ccf 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -59,8 +59,7 @@ static __u32 vmbus_get_next_version(__u32 current_version)
 	}
 }
 
-static int vmbus_negotiate_version(struct vmbus_channel_msginfo *msginfo,
-					__u32 version)
+int vmbus_negotiate_version(struct vmbus_channel_msginfo *msginfo, u32 version)
 {
 	int ret = 0;
 	unsigned int cur_cpu;

commit 3b20eb23724d493eca79f02b1e062bd5432e29d0
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 16:57:35 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 320
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms and conditions of the gnu general public license
      version 2 as published by the free software foundation this program
      is distributed in the hope it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details you should have received a copy of the gnu general
      public license along with this program if not write to the free
      software foundation inc 59 temple place suite 330 boston ma 02111
      1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 33 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190530000435.254582722@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index 4fe117b761ce..09829e15d4a0 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -1,24 +1,11 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  *
  * Copyright (c) 2009, Microsoft Corporation.
  *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
- * Place - Suite 330, Boston, MA 02111-1307 USA.
- *
  * Authors:
  *   Haiyang Zhang <haiyangz@microsoft.com>
  *   Hank Janssen  <hjanssen@microsoft.com>
- *
  */
 #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
 

commit 37c2578c0c40e286bc0d30bdc05290b2058cf66e
Author: Dexuan Cui <decui@microsoft.com>
Date:   Mon Dec 3 00:54:35 2018 +0000

    Drivers: hv: vmbus: Offload the handling of channels to two workqueues
    
    vmbus_process_offer() mustn't call channel->sc_creation_callback()
    directly for sub-channels, because sc_creation_callback() ->
    vmbus_open() may never get the host's response to the
    OPEN_CHANNEL message (the host may rescind a channel at any time,
    e.g. in the case of hot removing a NIC), and vmbus_onoffer_rescind()
    may not wake up the vmbus_open() as it's blocked due to a non-zero
    vmbus_connection.offer_in_progress, and finally we have a deadlock.
    
    The above is also true for primary channels, if the related device
    drivers use sync probing mode by default.
    
    And, usually the handling of primary channels and sub-channels can
    depend on each other, so we should offload them to different
    workqueues to avoid possible deadlock, e.g. in sync-probing mode,
    NIC1's netvsc_subchan_work() can race with NIC2's netvsc_probe() ->
    rtnl_lock(), and causes deadlock: the former gets the rtnl_lock
    and waits for all the sub-channels to appear, but the latter
    can't get the rtnl_lock and this blocks the handling of sub-channels.
    
    The patch can fix the multiple-NIC deadlock described above for
    v3.x kernels (e.g. RHEL 7.x) which don't support async-probing
    of devices, and v4.4, v4.9, v4.14 and v4.18 which support async-probing
    but don't enable async-probing for Hyper-V drivers (yet).
    
    The patch can also fix the hang issue in sub-channel's handling described
    above for all versions of kernels, including v4.19 and v4.20-rc4.
    
    So actually the patch should be applied to all the existing kernels,
    not only the kernels that have 8195b1396ec8.
    
    Fixes: 8195b1396ec8 ("hv_netvsc: fix deadlock on hotplug")
    Cc: stable@vger.kernel.org
    Cc: Stephen Hemminger <sthemmin@microsoft.com>
    Cc: K. Y. Srinivasan <kys@microsoft.com>
    Cc: Haiyang Zhang <haiyangz@microsoft.com>
    Signed-off-by: Dexuan Cui <decui@microsoft.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index f4d08c8ac7f8..4fe117b761ce 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -190,6 +190,20 @@ int vmbus_connect(void)
 		goto cleanup;
 	}
 
+	vmbus_connection.handle_primary_chan_wq =
+		create_workqueue("hv_pri_chan");
+	if (!vmbus_connection.handle_primary_chan_wq) {
+		ret = -ENOMEM;
+		goto cleanup;
+	}
+
+	vmbus_connection.handle_sub_chan_wq =
+		create_workqueue("hv_sub_chan");
+	if (!vmbus_connection.handle_sub_chan_wq) {
+		ret = -ENOMEM;
+		goto cleanup;
+	}
+
 	INIT_LIST_HEAD(&vmbus_connection.chn_msg_list);
 	spin_lock_init(&vmbus_connection.channelmsg_lock);
 
@@ -280,10 +294,14 @@ void vmbus_disconnect(void)
 	 */
 	vmbus_initiate_unload(false);
 
-	if (vmbus_connection.work_queue) {
-		drain_workqueue(vmbus_connection.work_queue);
+	if (vmbus_connection.handle_sub_chan_wq)
+		destroy_workqueue(vmbus_connection.handle_sub_chan_wq);
+
+	if (vmbus_connection.handle_primary_chan_wq)
+		destroy_workqueue(vmbus_connection.handle_primary_chan_wq);
+
+	if (vmbus_connection.work_queue)
 		destroy_workqueue(vmbus_connection.work_queue);
-	}
 
 	if (vmbus_connection.int_page) {
 		free_pages((unsigned long)vmbus_connection.int_page, 0);

commit 41e270f6898e7502be9fd6920ee0a108ca259d36
Author: Dexuan Cui <decui@microsoft.com>
Date:   Mon Sep 17 04:14:54 2018 +0000

    Drivers: hv: vmbus: Use get/put_cpu() in vmbus_connect()
    
    With CONFIG_DEBUG_PREEMPT=y, I always see this warning:
    BUG: using smp_processor_id() in preemptible [00000000]
    
    Fix the false warning by using get/put_cpu().
    
    Here vmbus_connect() sends a message to the host and waits for the
    host's response. The host will deliver the response message and an
    interrupt on CPU msg->target_vcpu, and later the interrupt handler
    will wake up vmbus_connect(). vmbus_connect() doesn't really have
    to run on the same cpu as CPU msg->target_vcpu, so it's safe to
    call put_cpu() just here.
    
    Signed-off-by: Dexuan Cui <decui@microsoft.com>
    Cc: stable@vger.kernel.org
    Cc: K. Y. Srinivasan <kys@microsoft.com>
    Cc: Haiyang Zhang <haiyangz@microsoft.com>
    Cc: Stephen Hemminger <sthemmin@microsoft.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index ced041899456..f4d08c8ac7f8 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -76,6 +76,7 @@ static int vmbus_negotiate_version(struct vmbus_channel_msginfo *msginfo,
 					__u32 version)
 {
 	int ret = 0;
+	unsigned int cur_cpu;
 	struct vmbus_channel_initiate_contact *msg;
 	unsigned long flags;
 
@@ -118,9 +119,10 @@ static int vmbus_negotiate_version(struct vmbus_channel_msginfo *msginfo,
 	 * the CPU attempting to connect may not be CPU 0.
 	 */
 	if (version >= VERSION_WIN8_1) {
-		msg->target_vcpu =
-			hv_cpu_number_to_vp_number(smp_processor_id());
-		vmbus_connection.connect_cpu = smp_processor_id();
+		cur_cpu = get_cpu();
+		msg->target_vcpu = hv_cpu_number_to_vp_number(cur_cpu);
+		vmbus_connection.connect_cpu = cur_cpu;
+		put_cpu();
 	} else {
 		msg->target_vcpu = 0;
 		vmbus_connection.connect_cpu = 0;

commit 897609370d25c69e95a174dbd75df6e5bc3a26c8
Author: Dexuan Cui <decui@microsoft.com>
Date:   Tue May 15 00:25:01 2018 +0000

    Drivers: hv: vmbus: Removed an unnecessary cast from void *
    
    In C, we don't need such a cast.
    
    Fixes: ae20b254306a ("Drivers: hv: vmbus: enable VMBus protocol version 5.0")
    Reported-by: Stephen Hemminger <sthemmin@microsoft.com>
    Signed-off-by: Dexuan Cui <decui@microsoft.com>
    Cc: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index 19e046820fda..ced041899456 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -409,7 +409,7 @@ int vmbus_post_msg(void *buffer, size_t buflen, bool can_sleep)
 			 * HV_STATUS_INVALID_CONNECTION_ID and we should
 			 * return an error immediately without retrying.
 			 */
-			hdr = (struct vmbus_channel_message_header *)buffer;
+			hdr = buffer;
 			if (hdr->msgtype == CHANNELMSG_INITIATE_CONTACT)
 				return -EINVAL;
 			/*

commit ae20b254306a6a47054ea0eb8444e0bd8e71fe12
Author: Dexuan Cui <decui@microsoft.com>
Date:   Sat May 12 02:30:33 2018 -0700

    Drivers: hv: vmbus: enable VMBus protocol version 5.0
    
    With VMBus protocol 5.0, we're able to better support new features, e.g.
    running two or more VMBus drivers simultaneously in a single VM -- note:
    we can't simply load the current VMBus driver twice, instead, a secondary
    VMBus driver must be implemented.
    
    This patch adds the support for the new VMBus protocol, which is available
    on new Windows hosts, by:
    
    1) We still use SINT2 for compatibility;
    2) We must use Connection ID 4 for the Initiate Contact Message, and for
    subsequent messages, we must use the Message Connection ID field in
    the host-returned VersionResponse Message.
    
    Notes for developers of the secondary VMBus driver:
    1) Must use VMBus protocol 5.0 as well;
    2) Must use a different SINT number that is not in use.
    3) Must use Connection ID 4 for the Initiate Contact Message, and for
    subsequent messages, must use the Message Connection ID field in
    the host-returned VersionResponse Message.
    4) It's possible that the primary VMBus driver using protocol version 4.0
    can work with a secondary VMBus driver using protocol version 5.0, but it's
    recommended that both should use 5.0 for new Hyper-V features in the future.
    
    Signed-off-by: Dexuan Cui <decui@microsoft.com>
    Cc: Stephen Hemminger <sthemmin@microsoft.com>
    Cc: K. Y. Srinivasan <kys@microsoft.com>
    Cc: Michael Kelley <mikelley@microsoft.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index 72855182b191..19e046820fda 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -63,6 +63,9 @@ static __u32 vmbus_get_next_version(__u32 current_version)
 	case (VERSION_WIN10):
 		return VERSION_WIN8_1;
 
+	case (VERSION_WIN10_V5):
+		return VERSION_WIN10;
+
 	case (VERSION_WS2008):
 	default:
 		return VERSION_INVAL;
@@ -80,9 +83,29 @@ static int vmbus_negotiate_version(struct vmbus_channel_msginfo *msginfo,
 
 	msg = (struct vmbus_channel_initiate_contact *)msginfo->msg;
 
+	memset(msg, 0, sizeof(*msg));
 	msg->header.msgtype = CHANNELMSG_INITIATE_CONTACT;
 	msg->vmbus_version_requested = version;
-	msg->interrupt_page = virt_to_phys(vmbus_connection.int_page);
+
+	/*
+	 * VMBus protocol 5.0 (VERSION_WIN10_V5) requires that we must use
+	 * VMBUS_MESSAGE_CONNECTION_ID_4 for the Initiate Contact Message,
+	 * and for subsequent messages, we must use the Message Connection ID
+	 * field in the host-returned Version Response Message. And, with
+	 * VERSION_WIN10_V5, we don't use msg->interrupt_page, but we tell
+	 * the host explicitly that we still use VMBUS_MESSAGE_SINT(2) for
+	 * compatibility.
+	 *
+	 * On old hosts, we should always use VMBUS_MESSAGE_CONNECTION_ID (1).
+	 */
+	if (version >= VERSION_WIN10_V5) {
+		msg->msg_sint = VMBUS_MESSAGE_SINT;
+		vmbus_connection.msg_conn_id = VMBUS_MESSAGE_CONNECTION_ID_4;
+	} else {
+		msg->interrupt_page = virt_to_phys(vmbus_connection.int_page);
+		vmbus_connection.msg_conn_id = VMBUS_MESSAGE_CONNECTION_ID;
+	}
+
 	msg->monitor_page1 = virt_to_phys(vmbus_connection.monitor_pages[0]);
 	msg->monitor_page2 = virt_to_phys(vmbus_connection.monitor_pages[1]);
 	/*
@@ -137,6 +160,10 @@ static int vmbus_negotiate_version(struct vmbus_channel_msginfo *msginfo,
 	/* Check if successful */
 	if (msginfo->response.version_response.version_supported) {
 		vmbus_connection.conn_state = CONNECTED;
+
+		if (version >= VERSION_WIN10_V5)
+			vmbus_connection.msg_conn_id =
+				msginfo->response.version_response.msg_conn_id;
 	} else {
 		return -ECONNREFUSED;
 	}
@@ -354,13 +381,14 @@ void vmbus_on_event(unsigned long data)
  */
 int vmbus_post_msg(void *buffer, size_t buflen, bool can_sleep)
 {
+	struct vmbus_channel_message_header *hdr;
 	union hv_connection_id conn_id;
 	int ret = 0;
 	int retries = 0;
 	u32 usec = 1;
 
 	conn_id.asu32 = 0;
-	conn_id.u.id = VMBUS_MESSAGE_CONNECTION_ID;
+	conn_id.u.id = vmbus_connection.msg_conn_id;
 
 	/*
 	 * hv_post_message() can have transient failures because of
@@ -372,6 +400,18 @@ int vmbus_post_msg(void *buffer, size_t buflen, bool can_sleep)
 
 		switch (ret) {
 		case HV_STATUS_INVALID_CONNECTION_ID:
+			/*
+			 * See vmbus_negotiate_version(): VMBus protocol 5.0
+			 * requires that we must use
+			 * VMBUS_MESSAGE_CONNECTION_ID_4 for the Initiate
+			 * Contact message, but on old hosts that only
+			 * support VMBus protocol 4.0 or lower, here we get
+			 * HV_STATUS_INVALID_CONNECTION_ID and we should
+			 * return an error immediately without retrying.
+			 */
+			hdr = (struct vmbus_channel_message_header *)buffer;
+			if (hdr->msgtype == CHANNELMSG_INITIATE_CONTACT)
+				return -EINVAL;
 			/*
 			 * We could get this if we send messages too
 			 * frequently.

commit 5a485803221777013944cbd1a7cd5c62efba3ffa
Author: Vitaly Kuznetsov <vkuznets@redhat.com>
Date:   Tue Mar 20 15:02:05 2018 +0100

    x86/hyper-v: move hyperv.h out of uapi
    
    hyperv.h is not part of uapi, there are no (known) users outside of kernel.
    We are making changes to this file to match current Hyper-V Hypervisor
    Top-Level Functional Specification (TLFS, see:
    https://docs.microsoft.com/en-us/virtualization/hyper-v-on-windows/reference/tlfs)
    and we don't want to maintain backwards compatibility.
    
    Move the file renaming to hyperv-tlfs.h to avoid confusing it with
    mshyperv.h. In future, all definitions from TLFS should go to it and
    all kernel objects should go to mshyperv.h or include/linux/hyperv.h.
    
    Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Radim Krčmář <rkrcmar@redhat.com>

diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index 447371f4de56..72855182b191 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -31,7 +31,6 @@
 #include <linux/vmalloc.h>
 #include <linux/hyperv.h>
 #include <linux/export.h>
-#include <asm/hyperv.h>
 #include <asm/mshyperv.h>
 
 #include "hyperv_vmbus.h"

commit 991f8f1c6eb634688952fa6a03cc0ce949b6e363
Author: Vitaly Kuznetsov <vkuznets@redhat.com>
Date:   Sun Oct 29 12:21:16 2017 -0700

    hyper-v: trace channel events
    
    Added an additional set of trace points for when channel gets notified
    or signals host.
    
    Suggested-by: Stephen Hemminger <sthemmin@microsoft.com>
    Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index 05f413c4fe3b..447371f4de56 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -322,6 +322,8 @@ void vmbus_on_event(unsigned long data)
 	struct vmbus_channel *channel = (void *) data;
 	unsigned long time_limit = jiffies + 2;
 
+	trace_vmbus_on_event(channel);
+
 	do {
 		void (*callback_fn)(void *);
 

commit 034ebf552e0a3403eeb7e7f8a3a502fc0c70a24c
Author: Vitaly Kuznetsov <vkuznets@redhat.com>
Date:   Sun Oct 29 12:21:13 2017 -0700

    hyper-v: trace vmbus_negotiate_version()
    
    Add tracepoint to CHANNELMSG_INITIATE_CONTACT sender.
    
    Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index b06a6b796819..05f413c4fe3b 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -117,6 +117,9 @@ static int vmbus_negotiate_version(struct vmbus_channel_msginfo *msginfo,
 	ret = vmbus_post_msg(msg,
 			     sizeof(struct vmbus_channel_initiate_contact),
 			     true);
+
+	trace_vmbus_negotiate_version(msg, ret);
+
 	if (ret != 0) {
 		spin_lock_irqsave(&vmbus_connection.channelmsg_lock, flags);
 		list_del(&msginfo->msglistentry);

commit 6981fbf3780366093858c5d2dcdaadcd1fbb04be
Author: Stephen Hemminger <stephen@networkplumber.org>
Date:   Sun Oct 29 11:33:40 2017 -0700

    Drivers: hv: vmbus: Expose per-channel interrupts and events counters
    
    When investigating performance, it is useful to be able to look at
    the number of host and guest events per-channel. This is equivalent
    to per-device interrupt statistics.
    
    Signed-off-by: Stephen Hemminger <sthemmin@microsoft.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index f41901f80b64..b06a6b796819 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -409,6 +409,8 @@ void vmbus_set_event(struct vmbus_channel *channel)
 	if (!channel->is_dedicated_interrupt)
 		vmbus_send_interrupt(child_relid);
 
+	++channel->sig_events;
+
 	hv_do_fast_hypercall8(HVCALL_SIGNAL_EVENT, channel->sig_event);
 }
 EXPORT_SYMBOL_GPL(vmbus_set_event);

commit 7415aea6072bab15969b6c3c5b2a193d88095326
Author: Vitaly Kuznetsov <vkuznets@redhat.com>
Date:   Wed Aug 2 18:09:18 2017 +0200

    hyper-v: Globalize vp_index
    
    To support implementing remote TLB flushing on Hyper-V with a hypercall
    we need to make vp_index available outside of vmbus module. Rename and
    globalize.
    
    Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
    Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Reviewed-by: Stephen Hemminger <sthemmin@microsoft.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Haiyang Zhang <haiyangz@microsoft.com>
    Cc: Jork Loeser <Jork.Loeser@microsoft.com>
    Cc: K. Y. Srinivasan <kys@microsoft.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Simon Xiao <sixiao@microsoft.com>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: devel@linuxdriverproject.org
    Link: http://lkml.kernel.org/r/20170802160921.21791-7-vkuznets@redhat.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index 37ecf514189e..f41901f80b64 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -96,7 +96,8 @@ static int vmbus_negotiate_version(struct vmbus_channel_msginfo *msginfo,
 	 * the CPU attempting to connect may not be CPU 0.
 	 */
 	if (version >= VERSION_WIN8_1) {
-		msg->target_vcpu = hv_context.vp_index[smp_processor_id()];
+		msg->target_vcpu =
+			hv_cpu_number_to_vp_number(smp_processor_id());
 		vmbus_connection.connect_cpu = smp_processor_id();
 	} else {
 		msg->target_vcpu = 0;

commit 057841713cfff62b4485cdd2b245f05b7ea3ba16
Author: Vitaly Kuznetsov <vkuznets@redhat.com>
Date:   Wed Aug 2 18:09:16 2017 +0200

    hyper-v: Use fast hypercall for HVCALL_SIGNAL_EVENT
    
    We need to pass only 8 bytes of input for HvSignalEvent which makes it a
    perfect fit for fast hypercall. hv_input_signal_event_buffer is not needed
    any more and hv_input_signal_event is converted to union for convenience.
    
    Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
    Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Reviewed-by: Stephen Hemminger <sthemmin@microsoft.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Haiyang Zhang <haiyangz@microsoft.com>
    Cc: Jork Loeser <Jork.Loeser@microsoft.com>
    Cc: K. Y. Srinivasan <kys@microsoft.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Simon Xiao <sixiao@microsoft.com>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: devel@linuxdriverproject.org
    Link: http://lkml.kernel.org/r/20170802160921.21791-5-vkuznets@redhat.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index 45e806e3112f..37ecf514189e 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -408,6 +408,6 @@ void vmbus_set_event(struct vmbus_channel *channel)
 	if (!channel->is_dedicated_interrupt)
 		vmbus_send_interrupt(child_relid);
 
-	hv_do_hypercall(HVCALL_SIGNAL_EVENT, channel->sig_event, NULL);
+	hv_do_fast_hypercall8(HVCALL_SIGNAL_EVENT, channel->sig_event);
 }
 EXPORT_SYMBOL_GPL(vmbus_set_event);

commit fc53662f13b889a5a1c069e79ee1e3d4534df132
Author: Vitaly Kuznetsov <vkuznets@redhat.com>
Date:   Wed Aug 2 18:09:14 2017 +0200

    x86/hyper-v: Make hv_do_hypercall() inline
    
    We have only three call sites for hv_do_hypercall() and we're going to
    change HVCALL_SIGNAL_EVENT to doing fast hypercall so we can inline this
    function for optimization.
    
    Hyper-V top level functional specification states that r9-r11 registers
    and flags may be clobbered by the hypervisor during hypercall and with
    inlining this is somewhat important, add the clobbers.
    
    Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
    Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Reviewed-by: Stephen Hemminger <sthemmin@microsoft.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Cc: Haiyang Zhang <haiyangz@microsoft.com>
    Cc: Jork Loeser <Jork.Loeser@microsoft.com>
    Cc: K. Y. Srinivasan <kys@microsoft.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Simon Xiao <sixiao@microsoft.com>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: devel@linuxdriverproject.org
    Link: http://lkml.kernel.org/r/20170802160921.21791-3-vkuznets@redhat.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index 59c11ff90d12..45e806e3112f 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -32,6 +32,8 @@
 #include <linux/hyperv.h>
 #include <linux/export.h>
 #include <asm/hyperv.h>
+#include <asm/mshyperv.h>
+
 #include "hyperv_vmbus.h"
 
 

commit e917a5e23a87e24931625c344daea834cd2d6f2f
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Thu May 18 10:46:05 2017 -0700

    drivers: hv: vmbus: Increase the time between retries in vmbus_post_msg()
    
    Commit c0bb03924f1a ("Drivers: hv: vmbus: Raise retry/wait limits in
    vmbus_post_msg()") increased the retry/wait limits of vmbus_post_msg()
    to address the new DoS protection policies in WS2016.
    Increase the time between retries to make the
    code more robust.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index c2d74ee95f60..59c11ff90d12 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -390,7 +390,7 @@ int vmbus_post_msg(void *buffer, size_t buflen, bool can_sleep)
 		else
 			mdelay(usec / 1000);
 
-		if (usec < 256000)
+		if (retries < 22)
 			usec *= 2;
 	}
 	return ret;

commit 54a66265d6754b37fb4baf1d970ec88a6225a988
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Sun Apr 30 16:21:18 2017 -0700

    Drivers: hv: vmbus: Fix rescind handling
    
    Fix the rescind handling. This patch addresses the following rescind
    scenario that is currently not handled correctly:
    
    If a rescind were to be received while the offer is still being
    peocessed, we will be blocked indefinitely since the rescind message
    is handled on the same work element as the offer message. Fix this
    issue.
    
    I would like to thank Dexuan Cui <decui@microsoft.com> and
    Long Li <longli@microsoft.com> for working with me on this patch.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index a938fcfe9bc9..c2d74ee95f60 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -93,10 +93,13 @@ static int vmbus_negotiate_version(struct vmbus_channel_msginfo *msginfo,
 	 * all the CPUs. This is needed for kexec to work correctly where
 	 * the CPU attempting to connect may not be CPU 0.
 	 */
-	if (version >= VERSION_WIN8_1)
+	if (version >= VERSION_WIN8_1) {
 		msg->target_vcpu = hv_context.vp_index[smp_processor_id()];
-	else
+		vmbus_connection.connect_cpu = smp_processor_id();
+	} else {
 		msg->target_vcpu = 0;
+		vmbus_connection.connect_cpu = 0;
+	}
 
 	/*
 	 * Add to list before we send the request since we may

commit 48f4ccdfc46906627f77fda94d80f2db1bd23ba3
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Sun Apr 30 16:21:16 2017 -0700

    Drivers: hv: vmbus: Fix error code returned by vmbus_post_msg()
    
    ENOBUFS is a more approrpiate error code to be returned
    when the hypervisor cannot post the message because of
    insufficient buffers. Make the adjustment.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index fce27fb141cc..a938fcfe9bc9 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -370,7 +370,7 @@ int vmbus_post_msg(void *buffer, size_t buflen, bool can_sleep)
 			break;
 		case HV_STATUS_INSUFFICIENT_MEMORY:
 		case HV_STATUS_INSUFFICIENT_BUFFERS:
-			ret = -ENOMEM;
+			ret = -ENOBUFS;
 			break;
 		case HV_STATUS_SUCCESS:
 			return ret;

commit ada6eb11137be0baf846e00fca40fc096ba85a28
Author: Stephen Hemminger <stephen@networkplumber.org>
Date:   Sat Mar 4 18:27:10 2017 -0700

    vmbus: only reschedule tasklet if time limit exceeded
    
    The change to reschedule tasklet if more data arrives in ring buffer
    can cause performance regression if host timing is such that the
    next response happens in small window.
    
    Go back to a modified version of the original looping behavior.
    If the race occurs in a small time, then loop. But if the tasklet
    has been running for a long interval due to flood, then reschedule
    the tasklet to allow migration to ksoftirqd.
    
    Signed-off-by: Stephen Hemminger <sthemmin@microsoft.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index a8366fec1458..fce27fb141cc 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -296,44 +296,47 @@ struct vmbus_channel *relid2channel(u32 relid)
 
 /*
  * vmbus_on_event - Process a channel event notification
+ *
+ * For batched channels (default) optimize host to guest signaling
+ * by ensuring:
+ * 1. While reading the channel, we disable interrupts from host.
+ * 2. Ensure that we process all posted messages from the host
+ *    before returning from this callback.
+ * 3. Once we return, enable signaling from the host. Once this
+ *    state is set we check to see if additional packets are
+ *    available to read. In this case we repeat the process.
+ *    If this tasklet has been running for a long time
+ *    then reschedule ourselves.
  */
 void vmbus_on_event(unsigned long data)
 {
 	struct vmbus_channel *channel = (void *) data;
-	void (*callback_fn)(void *);
+	unsigned long time_limit = jiffies + 2;
 
-	/*
-	 * A channel once created is persistent even when there
-	 * is no driver handling the device. An unloading driver
-	 * sets the onchannel_callback to NULL on the same CPU
-	 * as where this interrupt is handled (in an interrupt context).
-	 * Thus, checking and invoking the driver specific callback takes
-	 * care of orderly unloading of the driver.
-	 */
-	callback_fn = READ_ONCE(channel->onchannel_callback);
-	if (unlikely(callback_fn == NULL))
-		return;
-
-	(*callback_fn)(channel->channel_callback_context);
-
-	if (channel->callback_mode == HV_CALL_BATCHED) {
-		/*
-		 * This callback reads the messages sent by the host.
-		 * We can optimize host to guest signaling by ensuring:
-		 * 1. While reading the channel, we disable interrupts from
-		 *    host.
-		 * 2. Ensure that we process all posted messages from the host
-		 *    before returning from this callback.
-		 * 3. Once we return, enable signaling from the host. Once this
-		 *    state is set we check to see if additional packets are
-		 *    available to read. In this case we repeat the process.
+	do {
+		void (*callback_fn)(void *);
+
+		/* A channel once created is persistent even when
+		 * there is no driver handling the device. An
+		 * unloading driver sets the onchannel_callback to NULL.
 		 */
-		if (hv_end_read(&channel->inbound) != 0) {
-			hv_begin_read(&channel->inbound);
+		callback_fn = READ_ONCE(channel->onchannel_callback);
+		if (unlikely(callback_fn == NULL))
+			return;
 
-			tasklet_schedule(&channel->callback_event);
-		}
-	}
+		(*callback_fn)(channel->channel_callback_context);
+
+		if (channel->callback_mode != HV_CALL_BATCHED)
+			return;
+
+		if (likely(hv_end_read(&channel->inbound) == 0))
+			return;
+
+		hv_begin_read(&channel->inbound);
+	} while (likely(time_before(jiffies, time_limit)));
+
+	/* The time limit (2 jiffies) has been reached */
+	tasklet_schedule(&channel->callback_event);
 }
 
 /*

commit b71e328297a3a578c482fb4814e737a0ec185839
Author: Stephen Hemminger <stephen@networkplumber.org>
Date:   Sat Feb 11 23:02:21 2017 -0700

    vmbus: add direct isr callback mode
    
    Change the simple boolean batched_reading into a tri-value.
    For future NAPI support in netvsc driver, the callback needs to
    occur directly in interrupt handler.
    
    Batched mode is also changed to disable host interrupts immediately
    in interrupt routine (to avoid unnecessary host signals), and the
    tasklet is rescheduled if more data is detected.
    
    Signed-off-by: Stephen Hemminger <sthemmin@microsoft.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index 27e72dc07e12..a8366fec1458 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -300,9 +300,7 @@ struct vmbus_channel *relid2channel(u32 relid)
 void vmbus_on_event(unsigned long data)
 {
 	struct vmbus_channel *channel = (void *) data;
-	void *arg;
-	bool read_state;
-	u32 bytes_to_read;
+	void (*callback_fn)(void *);
 
 	/*
 	 * A channel once created is persistent even when there
@@ -312,9 +310,13 @@ void vmbus_on_event(unsigned long data)
 	 * Thus, checking and invoking the driver specific callback takes
 	 * care of orderly unloading of the driver.
 	 */
-	if (channel->onchannel_callback != NULL) {
-		arg = channel->channel_callback_context;
-		read_state = channel->batched_reading;
+	callback_fn = READ_ONCE(channel->onchannel_callback);
+	if (unlikely(callback_fn == NULL))
+		return;
+
+	(*callback_fn)(channel->channel_callback_context);
+
+	if (channel->callback_mode == HV_CALL_BATCHED) {
 		/*
 		 * This callback reads the messages sent by the host.
 		 * We can optimize host to guest signaling by ensuring:
@@ -326,16 +328,11 @@ void vmbus_on_event(unsigned long data)
 		 *    state is set we check to see if additional packets are
 		 *    available to read. In this case we repeat the process.
 		 */
+		if (hv_end_read(&channel->inbound) != 0) {
+			hv_begin_read(&channel->inbound);
 
-		do {
-			if (read_state)
-				hv_begin_read(&channel->inbound);
-			channel->onchannel_callback(arg);
-			if (read_state)
-				bytes_to_read = hv_end_read(&channel->inbound);
-			else
-				bytes_to_read = 0;
-		} while (read_state && (bytes_to_read != 0));
+			tasklet_schedule(&channel->callback_event);
+		}
 	}
 }
 

commit 631e63a9f346cb657761ae22138f294718696501
Author: Stephen Hemminger <stephen@networkplumber.org>
Date:   Sat Feb 11 23:02:20 2017 -0700

    vmbus: change to per channel tasklet
    
    Make the event handling tasklet per channel rather than per-cpu.
    This allows for better fairness when getting lots of data on the same
    cpu.
    
    Signed-off-by: Stephen Hemminger <sthemmin@microsoft.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index 158f12823baf..27e72dc07e12 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -259,29 +259,6 @@ void vmbus_disconnect(void)
 	vmbus_connection.monitor_pages[1] = NULL;
 }
 
-/*
- * Map the given relid to the corresponding channel based on the
- * per-cpu list of channels that have been affinitized to this CPU.
- * This will be used in the channel callback path as we can do this
- * mapping in a lock-free fashion.
- */
-static struct vmbus_channel *pcpu_relid2channel(u32 relid)
-{
-	struct hv_per_cpu_context *hv_cpu
-		= this_cpu_ptr(hv_context.cpu_context);
-	struct vmbus_channel *found_channel = NULL;
-	struct vmbus_channel *channel;
-
-	list_for_each_entry(channel, &hv_cpu->chan_list, percpu_list) {
-		if (channel->offermsg.child_relid == relid) {
-			found_channel = channel;
-			break;
-		}
-	}
-
-	return found_channel;
-}
-
 /*
  * relid2channel - Get the channel object given its
  * child relative id (ie channel id)
@@ -318,24 +295,15 @@ struct vmbus_channel *relid2channel(u32 relid)
 }
 
 /*
- * process_chn_event - Process a channel event notification
+ * vmbus_on_event - Process a channel event notification
  */
-static void process_chn_event(u32 relid)
+void vmbus_on_event(unsigned long data)
 {
-	struct vmbus_channel *channel;
+	struct vmbus_channel *channel = (void *) data;
 	void *arg;
 	bool read_state;
 	u32 bytes_to_read;
 
-	/*
-	 * Find the channel based on this relid and invokes the
-	 * channel callback to process the event
-	 */
-	channel = pcpu_relid2channel(relid);
-
-	if (!channel)
-		return;
-
 	/*
 	 * A channel once created is persistent even when there
 	 * is no driver handling the device. An unloading driver
@@ -344,7 +312,6 @@ static void process_chn_event(u32 relid)
 	 * Thus, checking and invoking the driver specific callback takes
 	 * care of orderly unloading of the driver.
 	 */
-
 	if (channel->onchannel_callback != NULL) {
 		arg = channel->channel_callback_context;
 		read_state = channel->batched_reading;
@@ -372,45 +339,6 @@ static void process_chn_event(u32 relid)
 	}
 }
 
-/*
- * vmbus_on_event - Handler for events
- */
-void vmbus_on_event(unsigned long data)
-{
-	struct hv_per_cpu_context *hv_cpu = (void *)data;
-	unsigned long *recv_int_page;
-	u32 maxbits, relid;
-
-	if (vmbus_proto_version < VERSION_WIN8) {
-		maxbits = MAX_NUM_CHANNELS_SUPPORTED;
-		recv_int_page = vmbus_connection.recv_int_page;
-	} else {
-		/*
-		 * When the host is win8 and beyond, the event page
-		 * can be directly checked to get the id of the channel
-		 * that has the interrupt pending.
-		 */
-		void *page_addr = hv_cpu->synic_event_page;
-		union hv_synic_event_flags *event
-			= (union hv_synic_event_flags *)page_addr +
-						 VMBUS_MESSAGE_SINT;
-
-		maxbits = HV_EVENT_FLAGS_COUNT;
-		recv_int_page = event->flags;
-	}
-
-	if (unlikely(!recv_int_page))
-		return;
-
-	for_each_set_bit(relid, recv_int_page, maxbits) {
-		if (sync_test_and_clear_bit(relid, recv_int_page)) {
-			/* Special case - vmbus channel protocol msg */
-			if (relid != 0)
-				process_chn_event(relid);
-		}
-	}
-}
-
 /*
  * vmbus_post_msg - Send a msg on the vmbus's message connection
  */

commit 37cdd991fac810a727cd285629d1640fcf53cd19
Author: Stephen Hemminger <stephen@networkplumber.org>
Date:   Sat Feb 11 23:02:19 2017 -0700

    vmbus: put related per-cpu variable together
    
    The hv_context structure had several arrays which were per-cpu
    and was allocating small structures (tasklet_struct). Instead use
    a single per-cpu array.
    
    Signed-off-by: Stephen Hemminger <sthemmin@microsoft.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index 1766ef03e78d..158f12823baf 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -93,12 +93,10 @@ static int vmbus_negotiate_version(struct vmbus_channel_msginfo *msginfo,
 	 * all the CPUs. This is needed for kexec to work correctly where
 	 * the CPU attempting to connect may not be CPU 0.
 	 */
-	if (version >= VERSION_WIN8_1) {
-		msg->target_vcpu = hv_context.vp_index[get_cpu()];
-		put_cpu();
-	} else {
+	if (version >= VERSION_WIN8_1)
+		msg->target_vcpu = hv_context.vp_index[smp_processor_id()];
+	else
 		msg->target_vcpu = 0;
-	}
 
 	/*
 	 * Add to list before we send the request since we may
@@ -269,12 +267,12 @@ void vmbus_disconnect(void)
  */
 static struct vmbus_channel *pcpu_relid2channel(u32 relid)
 {
+	struct hv_per_cpu_context *hv_cpu
+		= this_cpu_ptr(hv_context.cpu_context);
+	struct vmbus_channel *found_channel = NULL;
 	struct vmbus_channel *channel;
-	struct vmbus_channel *found_channel  = NULL;
-	int cpu = smp_processor_id();
-	struct list_head *pcpu_head = &hv_context.percpu_list[cpu];
 
-	list_for_each_entry(channel, pcpu_head, percpu_list) {
+	list_for_each_entry(channel, &hv_cpu->chan_list, percpu_list) {
 		if (channel->offermsg.child_relid == relid) {
 			found_channel = channel;
 			break;
@@ -379,6 +377,7 @@ static void process_chn_event(u32 relid)
  */
 void vmbus_on_event(unsigned long data)
 {
+	struct hv_per_cpu_context *hv_cpu = (void *)data;
 	unsigned long *recv_int_page;
 	u32 maxbits, relid;
 
@@ -391,8 +390,7 @@ void vmbus_on_event(unsigned long data)
 		 * can be directly checked to get the id of the channel
 		 * that has the interrupt pending.
 		 */
-		int cpu = smp_processor_id();
-		void *page_addr = hv_context.synic_event_page[cpu];
+		void *page_addr = hv_cpu->synic_event_page;
 		union hv_synic_event_flags *event
 			= (union hv_synic_event_flags *)page_addr +
 						 VMBUS_MESSAGE_SINT;

commit 5c1bec61fdfcd056df909a712e2a86bbaeb0f942
Author: Stephen Hemminger <stephen@networkplumber.org>
Date:   Sun Feb 5 17:20:31 2017 -0700

    vmbus: use kernel bitops for traversing interrupt mask
    
    Use standard kernel operations for find first set bit to traverse
    the channel bit array. This has added benefit of speeding up
    lookup on 64 bit and because it uses find first set instruction.
    
    Signed-off-by: Stephen Hemminger <sthemmin@microsoft.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index 307a5a8937f6..1766ef03e78d 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -379,17 +379,11 @@ static void process_chn_event(u32 relid)
  */
 void vmbus_on_event(unsigned long data)
 {
-	u32 dword;
-	u32 maxdword;
-	int bit;
-	u32 relid;
-	u32 *recv_int_page = NULL;
-	void *page_addr;
-	int cpu = smp_processor_id();
-	union hv_synic_event_flags *event;
+	unsigned long *recv_int_page;
+	u32 maxbits, relid;
 
 	if (vmbus_proto_version < VERSION_WIN8) {
-		maxdword = MAX_NUM_CHANNELS_SUPPORTED >> 5;
+		maxbits = MAX_NUM_CHANNELS_SUPPORTED;
 		recv_int_page = vmbus_connection.recv_int_page;
 	} else {
 		/*
@@ -397,35 +391,24 @@ void vmbus_on_event(unsigned long data)
 		 * can be directly checked to get the id of the channel
 		 * that has the interrupt pending.
 		 */
-		maxdword = HV_EVENT_FLAGS_DWORD_COUNT;
-		page_addr = hv_context.synic_event_page[cpu];
-		event = (union hv_synic_event_flags *)page_addr +
+		int cpu = smp_processor_id();
+		void *page_addr = hv_context.synic_event_page[cpu];
+		union hv_synic_event_flags *event
+			= (union hv_synic_event_flags *)page_addr +
 						 VMBUS_MESSAGE_SINT;
-		recv_int_page = event->flags32;
-	}
-
 
+		maxbits = HV_EVENT_FLAGS_COUNT;
+		recv_int_page = event->flags;
+	}
 
-	/* Check events */
-	if (!recv_int_page)
+	if (unlikely(!recv_int_page))
 		return;
-	for (dword = 0; dword < maxdword; dword++) {
-		if (!recv_int_page[dword])
-			continue;
-		for (bit = 0; bit < 32; bit++) {
-			if (sync_test_and_clear_bit(bit,
-				(unsigned long *)&recv_int_page[dword])) {
-				relid = (dword << 5) + bit;
-
-				if (relid == 0)
-					/*
-					 * Special case - vmbus
-					 * channel protocol msg
-					 */
-					continue;
 
+	for_each_set_bit(relid, recv_int_page, maxbits) {
+		if (sync_test_and_clear_bit(relid, recv_int_page)) {
+			/* Special case - vmbus channel protocol msg */
+			if (relid != 0)
 				process_chn_event(relid);
-			}
 		}
 	}
 }
@@ -491,12 +474,8 @@ void vmbus_set_event(struct vmbus_channel *channel)
 {
 	u32 child_relid = channel->offermsg.child_relid;
 
-	if (!channel->is_dedicated_interrupt) {
-		/* Each u32 represents 32 channels */
-		sync_set_bit(child_relid & 31,
-			(unsigned long *)vmbus_connection.send_int_page +
-			(child_relid >> 5));
-	}
+	if (!channel->is_dedicated_interrupt)
+		vmbus_send_interrupt(child_relid);
 
 	hv_do_hypercall(HVCALL_SIGNAL_EVENT, channel->sig_event, NULL);
 }

commit 8de8af7e0873c4fdac2205327dff922819e16657
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Thu Jan 19 11:51:47 2017 -0700

    Drivers: hv: vmbus: Move the extracting of Hypervisor version information
    
    As part of the effort to separate out architecture specific code,
    extract hypervisor version information in an architecture specific
    file.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index 9b72ebcd37bc..307a5a8937f6 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -221,11 +221,8 @@ int vmbus_connect(void)
 		goto cleanup;
 
 	vmbus_proto_version = version;
-	pr_info("Hyper-V Host Build:%d-%d.%d-%d-%d.%d; Vmbus version:%d.%d\n",
-		    host_info_eax, host_info_ebx >> 16,
-		    host_info_ebx & 0xFFFF, host_info_ecx,
-		    host_info_edx >> 24, host_info_edx & 0xFFFFFF,
-		    version >> 16, version & 0xFFFF);
+	pr_info("Vmbus version:%d.%d\n",
+		version >> 16, version & 0xFFFF);
 
 	kfree(msginfo);
 	return 0;

commit c0bb03924f1a80e7f65900e36c8e6b3dc167c5f8
Author: Vitaly Kuznetsov <vkuznets@redhat.com>
Date:   Wed Dec 7 01:16:24 2016 -0800

    Drivers: hv: vmbus: Raise retry/wait limits in vmbus_post_msg()
    
    DoS protection conditions were altered in WS2016 and now it's easy to get
    -EAGAIN returned from vmbus_post_msg() (e.g. when we try changing MTU on a
    netvsc device in a loop). All vmbus_post_msg() callers don't retry the
    operation and we usually end up with a non-functional device or crash.
    
    While host's DoS protection conditions are unknown to me my tests show that
    it can take up to 10 seconds before the message is sent so doing udelay()
    is not an option, we really need to sleep. Almost all vmbus_post_msg()
    callers are ready to sleep but there is one special case:
    vmbus_initiate_unload() which can be called from interrupt/NMI context and
    we can't sleep there. I'm also not sure about the lonely
    vmbus_send_tl_connect_request() which has no in-tree users but its external
    users are most likely waiting for the host to reply so sleeping there is
    also appropriate.
    
    Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index 6ce8b874e833..9b72ebcd37bc 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -111,7 +111,8 @@ static int vmbus_negotiate_version(struct vmbus_channel_msginfo *msginfo,
 	spin_unlock_irqrestore(&vmbus_connection.channelmsg_lock, flags);
 
 	ret = vmbus_post_msg(msg,
-			       sizeof(struct vmbus_channel_initiate_contact));
+			     sizeof(struct vmbus_channel_initiate_contact),
+			     true);
 	if (ret != 0) {
 		spin_lock_irqsave(&vmbus_connection.channelmsg_lock, flags);
 		list_del(&msginfo->msglistentry);
@@ -435,7 +436,7 @@ void vmbus_on_event(unsigned long data)
 /*
  * vmbus_post_msg - Send a msg on the vmbus's message connection
  */
-int vmbus_post_msg(void *buffer, size_t buflen)
+int vmbus_post_msg(void *buffer, size_t buflen, bool can_sleep)
 {
 	union hv_connection_id conn_id;
 	int ret = 0;
@@ -450,7 +451,7 @@ int vmbus_post_msg(void *buffer, size_t buflen)
 	 * insufficient resources. Retry the operation a couple of
 	 * times before giving up.
 	 */
-	while (retries < 20) {
+	while (retries < 100) {
 		ret = hv_post_message(conn_id, 1, buffer, buflen);
 
 		switch (ret) {
@@ -473,8 +474,14 @@ int vmbus_post_msg(void *buffer, size_t buflen)
 		}
 
 		retries++;
-		udelay(usec);
-		if (usec < 2048)
+		if (can_sleep && usec > 1000)
+			msleep(usec / 1000);
+		else if (usec < MAX_UDELAY_MS * 1000)
+			udelay(usec);
+		else
+			mdelay(usec / 1000);
+
+		if (usec < 256000)
 			usec *= 2;
 	}
 	return ret;

commit 95096f2fbd10186d3e78a328b327afc71428f65f
Author: Stephen Hemminger <sthemmin@microsoft.com>
Date:   Sat Dec 3 12:34:40 2016 -0800

    uio-hv-generic: new userspace i/o driver for VMBus
    
    This is a new driver to enable userspace networking on VMBus.
    It is based largely on the similar driver that already exists
    for PCI, and earlier work done by Brocade to support DPDK.
    
    Signed-off-by: Stephen Hemminger <sthemmin@microsoft.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index 78e6368a4423..6ce8b874e833 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -39,6 +39,7 @@ struct vmbus_connection vmbus_connection = {
 	.conn_state		= DISCONNECTED,
 	.next_gpadl_handle	= ATOMIC_INIT(0xE1E10),
 };
+EXPORT_SYMBOL_GPL(vmbus_connection);
 
 /*
  * Negotiated protocol version with the host.

commit 8de0d7e951826d7592e0ba1da655b175c4aa0923
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Fri Jul 1 16:26:36 2016 -0700

    Drivers: hv: vmbus: Reduce the delay between retries in vmbus_post_msg()
    
    The current delay between retries is unnecessarily high and is negatively
    affecting the time it takes to boot the system.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index fcf8a02dc0ea..78e6368a4423 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -439,7 +439,7 @@ int vmbus_post_msg(void *buffer, size_t buflen)
 	union hv_connection_id conn_id;
 	int ret = 0;
 	int retries = 0;
-	u32 msec = 1;
+	u32 usec = 1;
 
 	conn_id.asu32 = 0;
 	conn_id.u.id = VMBUS_MESSAGE_CONNECTION_ID;
@@ -472,9 +472,9 @@ int vmbus_post_msg(void *buffer, size_t buflen)
 		}
 
 		retries++;
-		msleep(msec);
-		if (msec < 2048)
-			msec *= 2;
+		udelay(usec);
+		if (usec < 2048)
+			usec *= 2;
 	}
 	return ret;
 }

commit 5cc472477f928fb8584eb8e08245c9cf9002d74a
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Sat Apr 2 17:59:49 2016 -0700

    Drivers: hv: vmbus: Export the vmbus_set_event() API
    
    In preparation for moving some ring buffer functionality out of the
    vmbus driver, export the API for signaling the host.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index d02f1373dd98..fcf8a02dc0ea 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -495,3 +495,4 @@ void vmbus_set_event(struct vmbus_channel *channel)
 
 	hv_do_hypercall(HVCALL_SIGNAL_EVENT, channel->sig_event, NULL);
 }
+EXPORT_SYMBOL_GPL(vmbus_set_event);

commit 7268644734f6a300353a4c4ff8bf3e013ba80f89
Author: Alex Ng <alexng@microsoft.com>
Date:   Fri Feb 26 15:13:22 2016 -0800

    Drivers: hv: vmbus: Support kexec on ws2012 r2 and above
    
    WS2012 R2 and above hosts can support kexec in that thay can support
    reconnecting to the host (as would be needed in the kexec path)
    on any CPU. Enable this. Pre ws2012 r2 hosts don't have this ability
    and consequently cannot support kexec.
    
    Signed-off-by: Alex Ng <alexng@microsoft.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index 3b6dc0017269..d02f1373dd98 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -88,8 +88,16 @@ static int vmbus_negotiate_version(struct vmbus_channel_msginfo *msginfo,
 	 * This has been the behavior pre-win8. This is not
 	 * perf issue and having all channel messages delivered on CPU 0
 	 * would be ok.
+	 * For post win8 hosts, we support receiving channel messagges on
+	 * all the CPUs. This is needed for kexec to work correctly where
+	 * the CPU attempting to connect may not be CPU 0.
 	 */
-	msg->target_vcpu = 0;
+	if (version >= VERSION_WIN8_1) {
+		msg->target_vcpu = hv_context.vp_index[get_cpu()];
+		put_cpu();
+	} else {
+		msg->target_vcpu = 0;
+	}
 
 	/*
 	 * Add to list before we send the request since we may

commit 75ff3a8a9168df750b5bd0589e897a6c0517a9f1
Author: Vitaly Kuznetsov <vkuznets@redhat.com>
Date:   Fri Feb 26 15:13:16 2016 -0800

    Drivers: hv: vmbus: avoid wait_for_completion() on crash
    
    wait_for_completion() may sleep, it enables interrupts and this
    is something we really want to avoid on crashes because interrupt
    handlers can cause other crashes. Switch to the recently introduced
    vmbus_wait_for_unload() doing busy wait instead.
    
    Reported-by: Radim Krcmar <rkrcmar@redhat.com>
    Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
    Reviewed-by: Radim Kr.má<rkrcmar@redhat.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index fa86b2cb28b8..3b6dc0017269 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -236,7 +236,7 @@ void vmbus_disconnect(void)
 	/*
 	 * First send the unload request to the host.
 	 */
-	vmbus_initiate_unload();
+	vmbus_initiate_unload(false);
 
 	if (vmbus_connection.work_queue) {
 		drain_workqueue(vmbus_connection.work_queue);

commit 85d9aa705184a4504d0330017e3956fcdae8a9d6
Author: Dexuan Cui <decui@microsoft.com>
Date:   Wed Jan 27 22:29:43 2016 -0800

    Drivers: hv: vmbus: add an API vmbus_hvsock_device_unregister()
    
    The hvsock driver needs this API to release all the resources related
    to the channel.
    
    Signed-off-by: Dexuan Cui <decui@microsoft.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index 4a320e60641a..fa86b2cb28b8 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -288,7 +288,8 @@ struct vmbus_channel *relid2channel(u32 relid)
 	struct list_head *cur, *tmp;
 	struct vmbus_channel *cur_sc;
 
-	mutex_lock(&vmbus_connection.channel_mutex);
+	BUG_ON(!mutex_is_locked(&vmbus_connection.channel_mutex));
+
 	list_for_each_entry(channel, &vmbus_connection.chn_list, listentry) {
 		if (channel->offermsg.child_relid == relid) {
 			found_channel = channel;
@@ -307,7 +308,6 @@ struct vmbus_channel *relid2channel(u32 relid)
 			}
 		}
 	}
-	mutex_unlock(&vmbus_connection.channel_mutex);
 
 	return found_channel;
 }

commit 1b807e1011af46a595ba46c75ad5e20ad7177af7
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Mon Dec 21 15:12:20 2015 -0800

    Drivers: hv: vmbus: Cleanup vmbus_set_event()
    
    Cleanup vmbus_set_event() by inlining the hypercall to post
    the event and since the return value of vmbus_set_event() is not checked,
    make it void. As part of this cleanup, get rid of the function
    hv_signal_event() as it is only callled from vmbus_set_event().
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index 3dc5a9c7fad6..4a320e60641a 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -474,7 +474,7 @@ int vmbus_post_msg(void *buffer, size_t buflen)
 /*
  * vmbus_set_event - Send an event notification to the parent
  */
-int vmbus_set_event(struct vmbus_channel *channel)
+void vmbus_set_event(struct vmbus_channel *channel)
 {
 	u32 child_relid = channel->offermsg.child_relid;
 
@@ -485,5 +485,5 @@ int vmbus_set_event(struct vmbus_channel *channel)
 			(child_relid >> 5));
 	}
 
-	return hv_signal_event(channel->sig_event);
+	hv_do_hypercall(HVCALL_SIGNAL_EVENT, channel->sig_event, NULL);
 }

commit b282e4c06fe89fc750fb26791c0bd7b25315973a
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Mon Dec 14 16:01:56 2015 -0800

    Drivers: hv: vmbus: Force all channel messages to be delivered on CPU 0
    
    Force all channel messages to be delivered on CPU0. These messages are not
    performance critical and are used during the setup and teardown of the
    channel.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index 521f48ed188e..3dc5a9c7fad6 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -83,10 +83,13 @@ static int vmbus_negotiate_version(struct vmbus_channel_msginfo *msginfo,
 	msg->interrupt_page = virt_to_phys(vmbus_connection.int_page);
 	msg->monitor_page1 = virt_to_phys(vmbus_connection.monitor_pages[0]);
 	msg->monitor_page2 = virt_to_phys(vmbus_connection.monitor_pages[1]);
-	if (version >= VERSION_WIN8_1) {
-		msg->target_vcpu = hv_context.vp_index[get_cpu()];
-		put_cpu();
-	}
+	/*
+	 * We want all channel messages to be delivered on CPU 0.
+	 * This has been the behavior pre-win8. This is not
+	 * perf issue and having all channel messages delivered on CPU 0
+	 * would be ok.
+	 */
+	msg->target_vcpu = 0;
 
 	/*
 	 * Add to list before we send the request since we may

commit d6f591e339d23f434efda11917da511870891472
Author: Dexuan Cui <decui@microsoft.com>
Date:   Mon Dec 14 16:01:51 2015 -0800

    Drivers: hv: vmbus: channge vmbus_connection.channel_lock to mutex
    
    spinlock is unnecessary here.
    mutex is enough.
    
    Signed-off-by: Dexuan Cui <decui@microsoft.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index 4fc2e8836e60..521f48ed188e 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -146,7 +146,7 @@ int vmbus_connect(void)
 	spin_lock_init(&vmbus_connection.channelmsg_lock);
 
 	INIT_LIST_HEAD(&vmbus_connection.chn_list);
-	spin_lock_init(&vmbus_connection.channel_lock);
+	mutex_init(&vmbus_connection.channel_mutex);
 
 	/*
 	 * Setup the vmbus event connection for channel interrupt
@@ -282,11 +282,10 @@ struct vmbus_channel *relid2channel(u32 relid)
 {
 	struct vmbus_channel *channel;
 	struct vmbus_channel *found_channel  = NULL;
-	unsigned long flags;
 	struct list_head *cur, *tmp;
 	struct vmbus_channel *cur_sc;
 
-	spin_lock_irqsave(&vmbus_connection.channel_lock, flags);
+	mutex_lock(&vmbus_connection.channel_mutex);
 	list_for_each_entry(channel, &vmbus_connection.chn_list, listentry) {
 		if (channel->offermsg.child_relid == relid) {
 			found_channel = channel;
@@ -305,7 +304,7 @@ struct vmbus_channel *relid2channel(u32 relid)
 			}
 		}
 	}
-	spin_unlock_irqrestore(&vmbus_connection.channel_lock, flags);
+	mutex_unlock(&vmbus_connection.channel_mutex);
 
 	return found_channel;
 }

commit 6c4e5f9c9ff41ea997fd0f345b3b2b88c113eb68
Author: Keith Mange <keith.mange@microsoft.com>
Date:   Tue May 26 14:23:01 2015 -0700

    Drivers: hv: vmbus:Update preferred vmbus protocol version to windows 10.
    
    Add support for Windows 10.
    
    Signed-off-by: Keith Mange <keith.mange@microsoft.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index acd50e9d666a..4fc2e8836e60 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -58,6 +58,9 @@ static __u32 vmbus_get_next_version(__u32 current_version)
 	case (VERSION_WIN8_1):
 		return VERSION_WIN8;
 
+	case (VERSION_WIN10):
+		return VERSION_WIN8_1;
+
 	case (VERSION_WS2008):
 	default:
 		return VERSION_INVAL;
@@ -80,7 +83,7 @@ static int vmbus_negotiate_version(struct vmbus_channel_msginfo *msginfo,
 	msg->interrupt_page = virt_to_phys(vmbus_connection.int_page);
 	msg->monitor_page1 = virt_to_phys(vmbus_connection.monitor_pages[0]);
 	msg->monitor_page2 = virt_to_phys(vmbus_connection.monitor_pages[1]);
-	if (version == VERSION_WIN8_1) {
+	if (version >= VERSION_WIN8_1) {
 		msg->target_vcpu = hv_context.vp_index[get_cpu()];
 		put_cpu();
 	}
@@ -376,8 +379,7 @@ void vmbus_on_event(unsigned long data)
 	int cpu = smp_processor_id();
 	union hv_synic_event_flags *event;
 
-	if ((vmbus_proto_version == VERSION_WS2008) ||
-		(vmbus_proto_version == VERSION_WIN7)) {
+	if (vmbus_proto_version < VERSION_WIN8) {
 		maxdword = MAX_NUM_CHANNELS_SUPPORTED >> 5;
 		recv_int_page = vmbus_connection.recv_int_page;
 	} else {

commit 2db84eff127e3f4b3635edc589cd6a56db8755a3
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Wed Apr 22 21:31:32 2015 -0700

    Drivers: hv: vmbus: Implement the protocol for tearing down vmbus state
    
    Implement the protocol for tearing down the monitor state established with
    the host.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Tested-by: Vitaly Kuznetsov <vkuznets@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index b27220a425f4..acd50e9d666a 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -227,6 +227,11 @@ int vmbus_connect(void)
 
 void vmbus_disconnect(void)
 {
+	/*
+	 * First send the unload request to the host.
+	 */
+	vmbus_initiate_unload();
+
 	if (vmbus_connection.work_queue) {
 		drain_workqueue(vmbus_connection.work_queue);
 		destroy_workqueue(vmbus_connection.work_queue);

commit e1c0d82dab4a4605d3bd1968436f030dfed4a829
Author: Haiyang Zhang <haiyangz@microsoft.com>
Date:   Fri Mar 27 09:10:14 2015 -0700

    hv_vmbus: Add gradually increased delay for retries in vmbus_post_msg()
    
    Most of the retries can be done within a millisecond successfully, so we
    sleep 1ms before the first retry, then gradually increase the retry
    interval to 2^n with max value of 2048ms. Doing so, we will have shorter
    overall delay time, because most of the cases succeed within 1-2 attempts.
    
    Signed-off-by: Haiyang Zhang <haiyangz@microsoft.com>
    Reviewed-by: K. Y. Srinivasan <kys@microsoft.com>
    Reviewed-by: Dexuan Cui <decui@microsoft.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index 583d7d42b46d..b27220a425f4 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -422,6 +422,7 @@ int vmbus_post_msg(void *buffer, size_t buflen)
 	union hv_connection_id conn_id;
 	int ret = 0;
 	int retries = 0;
+	u32 msec = 1;
 
 	conn_id.asu32 = 0;
 	conn_id.u.id = VMBUS_MESSAGE_CONNECTION_ID;
@@ -431,7 +432,7 @@ int vmbus_post_msg(void *buffer, size_t buflen)
 	 * insufficient resources. Retry the operation a couple of
 	 * times before giving up.
 	 */
-	while (retries < 10) {
+	while (retries < 20) {
 		ret = hv_post_message(conn_id, 1, buffer, buflen);
 
 		switch (ret) {
@@ -454,7 +455,9 @@ int vmbus_post_msg(void *buffer, size_t buflen)
 		}
 
 		retries++;
-		msleep(1000);
+		msleep(msec);
+		if (msec < 2048)
+			msec *= 2;
 	}
 	return ret;
 }

commit d43e2fe7da320310834467a3fd87a10adb25a221
Author: Dexuan Cui <decui@microsoft.com>
Date:   Fri Mar 27 09:10:09 2015 -0700

    hv: don't schedule new works in vmbus_onoffer()/vmbus_onoffer_rescind()
    
    Since the 2 fucntions can safely run in vmbus_connection.work_queue without
    hang, we don't need to schedule new work items into the per-channel workqueue.
    
    Actally we can even remove the per-channel workqueue now -- we'll do it
    in the next patch.
    
    Signed-off-by: Dexuan Cui <decui@microsoft.com>
    Cc: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index 8bcd3071c84f..583d7d42b46d 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -270,7 +270,7 @@ static struct vmbus_channel *pcpu_relid2channel(u32 relid)
  * relid2channel - Get the channel object given its
  * child relative id (ie channel id)
  */
-struct vmbus_channel *relid2channel(u32 relid, bool rescind)
+struct vmbus_channel *relid2channel(u32 relid)
 {
 	struct vmbus_channel *channel;
 	struct vmbus_channel *found_channel  = NULL;
@@ -282,8 +282,6 @@ struct vmbus_channel *relid2channel(u32 relid, bool rescind)
 	list_for_each_entry(channel, &vmbus_connection.chn_list, listentry) {
 		if (channel->offermsg.child_relid == relid) {
 			found_channel = channel;
-			if (rescind)
-				found_channel->rescind = true;
 			break;
 		} else if (!list_empty(&channel->sc_list)) {
 			/*
@@ -294,8 +292,6 @@ struct vmbus_channel *relid2channel(u32 relid, bool rescind)
 							sc_list);
 				if (cur_sc->offermsg.child_relid == relid) {
 					found_channel = cur_sc;
-					if (rescind)
-						found_channel->rescind = true;
 					break;
 				}
 			}

commit fde25d25dbd997067058f7d4c2ff31600157e6f2
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Wed Mar 18 12:29:21 2015 -0700

    Drivers: hv: vmbus: Perform device register in the per-channel work element
    
    This patch is a continuation of the rescind handling cleanup work. We cannot
    block in the global message handling work context especially if we are blocking
    waiting for the host to wake us up. I would like to thank
    Dexuan Cui <decui@microsoft.com> for observing this problem.
    
    The current char-next branch is broken and this patch fixes
    the bug.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index 583d7d42b46d..8bcd3071c84f 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -270,7 +270,7 @@ static struct vmbus_channel *pcpu_relid2channel(u32 relid)
  * relid2channel - Get the channel object given its
  * child relative id (ie channel id)
  */
-struct vmbus_channel *relid2channel(u32 relid)
+struct vmbus_channel *relid2channel(u32 relid, bool rescind)
 {
 	struct vmbus_channel *channel;
 	struct vmbus_channel *found_channel  = NULL;
@@ -282,6 +282,8 @@ struct vmbus_channel *relid2channel(u32 relid)
 	list_for_each_entry(channel, &vmbus_connection.chn_list, listentry) {
 		if (channel->offermsg.child_relid == relid) {
 			found_channel = channel;
+			if (rescind)
+				found_channel->rescind = true;
 			break;
 		} else if (!list_empty(&channel->sc_list)) {
 			/*
@@ -292,6 +294,8 @@ struct vmbus_channel *relid2channel(u32 relid)
 							sc_list);
 				if (cur_sc->offermsg.child_relid == relid) {
 					found_channel = cur_sc;
+					if (rescind)
+						found_channel->rescind = true;
 					break;
 				}
 			}

commit 37f492ce8148d84261cdb9fe1e925199f47531ae
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Sat Feb 28 11:18:21 2015 -0800

    Drivers: hv: vmbus: Get rid of some unnecessary messages
    
    Currently we log messages when either we are not able to map an ID to a
    channel or when the channel does not have a callback associated
    (in the channel interrupt handling path). These messages don't add
    any value, get rid of them.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index af2388fdc6b9..583d7d42b46d 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -318,10 +318,8 @@ static void process_chn_event(u32 relid)
 	 */
 	channel = pcpu_relid2channel(relid);
 
-	if (!channel) {
-		pr_err("channel not found for relid - %u\n", relid);
+	if (!channel)
 		return;
-	}
 
 	/*
 	 * A channel once created is persistent even when there
@@ -356,10 +354,7 @@ static void process_chn_event(u32 relid)
 			else
 				bytes_to_read = 0;
 		} while (read_state && (bytes_to_read != 0));
-	} else {
-		pr_err("no channel callback for relid - %u\n", relid);
 	}
-
 }
 
 /*

commit 89f9f6796d41e10e224b0cb0027ddd78cb881f65
Author: Dexuan Cui <decui@microsoft.com>
Date:   Fri Feb 27 11:25:59 2015 -0800

    hv: vmbus_post_msg: retry the hypercall on some transient errors
    
    I got HV_STATUS_INVALID_CONNECTION_ID on Hyper-V 2008 R2 when keeping running
    "rmmod hv_netvsc; modprobe hv_netvsc; rmmod hv_utils; modprobe hv_utils"
    in a Linux guest. Looks the host has some kind of throttling mechanism if
    some kinds of hypercalls are sent too frequently.
    Without the patch, the driver can occasionally fail to load.
    
    Also let's retry HV_STATUS_INSUFFICIENT_MEMORY, though we didn't get it
    before.
    
    Removed 'case -ENOMEM', since the hypervisor doesn't return this.
    
    CC: "K. Y. Srinivasan" <kys@microsoft.com>
    Reviewed-by: Jason Wang <jasowang@redhat.com>
    Signed-off-by: Dexuan Cui <decui@microsoft.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index c4acd1ce7c0c..af2388fdc6b9 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -440,9 +440,16 @@ int vmbus_post_msg(void *buffer, size_t buflen)
 		ret = hv_post_message(conn_id, 1, buffer, buflen);
 
 		switch (ret) {
+		case HV_STATUS_INVALID_CONNECTION_ID:
+			/*
+			 * We could get this if we send messages too
+			 * frequently.
+			 */
+			ret = -EAGAIN;
+			break;
+		case HV_STATUS_INSUFFICIENT_MEMORY:
 		case HV_STATUS_INSUFFICIENT_BUFFERS:
 			ret = -ENOMEM;
-		case -ENOMEM:
 			break;
 		case HV_STATUS_SUCCESS:
 			return ret;
@@ -452,7 +459,7 @@ int vmbus_post_msg(void *buffer, size_t buflen)
 		}
 
 		retries++;
-		msleep(100);
+		msleep(1000);
 	}
 	return ret;
 }

commit 09a196288ec4617a920e051af6651ce03968c8b9
Author: Vitaly Kuznetsov <vkuznets@redhat.com>
Date:   Fri Feb 27 11:25:54 2015 -0800

    Drivers: hv: vmbus: teardown hv_vmbus_con workqueue and vmbus_connection pages on shutdown
    
    We need to destroy hv_vmbus_con on module shutdown, otherwise the following
    crash is sometimes observed:
    
    [   76.569845] hv_vmbus: Hyper-V Host Build:9600-6.3-17-0.17039; Vmbus version:3.0
    [   82.598859] BUG: unable to handle kernel paging request at ffffffffa0003480
    [   82.599287] IP: [<ffffffffa0003480>] 0xffffffffa0003480
    [   82.599287] PGD 1f34067 PUD 1f35063 PMD 3f72d067 PTE 0
    [   82.599287] Oops: 0010 [#1] SMP
    [   82.599287] Modules linked in: [last unloaded: hv_vmbus]
    [   82.599287] CPU: 0 PID: 26 Comm: kworker/0:1 Not tainted 3.19.0-rc5_bug923184+ #488
    [   82.599287] Hardware name: Microsoft Corporation Virtual Machine/Virtual Machine, BIOS Hyper-V UEFI Release v1.0 11/26/2012
    [   82.599287] Workqueue: hv_vmbus_con 0xffffffffa0003480
    [   82.599287] task: ffff88007b6ddfa0 ti: ffff88007f8f8000 task.ti: ffff88007f8f8000
    [   82.599287] RIP: 0010:[<ffffffffa0003480>]  [<ffffffffa0003480>] 0xffffffffa0003480
    [   82.599287] RSP: 0018:ffff88007f8fbe00  EFLAGS: 00010202
    ...
    
    To avoid memory leaks we need to free monitor_pages and int_page for
    vmbus_connection. Implement vmbus_disconnect() function by separating cleanup
    path from vmbus_connect().
    
    As we use hv_vmbus_con to release channels (see free_channel() in channel_mgmt.c)
    we need to make sure the work was done before we remove the queue, do that with
    drain_workqueue(). We also need to avoid handling messages  which can (potentially)
    create new channels, so set vmbus_connection.conn_state = DISCONNECTED at the very
    beginning of vmbus_exit() and check for that in vmbus_onmessage_work().
    
    Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index a63a795300b9..c4acd1ce7c0c 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -216,10 +216,21 @@ int vmbus_connect(void)
 
 cleanup:
 	pr_err("Unable to connect to host\n");
+
 	vmbus_connection.conn_state = DISCONNECTED;
+	vmbus_disconnect();
+
+	kfree(msginfo);
+
+	return ret;
+}
 
-	if (vmbus_connection.work_queue)
+void vmbus_disconnect(void)
+{
+	if (vmbus_connection.work_queue) {
+		drain_workqueue(vmbus_connection.work_queue);
 		destroy_workqueue(vmbus_connection.work_queue);
+	}
 
 	if (vmbus_connection.int_page) {
 		free_pages((unsigned long)vmbus_connection.int_page, 0);
@@ -230,10 +241,6 @@ int vmbus_connect(void)
 	free_pages((unsigned long)vmbus_connection.monitor_pages[1], 0);
 	vmbus_connection.monitor_pages[0] = NULL;
 	vmbus_connection.monitor_pages[1] = NULL;
-
-	kfree(msginfo);
-
-	return ret;
 }
 
 /*

commit 87712bf81dd092821c406ea3fb47a07222484a64
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Sun Dec 14 23:34:51 2014 -0800

    Drivers: hv: vmbus: Use get_cpu() to get the current CPU
    
    Replace calls for smp_processor_id() to get_cpu() to get the CPU ID of
    the current CPU. In these instances, there is no correctness issue with
    regards to preemption, we just need the current CPU ID.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index e206619b946e..a63a795300b9 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -80,8 +80,10 @@ static int vmbus_negotiate_version(struct vmbus_channel_msginfo *msginfo,
 	msg->interrupt_page = virt_to_phys(vmbus_connection.int_page);
 	msg->monitor_page1 = virt_to_phys(vmbus_connection.monitor_pages[0]);
 	msg->monitor_page2 = virt_to_phys(vmbus_connection.monitor_pages[1]);
-	if (version == VERSION_WIN8_1)
-		msg->target_vcpu = hv_context.vp_index[smp_processor_id()];
+	if (version == VERSION_WIN8_1) {
+		msg->target_vcpu = hv_context.vp_index[get_cpu()];
+		put_cpu();
+	}
 
 	/*
 	 * Add to list before we send the request since we may

commit fdeebcc62279119dbeafbc1a2e39e773839025fd
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Wed Aug 27 16:25:31 2014 -0700

    Drivers: hv: vmbus: Cleanup vmbus_post_msg()
    
    Posting messages to the host can fail because of transient resource
    related failures. Correctly deal with these failures and increase the
    number of attempts to post the message before giving up.
    
    In this version of the patch, I have normalized the error code to
    Linux error code.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Cc: <stable@vger.kernel.org>
    Tested-by: Sitsofe Wheeler <sitsofe@yahoo.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index ae22e3c1fc4c..e206619b946e 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -427,10 +427,21 @@ int vmbus_post_msg(void *buffer, size_t buflen)
 	 * insufficient resources. Retry the operation a couple of
 	 * times before giving up.
 	 */
-	while (retries < 3) {
-		ret =  hv_post_message(conn_id, 1, buffer, buflen);
-		if (ret != HV_STATUS_INSUFFICIENT_BUFFERS)
+	while (retries < 10) {
+		ret = hv_post_message(conn_id, 1, buffer, buflen);
+
+		switch (ret) {
+		case HV_STATUS_INSUFFICIENT_BUFFERS:
+			ret = -ENOMEM;
+		case -ENOMEM:
+			break;
+		case HV_STATUS_SUCCESS:
 			return ret;
+		default:
+			pr_err("hv_post_msg() failed; error code:%d\n", ret);
+			return -EINVAL;
+		}
+
 		retries++;
 		msleep(100);
 	}

commit affb1aff300ddee54df307812b38f166e8a865ef
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Mon Jul 7 16:34:24 2014 -0700

    Drivers: hv: vmbus: Fix a bug in the channel callback dispatch code
    
    Starting with Win8, we have implemented several optimizations to improve the
    scalability and performance of the VMBUS transport between the Host and the
    Guest. Some of the non-performance critical services cannot leverage these
    optimization since they only read and process one message at a time.
    Make adjustments to the callback dispatch code to account for the way
    non-performance critical drivers handle reading of the channel.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index e84f4526eb36..ae22e3c1fc4c 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -339,9 +339,13 @@ static void process_chn_event(u32 relid)
 		 */
 
 		do {
-			hv_begin_read(&channel->inbound);
+			if (read_state)
+				hv_begin_read(&channel->inbound);
 			channel->onchannel_callback(arg);
-			bytes_to_read = hv_end_read(&channel->inbound);
+			if (read_state)
+				bytes_to_read = hv_end_read(&channel->inbound);
+			else
+				bytes_to_read = 0;
 		} while (read_state && (bytes_to_read != 0));
 	} else {
 		pr_err("no channel callback for relid - %u\n", relid);

commit a100d88df1e924e5c9678fabf054d1bae7ab74fb
Author: Radim Krčmář <rkrcmar@redhat.com>
Date:   Tue May 27 19:16:20 2014 +0200

    hv: use correct order when freeing monitor_pages
    
    We try to free two pages when only one has been allocated.
    Cleanup path is unlikely, so I haven't found any trace that would fit,
    but I hope that free_pages_prepare() does catch it.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Radim Krčmář <rkrcmar@redhat.com>
    Reviewed-by: Amos Kong <akong@redhat.com>
    Acked-by: Jason Wang <jasowang@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index 7f10c151632a..e84f4526eb36 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -224,8 +224,8 @@ int vmbus_connect(void)
 		vmbus_connection.int_page = NULL;
 	}
 
-	free_pages((unsigned long)vmbus_connection.monitor_pages[0], 1);
-	free_pages((unsigned long)vmbus_connection.monitor_pages[1], 1);
+	free_pages((unsigned long)vmbus_connection.monitor_pages[0], 0);
+	free_pages((unsigned long)vmbus_connection.monitor_pages[1], 0);
 	vmbus_connection.monitor_pages[0] = NULL;
 	vmbus_connection.monitor_pages[1] = NULL;
 

commit 3a28fa35d6658703cd26f9c16aaea0eae06afd40
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Tue Apr 8 18:45:54 2014 -0700

    Drivers: hv: vmbus: Implement per-CPU mapping of relid to channel
    
    Currently the mapping of the relID to channel is done under the protection of a
    single spin lock. Starting with ws2012, each channel is bound to a specific VCPU
    in the guest. Use this binding to eliminate the spin lock by setting up
    per-cpu state for mapping relId to the channel.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Reviewed-by: Haiyang Zhang <haiyangz@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index df2363ea017f..7f10c151632a 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -234,6 +234,28 @@ int vmbus_connect(void)
 	return ret;
 }
 
+/*
+ * Map the given relid to the corresponding channel based on the
+ * per-cpu list of channels that have been affinitized to this CPU.
+ * This will be used in the channel callback path as we can do this
+ * mapping in a lock-free fashion.
+ */
+static struct vmbus_channel *pcpu_relid2channel(u32 relid)
+{
+	struct vmbus_channel *channel;
+	struct vmbus_channel *found_channel  = NULL;
+	int cpu = smp_processor_id();
+	struct list_head *pcpu_head = &hv_context.percpu_list[cpu];
+
+	list_for_each_entry(channel, pcpu_head, percpu_list) {
+		if (channel->offermsg.child_relid == relid) {
+			found_channel = channel;
+			break;
+		}
+	}
+
+	return found_channel;
+}
 
 /*
  * relid2channel - Get the channel object given its
@@ -285,7 +307,7 @@ static void process_chn_event(u32 relid)
 	 * Find the channel based on this relid and invokes the
 	 * channel callback to process the event
 	 */
-	channel = relid2channel(relid);
+	channel = pcpu_relid2channel(relid);
 
 	if (!channel) {
 		pr_err("channel not found for relid - %u\n", relid);

commit d3ba720dd58cdf6630fee4b89482c465d5ad0d0f
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Tue Apr 8 18:45:53 2014 -0700

    Drivers: hv: Eliminate the channel spinlock in the callback path
    
    By ensuring that we set the callback handler to NULL in the channel close
    path on the same CPU that the channel is bound to, we can eliminate this lock
    acquisition and release in a performance critical path.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Reviewed-by: Haiyang Zhang <haiyangz@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index 2e7801af466e..df2363ea017f 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -277,7 +277,6 @@ struct vmbus_channel *relid2channel(u32 relid)
 static void process_chn_event(u32 relid)
 {
 	struct vmbus_channel *channel;
-	unsigned long flags;
 	void *arg;
 	bool read_state;
 	u32 bytes_to_read;
@@ -296,13 +295,12 @@ static void process_chn_event(u32 relid)
 	/*
 	 * A channel once created is persistent even when there
 	 * is no driver handling the device. An unloading driver
-	 * sets the onchannel_callback to NULL under the
-	 * protection of the channel inbound_lock. Thus, checking
-	 * and invoking the driver specific callback takes care of
-	 * orderly unloading of the driver.
+	 * sets the onchannel_callback to NULL on the same CPU
+	 * as where this interrupt is handled (in an interrupt context).
+	 * Thus, checking and invoking the driver specific callback takes
+	 * care of orderly unloading of the driver.
 	 */
 
-	spin_lock_irqsave(&channel->inbound_lock, flags);
 	if (channel->onchannel_callback != NULL) {
 		arg = channel->channel_callback_context;
 		read_state = channel->batched_reading;
@@ -327,7 +325,6 @@ static void process_chn_event(u32 relid)
 		pr_err("no channel callback for relid - %u\n", relid);
 	}
 
-	spin_unlock_irqrestore(&channel->inbound_lock, flags);
 }
 
 /*

commit 03367ef5ea811475187a0732aada068919e14d61
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Thu Apr 3 18:02:45 2014 -0700

    Drivers: hv: vmbus: Negotiate version 3.0 when running on ws2012r2 hosts
    
    Only ws2012r2 hosts support the ability to reconnect to the host on VMBUS. This functionality
    is needed by kexec in Linux. To use this functionality we need to negotiate version 3.0 of the
    VMBUS protocol.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Cc: <stable@vger.kernel.org>        [3.9+]
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index f2d7bf90c9fe..2e7801af466e 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -55,6 +55,9 @@ static __u32 vmbus_get_next_version(__u32 current_version)
 	case (VERSION_WIN8):
 		return VERSION_WIN7;
 
+	case (VERSION_WIN8_1):
+		return VERSION_WIN8;
+
 	case (VERSION_WS2008):
 	default:
 		return VERSION_INVAL;
@@ -77,7 +80,7 @@ static int vmbus_negotiate_version(struct vmbus_channel_msginfo *msginfo,
 	msg->interrupt_page = virt_to_phys(vmbus_connection.int_page);
 	msg->monitor_page1 = virt_to_phys(vmbus_connection.monitor_pages[0]);
 	msg->monitor_page2 = virt_to_phys(vmbus_connection.monitor_pages[1]);
-	if (version == VERSION_WIN8)
+	if (version == VERSION_WIN8_1)
 		msg->target_vcpu = hv_context.vp_index[smp_processor_id()];
 
 	/*

commit 269f979467cf49f2ea8132316c1f00f8c9678f7c
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Thu Jan 16 11:59:58 2014 -0800

    Drivers: hv: vmbus: Don't timeout during the initial connection with host
    
    When the guest attempts to connect with the host when there may already be a
    connection with the host (as would be the case during the kdump/kexec path),
    it is difficult to guarantee timely response from the host. Starting with
    WS2012 R2, the host supports this ability to re-connect with the host
    (explicitly to support kexec). Prior to responding to the guest, the host
    needs to ensure that device states based on the previous connection to
    the host have been properly torn down. This may introduce unbounded delays.
    To deal with this issue, don't do a timed wait during the initial connect
    with the host.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index 855bbda9964d..f2d7bf90c9fe 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -67,7 +67,6 @@ static int vmbus_negotiate_version(struct vmbus_channel_msginfo *msginfo,
 	int ret = 0;
 	struct vmbus_channel_initiate_contact *msg;
 	unsigned long flags;
-	int t;
 
 	init_completion(&msginfo->waitevent);
 
@@ -102,15 +101,7 @@ static int vmbus_negotiate_version(struct vmbus_channel_msginfo *msginfo,
 	}
 
 	/* Wait for the connection response */
-	t =  wait_for_completion_timeout(&msginfo->waitevent, 5*HZ);
-	if (t == 0) {
-		spin_lock_irqsave(&vmbus_connection.channelmsg_lock,
-				flags);
-		list_del(&msginfo->msglistentry);
-		spin_unlock_irqrestore(&vmbus_connection.channelmsg_lock,
-					flags);
-		return -ETIMEDOUT;
-	}
+	wait_for_completion(&msginfo->waitevent);
 
 	spin_lock_irqsave(&vmbus_connection.channelmsg_lock, flags);
 	list_del(&msginfo->msglistentry);

commit e28bab4828354583bb66ac09021ca69b341a7db4
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Wed Jan 15 17:12:58 2014 -0800

    Drivers: hv: vmbus: Specify the target CPU that should receive notification
    
    During the initial VMBUS connect phase, starting with WS2012 R2, we should
    specify the VPCU in the guest that should receive the notification. Fix this
    issue. This fix is required to properly connect to the host in the kexeced
    kernel.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Cc: <stable@vger.kernel.org>        [3.9+]
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index af6edf9b1936..855bbda9964d 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -78,6 +78,8 @@ static int vmbus_negotiate_version(struct vmbus_channel_msginfo *msginfo,
 	msg->interrupt_page = virt_to_phys(vmbus_connection.int_page);
 	msg->monitor_page1 = virt_to_phys(vmbus_connection.monitor_pages[0]);
 	msg->monitor_page2 = virt_to_phys(vmbus_connection.monitor_pages[1]);
+	if (version == VERSION_WIN8)
+		msg->target_vcpu = hv_context.vp_index[smp_processor_id()];
 
 	/*
 	 * Add to list before we send the request since we may

commit d7173493683853047d6efc8d4454c70469a7b033
Merge: 80d26236c7c5 15c03dd4859a
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Sun Sep 29 18:27:03 2013 -0700

    Merge 3.12-rc3 into char-misc-next
    
    We need/want the mei fixes in here so we can apply other updates that
    are depending on them.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 8bbf9f440f196ee08cc5ab1c19e62b1c5a736ff0
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Wed Sep 4 15:41:58 2013 -0700

    Drivers: hv: vmbus: Terminate vmbus version negotiation on timeout
    
    commit 666b9adc801ef012612c4e43e0f44b2cdc1979cf terminated vmbus
    version negotiation incorrectly. We need to terminate the version
    negotiation only if the current negotiation were to timeout.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Cc: Olaf Hering <ohering@suse.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index 8f4743ab5fb2..936093e0271e 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -195,7 +195,7 @@ int vmbus_connect(void)
 
 	do {
 		ret = vmbus_negotiate_version(msginfo, version);
-		if (ret)
+		if (ret == -ETIMEDOUT)
 			goto cleanup;
 
 		if (vmbus_connection.conn_state == CONNECTED)

commit 8681db445ed407167cd0d78c48727773b132367b
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Sep 13 11:32:55 2013 -0700

    hv: make "monitor_pages" a "real" pointer array
    
    monitor_pages was a void pointer, containing an unknown number of arrays that
    we just "knew" were a child and parent array of a specific size.  Instead of
    that implicit knowledge, let's make them a real pointer, allowing us to have
    type safety, and a semblance of sane addressing schemes.
    
    Tested-by: "K. Y. Srinivasan" <kys@microsoft.com>
    Cc: Haiyang Zhang <haiyangz@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index 8f4743ab5fb2..4faea979975e 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -76,10 +76,8 @@ static int vmbus_negotiate_version(struct vmbus_channel_msginfo *msginfo,
 	msg->header.msgtype = CHANNELMSG_INITIATE_CONTACT;
 	msg->vmbus_version_requested = version;
 	msg->interrupt_page = virt_to_phys(vmbus_connection.int_page);
-	msg->monitor_page1 = virt_to_phys(vmbus_connection.monitor_pages);
-	msg->monitor_page2 = virt_to_phys(
-			(void *)((unsigned long)vmbus_connection.monitor_pages +
-				 PAGE_SIZE));
+	msg->monitor_page1 = virt_to_phys(vmbus_connection.monitor_pages[0]);
+	msg->monitor_page2 = virt_to_phys(vmbus_connection.monitor_pages[1]);
 
 	/*
 	 * Add to list before we send the request since we may
@@ -169,9 +167,10 @@ int vmbus_connect(void)
 	 * Setup the monitor notification facility. The 1st page for
 	 * parent->child and the 2nd page for child->parent
 	 */
-	vmbus_connection.monitor_pages =
-	(void *)__get_free_pages((GFP_KERNEL|__GFP_ZERO), 1);
-	if (vmbus_connection.monitor_pages == NULL) {
+	vmbus_connection.monitor_pages[0] = (void *)__get_free_pages((GFP_KERNEL|__GFP_ZERO), 0);
+	vmbus_connection.monitor_pages[1] = (void *)__get_free_pages((GFP_KERNEL|__GFP_ZERO), 0);
+	if ((vmbus_connection.monitor_pages[0] == NULL) ||
+	    (vmbus_connection.monitor_pages[1] == NULL)) {
 		ret = -ENOMEM;
 		goto cleanup;
 	}
@@ -229,10 +228,10 @@ int vmbus_connect(void)
 		vmbus_connection.int_page = NULL;
 	}
 
-	if (vmbus_connection.monitor_pages) {
-		free_pages((unsigned long)vmbus_connection.monitor_pages, 1);
-		vmbus_connection.monitor_pages = NULL;
-	}
+	free_pages((unsigned long)vmbus_connection.monitor_pages[0], 1);
+	free_pages((unsigned long)vmbus_connection.monitor_pages[1], 1);
+	vmbus_connection.monitor_pages[0] = NULL;
+	vmbus_connection.monitor_pages[1] = NULL;
 
 	kfree(msginfo);
 

commit 666b9adc801ef012612c4e43e0f44b2cdc1979cf
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Wed Aug 28 14:56:54 2013 -0700

    Drivers: hv: vmbus: Do not attempt to negoatiate a new version prematurely
    
    The current code would attempt to negotiate a different protocol version if
    the current negotiation timed out. This triggers an assert in the host (on debug
    builds). Avoid this by negotiating a newer version only if the host properly
    rejects the current version being negotiated.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index ec3b8cdf1e04..8f4743ab5fb2 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -195,7 +195,10 @@ int vmbus_connect(void)
 
 	do {
 		ret = vmbus_negotiate_version(msginfo, version);
-		if (ret == 0)
+		if (ret)
+			goto cleanup;
+
+		if (vmbus_connection.conn_state == CONNECTED)
 			break;
 
 		version = vmbus_get_next_version(version);

commit e68d2971d26577b932a16333ce165af98a96e068
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Thu May 23 12:02:32 2013 -0700

    Drivers: hv: vmbus: Implement multi-channel support
    
    Starting with Win8, the host supports multiple sub-channels for a given
    device. As in the past, the initial channel offer specifies the device and
    is associated with both the type and the instance GUIDs. For performance
    critical devices, the host may support multiple sub-channels. The sub-channels
    share the same type and instance GUID as the primary channel. The number of
    sub-channels offerrred to the guest depends on the number of virtual CPUs
    assigned to the guest. The guest can request the creation of these sub-channels
    and once created and opened, the guest can distribute the traffic across all
    the channels (the primary and the sub-channels). A request sent on a sub-channel
    will have the response delivered on the same sub-channel.
    
    At channel (sub-channel) creation we bind the channel interrupt to a CPU and
    with this sub-channel support we will be able to spread the interrupt load
    of a given device across all available CPUs.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Reviewed-by: Haiyang Zhang <haiyangz@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index 253a74ba245c..ec3b8cdf1e04 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -246,12 +246,26 @@ struct vmbus_channel *relid2channel(u32 relid)
 	struct vmbus_channel *channel;
 	struct vmbus_channel *found_channel  = NULL;
 	unsigned long flags;
+	struct list_head *cur, *tmp;
+	struct vmbus_channel *cur_sc;
 
 	spin_lock_irqsave(&vmbus_connection.channel_lock, flags);
 	list_for_each_entry(channel, &vmbus_connection.chn_list, listentry) {
 		if (channel->offermsg.child_relid == relid) {
 			found_channel = channel;
 			break;
+		} else if (!list_empty(&channel->sc_list)) {
+			/*
+			 * Deal with sub-channels.
+			 */
+			list_for_each_safe(cur, tmp, &channel->sc_list) {
+				cur_sc = list_entry(cur, struct vmbus_channel,
+							sc_list);
+				if (cur_sc->offermsg.child_relid == relid) {
+					found_channel = cur_sc;
+					break;
+				}
+			}
 		}
 	}
 	spin_unlock_irqrestore(&vmbus_connection.channel_lock, flags);

commit 3bacaf0ce106d9caca75f64a58f3b938b070df29
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Sat Dec 1 06:46:59 2012 -0800

    Drivers: hv: Cleanup and consolidate reporting of build/version info
    
    Now, cleanup and consolidate reporting of host and vmbus version numbers.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Reviewed-by: Haiyang Zhang <haiyangz@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index 3965537a659d..253a74ba245c 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -120,9 +120,6 @@ static int vmbus_negotiate_version(struct vmbus_channel_msginfo *msginfo,
 	if (msginfo->response.version_response.version_supported) {
 		vmbus_connection.conn_state = CONNECTED;
 	} else {
-		pr_err("Unable to connect, "
-			"Version %d not supported by Hyper-V\n",
-			version);
 		return -ECONNREFUSED;
 	}
 
@@ -208,11 +205,17 @@ int vmbus_connect(void)
 		goto cleanup;
 
 	vmbus_proto_version = version;
-	pr_info("Negotiated host information %d\n", version);
+	pr_info("Hyper-V Host Build:%d-%d.%d-%d-%d.%d; Vmbus version:%d.%d\n",
+		    host_info_eax, host_info_ebx >> 16,
+		    host_info_ebx & 0xFFFF, host_info_ecx,
+		    host_info_edx >> 24, host_info_edx & 0xFFFFFF,
+		    version >> 16, version & 0xFFFF);
+
 	kfree(msginfo);
 	return 0;
 
 cleanup:
+	pr_err("Unable to connect to host\n");
 	vmbus_connection.conn_state = DISCONNECTED;
 
 	if (vmbus_connection.work_queue)

commit 2a5c43a821b3b26e6af1cdb987b4daeba6f13a6f
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Sat Dec 1 06:46:56 2012 -0800

    Drivers: hv: Enable protocol negotiation with win8 hosts
    
    Now that we have implemented all of the Win8 (WS2012) functionality, negotiate
    Win8 protocol with the host.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Reviewed-by: Haiyang Zhang <haiyangz@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index ac71653abb77..3965537a659d 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -194,7 +194,7 @@ int vmbus_connect(void)
 	 * version.
 	 */
 
-	version = VERSION_WS2008;
+	version = VERSION_CURRENT;
 
 	do {
 		ret = vmbus_negotiate_version(msginfo, version);

commit 6552ecd70cc6f31f4bb9d63f36a7dd023db3e519
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Sat Dec 1 06:46:49 2012 -0800

    Drivers: hv: Modify the interrupt handling code to support win8 and beyond
    
    Starting with Win8 (WS2012), the event page can be used to directly get the
    channel ID that needs servicing. Modify the channel event handling code
    to take advantage of this feature.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Reviewed-by: Haiyang Zhang <haiyangz@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index 114050dc8e28..ac71653abb77 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -321,10 +321,32 @@ static void process_chn_event(u32 relid)
 void vmbus_on_event(unsigned long data)
 {
 	u32 dword;
-	u32 maxdword = MAX_NUM_CHANNELS_SUPPORTED >> 5;
+	u32 maxdword;
 	int bit;
 	u32 relid;
-	u32 *recv_int_page = vmbus_connection.recv_int_page;
+	u32 *recv_int_page = NULL;
+	void *page_addr;
+	int cpu = smp_processor_id();
+	union hv_synic_event_flags *event;
+
+	if ((vmbus_proto_version == VERSION_WS2008) ||
+		(vmbus_proto_version == VERSION_WIN7)) {
+		maxdword = MAX_NUM_CHANNELS_SUPPORTED >> 5;
+		recv_int_page = vmbus_connection.recv_int_page;
+	} else {
+		/*
+		 * When the host is win8 and beyond, the event page
+		 * can be directly checked to get the id of the channel
+		 * that has the interrupt pending.
+		 */
+		maxdword = HV_EVENT_FLAGS_DWORD_COUNT;
+		page_addr = hv_context.synic_event_page[cpu];
+		event = (union hv_synic_event_flags *)page_addr +
+						 VMBUS_MESSAGE_SINT;
+		recv_int_page = event->flags32;
+	}
+
+
 
 	/* Check events */
 	if (!recv_int_page)

commit 3be77774017fc3c7dd0b434265dfa417aac23545
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Sat Dec 1 06:46:46 2012 -0800

    Drivers: hv: Cleanup vmbus_set_event() to support win7 and beyond
    
    On win7 (ws2008 R2) and beyond, we have the notion of having dedicated interrupts on
    a per-channel basis. When a channel has a dedicated interrupt assigned, there is no need
    to set the interrupt bit in the shared page. Implement this optimization.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Reviewed-by: Haiyang Zhang <haiyangz@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index 56b14e57bdd8..114050dc8e28 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -383,10 +383,13 @@ int vmbus_post_msg(void *buffer, size_t buflen)
 int vmbus_set_event(struct vmbus_channel *channel)
 {
 	u32 child_relid = channel->offermsg.child_relid;
-	/* Each u32 represents 32 channels */
-	sync_set_bit(child_relid & 31,
-		(unsigned long *)vmbus_connection.send_int_page +
-		(child_relid >> 5));
 
-	return hv_signal_event(hv_context.signal_event_param);
+	if (!channel->is_dedicated_interrupt) {
+		/* Each u32 represents 32 channels */
+		sync_set_bit(child_relid & 31,
+			(unsigned long *)vmbus_connection.send_int_page +
+			(child_relid >> 5));
+	}
+
+	return hv_signal_event(channel->sig_event);
 }

commit eafa7072e7cd806dff42b705284ca26189e527a4
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Sat Dec 1 06:46:44 2012 -0800

    Drivers: hv: Move vmbus version definitions to hyperv.h
    
    To support version specific optimization in various vmbus drivers,
    move the vmbus definitions to the public header file.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Reviewed-by: Haiyang Zhang <haiyangz@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index 0d8b13290e93..56b14e57bdd8 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -40,21 +40,6 @@ struct vmbus_connection vmbus_connection = {
 	.next_gpadl_handle	= ATOMIC_INIT(0xE1E10),
 };
 
-/*
- * VMBUS version is 32 bit entity broken up into
- * two 16 bit quantities: major_number. minor_number.
- *
- * 0 . 13 (Windows Server 2008)
- * 1 . 1  (Windows 7)
- * 2 . 4  (Windows 8)
- */
-
-#define VERSION_WS2008	((0 << 16) | (13))
-#define VERSION_WIN7	((1 << 16) | (1))
-#define VERSION_WIN8	((2 << 16) | (4))
-
-#define VERSION_INVAL -1
-
 /*
  * Negotiated protocol version with the host.
  */

commit 21c3bef5db359596806f19fee6c3ec0c033881d0
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Sat Dec 1 06:46:43 2012 -0800

    Drivers: hv: Change the signature of vmbus_set_event()
    
    In preparation for supporting a per-connection signaling mechanism,
    change the signature of vmbus_set_event(). This change is also
    needed to implement other aspects of the signaling optimization.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Reviewed-by: Haiyang Zhang <haiyangz@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index 3f8ce7be4c18..0d8b13290e93 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -395,8 +395,9 @@ int vmbus_post_msg(void *buffer, size_t buflen)
 /*
  * vmbus_set_event - Send an event notification to the parent
  */
-int vmbus_set_event(u32 child_relid)
+int vmbus_set_event(struct vmbus_channel *channel)
 {
+	u32 child_relid = channel->offermsg.child_relid;
 	/* Each u32 represents 32 channels */
 	sync_set_bit(child_relid & 31,
 		(unsigned long *)vmbus_connection.send_int_page +

commit 1f42248d724a413baaafd5f83a8f4746bc6f51a5
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Sat Dec 1 06:46:42 2012 -0800

    Drivers: hv: Change the signature for hv_signal_event()
    
    In preparation for implementing a per-connection signaling framework,
    change the signature of the function hv_signal_event(). The current
    code uses a global handle for signaling the host.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Reviewed-by: Haiyang Zhang <haiyangz@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index 70ea5d1fc16c..3f8ce7be4c18 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -402,5 +402,5 @@ int vmbus_set_event(u32 child_relid)
 		(unsigned long *)vmbus_connection.send_int_page +
 		(child_relid >> 5));
 
-	return hv_signal_event();
+	return hv_signal_event(hv_context.signal_event_param);
 }

commit 37f7278b81a9ab9b76cf4d716ba420444ca4a616
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Sat Dec 1 06:46:41 2012 -0800

    Drivers: hv: Save and export negotiated vmbus version
    
    Export the negotiated vmbus version as this may be useful for
    individual drivers.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Reviewed-by: Haiyang Zhang <haiyangz@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index 2b56a3f47b30..70ea5d1fc16c 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -30,6 +30,7 @@
 #include <linux/slab.h>
 #include <linux/vmalloc.h>
 #include <linux/hyperv.h>
+#include <linux/export.h>
 #include <asm/hyperv.h>
 #include "hyperv_vmbus.h"
 
@@ -54,6 +55,12 @@ struct vmbus_connection vmbus_connection = {
 
 #define VERSION_INVAL -1
 
+/*
+ * Negotiated protocol version with the host.
+ */
+__u32 vmbus_proto_version;
+EXPORT_SYMBOL_GPL(vmbus_proto_version);
+
 static __u32 vmbus_get_next_version(__u32 current_version)
 {
 	switch (current_version) {
@@ -215,6 +222,8 @@ int vmbus_connect(void)
 	if (version == VERSION_INVAL)
 		goto cleanup;
 
+	vmbus_proto_version = version;
+	pr_info("Negotiated host information %d\n", version);
 	kfree(msginfo);
 	return 0;
 

commit 610071c38463998d5a66388ff9956aaeb24b49a8
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Sat Dec 1 06:46:38 2012 -0800

    Drivers: hv: Support handling multiple VMBUS versions
    
    The current code hard coded the vmbus version independent of the host
    it was running on. Add code to dynamically negotiate the most appropriate
    version.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Reviewed-by: Haiyang Zhang <haiyangz@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index d1019a770ad7..2b56a3f47b30 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -39,16 +39,112 @@ struct vmbus_connection vmbus_connection = {
 	.next_gpadl_handle	= ATOMIC_INIT(0xE1E10),
 };
 
+/*
+ * VMBUS version is 32 bit entity broken up into
+ * two 16 bit quantities: major_number. minor_number.
+ *
+ * 0 . 13 (Windows Server 2008)
+ * 1 . 1  (Windows 7)
+ * 2 . 4  (Windows 8)
+ */
+
+#define VERSION_WS2008	((0 << 16) | (13))
+#define VERSION_WIN7	((1 << 16) | (1))
+#define VERSION_WIN8	((2 << 16) | (4))
+
+#define VERSION_INVAL -1
+
+static __u32 vmbus_get_next_version(__u32 current_version)
+{
+	switch (current_version) {
+	case (VERSION_WIN7):
+		return VERSION_WS2008;
+
+	case (VERSION_WIN8):
+		return VERSION_WIN7;
+
+	case (VERSION_WS2008):
+	default:
+		return VERSION_INVAL;
+	}
+}
+
+static int vmbus_negotiate_version(struct vmbus_channel_msginfo *msginfo,
+					__u32 version)
+{
+	int ret = 0;
+	struct vmbus_channel_initiate_contact *msg;
+	unsigned long flags;
+	int t;
+
+	init_completion(&msginfo->waitevent);
+
+	msg = (struct vmbus_channel_initiate_contact *)msginfo->msg;
+
+	msg->header.msgtype = CHANNELMSG_INITIATE_CONTACT;
+	msg->vmbus_version_requested = version;
+	msg->interrupt_page = virt_to_phys(vmbus_connection.int_page);
+	msg->monitor_page1 = virt_to_phys(vmbus_connection.monitor_pages);
+	msg->monitor_page2 = virt_to_phys(
+			(void *)((unsigned long)vmbus_connection.monitor_pages +
+				 PAGE_SIZE));
+
+	/*
+	 * Add to list before we send the request since we may
+	 * receive the response before returning from this routine
+	 */
+	spin_lock_irqsave(&vmbus_connection.channelmsg_lock, flags);
+	list_add_tail(&msginfo->msglistentry,
+		      &vmbus_connection.chn_msg_list);
+
+	spin_unlock_irqrestore(&vmbus_connection.channelmsg_lock, flags);
+
+	ret = vmbus_post_msg(msg,
+			       sizeof(struct vmbus_channel_initiate_contact));
+	if (ret != 0) {
+		spin_lock_irqsave(&vmbus_connection.channelmsg_lock, flags);
+		list_del(&msginfo->msglistentry);
+		spin_unlock_irqrestore(&vmbus_connection.channelmsg_lock,
+					flags);
+		return ret;
+	}
+
+	/* Wait for the connection response */
+	t =  wait_for_completion_timeout(&msginfo->waitevent, 5*HZ);
+	if (t == 0) {
+		spin_lock_irqsave(&vmbus_connection.channelmsg_lock,
+				flags);
+		list_del(&msginfo->msglistentry);
+		spin_unlock_irqrestore(&vmbus_connection.channelmsg_lock,
+					flags);
+		return -ETIMEDOUT;
+	}
+
+	spin_lock_irqsave(&vmbus_connection.channelmsg_lock, flags);
+	list_del(&msginfo->msglistentry);
+	spin_unlock_irqrestore(&vmbus_connection.channelmsg_lock, flags);
+
+	/* Check if successful */
+	if (msginfo->response.version_response.version_supported) {
+		vmbus_connection.conn_state = CONNECTED;
+	} else {
+		pr_err("Unable to connect, "
+			"Version %d not supported by Hyper-V\n",
+			version);
+		return -ECONNREFUSED;
+	}
+
+	return ret;
+}
+
 /*
  * vmbus_connect - Sends a connect request on the partition service connection
  */
 int vmbus_connect(void)
 {
 	int ret = 0;
-	int t;
 	struct vmbus_channel_msginfo *msginfo = NULL;
-	struct vmbus_channel_initiate_contact *msg;
-	unsigned long flags;
+	__u32 version;
 
 	/* Initialize the vmbus connection */
 	vmbus_connection.conn_state = CONNECTING;
@@ -99,64 +195,25 @@ int vmbus_connect(void)
 		goto cleanup;
 	}
 
-	init_completion(&msginfo->waitevent);
-
-	msg = (struct vmbus_channel_initiate_contact *)msginfo->msg;
-
-	msg->header.msgtype = CHANNELMSG_INITIATE_CONTACT;
-	msg->vmbus_version_requested = VMBUS_REVISION_NUMBER;
-	msg->interrupt_page = virt_to_phys(vmbus_connection.int_page);
-	msg->monitor_page1 = virt_to_phys(vmbus_connection.monitor_pages);
-	msg->monitor_page2 = virt_to_phys(
-			(void *)((unsigned long)vmbus_connection.monitor_pages +
-				 PAGE_SIZE));
-
 	/*
-	 * Add to list before we send the request since we may
-	 * receive the response before returning from this routine
+	 * Negotiate a compatible VMBUS version number with the
+	 * host. We start with the highest number we can support
+	 * and work our way down until we negotiate a compatible
+	 * version.
 	 */
-	spin_lock_irqsave(&vmbus_connection.channelmsg_lock, flags);
-	list_add_tail(&msginfo->msglistentry,
-		      &vmbus_connection.chn_msg_list);
-
-	spin_unlock_irqrestore(&vmbus_connection.channelmsg_lock, flags);
 
-	ret = vmbus_post_msg(msg,
-			       sizeof(struct vmbus_channel_initiate_contact));
-	if (ret != 0) {
-		spin_lock_irqsave(&vmbus_connection.channelmsg_lock, flags);
-		list_del(&msginfo->msglistentry);
-		spin_unlock_irqrestore(&vmbus_connection.channelmsg_lock,
-					flags);
-		goto cleanup;
-	}
+	version = VERSION_WS2008;
 
-	/* Wait for the connection response */
-	t =  wait_for_completion_timeout(&msginfo->waitevent, 5*HZ);
-	if (t == 0) {
-		spin_lock_irqsave(&vmbus_connection.channelmsg_lock,
-				flags);
-		list_del(&msginfo->msglistentry);
-		spin_unlock_irqrestore(&vmbus_connection.channelmsg_lock,
-					flags);
-		ret = -ETIMEDOUT;
-		goto cleanup;
-	}
+	do {
+		ret = vmbus_negotiate_version(msginfo, version);
+		if (ret == 0)
+			break;
 
-	spin_lock_irqsave(&vmbus_connection.channelmsg_lock, flags);
-	list_del(&msginfo->msglistentry);
-	spin_unlock_irqrestore(&vmbus_connection.channelmsg_lock, flags);
+		version = vmbus_get_next_version(version);
+	} while (version != VERSION_INVAL);
 
-	/* Check if successful */
-	if (msginfo->response.version_response.version_supported) {
-		vmbus_connection.conn_state = CONNECTED;
-	} else {
-		pr_err("Unable to connect, "
-			"Version %d not supported by Hyper-V\n",
-			VMBUS_REVISION_NUMBER);
-		ret = -ECONNREFUSED;
+	if (version == VERSION_INVAL)
 		goto cleanup;
-	}
 
 	kfree(msginfo);
 	return 0;

commit f878f3d59ed26f489add852ed6d5c8e5f3bbb1aa
Author: K. Y. Srinivasan <kys@microsoft.com>
Date:   Sat Dec 1 06:46:35 2012 -0800

    Drivers: hv: Optimize signaling in the read path
    
    Now that we have the infratructure for correctly determining when we
    should signal the host; optimize the signaling on the read side -
    signaling the guest from the host.
    
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Reviewed-by: Haiyang Zhang <haiyangz@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index 650c9f0b6642..d1019a770ad7 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -212,6 +212,9 @@ static void process_chn_event(u32 relid)
 {
 	struct vmbus_channel *channel;
 	unsigned long flags;
+	void *arg;
+	bool read_state;
+	u32 bytes_to_read;
 
 	/*
 	 * Find the channel based on this relid and invokes the
@@ -234,10 +237,29 @@ static void process_chn_event(u32 relid)
 	 */
 
 	spin_lock_irqsave(&channel->inbound_lock, flags);
-	if (channel->onchannel_callback != NULL)
-		channel->onchannel_callback(channel->channel_callback_context);
-	else
+	if (channel->onchannel_callback != NULL) {
+		arg = channel->channel_callback_context;
+		read_state = channel->batched_reading;
+		/*
+		 * This callback reads the messages sent by the host.
+		 * We can optimize host to guest signaling by ensuring:
+		 * 1. While reading the channel, we disable interrupts from
+		 *    host.
+		 * 2. Ensure that we process all posted messages from the host
+		 *    before returning from this callback.
+		 * 3. Once we return, enable signaling from the host. Once this
+		 *    state is set we check to see if additional packets are
+		 *    available to read. In this case we repeat the process.
+		 */
+
+		do {
+			hv_begin_read(&channel->inbound);
+			channel->onchannel_callback(arg);
+			bytes_to_read = hv_end_read(&channel->inbound);
+		} while (read_state && (bytes_to_read != 0));
+	} else {
 		pr_err("no channel callback for relid - %u\n", relid);
+	}
 
 	spin_unlock_irqrestore(&channel->inbound_lock, flags);
 }

commit 407dd1644302ea78fa5d740e67a1c09677aa18a4
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Oct 11 08:36:44 2011 -0600

    Staging: hv: remove unneeded asm include file in hyperv.h
    
    No one outside of the hyperv core needs to include the asm/hyperv.h
    file, so don't put it in the "global" include/linux/hyperv.h file.
    
    Cc: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index 5f438b650068..650c9f0b6642 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -30,7 +30,7 @@
 #include <linux/slab.h>
 #include <linux/vmalloc.h>
 #include <linux/hyperv.h>
-
+#include <asm/hyperv.h>
 #include "hyperv_vmbus.h"
 
 

commit 46a971913611a23478283931460a95be962ce329
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Oct 4 12:29:52 2011 -0700

    Staging: hv: move hyperv code out of staging directory
    
    After many years wandering the desert, it is finally time for the
    Microsoft HyperV code to move out of the staging directory.  Or at least
    the core hyperv bus code, and the utility driver, the rest still have
    some review to get through by the various subsystem maintainers.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>

diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
new file mode 100644
index 000000000000..5f438b650068
--- /dev/null
+++ b/drivers/hv/connection.c
@@ -0,0 +1,318 @@
+/*
+ *
+ * Copyright (c) 2009, Microsoft Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * Authors:
+ *   Haiyang Zhang <haiyangz@microsoft.com>
+ *   Hank Janssen  <hjanssen@microsoft.com>
+ *
+ */
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/wait.h>
+#include <linux/delay.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/hyperv.h>
+
+#include "hyperv_vmbus.h"
+
+
+struct vmbus_connection vmbus_connection = {
+	.conn_state		= DISCONNECTED,
+	.next_gpadl_handle	= ATOMIC_INIT(0xE1E10),
+};
+
+/*
+ * vmbus_connect - Sends a connect request on the partition service connection
+ */
+int vmbus_connect(void)
+{
+	int ret = 0;
+	int t;
+	struct vmbus_channel_msginfo *msginfo = NULL;
+	struct vmbus_channel_initiate_contact *msg;
+	unsigned long flags;
+
+	/* Initialize the vmbus connection */
+	vmbus_connection.conn_state = CONNECTING;
+	vmbus_connection.work_queue = create_workqueue("hv_vmbus_con");
+	if (!vmbus_connection.work_queue) {
+		ret = -ENOMEM;
+		goto cleanup;
+	}
+
+	INIT_LIST_HEAD(&vmbus_connection.chn_msg_list);
+	spin_lock_init(&vmbus_connection.channelmsg_lock);
+
+	INIT_LIST_HEAD(&vmbus_connection.chn_list);
+	spin_lock_init(&vmbus_connection.channel_lock);
+
+	/*
+	 * Setup the vmbus event connection for channel interrupt
+	 * abstraction stuff
+	 */
+	vmbus_connection.int_page =
+	(void *)__get_free_pages(GFP_KERNEL|__GFP_ZERO, 0);
+	if (vmbus_connection.int_page == NULL) {
+		ret = -ENOMEM;
+		goto cleanup;
+	}
+
+	vmbus_connection.recv_int_page = vmbus_connection.int_page;
+	vmbus_connection.send_int_page =
+		(void *)((unsigned long)vmbus_connection.int_page +
+			(PAGE_SIZE >> 1));
+
+	/*
+	 * Setup the monitor notification facility. The 1st page for
+	 * parent->child and the 2nd page for child->parent
+	 */
+	vmbus_connection.monitor_pages =
+	(void *)__get_free_pages((GFP_KERNEL|__GFP_ZERO), 1);
+	if (vmbus_connection.monitor_pages == NULL) {
+		ret = -ENOMEM;
+		goto cleanup;
+	}
+
+	msginfo = kzalloc(sizeof(*msginfo) +
+			  sizeof(struct vmbus_channel_initiate_contact),
+			  GFP_KERNEL);
+	if (msginfo == NULL) {
+		ret = -ENOMEM;
+		goto cleanup;
+	}
+
+	init_completion(&msginfo->waitevent);
+
+	msg = (struct vmbus_channel_initiate_contact *)msginfo->msg;
+
+	msg->header.msgtype = CHANNELMSG_INITIATE_CONTACT;
+	msg->vmbus_version_requested = VMBUS_REVISION_NUMBER;
+	msg->interrupt_page = virt_to_phys(vmbus_connection.int_page);
+	msg->monitor_page1 = virt_to_phys(vmbus_connection.monitor_pages);
+	msg->monitor_page2 = virt_to_phys(
+			(void *)((unsigned long)vmbus_connection.monitor_pages +
+				 PAGE_SIZE));
+
+	/*
+	 * Add to list before we send the request since we may
+	 * receive the response before returning from this routine
+	 */
+	spin_lock_irqsave(&vmbus_connection.channelmsg_lock, flags);
+	list_add_tail(&msginfo->msglistentry,
+		      &vmbus_connection.chn_msg_list);
+
+	spin_unlock_irqrestore(&vmbus_connection.channelmsg_lock, flags);
+
+	ret = vmbus_post_msg(msg,
+			       sizeof(struct vmbus_channel_initiate_contact));
+	if (ret != 0) {
+		spin_lock_irqsave(&vmbus_connection.channelmsg_lock, flags);
+		list_del(&msginfo->msglistentry);
+		spin_unlock_irqrestore(&vmbus_connection.channelmsg_lock,
+					flags);
+		goto cleanup;
+	}
+
+	/* Wait for the connection response */
+	t =  wait_for_completion_timeout(&msginfo->waitevent, 5*HZ);
+	if (t == 0) {
+		spin_lock_irqsave(&vmbus_connection.channelmsg_lock,
+				flags);
+		list_del(&msginfo->msglistentry);
+		spin_unlock_irqrestore(&vmbus_connection.channelmsg_lock,
+					flags);
+		ret = -ETIMEDOUT;
+		goto cleanup;
+	}
+
+	spin_lock_irqsave(&vmbus_connection.channelmsg_lock, flags);
+	list_del(&msginfo->msglistentry);
+	spin_unlock_irqrestore(&vmbus_connection.channelmsg_lock, flags);
+
+	/* Check if successful */
+	if (msginfo->response.version_response.version_supported) {
+		vmbus_connection.conn_state = CONNECTED;
+	} else {
+		pr_err("Unable to connect, "
+			"Version %d not supported by Hyper-V\n",
+			VMBUS_REVISION_NUMBER);
+		ret = -ECONNREFUSED;
+		goto cleanup;
+	}
+
+	kfree(msginfo);
+	return 0;
+
+cleanup:
+	vmbus_connection.conn_state = DISCONNECTED;
+
+	if (vmbus_connection.work_queue)
+		destroy_workqueue(vmbus_connection.work_queue);
+
+	if (vmbus_connection.int_page) {
+		free_pages((unsigned long)vmbus_connection.int_page, 0);
+		vmbus_connection.int_page = NULL;
+	}
+
+	if (vmbus_connection.monitor_pages) {
+		free_pages((unsigned long)vmbus_connection.monitor_pages, 1);
+		vmbus_connection.monitor_pages = NULL;
+	}
+
+	kfree(msginfo);
+
+	return ret;
+}
+
+
+/*
+ * relid2channel - Get the channel object given its
+ * child relative id (ie channel id)
+ */
+struct vmbus_channel *relid2channel(u32 relid)
+{
+	struct vmbus_channel *channel;
+	struct vmbus_channel *found_channel  = NULL;
+	unsigned long flags;
+
+	spin_lock_irqsave(&vmbus_connection.channel_lock, flags);
+	list_for_each_entry(channel, &vmbus_connection.chn_list, listentry) {
+		if (channel->offermsg.child_relid == relid) {
+			found_channel = channel;
+			break;
+		}
+	}
+	spin_unlock_irqrestore(&vmbus_connection.channel_lock, flags);
+
+	return found_channel;
+}
+
+/*
+ * process_chn_event - Process a channel event notification
+ */
+static void process_chn_event(u32 relid)
+{
+	struct vmbus_channel *channel;
+	unsigned long flags;
+
+	/*
+	 * Find the channel based on this relid and invokes the
+	 * channel callback to process the event
+	 */
+	channel = relid2channel(relid);
+
+	if (!channel) {
+		pr_err("channel not found for relid - %u\n", relid);
+		return;
+	}
+
+	/*
+	 * A channel once created is persistent even when there
+	 * is no driver handling the device. An unloading driver
+	 * sets the onchannel_callback to NULL under the
+	 * protection of the channel inbound_lock. Thus, checking
+	 * and invoking the driver specific callback takes care of
+	 * orderly unloading of the driver.
+	 */
+
+	spin_lock_irqsave(&channel->inbound_lock, flags);
+	if (channel->onchannel_callback != NULL)
+		channel->onchannel_callback(channel->channel_callback_context);
+	else
+		pr_err("no channel callback for relid - %u\n", relid);
+
+	spin_unlock_irqrestore(&channel->inbound_lock, flags);
+}
+
+/*
+ * vmbus_on_event - Handler for events
+ */
+void vmbus_on_event(unsigned long data)
+{
+	u32 dword;
+	u32 maxdword = MAX_NUM_CHANNELS_SUPPORTED >> 5;
+	int bit;
+	u32 relid;
+	u32 *recv_int_page = vmbus_connection.recv_int_page;
+
+	/* Check events */
+	if (!recv_int_page)
+		return;
+	for (dword = 0; dword < maxdword; dword++) {
+		if (!recv_int_page[dword])
+			continue;
+		for (bit = 0; bit < 32; bit++) {
+			if (sync_test_and_clear_bit(bit,
+				(unsigned long *)&recv_int_page[dword])) {
+				relid = (dword << 5) + bit;
+
+				if (relid == 0)
+					/*
+					 * Special case - vmbus
+					 * channel protocol msg
+					 */
+					continue;
+
+				process_chn_event(relid);
+			}
+		}
+	}
+}
+
+/*
+ * vmbus_post_msg - Send a msg on the vmbus's message connection
+ */
+int vmbus_post_msg(void *buffer, size_t buflen)
+{
+	union hv_connection_id conn_id;
+	int ret = 0;
+	int retries = 0;
+
+	conn_id.asu32 = 0;
+	conn_id.u.id = VMBUS_MESSAGE_CONNECTION_ID;
+
+	/*
+	 * hv_post_message() can have transient failures because of
+	 * insufficient resources. Retry the operation a couple of
+	 * times before giving up.
+	 */
+	while (retries < 3) {
+		ret =  hv_post_message(conn_id, 1, buffer, buflen);
+		if (ret != HV_STATUS_INSUFFICIENT_BUFFERS)
+			return ret;
+		retries++;
+		msleep(100);
+	}
+	return ret;
+}
+
+/*
+ * vmbus_set_event - Send an event notification to the parent
+ */
+int vmbus_set_event(u32 child_relid)
+{
+	/* Each u32 represents 32 channels */
+	sync_set_bit(child_relid & 31,
+		(unsigned long *)vmbus_connection.send_int_page +
+		(child_relid >> 5));
+
+	return hv_signal_event();
+}
