commit 43aa31327bb36002f52026b13d5f1bde35a1fc14
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 07:17:54 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 280
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation this program is
      distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose good title or non infringement see
      the gnu general public license for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 9 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190529141900.459653302@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hv/hv_utils_transport.h b/drivers/hv/hv_utils_transport.h
index 79afb626e166..1c162393c27b 100644
--- a/drivers/hv/hv_utils_transport.h
+++ b/drivers/hv/hv_utils_transport.h
@@ -1,18 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * Kernel/userspace transport abstraction for Hyper-V util driver.
  *
  * Copyright (C) 2015, Vitaly Kuznetsov <vkuznets@redhat.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or
- * NON INFRINGEMENT.  See the GNU General Public License for more
- * details.
- *
  */
 
 #ifndef _HV_UTILS_TRANSPORT_H

commit e9c18ae6eb2b312f16c63e34b43ea23926daa398
Author: Vitaly Kuznetsov <vkuznets@redhat.com>
Date:   Sat Mar 4 18:13:59 2017 -0700

    Drivers: hv: util: move waiting for release to hv_utils_transport itself
    
    Waiting for release_event in all three drivers introduced issues on release
    as on_reset() hook is not always called. E.g. if the device was never
    opened we will never get the completion.
    
    Move the waiting code to hvutil_transport_destroy() and make sure it is
    only called when the device is open. hvt->lock serialization should
    guarantee the absence of races.
    
    Fixes: 5a66fecbf6aa ("Drivers: hv: util: kvp: Fix a rescind processing issue")
    Fixes: 20951c7535b5 ("Drivers: hv: util: Fcopy: Fix a rescind processing issue")
    Fixes: d77044d142e9 ("Drivers: hv: util: Backup: Fix a rescind processing issue")
    
    Reported-by: Dexuan Cui <decui@microsoft.com>
    Tested-by: Dexuan Cui <decui@microsoft.com>
    Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hv/hv_utils_transport.h b/drivers/hv/hv_utils_transport.h
index d98f5225c3e6..79afb626e166 100644
--- a/drivers/hv/hv_utils_transport.h
+++ b/drivers/hv/hv_utils_transport.h
@@ -41,6 +41,7 @@ struct hvutil_transport {
 	int outmsg_len;                     /* its length */
 	wait_queue_head_t outmsg_q;         /* poll/read wait queue */
 	struct mutex lock;                  /* protects struct members */
+	struct completion release;          /* synchronize with fd release */
 };
 
 struct hvutil_transport *hvutil_transport_init(const char *name,

commit e0fa3e5e7df61eb2c339c9f0067c202c0cdeec2c
Author: Vitaly Kuznetsov <vkuznets@redhat.com>
Date:   Thu Jun 9 17:08:57 2016 -0700

    Drivers: hv: utils: fix a race on userspace daemons registration
    
    Background: userspace daemons registration protocol for Hyper-V utilities
    drivers has two steps:
    1) daemon writes its own version to kernel
    2) kernel reads it and replies with module version
    at this point we consider the handshake procedure being completed and we
    do hv_poll_channel() transitioning the utility device to HVUTIL_READY
    state. At this point we're ready to handle messages from kernel.
    
    When hvutil_transport is in HVUTIL_TRANSPORT_CHARDEV mode we have a
    single buffer for outgoing message. hvutil_transport_send() puts to this
    buffer and till the buffer is cleared with hvt_op_read() returns -EFAULT
    to all consequent calls. Host<->guest protocol guarantees there is no more
    than one request at a time and we will not get new requests till we reply
    to the previous one so this single message buffer is enough.
    
    Now to the race. When we finish negotiation procedure and send kernel
    module version to userspace with hvutil_transport_send() it goes into the
    above mentioned buffer and if the daemon is slow enough to read it from
    there we can get a collision when a request from the host comes, we won't
    be able to put anything to the buffer so the request will be lost. To
    solve the issue we need to know when the negotiation is really done (when
    the version message is read by the daemon) and transition to HVUTIL_READY
    state after this happens. Implement a callback on read to support this.
    Old style netlink communication is not affected by the change, we don't
    really know when these messages are delivered but we don't have a single
    message buffer there.
    
    Reported-by: Barry Davis <barry_davis@stormagic.com>
    Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hv/hv_utils_transport.h b/drivers/hv/hv_utils_transport.h
index 06254a165a18..d98f5225c3e6 100644
--- a/drivers/hv/hv_utils_transport.h
+++ b/drivers/hv/hv_utils_transport.h
@@ -36,6 +36,7 @@ struct hvutil_transport {
 	struct list_head list;              /* hvt_list */
 	int (*on_msg)(void *, int);         /* callback on new user message */
 	void (*on_reset)(void);             /* callback when userspace drops */
+	void (*on_read)(void);              /* callback on message read */
 	u8 *outmsg;                         /* message to the userspace */
 	int outmsg_len;                     /* its length */
 	wait_queue_head_t outmsg_q;         /* poll/read wait queue */
@@ -46,7 +47,8 @@ struct hvutil_transport *hvutil_transport_init(const char *name,
 					       u32 cn_idx, u32 cn_val,
 					       int (*on_msg)(void *, int),
 					       void (*on_reset)(void));
-int hvutil_transport_send(struct hvutil_transport *hvt, void *msg, int len);
+int hvutil_transport_send(struct hvutil_transport *hvt, void *msg, int len,
+			  void (*on_read_cb)(void));
 void hvutil_transport_destroy(struct hvutil_transport *hvt);
 
 #endif /* _HV_UTILS_TRANSPORT_H */

commit a15025660d4703a8b37290a14734cb4a84875770
Author: Vitaly Kuznetsov <vkuznets@redhat.com>
Date:   Mon Dec 14 19:01:55 2015 -0800

    Drivers: hv: utils: introduce HVUTIL_TRANSPORT_DESTROY mode
    
    When Hyper-V host asks us to remove some util driver by closing the
    appropriate channel there is no easy way to force the current file
    descriptor holder to hang up but we can start to respond -EBADF to all
    operations asking it to exit gracefully.
    
    As we're setting hvt->mode from two separate contexts now we need to use
    a proper locking.
    
    Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hv/hv_utils_transport.h b/drivers/hv/hv_utils_transport.h
index bff4c921e817..06254a165a18 100644
--- a/drivers/hv/hv_utils_transport.h
+++ b/drivers/hv/hv_utils_transport.h
@@ -25,6 +25,7 @@ enum hvutil_transport_mode {
 	HVUTIL_TRANSPORT_INIT = 0,
 	HVUTIL_TRANSPORT_NETLINK,
 	HVUTIL_TRANSPORT_CHARDEV,
+	HVUTIL_TRANSPORT_DESTROY,
 };
 
 struct hvutil_transport {

commit a72f3a4ccff22de879a1f599210ecdd9bd483a43
Author: Vitaly Kuznetsov <vkuznets@redhat.com>
Date:   Mon Dec 14 19:01:54 2015 -0800

    Drivers: hv: utils: rename outmsg_lock
    
    As a preparation to reusing outmsg_lock to protect test-and-set openrations
    on 'mode' rename it the more general 'lock'.
    
    Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hv/hv_utils_transport.h b/drivers/hv/hv_utils_transport.h
index 314c76ce1b07..bff4c921e817 100644
--- a/drivers/hv/hv_utils_transport.h
+++ b/drivers/hv/hv_utils_transport.h
@@ -38,7 +38,7 @@ struct hvutil_transport {
 	u8 *outmsg;                         /* message to the userspace */
 	int outmsg_len;                     /* its length */
 	wait_queue_head_t outmsg_q;         /* poll/read wait queue */
-	struct mutex outmsg_lock;           /* protects outmsg */
+	struct mutex lock;                  /* protects struct members */
 };
 
 struct hvutil_transport *hvutil_transport_init(const char *name,

commit 14b50f80c32dd4e84b6baeaa8bf4049cc5ecf56d
Author: Vitaly Kuznetsov <vkuznets@redhat.com>
Date:   Sat Apr 11 18:07:51 2015 -0700

    Drivers: hv: util: introduce hv_utils_transport abstraction
    
    The intention is to make KVP/VSS drivers work through misc char devices.
    Introduce an abstraction for kernel/userspace communication to make the
    migration smoother. Transport operational mode (netlink or char device)
    is determined by the first received message. To support driver upgrades
    the switch from netlink to chardev operational mode is supported.
    
    Every hv_util daemon is supposed to register 2 callbacks:
    1) on_msg() to get notified when the userspace daemon sent a message;
    2) on_reset() to get notified when the userspace daemon drops the connection.
    
    Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
    Tested-by: Alex Ng <alexng@microsoft.com>
    Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hv/hv_utils_transport.h b/drivers/hv/hv_utils_transport.h
new file mode 100644
index 000000000000..314c76ce1b07
--- /dev/null
+++ b/drivers/hv/hv_utils_transport.h
@@ -0,0 +1,51 @@
+/*
+ * Kernel/userspace transport abstraction for Hyper-V util driver.
+ *
+ * Copyright (C) 2015, Vitaly Kuznetsov <vkuznets@redhat.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or
+ * NON INFRINGEMENT.  See the GNU General Public License for more
+ * details.
+ *
+ */
+
+#ifndef _HV_UTILS_TRANSPORT_H
+#define _HV_UTILS_TRANSPORT_H
+
+#include <linux/connector.h>
+#include <linux/miscdevice.h>
+
+enum hvutil_transport_mode {
+	HVUTIL_TRANSPORT_INIT = 0,
+	HVUTIL_TRANSPORT_NETLINK,
+	HVUTIL_TRANSPORT_CHARDEV,
+};
+
+struct hvutil_transport {
+	int mode;                           /* hvutil_transport_mode */
+	struct file_operations fops;        /* file operations */
+	struct miscdevice mdev;             /* misc device */
+	struct cb_id cn_id;                 /* CN_*_IDX/CN_*_VAL */
+	struct list_head list;              /* hvt_list */
+	int (*on_msg)(void *, int);         /* callback on new user message */
+	void (*on_reset)(void);             /* callback when userspace drops */
+	u8 *outmsg;                         /* message to the userspace */
+	int outmsg_len;                     /* its length */
+	wait_queue_head_t outmsg_q;         /* poll/read wait queue */
+	struct mutex outmsg_lock;           /* protects outmsg */
+};
+
+struct hvutil_transport *hvutil_transport_init(const char *name,
+					       u32 cn_idx, u32 cn_val,
+					       int (*on_msg)(void *, int),
+					       void (*on_reset)(void));
+int hvutil_transport_send(struct hvutil_transport *hvt, void *msg, int len);
+void hvutil_transport_destroy(struct hvutil_transport *hvt);
+
+#endif /* _HV_UTILS_TRANSPORT_H */
