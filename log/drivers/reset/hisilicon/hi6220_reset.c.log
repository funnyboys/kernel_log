commit 697fa27dc5fb4c669471e728e97f176687982f95
Author: Peter Griffin <peter.griffin@linaro.org>
Date:   Fri Mar 6 17:21:13 2020 +0000

    reset: hi6220: Add support for AO reset controller
    
    This is required to bring Mali450 gpu out of reset.
    
    Cc: Peter Griffin <peter.griffin@linaro.org>
    Cc: Enrico Weigelt <info@metux.net>
    Signed-off-by: Peter Griffin <peter.griffin@linaro.org>
    [jstultz: Added comment, Fix void return build issue
    Reported-by: kbuild test robot <lkp@intel.com>]
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/drivers/reset/hisilicon/hi6220_reset.c b/drivers/reset/hisilicon/hi6220_reset.c
index 24e6d420b26b..19926506d033 100644
--- a/drivers/reset/hisilicon/hi6220_reset.c
+++ b/drivers/reset/hisilicon/hi6220_reset.c
@@ -33,6 +33,7 @@
 enum hi6220_reset_ctrl_type {
 	PERIPHERAL,
 	MEDIA,
+	AO,
 };
 
 struct hi6220_reset_data {
@@ -92,6 +93,65 @@ static const struct reset_control_ops hi6220_media_reset_ops = {
 	.deassert = hi6220_media_deassert,
 };
 
+#define AO_SCTRL_SC_PW_CLKEN0     0x800
+#define AO_SCTRL_SC_PW_CLKDIS0    0x804
+
+#define AO_SCTRL_SC_PW_RSTEN0     0x810
+#define AO_SCTRL_SC_PW_RSTDIS0    0x814
+
+#define AO_SCTRL_SC_PW_ISOEN0     0x820
+#define AO_SCTRL_SC_PW_ISODIS0    0x824
+#define AO_MAX_INDEX              12
+
+static int hi6220_ao_assert(struct reset_controller_dev *rc_dev,
+			       unsigned long idx)
+{
+	struct hi6220_reset_data *data = to_reset_data(rc_dev);
+	struct regmap *regmap = data->regmap;
+	int ret;
+
+	ret = regmap_write(regmap, AO_SCTRL_SC_PW_RSTEN0, BIT(idx));
+	if (ret)
+		return ret;
+
+	ret = regmap_write(regmap, AO_SCTRL_SC_PW_ISOEN0, BIT(idx));
+	if (ret)
+		return ret;
+
+	ret = regmap_write(regmap, AO_SCTRL_SC_PW_CLKDIS0, BIT(idx));
+	return ret;
+}
+
+static int hi6220_ao_deassert(struct reset_controller_dev *rc_dev,
+				 unsigned long idx)
+{
+	struct hi6220_reset_data *data = to_reset_data(rc_dev);
+	struct regmap *regmap = data->regmap;
+	int ret;
+
+	/*
+	 * It was suggested to disable isolation before enabling
+	 * the clocks and deasserting reset, to avoid glitches.
+	 * But this order is preserved to keep it matching the
+	 * vendor code.
+	 */
+	ret = regmap_write(regmap, AO_SCTRL_SC_PW_RSTDIS0, BIT(idx));
+	if (ret)
+		return ret;
+
+	ret = regmap_write(regmap, AO_SCTRL_SC_PW_ISODIS0, BIT(idx));
+	if (ret)
+		return ret;
+
+	ret = regmap_write(regmap, AO_SCTRL_SC_PW_CLKEN0, BIT(idx));
+	return ret;
+}
+
+static const struct reset_control_ops hi6220_ao_reset_ops = {
+	.assert = hi6220_ao_assert,
+	.deassert = hi6220_ao_deassert,
+};
+
 static int hi6220_reset_probe(struct platform_device *pdev)
 {
 	struct device_node *np = pdev->dev.of_node;
@@ -117,9 +177,12 @@ static int hi6220_reset_probe(struct platform_device *pdev)
 	if (type == MEDIA) {
 		data->rc_dev.ops = &hi6220_media_reset_ops;
 		data->rc_dev.nr_resets = MEDIA_MAX_INDEX;
-	} else {
+	} else if (type == PERIPHERAL) {
 		data->rc_dev.ops = &hi6220_peripheral_reset_ops;
 		data->rc_dev.nr_resets = PERIPH_MAX_INDEX;
+	} else {
+		data->rc_dev.ops = &hi6220_ao_reset_ops;
+		data->rc_dev.nr_resets = AO_MAX_INDEX;
 	}
 
 	return reset_controller_register(&data->rc_dev);
@@ -134,6 +197,10 @@ static const struct of_device_id hi6220_reset_match[] = {
 		.compatible = "hisilicon,hi6220-mediactrl",
 		.data = (void *)MEDIA,
 	},
+	{
+		.compatible = "hisilicon,hi6220-aoctrl",
+		.data = (void *)AO,
+	},
 	{ /* sentinel */ },
 };
 MODULE_DEVICE_TABLE(of, hi6220_reset_match);

commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/reset/hisilicon/hi6220_reset.c b/drivers/reset/hisilicon/hi6220_reset.c
index d5e5229308f2..24e6d420b26b 100644
--- a/drivers/reset/hisilicon/hi6220_reset.c
+++ b/drivers/reset/hisilicon/hi6220_reset.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Hisilicon Hi6220 reset controller driver
  *
@@ -5,10 +6,6 @@
  * Copyright (c) 2015-2016 Hisilicon Limited.
  *
  * Author: Feng Chen <puck.chen@hisilicon.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
  */
 
 #include <linux/io.h>

commit 4497a224f759cd8350e07382307b55f870ef0df2
Author: Jeremy Linton <lintonrjeremy@gmail.com>
Date:   Sat Apr 8 02:18:40 2017 -0500

    reset: hi6220: Set module license so that it can be loaded
    
    The hi6220_reset driver can be built as a standalone module
    yet it cannot be loaded because it depends on GPL exported symbols.
    
    Lets set the module license so that the module loads, and things like
    the on-board kirin drm starts working.
    
    Signed-off-by: Jeremy Linton <lintonrjeremy@gmail.com>
    Reviewed-by: Xinliang Liu <xinliang.liu@linaro.org>
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/drivers/reset/hisilicon/hi6220_reset.c b/drivers/reset/hisilicon/hi6220_reset.c
index 35ce53edabf9..d5e5229308f2 100644
--- a/drivers/reset/hisilicon/hi6220_reset.c
+++ b/drivers/reset/hisilicon/hi6220_reset.c
@@ -155,3 +155,5 @@ static int __init hi6220_reset_init(void)
 }
 
 postcore_initcall(hi6220_reset_init);
+
+MODULE_LICENSE("GPL v2");

commit ab52b599c197b5e50ad918f8084673d9b4caed83
Author: Xinliang Liu <xinliang.liu@linaro.org>
Date:   Mon Jun 20 11:50:07 2016 +0800

    reset: hisilicon: Add hi6220 media subsystem reset support
    
    Add hi6220 media subsystem reset controller.
    
    Signed-off-by: Chen Feng <puck.chen@hisilicon.com>
    Signed-off-by: Xia Qing <saberlily.xia@hisilicon.com>
    Signed-off-by: Xinliang Liu <xinliang.liu@linaro.org>
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/drivers/reset/hisilicon/hi6220_reset.c b/drivers/reset/hisilicon/hi6220_reset.c
index 686fea9e2c54..35ce53edabf9 100644
--- a/drivers/reset/hisilicon/hi6220_reset.c
+++ b/drivers/reset/hisilicon/hi6220_reset.c
@@ -27,8 +27,17 @@
 #define PERIPH_DEASSERT_OFFSET    0x304
 #define PERIPH_MAX_INDEX          0x509
 
+#define SC_MEDIA_RSTEN            0x052C
+#define SC_MEDIA_RSTDIS           0x0530
+#define MEDIA_MAX_INDEX           8
+
 #define to_reset_data(x) container_of(x, struct hi6220_reset_data, rc_dev)
 
+enum hi6220_reset_ctrl_type {
+	PERIPHERAL,
+	MEDIA,
+};
+
 struct hi6220_reset_data {
 	struct reset_controller_dev rc_dev;
 	struct regmap *regmap;
@@ -63,10 +72,34 @@ static const struct reset_control_ops hi6220_peripheral_reset_ops = {
 	.deassert = hi6220_peripheral_deassert,
 };
 
+static int hi6220_media_assert(struct reset_controller_dev *rc_dev,
+			       unsigned long idx)
+{
+	struct hi6220_reset_data *data = to_reset_data(rc_dev);
+	struct regmap *regmap = data->regmap;
+
+	return regmap_write(regmap, SC_MEDIA_RSTEN, BIT(idx));
+}
+
+static int hi6220_media_deassert(struct reset_controller_dev *rc_dev,
+				 unsigned long idx)
+{
+	struct hi6220_reset_data *data = to_reset_data(rc_dev);
+	struct regmap *regmap = data->regmap;
+
+	return regmap_write(regmap, SC_MEDIA_RSTDIS, BIT(idx));
+}
+
+static const struct reset_control_ops hi6220_media_reset_ops = {
+	.assert = hi6220_media_assert,
+	.deassert = hi6220_media_deassert,
+};
+
 static int hi6220_reset_probe(struct platform_device *pdev)
 {
 	struct device_node *np = pdev->dev.of_node;
 	struct device *dev = &pdev->dev;
+	enum hi6220_reset_ctrl_type type;
 	struct hi6220_reset_data *data;
 	struct regmap *regmap;
 
@@ -74,6 +107,8 @@ static int hi6220_reset_probe(struct platform_device *pdev)
 	if (!data)
 		return -ENOMEM;
 
+	type = (enum hi6220_reset_ctrl_type)of_device_get_match_data(dev);
+
 	regmap = syscon_node_to_regmap(np);
 	if (IS_ERR(regmap)) {
 		dev_err(dev, "failed to get reset controller regmap\n");
@@ -82,8 +117,13 @@ static int hi6220_reset_probe(struct platform_device *pdev)
 
 	data->regmap = regmap;
 	data->rc_dev.of_node = np;
-	data->rc_dev.ops = &hi6220_peripheral_reset_ops;
-	data->rc_dev.nr_resets = PERIPH_MAX_INDEX;
+	if (type == MEDIA) {
+		data->rc_dev.ops = &hi6220_media_reset_ops;
+		data->rc_dev.nr_resets = MEDIA_MAX_INDEX;
+	} else {
+		data->rc_dev.ops = &hi6220_peripheral_reset_ops;
+		data->rc_dev.nr_resets = PERIPH_MAX_INDEX;
+	}
 
 	return reset_controller_register(&data->rc_dev);
 }
@@ -91,6 +131,11 @@ static int hi6220_reset_probe(struct platform_device *pdev)
 static const struct of_device_id hi6220_reset_match[] = {
 	{
 		.compatible = "hisilicon,hi6220-sysctrl",
+		.data = (void *)PERIPHERAL,
+	},
+	{
+		.compatible = "hisilicon,hi6220-mediactrl",
+		.data = (void *)MEDIA,
 	},
 	{ /* sentinel */ },
 };

commit 8768a26cea4c54eb8d38bc063fbfba7c60c571f4
Author: Chen Feng <puck.chen@hisilicon.com>
Date:   Mon Jun 20 11:50:06 2016 +0800

    reset: hisilicon: Change to syscon register access
    
    There are two reset controllers in hi6220 SoC:
    The peripheral reset controller bits are part of sysctrl registers.
    The media reset controller bits are part of mediactrl registers.
    
    So change register access to syscon way.
    And rename current reset controller to peripheral one.
    
    Signed-off-by: Chen Feng <puck.chen@hisilicon.com>
    Signed-off-by: Xia Qing <saberlily.xia@hisilicon.com>
    Signed-off-by: Xinliang Liu <xinliang.liu@linaro.org>
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/drivers/reset/hisilicon/hi6220_reset.c b/drivers/reset/hisilicon/hi6220_reset.c
index 8f55fd4a2630..686fea9e2c54 100644
--- a/drivers/reset/hisilicon/hi6220_reset.c
+++ b/drivers/reset/hisilicon/hi6220_reset.c
@@ -1,7 +1,8 @@
 /*
  * Hisilicon Hi6220 reset controller driver
  *
- * Copyright (c) 2015 Hisilicon Limited.
+ * Copyright (c) 2016 Linaro Limited.
+ * Copyright (c) 2015-2016 Hisilicon Limited.
  *
  * Author: Feng Chen <puck.chen@hisilicon.com>
  *
@@ -15,81 +16,85 @@
 #include <linux/module.h>
 #include <linux/bitops.h>
 #include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/regmap.h>
+#include <linux/mfd/syscon.h>
 #include <linux/reset-controller.h>
 #include <linux/reset.h>
 #include <linux/platform_device.h>
 
-#define ASSERT_OFFSET            0x300
-#define DEASSERT_OFFSET          0x304
-#define MAX_INDEX                0x509
+#define PERIPH_ASSERT_OFFSET      0x300
+#define PERIPH_DEASSERT_OFFSET    0x304
+#define PERIPH_MAX_INDEX          0x509
 
 #define to_reset_data(x) container_of(x, struct hi6220_reset_data, rc_dev)
 
 struct hi6220_reset_data {
-	void __iomem			*assert_base;
-	void __iomem			*deassert_base;
-	struct reset_controller_dev	rc_dev;
+	struct reset_controller_dev rc_dev;
+	struct regmap *regmap;
 };
 
-static int hi6220_reset_assert(struct reset_controller_dev *rc_dev,
-			       unsigned long idx)
+static int hi6220_peripheral_assert(struct reset_controller_dev *rc_dev,
+				    unsigned long idx)
 {
 	struct hi6220_reset_data *data = to_reset_data(rc_dev);
+	struct regmap *regmap = data->regmap;
+	u32 bank = idx >> 8;
+	u32 offset = idx & 0xff;
+	u32 reg = PERIPH_ASSERT_OFFSET + bank * 0x10;
 
-	int bank = idx >> 8;
-	int offset = idx & 0xff;
-
-	writel(BIT(offset), data->assert_base + (bank * 0x10));
-
-	return 0;
+	return regmap_write(regmap, reg, BIT(offset));
 }
 
-static int hi6220_reset_deassert(struct reset_controller_dev *rc_dev,
-				 unsigned long idx)
+static int hi6220_peripheral_deassert(struct reset_controller_dev *rc_dev,
+				      unsigned long idx)
 {
 	struct hi6220_reset_data *data = to_reset_data(rc_dev);
+	struct regmap *regmap = data->regmap;
+	u32 bank = idx >> 8;
+	u32 offset = idx & 0xff;
+	u32 reg = PERIPH_DEASSERT_OFFSET + bank * 0x10;
 
-	int bank = idx >> 8;
-	int offset = idx & 0xff;
-
-	writel(BIT(offset), data->deassert_base + (bank * 0x10));
-
-	return 0;
+	return regmap_write(regmap, reg, BIT(offset));
 }
 
-static const struct reset_control_ops hi6220_reset_ops = {
-	.assert = hi6220_reset_assert,
-	.deassert = hi6220_reset_deassert,
+static const struct reset_control_ops hi6220_peripheral_reset_ops = {
+	.assert = hi6220_peripheral_assert,
+	.deassert = hi6220_peripheral_deassert,
 };
 
 static int hi6220_reset_probe(struct platform_device *pdev)
 {
+	struct device_node *np = pdev->dev.of_node;
+	struct device *dev = &pdev->dev;
 	struct hi6220_reset_data *data;
-	struct resource *res;
-	void __iomem *src_base;
+	struct regmap *regmap;
 
-	data = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);
+	data = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);
 	if (!data)
 		return -ENOMEM;
 
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	src_base = devm_ioremap_resource(&pdev->dev, res);
-	if (IS_ERR(src_base))
-		return PTR_ERR(src_base);
+	regmap = syscon_node_to_regmap(np);
+	if (IS_ERR(regmap)) {
+		dev_err(dev, "failed to get reset controller regmap\n");
+		return PTR_ERR(regmap);
+	}
 
-	data->assert_base = src_base + ASSERT_OFFSET;
-	data->deassert_base = src_base + DEASSERT_OFFSET;
-	data->rc_dev.nr_resets = MAX_INDEX;
-	data->rc_dev.ops = &hi6220_reset_ops;
-	data->rc_dev.of_node = pdev->dev.of_node;
+	data->regmap = regmap;
+	data->rc_dev.of_node = np;
+	data->rc_dev.ops = &hi6220_peripheral_reset_ops;
+	data->rc_dev.nr_resets = PERIPH_MAX_INDEX;
 
 	return reset_controller_register(&data->rc_dev);
 }
 
 static const struct of_device_id hi6220_reset_match[] = {
-	{ .compatible = "hisilicon,hi6220-sysctrl" },
-	{ },
+	{
+		.compatible = "hisilicon,hi6220-sysctrl",
+	},
+	{ /* sentinel */ },
 };
+MODULE_DEVICE_TABLE(of, hi6220_reset_match);
 
 static struct platform_driver hi6220_reset_driver = {
 	.probe = hi6220_reset_probe,

commit 0e18e60e1bded4b3c8c0eb29ac297ff7336ba5c7
Author: Philipp Zabel <p.zabel@pengutronix.de>
Date:   Sun Jan 17 15:11:59 2016 +0100

    reset: hi6220: Make reset_control_ops const
    
    The hi6220_reset_ops structure is never modified. Make it const.
    
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/drivers/reset/hisilicon/hi6220_reset.c b/drivers/reset/hisilicon/hi6220_reset.c
index 744b2e796442..8f55fd4a2630 100644
--- a/drivers/reset/hisilicon/hi6220_reset.c
+++ b/drivers/reset/hisilicon/hi6220_reset.c
@@ -57,7 +57,7 @@ static int hi6220_reset_deassert(struct reset_controller_dev *rc_dev,
 	return 0;
 }
 
-static struct reset_control_ops hi6220_reset_ops = {
+static const struct reset_control_ops hi6220_reset_ops = {
 	.assert = hi6220_reset_assert,
 	.deassert = hi6220_reset_deassert,
 };

commit c41ef91f65ea6151969dde699b206794772d407b
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Sun Jan 24 01:19:57 2016 +0900

    reset: hisilicon: check return value of reset_controller_register()
    
    The newly added hisilicon reset driver missed the subsystem-wide
    fixup by commit d1f15aa09558 ("reset: check return value of
    reset_controller_register()").  So fix it now.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/drivers/reset/hisilicon/hi6220_reset.c b/drivers/reset/hisilicon/hi6220_reset.c
index 7787a9b1cc67..744b2e796442 100644
--- a/drivers/reset/hisilicon/hi6220_reset.c
+++ b/drivers/reset/hisilicon/hi6220_reset.c
@@ -83,9 +83,7 @@ static int hi6220_reset_probe(struct platform_device *pdev)
 	data->rc_dev.ops = &hi6220_reset_ops;
 	data->rc_dev.of_node = pdev->dev.of_node;
 
-	reset_controller_register(&data->rc_dev);
-
-	return 0;
+	return reset_controller_register(&data->rc_dev);
 }
 
 static const struct of_device_id hi6220_reset_match[] = {

commit 70b3590f639f4e753e6f556209cb89b812879402
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Sat Dec 12 08:53:21 2015 +0100

    reset: hi6220: fix modular build
    
    We need to include <linux/module.h> to build the driver as a loadable
    module:
    
    drivers/reset/hisilicon/hi6220_reset.c:108:1: warning: data definition has no type or storage class
     postcore_initcall(hi6220_reset_init);
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/drivers/reset/hisilicon/hi6220_reset.c b/drivers/reset/hisilicon/hi6220_reset.c
index d17c910e8b63..7787a9b1cc67 100644
--- a/drivers/reset/hisilicon/hi6220_reset.c
+++ b/drivers/reset/hisilicon/hi6220_reset.c
@@ -12,6 +12,7 @@
 
 #include <linux/io.h>
 #include <linux/init.h>
+#include <linux/module.h>
 #include <linux/bitops.h>
 #include <linux/of.h>
 #include <linux/reset-controller.h>

commit f59d23c2c0eb23194ffc16f640dfac4da938b6ac
Author: Chen Feng <puck.chen@hisilicon.com>
Date:   Fri Nov 20 10:10:05 2015 +0800

    reset: hi6220: Reset driver for hisilicon hi6220 SoC
    
    Add reset driver for hi6220-hikey board,this driver supply deassert
    of IP on hi6220 SoC.
    
    Signed-off-by: Chen Feng <puck.chen@hisilicon.com>
    Signed-off-by: Philipp Zabel <p.zabel@pengutronix.de>

diff --git a/drivers/reset/hisilicon/hi6220_reset.c b/drivers/reset/hisilicon/hi6220_reset.c
new file mode 100644
index 000000000000..d17c910e8b63
--- /dev/null
+++ b/drivers/reset/hisilicon/hi6220_reset.c
@@ -0,0 +1,108 @@
+/*
+ * Hisilicon Hi6220 reset controller driver
+ *
+ * Copyright (c) 2015 Hisilicon Limited.
+ *
+ * Author: Feng Chen <puck.chen@hisilicon.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/io.h>
+#include <linux/init.h>
+#include <linux/bitops.h>
+#include <linux/of.h>
+#include <linux/reset-controller.h>
+#include <linux/reset.h>
+#include <linux/platform_device.h>
+
+#define ASSERT_OFFSET            0x300
+#define DEASSERT_OFFSET          0x304
+#define MAX_INDEX                0x509
+
+#define to_reset_data(x) container_of(x, struct hi6220_reset_data, rc_dev)
+
+struct hi6220_reset_data {
+	void __iomem			*assert_base;
+	void __iomem			*deassert_base;
+	struct reset_controller_dev	rc_dev;
+};
+
+static int hi6220_reset_assert(struct reset_controller_dev *rc_dev,
+			       unsigned long idx)
+{
+	struct hi6220_reset_data *data = to_reset_data(rc_dev);
+
+	int bank = idx >> 8;
+	int offset = idx & 0xff;
+
+	writel(BIT(offset), data->assert_base + (bank * 0x10));
+
+	return 0;
+}
+
+static int hi6220_reset_deassert(struct reset_controller_dev *rc_dev,
+				 unsigned long idx)
+{
+	struct hi6220_reset_data *data = to_reset_data(rc_dev);
+
+	int bank = idx >> 8;
+	int offset = idx & 0xff;
+
+	writel(BIT(offset), data->deassert_base + (bank * 0x10));
+
+	return 0;
+}
+
+static struct reset_control_ops hi6220_reset_ops = {
+	.assert = hi6220_reset_assert,
+	.deassert = hi6220_reset_deassert,
+};
+
+static int hi6220_reset_probe(struct platform_device *pdev)
+{
+	struct hi6220_reset_data *data;
+	struct resource *res;
+	void __iomem *src_base;
+
+	data = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	src_base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(src_base))
+		return PTR_ERR(src_base);
+
+	data->assert_base = src_base + ASSERT_OFFSET;
+	data->deassert_base = src_base + DEASSERT_OFFSET;
+	data->rc_dev.nr_resets = MAX_INDEX;
+	data->rc_dev.ops = &hi6220_reset_ops;
+	data->rc_dev.of_node = pdev->dev.of_node;
+
+	reset_controller_register(&data->rc_dev);
+
+	return 0;
+}
+
+static const struct of_device_id hi6220_reset_match[] = {
+	{ .compatible = "hisilicon,hi6220-sysctrl" },
+	{ },
+};
+
+static struct platform_driver hi6220_reset_driver = {
+	.probe = hi6220_reset_probe,
+	.driver = {
+		.name = "reset-hi6220",
+		.of_match_table = hi6220_reset_match,
+	},
+};
+
+static int __init hi6220_reset_init(void)
+{
+	return platform_driver_register(&hi6220_reset_driver);
+}
+
+postcore_initcall(hi6220_reset_init);
