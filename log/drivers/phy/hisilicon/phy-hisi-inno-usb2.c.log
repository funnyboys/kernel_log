commit fa093440142d3d25d619580373bb40e9653a203a
Author: YueHaibing <yuehaibing@huawei.com>
Date:   Wed Oct 16 21:57:35 2019 +0800

    phy: hisilicon: use devm_platform_ioremap_resource() to simplify code
    
    Use devm_platform_ioremap_resource() to simplify the code a bit.
    This is detected by coccinelle.
    
    Signed-off-by: YueHaibing <yuehaibing@huawei.com>
    Signed-off-by: Kishon Vijay Abraham I <kishon@ti.com>

diff --git a/drivers/phy/hisilicon/phy-hisi-inno-usb2.c b/drivers/phy/hisilicon/phy-hisi-inno-usb2.c
index 9b16f13b5ab2..34a6a9a1ceb2 100644
--- a/drivers/phy/hisilicon/phy-hisi-inno-usb2.c
+++ b/drivers/phy/hisilicon/phy-hisi-inno-usb2.c
@@ -114,7 +114,6 @@ static int hisi_inno_phy_probe(struct platform_device *pdev)
 	struct hisi_inno_phy_priv *priv;
 	struct phy_provider *provider;
 	struct device_node *child;
-	struct resource *res;
 	int i = 0;
 	int ret;
 
@@ -122,8 +121,7 @@ static int hisi_inno_phy_probe(struct platform_device *pdev)
 	if (!priv)
 		return -ENOMEM;
 
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	priv->mmio = devm_ioremap_resource(dev, res);
+	priv->mmio = devm_platform_ioremap_resource(pdev, 0);
 	if (IS_ERR(priv->mmio)) {
 		ret = PTR_ERR(priv->mmio);
 		return ret;

commit 1ccea77e2a2687cae171b7987eb44730ec8c6d5f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 15:51:43 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 13
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not see http www gnu org licenses
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details [based]
      [from] [clk] [highbank] [c] you should have received a copy of the
      gnu general public license along with this program if not see http
      www gnu org licenses
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 355 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Jilayne Lovejoy <opensource@jilayne.com>
    Reviewed-by: Steve Winslow <swinslow@gmail.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190519154041.837383322@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/phy/hisilicon/phy-hisi-inno-usb2.c b/drivers/phy/hisilicon/phy-hisi-inno-usb2.c
index 524381249a2b..9b16f13b5ab2 100644
--- a/drivers/phy/hisilicon/phy-hisi-inno-usb2.c
+++ b/drivers/phy/hisilicon/phy-hisi-inno-usb2.c
@@ -1,20 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * HiSilicon INNO USB2 PHY Driver.
  *
  * Copyright (c) 2016-2017 HiSilicon Technologies Co., Ltd.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program. If not, see <http://www.gnu.org/licenses/>.
  */
 
 #include <linux/clk.h>

commit ba8b0ee81fbbc249e60f84bf097bd56e8047c742
Author: Pengcheng Li <lpc.li@hisilicon.com>
Date:   Fri Mar 9 22:47:01 2018 +0800

    phy: add inno-usb2-phy driver for hi3798cv200 SoC
    
    It adds inno-usb2-phy driver for hi3798cv200 SoC USB 2.0 support.  One
    inno-usb2-phy device can support up to two PHY ports.  While there is
    device level reference clock and power reset to be controlled, each PHY
    port has its own utmi reset that needs to assert/de-assert as needed.
    
    Hi3798cv200 needs to access PHY port0 register via particular peripheral
    syscon controller register to control PHY, like turning on PHY clock.
    
    Signed-off-by: Pengcheng Li <lpc.li@hisilicon.com>
    Signed-off-by: Jiancheng Xue <xuejiancheng@hisilicon.com>
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
    Signed-off-by: Kishon Vijay Abraham I <kishon@ti.com>

diff --git a/drivers/phy/hisilicon/phy-hisi-inno-usb2.c b/drivers/phy/hisilicon/phy-hisi-inno-usb2.c
new file mode 100644
index 000000000000..524381249a2b
--- /dev/null
+++ b/drivers/phy/hisilicon/phy-hisi-inno-usb2.c
@@ -0,0 +1,197 @@
+/*
+ * HiSilicon INNO USB2 PHY Driver.
+ *
+ * Copyright (c) 2016-2017 HiSilicon Technologies Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/phy/phy.h>
+#include <linux/reset.h>
+
+#define INNO_PHY_PORT_NUM	2
+#define REF_CLK_STABLE_TIME	100	/* unit:us */
+#define UTMI_CLK_STABLE_TIME	200	/* unit:us */
+#define TEST_CLK_STABLE_TIME	2	/* unit:ms */
+#define PHY_CLK_STABLE_TIME	2	/* unit:ms */
+#define UTMI_RST_COMPLETE_TIME	2	/* unit:ms */
+#define POR_RST_COMPLETE_TIME	300	/* unit:us */
+#define PHY_TEST_DATA		GENMASK(7, 0)
+#define PHY_TEST_ADDR		GENMASK(15, 8)
+#define PHY_TEST_PORT		GENMASK(18, 16)
+#define PHY_TEST_WREN		BIT(21)
+#define PHY_TEST_CLK		BIT(22)	/* rising edge active */
+#define PHY_TEST_RST		BIT(23)	/* low active */
+#define PHY_CLK_ENABLE		BIT(2)
+
+struct hisi_inno_phy_port {
+	struct reset_control *utmi_rst;
+	struct hisi_inno_phy_priv *priv;
+};
+
+struct hisi_inno_phy_priv {
+	void __iomem *mmio;
+	struct clk *ref_clk;
+	struct reset_control *por_rst;
+	struct hisi_inno_phy_port ports[INNO_PHY_PORT_NUM];
+};
+
+static void hisi_inno_phy_write_reg(struct hisi_inno_phy_priv *priv,
+				    u8 port, u32 addr, u32 data)
+{
+	void __iomem *reg = priv->mmio;
+	u32 val;
+
+	val = (data & PHY_TEST_DATA) |
+	      ((addr << 8) & PHY_TEST_ADDR) |
+	      ((port << 16) & PHY_TEST_PORT) |
+	      PHY_TEST_WREN | PHY_TEST_RST;
+	writel(val, reg);
+
+	val |= PHY_TEST_CLK;
+	writel(val, reg);
+
+	val &= ~PHY_TEST_CLK;
+	writel(val, reg);
+}
+
+static void hisi_inno_phy_setup(struct hisi_inno_phy_priv *priv)
+{
+	/* The phy clk is controlled by the port0 register 0x06. */
+	hisi_inno_phy_write_reg(priv, 0, 0x06, PHY_CLK_ENABLE);
+	msleep(PHY_CLK_STABLE_TIME);
+}
+
+static int hisi_inno_phy_init(struct phy *phy)
+{
+	struct hisi_inno_phy_port *port = phy_get_drvdata(phy);
+	struct hisi_inno_phy_priv *priv = port->priv;
+	int ret;
+
+	ret = clk_prepare_enable(priv->ref_clk);
+	if (ret)
+		return ret;
+	udelay(REF_CLK_STABLE_TIME);
+
+	reset_control_deassert(priv->por_rst);
+	udelay(POR_RST_COMPLETE_TIME);
+
+	/* Set up phy registers */
+	hisi_inno_phy_setup(priv);
+
+	reset_control_deassert(port->utmi_rst);
+	udelay(UTMI_RST_COMPLETE_TIME);
+
+	return 0;
+}
+
+static int hisi_inno_phy_exit(struct phy *phy)
+{
+	struct hisi_inno_phy_port *port = phy_get_drvdata(phy);
+	struct hisi_inno_phy_priv *priv = port->priv;
+
+	reset_control_assert(port->utmi_rst);
+	reset_control_assert(priv->por_rst);
+	clk_disable_unprepare(priv->ref_clk);
+
+	return 0;
+}
+
+static const struct phy_ops hisi_inno_phy_ops = {
+	.init = hisi_inno_phy_init,
+	.exit = hisi_inno_phy_exit,
+	.owner = THIS_MODULE,
+};
+
+static int hisi_inno_phy_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node;
+	struct hisi_inno_phy_priv *priv;
+	struct phy_provider *provider;
+	struct device_node *child;
+	struct resource *res;
+	int i = 0;
+	int ret;
+
+	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	priv->mmio = devm_ioremap_resource(dev, res);
+	if (IS_ERR(priv->mmio)) {
+		ret = PTR_ERR(priv->mmio);
+		return ret;
+	}
+
+	priv->ref_clk = devm_clk_get(dev, NULL);
+	if (IS_ERR(priv->ref_clk))
+		return PTR_ERR(priv->ref_clk);
+
+	priv->por_rst = devm_reset_control_get_exclusive(dev, NULL);
+	if (IS_ERR(priv->por_rst))
+		return PTR_ERR(priv->por_rst);
+
+	for_each_child_of_node(np, child) {
+		struct reset_control *rst;
+		struct phy *phy;
+
+		rst = of_reset_control_get_exclusive(child, NULL);
+		if (IS_ERR(rst))
+			return PTR_ERR(rst);
+		priv->ports[i].utmi_rst = rst;
+		priv->ports[i].priv = priv;
+
+		phy = devm_phy_create(dev, child, &hisi_inno_phy_ops);
+		if (IS_ERR(phy))
+			return PTR_ERR(phy);
+
+		phy_set_bus_width(phy, 8);
+		phy_set_drvdata(phy, &priv->ports[i]);
+		i++;
+
+		if (i > INNO_PHY_PORT_NUM) {
+			dev_warn(dev, "Support %d ports in maximum\n", i);
+			break;
+		}
+	}
+
+	provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);
+	return PTR_ERR_OR_ZERO(provider);
+}
+
+static const struct of_device_id hisi_inno_phy_of_match[] = {
+	{ .compatible = "hisilicon,inno-usb2-phy", },
+	{ .compatible = "hisilicon,hi3798cv200-usb2-phy", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, hisi_inno_phy_of_match);
+
+static struct platform_driver hisi_inno_phy_driver = {
+	.probe	= hisi_inno_phy_probe,
+	.driver = {
+		.name	= "hisi-inno-phy",
+		.of_match_table	= hisi_inno_phy_of_match,
+	}
+};
+module_platform_driver(hisi_inno_phy_driver);
+
+MODULE_DESCRIPTION("HiSilicon INNO USB2 PHY Driver");
+MODULE_LICENSE("GPL v2");
