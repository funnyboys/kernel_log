commit a082121b55bac125f7d09d78de00607ea75a6903
Author: Jordan Crouse <jcrouse@codeaurora.org>
Date:   Thu Jun 4 14:39:04 2020 -0600

    iommu/arm-smmu: Mark qcom_smmu_client_of_match as possibly unused
    
    When CONFIG_OF=n of_match_device() gets pre-processed out of existence
    leaving qcom-smmu_client_of_match unused. Mark it as possibly unused to
    keep the compiler from warning in that case.
    
    Fixes: 0e764a01015d ("iommu/arm-smmu: Allow client devices to select direct mapping")
    Reported-by: kbuild test robot <lkp@intel.com>
    Signed-off-by: Jordan Crouse <jcrouse@codeaurora.org>
    Acked-by: Will Deacon <will@kernel.org>
    Link: https://lore.kernel.org/r/20200604203905.31964-1-jcrouse@codeaurora.org
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/drivers/iommu/arm-smmu-qcom.c b/drivers/iommu/arm-smmu-qcom.c
index cf01d0215a39..be4318044f96 100644
--- a/drivers/iommu/arm-smmu-qcom.c
+++ b/drivers/iommu/arm-smmu-qcom.c
@@ -12,7 +12,7 @@ struct qcom_smmu {
 	struct arm_smmu_device smmu;
 };
 
-static const struct of_device_id qcom_smmu_client_of_match[] = {
+static const struct of_device_id qcom_smmu_client_of_match[] __maybe_unused = {
 	{ .compatible = "qcom,adreno" },
 	{ .compatible = "qcom,mdp4" },
 	{ .compatible = "qcom,mdss" },

commit d100ff3843b731c5c0c974bc9210cf092a7ec9b6
Author: Sibi Sankar <sibis@codeaurora.org>
Date:   Mon May 11 23:25:32 2020 +0530

    iommu/arm-smmu-qcom: Request direct mapping for modem device
    
    The modem remote processor has two access paths to DDR. One path is
    directly connected to DDR and another path goes through an SMMU. The
    SMMU path is configured to be a direct mapping because it's used by
    various peripherals in the modem subsystem. Typically this direct
    mapping is configured statically at EL2 by QHEE (Qualcomm's Hypervisor
    Execution Environment) before the kernel is entered.
    
    In certain firmware configuration, especially when the kernel is already
    in full control of the SMMU, defer programming the modem SIDs to the
    kernel. Let's add compatibles here so that we can have the kernel
    program the SIDs for the modem in these cases.
    
    Signed-off-by: Sibi Sankar <sibis@codeaurora.org>
    Reviewed-by: Bjorn Andersson <bjorn.andersson@linaro.org>
    Reviewed-by: Stephen Boyd <swboyd@chromium.org>
    Link: https://lore.kernel.org/r/20200511175532.25874-1-sibis@codeaurora.org
    Signed-off-by: Will Deacon <will@kernel.org>

diff --git a/drivers/iommu/arm-smmu-qcom.c b/drivers/iommu/arm-smmu-qcom.c
index 5bedf21587a5..cf01d0215a39 100644
--- a/drivers/iommu/arm-smmu-qcom.c
+++ b/drivers/iommu/arm-smmu-qcom.c
@@ -17,7 +17,9 @@ static const struct of_device_id qcom_smmu_client_of_match[] = {
 	{ .compatible = "qcom,mdp4" },
 	{ .compatible = "qcom,mdss" },
 	{ .compatible = "qcom,sc7180-mdss" },
+	{ .compatible = "qcom,sc7180-mss-pil" },
 	{ .compatible = "qcom,sdm845-mdss" },
+	{ .compatible = "qcom,sdm845-mss-pil" },
 	{ }
 };
 

commit 0e764a01015dfebff8a8ffd297d74663772e248a
Author: Jordan Crouse <jcrouse@codeaurora.org>
Date:   Tue Apr 21 00:03:51 2020 +0530

    iommu/arm-smmu: Allow client devices to select direct mapping
    
    Some client devices want to directly map the IOMMU themselves instead
    of using the DMA domain. Allow those devices to opt in to direct
    mapping by way of a list of compatible strings.
    
    Co-developed-by: Sai Prakash Ranjan <saiprakash.ranjan@codeaurora.org>
    Signed-off-by: Jordan Crouse <jcrouse@codeaurora.org>
    Signed-off-by: Sai Prakash Ranjan <saiprakash.ranjan@codeaurora.org>
    Reviewed-by: Robin Murphy <robin.murphy@arm.com>
    Link: https://lore.kernel.org/r/7cf1f64167b5545b7f42275395be1f1e2ea3a6ac.1587407458.git.saiprakash.ranjan@codeaurora.org
    Signed-off-by: Will Deacon <will@kernel.org>

diff --git a/drivers/iommu/arm-smmu-qcom.c b/drivers/iommu/arm-smmu-qcom.c
index 64a4ab270ab7..5bedf21587a5 100644
--- a/drivers/iommu/arm-smmu-qcom.c
+++ b/drivers/iommu/arm-smmu-qcom.c
@@ -3,6 +3,7 @@
  * Copyright (c) 2019, The Linux Foundation. All rights reserved.
  */
 
+#include <linux/of_device.h>
 #include <linux/qcom_scm.h>
 
 #include "arm-smmu.h"
@@ -11,6 +12,23 @@ struct qcom_smmu {
 	struct arm_smmu_device smmu;
 };
 
+static const struct of_device_id qcom_smmu_client_of_match[] = {
+	{ .compatible = "qcom,adreno" },
+	{ .compatible = "qcom,mdp4" },
+	{ .compatible = "qcom,mdss" },
+	{ .compatible = "qcom,sc7180-mdss" },
+	{ .compatible = "qcom,sdm845-mdss" },
+	{ }
+};
+
+static int qcom_smmu_def_domain_type(struct device *dev)
+{
+	const struct of_device_id *match =
+		of_match_device(qcom_smmu_client_of_match, dev);
+
+	return match ? IOMMU_DOMAIN_IDENTITY : 0;
+}
+
 static int qcom_sdm845_smmu500_reset(struct arm_smmu_device *smmu)
 {
 	int ret;
@@ -41,6 +59,7 @@ static int qcom_smmu500_reset(struct arm_smmu_device *smmu)
 }
 
 static const struct arm_smmu_impl qcom_smmu_impl = {
+	.def_domain_type = qcom_smmu_def_domain_type,
 	.reset = qcom_smmu500_reset,
 };
 

commit 64510ede36845500584485f3ad30dbcbf83091a6
Author: Sai Prakash Ranjan <saiprakash.ranjan@codeaurora.org>
Date:   Tue Apr 21 00:03:49 2020 +0530

    iommu: arm-smmu-impl: Convert to a generic reset implementation
    
    Currently the QCOM specific smmu reset implementation is very
    specific to SDM845 SoC and has a wait-for-safe logic which
    may not be required for other SoCs. So move the SDM845 specific
    logic to its specific reset function. Also add SC7180 SMMU
    compatible for calling into QCOM specific implementation.
    
    Signed-off-by: Sai Prakash Ranjan <saiprakash.ranjan@codeaurora.org>
    Reviewed-by: Bjorn Andersson <bjorn.andersson@linaro.org>
    Reviewed-by: Stephen Boyd <swboyd@chromium.org>
    Reviewed-by: Robin Murphy <robin.murphy@arm.com>
    Link: https://lore.kernel.org/r/d24a0278021bc0b2732636c5728efe55e7318a8b.1587407458.git.saiprakash.ranjan@codeaurora.org
    Signed-off-by: Will Deacon <will@kernel.org>

diff --git a/drivers/iommu/arm-smmu-qcom.c b/drivers/iommu/arm-smmu-qcom.c
index 24c071c1d8b0..64a4ab270ab7 100644
--- a/drivers/iommu/arm-smmu-qcom.c
+++ b/drivers/iommu/arm-smmu-qcom.c
@@ -15,8 +15,6 @@ static int qcom_sdm845_smmu500_reset(struct arm_smmu_device *smmu)
 {
 	int ret;
 
-	arm_mmu500_reset(smmu);
-
 	/*
 	 * To address performance degradation in non-real time clients,
 	 * such as USB and UFS, turn off wait-for-safe on sdm845 based boards,
@@ -30,8 +28,20 @@ static int qcom_sdm845_smmu500_reset(struct arm_smmu_device *smmu)
 	return ret;
 }
 
+static int qcom_smmu500_reset(struct arm_smmu_device *smmu)
+{
+	const struct device_node *np = smmu->dev->of_node;
+
+	arm_mmu500_reset(smmu);
+
+	if (of_device_is_compatible(np, "qcom,sdm845-smmu-500"))
+		return qcom_sdm845_smmu500_reset(smmu);
+
+	return 0;
+}
+
 static const struct arm_smmu_impl qcom_smmu_impl = {
-	.reset = qcom_sdm845_smmu500_reset,
+	.reset = qcom_smmu500_reset,
 };
 
 struct arm_smmu_device *qcom_smmu_impl_init(struct arm_smmu_device *smmu)

commit 759aaa10c76cbaaefc0670410fb2d54cf4ec10cc
Author: Vivek Gautam <vivek.gautam@codeaurora.org>
Date:   Fri Sep 20 13:34:29 2019 +0530

    iommu: arm-smmu-impl: Add sdm845 implementation hook
    
    Add reset hook for sdm845 based platforms to turn off
    the wait-for-safe sequence.
    
    Understanding how wait-for-safe logic affects USB and UFS performance
    on MTP845 and DB845 boards:
    
    Qcom's implementation of arm,mmu-500 adds a WAIT-FOR-SAFE logic
    to address under-performance issues in real-time clients, such as
    Display, and Camera.
    On receiving an invalidation requests, the SMMU forwards SAFE request
    to these clients and waits for SAFE ack signal from real-time clients.
    The SAFE signal from such clients is used to qualify the start of
    invalidation.
    This logic is controlled by chicken bits, one for each - MDP (display),
    IFE0, and IFE1 (camera), that can be accessed only from secure software
    on sdm845.
    
    This configuration, however, degrades the performance of non-real time
    clients, such as USB, and UFS etc. This happens because, with wait-for-safe
    logic enabled the hardware tries to throttle non-real time clients while
    waiting for SAFE ack signals from real-time clients.
    
    On mtp845 and db845 devices, with wait-for-safe logic enabled by the
    bootloaders we see degraded performance of USB and UFS when kernel
    enables the smmu stage-1 translations for these clients.
    Turn off this wait-for-safe logic from the kernel gets us back the perf
    of USB and UFS devices until we re-visit this when we start seeing perf
    issues on display/camera on upstream supported SDM845 platforms.
    The bootloaders on these boards implement secure monitor callbacks to
    handle a specific command - QCOM_SCM_SVC_SMMU_PROGRAM with which the
    logic can be toggled.
    
    There are other boards such as cheza whose bootloaders don't enable this
    logic. Such boards don't implement callbacks to handle the specific SCM
    call so disabling this logic for such boards will be a no-op.
    
    This change is inspired by the downstream change from Patrick Daly
    to address performance issues with display and camera by handling
    this wait-for-safe within separte io-pagetable ops to do TLB
    maintenance. So a big thanks to him for the change and for all the
    offline discussions.
    
    Without this change the UFS reads are pretty slow:
    $ time dd if=/dev/sda of=/dev/zero bs=1048576 count=10 conv=sync
    10+0 records in
    10+0 records out
    10485760 bytes (10.0MB) copied, 22.394903 seconds, 457.2KB/s
    real    0m 22.39s
    user    0m 0.00s
    sys     0m 0.01s
    
    With this change they are back to rock!
    $ time dd if=/dev/sda of=/dev/zero bs=1048576 count=300 conv=sync
    300+0 records in
    300+0 records out
    314572800 bytes (300.0MB) copied, 1.030541 seconds, 291.1MB/s
    real    0m 1.03s
    user    0m 0.00s
    sys     0m 0.54s
    
    Signed-off-by: Vivek Gautam <vivek.gautam@codeaurora.org>
    Reviewed-by: Robin Murphy <robin.murphy@arm.com>
    Reviewed-by: Stephen Boyd <swboyd@chromium.org>
    Reviewed-by: Bjorn Andersson <bjorn.andersson@linaro.org>
    Signed-off-by: Sai Prakash Ranjan <saiprakash.ranjan@codeaurora.org>
    Signed-off-by: Will Deacon <will@kernel.org>

diff --git a/drivers/iommu/arm-smmu-qcom.c b/drivers/iommu/arm-smmu-qcom.c
new file mode 100644
index 000000000000..24c071c1d8b0
--- /dev/null
+++ b/drivers/iommu/arm-smmu-qcom.c
@@ -0,0 +1,51 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (c) 2019, The Linux Foundation. All rights reserved.
+ */
+
+#include <linux/qcom_scm.h>
+
+#include "arm-smmu.h"
+
+struct qcom_smmu {
+	struct arm_smmu_device smmu;
+};
+
+static int qcom_sdm845_smmu500_reset(struct arm_smmu_device *smmu)
+{
+	int ret;
+
+	arm_mmu500_reset(smmu);
+
+	/*
+	 * To address performance degradation in non-real time clients,
+	 * such as USB and UFS, turn off wait-for-safe on sdm845 based boards,
+	 * such as MTP and db845, whose firmwares implement secure monitor
+	 * call handlers to turn on/off the wait-for-safe logic.
+	 */
+	ret = qcom_scm_qsmmu500_wait_safe_toggle(0);
+	if (ret)
+		dev_warn(smmu->dev, "Failed to turn off SAFE logic\n");
+
+	return ret;
+}
+
+static const struct arm_smmu_impl qcom_smmu_impl = {
+	.reset = qcom_sdm845_smmu500_reset,
+};
+
+struct arm_smmu_device *qcom_smmu_impl_init(struct arm_smmu_device *smmu)
+{
+	struct qcom_smmu *qsmmu;
+
+	qsmmu = devm_kzalloc(smmu->dev, sizeof(*qsmmu), GFP_KERNEL);
+	if (!qsmmu)
+		return ERR_PTR(-ENOMEM);
+
+	qsmmu->smmu = *smmu;
+
+	qsmmu->smmu.impl = &qcom_smmu_impl;
+	devm_kfree(smmu->dev, smmu);
+
+	return &qsmmu->smmu;
+}
