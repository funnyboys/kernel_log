commit 604629bcb5057d778839652f8f38d23734f2fe1d
Author: Tero Kristo <t-kristo@ti.com>
Date:   Wed Aug 7 11:26:51 2019 +0300

    iommu/omap: add support for late attachment of iommu devices
    
    Current implementation of OMAP IOMMU enforces strict ordering of device
    probe, initiated by iommu and followed by remoteproc later. This doesn't
    work too well with the new setup done with ti-sysc changes which may
    have the devices probed at pretty much any order. To overcome this limitation,
    if iommu has not been probed yet when a consumer tries to attach to it,
    add the device to orphan device list which will be parsed during iommu
    probe to see if any orphan devices should be attached.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/drivers/iommu/omap-iommu.h b/drivers/iommu/omap-iommu.h
index 1d15aa857634..18ee713ede78 100644
--- a/drivers/iommu/omap-iommu.h
+++ b/drivers/iommu/omap-iommu.h
@@ -87,7 +87,8 @@ struct omap_iommu {
 
 /**
  * struct omap_iommu_arch_data - omap iommu private data
- * @iommu_dev: handle of the iommu device
+ * @iommu_dev: handle of the OMAP iommu device
+ * @dev: handle of the iommu device
  *
  * This is an omap iommu private data object, which binds an iommu user
  * to its iommu device. This object should be placed at the iommu user's
@@ -96,6 +97,7 @@ struct omap_iommu {
  */
 struct omap_iommu_arch_data {
 	struct omap_iommu *iommu_dev;
+	struct device *dev;
 };
 
 struct cr_regs {

commit c3b44a063d3b4d9b5afabaf5ab2e3fc11518dc84
Author: Suman Anna <s-anna@ti.com>
Date:   Wed Aug 7 11:26:48 2019 +0300

    iommu/omap: add logic to save/restore locked TLBs
    
    The MMUs provide a mechanism to lock TLB entries to avoid
    eviction and fetching of frequently used page table entries.
    These TLBs lose context when the MMUs are turned OFF. Add the
    logic to save and restore these locked TLBS during suspend
    and resume respectively. There are no locked TLBs during
    initial power ON, and they need not be saved during final
    shutdown.
    
    Signed-off-by: Suman Anna <s-anna@ti.com>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/drivers/iommu/omap-iommu.h b/drivers/iommu/omap-iommu.h
index aac1ca65ef9d..1d15aa857634 100644
--- a/drivers/iommu/omap-iommu.h
+++ b/drivers/iommu/omap-iommu.h
@@ -73,6 +73,9 @@ struct omap_iommu {
 
 	void *ctx; /* iommu context: registres saved area */
 
+	struct cr_regs *cr_ctx;
+	u32 num_cr_ctx;
+
 	int has_bus_err_back;
 	u32 id;
 

commit 3846a3b9511c5166082a93536d919a9c42abcd91
Author: Suman Anna <s-anna@ti.com>
Date:   Wed Aug 7 11:26:45 2019 +0300

    iommu/omap: fix boot issue on remoteprocs with AMMU/Unicache
    
    Support has been added to the OMAP IOMMU driver to fix a boot hang
    issue on OMAP remoteprocs with AMMU/Unicache, caused by an improper
    AMMU/Unicache state upon initial deassertion of the processor reset.
    The issue is described in detail in the next three paragraphs.
    
    All the Cortex M3/M4 IPU processor subsystems in OMAP SoCs have a
    AMMU/Unicache IP that dictates the memory attributes for addresses
    seen by the processor cores. The AMMU/Unicache is configured/enabled
    by the SCACHE_CONFIG.BYPASS bit - a value of 1 enables the cache and
    mandates all addresses accessed by M3/M4 be defined in the AMMU. This
    bit is not programmable from the host processor. The M3/M4 boot
    sequence starts out with the AMMU/Unicache in disabled state, and
    SYS/BIOS programs the AMMU regions and enables the Unicache during
    one of its initial boot steps. This SCACHE_CONFIG.BYPASS bit is
    however enabled by default whenever a RET reset is applied to the IP,
    irrespective of whether it was previously enabled or not. The AMMU
    registers lose their context whenever this reset is applied. The reset
    is effective as long as the MMU portion of the subsystem is enabled
    and clocked. This behavior is common to all the IPU and DSP subsystems
    that have an AMMU/Unicache.
    
    The IPU boot sequence involves enabling and programming the MMU, and
    loading the processor and releasing the reset(s) for the processor.
    The PM setup code currently sets the target state for most of the
    power domains to RET. The L2 MMU can be enabled, programmed and
    accessed properly just fine with the domain in hardware supervised
    mode, while the power domain goes through a RET->ON->RET transition
    during the programming sequence. However, the ON->RET transition
    asserts a RET reset, and the SCACHE_CONFIG.BYPASS bit gets auto-set.
    An AMMU fault is thrown immediately when the M3/M4 core's reset is
    released since the first instruction address itself will not be
    defined in any valid AMMU regions. The ON->RET transition happens
    automatically on the power domain after enabling the iommu due to
    the hardware supervised mode.
    
    This patch adds and invokes the .set_pwrdm_constraint pdata ops, if
    present, during the OMAP IOMMU enable and disable functions to resolve
    the above boot hang issue. The ops will allow to invoke a mach-omap2
    layer API pwrdm_set_next_pwrst() in a multi-arch kernel environment.
    The ops also returns the current power domain state while enforcing
    the constraint so that the driver can store it and use it to set back
    the power domain state while releasing the constraint. The pdata ops
    implementation restricts the target power domain to ON during enable,
    and back to the original power domain state during disable, and thereby
    eliminating the conditions for the boot issue. The implementation is
    effective only when the original power domain state is either RET or
    OFF, and is a no-op when it is ON or INACTIVE.
    
    The .set_pwrdm_constraint ops need to be plugged in pdata-quirks
    for the affected remote processors to be able to boot properly.
    
    Note that the current issue is seen only on kernels with the affected
    power domains programmed to enter RET. For eg., IPU1 on DRA7xx is in a
    separate domain and is susceptible to this bug, while the IPU2 subsystem
    is within CORE power domain, and CORE RET is not supported on this SoC.
    IPUs on OMAP4 and OMAP5 are also susceptible since they are in CORE power
    domain, and CORE RET is a valid power target on these SoCs.
    
    Signed-off-by: Suman Anna <s-anna@ti.com>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/drivers/iommu/omap-iommu.h b/drivers/iommu/omap-iommu.h
index 09968a02d291..aac1ca65ef9d 100644
--- a/drivers/iommu/omap-iommu.h
+++ b/drivers/iommu/omap-iommu.h
@@ -78,6 +78,8 @@ struct omap_iommu {
 
 	struct iommu_device iommu;
 	struct iommu_group *group;
+
+	u8 pwrst;
 };
 
 /**

commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/iommu/omap-iommu.h b/drivers/iommu/omap-iommu.h
index 1703159ef5af..09968a02d291 100644
--- a/drivers/iommu/omap-iommu.h
+++ b/drivers/iommu/omap-iommu.h
@@ -1,13 +1,10 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * omap iommu: main structures
  *
  * Copyright (C) 2008-2009 Nokia Corporation
  *
  * Written by Hiroshi DOYU <Hiroshi.DOYU@nokia.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
  */
 
 #ifndef _OMAP_IOMMU_H

commit 9d5018deec86673ef8418546a3ac43e47dbff3b9
Author: Suman Anna <s-anna@ti.com>
Date:   Tue Sep 5 17:56:18 2017 -0500

    iommu/omap: Add support to program multiple iommus
    
    A client user instantiates and attaches to an iommu_domain to
    program the OMAP IOMMU associated with the domain. The iommus
    programmed by a client user are bound with the iommu_domain
    through the user's device archdata. The OMAP IOMMU driver
    currently supports only one IOMMU per IOMMU domain per user.
    
    The OMAP IOMMU driver has been enhanced to support allowing
    multiple IOMMUs to be programmed by a single client user. This
    support is being added mainly to handle the DSP subsystems on
    the DRA7xx SoCs, which have two MMUs within the same subsystem.
    These MMUs provide translations for a processor core port and
    an internal EDMA port. This support allows both the MMUs to
    be programmed together, but with each one retaining it's own
    internal state objects. The internal EDMA block is managed by
    the software running on the DSPs, and this design provides
    on-par functionality with previous generation OMAP DSPs where
    the EDMA and the DSP core shared the same MMU.
    
    The multiple iommus are expected to be provided through a
    sentinel terminated array of omap_iommu_arch_data objects
    through the client user's device archdata. The OMAP driver
    core is enhanced to loop through the array of attached
    iommus and program them for all common operations. The
    sentinel-terminated logic is used so as to not change the
    omap_iommu_arch_data structure.
    
    NOTE:
    1. The IOMMU group and IOMMU core registration is done only for
       the DSP processor core MMU even though both MMUs are represented
       by their own platform device and are probed individually. The
       IOMMU device linking uses this registered MMU device. The struct
       iommu_device for the second MMU is not used even though memory
       for it is allocated.
    2. The OMAP IOMMU debugfs code still continues to operate on
       individual IOMMU objects.
    
    Signed-off-by: Suman Anna <s-anna@ti.com>
    [t-kristo@ti.com: ported support to 4.13 based kernel]
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/drivers/iommu/omap-iommu.h b/drivers/iommu/omap-iommu.h
index a675af29a6ec..1703159ef5af 100644
--- a/drivers/iommu/omap-iommu.h
+++ b/drivers/iommu/omap-iommu.h
@@ -28,18 +28,27 @@ struct iotlb_entry {
 	u32 endian, elsz, mixed;
 };
 
+/**
+ * struct omap_iommu_device - omap iommu device data
+ * @pgtable:	page table used by an omap iommu attached to a domain
+ * @iommu_dev:	pointer to store an omap iommu instance attached to a domain
+ */
+struct omap_iommu_device {
+	u32 *pgtable;
+	struct omap_iommu *iommu_dev;
+};
+
 /**
  * struct omap_iommu_domain - omap iommu domain
- * @pgtable:	the page table
- * @iommu_dev:	an omap iommu device attached to this domain. only a single
- *		iommu device can be attached for now.
+ * @num_iommus: number of iommus in this domain
+ * @iommus:	omap iommu device data for all iommus in this domain
  * @dev:	Device using this domain.
  * @lock:	domain lock, should be taken when attaching/detaching
  * @domain:	generic domain handle used by iommu core code
  */
 struct omap_iommu_domain {
-	u32 *pgtable;
-	struct omap_iommu *iommu_dev;
+	u32 num_iommus;
+	struct omap_iommu_device *iommus;
 	struct device *dev;
 	spinlock_t lock;
 	struct iommu_domain domain;
@@ -97,17 +106,6 @@ struct iotlb_lock {
 	short vict;
 };
 
-/**
- * dev_to_omap_iommu() - retrieves an omap iommu object from a user device
- * @dev: iommu client device
- */
-static inline struct omap_iommu *dev_to_omap_iommu(struct device *dev)
-{
-	struct omap_iommu_arch_data *arch_data = dev->archdata.iommu;
-
-	return arch_data->iommu_dev;
-}
-
 /*
  * MMU Register offsets
  */

commit bfee0cf0ee1da0010b97ba88ed241d6f7bed3e7a
Author: Josue Albarran <j-albarran@ti.com>
Date:   Fri Jul 28 15:49:14 2017 -0500

    iommu/omap: Use DMA-API for performing cache flushes
    
    The OMAP IOMMU driver was using ARM assembly code directly for
    flushing the MMU page table entries from the caches. This caused
    MMU faults on OMAP4 (Cortex-A9 based SoCs) as L2 caches were not
    handled due to the presence of a PL310 L2 Cache Controller. These
    faults were however not seen on OMAP5/DRA7 SoCs (Cortex-A15 based
    SoCs).
    
    The OMAP IOMMU driver is adapted to use the DMA Streaming API
    instead now to flush the page table/directory table entries from
    the CPU caches. This ensures that the devices always see the
    updated page table entries. The outer caches are now addressed
    automatically with the usage of the DMA API.
    
    Signed-off-by: Josue Albarran <j-albarran@ti.com>
    Acked-by: Suman Anna <s-anna@ti.com>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/drivers/iommu/omap-iommu.h b/drivers/iommu/omap-iommu.h
index 6e70515e6038..a675af29a6ec 100644
--- a/drivers/iommu/omap-iommu.h
+++ b/drivers/iommu/omap-iommu.h
@@ -61,6 +61,7 @@ struct omap_iommu {
 	 */
 	u32		*iopgd;
 	spinlock_t	page_table_lock; /* protect iopgd */
+	dma_addr_t	pd_dma;
 
 	int		nr_tlb_entries;
 

commit 28ae1e3e14f32c70913e4ebf4aeff7959ed03f84
Author: Joerg Roedel <jroedel@suse.de>
Date:   Wed Apr 12 00:21:31 2017 -0500

    iommu/omap: Add iommu-group support
    
    Support for IOMMU groups will become mandatory for drivers,
    so add it to the omap iommu driver.
    
    Signed-off-by: Joerg Roedel <jroedel@suse.de>
    [s-anna@ti.com: minor error cleanups]
    Signed-off-by: Suman Anna <s-anna@ti.com>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/drivers/iommu/omap-iommu.h b/drivers/iommu/omap-iommu.h
index 758958a4712c..6e70515e6038 100644
--- a/drivers/iommu/omap-iommu.h
+++ b/drivers/iommu/omap-iommu.h
@@ -70,6 +70,7 @@ struct omap_iommu {
 	u32 id;
 
 	struct iommu_device iommu;
+	struct iommu_group *group;
 };
 
 /**

commit 01611fe8478bf582af0c33d5853137dd25b72f2f
Author: Joerg Roedel <jroedel@suse.de>
Date:   Wed Apr 12 00:21:30 2017 -0500

    iommu/omap: Make use of 'struct iommu_device'
    
    Modify the driver to register individual iommus and
    establish links between devices and iommus in sysfs.
    
    Signed-off-by: Joerg Roedel <jroedel@suse.de>
    [s-anna@ti.com: fix some cleanup issues during failures]
    Signed-off-by: Suman Anna <s-anna@ti.com>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/drivers/iommu/omap-iommu.h b/drivers/iommu/omap-iommu.h
index f81184b549ec..758958a4712c 100644
--- a/drivers/iommu/omap-iommu.h
+++ b/drivers/iommu/omap-iommu.h
@@ -68,6 +68,8 @@ struct omap_iommu {
 
 	int has_bus_err_back;
 	u32 id;
+
+	struct iommu_device iommu;
 };
 
 /**

commit ede1c2e7d4dc49fb1591e1754db9d53fabbd4b8b
Author: Joerg Roedel <jroedel@suse.de>
Date:   Wed Apr 12 00:21:29 2017 -0500

    iommu/omap: Store iommu_dev pointer in arch_data
    
    Instead of finding the matching IOMMU for a device using
    string comparision functions, store the pointer to the
    iommu_dev in arch_data during the omap_iommu_add_device
    callback and reset it during the omap_iommu_remove_device
    callback functions.
    
    Signed-off-by: Joerg Roedel <jroedel@suse.de>
    [s-anna@ti.com: few minor cleanups]
    Signed-off-by: Suman Anna <s-anna@ti.com>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/drivers/iommu/omap-iommu.h b/drivers/iommu/omap-iommu.h
index 3c33608f48ca..f81184b549ec 100644
--- a/drivers/iommu/omap-iommu.h
+++ b/drivers/iommu/omap-iommu.h
@@ -72,7 +72,6 @@ struct omap_iommu {
 
 /**
  * struct omap_iommu_arch_data - omap iommu private data
- * @name: name of the iommu device
  * @iommu_dev: handle of the iommu device
  *
  * This is an omap iommu private data object, which binds an iommu user
@@ -81,7 +80,6 @@ struct omap_iommu {
  * utilize omap-specific plumbing anymore.
  */
 struct omap_iommu_arch_data {
-	const char *name;
 	struct omap_iommu *iommu_dev;
 };
 

commit e73b7afe4e8ca5ec4304a9e1d5009755a85fff91
Author: Joerg Roedel <jroedel@suse.de>
Date:   Wed Apr 12 00:21:28 2017 -0500

    iommu/omap: Move data structures to omap-iommu.h
    
    The internal data-structures are scattered over various
    header and C files. Consolidate them in omap-iommu.h.
    
    While at this, add the kerneldoc comment for the missing
    iommu domain variable and revise the iommu_arch_data name.
    
    Signed-off-by: Joerg Roedel <jroedel@suse.de>
    [s-anna@ti.com: revise kerneldoc comments]
    Signed-off-by: Suman Anna <s-anna@ti.com>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/drivers/iommu/omap-iommu.h b/drivers/iommu/omap-iommu.h
index 59628e5017b4..3c33608f48ca 100644
--- a/drivers/iommu/omap-iommu.h
+++ b/drivers/iommu/omap-iommu.h
@@ -14,6 +14,7 @@
 #define _OMAP_IOMMU_H
 
 #include <linux/bitops.h>
+#include <linux/iommu.h>
 
 #define for_each_iotlb_cr(obj, n, __i, cr)				\
 	for (__i = 0;							\
@@ -27,6 +28,23 @@ struct iotlb_entry {
 	u32 endian, elsz, mixed;
 };
 
+/**
+ * struct omap_iommu_domain - omap iommu domain
+ * @pgtable:	the page table
+ * @iommu_dev:	an omap iommu device attached to this domain. only a single
+ *		iommu device can be attached for now.
+ * @dev:	Device using this domain.
+ * @lock:	domain lock, should be taken when attaching/detaching
+ * @domain:	generic domain handle used by iommu core code
+ */
+struct omap_iommu_domain {
+	u32 *pgtable;
+	struct omap_iommu *iommu_dev;
+	struct device *dev;
+	spinlock_t lock;
+	struct iommu_domain domain;
+};
+
 struct omap_iommu {
 	const char	*name;
 	void __iomem	*regbase;
@@ -52,6 +70,21 @@ struct omap_iommu {
 	u32 id;
 };
 
+/**
+ * struct omap_iommu_arch_data - omap iommu private data
+ * @name: name of the iommu device
+ * @iommu_dev: handle of the iommu device
+ *
+ * This is an omap iommu private data object, which binds an iommu user
+ * to its iommu device. This object should be placed at the iommu user's
+ * dev_archdata so generic IOMMU API can be used without having to
+ * utilize omap-specific plumbing anymore.
+ */
+struct omap_iommu_arch_data {
+	const char *name;
+	struct omap_iommu *iommu_dev;
+};
+
 struct cr_regs {
 	u32 cam;
 	u32 ram;

commit 3ca9299e7dc65f2d8242cd7804818a8e840b5a26
Author: Suman Anna <s-anna@ti.com>
Date:   Fri Oct 2 18:02:44 2015 -0500

    iommu/omap: Add support for configuring dsp iommus on DRA7xx
    
    The DSP MMUs on DRA7xx SoC requires configuring an additional
    MMU_CONFIG register present in the DSP_SYSTEM sub module. This
    setting dictates whether the DSP Core's MDMA and EDMA traffic
    is routed through the respective MMU or not. Add the support
    to the OMAP iommu driver so that the traffic is not bypassed
    when enabling the MMUs.
    
    The MMU_CONFIG register has two different bits for enabling
    each of these two MMUs present in the DSP processor sub-system
    on DRA7xx. An id field is added to the OMAP iommu object to
    identify and enable each IOMMU. The id information and the
    DSP_SYSTEM.MMU_CONFIG register programming is achieved through
    the processing of the optional "ti,syscon-mmuconfig" property.
    A proper value is assigned to the id field only when this
    property is present.
    
    Signed-off-by: Suman Anna <s-anna@ti.com>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/drivers/iommu/omap-iommu.h b/drivers/iommu/omap-iommu.h
index a656df2f9e03..59628e5017b4 100644
--- a/drivers/iommu/omap-iommu.h
+++ b/drivers/iommu/omap-iommu.h
@@ -30,6 +30,7 @@ struct iotlb_entry {
 struct omap_iommu {
 	const char	*name;
 	void __iomem	*regbase;
+	struct regmap	*syscfg;
 	struct device	*dev;
 	struct iommu_domain *domain;
 	struct dentry	*debug_dir;
@@ -48,6 +49,7 @@ struct omap_iommu {
 	void *ctx; /* iommu context: registres saved area */
 
 	int has_bus_err_back;
+	u32 id;
 };
 
 struct cr_regs {
@@ -158,6 +160,13 @@ static inline struct omap_iommu *dev_to_omap_iommu(struct device *dev)
 	 ((pgsz) == MMU_CAM_PGSZ_64K) ? 0xffff0000 :	\
 	 ((pgsz) == MMU_CAM_PGSZ_4K)  ? 0xfffff000 : 0)
 
+/*
+ * DSP_SYSTEM registers and bit definitions (applicable only for DRA7xx DSP)
+ */
+#define DSP_SYS_REVISION		0x00
+#define DSP_SYS_MMU_CONFIG		0x18
+#define DSP_SYS_MMU_CONFIG_EN_SHIFT	4
+
 /*
  * utilities for super page(16MB, 1MB, 64KB and 4KB)
  */

commit eb642a3f5afdb13aa2b7ba0bda314b0d2b62165d
Author: Suman Anna <s-anna@ti.com>
Date:   Mon Jul 20 17:33:31 2015 -0500

    iommu/omap: Use BIT(x) macros in omap-iommu.h
    
    Switch to using the BIT(x) macros in omap-iommu.h where
    possible. This eliminates the following checkpatch check
    warning:
        "CHECK: Prefer using the BIT macro"
    
    A couple of the warnings were ignored for better readability
    of the bit-shift for the different values.
    
    Signed-off-by: Suman Anna <s-anna@ti.com>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/drivers/iommu/omap-iommu.h b/drivers/iommu/omap-iommu.h
index 5b98408c18bf..a656df2f9e03 100644
--- a/drivers/iommu/omap-iommu.h
+++ b/drivers/iommu/omap-iommu.h
@@ -13,6 +13,8 @@
 #ifndef _OMAP_IOMMU_H
 #define _OMAP_IOMMU_H
 
+#include <linux/bitops.h>
+
 #define for_each_iotlb_cr(obj, n, __i, cr)				\
 	for (__i = 0;							\
 	     (__i < (n)) && (cr = __iotlb_read_cr((obj), __i), true);	\
@@ -96,11 +98,11 @@ static inline struct omap_iommu *dev_to_omap_iommu(struct device *dev)
  * MMU Register bit definitions
  */
 /* IRQSTATUS & IRQENABLE */
-#define MMU_IRQ_MULTIHITFAULT	(1 << 4)
-#define MMU_IRQ_TABLEWALKFAULT	(1 << 3)
-#define MMU_IRQ_EMUMISS		(1 << 2)
-#define MMU_IRQ_TRANSLATIONFAULT	(1 << 1)
-#define MMU_IRQ_TLBMISS		(1 << 0)
+#define MMU_IRQ_MULTIHITFAULT	BIT(4)
+#define MMU_IRQ_TABLEWALKFAULT	BIT(3)
+#define MMU_IRQ_EMUMISS		BIT(2)
+#define MMU_IRQ_TRANSLATIONFAULT	BIT(1)
+#define MMU_IRQ_TLBMISS		BIT(0)
 
 #define __MMU_IRQ_FAULT		\
 	(MMU_IRQ_MULTIHITFAULT | MMU_IRQ_EMUMISS | MMU_IRQ_TRANSLATIONFAULT)
@@ -112,16 +114,16 @@ static inline struct omap_iommu *dev_to_omap_iommu(struct device *dev)
 /* MMU_CNTL */
 #define MMU_CNTL_SHIFT		1
 #define MMU_CNTL_MASK		(7 << MMU_CNTL_SHIFT)
-#define MMU_CNTL_EML_TLB	(1 << 3)
-#define MMU_CNTL_TWL_EN		(1 << 2)
-#define MMU_CNTL_MMU_EN		(1 << 1)
+#define MMU_CNTL_EML_TLB	BIT(3)
+#define MMU_CNTL_TWL_EN		BIT(2)
+#define MMU_CNTL_MMU_EN		BIT(1)
 
 /* CAM */
 #define MMU_CAM_VATAG_SHIFT	12
 #define MMU_CAM_VATAG_MASK \
 	((~0UL >> MMU_CAM_VATAG_SHIFT) << MMU_CAM_VATAG_SHIFT)
-#define MMU_CAM_P		(1 << 3)
-#define MMU_CAM_V		(1 << 2)
+#define MMU_CAM_P		BIT(3)
+#define MMU_CAM_V		BIT(2)
 #define MMU_CAM_PGSZ_MASK	3
 #define MMU_CAM_PGSZ_1M		(0 << 0)
 #define MMU_CAM_PGSZ_64K	(1 << 0)
@@ -134,9 +136,9 @@ static inline struct omap_iommu *dev_to_omap_iommu(struct device *dev)
 	((~0UL >> MMU_RAM_PADDR_SHIFT) << MMU_RAM_PADDR_SHIFT)
 
 #define MMU_RAM_ENDIAN_SHIFT	9
-#define MMU_RAM_ENDIAN_MASK	(1 << MMU_RAM_ENDIAN_SHIFT)
+#define MMU_RAM_ENDIAN_MASK	BIT(MMU_RAM_ENDIAN_SHIFT)
 #define MMU_RAM_ENDIAN_LITTLE	(0 << MMU_RAM_ENDIAN_SHIFT)
-#define MMU_RAM_ENDIAN_BIG	(1 << MMU_RAM_ENDIAN_SHIFT)
+#define MMU_RAM_ENDIAN_BIG	BIT(MMU_RAM_ENDIAN_SHIFT)
 
 #define MMU_RAM_ELSZ_SHIFT	7
 #define MMU_RAM_ELSZ_MASK	(3 << MMU_RAM_ELSZ_SHIFT)
@@ -145,7 +147,7 @@ static inline struct omap_iommu *dev_to_omap_iommu(struct device *dev)
 #define MMU_RAM_ELSZ_32		(2 << MMU_RAM_ELSZ_SHIFT)
 #define MMU_RAM_ELSZ_NONE	(3 << MMU_RAM_ELSZ_SHIFT)
 #define MMU_RAM_MIXED_SHIFT	6
-#define MMU_RAM_MIXED_MASK	(1 << MMU_RAM_MIXED_SHIFT)
+#define MMU_RAM_MIXED_MASK	BIT(MMU_RAM_MIXED_SHIFT)
 #define MMU_RAM_MIXED		MMU_RAM_MIXED_MASK
 
 #define MMU_GP_REG_BUS_ERR_BACK_EN	0x1

commit dc308f9f92b084a25989fd2002fac06cbf4a73d4
Author: Suman Anna <s-anna@ti.com>
Date:   Mon Jul 20 17:33:27 2015 -0500

    iommu/omap: Remove unused union fields
    
    There are couple of unions defined in the structures
    iotlb_entry and cr_regs. There are no usage/references
    to some of these union fields in the code, so clean
    them up and simplify the structures.
    
    Signed-off-by: Suman Anna <s-anna@ti.com>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/drivers/iommu/omap-iommu.h b/drivers/iommu/omap-iommu.h
index b6cc90b2ba41..5b98408c18bf 100644
--- a/drivers/iommu/omap-iommu.h
+++ b/drivers/iommu/omap-iommu.h
@@ -22,12 +22,7 @@ struct iotlb_entry {
 	u32 da;
 	u32 pa;
 	u32 pgsz, prsvd, valid;
-	union {
-		u16 ap;
-		struct {
-			u32 endian, elsz, mixed;
-		};
-	};
+	u32 endian, elsz, mixed;
 };
 
 struct omap_iommu {
@@ -54,20 +49,8 @@ struct omap_iommu {
 };
 
 struct cr_regs {
-	union {
-		struct {
-			u16 cam_l;
-			u16 cam_h;
-		};
-		u32 cam;
-	};
-	union {
-		struct {
-			u16 ram_l;
-			u16 ram_h;
-		};
-		u32 ram;
-	};
+	u32 cam;
+	u32 ram;
 };
 
 struct iotlb_lock {

commit 69c2c196328e73d3091dd0be89ab4b0c2af4b210
Author: Suman Anna <s-anna@ti.com>
Date:   Mon Jul 20 17:33:25 2015 -0500

    iommu/omap: Move debugfs functions to omap-iommu-debug.c
    
    The main OMAP IOMMU driver file has some helper functions used
    by the OMAP IOMMU debugfs functionality, and there is already a
    dedicated source file omap-iommu-debug.c dealing with these debugfs
    routines. Move all these functions to the omap-iommu-debug.c file,
    so that all the debugfs related routines are in one place.
    
    The move required exposing some new functions and moving some
    definitions to the internal omap-iommu.h header file.
    
    Signed-off-by: Suman Anna <s-anna@ti.com>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/drivers/iommu/omap-iommu.h b/drivers/iommu/omap-iommu.h
index d736630df3c8..b6cc90b2ba41 100644
--- a/drivers/iommu/omap-iommu.h
+++ b/drivers/iommu/omap-iommu.h
@@ -13,6 +13,11 @@
 #ifndef _OMAP_IOMMU_H
 #define _OMAP_IOMMU_H
 
+#define for_each_iotlb_cr(obj, n, __i, cr)				\
+	for (__i = 0;							\
+	     (__i < (n)) && (cr = __iotlb_read_cr((obj), __i), true);	\
+	     __i++)
+
 struct iotlb_entry {
 	u32 da;
 	u32 pa;
@@ -65,6 +70,11 @@ struct cr_regs {
 	};
 };
 
+struct iotlb_lock {
+	short base;
+	short vict;
+};
+
 /**
  * dev_to_omap_iommu() - retrieves an omap iommu object from a user device
  * @dev: iommu client device
@@ -190,12 +200,12 @@ static inline struct omap_iommu *dev_to_omap_iommu(struct device *dev)
 /*
  * global functions
  */
-#ifdef CONFIG_OMAP_IOMMU_DEBUG
-extern ssize_t
-omap_iommu_dump_ctx(struct omap_iommu *obj, char *buf, ssize_t len);
-extern size_t
-omap_dump_tlb_entries(struct omap_iommu *obj, char *buf, ssize_t len);
 
+struct cr_regs __iotlb_read_cr(struct omap_iommu *obj, int n);
+void iotlb_lock_get(struct omap_iommu *obj, struct iotlb_lock *l);
+void iotlb_lock_set(struct omap_iommu *obj, struct iotlb_lock *l);
+
+#ifdef CONFIG_OMAP_IOMMU_DEBUG
 void omap_iommu_debugfs_init(void);
 void omap_iommu_debugfs_exit(void);
 
@@ -222,4 +232,12 @@ static inline void iommu_write_reg(struct omap_iommu *obj, u32 val, size_t offs)
 	__raw_writel(val, obj->regbase + offs);
 }
 
+static inline int iotlb_cr_valid(struct cr_regs *cr)
+{
+	if (!cr)
+		return -EINVAL;
+
+	return cr->cam & MMU_CAM_V;
+}
+
 #endif /* _OMAP_IOMMU_H */

commit 4899a5636d535ba573a7e52b5ad7be1f886d40a3
Author: Suman Anna <s-anna@ti.com>
Date:   Wed Oct 22 17:22:32 2014 -0500

    iommu/omap: Do not export unneeded functions
    
    The following functions were exported previously for usage by
    the OMAP IOMMU debug module:
            omap_iommu_dump_ctx()
            omap_dump_tlb_entries()
            omap_iopgtable_store_entry()
    
    These functions need not be exported anymore as the OMAP IOMMU
    debugfs code is integrated with the OMAP IOMMU driver, and
    there won't be external users for these functions. So, remove
    the EXPORT_SYMBOL_GPL on these. The omap_iopgtable_store_entry()
    is also made internal only, after making the 'pagetable' debugfs
    entry read-only.
    
    Signed-off-by: Suman Anna <s-anna@ti.com>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/drivers/iommu/omap-iommu.h b/drivers/iommu/omap-iommu.h
index b18ceccd4845..d736630df3c8 100644
--- a/drivers/iommu/omap-iommu.h
+++ b/drivers/iommu/omap-iommu.h
@@ -190,9 +190,6 @@ static inline struct omap_iommu *dev_to_omap_iommu(struct device *dev)
 /*
  * global functions
  */
-extern int
-omap_iopgtable_store_entry(struct omap_iommu *obj, struct iotlb_entry *e);
-
 #ifdef CONFIG_OMAP_IOMMU_DEBUG
 extern ssize_t
 omap_iommu_dump_ctx(struct omap_iommu *obj, char *buf, ssize_t len);

commit c55caec124512d8192ff21eb3c08df55c94f2db3
Author: Suman Anna <s-anna@ti.com>
Date:   Wed Oct 22 17:22:31 2014 -0500

    iommu/omap: Remove couple of unused exported functions
    
    The exported functions omap_foreach_iommu_device() and
    omap_iotlb_cr_to_e() have been deleted, as they are no
    longer needed.
    
    The function omap_foreach_iommu_device() is not required
    after the consolidation of the OMAP IOMMU debug module,
    and the function omap_iotlb_cr_to_e() is not required
    after making the debugfs entry 'pagetable' read-only.
    
    Signed-off-by: Suman Anna <s-anna@ti.com>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/drivers/iommu/omap-iommu.h b/drivers/iommu/omap-iommu.h
index 478377924e8f..b18ceccd4845 100644
--- a/drivers/iommu/omap-iommu.h
+++ b/drivers/iommu/omap-iommu.h
@@ -190,14 +190,9 @@ static inline struct omap_iommu *dev_to_omap_iommu(struct device *dev)
 /*
  * global functions
  */
-extern void omap_iotlb_cr_to_e(struct cr_regs *cr, struct iotlb_entry *e);
-
 extern int
 omap_iopgtable_store_entry(struct omap_iommu *obj, struct iotlb_entry *e);
 
-extern int omap_foreach_iommu_device(void *data,
-				int (*fn)(struct device *, void *));
-
 #ifdef CONFIG_OMAP_IOMMU_DEBUG
 extern ssize_t
 omap_iommu_dump_ctx(struct omap_iommu *obj, char *buf, ssize_t len);

commit 61c753526dc3ef91a0601e0bf2bdeeb6c415e747
Author: Suman Anna <s-anna@ti.com>
Date:   Wed Oct 22 17:22:30 2014 -0500

    iommu/omap: Integrate omap-iommu-debug into omap-iommu
    
    The debugfs support for OMAP IOMMU is currently implemented
    as a module, warranting certain OMAP-specific IOMMU API to
    be exported. The OMAP IOMMU, when enabled, can only be built-in
    into the kernel, so integrate the OMAP IOMMU debug module
    into the OMAP IOMMU driver. This helps in eliminating the
    need to export most of the current OMAP IOMMU API.
    
    The following are the main changes:
    - The debugfs directory and entry creation logic is reversed,
      the calls are invoked by the OMAP IOMMU driver now.
    - The current iffy circular logic of adding IOMMU archdata
      to the IOMMU devices itself to get a pointer to the omap_iommu
      object in the debugfs support code is replaced by directly
      using the omap_iommu structure while creating the debugfs
      entries.
    - The debugfs root directory is renamed from the generic name
      "iommu" to a specific name "omap_iommu".
    - Unneeded headers have also been cleaned up while at this.
    - There will no longer be a omap-iommu-debug.ko module after
      this patch.
    - The OMAP_IOMMU_DEBUG Kconfig option is converted to boolean
      only, the OMAP IOMMU debugfs support is built alongside the
      OMAP IOMMU driver only when this option is enabled.
    
    Signed-off-by: Suman Anna <s-anna@ti.com>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/drivers/iommu/omap-iommu.h b/drivers/iommu/omap-iommu.h
index 0516e0ed77d7..478377924e8f 100644
--- a/drivers/iommu/omap-iommu.h
+++ b/drivers/iommu/omap-iommu.h
@@ -30,6 +30,7 @@ struct omap_iommu {
 	void __iomem	*regbase;
 	struct device	*dev;
 	struct iommu_domain *domain;
+	struct dentry	*debug_dir;
 
 	spinlock_t	iommu_lock;	/* global for this whole object */
 
@@ -197,11 +198,25 @@ omap_iopgtable_store_entry(struct omap_iommu *obj, struct iotlb_entry *e);
 extern int omap_foreach_iommu_device(void *data,
 				int (*fn)(struct device *, void *));
 
+#ifdef CONFIG_OMAP_IOMMU_DEBUG
 extern ssize_t
 omap_iommu_dump_ctx(struct omap_iommu *obj, char *buf, ssize_t len);
 extern size_t
 omap_dump_tlb_entries(struct omap_iommu *obj, char *buf, ssize_t len);
 
+void omap_iommu_debugfs_init(void);
+void omap_iommu_debugfs_exit(void);
+
+void omap_iommu_debugfs_add(struct omap_iommu *obj);
+void omap_iommu_debugfs_remove(struct omap_iommu *obj);
+#else
+static inline void omap_iommu_debugfs_init(void) { }
+static inline void omap_iommu_debugfs_exit(void) { }
+
+static inline void omap_iommu_debugfs_add(struct omap_iommu *obj) { }
+static inline void omap_iommu_debugfs_remove(struct omap_iommu *obj) { }
+#endif
+
 /*
  * register accessors
  */

commit bd4396f09a4a9e77423e92ec9448217ab46f6edf
Author: Suman Anna <s-anna@ti.com>
Date:   Wed Oct 22 17:22:27 2014 -0500

    iommu/omap: Consolidate OMAP IOMMU modules
    
    The OMAP IOMMU driver was originally designed as modules, and split
    into a core module and a thin arch-specific module through the OMAP
    arch-specific struct iommu_functions, to scale for both OMAP1 and
    OMAP2+ IOMMU variants. The driver can only be built for OMAP2+
    platforms currently, and also can only be built-in after the
    adaptation to generic IOMMU API. The OMAP1 variant was never added
    and will most probably be never added (the code for the only potential
    user, its parent, DSP processor has already been cleaned up). So,
    consolidate the OMAP2 specific omap-iommu2 module into the core OMAP
    IOMMU driver - this eliminates the arch-specific ops structure and
    simplifies the driver into a single module that only implements the
    generic IOMMU API's iommu_ops.
    
    The following are the main changes:
    - omap-iommu2 module is completely eliminated, with the common
      definitions moved to the internal omap-iommu.h, and the ops
      implementations moved into omap-iommu.c
    - OMAP arch-specific struct iommu_functions is also eliminated,
      with the ops implementations directly absorbed into the calling
      functions
    - iotlb_alloc_cr() is no longer inlined and defined only when
      PREFETCH_IOTLB is defined
    - iotlb_dump_cr() is similarly defined only when CONFIG_OMAP_IOMMU_DEBUG
      is defined
    - Elimination of the OMAP IOMMU exported functions to register the
      arch ops, omap_install_iommu_arch() & omap_uninstall_iommu_arch()
    - Any stale comments about OMAP1 are also cleaned up
    
    Signed-off-by: Suman Anna <s-anna@ti.com>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/drivers/iommu/omap-iommu.h b/drivers/iommu/omap-iommu.h
index 45fe67d641e2..0516e0ed77d7 100644
--- a/drivers/iommu/omap-iommu.h
+++ b/drivers/iommu/omap-iommu.h
@@ -13,10 +13,6 @@
 #ifndef _OMAP_IOMMU_H
 #define _OMAP_IOMMU_H
 
-#if defined(CONFIG_ARCH_OMAP1)
-#error "iommu for this processor not implemented yet"
-#endif
-
 struct iotlb_entry {
 	u32 da;
 	u32 pa;
@@ -68,31 +64,6 @@ struct cr_regs {
 	};
 };
 
-/* architecture specific functions */
-struct iommu_functions {
-	int (*enable)(struct omap_iommu *obj);
-	void (*disable)(struct omap_iommu *obj);
-	void (*set_twl)(struct omap_iommu *obj, bool on);
-	u32 (*fault_isr)(struct omap_iommu *obj, u32 *ra);
-
-	void (*tlb_read_cr)(struct omap_iommu *obj, struct cr_regs *cr);
-	void (*tlb_load_cr)(struct omap_iommu *obj, struct cr_regs *cr);
-
-	struct cr_regs *(*alloc_cr)(struct omap_iommu *obj,
-							struct iotlb_entry *e);
-	int (*cr_valid)(struct cr_regs *cr);
-	u32 (*cr_to_virt)(struct cr_regs *cr);
-	void (*cr_to_e)(struct cr_regs *cr, struct iotlb_entry *e);
-	ssize_t (*dump_cr)(struct omap_iommu *obj, struct cr_regs *cr,
-							char *buf);
-
-	u32 (*get_pte_attr)(struct iotlb_entry *e);
-
-	void (*save_ctx)(struct omap_iommu *obj);
-	void (*restore_ctx)(struct omap_iommu *obj);
-	ssize_t (*dump_ctx)(struct omap_iommu *obj, char *buf, ssize_t len);
-};
-
 /**
  * dev_to_omap_iommu() - retrieves an omap iommu object from a user device
  * @dev: iommu client device
@@ -130,6 +101,28 @@ static inline struct omap_iommu *dev_to_omap_iommu(struct device *dev)
 /*
  * MMU Register bit definitions
  */
+/* IRQSTATUS & IRQENABLE */
+#define MMU_IRQ_MULTIHITFAULT	(1 << 4)
+#define MMU_IRQ_TABLEWALKFAULT	(1 << 3)
+#define MMU_IRQ_EMUMISS		(1 << 2)
+#define MMU_IRQ_TRANSLATIONFAULT	(1 << 1)
+#define MMU_IRQ_TLBMISS		(1 << 0)
+
+#define __MMU_IRQ_FAULT		\
+	(MMU_IRQ_MULTIHITFAULT | MMU_IRQ_EMUMISS | MMU_IRQ_TRANSLATIONFAULT)
+#define MMU_IRQ_MASK		\
+	(__MMU_IRQ_FAULT | MMU_IRQ_TABLEWALKFAULT | MMU_IRQ_TLBMISS)
+#define MMU_IRQ_TWL_MASK	(__MMU_IRQ_FAULT | MMU_IRQ_TABLEWALKFAULT)
+#define MMU_IRQ_TLB_MISS_MASK	(__MMU_IRQ_FAULT | MMU_IRQ_TLBMISS)
+
+/* MMU_CNTL */
+#define MMU_CNTL_SHIFT		1
+#define MMU_CNTL_MASK		(7 << MMU_CNTL_SHIFT)
+#define MMU_CNTL_EML_TLB	(1 << 3)
+#define MMU_CNTL_TWL_EN		(1 << 2)
+#define MMU_CNTL_MMU_EN		(1 << 1)
+
+/* CAM */
 #define MMU_CAM_VATAG_SHIFT	12
 #define MMU_CAM_VATAG_MASK \
 	((~0UL >> MMU_CAM_VATAG_SHIFT) << MMU_CAM_VATAG_SHIFT)
@@ -141,6 +134,7 @@ static inline struct omap_iommu *dev_to_omap_iommu(struct device *dev)
 #define MMU_CAM_PGSZ_4K		(2 << 0)
 #define MMU_CAM_PGSZ_16M	(3 << 0)
 
+/* RAM */
 #define MMU_RAM_PADDR_SHIFT	12
 #define MMU_RAM_PADDR_MASK \
 	((~0UL >> MMU_RAM_PADDR_SHIFT) << MMU_RAM_PADDR_SHIFT)
@@ -162,6 +156,12 @@ static inline struct omap_iommu *dev_to_omap_iommu(struct device *dev)
 
 #define MMU_GP_REG_BUS_ERR_BACK_EN	0x1
 
+#define get_cam_va_mask(pgsz)				\
+	(((pgsz) == MMU_CAM_PGSZ_16M) ? 0xff000000 :	\
+	 ((pgsz) == MMU_CAM_PGSZ_1M)  ? 0xfff00000 :	\
+	 ((pgsz) == MMU_CAM_PGSZ_64K) ? 0xffff0000 :	\
+	 ((pgsz) == MMU_CAM_PGSZ_4K)  ? 0xfffff000 : 0)
+
 /*
  * utilities for super page(16MB, 1MB, 64KB and 4KB)
  */
@@ -197,9 +197,6 @@ omap_iopgtable_store_entry(struct omap_iommu *obj, struct iotlb_entry *e);
 extern int omap_foreach_iommu_device(void *data,
 				int (*fn)(struct device *, void *));
 
-extern int omap_install_iommu_arch(const struct iommu_functions *ops);
-extern void omap_uninstall_iommu_arch(const struct iommu_functions *ops);
-
 extern ssize_t
 omap_iommu_dump_ctx(struct omap_iommu *obj, char *buf, ssize_t len);
 extern size_t

commit 3acb04ca5ea4e03c5718a87b713b2fd6f7f52b51
Author: Suman Anna <s-anna@ti.com>
Date:   Wed Oct 22 17:22:24 2014 -0500

    iommu/omap: Remove omap_iommu_arch_version() and version field
    
    The function omap_iommu_arch_version() is not used anymore,
    and is not required either, so remove it. The .version field
    in struct iommu_functions that this function uses is also
    removed, as it is not really an ops to retrieve a version and
    there won't be any usage for this field either.
    
    Signed-off-by: Suman Anna <s-anna@ti.com>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/drivers/iommu/omap-iommu.h b/drivers/iommu/omap-iommu.h
index d7c51327cd25..45fe67d641e2 100644
--- a/drivers/iommu/omap-iommu.h
+++ b/drivers/iommu/omap-iommu.h
@@ -70,8 +70,6 @@ struct cr_regs {
 
 /* architecture specific functions */
 struct iommu_functions {
-	unsigned long	version;
-
 	int (*enable)(struct omap_iommu *obj);
 	void (*disable)(struct omap_iommu *obj);
 	void (*set_twl)(struct omap_iommu *obj, bool on);
@@ -191,8 +189,6 @@ static inline struct omap_iommu *dev_to_omap_iommu(struct device *dev)
 /*
  * global functions
  */
-extern u32 omap_iommu_arch_version(void);
-
 extern void omap_iotlb_cr_to_e(struct cr_regs *cr, struct iotlb_entry *e);
 
 extern int

commit 533b40cccd2fbe8cf6ba361cab7e99f626be45bf
Author: Suman Anna <s-anna@ti.com>
Date:   Wed Oct 22 17:22:22 2014 -0500

    iommu/omap: Remove conditional definition of dev_to_omap_iommu()
    
    The dev_to_omap_iommu() is local to the OMAP IOMMU modules, and
    need not be defined conditionally. The CONFIG_IOMMU_API dependency
    check was added in the past to fix a compilation issue back when
    the header resided in the arch/arm layers, and is no longer
    needed.
    
    While at this, fix the header against double inclusion as well.
    
    Signed-off-by: Suman Anna <s-anna@ti.com>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/drivers/iommu/omap-iommu.h b/drivers/iommu/omap-iommu.h
index 4fc51c8e24b1..d7c51327cd25 100644
--- a/drivers/iommu/omap-iommu.h
+++ b/drivers/iommu/omap-iommu.h
@@ -10,6 +10,9 @@
  * published by the Free Software Foundation.
  */
 
+#ifndef _OMAP_IOMMU_H
+#define _OMAP_IOMMU_H
+
 #if defined(CONFIG_ARCH_OMAP1)
 #error "iommu for this processor not implemented yet"
 #endif
@@ -92,7 +95,6 @@ struct iommu_functions {
 	ssize_t (*dump_ctx)(struct omap_iommu *obj, char *buf, ssize_t len);
 };
 
-#ifdef CONFIG_IOMMU_API
 /**
  * dev_to_omap_iommu() - retrieves an omap iommu object from a user device
  * @dev: iommu client device
@@ -103,7 +105,6 @@ static inline struct omap_iommu *dev_to_omap_iommu(struct device *dev)
 
 	return arch_data->iommu_dev;
 }
-#endif
 
 /*
  * MMU Register offsets
@@ -220,3 +221,5 @@ static inline void iommu_write_reg(struct omap_iommu *obj, u32 val, size_t offs)
 {
 	__raw_writel(val, obj->regbase + offs);
 }
+
+#endif /* _OMAP_IOMMU_H */

commit 52dad776fcb644f9ccfc1986c965bd9438e59b21
Author: Suman Anna <s-anna@ti.com>
Date:   Wed Oct 22 17:22:21 2014 -0500

    iommu/omap: Remove duplicate declarations
    
    The omap_iommu_save_ctx() and omap_iommu_restore_ctx() declarations
    are defined in include/linux/omap-iommu.h and do not belong in the
    internal drivers/iommu/omap-iommu.h header, so remove them.
    
    Signed-off-by: Suman Anna <s-anna@ti.com>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/drivers/iommu/omap-iommu.h b/drivers/iommu/omap-iommu.h
index 18a0f3a138d9..4fc51c8e24b1 100644
--- a/drivers/iommu/omap-iommu.h
+++ b/drivers/iommu/omap-iommu.h
@@ -197,9 +197,6 @@ extern void omap_iotlb_cr_to_e(struct cr_regs *cr, struct iotlb_entry *e);
 extern int
 omap_iopgtable_store_entry(struct omap_iommu *obj, struct iotlb_entry *e);
 
-extern void omap_iommu_save_ctx(struct device *dev);
-extern void omap_iommu_restore_ctx(struct device *dev);
-
 extern int omap_foreach_iommu_device(void *data,
 				int (*fn)(struct device *, void *));
 

commit 4cfcf2ab01617401236b84c3539a59099592c7f3
Author: Suman Anna <s-anna@ti.com>
Date:   Wed Oct 22 17:22:20 2014 -0500

    iommu/omap: Remove unused isr_priv field from omap_iommu
    
    The isr_priv field is a left-over from before the IOMMU API
    adaptation, this was used to store the callback data. This is
    no longer relevant, so remove it.
    
    Signed-off-by: Suman Anna <s-anna@ti.com>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/drivers/iommu/omap-iommu.h b/drivers/iommu/omap-iommu.h
index 5c1400024e35..18a0f3a138d9 100644
--- a/drivers/iommu/omap-iommu.h
+++ b/drivers/iommu/omap-iommu.h
@@ -30,7 +30,6 @@ struct omap_iommu {
 	const char	*name;
 	void __iomem	*regbase;
 	struct device	*dev;
-	void		*isr_priv;
 	struct iommu_domain *domain;
 
 	spinlock_t	iommu_lock;	/* global for this whole object */

commit 2088ecba93f68252464b95375d80a12fe723ba5e
Author: Suman Anna <s-anna@ti.com>
Date:   Wed Oct 22 17:22:19 2014 -0500

    iommu/omap: Remove refcount field from omap_iommu object
    
    The refcount field in omap_iommu object is primarily used to check
    if an IOMMU device has already been enabled, but this is already
    implicit in the omap_iommu_attach_dev() which ensures that only
    a single device can attach to an IOMMU. This field is redundant,
    and so has been cleaned up.
    
    Signed-off-by: Suman Anna <s-anna@ti.com>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/drivers/iommu/omap-iommu.h b/drivers/iommu/omap-iommu.h
index 4f1b68c08c15..5c1400024e35 100644
--- a/drivers/iommu/omap-iommu.h
+++ b/drivers/iommu/omap-iommu.h
@@ -33,7 +33,6 @@ struct omap_iommu {
 	void		*isr_priv;
 	struct iommu_domain *domain;
 
-	unsigned int	refcount;
 	spinlock_t	iommu_lock;	/* global for this whole object */
 
 	/*

commit a6fda0f586bb2c39e763a2ae5561e1f6ade8c3a8
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Sep 9 18:45:45 2014 +0300

    iommu/omap: Remove omap_iommu unused owner field
    
    The owner field is never set. Remove it.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Acked-by: Suman Anna <s-anna@ti.com>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/drivers/iommu/omap-iommu.h b/drivers/iommu/omap-iommu.h
index 1275a822934b..4f1b68c08c15 100644
--- a/drivers/iommu/omap-iommu.h
+++ b/drivers/iommu/omap-iommu.h
@@ -28,7 +28,6 @@ struct iotlb_entry {
 
 struct omap_iommu {
 	const char	*name;
-	struct module	*owner;
 	void __iomem	*regbase;
 	struct device	*dev;
 	void		*isr_priv;

commit baaa7b5d4f1e515a39f1eebd5fb16b67e00b22fb
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Fri Jul 18 12:49:55 2014 +0200

    iommu/omap: Remove virtual memory manager
    
    The OMAP3 ISP driver was the only user of the OMAP IOVMM API. Now that
    is has been ported to the DMA API, remove the unused virtual memory
    manager.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/drivers/iommu/omap-iommu.h b/drivers/iommu/omap-iommu.h
index ea920c3e94ff..1275a822934b 100644
--- a/drivers/iommu/omap-iommu.h
+++ b/drivers/iommu/omap-iommu.h
@@ -46,12 +46,7 @@ struct omap_iommu {
 
 	int		nr_tlb_entries;
 
-	struct list_head	mmap;
-	struct mutex		mmap_lock; /* protect mmap */
-
 	void *ctx; /* iommu context: registres saved area */
-	u32 da_start;
-	u32 da_end;
 
 	int has_bus_err_back;
 };
@@ -154,9 +149,12 @@ static inline struct omap_iommu *dev_to_omap_iommu(struct device *dev)
 #define MMU_RAM_PADDR_MASK \
 	((~0UL >> MMU_RAM_PADDR_SHIFT) << MMU_RAM_PADDR_SHIFT)
 
+#define MMU_RAM_ENDIAN_SHIFT	9
 #define MMU_RAM_ENDIAN_MASK	(1 << MMU_RAM_ENDIAN_SHIFT)
+#define MMU_RAM_ENDIAN_LITTLE	(0 << MMU_RAM_ENDIAN_SHIFT)
 #define MMU_RAM_ENDIAN_BIG	(1 << MMU_RAM_ENDIAN_SHIFT)
 
+#define MMU_RAM_ELSZ_SHIFT	7
 #define MMU_RAM_ELSZ_MASK	(3 << MMU_RAM_ELSZ_SHIFT)
 #define MMU_RAM_ELSZ_8		(0 << MMU_RAM_ELSZ_SHIFT)
 #define MMU_RAM_ELSZ_16		(1 << MMU_RAM_ELSZ_SHIFT)

commit b148d5fb2ef7bd1441e95402effe22b7b34f9a73
Author: Suman Anna <s-anna@ti.com>
Date:   Fri Feb 28 14:42:37 2014 -0600

    iommu/omap: Enable bus-error back on supported iommus
    
    The remoteproc MMUs in OMAP4+ SoCs have some additional debug
    registers that can give out the PC value in addition to the
    MMU fault address. The PC value can be extracted properly only
    on the DSP cores, and is not available on the ARM processors
    within the IPU sub-systems. Instead, the MMUs have been enhanced
    to throw a bus-error response back to the IPU processors.
    
    This functionality is programmable through the MMU_GP_REG register.
    The cores are simply stalled if the MMU_GP_REG.BUS_ERR_BACK_EN bit
    is not set. When set, a bus-error exception is raised allowing the
    processor to handle it as a bus fault and provide additional debug
    information. This feature is turned on by default by the driver on
    iommus supporting it.
    
    Signed-off-by: Subramaniam Chanderashekarapuram <subramaniam.ca@ti.com>
    Signed-off-by: Suman Anna <s-anna@ti.com>
    Signed-off-by: Joerg Roedel <joro@8bytes.org>

diff --git a/drivers/iommu/omap-iommu.h b/drivers/iommu/omap-iommu.h
index 120084206602..ea920c3e94ff 100644
--- a/drivers/iommu/omap-iommu.h
+++ b/drivers/iommu/omap-iommu.h
@@ -52,6 +52,8 @@ struct omap_iommu {
 	void *ctx; /* iommu context: registres saved area */
 	u32 da_start;
 	u32 da_end;
+
+	int has_bus_err_back;
 };
 
 struct cr_regs {
@@ -130,6 +132,7 @@ static inline struct omap_iommu *dev_to_omap_iommu(struct device *dev)
 #define MMU_READ_CAM		0x68
 #define MMU_READ_RAM		0x6c
 #define MMU_EMU_FAULT_AD	0x70
+#define MMU_GP_REG		0x88
 
 #define MMU_REG_SIZE		256
 
@@ -163,6 +166,8 @@ static inline struct omap_iommu *dev_to_omap_iommu(struct device *dev)
 #define MMU_RAM_MIXED_MASK	(1 << MMU_RAM_MIXED_SHIFT)
 #define MMU_RAM_MIXED		MMU_RAM_MIXED_MASK
 
+#define MMU_GP_REG_BUS_ERR_BACK_EN	0x1
+
 /*
  * utilities for super page(16MB, 1MB, 64KB and 4KB)
  */

commit ebf7cda0f92effd8169b831fae81e9437dce1fef
Author: Omar Ramirez Luna <omar.luna@linaro.org>
Date:   Mon Nov 19 19:05:51 2012 -0600

    iommu/omap: Adapt to runtime pm
    
    Use runtime PM functionality interfaced with hwmod enable/idle
    functions, to replace direct clock operations and sysconfig
    handling.
    
    Due to reset sequence, pm_runtime_[get|put]_sync must be used, to
    avoid possible operations with the module under reset. Because of
    this and given that the driver uses spin_locks to protect their
    critical sections, we must use pm_runtime_irq_safe in order for the
    runtime ops to be happy, otherwise might_sleep_if checks in runtime
    framework will complain.
    
    The remaining pm_runtime out of iommu_enable and iommu_disable
    corresponds to paths that can be accessed through debugfs, some of
    them doesn't work if the module is not enabled first, but in future
    if the mmu is idled withouth freeing, these are needed to debug.
    
    Signed-off-by: Omar Ramirez Luna <omar.luna@linaro.org>
    Tested-by: Ohad Ben-Cohen <ohad@wizery.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Joerg Roedel <joro@8bytes.org>

diff --git a/drivers/iommu/omap-iommu.h b/drivers/iommu/omap-iommu.h
index 2b5f3c04d167..120084206602 100644
--- a/drivers/iommu/omap-iommu.h
+++ b/drivers/iommu/omap-iommu.h
@@ -29,7 +29,6 @@ struct iotlb_entry {
 struct omap_iommu {
 	const char	*name;
 	struct module	*owner;
-	struct clk	*clk;
 	void __iomem	*regbase;
 	struct device	*dev;
 	void		*isr_priv;
@@ -116,8 +115,6 @@ static inline struct omap_iommu *dev_to_omap_iommu(struct device *dev)
  * MMU Register offsets
  */
 #define MMU_REVISION		0x00
-#define MMU_SYSCONFIG		0x10
-#define MMU_SYSSTATUS		0x14
 #define MMU_IRQSTATUS		0x18
 #define MMU_IRQENABLE		0x1c
 #define MMU_WALKING_ST		0x40

commit 7bd9e25fa4e1eab0adb2632a0752e0835850dfb7
Author: Ido Yariv <ido@wizery.com>
Date:   Fri Nov 2 12:24:09 2012 -0700

    ARM: OMAP2+: Make some definitions local
    
    Move some of the definitions in omap-iommu.h that can be made local to
    either drivers/iommu.
    
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Cc: Mauro Carvalho Chehab <mchehab@infradead.org>
    Cc: Omar Ramirez Luna <omar.luna@linaro.org>
    Signed-off-by: Ido Yariv <ido@wizery.com>
    Acked-by: Ohad Ben-Cohen <ohad@wizery.com>
    Acked-by: Joerg Roedel <joro@8bytes.org>
    [tony@atomide.com: updated for header changes in the series]
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/drivers/iommu/omap-iommu.h b/drivers/iommu/omap-iommu.h
index 8c3378d99b81..2b5f3c04d167 100644
--- a/drivers/iommu/omap-iommu.h
+++ b/drivers/iommu/omap-iommu.h
@@ -72,11 +72,6 @@ struct cr_regs {
 	};
 };
 
-struct iotlb_lock {
-	short base;
-	short vict;
-};
-
 /* architecture specific functions */
 struct iommu_functions {
 	unsigned long	version;
@@ -117,13 +112,6 @@ static inline struct omap_iommu *dev_to_omap_iommu(struct device *dev)
 }
 #endif
 
-/* IOMMU errors */
-#define OMAP_IOMMU_ERR_TLB_MISS		(1 << 0)
-#define OMAP_IOMMU_ERR_TRANS_FAULT	(1 << 1)
-#define OMAP_IOMMU_ERR_EMU_MISS		(1 << 2)
-#define OMAP_IOMMU_ERR_TBLWALK_FAULT	(1 << 3)
-#define OMAP_IOMMU_ERR_MULTIHIT_FAULT	(1 << 4)
-
 /*
  * MMU Register offsets
  */
@@ -151,16 +139,6 @@ static inline struct omap_iommu *dev_to_omap_iommu(struct device *dev)
 /*
  * MMU Register bit definitions
  */
-#define MMU_LOCK_BASE_SHIFT	10
-#define MMU_LOCK_BASE_MASK	(0x1f << MMU_LOCK_BASE_SHIFT)
-#define MMU_LOCK_BASE(x)	\
-	((x & MMU_LOCK_BASE_MASK) >> MMU_LOCK_BASE_SHIFT)
-
-#define MMU_LOCK_VICT_SHIFT	4
-#define MMU_LOCK_VICT_MASK	(0x1f << MMU_LOCK_VICT_SHIFT)
-#define MMU_LOCK_VICT(x)	\
-	((x & MMU_LOCK_VICT_MASK) >> MMU_LOCK_VICT_SHIFT)
-
 #define MMU_CAM_VATAG_SHIFT	12
 #define MMU_CAM_VATAG_MASK \
 	((~0UL >> MMU_CAM_VATAG_SHIFT) << MMU_CAM_VATAG_SHIFT)
@@ -222,20 +200,15 @@ extern void omap_iotlb_cr_to_e(struct cr_regs *cr, struct iotlb_entry *e);
 extern int
 omap_iopgtable_store_entry(struct omap_iommu *obj, struct iotlb_entry *e);
 
-extern int omap_iommu_set_isr(const char *name,
-		 int (*isr)(struct omap_iommu *obj, u32 da, u32 iommu_errs,
-				    void *priv),
-			 void *isr_priv);
-
 extern void omap_iommu_save_ctx(struct device *dev);
 extern void omap_iommu_restore_ctx(struct device *dev);
 
-extern int omap_install_iommu_arch(const struct iommu_functions *ops);
-extern void omap_uninstall_iommu_arch(const struct iommu_functions *ops);
-
 extern int omap_foreach_iommu_device(void *data,
 				int (*fn)(struct device *, void *));
 
+extern int omap_install_iommu_arch(const struct iommu_functions *ops);
+extern void omap_uninstall_iommu_arch(const struct iommu_functions *ops);
+
 extern ssize_t
 omap_iommu_dump_ctx(struct omap_iommu *obj, char *buf, ssize_t len);
 extern size_t

commit ed1c7de29f9f3d56b3ca5ef69682cc1a3d369e9d
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri Nov 2 12:24:06 2012 -0700

    ARM: OMAP2+: Move iommu2 to drivers/iommu/omap-iommu2.c
    
    This file should not be in arch/arm. Move it to drivers/iommu
    to allow making most of the header local to drivers/iommu.
    
    This is needed as we are removing plat and mach includes
    from drivers for ARM common zImage support.
    
    Cc: Ido Yariv <ido@wizery.com>
    Cc: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Cc: Mauro Carvalho Chehab <mchehab@infradead.org>
    Cc: Omar Ramirez Luna <omar.luna@linaro.org>
    Cc: linux-media@vger.kernel.org
    Acked-by: Ohad Ben-Cohen <ohad@wizery.com>
    Acked-by: Joerg Roedel <joro@8bytes.org>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/drivers/iommu/omap-iommu.h b/drivers/iommu/omap-iommu.h
new file mode 100644
index 000000000000..8c3378d99b81
--- /dev/null
+++ b/drivers/iommu/omap-iommu.h
@@ -0,0 +1,255 @@
+/*
+ * omap iommu: main structures
+ *
+ * Copyright (C) 2008-2009 Nokia Corporation
+ *
+ * Written by Hiroshi DOYU <Hiroshi.DOYU@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#if defined(CONFIG_ARCH_OMAP1)
+#error "iommu for this processor not implemented yet"
+#endif
+
+struct iotlb_entry {
+	u32 da;
+	u32 pa;
+	u32 pgsz, prsvd, valid;
+	union {
+		u16 ap;
+		struct {
+			u32 endian, elsz, mixed;
+		};
+	};
+};
+
+struct omap_iommu {
+	const char	*name;
+	struct module	*owner;
+	struct clk	*clk;
+	void __iomem	*regbase;
+	struct device	*dev;
+	void		*isr_priv;
+	struct iommu_domain *domain;
+
+	unsigned int	refcount;
+	spinlock_t	iommu_lock;	/* global for this whole object */
+
+	/*
+	 * We don't change iopgd for a situation like pgd for a task,
+	 * but share it globally for each iommu.
+	 */
+	u32		*iopgd;
+	spinlock_t	page_table_lock; /* protect iopgd */
+
+	int		nr_tlb_entries;
+
+	struct list_head	mmap;
+	struct mutex		mmap_lock; /* protect mmap */
+
+	void *ctx; /* iommu context: registres saved area */
+	u32 da_start;
+	u32 da_end;
+};
+
+struct cr_regs {
+	union {
+		struct {
+			u16 cam_l;
+			u16 cam_h;
+		};
+		u32 cam;
+	};
+	union {
+		struct {
+			u16 ram_l;
+			u16 ram_h;
+		};
+		u32 ram;
+	};
+};
+
+struct iotlb_lock {
+	short base;
+	short vict;
+};
+
+/* architecture specific functions */
+struct iommu_functions {
+	unsigned long	version;
+
+	int (*enable)(struct omap_iommu *obj);
+	void (*disable)(struct omap_iommu *obj);
+	void (*set_twl)(struct omap_iommu *obj, bool on);
+	u32 (*fault_isr)(struct omap_iommu *obj, u32 *ra);
+
+	void (*tlb_read_cr)(struct omap_iommu *obj, struct cr_regs *cr);
+	void (*tlb_load_cr)(struct omap_iommu *obj, struct cr_regs *cr);
+
+	struct cr_regs *(*alloc_cr)(struct omap_iommu *obj,
+							struct iotlb_entry *e);
+	int (*cr_valid)(struct cr_regs *cr);
+	u32 (*cr_to_virt)(struct cr_regs *cr);
+	void (*cr_to_e)(struct cr_regs *cr, struct iotlb_entry *e);
+	ssize_t (*dump_cr)(struct omap_iommu *obj, struct cr_regs *cr,
+							char *buf);
+
+	u32 (*get_pte_attr)(struct iotlb_entry *e);
+
+	void (*save_ctx)(struct omap_iommu *obj);
+	void (*restore_ctx)(struct omap_iommu *obj);
+	ssize_t (*dump_ctx)(struct omap_iommu *obj, char *buf, ssize_t len);
+};
+
+#ifdef CONFIG_IOMMU_API
+/**
+ * dev_to_omap_iommu() - retrieves an omap iommu object from a user device
+ * @dev: iommu client device
+ */
+static inline struct omap_iommu *dev_to_omap_iommu(struct device *dev)
+{
+	struct omap_iommu_arch_data *arch_data = dev->archdata.iommu;
+
+	return arch_data->iommu_dev;
+}
+#endif
+
+/* IOMMU errors */
+#define OMAP_IOMMU_ERR_TLB_MISS		(1 << 0)
+#define OMAP_IOMMU_ERR_TRANS_FAULT	(1 << 1)
+#define OMAP_IOMMU_ERR_EMU_MISS		(1 << 2)
+#define OMAP_IOMMU_ERR_TBLWALK_FAULT	(1 << 3)
+#define OMAP_IOMMU_ERR_MULTIHIT_FAULT	(1 << 4)
+
+/*
+ * MMU Register offsets
+ */
+#define MMU_REVISION		0x00
+#define MMU_SYSCONFIG		0x10
+#define MMU_SYSSTATUS		0x14
+#define MMU_IRQSTATUS		0x18
+#define MMU_IRQENABLE		0x1c
+#define MMU_WALKING_ST		0x40
+#define MMU_CNTL		0x44
+#define MMU_FAULT_AD		0x48
+#define MMU_TTB			0x4c
+#define MMU_LOCK		0x50
+#define MMU_LD_TLB		0x54
+#define MMU_CAM			0x58
+#define MMU_RAM			0x5c
+#define MMU_GFLUSH		0x60
+#define MMU_FLUSH_ENTRY		0x64
+#define MMU_READ_CAM		0x68
+#define MMU_READ_RAM		0x6c
+#define MMU_EMU_FAULT_AD	0x70
+
+#define MMU_REG_SIZE		256
+
+/*
+ * MMU Register bit definitions
+ */
+#define MMU_LOCK_BASE_SHIFT	10
+#define MMU_LOCK_BASE_MASK	(0x1f << MMU_LOCK_BASE_SHIFT)
+#define MMU_LOCK_BASE(x)	\
+	((x & MMU_LOCK_BASE_MASK) >> MMU_LOCK_BASE_SHIFT)
+
+#define MMU_LOCK_VICT_SHIFT	4
+#define MMU_LOCK_VICT_MASK	(0x1f << MMU_LOCK_VICT_SHIFT)
+#define MMU_LOCK_VICT(x)	\
+	((x & MMU_LOCK_VICT_MASK) >> MMU_LOCK_VICT_SHIFT)
+
+#define MMU_CAM_VATAG_SHIFT	12
+#define MMU_CAM_VATAG_MASK \
+	((~0UL >> MMU_CAM_VATAG_SHIFT) << MMU_CAM_VATAG_SHIFT)
+#define MMU_CAM_P		(1 << 3)
+#define MMU_CAM_V		(1 << 2)
+#define MMU_CAM_PGSZ_MASK	3
+#define MMU_CAM_PGSZ_1M		(0 << 0)
+#define MMU_CAM_PGSZ_64K	(1 << 0)
+#define MMU_CAM_PGSZ_4K		(2 << 0)
+#define MMU_CAM_PGSZ_16M	(3 << 0)
+
+#define MMU_RAM_PADDR_SHIFT	12
+#define MMU_RAM_PADDR_MASK \
+	((~0UL >> MMU_RAM_PADDR_SHIFT) << MMU_RAM_PADDR_SHIFT)
+
+#define MMU_RAM_ENDIAN_MASK	(1 << MMU_RAM_ENDIAN_SHIFT)
+#define MMU_RAM_ENDIAN_BIG	(1 << MMU_RAM_ENDIAN_SHIFT)
+
+#define MMU_RAM_ELSZ_MASK	(3 << MMU_RAM_ELSZ_SHIFT)
+#define MMU_RAM_ELSZ_8		(0 << MMU_RAM_ELSZ_SHIFT)
+#define MMU_RAM_ELSZ_16		(1 << MMU_RAM_ELSZ_SHIFT)
+#define MMU_RAM_ELSZ_32		(2 << MMU_RAM_ELSZ_SHIFT)
+#define MMU_RAM_ELSZ_NONE	(3 << MMU_RAM_ELSZ_SHIFT)
+#define MMU_RAM_MIXED_SHIFT	6
+#define MMU_RAM_MIXED_MASK	(1 << MMU_RAM_MIXED_SHIFT)
+#define MMU_RAM_MIXED		MMU_RAM_MIXED_MASK
+
+/*
+ * utilities for super page(16MB, 1MB, 64KB and 4KB)
+ */
+
+#define iopgsz_max(bytes)			\
+	(((bytes) >= SZ_16M) ? SZ_16M :		\
+	 ((bytes) >= SZ_1M)  ? SZ_1M  :		\
+	 ((bytes) >= SZ_64K) ? SZ_64K :		\
+	 ((bytes) >= SZ_4K)  ? SZ_4K  :	0)
+
+#define bytes_to_iopgsz(bytes)				\
+	(((bytes) == SZ_16M) ? MMU_CAM_PGSZ_16M :	\
+	 ((bytes) == SZ_1M)  ? MMU_CAM_PGSZ_1M  :	\
+	 ((bytes) == SZ_64K) ? MMU_CAM_PGSZ_64K :	\
+	 ((bytes) == SZ_4K)  ? MMU_CAM_PGSZ_4K  : -1)
+
+#define iopgsz_to_bytes(iopgsz)				\
+	(((iopgsz) == MMU_CAM_PGSZ_16M)	? SZ_16M :	\
+	 ((iopgsz) == MMU_CAM_PGSZ_1M)	? SZ_1M  :	\
+	 ((iopgsz) == MMU_CAM_PGSZ_64K)	? SZ_64K :	\
+	 ((iopgsz) == MMU_CAM_PGSZ_4K)	? SZ_4K  : 0)
+
+#define iopgsz_ok(bytes) (bytes_to_iopgsz(bytes) >= 0)
+
+/*
+ * global functions
+ */
+extern u32 omap_iommu_arch_version(void);
+
+extern void omap_iotlb_cr_to_e(struct cr_regs *cr, struct iotlb_entry *e);
+
+extern int
+omap_iopgtable_store_entry(struct omap_iommu *obj, struct iotlb_entry *e);
+
+extern int omap_iommu_set_isr(const char *name,
+		 int (*isr)(struct omap_iommu *obj, u32 da, u32 iommu_errs,
+				    void *priv),
+			 void *isr_priv);
+
+extern void omap_iommu_save_ctx(struct device *dev);
+extern void omap_iommu_restore_ctx(struct device *dev);
+
+extern int omap_install_iommu_arch(const struct iommu_functions *ops);
+extern void omap_uninstall_iommu_arch(const struct iommu_functions *ops);
+
+extern int omap_foreach_iommu_device(void *data,
+				int (*fn)(struct device *, void *));
+
+extern ssize_t
+omap_iommu_dump_ctx(struct omap_iommu *obj, char *buf, ssize_t len);
+extern size_t
+omap_dump_tlb_entries(struct omap_iommu *obj, char *buf, ssize_t len);
+
+/*
+ * register accessors
+ */
+static inline u32 iommu_read_reg(struct omap_iommu *obj, size_t offs)
+{
+	return __raw_readl(obj->regbase + offs);
+}
+
+static inline void iommu_write_reg(struct omap_iommu *obj, u32 val, size_t offs)
+{
+	__raw_writel(val, obj->regbase + offs);
+}
