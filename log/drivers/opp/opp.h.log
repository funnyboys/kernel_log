commit 8d45719caaf56c859be0172447f8559c0df40f93
Author: Kamil Konieczny <k.konieczny@samsung.com>
Date:   Fri Jul 19 17:05:32 2019 +0200

    opp: core: add regulators enable and disable
    
    Add enable regulators to dev_pm_opp_set_regulators() and disable
    regulators to dev_pm_opp_put_regulators(). Even if bootloader
    leaves regulators enabled, they should be enabled in kernel in
    order to increase the reference count.
    
    Tested-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Acked-by: Clément Péron <peron.clem@gmail.com>
    Tested-by: Clément Péron <peron.clem@gmail.com>
    Signed-off-by: Kamil Konieczny <k.konieczny@samsung.com>
    [ Viresh: Enable the regulator only after it is programmed and add a
              flag to track its status. ]
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/drivers/opp/opp.h b/drivers/opp/opp.h
index 2b81ffef1ba4..e51646ff279e 100644
--- a/drivers/opp/opp.h
+++ b/drivers/opp/opp.h
@@ -147,6 +147,7 @@ enum opp_table_access {
  * @clk: Device's clock handle
  * @regulators: Supply regulators
  * @regulator_count: Number of power supply regulators. Its value can be -1
+ * @regulator_enabled: Set to true if regulators were previously enabled.
  * (uninitialized), 0 (no opp-microvolt property) or > 0 (has opp-microvolt
  * property).
  * @paths: Interconnect path handles
@@ -194,6 +195,7 @@ struct opp_table {
 	struct clk *clk;
 	struct regulator **regulators;
 	int regulator_count;
+	bool regulator_enabled;
 	struct icc_path **paths;
 	unsigned int path_count;
 	bool genpd_performance_state;

commit 6d3f922c46f2e91f63c92f8dd28381f097082912
Author: Georgi Djakov <georgi.djakov@linaro.org>
Date:   Tue May 12 15:53:21 2020 +0300

    opp: Add support for parsing interconnect bandwidth
    
    The OPP bindings now support bandwidth values, so add support to parse it
    from device tree and store it into the new dev_pm_opp_icc_bw struct, which
    is part of the dev_pm_opp.
    
    Signed-off-by: Georgi Djakov <georgi.djakov@linaro.org>
    Reviewed-by: Matthias Kaehlcke <mka@chromium.org>
    [ Viresh: Create _read_bw() and use it, renamed _of_find_icc_paths() to
              dev_pm_opp_of_find_icc_paths(), exported it and made opp_table
              argument optional. Also drop the depends on from Kconfig. ]
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/drivers/opp/opp.h b/drivers/opp/opp.h
index bcadb1e328a4..2b81ffef1ba4 100644
--- a/drivers/opp/opp.h
+++ b/drivers/opp/opp.h
@@ -12,6 +12,7 @@
 #define __DRIVER_OPP_H__
 
 #include <linux/device.h>
+#include <linux/interconnect.h>
 #include <linux/kernel.h>
 #include <linux/kref.h>
 #include <linux/list.h>
@@ -59,6 +60,7 @@ extern struct list_head opp_tables;
  * @rate:	Frequency in hertz
  * @level:	Performance level
  * @supplies:	Power supplies voltage/current values
+ * @bandwidth:	Interconnect bandwidth values
  * @clock_latency_ns: Latency (in nanoseconds) of switching to this OPP's
  *		frequency from any other OPP's frequency.
  * @required_opps: List of OPPs that are required by this OPP.
@@ -81,6 +83,7 @@ struct dev_pm_opp {
 	unsigned int level;
 
 	struct dev_pm_opp_supply *supplies;
+	struct dev_pm_opp_icc_bw *bandwidth;
 
 	unsigned long clock_latency_ns;
 
@@ -146,6 +149,8 @@ enum opp_table_access {
  * @regulator_count: Number of power supply regulators. Its value can be -1
  * (uninitialized), 0 (no opp-microvolt property) or > 0 (has opp-microvolt
  * property).
+ * @paths: Interconnect path handles
+ * @path_count: Number of interconnect paths
  * @genpd_performance_state: Device's power domain support performance state.
  * @is_genpd: Marks if the OPP table belongs to a genpd.
  * @set_opp: Platform specific set_opp callback
@@ -189,6 +194,8 @@ struct opp_table {
 	struct clk *clk;
 	struct regulator **regulators;
 	int regulator_count;
+	struct icc_path **paths;
+	unsigned int path_count;
 	bool genpd_performance_state;
 	bool is_genpd;
 

commit 6c591eec67cbb4db988ab35b944f5cf9013c0714
Author: Saravana Kannan <saravanak@google.com>
Date:   Tue May 12 15:53:19 2020 +0300

    OPP: Add helpers for reading the binding properties
    
    The opp-hz DT property is not mandatory and we may use another property
    as a key in the OPP table. Add helper functions to simplify the reading
    and comparing the keys.
    
    Signed-off-by: Saravana Kannan <saravanak@google.com>
    Signed-off-by: Georgi Djakov <georgi.djakov@linaro.org>
    Reviewed-by: Matthias Kaehlcke <mka@chromium.org>
    Reviewed-by: Sibi Sankar <sibis@codeaurora.org>
    [ Viresh: Removed an unnecessary comment ]
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/drivers/opp/opp.h b/drivers/opp/opp.h
index d14e27102730..bcadb1e328a4 100644
--- a/drivers/opp/opp.h
+++ b/drivers/opp/opp.h
@@ -211,6 +211,7 @@ struct opp_device *_add_opp_dev(const struct device *dev, struct opp_table *opp_
 void _dev_pm_opp_find_and_remove_table(struct device *dev);
 struct dev_pm_opp *_opp_allocate(struct opp_table *opp_table);
 void _opp_free(struct dev_pm_opp *opp);
+int _opp_compare_key(struct dev_pm_opp *opp1, struct dev_pm_opp *opp2);
 int _opp_add(struct device *dev, struct dev_pm_opp *new_opp, struct opp_table *opp_table, bool rate_not_available);
 int _opp_add_v1(struct opp_table *opp_table, struct device *dev, unsigned long freq, long u_volt, bool dynamic);
 void _dev_pm_opp_cpumask_remove_table(const struct cpumask *cpumask, int last_cpu);

commit 03758d60265c773e1d06d436b99ee338f2ac55d6
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon Nov 11 16:35:03 2019 +0530

    opp: Replace list_kref with a local counter
    
    A kref or refcount isn't the right tool to be used here for counting
    number of devices that are sharing the static OPPs created for the OPP
    table. For example, we are reinitializing the kref again, after it
    reaches a value of 0 and frees the resources, if the static OPPs get
    added for the same OPP table structure (as the OPP table structure was
    never freed). That is messy and very unclear.
    
    This patch makes parsed_static_opps an unsigned integer and uses it to
    count the number of users of the static OPPs. The increment and
    decrement to parsed_static_opps is done under opp_table->lock now to
    make sure no races are possible if the OPP table is getting added and
    removed in parallel (which doesn't happen in practice, but can in
    theory).
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/drivers/opp/opp.h b/drivers/opp/opp.h
index 01a500e2c40a..d14e27102730 100644
--- a/drivers/opp/opp.h
+++ b/drivers/opp/opp.h
@@ -127,11 +127,10 @@ enum opp_table_access {
  * @dev_list:	list of devices that share these OPPs
  * @opp_list:	table of opps
  * @kref:	for reference count of the table.
- * @list_kref:	for reference count of the OPP list.
  * @lock:	mutex protecting the opp_list and dev_list.
  * @np:		struct device_node pointer for opp's DT node.
  * @clock_latency_ns_max: Max clock latency in nanoseconds.
- * @parsed_static_opps: True if OPPs are initialized from DT.
+ * @parsed_static_opps: Count of devices for which OPPs are initialized from DT.
  * @shared_opp: OPP is shared between multiple devices.
  * @suspend_opp: Pointer to OPP to be used during device suspend.
  * @genpd_virt_dev_lock: Mutex protecting the genpd virtual device pointers.
@@ -167,7 +166,6 @@ struct opp_table {
 	struct list_head dev_list;
 	struct list_head opp_list;
 	struct kref kref;
-	struct kref list_kref;
 	struct mutex lock;
 
 	struct device_node *np;
@@ -176,7 +174,7 @@ struct opp_table {
 	/* For backward compatibility with v1 bindings */
 	unsigned int voltage_tolerance_v1;
 
-	bool parsed_static_opps;
+	unsigned int parsed_static_opps;
 	enum opp_table_access shared_opp;
 	struct dev_pm_opp *suspend_opp;
 

commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/opp/opp.h b/drivers/opp/opp.h
index 569b3525aa67..01a500e2c40a 100644
--- a/drivers/opp/opp.h
+++ b/drivers/opp/opp.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * Generic OPP Interface
  *
@@ -5,10 +6,6 @@
  *	Nishanth Menon
  *	Romit Dasgupta
  *	Kevin Hilman
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
  */
 
 #ifndef __DRIVER_OPP_H__

commit ef8006846a3a97d9d8bf49e63dba948d0d2dbbf0
Merge: 8dcd175bc3d5 1271d6d576b7
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Mar 6 12:59:46 2019 -0800

    Merge tag 'pm-5.1-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull power management updates from Rafael Wysocki:
     "These are PM-runtime framework changes to use ktime instead of jiffies
      for accounting, new PM core flag to mark devices that don't need any
      form of power management, cpuidle updates including driver API
      documentation and a new governor, cpufreq updates including a new
      driver for Armada 8K, thermal cleanups and more, some energy-aware
      scheduling (EAS) enabling changes, new chips support in the intel_idle
      and RAPL drivers and assorted cleanups in some other places.
    
      Specifics:
    
       - Update the PM-runtime framework to use ktime instead of jiffies for
         accounting (Thara Gopinath, Vincent Guittot)
    
       - Optimize the autosuspend code in the PM-runtime framework somewhat
         (Ladislav Michl)
    
       - Add a PM core flag to mark devices that don't need any form of
         power management (Sudeep Holla)
    
       - Introduce driver API documentation for cpuidle and add a new
         cpuidle governor for tickless systems (Rafael Wysocki)
    
       - Add Jacobsville support to the intel_idle driver (Zhang Rui)
    
       - Clean up a cpuidle core header file and the cpuidle-dt and ACPI
         processor-idle drivers (Yangtao Li, Joseph Lo, Yazen Ghannam)
    
       - Add new cpufreq driver for Armada 8K (Gregory Clement)
    
       - Fix and clean up cpufreq core (Rafael Wysocki, Viresh Kumar, Amit
         Kucheria)
    
       - Add support for light-weight tear-down and bring-up of CPUs to the
         cpufreq core and use it in the cpufreq-dt driver (Viresh Kumar)
    
       - Fix cpu_cooling Kconfig dependencies, add support for CPU cooling
         auto-registration to the cpufreq core and use it in multiple
         cpufreq drivers (Amit Kucheria)
    
       - Fix some minor issues and do some cleanups in the davinci,
         e_powersaver, ap806, s5pv210, qcom and kryo cpufreq drivers
         (Bartosz Golaszewski, Gustavo Silva, Julia Lawall, Paweł Chmiel,
         Taniya Das, Viresh Kumar)
    
       - Add a Hisilicon CPPC quirk to the cppc_cpufreq driver (Xiongfeng
         Wang)
    
       - Clean up the intel_pstate and acpi-cpufreq drivers (Erwan Velu,
         Rafael Wysocki)
    
       - Clean up multiple cpufreq drivers (Yangtao Li)
    
       - Update cpufreq-related MAINTAINERS entries (Baruch Siach, Lukas
         Bulwahn)
    
       - Add support for exposing the Energy Model via debugfs and make
         multiple cpufreq drivers register an Energy Model to support
         energy-aware scheduling (Quentin Perret, Dietmar Eggemann, Matthias
         Kaehlcke)
    
       - Add Ice Lake mobile and Jacobsville support to the Intel RAPL
         power-capping driver (Gayatri Kammela, Zhang Rui)
    
       - Add a power estimation helper to the operating performance points
         (OPP) framework and clean up a core function in it (Quentin Perret,
         Viresh Kumar)
    
       - Make minor improvements in the generic power domains (genpd), OPP
         and system suspend frameworks and in the PM core (Aditya Pakki,
         Douglas Anderson, Greg Kroah-Hartman, Rafael Wysocki, Yangtao Li)"
    
    * tag 'pm-5.1-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (80 commits)
      cpufreq: kryo: Release OPP tables on module removal
      cpufreq: ap806: add missing of_node_put after of_device_is_available
      cpufreq: acpi-cpufreq: Report if CPU doesn't support boost technologies
      cpufreq: Pass updated policy to driver ->setpolicy() callback
      cpufreq: Fix two debug messages in cpufreq_set_policy()
      cpufreq: Reorder and simplify cpufreq_update_policy()
      cpufreq: Add kerneldoc comments for two core functions
      PM / core: Add support to skip power management in device/driver model
      cpufreq: intel_pstate: Rework iowait boosting to be less aggressive
      cpufreq: intel_pstate: Eliminate intel_pstate_get_base_pstate()
      cpufreq: intel_pstate: Avoid redundant initialization of local vars
      powercap/intel_rapl: add Ice Lake mobile
      ACPI / processor: Set P_LVL{2,3} idle state descriptions
      cpufreq / cppc: Work around for Hisilicon CPPC cpufreq
      ACPI / CPPC: Add a helper to get desired performance
      cpufreq: davinci: move configuration to include/linux/platform_data
      cpufreq: speedstep: convert BUG() to BUG_ON()
      cpufreq: powernv: fix missing check of return value in init_powernv_pstates()
      cpufreq: longhaul: remove unneeded semicolon
      cpufreq: pcc-cpufreq: remove unneeded semicolon
      ..

commit a2dea4cb907022447298d46b15a5c41f3f9903e6
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Jan 22 16:21:17 2019 +0100

    opp: no need to check return value of debugfs_create functions
    
    When calling debugfs functions, there is no need to ever check the
    return value.  The function can work or not, but the code logic should
    never do something different based on this.
    
    Cc: Viresh Kumar <vireshk@kernel.org>
    Cc: Nishanth Menon <nm@ti.com>
    Cc: Stephen Boyd <sboyd@kernel.org>
    Cc: linux-pm@vger.kernel.org
    Reviewed-by: Stephen Boyd <sboyd@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/drivers/opp/opp.h b/drivers/opp/opp.h
index e24d81497375..810a85b9a66d 100644
--- a/drivers/opp/opp.h
+++ b/drivers/opp/opp.h
@@ -236,18 +236,17 @@ static inline void _of_opp_free_required_opps(struct opp_table *opp_table,
 
 #ifdef CONFIG_DEBUG_FS
 void opp_debug_remove_one(struct dev_pm_opp *opp);
-int opp_debug_create_one(struct dev_pm_opp *opp, struct opp_table *opp_table);
-int opp_debug_register(struct opp_device *opp_dev, struct opp_table *opp_table);
+void opp_debug_create_one(struct dev_pm_opp *opp, struct opp_table *opp_table);
+void opp_debug_register(struct opp_device *opp_dev, struct opp_table *opp_table);
 void opp_debug_unregister(struct opp_device *opp_dev, struct opp_table *opp_table);
 #else
 static inline void opp_debug_remove_one(struct dev_pm_opp *opp) {}
 
-static inline int opp_debug_create_one(struct dev_pm_opp *opp,
-				       struct opp_table *opp_table)
-{ return 0; }
-static inline int opp_debug_register(struct opp_device *opp_dev,
-				     struct opp_table *opp_table)
-{ return 0; }
+static inline void opp_debug_create_one(struct dev_pm_opp *opp,
+					struct opp_table *opp_table) { }
+
+static inline void opp_debug_register(struct opp_device *opp_dev,
+				      struct opp_table *opp_table) { }
 
 static inline void opp_debug_unregister(struct opp_device *opp_dev,
 					struct opp_table *opp_table)

commit 5b93ac542301026eff8954589cf59f801d03db3e
Author: Rajendra Nayak <rnayak@codeaurora.org>
Date:   Thu Jan 10 09:32:02 2019 +0530

    OPP: Add support for parsing the 'opp-level' property
    
    Now that the OPP bindings are updated to include an optional
    'opp-level' property, add support to parse it from device tree
    and store it as part of dev_pm_opp structure.
    Also add and export an helper 'dev_pm_opp_get_level()' that can be
    used to get the level value read from device tree when present.
    
    Reviewed-by: Stephen Boyd <swboyd@chromium.org>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rajendra Nayak <rnayak@codeaurora.org>
    Signed-off-by: Bjorn Andersson <bjorn.andersson@linaro.org>
    Signed-off-by: Andy Gross <andy.gross@linaro.org>

diff --git a/drivers/opp/opp.h b/drivers/opp/opp.h
index e24d81497375..4458175aa661 100644
--- a/drivers/opp/opp.h
+++ b/drivers/opp/opp.h
@@ -60,6 +60,7 @@ extern struct list_head opp_tables;
  * @suspend:	true if suspend OPP
  * @pstate: Device's power domain's performance state.
  * @rate:	Frequency in hertz
+ * @level:	Performance level
  * @supplies:	Power supplies voltage/current values
  * @clock_latency_ns: Latency (in nanoseconds) of switching to this OPP's
  *		frequency from any other OPP's frequency.
@@ -80,6 +81,7 @@ struct dev_pm_opp {
 	bool suspend;
 	unsigned int pstate;
 	unsigned long rate;
+	unsigned int level;
 
 	struct dev_pm_opp_supply *supplies;
 

commit ade0c9493e972171103c7d804840248c32032954
Merge: 46f48aca2e5a 18edf49c4554
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Dec 14 16:28:52 2018 +0530

    Merge branch 'opp/genpd/propagation' into opp/linux-next

commit 46f48aca2e5aef3f430e95d1a5fb68227ec8ec85
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Dec 11 16:39:36 2018 +0530

    OPP: Fix missing debugfs supply directory for OPPs
    
    There is one case where we may end up with no "supply" directory for the
    OPPs in debugfs. That happens when the OPP core isn't managing the
    regulators for the device and the device's OPP do have microvolt
    property. It happens because the opp_table->regulator_count remains set
    to 0 and the debugfs routines don't add any supply directory in such a
    case.
    
    This commit fixes that by setting opp_table->regulator_count to 1 in
    that particular case. But to make everything work nicely and not break
    other parts of the core, regulator_count is defined as "int" now instead
    of "unsigned int" and it can have different special values now. It is
    set to -1 initially to mark it "uninitialized" and later only we set it
    to 0 or positive values after checking how many supplies are there.
    
    This also helps in finding the bugs where only few of the OPPs have the
    "opp-microvolt" property set and not all.
    
    Fixes: 1fae788ed640 ("PM / OPP: Don't create debugfs "supply-0" directory unnecessarily")
    Reported-by: Quentin Perret <quentin.perret@arm.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/drivers/opp/opp.h b/drivers/opp/opp.h
index 9c6544b4f4f9..14d732ccad08 100644
--- a/drivers/opp/opp.h
+++ b/drivers/opp/opp.h
@@ -138,7 +138,9 @@ enum opp_table_access {
  * @prop_name: A name to postfix to many DT properties, while parsing them.
  * @clk: Device's clock handle
  * @regulators: Supply regulators
- * @regulator_count: Number of power supply regulators
+ * @regulator_count: Number of power supply regulators. Its value can be -1
+ * (uninitialized), 0 (no opp-microvolt property) or > 0 (has opp-microvolt
+ * property).
  * @genpd_performance_state: Device's power domain support performance state.
  * @set_opp: Platform specific set_opp callback
  * @set_opp_data: Data to be passed to set_opp callback
@@ -176,7 +178,7 @@ struct opp_table {
 	const char *prop_name;
 	struct clk *clk;
 	struct regulator **regulators;
-	unsigned int regulator_count;
+	int regulator_count;
 	bool genpd_performance_state;
 
 	int (*set_opp)(struct dev_pm_set_opp_data *data);

commit 4f018bc0e1cfdec2e25072db9fecc1f363ba79ea
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Jun 26 16:29:34 2018 +0530

    OPP: Add dev_pm_opp_{set|put}_genpd_virt_dev() helper
    
    Multiple generic power domains for a consumer device are supported with
    the help of virtual devices, which are created for each consumer device
    - genpd pair. These are the device structures which are attached to the
    power domain and are required by the OPP core to set the performance
    state of the genpd.
    
    The helpers added by this commit are required to be called once for each
    of these virtual devices. These are required only if multiple domains
    are available for a device, otherwise the actual device structure will
    be used instead by the OPP core.
    
    The new helpers also support the complex cases where the consumer device
    wouldn't always require all the domains. For example, a camera may
    require only one power domain during normal operations but two during
    high resolution operations. The consumer driver can call
    dev_pm_opp_put_genpd_virt_dev(high_resolution_genpd_virt_dev) if it is
    currently operating in the normal mode and doesn't have any performance
    requirements from the genpd which manages high resolution power
    requirements. The consumer driver can later call
    dev_pm_opp_set_genpd_virt_dev(high_resolution_genpd_virt_dev) once it
    switches back to the high resolution mode.
    
    The new helpers differ from other OPP set/put helpers as the new ones
    can be called with OPPs initialized for the table as we may need to call
    them on the fly because of the complex case explained above. For this
    reason it is possible that the genpd virt_dev structure may be used in
    parallel while the new helpers are running and a new mutex is added to
    protect against that. We didn't use the existing opp_table->lock mutex
    as that is widely used in the OPP core and we will need this lock in the
    dev_pm_opp_set_rate() helper while changing OPP and we need to make sure
    there is not much contention while doing that as that's the hotpath.
    
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/drivers/opp/opp.h b/drivers/opp/opp.h
index 24b340ad18d1..8aec38792cae 100644
--- a/drivers/opp/opp.h
+++ b/drivers/opp/opp.h
@@ -135,6 +135,8 @@ enum opp_table_access {
  * @parsed_static_opps: True if OPPs are initialized from DT.
  * @shared_opp: OPP is shared between multiple devices.
  * @suspend_opp: Pointer to OPP to be used during device suspend.
+ * @genpd_virt_dev_lock: Mutex protecting the genpd virtual device pointers.
+ * @genpd_virt_devs: List of virtual devices for multiple genpd support.
  * @required_opp_tables: List of device OPP tables that are required by OPPs in
  *		this table.
  * @required_opp_count: Number of required devices.
@@ -177,6 +179,8 @@ struct opp_table {
 	enum opp_table_access shared_opp;
 	struct dev_pm_opp *suspend_opp;
 
+	struct mutex genpd_virt_dev_lock;
+	struct device **genpd_virt_devs;
 	struct opp_table **required_opp_tables;
 	unsigned int required_opp_count;
 

commit da544b61eb5541db8827af0beab618daead88a34
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jun 7 14:50:43 2018 +0530

    OPP: Populate OPPs from "required-opps" property
    
    An earlier commit populated the OPP tables from the "required-opps"
    property, this commit populates the individual OPPs. This is repeated
    for each OPP in the OPP table and these populated OPPs will be used by
    later commits.
    
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/drivers/opp/opp.h b/drivers/opp/opp.h
index 024e1be23d37..24b340ad18d1 100644
--- a/drivers/opp/opp.h
+++ b/drivers/opp/opp.h
@@ -63,6 +63,7 @@ extern struct list_head opp_tables;
  * @supplies:	Power supplies voltage/current values
  * @clock_latency_ns: Latency (in nanoseconds) of switching to this OPP's
  *		frequency from any other OPP's frequency.
+ * @required_opps: List of OPPs that are required by this OPP.
  * @opp_table:	points back to the opp_table struct this opp belongs to
  * @np:		OPP's device node.
  * @dentry:	debugfs dentry pointer (per opp)
@@ -84,6 +85,7 @@ struct dev_pm_opp {
 
 	unsigned long clock_latency_ns;
 
+	struct dev_pm_opp **required_opps;
 	struct opp_table *opp_table;
 
 	struct device_node *np;
@@ -216,10 +218,14 @@ void _put_opp_list_kref(struct opp_table *opp_table);
 void _of_init_opp_table(struct opp_table *opp_table, struct device *dev, int index);
 void _of_clear_opp_table(struct opp_table *opp_table);
 struct opp_table *_managed_opp(struct device *dev, int index);
+void _of_opp_free_required_opps(struct opp_table *opp_table,
+				struct dev_pm_opp *opp);
 #else
 static inline void _of_init_opp_table(struct opp_table *opp_table, struct device *dev, int index) {}
 static inline void _of_clear_opp_table(struct opp_table *opp_table) {}
 static inline struct opp_table *_managed_opp(struct device *dev, int index) { return NULL; }
+static inline void _of_opp_free_required_opps(struct opp_table *opp_table,
+					      struct dev_pm_opp *opp) {}
 #endif
 
 #ifdef CONFIG_DEBUG_FS

commit 5d6d106fa45501ea6494a8653adbf2bee4a6f803
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jun 7 14:50:43 2018 +0530

    OPP: Populate required opp tables from "required-opps" property
    
    The current implementation works only for the case where a single
    phandle is present in the "required-opps" property, while DT allows
    multiple phandles to be present there.
    
    This patch adds new infrastructure to parse all the phandles present in
    "required-opps" property and save pointers of the required OPP's OPP
    tables. These will be used by later commits.
    
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/drivers/opp/opp.h b/drivers/opp/opp.h
index cdb0c2b095e2..024e1be23d37 100644
--- a/drivers/opp/opp.h
+++ b/drivers/opp/opp.h
@@ -133,6 +133,9 @@ enum opp_table_access {
  * @parsed_static_opps: True if OPPs are initialized from DT.
  * @shared_opp: OPP is shared between multiple devices.
  * @suspend_opp: Pointer to OPP to be used during device suspend.
+ * @required_opp_tables: List of device OPP tables that are required by OPPs in
+ *		this table.
+ * @required_opp_count: Number of required devices.
  * @supported_hw: Array of version number to support.
  * @supported_hw_count: Number of elements in supported_hw array.
  * @prop_name: A name to postfix to many DT properties, while parsing them.
@@ -172,6 +175,9 @@ struct opp_table {
 	enum opp_table_access shared_opp;
 	struct dev_pm_opp *suspend_opp;
 
+	struct opp_table **required_opp_tables;
+	unsigned int required_opp_count;
+
 	unsigned int *supported_hw;
 	unsigned int supported_hw_count;
 	const char *prop_name;
@@ -208,9 +214,11 @@ void _put_opp_list_kref(struct opp_table *opp_table);
 
 #ifdef CONFIG_OF
 void _of_init_opp_table(struct opp_table *opp_table, struct device *dev, int index);
+void _of_clear_opp_table(struct opp_table *opp_table);
 struct opp_table *_managed_opp(struct device *dev, int index);
 #else
 static inline void _of_init_opp_table(struct opp_table *opp_table, struct device *dev, int index) {}
+static inline void _of_clear_opp_table(struct opp_table *opp_table) {}
 static inline struct opp_table *_managed_opp(struct device *dev, int index) { return NULL; }
 #endif
 

commit 61d8e7c73b0b55a529fe7e9cb0cccccf50ee967a
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed Jun 13 16:00:11 2018 +0530

    OPP: Identify and mark genpd OPP tables
    
    We need to handle genpd OPP tables differently, this is already the case
    at one location and will be extended going forward. Add another field to
    the OPP table to check if the table belongs to a genpd or not.
    
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/drivers/opp/opp.h b/drivers/opp/opp.h
index 9c6544b4f4f9..cdb0c2b095e2 100644
--- a/drivers/opp/opp.h
+++ b/drivers/opp/opp.h
@@ -140,6 +140,7 @@ enum opp_table_access {
  * @regulators: Supply regulators
  * @regulator_count: Number of power supply regulators
  * @genpd_performance_state: Device's power domain support performance state.
+ * @is_genpd: Marks if the OPP table belongs to a genpd.
  * @set_opp: Platform specific set_opp callback
  * @set_opp_data: Data to be passed to set_opp callback
  * @dentry:	debugfs dentry pointer of the real device directory (not links).
@@ -178,6 +179,7 @@ struct opp_table {
 	struct regulator **regulators;
 	unsigned int regulator_count;
 	bool genpd_performance_state;
+	bool is_genpd;
 
 	int (*set_opp)(struct dev_pm_set_opp_data *data);
 	struct dev_pm_set_opp_data *set_opp_data;

commit 283d55e68d8a0f302057f57dcbd4d2e000c2ac85
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Sep 7 09:01:54 2018 +0530

    OPP: Prevent creating multiple OPP tables for devices sharing OPP nodes
    
    When two or more devices are sharing their clock and voltage rails, they
    share the same OPP table. But there are some corner cases where the OPP
    core incorrectly creates separate OPP tables for them.
    
    For example, CPU 0 and 1 share clock/voltage rails. The platform
    specific code calls dev_pm_opp_set_regulators() for CPU0 and the OPP
    core creates an OPP table for it (the individual OPPs aren't initialized
    as of now). The same is repeated for CPU1 then. Because
    _opp_get_opp_table() doesn't compare DT node pointers currently, it
    fails to find the link between CPU0 and CPU1 and so creates a new OPP
    table.
    
    Fix this by calling _managed_opp() from _opp_get_opp_table().
    _managed_opp() gain an additional argument (index) to get the right node
    pointer. This resulted in simplifying code in _of_add_opp_table_v2() as
    well.
    
    Tested-by: Niklas Cassel <niklas.cassel@linaro.org>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/drivers/opp/opp.h b/drivers/opp/opp.h
index f9fbb7553fc4..9c6544b4f4f9 100644
--- a/drivers/opp/opp.h
+++ b/drivers/opp/opp.h
@@ -206,8 +206,10 @@ void _put_opp_list_kref(struct opp_table *opp_table);
 
 #ifdef CONFIG_OF
 void _of_init_opp_table(struct opp_table *opp_table, struct device *dev, int index);
+struct opp_table *_managed_opp(struct device *dev, int index);
 #else
 static inline void _of_init_opp_table(struct opp_table *opp_table, struct device *dev, int index) {}
+static inline struct opp_table *_managed_opp(struct device *dev, int index) { return NULL; }
 #endif
 
 #ifdef CONFIG_DEBUG_FS

commit cdd6ed90cdb6c2fd982909501f0a109274147fb4
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed Sep 12 12:35:19 2018 +0530

    OPP: Use a single mechanism to free the OPP table
    
    Currently there are two separate ways to free the OPP table based on how
    it is created in the first place.
    
    We call _dev_pm_opp_remove_table() to free the static and/or dynamic
    OPP, OPP list devices, etc. This is done for the case where the OPP
    table is added while initializing the OPPs, like via the path
    dev_pm_opp_of_add_table().
    
    We also call dev_pm_opp_put_opp_table() in some cases which eventually
    frees the OPP table structure once the reference count reaches 0. This
    is used by the first case as well as other cases like
    dev_pm_opp_set_regulators() where the OPPs aren't necessarily
    initialized at this point.
    
    This whole thing is a bit unclear and messy and obstruct any further
    cleanup/fixup of OPP core.
    
    This patch tries to streamline this by keeping a single path for OPP
    table destruction, i.e. dev_pm_opp_put_opp_table().
    
    All the cleanup happens in _opp_table_kref_release() now after the
    reference count reaches 0. _dev_pm_opp_remove_table() is removed as it
    isn't required anymore.
    
    We don't drop the reference to the OPP table after creating it from
    _of_add_opp_table_v{1|2}() anymore and the same is dropped only when we
    try to remove them.
    
    Tested-by: Niklas Cassel <niklas.cassel@linaro.org>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/drivers/opp/opp.h b/drivers/opp/opp.h
index 98dd7d39e1ad..f9fbb7553fc4 100644
--- a/drivers/opp/opp.h
+++ b/drivers/opp/opp.h
@@ -190,11 +190,11 @@ struct opp_table {
 
 /* Routines internal to opp core */
 void dev_pm_opp_get(struct dev_pm_opp *opp);
+void _opp_remove_all_static(struct opp_table *opp_table);
 void _get_opp_table_kref(struct opp_table *opp_table);
 int _get_opp_count(struct opp_table *opp_table);
 struct opp_table *_find_opp_table(struct device *dev);
 struct opp_device *_add_opp_dev(const struct device *dev, struct opp_table *opp_table);
-void _dev_pm_opp_remove_table(struct opp_table *opp_table, struct device *dev);
 void _dev_pm_opp_find_and_remove_table(struct device *dev);
 struct dev_pm_opp *_opp_allocate(struct opp_table *opp_table);
 void _opp_free(struct dev_pm_opp *opp);

commit 2a4eb7358aba6beff7fa23f028c733310756e525
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Sep 13 13:14:36 2018 +0530

    OPP: Don't remove dynamic OPPs from _dev_pm_opp_remove_table()
    
    Only one platform was depending on this feature and it is already
    updated now. Stop removing dynamic OPPs from _dev_pm_opp_remove_table().
    This simplifies lot of paths and removes unnecessary parameters.
    
    Tested-by: Niklas Cassel <niklas.cassel@linaro.org>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/drivers/opp/opp.h b/drivers/opp/opp.h
index 9274116c90e4..98dd7d39e1ad 100644
--- a/drivers/opp/opp.h
+++ b/drivers/opp/opp.h
@@ -194,13 +194,13 @@ void _get_opp_table_kref(struct opp_table *opp_table);
 int _get_opp_count(struct opp_table *opp_table);
 struct opp_table *_find_opp_table(struct device *dev);
 struct opp_device *_add_opp_dev(const struct device *dev, struct opp_table *opp_table);
-void _dev_pm_opp_remove_table(struct opp_table *opp_table, struct device *dev, bool remove_all);
-void _dev_pm_opp_find_and_remove_table(struct device *dev, bool remove_all);
+void _dev_pm_opp_remove_table(struct opp_table *opp_table, struct device *dev);
+void _dev_pm_opp_find_and_remove_table(struct device *dev);
 struct dev_pm_opp *_opp_allocate(struct opp_table *opp_table);
 void _opp_free(struct dev_pm_opp *opp);
 int _opp_add(struct device *dev, struct dev_pm_opp *new_opp, struct opp_table *opp_table, bool rate_not_available);
 int _opp_add_v1(struct opp_table *opp_table, struct device *dev, unsigned long freq, long u_volt, bool dynamic);
-void _dev_pm_opp_cpumask_remove_table(const struct cpumask *cpumask, bool of, int last_cpu);
+void _dev_pm_opp_cpumask_remove_table(const struct cpumask *cpumask, int last_cpu);
 struct opp_table *_add_opp_table(struct device *dev);
 void _put_opp_list_kref(struct opp_table *opp_table);
 

commit d0e8ae6c26da7b9436775dfd9768d7a821ed47b7
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Sep 11 11:14:11 2018 +0530

    OPP: Create separate kref for static OPPs list
    
    The static OPPs don't always get freed with the OPP table, it can happen
    before that as well. For example, if the OPP table is first created
    using helpers like dev_pm_opp_set_supported_hw() and the OPPs are
    created at a later point. Now when the OPPs are removed, the OPP table
    stays until the time dev_pm_opp_put_supported_hw() is called.
    
    Later patches will streamline the freeing of OPP table and that requires
    the static OPPs to get freed with help of a separate kernel reference.
    This patch prepares for that by creating a separate kref for static OPPs
    list.
    
    Tested-by: Niklas Cassel <niklas.cassel@linaro.org>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/drivers/opp/opp.h b/drivers/opp/opp.h
index b04c2b511c4d..9274116c90e4 100644
--- a/drivers/opp/opp.h
+++ b/drivers/opp/opp.h
@@ -126,6 +126,7 @@ enum opp_table_access {
  * @dev_list:	list of devices that share these OPPs
  * @opp_list:	table of opps
  * @kref:	for reference count of the table.
+ * @list_kref:	for reference count of the OPP list.
  * @lock:	mutex protecting the opp_list and dev_list.
  * @np:		struct device_node pointer for opp's DT node.
  * @clock_latency_ns_max: Max clock latency in nanoseconds.
@@ -157,6 +158,7 @@ struct opp_table {
 	struct list_head dev_list;
 	struct list_head opp_list;
 	struct kref kref;
+	struct kref list_kref;
 	struct mutex lock;
 
 	struct device_node *np;
@@ -200,6 +202,7 @@ int _opp_add(struct device *dev, struct dev_pm_opp *new_opp, struct opp_table *o
 int _opp_add_v1(struct opp_table *opp_table, struct device *dev, unsigned long freq, long u_volt, bool dynamic);
 void _dev_pm_opp_cpumask_remove_table(const struct cpumask *cpumask, bool of, int last_cpu);
 struct opp_table *_add_opp_table(struct device *dev);
+void _put_opp_list_kref(struct opp_table *opp_table);
 
 #ifdef CONFIG_OF
 void _of_init_opp_table(struct opp_table *opp_table, struct device *dev, int index);

commit f06ed90e7051a3a50c2172001c86ff9645e5c2ba
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jun 14 12:04:43 2018 +0530

    OPP: Parse OPP table's DT properties from _of_init_opp_table()
    
    Parse the DT properties present in the OPP table from
    _of_init_opp_table(), which is a dedicated routine for DT parsing.
    
    Minor relocation of helpers is required for this.
    
    It is possible now for _managed_opp() to return a partially initialized
    OPP table if the OPP table is created via the helpers like
    dev_pm_opp_set_supported_hw() and we need another flag to indicate if
    the static OPP are already parsed or not to make sure we don't
    incorrectly skip initializing the static OPPs.
    
    Tested-by: Niklas Cassel <niklas.cassel@linaro.org>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/drivers/opp/opp.h b/drivers/opp/opp.h
index b235e76fc8cc..b04c2b511c4d 100644
--- a/drivers/opp/opp.h
+++ b/drivers/opp/opp.h
@@ -129,6 +129,7 @@ enum opp_table_access {
  * @lock:	mutex protecting the opp_list and dev_list.
  * @np:		struct device_node pointer for opp's DT node.
  * @clock_latency_ns_max: Max clock latency in nanoseconds.
+ * @parsed_static_opps: True if OPPs are initialized from DT.
  * @shared_opp: OPP is shared between multiple devices.
  * @suspend_opp: Pointer to OPP to be used during device suspend.
  * @supported_hw: Array of version number to support.
@@ -164,6 +165,7 @@ struct opp_table {
 	/* For backward compatibility with v1 bindings */
 	unsigned int voltage_tolerance_v1;
 
+	bool parsed_static_opps;
 	enum opp_table_access shared_opp;
 	struct dev_pm_opp *suspend_opp;
 

commit eb7c8743d6cf489e30091e6656fd4d3306621e9a
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed Sep 5 16:17:14 2018 +0530

    OPP: Pass index to _of_init_opp_table()
    
    This is a preparatory patch required for the next commit which will
    start using OPP table's node pointer in _of_init_opp_table(), which
    requires the index in order to read the OPP table's phandle.
    
    This commit adds the index argument in the call chains in order to get
    it delivered to _of_init_opp_table().
    
    Tested-by: Niklas Cassel <niklas.cassel@linaro.org>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/drivers/opp/opp.h b/drivers/opp/opp.h
index 88e9f47aadf1..b235e76fc8cc 100644
--- a/drivers/opp/opp.h
+++ b/drivers/opp/opp.h
@@ -200,9 +200,9 @@ void _dev_pm_opp_cpumask_remove_table(const struct cpumask *cpumask, bool of, in
 struct opp_table *_add_opp_table(struct device *dev);
 
 #ifdef CONFIG_OF
-void _of_init_opp_table(struct opp_table *opp_table, struct device *dev);
+void _of_init_opp_table(struct opp_table *opp_table, struct device *dev, int index);
 #else
-static inline void _of_init_opp_table(struct opp_table *opp_table, struct device *dev) {}
+static inline void _of_init_opp_table(struct opp_table *opp_table, struct device *dev, int index) {}
 #endif
 
 #ifdef CONFIG_DEBUG_FS

commit 3d2556992a878a2210d3be498416aee39e0c32aa
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Aug 3 07:05:21 2018 +0530

    OPP: Protect dev_list with opp_table lock
    
    The dev_list needs to be protected with a lock, else we may have
    simultaneous access (addition/removal) to it and that would be racy.
    Extend scope of the opp_table lock to protect dev_list as well.
    
    Tested-by: Niklas Cassel <niklas.cassel@linaro.org>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/drivers/opp/opp.h b/drivers/opp/opp.h
index a9d22aa534c3..88e9f47aadf1 100644
--- a/drivers/opp/opp.h
+++ b/drivers/opp/opp.h
@@ -126,7 +126,7 @@ enum opp_table_access {
  * @dev_list:	list of devices that share these OPPs
  * @opp_list:	table of opps
  * @kref:	for reference count of the table.
- * @lock:	mutex protecting the opp_list.
+ * @lock:	mutex protecting the opp_list and dev_list.
  * @np:		struct device_node pointer for opp's DT node.
  * @clock_latency_ns_max: Max clock latency in nanoseconds.
  * @shared_opp: OPP is shared between multiple devices.

commit 404b1369ea26f598b96ae4d3183262a879703cfe
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Sep 13 13:09:27 2018 +0530

    OPP: Don't try to remove all OPP tables on failure
    
    dev_pm_opp_of_cpumask_add_table() creates the OPP table for all CPUs
    present in the cpumask and on errors it should revert all changes it has
    done.
    
    It actually is doing a bit more than that. On errors, it tries to free
    all the OPP tables, even the one it hasn't created yet. This may also
    end up freeing the OPP tables which were created from separate path,
    like dev_pm_opp_set_supported_hw().
    
    Reported-and-tested-by: Niklas Cassel <niklas.cassel@linaro.org>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/drivers/opp/opp.h b/drivers/opp/opp.h
index 7c540fd063b2..a9d22aa534c3 100644
--- a/drivers/opp/opp.h
+++ b/drivers/opp/opp.h
@@ -196,7 +196,7 @@ struct dev_pm_opp *_opp_allocate(struct opp_table *opp_table);
 void _opp_free(struct dev_pm_opp *opp);
 int _opp_add(struct device *dev, struct dev_pm_opp *new_opp, struct opp_table *opp_table, bool rate_not_available);
 int _opp_add_v1(struct opp_table *opp_table, struct device *dev, unsigned long freq, long u_volt, bool dynamic);
-void _dev_pm_opp_cpumask_remove_table(const struct cpumask *cpumask, bool of);
+void _dev_pm_opp_cpumask_remove_table(const struct cpumask *cpumask, bool of, int last_cpu);
 struct opp_table *_add_opp_table(struct device *dev);
 
 #ifdef CONFIG_OF

commit 28fa4aca262ce0865d27788ebc480e643117d7ab
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Dec 22 12:08:00 2017 +0530

    PM / OPP: Remove dev_pm_opp_{un}register_get_pstate_helper()
    
    These helpers aren't used anymore, remove them.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/opp/opp.h b/drivers/opp/opp.h
index f9eccf9811ae..7c540fd063b2 100644
--- a/drivers/opp/opp.h
+++ b/drivers/opp/opp.h
@@ -140,7 +140,6 @@ enum opp_table_access {
  * @genpd_performance_state: Device's power domain support performance state.
  * @set_opp: Platform specific set_opp callback
  * @set_opp_data: Data to be passed to set_opp callback
- * @get_pstate: Platform specific get_pstate callback
  * @dentry:	debugfs dentry pointer of the real device directory (not links).
  * @dentry_name: Name of the real dentry.
  *
@@ -178,7 +177,6 @@ struct opp_table {
 
 	int (*set_opp)(struct dev_pm_set_opp_data *data);
 	struct dev_pm_set_opp_data *set_opp_data;
-	int (*get_pstate)(struct device *dev, unsigned long rate);
 
 #ifdef CONFIG_DEBUG_FS
 	struct dentry *dentry;

commit a88bd2a51e901ed8081841d647157de8153df813
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed Nov 29 15:18:36 2017 +0530

    PM / OPP: Implement of_dev_pm_opp_find_required_opp()
    
    A device's DT node or its OPP nodes can contain a phandle to other
    device's OPP node, in the "required-opps" property.
    
    This patch implements a routine to find that required OPP from the node
    that contains the "required-opps" property.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/opp/opp.h b/drivers/opp/opp.h
index 381a4fb15d5c..f9eccf9811ae 100644
--- a/drivers/opp/opp.h
+++ b/drivers/opp/opp.h
@@ -187,6 +187,7 @@ struct opp_table {
 };
 
 /* Routines internal to opp core */
+void dev_pm_opp_get(struct dev_pm_opp *opp);
 void _get_opp_table_kref(struct opp_table *opp_table);
 int _get_opp_count(struct opp_table *opp_table);
 struct opp_table *_find_opp_table(struct device *dev);

commit a1e8c13600bfd96c51580732ccf31f69bc6de4d1
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Apr 6 14:35:45 2018 +0530

    PM / OPP: "opp-hz" is optional for power domains
    
    "opp-hz" property is optional for power domains now and we shouldn't
    error out if it is missing for power domains.
    
    This patch creates two new routines, _get_opp_count() and
    _opp_is_duplicate(), by separating existing code from their parent
    functions. Also skip duplicate OPP check for power domain OPPs as they
    may not have any the "opp-hz" field, but a platform specific performance
    state binding to uniquely identify OPP nodes.
    
    By default the debugfs OPP nodes are named using the "rate" value, but
    that isn't possible for the power domain OPP nodes and hence they use
    the index of the OPP node in the OPP node list instead.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/opp/opp.h b/drivers/opp/opp.h
index 4d00061648a3..381a4fb15d5c 100644
--- a/drivers/opp/opp.h
+++ b/drivers/opp/opp.h
@@ -188,13 +188,14 @@ struct opp_table {
 
 /* Routines internal to opp core */
 void _get_opp_table_kref(struct opp_table *opp_table);
+int _get_opp_count(struct opp_table *opp_table);
 struct opp_table *_find_opp_table(struct device *dev);
 struct opp_device *_add_opp_dev(const struct device *dev, struct opp_table *opp_table);
 void _dev_pm_opp_remove_table(struct opp_table *opp_table, struct device *dev, bool remove_all);
 void _dev_pm_opp_find_and_remove_table(struct device *dev, bool remove_all);
 struct dev_pm_opp *_opp_allocate(struct opp_table *opp_table);
 void _opp_free(struct dev_pm_opp *opp);
-int _opp_add(struct device *dev, struct dev_pm_opp *new_opp, struct opp_table *opp_table);
+int _opp_add(struct device *dev, struct dev_pm_opp *new_opp, struct opp_table *opp_table, bool rate_not_available);
 int _opp_add_v1(struct opp_table *opp_table, struct device *dev, unsigned long freq, long u_volt, bool dynamic);
 void _dev_pm_opp_cpumask_remove_table(const struct cpumask *cpumask, bool of);
 struct opp_table *_add_opp_table(struct device *dev);

commit b6aa98364f842f943495408895627702ad7ad44b
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed Oct 11 12:54:15 2017 +0530

    PM / OPP: Add dev_pm_opp_{un}register_get_pstate_helper()
    
    This adds the dev_pm_opp_{un}register_get_pstate_helper() helper
    routines which will be used to set the get_pstate() callback for a
    device. This callback will be later called internally by the OPP core to
    get performance state corresponding to an OPP.
    
    This is required temporarily until the time we have proper DT bindings
    to include the performance state information.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/opp/opp.h b/drivers/opp/opp.h
index e8f767ab5814..4d00061648a3 100644
--- a/drivers/opp/opp.h
+++ b/drivers/opp/opp.h
@@ -140,6 +140,7 @@ enum opp_table_access {
  * @genpd_performance_state: Device's power domain support performance state.
  * @set_opp: Platform specific set_opp callback
  * @set_opp_data: Data to be passed to set_opp callback
+ * @get_pstate: Platform specific get_pstate callback
  * @dentry:	debugfs dentry pointer of the real device directory (not links).
  * @dentry_name: Name of the real dentry.
  *
@@ -177,6 +178,7 @@ struct opp_table {
 
 	int (*set_opp)(struct dev_pm_set_opp_data *data);
 	struct dev_pm_set_opp_data *set_opp_data;
+	int (*get_pstate)(struct device *dev, unsigned long rate);
 
 #ifdef CONFIG_DEBUG_FS
 	struct dentry *dentry;

commit 009acd196fc860045bf7b2c3f5812f0f5efb2782
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed Oct 11 12:54:14 2017 +0530

    PM / OPP: Support updating performance state of device's power domain
    
    The genpd framework now provides an API to request device's power
    domain to update its performance state.  Use that interface from the
    OPP core for devices whose power domains support performance states.
    
    Note that this commit doesn't add any mechanism by which performance
    states are made available to the OPP core. That would be done by a
    later commit.
    
    Note that the current implementation is restricted to the case where
    the device doesn't have separate regulators for itself. We shouldn't
    over engineer the code before we have real use case for them. We can
    always come back and add more code to support such cases later on.
    
    Tested-by: Rajendra Nayak <rnayak@codeaurora.org>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/opp/opp.h b/drivers/opp/opp.h
index 166eef990599..e8f767ab5814 100644
--- a/drivers/opp/opp.h
+++ b/drivers/opp/opp.h
@@ -58,6 +58,7 @@ extern struct list_head opp_tables;
  * @dynamic:	not-created from static DT entries.
  * @turbo:	true if turbo (boost) OPP
  * @suspend:	true if suspend OPP
+ * @pstate: Device's power domain's performance state.
  * @rate:	Frequency in hertz
  * @supplies:	Power supplies voltage/current values
  * @clock_latency_ns: Latency (in nanoseconds) of switching to this OPP's
@@ -76,6 +77,7 @@ struct dev_pm_opp {
 	bool dynamic;
 	bool turbo;
 	bool suspend;
+	unsigned int pstate;
 	unsigned long rate;
 
 	struct dev_pm_opp_supply *supplies;
@@ -135,6 +137,7 @@ enum opp_table_access {
  * @clk: Device's clock handle
  * @regulators: Supply regulators
  * @regulator_count: Number of power supply regulators
+ * @genpd_performance_state: Device's power domain support performance state.
  * @set_opp: Platform specific set_opp callback
  * @set_opp_data: Data to be passed to set_opp callback
  * @dentry:	debugfs dentry pointer of the real device directory (not links).
@@ -170,6 +173,7 @@ struct opp_table {
 	struct clk *clk;
 	struct regulator **regulators;
 	unsigned int regulator_count;
+	bool genpd_performance_state;
 
 	int (*set_opp)(struct dev_pm_set_opp_data *data);
 	struct dev_pm_set_opp_data *set_opp_data;

commit 7813dd6fc75fb375d4caf002e7f80a826fc3153a
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Sep 26 15:12:40 2017 -0700

    PM / OPP: Move the OPP directory out of power/
    
    The drivers/base/power/ directory is special and contains code related
    to power management core like system suspend/resume, hibernation, etc.
    It was fine to keep the OPP code inside it when we had just one file for
    it, but it is growing now and already has a directory for itself.
    
    Lets move it directly under drivers/ directory, just like cpufreq and
    cpuidle.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/opp/opp.h b/drivers/opp/opp.h
new file mode 100644
index 000000000000..166eef990599
--- /dev/null
+++ b/drivers/opp/opp.h
@@ -0,0 +1,222 @@
+/*
+ * Generic OPP Interface
+ *
+ * Copyright (C) 2009-2010 Texas Instruments Incorporated.
+ *	Nishanth Menon
+ *	Romit Dasgupta
+ *	Kevin Hilman
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __DRIVER_OPP_H__
+#define __DRIVER_OPP_H__
+
+#include <linux/device.h>
+#include <linux/kernel.h>
+#include <linux/kref.h>
+#include <linux/list.h>
+#include <linux/limits.h>
+#include <linux/pm_opp.h>
+#include <linux/notifier.h>
+
+struct clk;
+struct regulator;
+
+/* Lock to allow exclusive modification to the device and opp lists */
+extern struct mutex opp_table_lock;
+
+extern struct list_head opp_tables;
+
+/*
+ * Internal data structure organization with the OPP layer library is as
+ * follows:
+ * opp_tables (root)
+ *	|- device 1 (represents voltage domain 1)
+ *	|	|- opp 1 (availability, freq, voltage)
+ *	|	|- opp 2 ..
+ *	...	...
+ *	|	`- opp n ..
+ *	|- device 2 (represents the next voltage domain)
+ *	...
+ *	`- device m (represents mth voltage domain)
+ * device 1, 2.. are represented by opp_table structure while each opp
+ * is represented by the opp structure.
+ */
+
+/**
+ * struct dev_pm_opp - Generic OPP description structure
+ * @node:	opp table node. The nodes are maintained throughout the lifetime
+ *		of boot. It is expected only an optimal set of OPPs are
+ *		added to the library by the SoC framework.
+ *		IMPORTANT: the opp nodes should be maintained in increasing
+ *		order.
+ * @kref:	for reference count of the OPP.
+ * @available:	true/false - marks if this OPP as available or not
+ * @dynamic:	not-created from static DT entries.
+ * @turbo:	true if turbo (boost) OPP
+ * @suspend:	true if suspend OPP
+ * @rate:	Frequency in hertz
+ * @supplies:	Power supplies voltage/current values
+ * @clock_latency_ns: Latency (in nanoseconds) of switching to this OPP's
+ *		frequency from any other OPP's frequency.
+ * @opp_table:	points back to the opp_table struct this opp belongs to
+ * @np:		OPP's device node.
+ * @dentry:	debugfs dentry pointer (per opp)
+ *
+ * This structure stores the OPP information for a given device.
+ */
+struct dev_pm_opp {
+	struct list_head node;
+	struct kref kref;
+
+	bool available;
+	bool dynamic;
+	bool turbo;
+	bool suspend;
+	unsigned long rate;
+
+	struct dev_pm_opp_supply *supplies;
+
+	unsigned long clock_latency_ns;
+
+	struct opp_table *opp_table;
+
+	struct device_node *np;
+
+#ifdef CONFIG_DEBUG_FS
+	struct dentry *dentry;
+#endif
+};
+
+/**
+ * struct opp_device - devices managed by 'struct opp_table'
+ * @node:	list node
+ * @dev:	device to which the struct object belongs
+ * @dentry:	debugfs dentry pointer (per device)
+ *
+ * This is an internal data structure maintaining the devices that are managed
+ * by 'struct opp_table'.
+ */
+struct opp_device {
+	struct list_head node;
+	const struct device *dev;
+
+#ifdef CONFIG_DEBUG_FS
+	struct dentry *dentry;
+#endif
+};
+
+enum opp_table_access {
+	OPP_TABLE_ACCESS_UNKNOWN = 0,
+	OPP_TABLE_ACCESS_EXCLUSIVE = 1,
+	OPP_TABLE_ACCESS_SHARED = 2,
+};
+
+/**
+ * struct opp_table - Device opp structure
+ * @node:	table node - contains the devices with OPPs that
+ *		have been registered. Nodes once added are not modified in this
+ *		table.
+ * @head:	notifier head to notify the OPP availability changes.
+ * @dev_list:	list of devices that share these OPPs
+ * @opp_list:	table of opps
+ * @kref:	for reference count of the table.
+ * @lock:	mutex protecting the opp_list.
+ * @np:		struct device_node pointer for opp's DT node.
+ * @clock_latency_ns_max: Max clock latency in nanoseconds.
+ * @shared_opp: OPP is shared between multiple devices.
+ * @suspend_opp: Pointer to OPP to be used during device suspend.
+ * @supported_hw: Array of version number to support.
+ * @supported_hw_count: Number of elements in supported_hw array.
+ * @prop_name: A name to postfix to many DT properties, while parsing them.
+ * @clk: Device's clock handle
+ * @regulators: Supply regulators
+ * @regulator_count: Number of power supply regulators
+ * @set_opp: Platform specific set_opp callback
+ * @set_opp_data: Data to be passed to set_opp callback
+ * @dentry:	debugfs dentry pointer of the real device directory (not links).
+ * @dentry_name: Name of the real dentry.
+ *
+ * @voltage_tolerance_v1: In percentage, for v1 bindings only.
+ *
+ * This is an internal data structure maintaining the link to opps attached to
+ * a device. This structure is not meant to be shared to users as it is
+ * meant for book keeping and private to OPP library.
+ */
+struct opp_table {
+	struct list_head node;
+
+	struct blocking_notifier_head head;
+	struct list_head dev_list;
+	struct list_head opp_list;
+	struct kref kref;
+	struct mutex lock;
+
+	struct device_node *np;
+	unsigned long clock_latency_ns_max;
+
+	/* For backward compatibility with v1 bindings */
+	unsigned int voltage_tolerance_v1;
+
+	enum opp_table_access shared_opp;
+	struct dev_pm_opp *suspend_opp;
+
+	unsigned int *supported_hw;
+	unsigned int supported_hw_count;
+	const char *prop_name;
+	struct clk *clk;
+	struct regulator **regulators;
+	unsigned int regulator_count;
+
+	int (*set_opp)(struct dev_pm_set_opp_data *data);
+	struct dev_pm_set_opp_data *set_opp_data;
+
+#ifdef CONFIG_DEBUG_FS
+	struct dentry *dentry;
+	char dentry_name[NAME_MAX];
+#endif
+};
+
+/* Routines internal to opp core */
+void _get_opp_table_kref(struct opp_table *opp_table);
+struct opp_table *_find_opp_table(struct device *dev);
+struct opp_device *_add_opp_dev(const struct device *dev, struct opp_table *opp_table);
+void _dev_pm_opp_remove_table(struct opp_table *opp_table, struct device *dev, bool remove_all);
+void _dev_pm_opp_find_and_remove_table(struct device *dev, bool remove_all);
+struct dev_pm_opp *_opp_allocate(struct opp_table *opp_table);
+void _opp_free(struct dev_pm_opp *opp);
+int _opp_add(struct device *dev, struct dev_pm_opp *new_opp, struct opp_table *opp_table);
+int _opp_add_v1(struct opp_table *opp_table, struct device *dev, unsigned long freq, long u_volt, bool dynamic);
+void _dev_pm_opp_cpumask_remove_table(const struct cpumask *cpumask, bool of);
+struct opp_table *_add_opp_table(struct device *dev);
+
+#ifdef CONFIG_OF
+void _of_init_opp_table(struct opp_table *opp_table, struct device *dev);
+#else
+static inline void _of_init_opp_table(struct opp_table *opp_table, struct device *dev) {}
+#endif
+
+#ifdef CONFIG_DEBUG_FS
+void opp_debug_remove_one(struct dev_pm_opp *opp);
+int opp_debug_create_one(struct dev_pm_opp *opp, struct opp_table *opp_table);
+int opp_debug_register(struct opp_device *opp_dev, struct opp_table *opp_table);
+void opp_debug_unregister(struct opp_device *opp_dev, struct opp_table *opp_table);
+#else
+static inline void opp_debug_remove_one(struct dev_pm_opp *opp) {}
+
+static inline int opp_debug_create_one(struct dev_pm_opp *opp,
+				       struct opp_table *opp_table)
+{ return 0; }
+static inline int opp_debug_register(struct opp_device *opp_dev,
+				     struct opp_table *opp_table)
+{ return 0; }
+
+static inline void opp_debug_unregister(struct opp_device *opp_dev,
+					struct opp_table *opp_table)
+{ }
+#endif		/* DEBUG_FS */
+
+#endif		/* __DRIVER_OPP_H__ */
