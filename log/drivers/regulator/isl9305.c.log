commit 77e29598ca3fc20314f1acec35ada9706b3ea16b
Author: Axel Lin <axel.lin@ingics.com>
Date:   Thu Jan 9 23:58:08 2020 +0800

    regulator: Convert i2c drivers to use .probe_new
    
    Use the new .probe_new for i2c drivers.
    These drivers do not use const struct i2c_device_id * argument, so convert
    them to utilise the simplified i2c driver registration.
    
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Link: https://lore.kernel.org/r/20200109155808.22003-1-axel.lin@ingics.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/isl9305.c b/drivers/regulator/isl9305.c
index 978f5e903cae..cfb765986d0d 100644
--- a/drivers/regulator/isl9305.c
+++ b/drivers/regulator/isl9305.c
@@ -137,8 +137,7 @@ static const struct regmap_config isl9305_regmap = {
 	.cache_type = REGCACHE_RBTREE,
 };
 
-static int isl9305_i2c_probe(struct i2c_client *i2c,
-			     const struct i2c_device_id *id)
+static int isl9305_i2c_probe(struct i2c_client *i2c)
 {
 	struct regulator_config config = { };
 	struct isl9305_pdata *pdata = i2c->dev.platform_data;
@@ -198,7 +197,7 @@ static struct i2c_driver isl9305_regulator_driver = {
 		.name = "isl9305",
 		.of_match_table	= of_match_ptr(isl9305_dt_ids),
 	},
-	.probe = isl9305_i2c_probe,
+	.probe_new = isl9305_i2c_probe,
 	.id_table = isl9305_i2c_id,
 };
 

commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/regulator/isl9305.c b/drivers/regulator/isl9305.c
index 9c2607e912cf..978f5e903cae 100644
--- a/drivers/regulator/isl9305.c
+++ b/drivers/regulator/isl9305.c
@@ -1,14 +1,10 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * isl9305 - Intersil ISL9305 DCDC regulator
  *
  * Copyright 2014 Linaro Ltd
  *
  * Author: Mark Brown <broonie@kernel.org>
- *
- *  This program is free software; you can redistribute  it and/or modify it
- *  under  the terms of  the GNU General  Public License as published by the
- *  Free Software Foundation;  either version 2 of the  License, or (at your
- *  option) any later version.
  */
 
 #include <linux/module.h>

commit 46942b21a95ffd1476c82b3a8683a1caa58b6f40
Author: Axel Lin <axel.lin@ingics.com>
Date:   Mon Aug 27 22:15:21 2018 +0800

    regulator: isl9305: Add missing .owner field in regulator_desc
    
    Add missing .owner field in regulator_desc, which is used for refcounting.
    
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/isl9305.c b/drivers/regulator/isl9305.c
index 257c1943e753..9c2607e912cf 100644
--- a/drivers/regulator/isl9305.c
+++ b/drivers/regulator/isl9305.c
@@ -84,6 +84,7 @@ static const struct regulator_desc isl9305_regulators[] = {
 		.enable_mask =	ISL9305_DCD1_EN,
 		.supply_name =	"VINDCD1",
 		.ops =		&isl9305_ops,
+		.owner =	THIS_MODULE,
 	},
 	[ISL9305_DCD2] = {
 		.name =		"DCD2",
@@ -98,6 +99,7 @@ static const struct regulator_desc isl9305_regulators[] = {
 		.enable_mask =	ISL9305_DCD2_EN,
 		.supply_name =	"VINDCD2",
 		.ops =		&isl9305_ops,
+		.owner =	THIS_MODULE,
 	},
 	[ISL9305_LDO1] = {
 		.name =		"LDO1",
@@ -112,6 +114,7 @@ static const struct regulator_desc isl9305_regulators[] = {
 		.enable_mask =	ISL9305_LDO1_EN,
 		.supply_name =	"VINLDO1",
 		.ops =		&isl9305_ops,
+		.owner =	THIS_MODULE,
 	},
 	[ISL9305_LDO2] = {
 		.name =		"LDO2",
@@ -126,6 +129,7 @@ static const struct regulator_desc isl9305_regulators[] = {
 		.enable_mask =	ISL9305_LDO2_EN,
 		.supply_name =	"VINLDO2",
 		.ops =		&isl9305_ops,
+		.owner =	THIS_MODULE,
 	},
 };
 

commit 3e683126f4b42bd29ac5adff1eb178880aa7706a
Merge: 176175b613cb 6d73aef11760 3a003baeec24 a807a6cc2911 a02daad70214 60cb65ebf49e
Author: Mark Brown <broonie@kernel.org>
Date:   Sun Aug 30 14:39:48 2015 +0100

    Merge remote-tracking branches 'regulator/topic/mt6311', 'regulator/topic/ocp', 'regulator/topic/owner', 'regulator/topic/pfuze100' and 'regulator/topic/pwm' into regulator-next

commit 5b87af4cca175c4f03f790f2b15be7e4dd436df9
Author: Javier Martinez Canillas <javier@osg.samsung.com>
Date:   Tue Aug 25 08:31:17 2015 +0200

    regulator: isl9305: Export OF module alias information
    
    The I2C core always reports the MODALIAS uevent as "i2c:<modalias>"
    regardless of the mechanism that was used to register the device
    (i.e: OF or board code) and the table that is used later to match
    the driver with the device (i.e: I2C id table or OF match table).
    
    So drivers needs to export the I2C id table and this be built into
    the module or udev won't have the necessary information to autoload
    the needed driver module when the device is added.
    
    But this means that OF-only drivers needs to have both OF and I2C id
    tables that have to be kept in sync and also the dev node compatible
    manufacturer prefix is stripped when reporting the MODALIAS. Which can
    lead to issues if two vendors use the same I2C device name for example.
    
    To avoid the above, the I2C core behavior may be changed in the future
    to not require an SPI device table for OF-only drivers and report the
    OF module alias. So, it's better to also export the OF table even when
    is unused now to prevent breaking module loading when the core changes.
    
    Signed-off-by: Javier Martinez Canillas <javier@osg.samsung.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/isl9305.c b/drivers/regulator/isl9305.c
index 6e3a15fe00f1..e02e9a9dddbd 100644
--- a/drivers/regulator/isl9305.c
+++ b/drivers/regulator/isl9305.c
@@ -183,6 +183,7 @@ static const struct of_device_id isl9305_dt_ids[] = {
 	{ .compatible = "isil,isl9305h" },
 	{},
 };
+MODULE_DEVICE_TABLE(of, isl9305_dt_ids);
 #endif
 
 static const struct i2c_device_id isl9305_i2c_id[] = {

commit a807a6cc29115a9a43c168fc0d4540b3d9284815
Author: Krzysztof Kozlowski <k.kozlowski@samsung.com>
Date:   Fri Jul 10 14:44:00 2015 +0900

    regulator: drivers: Drop owner assignment from i2c_driver
    
    i2c_driver does not need to set an owner because i2c_register_driver()
    will set it.
    
    Signed-off-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/isl9305.c b/drivers/regulator/isl9305.c
index 6e3a15fe00f1..eae9d1ffe641 100644
--- a/drivers/regulator/isl9305.c
+++ b/drivers/regulator/isl9305.c
@@ -195,7 +195,6 @@ MODULE_DEVICE_TABLE(i2c, isl9305_i2c_id);
 static struct i2c_driver isl9305_regulator_driver = {
 	.driver = {
 		.name = "isl9305",
-		.owner = THIS_MODULE,
 		.of_match_table	= of_match_ptr(isl9305_dt_ids),
 	},
 	.probe = isl9305_i2c_probe,

commit 6fd753572c34a2469b41813aa6f376569cf2681f
Author: Arnaud Ebalard <arno@natisbad.org>
Date:   Tue Dec 16 22:20:50 2014 +0100

    regulator: isl9305: deprecate use of isl in compatible string for isil
    
    "isil" and "isl" prefixes are used at various locations inside the kernel
    to reference Intersil corporation. This patch is part of a series fixing
    those locations were "isl" is used in compatible strings to use the now
    expected "isil" prefix instead (NASDAQ symbol for Intersil and most used
    version). The old compatible string is kept for backward compatibility.
    
    Signed-off-by: Arnaud Ebalard <arno@natisbad.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/isl9305.c b/drivers/regulator/isl9305.c
index 92fefd98da58..6e3a15fe00f1 100644
--- a/drivers/regulator/isl9305.c
+++ b/drivers/regulator/isl9305.c
@@ -177,8 +177,10 @@ static int isl9305_i2c_probe(struct i2c_client *i2c,
 
 #ifdef CONFIG_OF
 static const struct of_device_id isl9305_dt_ids[] = {
-	{ .compatible = "isl,isl9305" },
-	{ .compatible = "isl,isl9305h" },
+	{ .compatible = "isl,isl9305" }, /* for backward compat., don't use */
+	{ .compatible = "isil,isl9305" },
+	{ .compatible = "isl,isl9305h" }, /* for backward compat., don't use */
+	{ .compatible = "isil,isl9305h" },
 	{},
 };
 #endif

commit 93a127b11ac034b160ccdd32e27d791b98f52cf5
Author: Mark Brown <broonie@kernel.org>
Date:   Wed Sep 10 12:18:56 2014 +0100

    regulator: isl9305: Convert to new style DT parsing
    
    This removes some code and replaces it with data.
    
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/isl9305.c b/drivers/regulator/isl9305.c
index b0d12d186b68..92fefd98da58 100644
--- a/drivers/regulator/isl9305.c
+++ b/drivers/regulator/isl9305.c
@@ -73,6 +73,8 @@ static const struct regulator_ops isl9305_ops = {
 static const struct regulator_desc isl9305_regulators[] = {
 	[ISL9305_DCD1] = {
 		.name =		"DCD1",
+		.of_match =	of_match_ptr("dcd1"),
+		.regulators_node = of_match_ptr("regulators"),
 		.n_voltages =	0x70,
 		.min_uV =	825000,
 		.uV_step =	25000,
@@ -85,6 +87,8 @@ static const struct regulator_desc isl9305_regulators[] = {
 	},
 	[ISL9305_DCD2] = {
 		.name =		"DCD2",
+		.of_match =	of_match_ptr("dcd2"),
+		.regulators_node = of_match_ptr("regulators"),
 		.n_voltages =	0x70,
 		.min_uV =	825000,
 		.uV_step =	25000,
@@ -97,6 +101,8 @@ static const struct regulator_desc isl9305_regulators[] = {
 	},
 	[ISL9305_LDO1] = {
 		.name =		"LDO1",
+		.of_match =	of_match_ptr("ldo1"),
+		.regulators_node = of_match_ptr("regulators"),
 		.n_voltages =	0x37,
 		.min_uV =	900000,
 		.uV_step =	50000,
@@ -109,6 +115,8 @@ static const struct regulator_desc isl9305_regulators[] = {
 	},
 	[ISL9305_LDO2] = {
 		.name =		"LDO2",
+		.of_match =	of_match_ptr("ldo2"),
+		.regulators_node = of_match_ptr("regulators"),
 		.n_voltages =	0x37,
 		.min_uV =	900000,
 		.uV_step =	50000,
@@ -121,45 +129,6 @@ static const struct regulator_desc isl9305_regulators[] = {
 	},
 };
 
-#ifdef CONFIG_OF
-static struct of_regulator_match isl9305_reg_matches[] = {
-	[ISL9305_DCD1] = { .name = "dcd1" },
-	[ISL9305_DCD2] = { .name = "dcd2" },
-	[ISL9305_LDO1] = { .name = "ldo1" },
-	[ISL9305_LDO2] = { .name = "ldo2" },
-};
-
-static struct of_regulator_match *isl9305_parse_dt(struct i2c_client *i2c)
-{
-	struct device_node *node = i2c->dev.of_node;
-	struct of_regulator_match *matches;
-	struct device_node *regs;
-	int count;
-
-	regs = of_get_child_by_name(node, "regulators");
-	if (!regs)
-		return NULL;
-
-	matches = devm_kmemdup(&i2c->dev, isl9305_reg_matches,
-			       sizeof(isl9305_reg_matches), GFP_KERNEL);
-	if (!matches)
-		return NULL;
-
-	count = of_regulator_match(&i2c->dev, regs, matches,
-				   ARRAY_SIZE(isl9305_reg_matches));
-	of_node_put(regs);
-	if ((count < 0) || (count > ARRAY_SIZE(isl9305_reg_matches)))
-		return NULL;
-
-	return matches;
-}
-#else
-static struct of_regulator_match *isl9305_parse_dt(struct i2c_client *i2c)
-{
-	return NULL;
-}
-#endif
-
 static const struct regmap_config isl9305_regmap = {
 	.reg_bits = 8,
 	.val_bits = 8,
@@ -173,13 +142,10 @@ static int isl9305_i2c_probe(struct i2c_client *i2c,
 {
 	struct regulator_config config = { };
 	struct isl9305_pdata *pdata = i2c->dev.platform_data;
-	struct of_regulator_match *of_matches;
 	struct regulator_dev *rdev;
 	struct regmap *regmap;
 	int i, ret;
 
-	of_matches = isl9305_parse_dt(i2c);
-
 	regmap = devm_regmap_init_i2c(i2c, &isl9305_regmap);
 	if (IS_ERR(regmap)) {
 		ret = PTR_ERR(regmap);
@@ -190,16 +156,10 @@ static int isl9305_i2c_probe(struct i2c_client *i2c,
 	config.dev = &i2c->dev;
 
 	for (i = 0; i < ARRAY_SIZE(isl9305_regulators); i++) {
-		config.of_node = NULL;
-		config.init_data = NULL;
-
-		if (of_matches) {
-			config.init_data = of_matches[i].init_data;
-			config.of_node = of_matches[i].of_node;
-		}
-
-		if (!config.init_data && pdata)
+		if (pdata)
 			config.init_data = pdata->init_data[i];
+		else
+			config.init_data = NULL;
 
 		rdev = devm_regulator_register(&i2c->dev,
 					       &isl9305_regulators[i],

commit dec38b5ce6a9edb406c60c2670b26a1a4262fdb9
Author: Mark Brown <broonie@kernel.org>
Date:   Sat Sep 6 01:11:12 2014 +0100

    regulator: isl9305: Add Intersil ISL9305/H driver
    
    The ISL9305 and ISL9305H are mini-PMICs offering two DCDC regulators and
    two LDO regulators. While there are some register differences between them
    these do not affect the current Linux driver as the relevant features are
    not yet supported.
    
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/isl9305.c b/drivers/regulator/isl9305.c
new file mode 100644
index 000000000000..b0d12d186b68
--- /dev/null
+++ b/drivers/regulator/isl9305.c
@@ -0,0 +1,247 @@
+/*
+ * isl9305 - Intersil ISL9305 DCDC regulator
+ *
+ * Copyright 2014 Linaro Ltd
+ *
+ * Author: Mark Brown <broonie@kernel.org>
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/err.h>
+#include <linux/i2c.h>
+#include <linux/of.h>
+#include <linux/platform_data/isl9305.h>
+#include <linux/regmap.h>
+#include <linux/regulator/driver.h>
+#include <linux/regulator/of_regulator.h>
+#include <linux/slab.h>
+
+/*
+ * Registers
+ */
+#define ISL9305_DCD1OUT          0x0
+#define ISL9305_DCD2OUT          0x1
+#define ISL9305_LDO1OUT          0x2
+#define ISL9305_LDO2OUT          0x3
+#define ISL9305_DCD_PARAMETER    0x4
+#define ISL9305_SYSTEM_PARAMETER 0x5
+#define ISL9305_DCD_SRCTL        0x6
+
+#define ISL9305_MAX_REG ISL9305_DCD_SRCTL
+
+/*
+ * DCD_PARAMETER
+ */
+#define ISL9305_DCD_PHASE   0x40
+#define ISL9305_DCD2_ULTRA  0x20
+#define ISL9305_DCD1_ULTRA  0x10
+#define ISL9305_DCD2_BLD    0x08
+#define ISL9305_DCD1_BLD    0x04
+#define ISL9305_DCD2_MODE   0x02
+#define ISL9305_DCD1_MODE   0x01
+
+/*
+ * SYSTEM_PARAMETER
+ */
+#define ISL9305_I2C_EN      0x40
+#define ISL9305_DCDPOR_MASK 0x30
+#define ISL9305_LDO2_EN     0x08
+#define ISL9305_LDO1_EN     0x04
+#define ISL9305_DCD2_EN     0x02
+#define ISL9305_DCD1_EN     0x01
+
+/*
+ * DCD_SRCTL
+ */
+#define ISL9305_DCD2SR_MASK 0xc0
+#define ISL9305_DCD1SR_MASK 0x07
+
+static const struct regulator_ops isl9305_ops = {
+	.enable = regulator_enable_regmap,
+	.disable = regulator_disable_regmap,
+	.is_enabled = regulator_is_enabled_regmap,
+	.list_voltage = regulator_list_voltage_linear,
+	.get_voltage_sel = regulator_get_voltage_sel_regmap,
+	.set_voltage_sel = regulator_set_voltage_sel_regmap,
+};
+
+static const struct regulator_desc isl9305_regulators[] = {
+	[ISL9305_DCD1] = {
+		.name =		"DCD1",
+		.n_voltages =	0x70,
+		.min_uV =	825000,
+		.uV_step =	25000,
+		.vsel_reg =	ISL9305_DCD1OUT,
+		.vsel_mask =	0x7f,
+		.enable_reg =	ISL9305_SYSTEM_PARAMETER,
+		.enable_mask =	ISL9305_DCD1_EN,
+		.supply_name =	"VINDCD1",
+		.ops =		&isl9305_ops,
+	},
+	[ISL9305_DCD2] = {
+		.name =		"DCD2",
+		.n_voltages =	0x70,
+		.min_uV =	825000,
+		.uV_step =	25000,
+		.vsel_reg =	ISL9305_DCD2OUT,
+		.vsel_mask =	0x7f,
+		.enable_reg =	ISL9305_SYSTEM_PARAMETER,
+		.enable_mask =	ISL9305_DCD2_EN,
+		.supply_name =	"VINDCD2",
+		.ops =		&isl9305_ops,
+	},
+	[ISL9305_LDO1] = {
+		.name =		"LDO1",
+		.n_voltages =	0x37,
+		.min_uV =	900000,
+		.uV_step =	50000,
+		.vsel_reg =	ISL9305_LDO1OUT,
+		.vsel_mask =	0x3f,
+		.enable_reg =	ISL9305_SYSTEM_PARAMETER,
+		.enable_mask =	ISL9305_LDO1_EN,
+		.supply_name =	"VINLDO1",
+		.ops =		&isl9305_ops,
+	},
+	[ISL9305_LDO2] = {
+		.name =		"LDO2",
+		.n_voltages =	0x37,
+		.min_uV =	900000,
+		.uV_step =	50000,
+		.vsel_reg =	ISL9305_LDO2OUT,
+		.vsel_mask =	0x3f,
+		.enable_reg =	ISL9305_SYSTEM_PARAMETER,
+		.enable_mask =	ISL9305_LDO2_EN,
+		.supply_name =	"VINLDO2",
+		.ops =		&isl9305_ops,
+	},
+};
+
+#ifdef CONFIG_OF
+static struct of_regulator_match isl9305_reg_matches[] = {
+	[ISL9305_DCD1] = { .name = "dcd1" },
+	[ISL9305_DCD2] = { .name = "dcd2" },
+	[ISL9305_LDO1] = { .name = "ldo1" },
+	[ISL9305_LDO2] = { .name = "ldo2" },
+};
+
+static struct of_regulator_match *isl9305_parse_dt(struct i2c_client *i2c)
+{
+	struct device_node *node = i2c->dev.of_node;
+	struct of_regulator_match *matches;
+	struct device_node *regs;
+	int count;
+
+	regs = of_get_child_by_name(node, "regulators");
+	if (!regs)
+		return NULL;
+
+	matches = devm_kmemdup(&i2c->dev, isl9305_reg_matches,
+			       sizeof(isl9305_reg_matches), GFP_KERNEL);
+	if (!matches)
+		return NULL;
+
+	count = of_regulator_match(&i2c->dev, regs, matches,
+				   ARRAY_SIZE(isl9305_reg_matches));
+	of_node_put(regs);
+	if ((count < 0) || (count > ARRAY_SIZE(isl9305_reg_matches)))
+		return NULL;
+
+	return matches;
+}
+#else
+static struct of_regulator_match *isl9305_parse_dt(struct i2c_client *i2c)
+{
+	return NULL;
+}
+#endif
+
+static const struct regmap_config isl9305_regmap = {
+	.reg_bits = 8,
+	.val_bits = 8,
+
+	.max_register = ISL9305_MAX_REG,
+	.cache_type = REGCACHE_RBTREE,
+};
+
+static int isl9305_i2c_probe(struct i2c_client *i2c,
+			     const struct i2c_device_id *id)
+{
+	struct regulator_config config = { };
+	struct isl9305_pdata *pdata = i2c->dev.platform_data;
+	struct of_regulator_match *of_matches;
+	struct regulator_dev *rdev;
+	struct regmap *regmap;
+	int i, ret;
+
+	of_matches = isl9305_parse_dt(i2c);
+
+	regmap = devm_regmap_init_i2c(i2c, &isl9305_regmap);
+	if (IS_ERR(regmap)) {
+		ret = PTR_ERR(regmap);
+		dev_err(&i2c->dev, "Failed to create regmap: %d\n", ret);
+		return ret;
+	}
+
+	config.dev = &i2c->dev;
+
+	for (i = 0; i < ARRAY_SIZE(isl9305_regulators); i++) {
+		config.of_node = NULL;
+		config.init_data = NULL;
+
+		if (of_matches) {
+			config.init_data = of_matches[i].init_data;
+			config.of_node = of_matches[i].of_node;
+		}
+
+		if (!config.init_data && pdata)
+			config.init_data = pdata->init_data[i];
+
+		rdev = devm_regulator_register(&i2c->dev,
+					       &isl9305_regulators[i],
+					       &config);
+		if (IS_ERR(rdev)) {
+			ret = PTR_ERR(rdev);
+			dev_err(&i2c->dev, "Failed to register %s: %d\n",
+				isl9305_regulators[i].name, ret);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id isl9305_dt_ids[] = {
+	{ .compatible = "isl,isl9305" },
+	{ .compatible = "isl,isl9305h" },
+	{},
+};
+#endif
+
+static const struct i2c_device_id isl9305_i2c_id[] = {
+	{ "isl9305", },
+	{ "isl9305h", },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, isl9305_i2c_id);
+
+static struct i2c_driver isl9305_regulator_driver = {
+	.driver = {
+		.name = "isl9305",
+		.owner = THIS_MODULE,
+		.of_match_table	= of_match_ptr(isl9305_dt_ids),
+	},
+	.probe = isl9305_i2c_probe,
+	.id_table = isl9305_i2c_id,
+};
+
+module_i2c_driver(isl9305_regulator_driver);
+
+MODULE_AUTHOR("Mark Brown");
+MODULE_DESCRIPTION("Intersil ISL9305 DCDC regulator");
+MODULE_LICENSE("GPL");
