commit b59b654478093fa429ad4c7897ae29f201146a00
Author: Saravana Kannan <saravanak@google.com>
Date:   Thu Nov 14 16:04:38 2019 -0800

    regulator: core: Don't try to remove device links if add failed
    
    device_link_add() might not always succeed depending on the type of
    device link and the rest of the dependencies in the system. If
    device_link_add() didn't succeed, then we shouldn't try to remove the
    link later on as it might remove a link someone else created.
    
    Signed-off-by: Saravana Kannan <saravanak@google.com>
    Link: https://lore.kernel.org/r/20191115000438.45970-1-saravanak@google.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/internal.h b/drivers/regulator/internal.h
index 83ae442f515b..2391b565ef11 100644
--- a/drivers/regulator/internal.h
+++ b/drivers/regulator/internal.h
@@ -36,6 +36,7 @@ struct regulator {
 	struct list_head list;
 	unsigned int always_on:1;
 	unsigned int bypass:1;
+	unsigned int device_link:1;
 	int uA_load;
 	unsigned int enable_count;
 	unsigned int deferred_disables;

commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/regulator/internal.h b/drivers/regulator/internal.h
index 6017f15c5d75..83ae442f515b 100644
--- a/drivers/regulator/internal.h
+++ b/drivers/regulator/internal.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
 /*
  * internal.h  --  Voltage/Current Regulator framework internal code
  *
@@ -5,12 +6,6 @@
  * Copyright 2008 SlimLogic Ltd.
  *
  * Author: Liam Girdwood <lrg@slimlogic.co.uk>
- *
- *  This program is free software; you can redistribute  it and/or modify it
- *  under  the terms of  the GNU General  Public License as published by the
- *  Free Software Foundation;  either version 2 of the  License, or (at your
- *  option) any later version.
- *
  */
 
 #ifndef __REGULATOR_INTERNAL_H

commit 5451781dadf85000665e0e2c3288e9e0f34b860a
Author: Douglas Anderson <dianders@chromium.org>
Date:   Tue Nov 20 09:52:53 2018 -0800

    regulator: core: Only count load for enabled consumers
    
    In general when the consumer of a regulator requests that the
    regulator be disabled it no longer will be drawing much load from the
    regulator--it should just be the leakage current and that should be
    very close to 0.
    
    Up to this point the regulator framework has continued to count a
    consumer's load request for disabled regulators.  This has led to code
    patterns that look like this:
    
      enable_my_thing():
        regular_set_load(reg, load_uA)
        regulator_enable(reg)
    
      disable_my_thing():
        regulator_disable(reg)
        regulator_set_load(reg, 0)
    
    Sometimes disable_my_thing() sets a nominal (<= 100 uA) load instead
    of setting a 0 uA load.  I will make the assertion that nearly all (if
    not all) places where we set a nominal load of 100 uA or less we end
    up with a result that is the same as if we had set a load of 0 uA.
    Specifically:
    - The whole point of setting the load is to help set the operating
      mode of the regulator.  Higher loads may need less efficient
      operating modes.
    - The only time this matters at all is if there is another consumer of
      the regulator that wants the regulator on.  If there are no other
      consumers of the regulator then the regulator will turn off and we
      don't care about the operating mode.
    - If there's another consumer that actually wants the regulator on
      then presumably it is requesting a load that makes our nominal
      <= 100 uA load insignificant.
    
    A quick survey of the existing callers to regulator_set_load() to see
    how everyone uses it:
    
    Signed-off-by: Douglas Anderson <dianders@chromium.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/internal.h b/drivers/regulator/internal.h
index 943926a156f2..6017f15c5d75 100644
--- a/drivers/regulator/internal.h
+++ b/drivers/regulator/internal.h
@@ -42,6 +42,8 @@ struct regulator {
 	unsigned int always_on:1;
 	unsigned int bypass:1;
 	int uA_load;
+	unsigned int enable_count;
+	unsigned int deferred_disables;
 	struct regulator_voltage voltage[REGULATOR_STATES_NUM];
 	const char *supply_name;
 	struct device_attribute dev_attr;

commit a085a31af566254fb8f7721911c828c8fa797894
Author: Maciej Purski <m.purski@samsung.com>
Date:   Mon Apr 23 16:33:39 2018 +0200

    regulator: core: Parse coupled regulators properties
    
    On Odroid XU3/4 and other Exynos5422 based boards there is a case, that
    different devices on the board are supplied by different regulators
    with non-fixed voltages. If one of these devices temporarily requires
    higher voltage, there might occur a situation that the spread between
    devices' voltages is so high, that there is a risk of changing
    'high' and 'low' states on the interconnection between devices powered
    by those regulators.
    
    Add new structure "coupling_desc" to regulator_dev, which contains
    pointers to all coupled regulators including the owner of the structure,
    number of coupled regulators and counter of currently resolved
    regulators.
    
    Add of_functions to parse all data needed in regulator coupling.
    Provide method to check DTS data consistency. Check if each coupled
    regulator's max_spread is equal and if their lists of regulators match.
    
    Signed-off-by: Maciej Purski <m.purski@samsung.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/internal.h b/drivers/regulator/internal.h
index 24fde1e08f3a..943926a156f2 100644
--- a/drivers/regulator/internal.h
+++ b/drivers/regulator/internal.h
@@ -62,6 +62,14 @@ struct regulator_init_data *regulator_of_get_init_data(struct device *dev,
 			         const struct regulator_desc *desc,
 				 struct regulator_config *config,
 				 struct device_node **node);
+
+struct regulator_dev *of_parse_coupled_regulator(struct regulator_dev *rdev,
+						 int index);
+
+int of_get_n_coupled(struct regulator_dev *rdev);
+
+bool of_check_coupling_data(struct regulator_dev *rdev);
+
 #else
 static inline struct regulator_dev *
 of_find_regulator_by_node(struct device_node *np)
@@ -77,8 +85,25 @@ regulator_of_get_init_data(struct device *dev,
 {
 	return NULL;
 }
-#endif
 
+static inline struct regulator_dev *
+of_parse_coupled_regulator(struct regulator_dev *rdev,
+			   int index)
+{
+	return NULL;
+}
+
+static inline int of_get_n_coupled(struct regulator_dev *rdev)
+{
+	return 0;
+}
+
+static inline bool of_check_coupling_data(struct regulator_dev *rdev)
+{
+	return false;
+}
+
+#endif
 enum regulator_get_type {
 	NORMAL_GET,
 	EXCLUSIVE_GET,
@@ -88,5 +113,4 @@ enum regulator_get_type {
 
 struct regulator *_regulator_get(struct device *dev, const char *id,
 				 enum regulator_get_type get_type);
-
 #endif

commit 08813e0ec1cb48e53c86a24d88d26b26878e7b6e
Author: Changbin Du <changbin.du@intel.com>
Date:   Wed May 2 21:44:57 2018 +0800

    regulator: add dummy function of_find_regulator_by_node
    
    If device tree is not enabled, of_find_regulator_by_node() should have
    a dummy function since the function call is still there.
    
    This is to fix build error after CONFIG_NO_AUTO_INLINE is introduced.
    If this option is enabled, GCC will not auto-inline functions that are
    not explicitly marked as inline.
    
    In this case (no CONFIG_OF), the copmiler will report error in function
    regulator_dev_lookup().
    
    W/O NO_AUTO_INLINE, function of_get_regulator() is auto-inlined and then
    the call to of_find_regulator_by_node() is optimized out since
    of_get_regulator() always return NULL.
    
    W/ NO_AUTO_INLINE, the return value of of_get_regulator() is a variable
    so the call to of_find_regulator_by_node() cannot be optimized out. So
    we need a stub of_find_regulator_by_node().
    
    static struct regulator_dev *regulator_dev_lookup(struct device *dev,
                                                      const char *supply)
    {
            struct regulator_dev *r = NULL;
            struct device_node *node;
            struct regulator_map *map;
            const char *devname = NULL;
    
            regulator_supply_alias(&dev, &supply);
    
            /* first do a dt based lookup */
            if (dev && dev->of_node) {
                    node = of_get_regulator(dev, supply);
                    if (node) {
                            r = of_find_regulator_by_node(node);
                            if (r)
                                    return r;
            ...
    
    Signed-off-by: Changbin Du <changbin.du@intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/internal.h b/drivers/regulator/internal.h
index abfd56e8c78a..24fde1e08f3a 100644
--- a/drivers/regulator/internal.h
+++ b/drivers/regulator/internal.h
@@ -56,14 +56,19 @@ static inline struct regulator_dev *dev_to_rdev(struct device *dev)
 	return container_of(dev, struct regulator_dev, dev);
 }
 
-struct regulator_dev *of_find_regulator_by_node(struct device_node *np);
-
 #ifdef CONFIG_OF
+struct regulator_dev *of_find_regulator_by_node(struct device_node *np);
 struct regulator_init_data *regulator_of_get_init_data(struct device *dev,
 			         const struct regulator_desc *desc,
 				 struct regulator_config *config,
 				 struct device_node **node);
 #else
+static inline struct regulator_dev *
+of_find_regulator_by_node(struct device_node *np)
+{
+	return NULL;
+}
+
 static inline struct regulator_init_data *
 regulator_of_get_init_data(struct device *dev,
 			   const struct regulator_desc *desc,

commit 285c22de377dd6895af30af6272cc7778cee36a7
Merge: 3d67fe950707 f7efad10b5c4
Author: Mark Brown <broonie@kernel.org>
Date:   Fri Jan 26 17:40:03 2018 +0000

    Merge branch 'topic/suspend' of https://git.kernel.org/pub/scm/linux/kernel/git/broonie/regulator into regulator-core

commit 148096af0bf381c78afe253c07ef1c77778f0e68
Author: Maciej Purski <m.purski@samsung.com>
Date:   Mon Jan 22 15:30:06 2018 +0100

    regulator: core: Move of_find_regulator_by_node() to of_regulator.c
    
    As of_find_regulator_by_node() is an of function it should be moved from
    core.c to of_regulator.c. It provides better separation of device tree
    functions from the core and allows other of_functions in of_regulator.c
    to resolve device_node to regulator_dev. This will be useful for
    implementation of parsing coupled regulators properties.
    
    Declare of_find_regulator_by_node() function in internal.h as well as
    regulator_class and dev_to_rdev(), as they are needed by
    of_find_regulator_by_node().
    
    Signed-off-by: Maciej Purski <m.purski@samsung.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/internal.h b/drivers/regulator/internal.h
index 66a8ea0c8386..2f3218be5b8d 100644
--- a/drivers/regulator/internal.h
+++ b/drivers/regulator/internal.h
@@ -35,6 +35,15 @@ struct regulator {
 	struct dentry *debugfs;
 };
 
+extern struct class regulator_class;
+
+static inline struct regulator_dev *dev_to_rdev(struct device *dev)
+{
+	return container_of(dev, struct regulator_dev, dev);
+}
+
+struct regulator_dev *of_find_regulator_by_node(struct device_node *np);
+
 #ifdef CONFIG_OF
 struct regulator_init_data *regulator_of_get_init_data(struct device *dev,
 			         const struct regulator_desc *desc,

commit c360a6df02cdba47c0590ffc7d15ec6687183e8c
Author: Chunyan Zhang <zhang.chunyan@linaro.org>
Date:   Fri Jan 26 21:08:44 2018 +0800

    regulator: make regulator voltage be an array to support more states
    
    Some regulator consumers would like to make the regulator device
    keeping a voltage range output when the system entering into
    suspend states.
    
    Making regulator voltage be an array can allow consumers to set voltage
    for normal state as well as for suspend states through the same code.
    
    Signed-off-by: Chunyan Zhang <zhang.chunyan@linaro.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/internal.h b/drivers/regulator/internal.h
index 66a8ea0c8386..aba8e4149838 100644
--- a/drivers/regulator/internal.h
+++ b/drivers/regulator/internal.h
@@ -16,10 +16,25 @@
 #ifndef __REGULATOR_INTERNAL_H
 #define __REGULATOR_INTERNAL_H
 
+#include <linux/suspend.h>
+
+#define REGULATOR_STATES_NUM	(PM_SUSPEND_MAX + 1)
+
+struct regulator_voltage {
+	int min_uV;
+	int max_uV;
+};
+
 /*
  * struct regulator
  *
  * One for each consumer device.
+ * @voltage - a voltage array for each state of runtime, i.e.:
+ *            PM_SUSPEND_ON
+ *            PM_SUSPEND_TO_IDLE
+ *            PM_SUSPEND_STANDBY
+ *            PM_SUSPEND_MEM
+ *            PM_SUSPEND_MAX
  */
 struct regulator {
 	struct device *dev;
@@ -27,8 +42,7 @@ struct regulator {
 	unsigned int always_on:1;
 	unsigned int bypass:1;
 	int uA_load;
-	int min_uV;
-	int max_uV;
+	struct regulator_voltage voltage[REGULATOR_STATES_NUM];
 	const char *supply_name;
 	struct device_attribute dev_attr;
 	struct regulator_dev *rdev;

commit 0630b614391f8cbc35e837b4645ec8faaaa6465e
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Thu Mar 16 18:07:14 2017 -0700

    regulator: Mark supply_name const and duplicate it as such
    
    The supply_name member of struct regulator can be const as we
    don't change it in the regulator core. Furthermore, when we copy
    the supply name we can use kstrdup_const() here to avoid a copy
    if the name is in the ro data section.
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/internal.h b/drivers/regulator/internal.h
index 1dd575b28564..66a8ea0c8386 100644
--- a/drivers/regulator/internal.h
+++ b/drivers/regulator/internal.h
@@ -29,7 +29,7 @@ struct regulator {
 	int uA_load;
 	int min_uV;
 	int max_uV;
-	char *supply_name;
+	const char *supply_name;
 	struct device_attribute dev_attr;
 	struct regulator_dev *rdev;
 	struct dentry *debugfs;

commit a8bd42a97741aefa5942605fa87418fc8a6c4169
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Fri Feb 3 13:56:02 2017 -0800

    regulator: core: have _regulator_get() accept get_type argument
    
    Instead of separate "exclusive" and "allow_dummy" arguments, that formed 3
    valid combinations (normal, exclusive and optional) and an invalid one,
    let's accept explicit "get_type", like we did in devm-managed code.
    
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/internal.h b/drivers/regulator/internal.h
index c74ac8734023..1dd575b28564 100644
--- a/drivers/regulator/internal.h
+++ b/drivers/regulator/internal.h
@@ -51,4 +51,14 @@ regulator_of_get_init_data(struct device *dev,
 }
 #endif
 
+enum regulator_get_type {
+	NORMAL_GET,
+	EXCLUSIVE_GET,
+	OPTIONAL_GET,
+	MAX_GET_TYPE
+};
+
+struct regulator *_regulator_get(struct device *dev, const char *id,
+				 enum regulator_get_type get_type);
+
 #endif

commit bfa21a0dfe6915dc85953b5d40ea9dae5fdf205f
Author: Krzysztof Kozlowski <k.kozlowski@samsung.com>
Date:   Mon Jan 5 12:48:42 2015 +0100

    regulator: Allow parsing custom properties when using simplified DT parsing
    
    When drivers use simplified DT parsing method (they provide
    'regulator_desc.of_match') they still may want to parse custom
    properties for some of the regulators. For example some of the
    regulators support GPIO enable control.
    
    Add a driver-supplied callback for such case. This way the regulator
    core parses common bindings offloading a lot of code from drivers and
    still custom properties may be used.
    
    The callback, called for each parsed regulator, may modify the
    'regulator_config' initially passed to regulator_register().
    
    Signed-off-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/internal.h b/drivers/regulator/internal.h
index 80ba2a35a04b..c74ac8734023 100644
--- a/drivers/regulator/internal.h
+++ b/drivers/regulator/internal.h
@@ -38,11 +38,13 @@ struct regulator {
 #ifdef CONFIG_OF
 struct regulator_init_data *regulator_of_get_init_data(struct device *dev,
 			         const struct regulator_desc *desc,
+				 struct regulator_config *config,
 				 struct device_node **node);
 #else
 static inline struct regulator_init_data *
 regulator_of_get_init_data(struct device *dev,
 			   const struct regulator_desc *desc,
+			   struct regulator_config *config,
 			   struct device_node **node)
 {
 	return NULL;

commit ef126a4a8112998a9d4dcea166781331f1020f76
Author: Mark Brown <broonie@kernel.org>
Date:   Wed Sep 10 15:17:01 2014 +0100

    regulator: of: Add stub OF match function for !OF case
    
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/internal.h b/drivers/regulator/internal.h
index a6043ad32ead..80ba2a35a04b 100644
--- a/drivers/regulator/internal.h
+++ b/drivers/regulator/internal.h
@@ -35,8 +35,18 @@ struct regulator {
 	struct dentry *debugfs;
 };
 
+#ifdef CONFIG_OF
 struct regulator_init_data *regulator_of_get_init_data(struct device *dev,
 			         const struct regulator_desc *desc,
 				 struct device_node **node);
+#else
+static inline struct regulator_init_data *
+regulator_of_get_init_data(struct device *dev,
+			   const struct regulator_desc *desc,
+			   struct device_node **node)
+{
+	return NULL;
+}
+#endif
 
 #endif

commit a0c7b164ad115ec0556dc0904ee2218cbc5cedfa
Author: Mark Brown <broonie@kernel.org>
Date:   Tue Sep 9 23:13:57 2014 +0100

    regulator: of: Provide simplified DT parsing method
    
    Currently regulator drivers which support DT all repeat very similar code
    to supply a list of known regulator identifiers to be matched with DT,
    convert that to platform data which is then matched up with the regulators
    as they are registered. This is both fiddly to get right and for devices
    which can use the standard helpers to provide their operations is the main
    source of code in the driver.
    
    Since this code is essentially identical for most drivers we can factor it
    out into the core, moving the identifiers in the match table into the
    regulator descriptors and also allowing drivers to pass in the name of the
    subnode to search. When a driver provides an of_match string for the
    regulator the core will attempt to use that to obtain init_data, allowing
    the driver to remove all explicit code for DT parsing and simply provide
    data instead.
    
    The current code leaks the phandles for the child nodes, this will be
    addressed incrementally and makes no practical difference for FDT anyway
    as the DT data structures are never freed.
    
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/regulator/internal.h b/drivers/regulator/internal.h
index 84bbda10c396..a6043ad32ead 100644
--- a/drivers/regulator/internal.h
+++ b/drivers/regulator/internal.h
@@ -35,4 +35,8 @@ struct regulator {
 	struct dentry *debugfs;
 };
 
+struct regulator_init_data *regulator_of_get_init_data(struct device *dev,
+			         const struct regulator_desc *desc,
+				 struct device_node **node);
+
 #endif

commit 0cdfcc0f9352a4c076fbb51299e2b12a35619a51
Author: Mark Brown <broonie@linaro.org>
Date:   Wed Sep 11 13:15:40 2013 +0100

    regulator: core: Split devres code out into a separate file
    
    Cut down on the size of core.c a bit more and ensure that the devres
    versions of things don't do too much peering inside the internals of
    the APIs they wrap.
    
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/regulator/internal.h b/drivers/regulator/internal.h
new file mode 100644
index 000000000000..84bbda10c396
--- /dev/null
+++ b/drivers/regulator/internal.h
@@ -0,0 +1,38 @@
+/*
+ * internal.h  --  Voltage/Current Regulator framework internal code
+ *
+ * Copyright 2007, 2008 Wolfson Microelectronics PLC.
+ * Copyright 2008 SlimLogic Ltd.
+ *
+ * Author: Liam Girdwood <lrg@slimlogic.co.uk>
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ */
+
+#ifndef __REGULATOR_INTERNAL_H
+#define __REGULATOR_INTERNAL_H
+
+/*
+ * struct regulator
+ *
+ * One for each consumer device.
+ */
+struct regulator {
+	struct device *dev;
+	struct list_head list;
+	unsigned int always_on:1;
+	unsigned int bypass:1;
+	int uA_load;
+	int min_uV;
+	int max_uV;
+	char *supply_name;
+	struct device_attribute dev_attr;
+	struct regulator_dev *rdev;
+	struct dentry *debugfs;
+};
+
+#endif
