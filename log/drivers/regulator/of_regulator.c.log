commit deed1d44699135e5af7678442607469d14a92141
Merge: 13b86bc4cd64 77fd66c9ff3e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Oct 23 15:31:17 2019 -0400

    Merge tag 'regulator-fix-v5.4-rc4' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/regulator
    
    Pull regulator fixes from Mark Brown:
     "There are a few core fixes here around error handling and handling if
      suspend mode configuration and some driver specific fixes here but the
      most important change is the fix to the fixed-regulator DT schema
      conversion introduced during the last merge window.
    
      That fixes one of the last two errors preventing successful execution
      of "make dt_binding_check" which will be enormously helpful for DT
      schema development"
    
    * tag 'regulator-fix-v5.4-rc4' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/regulator:
      regulator: qcom-rpmh: Fix PMIC5 BoB min voltage
      regulator: pfuze100-regulator: Variable "val" in pfuze100_regulator_probe() could be uninitialized
      regulator: lochnagar: Add on_off_delay for VDDCORE
      regulator: ti-abb: Fix timeout in ti_abb_wait_txdone/ti_abb_clear_all_txdone
      regulator: da9062: fix suspend_enable/disable preparation
      dt-bindings: fixed-regulator: fix compatible enum
      regulator: fixed: Prevent NULL pointer dereference when !CONFIG_OF
      regulator: core: make regulator_register() EPROBE_DEFER aware
      regulator: of: fix suspend-min/max-voltage parsing

commit 4feaab05dc1eda3dbb57b097377766002e7a7cb9
Merge: e7345f92c27a 6d4faf3b6b6e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Sep 17 18:40:42 2019 -0700

    Merge tag 'leds-for-5.4-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/j.anaszewski/linux-leds
    
    Pull LED updates from Jacek Anaszewski:
     "In this cycle we've finally managed to contribute the patch set
      sorting out LED naming issues. Besides that there are many changes
      scattered among various LED class drivers and triggers.
    
      LED naming related improvements:
    
       - add new 'function' and 'color' fwnode properties and deprecate
         'label' property which has been frequently abused for conveying
         vendor specific names that have been available in sysfs anyway
    
       - introduce a set of standard LED_FUNCTION* definitions
    
       - introduce a set of standard LED_COLOR_ID* definitions
    
       - add a new {devm_}led_classdev_register_ext() API with the
         capability of automatic LED name composition basing on the
         properties available in the passed fwnode; the function is
         backwards compatible in a sense that it uses 'label' data, if
         present in the fwnode, for creating LED name
    
       - add tools/leds/get_led_device_info.sh script for retrieving LED
         vendor, product and bus names, if applicable; it also performs
         basic validation of an LED name
    
       - update following drivers and their DT bindings to use the new LED
         registration API:
    
            - leds-an30259a, leds-gpio, leds-as3645a, leds-aat1290, leds-cr0014114,
              leds-lm3601x, leds-lm3692x, leds-lp8860, leds-lt3593, leds-sc27xx-blt
    
      Other LED class improvements:
    
       - replace {devm_}led_classdev_register() macros with inlines
    
       - allow to call led_classdev_unregister() unconditionally
    
       - switch to use fwnode instead of be stuck with OF one
    
      LED triggers improvements:
    
       - led-triggers:
            - fix dereferencing of null pointer
            - fix a memory leak bug
    
       - ledtrig-gpio:
            - GPIO 0 is valid
    
      Drop superseeded apu2/3 support from leds-apu since for apu2+ a newer,
      more complete driver exists, based on a generic driver for the AMD
      SOCs gpio-controller, supporting LEDs as well other devices:
    
       - drop profile field from priv data
    
       - drop iosize field from priv data
    
       - drop enum_apu_led_platform_types
    
       - drop superseeded apu2/3 led support
    
       - add pr_fmt prefix for better log output
    
       - fix error message on probing failure
    
      Other misc fixes and improvements to existing LED class drivers:
    
       - leds-ns2, leds-max77650:
            - add of_node_put() before return
    
       - leds-pwm, leds-is31fl32xx:
            - use struct_size() helper
    
       - leds-lm3697, leds-lm36274, leds-lm3532:
            - switch to use fwnode_property_count_uXX()
    
       - leds-lm3532:
            - fix brightness control for i2c mode
            - change the define for the fs current register
            - fixes for the driver for stability
            - add full scale current configuration
            - dt: Add property for full scale current.
            - avoid potentially unpaired regulator calls
            - move static keyword to the front of declarations
            - fix optional led-max-microamp prop error handling
    
       - leds-max77650:
            - add of_node_put() before return
            - add MODULE_ALIAS()
            - Switch to fwnode property API
    
       - leds-as3645a:
            - fix misuse of strlcpy
    
       - leds-netxbig:
            - add of_node_put() in netxbig_leds_get_of_pdata()
            - remove legacy board-file support
    
       - leds-is31fl319x:
            - simplify getting the adapter of a client
    
       - leds-ti-lmu-common:
            - fix coccinelle issue
            - move static keyword to the front of declaration
    
       - leds-syscon:
            - use resource managed variant of device register
    
       - leds-ktd2692:
            - fix a typo in the name of a constant
    
       - leds-lp5562:
            - allow firmware files up to the maximum length
    
       - leds-an30259a:
            - fix typo
    
       - leds-pca953x:
            - include the right header"
    
    * tag 'leds-for-5.4-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/j.anaszewski/linux-leds: (72 commits)
      leds: lm3532: Fix optional led-max-microamp prop error handling
      led: triggers: Fix dereferencing of null pointer
      leds: ti-lmu-common: Move static keyword to the front of declaration
      leds: lm3532: Move static keyword to the front of declarations
      leds: trigger: gpio: GPIO 0 is valid
      leds: pwm: Use struct_size() helper
      leds: is31fl32xx: Use struct_size() helper
      leds: ti-lmu-common: Fix coccinelle issue in TI LMU
      leds: lm3532: Avoid potentially unpaired regulator calls
      leds: syscon: Use resource managed variant of device register
      leds: Replace {devm_}led_classdev_register() macros with inlines
      leds: Allow to call led_classdev_unregister() unconditionally
      leds: lm3532: Add full scale current configuration
      dt: lm3532: Add property for full scale current.
      leds: lm3532: Fixes for the driver for stability
      leds: lm3532: Change the define for the fs current register
      leds: lm3532: Fix brightness control for i2c mode
      leds: Switch to use fwnode instead of be stuck with OF one
      leds: max77650: Switch to fwnode property API
      led: triggers: Fix a memory leak bug
      ...

commit f8970d341eec73c976a3462b9ecdb02b60b84dd6
Author: Marco Felsch <m.felsch@pengutronix.de>
Date:   Tue Sep 17 17:40:21 2019 +0200

    regulator: core: make regulator_register() EPROBE_DEFER aware
    
    Sometimes it can happen that the regulator_of_get_init_data() can't
    retrieve the config due to a not probed device the regulator depends on.
    Fix that by checking the return value of of_parse_cb() and return
    EPROBE_DEFER in such cases.
    
    Signed-off-by: Marco Felsch <m.felsch@pengutronix.de>
    Link: https://lore.kernel.org/r/20190917154021.14693-4-m.felsch@pengutronix.de
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/of_regulator.c b/drivers/regulator/of_regulator.c
index 38dd06fbab38..ef7198b76e50 100644
--- a/drivers/regulator/of_regulator.c
+++ b/drivers/regulator/of_regulator.c
@@ -445,11 +445,20 @@ struct regulator_init_data *regulator_of_get_init_data(struct device *dev,
 		goto error;
 	}
 
-	if (desc->of_parse_cb && desc->of_parse_cb(child, desc, config)) {
-		dev_err(dev,
-			"driver callback failed to parse DT for regulator %pOFn\n",
-			child);
-		goto error;
+	if (desc->of_parse_cb) {
+		int ret;
+
+		ret = desc->of_parse_cb(child, desc, config);
+		if (ret) {
+			if (ret == -EPROBE_DEFER) {
+				of_node_put(child);
+				return ERR_PTR(-EPROBE_DEFER);
+			}
+			dev_err(dev,
+				"driver callback failed to parse DT for regulator %pOFn\n",
+				child);
+			goto error;
+		}
 	}
 
 	*node = child;

commit 131cb1210d4b58acb0695707dad2eb90dcb50a2a
Author: Marco Felsch <m.felsch@pengutronix.de>
Date:   Tue Sep 17 17:40:20 2019 +0200

    regulator: of: fix suspend-min/max-voltage parsing
    
    Currently the regulator-suspend-min/max-microvolt must be within the
    root regulator node but the dt-bindings specifies it as subnode
    properties for the regulator-state-[mem/disk/standby] node. The only DT
    using this bindings currently is the at91-sama5d2_xplained.dts and this
    DT uses it correctly. I don't know if it isn't tested but it can't work
    without this fix.
    
    Fixes: f7efad10b5c4 ("regulator: add PM suspend and resume hooks")
    Signed-off-by: Marco Felsch <m.felsch@pengutronix.de>
    Link: https://lore.kernel.org/r/20190917154021.14693-3-m.felsch@pengutronix.de
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/of_regulator.c b/drivers/regulator/of_regulator.c
index 9112faa6a9a0..38dd06fbab38 100644
--- a/drivers/regulator/of_regulator.c
+++ b/drivers/regulator/of_regulator.c
@@ -231,12 +231,12 @@ static int of_get_regulation_constraints(struct device *dev,
 					"regulator-off-in-suspend"))
 			suspend_state->enabled = DISABLE_IN_SUSPEND;
 
-		if (!of_property_read_u32(np, "regulator-suspend-min-microvolt",
-					  &pval))
+		if (!of_property_read_u32(suspend_np,
+				"regulator-suspend-min-microvolt", &pval))
 			suspend_state->min_uV = pval;
 
-		if (!of_property_read_u32(np, "regulator-suspend-max-microvolt",
-					  &pval))
+		if (!of_property_read_u32(suspend_np,
+				"regulator-suspend-max-microvolt", &pval))
 			suspend_state->max_uV = pval;
 
 		if (!of_property_read_u32(suspend_np,

commit 811ba489fa524ec634933cdf83aaf6c007a4c004
Author: Nishka Dasgupta <nishkadg.linux@gmail.com>
Date:   Wed Jul 24 14:02:31 2019 +0530

    regulator: of: Add of_node_put() before return in function
    
    The local variable search in regulator_of_get_init_node takes the value
    returned by either of_get_child_by_name or of_node_get, both of which
    get a node. If this node is not put before returning, it could cause a
    memory leak. Hence put search before a mid-loop return statement.
    Issue found with Coccinelle.
    
    Signed-off-by: Nishka Dasgupta <nishkadg.linux@gmail.com>
    Link: https://lore.kernel.org/r/20190724083231.10276-1-nishkadg.linux@gmail.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/of_regulator.c b/drivers/regulator/of_regulator.c
index 397918ebba55..9112faa6a9a0 100644
--- a/drivers/regulator/of_regulator.c
+++ b/drivers/regulator/of_regulator.c
@@ -416,8 +416,10 @@ device_node *regulator_of_get_init_node(struct device *dev,
 		if (!name)
 			name = child->name;
 
-		if (!strcmp(desc->of_match, name))
+		if (!strcmp(desc->of_match, name)) {
+			of_node_put(search);
 			return of_node_get(child);
+		}
 	}
 
 	of_node_put(search);

commit cfba5de9b99f8bbb8b4ea11b3049784e78b8759b
Author: Suzuki K Poulose <suzuki.poulose@arm.com>
Date:   Tue Jul 23 23:18:33 2019 +0100

    drivers: Introduce device lookup variants by of_node
    
    Introduce wrappers for {bus/driver/class}_find_device() to
    locate devices by its of_node.
    
    Cc: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Cc: Maxime Ripard <maxime.ripard@bootlin.com>
    Cc: dri-devel@lists.freedesktop.org
    Cc: David Airlie <airlied@linux.ie>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Cc: devicetree@vger.kernel.org
    Cc: Florian Fainelli <f.fainelli@gmail.com>
    Cc: Frank Rowand <frowand.list@gmail.com>
    Cc: Heiko Stuebner <heiko@sntech.de>
    Cc: Liam Girdwood <lgirdwood@gmail.com>
    Cc: linux-i2c@vger.kernel.org
    Cc: linux-rockchip@lists.infradead.org
    Cc: linux-spi@vger.kernel.org
    Cc: Mathieu Poirier <mathieu.poirier@linaro.org>
    Cc: Rob Herring <robh+dt@kernel.org>
    Cc: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
    Cc: Takashi Iwai <tiwai@suse.com>
    Cc: Alan Tull <atull@kernel.org>
    Cc: linux-fpga@vger.kernel.org
    Cc: Peter Rosin <peda@axentia.se>
    Cc: Florian Fainelli <f.fainelli@gmail.com>
    Cc: Heiner Kallweit <hkallweit1@gmail.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Andrew Lunn <andrew@lunn.ch>
    Cc: Liam Girdwood <lgirdwood@gmail.com>
    Cc: "Rafael J. Wysocki" <rafael@kernel.org>
    Cc: Thor Thayer <thor.thayer@linux.intel.com>
    Cc: Jiri Slaby <jslaby@suse.com>
    Cc: Andrew Lunn <andrew@lunn.ch>
    Cc: Peter Rosin <peda@axentia.se>
    Signed-off-by: Suzuki K Poulose <suzuki.poulose@arm.com>
    Acked-by: Lee Jones <lee.jones@linaro.org>
    Acked-by: Wolfram Sang <wsa@the-dreams.de> # I2C part
    Acked-by: Moritz Fischer <mdf@kernel.org> # For FPGA part
    Acked-by: Mark Brown <broonie@kernel.org>
    Link: https://lore.kernel.org/r/20190723221838.12024-3-suzuki.poulose@arm.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/regulator/of_regulator.c b/drivers/regulator/of_regulator.c
index 397918ebba55..20dcc9c03adc 100644
--- a/drivers/regulator/of_regulator.c
+++ b/drivers/regulator/of_regulator.c
@@ -460,16 +460,11 @@ struct regulator_init_data *regulator_of_get_init_data(struct device *dev,
 	return NULL;
 }
 
-static int of_node_match(struct device *dev, const void *data)
-{
-	return dev->of_node == data;
-}
-
 struct regulator_dev *of_find_regulator_by_node(struct device_node *np)
 {
 	struct device *dev;
 
-	dev = class_find_device(&regulator_class, NULL, np, of_node_match);
+	dev = class_find_device_by_of_node(&regulator_class, np);
 
 	return dev ? dev_to_rdev(dev) : NULL;
 }

commit 0ed4513c9a32a479b4dc41685be68edf1e99c139
Merge: 65244e5b1f4f d22b85a1b97d
Author: Mark Brown <broonie@kernel.org>
Date:   Thu Jul 4 17:34:34 2019 +0100

    Merge remote-tracking branch 'regulator/topic/coupled' into regulator-next

commit d8ca7d184b33af7913c244900df77c6cad6a5590
Author: Dmitry Osipenko <digetx@gmail.com>
Date:   Mon Jun 24 00:08:31 2019 +0300

    regulator: core: Introduce API for regulators coupling customization
    
    Right now regulator core supports only one type of regulators coupling,
    the "voltage max-spread" which keeps voltages of coupled regulators in a
    given range from each other. A more sophisticated coupling may be required
    in practice, one example is the NVIDIA Tegra SoCs which besides the
    max-spreading have other restrictions that must be adhered. Introduce API
    that allow platforms to provide their own customized coupling algorithms.
    
    Signed-off-by: Dmitry Osipenko <digetx@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/of_regulator.c b/drivers/regulator/of_regulator.c
index 6dca0ba044d8..db1cb2714b92 100644
--- a/drivers/regulator/of_regulator.c
+++ b/drivers/regulator/of_regulator.c
@@ -25,7 +25,8 @@ static const char *const regulator_states[PM_SUSPEND_MAX + 1] = {
 	[PM_SUSPEND_MAX]	= "regulator-state-disk",
 };
 
-static void of_get_regulation_constraints(struct device_node *np,
+static int of_get_regulation_constraints(struct device *dev,
+					struct device_node *np,
 					struct regulator_init_data **init_data,
 					const struct regulator_desc *desc)
 {
@@ -34,8 +35,13 @@ static void of_get_regulation_constraints(struct device_node *np,
 	struct device_node *suspend_np;
 	unsigned int mode;
 	int ret, i, len;
+	int n_phandles;
 	u32 pval;
 
+	n_phandles = of_count_phandle_with_args(np, "regulator-coupled-with",
+						NULL);
+	n_phandles = max(n_phandles, 0);
+
 	constraints->name = of_get_property(np, "regulator-name", NULL);
 
 	if (!of_property_read_u32(np, "regulator-min-microvolt", &pval))
@@ -167,9 +173,17 @@ static void of_get_regulation_constraints(struct device_node *np,
 	if (!of_property_read_u32(np, "regulator-system-load", &pval))
 		constraints->system_load = pval;
 
-	if (!of_property_read_u32(np, "regulator-coupled-max-spread",
-				  &pval))
-		constraints->max_spread = pval;
+	if (n_phandles) {
+		constraints->max_spread = devm_kzalloc(dev,
+				sizeof(*constraints->max_spread) * n_phandles,
+				GFP_KERNEL);
+
+		if (!constraints->max_spread)
+			return -ENOMEM;
+
+		of_property_read_u32_array(np, "regulator-coupled-max-spread",
+					   constraints->max_spread, n_phandles);
+	}
 
 	if (!of_property_read_u32(np, "regulator-max-step-microvolt",
 				  &pval))
@@ -246,6 +260,8 @@ static void of_get_regulation_constraints(struct device_node *np,
 		suspend_state = NULL;
 		suspend_np = NULL;
 	}
+
+	return 0;
 }
 
 /**
@@ -271,7 +287,9 @@ struct regulator_init_data *of_get_regulator_init_data(struct device *dev,
 	if (!init_data)
 		return NULL; /* Out of memory? */
 
-	of_get_regulation_constraints(node, &init_data, desc);
+	if (of_get_regulation_constraints(dev, node, &init_data, desc))
+		return NULL;
+
 	return init_data;
 }
 EXPORT_SYMBOL_GPL(of_get_regulator_init_data);
@@ -477,7 +495,8 @@ int of_get_n_coupled(struct regulator_dev *rdev)
 
 /* Looks for "to_find" device_node in src's "regulator-coupled-with" property */
 static bool of_coupling_find_node(struct device_node *src,
-				  struct device_node *to_find)
+				  struct device_node *to_find,
+				  int *index)
 {
 	int n_phandles, i;
 	bool found = false;
@@ -499,8 +518,10 @@ static bool of_coupling_find_node(struct device_node *src,
 
 		of_node_put(tmp);
 
-		if (found)
+		if (found) {
+			*index = i;
 			break;
+		}
 	}
 
 	return found;
@@ -521,22 +542,23 @@ static bool of_coupling_find_node(struct device_node *src,
  */
 bool of_check_coupling_data(struct regulator_dev *rdev)
 {
-	int max_spread = rdev->constraints->max_spread;
 	struct device_node *node = rdev->dev.of_node;
 	int n_phandles = of_get_n_coupled(rdev);
 	struct device_node *c_node;
+	int index;
 	int i;
 	bool ret = true;
 
-	if (max_spread <= 0) {
-		dev_err(&rdev->dev, "max_spread value invalid\n");
-		return false;
-	}
-
 	/* iterate over rdev's phandles */
 	for (i = 0; i < n_phandles; i++) {
+		int max_spread = rdev->constraints->max_spread[i];
 		int c_max_spread, c_n_phandles;
 
+		if (max_spread <= 0) {
+			dev_err(&rdev->dev, "max_spread value invalid\n");
+			return false;
+		}
+
 		c_node = of_parse_phandle(node,
 					  "regulator-coupled-with", i);
 
@@ -553,22 +575,23 @@ bool of_check_coupling_data(struct regulator_dev *rdev)
 			goto clean;
 		}
 
-		if (of_property_read_u32(c_node, "regulator-coupled-max-spread",
-					 &c_max_spread)) {
+		if (!of_coupling_find_node(c_node, node, &index)) {
+			dev_err(&rdev->dev, "missing 2-way linking for coupled regulators\n");
 			ret = false;
 			goto clean;
 		}
 
-		if (c_max_spread != max_spread) {
-			dev_err(&rdev->dev,
-				"coupled regulators max_spread mismatch\n");
+		if (of_property_read_u32_index(c_node, "regulator-coupled-max-spread",
+					       index, &c_max_spread)) {
 			ret = false;
 			goto clean;
 		}
 
-		if (!of_coupling_find_node(c_node, node)) {
-			dev_err(&rdev->dev, "missing 2-way linking for coupled regulators\n");
+		if (c_max_spread != max_spread) {
+			dev_err(&rdev->dev,
+				"coupled regulators max_spread mismatch\n");
 			ret = false;
+			goto clean;
 		}
 
 clean:

commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/regulator/of_regulator.c b/drivers/regulator/of_regulator.c
index 6dca0ba044d8..0ead1164e4d6 100644
--- a/drivers/regulator/of_regulator.c
+++ b/drivers/regulator/of_regulator.c
@@ -1,13 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * OF helpers for regulator framework
  *
  * Copyright (C) 2011 Texas Instruments, Inc.
  * Rajendra Nayak <rnayak@ti.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
  */
 
 #include <linux/module.h>

commit 7a67eb1d3abefe16b491b0e9801f98a98f15a3bf
Author: YueHaibing <yuehaibing@huawei.com>
Date:   Tue Mar 19 23:23:19 2019 +0800

    regulator: of: Make regulator_of_get_init_node static
    
    Fix sparse warning:
    
    drivers/regulator/of_regulator.c:374:20:
     warning: symbol 'regulator_of_get_init_node' was not declared. Should it be static?
    
    Signed-off-by: YueHaibing <yuehaibing@huawei.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/of_regulator.c b/drivers/regulator/of_regulator.c
index 7b6bf3536271..6dca0ba044d8 100644
--- a/drivers/regulator/of_regulator.c
+++ b/drivers/regulator/of_regulator.c
@@ -371,8 +371,9 @@ int of_regulator_match(struct device *dev, struct device_node *node,
 }
 EXPORT_SYMBOL_GPL(of_regulator_match);
 
-struct device_node *regulator_of_get_init_node(struct device *dev,
-					       const struct regulator_desc *desc)
+static struct
+device_node *regulator_of_get_init_node(struct device *dev,
+					const struct regulator_desc *desc)
 {
 	struct device_node *search, *child;
 	const char *name;

commit 48f1b4efd67c922eff113f247533cbe175b1491e
Author: Krzysztof Kozlowski <krzk@kernel.org>
Date:   Tue Jan 8 13:12:33 2019 +0100

    regulator: Fix trivial language typos
    
    Fix few trivial language typos in core and drivers.
    
    Signed-off-by: Krzysztof Kozlowski <krzk@kernel.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/of_regulator.c b/drivers/regulator/of_regulator.c
index ffa5fc3724e4..7b6bf3536271 100644
--- a/drivers/regulator/of_regulator.c
+++ b/drivers/regulator/of_regulator.c
@@ -255,7 +255,7 @@ static void of_get_regulation_constraints(struct device_node *np,
  * @desc: regulator description
  *
  * Populates regulator_init_data structure by extracting data from device
- * tree node, returns a pointer to the populated struture or NULL if memory
+ * tree node, returns a pointer to the populated structure or NULL if memory
  * alloc fails.
  */
 struct regulator_init_data *of_get_regulator_init_data(struct device *dev,
@@ -547,7 +547,7 @@ bool of_check_coupling_data(struct regulator_dev *rdev)
 							  NULL);
 
 		if (c_n_phandles != n_phandles) {
-			dev_err(&rdev->dev, "number of couped reg phandles mismatch\n");
+			dev_err(&rdev->dev, "number of coupled reg phandles mismatch\n");
 			ret = false;
 			goto clean;
 		}

commit eba9473f6761d8df6cabf278b272cc5466733737
Author: Charles Keepax <ckeepax@opensource.cirrus.com>
Date:   Thu Nov 29 10:28:21 2018 +0000

    regulator: Allow regulator nodes to contain their own init data
    
    Currently it is expected that regulator init data will be defined as a
    series of sub-nodes from the node that bound in the driver. Add support
    for a node to both bind in a driver and contain init data for that
    regulator.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.cirrus.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/of_regulator.c b/drivers/regulator/of_regulator.c
index 4bb8928bdb3f..ffa5fc3724e4 100644
--- a/drivers/regulator/of_regulator.c
+++ b/drivers/regulator/of_regulator.c
@@ -380,12 +380,16 @@ struct device_node *regulator_of_get_init_node(struct device *dev,
 	if (!dev->of_node || !desc->of_match)
 		return NULL;
 
-	if (desc->regulators_node)
+	if (desc->regulators_node) {
 		search = of_get_child_by_name(dev->of_node,
 					      desc->regulators_node);
-	else
+	} else {
 		search = of_node_get(dev->of_node);
 
+		if (!strcmp(desc->of_match, search->name))
+			return search;
+	}
+
 	if (!search) {
 		dev_dbg(dev, "Failed to find regulator container node '%s'\n",
 			desc->regulators_node);

commit 925c85e21ed8773c8b0ab01d60618b862847a10f
Author: Charles Keepax <ckeepax@opensource.cirrus.com>
Date:   Thu Nov 29 10:28:20 2018 +0000

    regulator: Factor out location of init data OF node
    
    To support future additions factor out the location of the OF node
    containing the init data for the regulator from the code that parses the
    init data.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.cirrus.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/of_regulator.c b/drivers/regulator/of_regulator.c
index c711a0a2bc4b..4bb8928bdb3f 100644
--- a/drivers/regulator/of_regulator.c
+++ b/drivers/regulator/of_regulator.c
@@ -371,13 +371,10 @@ int of_regulator_match(struct device *dev, struct device_node *node,
 }
 EXPORT_SYMBOL_GPL(of_regulator_match);
 
-struct regulator_init_data *regulator_of_get_init_data(struct device *dev,
-					    const struct regulator_desc *desc,
-					    struct regulator_config *config,
-					    struct device_node **node)
+struct device_node *regulator_of_get_init_node(struct device *dev,
+					       const struct regulator_desc *desc)
 {
 	struct device_node *search, *child;
-	struct regulator_init_data *init_data = NULL;
 	const char *name;
 
 	if (!dev->of_node || !desc->of_match)
@@ -400,35 +397,48 @@ struct regulator_init_data *regulator_of_get_init_data(struct device *dev,
 		if (!name)
 			name = child->name;
 
-		if (strcmp(desc->of_match, name))
-			continue;
+		if (!strcmp(desc->of_match, name))
+			return of_node_get(child);
+	}
 
-		init_data = of_get_regulator_init_data(dev, child, desc);
-		if (!init_data) {
-			dev_err(dev,
-				"failed to parse DT for regulator %pOFn\n",
-				child);
-			break;
-		}
+	of_node_put(search);
 
-		if (desc->of_parse_cb) {
-			if (desc->of_parse_cb(child, desc, config)) {
-				dev_err(dev,
-					"driver callback failed to parse DT for regulator %pOFn\n",
-					child);
-				init_data = NULL;
-				break;
-			}
-		}
+	return NULL;
+}
 
-		of_node_get(child);
-		*node = child;
-		break;
+struct regulator_init_data *regulator_of_get_init_data(struct device *dev,
+					    const struct regulator_desc *desc,
+					    struct regulator_config *config,
+					    struct device_node **node)
+{
+	struct device_node *child;
+	struct regulator_init_data *init_data = NULL;
+
+	child = regulator_of_get_init_node(dev, desc);
+	if (!child)
+		return NULL;
+
+	init_data = of_get_regulator_init_data(dev, child, desc);
+	if (!init_data) {
+		dev_err(dev, "failed to parse DT for regulator %pOFn\n", child);
+		goto error;
 	}
 
-	of_node_put(search);
+	if (desc->of_parse_cb && desc->of_parse_cb(child, desc, config)) {
+		dev_err(dev,
+			"driver callback failed to parse DT for regulator %pOFn\n",
+			child);
+		goto error;
+	}
+
+	*node = child;
 
 	return init_data;
+
+error:
+	of_node_put(child);
+
+	return NULL;
 }
 
 static int of_node_match(struct device *dev, const void *data)

commit ffb8c1e45e7ae648a3a1689aa71be50fb459316e
Merge: a8d8ee437ea0 ff9b34b615a3
Author: Mark Brown <broonie@kernel.org>
Date:   Mon Nov 19 13:16:15 2018 +0000

    Merge branch 'topic/coupled' of https://git.kernel.org/pub/scm/linux/kernel/git/broonie/regulator into regulator-4.21 for trivial conflict

commit f2b4076988a9c229dab373470b4b108ef0e106c8
Author: Andrei.Stefanescu@microchip.com <Andrei.Stefanescu@microchip.com>
Date:   Tue Nov 13 14:47:37 2018 +0000

    regulator: of: add support for parsing regulator-state-standby
    
    Set the according constraints for PM_SUSPEND_STANDBY case.
    Previously, only suspend to mem/disk were taken into
    consideration.
    
    Signed-off-by: Andrei Stefanescu <andrei.stefanescu@microchip.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/of_regulator.c b/drivers/regulator/of_regulator.c
index c4223b3e0dff..82fb1228ca2c 100644
--- a/drivers/regulator/of_regulator.c
+++ b/drivers/regulator/of_regulator.c
@@ -20,6 +20,7 @@
 #include "internal.h"
 
 static const char *const regulator_states[PM_SUSPEND_MAX + 1] = {
+	[PM_SUSPEND_STANDBY]	= "regulator-state-standby",
 	[PM_SUSPEND_MEM]	= "regulator-state-mem",
 	[PM_SUSPEND_MAX]	= "regulator-state-disk",
 };
@@ -181,9 +182,11 @@ static void of_get_regulation_constraints(struct device_node *np,
 		case PM_SUSPEND_MAX:
 			suspend_state = &constraints->state_disk;
 			break;
+		case PM_SUSPEND_STANDBY:
+			suspend_state = &constraints->state_standby;
+			break;
 		case PM_SUSPEND_ON:
 		case PM_SUSPEND_TO_IDLE:
-		case PM_SUSPEND_STANDBY:
 		default:
 			continue;
 		}

commit 85254bcf394f93a8955814da1eef4d477b63eb84
Author: Dmitry Osipenko <digetx@gmail.com>
Date:   Fri Oct 5 18:36:35 2018 +0300

    regulator: core: Add new max_uV_step constraint
    
    On NVIDIA Tegra30 there is a requirement for regulator "A" to have voltage
    higher than voltage of regulator "B" by N microvolts, the N value changes
    depending on the voltage of regulator "B". This is similar to min-spread
    between voltages of regulators, the difference is that the spread value
    isn't fixed. This means that extra carefulness is required for regulator
    "A" to drop its voltage without violating the requirement, hence its
    voltage should be changed in steps so that its couple "B" could follow
    (there is also max-spread requirement).
    
    Add new "max_uV_step" constraint that breaks voltage change into several
    steps, each step is limited by the max_uV_step value.
    
    Signed-off-by: Dmitry Osipenko <digetx@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/of_regulator.c b/drivers/regulator/of_regulator.c
index c4223b3e0dff..a732f09d207b 100644
--- a/drivers/regulator/of_regulator.c
+++ b/drivers/regulator/of_regulator.c
@@ -170,6 +170,10 @@ static void of_get_regulation_constraints(struct device_node *np,
 				  &pval))
 		constraints->max_spread = pval;
 
+	if (!of_property_read_u32(np, "regulator-max-step-microvolt",
+				  &pval))
+		constraints->max_uV_step = pval;
+
 	constraints->over_current_protection = of_property_read_bool(np,
 					"regulator-over-current-protection");
 

commit 2e0fe4d0c6ca59c3c05f9e6b0067d70cb9821500
Merge: 61b2e6741e81 fb6de923ca33
Author: Mark Brown <broonie@kernel.org>
Date:   Fri Sep 28 14:50:33 2018 +0100

    Merge tag 'regulator-v4.19-rc5' into regulator-bd718xx
    
    regulator: Fixes for 4.19
    
    A collection of fairly minor bug fixes here, a couple of driver specific
    ones plus two core fixes.  There's one fix for the new suspend state
    code which fixes some confusion with constant values that are supposed
    to indicate noop operation and another fixing a race condition with the
    creation of sysfs files on new regulators.

commit 3edd79cf5a44b12dbb13bc320f5788aed6562b36
Author: Marek Szyprowski <m.szyprowski@samsung.com>
Date:   Mon Sep 3 16:49:37 2018 +0200

    regulator: Fix 'do-nothing' value for regulators without suspend state
    
    Some regulators don't have all states defined and in such cases regulator
    core should not assume anything. However in current implementation
    of of_get_regulation_constraints() DO_NOTHING_IN_SUSPEND enable value was
    set only for regulators which had suspend node defined, otherwise the
    default 0 value was used, what means DISABLE_IN_SUSPEND. This lead to
    broken system suspend/resume on boards, which had simple regulator
    constraints definition (without suspend state nodes).
    
    To avoid further mismatches between the default and uninitialized values
    of the suspend enabled/disabled states, change the values of the them,
    so default '0' means DO_NOTHING_IN_SUSPEND.
    
    Fixes: 72069f9957a1: regulator: leave one item to record whether regulator is enabled
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Cc: stable@vger.kernel.org

diff --git a/drivers/regulator/of_regulator.c b/drivers/regulator/of_regulator.c
index 638f17d4c848..210fc20f7de7 100644
--- a/drivers/regulator/of_regulator.c
+++ b/drivers/regulator/of_regulator.c
@@ -213,8 +213,6 @@ static void of_get_regulation_constraints(struct device_node *np,
 		else if (of_property_read_bool(suspend_np,
 					"regulator-off-in-suspend"))
 			suspend_state->enabled = DISABLE_IN_SUSPEND;
-		else
-			suspend_state->enabled = DO_NOTHING_IN_SUSPEND;
 
 		if (!of_property_read_u32(np, "regulator-suspend-min-microvolt",
 					  &pval))

commit 0c9721a5d1dea7122601dc8694e7d4a208874b84
Author: Rob Herring <robh@kernel.org>
Date:   Mon Aug 27 20:52:42 2018 -0500

    regulator: Convert to using %pOFn instead of device_node.name
    
    In preparation to remove the node name pointer from struct device_node,
    convert printf users to use the %pOFn format specifier.
    
    Signed-off-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/of_regulator.c b/drivers/regulator/of_regulator.c
index 638f17d4c848..92a516b959a7 100644
--- a/drivers/regulator/of_regulator.c
+++ b/drivers/regulator/of_regulator.c
@@ -95,8 +95,8 @@ static void of_get_regulation_constraints(struct device_node *np,
 	if (!ret)
 		constraints->settling_time_up = pval;
 	if (constraints->settling_time_up && constraints->settling_time) {
-		pr_warn("%s: ambiguous configuration for settling time, ignoring 'regulator-settling-time-up-us'\n",
-			np->name);
+		pr_warn("%pOFn: ambiguous configuration for settling time, ignoring 'regulator-settling-time-up-us'\n",
+			np);
 		constraints->settling_time_up = 0;
 	}
 
@@ -105,8 +105,8 @@ static void of_get_regulation_constraints(struct device_node *np,
 	if (!ret)
 		constraints->settling_time_down = pval;
 	if (constraints->settling_time_down && constraints->settling_time) {
-		pr_warn("%s: ambiguous configuration for settling time, ignoring 'regulator-settling-time-down-us'\n",
-			np->name);
+		pr_warn("%pOFn: ambiguous configuration for settling time, ignoring 'regulator-settling-time-down-us'\n",
+			np);
 		constraints->settling_time_down = 0;
 	}
 
@@ -127,12 +127,12 @@ static void of_get_regulation_constraints(struct device_node *np,
 		if (desc && desc->of_map_mode) {
 			mode = desc->of_map_mode(pval);
 			if (mode == REGULATOR_MODE_INVALID)
-				pr_err("%s: invalid mode %u\n", np->name, pval);
+				pr_err("%pOFn: invalid mode %u\n", np, pval);
 			else
 				constraints->initial_mode = mode;
 		} else {
-			pr_warn("%s: mapping for mode %d not defined\n",
-				np->name, pval);
+			pr_warn("%pOFn: mapping for mode %d not defined\n",
+				np, pval);
 		}
 	}
 
@@ -144,14 +144,14 @@ static void of_get_regulation_constraints(struct device_node *np,
 				ret = of_property_read_u32_index(np,
 					"regulator-allowed-modes", i, &pval);
 				if (ret) {
-					pr_err("%s: couldn't read allowed modes index %d, ret=%d\n",
-						np->name, i, ret);
+					pr_err("%pOFn: couldn't read allowed modes index %d, ret=%d\n",
+						np, i, ret);
 					break;
 				}
 				mode = desc->of_map_mode(pval);
 				if (mode == REGULATOR_MODE_INVALID)
-					pr_err("%s: invalid regulator-allowed-modes element %u\n",
-						np->name, pval);
+					pr_err("%pOFn: invalid regulator-allowed-modes element %u\n",
+						np, pval);
 				else
 					constraints->valid_modes_mask |= mode;
 			}
@@ -159,7 +159,7 @@ static void of_get_regulation_constraints(struct device_node *np,
 				constraints->valid_ops_mask
 					|= REGULATOR_CHANGE_MODE;
 		} else {
-			pr_warn("%s: mode mapping not defined\n", np->name);
+			pr_warn("%pOFn: mode mapping not defined\n", np);
 		}
 	}
 
@@ -197,13 +197,13 @@ static void of_get_regulation_constraints(struct device_node *np,
 			if (desc && desc->of_map_mode) {
 				mode = desc->of_map_mode(pval);
 				if (mode == REGULATOR_MODE_INVALID)
-					pr_err("%s: invalid mode %u\n",
-					       np->name, pval);
+					pr_err("%pOFn: invalid mode %u\n",
+					       np, pval);
 				else
 					suspend_state->mode = mode;
 			} else {
-				pr_warn("%s: mapping for mode %d not defined\n",
-					np->name, pval);
+				pr_warn("%pOFn: mapping for mode %d not defined\n",
+					np, pval);
 			}
 		}
 
@@ -351,8 +351,8 @@ int of_regulator_match(struct device *dev, struct device_node *node,
 							   match->desc);
 			if (!match->init_data) {
 				dev_err(dev,
-					"failed to parse DT for regulator %s\n",
-					child->name);
+					"failed to parse DT for regulator %pOFn\n",
+					child);
 				of_node_put(child);
 				return -EINVAL;
 			}
@@ -401,16 +401,16 @@ struct regulator_init_data *regulator_of_get_init_data(struct device *dev,
 		init_data = of_get_regulator_init_data(dev, child, desc);
 		if (!init_data) {
 			dev_err(dev,
-				"failed to parse DT for regulator %s\n",
-				child->name);
+				"failed to parse DT for regulator %pOFn\n",
+				child);
 			break;
 		}
 
 		if (desc->of_parse_cb) {
 			if (desc->of_parse_cb(child, desc, config)) {
 				dev_err(dev,
-					"driver callback failed to parse DT for regulator %s\n",
-					child->name);
+					"driver callback failed to parse DT for regulator %pOFn\n",
+					child);
 				init_data = NULL;
 				break;
 			}

commit a085a31af566254fb8f7721911c828c8fa797894
Author: Maciej Purski <m.purski@samsung.com>
Date:   Mon Apr 23 16:33:39 2018 +0200

    regulator: core: Parse coupled regulators properties
    
    On Odroid XU3/4 and other Exynos5422 based boards there is a case, that
    different devices on the board are supplied by different regulators
    with non-fixed voltages. If one of these devices temporarily requires
    higher voltage, there might occur a situation that the spread between
    devices' voltages is so high, that there is a risk of changing
    'high' and 'low' states on the interconnection between devices powered
    by those regulators.
    
    Add new structure "coupling_desc" to regulator_dev, which contains
    pointers to all coupled regulators including the owner of the structure,
    number of coupled regulators and counter of currently resolved
    regulators.
    
    Add of_functions to parse all data needed in regulator coupling.
    Provide method to check DTS data consistency. Check if each coupled
    regulator's max_spread is equal and if their lists of regulators match.
    
    Signed-off-by: Maciej Purski <m.purski@samsung.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/of_regulator.c b/drivers/regulator/of_regulator.c
index d61fed28fdb9..638f17d4c848 100644
--- a/drivers/regulator/of_regulator.c
+++ b/drivers/regulator/of_regulator.c
@@ -166,6 +166,10 @@ static void of_get_regulation_constraints(struct device_node *np,
 	if (!of_property_read_u32(np, "regulator-system-load", &pval))
 		constraints->system_load = pval;
 
+	if (!of_property_read_u32(np, "regulator-coupled-max-spread",
+				  &pval))
+		constraints->max_spread = pval;
+
 	constraints->over_current_protection = of_property_read_bool(np,
 					"regulator-over-current-protection");
 
@@ -435,3 +439,150 @@ struct regulator_dev *of_find_regulator_by_node(struct device_node *np)
 
 	return dev ? dev_to_rdev(dev) : NULL;
 }
+
+/*
+ * Returns number of regulators coupled with rdev.
+ */
+int of_get_n_coupled(struct regulator_dev *rdev)
+{
+	struct device_node *node = rdev->dev.of_node;
+	int n_phandles;
+
+	n_phandles = of_count_phandle_with_args(node,
+						"regulator-coupled-with",
+						NULL);
+
+	return (n_phandles > 0) ? n_phandles : 0;
+}
+
+/* Looks for "to_find" device_node in src's "regulator-coupled-with" property */
+static bool of_coupling_find_node(struct device_node *src,
+				  struct device_node *to_find)
+{
+	int n_phandles, i;
+	bool found = false;
+
+	n_phandles = of_count_phandle_with_args(src,
+						"regulator-coupled-with",
+						NULL);
+
+	for (i = 0; i < n_phandles; i++) {
+		struct device_node *tmp = of_parse_phandle(src,
+					   "regulator-coupled-with", i);
+
+		if (!tmp)
+			break;
+
+		/* found */
+		if (tmp == to_find)
+			found = true;
+
+		of_node_put(tmp);
+
+		if (found)
+			break;
+	}
+
+	return found;
+}
+
+/**
+ * of_check_coupling_data - Parse rdev's coupling properties and check data
+ *			    consistency
+ * @rdev - pointer to regulator_dev whose data is checked
+ *
+ * Function checks if all the following conditions are met:
+ * - rdev's max_spread is greater than 0
+ * - all coupled regulators have the same max_spread
+ * - all coupled regulators have the same number of regulator_dev phandles
+ * - all regulators are linked to each other
+ *
+ * Returns true if all conditions are met.
+ */
+bool of_check_coupling_data(struct regulator_dev *rdev)
+{
+	int max_spread = rdev->constraints->max_spread;
+	struct device_node *node = rdev->dev.of_node;
+	int n_phandles = of_get_n_coupled(rdev);
+	struct device_node *c_node;
+	int i;
+	bool ret = true;
+
+	if (max_spread <= 0) {
+		dev_err(&rdev->dev, "max_spread value invalid\n");
+		return false;
+	}
+
+	/* iterate over rdev's phandles */
+	for (i = 0; i < n_phandles; i++) {
+		int c_max_spread, c_n_phandles;
+
+		c_node = of_parse_phandle(node,
+					  "regulator-coupled-with", i);
+
+		if (!c_node)
+			ret = false;
+
+		c_n_phandles = of_count_phandle_with_args(c_node,
+							  "regulator-coupled-with",
+							  NULL);
+
+		if (c_n_phandles != n_phandles) {
+			dev_err(&rdev->dev, "number of couped reg phandles mismatch\n");
+			ret = false;
+			goto clean;
+		}
+
+		if (of_property_read_u32(c_node, "regulator-coupled-max-spread",
+					 &c_max_spread)) {
+			ret = false;
+			goto clean;
+		}
+
+		if (c_max_spread != max_spread) {
+			dev_err(&rdev->dev,
+				"coupled regulators max_spread mismatch\n");
+			ret = false;
+			goto clean;
+		}
+
+		if (!of_coupling_find_node(c_node, node)) {
+			dev_err(&rdev->dev, "missing 2-way linking for coupled regulators\n");
+			ret = false;
+		}
+
+clean:
+		of_node_put(c_node);
+		if (!ret)
+			break;
+	}
+
+	return ret;
+}
+
+/**
+ * of_parse_coupled regulator - Get regulator_dev pointer from rdev's property
+ * @rdev: Pointer to regulator_dev, whose DTS is used as a source to parse
+ *	  "regulator-coupled-with" property
+ * @index: Index in phandles array
+ *
+ * Returns the regulator_dev pointer parsed from DTS. If it has not been yet
+ * registered, returns NULL
+ */
+struct regulator_dev *of_parse_coupled_regulator(struct regulator_dev *rdev,
+						 int index)
+{
+	struct device_node *node = rdev->dev.of_node;
+	struct device_node *c_node;
+	struct regulator_dev *c_rdev;
+
+	c_node = of_parse_phandle(node, "regulator-coupled-with", index);
+	if (!c_node)
+		return NULL;
+
+	c_rdev = of_find_regulator_by_node(c_node);
+
+	of_node_put(c_node);
+
+	return c_rdev;
+}

commit 54557ad9737e28b06b632cce723ef2373fe6bf12
Author: David Collins <collinsd@codeaurora.org>
Date:   Fri May 11 18:46:47 2018 -0700

    regulator: of: add support for allowed modes configuration
    
    Add support for configuring the machine constraints
    valid_modes_mask element based on a list of allowed modes
    specified via a device tree property.
    
    Signed-off-by: David Collins <collinsd@codeaurora.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/of_regulator.c b/drivers/regulator/of_regulator.c
index 0d3f73eacb99..d61fed28fdb9 100644
--- a/drivers/regulator/of_regulator.c
+++ b/drivers/regulator/of_regulator.c
@@ -32,7 +32,7 @@ static void of_get_regulation_constraints(struct device_node *np,
 	struct regulator_state *suspend_state;
 	struct device_node *suspend_np;
 	unsigned int mode;
-	int ret, i;
+	int ret, i, len;
 	u32 pval;
 
 	constraints->name = of_get_property(np, "regulator-name", NULL);
@@ -136,6 +136,33 @@ static void of_get_regulation_constraints(struct device_node *np,
 		}
 	}
 
+	len = of_property_count_elems_of_size(np, "regulator-allowed-modes",
+						sizeof(u32));
+	if (len > 0) {
+		if (desc && desc->of_map_mode) {
+			for (i = 0; i < len; i++) {
+				ret = of_property_read_u32_index(np,
+					"regulator-allowed-modes", i, &pval);
+				if (ret) {
+					pr_err("%s: couldn't read allowed modes index %d, ret=%d\n",
+						np->name, i, ret);
+					break;
+				}
+				mode = desc->of_map_mode(pval);
+				if (mode == REGULATOR_MODE_INVALID)
+					pr_err("%s: invalid regulator-allowed-modes element %u\n",
+						np->name, pval);
+				else
+					constraints->valid_modes_mask |= mode;
+			}
+			if (constraints->valid_modes_mask)
+				constraints->valid_ops_mask
+					|= REGULATOR_CHANGE_MODE;
+		} else {
+			pr_warn("%s: mode mapping not defined\n", np->name);
+		}
+	}
+
 	if (!of_property_read_u32(np, "regulator-system-load", &pval))
 		constraints->system_load = pval;
 

commit 02f3703934a42417021405ef336fe45add13c3d1
Author: Douglas Anderson <dianders@chromium.org>
Date:   Wed Apr 18 08:54:18 2018 -0700

    regulator: Don't return or expect -errno from of_map_mode()
    
    In of_get_regulation_constraints() we were taking the result of
    of_map_mode() (an unsigned int) and assigning it to an int.  We were
    then checking whether this value was -EINVAL.  Some implementers of
    of_map_mode() were returning -EINVAL (even though the return type of
    their function needed to be unsigned int) because they needed to
    signal an error back to of_get_regulation_constraints().
    
    In general in the regulator framework the mode is always referred to
    as an unsigned int.  While we could fix this to be a signed int (the
    highest value we store in there right now is 0x8), it's actually
    pretty clean to just define the regulator mode 0x0 (the lack of any
    bits set) as an invalid mode.  Let's do that.
    
    Fixes: 5e5e3a42c653 ("regulator: of: Add support for parsing initial and suspend modes")
    Suggested-by: Javier Martinez Canillas <javierm@redhat.com>
    Signed-off-by: Douglas Anderson <dianders@chromium.org>
    Reviewed-by: Javier Martinez Canillas <javierm@redhat.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/of_regulator.c b/drivers/regulator/of_regulator.c
index f47264fa1940..0d3f73eacb99 100644
--- a/drivers/regulator/of_regulator.c
+++ b/drivers/regulator/of_regulator.c
@@ -31,6 +31,7 @@ static void of_get_regulation_constraints(struct device_node *np,
 	struct regulation_constraints *constraints = &(*init_data)->constraints;
 	struct regulator_state *suspend_state;
 	struct device_node *suspend_np;
+	unsigned int mode;
 	int ret, i;
 	u32 pval;
 
@@ -124,11 +125,11 @@ static void of_get_regulation_constraints(struct device_node *np,
 
 	if (!of_property_read_u32(np, "regulator-initial-mode", &pval)) {
 		if (desc && desc->of_map_mode) {
-			ret = desc->of_map_mode(pval);
-			if (ret == -EINVAL)
+			mode = desc->of_map_mode(pval);
+			if (mode == REGULATOR_MODE_INVALID)
 				pr_err("%s: invalid mode %u\n", np->name, pval);
 			else
-				constraints->initial_mode = ret;
+				constraints->initial_mode = mode;
 		} else {
 			pr_warn("%s: mapping for mode %d not defined\n",
 				np->name, pval);
@@ -163,12 +164,12 @@ static void of_get_regulation_constraints(struct device_node *np,
 		if (!of_property_read_u32(suspend_np, "regulator-mode",
 					  &pval)) {
 			if (desc && desc->of_map_mode) {
-				ret = desc->of_map_mode(pval);
-				if (ret == -EINVAL)
+				mode = desc->of_map_mode(pval);
+				if (mode == REGULATOR_MODE_INVALID)
 					pr_err("%s: invalid mode %u\n",
 					       np->name, pval);
 				else
-					suspend_state->mode = ret;
+					suspend_state->mode = mode;
 			} else {
 				pr_warn("%s: mapping for mode %d not defined\n",
 					np->name, pval);

commit 30966861a7a2051457be8c49466887d78cc47e97
Author: Christophe JAILLET <christophe.jaillet@wanadoo.fr>
Date:   Fri Jan 26 23:13:44 2018 +0100

    regulator: of: Add a missing 'of_node_put()' in an error handling path of 'of_regulator_match()'
    
    If an unlikely failure in 'of_get_regulator_init_data()' occurs, we must
    release the reference on the current 'child' node before returning.
    
    Signed-off-by: Christophe JAILLET <christophe.jaillet@wanadoo.fr>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/of_regulator.c b/drivers/regulator/of_regulator.c
index 092ed6efb3ec..f47264fa1940 100644
--- a/drivers/regulator/of_regulator.c
+++ b/drivers/regulator/of_regulator.c
@@ -321,6 +321,7 @@ int of_regulator_match(struct device *dev, struct device_node *node,
 				dev_err(dev,
 					"failed to parse DT for regulator %s\n",
 					child->name);
+				of_node_put(child);
 				return -EINVAL;
 			}
 			match->of_node = of_node_get(child);

commit 285c22de377dd6895af30af6272cc7778cee36a7
Merge: 3d67fe950707 f7efad10b5c4
Author: Mark Brown <broonie@kernel.org>
Date:   Fri Jan 26 17:40:03 2018 +0000

    Merge branch 'topic/suspend' of https://git.kernel.org/pub/scm/linux/kernel/git/broonie/regulator into regulator-core

commit 148096af0bf381c78afe253c07ef1c77778f0e68
Author: Maciej Purski <m.purski@samsung.com>
Date:   Mon Jan 22 15:30:06 2018 +0100

    regulator: core: Move of_find_regulator_by_node() to of_regulator.c
    
    As of_find_regulator_by_node() is an of function it should be moved from
    core.c to of_regulator.c. It provides better separation of device tree
    functions from the core and allows other of_functions in of_regulator.c
    to resolve device_node to regulator_dev. This will be useful for
    implementation of parsing coupled regulators properties.
    
    Declare of_find_regulator_by_node() function in internal.h as well as
    regulator_class and dev_to_rdev(), as they are needed by
    of_find_regulator_by_node().
    
    Signed-off-by: Maciej Purski <m.purski@samsung.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/of_regulator.c b/drivers/regulator/of_regulator.c
index 14637a01ba2d..54e810ae93d6 100644
--- a/drivers/regulator/of_regulator.c
+++ b/drivers/regulator/of_regulator.c
@@ -376,3 +376,17 @@ struct regulator_init_data *regulator_of_get_init_data(struct device *dev,
 
 	return init_data;
 }
+
+static int of_node_match(struct device *dev, const void *data)
+{
+	return dev->of_node == data;
+}
+
+struct regulator_dev *of_find_regulator_by_node(struct device_node *np)
+{
+	struct device *dev;
+
+	dev = class_find_device(&regulator_class, NULL, np, of_node_match);
+
+	return dev ? dev_to_rdev(dev) : NULL;
+}

commit f7efad10b5c492892b1e5decf5d3ebb29fa5c9af
Author: Chunyan Zhang <zhang.chunyan@linaro.org>
Date:   Fri Jan 26 21:08:47 2018 +0800

    regulator: add PM suspend and resume hooks
    
    In this patch, consumers are allowed to set suspend voltage, and this
    actually just set the "uV" in constraint::regulator_state, when the
    regulator_suspend_late() was called by PM core through callback when
    the system is entering into suspend, the regulator device would act
    suspend activity then.
    
    And it assumes that if any consumer set suspend voltage, the regulator
    device should be enabled in the suspend state.  And if the suspend
    voltage of a regulator device for all consumers was set zero, the
    regulator device would be off in the suspend state.
    
    This patch also provides a new function hook to regulator devices for
    resuming from suspend states.
    
    Signed-off-by: Chunyan Zhang <zhang.chunyan@linaro.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/of_regulator.c b/drivers/regulator/of_regulator.c
index 41dad42b18f0..a09ef6cc2e9c 100644
--- a/drivers/regulator/of_regulator.c
+++ b/drivers/regulator/of_regulator.c
@@ -184,9 +184,23 @@ static void of_get_regulation_constraints(struct device_node *np,
 		else
 			suspend_state->enabled = DO_NOTHING_IN_SUSPEND;
 
+		if (!of_property_read_u32(np, "regulator-suspend-min-microvolt",
+					  &pval))
+			suspend_state->min_uV = pval;
+
+		if (!of_property_read_u32(np, "regulator-suspend-max-microvolt",
+					  &pval))
+			suspend_state->max_uV = pval;
+
 		if (!of_property_read_u32(suspend_np,
 					"regulator-suspend-microvolt", &pval))
 			suspend_state->uV = pval;
+		else /* otherwise use min_uV as default suspend voltage */
+			suspend_state->uV = suspend_state->min_uV;
+
+		if (of_property_read_bool(suspend_np,
+					"regulator-changeable-in-suspend"))
+			suspend_state->changeable = true;
 
 		if (i == PM_SUSPEND_MEM)
 			constraints->initial_state = PM_SUSPEND_MEM;

commit 72069f9957a11896e79e95c8b55ec815e97c2187
Author: Chunyan Zhang <zhang.chunyan@linaro.org>
Date:   Fri Jan 26 21:08:45 2018 +0800

    regulator: leave one item to record whether regulator is enabled
    
    The items "disabled" and "enabled" are a little redundant, since only one
    of them would be set to record if the regulator device should keep on
    or be switched to off in suspend states.
    
    So in this patch, the "disabled" was removed, only leave the "enabled":
      - enabled == 1 for regulator-on-in-suspend
      - enabled == 0 for regulator-off-in-suspend
      - enabled == -1 means do nothing when entering suspend mode.
    
    Signed-off-by: Chunyan Zhang <zhang.chunyan@linaro.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/of_regulator.c b/drivers/regulator/of_regulator.c
index 14637a01ba2d..41dad42b18f0 100644
--- a/drivers/regulator/of_regulator.c
+++ b/drivers/regulator/of_regulator.c
@@ -177,10 +177,12 @@ static void of_get_regulation_constraints(struct device_node *np,
 
 		if (of_property_read_bool(suspend_np,
 					"regulator-on-in-suspend"))
-			suspend_state->enabled = true;
+			suspend_state->enabled = ENABLE_IN_SUSPEND;
 		else if (of_property_read_bool(suspend_np,
 					"regulator-off-in-suspend"))
-			suspend_state->disabled = true;
+			suspend_state->enabled = DISABLE_IN_SUSPEND;
+		else
+			suspend_state->enabled = DO_NOTHING_IN_SUSPEND;
 
 		if (!of_property_read_u32(suspend_np,
 					"regulator-suspend-microvolt", &pval))

commit 439644096c1a6afb9bd9953130f4444a856f76c5
Merge: b42a362e6d10 d97561f461e4
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Sep 5 12:19:08 2017 -0700

    Merge tag 'pm-4.14-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull power management updates from Rafael Wysocki:
     "This time (again) cpufreq gets the majority of changes which mostly
      are driver updates (including a major consolidation of intel_pstate),
      some schedutil governor modifications and core cleanups.
    
      There also are some changes in the system suspend area, mostly related
      to diagnostics and debug messages plus some renames of things related
      to suspend-to-idle. One major change here is that suspend-to-idle is
      now going to be preferred over S3 on systems where the ACPI tables
      indicate to do so and provide requsite support (the Low Power Idle S0
      _DSM in particular). The system sleep documentation and the tools
      related to it are updated too.
    
      The rest is a few cpuidle changes (nothing major), devfreq updates,
      generic power domains (genpd) framework updates and a few assorted
      modifications elsewhere.
    
      Specifics:
    
       - Drop the P-state selection algorithm based on a PID controller from
         intel_pstate and make it use the same P-state selection method
         (based on the CPU load) for all types of systems in the active mode
         (Rafael Wysocki, Srinivas Pandruvada).
    
       - Rework the cpufreq core and governors to make it possible to take
         cross-CPU utilization updates into account and modify the schedutil
         governor to actually do so (Viresh Kumar).
    
       - Clean up the handling of transition latency information in the
         cpufreq core and untangle it from the information on which drivers
         cannot do dynamic frequency switching (Viresh Kumar).
    
       - Add support for new SoCs (MT2701/MT7623 and MT7622) to the mediatek
         cpufreq driver and update its DT bindings (Sean Wang).
    
       - Modify the cpufreq dt-platdev driver to autimatically create
         cpufreq devices for the new (v2) Operating Performance Points (OPP)
         DT bindings and update its whitelist of supported systems (Viresh
         Kumar, Shubhrajyoti Datta, Marc Gonzalez, Khiem Nguyen, Finley
         Xiao).
    
       - Add support for Ux500 to the cpufreq-dt driver and drop the
         obsolete dbx500 cpufreq driver (Linus Walleij, Arnd Bergmann).
    
       - Add new SoC (R8A7795) support to the cpufreq rcar driver (Khiem
         Nguyen).
    
       - Fix and clean up assorted issues in the cpufreq drivers and core
         (Arvind Yadav, Christophe Jaillet, Colin Ian King, Gustavo Silva,
         Julia Lawall, Leonard Crestez, Rob Herring, Sudeep Holla).
    
       - Update the IO-wait boost handling in the schedutil governor to make
         it less aggressive (Joel Fernandes).
    
       - Rework system suspend diagnostics to make it print fewer messages
         to the kernel log by default, add a sysfs knob to allow more
         suspend-related messages to be printed and add Low Power S0 Idle
         constraints checks to the ACPI suspend-to-idle code (Rafael
         Wysocki, Srinivas Pandruvada).
    
       - Prefer suspend-to-idle over S3 on ACPI-based systems with the
         ACPI_FADT_LOW_POWER_S0 flag set and the Low Power Idle S0 _DSM
         interface present in the ACPI tables (Rafael Wysocki).
    
       - Update documentation related to system sleep and rename a number of
         items in the code to make it cleare that they are related to
         suspend-to-idle (Rafael Wysocki).
    
       - Export a variable allowing device drivers to check the target
         system sleep state from the core system suspend code (Florian
         Fainelli).
    
       - Clean up the cpuidle subsystem to handle the polling state on x86
         in a more straightforward way and to use %pOF instead of full_name
         (Rafael Wysocki, Rob Herring).
    
       - Update the devfreq framework to fix and clean up a few minor issues
         (Chanwoo Choi, Rob Herring).
    
       - Extend diagnostics in the generic power domains (genpd) framework
         and clean it up slightly (Thara Gopinath, Rob Herring).
    
       - Fix and clean up a couple of issues in the operating performance
         points (OPP) framework (Viresh Kumar, Waldemar Rymarkiewicz).
    
       - Add support for RV1108 to the rockchip-io Adaptive Voltage Scaling
         (AVS) driver (David Wu).
    
       - Fix the usage of notifiers in CPU power management on some
         platforms (Alex Shi).
    
       - Update the pm-graph system suspend/hibernation and boot profiling
         utility (Todd Brandt).
    
       - Make it possible to run the cpupower utility without CPU0 (Prarit
         Bhargava)"
    
    * tag 'pm-4.14-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (87 commits)
      cpuidle: Make drivers initialize polling state
      cpuidle: Move polling state initialization code to separate file
      cpuidle: Eliminate the CPUIDLE_DRIVER_STATE_START symbol
      cpufreq: imx6q: Fix imx6sx low frequency support
      cpufreq: speedstep-lib: make several arrays static, makes code smaller
      PM: docs: Delete the obsolete states.txt document
      PM: docs: Describe high-level PM strategies and sleep states
      PM / devfreq: Fix memory leak when fail to register device
      PM / devfreq: Add dependency on PM_OPP
      PM / devfreq: Move private devfreq_update_stats() into devfreq
      PM / devfreq: Convert to using %pOF instead of full_name
      PM / AVS: rockchip-io: add io selectors and supplies for RV1108
      cpufreq: ti: Fix 'of_node_put' being called twice in error handling path
      cpufreq: dt-platdev: Drop few entries from whitelist
      cpufreq: dt-platdev: Automatically create cpufreq device with OPP v2
      ARM: ux500: don't select CPUFREQ_DT
      cpuidle: Convert to using %pOF instead of full_name
      cpufreq: Convert to using %pOF instead of full_name
      PM / Domains: Convert to using %pOF instead of full_name
      cpufreq: Cap the default transition delay value to 10 ms
      ...

commit 690cbb90a709c1b9389c6cb8e1978e77553ce0fb
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Aug 10 00:13:07 2017 +0200

    PM / s2idle: Rename PM_SUSPEND_FREEZE to PM_SUSPEND_TO_IDLE
    
    To make it clear that the symbol in question refers to
    suspend-to-idle, rename it from PM_SUSPEND_FREEZE to
    PM_SUSPEND_TO_IDLE.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/regulator/of_regulator.c b/drivers/regulator/of_regulator.c
index 96bf75458da5..860480ecf2be 100644
--- a/drivers/regulator/of_regulator.c
+++ b/drivers/regulator/of_regulator.c
@@ -150,7 +150,7 @@ static void of_get_regulation_constraints(struct device_node *np,
 			suspend_state = &constraints->state_disk;
 			break;
 		case PM_SUSPEND_ON:
-		case PM_SUSPEND_FREEZE:
+		case PM_SUSPEND_TO_IDLE:
 		case PM_SUSPEND_STANDBY:
 		default:
 			continue;

commit 423a11647c53e9d7ebbea1c61bc469ea13dafeff
Author: Frank Rowand <frank.rowand@sony.com>
Date:   Tue Jul 18 16:36:37 2017 -0700

    regulator: of: regulator_of_get_init_data() missing of_node_get()
    
    Boot fails for qcom-apq8074-dragonboard on 4.13-rc1 with error:
    OF: ERROR: Bad of_node_put() on /soc/spmi@fc4cf000/pm8941@1/regulators
    
    The error will occur if the configuration is set to:
       CONFIG_OF_OVERLAY y
       CONFIG_OF_UNITTEST y
       CONFIG_OF_DYNAMIC y
       CONFIG_OF_RESOLVE y
    
    If CONFIG_OF_DYNAMIC is enabled then of_node_release() detects an
    attempt to release a node that is still attached to the device tree.
    
    Signed-off-by: Frank Rowand <frank.rowand@sony.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/of_regulator.c b/drivers/regulator/of_regulator.c
index 96bf75458da5..9dd44dd4cdf6 100644
--- a/drivers/regulator/of_regulator.c
+++ b/drivers/regulator/of_regulator.c
@@ -333,7 +333,7 @@ struct regulator_init_data *regulator_of_get_init_data(struct device *dev,
 		search = of_get_child_by_name(dev->of_node,
 					      desc->regulators_node);
 	else
-		search = dev->of_node;
+		search = of_node_get(dev->of_node);
 
 	if (!search) {
 		dev_dbg(dev, "Failed to find regulator container node '%s'\n",

commit 3ffad468cf1d9825b425733941bdad0d8d20e795
Author: Matthias Kaehlcke <mka@chromium.org>
Date:   Tue May 16 11:43:43 2017 -0700

    regulator: Allow for asymmetric settling times
    
    Some regulators have different settling times for voltage increases and
    decreases. To avoid a time penalty on the faster transition allow for
    different settings for up- and downward transitions.
    
    Signed-off-by: Matthias Kaehlcke <mka@chromium.org>
    Acked-by: Laxman Dewangan <ldewangan@nvidia.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/of_regulator.c b/drivers/regulator/of_regulator.c
index 09d677d5d3f0..96bf75458da5 100644
--- a/drivers/regulator/of_regulator.c
+++ b/drivers/regulator/of_regulator.c
@@ -90,6 +90,25 @@ static void of_get_regulation_constraints(struct device_node *np,
 	if (!ret)
 		constraints->settling_time = pval;
 
+	ret = of_property_read_u32(np, "regulator-settling-time-up-us", &pval);
+	if (!ret)
+		constraints->settling_time_up = pval;
+	if (constraints->settling_time_up && constraints->settling_time) {
+		pr_warn("%s: ambiguous configuration for settling time, ignoring 'regulator-settling-time-up-us'\n",
+			np->name);
+		constraints->settling_time_up = 0;
+	}
+
+	ret = of_property_read_u32(np, "regulator-settling-time-down-us",
+				   &pval);
+	if (!ret)
+		constraints->settling_time_down = pval;
+	if (constraints->settling_time_down && constraints->settling_time) {
+		pr_warn("%s: ambiguous configuration for settling time, ignoring 'regulator-settling-time-down-us'\n",
+			np->name);
+		constraints->settling_time_down = 0;
+	}
+
 	ret = of_property_read_u32(np, "regulator-enable-ramp-delay", &pval);
 	if (!ret)
 		constraints->enable_time = pval;

commit d6c1dc3f52e3a65f35c58433ba57d14c0bad902f
Author: Laxman Dewangan <ldewangan@nvidia.com>
Date:   Tue Apr 4 18:59:50 2017 +0530

    regulator: Add settling time for non-linear voltage transition
    
    Some regulators (some PWM regulators) have the voltage transition
    non-linear i.e. exponentially. On such cases, the settling time
    for voltage transition can not be presented in the voltage-ramp-delay.
    
    Add new property for non-linear voltage transition and handle this
    in getting the voltage settling time.
    
    Signed-off-by: Laxman Dewangan <ldewangan@nvidia.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/of_regulator.c b/drivers/regulator/of_regulator.c
index 4f613ec99500..09d677d5d3f0 100644
--- a/drivers/regulator/of_regulator.c
+++ b/drivers/regulator/of_regulator.c
@@ -86,6 +86,10 @@ static void of_get_regulation_constraints(struct device_node *np,
 			constraints->ramp_disable = true;
 	}
 
+	ret = of_property_read_u32(np, "regulator-settling-time-us", &pval);
+	if (!ret)
+		constraints->settling_time = pval;
+
 	ret = of_property_read_u32(np, "regulator-enable-ramp-delay", &pval);
 	if (!ret)
 		constraints->enable_time = pval;

commit a0f78bc89c0396d14b6102c6f72485e14c8821f3
Author: Keerthy <j-keerthy@ti.com>
Date:   Mon Jun 20 14:13:31 2016 +0530

    regulator: of: setup initial suspend state
    
    Setup initial suspend state to mem, if suspend state is defined for
    mem state. This makes sure that the regulators are in proper mode
    already from boot.
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Signed-off-by: Dave Gerlach <d-gerlach@ti.com>
    Signed-off-by: Keerthy <j-keerthy@ti.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/of_regulator.c b/drivers/regulator/of_regulator.c
index cd828dbf9d52..4f613ec99500 100644
--- a/drivers/regulator/of_regulator.c
+++ b/drivers/regulator/of_regulator.c
@@ -163,6 +163,9 @@ static void of_get_regulation_constraints(struct device_node *np,
 					"regulator-suspend-microvolt", &pval))
 			suspend_state->uV = pval;
 
+		if (i == PM_SUSPEND_MEM)
+			constraints->initial_state = PM_SUSPEND_MEM;
+
 		of_node_put(suspend_np);
 		suspend_state = NULL;
 		suspend_np = NULL;

commit 45fa2038cf7820ecfcca8793b81e656ca3caaf0f
Author: Mark Brown <broonie@kernel.org>
Date:   Wed Mar 30 08:26:09 2016 -0700

    regulator: of: Don't flag voltage change as possible for exact voltages
    
    Flagging voltage changes as possible for exactly specified voltages
    appears to be triggering bugs in the SDHCI code (it should be able to
    handle the case where only one voltage it wants is in the range it is
    allowed to set) so make sure we only set the flag in cases where there's
    genuine variability.
    
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/of_regulator.c b/drivers/regulator/of_regulator.c
index f45106a44635..cd828dbf9d52 100644
--- a/drivers/regulator/of_regulator.c
+++ b/drivers/regulator/of_regulator.c
@@ -43,10 +43,12 @@ static void of_get_regulation_constraints(struct device_node *np,
 		constraints->max_uV = pval;
 
 	/* Voltage change possible? */
-	if (constraints->min_uV && constraints->max_uV) {
+	if (constraints->min_uV != constraints->max_uV)
 		constraints->valid_ops_mask |= REGULATOR_CHANGE_VOLTAGE;
+
+	/* Do we have a voltage range, if so try to apply it? */
+	if (constraints->min_uV && constraints->max_uV)
 		constraints->apply_uV = true;
-	}
 
 	if (!of_property_read_u32(np, "regulator-microvolt-offset", &pval))
 		constraints->uV_offset = pval;

commit fa93fd4ecc9c58475abac6db93a797bff893bc16
Author: Mark Brown <broonie@kernel.org>
Date:   Mon Mar 21 18:12:52 2016 +0000

    regulator: core: Ensure we are at least in bounds for our constraints
    
    Currently we only attempt to set the voltage during constraints
    application if an exact voltage is specified.  Extend this so that if
    the currently set voltage for the regulator is outside the bounds set in
    constraints we will move the voltage to the nearest constraint, raising
    to the minimum or lowering to the maximum as needed.  This ensures that
    drivers can probe without the hardware being driven out of spec.
    
    Reported-by: Ivaylo Dimitrov <ivo.g.dimitrov.75@gmail.com>
    Tested-by: Ivaylo Dimitrov <ivo.g.dimitrov.75@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/of_regulator.c b/drivers/regulator/of_regulator.c
index d2ddefaaddaf..f45106a44635 100644
--- a/drivers/regulator/of_regulator.c
+++ b/drivers/regulator/of_regulator.c
@@ -43,7 +43,7 @@ static void of_get_regulation_constraints(struct device_node *np,
 		constraints->max_uV = pval;
 
 	/* Voltage change possible? */
-	if (constraints->min_uV != constraints->max_uV) {
+	if (constraints->min_uV && constraints->max_uV) {
 		constraints->valid_ops_mask |= REGULATOR_CHANGE_VOLTAGE;
 		constraints->apply_uV = true;
 	}

commit 895fe2321efaf62023fdd8239d1846394df68570
Author: Mark Brown <broonie@kernel.org>
Date:   Mon Mar 21 18:17:43 2016 +0000

    regulator: core: Always flag voltage constraints as appliable
    
    Allow the core to always use the voltage constraints to set the voltage
    on startup.  A forthcoming change in that code will ensure that we bring
    out of constraints voltages into spec with this setting.
    
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/of_regulator.c b/drivers/regulator/of_regulator.c
index 6b0aa80b22fd..d2ddefaaddaf 100644
--- a/drivers/regulator/of_regulator.c
+++ b/drivers/regulator/of_regulator.c
@@ -43,12 +43,10 @@ static void of_get_regulation_constraints(struct device_node *np,
 		constraints->max_uV = pval;
 
 	/* Voltage change possible? */
-	if (constraints->min_uV != constraints->max_uV)
+	if (constraints->min_uV != constraints->max_uV) {
 		constraints->valid_ops_mask |= REGULATOR_CHANGE_VOLTAGE;
-	/* Only one voltage?  Then make sure it's set. */
-	if (constraints->min_uV && constraints->max_uV &&
-	    constraints->min_uV == constraints->max_uV)
 		constraints->apply_uV = true;
+	}
 
 	if (!of_property_read_u32(np, "regulator-microvolt-offset", &pval))
 		constraints->uV_offset = pval;

commit 41eeb34acd3def009b1dd827364c9ed6d70ca4ea
Merge: d6d50a8f1741 abbf043b6508 a34785f10d33 a7c2ded6962d f907a0a9498d 7ddec6412149
Author: Mark Brown <broonie@kernel.org>
Date:   Sun Mar 13 15:20:00 2016 +0700

    Merge remote-tracking branches 'regulator/topic/mt6397', 'regulator/topic/of', 'regulator/topic/pv88060', 'regulator/topic/pwm' and 'regulator/topic/s2mps11' into regulator-next

commit a34785f10d33f70680941da284d7ec3a612aad1a
Author: Laxman Dewangan <ldewangan@nvidia.com>
Date:   Thu Mar 10 17:42:47 2016 +0530

    regulator: of: Use of_property_read_u32() for reading min/max
    
    OF interface provides to read the u32 value via standard interface
    of_property_read_u32(). Use this API to read "regulator-min-microvolts"
    and "regulator-max-microvolt".
    
    This will make consistent with other property value reads.
    
    Signed-off-by: Laxman Dewangan <ldewangan@nvidia.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/of_regulator.c b/drivers/regulator/of_regulator.c
index 499e437c7e91..92818979ed8f 100644
--- a/drivers/regulator/of_regulator.c
+++ b/drivers/regulator/of_regulator.c
@@ -28,7 +28,6 @@ static void of_get_regulation_constraints(struct device_node *np,
 					struct regulator_init_data **init_data,
 					const struct regulator_desc *desc)
 {
-	const __be32 *min_uV, *max_uV;
 	struct regulation_constraints *constraints = &(*init_data)->constraints;
 	struct regulator_state *suspend_state;
 	struct device_node *suspend_np;
@@ -37,18 +36,18 @@ static void of_get_regulation_constraints(struct device_node *np,
 
 	constraints->name = of_get_property(np, "regulator-name", NULL);
 
-	min_uV = of_get_property(np, "regulator-min-microvolt", NULL);
-	if (min_uV)
-		constraints->min_uV = be32_to_cpu(*min_uV);
-	max_uV = of_get_property(np, "regulator-max-microvolt", NULL);
-	if (max_uV)
-		constraints->max_uV = be32_to_cpu(*max_uV);
+	if (!of_property_read_u32(np, "regulator-min-microvolt", &pval))
+		constraints->min_uV = pval;
+
+	if (!of_property_read_u32(np, "regulator-max-microvolt", &pval))
+		constraints->max_uV = pval;
 
 	/* Voltage change possible? */
 	if (constraints->min_uV != constraints->max_uV)
 		constraints->valid_ops_mask |= REGULATOR_CHANGE_VOLTAGE;
 	/* Only one voltage?  Then make sure it's set. */
-	if (min_uV && max_uV && constraints->min_uV == constraints->max_uV)
+	if (constraints->min_uV && constraints->max_uV &&
+	    constraints->min_uV == constraints->max_uV)
 		constraints->apply_uV = true;
 
 	if (!of_property_read_u32(np, "regulator-microvolt-offset", &pval))

commit 670666b9e0aff40c65d8061a2f53e79eee238685
Author: Laxman Dewangan <ldewangan@nvidia.com>
Date:   Wed Mar 2 16:24:46 2016 +0530

    regulator: core: Add support for active-discharge configuration
    
    Add support to enable/disable active discharge of regulator via
    machine constraints. This configuration is done when setting
    machine constraint during regulator register and if regulator
    driver implemented the callback ops.
    
    Signed-off-by: Laxman Dewangan <ldewangan@nvidia.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/of_regulator.c b/drivers/regulator/of_regulator.c
index 499e437c7e91..fe2e33441dae 100644
--- a/drivers/regulator/of_regulator.c
+++ b/drivers/regulator/of_regulator.c
@@ -93,6 +93,12 @@ static void of_get_regulation_constraints(struct device_node *np,
 
 	constraints->soft_start = of_property_read_bool(np,
 					"regulator-soft-start");
+	ret = of_property_read_u32(np, "regulator-active-discharge", &pval);
+	if (!ret) {
+		constraints->active_discharge =
+				(pval) ? REGULATOR_ACTIVE_DISCHARGE_ENABLE :
+					REGULATOR_ACTIVE_DISCHARGE_DISABLE;
+	}
 
 	if (!of_property_read_u32(np, "regulator-initial-mode", &pval)) {
 		if (desc && desc->of_map_mode) {

commit b263d20373d7726dd3ac0cd5e32f123e69a02847
Author: Bjorn Andersson <bjorn.andersson@sonymobile.com>
Date:   Tue Aug 18 15:14:06 2015 -0700

    regulator: Introduce property to flag set-load support
    
    Introduce "regulator-allow-set-load" property to make it possible to
    flag in the board configuration that a regulator is allowed to have the
    load requirements changed.
    
    Signed-off-by: Bjorn Andersson <bjorn.andersson@sonymobile.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/of_regulator.c b/drivers/regulator/of_regulator.c
index 250700c853bf..499e437c7e91 100644
--- a/drivers/regulator/of_regulator.c
+++ b/drivers/regulator/of_regulator.c
@@ -76,6 +76,9 @@ static void of_get_regulation_constraints(struct device_node *np,
 	if (of_property_read_bool(np, "regulator-allow-bypass"))
 		constraints->valid_ops_mask |= REGULATOR_CHANGE_BYPASS;
 
+	if (of_property_read_bool(np, "regulator-allow-set-load"))
+		constraints->valid_ops_mask |= REGULATOR_CHANGE_DRMS;
+
 	ret = of_property_read_u32(np, "regulator-ramp-delay", &pval);
 	if (!ret) {
 		if (pval)

commit 3a003baeec246f604ed1d2e0087560d7f15edcc6
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Fri Jul 17 14:41:54 2015 -0700

    regulator: Add over current protection (OCP) support
    
    Some regulators can automatically shut down when they detect an
    over current event. Add an op (set_over_current_protection) and a
    DT property + constraint to support this capability.
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/of_regulator.c b/drivers/regulator/of_regulator.c
index b1c485b24ab2..250700c853bf 100644
--- a/drivers/regulator/of_regulator.c
+++ b/drivers/regulator/of_regulator.c
@@ -107,6 +107,9 @@ static void of_get_regulation_constraints(struct device_node *np,
 	if (!of_property_read_u32(np, "regulator-system-load", &pval))
 		constraints->system_load = pval;
 
+	constraints->over_current_protection = of_property_read_bool(np,
+					"regulator-over-current-protection");
+
 	for (i = 0; i < ARRAY_SIZE(regulator_states); i++) {
 		switch (i) {
 		case PM_SUSPEND_MEM:

commit 733ada000f2c9618ccbac7b9ba146113f0a6675b
Merge: 0460a368ea4c 130daa3f3570 ab101e35448b 419d06a1cf58 c751ad0dd640
Author: Mark Brown <broonie@kernel.org>
Date:   Mon Jun 22 11:19:56 2015 +0100

    Merge remote-tracking branches 'regulator/topic/of', 'regulator/topic/pwm', 'regulator/topic/qcom' and 'regulator/topic/soft-start' into regulator-next

commit c16bcf03c8c29aaf68e281bfd2b8634f313a58d7
Merge: 4055da975de9 d87aef9164a5 126187dafd22 fda87a4283cf 9eac5fdfabc6 36e4f839de59
Author: Mark Brown <broonie@kernel.org>
Date:   Mon Jun 22 11:19:52 2015 +0100

    Merge remote-tracking branches 'regulator/topic/da9063', 'regulator/topic/doc', 'regulator/topic/fan53555', 'regulator/topic/gpio' and 'regulator/topic/ilim' into regulator-next

commit 36e4f839de59b6216a16cdf5c1d3263f4dbd9421
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Thu Jun 11 17:37:06 2015 -0700

    regulator: Add input current limit support
    
    Some regulators can limit their input current (typically annotated
    as ilim). Add an op (set_input_current_limit) and a DT property +
    constraint to support this.
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/of_regulator.c b/drivers/regulator/of_regulator.c
index 207da037cd2d..f025c1047d0a 100644
--- a/drivers/regulator/of_regulator.c
+++ b/drivers/regulator/of_regulator.c
@@ -58,6 +58,10 @@ static void of_get_regulation_constraints(struct device_node *np,
 	if (!of_property_read_u32(np, "regulator-max-microamp", &pval))
 		constraints->max_uA = pval;
 
+	if (!of_property_read_u32(np, "regulator-input-current-limit-microamp",
+				  &pval))
+		constraints->ilim_uA = pval;
+
 	/* Current change possible? */
 	if (constraints->min_uA != constraints->max_uA)
 		constraints->valid_ops_mask |= REGULATOR_CHANGE_CURRENT;

commit 57f66b78860968fc7eddc9ce25f8e57f7e5000bd
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Thu Jun 11 17:37:05 2015 -0700

    regulator: Add soft start support
    
    Some regulators support a "soft start" feature where the voltage
    ramps up slowly when the regulator is enabled. Add an op
    (set_soft_start) and a DT property + constraint to support this.
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/of_regulator.c b/drivers/regulator/of_regulator.c
index c3433db0acda..207da037cd2d 100644
--- a/drivers/regulator/of_regulator.c
+++ b/drivers/regulator/of_regulator.c
@@ -84,6 +84,9 @@ static void of_get_regulation_constraints(struct device_node *np,
 	if (!ret)
 		constraints->enable_time = pval;
 
+	constraints->soft_start = of_property_read_bool(np,
+					"regulator-soft-start");
+
 	if (!of_property_read_u32(np, "regulator-initial-mode", &pval)) {
 		if (desc && desc->of_map_mode) {
 			ret = desc->of_map_mode(pval);

commit 23c779b9f9161d6568d3b2fca06e70ad182c480c
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Thu Jun 11 17:37:04 2015 -0700

    regulator: Add pull down support
    
    Some regulators need to be configured to pull down a resistor
    when the regulator is disabled. Add an op (set_pull_down) and a
    DT property + constraint to support this.
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/of_regulator.c b/drivers/regulator/of_regulator.c
index 482a86f90839..c3433db0acda 100644
--- a/drivers/regulator/of_regulator.c
+++ b/drivers/regulator/of_regulator.c
@@ -67,6 +67,8 @@ static void of_get_regulation_constraints(struct device_node *np,
 	if (!constraints->always_on) /* status change should be possible. */
 		constraints->valid_ops_mask |= REGULATOR_CHANGE_STATUS;
 
+	constraints->pull_down = of_property_read_bool(np, "regulator-pull-down");
+
 	if (of_property_read_bool(np, "regulator-allow-bypass"))
 		constraints->valid_ops_mask |= REGULATOR_CHANGE_BYPASS;
 

commit 22a10bca280073f81e9e2d9fed6f90a3bcf00236
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Thu Jun 11 17:37:03 2015 -0700

    regulator: Add system_load constraint
    
    Some regulators have a fixed load that isn't captured by
    consumers that the kernel knows about. Add a constraint to
    support this.
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/of_regulator.c b/drivers/regulator/of_regulator.c
index 24e812c48d93..482a86f90839 100644
--- a/drivers/regulator/of_regulator.c
+++ b/drivers/regulator/of_regulator.c
@@ -95,6 +95,9 @@ static void of_get_regulation_constraints(struct device_node *np,
 		}
 	}
 
+	if (!of_property_read_u32(np, "regulator-system-load", &pval))
+		constraints->system_load = pval;
+
 	for (i = 0; i < ARRAY_SIZE(regulator_states); i++) {
 		switch (i) {
 		case PM_SUSPEND_MEM:

commit 130daa3f3570890d9082a06b8c36951a9ef630b6
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Tue May 12 14:42:07 2015 -0700

    regulator: of: Skip disabled regulator nodes
    
    If a regulator is listed in devicetree, but the node is marked as
    "disabled" we should skip parsing the regulator init data and
    deny consumers from interacting with the regulator. This
    simplifies devicetree maintenance where we can have one dtsi file
    with all regulators supported by a PMIC and then select what
    regulators are used depending on the board configuration.
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/of_regulator.c b/drivers/regulator/of_regulator.c
index 24e812c48d93..856c17d69b7e 100644
--- a/drivers/regulator/of_regulator.c
+++ b/drivers/regulator/of_regulator.c
@@ -292,7 +292,7 @@ struct regulator_init_data *regulator_of_get_init_data(struct device *dev,
 		return NULL;
 	}
 
-	for_each_child_of_node(search, child) {
+	for_each_available_child_of_node(search, child) {
 		name = of_get_property(child, "regulator-compatible", NULL);
 		if (!name)
 			name = child->name;

commit 7cf225b98a7b899323edeb3ef709da880fa88481
Author: Krzysztof Kozlowski <k.kozlowski.k@gmail.com>
Date:   Thu Apr 23 21:24:32 2015 +0900

    regulator: Remove unneeded semicolons
    
    Remove unneeded semicolons after the switch statement to satisfy
    coccicheck.
    
    Signed-off-by: Krzysztof Kozlowski <k.kozlowski.k@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/of_regulator.c b/drivers/regulator/of_regulator.c
index 24e812c48d93..e952439e0d83 100644
--- a/drivers/regulator/of_regulator.c
+++ b/drivers/regulator/of_regulator.c
@@ -108,7 +108,7 @@ static void of_get_regulation_constraints(struct device_node *np,
 		case PM_SUSPEND_STANDBY:
 		default:
 			continue;
-		};
+		}
 
 		suspend_np = of_get_child_by_name(np, regulator_states[i]);
 		if (!suspend_np || !suspend_state)

commit bfa21a0dfe6915dc85953b5d40ea9dae5fdf205f
Author: Krzysztof Kozlowski <k.kozlowski@samsung.com>
Date:   Mon Jan 5 12:48:42 2015 +0100

    regulator: Allow parsing custom properties when using simplified DT parsing
    
    When drivers use simplified DT parsing method (they provide
    'regulator_desc.of_match') they still may want to parse custom
    properties for some of the regulators. For example some of the
    regulators support GPIO enable control.
    
    Add a driver-supplied callback for such case. This way the regulator
    core parses common bindings offloading a lot of code from drivers and
    still custom properties may be used.
    
    The callback, called for each parsed regulator, may modify the
    'regulator_config' initially passed to regulator_register().
    
    Signed-off-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/of_regulator.c b/drivers/regulator/of_regulator.c
index 91eaaf010524..24e812c48d93 100644
--- a/drivers/regulator/of_regulator.c
+++ b/drivers/regulator/of_regulator.c
@@ -270,6 +270,7 @@ EXPORT_SYMBOL_GPL(of_regulator_match);
 
 struct regulator_init_data *regulator_of_get_init_data(struct device *dev,
 					    const struct regulator_desc *desc,
+					    struct regulator_config *config,
 					    struct device_node **node)
 {
 	struct device_node *search, *child;
@@ -307,6 +308,16 @@ struct regulator_init_data *regulator_of_get_init_data(struct device *dev,
 			break;
 		}
 
+		if (desc->of_parse_cb) {
+			if (desc->of_parse_cb(child, desc, config)) {
+				dev_err(dev,
+					"driver callback failed to parse DT for regulator %s\n",
+					child->name);
+				init_data = NULL;
+				break;
+			}
+		}
+
 		of_node_get(child);
 		*node = child;
 		break;

commit cf2394f70cf7774a107fbaa1ef5010db4bd69baa
Merge: 45fc84c668ba 206c5f60a3d9
Author: Mark Brown <broonie@kernel.org>
Date:   Wed Nov 26 20:37:57 2014 +0000

    Merge tag 'v3.18-rc4' into regulator-max77802
    
    Linux 3.18-rc4

commit 5e5e3a42c653c5ef1c281651f1882411601129bd
Author: Javier Martinez Canillas <javier.martinez@collabora.co.uk>
Date:   Mon Nov 10 14:43:55 2014 +0100

    regulator: of: Add support for parsing initial and suspend modes
    
    Some regulators support their operating mode to be changed on startup
    or by consumers when the system is running while others only support
    their operating mode to be changed while the system has entered in a
    suspend state.
    
    The regulator Device Tree binding documents a set of properties to
    configure the regulators operating modes from a FDT. This patch builds
    on (40e20d6 regulator: of: Add support for parsing regulator_state for
    suspend state) and adds support to parse those properties and fill the
    regulator constraints so the regulator core can call the right suspend
    handlers when the system enters into sleep.
    
    The modes are defined in the Device Tree using the hardware specific
    modes supported by the regulators. Regulator drivers have to define a
    translation function that is used to map the hardware specific modes
    to the standard ones.
    
    Signed-off-by: Javier Martinez Canillas <javier.martinez@collabora.co.uk>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/of_regulator.c b/drivers/regulator/of_regulator.c
index 64c09a37ac7f..163946075656 100644
--- a/drivers/regulator/of_regulator.c
+++ b/drivers/regulator/of_regulator.c
@@ -25,7 +25,8 @@ static const char *const regulator_states[PM_SUSPEND_MAX + 1] = {
 };
 
 static void of_get_regulation_constraints(struct device_node *np,
-					struct regulator_init_data **init_data)
+					struct regulator_init_data **init_data,
+					const struct regulator_desc *desc)
 {
 	const __be32 *min_uV, *max_uV;
 	struct regulation_constraints *constraints = &(*init_data)->constraints;
@@ -81,6 +82,19 @@ static void of_get_regulation_constraints(struct device_node *np,
 	if (!ret)
 		constraints->enable_time = pval;
 
+	if (!of_property_read_u32(np, "regulator-initial-mode", &pval)) {
+		if (desc && desc->of_map_mode) {
+			ret = desc->of_map_mode(pval);
+			if (ret == -EINVAL)
+				pr_err("%s: invalid mode %u\n", np->name, pval);
+			else
+				constraints->initial_mode = ret;
+		} else {
+			pr_warn("%s: mapping for mode %d not defined\n",
+				np->name, pval);
+		}
+	}
+
 	for (i = 0; i < ARRAY_SIZE(regulator_states); i++) {
 		switch (i) {
 		case PM_SUSPEND_MEM:
@@ -100,6 +114,21 @@ static void of_get_regulation_constraints(struct device_node *np,
 		if (!suspend_np || !suspend_state)
 			continue;
 
+		if (!of_property_read_u32(suspend_np, "regulator-mode",
+					  &pval)) {
+			if (desc && desc->of_map_mode) {
+				ret = desc->of_map_mode(pval);
+				if (ret == -EINVAL)
+					pr_err("%s: invalid mode %u\n",
+					       np->name, pval);
+				else
+					suspend_state->mode = ret;
+			} else {
+				pr_warn("%s: mapping for mode %d not defined\n",
+					np->name, pval);
+			}
+		}
+
 		if (of_property_read_bool(suspend_np,
 					"regulator-on-in-suspend"))
 			suspend_state->enabled = true;
@@ -140,7 +169,7 @@ struct regulator_init_data *of_get_regulator_init_data(struct device *dev,
 	if (!init_data)
 		return NULL; /* Out of memory? */
 
-	of_get_regulation_constraints(node, &init_data);
+	of_get_regulation_constraints(node, &init_data, desc);
 	return init_data;
 }
 EXPORT_SYMBOL_GPL(of_get_regulator_init_data);

commit 75d6b2faf79cbe9086e831351d5d9085f1852928
Author: Javier Martinez Canillas <javier.martinez@collabora.co.uk>
Date:   Mon Nov 10 14:43:54 2014 +0100

    regulator: of: Pass the regulator description in the match table
    
    Drivers can use the of_regulator_match() function to parse the regulator
    init_data from DT. A match table is used to specify the name of the node
    containing the regulators, the device node and to return the init_data
    to the caller.
    
    But also the static regulator descriptor is needed to correctly extract
    some DT properties like the regulator initial and suspend modes. Use the
    match table to pass that information.
    
    Signed-off-by: Javier Martinez Canillas <javier.martinez@collabora.co.uk>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/of_regulator.c b/drivers/regulator/of_regulator.c
index 3687a1c38c1c..64c09a37ac7f 100644
--- a/drivers/regulator/of_regulator.c
+++ b/drivers/regulator/of_regulator.c
@@ -221,7 +221,8 @@ int of_regulator_match(struct device *dev, struct device_node *node,
 				continue;
 
 			match->init_data =
-				of_get_regulator_init_data(dev, child, NULL);
+				of_get_regulator_init_data(dev, child,
+							   match->desc);
 			if (!match->init_data) {
 				dev_err(dev,
 					"failed to parse DT for regulator %s\n",

commit 072e78b12bf5182a3e2e460388214a291023ef1c
Author: Javier Martinez Canillas <javier.martinez@collabora.co.uk>
Date:   Mon Nov 10 14:43:53 2014 +0100

    regulator: of: Add regulator desc param to of_get_regulator_init_data()
    
    The of_get_regulator_init_data() function is used to extract the regulator
    init_data but information on how to extract certain data is defined in the
    static regulator descriptor (e.g: how to map the hardware operating modes).
    
    Add a const struct regulator_desc * parameter to the function signature so
    the parsing logic could use the information in the struct regulator_desc.
    
    of_get_regulator_init_data() relies on of_get_regulation_constraints() to
    actually extract the init_data so it has to pass the struct regulator_desc
    but that is modified on a later patch.
    
    Signed-off-by: Javier Martinez Canillas <javier.martinez@collabora.co.uk>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/of_regulator.c b/drivers/regulator/of_regulator.c
index 50be70878d2d..3687a1c38c1c 100644
--- a/drivers/regulator/of_regulator.c
+++ b/drivers/regulator/of_regulator.c
@@ -120,13 +120,16 @@ static void of_get_regulation_constraints(struct device_node *np,
 /**
  * of_get_regulator_init_data - extract regulator_init_data structure info
  * @dev: device requesting for regulator_init_data
+ * @node: regulator device node
+ * @desc: regulator description
  *
  * Populates regulator_init_data structure by extracting data from device
  * tree node, returns a pointer to the populated struture or NULL if memory
  * alloc fails.
  */
 struct regulator_init_data *of_get_regulator_init_data(struct device *dev,
-						struct device_node *node)
+					  struct device_node *node,
+					  const struct regulator_desc *desc)
 {
 	struct regulator_init_data *init_data;
 
@@ -218,7 +221,7 @@ int of_regulator_match(struct device *dev, struct device_node *node,
 				continue;
 
 			match->init_data =
-				of_get_regulator_init_data(dev, child);
+				of_get_regulator_init_data(dev, child, NULL);
 			if (!match->init_data) {
 				dev_err(dev,
 					"failed to parse DT for regulator %s\n",
@@ -265,7 +268,7 @@ struct regulator_init_data *regulator_of_get_init_data(struct device *dev,
 		if (strcmp(desc->of_match, name))
 			continue;
 
-		init_data = of_get_regulator_init_data(dev, child);
+		init_data = of_get_regulator_init_data(dev, child, desc);
 		if (!init_data) {
 			dev_err(dev,
 				"failed to parse DT for regulator %s\n",

commit 8cbcaea89cfc4603c954f50aaddc3172446961d1
Author: Doug Anderson <dianders@chromium.org>
Date:   Fri Oct 31 20:52:58 2014 -0700

    regulator: of: Add support for parsing microvolts for suspend state
    
    Leverage all the work that was done in (40e20d6 regulator: of: Add
    support for parsing regulator_state for suspend state) and throw in
    the ability to set suspend microvolts from the device tree.
    
    Signed-off-by: Doug Anderson <dianders@chromium.org>
    Reviewed-by: Javier Martinez Canillas <javier.martinez@collabora.co.uk>
    Reviewed-by: Chris Zhong <zyw@rock-chips.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/of_regulator.c b/drivers/regulator/of_regulator.c
index 36a1f5cc14e9..50be70878d2d 100644
--- a/drivers/regulator/of_regulator.c
+++ b/drivers/regulator/of_regulator.c
@@ -107,6 +107,10 @@ static void of_get_regulation_constraints(struct device_node *np,
 					"regulator-off-in-suspend"))
 			suspend_state->disabled = true;
 
+		if (!of_property_read_u32(suspend_np,
+					"regulator-suspend-microvolt", &pval))
+			suspend_state->uV = pval;
+
 		of_node_put(suspend_np);
 		suspend_state = NULL;
 		suspend_np = NULL;

commit f32fa89ca9b2e1048d925af48bb0b1b3275d39d6
Author: Krzysztof Kozlowski <k.kozlowski@samsung.com>
Date:   Fri Oct 31 17:04:14 2014 +0100

    regulator: Staticize 'regulator_states' array
    
    The 'regulator_states' array is used only in this unit and it is not
    exported. Make it static.
    
    This also fixes following sparse warning:
    drivers/regulator/of_regulator.c:22:12: warning: symbol 'regulator_states' was not declared. Should it be static?
    
    Signed-off-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/of_regulator.c b/drivers/regulator/of_regulator.c
index f0d19fc9d5d5..36a1f5cc14e9 100644
--- a/drivers/regulator/of_regulator.c
+++ b/drivers/regulator/of_regulator.c
@@ -19,7 +19,7 @@
 
 #include "internal.h"
 
-const char *const regulator_states[PM_SUSPEND_MAX + 1] = {
+static const char *const regulator_states[PM_SUSPEND_MAX + 1] = {
 	[PM_SUSPEND_MEM]	= "regulator-state-mem",
 	[PM_SUSPEND_MAX]	= "regulator-state-disk",
 };

commit 7de79a1d4992921c85b10077520385acc5b9a6e0
Author: Mark Brown <broonie@kernel.org>
Date:   Wed Oct 8 23:08:13 2014 +0100

    regulator: of: Lower the severity of the error with no container
    
    Description of regulators should generally be optional so if there is no
    DT node for the regulators container then we shouldn't print an error
    message. Lower the severity of the message to debug level (it might help
    someone work out what went wrong) and while we're at it say what we were
    looking for.
    
    Reported-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/of_regulator.c b/drivers/regulator/of_regulator.c
index 7a51814abdc5..5a1d4afa4776 100644
--- a/drivers/regulator/of_regulator.c
+++ b/drivers/regulator/of_regulator.c
@@ -211,7 +211,8 @@ struct regulator_init_data *regulator_of_get_init_data(struct device *dev,
 		search = dev->of_node;
 
 	if (!search) {
-		dev_err(dev, "Failed to find regulator container node\n");
+		dev_dbg(dev, "Failed to find regulator container node '%s'\n",
+			desc->regulators_node);
 		return NULL;
 	}
 

commit 4eafec83aa9ea8eb21bd5c1c980debc623eea164
Author: Javier Martinez Canillas <javier.martinez@collabora.co.uk>
Date:   Mon Oct 20 16:47:48 2014 +0200

    regulator: of: Decrement refcount for suspend state nodes
    
    of_get_regulation_constraints() calls of_get_child_by_name() to find the
    regulator-state-{mem,disk} child nodes for each regulator. This function
    increments the device node reference counter but this is not decremented
    once the function is done using the node.
    
    Fix that by calling of_node_put() after finishing using the device node.
    
    Signed-off-by: Javier Martinez Canillas <javier.martinez@collabora.co.uk>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/of_regulator.c b/drivers/regulator/of_regulator.c
index b375ffe40df1..f0d19fc9d5d5 100644
--- a/drivers/regulator/of_regulator.c
+++ b/drivers/regulator/of_regulator.c
@@ -107,6 +107,7 @@ static void of_get_regulation_constraints(struct device_node *np,
 					"regulator-off-in-suspend"))
 			suspend_state->disabled = true;
 
+		of_node_put(suspend_np);
 		suspend_state = NULL;
 		suspend_np = NULL;
 	}

commit 40e20d68bb3fb1ce2704c886d597918988d3321d
Author: Chanwoo Choi <cw00.choi@samsung.com>
Date:   Fri Oct 10 20:35:33 2014 +0900

    regulator: of: Add support for parsing regulator_state for suspend state
    
    The regulation_constraints structure includes specific field to support
    suspend state for global PMIC SUSPEND/HIBERNATE mode. This patch add support
    for parsing regulator_state for suspend state.
    
    Signed-off-by: Chanwoo Choi <cw00.choi@samsung.com>
    Acked-by: Kyungmin Park <kyungmin.park@samsung.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/of_regulator.c b/drivers/regulator/of_regulator.c
index 7a51814abdc5..b375ffe40df1 100644
--- a/drivers/regulator/of_regulator.c
+++ b/drivers/regulator/of_regulator.c
@@ -19,12 +19,19 @@
 
 #include "internal.h"
 
+const char *const regulator_states[PM_SUSPEND_MAX + 1] = {
+	[PM_SUSPEND_MEM]	= "regulator-state-mem",
+	[PM_SUSPEND_MAX]	= "regulator-state-disk",
+};
+
 static void of_get_regulation_constraints(struct device_node *np,
 					struct regulator_init_data **init_data)
 {
 	const __be32 *min_uV, *max_uV;
 	struct regulation_constraints *constraints = &(*init_data)->constraints;
-	int ret;
+	struct regulator_state *suspend_state;
+	struct device_node *suspend_np;
+	int ret, i;
 	u32 pval;
 
 	constraints->name = of_get_property(np, "regulator-name", NULL);
@@ -73,6 +80,36 @@ static void of_get_regulation_constraints(struct device_node *np,
 	ret = of_property_read_u32(np, "regulator-enable-ramp-delay", &pval);
 	if (!ret)
 		constraints->enable_time = pval;
+
+	for (i = 0; i < ARRAY_SIZE(regulator_states); i++) {
+		switch (i) {
+		case PM_SUSPEND_MEM:
+			suspend_state = &constraints->state_mem;
+			break;
+		case PM_SUSPEND_MAX:
+			suspend_state = &constraints->state_disk;
+			break;
+		case PM_SUSPEND_ON:
+		case PM_SUSPEND_FREEZE:
+		case PM_SUSPEND_STANDBY:
+		default:
+			continue;
+		};
+
+		suspend_np = of_get_child_by_name(np, regulator_states[i]);
+		if (!suspend_np || !suspend_state)
+			continue;
+
+		if (of_property_read_bool(suspend_np,
+					"regulator-on-in-suspend"))
+			suspend_state->enabled = true;
+		else if (of_property_read_bool(suspend_np,
+					"regulator-off-in-suspend"))
+			suspend_state->disabled = true;
+
+		suspend_state = NULL;
+		suspend_np = NULL;
+	}
 }
 
 /**

commit a0c7b164ad115ec0556dc0904ee2218cbc5cedfa
Author: Mark Brown <broonie@kernel.org>
Date:   Tue Sep 9 23:13:57 2014 +0100

    regulator: of: Provide simplified DT parsing method
    
    Currently regulator drivers which support DT all repeat very similar code
    to supply a list of known regulator identifiers to be matched with DT,
    convert that to platform data which is then matched up with the regulators
    as they are registered. This is both fiddly to get right and for devices
    which can use the standard helpers to provide their operations is the main
    source of code in the driver.
    
    Since this code is essentially identical for most drivers we can factor it
    out into the core, moving the identifiers in the match table into the
    regulator descriptors and also allowing drivers to pass in the name of the
    subnode to search. When a driver provides an of_match string for the
    regulator the core will attempt to use that to obtain init_data, allowing
    the driver to remove all explicit code for DT parsing and simply provide
    data instead.
    
    The current code leaks the phandles for the child nodes, this will be
    addressed incrementally and makes no practical difference for FDT anyway
    as the DT data structures are never freed.
    
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/regulator/of_regulator.c b/drivers/regulator/of_regulator.c
index ee5e67bc8d5b..7a51814abdc5 100644
--- a/drivers/regulator/of_regulator.c
+++ b/drivers/regulator/of_regulator.c
@@ -14,8 +14,11 @@
 #include <linux/slab.h>
 #include <linux/of.h>
 #include <linux/regulator/machine.h>
+#include <linux/regulator/driver.h>
 #include <linux/regulator/of_regulator.h>
 
+#include "internal.h"
+
 static void of_get_regulation_constraints(struct device_node *np,
 					struct regulator_init_data **init_data)
 {
@@ -189,3 +192,51 @@ int of_regulator_match(struct device *dev, struct device_node *node,
 	return count;
 }
 EXPORT_SYMBOL_GPL(of_regulator_match);
+
+struct regulator_init_data *regulator_of_get_init_data(struct device *dev,
+					    const struct regulator_desc *desc,
+					    struct device_node **node)
+{
+	struct device_node *search, *child;
+	struct regulator_init_data *init_data = NULL;
+	const char *name;
+
+	if (!dev->of_node || !desc->of_match)
+		return NULL;
+
+	if (desc->regulators_node)
+		search = of_get_child_by_name(dev->of_node,
+					      desc->regulators_node);
+	else
+		search = dev->of_node;
+
+	if (!search) {
+		dev_err(dev, "Failed to find regulator container node\n");
+		return NULL;
+	}
+
+	for_each_child_of_node(search, child) {
+		name = of_get_property(child, "regulator-compatible", NULL);
+		if (!name)
+			name = child->name;
+
+		if (strcmp(desc->of_match, name))
+			continue;
+
+		init_data = of_get_regulator_init_data(dev, child);
+		if (!init_data) {
+			dev_err(dev,
+				"failed to parse DT for regulator %s\n",
+				child->name);
+			break;
+		}
+
+		of_node_get(child);
+		*node = child;
+		break;
+	}
+
+	of_node_put(search);
+
+	return init_data;
+}

commit 1e050eabb622ca60640e4714b01cb3caa29505f0
Author: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
Date:   Tue May 27 00:27:19 2014 +0400

    regulator: use of_property_read_{bool|u32}()
    
    Use more compact of_property_read_{bool|u32}() calls instead of the
    of_{find|get}_property() calls in of_get_regulation_constraints() where
    possible (note that of_property_read_{bool|u32}() were already used to read
    some properties).
    
    Signed-off-by: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/regulator/of_regulator.c b/drivers/regulator/of_regulator.c
index 4672cd2f4632..ee5e67bc8d5b 100644
--- a/drivers/regulator/of_regulator.c
+++ b/drivers/regulator/of_regulator.c
@@ -19,9 +19,7 @@
 static void of_get_regulation_constraints(struct device_node *np,
 					struct regulator_init_data **init_data)
 {
-	const __be32 *min_uV, *max_uV, *uV_offset;
-	const __be32 *min_uA, *max_uA, *ramp_delay;
-	struct property *prop;
+	const __be32 *min_uV, *max_uV;
 	struct regulation_constraints *constraints = &(*init_data)->constraints;
 	int ret;
 	u32 pval;
@@ -42,36 +40,29 @@ static void of_get_regulation_constraints(struct device_node *np,
 	if (min_uV && max_uV && constraints->min_uV == constraints->max_uV)
 		constraints->apply_uV = true;
 
-	uV_offset = of_get_property(np, "regulator-microvolt-offset", NULL);
-	if (uV_offset)
-		constraints->uV_offset = be32_to_cpu(*uV_offset);
-	min_uA = of_get_property(np, "regulator-min-microamp", NULL);
-	if (min_uA)
-		constraints->min_uA = be32_to_cpu(*min_uA);
-	max_uA = of_get_property(np, "regulator-max-microamp", NULL);
-	if (max_uA)
-		constraints->max_uA = be32_to_cpu(*max_uA);
+	if (!of_property_read_u32(np, "regulator-microvolt-offset", &pval))
+		constraints->uV_offset = pval;
+	if (!of_property_read_u32(np, "regulator-min-microamp", &pval))
+		constraints->min_uA = pval;
+	if (!of_property_read_u32(np, "regulator-max-microamp", &pval))
+		constraints->max_uA = pval;
 
 	/* Current change possible? */
 	if (constraints->min_uA != constraints->max_uA)
 		constraints->valid_ops_mask |= REGULATOR_CHANGE_CURRENT;
 
-	if (of_find_property(np, "regulator-boot-on", NULL))
-		constraints->boot_on = true;
-
-	if (of_find_property(np, "regulator-always-on", NULL))
-		constraints->always_on = true;
-	else /* status change should be possible if not always on. */
+	constraints->boot_on = of_property_read_bool(np, "regulator-boot-on");
+	constraints->always_on = of_property_read_bool(np, "regulator-always-on");
+	if (!constraints->always_on) /* status change should be possible. */
 		constraints->valid_ops_mask |= REGULATOR_CHANGE_STATUS;
 
 	if (of_property_read_bool(np, "regulator-allow-bypass"))
 		constraints->valid_ops_mask |= REGULATOR_CHANGE_BYPASS;
 
-	prop = of_find_property(np, "regulator-ramp-delay", NULL);
-	if (prop && prop->value) {
-		ramp_delay = prop->value;
-		if (*ramp_delay)
-			constraints->ramp_delay = be32_to_cpu(*ramp_delay);
+	ret = of_property_read_u32(np, "regulator-ramp-delay", &pval);
+	if (!ret) {
+		if (pval)
+			constraints->ramp_delay = pval;
 		else
 			constraints->ramp_disable = true;
 	}

commit 13b3fde808ed287ad23c4549733fb3e3be785114
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Tue Apr 15 13:34:36 2014 +0100

    regulator: core: Use devres for releasing of_regulator_match of_nodes
    
    Rather than requiring individual drivers to put the of_nodes returned
    from of_regulator_match use devres to put them. This also has the
    benefit it makes the life-time of the of_nodes match the lifetime of
    the init data also contained in the of_regulator_match structure, which
    seems more consistent.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/regulator/of_regulator.c b/drivers/regulator/of_regulator.c
index 188e0cb10d03..4672cd2f4632 100644
--- a/drivers/regulator/of_regulator.c
+++ b/drivers/regulator/of_regulator.c
@@ -106,6 +106,20 @@ struct regulator_init_data *of_get_regulator_init_data(struct device *dev,
 }
 EXPORT_SYMBOL_GPL(of_get_regulator_init_data);
 
+struct devm_of_regulator_matches {
+	struct of_regulator_match *matches;
+	unsigned int num_matches;
+};
+
+static void devm_of_regulator_put_matches(struct device *dev, void *res)
+{
+	struct devm_of_regulator_matches *devm_matches = res;
+	int i;
+
+	for (i = 0; i < devm_matches->num_matches; i++)
+		of_node_put(devm_matches->matches[i].of_node);
+}
+
 /**
  * of_regulator_match - extract multiple regulator init data from device tree.
  * @dev: device requesting the data
@@ -132,10 +146,22 @@ int of_regulator_match(struct device *dev, struct device_node *node,
 	unsigned int i;
 	const char *name;
 	struct device_node *child;
+	struct devm_of_regulator_matches *devm_matches;
 
 	if (!dev || !node)
 		return -EINVAL;
 
+	devm_matches = devres_alloc(devm_of_regulator_put_matches,
+				    sizeof(struct devm_of_regulator_matches),
+				    GFP_KERNEL);
+	if (!devm_matches)
+		return -ENOMEM;
+
+	devm_matches->matches = matches;
+	devm_matches->num_matches = num_matches;
+
+	devres_add(dev, devm_matches);
+
 	for (i = 0; i < num_matches; i++) {
 		struct of_regulator_match *match = &matches[i];
 		match->init_data = NULL;
@@ -172,24 +198,3 @@ int of_regulator_match(struct device *dev, struct device_node *node,
 	return count;
 }
 EXPORT_SYMBOL_GPL(of_regulator_match);
-
-/**
- * of_regulator_put_match - put the of_node references from an
- *                          of_regulator_match structure
- * @matches: match table for the regulators
- * @num_matches: number of entries in match table
- *
- * This function goes through a match table and calls of_node_put on each
- * of_node.
- */
-int of_regulator_put_match(struct of_regulator_match *matches,
-			   unsigned int num_matches)
-{
-	int i;
-
-	for (i = 0; i < num_matches; i++)
-		of_node_put(matches[i].of_node);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(of_regulator_put_match);

commit 3764806440149ea9024dff039497d1e45d6ed027
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Thu Apr 3 15:32:16 2014 +0100

    regulator: core: Add helper to put of_nodes from matches
    
    As of_regulator_match will take an of_node reference to each matched
    regulator, it makes sense to provide a helper to put all those
    references. This patch does that.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/regulator/of_regulator.c b/drivers/regulator/of_regulator.c
index c58c8d178948..188e0cb10d03 100644
--- a/drivers/regulator/of_regulator.c
+++ b/drivers/regulator/of_regulator.c
@@ -172,3 +172,24 @@ int of_regulator_match(struct device *dev, struct device_node *node,
 	return count;
 }
 EXPORT_SYMBOL_GPL(of_regulator_match);
+
+/**
+ * of_regulator_put_match - put the of_node references from an
+ *                          of_regulator_match structure
+ * @matches: match table for the regulators
+ * @num_matches: number of entries in match table
+ *
+ * This function goes through a match table and calls of_node_put on each
+ * of_node.
+ */
+int of_regulator_put_match(struct of_regulator_match *matches,
+			   unsigned int num_matches)
+{
+	int i;
+
+	for (i = 0; i < num_matches; i++)
+		of_node_put(matches[i].of_node);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(of_regulator_put_match);

commit bd0dda744cdfb93a1907091c4540764593a28fa2
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Thu Apr 3 15:32:15 2014 +0100

    regulator: core: Add of_node_get to of_regulator_match
    
    Currently, of_regulator_match does not increment the reference count of
    the of_nodes it takes new references to. This could cause the node
    pointer held to be invalid, by the time it is passed to the regulator
    core. This patchs adds an of_node_get when we copy each of_node pointer
    into the match structure.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/regulator/of_regulator.c b/drivers/regulator/of_regulator.c
index ea4f36f2cbe2..c58c8d178948 100644
--- a/drivers/regulator/of_regulator.c
+++ b/drivers/regulator/of_regulator.c
@@ -119,7 +119,8 @@ EXPORT_SYMBOL_GPL(of_get_regulator_init_data);
  * regulator. The data parsed from a child node will be matched to a regulator
  * based on either the deprecated property regulator-compatible if present,
  * or otherwise the child node's name. Note that the match table is modified
- * in place.
+ * in place and an additional of_node reference is taken for each matched
+ * regulator.
  *
  * Returns the number of matches found or a negative error code on failure.
  */
@@ -162,7 +163,7 @@ int of_regulator_match(struct device *dev, struct device_node *node,
 					child->name);
 				return -EINVAL;
 			}
-			match->of_node = child;
+			match->of_node = of_node_get(child);
 			count++;
 			break;
 		}

commit 00c877c69ba315d6c565a4df51c71b11e82cdeb8
Author: Laxman Dewangan <ldewangan@nvidia.com>
Date:   Wed Sep 18 18:18:02 2013 +0530

    regulator: core: add support for configuring turn-on time through constraints
    
    The turn-on time of the regulator depends on the regulator device's
    electrical characteristics. Sometimes regulator turn-on time also
    depends on the capacitive load on the given platform and it can be
    more than the datasheet value.
    
    The driver provides the enable-time as per datasheet.
    
    Add support for configure the enable ramp time through regulator
    constraints so that regulator core can take this value for enable
    time for that regulator.
    
    Signed-off-by: Laxman Dewangan <ldewangan@nvidia.com>
    Acked-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/regulator/of_regulator.c b/drivers/regulator/of_regulator.c
index 7827384680d6..ea4f36f2cbe2 100644
--- a/drivers/regulator/of_regulator.c
+++ b/drivers/regulator/of_regulator.c
@@ -23,6 +23,8 @@ static void of_get_regulation_constraints(struct device_node *np,
 	const __be32 *min_uA, *max_uA, *ramp_delay;
 	struct property *prop;
 	struct regulation_constraints *constraints = &(*init_data)->constraints;
+	int ret;
+	u32 pval;
 
 	constraints->name = of_get_property(np, "regulator-name", NULL);
 
@@ -73,6 +75,10 @@ static void of_get_regulation_constraints(struct device_node *np,
 		else
 			constraints->ramp_disable = true;
 	}
+
+	ret = of_property_read_u32(np, "regulator-enable-ramp-delay", &pval);
+	if (!ret)
+		constraints->enable_time = pval;
 }
 
 /**

commit 1653ccf4c52df6a4abe8ec2f33f2cb2896d129ea
Author: Yadwinder Singh Brar <yadi.brar@samsung.com>
Date:   Sat Jun 29 18:21:15 2013 +0530

    regulator: core: Add support for disabling ramp delay
    
    Some hardwares support disabling ramp delay, so adding ramp_disable flag to
    constraints. It will be used to figure out whether ramp_delay in constraints
    is explicitly set to zero or its unintialized (zero by default).
    And we don't need to call set_voltage_time_sel() for regulators for whom ramp
    delay is disabled in constraints.
    
    Signed-off-by: Yadwinder Singh Brar <yadi.brar@samsung.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/regulator/of_regulator.c b/drivers/regulator/of_regulator.c
index f3c8f8f9dc39..7827384680d6 100644
--- a/drivers/regulator/of_regulator.c
+++ b/drivers/regulator/of_regulator.c
@@ -21,6 +21,7 @@ static void of_get_regulation_constraints(struct device_node *np,
 {
 	const __be32 *min_uV, *max_uV, *uV_offset;
 	const __be32 *min_uA, *max_uA, *ramp_delay;
+	struct property *prop;
 	struct regulation_constraints *constraints = &(*init_data)->constraints;
 
 	constraints->name = of_get_property(np, "regulator-name", NULL);
@@ -64,9 +65,14 @@ static void of_get_regulation_constraints(struct device_node *np,
 	if (of_property_read_bool(np, "regulator-allow-bypass"))
 		constraints->valid_ops_mask |= REGULATOR_CHANGE_BYPASS;
 
-	ramp_delay = of_get_property(np, "regulator-ramp-delay", NULL);
-	if (ramp_delay)
-		constraints->ramp_delay = be32_to_cpu(*ramp_delay);
+	prop = of_find_property(np, "regulator-ramp-delay", NULL);
+	if (prop && prop->value) {
+		ramp_delay = prop->value;
+		if (*ramp_delay)
+			constraints->ramp_delay = be32_to_cpu(*ramp_delay);
+		else
+			constraints->ramp_disable = true;
+	}
 }
 
 /**

commit 93134c7b40580ae8bb061d278a3ecffd7bbfccd6
Author: Kishon Vijay Abraham I <kishon@ti.com>
Date:   Thu Jun 20 14:07:37 2013 +0530

    regulator: of: Added a property to indicate bypass mode support
    
    Added a property to indicate if the regulator supports bypass mode.
    Also modified of_get_regulation_constraints() to check for that
    property and set appropriate constraints.
    
    Signed-off-by: Kishon Vijay Abraham I <kishon@ti.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/regulator/of_regulator.c b/drivers/regulator/of_regulator.c
index 66ca769287ab..f3c8f8f9dc39 100644
--- a/drivers/regulator/of_regulator.c
+++ b/drivers/regulator/of_regulator.c
@@ -61,6 +61,9 @@ static void of_get_regulation_constraints(struct device_node *np,
 	else /* status change should be possible if not always on. */
 		constraints->valid_ops_mask |= REGULATOR_CHANGE_STATUS;
 
+	if (of_property_read_bool(np, "regulator-allow-bypass"))
+		constraints->valid_ops_mask |= REGULATOR_CHANGE_BYPASS;
+
 	ramp_delay = of_get_property(np, "regulator-ramp-delay", NULL);
 	if (ramp_delay)
 		constraints->ramp_delay = be32_to_cpu(*ramp_delay);

commit a2f95c363701deba2205f81929b40222ea6f4f80
Author: Stephen Warren <swarren@nvidia.com>
Date:   Tue Jan 29 12:01:13 2013 -0700

    regulator: clear state each invocation of of_regulator_match
    
    of_regulator_match() saves some dynamcially allocated state into the
    match table that's passed to it. By implementation and not contract, for
    each match table entry, if non-NULL state is already present,
    of_regulator_match() will not overwrite it. of_regulator_match() is
    typically called each time a regulator is probe()d. This means it is
    called with the same match table over and over again if a regulator
    triggers deferred probe. This results in stale, kfree()d data being left
    in the match table from probe to probe, which causes a variety of crashes
    or use of invalid data.
    
    Explicitly free all output state from of_regulator_match() before
    generating new results in order to avoid this.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/regulator/of_regulator.c b/drivers/regulator/of_regulator.c
index 6f684916fd79..66ca769287ab 100644
--- a/drivers/regulator/of_regulator.c
+++ b/drivers/regulator/of_regulator.c
@@ -120,6 +120,12 @@ int of_regulator_match(struct device *dev, struct device_node *node,
 	if (!dev || !node)
 		return -EINVAL;
 
+	for (i = 0; i < num_matches; i++) {
+		struct of_regulator_match *match = &matches[i];
+		match->init_data = NULL;
+		match->of_node = NULL;
+	}
+
 	for_each_child_of_node(node, child) {
 		name = of_get_property(child,
 					"regulator-compatible", NULL);

commit 13511def87b9f68697a0fc4c64ddacece585a471
Author: Stephen Warren <swarren@nvidia.com>
Date:   Mon Sep 24 13:25:00 2012 -0600

    regulator: deprecate regulator-compatible DT property
    
    When the bindings for the TPS6586x regulator were being proposed, I
    asserted that DT node naming rules for bus child nodes should also be
    applied to nodes inside the TPS6586x regulator node itself. In other
    words, that each node providing regulator init data should be named
    after the type of object it represented ("regulator") and hence that
    some other property was required to indicate which regulator the node
    described ("regulator-compatible"). In turn this led to multiple nodes
    having the same name, thus requiring node names to use a unit address
    to make them unique, thus requiring reg properties within the nodes and
    
    However, subsequent discussion indicates that the rules I was asserting
    only applies to standardized bus nodes, and within a device's own node,
    the binding can basically do anything sane that it wants.
    
    Hence, this change deprecates the register-compatible property, and
    instead uses node names to replace this functionality. This greatly
    simplifies the device tree content, making them smaller and more legible.
    
    The code is changed such that old device trees continue to work.
    
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/of_regulator.c b/drivers/regulator/of_regulator.c
index 3e4106f2bda9..6f684916fd79 100644
--- a/drivers/regulator/of_regulator.c
+++ b/drivers/regulator/of_regulator.c
@@ -92,16 +92,18 @@ struct regulator_init_data *of_get_regulator_init_data(struct device *dev,
 EXPORT_SYMBOL_GPL(of_get_regulator_init_data);
 
 /**
- * of_regulator_match - extract regulator init data when node
- * property "regulator-compatible" matches with the regulator name.
+ * of_regulator_match - extract multiple regulator init data from device tree.
  * @dev: device requesting the data
  * @node: parent device node of the regulators
  * @matches: match table for the regulators
  * @num_matches: number of entries in match table
  *
- * This function uses a match table specified by the regulator driver and
- * looks up the corresponding init data in the device tree  if
- * regulator-compatible matches. Note that the match table is modified
+ * This function uses a match table specified by the regulator driver to
+ * parse regulator init data from the device tree. @node is expected to
+ * contain a set of child nodes, each providing the init data for one
+ * regulator. The data parsed from a child node will be matched to a regulator
+ * based on either the deprecated property regulator-compatible if present,
+ * or otherwise the child node's name. Note that the match table is modified
  * in place.
  *
  * Returns the number of matches found or a negative error code on failure.
@@ -112,26 +114,23 @@ int of_regulator_match(struct device *dev, struct device_node *node,
 {
 	unsigned int count = 0;
 	unsigned int i;
-	const char *regulator_comp;
+	const char *name;
 	struct device_node *child;
 
 	if (!dev || !node)
 		return -EINVAL;
 
 	for_each_child_of_node(node, child) {
-		regulator_comp = of_get_property(child,
+		name = of_get_property(child,
 					"regulator-compatible", NULL);
-		if (!regulator_comp) {
-			dev_err(dev, "regulator-compatible is missing for node %s\n",
-				child->name);
-			continue;
-		}
+		if (!name)
+			name = child->name;
 		for (i = 0; i < num_matches; i++) {
 			struct of_regulator_match *match = &matches[i];
 			if (match->of_node)
 				continue;
 
-			if (strcmp(match->name, regulator_comp))
+			if (strcmp(match->name, name))
 				continue;
 
 			match->init_data =

commit 5260cd2bc97318b8477b1d1e99c5a2c53764135b
Author: Laxman Dewangan <ldewangan@nvidia.com>
Date:   Wed Jun 20 17:53:06 2012 +0530

    regulator: dt: regulator match by regulator-compatible
    
    Match the device's regulators with the property of
    "regulator-compatible" of each regulator node.
    
    Signed-off-by: Laxman Dewangan <ldewangan@nvidia.com>
    Acked-by: Stephen Warren <swarren@wwwdotorg.org>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/of_regulator.c b/drivers/regulator/of_regulator.c
index 68dc3d43dd37..3e4106f2bda9 100644
--- a/drivers/regulator/of_regulator.c
+++ b/drivers/regulator/of_regulator.c
@@ -92,15 +92,17 @@ struct regulator_init_data *of_get_regulator_init_data(struct device *dev,
 EXPORT_SYMBOL_GPL(of_get_regulator_init_data);
 
 /**
- * of_regulator_match - extract regulator init data
+ * of_regulator_match - extract regulator init data when node
+ * property "regulator-compatible" matches with the regulator name.
  * @dev: device requesting the data
  * @node: parent device node of the regulators
  * @matches: match table for the regulators
  * @num_matches: number of entries in match table
  *
  * This function uses a match table specified by the regulator driver and
- * looks up the corresponding init data in the device tree. Note that the
- * match table is modified in place.
+ * looks up the corresponding init data in the device tree  if
+ * regulator-compatible matches. Note that the match table is modified
+ * in place.
  *
  * Returns the number of matches found or a negative error code on failure.
  */
@@ -110,27 +112,40 @@ int of_regulator_match(struct device *dev, struct device_node *node,
 {
 	unsigned int count = 0;
 	unsigned int i;
+	const char *regulator_comp;
+	struct device_node *child;
 
 	if (!dev || !node)
 		return -EINVAL;
 
-	for (i = 0; i < num_matches; i++) {
-		struct of_regulator_match *match = &matches[i];
-		struct device_node *child;
-
-		child = of_find_node_by_name(node, match->name);
-		if (!child)
-			continue;
-
-		match->init_data = of_get_regulator_init_data(dev, child);
-		if (!match->init_data) {
-			dev_err(dev, "failed to parse DT for regulator %s\n",
+	for_each_child_of_node(node, child) {
+		regulator_comp = of_get_property(child,
+					"regulator-compatible", NULL);
+		if (!regulator_comp) {
+			dev_err(dev, "regulator-compatible is missing for node %s\n",
 				child->name);
-			return -EINVAL;
+			continue;
+		}
+		for (i = 0; i < num_matches; i++) {
+			struct of_regulator_match *match = &matches[i];
+			if (match->of_node)
+				continue;
+
+			if (strcmp(match->name, regulator_comp))
+				continue;
+
+			match->init_data =
+				of_get_regulator_init_data(dev, child);
+			if (!match->init_data) {
+				dev_err(dev,
+					"failed to parse DT for regulator %s\n",
+					child->name);
+				return -EINVAL;
+			}
+			match->of_node = child;
+			count++;
+			break;
 		}
-
-		match->of_node = child;
-		count++;
 	}
 
 	return count;

commit 086ccd4379ad6c9c7c7713ef5f61b9d12e995147
Author: Axel Lin <axel.lin@gmail.com>
Date:   Mon Jun 18 13:59:02 2012 +0800

    regulator: Fix setting constraints->ramp_delay in of_get_regulation_constraints
    
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/of_regulator.c b/drivers/regulator/of_regulator.c
index e2a731079066..68dc3d43dd37 100644
--- a/drivers/regulator/of_regulator.c
+++ b/drivers/regulator/of_regulator.c
@@ -63,7 +63,7 @@ static void of_get_regulation_constraints(struct device_node *np,
 
 	ramp_delay = of_get_property(np, "regulator-ramp-delay", NULL);
 	if (ramp_delay)
-		constraints->min_uV = be32_to_cpu(*ramp_delay);
+		constraints->ramp_delay = be32_to_cpu(*ramp_delay);
 }
 
 /**

commit 6f0b2c696ca340cc2da381fe693fda3f8fdb2149
Author: Yadwinder Singh Brar <yadi.brar01@gmail.com>
Date:   Mon Jun 11 17:41:08 2012 +0530

    regulator: Add ramp_delay configuration to constraints
    
    For some hardwares ramp_delay for BUCKs is a configurable parameter which can
    be configured through DT or board file.This patch adds ramp_delay to regulator
    constraints and allow user to configure it for regulators which supports this
    feature, through DT or board file. It will provide two ways of setting the
    ramp_delay for a regulator:
            First, by setting it as constraints in board file(for configurable
    regulators) and set_machine_constraints() will take care of setting it on
    hardware by calling(the provided) .set_ramp_delay() operation(callback).
            Second, by setting it as data in regulator_desc(as fixed/default
    ramp_delay rate) for a regulator in driver.
    
    regulator_set_voltage_time_sel() will give preference to
    constraints->ramp_delay while reading ramp_delay rate for regulator. Similarly
    users should also take care accordingly while refering ramp_delay rate(in case
    of implementing their private .set_voltage_time_sel() callbacks for different
    regulators).
    
    [Rewrote subject for 80 columns -- broonie]
    
    Signed-off-by: Yadwinder Singh Brar <yadi.brar@samsung.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/of_regulator.c b/drivers/regulator/of_regulator.c
index 56593b75168a..e2a731079066 100644
--- a/drivers/regulator/of_regulator.c
+++ b/drivers/regulator/of_regulator.c
@@ -20,7 +20,7 @@ static void of_get_regulation_constraints(struct device_node *np,
 					struct regulator_init_data **init_data)
 {
 	const __be32 *min_uV, *max_uV, *uV_offset;
-	const __be32 *min_uA, *max_uA;
+	const __be32 *min_uA, *max_uA, *ramp_delay;
 	struct regulation_constraints *constraints = &(*init_data)->constraints;
 
 	constraints->name = of_get_property(np, "regulator-name", NULL);
@@ -60,6 +60,10 @@ static void of_get_regulation_constraints(struct device_node *np,
 		constraints->always_on = true;
 	else /* status change should be possible if not always on. */
 		constraints->valid_ops_mask |= REGULATOR_CHANGE_STATUS;
+
+	ramp_delay = of_get_property(np, "regulator-ramp-delay", NULL);
+	if (ramp_delay)
+		constraints->min_uV = be32_to_cpu(*ramp_delay);
 }
 
 /**

commit 1c8fa58f4750e9ad722fbf899866c312ffabab67
Author: Thierry Reding <thierry.reding@avionic-design.de>
Date:   Thu Apr 26 16:52:20 2012 +0200

    regulator: Add generic DT parsing for regulators
    
    Looking up init data for regulators found on chips is a common operation
    that can be handled in a generic way. The new helper function introduced
    by this patch looks up the children of a given node by names specified
    in a match table and fills that match table with information parsed from
    the DT.
    
    This is based on work by Rhyland Klein <rklein@nvidia.com>.
    
    Signed-off-by: Thierry Reding <thierry.reding@avionic-design.de>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/of_regulator.c b/drivers/regulator/of_regulator.c
index 679734d26a16..56593b75168a 100644
--- a/drivers/regulator/of_regulator.c
+++ b/drivers/regulator/of_regulator.c
@@ -14,6 +14,7 @@
 #include <linux/slab.h>
 #include <linux/of.h>
 #include <linux/regulator/machine.h>
+#include <linux/regulator/of_regulator.h>
 
 static void of_get_regulation_constraints(struct device_node *np,
 					struct regulator_init_data **init_data)
@@ -85,3 +86,49 @@ struct regulator_init_data *of_get_regulator_init_data(struct device *dev,
 	return init_data;
 }
 EXPORT_SYMBOL_GPL(of_get_regulator_init_data);
+
+/**
+ * of_regulator_match - extract regulator init data
+ * @dev: device requesting the data
+ * @node: parent device node of the regulators
+ * @matches: match table for the regulators
+ * @num_matches: number of entries in match table
+ *
+ * This function uses a match table specified by the regulator driver and
+ * looks up the corresponding init data in the device tree. Note that the
+ * match table is modified in place.
+ *
+ * Returns the number of matches found or a negative error code on failure.
+ */
+int of_regulator_match(struct device *dev, struct device_node *node,
+		       struct of_regulator_match *matches,
+		       unsigned int num_matches)
+{
+	unsigned int count = 0;
+	unsigned int i;
+
+	if (!dev || !node)
+		return -EINVAL;
+
+	for (i = 0; i < num_matches; i++) {
+		struct of_regulator_match *match = &matches[i];
+		struct device_node *child;
+
+		child = of_find_node_by_name(node, match->name);
+		if (!child)
+			continue;
+
+		match->init_data = of_get_regulator_init_data(dev, child);
+		if (!match->init_data) {
+			dev_err(dev, "failed to parse DT for regulator %s\n",
+				child->name);
+			return -EINVAL;
+		}
+
+		match->of_node = child;
+		count++;
+	}
+
+	return count;
+}
+EXPORT_SYMBOL_GPL(of_regulator_match);

commit 8a093049c604ab32d94bcc5baa24f7939d5e3f7b
Author: Karol Lewandowski <k.lewandowsk@samsung.com>
Date:   Wed Jan 25 10:31:45 2012 +0100

    regulator: Set apply_uV only when min and max voltages are defined
    
    apply_uV is errornously set when regulator is instantiated from device
    tree, even when it doesn't contain any voltage constraints.
    
    This commit fixes error:
    
      machine_constraints_voltage: CHARGER: failed to apply 0uV constraint
    
    for following regulator description in DTS:
    
      CHARGER {
            regulator-min-microamp = <100000>;
            regulator-max-microamp = <200000>;
      }
    
    Signed-off-by: Karol Lewandowski <k.lewandowsk@samsung.com>
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/of_regulator.c b/drivers/regulator/of_regulator.c
index f1651eb69648..679734d26a16 100644
--- a/drivers/regulator/of_regulator.c
+++ b/drivers/regulator/of_regulator.c
@@ -35,7 +35,7 @@ static void of_get_regulation_constraints(struct device_node *np,
 	if (constraints->min_uV != constraints->max_uV)
 		constraints->valid_ops_mask |= REGULATOR_CHANGE_VOLTAGE;
 	/* Only one voltage?  Then make sure it's set. */
-	if (constraints->min_uV == constraints->max_uV)
+	if (min_uV && max_uV && constraints->min_uV == constraints->max_uV)
 		constraints->apply_uV = true;
 
 	uV_offset = of_get_property(np, "regulator-microvolt-offset", NULL);

commit d9a861cce10596ae1f10cffefe1ad4519a253475
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Thu Dec 1 17:21:06 2011 +0800

    regulator: pass device_node to of_get_regulator_init_data()
    
    It's not always true that the device_node of regulator can be found
    at dev->of_node at the time when of_get_regulator_init_data() is being
    called, because in some cases the regulator nodes in device tree do
    not have 'struct device' behind them until regulator_dev gets created
    for it by core function regulator_register().
    
    The patch adds device_node as a new parameter to
    of_get_regulator_init_data(), so that caller can pass in the node of
    regulator directly.
    
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
    Cc: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Cc: Liam Girdwood <lrg@ti.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/of_regulator.c b/drivers/regulator/of_regulator.c
index b7b3fc3b09e2..f1651eb69648 100644
--- a/drivers/regulator/of_regulator.c
+++ b/drivers/regulator/of_regulator.c
@@ -69,18 +69,19 @@ static void of_get_regulation_constraints(struct device_node *np,
  * tree node, returns a pointer to the populated struture or NULL if memory
  * alloc fails.
  */
-struct regulator_init_data *of_get_regulator_init_data(struct device *dev)
+struct regulator_init_data *of_get_regulator_init_data(struct device *dev,
+						struct device_node *node)
 {
 	struct regulator_init_data *init_data;
 
-	if (!dev->of_node)
+	if (!node)
 		return NULL;
 
 	init_data = devm_kzalloc(dev, sizeof(*init_data), GFP_KERNEL);
 	if (!init_data)
 		return NULL; /* Out of memory? */
 
-	of_get_regulation_constraints(dev->of_node, &init_data);
+	of_get_regulation_constraints(node, &init_data);
 	return init_data;
 }
 EXPORT_SYMBOL_GPL(of_get_regulator_init_data);

commit ab62aa931ed3512bc67857a03636756b96c78eae
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Dec 5 10:58:41 2011 +0000

    regulator: If a single voltage is set with device tree then set apply_uV
    
    Otherwise there is no way in the bindings to configure a fixed voltage
    via software. It seems reasonable to assume that if the binding explicitly
    specifies a voltage we want to actually use that voltage.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/of_regulator.c b/drivers/regulator/of_regulator.c
index acd7045d1601..b7b3fc3b09e2 100644
--- a/drivers/regulator/of_regulator.c
+++ b/drivers/regulator/of_regulator.c
@@ -34,6 +34,9 @@ static void of_get_regulation_constraints(struct device_node *np,
 	/* Voltage change possible? */
 	if (constraints->min_uV != constraints->max_uV)
 		constraints->valid_ops_mask |= REGULATOR_CHANGE_VOLTAGE;
+	/* Only one voltage?  Then make sure it's set. */
+	if (constraints->min_uV == constraints->max_uV)
+		constraints->apply_uV = true;
 
 	uV_offset = of_get_property(np, "regulator-microvolt-offset", NULL);
 	if (uV_offset)

commit e69af5e9677b1e5bf2a2432747ecd714aa537f2a
Author: Axel Lin <axel.lin@gmail.com>
Date:   Sat Nov 26 18:50:58 2011 +0800

    regulator: export of_get_regulator_init_data
    
    of_get_regulator_init_data is called in drivers/regulator/fixed.c
    which could be a module.
    
    Export of_get_regulator_init_data to fix below build error:
    ERROR: "of_get_regulator_init_data" [drivers/regulator/fixed.ko] undefined!
    make[1]: *** [__modpost] Error 1
    make: *** [modules] Error 2
    
    Reported-by: Randy Dunlap <rdunlap@xenotime.net>
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/of_regulator.c b/drivers/regulator/of_regulator.c
index 76673c784ab8..acd7045d1601 100644
--- a/drivers/regulator/of_regulator.c
+++ b/drivers/regulator/of_regulator.c
@@ -10,6 +10,7 @@
  * (at your option) any later version.
  */
 
+#include <linux/module.h>
 #include <linux/slab.h>
 #include <linux/of.h>
 #include <linux/regulator/machine.h>
@@ -79,3 +80,4 @@ struct regulator_init_data *of_get_regulator_init_data(struct device *dev)
 	of_get_regulation_constraints(dev->of_node, &init_data);
 	return init_data;
 }
+EXPORT_SYMBOL_GPL(of_get_regulator_init_data);

commit 8f446e6fa1d506be2cb80f91c214f1705327c7f9
Author: Rajendra Nayak <rnayak@ti.com>
Date:   Fri Nov 18 16:47:17 2011 +0530

    regulator: helper routine to extract regulator_init_data
    
    The helper routine is meant to be used by the regulator drivers
    to extract the regulator_init_data structure from the data
    that is passed from device tree.
    'consumer_supplies' which is part of regulator_init_data is not extracted
    as the regulator consumer mappings are passed through DT differently,
    implemented in subsequent patches.
    Similarly the regulator<-->parent/supply mapping is handled in
    subsequent patches.
    
    Also add documentation for regulator bindings to be used to pass
    regulator_init_data struct information from device tree.
    
    Some of the regulator properties which are linux and board specific,
    are left out since its not clear if they can
    be in someway embedded into the kernel or passed in from DT.
    They will be revisited later.
    
    Signed-off-by: Rajendra Nayak <rnayak@ti.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/of_regulator.c b/drivers/regulator/of_regulator.c
new file mode 100644
index 000000000000..76673c784ab8
--- /dev/null
+++ b/drivers/regulator/of_regulator.c
@@ -0,0 +1,81 @@
+/*
+ * OF helpers for regulator framework
+ *
+ * Copyright (C) 2011 Texas Instruments, Inc.
+ * Rajendra Nayak <rnayak@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/slab.h>
+#include <linux/of.h>
+#include <linux/regulator/machine.h>
+
+static void of_get_regulation_constraints(struct device_node *np,
+					struct regulator_init_data **init_data)
+{
+	const __be32 *min_uV, *max_uV, *uV_offset;
+	const __be32 *min_uA, *max_uA;
+	struct regulation_constraints *constraints = &(*init_data)->constraints;
+
+	constraints->name = of_get_property(np, "regulator-name", NULL);
+
+	min_uV = of_get_property(np, "regulator-min-microvolt", NULL);
+	if (min_uV)
+		constraints->min_uV = be32_to_cpu(*min_uV);
+	max_uV = of_get_property(np, "regulator-max-microvolt", NULL);
+	if (max_uV)
+		constraints->max_uV = be32_to_cpu(*max_uV);
+
+	/* Voltage change possible? */
+	if (constraints->min_uV != constraints->max_uV)
+		constraints->valid_ops_mask |= REGULATOR_CHANGE_VOLTAGE;
+
+	uV_offset = of_get_property(np, "regulator-microvolt-offset", NULL);
+	if (uV_offset)
+		constraints->uV_offset = be32_to_cpu(*uV_offset);
+	min_uA = of_get_property(np, "regulator-min-microamp", NULL);
+	if (min_uA)
+		constraints->min_uA = be32_to_cpu(*min_uA);
+	max_uA = of_get_property(np, "regulator-max-microamp", NULL);
+	if (max_uA)
+		constraints->max_uA = be32_to_cpu(*max_uA);
+
+	/* Current change possible? */
+	if (constraints->min_uA != constraints->max_uA)
+		constraints->valid_ops_mask |= REGULATOR_CHANGE_CURRENT;
+
+	if (of_find_property(np, "regulator-boot-on", NULL))
+		constraints->boot_on = true;
+
+	if (of_find_property(np, "regulator-always-on", NULL))
+		constraints->always_on = true;
+	else /* status change should be possible if not always on. */
+		constraints->valid_ops_mask |= REGULATOR_CHANGE_STATUS;
+}
+
+/**
+ * of_get_regulator_init_data - extract regulator_init_data structure info
+ * @dev: device requesting for regulator_init_data
+ *
+ * Populates regulator_init_data structure by extracting data from device
+ * tree node, returns a pointer to the populated struture or NULL if memory
+ * alloc fails.
+ */
+struct regulator_init_data *of_get_regulator_init_data(struct device *dev)
+{
+	struct regulator_init_data *init_data;
+
+	if (!dev->of_node)
+		return NULL;
+
+	init_data = devm_kzalloc(dev, sizeof(*init_data), GFP_KERNEL);
+	if (!init_data)
+		return NULL; /* Out of memory? */
+
+	of_get_regulation_constraints(dev->of_node, &init_data);
+	return init_data;
+}
