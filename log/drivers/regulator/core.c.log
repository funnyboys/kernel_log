commit 48325655290869dbcdc356478bde4606d79d600e
Author: Charles Keepax <ckeepax@opensource.cirrus.com>
Date:   Fri May 29 16:22:16 2020 +0100

    regulator: core: Add regulator bypass trace points
    
    Add new trace points for the start and end of enabling bypass on a
    regulator, to allow monitoring of when regulators are moved into bypass
    and how long that takes.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.cirrus.com>
    Link: https://lore.kernel.org/r/20200529152216.9671-1-ckeepax@opensource.cirrus.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 370c655ad8f6..03154f5b939f 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -4321,6 +4321,7 @@ EXPORT_SYMBOL_GPL(regulator_set_load);
 int regulator_allow_bypass(struct regulator *regulator, bool enable)
 {
 	struct regulator_dev *rdev = regulator->rdev;
+	const char *name = rdev_get_name(rdev);
 	int ret = 0;
 
 	if (!rdev->desc->ops->set_bypass)
@@ -4335,18 +4336,26 @@ int regulator_allow_bypass(struct regulator *regulator, bool enable)
 		rdev->bypass_count++;
 
 		if (rdev->bypass_count == rdev->open_count) {
+			trace_regulator_bypass_enable(name);
+
 			ret = rdev->desc->ops->set_bypass(rdev, enable);
 			if (ret != 0)
 				rdev->bypass_count--;
+			else
+				trace_regulator_bypass_enable_complete(name);
 		}
 
 	} else if (!enable && regulator->bypass) {
 		rdev->bypass_count--;
 
 		if (rdev->bypass_count != rdev->open_count) {
+			trace_regulator_bypass_disable(name);
+
 			ret = rdev->desc->ops->set_bypass(rdev, enable);
 			if (ret != 0)
 				rdev->bypass_count++;
+			else
+				trace_regulator_bypass_disable_complete(name);
 		}
 	}
 

commit c1f615e4f463b1620fff51d1c08a5e83c1683d6b
Merge: 0c680ffb99ea 752db83a5dfd
Author: Mark Brown <broonie@kernel.org>
Date:   Fri May 29 14:36:03 2020 +0100

    Merge series "Fix regulators coupling for Exynos5800" from Marek Szyprowski <m.szyprowski@samsung.com>:
    
    Hi!
    
    This patchset is another attempt to fix the regulator coupling on
    Exynos5800/5422 SoCs. Here are links to the previous attempts:
    
    https://lore.kernel.org/linux-samsung-soc/20191008101709.qVNy8eijBi0LynOteWFMnTg4GUwKG599n6OyYoX1Abs@z/
    https://lore.kernel.org/lkml/20191017102758.8104-1-m.szyprowski@samsung.com/
    https://lore.kernel.org/linux-pm/cover.1589528491.git.viresh.kumar@linaro.org/
    https://lore.kernel.org/linux-pm/20200528131130.17984-1-m.szyprowski@samsung.com/
    
    The problem is with "vdd_int" regulator coupled with "vdd_arm" on Odroid
    XU3/XU4 boards family. "vdd_arm" is handled by CPUfreq. "vdd_int" is
    handled by devfreq. CPUfreq initialized quite early during boot and it
    starts changing OPPs and "vdd_arm" value. Sometimes CPU activity during
    boot goes down and some low-frequency OPPs are selected, what in turn
    causes lowering "vdd_arm". This happens before devfreq applies its
    requirements on "vdd_int". Regulator balancing code reduces "vdd_arm"
    voltage value, what in turn causes lowering "vdd_int" value to the lowest
    possible value. This is much below the operation point of the wcore bus,
    which still runs at the highest frequency.
    
    The issue was hard to notice because in the most cases the board managed
    to boot properly, even when the regulator was set to lowest value allowed
    by the regulator constraints. However, it caused some random issues,
    which can be observed as "Unhandled prefetch abort" or low USB stability.
    
    Adding more and more special cases to the generic code has been rejected,
    so the only way to ensure the desired behavior on Exynos5800-based SoCs
    is to make a custom regulator coupler driver.
    
    Best regards,
    Marek Szyprowski
    
    Patch summary:
    
    Marek Szyprowski (2):
      regulator: extract voltage balancing code to separate function
      soc: samsung: Add simple voltage coupler for Exynos5800
    
     arch/arm/mach-exynos/Kconfig                  |  1 +
     drivers/regulator/core.c                      | 49 ++++++++-------
     drivers/soc/samsung/Kconfig                   |  3 +
     drivers/soc/samsung/Makefile                  |  1 +
     .../soc/samsung/exynos-regulator-coupler.c    | 59 +++++++++++++++++++
     include/linux/regulator/coupler.h             |  8 +++
     6 files changed, 101 insertions(+), 20 deletions(-)
     create mode 100644 drivers/soc/samsung/exynos-regulator-coupler.c
    
    --
    2.17.1
    
    base-commit: 8f3d9f354286745c751374f5f1fcafee6b3f3136

commit 752db83a5dfd4fd3a0624b9ab440ed947fa003ca
Author: Marek Szyprowski <m.szyprowski@samsung.com>
Date:   Fri May 29 14:49:39 2020 +0200

    regulator: extract voltage balancing code to the separate function
    
    Move the coupled regulators voltage balancing code to the separate
    function and allow to call it from the custom regulator couplers.
    
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Link: https://lore.kernel.org/r/20200529124940.10675-2-m.szyprowski@samsung.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index c340505150b6..1eba6c202bf5 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -3642,36 +3642,19 @@ static int regulator_get_optimal_voltage(struct regulator_dev *rdev,
 	return done;
 }
 
-static int regulator_balance_voltage(struct regulator_dev *rdev,
-				     suspend_state_t state)
+int regulator_do_balance_voltage(struct regulator_dev *rdev,
+				 suspend_state_t state, bool skip_coupled)
 {
 	struct regulator_dev **c_rdevs;
 	struct regulator_dev *best_rdev;
 	struct coupling_desc *c_desc = &rdev->coupling_desc;
-	struct regulator_coupler *coupler = c_desc->coupler;
 	int i, ret, n_coupled, best_min_uV, best_max_uV, best_c_rdev;
 	unsigned int delta, best_delta;
 	unsigned long c_rdev_done = 0;
 	bool best_c_rdev_done;
 
 	c_rdevs = c_desc->coupled_rdevs;
-	n_coupled = c_desc->n_coupled;
-
-	/*
-	 * If system is in a state other than PM_SUSPEND_ON, don't check
-	 * other coupled regulators.
-	 */
-	if (state != PM_SUSPEND_ON)
-		n_coupled = 1;
-
-	if (c_desc->n_resolved < n_coupled) {
-		rdev_err(rdev, "Not all coupled regulators registered\n");
-		return -EPERM;
-	}
-
-	/* Invoke custom balancer for customized couplers */
-	if (coupler && coupler->balance_voltage)
-		return coupler->balance_voltage(coupler, rdev, state);
+	n_coupled = skip_coupled ? 1 : c_desc->n_coupled;
 
 	/*
 	 * Find the best possible voltage change on each loop. Leave the loop
@@ -3742,6 +3725,32 @@ static int regulator_balance_voltage(struct regulator_dev *rdev,
 	return ret;
 }
 
+static int regulator_balance_voltage(struct regulator_dev *rdev,
+				     suspend_state_t state)
+{
+	struct coupling_desc *c_desc = &rdev->coupling_desc;
+	struct regulator_coupler *coupler = c_desc->coupler;
+	bool skip_coupled = false;
+
+	/*
+	 * If system is in a state other than PM_SUSPEND_ON, don't check
+	 * other coupled regulators.
+	 */
+	if (state != PM_SUSPEND_ON)
+		skip_coupled = true;
+
+	if (c_desc->n_resolved < c_desc->n_coupled) {
+		rdev_err(rdev, "Not all coupled regulators registered\n");
+		return -EPERM;
+	}
+
+	/* Invoke custom balancer for customized couplers */
+	if (coupler && coupler->balance_voltage)
+		return coupler->balance_voltage(coupler, rdev, state);
+
+	return regulator_do_balance_voltage(rdev, state, skip_coupled);
+}
+
 /**
  * regulator_set_voltage - set regulator output voltage
  * @regulator: regulator source

commit a24490e0170e4cc6d4fd1f37691f19a106b694ae
Merge: 9bcbabafa19b 7e73861eb40d
Author: Mark Brown <broonie@kernel.org>
Date:   Wed May 20 16:09:02 2020 +0100

    Merge series "MAINTAINER entries for few ROHM power devices" from Matti Vaittinen <matti.vaittinen@fi.rohmeurope.com>:
    
    Add maintainer entries to a few ROHM devices and Linear Ranges
    
    Linear Ranges helpers were refactored out of regulator core to lib so
    that other drivers could utilize them too. (I guess power/supply drivers
    and possibly clk drivers can benefit from them). As regulators is
    currently the main user it makes sense the changes to linear_ranges go
    through Mark's tree.
    
    During past two years few ROHM PMIC drivers have been added to
    mainstream. They deserve a supporter from ROHM side too :)
    
    Patch 1:
            Maintainer entries for few ROHM IC drivers
    Patch 2:
            Maintainer entry for linear ranges helpers
    
    ---
    
    Matti Vaittinen (2):
      MAINTAINERS: Add entry for ROHM power management ICs
      MAINTAINERS: Add maintainer entry for linear ranges helper
    
     MAINTAINERS | 37 +++++++++++++++++++++++++++++++++++++
     1 file changed, 37 insertions(+)
    
    base-commit: b9bbe6ed63b2b9f2c9ee5cbd0f2c946a2723f4ce
    --
    2.21.0
    
    --
    Matti Vaittinen, Linux device drivers
    ROHM Semiconductors, Finland SWDC
    Kiviharjunlenkki 1E
    90220 OULU
    FINLAND
    
    ~~~ "I don't think so," said Rene Descartes. Just then he vanished ~~~
    Simon says - in Latin please.
    ~~~ "non cogito me" dixit Rene Descarte, deinde evanescavit ~~~
    Thanks to Simon Glass for the translation =]

commit 2a15483b401c0b07e44b43b95414e36f32c02f32
Author: John Stultz <john.stultz@linaro.org>
Date:   Wed Apr 29 17:23:49 2020 +0000

    regulator: Revert "Use driver_deferred_probe_timeout for regulator_init_complete_work"
    
    This reverts commit dca0b44957e5 ("regulator: Use
    driver_deferred_probe_timeout for regulator_init_complete_work"),
    as we ended up reverting the default deferred_probe_timeout
    value back to zero, to preserve behavior with 5.6 we need to
    decouple the regulator timeout which was previously 30 seconds.
    
    This avoids breaking some systems that depend on the regulator
    timeout but don't require the deferred probe timeout.
    
    Cc: linux-pm@vger.kernel.org
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: Thierry Reding <treding@nvidia.com>
    Cc: Liam Girdwood <lgirdwood@gmail.com>
    Cc: Bjorn Andersson <bjorn.andersson@linaro.org>
    Cc: Saravana Kannan <saravanak@google.com>
    Cc: Todd Kjos <tkjos@google.com>
    Cc: Len Brown <len.brown@intel.com>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: Ulf Hansson <ulf.hansson@linaro.org>
    Cc: Kevin Hilman <khilman@kernel.org>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Rob Herring <robh@kernel.org>
    Reported-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Suggested-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Reviewed-by: Mark Brown <broonie@kernel.org>
    Link: https://lore.kernel.org/r/20200429172349.55979-1-john.stultz@linaro.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index c340505150b6..7486f6e4e613 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -5754,10 +5754,6 @@ static DECLARE_DELAYED_WORK(regulator_init_complete_work,
 
 static int __init regulator_init_complete(void)
 {
-	int delay = driver_deferred_probe_timeout;
-
-	if (delay < 0)
-		delay = 0;
 	/*
 	 * Since DT doesn't provide an idiomatic mechanism for
 	 * enabling full constraints and since it's much more natural
@@ -5768,17 +5764,18 @@ static int __init regulator_init_complete(void)
 		has_full_constraints = true;
 
 	/*
-	 * If driver_deferred_probe_timeout is set, we punt
-	 * completion for that many seconds since systems like
-	 * distros will load many drivers from userspace so consumers
-	 * might not always be ready yet, this is particularly an
-	 * issue with laptops where this might bounce the display off
-	 * then on.  Ideally we'd get a notification from userspace
-	 * when this happens but we don't so just wait a bit and hope
-	 * we waited long enough.  It'd be better if we'd only do
-	 * this on systems that need it.
+	 * We punt completion for an arbitrary amount of time since
+	 * systems like distros will load many drivers from userspace
+	 * so consumers might not always be ready yet, this is
+	 * particularly an issue with laptops where this might bounce
+	 * the display off then on.  Ideally we'd get a notification
+	 * from userspace when this happens but we don't so just wait
+	 * a bit and hope we waited long enough.  It'd be better if
+	 * we'd only do this on systems that need it, and a kernel
+	 * command line option might be useful.
 	 */
-	schedule_delayed_work(&regulator_init_complete_work, delay * HZ);
+	schedule_delayed_work(&regulator_init_complete_work,
+			      msecs_to_jiffies(30000));
 
 	return 0;
 }

commit 6b576eb035dba77daf091f045fa1448682ee12b4
Author: Michał Mirosław <mirq-linux@rere.qmqm.pl>
Date:   Sat Apr 4 02:11:57 2020 +0200

    regulator: use consumer->supply_name in debugfs/regulator_summary
    
    Make it easier to identify regulator consumers when consumer device
    uses more than one supply.
    
    Before:
    
      regulator                      ena use open bypass voltage current min     max
     -----------------------------------------------------------------------------------
      regulator-dummy                  1   0    2      0     0mV     0mA 0mV     0mV
         1-0010                                                          0mV     0mV
         1-0010                                                          0mV     0mV
    
    After:
    
      regulator                      ena use open bypass voltage current min     max
     -----------------------------------------------------------------------------------
      regulator-dummy                  1   0    2      0     0mV     0mA 0mV     0mV
         1-0010-vccio                                                    0mV     0mV
         1-0010-vcc33                                                    0mV     0mV
    
    Signed-off-by: Michał Mirosław <mirq-linux@rere.qmqm.pl>
    Link: https://lore.kernel.org/r/731a4b299c6ae0ee9d8995157600a3477f21a36c.1585959068.git.mirq-linux@rere.qmqm.pl
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index c340505150b6..ad143004c32b 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -5496,6 +5496,7 @@ static void regulator_summary_show_subtree(struct seq_file *s,
 		seq_printf(s, "%*s%-*s ",
 			   (level + 1) * 3 + 1, "",
 			   30 - (level + 1) * 3,
+			   consumer->supply_name ? consumer->supply_name :
 			   consumer->dev ? dev_name(consumer->dev) : "deviceless");
 
 		switch (rdev->desc->type) {

commit a231bed2267cf45b0759da1d3ad62483b8bd0925
Merge: e129940938d8 6dfae59d37ae
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Mar 30 14:58:26 2020 -0700

    Merge tag 'regulator-spi-v5.7' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/misc
    
    Pull spi and regulator updates from Mark Brown:
     "At one point in the release cycle I managed to fat finger things and
      apply some SPI fixes onto a regulator branch and merge that into the
      SPI tree, then pull in a change shared with the MTD tree moving the
      Mediatek quadspi driver over to become the Mediatek spi-nor driver in
      the SPI tree.
    
      This has made a mess which I only just noticed while preparing this
      and I can't see a sensible way to unpick things due to other
      subsequent merge commits especially the pull from MTD so it looks like
      the most sensible thing to do is give up and combine the two pull
      requests.
    
      Fortunately both subsystems were fairly quiet this cycle, the
      highlights are:
    
      regulator:
    
       - Support for Monoloithic Power Systems MP5416, MP8867 and MPS8869
         and Qualcomm PMI8994 and SMB208.
    
      SPI:
    
       - Lots of enhancements for spi-fsl-dspi, including XSPI mode support,
         from Vladimir Oltean.
    
       - Support for amlogic Meson G12A, IBM FSI, Mediatek spi-nor (moved
         from MTD), NXP i.MX8Mx, Rockchip PX30, RK3308 and RK3328, and
         Qualcomm Atheros AR934x/QCA95xx"
    
    * tag 'regulator-spi-v5.7' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/misc: (118 commits)
      spi: efm32: Convert to use GPIO descriptors
      regulator: qcom_smd: Add pmi8994 regulator support
      regulator: da9063: Fix get_mode() functions to read sleep field
      spi: spi-fsl-lpspi: Replace zero-length array with flexible-array member
      spi: spi-s3c24xx: Replace zero-length array with flexible-array member
      spi: stm32: Fix comments compilation warnings
      spi: atmel-quadspi: Add verbose debug facilities to monitor register accesses
      spi: spi-fsl-dspi: Add support for LS1028A
      spi: spi-fsl-dspi: Move invariant configs out of dspi_transfer_one_message
      spi: spi-fsl-dspi: Fix interrupt-less DMA mode taking an XSPI code path
      spi: spi-fsl-dspi: Avoid NULL pointer in dspi_slave_abort for non-DMA mode
      spi: spi-fsl-dspi: Replace interruptible wait queue with a simple completion
      spi: spi-fsl-dspi: Protect against races on dspi->words_in_flight
      spi: spi-fsl-dspi: Avoid reading more data than written in EOQ mode
      spi: spi-fsl-dspi: Fix bits-per-word acceleration in DMA mode
      spi: spi-fsl-dspi: Fix little endian access to PUSHR CMD and TXDATA
      spi: spi-fsl-dspi: Don't access reserved fields in SPI_MCR
      regulator: driver.h: fix regulator_map_* function names
      regulator: da9063: fix suspend
      spi: mxs: Drop GPIO includes
      ...

commit 6e5505cf3ee411761fae8b7419e4f673be41690a
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Thu Mar 12 20:32:45 2020 +0200

    regulator: core: Avoid device name duplication in NORMAL_GET
    
    With current code:
            st-gyro-i2c i2c-PRP0001:00: i2c-PRP0001:00 supply vdd not found, using dummy regulator
    
    which looks a bit oververbose.
    
    Replace this with simplified format string for the above case, and drop
    "deviceless" case since for all dev_*() macros used in _regulator_get()
    the "(null)" will be printed anyway.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Link: https://lore.kernel.org/r/20200312183245.1612-1-andriy.shevchenko@linux.intel.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index d015d99cb59d..7486f6e4e613 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1849,7 +1849,6 @@ struct regulator *_regulator_get(struct device *dev, const char *id,
 {
 	struct regulator_dev *rdev;
 	struct regulator *regulator;
-	const char *devname = dev ? dev_name(dev) : "deviceless";
 	struct device_link *link;
 	int ret;
 
@@ -1887,9 +1886,7 @@ struct regulator *_regulator_get(struct device *dev, const char *id,
 			 * enabled, even if it isn't hooked up, and just
 			 * provide a dummy.
 			 */
-			dev_warn(dev,
-				 "%s supply %s not found, using dummy regulator\n",
-				 devname, id);
+			dev_warn(dev, "supply %s not found, using dummy regulator\n", id);
 			rdev = dummy_regulator_rdev;
 			get_device(&rdev->dev);
 			break;

commit dca0b44957e581e76dcbe54498f5f198c67d4164
Author: John Stultz <john.stultz@linaro.org>
Date:   Tue Feb 25 05:08:28 2020 +0000

    regulator: Use driver_deferred_probe_timeout for regulator_init_complete_work
    
    The regulator_init_complete_work logic defers the cleanup for an
    arbitrary 30 seconds of time to allow modules loaded by userland
    to start.
    
    This arbitrary timeout is similar to the
    driver_deferred_probe_timeout value, and its been suggested we
    align these so users have a method to extend the timeouts as
    needed.
    
    So this patch changes the logic to use the
    driver_deferred_probe_timeout value for the delay value if it
    is set (using a delay of 0 if it is not).
    
    Cc: linux-pm@vger.kernel.org
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: Thierry Reding <treding@nvidia.com>
    Cc: Mark Brown <broonie@kernel.org>
    Cc: Liam Girdwood <lgirdwood@gmail.com>
    Cc: Bjorn Andersson <bjorn.andersson@linaro.org>
    Cc: Saravana Kannan <saravanak@google.com>
    Cc: Todd Kjos <tkjos@google.com>
    Cc: Len Brown <len.brown@intel.com>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: Ulf Hansson <ulf.hansson@linaro.org>
    Cc: Kevin Hilman <khilman@kernel.org>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Rob Herring <robh@kernel.org>
    Acked-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Link: https://lore.kernel.org/r/20200225050828.56458-7-john.stultz@linaro.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index d015d99cb59d..51b6a2dea717 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -5757,6 +5757,10 @@ static DECLARE_DELAYED_WORK(regulator_init_complete_work,
 
 static int __init regulator_init_complete(void)
 {
+	int delay = driver_deferred_probe_timeout;
+
+	if (delay < 0)
+		delay = 0;
 	/*
 	 * Since DT doesn't provide an idiomatic mechanism for
 	 * enabling full constraints and since it's much more natural
@@ -5767,18 +5771,17 @@ static int __init regulator_init_complete(void)
 		has_full_constraints = true;
 
 	/*
-	 * We punt completion for an arbitrary amount of time since
-	 * systems like distros will load many drivers from userspace
-	 * so consumers might not always be ready yet, this is
-	 * particularly an issue with laptops where this might bounce
-	 * the display off then on.  Ideally we'd get a notification
-	 * from userspace when this happens but we don't so just wait
-	 * a bit and hope we waited long enough.  It'd be better if
-	 * we'd only do this on systems that need it, and a kernel
-	 * command line option might be useful.
+	 * If driver_deferred_probe_timeout is set, we punt
+	 * completion for that many seconds since systems like
+	 * distros will load many drivers from userspace so consumers
+	 * might not always be ready yet, this is particularly an
+	 * issue with laptops where this might bounce the display off
+	 * then on.  Ideally we'd get a notification from userspace
+	 * when this happens but we don't so just wait a bit and hope
+	 * we waited long enough.  It'd be better if we'd only do
+	 * this on systems that need it.
 	 */
-	schedule_delayed_work(&regulator_init_complete_work,
-			      msecs_to_jiffies(30000));
+	schedule_delayed_work(&regulator_init_complete_work, delay * HZ);
 
 	return 0;
 }

commit f7abb7e33b295a3556b7e86ba3dbb7390e7880af
Merge: def9d2780727 3d7610e8da99
Author: Mark Brown <broonie@kernel.org>
Date:   Thu Jan 23 12:37:04 2020 +0000

    Merge branch 'regulator-5.5' into regulator-linus

commit 3d7610e8da993539346dce6f7c909fd3d56bf4d5
Author: Enric Balletbo i Serra <enric.balletbo@collabora.com>
Date:   Mon Jan 20 13:39:21 2020 +0100

    regulator: core: Fix exported symbols to the exported GPL version
    
    Change the exported symbols introduced by commit e9153311491da
    ("regulator: vctrl-regulator: Avoid deadlock getting and setting the voltage")
    from EXPORT_SYMBOL() to EXPORT_SYMBOL_GPL(), like is used for all the core
    parts.
    
    Fixes: e9153311491da ("regulator: vctrl-regulator: Avoid deadlock getting and setting the voltage")
    Reported-by: Dmitry Osipenko <digetx@gmail.com>
    Signed-off-by: Enric Balletbo i Serra <enric.balletbo@collabora.com>
    Link: https://lore.kernel.org/r/20200120123921.1204339-1-enric.balletbo@collabora.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 6be687d25484..5bab251b9a9d 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -3466,7 +3466,7 @@ int regulator_set_voltage_rdev(struct regulator_dev *rdev, int min_uV,
 out:
 	return ret;
 }
-EXPORT_SYMBOL(regulator_set_voltage_rdev);
+EXPORT_SYMBOL_GPL(regulator_set_voltage_rdev);
 
 static int regulator_limit_voltage_step(struct regulator_dev *rdev,
 					int *current_uV, int *min_uV)
@@ -4031,7 +4031,7 @@ int regulator_get_voltage_rdev(struct regulator_dev *rdev)
 		return ret;
 	return ret - rdev->constraints->uV_offset;
 }
-EXPORT_SYMBOL(regulator_get_voltage_rdev);
+EXPORT_SYMBOL_GPL(regulator_get_voltage_rdev);
 
 /**
  * regulator_get_voltage - get regulator output voltage

commit e9153311491da9d9863ead9888a1613531cb4a1b
Author: Enric Balletbo i Serra <enric.balletbo@collabora.com>
Date:   Thu Jan 16 10:45:43 2020 +0100

    regulator: vctrl-regulator: Avoid deadlock getting and setting the voltage
    
    `cat /sys/kernel/debug/regulator/regulator_summary` ends on a deadlock
    when you have a voltage controlled regulator (vctrl).
    
    The problem is that the vctrl_get_voltage() and vctrl_set_voltage() calls the
    regulator_get_voltage() and regulator_set_voltage() and that will try to lock
    again the dependent regulators (the regulator supplying the control voltage).
    
    Fix the issue by exporting the unlocked version of the regulator_get_voltage()
    and regulator_set_voltage() API so drivers that need it, like the voltage
    controlled regulator driver can use it.
    
    Fixes: f8702f9e4aa7 ("regulator: core: Use ww_mutex for regulators locking")
    Reported-by: Douglas Anderson <dianders@chromium.org>
    Signed-off-by: Enric Balletbo i Serra <enric.balletbo@collabora.com>
    Link: https://lore.kernel.org/r/20200116094543.2847321-1-enric.balletbo@collabora.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 2961ac08d1ae..6be687d25484 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -3466,6 +3466,7 @@ int regulator_set_voltage_rdev(struct regulator_dev *rdev, int min_uV,
 out:
 	return ret;
 }
+EXPORT_SYMBOL(regulator_set_voltage_rdev);
 
 static int regulator_limit_voltage_step(struct regulator_dev *rdev,
 					int *current_uV, int *min_uV)
@@ -4030,6 +4031,7 @@ int regulator_get_voltage_rdev(struct regulator_dev *rdev)
 		return ret;
 	return ret - rdev->constraints->uV_offset;
 }
+EXPORT_SYMBOL(regulator_get_voltage_rdev);
 
 /**
  * regulator_get_voltage - get regulator output voltage

commit 58d90a04bdcc28e1b34251f4d9c1c4d39d4bba69
Merge: a922f1a9aec1 62a1923cc8fe
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Dec 17 13:08:41 2019 -0800

    Merge tag 'regulator-fix-v5.5-rc2' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/regulator
    
    Pull regulator fixes from Mark Brown:
     "A small set of fixes for mostly minor issues here, the only real code
      ones are Wen Yang's fixes for error handling in the core and Christian
      Marussi's list_voltage() change which is a fix for disruptively bad
      performance for regulators with continuous voltage control (which are
      rare)"
    
    * tag 'regulator-fix-v5.5-rc2' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/regulator:
      regulator: rn5t618: fix module aliases
      regulator: max77650: add of_match table
      regulator: core: avoid unneeded .list_voltage calls
      regulator: s5m8767: Fix a warning message
      regulator: core: fix regulator_register() error paths to properly release rdev
      regulator: fix use after free issue

commit 6d30fc511bec82dd8801b9bb8718cbeea1366ad8
Author: Cristian Marussi <cristian.marussi@arm.com>
Date:   Mon Dec 9 12:52:39 2019 +0000

    regulator: core: avoid unneeded .list_voltage calls
    
    Inside machine_constraints_voltage() a loop is in charge of verifying that
    each of the defined voltages are within the configured constraints and
    that those constraints are in fact compatible with the available voltages'
    list.
    
    When the registered regulator happens to be defined with a wide range of
    possible voltages the above O(n) loop can be costly.
    Moreover since this behaviour is triggered during the registration process,
    it means also that it can be easily triggered at probe time, slowing down
    considerably some module loading.
    
    On the other side if such wide range of voltage values happens to be also
    continuous and without discontinuity of any kind, the above potentially
    cumbersome operation is also useless.
    
    For these reasons, avoid such .list_voltage poll loop when regulator is
    described as 'continuous_voltage_range' as is, indeed, similarly already
    done inside regulator_is_supported_voltage().
    
    Signed-off-by: Cristian Marussi <cristian.marussi@arm.com>
    Link: https://lore.kernel.org/r/20191209125239.46054-1-cristian.marussi@arm.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 2c3a03cfd381..2961ac08d1ae 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1198,6 +1198,10 @@ static int machine_constraints_voltage(struct regulator_dev *rdev,
 			return -EINVAL;
 		}
 
+		/* no need to loop voltages if range is continuous */
+		if (rdev->desc->continuous_voltage_range)
+			return 0;
+
 		/* initial: [cmin..cmax] valid, [min_uV..max_uV] not */
 		for (i = 0; i < count; i++) {
 			int	value;

commit a3cde9534ebdafe18a9bbab208df724c57e6c8e8
Author: Wen Yang <wenyang@linux.alibaba.com>
Date:   Sun Dec 1 11:02:50 2019 +0800

    regulator: core: fix regulator_register() error paths to properly release rdev
    
    There are several issues with the error handling code of
    the regulator_register() function:
            ret = device_register(&rdev->dev);
            if (ret != 0) {
                    put_device(&rdev->dev); --> rdev released
                    goto unset_supplies;
            }
    ...
    unset_supplies:
    ...
            unset_regulator_supplies(rdev); --> use-after-free
    ...
    clean:
            if (dangling_of_gpiod)
                    gpiod_put(config->ena_gpiod);
            kfree(rdev);                     --> double free
    
    We add a variable to record the failure of device_register() and
    move put_device() down a bit to avoid the above issues.
    
    Fixes: c438b9d01736 ("regulator: core: Move registration of regulator device")
    Signed-off-by: Wen Yang <wenyang@linux.alibaba.com>
    Cc: Liam Girdwood <lgirdwood@gmail.com>
    Cc: Mark Brown <broonie@kernel.org>
    Cc: linux-kernel@vger.kernel.org
    Link: https://lore.kernel.org/r/20191201030250.38074-1-wenyang@linux.alibaba.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index c80f3fd9532d..2c3a03cfd381 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -4998,6 +4998,7 @@ regulator_register(const struct regulator_desc *regulator_desc,
 	struct regulator_dev *rdev;
 	bool dangling_cfg_gpiod = false;
 	bool dangling_of_gpiod = false;
+	bool reg_device_fail = false;
 	struct device *dev;
 	int ret, i;
 
@@ -5183,7 +5184,7 @@ regulator_register(const struct regulator_desc *regulator_desc,
 	dev_set_drvdata(&rdev->dev, rdev);
 	ret = device_register(&rdev->dev);
 	if (ret != 0) {
-		put_device(&rdev->dev);
+		reg_device_fail = true;
 		goto unset_supplies;
 	}
 
@@ -5213,7 +5214,10 @@ regulator_register(const struct regulator_desc *regulator_desc,
 clean:
 	if (dangling_of_gpiod)
 		gpiod_put(config->ena_gpiod);
-	kfree(rdev);
+	if (reg_device_fail)
+		put_device(&rdev->dev);
+	else
+		kfree(rdev);
 	kfree(config);
 rinse:
 	if (dangling_cfg_gpiod)

commit 4affd79a125ac91e6a53be843ea3960a8fc00cbb
Author: Wen Yang <wenyang@linux.alibaba.com>
Date:   Sun Nov 24 22:58:35 2019 +0800

    regulator: fix use after free issue
    
    This is caused by dereferencing 'rdev' after put_device() in
    the _regulator_get()/_regulator_put() functions.
    This patch just moves the put_device() down a bit to avoid the
    issue.
    
    Signed-off-by: Wen Yang <wenyang@linux.alibaba.com>
    Cc: Liam Girdwood <lgirdwood@gmail.com>
    Cc: Mark Brown <broonie@kernel.org>
    Cc: linux-kernel@vger.kernel.org
    Link: https://lore.kernel.org/r/20191124145835.25999-1-wenyang@linux.alibaba.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 5e6c629806e4..c80f3fd9532d 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1937,8 +1937,8 @@ struct regulator *_regulator_get(struct device *dev, const char *id,
 	regulator = create_regulator(rdev, dev, id);
 	if (regulator == NULL) {
 		regulator = ERR_PTR(-ENOMEM);
-		put_device(&rdev->dev);
 		module_put(rdev->owner);
+		put_device(&rdev->dev);
 		return regulator;
 	}
 
@@ -2059,13 +2059,13 @@ static void _regulator_put(struct regulator *regulator)
 
 	rdev->open_count--;
 	rdev->exclusive = 0;
-	put_device(&rdev->dev);
 	regulator_unlock(rdev);
 
 	kfree_const(regulator->supply_name);
 	kfree(regulator);
 
 	module_put(rdev->owner);
+	put_device(&rdev->dev);
 }
 
 /**

commit a21da94f617bce0771144ea8093b6987184b38d0
Merge: c642e8708684 c15d5a645875
Author: Mark Brown <broonie@kernel.org>
Date:   Fri Nov 22 19:56:20 2019 +0000

    Merge branch 'regulator-5.5' into regulator-next

commit 089b3f61ecfc43ca4ea26d595e1d31ead6de3f7b
Author: Pascal Paillet <p.paillet@st.com>
Date:   Wed Nov 13 11:27:37 2019 +0100

    regulator: core: Let boot-on regulators be powered off
    
    Boot-on regulators are always kept on because their use_count value
    is now incremented at boot time and never cleaned.
    
    Only increment count value for alway-on regulators.
    regulator_late_cleanup() is now able to power off boot-on regulators
    when unused.
    
    Fixes: 05f224ca6693 ("regulator: core: Clean enabling always-on regulators + their supplies")
    Signed-off-by: Pascal Paillet <p.paillet@st.com>
    Link: https://lore.kernel.org/r/20191113102737.27831-1-p.paillet@st.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index a5b2a9b02108..5e6c629806e4 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1403,7 +1403,9 @@ static int set_machine_constraints(struct regulator_dev *rdev,
 			rdev_err(rdev, "failed to enable\n");
 			return ret;
 		}
-		rdev->use_count++;
+
+		if (rdev->constraints->always_on)
+			rdev->use_count++;
 	}
 
 	print_constraints(rdev);

commit b59b654478093fa429ad4c7897ae29f201146a00
Author: Saravana Kannan <saravanak@google.com>
Date:   Thu Nov 14 16:04:38 2019 -0800

    regulator: core: Don't try to remove device links if add failed
    
    device_link_add() might not always succeed depending on the type of
    device link and the rest of the dependencies in the system. If
    device_link_add() didn't succeed, then we shouldn't try to remove the
    link later on as it might remove a link someone else created.
    
    Signed-off-by: Saravana Kannan <saravanak@google.com>
    Link: https://lore.kernel.org/r/20191115000438.45970-1-saravanak@google.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 51ce280c1ce1..df49f35ae20f 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1844,6 +1844,7 @@ struct regulator *_regulator_get(struct device *dev, const char *id,
 	struct regulator_dev *rdev;
 	struct regulator *regulator;
 	const char *devname = dev ? dev_name(dev) : "deviceless";
+	struct device_link *link;
 	int ret;
 
 	if (get_type >= MAX_GET_TYPE) {
@@ -1951,7 +1952,9 @@ struct regulator *_regulator_get(struct device *dev, const char *id,
 			rdev->use_count = 0;
 	}
 
-	device_link_add(dev, &rdev->dev, DL_FLAG_STATELESS);
+	link = device_link_add(dev, &rdev->dev, DL_FLAG_STATELESS);
+	if (!IS_ERR_OR_NULL(link))
+		regulator->device_link = true;
 
 	return regulator;
 }
@@ -2046,7 +2049,8 @@ static void _regulator_put(struct regulator *regulator)
 	debugfs_remove_recursive(regulator->debugfs);
 
 	if (regulator->dev) {
-		device_link_remove(regulator->dev, &rdev->dev);
+		if (regulator->device_link)
+			device_link_remove(regulator->dev, &rdev->dev);
 
 		/* remove any sysfs entries */
 		sysfs_remove_link(&rdev->dev.kobj, regulator->supply_name);

commit e381bfe45a891a5894465f072c5bbf3ed3e33b8a
Author: Dmitry Osipenko <digetx@gmail.com>
Date:   Fri Oct 25 03:22:40 2019 +0300

    regulator: core: Allow generic coupling only for always-on regulators
    
    The generic voltage balancer doesn't work correctly if one of regulator
    couples turns off. Currently there are no users in kernel for that case,
    although let's explicitly show that this case is unsupported for those who
    will try to use that feature.
    
    Link: https://lore.kernel.org/linux-samsung-soc/20191008170503.yd6GscYPLxjgrXqDuCO7AJc6i6egNZGJkVWHLlCxvA4@z/
    Signed-off-by: Dmitry Osipenko <digetx@gmail.com>
    Link: https://lore.kernel.org/r/20191025002240.25288-2-digetx@gmail.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index a46be221dbdc..a5b2a9b02108 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -4963,6 +4963,12 @@ static int generic_coupler_attach(struct regulator_coupler *coupler,
 		return -EPERM;
 	}
 
+	if (!rdev->constraints->always_on) {
+		rdev_err(rdev,
+			 "Coupling of a non always-on regulator is unimplemented\n");
+		return -ENOTSUPP;
+	}
+
 	return 0;
 }
 

commit 26c2c997aa1a6c5522f6619910ba025e53e69763
Author: Dmitry Osipenko <digetx@gmail.com>
Date:   Fri Oct 25 03:22:39 2019 +0300

    regulator: core: Release coupled_rdevs on regulator_init_coupling() error
    
    This patch fixes memory leak which should happen if regulator's coupling
    fails to initialize.
    
    Fixes: d8ca7d184b33 ("regulator: core: Introduce API for regulators coupling customization")
    Signed-off-by: Dmitry Osipenko <digetx@gmail.com>
    Link: https://lore.kernel.org/r/20191025002240.25288-1-digetx@gmail.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index a46be221dbdc..51ce280c1ce1 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -5198,6 +5198,7 @@ regulator_register(const struct regulator_desc *regulator_desc,
 	regulator_remove_coupling(rdev);
 	mutex_unlock(&regulator_list_mutex);
 wash:
+	kfree(rdev->coupling_desc.coupled_rdevs);
 	kfree(rdev->constraints);
 	mutex_lock(&regulator_list_mutex);
 	regulator_ena_gpio_free(rdev);

commit f8970d341eec73c976a3462b9ecdb02b60b84dd6
Author: Marco Felsch <m.felsch@pengutronix.de>
Date:   Tue Sep 17 17:40:21 2019 +0200

    regulator: core: make regulator_register() EPROBE_DEFER aware
    
    Sometimes it can happen that the regulator_of_get_init_data() can't
    retrieve the config due to a not probed device the regulator depends on.
    Fix that by checking the return value of of_parse_cb() and return
    EPROBE_DEFER in such cases.
    
    Signed-off-by: Marco Felsch <m.felsch@pengutronix.de>
    Link: https://lore.kernel.org/r/20190917154021.14693-4-m.felsch@pengutronix.de
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index afe94470b67f..a46be221dbdc 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -5053,6 +5053,19 @@ regulator_register(const struct regulator_desc *regulator_desc,
 
 	init_data = regulator_of_get_init_data(dev, regulator_desc, config,
 					       &rdev->dev.of_node);
+
+	/*
+	 * Sometimes not all resources are probed already so we need to take
+	 * that into account. This happens most the time if the ena_gpiod comes
+	 * from a gpio extender or something else.
+	 */
+	if (PTR_ERR(init_data) == -EPROBE_DEFER) {
+		kfree(config);
+		kfree(rdev);
+		ret = -EPROBE_DEFER;
+		goto rinse;
+	}
+
 	/*
 	 * We need to keep track of any GPIO descriptor coming from the
 	 * device tree until we have handled it over to the core. If the

commit c82f27df07573ec7b124efe176d2ac6c038787a5
Author: H. Nikolaus Schaller <hns@goldelico.com>
Date:   Tue Sep 10 21:22:29 2019 +0200

    regulator: core: Fix error return for /sys access
    
    regulator_uV_show() is missing error handling if regulator_get_voltage_rdev()
    returns negative values. Instead it prints the errno as a string, e.g. -EINVAL
    as "-22" which could be interpreted as -22 µV.
    
    We also do not need to hold the lock while converting the integer to a string.
    
    Reported-by: Adam Ford <aford173@gmail.com>
    Signed-off-by: H. Nikolaus Schaller <hns@goldelico.com>
    Tested-by: Adam Ford <aford173@gmail.com>
    Link: https://lore.kernel.org/r/f37f2a1276efcb34cf3b7f1a25481175be048806.1568143348.git.hns@goldelico.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 340db986b67f..afe94470b67f 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -568,13 +568,15 @@ static ssize_t regulator_uV_show(struct device *dev,
 				struct device_attribute *attr, char *buf)
 {
 	struct regulator_dev *rdev = dev_get_drvdata(dev);
-	ssize_t ret;
+	int uV;
 
 	regulator_lock(rdev);
-	ret = sprintf(buf, "%d\n", regulator_get_voltage_rdev(rdev));
+	uV = regulator_get_voltage_rdev(rdev);
 	regulator_unlock(rdev);
 
-	return ret;
+	if (uV < 0)
+		return uV;
+	return sprintf(buf, "%d\n", uV);
 }
 static DEVICE_ATTR(microvolts, 0444, regulator_uV_show, NULL);
 

commit 55576cf1853798e86f620766e23b604c9224c19c
Author: Mark Brown <broonie@kernel.org>
Date:   Wed Sep 4 13:42:50 2019 +0100

    regulator: Defer init completion for a while after late_initcall
    
    The kernel has no way of knowing when we have finished instantiating
    drivers, between deferred probe and systems that build key drivers as
    modules we might be doing this long after userspace has booted. This has
    always been a bit of an issue with regulator_init_complete since it can
    power off hardware that's not had it's driver loaded which can result in
    user visible effects, the main case is powering off displays. Practically
    speaking it's not been an issue in real systems since most systems that
    use the regulator API are embedded and build in key drivers anyway but
    with Arm laptops coming on the market it's becoming more of an issue so
    let's do something about it.
    
    In the absence of any better idea just defer the powering off for 30s
    after late_initcall(), this is obviously a hack but it should mask the
    issue for now and it's no more arbitrary than late_initcall() itself.
    Ideally we'd have some heuristics to detect if we're on an affected
    system and tune or skip the delay appropriately, and there may be some
    need for a command line option to be added.
    
    Link: https://lore.kernel.org/r/20190904124250.25844-1-broonie@kernel.org
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Tested-by: Lee Jones <lee.jones@linaro.org>
    Cc: stable@vger.kernel.org

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 4a27a46ec6e7..340db986b67f 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -5644,7 +5644,7 @@ static int __init regulator_init(void)
 /* init early to allow our consumers to complete system booting */
 core_initcall(regulator_init);
 
-static int __init regulator_late_cleanup(struct device *dev, void *data)
+static int regulator_late_cleanup(struct device *dev, void *data)
 {
 	struct regulator_dev *rdev = dev_to_rdev(dev);
 	const struct regulator_ops *ops = rdev->desc->ops;
@@ -5693,17 +5693,8 @@ static int __init regulator_late_cleanup(struct device *dev, void *data)
 	return 0;
 }
 
-static int __init regulator_init_complete(void)
+static void regulator_init_complete_work_function(struct work_struct *work)
 {
-	/*
-	 * Since DT doesn't provide an idiomatic mechanism for
-	 * enabling full constraints and since it's much more natural
-	 * with DT to provide them just assume that a DT enabled
-	 * system has full constraints.
-	 */
-	if (of_have_populated_dt())
-		has_full_constraints = true;
-
 	/*
 	 * Regulators may had failed to resolve their input supplies
 	 * when were registered, either because the input supply was
@@ -5721,6 +5712,35 @@ static int __init regulator_init_complete(void)
 	 */
 	class_for_each_device(&regulator_class, NULL, NULL,
 			      regulator_late_cleanup);
+}
+
+static DECLARE_DELAYED_WORK(regulator_init_complete_work,
+			    regulator_init_complete_work_function);
+
+static int __init regulator_init_complete(void)
+{
+	/*
+	 * Since DT doesn't provide an idiomatic mechanism for
+	 * enabling full constraints and since it's much more natural
+	 * with DT to provide them just assume that a DT enabled
+	 * system has full constraints.
+	 */
+	if (of_have_populated_dt())
+		has_full_constraints = true;
+
+	/*
+	 * We punt completion for an arbitrary amount of time since
+	 * systems like distros will load many drivers from userspace
+	 * so consumers might not always be ready yet, this is
+	 * particularly an issue with laptops where this might bounce
+	 * the display off then on.  Ideally we'd get a notification
+	 * from userspace when this happens but we don't so just wait
+	 * a bit and hope we waited long enough.  It'd be better if
+	 * we'd only do this on systems that need it, and a kernel
+	 * command line option might be useful.
+	 */
+	schedule_delayed_work(&regulator_init_complete_work,
+			      msecs_to_jiffies(30000));
 
 	return 0;
 }

commit 81eeb0a35c2e40bcaf122c6aae3be4f7d9abe201
Author: Nishka Dasgupta <nishkadg.linux@gmail.com>
Date:   Thu Aug 15 11:07:04 2019 +0530

    regulator: core: Add label to collate of_node_put() statements
    
    In function of_get_child_regulator(), the loop for_each_child_of_node()
    contains two mid-loop return statements, each preceded by a statement
    putting child. In order to reduce this repetition, create a new label,
    err_node_put, that puts child and then returns the required value;
    edit the mid-loop return blocks to instead go to this new label.
    
    Signed-off-by: Nishka Dasgupta <nishkadg.linux@gmail.com>
    Link: https://lore.kernel.org/r/20190815053704.32156-1-nishkadg.linux@gmail.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 7a5d52948703..4a27a46ec6e7 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -380,16 +380,17 @@ static struct device_node *of_get_child_regulator(struct device_node *parent,
 
 		if (!regnode) {
 			regnode = of_get_child_regulator(child, prop_name);
-			if (regnode) {
-				of_node_put(child);
-				return regnode;
-			}
+			if (regnode)
+				goto err_node_put;
 		} else {
-			of_node_put(child);
-			return regnode;
+			goto err_node_put;
 		}
 	}
 	return NULL;
+
+err_node_put:
+	of_node_put(child);
+	return regnode;
 }
 
 /**

commit db2a17320a25a63b46ddb081a306af9ded1b906e
Author: Nishka Dasgupta <nishkadg.linux@gmail.com>
Date:   Sun Aug 4 21:50:23 2019 +0530

    regulator: core: Add of_node_put() before return
    
    Each iteration of for_each_child_of_node puts the previous node, but in
    the case of a return from the middle of the loop, there is no put, thus
    causing a memory leak. Hence add an of_node_put before the return in
    two places.
    Issue found with Coccinelle.
    
    Signed-off-by: Nishka Dasgupta <nishkadg.linux@gmail.com>
    Link: https://lore.kernel.org/r/20190804162023.5673-1-nishkadg.linux@gmail.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index e0c0cf462004..7a5d52948703 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -380,9 +380,12 @@ static struct device_node *of_get_child_regulator(struct device_node *parent,
 
 		if (!regnode) {
 			regnode = of_get_child_regulator(child, prop_name);
-			if (regnode)
+			if (regnode) {
+				of_node_put(child);
 				return regnode;
+			}
 		} else {
+			of_node_put(child);
 			return regnode;
 		}
 	}

commit e9a83bd2322035ed9d7dcf35753d3f984d76c6a5
Merge: 7011b7e1b702 454f96f2b738
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jul 9 12:34:26 2019 -0700

    Merge tag 'docs-5.3' of git://git.lwn.net/linux
    
    Pull Documentation updates from Jonathan Corbet:
     "It's been a relatively busy cycle for docs:
    
       - A fair pile of RST conversions, many from Mauro. These create more
         than the usual number of simple but annoying merge conflicts with
         other trees, unfortunately. He has a lot more of these waiting on
         the wings that, I think, will go to you directly later on.
    
       - A new document on how to use merges and rebases in kernel repos,
         and one on Spectre vulnerabilities.
    
       - Various improvements to the build system, including automatic
         markup of function() references because some people, for reasons I
         will never understand, were of the opinion that
         :c:func:``function()`` is unattractive and not fun to type.
    
       - We now recommend using sphinx 1.7, but still support back to 1.4.
    
       - Lots of smaller improvements, warning fixes, typo fixes, etc"
    
    * tag 'docs-5.3' of git://git.lwn.net/linux: (129 commits)
      docs: automarkup.py: ignore exceptions when seeking for xrefs
      docs: Move binderfs to admin-guide
      Disable Sphinx SmartyPants in HTML output
      doc: RCU callback locks need only _bh, not necessarily _irq
      docs: format kernel-parameters -- as code
      Doc : doc-guide : Fix a typo
      platform: x86: get rid of a non-existent document
      Add the RCU docs to the core-api manual
      Documentation: RCU: Add TOC tree hooks
      Documentation: RCU: Rename txt files to rst
      Documentation: RCU: Convert RCU UP systems to reST
      Documentation: RCU: Convert RCU linked list to reST
      Documentation: RCU: Convert RCU basic concepts to reST
      docs: filesystems: Remove uneeded .rst extension on toctables
      scripts/sphinx-pre-install: fix out-of-tree build
      docs: zh_CN: submitting-drivers.rst: Remove a duplicated Documentation/
      Documentation: PGP: update for newer HW devices
      Documentation: Add section about CPU vulnerabilities for Spectre
      Documentation: platform: Delete x86-laptop-drivers.txt
      docs: Note that :c:func: should no longer be used
      ...

commit 0ed4513c9a32a479b4dc41685be68edf1e99c139
Merge: 65244e5b1f4f d22b85a1b97d
Author: Mark Brown <broonie@kernel.org>
Date:   Thu Jul 4 17:34:34 2019 +0100

    Merge remote-tracking branch 'regulator/topic/coupled' into regulator-next

commit 2da8d9473e20a2f6645dcb0cea4848a2c1e83af9
Author: Bartosz Golaszewski <bgolaszewski@baylibre.com>
Date:   Wed Jul 3 18:10:34 2019 +0200

    regulator: implement selector stepping
    
    Some regulators require that the requested voltage be reached gradually
    by setting all or some of the intermediate values. Implement a new field
    in the regulator description struct that allows users to specify the
    number of selectors by which the regulator API should step when ramping
    the voltage up/down.
    
    Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>
    Link: https://lore.kernel.org/r/20190703161035.31808-2-brgl@bgdev.pl
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 9d3ed13b7f12..df82e2a8442a 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -3106,6 +3106,66 @@ static int _regulator_call_set_voltage_sel(struct regulator_dev *rdev,
 	return ret;
 }
 
+static int _regulator_set_voltage_sel_step(struct regulator_dev *rdev,
+					   int uV, int new_selector)
+{
+	const struct regulator_ops *ops = rdev->desc->ops;
+	int diff, old_sel, curr_sel, ret;
+
+	/* Stepping is only needed if the regulator is enabled. */
+	if (!_regulator_is_enabled(rdev))
+		goto final_set;
+
+	if (!ops->get_voltage_sel)
+		return -EINVAL;
+
+	old_sel = ops->get_voltage_sel(rdev);
+	if (old_sel < 0)
+		return old_sel;
+
+	diff = new_selector - old_sel;
+	if (diff == 0)
+		return 0; /* No change needed. */
+
+	if (diff > 0) {
+		/* Stepping up. */
+		for (curr_sel = old_sel + rdev->desc->vsel_step;
+		     curr_sel < new_selector;
+		     curr_sel += rdev->desc->vsel_step) {
+			/*
+			 * Call the callback directly instead of using
+			 * _regulator_call_set_voltage_sel() as we don't
+			 * want to notify anyone yet. Same in the branch
+			 * below.
+			 */
+			ret = ops->set_voltage_sel(rdev, curr_sel);
+			if (ret)
+				goto try_revert;
+		}
+	} else {
+		/* Stepping down. */
+		for (curr_sel = old_sel - rdev->desc->vsel_step;
+		     curr_sel > new_selector;
+		     curr_sel -= rdev->desc->vsel_step) {
+			ret = ops->set_voltage_sel(rdev, curr_sel);
+			if (ret)
+				goto try_revert;
+		}
+	}
+
+final_set:
+	/* The final selector will trigger the notifiers. */
+	return _regulator_call_set_voltage_sel(rdev, uV, new_selector);
+
+try_revert:
+	/*
+	 * At least try to return to the previous voltage if setting a new
+	 * one failed.
+	 */
+	(void)ops->set_voltage_sel(rdev, old_sel);
+	return ret;
+}
+
 static int _regulator_set_voltage_time(struct regulator_dev *rdev,
 				       int old_uV, int new_uV)
 {
@@ -3179,6 +3239,9 @@ static int _regulator_do_set_voltage(struct regulator_dev *rdev,
 				selector = ret;
 				if (old_selector == selector)
 					ret = 0;
+				else if (rdev->desc->vsel_step)
+					ret = _regulator_set_voltage_sel_step(
+						rdev, best_val, selector);
 				else
 					ret = _regulator_call_set_voltage_sel(
 						rdev, best_val, selector);

commit d22b85a1b97d12a4940ef9d778f6122546736f78
Author: Dmitry Osipenko <digetx@gmail.com>
Date:   Mon Jun 24 00:08:32 2019 +0300

    regulator: core: Expose some of core functions needed by couplers
    
    Expose some of internal functions that are required for implementation of
    customized regulator couplers.
    
    Signed-off-by: Dmitry Osipenko <digetx@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 12c870f790f5..b9bc45128b8c 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -100,7 +100,6 @@ struct regulator_supply_alias {
 
 static int _regulator_is_enabled(struct regulator_dev *rdev);
 static int _regulator_disable(struct regulator *regulator);
-static int _regulator_get_voltage(struct regulator_dev *rdev);
 static int _regulator_get_current_limit(struct regulator_dev *rdev);
 static unsigned int _regulator_get_mode(struct regulator_dev *rdev);
 static int _notifier_call_chain(struct regulator_dev *rdev,
@@ -109,15 +108,12 @@ static int _regulator_do_set_voltage(struct regulator_dev *rdev,
 				     int min_uV, int max_uV);
 static int regulator_balance_voltage(struct regulator_dev *rdev,
 				     suspend_state_t state);
-static int regulator_set_voltage_rdev(struct regulator_dev *rdev,
-				      int min_uV, int max_uV,
-				      suspend_state_t state);
 static struct regulator *create_regulator(struct regulator_dev *rdev,
 					  struct device *dev,
 					  const char *supply_name);
 static void _regulator_put(struct regulator *regulator);
 
-static const char *rdev_get_name(struct regulator_dev *rdev)
+const char *rdev_get_name(struct regulator_dev *rdev)
 {
 	if (rdev->constraints && rdev->constraints->name)
 		return rdev->constraints->name;
@@ -431,8 +427,8 @@ static struct device_node *of_get_regulator(struct device *dev, const char *supp
 }
 
 /* Platform voltage constraint check */
-static int regulator_check_voltage(struct regulator_dev *rdev,
-				   int *min_uV, int *max_uV)
+int regulator_check_voltage(struct regulator_dev *rdev,
+			    int *min_uV, int *max_uV)
 {
 	BUG_ON(*min_uV > *max_uV);
 
@@ -464,9 +460,9 @@ static int regulator_check_states(suspend_state_t state)
 /* Make sure we select a voltage that suits the needs of all
  * regulator consumers
  */
-static int regulator_check_consumers(struct regulator_dev *rdev,
-				     int *min_uV, int *max_uV,
-				     suspend_state_t state)
+int regulator_check_consumers(struct regulator_dev *rdev,
+			      int *min_uV, int *max_uV,
+			      suspend_state_t state)
 {
 	struct regulator *regulator;
 	struct regulator_voltage *voltage;
@@ -577,7 +573,7 @@ static ssize_t regulator_uV_show(struct device *dev,
 	ssize_t ret;
 
 	regulator_lock(rdev);
-	ret = sprintf(buf, "%d\n", _regulator_get_voltage(rdev));
+	ret = sprintf(buf, "%d\n", regulator_get_voltage_rdev(rdev));
 	regulator_unlock(rdev);
 
 	return ret;
@@ -948,7 +944,7 @@ static int drms_uA_update(struct regulator_dev *rdev)
 			rdev_err(rdev, "failed to set load %d\n", current_uA);
 	} else {
 		/* get output voltage */
-		output_uV = _regulator_get_voltage(rdev);
+		output_uV = regulator_get_voltage_rdev(rdev);
 		if (output_uV <= 0) {
 			rdev_err(rdev, "invalid output voltage found\n");
 			return -EINVAL;
@@ -1061,7 +1057,7 @@ static void print_constraints(struct regulator_dev *rdev)
 
 	if (!constraints->min_uV ||
 	    constraints->min_uV != constraints->max_uV) {
-		ret = _regulator_get_voltage(rdev);
+		ret = regulator_get_voltage_rdev(rdev);
 		if (ret > 0)
 			count += scnprintf(buf + count, len - count,
 					   "at %d mV ", ret / 1000);
@@ -1120,7 +1116,7 @@ static int machine_constraints_voltage(struct regulator_dev *rdev,
 	if (rdev->constraints->apply_uV &&
 	    rdev->constraints->min_uV && rdev->constraints->max_uV) {
 		int target_min, target_max;
-		int current_uV = _regulator_get_voltage(rdev);
+		int current_uV = regulator_get_voltage_rdev(rdev);
 
 		if (current_uV == -ENOTRECOVERABLE) {
 			/* This regulator can't be read and must be initialized */
@@ -1130,7 +1126,7 @@ static int machine_constraints_voltage(struct regulator_dev *rdev,
 			_regulator_do_set_voltage(rdev,
 						  rdev->constraints->min_uV,
 						  rdev->constraints->max_uV);
-			current_uV = _regulator_get_voltage(rdev);
+			current_uV = regulator_get_voltage_rdev(rdev);
 		}
 
 		if (current_uV < 0) {
@@ -3072,7 +3068,7 @@ static int _regulator_call_set_voltage(struct regulator_dev *rdev,
 	struct pre_voltage_change_data data;
 	int ret;
 
-	data.old_uV = _regulator_get_voltage(rdev);
+	data.old_uV = regulator_get_voltage_rdev(rdev);
 	data.min_uV = min_uV;
 	data.max_uV = max_uV;
 	ret = _notifier_call_chain(rdev, REGULATOR_EVENT_PRE_VOLTAGE_CHANGE,
@@ -3096,7 +3092,7 @@ static int _regulator_call_set_voltage_sel(struct regulator_dev *rdev,
 	struct pre_voltage_change_data data;
 	int ret;
 
-	data.old_uV = _regulator_get_voltage(rdev);
+	data.old_uV = regulator_get_voltage_rdev(rdev);
 	data.min_uV = uV;
 	data.max_uV = uV;
 	ret = _notifier_call_chain(rdev, REGULATOR_EVENT_PRE_VOLTAGE_CHANGE,
@@ -3149,7 +3145,7 @@ static int _regulator_do_set_voltage(struct regulator_dev *rdev,
 	unsigned int selector;
 	int old_selector = -1;
 	const struct regulator_ops *ops = rdev->desc->ops;
-	int old_uV = _regulator_get_voltage(rdev);
+	int old_uV = regulator_get_voltage_rdev(rdev);
 
 	trace_regulator_set_voltage(rdev_get_name(rdev), min_uV, max_uV);
 
@@ -3176,7 +3172,7 @@ static int _regulator_do_set_voltage(struct regulator_dev *rdev,
 				best_val = ops->list_voltage(rdev,
 							     selector);
 			else
-				best_val = _regulator_get_voltage(rdev);
+				best_val = regulator_get_voltage_rdev(rdev);
 		}
 
 	} else if (ops->set_voltage_sel) {
@@ -3295,7 +3291,7 @@ static int regulator_set_voltage_unlocked(struct regulator *regulator,
 	 * changing the voltage.
 	 */
 	if (!regulator_ops_is_valid(rdev, REGULATOR_CHANGE_VOLTAGE)) {
-		current_uV = _regulator_get_voltage(rdev);
+		current_uV = regulator_get_voltage_rdev(rdev);
 		if (min_uV <= current_uV && current_uV <= max_uV) {
 			voltage->min_uV = min_uV;
 			voltage->max_uV = max_uV;
@@ -3332,8 +3328,8 @@ static int regulator_set_voltage_unlocked(struct regulator *regulator,
 	return ret;
 }
 
-static int regulator_set_voltage_rdev(struct regulator_dev *rdev, int min_uV,
-				      int max_uV, suspend_state_t state)
+int regulator_set_voltage_rdev(struct regulator_dev *rdev, int min_uV,
+			       int max_uV, suspend_state_t state)
 {
 	int best_supply_uV = 0;
 	int supply_change_uV = 0;
@@ -3361,7 +3357,7 @@ static int regulator_set_voltage_rdev(struct regulator_dev *rdev, int min_uV,
 
 		best_supply_uV += rdev->desc->min_dropout_uV;
 
-		current_supply_uV = _regulator_get_voltage(rdev->supply->rdev);
+		current_supply_uV = regulator_get_voltage_rdev(rdev->supply->rdev);
 		if (current_supply_uV < 0) {
 			ret = current_supply_uV;
 			goto out;
@@ -3412,7 +3408,7 @@ static int regulator_limit_voltage_step(struct regulator_dev *rdev,
 		return 1;
 
 	if (*current_uV < 0) {
-		*current_uV = _regulator_get_voltage(rdev);
+		*current_uV = regulator_get_voltage_rdev(rdev);
 
 		if (*current_uV < 0)
 			return *current_uV;
@@ -3517,7 +3513,7 @@ static int regulator_get_optimal_voltage(struct regulator_dev *rdev,
 		if (!_regulator_is_enabled(c_rdevs[i]))
 			continue;
 
-		tmp_act = _regulator_get_voltage(c_rdevs[i]);
+		tmp_act = regulator_get_voltage_rdev(c_rdevs[i]);
 		if (tmp_act < 0)
 			return tmp_act;
 
@@ -3559,7 +3555,7 @@ static int regulator_get_optimal_voltage(struct regulator_dev *rdev,
 	if (n_coupled > 1 && *current_uV == -1) {
 
 		if (_regulator_is_enabled(rdev)) {
-			ret = _regulator_get_voltage(rdev);
+			ret = regulator_get_voltage_rdev(rdev);
 			if (ret < 0)
 				return ret;
 
@@ -3923,7 +3919,7 @@ int regulator_sync_voltage(struct regulator *regulator)
 }
 EXPORT_SYMBOL_GPL(regulator_sync_voltage);
 
-static int _regulator_get_voltage(struct regulator_dev *rdev)
+int regulator_get_voltage_rdev(struct regulator_dev *rdev)
 {
 	int sel, ret;
 	bool bypassed;
@@ -3940,7 +3936,7 @@ static int _regulator_get_voltage(struct regulator_dev *rdev)
 				return -EPROBE_DEFER;
 			}
 
-			return _regulator_get_voltage(rdev->supply->rdev);
+			return regulator_get_voltage_rdev(rdev->supply->rdev);
 		}
 	}
 
@@ -3956,7 +3952,7 @@ static int _regulator_get_voltage(struct regulator_dev *rdev)
 	} else if (rdev->desc->fixed_uV && (rdev->desc->n_voltages == 1)) {
 		ret = rdev->desc->fixed_uV;
 	} else if (rdev->supply) {
-		ret = _regulator_get_voltage(rdev->supply->rdev);
+		ret = regulator_get_voltage_rdev(rdev->supply->rdev);
 	} else {
 		return -EINVAL;
 	}
@@ -3981,7 +3977,7 @@ int regulator_get_voltage(struct regulator *regulator)
 	int ret;
 
 	regulator_lock_dependent(regulator->rdev, &ww_ctx);
-	ret = _regulator_get_voltage(regulator->rdev);
+	ret = regulator_get_voltage_rdev(regulator->rdev);
 	regulator_unlock_dependent(regulator->rdev, &ww_ctx);
 
 	return ret;
@@ -5377,7 +5373,7 @@ static void regulator_summary_show_subtree(struct seq_file *s,
 		   rdev->use_count, rdev->open_count, rdev->bypass_count,
 		   regulator_opmode_to_str(opmode));
 
-	seq_printf(s, "%5dmV ", _regulator_get_voltage(rdev) / 1000);
+	seq_printf(s, "%5dmV ", regulator_get_voltage_rdev(rdev) / 1000);
 	seq_printf(s, "%5dmA ",
 		   _regulator_get_current_limit_unlocked(rdev) / 1000);
 

commit d8ca7d184b33af7913c244900df77c6cad6a5590
Author: Dmitry Osipenko <digetx@gmail.com>
Date:   Mon Jun 24 00:08:31 2019 +0300

    regulator: core: Introduce API for regulators coupling customization
    
    Right now regulator core supports only one type of regulators coupling,
    the "voltage max-spread" which keeps voltages of coupled regulators in a
    given range from each other. A more sophisticated coupling may be required
    in practice, one example is the NVIDIA Tegra SoCs which besides the
    max-spreading have other restrictions that must be adhered. Introduce API
    that allow platforms to provide their own customized coupling algorithms.
    
    Signed-off-by: Dmitry Osipenko <digetx@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 955a0a15b9cb..12c870f790f5 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -28,6 +28,7 @@
 #include <linux/regmap.h>
 #include <linux/regulator/of_regulator.h>
 #include <linux/regulator/consumer.h>
+#include <linux/regulator/coupler.h>
 #include <linux/regulator/driver.h>
 #include <linux/regulator/machine.h>
 #include <linux/module.h>
@@ -55,6 +56,7 @@ static DEFINE_MUTEX(regulator_list_mutex);
 static LIST_HEAD(regulator_map_list);
 static LIST_HEAD(regulator_ena_gpio_list);
 static LIST_HEAD(regulator_supply_alias_list);
+static LIST_HEAD(regulator_coupler_list);
 static bool has_full_constraints;
 
 static struct dentry *debugfs_root;
@@ -3439,11 +3441,10 @@ static int regulator_get_optimal_voltage(struct regulator_dev *rdev,
 	struct coupling_desc *c_desc = &rdev->coupling_desc;
 	struct regulator_dev **c_rdevs = c_desc->coupled_rdevs;
 	struct regulation_constraints *constraints = rdev->constraints;
-	int max_spread = constraints->max_spread;
 	int desired_min_uV = 0, desired_max_uV = INT_MAX;
 	int max_current_uV = 0, min_current_uV = INT_MAX;
 	int highest_min_uV = 0, target_uV, possible_uV;
-	int i, ret;
+	int i, ret, max_spread;
 	bool done;
 
 	*current_uV = -1;
@@ -3497,6 +3498,8 @@ static int regulator_get_optimal_voltage(struct regulator_dev *rdev,
 		}
 	}
 
+	max_spread = constraints->max_spread[0];
+
 	/*
 	 * Let target_uV be equal to the desired one if possible.
 	 * If not, set it to minimum voltage, allowed by other coupled
@@ -3578,9 +3581,11 @@ static int regulator_balance_voltage(struct regulator_dev *rdev,
 	struct regulator_dev **c_rdevs;
 	struct regulator_dev *best_rdev;
 	struct coupling_desc *c_desc = &rdev->coupling_desc;
+	struct regulator_coupler *coupler = c_desc->coupler;
 	int i, ret, n_coupled, best_min_uV, best_max_uV, best_c_rdev;
-	bool best_c_rdev_done, c_rdev_done[MAX_COUPLED];
 	unsigned int delta, best_delta;
+	unsigned long c_rdev_done = 0;
+	bool best_c_rdev_done;
 
 	c_rdevs = c_desc->coupled_rdevs;
 	n_coupled = c_desc->n_coupled;
@@ -3597,8 +3602,9 @@ static int regulator_balance_voltage(struct regulator_dev *rdev,
 		return -EPERM;
 	}
 
-	for (i = 0; i < n_coupled; i++)
-		c_rdev_done[i] = false;
+	/* Invoke custom balancer for customized couplers */
+	if (coupler && coupler->balance_voltage)
+		return coupler->balance_voltage(coupler, rdev, state);
 
 	/*
 	 * Find the best possible voltage change on each loop. Leave the loop
@@ -3625,7 +3631,7 @@ static int regulator_balance_voltage(struct regulator_dev *rdev,
 			 */
 			int optimal_uV = 0, optimal_max_uV = 0, current_uV = 0;
 
-			if (c_rdev_done[i])
+			if (test_bit(i, &c_rdev_done))
 				continue;
 
 			ret = regulator_get_optimal_voltage(c_rdevs[i],
@@ -3660,7 +3666,8 @@ static int regulator_balance_voltage(struct regulator_dev *rdev,
 		if (ret < 0)
 			goto out;
 
-		c_rdev_done[best_c_rdev] = best_c_rdev_done;
+		if (best_c_rdev_done)
+			set_bit(best_c_rdev, &c_rdev_done);
 
 	} while (n_coupled > 1);
 
@@ -4712,8 +4719,60 @@ static int regulator_register_resolve_supply(struct device *dev, void *data)
 	return 0;
 }
 
+int regulator_coupler_register(struct regulator_coupler *coupler)
+{
+	mutex_lock(&regulator_list_mutex);
+	list_add_tail(&coupler->list, &regulator_coupler_list);
+	mutex_unlock(&regulator_list_mutex);
+
+	return 0;
+}
+
+static struct regulator_coupler *
+regulator_find_coupler(struct regulator_dev *rdev)
+{
+	struct regulator_coupler *coupler;
+	int err;
+
+	/*
+	 * Note that regulators are appended to the list and the generic
+	 * coupler is registered first, hence it will be attached at last
+	 * if nobody cared.
+	 */
+	list_for_each_entry_reverse(coupler, &regulator_coupler_list, list) {
+		err = coupler->attach_regulator(coupler, rdev);
+		if (!err) {
+			if (!coupler->balance_voltage &&
+			    rdev->coupling_desc.n_coupled > 2)
+				goto err_unsupported;
+
+			return coupler;
+		}
+
+		if (err < 0)
+			return ERR_PTR(err);
+
+		if (err == 1)
+			continue;
+
+		break;
+	}
+
+	return ERR_PTR(-EINVAL);
+
+err_unsupported:
+	if (coupler->detach_regulator)
+		coupler->detach_regulator(coupler, rdev);
+
+	rdev_err(rdev,
+		"Voltage balancing for multiple regulator couples is unimplemented\n");
+
+	return ERR_PTR(-EPERM);
+}
+
 static void regulator_resolve_coupling(struct regulator_dev *rdev)
 {
+	struct regulator_coupler *coupler = rdev->coupling_desc.coupler;
 	struct coupling_desc *c_desc = &rdev->coupling_desc;
 	int n_coupled = c_desc->n_coupled;
 	struct regulator_dev *c_rdev;
@@ -4729,6 +4788,12 @@ static void regulator_resolve_coupling(struct regulator_dev *rdev)
 		if (!c_rdev)
 			continue;
 
+		if (c_rdev->coupling_desc.coupler != coupler) {
+			rdev_err(rdev, "coupler mismatch with %s\n",
+				 rdev_get_name(c_rdev));
+			return;
+		}
+
 		regulator_lock(c_rdev);
 
 		c_desc->coupled_rdevs[i] = c_rdev;
@@ -4742,10 +4807,12 @@ static void regulator_resolve_coupling(struct regulator_dev *rdev)
 
 static void regulator_remove_coupling(struct regulator_dev *rdev)
 {
+	struct regulator_coupler *coupler = rdev->coupling_desc.coupler;
 	struct coupling_desc *__c_desc, *c_desc = &rdev->coupling_desc;
 	struct regulator_dev *__c_rdev, *c_rdev;
 	unsigned int __n_coupled, n_coupled;
 	int i, k;
+	int err;
 
 	n_coupled = c_desc->n_coupled;
 
@@ -4775,21 +4842,33 @@ static void regulator_remove_coupling(struct regulator_dev *rdev)
 		c_desc->coupled_rdevs[i] = NULL;
 		c_desc->n_resolved--;
 	}
+
+	if (coupler && coupler->detach_regulator) {
+		err = coupler->detach_regulator(coupler, rdev);
+		if (err)
+			rdev_err(rdev, "failed to detach from coupler: %d\n",
+				 err);
+	}
+
+	kfree(rdev->coupling_desc.coupled_rdevs);
+	rdev->coupling_desc.coupled_rdevs = NULL;
 }
 
 static int regulator_init_coupling(struct regulator_dev *rdev)
 {
-	int n_phandles;
+	int err, n_phandles;
+	size_t alloc_size;
 
 	if (!IS_ENABLED(CONFIG_OF))
 		n_phandles = 0;
 	else
 		n_phandles = of_get_n_coupled(rdev);
 
-	if (n_phandles + 1 > MAX_COUPLED) {
-		rdev_err(rdev, "too many regulators coupled\n");
-		return -EPERM;
-	}
+	alloc_size = sizeof(*rdev) * (n_phandles + 1);
+
+	rdev->coupling_desc.coupled_rdevs = kzalloc(alloc_size, GFP_KERNEL);
+	if (!rdev->coupling_desc.coupled_rdevs)
+		return -ENOMEM;
 
 	/*
 	 * Every regulator should always have coupling descriptor filled with
@@ -4803,23 +4882,35 @@ static int regulator_init_coupling(struct regulator_dev *rdev)
 	if (n_phandles == 0)
 		return 0;
 
-	/* regulator, which can't change its voltage, can't be coupled */
-	if (!regulator_ops_is_valid(rdev, REGULATOR_CHANGE_VOLTAGE)) {
-		rdev_err(rdev, "voltage operation not allowed\n");
+	if (!of_check_coupling_data(rdev))
 		return -EPERM;
-	}
 
-	if (rdev->constraints->max_spread <= 0) {
-		rdev_err(rdev, "wrong max_spread value\n");
-		return -EPERM;
+	rdev->coupling_desc.coupler = regulator_find_coupler(rdev);
+	if (IS_ERR(rdev->coupling_desc.coupler)) {
+		err = PTR_ERR(rdev->coupling_desc.coupler);
+		rdev_err(rdev, "failed to get coupler: %d\n", err);
+		return err;
 	}
 
-	if (!of_check_coupling_data(rdev))
+	return 0;
+}
+
+static int generic_coupler_attach(struct regulator_coupler *coupler,
+				  struct regulator_dev *rdev)
+{
+	if (rdev->coupling_desc.n_coupled > 2) {
+		rdev_err(rdev,
+			 "Voltage balancing for multiple regulator couples is unimplemented\n");
 		return -EPERM;
+	}
 
 	return 0;
 }
 
+static struct regulator_coupler generic_regulator_coupler = {
+	.attach_regulator = generic_coupler_attach,
+};
+
 /**
  * regulator_register - register regulator
  * @regulator_desc: regulator to register
@@ -4981,7 +5072,9 @@ regulator_register(const struct regulator_desc *regulator_desc,
 	if (ret < 0)
 		goto wash;
 
+	mutex_lock(&regulator_list_mutex);
 	ret = regulator_init_coupling(rdev);
+	mutex_unlock(&regulator_list_mutex);
 	if (ret < 0)
 		goto wash;
 
@@ -5030,6 +5123,7 @@ regulator_register(const struct regulator_desc *regulator_desc,
 unset_supplies:
 	mutex_lock(&regulator_list_mutex);
 	unset_regulator_supplies(rdev);
+	regulator_remove_coupling(rdev);
 	mutex_unlock(&regulator_list_mutex);
 wash:
 	kfree(rdev->constraints);
@@ -5485,6 +5579,8 @@ static int __init regulator_init(void)
 #endif
 	regulator_dummy_init();
 
+	regulator_coupler_register(&generic_regulator_coupler);
+
 	return ret;
 }
 

commit f2c6203fdd1197d8254073a8f3f3372b0d3d9e6b
Author: Mark Brown <broonie@kernel.org>
Date:   Mon Jun 17 18:16:52 2019 +0100

    regulator: core: Make entire header comment C++ style
    
    Makes things look more consistent.
    
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 85f61e5dc312..9d3ed13b7f12 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1,12 +1,11 @@
 // SPDX-License-Identifier: GPL-2.0-or-later
-/*
- * core.c  --  Voltage/Current Regulator framework.
- *
- * Copyright 2007, 2008 Wolfson Microelectronics PLC.
- * Copyright 2008 SlimLogic Ltd.
- *
- * Author: Liam Girdwood <lrg@slimlogic.co.uk>
- */
+//
+// core.c  --  Voltage/Current Regulator framework.
+//
+// Copyright 2007, 2008 Wolfson Microelectronics PLC.
+// Copyright 2008 SlimLogic Ltd.
+//
+// Author: Liam Girdwood <lrg@slimlogic.co.uk>
 
 #include <linux/kernel.h>
 #include <linux/init.h>

commit e1d700f7c94e755106749411706a38e39a93404b
Merge: ba576a6232dc d1fdb6d8f6a4
Author: Mark Brown <broonie@kernel.org>
Date:   Tue Jun 18 19:12:47 2019 +0100

    Merge tag 'v5.2-rc4' into regulator-5.3
    
    Linux 5.2-rc4

commit 458f69ef36656dc74679667380422dd8063eabfb
Author: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
Date:   Wed Jun 12 14:53:00 2019 -0300

    docs: timers: convert docs to ReST and rename to *.rst
    
    The conversion here is really trivial: just a bunch of title
    markups and very few puntual changes is enough to make it to
    be parsed by Sphinx and generate a nice html.
    
    The conversion is actually:
      - add blank lines and identation in order to identify paragraphs;
      - fix tables markups;
      - add some lists markups;
      - mark literal blocks;
      - adjust title markups.
    
    At its new index.rst, let's add a :orphan: while this is not linked to
    the main index.rst file, in order to avoid build warnings.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
    Acked-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Jonathan Corbet <corbet@lwn.net>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index c894cf0d8a28..c5d8996d5165 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2304,7 +2304,7 @@ static int regulator_ena_gpio_ctrl(struct regulator_dev *rdev, bool enable)
  *
  * Delay for the requested amount of time as per the guidelines in:
  *
- *     Documentation/timers/timers-howto.txt
+ *     Documentation/timers/timers-howto.rst
  *
  * The assumption here is that regulators will never be enabled in
  * atomic context and therefore sleeping functions can be used.

commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 955a0a15b9cb..c894cf0d8a28 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * core.c  --  Voltage/Current Regulator framework.
  *
@@ -5,12 +6,6 @@
  * Copyright 2008 SlimLogic Ltd.
  *
  * Author: Liam Girdwood <lrg@slimlogic.co.uk>
- *
- *  This program is free software; you can redistribute  it and/or modify it
- *  under  the terms of  the GNU General  Public License as published by the
- *  Free Software Foundation;  either version 2 of the  License, or (at your
- *  option) any later version.
- *
  */
 
 #include <linux/kernel.h>

commit 68ce3a4461726ebd3acf9d94841a46386402a058
Author: Axel Lin <axel.lin@ingics.com>
Date:   Sat May 4 11:33:36 2019 +0800

    regulator: core: Slightly improve readability of _regulator_get_enable_time
    
    The logic is equivalent, but it looks more straightforward this way:
    If rdev->desc->ops->enable_time is set, call it.
    Otherwise fallback to return rdev->desc->enable_time.
    
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 955a0a15b9cb..bf4cdbcf0653 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1650,9 +1650,9 @@ static int _regulator_get_enable_time(struct regulator_dev *rdev)
 {
 	if (rdev->constraints && rdev->constraints->enable_time)
 		return rdev->constraints->enable_time;
-	if (!rdev->desc->ops->enable_time)
-		return rdev->desc->enable_time;
-	return rdev->desc->ops->enable_time(rdev);
+	if (rdev->desc->ops->enable_time)
+		return rdev->desc->ops->enable_time(rdev);
+	return rdev->desc->enable_time;
 }
 
 static struct regulator_supply_alias *regulator_find_supply_alias(

commit e2a23affe6a6a15111ae56edd7e4f3c9673ef201
Merge: c7b5128f72ef 498209445124
Author: Mark Brown <broonie@kernel.org>
Date:   Mon May 6 22:52:14 2019 +0900

    Merge branch 'regulator-5.2' into regulator-next

commit 498209445124920b365ef43aac93d6f1acbaa1b7
Author: Jorge Ramirez-Ortiz <jorge.ramirez-ortiz@linaro.org>
Date:   Mon Apr 22 19:28:24 2019 +0200

    regulator: core: simplify return value on suported_voltage
    
    All the current clients of this API  assume that 0 corresponds
    to a failure and non-zero to a pass therefore ignoring the need to
    handle a negative error code.
    
    This commit modifies the API to follow that standard since returning a
    negative (EINVAL) doesn't seem to provide enough value to justify
    the need to handle it.
    
    Signed-off-by: Jorge Ramirez-Ortiz <jorge.ramirez-ortiz@linaro.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 08ccabe07fe3..af8b4dadb09b 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -3002,7 +3002,7 @@ EXPORT_SYMBOL_GPL(regulator_get_linear_step);
  * @min_uV: Minimum required voltage in uV.
  * @max_uV: Maximum required voltage in uV.
  *
- * Returns a boolean or a negative error code.
+ * Returns a boolean.
  */
 int regulator_is_supported_voltage(struct regulator *regulator,
 				   int min_uV, int max_uV)
@@ -3026,7 +3026,7 @@ int regulator_is_supported_voltage(struct regulator *regulator,
 
 	ret = regulator_count_voltages(regulator);
 	if (ret < 0)
-		return ret;
+		return 0;
 	voltages = ret;
 
 	for (i = 0; i < voltages; i++) {

commit b9816363c0e82f4cd8f9be8153fbc5b81b22911c
Author: Jorge Ramirez-Ortiz <jorge.ramirez-ortiz@linaro.org>
Date:   Wed Apr 17 21:24:43 2019 +0200

    regulator: core: do not report EPROBE_DEFER as error but as debug
    
    Temporary failures to get a regulator (EPROBE_DEFER) should be logged
    as debug information instead of errors.
    
    Signed-off-by: Jorge Ramirez-Ortiz <jorge.ramirez-ortiz@linaro.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 5a9ebcf7fe7a..08ccabe07fe3 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -4345,8 +4345,6 @@ int regulator_bulk_get(struct device *dev, int num_consumers,
 						      consumers[i].supply);
 		if (IS_ERR(consumers[i].consumer)) {
 			ret = PTR_ERR(consumers[i].consumer);
-			dev_err(dev, "Failed to get supply '%s': %d\n",
-				consumers[i].supply, ret);
 			consumers[i].consumer = NULL;
 			goto err;
 		}
@@ -4355,6 +4353,13 @@ int regulator_bulk_get(struct device *dev, int num_consumers,
 	return 0;
 
 err:
+	if (ret != -EPROBE_DEFER)
+		dev_err(dev, "Failed to get supply '%s': %d\n",
+			consumers[i].supply, ret);
+	else
+		dev_dbg(dev, "Failed to get supply '%s', deferring\n",
+			consumers[i].supply);
+
 	while (--i >= 0)
 		regulator_put(consumers[i].consumer);
 

commit 78927aa40bc82f32de07323ddc1c9de07ac68180
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Sat Apr 20 13:34:30 2019 +0200

    regulator: core: Actually put the gpiod after use
    
    I went to great lengths to hand over the management of the GPIO
    descriptors to the regulator core, and some stray rebased
    oneliner in the old patch must have been assuming the devices
    were still doing devres management of it.
    
    We handed the management over to the regulator core, so of
    course the regulator core shall issue gpiod_put() when done.
    
    Sorry for the descriptor leak.
    
    Fixes: 541d052d7215 ("regulator: core: Only support passing enable GPIO descriptors")
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 8573dd0871fd..35a7d020afec 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2256,6 +2256,7 @@ static void regulator_ena_gpio_free(struct regulator_dev *rdev)
 		if (pin->gpiod == rdev->ena_pin->gpiod) {
 			if (pin->request_count <= 1) {
 				pin->request_count = 0;
+				gpiod_put(pin->gpiod);
 				list_del(&pin->list);
 				kfree(pin);
 				rdev->ena_pin = NULL;

commit 063773011d33bb36588a90385aa9eb75d13c6d80
Author: Charles Keepax <ckeepax@opensource.cirrus.com>
Date:   Thu Apr 4 16:32:18 2019 +0100

    regulator: core: Avoid potential deadlock on regulator_unregister
    
    Lockdep reports the following issue on my setup:
    
    Possible unsafe locking scenario:
    
    CPU0                    CPU1
    ----                    ----
    lock((work_completion)(&(&rdev->disable_work)->work));
                            lock(regulator_list_mutex);
                            lock((work_completion)(&(&rdev->disable_work)->work));
    lock(regulator_list_mutex);
    
    The problem is that regulator_unregister takes the
    regulator_list_mutex and then calls flush_work on disable_work. But
    regulator_disable_work calls regulator_lock_dependent which will
    also take the regulator_list_mutex. Resulting in a deadlock if the
    flush_work call actually needs to flush the work.
    
    Fix this issue by moving the flush_work outside of the
    regulator_list_mutex. The list mutex is not used to guard the point at
    which the delayed work is queued, so its use adds no additional safety.
    
    Fixes: f8702f9e4aa7 ("regulator: core: Use ww_mutex for regulators locking")
    Signed-off-by: Charles Keepax <ckeepax@opensource.cirrus.com>
    Reviewed-by: Dmitry Osipenko <digetx@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 968dcd9d7a07..8573dd0871fd 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -5061,10 +5061,11 @@ void regulator_unregister(struct regulator_dev *rdev)
 		regulator_put(rdev->supply);
 	}
 
+	flush_work(&rdev->disable_work.work);
+
 	mutex_lock(&regulator_list_mutex);
 
 	debugfs_remove_recursive(rdev->debugfs);
-	flush_work(&rdev->disable_work.work);
 	WARN_ON(rdev->open_count);
 	regulator_remove_coupling(rdev);
 	unset_regulator_supplies(rdev);

commit 70b464918e5331e488058870fcc6821d54c4e541
Author: Steve Twiss <stwiss.opensource@diasemi.com>
Date:   Mon Mar 18 16:17:57 2019 +0000

    regulator: core: fix error path for regulator_set_voltage_unlocked
    
    During several error paths in the function
    regulator_set_voltage_unlocked() the value of 'ret' can take on negative
    error values. However, in calls that go through the 'goto out' statement,
    this return value is lost and return 0 is used instead, indicating a
    'pass'.
    
    There are several cases where this function should legitimately return a
    fail instead of a pass: one such case includes constraints check during
    voltage selection in the call to regulator_check_voltage(), which can
    have -EINVAL for the case when an unsupported voltage is incorrectly
    requested. In that case, -22 is expected as the return value, not 0.
    
    Fixes: 9243a195be7a ("regulator: core: Change voltage setting path")
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Steve Twiss <stwiss.opensource@diasemi.com>
    Reviewed-by: Dmitry Osipenko <digetx@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 68473d0cc57e..968dcd9d7a07 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -3322,15 +3322,12 @@ static int regulator_set_voltage_unlocked(struct regulator *regulator,
 
 	/* for not coupled regulators this will just set the voltage */
 	ret = regulator_balance_voltage(rdev, state);
-	if (ret < 0)
-		goto out2;
+	if (ret < 0) {
+		voltage->min_uV = old_min_uV;
+		voltage->max_uV = old_max_uV;
+	}
 
 out:
-	return 0;
-out2:
-	voltage->min_uV = old_min_uV;
-	voltage->max_uV = old_max_uV;
-
 	return ret;
 }
 

commit a48f127519d916b9576c213a9ca6b79e7f926d2d
Author: Mark Brown <broonie@kernel.org>
Date:   Mon Feb 18 20:29:14 2019 +0100

    regulator: core: Fix application of "drop lockdep annotation in drms_uA_update()"
    
    [The original commit was sent against -next but needed to be sent as a
    bugfix, however -next had some additional changes which needed to be
    reverted.  Now everything is all in one branch applying the rest of the
    changes to fix up the merge issue -- broonie]
    
    commit e5e21f70bfd3 ("regulator: core: Take lock before applying system
    load") took the regulator lock before calling drms_uA_update() in order
    to silence a lockdep warning during regulator_register().
    
    However, we are not supposed to need locks at this point as the regulator
    is in the process of being registered, so there should be no possibility
    of concurrent access.
    
    Instead, remove the unnecessary locking and simply drop the lockdep
    annotation, since it is no longer valid.
    
    Fixes: e5e21f70bfd3 ("regulator: core: Take lock before applying system load")
    Signed-off-by: Niklas Cassel <niklas.cassel@linaro.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 68473d0cc57e..5a9ebcf7fe7a 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1339,9 +1339,7 @@ static int set_machine_constraints(struct regulator_dev *rdev,
 		 * We'll only apply the initial system load if an
 		 * initial mode wasn't specified.
 		 */
-		regulator_lock(rdev);
 		drms_uA_update(rdev);
-		regulator_unlock(rdev);
 	}
 
 	if ((rdev->constraints->ramp_delay || rdev->constraints->ramp_disable)

commit 74a569ee4c452e2a1c997f034837ddae500734ca
Author: Marc Gonzalez <marc.w.gonzalez@free.fr>
Date:   Thu Feb 21 12:55:22 2019 +0100

    regulator: core: Log forbidden DRMS operation
    
    When REGULATOR_CHANGE_DRMS is not set, drms_uA_update is a no-op.
    It used to print a debug message, which was dropped in commit
    8a34e979f684 ("regulator: refactor valid_ops_mask checking code")
    
    Let's bring the debug message back, because it helps find missing
    regulator-allow-set-load properties.
    
    Signed-off-by: Marc Gonzalez <marc.w.gonzalez@free.fr>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 9cf09666616f..68473d0cc57e 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -918,8 +918,10 @@ static int drms_uA_update(struct regulator_dev *rdev)
 	 * first check to see if we can set modes at all, otherwise just
 	 * tell the consumer everything is OK.
 	 */
-	if (!regulator_ops_is_valid(rdev, REGULATOR_CHANGE_DRMS))
+	if (!regulator_ops_is_valid(rdev, REGULATOR_CHANGE_DRMS)) {
+		rdev_dbg(rdev, "DRMS operation not allowed\n");
 		return 0;
+	}
 
 	if (!rdev->desc->ops->get_optimum_mode &&
 	    !rdev->desc->ops->set_load)

commit 16646d8d3d66e0a89528f72a28a23023b054417d
Merge: e6fff62ab8ac 48593a99a1f6
Author: Mark Brown <broonie@kernel.org>
Date:   Tue Feb 19 11:06:41 2019 +0000

    Merge branch 'regulator-5.0' into regulator-5.1 stpmic1 const/range

commit c407438f8795e6b403674b51fbdf5b3d66f811a4
Author: Niklas Cassel <niklas.cassel@linaro.org>
Date:   Mon Feb 18 20:29:14 2019 +0100

    regulator: core: Drop lockdep annotation in drms_uA_update()
    
    commit e5e21f70bfd3 ("regulator: core: Take lock before applying system
    load") took the regulator lock before calling drms_uA_update() in order
    to silence a lockdep warning during regulator_register().
    
    However, we are not supposed to need locks at this point as the regulator
    is in the process of being registered, so there should be no possibility
    of concurrent access.
    
    Instead, remove the unnecessary locking and simply drop the lockdep
    annotation, since it is no longer valid.
    
    Fixes: e5e21f70bfd3 ("regulator: core: Take lock before applying system load")
    Signed-off-by: Niklas Cassel <niklas.cassel@linaro.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index defde9125a50..3e9aa0d0b471 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -914,8 +914,6 @@ static int drms_uA_update(struct regulator_dev *rdev)
 	int current_uA = 0, output_uV, input_uV, err;
 	unsigned int mode;
 
-	lockdep_assert_held_once(&rdev->mutex.base);
-
 	/*
 	 * first check to see if we can set modes at all, otherwise just
 	 * tell the consumer everything is OK.

commit 075ddd75680f3556e18f74198622529fba8f2a00
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Mon Feb 18 15:08:38 2019 +0900

    regulator: core: remove unused rdev_get_supply()
    
    This is a remnant of commit 70a7fb80e85a ("regulator: core: Fix nested
    locking of supplies").
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 4fb475a2e4f2..defde9125a50 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -143,14 +143,6 @@ static bool regulator_ops_is_valid(struct regulator_dev *rdev, int ops)
 	return false;
 }
 
-static inline struct regulator_dev *rdev_get_supply(struct regulator_dev *rdev)
-{
-	if (rdev && rdev->supply)
-		return rdev->supply->rdev;
-
-	return NULL;
-}
-
 /**
  * regulator_lock_nested - lock a single regulator
  * @rdev:		regulator source

commit e5e21f70bfd3a201e627b48aed82793d1bcd6f78
Author: Niklas Cassel <niklas.cassel@linaro.org>
Date:   Fri Feb 15 11:55:33 2019 +0100

    regulator: core: Take lock before applying system load
    
    Take the regulator lock before applying system load.
    
    Fixes the following lockdep splat:
    
    [    5.583581] WARNING: CPU: 1 PID: 16 at drivers/regulator/core.c:925 drms_uA_update+0x114/0x360
    [    5.588467] Modules linked in:
    [    5.596833] CPU: 1 PID: 16 Comm: kworker/1:0 Not tainted 5.0.0-rc6-next-20190213-00002-g0fce66ab480f #18
    [    5.599933] Hardware name: Qualcomm Technologies, Inc. APQ 8016 SBC (DT)
    [    5.609544] Workqueue: events qcom_channel_state_worker
    [    5.616209] pstate: 60000005 (nZCv daif -PAN -UAO)
    [    5.621152] pc : drms_uA_update+0x114/0x360
    [    5.626006] lr : drms_uA_update+0x110/0x360
    [    5.630084] sp : ffff0000124b3490
    [    5.634242] x29: ffff0000124b3490 x28: ffff800005326e00
    [    5.637735] x27: ffff0000124b35f8 x26: 000000000032bc48
    [    5.643117] x25: ffff800004c7e800 x24: ffff800004c6d500
    [    5.648411] x23: ffff800004c38a80 x22: 00000000000000d1
    [    5.653706] x21: 00000000001ab3f0 x20: ffff800004c7e800
    [    5.659001] x19: ffff0000114c3000 x18: ffffffffffffffff
    [    5.664297] x17: 0000000000000000 x16: 0000000000000000
    [    5.669592] x15: ffff0000114c3808 x14: 0720072007200720
    [    5.674888] x13: 00000000199c9b28 x12: ffff80002bcccc40
    [    5.680183] x11: ffff000012286000 x10: ffff0000114c3808
    [    5.685477] x9 : 0720072007200720 x8 : ffff000010e9e808
    [    5.690772] x7 : ffff0000106da568 x6 : 0000000000000000
    [    5.696067] x5 : 0000000000000000 x4 : 0000000000000000
    [    5.701362] x3 : 0000000000000004 x2 : 0000000000000000
    [    5.706658] x1 : 0000000000000000 x0 : 0000000000000000
    [    5.711952] Call trace:
    [    5.717223]  drms_uA_update+0x114/0x360
    [    5.719405]  regulator_register+0xb30/0x1140
    [    5.723230]  devm_regulator_register+0x4c/0xa8
    [    5.727745]  rpm_reg_probe+0xfc/0x1b0
    [    5.731992]  platform_drv_probe+0x50/0xa0
    [    5.735727]  really_probe+0x20c/0x2b8
    [    5.739718]  driver_probe_device+0x58/0x100
    [    5.743368]  __device_attach_driver+0x90/0xd0
    [    5.747363]  bus_for_each_drv+0x64/0xc8
    [    5.751870]  __device_attach+0xd8/0x138
    [    5.755516]  device_initial_probe+0x10/0x18
    [    5.759341]  bus_probe_device+0x98/0xa0
    [    5.763502]  device_add+0x3d0/0x640
    [    5.767319]  of_device_add+0x48/0x58
    [    5.770793]  of_platform_device_create_pdata+0xb0/0x128
    [    5.774629]  of_platform_bus_create+0x174/0x370
    [    5.779569]  of_platform_populate+0x78/0xe0
    [    5.784082]  qcom_smd_rpm_probe+0x80/0xa0
    [    5.788245]  rpmsg_dev_probe+0x114/0x1a0
    [    5.792411]  really_probe+0x20c/0x2b8
    [    5.796401]  driver_probe_device+0x58/0x100
    [    5.799964]  __device_attach_driver+0x90/0xd0
    [    5.803960]  bus_for_each_drv+0x64/0xc8
    [    5.808468]  __device_attach+0xd8/0x138
    [    5.812115]  device_initial_probe+0x10/0x18
    [    5.815936]  bus_probe_device+0x98/0xa0
    [    5.820099]  device_add+0x3d0/0x640
    [    5.823916]  device_register+0x1c/0x28
    [    5.827391]  rpmsg_register_device+0x4c/0x90
    [    5.831216]  qcom_channel_state_worker+0x170/0x298
    [    5.835651]  process_one_work+0x294/0x6e8
    [    5.840241]  worker_thread+0x40/0x450
    [    5.844318]  kthread+0x11c/0x120
    [    5.847961]  ret_from_fork+0x10/0x18
    [    5.851260] irq event stamp: 9090
    [    5.854820] hardirqs last  enabled at (9089): [<ffff000010160798>] console_unlock+0x3e0/0x5b0
    [    5.858086] hardirqs last disabled at (9090): [<ffff0000100817cc>] do_debug_exception+0x104/0x140
    [    5.866596] softirqs last  enabled at (9086): [<ffff000010082024>] __do_softirq+0x474/0x574
    [    5.875446] softirqs last disabled at (9079): [<ffff0000100f2254>] irq_exit+0x13c/0x148
    [    5.883598] ---[ end trace 6984ef7f081afa21 ]---
    
    Fixes: fa94e48e13a1 ("regulator: core: Apply system load even if no consumer loads")
    Signed-off-by: Niklas Cassel <niklas.cassel@linaro.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 2994ee023b40..19b35d9f3a97 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1349,7 +1349,9 @@ static int set_machine_constraints(struct regulator_dev *rdev,
 		 * We'll only apply the initial system load if an
 		 * initial mode wasn't specified.
 		 */
+		regulator_lock(rdev);
 		drms_uA_update(rdev);
+		regulator_unlock(rdev);
 	}
 
 	if ((rdev->constraints->ramp_delay || rdev->constraints->ramp_disable)

commit 82874ba4c6455ca8a90a8fe59834baa4cd4a1e50
Author: Guennadi Liakhovetski <guennadi.liakhovetski@linux.intel.com>
Date:   Fri Feb 8 08:41:53 2019 +0100

    regulator: fix device unlinking
    
    Device links are refcounted, device_link_remove() has to be called as
    many times as device_link_add().
    
    Signed-off-by: Guennadi Liakhovetski <guennadi.liakhovetski@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index b9d7b45c7295..2994ee023b40 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2058,15 +2058,7 @@ static void _regulator_put(struct regulator *regulator)
 	debugfs_remove_recursive(regulator->debugfs);
 
 	if (regulator->dev) {
-		int count = 0;
-		struct regulator *r;
-
-		list_for_each_entry(r, &rdev->consumer_list, list)
-			if (r->dev == regulator->dev)
-				count++;
-
-		if (count == 1)
-			device_link_remove(regulator->dev, &rdev->dev);
+		device_link_remove(regulator->dev, &rdev->dev);
 
 		/* remove any sysfs entries */
 		sysfs_remove_link(&rdev->dev.kobj, regulator->supply_name);

commit 541d052d721506549774ab780a2709e4ff8ca79b
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Jan 29 11:31:56 2019 +0100

    regulator: core: Only support passing enable GPIO descriptors
    
    Now that we changed all providers to pass descriptors into the core
    for enable GPIOs instead of a global GPIO number, delete the support
    for passing GPIO numbers in, and we get a cleanup and size reduction
    in the core, and from a GPIO point of view we use the modern, cleaner
    interface.
    
    Tested-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 1778c5d1b2d0..4fb475a2e4f2 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -23,7 +23,6 @@
 #include <linux/mutex.h>
 #include <linux/suspend.h>
 #include <linux/delay.h>
-#include <linux/gpio.h>
 #include <linux/gpio/consumer.h>
 #include <linux/of.h>
 #include <linux/regmap.h>
@@ -2236,35 +2235,19 @@ static int regulator_ena_gpio_request(struct regulator_dev *rdev,
 {
 	struct regulator_enable_gpio *pin;
 	struct gpio_desc *gpiod;
-	int ret;
 
-	if (config->ena_gpiod)
-		gpiod = config->ena_gpiod;
-	else
-		gpiod = gpio_to_desc(config->ena_gpio);
+	gpiod = config->ena_gpiod;
 
 	list_for_each_entry(pin, &regulator_ena_gpio_list, list) {
 		if (pin->gpiod == gpiod) {
-			rdev_dbg(rdev, "GPIO %d is already used\n",
-				config->ena_gpio);
+			rdev_dbg(rdev, "GPIO is already used\n");
 			goto update_ena_gpio_to_rdev;
 		}
 	}
 
-	if (!config->ena_gpiod) {
-		ret = gpio_request_one(config->ena_gpio,
-				       GPIOF_DIR_OUT | config->ena_gpio_flags,
-				       rdev_get_name(rdev));
-		if (ret)
-			return ret;
-	}
-
 	pin = kzalloc(sizeof(struct regulator_enable_gpio), GFP_KERNEL);
-	if (pin == NULL) {
-		if (!config->ena_gpiod)
-			gpio_free(config->ena_gpio);
+	if (pin == NULL)
 		return -ENOMEM;
-	}
 
 	pin->gpiod = gpiod;
 	list_add(&pin->list, &regulator_ena_gpio_list);
@@ -2287,7 +2270,6 @@ static void regulator_ena_gpio_free(struct regulator_dev *rdev)
 		if (pin->gpiod == rdev->ena_pin->gpiod) {
 			if (pin->request_count <= 1) {
 				pin->request_count = 0;
-				gpiod_put(pin->gpiod);
 				list_del(&pin->list);
 				kfree(pin);
 				rdev->ena_pin = NULL;
@@ -4971,15 +4953,13 @@ regulator_register(const struct regulator_desc *regulator_desc,
 			goto clean;
 	}
 
-	if (config->ena_gpiod ||
-	    ((config->ena_gpio || config->ena_gpio_initialized) &&
-	     gpio_is_valid(config->ena_gpio))) {
+	if (config->ena_gpiod) {
 		mutex_lock(&regulator_list_mutex);
 		ret = regulator_ena_gpio_request(rdev, config);
 		mutex_unlock(&regulator_list_mutex);
 		if (ret != 0) {
-			rdev_err(rdev, "Failed to request enable GPIO%d: %d\n",
-				 config->ena_gpio, ret);
+			rdev_err(rdev, "Failed to request enable GPIO: %d\n",
+				 ret);
 			goto clean;
 		}
 		/* The regulator core took over the GPIO descriptor */

commit 01dc79cd6fe7d25b0eba84009634f5435cbdb4e6
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Jan 29 11:31:53 2019 +0100

    regulator: fixed/gpio: Pull inversion/OD into gpiolib
    
    This pushes the handling of inversion semantics and open drain
    settings to the GPIO descriptor and gpiolib. All affected board
    files are also augmented.
    
    This is especially nice since we don't have to have any
    confusing flags passed around to the left and right littering
    the fixed and GPIO regulator drivers and the regulator core.
    It is all just very straight-forward: the core asks the GPIO
    line to be asserted or deasserted and gpiolib deals with the
    rest depending on how the platform is configured: if the line
    is active low, it deals with that, if the line is open drain,
    it deals with that too.
    
    Cc: Alexander Shiyan <shc_work@mail.ru> # i.MX boards user
    Cc: Haojian Zhuang <haojian.zhuang@gmail.com> # MMP2 maintainer
    Cc: Aaro Koskinen <aaro.koskinen@iki.fi> # OMAP1 maintainer
    Cc: Tony Lindgren <tony@atomide.com> # OMAP1,2,3 maintainer
    Cc: Mike Rapoport <rppt@linux.vnet.ibm.com> # EM-X270 maintainer
    Cc: Robert Jarzmik <robert.jarzmik@free.fr> # EZX maintainer
    Cc: Philipp Zabel <philipp.zabel@gmail.com> # Magician maintainer
    Cc: Petr Cvek <petr.cvek@tul.cz> # Magician
    Cc: Robert Jarzmik <robert.jarzmik@free.fr> # PXA
    Cc: Paul Parsons <lost.distance@yahoo.com> # hx4700
    Cc: Daniel Mack <zonque@gmail.com> # Raumfeld maintainer
    Cc: Marc Zyngier <marc.zyngier@arm.com> # Zeus maintainer
    Cc: Geert Uytterhoeven <geert+renesas@glider.be> # SuperH pinctrl/GPIO maintainer
    Cc: Russell King <rmk+kernel@armlinux.org.uk> # SA1100
    Tested-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Tested-by: Janusz Krzysztofik <jmkrzyszt@gmail.com> #OMAP1 Amstrad Delta
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 430a73dea487..1778c5d1b2d0 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -82,7 +82,6 @@ struct regulator_enable_gpio {
 	struct gpio_desc *gpiod;
 	u32 enable_count;	/* a number of enabled shared GPIO */
 	u32 request_count;	/* a number of requested shared GPIO */
-	unsigned int ena_gpio_invert:1;
 };
 
 /*
@@ -2268,7 +2267,6 @@ static int regulator_ena_gpio_request(struct regulator_dev *rdev,
 	}
 
 	pin->gpiod = gpiod;
-	pin->ena_gpio_invert = config->ena_gpio_invert;
 	list_add(&pin->list, &regulator_ena_gpio_list);
 
 update_ena_gpio_to_rdev:
@@ -2319,8 +2317,7 @@ static int regulator_ena_gpio_ctrl(struct regulator_dev *rdev, bool enable)
 	if (enable) {
 		/* Enable GPIO at initial use */
 		if (pin->enable_count == 0)
-			gpiod_set_value_cansleep(pin->gpiod,
-						 !pin->ena_gpio_invert);
+			gpiod_set_value_cansleep(pin->gpiod, 1);
 
 		pin->enable_count++;
 	} else {
@@ -2331,8 +2328,7 @@ static int regulator_ena_gpio_ctrl(struct regulator_dev *rdev, bool enable)
 
 		/* Disable GPIO if not used */
 		if (pin->enable_count <= 1) {
-			gpiod_set_value_cansleep(pin->gpiod,
-						 pin->ena_gpio_invert);
+			gpiod_set_value_cansleep(pin->gpiod, 0);
 			pin->enable_count = 0;
 		}
 	}

commit 03c87b95ac04c2a34045641b25dded6e3e889556
Author: Bartosz Golaszewski <bgolaszewski@baylibre.com>
Date:   Wed Jan 9 18:44:00 2019 +0100

    regulator: provide rdev_get_regmap()
    
    Provide a helper allowing to access regulator's regmap.
    
    Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 3f9d81b6e763..430a73dea487 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -5251,6 +5251,12 @@ struct device *rdev_get_dev(struct regulator_dev *rdev)
 }
 EXPORT_SYMBOL_GPL(rdev_get_dev);
 
+struct regmap *rdev_get_regmap(struct regulator_dev *rdev)
+{
+	return rdev->regmap;
+}
+EXPORT_SYMBOL_GPL(rdev_get_regmap);
+
 void *regulator_get_init_drvdata(struct regulator_init_data *reg_init_data)
 {
 	return reg_init_data->driver_data;

commit 48f1b4efd67c922eff113f247533cbe175b1491e
Author: Krzysztof Kozlowski <krzk@kernel.org>
Date:   Tue Jan 8 13:12:33 2019 +0100

    regulator: Fix trivial language typos
    
    Fix few trivial language typos in core and drivers.
    
    Signed-off-by: Krzysztof Kozlowski <krzk@kernel.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index b9d7b45c7295..3f9d81b6e763 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -326,7 +326,7 @@ static int regulator_lock_recursive(struct regulator_dev *rdev,
  * @rdev:			regulator source
  * @ww_ctx:			w/w mutex acquire context
  *
- * Unlock all regulators related with rdev by coupling or suppling.
+ * Unlock all regulators related with rdev by coupling or supplying.
  */
 static void regulator_unlock_dependent(struct regulator_dev *rdev,
 				       struct ww_acquire_ctx *ww_ctx)
@@ -341,7 +341,7 @@ static void regulator_unlock_dependent(struct regulator_dev *rdev,
  * @ww_ctx:			w/w mutex acquire context
  *
  * This function as a wrapper on regulator_lock_recursive(), which locks
- * all regulators related with rdev by coupling or suppling.
+ * all regulators related with rdev by coupling or supplying.
  */
 static void regulator_lock_dependent(struct regulator_dev *rdev,
 				     struct ww_acquire_ctx *ww_ctx)
@@ -1003,7 +1003,7 @@ static int suspend_set_state(struct regulator_dev *rdev,
 	if (rstate == NULL)
 		return 0;
 
-	/* If we have no suspend mode configration don't set anything;
+	/* If we have no suspend mode configuration don't set anything;
 	 * only warn if the driver implements set_suspend_voltage or
 	 * set_suspend_mode callback.
 	 */
@@ -1131,7 +1131,7 @@ static int machine_constraints_voltage(struct regulator_dev *rdev,
 		int current_uV = _regulator_get_voltage(rdev);
 
 		if (current_uV == -ENOTRECOVERABLE) {
-			/* This regulator can't be read and must be initted */
+			/* This regulator can't be read and must be initialized */
 			rdev_info(rdev, "Setting %d-%duV\n",
 				  rdev->constraints->min_uV,
 				  rdev->constraints->max_uV);
@@ -1780,7 +1780,7 @@ static int regulator_resolve_supply(struct regulator_dev *rdev)
 	struct device *dev = rdev->dev.parent;
 	int ret;
 
-	/* No supply to resovle? */
+	/* No supply to resolve? */
 	if (!rdev->supply_name)
 		return 0;
 
@@ -2409,7 +2409,7 @@ static int _regulator_do_enable(struct regulator_dev *rdev)
 			 * timer wrapping.
 			 * in case of multiple timer wrapping, either it can be
 			 * detected by out-of-range remaining, or it cannot be
-			 * detected and we gets a panelty of
+			 * detected and we get a penalty of
 			 * _regulator_enable_delay().
 			 */
 			remaining = intended - start_jiffy;
@@ -2809,7 +2809,7 @@ static void regulator_disable_work(struct work_struct *work)
 /**
  * regulator_disable_deferred - disable regulator output with delay
  * @regulator: regulator source
- * @ms: miliseconds until the regulator is disabled
+ * @ms: milliseconds until the regulator is disabled
  *
  * Execute regulator_disable() on the regulator after a delay.  This
  * is intended for use with devices that require some time to quiesce.
@@ -4943,7 +4943,7 @@ regulator_register(const struct regulator_desc *regulator_desc,
 	 * device tree until we have handled it over to the core. If the
 	 * config that was passed in to this function DOES NOT contain
 	 * a descriptor, and the config after this call DOES contain
-	 * a descriptor, we definately got one from parsing the device
+	 * a descriptor, we definitely got one from parsing the device
 	 * tree.
 	 */
 	if (!cfg->ena_gpiod && config->ena_gpiod)

commit c3b5725965228014215de553eed3492dbd80a4bd
Merge: b27d9668be60 8ff00ba79283
Author: Mark Brown <broonie@kernel.org>
Date:   Fri Dec 21 13:43:35 2018 +0000

    Merge remote-tracking branch 'regulator/topic/coupled' into regulator-next

commit 3e60b4fc86710cd2095628c67b296e7cc4b239c1
Author: Yangtao Li <tiny.windzz@gmail.com>
Date:   Sat Dec 15 03:21:48 2018 -0500

    regulator: convert to DEFINE_SHOW_ATTRIBUTE
    
    Use DEFINE_SHOW_ATTRIBUTE macro to simplify the code.
    
    Signed-off-by: Yangtao Li <tiny.windzz@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index f211aa7da44e..0e402606e8be 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -5278,23 +5278,8 @@ static int supply_map_show(struct seq_file *sf, void *data)
 
 	return 0;
 }
+DEFINE_SHOW_ATTRIBUTE(supply_map);
 
-static int supply_map_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, supply_map_show, inode->i_private);
-}
-#endif
-
-static const struct file_operations supply_map_fops = {
-#ifdef CONFIG_DEBUG_FS
-	.open = supply_map_open,
-	.read = seq_read,
-	.llseek = seq_lseek,
-	.release = single_release,
-#endif
-};
-
-#ifdef CONFIG_DEBUG_FS
 struct summary_data {
 	struct seq_file *s;
 	struct regulator_dev *parent;
@@ -5516,21 +5501,8 @@ static int regulator_summary_show(struct seq_file *s, void *data)
 
 	return 0;
 }
-
-static int regulator_summary_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, regulator_summary_show, inode->i_private);
-}
-#endif
-
-static const struct file_operations regulator_summary_fops = {
-#ifdef CONFIG_DEBUG_FS
-	.open		= regulator_summary_open,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release	= single_release,
-#endif
-};
+DEFINE_SHOW_ATTRIBUTE(regulator_summary);
+#endif /* CONFIG_DEBUG_FS */
 
 static int __init regulator_init(void)
 {
@@ -5542,12 +5514,13 @@ static int __init regulator_init(void)
 	if (!debugfs_root)
 		pr_warn("regulator: Failed to create debugfs directory\n");
 
+#ifdef CONFIG_DEBUG_FS
 	debugfs_create_file("supply_map", 0444, debugfs_root, NULL,
 			    &supply_map_fops);
 
 	debugfs_create_file("regulator_summary", 0444, debugfs_root,
 			    NULL, &regulator_summary_fops);
-
+#endif
 	regulator_dummy_init();
 
 	return ret;

commit 05f224ca669398b567d09feb6e2ceefcb7d7f945
Author: Douglas Anderson <dianders@chromium.org>
Date:   Thu Dec 6 14:23:18 2018 -0800

    regulator: core: Clean enabling always-on regulators + their supplies
    
    At the end of regulator_resolve_supply() we have historically turned
    on our supply in some cases.  This could be for one of two reasons:
    
    1. If resolving supplies was happening before the call to
       set_machine_constraints() we needed to predict if
       set_machine_constraints() was going to turn the regulator on and we
       needed to preemptively turn the supply on.
    2. Maybe set_machine_constraints() happened before we could resolve
       supplies (because we failed the first time to resolve) and thus we
       might need to propagate an enable that already happened up to our
       supply.
    
    Historically regulator_resolve_supply() used _regulator_is_enabled()
    to decide whether to turn on the supply.
    
    Let's change things a little bit.  Specifically:
    
    1. Let's try to enable the supply and the regulator in the same place,
       both in set_machine_constraints().  This means that we have exactly
       the same logic for enabling the supply and the regulator.
    2. Let's properly set use_count when we enable always-on or boot-on
       regulators even for those that don't have supplies.  The previous
       commit 1fc12b05895e ("regulator: core: Avoid propagating to
       supplies when possible") only did this right for regulators with
       supplies.
    3. Let's make it clear that the only time we need to enable the supply
       in regulator_resolve_supply() is if the main regulator is currently
       in use.  By using use_count (like the rest of the code) to decide
       if we're going to enable our supply we keep everything consistent.
    
    Overall the new scheme should be cleaner and easier to reason about.
    In addition to fixing regulator_summary to be more correct (because of
    the more correct use_count), this change also has the effect of no
    longer using _regulator_is_enabled() in this code path.
    _regulator_is_enabled() could return an error code for some regulators
    at bootup (like RPMh) that can't read their initial state.  While one
    can argue that the design of those regulators is sub-optimal, the new
    logic sidesteps this brokenness.  This fix in particular fixes
    observed problems on Qualcomm sdm845 boards which use the
    above-mentioned RPMh regulator.  Those problems were made worse by
    commit 1fc12b05895e ("regulator: core: Avoid propagating to supplies
    when possible") because now we'd think at bootup that the SD
    regulators were already enabled and we'd never try them again.
    
    Fixes: 1fc12b05895e ("regulator: core: Avoid propagating to supplies when possible")
    Reported-by: Evan Green <evgreen@chromium.org>
    Signed-off-by: Douglas Anderson <dianders@chromium.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index ae0a559d1978..f211aa7da44e 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1399,11 +1399,21 @@ static int set_machine_constraints(struct regulator_dev *rdev,
 	 * and we have control then make sure it is enabled.
 	 */
 	if (rdev->constraints->always_on || rdev->constraints->boot_on) {
+		if (rdev->supply) {
+			ret = regulator_enable(rdev->supply);
+			if (ret < 0) {
+				_regulator_put(rdev->supply);
+				rdev->supply = NULL;
+				return ret;
+			}
+		}
+
 		ret = _regulator_do_enable(rdev);
 		if (ret < 0 && ret != -EINVAL) {
 			rdev_err(rdev, "failed to enable\n");
 			return ret;
 		}
+		rdev->use_count++;
 	}
 
 	print_constraints(rdev);
@@ -1820,15 +1830,18 @@ static int regulator_resolve_supply(struct regulator_dev *rdev)
 		return ret;
 	}
 
-	/* Cascade always-on state to supply */
-	if (_regulator_is_enabled(rdev)) {
+	/*
+	 * In set_machine_constraints() we may have turned this regulator on
+	 * but we couldn't propagate to the supply if it hadn't been resolved
+	 * yet.  Do it now.
+	 */
+	if (rdev->use_count) {
 		ret = regulator_enable(rdev->supply);
 		if (ret < 0) {
 			_regulator_put(rdev->supply);
 			rdev->supply = NULL;
 			return ret;
 		}
-		rdev->use_count = 1;
 	}
 
 	return 0;

commit e6202e8249aa7115af65f2d80b43c132816224ef
Merge: 2b96edb57070 d407c81adae5
Author: Mark Brown <broonie@kernel.org>
Date:   Tue Dec 11 20:44:49 2018 +0000

    Merge branch 'for-linus' of https://git.kernel.org/pub/scm/linux/kernel/git/broonie/regulator into regulator-4.21

commit 0edb040d416ab350c02ac710233349aeaf8c2a26
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Thu Dec 6 13:43:37 2018 +0100

    regulator: core: Track dangling GPIO descriptors
    
    If a GPIO descriptor is passed to the regulator_register()
    function inside the config->ena_gpiod callers must be
    sure that once they call this API the regulator core
    owns that descriptor and will make sure to issue
    gpiod_put() on it, no matter whether the call is
    successful or not.
    
    For device tree regulators, the regulator core will
    automatically set up regulator init data from the device
    tree when registering a regulator by calling
    regulator_of_get_init_data() which in turn calls down to
    the regulator driver's .of_parse_cb() callback.
    This callback (in drivers such as for max77686) may also
    choose to fill in the config->ena_gpiod field with a GPIO
    descriptor.
    
    Harden the errorpath of regulator_register() to
    properly gpiod_put() any passed in cfg->ena_gpiod
    or any gpiod coming from the device tree on any type
    of error.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Reviewed-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Tested-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Reviewed-by: Charles Keepax <ckeepax@opensource.cirrus.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 757619878068..79cb090ff22f 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -4868,21 +4868,33 @@ regulator_register(const struct regulator_desc *regulator_desc,
 	struct regulator_config *config = NULL;
 	static atomic_t regulator_no = ATOMIC_INIT(-1);
 	struct regulator_dev *rdev;
+	bool dangling_cfg_gpiod = false;
+	bool dangling_of_gpiod = false;
 	struct device *dev;
 	int ret, i;
 
-	if (regulator_desc == NULL || cfg == NULL)
+	if (cfg == NULL)
 		return ERR_PTR(-EINVAL);
+	if (cfg->ena_gpiod)
+		dangling_cfg_gpiod = true;
+	if (regulator_desc == NULL) {
+		ret = -EINVAL;
+		goto rinse;
+	}
 
 	dev = cfg->dev;
 	WARN_ON(!dev);
 
-	if (regulator_desc->name == NULL || regulator_desc->ops == NULL)
-		return ERR_PTR(-EINVAL);
+	if (regulator_desc->name == NULL || regulator_desc->ops == NULL) {
+		ret = -EINVAL;
+		goto rinse;
+	}
 
 	if (regulator_desc->type != REGULATOR_VOLTAGE &&
-	    regulator_desc->type != REGULATOR_CURRENT)
-		return ERR_PTR(-EINVAL);
+	    regulator_desc->type != REGULATOR_CURRENT) {
+		ret = -EINVAL;
+		goto rinse;
+	}
 
 	/* Only one of each should be implemented */
 	WARN_ON(regulator_desc->ops->get_voltage &&
@@ -4893,16 +4905,20 @@ regulator_register(const struct regulator_desc *regulator_desc,
 	/* If we're using selectors we must implement list_voltage. */
 	if (regulator_desc->ops->get_voltage_sel &&
 	    !regulator_desc->ops->list_voltage) {
-		return ERR_PTR(-EINVAL);
+		ret = -EINVAL;
+		goto rinse;
 	}
 	if (regulator_desc->ops->set_voltage_sel &&
 	    !regulator_desc->ops->list_voltage) {
-		return ERR_PTR(-EINVAL);
+		ret = -EINVAL;
+		goto rinse;
 	}
 
 	rdev = kzalloc(sizeof(struct regulator_dev), GFP_KERNEL);
-	if (rdev == NULL)
-		return ERR_PTR(-ENOMEM);
+	if (rdev == NULL) {
+		ret = -ENOMEM;
+		goto rinse;
+	}
 
 	/*
 	 * Duplicate the config so the driver could override it after
@@ -4911,11 +4927,22 @@ regulator_register(const struct regulator_desc *regulator_desc,
 	config = kmemdup(cfg, sizeof(*cfg), GFP_KERNEL);
 	if (config == NULL) {
 		kfree(rdev);
-		return ERR_PTR(-ENOMEM);
+		ret = -ENOMEM;
+		goto rinse;
 	}
 
 	init_data = regulator_of_get_init_data(dev, regulator_desc, config,
 					       &rdev->dev.of_node);
+	/*
+	 * We need to keep track of any GPIO descriptor coming from the
+	 * device tree until we have handled it over to the core. If the
+	 * config that was passed in to this function DOES NOT contain
+	 * a descriptor, and the config after this call DOES contain
+	 * a descriptor, we definately got one from parsing the device
+	 * tree.
+	 */
+	if (!cfg->ena_gpiod && config->ena_gpiod)
+		dangling_of_gpiod = true;
 	if (!init_data) {
 		init_data = config->init_data;
 		rdev->dev.of_node = of_node_get(config->of_node);
@@ -4954,6 +4981,9 @@ regulator_register(const struct regulator_desc *regulator_desc,
 				 config->ena_gpio, ret);
 			goto clean;
 		}
+		/* The regulator core took over the GPIO descriptor */
+		dangling_cfg_gpiod = false;
+		dangling_of_gpiod = false;
 	}
 
 	/* register with sysfs */
@@ -5039,8 +5069,13 @@ regulator_register(const struct regulator_desc *regulator_desc,
 	regulator_ena_gpio_free(rdev);
 	mutex_unlock(&regulator_list_mutex);
 clean:
+	if (dangling_of_gpiod)
+		gpiod_put(config->ena_gpiod);
 	kfree(rdev);
 	kfree(config);
+rinse:
+	if (dangling_cfg_gpiod)
+		gpiod_put(cfg->ena_gpiod);
 	return ERR_PTR(ret);
 }
 EXPORT_SYMBOL_GPL(regulator_register);

commit fa94e48e13a1aaf814b9e956d8e5a52ef303b569
Author: Douglas Anderson <dianders@chromium.org>
Date:   Mon Nov 26 09:08:27 2018 -0800

    regulator: core: Apply system load even if no consumer loads
    
    Prior to commit 5451781dadf8 ("regulator: core: Only count load for
    enabled consumers") we used to always add up the total load on every
    enable in _regulator_enable().  After that commit we only updated the
    total load when enabling / disabling a regulator where a consumer
    specified a load or when changing the consumer load on an enabled
    regulator.
    
    The problem with the new scheme is that if there is a system load
    specified for a regulator but no consumers specify a load then we
    never account for it.
    
    Let's account for the system load in set_machine_constraints().
    
    NOTE: with the new scheme we end up with a bit of a quandry.  What if
    someone specifies _both_ an initial mode and a system load?  If we
    take the system load into account right at init time then it will
    effectively clobber the initial mode.  We'll resolve this by saying
    that if both are specified then the initial mode will win.  The system
    load will then only take effect if/when a consumer specifies a load.
    If no consumers ever specify a load then the initial mode will persist
    and the system load will have no effect.
    
    Fixes: 5451781dadf8 ("regulator: core: Only count load for enabled consumers")
    Reported-by: Brian Masney <masneyb@onstation.org>
    Signed-off-by: Douglas Anderson <dianders@chromium.org>
    Tested-by: Brian Masney <masneyb@onstation.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 03a03763457c..757619878068 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1342,6 +1342,12 @@ static int set_machine_constraints(struct regulator_dev *rdev,
 			rdev_err(rdev, "failed to set initial mode: %d\n", ret);
 			return ret;
 		}
+	} else if (rdev->constraints->system_load) {
+		/*
+		 * We'll only apply the initial system load if an
+		 * initial mode wasn't specified.
+		 */
+		drms_uA_update(rdev);
 	}
 
 	/* If the constraints say the regulator should be on at this point

commit 2bb1666369339f69f227ad060c250afde94d5c69
Author: Olliver Schinagl <oliver@schinagl.nl>
Date:   Mon Nov 26 17:27:44 2018 +0200

    regulator: core: enable power when setting up constraints
    
    When a regulator is marked as always on, it is enabled early on, when
    checking and setting up constraints. It makes the assumption that the
    bootloader properly initialized the regulator, and just in case enables
    the regulator anyway.
    
    Some constraints however currently get missed, such as the soft-start
    and ramp-delay. This causes the regulator to be enabled, without the
    soft-start and ramp-delay being applied, which in turn can cause
    high-currents or other start-up problems.
    
    By moving the always-enabled constraints later in the constraints check,
    we can at least ensure all constraints for the regulator are followed.
    
    Signed-off-by: Olliver Schinagl <oliver@schinagl.nl>
    Signed-off-by: Priit Laes <plaes@plaes.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 2c66b528aede..6e146102fd93 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1158,17 +1158,6 @@ static int set_machine_constraints(struct regulator_dev *rdev,
 		}
 	}
 
-	/* If the constraints say the regulator should be on at this point
-	 * and we have control then make sure it is enabled.
-	 */
-	if (rdev->constraints->always_on || rdev->constraints->boot_on) {
-		ret = _regulator_do_enable(rdev);
-		if (ret < 0 && ret != -EINVAL) {
-			rdev_err(rdev, "failed to enable\n");
-			return ret;
-		}
-	}
-
 	if ((rdev->constraints->ramp_delay || rdev->constraints->ramp_disable)
 		&& ops->set_ramp_delay) {
 		ret = ops->set_ramp_delay(rdev, rdev->constraints->ramp_delay);
@@ -1214,6 +1203,17 @@ static int set_machine_constraints(struct regulator_dev *rdev,
 		}
 	}
 
+	/* If the constraints say the regulator should be on at this point
+	 * and we have control then make sure it is enabled.
+	 */
+	if (rdev->constraints->always_on || rdev->constraints->boot_on) {
+		ret = _regulator_do_enable(rdev);
+		if (ret < 0 && ret != -EINVAL) {
+			rdev_err(rdev, "failed to enable\n");
+			return ret;
+		}
+	}
+
 	print_constraints(rdev);
 	return 0;
 }

commit 1fc12b05895ea50386f0e666f84053f0c8307943
Author: Douglas Anderson <dianders@chromium.org>
Date:   Tue Nov 20 09:52:54 2018 -0800

    regulator: core: Avoid propagating to supplies when possible
    
    When we called regulator_enable() on a regulator we'd end up
    propagating that call all the way up the chain every time.  This is a
    bit of a waste of time.  A child regulator already refcounts its own
    enables so it should avoid passing on to its parent unless the
    refcount transitioned between 0 and 1.
    
    Historically this hasn't been a huge problem since we skipped dealing
    with enable for always-on regulators.  In a previous patch, however,
    we removed the always-on optimization.  On one system, the debugfs
    regulator_summary was now showing a "use_count" of 33 for a top-level
    regulator.
    
    Let's implement this optimization.  This turns out to be fairly
    trivial with the recent reorganization of the regulator core.
    
    NOTE: as part of this patch I'll make "always-on" regulators start
    with a use count of 1.  This keeps the counts clean when recursively
    resolving regulators.
    
    ALSO NOTE: this commit also contains somewhat of a bug fix to
    regulator_force_disable().  It was incorrectly looping over
    "rdev->open_count" when it should have been looping over use_count.
    We have to touch that code anyway (since we should no longer loop at
    all), so we'll fix it together in one patch.  Also: since this comes
    after commit f8702f9e4aa7 ("regulator: core: Use ww_mutex for
    regulators locking") we can now move to use _regulator_disable() for
    our supply and keep it in the lock.
    
    Signed-off-by: Douglas Anderson <dianders@chromium.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 26a0c523ed86..03a03763457c 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1822,6 +1822,7 @@ static int regulator_resolve_supply(struct regulator_dev *rdev)
 			rdev->supply = NULL;
 			return ret;
 		}
+		rdev->use_count = 1;
 	}
 
 	return 0;
@@ -2491,7 +2492,7 @@ static int _regulator_enable(struct regulator *regulator)
 
 	lockdep_assert_held_once(&rdev->mutex.base);
 
-	if (rdev->supply) {
+	if (rdev->use_count == 0 && rdev->supply) {
 		ret = _regulator_enable(rdev->supply);
 		if (ret < 0)
 			return ret;
@@ -2539,7 +2540,7 @@ static int _regulator_enable(struct regulator *regulator)
 	_regulator_handle_consumer_disable(regulator);
 
 err_disable_supply:
-	if (rdev->supply)
+	if (rdev->use_count == 0 && rdev->supply)
 		_regulator_disable(rdev->supply);
 
 	return ret;
@@ -2648,7 +2649,7 @@ static int _regulator_disable(struct regulator *regulator)
 	if (ret == 0 && rdev->coupling_desc.n_coupled > 1)
 		ret = regulator_balance_voltage(rdev, PM_SUSPEND_ON);
 
-	if (ret == 0 && rdev->supply)
+	if (ret == 0 && rdev->use_count == 0 && rdev->supply)
 		ret = _regulator_disable(rdev->supply);
 
 	return ret;
@@ -2733,11 +2734,10 @@ int regulator_force_disable(struct regulator *regulator)
 		ret = drms_uA_update(rdev);
 	}
 
-	regulator_unlock_dependent(rdev, &ww_ctx);
+	if (rdev->use_count != 0 && rdev->supply)
+		_regulator_disable(rdev->supply);
 
-	if (rdev->supply)
-		while (rdev->open_count--)
-			regulator_disable(rdev->supply);
+	regulator_unlock_dependent(rdev, &ww_ctx);
 
 	return ret;
 }

commit 5451781dadf85000665e0e2c3288e9e0f34b860a
Author: Douglas Anderson <dianders@chromium.org>
Date:   Tue Nov 20 09:52:53 2018 -0800

    regulator: core: Only count load for enabled consumers
    
    In general when the consumer of a regulator requests that the
    regulator be disabled it no longer will be drawing much load from the
    regulator--it should just be the leakage current and that should be
    very close to 0.
    
    Up to this point the regulator framework has continued to count a
    consumer's load request for disabled regulators.  This has led to code
    patterns that look like this:
    
      enable_my_thing():
        regular_set_load(reg, load_uA)
        regulator_enable(reg)
    
      disable_my_thing():
        regulator_disable(reg)
        regulator_set_load(reg, 0)
    
    Sometimes disable_my_thing() sets a nominal (<= 100 uA) load instead
    of setting a 0 uA load.  I will make the assertion that nearly all (if
    not all) places where we set a nominal load of 100 uA or less we end
    up with a result that is the same as if we had set a load of 0 uA.
    Specifically:
    - The whole point of setting the load is to help set the operating
      mode of the regulator.  Higher loads may need less efficient
      operating modes.
    - The only time this matters at all is if there is another consumer of
      the regulator that wants the regulator on.  If there are no other
      consumers of the regulator then the regulator will turn off and we
      don't care about the operating mode.
    - If there's another consumer that actually wants the regulator on
      then presumably it is requesting a load that makes our nominal
      <= 100 uA load insignificant.
    
    A quick survey of the existing callers to regulator_set_load() to see
    how everyone uses it:
    
    Signed-off-by: Douglas Anderson <dianders@chromium.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index ff5ca185bb8f..26a0c523ed86 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -99,7 +99,7 @@ struct regulator_supply_alias {
 };
 
 static int _regulator_is_enabled(struct regulator_dev *rdev);
-static int _regulator_disable(struct regulator_dev *rdev);
+static int _regulator_disable(struct regulator *regulator);
 static int _regulator_get_voltage(struct regulator_dev *rdev);
 static int _regulator_get_current_limit(struct regulator_dev *rdev);
 static unsigned int _regulator_get_mode(struct regulator_dev *rdev);
@@ -764,8 +764,10 @@ static ssize_t regulator_total_uA_show(struct device *dev,
 	int uA = 0;
 
 	regulator_lock(rdev);
-	list_for_each_entry(regulator, &rdev->consumer_list, list)
-		uA += regulator->uA_load;
+	list_for_each_entry(regulator, &rdev->consumer_list, list) {
+		if (regulator->enable_count)
+			uA += regulator->uA_load;
+	}
 	regulator_unlock(rdev);
 	return sprintf(buf, "%d\n", uA);
 }
@@ -938,8 +940,10 @@ static int drms_uA_update(struct regulator_dev *rdev)
 		return -EINVAL;
 
 	/* calc total requested load */
-	list_for_each_entry(sibling, &rdev->consumer_list, list)
-		current_uA += sibling->uA_load;
+	list_for_each_entry(sibling, &rdev->consumer_list, list) {
+		if (sibling->enable_count)
+			current_uA += sibling->uA_load;
+	}
 
 	current_uA += rdev->constraints->system_load;
 
@@ -2024,6 +2028,9 @@ static void _regulator_put(struct regulator *regulator)
 
 	lockdep_assert_held_once(&regulator_list_mutex);
 
+	/* Docs say you must disable before calling regulator_put() */
+	WARN_ON(regulator->enable_count);
+
 	rdev = regulator->rdev;
 
 	debugfs_remove_recursive(regulator->debugfs);
@@ -2417,15 +2424,75 @@ static int _regulator_do_enable(struct regulator_dev *rdev)
 	return 0;
 }
 
+/**
+ * _regulator_handle_consumer_enable - handle that a consumer enabled
+ * @regulator: regulator source
+ *
+ * Some things on a regulator consumer (like the contribution towards total
+ * load on the regulator) only have an effect when the consumer wants the
+ * regulator enabled.  Explained in example with two consumers of the same
+ * regulator:
+ *   consumer A: set_load(100);       => total load = 0
+ *   consumer A: regulator_enable();  => total load = 100
+ *   consumer B: set_load(1000);      => total load = 100
+ *   consumer B: regulator_enable();  => total load = 1100
+ *   consumer A: regulator_disable(); => total_load = 1000
+ *
+ * This function (together with _regulator_handle_consumer_disable) is
+ * responsible for keeping track of the refcount for a given regulator consumer
+ * and applying / unapplying these things.
+ *
+ * Returns 0 upon no error; -error upon error.
+ */
+static int _regulator_handle_consumer_enable(struct regulator *regulator)
+{
+	struct regulator_dev *rdev = regulator->rdev;
+
+	lockdep_assert_held_once(&rdev->mutex.base);
+
+	regulator->enable_count++;
+	if (regulator->uA_load && regulator->enable_count == 1)
+		return drms_uA_update(rdev);
+
+	return 0;
+}
+
+/**
+ * _regulator_handle_consumer_disable - handle that a consumer disabled
+ * @regulator: regulator source
+ *
+ * The opposite of _regulator_handle_consumer_enable().
+ *
+ * Returns 0 upon no error; -error upon error.
+ */
+static int _regulator_handle_consumer_disable(struct regulator *regulator)
+{
+	struct regulator_dev *rdev = regulator->rdev;
+
+	lockdep_assert_held_once(&rdev->mutex.base);
+
+	if (!regulator->enable_count) {
+		rdev_err(rdev, "Underflow of regulator enable count\n");
+		return -EINVAL;
+	}
+
+	regulator->enable_count--;
+	if (regulator->uA_load && regulator->enable_count == 0)
+		return drms_uA_update(rdev);
+
+	return 0;
+}
+
 /* locks held by regulator_enable() */
-static int _regulator_enable(struct regulator_dev *rdev)
+static int _regulator_enable(struct regulator *regulator)
 {
+	struct regulator_dev *rdev = regulator->rdev;
 	int ret;
 
 	lockdep_assert_held_once(&rdev->mutex.base);
 
 	if (rdev->supply) {
-		ret = _regulator_enable(rdev->supply->rdev);
+		ret = _regulator_enable(rdev->supply);
 		if (ret < 0)
 			return ret;
 	}
@@ -2437,9 +2504,9 @@ static int _regulator_enable(struct regulator_dev *rdev)
 			goto err_disable_supply;
 	}
 
-	/* check voltage and requested load before enabling */
-	if (regulator_ops_is_valid(rdev, REGULATOR_CHANGE_DRMS))
-		drms_uA_update(rdev);
+	ret = _regulator_handle_consumer_enable(regulator);
+	if (ret < 0)
+		goto err_disable_supply;
 
 	if (rdev->use_count == 0) {
 		/* The regulator may on if it's not switchable or left on */
@@ -2448,18 +2515,18 @@ static int _regulator_enable(struct regulator_dev *rdev)
 			if (!regulator_ops_is_valid(rdev,
 					REGULATOR_CHANGE_STATUS)) {
 				ret = -EPERM;
-				goto err_disable_supply;
+				goto err_consumer_disable;
 			}
 
 			ret = _regulator_do_enable(rdev);
 			if (ret < 0)
-				goto err_disable_supply;
+				goto err_consumer_disable;
 
 			_notifier_call_chain(rdev, REGULATOR_EVENT_ENABLE,
 					     NULL);
 		} else if (ret < 0) {
 			rdev_err(rdev, "is_enabled() failed: %d\n", ret);
-			goto err_disable_supply;
+			goto err_consumer_disable;
 		}
 		/* Fallthrough on positive return values - already enabled */
 	}
@@ -2468,9 +2535,12 @@ static int _regulator_enable(struct regulator_dev *rdev)
 
 	return 0;
 
+err_consumer_disable:
+	_regulator_handle_consumer_disable(regulator);
+
 err_disable_supply:
 	if (rdev->supply)
-		_regulator_disable(rdev->supply->rdev);
+		_regulator_disable(rdev->supply);
 
 	return ret;
 }
@@ -2490,13 +2560,10 @@ int regulator_enable(struct regulator *regulator)
 {
 	struct regulator_dev *rdev = regulator->rdev;
 	struct ww_acquire_ctx ww_ctx;
-	int ret = 0;
-
-	if (regulator->always_on)
-		return 0;
+	int ret;
 
 	regulator_lock_dependent(rdev, &ww_ctx);
-	ret = _regulator_enable(rdev);
+	ret = _regulator_enable(regulator);
 	regulator_unlock_dependent(rdev, &ww_ctx);
 
 	return ret;
@@ -2535,8 +2602,9 @@ static int _regulator_do_disable(struct regulator_dev *rdev)
 }
 
 /* locks held by regulator_disable() */
-static int _regulator_disable(struct regulator_dev *rdev)
+static int _regulator_disable(struct regulator *regulator)
 {
+	struct regulator_dev *rdev = regulator->rdev;
 	int ret = 0;
 
 	lockdep_assert_held_once(&rdev->mutex.base);
@@ -2571,17 +2639,17 @@ static int _regulator_disable(struct regulator_dev *rdev)
 
 		rdev->use_count = 0;
 	} else if (rdev->use_count > 1) {
-		if (regulator_ops_is_valid(rdev, REGULATOR_CHANGE_DRMS))
-			drms_uA_update(rdev);
-
 		rdev->use_count--;
 	}
 
+	if (ret == 0)
+		ret = _regulator_handle_consumer_disable(regulator);
+
 	if (ret == 0 && rdev->coupling_desc.n_coupled > 1)
 		ret = regulator_balance_voltage(rdev, PM_SUSPEND_ON);
 
 	if (ret == 0 && rdev->supply)
-		ret = _regulator_disable(rdev->supply->rdev);
+		ret = _regulator_disable(rdev->supply);
 
 	return ret;
 }
@@ -2602,13 +2670,10 @@ int regulator_disable(struct regulator *regulator)
 {
 	struct regulator_dev *rdev = regulator->rdev;
 	struct ww_acquire_ctx ww_ctx;
-	int ret = 0;
-
-	if (regulator->always_on)
-		return 0;
+	int ret;
 
 	regulator_lock_dependent(rdev, &ww_ctx);
-	ret = _regulator_disable(rdev);
+	ret = _regulator_disable(regulator);
 	regulator_unlock_dependent(rdev, &ww_ctx);
 
 	return ret;
@@ -2657,10 +2722,17 @@ int regulator_force_disable(struct regulator *regulator)
 	int ret;
 
 	regulator_lock_dependent(rdev, &ww_ctx);
-	regulator->uA_load = 0;
+
 	ret = _regulator_force_disable(regulator->rdev);
+
 	if (rdev->coupling_desc.n_coupled > 1)
 		regulator_balance_voltage(rdev, PM_SUSPEND_ON);
+
+	if (regulator->uA_load) {
+		regulator->uA_load = 0;
+		ret = drms_uA_update(rdev);
+	}
+
 	regulator_unlock_dependent(rdev, &ww_ctx);
 
 	if (rdev->supply)
@@ -2677,14 +2749,11 @@ static void regulator_disable_work(struct work_struct *work)
 						  disable_work.work);
 	struct ww_acquire_ctx ww_ctx;
 	int count, i, ret;
+	struct regulator *regulator;
+	int total_count = 0;
 
 	regulator_lock_dependent(rdev, &ww_ctx);
 
-	BUG_ON(!rdev->deferred_disables);
-
-	count = rdev->deferred_disables;
-	rdev->deferred_disables = 0;
-
 	/*
 	 * Workqueue functions queue the new work instance while the previous
 	 * work instance is being processed. Cancel the queued work instance
@@ -2693,11 +2762,22 @@ static void regulator_disable_work(struct work_struct *work)
 	 */
 	cancel_delayed_work(&rdev->disable_work);
 
-	for (i = 0; i < count; i++) {
-		ret = _regulator_disable(rdev);
-		if (ret != 0)
-			rdev_err(rdev, "Deferred disable failed: %d\n", ret);
+	list_for_each_entry(regulator, &rdev->consumer_list, list) {
+		count = regulator->deferred_disables;
+
+		if (!count)
+			continue;
+
+		total_count += count;
+		regulator->deferred_disables = 0;
+
+		for (i = 0; i < count; i++) {
+			ret = _regulator_disable(regulator);
+			if (ret != 0)
+				rdev_err(rdev, "Deferred disable failed: %d\n", ret);
+		}
 	}
+	WARN_ON(!total_count);
 
 	if (rdev->coupling_desc.n_coupled > 1)
 		regulator_balance_voltage(rdev, PM_SUSPEND_ON);
@@ -2731,14 +2811,11 @@ int regulator_disable_deferred(struct regulator *regulator, int ms)
 {
 	struct regulator_dev *rdev = regulator->rdev;
 
-	if (regulator->always_on)
-		return 0;
-
 	if (!ms)
 		return regulator_disable(regulator);
 
 	regulator_lock(rdev);
-	rdev->deferred_disables++;
+	regulator->deferred_disables++;
 	mod_delayed_work(system_power_efficient_wq, &rdev->disable_work,
 			 msecs_to_jiffies(ms));
 	regulator_unlock(rdev);
@@ -4145,16 +4222,30 @@ EXPORT_SYMBOL_GPL(regulator_get_error_flags);
  * DRMS will sum the total requested load on the regulator and change
  * to the most efficient operating mode if platform constraints allow.
  *
+ * NOTE: when a regulator consumer requests to have a regulator
+ * disabled then any load that consumer requested no longer counts
+ * toward the total requested load.  If the regulator is re-enabled
+ * then the previously requested load will start counting again.
+ *
+ * If a regulator is an always-on regulator then an individual consumer's
+ * load will still be removed if that consumer is fully disabled.
+ *
  * On error a negative errno is returned.
  */
 int regulator_set_load(struct regulator *regulator, int uA_load)
 {
 	struct regulator_dev *rdev = regulator->rdev;
-	int ret;
+	int old_uA_load;
+	int ret = 0;
 
 	regulator_lock(rdev);
+	old_uA_load = regulator->uA_load;
 	regulator->uA_load = uA_load;
-	ret = drms_uA_update(rdev);
+	if (regulator->enable_count && old_uA_load != uA_load) {
+		ret = drms_uA_update(rdev);
+		if (ret < 0)
+			regulator->uA_load = old_uA_load;
+	}
 	regulator_unlock(rdev);
 
 	return ret;
@@ -4325,11 +4416,8 @@ int regulator_bulk_enable(int num_consumers,
 	int ret = 0;
 
 	for (i = 0; i < num_consumers; i++) {
-		if (consumers[i].consumer->always_on)
-			consumers[i].ret = 0;
-		else
-			async_schedule_domain(regulator_bulk_enable_async,
-					      &consumers[i], &async_domain);
+		async_schedule_domain(regulator_bulk_enable_async,
+				      &consumers[i], &async_domain);
 	}
 
 	async_synchronize_full_domain(&async_domain);
@@ -5225,8 +5313,11 @@ static void regulator_summary_show_subtree(struct seq_file *s,
 
 		switch (rdev->desc->type) {
 		case REGULATOR_VOLTAGE:
-			seq_printf(s, "%37dmA %5dmV %5dmV",
+			seq_printf(s, "%3d %33dmA%c%5dmV %5dmV",
+				   consumer->enable_count,
 				   consumer->uA_load / 1000,
+				   consumer->uA_load && !consumer->enable_count ?
+				   '*' : ' ',
 				   consumer->voltage[PM_SUSPEND_ON].min_uV / 1000,
 				   consumer->voltage[PM_SUSPEND_ON].max_uV / 1000);
 			break;

commit 8ff00ba79283e691ae294a158879237179c683eb
Author: Douglas Anderson <dianders@chromium.org>
Date:   Mon Nov 19 16:26:50 2018 -0800

    regulator: core: Don't double-disable supplies in regulator_disable_deferred()
    
    In the commit f8702f9e4aa7 ("regulator: core: Use ww_mutex for
    regulators locking") disabling of the supply was moved into
    _regulator_disable().  That means regulator_disable_work() shouldn't
    be disabling since that double-disables the supply.
    
    Fixes: f8702f9e4aa7 ("regulator: core: Use ww_mutex for regulators locking")
    Signed-off-by: Douglas Anderson <dianders@chromium.org>
    Reviewed-by: Dmitry Osipenko <digetx@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index f937a33e5f02..cfc2b8f6453b 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2670,16 +2670,6 @@ static void regulator_disable_work(struct work_struct *work)
 		regulator_balance_voltage(rdev, PM_SUSPEND_ON);
 
 	regulator_unlock_dependent(rdev, &ww_ctx);
-
-	if (rdev->supply) {
-		for (i = 0; i < count; i++) {
-			ret = regulator_disable(rdev->supply);
-			if (ret != 0) {
-				rdev_err(rdev,
-					 "Supply disable failed: %d\n", ret);
-			}
-		}
-	}
 }
 
 /**

commit 7b51a821211eb6217f60962c31f30cb73e30a0c7
Author: Douglas Anderson <dianders@chromium.org>
Date:   Mon Nov 19 16:26:48 2018 -0800

    regulator: core: Properly expose requested_microamps in sysfs
    
    The "requested_microamps" sysfs attribute was only being exposed for
    "current" regulators.  This didn't make sense.  Allow it to be exposed
    always.
    
    Signed-off-by: Douglas Anderson <dianders@chromium.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index d7ffd7b12472..ff5ca185bb8f 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -4565,10 +4565,6 @@ static umode_t regulator_attr_is_visible(struct kobject *kobj,
 	if (attr == &dev_attr_bypass.attr)
 		return ops->get_bypass ? mode : 0;
 
-	/* some attributes are type-specific */
-	if (attr == &dev_attr_requested_microamps.attr)
-		return rdev->desc->type == REGULATOR_CURRENT ? mode : 0;
-
 	/* constraints need specific supporting methods */
 	if (attr == &dev_attr_min_microvolts.attr ||
 	    attr == &dev_attr_max_microvolts.attr)

commit 14a742724fc0f089893c6f70a62d30ab418ed7ff
Author: Dmitry Osipenko <digetx@gmail.com>
Date:   Tue Nov 20 04:20:19 2018 +0300

    regulator: core: Export regulator_lock and regulator_unlock
    
    This fixes compiling regulator drivers that use these function when
    these drivers are built as kernel modules.
    
    Fixes: f8702f9e4aa7 ("regulator: core: Use ww_mutex for regulators locking")
    Signed-off-by: Dmitry Osipenko <digetx@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index fd237bc0fa7c..f937a33e5f02 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -211,6 +211,7 @@ void regulator_lock(struct regulator_dev *rdev)
 {
 	regulator_lock_nested(rdev, NULL);
 }
+EXPORT_SYMBOL_GPL(regulator_lock);
 
 /**
  * regulator_unlock - unlock a single regulator
@@ -232,6 +233,7 @@ void regulator_unlock(struct regulator_dev *rdev)
 
 	mutex_unlock(&regulator_nesting_mutex);
 }
+EXPORT_SYMBOL_GPL(regulator_unlock);
 
 static bool regulator_supply_is_couple(struct regulator_dev *rdev)
 {

commit ffb8c1e45e7ae648a3a1689aa71be50fb459316e
Merge: a8d8ee437ea0 ff9b34b615a3
Author: Mark Brown <broonie@kernel.org>
Date:   Mon Nov 19 13:16:15 2018 +0000

    Merge branch 'topic/coupled' of https://git.kernel.org/pub/scm/linux/kernel/git/broonie/regulator into regulator-4.21 for trivial conflict

commit ff9b34b615a37a3f4d359bf82fc97f5e0310b301
Author: Dmitry Osipenko <digetx@gmail.com>
Date:   Mon Nov 19 00:56:19 2018 +0300

    regulator: core: Keep regulators-list locked while traversing the list
    
    It's unlikely that regulators may disappear/appear while regulators
    debug-summary is being prepared, but let's be consistent and avoid that
    situation.
    
    Signed-off-by: Dmitry Osipenko <digetx@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index e46e53aa43db..fd237bc0fa7c 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -4936,7 +4936,9 @@ void regulator_unregister(struct regulator_dev *rdev)
 			regulator_disable(rdev->supply);
 		regulator_put(rdev->supply);
 	}
+
 	mutex_lock(&regulator_list_mutex);
+
 	debugfs_remove_recursive(rdev->debugfs);
 	flush_work(&rdev->disable_work.work);
 	WARN_ON(rdev->open_count);
@@ -4944,8 +4946,9 @@ void regulator_unregister(struct regulator_dev *rdev)
 	unset_regulator_supplies(rdev);
 	list_del(&rdev->list);
 	regulator_ena_gpio_free(rdev);
-	mutex_unlock(&regulator_list_mutex);
 	device_unregister(&rdev->dev);
+
+	mutex_unlock(&regulator_list_mutex);
 }
 EXPORT_SYMBOL_GPL(regulator_unregister);
 
@@ -5278,6 +5281,8 @@ static void regulator_summary_lock(struct ww_acquire_ctx *ww_ctx)
 	struct regulator_dev *old_contended_rdev = NULL;
 	int err;
 
+	mutex_lock(&regulator_list_mutex);
+
 	ww_acquire_init(ww_ctx, &regulator_ww_class);
 
 	do {
@@ -5304,6 +5309,8 @@ static void regulator_summary_unlock(struct ww_acquire_ctx *ww_ctx)
 	class_for_each_device(&regulator_class, NULL, NULL,
 			      regulator_summary_unlock_one);
 	ww_acquire_fini(ww_ctx);
+
+	mutex_unlock(&regulator_list_mutex);
 }
 
 static int regulator_summary_show_roots(struct device *dev, void *data)

commit 089e2cc2e1861ad13a56811aa538419989346089
Author: Dmitry Osipenko <digetx@gmail.com>
Date:   Mon Nov 19 00:56:18 2018 +0300

    regulator: core: Properly handle case where supply is the couple
    
    Check whether supply regulator is the couple to avoid infinite recursion
    during of locking.
    
    Signed-off-by: Dmitry Osipenko <digetx@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 47ccd35c7965..e46e53aa43db 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -233,6 +233,21 @@ void regulator_unlock(struct regulator_dev *rdev)
 	mutex_unlock(&regulator_nesting_mutex);
 }
 
+static bool regulator_supply_is_couple(struct regulator_dev *rdev)
+{
+	struct regulator_dev *c_rdev;
+	int i;
+
+	for (i = 1; i < rdev->coupling_desc.n_coupled; i++) {
+		c_rdev = rdev->coupling_desc.coupled_rdevs[i];
+
+		if (rdev->supply->rdev == c_rdev)
+			return true;
+	}
+
+	return false;
+}
+
 static void regulator_unlock_recursive(struct regulator_dev *rdev,
 				       unsigned int n_coupled)
 {
@@ -245,7 +260,7 @@ static void regulator_unlock_recursive(struct regulator_dev *rdev,
 		if (!c_rdev)
 			continue;
 
-		if (c_rdev->supply)
+		if (c_rdev->supply && !regulator_supply_is_couple(c_rdev))
 			regulator_unlock_recursive(
 					c_rdev->supply->rdev,
 					c_rdev->coupling_desc.n_coupled);
@@ -283,7 +298,7 @@ static int regulator_lock_recursive(struct regulator_dev *rdev,
 			*old_contended_rdev = NULL;
 		}
 
-		if (c_rdev->supply) {
+		if (c_rdev->supply && !regulator_supply_is_couple(c_rdev)) {
 			err = regulator_lock_recursive(c_rdev->supply->rdev,
 						       new_contended_rdev,
 						       old_contended_rdev,

commit f8702f9e4aa7b45131af3df5531d6e3835269141
Author: Dmitry Osipenko <digetx@gmail.com>
Date:   Mon Nov 19 00:56:17 2018 +0300

    regulator: core: Use ww_mutex for regulators locking
    
    Wait/wound mutex shall be used in order to avoid lockups on locking of
    coupled regulators.
    
    Signed-off-by: Dmitry Osipenko <digetx@gmail.com>
    Suggested-by: Lucas Stach <l.stach@pengutronix.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 783ec9c74104..47ccd35c7965 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -50,6 +50,8 @@
 #define rdev_dbg(rdev, fmt, ...)					\
 	pr_debug("%s: " fmt, rdev_get_name(rdev), ##__VA_ARGS__)
 
+static DEFINE_WW_CLASS(regulator_ww_class);
+static DEFINE_MUTEX(regulator_nesting_mutex);
 static DEFINE_MUTEX(regulator_list_mutex);
 static LIST_HEAD(regulator_map_list);
 static LIST_HEAD(regulator_ena_gpio_list);
@@ -154,7 +156,7 @@ static inline struct regulator_dev *rdev_get_supply(struct regulator_dev *rdev)
 /**
  * regulator_lock_nested - lock a single regulator
  * @rdev:		regulator source
- * @subclass:		mutex subclass used for lockdep
+ * @ww_ctx:		w/w mutex acquire context
  *
  * This function can be called many times by one task on
  * a single regulator and its mutex will be locked only
@@ -162,24 +164,52 @@ static inline struct regulator_dev *rdev_get_supply(struct regulator_dev *rdev)
  * than the one, which initially locked the mutex, it will
  * wait on mutex.
  */
-static void regulator_lock_nested(struct regulator_dev *rdev,
-				  unsigned int subclass)
+static inline int regulator_lock_nested(struct regulator_dev *rdev,
+					struct ww_acquire_ctx *ww_ctx)
 {
-	if (!mutex_trylock(&rdev->mutex)) {
-		if (rdev->mutex_owner == current) {
+	bool lock = false;
+	int ret = 0;
+
+	mutex_lock(&regulator_nesting_mutex);
+
+	if (ww_ctx || !ww_mutex_trylock(&rdev->mutex)) {
+		if (rdev->mutex_owner == current)
 			rdev->ref_cnt++;
-			return;
+		else
+			lock = true;
+
+		if (lock) {
+			mutex_unlock(&regulator_nesting_mutex);
+			ret = ww_mutex_lock(&rdev->mutex, ww_ctx);
+			mutex_lock(&regulator_nesting_mutex);
 		}
-		mutex_lock_nested(&rdev->mutex, subclass);
+	} else {
+		lock = true;
 	}
 
-	rdev->ref_cnt = 1;
-	rdev->mutex_owner = current;
+	if (lock && ret != -EDEADLK) {
+		rdev->ref_cnt++;
+		rdev->mutex_owner = current;
+	}
+
+	mutex_unlock(&regulator_nesting_mutex);
+
+	return ret;
 }
 
-static inline void regulator_lock(struct regulator_dev *rdev)
+/**
+ * regulator_lock - lock a single regulator
+ * @rdev:		regulator source
+ *
+ * This function can be called many times by one task on
+ * a single regulator and its mutex will be locked only
+ * once. If a task, which is calling this function is other
+ * than the one, which initially locked the mutex, it will
+ * wait on mutex.
+ */
+void regulator_lock(struct regulator_dev *rdev)
 {
-	regulator_lock_nested(rdev, 0);
+	regulator_lock_nested(rdev, NULL);
 }
 
 /**
@@ -189,52 +219,48 @@ static inline void regulator_lock(struct regulator_dev *rdev)
  * This function unlocks the mutex when the
  * reference counter reaches 0.
  */
-static void regulator_unlock(struct regulator_dev *rdev)
+void regulator_unlock(struct regulator_dev *rdev)
 {
-	if (rdev->ref_cnt != 0) {
-		rdev->ref_cnt--;
+	mutex_lock(&regulator_nesting_mutex);
 
-		if (!rdev->ref_cnt) {
-			rdev->mutex_owner = NULL;
-			mutex_unlock(&rdev->mutex);
-		}
+	if (--rdev->ref_cnt == 0) {
+		rdev->mutex_owner = NULL;
+		ww_mutex_unlock(&rdev->mutex);
 	}
+
+	WARN_ON_ONCE(rdev->ref_cnt < 0);
+
+	mutex_unlock(&regulator_nesting_mutex);
 }
 
-static int regulator_lock_recursive(struct regulator_dev *rdev,
-				    unsigned int subclass)
+static void regulator_unlock_recursive(struct regulator_dev *rdev,
+				       unsigned int n_coupled)
 {
 	struct regulator_dev *c_rdev;
 	int i;
 
-	for (i = 0; i < rdev->coupling_desc.n_coupled; i++) {
-		c_rdev = rdev->coupling_desc.coupled_rdevs[i];
+	for (i = n_coupled; i > 0; i--) {
+		c_rdev = rdev->coupling_desc.coupled_rdevs[i - 1];
 
 		if (!c_rdev)
 			continue;
 
-		regulator_lock_nested(c_rdev, subclass++);
-
 		if (c_rdev->supply)
-			subclass =
-				regulator_lock_recursive(c_rdev->supply->rdev,
-							 subclass);
-	}
+			regulator_unlock_recursive(
+					c_rdev->supply->rdev,
+					c_rdev->coupling_desc.n_coupled);
 
-	return subclass;
+		regulator_unlock(c_rdev);
+	}
 }
 
-/**
- * regulator_unlock_dependent - unlock regulator's suppliers and coupled
- *				regulators
- * @rdev:			regulator source
- *
- * Unlock all regulators related with rdev by coupling or suppling.
- */
-static void regulator_unlock_dependent(struct regulator_dev *rdev)
+static int regulator_lock_recursive(struct regulator_dev *rdev,
+				    struct regulator_dev **new_contended_rdev,
+				    struct regulator_dev **old_contended_rdev,
+				    struct ww_acquire_ctx *ww_ctx)
 {
 	struct regulator_dev *c_rdev;
-	int i;
+	int i, err;
 
 	for (i = 0; i < rdev->coupling_desc.n_coupled; i++) {
 		c_rdev = rdev->coupling_desc.coupled_rdevs[i];
@@ -242,23 +268,95 @@ static void regulator_unlock_dependent(struct regulator_dev *rdev)
 		if (!c_rdev)
 			continue;
 
-		regulator_unlock(c_rdev);
+		if (c_rdev != *old_contended_rdev) {
+			err = regulator_lock_nested(c_rdev, ww_ctx);
+			if (err) {
+				if (err == -EDEADLK) {
+					*new_contended_rdev = c_rdev;
+					goto err_unlock;
+				}
 
-		if (c_rdev->supply)
-			regulator_unlock_dependent(c_rdev->supply->rdev);
+				/* shouldn't happen */
+				WARN_ON_ONCE(err != -EALREADY);
+			}
+		} else {
+			*old_contended_rdev = NULL;
+		}
+
+		if (c_rdev->supply) {
+			err = regulator_lock_recursive(c_rdev->supply->rdev,
+						       new_contended_rdev,
+						       old_contended_rdev,
+						       ww_ctx);
+			if (err) {
+				regulator_unlock(c_rdev);
+				goto err_unlock;
+			}
+		}
 	}
+
+	return 0;
+
+err_unlock:
+	regulator_unlock_recursive(rdev, i);
+
+	return err;
+}
+
+/**
+ * regulator_unlock_dependent - unlock regulator's suppliers and coupled
+ *				regulators
+ * @rdev:			regulator source
+ * @ww_ctx:			w/w mutex acquire context
+ *
+ * Unlock all regulators related with rdev by coupling or suppling.
+ */
+static void regulator_unlock_dependent(struct regulator_dev *rdev,
+				       struct ww_acquire_ctx *ww_ctx)
+{
+	regulator_unlock_recursive(rdev, rdev->coupling_desc.n_coupled);
+	ww_acquire_fini(ww_ctx);
 }
 
 /**
  * regulator_lock_dependent - lock regulator's suppliers and coupled regulators
  * @rdev:			regulator source
+ * @ww_ctx:			w/w mutex acquire context
  *
  * This function as a wrapper on regulator_lock_recursive(), which locks
  * all regulators related with rdev by coupling or suppling.
  */
-static inline void regulator_lock_dependent(struct regulator_dev *rdev)
+static void regulator_lock_dependent(struct regulator_dev *rdev,
+				     struct ww_acquire_ctx *ww_ctx)
 {
-	regulator_lock_recursive(rdev, 0);
+	struct regulator_dev *new_contended_rdev = NULL;
+	struct regulator_dev *old_contended_rdev = NULL;
+	int err;
+
+	mutex_lock(&regulator_list_mutex);
+
+	ww_acquire_init(ww_ctx, &regulator_ww_class);
+
+	do {
+		if (new_contended_rdev) {
+			ww_mutex_lock_slow(&new_contended_rdev->mutex, ww_ctx);
+			old_contended_rdev = new_contended_rdev;
+			old_contended_rdev->ref_cnt++;
+		}
+
+		err = regulator_lock_recursive(rdev,
+					       &new_contended_rdev,
+					       &old_contended_rdev,
+					       ww_ctx);
+
+		if (old_contended_rdev)
+			regulator_unlock(old_contended_rdev);
+
+	} while (err == -EDEADLK);
+
+	ww_acquire_done(ww_ctx);
+
+	mutex_unlock(&regulator_list_mutex);
 }
 
 /**
@@ -772,7 +870,7 @@ static int drms_uA_update(struct regulator_dev *rdev)
 	int current_uA = 0, output_uV, input_uV, err;
 	unsigned int mode;
 
-	lockdep_assert_held_once(&rdev->mutex);
+	lockdep_assert_held_once(&rdev->mutex.base);
 
 	/*
 	 * first check to see if we can set modes at all, otherwise just
@@ -2274,7 +2372,20 @@ static int _regulator_enable(struct regulator_dev *rdev)
 {
 	int ret;
 
-	lockdep_assert_held_once(&rdev->mutex);
+	lockdep_assert_held_once(&rdev->mutex.base);
+
+	if (rdev->supply) {
+		ret = _regulator_enable(rdev->supply->rdev);
+		if (ret < 0)
+			return ret;
+	}
+
+	/* balance only if there are regulators coupled */
+	if (rdev->coupling_desc.n_coupled > 1) {
+		ret = regulator_balance_voltage(rdev, PM_SUSPEND_ON);
+		if (ret < 0)
+			goto err_disable_supply;
+	}
 
 	/* check voltage and requested load before enabling */
 	if (regulator_ops_is_valid(rdev, REGULATOR_CHANGE_DRMS))
@@ -2285,18 +2396,20 @@ static int _regulator_enable(struct regulator_dev *rdev)
 		ret = _regulator_is_enabled(rdev);
 		if (ret == -EINVAL || ret == 0) {
 			if (!regulator_ops_is_valid(rdev,
-					REGULATOR_CHANGE_STATUS))
-				return -EPERM;
+					REGULATOR_CHANGE_STATUS)) {
+				ret = -EPERM;
+				goto err_disable_supply;
+			}
 
 			ret = _regulator_do_enable(rdev);
 			if (ret < 0)
-				return ret;
+				goto err_disable_supply;
 
 			_notifier_call_chain(rdev, REGULATOR_EVENT_ENABLE,
 					     NULL);
 		} else if (ret < 0) {
 			rdev_err(rdev, "is_enabled() failed: %d\n", ret);
-			return ret;
+			goto err_disable_supply;
 		}
 		/* Fallthrough on positive return values - already enabled */
 	}
@@ -2304,6 +2417,12 @@ static int _regulator_enable(struct regulator_dev *rdev)
 	rdev->use_count++;
 
 	return 0;
+
+err_disable_supply:
+	if (rdev->supply)
+		_regulator_disable(rdev->supply->rdev);
+
+	return ret;
 }
 
 /**
@@ -2320,30 +2439,15 @@ static int _regulator_enable(struct regulator_dev *rdev)
 int regulator_enable(struct regulator *regulator)
 {
 	struct regulator_dev *rdev = regulator->rdev;
+	struct ww_acquire_ctx ww_ctx;
 	int ret = 0;
 
 	if (regulator->always_on)
 		return 0;
 
-	if (rdev->supply) {
-		ret = regulator_enable(rdev->supply);
-		if (ret != 0)
-			return ret;
-	}
-
-	regulator_lock_dependent(rdev);
-	/* balance only if there are regulators coupled */
-	if (rdev->coupling_desc.n_coupled > 1) {
-		ret = regulator_balance_voltage(rdev, PM_SUSPEND_ON);
-		if (ret != 0)
-			goto unlock;
-	}
+	regulator_lock_dependent(rdev, &ww_ctx);
 	ret = _regulator_enable(rdev);
-unlock:
-	regulator_unlock_dependent(rdev);
-
-	if (ret != 0 && rdev->supply)
-		regulator_disable(rdev->supply);
+	regulator_unlock_dependent(rdev, &ww_ctx);
 
 	return ret;
 }
@@ -2385,7 +2489,7 @@ static int _regulator_disable(struct regulator_dev *rdev)
 {
 	int ret = 0;
 
-	lockdep_assert_held_once(&rdev->mutex);
+	lockdep_assert_held_once(&rdev->mutex.base);
 
 	if (WARN(rdev->use_count <= 0,
 		 "unbalanced disables for %s\n", rdev_get_name(rdev)))
@@ -2423,6 +2527,12 @@ static int _regulator_disable(struct regulator_dev *rdev)
 		rdev->use_count--;
 	}
 
+	if (ret == 0 && rdev->coupling_desc.n_coupled > 1)
+		ret = regulator_balance_voltage(rdev, PM_SUSPEND_ON);
+
+	if (ret == 0 && rdev->supply)
+		ret = _regulator_disable(rdev->supply->rdev);
+
 	return ret;
 }
 
@@ -2441,19 +2551,15 @@ static int _regulator_disable(struct regulator_dev *rdev)
 int regulator_disable(struct regulator *regulator)
 {
 	struct regulator_dev *rdev = regulator->rdev;
+	struct ww_acquire_ctx ww_ctx;
 	int ret = 0;
 
 	if (regulator->always_on)
 		return 0;
 
-	regulator_lock_dependent(rdev);
+	regulator_lock_dependent(rdev, &ww_ctx);
 	ret = _regulator_disable(rdev);
-	if (rdev->coupling_desc.n_coupled > 1)
-		regulator_balance_voltage(rdev, PM_SUSPEND_ON);
-	regulator_unlock_dependent(rdev);
-
-	if (ret == 0 && rdev->supply)
-		regulator_disable(rdev->supply);
+	regulator_unlock_dependent(rdev, &ww_ctx);
 
 	return ret;
 }
@@ -2464,7 +2570,7 @@ static int _regulator_force_disable(struct regulator_dev *rdev)
 {
 	int ret = 0;
 
-	lockdep_assert_held_once(&rdev->mutex);
+	lockdep_assert_held_once(&rdev->mutex.base);
 
 	ret = _notifier_call_chain(rdev, REGULATOR_EVENT_FORCE_DISABLE |
 			REGULATOR_EVENT_PRE_DISABLE, NULL);
@@ -2497,14 +2603,15 @@ static int _regulator_force_disable(struct regulator_dev *rdev)
 int regulator_force_disable(struct regulator *regulator)
 {
 	struct regulator_dev *rdev = regulator->rdev;
+	struct ww_acquire_ctx ww_ctx;
 	int ret;
 
-	regulator_lock_dependent(rdev);
+	regulator_lock_dependent(rdev, &ww_ctx);
 	regulator->uA_load = 0;
 	ret = _regulator_force_disable(regulator->rdev);
 	if (rdev->coupling_desc.n_coupled > 1)
 		regulator_balance_voltage(rdev, PM_SUSPEND_ON);
-	regulator_unlock_dependent(rdev);
+	regulator_unlock_dependent(rdev, &ww_ctx);
 
 	if (rdev->supply)
 		while (rdev->open_count--)
@@ -2518,9 +2625,10 @@ static void regulator_disable_work(struct work_struct *work)
 {
 	struct regulator_dev *rdev = container_of(work, struct regulator_dev,
 						  disable_work.work);
+	struct ww_acquire_ctx ww_ctx;
 	int count, i, ret;
 
-	regulator_lock(rdev);
+	regulator_lock_dependent(rdev, &ww_ctx);
 
 	BUG_ON(!rdev->deferred_disables);
 
@@ -2541,7 +2649,10 @@ static void regulator_disable_work(struct work_struct *work)
 			rdev_err(rdev, "Deferred disable failed: %d\n", ret);
 	}
 
-	regulator_unlock(rdev);
+	if (rdev->coupling_desc.n_coupled > 1)
+		regulator_balance_voltage(rdev, PM_SUSPEND_ON);
+
+	regulator_unlock_dependent(rdev, &ww_ctx);
 
 	if (rdev->supply) {
 		for (i = 0; i < count; i++) {
@@ -2652,9 +2763,9 @@ int regulator_is_enabled(struct regulator *regulator)
 	if (regulator->always_on)
 		return 1;
 
-	regulator_lock_dependent(regulator->rdev);
+	regulator_lock(regulator->rdev);
 	ret = _regulator_is_enabled(regulator->rdev);
-	regulator_unlock_dependent(regulator->rdev);
+	regulator_unlock(regulator->rdev);
 
 	return ret;
 }
@@ -3268,7 +3379,7 @@ static int regulator_get_optimal_voltage(struct regulator_dev *rdev,
 		int tmp_min = 0;
 		int tmp_max = INT_MAX;
 
-		lockdep_assert_held_once(&c_rdevs[i]->mutex);
+		lockdep_assert_held_once(&c_rdevs[i]->mutex.base);
 
 		ret = regulator_check_consumers(c_rdevs[i],
 						&tmp_min,
@@ -3479,14 +3590,15 @@ static int regulator_balance_voltage(struct regulator_dev *rdev,
  */
 int regulator_set_voltage(struct regulator *regulator, int min_uV, int max_uV)
 {
-	int ret = 0;
+	struct ww_acquire_ctx ww_ctx;
+	int ret;
 
-	regulator_lock_dependent(regulator->rdev);
+	regulator_lock_dependent(regulator->rdev, &ww_ctx);
 
 	ret = regulator_set_voltage_unlocked(regulator, min_uV, max_uV,
 					     PM_SUSPEND_ON);
 
-	regulator_unlock_dependent(regulator->rdev);
+	regulator_unlock_dependent(regulator->rdev, &ww_ctx);
 
 	return ret;
 }
@@ -3558,18 +3670,19 @@ static int _regulator_set_suspend_voltage(struct regulator *regulator,
 int regulator_set_suspend_voltage(struct regulator *regulator, int min_uV,
 				  int max_uV, suspend_state_t state)
 {
-	int ret = 0;
+	struct ww_acquire_ctx ww_ctx;
+	int ret;
 
 	/* PM_SUSPEND_ON is handled by regulator_set_voltage() */
 	if (regulator_check_states(state) || state == PM_SUSPEND_ON)
 		return -EINVAL;
 
-	regulator_lock_dependent(regulator->rdev);
+	regulator_lock_dependent(regulator->rdev, &ww_ctx);
 
 	ret = _regulator_set_suspend_voltage(regulator, min_uV,
 					     max_uV, state);
 
-	regulator_unlock_dependent(regulator->rdev);
+	regulator_unlock_dependent(regulator->rdev, &ww_ctx);
 
 	return ret;
 }
@@ -3759,13 +3872,12 @@ static int _regulator_get_voltage(struct regulator_dev *rdev)
  */
 int regulator_get_voltage(struct regulator *regulator)
 {
+	struct ww_acquire_ctx ww_ctx;
 	int ret;
 
-	regulator_lock_dependent(regulator->rdev);
-
+	regulator_lock_dependent(regulator->rdev, &ww_ctx);
 	ret = _regulator_get_voltage(regulator->rdev);
-
-	regulator_unlock_dependent(regulator->rdev);
+	regulator_unlock_dependent(regulator->rdev, &ww_ctx);
 
 	return ret;
 }
@@ -4301,7 +4413,7 @@ EXPORT_SYMBOL_GPL(regulator_bulk_free);
 int regulator_notifier_call_chain(struct regulator_dev *rdev,
 				  unsigned long event, void *data)
 {
-	lockdep_assert_held_once(&rdev->mutex);
+	lockdep_assert_held_once(&rdev->mutex.base);
 
 	_notifier_call_chain(rdev, event, data);
 	return NOTIFY_DONE;
@@ -4669,7 +4781,7 @@ regulator_register(const struct regulator_desc *regulator_desc,
 		rdev->dev.of_node = of_node_get(config->of_node);
 	}
 
-	mutex_init(&rdev->mutex);
+	ww_mutex_init(&rdev->mutex, &regulator_ww_class);
 	rdev->reg_data = config->driver_data;
 	rdev->owner = regulator_desc->owner;
 	rdev->desc = regulator_desc;
@@ -5026,8 +5138,6 @@ static void regulator_summary_show_subtree(struct seq_file *s,
 	if (!rdev)
 		return;
 
-	regulator_lock_nested(rdev, level);
-
 	opmode = _regulator_get_mode_unlocked(rdev);
 	seq_printf(s, "%*s%-*s %3d %4d %6d %7s ",
 		   level * 3 + 1, "",
@@ -5084,8 +5194,101 @@ static void regulator_summary_show_subtree(struct seq_file *s,
 
 	class_for_each_device(&regulator_class, NULL, &summary_data,
 			      regulator_summary_show_children);
+}
+
+struct summary_lock_data {
+	struct ww_acquire_ctx *ww_ctx;
+	struct regulator_dev **new_contended_rdev;
+	struct regulator_dev **old_contended_rdev;
+};
+
+static int regulator_summary_lock_one(struct device *dev, void *data)
+{
+	struct regulator_dev *rdev = dev_to_rdev(dev);
+	struct summary_lock_data *lock_data = data;
+	int ret = 0;
+
+	if (rdev != *lock_data->old_contended_rdev) {
+		ret = regulator_lock_nested(rdev, lock_data->ww_ctx);
+
+		if (ret == -EDEADLK)
+			*lock_data->new_contended_rdev = rdev;
+		else
+			WARN_ON_ONCE(ret);
+	} else {
+		*lock_data->old_contended_rdev = NULL;
+	}
+
+	return ret;
+}
+
+static int regulator_summary_unlock_one(struct device *dev, void *data)
+{
+	struct regulator_dev *rdev = dev_to_rdev(dev);
+	struct summary_lock_data *lock_data = data;
+
+	if (lock_data) {
+		if (rdev == *lock_data->new_contended_rdev)
+			return -EDEADLK;
+	}
 
 	regulator_unlock(rdev);
+
+	return 0;
+}
+
+static int regulator_summary_lock_all(struct ww_acquire_ctx *ww_ctx,
+				      struct regulator_dev **new_contended_rdev,
+				      struct regulator_dev **old_contended_rdev)
+{
+	struct summary_lock_data lock_data;
+	int ret;
+
+	lock_data.ww_ctx = ww_ctx;
+	lock_data.new_contended_rdev = new_contended_rdev;
+	lock_data.old_contended_rdev = old_contended_rdev;
+
+	ret = class_for_each_device(&regulator_class, NULL, &lock_data,
+				    regulator_summary_lock_one);
+	if (ret)
+		class_for_each_device(&regulator_class, NULL, &lock_data,
+				      regulator_summary_unlock_one);
+
+	return ret;
+}
+
+static void regulator_summary_lock(struct ww_acquire_ctx *ww_ctx)
+{
+	struct regulator_dev *new_contended_rdev = NULL;
+	struct regulator_dev *old_contended_rdev = NULL;
+	int err;
+
+	ww_acquire_init(ww_ctx, &regulator_ww_class);
+
+	do {
+		if (new_contended_rdev) {
+			ww_mutex_lock_slow(&new_contended_rdev->mutex, ww_ctx);
+			old_contended_rdev = new_contended_rdev;
+			old_contended_rdev->ref_cnt++;
+		}
+
+		err = regulator_summary_lock_all(ww_ctx,
+						 &new_contended_rdev,
+						 &old_contended_rdev);
+
+		if (old_contended_rdev)
+			regulator_unlock(old_contended_rdev);
+
+	} while (err == -EDEADLK);
+
+	ww_acquire_done(ww_ctx);
+}
+
+static void regulator_summary_unlock(struct ww_acquire_ctx *ww_ctx)
+{
+	class_for_each_device(&regulator_class, NULL, NULL,
+			      regulator_summary_unlock_one);
+	ww_acquire_fini(ww_ctx);
 }
 
 static int regulator_summary_show_roots(struct device *dev, void *data)
@@ -5101,12 +5304,18 @@ static int regulator_summary_show_roots(struct device *dev, void *data)
 
 static int regulator_summary_show(struct seq_file *s, void *data)
 {
+	struct ww_acquire_ctx ww_ctx;
+
 	seq_puts(s, " regulator                      use open bypass  opmode voltage current     min     max\n");
 	seq_puts(s, "---------------------------------------------------------------------------------------\n");
 
+	regulator_summary_lock(&ww_ctx);
+
 	class_for_each_device(&regulator_class, NULL, s,
 			      regulator_summary_show_roots);
 
+	regulator_summary_unlock(&ww_ctx);
+
 	return 0;
 }
 

commit fe06051dbf8abf5962d9258c4a863056bdfa6eae
Author: zoro <long17.cool@163.com>
Date:   Wed Nov 14 17:38:22 2018 +0800

    regulator/of_get_regulator: add child path to find the regulator supplier
    
    when the VIR_LDO1 regulator supplier is it's brother,
    we can't find the supplier.
    
    example code :
    &vir_regulator {
            ldo0_vir: ldo0-virtual {
                    regulator-compatible = "VIR_LDO0";
                    regulator-name= "VIR_LDO0";
                    regulator-min-microvolt = <1000000>;
                    regulator-max-microvolt = <2000000>;
            };
            ldo1_vir: ldo1-virtual {
                    regulator-compatible = "VIR_LDO1";
                    regulator-name= "VIR_LDO1";
                    regulator-min-microvolt = <1000000>;
                    regulator-max-microvolt = <3000000>;
                    ldo1-supply = <&ldo0_vir>;
            };
            ...
    }
    
    so we add the child ptah to find the suppier.
    
    Signed-off-by: zoro <long17.cool@163.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 2c66b528aede..55207264c212 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -227,6 +227,37 @@ static void regulator_unlock_supply(struct regulator_dev *rdev)
 	}
 }
 
+/**
+ * of_get_child_regulator - get a child regulator device node
+ * based on supply name
+ * @parent: Parent device node
+ * @prop_name: Combination regulator supply name and "-supply"
+ *
+ * Traverse all child nodes.
+ * Extract the child regulator device node corresponding to the supply name.
+ * returns the device node corresponding to the regulator if found, else
+ * returns NULL.
+ */
+static struct device_node *of_get_child_regulator(struct device_node *parent,
+						  const char *prop_name)
+{
+	struct device_node *regnode = NULL;
+	struct device_node *child = NULL;
+
+	for_each_child_of_node(parent, child) {
+		regnode = of_parse_phandle(child, prop_name, 0);
+
+		if (!regnode) {
+			regnode = of_get_child_regulator(child, prop_name);
+			if (regnode)
+				return regnode;
+		} else {
+			return regnode;
+		}
+	}
+	return NULL;
+}
+
 /**
  * of_get_regulator - get a regulator device node based on supply name
  * @dev: Device pointer for the consumer (of regulator) device
@@ -247,6 +278,10 @@ static struct device_node *of_get_regulator(struct device *dev, const char *supp
 	regnode = of_parse_phandle(dev->of_node, prop_name, 0);
 
 	if (!regnode) {
+		regnode = of_get_child_regulator(dev->of_node, prop_name);
+		if (regnode)
+			return regnode;
+
 		dev_dbg(dev, "Looking up %s property in node %pOF failed\n",
 				prop_name, dev->of_node);
 		return NULL;

commit 6303f3e78b6fd3f84dbe7f2fa4f108d47061d1fb
Author: Dmitry Osipenko <digetx@gmail.com>
Date:   Fri Oct 5 18:36:36 2018 +0300

    regulator: core: Decouple regulators on regulator_unregister()
    
    Regulators shall be uncoupled if one of the couples disappear.
    
    Signed-off-by: Dmitry Osipenko <digetx@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index ba03bdf3716f..783ec9c74104 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -4518,6 +4518,43 @@ static void regulator_resolve_coupling(struct regulator_dev *rdev)
 	}
 }
 
+static void regulator_remove_coupling(struct regulator_dev *rdev)
+{
+	struct coupling_desc *__c_desc, *c_desc = &rdev->coupling_desc;
+	struct regulator_dev *__c_rdev, *c_rdev;
+	unsigned int __n_coupled, n_coupled;
+	int i, k;
+
+	n_coupled = c_desc->n_coupled;
+
+	for (i = 1; i < n_coupled; i++) {
+		c_rdev = c_desc->coupled_rdevs[i];
+
+		if (!c_rdev)
+			continue;
+
+		regulator_lock(c_rdev);
+
+		__c_desc = &c_rdev->coupling_desc;
+		__n_coupled = __c_desc->n_coupled;
+
+		for (k = 1; k < __n_coupled; k++) {
+			__c_rdev = __c_desc->coupled_rdevs[k];
+
+			if (__c_rdev == rdev) {
+				__c_desc->coupled_rdevs[k] = NULL;
+				__c_desc->n_resolved--;
+				break;
+			}
+		}
+
+		regulator_unlock(c_rdev);
+
+		c_desc->coupled_rdevs[i] = NULL;
+		c_desc->n_resolved--;
+	}
+}
+
 static int regulator_init_coupling(struct regulator_dev *rdev)
 {
 	int n_phandles;
@@ -4776,6 +4813,7 @@ void regulator_unregister(struct regulator_dev *rdev)
 	debugfs_remove_recursive(rdev->debugfs);
 	flush_work(&rdev->disable_work.work);
 	WARN_ON(rdev->open_count);
+	regulator_remove_coupling(rdev);
 	unset_regulator_supplies(rdev);
 	list_del(&rdev->list);
 	regulator_ena_gpio_free(rdev);

commit 85254bcf394f93a8955814da1eef4d477b63eb84
Author: Dmitry Osipenko <digetx@gmail.com>
Date:   Fri Oct 5 18:36:35 2018 +0300

    regulator: core: Add new max_uV_step constraint
    
    On NVIDIA Tegra30 there is a requirement for regulator "A" to have voltage
    higher than voltage of regulator "B" by N microvolts, the N value changes
    depending on the voltage of regulator "B". This is similar to min-spread
    between voltages of regulators, the difference is that the spread value
    isn't fixed. This means that extra carefulness is required for regulator
    "A" to drop its voltage without violating the requirement, hence its
    voltage should be changed in steps so that its couple "B" could follow
    (there is also max-spread requirement).
    
    Add new "max_uV_step" constraint that breaks voltage change into several
    steps, each step is limited by the max_uV_step value.
    
    Signed-off-by: Dmitry Osipenko <digetx@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 089e8ad8ef57..ba03bdf3716f 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -3191,6 +3191,36 @@ static int regulator_set_voltage_rdev(struct regulator_dev *rdev, int min_uV,
 	return ret;
 }
 
+static int regulator_limit_voltage_step(struct regulator_dev *rdev,
+					int *current_uV, int *min_uV)
+{
+	struct regulation_constraints *constraints = rdev->constraints;
+
+	/* Limit voltage change only if necessary */
+	if (!constraints->max_uV_step || !_regulator_is_enabled(rdev))
+		return 1;
+
+	if (*current_uV < 0) {
+		*current_uV = _regulator_get_voltage(rdev);
+
+		if (*current_uV < 0)
+			return *current_uV;
+	}
+
+	if (abs(*current_uV - *min_uV) <= constraints->max_uV_step)
+		return 1;
+
+	/* Clamp target voltage within the given step */
+	if (*current_uV < *min_uV)
+		*min_uV = min(*current_uV + constraints->max_uV_step,
+			      *min_uV);
+	else
+		*min_uV = max(*current_uV - constraints->max_uV_step,
+			      *min_uV);
+
+	return 0;
+}
+
 static int regulator_get_optimal_voltage(struct regulator_dev *rdev,
 					 int *current_uV,
 					 int *min_uV, int *max_uV,
@@ -3302,6 +3332,17 @@ static int regulator_get_optimal_voltage(struct regulator_dev *rdev,
 	desired_min_uV = possible_uV;
 
 finish:
+	/* Apply max_uV_step constraint if necessary */
+	if (state == PM_SUSPEND_ON) {
+		ret = regulator_limit_voltage_step(rdev, current_uV,
+						   &desired_min_uV);
+		if (ret < 0)
+			return ret;
+
+		if (ret == 0)
+			done = false;
+	}
+
 	/* Set current_uV if wasn't done earlier in the code and if necessary */
 	if (n_coupled > 1 && *current_uV == -1) {
 

commit 79d6f049f4f05f5cb6e1647a9a253dad14bfabbe
Author: Dmitry Osipenko <digetx@gmail.com>
Date:   Fri Oct 5 18:36:31 2018 +0300

    regulator: core: Don't allow to get regulator until all couples resolved
    
    Don't allow to get regulator until all of its couples resolved because
    consumer will get EPERM and coupling shall be transparent for the drivers.
    
    Signed-off-by: Dmitry Osipenko <digetx@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 925df9e6f1e3..089e8ad8ef57 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1747,6 +1747,16 @@ struct regulator *_regulator_get(struct device *dev, const char *id,
 		return regulator;
 	}
 
+	mutex_lock(&regulator_list_mutex);
+	ret = (rdev->coupling_desc.n_resolved != rdev->coupling_desc.n_coupled);
+	mutex_unlock(&regulator_list_mutex);
+
+	if (ret != 0) {
+		regulator = ERR_PTR(-EPROBE_DEFER);
+		put_device(&rdev->dev);
+		return regulator;
+	}
+
 	ret = regulator_resolve_supply(rdev);
 	if (ret < 0) {
 		regulator = ERR_PTR(ret);

commit f9503385b1877ac34514cd5ea7683eee61c4bec3
Author: Dmitry Osipenko <digetx@gmail.com>
Date:   Fri Oct 5 18:36:30 2018 +0300

    regulator: core: Mutually resolve regulators coupling
    
    If registered regulator found a couple, then the couple can find the
    registered regulator too and hence coupling can be mutually resolved
    at the registration time.
    
    Signed-off-by: Dmitry Osipenko <digetx@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 5105eaaf3cef..925df9e6f1e3 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -4439,7 +4439,7 @@ static int regulator_register_resolve_supply(struct device *dev, void *data)
 	return 0;
 }
 
-static int regulator_fill_coupling_array(struct regulator_dev *rdev)
+static void regulator_resolve_coupling(struct regulator_dev *rdev)
 {
 	struct coupling_desc *c_desc = &rdev->coupling_desc;
 	int n_coupled = c_desc->n_coupled;
@@ -4453,33 +4453,21 @@ static int regulator_fill_coupling_array(struct regulator_dev *rdev)
 
 		c_rdev = of_parse_coupled_regulator(rdev, i - 1);
 
-		if (c_rdev) {
-			c_desc->coupled_rdevs[i] = c_rdev;
-			c_desc->n_resolved++;
-		}
-	}
-
-	if (rdev->coupling_desc.n_resolved < n_coupled)
-		return -1;
-	else
-		return 0;
-}
+		if (!c_rdev)
+			continue;
 
-static int regulator_register_fill_coupling_array(struct device *dev,
-						  void *data)
-{
-	struct regulator_dev *rdev = dev_to_rdev(dev);
+		regulator_lock(c_rdev);
 
-	if (!IS_ENABLED(CONFIG_OF))
-		return 0;
+		c_desc->coupled_rdevs[i] = c_rdev;
+		c_desc->n_resolved++;
 
-	if (regulator_fill_coupling_array(rdev))
-		rdev_dbg(rdev, "unable to resolve coupling\n");
+		regulator_unlock(c_rdev);
 
-	return 0;
+		regulator_resolve_coupling(c_rdev);
+	}
 }
 
-static int regulator_resolve_coupling(struct regulator_dev *rdev)
+static int regulator_init_coupling(struct regulator_dev *rdev)
 {
 	int n_phandles;
 
@@ -4519,13 +4507,6 @@ static int regulator_resolve_coupling(struct regulator_dev *rdev)
 	if (!of_check_coupling_data(rdev))
 		return -EPERM;
 
-	/*
-	 * After everything has been checked, try to fill rdevs array
-	 * with pointers to regulators parsed from device tree. If some
-	 * regulators are not registered yet, retry in late init call
-	 */
-	regulator_fill_coupling_array(rdev);
-
 	return 0;
 }
 
@@ -4662,11 +4643,8 @@ regulator_register(const struct regulator_desc *regulator_desc,
 	if (ret < 0)
 		goto wash;
 
-	mutex_lock(&regulator_list_mutex);
-	ret = regulator_resolve_coupling(rdev);
-	mutex_unlock(&regulator_list_mutex);
-
-	if (ret != 0)
+	ret = regulator_init_coupling(rdev);
+	if (ret < 0)
 		goto wash;
 
 	/* add consumers devices */
@@ -4700,6 +4678,11 @@ regulator_register(const struct regulator_desc *regulator_desc,
 
 	rdev_init_debugfs(rdev);
 
+	/* try to resolve regulators coupling since a new one was registered */
+	mutex_lock(&regulator_list_mutex);
+	regulator_resolve_coupling(rdev);
+	mutex_unlock(&regulator_list_mutex);
+
 	/* try to resolve regulators supply since a new one was registered */
 	class_for_each_device(&regulator_class, NULL, NULL,
 			      regulator_register_resolve_supply);
@@ -5155,9 +5138,6 @@ static int __init regulator_init_complete(void)
 	class_for_each_device(&regulator_class, NULL, NULL,
 			      regulator_late_cleanup);
 
-	class_for_each_device(&regulator_class, NULL, NULL,
-			      regulator_register_fill_coupling_array);
-
 	return 0;
 }
 late_initcall_sync(regulator_init_complete);

commit 9243a195be7af96a9b69990e9313c4ba1c5fbeca
Author: Maciej Purski <m.purski@samsung.com>
Date:   Fri Oct 5 18:36:29 2018 +0300

    regulator: core: Change voltage setting path
    
    On Odroid XU3/4 and other Exynos5422 based boards there is a case, that
    different devices on the board are supplied by different regulators
    with non-fixed voltages. If one of these devices temporarily requires
    higher voltage, there might occur a situation that the spread between
    two devices' voltages is so high, that there is a risk of changing
    'high' and 'low' states on the interconnection between devices powered
    by those regulators.
    
    Uncoupled regulators should be a special case of coupled regulators, so
    they should share a common voltage setting path. When enabling,
    disabling or setting voltage of a coupled regulator, all coupled
    regulators should be locked. Regulator's supplies should be locked, when
    setting voltage of a single regulator. Enabling a coupled regulator or
    setting its voltage should not be possible if some of its coupled
    regulators, has not been registered.
    
    Add function for locking coupled regulators and supplies. Extract
    a new function regulator_set_voltage_rdev() from
    regulator_set_voltage_unlocked(), which is called when setting
    voltage of a single regulator.
    
    Signed-off-by: Maciej Purski <m.purski@samsung.com>
    Signed-off-by: Dmitry Osipenko <digetx@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index a2a513780fd7..5105eaaf3cef 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -107,6 +107,9 @@ static int _regulator_do_set_voltage(struct regulator_dev *rdev,
 				     int min_uV, int max_uV);
 static int regulator_balance_voltage(struct regulator_dev *rdev,
 				     suspend_state_t state);
+static int regulator_set_voltage_rdev(struct regulator_dev *rdev,
+				      int min_uV, int max_uV,
+				      suspend_state_t state);
 static struct regulator *create_regulator(struct regulator_dev *rdev,
 					  struct device *dev,
 					  const char *supply_name);
@@ -198,37 +201,66 @@ static void regulator_unlock(struct regulator_dev *rdev)
 	}
 }
 
-/**
- * regulator_lock_supply - lock a regulator and its supplies
- * @rdev:         regulator source
- */
-static void regulator_lock_supply(struct regulator_dev *rdev)
+static int regulator_lock_recursive(struct regulator_dev *rdev,
+				    unsigned int subclass)
 {
+	struct regulator_dev *c_rdev;
 	int i;
 
-	for (i = 0; rdev; rdev = rdev_get_supply(rdev), i++)
-		regulator_lock_nested(rdev, i);
+	for (i = 0; i < rdev->coupling_desc.n_coupled; i++) {
+		c_rdev = rdev->coupling_desc.coupled_rdevs[i];
+
+		if (!c_rdev)
+			continue;
+
+		regulator_lock_nested(c_rdev, subclass++);
+
+		if (c_rdev->supply)
+			subclass =
+				regulator_lock_recursive(c_rdev->supply->rdev,
+							 subclass);
+	}
+
+	return subclass;
 }
 
 /**
- * regulator_unlock_supply - unlock a regulator and its supplies
- * @rdev:         regulator source
+ * regulator_unlock_dependent - unlock regulator's suppliers and coupled
+ *				regulators
+ * @rdev:			regulator source
+ *
+ * Unlock all regulators related with rdev by coupling or suppling.
  */
-static void regulator_unlock_supply(struct regulator_dev *rdev)
+static void regulator_unlock_dependent(struct regulator_dev *rdev)
 {
-	struct regulator *supply;
+	struct regulator_dev *c_rdev;
+	int i;
 
-	while (1) {
-		regulator_unlock(rdev);
-		supply = rdev->supply;
+	for (i = 0; i < rdev->coupling_desc.n_coupled; i++) {
+		c_rdev = rdev->coupling_desc.coupled_rdevs[i];
 
-		if (!rdev->supply)
-			return;
+		if (!c_rdev)
+			continue;
 
-		rdev = supply->rdev;
+		regulator_unlock(c_rdev);
+
+		if (c_rdev->supply)
+			regulator_unlock_dependent(c_rdev->supply->rdev);
 	}
 }
 
+/**
+ * regulator_lock_dependent - lock regulator's suppliers and coupled regulators
+ * @rdev:			regulator source
+ *
+ * This function as a wrapper on regulator_lock_recursive(), which locks
+ * all regulators related with rdev by coupling or suppling.
+ */
+static inline void regulator_lock_dependent(struct regulator_dev *rdev)
+{
+	regulator_lock_recursive(rdev, 0);
+}
+
 /**
  * of_get_regulator - get a regulator device node based on supply name
  * @dev: Device pointer for the consumer (of regulator) device
@@ -2289,9 +2321,16 @@ int regulator_enable(struct regulator *regulator)
 			return ret;
 	}
 
-	mutex_lock(&rdev->mutex);
+	regulator_lock_dependent(rdev);
+	/* balance only if there are regulators coupled */
+	if (rdev->coupling_desc.n_coupled > 1) {
+		ret = regulator_balance_voltage(rdev, PM_SUSPEND_ON);
+		if (ret != 0)
+			goto unlock;
+	}
 	ret = _regulator_enable(rdev);
-	mutex_unlock(&rdev->mutex);
+unlock:
+	regulator_unlock_dependent(rdev);
 
 	if (ret != 0 && rdev->supply)
 		regulator_disable(rdev->supply);
@@ -2397,9 +2436,11 @@ int regulator_disable(struct regulator *regulator)
 	if (regulator->always_on)
 		return 0;
 
-	mutex_lock(&rdev->mutex);
+	regulator_lock_dependent(rdev);
 	ret = _regulator_disable(rdev);
-	mutex_unlock(&rdev->mutex);
+	if (rdev->coupling_desc.n_coupled > 1)
+		regulator_balance_voltage(rdev, PM_SUSPEND_ON);
+	regulator_unlock_dependent(rdev);
 
 	if (ret == 0 && rdev->supply)
 		regulator_disable(rdev->supply);
@@ -2448,10 +2489,12 @@ int regulator_force_disable(struct regulator *regulator)
 	struct regulator_dev *rdev = regulator->rdev;
 	int ret;
 
-	mutex_lock(&rdev->mutex);
+	regulator_lock_dependent(rdev);
 	regulator->uA_load = 0;
 	ret = _regulator_force_disable(regulator->rdev);
-	mutex_unlock(&rdev->mutex);
+	if (rdev->coupling_desc.n_coupled > 1)
+		regulator_balance_voltage(rdev, PM_SUSPEND_ON);
+	regulator_unlock_dependent(rdev);
 
 	if (rdev->supply)
 		while (rdev->open_count--)
@@ -2599,9 +2642,9 @@ int regulator_is_enabled(struct regulator *regulator)
 	if (regulator->always_on)
 		return 1;
 
-	mutex_lock(&regulator->rdev->mutex);
+	regulator_lock_dependent(regulator->rdev);
 	ret = _regulator_is_enabled(regulator->rdev);
-	mutex_unlock(&regulator->rdev->mutex);
+	regulator_unlock_dependent(regulator->rdev);
 
 	return ret;
 }
@@ -3015,8 +3058,6 @@ static int regulator_set_voltage_unlocked(struct regulator *regulator,
 	int ret = 0;
 	int old_min_uV, old_max_uV;
 	int current_uV;
-	int best_supply_uV = 0;
-	int supply_change_uV = 0;
 
 	/* If we're setting the same range as last time the change
 	 * should be a noop (some cpufreq implementations use the same
@@ -3056,10 +3097,27 @@ static int regulator_set_voltage_unlocked(struct regulator *regulator,
 	voltage->min_uV = min_uV;
 	voltage->max_uV = max_uV;
 
-	ret = regulator_check_consumers(rdev, &min_uV, &max_uV, state);
+	/* for not coupled regulators this will just set the voltage */
+	ret = regulator_balance_voltage(rdev, state);
 	if (ret < 0)
 		goto out2;
 
+out:
+	return 0;
+out2:
+	voltage->min_uV = old_min_uV;
+	voltage->max_uV = old_max_uV;
+
+	return ret;
+}
+
+static int regulator_set_voltage_rdev(struct regulator_dev *rdev, int min_uV,
+				      int max_uV, suspend_state_t state)
+{
+	int best_supply_uV = 0;
+	int supply_change_uV = 0;
+	int ret;
+
 	if (rdev->supply &&
 	    regulator_ops_is_valid(rdev->supply->rdev,
 				   REGULATOR_CHANGE_VOLTAGE) &&
@@ -3071,13 +3129,13 @@ static int regulator_set_voltage_unlocked(struct regulator *regulator,
 		selector = regulator_map_voltage(rdev, min_uV, max_uV);
 		if (selector < 0) {
 			ret = selector;
-			goto out2;
+			goto out;
 		}
 
 		best_supply_uV = _regulator_list_voltage(rdev, selector, 0);
 		if (best_supply_uV < 0) {
 			ret = best_supply_uV;
-			goto out2;
+			goto out;
 		}
 
 		best_supply_uV += rdev->desc->min_dropout_uV;
@@ -3085,7 +3143,7 @@ static int regulator_set_voltage_unlocked(struct regulator *regulator,
 		current_supply_uV = _regulator_get_voltage(rdev->supply->rdev);
 		if (current_supply_uV < 0) {
 			ret = current_supply_uV;
-			goto out2;
+			goto out;
 		}
 
 		supply_change_uV = best_supply_uV - current_supply_uV;
@@ -3097,7 +3155,7 @@ static int regulator_set_voltage_unlocked(struct regulator *regulator,
 		if (ret) {
 			dev_err(&rdev->dev, "Failed to increase supply voltage: %d\n",
 					ret);
-			goto out2;
+			goto out;
 		}
 	}
 
@@ -3107,7 +3165,7 @@ static int regulator_set_voltage_unlocked(struct regulator *regulator,
 		ret = _regulator_do_set_suspend_voltage(rdev, min_uV,
 							max_uV, state);
 	if (ret < 0)
-		goto out2;
+		goto out;
 
 	if (supply_change_uV < 0) {
 		ret = regulator_set_voltage_unlocked(rdev->supply,
@@ -3120,11 +3178,6 @@ static int regulator_set_voltage_unlocked(struct regulator *regulator,
 	}
 
 out:
-	return ret;
-out2:
-	voltage->min_uV = old_min_uV;
-	voltage->max_uV = old_max_uV;
-
 	return ret;
 }
 
@@ -3340,10 +3393,10 @@ static int regulator_balance_voltage(struct regulator_dev *rdev,
 			ret = 0;
 			goto out;
 		}
-#if 0
+
 		ret = regulator_set_voltage_rdev(best_rdev, best_min_uV,
 						 best_max_uV, state);
-#endif
+
 		if (ret < 0)
 			goto out;
 
@@ -3377,12 +3430,12 @@ int regulator_set_voltage(struct regulator *regulator, int min_uV, int max_uV)
 {
 	int ret = 0;
 
-	regulator_lock_supply(regulator->rdev);
+	regulator_lock_dependent(regulator->rdev);
 
 	ret = regulator_set_voltage_unlocked(regulator, min_uV, max_uV,
 					     PM_SUSPEND_ON);
 
-	regulator_unlock_supply(regulator->rdev);
+	regulator_unlock_dependent(regulator->rdev);
 
 	return ret;
 }
@@ -3460,12 +3513,12 @@ int regulator_set_suspend_voltage(struct regulator *regulator, int min_uV,
 	if (regulator_check_states(state) || state == PM_SUSPEND_ON)
 		return -EINVAL;
 
-	regulator_lock_supply(regulator->rdev);
+	regulator_lock_dependent(regulator->rdev);
 
 	ret = _regulator_set_suspend_voltage(regulator, min_uV,
 					     max_uV, state);
 
-	regulator_unlock_supply(regulator->rdev);
+	regulator_unlock_dependent(regulator->rdev);
 
 	return ret;
 }
@@ -3657,11 +3710,11 @@ int regulator_get_voltage(struct regulator *regulator)
 {
 	int ret;
 
-	regulator_lock_supply(regulator->rdev);
+	regulator_lock_dependent(regulator->rdev);
 
 	ret = _regulator_get_voltage(regulator->rdev);
 
-	regulator_unlock_supply(regulator->rdev);
+	regulator_unlock_dependent(regulator->rdev);
 
 	return ret;
 }

commit c054c6c792e165de2be51bc3feeaf3cebdedc8d6
Author: Maciej Purski <m.purski@samsung.com>
Date:   Fri Oct 5 18:36:28 2018 +0300

    regulator: core: Add voltage balancing mechanism
    
    On Odroid XU3/4 and other Exynos5422 based boards there is a case, that
    different devices on the board are supplied by different regulators
    with non-fixed voltages. If one of these devices temporarily requires
    higher voltage, there might occur a situation that the spread between
    two devices' voltages is so high, that there is a risk of changing
    'high' and 'low' states on the interconnection between devices powered
    by those regulators.
    
    Introduce new function regulator_balance_voltage(), which
    keeps max_spread constraint fulfilled between a group of coupled
    regulators. It should be called if a regulator changes its
    voltage or after disabling or enabling. Disabled regulators should
    follow changes of the enabled ones, but their consumers' demands
    shouldn't be taken into account while calculating voltage of other
    coupled regulators.
    
    Find voltages, which are closest to suiting all the consumers' demands,
    while fulfilling max_spread constraint, keeping the following rules:
    - if one regulator is about to rise its voltage, rise others
      voltages in order to keep the max_spread
    - if a regulator, which has caused rising other regulators, is
      lowered, lower other regulators if possible
    - if one regulator is about to lower its voltage, but it hasn't caused
      rising other regulators, change its voltage so that it doesn't break the
      max_spread
    
    Change regulators' voltages step by step, keeping max_spread constraint
    fulfilled all the time. Function regulator_get_optimal_voltage()
    should find the best possible change for the regulator, which doesn't
    break max_spread constraint. In function regulator_balance_voltage()
    optimize number of steps by finding highest voltage difference on
    each iteration.
    
    If a regulator, which is about to change its voltage, is not coupled,
    method regulator_get_optimal_voltage() should simply return the lowest
    voltage fulfilling consumers' demands.
    
    Coupling should be checked only if the system is in PM_SUSPEND_ON state.
    
    Signed-off-by: Maciej Purski <m.purski@samsung.com>
    Signed-off-by: Dmitry Osipenko <digetx@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 2c66b528aede..a2a513780fd7 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -105,6 +105,8 @@ static int _notifier_call_chain(struct regulator_dev *rdev,
 				  unsigned long event, void *data);
 static int _regulator_do_set_voltage(struct regulator_dev *rdev,
 				     int min_uV, int max_uV);
+static int regulator_balance_voltage(struct regulator_dev *rdev,
+				     suspend_state_t state);
 static struct regulator *create_regulator(struct regulator_dev *rdev,
 					  struct device *dev,
 					  const char *supply_name);
@@ -3126,6 +3128,233 @@ static int regulator_set_voltage_unlocked(struct regulator *regulator,
 	return ret;
 }
 
+static int regulator_get_optimal_voltage(struct regulator_dev *rdev,
+					 int *current_uV,
+					 int *min_uV, int *max_uV,
+					 suspend_state_t state,
+					 int n_coupled)
+{
+	struct coupling_desc *c_desc = &rdev->coupling_desc;
+	struct regulator_dev **c_rdevs = c_desc->coupled_rdevs;
+	struct regulation_constraints *constraints = rdev->constraints;
+	int max_spread = constraints->max_spread;
+	int desired_min_uV = 0, desired_max_uV = INT_MAX;
+	int max_current_uV = 0, min_current_uV = INT_MAX;
+	int highest_min_uV = 0, target_uV, possible_uV;
+	int i, ret;
+	bool done;
+
+	*current_uV = -1;
+
+	/*
+	 * If there are no coupled regulators, simply set the voltage
+	 * demanded by consumers.
+	 */
+	if (n_coupled == 1) {
+		/*
+		 * If consumers don't provide any demands, set voltage
+		 * to min_uV
+		 */
+		desired_min_uV = constraints->min_uV;
+		desired_max_uV = constraints->max_uV;
+
+		ret = regulator_check_consumers(rdev,
+						&desired_min_uV,
+						&desired_max_uV, state);
+		if (ret < 0)
+			return ret;
+
+		possible_uV = desired_min_uV;
+		done = true;
+
+		goto finish;
+	}
+
+	/* Find highest min desired voltage */
+	for (i = 0; i < n_coupled; i++) {
+		int tmp_min = 0;
+		int tmp_max = INT_MAX;
+
+		lockdep_assert_held_once(&c_rdevs[i]->mutex);
+
+		ret = regulator_check_consumers(c_rdevs[i],
+						&tmp_min,
+						&tmp_max, state);
+		if (ret < 0)
+			return ret;
+
+		ret = regulator_check_voltage(c_rdevs[i], &tmp_min, &tmp_max);
+		if (ret < 0)
+			return ret;
+
+		highest_min_uV = max(highest_min_uV, tmp_min);
+
+		if (i == 0) {
+			desired_min_uV = tmp_min;
+			desired_max_uV = tmp_max;
+		}
+	}
+
+	/*
+	 * Let target_uV be equal to the desired one if possible.
+	 * If not, set it to minimum voltage, allowed by other coupled
+	 * regulators.
+	 */
+	target_uV = max(desired_min_uV, highest_min_uV - max_spread);
+
+	/*
+	 * Find min and max voltages, which currently aren't violating
+	 * max_spread.
+	 */
+	for (i = 1; i < n_coupled; i++) {
+		int tmp_act;
+
+		if (!_regulator_is_enabled(c_rdevs[i]))
+			continue;
+
+		tmp_act = _regulator_get_voltage(c_rdevs[i]);
+		if (tmp_act < 0)
+			return tmp_act;
+
+		min_current_uV = min(tmp_act, min_current_uV);
+		max_current_uV = max(tmp_act, max_current_uV);
+	}
+
+	/* There aren't any other regulators enabled */
+	if (max_current_uV == 0) {
+		possible_uV = target_uV;
+	} else {
+		/*
+		 * Correct target voltage, so as it currently isn't
+		 * violating max_spread
+		 */
+		possible_uV = max(target_uV, max_current_uV - max_spread);
+		possible_uV = min(possible_uV, min_current_uV + max_spread);
+	}
+
+	if (possible_uV > desired_max_uV)
+		return -EINVAL;
+
+	done = (possible_uV == target_uV);
+	desired_min_uV = possible_uV;
+
+finish:
+	/* Set current_uV if wasn't done earlier in the code and if necessary */
+	if (n_coupled > 1 && *current_uV == -1) {
+
+		if (_regulator_is_enabled(rdev)) {
+			ret = _regulator_get_voltage(rdev);
+			if (ret < 0)
+				return ret;
+
+			*current_uV = ret;
+		} else {
+			*current_uV = desired_min_uV;
+		}
+	}
+
+	*min_uV = desired_min_uV;
+	*max_uV = desired_max_uV;
+
+	return done;
+}
+
+static int regulator_balance_voltage(struct regulator_dev *rdev,
+				     suspend_state_t state)
+{
+	struct regulator_dev **c_rdevs;
+	struct regulator_dev *best_rdev;
+	struct coupling_desc *c_desc = &rdev->coupling_desc;
+	int i, ret, n_coupled, best_min_uV, best_max_uV, best_c_rdev;
+	bool best_c_rdev_done, c_rdev_done[MAX_COUPLED];
+	unsigned int delta, best_delta;
+
+	c_rdevs = c_desc->coupled_rdevs;
+	n_coupled = c_desc->n_coupled;
+
+	/*
+	 * If system is in a state other than PM_SUSPEND_ON, don't check
+	 * other coupled regulators.
+	 */
+	if (state != PM_SUSPEND_ON)
+		n_coupled = 1;
+
+	if (c_desc->n_resolved < n_coupled) {
+		rdev_err(rdev, "Not all coupled regulators registered\n");
+		return -EPERM;
+	}
+
+	for (i = 0; i < n_coupled; i++)
+		c_rdev_done[i] = false;
+
+	/*
+	 * Find the best possible voltage change on each loop. Leave the loop
+	 * if there isn't any possible change.
+	 */
+	do {
+		best_c_rdev_done = false;
+		best_delta = 0;
+		best_min_uV = 0;
+		best_max_uV = 0;
+		best_c_rdev = 0;
+		best_rdev = NULL;
+
+		/*
+		 * Find highest difference between optimal voltage
+		 * and current voltage.
+		 */
+		for (i = 0; i < n_coupled; i++) {
+			/*
+			 * optimal_uV is the best voltage that can be set for
+			 * i-th regulator at the moment without violating
+			 * max_spread constraint in order to balance
+			 * the coupled voltages.
+			 */
+			int optimal_uV = 0, optimal_max_uV = 0, current_uV = 0;
+
+			if (c_rdev_done[i])
+				continue;
+
+			ret = regulator_get_optimal_voltage(c_rdevs[i],
+							    &current_uV,
+							    &optimal_uV,
+							    &optimal_max_uV,
+							    state, n_coupled);
+			if (ret < 0)
+				goto out;
+
+			delta = abs(optimal_uV - current_uV);
+
+			if (delta && best_delta <= delta) {
+				best_c_rdev_done = ret;
+				best_delta = delta;
+				best_rdev = c_rdevs[i];
+				best_min_uV = optimal_uV;
+				best_max_uV = optimal_max_uV;
+				best_c_rdev = i;
+			}
+		}
+
+		/* Nothing to change, return successfully */
+		if (!best_rdev) {
+			ret = 0;
+			goto out;
+		}
+#if 0
+		ret = regulator_set_voltage_rdev(best_rdev, best_min_uV,
+						 best_max_uV, state);
+#endif
+		if (ret < 0)
+			goto out;
+
+		c_rdev_done[best_c_rdev] = best_c_rdev_done;
+
+	} while (n_coupled > 1);
+
+out:
+	return ret;
+}
+
 /**
  * regulator_set_voltage - set regulator output voltage
  * @regulator: regulator source

commit 5451521409ce1c04d56c03854008fe8861893b05
Merge: 5a7d7d0f9f79 2ece646c90c5
Author: Mark Brown <broonie@kernel.org>
Date:   Fri Sep 28 15:07:30 2018 +0100

    Merge tag 'bd71847-support' into regulator-4.20
    
    regulator/mfd: Support for the ROHM BD71847
    
    This adds support for the BD71847 which touches both MFD and regulator.
    There's a few other bits and pieces included as some dependency patches
    had already been applied so would've required rebasing.

commit 18e4b55fbd2069cee51ef9660b35c65ec13bee6d
Author: Matti Vaittinen <matti.vaittinen@fi.rohmeurope.com>
Date:   Fri Sep 14 11:31:36 2018 +0300

    regulator: Support regulators where voltage ranges are selectable
    
    For example ROHM BD71837 and ROHM BD71847 Power management ICs have
    regulators which provide multiple linear ranges. Ranges can be
    selected by individual non contagious bit in vsel register. Add
    regmap helper functions for selecting ranges.
    
    Signed-off-by: Matti Vaittinen <matti.vaittinen@fi.rohmeurope.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 9577d8941846..4b1755a8ef00 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2783,6 +2783,11 @@ static int regulator_map_voltage(struct regulator_dev *rdev, int min_uV,
 	if (desc->ops->list_voltage == regulator_list_voltage_linear_range)
 		return regulator_map_voltage_linear_range(rdev, min_uV, max_uV);
 
+	if (desc->ops->list_voltage ==
+		regulator_list_voltage_pickable_linear_range)
+		return regulator_map_voltage_pickable_linear_range(rdev,
+							min_uV, max_uV);
+
 	return regulator_map_voltage_iterate(rdev, min_uV, max_uV);
 }
 

commit fb6de923ca3358a91525552b4907d4cb38730bdd
Author: Yu Zhao <yuzhao@google.com>
Date:   Wed Sep 19 15:30:51 2018 -0600

    regulator: fix crash caused by null driver data
    
    dev_set_drvdata() needs to be called before device_register()
    exposes device to userspace. Otherwise kernel crashes after it
    gets null pointer from dev_get_drvdata() when userspace tries
    to access sysfs entries.
    
    [Removed backtrace for length -- broonie]
    
    Signed-off-by: Yu Zhao <yuzhao@google.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Cc: stable@vger.kernel.org

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 90215f57270f..9577d8941846 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -4395,13 +4395,13 @@ regulator_register(const struct regulator_desc *regulator_desc,
 	    !rdev->desc->fixed_uV)
 		rdev->is_switch = true;
 
+	dev_set_drvdata(&rdev->dev, rdev);
 	ret = device_register(&rdev->dev);
 	if (ret != 0) {
 		put_device(&rdev->dev);
 		goto unset_supplies;
 	}
 
-	dev_set_drvdata(&rdev->dev, rdev);
 	rdev_init_debugfs(rdev);
 
 	/* try to resolve regulators supply since a new one was registered */

commit 1efef7cc72716a168f37c0cc19889a4bf9ee8603
Author: Randy Dunlap <rdunlap@infradead.org>
Date:   Tue Sep 4 08:30:05 2018 -0700

    regulator: fix kernel-doc for regulator_suspend()
    
    Fix kernel-doc warning:
    
    ../drivers/regulator/core.c:4479: warning: Excess function parameter 'state' description in 'regulator_suspend'
    
    Signed-off-by: Randy Dunlap <rdunlap@infradead.org>
    Cc: Liam Girdwood <lgirdwood@gmail.com>
    Cc: Mark Brown <broonie@kernel.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index a147871af09b..45fee12b9878 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -4466,7 +4466,7 @@ EXPORT_SYMBOL_GPL(regulator_unregister);
 #ifdef CONFIG_SUSPEND
 /**
  * regulator_suspend - prepare regulators for system wide suspend
- * @state: system suspend state
+ * @dev: ``&struct device`` pointer that is passed to _regulator_suspend()
  *
  * Configure each regulator with it's suspend operating parameters for state.
  */

commit cd7e36ab7222af85597517bafd66013cbc8f9877
Author: Marek Szyprowski <m.szyprowski@samsung.com>
Date:   Mon Sep 3 16:49:36 2018 +0200

    regulator: Fix useless O^2 complexity in suspend/resume
    
    regulator_pm_ops with regulator_suspend and regulator_resume functions are
    assigned to every regulator device registered in the system, so there is no
    need to iterate over all again in them. Replace class_for_each_device()
    construction with direct operation on the rdev embedded in the given
    regulator device. This saves a lots of useless operations in suspend and
    resume paths.
    
    Fixes: f7efad10b5c4: regulator: add PM suspend and resume hooks
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index f686f2311317..a147871af09b 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -4464,19 +4464,6 @@ void regulator_unregister(struct regulator_dev *rdev)
 EXPORT_SYMBOL_GPL(regulator_unregister);
 
 #ifdef CONFIG_SUSPEND
-static int _regulator_suspend(struct device *dev, void *data)
-{
-	struct regulator_dev *rdev = dev_to_rdev(dev);
-	suspend_state_t *state = data;
-	int ret;
-
-	regulator_lock(rdev);
-	ret = suspend_set_state(rdev, *state);
-	regulator_unlock(rdev);
-
-	return ret;
-}
-
 /**
  * regulator_suspend - prepare regulators for system wide suspend
  * @state: system suspend state
@@ -4485,20 +4472,25 @@ static int _regulator_suspend(struct device *dev, void *data)
  */
 static int regulator_suspend(struct device *dev)
 {
+	struct regulator_dev *rdev = dev_to_rdev(dev);
 	suspend_state_t state = pm_suspend_target_state;
+	int ret;
+
+	regulator_lock(rdev);
+	ret = suspend_set_state(rdev, state);
+	regulator_unlock(rdev);
 
-	return class_for_each_device(&regulator_class, NULL, &state,
-				     _regulator_suspend);
+	return ret;
 }
 
-static int _regulator_resume(struct device *dev, void *data)
+static int regulator_resume(struct device *dev)
 {
-	int ret = 0;
+	suspend_state_t state = pm_suspend_target_state;
 	struct regulator_dev *rdev = dev_to_rdev(dev);
-	suspend_state_t *state = data;
 	struct regulator_state *rstate;
+	int ret = 0;
 
-	rstate = regulator_get_suspend_state(rdev, *state);
+	rstate = regulator_get_suspend_state(rdev, state);
 	if (rstate == NULL)
 		return 0;
 
@@ -4513,15 +4505,6 @@ static int _regulator_resume(struct device *dev, void *data)
 
 	return ret;
 }
-
-static int regulator_resume(struct device *dev)
-{
-	suspend_state_t state = pm_suspend_target_state;
-
-	return class_for_each_device(&regulator_class, NULL, &state,
-				     _regulator_resume);
-}
-
 #else /* !CONFIG_SUSPEND */
 
 #define regulator_suspend	NULL

commit 3edd79cf5a44b12dbb13bc320f5788aed6562b36
Author: Marek Szyprowski <m.szyprowski@samsung.com>
Date:   Mon Sep 3 16:49:37 2018 +0200

    regulator: Fix 'do-nothing' value for regulators without suspend state
    
    Some regulators don't have all states defined and in such cases regulator
    core should not assume anything. However in current implementation
    of of_get_regulation_constraints() DO_NOTHING_IN_SUSPEND enable value was
    set only for regulators which had suspend node defined, otherwise the
    default 0 value was used, what means DISABLE_IN_SUSPEND. This lead to
    broken system suspend/resume on boards, which had simple regulator
    constraints definition (without suspend state nodes).
    
    To avoid further mismatches between the default and uninitialized values
    of the suspend enabled/disabled states, change the values of the them,
    so default '0' means DO_NOTHING_IN_SUSPEND.
    
    Fixes: 72069f9957a1: regulator: leave one item to record whether regulator is enabled
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Cc: stable@vger.kernel.org

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index bb1324f93143..90215f57270f 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -3161,7 +3161,7 @@ static inline int regulator_suspend_toggle(struct regulator_dev *rdev,
 	if (!rstate->changeable)
 		return -EPERM;
 
-	rstate->enabled = en;
+	rstate->enabled = (en) ? ENABLE_IN_SUSPEND : DISABLE_IN_SUSPEND;
 
 	return 0;
 }

commit 7e4d9683d6a716533f5c5026795b7b1ebdbcb2ed
Author: Douglas Anderson <dianders@chromium.org>
Date:   Thu Aug 16 13:28:03 2018 -0700

    regulator: core: Add locking to debugfs regulator_summary
    
    Most functions that access the rdev lock the rdev mutex before looking
    at data.  ...but not the code that implements the debugfs
    regulator_summary.  It probably should though, so let's do it.
    
    Note: this fixes no known issues.  The problem was found only by code
    inspection.
    
    Signed-off-by: Douglas Anderson <dianders@chromium.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index df55cf8f09f0..f686f2311317 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -3475,21 +3475,23 @@ int regulator_set_current_limit(struct regulator *regulator,
 }
 EXPORT_SYMBOL_GPL(regulator_set_current_limit);
 
+static int _regulator_get_current_limit_unlocked(struct regulator_dev *rdev)
+{
+	/* sanity check */
+	if (!rdev->desc->ops->get_current_limit)
+		return -EINVAL;
+
+	return rdev->desc->ops->get_current_limit(rdev);
+}
+
 static int _regulator_get_current_limit(struct regulator_dev *rdev)
 {
 	int ret;
 
 	regulator_lock(rdev);
-
-	/* sanity check */
-	if (!rdev->desc->ops->get_current_limit) {
-		ret = -EINVAL;
-		goto out;
-	}
-
-	ret = rdev->desc->ops->get_current_limit(rdev);
-out:
+	ret = _regulator_get_current_limit_unlocked(rdev);
 	regulator_unlock(rdev);
+
 	return ret;
 }
 
@@ -3554,21 +3556,23 @@ int regulator_set_mode(struct regulator *regulator, unsigned int mode)
 }
 EXPORT_SYMBOL_GPL(regulator_set_mode);
 
+static unsigned int _regulator_get_mode_unlocked(struct regulator_dev *rdev)
+{
+	/* sanity check */
+	if (!rdev->desc->ops->get_mode)
+		return -EINVAL;
+
+	return rdev->desc->ops->get_mode(rdev);
+}
+
 static unsigned int _regulator_get_mode(struct regulator_dev *rdev)
 {
 	int ret;
 
 	regulator_lock(rdev);
-
-	/* sanity check */
-	if (!rdev->desc->ops->get_mode) {
-		ret = -EINVAL;
-		goto out;
-	}
-
-	ret = rdev->desc->ops->get_mode(rdev);
-out:
+	ret = _regulator_get_mode_unlocked(rdev);
 	regulator_unlock(rdev);
+
 	return ret;
 }
 
@@ -4675,18 +4679,23 @@ static void regulator_summary_show_subtree(struct seq_file *s,
 	struct regulation_constraints *c;
 	struct regulator *consumer;
 	struct summary_data summary_data;
+	unsigned int opmode;
 
 	if (!rdev)
 		return;
 
+	regulator_lock_nested(rdev, level);
+
+	opmode = _regulator_get_mode_unlocked(rdev);
 	seq_printf(s, "%*s%-*s %3d %4d %6d %7s ",
 		   level * 3 + 1, "",
 		   30 - level * 3, rdev_get_name(rdev),
 		   rdev->use_count, rdev->open_count, rdev->bypass_count,
-		   regulator_opmode_to_str(_regulator_get_mode(rdev)));
+		   regulator_opmode_to_str(opmode));
 
 	seq_printf(s, "%5dmV ", _regulator_get_voltage(rdev) / 1000);
-	seq_printf(s, "%5dmA ", _regulator_get_current_limit(rdev) / 1000);
+	seq_printf(s, "%5dmA ",
+		   _regulator_get_current_limit_unlocked(rdev) / 1000);
 
 	c = rdev->constraints;
 	if (c) {
@@ -4733,6 +4742,8 @@ static void regulator_summary_show_subtree(struct seq_file *s,
 
 	class_for_each_device(&regulator_class, NULL, &summary_data,
 			      regulator_summary_show_children);
+
+	regulator_unlock(rdev);
 }
 
 static int regulator_summary_show_roots(struct device *dev, void *data)

commit 7d3827b5954840ff7765aef282257b7368b5ea67
Author: Douglas Anderson <dianders@chromium.org>
Date:   Thu Aug 16 13:28:02 2018 -0700

    regulator: core: Add consumer-requested load in regulator_summary
    
    It's handy to see the load requested by a regulator consumer in the
    regulator_summary.  Add it.
    
    Signed-off-by: Douglas Anderson <dianders@chromium.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 69b64e5ffc76..df55cf8f09f0 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -4715,7 +4715,8 @@ static void regulator_summary_show_subtree(struct seq_file *s,
 
 		switch (rdev->desc->type) {
 		case REGULATOR_VOLTAGE:
-			seq_printf(s, "%45dmV %5dmV",
+			seq_printf(s, "%37dmA %5dmV %5dmV",
+				   consumer->uA_load / 1000,
 				   consumer->voltage[PM_SUSPEND_ON].min_uV / 1000,
 				   consumer->voltage[PM_SUSPEND_ON].max_uV / 1000);
 			break;

commit 01de19d09ce6129740b318687a92c137451d2369
Author: Douglas Anderson <dianders@chromium.org>
Date:   Thu Aug 16 13:28:01 2018 -0700

    regulator: core: Add the opmode to regulator_summary
    
    It's handy to know what opmode a regulator has been configured to in
    the summary.  Add it.
    
    Signed-off-by: Douglas Anderson <dianders@chromium.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index bb1324f93143..69b64e5ffc76 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -426,19 +426,24 @@ static ssize_t name_show(struct device *dev, struct device_attribute *attr,
 }
 static DEVICE_ATTR_RO(name);
 
-static ssize_t regulator_print_opmode(char *buf, int mode)
+static const char *regulator_opmode_to_str(int mode)
 {
 	switch (mode) {
 	case REGULATOR_MODE_FAST:
-		return sprintf(buf, "fast\n");
+		return "fast";
 	case REGULATOR_MODE_NORMAL:
-		return sprintf(buf, "normal\n");
+		return "normal";
 	case REGULATOR_MODE_IDLE:
-		return sprintf(buf, "idle\n");
+		return "idle";
 	case REGULATOR_MODE_STANDBY:
-		return sprintf(buf, "standby\n");
+		return "standby";
 	}
-	return sprintf(buf, "unknown\n");
+	return "unknown";
+}
+
+static ssize_t regulator_print_opmode(char *buf, int mode)
+{
+	return sprintf(buf, "%s\n", regulator_opmode_to_str(mode));
 }
 
 static ssize_t regulator_opmode_show(struct device *dev,
@@ -4674,10 +4679,11 @@ static void regulator_summary_show_subtree(struct seq_file *s,
 	if (!rdev)
 		return;
 
-	seq_printf(s, "%*s%-*s %3d %4d %6d ",
+	seq_printf(s, "%*s%-*s %3d %4d %6d %7s ",
 		   level * 3 + 1, "",
 		   30 - level * 3, rdev_get_name(rdev),
-		   rdev->use_count, rdev->open_count, rdev->bypass_count);
+		   rdev->use_count, rdev->open_count, rdev->bypass_count,
+		   regulator_opmode_to_str(_regulator_get_mode(rdev)));
 
 	seq_printf(s, "%5dmV ", _regulator_get_voltage(rdev) / 1000);
 	seq_printf(s, "%5dmA ", _regulator_get_current_limit(rdev) / 1000);
@@ -4709,7 +4715,7 @@ static void regulator_summary_show_subtree(struct seq_file *s,
 
 		switch (rdev->desc->type) {
 		case REGULATOR_VOLTAGE:
-			seq_printf(s, "%37dmV %5dmV",
+			seq_printf(s, "%45dmV %5dmV",
 				   consumer->voltage[PM_SUSPEND_ON].min_uV / 1000,
 				   consumer->voltage[PM_SUSPEND_ON].max_uV / 1000);
 			break;
@@ -4741,8 +4747,8 @@ static int regulator_summary_show_roots(struct device *dev, void *data)
 
 static int regulator_summary_show(struct seq_file *s, void *data)
 {
-	seq_puts(s, " regulator                      use open bypass voltage current     min     max\n");
-	seq_puts(s, "-------------------------------------------------------------------------------\n");
+	seq_puts(s, " regulator                      use open bypass  opmode voltage current     min     max\n");
+	seq_puts(s, "---------------------------------------------------------------------------------------\n");
 
 	class_for_each_device(&regulator_class, NULL, s,
 			      regulator_summary_show_roots);

commit ed1ae2dd9f242c7a36e8e39100f6a7f6bcdfdd89
Author: pascal paillet <p.paillet@st.com>
Date:   Thu Jul 5 14:25:56 2018 +0000

    regulator: core: Link consumer with regulator driver
    
    Add a device link between the consumer and the driver so that
    the consumer is not suspended before the driver. The goal is to avoid
    implementing suspend_late ops in regulator drivers.
    
    Signed-off-by: pascal paillet <p.paillet@st.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index da9b0fed8330..bb1324f93143 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1740,6 +1740,8 @@ struct regulator *_regulator_get(struct device *dev, const char *id,
 			rdev->use_count = 0;
 	}
 
+	device_link_add(dev, &rdev->dev, DL_FLAG_STATELESS);
+
 	return regulator;
 }
 
@@ -1829,9 +1831,21 @@ static void _regulator_put(struct regulator *regulator)
 
 	debugfs_remove_recursive(regulator->debugfs);
 
-	/* remove any sysfs entries */
-	if (regulator->dev)
+	if (regulator->dev) {
+		int count = 0;
+		struct regulator *r;
+
+		list_for_each_entry(r, &rdev->consumer_list, list)
+			if (r->dev == regulator->dev)
+				count++;
+
+		if (count == 1)
+			device_link_remove(regulator->dev, &rdev->dev);
+
+		/* remove any sysfs entries */
 		sysfs_remove_link(&rdev->dev.kobj, regulator->supply_name);
+	}
+
 	regulator_lock(rdev);
 	list_del(&regulator->list);
 

commit 0380cf7dbaca75c524e34b30979f0806124fa8e6
Author: pascal paillet <p.paillet@st.com>
Date:   Thu Jul 5 14:25:57 2018 +0000

    regulator: core: Change suspend_late to suspend
    
    Change suspend_late ops to suspend normal ops. The goal is to avoid
    requesting all the regulator drivers to be operational in suspend late
    phase.
    
    Signed-off-by: pascal paillet <p.paillet@st.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 6ed568b96c0e..da9b0fed8330 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -4441,7 +4441,7 @@ void regulator_unregister(struct regulator_dev *rdev)
 EXPORT_SYMBOL_GPL(regulator_unregister);
 
 #ifdef CONFIG_SUSPEND
-static int _regulator_suspend_late(struct device *dev, void *data)
+static int _regulator_suspend(struct device *dev, void *data)
 {
 	struct regulator_dev *rdev = dev_to_rdev(dev);
 	suspend_state_t *state = data;
@@ -4455,20 +4455,20 @@ static int _regulator_suspend_late(struct device *dev, void *data)
 }
 
 /**
- * regulator_suspend_late - prepare regulators for system wide suspend
+ * regulator_suspend - prepare regulators for system wide suspend
  * @state: system suspend state
  *
  * Configure each regulator with it's suspend operating parameters for state.
  */
-static int regulator_suspend_late(struct device *dev)
+static int regulator_suspend(struct device *dev)
 {
 	suspend_state_t state = pm_suspend_target_state;
 
 	return class_for_each_device(&regulator_class, NULL, &state,
-				     _regulator_suspend_late);
+				     _regulator_suspend);
 }
 
-static int _regulator_resume_early(struct device *dev, void *data)
+static int _regulator_resume(struct device *dev, void *data)
 {
 	int ret = 0;
 	struct regulator_dev *rdev = dev_to_rdev(dev);
@@ -4481,35 +4481,35 @@ static int _regulator_resume_early(struct device *dev, void *data)
 
 	regulator_lock(rdev);
 
-	if (rdev->desc->ops->resume_early &&
+	if (rdev->desc->ops->resume &&
 	    (rstate->enabled == ENABLE_IN_SUSPEND ||
 	     rstate->enabled == DISABLE_IN_SUSPEND))
-		ret = rdev->desc->ops->resume_early(rdev);
+		ret = rdev->desc->ops->resume(rdev);
 
 	regulator_unlock(rdev);
 
 	return ret;
 }
 
-static int regulator_resume_early(struct device *dev)
+static int regulator_resume(struct device *dev)
 {
 	suspend_state_t state = pm_suspend_target_state;
 
 	return class_for_each_device(&regulator_class, NULL, &state,
-				     _regulator_resume_early);
+				     _regulator_resume);
 }
 
 #else /* !CONFIG_SUSPEND */
 
-#define regulator_suspend_late	NULL
-#define regulator_resume_early	NULL
+#define regulator_suspend	NULL
+#define regulator_resume	NULL
 
 #endif /* !CONFIG_SUSPEND */
 
 #ifdef CONFIG_PM
 static const struct dev_pm_ops __maybe_unused regulator_pm_ops = {
-	.suspend_late	= regulator_suspend_late,
-	.resume_early	= regulator_resume_early,
+	.suspend	= regulator_suspend,
+	.resume		= regulator_resume,
 };
 #endif
 

commit 38de19fa7159838fbe180e859cb46501d9fca4f4
Author: Mark Brown <broonie@kernel.org>
Date:   Wed May 30 15:20:03 2018 +0100

    regulator: Revert coupled regulator support again
    
    Revert the last two commits of the voltage coupling mechanism patch set:
    
    456e7cdf3b1a14e2606b8 regulator: core: Change voltage setting path
    696861761a58d8c93605b regulator: core: Add voltage balancing mechanism
    
    as they broke boot on OMAP again.
    
    Reported-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index ac97e21bff10..6ed568b96c0e 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -105,11 +105,6 @@ static int _notifier_call_chain(struct regulator_dev *rdev,
 				  unsigned long event, void *data);
 static int _regulator_do_set_voltage(struct regulator_dev *rdev,
 				     int min_uV, int max_uV);
-static int regulator_balance_voltage(struct regulator_dev *rdev,
-				     suspend_state_t state);
-static int regulator_set_voltage_rdev(struct regulator_dev *rdev,
-				      int min_uV, int max_uV,
-				      suspend_state_t state);
 static struct regulator *create_regulator(struct regulator_dev *rdev,
 					  struct device *dev,
 					  const char *supply_name);
@@ -201,66 +196,37 @@ static void regulator_unlock(struct regulator_dev *rdev)
 	}
 }
 
-static int regulator_lock_recursive(struct regulator_dev *rdev,
-				    unsigned int subclass)
+/**
+ * regulator_lock_supply - lock a regulator and its supplies
+ * @rdev:         regulator source
+ */
+static void regulator_lock_supply(struct regulator_dev *rdev)
 {
-	struct regulator_dev *c_rdev;
 	int i;
 
-	for (i = 0; i < rdev->coupling_desc.n_coupled; i++) {
-		c_rdev = rdev->coupling_desc.coupled_rdevs[i];
-
-		if (!c_rdev)
-			continue;
-
-		regulator_lock_nested(c_rdev, subclass++);
-
-		if (c_rdev->supply)
-			subclass =
-				regulator_lock_recursive(c_rdev->supply->rdev,
-							 subclass);
-	}
-
-	return subclass;
+	for (i = 0; rdev; rdev = rdev_get_supply(rdev), i++)
+		regulator_lock_nested(rdev, i);
 }
 
 /**
- * regulator_unlock_dependent - unlock regulator's suppliers and coupled
- *				regulators
- * @rdev:			regulator source
- *
- * Unlock all regulators related with rdev by coupling or suppling.
+ * regulator_unlock_supply - unlock a regulator and its supplies
+ * @rdev:         regulator source
  */
-static void regulator_unlock_dependent(struct regulator_dev *rdev)
+static void regulator_unlock_supply(struct regulator_dev *rdev)
 {
-	struct regulator_dev *c_rdev;
-	int i;
+	struct regulator *supply;
 
-	for (i = 0; i < rdev->coupling_desc.n_coupled; i++) {
-		c_rdev = rdev->coupling_desc.coupled_rdevs[i];
-
-		if (!c_rdev)
-			continue;
+	while (1) {
+		regulator_unlock(rdev);
+		supply = rdev->supply;
 
-		regulator_unlock(c_rdev);
+		if (!rdev->supply)
+			return;
 
-		if (c_rdev->supply)
-			regulator_unlock_dependent(c_rdev->supply->rdev);
+		rdev = supply->rdev;
 	}
 }
 
-/**
- * regulator_lock_dependent - lock regulator's suppliers and coupled regulators
- * @rdev:			regulator source
- *
- * This function as a wrapper on regulator_lock_recursive(), which locks
- * all regulators related with rdev by coupling or suppling.
- */
-static inline void regulator_lock_dependent(struct regulator_dev *rdev)
-{
-	regulator_lock_recursive(rdev, 0);
-}
-
 /**
  * of_get_regulator - get a regulator device node based on supply name
  * @dev: Device pointer for the consumer (of regulator) device
@@ -2293,11 +2259,6 @@ int regulator_enable(struct regulator *regulator)
 	struct regulator_dev *rdev = regulator->rdev;
 	int ret = 0;
 
-	if (rdev->coupling_desc.n_resolved != rdev->coupling_desc.n_coupled) {
-		rdev_err(rdev, "not all coupled regulators registered\n");
-		return -EPERM;
-	}
-
 	if (regulator->always_on)
 		return 0;
 
@@ -2307,12 +2268,9 @@ int regulator_enable(struct regulator *regulator)
 			return ret;
 	}
 
-	regulator_lock_dependent(rdev);
+	mutex_lock(&rdev->mutex);
 	ret = _regulator_enable(rdev);
-	/* balance only if there are regulators coupled */
-	if (rdev->coupling_desc.n_coupled > 1)
-		regulator_balance_voltage(rdev, PM_SUSPEND_ON);
-	regulator_unlock_dependent(rdev);
+	mutex_unlock(&rdev->mutex);
 
 	if (ret != 0 && rdev->supply)
 		regulator_disable(rdev->supply);
@@ -2418,11 +2376,9 @@ int regulator_disable(struct regulator *regulator)
 	if (regulator->always_on)
 		return 0;
 
-	regulator_lock_dependent(rdev);
+	mutex_lock(&rdev->mutex);
 	ret = _regulator_disable(rdev);
-	if (rdev->coupling_desc.n_coupled > 1)
-		regulator_balance_voltage(rdev, PM_SUSPEND_ON);
-	regulator_unlock_dependent(rdev);
+	mutex_unlock(&rdev->mutex);
 
 	if (ret == 0 && rdev->supply)
 		regulator_disable(rdev->supply);
@@ -2471,12 +2427,10 @@ int regulator_force_disable(struct regulator *regulator)
 	struct regulator_dev *rdev = regulator->rdev;
 	int ret;
 
-	regulator_lock_dependent(rdev);
+	mutex_lock(&rdev->mutex);
 	regulator->uA_load = 0;
 	ret = _regulator_force_disable(regulator->rdev);
-	if (rdev->coupling_desc.n_coupled > 1)
-		regulator_balance_voltage(rdev, PM_SUSPEND_ON);
-	regulator_unlock_dependent(rdev);
+	mutex_unlock(&rdev->mutex);
 
 	if (rdev->supply)
 		while (rdev->open_count--)
@@ -2624,9 +2578,9 @@ int regulator_is_enabled(struct regulator *regulator)
 	if (regulator->always_on)
 		return 1;
 
-	regulator_lock_dependent(regulator->rdev);
+	mutex_lock(&regulator->rdev->mutex);
 	ret = _regulator_is_enabled(regulator->rdev);
-	regulator_unlock_dependent(regulator->rdev);
+	mutex_unlock(&regulator->rdev->mutex);
 
 	return ret;
 }
@@ -3035,12 +2989,8 @@ static int regulator_set_voltage_unlocked(struct regulator *regulator,
 	int ret = 0;
 	int old_min_uV, old_max_uV;
 	int current_uV;
-
-	if (rdev->coupling_desc.n_resolved != rdev->coupling_desc.n_coupled) {
-		rdev_err(rdev, "not all coupled regulators registered\n");
-		ret = -EPERM;
-		goto out;
-	}
+	int best_supply_uV = 0;
+	int supply_change_uV = 0;
 
 	/* If we're setting the same range as last time the change
 	 * should be a noop (some cpufreq implementations use the same
@@ -3084,27 +3034,6 @@ static int regulator_set_voltage_unlocked(struct regulator *regulator,
 	if (ret < 0)
 		goto out2;
 
-	/* for not coupled regulators this will just set the voltage */
-	ret = regulator_balance_voltage(rdev, state);
-	if (ret < 0)
-		goto out2;
-
-out:
-	return 0;
-out2:
-	voltage->min_uV = old_min_uV;
-	voltage->max_uV = old_max_uV;
-
-	return ret;
-}
-
-static int regulator_set_voltage_rdev(struct regulator_dev *rdev, int min_uV,
-				      int max_uV, suspend_state_t state)
-{
-	int best_supply_uV = 0;
-	int supply_change_uV = 0;
-	int ret;
-
 	if (rdev->supply &&
 	    regulator_ops_is_valid(rdev->supply->rdev,
 				   REGULATOR_CHANGE_VOLTAGE) &&
@@ -3116,13 +3045,13 @@ static int regulator_set_voltage_rdev(struct regulator_dev *rdev, int min_uV,
 		selector = regulator_map_voltage(rdev, min_uV, max_uV);
 		if (selector < 0) {
 			ret = selector;
-			goto out;
+			goto out2;
 		}
 
 		best_supply_uV = _regulator_list_voltage(rdev, selector, 0);
 		if (best_supply_uV < 0) {
 			ret = best_supply_uV;
-			goto out;
+			goto out2;
 		}
 
 		best_supply_uV += rdev->desc->min_dropout_uV;
@@ -3130,7 +3059,7 @@ static int regulator_set_voltage_rdev(struct regulator_dev *rdev, int min_uV,
 		current_supply_uV = _regulator_get_voltage(rdev->supply->rdev);
 		if (current_supply_uV < 0) {
 			ret = current_supply_uV;
-			goto out;
+			goto out2;
 		}
 
 		supply_change_uV = best_supply_uV - current_supply_uV;
@@ -3142,7 +3071,7 @@ static int regulator_set_voltage_rdev(struct regulator_dev *rdev, int min_uV,
 		if (ret) {
 			dev_err(&rdev->dev, "Failed to increase supply voltage: %d\n",
 					ret);
-			goto out;
+			goto out2;
 		}
 	}
 
@@ -3152,7 +3081,7 @@ static int regulator_set_voltage_rdev(struct regulator_dev *rdev, int min_uV,
 		ret = _regulator_do_set_suspend_voltage(rdev, min_uV,
 							max_uV, state);
 	if (ret < 0)
-		goto out;
+		goto out2;
 
 	if (supply_change_uV < 0) {
 		ret = regulator_set_voltage_unlocked(rdev->supply,
@@ -3166,186 +3095,10 @@ static int regulator_set_voltage_rdev(struct regulator_dev *rdev, int min_uV,
 
 out:
 	return ret;
-}
-
-static int regulator_get_optimal_voltage(struct regulator_dev *rdev)
-{
-	struct coupling_desc *c_desc = &rdev->coupling_desc;
-	struct regulator_dev **c_rdevs = c_desc->coupled_rdevs;
-	int max_spread = rdev->constraints->max_spread;
-	int n_coupled = c_desc->n_coupled;
-	int desired_min_uV, desired_max_uV, min_current_uV = INT_MAX;
-	int max_current_uV = 0, highest_min_uV = 0, target_uV, possible_uV;
-	int i, ret;
-
-	/* If consumers don't provide any demands, set voltage to min_uV */
-	desired_min_uV = rdev->constraints->min_uV;
-	desired_max_uV = rdev->constraints->max_uV;
-	ret = regulator_check_consumers(rdev,
-					&desired_min_uV,
-					&desired_max_uV, PM_SUSPEND_ON);
-	if (ret < 0)
-		goto out;
-
-	/*
-	 * If there are no coupled regulators, simply set the voltage demanded
-	 * by consumers.
-	 */
-	if (n_coupled == 1) {
-		ret = desired_min_uV;
-		goto out;
-	}
-
-	/* Find highest min desired voltage */
-	for (i = 0; i < n_coupled; i++) {
-		int tmp_min = 0;
-		int tmp_max = INT_MAX;
-
-		if (!_regulator_is_enabled(c_rdevs[i]))
-			continue;
-
-		ret = regulator_check_consumers(c_rdevs[i],
-						&tmp_min,
-						&tmp_max, PM_SUSPEND_ON);
-		if (ret < 0)
-			goto out;
-
-		if (tmp_min > highest_min_uV)
-			highest_min_uV = tmp_min;
-	}
-
-	/*
-	 * Let target_uV be equal to the desired one if possible.
-	 * If not, set it to minimum voltage, allowed by other coupled
-	 * regulators.
-	 */
-	target_uV = max(desired_min_uV,  highest_min_uV - max_spread);
-
-	/*
-	 * Find min and max voltages, which currently aren't
-	 * violating max_spread
-	 */
-	for (i = 0; i < n_coupled; i++) {
-		int tmp_act;
-
-		/*
-		 * Don't check the regulator, which is about
-		 * to change voltage
-		 */
-		if (c_rdevs[i] == rdev)
-			continue;
-		if (!_regulator_is_enabled(c_rdevs[i]))
-			continue;
-
-		tmp_act = _regulator_get_voltage(c_rdevs[i]);
-		if (tmp_act < 0) {
-			ret = tmp_act;
-			goto out;
-		}
-
-		if (tmp_act < min_current_uV)
-			min_current_uV = tmp_act;
-
-		if (tmp_act > max_current_uV)
-			max_current_uV = tmp_act;
-	}
-
-	/* There aren't any other regulators enabled */
-	if (max_current_uV == 0) {
-		possible_uV = target_uV;
-	} else {
-		/*
-		 * Correct target voltage, so as it currently isn't
-		 * violating max_spread
-		 */
-		possible_uV = max(target_uV, max_current_uV - max_spread);
-		possible_uV = min(possible_uV, min_current_uV + max_spread);
-	}
-
-	if (possible_uV > desired_max_uV) {
-		ret = -EINVAL;
-		goto out;
-	}
-	ret = possible_uV;
-
-out:
-	return ret;
-}
-
-static int regulator_balance_voltage(struct regulator_dev *rdev,
-				     suspend_state_t state)
-{
-	struct regulator_dev **c_rdevs;
-	struct regulator_dev *best_rdev;
-	struct coupling_desc *c_desc = &rdev->coupling_desc;
-	int n_coupled;
-	int i, best_delta, best_uV, ret = 1;
-
-	c_rdevs = c_desc->coupled_rdevs;
-	n_coupled = c_desc->n_coupled;
-
-	/*
-	 * if system is in a state other than PM_SUSPEND_ON, don't check
-	 * other coupled regulators
-	 */
-	if (state != PM_SUSPEND_ON)
-		n_coupled = 1;
-
-	/*
-	 * Find the best possible voltage change on each loop. Leave the loop
-	 * if there isn't any possible change.
-	 */
-	while (1) {
-		best_delta = 0;
-		best_uV = 0;
-		best_rdev = NULL;
-
-		/*
-		 * Find highest difference between optimal voltage
-		 * and current voltage.
-		 */
-		for (i = 0; i < n_coupled; i++) {
-			/*
-			 * optimal_uV is the best voltage that can be set for
-			 * i-th regulator at the moment without violating
-			 * max_spread constraint in order to balance
-			 * the coupled voltages.
-			 */
-			int optimal_uV, current_uV;
-
-			optimal_uV = regulator_get_optimal_voltage(c_rdevs[i]);
-			if (optimal_uV < 0) {
-				ret = optimal_uV;
-				goto out;
-			}
-
-			current_uV = _regulator_get_voltage(c_rdevs[i]);
-			if (current_uV < 0) {
-				ret = optimal_uV;
-				goto out;
-			}
-
-			if (abs(best_delta) < abs(optimal_uV - current_uV)) {
-				best_delta = optimal_uV - current_uV;
-				best_rdev = c_rdevs[i];
-				best_uV = optimal_uV;
-			}
-		}
-
-		/* Nothing to change, return successfully */
-		if (!best_rdev) {
-			ret = 0;
-			goto out;
-		}
-
-		ret = regulator_set_voltage_rdev(best_rdev, best_uV,
-						 best_uV, state);
-
-		if (ret < 0)
-			goto out;
-	}
+out2:
+	voltage->min_uV = old_min_uV;
+	voltage->max_uV = old_max_uV;
 
-out:
 	return ret;
 }
 
@@ -3371,12 +3124,12 @@ int regulator_set_voltage(struct regulator *regulator, int min_uV, int max_uV)
 {
 	int ret = 0;
 
-	regulator_lock_dependent(regulator->rdev);
+	regulator_lock_supply(regulator->rdev);
 
 	ret = regulator_set_voltage_unlocked(regulator, min_uV, max_uV,
 					     PM_SUSPEND_ON);
 
-	regulator_unlock_dependent(regulator->rdev);
+	regulator_unlock_supply(regulator->rdev);
 
 	return ret;
 }
@@ -3454,12 +3207,12 @@ int regulator_set_suspend_voltage(struct regulator *regulator, int min_uV,
 	if (regulator_check_states(state) || state == PM_SUSPEND_ON)
 		return -EINVAL;
 
-	regulator_lock_dependent(regulator->rdev);
+	regulator_lock_supply(regulator->rdev);
 
 	ret = _regulator_set_suspend_voltage(regulator, min_uV,
 					     max_uV, state);
 
-	regulator_unlock_dependent(regulator->rdev);
+	regulator_unlock_supply(regulator->rdev);
 
 	return ret;
 }
@@ -3651,11 +3404,11 @@ int regulator_get_voltage(struct regulator *regulator)
 {
 	int ret;
 
-	regulator_lock_dependent(regulator->rdev);
+	regulator_lock_supply(regulator->rdev);
 
 	ret = _regulator_get_voltage(regulator->rdev);
 
-	regulator_unlock_dependent(regulator->rdev);
+	regulator_unlock_supply(regulator->rdev);
 
 	return ret;
 }

commit 456e7cdf3b1a14e2606b8b687385ab2e3f23a49a
Author: Maciej Purski <m.purski@samsung.com>
Date:   Mon Apr 23 16:33:42 2018 +0200

    regulator: core: Change voltage setting path
    
    On Odroid XU3/4 and other Exynos5422 based boards there is a case, that
    different devices on the board are supplied by different regulators
    with non-fixed voltages. If one of these devices temporarily requires
    higher voltage, there might occur a situation that the spread between
    two devices' voltages is so high, that there is a risk of changing
    'high' and 'low' states on the interconnection between devices powered
    by those regulators.
    
    Uncoupled regulators should be a special case of coupled regulators, so
    they should share a common voltage setting path. When enabling,
    disabling or setting voltage of a coupled regulator, all coupled
    regulators should be locked. Regulator's supplies should be locked, when
    setting voltage of a single regulator. Enabling a coupled regulator or
    setting its voltage should not be possible if some of its coupled
    regulators, has not been registered.
    
    Add function for locking coupled regulators and supplies. Extract
    a new function regulator_set_voltage_rdev() from
    regulator_set_voltage_unlocked(), which is called when setting
    voltage of a single regulator.
    
    Signed-off-by: Maciej Purski <m.purski@samsung.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 225eaca24921..ac97e21bff10 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -107,6 +107,9 @@ static int _regulator_do_set_voltage(struct regulator_dev *rdev,
 				     int min_uV, int max_uV);
 static int regulator_balance_voltage(struct regulator_dev *rdev,
 				     suspend_state_t state);
+static int regulator_set_voltage_rdev(struct regulator_dev *rdev,
+				      int min_uV, int max_uV,
+				      suspend_state_t state);
 static struct regulator *create_regulator(struct regulator_dev *rdev,
 					  struct device *dev,
 					  const char *supply_name);
@@ -198,37 +201,66 @@ static void regulator_unlock(struct regulator_dev *rdev)
 	}
 }
 
-/**
- * regulator_lock_supply - lock a regulator and its supplies
- * @rdev:         regulator source
- */
-static void regulator_lock_supply(struct regulator_dev *rdev)
+static int regulator_lock_recursive(struct regulator_dev *rdev,
+				    unsigned int subclass)
 {
+	struct regulator_dev *c_rdev;
 	int i;
 
-	for (i = 0; rdev; rdev = rdev_get_supply(rdev), i++)
-		regulator_lock_nested(rdev, i);
+	for (i = 0; i < rdev->coupling_desc.n_coupled; i++) {
+		c_rdev = rdev->coupling_desc.coupled_rdevs[i];
+
+		if (!c_rdev)
+			continue;
+
+		regulator_lock_nested(c_rdev, subclass++);
+
+		if (c_rdev->supply)
+			subclass =
+				regulator_lock_recursive(c_rdev->supply->rdev,
+							 subclass);
+	}
+
+	return subclass;
 }
 
 /**
- * regulator_unlock_supply - unlock a regulator and its supplies
- * @rdev:         regulator source
+ * regulator_unlock_dependent - unlock regulator's suppliers and coupled
+ *				regulators
+ * @rdev:			regulator source
+ *
+ * Unlock all regulators related with rdev by coupling or suppling.
  */
-static void regulator_unlock_supply(struct regulator_dev *rdev)
+static void regulator_unlock_dependent(struct regulator_dev *rdev)
 {
-	struct regulator *supply;
+	struct regulator_dev *c_rdev;
+	int i;
 
-	while (1) {
-		regulator_unlock(rdev);
-		supply = rdev->supply;
+	for (i = 0; i < rdev->coupling_desc.n_coupled; i++) {
+		c_rdev = rdev->coupling_desc.coupled_rdevs[i];
 
-		if (!rdev->supply)
-			return;
+		if (!c_rdev)
+			continue;
+
+		regulator_unlock(c_rdev);
 
-		rdev = supply->rdev;
+		if (c_rdev->supply)
+			regulator_unlock_dependent(c_rdev->supply->rdev);
 	}
 }
 
+/**
+ * regulator_lock_dependent - lock regulator's suppliers and coupled regulators
+ * @rdev:			regulator source
+ *
+ * This function as a wrapper on regulator_lock_recursive(), which locks
+ * all regulators related with rdev by coupling or suppling.
+ */
+static inline void regulator_lock_dependent(struct regulator_dev *rdev)
+{
+	regulator_lock_recursive(rdev, 0);
+}
+
 /**
  * of_get_regulator - get a regulator device node based on supply name
  * @dev: Device pointer for the consumer (of regulator) device
@@ -2261,6 +2293,11 @@ int regulator_enable(struct regulator *regulator)
 	struct regulator_dev *rdev = regulator->rdev;
 	int ret = 0;
 
+	if (rdev->coupling_desc.n_resolved != rdev->coupling_desc.n_coupled) {
+		rdev_err(rdev, "not all coupled regulators registered\n");
+		return -EPERM;
+	}
+
 	if (regulator->always_on)
 		return 0;
 
@@ -2270,9 +2307,12 @@ int regulator_enable(struct regulator *regulator)
 			return ret;
 	}
 
-	mutex_lock(&rdev->mutex);
+	regulator_lock_dependent(rdev);
 	ret = _regulator_enable(rdev);
-	mutex_unlock(&rdev->mutex);
+	/* balance only if there are regulators coupled */
+	if (rdev->coupling_desc.n_coupled > 1)
+		regulator_balance_voltage(rdev, PM_SUSPEND_ON);
+	regulator_unlock_dependent(rdev);
 
 	if (ret != 0 && rdev->supply)
 		regulator_disable(rdev->supply);
@@ -2378,9 +2418,11 @@ int regulator_disable(struct regulator *regulator)
 	if (regulator->always_on)
 		return 0;
 
-	mutex_lock(&rdev->mutex);
+	regulator_lock_dependent(rdev);
 	ret = _regulator_disable(rdev);
-	mutex_unlock(&rdev->mutex);
+	if (rdev->coupling_desc.n_coupled > 1)
+		regulator_balance_voltage(rdev, PM_SUSPEND_ON);
+	regulator_unlock_dependent(rdev);
 
 	if (ret == 0 && rdev->supply)
 		regulator_disable(rdev->supply);
@@ -2429,10 +2471,12 @@ int regulator_force_disable(struct regulator *regulator)
 	struct regulator_dev *rdev = regulator->rdev;
 	int ret;
 
-	mutex_lock(&rdev->mutex);
+	regulator_lock_dependent(rdev);
 	regulator->uA_load = 0;
 	ret = _regulator_force_disable(regulator->rdev);
-	mutex_unlock(&rdev->mutex);
+	if (rdev->coupling_desc.n_coupled > 1)
+		regulator_balance_voltage(rdev, PM_SUSPEND_ON);
+	regulator_unlock_dependent(rdev);
 
 	if (rdev->supply)
 		while (rdev->open_count--)
@@ -2580,9 +2624,9 @@ int regulator_is_enabled(struct regulator *regulator)
 	if (regulator->always_on)
 		return 1;
 
-	mutex_lock(&regulator->rdev->mutex);
+	regulator_lock_dependent(regulator->rdev);
 	ret = _regulator_is_enabled(regulator->rdev);
-	mutex_unlock(&regulator->rdev->mutex);
+	regulator_unlock_dependent(regulator->rdev);
 
 	return ret;
 }
@@ -2991,8 +3035,12 @@ static int regulator_set_voltage_unlocked(struct regulator *regulator,
 	int ret = 0;
 	int old_min_uV, old_max_uV;
 	int current_uV;
-	int best_supply_uV = 0;
-	int supply_change_uV = 0;
+
+	if (rdev->coupling_desc.n_resolved != rdev->coupling_desc.n_coupled) {
+		rdev_err(rdev, "not all coupled regulators registered\n");
+		ret = -EPERM;
+		goto out;
+	}
 
 	/* If we're setting the same range as last time the change
 	 * should be a noop (some cpufreq implementations use the same
@@ -3036,6 +3084,27 @@ static int regulator_set_voltage_unlocked(struct regulator *regulator,
 	if (ret < 0)
 		goto out2;
 
+	/* for not coupled regulators this will just set the voltage */
+	ret = regulator_balance_voltage(rdev, state);
+	if (ret < 0)
+		goto out2;
+
+out:
+	return 0;
+out2:
+	voltage->min_uV = old_min_uV;
+	voltage->max_uV = old_max_uV;
+
+	return ret;
+}
+
+static int regulator_set_voltage_rdev(struct regulator_dev *rdev, int min_uV,
+				      int max_uV, suspend_state_t state)
+{
+	int best_supply_uV = 0;
+	int supply_change_uV = 0;
+	int ret;
+
 	if (rdev->supply &&
 	    regulator_ops_is_valid(rdev->supply->rdev,
 				   REGULATOR_CHANGE_VOLTAGE) &&
@@ -3047,13 +3116,13 @@ static int regulator_set_voltage_unlocked(struct regulator *regulator,
 		selector = regulator_map_voltage(rdev, min_uV, max_uV);
 		if (selector < 0) {
 			ret = selector;
-			goto out2;
+			goto out;
 		}
 
 		best_supply_uV = _regulator_list_voltage(rdev, selector, 0);
 		if (best_supply_uV < 0) {
 			ret = best_supply_uV;
-			goto out2;
+			goto out;
 		}
 
 		best_supply_uV += rdev->desc->min_dropout_uV;
@@ -3061,7 +3130,7 @@ static int regulator_set_voltage_unlocked(struct regulator *regulator,
 		current_supply_uV = _regulator_get_voltage(rdev->supply->rdev);
 		if (current_supply_uV < 0) {
 			ret = current_supply_uV;
-			goto out2;
+			goto out;
 		}
 
 		supply_change_uV = best_supply_uV - current_supply_uV;
@@ -3073,7 +3142,7 @@ static int regulator_set_voltage_unlocked(struct regulator *regulator,
 		if (ret) {
 			dev_err(&rdev->dev, "Failed to increase supply voltage: %d\n",
 					ret);
-			goto out2;
+			goto out;
 		}
 	}
 
@@ -3083,7 +3152,7 @@ static int regulator_set_voltage_unlocked(struct regulator *regulator,
 		ret = _regulator_do_set_suspend_voltage(rdev, min_uV,
 							max_uV, state);
 	if (ret < 0)
-		goto out2;
+		goto out;
 
 	if (supply_change_uV < 0) {
 		ret = regulator_set_voltage_unlocked(rdev->supply,
@@ -3096,11 +3165,6 @@ static int regulator_set_voltage_unlocked(struct regulator *regulator,
 	}
 
 out:
-	return ret;
-out2:
-	voltage->min_uV = old_min_uV;
-	voltage->max_uV = old_max_uV;
-
 	return ret;
 }
 
@@ -3274,17 +3338,8 @@ static int regulator_balance_voltage(struct regulator_dev *rdev,
 			goto out;
 		}
 
-		/*
-		 * Lock just the supply regulators, as the regulator itself
-		 * is already locked by regulator_lock_coupled().
-		 */
-		if (best_rdev->supply)
-			regulator_lock_supply(best_rdev->supply->rdev);
-
 		ret = regulator_set_voltage_rdev(best_rdev, best_uV,
 						 best_uV, state);
-		if (best_rdev->supply)
-			regulator_unlock_supply(best_rdev->supply->rdev);
 
 		if (ret < 0)
 			goto out;
@@ -3316,12 +3371,12 @@ int regulator_set_voltage(struct regulator *regulator, int min_uV, int max_uV)
 {
 	int ret = 0;
 
-	regulator_lock_supply(regulator->rdev);
+	regulator_lock_dependent(regulator->rdev);
 
 	ret = regulator_set_voltage_unlocked(regulator, min_uV, max_uV,
 					     PM_SUSPEND_ON);
 
-	regulator_unlock_supply(regulator->rdev);
+	regulator_unlock_dependent(regulator->rdev);
 
 	return ret;
 }
@@ -3399,12 +3454,12 @@ int regulator_set_suspend_voltage(struct regulator *regulator, int min_uV,
 	if (regulator_check_states(state) || state == PM_SUSPEND_ON)
 		return -EINVAL;
 
-	regulator_lock_supply(regulator->rdev);
+	regulator_lock_dependent(regulator->rdev);
 
 	ret = _regulator_set_suspend_voltage(regulator, min_uV,
 					     max_uV, state);
 
-	regulator_unlock_supply(regulator->rdev);
+	regulator_unlock_dependent(regulator->rdev);
 
 	return ret;
 }
@@ -3596,11 +3651,11 @@ int regulator_get_voltage(struct regulator *regulator)
 {
 	int ret;
 
-	regulator_lock_supply(regulator->rdev);
+	regulator_lock_dependent(regulator->rdev);
 
 	ret = _regulator_get_voltage(regulator->rdev);
 
-	regulator_unlock_supply(regulator->rdev);
+	regulator_unlock_dependent(regulator->rdev);
 
 	return ret;
 }

commit 696861761a58d8c93605b5663824929fb6540f16
Author: Maciej Purski <m.purski@samsung.com>
Date:   Mon Apr 23 16:33:41 2018 +0200

    regulator: core: Add voltage balancing mechanism
    
    On Odroid XU3/4 and other Exynos5422 based boards there is a case, that
    different devices on the board are supplied by different regulators
    with non-fixed voltages. If one of these devices temporarily requires
    higher voltage, there might occur a situation that the spread between
    two devices' voltages is so high, that there is a risk of changing
    'high' and 'low' states on the interconnection between devices powered
    by those regulators.
    
    Introduce new function regulator_balance_voltage(), which
    keeps max_spread constraint fulfilled between a group of coupled
    regulators. It should be called if a regulator changes its
    voltage or after disabling or enabling. Disabled regulators should
    follow changes of the enabled ones, but their consumers' demands
    shouldn't be taken into account while calculating voltage of other
    coupled regulators.
    
    Find voltages, which are closest to suiting all the consumers' demands,
    while fulfilling max_spread constraint, keeping the following rules:
    - if one regulator is about to rise its voltage, rise others
      voltages in order to keep the max_spread
    - if a regulator, which has caused rising other regulators, is
      lowered, lower other regulators if possible
    - if one regulator is about to lower its voltage, but it hasn't caused
      rising other regulators, don't change its voltage if it breaks the
      max_spread
    
    Change regulators' voltages step by step, keeping max_spread constraint
    fulfilled all the time. Function regulator_get_optimal_voltage()
    should find the best possible change for the regulator, which doesn't
    break max_spread constraint. In function regulator_balance_voltage()
    optimize number of steps by finding highest voltage difference on
    each iteration.
    
    If a regulator, which is about to change its voltage, is not coupled,
    method regulator_get_optimal_voltage() should simply return the lowest
    voltage fulfilling consumers' demands.
    
    Coupling should be checked only if the system is in PM_SUSPEND_ON state.
    
    Signed-off-by: Maciej Purski <m.purski@samsung.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 6ed568b96c0e..225eaca24921 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -105,6 +105,8 @@ static int _notifier_call_chain(struct regulator_dev *rdev,
 				  unsigned long event, void *data);
 static int _regulator_do_set_voltage(struct regulator_dev *rdev,
 				     int min_uV, int max_uV);
+static int regulator_balance_voltage(struct regulator_dev *rdev,
+				     suspend_state_t state);
 static struct regulator *create_regulator(struct regulator_dev *rdev,
 					  struct device *dev,
 					  const char *supply_name);
@@ -3102,6 +3104,196 @@ static int regulator_set_voltage_unlocked(struct regulator *regulator,
 	return ret;
 }
 
+static int regulator_get_optimal_voltage(struct regulator_dev *rdev)
+{
+	struct coupling_desc *c_desc = &rdev->coupling_desc;
+	struct regulator_dev **c_rdevs = c_desc->coupled_rdevs;
+	int max_spread = rdev->constraints->max_spread;
+	int n_coupled = c_desc->n_coupled;
+	int desired_min_uV, desired_max_uV, min_current_uV = INT_MAX;
+	int max_current_uV = 0, highest_min_uV = 0, target_uV, possible_uV;
+	int i, ret;
+
+	/* If consumers don't provide any demands, set voltage to min_uV */
+	desired_min_uV = rdev->constraints->min_uV;
+	desired_max_uV = rdev->constraints->max_uV;
+	ret = regulator_check_consumers(rdev,
+					&desired_min_uV,
+					&desired_max_uV, PM_SUSPEND_ON);
+	if (ret < 0)
+		goto out;
+
+	/*
+	 * If there are no coupled regulators, simply set the voltage demanded
+	 * by consumers.
+	 */
+	if (n_coupled == 1) {
+		ret = desired_min_uV;
+		goto out;
+	}
+
+	/* Find highest min desired voltage */
+	for (i = 0; i < n_coupled; i++) {
+		int tmp_min = 0;
+		int tmp_max = INT_MAX;
+
+		if (!_regulator_is_enabled(c_rdevs[i]))
+			continue;
+
+		ret = regulator_check_consumers(c_rdevs[i],
+						&tmp_min,
+						&tmp_max, PM_SUSPEND_ON);
+		if (ret < 0)
+			goto out;
+
+		if (tmp_min > highest_min_uV)
+			highest_min_uV = tmp_min;
+	}
+
+	/*
+	 * Let target_uV be equal to the desired one if possible.
+	 * If not, set it to minimum voltage, allowed by other coupled
+	 * regulators.
+	 */
+	target_uV = max(desired_min_uV,  highest_min_uV - max_spread);
+
+	/*
+	 * Find min and max voltages, which currently aren't
+	 * violating max_spread
+	 */
+	for (i = 0; i < n_coupled; i++) {
+		int tmp_act;
+
+		/*
+		 * Don't check the regulator, which is about
+		 * to change voltage
+		 */
+		if (c_rdevs[i] == rdev)
+			continue;
+		if (!_regulator_is_enabled(c_rdevs[i]))
+			continue;
+
+		tmp_act = _regulator_get_voltage(c_rdevs[i]);
+		if (tmp_act < 0) {
+			ret = tmp_act;
+			goto out;
+		}
+
+		if (tmp_act < min_current_uV)
+			min_current_uV = tmp_act;
+
+		if (tmp_act > max_current_uV)
+			max_current_uV = tmp_act;
+	}
+
+	/* There aren't any other regulators enabled */
+	if (max_current_uV == 0) {
+		possible_uV = target_uV;
+	} else {
+		/*
+		 * Correct target voltage, so as it currently isn't
+		 * violating max_spread
+		 */
+		possible_uV = max(target_uV, max_current_uV - max_spread);
+		possible_uV = min(possible_uV, min_current_uV + max_spread);
+	}
+
+	if (possible_uV > desired_max_uV) {
+		ret = -EINVAL;
+		goto out;
+	}
+	ret = possible_uV;
+
+out:
+	return ret;
+}
+
+static int regulator_balance_voltage(struct regulator_dev *rdev,
+				     suspend_state_t state)
+{
+	struct regulator_dev **c_rdevs;
+	struct regulator_dev *best_rdev;
+	struct coupling_desc *c_desc = &rdev->coupling_desc;
+	int n_coupled;
+	int i, best_delta, best_uV, ret = 1;
+
+	c_rdevs = c_desc->coupled_rdevs;
+	n_coupled = c_desc->n_coupled;
+
+	/*
+	 * if system is in a state other than PM_SUSPEND_ON, don't check
+	 * other coupled regulators
+	 */
+	if (state != PM_SUSPEND_ON)
+		n_coupled = 1;
+
+	/*
+	 * Find the best possible voltage change on each loop. Leave the loop
+	 * if there isn't any possible change.
+	 */
+	while (1) {
+		best_delta = 0;
+		best_uV = 0;
+		best_rdev = NULL;
+
+		/*
+		 * Find highest difference between optimal voltage
+		 * and current voltage.
+		 */
+		for (i = 0; i < n_coupled; i++) {
+			/*
+			 * optimal_uV is the best voltage that can be set for
+			 * i-th regulator at the moment without violating
+			 * max_spread constraint in order to balance
+			 * the coupled voltages.
+			 */
+			int optimal_uV, current_uV;
+
+			optimal_uV = regulator_get_optimal_voltage(c_rdevs[i]);
+			if (optimal_uV < 0) {
+				ret = optimal_uV;
+				goto out;
+			}
+
+			current_uV = _regulator_get_voltage(c_rdevs[i]);
+			if (current_uV < 0) {
+				ret = optimal_uV;
+				goto out;
+			}
+
+			if (abs(best_delta) < abs(optimal_uV - current_uV)) {
+				best_delta = optimal_uV - current_uV;
+				best_rdev = c_rdevs[i];
+				best_uV = optimal_uV;
+			}
+		}
+
+		/* Nothing to change, return successfully */
+		if (!best_rdev) {
+			ret = 0;
+			goto out;
+		}
+
+		/*
+		 * Lock just the supply regulators, as the regulator itself
+		 * is already locked by regulator_lock_coupled().
+		 */
+		if (best_rdev->supply)
+			regulator_lock_supply(best_rdev->supply->rdev);
+
+		ret = regulator_set_voltage_rdev(best_rdev, best_uV,
+						 best_uV, state);
+		if (best_rdev->supply)
+			regulator_unlock_supply(best_rdev->supply->rdev);
+
+		if (ret < 0)
+			goto out;
+	}
+
+out:
+	return ret;
+}
+
 /**
  * regulator_set_voltage - set regulator output voltage
  * @regulator: regulator source

commit d3d64537c33956c94cfa2376b87d8917868a0f5e
Author: Maciej Purski <m.purski@samsung.com>
Date:   Mon Apr 23 16:33:40 2018 +0200

    regulator: core: Resolve coupled regulators
    
    On Odroid XU3/4 and other Exynos5422 based boards there is a case, that
    different devices on the board are supplied by different regulators
    with non-fixed voltages. If one of these devices temporarily requires
    higher voltage, there might occur a situation that the spread between
    two devices' voltages is so high, that there is a risk of changing
    'high' and 'low' states on the interconnection between devices powered
    by those regulators.
    
    Fill coupling descriptor with data obtained from DTS using previously
    defined of_functions. Fail to register a regulator, if some data
    inconsistency occurs. If some coupled regulators are not yet registered,
    don't fail to register, but try to resolve them in late init call.
    
    Signed-off-by: Maciej Purski <m.purski@samsung.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 0ca941b53571..6ed568b96c0e 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -4129,6 +4129,96 @@ static int regulator_register_resolve_supply(struct device *dev, void *data)
 	return 0;
 }
 
+static int regulator_fill_coupling_array(struct regulator_dev *rdev)
+{
+	struct coupling_desc *c_desc = &rdev->coupling_desc;
+	int n_coupled = c_desc->n_coupled;
+	struct regulator_dev *c_rdev;
+	int i;
+
+	for (i = 1; i < n_coupled; i++) {
+		/* already resolved */
+		if (c_desc->coupled_rdevs[i])
+			continue;
+
+		c_rdev = of_parse_coupled_regulator(rdev, i - 1);
+
+		if (c_rdev) {
+			c_desc->coupled_rdevs[i] = c_rdev;
+			c_desc->n_resolved++;
+		}
+	}
+
+	if (rdev->coupling_desc.n_resolved < n_coupled)
+		return -1;
+	else
+		return 0;
+}
+
+static int regulator_register_fill_coupling_array(struct device *dev,
+						  void *data)
+{
+	struct regulator_dev *rdev = dev_to_rdev(dev);
+
+	if (!IS_ENABLED(CONFIG_OF))
+		return 0;
+
+	if (regulator_fill_coupling_array(rdev))
+		rdev_dbg(rdev, "unable to resolve coupling\n");
+
+	return 0;
+}
+
+static int regulator_resolve_coupling(struct regulator_dev *rdev)
+{
+	int n_phandles;
+
+	if (!IS_ENABLED(CONFIG_OF))
+		n_phandles = 0;
+	else
+		n_phandles = of_get_n_coupled(rdev);
+
+	if (n_phandles + 1 > MAX_COUPLED) {
+		rdev_err(rdev, "too many regulators coupled\n");
+		return -EPERM;
+	}
+
+	/*
+	 * Every regulator should always have coupling descriptor filled with
+	 * at least pointer to itself.
+	 */
+	rdev->coupling_desc.coupled_rdevs[0] = rdev;
+	rdev->coupling_desc.n_coupled = n_phandles + 1;
+	rdev->coupling_desc.n_resolved++;
+
+	/* regulator isn't coupled */
+	if (n_phandles == 0)
+		return 0;
+
+	/* regulator, which can't change its voltage, can't be coupled */
+	if (!regulator_ops_is_valid(rdev, REGULATOR_CHANGE_VOLTAGE)) {
+		rdev_err(rdev, "voltage operation not allowed\n");
+		return -EPERM;
+	}
+
+	if (rdev->constraints->max_spread <= 0) {
+		rdev_err(rdev, "wrong max_spread value\n");
+		return -EPERM;
+	}
+
+	if (!of_check_coupling_data(rdev))
+		return -EPERM;
+
+	/*
+	 * After everything has been checked, try to fill rdevs array
+	 * with pointers to regulators parsed from device tree. If some
+	 * regulators are not registered yet, retry in late init call
+	 */
+	regulator_fill_coupling_array(rdev);
+
+	return 0;
+}
+
 /**
  * regulator_register - register regulator
  * @regulator_desc: regulator to register
@@ -4262,6 +4352,13 @@ regulator_register(const struct regulator_desc *regulator_desc,
 	if (ret < 0)
 		goto wash;
 
+	mutex_lock(&regulator_list_mutex);
+	ret = regulator_resolve_coupling(rdev);
+	mutex_unlock(&regulator_list_mutex);
+
+	if (ret != 0)
+		goto wash;
+
 	/* add consumers devices */
 	if (init_data) {
 		mutex_lock(&regulator_list_mutex);
@@ -4756,6 +4853,9 @@ static int __init regulator_init_complete(void)
 	class_for_each_device(&regulator_class, NULL, NULL,
 			      regulator_late_cleanup);
 
+	class_for_each_device(&regulator_class, NULL, NULL,
+			      regulator_register_fill_coupling_array);
+
 	return 0;
 }
 late_initcall_sync(regulator_init_complete);

commit 66cf9a7e0192734c1c94751e628bd075be62cff4
Author: Maciej Purski <m.purski@samsung.com>
Date:   Mon Apr 23 16:33:37 2018 +0200

    regulator: core: Make locks re-entrant
    
    Setting voltage, enabling/disabling regulators requires operations on
    all regulators related with the regulator being changed. Therefore,
    all of them should be locked for the whole operation. With the current
    locking implementation, adding additional dependency (regulators
    coupling) causes deadlocks in some cases.
    
    Introduce a possibility to attempt to lock a mutex multiple times
    by the same task without waiting on a mutex. This should handle all
    reasonable coupling-supplying combinations, especially when two coupled
    regulators share common supplies. The only situation that should be
    forbidden is simultaneous coupling and supplying between a pair of
    regulators.
    
    The idea is based on clk core.
    
    Signed-off-by: Maciej Purski <m.purski@samsung.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index fe314ff56772..0ca941b53571 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -146,6 +146,56 @@ static inline struct regulator_dev *rdev_get_supply(struct regulator_dev *rdev)
 	return NULL;
 }
 
+/**
+ * regulator_lock_nested - lock a single regulator
+ * @rdev:		regulator source
+ * @subclass:		mutex subclass used for lockdep
+ *
+ * This function can be called many times by one task on
+ * a single regulator and its mutex will be locked only
+ * once. If a task, which is calling this function is other
+ * than the one, which initially locked the mutex, it will
+ * wait on mutex.
+ */
+static void regulator_lock_nested(struct regulator_dev *rdev,
+				  unsigned int subclass)
+{
+	if (!mutex_trylock(&rdev->mutex)) {
+		if (rdev->mutex_owner == current) {
+			rdev->ref_cnt++;
+			return;
+		}
+		mutex_lock_nested(&rdev->mutex, subclass);
+	}
+
+	rdev->ref_cnt = 1;
+	rdev->mutex_owner = current;
+}
+
+static inline void regulator_lock(struct regulator_dev *rdev)
+{
+	regulator_lock_nested(rdev, 0);
+}
+
+/**
+ * regulator_unlock - unlock a single regulator
+ * @rdev:		regulator_source
+ *
+ * This function unlocks the mutex when the
+ * reference counter reaches 0.
+ */
+static void regulator_unlock(struct regulator_dev *rdev)
+{
+	if (rdev->ref_cnt != 0) {
+		rdev->ref_cnt--;
+
+		if (!rdev->ref_cnt) {
+			rdev->mutex_owner = NULL;
+			mutex_unlock(&rdev->mutex);
+		}
+	}
+}
+
 /**
  * regulator_lock_supply - lock a regulator and its supplies
  * @rdev:         regulator source
@@ -155,7 +205,7 @@ static void regulator_lock_supply(struct regulator_dev *rdev)
 	int i;
 
 	for (i = 0; rdev; rdev = rdev_get_supply(rdev), i++)
-		mutex_lock_nested(&rdev->mutex, i);
+		regulator_lock_nested(rdev, i);
 }
 
 /**
@@ -167,7 +217,7 @@ static void regulator_unlock_supply(struct regulator_dev *rdev)
 	struct regulator *supply;
 
 	while (1) {
-		mutex_unlock(&rdev->mutex);
+		regulator_unlock(rdev);
 		supply = rdev->supply;
 
 		if (!rdev->supply)
@@ -350,9 +400,9 @@ static ssize_t regulator_uV_show(struct device *dev,
 	struct regulator_dev *rdev = dev_get_drvdata(dev);
 	ssize_t ret;
 
-	mutex_lock(&rdev->mutex);
+	regulator_lock(rdev);
 	ret = sprintf(buf, "%d\n", _regulator_get_voltage(rdev));
-	mutex_unlock(&rdev->mutex);
+	regulator_unlock(rdev);
 
 	return ret;
 }
@@ -416,9 +466,9 @@ static ssize_t regulator_state_show(struct device *dev,
 	struct regulator_dev *rdev = dev_get_drvdata(dev);
 	ssize_t ret;
 
-	mutex_lock(&rdev->mutex);
+	regulator_lock(rdev);
 	ret = regulator_print_state(buf, _regulator_is_enabled(rdev));
-	mutex_unlock(&rdev->mutex);
+	regulator_unlock(rdev);
 
 	return ret;
 }
@@ -526,10 +576,10 @@ static ssize_t regulator_total_uA_show(struct device *dev,
 	struct regulator *regulator;
 	int uA = 0;
 
-	mutex_lock(&rdev->mutex);
+	regulator_lock(rdev);
 	list_for_each_entry(regulator, &rdev->consumer_list, list)
 		uA += regulator->uA_load;
-	mutex_unlock(&rdev->mutex);
+	regulator_unlock(rdev);
 	return sprintf(buf, "%d\n", uA);
 }
 static DEVICE_ATTR(requested_microamps, 0444, regulator_total_uA_show, NULL);
@@ -1333,7 +1383,7 @@ static struct regulator *create_regulator(struct regulator_dev *rdev,
 	if (regulator == NULL)
 		return NULL;
 
-	mutex_lock(&rdev->mutex);
+	regulator_lock(rdev);
 	regulator->rdev = rdev;
 	list_add(&regulator->list, &rdev->consumer_list);
 
@@ -1388,12 +1438,12 @@ static struct regulator *create_regulator(struct regulator_dev *rdev,
 	    _regulator_is_enabled(rdev))
 		regulator->always_on = true;
 
-	mutex_unlock(&rdev->mutex);
+	regulator_unlock(rdev);
 	return regulator;
 overflow_err:
 	list_del(&regulator->list);
 	kfree(regulator);
-	mutex_unlock(&rdev->mutex);
+	regulator_unlock(rdev);
 	return NULL;
 }
 
@@ -1782,13 +1832,13 @@ static void _regulator_put(struct regulator *regulator)
 	/* remove any sysfs entries */
 	if (regulator->dev)
 		sysfs_remove_link(&rdev->dev.kobj, regulator->supply_name);
-	mutex_lock(&rdev->mutex);
+	regulator_lock(rdev);
 	list_del(&regulator->list);
 
 	rdev->open_count--;
 	rdev->exclusive = 0;
 	put_device(&rdev->dev);
-	mutex_unlock(&rdev->mutex);
+	regulator_unlock(rdev);
 
 	kfree_const(regulator->supply_name);
 	kfree(regulator);
@@ -2396,7 +2446,7 @@ static void regulator_disable_work(struct work_struct *work)
 						  disable_work.work);
 	int count, i, ret;
 
-	mutex_lock(&rdev->mutex);
+	regulator_lock(rdev);
 
 	BUG_ON(!rdev->deferred_disables);
 
@@ -2417,7 +2467,7 @@ static void regulator_disable_work(struct work_struct *work)
 			rdev_err(rdev, "Deferred disable failed: %d\n", ret);
 	}
 
-	mutex_unlock(&rdev->mutex);
+	regulator_unlock(rdev);
 
 	if (rdev->supply) {
 		for (i = 0; i < count; i++) {
@@ -2452,11 +2502,11 @@ int regulator_disable_deferred(struct regulator *regulator, int ms)
 	if (!ms)
 		return regulator_disable(regulator);
 
-	mutex_lock(&rdev->mutex);
+	regulator_lock(rdev);
 	rdev->deferred_disables++;
 	mod_delayed_work(system_power_efficient_wq, &rdev->disable_work,
 			 msecs_to_jiffies(ms));
-	mutex_unlock(&rdev->mutex);
+	regulator_unlock(rdev);
 
 	return 0;
 }
@@ -2488,10 +2538,10 @@ static int _regulator_list_voltage(struct regulator_dev *rdev,
 		if (selector >= rdev->desc->n_voltages)
 			return -EINVAL;
 		if (lock)
-			mutex_lock(&rdev->mutex);
+			regulator_lock(rdev);
 		ret = ops->list_voltage(rdev, selector);
 		if (lock)
-			mutex_unlock(&rdev->mutex);
+			regulator_unlock(rdev);
 	} else if (rdev->is_switch && rdev->supply) {
 		ret = _regulator_list_voltage(rdev->supply->rdev,
 					      selector, lock);
@@ -3264,7 +3314,7 @@ int regulator_sync_voltage(struct regulator *regulator)
 	struct regulator_voltage *voltage = &regulator->voltage[PM_SUSPEND_ON];
 	int ret, min_uV, max_uV;
 
-	mutex_lock(&rdev->mutex);
+	regulator_lock(rdev);
 
 	if (!rdev->desc->ops->set_voltage &&
 	    !rdev->desc->ops->set_voltage_sel) {
@@ -3293,7 +3343,7 @@ int regulator_sync_voltage(struct regulator *regulator)
 	ret = _regulator_do_set_voltage(rdev, min_uV, max_uV);
 
 out:
-	mutex_unlock(&rdev->mutex);
+	regulator_unlock(rdev);
 	return ret;
 }
 EXPORT_SYMBOL_GPL(regulator_sync_voltage);
@@ -3386,7 +3436,7 @@ int regulator_set_current_limit(struct regulator *regulator,
 	struct regulator_dev *rdev = regulator->rdev;
 	int ret;
 
-	mutex_lock(&rdev->mutex);
+	regulator_lock(rdev);
 
 	/* sanity check */
 	if (!rdev->desc->ops->set_current_limit) {
@@ -3401,7 +3451,7 @@ int regulator_set_current_limit(struct regulator *regulator,
 
 	ret = rdev->desc->ops->set_current_limit(rdev, min_uA, max_uA);
 out:
-	mutex_unlock(&rdev->mutex);
+	regulator_unlock(rdev);
 	return ret;
 }
 EXPORT_SYMBOL_GPL(regulator_set_current_limit);
@@ -3410,7 +3460,7 @@ static int _regulator_get_current_limit(struct regulator_dev *rdev)
 {
 	int ret;
 
-	mutex_lock(&rdev->mutex);
+	regulator_lock(rdev);
 
 	/* sanity check */
 	if (!rdev->desc->ops->get_current_limit) {
@@ -3420,7 +3470,7 @@ static int _regulator_get_current_limit(struct regulator_dev *rdev)
 
 	ret = rdev->desc->ops->get_current_limit(rdev);
 out:
-	mutex_unlock(&rdev->mutex);
+	regulator_unlock(rdev);
 	return ret;
 }
 
@@ -3456,7 +3506,7 @@ int regulator_set_mode(struct regulator *regulator, unsigned int mode)
 	int ret;
 	int regulator_curr_mode;
 
-	mutex_lock(&rdev->mutex);
+	regulator_lock(rdev);
 
 	/* sanity check */
 	if (!rdev->desc->ops->set_mode) {
@@ -3480,7 +3530,7 @@ int regulator_set_mode(struct regulator *regulator, unsigned int mode)
 
 	ret = rdev->desc->ops->set_mode(rdev, mode);
 out:
-	mutex_unlock(&rdev->mutex);
+	regulator_unlock(rdev);
 	return ret;
 }
 EXPORT_SYMBOL_GPL(regulator_set_mode);
@@ -3489,7 +3539,7 @@ static unsigned int _regulator_get_mode(struct regulator_dev *rdev)
 {
 	int ret;
 
-	mutex_lock(&rdev->mutex);
+	regulator_lock(rdev);
 
 	/* sanity check */
 	if (!rdev->desc->ops->get_mode) {
@@ -3499,7 +3549,7 @@ static unsigned int _regulator_get_mode(struct regulator_dev *rdev)
 
 	ret = rdev->desc->ops->get_mode(rdev);
 out:
-	mutex_unlock(&rdev->mutex);
+	regulator_unlock(rdev);
 	return ret;
 }
 
@@ -3520,7 +3570,7 @@ static int _regulator_get_error_flags(struct regulator_dev *rdev,
 {
 	int ret;
 
-	mutex_lock(&rdev->mutex);
+	regulator_lock(rdev);
 
 	/* sanity check */
 	if (!rdev->desc->ops->get_error_flags) {
@@ -3530,7 +3580,7 @@ static int _regulator_get_error_flags(struct regulator_dev *rdev,
 
 	ret = rdev->desc->ops->get_error_flags(rdev, flags);
 out:
-	mutex_unlock(&rdev->mutex);
+	regulator_unlock(rdev);
 	return ret;
 }
 
@@ -3579,10 +3629,10 @@ int regulator_set_load(struct regulator *regulator, int uA_load)
 	struct regulator_dev *rdev = regulator->rdev;
 	int ret;
 
-	mutex_lock(&rdev->mutex);
+	regulator_lock(rdev);
 	regulator->uA_load = uA_load;
 	ret = drms_uA_update(rdev);
-	mutex_unlock(&rdev->mutex);
+	regulator_unlock(rdev);
 
 	return ret;
 }
@@ -3610,7 +3660,7 @@ int regulator_allow_bypass(struct regulator *regulator, bool enable)
 	if (!regulator_ops_is_valid(rdev, REGULATOR_CHANGE_BYPASS))
 		return 0;
 
-	mutex_lock(&rdev->mutex);
+	regulator_lock(rdev);
 
 	if (enable && !regulator->bypass) {
 		rdev->bypass_count++;
@@ -3634,7 +3684,7 @@ int regulator_allow_bypass(struct regulator *regulator, bool enable)
 	if (ret == 0)
 		regulator->bypass = enable;
 
-	mutex_unlock(&rdev->mutex);
+	regulator_unlock(rdev);
 
 	return ret;
 }
@@ -4300,9 +4350,9 @@ static int _regulator_suspend_late(struct device *dev, void *data)
 	suspend_state_t *state = data;
 	int ret;
 
-	mutex_lock(&rdev->mutex);
+	regulator_lock(rdev);
 	ret = suspend_set_state(rdev, *state);
-	mutex_unlock(&rdev->mutex);
+	regulator_unlock(rdev);
 
 	return ret;
 }
@@ -4332,14 +4382,14 @@ static int _regulator_resume_early(struct device *dev, void *data)
 	if (rstate == NULL)
 		return 0;
 
-	mutex_lock(&rdev->mutex);
+	regulator_lock(rdev);
 
 	if (rdev->desc->ops->resume_early &&
 	    (rstate->enabled == ENABLE_IN_SUSPEND ||
 	     rstate->enabled == DISABLE_IN_SUSPEND))
 		ret = rdev->desc->ops->resume_early(rdev);
 
-	mutex_unlock(&rdev->mutex);
+	regulator_unlock(rdev);
 
 	return ret;
 }
@@ -4641,7 +4691,7 @@ static int __init regulator_late_cleanup(struct device *dev, void *data)
 	if (!regulator_ops_is_valid(rdev, REGULATOR_CHANGE_STATUS))
 		return 0;
 
-	mutex_lock(&rdev->mutex);
+	regulator_lock(rdev);
 
 	if (rdev->use_count)
 		goto unlock;
@@ -4672,7 +4722,7 @@ static int __init regulator_late_cleanup(struct device *dev, void *data)
 	}
 
 unlock:
-	mutex_unlock(&rdev->mutex);
+	regulator_unlock(rdev);
 
 	return 0;
 }

commit 84b3a7c9c6befe5ab4d49070fe7bcab2da22637e
Author: Douglas Anderson <dianders@chromium.org>
Date:   Tue May 15 15:07:17 2018 -0700

    regulator: core: Allow for regulators that can't be read at bootup
    
    Regulators attached via RPMh on Qualcomm sdm845 apparently are
    write-only.  Specifically you can send a request for a certain voltage
    but you can't read back to see what voltage you've requested.  What
    this means is that at bootup we have absolutely no idea what voltage
    we could be at.
    
    As discussed in the patches to try to support the RPMh regulators [1],
    the fact that regulators are write-only means that its driver's
    get_voltage_sel() should return an error code if it's called before
    any calls to set_voltage_sel().  This causes problems in
    machine_constraints_voltage() when trying to apply the constraints.
    
    A proposed fix was to come up with an error code that could be
    returned by get_voltage_sel() which would cause the regulator
    framework to simply try setting the voltage with the current
    constraints.
    
    In this patch I propose the error code -ENOTRECOVERABLE.  In errno.h
    this error is described as "State not recoverable".  Though the error
    code was originally intended "for robust mutexes", the description of
    the error code seems to apply here because we can't read the state of
    the regulator.  Also note that the only existing user of this error
    code in the regulator framework is tps65090-regulator.c which returns
    this error code from the enable() call (not get_voltage() or
    get_voltage_sel()), so there should be no existing regulators that
    might accidentally get the new behavior.  (Side note is that tps65090
    seems to interpret this error code to mean an error that you can't
    recover from rather than some data that can't be recovered).
    
    [1] https://patchwork.kernel.org/patch/10340897/
    
    Signed-off-by: Douglas Anderson <dianders@chromium.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index d4803460a557..fe314ff56772 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -886,6 +886,18 @@ static int machine_constraints_voltage(struct regulator_dev *rdev,
 	    rdev->constraints->min_uV && rdev->constraints->max_uV) {
 		int target_min, target_max;
 		int current_uV = _regulator_get_voltage(rdev);
+
+		if (current_uV == -ENOTRECOVERABLE) {
+			/* This regulator can't be read and must be initted */
+			rdev_info(rdev, "Setting %d-%duV\n",
+				  rdev->constraints->min_uV,
+				  rdev->constraints->max_uV);
+			_regulator_do_set_voltage(rdev,
+						  rdev->constraints->min_uV,
+						  rdev->constraints->max_uV);
+			current_uV = _regulator_get_voltage(rdev);
+		}
+
 		if (current_uV < 0) {
 			rdev_err(rdev,
 				 "failed to get the current voltage(%d)\n",

commit 36fd679f45a25a7c634b3dbec35a2d7fdb832a65
Merge: bca334e3eac0 a265b03bd29a 4b7529162183 d3e4eccbb8dd 37ad490bab09
Author: Mark Brown <broonie@kernel.org>
Date:   Wed Mar 28 10:33:53 2018 +0800

    Merge remote-tracking branches 'regulator/topic/88pg86x', 'regulator/topic/dt', 'regulator/topic/formatting' and 'regulator/topic/gpio' into regulator-next

commit d3e4eccbb8ddd2bcf906a9c2a43980b00a568eb4
Author: Mark Brown <broonie@kernel.org>
Date:   Thu Mar 22 15:23:35 2018 +0800

    regulator: core: Add missing blank line between functions
    
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index dd4708c58480..bdd947083924 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -4301,6 +4301,7 @@ static int regulator_suspend_late(struct device *dev)
 	return class_for_each_device(&regulator_class, NULL, &state,
 				     _regulator_suspend_late);
 }
+
 static int _regulator_resume_early(struct device *dev, void *data)
 {
 	int ret = 0;

commit 35b5f14ec6dab281346a2d0ceb34abe2dba94190
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Tue Feb 13 10:37:59 2018 +0100

    regulator: Fix resume from suspend to idle
    
    When resuming from idle with the new suspend mode configuration support
    we go through the resume callbacks with a state of PM_SUSPEND_TO_IDLE
    which we don't have regulator constraints for, causing an error:
    
        dpm_run_callback(): regulator_resume_early+0x0/0x64 returns -22
        PM: Device regulator.0 failed to resume early: error -22
    
    Avoid this and similar errors by treating missing constraints as a noop.
    
    See also commit 57a0dd187956ea04 ("regulator: Fix suspend to idle"),
    which fixed the suspend part.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index dd4708c58480..1fc0c0811da4 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -4310,7 +4310,7 @@ static int _regulator_resume_early(struct device *dev, void *data)
 
 	rstate = regulator_get_suspend_state(rdev, *state);
 	if (rstate == NULL)
-		return -EINVAL;
+		return 0;
 
 	mutex_lock(&rdev->mutex);
 

commit e45e290a882e2c0dc8ebb7dd21c66a8209d8e3a5
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Mon Feb 12 14:16:57 2018 +0100

    regulator: core: Support passing an initialized GPIO enable descriptor
    
    We are currently passing a GPIO number from the global GPIO numberspace
    into the regulator core for handling enable GPIOs. This is not good
    since it ties into the global GPIO numberspace and uses gpio_to_desc()
    to overcome this.
    
    Start supporting passing an already initialized GPIO descriptor to the
    core instead: leaf drivers pick their descriptors, associated directly
    with the device node (or from ACPI or from a board descriptor table)
    and use that directly without any roundtrip over the global GPIO
    numberspace.
    
    This looks messy since it adds a bunch of extra code in the core, but
    at the end of the patch series we will delete the handling of the GPIO
    number and only deal with descriptors so things end up neat.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index dd4708c58480..4549b93b0ff9 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1937,7 +1937,10 @@ static int regulator_ena_gpio_request(struct regulator_dev *rdev,
 	struct gpio_desc *gpiod;
 	int ret;
 
-	gpiod = gpio_to_desc(config->ena_gpio);
+	if (config->ena_gpiod)
+		gpiod = config->ena_gpiod;
+	else
+		gpiod = gpio_to_desc(config->ena_gpio);
 
 	list_for_each_entry(pin, &regulator_ena_gpio_list, list) {
 		if (pin->gpiod == gpiod) {
@@ -1947,15 +1950,18 @@ static int regulator_ena_gpio_request(struct regulator_dev *rdev,
 		}
 	}
 
-	ret = gpio_request_one(config->ena_gpio,
-				GPIOF_DIR_OUT | config->ena_gpio_flags,
-				rdev_get_name(rdev));
-	if (ret)
-		return ret;
+	if (!config->ena_gpiod) {
+		ret = gpio_request_one(config->ena_gpio,
+				       GPIOF_DIR_OUT | config->ena_gpio_flags,
+				       rdev_get_name(rdev));
+		if (ret)
+			return ret;
+	}
 
 	pin = kzalloc(sizeof(struct regulator_enable_gpio), GFP_KERNEL);
 	if (pin == NULL) {
-		gpio_free(config->ena_gpio);
+		if (!config->ena_gpiod)
+			gpio_free(config->ena_gpio);
 		return -ENOMEM;
 	}
 
@@ -4154,8 +4160,9 @@ regulator_register(const struct regulator_desc *regulator_desc,
 			goto clean;
 	}
 
-	if ((config->ena_gpio || config->ena_gpio_initialized) &&
-	    gpio_is_valid(config->ena_gpio)) {
+	if (config->ena_gpiod ||
+	    ((config->ena_gpio || config->ena_gpio_initialized) &&
+	     gpio_is_valid(config->ena_gpio))) {
 		mutex_lock(&regulator_list_mutex);
 		ret = regulator_ena_gpio_request(rdev, config);
 		mutex_unlock(&regulator_list_mutex);

commit 57a0dd187956ea04870f4bbbf25a63c425ee7cad
Author: Mark Brown <broonie@kernel.org>
Date:   Tue Jan 30 12:16:31 2018 +0000

    regulator: Fix suspend to idle
    
    When suspending to idle with the new suspend mode configuration support
    we go through the suspend callbacks with a state of PM_SUSPEND_TO_IDLE
    which we don't have regulator constraints for, causing an error.  Avoid
    this and similar errors by treating missing constraints as a noop.
    
    Reported-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Tested-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 42681c10cbe4..dd4708c58480 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -758,7 +758,7 @@ static int suspend_set_state(struct regulator_dev *rdev,
 
 	rstate = regulator_get_suspend_state(rdev, state);
 	if (rstate == NULL)
-		return -EINVAL;
+		return 0;
 
 	/* If we have no suspend mode configration don't set anything;
 	 * only warn if the driver implements set_suspend_voltage or

commit 00cb9f4f5ef5e98653d4726836a4482180bd2efd
Author: Mark Brown <broonie@kernel.org>
Date:   Fri Jan 26 17:55:30 2018 +0000

    regulator: Fix build error
    
    3d67fe950707 (regulator: core: Refactor regulator_list_voltage()) missed
    one user of regulator_list_voltage(), update for that.
    
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 2dccc4b3766e..42681c10cbe4 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2980,7 +2980,7 @@ static int regulator_set_voltage_unlocked(struct regulator *regulator,
 			goto out2;
 		}
 
-		best_supply_uV = _regulator_list_voltage(regulator, selector, 0);
+		best_supply_uV = _regulator_list_voltage(rdev, selector, 0);
 		if (best_supply_uV < 0) {
 			ret = best_supply_uV;
 			goto out2;

commit 285c22de377dd6895af30af6272cc7778cee36a7
Merge: 3d67fe950707 f7efad10b5c4
Author: Mark Brown <broonie@kernel.org>
Date:   Fri Jan 26 17:40:03 2018 +0000

    Merge branch 'topic/suspend' of https://git.kernel.org/pub/scm/linux/kernel/git/broonie/regulator into regulator-core

commit 3d67fe950707a930664c5673ecc026f1bb497136
Author: Maciej Purski <m.purski@samsung.com>
Date:   Mon Jan 22 15:30:07 2018 +0100

    regulator: core: Refactor regulator_list_voltage()
    
    Change _regulator_list_voltage() argument from regulator to
    regulator_dev in order to provide better separation of core layers.
    Allow calling _regulator_list_voltage() from functions, with
    regulator_dev argument. This refactoring is needed in order to
    implement setting voltage of coupled regulators.
    
    Signed-off-by: Maciej Purski <m.purski@samsung.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 5f7678292cef..fd8eacfea422 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2447,10 +2447,9 @@ static int _regulator_is_enabled(struct regulator_dev *rdev)
 	return rdev->desc->ops->is_enabled(rdev);
 }
 
-static int _regulator_list_voltage(struct regulator *regulator,
-				    unsigned selector, int lock)
+static int _regulator_list_voltage(struct regulator_dev *rdev,
+				   unsigned selector, int lock)
 {
-	struct regulator_dev *rdev = regulator->rdev;
 	const struct regulator_ops *ops = rdev->desc->ops;
 	int ret;
 
@@ -2466,7 +2465,8 @@ static int _regulator_list_voltage(struct regulator *regulator,
 		if (lock)
 			mutex_unlock(&rdev->mutex);
 	} else if (rdev->is_switch && rdev->supply) {
-		ret = _regulator_list_voltage(rdev->supply, selector, lock);
+		ret = _regulator_list_voltage(rdev->supply->rdev,
+					      selector, lock);
 	} else {
 		return -EINVAL;
 	}
@@ -2542,7 +2542,7 @@ EXPORT_SYMBOL_GPL(regulator_count_voltages);
  */
 int regulator_list_voltage(struct regulator *regulator, unsigned selector)
 {
-	return _regulator_list_voltage(regulator, selector, 1);
+	return _regulator_list_voltage(regulator->rdev, selector, 1);
 }
 EXPORT_SYMBOL_GPL(regulator_list_voltage);
 

commit 148096af0bf381c78afe253c07ef1c77778f0e68
Author: Maciej Purski <m.purski@samsung.com>
Date:   Mon Jan 22 15:30:06 2018 +0100

    regulator: core: Move of_find_regulator_by_node() to of_regulator.c
    
    As of_find_regulator_by_node() is an of function it should be moved from
    core.c to of_regulator.c. It provides better separation of device tree
    functions from the core and allows other of_functions in of_regulator.c
    to resolve device_node to regulator_dev. This will be useful for
    implementation of parsing coupled regulators properties.
    
    Declare of_find_regulator_by_node() function in internal.h as well as
    regulator_class and dev_to_rdev(), as they are needed by
    of_find_regulator_by_node().
    
    Signed-off-by: Maciej Purski <m.purski@samsung.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 365b32e3f505..5f7678292cef 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -58,8 +58,6 @@ static bool has_full_constraints;
 
 static struct dentry *debugfs_root;
 
-static struct class regulator_class;
-
 /*
  * struct regulator_map
  *
@@ -112,11 +110,6 @@ static struct regulator *create_regulator(struct regulator_dev *rdev,
 					  const char *supply_name);
 static void _regulator_put(struct regulator *regulator);
 
-static struct regulator_dev *dev_to_rdev(struct device *dev)
-{
-	return container_of(dev, struct regulator_dev, dev);
-}
-
 static const char *rdev_get_name(struct regulator_dev *rdev)
 {
 	if (rdev->constraints && rdev->constraints->name)
@@ -1417,20 +1410,6 @@ static void regulator_supply_alias(struct device **dev, const char **supply)
 	}
 }
 
-static int of_node_match(struct device *dev, const void *data)
-{
-	return dev->of_node == data;
-}
-
-static struct regulator_dev *of_find_regulator_by_node(struct device_node *np)
-{
-	struct device *dev;
-
-	dev = class_find_device(&regulator_class, NULL, np, of_node_match);
-
-	return dev ? dev_to_rdev(dev) : NULL;
-}
-
 static int regulator_match(struct device *dev, const void *data)
 {
 	struct regulator_dev *r = dev_to_rdev(dev);
@@ -3918,7 +3897,7 @@ static void regulator_dev_release(struct device *dev)
 	kfree(rdev);
 }
 
-static struct class regulator_class = {
+struct class regulator_class = {
 	.name = "regulator",
 	.dev_release = regulator_dev_release,
 	.dev_groups = regulator_dev_groups,

commit f7efad10b5c492892b1e5decf5d3ebb29fa5c9af
Author: Chunyan Zhang <zhang.chunyan@linaro.org>
Date:   Fri Jan 26 21:08:47 2018 +0800

    regulator: add PM suspend and resume hooks
    
    In this patch, consumers are allowed to set suspend voltage, and this
    actually just set the "uV" in constraint::regulator_state, when the
    regulator_suspend_late() was called by PM core through callback when
    the system is entering into suspend, the regulator device would act
    suspend activity then.
    
    And it assumes that if any consumer set suspend voltage, the regulator
    device should be enabled in the suspend state.  And if the suspend
    voltage of a regulator device for all consumers was set zero, the
    regulator device would be off in the suspend state.
    
    This patch also provides a new function hook to regulator devices for
    resuming from suspend states.
    
    Signed-off-by: Chunyan Zhang <zhang.chunyan@linaro.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 080c2334edc5..949e317e4d6e 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -236,6 +236,12 @@ static int regulator_check_voltage(struct regulator_dev *rdev,
 	return 0;
 }
 
+/* return 0 if the state is valid */
+static int regulator_check_states(suspend_state_t state)
+{
+	return (state > PM_SUSPEND_MAX || state == PM_SUSPEND_TO_IDLE);
+}
+
 /* Make sure we select a voltage that suits the needs of all
  * regulator consumers
  */
@@ -327,6 +333,24 @@ static int regulator_mode_constrain(struct regulator_dev *rdev,
 	return -EINVAL;
 }
 
+static inline struct regulator_state *
+regulator_get_suspend_state(struct regulator_dev *rdev, suspend_state_t state)
+{
+	if (rdev->constraints == NULL)
+		return NULL;
+
+	switch (state) {
+	case PM_SUSPEND_STANDBY:
+		return &rdev->constraints->state_standby;
+	case PM_SUSPEND_MEM:
+		return &rdev->constraints->state_mem;
+	case PM_SUSPEND_MAX:
+		return &rdev->constraints->state_disk;
+	default:
+		return NULL;
+	}
+}
+
 static ssize_t regulator_uV_show(struct device *dev,
 				struct device_attribute *attr, char *buf)
 {
@@ -734,9 +758,14 @@ static int drms_uA_update(struct regulator_dev *rdev)
 }
 
 static int suspend_set_state(struct regulator_dev *rdev,
-	struct regulator_state *rstate)
+				    suspend_state_t state)
 {
 	int ret = 0;
+	struct regulator_state *rstate;
+
+	rstate = regulator_get_suspend_state(rdev, state);
+	if (rstate == NULL)
+		return -EINVAL;
 
 	/* If we have no suspend mode configration don't set anything;
 	 * only warn if the driver implements set_suspend_voltage or
@@ -779,28 +808,8 @@ static int suspend_set_state(struct regulator_dev *rdev,
 			return ret;
 		}
 	}
-	return ret;
-}
 
-/* locks held by caller */
-static int suspend_prepare(struct regulator_dev *rdev, suspend_state_t state)
-{
-	if (!rdev->constraints)
-		return -EINVAL;
-
-	switch (state) {
-	case PM_SUSPEND_STANDBY:
-		return suspend_set_state(rdev,
-			&rdev->constraints->state_standby);
-	case PM_SUSPEND_MEM:
-		return suspend_set_state(rdev,
-			&rdev->constraints->state_mem);
-	case PM_SUSPEND_MAX:
-		return suspend_set_state(rdev,
-			&rdev->constraints->state_disk);
-	default:
-		return -EINVAL;
-	}
+	return ret;
 }
 
 static void print_constraints(struct regulator_dev *rdev)
@@ -1069,7 +1078,7 @@ static int set_machine_constraints(struct regulator_dev *rdev,
 
 	/* do we need to setup our suspend state */
 	if (rdev->constraints->initial_state) {
-		ret = suspend_prepare(rdev, rdev->constraints->initial_state);
+		ret = suspend_set_state(rdev, rdev->constraints->initial_state);
 		if (ret < 0) {
 			rdev_err(rdev, "failed to set suspend state\n");
 			return ret;
@@ -2898,6 +2907,32 @@ static int _regulator_do_set_voltage(struct regulator_dev *rdev,
 	return ret;
 }
 
+static int _regulator_do_set_suspend_voltage(struct regulator_dev *rdev,
+				  int min_uV, int max_uV, suspend_state_t state)
+{
+	struct regulator_state *rstate;
+	int uV, sel;
+
+	rstate = regulator_get_suspend_state(rdev, state);
+	if (rstate == NULL)
+		return -EINVAL;
+
+	if (min_uV < rstate->min_uV)
+		min_uV = rstate->min_uV;
+	if (max_uV > rstate->max_uV)
+		max_uV = rstate->max_uV;
+
+	sel = regulator_map_voltage(rdev, min_uV, max_uV);
+	if (sel < 0)
+		return sel;
+
+	uV = rdev->desc->ops->list_voltage(rdev, sel);
+	if (uV >= min_uV && uV <= max_uV)
+		rstate->uV = uV;
+
+	return 0;
+}
+
 static int regulator_set_voltage_unlocked(struct regulator *regulator,
 					  int min_uV, int max_uV,
 					  suspend_state_t state)
@@ -2993,7 +3028,11 @@ static int regulator_set_voltage_unlocked(struct regulator *regulator,
 		}
 	}
 
-	ret = _regulator_do_set_voltage(rdev, min_uV, max_uV);
+	if (state == PM_SUSPEND_ON)
+		ret = _regulator_do_set_voltage(rdev, min_uV, max_uV);
+	else
+		ret = _regulator_do_set_suspend_voltage(rdev, min_uV,
+							max_uV, state);
 	if (ret < 0)
 		goto out2;
 
@@ -3049,6 +3088,89 @@ int regulator_set_voltage(struct regulator *regulator, int min_uV, int max_uV)
 }
 EXPORT_SYMBOL_GPL(regulator_set_voltage);
 
+static inline int regulator_suspend_toggle(struct regulator_dev *rdev,
+					   suspend_state_t state, bool en)
+{
+	struct regulator_state *rstate;
+
+	rstate = regulator_get_suspend_state(rdev, state);
+	if (rstate == NULL)
+		return -EINVAL;
+
+	if (!rstate->changeable)
+		return -EPERM;
+
+	rstate->enabled = en;
+
+	return 0;
+}
+
+int regulator_suspend_enable(struct regulator_dev *rdev,
+				    suspend_state_t state)
+{
+	return regulator_suspend_toggle(rdev, state, true);
+}
+EXPORT_SYMBOL_GPL(regulator_suspend_enable);
+
+int regulator_suspend_disable(struct regulator_dev *rdev,
+				     suspend_state_t state)
+{
+	struct regulator *regulator;
+	struct regulator_voltage *voltage;
+
+	/*
+	 * if any consumer wants this regulator device keeping on in
+	 * suspend states, don't set it as disabled.
+	 */
+	list_for_each_entry(regulator, &rdev->consumer_list, list) {
+		voltage = &regulator->voltage[state];
+		if (voltage->min_uV || voltage->max_uV)
+			return 0;
+	}
+
+	return regulator_suspend_toggle(rdev, state, false);
+}
+EXPORT_SYMBOL_GPL(regulator_suspend_disable);
+
+static int _regulator_set_suspend_voltage(struct regulator *regulator,
+					  int min_uV, int max_uV,
+					  suspend_state_t state)
+{
+	struct regulator_dev *rdev = regulator->rdev;
+	struct regulator_state *rstate;
+
+	rstate = regulator_get_suspend_state(rdev, state);
+	if (rstate == NULL)
+		return -EINVAL;
+
+	if (rstate->min_uV == rstate->max_uV) {
+		rdev_err(rdev, "The suspend voltage can't be changed!\n");
+		return -EPERM;
+	}
+
+	return regulator_set_voltage_unlocked(regulator, min_uV, max_uV, state);
+}
+
+int regulator_set_suspend_voltage(struct regulator *regulator, int min_uV,
+				  int max_uV, suspend_state_t state)
+{
+	int ret = 0;
+
+	/* PM_SUSPEND_ON is handled by regulator_set_voltage() */
+	if (regulator_check_states(state) || state == PM_SUSPEND_ON)
+		return -EINVAL;
+
+	regulator_lock_supply(regulator->rdev);
+
+	ret = _regulator_set_suspend_voltage(regulator, min_uV,
+					     max_uV, state);
+
+	regulator_unlock_supply(regulator->rdev);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(regulator_set_suspend_voltage);
+
 /**
  * regulator_set_voltage_time - get raise/fall time
  * @regulator: regulator source
@@ -3923,12 +4045,6 @@ static void regulator_dev_release(struct device *dev)
 	kfree(rdev);
 }
 
-static struct class regulator_class = {
-	.name = "regulator",
-	.dev_release = regulator_dev_release,
-	.dev_groups = regulator_dev_groups,
-};
-
 static void rdev_init_debugfs(struct regulator_dev *rdev)
 {
 	struct device *parent = rdev->dev.parent;
@@ -4179,7 +4295,86 @@ void regulator_unregister(struct regulator_dev *rdev)
 }
 EXPORT_SYMBOL_GPL(regulator_unregister);
 
+#ifdef CONFIG_SUSPEND
+static int _regulator_suspend_late(struct device *dev, void *data)
+{
+	struct regulator_dev *rdev = dev_to_rdev(dev);
+	suspend_state_t *state = data;
+	int ret;
+
+	mutex_lock(&rdev->mutex);
+	ret = suspend_set_state(rdev, *state);
+	mutex_unlock(&rdev->mutex);
+
+	return ret;
+}
 
+/**
+ * regulator_suspend_late - prepare regulators for system wide suspend
+ * @state: system suspend state
+ *
+ * Configure each regulator with it's suspend operating parameters for state.
+ */
+static int regulator_suspend_late(struct device *dev)
+{
+	suspend_state_t state = pm_suspend_target_state;
+
+	return class_for_each_device(&regulator_class, NULL, &state,
+				     _regulator_suspend_late);
+}
+static int _regulator_resume_early(struct device *dev, void *data)
+{
+	int ret = 0;
+	struct regulator_dev *rdev = dev_to_rdev(dev);
+	suspend_state_t *state = data;
+	struct regulator_state *rstate;
+
+	rstate = regulator_get_suspend_state(rdev, *state);
+	if (rstate == NULL)
+		return -EINVAL;
+
+	mutex_lock(&rdev->mutex);
+
+	if (rdev->desc->ops->resume_early &&
+	    (rstate->enabled == ENABLE_IN_SUSPEND ||
+	     rstate->enabled == DISABLE_IN_SUSPEND))
+		ret = rdev->desc->ops->resume_early(rdev);
+
+	mutex_unlock(&rdev->mutex);
+
+	return ret;
+}
+
+static int regulator_resume_early(struct device *dev)
+{
+	suspend_state_t state = pm_suspend_target_state;
+
+	return class_for_each_device(&regulator_class, NULL, &state,
+				     _regulator_resume_early);
+}
+
+#else /* !CONFIG_SUSPEND */
+
+#define regulator_suspend_late	NULL
+#define regulator_resume_early	NULL
+
+#endif /* !CONFIG_SUSPEND */
+
+#ifdef CONFIG_PM
+static const struct dev_pm_ops __maybe_unused regulator_pm_ops = {
+	.suspend_late	= regulator_suspend_late,
+	.resume_early	= regulator_resume_early,
+};
+#endif
+
+static struct class regulator_class = {
+	.name = "regulator",
+	.dev_release = regulator_dev_release,
+	.dev_groups = regulator_dev_groups,
+#ifdef CONFIG_PM
+	.pm = &regulator_pm_ops,
+#endif
+};
 /**
  * regulator_has_full_constraints - the system has fully specified constraints
  *

commit aa27bbc6c6c60227c096d515f55ffe6cdfef7d2b
Author: Chunyan Zhang <zhang.chunyan@linaro.org>
Date:   Fri Jan 26 21:08:46 2018 +0800

    regulator: empty the old suspend functions
    
    Regualtor suspend/resume functions should only be called by PM suspend
    core via registering dev_pm_ops, and regulator devices should implement
    the callback functions.  Thus, any regulator consumer shouldn't call
    the regulator suspend/resume functions directly.
    
    In order to avoid compile errors, two empty functions with the same name
    still be left for the time being.
    
    Signed-off-by: Chunyan Zhang <zhang.chunyan@linaro.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 5ea80e94eb69..080c2334edc5 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -4179,80 +4179,6 @@ void regulator_unregister(struct regulator_dev *rdev)
 }
 EXPORT_SYMBOL_GPL(regulator_unregister);
 
-static int _regulator_suspend_prepare(struct device *dev, void *data)
-{
-	struct regulator_dev *rdev = dev_to_rdev(dev);
-	const suspend_state_t *state = data;
-	int ret;
-
-	mutex_lock(&rdev->mutex);
-	ret = suspend_prepare(rdev, *state);
-	mutex_unlock(&rdev->mutex);
-
-	return ret;
-}
-
-/**
- * regulator_suspend_prepare - prepare regulators for system wide suspend
- * @state: system suspend state
- *
- * Configure each regulator with it's suspend operating parameters for state.
- * This will usually be called by machine suspend code prior to supending.
- */
-int regulator_suspend_prepare(suspend_state_t state)
-{
-	/* ON is handled by regulator active state */
-	if (state == PM_SUSPEND_ON)
-		return -EINVAL;
-
-	return class_for_each_device(&regulator_class, NULL, &state,
-				     _regulator_suspend_prepare);
-}
-EXPORT_SYMBOL_GPL(regulator_suspend_prepare);
-
-static int _regulator_suspend_finish(struct device *dev, void *data)
-{
-	struct regulator_dev *rdev = dev_to_rdev(dev);
-	int ret;
-
-	mutex_lock(&rdev->mutex);
-	if (rdev->use_count > 0  || rdev->constraints->always_on) {
-		if (!_regulator_is_enabled(rdev)) {
-			ret = _regulator_do_enable(rdev);
-			if (ret)
-				dev_err(dev,
-					"Failed to resume regulator %d\n",
-					ret);
-		}
-	} else {
-		if (!have_full_constraints())
-			goto unlock;
-		if (!_regulator_is_enabled(rdev))
-			goto unlock;
-
-		ret = _regulator_do_disable(rdev);
-		if (ret)
-			dev_err(dev, "Failed to suspend regulator %d\n", ret);
-	}
-unlock:
-	mutex_unlock(&rdev->mutex);
-
-	/* Keep processing regulators in spite of any errors */
-	return 0;
-}
-
-/**
- * regulator_suspend_finish - resume regulators from system wide suspend
- *
- * Turn on regulators that might be turned off by regulator_suspend_prepare
- * and that should be turned on according to the regulators properties.
- */
-int regulator_suspend_finish(void)
-{
-	return class_for_each_device(&regulator_class, NULL, NULL,
-				     _regulator_suspend_finish);
-}
-EXPORT_SYMBOL_GPL(regulator_suspend_finish);
 
 /**
  * regulator_has_full_constraints - the system has fully specified constraints

commit 72069f9957a11896e79e95c8b55ec815e97c2187
Author: Chunyan Zhang <zhang.chunyan@linaro.org>
Date:   Fri Jan 26 21:08:45 2018 +0800

    regulator: leave one item to record whether regulator is enabled
    
    The items "disabled" and "enabled" are a little redundant, since only one
    of them would be set to record if the regulator device should keep on
    or be switched to off in suspend states.
    
    So in this patch, the "disabled" was removed, only leave the "enabled":
      - enabled == 1 for regulator-on-in-suspend
      - enabled == 0 for regulator-off-in-suspend
      - enabled == -1 means do nothing when entering suspend mode.
    
    Signed-off-by: Chunyan Zhang <zhang.chunyan@linaro.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 97bc9f7adf2f..5ea80e94eb69 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -742,21 +742,19 @@ static int suspend_set_state(struct regulator_dev *rdev,
 	 * only warn if the driver implements set_suspend_voltage or
 	 * set_suspend_mode callback.
 	 */
-	if (!rstate->enabled && !rstate->disabled) {
+	if (rstate->enabled != ENABLE_IN_SUSPEND &&
+	    rstate->enabled != DISABLE_IN_SUSPEND) {
 		if (rdev->desc->ops->set_suspend_voltage ||
 		    rdev->desc->ops->set_suspend_mode)
 			rdev_warn(rdev, "No configuration\n");
 		return 0;
 	}
 
-	if (rstate->enabled && rstate->disabled) {
-		rdev_err(rdev, "invalid configuration\n");
-		return -EINVAL;
-	}
-
-	if (rstate->enabled && rdev->desc->ops->set_suspend_enable)
+	if (rstate->enabled == ENABLE_IN_SUSPEND &&
+		rdev->desc->ops->set_suspend_enable)
 		ret = rdev->desc->ops->set_suspend_enable(rdev);
-	else if (rstate->disabled && rdev->desc->ops->set_suspend_disable)
+	else if (rstate->enabled == DISABLE_IN_SUSPEND &&
+		rdev->desc->ops->set_suspend_disable)
 		ret = rdev->desc->ops->set_suspend_disable(rdev);
 	else /* OK if set_suspend_enable or set_suspend_disable is NULL */
 		ret = 0;

commit c360a6df02cdba47c0590ffc7d15ec6687183e8c
Author: Chunyan Zhang <zhang.chunyan@linaro.org>
Date:   Fri Jan 26 21:08:44 2018 +0800

    regulator: make regulator voltage be an array to support more states
    
    Some regulator consumers would like to make the regulator device
    keeping a voltage range output when the system entering into
    suspend states.
    
    Making regulator voltage be an array can allow consumers to set voltage
    for normal state as well as for suspend states through the same code.
    
    Signed-off-by: Chunyan Zhang <zhang.chunyan@linaro.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index b64b7916507f..97bc9f7adf2f 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -240,22 +240,25 @@ static int regulator_check_voltage(struct regulator_dev *rdev,
  * regulator consumers
  */
 static int regulator_check_consumers(struct regulator_dev *rdev,
-				     int *min_uV, int *max_uV)
+				     int *min_uV, int *max_uV,
+				     suspend_state_t state)
 {
 	struct regulator *regulator;
+	struct regulator_voltage *voltage;
 
 	list_for_each_entry(regulator, &rdev->consumer_list, list) {
+		voltage = &regulator->voltage[state];
 		/*
 		 * Assume consumers that didn't say anything are OK
 		 * with anything in the constraint range.
 		 */
-		if (!regulator->min_uV && !regulator->max_uV)
+		if (!voltage->min_uV && !voltage->max_uV)
 			continue;
 
-		if (*max_uV > regulator->max_uV)
-			*max_uV = regulator->max_uV;
-		if (*min_uV < regulator->min_uV)
-			*min_uV = regulator->min_uV;
+		if (*max_uV > voltage->max_uV)
+			*max_uV = voltage->max_uV;
+		if (*min_uV < voltage->min_uV)
+			*min_uV = voltage->min_uV;
 	}
 
 	if (*min_uV > *max_uV) {
@@ -1356,9 +1359,9 @@ static struct regulator *create_regulator(struct regulator_dev *rdev,
 		debugfs_create_u32("uA_load", 0444, regulator->debugfs,
 				   &regulator->uA_load);
 		debugfs_create_u32("min_uV", 0444, regulator->debugfs,
-				   &regulator->min_uV);
+				   &regulator->voltage[PM_SUSPEND_ON].min_uV);
 		debugfs_create_u32("max_uV", 0444, regulator->debugfs,
-				   &regulator->max_uV);
+				   &regulator->voltage[PM_SUSPEND_ON].max_uV);
 		debugfs_create_file("constraint_flags", 0444,
 				    regulator->debugfs, regulator,
 				    &constraint_flags_fops);
@@ -2898,9 +2901,11 @@ static int _regulator_do_set_voltage(struct regulator_dev *rdev,
 }
 
 static int regulator_set_voltage_unlocked(struct regulator *regulator,
-					  int min_uV, int max_uV)
+					  int min_uV, int max_uV,
+					  suspend_state_t state)
 {
 	struct regulator_dev *rdev = regulator->rdev;
+	struct regulator_voltage *voltage = &regulator->voltage[state];
 	int ret = 0;
 	int old_min_uV, old_max_uV;
 	int current_uV;
@@ -2911,7 +2916,7 @@ static int regulator_set_voltage_unlocked(struct regulator *regulator,
 	 * should be a noop (some cpufreq implementations use the same
 	 * voltage for multiple frequencies, for example).
 	 */
-	if (regulator->min_uV == min_uV && regulator->max_uV == max_uV)
+	if (voltage->min_uV == min_uV && voltage->max_uV == max_uV)
 		goto out;
 
 	/* If we're trying to set a range that overlaps the current voltage,
@@ -2921,8 +2926,8 @@ static int regulator_set_voltage_unlocked(struct regulator *regulator,
 	if (!regulator_ops_is_valid(rdev, REGULATOR_CHANGE_VOLTAGE)) {
 		current_uV = _regulator_get_voltage(rdev);
 		if (min_uV <= current_uV && current_uV <= max_uV) {
-			regulator->min_uV = min_uV;
-			regulator->max_uV = max_uV;
+			voltage->min_uV = min_uV;
+			voltage->max_uV = max_uV;
 			goto out;
 		}
 	}
@@ -2940,12 +2945,12 @@ static int regulator_set_voltage_unlocked(struct regulator *regulator,
 		goto out;
 
 	/* restore original values in case of error */
-	old_min_uV = regulator->min_uV;
-	old_max_uV = regulator->max_uV;
-	regulator->min_uV = min_uV;
-	regulator->max_uV = max_uV;
+	old_min_uV = voltage->min_uV;
+	old_max_uV = voltage->max_uV;
+	voltage->min_uV = min_uV;
+	voltage->max_uV = max_uV;
 
-	ret = regulator_check_consumers(rdev, &min_uV, &max_uV);
+	ret = regulator_check_consumers(rdev, &min_uV, &max_uV, state);
 	if (ret < 0)
 		goto out2;
 
@@ -2982,7 +2987,7 @@ static int regulator_set_voltage_unlocked(struct regulator *regulator,
 
 	if (supply_change_uV > 0) {
 		ret = regulator_set_voltage_unlocked(rdev->supply,
-				best_supply_uV, INT_MAX);
+				best_supply_uV, INT_MAX, state);
 		if (ret) {
 			dev_err(&rdev->dev, "Failed to increase supply voltage: %d\n",
 					ret);
@@ -2996,7 +3001,7 @@ static int regulator_set_voltage_unlocked(struct regulator *regulator,
 
 	if (supply_change_uV < 0) {
 		ret = regulator_set_voltage_unlocked(rdev->supply,
-				best_supply_uV, INT_MAX);
+				best_supply_uV, INT_MAX, state);
 		if (ret)
 			dev_warn(&rdev->dev, "Failed to decrease supply voltage: %d\n",
 					ret);
@@ -3007,8 +3012,8 @@ static int regulator_set_voltage_unlocked(struct regulator *regulator,
 out:
 	return ret;
 out2:
-	regulator->min_uV = old_min_uV;
-	regulator->max_uV = old_max_uV;
+	voltage->min_uV = old_min_uV;
+	voltage->max_uV = old_max_uV;
 
 	return ret;
 }
@@ -3037,7 +3042,8 @@ int regulator_set_voltage(struct regulator *regulator, int min_uV, int max_uV)
 
 	regulator_lock_supply(regulator->rdev);
 
-	ret = regulator_set_voltage_unlocked(regulator, min_uV, max_uV);
+	ret = regulator_set_voltage_unlocked(regulator, min_uV, max_uV,
+					     PM_SUSPEND_ON);
 
 	regulator_unlock_supply(regulator->rdev);
 
@@ -3138,6 +3144,7 @@ EXPORT_SYMBOL_GPL(regulator_set_voltage_time_sel);
 int regulator_sync_voltage(struct regulator *regulator)
 {
 	struct regulator_dev *rdev = regulator->rdev;
+	struct regulator_voltage *voltage = &regulator->voltage[PM_SUSPEND_ON];
 	int ret, min_uV, max_uV;
 
 	mutex_lock(&rdev->mutex);
@@ -3149,20 +3156,20 @@ int regulator_sync_voltage(struct regulator *regulator)
 	}
 
 	/* This is only going to work if we've had a voltage configured. */
-	if (!regulator->min_uV && !regulator->max_uV) {
+	if (!voltage->min_uV && !voltage->max_uV) {
 		ret = -EINVAL;
 		goto out;
 	}
 
-	min_uV = regulator->min_uV;
-	max_uV = regulator->max_uV;
+	min_uV = voltage->min_uV;
+	max_uV = voltage->max_uV;
 
 	/* This should be a paranoia check... */
 	ret = regulator_check_voltage(rdev, &min_uV, &max_uV);
 	if (ret < 0)
 		goto out;
 
-	ret = regulator_check_consumers(rdev, &min_uV, &max_uV);
+	ret = regulator_check_consumers(rdev, &min_uV, &max_uV, 0);
 	if (ret < 0)
 		goto out;
 
@@ -4424,8 +4431,8 @@ static void regulator_summary_show_subtree(struct seq_file *s,
 		switch (rdev->desc->type) {
 		case REGULATOR_VOLTAGE:
 			seq_printf(s, "%37dmV %5dmV",
-				   consumer->min_uV / 1000,
-				   consumer->max_uV / 1000);
+				   consumer->voltage[PM_SUSPEND_ON].min_uV / 1000,
+				   consumer->voltage[PM_SUSPEND_ON].max_uV / 1000);
 			break;
 		case REGULATOR_CURRENT:
 			break;

commit 0d5c8633b173dd64f0005bba83501c8462463e65
Author: Colin Ian King <colin.king@canonical.com>
Date:   Thu Dec 7 13:30:09 2017 +0000

    regulator: fix incorrect indentation of two assignment statements
    
    Remove extraneous space to fix indentation on a couple of assignment
    statements.
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index b64b7916507f..365b32e3f505 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2605,8 +2605,8 @@ int regulator_get_hardware_vsel_register(struct regulator *regulator,
 	if (ops->set_voltage_sel != regulator_set_voltage_sel_regmap)
 		return -EOPNOTSUPP;
 
-	 *vsel_reg = rdev->desc->vsel_reg;
-	 *vsel_mask = rdev->desc->vsel_mask;
+	*vsel_reg = rdev->desc->vsel_reg;
+	*vsel_mask = rdev->desc->vsel_mask;
 
 	 return 0;
 }

commit 02929a4478b66727dc895346a408b63e06dfe4ee
Merge: 0ab912978c62 74ff8e065101 b66156598278 7799167b7a14 fc1111b88543 6d284bb11c30
Author: Mark Brown <broonie@kernel.org>
Date:   Mon Sep 4 17:45:42 2017 +0100

    Merge remote-tracking branches 'regulator/topic/cpcap', 'regulator/topic/da9063', 'regulator/topic/dt', 'regulator/topic/fan53555' and 'regulator/topic/ltc3589' into regulator-next

commit c9ccaa0cac3fc8e7d17a668aabfdf632c7c0517a
Author: Tirupathi Reddy <tirupath@codeaurora.org>
Date:   Wed Jul 12 17:08:13 2017 +0530

    regulator: core: fix a possible race in disable_work handling
    
    A race condition between queueing and processing the disable_work
    instances results in having a work instance in the queue and the
    deferred_disables variable of regulator device structure having a
    value '0'. If no new regulator_disable_deferred() call later from
    clients, the deferred_disables variable value remains '0' and hits
    BUG() in regulator_disable_work() when the queued instance scheduled
    for processing the work.
    
    The race occurs as below:
    
            Core-0                                       Core-1
            .....          /* deferred_disables = 2 */   .....
            .....          /* disable_work is queued */  .....
            .....                                        .....
    regulator_disable_deferred:             regulator_disable_work:
       mutex_lock(&rdev->mutex);                         .....
       rdev->deferred_disables++;                        .....
       mutex_unlock(&rdev->mutex);                       .....
       queue_delayed_work(...)                  mutex_lock(&rdev->mutex);
            .....                               count =rdev->deferred_disables;
            .....                               rdev->deferred_disables = 0;
            .....                                        .....
            .....                               mutex_unlock(&rdev->mutex);
            .....                                        .....
            .....                               return;
            .....                                        .....
            /* No new regulator_disable_deferred() calls from clients */
            /* The newly queued instance is scheduled for processing */
            .....                                        .....
    regulator_disable_work:
            .....
       mutex_lock(&rdev->mutex);
       BUG_ON(!rdev->deferred_disables); /* deferred_disables = 0 */
    
    The race is fixed by removing the work instance that is queued while
    processing the previous queued instance. Cancel the newly queued instance
    from disable_work() handler just after reset the deferred_disables variable
    to value '0'. Also move the work queueing step before mutex_unlock in
    regulator_disable_deferred().
    
    Also use mod_delayed_work() in the pace of queue_delayed_work() as
    queue_delayed_work() always uses the delay requested in the first call
    when multiple consumers call regulator_disable_deferred() close in time
    and does not guarantee the semantics of regulator_disable_deferred().
    
    Signed-off-by: Tirupathi Reddy <tirupath@codeaurora.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index e567fa54980b..9f4d484eb25d 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2396,6 +2396,14 @@ static void regulator_disable_work(struct work_struct *work)
 	count = rdev->deferred_disables;
 	rdev->deferred_disables = 0;
 
+	/*
+	 * Workqueue functions queue the new work instance while the previous
+	 * work instance is being processed. Cancel the queued work instance
+	 * as the work instance under processing does the job of the queued
+	 * work instance.
+	 */
+	cancel_delayed_work(&rdev->disable_work);
+
 	for (i = 0; i < count; i++) {
 		ret = _regulator_disable(rdev);
 		if (ret != 0)
@@ -2439,10 +2447,10 @@ int regulator_disable_deferred(struct regulator *regulator, int ms)
 
 	mutex_lock(&rdev->mutex);
 	rdev->deferred_disables++;
+	mod_delayed_work(system_power_efficient_wq, &rdev->disable_work,
+			 msecs_to_jiffies(ms));
 	mutex_unlock(&rdev->mutex);
 
-	queue_delayed_work(system_power_efficient_wq, &rdev->disable_work,
-			   msecs_to_jiffies(ms));
 	return 0;
 }
 EXPORT_SYMBOL_GPL(regulator_disable_deferred);

commit 7799167b7a14feb17c258fb33a02c61eb54f67d1
Author: Rob Herring <robh@kernel.org>
Date:   Tue Jul 18 16:43:26 2017 -0500

    regulator: Convert to using %pOF instead of full_name
    
    Now that we have a custom printf format specifier, convert users of
    full_name to use %pOF instead. This is preparation to remove storing
    of the full path string for each node.
    
    Signed-off-by: Rob Herring <robh@kernel.org>
    Reviewed-by: Krzysztof Kozlowski <krzk@kernel.org>
    Reviewed-by: Philipp Zabel <p.zabel@pengutronix.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index e567fa54980b..d79ba9af9352 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -204,8 +204,8 @@ static struct device_node *of_get_regulator(struct device *dev, const char *supp
 	regnode = of_parse_phandle(dev->of_node, prop_name, 0);
 
 	if (!regnode) {
-		dev_dbg(dev, "Looking up %s property in node %s failed\n",
-				prop_name, dev->of_node->full_name);
+		dev_dbg(dev, "Looking up %s property in node %pOF failed\n",
+				prop_name, dev->of_node);
 		return NULL;
 	}
 	return regnode;

commit 8d67f64f7739464c352d4b167ed1748f3b2c1f44
Merge: 9b08f765f581 3ffad468cf1d a9bc67de0c57 be035303182a
Author: Mark Brown <broonie@kernel.org>
Date:   Mon Jul 3 16:52:21 2017 +0100

    Merge remote-tracking branches 'regulator/topic/settle', 'regulator/topic/tps65910' and 'regulator/topic/tps65917' into regulator-next

commit fcaa3167b2763d35a7dc60c5724f23e441d29f4f
Merge: 85fd19e432b5 dbc559554086
Author: Mark Brown <broonie@kernel.org>
Date:   Mon Jul 3 16:52:16 2017 +0100

    Merge remote-tracking branch 'regulator/topic/core' into regulator-next

commit dbc559554086f176b04f97eec561ad26ee54e47c
Author: Haishan Zhou <zhssmail@gmail.com>
Date:   Fri Jun 30 11:43:42 2017 +0800

    regulator: core: Fix size limit of supply_map
    
    Now the debugfs file supply_map has a size limit PAGE_SIZE and the user
    can not see the whole content of regulator_map_list when it is larger
    than this limit.
    
    This patch uses seq_file instead to make sure supply_map shows the full
    information of regulator_map_list.
    
    Signed-off-by: Haishan Zhou <zhssmail@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index a0362a63902e..f8e76f73da35 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -4311,41 +4311,31 @@ void *regulator_get_init_drvdata(struct regulator_init_data *reg_init_data)
 EXPORT_SYMBOL_GPL(regulator_get_init_drvdata);
 
 #ifdef CONFIG_DEBUG_FS
-static ssize_t supply_map_read_file(struct file *file, char __user *user_buf,
-				    size_t count, loff_t *ppos)
+static int supply_map_show(struct seq_file *sf, void *data)
 {
-	char *buf = kmalloc(PAGE_SIZE, GFP_KERNEL);
-	ssize_t len, ret = 0;
 	struct regulator_map *map;
 
-	if (!buf)
-		return -ENOMEM;
-
 	list_for_each_entry(map, &regulator_map_list, list) {
-		len = snprintf(buf + ret, PAGE_SIZE - ret,
-			       "%s -> %s.%s\n",
-			       rdev_get_name(map->regulator), map->dev_name,
-			       map->supply);
-		if (len >= 0)
-			ret += len;
-		if (ret > PAGE_SIZE) {
-			ret = PAGE_SIZE;
-			break;
-		}
+		seq_printf(sf, "%s -> %s.%s\n",
+				rdev_get_name(map->regulator), map->dev_name,
+				map->supply);
 	}
 
-	ret = simple_read_from_buffer(user_buf, count, ppos, buf, ret);
-
-	kfree(buf);
+	return 0;
+}
 
-	return ret;
+static int supply_map_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, supply_map_show, inode->i_private);
 }
 #endif
 
 static const struct file_operations supply_map_fops = {
 #ifdef CONFIG_DEBUG_FS
-	.read = supply_map_read_file,
-	.llseek = default_llseek,
+	.open = supply_map_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
 #endif
 };
 

commit 2c2874b191d54fbf9216524e629558eee89e1d20
Author: Tirupathi Reddy <tirupath@codeaurora.org>
Date:   Thu May 25 15:33:17 2017 +0530

    regulator: core: Fix voltage change propagations to supply regulators
    
    Some regulators support get_voltage() and some support get_voltage_sel()
    operations but currently we only propagate changes if the regulator has
    a get_voltage() operation.  Also do this if we've got get_voltage_sel()
    
    [Rewite commit message for clarity -- broonie]
    
    Signed-off-by: Tirupathi Reddy <tirupath@codeaurora.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index c0d9ae8d0860..9fecbd4e3546 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2938,7 +2938,8 @@ static int regulator_set_voltage_unlocked(struct regulator *regulator,
 	if (rdev->supply &&
 	    regulator_ops_is_valid(rdev->supply->rdev,
 				   REGULATOR_CHANGE_VOLTAGE) &&
-	    (rdev->desc->min_dropout_uV || !rdev->desc->ops->get_voltage)) {
+	    (rdev->desc->min_dropout_uV || !(rdev->desc->ops->get_voltage ||
+					   rdev->desc->ops->get_voltage_sel))) {
 		int current_supply_uV;
 		int selector;
 

commit 062171973e05440673cb997e64395e84a8e66350
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Tue Jun 13 16:12:47 2017 +0100

    regulator: core: Prioritise consumer mappings over regulator name
    
    Currently, when looking up a regulator supply, the regulator name
    takes priority over the consumer mappings. As there are a lot of
    regulator names that are in fairly common use (VDD, MICVDD, etc.) this
    can easily lead to obtaining the wrong supply, when a system contains
    two regulators that share a name.
    
    The explicit consumer mappings contain much less ambiguity as they
    specify both a name and a consumer device. As such prioritise those if
    one exists and only fall back to the regulator name if there are no
    matching explicit mappings.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index c0d9ae8d0860..a0362a63902e 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1462,7 +1462,7 @@ static struct regulator_dev *regulator_lookup_by_name(const char *name)
 static struct regulator_dev *regulator_dev_lookup(struct device *dev,
 						  const char *supply)
 {
-	struct regulator_dev *r;
+	struct regulator_dev *r = NULL;
 	struct device_node *node;
 	struct regulator_map *map;
 	const char *devname = NULL;
@@ -1489,10 +1489,6 @@ static struct regulator_dev *regulator_dev_lookup(struct device *dev,
 	if (dev)
 		devname = dev_name(dev);
 
-	r = regulator_lookup_by_name(supply);
-	if (r)
-		return r;
-
 	mutex_lock(&regulator_list_mutex);
 	list_for_each_entry(map, &regulator_map_list, list) {
 		/* If the mapping has a device set up it must match */
@@ -1508,6 +1504,10 @@ static struct regulator_dev *regulator_dev_lookup(struct device *dev,
 	}
 	mutex_unlock(&regulator_list_mutex);
 
+	if (r)
+		return r;
+
+	r = regulator_lookup_by_name(supply);
 	if (r)
 		return r;
 

commit 3ffad468cf1d9825b425733941bdad0d8d20e795
Author: Matthias Kaehlcke <mka@chromium.org>
Date:   Tue May 16 11:43:43 2017 -0700

    regulator: Allow for asymmetric settling times
    
    Some regulators have different settling times for voltage increases and
    decreases. To avoid a time penalty on the faster transition allow for
    different settings for up- and downward transitions.
    
    Signed-off-by: Matthias Kaehlcke <mka@chromium.org>
    Acked-by: Laxman Dewangan <ldewangan@nvidia.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index c0d9ae8d0860..919b7f178209 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2767,6 +2767,12 @@ static int _regulator_set_voltage_time(struct regulator_dev *rdev,
 		ramp_delay = rdev->desc->ramp_delay;
 	else if (rdev->constraints->settling_time)
 		return rdev->constraints->settling_time;
+	else if (rdev->constraints->settling_time_up &&
+		 (new_uV > old_uV))
+		return rdev->constraints->settling_time_up;
+	else if (rdev->constraints->settling_time_down &&
+		 (new_uV < old_uV))
+		return rdev->constraints->settling_time_down;
 
 	if (ramp_delay == 0) {
 		rdev_dbg(rdev, "ramp_delay not set\n");

commit 81bc8e386f394961b22cb0758c78cee8e0905233
Merge: 0603b37e1ea0 264b88c9e5c8 c6182ac96096 d6c1dc3f52e3 43594dd453f0 c635df496a5c
Author: Mark Brown <broonie@kernel.org>
Date:   Sun Apr 30 22:17:36 2017 +0900

    Merge remote-tracking branches 'regulator/topic/notifier', 'regulator/topic/pfuze100', 'regulator/topic/settle', 'regulator/topic/tps65132' and 'regulator/topic/twl6030' into regulator-next

commit c93609ab3924cc974fc90001fb6aa250a8900a3c
Author: Mark Brown <broonie@kernel.org>
Date:   Tue Apr 11 21:31:40 2017 +0100

    regulator: core: Allow dummy regulators for supplies
    
    Rather than just not resolving the supply when there is explicitly no
    supply mapping fall through and allow a dummy supply to be substituted.
    This fixes issues with constant retries reported by Dong Aisheng.
    
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Tested-by: Dong Aisheng <aisheng.dong@nxp.com>
    Reviewed-by: Dong Aisheng <aisheng.dong@nxp.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 3f424ec4fc56..462e6e679ce1 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1532,14 +1532,6 @@ static int regulator_resolve_supply(struct regulator_dev *rdev)
 	if (IS_ERR(r)) {
 		ret = PTR_ERR(r);
 
-		if (ret == -ENODEV) {
-			/*
-			 * No supply was specified for this regulator and
-			 * there will never be one.
-			 */
-			return 0;
-		}
-
 		/* Did the lookup explicitly defer for us? */
 		if (ret == -EPROBE_DEFER)
 			return ret;

commit 43fc99f293cc802866bea904ca2f1f8573f236f7
Author: Mark Brown <broonie@kernel.org>
Date:   Thu Apr 13 18:36:59 2017 +0100

    regulator: core: Only propagate voltage changes to if it can change voltages
    
    When we are propagating voltage changes to parent regulators don't
    bother if the parent does not have permission to change voltages.  This
    simplifies error checking in the function for cases where the regulator
    lacks some of the voltage operations.
    
    Reported-by: Dong Aisheng <aisheng.dong@nxp.com>
    Tested-by: Dong Aisheng <aisheng.dong@nxp.com>
    Reviewed-by: Dong Aisheng <aisheng.dong@nxp.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index aff302dfab5d..3f424ec4fc56 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2939,8 +2939,10 @@ static int regulator_set_voltage_unlocked(struct regulator *regulator,
 	if (ret < 0)
 		goto out2;
 
-	if (rdev->supply && (rdev->desc->min_dropout_uV ||
-				!rdev->desc->ops->get_voltage)) {
+	if (rdev->supply &&
+	    regulator_ops_is_valid(rdev->supply->rdev,
+				   REGULATOR_CHANGE_VOLTAGE) &&
+	    (rdev->desc->min_dropout_uV || !rdev->desc->ops->get_voltage)) {
 		int current_supply_uV;
 		int selector;
 

commit d6c1dc3f52e3a65f35c58433ba57d14c0bad902f
Author: Laxman Dewangan <ldewangan@nvidia.com>
Date:   Tue Apr 4 18:59:50 2017 +0530

    regulator: Add settling time for non-linear voltage transition
    
    Some regulators (some PWM regulators) have the voltage transition
    non-linear i.e. exponentially. On such cases, the settling time
    for voltage transition can not be presented in the voltage-ramp-delay.
    
    Add new property for non-linear voltage transition and handle this
    in getting the voltage settling time.
    
    Signed-off-by: Laxman Dewangan <ldewangan@nvidia.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 04baac9a165b..3a641d64f8e1 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2753,6 +2753,8 @@ static int _regulator_set_voltage_time(struct regulator_dev *rdev,
 		ramp_delay = rdev->constraints->ramp_delay;
 	else if (rdev->desc->ramp_delay)
 		ramp_delay = rdev->desc->ramp_delay;
+	else if (rdev->constraints->settling_time)
+		return rdev->constraints->settling_time;
 
 	if (ramp_delay == 0) {
 		rdev_dbg(rdev, "ramp_delay not set\n");

commit fd086045559d90cd7854818b4c60a7119eda6231
Author: Matthias Kaehlcke <mka@chromium.org>
Date:   Mon Mar 27 16:54:12 2017 -0700

    regulator: core: Limit propagation of parent voltage count and list
    
    Commit 26988efe11b1 ("regulator: core: Allow to get voltage count and
    list from parent") introduces the propagation of the parent voltage
    count and list for regulators that don't provide this information
    themselves. The goal is to support simple switch regulators, however as
    a side effect normal continuous regulators can leak details of their
    supplies and provide consumers with inconsistent information.
    
    Limit the propagation of the voltage count and list to switch
    regulators.
    
    Fixes: 26988efe11b1 ("regulator: core: Allow to get voltage count and
      list from parent")
    Signed-off-by: Matthias Kaehlcke <mka@chromium.org>
    Reviewed-by: Javier Martinez Canillas <javier@osg.samsung.com>
    Tested-by: Javier Martinez Canillas <javier@osg.samsung.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index c20b28a63d15..aff302dfab5d 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2484,7 +2484,7 @@ static int _regulator_list_voltage(struct regulator *regulator,
 		ret = ops->list_voltage(rdev, selector);
 		if (lock)
 			mutex_unlock(&rdev->mutex);
-	} else if (rdev->supply) {
+	} else if (rdev->is_switch && rdev->supply) {
 		ret = _regulator_list_voltage(rdev->supply, selector, lock);
 	} else {
 		return -EINVAL;
@@ -2542,7 +2542,7 @@ int regulator_count_voltages(struct regulator *regulator)
 	if (rdev->desc->n_voltages)
 		return rdev->desc->n_voltages;
 
-	if (!rdev->supply)
+	if (!rdev->is_switch || !rdev->supply)
 		return -EINVAL;
 
 	return regulator_count_voltages(rdev->supply);
@@ -4097,6 +4097,11 @@ regulator_register(const struct regulator_desc *regulator_desc,
 		mutex_unlock(&regulator_list_mutex);
 	}
 
+	if (!rdev->desc->ops->get_voltage &&
+	    !rdev->desc->ops->list_voltage &&
+	    !rdev->desc->fixed_uV)
+		rdev->is_switch = true;
+
 	ret = device_register(&rdev->dev);
 	if (ret != 0) {
 		put_device(&rdev->dev);

commit fffd1133388857f5b4b8c588b41b2ade16c7891c
Author: Tamara Diaconita <diaconitatamara@gmail.com>
Date:   Tue Mar 28 21:30:21 2017 +0300

    regulator: core: Fix kerneldoc comments
    
    Remove the description for the non-existing 'ret' to fix the build warning:
    ./drivers/regulator/core.c:1467: warning:
    Excess function parameter 'ret' description in 'regulator_dev_lookup'.
    The description found for the return value is: @ret: 0 on success, -ENODEV
    if lookup fails permanently, -EPROBE_DEFER if lookup could succeed in the future.
    
    Signed-off-by: Tamara Diaconita <diaconita.tamara@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 49a0b6a2e237..c20b28a63d15 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1451,8 +1451,6 @@ static struct regulator_dev *regulator_lookup_by_name(const char *name)
  * regulator_dev_lookup - lookup a regulator device.
  * @dev: device for regulator "consumer".
  * @supply: Supply name or regulator ID.
- * @ret: 0 on success, -ENODEV if lookup fails permanently, -EPROBE_DEFER if
- * lookup could succeed in the future.
  *
  * If successful, returns a struct regulator_dev that corresponds to the name
  * @supply and with the embedded struct device refcount incremented by one.

commit 264b88c9e5c86c92ca1d67689779362760baf651
Author: Harald Geyer <harald@ccbib.org>
Date:   Thu Feb 23 17:06:52 2017 +0000

    regulator: core: Add new notification for enabling of regulator
    
    This is useful for devices, which need some time to start up, to help
    the drivers track how long the supply has been up already. Ie whether
    it can safely talk to the HW or needs to wait.
    
    Signed-off-by: Harald Geyer <harald@ccbib.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 04baac9a165b..6b9bb1b00226 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2162,6 +2162,8 @@ static int _regulator_enable(struct regulator_dev *rdev)
 			if (ret < 0)
 				return ret;
 
+			_notifier_call_chain(rdev, REGULATOR_EVENT_ENABLE,
+					     NULL);
 		} else if (ret < 0) {
 			rdev_err(rdev, "is_enabled() failed: %d\n", ret);
 			return ret;

commit 0630b614391f8cbc35e837b4645ec8faaaa6465e
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Thu Mar 16 18:07:14 2017 -0700

    regulator: Mark supply_name const and duplicate it as such
    
    The supply_name member of struct regulator can be const as we
    don't change it in the regulator core. Furthermore, when we copy
    the supply name we can use kstrdup_const() here to avoid a copy
    if the name is in the ro data section.
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index f20ad0a8fc38..49a0b6a2e237 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1343,7 +1343,7 @@ static struct regulator *create_regulator(struct regulator_dev *rdev,
 			/* non-fatal */
 		}
 	} else {
-		regulator->supply_name = kstrdup(supply_name, GFP_KERNEL);
+		regulator->supply_name = kstrdup_const(supply_name, GFP_KERNEL);
 		if (regulator->supply_name == NULL)
 			goto overflow_err;
 	}
@@ -1799,7 +1799,7 @@ static void _regulator_put(struct regulator *regulator)
 	put_device(&rdev->dev);
 	mutex_unlock(&rdev->mutex);
 
-	kfree(regulator->supply_name);
+	kfree_const(regulator->supply_name);
 	kfree(regulator);
 
 	module_put(rdev->owner);

commit b7cd1b1386ff46e60452ad1f16530645761ca7b8
Author: Bartosz Golaszewski <bgolaszewski@baylibre.com>
Date:   Mon Mar 6 17:34:48 2017 +0100

    regulator: core: use snprintf() instead of scnprintf()
    
    When creating the link to the device sysfs entry, the regulator core
    calls scnprintf() and then checks if the returned value is greater or
    equal than the buffer size.
    
    The former can never happen as scnprintf() returns the number of bytes
    that were actually written to the buffer, not the bytes that *would*
    have been written.
    
    Use the right function in this case: snprintf().
    
    Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 53d4fc70dbd0..f20ad0a8fc38 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1326,8 +1326,8 @@ static struct regulator *create_regulator(struct regulator_dev *rdev,
 		regulator->dev = dev;
 
 		/* Add a link to the device sysfs entry */
-		size = scnprintf(buf, REG_STR_SIZE, "%s-%s",
-				 dev->kobj.name, supply_name);
+		size = snprintf(buf, REG_STR_SIZE, "%s-%s",
+				dev->kobj.name, supply_name);
 		if (size >= REG_STR_SIZE)
 			goto overflow_err;
 

commit fad9cd45edf558b5886219d58986a88a83926bbf
Merge: 0755fad8a6af 33f0698a52d9 66d228a2bf03 b4c2e158a1e1
Author: Mark Brown <broonie@kernel.org>
Date:   Sun Feb 19 16:40:41 2017 +0000

    Merge remote-tracking branches 'regulator/topic/s2mpa01', 'regulator/topic/supplies' and 'regulator/topic/tps65217' into regulator-next

commit 401c42429caa8e374d17abcbc92505dd6b2e2a18
Merge: 0fe3f971fc83 a4d7641fa797
Author: Mark Brown <broonie@kernel.org>
Date:   Sun Feb 19 16:40:23 2017 +0000

    Merge remote-tracking branch 'regulator/topic/core' into regulator-next

commit 0fe3f971fc83bfd709b70f8ac822ad6db4a05c9e
Merge: 1c35539cd768 e42a46b6f524 6308f1787fb8
Author: Mark Brown <broonie@kernel.org>
Date:   Sun Feb 19 16:40:22 2017 +0000

    Merge remote-tracking branches 'regulator/fix/debugfs' and 'regulator/fix/tps65086' into regulator-linus

commit 3827b64dba27ebadb4faf51f2c91143e01ba1f6d
Author: Javier Martinez Canillas <javier@osg.samsung.com>
Date:   Thu Feb 16 14:30:02 2017 -0300

    regulator: core: Resolve supplies before disabling unused regulators
    
    After commit 66d228a2bf03 ("regulator: core: Don't use regulators as
    supplies until the parent is bound"), input supplies aren't resolved
    if the input supplies parent device has not been bound. This prevent
    regulators to hold an invalid reference if its supply parent device
    driver probe is deferred.
    
    But this causes issues on some boards where a PMIC's regulator use as
    input supply a regulator from another PMIC whose driver is registered
    after the driver for the former.
    
    In this case the regulators for the first PMIC will fail to resolve
    input supplies on regulators registration (since the other PMIC wasn't
    probed yet). And when the core attempts to resolve again latter when
    the other PMIC registers its own regulators, it will fail again since
    the parent device isn't bound yet.
    
    This will cause some parent supplies to never be resolved and wrongly
    be disabled on boot due taking them as unused.
    
    To solve this problem, also attempt to resolve the pending regulators
    input supplies before disabling the unused regulators.
    
    Signed-off-by: Javier Martinez Canillas <javier@osg.samsung.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 04baac9a165b..8028835d3967 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -4540,6 +4540,16 @@ static int __init regulator_init_complete(void)
 	if (of_have_populated_dt())
 		has_full_constraints = true;
 
+	/*
+	 * Regulators may had failed to resolve their input supplies
+	 * when were registered, either because the input supply was
+	 * not registered yet or because its parent device was not
+	 * bound yet. So attempt to resolve the input supplies for
+	 * pending regulators before trying to disable unused ones.
+	 */
+	class_for_each_device(&regulator_class, NULL, NULL,
+			      regulator_register_resolve_supply);
+
 	/* If we have a full configuration then disable any regulators
 	 * we have permission to change the status for and which are
 	 * not in use or always_on.  This is effectively the default

commit e42a46b6f52473661ad192f76a128a68fe301df4
Author: Leonard Crestez <leonard.crestez@nxp.com>
Date:   Tue Feb 14 17:31:03 2017 +0200

    regulator: Fix regulator_summary for deviceless consumers
    
    It is allowed to call regulator_get with a NULL dev argument
    (_regulator_get explicitly checks for it) but this causes an error later
    when printing /sys/kernel/debug/regulator_summary.
    
    Fix this by explicitly handling "deviceless" consumers in the debugfs code.
    
    Signed-off-by: Leonard Crestez <leonard.crestez@nxp.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Cc: stable@vger.kernel.org

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 04baac9a165b..66319542baa6 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -4391,12 +4391,13 @@ static void regulator_summary_show_subtree(struct seq_file *s,
 	seq_puts(s, "\n");
 
 	list_for_each_entry(consumer, &rdev->consumer_list, list) {
-		if (consumer->dev->class == &regulator_class)
+		if (consumer->dev && consumer->dev->class == &regulator_class)
 			continue;
 
 		seq_printf(s, "%*s%-*s ",
 			   (level + 1) * 3 + 1, "",
-			   30 - (level + 1) * 3, dev_name(consumer->dev));
+			   30 - (level + 1) * 3,
+			   consumer->dev ? dev_name(consumer->dev) : "deviceless");
 
 		switch (rdev->desc->type) {
 		case REGULATOR_VOLTAGE:

commit a4d7641fa797b523c0789d2fa55b0a3d53abc2fb
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Mon Feb 6 19:56:14 2017 -0800

    regulator: core: simplify _regulator_get()
    
    The code in _regulator_get() got a bit confusing over time, with control
    flow jumping to a label from couple of places. Let's untangle it a bit by
    doing the following:
    
    1. Make handling of missing supplies and substituting them with dummy
    regulators more explicit:
    
    - check if we not have full constraints and refuse considering dummy
      regulators with appropriate message;
    
    - use "switch (get_type)" to handle different types of request explicitly
      as well. "Normal" requests will get dummies, exclusive will not and
      will notify user about that; optional will fail silently.
    
    2. Stop jumping to a label in the middle of the function but instead have
    proper conditional flow. I believe jumps should be reserved for error
    handling, breaking from inner loop, or restarting a loop, but not for
    implementing normal conditional flow.
    
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 3e246c82939d..a62f5b725061 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1588,7 +1588,7 @@ struct regulator *_regulator_get(struct device *dev, const char *id,
 {
 	struct regulator_dev *rdev;
 	struct regulator *regulator;
-	const char *devname = NULL;
+	const char *devname = dev ? dev_name(dev) : "deviceless";
 	int ret;
 
 	if (get_type >= MAX_GET_TYPE) {
@@ -1601,45 +1601,47 @@ struct regulator *_regulator_get(struct device *dev, const char *id,
 		return ERR_PTR(-EINVAL);
 	}
 
-	if (dev)
-		devname = dev_name(dev);
-
 	rdev = regulator_dev_lookup(dev, id);
-	if (!IS_ERR(rdev))
-		goto found;
+	if (IS_ERR(rdev)) {
+		ret = PTR_ERR(rdev);
 
-	ret = PTR_ERR(rdev);
-	regulator = ERR_PTR(ret);
+		/*
+		 * If regulator_dev_lookup() fails with error other
+		 * than -ENODEV our job here is done, we simply return it.
+		 */
+		if (ret != -ENODEV)
+			return ERR_PTR(ret);
 
-	/*
-	 * If we have return value from dev_lookup fail, we do not expect to
-	 * succeed, so, quit with appropriate error value
-	 */
-	if (ret && ret != -ENODEV)
-		return regulator;
+		if (!have_full_constraints()) {
+			dev_warn(dev,
+				 "incomplete constraints, dummy supplies not allowed\n");
+			return ERR_PTR(-ENODEV);
+		}
 
-	if (!devname)
-		devname = "deviceless";
+		switch (get_type) {
+		case NORMAL_GET:
+			/*
+			 * Assume that a regulator is physically present and
+			 * enabled, even if it isn't hooked up, and just
+			 * provide a dummy.
+			 */
+			dev_warn(dev,
+				 "%s supply %s not found, using dummy regulator\n",
+				 devname, id);
+			rdev = dummy_regulator_rdev;
+			get_device(&rdev->dev);
+			break;
 
-	/*
-	 * Assume that a regulator is physically present and enabled
-	 * even if it isn't hooked up and just provide a dummy.
-	 */
-	if (have_full_constraints() && get_type == NORMAL_GET) {
-		pr_warn("%s supply %s not found, using dummy regulator\n",
-			devname, id);
+		case EXCLUSIVE_GET:
+			dev_warn(dev,
+				 "dummy supplies not allowed for exclusive requests\n");
+			/* fall through */
 
-		rdev = dummy_regulator_rdev;
-		get_device(&rdev->dev);
-		goto found;
-	/* Don't log an error when called from regulator_get_optional() */
-	} else if (!have_full_constraints() || get_type == EXCLUSIVE_GET) {
-		dev_warn(dev, "dummy supplies not allowed\n");
+		default:
+			return ERR_PTR(-ENODEV);
+		}
 	}
 
-	return regulator;
-
-found:
 	if (rdev->exclusive) {
 		regulator = ERR_PTR(-EPERM);
 		put_device(&rdev->dev);

commit 163478dae0b6ce2437488e54012705b53ef43f3d
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Sat Feb 4 10:19:21 2017 -0800

    regulator: core: have regulator_dev_lookup() return ERR_PTR-encoded errors
    
    Instead of returning both regulator_dev structure as return value and
    auxiliary error code in 'ret' argument, let's switch to using ERR_PTR
    encoded values. This makes it more obvious what is going on at call sites.
    
    Also, let's not unlock the mutex in the middle of a loop, but rather break
    out and have single unlock path.
    
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 867756651544..3e246c82939d 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1455,12 +1455,14 @@ static struct regulator_dev *regulator_lookup_by_name(const char *name)
  * lookup could succeed in the future.
  *
  * If successful, returns a struct regulator_dev that corresponds to the name
- * @supply and with the embedded struct device refcount incremented by one,
- * or NULL on failure. The refcount must be dropped by calling put_device().
+ * @supply and with the embedded struct device refcount incremented by one.
+ * The refcount must be dropped by calling put_device().
+ * On failure one of the following ERR-PTR-encoded values is returned:
+ * -ENODEV if lookup fails permanently, -EPROBE_DEFER if lookup could succeed
+ * in the future.
  */
 static struct regulator_dev *regulator_dev_lookup(struct device *dev,
-						  const char *supply,
-						  int *ret)
+						  const char *supply)
 {
 	struct regulator_dev *r;
 	struct device_node *node;
@@ -1476,16 +1478,12 @@ static struct regulator_dev *regulator_dev_lookup(struct device *dev,
 			r = of_find_regulator_by_node(node);
 			if (r)
 				return r;
-			*ret = -EPROBE_DEFER;
-			return NULL;
-		} else {
+
 			/*
-			 * If we couldn't even get the node then it's
-			 * not just that the device didn't register
-			 * yet, there's no node and we'll never
-			 * succeed.
+			 * We have a node, but there is no device.
+			 * assume it has not registered yet.
 			 */
-			*ret = -ENODEV;
+			return ERR_PTR(-EPROBE_DEFER);
 		}
 	}
 
@@ -1506,13 +1504,16 @@ static struct regulator_dev *regulator_dev_lookup(struct device *dev,
 
 		if (strcmp(map->supply, supply) == 0 &&
 		    get_device(&map->regulator->dev)) {
-			mutex_unlock(&regulator_list_mutex);
-			return map->regulator;
+			r = map->regulator;
+			break;
 		}
 	}
 	mutex_unlock(&regulator_list_mutex);
 
-	return NULL;
+	if (r)
+		return r;
+
+	return ERR_PTR(-ENODEV);
 }
 
 static int regulator_resolve_supply(struct regulator_dev *rdev)
@@ -1529,8 +1530,10 @@ static int regulator_resolve_supply(struct regulator_dev *rdev)
 	if (rdev->supply)
 		return 0;
 
-	r = regulator_dev_lookup(dev, rdev->supply_name, &ret);
-	if (!r) {
+	r = regulator_dev_lookup(dev, rdev->supply_name);
+	if (IS_ERR(r)) {
+		ret = PTR_ERR(r);
+
 		if (ret == -ENODEV) {
 			/*
 			 * No supply was specified for this regulator and
@@ -1601,10 +1604,11 @@ struct regulator *_regulator_get(struct device *dev, const char *id,
 	if (dev)
 		devname = dev_name(dev);
 
-	rdev = regulator_dev_lookup(dev, id, &ret);
-	if (rdev)
+	rdev = regulator_dev_lookup(dev, id);
+	if (!IS_ERR(rdev))
 		goto found;
 
+	ret = PTR_ERR(rdev);
 	regulator = ERR_PTR(ret);
 
 	/*

commit d1642ea717be09039114dad57a8ae08d77f17dfb
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Fri Feb 3 15:16:16 2017 -0800

    regulator: core: fix typo in regulator_bulk_disable()
    
    "re-enable" was misspelled as "reename".
    
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index fe05923611ee..867756651544 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -3661,7 +3661,7 @@ int regulator_bulk_disable(int num_consumers,
 	for (++i; i < num_consumers; ++i) {
 		r = regulator_enable(consumers[i].consumer);
 		if (r != 0)
-			pr_err("Failed to reename %s: %d\n",
+			pr_err("Failed to re-enable %s: %d\n",
 			       consumers[i].supply, r);
 	}
 

commit b8c77ff6902baa6ca93ca643bfff2d565801ea30
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Fri Feb 3 15:16:17 2017 -0800

    regulator: core: simplify regulator_bulk_force_disable()
    
    There is no need to have two loops there, we can store error for subsequent
    reporting.
    
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 206c274c0003..fe05923611ee 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -3687,21 +3687,17 @@ int regulator_bulk_force_disable(int num_consumers,
 			   struct regulator_bulk_data *consumers)
 {
 	int i;
-	int ret;
+	int ret = 0;
 
-	for (i = 0; i < num_consumers; i++)
+	for (i = 0; i < num_consumers; i++) {
 		consumers[i].ret =
 			    regulator_force_disable(consumers[i].consumer);
 
-	for (i = 0; i < num_consumers; i++) {
-		if (consumers[i].ret != 0) {
+		/* Store first error for reporting */
+		if (consumers[i].ret && !ret)
 			ret = consumers[i].ret;
-			goto out;
-		}
 	}
 
-	return 0;
-out:
 	return ret;
 }
 EXPORT_SYMBOL_GPL(regulator_bulk_force_disable);

commit a8bd42a97741aefa5942605fa87418fc8a6c4169
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Fri Feb 3 13:56:02 2017 -0800

    regulator: core: have _regulator_get() accept get_type argument
    
    Instead of separate "exclusive" and "allow_dummy" arguments, that formed 3
    valid combinations (normal, exclusive and optional) and an invalid one,
    let's accept explicit "get_type", like we did in devm-managed code.
    
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index b0ee068310c5..206c274c0003 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1580,14 +1580,19 @@ static int regulator_resolve_supply(struct regulator_dev *rdev)
 }
 
 /* Internal regulator request function */
-static struct regulator *_regulator_get(struct device *dev, const char *id,
-					bool exclusive, bool allow_dummy)
+struct regulator *_regulator_get(struct device *dev, const char *id,
+				 enum regulator_get_type get_type)
 {
 	struct regulator_dev *rdev;
 	struct regulator *regulator;
 	const char *devname = NULL;
 	int ret;
 
+	if (get_type >= MAX_GET_TYPE) {
+		dev_err(dev, "invalid type %d in %s\n", get_type, __func__);
+		return ERR_PTR(-EINVAL);
+	}
+
 	if (id == NULL) {
 		pr_err("get() with no identifier\n");
 		return ERR_PTR(-EINVAL);
@@ -1616,7 +1621,7 @@ static struct regulator *_regulator_get(struct device *dev, const char *id,
 	 * Assume that a regulator is physically present and enabled
 	 * even if it isn't hooked up and just provide a dummy.
 	 */
-	if (have_full_constraints() && allow_dummy) {
+	if (have_full_constraints() && get_type == NORMAL_GET) {
 		pr_warn("%s supply %s not found, using dummy regulator\n",
 			devname, id);
 
@@ -1624,7 +1629,7 @@ static struct regulator *_regulator_get(struct device *dev, const char *id,
 		get_device(&rdev->dev);
 		goto found;
 	/* Don't log an error when called from regulator_get_optional() */
-	} else if (!have_full_constraints() || exclusive) {
+	} else if (!have_full_constraints() || get_type == EXCLUSIVE_GET) {
 		dev_warn(dev, "dummy supplies not allowed\n");
 	}
 
@@ -1637,7 +1642,7 @@ static struct regulator *_regulator_get(struct device *dev, const char *id,
 		return regulator;
 	}
 
-	if (exclusive && rdev->open_count) {
+	if (get_type == EXCLUSIVE_GET && rdev->open_count) {
 		regulator = ERR_PTR(-EBUSY);
 		put_device(&rdev->dev);
 		return regulator;
@@ -1665,7 +1670,7 @@ static struct regulator *_regulator_get(struct device *dev, const char *id,
 	}
 
 	rdev->open_count++;
-	if (exclusive) {
+	if (get_type == EXCLUSIVE_GET) {
 		rdev->exclusive = 1;
 
 		ret = _regulator_is_enabled(rdev);
@@ -1693,7 +1698,7 @@ static struct regulator *_regulator_get(struct device *dev, const char *id,
  */
 struct regulator *regulator_get(struct device *dev, const char *id)
 {
-	return _regulator_get(dev, id, false, true);
+	return _regulator_get(dev, id, NORMAL_GET);
 }
 EXPORT_SYMBOL_GPL(regulator_get);
 
@@ -1720,7 +1725,7 @@ EXPORT_SYMBOL_GPL(regulator_get);
  */
 struct regulator *regulator_get_exclusive(struct device *dev, const char *id)
 {
-	return _regulator_get(dev, id, true, false);
+	return _regulator_get(dev, id, EXCLUSIVE_GET);
 }
 EXPORT_SYMBOL_GPL(regulator_get_exclusive);
 
@@ -1746,7 +1751,7 @@ EXPORT_SYMBOL_GPL(regulator_get_exclusive);
  */
 struct regulator *regulator_get_optional(struct device *dev, const char *id)
 {
-	return _regulator_get(dev, id, false, false);
+	return _regulator_get(dev, id, OPTIONAL_GET);
 }
 EXPORT_SYMBOL_GPL(regulator_get_optional);
 

commit 7d245afa24b3ed911f6fd90079d70932ac5e5923
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Fri Feb 3 13:56:00 2017 -0800

    regulator: core: remove dead code in _regulator_get()
    
    There is no point in assigning value to 'ret' before calling
    regulator_dev_lookup() as it will clobber 'ret' anyway.
    
    Also, let's explicitly return -PROBE_DEFER when try_module_get() fails,
    instead of relying that earlier initialization of "regulator" carries
    correct value.
    
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 04baac9a165b..b0ee068310c5 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1584,7 +1584,7 @@ static struct regulator *_regulator_get(struct device *dev, const char *id,
 					bool exclusive, bool allow_dummy)
 {
 	struct regulator_dev *rdev;
-	struct regulator *regulator = ERR_PTR(-EPROBE_DEFER);
+	struct regulator *regulator;
 	const char *devname = NULL;
 	int ret;
 
@@ -1596,11 +1596,6 @@ static struct regulator *_regulator_get(struct device *dev, const char *id,
 	if (dev)
 		devname = dev_name(dev);
 
-	if (have_full_constraints())
-		ret = -ENODEV;
-	else
-		ret = -EPROBE_DEFER;
-
 	rdev = regulator_dev_lookup(dev, id, &ret);
 	if (rdev)
 		goto found;
@@ -1656,6 +1651,7 @@ static struct regulator *_regulator_get(struct device *dev, const char *id,
 	}
 
 	if (!try_module_get(rdev->owner)) {
+		regulator = ERR_PTR(-EPROBE_DEFER);
 		put_device(&rdev->dev);
 		return regulator;
 	}

commit 66d228a2bf03b163ddaeca5f24f1ff89a84ad668
Author: Jon Hunter <jonathanh@nvidia.com>
Date:   Wed Jan 11 17:44:25 2017 +0000

    regulator: core: Don't use regulators as supplies until the parent is bound
    
    When regulators are successfully registered, we check to see if the
    regulator is a supply for any other registered regulator and if so
    add the new regulator as the supply for the existing regulator(s).
    
    Some devices, such as Power Management ICs, may register a series of
    regulators when probed and there are cases where one of the regulators
    may fail to register and defer the probing of the parent device. In this
    case any successfully registered regulators would be unregistered so
    that they can be re-registered at some time later when the probe is
    attempted again. However, if one of the regulators that was registered
    was added as a supply to another registered regulator (that did not
    belong to the same parent device), then this supply regulator was
    unregister again because the parent device is probe deferred, then a
    regulator could be holding an invalid reference to a supply regulator
    that has been unregistered. This will lead to a system crash if that
    regulator is then used.
    
    Although it would be possible to check when unregistering a regulator
    if any other regulator in the system is using it as a supply, it still
    may not be possible to remove it as a supply if this other regulator is
    in use. Therefore, fix this by preventing any regulator from adding
    another regulator as a supply if the parent device for the supply
    regulator has not been bound and if the parent device for the supply
    and the regulator are different. This will allow a parent device that is
    registering regulators to be probe deferred and ensure that none of the
    regulators it has registered are used as supplies for any other
    regulator from another device.
    
    Signed-off-by: Jon Hunter <jonathanh@nvidia.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 04baac9a165b..bcf67abd1cd2 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1553,6 +1553,19 @@ static int regulator_resolve_supply(struct regulator_dev *rdev)
 		}
 	}
 
+	/*
+	 * If the supply's parent device is not the same as the
+	 * regulator's parent device, then ensure the parent device
+	 * is bound before we resolve the supply, in case the parent
+	 * device get probe deferred and unregisters the supply.
+	 */
+	if (r->dev.parent && r->dev.parent != rdev->dev.parent) {
+		if (!device_is_bound(r->dev.parent)) {
+			put_device(&r->dev);
+			return -EPROBE_DEFER;
+		}
+	}
+
 	/* Recursively resolve the supply of the supply */
 	ret = regulator_resolve_supply(r);
 	if (ret < 0) {

commit bed69721b67aeb3616e983ed32acc131968188f5
Merge: 6b4685624659 88f0e3a5e6ed 85b037442e3f 30103b5b6432 cc9b94029e9e
Author: Mark Brown <broonie@kernel.org>
Date:   Mon Dec 12 12:17:24 2016 +0000

    Merge remote-tracking branches 'regulator/topic/arizona', 'regulator/topic/bypass', 'regulator/topic/error' and 'regulator/topic/fixed' into regulator-next

commit 6b46856246592f860840acf32fcb732111c1c9eb
Merge: 99305bdc7c84 b2661e983f5b
Author: Mark Brown <broonie@kernel.org>
Date:   Mon Dec 12 12:17:23 2016 +0000

    Merge remote-tracking branch 'regulator/topic/core' into regulator-next

commit b2661e983f5b55d4895673bd5eafa14b1e7c8881
Author: David Lechner <david@lechnology.com>
Date:   Sun Dec 4 19:48:11 2016 -0600

    regulator: core: add newline in debug message
    
    This adds a trailing newline to a debug message.
    
    Signed-off-by: David Lechner <david@lechnology.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index b6b3aa8ef5db..cf23b1e2ac4c 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -204,7 +204,7 @@ static struct device_node *of_get_regulator(struct device *dev, const char *supp
 	regnode = of_parse_phandle(dev->of_node, prop_name, 0);
 
 	if (!regnode) {
-		dev_dbg(dev, "Looking up %s property in node %s failed",
+		dev_dbg(dev, "Looking up %s property in node %s failed\n",
 				prop_name, dev->of_node->full_name);
 		return NULL;
 	}

commit 109c75afa1cf7c08015f19e354bed581f29f7a94
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Tue Nov 29 11:50:03 2016 +0000

    regulator: core: Correct type of mode in regulator_mode_constrain
    
    Every function handling the mode within the regulator core uses an unsigned
    int for mode, except for regulator_mode_constrain. This patch changes the
    type of mode within regulator_mode_constrain which fixes several instances
    where we are passing pointers to unsigned ints then treating them as an int
    within this function.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 67426c0477d3..b6b3aa8ef5db 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -293,7 +293,8 @@ static int regulator_check_current_limit(struct regulator_dev *rdev,
 }
 
 /* operating mode constraint check */
-static int regulator_mode_constrain(struct regulator_dev *rdev, int *mode)
+static int regulator_mode_constrain(struct regulator_dev *rdev,
+				    unsigned int *mode)
 {
 	switch (*mode) {
 	case REGULATOR_MODE_FAST:

commit 1b5b42216469b05ef4b5916cb40b127dfab1da88
Author: Axel Haslam <ahaslam@baylibre.com>
Date:   Thu Nov 3 12:11:42 2016 +0100

    regulator: core: Add new API to poll for error conditions
    
    Regulator consumers can receive event notifications when
    errors are reported to the driver, but currently, there is
    no way for a regulator consumer to know when the error is over.
    
    To allow a regulator consumer to poll for error conditions
    add a new API: regulator_get_error_flags.
    
    Signed-off-by: Axel Haslam <ahaslam@baylibre.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 67426c0477d3..08260c215895 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -3359,6 +3359,39 @@ unsigned int regulator_get_mode(struct regulator *regulator)
 }
 EXPORT_SYMBOL_GPL(regulator_get_mode);
 
+static int _regulator_get_error_flags(struct regulator_dev *rdev,
+					unsigned int *flags)
+{
+	int ret;
+
+	mutex_lock(&rdev->mutex);
+
+	/* sanity check */
+	if (!rdev->desc->ops->get_error_flags) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	ret = rdev->desc->ops->get_error_flags(rdev, flags);
+out:
+	mutex_unlock(&rdev->mutex);
+	return ret;
+}
+
+/**
+ * regulator_get_error_flags - get regulator error information
+ * @regulator: regulator source
+ * @flags: pointer to store error flags
+ *
+ * Get the current regulator error information.
+ */
+int regulator_get_error_flags(struct regulator *regulator,
+				unsigned int *flags)
+{
+	return _regulator_get_error_flags(regulator->rdev, flags);
+}
+EXPORT_SYMBOL_GPL(regulator_get_error_flags);
+
 /**
  * regulator_set_load - set regulator load
  * @regulator: regulator source

commit ba14fa1a57c07cca9d520ceded8d3da5beb6175f
Author: H. Nikolaus Schaller <hns@goldelico.com>
Date:   Thu Oct 27 14:31:39 2016 +0200

    regulator: core: silence warning: "VDD1: ramp_delay not set"
    
    commit 73e705bf81ce ("regulator: core: Add set_voltage_time op")
    
    introduced a new rdev_warn() if the ramp_delay is 0.
    
    Apparently, on omap3/twl4030 platforms with dynamic voltage
    management this results in non-ending spurious messages like
    
    [  511.143066] VDD1: ramp_delay not set
    [  511.662322] VDD1: ramp_delay not set
    [  513.903625] VDD1: ramp_delay not set
    [  514.222198] VDD1: ramp_delay not set
    [  517.062835] VDD1: ramp_delay not set
    [  517.382568] VDD1: ramp_delay not set
    [  520.142791] VDD1: ramp_delay not set
    [  520.502593] VDD1: ramp_delay not set
    [  523.062896] VDD1: ramp_delay not set
    [  523.362701] VDD1: ramp_delay not set
    [  526.143035] VDD1: ramp_delay not set
    
    I have observed this on GTA04 while it is reported to occur on
    N900 as well: https://bugzilla.kernel.org/show_bug.cgi?id=178371
    
    This patch makes the warning appear only in debugging mode.
    
    Signed-off-by: H. Nikolaus Schaller <hns@goldelico.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 67426c0477d3..5c1519b229e0 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2754,7 +2754,7 @@ static int _regulator_set_voltage_time(struct regulator_dev *rdev,
 		ramp_delay = rdev->desc->ramp_delay;
 
 	if (ramp_delay == 0) {
-		rdev_warn(rdev, "ramp_delay not set\n");
+		rdev_dbg(rdev, "ramp_delay not set\n");
 		return 0;
 	}
 

commit 2dfcb921da781f8b1a166d0ff3a36b3e6804cdf1
Merge: 81c383c9ba5f 1283b9121155 5ff00f6aa84b 556ae220ac64 73e705bf81ce 23a34f9d03a5
Author: Mark Brown <broonie@kernel.org>
Date:   Fri Sep 30 09:13:58 2016 -0700

    Merge remote-tracking branches 'regulator/topic/of', 'regulator/topic/pv88080', 'regulator/topic/rk808', 'regulator/topic/set-voltage' and 'regulator/topic/tps65218' into regulator-next

commit 81c383c9ba5fc1df58693468618b4b3ae515a7de
Merge: ec09f1c575e1 565f9b073f37 5258beedc30a ea2f7321a902 577766175c40 37b918a034fe
Author: Mark Brown <broonie@kernel.org>
Date:   Fri Sep 30 09:13:55 2016 -0700

    Merge remote-tracking branches 'regulator/topic/bulk', 'regulator/topic/dbx500', 'regulator/topic/hi6421', 'regulator/topic/load' and 'regulator/topic/ltc3676' into regulator-next

commit 577766175c40d4f425be47b9e70d80238e53f996
Author: Joonwoo Park <joonwoop@codeaurora.org>
Date:   Mon Sep 19 14:46:54 2016 -0700

    regulator: core: don't return error with inadequate reason
    
    drms_uA_update() always returns failure when it cannot find regulator's
    input voltage.  But if hardware supports load configuration with
    ops->set_load() and the input regulator isn't specified with valid reason
    such as the input regulator is battery, not finding input voltage is
    normal so such case should not return with an error.
    
    Avoid such inadequate error return by checking input/output voltages
    only when drms_uA_update() is about to configure load with enum based
    ops->set_mode().
    
    Cc: Liam Girdwood <lgirdwood@gmail.com>
    Cc: Mark Brown <broonie@kernel.org>
    Cc: Bjorn Andersson <bjorn.andersson@linaro.org>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Joonwoo Park <joonwoop@codeaurora.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index db320e8fa865..bafcdff42872 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -679,24 +679,6 @@ static int drms_uA_update(struct regulator_dev *rdev)
 	    !rdev->desc->ops->set_load)
 		return -EINVAL;
 
-	/* get output voltage */
-	output_uV = _regulator_get_voltage(rdev);
-	if (output_uV <= 0) {
-		rdev_err(rdev, "invalid output voltage found\n");
-		return -EINVAL;
-	}
-
-	/* get input voltage */
-	input_uV = 0;
-	if (rdev->supply)
-		input_uV = regulator_get_voltage(rdev->supply);
-	if (input_uV <= 0)
-		input_uV = rdev->constraints->input_uV;
-	if (input_uV <= 0) {
-		rdev_err(rdev, "invalid input voltage found\n");
-		return -EINVAL;
-	}
-
 	/* calc total requested load */
 	list_for_each_entry(sibling, &rdev->consumer_list, list)
 		current_uA += sibling->uA_load;
@@ -709,6 +691,24 @@ static int drms_uA_update(struct regulator_dev *rdev)
 		if (err < 0)
 			rdev_err(rdev, "failed to set load %d\n", current_uA);
 	} else {
+		/* get output voltage */
+		output_uV = _regulator_get_voltage(rdev);
+		if (output_uV <= 0) {
+			rdev_err(rdev, "invalid output voltage found\n");
+			return -EINVAL;
+		}
+
+		/* get input voltage */
+		input_uV = 0;
+		if (rdev->supply)
+			input_uV = regulator_get_voltage(rdev->supply);
+		if (input_uV <= 0)
+			input_uV = rdev->constraints->input_uV;
+		if (input_uV <= 0) {
+			rdev_err(rdev, "invalid input voltage found\n");
+			return -EINVAL;
+		}
+
 		/* now get the optimum mode for our new total regulator load */
 		mode = rdev->desc->ops->get_optimum_mode(rdev, input_uV,
 							 output_uV, current_uA);

commit 73e705bf81ceb84b39ef9cf6ffb8d12ca0c58a23
Author: Matthias Kaehlcke <mka@chromium.org>
Date:   Wed Sep 14 09:52:08 2016 -0700

    regulator: core: Add set_voltage_time op
    
    The new op is analogous to set_voltage_time_sel. It can be used by
    regulators which don't have a table of discrete voltages. The function
    returns the time for the regulator output voltage to stabilize after
    being set to a new value, in microseconds. If the op is not set a
    default implementation is used to calculate the delay.
    
    This change also removes the ramp_delay calculation in the PWM
    regulator, since the driver now uses the core code for the calculation
    of the delay.
    
    Signed-off-by: Matthias Kaehlcke <mka@chromium.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index df3028b2a8e9..c52fc0ce2693 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2743,6 +2743,24 @@ static int _regulator_call_set_voltage_sel(struct regulator_dev *rdev,
 	return ret;
 }
 
+static int _regulator_set_voltage_time(struct regulator_dev *rdev,
+				       int old_uV, int new_uV)
+{
+	unsigned int ramp_delay = 0;
+
+	if (rdev->constraints->ramp_delay)
+		ramp_delay = rdev->constraints->ramp_delay;
+	else if (rdev->desc->ramp_delay)
+		ramp_delay = rdev->desc->ramp_delay;
+
+	if (ramp_delay == 0) {
+		rdev_warn(rdev, "ramp_delay not set\n");
+		return 0;
+	}
+
+	return DIV_ROUND_UP(abs(new_uV - old_uV), ramp_delay);
+}
+
 static int _regulator_do_set_voltage(struct regulator_dev *rdev,
 				     int min_uV, int max_uV)
 {
@@ -2752,6 +2770,7 @@ static int _regulator_do_set_voltage(struct regulator_dev *rdev,
 	unsigned int selector;
 	int old_selector = -1;
 	const struct regulator_ops *ops = rdev->desc->ops;
+	int old_uV = _regulator_get_voltage(rdev);
 
 	trace_regulator_set_voltage(rdev_get_name(rdev), min_uV, max_uV);
 
@@ -2803,23 +2822,37 @@ static int _regulator_do_set_voltage(struct regulator_dev *rdev,
 	if (ret)
 		goto out;
 
-	/* Call set_voltage_time_sel if successfully obtained old_selector */
-	if (!old_selector >= 0 && old_selector != selector) {
-		delay = ops->set_voltage_time_sel(rdev,
-						old_selector, selector);
-		if (delay < 0) {
-			rdev_warn(rdev, "set_voltage_time_sel() failed: %d\n",
-				  delay);
-			delay = 0;
+	if (ops->set_voltage_time_sel) {
+		/*
+		 * Call set_voltage_time_sel if successfully obtained
+		 * old_selector
+		 */
+		if (old_selector >= 0 && old_selector != selector)
+			delay = ops->set_voltage_time_sel(rdev, old_selector,
+							  selector);
+	} else {
+		if (old_uV != best_val) {
+			if (ops->set_voltage_time)
+				delay = ops->set_voltage_time(rdev, old_uV,
+							      best_val);
+			else
+				delay = _regulator_set_voltage_time(rdev,
+								    old_uV,
+								    best_val);
 		}
+	}
 
-		/* Insert any necessary delays */
-		if (delay >= 1000) {
-			mdelay(delay / 1000);
-			udelay(delay % 1000);
-		} else if (delay) {
-			udelay(delay);
-		}
+	if (delay < 0) {
+		rdev_warn(rdev, "failed to get delay: %d\n", delay);
+		delay = 0;
+	}
+
+	/* Insert any necessary delays */
+	if (delay >= 1000) {
+		mdelay(delay / 1000);
+		udelay(delay % 1000);
+	} else if (delay) {
+		udelay(delay);
 	}
 
 	if (best_val >= 0) {
@@ -3000,9 +3033,13 @@ int regulator_set_voltage_time(struct regulator *regulator,
 	int voltage;
 	int i;
 
+	if (ops->set_voltage_time)
+		return ops->set_voltage_time(rdev, old_uV, new_uV);
+	else if (!ops->set_voltage_time_sel)
+		return _regulator_set_voltage_time(rdev, old_uV, new_uV);
+
 	/* Currently requires operations to do this */
-	if (!ops->list_voltage || !ops->set_voltage_time_sel
-	    || !rdev->desc->n_voltages)
+	if (!ops->list_voltage || !rdev->desc->n_voltages)
 		return -EINVAL;
 
 	for (i = 0; i < rdev->desc->n_voltages; i++) {
@@ -3041,17 +3078,8 @@ int regulator_set_voltage_time_sel(struct regulator_dev *rdev,
 				   unsigned int old_selector,
 				   unsigned int new_selector)
 {
-	unsigned int ramp_delay = 0;
 	int old_volt, new_volt;
 
-	if (rdev->constraints->ramp_delay)
-		ramp_delay = rdev->constraints->ramp_delay;
-	else if (rdev->desc->ramp_delay)
-		ramp_delay = rdev->desc->ramp_delay;
-
-	if (ramp_delay == 0)
-		return 0;
-
 	/* sanity check */
 	if (!rdev->desc->ops->list_voltage)
 		return -EINVAL;
@@ -3059,7 +3087,11 @@ int regulator_set_voltage_time_sel(struct regulator_dev *rdev,
 	old_volt = rdev->desc->ops->list_voltage(rdev, old_selector);
 	new_volt = rdev->desc->ops->list_voltage(rdev, new_selector);
 
-	return DIV_ROUND_UP(abs(new_volt - old_volt), ramp_delay);
+	if (rdev->desc->ops->set_voltage_time)
+		return rdev->desc->ops->set_voltage_time(rdev, old_volt,
+							 new_volt);
+	else
+		return _regulator_set_voltage_time(rdev, old_volt, new_volt);
 }
 EXPORT_SYMBOL_GPL(regulator_set_voltage_time_sel);
 

commit d89564efe79419a093e966a959bf5ba2c94e693f
Author: Matthias Kaehlcke <mka@chromium.org>
Date:   Wed Sep 14 09:52:07 2016 -0700

    regulator: core: Don't skip set_voltage_time when ramp delay disabled
    
    The current code assumes that only the ramp_delay is used to determine
    the time needed for the voltage to stabilize. This may be true for the
    calculation done by regulator_set_voltage_time_sel(), however regulators
    can implement their own set_voltage_time_sel() op which would be skipped
    if no ramp delay is specified. Remove the check in
    _regulator_do_set_voltage(), the functions calculating the ramp delay
    return 0 anyway when the ramp delay is not configured.
    
    Signed-off-by: Matthias Kaehlcke <mka@chromium.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index b0076ccf896b..df3028b2a8e9 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2804,9 +2804,7 @@ static int _regulator_do_set_voltage(struct regulator_dev *rdev,
 		goto out;
 
 	/* Call set_voltage_time_sel if successfully obtained old_selector */
-	if (!rdev->constraints->ramp_disable && old_selector >= 0
-		&& old_selector != selector) {
-
+	if (!old_selector >= 0 && old_selector != selector) {
 		delay = ops->set_voltage_time_sel(rdev,
 						old_selector, selector);
 		if (delay < 0) {
@@ -3051,10 +3049,8 @@ int regulator_set_voltage_time_sel(struct regulator_dev *rdev,
 	else if (rdev->desc->ramp_delay)
 		ramp_delay = rdev->desc->ramp_delay;
 
-	if (ramp_delay == 0) {
-		rdev_warn(rdev, "ramp_delay not set\n");
+	if (ramp_delay == 0)
 		return 0;
-	}
 
 	/* sanity check */
 	if (!rdev->desc->ops->list_voltage)

commit 31dfe686ed0ba5a796bcfc5a6745e77ddb5daa4e
Author: Matthias Kaehlcke <mka@chromium.org>
Date:   Wed Sep 14 09:52:06 2016 -0700

    regulator: core: Simplify error flow in _regulator_do_set_voltage()
    
    If the voltage can not be set jump to the end of the function. This
    avoids having to check for an error multiple times and eliminates one
    level of nesting in a follow-up change.
    
    Signed-off-by: Matthias Kaehlcke <mka@chromium.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index b059e8334567..b0076ccf896b 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2800,8 +2800,11 @@ static int _regulator_do_set_voltage(struct regulator_dev *rdev,
 		ret = -EINVAL;
 	}
 
+	if (ret)
+		goto out;
+
 	/* Call set_voltage_time_sel if successfully obtained old_selector */
-	if (ret == 0 && !rdev->constraints->ramp_disable && old_selector >= 0
+	if (!rdev->constraints->ramp_disable && old_selector >= 0
 		&& old_selector != selector) {
 
 		delay = ops->set_voltage_time_sel(rdev,
@@ -2821,13 +2824,14 @@ static int _regulator_do_set_voltage(struct regulator_dev *rdev,
 		}
 	}
 
-	if (ret == 0 && best_val >= 0) {
+	if (best_val >= 0) {
 		unsigned long data = best_val;
 
 		_notifier_call_chain(rdev, REGULATOR_EVENT_VOLTAGE_CHANGE,
 				     (void *)data);
 	}
 
+out:
 	trace_regulator_set_voltage_complete(rdev_get_name(rdev), best_val);
 
 	return ret;

commit 57995a4860542ea2089558c84f739e12d5ca1059
Author: Matthias Kaehlcke <mka@chromium.org>
Date:   Wed Sep 14 09:52:05 2016 -0700

    regulator: core: Use local ops variable in _regulator_do_set_voltage()
    
    Signed-off-by: Matthias Kaehlcke <mka@chromium.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index db320e8fa865..b059e8334567 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2751,6 +2751,7 @@ static int _regulator_do_set_voltage(struct regulator_dev *rdev,
 	int best_val = 0;
 	unsigned int selector;
 	int old_selector = -1;
+	const struct regulator_ops *ops = rdev->desc->ops;
 
 	trace_regulator_set_voltage(rdev_get_name(rdev), min_uV, max_uV);
 
@@ -2762,29 +2763,28 @@ static int _regulator_do_set_voltage(struct regulator_dev *rdev,
 	 * info to call set_voltage_time_sel().
 	 */
 	if (_regulator_is_enabled(rdev) &&
-	    rdev->desc->ops->set_voltage_time_sel &&
-	    rdev->desc->ops->get_voltage_sel) {
-		old_selector = rdev->desc->ops->get_voltage_sel(rdev);
+	    ops->set_voltage_time_sel && ops->get_voltage_sel) {
+		old_selector = ops->get_voltage_sel(rdev);
 		if (old_selector < 0)
 			return old_selector;
 	}
 
-	if (rdev->desc->ops->set_voltage) {
+	if (ops->set_voltage) {
 		ret = _regulator_call_set_voltage(rdev, min_uV, max_uV,
 						  &selector);
 
 		if (ret >= 0) {
-			if (rdev->desc->ops->list_voltage)
-				best_val = rdev->desc->ops->list_voltage(rdev,
-									 selector);
+			if (ops->list_voltage)
+				best_val = ops->list_voltage(rdev,
+							     selector);
 			else
 				best_val = _regulator_get_voltage(rdev);
 		}
 
-	} else if (rdev->desc->ops->set_voltage_sel) {
+	} else if (ops->set_voltage_sel) {
 		ret = regulator_map_voltage(rdev, min_uV, max_uV);
 		if (ret >= 0) {
-			best_val = rdev->desc->ops->list_voltage(rdev, ret);
+			best_val = ops->list_voltage(rdev, ret);
 			if (min_uV <= best_val && max_uV >= best_val) {
 				selector = ret;
 				if (old_selector == selector)
@@ -2804,7 +2804,7 @@ static int _regulator_do_set_voltage(struct regulator_dev *rdev,
 	if (ret == 0 && !rdev->constraints->ramp_disable && old_selector >= 0
 		&& old_selector != selector) {
 
-		delay = rdev->desc->ops->set_voltage_time_sel(rdev,
+		delay = ops->set_voltage_time_sel(rdev,
 						old_selector, selector);
 		if (delay < 0) {
 			rdev_warn(rdev, "set_voltage_time_sel() failed: %d\n",

commit 565f9b073f37e5cb6f80ad0ad71ec1144f87fd9f
Author: Bjorn Andersson <bjorn.andersson@linaro.org>
Date:   Tue Aug 16 11:50:32 2016 -0700

    regulator: Remove support for optional supplies in the bulk API
    
    The patch was based on my missinterpretation of the API and only
    accidentally worked for me. Let's clean it out to not confuse others.
    
    This reverts commit 3ff3f518a135fa4592fe2817e9ac2cce1fa23dc2.
    
    Signed-off-by: Bjorn Andersson <bjorn.andersson@linaro.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index db320e8fa865..8ccdaf89b1c3 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -3483,10 +3483,8 @@ int regulator_bulk_get(struct device *dev, int num_consumers,
 		consumers[i].consumer = NULL;
 
 	for (i = 0; i < num_consumers; i++) {
-		consumers[i].consumer = _regulator_get(dev,
-						       consumers[i].supply,
-						       false,
-						       !consumers[i].optional);
+		consumers[i].consumer = regulator_get(dev,
+						      consumers[i].supply);
 		if (IS_ERR(consumers[i].consumer)) {
 			ret = PTR_ERR(consumers[i].consumer);
 			dev_err(dev, "Failed to get supply '%s': %d\n",

commit fc1e1c4a249e8bf0aff68576fad776dd5adc0562
Author: Mark Brown <broonie@kernel.org>
Date:   Thu Jun 9 10:49:02 2016 +0100

    regulator: Remove regulator_can_change_voltage()
    
    There is little obvious use case for a regualtor driver to know if it is
    possible to vary voltages at all by itself.  If a consumer needs to
    limit what voltages it tries to set based on the system configuration
    then it will need to enumerate the possible voltages, and without that
    even if it is possible to change voltages that doesn't mean that
    constraints or other consumers will allow whatever change the driver is
    trying to do at a given time.  It doesn't even indicate if _set_voltage()
    calls will work as noop _set_voltage() calls return success.
    
    There were no users of this API that weren't abusing it and now they're
    all gone so remove the API.
    
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index ec8184d53f13..db320e8fa865 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2508,33 +2508,6 @@ int regulator_is_enabled(struct regulator *regulator)
 }
 EXPORT_SYMBOL_GPL(regulator_is_enabled);
 
-/**
- * regulator_can_change_voltage - check if regulator can change voltage
- * @regulator: regulator source
- *
- * Returns positive if the regulator driver backing the source/client
- * can change its voltage, false otherwise. Useful for detecting fixed
- * or dummy regulators and disabling voltage change logic in the client
- * driver.
- */
-int regulator_can_change_voltage(struct regulator *regulator)
-{
-	struct regulator_dev	*rdev = regulator->rdev;
-
-	if (regulator_ops_is_valid(rdev, REGULATOR_CHANGE_VOLTAGE)) {
-		if (rdev->desc->n_voltages - rdev->desc->linear_min_sel > 1)
-			return 1;
-
-		if (rdev->desc->continuous_voltage_range &&
-		    rdev->constraints->min_uV && rdev->constraints->max_uV &&
-		    rdev->constraints->min_uV != rdev->constraints->max_uV)
-			return 1;
-	}
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(regulator_can_change_voltage);
-
 /**
  * regulator_count_voltages - count regulator_list_voltage() selectors
  * @regulator: regulator source

commit 78d5501cf41d25a2a78dd571d91fee3e1e271d3f
Merge: 8595bb27cebe 6a0028b3dd67 8a34e979f684 2d80a91b2f2a abf2f825d115
Author: Mark Brown <broonie@kernel.org>
Date:   Fri May 13 14:23:27 2016 +0100

    Merge remote-tracking branches 'regulator/topic/can-change', 'regulator/topic/constrain', 'regulator/topic/debugfs' and 'regulator/topic/doc' into regulator-next

commit ab3688541d72cae7570840c7e3c7770b35adc0ba
Merge: 170b649e40c0 45389c47526d
Author: Mark Brown <broonie@kernel.org>
Date:   Fri May 13 14:23:01 2016 +0100

    Merge remote-tracking branch 'regulator/topic/supply' into regulator-next

commit 170b649e40c0dac86eba6bd446fc79dd3b38c7ea
Merge: 75941a1ba32d de4a54c4dfae
Author: Mark Brown <broonie@kernel.org>
Date:   Fri May 13 14:22:57 2016 +0100

    Merge remote-tracking branch 'regulator/topic/core' into regulator-next

commit 75941a1ba32d36fe6230a6388f10c493b3f6232b
Merge: 93878cd54050 fef95019016a
Author: Mark Brown <broonie@kernel.org>
Date:   Fri May 13 14:22:55 2016 +0100

    Merge remote-tracking branch 'regulator/topic/bypass' into regulator-next

commit 93878cd540500884b2ea428f620c8e1426fc4d6d
Merge: 5535fc7958ef 45fa2038cf78 a21513742308
Author: Mark Brown <broonie@kernel.org>
Date:   Fri May 13 14:22:43 2016 +0100

    Merge remote-tracking branches 'regulator/fix/constrain' and 'regulator/fix/defer' into regulator-linus

commit 45389c47526d1eca70f96872c172aea0941e8520
Author: Jon Hunter <jonathanh@nvidia.com>
Date:   Tue Apr 26 11:29:45 2016 +0100

    regulator: core: Add early supply resolution for regulators
    
    The call to set_machine_constraints() in regulator_register(), will
    attempt to get the voltage for the regulator. If a regulator is in
    bypass will fail to get the voltage (ie. it's bypass voltage) and
    hence register the regulator, because the supply for the regulator has
    not been resolved yet.
    
    To fix this, add a call to regulator_resolve_supply() before we call
    set_machine_constraints(). If the call to regulator_resolve_supply()
    fails, rather than returning an error at this point, allow the
    registration of the regulator to continue because for some regulators
    resolving the supply at this point may not be necessary and it will be
    resolved later as more regulators are added. Furthermore, if the supply
    is still not resolved for a bypassed regulator, this will be detected
    when we attempt to get the voltage for the regulator and an error will
    be propagated at this point.
    
    If a bypassed regulator does not have a supply when we attempt to get
    the voltage, rather than returing -EINVAL, return -EPROBE_DEFER instead
    to allow the registration of the regulator to be deferred and tried
    again later.
    
    Please note that regulator_resolve_supply() will call
    regulator_dev_lookup() which may acquire the regulator_list_mutex. To
    avoid any deadlocks we cannot hold the regulator_list_mutex when calling
    regulator_resolve_supply(). Therefore, rather than holding the lock
    around a large portion of the registration code, just hold the lock when
    aquiring any GPIOs and setting up supplies because these sections may
    add entries to the regulator_map_list and regulator_ena_gpio_list,
    respectively.
    
    Signed-off-by: Jon Hunter <jonathanh@nvidia.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index f6d624dfcf9f..f4ab8c8bab23 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -3118,8 +3118,11 @@ static int _regulator_get_voltage(struct regulator_dev *rdev)
 			return ret;
 		if (bypassed) {
 			/* if bypassed the regulator must have a supply */
-			if (!rdev->supply)
-				return -EINVAL;
+			if (!rdev->supply) {
+				rdev_err(rdev,
+					 "bypassed regulator has no supply!\n");
+				return -EPROBE_DEFER;
+			}
 
 			return _regulator_get_voltage(rdev->supply->rdev);
 		}
@@ -3936,8 +3939,6 @@ regulator_register(const struct regulator_desc *regulator_desc,
 		rdev->dev.of_node = of_node_get(config->of_node);
 	}
 
-	mutex_lock(&regulator_list_mutex);
-
 	mutex_init(&rdev->mutex);
 	rdev->reg_data = config->driver_data;
 	rdev->owner = regulator_desc->owner;
@@ -3962,7 +3963,9 @@ regulator_register(const struct regulator_desc *regulator_desc,
 
 	if ((config->ena_gpio || config->ena_gpio_initialized) &&
 	    gpio_is_valid(config->ena_gpio)) {
+		mutex_lock(&regulator_list_mutex);
 		ret = regulator_ena_gpio_request(rdev, config);
+		mutex_unlock(&regulator_list_mutex);
 		if (ret != 0) {
 			rdev_err(rdev, "Failed to request enable GPIO%d: %d\n",
 				 config->ena_gpio, ret);
@@ -3980,31 +3983,40 @@ regulator_register(const struct regulator_desc *regulator_desc,
 	if (init_data)
 		constraints = &init_data->constraints;
 
-	ret = set_machine_constraints(rdev, constraints);
-	if (ret < 0)
-		goto wash;
-
 	if (init_data && init_data->supply_regulator)
 		rdev->supply_name = init_data->supply_regulator;
 	else if (regulator_desc->supply_name)
 		rdev->supply_name = regulator_desc->supply_name;
 
+	/*
+	 * Attempt to resolve the regulator supply, if specified,
+	 * but don't return an error if we fail because we will try
+	 * to resolve it again later as more regulators are added.
+	 */
+	if (regulator_resolve_supply(rdev))
+		rdev_dbg(rdev, "unable to resolve supply\n");
+
+	ret = set_machine_constraints(rdev, constraints);
+	if (ret < 0)
+		goto wash;
+
 	/* add consumers devices */
 	if (init_data) {
+		mutex_lock(&regulator_list_mutex);
 		for (i = 0; i < init_data->num_consumer_supplies; i++) {
 			ret = set_consumer_device_supply(rdev,
 				init_data->consumer_supplies[i].dev_name,
 				init_data->consumer_supplies[i].supply);
 			if (ret < 0) {
+				mutex_unlock(&regulator_list_mutex);
 				dev_err(dev, "Failed to set supply %s\n",
 					init_data->consumer_supplies[i].supply);
 				goto unset_supplies;
 			}
 		}
+		mutex_unlock(&regulator_list_mutex);
 	}
 
-	mutex_unlock(&regulator_list_mutex);
-
 	ret = device_register(&rdev->dev);
 	if (ret != 0) {
 		put_device(&rdev->dev);
@@ -4021,13 +4033,16 @@ regulator_register(const struct regulator_desc *regulator_desc,
 	return rdev;
 
 unset_supplies:
+	mutex_lock(&regulator_list_mutex);
 	unset_regulator_supplies(rdev);
+	mutex_unlock(&regulator_list_mutex);
 wash:
 	kfree(rdev->constraints);
+	mutex_lock(&regulator_list_mutex);
 	regulator_ena_gpio_free(rdev);
+	mutex_unlock(&regulator_list_mutex);
 clean:
 	kfree(rdev);
-	mutex_unlock(&regulator_list_mutex);
 	kfree(config);
 	return ERR_PTR(ret);
 }

commit cbc13a66fdd89ac5e360af32fec0a1a4fcd4d2f1
Merge: c438b9d01736 fef95019016a
Author: Mark Brown <broonie@kernel.org>
Date:   Wed Apr 27 16:32:14 2016 +0100

    Merge branch 'topic/bypass' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/regulator into regulator-supply

commit 8a34e979f684aa13e6c4bf23b394cca9dfabf4a9
Author: WEN Pingbo <pingbo.wen@linaro.org>
Date:   Sat Apr 23 15:11:05 2016 +0800

    regulator: refactor valid_ops_mask checking code
    
    To make the code more compat and centralized, this patch add a
    unified function - regulator_ops_is_valid. So we can add
    some extra checking code easily later.
    
    Signed-off-by: WEN Pingbo <pingbo.wen@linaro.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 18dd7ee61455..bca9167d8c43 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -132,6 +132,19 @@ static bool have_full_constraints(void)
 	return has_full_constraints || of_have_populated_dt();
 }
 
+static bool regulator_ops_is_valid(struct regulator_dev *rdev, int ops)
+{
+	if (!rdev->constraints) {
+		rdev_err(rdev, "no constraints\n");
+		return false;
+	}
+
+	if (rdev->constraints->valid_ops_mask & ops)
+		return true;
+
+	return false;
+}
+
 static inline struct regulator_dev *rdev_get_supply(struct regulator_dev *rdev)
 {
 	if (rdev && rdev->supply)
@@ -198,28 +211,13 @@ static struct device_node *of_get_regulator(struct device *dev, const char *supp
 	return regnode;
 }
 
-static int _regulator_can_change_status(struct regulator_dev *rdev)
-{
-	if (!rdev->constraints)
-		return 0;
-
-	if (rdev->constraints->valid_ops_mask & REGULATOR_CHANGE_STATUS)
-		return 1;
-	else
-		return 0;
-}
-
 /* Platform voltage constraint check */
 static int regulator_check_voltage(struct regulator_dev *rdev,
 				   int *min_uV, int *max_uV)
 {
 	BUG_ON(*min_uV > *max_uV);
 
-	if (!rdev->constraints) {
-		rdev_err(rdev, "no constraints\n");
-		return -ENODEV;
-	}
-	if (!(rdev->constraints->valid_ops_mask & REGULATOR_CHANGE_VOLTAGE)) {
+	if (!regulator_ops_is_valid(rdev, REGULATOR_CHANGE_VOLTAGE)) {
 		rdev_err(rdev, "voltage operation not allowed\n");
 		return -EPERM;
 	}
@@ -275,11 +273,7 @@ static int regulator_check_current_limit(struct regulator_dev *rdev,
 {
 	BUG_ON(*min_uA > *max_uA);
 
-	if (!rdev->constraints) {
-		rdev_err(rdev, "no constraints\n");
-		return -ENODEV;
-	}
-	if (!(rdev->constraints->valid_ops_mask & REGULATOR_CHANGE_CURRENT)) {
+	if (!regulator_ops_is_valid(rdev, REGULATOR_CHANGE_CURRENT)) {
 		rdev_err(rdev, "current operation not allowed\n");
 		return -EPERM;
 	}
@@ -312,11 +306,7 @@ static int regulator_mode_constrain(struct regulator_dev *rdev, int *mode)
 		return -EINVAL;
 	}
 
-	if (!rdev->constraints) {
-		rdev_err(rdev, "no constraints\n");
-		return -ENODEV;
-	}
-	if (!(rdev->constraints->valid_ops_mask & REGULATOR_CHANGE_MODE)) {
+	if (!regulator_ops_is_valid(rdev, REGULATOR_CHANGE_MODE)) {
 		rdev_err(rdev, "mode operation not allowed\n");
 		return -EPERM;
 	}
@@ -333,20 +323,6 @@ static int regulator_mode_constrain(struct regulator_dev *rdev, int *mode)
 	return -EINVAL;
 }
 
-/* dynamic regulator mode switching constraint check */
-static int regulator_check_drms(struct regulator_dev *rdev)
-{
-	if (!rdev->constraints) {
-		rdev_err(rdev, "no constraints\n");
-		return -ENODEV;
-	}
-	if (!(rdev->constraints->valid_ops_mask & REGULATOR_CHANGE_DRMS)) {
-		rdev_dbg(rdev, "drms operation not allowed\n");
-		return -EPERM;
-	}
-	return 0;
-}
-
 static ssize_t regulator_uV_show(struct device *dev,
 				struct device_attribute *attr, char *buf)
 {
@@ -692,8 +668,7 @@ static int drms_uA_update(struct regulator_dev *rdev)
 	 * first check to see if we can set modes at all, otherwise just
 	 * tell the consumer everything is OK.
 	 */
-	err = regulator_check_drms(rdev);
-	if (err < 0)
+	if (!regulator_ops_is_valid(rdev, REGULATOR_CHANGE_DRMS))
 		return 0;
 
 	if (!rdev->desc->ops->get_optimum_mode &&
@@ -893,7 +868,7 @@ static void print_constraints(struct regulator_dev *rdev)
 	rdev_dbg(rdev, "%s\n", buf);
 
 	if ((constraints->min_uV != constraints->max_uV) &&
-	    !(constraints->valid_ops_mask & REGULATOR_CHANGE_VOLTAGE))
+	    !regulator_ops_is_valid(rdev, REGULATOR_CHANGE_VOLTAGE))
 		rdev_warn(rdev,
 			  "Voltage range but no REGULATOR_CHANGE_VOLTAGE\n");
 }
@@ -1354,7 +1329,7 @@ static struct regulator *create_regulator(struct regulator_dev *rdev,
 	 * it is then we don't need to do nearly so much work for
 	 * enable/disable calls.
 	 */
-	if (!_regulator_can_change_status(rdev) &&
+	if (!regulator_ops_is_valid(rdev, REGULATOR_CHANGE_STATUS) &&
 	    _regulator_is_enabled(rdev))
 		regulator->always_on = true;
 
@@ -2131,15 +2106,15 @@ static int _regulator_enable(struct regulator_dev *rdev)
 	lockdep_assert_held_once(&rdev->mutex);
 
 	/* check voltage and requested load before enabling */
-	if (rdev->constraints &&
-	    (rdev->constraints->valid_ops_mask & REGULATOR_CHANGE_DRMS))
+	if (regulator_ops_is_valid(rdev, REGULATOR_CHANGE_DRMS))
 		drms_uA_update(rdev);
 
 	if (rdev->use_count == 0) {
 		/* The regulator may on if it's not switchable or left on */
 		ret = _regulator_is_enabled(rdev);
 		if (ret == -EINVAL || ret == 0) {
-			if (!_regulator_can_change_status(rdev))
+			if (!regulator_ops_is_valid(rdev,
+					REGULATOR_CHANGE_STATUS))
 				return -EPERM;
 
 			ret = _regulator_do_enable(rdev);
@@ -2241,7 +2216,7 @@ static int _regulator_disable(struct regulator_dev *rdev)
 	    (rdev->constraints && !rdev->constraints->always_on)) {
 
 		/* we are last user */
-		if (_regulator_can_change_status(rdev)) {
+		if (regulator_ops_is_valid(rdev, REGULATOR_CHANGE_STATUS)) {
 			ret = _notifier_call_chain(rdev,
 						   REGULATOR_EVENT_PRE_DISABLE,
 						   NULL);
@@ -2262,10 +2237,7 @@ static int _regulator_disable(struct regulator_dev *rdev)
 
 		rdev->use_count = 0;
 	} else if (rdev->use_count > 1) {
-
-		if (rdev->constraints &&
-			(rdev->constraints->valid_ops_mask &
-			REGULATOR_CHANGE_DRMS))
+		if (regulator_ops_is_valid(rdev, REGULATOR_CHANGE_DRMS))
 			drms_uA_update(rdev);
 
 		rdev->use_count--;
@@ -2509,8 +2481,7 @@ int regulator_can_change_voltage(struct regulator *regulator)
 {
 	struct regulator_dev	*rdev = regulator->rdev;
 
-	if (rdev->constraints &&
-	    (rdev->constraints->valid_ops_mask & REGULATOR_CHANGE_VOLTAGE)) {
+	if (regulator_ops_is_valid(rdev, REGULATOR_CHANGE_VOLTAGE)) {
 		if (rdev->desc->n_voltages - rdev->desc->linear_min_sel > 1)
 			return 1;
 
@@ -2664,7 +2635,7 @@ int regulator_is_supported_voltage(struct regulator *regulator,
 	int i, voltages, ret;
 
 	/* If we can't change voltage check the current voltage */
-	if (!(rdev->constraints->valid_ops_mask & REGULATOR_CHANGE_VOLTAGE)) {
+	if (!regulator_ops_is_valid(rdev, REGULATOR_CHANGE_VOLTAGE)) {
 		ret = regulator_get_voltage(regulator);
 		if (ret >= 0)
 			return min_uV <= ret && ret <= max_uV;
@@ -2870,7 +2841,7 @@ static int regulator_set_voltage_unlocked(struct regulator *regulator,
 	 * return successfully even though the regulator does not support
 	 * changing the voltage.
 	 */
-	if (!(rdev->constraints->valid_ops_mask & REGULATOR_CHANGE_VOLTAGE)) {
+	if (!regulator_ops_is_valid(rdev, REGULATOR_CHANGE_VOLTAGE)) {
 		current_uV = _regulator_get_voltage(rdev);
 		if (min_uV <= current_uV && current_uV <= max_uV) {
 			regulator->min_uV = min_uV;
@@ -3385,8 +3356,7 @@ int regulator_allow_bypass(struct regulator *regulator, bool enable)
 	if (!rdev->desc->ops->set_bypass)
 		return 0;
 
-	if (rdev->constraints &&
-	    !(rdev->constraints->valid_ops_mask & REGULATOR_CHANGE_BYPASS))
+	if (!regulator_ops_is_valid(rdev, REGULATOR_CHANGE_BYPASS))
 		return 0;
 
 	mutex_lock(&rdev->mutex);
@@ -4406,7 +4376,7 @@ static int __init regulator_late_cleanup(struct device *dev, void *data)
 	if (c && c->always_on)
 		return 0;
 
-	if (c && !(c->valid_ops_mask & REGULATOR_CHANGE_STATUS))
+	if (!regulator_ops_is_valid(rdev, REGULATOR_CHANGE_STATUS))
 		return 0;
 
 	mutex_lock(&rdev->mutex);

commit c438b9d017362b65f6b1a9e54f7f35e7f873dc7c
Author: Jon Hunter <jonathanh@nvidia.com>
Date:   Thu Apr 21 17:11:59 2016 +0100

    regulator: core: Move registration of regulator device
    
    The public functions to acquire a regulator, such as regulator_get(),
    internally look-up the regulator from the list of regulators that have
    been registered with the regulator device class. The registration of
    a new regulator with the regulator device class happens before the
    regulator has been completely setup. Therefore, it is possible that
    the regulator could be acquired before it has been setup successfully.
    To avoid this move the device registration of the regulator to the end
    of the regulator setup and update the error exit path accordingly.
    
    Signed-off-by: Jon Hunter <jonathanh@nvidia.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index a17ce6cbbe77..8362a0a5105d 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -3970,14 +3970,6 @@ regulator_register(const struct regulator_desc *regulator_desc,
 	if (ret < 0)
 		goto wash;
 
-	ret = device_register(&rdev->dev);
-	if (ret != 0) {
-		put_device(&rdev->dev);
-		goto wash;
-	}
-
-	dev_set_drvdata(&rdev->dev, rdev);
-
 	if (init_data && init_data->supply_regulator)
 		rdev->supply_name = init_data->supply_regulator;
 	else if (regulator_desc->supply_name)
@@ -3997,9 +3989,17 @@ regulator_register(const struct regulator_desc *regulator_desc,
 		}
 	}
 
-	rdev_init_debugfs(rdev);
 	mutex_unlock(&regulator_list_mutex);
 
+	ret = device_register(&rdev->dev);
+	if (ret != 0) {
+		put_device(&rdev->dev);
+		goto unset_supplies;
+	}
+
+	dev_set_drvdata(&rdev->dev, rdev);
+	rdev_init_debugfs(rdev);
+
 	/* try to resolve regulators supply since a new one was registered */
 	class_for_each_device(&regulator_class, NULL, NULL,
 			      regulator_register_resolve_supply);
@@ -4008,17 +4008,11 @@ regulator_register(const struct regulator_desc *regulator_desc,
 
 unset_supplies:
 	unset_regulator_supplies(rdev);
-	regulator_ena_gpio_free(rdev);
-	device_unregister(&rdev->dev);
-	/* device core frees rdev */
-	goto out;
-
 wash:
 	kfree(rdev->constraints);
 	regulator_ena_gpio_free(rdev);
 clean:
 	kfree(rdev);
-out:
 	mutex_unlock(&regulator_list_mutex);
 	kfree(config);
 	return ERR_PTR(ret);

commit f89ba3383ee69e2e1473e41ed42614fc7c9d9192
Merge: 8e5356a73604 469b640e4f4a
Author: Mark Brown <broonie@kernel.org>
Date:   Fri Apr 22 11:38:42 2016 +0100

    Merge branch 'topic/sysfs-init' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/regulator into regulator-supply

commit 8e5356a73604f53da6a1e0756727cb8f9f7bba17
Author: Jon Hunter <jonathanh@nvidia.com>
Date:   Thu Apr 21 17:11:58 2016 +0100

    regulator: core: Clear the supply pointer if enabling fails
    
    During the resolution of a regulator's supply, we may attempt to enable
    the supply if the regulator itself is already enabled. If enabling the
    supply fails, then we will call _regulator_put() for the supply.
    However, the pointer to the supply has not been cleared for the
    regulator and this will cause a crash if we then unregister the
    regulator and attempt to call regulator_put() a second time for the
    supply. Fix this by clearing the supply pointer if enabling the supply
    after fails when resolving the supply for a regulator.
    
    Signed-off-by: Jon Hunter <jonathanh@nvidia.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 9922922ce6bd..bd9ec309b707 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1536,6 +1536,7 @@ static int regulator_resolve_supply(struct regulator_dev *rdev)
 		ret = regulator_enable(rdev->supply);
 		if (ret < 0) {
 			_regulator_put(rdev->supply);
+			rdev->supply = NULL;
 			return ret;
 		}
 	}

commit 7ddede6a58a0bd26efcfd2a5055611195411f514
Author: Jon Hunter <jonathanh@nvidia.com>
Date:   Thu Apr 21 17:11:57 2016 +0100

    regulator: core: Don't terminate supply resolution early
    
    The function regulator_register_resolve_supply() is called from the
    context of class_for_each_dev() (during the regulator registration) to
    resolve any supplies added. regulator_register_resolve_supply() will
    return an error if a regulator's supply cannot be resolved and this will
    terminate the loop in class_for_each_dev(). This means that we will not
    attempt to resolve any other supplies after one has failed. Hence, this
    may delay the resolution of other regulator supplies until the failing
    one itself can be resolved.
    
    Rather than terminating the loop early, don't return an error code and
    keep attempting to resolve any other supplies for regulators that have
    been registered.
    
    Signed-off-by: Jon Hunter <jonathanh@nvidia.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index fd0e4e37f4e1..9922922ce6bd 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -3842,7 +3842,12 @@ static void rdev_init_debugfs(struct regulator_dev *rdev)
 
 static int regulator_register_resolve_supply(struct device *dev, void *data)
 {
-	return regulator_resolve_supply(dev_to_rdev(dev));
+	struct regulator_dev *rdev = dev_to_rdev(dev);
+
+	if (regulator_resolve_supply(rdev))
+		rdev_dbg(rdev, "unable to resolve supply\n");
+
+	return 0;
 }
 
 /**

commit 2d80a91b2f2a96f38877bc328dac135d69564911
Author: Richard Fitzgerald <rf@opensource.wolfsonmicro.com>
Date:   Thu Apr 21 17:23:21 2016 +0100

    regulator: core: Add debugfs to show constraint flags
    
    There are debugfs entries for voltage and current, but not for
    the constraint flags. It's useful for debugging to be able to
    see what these flags are so this patch adds a new debugfs file.
    We can't use debugfs_create_bool for this because the flags are
    bitfields, so as this needs a special read callback they have been
    collected into a single file that lists all the flags.
    
    Signed-off-by: Richard Fitzgerald <rf@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index e0b764284773..73381752ff78 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1272,6 +1272,55 @@ static void unset_regulator_supplies(struct regulator_dev *rdev)
 	}
 }
 
+#ifdef CONFIG_DEBUG_FS
+static ssize_t constraint_flags_read_file(struct file *file,
+					  char __user *user_buf,
+					  size_t count, loff_t *ppos)
+{
+	const struct regulator *regulator = file->private_data;
+	const struct regulation_constraints *c = regulator->rdev->constraints;
+	char *buf;
+	ssize_t ret;
+
+	if (!c)
+		return 0;
+
+	buf = kmalloc(PAGE_SIZE, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	ret = snprintf(buf, PAGE_SIZE,
+			"always_on: %u\n"
+			"boot_on: %u\n"
+			"apply_uV: %u\n"
+			"ramp_disable: %u\n"
+			"soft_start: %u\n"
+			"pull_down: %u\n"
+			"over_current_protection: %u\n",
+			c->always_on,
+			c->boot_on,
+			c->apply_uV,
+			c->ramp_disable,
+			c->soft_start,
+			c->pull_down,
+			c->over_current_protection);
+
+	ret = simple_read_from_buffer(user_buf, count, ppos, buf, ret);
+	kfree(buf);
+
+	return ret;
+}
+
+#endif
+
+static const struct file_operations constraint_flags_fops = {
+#ifdef CONFIG_DEBUG_FS
+	.open = simple_open,
+	.read = constraint_flags_read_file,
+	.llseek = default_llseek,
+#endif
+};
+
 #define REG_STR_SIZE	64
 
 static struct regulator *create_regulator(struct regulator_dev *rdev,
@@ -1327,6 +1376,9 @@ static struct regulator *create_regulator(struct regulator_dev *rdev,
 				   &regulator->min_uV);
 		debugfs_create_u32("max_uV", 0444, regulator->debugfs,
 				   &regulator->max_uV);
+		debugfs_create_file("constraint_flags", 0444,
+				    regulator->debugfs, regulator,
+				    &constraint_flags_fops);
 	}
 
 	/*

commit 07c5c3ad98926dc15d31aa86de62fd4170f2a745
Author: Tero Kristo <t-kristo@ti.com>
Date:   Mon Apr 18 14:49:53 2016 +0300

    regulator: core: remove lockdep assert from suspend_prepare
    
    suspend_prepare can be called during regulator init time also, where
    the mutex is not locked yet. This causes a false lockdep warning.
    To avoid the problem, remove the lockdep assertion from the function
    causing the issue. An alternative would be to lock the mutex during
    init, but this would cause other problems (some APIs used during init
    will attempt to lock the mutex also, causing deadlock.)
    
    Signed-off-by: Tero Kristo <t-kristo@ti.com>
    Reported-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 6dd63523bcfe..f28fca4b68e3 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -808,8 +808,6 @@ static int suspend_set_state(struct regulator_dev *rdev,
 /* locks held by caller */
 static int suspend_prepare(struct regulator_dev *rdev, suspend_state_t state)
 {
-	lockdep_assert_held_once(&rdev->mutex);
-
 	if (!rdev->constraints)
 		return -EINVAL;
 

commit 2c0a303a128cbef54a7b58dc2e413b874d760097
Author: Mark Brown <broonie@kernel.org>
Date:   Tue Apr 12 08:05:43 2016 +0100

    regulator: core: Fix locking of GPIO list on free
    
    When we acquire a shareable enable GPIO on probe we do so with the
    regulator_list_mutex held.  However when we release the GPIOs we do this
    immediately after dropping the mutex meaning that the list could become
    corrupted.  Move the release into the locked region to avoid this.
    
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 1cff11205642..e414c24b2906 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -4021,8 +4021,8 @@ void regulator_unregister(struct regulator_dev *rdev)
 	WARN_ON(rdev->open_count);
 	unset_regulator_supplies(rdev);
 	list_del(&rdev->list);
-	mutex_unlock(&regulator_list_mutex);
 	regulator_ena_gpio_free(rdev);
+	mutex_unlock(&regulator_list_mutex);
 	device_unregister(&rdev->dev);
 }
 EXPORT_SYMBOL_GPL(regulator_unregister);

commit 469b640e4f4a28bdd50f0ac1d2b310907afb464c
Author: Boris Brezillon <boris.brezillon@free-electrons.com>
Date:   Tue Apr 12 12:31:00 2016 +0200

    regulator: reorder initialization steps in regulator_register()
    
    device_register() is calling ->get_voltage() as part of it's sysfs attribute
    initialization process, and this functions might need to know the regulator
    constraints to return a valid value.
    This is at least true for the pwm regulator driver (when operating in
    continuous mode) which needs to know the minimum and maximum voltage values
    to calculate the current voltage:
    
    min_uV + (((max_uV - min_uV) * dutycycle) / 100);
    
    Move device_register() after set_machine_constraints() to make sure those
    constraints are correctly initialized when ->get_voltage() is called.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Reported-by: Stephen Barber <smbarber@chromium.org>
    Tested-by: Caesar Wang <wxt@rock-chips.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index e0b764284773..8258568c793a 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -3950,13 +3950,6 @@ regulator_register(const struct regulator_desc *regulator_desc,
 	rdev->dev.parent = dev;
 	dev_set_name(&rdev->dev, "regulator.%lu",
 		    (unsigned long) atomic_inc_return(&regulator_no));
-	ret = device_register(&rdev->dev);
-	if (ret != 0) {
-		put_device(&rdev->dev);
-		goto wash;
-	}
-
-	dev_set_drvdata(&rdev->dev, rdev);
 
 	/* set regulator constraints */
 	if (init_data)
@@ -3964,7 +3957,15 @@ regulator_register(const struct regulator_desc *regulator_desc,
 
 	ret = set_machine_constraints(rdev, constraints);
 	if (ret < 0)
-		goto scrub;
+		goto wash;
+
+	ret = device_register(&rdev->dev);
+	if (ret != 0) {
+		put_device(&rdev->dev);
+		goto wash;
+	}
+
+	dev_set_drvdata(&rdev->dev, rdev);
 
 	if (init_data && init_data->supply_regulator)
 		rdev->supply_name = init_data->supply_regulator;
@@ -3993,8 +3994,6 @@ regulator_register(const struct regulator_desc *regulator_desc,
 
 unset_supplies:
 	unset_regulator_supplies(rdev);
-
-scrub:
 	regulator_ena_gpio_free(rdev);
 	device_unregister(&rdev->dev);
 	/* device core frees rdev */
@@ -4002,6 +4001,7 @@ regulator_register(const struct regulator_desc *regulator_desc,
 	goto out;
 
 wash:
+	kfree(rdev->constraints);
 	regulator_ena_gpio_free(rdev);
 clean:
 	kfree(rdev);

commit fef95019016ac10e250d2c67a3c97af5797e3938
Author: Mark Brown <broonie@kernel.org>
Date:   Thu Apr 7 16:22:36 2016 +0200

    regulator: core: Use parent voltage from the supply when bypassed
    
    When a regulator is in bypass mode it is functioning as a switch
    returning the voltage set in the regulator will not give the voltage
    being output by the regulator as it's just passing through its supply.
    This means that when we are getting the voltage from a regulator we
    should check to see if it is in bypass mode and if it is we should
    report the voltage from the supply rather than that which is set on the
    regulator.
    
    Reported-by: Jon Hunter <jonathanh@nvidia.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>
    [treding@nvidia.com: return early for bypass mode]
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index e0b764284773..990fd7b3da7d 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -3109,6 +3109,20 @@ EXPORT_SYMBOL_GPL(regulator_sync_voltage);
 static int _regulator_get_voltage(struct regulator_dev *rdev)
 {
 	int sel, ret;
+	bool bypassed;
+
+	if (rdev->desc->ops->get_bypass) {
+		ret = rdev->desc->ops->get_bypass(rdev, &bypassed);
+		if (ret < 0)
+			return ret;
+		if (bypassed) {
+			/* if bypassed the regulator must have a supply */
+			if (!rdev->supply)
+				return -EINVAL;
+
+			return _regulator_get_voltage(rdev->supply->rdev);
+		}
+	}
 
 	if (rdev->desc->ops->get_voltage_sel) {
 		sel = rdev->desc->ops->get_voltage_sel(rdev);

commit a2151374230820a3a6e654f2998b2a44dbfae4e1
Author: Jon Hunter <jonathanh@nvidia.com>
Date:   Wed Mar 30 17:09:13 2016 +0100

    regulator: Fix deadlock during regulator registration
    
    Commit 5e3ca2b349b1 ("regulator: Try to resolve regulators supplies on
    registration") added a call to regulator_resolve_supply() within
    regulator_register() where the regulator_list_mutex is held. This causes
    a deadlock to occur on the Tegra114 Dalmore board when the palmas PMIC
    is registered because regulator_register_resolve_supply() calls
    regulator_dev_lookup() which may try to acquire the regulator_list_mutex
    again.
    
    Fix this by releasing the mutex before calling
    regulator_register_resolve_supply() and update the error exit path to
    ensure the mutex is released on an error.
    
    [Made commit message more legible -- broonie]
    
    Signed-off-by: Jon Hunter <jonathanh@nvidia.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index ab1838138877..fd0e4e37f4e1 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -3991,12 +3991,11 @@ regulator_register(const struct regulator_desc *regulator_desc,
 	}
 
 	rdev_init_debugfs(rdev);
+	mutex_unlock(&regulator_list_mutex);
 
 	/* try to resolve regulators supply since a new one was registered */
 	class_for_each_device(&regulator_class, NULL, NULL,
 			      regulator_register_resolve_supply);
-out:
-	mutex_unlock(&regulator_list_mutex);
 	kfree(config);
 	return rdev;
 
@@ -4007,15 +4006,16 @@ regulator_register(const struct regulator_desc *regulator_desc,
 	regulator_ena_gpio_free(rdev);
 	device_unregister(&rdev->dev);
 	/* device core frees rdev */
-	rdev = ERR_PTR(ret);
 	goto out;
 
 wash:
 	regulator_ena_gpio_free(rdev);
 clean:
 	kfree(rdev);
-	rdev = ERR_PTR(ret);
-	goto out;
+out:
+	mutex_unlock(&regulator_list_mutex);
+	kfree(config);
+	return ERR_PTR(ret);
 }
 EXPORT_SYMBOL_GPL(regulator_register);
 

commit 45a91e8f767afbbffff46bf7251f81d15d121136
Author: Mark Brown <broonie@kernel.org>
Date:   Tue Mar 29 16:33:42 2016 -0700

    regulator: core: Log when we bring constraints into range
    
    This aids in debugging problems triggered by the regulator core applying
    its constraints, we could potentially crash immediately after updating
    the voltage if the constraints are buggy.
    
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 881c37e61f75..18dd7ee61455 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -935,6 +935,8 @@ static int machine_constraints_voltage(struct regulator_dev *rdev,
 		}
 
 		if (target_min != current_uV || target_max != current_uV) {
+			rdev_info(rdev, "Bringing %duV into %d-%duV\n",
+				  current_uV, target_min, target_max);
 			ret = _regulator_do_set_voltage(
 				rdev, target_min, target_max);
 			if (ret < 0) {

commit 5e3ca2b349b1e2c80b060b51bbf2af37448fad85
Author: Javier Martinez Canillas <javier@osg.samsung.com>
Date:   Wed Mar 23 20:59:34 2016 -0300

    regulator: Try to resolve regulators supplies on registration
    
    Commit 6261b06de565 ("regulator: Defer lookup of supply to regulator_get")
    moved the regulator supplies lookup logic from the regulators registration
    to the regulators get time.
    
    Unfortunately, that changed the behavior of the regulator core since now a
    parent supply with a child regulator marked as always-on, won't be enabled
    unless a client driver attempts to get the child regulator during boot.
    
    This patch tries to resolve the parent supply for the already registered
    regulators each time that a new regulator is registered. So the regulators
    that have child regulators marked as always on will be enabled regardless
    if a driver gets the child regulator or not.
    
    That was the behavior before the mentioned commit, since parent supplies
    were looked up at regulator registration time instead of during child get.
    
    Since regulator_resolve_supply() checks for rdev->supply, most of the times
    it will be a no-op. Errors aren't checked to keep the possible out of order
    dependencies which was the motivation for the mentioned commit.
    
    Also, the supply being available will be enforced on regulator get anyways
    in case the resolve fails on regulators registration.
    
    Fixes: 6261b06de565 ("regulator: Defer lookup of supply to regulator_get")
    Suggested-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Javier Martinez Canillas <javier@osg.samsung.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Cc: <stable@vger.kernel.org> # 4.1+

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index e0b764284773..ab1838138877 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -3840,6 +3840,11 @@ static void rdev_init_debugfs(struct regulator_dev *rdev)
 			   &rdev->bypass_count);
 }
 
+static int regulator_register_resolve_supply(struct device *dev, void *data)
+{
+	return regulator_resolve_supply(dev_to_rdev(dev));
+}
+
 /**
  * regulator_register - register regulator
  * @regulator_desc: regulator to register
@@ -3986,6 +3991,10 @@ regulator_register(const struct regulator_desc *regulator_desc,
 	}
 
 	rdev_init_debugfs(rdev);
+
+	/* try to resolve regulators supply since a new one was registered */
+	class_for_each_device(&regulator_class, NULL, NULL,
+			      regulator_register_resolve_supply);
 out:
 	mutex_unlock(&regulator_list_mutex);
 	kfree(config);

commit fa93fd4ecc9c58475abac6db93a797bff893bc16
Author: Mark Brown <broonie@kernel.org>
Date:   Mon Mar 21 18:12:52 2016 +0000

    regulator: core: Ensure we are at least in bounds for our constraints
    
    Currently we only attempt to set the voltage during constraints
    application if an exact voltage is specified.  Extend this so that if
    the currently set voltage for the regulator is outside the bounds set in
    constraints we will move the voltage to the nearest constraint, raising
    to the minimum or lowering to the maximum as needed.  This ensures that
    drivers can probe without the hardware being driven out of spec.
    
    Reported-by: Ivaylo Dimitrov <ivo.g.dimitrov.75@gmail.com>
    Tested-by: Ivaylo Dimitrov <ivo.g.dimitrov.75@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index e0b764284773..881c37e61f75 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -906,7 +906,8 @@ static int machine_constraints_voltage(struct regulator_dev *rdev,
 
 	/* do we need to apply the constraint voltage */
 	if (rdev->constraints->apply_uV &&
-	    rdev->constraints->min_uV == rdev->constraints->max_uV) {
+	    rdev->constraints->min_uV && rdev->constraints->max_uV) {
+		int target_min, target_max;
 		int current_uV = _regulator_get_voltage(rdev);
 		if (current_uV < 0) {
 			rdev_err(rdev,
@@ -914,15 +915,32 @@ static int machine_constraints_voltage(struct regulator_dev *rdev,
 				 current_uV);
 			return current_uV;
 		}
-		if (current_uV < rdev->constraints->min_uV ||
-		    current_uV > rdev->constraints->max_uV) {
+
+		/*
+		 * If we're below the minimum voltage move up to the
+		 * minimum voltage, if we're above the maximum voltage
+		 * then move down to the maximum.
+		 */
+		target_min = current_uV;
+		target_max = current_uV;
+
+		if (current_uV < rdev->constraints->min_uV) {
+			target_min = rdev->constraints->min_uV;
+			target_max = rdev->constraints->min_uV;
+		}
+
+		if (current_uV > rdev->constraints->max_uV) {
+			target_min = rdev->constraints->max_uV;
+			target_max = rdev->constraints->max_uV;
+		}
+
+		if (target_min != current_uV || target_max != current_uV) {
 			ret = _regulator_do_set_voltage(
-				rdev, rdev->constraints->min_uV,
-				rdev->constraints->max_uV);
+				rdev, target_min, target_max);
 			if (ret < 0) {
 				rdev_err(rdev,
-					"failed to apply %duV constraint(%d)\n",
-					rdev->constraints->min_uV, ret);
+					"failed to apply %d-%duV constraint(%d)\n",
+					target_min, target_max, ret);
 				return ret;
 			}
 		}

commit e437b90026ac754a0f8b4fe44b844d12ce6162d1
Author: Vladimir Zapolskiy <vladimir_zapolskiy@mentor.com>
Date:   Thu Mar 24 21:52:01 2016 +0200

    regulator: core: Remove duplicate copy of active-discharge parsing
    
    Apparently due to a wrongly resolved merge conflict between two
    branches, which contained the same commit, the commit contents
    partially was added two times in a row.
    
    This change reverts the latter wrong inclusion of commit 909f7ee0b5f3
    ("regulator: core: Add support for active-discharge configuration").
    
    The first applied commit 670666b9e0af ("regulator: core: Add support
    for active-discharge configuration") is not touched.
    
    Signed-off-by: Vladimir Zapolskiy <vladimir_zapolskiy@mentor.com>
    Cc: Laxman Dewangan <ldewangan@nvidia.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index e0b764284773..1cff11205642 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1150,17 +1150,6 @@ static int set_machine_constraints(struct regulator_dev *rdev,
 		}
 	}
 
-	if (rdev->constraints->active_discharge && ops->set_active_discharge) {
-		bool ad_state = (rdev->constraints->active_discharge ==
-			      REGULATOR_ACTIVE_DISCHARGE_ENABLE) ? true : false;
-
-		ret = ops->set_active_discharge(rdev, ad_state);
-		if (ret < 0) {
-			rdev_err(rdev, "failed to set active discharge\n");
-			return ret;
-		}
-	}
-
 	print_constraints(rdev);
 	return 0;
 }

commit 95a293c7ba17253b8cffcacbdd716ebfbfe42587
Author: Javier Martinez Canillas <javier@osg.samsung.com>
Date:   Sun Mar 20 23:29:45 2016 -0300

    regulator: Remove unneded check for regulator supply
    
    The regulator_resolve_supply() function checks if a supply has been
    associated with a regulator to avoid enabling it if that is not the
    case.
    
    But the supply was already looked up with regulator_resolve_supply()
    and set with set_supply() before the check and both return on error.
    
    So the fact that this statement has been reached means that neither
    of them failed and a supply must be associated with the regulator.
    
    Signed-off-by: Javier Martinez Canillas <javier@osg.samsung.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index e0b764284773..6dd63523bcfe 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1532,7 +1532,7 @@ static int regulator_resolve_supply(struct regulator_dev *rdev)
 	}
 
 	/* Cascade always-on state to supply */
-	if (_regulator_is_enabled(rdev) && rdev->supply) {
+	if (_regulator_is_enabled(rdev)) {
 		ret = regulator_enable(rdev->supply);
 		if (ret < 0) {
 			_regulator_put(rdev->supply);

commit d6d50a8f174141846f7507cefbf369a7100a6788
Merge: d1f83021d5ca d4930cf0ae33 51817f468fb1 0998a436b1c2 917e50d6941e 96173cc6a4c4
Author: Mark Brown <broonie@kernel.org>
Date:   Sun Mar 13 15:19:47 2016 +0700

    Merge remote-tracking branches 'regulator/topic/ltc3589', 'regulator/topic/max77620', 'regulator/topic/max77686', 'regulator/topic/max77802' and 'regulator/topic/maxim' into regulator-next

commit d1f83021d5ca993242105f7b41f924614501fce5
Merge: 92aa18f88c12 354794dacc21 ab7cad331155 0258382bf398 4618119b9be5 7e6213f4345c
Author: Mark Brown <broonie@kernel.org>
Date:   Sun Mar 13 15:19:35 2016 +0700

    Merge remote-tracking branches 'regulator/topic/discharge', 'regulator/topic/fan53555', 'regulator/topic/gpio', 'regulator/topic/hi655x' and 'regulator/topic/lp872x' into regulator-next

commit 909f7ee0b5f30f735e16864a7ed18d2e6123e6d9
Author: Laxman Dewangan <ldewangan@nvidia.com>
Date:   Wed Mar 2 16:24:46 2016 +0530

    regulator: core: Add support for active-discharge configuration
    
    Add support to enable/disable active discharge of regulator via
    machine constraints. This configuration is done when setting
    machine constraint during regulator register and if regulator
    driver implemented the callback ops.
    
    Signed-off-by: Laxman Dewangan <ldewangan@nvidia.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 7ebb7c899158..5b1e049a5930 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1151,6 +1151,17 @@ static int set_machine_constraints(struct regulator_dev *rdev,
 		}
 	}
 
+	if (rdev->constraints->active_discharge && ops->set_active_discharge) {
+		bool ad_state = (rdev->constraints->active_discharge ==
+			      REGULATOR_ACTIVE_DISCHARGE_ENABLE) ? true : false;
+
+		ret = ops->set_active_discharge(rdev, ad_state);
+		if (ret < 0) {
+			rdev_err(rdev, "failed to set active discharge\n");
+			return ret;
+		}
+	}
+
 	print_constraints(rdev);
 	return 0;
 out:

commit 670666b9e0aff40c65d8061a2f53e79eee238685
Author: Laxman Dewangan <ldewangan@nvidia.com>
Date:   Wed Mar 2 16:24:46 2016 +0530

    regulator: core: Add support for active-discharge configuration
    
    Add support to enable/disable active discharge of regulator via
    machine constraints. This configuration is done when setting
    machine constraint during regulator register and if regulator
    driver implemented the callback ops.
    
    Signed-off-by: Laxman Dewangan <ldewangan@nvidia.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 744c9889f88d..7ebb7c899158 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1140,6 +1140,17 @@ static int set_machine_constraints(struct regulator_dev *rdev,
 		}
 	}
 
+	if (rdev->constraints->active_discharge && ops->set_active_discharge) {
+		bool ad_state = (rdev->constraints->active_discharge ==
+			      REGULATOR_ACTIVE_DISCHARGE_ENABLE) ? true : false;
+
+		ret = ops->set_active_discharge(rdev, ad_state);
+		if (ret < 0) {
+			rdev_err(rdev, "failed to set active discharge\n");
+			return ret;
+		}
+	}
+
 	print_constraints(rdev);
 	return 0;
 out:

commit 32165230eb6e629d7f88e66e0bd90a201549de53
Author: Krzysztof Adamski <krzysztof.adamski@tieto.com>
Date:   Wed Feb 24 11:52:50 2016 +0100

    regulator: core: fix crash in error path of regulator_register
    
    This problem was introduced by:
    commit daad134d6649 ("regulator: core: Request GPIO before creating
    sysfs entries")
    
    The error path was not updated correctly after moving GPIO registration
    code and in case regulator_ena_gpio_free failed, device_unregister() was
    called even though device_register() was not yet called.
    
    This problem breaks the boot at least on all Tegra 32-bit devices. It
    will also crash each device that specifices GPIO that is unavaiable at
    regulator_register call. Here's error log I've got when forced GPIO to
    be invalid:
    
    [    1.116612] usb-otg-vbus-reg: Failed to request enable GPIO10: -22
    [    1.122794] Unable to handle kernel NULL pointer dereference at
    virtual address 00000044
    [    1.130894] pgd = c0004000
    [    1.133598] [00000044] *pgd=00000000
    [    1.137205] Internal error: Oops: 5 [#1] SMP ARM
    
    and here's backtrace from KDB:
    
    Exception stack(0xef11fbd0 to 0xef11fc18)
    fbc0:                                     00000000 c0738a14 00000000 00000000
    fbe0: c0b2a0b0 00000000 00000000 c0738a14 c0b5fdf8 00000001 ef7f6074 ef11fc4c
    fc00: ef11fc50 ef11fc20 c02a8344 c02a7f1c 60000013 ffffffff
    [<c010cee0>] (__dabt_svc) from [<c02a7f1c>] (kernfs_find_ns+0x18/0xf8)
    [<c02a7f1c>] (kernfs_find_ns) from [<c02a8344>] (kernfs_find_and_get_ns+0x40/0x58)
    [<c02a8344>] (kernfs_find_and_get_ns) from [<c02ac4a4>] (sysfs_unmerge_group+0x28/0x68)
    [<c02ac4a4>] (sysfs_unmerge_group) from [<c044389c>] (dpm_sysfs_remove+0x30/0x5c)
    [<c044389c>] (dpm_sysfs_remove) from [<c0436ba8>] (device_del+0x48/0x1f4)
    [<c0436ba8>] (device_del) from [<c0436d84>] (device_unregister+0x30/0x6c)
    [<c0436d84>] (device_unregister) from [<c0403910>] (regulator_register+0x6d0/0xdac)
    [<c0403910>] (regulator_register) from [<c04052d4>] (devm_regulator_register+0x50/0x84)
    [<c04052d4>] (devm_regulator_register) from [<c0406298>] (reg_fixed_voltage_probe+0x25c/0x3c0)
    [<c0406298>] (reg_fixed_voltage_probe) from [<c043d21c>] (platform_drv_probe+0x60/0xb0)
    [<c043d21c>] (platform_drv_probe) from [<c043b078>] (driver_probe_device+0x24c/0x440)
    [<c043b078>] (driver_probe_device) from [<c043b5e8>] (__device_attach_driver+0xc0/0x120)
    [<c043b5e8>] (__device_attach_driver) from [<c043901c>] (bus_for_each_drv+0x6c/0x98)
    [<c043901c>] (bus_for_each_drv) from [<c043ad20>] (__device_attach+0xac/0x138)
    [<c043ad20>] (__device_attach) from [<c043b664>] (device_initial_probe+0x1c/0x20)
    [<c043b664>] (device_initial_probe) from [<c043a074>] (bus_probe_device+0x94/0x9c)
    [<c043a074>] (bus_probe_device) from [<c043a610>] (deferred_probe_work_func+0x80/0xcc)
    [<c043a610>] (deferred_probe_work_func) from [<c01381d0>] (process_one_work+0x158/0x454)
    [<c01381d0>] (process_one_work) from [<c013854c>] (worker_thread+0x38/0x510)
    [<c013854c>] (worker_thread) from [<c013e154>] (kthread+0xe8/0x104)
    [<c013e154>] (kthread) from [<c0108638>] (ret_from_fork+0x14/0x3c)
    
    Signed-off-by: Krzysztof Adamski <krzysztof.adamski@tieto.com>
    Reported-by: Jon Hunter <jonathanh@nvidia.com>
    Acked-by: Jon Hunter <jonathanh@nvidia.com>
    Tested-by: Jon Hunter <jonathanh@nvidia.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 6ee9ba43fa8f..055f8c1a83a8 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -3919,7 +3919,7 @@ regulator_register(const struct regulator_desc *regulator_desc,
 		if (ret != 0) {
 			rdev_err(rdev, "Failed to request enable GPIO%d: %d\n",
 				 config->ena_gpio, ret);
-			goto wash;
+			goto clean;
 		}
 	}
 
@@ -3931,7 +3931,7 @@ regulator_register(const struct regulator_desc *regulator_desc,
 	ret = device_register(&rdev->dev);
 	if (ret != 0) {
 		put_device(&rdev->dev);
-		goto clean;
+		goto wash;
 	}
 
 	dev_set_drvdata(&rdev->dev, rdev);
@@ -3974,13 +3974,13 @@ regulator_register(const struct regulator_desc *regulator_desc,
 
 scrub:
 	regulator_ena_gpio_free(rdev);
-
-wash:
 	device_unregister(&rdev->dev);
 	/* device core frees rdev */
 	rdev = ERR_PTR(ret);
 	goto out;
 
+wash:
+	regulator_ena_gpio_free(rdev);
 clean:
 	kfree(rdev);
 	rdev = ERR_PTR(ret);

commit ece497ae37ecf080eecdc591504a73808aa058e0
Merge: daad134d6649 6333ef46bbe5
Author: Mark Brown <broonie@kernel.org>
Date:   Thu Feb 25 10:48:11 2016 +0900

    Merge branch 'fix/core' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/regulator into regulator-core

commit daad134d66492a9f641163c94510549770b39657
Author: Krzysztof Adamski <krzysztof.adamski@tieto.com>
Date:   Mon Feb 22 09:24:00 2016 +0100

    regulator: core: Request GPIO before creating sysfs entries
    
    regulator_attr_is_visible (which is a .is_visible callback of
    regulator_dev_group attribute_grpup) checks rdev->ena_pin to decide if
    "status" file should be present in sysfs. This field is set at the end
    of regulator_ena_gpio_request so it has to be called before
    device_register() otherwise this test will always fail, causing "status"
    file to not be visible.
    
    Since regulator_attr_is_visible also tests for is_enabled() op, this
    problem is only visible for regulators that does not define this
    callback, like regulator-fixed.c.
    
    Signed-off-by: Krzysztof Adamski <krzysztof.adamski@tieto.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 744c9889f88d..3c987d76e684 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -3918,6 +3918,16 @@ regulator_register(const struct regulator_desc *regulator_desc,
 			goto clean;
 	}
 
+	if ((config->ena_gpio || config->ena_gpio_initialized) &&
+	    gpio_is_valid(config->ena_gpio)) {
+		ret = regulator_ena_gpio_request(rdev, config);
+		if (ret != 0) {
+			rdev_err(rdev, "Failed to request enable GPIO%d: %d\n",
+				 config->ena_gpio, ret);
+			goto wash;
+		}
+	}
+
 	/* register with sysfs */
 	rdev->dev.class = &regulator_class;
 	rdev->dev.parent = dev;
@@ -3931,16 +3941,6 @@ regulator_register(const struct regulator_desc *regulator_desc,
 
 	dev_set_drvdata(&rdev->dev, rdev);
 
-	if ((config->ena_gpio || config->ena_gpio_initialized) &&
-	    gpio_is_valid(config->ena_gpio)) {
-		ret = regulator_ena_gpio_request(rdev, config);
-		if (ret != 0) {
-			rdev_err(rdev, "Failed to request enable GPIO%d: %d\n",
-				 config->ena_gpio, ret);
-			goto wash;
-		}
-	}
-
 	/* set regulator constraints */
 	if (init_data)
 		constraints = &init_data->constraints;

commit 6333ef46bbe514a8ece6c432aab6bcf8637b2d7c
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Tue Jan 26 16:38:59 2016 +0000

    regulator: core: Rely on regulator_dev_release to free constraints
    
    As we now free the constraints in regulator_dev_release we will still
    call free on the constraints pointer even if we went down an error
    path in regulator_register, because it is only allocated after the
    device_register. As such we no longer need to free rdev->constraints
    on the error paths, so this patch removes said frees.
    
    Fixes: 29f5f4860a8e ("regulator: core: Move more deallocation into class unregister")
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 744c9889f88d..4405be13eb0e 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1057,18 +1057,18 @@ static int set_machine_constraints(struct regulator_dev *rdev,
 
 	ret = machine_constraints_voltage(rdev, rdev->constraints);
 	if (ret != 0)
-		goto out;
+		return ret;
 
 	ret = machine_constraints_current(rdev, rdev->constraints);
 	if (ret != 0)
-		goto out;
+		return ret;
 
 	if (rdev->constraints->ilim_uA && ops->set_input_current_limit) {
 		ret = ops->set_input_current_limit(rdev,
 						   rdev->constraints->ilim_uA);
 		if (ret < 0) {
 			rdev_err(rdev, "failed to set input limit\n");
-			goto out;
+			return ret;
 		}
 	}
 
@@ -1077,21 +1077,20 @@ static int set_machine_constraints(struct regulator_dev *rdev,
 		ret = suspend_prepare(rdev, rdev->constraints->initial_state);
 		if (ret < 0) {
 			rdev_err(rdev, "failed to set suspend state\n");
-			goto out;
+			return ret;
 		}
 	}
 
 	if (rdev->constraints->initial_mode) {
 		if (!ops->set_mode) {
 			rdev_err(rdev, "no set_mode operation\n");
-			ret = -EINVAL;
-			goto out;
+			return -EINVAL;
 		}
 
 		ret = ops->set_mode(rdev, rdev->constraints->initial_mode);
 		if (ret < 0) {
 			rdev_err(rdev, "failed to set initial mode: %d\n", ret);
-			goto out;
+			return ret;
 		}
 	}
 
@@ -1102,7 +1101,7 @@ static int set_machine_constraints(struct regulator_dev *rdev,
 		ret = _regulator_do_enable(rdev);
 		if (ret < 0 && ret != -EINVAL) {
 			rdev_err(rdev, "failed to enable\n");
-			goto out;
+			return ret;
 		}
 	}
 
@@ -1111,7 +1110,7 @@ static int set_machine_constraints(struct regulator_dev *rdev,
 		ret = ops->set_ramp_delay(rdev, rdev->constraints->ramp_delay);
 		if (ret < 0) {
 			rdev_err(rdev, "failed to set ramp_delay\n");
-			goto out;
+			return ret;
 		}
 	}
 
@@ -1119,7 +1118,7 @@ static int set_machine_constraints(struct regulator_dev *rdev,
 		ret = ops->set_pull_down(rdev);
 		if (ret < 0) {
 			rdev_err(rdev, "failed to set pull down\n");
-			goto out;
+			return ret;
 		}
 	}
 
@@ -1127,7 +1126,7 @@ static int set_machine_constraints(struct regulator_dev *rdev,
 		ret = ops->set_soft_start(rdev);
 		if (ret < 0) {
 			rdev_err(rdev, "failed to set soft start\n");
-			goto out;
+			return ret;
 		}
 	}
 
@@ -1136,16 +1135,12 @@ static int set_machine_constraints(struct regulator_dev *rdev,
 		ret = ops->set_over_current_protection(rdev);
 		if (ret < 0) {
 			rdev_err(rdev, "failed to set over current protection\n");
-			goto out;
+			return ret;
 		}
 	}
 
 	print_constraints(rdev);
 	return 0;
-out:
-	kfree(rdev->constraints);
-	rdev->constraints = NULL;
-	return ret;
 }
 
 /**
@@ -3979,7 +3974,7 @@ regulator_register(const struct regulator_desc *regulator_desc,
 
 scrub:
 	regulator_ena_gpio_free(rdev);
-	kfree(rdev->constraints);
+
 wash:
 	device_unregister(&rdev->dev);
 	/* device core frees rdev */

commit 3fbd90bf6b21453d235f533c5c5d335ecc1052eb
Merge: 8bd31df8de33 95dfead1ddb8 47769cbc09eb 3ff3f518a135 b554e1450658 3c0a2f64bcc1
Author: Mark Brown <broonie@kernel.org>
Date:   Tue Jan 12 18:26:07 2016 +0000

    Merge remote-tracking branches 'regulator/topic/lp8788', 'regulator/topic/mt6311', 'regulator/topic/optional', 'regulator/topic/palmas' and 'regulator/topic/pv88060' into regulator-next

commit 8bd31df8de3351465c5d202d1a6f0da5834726b9
Merge: 9fa295742d4f b0d6dd3ba3c3 faa5cf3af39f 70a7fb80e85a 8a99cc6ff571
Author: Mark Brown <broonie@kernel.org>
Date:   Tue Jan 12 18:26:05 2016 +0000

    Merge remote-tracking branches 'regulator/topic/const', 'regulator/topic/lm363x', 'regulator/topic/lockdep' and 'regulator/topic/lp872x' into regulator-next

commit 9fa295742d4f3064b1faf8fbbbcba21969ec9df6
Merge: 353915f0b43f 70dc6daff090
Author: Mark Brown <broonie@kernel.org>
Date:   Tue Jan 12 18:26:05 2016 +0000

    Merge remote-tracking branch 'regulator/topic/core' into regulator-next

commit 70dc6daff090afaab588e800fca3db59bfac694e
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Thu Jan 7 13:03:08 2016 +0300

    regulator: core: remove some dead code
    
    Originally queue_delayed_work() used to negative error codes or 0 and 1
    on success depending if the work was queued or not.  It caused a lot of
    bugs where people treated all non-zero returns as failures so we changed
    it to return bool instead in d4283e937861 ('workqueue: make queueing
    functions return bool').  Now it never returns failure.
    
    Checking for negative values causes a static checker warning since it is
    impossible based on the bool type.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 0853a80bf7fe..856fec528b8d 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2368,7 +2368,6 @@ static void regulator_disable_work(struct work_struct *work)
 int regulator_disable_deferred(struct regulator *regulator, int ms)
 {
 	struct regulator_dev *rdev = regulator->rdev;
-	int ret;
 
 	if (regulator->always_on)
 		return 0;
@@ -2380,13 +2379,9 @@ int regulator_disable_deferred(struct regulator *regulator, int ms)
 	rdev->deferred_disables++;
 	mutex_unlock(&rdev->mutex);
 
-	ret = queue_delayed_work(system_power_efficient_wq,
-				 &rdev->disable_work,
-				 msecs_to_jiffies(ms));
-	if (ret < 0)
-		return ret;
-	else
-		return 0;
+	queue_delayed_work(system_power_efficient_wq, &rdev->disable_work,
+			   msecs_to_jiffies(ms));
+	return 0;
 }
 EXPORT_SYMBOL_GPL(regulator_disable_deferred);
 

commit 83080a140874b6860b5191b375cfdad267eaa107
Author: Geliang Tang <geliangtang@163.com>
Date:   Tue Jan 5 22:07:55 2016 +0800

    regulator: core: use dev_to_rdev
    
    Use dev_to_rdev() instead of open-coding it.
    
    Signed-off-by: Geliang Tang <geliangtang@163.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 73b7683355cd..0853a80bf7fe 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -3708,7 +3708,7 @@ static umode_t regulator_attr_is_visible(struct kobject *kobj,
 					 struct attribute *attr, int idx)
 {
 	struct device *dev = kobj_to_dev(kobj);
-	struct regulator_dev *rdev = container_of(dev, struct regulator_dev, dev);
+	struct regulator_dev *rdev = dev_to_rdev(dev);
 	const struct regulator_ops *ops = rdev->desc->ops;
 	umode_t mode = attr->mode;
 

commit 70a7fb80e85ae7f78f8e90cec3fbd862ea6a4d4b
Author: Thierry Reding <treding@nvidia.com>
Date:   Wed Dec 2 16:54:50 2015 +0100

    regulator: core: Fix nested locking of supplies
    
    Commit fa731ac7ea04 ("regulator: core: avoid unused variable warning")
    introduced a subtle change in how supplies are locked. Where previously
    code was always locking the regulator of the current iteration, the new
    implementation only locks the regulator if it has a supply. For any
    given power tree that means that the root will never get locked.
    
    On the other hand the regulator_unlock_supply() will still release all
    the locks, which in turn causes the lock debugging code to warn about a
    mutex being unlocked which wasn't locked.
    
    Cc: Mark Brown <broonie@kernel.org>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Fixes: Fixes: fa731ac7ea04 ("regulator: core: avoid unused variable warning")
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index f71db02fcb71..732ac71b82cd 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -132,6 +132,14 @@ static bool have_full_constraints(void)
 	return has_full_constraints || of_have_populated_dt();
 }
 
+static inline struct regulator_dev *rdev_get_supply(struct regulator_dev *rdev)
+{
+	if (rdev && rdev->supply)
+		return rdev->supply->rdev;
+
+	return NULL;
+}
+
 /**
  * regulator_lock_supply - lock a regulator and its supplies
  * @rdev:         regulator source
@@ -140,8 +148,7 @@ static void regulator_lock_supply(struct regulator_dev *rdev)
 {
 	int i;
 
-	mutex_lock(&rdev->mutex);
-	for (i = 1; rdev; rdev = rdev->supply->rdev, i++)
+	for (i = 0; rdev; rdev = rdev_get_supply(rdev), i++)
 		mutex_lock_nested(&rdev->mutex, i);
 }
 

commit 49a6bb7a1c0963f260e4b0dcc2c0e56ec65a28b2
Author: Mark Brown <broonie@kernel.org>
Date:   Tue Dec 1 15:51:52 2015 +0000

    regulator: core: Ensure we lock all regulators
    
    The latest workaround for the lockdep interface's not using the second
    argument of mutex_lock_nested() changed the loop missed locking the last
    regulator due to a thinko with the loop termination condition exiting
    one regulator too soon.
    
    Reported-by: Tyler Baker <tyler.baker@linaro.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index daffff83ced2..f71db02fcb71 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -141,7 +141,7 @@ static void regulator_lock_supply(struct regulator_dev *rdev)
 	int i;
 
 	mutex_lock(&rdev->mutex);
-	for (i = 1; rdev->supply; rdev = rdev->supply->rdev, i++)
+	for (i = 1; rdev; rdev = rdev->supply->rdev, i++)
 		mutex_lock_nested(&rdev->mutex, i);
 }
 

commit bb41897e38c53458a88b271f2fbcd905ee1f9584
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Nov 27 14:46:41 2015 +0100

    regulator: core: fix regulator_lock_supply regression
    
    As noticed by Geert Uytterhoeven, my patch to avoid a harmless build warning
    in regulator_lock_supply() was total crap and introduced a real bug:
    
    > [ BUG: bad unlock balance detected! ]
    > kworker/u4:0/6 is trying to release lock (&rdev->mutex) at:
    > [<c0247b84>] regulator_set_voltage+0x38/0x50
    
    we still lock the regulator supplies, but not the actual regulators,
    so we are missing a lock, and the unlock is unbalanced.
    
    This rectifies it by first locking the regulator device itself before
    using the same loop as before to lock its supplies.
    
    Reported-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Fixes: 716fec9d1965 ("[SUBMITTED] regulator: core: avoid unused variable warning")
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index c70017d5f74b..daffff83ced2 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -140,7 +140,8 @@ static void regulator_lock_supply(struct regulator_dev *rdev)
 {
 	int i;
 
-	for (i = 0; rdev->supply; rdev = rdev->supply->rdev, i++)
+	mutex_lock(&rdev->mutex);
+	for (i = 1; rdev->supply; rdev = rdev->supply->rdev, i++)
 		mutex_lock_nested(&rdev->mutex, i);
 }
 

commit fa731ac7ea04a7d3a5c6d2f568132478c02a83b3
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Nov 20 15:24:39 2015 +0100

    regulator: core: avoid unused variable warning
    
    The second argument of the mutex_lock_nested() helper is only
    evaluated if CONFIG_DEBUG_LOCK_ALLOC is set. Otherwise we
    get this build warning for the new regulator_lock_supply
    function:
    
    drivers/regulator/core.c: In function 'regulator_lock_supply':
    drivers/regulator/core.c:142:6: warning: unused variable 'i' [-Wunused-variable]
    
    To avoid the warning, this restructures the code to make it
    both simpler and to move the 'i++' outside of the mutex_lock_nested
    call, where it is now always used and the variable is not
    flagged as unused.
    
    We had some discussion about changing mutex_lock_nested to an
    inline function, which would make the code do the right thing here,
    but in the end decided against it, in order to guarantee that
    mutex_lock_nested() does not introduced overhead without
    CONFIG_DEBUG_LOCK_ALLOC.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Fixes: 9f01cd4a915 ("regulator: core: introduce function to lock regulators and its supplies")
    Link: http://permalink.gmane.org/gmane.linux.kernel/2068900
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 73b7683355cd..c70017d5f74b 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -138,18 +138,10 @@ static bool have_full_constraints(void)
  */
 static void regulator_lock_supply(struct regulator_dev *rdev)
 {
-	struct regulator *supply;
-	int i = 0;
-
-	while (1) {
-		mutex_lock_nested(&rdev->mutex, i++);
-		supply = rdev->supply;
-
-		if (!rdev->supply)
-			return;
+	int i;
 
-		rdev = supply->rdev;
-	}
+	for (i = 0; rdev->supply; rdev = rdev->supply->rdev, i++)
+		mutex_lock_nested(&rdev->mutex, i);
 }
 
 /**

commit 3ff3f518a135fa4592fe2817e9ac2cce1fa23dc2
Author: Bjorn Andersson <bjorn.andersson@sonymobile.com>
Date:   Mon Nov 9 22:20:37 2015 -0800

    regulator: Make bulk API support optional supplies
    
    Make it possible to use the bulk API with optional supplies, by allowing
    the consumer to marking supplies as optional in the regulator_bulk_data.
    
    Signed-off-by: Bjorn Andersson <bjorn.andersson@sonymobile.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 73b7683355cd..4cf1390784e5 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -3451,8 +3451,10 @@ int regulator_bulk_get(struct device *dev, int num_consumers,
 		consumers[i].consumer = NULL;
 
 	for (i = 0; i < num_consumers; i++) {
-		consumers[i].consumer = regulator_get(dev,
-						      consumers[i].supply);
+		consumers[i].consumer = _regulator_get(dev,
+						       consumers[i].supply,
+						       false,
+						       !consumers[i].optional);
 		if (IS_ERR(consumers[i].consumer)) {
 			ret = PTR_ERR(consumers[i].consumer);
 			dev_err(dev, "Failed to get supply '%s': %d\n",

commit 62e544b983a0a8ec36a33017e1d7eb60eb7ffb5e
Merge: 2dab48ef2b2e d9b96d35d252 c2f4160b77f1 2d3eda67dd2a
Author: Mark Brown <broonie@kernel.org>
Date:   Wed Nov 4 11:19:43 2015 +0000

    Merge remote-tracking branches 'regulator/topic/supply', 'regulator/topic/tps6105x' and 'regulator/topic/tps65023' into regulator-next

commit 5408dd8f0969ba6c0cfc1a167ca522205e939f06
Merge: ce3c05973104 85f3b4311629
Author: Mark Brown <broonie@kernel.org>
Date:   Wed Nov 4 11:19:36 2015 +0000

    Merge remote-tracking branch 'regulator/topic/list' into regulator-next

commit ce3c059731043f7945dcd80b816540dbd7f928bd
Merge: 6a13feb9c828 7ebcf26c3920
Author: Mark Brown <broonie@kernel.org>
Date:   Wed Nov 4 11:19:36 2015 +0000

    Merge remote-tracking branch 'regulator/topic/core' into regulator-next

commit d9b96d35d2521342fdbcbc7468a0f7dcfaba4147
Author: Mark Brown <broonie@kernel.org>
Date:   Tue Nov 3 05:58:14 2015 +0000

    regulator: Use regulator_lock_supply() for get_voltage() too
    
    Since we need to read voltages of parents as part of setting supply
    voltages we need to be able to do get_voltage() internally without
    taking locks so reorganize the locking to take locks on the full tree on
    entry rather than as we recurse when called externally.
    
    Reported-by: John Stultz <john.stultz@linaro.org>
    Tested-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 771c6235cced..b4970eb85357 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -3055,7 +3055,7 @@ static int _regulator_get_voltage(struct regulator_dev *rdev)
 	} else if (rdev->desc->fixed_uV && (rdev->desc->n_voltages == 1)) {
 		ret = rdev->desc->fixed_uV;
 	} else if (rdev->supply) {
-		ret = regulator_get_voltage(rdev->supply);
+		ret = _regulator_get_voltage(rdev->supply->rdev);
 	} else {
 		return -EINVAL;
 	}
@@ -3078,11 +3078,11 @@ int regulator_get_voltage(struct regulator *regulator)
 {
 	int ret;
 
-	mutex_lock(&regulator->rdev->mutex);
+	regulator_lock_supply(regulator->rdev);
 
 	ret = _regulator_get_voltage(regulator->rdev);
 
-	mutex_unlock(&regulator->rdev->mutex);
+	regulator_unlock_supply(regulator->rdev);
 
 	return ret;
 }

commit fc42112c0eaa6fc7c7fe61f8c6fb91b204b4d31d
Author: Sascha Hauer <s.hauer@pengutronix.de>
Date:   Tue Oct 20 14:37:28 2015 +0200

    regulator: core: Propagate voltage changes to supply regulators
    
    Until now changing the voltage of a regulator only ever effected the
    regulator itself, but never its supplies. It's a common pattern though
    to put LDO regulators behind switching regulators. The switching
    regulators efficiently drop the input voltage but have a high ripple on
    their output. The output is then cleaned up by the LDOs. For higher
    energy efficiency the voltage drop at the LDOs should be minimized. For
    this scenario we need to propagate the voltage change to the supply
    regulators. Another scenario where voltage propagation is desired is
    a regulator which only consists of a switch and thus cannot regulate
    voltages itself. In this case we can pass setting voltages to the
    supply.
    
    This patch adds support for voltage propagation. We do voltage
    propagation when the current regulator has a minimum dropout voltage
    specified or if the current regulator lacks a get_voltage operation
    (indicating it's a switch and not a regulator).
    
    Changing the supply voltage must be done carefully. When we are
    increasing the current regulators output we must first increase the
    supply voltage and then the regulator itself. When we are decreasing the
    current regulators voltage we must decrease the supply voltage after
    changing the current regulators voltage.
    
    Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index f15b04548715..771c6235cced 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2769,6 +2769,8 @@ static int regulator_set_voltage_unlocked(struct regulator *regulator,
 	int ret = 0;
 	int old_min_uV, old_max_uV;
 	int current_uV;
+	int best_supply_uV = 0;
+	int supply_change_uV = 0;
 
 	/* If we're setting the same range as last time the change
 	 * should be a noop (some cpufreq implementations use the same
@@ -2812,10 +2814,58 @@ static int regulator_set_voltage_unlocked(struct regulator *regulator,
 	if (ret < 0)
 		goto out2;
 
+	if (rdev->supply && (rdev->desc->min_dropout_uV ||
+				!rdev->desc->ops->get_voltage)) {
+		int current_supply_uV;
+		int selector;
+
+		selector = regulator_map_voltage(rdev, min_uV, max_uV);
+		if (selector < 0) {
+			ret = selector;
+			goto out2;
+		}
+
+		best_supply_uV = _regulator_list_voltage(regulator, selector, 0);
+		if (best_supply_uV < 0) {
+			ret = best_supply_uV;
+			goto out2;
+		}
+
+		best_supply_uV += rdev->desc->min_dropout_uV;
+
+		current_supply_uV = _regulator_get_voltage(rdev->supply->rdev);
+		if (current_supply_uV < 0) {
+			ret = current_supply_uV;
+			goto out2;
+		}
+
+		supply_change_uV = best_supply_uV - current_supply_uV;
+	}
+
+	if (supply_change_uV > 0) {
+		ret = regulator_set_voltage_unlocked(rdev->supply,
+				best_supply_uV, INT_MAX);
+		if (ret) {
+			dev_err(&rdev->dev, "Failed to increase supply voltage: %d\n",
+					ret);
+			goto out2;
+		}
+	}
+
 	ret = _regulator_do_set_voltage(rdev, min_uV, max_uV);
 	if (ret < 0)
 		goto out2;
 
+	if (supply_change_uV < 0) {
+		ret = regulator_set_voltage_unlocked(rdev->supply,
+				best_supply_uV, INT_MAX);
+		if (ret)
+			dev_warn(&rdev->dev, "Failed to decrease supply voltage: %d\n",
+					ret);
+		/* No need to fail here */
+		ret = 0;
+	}
+
 out:
 	return ret;
 out2:
@@ -2847,11 +2897,11 @@ int regulator_set_voltage(struct regulator *regulator, int min_uV, int max_uV)
 {
 	int ret = 0;
 
-	mutex_lock(&regulator->rdev->mutex);
+	regulator_lock_supply(regulator->rdev);
 
 	ret = regulator_set_voltage_unlocked(regulator, min_uV, max_uV);
 
-	mutex_unlock(&regulator->rdev->mutex);
+	regulator_unlock_supply(regulator->rdev);
 
 	return ret;
 }

commit a204f41e2d670c07c4dbd382d5bd8f6db8347ac2
Author: Sascha Hauer <s.hauer@pengutronix.de>
Date:   Tue Oct 20 14:37:27 2015 +0200

    regulator: core: Factor out regulator_map_voltage
    
    _regulator_call_set_voltage has code to translate a minimum/maximum
    voltage pair into a selector. This code is useful for others aswell,
    so create a regulator_map_voltage function.
    
    Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 5d161e11d5e6..f15b04548715 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2606,6 +2606,23 @@ int regulator_is_supported_voltage(struct regulator *regulator,
 }
 EXPORT_SYMBOL_GPL(regulator_is_supported_voltage);
 
+static int regulator_map_voltage(struct regulator_dev *rdev, int min_uV,
+				 int max_uV)
+{
+	const struct regulator_desc *desc = rdev->desc;
+
+	if (desc->ops->map_voltage)
+		return desc->ops->map_voltage(rdev, min_uV, max_uV);
+
+	if (desc->ops->list_voltage == regulator_list_voltage_linear)
+		return regulator_map_voltage_linear(rdev, min_uV, max_uV);
+
+	if (desc->ops->list_voltage == regulator_list_voltage_linear_range)
+		return regulator_map_voltage_linear_range(rdev, min_uV, max_uV);
+
+	return regulator_map_voltage_iterate(rdev, min_uV, max_uV);
+}
+
 static int _regulator_call_set_voltage(struct regulator_dev *rdev,
 				       int min_uV, int max_uV,
 				       unsigned *selector)
@@ -2694,23 +2711,7 @@ static int _regulator_do_set_voltage(struct regulator_dev *rdev,
 		}
 
 	} else if (rdev->desc->ops->set_voltage_sel) {
-		if (rdev->desc->ops->map_voltage) {
-			ret = rdev->desc->ops->map_voltage(rdev, min_uV,
-							   max_uV);
-		} else {
-			if (rdev->desc->ops->list_voltage ==
-			    regulator_list_voltage_linear)
-				ret = regulator_map_voltage_linear(rdev,
-								min_uV, max_uV);
-			else if (rdev->desc->ops->list_voltage ==
-				 regulator_list_voltage_linear_range)
-				ret = regulator_map_voltage_linear_range(rdev,
-								min_uV, max_uV);
-			else
-				ret = regulator_map_voltage_iterate(rdev,
-								min_uV, max_uV);
-		}
-
+		ret = regulator_map_voltage(rdev, min_uV, max_uV);
 		if (ret >= 0) {
 			best_val = rdev->desc->ops->list_voltage(rdev, ret);
 			if (min_uV <= best_val && max_uV >= best_val) {

commit a9f226bcd9bb1941e581806e83d2c03d4043c367
Author: Sascha Hauer <s.hauer@pengutronix.de>
Date:   Tue Oct 13 12:45:25 2015 +0200

    regulator: core: create unlocked version of regulator_set_voltage
    
    The unlocked version will be needed when we start propagating voltage
    changes to the supply regulators.
    
    Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index f28c133693ad..5d161e11d5e6 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2761,33 +2761,14 @@ static int _regulator_do_set_voltage(struct regulator_dev *rdev,
 	return ret;
 }
 
-/**
- * regulator_set_voltage - set regulator output voltage
- * @regulator: regulator source
- * @min_uV: Minimum required voltage in uV
- * @max_uV: Maximum acceptable voltage in uV
- *
- * Sets a voltage regulator to the desired output voltage. This can be set
- * during any regulator state. IOW, regulator can be disabled or enabled.
- *
- * If the regulator is enabled then the voltage will change to the new value
- * immediately otherwise if the regulator is disabled the regulator will
- * output at the new voltage when enabled.
- *
- * NOTE: If the regulator is shared between several devices then the lowest
- * request voltage that meets the system constraints will be used.
- * Regulator system constraints must be set for this regulator before
- * calling this function otherwise this call will fail.
- */
-int regulator_set_voltage(struct regulator *regulator, int min_uV, int max_uV)
+static int regulator_set_voltage_unlocked(struct regulator *regulator,
+					  int min_uV, int max_uV)
 {
 	struct regulator_dev *rdev = regulator->rdev;
 	int ret = 0;
 	int old_min_uV, old_max_uV;
 	int current_uV;
 
-	mutex_lock(&rdev->mutex);
-
 	/* If we're setting the same range as last time the change
 	 * should be a noop (some cpufreq implementations use the same
 	 * voltage for multiple frequencies, for example).
@@ -2835,12 +2816,42 @@ int regulator_set_voltage(struct regulator *regulator, int min_uV, int max_uV)
 		goto out2;
 
 out:
-	mutex_unlock(&rdev->mutex);
 	return ret;
 out2:
 	regulator->min_uV = old_min_uV;
 	regulator->max_uV = old_max_uV;
-	mutex_unlock(&rdev->mutex);
+
+	return ret;
+}
+
+/**
+ * regulator_set_voltage - set regulator output voltage
+ * @regulator: regulator source
+ * @min_uV: Minimum required voltage in uV
+ * @max_uV: Maximum acceptable voltage in uV
+ *
+ * Sets a voltage regulator to the desired output voltage. This can be set
+ * during any regulator state. IOW, regulator can be disabled or enabled.
+ *
+ * If the regulator is enabled then the voltage will change to the new value
+ * immediately otherwise if the regulator is disabled the regulator will
+ * output at the new voltage when enabled.
+ *
+ * NOTE: If the regulator is shared between several devices then the lowest
+ * request voltage that meets the system constraints will be used.
+ * Regulator system constraints must be set for this regulator before
+ * calling this function otherwise this call will fail.
+ */
+int regulator_set_voltage(struct regulator *regulator, int min_uV, int max_uV)
+{
+	int ret = 0;
+
+	mutex_lock(&regulator->rdev->mutex);
+
+	ret = regulator_set_voltage_unlocked(regulator, min_uV, max_uV);
+
+	mutex_unlock(&regulator->rdev->mutex);
+
 	return ret;
 }
 EXPORT_SYMBOL_GPL(regulator_set_voltage);

commit 3a40cfc36bb3d2e25c9af31e56863ea7144c5324
Author: Sascha Hauer <s.hauer@pengutronix.de>
Date:   Wed Sep 30 16:05:43 2015 +0200

    regulator: core: create unlocked version of regulator_list_voltage
    
    The unlocked version will be needed when we start propagating voltage
    changes to the supply regulators.
    
    Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 1f9ff55b3620..f28c133693ad 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2348,6 +2348,40 @@ static int _regulator_is_enabled(struct regulator_dev *rdev)
 	return rdev->desc->ops->is_enabled(rdev);
 }
 
+static int _regulator_list_voltage(struct regulator *regulator,
+				    unsigned selector, int lock)
+{
+	struct regulator_dev *rdev = regulator->rdev;
+	const struct regulator_ops *ops = rdev->desc->ops;
+	int ret;
+
+	if (rdev->desc->fixed_uV && rdev->desc->n_voltages == 1 && !selector)
+		return rdev->desc->fixed_uV;
+
+	if (ops->list_voltage) {
+		if (selector >= rdev->desc->n_voltages)
+			return -EINVAL;
+		if (lock)
+			mutex_lock(&rdev->mutex);
+		ret = ops->list_voltage(rdev, selector);
+		if (lock)
+			mutex_unlock(&rdev->mutex);
+	} else if (rdev->supply) {
+		ret = _regulator_list_voltage(rdev->supply, selector, lock);
+	} else {
+		return -EINVAL;
+	}
+
+	if (ret > 0) {
+		if (ret < rdev->constraints->min_uV)
+			ret = 0;
+		else if (ret > rdev->constraints->max_uV)
+			ret = 0;
+	}
+
+	return ret;
+}
+
 /**
  * regulator_is_enabled - is the regulator output enabled
  * @regulator: regulator source
@@ -2437,33 +2471,7 @@ EXPORT_SYMBOL_GPL(regulator_count_voltages);
  */
 int regulator_list_voltage(struct regulator *regulator, unsigned selector)
 {
-	struct regulator_dev *rdev = regulator->rdev;
-	const struct regulator_ops *ops = rdev->desc->ops;
-	int ret;
-
-	if (rdev->desc->fixed_uV && rdev->desc->n_voltages == 1 && !selector)
-		return rdev->desc->fixed_uV;
-
-	if (ops->list_voltage) {
-		if (selector >= rdev->desc->n_voltages)
-			return -EINVAL;
-		mutex_lock(&rdev->mutex);
-		ret = ops->list_voltage(rdev, selector);
-		mutex_unlock(&rdev->mutex);
-	} else if (rdev->supply) {
-		ret = regulator_list_voltage(rdev->supply, selector);
-	} else {
-		return -EINVAL;
-	}
-
-	if (ret > 0) {
-		if (ret < rdev->constraints->min_uV)
-			ret = 0;
-		else if (ret > rdev->constraints->max_uV)
-			ret = 0;
-	}
-
-	return ret;
+	return _regulator_list_voltage(regulator, selector, 1);
 }
 EXPORT_SYMBOL_GPL(regulator_list_voltage);
 

commit 9f01cd4a915e13dda6a61b989229015687ffd58f
Author: Sascha Hauer <s.hauer@pengutronix.de>
Date:   Wed Sep 30 16:05:42 2015 +0200

    regulator: core: introduce function to lock regulators and its supplies
    
    Each regulator_dev is locked with its own mutex. This is fine as long
    as only one regulator_dev is locked, but makes lockdep unhappy when we
    have to walk up the supply chain like it can happen in
    regulator_get_voltage:
    
    regulator_get_voltage ->
     mutex_lock(&regulator->rdev->mutex) ->
    _regulator_get_voltage(regulator->rdev) ->
    regulator_get_voltage(rdev->supply) ->
    mutex_lock(&regulator->rdev->mutex);
    
    This causes lockdep to issue a possible deadlock warning.
    
    There are at least two ways to work around this:
    
    - We can always lock the whole supply chain using the functions
      introduced with this patch.
    - We could store the current voltage in struct regulator_rdev so
      that we do not have to walk up the supply chain for the
      _regulator_get_voltage case.
    
    Anyway, regulator_lock_supply/regulator_unlock_supply will be needed
    once we allow regulator_set_voltage to optimize the supply voltages.
    
    Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 7a85ac9e32c5..1f9ff55b3620 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -131,6 +131,45 @@ static bool have_full_constraints(void)
 	return has_full_constraints || of_have_populated_dt();
 }
 
+/**
+ * regulator_lock_supply - lock a regulator and its supplies
+ * @rdev:         regulator source
+ */
+static void regulator_lock_supply(struct regulator_dev *rdev)
+{
+	struct regulator *supply;
+	int i = 0;
+
+	while (1) {
+		mutex_lock_nested(&rdev->mutex, i++);
+		supply = rdev->supply;
+
+		if (!rdev->supply)
+			return;
+
+		rdev = supply->rdev;
+	}
+}
+
+/**
+ * regulator_unlock_supply - unlock a regulator and its supplies
+ * @rdev:         regulator source
+ */
+static void regulator_unlock_supply(struct regulator_dev *rdev)
+{
+	struct regulator *supply;
+
+	while (1) {
+		mutex_unlock(&rdev->mutex);
+		supply = rdev->supply;
+
+		if (!rdev->supply)
+			return;
+
+		rdev = supply->rdev;
+	}
+}
+
 /**
  * of_get_regulator - get a regulator device node based on supply name
  * @dev: Device pointer for the consumer (of regulator) device

commit 06423121d9eba0a56b9341cf82b88479017bce14
Author: Mark Brown <broonie@kernel.org>
Date:   Thu Oct 1 10:59:48 2015 +0100

    regulator: core: Handle probe deferral from DT when resolving supplies
    
    When resolving regulator-regulator supplies we ignore probe deferral
    returns from regulator_dev_lookup() (such as are generated for DT when
    we can see a supply is registered) and just fall back to the dummy
    regulator if there are full constraints (as is the case for DT).  This
    means that probe deferral is broken for DT systems, fix that by paying
    attention to -EPROBE_DEFER return codes like we do -ENODEV.
    
    A further patch will simplify this further, this is a minimal fix for
    the specific issue.
    
    Fixes: 9f7e25edb1575a6d2 (regulator: core: Handle full constraints systems when resolving supplies)
    Reported-by: Sascha Hauer <s.hauer@pengutronix.de>
    Tested-by: Sascha Hauer <s.hauer@pengutronix.de>
    Signed-off-by: Mark Brown <broonnie@kernel.org>
    Cc: stable@vger.kernel.org

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 7849187d91ae..8a34f6acc801 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1403,6 +1403,10 @@ static int regulator_resolve_supply(struct regulator_dev *rdev)
 			return 0;
 		}
 
+		/* Did the lookup explicitly defer for us? */
+		if (ret == -EPROBE_DEFER)
+			return ret;
+
 		if (have_full_constraints()) {
 			r = dummy_regulator_rdev;
 		} else {

commit 4e2e986473f708be46bd00007621f97178bd7047
Merge: 1f93e4a96c91 23c3f310e897
Author: Mark Brown <broonie@kernel.org>
Date:   Mon Sep 21 14:15:58 2015 -0700

    Merge remote-tracking branch 'regulator/fix/core' into regulator-linus

commit 85f3b4311629defd68eb2b9779fda593d8fb7728
Author: Tomeu Vizoso <tomeu.vizoso@collabora.com>
Date:   Mon Sep 21 16:02:47 2015 +0200

    regulator: core: Remove regulator_list
    
    As we are already registering a device with regulator_class for each
    regulator device, regulator_list is redundant and can be replaced with
    calls to class_find_device() and class_for_each_device().
    
    Signed-off-by: Tomeu Vizoso <tomeu.vizoso@collabora.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 7a85ac9e32c5..57a5deb6a949 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -51,7 +51,6 @@
 	pr_debug("%s: " fmt, rdev_get_name(rdev), ##__VA_ARGS__)
 
 static DEFINE_MUTEX(regulator_list_mutex);
-static LIST_HEAD(regulator_list);
 static LIST_HEAD(regulator_map_list);
 static LIST_HEAD(regulator_ena_gpio_list);
 static LIST_HEAD(regulator_supply_alias_list);
@@ -59,6 +58,8 @@ static bool has_full_constraints;
 
 static struct dentry *debugfs_root;
 
+static struct class regulator_class;
+
 /*
  * struct regulator_map
  *
@@ -1325,6 +1326,47 @@ static void regulator_supply_alias(struct device **dev, const char **supply)
 	}
 }
 
+static int of_node_match(struct device *dev, const void *data)
+{
+	return dev->of_node == data;
+}
+
+static struct regulator_dev *of_find_regulator_by_node(struct device_node *np)
+{
+	struct device *dev;
+
+	dev = class_find_device(&regulator_class, NULL, np, of_node_match);
+
+	return dev ? dev_to_rdev(dev) : NULL;
+}
+
+static int regulator_match(struct device *dev, const void *data)
+{
+	struct regulator_dev *r = dev_to_rdev(dev);
+
+	return strcmp(rdev_get_name(r), data) == 0;
+}
+
+static struct regulator_dev *regulator_lookup_by_name(const char *name)
+{
+	struct device *dev;
+
+	dev = class_find_device(&regulator_class, NULL, name, regulator_match);
+
+	return dev ? dev_to_rdev(dev) : NULL;
+}
+
+/**
+ * regulator_dev_lookup - lookup a regulator device.
+ * @dev: device for regulator "consumer".
+ * @supply: Supply name or regulator ID.
+ * @ret: 0 on success, -ENODEV if lookup fails permanently, -EPROBE_DEFER if
+ * lookup could succeed in the future.
+ *
+ * If successful, returns a struct regulator_dev that corresponds to the name
+ * @supply and with the embedded struct device refcount incremented by one,
+ * or NULL on failure. The refcount must be dropped by calling put_device().
+ */
 static struct regulator_dev *regulator_dev_lookup(struct device *dev,
 						  const char *supply,
 						  int *ret)
@@ -1340,10 +1382,9 @@ static struct regulator_dev *regulator_dev_lookup(struct device *dev,
 	if (dev && dev->of_node) {
 		node = of_get_regulator(dev, supply);
 		if (node) {
-			list_for_each_entry(r, &regulator_list, list)
-				if (r->dev.parent &&
-					node == r->dev.of_node)
-					return r;
+			r = of_find_regulator_by_node(node);
+			if (r)
+				return r;
 			*ret = -EPROBE_DEFER;
 			return NULL;
 		} else {
@@ -1361,20 +1402,24 @@ static struct regulator_dev *regulator_dev_lookup(struct device *dev,
 	if (dev)
 		devname = dev_name(dev);
 
-	list_for_each_entry(r, &regulator_list, list)
-		if (strcmp(rdev_get_name(r), supply) == 0)
-			return r;
+	r = regulator_lookup_by_name(supply);
+	if (r)
+		return r;
 
+	mutex_lock(&regulator_list_mutex);
 	list_for_each_entry(map, &regulator_map_list, list) {
 		/* If the mapping has a device set up it must match */
 		if (map->dev_name &&
 		    (!devname || strcmp(map->dev_name, devname)))
 			continue;
 
-		if (strcmp(map->supply, supply) == 0)
+		if (strcmp(map->supply, supply) == 0 &&
+		    get_device(&map->regulator->dev)) {
+			mutex_unlock(&regulator_list_mutex);
 			return map->regulator;
+		}
 	}
-
+	mutex_unlock(&regulator_list_mutex);
 
 	return NULL;
 }
@@ -1405,6 +1450,7 @@ static int regulator_resolve_supply(struct regulator_dev *rdev)
 	if (!r) {
 		if (have_full_constraints()) {
 			r = dummy_regulator_rdev;
+			get_device(&r->dev);
 		} else {
 			dev_err(dev, "Failed to resolve %s-supply for %s\n",
 				rdev->supply_name, rdev->desc->name);
@@ -1414,12 +1460,16 @@ static int regulator_resolve_supply(struct regulator_dev *rdev)
 
 	/* Recursively resolve the supply of the supply */
 	ret = regulator_resolve_supply(r);
-	if (ret < 0)
+	if (ret < 0) {
+		put_device(&r->dev);
 		return ret;
+	}
 
 	ret = set_supply(rdev, r);
-	if (ret < 0)
+	if (ret < 0) {
+		put_device(&r->dev);
 		return ret;
+	}
 
 	/* Cascade always-on state to supply */
 	if (_regulator_is_enabled(rdev)) {
@@ -1456,8 +1506,6 @@ static struct regulator *_regulator_get(struct device *dev, const char *id,
 	else
 		ret = -EPROBE_DEFER;
 
-	mutex_lock(&regulator_list_mutex);
-
 	rdev = regulator_dev_lookup(dev, id, &ret);
 	if (rdev)
 		goto found;
@@ -1469,7 +1517,7 @@ static struct regulator *_regulator_get(struct device *dev, const char *id,
 	 * succeed, so, quit with appropriate error value
 	 */
 	if (ret && ret != -ENODEV)
-		goto out;
+		return regulator;
 
 	if (!devname)
 		devname = "deviceless";
@@ -1483,40 +1531,46 @@ static struct regulator *_regulator_get(struct device *dev, const char *id,
 			devname, id);
 
 		rdev = dummy_regulator_rdev;
+		get_device(&rdev->dev);
 		goto found;
 	/* Don't log an error when called from regulator_get_optional() */
 	} else if (!have_full_constraints() || exclusive) {
 		dev_warn(dev, "dummy supplies not allowed\n");
 	}
 
-	mutex_unlock(&regulator_list_mutex);
 	return regulator;
 
 found:
 	if (rdev->exclusive) {
 		regulator = ERR_PTR(-EPERM);
-		goto out;
+		put_device(&rdev->dev);
+		return regulator;
 	}
 
 	if (exclusive && rdev->open_count) {
 		regulator = ERR_PTR(-EBUSY);
-		goto out;
+		put_device(&rdev->dev);
+		return regulator;
 	}
 
 	ret = regulator_resolve_supply(rdev);
 	if (ret < 0) {
 		regulator = ERR_PTR(ret);
-		goto out;
+		put_device(&rdev->dev);
+		return regulator;
 	}
 
-	if (!try_module_get(rdev->owner))
-		goto out;
+	if (!try_module_get(rdev->owner)) {
+		put_device(&rdev->dev);
+		return regulator;
+	}
 
 	regulator = create_regulator(rdev, dev, id);
 	if (regulator == NULL) {
 		regulator = ERR_PTR(-ENOMEM);
+		put_device(&rdev->dev);
 		module_put(rdev->owner);
-		goto out;
+		return regulator;
 	}
 
 	rdev->open_count++;
@@ -1530,9 +1584,6 @@ static struct regulator *_regulator_get(struct device *dev, const char *id,
 			rdev->use_count = 0;
 	}
 
-out:
-	mutex_unlock(&regulator_list_mutex);
-
 	return regulator;
 }
 
@@ -1630,6 +1681,7 @@ static void _regulator_put(struct regulator *regulator)
 
 	rdev->open_count--;
 	rdev->exclusive = 0;
+	put_device(&rdev->dev);
 	mutex_unlock(&rdev->mutex);
 
 	kfree(regulator->supply_name);
@@ -3807,8 +3859,6 @@ regulator_register(const struct regulator_desc *regulator_desc,
 		}
 	}
 
-	list_add(&rdev->list, &regulator_list);
-
 	rdev_init_debugfs(rdev);
 out:
 	mutex_unlock(&regulator_list_mutex);
@@ -3862,6 +3912,19 @@ void regulator_unregister(struct regulator_dev *rdev)
 }
 EXPORT_SYMBOL_GPL(regulator_unregister);
 
+static int _regulator_suspend_prepare(struct device *dev, void *data)
+{
+	struct regulator_dev *rdev = dev_to_rdev(dev);
+	const suspend_state_t *state = data;
+	int ret;
+
+	mutex_lock(&rdev->mutex);
+	ret = suspend_prepare(rdev, *state);
+	mutex_unlock(&rdev->mutex);
+
+	return ret;
+}
+
 /**
  * regulator_suspend_prepare - prepare regulators for system wide suspend
  * @state: system suspend state
@@ -3871,30 +3934,45 @@ EXPORT_SYMBOL_GPL(regulator_unregister);
  */
 int regulator_suspend_prepare(suspend_state_t state)
 {
-	struct regulator_dev *rdev;
-	int ret = 0;
-
 	/* ON is handled by regulator active state */
 	if (state == PM_SUSPEND_ON)
 		return -EINVAL;
 
-	mutex_lock(&regulator_list_mutex);
-	list_for_each_entry(rdev, &regulator_list, list) {
+	return class_for_each_device(&regulator_class, NULL, &state,
+				     _regulator_suspend_prepare);
+}
+EXPORT_SYMBOL_GPL(regulator_suspend_prepare);
 
-		mutex_lock(&rdev->mutex);
-		ret = suspend_prepare(rdev, state);
-		mutex_unlock(&rdev->mutex);
+static int _regulator_suspend_finish(struct device *dev, void *data)
+{
+	struct regulator_dev *rdev = dev_to_rdev(dev);
+	int ret;
 
-		if (ret < 0) {
-			rdev_err(rdev, "failed to prepare\n");
-			goto out;
+	mutex_lock(&rdev->mutex);
+	if (rdev->use_count > 0  || rdev->constraints->always_on) {
+		if (!_regulator_is_enabled(rdev)) {
+			ret = _regulator_do_enable(rdev);
+			if (ret)
+				dev_err(dev,
+					"Failed to resume regulator %d\n",
+					ret);
 		}
+	} else {
+		if (!have_full_constraints())
+			goto unlock;
+		if (!_regulator_is_enabled(rdev))
+			goto unlock;
+
+		ret = _regulator_do_disable(rdev);
+		if (ret)
+			dev_err(dev, "Failed to suspend regulator %d\n", ret);
 	}
-out:
-	mutex_unlock(&regulator_list_mutex);
-	return ret;
+unlock:
+	mutex_unlock(&rdev->mutex);
+
+	/* Keep processing regulators in spite of any errors */
+	return 0;
 }
-EXPORT_SYMBOL_GPL(regulator_suspend_prepare);
 
 /**
  * regulator_suspend_finish - resume regulators from system wide suspend
@@ -3904,33 +3982,8 @@ EXPORT_SYMBOL_GPL(regulator_suspend_prepare);
  */
 int regulator_suspend_finish(void)
 {
-	struct regulator_dev *rdev;
-	int ret = 0, error;
-
-	mutex_lock(&regulator_list_mutex);
-	list_for_each_entry(rdev, &regulator_list, list) {
-		mutex_lock(&rdev->mutex);
-		if (rdev->use_count > 0  || rdev->constraints->always_on) {
-			if (!_regulator_is_enabled(rdev)) {
-				error = _regulator_do_enable(rdev);
-				if (error)
-					ret = error;
-			}
-		} else {
-			if (!have_full_constraints())
-				goto unlock;
-			if (!_regulator_is_enabled(rdev))
-				goto unlock;
-
-			error = _regulator_do_disable(rdev);
-			if (error)
-				ret = error;
-		}
-unlock:
-		mutex_unlock(&rdev->mutex);
-	}
-	mutex_unlock(&regulator_list_mutex);
-	return ret;
+	return class_for_each_device(&regulator_class, NULL, NULL,
+				     _regulator_suspend_finish);
 }
 EXPORT_SYMBOL_GPL(regulator_suspend_finish);
 
@@ -4050,14 +4103,35 @@ static const struct file_operations supply_map_fops = {
 };
 
 #ifdef CONFIG_DEBUG_FS
+struct summary_data {
+	struct seq_file *s;
+	struct regulator_dev *parent;
+	int level;
+};
+
+static void regulator_summary_show_subtree(struct seq_file *s,
+					   struct regulator_dev *rdev,
+					   int level);
+
+static int regulator_summary_show_children(struct device *dev, void *data)
+{
+	struct regulator_dev *rdev = dev_to_rdev(dev);
+	struct summary_data *summary_data = data;
+
+	if (rdev->supply && rdev->supply->rdev == summary_data->parent)
+		regulator_summary_show_subtree(summary_data->s, rdev,
+					       summary_data->level + 1);
+
+	return 0;
+}
+
 static void regulator_summary_show_subtree(struct seq_file *s,
 					   struct regulator_dev *rdev,
 					   int level)
 {
-	struct list_head *list = s->private;
-	struct regulator_dev *child;
 	struct regulation_constraints *c;
 	struct regulator *consumer;
+	struct summary_data summary_data;
 
 	if (!rdev)
 		return;
@@ -4107,33 +4181,32 @@ static void regulator_summary_show_subtree(struct seq_file *s,
 		seq_puts(s, "\n");
 	}
 
-	list_for_each_entry(child, list, list) {
-		/* handle only non-root regulators supplied by current rdev */
-		if (!child->supply || child->supply->rdev != rdev)
-			continue;
+	summary_data.s = s;
+	summary_data.level = level;
+	summary_data.parent = rdev;
 
-		regulator_summary_show_subtree(s, child, level + 1);
-	}
+	class_for_each_device(&regulator_class, NULL, &summary_data,
+			      regulator_summary_show_children);
 }
 
-static int regulator_summary_show(struct seq_file *s, void *data)
+static int regulator_summary_show_roots(struct device *dev, void *data)
 {
-	struct list_head *list = s->private;
-	struct regulator_dev *rdev;
-
-	seq_puts(s, " regulator                      use open bypass voltage current     min     max\n");
-	seq_puts(s, "-------------------------------------------------------------------------------\n");
+	struct regulator_dev *rdev = dev_to_rdev(dev);
+	struct seq_file *s = data;
 
-	mutex_lock(&regulator_list_mutex);
+	if (!rdev->supply)
+		regulator_summary_show_subtree(s, rdev, 0);
 
-	list_for_each_entry(rdev, list, list) {
-		if (rdev->supply)
-			continue;
+	return 0;
+}
 
-		regulator_summary_show_subtree(s, rdev, 0);
-	}
+static int regulator_summary_show(struct seq_file *s, void *data)
+{
+	seq_puts(s, " regulator                      use open bypass voltage current     min     max\n");
+	seq_puts(s, "-------------------------------------------------------------------------------\n");
 
-	mutex_unlock(&regulator_list_mutex);
+	class_for_each_device(&regulator_class, NULL, s,
+			      regulator_summary_show_roots);
 
 	return 0;
 }
@@ -4167,7 +4240,7 @@ static int __init regulator_init(void)
 			    &supply_map_fops);
 
 	debugfs_create_file("regulator_summary", 0444, debugfs_root,
-			    &regulator_list, &regulator_summary_fops);
+			    NULL, &regulator_summary_fops);
 
 	regulator_dummy_init();
 

commit 23c3f310e897837aeb8ffe8700b803cb58e7b35d
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Thu Sep 17 14:50:20 2015 +0100

    regulator: core: Correct return value check in regulator_resolve_supply
    
    The ret pointer passed to regulator_dev_lookup is only filled with a
    valid error code if regulator_dev_lookup returned NULL. Currently
    regulator_resolve_supply checks this ret value before it checks if a
    regulator was returned, this can result in valid regulator lookups being
    ignored.
    
    Fixes: 6261b06de565 ("regulator: Defer lookup of supply to regulator_get")
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Cc: stable@vger.kernel.org

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 7150ff6ef46b..d0fbaea9bf54 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1394,15 +1394,15 @@ static int regulator_resolve_supply(struct regulator_dev *rdev)
 		return 0;
 
 	r = regulator_dev_lookup(dev, rdev->supply_name, &ret);
-	if (ret == -ENODEV) {
-		/*
-		 * No supply was specified for this regulator and
-		 * there will never be one.
-		 */
-		return 0;
-	}
-
 	if (!r) {
+		if (ret == -ENODEV) {
+			/*
+			 * No supply was specified for this regulator and
+			 * there will never be one.
+			 */
+			return 0;
+		}
+
 		if (have_full_constraints()) {
 			r = dummy_regulator_rdev;
 		} else {

commit 7ebcf26c39205ca8d61c178dcd3f5be4f25b1309
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Wed Sep 16 12:10:26 2015 -0700

    regulator: core: Make error messages more informative
    
    The same error print exists 4 times in the regulator core
    
            <rdev>: operation not allowed
    
    Unfortunately, seeing this in the dmesg is not very informative.
    Add what type of operation is not allowed to the message so that
    these errors are unique, hopefully pointing developers in the
    right direction
    
            <rdev>: drms operation not allowed
            <rdev>: voltage operation not allowed
            <rdev>: current operation not allowed
            <rdev>: mode operation not allowed
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 7a85ac9e32c5..065fe877dcf5 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -180,7 +180,7 @@ static int regulator_check_voltage(struct regulator_dev *rdev,
 		return -ENODEV;
 	}
 	if (!(rdev->constraints->valid_ops_mask & REGULATOR_CHANGE_VOLTAGE)) {
-		rdev_err(rdev, "operation not allowed\n");
+		rdev_err(rdev, "voltage operation not allowed\n");
 		return -EPERM;
 	}
 
@@ -240,7 +240,7 @@ static int regulator_check_current_limit(struct regulator_dev *rdev,
 		return -ENODEV;
 	}
 	if (!(rdev->constraints->valid_ops_mask & REGULATOR_CHANGE_CURRENT)) {
-		rdev_err(rdev, "operation not allowed\n");
+		rdev_err(rdev, "current operation not allowed\n");
 		return -EPERM;
 	}
 
@@ -277,7 +277,7 @@ static int regulator_mode_constrain(struct regulator_dev *rdev, int *mode)
 		return -ENODEV;
 	}
 	if (!(rdev->constraints->valid_ops_mask & REGULATOR_CHANGE_MODE)) {
-		rdev_err(rdev, "operation not allowed\n");
+		rdev_err(rdev, "mode operation not allowed\n");
 		return -EPERM;
 	}
 
@@ -301,7 +301,7 @@ static int regulator_check_drms(struct regulator_dev *rdev)
 		return -ENODEV;
 	}
 	if (!(rdev->constraints->valid_ops_mask & REGULATOR_CHANGE_DRMS)) {
-		rdev_dbg(rdev, "operation not allowed\n");
+		rdev_dbg(rdev, "drms operation not allowed\n");
 		return -EPERM;
 	}
 	return 0;

commit e81b594cdae73f341ea13bc9fb2b57a5b739c1a3
Merge: fa815580fb87 072502a67c91
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Sep 8 16:48:55 2015 -0700

    Merge tag 'regmap-v4.3' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/regmap
    
    Pull regmap updates from Mark Brown:
     "This has been a busy release for regmap.
    
      By far the biggest set of changes here are those from Markus Pargmann
      which implement support for block transfers in smbus devices.  This
      required quite a bit of refactoring but leaves us better able to
      handle odd restrictions that controllers may have and with better
      performance on smbus.
    
      Other new features include:
    
       - Fix interactions with lockdep for nested regmaps (eg, when a device
         using regmap is connected to a bus where the bus controller has a
         separate regmap).  Lockdep's default class identification is too
         crude to work without help.
    
       - Support for must write bitfield operations, useful for operations
         which require writing a bit to trigger them from Kuniori Morimoto.
    
       - Support for delaying during register patch application from Nariman
         Poushin.
    
       - Support for overriding cache state via the debugfs implementation
         from Richard Fitzgerald"
    
    * tag 'regmap-v4.3' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/regmap: (25 commits)
      regmap: fix a NULL pointer dereference in __regmap_init
      regmap: Support bulk reads for devices without raw formatting
      regmap-i2c: Add smbus i2c block support
      regmap: Add raw_write/read checks for max_raw_write/read sizes
      regmap: regmap max_raw_read/write getter functions
      regmap: Introduce max_raw_read/write for regmap_bulk_read/write
      regmap: Add missing comments about struct regmap_bus
      regmap: No multi_write support if bus->write does not exist
      regmap: Split use_single_rw internally into use_single_read/write
      regmap: Fix regmap_bulk_write for bus writes
      regmap: regmap_raw_read return error on !bus->read
      regulator: core: Print at debug level on debugfs creation failure
      regmap: Fix regmap_can_raw_write check
      regmap: fix typos in regmap.c
      regmap: Fix integertypes for register address and value
      regmap: Move documentation to regmap.h
      regmap: Use different lockdep class for each regmap init call
      thermal: sti: Add parentheses around bridge->ops->regmap_init call
      mfd: vexpress: Add parentheses around bridge->ops->regmap_init call
      regmap: debugfs: Fix misuse of IS_ENABLED
      ...

commit 84fb9015d20dc12a2d36f7d775700a53cc45ad90
Merge: a458a6d411b8 ad3a942bd22f e874e6c7edc4
Author: Mark Brown <broonie@kernel.org>
Date:   Fri Sep 4 17:22:09 2015 +0100

    Merge remote-tracking branches 'regmap/topic/debugfs' and 'regmap/topic/force-update' into regmap-next

commit 9f8df6adf6c53abfa10e243cb289c34eb18ec581
Author: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
Date:   Wed Sep 2 16:14:06 2015 +0530

    regulator: core: fix possible NULL dereference
    
    We were checking rdev->supply for NULL after dereferencing it. Lets
    check for rdev->supply along with _regulator_is_enabled() and call
    regulator_enable() only if rdev->supply is not NULL.
    
    Signed-off-by: Sudip Mukherjee <sudip@vectorindia.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index de9f272a0faf..7150ff6ef46b 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1422,11 +1422,10 @@ static int regulator_resolve_supply(struct regulator_dev *rdev)
 		return ret;
 
 	/* Cascade always-on state to supply */
-	if (_regulator_is_enabled(rdev)) {
+	if (_regulator_is_enabled(rdev) && rdev->supply) {
 		ret = regulator_enable(rdev->supply);
 		if (ret < 0) {
-			if (rdev->supply)
-				_regulator_put(rdev->supply);
+			_regulator_put(rdev->supply);
 			return ret;
 		}
 	}

commit 3e683126f4b42bd29ac5adff1eb178880aa7706a
Merge: 176175b613cb 6d73aef11760 3a003baeec24 a807a6cc2911 a02daad70214 60cb65ebf49e
Author: Mark Brown <broonie@kernel.org>
Date:   Sun Aug 30 14:39:48 2015 +0100

    Merge remote-tracking branches 'regulator/topic/mt6311', 'regulator/topic/ocp', 'regulator/topic/owner', 'regulator/topic/pfuze100' and 'regulator/topic/pwm' into regulator-next

commit 11f24823667400983a05e6099d645f523d1989ef
Merge: 08aad16c80f2 4245746037e3 7bd393543287 e80c47bd738b 5b87af4cca17 609ca5f3cb32
Author: Mark Brown <broonie@kernel.org>
Date:   Sun Aug 30 14:39:14 2015 +0100

    Merge remote-tracking branches 'regulator/topic/da9210', 'regulator/topic/da9211', 'regulator/topic/fan53555', 'regulator/topic/isl9305' and 'regulator/topic/list' into regulator-next

commit eaf018e170cef4a5a4378c984b70d768dd30048d
Merge: e616e2f11b27 099982fac0f3
Author: Mark Brown <broonie@kernel.org>
Date:   Sun Aug 30 14:38:46 2015 +0100

    Merge remote-tracking branch 'regulator/topic/core' into regulator-next

commit 099982fac0f3e884ed4af2178d4dcded69e0042e
Author: Archit Taneja <architt@codeaurora.org>
Date:   Fri Aug 28 16:22:18 2015 +0530

    regulator: core: use debug level print in regulator_check_drms
    
    When calling regulator_set_load, regulator_check_drms prints and returns
    an error if the regulator device's flag REGULATOR_CHANGE_DRMS isn't set.
    drms_uA_update, however, bails out without reporting an error.
    
    Replace the error print with a debug level print so that we don't get
    such prints when the underlying regulator doesn't support DRMS.
    
    Signed-off-by: Archit Taneja <architt@codeaurora.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 5d61eb8f2a79..22e276f7e72f 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -295,7 +295,7 @@ static int regulator_check_drms(struct regulator_dev *rdev)
 		return -ENODEV;
 	}
 	if (!(rdev->constraints->valid_ops_mask & REGULATOR_CHANGE_DRMS)) {
-		rdev_err(rdev, "operation not allowed\n");
+		rdev_dbg(rdev, "operation not allowed\n");
 		return -EPERM;
 	}
 	return 0;

commit 93576842718edf302b03f30b9915d3e704b0c78a
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon Aug 17 12:30:58 2015 +0530

    regulator: core: Use IS_ERR_OR_NULL()
    
    Use IS_ERR_OR_NULL() rather than open coding it.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 999a94b9735e..5d61eb8f2a79 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1588,7 +1588,7 @@ static void _regulator_put(struct regulator *regulator)
 {
 	struct regulator_dev *rdev;
 
-	if (regulator == NULL || IS_ERR(regulator))
+	if (IS_ERR_OR_NULL(regulator))
 		return;
 
 	lockdep_assert_held_once(&regulator_list_mutex);

commit ad3a942bd22fd40a0f4ddaf2759946ce945662af
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Mon Jun 1 18:47:55 2015 -0700

    regulator: core: Print at debug level on debugfs creation failure
    
    Failure to create a debugfs node is not an error, but we print a
    warning upon failure to create the node. Downgrade this to a
    debug printk so that we're quiet here. This allows multiple
    drivers to request a CPU's regulator so that CPUfreq and AVSish
    drivers can coexist.
    
    The downside of this approach is that whoever gets to debugfs first
    the others who come later to not have any debugfs attributes associated
    with them.
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index c9f72019bd68..c203f3ebe951 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1240,7 +1240,7 @@ static struct regulator *create_regulator(struct regulator_dev *rdev,
 	regulator->debugfs = debugfs_create_dir(regulator->supply_name,
 						rdev->debugfs);
 	if (!regulator->debugfs) {
-		rdev_warn(rdev, "Failed to create debugfs directory\n");
+		rdev_dbg(rdev, "Failed to create debugfs directory\n");
 	} else {
 		debugfs_create_u32("uA_load", 0444, regulator->debugfs,
 				   &regulator->uA_load);

commit d3fb9800146b7ad96b7604755c1a943fe1abbde2
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Aug 13 18:09:49 2015 +0530

    regulator: core: Spelling fix
    
    Trivial spell fix, s/succesfully/successfully.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 62e4f3bd5783..999a94b9735e 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2723,7 +2723,7 @@ int regulator_set_voltage(struct regulator *regulator, int min_uV, int max_uV)
 		goto out;
 
 	/* If we're trying to set a range that overlaps the current voltage,
-	 * return succesfully even though the regulator does not support
+	 * return successfully even though the regulator does not support
 	 * changing the voltage.
 	 */
 	if (!(rdev->constraints->valid_ops_mask & REGULATOR_CHANGE_VOLTAGE)) {

commit 609ca5f3cb32c2d11fd8cabe293ff3689e7d2613
Author: Mark Brown <broonie@kernel.org>
Date:   Mon Aug 10 19:43:47 2015 +0100

    regulator: core: Use class device list for regulator_list in late init
    
    The regulator_list has exactly the same contents as the list that the
    driver core maintains of regulator_class members so is redundant. As a
    first step in converting over to use the class device list convert our
    iteration in late_initcall() to use the class device iterator.
    
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 01a0a78368b8..0c0e9ab94d4d 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -110,6 +110,11 @@ static struct regulator *create_regulator(struct regulator_dev *rdev,
 					  struct device *dev,
 					  const char *supply_name);
 
+static struct regulator_dev *dev_to_rdev(struct device *dev)
+{
+	return container_of(dev, struct regulator_dev, dev);
+}
+
 static const char *rdev_get_name(struct regulator_dev *rdev)
 {
 	if (rdev->constraints && rdev->constraints->name)
@@ -4152,13 +4157,57 @@ static int __init regulator_init(void)
 /* init early to allow our consumers to complete system booting */
 core_initcall(regulator_init);
 
-static int __init regulator_init_complete(void)
+static int __init regulator_late_cleanup(struct device *dev, void *data)
 {
-	struct regulator_dev *rdev;
-	const struct regulator_ops *ops;
-	struct regulation_constraints *c;
+	struct regulator_dev *rdev = dev_to_rdev(dev);
+	const struct regulator_ops *ops = rdev->desc->ops;
+	struct regulation_constraints *c = rdev->constraints;
 	int enabled, ret;
 
+	if (c && c->always_on)
+		return 0;
+
+	if (c && !(c->valid_ops_mask & REGULATOR_CHANGE_STATUS))
+		return 0;
+
+	mutex_lock(&rdev->mutex);
+
+	if (rdev->use_count)
+		goto unlock;
+
+	/* If we can't read the status assume it's on. */
+	if (ops->is_enabled)
+		enabled = ops->is_enabled(rdev);
+	else
+		enabled = 1;
+
+	if (!enabled)
+		goto unlock;
+
+	if (have_full_constraints()) {
+		/* We log since this may kill the system if it goes
+		 * wrong. */
+		rdev_info(rdev, "disabling\n");
+		ret = _regulator_do_disable(rdev);
+		if (ret != 0)
+			rdev_err(rdev, "couldn't disable: %d\n", ret);
+	} else {
+		/* The intention is that in future we will
+		 * assume that full constraints are provided
+		 * so warn even if we aren't going to do
+		 * anything here.
+		 */
+		rdev_warn(rdev, "incomplete constraints, leaving on\n");
+	}
+
+unlock:
+	mutex_unlock(&rdev->mutex);
+
+	return 0;
+}
+
+static int __init regulator_init_complete(void)
+{
 	/*
 	 * Since DT doesn't provide an idiomatic mechanism for
 	 * enabling full constraints and since it's much more natural
@@ -4168,58 +4217,13 @@ static int __init regulator_init_complete(void)
 	if (of_have_populated_dt())
 		has_full_constraints = true;
 
-	mutex_lock(&regulator_list_mutex);
-
 	/* If we have a full configuration then disable any regulators
 	 * we have permission to change the status for and which are
 	 * not in use or always_on.  This is effectively the default
 	 * for DT and ACPI as they have full constraints.
 	 */
-	list_for_each_entry(rdev, &regulator_list, list) {
-		ops = rdev->desc->ops;
-		c = rdev->constraints;
-
-		if (c && c->always_on)
-			continue;
-
-		if (c && !(c->valid_ops_mask & REGULATOR_CHANGE_STATUS))
-			continue;
-
-		mutex_lock(&rdev->mutex);
-
-		if (rdev->use_count)
-			goto unlock;
-
-		/* If we can't read the status assume it's on. */
-		if (ops->is_enabled)
-			enabled = ops->is_enabled(rdev);
-		else
-			enabled = 1;
-
-		if (!enabled)
-			goto unlock;
-
-		if (have_full_constraints()) {
-			/* We log since this may kill the system if it
-			 * goes wrong. */
-			rdev_info(rdev, "disabling\n");
-			ret = _regulator_do_disable(rdev);
-			if (ret != 0)
-				rdev_err(rdev, "couldn't disable: %d\n", ret);
-		} else {
-			/* The intention is that in future we will
-			 * assume that full constraints are provided
-			 * so warn even if we aren't going to do
-			 * anything here.
-			 */
-			rdev_warn(rdev, "incomplete constraints, leaving on\n");
-		}
-
-unlock:
-		mutex_unlock(&rdev->mutex);
-	}
-
-	mutex_unlock(&regulator_list_mutex);
+	class_for_each_device(&regulator_class, NULL, NULL,
+			      regulator_late_cleanup);
 
 	return 0;
 }

commit 29f5f4860a8ef9407736594ec43b4fa4152ac7fa
Author: Mark Brown <broonie@kernel.org>
Date:   Fri Aug 7 20:01:32 2015 +0100

    regulator: core: Move more deallocation into class unregister
    
    We really ought to be using the class dvice lifetime management features
    more than we are rather than open coding them so take a step towards that
    by moving some of the simplest deallocations to the dev_release() function.
    
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 89be8e287275..01a0a78368b8 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -3598,6 +3598,9 @@ static const struct attribute_group *regulator_dev_groups[] = {
 static void regulator_dev_release(struct device *dev)
 {
 	struct regulator_dev *rdev = dev_get_drvdata(dev);
+
+	kfree(rdev->constraints);
+	of_node_put(rdev->dev.of_node);
 	kfree(rdev);
 }
 
@@ -3829,9 +3832,7 @@ void regulator_unregister(struct regulator_dev *rdev)
 	unset_regulator_supplies(rdev);
 	list_del(&rdev->list);
 	mutex_unlock(&regulator_list_mutex);
-	kfree(rdev->constraints);
 	regulator_ena_gpio_free(rdev);
-	of_node_put(rdev->dev.of_node);
 	device_unregister(&rdev->dev);
 }
 EXPORT_SYMBOL_GPL(regulator_unregister);

commit 1768514eebfa888563049fa165449a1c1eba92d8
Author: Mark Brown <broonie@kernel.org>
Date:   Fri Aug 7 21:19:26 2015 +0100

    regulator: core: Reduce rdev locking region when releasing regulator
    
    When we release a regulator we need to remove references to it from the
    rdev which means locking the rdev.  Currently we also free resources
    associated with the regulator inside the rdev lock but there is no need
    to do this, we can reduce the region the lock is held by restricting it
    to just actions that affect the rdev.
    
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 62e4f3bd5783..89be8e287275 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1601,14 +1601,15 @@ static void _regulator_put(struct regulator *regulator)
 	if (regulator->dev)
 		sysfs_remove_link(&rdev->dev.kobj, regulator->supply_name);
 	mutex_lock(&rdev->mutex);
-	kfree(regulator->supply_name);
 	list_del(&regulator->list);
-	kfree(regulator);
 
 	rdev->open_count--;
 	rdev->exclusive = 0;
 	mutex_unlock(&rdev->mutex);
 
+	kfree(regulator->supply_name);
+	kfree(regulator);
+
 	module_put(rdev->owner);
 }
 

commit 7cd71c3ba166913a0afb8ac0d6bd5d2730fea6df
Author: Mark Brown <broonie@kernel.org>
Date:   Fri Aug 7 13:00:35 2015 +0100

    regulator: core: Drop regulator_list_mutex when we're done with it on remove
    
    When removing a regulator we hold regulator_list_mutex in order to
    ensure the regualtor doesn't become removed again.  However we only need
    to protect the list until we remove the regulator from the list so move
    the unlock earlier to reduce the locked region.
    
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 68b616580533..62e4f3bd5783 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -3827,11 +3827,11 @@ void regulator_unregister(struct regulator_dev *rdev)
 	WARN_ON(rdev->open_count);
 	unset_regulator_supplies(rdev);
 	list_del(&rdev->list);
+	mutex_unlock(&regulator_list_mutex);
 	kfree(rdev->constraints);
 	regulator_ena_gpio_free(rdev);
 	of_node_put(rdev->dev.of_node);
 	device_unregister(&rdev->dev);
-	mutex_unlock(&regulator_list_mutex);
 }
 EXPORT_SYMBOL_GPL(regulator_unregister);
 

commit 3a003baeec246f604ed1d2e0087560d7f15edcc6
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Fri Jul 17 14:41:54 2015 -0700

    regulator: Add over current protection (OCP) support
    
    Some regulators can automatically shut down when they detect an
    over current event. Add an op (set_over_current_protection) and a
    DT property + constraint to support this capability.
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index c9f72019bd68..520413e2bca0 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1081,6 +1081,15 @@ static int set_machine_constraints(struct regulator_dev *rdev,
 		}
 	}
 
+	if (rdev->constraints->over_current_protection
+		&& ops->set_over_current_protection) {
+		ret = ops->set_over_current_protection(rdev);
+		if (ret < 0) {
+			rdev_err(rdev, "failed to set over current protection\n");
+			goto out;
+		}
+	}
+
 	print_constraints(rdev);
 	return 0;
 out:

commit 4c7d83e8a8106d90d4eff971c8d070f718ac4f9c
Merge: 7055a3145402 322dfa6402ec 127e10624232 32c848e33ace 36a1f1b6ddc6
Author: Mark Brown <broonie@kernel.org>
Date:   Fri Jul 24 16:19:25 2015 +0100

    Merge remote-tracking branches 'regulator/fix/88pm800', 'regulator/fix/max8973', 'regulator/fix/s2mps11' and 'regulator/fix/supply' into regulator-linus

commit 36a1f1b6ddc6d1442424e29548e790633ca39c7b
Author: Javier Martinez Canillas <javier@osg.samsung.com>
Date:   Wed Jul 15 16:10:29 2015 +0200

    regulator: core: Fix memory leak in regulator_resolve_supply()
    
    The regulator_resolve_supply() function calls set_supply() which in turn
    calls create_regulator() to allocate a supply regulator.
    
    If an error occurs after set_supply() succeeded, the allocated regulator
    has to be freed before propagating the error code.
    
    Signed-off-by: Javier Martinez Canillas <javier@osg.samsung.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 934fde4faebe..80a123e8d0c3 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -109,6 +109,7 @@ static int _regulator_do_set_voltage(struct regulator_dev *rdev,
 static struct regulator *create_regulator(struct regulator_dev *rdev,
 					  struct device *dev,
 					  const char *supply_name);
+static void _regulator_put(struct regulator *regulator);
 
 static const char *rdev_get_name(struct regulator_dev *rdev)
 {
@@ -1401,8 +1402,11 @@ static int regulator_resolve_supply(struct regulator_dev *rdev)
 	/* Cascade always-on state to supply */
 	if (_regulator_is_enabled(rdev)) {
 		ret = regulator_enable(rdev->supply);
-		if (ret < 0)
+		if (ret < 0) {
+			if (rdev->supply)
+				_regulator_put(rdev->supply);
 			return ret;
+		}
 	}
 
 	return 0;

commit e2c09ae7a74d94222187edbe8f5cf1fa9364efcd
Author: Javier Martinez Canillas <javier@osg.samsung.com>
Date:   Wed Jul 15 16:10:28 2015 +0200

    regulator: core: Increase refcount for regulator supply's module
    
    When a regulator is unregistered with regulator_unregister(), a call to
    regulator_put() is made for its input supply if there is one. This does
    a module_put() to decrement the refcount of the module that owns the
    supply but there isn't a corresponding try_module_get() in set_supply()
    to make the calls balanced.
    
    Signed-off-by: Javier Martinez Canillas <javier@osg.samsung.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index c9f72019bd68..934fde4faebe 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1105,6 +1105,9 @@ static int set_supply(struct regulator_dev *rdev,
 
 	rdev_info(rdev, "supplied by %s\n", rdev_get_name(supply_rdev));
 
+	if (!try_module_get(supply_rdev->owner))
+		return -ENODEV;
+
 	rdev->supply = create_regulator(supply_rdev, &rdev->dev, "SUPPLY");
 	if (rdev->supply == NULL) {
 		err = -ENOMEM;

commit 9f7e25edb1575a6d2363dc003f9cc09d840657e2
Author: Mark Brown <broonie@kernel.org>
Date:   Tue Jul 14 11:17:26 2015 +0100

    regulator: core: Handle full constraints systems when resolving supplies
    
    When resolving device supplies if we fail to look up the regulator we
    substitute in the dummy supply instead if the system has fully specified
    constraints. When resolving supplies for regulators we do not have the
    equivalent code and instead just directly use the regulator_dev_lookup()
    result causing spurious failures.
    
    This does not affect DT systems since we are able to detect missing
    mappings directly as part of regulator_dev_lookup() and so have appropriate
    handling in the DT specific code.
    
    Reported-by: Christian Hartmann <cornogle@googlemail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index c9f72019bd68..bb8528dfad8c 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1381,9 +1381,13 @@ static int regulator_resolve_supply(struct regulator_dev *rdev)
 	}
 
 	if (!r) {
-		dev_err(dev, "Failed to resolve %s-supply for %s\n",
-			rdev->supply_name, rdev->desc->name);
-		return -EPROBE_DEFER;
+		if (have_full_constraints()) {
+			r = dummy_regulator_rdev;
+		} else {
+			dev_err(dev, "Failed to resolve %s-supply for %s\n",
+				rdev->supply_name, rdev->desc->name);
+			return -EPROBE_DEFER;
+		}
 	}
 
 	/* Recursively resolve the supply of the supply */

commit 70cfef26267474f94ff4a988fb45ff78442b1cf4
Author: Krzysztof Kozlowski <k.kozlowski@samsung.com>
Date:   Mon Jun 29 09:04:43 2015 +0900

    regulator: Add lockdep asserts to help detecting locking misuse
    
    Add lockdep_assert_held_once() to functions explicitly mentioning that
    rdev or regulator_list mutex must be held. Using WARN_ONCE shouldn't
    pollute the dmesg to much.
    
    The patch (if CONFIG_LOCKDEP enabled) will show warnings in certain
    regulators calling regulator_notifier_call_chain() without rdev->mutex
    held.
    
    Signed-off-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index c9f72019bd68..68b616580533 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -640,6 +640,8 @@ static int drms_uA_update(struct regulator_dev *rdev)
 	int current_uA = 0, output_uV, input_uV, err;
 	unsigned int mode;
 
+	lockdep_assert_held_once(&rdev->mutex);
+
 	/*
 	 * first check to see if we can set modes at all, otherwise just
 	 * tell the consumer everything is OK.
@@ -760,6 +762,8 @@ static int suspend_set_state(struct regulator_dev *rdev,
 /* locks held by caller */
 static int suspend_prepare(struct regulator_dev *rdev, suspend_state_t state)
 {
+	lockdep_assert_held_once(&rdev->mutex);
+
 	if (!rdev->constraints)
 		return -EINVAL;
 
@@ -1587,6 +1591,8 @@ static void _regulator_put(struct regulator *regulator)
 	if (regulator == NULL || IS_ERR(regulator))
 		return;
 
+	lockdep_assert_held_once(&regulator_list_mutex);
+
 	rdev = regulator->rdev;
 
 	debugfs_remove_recursive(regulator->debugfs);
@@ -1965,6 +1971,8 @@ static int _regulator_enable(struct regulator_dev *rdev)
 {
 	int ret;
 
+	lockdep_assert_held_once(&rdev->mutex);
+
 	/* check voltage and requested load before enabling */
 	if (rdev->constraints &&
 	    (rdev->constraints->valid_ops_mask & REGULATOR_CHANGE_DRMS))
@@ -2065,6 +2073,8 @@ static int _regulator_disable(struct regulator_dev *rdev)
 {
 	int ret = 0;
 
+	lockdep_assert_held_once(&rdev->mutex);
+
 	if (WARN(rdev->use_count <= 0,
 		 "unbalanced disables for %s\n", rdev_get_name(rdev)))
 		return -EIO;
@@ -2143,6 +2153,8 @@ static int _regulator_force_disable(struct regulator_dev *rdev)
 {
 	int ret = 0;
 
+	lockdep_assert_held_once(&rdev->mutex);
+
 	ret = _notifier_call_chain(rdev, REGULATOR_EVENT_FORCE_DISABLE |
 			REGULATOR_EVENT_PRE_DISABLE, NULL);
 	if (ret & NOTIFY_STOP_MASK)
@@ -3439,6 +3451,8 @@ EXPORT_SYMBOL_GPL(regulator_bulk_free);
 int regulator_notifier_call_chain(struct regulator_dev *rdev,
 				  unsigned long event, void *data)
 {
+	lockdep_assert_held_once(&rdev->mutex);
+
 	_notifier_call_chain(rdev, event, data);
 	return NOTIFY_DONE;
 

commit c16bcf03c8c29aaf68e281bfd2b8634f313a58d7
Merge: 4055da975de9 d87aef9164a5 126187dafd22 fda87a4283cf 9eac5fdfabc6 36e4f839de59
Author: Mark Brown <broonie@kernel.org>
Date:   Mon Jun 22 11:19:52 2015 +0100

    Merge remote-tracking branches 'regulator/topic/da9063', 'regulator/topic/doc', 'regulator/topic/fan53555', 'regulator/topic/gpio' and 'regulator/topic/ilim' into regulator-next

commit 36e4f839de59b6216a16cdf5c1d3263f4dbd9421
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Thu Jun 11 17:37:06 2015 -0700

    regulator: Add input current limit support
    
    Some regulators can limit their input current (typically annotated
    as ilim). Add an op (set_input_current_limit) and a DT property +
    constraint to support this.
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 6dfb2d6c19ae..ba565416d1d0 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1008,6 +1008,15 @@ static int set_machine_constraints(struct regulator_dev *rdev,
 	if (ret != 0)
 		goto out;
 
+	if (rdev->constraints->ilim_uA && ops->set_input_current_limit) {
+		ret = ops->set_input_current_limit(rdev,
+						   rdev->constraints->ilim_uA);
+		if (ret < 0) {
+			rdev_err(rdev, "failed to set input limit\n");
+			goto out;
+		}
+	}
+
 	/* do we need to setup our suspend state */
 	if (rdev->constraints->initial_state) {
 		ret = suspend_prepare(rdev, rdev->constraints->initial_state);

commit 57f66b78860968fc7eddc9ce25f8e57f7e5000bd
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Thu Jun 11 17:37:05 2015 -0700

    regulator: Add soft start support
    
    Some regulators support a "soft start" feature where the voltage
    ramps up slowly when the regulator is enabled. Add an op
    (set_soft_start) and a DT property + constraint to support this.
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 60fcfba52592..6dfb2d6c19ae 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1059,6 +1059,14 @@ static int set_machine_constraints(struct regulator_dev *rdev,
 		}
 	}
 
+	if (rdev->constraints->soft_start && ops->set_soft_start) {
+		ret = ops->set_soft_start(rdev);
+		if (ret < 0) {
+			rdev_err(rdev, "failed to set soft start\n");
+			goto out;
+		}
+	}
+
 	print_constraints(rdev);
 	return 0;
 out:

commit 23c779b9f9161d6568d3b2fca06e70ad182c480c
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Thu Jun 11 17:37:04 2015 -0700

    regulator: Add pull down support
    
    Some regulators need to be configured to pull down a resistor
    when the regulator is disabled. Add an op (set_pull_down) and a
    DT property + constraint to support this.
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index c8d5e2b05fdf..60fcfba52592 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1051,6 +1051,14 @@ static int set_machine_constraints(struct regulator_dev *rdev,
 		}
 	}
 
+	if (rdev->constraints->pull_down && ops->set_pull_down) {
+		ret = ops->set_pull_down(rdev);
+		if (ret < 0) {
+			rdev_err(rdev, "failed to set pull down\n");
+			goto out;
+		}
+	}
+
 	print_constraints(rdev);
 	return 0;
 out:

commit 22a10bca280073f81e9e2d9fed6f90a3bcf00236
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Thu Jun 11 17:37:03 2015 -0700

    regulator: Add system_load constraint
    
    Some regulators have a fixed load that isn't captured by
    consumers that the kernel knows about. Add a constraint to
    support this.
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 443eaab933fc..c8d5e2b05fdf 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -678,6 +678,8 @@ static int drms_uA_update(struct regulator_dev *rdev)
 	list_for_each_entry(sibling, &rdev->consumer_list, list)
 		current_uA += sibling->uA_load;
 
+	current_uA += rdev->constraints->system_load;
+
 	if (rdev->desc->ops->set_load) {
 		/* set the optimum mode for our new total regulator load */
 		err = rdev->desc->ops->set_load(rdev, current_uA);

commit 5751a99fe971262f3701922d116bcde7e9045b17
Author: Stefan Wahren <stefan.wahren@i2se.com>
Date:   Wed Jun 10 06:13:15 2015 +0000

    regulator: core: replace sprintf with scnprintf
    
    In order to avoid potential overflows in print_constraints we
    better replace sprintf() with scnprintf().
    
    Signed-off-by: Stefan Wahren <stefan.wahren@i2se.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 6b9edb525d74..9da5c5559147 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -780,58 +780,63 @@ static void print_constraints(struct regulator_dev *rdev)
 {
 	struct regulation_constraints *constraints = rdev->constraints;
 	char buf[160] = "";
+	size_t len = sizeof(buf) - 1;
 	int count = 0;
 	int ret;
 
 	if (constraints->min_uV && constraints->max_uV) {
 		if (constraints->min_uV == constraints->max_uV)
-			count += sprintf(buf + count, "%d mV ",
-					 constraints->min_uV / 1000);
+			count += scnprintf(buf + count, len - count, "%d mV ",
+					   constraints->min_uV / 1000);
 		else
-			count += sprintf(buf + count, "%d <--> %d mV ",
-					 constraints->min_uV / 1000,
-					 constraints->max_uV / 1000);
+			count += scnprintf(buf + count, len - count,
+					   "%d <--> %d mV ",
+					   constraints->min_uV / 1000,
+					   constraints->max_uV / 1000);
 	}
 
 	if (!constraints->min_uV ||
 	    constraints->min_uV != constraints->max_uV) {
 		ret = _regulator_get_voltage(rdev);
 		if (ret > 0)
-			count += sprintf(buf + count, "at %d mV ", ret / 1000);
+			count += scnprintf(buf + count, len - count,
+					   "at %d mV ", ret / 1000);
 	}
 
 	if (constraints->uV_offset)
-		count += sprintf(buf + count, "%dmV offset ",
-				 constraints->uV_offset / 1000);
+		count += scnprintf(buf + count, len - count, "%dmV offset ",
+				   constraints->uV_offset / 1000);
 
 	if (constraints->min_uA && constraints->max_uA) {
 		if (constraints->min_uA == constraints->max_uA)
-			count += sprintf(buf + count, "%d mA ",
-					 constraints->min_uA / 1000);
+			count += scnprintf(buf + count, len - count, "%d mA ",
+					   constraints->min_uA / 1000);
 		else
-			count += sprintf(buf + count, "%d <--> %d mA ",
-					 constraints->min_uA / 1000,
-					 constraints->max_uA / 1000);
+			count += scnprintf(buf + count, len - count,
+					   "%d <--> %d mA ",
+					   constraints->min_uA / 1000,
+					   constraints->max_uA / 1000);
 	}
 
 	if (!constraints->min_uA ||
 	    constraints->min_uA != constraints->max_uA) {
 		ret = _regulator_get_current_limit(rdev);
 		if (ret > 0)
-			count += sprintf(buf + count, "at %d mA ", ret / 1000);
+			count += scnprintf(buf + count, len - count,
+					   "at %d mA ", ret / 1000);
 	}
 
 	if (constraints->valid_modes_mask & REGULATOR_MODE_FAST)
-		count += sprintf(buf + count, "fast ");
+		count += scnprintf(buf + count, len - count, "fast ");
 	if (constraints->valid_modes_mask & REGULATOR_MODE_NORMAL)
-		count += sprintf(buf + count, "normal ");
+		count += scnprintf(buf + count, len - count, "normal ");
 	if (constraints->valid_modes_mask & REGULATOR_MODE_IDLE)
-		count += sprintf(buf + count, "idle ");
+		count += scnprintf(buf + count, len - count, "idle ");
 	if (constraints->valid_modes_mask & REGULATOR_MODE_STANDBY)
-		count += sprintf(buf + count, "standby");
+		count += scnprintf(buf + count, len - count, "standby");
 
 	if (!count)
-		sprintf(buf, "no parameters");
+		scnprintf(buf, len, "no parameters");
 
 	rdev_dbg(rdev, "%s\n", buf);
 

commit 96dc589624954fea915c1cee90e0987ff9631386
Merge: ff268b56ce8c a7068e3932ee
Author: Mark Brown <broonie@kernel.org>
Date:   Wed Jun 10 11:09:28 2015 +0100

    Merge branch 'fix/core' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/regulator into regulator-core

commit a7068e3932eee8268c4ce4e080a338ee7b8a27bf
Author: Stefan Wahren <stefan.wahren@i2se.com>
Date:   Tue Jun 9 20:09:42 2015 +0000

    regulator: core: fix constraints output buffer
    
    The buffer for condtraints debug isn't big enough to hold the output
    in all cases. So fix this issue by increasing the buffer.
    
    Signed-off-by: Stefan Wahren <stefan.wahren@i2se.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Cc: <stable@vger.kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 9afa3af78b6a..53ed2d46071e 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -779,7 +779,7 @@ static int suspend_prepare(struct regulator_dev *rdev, suspend_state_t state)
 static void print_constraints(struct regulator_dev *rdev)
 {
 	struct regulation_constraints *constraints = rdev->constraints;
-	char buf[80] = "";
+	char buf[160] = "";
 	int count = 0;
 	int ret;
 

commit c456b89a93664d6ff0aba1ced9dd88b88df2505a
Author: Mark Brown <broonie@kernel.org>
Date:   Tue Jun 9 19:54:10 2015 +0100

    regulator: core: Don't corrupt display when printing uV offsets
    
    We weren't taking into account the already used buffer when telling
    sprintf() where to print to.
    
    Reported-by: Stefan Wahren <stefan.wahren@i2se.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 443eaab933fc..9afa3af78b6a 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -801,7 +801,7 @@ static void print_constraints(struct regulator_dev *rdev)
 	}
 
 	if (constraints->uV_offset)
-		count += sprintf(buf, "%dmV offset ",
+		count += sprintf(buf + count, "%dmV offset ",
 				 constraints->uV_offset / 1000);
 
 	if (constraints->min_uA && constraints->max_uA) {

commit ff268b56ce8c86be920e1e6a15d68b168bed66c9
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Mon Jun 1 18:47:54 2015 -0700

    regulator: core: Don't spew backtraces on duplicate sysfs
    
    We don't consider a failure to add the sysfs node as a problem,
    so use sysfs_create_link_nowarn() so that we don't print a
    backtrace when duplicated files exist. Also, downgrade the printk
    message to a debug statement so that we're quiet here. This
    allows multiple drivers to request a CPU's regulator so that
    CPUfreq and AVSish drivers can coexist.
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 443eaab933fc..f6989485c382 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1192,10 +1192,10 @@ static struct regulator *create_regulator(struct regulator_dev *rdev,
 		if (regulator->supply_name == NULL)
 			goto overflow_err;
 
-		err = sysfs_create_link(&rdev->dev.kobj, &dev->kobj,
+		err = sysfs_create_link_nowarn(&rdev->dev.kobj, &dev->kobj,
 					buf);
 		if (err) {
-			rdev_warn(rdev, "could not add device link %s err %d\n",
+			rdev_dbg(rdev, "could not add device link %s err %d\n",
 				  dev->kobj.name, err);
 			/* non-fatal */
 		}

commit bea3672833dac06e37651e755d24ffdb0c471907
Merge: 3984c9da458d 7e476c7dd8d3 046db763aaae e999c7289cf2 ce8ae17c5d86 14aef2919d06
Author: Mark Brown <broonie@kernel.org>
Date:   Fri Apr 10 19:16:03 2015 +0100

    Merge remote-tracking branches 'regulator/topic/mode', 'regulator/topic/notifier', 'regulator/topic/palmas', 'regulator/topic/qcom' and 'regulator/topic/stw481x' into regulator-next

commit 3984c9da458dbdc352a82909a51c42cf2860a4a5
Merge: e5073849f9d7 af78114ec757 2b85c28a5a7c eb2d90c05828 c0cf5a59fb69
Author: Mark Brown <broonie@kernel.org>
Date:   Fri Apr 10 19:16:02 2015 +0100

    Merge remote-tracking branches 'regulator/topic/dbx500', 'regulator/topic/load-op', 'regulator/topic/max77693' and 'regulator/topic/max8660' into regulator-next

commit 5fc31b43d59a983c47c37b7a6d327f83395609ed
Merge: f22e6e847115 498e530e50ff
Author: Mark Brown <broonie@kernel.org>
Date:   Fri Apr 10 19:15:59 2015 +0100

    Merge remote-tracking branch 'regulator/topic/core' into regulator-next

commit 498e530e50ffccb979cf5f2f2e5bbce01afe1b6e
Merge: 6261b06de565 23296099e708
Author: Mark Brown <broonie@kernel.org>
Date:   Fri Apr 10 19:05:21 2015 +0100

    Merge branch 'topic/debugfs' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/regulator into regulator-core

commit 23296099e70854a272fc369bab8ddcc57f27f97a
Author: Heiko Stübner <heiko@sntech.de>
Date:   Fri Apr 10 13:48:41 2015 +0200

    regulator: output current-limit for all regulators in summary
    
    Voltage regulators can have (unregulated) current limits too, so we should
    probably output both voltage and current for all regulators.
    
    Holding the rdev->mutex actually conflicts with _regulator_get_current_limit
    but also is not really necessary, as the global regulator_list_mutex already
    protects us from the regulator vanishing while we go through the list.
    
    On the rk3288-firefly the summary now looks like:
    
     regulator                      use open bypass voltage current     min     max
    -------------------------------------------------------------------------------
     vcc_sys                          0   12      0  5000mV     0mA  5000mV  5000mV
        vcc_lan                       1    1      0  3300mV     0mA  3300mV  3300mV
           ff290000.ethernet                                            0mV     0mV
        vcca_33                       0    0      0  3300mV     0mA  3300mV  3300mV
        vcca_18                       0    0      0  1800mV     0mA  1800mV  1800mV
        vdd10_lcd                     0    0      0  1000mV     0mA  1000mV  1000mV
     [...]
    
    Suggested-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Heiko Stuebner <heiko@sntech.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 5aae1bd61151..0ea0a019dc57 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -3967,23 +3967,13 @@ static void regulator_summary_show_subtree(struct seq_file *s,
 	if (!rdev)
 		return;
 
-	mutex_lock(&rdev->mutex);
-
 	seq_printf(s, "%*s%-*s %3d %4d %6d ",
 		   level * 3 + 1, "",
 		   30 - level * 3, rdev_get_name(rdev),
 		   rdev->use_count, rdev->open_count, rdev->bypass_count);
 
-	switch (rdev->desc->type) {
-	case REGULATOR_VOLTAGE:
-		seq_printf(s, "%5dmV ",
-			   _regulator_get_voltage(rdev) / 1000);
-		break;
-	case REGULATOR_CURRENT:
-		seq_printf(s, "%5dmA ",
-			   _regulator_get_current_limit(rdev) / 1000);
-		break;
-	}
+	seq_printf(s, "%5dmV ", _regulator_get_voltage(rdev) / 1000);
+	seq_printf(s, "%5dmA ", _regulator_get_current_limit(rdev) / 1000);
 
 	c = rdev->constraints;
 	if (c) {
@@ -4011,21 +4001,17 @@ static void regulator_summary_show_subtree(struct seq_file *s,
 
 		switch (rdev->desc->type) {
 		case REGULATOR_VOLTAGE:
-			seq_printf(s, "%29dmV %5dmV",
+			seq_printf(s, "%37dmV %5dmV",
 				   consumer->min_uV / 1000,
 				   consumer->max_uV / 1000);
 			break;
 		case REGULATOR_CURRENT:
-			seq_printf(s, "%37dmA",
-				regulator_get_current_limit(consumer) / 1000);
 			break;
 		}
 
 		seq_puts(s, "\n");
 	}
 
-	mutex_unlock(&rdev->mutex);
-
 	list_for_each_entry(child, list, list) {
 		/* handle only non-root regulators supplied by current rdev */
 		if (!child->supply || child->supply->rdev != rdev)
@@ -4040,8 +4026,8 @@ static int regulator_summary_show(struct seq_file *s, void *data)
 	struct list_head *list = s->private;
 	struct regulator_dev *rdev;
 
-	seq_puts(s, " regulator                      use open bypass   value     min     max\n");
-	seq_puts(s, "-----------------------------------------------------------------------\n");
+	seq_puts(s, " regulator                      use open bypass voltage current     min     max\n");
+	seq_puts(s, "-------------------------------------------------------------------------------\n");
 
 	mutex_lock(&regulator_list_mutex);
 

commit 7c225ec90c368a474daa9803922f4b7d6fe6d5c8
Author: Heiko Stübner <heiko@sntech.de>
Date:   Tue Apr 7 16:16:39 2015 +0200

    regulator: add a summary tree in debugfs
    
    On modern systems the regulator hierarchy can get quite long and nested
    with regulators supplying other regulators. In some cases when debugging
    it might be nice to get a tree of these regulators, their consumers
    and the regulation constraints in one go.
    
    To achieve this add a regulator_summary sysfs node, similar to
    clk_summary in the common clock framework, that walks the regulator
    list and creates a tree out of the regulators, their consumers and
    core per-regulator settings.
    
    On a rk3288-firefly the regulator_summary would for example look
    something like:
    
     regulator                      use open bypass   value     min     max
    -----------------------------------------------------------------------
     vcc_sys                          0   12      0  5000mV  5000mV  5000mV
        vcc_lan                       1    1      0  3300mV  3300mV  3300mV
           ff290000.ethernet                                    0mV     0mV
        vcca_33                       0    0      0  3300mV  3300mV  3300mV
        vcca_18                       0    0      0  1800mV  1800mV  1800mV
        vdd10_lcd                     0    0      0  1000mV  1000mV  1000mV
        vccio_sd                      0    0      0  3300mV  3300mV  3300mV
        vcc_20                        0    3      0  2000mV  2000mV  2000mV
           vcc18_lcd                  0    0      0  1800mV  1800mV  1800mV
           vcc_18                     0    2      0  1800mV  1800mV  1800mV
              ff100000.saradc                                   0mV     0mV
              ff0d0000.dwmmc                                 1650mV  1950mV
           vdd_10                     0    0      0  1000mV  1000mV  1000mV
        vdd_log                       0    0      0  1100mV  1100mV  1100mV
        vcc_io                        0    3      0  3300mV  3300mV  3300mV
           ff0f0000.dwmmc                                    3300mV  3400mV
           vcc_flash                  1    1      0  1800mV  1800mV  1800mV
              ff0f0000.dwmmc                                 1700mV  1950mV
           vcc_sd                     1    1      0  3300mV  3300mV  3300mV
              ff0c0000.dwmmc                                 3300mV  3400mV
        vcc_ddr                       0    0      0  1200mV  1200mV  1200mV
        vdd_gpu                       0    0      0  1000mV   850mV  1350mV
        vdd_cpu                       0    1      0   900mV   850mV  1350mV
           cpu0                                               900mV   900mV
        vcc_5v                        0    2      0  5000mV  5000mV  5000mV
           vcc_otg_5v                 0    0      0  5000mV  5000mV  5000mV
           vcc_host_5v                0    0      0  5000mV  5000mV  5000mV
     regulator-dummy                  0    0      0     0mV     0mV     0mV
    
    Signed-off-by: Heiko Stuebner <heiko@sntech.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index cc242aa368ef..5aae1bd61151 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -3954,6 +3954,124 @@ static const struct file_operations supply_map_fops = {
 #endif
 };
 
+#ifdef CONFIG_DEBUG_FS
+static void regulator_summary_show_subtree(struct seq_file *s,
+					   struct regulator_dev *rdev,
+					   int level)
+{
+	struct list_head *list = s->private;
+	struct regulator_dev *child;
+	struct regulation_constraints *c;
+	struct regulator *consumer;
+
+	if (!rdev)
+		return;
+
+	mutex_lock(&rdev->mutex);
+
+	seq_printf(s, "%*s%-*s %3d %4d %6d ",
+		   level * 3 + 1, "",
+		   30 - level * 3, rdev_get_name(rdev),
+		   rdev->use_count, rdev->open_count, rdev->bypass_count);
+
+	switch (rdev->desc->type) {
+	case REGULATOR_VOLTAGE:
+		seq_printf(s, "%5dmV ",
+			   _regulator_get_voltage(rdev) / 1000);
+		break;
+	case REGULATOR_CURRENT:
+		seq_printf(s, "%5dmA ",
+			   _regulator_get_current_limit(rdev) / 1000);
+		break;
+	}
+
+	c = rdev->constraints;
+	if (c) {
+		switch (rdev->desc->type) {
+		case REGULATOR_VOLTAGE:
+			seq_printf(s, "%5dmV %5dmV ",
+				   c->min_uV / 1000, c->max_uV / 1000);
+			break;
+		case REGULATOR_CURRENT:
+			seq_printf(s, "%5dmA %5dmA ",
+				   c->min_uA / 1000, c->max_uA / 1000);
+			break;
+		}
+	}
+
+	seq_puts(s, "\n");
+
+	list_for_each_entry(consumer, &rdev->consumer_list, list) {
+		if (consumer->dev->class == &regulator_class)
+			continue;
+
+		seq_printf(s, "%*s%-*s ",
+			   (level + 1) * 3 + 1, "",
+			   30 - (level + 1) * 3, dev_name(consumer->dev));
+
+		switch (rdev->desc->type) {
+		case REGULATOR_VOLTAGE:
+			seq_printf(s, "%29dmV %5dmV",
+				   consumer->min_uV / 1000,
+				   consumer->max_uV / 1000);
+			break;
+		case REGULATOR_CURRENT:
+			seq_printf(s, "%37dmA",
+				regulator_get_current_limit(consumer) / 1000);
+			break;
+		}
+
+		seq_puts(s, "\n");
+	}
+
+	mutex_unlock(&rdev->mutex);
+
+	list_for_each_entry(child, list, list) {
+		/* handle only non-root regulators supplied by current rdev */
+		if (!child->supply || child->supply->rdev != rdev)
+			continue;
+
+		regulator_summary_show_subtree(s, child, level + 1);
+	}
+}
+
+static int regulator_summary_show(struct seq_file *s, void *data)
+{
+	struct list_head *list = s->private;
+	struct regulator_dev *rdev;
+
+	seq_puts(s, " regulator                      use open bypass   value     min     max\n");
+	seq_puts(s, "-----------------------------------------------------------------------\n");
+
+	mutex_lock(&regulator_list_mutex);
+
+	list_for_each_entry(rdev, list, list) {
+		if (rdev->supply)
+			continue;
+
+		regulator_summary_show_subtree(s, rdev, 0);
+	}
+
+	mutex_unlock(&regulator_list_mutex);
+
+	return 0;
+}
+
+static int regulator_summary_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, regulator_summary_show, inode->i_private);
+}
+#endif
+
+static const struct file_operations regulator_summary_fops = {
+#ifdef CONFIG_DEBUG_FS
+	.open		= regulator_summary_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+#endif
+};
+
 static int __init regulator_init(void)
 {
 	int ret;
@@ -3967,6 +4085,9 @@ static int __init regulator_init(void)
 	debugfs_create_file("supply_map", 0444, debugfs_root, NULL,
 			    &supply_map_fops);
 
+	debugfs_create_file("regulator_summary", 0444, debugfs_root,
+			    &regulator_list, &regulator_summary_fops);
+
 	regulator_dummy_init();
 
 	return ret;

commit 6261b06de565baafa590e58a531a1a5522cea0b6
Author: Bjorn Andersson <bjorn.andersson@sonymobile.com>
Date:   Tue Mar 24 18:56:05 2015 -0700

    regulator: Defer lookup of supply to regulator_get
    
    Instead of resolving regulator supplies during registration move this to
    the time of a consumer retrieving a handle. The benefit is that it's
    possible for one driver to register regulators with internal
    dependencies out of order.
    
    Signed-off-by: Bjorn Andersson <bjorn.andersson@sonymobile.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index b899947d839d..a291a6b9cd44 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1316,6 +1316,54 @@ static struct regulator_dev *regulator_dev_lookup(struct device *dev,
 	return NULL;
 }
 
+static int regulator_resolve_supply(struct regulator_dev *rdev)
+{
+	struct regulator_dev *r;
+	struct device *dev = rdev->dev.parent;
+	int ret;
+
+	/* No supply to resovle? */
+	if (!rdev->supply_name)
+		return 0;
+
+	/* Supply already resolved? */
+	if (rdev->supply)
+		return 0;
+
+	r = regulator_dev_lookup(dev, rdev->supply_name, &ret);
+	if (ret == -ENODEV) {
+		/*
+		 * No supply was specified for this regulator and
+		 * there will never be one.
+		 */
+		return 0;
+	}
+
+	if (!r) {
+		dev_err(dev, "Failed to resolve %s-supply for %s\n",
+			rdev->supply_name, rdev->desc->name);
+		return -EPROBE_DEFER;
+	}
+
+	/* Recursively resolve the supply of the supply */
+	ret = regulator_resolve_supply(r);
+	if (ret < 0)
+		return ret;
+
+	ret = set_supply(rdev, r);
+	if (ret < 0)
+		return ret;
+
+	/* Cascade always-on state to supply */
+	if (_regulator_is_enabled(rdev)) {
+		ret = regulator_enable(rdev->supply);
+		if (ret < 0)
+			return ret;
+	}
+
+	return 0;
+}
+
 /* Internal regulator request function */
 static struct regulator *_regulator_get(struct device *dev, const char *id,
 					bool exclusive, bool allow_dummy)
@@ -1385,6 +1433,12 @@ static struct regulator *_regulator_get(struct device *dev, const char *id,
 		goto out;
 	}
 
+	ret = regulator_resolve_supply(rdev);
+	if (ret < 0) {
+		regulator = ERR_PTR(ret);
+		goto out;
+	}
+
 	if (!try_module_get(rdev->owner))
 		goto out;
 
@@ -3536,7 +3590,6 @@ regulator_register(const struct regulator_desc *regulator_desc,
 	struct regulator_dev *rdev;
 	struct device *dev;
 	int ret, i;
-	const char *supply = NULL;
 
 	if (regulator_desc == NULL || cfg == NULL)
 		return ERR_PTR(-EINVAL);
@@ -3650,41 +3703,10 @@ regulator_register(const struct regulator_desc *regulator_desc,
 		goto scrub;
 
 	if (init_data && init_data->supply_regulator)
-		supply = init_data->supply_regulator;
+		rdev->supply_name = init_data->supply_regulator;
 	else if (regulator_desc->supply_name)
-		supply = regulator_desc->supply_name;
-
-	if (supply) {
-		struct regulator_dev *r;
-
-		r = regulator_dev_lookup(dev, supply, &ret);
+		rdev->supply_name = regulator_desc->supply_name;
 
-		if (ret == -ENODEV) {
-			/*
-			 * No supply was specified for this regulator and
-			 * there will never be one.
-			 */
-			ret = 0;
-			goto add_dev;
-		} else if (!r) {
-			dev_err(dev, "Failed to find supply %s\n", supply);
-			ret = -EPROBE_DEFER;
-			goto scrub;
-		}
-
-		ret = set_supply(rdev, r);
-		if (ret < 0)
-			goto scrub;
-
-		/* Enable supply if rail is enabled */
-		if (_regulator_is_enabled(rdev)) {
-			ret = regulator_enable(rdev->supply);
-			if (ret < 0)
-				goto scrub;
-		}
-	}
-
-add_dev:
 	/* add consumers devices */
 	if (init_data) {
 		for (i = 0; i < init_data->num_consumer_supplies; i++) {
@@ -3711,8 +3733,6 @@ regulator_register(const struct regulator_desc *regulator_desc,
 	unset_regulator_supplies(rdev);
 
 scrub:
-	if (rdev->supply)
-		_regulator_put(rdev->supply);
 	regulator_ena_gpio_free(rdev);
 	kfree(rdev->constraints);
 wash:

commit a9eaa8130707d4013fb109b80323489c0d0111ac
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Fri Oct 17 08:17:03 2014 -0700

    regulator: Ensure unique regulator debugfs directory names
    
    If multiple regulator devices of the same type exist in a system,
    the regulator driver assigns generic names for the regulators it
    provides, and debugfs is enabled, the regulator subsystem attempts
    to create multiple entries with the same name in the regulator debugfs
    directory. This fails for all but the first regulator, resulting in
    multiple "Failed to create debugfs directory" log entries.
    
    To avoid the problem, prepend the debugfs directory name for a regulator
    with its parent device name if available, but only if no explicit
    regulator name was provided.
    
    Cc: Alan Tull <atull@opensource.altera.com>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index b899947d839d..cc242aa368ef 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -3502,7 +3502,18 @@ static struct class regulator_class = {
 
 static void rdev_init_debugfs(struct regulator_dev *rdev)
 {
-	rdev->debugfs = debugfs_create_dir(rdev_get_name(rdev), debugfs_root);
+	struct device *parent = rdev->dev.parent;
+	const char *rname = rdev_get_name(rdev);
+	char name[NAME_MAX];
+
+	/* Avoid duplicate debugfs directory names */
+	if (parent && rname == rdev->desc->name) {
+		snprintf(name, sizeof(name), "%s-%s", dev_name(parent),
+			 rname);
+		rname = name;
+	}
+
+	rdev->debugfs = debugfs_create_dir(rname, debugfs_root);
 	if (!rdev->debugfs) {
 		rdev_warn(rdev, "Failed to create debugfs directory\n");
 		return;

commit 8ca8f32666d2a655e274836400e1a7f7fa313502
Merge: 06e5801b8cb3 29d62ec5f87f d16da513c9c8
Author: Mark Brown <broonie@kernel.org>
Date:   Mon Mar 16 11:43:24 2015 +0000

    Merge remote-tracking branches 'regulator/fix/gpio-enable' and 'regulator/fix/tps65910' into regulator-linus

commit e39ce48f5362df9f87400b4909a6fb0f51b109ac
Author: Bjorn Andersson <bjorn.andersson@sonymobile.com>
Date:   Wed Feb 11 19:35:27 2015 -0800

    regulator: Rename regulator_set_optimum_mode
    
    Rename the regulator_set_optimum_mode() function regulator_set_load() to
    better represent what's going on.
    
    Signed-off-by: Bjorn Andersson <bjorn.andersson@sonymobile.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index b899947d839d..03088f9c3d4f 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2994,7 +2994,7 @@ unsigned int regulator_get_mode(struct regulator *regulator)
 EXPORT_SYMBOL_GPL(regulator_get_mode);
 
 /**
- * regulator_set_optimum_mode - set regulator optimum operating mode
+ * regulator_set_load - set regulator load
  * @regulator: regulator source
  * @uA_load: load current
  *
@@ -3017,9 +3017,9 @@ EXPORT_SYMBOL_GPL(regulator_get_mode);
  * DRMS will sum the total requested load on the regulator and change
  * to the most efficient operating mode if platform constraints allow.
  *
- * Returns the new regulator mode or error.
+ * On error a negative errno is returned.
  */
-int regulator_set_optimum_mode(struct regulator *regulator, int uA_load)
+int regulator_set_load(struct regulator *regulator, int uA_load)
 {
 	struct regulator_dev *rdev = regulator->rdev;
 	int ret;
@@ -3031,7 +3031,7 @@ int regulator_set_optimum_mode(struct regulator *regulator, int uA_load)
 
 	return ret;
 }
-EXPORT_SYMBOL_GPL(regulator_set_optimum_mode);
+EXPORT_SYMBOL_GPL(regulator_set_load);
 
 /**
  * regulator_allow_bypass - allow the regulator to go into bypass mode

commit 29d62ec5f87fbeec8413e2215ddad12e7f972e4c
Author: Doug Anderson <dianders@chromium.org>
Date:   Tue Mar 3 15:20:47 2015 -0800

    regulator: core: Fix enable GPIO reference counting
    
    Normally _regulator_do_enable() isn't called on an already-enabled
    rdev.  That's because the main caller, _regulator_enable() always
    calls _regulator_is_enabled() and only calls _regulator_do_enable() if
    the rdev was not already enabled.
    
    However, there is one caller of _regulator_do_enable() that doesn't
    check: regulator_suspend_finish().  While we might want to make
    regulator_suspend_finish() behave more like _regulator_enable(), it's
    probably also a good idea to make _regulator_do_enable() robust if it
    is called on an already enabled rdev.
    
    At the moment, _regulator_do_enable() is _not_ robust for already
    enabled rdevs if we're using an ena_pin.  Each time
    _regulator_do_enable() is called for an rdev using an ena_pin the
    reference count of the ena_pin is incremented even if the rdev was
    already enabled.  This is not as intended because the ena_pin is for
    something else: for keeping track of how many active rdevs there are
    sharing the same ena_pin.
    
    Here's how the reference counting works here:
    
    * Each time _regulator_enable() is called we increment
      rdev->use_count, so _regulator_enable() calls need to be balanced
      with _regulator_disable() calls.
    
    * There is no explicit reference counting in _regulator_do_enable()
      which is normally just a warapper around rdev->desc->ops->enable()
      with code for supporting delays.  It's not expected that the
      "ops->enable()" call do reference counting.
    
    * Since regulator_ena_gpio_ctrl() does have reference counting
      (handling the sharing of the pin amongst multiple rdevs), we
      shouldn't call it if the current rdev is already enabled.
    
    Note that as part of this we cleanup (remove) the initting of
    ena_gpio_state in regulator_register().  In _regulator_do_enable(),
    _regulator_do_disable() and _regulator_is_enabled() is is clear that
    ena_gpio_state should be the state of whether this particular rdev has
    requested the GPIO be enabled.  regulator_register() was initting it
    as the actual state of the pin.
    
    Fixes: 967cfb18c0e3 ("regulator: core: manage enable GPIO list")
    Signed-off-by: Doug Anderson <dianders@chromium.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Cc: stable@vger.kernel.org

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 0e271e57504a..fafeb32427c1 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1839,10 +1839,12 @@ static int _regulator_do_enable(struct regulator_dev *rdev)
 	}
 
 	if (rdev->ena_pin) {
-		ret = regulator_ena_gpio_ctrl(rdev, true);
-		if (ret < 0)
-			return ret;
-		rdev->ena_gpio_state = 1;
+		if (!rdev->ena_gpio_state) {
+			ret = regulator_ena_gpio_ctrl(rdev, true);
+			if (ret < 0)
+				return ret;
+			rdev->ena_gpio_state = 1;
+		}
 	} else if (rdev->desc->ops->enable) {
 		ret = rdev->desc->ops->enable(rdev);
 		if (ret < 0)
@@ -1939,10 +1941,12 @@ static int _regulator_do_disable(struct regulator_dev *rdev)
 	trace_regulator_disable(rdev_get_name(rdev));
 
 	if (rdev->ena_pin) {
-		ret = regulator_ena_gpio_ctrl(rdev, false);
-		if (ret < 0)
-			return ret;
-		rdev->ena_gpio_state = 0;
+		if (rdev->ena_gpio_state) {
+			ret = regulator_ena_gpio_ctrl(rdev, false);
+			if (ret < 0)
+				return ret;
+			rdev->ena_gpio_state = 0;
+		}
 
 	} else if (rdev->desc->ops->disable) {
 		ret = rdev->desc->ops->disable(rdev);
@@ -3633,12 +3637,6 @@ regulator_register(const struct regulator_desc *regulator_desc,
 				 config->ena_gpio, ret);
 			goto wash;
 		}
-
-		if (config->ena_gpio_flags & GPIOF_OUT_INIT_HIGH)
-			rdev->ena_gpio_state = 1;
-
-		if (config->ena_gpio_invert)
-			rdev->ena_gpio_state = !rdev->ena_gpio_state;
 	}
 
 	/* set regulator constraints */

commit 0548bf4f5ad6fc3bd93c4940fa48078b34609682
Author: Javier Martinez Canillas <javier.martinez@collabora.co.uk>
Date:   Mon Mar 2 21:40:39 2015 +0100

    regulator: Only enable disabled regulators on resume
    
    The _regulator_do_enable() call ought to be a no-op when called on an
    already-enabled regulator.  However, as an optimization
    _regulator_enable() doesn't call _regulator_do_enable() on an already
    enabled regulator.  That means we never test the case of calling
    _regulator_do_enable() during normal usage and there may be hidden
    bugs or warnings.  We have seen warnings issued by the tps65090 driver
    and bugs when using the GPIO enable pin.
    
    Let's match the same optimization that _regulator_enable() in
    regulator_suspend_finish().  That may speed up suspend/resume and also
    avoids exposing hidden bugs.
    
    [Use much clearer commit message from Doug Anderson]
    
    Signed-off-by: Javier Martinez Canillas <javier.martinez@collabora.co.uk>
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Cc: stable@vger.kernel.org

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index b899947d839d..0e271e57504a 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -3807,9 +3807,11 @@ int regulator_suspend_finish(void)
 	list_for_each_entry(rdev, &regulator_list, list) {
 		mutex_lock(&rdev->mutex);
 		if (rdev->use_count > 0  || rdev->constraints->always_on) {
-			error = _regulator_do_enable(rdev);
-			if (error)
-				ret = error;
+			if (!_regulator_is_enabled(rdev)) {
+				error = _regulator_do_enable(rdev);
+				if (error)
+					ret = error;
+			}
 		} else {
 			if (!have_full_constraints())
 				goto unlock;

commit cde72ccfdd5920abb0413d16240c1551de3bd13a
Author: Takashi Iwai <tiwai@suse.de>
Date:   Tue Mar 3 14:28:51 2015 +0100

    regulator: Fix regression due to NULL constraints check
    
    The commit [39f802d6b6d9: 'regulator: Build sysfs entries with static
    attribute groups'] converted the sysfs entry creation to static
    attribute groups, but this resulted in a regression due to the NULL
    check of rdev->constraints.  At the point where the device is
    registered, rdev->constraints isn't set, so the attributes depending
    on it are missing.
    
    We may fix it by shuffling the code order in regulator_register(), but
    a quicker fix is to just remove this NULL check.  rdev->constraints is
    in anyway always set to non-NULL in set_machine_constraints(), thus
    the check there is basically superfluous.
    
    Fixes: 39f802d6b6d9 ('regulator: Build sysfs entries with static attribute groups')
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Reportded-by: Steve Twiss <stwiss.opensource@diasemi.com>
    Tested-by: Steve Twiss <stwiss.opensource@diasemi.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index b899947d839d..1245dca79009 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -3444,13 +3444,6 @@ static umode_t regulator_attr_is_visible(struct kobject *kobj,
 	if (attr == &dev_attr_requested_microamps.attr)
 		return rdev->desc->type == REGULATOR_CURRENT ? mode : 0;
 
-	/* all the other attributes exist to support constraints;
-	 * don't show them if there are no constraints, or if the
-	 * relevant supporting methods are missing.
-	 */
-	if (!rdev->constraints)
-		return 0;
-
 	/* constraints need specific supporting methods */
 	if (attr == &dev_attr_min_microvolts.attr ||
 	    attr == &dev_attr_max_microvolts.attr)

commit 8f4490e09694efaf7fe60ac6a1135530aa8c05ad
Author: Bjorn Andersson <bjorn.andersson@sonymobile.com>
Date:   Wed Feb 11 19:39:12 2015 -0800

    regulator: core: Introduce set_load op
    
    Expose the requested load directly to the regulator implementation for
    hardware that does not support the normal enum based set_mode().
    
    Signed-off-by: Bjorn Andersson <bjorn.andersson@sonymobile.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index b899947d839d..f2452148c8da 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -648,10 +648,12 @@ static int drms_uA_update(struct regulator_dev *rdev)
 	if (err < 0)
 		return 0;
 
-	if (!rdev->desc->ops->get_optimum_mode)
+	if (!rdev->desc->ops->get_optimum_mode &&
+	    !rdev->desc->ops->set_load)
 		return 0;
 
-	if (!rdev->desc->ops->set_mode)
+	if (!rdev->desc->ops->set_mode &&
+	    !rdev->desc->ops->set_load)
 		return -EINVAL;
 
 	/* get output voltage */
@@ -676,22 +678,29 @@ static int drms_uA_update(struct regulator_dev *rdev)
 	list_for_each_entry(sibling, &rdev->consumer_list, list)
 		current_uA += sibling->uA_load;
 
-	/* now get the optimum mode for our new total regulator load */
-	mode = rdev->desc->ops->get_optimum_mode(rdev, input_uV,
-						  output_uV, current_uA);
+	if (rdev->desc->ops->set_load) {
+		/* set the optimum mode for our new total regulator load */
+		err = rdev->desc->ops->set_load(rdev, current_uA);
+		if (err < 0)
+			rdev_err(rdev, "failed to set load %d\n", current_uA);
+	} else {
+		/* now get the optimum mode for our new total regulator load */
+		mode = rdev->desc->ops->get_optimum_mode(rdev, input_uV,
+							 output_uV, current_uA);
+
+		/* check the new mode is allowed */
+		err = regulator_mode_constrain(rdev, &mode);
+		if (err < 0) {
+			rdev_err(rdev, "failed to get optimum mode @ %d uA %d -> %d uV\n",
+				 current_uA, input_uV, output_uV);
+			return err;
+		}
 
-	/* check the new mode is allowed */
-	err = regulator_mode_constrain(rdev, &mode);
-	if (err < 0) {
-		rdev_err(rdev, "failed to get optimum mode @ %d uA %d -> %d uV\n",
-			 current_uA, input_uV, output_uV);
-		return err;
+		err = rdev->desc->ops->set_mode(rdev, mode);
+		if (err < 0)
+			rdev_err(rdev, "failed to set optimum mode %x\n", mode);
 	}
 
-	err = rdev->desc->ops->set_mode(rdev, mode);
-	if (err < 0)
-		rdev_err(rdev, "failed to set optimum mode %x\n", mode);
-
 	return err;
 }
 

commit ffe167b0f2debbb3e21d2094508f8caca5a5bd8e
Merge: f3ba7299001c 035f3324b352 8460ef38872a 269675757901 e5a7a72cd51a 00cea31f0f0f
Author: Mark Brown <broonie@kernel.org>
Date:   Sun Feb 8 11:16:27 2015 +0800

    Merge remote-tracking branches 'regulator/topic/max8649', 'regulator/topic/mode', 'regulator/topic/mt6397', 'regulator/topic/pfuze100' and 'regulator/topic/qcom-rpm' into regulator-next

commit fca8e13f50e604436951ce59736046a79258ec20
Merge: a9877b606ceb f47531b1aa86
Author: Mark Brown <broonie@kernel.org>
Date:   Sun Feb 8 11:16:22 2015 +0800

    Merge remote-tracking branch 'regulator/topic/dt-cb' into regulator-next

commit a9877b606ceb40e5b7e08b62d5f10c65b761dcff
Merge: 36818b821bde 39f802d6b6d9
Author: Mark Brown <broonie@kernel.org>
Date:   Sun Feb 8 11:16:21 2015 +0800

    Merge remote-tracking branch 'regulator/topic/core' into regulator-next

commit 39f802d6b6d9a922f2c7a9165f0a7a5b819a1e3f
Author: Takashi Iwai <tiwai@suse.de>
Date:   Fri Jan 30 20:29:31 2015 +0100

    regulator: Build sysfs entries with static attribute groups
    
    Instead of calling device_create_file() manually after the device
    registration, put all in attribute groups and filter the unwanted ones
    via is_visible callback.  This not only simplifies the code but also
    avoids the possible race between the device registration and sysfs
    registration.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index c2554d89d472..91d79b84358b 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -632,30 +632,6 @@ static ssize_t regulator_bypass_show(struct device *dev,
 static DEVICE_ATTR(bypass, 0444,
 		   regulator_bypass_show, NULL);
 
-/*
- * These are the only attributes are present for all regulators.
- * Other attributes are a function of regulator functionality.
- */
-static struct attribute *regulator_dev_attrs[] = {
-	&dev_attr_name.attr,
-	&dev_attr_num_users.attr,
-	&dev_attr_type.attr,
-	NULL,
-};
-ATTRIBUTE_GROUPS(regulator_dev);
-
-static void regulator_dev_release(struct device *dev)
-{
-	struct regulator_dev *rdev = dev_get_drvdata(dev);
-	kfree(rdev);
-}
-
-static struct class regulator_class = {
-	.name = "regulator",
-	.dev_release = regulator_dev_release,
-	.dev_groups = regulator_dev_groups,
-};
-
 /* Calculate the new optimum regulator operating mode based on the new total
  * consumer load. All locks held by caller */
 static void drms_uA_update(struct regulator_dev *rdev)
@@ -3434,126 +3410,136 @@ int regulator_mode_to_status(unsigned int mode)
 }
 EXPORT_SYMBOL_GPL(regulator_mode_to_status);
 
+static struct attribute *regulator_dev_attrs[] = {
+	&dev_attr_name.attr,
+	&dev_attr_num_users.attr,
+	&dev_attr_type.attr,
+	&dev_attr_microvolts.attr,
+	&dev_attr_microamps.attr,
+	&dev_attr_opmode.attr,
+	&dev_attr_state.attr,
+	&dev_attr_status.attr,
+	&dev_attr_bypass.attr,
+	&dev_attr_requested_microamps.attr,
+	&dev_attr_min_microvolts.attr,
+	&dev_attr_max_microvolts.attr,
+	&dev_attr_min_microamps.attr,
+	&dev_attr_max_microamps.attr,
+	&dev_attr_suspend_standby_state.attr,
+	&dev_attr_suspend_mem_state.attr,
+	&dev_attr_suspend_disk_state.attr,
+	&dev_attr_suspend_standby_microvolts.attr,
+	&dev_attr_suspend_mem_microvolts.attr,
+	&dev_attr_suspend_disk_microvolts.attr,
+	&dev_attr_suspend_standby_mode.attr,
+	&dev_attr_suspend_mem_mode.attr,
+	&dev_attr_suspend_disk_mode.attr,
+	NULL
+};
+
 /*
  * To avoid cluttering sysfs (and memory) with useless state, only
  * create attributes that can be meaningfully displayed.
  */
-static int add_regulator_attributes(struct regulator_dev *rdev)
+static umode_t regulator_attr_is_visible(struct kobject *kobj,
+					 struct attribute *attr, int idx)
 {
-	struct device *dev = &rdev->dev;
+	struct device *dev = kobj_to_dev(kobj);
+	struct regulator_dev *rdev = container_of(dev, struct regulator_dev, dev);
 	const struct regulator_ops *ops = rdev->desc->ops;
-	int status = 0;
+	umode_t mode = attr->mode;
+
+	/* these three are always present */
+	if (attr == &dev_attr_name.attr ||
+	    attr == &dev_attr_num_users.attr ||
+	    attr == &dev_attr_type.attr)
+		return mode;
 
 	/* some attributes need specific methods to be displayed */
-	if ((ops->get_voltage && ops->get_voltage(rdev) >= 0) ||
-	    (ops->get_voltage_sel && ops->get_voltage_sel(rdev) >= 0) ||
-	    (ops->list_voltage && ops->list_voltage(rdev, 0) >= 0) ||
-		(rdev->desc->fixed_uV && (rdev->desc->n_voltages == 1))) {
-		status = device_create_file(dev, &dev_attr_microvolts);
-		if (status < 0)
-			return status;
-	}
-	if (ops->get_current_limit) {
-		status = device_create_file(dev, &dev_attr_microamps);
-		if (status < 0)
-			return status;
-	}
-	if (ops->get_mode) {
-		status = device_create_file(dev, &dev_attr_opmode);
-		if (status < 0)
-			return status;
-	}
-	if (rdev->ena_pin || ops->is_enabled) {
-		status = device_create_file(dev, &dev_attr_state);
-		if (status < 0)
-			return status;
-	}
-	if (ops->get_status) {
-		status = device_create_file(dev, &dev_attr_status);
-		if (status < 0)
-			return status;
-	}
-	if (ops->get_bypass) {
-		status = device_create_file(dev, &dev_attr_bypass);
-		if (status < 0)
-			return status;
+	if (attr == &dev_attr_microvolts.attr) {
+		if ((ops->get_voltage && ops->get_voltage(rdev) >= 0) ||
+		    (ops->get_voltage_sel && ops->get_voltage_sel(rdev) >= 0) ||
+		    (ops->list_voltage && ops->list_voltage(rdev, 0) >= 0) ||
+		    (rdev->desc->fixed_uV && rdev->desc->n_voltages == 1))
+			return mode;
+		return 0;
 	}
 
+	if (attr == &dev_attr_microamps.attr)
+		return ops->get_current_limit ? mode : 0;
+
+	if (attr == &dev_attr_opmode.attr)
+		return ops->get_mode ? mode : 0;
+
+	if (attr == &dev_attr_state.attr)
+		return (rdev->ena_pin || ops->is_enabled) ? mode : 0;
+
+	if (attr == &dev_attr_status.attr)
+		return ops->get_status ? mode : 0;
+
+	if (attr == &dev_attr_bypass.attr)
+		return ops->get_bypass ? mode : 0;
+
 	/* some attributes are type-specific */
-	if (rdev->desc->type == REGULATOR_CURRENT) {
-		status = device_create_file(dev, &dev_attr_requested_microamps);
-		if (status < 0)
-			return status;
-	}
+	if (attr == &dev_attr_requested_microamps.attr)
+		return rdev->desc->type == REGULATOR_CURRENT ? mode : 0;
 
 	/* all the other attributes exist to support constraints;
 	 * don't show them if there are no constraints, or if the
 	 * relevant supporting methods are missing.
 	 */
 	if (!rdev->constraints)
-		return status;
+		return 0;
 
 	/* constraints need specific supporting methods */
-	if (ops->set_voltage || ops->set_voltage_sel) {
-		status = device_create_file(dev, &dev_attr_min_microvolts);
-		if (status < 0)
-			return status;
-		status = device_create_file(dev, &dev_attr_max_microvolts);
-		if (status < 0)
-			return status;
-	}
-	if (ops->set_current_limit) {
-		status = device_create_file(dev, &dev_attr_min_microamps);
-		if (status < 0)
-			return status;
-		status = device_create_file(dev, &dev_attr_max_microamps);
-		if (status < 0)
-			return status;
-	}
-
-	status = device_create_file(dev, &dev_attr_suspend_standby_state);
-	if (status < 0)
-		return status;
-	status = device_create_file(dev, &dev_attr_suspend_mem_state);
-	if (status < 0)
-		return status;
-	status = device_create_file(dev, &dev_attr_suspend_disk_state);
-	if (status < 0)
-		return status;
+	if (attr == &dev_attr_min_microvolts.attr ||
+	    attr == &dev_attr_max_microvolts.attr)
+		return (ops->set_voltage || ops->set_voltage_sel) ? mode : 0;
+
+	if (attr == &dev_attr_min_microamps.attr ||
+	    attr == &dev_attr_max_microamps.attr)
+		return ops->set_current_limit ? mode : 0;
+
+	if (attr == &dev_attr_suspend_standby_state.attr ||
+	    attr == &dev_attr_suspend_mem_state.attr ||
+	    attr == &dev_attr_suspend_disk_state.attr)
+		return mode;
+
+	if (attr == &dev_attr_suspend_standby_microvolts.attr ||
+	    attr == &dev_attr_suspend_mem_microvolts.attr ||
+	    attr == &dev_attr_suspend_disk_microvolts.attr)
+		return ops->set_suspend_voltage ? mode : 0;
+
+	if (attr == &dev_attr_suspend_standby_mode.attr ||
+	    attr == &dev_attr_suspend_mem_mode.attr ||
+	    attr == &dev_attr_suspend_disk_mode.attr)
+		return ops->set_suspend_mode ? mode : 0;
+
+	return mode;
+}
+
+static const struct attribute_group regulator_dev_group = {
+	.attrs = regulator_dev_attrs,
+	.is_visible = regulator_attr_is_visible,
+};
+
+static const struct attribute_group *regulator_dev_groups[] = {
+	&regulator_dev_group,
+	NULL
+};
 
-	if (ops->set_suspend_voltage) {
-		status = device_create_file(dev,
-				&dev_attr_suspend_standby_microvolts);
-		if (status < 0)
-			return status;
-		status = device_create_file(dev,
-				&dev_attr_suspend_mem_microvolts);
-		if (status < 0)
-			return status;
-		status = device_create_file(dev,
-				&dev_attr_suspend_disk_microvolts);
-		if (status < 0)
-			return status;
-	}
-
-	if (ops->set_suspend_mode) {
-		status = device_create_file(dev,
-				&dev_attr_suspend_standby_mode);
-		if (status < 0)
-			return status;
-		status = device_create_file(dev,
-				&dev_attr_suspend_mem_mode);
-		if (status < 0)
-			return status;
-		status = device_create_file(dev,
-				&dev_attr_suspend_disk_mode);
-		if (status < 0)
-			return status;
-	}
-
-	return status;
+static void regulator_dev_release(struct device *dev)
+{
+	struct regulator_dev *rdev = dev_get_drvdata(dev);
+	kfree(rdev);
 }
 
+static struct class regulator_class = {
+	.name = "regulator",
+	.dev_release = regulator_dev_release,
+	.dev_groups = regulator_dev_groups,
+};
+
 static void rdev_init_debugfs(struct regulator_dev *rdev)
 {
 	rdev->debugfs = debugfs_create_dir(rdev_get_name(rdev), debugfs_root);
@@ -3692,11 +3678,6 @@ regulator_register(const struct regulator_desc *regulator_desc,
 	if (ret < 0)
 		goto scrub;
 
-	/* add attributes supported by this regulator */
-	ret = add_regulator_attributes(rdev);
-	if (ret < 0)
-		goto scrub;
-
 	if (init_data && init_data->supply_regulator)
 		supply = init_data->supply_regulator;
 	else if (regulator_desc->supply_name)

commit 8460ef38872a89cf1f95b37ee2707ec32dc8ec0b
Author: Bjorn Andersson <bjorn.andersson@sonymobile.com>
Date:   Tue Jan 27 18:46:31 2015 -0800

    regulator: core: Consolidate drms update handling
    
    Refactor drms_uA_update() slightly to allow regulator_set_optimum_mode()
    to utilize the same logic instead of duplicating it.
    
    Signed-off-by: Bjorn Andersson <bjorn.andersson@sonymobile.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index e225711bb8bc..0e0d8297dc8e 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -658,23 +658,32 @@ static struct class regulator_class = {
 
 /* Calculate the new optimum regulator operating mode based on the new total
  * consumer load. All locks held by caller */
-static void drms_uA_update(struct regulator_dev *rdev)
+static int drms_uA_update(struct regulator_dev *rdev)
 {
 	struct regulator *sibling;
 	int current_uA = 0, output_uV, input_uV, err;
 	unsigned int mode;
 
+	/*
+	 * first check to see if we can set modes at all, otherwise just
+	 * tell the consumer everything is OK.
+	 */
 	err = regulator_check_drms(rdev);
-	if (err < 0 || !rdev->desc->ops->get_optimum_mode ||
-	    (!rdev->desc->ops->get_voltage &&
-	     !rdev->desc->ops->get_voltage_sel) ||
-	    !rdev->desc->ops->set_mode)
-		return;
+	if (err < 0)
+		return 0;
+
+	if (!rdev->desc->ops->get_optimum_mode)
+		return 0;
+
+	if (!rdev->desc->ops->set_mode)
+		return -EINVAL;
 
 	/* get output voltage */
 	output_uV = _regulator_get_voltage(rdev);
-	if (output_uV <= 0)
-		return;
+	if (output_uV <= 0) {
+		rdev_err(rdev, "invalid output voltage found\n");
+		return -EINVAL;
+	}
 
 	/* get input voltage */
 	input_uV = 0;
@@ -682,8 +691,10 @@ static void drms_uA_update(struct regulator_dev *rdev)
 		input_uV = regulator_get_voltage(rdev->supply);
 	if (input_uV <= 0)
 		input_uV = rdev->constraints->input_uV;
-	if (input_uV <= 0)
-		return;
+	if (input_uV <= 0) {
+		rdev_err(rdev, "invalid input voltage found\n");
+		return -EINVAL;
+	}
 
 	/* calc total requested load */
 	list_for_each_entry(sibling, &rdev->consumer_list, list)
@@ -695,8 +706,17 @@ static void drms_uA_update(struct regulator_dev *rdev)
 
 	/* check the new mode is allowed */
 	err = regulator_mode_constrain(rdev, &mode);
-	if (err == 0)
-		rdev->desc->ops->set_mode(rdev, mode);
+	if (err < 0) {
+		rdev_err(rdev, "failed to get optimum mode @ %d uA %d -> %d uV\n",
+			 current_uA, input_uV, output_uV);
+		return err;
+	}
+
+	err = rdev->desc->ops->set_mode(rdev, mode);
+	if (err < 0)
+		rdev_err(rdev, "failed to set optimum mode %x\n", mode);
+
+	return err;
 }
 
 static int suspend_set_state(struct regulator_dev *rdev,
@@ -3024,75 +3044,13 @@ EXPORT_SYMBOL_GPL(regulator_get_mode);
 int regulator_set_optimum_mode(struct regulator *regulator, int uA_load)
 {
 	struct regulator_dev *rdev = regulator->rdev;
-	struct regulator *consumer;
-	int ret, output_uV, input_uV = 0, total_uA_load = 0;
-	unsigned int mode;
-
-	if (rdev->supply)
-		input_uV = regulator_get_voltage(rdev->supply);
+	int ret;
 
 	mutex_lock(&rdev->mutex);
-
-	/*
-	 * first check to see if we can set modes at all, otherwise just
-	 * tell the consumer everything is OK.
-	 */
 	regulator->uA_load = uA_load;
-	ret = regulator_check_drms(rdev);
-	if (ret < 0) {
-		ret = 0;
-		goto out;
-	}
-
-	if (!rdev->desc->ops->get_optimum_mode)
-		goto out;
-
-	/*
-	 * we can actually do this so any errors are indicators of
-	 * potential real failure.
-	 */
-	ret = -EINVAL;
-
-	if (!rdev->desc->ops->set_mode)
-		goto out;
-
-	/* get output voltage */
-	output_uV = _regulator_get_voltage(rdev);
-	if (output_uV <= 0) {
-		rdev_err(rdev, "invalid output voltage found\n");
-		goto out;
-	}
-
-	/* No supply? Use constraint voltage */
-	if (input_uV <= 0)
-		input_uV = rdev->constraints->input_uV;
-	if (input_uV <= 0) {
-		rdev_err(rdev, "invalid input voltage found\n");
-		goto out;
-	}
-
-	/* calc total requested load for this regulator */
-	list_for_each_entry(consumer, &rdev->consumer_list, list)
-		total_uA_load += consumer->uA_load;
-
-	mode = rdev->desc->ops->get_optimum_mode(rdev,
-						 input_uV, output_uV,
-						 total_uA_load);
-	ret = regulator_mode_constrain(rdev, &mode);
-	if (ret < 0) {
-		rdev_err(rdev, "failed to get optimum mode @ %d uA %d -> %d uV\n",
-			 total_uA_load, input_uV, output_uV);
-		goto out;
-	}
-
-	ret = rdev->desc->ops->set_mode(rdev, mode);
-	if (ret < 0) {
-		rdev_err(rdev, "failed to set optimum mode %x\n", mode);
-		goto out;
-	}
-	ret = mode;
-out:
+	ret = drms_uA_update(rdev);
 	mutex_unlock(&rdev->mutex);
+
 	return ret;
 }
 EXPORT_SYMBOL_GPL(regulator_set_optimum_mode);

commit f47531b1aa86e0bef898c1ff810f8486f469b111
Author: Krzysztof Kozlowski <k.kozlowski@samsung.com>
Date:   Mon Jan 12 09:01:39 2015 +0100

    regulator: Update documentation after renaming function argument
    
    Update documentation for regulator_register() function after renaming
    its argument.
    
    Signed-off-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Reported-by: kbuild test robot <fengguang.wu@intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 685cc1500e38..d9a2ad57b17f 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -3573,7 +3573,7 @@ static void rdev_init_debugfs(struct regulator_dev *rdev)
 /**
  * regulator_register - register regulator
  * @regulator_desc: regulator to register
- * @config: runtime configuration for regulator
+ * @cfg: runtime configuration for regulator
  *
  * Called by regulator drivers to register a regulator.
  * Returns a valid pointer to struct regulator_dev on success

commit 09d3f6f1613f287b1d3ea7d2c9caf5b7aff70c99
Merge: bfa21a0dfe69 39138818a4f5
Author: Mark Brown <broonie@kernel.org>
Date:   Fri Jan 9 18:03:55 2015 +0000

    Merge branch 'topic/core' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/regulator into regulator-dt-cb
    
    Conflicts:
            drivers/regulator/core.c

commit bfa21a0dfe6915dc85953b5d40ea9dae5fdf205f
Author: Krzysztof Kozlowski <k.kozlowski@samsung.com>
Date:   Mon Jan 5 12:48:42 2015 +0100

    regulator: Allow parsing custom properties when using simplified DT parsing
    
    When drivers use simplified DT parsing method (they provide
    'regulator_desc.of_match') they still may want to parse custom
    properties for some of the regulators. For example some of the
    regulators support GPIO enable control.
    
    Add a driver-supplied callback for such case. This way the regulator
    core parses common bindings offloading a lot of code from drivers and
    still custom properties may be used.
    
    The callback, called for each parsed regulator, may modify the
    'regulator_config' initially passed to regulator_register().
    
    Signed-off-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index c13b557a560e..5fae8cabd254 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -3635,7 +3635,7 @@ regulator_register(const struct regulator_desc *regulator_desc,
 		return ERR_PTR(-ENOMEM);
 	}
 
-	init_data = regulator_of_get_init_data(dev, regulator_desc,
+	init_data = regulator_of_get_init_data(dev, regulator_desc, config,
 					       &rdev->dev.of_node);
 	if (!init_data) {
 		init_data = config->init_data;

commit 1b3de223385d6bf2ab9bf2e9e80aebb26fedd426
Author: Krzysztof Kozlowski <k.kozlowski@samsung.com>
Date:   Mon Jan 5 12:48:41 2015 +0100

    regulator: Copy config passed during registration
    
    Copy the 'regulator_config' structure passed to regulator_register()
    function so the driver could safely modify it after parsing init data.
    
    The driver may want to change the config as a result of specific init
    data parsed by regulator core (e.g. when core handled parsing device
    tree).
    
    Signed-off-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index e225711bb8bc..c13b557a560e 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -3581,20 +3581,21 @@ static void rdev_init_debugfs(struct regulator_dev *rdev)
  */
 struct regulator_dev *
 regulator_register(const struct regulator_desc *regulator_desc,
-		   const struct regulator_config *config)
+		   const struct regulator_config *cfg)
 {
 	const struct regulation_constraints *constraints = NULL;
 	const struct regulator_init_data *init_data;
+	struct regulator_config *config = NULL;
 	static atomic_t regulator_no = ATOMIC_INIT(0);
 	struct regulator_dev *rdev;
 	struct device *dev;
 	int ret, i;
 	const char *supply = NULL;
 
-	if (regulator_desc == NULL || config == NULL)
+	if (regulator_desc == NULL || cfg == NULL)
 		return ERR_PTR(-EINVAL);
 
-	dev = config->dev;
+	dev = cfg->dev;
 	WARN_ON(!dev);
 
 	if (regulator_desc->name == NULL || regulator_desc->ops == NULL)
@@ -3624,6 +3625,16 @@ regulator_register(const struct regulator_desc *regulator_desc,
 	if (rdev == NULL)
 		return ERR_PTR(-ENOMEM);
 
+	/*
+	 * Duplicate the config so the driver could override it after
+	 * parsing init data.
+	 */
+	config = kmemdup(cfg, sizeof(*cfg), GFP_KERNEL);
+	if (config == NULL) {
+		kfree(rdev);
+		return ERR_PTR(-ENOMEM);
+	}
+
 	init_data = regulator_of_get_init_data(dev, regulator_desc,
 					       &rdev->dev.of_node);
 	if (!init_data) {
@@ -3752,6 +3763,7 @@ regulator_register(const struct regulator_desc *regulator_desc,
 	rdev_init_debugfs(rdev);
 out:
 	mutex_unlock(&regulator_list_mutex);
+	kfree(config);
 	return rdev;
 
 unset_supplies:

commit 83b0302d347a49f951e904184afe57ac3723476e
Author: Ashay Jaiswal <ashayj@codeaurora.org>
Date:   Thu Jan 8 18:54:25 2015 +0530

    regulator: core: fix race condition in regulator_put()
    
    The regulator framework maintains a list of consumer regulators
    for a regulator device and protects it from concurrent access using
    the regulator device's mutex lock.
    
    In the case of regulator_put() the consumer is removed and regulator
    device's parameters are updated without holding the regulator device's
    mutex. This would lead to a race condition between the regulator_put()
    and any function which traverses the consumer list or modifies regulator
    device's parameters.
    Fix this race condition by holding the regulator device's mutex in case
    of regulator_put.
    
    Signed-off-by: Ashay Jaiswal <ashayj@codeaurora.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Cc: stable@vger.kernel.org

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index e225711bb8bc..9c48fb32f660 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1488,7 +1488,7 @@ struct regulator *regulator_get_optional(struct device *dev, const char *id)
 }
 EXPORT_SYMBOL_GPL(regulator_get_optional);
 
-/* Locks held by regulator_put() */
+/* regulator_list_mutex lock held by regulator_put() */
 static void _regulator_put(struct regulator *regulator)
 {
 	struct regulator_dev *rdev;
@@ -1503,12 +1503,14 @@ static void _regulator_put(struct regulator *regulator)
 	/* remove any sysfs entries */
 	if (regulator->dev)
 		sysfs_remove_link(&rdev->dev.kobj, regulator->supply_name);
+	mutex_lock(&rdev->mutex);
 	kfree(regulator->supply_name);
 	list_del(&regulator->list);
 	kfree(regulator);
 
 	rdev->open_count--;
 	rdev->exclusive = 0;
+	mutex_unlock(&rdev->mutex);
 
 	module_put(rdev->owner);
 }

commit 39138818a4f5c62d70f35504477c2509f982f211
Author: Aniroop Mathur <aniroop.mathur@gmail.com>
Date:   Mon Dec 29 22:36:48 2014 +0530

    regulator: core: Fix format specifier warning
    
    Signed-off-by: Aniroop Mathur <a.mathur@samsung.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 4bc5ea9721c2..c2554d89d472 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -3659,7 +3659,7 @@ regulator_register(const struct regulator_desc *regulator_desc,
 	rdev->dev.class = &regulator_class;
 	rdev->dev.parent = dev;
 	dev_set_name(&rdev->dev, "regulator.%lu",
-		     atomic_inc_return(&regulator_no));
+		    (unsigned long) atomic_inc_return(&regulator_no));
 	ret = device_register(&rdev->dev);
 	if (ret != 0) {
 		put_device(&rdev->dev);

commit 72dca06f62c50415de3202f204200f58769d0b8b
Author: Aniroop Mathur <aniroop.mathur@gmail.com>
Date:   Sun Dec 28 22:08:38 2014 +0530

    regulator: core: Avoid negative regulator no & initialize it to -1
    
    This patch initializes regulator_no to -1 to avoid extra subtraction
    operation performed every time we register a regulator and avoid negative
    regulator no in its name.
    
    Signed-off-by: Aniroop Mathur <a.mathur@samsung.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index e225711bb8bc..4bc5ea9721c2 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -3585,7 +3585,7 @@ regulator_register(const struct regulator_desc *regulator_desc,
 {
 	const struct regulation_constraints *constraints = NULL;
 	const struct regulator_init_data *init_data;
-	static atomic_t regulator_no = ATOMIC_INIT(0);
+	static atomic_t regulator_no = ATOMIC_INIT(-1);
 	struct regulator_dev *rdev;
 	struct device *dev;
 	int ret, i;
@@ -3658,8 +3658,8 @@ regulator_register(const struct regulator_desc *regulator_desc,
 	/* register with sysfs */
 	rdev->dev.class = &regulator_class;
 	rdev->dev.parent = dev;
-	dev_set_name(&rdev->dev, "regulator.%d",
-		     atomic_inc_return(&regulator_no) - 1);
+	dev_set_name(&rdev->dev, "regulator.%lu",
+		     atomic_inc_return(&regulator_no));
 	ret = device_register(&rdev->dev);
 	if (ret != 0) {
 		put_device(&rdev->dev);

commit af012d6278d87ea612f2f9b74a0ffa75d2d92f20
Merge: 15db0c8d79b3 da0607c8df5c a1c8a5512b7c e1326eff80bf 9f946099fe19
Author: Mark Brown <broonie@kernel.org>
Date:   Fri Dec 5 11:14:35 2014 +0000

    Merge remote-tracking branches 'regulator/topic/anatop', 'regulator/topic/disable', 'regulator/topic/dummy' and 'regulator/topic/gpio' into regulator-next

commit 60a2362f769cf549dc466134efe71c8bf9fbaaba
Author: Seung-Woo Kim <sw0312.kim@samsung.com>
Date:   Thu Dec 4 19:17:17 2014 +0900

    regulator: core: Fix regualtor_ena_gpio_free not to access pin after freeing
    
    After freeing pin from regulator_ena_gpio_free, loop can access
    the pin. So this patch fixes not to access pin after freeing.
    
    Signed-off-by: Seung-Woo Kim <sw0312.kim@samsung.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index df2af3a11351..47a455cfe04f 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1713,6 +1713,8 @@ static void regulator_ena_gpio_free(struct regulator_dev *rdev)
 				gpiod_put(pin->gpiod);
 				list_del(&pin->list);
 				kfree(pin);
+				rdev->ena_pin = NULL;
+				return;
 			} else {
 				pin->request_count--;
 			}

commit a1c8a5512b7cddc81767172f0de37b155cea039f
Author: Richard Fitzgerald <rf@opensource.wolfsonmicro.com>
Date:   Mon Nov 24 14:10:52 2014 +0000

    regulator: core: Add PRE_DISABLE notification
    
    Add a PRE_DISABLE notification so that consumers can use a
    notifier to run any steps required to prepare for the
    regulator being switched off. Since the regulator disable
    can fail an abort notification is also added.
    
    Signed-off-by: Richard Fitzgerald <rf@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index cd87c0c37034..53de911a0954 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1976,9 +1976,18 @@ static int _regulator_disable(struct regulator_dev *rdev)
 
 		/* we are last user */
 		if (_regulator_can_change_status(rdev)) {
+			ret = _notifier_call_chain(rdev,
+						   REGULATOR_EVENT_PRE_DISABLE,
+						   NULL);
+			if (ret & NOTIFY_STOP_MASK)
+				return -EINVAL;
+
 			ret = _regulator_do_disable(rdev);
 			if (ret < 0) {
 				rdev_err(rdev, "failed to disable\n");
+				_notifier_call_chain(rdev,
+						REGULATOR_EVENT_ABORT_DISABLE,
+						NULL);
 				return ret;
 			}
 			_notifier_call_chain(rdev, REGULATOR_EVENT_DISABLE,
@@ -2035,9 +2044,16 @@ static int _regulator_force_disable(struct regulator_dev *rdev)
 {
 	int ret = 0;
 
+	ret = _notifier_call_chain(rdev, REGULATOR_EVENT_FORCE_DISABLE |
+			REGULATOR_EVENT_PRE_DISABLE, NULL);
+	if (ret & NOTIFY_STOP_MASK)
+		return -EINVAL;
+
 	ret = _regulator_do_disable(rdev);
 	if (ret < 0) {
 		rdev_err(rdev, "failed to force disable\n");
+		_notifier_call_chain(rdev, REGULATOR_EVENT_FORCE_DISABLE |
+				REGULATOR_EVENT_ABORT_DISABLE, NULL);
 		return ret;
 	}
 

commit 194dbaefa0da24bb60d9df1c99dda807f51fc33f
Author: Mark Brown <broonie@kernel.org>
Date:   Fri Oct 31 19:11:59 2014 +0000

    regulator: Lower priority of constraint logging
    
    Some systems have very large numbers of regulators so the constraint
    logging done at startup can end up being a very big part of the boot
    output which is both verbose and slows things down if the console is
    a serial console. Lower to dev_dbg() instead, we may want to provide
    a boot parameter to raise this in future but for now people can edit
    the source.
    
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Reviewed-by: Guenter Roeck <linux@roeck-us.net>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index cd87c0c37034..df2af3a11351 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -828,7 +828,7 @@ static void print_constraints(struct regulator_dev *rdev)
 	if (!count)
 		sprintf(buf, "no parameters");
 
-	rdev_info(rdev, "%s\n", buf);
+	rdev_dbg(rdev, "%s\n", buf);
 
 	if ((constraints->min_uV != constraints->max_uV) &&
 	    !(constraints->valid_ops_mask & REGULATOR_CHANGE_VOLTAGE))

commit 76f439df50aba1838e06dd01e5f20dada7473f57
Author: Markus Pargmann <mpa@pengutronix.de>
Date:   Wed Oct 8 15:47:05 2014 +0200

    regulator: Add ena_gpio_initialized to regulator_config
    
    Most drivers do not set the ena_gpio field of struct regulator_config
    before passing it to the regulator core. This is fine as long as the
    gpio identifier that is passed is a positive integer. But the gpio
    identifier 0 is also valid. So we are not able to decide wether we got a
    real gpio identifier or not based on a 0 in ena_gpio.
    
    To be able to decide if it is a valid gpio that got passed, this patch
    adds a ena_gpio_initialized field that should be set if was initialized
    with a correct value, either a gpio >= 0 or a negative error number. The
    core then checks if ena_gpio or ena_gpio_initialized before handling it
    as a gpio. This way we maintain backwards compatibility and fix the
    behaviour for gpio number 0.
    
    Signed-off-by: Markus Pargmann <mpa@pengutronix.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index cd87c0c37034..55a87a2722d8 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -3650,7 +3650,8 @@ regulator_register(const struct regulator_desc *regulator_desc,
 
 	dev_set_drvdata(&rdev->dev, rdev);
 
-	if (config->ena_gpio && gpio_is_valid(config->ena_gpio)) {
+	if ((config->ena_gpio || config->ena_gpio_initialized) &&
+	    gpio_is_valid(config->ena_gpio)) {
 		ret = regulator_ena_gpio_request(rdev, config);
 		if (ret != 0) {
 			rdev_err(rdev, "Failed to request enable GPIO%d: %d\n",

commit ad21edcdb2172c0d8f47f856867104e331525820
Merge: 6d9deb7ad455 7d42a7f293da 23b1134838ef 7179569aeb52
Author: Mark Brown <broonie@kernel.org>
Date:   Tue Sep 30 13:50:31 2014 +0100

    Merge remote-tracking branches 'regulator/topic/tps65217', 'regulator/topic/tps65910' and 'regulator/topic/voltage-ev' into regulator-next

commit a81bf3c4fc391ec10696d448408c1ac83bfb6112
Merge: 95528a55dba0 fdaff15ae6cc df11e506d330 e13426bf249b 5c5e417bc06f ba441ec22533
Author: Mark Brown <broonie@kernel.org>
Date:   Tue Sep 30 13:50:27 2014 +0100

    Merge remote-tracking branches 'regulator/topic/drivers', 'regulator/topic/enable', 'regulator/topic/fan53555', 'regulator/topic/hi6421' and 'regulator/topic/isl9305' into regulator-next

commit 3f7c69637511a39f4400dc8312bbcecaa592ab61
Merge: dec38b5ce6a9 a0c7b164ad11
Author: Mark Brown <broonie@kernel.org>
Date:   Wed Sep 10 12:03:23 2014 +0100

    Merge branch 'topic/of' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/regulator into regulator-isl9305

commit a0c7b164ad115ec0556dc0904ee2218cbc5cedfa
Author: Mark Brown <broonie@kernel.org>
Date:   Tue Sep 9 23:13:57 2014 +0100

    regulator: of: Provide simplified DT parsing method
    
    Currently regulator drivers which support DT all repeat very similar code
    to supply a list of known regulator identifiers to be matched with DT,
    convert that to platform data which is then matched up with the regulators
    as they are registered. This is both fiddly to get right and for devices
    which can use the standard helpers to provide their operations is the main
    source of code in the driver.
    
    Since this code is essentially identical for most drivers we can factor it
    out into the core, moving the identifiers in the match table into the
    regulator descriptors and also allowing drivers to pass in the name of the
    subnode to search. When a driver provides an of_match string for the
    regulator the core will attempt to use that to obtain init_data, allowing
    the driver to remove all explicit code for DT parsing and simply provide
    data instead.
    
    The current code leaks the phandles for the child nodes, this will be
    addressed incrementally and makes no practical difference for FDT anyway
    as the DT data structures are never freed.
    
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index a3c3785901f5..496002efd961 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -3516,12 +3516,17 @@ regulator_register(const struct regulator_desc *regulator_desc,
 		return ERR_PTR(-EINVAL);
 	}
 
-	init_data = config->init_data;
-
 	rdev = kzalloc(sizeof(struct regulator_dev), GFP_KERNEL);
 	if (rdev == NULL)
 		return ERR_PTR(-ENOMEM);
 
+	init_data = regulator_of_get_init_data(dev, regulator_desc,
+					       &rdev->dev.of_node);
+	if (!init_data) {
+		init_data = config->init_data;
+		rdev->dev.of_node = of_node_get(config->of_node);
+	}
+
 	mutex_lock(&regulator_list_mutex);
 
 	mutex_init(&rdev->mutex);
@@ -3548,7 +3553,6 @@ regulator_register(const struct regulator_desc *regulator_desc,
 
 	/* register with sysfs */
 	rdev->dev.class = &regulator_class;
-	rdev->dev.of_node = of_node_get(config->of_node);
 	rdev->dev.parent = dev;
 	dev_set_name(&rdev->dev, "regulator.%d",
 		     atomic_inc_return(&regulator_no) - 1);

commit 7179569aeb52197fd2a9909ba226c4c9cc0e2e2a
Author: Heiko Stübner <heiko@sntech.de>
Date:   Thu Aug 28 12:36:04 2014 -0700

    regulator: core: Add REGULATOR_EVENT_PRE_VOLTAGE_CHANGE (and ABORT)
    
    In some cases we need to know when a regulator is about to be changed.
    Add a way for clients to be notified.  Note that for set_voltage() we
    don't necessarily know what voltage we'll end up with, so we tell the
    client what the range will be so they can prepare.
    
    Signed-off-by: Heiko Stübner <heiko@sntech.de>
    Signed-off-by: Doug Anderson <dianders@chromium.org>
    Signed-off-by: Mark Brown <broonie+linaro@kernel.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index a3c3785901f5..dabc8e8862c8 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -102,7 +102,7 @@ static int _regulator_disable(struct regulator_dev *rdev);
 static int _regulator_get_voltage(struct regulator_dev *rdev);
 static int _regulator_get_current_limit(struct regulator_dev *rdev);
 static unsigned int _regulator_get_mode(struct regulator_dev *rdev);
-static void _notifier_call_chain(struct regulator_dev *rdev,
+static int _notifier_call_chain(struct regulator_dev *rdev,
 				  unsigned long event, void *data);
 static int _regulator_do_set_voltage(struct regulator_dev *rdev,
 				     int min_uV, int max_uV);
@@ -2369,6 +2369,55 @@ int regulator_is_supported_voltage(struct regulator *regulator,
 }
 EXPORT_SYMBOL_GPL(regulator_is_supported_voltage);
 
+static int _regulator_call_set_voltage(struct regulator_dev *rdev,
+				       int min_uV, int max_uV,
+				       unsigned *selector)
+{
+	struct pre_voltage_change_data data;
+	int ret;
+
+	data.old_uV = _regulator_get_voltage(rdev);
+	data.min_uV = min_uV;
+	data.max_uV = max_uV;
+	ret = _notifier_call_chain(rdev, REGULATOR_EVENT_PRE_VOLTAGE_CHANGE,
+				   &data);
+	if (ret & NOTIFY_STOP_MASK)
+		return -EINVAL;
+
+	ret = rdev->desc->ops->set_voltage(rdev, min_uV, max_uV, selector);
+	if (ret >= 0)
+		return ret;
+
+	_notifier_call_chain(rdev, REGULATOR_EVENT_ABORT_VOLTAGE_CHANGE,
+			     (void *)data.old_uV);
+
+	return ret;
+}
+
+static int _regulator_call_set_voltage_sel(struct regulator_dev *rdev,
+					   int uV, unsigned selector)
+{
+	struct pre_voltage_change_data data;
+	int ret;
+
+	data.old_uV = _regulator_get_voltage(rdev);
+	data.min_uV = uV;
+	data.max_uV = uV;
+	ret = _notifier_call_chain(rdev, REGULATOR_EVENT_PRE_VOLTAGE_CHANGE,
+				   &data);
+	if (ret & NOTIFY_STOP_MASK)
+		return -EINVAL;
+
+	ret = rdev->desc->ops->set_voltage_sel(rdev, selector);
+	if (ret >= 0)
+		return ret;
+
+	_notifier_call_chain(rdev, REGULATOR_EVENT_ABORT_VOLTAGE_CHANGE,
+			     (void *)data.old_uV);
+
+	return ret;
+}
+
 static int _regulator_do_set_voltage(struct regulator_dev *rdev,
 				     int min_uV, int max_uV)
 {
@@ -2396,8 +2445,8 @@ static int _regulator_do_set_voltage(struct regulator_dev *rdev,
 	}
 
 	if (rdev->desc->ops->set_voltage) {
-		ret = rdev->desc->ops->set_voltage(rdev, min_uV, max_uV,
-						   &selector);
+		ret = _regulator_call_set_voltage(rdev, min_uV, max_uV,
+						  &selector);
 
 		if (ret >= 0) {
 			if (rdev->desc->ops->list_voltage)
@@ -2432,8 +2481,8 @@ static int _regulator_do_set_voltage(struct regulator_dev *rdev,
 				if (old_selector == selector)
 					ret = 0;
 				else
-					ret = rdev->desc->ops->set_voltage_sel(
-								rdev, ret);
+					ret = _regulator_call_set_voltage_sel(
+						rdev, best_val, selector);
 			} else {
 				ret = -EINVAL;
 			}
@@ -3079,11 +3128,11 @@ EXPORT_SYMBOL_GPL(regulator_unregister_notifier);
 /* notify regulator consumers and downstream regulator consumers.
  * Note mutex must be held by caller.
  */
-static void _notifier_call_chain(struct regulator_dev *rdev,
+static int _notifier_call_chain(struct regulator_dev *rdev,
 				  unsigned long event, void *data)
 {
 	/* call rdev chain first */
-	blocking_notifier_call_chain(&rdev->notifier, event, data);
+	return blocking_notifier_call_chain(&rdev->notifier, event, data);
 }
 
 /**

commit 39f5460d7f9cc57d3dd745301bf60ca5d65a6e7b
Author: Guodong Xu <guodong.xu@linaro.org>
Date:   Tue Aug 19 18:07:41 2014 +0800

    regulator: core: add const to regulator_ops and fix build error in mc13892
    
    Commit 272e2315fac3 ("regulator: core: add const qualifier to ops in
    struct regulator_desc") introduced const qualifier to ops in regulator_desc.
    
    This patch adds 'const' to regulator_ops vars in newly added core APIs
    for v3.17-rc1:
     - regulator_get_hardware_vsel_register()
     - regulator_list_hardware_vsel()
    
    This patch also fix a build error in mc13892-regulator.c due to const
    regulator_desc.ops. Modification of regulator_desc.ops' member fields is not
    allowed.
    
    Signed-off-by: Guodong Xu <guodong.xu@linaro.org>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 1e976b6320a2..7bce7158d7e6 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2307,8 +2307,8 @@ int regulator_get_hardware_vsel_register(struct regulator *regulator,
 					 unsigned *vsel_reg,
 					 unsigned *vsel_mask)
 {
-	struct regulator_dev	*rdev = regulator->rdev;
-	struct regulator_ops	*ops = rdev->desc->ops;
+	struct regulator_dev *rdev = regulator->rdev;
+	const struct regulator_ops *ops = rdev->desc->ops;
 
 	if (ops->set_voltage_sel != regulator_set_voltage_sel_regmap)
 		return -EOPNOTSUPP;
@@ -2334,8 +2334,8 @@ EXPORT_SYMBOL_GPL(regulator_get_hardware_vsel_register);
 int regulator_list_hardware_vsel(struct regulator *regulator,
 				 unsigned selector)
 {
-	struct regulator_dev	*rdev = regulator->rdev;
-	struct regulator_ops	*ops = rdev->desc->ops;
+	struct regulator_dev *rdev = regulator->rdev;
+	const struct regulator_ops *ops = rdev->desc->ops;
 
 	if (selector >= rdev->desc->n_voltages)
 		return -EINVAL;

commit 871f565055ed232e5751da18a331b73e8254adaf
Author: Guodong Xu <guodong.xu@linaro.org>
Date:   Wed Aug 13 19:33:40 2014 +0800

    regulator: core: add guard delay between calling regulator_disable and _enable
    
    Some regulator require a minimum delay between its disable and next enable.
    This is to avoid damages when out-of-range frequent disable/enable of a
    single regulator can bring to the regulator chip.
    
    Add @off_on_delay to struct regulator_desc. Device drivers' can use this field
    to set this guard time.
    
    Add @last_off_jiffy to struct regulator_dev. When @off_on_delay is set by
    driver, regulator core can store its last off (disable) time into this field.
    
    Signed-off-by: Guodong Xu <guodong.xu@linaro.org>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index dc0e9813b62d..1e976b6320a2 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1813,6 +1813,31 @@ static int _regulator_do_enable(struct regulator_dev *rdev)
 
 	trace_regulator_enable(rdev_get_name(rdev));
 
+	if (rdev->desc->off_on_delay) {
+		/* if needed, keep a distance of off_on_delay from last time
+		 * this regulator was disabled.
+		 */
+		unsigned long start_jiffy = jiffies;
+		unsigned long intended, max_delay, remaining;
+
+		max_delay = usecs_to_jiffies(rdev->desc->off_on_delay);
+		intended = rdev->last_off_jiffy + max_delay;
+
+		if (time_before(start_jiffy, intended)) {
+			/* calc remaining jiffies to deal with one-time
+			 * timer wrapping.
+			 * in case of multiple timer wrapping, either it can be
+			 * detected by out-of-range remaining, or it cannot be
+			 * detected and we gets a panelty of
+			 * _regulator_enable_delay().
+			 */
+			remaining = intended - start_jiffy;
+			if (remaining <= max_delay)
+				_regulator_enable_delay(
+						jiffies_to_usecs(remaining));
+		}
+	}
+
 	if (rdev->ena_pin) {
 		ret = regulator_ena_gpio_ctrl(rdev, true);
 		if (ret < 0)
@@ -1925,6 +1950,12 @@ static int _regulator_do_disable(struct regulator_dev *rdev)
 			return ret;
 	}
 
+	/* cares about last_off_jiffy only if off_on_delay is required by
+	 * device.
+	 */
+	if (rdev->desc->off_on_delay)
+		rdev->last_off_jiffy = jiffies;
+
 	trace_regulator_disable_complete(rdev_get_name(rdev));
 
 	return 0;

commit 79fd114161a764dfa456191af89358b3f5201c87
Author: Guodong Xu <guodong.xu@linaro.org>
Date:   Wed Aug 13 19:33:39 2014 +0800

    regulator: core: factor out delay function from _regulator_do_enable
    
    A common delay function can be helpful when implementing new features. Factor
    it out to maximize code reusability.
    
    Signed-off-by: Guodong Xu <guodong.xu@linaro.org>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 052e7f1f011d..dc0e9813b62d 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1759,6 +1759,45 @@ static int regulator_ena_gpio_ctrl(struct regulator_dev *rdev, bool enable)
 	return 0;
 }
 
+/**
+ * _regulator_enable_delay - a delay helper function
+ * @delay: time to delay in microseconds
+ *
+ * Delay for the requested amount of time as per the guidelines in:
+ *
+ *     Documentation/timers/timers-howto.txt
+ *
+ * The assumption here is that regulators will never be enabled in
+ * atomic context and therefore sleeping functions can be used.
+ */
+static void _regulator_enable_delay(unsigned int delay)
+{
+	unsigned int ms = delay / 1000;
+	unsigned int us = delay % 1000;
+
+	if (ms > 0) {
+		/*
+		 * For small enough values, handle super-millisecond
+		 * delays in the usleep_range() call below.
+		 */
+		if (ms < 20)
+			us += ms * 1000;
+		else
+			msleep(ms);
+	}
+
+	/*
+	 * Give the scheduler some room to coalesce with any other
+	 * wakeup sources. For delays shorter than 10 us, don't even
+	 * bother setting up high-resolution timers and just busy-
+	 * loop.
+	 */
+	if (us >= 10)
+		usleep_range(us, us + 100);
+	else
+		udelay(us);
+}
+
 static int _regulator_do_enable(struct regulator_dev *rdev)
 {
 	int ret, delay;
@@ -1792,40 +1831,7 @@ static int _regulator_do_enable(struct regulator_dev *rdev)
 	 * together.  */
 	trace_regulator_enable_delay(rdev_get_name(rdev));
 
-	/*
-	 * Delay for the requested amount of time as per the guidelines in:
-	 *
-	 *     Documentation/timers/timers-howto.txt
-	 *
-	 * The assumption here is that regulators will never be enabled in
-	 * atomic context and therefore sleeping functions can be used.
-	 */
-	if (delay) {
-		unsigned int ms = delay / 1000;
-		unsigned int us = delay % 1000;
-
-		if (ms > 0) {
-			/*
-			 * For small enough values, handle super-millisecond
-			 * delays in the usleep_range() call below.
-			 */
-			if (ms < 20)
-				us += ms * 1000;
-			else
-				msleep(ms);
-		}
-
-		/*
-		 * Give the scheduler some room to coalesce with any other
-		 * wakeup sources. For delays shorter than 10 us, don't even
-		 * bother setting up high-resolution timers and just busy-
-		 * loop.
-		 */
-		if (us >= 10)
-			usleep_range(us, us + 100);
-		else
-			udelay(us);
-	}
+	_regulator_enable_delay(delay);
 
 	trace_regulator_enable_complete(rdev_get_name(rdev));
 

commit 272e2315fac3bfca0edfa3252b8a643c425602af
Author: Guodong Xu <guodong.xu@linaro.org>
Date:   Wed Aug 13 19:33:38 2014 +0800

    regulator: core: add const qualifier to ops in struct regulator_desc
    
    struct regulator_ops *ops is a member in struct regulator_desc, which gets
    its value from individual regulator driver upon regulator_register() and
    is used by regulator core APIs. It's not allowed for regulator core to
    modify any of these callbacks in *ops. Add 'const' qualifier to enforce that.
    
    Signed-off-by: Guodong Xu <guodong.xu@linaro.org>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index a3c3785901f5..052e7f1f011d 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -839,7 +839,7 @@ static void print_constraints(struct regulator_dev *rdev)
 static int machine_constraints_voltage(struct regulator_dev *rdev,
 	struct regulation_constraints *constraints)
 {
-	struct regulator_ops *ops = rdev->desc->ops;
+	const struct regulator_ops *ops = rdev->desc->ops;
 	int ret;
 
 	/* do we need to apply the constraint voltage */
@@ -938,7 +938,7 @@ static int machine_constraints_voltage(struct regulator_dev *rdev,
 static int machine_constraints_current(struct regulator_dev *rdev,
 	struct regulation_constraints *constraints)
 {
-	struct regulator_ops *ops = rdev->desc->ops;
+	const struct regulator_ops *ops = rdev->desc->ops;
 	int ret;
 
 	if (!constraints->min_uA && !constraints->max_uA)
@@ -982,7 +982,7 @@ static int set_machine_constraints(struct regulator_dev *rdev,
 	const struct regulation_constraints *constraints)
 {
 	int ret = 0;
-	struct regulator_ops *ops = rdev->desc->ops;
+	const struct regulator_ops *ops = rdev->desc->ops;
 
 	if (constraints)
 		rdev->constraints = kmemdup(constraints, sizeof(*constraints),
@@ -2208,9 +2208,9 @@ EXPORT_SYMBOL_GPL(regulator_count_voltages);
  */
 int regulator_list_voltage(struct regulator *regulator, unsigned selector)
 {
-	struct regulator_dev	*rdev = regulator->rdev;
-	struct regulator_ops	*ops = rdev->desc->ops;
-	int			ret;
+	struct regulator_dev *rdev = regulator->rdev;
+	const struct regulator_ops *ops = rdev->desc->ops;
+	int ret;
 
 	if (rdev->desc->fixed_uV && rdev->desc->n_voltages == 1 && !selector)
 		return rdev->desc->fixed_uV;
@@ -2572,8 +2572,8 @@ EXPORT_SYMBOL_GPL(regulator_set_voltage);
 int regulator_set_voltage_time(struct regulator *regulator,
 			       int old_uV, int new_uV)
 {
-	struct regulator_dev	*rdev = regulator->rdev;
-	struct regulator_ops	*ops = rdev->desc->ops;
+	struct regulator_dev *rdev = regulator->rdev;
+	const struct regulator_ops *ops = rdev->desc->ops;
 	int old_sel = -1;
 	int new_sel = -1;
 	int voltage;
@@ -3336,9 +3336,9 @@ EXPORT_SYMBOL_GPL(regulator_mode_to_status);
  */
 static int add_regulator_attributes(struct regulator_dev *rdev)
 {
-	struct device		*dev = &rdev->dev;
-	struct regulator_ops	*ops = rdev->desc->ops;
-	int			status = 0;
+	struct device *dev = &rdev->dev;
+	const struct regulator_ops *ops = rdev->desc->ops;
+	int status = 0;
 
 	/* some attributes need specific methods to be displayed */
 	if ((ops->get_voltage && ops->get_voltage(rdev) >= 0) ||
@@ -3905,7 +3905,7 @@ core_initcall(regulator_init);
 static int __init regulator_init_complete(void)
 {
 	struct regulator_dev *rdev;
-	struct regulator_ops *ops;
+	const struct regulator_ops *ops;
 	struct regulation_constraints *c;
 	int enabled, ret;
 

commit a627506a01a787e49b3068f64172c59852c25bb3
Merge: 862f9f840d32 516c1514b089 3bc0312e67f0 778b28b4348a 404d4df260bc
Author: Mark Brown <broonie@linaro.org>
Date:   Tue Aug 5 18:29:21 2014 +0100

    Merge remote-tracking branches 'regulator/topic/da9211', 'regulator/topic/getreg', 'regulator/topic/gpio' and 'regulator/topic/lp872x' into regulator-next

commit 26988efe11b1dc44853035122927ced25578f302
Author: Javier Martinez Canillas <javier.martinez@collabora.co.uk>
Date:   Tue Jul 29 18:28:56 2014 +0200

    regulator: core: Allow to get voltage count and list from parent
    
    Load switches are modeled as regulators but they just provide
    the voltage of their parent input supply. So, the drivers for
    these switches usually neither provide a .list_voltage handler
    not set a .n_voltages count. But there is code in the kernel
    that assumes that all regulators should be able to provide this
    information (e.g: cpufreq and mmc subsystems).
    
    If the voltage count and list are not available for a regulator
    and it has a parent input supply, then use the parent values.
    
    Signed-off-by: Javier Martinez Canillas <javier.martinez@collabora.co.uk>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 57fe446fabce..5299456d07ee 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2182,7 +2182,13 @@ int regulator_count_voltages(struct regulator *regulator)
 {
 	struct regulator_dev	*rdev = regulator->rdev;
 
-	return rdev->desc->n_voltages ? : -EINVAL;
+	if (rdev->desc->n_voltages)
+		return rdev->desc->n_voltages;
+
+	if (!rdev->supply)
+		return -EINVAL;
+
+	return regulator_count_voltages(rdev->supply);
 }
 EXPORT_SYMBOL_GPL(regulator_count_voltages);
 
@@ -2205,12 +2211,17 @@ int regulator_list_voltage(struct regulator *regulator, unsigned selector)
 	if (rdev->desc->fixed_uV && rdev->desc->n_voltages == 1 && !selector)
 		return rdev->desc->fixed_uV;
 
-	if (!ops->list_voltage || selector >= rdev->desc->n_voltages)
+	if (ops->list_voltage) {
+		if (selector >= rdev->desc->n_voltages)
+			return -EINVAL;
+		mutex_lock(&rdev->mutex);
+		ret = ops->list_voltage(rdev, selector);
+		mutex_unlock(&rdev->mutex);
+	} else if (rdev->supply) {
+		ret = regulator_list_voltage(rdev->supply, selector);
+	} else {
 		return -EINVAL;
-
-	mutex_lock(&rdev->mutex);
-	ret = ops->list_voltage(rdev, selector);
-	mutex_unlock(&rdev->mutex);
+	}
 
 	if (ret > 0) {
 		if (ret < rdev->constraints->min_uV)

commit e303996e94b8705c85f3d78f3c094d05b0620c9d
Author: Javier Martinez Canillas <javier.martinez@collabora.co.uk>
Date:   Tue Jul 29 18:28:55 2014 +0200

    regulator: core: Get voltage from parent if not available
    
    Load switches are modeled as regulators but they just provide
    the voltage of their parent input supply. So the drivers for
    these switches usually don't provide a .get_voltage function
    handler but there is code in the kernel that assumes that all
    regulators should be able to provide its current voltage rail.
    
    So, if the output voltage for a regulator is not available and
    it has a parent supply, then pass the voltage of its parent.
    
    Signed-off-by: Javier Martinez Canillas <javier.martinez@collabora.co.uk>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index b4902ab64abe..57fe446fabce 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2620,6 +2620,8 @@ static int _regulator_get_voltage(struct regulator_dev *rdev)
 		ret = rdev->desc->ops->list_voltage(rdev, 0);
 	} else if (rdev->desc->fixed_uV && (rdev->desc->n_voltages == 1)) {
 		ret = rdev->desc->fixed_uV;
+	} else if (rdev->supply) {
+		ret = regulator_get_voltage(rdev->supply);
 	} else {
 		return -EINVAL;
 	}

commit 04eca28cde52cdf9eb91e127cc358ad79a8ec53b
Author: Tuomas Tynkkynen <ttynkkynen@nvidia.com>
Date:   Mon Jul 21 18:38:48 2014 +0300

    regulator: Add helpers for low-level register access
    
    Add helper functions that allow regulator consumers to obtain low-level
    details about the regulator hardware, like the voltage selector register
    address and such. These details can be useful when configuring hardware
    or firmware that want to do low-level access to regulators, with no
    involvement from the kernel.
    
    The use-case for Tegra is a voltage-controlled oscillator clocksource
    which has control logic to change the supply voltage via I2C to achieve
    a desired output clock rate.
    
    Signed-off-by: Tuomas Tynkkynen <ttynkkynen@nvidia.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 4c1f999041dd..486b5908469e 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2221,6 +2221,77 @@ int regulator_list_voltage(struct regulator *regulator, unsigned selector)
 }
 EXPORT_SYMBOL_GPL(regulator_list_voltage);
 
+/**
+ * regulator_get_regmap - get the regulator's register map
+ * @regulator: regulator source
+ *
+ * Returns the register map for the given regulator, or an ERR_PTR value
+ * if the regulator doesn't use regmap.
+ */
+struct regmap *regulator_get_regmap(struct regulator *regulator)
+{
+	struct regmap *map = regulator->rdev->regmap;
+
+	return map ? map : ERR_PTR(-EOPNOTSUPP);
+}
+
+/**
+ * regulator_get_hardware_vsel_register - get the HW voltage selector register
+ * @regulator: regulator source
+ * @vsel_reg: voltage selector register, output parameter
+ * @vsel_mask: mask for voltage selector bitfield, output parameter
+ *
+ * Returns the hardware register offset and bitmask used for setting the
+ * regulator voltage. This might be useful when configuring voltage-scaling
+ * hardware or firmware that can make I2C requests behind the kernel's back,
+ * for example.
+ *
+ * On success, the output parameters @vsel_reg and @vsel_mask are filled in
+ * and 0 is returned, otherwise a negative errno is returned.
+ */
+int regulator_get_hardware_vsel_register(struct regulator *regulator,
+					 unsigned *vsel_reg,
+					 unsigned *vsel_mask)
+{
+	struct regulator_dev	*rdev = regulator->rdev;
+	struct regulator_ops	*ops = rdev->desc->ops;
+
+	if (ops->set_voltage_sel != regulator_set_voltage_sel_regmap)
+		return -EOPNOTSUPP;
+
+	 *vsel_reg = rdev->desc->vsel_reg;
+	 *vsel_mask = rdev->desc->vsel_mask;
+
+	 return 0;
+}
+EXPORT_SYMBOL_GPL(regulator_get_hardware_vsel_register);
+
+/**
+ * regulator_list_hardware_vsel - get the HW-specific register value for a selector
+ * @regulator: regulator source
+ * @selector: identify voltage to list
+ *
+ * Converts the selector to a hardware-specific voltage selector that can be
+ * directly written to the regulator registers. The address of the voltage
+ * register can be determined by calling @regulator_get_hardware_vsel_register.
+ *
+ * On error a negative errno is returned.
+ */
+int regulator_list_hardware_vsel(struct regulator *regulator,
+				 unsigned selector)
+{
+	struct regulator_dev	*rdev = regulator->rdev;
+	struct regulator_ops	*ops = rdev->desc->ops;
+
+	if (selector >= rdev->desc->n_voltages)
+		return -EINVAL;
+	if (ops->set_voltage_sel != regulator_set_voltage_sel_regmap)
+		return -EOPNOTSUPP;
+
+	return selector;
+}
+EXPORT_SYMBOL_GPL(regulator_list_hardware_vsel);
+
 /**
  * regulator_get_linear_step - return the voltage step size between VSEL values
  * @regulator: regulator source

commit 778b28b4348af9c72bb5ac0dc129363a706325ef
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sun Jun 29 17:55:54 2014 +0100

    regulator: core: convert to use gpio_desc internally
    
    Convert the regulator GPIO handling to use a gpio descriptor rather than
    numbers.  This allows us to revise the interfaces to permit all GPIOs
    to be used with the regulator core.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 4c1f999041dd..03ce33387a5d 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -24,6 +24,7 @@
 #include <linux/suspend.h>
 #include <linux/delay.h>
 #include <linux/gpio.h>
+#include <linux/gpio/consumer.h>
 #include <linux/of.h>
 #include <linux/regmap.h>
 #include <linux/regulator/of_regulator.h>
@@ -77,7 +78,7 @@ struct regulator_map {
  */
 struct regulator_enable_gpio {
 	struct list_head list;
-	int gpio;
+	struct gpio_desc *gpiod;
 	u32 enable_count;	/* a number of enabled shared GPIO */
 	u32 request_count;	/* a number of requested shared GPIO */
 	unsigned int ena_gpio_invert:1;
@@ -1660,10 +1661,13 @@ static int regulator_ena_gpio_request(struct regulator_dev *rdev,
 				const struct regulator_config *config)
 {
 	struct regulator_enable_gpio *pin;
+	struct gpio_desc *gpiod;
 	int ret;
 
+	gpiod = gpio_to_desc(config->ena_gpio);
+
 	list_for_each_entry(pin, &regulator_ena_gpio_list, list) {
-		if (pin->gpio == config->ena_gpio) {
+		if (pin->gpiod == gpiod) {
 			rdev_dbg(rdev, "GPIO %d is already used\n",
 				config->ena_gpio);
 			goto update_ena_gpio_to_rdev;
@@ -1682,7 +1686,7 @@ static int regulator_ena_gpio_request(struct regulator_dev *rdev,
 		return -ENOMEM;
 	}
 
-	pin->gpio = config->ena_gpio;
+	pin->gpiod = gpiod;
 	pin->ena_gpio_invert = config->ena_gpio_invert;
 	list_add(&pin->list, &regulator_ena_gpio_list);
 
@@ -1701,10 +1705,10 @@ static void regulator_ena_gpio_free(struct regulator_dev *rdev)
 
 	/* Free the GPIO only in case of no use */
 	list_for_each_entry_safe(pin, n, &regulator_ena_gpio_list, list) {
-		if (pin->gpio == rdev->ena_pin->gpio) {
+		if (pin->gpiod == rdev->ena_pin->gpiod) {
 			if (pin->request_count <= 1) {
 				pin->request_count = 0;
-				gpio_free(pin->gpio);
+				gpiod_put(pin->gpiod);
 				list_del(&pin->list);
 				kfree(pin);
 			} else {
@@ -1732,8 +1736,8 @@ static int regulator_ena_gpio_ctrl(struct regulator_dev *rdev, bool enable)
 	if (enable) {
 		/* Enable GPIO at initial use */
 		if (pin->enable_count == 0)
-			gpio_set_value_cansleep(pin->gpio,
-						!pin->ena_gpio_invert);
+			gpiod_set_value_cansleep(pin->gpiod,
+						 !pin->ena_gpio_invert);
 
 		pin->enable_count++;
 	} else {
@@ -1744,8 +1748,8 @@ static int regulator_ena_gpio_ctrl(struct regulator_dev *rdev, bool enable)
 
 		/* Disable GPIO if not used */
 		if (pin->enable_count <= 1) {
-			gpio_set_value_cansleep(pin->gpio,
-						pin->ena_gpio_invert);
+			gpiod_set_value_cansleep(pin->gpiod,
+						 pin->ena_gpio_invert);
 			pin->enable_count = 0;
 		}
 	}

commit 69d588392b057c0cedb1ba58d7973b77a65997ec
Author: Nishanth Menon <nm@ti.com>
Date:   Wed Jun 4 14:53:25 2014 -0500

    regulator: core: print error value when constraints are not applied
    
    With commit 064d5cd110f94ce41ca5681dcda8b77fa63d5b95
    (regulator: core: Fix the init of DT defined fixed regulators)
    We ensure that regulator must be capable of providing it's current
    voltage when constraints are used, however adding the return value in
    the print is a little more informative to explain the nature of the
    failure involved.
    
    So, instead of providing message such as:
    smps9: failed to get the current voltage
    
    having error value added to the message such as:
    smps9: failed to get the current voltage(-22)
    
    is a little more informative for debugging the error.
    
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 4c1f999041dd..b4902ab64abe 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -846,7 +846,9 @@ static int machine_constraints_voltage(struct regulator_dev *rdev,
 	    rdev->constraints->min_uV == rdev->constraints->max_uV) {
 		int current_uV = _regulator_get_voltage(rdev);
 		if (current_uV < 0) {
-			rdev_err(rdev, "failed to get the current voltage\n");
+			rdev_err(rdev,
+				 "failed to get the current voltage(%d)\n",
+				 current_uV);
 			return current_uV;
 		}
 		if (current_uV < rdev->constraints->min_uV ||
@@ -856,8 +858,8 @@ static int machine_constraints_voltage(struct regulator_dev *rdev,
 				rdev->constraints->max_uV);
 			if (ret < 0) {
 				rdev_err(rdev,
-					"failed to apply %duV constraint\n",
-					rdev->constraints->min_uV);
+					"failed to apply %duV constraint(%d)\n",
+					rdev->constraints->min_uV, ret);
 				return ret;
 			}
 		}

commit 2c7a6a354794714da8aeaea0cf8fd162feb4a7a1
Merge: 8ff15e0909e3 4127f696f964 cfe6e3334eea c0c14e6af9ec 6e27e99613b3 1e050eabb622
Author: Mark Brown <broonie@linaro.org>
Date:   Mon Jun 2 17:08:05 2014 +0100

    Merge remote-tracking branches 'regulator/topic/fixed', 'regulator/topic/id-const', 'regulator/topic/ltc3589', 'regulator/topic/max8649' and 'regulator/topic/of' into regulator-next

commit 42398dbdea411eec0ec3d469df0eeb2e4089d9ab
Merge: dc49f3d5eb93 69c3f7239e29
Author: Mark Brown <broonie@linaro.org>
Date:   Mon Jun 2 17:08:02 2014 +0100

    Merge remote-tracking branch 'regulator/topic/core' into regulator-next

commit 064d5cd110f94ce41ca5681dcda8b77fa63d5b95
Author: Alban Bedel <alban.bedel@avionic-design.de>
Date:   Tue May 20 12:12:16 2014 +0200

    regulator: core: Fix the init of DT defined fixed regulators
    
    When a regulator is defined using DT and it has a single voltage the
    regulator init always tries to apply this voltage. However it fails if
    the regulator isn't settable because it is using an internal low level
    function. To overcome this we now first query the regulator and only
    set it if needed.
    
    Signed-off-by: Alban Bedel <alban.bedel@avionic-design.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 236ca3f1df73..d70f00f8fc66 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -844,13 +844,22 @@ static int machine_constraints_voltage(struct regulator_dev *rdev,
 	/* do we need to apply the constraint voltage */
 	if (rdev->constraints->apply_uV &&
 	    rdev->constraints->min_uV == rdev->constraints->max_uV) {
-		ret = _regulator_do_set_voltage(rdev,
-						rdev->constraints->min_uV,
-						rdev->constraints->max_uV);
-		if (ret < 0) {
-			rdev_err(rdev, "failed to apply %duV constraint\n",
-				 rdev->constraints->min_uV);
-			return ret;
+		int current_uV = _regulator_get_voltage(rdev);
+		if (current_uV < 0) {
+			rdev_err(rdev, "failed to get the current voltage\n");
+			return current_uV;
+		}
+		if (current_uV < rdev->constraints->min_uV ||
+		    current_uV > rdev->constraints->max_uV) {
+			ret = _regulator_do_set_voltage(
+				rdev, rdev->constraints->min_uV,
+				rdev->constraints->max_uV);
+			if (ret < 0) {
+				rdev_err(rdev,
+					"failed to apply %duV constraint\n",
+					rdev->constraints->min_uV);
+				return ret;
+			}
 		}
 	}
 

commit fd482a3e3e20cddfb6d775ec0382f98a92b8a25e
Author: Saravana Kannan <skannan@codeaurora.org>
Date:   Wed Apr 23 18:10:50 2014 -0500

    regulator: core: Disable unused regulators after deferred probing is done
    
    regulator_init_complete does a scan of regulators which dont have
    always-on or consumers are automatically disabled as being unused.
    However, with deferred probing, late_initcall() is too soon to
    declare a regulator as unused as the regulator itself might not
    have registered due to defferal - Example: A regulator deffered due
    to i2bus not available which in turn is deffered due to pinctrl
    availability.
    
    Since deferred probing is done in late_initcall(), do the cleanup of
    unused regulators by regulator_init_complete in late_initcall_sync
    instead of late_initcall.
    
    Cc: Liam Girdwood <lgirdwood@gmail.com>
    Cc: Mark Brown <broonie@kernel.org>
    Cc: Markus Pargmann <mpa@pengutronix.de>
    Signed-off-by: Saravana Kannan <skannan@codeaurora.org>
    [nm@ti.com: minor rewording]
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index e3cb9b66731f..236ca3f1df73 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -3871,4 +3871,4 @@ static int __init regulator_init_complete(void)
 
 	return 0;
 }
-late_initcall(regulator_init_complete);
+late_initcall_sync(regulator_init_complete);

commit e953583456005823d7c20fefe5212f0f60a93fb6
Author: Mark Brown <broonie@linaro.org>
Date:   Sun Jun 1 19:15:16 2014 +0100

    regulator: Don't disable unused regulators we don't have permission for
    
    In the spirit of conservatism that governs our general approach to
    permissions it is better if we don't touch regulators we weren't explicitly
    given permissions to control. This avoids the need to explicitly specify
    unknown regulators in DT as always on, if a regulator is not otherwise
    involved in software control it can be omitted from the DT.
    
    Regulators explicitly given constraints in DT still need to have an always
    on constraint specified as before.
    
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 9a09f3cdbabb..e3cb9b66731f 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -3819,8 +3819,9 @@ static int __init regulator_init_complete(void)
 	mutex_lock(&regulator_list_mutex);
 
 	/* If we have a full configuration then disable any regulators
-	 * which are not in use or always_on.  This will become the
-	 * default behaviour in the future.
+	 * we have permission to change the status for and which are
+	 * not in use or always_on.  This is effectively the default
+	 * for DT and ACPI as they have full constraints.
 	 */
 	list_for_each_entry(rdev, &regulator_list, list) {
 		ops = rdev->desc->ops;
@@ -3829,6 +3830,9 @@ static int __init regulator_init_complete(void)
 		if (c && c->always_on)
 			continue;
 
+		if (c && !(c->valid_ops_mask & REGULATOR_CHANGE_STATUS))
+			continue;
+
 		mutex_lock(&rdev->mutex);
 
 		if (rdev->use_count)

commit 69c3f7239e29216fbf92a39c86b4e9cc63cd6d74
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Wed May 28 12:41:28 2014 -0700

    regulator: Fix regulator_get_{optional,exclusive}() documentation
    
    regulator_get_optional() doesn't hold an exclusive reference to
    the regulator. Fix the documentation and reword the exclusive
    documentation to fix the grammatical error "this reference is
    held".
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 476661117930..d1159badf8ca 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1430,9 +1430,9 @@ EXPORT_SYMBOL_GPL(regulator_get);
  *
  * Returns a struct regulator corresponding to the regulator producer,
  * or IS_ERR() condition containing errno.  Other consumers will be
- * unable to obtain this reference is held and the use count for the
- * regulator will be initialised to reflect the current state of the
- * regulator.
+ * unable to obtain this regulator while this reference is held and the
+ * use count for the regulator will be initialised to reflect the current
+ * state of the regulator.
  *
  * This is intended for use by consumers which cannot tolerate shared
  * use of the regulator such as those which need to force the
@@ -1456,10 +1456,7 @@ EXPORT_SYMBOL_GPL(regulator_get_exclusive);
  * @id: Supply name or regulator ID.
  *
  * Returns a struct regulator corresponding to the regulator producer,
- * or IS_ERR() condition containing errno.  Other consumers will be
- * unable to obtain this reference is held and the use count for the
- * regulator will be initialised to reflect the current state of the
- * regulator.
+ * or IS_ERR() condition containing errno.
  *
  * This is intended for use by consumers for devices which can have
  * some supplies unconnected in normal use, such as some MMC devices.

commit 366986274c548261c42d5ca24391cb4eef3008c2
Author: Axel Lin <axel.lin@ingics.com>
Date:   Sat May 24 11:10:43 2014 +0800

    regulator: core: Use map_voltage_linear_range by default for list_voltage_linear_range
    
    Use map_voltage_linear_range() if list_voltage_linear_range() is in use and
    nothing is set.
    
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index ba28d29b66d2..476661117930 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2322,6 +2322,10 @@ static int _regulator_do_set_voltage(struct regulator_dev *rdev,
 			    regulator_list_voltage_linear)
 				ret = regulator_map_voltage_linear(rdev,
 								min_uV, max_uV);
+			else if (rdev->desc->ops->list_voltage ==
+				 regulator_list_voltage_linear_range)
+				ret = regulator_map_voltage_linear_range(rdev,
+								min_uV, max_uV);
 			else
 				ret = regulator_map_voltage_iterate(rdev,
 								min_uV, max_uV);

commit 9f8c0fe9542141fd0008d5c0f6ae365890f6da94
Author: Lee Jones <lee.jones@linaro.org>
Date:   Fri May 23 16:44:10 2014 +0100

    regulator: Constify the pointer to alias name array
    
    Toughen-up checks for read-only regulator names.
    
    Signed-off-by: Lee Jones <lee.jones@linaro.org>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 9a09f3cdbabb..ba28d29b66d2 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1597,9 +1597,10 @@ EXPORT_SYMBOL_GPL(regulator_unregister_supply_alias);
  * registered any aliases that were registered will be removed
  * before returning to the caller.
  */
-int regulator_bulk_register_supply_alias(struct device *dev, const char **id,
+int regulator_bulk_register_supply_alias(struct device *dev,
+					 const char *const *id,
 					 struct device *alias_dev,
-					 const char **alias_id,
+					 const char *const *alias_id,
 					 int num_id)
 {
 	int i;
@@ -1637,7 +1638,7 @@ EXPORT_SYMBOL_GPL(regulator_bulk_register_supply_alias);
  * aliases in one operation.
  */
 void regulator_bulk_unregister_supply_alias(struct device *dev,
-					    const char **id,
+					    const char *const *id,
 					    int num_id)
 {
 	int i;

commit 63c7c9e16c8e92cc069854f2babdf82d2d38e4c7
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Thu Apr 3 15:32:17 2014 +0100

    regulator: core: Get and put regulator of_node
    
    Currently the regulator core does not take an additional reference to
    the of_node it is passed. This means that the caller must ensure that
    the of_node is valid for the duration of the regulator's existance.
    It is reasonable for the framework to assume it is passed a valid
    of_node but seems onerous for it to assume the caller will keep the node
    valid for the life-time of the regulator, especially when
    devm_regulator_register is used and there will likely be no code in the
    driver called at the point it would be safe to put the of_node.
    
    This patch adds an additional of_node_get when the regulator is
    registered and an of_node_put when it is unregistered in the core. This
    means individual drivers are free to put their of_node references at the
    end of probe letting the regulator core handling it from there. This
    simplifies code on the driver side.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 9a09f3cdbabb..b97ffd2365d3 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -3447,7 +3447,7 @@ regulator_register(const struct regulator_desc *regulator_desc,
 
 	/* register with sysfs */
 	rdev->dev.class = &regulator_class;
-	rdev->dev.of_node = config->of_node;
+	rdev->dev.of_node = of_node_get(config->of_node);
 	rdev->dev.parent = dev;
 	dev_set_name(&rdev->dev, "regulator.%d",
 		     atomic_inc_return(&regulator_no) - 1);
@@ -3589,6 +3589,7 @@ void regulator_unregister(struct regulator_dev *rdev)
 	list_del(&rdev->list);
 	kfree(rdev->constraints);
 	regulator_ena_gpio_free(rdev);
+	of_node_put(rdev->dev.of_node);
 	device_unregister(&rdev->dev);
 	mutex_unlock(&regulator_list_mutex);
 }

commit 159d8133d0b54a501a41a66fe3a0e7d16405e36d
Merge: 05bf58ca4b8f c800bcd5f53f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Apr 2 16:23:38 2014 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial
    
    Pull trivial tree updates from Jiri Kosina:
     "Usual rocket science -- mostly documentation and comment updates"
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial:
      sparse: fix comment
      doc: fix double words
      isdn: capi: fix "CAPI_VERSION" comment
      doc: DocBook: Fix typos in xml and template file
      Bluetooth: add module name for btwilink
      driver core: unexport static function create_syslog_header
      mmc: core: typo fix in printk specifier
      ARM: spear: clean up editing mistake
      net-sysfs: fix comment typo 'CONFIG_SYFS'
      doc: Insert MODULE_ in module-signing macros
      Documentation: update URL to hfsplus Technote 1150
      gpio: update path to documentation
      ixgbe: Fix format string in ixgbe_fcoe.
      Kconfig: Remove useless "default N" lines
      user_namespace.c: Remove duplicated word in comment
      CREDITS: fix formatting
      treewide: Fix typo in Documentation/DocBook
      mm: Fix warning on make htmldocs caused by slab.c
      ata: ata-samsung_cf: cleanup in header file
      idr: remove unused prototype of idr_free()

commit 29dbdcf3163bc05aad758e978abb66cf161e6d0e
Merge: b098d6726bbf 8669544a788a
Author: Mark Brown <broonie@linaro.org>
Date:   Wed Mar 26 16:57:44 2014 +0000

    Merge remote-tracking branch 'regulator/topic/core' into regulator-next

commit 16e3f5391c23a52a91a11ee4f2661a625b36dfe1
Merge: 3f803abf2e49 66fda75f47dc
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Mar 4 08:41:42 2014 -0800

    Merge tag 'regulator-v3.14-rc5' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/regulator
    
    Pull regulator fixes from Mark Brown:
     "A couple of fixes here which ensure that regulators using the core
      support for GPIO enables work in all cases by ensuring that helpers
      are used consistently rather than open coding in places and hence not
      having GPIO support in some of them"
    
    * tag 'regulator-v3.14-rc5' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/regulator:
      regulator: core: Replace direct ops->disable usage
      regulator: core: Replace direct ops->enable usage

commit 66fda75f47dc583f1c187556e9a2c082dd64f8c6
Author: Markus Pargmann <mpa@pengutronix.de>
Date:   Thu Feb 20 17:36:04 2014 +0100

    regulator: core: Replace direct ops->disable usage
    
    There are many places where ops->disable is called directly. Instead we
    should use _regulator_do_disable() which also handles gpio regulators.
    
    To be able to use the wrapper function from _regulator_force_disable(),
    I moved the _notifier_call_chain() call from _regulator_do_disable() to
    _regulator_disable(). This way, _regulator_force_disable() can use
    different flags for _notifier_call_chain() without calling it twice.
    
    Cc: <stable@vger.kernel.org> # 3.10+
    Signed-off-by: Markus Pargmann <mpa@pengutronix.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 00feec321e3c..6f7198516fef 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1901,8 +1901,6 @@ static int _regulator_do_disable(struct regulator_dev *rdev)
 
 	trace_regulator_disable_complete(rdev_get_name(rdev));
 
-	_notifier_call_chain(rdev, REGULATOR_EVENT_DISABLE,
-			     NULL);
 	return 0;
 }
 
@@ -1926,6 +1924,8 @@ static int _regulator_disable(struct regulator_dev *rdev)
 				rdev_err(rdev, "failed to disable\n");
 				return ret;
 			}
+			_notifier_call_chain(rdev, REGULATOR_EVENT_DISABLE,
+					NULL);
 		}
 
 		rdev->use_count = 0;
@@ -1978,20 +1978,16 @@ static int _regulator_force_disable(struct regulator_dev *rdev)
 {
 	int ret = 0;
 
-	/* force disable */
-	if (rdev->desc->ops->disable) {
-		/* ah well, who wants to live forever... */
-		ret = rdev->desc->ops->disable(rdev);
-		if (ret < 0) {
-			rdev_err(rdev, "failed to force disable\n");
-			return ret;
-		}
-		/* notify other consumers that power has been forced off */
-		_notifier_call_chain(rdev, REGULATOR_EVENT_FORCE_DISABLE |
-			REGULATOR_EVENT_DISABLE, NULL);
+	ret = _regulator_do_disable(rdev);
+	if (ret < 0) {
+		rdev_err(rdev, "failed to force disable\n");
+		return ret;
 	}
 
-	return ret;
+	_notifier_call_chain(rdev, REGULATOR_EVENT_FORCE_DISABLE |
+			REGULATOR_EVENT_DISABLE, NULL);
+
+	return 0;
 }
 
 /**
@@ -3624,8 +3620,6 @@ int regulator_suspend_finish(void)
 
 	mutex_lock(&regulator_list_mutex);
 	list_for_each_entry(rdev, &regulator_list, list) {
-		struct regulator_ops *ops = rdev->desc->ops;
-
 		mutex_lock(&rdev->mutex);
 		if (rdev->use_count > 0  || rdev->constraints->always_on) {
 			error = _regulator_do_enable(rdev);
@@ -3634,12 +3628,10 @@ int regulator_suspend_finish(void)
 		} else {
 			if (!have_full_constraints())
 				goto unlock;
-			if (!ops->disable)
-				goto unlock;
 			if (!_regulator_is_enabled(rdev))
 				goto unlock;
 
-			error = ops->disable(rdev);
+			error = _regulator_do_disable(rdev);
 			if (error)
 				ret = error;
 		}
@@ -3813,7 +3805,7 @@ static int __init regulator_init_complete(void)
 		ops = rdev->desc->ops;
 		c = rdev->constraints;
 
-		if (!ops->disable || (c && c->always_on))
+		if (c && c->always_on)
 			continue;
 
 		mutex_lock(&rdev->mutex);
@@ -3834,7 +3826,7 @@ static int __init regulator_init_complete(void)
 			/* We log since this may kill the system if it
 			 * goes wrong. */
 			rdev_info(rdev, "disabling\n");
-			ret = ops->disable(rdev);
+			ret = _regulator_do_disable(rdev);
 			if (ret != 0)
 				rdev_err(rdev, "couldn't disable: %d\n", ret);
 		} else {

commit 30c219710358c5cca2f8bd2e9e547c6aadf7cf8b
Author: Markus Pargmann <mpa@pengutronix.de>
Date:   Thu Feb 20 17:36:03 2014 +0100

    regulator: core: Replace direct ops->enable usage
    
    There are some direct ops->enable in the regulator core driver. This is
    a potential issue as the function _regulator_do_enable() handles gpio
    regulators and the normal ops->enable calls. These gpio regulators are
    simply ignored when ops->enable is called directly.
    
    One possible bug is that boot-on and always-on gpio regulators are not
    enabled on registration.
    
    This patch replaces all ops->enable calls by _regulator_do_enable.
    
    [Handle missing enable operations -- broonie]
    
    Cc: <stable@vger.kernel.org> # 3.10+
    Signed-off-by: Markus Pargmann <mpa@pengutronix.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>
    
    regulator: Handle invalid enable operation for always/boot on regulators
    
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 74e9fb2e52e7..00feec321e3c 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -953,6 +953,8 @@ static int machine_constraints_current(struct regulator_dev *rdev,
 	return 0;
 }
 
+static int _regulator_do_enable(struct regulator_dev *rdev);
+
 /**
  * set_machine_constraints - sets regulator constraints
  * @rdev: regulator source
@@ -1013,10 +1015,9 @@ static int set_machine_constraints(struct regulator_dev *rdev,
 	/* If the constraints say the regulator should be on at this point
 	 * and we have control then make sure it is enabled.
 	 */
-	if ((rdev->constraints->always_on || rdev->constraints->boot_on) &&
-	    ops->enable) {
-		ret = ops->enable(rdev);
-		if (ret < 0) {
+	if (rdev->constraints->always_on || rdev->constraints->boot_on) {
+		ret = _regulator_do_enable(rdev);
+		if (ret < 0 && ret != -EINVAL) {
 			rdev_err(rdev, "failed to enable\n");
 			goto out;
 		}
@@ -3626,9 +3627,8 @@ int regulator_suspend_finish(void)
 		struct regulator_ops *ops = rdev->desc->ops;
 
 		mutex_lock(&rdev->mutex);
-		if ((rdev->use_count > 0  || rdev->constraints->always_on) &&
-				ops->enable) {
-			error = ops->enable(rdev);
+		if (rdev->use_count > 0  || rdev->constraints->always_on) {
+			error = _regulator_do_enable(rdev);
 			if (error)
 				ret = error;
 		} else {

commit f29d778fa47aacb4b0e7dede603756ac782c9391
Merge: 6d0abeca3242 acc3d5cec84f
Author: Mark Brown <broonie@linaro.org>
Date:   Sun Feb 23 12:22:18 2014 +0900

    Merge remote-tracking branch 'regulator/fix/core' into regulator-linus

commit acc3d5cec84f82ebea535fa0bd9500ac3df2aee9
Author: Shuah Khan <shuah.kh@samsung.com>
Date:   Thu Feb 20 12:58:15 2014 -0700

    regulator: core: Change dummy supplies error message to a warning
    
    Change "dummy supplies not allowed" error message to warning instead, as this
    is a just warning message with no change to the behavior.
    
    [Added a CC to stable since some other bug fixes cause this to come up
    more frequently on PCs which is how it was noticed -- broonie]
    
    Signed-off-by: Shuah Khan <shuah.kh@samsung.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>
    Cc: stable@vger.kernel.org

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index b38a6b669e8c..74e9fb2e52e7 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1352,7 +1352,7 @@ static struct regulator *_regulator_get(struct device *dev, const char *id,
 		goto found;
 	/* Don't log an error when called from regulator_get_optional() */
 	} else if (!have_full_constraints() || exclusive) {
-		dev_err(dev, "dummy supplies not allowed\n");
+		dev_warn(dev, "dummy supplies not allowed\n");
 	}
 
 	mutex_unlock(&regulator_list_mutex);

commit d4263348f796f29546f90802177865dd4379dd0a
Merge: be873ac782f5 6d0abeca3242
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Thu Feb 20 14:54:28 2014 +0100

    Merge branch 'master' into for-next

commit e227867f12302633737bd2a48a10a9a72c0630cb
Author: Masanari Iida <standby24x7@gmail.com>
Date:   Tue Feb 18 22:54:36 2014 +0900

    treewide: Fix typo in Documentation/DocBook
    
    This patch fix spelling typo in Documentation/DocBook.
    It is because .html and .xml files are generated by make htmldocs,
    I have to fix a typo within the source files.
    
    Signed-off-by: Masanari Iida <standby24x7@gmail.com>
    Acked-by: Randy Dunlap <rdunlap@infradead.org>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index d85f31385b24..d59aa96a4dc4 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2134,7 +2134,7 @@ EXPORT_SYMBOL_GPL(regulator_is_enabled);
  * @regulator: regulator source
  *
  * Returns positive if the regulator driver backing the source/client
- * can change its voltage, false otherwise. Usefull for detecting fixed
+ * can change its voltage, false otherwise. Useful for detecting fixed
  * or dummy regulators and disabling voltage change logic in the client
  * driver.
  */

commit c00dc359e5e0b10de993651d8e73e60c41bf29cd
Author: Bjorn Andersson <bjorn@kryo.se>
Date:   Wed Feb 5 12:30:26 2014 -0800

    regulator: core: Allow regulator_set_voltage for fixed regulators
    
    Make it okay to call regulator_set_voltage on regulators with fixed
    voltage if the requested range overlaps the current/configured voltage.
    
    Signed-off-by: Bjorn Andersson <bjorn.andersson@sonymobile.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index b38a6b669e8c..0cd1a3b8e589 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2395,6 +2395,7 @@ int regulator_set_voltage(struct regulator *regulator, int min_uV, int max_uV)
 	struct regulator_dev *rdev = regulator->rdev;
 	int ret = 0;
 	int old_min_uV, old_max_uV;
+	int current_uV;
 
 	mutex_lock(&rdev->mutex);
 
@@ -2405,6 +2406,19 @@ int regulator_set_voltage(struct regulator *regulator, int min_uV, int max_uV)
 	if (regulator->min_uV == min_uV && regulator->max_uV == max_uV)
 		goto out;
 
+	/* If we're trying to set a range that overlaps the current voltage,
+	 * return succesfully even though the regulator does not support
+	 * changing the voltage.
+	 */
+	if (!(rdev->constraints->valid_ops_mask & REGULATOR_CHANGE_VOLTAGE)) {
+		current_uV = _regulator_get_voltage(rdev);
+		if (min_uV <= current_uV && current_uV <= max_uV) {
+			regulator->min_uV = min_uV;
+			regulator->max_uV = max_uV;
+			goto out;
+		}
+	}
+
 	/* sanity check */
 	if (!rdev->desc->ops->set_voltage &&
 	    !rdev->desc->ops->set_voltage_sel) {

commit 317b5684d52269b75b4ec6480f9dac056d0d4ba8
Author: Mark Brown <broonie@linaro.org>
Date:   Mon Jan 27 17:34:07 2014 +0000

    regulator: core: Correct default return value for full constraints
    
    Once we have full constraints then all supply mappings should be known to
    the regulator API. This means that we should treat failed lookups as fatal
    rather than deferring in the hope of further registrations but this was
    broken by commit 9b92da1f1205bd25 "regulator: core: Fix default return
    value for _get()" which was targeted at DT systems but unintentionally
    broke non-DT systems by changing the default return value.
    
    Fix this by explicitly returning -EPROBE_DEFER from the DT lookup if we
    find a property but no corresponding regulator and by having the non-DT
    case default to -ENODEV when we have full constraints.
    
    Fixes: 9b92da1f1205bd25 "regulator: core: Fix default return value for _get()"
    Signed-off-by: Mark Brown <broonie@linaro.org>
    Tested-by: Guenter Roeck <linux@roeck-us.net>
    Cc: stable@vger.kernel.org

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index b38a6b669e8c..16a309e5c024 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1272,6 +1272,8 @@ static struct regulator_dev *regulator_dev_lookup(struct device *dev,
 				if (r->dev.parent &&
 					node == r->dev.of_node)
 					return r;
+			*ret = -EPROBE_DEFER;
+			return NULL;
 		} else {
 			/*
 			 * If we couldn't even get the node then it's
@@ -1312,7 +1314,7 @@ static struct regulator *_regulator_get(struct device *dev, const char *id,
 	struct regulator_dev *rdev;
 	struct regulator *regulator = ERR_PTR(-EPROBE_DEFER);
 	const char *devname = NULL;
-	int ret = -EPROBE_DEFER;
+	int ret;
 
 	if (id == NULL) {
 		pr_err("get() with no identifier\n");
@@ -1322,6 +1324,11 @@ static struct regulator *_regulator_get(struct device *dev, const char *id,
 	if (dev)
 		devname = dev_name(dev);
 
+	if (have_full_constraints())
+		ret = -ENODEV;
+	else
+		ret = -EPROBE_DEFER;
+
 	mutex_lock(&regulator_list_mutex);
 
 	rdev = regulator_dev_lookup(dev, id, &ret);

commit 0d25d09de114bffc984a03c417d4dddb53acd8d8
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Wed Jan 8 10:02:16 2014 +0900

    regulator: core: Fix checkpatch issue
    
    Fix the following checkpatch errors and warnings.
    
      ERROR: trailing whitespace
      ERROR: return is not a function, parentheses are not required
      WARNING: braces {} are not necessary for single statement blocks
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 9888f26aa131..b38a6b669e8c 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1334,9 +1334,8 @@ static struct regulator *_regulator_get(struct device *dev, const char *id,
 	 * If we have return value from dev_lookup fail, we do not expect to
 	 * succeed, so, quit with appropriate error value
 	 */
-	if (ret && ret != -ENODEV) {
+	if (ret && ret != -ENODEV)
 		goto out;
-	}
 
 	if (!devname)
 		devname = "deviceless";
@@ -2245,7 +2244,7 @@ int regulator_is_supported_voltage(struct regulator *regulator,
 	if (!(rdev->constraints->valid_ops_mask & REGULATOR_CHANGE_VOLTAGE)) {
 		ret = regulator_get_voltage(regulator);
 		if (ret >= 0)
-			return (min_uV <= ret && ret <= max_uV);
+			return min_uV <= ret && ret <= max_uV;
 		else
 			return ret;
 	}
@@ -2417,7 +2416,7 @@ int regulator_set_voltage(struct regulator *regulator, int min_uV, int max_uV)
 	ret = regulator_check_voltage(rdev, &min_uV, &max_uV);
 	if (ret < 0)
 		goto out;
-	
+
 	/* restore original values in case of error */
 	old_min_uV = regulator->min_uV;
 	old_max_uV = regulator->max_uV;
@@ -2431,7 +2430,7 @@ int regulator_set_voltage(struct regulator *regulator, int min_uV, int max_uV)
 	ret = _regulator_do_set_voltage(rdev, min_uV, max_uV);
 	if (ret < 0)
 		goto out2;
-	
+
 out:
 	mutex_unlock(&rdev->mutex);
 	return ret;
@@ -3836,9 +3835,8 @@ static int __init regulator_init_complete(void)
 			 * goes wrong. */
 			rdev_info(rdev, "disabling\n");
 			ret = ops->disable(rdev);
-			if (ret != 0) {
+			if (ret != 0)
 				rdev_err(rdev, "couldn't disable: %d\n", ret);
-			}
 		} else {
 			/* The intention is that in future we will
 			 * assume that full constraints are provided

commit 0781719bd6614e60dd5fff1b5cd45dbce2f7dd2d
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Tue Dec 17 16:24:57 2013 +0100

    regulator: core: don't print an error when no regulator is found
    
    Only print an error when _regulator_get() is expected to return a valid
    regulator, that is when _regulator_get() is called from regulator_get() and
    we're not using the dummy because we don't have full-constraints, or when
    _regulator_get() is called from regulator_get_exclusive() in which case
    returning a dummy is not allowed.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index d85f31385b24..9888f26aa131 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1351,7 +1351,8 @@ static struct regulator *_regulator_get(struct device *dev, const char *id,
 
 		rdev = dummy_regulator_rdev;
 		goto found;
-	} else {
+	/* Don't log an error when called from regulator_get_optional() */
+	} else if (!have_full_constraints() || exclusive) {
 		dev_err(dev, "dummy supplies not allowed\n");
 	}
 

commit 334a82086d6428ede052c4cd11ee588bcdf2a9e8
Merge: 67cc68855484 75bc9641cadd
Author: Mark Brown <broonie@linaro.org>
Date:   Fri Dec 13 13:44:57 2013 +0000

    Merge remote-tracking branch 'regulator/topic/constraints' into regulator-linus

commit 75bc9641cadd2a3f91f9c2e7f2fdfdeb8bd4b1d6
Author: Mark Brown <broonie@linaro.org>
Date:   Wed Nov 27 16:22:53 2013 +0000

    regulator: core: Check for DT every time we check full constraints
    
    Eliminate the gap between DT becoming available and this being used to say
    we have full constraints by checking directly for DT every time we check
    for full constraints. This improves interoperaton with optional regulator
    support.
    
    Signed-off-by: Mark Brown <broonie@linaro.org>
    Tested-by: Fabio Estevam <fabio.estevam@freescale.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 1f314921774d..6a75794ab20d 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -121,7 +121,7 @@ static const char *rdev_get_name(struct regulator_dev *rdev)
 
 static bool have_full_constraints(void)
 {
-	return has_full_constraints;
+	return has_full_constraints || of_have_populated_dt();
 }
 
 /**

commit 87b2841753e1694fc96fefb467f6aff9940b07af
Author: Mark Brown <broonie@linaro.org>
Date:   Wed Nov 27 16:13:10 2013 +0000

    regulator: core: Replace checks of have_full_constraints with a function
    
    Simple code reorganisation so we can change the logic for deciding what
    full constraints are more easily.
    
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 6382f0af353b..1f314921774d 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -119,6 +119,11 @@ static const char *rdev_get_name(struct regulator_dev *rdev)
 		return "";
 }
 
+static bool have_full_constraints(void)
+{
+	return has_full_constraints;
+}
+
 /**
  * of_get_regulator - get a regulator device node based on supply name
  * @dev: Device pointer for the consumer (of regulator) device
@@ -1340,7 +1345,7 @@ static struct regulator *_regulator_get(struct device *dev, const char *id,
 	 * Assume that a regulator is physically present and enabled
 	 * even if it isn't hooked up and just provide a dummy.
 	 */
-	if (has_full_constraints && allow_dummy) {
+	if (have_full_constraints() && allow_dummy) {
 		pr_warn("%s supply %s not found, using dummy regulator\n",
 			devname, id);
 
@@ -3624,7 +3629,7 @@ int regulator_suspend_finish(void)
 			if (error)
 				ret = error;
 		} else {
-			if (!has_full_constraints)
+			if (!have_full_constraints())
 				goto unlock;
 			if (!ops->disable)
 				goto unlock;
@@ -3822,7 +3827,7 @@ static int __init regulator_init_complete(void)
 		if (!enabled)
 			goto unlock;
 
-		if (has_full_constraints) {
+		if (have_full_constraints()) {
 			/* We log since this may kill the system if it
 			 * goes wrong. */
 			rdev_info(rdev, "disabling\n");

commit f446043f1aa74c2d699db48ba4a7a075b88dc14d
Author: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
Date:   Wed Nov 13 12:33:00 2013 +0100

    regulator: fixed: fix regulator_list_voltage() for regression
    
    Commit c368e5fc2a190923b786f2de3e79430ea3566a25 "regulator: fixed:
    get rid of {get|list}_voltage()" broke regulator_list_voltage() for
    the fixed regulator, because an earlier commit
    5a523605afa7d3b54b2e7041f8c9e6bc39872a7e "regulator: core: provide
    fixed voltage in desc for single voltage rail" missed to add support
    for the fixed-voltage special case to that function. This patch
    fixes that regression.
    
    Signed-off-by: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
    Acked-by: Laxman Dewangan <ldewangan@nvidia.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 6382f0af353b..3fe13130baec 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2184,6 +2184,9 @@ int regulator_list_voltage(struct regulator *regulator, unsigned selector)
 	struct regulator_ops	*ops = rdev->desc->ops;
 	int			ret;
 
+	if (rdev->desc->fixed_uV && rdev->desc->n_voltages == 1 && !selector)
+		return rdev->desc->fixed_uV;
+
 	if (!ops->list_voltage || selector >= rdev->desc->n_voltages)
 		return -EINVAL;
 

commit aef393da7501693a1b91a1cfed1a9ea408ceabe6
Merge: 88c260a18081 4040394e12cb
Author: Mark Brown <broonie@linaro.org>
Date:   Thu Oct 24 11:11:39 2013 +0100

    Merge remote-tracking branch 'regulator/topic/optional' into regulator-next

commit 706664c290d69f890a9e3acfc6a8196098459826
Merge: b735e47f6e94 609d5f6ddc18
Author: Mark Brown <broonie@linaro.org>
Date:   Thu Oct 24 11:11:36 2013 +0100

    Merge remote-tracking branch 'regulator/topic/fixed' into regulator-next

commit 81e439f476a397af695e8141df6e7324a8ac4893
Merge: cea64d8c0892 5df529d440aa
Author: Mark Brown <broonie@linaro.org>
Date:   Thu Oct 24 11:11:33 2013 +0100

    Merge remote-tracking branch 'regulator/topic/core' into regulator-next

commit a06ccd9c3785fa5550917ae036944f4e080b5749
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Tue Oct 15 20:14:20 2013 +0100

    regulator: core: Add ability to create a lookup alias for supply
    
    These patches add the ability to create an alternative device on which
    a lookup for a certain supply should be conducted.
    
    A common use-case for this would be devices that are logically
    represented as a collection of drivers within Linux but are are
    presented as a single device from device tree. It this case it is
    necessary for each sub device to locate their supply data on the main
    device.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 906deb7354ed..16427de56ce8 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -53,6 +53,7 @@ static DEFINE_MUTEX(regulator_list_mutex);
 static LIST_HEAD(regulator_list);
 static LIST_HEAD(regulator_map_list);
 static LIST_HEAD(regulator_ena_gpio_list);
+static LIST_HEAD(regulator_supply_alias_list);
 static bool has_full_constraints;
 static bool board_wants_dummy_regulator;
 
@@ -83,6 +84,19 @@ struct regulator_enable_gpio {
 	unsigned int ena_gpio_invert:1;
 };
 
+/*
+ * struct regulator_supply_alias
+ *
+ * Used to map lookups for a supply onto an alternative device.
+ */
+struct regulator_supply_alias {
+	struct list_head list;
+	struct device *src_dev;
+	const char *src_supply;
+	struct device *alias_dev;
+	const char *alias_supply;
+};
+
 static int _regulator_is_enabled(struct regulator_dev *rdev);
 static int _regulator_disable(struct regulator_dev *rdev);
 static int _regulator_get_voltage(struct regulator_dev *rdev);
@@ -1173,6 +1187,32 @@ static int _regulator_get_enable_time(struct regulator_dev *rdev)
 	return rdev->desc->ops->enable_time(rdev);
 }
 
+static struct regulator_supply_alias *regulator_find_supply_alias(
+		struct device *dev, const char *supply)
+{
+	struct regulator_supply_alias *map;
+
+	list_for_each_entry(map, &regulator_supply_alias_list, list)
+		if (map->src_dev == dev && strcmp(map->src_supply, supply) == 0)
+			return map;
+
+	return NULL;
+}
+
+static void regulator_supply_alias(struct device **dev, const char **supply)
+{
+	struct regulator_supply_alias *map;
+
+	map = regulator_find_supply_alias(*dev, *supply);
+	if (map) {
+		dev_dbg(*dev, "Mapping supply %s to %s,%s\n",
+				*supply, map->alias_supply,
+				dev_name(map->alias_dev));
+		*dev = map->alias_dev;
+		*supply = map->alias_supply;
+	}
+}
+
 static struct regulator_dev *regulator_dev_lookup(struct device *dev,
 						  const char *supply,
 						  int *ret)
@@ -1182,6 +1222,8 @@ static struct regulator_dev *regulator_dev_lookup(struct device *dev,
 	struct regulator_map *map;
 	const char *devname = NULL;
 
+	regulator_supply_alias(&dev, &supply);
+
 	/* first do a dt based lookup */
 	if (dev && dev->of_node) {
 		node = of_get_regulator(dev, supply);
@@ -1432,6 +1474,134 @@ void regulator_put(struct regulator *regulator)
 }
 EXPORT_SYMBOL_GPL(regulator_put);
 
+/**
+ * regulator_register_supply_alias - Provide device alias for supply lookup
+ *
+ * @dev: device that will be given as the regulator "consumer"
+ * @id: Supply name or regulator ID
+ * @alias_dev: device that should be used to lookup the supply
+ * @alias_id: Supply name or regulator ID that should be used to lookup the
+ * supply
+ *
+ * All lookups for id on dev will instead be conducted for alias_id on
+ * alias_dev.
+ */
+int regulator_register_supply_alias(struct device *dev, const char *id,
+				    struct device *alias_dev,
+				    const char *alias_id)
+{
+	struct regulator_supply_alias *map;
+
+	map = regulator_find_supply_alias(dev, id);
+	if (map)
+		return -EEXIST;
+
+	map = kzalloc(sizeof(struct regulator_supply_alias), GFP_KERNEL);
+	if (!map)
+		return -ENOMEM;
+
+	map->src_dev = dev;
+	map->src_supply = id;
+	map->alias_dev = alias_dev;
+	map->alias_supply = alias_id;
+
+	list_add(&map->list, &regulator_supply_alias_list);
+
+	pr_info("Adding alias for supply %s,%s -> %s,%s\n",
+		id, dev_name(dev), alias_id, dev_name(alias_dev));
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(regulator_register_supply_alias);
+
+/**
+ * regulator_unregister_supply_alias - Remove device alias
+ *
+ * @dev: device that will be given as the regulator "consumer"
+ * @id: Supply name or regulator ID
+ *
+ * Remove a lookup alias if one exists for id on dev.
+ */
+void regulator_unregister_supply_alias(struct device *dev, const char *id)
+{
+	struct regulator_supply_alias *map;
+
+	map = regulator_find_supply_alias(dev, id);
+	if (map) {
+		list_del(&map->list);
+		kfree(map);
+	}
+}
+EXPORT_SYMBOL_GPL(regulator_unregister_supply_alias);
+
+/**
+ * regulator_bulk_register_supply_alias - register multiple aliases
+ *
+ * @dev: device that will be given as the regulator "consumer"
+ * @id: List of supply names or regulator IDs
+ * @alias_dev: device that should be used to lookup the supply
+ * @alias_id: List of supply names or regulator IDs that should be used to
+ * lookup the supply
+ * @num_id: Number of aliases to register
+ *
+ * @return 0 on success, an errno on failure.
+ *
+ * This helper function allows drivers to register several supply
+ * aliases in one operation.  If any of the aliases cannot be
+ * registered any aliases that were registered will be removed
+ * before returning to the caller.
+ */
+int regulator_bulk_register_supply_alias(struct device *dev, const char **id,
+					 struct device *alias_dev,
+					 const char **alias_id,
+					 int num_id)
+{
+	int i;
+	int ret;
+
+	for (i = 0; i < num_id; ++i) {
+		ret = regulator_register_supply_alias(dev, id[i], alias_dev,
+						      alias_id[i]);
+		if (ret < 0)
+			goto err;
+	}
+
+	return 0;
+
+err:
+	dev_err(dev,
+		"Failed to create supply alias %s,%s -> %s,%s\n",
+		id[i], dev_name(dev), alias_id[i], dev_name(alias_dev));
+
+	while (--i >= 0)
+		regulator_unregister_supply_alias(dev, id[i]);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(regulator_bulk_register_supply_alias);
+
+/**
+ * regulator_bulk_unregister_supply_alias - unregister multiple aliases
+ *
+ * @dev: device that will be given as the regulator "consumer"
+ * @id: List of supply names or regulator IDs
+ * @num_id: Number of aliases to unregister
+ *
+ * This helper function allows drivers to unregister several supply
+ * aliases in one operation.
+ */
+void regulator_bulk_unregister_supply_alias(struct device *dev,
+					    const char **id,
+					    int num_id)
+{
+	int i;
+
+	for (i = 0; i < num_id; ++i)
+		regulator_unregister_supply_alias(dev, id[i]);
+}
+EXPORT_SYMBOL_GPL(regulator_bulk_unregister_supply_alias);
+
+
 /* Manage enable GPIO list. Same GPIO pin can be shared among regulators */
 static int regulator_ena_gpio_request(struct regulator_dev *rdev,
 				const struct regulator_config *config)

commit 4040394e12cb1eed21d1306cacdc8a6f0464c8e2
Author: Mark Brown <broonie@linaro.org>
Date:   Fri Oct 4 11:42:53 2013 +0100

    regulator: core: Always warn when using a dummy regulator
    
    This helps people spot if they have missed a supply from a device tree or
    equivalent data structure.
    
    Suggested-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index a40055edaae4..82805e2d8a64 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1281,13 +1281,8 @@ static struct regulator *_regulator_get(struct device *dev, const char *id,
 	 * even if it isn't hooked up and just provide a dummy.
 	 */
 	if (has_full_constraints && allow_dummy) {
-		/*
-		 * Log the substitution if regulator configuration is
-		 * not complete to help development.
-		 */
-		if (!has_full_constraints)
-			pr_warn("%s supply %s not found, using dummy regulator\n",
-				devname, id);
+		pr_warn("%s supply %s not found, using dummy regulator\n",
+			devname, id);
 
 		rdev = dummy_regulator_rdev;
 		goto found;

commit 5df529d440aa4f0e67be9af3718e7edf05db7d02
Author: Thierry Reding <thierry.reding@gmail.com>
Date:   Fri Sep 20 13:51:56 2013 +0200

    regulator: core: Reduce busy-wait looping
    
    Keep busy-wait looping to a minimum while waiting for a regulator to
    ramp-up to the target voltage. This follows the guidelines set forth
    in Documentation/timers/timers-howto.txt and assumes that regulators
    are never enabled in atomic context.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index ad154247bb90..5075ed1e94a6 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1740,11 +1740,39 @@ static int _regulator_do_enable(struct regulator_dev *rdev)
 	 * together.  */
 	trace_regulator_enable_delay(rdev_get_name(rdev));
 
-	if (delay >= 1000) {
-		mdelay(delay / 1000);
-		udelay(delay % 1000);
-	} else if (delay) {
-		udelay(delay);
+	/*
+	 * Delay for the requested amount of time as per the guidelines in:
+	 *
+	 *     Documentation/timers/timers-howto.txt
+	 *
+	 * The assumption here is that regulators will never be enabled in
+	 * atomic context and therefore sleeping functions can be used.
+	 */
+	if (delay) {
+		unsigned int ms = delay / 1000;
+		unsigned int us = delay % 1000;
+
+		if (ms > 0) {
+			/*
+			 * For small enough values, handle super-millisecond
+			 * delays in the usleep_range() call below.
+			 */
+			if (ms < 20)
+				us += ms * 1000;
+			else
+				msleep(ms);
+		}
+
+		/*
+		 * Give the scheduler some room to coalesce with any other
+		 * wakeup sources. For delays shorter than 10 us, don't even
+		 * bother setting up high-resolution timers and just busy-
+		 * loop.
+		 */
+		if (us >= 10)
+			usleep_range(us, us + 100);
+		else
+			udelay(us);
 	}
 
 	trace_regulator_enable_complete(rdev_get_name(rdev));

commit ef60abbb6b406389245225ab4acfe73f66e7d92c
Author: Mark Brown <broonie@linaro.org>
Date:   Mon Sep 23 16:12:52 2013 +0100

    regulator: core: Always use return value when regulator_dev_lookup() fails
    
    Ensure that the return value is always set when we return now that the
    logic has changed for regulator_get_optional() so we don't get missing
    codes leaking out.
    
    Reported-by: Thierry Reding <treding@nvidia.com>
    Tested-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 088b41ac9506..a40055edaae4 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1263,12 +1263,13 @@ static struct regulator *_regulator_get(struct device *dev, const char *id,
 	if (rdev)
 		goto found;
 
+	regulator = ERR_PTR(ret);
+
 	/*
 	 * If we have return value from dev_lookup fail, we do not expect to
 	 * succeed, so, quit with appropriate error value
 	 */
 	if (ret && ret != -ENODEV) {
-		regulator = ERR_PTR(ret);
 		goto out;
 	}
 

commit 043c998f95036e7fc796b240ab5ba49a8de36df3
Author: Mark Brown <broonie@linaro.org>
Date:   Fri Sep 20 12:32:18 2013 +0100

    regulator: core: Fix return code for invalid parameters
    
    We should be returning an error, a repeated call will never succeed.
    
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 66ae12d12c10..ad154247bb90 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1288,7 +1288,7 @@ static struct regulator *_regulator_get(struct device *dev, const char *id,
 
 	if (id == NULL) {
 		pr_err("get() with no identifier\n");
-		return regulator;
+		return ERR_PTR(-EINVAL);
 	}
 
 	if (dev)

commit 9b92da1f1205bd2591487051a93624dd6c258eef
Author: Mark Brown <broonie@linaro.org>
Date:   Fri Sep 20 12:23:30 2013 +0100

    regulator: core: Fix default return value for _get()
    
    Now that we are defaulting to providing dummy regulators fix the logic
    for substituting a dummy by making the default return code -EPROBE_DEFER.
    
    Reported-by: Thierry Reding <treding@nvidia.com>
    Tested-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index ac3a864d3635..088b41ac9506 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1247,7 +1247,7 @@ static struct regulator *_regulator_get(struct device *dev, const char *id,
 	struct regulator_dev *rdev;
 	struct regulator *regulator = ERR_PTR(-EPROBE_DEFER);
 	const char *devname = NULL;
-	int ret = 0;
+	int ret = -EPROBE_DEFER;
 
 	if (id == NULL) {
 		pr_err("get() with no identifier\n");

commit f8c1700dd7d2ce9b2238b20d364317b2968ac76b
Author: Laxman Dewangan <ldewangan@nvidia.com>
Date:   Fri Sep 20 13:13:02 2013 +0530

    regulator: core: set current constraints while setting machine constraints
    
    Machine constraints is configured during regulator register. If current
    constraints are provided through machine constraints then it is observed
    that sometime the current configured on rail is out of range what machine
    constraint has.
    
    Set the current constraints when setting machine constraints to make
    sure that rail's current is within the range of given machine constraints.
    
    Signed-off-by: Laxman Dewangan <ldewangan@nvidia.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 5217c1964c32..66ae12d12c10 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -923,6 +923,36 @@ static int machine_constraints_voltage(struct regulator_dev *rdev,
 	return 0;
 }
 
+static int machine_constraints_current(struct regulator_dev *rdev,
+	struct regulation_constraints *constraints)
+{
+	struct regulator_ops *ops = rdev->desc->ops;
+	int ret;
+
+	if (!constraints->min_uA && !constraints->max_uA)
+		return 0;
+
+	if (constraints->min_uA > constraints->max_uA) {
+		rdev_err(rdev, "Invalid current constraints\n");
+		return -EINVAL;
+	}
+
+	if (!ops->set_current_limit || !ops->get_current_limit) {
+		rdev_warn(rdev, "Operation of current configuration missing\n");
+		return 0;
+	}
+
+	/* Set regulator current in constraints range */
+	ret = ops->set_current_limit(rdev, constraints->min_uA,
+			constraints->max_uA);
+	if (ret < 0) {
+		rdev_err(rdev, "Failed to set current constraint, %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
 /**
  * set_machine_constraints - sets regulator constraints
  * @rdev: regulator source
@@ -953,6 +983,10 @@ static int set_machine_constraints(struct regulator_dev *rdev,
 	if (ret != 0)
 		goto out;
 
+	ret = machine_constraints_current(rdev, rdev->constraints);
+	if (ret != 0)
+		goto out;
+
 	/* do we need to setup our suspend state */
 	if (rdev->constraints->initial_state) {
 		ret = suspend_prepare(rdev, rdev->constraints->initial_state);

commit 00c877c69ba315d6c565a4df51c71b11e82cdeb8
Author: Laxman Dewangan <ldewangan@nvidia.com>
Date:   Wed Sep 18 18:18:02 2013 +0530

    regulator: core: add support for configuring turn-on time through constraints
    
    The turn-on time of the regulator depends on the regulator device's
    electrical characteristics. Sometimes regulator turn-on time also
    depends on the capacitive load on the given platform and it can be
    more than the datasheet value.
    
    The driver provides the enable-time as per datasheet.
    
    Add support for configure the enable ramp time through regulator
    constraints so that regulator core can take this value for enable
    time for that regulator.
    
    Signed-off-by: Laxman Dewangan <ldewangan@nvidia.com>
    Acked-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index a01b8b3b70ca..5217c1964c32 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1186,6 +1186,8 @@ static struct regulator *create_regulator(struct regulator_dev *rdev,
 
 static int _regulator_get_enable_time(struct regulator_dev *rdev)
 {
+	if (rdev->constraints && rdev->constraints->enable_time)
+		return rdev->constraints->enable_time;
 	if (!rdev->desc->ops->enable_time)
 		return rdev->desc->enable_time;
 	return rdev->desc->ops->enable_time(rdev);

commit 4f0ac6dabf867095b31f851ba0d0ceaca2f87e2e
Author: Mark Brown <broonie@linaro.org>
Date:   Fri Sep 13 19:51:47 2013 +0100

    regulator: core: Remove unused regulator_use_dummy_regulator()
    
    No boards have used this functionality and the new default of providing
    dummy regulators by default provides a better solution to the problem it
    was trying to solve.
    
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 8fd170788c3e..ac3a864d3635 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -53,7 +53,6 @@ static LIST_HEAD(regulator_list);
 static LIST_HEAD(regulator_map_list);
 static LIST_HEAD(regulator_ena_gpio_list);
 static bool has_full_constraints;
-static bool board_wants_dummy_regulator;
 
 static struct dentry *debugfs_root;
 
@@ -3615,22 +3614,6 @@ void regulator_has_full_constraints(void)
 }
 EXPORT_SYMBOL_GPL(regulator_has_full_constraints);
 
-/**
- * regulator_use_dummy_regulator - Provide a dummy regulator when none is found
- *
- * Calling this function will cause the regulator API to provide a
- * dummy regulator to consumers if no physical regulator is found,
- * allowing most consumers to proceed as though a regulator were
- * configured.  This allows systems such as those with software
- * controllable regulators for the CPU core only to be brought up more
- * readily.
- */
-void regulator_use_dummy_regulator(void)
-{
-	board_wants_dummy_regulator = true;
-}
-EXPORT_SYMBOL_GPL(regulator_use_dummy_regulator);
-
 /**
  * rdev_get_drvdata - get rdev regulator driver data
  * @rdev: regulator

commit 4ddfebd3b0d5b65c69492408bb67fd1202104643
Author: Mark Brown <broonie@linaro.org>
Date:   Fri Sep 13 19:50:37 2013 +0100

    regulator: core: Provide a dummy regulator with full constraints
    
    When a system has said that it has fully specified constraints for its
    regulators it is still possible that some supplies may be missing,
    especially if regulator support has been added to a driver after the
    board was integrated. We can handle such situations more gracefully by
    providing a dummy regulator.
    
    Unless the caller has specifically indicated that the system design may
    not include a given regulator by using regulator_get_optional() or that
    it needs its interactions to have an effect using regulator_get_exclusive()
    provide a dummy regulator if we can't locate a real one.
    
    The kconfig option REGULATOR_DUMMY that provided similar behaviour for all
    regulators has been removed, systems that need it should flag that they
    have full constraints instead.
    
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index a01b8b3b70ca..8fd170788c3e 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1243,7 +1243,7 @@ static struct regulator_dev *regulator_dev_lookup(struct device *dev,
 
 /* Internal regulator request function */
 static struct regulator *_regulator_get(struct device *dev, const char *id,
-					bool exclusive)
+					bool exclusive, bool allow_dummy)
 {
 	struct regulator_dev *rdev;
 	struct regulator *regulator = ERR_PTR(-EPROBE_DEFER);
@@ -1268,30 +1268,32 @@ static struct regulator *_regulator_get(struct device *dev, const char *id,
 	 * If we have return value from dev_lookup fail, we do not expect to
 	 * succeed, so, quit with appropriate error value
 	 */
-	if (ret) {
+	if (ret && ret != -ENODEV) {
 		regulator = ERR_PTR(ret);
 		goto out;
 	}
 
-	if (board_wants_dummy_regulator) {
-		rdev = dummy_regulator_rdev;
-		goto found;
-	}
-
-#ifdef CONFIG_REGULATOR_DUMMY
 	if (!devname)
 		devname = "deviceless";
 
-	/* If the board didn't flag that it was fully constrained then
-	 * substitute in a dummy regulator so consumers can continue.
+	/*
+	 * Assume that a regulator is physically present and enabled
+	 * even if it isn't hooked up and just provide a dummy.
 	 */
-	if (!has_full_constraints) {
-		pr_warn("%s supply %s not found, using dummy regulator\n",
-			devname, id);
+	if (has_full_constraints && allow_dummy) {
+		/*
+		 * Log the substitution if regulator configuration is
+		 * not complete to help development.
+		 */
+		if (!has_full_constraints)
+			pr_warn("%s supply %s not found, using dummy regulator\n",
+				devname, id);
+
 		rdev = dummy_regulator_rdev;
 		goto found;
+	} else {
+		dev_err(dev, "dummy supplies not allowed\n");
 	}
-#endif
 
 	mutex_unlock(&regulator_list_mutex);
 	return regulator;
@@ -1349,7 +1351,7 @@ static struct regulator *_regulator_get(struct device *dev, const char *id,
  */
 struct regulator *regulator_get(struct device *dev, const char *id)
 {
-	return _regulator_get(dev, id, false);
+	return _regulator_get(dev, id, false, true);
 }
 EXPORT_SYMBOL_GPL(regulator_get);
 
@@ -1410,7 +1412,7 @@ EXPORT_SYMBOL_GPL(devm_regulator_get);
  */
 struct regulator *regulator_get_exclusive(struct device *dev, const char *id)
 {
-	return _regulator_get(dev, id, true);
+	return _regulator_get(dev, id, true, false);
 }
 EXPORT_SYMBOL_GPL(regulator_get_exclusive);
 
@@ -1439,7 +1441,7 @@ EXPORT_SYMBOL_GPL(regulator_get_exclusive);
  */
 struct regulator *regulator_get_optional(struct device *dev, const char *id)
 {
-	return _regulator_get(dev, id, 0);
+	return _regulator_get(dev, id, false, false);
 }
 EXPORT_SYMBOL_GPL(regulator_get_optional);
 

commit 0cdfcc0f9352a4c076fbb51299e2b12a35619a51
Author: Mark Brown <broonie@linaro.org>
Date:   Wed Sep 11 13:15:40 2013 +0100

    regulator: core: Split devres code out into a separate file
    
    Cut down on the size of core.c a bit more and ensure that the devres
    versions of things don't do too much peering inside the internals of
    the APIs they wrap.
    
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 388397bb3192..906deb7354ed 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -36,6 +36,7 @@
 #include <trace/events/regulator.h>
 
 #include "dummy.h"
+#include "internal.h"
 
 #define rdev_crit(rdev, fmt, ...)					\
 	pr_crit("%s: " fmt, rdev_get_name(rdev), ##__VA_ARGS__)
@@ -82,25 +83,6 @@ struct regulator_enable_gpio {
 	unsigned int ena_gpio_invert:1;
 };
 
-/*
- * struct regulator
- *
- * One for each consumer device.
- */
-struct regulator {
-	struct device *dev;
-	struct list_head list;
-	unsigned int always_on:1;
-	unsigned int bypass:1;
-	int uA_load;
-	int min_uV;
-	int max_uV;
-	char *supply_name;
-	struct device_attribute dev_attr;
-	struct regulator_dev *rdev;
-	struct dentry *debugfs;
-};
-
 static int _regulator_is_enabled(struct regulator_dev *rdev);
 static int _regulator_disable(struct regulator_dev *rdev);
 static int _regulator_get_voltage(struct regulator_dev *rdev);
@@ -1334,50 +1316,6 @@ static struct regulator *_regulator_get(struct device *dev, const char *id,
 	return regulator;
 }
 
-enum {
-	NORMAL_GET,
-	EXCLUSIVE_GET,
-	OPTIONAL_GET,
-};
-
-static void devm_regulator_release(struct device *dev, void *res)
-{
-	regulator_put(*(struct regulator **)res);
-}
-
-static struct regulator *_devm_regulator_get(struct device *dev, const char *id,
-					     int get_type)
-{
-	struct regulator **ptr, *regulator;
-
-	ptr = devres_alloc(devm_regulator_release, sizeof(*ptr), GFP_KERNEL);
-	if (!ptr)
-		return ERR_PTR(-ENOMEM);
-
-	switch (get_type) {
-	case NORMAL_GET:
-		regulator = regulator_get(dev, id);
-		break;
-	case EXCLUSIVE_GET:
-		regulator = regulator_get_exclusive(dev, id);
-		break;
-	case OPTIONAL_GET:
-		regulator = regulator_get_optional(dev, id);
-		break;
-	default:
-		regulator = ERR_PTR(-EINVAL);
-	}
-
-	if (!IS_ERR(regulator)) {
-		*ptr = regulator;
-		devres_add(dev, ptr);
-	} else {
-		devres_free(ptr);
-	}
-
-	return regulator;
-}
-
 /**
  * regulator_get - lookup and obtain a reference to a regulator.
  * @dev: device for regulator "consumer"
@@ -1397,21 +1335,6 @@ struct regulator *regulator_get(struct device *dev, const char *id)
 }
 EXPORT_SYMBOL_GPL(regulator_get);
 
-/**
- * devm_regulator_get - Resource managed regulator_get()
- * @dev: device for regulator "consumer"
- * @id: Supply name or regulator ID.
- *
- * Managed regulator_get(). Regulators returned from this function are
- * automatically regulator_put() on driver detach. See regulator_get() for more
- * information.
- */
-struct regulator *devm_regulator_get(struct device *dev, const char *id)
-{
-	return _devm_regulator_get(dev, id, NORMAL_GET);
-}
-EXPORT_SYMBOL_GPL(devm_regulator_get);
-
 /**
  * regulator_get_exclusive - obtain exclusive access to a regulator.
  * @dev: device for regulator "consumer"
@@ -1439,22 +1362,6 @@ struct regulator *regulator_get_exclusive(struct device *dev, const char *id)
 }
 EXPORT_SYMBOL_GPL(regulator_get_exclusive);
 
-/**
- * devm_regulator_get_exclusive - Resource managed regulator_get_exclusive()
- * @dev: device for regulator "consumer"
- * @id: Supply name or regulator ID.
- *
- * Managed regulator_get_exclusive(). Regulators returned from this function
- * are automatically regulator_put() on driver detach. See regulator_get() for
- * more information.
- */
-struct regulator *devm_regulator_get_exclusive(struct device *dev,
-					       const char *id)
-{
-	return _devm_regulator_get(dev, id, EXCLUSIVE_GET);
-}
-EXPORT_SYMBOL_GPL(devm_regulator_get_exclusive);
-
 /**
  * regulator_get_optional - obtain optional access to a regulator.
  * @dev: device for regulator "consumer"
@@ -1484,22 +1391,6 @@ struct regulator *regulator_get_optional(struct device *dev, const char *id)
 }
 EXPORT_SYMBOL_GPL(regulator_get_optional);
 
-/**
- * devm_regulator_get_optional - Resource managed regulator_get_optional()
- * @dev: device for regulator "consumer"
- * @id: Supply name or regulator ID.
- *
- * Managed regulator_get_optional(). Regulators returned from this
- * function are automatically regulator_put() on driver detach. See
- * regulator_get_optional() for more information.
- */
-struct regulator *devm_regulator_get_optional(struct device *dev,
-					      const char *id)
-{
-	return _devm_regulator_get(dev, id, OPTIONAL_GET);
-}
-EXPORT_SYMBOL_GPL(devm_regulator_get_optional);
-
 /* Locks held by regulator_put() */
 static void _regulator_put(struct regulator *regulator)
 {
@@ -1541,35 +1432,6 @@ void regulator_put(struct regulator *regulator)
 }
 EXPORT_SYMBOL_GPL(regulator_put);
 
-static int devm_regulator_match(struct device *dev, void *res, void *data)
-{
-	struct regulator **r = res;
-	if (!r || !*r) {
-		WARN_ON(!r || !*r);
-		return 0;
-	}
-	return *r == data;
-}
-
-/**
- * devm_regulator_put - Resource managed regulator_put()
- * @regulator: regulator to free
- *
- * Deallocate a regulator allocated with devm_regulator_get(). Normally
- * this function will not need to be called and the resource management
- * code will ensure that the resource is freed.
- */
-void devm_regulator_put(struct regulator *regulator)
-{
-	int rc;
-
-	rc = devres_release(regulator->dev, devm_regulator_release,
-			    devm_regulator_match, regulator);
-	if (rc != 0)
-		WARN_ON(rc);
-}
-EXPORT_SYMBOL_GPL(devm_regulator_put);
-
 /* Manage enable GPIO list. Same GPIO pin can be shared among regulators */
 static int regulator_ena_gpio_request(struct regulator_dev *rdev,
 				const struct regulator_config *config)
@@ -2909,52 +2771,6 @@ int regulator_bulk_get(struct device *dev, int num_consumers,
 }
 EXPORT_SYMBOL_GPL(regulator_bulk_get);
 
-/**
- * devm_regulator_bulk_get - managed get multiple regulator consumers
- *
- * @dev:           Device to supply
- * @num_consumers: Number of consumers to register
- * @consumers:     Configuration of consumers; clients are stored here.
- *
- * @return 0 on success, an errno on failure.
- *
- * This helper function allows drivers to get several regulator
- * consumers in one operation with management, the regulators will
- * automatically be freed when the device is unbound.  If any of the
- * regulators cannot be acquired then any regulators that were
- * allocated will be freed before returning to the caller.
- */
-int devm_regulator_bulk_get(struct device *dev, int num_consumers,
-			    struct regulator_bulk_data *consumers)
-{
-	int i;
-	int ret;
-
-	for (i = 0; i < num_consumers; i++)
-		consumers[i].consumer = NULL;
-
-	for (i = 0; i < num_consumers; i++) {
-		consumers[i].consumer = devm_regulator_get(dev,
-							   consumers[i].supply);
-		if (IS_ERR(consumers[i].consumer)) {
-			ret = PTR_ERR(consumers[i].consumer);
-			dev_err(dev, "Failed to get supply '%s': %d\n",
-				consumers[i].supply, ret);
-			consumers[i].consumer = NULL;
-			goto err;
-		}
-	}
-
-	return 0;
-
-err:
-	for (i = 0; i < num_consumers && consumers[i].consumer; i++)
-		devm_regulator_put(consumers[i].consumer);
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(devm_regulator_bulk_get);
-
 static void regulator_bulk_enable_async(void *data, async_cookie_t cookie)
 {
 	struct regulator_bulk_data *bulk = data;
@@ -3489,44 +3305,6 @@ regulator_register(const struct regulator_desc *regulator_desc,
 }
 EXPORT_SYMBOL_GPL(regulator_register);
 
-static void devm_rdev_release(struct device *dev, void *res)
-{
-	regulator_unregister(*(struct regulator_dev **)res);
-}
-
-/**
- * devm_regulator_register - Resource managed regulator_register()
- * @regulator_desc: regulator to register
- * @config: runtime configuration for regulator
- *
- * Called by regulator drivers to register a regulator.  Returns a
- * valid pointer to struct regulator_dev on success or an ERR_PTR() on
- * error.  The regulator will automatically be released when the device
- * is unbound.
- */
-struct regulator_dev *devm_regulator_register(struct device *dev,
-				  const struct regulator_desc *regulator_desc,
-				  const struct regulator_config *config)
-{
-	struct regulator_dev **ptr, *rdev;
-
-	ptr = devres_alloc(devm_rdev_release, sizeof(*ptr),
-			   GFP_KERNEL);
-	if (!ptr)
-		return ERR_PTR(-ENOMEM);
-
-	rdev = regulator_register(regulator_desc, config);
-	if (!IS_ERR(rdev)) {
-		*ptr = rdev;
-		devres_add(dev, ptr);
-	} else {
-		devres_free(ptr);
-	}
-
-	return rdev;
-}
-EXPORT_SYMBOL_GPL(devm_regulator_register);
-
 /**
  * regulator_unregister - unregister regulator
  * @rdev: regulator to unregister
@@ -3556,34 +3334,6 @@ void regulator_unregister(struct regulator_dev *rdev)
 }
 EXPORT_SYMBOL_GPL(regulator_unregister);
 
-static int devm_rdev_match(struct device *dev, void *res, void *data)
-{
-	struct regulator_dev **r = res;
-	if (!r || !*r) {
-		WARN_ON(!r || !*r);
-		return 0;
-	}
-	return *r == data;
-}
-
-/**
- * devm_regulator_unregister - Resource managed regulator_unregister()
- * @regulator: regulator to free
- *
- * Unregister a regulator registered with devm_regulator_register().
- * Normally this function will not need to be called and the resource
- * management code will ensure that the resource is freed.
- */
-void devm_regulator_unregister(struct device *dev, struct regulator_dev *rdev)
-{
-	int rc;
-
-	rc = devres_release(dev, devm_rdev_release, devm_rdev_match, rdev);
-	if (rc != 0)
-		WARN_ON(rc);
-}
-EXPORT_SYMBOL_GPL(devm_regulator_unregister);
-
 /**
  * regulator_suspend_prepare - prepare regulators for system wide suspend
  * @state: system suspend state

commit cee8e355942c01f408bddf8a53596be1dff7a86b
Author: Axel Lin <axel.lin@ingics.com>
Date:   Sun Sep 1 12:24:17 2013 +0800

    regulator: core: Refactor devm_regulator_get* APIs
    
    The implementation of devm_regulator_get, devm_regulator_get_exclusive and
    devm_regulator_get_optional are almost the same.
    Introduce _devm_regulator_get helper function and refactor the code.
    
    Also move devm_regulator_get_exclusive to proper place, put it after
    regulator_get_exclusive() function.
    
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 85e8cbed1cbc..388397bb3192 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1334,6 +1334,50 @@ static struct regulator *_regulator_get(struct device *dev, const char *id,
 	return regulator;
 }
 
+enum {
+	NORMAL_GET,
+	EXCLUSIVE_GET,
+	OPTIONAL_GET,
+};
+
+static void devm_regulator_release(struct device *dev, void *res)
+{
+	regulator_put(*(struct regulator **)res);
+}
+
+static struct regulator *_devm_regulator_get(struct device *dev, const char *id,
+					     int get_type)
+{
+	struct regulator **ptr, *regulator;
+
+	ptr = devres_alloc(devm_regulator_release, sizeof(*ptr), GFP_KERNEL);
+	if (!ptr)
+		return ERR_PTR(-ENOMEM);
+
+	switch (get_type) {
+	case NORMAL_GET:
+		regulator = regulator_get(dev, id);
+		break;
+	case EXCLUSIVE_GET:
+		regulator = regulator_get_exclusive(dev, id);
+		break;
+	case OPTIONAL_GET:
+		regulator = regulator_get_optional(dev, id);
+		break;
+	default:
+		regulator = ERR_PTR(-EINVAL);
+	}
+
+	if (!IS_ERR(regulator)) {
+		*ptr = regulator;
+		devres_add(dev, ptr);
+	} else {
+		devres_free(ptr);
+	}
+
+	return regulator;
+}
+
 /**
  * regulator_get - lookup and obtain a reference to a regulator.
  * @dev: device for regulator "consumer"
@@ -1353,11 +1397,6 @@ struct regulator *regulator_get(struct device *dev, const char *id)
 }
 EXPORT_SYMBOL_GPL(regulator_get);
 
-static void devm_regulator_release(struct device *dev, void *res)
-{
-	regulator_put(*(struct regulator **)res);
-}
-
 /**
  * devm_regulator_get - Resource managed regulator_get()
  * @dev: device for regulator "consumer"
@@ -1369,21 +1408,7 @@ static void devm_regulator_release(struct device *dev, void *res)
  */
 struct regulator *devm_regulator_get(struct device *dev, const char *id)
 {
-	struct regulator **ptr, *regulator;
-
-	ptr = devres_alloc(devm_regulator_release, sizeof(*ptr), GFP_KERNEL);
-	if (!ptr)
-		return ERR_PTR(-ENOMEM);
-
-	regulator = regulator_get(dev, id);
-	if (!IS_ERR(regulator)) {
-		*ptr = regulator;
-		devres_add(dev, ptr);
-	} else {
-		devres_free(ptr);
-	}
-
-	return regulator;
+	return _devm_regulator_get(dev, id, NORMAL_GET);
 }
 EXPORT_SYMBOL_GPL(devm_regulator_get);
 
@@ -1414,6 +1439,22 @@ struct regulator *regulator_get_exclusive(struct device *dev, const char *id)
 }
 EXPORT_SYMBOL_GPL(regulator_get_exclusive);
 
+/**
+ * devm_regulator_get_exclusive - Resource managed regulator_get_exclusive()
+ * @dev: device for regulator "consumer"
+ * @id: Supply name or regulator ID.
+ *
+ * Managed regulator_get_exclusive(). Regulators returned from this function
+ * are automatically regulator_put() on driver detach. See regulator_get() for
+ * more information.
+ */
+struct regulator *devm_regulator_get_exclusive(struct device *dev,
+					       const char *id)
+{
+	return _devm_regulator_get(dev, id, EXCLUSIVE_GET);
+}
+EXPORT_SYMBOL_GPL(devm_regulator_get_exclusive);
+
 /**
  * regulator_get_optional - obtain optional access to a regulator.
  * @dev: device for regulator "consumer"
@@ -1455,21 +1496,7 @@ EXPORT_SYMBOL_GPL(regulator_get_optional);
 struct regulator *devm_regulator_get_optional(struct device *dev,
 					      const char *id)
 {
-	struct regulator **ptr, *regulator;
-
-	ptr = devres_alloc(devm_regulator_release, sizeof(*ptr), GFP_KERNEL);
-	if (!ptr)
-		return ERR_PTR(-ENOMEM);
-
-	regulator = regulator_get_optional(dev, id);
-	if (!IS_ERR(regulator)) {
-		*ptr = regulator;
-		devres_add(dev, ptr);
-	} else {
-		devres_free(ptr);
-	}
-
-	return regulator;
+	return _devm_regulator_get(dev, id, OPTIONAL_GET);
 }
 EXPORT_SYMBOL_GPL(devm_regulator_get_optional);
 
@@ -1498,36 +1525,6 @@ static void _regulator_put(struct regulator *regulator)
 	module_put(rdev->owner);
 }
 
-/**
- * devm_regulator_get_exclusive - Resource managed regulator_get_exclusive()
- * @dev: device for regulator "consumer"
- * @id: Supply name or regulator ID.
- *
- * Managed regulator_get_exclusive(). Regulators returned from this function
- * are automatically regulator_put() on driver detach. See regulator_get() for
- * more information.
- */
-struct regulator *devm_regulator_get_exclusive(struct device *dev,
-					       const char *id)
-{
-	struct regulator **ptr, *regulator;
-
-	ptr = devres_alloc(devm_regulator_release, sizeof(*ptr), GFP_KERNEL);
-	if (!ptr)
-		return ERR_PTR(-ENOMEM);
-
-	regulator = _regulator_get(dev, id, 1);
-	if (!IS_ERR(regulator)) {
-		*ptr = regulator;
-		devres_add(dev, ptr);
-	} else {
-		devres_free(ptr);
-	}
-
-	return regulator;
-}
-EXPORT_SYMBOL_GPL(devm_regulator_get_exclusive);
-
 /**
  * regulator_put - "free" the regulator source
  * @regulator: regulator source

commit 42141f22e32a452b02b3dc8764d93223505e1c10
Author: Sachin Kamat <sachin.kamat@linaro.org>
Date:   Thu Sep 5 09:22:02 2013 +0530

    regulator: core: Fix a trivial typo
    
    Changed automaticall -> automatically.
    
    Signed-off-by: Sachin Kamat <sachin.kamat@linaro.org>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 5f995d281672..85e8cbed1cbc 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -3504,7 +3504,7 @@ static void devm_rdev_release(struct device *dev, void *res)
  *
  * Called by regulator drivers to register a regulator.  Returns a
  * valid pointer to struct regulator_dev on success or an ERR_PTR() on
- * error.  The regulator will automaticall be released when the device
+ * error.  The regulator will automatically be released when the device
  * is unbound.
  */
 struct regulator_dev *devm_regulator_register(struct device *dev,

commit b33e46bcdc4e598d738ed12a5a7906be4e11d786
Author: Mark Brown <broonie@linaro.org>
Date:   Sat Aug 31 11:58:26 2013 +0100

    regulator: core: Provide managed regulator registration
    
    Many regulator drivers have a remove function that consists solely of
    calling regulator_unregister() so provide a devm_regulator_register()
    in order to allow this repeated code to be removed and help eliminate
    error handling code.
    
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index a01b8b3b70ca..5f995d281672 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -3492,6 +3492,44 @@ regulator_register(const struct regulator_desc *regulator_desc,
 }
 EXPORT_SYMBOL_GPL(regulator_register);
 
+static void devm_rdev_release(struct device *dev, void *res)
+{
+	regulator_unregister(*(struct regulator_dev **)res);
+}
+
+/**
+ * devm_regulator_register - Resource managed regulator_register()
+ * @regulator_desc: regulator to register
+ * @config: runtime configuration for regulator
+ *
+ * Called by regulator drivers to register a regulator.  Returns a
+ * valid pointer to struct regulator_dev on success or an ERR_PTR() on
+ * error.  The regulator will automaticall be released when the device
+ * is unbound.
+ */
+struct regulator_dev *devm_regulator_register(struct device *dev,
+				  const struct regulator_desc *regulator_desc,
+				  const struct regulator_config *config)
+{
+	struct regulator_dev **ptr, *rdev;
+
+	ptr = devres_alloc(devm_rdev_release, sizeof(*ptr),
+			   GFP_KERNEL);
+	if (!ptr)
+		return ERR_PTR(-ENOMEM);
+
+	rdev = regulator_register(regulator_desc, config);
+	if (!IS_ERR(rdev)) {
+		*ptr = rdev;
+		devres_add(dev, ptr);
+	} else {
+		devres_free(ptr);
+	}
+
+	return rdev;
+}
+EXPORT_SYMBOL_GPL(devm_regulator_register);
+
 /**
  * regulator_unregister - unregister regulator
  * @rdev: regulator to unregister
@@ -3521,6 +3559,34 @@ void regulator_unregister(struct regulator_dev *rdev)
 }
 EXPORT_SYMBOL_GPL(regulator_unregister);
 
+static int devm_rdev_match(struct device *dev, void *res, void *data)
+{
+	struct regulator_dev **r = res;
+	if (!r || !*r) {
+		WARN_ON(!r || !*r);
+		return 0;
+	}
+	return *r == data;
+}
+
+/**
+ * devm_regulator_unregister - Resource managed regulator_unregister()
+ * @regulator: regulator to free
+ *
+ * Unregister a regulator registered with devm_regulator_register().
+ * Normally this function will not need to be called and the resource
+ * management code will ensure that the resource is freed.
+ */
+void devm_regulator_unregister(struct device *dev, struct regulator_dev *rdev)
+{
+	int rc;
+
+	rc = devres_release(dev, devm_rdev_release, devm_rdev_match, rdev);
+	if (rc != 0)
+		WARN_ON(rc);
+}
+EXPORT_SYMBOL_GPL(devm_regulator_unregister);
+
 /**
  * regulator_suspend_prepare - prepare regulators for system wide suspend
  * @state: system suspend state

commit 5a523605afa7d3b54b2e7041f8c9e6bc39872a7e
Author: Laxman Dewangan <ldewangan@nvidia.com>
Date:   Tue Sep 10 15:45:05 2013 +0530

    regulator: core: provide fixed voltage in desc for single voltage rail
    
    If given rail has the single voltage (n_voltages = 1) then provide the
    rail voltage through regulator descriptor so that core can use this
    value for finding voltage.
    
    This will avoid the implementation of the callback for get_voltage() or
    list_voltage() callback on regulator driver.
    
    Signed-off-by: Laxman Dewangan <ldewangan@nvidia.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index a01b8b3b70ca..abc899ed1ebf 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2489,6 +2489,8 @@ static int _regulator_get_voltage(struct regulator_dev *rdev)
 		ret = rdev->desc->ops->get_voltage(rdev);
 	} else if (rdev->desc->ops->list_voltage) {
 		ret = rdev->desc->ops->list_voltage(rdev, 0);
+	} else if (rdev->desc->fixed_uV && (rdev->desc->n_voltages == 1)) {
+		ret = rdev->desc->fixed_uV;
 	} else {
 		return -EINVAL;
 	}
@@ -3170,7 +3172,8 @@ static int add_regulator_attributes(struct regulator_dev *rdev)
 	/* some attributes need specific methods to be displayed */
 	if ((ops->get_voltage && ops->get_voltage(rdev) >= 0) ||
 	    (ops->get_voltage_sel && ops->get_voltage_sel(rdev) >= 0) ||
-	    (ops->list_voltage && ops->list_voltage(rdev, 0) >= 0)) {
+	    (ops->list_voltage && ops->list_voltage(rdev, 0) >= 0) ||
+		(rdev->desc->fixed_uV && (rdev->desc->n_voltages == 1))) {
 		status = device_create_file(dev, &dev_attr_microvolts);
 		if (status < 0)
 			return status;

commit a89f5c759857b1d1a56a4d530ad30bc1cacc58c9
Merge: 09f2dd88ff93 5b175952011a
Author: Mark Brown <broonie@linaro.org>
Date:   Sun Sep 1 13:50:20 2013 +0100

    Merge remote-tracking branch 'regulator/topic/ramp' into regulator-next

commit f27a5fb424d4897edd3c7735ecf054ee57a5dbd0
Merge: 6979380d85fd 9efdd27678ef
Author: Mark Brown <broonie@linaro.org>
Date:   Sun Sep 1 13:50:17 2013 +0100

    Merge remote-tracking branch 'regulator/topic/optional' into regulator-next

commit 724d054490883fed2d7e5fc716dffa7675476740
Merge: 446b4665e323 d295f7670127
Author: Mark Brown <broonie@linaro.org>
Date:   Sun Sep 1 13:50:09 2013 +0100

    Merge remote-tracking branch 'regulator/topic/helpers' into regulator-next

commit 1ad13028e55847185646b2be7d8b86b311c33249
Merge: 5288be36cd40 84fcf447a99c
Author: Mark Brown <broonie@linaro.org>
Date:   Sun Sep 1 13:50:06 2013 +0100

    Merge remote-tracking branch 'regulator/topic/core' into regulator-next

commit 9efdd27678ef5e22c27c230a08a211b702768f3a
Author: Matthias Kaehlcke <matthias.list@kaehlcke.net>
Date:   Sun Aug 25 17:54:13 2013 +0200

    regulator: Add devm_regulator_get_exclusive()
    
    Add a resource managed regulator_get_exclusive()
    
    Signed-off-by: Matthias Kaehlcke <matthias@kaehlcke.net>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index a27a5b6267dd..4b9039b43b6c 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1493,6 +1493,36 @@ static void _regulator_put(struct regulator *regulator)
 	module_put(rdev->owner);
 }
 
+/**
+ * devm_regulator_get_exclusive - Resource managed regulator_get_exclusive()
+ * @dev: device for regulator "consumer"
+ * @id: Supply name or regulator ID.
+ *
+ * Managed regulator_get_exclusive(). Regulators returned from this function
+ * are automatically regulator_put() on driver detach. See regulator_get() for
+ * more information.
+ */
+struct regulator *devm_regulator_get_exclusive(struct device *dev,
+					       const char *id)
+{
+	struct regulator **ptr, *regulator;
+
+	ptr = devres_alloc(devm_regulator_release, sizeof(*ptr), GFP_KERNEL);
+	if (!ptr)
+		return ERR_PTR(-ENOMEM);
+
+	regulator = _regulator_get(dev, id, 1);
+	if (!IS_ERR(regulator)) {
+		*ptr = regulator;
+		devres_add(dev, ptr);
+	} else {
+		devres_free(ptr);
+	}
+
+	return regulator;
+}
+EXPORT_SYMBOL_GPL(devm_regulator_get_exclusive);
+
 /**
  * regulator_put - "free" the regulator source
  * @regulator: regulator source

commit 84fcf447a99c8cc9cc906b42e590d1a3a7ed56ab
Author: Mark Brown <broonie@linaro.org>
Date:   Sun Aug 18 18:03:22 2013 +0100

    regulator: core: Use bool for exclusivitity flag
    
    Just for neatness.
    
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 101f7cb14be6..44b72f6715e4 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1242,7 +1242,7 @@ static struct regulator_dev *regulator_dev_lookup(struct device *dev,
 
 /* Internal regulator request function */
 static struct regulator *_regulator_get(struct device *dev, const char *id,
-					int exclusive)
+					bool exclusive)
 {
 	struct regulator_dev *rdev;
 	struct regulator *regulator = ERR_PTR(-EPROBE_DEFER);
@@ -1348,7 +1348,7 @@ static struct regulator *_regulator_get(struct device *dev, const char *id,
  */
 struct regulator *regulator_get(struct device *dev, const char *id)
 {
-	return _regulator_get(dev, id, 0);
+	return _regulator_get(dev, id, false);
 }
 EXPORT_SYMBOL_GPL(regulator_get);
 
@@ -1409,7 +1409,7 @@ EXPORT_SYMBOL_GPL(devm_regulator_get);
  */
 struct regulator *regulator_get_exclusive(struct device *dev, const char *id)
 {
-	return _regulator_get(dev, id, 1);
+	return _regulator_get(dev, id, true);
 }
 EXPORT_SYMBOL_GPL(regulator_get_exclusive);
 

commit d295f7670127eb241d81e96e003b380c77c2b254
Author: Axel Lin <axel.lin@ingics.com>
Date:   Fri Aug 9 15:29:27 2013 +0800

    regulator: core: Move list_voltage_{linear,linear_range,table} to helpers.c
    
    Move regulator_list_voltage_{linear,linear_range,table} helper functions to
    helpers.c.
    
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 01d9675b0e83..c111a2c19119 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1988,92 +1988,6 @@ int regulator_count_voltages(struct regulator *regulator)
 }
 EXPORT_SYMBOL_GPL(regulator_count_voltages);
 
-/**
- * regulator_list_voltage_linear - List voltages with simple calculation
- *
- * @rdev: Regulator device
- * @selector: Selector to convert into a voltage
- *
- * Regulators with a simple linear mapping between voltages and
- * selectors can set min_uV and uV_step in the regulator descriptor
- * and then use this function as their list_voltage() operation,
- */
-int regulator_list_voltage_linear(struct regulator_dev *rdev,
-				  unsigned int selector)
-{
-	if (selector >= rdev->desc->n_voltages)
-		return -EINVAL;
-	if (selector < rdev->desc->linear_min_sel)
-		return 0;
-
-	selector -= rdev->desc->linear_min_sel;
-
-	return rdev->desc->min_uV + (rdev->desc->uV_step * selector);
-}
-EXPORT_SYMBOL_GPL(regulator_list_voltage_linear);
-
-/**
- * regulator_list_voltage_linear_range - List voltages for linear ranges
- *
- * @rdev: Regulator device
- * @selector: Selector to convert into a voltage
- *
- * Regulators with a series of simple linear mappings between voltages
- * and selectors can set linear_ranges in the regulator descriptor and
- * then use this function as their list_voltage() operation,
- */
-int regulator_list_voltage_linear_range(struct regulator_dev *rdev,
-					unsigned int selector)
-{
-	const struct regulator_linear_range *range;
-	int i;
-
-	if (!rdev->desc->n_linear_ranges) {
-		BUG_ON(!rdev->desc->n_linear_ranges);
-		return -EINVAL;
-	}
-
-	for (i = 0; i < rdev->desc->n_linear_ranges; i++) {
-		range = &rdev->desc->linear_ranges[i];
-
-		if (!(selector >= range->min_sel &&
-		      selector <= range->max_sel))
-			continue;
-
-		selector -= range->min_sel;
-
-		return range->min_uV + (range->uV_step * selector);
-	}
-
-	return -EINVAL;
-}
-EXPORT_SYMBOL_GPL(regulator_list_voltage_linear_range);
-
-/**
- * regulator_list_voltage_table - List voltages with table based mapping
- *
- * @rdev: Regulator device
- * @selector: Selector to convert into a voltage
- *
- * Regulators with table based mapping between voltages and
- * selectors can set volt_table in the regulator descriptor
- * and then use this function as their list_voltage() operation.
- */
-int regulator_list_voltage_table(struct regulator_dev *rdev,
-				 unsigned int selector)
-{
-	if (!rdev->desc->volt_table) {
-		BUG_ON(!rdev->desc->volt_table);
-		return -EINVAL;
-	}
-
-	if (selector >= rdev->desc->n_voltages)
-		return -EINVAL;
-
-	return rdev->desc->volt_table[selector];
-}
-EXPORT_SYMBOL_GPL(regulator_list_voltage_table);
-
 /**
  * regulator_list_voltage - enumerate supported voltages
  * @regulator: regulator source

commit c4a54b8d54218a75b94ab9947449e688869df00d
Author: Mark Brown <broonie@linaro.org>
Date:   Tue Aug 6 01:31:28 2013 +0100

    regulator: core: Move helpers for drivers out into a separate file
    
    Reduce the size of core.c a bit.
    
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 1034e05fb00a..01d9675b0e83 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1904,77 +1904,6 @@ int regulator_disable_deferred(struct regulator *regulator, int ms)
 }
 EXPORT_SYMBOL_GPL(regulator_disable_deferred);
 
-/**
- * regulator_is_enabled_regmap - standard is_enabled() for regmap users
- *
- * @rdev: regulator to operate on
- *
- * Regulators that use regmap for their register I/O can set the
- * enable_reg and enable_mask fields in their descriptor and then use
- * this as their is_enabled operation, saving some code.
- */
-int regulator_is_enabled_regmap(struct regulator_dev *rdev)
-{
-	unsigned int val;
-	int ret;
-
-	ret = regmap_read(rdev->regmap, rdev->desc->enable_reg, &val);
-	if (ret != 0)
-		return ret;
-
-	if (rdev->desc->enable_is_inverted)
-		return (val & rdev->desc->enable_mask) == 0;
-	else
-		return (val & rdev->desc->enable_mask) != 0;
-}
-EXPORT_SYMBOL_GPL(regulator_is_enabled_regmap);
-
-/**
- * regulator_enable_regmap - standard enable() for regmap users
- *
- * @rdev: regulator to operate on
- *
- * Regulators that use regmap for their register I/O can set the
- * enable_reg and enable_mask fields in their descriptor and then use
- * this as their enable() operation, saving some code.
- */
-int regulator_enable_regmap(struct regulator_dev *rdev)
-{
-	unsigned int val;
-
-	if (rdev->desc->enable_is_inverted)
-		val = 0;
-	else
-		val = rdev->desc->enable_mask;
-
-	return regmap_update_bits(rdev->regmap, rdev->desc->enable_reg,
-				  rdev->desc->enable_mask, val);
-}
-EXPORT_SYMBOL_GPL(regulator_enable_regmap);
-
-/**
- * regulator_disable_regmap - standard disable() for regmap users
- *
- * @rdev: regulator to operate on
- *
- * Regulators that use regmap for their register I/O can set the
- * enable_reg and enable_mask fields in their descriptor and then use
- * this as their disable() operation, saving some code.
- */
-int regulator_disable_regmap(struct regulator_dev *rdev)
-{
-	unsigned int val;
-
-	if (rdev->desc->enable_is_inverted)
-		val = rdev->desc->enable_mask;
-	else
-		val = 0;
-
-	return regmap_update_bits(rdev->regmap, rdev->desc->enable_reg,
-				  rdev->desc->enable_mask, val);
-}
-EXPORT_SYMBOL_GPL(regulator_disable_regmap);
-
 static int _regulator_is_enabled(struct regulator_dev *rdev)
 {
 	/* A GPIO control always takes precedence */
@@ -2239,235 +2168,6 @@ int regulator_is_supported_voltage(struct regulator *regulator,
 }
 EXPORT_SYMBOL_GPL(regulator_is_supported_voltage);
 
-/**
- * regulator_get_voltage_sel_regmap - standard get_voltage_sel for regmap users
- *
- * @rdev: regulator to operate on
- *
- * Regulators that use regmap for their register I/O can set the
- * vsel_reg and vsel_mask fields in their descriptor and then use this
- * as their get_voltage_vsel operation, saving some code.
- */
-int regulator_get_voltage_sel_regmap(struct regulator_dev *rdev)
-{
-	unsigned int val;
-	int ret;
-
-	ret = regmap_read(rdev->regmap, rdev->desc->vsel_reg, &val);
-	if (ret != 0)
-		return ret;
-
-	val &= rdev->desc->vsel_mask;
-	val >>= ffs(rdev->desc->vsel_mask) - 1;
-
-	return val;
-}
-EXPORT_SYMBOL_GPL(regulator_get_voltage_sel_regmap);
-
-/**
- * regulator_set_voltage_sel_regmap - standard set_voltage_sel for regmap users
- *
- * @rdev: regulator to operate on
- * @sel: Selector to set
- *
- * Regulators that use regmap for their register I/O can set the
- * vsel_reg and vsel_mask fields in their descriptor and then use this
- * as their set_voltage_vsel operation, saving some code.
- */
-int regulator_set_voltage_sel_regmap(struct regulator_dev *rdev, unsigned sel)
-{
-	int ret;
-
-	sel <<= ffs(rdev->desc->vsel_mask) - 1;
-
-	ret = regmap_update_bits(rdev->regmap, rdev->desc->vsel_reg,
-				  rdev->desc->vsel_mask, sel);
-	if (ret)
-		return ret;
-
-	if (rdev->desc->apply_bit)
-		ret = regmap_update_bits(rdev->regmap, rdev->desc->apply_reg,
-					 rdev->desc->apply_bit,
-					 rdev->desc->apply_bit);
-	return ret;
-}
-EXPORT_SYMBOL_GPL(regulator_set_voltage_sel_regmap);
-
-/**
- * regulator_map_voltage_iterate - map_voltage() based on list_voltage()
- *
- * @rdev: Regulator to operate on
- * @min_uV: Lower bound for voltage
- * @max_uV: Upper bound for voltage
- *
- * Drivers implementing set_voltage_sel() and list_voltage() can use
- * this as their map_voltage() operation.  It will find a suitable
- * voltage by calling list_voltage() until it gets something in bounds
- * for the requested voltages.
- */
-int regulator_map_voltage_iterate(struct regulator_dev *rdev,
-				  int min_uV, int max_uV)
-{
-	int best_val = INT_MAX;
-	int selector = 0;
-	int i, ret;
-
-	/* Find the smallest voltage that falls within the specified
-	 * range.
-	 */
-	for (i = 0; i < rdev->desc->n_voltages; i++) {
-		ret = rdev->desc->ops->list_voltage(rdev, i);
-		if (ret < 0)
-			continue;
-
-		if (ret < best_val && ret >= min_uV && ret <= max_uV) {
-			best_val = ret;
-			selector = i;
-		}
-	}
-
-	if (best_val != INT_MAX)
-		return selector;
-	else
-		return -EINVAL;
-}
-EXPORT_SYMBOL_GPL(regulator_map_voltage_iterate);
-
-/**
- * regulator_map_voltage_ascend - map_voltage() for ascendant voltage list
- *
- * @rdev: Regulator to operate on
- * @min_uV: Lower bound for voltage
- * @max_uV: Upper bound for voltage
- *
- * Drivers that have ascendant voltage list can use this as their
- * map_voltage() operation.
- */
-int regulator_map_voltage_ascend(struct regulator_dev *rdev,
-				 int min_uV, int max_uV)
-{
-	int i, ret;
-
-	for (i = 0; i < rdev->desc->n_voltages; i++) {
-		ret = rdev->desc->ops->list_voltage(rdev, i);
-		if (ret < 0)
-			continue;
-
-		if (ret > max_uV)
-			break;
-
-		if (ret >= min_uV && ret <= max_uV)
-			return i;
-	}
-
-	return -EINVAL;
-}
-EXPORT_SYMBOL_GPL(regulator_map_voltage_ascend);
-
-/**
- * regulator_map_voltage_linear - map_voltage() for simple linear mappings
- *
- * @rdev: Regulator to operate on
- * @min_uV: Lower bound for voltage
- * @max_uV: Upper bound for voltage
- *
- * Drivers providing min_uV and uV_step in their regulator_desc can
- * use this as their map_voltage() operation.
- */
-int regulator_map_voltage_linear(struct regulator_dev *rdev,
-				 int min_uV, int max_uV)
-{
-	int ret, voltage;
-
-	/* Allow uV_step to be 0 for fixed voltage */
-	if (rdev->desc->n_voltages == 1 && rdev->desc->uV_step == 0) {
-		if (min_uV <= rdev->desc->min_uV && rdev->desc->min_uV <= max_uV)
-			return 0;
-		else
-			return -EINVAL;
-	}
-
-	if (!rdev->desc->uV_step) {
-		BUG_ON(!rdev->desc->uV_step);
-		return -EINVAL;
-	}
-
-	if (min_uV < rdev->desc->min_uV)
-		min_uV = rdev->desc->min_uV;
-
-	ret = DIV_ROUND_UP(min_uV - rdev->desc->min_uV, rdev->desc->uV_step);
-	if (ret < 0)
-		return ret;
-
-	ret += rdev->desc->linear_min_sel;
-
-	/* Map back into a voltage to verify we're still in bounds */
-	voltage = rdev->desc->ops->list_voltage(rdev, ret);
-	if (voltage < min_uV || voltage > max_uV)
-		return -EINVAL;
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(regulator_map_voltage_linear);
-
-/**
- * regulator_map_voltage_linear - map_voltage() for multiple linear ranges
- *
- * @rdev: Regulator to operate on
- * @min_uV: Lower bound for voltage
- * @max_uV: Upper bound for voltage
- *
- * Drivers providing linear_ranges in their descriptor can use this as
- * their map_voltage() callback.
- */
-int regulator_map_voltage_linear_range(struct regulator_dev *rdev,
-				       int min_uV, int max_uV)
-{
-	const struct regulator_linear_range *range;
-	int ret = -EINVAL;
-	int voltage, i;
-
-	if (!rdev->desc->n_linear_ranges) {
-		BUG_ON(!rdev->desc->n_linear_ranges);
-		return -EINVAL;
-	}
-
-	for (i = 0; i < rdev->desc->n_linear_ranges; i++) {
-		range = &rdev->desc->linear_ranges[i];
-
-		if (!(min_uV <= range->max_uV && max_uV >= range->min_uV))
-			continue;
-
-		if (min_uV <= range->min_uV)
-			min_uV = range->min_uV;
-
-		/* range->uV_step == 0 means fixed voltage range */
-		if (range->uV_step == 0) {
-			ret = 0;
-		} else {
-			ret = DIV_ROUND_UP(min_uV - range->min_uV,
-					   range->uV_step);
-			if (ret < 0)
-				return ret;
-		}
-
-		ret += range->min_sel;
-
-		break;
-	}
-
-	if (i == rdev->desc->n_linear_ranges)
-		return -EINVAL;
-
-	/* Map back into a voltage to verify we're still in bounds */
-	voltage = rdev->desc->ops->list_voltage(rdev, ret);
-	if (voltage < min_uV || voltage > max_uV)
-		return -EINVAL;
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(regulator_map_voltage_linear_range);
-
 static int _regulator_do_set_voltage(struct regulator_dev *rdev,
 				     int min_uV, int max_uV)
 {
@@ -3070,47 +2770,6 @@ int regulator_set_optimum_mode(struct regulator *regulator, int uA_load)
 }
 EXPORT_SYMBOL_GPL(regulator_set_optimum_mode);
 
-/**
- * regulator_set_bypass_regmap - Default set_bypass() using regmap
- *
- * @rdev: device to operate on.
- * @enable: state to set.
- */
-int regulator_set_bypass_regmap(struct regulator_dev *rdev, bool enable)
-{
-	unsigned int val;
-
-	if (enable)
-		val = rdev->desc->bypass_mask;
-	else
-		val = 0;
-
-	return regmap_update_bits(rdev->regmap, rdev->desc->bypass_reg,
-				  rdev->desc->bypass_mask, val);
-}
-EXPORT_SYMBOL_GPL(regulator_set_bypass_regmap);
-
-/**
- * regulator_get_bypass_regmap - Default get_bypass() using regmap
- *
- * @rdev: device to operate on.
- * @enable: current state.
- */
-int regulator_get_bypass_regmap(struct regulator_dev *rdev, bool *enable)
-{
-	unsigned int val;
-	int ret;
-
-	ret = regmap_read(rdev->regmap, rdev->desc->bypass_reg, &val);
-	if (ret != 0)
-		return ret;
-
-	*enable = val & rdev->desc->bypass_mask;
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(regulator_get_bypass_regmap);
-
 /**
  * regulator_allow_bypass - allow the regulator to go into bypass mode
  *

commit eca2a654b8e9b45680f75f77b716b483f1ecffce
Merge: 587cea27e4fe 550bf89366e0
Author: Mark Brown <broonie@linaro.org>
Date:   Wed Aug 7 11:05:04 2013 +0100

    Merge remote-tracking branch 'regulator/topic/linear-range' into regulator-helpers

commit de1dd9fd2156874b45803299b3b27e65d5defdd9
Author: Mark Brown <broonie@linaro.org>
Date:   Mon Jul 29 21:42:42 2013 +0100

    regulator: core: Provide hints to the core about optional supplies
    
    While the majority of supplies on devices are mandatory and can't be
    physically omitted for electrical reasons some devices do have optional
    supplies and need to know if they are missing, MMC being the most common
    of these.
    
    Currently the core accurately reports all errors when regulators are
    requested since it does not know if the supply is one that must be provided
    even if by a regulator software does not know about or if it is one that
    may genuinely be disconnected. In order to allow this behaviour to be
    changed and stub regulators to be provided in the former case add a new
    regulator request function regulator_get_optional() which provides a hint
    to the core that the regulator may genuinely not be connected.
    
    Currently the implementation is identical to the current behaviour, future
    patches will add support in the core for returning stub regulators in the
    case where normal regulator_get() fails and the board has requested it.
    
    Signed-off-by: Mark Brown <broonie@linaro.org>
    Acked-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 288c75abc190..a27a5b6267dd 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1409,6 +1409,65 @@ struct regulator *regulator_get_exclusive(struct device *dev, const char *id)
 }
 EXPORT_SYMBOL_GPL(regulator_get_exclusive);
 
+/**
+ * regulator_get_optional - obtain optional access to a regulator.
+ * @dev: device for regulator "consumer"
+ * @id: Supply name or regulator ID.
+ *
+ * Returns a struct regulator corresponding to the regulator producer,
+ * or IS_ERR() condition containing errno.  Other consumers will be
+ * unable to obtain this reference is held and the use count for the
+ * regulator will be initialised to reflect the current state of the
+ * regulator.
+ *
+ * This is intended for use by consumers for devices which can have
+ * some supplies unconnected in normal use, such as some MMC devices.
+ * It can allow the regulator core to provide stub supplies for other
+ * supplies requested using normal regulator_get() calls without
+ * disrupting the operation of drivers that can handle absent
+ * supplies.
+ *
+ * Use of supply names configured via regulator_set_device_supply() is
+ * strongly encouraged.  It is recommended that the supply name used
+ * should match the name used for the supply and/or the relevant
+ * device pins in the datasheet.
+ */
+struct regulator *regulator_get_optional(struct device *dev, const char *id)
+{
+	return _regulator_get(dev, id, 0);
+}
+EXPORT_SYMBOL_GPL(regulator_get_optional);
+
+/**
+ * devm_regulator_get_optional - Resource managed regulator_get_optional()
+ * @dev: device for regulator "consumer"
+ * @id: Supply name or regulator ID.
+ *
+ * Managed regulator_get_optional(). Regulators returned from this
+ * function are automatically regulator_put() on driver detach. See
+ * regulator_get_optional() for more information.
+ */
+struct regulator *devm_regulator_get_optional(struct device *dev,
+					      const char *id)
+{
+	struct regulator **ptr, *regulator;
+
+	ptr = devres_alloc(devm_regulator_release, sizeof(*ptr), GFP_KERNEL);
+	if (!ptr)
+		return ERR_PTR(-ENOMEM);
+
+	regulator = regulator_get_optional(dev, id);
+	if (!IS_ERR(regulator)) {
+		*ptr = regulator;
+		devres_add(dev, ptr);
+	} else {
+		devres_free(ptr);
+	}
+
+	return regulator;
+}
+EXPORT_SYMBOL_GPL(devm_regulator_get_optional);
+
 /* Locks held by regulator_put() */
 static void _regulator_put(struct regulator *regulator)
 {

commit 587cea27e4feee7365b22935b3e19e1e8906e9cb
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Jul 24 15:05:21 2013 -0700

    regulator: core: convert class code to use dev_groups
    
    The dev_attrs field of struct class is going away soon, dev_groups
    should be used instead.  This converts the regulator class code to use
    the correct field.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index f49c6615dc37..101f7cb14be6 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -323,13 +323,14 @@ static ssize_t regulator_uA_show(struct device *dev,
 }
 static DEVICE_ATTR(microamps, 0444, regulator_uA_show, NULL);
 
-static ssize_t regulator_name_show(struct device *dev,
-			     struct device_attribute *attr, char *buf)
+static ssize_t name_show(struct device *dev, struct device_attribute *attr,
+			 char *buf)
 {
 	struct regulator_dev *rdev = dev_get_drvdata(dev);
 
 	return sprintf(buf, "%s\n", rdev_get_name(rdev));
 }
+static DEVICE_ATTR_RO(name);
 
 static ssize_t regulator_print_opmode(char *buf, int mode)
 {
@@ -489,15 +490,16 @@ static ssize_t regulator_total_uA_show(struct device *dev,
 }
 static DEVICE_ATTR(requested_microamps, 0444, regulator_total_uA_show, NULL);
 
-static ssize_t regulator_num_users_show(struct device *dev,
-				      struct device_attribute *attr, char *buf)
+static ssize_t num_users_show(struct device *dev, struct device_attribute *attr,
+			      char *buf)
 {
 	struct regulator_dev *rdev = dev_get_drvdata(dev);
 	return sprintf(buf, "%d\n", rdev->use_count);
 }
+static DEVICE_ATTR_RO(num_users);
 
-static ssize_t regulator_type_show(struct device *dev,
-				  struct device_attribute *attr, char *buf)
+static ssize_t type_show(struct device *dev, struct device_attribute *attr,
+			 char *buf)
 {
 	struct regulator_dev *rdev = dev_get_drvdata(dev);
 
@@ -509,6 +511,7 @@ static ssize_t regulator_type_show(struct device *dev,
 	}
 	return sprintf(buf, "unknown\n");
 }
+static DEVICE_ATTR_RO(type);
 
 static ssize_t regulator_suspend_mem_uV_show(struct device *dev,
 				struct device_attribute *attr, char *buf)
@@ -632,12 +635,13 @@ static DEVICE_ATTR(bypass, 0444,
  * These are the only attributes are present for all regulators.
  * Other attributes are a function of regulator functionality.
  */
-static struct device_attribute regulator_dev_attrs[] = {
-	__ATTR(name, 0444, regulator_name_show, NULL),
-	__ATTR(num_users, 0444, regulator_num_users_show, NULL),
-	__ATTR(type, 0444, regulator_type_show, NULL),
-	__ATTR_NULL,
+static struct attribute *regulator_dev_attrs[] = {
+	&dev_attr_name.attr,
+	&dev_attr_num_users.attr,
+	&dev_attr_type.attr,
+	NULL,
 };
+ATTRIBUTE_GROUPS(regulator_dev);
 
 static void regulator_dev_release(struct device *dev)
 {
@@ -648,7 +652,7 @@ static void regulator_dev_release(struct device *dev)
 static struct class regulator_class = {
 	.name = "regulator",
 	.dev_release = regulator_dev_release,
-	.dev_attrs = regulator_dev_attrs,
+	.dev_groups = regulator_dev_groups,
 };
 
 /* Calculate the new optimum regulator operating mode based on the new total

commit 6c918d220925eeeca75b67e896eabffd061cd128
Author: Mark Brown <broonie@linaro.org>
Date:   Thu Jul 18 16:06:33 2013 +0100

    regulator: core: Ensure selector is mapped
    
    Clearly the testing only covered the bottom range.
    
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index fd3f6e003729..42ae134797e0 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2446,6 +2446,8 @@ int regulator_map_voltage_linear_range(struct regulator_dev *rdev,
 				return ret;
 		}
 
+		ret += range->min_sel;
+
 		break;
 	}
 

commit a56d66a2f01b172bc00d73b0b0392423c8aaae19
Author: Axel Lin <axel.lin@ingics.com>
Date:   Thu Jul 18 22:21:57 2013 +0800

    regulator: core: Allow fixed voltage range in multiple linear ranges
    
    Current code does not allow fixed voltage range in multiple linear ranges.
    If someone does set range->uV_step == 0 in one of the linear ranges, we hit
    divided by zero bug. This patch fixes this issue.
    For fixed voltage range, return any selector means the same voltage.
    Thus just return 0.
    
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index e8604be4c66d..fd3f6e003729 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2436,9 +2436,15 @@ int regulator_map_voltage_linear_range(struct regulator_dev *rdev,
 		if (min_uV <= range->min_uV)
 			min_uV = range->min_uV;
 
-		ret = DIV_ROUND_UP(min_uV - range->min_uV, range->uV_step);
-		if (ret < 0)
-			return ret;
+		/* range->uV_step == 0 means fixed voltage range */
+		if (range->uV_step == 0) {
+			ret = 0;
+		} else {
+			ret = DIV_ROUND_UP(min_uV - range->min_uV,
+					   range->uV_step);
+			if (ret < 0)
+				return ret;
+		}
 
 		break;
 	}

commit 070260f07c7daec311f2466eb9d1df475d5a46f8
Author: Mark Brown <broonie@linaro.org>
Date:   Thu Jul 18 11:52:04 2013 +0100

    regulator: core: Use the power efficient workqueue for delayed powerdown
    
    There is no need to use a normal per-CPU workqueue for delayed power downs
    as they're not timing or performance critical and waking up a core for them
    would defeat some of the point.
    
    Signed-off-by: Mark Brown <broonie@linaro.org>
    Reviewed-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Liam Girdwood <liam.r.girdwood@intel.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 1510333bcf0d..f49c6615dc37 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1890,8 +1890,9 @@ int regulator_disable_deferred(struct regulator *regulator, int ms)
 	rdev->deferred_disables++;
 	mutex_unlock(&rdev->mutex);
 
-	ret = schedule_delayed_work(&rdev->disable_work,
-				    msecs_to_jiffies(ms));
+	ret = queue_delayed_work(system_power_efficient_wq,
+				 &rdev->disable_work,
+				 msecs_to_jiffies(ms));
 	if (ret < 0)
 		return ret;
 	else

commit 5b175952011adae30b531ab89cc24acb173b2ce4
Author: Yadwinder Singh Brar <yadi.brar@samsung.com>
Date:   Sat Jun 29 18:21:19 2013 +0530

    regulator: core: Remove redundant checks
    
    In function _regulator_do_set_voltage(), old_selector gets intialised only
    if (_regulator_is_enabled(rdev) && rdev->desc->ops->set_voltage_time_sel &&
    rdev->desc->ops->get_voltage_sel)) is true.
    
    Before calling set_voltage_time_sel() we checks if (old_selector >= 0) and it
    will true if it got intialised properly. so we don't need to check again
    _regulator_is_enabled(rdev) && rdev->desc->ops->set_voltage_time_sel before
    calling set_voltage_time_sel().
    
    Signed-off-by: Yadwinder Singh Brar <yadi.brar@samsung.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 6e6371c2346c..15368f35bbdf 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2439,9 +2439,8 @@ static int _regulator_do_set_voltage(struct regulator_dev *rdev,
 	}
 
 	/* Call set_voltage_time_sel if successfully obtained old_selector */
-	if (ret == 0 && !rdev->constraints->ramp_disable &&
-	    _regulator_is_enabled(rdev) && old_selector >= 0 &&
-	    old_selector != selector && rdev->desc->ops->set_voltage_time_sel) {
+	if (ret == 0 && !rdev->constraints->ramp_disable && old_selector >= 0
+		&& old_selector != selector) {
 
 		delay = rdev->desc->ops->set_voltage_time_sel(rdev,
 						old_selector, selector);

commit 1653ccf4c52df6a4abe8ec2f33f2cb2896d129ea
Author: Yadwinder Singh Brar <yadi.brar@samsung.com>
Date:   Sat Jun 29 18:21:15 2013 +0530

    regulator: core: Add support for disabling ramp delay
    
    Some hardwares support disabling ramp delay, so adding ramp_disable flag to
    constraints. It will be used to figure out whether ramp_delay in constraints
    is explicitly set to zero or its unintialized (zero by default).
    And we don't need to call set_voltage_time_sel() for regulators for whom ramp
    delay is disabled in constraints.
    
    Signed-off-by: Yadwinder Singh Brar <yadi.brar@samsung.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 288c75abc190..6e6371c2346c 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -984,7 +984,8 @@ static int set_machine_constraints(struct regulator_dev *rdev,
 		}
 	}
 
-	if (rdev->constraints->ramp_delay && ops->set_ramp_delay) {
+	if ((rdev->constraints->ramp_delay || rdev->constraints->ramp_disable)
+		&& ops->set_ramp_delay) {
 		ret = ops->set_ramp_delay(rdev, rdev->constraints->ramp_delay);
 		if (ret < 0) {
 			rdev_err(rdev, "failed to set ramp_delay\n");
@@ -2438,7 +2439,8 @@ static int _regulator_do_set_voltage(struct regulator_dev *rdev,
 	}
 
 	/* Call set_voltage_time_sel if successfully obtained old_selector */
-	if (ret == 0 && _regulator_is_enabled(rdev) && old_selector >= 0 &&
+	if (ret == 0 && !rdev->constraints->ramp_disable &&
+	    _regulator_is_enabled(rdev) && old_selector >= 0 &&
 	    old_selector != selector && rdev->desc->ops->set_voltage_time_sel) {
 
 		delay = rdev->desc->ops->set_voltage_time_sel(rdev,

commit 94d33c02c7186b69849c292e1216a08ad1c0d99d
Author: Mark Brown <broonie@linaro.org>
Date:   Tue Jul 2 22:52:41 2013 +0100

    regulator: core: Add helpers for multiple linear ranges
    
    Many regulators have several linear ranges of selector with different
    step sizes, for example offering better resolution at lower voltages.
    Provide regulator_{map,list}_voltage_linear_range() allowing these
    regulators to use generic code. To do so a table of regulator_linear_range
    structs needs to be pointed to from the descriptor.
    
    This was inspired by similar code included in a driver submission from
    Chao Xie and Yi Zhang at Marvell.
    
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 288c75abc190..e8604be4c66d 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2078,6 +2078,43 @@ int regulator_list_voltage_linear(struct regulator_dev *rdev,
 }
 EXPORT_SYMBOL_GPL(regulator_list_voltage_linear);
 
+/**
+ * regulator_list_voltage_linear_range - List voltages for linear ranges
+ *
+ * @rdev: Regulator device
+ * @selector: Selector to convert into a voltage
+ *
+ * Regulators with a series of simple linear mappings between voltages
+ * and selectors can set linear_ranges in the regulator descriptor and
+ * then use this function as their list_voltage() operation,
+ */
+int regulator_list_voltage_linear_range(struct regulator_dev *rdev,
+					unsigned int selector)
+{
+	const struct regulator_linear_range *range;
+	int i;
+
+	if (!rdev->desc->n_linear_ranges) {
+		BUG_ON(!rdev->desc->n_linear_ranges);
+		return -EINVAL;
+	}
+
+	for (i = 0; i < rdev->desc->n_linear_ranges; i++) {
+		range = &rdev->desc->linear_ranges[i];
+
+		if (!(selector >= range->min_sel &&
+		      selector <= range->max_sel))
+			continue;
+
+		selector -= range->min_sel;
+
+		return range->min_uV + (range->uV_step * selector);
+	}
+
+	return -EINVAL;
+}
+EXPORT_SYMBOL_GPL(regulator_list_voltage_linear_range);
+
 /**
  * regulator_list_voltage_table - List voltages with table based mapping
  *
@@ -2368,6 +2405,56 @@ int regulator_map_voltage_linear(struct regulator_dev *rdev,
 }
 EXPORT_SYMBOL_GPL(regulator_map_voltage_linear);
 
+/**
+ * regulator_map_voltage_linear - map_voltage() for multiple linear ranges
+ *
+ * @rdev: Regulator to operate on
+ * @min_uV: Lower bound for voltage
+ * @max_uV: Upper bound for voltage
+ *
+ * Drivers providing linear_ranges in their descriptor can use this as
+ * their map_voltage() callback.
+ */
+int regulator_map_voltage_linear_range(struct regulator_dev *rdev,
+				       int min_uV, int max_uV)
+{
+	const struct regulator_linear_range *range;
+	int ret = -EINVAL;
+	int voltage, i;
+
+	if (!rdev->desc->n_linear_ranges) {
+		BUG_ON(!rdev->desc->n_linear_ranges);
+		return -EINVAL;
+	}
+
+	for (i = 0; i < rdev->desc->n_linear_ranges; i++) {
+		range = &rdev->desc->linear_ranges[i];
+
+		if (!(min_uV <= range->max_uV && max_uV >= range->min_uV))
+			continue;
+
+		if (min_uV <= range->min_uV)
+			min_uV = range->min_uV;
+
+		ret = DIV_ROUND_UP(min_uV - range->min_uV, range->uV_step);
+		if (ret < 0)
+			return ret;
+
+		break;
+	}
+
+	if (i == rdev->desc->n_linear_ranges)
+		return -EINVAL;
+
+	/* Map back into a voltage to verify we're still in bounds */
+	voltage = rdev->desc->ops->list_voltage(rdev, ret);
+	if (voltage < min_uV || voltage > max_uV)
+		return -EINVAL;
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(regulator_map_voltage_linear_range);
+
 static int _regulator_do_set_voltage(struct regulator_dev *rdev,
 				     int min_uV, int max_uV)
 {

commit 891636ea27ef42d92a420185d2ccbe190ba00a23
Author: Mark Brown <broonie@linaro.org>
Date:   Mon Jul 8 09:14:45 2013 +0100

    regulator: core: Drop references on supply regulator when unregistering
    
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 288c75abc190..1510333bcf0d 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -3740,8 +3740,11 @@ void regulator_unregister(struct regulator_dev *rdev)
 	if (rdev == NULL)
 		return;
 
-	if (rdev->supply)
+	if (rdev->supply) {
+		while (rdev->use_count--)
+			regulator_disable(rdev->supply);
 		regulator_put(rdev->supply);
+	}
 	mutex_lock(&regulator_list_mutex);
 	debugfs_remove_recursive(rdev->debugfs);
 	flush_work(&rdev->disable_work.work);

commit 0a192cc8600bede44a0425402758631d410a7c6f
Merge: 39c9f80f43d7 2a668a8bc2cb
Author: Mark Brown <broonie@linaro.org>
Date:   Mon Jul 1 11:17:08 2013 +0100

    Merge remote-tracking branch 'regulator/topic/linar' into regulator-next

commit 2a668a8bc2cbe7a464ab1212475a3efb23a94b1e
Author: Paul Walmsley <pwalmsley@nvidia.com>
Date:   Fri Jun 7 08:06:56 2013 +0000

    regulator: core: add regulator_get_linear_step()
    
    Add regulator_get_linear_step(), which returns the voltage step size
    between VSEL values for linear regulators.  This is intended for use
    by regulator consumers which build their own voltage-to-VSEL tables.
    
    Signed-off-by: Paul Walmsley <pwalmsley@nvidia.com>
    Reviewed-by: Andrew Chew <achew@nvidia.com>
    Cc: Matthew Longnecker <mlongnecker@nvidia.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 6e5017841582..f07d7adefdda 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2134,6 +2134,21 @@ int regulator_list_voltage(struct regulator *regulator, unsigned selector)
 }
 EXPORT_SYMBOL_GPL(regulator_list_voltage);
 
+/**
+ * regulator_get_linear_step - return the voltage step size between VSEL values
+ * @regulator: regulator source
+ *
+ * Returns the voltage step size between VSEL values for linear
+ * regulators, or return 0 if the regulator isn't a linear regulator.
+ */
+unsigned int regulator_get_linear_step(struct regulator *regulator)
+{
+	struct regulator_dev *rdev = regulator->rdev;
+
+	return rdev->desc->uV_step;
+}
+EXPORT_SYMBOL_GPL(regulator_get_linear_step);
+
 /**
  * regulator_is_supported_voltage - check if a voltage range can be supported
  *

commit 2a66a854f5d716bb67e24dba78e53bdd5f0253ad
Merge: e4bf063cb8b5 31d6eebf7e07
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Thu May 30 11:58:39 2013 +0100

    Merge remote-tracking branch 'regulator/fix/doc' into regulator-linus

commit ce0d10f887cabf9f16d1cbb60ef013021befbfdf
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Tue May 21 15:04:07 2013 +0100

    regulator: core: Correct spelling mistake in comment
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 6e5017841582..5e50b20f0f96 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2702,7 +2702,7 @@ EXPORT_SYMBOL_GPL(regulator_get_voltage);
 /**
  * regulator_set_current_limit - set regulator output current limit
  * @regulator: regulator source
- * @min_uA: Minimuum supported current in uA
+ * @min_uA: Minimum supported current in uA
  * @max_uA: Maximum supported current in uA
  *
  * Sets current sink to the desired output current. This can be set during

commit 31d6eebf7e079cfb5e98e65d5af4c6de093e076c
Author: Robert P. J. Day <rpjday@crashcourse.ca>
Date:   Thu May 2 10:19:11 2013 -0400

    regulator: Fix kernel-doc generation warnings.
    
    Add a couple kernel-doc lines to get rid of kernel-doc generation
    warnings, no functional change.
    
    Signed-off-by: Robert P. J. Day <rpjday@crashcourse.ca>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 6e5017841582..014c92a5434d 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1539,7 +1539,10 @@ static void regulator_ena_gpio_free(struct regulator_dev *rdev)
 }
 
 /**
- * Balance enable_count of each GPIO and actual GPIO pin control.
+ * regulator_ena_gpio_ctrl - balance enable_count of each GPIO and actual GPIO pin control
+ * @rdev: regulator_dev structure
+ * @enable: enable GPIO at initial use?
+ *
  * GPIO is enabled in case of initial use. (enable_count is 0)
  * GPIO is disabled when it is not shared any more. (enable_count <= 1)
  */

commit 3dc06c1baf2b28e5365a1159755eac2e95142601
Merge: 5f19a85ba728 407945fd78c3
Author: Mark Brown <broonie@sirena.org.uk>
Date:   Sun Apr 28 02:13:40 2013 +0100

    Merge remote-tracking branch 'regulator/topic/gpio' into v3.9-rc8

commit 1d60a4cf975a196d585149e667f58cbca1a574fc
Merge: 0e340ce1ddcf ea88b132acdf
Author: Mark Brown <broonie@sirena.org.uk>
Date:   Sun Apr 28 02:13:37 2013 +0100

    Merge remote-tracking branch 'regulator/topic/enable-invert' into v3.9-rc8

commit 0e340ce1ddcf41ca435ef695ef004a6f587c749e
Merge: 97844ede9487 020501f1a091
Author: Mark Brown <broonie@sirena.org.uk>
Date:   Sun Apr 28 02:13:37 2013 +0100

    Merge remote-tracking branch 'regulator/topic/core' into v3.9-rc8

commit fcf371ee5624cc87abac205cd0dad2432d7f0346
Author: Axel Lin <axel.lin@ingics.com>
Date:   Thu Apr 18 10:34:49 2013 +0800

    regulator: core: Add regulator_map_voltage_ascend() API
    
    A lot of regulator hardware has ascendant voltage list.
    This patch adds regulator_map_voltage_ascend() and export it.
    
    Drivers that have ascendant voltage list can use this as their map_voltage()
    operation, this is more efficient than default regulator_map_voltage_iterate()
    function.
    
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index e3661c20cf38..56f4ca0854c9 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2137,6 +2137,37 @@ int regulator_map_voltage_iterate(struct regulator_dev *rdev,
 }
 EXPORT_SYMBOL_GPL(regulator_map_voltage_iterate);
 
+/**
+ * regulator_map_voltage_ascend - map_voltage() for ascendant voltage list
+ *
+ * @rdev: Regulator to operate on
+ * @min_uV: Lower bound for voltage
+ * @max_uV: Upper bound for voltage
+ *
+ * Drivers that have ascendant voltage list can use this as their
+ * map_voltage() operation.
+ */
+int regulator_map_voltage_ascend(struct regulator_dev *rdev,
+				 int min_uV, int max_uV)
+{
+	int i, ret;
+
+	for (i = 0; i < rdev->desc->n_voltages; i++) {
+		ret = rdev->desc->ops->list_voltage(rdev, i);
+		if (ret < 0)
+			continue;
+
+		if (ret > max_uV)
+			break;
+
+		if (ret >= min_uV && ret <= max_uV)
+			return i;
+	}
+
+	return -EINVAL;
+}
+EXPORT_SYMBOL_GPL(regulator_map_voltage_ascend);
+
 /**
  * regulator_map_voltage_linear - map_voltage() for simple linear mappings
  *

commit 1e4b545cdd93318379c6b1fb0a99536fa3260f53
Author: Nishanth Menon <nm@ti.com>
Date:   Tue Apr 16 16:45:16 2013 -0500

    regulator: core: return err value for regulator_get if there is no DT binding
    
    commit 6d191a5fc7a969d972f1681e1c23781aecb06a61
    (regulator: core: Don't defer probe if there's no DT binding for a supply)
    
    Attempted to differentiate between regulator_get() with an actual
    DT binding for the supply and when there is none to avoid unnecessary
    deferal.
    However, ret value supplied by regulator_dev_lookup() is being
    ignored by regulator_get(). So, exit with the appropriate return value.
    
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index a51e1e5fdff3..73edb0ef6e17 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1229,7 +1229,7 @@ static struct regulator *_regulator_get(struct device *dev, const char *id,
 	struct regulator_dev *rdev;
 	struct regulator *regulator = ERR_PTR(-EPROBE_DEFER);
 	const char *devname = NULL;
-	int ret;
+	int ret = 0;
 
 	if (id == NULL) {
 		pr_err("get() with no identifier\n");
@@ -1245,6 +1245,15 @@ static struct regulator *_regulator_get(struct device *dev, const char *id,
 	if (rdev)
 		goto found;
 
+	/*
+	 * If we have return value from dev_lookup fail, we do not expect to
+	 * succeed, so, quit with appropriate error value
+	 */
+	if (ret) {
+		regulator = ERR_PTR(ret);
+		goto out;
+	}
+
 	if (board_wants_dummy_regulator) {
 		rdev = dummy_regulator_rdev;
 		goto found;

commit 0f7b87f0acc04e4f22ec5d3f2283a80993ca3aa8
Author: Andrew Bresticker <abrestic@chromium.org>
Date:   Thu Apr 4 15:27:47 2013 -0700

    regulator: core: don't require a supply when supply_name is specified
    
    Regulator drivers may specify regulator_desc->supply_name which
    regulator_register() will use to find the supply node for a regulator.
    If no supply was specified in the device tree or the supply has yet
    to be registered regulator_register() will fail, deferring the probe
    of the regulator.  In the case where no supply node was specified in the
    device tree, there is no supply and it is pointless to try and find one
    later, so go ahead and add the regulator without the supply.
    
    Signed-off-by: Andrew Bresticker <abrestic@chromium.org>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index edfa2230d475..a51e1e5fdff3 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -3477,7 +3477,14 @@ regulator_register(const struct regulator_desc *regulator_desc,
 
 		r = regulator_dev_lookup(dev, supply, &ret);
 
-		if (!r) {
+		if (ret == -ENODEV) {
+			/*
+			 * No supply was specified for this regulator and
+			 * there will never be one.
+			 */
+			ret = 0;
+			goto add_dev;
+		} else if (!r) {
 			dev_err(dev, "Failed to find supply %s\n", supply);
 			ret = -EPROBE_DEFER;
 			goto scrub;
@@ -3495,6 +3502,7 @@ regulator_register(const struct regulator_desc *regulator_desc,
 		}
 	}
 
+add_dev:
 	/* add consumers devices */
 	if (init_data) {
 		for (i = 0; i < init_data->num_consumer_supplies; i++) {

commit 167d41dce7633b70aae4175fdec734e1cdd3a190
Author: Maxime Ripard <maxime.ripard@free-electrons.com>
Date:   Sat Mar 23 11:00:41 2013 +0100

    regulator: Fix typo in of_get_regulator function comments
    
    Signed-off-by: Maxime Ripard <maxime.ripard@free-electrons.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index da9782bd27d0..edfa2230d475 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -116,7 +116,7 @@ static const char *rdev_get_name(struct regulator_dev *rdev)
  * @supply: regulator supply name
  *
  * Extract the regulator device node corresponding to the supply name.
- * retruns the device node corresponding to the regulator if found, else
+ * returns the device node corresponding to the regulator if found, else
  * returns NULL.
  */
 static struct device_node *of_get_regulator(struct device *dev, const char *supply)

commit 51dcdafcb720a9d1fd73b597d0ccf48837abc59f
Author: Axel Lin <axel.lin@ingics.com>
Date:   Tue Mar 5 14:16:00 2013 +0800

    regulator: core: Add enable_is_inverted flag to indicate set enable_mask bits to disable
    
    Add enable_is_inverted flag to indicate set enable_mask bits to disable
    when using regulator_enable_regmap and friends APIs.
    
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Reviewed-by: Haojian Zhuang <haojian.zhuang@gmail.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 154bc8f0c1a0..d887b9f5b213 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1794,7 +1794,10 @@ int regulator_is_enabled_regmap(struct regulator_dev *rdev)
 	if (ret != 0)
 		return ret;
 
-	return (val & rdev->desc->enable_mask) != 0;
+	if (rdev->desc->enable_is_inverted)
+		return (val & rdev->desc->enable_mask) == 0;
+	else
+		return (val & rdev->desc->enable_mask) != 0;
 }
 EXPORT_SYMBOL_GPL(regulator_is_enabled_regmap);
 
@@ -1809,9 +1812,15 @@ EXPORT_SYMBOL_GPL(regulator_is_enabled_regmap);
  */
 int regulator_enable_regmap(struct regulator_dev *rdev)
 {
+	unsigned int val;
+
+	if (rdev->desc->enable_is_inverted)
+		val = 0;
+	else
+		val = rdev->desc->enable_mask;
+
 	return regmap_update_bits(rdev->regmap, rdev->desc->enable_reg,
-				  rdev->desc->enable_mask,
-				  rdev->desc->enable_mask);
+				  rdev->desc->enable_mask, val);
 }
 EXPORT_SYMBOL_GPL(regulator_enable_regmap);
 
@@ -1826,8 +1835,15 @@ EXPORT_SYMBOL_GPL(regulator_enable_regmap);
  */
 int regulator_disable_regmap(struct regulator_dev *rdev)
 {
+	unsigned int val;
+
+	if (rdev->desc->enable_is_inverted)
+		val = rdev->desc->enable_mask;
+	else
+		val = 0;
+
 	return regmap_update_bits(rdev->regmap, rdev->desc->enable_reg,
-				  rdev->desc->enable_mask, 0);
+				  rdev->desc->enable_mask, val);
 }
 EXPORT_SYMBOL_GPL(regulator_disable_regmap);
 

commit 6d62768468d5ff96b3977a04045dd80d6710be5d
Merge: 521e2e03b8f6 9345dfb8495a
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Mar 5 10:12:39 2013 +0800

    Merge remote-tracking branch 'regulator/fix/doc' into tmp

commit 7b74d149247c8972da1cec3e4c70b67049aaeb69
Author: Kim, Milo <Milo.Kim@ti.com>
Date:   Mon Feb 18 06:50:55 2013 +0000

    regulator: core: use regulator_ena_pin member
    
     The regulator_dev has regulator_enable_gpio structure.
     'ena_gpio' and 'ena_gpio_invert' were moved to in regulator_enable_gpio.
    
      regulator_dev   --->   regulator_enable_gpio
      .ena_gpio              .gpio
      .ena_gpio_invert       .ena_gpio_invert
    
      Pointer, 'ena_pin' is used for checking valid enable GPIO pin.
    
    Signed-off-by: Milo(Woogyom) Kim <milo.kim@ti.com>
    Reviewed-by: Axel Lin <axel.lin@ingics.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 57d434d3145a..6c8c82406cd9 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1945,7 +1945,7 @@ EXPORT_SYMBOL_GPL(regulator_disable_regmap);
 static int _regulator_is_enabled(struct regulator_dev *rdev)
 {
 	/* A GPIO control always takes precedence */
-	if (rdev->ena_gpio)
+	if (rdev->ena_pin)
 		return rdev->ena_gpio_state;
 
 	/* If we don't know then assume that the regulator is always on */
@@ -3344,7 +3344,7 @@ static int add_regulator_attributes(struct regulator_dev *rdev)
 		if (status < 0)
 			return status;
 	}
-	if (rdev->ena_gpio || ops->is_enabled) {
+	if (rdev->ena_pin || ops->is_enabled) {
 		status = device_create_file(dev, &dev_attr_state);
 		if (status < 0)
 			return status;
@@ -3556,7 +3556,7 @@ regulator_register(const struct regulator_desc *regulator_desc,
 		if (config->ena_gpio_flags & GPIOF_OUT_INIT_HIGH)
 			rdev->ena_gpio_state = 1;
 
-		if (rdev->ena_gpio_invert)
+		if (config->ena_gpio_invert)
 			rdev->ena_gpio_state = !rdev->ena_gpio_state;
 	}
 

commit 967cfb18c0e331b43a29ae7f60ec1ef0dcb02f6b
Author: Kim, Milo <Milo.Kim@ti.com>
Date:   Mon Feb 18 06:50:48 2013 +0000

    regulator: core: manage enable GPIO list
    
     To support shared enable GPIO pin, replace GPIO code with new static functions
    
     Reference count: 'enable_count'
       Balance the reference count of each GPIO and actual pin control.
       The count is incremented with enabling GPIO.
       On the other hand, it is decremented on disabling GPIO.
       Actual GPIO pin is enabled at the initial use.(enable_count = 0)
       The pin is disabled if it is not used(shared) any more. (enable_count <=1)
       Regardless of the enable count, update GPIO state of the regulator.
    
    Signed-off-by: Milo(Woogyom) Kim <milo.kim@ti.com>
    Reviewed-by: Axel Lin <axel.lin@ingics.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 71d6adc4eeab..57d434d3145a 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1529,6 +1529,42 @@ static void regulator_ena_gpio_free(struct regulator_dev *rdev)
 	}
 }
 
+/**
+ * Balance enable_count of each GPIO and actual GPIO pin control.
+ * GPIO is enabled in case of initial use. (enable_count is 0)
+ * GPIO is disabled when it is not shared any more. (enable_count <= 1)
+ */
+static int regulator_ena_gpio_ctrl(struct regulator_dev *rdev, bool enable)
+{
+	struct regulator_enable_gpio *pin = rdev->ena_pin;
+
+	if (!pin)
+		return -EINVAL;
+
+	if (enable) {
+		/* Enable GPIO at initial use */
+		if (pin->enable_count == 0)
+			gpio_set_value_cansleep(pin->gpio,
+						!pin->ena_gpio_invert);
+
+		pin->enable_count++;
+	} else {
+		if (pin->enable_count > 1) {
+			pin->enable_count--;
+			return 0;
+		}
+
+		/* Disable GPIO if not used */
+		if (pin->enable_count <= 1) {
+			gpio_set_value_cansleep(pin->gpio,
+						pin->ena_gpio_invert);
+			pin->enable_count = 0;
+		}
+	}
+
+	return 0;
+}
+
 static int _regulator_do_enable(struct regulator_dev *rdev)
 {
 	int ret, delay;
@@ -1544,9 +1580,10 @@ static int _regulator_do_enable(struct regulator_dev *rdev)
 
 	trace_regulator_enable(rdev_get_name(rdev));
 
-	if (rdev->ena_gpio) {
-		gpio_set_value_cansleep(rdev->ena_gpio,
-					!rdev->ena_gpio_invert);
+	if (rdev->ena_pin) {
+		ret = regulator_ena_gpio_ctrl(rdev, true);
+		if (ret < 0)
+			return ret;
 		rdev->ena_gpio_state = 1;
 	} else if (rdev->desc->ops->enable) {
 		ret = rdev->desc->ops->enable(rdev);
@@ -1648,9 +1685,10 @@ static int _regulator_do_disable(struct regulator_dev *rdev)
 
 	trace_regulator_disable(rdev_get_name(rdev));
 
-	if (rdev->ena_gpio) {
-		gpio_set_value_cansleep(rdev->ena_gpio,
-					rdev->ena_gpio_invert);
+	if (rdev->ena_pin) {
+		ret = regulator_ena_gpio_ctrl(rdev, false);
+		if (ret < 0)
+			return ret;
 		rdev->ena_gpio_state = 0;
 
 	} else if (rdev->desc->ops->disable) {

commit f19b00da8ed37db4e3891fe534fcf3a605a0e562
Author: Kim, Milo <Milo.Kim@ti.com>
Date:   Mon Feb 18 06:50:39 2013 +0000

    regulator: core: support shared enable GPIO concept
    
     A Regulator can be enabled by external GPIO pin.
     This is configurable in the regulator_config.
     At this moment, the GPIO can be owned by only one regulator device.
     In some devices, multiple regulators are enabled by shared one GPIO pin.
     This patch extends this limitation, enabling shared enable GPIO of regulators.
    
     New list for enable GPIO: 'regulator_ena_gpio_list'
       This manages enable GPIO list.
    
     New structure for supporting shared enable GPIO: 'regulator_enable_gpio'
       The enable count is used for balancing GPIO control count.
       This count is incremented when GPIO is enabled.
       On the other hand, it's decremented when GPIO is disabled.
    
     Reference count: 'request_count'
       The reference count, 'request_count' is incremented/decremented on
       requesting/freeing the GPIO. This count makes sure only free the GPIO
       when it has no users.
    
     How it works
       If the GPIO is already used, skip requesting new GPIO usage.
       The GPIO is new one, request GPIO function and add it to the list of
       enable GPIO.
       This list is used for balancing enable GPIO count and pin control.
    
     Updating a GPIO and invert code moved
       'ena_gpio' and 'ena_gpio_invert' of the regulator_config were moved to
        new function, regulator_ena_gpio_request().
        Use regulator_enable_pin structure rather than regulator_dev.
    
    Signed-off-by: Milo(Woogyom) Kim <milo.kim@ti.com>
    Reviewed-by: Axel Lin <axel.lin@ingics.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index da9782bd27d0..71d6adc4eeab 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -51,6 +51,7 @@
 static DEFINE_MUTEX(regulator_list_mutex);
 static LIST_HEAD(regulator_list);
 static LIST_HEAD(regulator_map_list);
+static LIST_HEAD(regulator_ena_gpio_list);
 static bool has_full_constraints;
 static bool board_wants_dummy_regulator;
 
@@ -68,6 +69,19 @@ struct regulator_map {
 	struct regulator_dev *regulator;
 };
 
+/*
+ * struct regulator_enable_gpio
+ *
+ * Management for shared enable GPIO pin
+ */
+struct regulator_enable_gpio {
+	struct list_head list;
+	int gpio;
+	u32 enable_count;	/* a number of enabled shared GPIO */
+	u32 request_count;	/* a number of requested shared GPIO */
+	unsigned int ena_gpio_invert:1;
+};
+
 /*
  * struct regulator
  *
@@ -1456,6 +1470,65 @@ void devm_regulator_put(struct regulator *regulator)
 }
 EXPORT_SYMBOL_GPL(devm_regulator_put);
 
+/* Manage enable GPIO list. Same GPIO pin can be shared among regulators */
+static int regulator_ena_gpio_request(struct regulator_dev *rdev,
+				const struct regulator_config *config)
+{
+	struct regulator_enable_gpio *pin;
+	int ret;
+
+	list_for_each_entry(pin, &regulator_ena_gpio_list, list) {
+		if (pin->gpio == config->ena_gpio) {
+			rdev_dbg(rdev, "GPIO %d is already used\n",
+				config->ena_gpio);
+			goto update_ena_gpio_to_rdev;
+		}
+	}
+
+	ret = gpio_request_one(config->ena_gpio,
+				GPIOF_DIR_OUT | config->ena_gpio_flags,
+				rdev_get_name(rdev));
+	if (ret)
+		return ret;
+
+	pin = kzalloc(sizeof(struct regulator_enable_gpio), GFP_KERNEL);
+	if (pin == NULL) {
+		gpio_free(config->ena_gpio);
+		return -ENOMEM;
+	}
+
+	pin->gpio = config->ena_gpio;
+	pin->ena_gpio_invert = config->ena_gpio_invert;
+	list_add(&pin->list, &regulator_ena_gpio_list);
+
+update_ena_gpio_to_rdev:
+	pin->request_count++;
+	rdev->ena_pin = pin;
+	return 0;
+}
+
+static void regulator_ena_gpio_free(struct regulator_dev *rdev)
+{
+	struct regulator_enable_gpio *pin, *n;
+
+	if (!rdev->ena_pin)
+		return;
+
+	/* Free the GPIO only in case of no use */
+	list_for_each_entry_safe(pin, n, &regulator_ena_gpio_list, list) {
+		if (pin->gpio == rdev->ena_pin->gpio) {
+			if (pin->request_count <= 1) {
+				pin->request_count = 0;
+				gpio_free(pin->gpio);
+				list_del(&pin->list);
+				kfree(pin);
+			} else {
+				pin->request_count--;
+			}
+		}
+	}
+}
+
 static int _regulator_do_enable(struct regulator_dev *rdev)
 {
 	int ret, delay;
@@ -3435,18 +3508,13 @@ regulator_register(const struct regulator_desc *regulator_desc,
 	dev_set_drvdata(&rdev->dev, rdev);
 
 	if (config->ena_gpio && gpio_is_valid(config->ena_gpio)) {
-		ret = gpio_request_one(config->ena_gpio,
-				       GPIOF_DIR_OUT | config->ena_gpio_flags,
-				       rdev_get_name(rdev));
+		ret = regulator_ena_gpio_request(rdev, config);
 		if (ret != 0) {
 			rdev_err(rdev, "Failed to request enable GPIO%d: %d\n",
 				 config->ena_gpio, ret);
 			goto wash;
 		}
 
-		rdev->ena_gpio = config->ena_gpio;
-		rdev->ena_gpio_invert = config->ena_gpio_invert;
-
 		if (config->ena_gpio_flags & GPIOF_OUT_INIT_HIGH)
 			rdev->ena_gpio_state = 1;
 
@@ -3522,8 +3590,7 @@ regulator_register(const struct regulator_desc *regulator_desc,
 scrub:
 	if (rdev->supply)
 		_regulator_put(rdev->supply);
-	if (rdev->ena_gpio)
-		gpio_free(rdev->ena_gpio);
+	regulator_ena_gpio_free(rdev);
 	kfree(rdev->constraints);
 wash:
 	device_unregister(&rdev->dev);
@@ -3558,8 +3625,7 @@ void regulator_unregister(struct regulator_dev *rdev)
 	unset_regulator_supplies(rdev);
 	list_del(&rdev->list);
 	kfree(rdev->constraints);
-	if (rdev->ena_gpio)
-		gpio_free(rdev->ena_gpio);
+	regulator_ena_gpio_free(rdev);
 	device_unregister(&rdev->dev);
 	mutex_unlock(&regulator_list_mutex);
 }

commit fbe31057fafebdc2811a7101b8b4a0460f5417d1
Author: Andrzej Hajda <a.hajda@samsung.com>
Date:   Fri Mar 1 12:24:05 2013 +0100

    regulator: fixed regulator_bulk_enable unwinding code
    
    Unwinding code disables all successfully enabled regulators.
    Error is logged for every failed regulator.
    
    Signed-off-by: Andrzej Hajda <a.hajda@samsung.com>
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index da9782bd27d0..4a7790c58257 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -3057,9 +3057,13 @@ int regulator_bulk_enable(int num_consumers,
 	return 0;
 
 err:
-	pr_err("Failed to enable %s: %d\n", consumers[i].supply, ret);
-	while (--i >= 0)
-		regulator_disable(consumers[i].consumer);
+	for (i = 0; i < num_consumers; i++) {
+		if (consumers[i].ret < 0)
+			pr_err("Failed to enable %s: %d\n", consumers[i].supply,
+			       consumers[i].ret);
+		else
+			regulator_disable(consumers[i].consumer);
+	}
 
 	return ret;
 }

commit 9345dfb8495aa17ce7c575e1a96e5ad64def0b3d
Author: Nishanth Menon <nm@ti.com>
Date:   Thu Feb 28 18:44:54 2013 -0600

    regulator: core: fix documentation error in regulator_allow_bypass
    
    commit f59c8f9f (regulator: core: Support bypass mode)
    has a short documentation error around the regulator_allow_bypass
    parameter 'enable' which is documented as 'allow'.
    
    This generates kernel-doc warning as follows:
    ./scripts/kernel-doc drivers/regulator/core.c >/dev/null
    Warning(drivers/regulator/core.c:2841): No description found for parameter 'enable'
    Warning(drivers/regulator/core.c:2841): Excess function parameter 'allow' description in 'regulator_allow_bypass'
    
    Cc: Liam Girdwood <lgirdwood@gmail.com>
    Cc: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index da9782bd27d0..154bc8f0c1a0 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2830,7 +2830,7 @@ EXPORT_SYMBOL_GPL(regulator_get_bypass_regmap);
  * regulator_allow_bypass - allow the regulator to go into bypass mode
  *
  * @regulator: Regulator to configure
- * @allow: enable or disable bypass mode
+ * @enable: enable or disable bypass mode
  *
  * Allow the regulator to go into bypass mode if all other consumers
  * for the regulator also enable bypass mode and the machine

commit a4dba88e6311ac51ea4328fea6fd000dc2948ddb
Merge: eb230d4a6120 896b65f3453d
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Feb 19 12:42:34 2013 +0000

    Merge remote-tracking branch 'regulator/topic/gpio' into regulator-next

commit 52582adcb9c45b0d7b6decfb39325c303f06d8e0
Merge: 20ab4a7a792b 9c7b4e8a8ad2
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Feb 19 12:42:32 2013 +0000

    Merge remote-tracking branch 'regulator/topic/core' into regulator-next

commit fc221525bd63887f74c18708ee1d654d019fa8c3
Merge: 0dbf165ec43d c6f0a0efb163
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Feb 19 12:42:29 2013 +0000

    Merge remote-tracking branch 'regulator/topic/apply' into regulator-next

commit 9c7b4e8a8ad2624106fbf690fa97ab9c8c9bfa88
Author: Russ Dill <Russ.Dill@ti.com>
Date:   Thu Feb 14 04:46:33 2013 -0800

    regulator: Fix memory garbage dev_err printout.
    
    commit dd8004af: 'regulator: core: Log when a device causes a voltage
    constraint fail', tried to print out some information about the
    check consumer min/max uV fixup, however, it uses a garbage pointer
    left over from list_for_each_entry leading to boot messages in the
    form:
    
    '[    2.079890] <RANDOM ASCII>: Restricting voltage, 3735899821-4294967295uV'
    
    Because it references regulator->dev, it could potentially read memory from
    anywhere causing a panic.
    
    This patch instead uses rdev and the updated min/max uV values.
    
    Signed-off-by: Russ Dill <Russ.Dill@ti.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index abd3a05e8ee2..8d5e491514ee 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -200,8 +200,8 @@ static int regulator_check_consumers(struct regulator_dev *rdev,
 	}
 
 	if (*min_uV > *max_uV) {
-		dev_err(regulator->dev, "Restricting voltage, %u-%uuV\n",
-			regulator->min_uV, regulator->max_uV);
+		rdev_err(rdev, "Restricting voltage, %u-%uuV\n",
+			*min_uV, *max_uV);
 		return -EINVAL;
 	}
 

commit f2e5d078f7f02d4289db31f5f63e23e39914075e
Merge: c66a566afbe6 836dc9e3fbba
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Thu Feb 14 16:13:19 2013 +0000

    Merge tag 'v3.8-rc7' into regulator-core
    
    Linux 3.8-rc7

commit c66a566afbe6e2c94b1ae70f70cc1e3d4c73639b
Author: Axel Lin <axel.lin@ingics.com>
Date:   Wed Feb 6 11:09:48 2013 +0800

    regulator: core: Optimize _regulator_do_set_voltage if voltage does not change
    
    Optimize _regulator_do_set_voltage() for the case selector is equal to
    old_selector. Since the voltage does not change, we don't need to call
    set_voltage_sel() and set_voltage_time_sel() in this case.
    
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index c347fd03b727..7ec2ed6a1d7b 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2185,8 +2185,11 @@ static int _regulator_do_set_voltage(struct regulator_dev *rdev,
 			best_val = rdev->desc->ops->list_voltage(rdev, ret);
 			if (min_uV <= best_val && max_uV >= best_val) {
 				selector = ret;
-				ret = rdev->desc->ops->set_voltage_sel(rdev,
-								       ret);
+				if (old_selector == selector)
+					ret = 0;
+				else
+					ret = rdev->desc->ops->set_voltage_sel(
+								rdev, ret);
 			} else {
 				ret = -EINVAL;
 			}
@@ -2197,7 +2200,7 @@ static int _regulator_do_set_voltage(struct regulator_dev *rdev,
 
 	/* Call set_voltage_time_sel if successfully obtained old_selector */
 	if (ret == 0 && _regulator_is_enabled(rdev) && old_selector >= 0 &&
-	    rdev->desc->ops->set_voltage_time_sel) {
+	    old_selector != selector && rdev->desc->ops->set_voltage_time_sel) {
 
 		delay = rdev->desc->ops->set_voltage_time_sel(rdev,
 						old_selector, selector);

commit 896b65f3453d434983969e3ee7c254f4f8ba1424
Author: Michał Mirosław <mirq-linux@rere.qmqm.pl>
Date:   Fri Feb 1 20:40:17 2013 +0100

    regulator: show state for GPIO-controlled regulators
    
    Signed-off-by: Michał Mirosław <mirq-linux@rere.qmqm.pl>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 278584302f2d..6b3550ab480f 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -3208,7 +3208,7 @@ static int add_regulator_attributes(struct regulator_dev *rdev)
 		if (status < 0)
 			return status;
 	}
-	if (ops->is_enabled) {
+	if (rdev->ena_gpio || ops->is_enabled) {
 		status = device_create_file(dev, &dev_attr_state);
 		if (status < 0)
 			return status;

commit 0384618a79ccfafd05ca1538867764f7c4b7916b
Author: Axel Lin <axel.lin@ingics.com>
Date:   Thu Jan 3 21:01:47 2013 +0800

    regulator: core: Fix comment for regulator_register()
    
    regulator_register() does not return 0 on success, fix the comment.
    
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index d7448adc7a2c..278584302f2d 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -3321,7 +3321,8 @@ static void rdev_init_debugfs(struct regulator_dev *rdev)
  * @config: runtime configuration for regulator
  *
  * Called by regulator drivers to register a regulator.
- * Returns 0 on success.
+ * Returns a valid pointer to struct regulator_dev on success
+ * or an ERR_PTR() on error.
  */
 struct regulator_dev *
 regulator_register(const struct regulator_desc *regulator_desc,

commit c8520b4c5d25eb7b8b54f1ae9ba7da71375f2b2c
Author: Axel Lin <axel.lin@ingics.com>
Date:   Tue Dec 18 09:30:10 2012 +0800

    regulator: core: Allow specify apply_[reg|bit] for regmap based voltage_sel operations
    
    Some DVM regulators needs to update apply_bit after setting vsel_reg to
    initiate voltage change on the output.  This patch adds apply_reg and
    apply_bit to struct regulator_desc and update
    regulator_set_voltage_sel_regmap() to set apply_bit of apply_reg when
    apply_bit is set.
    
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 0f65b246cc0c..571ce0f1c06e 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2074,10 +2074,20 @@ EXPORT_SYMBOL_GPL(regulator_get_voltage_sel_regmap);
  */
 int regulator_set_voltage_sel_regmap(struct regulator_dev *rdev, unsigned sel)
 {
+	int ret;
+
 	sel <<= ffs(rdev->desc->vsel_mask) - 1;
 
-	return regmap_update_bits(rdev->regmap, rdev->desc->vsel_reg,
+	ret = regmap_update_bits(rdev->regmap, rdev->desc->vsel_reg,
 				  rdev->desc->vsel_mask, sel);
+	if (ret)
+		return ret;
+
+	if (rdev->desc->apply_bit)
+		ret = regmap_update_bits(rdev->regmap, rdev->desc->apply_reg,
+					 rdev->desc->apply_bit,
+					 rdev->desc->apply_bit);
+	return ret;
 }
 EXPORT_SYMBOL_GPL(regulator_set_voltage_sel_regmap);
 

commit 19280e40714c9a3c55ab47f76df110072f6cde5e
Author: Axel Lin <axel.lin@ingics.com>
Date:   Wed Dec 12 09:22:46 2012 +0800

    regulator: core: Fix continuous_voltage_range case in regulator_can_change_voltage
    
    Regulator drivers with continuous_voltage_range flag set allows not setting
    n_voltages. Thus if continuous_voltage_range is set, check the constraint range
    instead.
    
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 0f65b246cc0c..d7448adc7a2c 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1885,9 +1885,15 @@ int regulator_can_change_voltage(struct regulator *regulator)
 	struct regulator_dev	*rdev = regulator->rdev;
 
 	if (rdev->constraints &&
-	    rdev->constraints->valid_ops_mask & REGULATOR_CHANGE_VOLTAGE &&
-	    (rdev->desc->n_voltages - rdev->desc->linear_min_sel) > 1)
-		return 1;
+	    (rdev->constraints->valid_ops_mask & REGULATOR_CHANGE_VOLTAGE)) {
+		if (rdev->desc->n_voltages - rdev->desc->linear_min_sel > 1)
+			return 1;
+
+		if (rdev->desc->continuous_voltage_range &&
+		    rdev->constraints->min_uV && rdev->constraints->max_uV &&
+		    rdev->constraints->min_uV != rdev->constraints->max_uV)
+			return 1;
+	}
 
 	return 0;
 }

commit 92d7a55879c01b30349045501108e775655a4b92
Author: Paolo Pisati <paolo.pisati@canonical.com>
Date:   Thu Dec 13 10:13:00 2012 +0100

    regulator: core: if voltage scaling fails, restore original voltage values
    
    Signed-off-by: Paolo Pisati <paolo.pisati@canonical.com>
    Tested-by: Robert Nelson <robertcnelson@gmail.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index e872c8be080e..c347fd03b727 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2250,6 +2250,7 @@ int regulator_set_voltage(struct regulator *regulator, int min_uV, int max_uV)
 {
 	struct regulator_dev *rdev = regulator->rdev;
 	int ret = 0;
+	int old_min_uV, old_max_uV;
 
 	mutex_lock(&rdev->mutex);
 
@@ -2271,18 +2272,29 @@ int regulator_set_voltage(struct regulator *regulator, int min_uV, int max_uV)
 	ret = regulator_check_voltage(rdev, &min_uV, &max_uV);
 	if (ret < 0)
 		goto out;
+	
+	/* restore original values in case of error */
+	old_min_uV = regulator->min_uV;
+	old_max_uV = regulator->max_uV;
 	regulator->min_uV = min_uV;
 	regulator->max_uV = max_uV;
 
 	ret = regulator_check_consumers(rdev, &min_uV, &max_uV);
 	if (ret < 0)
-		goto out;
+		goto out2;
 
 	ret = _regulator_do_set_voltage(rdev, min_uV, max_uV);
-
+	if (ret < 0)
+		goto out2;
+	
 out:
 	mutex_unlock(&rdev->mutex);
 	return ret;
+out2:
+	regulator->min_uV = old_min_uV;
+	regulator->max_uV = old_max_uV;
+	mutex_unlock(&rdev->mutex);
+	return ret;
 }
 EXPORT_SYMBOL_GPL(regulator_set_voltage);
 

commit f3cd19c38c3453d3af766979ccdde91eeb8b4d05
Merge: bfd9155ebbdd 8a23b4e03d68
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Dec 11 21:44:53 2012 +0900

    Merge remote-tracking branch 'regulator/topic/change' into regulator-next

commit 8a23b4e03d6873ec50f7d212de78ff01e393fc1a
Author: Axel Lin <axel.lin@ingics.com>
Date:   Tue Dec 11 20:36:37 2012 +0800

    regulator: core: Fix logic to determinate if regulator can change voltage
    
    Having a linear_min_sel setting means the first linear_min_sel selectors are
    invalid. We need to subtract linear_min_sel when use n_voltages to determinate
    if regulator can change voltage.
    
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 1c8ff8ce5c57..f3cdfe5810cc 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1881,7 +1881,7 @@ int regulator_can_change_voltage(struct regulator *regulator)
 
 	if (rdev->constraints &&
 	    rdev->constraints->valid_ops_mask & REGULATOR_CHANGE_VOLTAGE &&
-	    rdev->desc->n_voltages > 1)
+	    (rdev->desc->n_voltages - rdev->desc->linear_min_sel) > 1)
 		return 1;
 
 	return 0;

commit b17fc86cc5e8fbfd1d18765f6463d1989c59f9c6
Merge: d1e7de3007c6 e1b0144f9997
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Dec 11 21:44:17 2012 +0900

    Merge branch 'topic/min' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/regulator into regulator-change

commit adca48f7c61c53708a1f1ed567e0447ccb2b3b96
Merge: 9e218670737e e1b0144f9997
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Dec 10 12:43:00 2012 +0900

    Merge remote-tracking branch 'regulator/topic/min' into regulator-next

commit bdb7e45507893f4c509c539d442ed4962ac6fa0f
Merge: 1f9cc5f7716d fff15bef48e8
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Dec 10 12:42:56 2012 +0900

    Merge remote-tracking branch 'regulator/topic/log' into regulator-next

commit 1f9cc5f7716d664bfe32289ca61327be01a0a8e3
Merge: 207f30894a84 8dc995f56ef7
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Dec 10 12:42:55 2012 +0900

    Merge remote-tracking branch 'regulator/topic/hotplug' into regulator-next

commit d1e7de3007c6e34c5e6d5e1b707b5aba4a1cd57f
Author: Marek Szyprowski <m.szyprowski@samsung.com>
Date:   Tue Dec 4 15:01:01 2012 +0100

    regulators: add regulator_can_change_voltage() function
    
    Introduce a regulator_can_change_voltage() function for the subsytems or
    drivers which might check if applying voltage change is possible and use
    special workaround code when the driver is used with fixed regulators or
    regulators with disabled ability to change the voltage.
    
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index e872c8be080e..59e08633372a 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1866,6 +1866,28 @@ int regulator_is_enabled(struct regulator *regulator)
 }
 EXPORT_SYMBOL_GPL(regulator_is_enabled);
 
+/**
+ * regulator_can_change_voltage - check if regulator can change voltage
+ * @regulator: regulator source
+ *
+ * Returns positive if the regulator driver backing the source/client
+ * can change its voltage, false otherwise. Usefull for detecting fixed
+ * or dummy regulators and disabling voltage change logic in the client
+ * driver.
+ */
+int regulator_can_change_voltage(struct regulator *regulator)
+{
+	struct regulator_dev	*rdev = regulator->rdev;
+
+	if (rdev->constraints &&
+	    rdev->constraints->valid_ops_mask & REGULATOR_CHANGE_VOLTAGE &&
+	    rdev->desc->n_voltages > 1)
+		return 1;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(regulator_can_change_voltage);
+
 /**
  * regulator_count_voltages - count regulator_list_voltage() selectors
  * @regulator: regulator source

commit fff15bef48e846d2670c86c95f8dbc3f84bbe866
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Nov 27 18:48:56 2012 +0000

    regulator: core: Say what unsupportable voltage constraints are
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index e7fffd15953f..7fbbd8250ed9 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -883,7 +883,9 @@ static int machine_constraints_voltage(struct regulator_dev *rdev,
 
 		/* final: [min_uV..max_uV] valid iff constraints valid */
 		if (max_uV < min_uV) {
-			rdev_err(rdev, "unsupportable voltage constraints\n");
+			rdev_err(rdev,
+				 "unsupportable voltage constraints %u-%uuV\n",
+				 min_uV, max_uV);
 			return -EINVAL;
 		}
 

commit dd8004af2b0e903b2ee9fce305cb615245fa12ee
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Nov 28 17:09:27 2012 +0000

    regulator: core: Log when a device causes a voltage constraint fail
    
    Helps with figuring out when things went wrong.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index e872c8be080e..e7fffd15953f 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -199,8 +199,11 @@ static int regulator_check_consumers(struct regulator_dev *rdev,
 			*min_uV = regulator->min_uV;
 	}
 
-	if (*min_uV > *max_uV)
+	if (*min_uV > *max_uV) {
+		dev_err(regulator->dev, "Restricting voltage, %u-%uuV\n",
+			regulator->min_uV, regulator->max_uV);
 		return -EINVAL;
+	}
 
 	return 0;
 }

commit 33234e791de2ac3ea915158e042907748191cabd
Author: Axel Lin <axel.lin@ingics.com>
Date:   Tue Nov 27 10:24:33 2012 +0800

    regulator: core: Allow specific minimal selector for starting linear mapping
    
    Some drivers (at least 3 drivers) have such variant of linear mapping that
    the first few selectors are invalid and the reset are linear mapping.
    Let's support this case in core.
    
    This patch adds linear_min_sel in struct regulator_desc,
    so we can allow specific minimal selector for starting linear mapping.
    Then extends regulator_[map|list]_voltage_linear() to support this feature.
    
    Note that for selectors less than min_linear_index, we need count them to
    n_voltages so regulator_list_voltage() won't fail while checking the boundary
    for selector before calling list_voltage callback.
    
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index e872c8be080e..02a249b024b3 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1897,6 +1897,10 @@ int regulator_list_voltage_linear(struct regulator_dev *rdev,
 {
 	if (selector >= rdev->desc->n_voltages)
 		return -EINVAL;
+	if (selector < rdev->desc->linear_min_sel)
+		return 0;
+
+	selector -= rdev->desc->linear_min_sel;
 
 	return rdev->desc->min_uV + (rdev->desc->uV_step * selector);
 }
@@ -2120,6 +2124,8 @@ int regulator_map_voltage_linear(struct regulator_dev *rdev,
 	if (ret < 0)
 		return ret;
 
+	ret += rdev->desc->linear_min_sel;
+
 	/* Map back into a voltage to verify we're still in bounds */
 	voltage = rdev->desc->ops->list_voltage(rdev, ret);
 	if (voltage < min_uV || voltage > max_uV)

commit f86221d2b9ce943753bbc2d2f79d12e9af1c4790
Merge: f4a75d2eb7b1 7bde76726fa2 b92f787d1479 9f4e45f77e8a 560615ef8b95 216f2b9c95ac f329b1755b47
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Nov 20 10:30:22 2012 +0900

    Merge branches 'topic/tps51632', 'topic/tps80031', 'topic/vexpress', 'topic/max8925', 'topic/gpio' and 'topic/tps65090' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/regulator into regulator-hotplug

commit ecb48c337b1814aefa9f8b33f4ee93d0ab955902
Merge: b2da55d9441c 23ff2f0f6128 f0f98b19e23d
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Thu Nov 15 11:16:02 2012 +0900

    Merge remote-tracking branches 'regulator/fix/gpio', 'regulator/fix/put' and 'regulator/fix/supp-volt' into tmp

commit f0f98b19e23d4426ca185e3d4ca80e6aff5ef51b
Author: Marek Szyprowski <m.szyprowski@samsung.com>
Date:   Tue Nov 13 09:48:51 2012 +0100

    regulator: fix voltage check in regulator_is_supported_voltage()
    
    regulator_is_supported_voltage() should return true only if the voltage
    of fixed/constant regulator is between min_uV and max_uV.
    
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 5c4829cba6a6..27eb9d66f06a 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1974,7 +1974,7 @@ int regulator_is_supported_voltage(struct regulator *regulator,
 	if (!(rdev->constraints->valid_ops_mask & REGULATOR_CHANGE_VOLTAGE)) {
 		ret = regulator_get_voltage(regulator);
 		if (ret >= 0)
-			return (min_uV >= ret && ret <= max_uV);
+			return (min_uV <= ret && ret <= max_uV);
 		else
 			return ret;
 	}

commit 23ff2f0f6128b4c310fbb274dbb91cc2f9b6ab06
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Wed Nov 14 09:39:31 2012 +0000

    regulator: core: Avoid deadlock when regulator_register fails
    
    When regulator_register fails and exits through the scrub path the
    regulator_put function was called whilst holding the
    regulator_list_mutex, causing deadlock.
    
    This patch adds a private version of the regulator_put function which
    can be safely called whilst holding the mutex, replacing the
    aforementioned call.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 5c4829cba6a6..3ebc06b280ab 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1381,22 +1381,14 @@ struct regulator *regulator_get_exclusive(struct device *dev, const char *id)
 }
 EXPORT_SYMBOL_GPL(regulator_get_exclusive);
 
-/**
- * regulator_put - "free" the regulator source
- * @regulator: regulator source
- *
- * Note: drivers must ensure that all regulator_enable calls made on this
- * regulator source are balanced by regulator_disable calls prior to calling
- * this function.
- */
-void regulator_put(struct regulator *regulator)
+/* Locks held by regulator_put() */
+static void _regulator_put(struct regulator *regulator)
 {
 	struct regulator_dev *rdev;
 
 	if (regulator == NULL || IS_ERR(regulator))
 		return;
 
-	mutex_lock(&regulator_list_mutex);
 	rdev = regulator->rdev;
 
 	debugfs_remove_recursive(regulator->debugfs);
@@ -1412,6 +1404,20 @@ void regulator_put(struct regulator *regulator)
 	rdev->exclusive = 0;
 
 	module_put(rdev->owner);
+}
+
+/**
+ * regulator_put - "free" the regulator source
+ * @regulator: regulator source
+ *
+ * Note: drivers must ensure that all regulator_enable calls made on this
+ * regulator source are balanced by regulator_disable calls prior to calling
+ * this function.
+ */
+void regulator_put(struct regulator *regulator)
+{
+	mutex_lock(&regulator_list_mutex);
+	_regulator_put(regulator);
 	mutex_unlock(&regulator_list_mutex);
 }
 EXPORT_SYMBOL_GPL(regulator_put);
@@ -3445,7 +3451,7 @@ regulator_register(const struct regulator_desc *regulator_desc,
 
 scrub:
 	if (rdev->supply)
-		regulator_put(rdev->supply);
+		_regulator_put(rdev->supply);
 	if (rdev->ena_gpio)
 		gpio_free(rdev->ena_gpio);
 	kfree(rdev->constraints);

commit b2da55d9441cbdaf73c12403ed801b644d5ae5e3
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Sun Oct 28 16:01:11 2012 +0100

    Regulator: core: Unregister when gpio request fails.
    
    If the gpio_request_one() fails, or returns EPROBE_DEFER, the
    regulator must be device_unregister()ed. When this is not done,
    there are WARNING: from sysfs:
    
    WARNING: at fs/sysfs/file.c:343 sysfs_open_file+0x238/0x268()
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 5c4829cba6a6..aa4d28b5984e 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -3365,7 +3365,7 @@ regulator_register(const struct regulator_desc *regulator_desc,
 		if (ret != 0) {
 			rdev_err(rdev, "Failed to request enable GPIO%d: %d\n",
 				 config->ena_gpio, ret);
-			goto clean;
+			goto wash;
 		}
 
 		rdev->ena_gpio = config->ena_gpio;
@@ -3449,6 +3449,7 @@ regulator_register(const struct regulator_desc *regulator_desc,
 	if (rdev->ena_gpio)
 		gpio_free(rdev->ena_gpio);
 	kfree(rdev->constraints);
+wash:
 	device_unregister(&rdev->dev);
 	/* device core frees rdev */
 	rdev = ERR_PTR(ret);

commit bd7a2b600ace90c8819495b639a744c8f5c68feb
Author: Pawel Moll <pawel.moll@arm.com>
Date:   Mon Sep 24 18:56:53 2012 +0100

    regulator: core: Support for continuous voltage range
    
    Some regulators can set any voltage within the constraints range,
    not being limited to specified operating points.
    
    This patch makes it possible to describe such regulator and makes
    the regulator_is_supported_voltage() function behave correctly.
    
    Signed-off-by: Pawel Moll <pawel.moll@arm.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 5c4829cba6a6..f7c74db7465c 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1979,6 +1979,11 @@ int regulator_is_supported_voltage(struct regulator *regulator,
 			return ret;
 	}
 
+	/* Any voltage within constrains range is fine? */
+	if (rdev->desc->continuous_voltage_range)
+		return min_uV >= rdev->constraints->min_uV &&
+				max_uV <= rdev->constraints->max_uV;
+
 	ret = regulator_count_voltages(regulator);
 	if (ret < 0)
 		return ret;

commit 033d9959ed2dc1029217d4165f80a71702dc578e
Merge: 974a847e00cf 7c6e72e46c9e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Oct 2 09:54:49 2012 -0700

    Merge branch 'for-3.7' of git://git.kernel.org/pub/scm/linux/kernel/git/tj/wq
    
    Pull workqueue changes from Tejun Heo:
     "This is workqueue updates for v3.7-rc1.  A lot of activities this
      round including considerable API and behavior cleanups.
    
       * delayed_work combines a timer and a work item.  The handling of the
         timer part has always been a bit clunky leading to confusing
         cancelation API with weird corner-case behaviors.  delayed_work is
         updated to use new IRQ safe timer and cancelation now works as
         expected.
    
       * Another deficiency of delayed_work was lack of the counterpart of
         mod_timer() which led to cancel+queue combinations or open-coded
         timer+work usages.  mod_delayed_work[_on]() are added.
    
         These two delayed_work changes make delayed_work provide interface
         and behave like timer which is executed with process context.
    
       * A work item could be executed concurrently on multiple CPUs, which
         is rather unintuitive and made flush_work() behavior confusing and
         half-broken under certain circumstances.  This problem doesn't
         exist for non-reentrant workqueues.  While non-reentrancy check
         isn't free, the overhead is incurred only when a work item bounces
         across different CPUs and even in simulated pathological scenario
         the overhead isn't too high.
    
         All workqueues are made non-reentrant.  This removes the
         distinction between flush_[delayed_]work() and
         flush_[delayed_]_work_sync().  The former is now as strong as the
         latter and the specified work item is guaranteed to have finished
         execution of any previous queueing on return.
    
       * In addition to the various bug fixes, Lai redid and simplified CPU
         hotplug handling significantly.
    
       * Joonsoo introduced system_highpri_wq and used it during CPU
         hotplug.
    
      There are two merge commits - one to pull in IRQ safe timer from
      tip/timers/core and the other to pull in CPU hotplug fixes from
      wq/for-3.6-fixes as Lai's hotplug restructuring depended on them."
    
    Fixed a number of trivial conflicts, but the more interesting conflicts
    were silent ones where the deprecated interfaces had been used by new
    code in the merge window, and thus didn't cause any real data conflicts.
    
    Tejun pointed out a few of them, I fixed a couple more.
    
    * 'for-3.7' of git://git.kernel.org/pub/scm/linux/kernel/git/tj/wq: (46 commits)
      workqueue: remove spurious WARN_ON_ONCE(in_irq()) from try_to_grab_pending()
      workqueue: use cwq_set_max_active() helper for workqueue_set_max_active()
      workqueue: introduce cwq_set_max_active() helper for thaw_workqueues()
      workqueue: remove @delayed from cwq_dec_nr_in_flight()
      workqueue: fix possible stall on try_to_grab_pending() of a delayed work item
      workqueue: use hotcpu_notifier() for workqueue_cpu_down_callback()
      workqueue: use __cpuinit instead of __devinit for cpu callbacks
      workqueue: rename manager_mutex to assoc_mutex
      workqueue: WORKER_REBIND is no longer necessary for idle rebinding
      workqueue: WORKER_REBIND is no longer necessary for busy rebinding
      workqueue: reimplement idle worker rebinding
      workqueue: deprecate __cancel_delayed_work()
      workqueue: reimplement cancel_delayed_work() using try_to_grab_pending()
      workqueue: use mod_delayed_work() instead of __cancel + queue
      workqueue: use irqsafe timer for delayed_work
      workqueue: clean up delayed_work initializers and add missing one
      workqueue: make deferrable delayed_work initializer names consistent
      workqueue: cosmetic whitespace updates for macro definitions
      workqueue: deprecate system_nrt[_freezable]_wq
      workqueue: deprecate flush[_delayed]_work_sync()
      ...

commit 6a2027abd2048f7f7fdcc6e11ff10b3d9b0d0899
Merge: 5698bd757d55 52b84dac436a b8575a1143f6 3f1965776f6e e96961dabe44 3006b8d665c9
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Fri Sep 28 14:45:07 2012 +0100

    Merge remote-tracking branches 'regulator/topic/core', 'regulator/topic/bypass', 'regulator/topic/tol', 'regulator/topic/drivers' and 'regulator/topic/tps6586x' into regulator-next

commit df36793115b4f68181877a1c89bac54feadd965d
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Aug 27 16:04:23 2012 -0700

    regulator: core: Provide regmap get/set bypass operations
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 64e16053975e..419805cdd9d7 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2698,6 +2698,47 @@ int regulator_set_optimum_mode(struct regulator *regulator, int uA_load)
 }
 EXPORT_SYMBOL_GPL(regulator_set_optimum_mode);
 
+/**
+ * regulator_set_bypass_regmap - Default set_bypass() using regmap
+ *
+ * @rdev: device to operate on.
+ * @enable: state to set.
+ */
+int regulator_set_bypass_regmap(struct regulator_dev *rdev, bool enable)
+{
+	unsigned int val;
+
+	if (enable)
+		val = rdev->desc->bypass_mask;
+	else
+		val = 0;
+
+	return regmap_update_bits(rdev->regmap, rdev->desc->bypass_reg,
+				  rdev->desc->bypass_mask, val);
+}
+EXPORT_SYMBOL_GPL(regulator_set_bypass_regmap);
+
+/**
+ * regulator_get_bypass_regmap - Default get_bypass() using regmap
+ *
+ * @rdev: device to operate on.
+ * @enable: current state.
+ */
+int regulator_get_bypass_regmap(struct regulator_dev *rdev, bool *enable)
+{
+	unsigned int val;
+	int ret;
+
+	ret = regmap_read(rdev->regmap, rdev->desc->bypass_reg, &val);
+	if (ret != 0)
+		return ret;
+
+	*enable = val & rdev->desc->bypass_mask;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(regulator_get_bypass_regmap);
+
 /**
  * regulator_allow_bypass - allow the regulator to go into bypass mode
  *

commit f59c8f9fe689790248ae7aa7426579982050638c
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Fri Aug 31 10:36:37 2012 -0700

    regulator: core: Support bypass mode
    
    Many regulators support a bypass mode where they simply switch their
    input supply to the output. This is mainly used in low power retention
    states where power consumption is extremely low so higher voltage or
    less clean supplies can be used.
    
    Support this by providing ops for the drivers and a consumer API which
    allows the device to be put into bypass mode if all consumers enable it
    and the machine enables permission for this.
    
    This is not supported as a mode since the existing modes are rarely used
    due to fuzzy definition and mostly redundant with modern hardware which is
    able to respond promptly to load changes.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Reviewed-by: Graeme Gregory <gg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 48385318175a..64e16053975e 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -77,6 +77,7 @@ struct regulator {
 	struct device *dev;
 	struct list_head list;
 	unsigned int always_on:1;
+	unsigned int bypass:1;
 	int uA_load;
 	int min_uV;
 	int max_uV;
@@ -394,6 +395,9 @@ static ssize_t regulator_status_show(struct device *dev,
 	case REGULATOR_STATUS_STANDBY:
 		label = "standby";
 		break;
+	case REGULATOR_STATUS_BYPASS:
+		label = "bypass";
+		break;
 	case REGULATOR_STATUS_UNDEFINED:
 		label = "undefined";
 		break;
@@ -585,6 +589,27 @@ static ssize_t regulator_suspend_standby_state_show(struct device *dev,
 static DEVICE_ATTR(suspend_standby_state, 0444,
 		regulator_suspend_standby_state_show, NULL);
 
+static ssize_t regulator_bypass_show(struct device *dev,
+				     struct device_attribute *attr, char *buf)
+{
+	struct regulator_dev *rdev = dev_get_drvdata(dev);
+	const char *report;
+	bool bypass;
+	int ret;
+
+	ret = rdev->desc->ops->get_bypass(rdev, &bypass);
+
+	if (ret != 0)
+		report = "unknown";
+	else if (bypass)
+		report = "enabled";
+	else
+		report = "disabled";
+
+	return sprintf(buf, "%s\n", report);
+}
+static DEVICE_ATTR(bypass, 0444,
+		   regulator_bypass_show, NULL);
 
 /*
  * These are the only attributes are present for all regulators.
@@ -2673,6 +2698,59 @@ int regulator_set_optimum_mode(struct regulator *regulator, int uA_load)
 }
 EXPORT_SYMBOL_GPL(regulator_set_optimum_mode);
 
+/**
+ * regulator_allow_bypass - allow the regulator to go into bypass mode
+ *
+ * @regulator: Regulator to configure
+ * @allow: enable or disable bypass mode
+ *
+ * Allow the regulator to go into bypass mode if all other consumers
+ * for the regulator also enable bypass mode and the machine
+ * constraints allow this.  Bypass mode means that the regulator is
+ * simply passing the input directly to the output with no regulation.
+ */
+int regulator_allow_bypass(struct regulator *regulator, bool enable)
+{
+	struct regulator_dev *rdev = regulator->rdev;
+	int ret = 0;
+
+	if (!rdev->desc->ops->set_bypass)
+		return 0;
+
+	if (rdev->constraints &&
+	    !(rdev->constraints->valid_ops_mask & REGULATOR_CHANGE_BYPASS))
+		return 0;
+
+	mutex_lock(&rdev->mutex);
+
+	if (enable && !regulator->bypass) {
+		rdev->bypass_count++;
+
+		if (rdev->bypass_count == rdev->open_count) {
+			ret = rdev->desc->ops->set_bypass(rdev, enable);
+			if (ret != 0)
+				rdev->bypass_count--;
+		}
+
+	} else if (!enable && regulator->bypass) {
+		rdev->bypass_count--;
+
+		if (rdev->bypass_count != rdev->open_count) {
+			ret = rdev->desc->ops->set_bypass(rdev, enable);
+			if (ret != 0)
+				rdev->bypass_count++;
+		}
+	}
+
+	if (ret == 0)
+		regulator->bypass = enable;
+
+	mutex_unlock(&rdev->mutex);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(regulator_allow_bypass);
+
 /**
  * regulator_register_notifier - register regulator event notifier
  * @regulator: regulator source
@@ -3036,6 +3114,11 @@ static int add_regulator_attributes(struct regulator_dev *rdev)
 		if (status < 0)
 			return status;
 	}
+	if (ops->get_bypass) {
+		status = device_create_file(dev, &dev_attr_bypass);
+		if (status < 0)
+			return status;
+	}
 
 	/* some attributes are type-specific */
 	if (rdev->desc->type == REGULATOR_CURRENT) {
@@ -3124,6 +3207,8 @@ static void rdev_init_debugfs(struct regulator_dev *rdev)
 			   &rdev->use_count);
 	debugfs_create_u32("open_count", 0444, rdev->debugfs,
 			   &rdev->open_count);
+	debugfs_create_u32("bypass_count", 0444, rdev->debugfs,
+			   &rdev->bypass_count);
 }
 
 /**

commit 52b84dac436a681fa51dad2b9e57b6ea50309cbd
Author: AnilKumar Ch <anilkumar@ti.com>
Date:   Fri Sep 7 20:45:05 2012 +0530

    regulator: core: Try using the parent device for the default regmap
    
    If the device doesn't have a regmap specified by the driver and we can't
    find one on the device itself try its parent, providing a useful defualt
    for many MFDs.
    
    [Rewrite commit message -- broonie]
    
    Signed-off-by: AnilKumar Ch <anilkumar@ti.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index ed376d9f525d..03fad8153476 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -3202,8 +3202,10 @@ regulator_register(const struct regulator_desc *regulator_desc,
 	rdev->desc = regulator_desc;
 	if (config->regmap)
 		rdev->regmap = config->regmap;
-	else
+	else if (dev_get_regmap(dev, NULL))
 		rdev->regmap = dev_get_regmap(dev, NULL);
+	else if (dev->parent)
+		rdev->regmap = dev_get_regmap(dev->parent, NULL);
 	INIT_LIST_HEAD(&rdev->consumer_list);
 	INIT_LIST_HEAD(&rdev->list);
 	BLOCKING_INIT_NOTIFIER_HEAD(&rdev->notifier);

commit 2b5a24a01df12fbfa3e702ad7efae27bcb852e33
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Fri Sep 7 11:00:53 2012 +0800

    regulator: core: Fast path non-deferred disables
    
    Users (especially framework code) may end up passing in a zero deferral
    time depending on runtime conditions or configuration. If they do then
    just call regulator_disable() directly to save scheduling.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@ti.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 50977a69f09a..ed376d9f525d 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1724,6 +1724,9 @@ int regulator_disable_deferred(struct regulator *regulator, int ms)
 	if (regulator->always_on)
 		return 0;
 
+	if (!ms)
+		return regulator_disable(regulator);
+
 	mutex_lock(&rdev->mutex);
 	rdev->deferred_disables++;
 	mutex_unlock(&rdev->mutex);

commit f2889e650a8dbd51644997aef7bae71d6ac4d423
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Aug 27 11:37:04 2012 -0700

    regulator: core: Report microvolts in sysfs even with only list_voltage()
    
    If a regulator only supports a single voltage list_voltage() can be used
    to report what that voltage is so add this as one of the criteria for
    creating the microvolts file in sysfs.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 2a3e4213865b..50977a69f09a 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -3020,7 +3020,8 @@ static int add_regulator_attributes(struct regulator_dev *rdev)
 
 	/* some attributes need specific methods to be displayed */
 	if ((ops->get_voltage && ops->get_voltage(rdev) >= 0) ||
-	    (ops->get_voltage_sel && ops->get_voltage_sel(rdev) >= 0)) {
+	    (ops->get_voltage_sel && ops->get_voltage_sel(rdev) >= 0) ||
+	    (ops->list_voltage && ops->list_voltage(rdev, 0) >= 0)) {
 		status = device_create_file(dev, &dev_attr_microvolts);
 		if (status < 0)
 			return status;

commit dedae957a41b4f4523199f7a822ee4e5735640b0
Author: Randy Dunlap <rdunlap@xenotime.net>
Date:   Sat Aug 18 17:44:14 2012 -0700

    regulator: fix kernel-doc warnings in drivers/regulator/core.c
    
    Fix regulator kernel-doc warnings:
    
    Warning(drivers/regulator/core.c:2308): No description found for parameter 'rdev'
    Warning(drivers/regulator/core.c:2308): Excess function parameter 'regulator' description in 'regulator_set_voltage_time_sel'
    
    Signed-off-by: Randy Dunlap <rdunlap@xenotime.net>
    Cc:     Liam Girdwood <lrg@ti.com>
    Cc:     Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 48385318175a..d49d86d2d479 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2291,8 +2291,8 @@ int regulator_set_voltage_time(struct regulator *regulator,
 EXPORT_SYMBOL_GPL(regulator_set_voltage_time);
 
 /**
- *regulator_set_voltage_time_sel - get raise/fall time
- * @regulator: regulator source
+ * regulator_set_voltage_time_sel - get raise/fall time
+ * @rdev: regulator source device
  * @old_selector: selector for starting voltage
  * @new_selector: selector for target voltage
  *

commit 43829731dd372d04d6706c51052b9dabab9ca356
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Aug 20 14:51:24 2012 -0700

    workqueue: deprecate flush[_delayed]_work_sync()
    
    flush[_delayed]_work_sync() are now spurious.  Mark them deprecated
    and convert all users to flush[_delayed]_work().
    
    If you're cc'd and wondering what's going on: Now all workqueues are
    non-reentrant and the regular flushes guarantee that the work item is
    not pending or running on any CPU on return, so there's no reason to
    use the sync flushes at all and they're going away.
    
    This patch doesn't make any functional difference.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Cc: Ian Campbell <ian.campbell@citrix.com>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Mattia Dongili <malattia@linux.it>
    Cc: Kent Yoder <key@linux.vnet.ibm.com>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Jiri Kosina <jkosina@suse.cz>
    Cc: Karsten Keil <isdn@linux-pingi.de>
    Cc: Bryan Wu <bryan.wu@canonical.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Alasdair Kergon <agk@redhat.com>
    Cc: Mauro Carvalho Chehab <mchehab@infradead.org>
    Cc: Florian Tobias Schandinat <FlorianSchandinat@gmx.de>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: linux-wireless@vger.kernel.org
    Cc: Anton Vorontsov <cbou@mail.ru>
    Cc: Sangbeom Kim <sbkim73@samsung.com>
    Cc: "James E.J. Bottomley" <James.Bottomley@HansenPartnership.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Eric Van Hensbergen <ericvh@gmail.com>
    Cc: Takashi Iwai <tiwai@suse.de>
    Cc: Steven Whitehouse <swhiteho@redhat.com>
    Cc: Petr Vandrovec <petr@vandrovec.name>
    Cc: Mark Fasheh <mfasheh@suse.com>
    Cc: Christoph Hellwig <hch@infradead.org>
    Cc: Avi Kivity <avi@redhat.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index f092588a078c..1d2b70017a8d 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -3335,7 +3335,7 @@ void regulator_unregister(struct regulator_dev *rdev)
 		regulator_put(rdev->supply);
 	mutex_lock(&regulator_list_mutex);
 	debugfs_remove_recursive(rdev->debugfs);
-	flush_work_sync(&rdev->disable_work.work);
+	flush_work(&rdev->disable_work.work);
 	WARN_ON(rdev->open_count);
 	unset_regulator_supplies(rdev);
 	list_del(&rdev->list);

commit 296c656616bd567b2849f5a8a444452c4849ac01
Author: Randy Dunlap <rdunlap@xenotime.net>
Date:   Sat Aug 18 17:44:14 2012 -0700

    regulator: fix kernel-doc warnings in drivers/regulator/core.c
    
    Fix regulator kernel-doc warnings:
    
    Warning(drivers/regulator/core.c:2308): No description found for parameter 'rdev'
    Warning(drivers/regulator/core.c:2308): Excess function parameter 'regulator' description in 'regulator_set_voltage_time_sel'
    
    Signed-off-by: Randy Dunlap <rdunlap@xenotime.net>
    Cc:     Liam Girdwood <lrg@ti.com>
    Cc:     Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index ff8f54447305..2a3e4213865b 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2298,8 +2298,8 @@ int regulator_set_voltage_time(struct regulator *regulator,
 EXPORT_SYMBOL_GPL(regulator_set_voltage_time);
 
 /**
- *regulator_set_voltage_time_sel - get raise/fall time
- * @regulator: regulator source
+ * regulator_set_voltage_time_sel - get raise/fall time
+ * @rdev: regulator source device
  * @old_selector: selector for starting voltage
  * @new_selector: selector for target voltage
  *

commit b2a1ef473b031b630a26685c91a46b9ae668d35c
Author: Marek Szyprowski <m.szyprowski@samsung.com>
Date:   Thu Aug 9 16:33:00 2012 +0200

    regulator: core: request only valid gpio pins for regulator enable
    
    Commit 65f735082de3 ("regulator: core: Add core support for GPIO controlled
    enable lines") introduced enable gpio entry in regulator configuration
    structure. Some drivers use '-1' as a placeholder for marking that such
    gpio line is not available, because '0' is considered as a valid gpio
    number. This patch fixes initialization of such drivers (like MAX8952
    on UniversalC210 board), when '-1' is provided as enable gpio pin in the
    regulator's platform data.
    
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index f092588a078c..48385318175a 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -3217,7 +3217,7 @@ regulator_register(const struct regulator_desc *regulator_desc,
 
 	dev_set_drvdata(&rdev->dev, rdev);
 
-	if (config->ena_gpio) {
+	if (config->ena_gpio && gpio_is_valid(config->ena_gpio)) {
 		ret = gpio_request_one(config->ena_gpio,
 				       GPIOF_DIR_OUT | config->ena_gpio_flags,
 				       rdev_get_name(rdev));

commit f7df20ec323009bd2ea8e1c65f11bb43fd526c4f
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Thu Aug 9 16:42:19 2012 +0100

    regulator: core: Use list_voltage() to read single voltage regulators
    
    If the regulator doesn't supply a way of reading back the voltage but does
    provide a list_voltage() operation then use that with a selector of zero
    to read the voltage.  Regulators doing this means that we have the list
    operation there for consumers that want to configure themselves.
    
    Reported-by: Stephen Warren <swarren@wwwdotorg.org>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 157def15ed78..ff8f54447305 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2395,6 +2395,8 @@ static int _regulator_get_voltage(struct regulator_dev *rdev)
 		ret = rdev->desc->ops->list_voltage(rdev, sel);
 	} else if (rdev->desc->ops->get_voltage) {
 		ret = rdev->desc->ops->get_voltage(rdev);
+	} else if (rdev->desc->ops->list_voltage) {
+		ret = rdev->desc->ops->list_voltage(rdev, 0);
 	} else {
 		return -EINVAL;
 	}

commit 215b8b055de7dad26ab6c10f70130934309cb696
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Tue Aug 7 21:01:37 2012 +0200

    regulator: make the dummy regulator's print_constraint more helpful
    
    This prevents the output of just
    
            dummy:
    
    in the boot log. Now it says:
    
            regulator-dummy: no parameters
    
    which at least doesn't make it look like an accidental printk and also doesn't
    only use "dummy" which could mean anything.
    
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 5f2221095a46..157def15ed78 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -778,6 +778,9 @@ static void print_constraints(struct regulator_dev *rdev)
 	if (constraints->valid_modes_mask & REGULATOR_MODE_STANDBY)
 		count += sprintf(buf + count, "standby");
 
+	if (!count)
+		sprintf(buf, "no parameters");
+
 	rdev_info(rdev, "%s\n", buf);
 
 	if ((constraints->min_uV != constraints->max_uV) &&

commit 2f6c797f84fd764efb5eeb7cbb6a80a7244bd13c
Author: Axel Lin <axel.lin@gmail.com>
Date:   Mon Aug 6 23:44:19 2012 +0800

    regulator: core: Fix cast to pointer from integer of different size warning
    
    This is to address the following warning during compilation time: (Compile on x86_64)
    
      CC      drivers/regulator/core.o
    drivers/regulator/core.c: In function '_regulator_do_set_voltage':
    drivers/regulator/core.c:2183:10: warning: cast to pointer from integer of different size [-Wint-to-pointer-cast]
    
    This patch adds a temporary variable to avoid double cast.
    
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index b28221af648e..5f2221095a46 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2179,9 +2179,12 @@ static int _regulator_do_set_voltage(struct regulator_dev *rdev,
 		}
 	}
 
-	if (ret == 0 && best_val >= 0)
+	if (ret == 0 && best_val >= 0) {
+		unsigned long data = best_val;
+
 		_notifier_call_chain(rdev, REGULATOR_EVENT_VOLTAGE_CHANGE,
-				     (void *)best_val);
+				     (void *)data);
+	}
 
 	trace_regulator_set_voltage_complete(rdev_get_name(rdev), best_val);
 

commit 57ad526ae2c28d128fe0d9deeb428697151c849b
Author: Laxman Dewangan <ldewangan@nvidia.com>
Date:   Mon Jul 23 20:35:46 2012 +0530

    regulator: core: increment open_count when regulator supply is set
    
    When registering the regulator and setting supply for the regulator
    then increment open_count to reflect correct number of users.
    
    Signed-off-by: Laxman Dewangan <ldewangan@nvidia.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index f092588a078c..b28221af648e 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -974,6 +974,7 @@ static int set_supply(struct regulator_dev *rdev,
 		err = -ENOMEM;
 		return err;
 	}
+	supply_rdev->open_count++;
 
 	return 0;
 }

commit bdc0077af574800d24318b6945cf2344e8dbb050
Merge: 801b03653fc0 e96eb23d82b4
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jul 24 18:11:22 2012 -0700

    Merge tag 'scsi-misc' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi
    
    Pull first round of SCSI updates from James Bottomley:
     "The most important feature of this patch set is the new async
      infrastructure that makes sure async_synchronize_full() synchronizes
      all domains and allows us to remove all the hacks (like having
      scsi_complete_async_scans() in the device base code) and means that
      the async infrastructure will "just work" in future.
    
      The rest is assorted driver updates (aacraid, bnx2fc, virto-scsi,
      megaraid, bfa, lpfc, qla2xxx, qla4xxx) plus a lot of infrastructure
      work in sas and FC.
    
      Signed-off-by: James Bottomley <JBottomley@Parallels.com>"
    
    * tag 'scsi-misc' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi: (97 commits)
      [SCSI] Revert "[SCSI] fix async probe regression"
      [SCSI] cleanup usages of scsi_complete_async_scans
      [SCSI] queue async scan work to an async_schedule domain
      [SCSI] async: make async_synchronize_full() flush all work regardless of domain
      [SCSI] async: introduce 'async_domain' type
      [SCSI] bfa: Fix to set correct return error codes and misc cleanup.
      [SCSI] aacraid: Series 7 Async. (performance) mode support
      [SCSI] aha152x: Allow use on 64bit systems
      [SCSI] virtio-scsi: Add vdrv->scan for post VIRTIO_CONFIG_S_DRIVER_OK LUN scanning
      [SCSI] bfa: squelch lockdep complaint with a spin_lock_init
      [SCSI] qla2xxx: remove unnecessary reads of PCI_CAP_ID_EXP
      [SCSI] qla4xxx: remove unnecessary read of PCI_CAP_ID_EXP
      [SCSI] ufs: fix incorrect return value about SUCCESS and FAILED
      [SCSI] ufs: reverse the ufshcd_is_device_present logic
      [SCSI] ufs: use module_pci_driver
      [SCSI] usb-storage: update usb devices for write cache quirk in quirk list.
      [SCSI] usb-storage: add support for write cache quirk
      [SCSI] set to WCE if usb cache quirk is present.
      [SCSI] virtio-scsi: hotplug support for virtio-scsi
      [SCSI] virtio-scsi: split scatterlist per target
      ...

commit 3384fb98845dc014770caa224d61a2effd258ca5
Merge: 8cfc545e0e3e ade7515fefad
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Sun Jul 22 19:32:00 2012 +0100

    Merge branch 'regulator-drivers' into regulator-next

commit 8cfc545e0e3e6cc82acfdc79321b41eeeab0ca45
Merge: 1beaf762b4ad 86f5fcfc3e40 15719ccc2749
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Sun Jul 22 19:31:41 2012 +0100

    Merge branches 'regulator-core', 'regulator-dt' and 'regulator-dummy' into regulator-next

commit 2955b47d2c1983998a8c5915cb96884e67f7cb53
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Mon Jul 9 19:33:25 2012 -0700

    [SCSI] async: introduce 'async_domain' type
    
    This is in preparation for teaching async_synchronize_full() to sync all
    pending async work, and not just on the async_running domain.  This
    conversion is functionally equivalent, just embedding the existing list
    in a new async_domain type.
    
    The .registered attribute is used in a later patch to distinguish
    between domains that want to be flushed by async_synchronize_full()
    versus those that only expect async_synchronize_{full|cookie}_domain to
    be used for flushing.
    
    [jejb: add async.h to scsi_priv.h for struct async_domain]
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Acked-by: Arjan van de Ven <arjan@linux.intel.com>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Tested-by: Eldad Zack <eldad@fogrefinery.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 8b4b3829d9e7..6c74546fc3cd 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2744,7 +2744,7 @@ static void regulator_bulk_enable_async(void *data, async_cookie_t cookie)
 int regulator_bulk_enable(int num_consumers,
 			  struct regulator_bulk_data *consumers)
 {
-	LIST_HEAD(async_domain);
+	ASYNC_DOMAIN_EXCLUSIVE(async_domain);
 	int i;
 	int ret = 0;
 

commit d5b2e30bdc695a1735b3c970e1f9738e9ca3dbf0
Merge: 7c7fac30581b 84a1caf1453c
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Sun Jul 15 21:49:21 2012 +0100

    Merge tag 'v3.5-rc7' into regulator-drivers
    
    Linux 3.5-rc7

commit 1beaf762b4ad5f53876f790bb6cfbd3bac072985
Author: Krystian Garbaciak <krystian.garbaciak@diasemi.com>
Date:   Thu Jul 12 13:53:35 2012 +0100

    regulator: Add REGULATOR_STATUS_UNDEFINED.
    
    REGULATOR_STATUS_UNDEFINED is to be returned by regulator, if any other state
    doesn't really apply.
    
    Signed-off-by: Krystian Garbaciak <krystian.garbaciak@diasemi.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 4b136f8cb99f..01a67c50c4ea 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -393,6 +393,9 @@ static ssize_t regulator_status_show(struct device *dev,
 	case REGULATOR_STATUS_STANDBY:
 		label = "standby";
 		break;
+	case REGULATOR_STATUS_UNDEFINED:
+		label = "undefined";
+		break;
 	default:
 		return -ERANGE;
 	}
@@ -2897,7 +2900,7 @@ int regulator_mode_to_status(unsigned int mode)
 	case REGULATOR_MODE_STANDBY:
 		return REGULATOR_STATUS_STANDBY;
 	default:
-		return 0;
+		return REGULATOR_STATUS_UNDEFINED;
 	}
 }
 EXPORT_SYMBOL_GPL(regulator_mode_to_status);

commit 03ffcf3d0838bd5e693cd4520becfb22577cf34d
Author: Krystian Garbaciak <krystian.garbaciak@diasemi.com>
Date:   Thu Jul 12 11:50:38 2012 +0100

    regulator: Fix a typo in regulator_mode_to_status() core function.
    
    Case REGULATOR_STATUS_STANDBY -> REGULATOR_MODE_STANDBY.
    
    Signed-off-by: Krystian Garbaciak <krystian.garbaciak@diasemi.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 974276afd1f0..4b136f8cb99f 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2894,7 +2894,7 @@ int regulator_mode_to_status(unsigned int mode)
 		return REGULATOR_STATUS_NORMAL;
 	case REGULATOR_MODE_IDLE:
 		return REGULATOR_STATUS_IDLE;
-	case REGULATOR_STATUS_STANDBY:
+	case REGULATOR_MODE_STANDBY:
 		return REGULATOR_STATUS_STANDBY;
 	default:
 		return 0;

commit 86f5fcfc3e400b2ac1562cb0fd6aabc9f83ee3e2
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Fri Jul 6 18:19:13 2012 +0100

    regulator: core: Mark all DT based boards as having full constraints
    
    Since DT doesn't provide an idiomatic mechanism for enabling full
    constraints and since it's much more natural with DT to provide them
    just assume that a DT enabled system has full constraints.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@ti.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 09a737c868b5..4c53b39b92a6 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -3472,6 +3472,15 @@ static int __init regulator_init_complete(void)
 	struct regulation_constraints *c;
 	int enabled, ret;
 
+	/*
+	 * Since DT doesn't provide an idiomatic mechanism for
+	 * enabling full constraints and since it's much more natural
+	 * with DT to provide them just assume that a DT enabled
+	 * system has full constraints.
+	 */
+	if (of_have_populated_dt())
+		has_full_constraints = true;
+
 	mutex_lock(&regulator_list_mutex);
 
 	/* If we have a full configuration then disable any regulators

commit e2c98eaf928a2a0ecaca1db9aa5dc56a36699d9f
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Thu Jul 5 14:19:42 2012 +0800

    regulator: core: remove sysfs entry properly in regulator_put
    
    With changes introduced by commit 222cc7b (regulator: core: Allow
    multiple requests of a single supply mapping) on create_regulator,
    regulator_put needs a corresponding update on sysfs entry removing.
    
    Also regulator->dev still needs to get assigned in create_regulator,
    otherwise, sysfs_remove_link call in regulator_put will get bypassed.
    
    Reported-by: Fabio Estevam <festevam@gmail.com>
    Tested-by: Dong Aisheng <dong.aisheng@linaro.org>
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index f98a8ee29933..974276afd1f0 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1063,6 +1063,8 @@ static struct regulator *create_regulator(struct regulator_dev *rdev,
 	list_add(&regulator->list, &rdev->consumer_list);
 
 	if (dev) {
+		regulator->dev = dev;
+
 		/* Add a link to the device sysfs entry */
 		size = scnprintf(buf, REG_STR_SIZE, "%s-%s",
 				 dev->kobj.name, supply_name);
@@ -1359,11 +1361,8 @@ void regulator_put(struct regulator *regulator)
 	debugfs_remove_recursive(regulator->debugfs);
 
 	/* remove any sysfs entries */
-	if (regulator->dev) {
+	if (regulator->dev)
 		sysfs_remove_link(&rdev->dev.kobj, regulator->supply_name);
-		device_remove_file(regulator->dev, &regulator->dev_attr);
-		kfree(regulator->dev_attr.attr.name);
-	}
 	kfree(regulator->supply_name);
 	list_del(&regulator->list);
 	kfree(regulator);

commit 65f735082de35aa4d44e8d0afe862798d0e09e29
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Jun 27 14:14:38 2012 +0100

    regulator: core: Add core support for GPIO controlled enable lines
    
    It is very common for regulators to support having their enable signal
    controlled by a GPIO. Since there are a bunch of fiddly things to get
    right like handling the operations when the enable signal is tied to
    a rail and it's just replicated code add support for this to the core.
    
    Drivers should set ena_gpio in their config if they have a GPIO control,
    using ena_gpio_flags to specify any flags (including GPIOF_OUT_INIT_ for
    the initial state) and ena_gpio_invert if the GPIO is active low. The
    core will then override any enable and disable operations the driver has
    and instead control the specified GPIO.
    
    This will in the future also allow us to further extend the core by
    identifying when several enable signals have been tied together and
    handling this properly.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 82650a16a975..8d81bafcb721 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -23,6 +23,7 @@
 #include <linux/mutex.h>
 #include <linux/suspend.h>
 #include <linux/delay.h>
+#include <linux/gpio.h>
 #include <linux/of.h>
 #include <linux/regmap.h>
 #include <linux/regulator/of_regulator.h>
@@ -1491,7 +1492,11 @@ static int _regulator_do_enable(struct regulator_dev *rdev)
 
 	trace_regulator_enable(rdev_get_name(rdev));
 
-	if (rdev->desc->ops->enable) {
+	if (rdev->ena_gpio) {
+		gpio_set_value_cansleep(rdev->ena_gpio,
+					!rdev->ena_gpio_invert);
+		rdev->ena_gpio_state = 1;
+	} else if (rdev->desc->ops->enable) {
 		ret = rdev->desc->ops->enable(rdev);
 		if (ret < 0)
 			return ret;
@@ -1846,6 +1851,10 @@ EXPORT_SYMBOL_GPL(regulator_disable_regmap);
 
 static int _regulator_is_enabled(struct regulator_dev *rdev)
 {
+	/* A GPIO control always takes precedence */
+	if (rdev->ena_gpio)
+		return rdev->ena_gpio_state;
+
 	/* If we don't know then assume that the regulator is always on */
 	if (!rdev->desc->ops->is_enabled)
 		return 1;
@@ -3243,6 +3252,26 @@ regulator_register(const struct regulator_desc *regulator_desc,
 
 	dev_set_drvdata(&rdev->dev, rdev);
 
+	if (config->ena_gpio) {
+		ret = gpio_request_one(config->ena_gpio,
+				       GPIOF_DIR_OUT | config->ena_gpio_flags,
+				       rdev_get_name(rdev));
+		if (ret != 0) {
+			rdev_err(rdev, "Failed to request enable GPIO%d: %d\n",
+				 config->ena_gpio, ret);
+			goto clean;
+		}
+
+		rdev->ena_gpio = config->ena_gpio;
+		rdev->ena_gpio_invert = config->ena_gpio_invert;
+
+		if (config->ena_gpio_flags & GPIOF_OUT_INIT_HIGH)
+			rdev->ena_gpio_state = 1;
+
+		if (rdev->ena_gpio_invert)
+			rdev->ena_gpio_state = !rdev->ena_gpio_state;
+	}
+
 	/* set regulator constraints */
 	if (init_data)
 		constraints = &init_data->constraints;
@@ -3311,6 +3340,8 @@ regulator_register(const struct regulator_desc *regulator_desc,
 scrub:
 	if (rdev->supply)
 		regulator_put(rdev->supply);
+	if (rdev->ena_gpio)
+		gpio_free(rdev->ena_gpio);
 	kfree(rdev->constraints);
 	device_unregister(&rdev->dev);
 	/* device core frees rdev */
@@ -3344,6 +3375,8 @@ void regulator_unregister(struct regulator_dev *rdev)
 	unset_regulator_supplies(rdev);
 	list_del(&rdev->list);
 	kfree(rdev->constraints);
+	if (rdev->ena_gpio)
+		gpio_free(rdev->ena_gpio);
 	device_unregister(&rdev->dev);
 	mutex_unlock(&regulator_list_mutex);
 }

commit 5c5659d0a22ec4f947ef4faa3055767572f15e74
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Jun 27 13:21:26 2012 +0100

    regulator: core: Factor out enable and disable operations some more
    
    Create new _regulator_do_enable() and _regulator_do_disable() operations
    which deal with the mechanics of performing the enable and disable, partly
    to cut down on the levels of indentation and partly to support some future
    work.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 6e488aa6f1e8..82650a16a975 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1476,10 +1476,50 @@ void devm_regulator_put(struct regulator *regulator)
 }
 EXPORT_SYMBOL_GPL(devm_regulator_put);
 
+static int _regulator_do_enable(struct regulator_dev *rdev)
+{
+	int ret, delay;
+
+	/* Query before enabling in case configuration dependent.  */
+	ret = _regulator_get_enable_time(rdev);
+	if (ret >= 0) {
+		delay = ret;
+	} else {
+		rdev_warn(rdev, "enable_time() failed: %d\n", ret);
+		delay = 0;
+	}
+
+	trace_regulator_enable(rdev_get_name(rdev));
+
+	if (rdev->desc->ops->enable) {
+		ret = rdev->desc->ops->enable(rdev);
+		if (ret < 0)
+			return ret;
+	} else {
+		return -EINVAL;
+	}
+
+	/* Allow the regulator to ramp; it would be useful to extend
+	 * this for bulk operations so that the regulators can ramp
+	 * together.  */
+	trace_regulator_enable_delay(rdev_get_name(rdev));
+
+	if (delay >= 1000) {
+		mdelay(delay / 1000);
+		udelay(delay % 1000);
+	} else if (delay) {
+		udelay(delay);
+	}
+
+	trace_regulator_enable_complete(rdev_get_name(rdev));
+
+	return 0;
+}
+
 /* locks held by regulator_enable() */
 static int _regulator_enable(struct regulator_dev *rdev)
 {
-	int ret, delay;
+	int ret;
 
 	/* check voltage and requested load before enabling */
 	if (rdev->constraints &&
@@ -1493,40 +1533,10 @@ static int _regulator_enable(struct regulator_dev *rdev)
 			if (!_regulator_can_change_status(rdev))
 				return -EPERM;
 
-			if (!rdev->desc->ops->enable)
-				return -EINVAL;
-
-			/* Query before enabling in case configuration
-			 * dependent.  */
-			ret = _regulator_get_enable_time(rdev);
-			if (ret >= 0) {
-				delay = ret;
-			} else {
-				rdev_warn(rdev, "enable_time() failed: %d\n",
-					   ret);
-				delay = 0;
-			}
-
-			trace_regulator_enable(rdev_get_name(rdev));
-
-			/* Allow the regulator to ramp; it would be useful
-			 * to extend this for bulk operations so that the
-			 * regulators can ramp together.  */
-			ret = rdev->desc->ops->enable(rdev);
+			ret = _regulator_do_enable(rdev);
 			if (ret < 0)
 				return ret;
 
-			trace_regulator_enable_delay(rdev_get_name(rdev));
-
-			if (delay >= 1000) {
-				mdelay(delay / 1000);
-				udelay(delay % 1000);
-			} else if (delay) {
-				udelay(delay);
-			}
-
-			trace_regulator_enable_complete(rdev_get_name(rdev));
-
 		} else if (ret < 0) {
 			rdev_err(rdev, "is_enabled() failed: %d\n", ret);
 			return ret;
@@ -1575,6 +1585,30 @@ int regulator_enable(struct regulator *regulator)
 }
 EXPORT_SYMBOL_GPL(regulator_enable);
 
+static int _regulator_do_disable(struct regulator_dev *rdev)
+{
+	int ret;
+
+	trace_regulator_disable(rdev_get_name(rdev));
+
+	if (rdev->ena_gpio) {
+		gpio_set_value_cansleep(rdev->ena_gpio,
+					rdev->ena_gpio_invert);
+		rdev->ena_gpio_state = 0;
+
+	} else if (rdev->desc->ops->disable) {
+		ret = rdev->desc->ops->disable(rdev);
+		if (ret != 0)
+			return ret;
+	}
+
+	trace_regulator_disable_complete(rdev_get_name(rdev));
+
+	_notifier_call_chain(rdev, REGULATOR_EVENT_DISABLE,
+			     NULL);
+	return 0;
+}
+
 /* locks held by regulator_disable() */
 static int _regulator_disable(struct regulator_dev *rdev)
 {
@@ -1589,20 +1623,12 @@ static int _regulator_disable(struct regulator_dev *rdev)
 	    (rdev->constraints && !rdev->constraints->always_on)) {
 
 		/* we are last user */
-		if (_regulator_can_change_status(rdev) &&
-		    rdev->desc->ops->disable) {
-			trace_regulator_disable(rdev_get_name(rdev));
-
-			ret = rdev->desc->ops->disable(rdev);
+		if (_regulator_can_change_status(rdev)) {
+			ret = _regulator_do_disable(rdev);
 			if (ret < 0) {
 				rdev_err(rdev, "failed to disable\n");
 				return ret;
 			}
-
-			trace_regulator_disable_complete(rdev_get_name(rdev));
-
-			_notifier_call_chain(rdev, REGULATOR_EVENT_DISABLE,
-					     NULL);
 		}
 
 		rdev->use_count = 0;

commit 79511ed3225a64f6b7fc749f4f9c1ed82f24f729
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Jun 27 14:23:10 2012 +0100

    regulator: core: Allow fixed enable_time to be set in the regulator_desc
    
    Many regulators have a fixed specification for their enable time. Allow
    this to be set in the regulator_desc as a number to save them having to
    implement an explicit operation.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index aa82c0465f4f..6e488aa6f1e8 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1189,7 +1189,7 @@ static struct regulator *create_regulator(struct regulator_dev *rdev,
 static int _regulator_get_enable_time(struct regulator_dev *rdev)
 {
 	if (!rdev->desc->ops->enable_time)
-		return 0;
+		return rdev->desc->enable_time;
 	return rdev->desc->ops->enable_time(rdev);
 }
 

commit e113d792d56d4b720b3d84c122b6af84c3bfa094
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Jun 26 10:57:51 2012 +0100

    regulator: core: Check that the selector from map_voltage() is valid
    
    Lots of regulator drivers have checks in their map_voltage() functions
    to verify that the result of the mapping is in the range originally
    specified. Factor these out in the core and provide a bit of extra
    defensiveness for other drivers by doing the check in the core.
    
    Since we're now doing a list_voltage() earlier move the current mapping
    back to a voltage out into the set_voltage() call to save redoing it.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index a80886626230..f98a8ee29933 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2040,7 +2040,7 @@ static int _regulator_do_set_voltage(struct regulator_dev *rdev,
 {
 	int ret;
 	int delay = 0;
-	int best_val;
+	int best_val = 0;
 	unsigned int selector;
 	int old_selector = -1;
 
@@ -2064,6 +2064,15 @@ static int _regulator_do_set_voltage(struct regulator_dev *rdev,
 	if (rdev->desc->ops->set_voltage) {
 		ret = rdev->desc->ops->set_voltage(rdev, min_uV, max_uV,
 						   &selector);
+
+		if (ret >= 0) {
+			if (rdev->desc->ops->list_voltage)
+				best_val = rdev->desc->ops->list_voltage(rdev,
+									 selector);
+			else
+				best_val = _regulator_get_voltage(rdev);
+		}
+
 	} else if (rdev->desc->ops->set_voltage_sel) {
 		if (rdev->desc->ops->map_voltage) {
 			ret = rdev->desc->ops->map_voltage(rdev, min_uV,
@@ -2079,18 +2088,19 @@ static int _regulator_do_set_voltage(struct regulator_dev *rdev,
 		}
 
 		if (ret >= 0) {
-			selector = ret;
-			ret = rdev->desc->ops->set_voltage_sel(rdev, ret);
+			best_val = rdev->desc->ops->list_voltage(rdev, ret);
+			if (min_uV <= best_val && max_uV >= best_val) {
+				selector = ret;
+				ret = rdev->desc->ops->set_voltage_sel(rdev,
+								       ret);
+			} else {
+				ret = -EINVAL;
+			}
 		}
 	} else {
 		ret = -EINVAL;
 	}
 
-	if (rdev->desc->ops->list_voltage)
-		best_val = rdev->desc->ops->list_voltage(rdev, selector);
-	else
-		best_val = _regulator_get_voltage(rdev);
-
 	/* Call set_voltage_time_sel if successfully obtained old_selector */
 	if (ret == 0 && _regulator_is_enabled(rdev) && old_selector >= 0 &&
 	    rdev->desc->ops->set_voltage_time_sel) {

commit c5f3939b8fe0c358d35397982e5afdef112afc81
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Jul 2 15:00:18 2012 +0100

    regulator: core: Support fixed voltages in regulator_is_supported_voltage()
    
    Currently regulator_is_supported_voltage() works by enumerating the set
    of voltages which can be set by the regulator but the checks we're doing
    to impose constraints mean that if we can't vary the voltage we'll not
    report any voltages as supported even though the regulator is actually
    set at that voltage.
    
    We could fix the voltage listing but this would mean that list_voltage()
    could end up going to the hardware to get the current voltage which isn't
    expected (it's supposed to be very cheap) so instead special case things
    when we can't change the voltage and compare the requested range against
    the current voltage.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index d886ee265e47..a80886626230 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1890,8 +1890,18 @@ EXPORT_SYMBOL_GPL(regulator_list_voltage);
 int regulator_is_supported_voltage(struct regulator *regulator,
 				   int min_uV, int max_uV)
 {
+	struct regulator_dev *rdev = regulator->rdev;
 	int i, voltages, ret;
 
+	/* If we can't change voltage check the current voltage */
+	if (!(rdev->constraints->valid_ops_mask & REGULATOR_CHANGE_VOLTAGE)) {
+		ret = regulator_get_voltage(regulator);
+		if (ret >= 0)
+			return (min_uV >= ret && ret <= max_uV);
+		else
+			return ret;
+	}
+
 	ret = regulator_count_voltages(regulator);
 	if (ret < 0)
 		return ret;

commit d92d95b6bf2722ffa0fefa7651c51bf336743dd7
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Mon Jul 2 19:21:06 2012 -0700

    regulator: Fix recursive mutex lockdep warning
    
    A recursive lockdep warning occurs if you call
    regulator_set_optimum_mode() on a regulator with a supply because
    there is no nesting annotation for the rdev->mutex. To avoid this
    warning, get the supply's load before locking the regulator's
    mutex to avoid grabbing the same class of lock twice.
    
    =============================================
    [ INFO: possible recursive locking detected ]
    3.4.0 #3257 Tainted: G        W
    ---------------------------------------------
    swapper/0/1 is trying to acquire lock:
     (&rdev->mutex){+.+.+.}, at: [<c036e9e0>] regulator_get_voltage+0x18/0x38
    
    but task is already holding lock:
     (&rdev->mutex){+.+.+.}, at: [<c036ef38>] regulator_set_optimum_mode+0x24/0x224
    
    other info that might help us debug this:
     Possible unsafe locking scenario:
    
           CPU0
           ----
      lock(&rdev->mutex);
      lock(&rdev->mutex);
    
     *** DEADLOCK ***
    
     May be due to missing lock nesting notation
    
    3 locks held by swapper/0/1:
     #0:  (&__lockdep_no_validate__){......}, at: [<c03dbb48>] __driver_attach+0x40/0x8c
     #1:  (&__lockdep_no_validate__){......}, at: [<c03dbb58>] __driver_attach+0x50/0x8c
     #2:  (&rdev->mutex){+.+.+.}, at: [<c036ef38>] regulator_set_optimum_mode+0x24/0x224
    
    stack backtrace:
    [<c001521c>] (unwind_backtrace+0x0/0x12c) from [<c00cc4d4>] (validate_chain+0x760/0x1080)
    [<c00cc4d4>] (validate_chain+0x760/0x1080) from [<c00cd744>] (__lock_acquire+0x950/0xa10)
    [<c00cd744>] (__lock_acquire+0x950/0xa10) from [<c00cd990>] (lock_acquire+0x18c/0x1e8)
    [<c00cd990>] (lock_acquire+0x18c/0x1e8) from [<c080c248>] (mutex_lock_nested+0x68/0x3c4)
    [<c080c248>] (mutex_lock_nested+0x68/0x3c4) from [<c036e9e0>] (regulator_get_voltage+0x18/0x38)
    [<c036e9e0>] (regulator_get_voltage+0x18/0x38) from [<c036efb8>] (regulator_set_optimum_mode+0xa4/0x224)
    ...
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 09a737c868b5..8b4b3829d9e7 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2519,9 +2519,12 @@ int regulator_set_optimum_mode(struct regulator *regulator, int uA_load)
 {
 	struct regulator_dev *rdev = regulator->rdev;
 	struct regulator *consumer;
-	int ret, output_uV, input_uV, total_uA_load = 0;
+	int ret, output_uV, input_uV = 0, total_uA_load = 0;
 	unsigned int mode;
 
+	if (rdev->supply)
+		input_uV = regulator_get_voltage(rdev->supply);
+
 	mutex_lock(&rdev->mutex);
 
 	/*
@@ -2554,10 +2557,7 @@ int regulator_set_optimum_mode(struct regulator *regulator, int uA_load)
 		goto out;
 	}
 
-	/* get input voltage */
-	input_uV = 0;
-	if (rdev->supply)
-		input_uV = regulator_get_voltage(rdev->supply);
+	/* No supply? Use constraint voltage */
 	if (input_uV <= 0)
 		input_uV = rdev->constraints->input_uV;
 	if (input_uV <= 0) {

commit bf2516cd020dbf80ed2f1750ac1f4b0da3549c91
Author: Fabio Estevam <fabio.estevam@freescale.com>
Date:   Wed Jun 27 10:40:28 2012 -0300

    regulator: core: Remove unused get_device_regulator
    
    commit 222cc7b1 (regulator: core: Allow multiple requests of a single supply mapping)
    removed the usage of get_device_regulator().
    
    Remove the function definition too amd get rid of the following warning:
    
    drivers/regulator/core.c:112:26: warning: 'get_device_regulator' defined but not used [-Wunused-function]
    
    Signed-off-by: Fabio Estevam <fabio.estevam@freescale.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 00c787c01f3b..d886ee265e47 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -108,28 +108,6 @@ static const char *rdev_get_name(struct regulator_dev *rdev)
 		return "";
 }
 
-/* gets the regulator for a given consumer device */
-static struct regulator *get_device_regulator(struct device *dev)
-{
-	struct regulator *regulator = NULL;
-	struct regulator_dev *rdev;
-
-	mutex_lock(&regulator_list_mutex);
-	list_for_each_entry(rdev, &regulator_list, list) {
-		mutex_lock(&rdev->mutex);
-		list_for_each_entry(regulator, &rdev->consumer_list, list) {
-			if (regulator->dev == dev) {
-				mutex_unlock(&rdev->mutex);
-				mutex_unlock(&regulator_list_mutex);
-				return regulator;
-			}
-		}
-		mutex_unlock(&rdev->mutex);
-	}
-	mutex_unlock(&regulator_list_mutex);
-	return NULL;
-}
-
 /**
  * of_get_regulator - get a regulator device node based on supply name
  * @dev: Device pointer for the consumer (of regulator) device

commit 222cc7b1cefbab1287ed5d5e3cce1f45aec60d39
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Fri Jun 22 11:39:16 2012 +0100

    regulator: core: Allow multiple requests of a single supply mapping
    
    Sometimes it may be useful to allow a device to request a supply multiple
    times, for example in order to allow framework management of some uses of
    the supply with some additional driver specific management or in order to
    allow multiple children of an MFD to work with the supply. Currently this
    is not possible due to the creation of
    
    Solve this by removing the requested_uA entry (we have no current users
    of this feature anyway) and ignoring errors creating the symlink to the
    consumer. We should do something nicer than this as this causes sysfs to
    spew enormous warnings but it allows users to run for now.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@ti.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 890fa5eb770d..00c787c01f3b 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -303,18 +303,6 @@ static int regulator_check_drms(struct regulator_dev *rdev)
 	return 0;
 }
 
-static ssize_t device_requested_uA_show(struct device *dev,
-			     struct device_attribute *attr, char *buf)
-{
-	struct regulator *regulator;
-
-	regulator = get_device_regulator(dev);
-	if (regulator == NULL)
-		return 0;
-
-	return sprintf(buf, "%d\n", regulator->uA_load);
-}
-
 static ssize_t regulator_uV_show(struct device *dev,
 				struct device_attribute *attr, char *buf)
 {
@@ -1097,48 +1085,27 @@ static struct regulator *create_regulator(struct regulator_dev *rdev,
 	list_add(&regulator->list, &rdev->consumer_list);
 
 	if (dev) {
-		/* create a 'requested_microamps_name' sysfs entry */
-		size = scnprintf(buf, REG_STR_SIZE,
-				 "microamps_requested_%s-%s",
-				 dev_name(dev), supply_name);
-		if (size >= REG_STR_SIZE)
-			goto overflow_err;
-
-		regulator->dev = dev;
-		sysfs_attr_init(&regulator->dev_attr.attr);
-		regulator->dev_attr.attr.name = kstrdup(buf, GFP_KERNEL);
-		if (regulator->dev_attr.attr.name == NULL)
-			goto attr_name_err;
-
-		regulator->dev_attr.attr.mode = 0444;
-		regulator->dev_attr.show = device_requested_uA_show;
-		err = device_create_file(dev, &regulator->dev_attr);
-		if (err < 0) {
-			rdev_warn(rdev, "could not add regulator_dev requested microamps sysfs entry\n");
-			goto attr_name_err;
-		}
-
-		/* also add a link to the device sysfs entry */
+		/* Add a link to the device sysfs entry */
 		size = scnprintf(buf, REG_STR_SIZE, "%s-%s",
 				 dev->kobj.name, supply_name);
 		if (size >= REG_STR_SIZE)
-			goto attr_err;
+			goto overflow_err;
 
 		regulator->supply_name = kstrdup(buf, GFP_KERNEL);
 		if (regulator->supply_name == NULL)
-			goto attr_err;
+			goto overflow_err;
 
 		err = sysfs_create_link(&rdev->dev.kobj, &dev->kobj,
 					buf);
 		if (err) {
 			rdev_warn(rdev, "could not add device link %s err %d\n",
 				  dev->kobj.name, err);
-			goto link_name_err;
+			/* non-fatal */
 		}
 	} else {
 		regulator->supply_name = kstrdup(supply_name, GFP_KERNEL);
 		if (regulator->supply_name == NULL)
-			goto attr_err;
+			goto overflow_err;
 	}
 
 	regulator->debugfs = debugfs_create_dir(regulator->supply_name,
@@ -1165,12 +1132,6 @@ static struct regulator *create_regulator(struct regulator_dev *rdev,
 
 	mutex_unlock(&rdev->mutex);
 	return regulator;
-link_name_err:
-	kfree(regulator->supply_name);
-attr_err:
-	device_remove_file(regulator->dev, &regulator->dev_attr);
-attr_name_err:
-	kfree(regulator->dev_attr.attr.name);
 overflow_err:
 	list_del(&regulator->list);
 	kfree(regulator);

commit 5aff3a8b20c54888e199e863744848007f1f4120
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Jun 26 11:16:58 2012 +0100

    regulator: core: Check for failed voltage sets before checking for delay
    
    There is no need to consider waiting for the voltage to ramp if we
    didn't manage to set it and looking at the return value is going to be
    cheaper than is_enabled().
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 729b20d1c1de..890fa5eb770d 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2143,7 +2143,7 @@ static int _regulator_do_set_voltage(struct regulator_dev *rdev,
 		best_val = _regulator_get_voltage(rdev);
 
 	/* Call set_voltage_time_sel if successfully obtained old_selector */
-	if (_regulator_is_enabled(rdev) && ret == 0 && old_selector >= 0 &&
+	if (ret == 0 && _regulator_is_enabled(rdev) && old_selector >= 0 &&
 	    rdev->desc->ops->set_voltage_time_sel) {
 
 		delay = rdev->desc->ops->set_voltage_time_sel(rdev,

commit 85e63343f49cdf859bb630ba39d9a9af85dfb3e6
Merge: 2f6ae6ef631c 6b16351acbd4
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Jun 25 10:11:40 2012 +0100

    Merge tag 'v3.5-rc4' into regulator-drivers
    
    Linux 3.5-rc4 contains patches which conflict with some of the
    development work.

commit f11d08c3d611d6f2845677caabe13b2c58f95658
Author: Axel Lin <axel.lin@gmail.com>
Date:   Tue Jun 19 09:38:45 2012 +0800

    regulator: Use list_voltage() to get voltage in regulator_set_voltage_time_sel
    
    With this change, regulator_set_voltage_time_sel() can be more generic and not
    limited to linear and table based mapping now.
    One side-effect of this change is that list_voltage() must be implemented.
    
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 26b71048709b..e3597ab09be3 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2296,8 +2296,7 @@ EXPORT_SYMBOL_GPL(regulator_set_voltage_time);
  * Provided with the starting and target voltage selectors, this function
  * returns time in microseconds required to rise or fall to this new voltage
  *
- * Drivers providing uV_step or volt_table in their regulator_desc and
- * ramp_delay in regulation_constraints can use this as their
+ * Drivers providing ramp_delay in regulation_constraints can use this as their
  * set_voltage_time_sel() operation.
  */
 int regulator_set_voltage_time_sel(struct regulator_dev *rdev,
@@ -2305,6 +2304,7 @@ int regulator_set_voltage_time_sel(struct regulator_dev *rdev,
 				   unsigned int new_selector)
 {
 	unsigned int ramp_delay = 0;
+	int old_volt, new_volt;
 
 	if (rdev->constraints->ramp_delay)
 		ramp_delay = rdev->constraints->ramp_delay;
@@ -2316,19 +2316,14 @@ int regulator_set_voltage_time_sel(struct regulator_dev *rdev,
 		return 0;
 	}
 
-	if (rdev->desc->uV_step) {
-		return DIV_ROUND_UP(rdev->desc->uV_step *
-				    abs(new_selector - old_selector),
-				    ramp_delay);
-	} else if (rdev->desc->volt_table) {
-		return DIV_ROUND_UP(abs(rdev->desc->volt_table[new_selector] -
-					rdev->desc->volt_table[old_selector]),
-				    ramp_delay);
-	} else {
-		rdev_warn(rdev, "Unsupported voltage mapping settings\n");
-	}
+	/* sanity check */
+	if (!rdev->desc->ops->list_voltage)
+		return -EINVAL;
 
-	return 0;
+	old_volt = rdev->desc->ops->list_voltage(rdev, old_selector);
+	new_volt = rdev->desc->ops->list_voltage(rdev, new_selector);
+
+	return DIV_ROUND_UP(abs(new_volt - old_volt), ramp_delay);
 }
 EXPORT_SYMBOL_GPL(regulator_set_voltage_time_sel);
 

commit b19dbf711e8dae026f8d014eae90d766d02f4acb
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Sat Jun 23 11:34:20 2012 +0100

    regulator: core: Add export of regulator_set_voltage_time_sel()
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index ce0a3462e0de..26b71048709b 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2330,6 +2330,7 @@ int regulator_set_voltage_time_sel(struct regulator_dev *rdev,
 
 	return 0;
 }
+EXPORT_SYMBOL_GPL(regulator_set_voltage_time_sel);
 
 /**
  * regulator_sync_voltage - re-apply last regulator output voltage

commit 230a5a1c41464f7fe5b676c21280ae4effa222c8
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Fri Jun 15 18:25:08 2012 +0100

    regulator: Fix double free in devm_regulator_put()
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 663ebd534ef9..729b20d1c1de 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1461,9 +1461,7 @@ void devm_regulator_put(struct regulator *regulator)
 
 	rc = devres_release(regulator->dev, devm_regulator_release,
 			    devm_regulator_match, regulator);
-	if (rc == 0)
-		regulator_put(regulator);
-	else
+	if (rc != 0)
 		WARN_ON(rc);
 }
 EXPORT_SYMBOL_GPL(devm_regulator_put);

commit ea38d13fd1666bc030cb1c0feec5b0da2f89f9b2
Author: Axel Lin <axel.lin@gmail.com>
Date:   Mon Jun 18 14:03:16 2012 +0800

    regulator: core: Change the unit of ramp_delay from mV/uS to uV/uS
    
    This change makes it possible to set ramp_delay with 0.xxx mV/uS without
    truncation issue.
    
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 73a3d874ca6e..ce0a3462e0de 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2319,11 +2319,11 @@ int regulator_set_voltage_time_sel(struct regulator_dev *rdev,
 	if (rdev->desc->uV_step) {
 		return DIV_ROUND_UP(rdev->desc->uV_step *
 				    abs(new_selector - old_selector),
-				    ramp_delay * 1000);
+				    ramp_delay);
 	} else if (rdev->desc->volt_table) {
 		return DIV_ROUND_UP(abs(rdev->desc->volt_table[new_selector] -
 					rdev->desc->volt_table[old_selector]),
-				    ramp_delay * 1000);
+				    ramp_delay);
 	} else {
 		rdev_warn(rdev, "Unsupported voltage mapping settings\n");
 	}

commit 398715ab9414b3b7741c8239c254111f5016821c
Author: Axel Lin <axel.lin@gmail.com>
Date:   Mon Jun 18 10:11:28 2012 +0800

    regulator: core: Support table based mapping in regulator_set_voltage_time_sel
    
    For table based mapping, we can calculate voltage difference by below equation:
    abs(rdev->desc->volt_table[new_selector] - rdev->desc->volt_table[old_selector])
    
    Thus we can make regulator_set_voltage_time_sel work for table based mapping.
    
    regulator_set_voltage_time_sel() only supports linear or table based mapping.
    In case it is misused, also warn if neither linear nor table based mapping
    is used with regulator_set_voltage_time_sel().
    
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index b615ae6606db..73a3d874ca6e 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2296,25 +2296,38 @@ EXPORT_SYMBOL_GPL(regulator_set_voltage_time);
  * Provided with the starting and target voltage selectors, this function
  * returns time in microseconds required to rise or fall to this new voltage
  *
- * Drivers providing uV_step in their regulator_desc and ramp_delay in
- * regulation_constraints can use this as their set_voltage_time_sel()
- * operation.
+ * Drivers providing uV_step or volt_table in their regulator_desc and
+ * ramp_delay in regulation_constraints can use this as their
+ * set_voltage_time_sel() operation.
  */
 int regulator_set_voltage_time_sel(struct regulator_dev *rdev,
 				   unsigned int old_selector,
 				   unsigned int new_selector)
 {
-	if (rdev->desc->uV_step) {
-		if (rdev->constraints->ramp_delay)
-			return DIV_ROUND_UP(rdev->desc->uV_step *
-				abs(new_selector - old_selector),
-				rdev->constraints->ramp_delay * 1000);
-		if (rdev->desc->ramp_delay)
-			return DIV_ROUND_UP(rdev->desc->uV_step *
-				abs(new_selector - old_selector),
-				rdev->desc->ramp_delay * 1000);
+	unsigned int ramp_delay = 0;
+
+	if (rdev->constraints->ramp_delay)
+		ramp_delay = rdev->constraints->ramp_delay;
+	else if (rdev->desc->ramp_delay)
+		ramp_delay = rdev->desc->ramp_delay;
+
+	if (ramp_delay == 0) {
 		rdev_warn(rdev, "ramp_delay not set\n");
+		return 0;
 	}
+
+	if (rdev->desc->uV_step) {
+		return DIV_ROUND_UP(rdev->desc->uV_step *
+				    abs(new_selector - old_selector),
+				    ramp_delay * 1000);
+	} else if (rdev->desc->volt_table) {
+		return DIV_ROUND_UP(abs(rdev->desc->volt_table[new_selector] -
+					rdev->desc->volt_table[old_selector]),
+				    ramp_delay * 1000);
+	} else {
+		rdev_warn(rdev, "Unsupported voltage mapping settings\n");
+	}
+
 	return 0;
 }
 

commit 6f0b2c696ca340cc2da381fe693fda3f8fdb2149
Author: Yadwinder Singh Brar <yadi.brar01@gmail.com>
Date:   Mon Jun 11 17:41:08 2012 +0530

    regulator: Add ramp_delay configuration to constraints
    
    For some hardwares ramp_delay for BUCKs is a configurable parameter which can
    be configured through DT or board file.This patch adds ramp_delay to regulator
    constraints and allow user to configure it for regulators which supports this
    feature, through DT or board file. It will provide two ways of setting the
    ramp_delay for a regulator:
            First, by setting it as constraints in board file(for configurable
    regulators) and set_machine_constraints() will take care of setting it on
    hardware by calling(the provided) .set_ramp_delay() operation(callback).
            Second, by setting it as data in regulator_desc(as fixed/default
    ramp_delay rate) for a regulator in driver.
    
    regulator_set_voltage_time_sel() will give preference to
    constraints->ramp_delay while reading ramp_delay rate for regulator. Similarly
    users should also take care accordingly while refering ramp_delay rate(in case
    of implementing their private .set_voltage_time_sel() callbacks for different
    regulators).
    
    [Rewrote subject for 80 columns -- broonie]
    
    Signed-off-by: Yadwinder Singh Brar <yadi.brar@samsung.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 6ffca9b32388..b615ae6606db 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -967,6 +967,14 @@ static int set_machine_constraints(struct regulator_dev *rdev,
 		}
 	}
 
+	if (rdev->constraints->ramp_delay && ops->set_ramp_delay) {
+		ret = ops->set_ramp_delay(rdev, rdev->constraints->ramp_delay);
+		if (ret < 0) {
+			rdev_err(rdev, "failed to set ramp_delay\n");
+			goto out;
+		}
+	}
+
 	print_constraints(rdev);
 	return 0;
 out:
@@ -2296,10 +2304,17 @@ int regulator_set_voltage_time_sel(struct regulator_dev *rdev,
 				   unsigned int old_selector,
 				   unsigned int new_selector)
 {
-	if (rdev->desc->ramp_delay && rdev->desc->uV_step)
-		return DIV_ROUND_UP(rdev->desc->uV_step *
-			abs(new_selector - old_selector),
-			rdev->desc->ramp_delay * 1000);
+	if (rdev->desc->uV_step) {
+		if (rdev->constraints->ramp_delay)
+			return DIV_ROUND_UP(rdev->desc->uV_step *
+				abs(new_selector - old_selector),
+				rdev->constraints->ramp_delay * 1000);
+		if (rdev->desc->ramp_delay)
+			return DIV_ROUND_UP(rdev->desc->uV_step *
+				abs(new_selector - old_selector),
+				rdev->desc->ramp_delay * 1000);
+		rdev_warn(rdev, "ramp_delay not set\n");
+	}
 	return 0;
 }
 

commit 8b96de31b0cf190fb6b21c4ab1ce310c430b72ae
Author: Philip Rakity <prakity@marvell.com>
Date:   Thu Jun 14 15:07:56 2012 -0700

    regulator: core.c Only delay when setting voltage requires this
    
    minor optimization: move delay code to where delay is set and
    thus where it is used vs in the main line path.
    
    Signed-off-by: Philip Rakity <prakity@marvell.com>
    Acked-by: Axel Lin <axel.lin@gmail.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index ebdd9e0e14d4..663ebd534ef9 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2155,14 +2155,14 @@ static int _regulator_do_set_voltage(struct regulator_dev *rdev,
 				  delay);
 			delay = 0;
 		}
-	}
 
-	/* Insert any necessary delays */
-	if (delay >= 1000) {
-		mdelay(delay / 1000);
-		udelay(delay % 1000);
-	} else if (delay) {
-		udelay(delay);
+		/* Insert any necessary delays */
+		if (delay >= 1000) {
+			mdelay(delay / 1000);
+			udelay(delay % 1000);
+		} else if (delay) {
+			udelay(delay);
+		}
 	}
 
 	if (ret == 0 && best_val >= 0)

commit 2f7baf89d3e4ed787989168cf31f2fdc04067586
Author: Philip Rakity <prakity@marvell.com>
Date:   Fri Jun 15 11:27:36 2012 -0700

    regulator: core.c Pass voltage to notifier when setting voltage
    
    The voltage being set should be passed to the call in handler
    requesting the callback.  Currently this is not done.
    
    The calling handler cannot call regulator_get_voltage() to get the
    information since the mutex is held by the regulator and
    deadlock occurs.
    
    Without this change the receiver of the call in cannot know what
    action to take.  This is used, for example, to set PAD voltages
    when doing SD vccq voltage changes.
    
    [Review and spelling fix in the commit log from Pankaj Jangra]
    
    Signed-off-by: Philip Rakity <prakity@marvell.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 52a9bae10393..ebdd9e0e14d4 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2142,7 +2142,7 @@ static int _regulator_do_set_voltage(struct regulator_dev *rdev,
 	if (rdev->desc->ops->list_voltage)
 		best_val = rdev->desc->ops->list_voltage(rdev, selector);
 	else
-		best_val = -1;
+		best_val = _regulator_get_voltage(rdev);
 
 	/* Call set_voltage_time_sel if successfully obtained old_selector */
 	if (_regulator_is_enabled(rdev) && ret == 0 && old_selector >= 0 &&
@@ -2165,9 +2165,9 @@ static int _regulator_do_set_voltage(struct regulator_dev *rdev,
 		udelay(delay);
 	}
 
-	if (ret == 0)
+	if (ret == 0 && best_val >= 0)
 		_notifier_call_chain(rdev, REGULATOR_EVENT_VOLTAGE_CHANGE,
-				     NULL);
+				     (void *)best_val);
 
 	trace_regulator_set_voltage_complete(rdev_get_name(rdev), best_val);
 

commit d8493d210b69b2965236a8a02f5f6e2835ad5e30
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Fri Jun 15 19:09:09 2012 +0100

    regulator: core: Actually use the data in _notifier_call_chain()
    
    Reported-by: Pankaj Jangra <jangra.pankaj9@gmail.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 3cbe3129ed3b..52a9bae10393 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2657,7 +2657,7 @@ static void _notifier_call_chain(struct regulator_dev *rdev,
 				  unsigned long event, void *data)
 {
 	/* call rdev chain first */
-	blocking_notifier_call_chain(&rdev->notifier, event, NULL);
+	blocking_notifier_call_chain(&rdev->notifier, event, data);
 }
 
 /**

commit 578df8babf3b1895d562e1ea0d3a81d1e77e0182
Author: Axel Lin <axel.lin@gmail.com>
Date:   Mon Jun 11 13:14:50 2012 +0800

    regulator: core: Return correct delay time in regulator_set_voltage_time_sel
    
    rdev->desc->uV_step * abs(new_selector - old_selector) returns uV.
    The unit of ramp_delay is mV/us.
    
    Current code multiples 1000 at wrong place.
    
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index ff76abde3ab3..6ffca9b32388 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2299,7 +2299,7 @@ int regulator_set_voltage_time_sel(struct regulator_dev *rdev,
 	if (rdev->desc->ramp_delay && rdev->desc->uV_step)
 		return DIV_ROUND_UP(rdev->desc->uV_step *
 			abs(new_selector - old_selector),
-			rdev->desc->ramp_delay) * 1000;
+			rdev->desc->ramp_delay * 1000);
 	return 0;
 }
 

commit 98a175b60f46a80dfa44fb0e0807f2e5a351f35f
Author: Yadwinder Singh Brar <yadi.brar01@gmail.com>
Date:   Sat Jun 9 16:40:38 2012 +0530

    regulator: core: Add regulator_set_voltage_time_sel to calculate ramp delay.
    
    This patch adds regulator_set_voltage_time_sel(), to move into core, the
    commonly used code by drivers to provide the .set_voltage_time_sel callback.
    It will also allow us to configure different ramp delay for different
    regulators easily.
    
    Signed-off-by: Yadwinder Singh Brar <yadi.brar@samsung.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 5c6aedaa934d..ff76abde3ab3 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2279,6 +2279,30 @@ int regulator_set_voltage_time(struct regulator *regulator,
 }
 EXPORT_SYMBOL_GPL(regulator_set_voltage_time);
 
+/**
+ *regulator_set_voltage_time_sel - get raise/fall time
+ * @regulator: regulator source
+ * @old_selector: selector for starting voltage
+ * @new_selector: selector for target voltage
+ *
+ * Provided with the starting and target voltage selectors, this function
+ * returns time in microseconds required to rise or fall to this new voltage
+ *
+ * Drivers providing uV_step in their regulator_desc and ramp_delay in
+ * regulation_constraints can use this as their set_voltage_time_sel()
+ * operation.
+ */
+int regulator_set_voltage_time_sel(struct regulator_dev *rdev,
+				   unsigned int old_selector,
+				   unsigned int new_selector)
+{
+	if (rdev->desc->ramp_delay && rdev->desc->uV_step)
+		return DIV_ROUND_UP(rdev->desc->uV_step *
+			abs(new_selector - old_selector),
+			rdev->desc->ramp_delay) * 1000;
+	return 0;
+}
+
 /**
  * regulator_sync_voltage - re-apply last regulator output voltage
  * @regulator: regulator source

commit 5a6881e8e134ea636bbc8423049e84638dbb7106
Author: Axel Lin <axel.lin@gmail.com>
Date:   Thu Jun 7 10:05:14 2012 +0800

    regulator: core: Handle fixed voltage in map_voltage_linear
    
    Fixed voltage is a kind of linear mapping where n_voltages is 1.
    This change allows [list|map]_voltage_linear to be used for fixed
    voltage.
    
    For fixed voltage, n_voltages is 1 and the only valid selector is 0.
    Thus we actually don't care the uV_step setting.
    
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 8521e0d6b3bc..5c6aedaa934d 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2070,6 +2070,14 @@ int regulator_map_voltage_linear(struct regulator_dev *rdev,
 {
 	int ret, voltage;
 
+	/* Allow uV_step to be 0 for fixed voltage */
+	if (rdev->desc->n_voltages == 1 && rdev->desc->uV_step == 0) {
+		if (min_uV <= rdev->desc->min_uV && rdev->desc->min_uV <= max_uV)
+			return 0;
+		else
+			return -EINVAL;
+	}
+
 	if (!rdev->desc->uV_step) {
 		BUG_ON(!rdev->desc->uV_step);
 		return -EINVAL;

commit 0bdc81e4e944781a2bcc971f9e3cf24ac7030939
Author: Axel Lin <axel.lin@gmail.com>
Date:   Thu Jun 7 09:52:12 2012 +0800

    regulator: core: Properly handle the case min_uV < rdev->desc->min_uV in map_voltage_linear
    
    Properly handle the case if the specified min_uV is less than the voltage given
    by the lowest selector.
    
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 7584a74eec8a..09a737c868b5 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2050,6 +2050,9 @@ int regulator_map_voltage_linear(struct regulator_dev *rdev,
 		return -EINVAL;
 	}
 
+	if (min_uV < rdev->desc->min_uV)
+		min_uV = rdev->desc->min_uV;
+
 	ret = DIV_ROUND_UP(min_uV - rdev->desc->min_uV, rdev->desc->uV_step);
 	if (ret < 0)
 		return ret;

commit 9152c36a3b37a95c1161508dc105719456d7f7d0
Author: Axel Lin <axel.lin@gmail.com>
Date:   Mon Jun 4 09:41:38 2012 +0800

    regulator: core: Use map_voltage_linear() if list_voltage_linear() is in use and nothing is set
    
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 8521e0d6b3bc..3cbe3129ed3b 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2118,12 +2118,18 @@ static int _regulator_do_set_voltage(struct regulator_dev *rdev,
 		ret = rdev->desc->ops->set_voltage(rdev, min_uV, max_uV,
 						   &selector);
 	} else if (rdev->desc->ops->set_voltage_sel) {
-		if (rdev->desc->ops->map_voltage)
+		if (rdev->desc->ops->map_voltage) {
 			ret = rdev->desc->ops->map_voltage(rdev, min_uV,
 							   max_uV);
-		else
-			ret = regulator_map_voltage_iterate(rdev, min_uV,
-							    max_uV);
+		} else {
+			if (rdev->desc->ops->list_voltage ==
+			    regulator_list_voltage_linear)
+				ret = regulator_map_voltage_linear(rdev,
+								min_uV, max_uV);
+			else
+				ret = regulator_map_voltage_iterate(rdev,
+								min_uV, max_uV);
+		}
 
 		if (ret >= 0) {
 			selector = ret;

commit 3a4b0a07fa69cbfbdd4bc2ebe769cf789949db46
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue May 8 18:10:45 2012 +0100

    regulator: core: Use dev_get_regmap() to find the regmap
    
    If no regmap is explicitly specified then use dev_get_regmap() to obtain
    one. The driver must explicitly enable any actual usage of the regmap
    so there's no concern with unwanted usage.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@ti.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 7965e86a3fbb..8521e0d6b3bc 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -3128,7 +3128,10 @@ regulator_register(const struct regulator_desc *regulator_desc,
 	rdev->reg_data = config->driver_data;
 	rdev->owner = regulator_desc->owner;
 	rdev->desc = regulator_desc;
-	rdev->regmap = config->regmap;
+	if (config->regmap)
+		rdev->regmap = config->regmap;
+	else
+		rdev->regmap = dev_get_regmap(dev, NULL);
 	INIT_LIST_HEAD(&rdev->consumer_list);
 	INIT_LIST_HEAD(&rdev->list);
 	BLOCKING_INIT_NOTIFIER_HEAD(&rdev->notifier);

commit 361ff5017446605dca8b0a084c826e3d2a0d0a99
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon May 7 14:14:30 2012 +0100

    regulator: Use newly added devres_release() rather than open coding
    
    devres_release() will call the destructor for the resource as well as
    freeing the devres data.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@ti.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 58a4749c6347..7965e86a3fbb 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1459,7 +1459,7 @@ void devm_regulator_put(struct regulator *regulator)
 {
 	int rc;
 
-	rc = devres_destroy(regulator->dev, devm_regulator_release,
+	rc = devres_release(regulator->dev, devm_regulator_release,
 			    devm_regulator_match, regulator);
 	if (rc == 0)
 		regulator_put(regulator);

commit 8b7485ef623b9171e5a58c67eef5912a27db5822
Author: Axel Lin <axel.lin@gmail.com>
Date:   Mon May 21 09:37:52 2012 +0800

    regulator: core: Call set_voltage_time_sel() only when the regulator is on
    
    If the regulator is not on, it won't take time setting new voltage.
    So only call set_voltage_time_sel() to get the necessary delay when
    the regulator is on.
    
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 333b7ebe7cae..58a4749c6347 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2106,7 +2106,8 @@ static int _regulator_do_set_voltage(struct regulator_dev *rdev,
 	 * If we can't obtain the old selector there is not enough
 	 * info to call set_voltage_time_sel().
 	 */
-	if (rdev->desc->ops->set_voltage_time_sel &&
+	if (_regulator_is_enabled(rdev) &&
+	    rdev->desc->ops->set_voltage_time_sel &&
 	    rdev->desc->ops->get_voltage_sel) {
 		old_selector = rdev->desc->ops->get_voltage_sel(rdev);
 		if (old_selector < 0)
@@ -2138,7 +2139,7 @@ static int _regulator_do_set_voltage(struct regulator_dev *rdev,
 		best_val = -1;
 
 	/* Call set_voltage_time_sel if successfully obtained old_selector */
-	if (ret == 0 && old_selector >= 0 &&
+	if (_regulator_is_enabled(rdev) && ret == 0 && old_selector >= 0 &&
 	    rdev->desc->ops->set_voltage_time_sel) {
 
 		delay = rdev->desc->ops->set_voltage_time_sel(rdev,

commit cffc9592fde309deafce12362e0a285108cfa3c8
Author: Axel Lin <axel.lin@gmail.com>
Date:   Sun May 20 10:30:21 2012 +0800

    regulator: core: Allow drivers to set voltage mapping table in regulator_desc
    
    Some regulator hardware use table based mapping can set volt_table in
    regulator_desc and use regulator_list_voltage_table() for their list_voltage
    callback.
    
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Acked-by: Liam Girdwood <lrg@ti.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 7584a74eec8a..333b7ebe7cae 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1882,6 +1882,31 @@ int regulator_list_voltage_linear(struct regulator_dev *rdev,
 }
 EXPORT_SYMBOL_GPL(regulator_list_voltage_linear);
 
+/**
+ * regulator_list_voltage_table - List voltages with table based mapping
+ *
+ * @rdev: Regulator device
+ * @selector: Selector to convert into a voltage
+ *
+ * Regulators with table based mapping between voltages and
+ * selectors can set volt_table in the regulator descriptor
+ * and then use this function as their list_voltage() operation.
+ */
+int regulator_list_voltage_table(struct regulator_dev *rdev,
+				 unsigned int selector)
+{
+	if (!rdev->desc->volt_table) {
+		BUG_ON(!rdev->desc->volt_table);
+		return -EINVAL;
+	}
+
+	if (selector >= rdev->desc->n_voltages)
+		return -EINVAL;
+
+	return rdev->desc->volt_table[selector];
+}
+EXPORT_SYMBOL_GPL(regulator_list_voltage_table);
+
 /**
  * regulator_list_voltage - enumerate supported voltages
  * @regulator: regulator source

commit ac1806572df55b6125ad9d117906820dacfa3145
Merge: ae82a8282031 84df8c1241be
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon May 21 16:49:16 2012 -0700

    Merge tag 'regulator-3.5' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/regulator
    
    Pull regulator updates from Mark Brown:
     "The major thing here is the addition of some helpers to factor code
      out of drivers, making a fair proportion of regulators much more just
      data rather than code which is nice.
    
      - Helpers in the core for regulators using regmap, providing generic
        implementations of the enable and voltage selection operations which
        just need data to describe them in the drivers.
      - Split out voltage mapping and voltage setting, allowing many more
        drivers to take advantage of the infrastructure for selectors.
      - Loads and loads of cleanups from Axel Lin once again, including many
        changes to take advantage of the above new framework features
      - New drivers for Ricoh RC5T583, TI TPS62362, TI TPS62363, TI
        TPS65913, TI TWL6035 and TI TWL6037.
    
      Some of the registration changes to support the core refactoring
      caused so many conflicts that eventually topic branches were abandoned
      for this release."
    
    * tag 'regulator-3.5' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/regulator: (227 commits)
      regulator: tps65910: use of_node of matched regulator being register
      regulator: tps65910: dt: support when "regulators" node found
      regulator: tps65910: add error message in case of failure
      regulator: tps62360: dt: initialize of_node param for regulator register.
      regulator: tps65910: use devm_* for memory allocation
      regulator: tps65910: use small letter for regulator names
      mfd: tpx6586x:  Depend on regulator
      regulator: regulator for Palmas Kconfig
      regulator: regulator driver for Palmas series chips
      regulator: Enable Device Tree for the db8500-prcmu regulator driver
      regulator: db8500-prcmu: Separate regulator registration from probe
      regulator: ab3100: Use regulator_map_voltage_iterate()
      regulator: tps65217: Convert to set_voltage_sel and map_voltage
      regulator: Enable the ab8500 for Device Tree
      regulator: ab8500: Split up probe() into manageable pieces
      regulator: max8925: Remove check_range function and max_uV from struct rc5t583_regulator_info
      regulator: max8649: Remove unused check_range() function
      regulator: rc5t583: Remove max_uV from struct rc5t583_regulator_info
      regulator: da9052: Convert to set_voltage_sel and map_voltage
      regulator: max8952: Use devm_kzalloc
      ...

commit b1a868310e7024650918119d292129446b2f8336
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon May 14 00:40:14 2012 +0100

    regulator: core: Don't open code _regulator_is_enabled()
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@ti.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 5a33282181d8..faa053278194 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -3160,8 +3160,7 @@ regulator_register(const struct regulator_desc *regulator_desc,
 			goto scrub;
 
 		/* Enable supply if rail is enabled */
-		if (rdev->desc->ops->is_enabled &&
-				rdev->desc->ops->is_enabled(rdev)) {
+		if (_regulator_is_enabled(rdev)) {
 			ret = regulator_enable(rdev->supply);
 			if (ret < 0)
 				goto scrub;
@@ -3293,7 +3292,7 @@ int regulator_suspend_finish(void)
 				goto unlock;
 			if (!ops->disable)
 				goto unlock;
-			if (ops->is_enabled && !ops->is_enabled(rdev))
+			if (!_regulator_is_enabled(rdev))
 				goto unlock;
 
 			error = ops->disable(rdev);

commit e81dba85c6388dfabcb76cbc2b8bd02836a53ae5
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Sun May 13 18:35:56 2012 +0100

    regulator: core: Release regulator-regulator supplies on error
    
    If we fail while registering a regulator make sure we release the supply
    for the regulator if there is one.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@ti.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 8918271f9e85..5a33282181d8 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -3193,6 +3193,8 @@ regulator_register(const struct regulator_desc *regulator_desc,
 	unset_regulator_supplies(rdev);
 
 scrub:
+	if (rdev->supply)
+		regulator_put(rdev->supply);
 	kfree(rdev->constraints);
 	device_unregister(&rdev->dev);
 	/* device core frees rdev */

commit ccfcb1c3cf5616ebd9c61e6c834af3b87fe6b7f7
Author: Axel Lin <axel.lin@gmail.com>
Date:   Mon May 14 10:33:37 2012 +0800

    regulator: core: Ensure simple linear voltage mappings falls within the specified range
    
    Integer division may truncate the result.
    Use DIV_ROUND_UP to ensure simple linear voltage mappings falls within the
    specified range.
    
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 5751f5ed47c0..8918271f9e85 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2047,7 +2047,7 @@ int regulator_map_voltage_linear(struct regulator_dev *rdev,
 		return -EINVAL;
 	}
 
-	ret = (min_uV - rdev->desc->min_uV) / rdev->desc->uV_step;
+	ret = DIV_ROUND_UP(min_uV - rdev->desc->min_uV, rdev->desc->uV_step);
 	if (ret < 0)
 		return ret;
 

commit bca7bbfff37808d56355bbcf0ceec34f0cc6c85d
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed May 9 21:38:33 2012 +0100

    regulator: core: Allow drivers to set simple linear voltage maps as data
    
    A lot of regulator hardware maps selectors on to voltages with a simple
    linear mapping function
    
        selector = base + (selector * step size)
    
    Provide off the shelf list_voltage() and map_voltage() operations which
    use new min_uV and uV_step members in the regulator_desc to implement
    this function.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@ti.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 5e32698d893a..5751f5ed47c0 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1859,6 +1859,26 @@ int regulator_count_voltages(struct regulator *regulator)
 }
 EXPORT_SYMBOL_GPL(regulator_count_voltages);
 
+/**
+ * regulator_list_voltage_linear - List voltages with simple calculation
+ *
+ * @rdev: Regulator device
+ * @selector: Selector to convert into a voltage
+ *
+ * Regulators with a simple linear mapping between voltages and
+ * selectors can set min_uV and uV_step in the regulator descriptor
+ * and then use this function as their list_voltage() operation,
+ */
+int regulator_list_voltage_linear(struct regulator_dev *rdev,
+				  unsigned int selector)
+{
+	if (selector >= rdev->desc->n_voltages)
+		return -EINVAL;
+
+	return rdev->desc->min_uV + (rdev->desc->uV_step * selector);
+}
+EXPORT_SYMBOL_GPL(regulator_list_voltage_linear);
+
 /**
  * regulator_list_voltage - enumerate supported voltages
  * @regulator: regulator source
@@ -2007,6 +2027,39 @@ int regulator_map_voltage_iterate(struct regulator_dev *rdev,
 }
 EXPORT_SYMBOL_GPL(regulator_map_voltage_iterate);
 
+/**
+ * regulator_map_voltage_linear - map_voltage() for simple linear mappings
+ *
+ * @rdev: Regulator to operate on
+ * @min_uV: Lower bound for voltage
+ * @max_uV: Upper bound for voltage
+ *
+ * Drivers providing min_uV and uV_step in their regulator_desc can
+ * use this as their map_voltage() operation.
+ */
+int regulator_map_voltage_linear(struct regulator_dev *rdev,
+				 int min_uV, int max_uV)
+{
+	int ret, voltage;
+
+	if (!rdev->desc->uV_step) {
+		BUG_ON(!rdev->desc->uV_step);
+		return -EINVAL;
+	}
+
+	ret = (min_uV - rdev->desc->min_uV) / rdev->desc->uV_step;
+	if (ret < 0)
+		return ret;
+
+	/* Map back into a voltage to verify we're still in bounds */
+	voltage = rdev->desc->ops->list_voltage(rdev, ret);
+	if (voltage < min_uV || voltage > max_uV)
+		return -EINVAL;
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(regulator_map_voltage_linear);
+
 static int _regulator_do_set_voltage(struct regulator_dev *rdev,
 				     int min_uV, int max_uV)
 {

commit e843fc4616485bbd8b5a115f5bd4f73808656373
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed May 9 21:16:06 2012 +0100

    regulator: core: Allow regulators to provide a voltage to selector mapping
    
    In order to allow more drivers to factor things out into data allow
    drivers to provide a mapping function to convert voltages into selectors.
    This allows any driver to use set_voltage_sel(). The existing mapping
    based on iterating over list_voltage() is provided as an operation which
    can be assigned to the new map_voltage() function though for ease of
    transition it is treated as the default.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@ti.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index aec7ad5cb2d3..5e32698d893a 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1967,14 +1967,54 @@ int regulator_set_voltage_sel_regmap(struct regulator_dev *rdev, unsigned sel)
 }
 EXPORT_SYMBOL_GPL(regulator_set_voltage_sel_regmap);
 
+/**
+ * regulator_map_voltage_iterate - map_voltage() based on list_voltage()
+ *
+ * @rdev: Regulator to operate on
+ * @min_uV: Lower bound for voltage
+ * @max_uV: Upper bound for voltage
+ *
+ * Drivers implementing set_voltage_sel() and list_voltage() can use
+ * this as their map_voltage() operation.  It will find a suitable
+ * voltage by calling list_voltage() until it gets something in bounds
+ * for the requested voltages.
+ */
+int regulator_map_voltage_iterate(struct regulator_dev *rdev,
+				  int min_uV, int max_uV)
+{
+	int best_val = INT_MAX;
+	int selector = 0;
+	int i, ret;
+
+	/* Find the smallest voltage that falls within the specified
+	 * range.
+	 */
+	for (i = 0; i < rdev->desc->n_voltages; i++) {
+		ret = rdev->desc->ops->list_voltage(rdev, i);
+		if (ret < 0)
+			continue;
+
+		if (ret < best_val && ret >= min_uV && ret <= max_uV) {
+			best_val = ret;
+			selector = i;
+		}
+	}
+
+	if (best_val != INT_MAX)
+		return selector;
+	else
+		return -EINVAL;
+}
+EXPORT_SYMBOL_GPL(regulator_map_voltage_iterate);
+
 static int _regulator_do_set_voltage(struct regulator_dev *rdev,
 				     int min_uV, int max_uV)
 {
 	int ret;
 	int delay = 0;
+	int best_val;
 	unsigned int selector;
 	int old_selector = -1;
-	int best_val = INT_MAX;
 
 	trace_regulator_set_voltage(rdev_get_name(rdev), min_uV, max_uV);
 
@@ -1995,39 +2035,27 @@ static int _regulator_do_set_voltage(struct regulator_dev *rdev,
 	if (rdev->desc->ops->set_voltage) {
 		ret = rdev->desc->ops->set_voltage(rdev, min_uV, max_uV,
 						   &selector);
-
-		if (rdev->desc->ops->list_voltage)
-			best_val = rdev->desc->ops->list_voltage(rdev,
-								 selector);
-		else
-			best_val = -1;
 	} else if (rdev->desc->ops->set_voltage_sel) {
-		int i;
-
-		selector = 0;
-
-		/* Find the smallest voltage that falls within the specified
-		 * range.
-		 */
-		for (i = 0; i < rdev->desc->n_voltages; i++) {
-			ret = rdev->desc->ops->list_voltage(rdev, i);
-			if (ret < 0)
-				continue;
+		if (rdev->desc->ops->map_voltage)
+			ret = rdev->desc->ops->map_voltage(rdev, min_uV,
+							   max_uV);
+		else
+			ret = regulator_map_voltage_iterate(rdev, min_uV,
+							    max_uV);
 
-			if (ret < best_val && ret >= min_uV && ret <= max_uV) {
-				best_val = ret;
-				selector = i;
-			}
+		if (ret >= 0) {
+			selector = ret;
+			ret = rdev->desc->ops->set_voltage_sel(rdev, ret);
 		}
-
-		if (best_val != INT_MAX)
-			ret = rdev->desc->ops->set_voltage_sel(rdev, selector);
-		else
-			ret = -EINVAL;
 	} else {
 		ret = -EINVAL;
 	}
 
+	if (rdev->desc->ops->list_voltage)
+		best_val = rdev->desc->ops->list_voltage(rdev, selector);
+	else
+		best_val = -1;
+
 	/* Call set_voltage_time_sel if successfully obtained old_selector */
 	if (ret == 0 && old_selector >= 0 &&
 	    rdev->desc->ops->set_voltage_time_sel) {

commit 178e43aef2979525d7864daefd9499614e13800e
Merge: d48b97b403d2 6492bc1b1a9c dcf701125eef
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Sat May 12 11:09:47 2012 +0100

    Merge remote-tracking branches 'regulator/topic/core', 'regulator/topic/regmap' and 'regulator/topic/register' into regulator-next

commit dcf701125eefea6baf72753533cb8b60fb0e3934
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue May 8 18:09:12 2012 +0100

    regulator: core: Warn on missing struct device
    
    The core really wants a struct device to be supplied for regulators and
    there's no reason this should be impossible so provide one so complain
    if we didn't get one.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@ti.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 9fafa00b8cd4..10fb252323fb 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2941,6 +2941,7 @@ regulator_register(const struct regulator_desc *regulator_desc,
 		return ERR_PTR(-EINVAL);
 
 	dev = config->dev;
+	WARN_ON(!dev);
 
 	if (regulator_desc->name == NULL || regulator_desc->ops == NULL)
 		return ERR_PTR(-EINVAL);

commit 968c2c1707a3396ccd6e7e6c5ddaf658a6d3bd66
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon May 7 11:34:52 2012 +0100

    regulator: Actually free the regulator in devm_regulator_put()
    
    It turns out that (quite surprisingly) devres_destroy() only undoes the
    devres mapping, it doesn't destroy the underlying resource, meaning that
    anything using devm_regulator_put() would leak. While we wait for the new
    devres_release() which does what we want to get merged open code it in
    devm_regulator_put().
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@ti.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index e70dd382a009..046fb1bd8619 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1431,7 +1431,10 @@ void devm_regulator_put(struct regulator *regulator)
 
 	rc = devres_destroy(regulator->dev, devm_regulator_release,
 			    devm_regulator_match, regulator);
-	WARN_ON(rc);
+	if (rc == 0)
+		regulator_put(regulator);
+	else
+		WARN_ON(rc);
 }
 EXPORT_SYMBOL_GPL(devm_regulator_put);
 

commit 6492bc1b1a9cb21d28cde3c70d090c7648c8b0ed
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Thu Apr 19 13:19:07 2012 +0100

    regulator: core: Optimise enable/disable path for always on regulators
    
    If a regulator is always on for any reason then cache that when the
    consumer is created and use it to optimise away the need to take locks
    or recurse up the supply tree when consumers do enable or disable calls.
    The scheduling of asynchronous work for bulk enables is also skipped.
    
    We don't actually check if the device physically supports control on the
    basis that constraints allowing status changes on physically always on
    regulators are nonsensical anyway.
    
    This is a very common pattern in hardware - it's normal to have some
    power supplies that have either no software control or are critical to
    system function - so many systems should be able to benefit.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@ti.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 2f0d557a910d..4b2c02c519f0 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -74,6 +74,7 @@ struct regulator_map {
 struct regulator {
 	struct device *dev;
 	struct list_head list;
+	unsigned int always_on:1;
 	int uA_load;
 	int min_uV;
 	int max_uV;
@@ -155,6 +156,17 @@ static struct device_node *of_get_regulator(struct device *dev, const char *supp
 	return regnode;
 }
 
+static int _regulator_can_change_status(struct regulator_dev *rdev)
+{
+	if (!rdev->constraints)
+		return 0;
+
+	if (rdev->constraints->valid_ops_mask & REGULATOR_CHANGE_STATUS)
+		return 1;
+	else
+		return 0;
+}
+
 /* Platform voltage constraint check */
 static int regulator_check_voltage(struct regulator_dev *rdev,
 				   int *min_uV, int *max_uV)
@@ -1141,6 +1153,15 @@ static struct regulator *create_regulator(struct regulator_dev *rdev,
 				   &regulator->max_uV);
 	}
 
+	/*
+	 * Check now if the regulator is an always on regulator - if
+	 * it is then we don't need to do nearly so much work for
+	 * enable/disable calls.
+	 */
+	if (!_regulator_can_change_status(rdev) &&
+	    _regulator_is_enabled(rdev))
+		regulator->always_on = true;
+
 	mutex_unlock(&rdev->mutex);
 	return regulator;
 link_name_err:
@@ -1443,17 +1464,6 @@ void devm_regulator_put(struct regulator *regulator)
 }
 EXPORT_SYMBOL_GPL(devm_regulator_put);
 
-static int _regulator_can_change_status(struct regulator_dev *rdev)
-{
-	if (!rdev->constraints)
-		return 0;
-
-	if (rdev->constraints->valid_ops_mask & REGULATOR_CHANGE_STATUS)
-		return 1;
-	else
-		return 0;
-}
-
 /* locks held by regulator_enable() */
 static int _regulator_enable(struct regulator_dev *rdev)
 {
@@ -1533,6 +1543,9 @@ int regulator_enable(struct regulator *regulator)
 	struct regulator_dev *rdev = regulator->rdev;
 	int ret = 0;
 
+	if (regulator->always_on)
+		return 0;
+
 	if (rdev->supply) {
 		ret = regulator_enable(rdev->supply);
 		if (ret != 0)
@@ -1611,6 +1624,9 @@ int regulator_disable(struct regulator *regulator)
 	struct regulator_dev *rdev = regulator->rdev;
 	int ret = 0;
 
+	if (regulator->always_on)
+		return 0;
+
 	mutex_lock(&rdev->mutex);
 	ret = _regulator_disable(rdev);
 	mutex_unlock(&rdev->mutex);
@@ -1719,6 +1735,9 @@ int regulator_disable_deferred(struct regulator *regulator, int ms)
 	struct regulator_dev *rdev = regulator->rdev;
 	int ret;
 
+	if (regulator->always_on)
+		return 0;
+
 	mutex_lock(&rdev->mutex);
 	rdev->deferred_disables++;
 	mutex_unlock(&rdev->mutex);
@@ -1757,6 +1776,9 @@ int regulator_is_enabled(struct regulator *regulator)
 {
 	int ret;
 
+	if (regulator->always_on)
+		return 1;
+
 	mutex_lock(&regulator->rdev->mutex);
 	ret = _regulator_is_enabled(regulator->rdev);
 	mutex_unlock(&regulator->rdev->mutex);
@@ -2539,9 +2561,13 @@ int regulator_bulk_enable(int num_consumers,
 	int i;
 	int ret = 0;
 
-	for (i = 0; i < num_consumers; i++)
-		async_schedule_domain(regulator_bulk_enable_async,
-				      &consumers[i], &async_domain);
+	for (i = 0; i < num_consumers; i++) {
+		if (consumers[i].consumer->always_on)
+			consumers[i].ret = 0;
+		else
+			async_schedule_domain(regulator_bulk_enable_async,
+					      &consumers[i], &async_domain);
+	}
 
 	async_synchronize_full_domain(&async_domain);
 

commit 854ccbaee7e48734936690a3fd4817c57e98aaad
Author: Axel Lin <axel.lin@gmail.com>
Date:   Mon Apr 16 18:44:23 2012 +0800

    regulator: core: Add checking set_mode callback in regulator_set_optimum_mode
    
    regulator_set_optimum_mode needs set_mode to properly work.
    Add checking for set_mode callback in case it may be not implemented.
    
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 5c0c975e5ac2..2f0d557a910d 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2335,6 +2335,9 @@ int regulator_set_optimum_mode(struct regulator *regulator, int uA_load)
 	 */
 	ret = -EINVAL;
 
+	if (!rdev->desc->ops->set_mode)
+		goto out;
+
 	/* get output voltage */
 	output_uV = _regulator_get_voltage(rdev);
 	if (output_uV <= 0) {

commit cd6dffb4c6c476f5787f4df3eda7ecb16e25780d
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Sun Apr 15 12:37:47 2012 +0100

    regulator: core: Provide standard enable operations for regmap users
    
    Since the enable(), disable() and is_enabled() operations for most regmap
    based regulators come down to reading and updating a single register bit
    we can factor out the code and allow these drivers to just define which
    bit to update using the enable_reg and enable_mask fields in their desc
    and then use operations provided by the core.
    
    As well as the code saving this opens the door to future optimisation of
    the bulk operations - if the core can realise that we are updating a
    single register for multiple regulators then it should be able to combine
    these updates into a single physical operation.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@ti.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 02d2e15b2262..9fafa00b8cd4 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1725,6 +1725,61 @@ int regulator_disable_deferred(struct regulator *regulator, int ms)
 }
 EXPORT_SYMBOL_GPL(regulator_disable_deferred);
 
+/**
+ * regulator_is_enabled_regmap - standard is_enabled() for regmap users
+ *
+ * @rdev: regulator to operate on
+ *
+ * Regulators that use regmap for their register I/O can set the
+ * enable_reg and enable_mask fields in their descriptor and then use
+ * this as their is_enabled operation, saving some code.
+ */
+int regulator_is_enabled_regmap(struct regulator_dev *rdev)
+{
+	unsigned int val;
+	int ret;
+
+	ret = regmap_read(rdev->regmap, rdev->desc->enable_reg, &val);
+	if (ret != 0)
+		return ret;
+
+	return (val & rdev->desc->enable_mask) != 0;
+}
+EXPORT_SYMBOL_GPL(regulator_is_enabled_regmap);
+
+/**
+ * regulator_enable_regmap - standard enable() for regmap users
+ *
+ * @rdev: regulator to operate on
+ *
+ * Regulators that use regmap for their register I/O can set the
+ * enable_reg and enable_mask fields in their descriptor and then use
+ * this as their enable() operation, saving some code.
+ */
+int regulator_enable_regmap(struct regulator_dev *rdev)
+{
+	return regmap_update_bits(rdev->regmap, rdev->desc->enable_reg,
+				  rdev->desc->enable_mask,
+				  rdev->desc->enable_mask);
+}
+EXPORT_SYMBOL_GPL(regulator_enable_regmap);
+
+/**
+ * regulator_disable_regmap - standard disable() for regmap users
+ *
+ * @rdev: regulator to operate on
+ *
+ * Regulators that use regmap for their register I/O can set the
+ * enable_reg and enable_mask fields in their descriptor and then use
+ * this as their disable() operation, saving some code.
+ */
+int regulator_disable_regmap(struct regulator_dev *rdev)
+{
+	return regmap_update_bits(rdev->regmap, rdev->desc->enable_reg,
+				  rdev->desc->enable_mask, 0);
+}
+EXPORT_SYMBOL_GPL(regulator_disable_regmap);
+
 static int _regulator_is_enabled(struct regulator_dev *rdev)
 {
 	/* If we don't know then assume that the regulator is always on */

commit 4ab5b3d92c863e55fa28cc41a7b005b7ae87afee
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Sun Apr 15 11:23:30 2012 +0100

    regulator: core: Provide regmap based voltage_sel operations
    
    Since the voltage selector operations are intended to directly map a
    bitfield in the device register map into regulator API operations the
    code for implementing them is usually very standard we can save some
    code by providing standard implementations for devices using the regmap
    API.
    
    Drivers using regmap can pass their regmap in in the regmap_config
    struct, set vsel_reg and vsel_mask in their regulator_desc and then
    use regulator_{get,set}_voltage_sel_regmap in their ops. This saves
    a small amount of code from each driver.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@ti.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index bca1e5989243..02d2e15b2262 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1838,6 +1838,50 @@ int regulator_is_supported_voltage(struct regulator *regulator,
 }
 EXPORT_SYMBOL_GPL(regulator_is_supported_voltage);
 
+/**
+ * regulator_get_voltage_sel_regmap - standard get_voltage_sel for regmap users
+ *
+ * @rdev: regulator to operate on
+ *
+ * Regulators that use regmap for their register I/O can set the
+ * vsel_reg and vsel_mask fields in their descriptor and then use this
+ * as their get_voltage_vsel operation, saving some code.
+ */
+int regulator_get_voltage_sel_regmap(struct regulator_dev *rdev)
+{
+	unsigned int val;
+	int ret;
+
+	ret = regmap_read(rdev->regmap, rdev->desc->vsel_reg, &val);
+	if (ret != 0)
+		return ret;
+
+	val &= rdev->desc->vsel_mask;
+	val >>= ffs(rdev->desc->vsel_mask) - 1;
+
+	return val;
+}
+EXPORT_SYMBOL_GPL(regulator_get_voltage_sel_regmap);
+
+/**
+ * regulator_set_voltage_sel_regmap - standard set_voltage_sel for regmap users
+ *
+ * @rdev: regulator to operate on
+ * @sel: Selector to set
+ *
+ * Regulators that use regmap for their register I/O can set the
+ * vsel_reg and vsel_mask fields in their descriptor and then use this
+ * as their set_voltage_vsel operation, saving some code.
+ */
+int regulator_set_voltage_sel_regmap(struct regulator_dev *rdev, unsigned sel)
+{
+	sel <<= ffs(rdev->desc->vsel_mask) - 1;
+
+	return regmap_update_bits(rdev->regmap, rdev->desc->vsel_reg,
+				  rdev->desc->vsel_mask, sel);
+}
+EXPORT_SYMBOL_GPL(regulator_set_voltage_sel_regmap);
+
 static int _regulator_do_set_voltage(struct regulator_dev *rdev,
 				     int min_uV, int max_uV)
 {

commit 65b19ce6c223287ac95bbc22b12ef5a2738472d1
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Sun Apr 15 11:16:05 2012 +0100

    regulator: core: Allow drivers to pass in a regmap
    
    Since many regulators use regmap for register I/O and since there's quite
    a few very common patterns in the code allow drivers to pass in a regmap
    to the core for use in generic code.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@ti.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 7943fd64988d..bca1e5989243 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -24,6 +24,7 @@
 #include <linux/suspend.h>
 #include <linux/delay.h>
 #include <linux/of.h>
+#include <linux/regmap.h>
 #include <linux/regulator/of_regulator.h>
 #include <linux/regulator/consumer.h>
 #include <linux/regulator/driver.h>
@@ -2877,6 +2878,7 @@ regulator_register(const struct regulator_desc *regulator_desc,
 	rdev->reg_data = config->driver_data;
 	rdev->owner = regulator_desc->owner;
 	rdev->desc = regulator_desc;
+	rdev->regmap = config->regmap;
 	INIT_LIST_HEAD(&rdev->consumer_list);
 	INIT_LIST_HEAD(&rdev->list);
 	BLOCKING_INIT_NOTIFIER_HEAD(&rdev->notifier);

commit 8ac0e95d6467ced054565312ecdf0a55a5333c64
Author: Axel Lin <axel.lin@gmail.com>
Date:   Sat Apr 14 09:14:34 2012 +0800

    regulator: core: Support setting suspend_[mode|voltage] if set_suspend_[en|dis]able is NULL
    
    In current implementation, to support set_suspend_voltage and set_suspend_mode
    the regulator code needs the regulator driver to implement both
    set_suspend_enable and set_suspend_disable callbacks.
    
    This patch removes this limitation. In the case set_suspend_enable and/or
    set_suspend_disable are NULL, the regulator code assumes we don't need to
    do any thing to enable/disable regulator when system is suspended and
    then will continue to handle set_suspend_mode and set_suspend_voltage.
    
    Currently the regulator core creates suspend state related sysfs entries only
    if both set_suspend_enable and set_suspend_disable callbacks are not NULL.
    A side-effect of this change is that the regulator core will create suspend
    state related sysfs entries unconditionally now.
    
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 713981b52f2a..5c0c975e5ac2 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -673,17 +673,14 @@ static int suspend_set_state(struct regulator_dev *rdev,
 	struct regulator_state *rstate)
 {
 	int ret = 0;
-	bool can_set_state;
-
-	can_set_state = rdev->desc->ops->set_suspend_enable &&
-		rdev->desc->ops->set_suspend_disable;
 
 	/* If we have no suspend mode configration don't set anything;
-	 * only warn if the driver actually makes the suspend mode
-	 * configurable.
+	 * only warn if the driver implements set_suspend_voltage or
+	 * set_suspend_mode callback.
 	 */
 	if (!rstate->enabled && !rstate->disabled) {
-		if (can_set_state)
+		if (rdev->desc->ops->set_suspend_voltage ||
+		    rdev->desc->ops->set_suspend_mode)
 			rdev_warn(rdev, "No configuration\n");
 		return 0;
 	}
@@ -693,15 +690,13 @@ static int suspend_set_state(struct regulator_dev *rdev,
 		return -EINVAL;
 	}
 
-	if (!can_set_state) {
-		rdev_err(rdev, "no way to set suspend state\n");
-		return -EINVAL;
-	}
-
-	if (rstate->enabled)
+	if (rstate->enabled && rdev->desc->ops->set_suspend_enable)
 		ret = rdev->desc->ops->set_suspend_enable(rdev);
-	else
+	else if (rstate->disabled && rdev->desc->ops->set_suspend_disable)
 		ret = rdev->desc->ops->set_suspend_disable(rdev);
+	else /* OK if set_suspend_enable or set_suspend_disable is NULL */
+		ret = 0;
+
 	if (ret < 0) {
 		rdev_err(rdev, "failed to enabled/disable\n");
 		return ret;
@@ -2776,10 +2771,6 @@ static int add_regulator_attributes(struct regulator_dev *rdev)
 			return status;
 	}
 
-	/* suspend mode constraints need multiple supporting methods */
-	if (!(ops->set_suspend_enable && ops->set_suspend_disable))
-		return status;
-
 	status = device_create_file(dev, &dev_attr_suspend_standby_state);
 	if (status < 0)
 		return status;

commit 3f24f5ada638dd07705bd83ebcc80044d587f374
Author: Axel Lin <axel.lin@gmail.com>
Date:   Fri Apr 13 21:35:05 2012 +0800

    regulator: core: Fix getting input_uV when supplied by another regulator
    
    When supplied by another regulator, returns the supply regulator's output
    voltage for inpu_uV.
    
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index d4d34cbd34d9..713981b52f2a 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -649,7 +649,7 @@ static void drms_uA_update(struct regulator_dev *rdev)
 	/* get input voltage */
 	input_uV = 0;
 	if (rdev->supply)
-		input_uV = _regulator_get_voltage(rdev);
+		input_uV = regulator_get_voltage(rdev->supply);
 	if (input_uV <= 0)
 		input_uV = rdev->constraints->input_uV;
 	if (input_uV <= 0)

commit 32c8fad438200b523ec44a49b40cb8ffdf715f7c
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Apr 11 10:19:12 2012 +0100

    regulator: Appease smatch in regulator_register()
    
    We don't support missing configs at all so segfaulting isn't that bad
    but since we've got checks in the code move the dereference after them.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 4bb1f8456123..7943fd64988d 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2833,13 +2833,15 @@ regulator_register(const struct regulator_desc *regulator_desc,
 	const struct regulator_init_data *init_data;
 	static atomic_t regulator_no = ATOMIC_INIT(0);
 	struct regulator_dev *rdev;
-	struct device *dev = config->dev;
+	struct device *dev;
 	int ret, i;
 	const char *supply = NULL;
 
 	if (regulator_desc == NULL || config == NULL)
 		return ERR_PTR(-EINVAL);
 
+	dev = config->dev;
+
 	if (regulator_desc->name == NULL || regulator_desc->ops == NULL)
 		return ERR_PTR(-EINVAL);
 

commit b920eb41a8241c54efbbd4f2ed6d074f497b0d9e
Merge: a9d5801041ee 0034102808e0
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Apr 10 09:52:59 2012 +0100

    Merge tag 'v3.4-rc2' into regulator-drivers
    
    Linux 3.4-rc2 contains some fixes that further patches depend upon.

commit c172708d38a401b2f3f841dfcd862b469fa0b670
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Apr 4 00:50:22 2012 +0100

    regulator: core: Use a struct to pass in regulator runtime configuration
    
    Rather than adding new arguments to regulator_register() every time we
    want to add a new bit of dynamic information at runtime change the function
    to take these via a struct. By doing this we avoid needing to do further
    changes like the recent addition of device tree support which required each
    regulator driver to be updated to take an additional parameter.
    
    The regulator_desc which should (mostly) be static data is still passed
    separately as most drivers are able to configure this statically at build
    time.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index c4b626789f8e..8b9f8602d47b 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2820,27 +2820,24 @@ static void rdev_init_debugfs(struct regulator_dev *rdev)
 /**
  * regulator_register - register regulator
  * @regulator_desc: regulator to register
- * @dev: struct device for the regulator
- * @init_data: platform provided init data, passed through by driver
- * @driver_data: private regulator data
- * @of_node: OpenFirmware node to parse for device tree bindings (may be
- *           NULL).
+ * @config: runtime configuration for regulator
  *
  * Called by regulator drivers to register a regulator.
  * Returns 0 on success.
  */
 struct regulator_dev *
 regulator_register(const struct regulator_desc *regulator_desc,
-	struct device *dev, const struct regulator_init_data *init_data,
-	void *driver_data, struct device_node *of_node)
+		   const struct regulator_config *config)
 {
 	const struct regulation_constraints *constraints = NULL;
+	const struct regulator_init_data *init_data;
 	static atomic_t regulator_no = ATOMIC_INIT(0);
 	struct regulator_dev *rdev;
+	struct device *dev = config->dev;
 	int ret, i;
 	const char *supply = NULL;
 
-	if (regulator_desc == NULL)
+	if (regulator_desc == NULL || config == NULL)
 		return ERR_PTR(-EINVAL);
 
 	if (regulator_desc->name == NULL || regulator_desc->ops == NULL)
@@ -2866,6 +2863,8 @@ regulator_register(const struct regulator_desc *regulator_desc,
 		return ERR_PTR(-EINVAL);
 	}
 
+	init_data = config->init_data;
+
 	rdev = kzalloc(sizeof(struct regulator_dev), GFP_KERNEL);
 	if (rdev == NULL)
 		return ERR_PTR(-ENOMEM);
@@ -2873,7 +2872,7 @@ regulator_register(const struct regulator_desc *regulator_desc,
 	mutex_lock(&regulator_list_mutex);
 
 	mutex_init(&rdev->mutex);
-	rdev->reg_data = driver_data;
+	rdev->reg_data = config->driver_data;
 	rdev->owner = regulator_desc->owner;
 	rdev->desc = regulator_desc;
 	INIT_LIST_HEAD(&rdev->consumer_list);
@@ -2890,7 +2889,7 @@ regulator_register(const struct regulator_desc *regulator_desc,
 
 	/* register with sysfs */
 	rdev->dev.class = &regulator_class;
-	rdev->dev.of_node = of_node;
+	rdev->dev.of_node = config->of_node;
 	rdev->dev.parent = dev;
 	dev_set_name(&rdev->dev, "regulator.%d",
 		     atomic_inc_return(&regulator_no) - 1);

commit eba41a5e8c9473c24c333df288d4fd6a40e98464
Author: Axel Lin <axel.lin@gmail.com>
Date:   Wed Apr 4 10:32:10 2012 +0800

    regulator: Support set_voltage_time_sel for drivers implement set_voltage
    
    In currently implementation of _regulator_do_set_voltage, set_voltage_time_sel will
    only be called if set_voltage_sel is implemented.
    
    set_voltage_time_sel actually only needs get_voltage_sel to get old_selector.
    
    This patch makes regulator core support set_voltage_time_sel for drivers
    implement either set_voltage or set_voltage_sel.
    
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index f032823caa98..d4d34cbd34d9 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1856,23 +1856,35 @@ static int _regulator_do_set_voltage(struct regulator_dev *rdev,
 	int ret;
 	int delay = 0;
 	unsigned int selector;
+	int old_selector = -1;
+	int best_val = INT_MAX;
 
 	trace_regulator_set_voltage(rdev_get_name(rdev), min_uV, max_uV);
 
 	min_uV += rdev->constraints->uV_offset;
 	max_uV += rdev->constraints->uV_offset;
 
+	/*
+	 * If we can't obtain the old selector there is not enough
+	 * info to call set_voltage_time_sel().
+	 */
+	if (rdev->desc->ops->set_voltage_time_sel &&
+	    rdev->desc->ops->get_voltage_sel) {
+		old_selector = rdev->desc->ops->get_voltage_sel(rdev);
+		if (old_selector < 0)
+			return old_selector;
+	}
+
 	if (rdev->desc->ops->set_voltage) {
 		ret = rdev->desc->ops->set_voltage(rdev, min_uV, max_uV,
 						   &selector);
 
 		if (rdev->desc->ops->list_voltage)
-			selector = rdev->desc->ops->list_voltage(rdev,
+			best_val = rdev->desc->ops->list_voltage(rdev,
 								 selector);
 		else
-			selector = -1;
+			best_val = -1;
 	} else if (rdev->desc->ops->set_voltage_sel) {
-		int best_val = INT_MAX;
 		int i;
 
 		selector = 0;
@@ -1891,36 +1903,27 @@ static int _regulator_do_set_voltage(struct regulator_dev *rdev,
 			}
 		}
 
-		/*
-		 * If we can't obtain the old selector there is not enough
-		 * info to call set_voltage_time_sel().
-		 */
-		if (rdev->desc->ops->set_voltage_time_sel &&
-		    rdev->desc->ops->get_voltage_sel) {
-			unsigned int old_selector = 0;
-
-			ret = rdev->desc->ops->get_voltage_sel(rdev);
-			if (ret < 0)
-				return ret;
-			old_selector = ret;
-			ret = rdev->desc->ops->set_voltage_time_sel(rdev,
-						old_selector, selector);
-			if (ret < 0)
-				rdev_warn(rdev, "set_voltage_time_sel() failed: %d\n", ret);
-			else
-				delay = ret;
-		}
-
-		if (best_val != INT_MAX) {
+		if (best_val != INT_MAX)
 			ret = rdev->desc->ops->set_voltage_sel(rdev, selector);
-			selector = best_val;
-		} else {
+		else
 			ret = -EINVAL;
-		}
 	} else {
 		ret = -EINVAL;
 	}
 
+	/* Call set_voltage_time_sel if successfully obtained old_selector */
+	if (ret == 0 && old_selector >= 0 &&
+	    rdev->desc->ops->set_voltage_time_sel) {
+
+		delay = rdev->desc->ops->set_voltage_time_sel(rdev,
+						old_selector, selector);
+		if (delay < 0) {
+			rdev_warn(rdev, "set_voltage_time_sel() failed: %d\n",
+				  delay);
+			delay = 0;
+		}
+	}
+
 	/* Insert any necessary delays */
 	if (delay >= 1000) {
 		mdelay(delay / 1000);
@@ -1933,7 +1936,7 @@ static int _regulator_do_set_voltage(struct regulator_dev *rdev,
 		_notifier_call_chain(rdev, REGULATOR_EVENT_VOLTAGE_CHANGE,
 				     NULL);
 
-	trace_regulator_set_voltage_complete(rdev_get_name(rdev), selector);
+	trace_regulator_set_voltage_complete(rdev_get_name(rdev), best_val);
 
 	return ret;
 }

commit 4a1e8ebc5e5918079109cc1cd1c44c2f0fd0e11b
Merge: 66cfb3277249 d49fe3c4cd22
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Apr 4 10:09:30 2012 -0700

    Merge tag 'regulator-3.4' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/regulator
    
    Pull regulator fixes from Mark Brown:
     "A bunch of smallish fixes that came up during the merge window as
      things got more testing - even more fixes from Axel, a fix for error
      handling in more complex systems using -EPROBE_DEFER and a couple of
      small fixes for the new dummy regulators."
    
    * tag 'regulator-3.4' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/regulator:
      regulator: Remove non-existent parameter from fixed-helper.c kernel doc
      regulator: Fix setting new voltage in s5m8767_set_voltage
      regulator: fix sysfs name collision between dummy and fixed dummy regulator
      regulator: Fix deadlock on removal of regulators with supplies
      regulator: Fix comments in include/linux/regulator/machine.h
      regulator: Only update [LDOx|DCx]_HIB_MODE bits in wm8350_[ldo|dcdc]_set_suspend_disable
      regulator: Fix setting low power mode for wm831x aldo
      regulator: Return microamps in wm8350_isink_get_current
      regulator: wm8350: Fix the logic to choose best current limit setting
      regulator: wm831x-isink: Fix the logic to choose best current limit setting
      regulator: wm831x-dcdc: Fix the logic to choose best current limit setting
      regulator: anatop: patching to device-tree property "reg".
      regulator: Do proper shift to set correct bit for DC[2|5]_HIB_MODE setting
      regulator: Fix restoring pmic.dcdcx_hib_mode settings in wm8350_dcdc_set_suspend_enable
      regulator: Fix unbalanced lock/unlock in mc13892_regulator_probe error path
      regulator: Fix set and get current limit for wm831x_buckv
      regulator: tps6586x: Fix list minimal voltage setting for LDO0

commit 65f26846b90611742f3b407cc538a1cad33abde8
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Apr 3 20:46:53 2012 +0100

    regulator: core: Constify the regulator_desc passed in when registering
    
    Drivers should be able to declare their descriptors const and the framework
    shouldn't ever be modifying the desciptor. Make the parameter and the
    pointer in regulator_dev const to enforce this.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index c056abd7562a..c4b626789f8e 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2829,7 +2829,8 @@ static void rdev_init_debugfs(struct regulator_dev *rdev)
  * Called by regulator drivers to register a regulator.
  * Returns 0 on success.
  */
-struct regulator_dev *regulator_register(struct regulator_desc *regulator_desc,
+struct regulator_dev *
+regulator_register(const struct regulator_desc *regulator_desc,
 	struct device *dev, const struct regulator_init_data *init_data,
 	void *driver_data, struct device_node *of_node)
 {

commit 576ca4367f291a9b240d027670fa2e344edf8c8a
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Fri Mar 30 12:24:37 2012 +0100

    regulator: core: Pull non-DT supply mapping into regulator_dev_lookup()
    
    Ensure we always apply the supply mapping when doing a lookup rather than
    only doing it in non-DT cases, ensuring that regulators with supplies
    specified in the regulator_desc can find their supplies on non-DT systems
    and generally making the code more obvious.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 7b11979d79d1..f032823caa98 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1174,6 +1174,8 @@ static struct regulator_dev *regulator_dev_lookup(struct device *dev,
 {
 	struct regulator_dev *r;
 	struct device_node *node;
+	struct regulator_map *map;
+	const char *devname = NULL;
 
 	/* first do a dt based lookup */
 	if (dev && dev->of_node) {
@@ -1195,10 +1197,24 @@ static struct regulator_dev *regulator_dev_lookup(struct device *dev,
 	}
 
 	/* if not found, try doing it non-dt way */
+	if (dev)
+		devname = dev_name(dev);
+
 	list_for_each_entry(r, &regulator_list, list)
 		if (strcmp(rdev_get_name(r), supply) == 0)
 			return r;
 
+	list_for_each_entry(map, &regulator_map_list, list) {
+		/* If the mapping has a device set up it must match */
+		if (map->dev_name &&
+		    (!devname || strcmp(map->dev_name, devname)))
+			continue;
+
+		if (strcmp(map->supply, supply) == 0)
+			return map->regulator;
+	}
+
+
 	return NULL;
 }
 
@@ -1207,7 +1223,6 @@ static struct regulator *_regulator_get(struct device *dev, const char *id,
 					int exclusive)
 {
 	struct regulator_dev *rdev;
-	struct regulator_map *map;
 	struct regulator *regulator = ERR_PTR(-EPROBE_DEFER);
 	const char *devname = NULL;
 	int ret;
@@ -1226,18 +1241,6 @@ static struct regulator *_regulator_get(struct device *dev, const char *id,
 	if (rdev)
 		goto found;
 
-	list_for_each_entry(map, &regulator_map_list, list) {
-		/* If the mapping has a device set up it must match */
-		if (map->dev_name &&
-		    (!devname || strcmp(map->dev_name, devname)))
-			continue;
-
-		if (strcmp(map->supply, id) == 0) {
-			rdev = map->regulator;
-			goto found;
-		}
-	}
-
 	if (board_wants_dummy_regulator) {
 		rdev = dummy_regulator_rdev;
 		goto found;

commit 6d191a5fc7a969d972f1681e1c23781aecb06a61
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Thu Mar 29 14:19:02 2012 +0100

    regulator: core: Don't defer probe if there's no DT binding for a supply
    
    When using device tree if there's no binding for a supply then there's no
    way that one could appear later so just fail permanently right away. This
    avoids wasting time trying to reprobe when that can never work.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index fe28481dc91c..7b11979d79d1 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1169,7 +1169,8 @@ static int _regulator_get_enable_time(struct regulator_dev *rdev)
 }
 
 static struct regulator_dev *regulator_dev_lookup(struct device *dev,
-							 const char *supply)
+						  const char *supply,
+						  int *ret)
 {
 	struct regulator_dev *r;
 	struct device_node *node;
@@ -1177,11 +1178,20 @@ static struct regulator_dev *regulator_dev_lookup(struct device *dev,
 	/* first do a dt based lookup */
 	if (dev && dev->of_node) {
 		node = of_get_regulator(dev, supply);
-		if (node)
+		if (node) {
 			list_for_each_entry(r, &regulator_list, list)
 				if (r->dev.parent &&
 					node == r->dev.of_node)
 					return r;
+		} else {
+			/*
+			 * If we couldn't even get the node then it's
+			 * not just that the device didn't register
+			 * yet, there's no node and we'll never
+			 * succeed.
+			 */
+			*ret = -ENODEV;
+		}
 	}
 
 	/* if not found, try doing it non-dt way */
@@ -1212,7 +1222,7 @@ static struct regulator *_regulator_get(struct device *dev, const char *id,
 
 	mutex_lock(&regulator_list_mutex);
 
-	rdev = regulator_dev_lookup(dev, id);
+	rdev = regulator_dev_lookup(dev, id, &ret);
 	if (rdev)
 		goto found;
 
@@ -2926,7 +2936,7 @@ struct regulator_dev *regulator_register(struct regulator_desc *regulator_desc,
 	if (supply) {
 		struct regulator_dev *r;
 
-		r = regulator_dev_lookup(dev, supply);
+		r = regulator_dev_lookup(dev, supply, &ret);
 
 		if (!r) {
 			dev_err(dev, "Failed to find supply %s\n", supply);

commit 01e86f4988297abb403be92bc3b6ad24e1d058de
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Mar 28 21:36:38 2012 +0100

    regulator: core: Complain if we can't reenable a supply
    
    When cleaning up after a failed bulk_disable() we try to reenable any
    supplies that we did manage to disable - complain if we fail to do that
    when we try.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index c056abd7562a..fe28481dc91c 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2566,7 +2566,7 @@ int regulator_bulk_disable(int num_consumers,
 			   struct regulator_bulk_data *consumers)
 {
 	int i;
-	int ret;
+	int ret, r;
 
 	for (i = num_consumers - 1; i >= 0; --i) {
 		ret = regulator_disable(consumers[i].consumer);
@@ -2578,8 +2578,12 @@ int regulator_bulk_disable(int num_consumers,
 
 err:
 	pr_err("Failed to disable %s: %d\n", consumers[i].supply, ret);
-	for (++i; i < num_consumers; ++i)
-		regulator_enable(consumers[i].consumer);
+	for (++i; i < num_consumers; ++i) {
+		r = regulator_enable(consumers[i].consumer);
+		if (r != 0)
+			pr_err("Failed to reename %s: %d\n",
+			       consumers[i].supply, r);
+	}
 
 	return ret;
 }

commit e032b376551a61662b20a2c8544fbbc568ab2e7f
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Mar 28 21:17:55 2012 +0100

    regulator: Fix deadlock on removal of regulators with supplies
    
    If a regulator with a supply is being unregistered we will call
    regulator_put() to release the supply with the regulator_list_mutex held
    but this deadlocks as regulator_put() takes the same lock. Fix this by
    releasing the supply before we take the mutex in regulator_unregister().
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index e2f3afa71efb..4a5054ef9421 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2992,14 +2992,14 @@ void regulator_unregister(struct regulator_dev *rdev)
 	if (rdev == NULL)
 		return;
 
+	if (rdev->supply)
+		regulator_put(rdev->supply);
 	mutex_lock(&regulator_list_mutex);
 	debugfs_remove_recursive(rdev->debugfs);
 	flush_work_sync(&rdev->disable_work.work);
 	WARN_ON(rdev->open_count);
 	unset_regulator_supplies(rdev);
 	list_del(&rdev->list);
-	if (rdev->supply)
-		regulator_put(rdev->supply);
 	kfree(rdev->constraints);
 	device_unregister(&rdev->dev);
 	mutex_unlock(&regulator_list_mutex);

commit d15d76448bb58c7832e954b6a8f1e301720b7866
Merge: 0c2fe82a9b10 4992fa1fd425
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Mar 21 10:34:56 2012 -0700

    Merge tag 'regulator-3.4' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/regulator
    
    Pull regulator updates for 3.4 from Mark Brown:
     "This has been a fairly quiet release from a regulator point of view,
      the only real framework features added were devm support and a
      convenience helper for setting up fixed voltage regulators.
    
      We also added a couple of drivers (but will drop the BQ240022 driver
      via the arm-soc tree as it's been replaced by the more generic
      gpio-regulator driver) and Axel Lin continued his relentless and
      generally awesome stream of fixes and cleanups."
    
    * tag 'regulator-3.4' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/regulator: (93 commits)
      regulator: Fix up a confusing dev_warn when DT lookup fails
      regulator: Convert tps6507x to set_voltage_sel
      regulator: Refactor tps6507x to use one tps6507x_pmic_ops for all LDOs and DCDCs
      regulator: Make s5m8767_get_voltage_register always return correct register
      regulator: s5m8767: Check pdata->buck[2|3|4]_gpiodvs earlier
      regulator: tps65910: Provide settling time for DCDC voltage change
      regulator: Add Anatop regulator driver
      regulator: Simplify implementation of tps65912_get_voltage_dcdc
      regulator: Use tps65912_set_voltage_sel for both DCDCx and LDOx
      regulator: tps65910: Provide settling time for enabling rails
      regulator: max8925: Use DIV_ROUND_UP macro
      regulator: tps65912: Use simple equations to get register address
      regulator: Fix the logic of tps65910_get_mode
      regulator: Merge tps65217_pmic_ldo234_ops and tps65217_pmic_dcdc_ops to tps65217_pmic_ops
      regulator: Use DIV_ROUND_CLOSEST in wm8350_isink_get_current
      regulator: Use array to store dcdc_range settings for tps65912
      regulator: Rename s5m8767_convert_voltage to s5m8767_convert_voltage_to_sel
      regulator: tps6524x: Remove unneeded comment for N_REGULATORS
      regulator: Rename set_voltage_sel callback function name to *_sel
      regulator: Fix s5m8767_set_voltage_time_sel calculation value
      ...

commit 115e4bfd5bc68f870b3c889ab8f2d2733bcda452
Merge: c02f935f5f64 5bc78015998e
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Sun Mar 18 21:39:19 2012 +0000

    Merge remote-tracking branch 'regulator/topic/supply' into regulator-next

commit c02f935f5f646fe1b5dbcd909e9d09c3a912914e
Merge: c592c761a362 c1432b1ebc68
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Sun Mar 18 21:38:28 2012 +0000

    Merge remote-tracking branches 'regulator/topic/devm' and 'regulator/topic/stub' into regulator-next

commit c592c761a36286ab83451daa37a21c8558ea99c0
Merge: 63236f4038f7 33499df88b71
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Sun Mar 18 21:38:20 2012 +0000

    Merge remote-tracking branch 'regulator/topic/stub' into regulator-next

commit 16fbcc3b1139e90fe560fde5619169db74dc02c2
Author: Rajendra Nayak <rnayak@ti.com>
Date:   Fri Mar 16 15:50:21 2012 +0530

    regulator: Fix up a confusing dev_warn when DT lookup fails
    
    of_parse_phandle() returns NULL either if the property name
    itself does not exist or if it (exists and) does not
    reference a valid phandle.
    Giving out a warn like the one below (that the property references
    an invalid phandle) can be confusing when the property itself
    does not exist in the node.
    Fix it with a more sensible message and make it a dev_dbg instead
    of a dev_warn.
    
    Reported-by: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Signed-off-by: Rajendra Nayak <rnayak@ti.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index b97c4a256636..fc4ccf880cbc 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -148,7 +148,7 @@ static struct device_node *of_get_regulator(struct device *dev, const char *supp
 	regnode = of_parse_phandle(dev->of_node, prop_name, 0);
 
 	if (!regnode) {
-		dev_warn(dev, "%s property in node %s references invalid phandle",
+		dev_dbg(dev, "Looking up %s property in node %s failed",
 				prop_name, dev->of_node->full_name);
 		return NULL;
 	}

commit 04bf30115f4ba2beda1efb6cfbae49cdc757f3a9
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Sun Mar 11 13:07:56 2012 +0000

    regulator: Support driver probe deferral
    
    If we fail to locate a requested regulator return -EPROBE_DEFER. If drivers
    pass this error code through to their caller (which they really should)
    then this will ensure that the probe is retried later when further devices
    become available.  In the unusual case where a driver doesn't want this
    it can override the default behaviour.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Grant Likely <grant.likely@secretlab.ca>
    Acked-by: Liam Girdwood <lrg@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index e9a83f84adaf..fcde037b3461 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1210,7 +1210,7 @@ static struct regulator *_regulator_get(struct device *dev, const char *id,
 {
 	struct regulator_dev *rdev;
 	struct regulator_map *map;
-	struct regulator *regulator = ERR_PTR(-ENODEV);
+	struct regulator *regulator = ERR_PTR(-EPROBE_DEFER);
 	const char *devname = NULL;
 	int ret;
 
@@ -2834,7 +2834,7 @@ struct regulator_dev *regulator_register(struct regulator_desc *regulator_desc,
 
 		if (!r) {
 			dev_err(dev, "Failed to find supply %s\n", supply);
-			ret = -ENODEV;
+			ret = -EPROBE_DEFER;
 			goto scrub;
 		}
 

commit 073512336e6333ffcaabbb2b92f8e616db3a0789
Author: Axel Lin <axel.lin@gmail.com>
Date:   Fri Feb 24 23:13:19 2012 +0800

    regulator: Set delay to 0 if set_voltage_time_sel callback returns error
    
    rdev->desc->ops->set_voltage_time_sel may return negative error code.
    Set delay to 0 and also show warning if set_voltage_time_sel returns error.
    
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 603e39f81ce0..b97c4a256636 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1836,8 +1836,12 @@ static int _regulator_do_set_voltage(struct regulator_dev *rdev,
 			if (ret < 0)
 				return ret;
 			old_selector = ret;
-			delay = rdev->desc->ops->set_voltage_time_sel(rdev,
+			ret = rdev->desc->ops->set_voltage_time_sel(rdev,
 						old_selector, selector);
+			if (ret < 0)
+				rdev_warn(rdev, "set_voltage_time_sel() failed: %d\n", ret);
+			else
+				delay = ret;
 		}
 
 		if (best_val != INT_MAX) {

commit 247514344492a0cf602317d2089bab1301922624
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Mon Feb 20 22:50:42 2012 -0800

    regulator: Remove ifdefs for debugfs code
    
    If CONFIG_DEBUG_FS=y debugfs functions will never return an
    ERR_PTR. Instead they'll return NULL. The intent is to remove
    ifdefs in calling code.
    
    Update the code to reflect this. We gain an extra dentry pointer
    per struct regulator and struct regulator_dev but that should be
    ok because most distros have debugfs compiled in anyway.
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 81ea66dcca9c..603e39f81ce0 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -52,9 +52,7 @@ static LIST_HEAD(regulator_map_list);
 static bool has_full_constraints;
 static bool board_wants_dummy_regulator;
 
-#ifdef CONFIG_DEBUG_FS
 static struct dentry *debugfs_root;
-#endif
 
 /*
  * struct regulator_map
@@ -82,9 +80,7 @@ struct regulator {
 	char *supply_name;
 	struct device_attribute dev_attr;
 	struct regulator_dev *rdev;
-#ifdef CONFIG_DEBUG_FS
 	struct dentry *debugfs;
-#endif
 };
 
 static int _regulator_is_enabled(struct regulator_dev *rdev);
@@ -1145,12 +1141,10 @@ static struct regulator *create_regulator(struct regulator_dev *rdev,
 			goto attr_err;
 	}
 
-#ifdef CONFIG_DEBUG_FS
 	regulator->debugfs = debugfs_create_dir(regulator->supply_name,
 						rdev->debugfs);
-	if (IS_ERR_OR_NULL(regulator->debugfs)) {
+	if (!regulator->debugfs) {
 		rdev_warn(rdev, "Failed to create debugfs directory\n");
-		regulator->debugfs = NULL;
 	} else {
 		debugfs_create_u32("uA_load", 0444, regulator->debugfs,
 				   &regulator->uA_load);
@@ -1159,7 +1153,6 @@ static struct regulator *create_regulator(struct regulator_dev *rdev,
 		debugfs_create_u32("max_uV", 0444, regulator->debugfs,
 				   &regulator->max_uV);
 	}
-#endif
 
 	mutex_unlock(&rdev->mutex);
 	return regulator;
@@ -1368,9 +1361,7 @@ void regulator_put(struct regulator *regulator)
 	mutex_lock(&regulator_list_mutex);
 	rdev = regulator->rdev;
 
-#ifdef CONFIG_DEBUG_FS
 	debugfs_remove_recursive(regulator->debugfs);
-#endif
 
 	/* remove any sysfs entries */
 	if (regulator->dev) {
@@ -2710,11 +2701,9 @@ static int add_regulator_attributes(struct regulator_dev *rdev)
 
 static void rdev_init_debugfs(struct regulator_dev *rdev)
 {
-#ifdef CONFIG_DEBUG_FS
 	rdev->debugfs = debugfs_create_dir(rdev_get_name(rdev), debugfs_root);
-	if (IS_ERR_OR_NULL(rdev->debugfs)) {
+	if (!rdev->debugfs) {
 		rdev_warn(rdev, "Failed to create debugfs directory\n");
-		rdev->debugfs = NULL;
 		return;
 	}
 
@@ -2722,7 +2711,6 @@ static void rdev_init_debugfs(struct regulator_dev *rdev)
 			   &rdev->use_count);
 	debugfs_create_u32("open_count", 0444, rdev->debugfs,
 			   &rdev->open_count);
-#endif
 }
 
 /**
@@ -2900,9 +2888,7 @@ void regulator_unregister(struct regulator_dev *rdev)
 		return;
 
 	mutex_lock(&regulator_list_mutex);
-#ifdef CONFIG_DEBUG_FS
 	debugfs_remove_recursive(rdev->debugfs);
-#endif
 	flush_work_sync(&rdev->disable_work.work);
 	WARN_ON(rdev->open_count);
 	unset_regulator_supplies(rdev);
@@ -3112,12 +3098,14 @@ static ssize_t supply_map_read_file(struct file *file, char __user *user_buf,
 
 	return ret;
 }
+#endif
 
 static const struct file_operations supply_map_fops = {
+#ifdef CONFIG_DEBUG_FS
 	.read = supply_map_read_file,
 	.llseek = default_llseek,
-};
 #endif
+};
 
 static int __init regulator_init(void)
 {
@@ -3125,16 +3113,12 @@ static int __init regulator_init(void)
 
 	ret = class_register(&regulator_class);
 
-#ifdef CONFIG_DEBUG_FS
 	debugfs_root = debugfs_create_dir("regulator", NULL);
-	if (IS_ERR_OR_NULL(debugfs_root)) {
+	if (!debugfs_root)
 		pr_warn("regulator: Failed to create debugfs directory\n");
-		debugfs_root = NULL;
-	}
 
 	debugfs_create_file("supply_map", 0444, debugfs_root, NULL,
 			    &supply_map_fops);
-#endif
 
 	regulator_dummy_init();
 

commit f4d562c6e616bb686f43d38752b2e5b83359e1fc
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Feb 20 21:01:04 2012 +0000

    regulator: Clean up debugfs error handling a bit
    
    Use IS_ERR_OR_NULL() rather than open coding it and ignore errors from
    failure to create the supply map.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 6c845200a530..81ea66dcca9c 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2712,7 +2712,7 @@ static void rdev_init_debugfs(struct regulator_dev *rdev)
 {
 #ifdef CONFIG_DEBUG_FS
 	rdev->debugfs = debugfs_create_dir(rdev_get_name(rdev), debugfs_root);
-	if (IS_ERR(rdev->debugfs) || !rdev->debugfs) {
+	if (IS_ERR_OR_NULL(rdev->debugfs)) {
 		rdev_warn(rdev, "Failed to create debugfs directory\n");
 		rdev->debugfs = NULL;
 		return;
@@ -3127,14 +3127,13 @@ static int __init regulator_init(void)
 
 #ifdef CONFIG_DEBUG_FS
 	debugfs_root = debugfs_create_dir("regulator", NULL);
-	if (IS_ERR(debugfs_root) || !debugfs_root) {
+	if (IS_ERR_OR_NULL(debugfs_root)) {
 		pr_warn("regulator: Failed to create debugfs directory\n");
 		debugfs_root = NULL;
 	}
 
-	if (IS_ERR(debugfs_create_file("supply_map", 0444, debugfs_root,
-				       NULL, &supply_map_fops)))
-		pr_warn("regulator: Failed to create supplies debugfs\n");
+	debugfs_create_file("supply_map", 0444, debugfs_root, NULL,
+			    &supply_map_fops);
 #endif
 
 	regulator_dummy_init();

commit b29c7690a764b9829b1034f873f97b7bbfa19565
Author: Axel Lin <axel.lin@gmail.com>
Date:   Mon Feb 20 10:32:16 2012 +0800

    regulator: Simplify regulator_bulk_get and regulator_bulk_enable error paths
    
    Start unwind from the point the error happens instead of iterating over all
    consumers, then unwind code can be simpler.
    
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 9a143aebb84b..6c845200a530 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2397,7 +2397,7 @@ int regulator_bulk_get(struct device *dev, int num_consumers,
 	return 0;
 
 err:
-	for (i = 0; i < num_consumers && consumers[i].consumer; i++)
+	while (--i >= 0)
 		regulator_put(consumers[i].consumer);
 
 	return ret;
@@ -2447,12 +2447,9 @@ int regulator_bulk_enable(int num_consumers,
 	return 0;
 
 err:
-	for (i = 0; i < num_consumers; i++)
-		if (consumers[i].ret == 0)
-			regulator_disable(consumers[i].consumer);
-		else
-			pr_err("Failed to enable %s: %d\n",
-			       consumers[i].supply, consumers[i].ret);
+	pr_err("Failed to enable %s: %d\n", consumers[i].supply, ret);
+	while (--i >= 0)
+		regulator_disable(consumers[i].consumer);
 
 	return ret;
 }

commit 5bc78015998e14bf0362a01fc47e8b63053dbfd8
Author: Axel Lin <axel.lin@gmail.com>
Date:   Sat Feb 18 22:53:15 2012 +0800

    regulator: Remove obsolete consumer_dev related comment
    
    consumer_dev is remove by commit 737f36
    "regulator: Remove support for supplies specified by struct device".
    Thus remove the obsolete comment.
    
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index b9c900e81790..645c122bb5bc 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1003,8 +1003,6 @@ static int set_supply(struct regulator_dev *rdev,
  * sources to symbolic names for supplies for use by devices.  Devices
  * should use these symbolic names to request regulators, avoiding the
  * need to provide board-specific regulator names as platform data.
- *
- * Only one of consumer_dev and consumer_dev_name may be specified.
  */
 static int set_consumer_device_supply(struct regulator_dev *rdev,
 				      const char *consumer_dev_name,

commit 4a682922817fde4d82fed4303dc902c29d7b2e4e
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Thu Feb 9 13:26:13 2012 +0000

    regulator: Complain if a voltage range is specified but can't be used
    
    It doesn't make much sense to specify a range of voltages consumers can
    use if they haven't been given permission to change the voltage. Log if
    this happens, probably the user forgot to specify CHANGE_VOLTAGE.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@ti.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index e3271daa3ab9..9a143aebb84b 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -805,6 +805,11 @@ static void print_constraints(struct regulator_dev *rdev)
 		count += sprintf(buf + count, "standby");
 
 	rdev_info(rdev, "%s\n", buf);
+
+	if ((constraints->min_uV != constraints->max_uV) &&
+	    !(constraints->valid_ops_mask & REGULATOR_CHANGE_VOLTAGE))
+		rdev_warn(rdev,
+			  "Voltage range but no REGULATOR_CHANGE_VOLTAGE\n");
 }
 
 static int machine_constraints_voltage(struct regulator_dev *rdev,

commit 43f674a322aa8a3404df5785f84dc1351a5d84b6
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Thu Feb 9 13:08:39 2012 +0000

    regulator: Don't add the function name to pr_fmt
    
    Liam pointed out via IM that since we now use the pure function name for
    all regulator logging a lot of the messages such as those logging the
    constraints are getting a bit noisy due to the implementation detail
    that is the function name:
    
    print_constraints: VDDARM: 1000 <--> 1300 mV at 1300 mV at 0 mA
    
    In discussion it seemed like the best thing was to just drop the pr_fmt
    and clarify individual log messages where there is an issue otherwise
    we get into silly things like renaming the functions to suit the logging.
    
    This is mostly an issue as we have a moderate amount of non-error logging
    in the boot sequence to aid debug if something goes wrong since regulator
    misconfiguration can kill the system pretty quickly.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@ti.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index daba2f60f7d9..e3271daa3ab9 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -13,8 +13,6 @@
  *
  */
 
-#define pr_fmt(fmt) "%s: " fmt, __func__
-
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/debugfs.h>

commit 737f360d5bef5e01c6cfa755dca0b449a154c1e0
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Thu Feb 2 00:10:51 2012 +0000

    regulator: Remove support for supplies specified by struct device
    
    This has been deprecated for a very long time now.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Liam Girdwood <lrg@ti.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index e9a83f84adaf..b9c900e81790 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -996,7 +996,6 @@ static int set_supply(struct regulator_dev *rdev,
 /**
  * set_consumer_device_supply - Bind a regulator to a symbolic supply
  * @rdev:         regulator source
- * @consumer_dev: device the supply applies to
  * @consumer_dev_name: dev_name() string for device supply applies to
  * @supply:       symbolic name for supply
  *
@@ -1008,18 +1007,12 @@ static int set_supply(struct regulator_dev *rdev,
  * Only one of consumer_dev and consumer_dev_name may be specified.
  */
 static int set_consumer_device_supply(struct regulator_dev *rdev,
-	struct device *consumer_dev, const char *consumer_dev_name,
-	const char *supply)
+				      const char *consumer_dev_name,
+				      const char *supply)
 {
 	struct regulator_map *node;
 	int has_dev;
 
-	if (consumer_dev && consumer_dev_name)
-		return -EINVAL;
-
-	if (!consumer_dev_name && consumer_dev)
-		consumer_dev_name = dev_name(consumer_dev);
-
 	if (supply == NULL)
 		return -EINVAL;
 
@@ -1039,11 +1032,12 @@ static int set_consumer_device_supply(struct regulator_dev *rdev,
 		if (strcmp(node->supply, supply) != 0)
 			continue;
 
-		dev_dbg(consumer_dev, "%s/%s is '%s' supply; fail %s/%s\n",
-			dev_name(&node->regulator->dev),
-			node->regulator->desc->name,
-			supply,
-			dev_name(&rdev->dev), rdev_get_name(rdev));
+		pr_debug("%s: %s/%s is '%s' supply; fail %s/%s\n",
+			 consumer_dev_name,
+			 dev_name(&node->regulator->dev),
+			 node->regulator->desc->name,
+			 supply,
+			 dev_name(&rdev->dev), rdev_get_name(rdev));
 		return -EBUSY;
 	}
 
@@ -2855,7 +2849,6 @@ struct regulator_dev *regulator_register(struct regulator_desc *regulator_desc,
 	if (init_data) {
 		for (i = 0; i < init_data->num_consumer_supplies; i++) {
 			ret = set_consumer_device_supply(rdev,
-				init_data->consumer_supplies[i].dev,
 				init_data->consumer_supplies[i].dev_name,
 				init_data->consumer_supplies[i].supply);
 			if (ret < 0) {

commit 49e226323d462785582750d9f38acca5ffa5dd48
Author: Sylwester Nawrocki <s.nawrocki@samsung.com>
Date:   Wed Jan 25 12:35:38 2012 +0100

    regulator: Reverse the disable sequence in regulator_bulk_disable()
    
    Often there is a need for disabling a set of regulators in order opposite
    to the enable order. Currently the function regulator_bulk_disable() walks
    list of regulators in same order as regulator_bulk_enable(). This may cause
    trouble, especially for devices with mixed analogue and digital circuits.
    So reverse the disabling sequence of regulator_bulk_disable().
    While at it, also correct the comment.
    
    Signed-off-by: Sylwester Nawrocki <s.nawrocki@samsung.com>
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index ca86f39a0fdc..daba2f60f7d9 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2463,8 +2463,8 @@ EXPORT_SYMBOL_GPL(regulator_bulk_enable);
  * @return         0 on success, an errno on failure
  *
  * This convenience API allows consumers to disable multiple regulator
- * clients in a single API call.  If any consumers cannot be enabled
- * then any others that were disabled will be disabled again prior to
+ * clients in a single API call.  If any consumers cannot be disabled
+ * then any others that were disabled will be enabled again prior to
  * return.
  */
 int regulator_bulk_disable(int num_consumers,
@@ -2473,7 +2473,7 @@ int regulator_bulk_disable(int num_consumers,
 	int i;
 	int ret;
 
-	for (i = 0; i < num_consumers; i++) {
+	for (i = num_consumers - 1; i >= 0; --i) {
 		ret = regulator_disable(consumers[i].consumer);
 		if (ret != 0)
 			goto err;
@@ -2483,7 +2483,7 @@ int regulator_bulk_disable(int num_consumers,
 
 err:
 	pr_err("Failed to disable %s: %d\n", consumers[i].supply, ret);
-	for (--i; i >= 0; --i)
+	for (++i; i < num_consumers; ++i)
 		regulator_enable(consumers[i].consumer);
 
 	return ret;

commit 4a7cbb56fdbd92a47f57ca8b25bf5db35f0d6518
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Jan 24 11:17:26 2012 +0000

    regulator: Fix documentation for of_node parameter of regulator_register()
    
    Commit 5bc75a886353 ("kernel-doc: fix new warning in regulator core")
    added documentation for of_node to address a warning but the
    documentation didn't explain what the parameter is for so would be
    likely to be unhelpful for users.  Clarify that.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index b1fa25d6583a..e9a83f84adaf 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2731,7 +2731,8 @@ static void rdev_init_debugfs(struct regulator_dev *rdev)
  * @dev: struct device for the regulator
  * @init_data: platform provided init data, passed through by driver
  * @driver_data: private regulator data
- * @of_node: target open firmware device structure (may be NULL)
+ * @of_node: OpenFirmware node to parse for device tree bindings (may be
+ *           NULL).
  *
  * Called by regulator drivers to register a regulator.
  * Returns 0 on success.

commit 5bc75a886353fa5f386c5ce49a93da1756006d8f
Author: Randy Dunlap <rdunlap@xenotime.net>
Date:   Sat Jan 21 11:02:38 2012 -0800

    kernel-doc: fix new warning in regulator core
    
    Fix new kernel-doc warning:
    
    Warning(drivers/regulator/core.c:2741): No description found for parameter 'of_node'
    
    Signed-off-by: Randy Dunlap <rdunlap@xenotime.net>
    Cc:     Liam Girdwood <lrg@ti.com>
    Cc:     Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index ca86f39a0fdc..b1fa25d6583a 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2731,6 +2731,7 @@ static void rdev_init_debugfs(struct regulator_dev *rdev)
  * @dev: struct device for the regulator
  * @init_data: platform provided init data, passed through by driver
  * @driver_data: private regulator data
+ * @of_node: target open firmware device structure (may be NULL)
  *
  * Called by regulator drivers to register a regulator.
  * Returns 0 on success.

commit e6e740304aa2a49ef09497e6c0bb906ed7987f6b
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Fri Jan 20 20:10:08 2012 +0000

    regulator: Provide devm_regulator_bulk_get()
    
    Allow drivers to benefit from both the bulk APIs and managed resources
    simultaneously.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 88bcb111ca68..1432c22926b5 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2463,6 +2463,52 @@ int regulator_bulk_get(struct device *dev, int num_consumers,
 }
 EXPORT_SYMBOL_GPL(regulator_bulk_get);
 
+/**
+ * devm_regulator_bulk_get - managed get multiple regulator consumers
+ *
+ * @dev:           Device to supply
+ * @num_consumers: Number of consumers to register
+ * @consumers:     Configuration of consumers; clients are stored here.
+ *
+ * @return 0 on success, an errno on failure.
+ *
+ * This helper function allows drivers to get several regulator
+ * consumers in one operation with management, the regulators will
+ * automatically be freed when the device is unbound.  If any of the
+ * regulators cannot be acquired then any regulators that were
+ * allocated will be freed before returning to the caller.
+ */
+int devm_regulator_bulk_get(struct device *dev, int num_consumers,
+			    struct regulator_bulk_data *consumers)
+{
+	int i;
+	int ret;
+
+	for (i = 0; i < num_consumers; i++)
+		consumers[i].consumer = NULL;
+
+	for (i = 0; i < num_consumers; i++) {
+		consumers[i].consumer = devm_regulator_get(dev,
+							   consumers[i].supply);
+		if (IS_ERR(consumers[i].consumer)) {
+			ret = PTR_ERR(consumers[i].consumer);
+			dev_err(dev, "Failed to get supply '%s': %d\n",
+				consumers[i].supply, ret);
+			consumers[i].consumer = NULL;
+			goto err;
+		}
+	}
+
+	return 0;
+
+err:
+	for (i = 0; i < num_consumers && consumers[i].consumer; i++)
+		devm_regulator_put(consumers[i].consumer);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(devm_regulator_bulk_get);
+
 static void regulator_bulk_enable_async(void *data, async_cookie_t cookie)
 {
 	struct regulator_bulk_data *bulk = data;

commit d5ad34f7cb8b23ab165cabef69577a2a20d53195
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Fri Jan 20 20:09:18 2012 +0000

    regulator: Implement devm_regulator_free()
    
    Allow consumers to free regulators allocated using devm_regulator_get()
    if they need to. This will not normally be required.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 214640db084b..88bcb111ca68 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1421,6 +1421,34 @@ void regulator_put(struct regulator *regulator)
 }
 EXPORT_SYMBOL_GPL(regulator_put);
 
+static int devm_regulator_match(struct device *dev, void *res, void *data)
+{
+	struct regulator **r = res;
+	if (!r || !*r) {
+		WARN_ON(!r || !*r);
+		return 0;
+	}
+	return *r == data;
+}
+
+/**
+ * devm_regulator_put - Resource managed regulator_put()
+ * @regulator: regulator to free
+ *
+ * Deallocate a regulator allocated with devm_regulator_get(). Normally
+ * this function will not need to be called and the resource management
+ * code will ensure that the resource is freed.
+ */
+void devm_regulator_put(struct regulator *regulator)
+{
+	int rc;
+
+	rc = devres_destroy(regulator->dev, devm_regulator_release,
+			    devm_regulator_match, regulator);
+	WARN_ON(rc);
+}
+EXPORT_SYMBOL_GPL(devm_regulator_put);
+
 static int _regulator_can_change_status(struct regulator_dev *rdev)
 {
 	if (!rdev->constraints)

commit 070b9079226d4f3e3e7c9f4eb81f2e02e7d99572
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Mon Jan 16 19:39:58 2012 -0800

    regulator: Add devm_regulator_get()
    
    Add a resource managed regulator_get() to simplify regulator
    usage in drivers. This allows driver authors to "get and forget"
    about their regulators by automatically calling regulator_put()
    when the driver is detached.
    
    [Fixed up a couple of coding style issues -- broonie]
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index ca86f39a0fdc..214640db084b 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1320,6 +1320,40 @@ struct regulator *regulator_get(struct device *dev, const char *id)
 }
 EXPORT_SYMBOL_GPL(regulator_get);
 
+static void devm_regulator_release(struct device *dev, void *res)
+{
+	regulator_put(*(struct regulator **)res);
+}
+
+/**
+ * devm_regulator_get - Resource managed regulator_get()
+ * @dev: device for regulator "consumer"
+ * @id: Supply name or regulator ID.
+ *
+ * Managed regulator_get(). Regulators returned from this function are
+ * automatically regulator_put() on driver detach. See regulator_get() for more
+ * information.
+ */
+struct regulator *devm_regulator_get(struct device *dev, const char *id)
+{
+	struct regulator **ptr, *regulator;
+
+	ptr = devres_alloc(devm_regulator_release, sizeof(*ptr), GFP_KERNEL);
+	if (!ptr)
+		return ERR_PTR(-ENOMEM);
+
+	regulator = regulator_get(dev, id);
+	if (!IS_ERR(regulator)) {
+		*ptr = regulator;
+		devres_add(dev, ptr);
+	} else {
+		devres_free(ptr);
+	}
+
+	return regulator;
+}
+EXPORT_SYMBOL_GPL(devm_regulator_get);
+
 /**
  * regulator_get_exclusive - obtain exclusive access to a regulator.
  * @dev: device for regulator "consumer"

commit e1de2f423462a5c6ba2c902dff1f5ddd8d3dbde3
Author: Donggeun Kim <dg77.kim@samsung.com>
Date:   Tue Jan 3 16:22:03 2012 +0900

    regulator: add regulator_bulk_force_disable function
    
    This patch allows consumers to forcibly disable multiple regulator
    clients in a single API call.
    
    Signed-off-by: Donggeun Kim <dg77.kim@samsung.com>
    Signed-off-by: MyungJoo Ham <myungjoo.ham@samsung.com>
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index eb750a1ed7fe..ca86f39a0fdc 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2490,6 +2490,43 @@ int regulator_bulk_disable(int num_consumers,
 }
 EXPORT_SYMBOL_GPL(regulator_bulk_disable);
 
+/**
+ * regulator_bulk_force_disable - force disable multiple regulator consumers
+ *
+ * @num_consumers: Number of consumers
+ * @consumers:     Consumer data; clients are stored here.
+ * @return         0 on success, an errno on failure
+ *
+ * This convenience API allows consumers to forcibly disable multiple regulator
+ * clients in a single API call.
+ * NOTE: This should be used for situations when device damage will
+ * likely occur if the regulators are not disabled (e.g. over temp).
+ * Although regulator_force_disable function call for some consumers can
+ * return error numbers, the function is called for all consumers.
+ */
+int regulator_bulk_force_disable(int num_consumers,
+			   struct regulator_bulk_data *consumers)
+{
+	int i;
+	int ret;
+
+	for (i = 0; i < num_consumers; i++)
+		consumers[i].ret =
+			    regulator_force_disable(consumers[i].consumer);
+
+	for (i = 0; i < num_consumers; i++) {
+		if (consumers[i].ret != 0) {
+			ret = consumers[i].ret;
+			goto out;
+		}
+	}
+
+	return 0;
+out:
+	return ret;
+}
+EXPORT_SYMBOL_GPL(regulator_bulk_force_disable);
+
 /**
  * regulator_bulk_free - free multiple regulator consumers
  *

commit b2296bd43e781976743354c668a356b0df98e1da
Author: Laxman Dewangan <ldewangan@nvidia.com>
Date:   Mon Jan 2 13:08:45 2012 +0530

    regulator: Enable supply regulator if child rail is enabled.
    
    During regulator_register, the rail is set on the provided
    machine constraints and if it is enabled then it is also
    require to enable the supply regulator. This will make sure
    that:
       1. Proper reference count for supply regulator to be maintain.
       2. Supply regulator should be enable when given rail is enabled.
    
    Signed-off-by: Laxman Dewangan <ldewangan@nvidia.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index e70e15c4aa28..eb750a1ed7fe 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2802,6 +2802,14 @@ struct regulator_dev *regulator_register(struct regulator_desc *regulator_desc,
 		ret = set_supply(rdev, r);
 		if (ret < 0)
 			goto scrub;
+
+		/* Enable supply if rail is enabled */
+		if (rdev->desc->ops->is_enabled &&
+				rdev->desc->ops->is_enabled(rdev)) {
+			ret = regulator_enable(rdev->supply);
+			if (ret < 0)
+				goto scrub;
+		}
 	}
 
 	/* add consumers devices */

commit 32c78de8f17369def492ea3ddd785f0cc140af02
Author: Axel Lin <axel.lin@gmail.com>
Date:   Thu Dec 29 17:03:20 2011 +0800

    regulator: Fix checking return value of create_regulator
    
    create_regulator() returns NULL on fail.
    
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 6cb9d399affd..e70e15c4aa28 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -985,9 +985,8 @@ static int set_supply(struct regulator_dev *rdev,
 	rdev_info(rdev, "supplied by %s\n", rdev_get_name(supply_rdev));
 
 	rdev->supply = create_regulator(supply_rdev, &rdev->dev, "SUPPLY");
-	if (IS_ERR(rdev->supply)) {
-		err = PTR_ERR(rdev->supply);
-		rdev->supply = NULL;
+	if (rdev->supply == NULL) {
+		err = -ENOMEM;
 		return err;
 	}
 

commit bcda432194fc7c4a2dbe9d7146f00b4b21e66c8c
Author: Axel Lin <axel.lin@gmail.com>
Date:   Thu Dec 29 17:02:08 2011 +0800

    regulator: Fix the error handling if create_regulator fails
    
    In the case of create_regulator() fails, goto the error path immediately.
    It does not make sense to update rdev->open_count if create_regulator fails.
    
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 6f7d411b048b..6cb9d399affd 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1282,6 +1282,7 @@ static struct regulator *_regulator_get(struct device *dev, const char *id,
 	if (regulator == NULL) {
 		regulator = ERR_PTR(-ENOMEM);
 		module_put(rdev->owner);
+		goto out;
 	}
 
 	rdev->open_count++;

commit a398eaa23e42b73216efbe03dc1d754b2e5d603c
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Dec 28 12:48:45 2011 +0000

    regulator: Export regulator_is_supported_voltage()
    
    It's part of the driver interface so should be available to modules.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index dbdebed660bf..6f7d411b048b 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1787,6 +1787,7 @@ int regulator_is_supported_voltage(struct regulator *regulator,
 
 	return 0;
 }
+EXPORT_SYMBOL_GPL(regulator_is_supported_voltage);
 
 static int _regulator_do_set_voltage(struct regulator_dev *rdev,
 				     int min_uV, int max_uV)

commit 9a8f5e07200dd80fe5979490c36b62f64f70825b
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Nov 29 18:11:19 2011 +0000

    regulator: Allow regulators to register with no init_data
    
    This allows read-only access to the device configuration which may be
    useful for diagnostics.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@ti.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index ca2efca00734..dbdebed660bf 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -912,8 +912,12 @@ static int set_machine_constraints(struct regulator_dev *rdev,
 	int ret = 0;
 	struct regulator_ops *ops = rdev->desc->ops;
 
-	rdev->constraints = kmemdup(constraints, sizeof(*constraints),
-				    GFP_KERNEL);
+	if (constraints)
+		rdev->constraints = kmemdup(constraints, sizeof(*constraints),
+					    GFP_KERNEL);
+	else
+		rdev->constraints = kzalloc(sizeof(*constraints),
+					    GFP_KERNEL);
 	if (!rdev->constraints)
 		return -ENOMEM;
 
@@ -922,7 +926,7 @@ static int set_machine_constraints(struct regulator_dev *rdev,
 		goto out;
 
 	/* do we need to setup our suspend state */
-	if (constraints->initial_state) {
+	if (rdev->constraints->initial_state) {
 		ret = suspend_prepare(rdev, rdev->constraints->initial_state);
 		if (ret < 0) {
 			rdev_err(rdev, "failed to set suspend state\n");
@@ -930,7 +934,7 @@ static int set_machine_constraints(struct regulator_dev *rdev,
 		}
 	}
 
-	if (constraints->initial_mode) {
+	if (rdev->constraints->initial_mode) {
 		if (!ops->set_mode) {
 			rdev_err(rdev, "no set_mode operation\n");
 			ret = -EINVAL;
@@ -2697,6 +2701,7 @@ struct regulator_dev *regulator_register(struct regulator_desc *regulator_desc,
 	struct device *dev, const struct regulator_init_data *init_data,
 	void *driver_data, struct device_node *of_node)
 {
+	const struct regulation_constraints *constraints = NULL;
 	static atomic_t regulator_no = ATOMIC_INIT(0);
 	struct regulator_dev *rdev;
 	int ret, i;
@@ -2712,9 +2717,6 @@ struct regulator_dev *regulator_register(struct regulator_desc *regulator_desc,
 	    regulator_desc->type != REGULATOR_CURRENT)
 		return ERR_PTR(-EINVAL);
 
-	if (!init_data)
-		return ERR_PTR(-EINVAL);
-
 	/* Only one of each should be implemented */
 	WARN_ON(regulator_desc->ops->get_voltage &&
 		regulator_desc->ops->get_voltage_sel);
@@ -2747,7 +2749,7 @@ struct regulator_dev *regulator_register(struct regulator_desc *regulator_desc,
 	INIT_DELAYED_WORK(&rdev->disable_work, regulator_disable_work);
 
 	/* preform any regulator specific init */
-	if (init_data->regulator_init) {
+	if (init_data && init_data->regulator_init) {
 		ret = init_data->regulator_init(rdev->reg_data);
 		if (ret < 0)
 			goto clean;
@@ -2768,7 +2770,10 @@ struct regulator_dev *regulator_register(struct regulator_desc *regulator_desc,
 	dev_set_drvdata(&rdev->dev, rdev);
 
 	/* set regulator constraints */
-	ret = set_machine_constraints(rdev, &init_data->constraints);
+	if (init_data)
+		constraints = &init_data->constraints;
+
+	ret = set_machine_constraints(rdev, constraints);
 	if (ret < 0)
 		goto scrub;
 
@@ -2777,7 +2782,7 @@ struct regulator_dev *regulator_register(struct regulator_desc *regulator_desc,
 	if (ret < 0)
 		goto scrub;
 
-	if (init_data->supply_regulator)
+	if (init_data && init_data->supply_regulator)
 		supply = init_data->supply_regulator;
 	else if (regulator_desc->supply_name)
 		supply = regulator_desc->supply_name;
@@ -2799,15 +2804,17 @@ struct regulator_dev *regulator_register(struct regulator_desc *regulator_desc,
 	}
 
 	/* add consumers devices */
-	for (i = 0; i < init_data->num_consumer_supplies; i++) {
-		ret = set_consumer_device_supply(rdev,
-			init_data->consumer_supplies[i].dev,
-			init_data->consumer_supplies[i].dev_name,
-			init_data->consumer_supplies[i].supply);
-		if (ret < 0) {
-			dev_err(dev, "Failed to set supply %s\n",
+	if (init_data) {
+		for (i = 0; i < init_data->num_consumer_supplies; i++) {
+			ret = set_consumer_device_supply(rdev,
+				init_data->consumer_supplies[i].dev,
+				init_data->consumer_supplies[i].dev_name,
 				init_data->consumer_supplies[i].supply);
-			goto unset_supplies;
+			if (ret < 0) {
+				dev_err(dev, "Failed to set supply %s\n",
+					init_data->consumer_supplies[i].supply);
+				goto unset_supplies;
+			}
 		}
 	}
 

commit 12f457dd78900dbdf9431330d0c1abc040e03dbe
Merge: 9ee4be4156b1 58fb5cf5d1ed
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Nov 28 14:50:45 2011 +0000

    Merge remote-tracking branch 'regulator/for-linus' into regulator-next

commit 58fb5cf5d1edb7e306574833ee55d732918c89e3
Author: Lothar Waßmann <LW@KARO-electronics.de>
Date:   Mon Nov 28 15:38:37 2011 +0100

    regulator: fix use after free bug
    
    This is caused by dereferencing 'rdev' after device_unregister() in
    the regulator_unregister() function.  'rdev' is freed by
    device_unregister(), so it must not be dereferenced after this call.
    
    [Edited commit message for legibility -- broonie]
    
    Signed-off-by: Lothar Waßmann <LW@KARO-electronics.de>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 669d02160221..938398f3e869 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2799,8 +2799,8 @@ void regulator_unregister(struct regulator_dev *rdev)
 	list_del(&rdev->list);
 	if (rdev->supply)
 		regulator_put(rdev->supply);
-	device_unregister(&rdev->dev);
 	kfree(rdev->constraints);
+	device_unregister(&rdev->dev);
 	mutex_unlock(&regulator_list_mutex);
 }
 EXPORT_SYMBOL_GPL(regulator_unregister);

commit 924ee2c9621b65df9dffa8218af5ee9a9b892bba
Merge: 68aaa37d0e82 69511a452e6d
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Nov 23 18:50:59 2011 +0000

    Merge remote-tracking branch 'regulator/topic/dt' into regulator-next

commit 69511a452e6dc6b74fe4f3671a51b1b44b9c57e3
Author: Rajendra Nayak <rnayak@ti.com>
Date:   Fri Nov 18 16:47:20 2011 +0530

    regulator: map consumer regulator based on device tree
    
    Device nodes in DT can associate themselves with one or more
    regulators/supply by providing a list of phandles (to regulator nodes)
    and corresponding supply names.
    
    For Example:
            devicenode: node@0x0 {
                    ...
                    ...
                    vmmc-supply = <&regulator1>;
                    vpll-supply = <&regulator2>;
            };
    
    The driver would then do a regulator_get(dev, "vmmc"); to get
    regulator1 and do a regulator_get(dev, "vpll"); to get
    regulator2.
    
    of_get_regulator() extracts the regulator node for a given
    device, based on the supply name.
    
    Use it to look up the regulator for a given consumer from device tree, during
    a regulator_get(). If not found fallback and lookup through
    the regulator_map_list instead.
    
    Also, since the regulator dt nodes can use the same binding to
    associate with a parent regulator/supply, allow the drivers to
    specify a supply_name, which can then be used to lookup dt
    to find the parent phandle.
    
    Signed-off-by: Rajendra Nayak <rnayak@ti.com>
    Acked-by: Grant Likely <grant.likely@secretlab.ca>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 8b01eb06ba64..9867ebc00bed 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -25,6 +25,8 @@
 #include <linux/mutex.h>
 #include <linux/suspend.h>
 #include <linux/delay.h>
+#include <linux/of.h>
+#include <linux/regulator/of_regulator.h>
 #include <linux/regulator/consumer.h>
 #include <linux/regulator/driver.h>
 #include <linux/regulator/machine.h>
@@ -132,6 +134,33 @@ static struct regulator *get_device_regulator(struct device *dev)
 	return NULL;
 }
 
+/**
+ * of_get_regulator - get a regulator device node based on supply name
+ * @dev: Device pointer for the consumer (of regulator) device
+ * @supply: regulator supply name
+ *
+ * Extract the regulator device node corresponding to the supply name.
+ * retruns the device node corresponding to the regulator if found, else
+ * returns NULL.
+ */
+static struct device_node *of_get_regulator(struct device *dev, const char *supply)
+{
+	struct device_node *regnode = NULL;
+	char prop_name[32]; /* 32 is max size of property name */
+
+	dev_dbg(dev, "Looking up %s-supply from device tree\n", supply);
+
+	snprintf(prop_name, 32, "%s-supply", supply);
+	regnode = of_parse_phandle(dev->of_node, prop_name, 0);
+
+	if (!regnode) {
+		dev_warn(dev, "%s property in node %s references invalid phandle",
+				prop_name, dev->of_node->full_name);
+		return NULL;
+	}
+	return regnode;
+}
+
 /* Platform voltage constraint check */
 static int regulator_check_voltage(struct regulator_dev *rdev,
 				   int *min_uV, int *max_uV)
@@ -1148,6 +1177,30 @@ static int _regulator_get_enable_time(struct regulator_dev *rdev)
 	return rdev->desc->ops->enable_time(rdev);
 }
 
+static struct regulator_dev *regulator_dev_lookup(struct device *dev,
+							 const char *supply)
+{
+	struct regulator_dev *r;
+	struct device_node *node;
+
+	/* first do a dt based lookup */
+	if (dev && dev->of_node) {
+		node = of_get_regulator(dev, supply);
+		if (node)
+			list_for_each_entry(r, &regulator_list, list)
+				if (r->dev.parent &&
+					node == r->dev.of_node)
+					return r;
+	}
+
+	/* if not found, try doing it non-dt way */
+	list_for_each_entry(r, &regulator_list, list)
+		if (strcmp(rdev_get_name(r), supply) == 0)
+			return r;
+
+	return NULL;
+}
+
 /* Internal regulator request function */
 static struct regulator *_regulator_get(struct device *dev, const char *id,
 					int exclusive)
@@ -1168,6 +1221,10 @@ static struct regulator *_regulator_get(struct device *dev, const char *id,
 
 	mutex_lock(&regulator_list_mutex);
 
+	rdev = regulator_dev_lookup(dev, id);
+	if (rdev)
+		goto found;
+
 	list_for_each_entry(map, &regulator_map_list, list) {
 		/* If the mapping has a device set up it must match */
 		if (map->dev_name &&
@@ -2642,6 +2699,7 @@ struct regulator_dev *regulator_register(struct regulator_desc *regulator_desc,
 	static atomic_t regulator_no = ATOMIC_INIT(0);
 	struct regulator_dev *rdev;
 	int ret, i;
+	const char *supply = NULL;
 
 	if (regulator_desc == NULL)
 		return ERR_PTR(-EINVAL);
@@ -2718,21 +2776,18 @@ struct regulator_dev *regulator_register(struct regulator_desc *regulator_desc,
 	if (ret < 0)
 		goto scrub;
 
-	if (init_data->supply_regulator) {
+	if (init_data->supply_regulator)
+		supply = init_data->supply_regulator;
+	else if (regulator_desc->supply_name)
+		supply = regulator_desc->supply_name;
+
+	if (supply) {
 		struct regulator_dev *r;
-		int found = 0;
 
-		list_for_each_entry(r, &regulator_list, list) {
-			if (strcmp(rdev_get_name(r),
-				   init_data->supply_regulator) == 0) {
-				found = 1;
-				break;
-			}
-		}
+		r = regulator_dev_lookup(dev, supply);
 
-		if (!found) {
-			dev_err(dev, "Failed to find supply %s\n",
-				init_data->supply_regulator);
+		if (!r) {
+			dev_err(dev, "Failed to find supply %s\n", supply);
 			ret = -ENODEV;
 			goto scrub;
 		}

commit 2c043bcbf287dc69848054d5c02c55c20f7a7bc5
Author: Rajendra Nayak <rnayak@ti.com>
Date:   Fri Nov 18 16:47:19 2011 +0530

    regulator: pass additional of_node to regulator_register()
    
    With device tree support for regulators, its needed that the
    regulator_dev->dev device has the right of_node attached.
    To be able to do this add an additional parameter to the
    regulator_register() api, wherein the dt-adapted driver can
    then pass this additional info onto the regulator core.
    
    Signed-off-by: Rajendra Nayak <rnayak@ti.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 669d02160221..8b01eb06ba64 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2637,7 +2637,7 @@ static void rdev_init_debugfs(struct regulator_dev *rdev)
  */
 struct regulator_dev *regulator_register(struct regulator_desc *regulator_desc,
 	struct device *dev, const struct regulator_init_data *init_data,
-	void *driver_data)
+	void *driver_data, struct device_node *of_node)
 {
 	static atomic_t regulator_no = ATOMIC_INIT(0);
 	struct regulator_dev *rdev;
@@ -2696,6 +2696,7 @@ struct regulator_dev *regulator_register(struct regulator_desc *regulator_desc,
 
 	/* register with sysfs */
 	rdev->dev.class = &regulator_class;
+	rdev->dev.of_node = of_node;
 	rdev->dev.parent = dev;
 	dev_set_name(&rdev->dev, "regulator.%d",
 		     atomic_inc_return(&regulator_no) - 1);

commit 4c78899b92335af0da11e104698e329bb50810b5
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Nov 2 11:39:09 2011 +0000

    regulator: Don't create voltage sysfs entries if we can't read voltage
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 669d02160221..679f92ec9a45 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2503,7 +2503,8 @@ static int add_regulator_attributes(struct regulator_dev *rdev)
 	int			status = 0;
 
 	/* some attributes need specific methods to be displayed */
-	if (ops->get_voltage || ops->get_voltage_sel) {
+	if ((ops->get_voltage && ops->get_voltage(rdev) >= 0) ||
+	    (ops->get_voltage_sel && ops->get_voltage_sel(rdev) >= 0)) {
 		status = device_create_file(dev, &dev_attr_microvolts);
 		if (status < 0)
 			return status;

commit 32aaeffbd4a7457bf2f7448b33b5946ff2a960eb
Merge: 208bca086040 67b84999b1a8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Nov 6 19:44:47 2011 -0800

    Merge branch 'modsplit-Oct31_2011' of git://git.kernel.org/pub/scm/linux/kernel/git/paulg/linux
    
    * 'modsplit-Oct31_2011' of git://git.kernel.org/pub/scm/linux/kernel/git/paulg/linux: (230 commits)
      Revert "tracing: Include module.h in define_trace.h"
      irq: don't put module.h into irq.h for tracking irqgen modules.
      bluetooth: macroize two small inlines to avoid module.h
      ip_vs.h: fix implicit use of module_get/module_put from module.h
      nf_conntrack.h: fix up fallout from implicit moduleparam.h presence
      include: replace linux/module.h with "struct module" wherever possible
      include: convert various register fcns to macros to avoid include chaining
      crypto.h: remove unused crypto_tfm_alg_modname() inline
      uwb.h: fix implicit use of asm/page.h for PAGE_SIZE
      pm_runtime.h: explicitly requires notifier.h
      linux/dmaengine.h: fix implicit use of bitmap.h and asm/page.h
      miscdevice.h: fix up implicit use of lists and types
      stop_machine.h: fix implicit use of smp.h for smp_processor_id
      of: fix implicit use of errno.h in include/linux/of.h
      of_platform.h: delete needless include <linux/module.h>
      acpi: remove module.h include from platform/aclinux.h
      miscdevice.h: delete unnecessary inclusion of module.h
      device_cgroup.h: delete needless include <linux/module.h>
      net: sch_generic remove redundant use of <linux/module.h>
      net: inet_timewait_sock doesnt need <linux/module.h>
      ...
    
    Fix up trivial conflicts (other header files, and  removal of the ab3550 mfd driver) in
     - drivers/media/dvb/frontends/dibx000_common.c
     - drivers/media/video/{mt9m111.c,ov6650.c}
     - drivers/mfd/ab3550-core.c
     - include/linux/dmaengine.h

commit f3c3f0670501fee130f22193369249deea8cc630
Merge: c18ae42aa5b3 0151546fb34e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Nov 1 15:06:20 2011 -0700

    Merge branch 'for-linus' of git://opensource.wolfsonmicro.com/regulator
    
    * 'for-linus' of git://opensource.wolfsonmicro.com/regulator: (22 commits)
      regulator: Constify constraints name
      regulator: Fix possible nullpointer dereference in regulator_enable()
      regulator: gpio-regulator add dependency on GENERIC_GPIO
      regulator: Add module.h include to gpio-regulator
      regulator: Add driver for gpio-controlled regulators
      regulator: remove duplicate REG_CTRL2 defines in tps65023
      regulator: Clarify documentation for regulator-regulator supplies
      regulator: Fix some bitrot in the machine driver documentation
      regulator: tps65023: Added support for the similiar TPS65020 chip
      regulator: tps65023: Setting correct core regulator for tps65021
      regulator: tps65023: Set missing bit for update core-voltage
      regulator: tps65023: Fixes i2c configuration issues
      regulator: Add debugfs file showing the supply map table
      regulator: tps6586x: add SMx slew rate setting
      regulator: tps65023: Fixes i2c configuration issues
      regulator: tps6507x: Remove num_voltages array
      regulator: max8952: removed unused mutex.
      regulator: fix regulator/consumer.h kernel-doc warning
      regulator: Ensure enough enable time for max8649
      regulator: 88pm8607: Fix off-by-one value range checking in the case of no id is matched
      ...

commit 65602c32ee9b5500e3cb617ccec2154ee2191898
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Sun Jul 17 16:28:23 2011 -0400

    regulator: Add module.h to drivers/regulator users as required
    
    Another group of drivers that are taking advantage of the implicit
    presence of module.h -- and will break when we pull the carpet out
    from under them during a cleanup.  Fix 'em now.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 9e4c123c4028..e31c6efdd9f8 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -28,6 +28,7 @@
 #include <linux/regulator/consumer.h>
 #include <linux/regulator/driver.h>
 #include <linux/regulator/machine.h>
+#include <linux/module.h>
 
 #define CREATE_TRACE_POINTS
 #include <trace/events/regulator.h>

commit d1685e4e2c3854782272f32b71f2f3eff5c6e0d0
Author: Heiko Stübner <heiko@sntech.de>
Date:   Fri Oct 14 18:00:29 2011 +0200

    regulator: Fix possible nullpointer dereference in regulator_enable()
    
    In the case where _regulator_enable returns an error it was not checked
    if a supplying regulator exists before trying to disable it, leading
    to a null pointer-dereference if no supplying regulator existed.
    
    Signed-off-by: Heiko Stuebner <heiko@sntech.de>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 9a33fe2021b6..87d9328f1695 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1425,7 +1425,7 @@ int regulator_enable(struct regulator *regulator)
 	ret = _regulator_enable(rdev);
 	mutex_unlock(&rdev->mutex);
 
-	if (ret != 0)
+	if (ret != 0 && rdev->supply)
 		regulator_disable(rdev->supply);
 
 	return ret;

commit aa59802dedac98dc95310a456121cec6a9d6b63f
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Oct 3 22:42:43 2011 +0100

    regulator: Fix return code from regulator_disable_deferred()
    
    schedule_delayed_work() returns a bool indicating if the work was already
    queued when it succeeds so we need to squash a true down to zero.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index d0bde70f3466..9e4c123c4028 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1599,13 +1599,18 @@ static void regulator_disable_work(struct work_struct *work)
 int regulator_disable_deferred(struct regulator *regulator, int ms)
 {
 	struct regulator_dev *rdev = regulator->rdev;
+	int ret;
 
 	mutex_lock(&rdev->mutex);
 	rdev->deferred_disables++;
 	mutex_unlock(&rdev->mutex);
 
-	return schedule_delayed_work(&rdev->disable_work,
-				     msecs_to_jiffies(ms));
+	ret = schedule_delayed_work(&rdev->disable_work,
+				    msecs_to_jiffies(ms));
+	if (ret < 0)
+		return ret;
+	else
+		return 0;
 }
 EXPORT_SYMBOL_GPL(regulator_disable_deferred);
 

commit da07ecd93b196819dcec488b7ebec69a71f3819e
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Sun Sep 11 09:53:50 2011 +0100

    regulator: Implement deferred disable support
    
    It is a reasonably common pattern for hardware to require some delay after
    being quiesced before the disable has finalised, especially in mixed signal
    devices. For example, an active discharge may be required to ensure that
    the circuit starts up again in a known state. Avoid having to implement
    such delays in the regulator API by providing regulator_deferred_disable()
    which will do a regulator_disable() a specified number of milliseconds
    after it is called.
    
    Due to the reference counting done on regulators a deferred disable can
    be cancelled by doing another regulator_enable().
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Liam Girdwood <lrg@ti.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index d8e6a429e8ba..d0bde70f3466 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1552,6 +1552,63 @@ int regulator_force_disable(struct regulator *regulator)
 }
 EXPORT_SYMBOL_GPL(regulator_force_disable);
 
+static void regulator_disable_work(struct work_struct *work)
+{
+	struct regulator_dev *rdev = container_of(work, struct regulator_dev,
+						  disable_work.work);
+	int count, i, ret;
+
+	mutex_lock(&rdev->mutex);
+
+	BUG_ON(!rdev->deferred_disables);
+
+	count = rdev->deferred_disables;
+	rdev->deferred_disables = 0;
+
+	for (i = 0; i < count; i++) {
+		ret = _regulator_disable(rdev);
+		if (ret != 0)
+			rdev_err(rdev, "Deferred disable failed: %d\n", ret);
+	}
+
+	mutex_unlock(&rdev->mutex);
+
+	if (rdev->supply) {
+		for (i = 0; i < count; i++) {
+			ret = regulator_disable(rdev->supply);
+			if (ret != 0) {
+				rdev_err(rdev,
+					 "Supply disable failed: %d\n", ret);
+			}
+		}
+	}
+}
+
+/**
+ * regulator_disable_deferred - disable regulator output with delay
+ * @regulator: regulator source
+ * @ms: miliseconds until the regulator is disabled
+ *
+ * Execute regulator_disable() on the regulator after a delay.  This
+ * is intended for use with devices that require some time to quiesce.
+ *
+ * NOTE: this will only disable the regulator output if no other consumer
+ * devices have it enabled, the regulator device supports disabling and
+ * machine constraints permit this operation.
+ */
+int regulator_disable_deferred(struct regulator *regulator, int ms)
+{
+	struct regulator_dev *rdev = regulator->rdev;
+
+	mutex_lock(&rdev->mutex);
+	rdev->deferred_disables++;
+	mutex_unlock(&rdev->mutex);
+
+	return schedule_delayed_work(&rdev->disable_work,
+				     msecs_to_jiffies(ms));
+}
+EXPORT_SYMBOL_GPL(regulator_disable_deferred);
+
 static int _regulator_is_enabled(struct regulator_dev *rdev)
 {
 	/* If we don't know then assume that the regulator is always on */
@@ -2622,6 +2679,7 @@ struct regulator_dev *regulator_register(struct regulator_desc *regulator_desc,
 	INIT_LIST_HEAD(&rdev->consumer_list);
 	INIT_LIST_HEAD(&rdev->list);
 	BLOCKING_INIT_NOTIFIER_HEAD(&rdev->notifier);
+	INIT_DELAYED_WORK(&rdev->disable_work, regulator_disable_work);
 
 	/* preform any regulator specific init */
 	if (init_data->regulator_init) {
@@ -2729,6 +2787,7 @@ void regulator_unregister(struct regulator_dev *rdev)
 #ifdef CONFIG_DEBUG_FS
 	debugfs_remove_recursive(rdev->debugfs);
 #endif
+	flush_work_sync(&rdev->disable_work.work);
 	WARN_ON(rdev->open_count);
 	unset_regulator_supplies(rdev);
 	list_del(&rdev->list);

commit ba55a9741da6c85176987c15e24383b858749aa2
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Aug 23 17:39:10 2011 +0100

    regulator: Add debugfs file showing the supply map table
    
    Useful for working out why things aren't getting plugged together properly.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index d8e6a429e8ba..9a33fe2021b6 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2907,6 +2907,43 @@ void *regulator_get_init_drvdata(struct regulator_init_data *reg_init_data)
 }
 EXPORT_SYMBOL_GPL(regulator_get_init_drvdata);
 
+#ifdef CONFIG_DEBUG_FS
+static ssize_t supply_map_read_file(struct file *file, char __user *user_buf,
+				    size_t count, loff_t *ppos)
+{
+	char *buf = kmalloc(PAGE_SIZE, GFP_KERNEL);
+	ssize_t len, ret = 0;
+	struct regulator_map *map;
+
+	if (!buf)
+		return -ENOMEM;
+
+	list_for_each_entry(map, &regulator_map_list, list) {
+		len = snprintf(buf + ret, PAGE_SIZE - ret,
+			       "%s -> %s.%s\n",
+			       rdev_get_name(map->regulator), map->dev_name,
+			       map->supply);
+		if (len >= 0)
+			ret += len;
+		if (ret > PAGE_SIZE) {
+			ret = PAGE_SIZE;
+			break;
+		}
+	}
+
+	ret = simple_read_from_buffer(user_buf, count, ppos, buf, ret);
+
+	kfree(buf);
+
+	return ret;
+}
+
+static const struct file_operations supply_map_fops = {
+	.read = supply_map_read_file,
+	.llseek = default_llseek,
+};
+#endif
+
 static int __init regulator_init(void)
 {
 	int ret;
@@ -2919,6 +2956,10 @@ static int __init regulator_init(void)
 		pr_warn("regulator: Failed to create debugfs directory\n");
 		debugfs_root = NULL;
 	}
+
+	if (IS_ERR(debugfs_create_file("supply_map", 0444, debugfs_root,
+				       NULL, &supply_map_fops)))
+		pr_warn("regulator: Failed to create supplies debugfs\n");
 #endif
 
 	regulator_dummy_init();

commit 54abd335fda86d305845f9e62b4bc0997386eb66
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Thu Jul 21 15:07:37 2011 +0100

    regulator: Fix argument format type errors in error prints
    
    We need to dereference the pointers to print their values.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index a01954456752..d8e6a429e8ba 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -153,7 +153,7 @@ static int regulator_check_voltage(struct regulator_dev *rdev,
 
 	if (*min_uV > *max_uV) {
 		rdev_err(rdev, "unsupportable voltage range: %d-%duV\n",
-			 min_uV, max_uV);
+			 *min_uV, *max_uV);
 		return -EINVAL;
 	}
 
@@ -210,7 +210,7 @@ static int regulator_check_current_limit(struct regulator_dev *rdev,
 
 	if (*min_uA > *max_uA) {
 		rdev_err(rdev, "unsupportable current range: %d-%duA\n",
-			 min_uA, max_uA);
+			 *min_uA, *max_uA);
 		return -EINVAL;
 	}
 

commit 1a6958e79f9e191c89fe0c13f7452b0bd8097050
Author: Axel Lin <axel.lin@gmail.com>
Date:   Fri Jul 15 10:50:43 2011 +0800

    regulator: Fix memory leak in set_machine_constraints() error paths
    
    Properly kfree rdev->constraints in all set_machine_constraints() error paths.
    Also properly kfree rdev->constraints in regulator_register() error paths.
    
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 3700d0953d73..a01954456752 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -794,7 +794,6 @@ static int machine_constraints_voltage(struct regulator_dev *rdev,
 		if (ret < 0) {
 			rdev_err(rdev, "failed to apply %duV constraint\n",
 				 rdev->constraints->min_uV);
-			rdev->constraints = NULL;
 			return ret;
 		}
 	}
@@ -897,7 +896,6 @@ static int set_machine_constraints(struct regulator_dev *rdev,
 		ret = suspend_prepare(rdev, rdev->constraints->initial_state);
 		if (ret < 0) {
 			rdev_err(rdev, "failed to set suspend state\n");
-			rdev->constraints = NULL;
 			goto out;
 		}
 	}
@@ -924,13 +922,15 @@ static int set_machine_constraints(struct regulator_dev *rdev,
 		ret = ops->enable(rdev);
 		if (ret < 0) {
 			rdev_err(rdev, "failed to enable\n");
-			rdev->constraints = NULL;
 			goto out;
 		}
 	}
 
 	print_constraints(rdev);
+	return 0;
 out:
+	kfree(rdev->constraints);
+	rdev->constraints = NULL;
 	return ret;
 }
 
@@ -2701,6 +2701,7 @@ struct regulator_dev *regulator_register(struct regulator_desc *regulator_desc,
 	unset_regulator_supplies(rdev);
 
 scrub:
+	kfree(rdev->constraints);
 	device_unregister(&rdev->dev);
 	/* device core frees rdev */
 	rdev = ERR_PTR(ret);

commit 89f425ed5bf3d4fd97e840296dccd75b8e0fe4c9
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Jul 12 11:20:37 2011 +0900

    regulator: Make core more chatty about some errors
    
    Prevent some head scratching by making the core log about some rare but
    possible errors with invalid voltage ranges and modes being set.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index f59821f10fdc..3700d0953d73 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -151,8 +151,11 @@ static int regulator_check_voltage(struct regulator_dev *rdev,
 	if (*min_uV < rdev->constraints->min_uV)
 		*min_uV = rdev->constraints->min_uV;
 
-	if (*min_uV > *max_uV)
+	if (*min_uV > *max_uV) {
+		rdev_err(rdev, "unsupportable voltage range: %d-%duV\n",
+			 min_uV, max_uV);
 		return -EINVAL;
+	}
 
 	return 0;
 }
@@ -205,8 +208,11 @@ static int regulator_check_current_limit(struct regulator_dev *rdev,
 	if (*min_uA < rdev->constraints->min_uA)
 		*min_uA = rdev->constraints->min_uA;
 
-	if (*min_uA > *max_uA)
+	if (*min_uA > *max_uA) {
+		rdev_err(rdev, "unsupportable current range: %d-%duA\n",
+			 min_uA, max_uA);
 		return -EINVAL;
+	}
 
 	return 0;
 }
@@ -221,6 +227,7 @@ static int regulator_mode_constrain(struct regulator_dev *rdev, int *mode)
 	case REGULATOR_MODE_STANDBY:
 		break;
 	default:
+		rdev_err(rdev, "invalid mode %x specified\n", *mode);
 		return -EINVAL;
 	}
 

commit 5de705194e9883a39f993e2ff96028d5aab99b37
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Sun Jun 19 13:33:16 2011 +0100

    regulator: Add basic per consumer debugfs
    
    Report the requested load and voltage for each consumer in debugfs when it
    is enabled.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index cc3dfd66f395..f59821f10fdc 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -81,6 +81,9 @@ struct regulator {
 	char *supply_name;
 	struct device_attribute dev_attr;
 	struct regulator_dev *rdev;
+#ifdef CONFIG_DEBUG_FS
+	struct dentry *debugfs;
+#endif
 };
 
 static int _regulator_is_enabled(struct regulator_dev *rdev);
@@ -1093,7 +1096,28 @@ static struct regulator *create_regulator(struct regulator_dev *rdev,
 				  dev->kobj.name, err);
 			goto link_name_err;
 		}
+	} else {
+		regulator->supply_name = kstrdup(supply_name, GFP_KERNEL);
+		if (regulator->supply_name == NULL)
+			goto attr_err;
+	}
+
+#ifdef CONFIG_DEBUG_FS
+	regulator->debugfs = debugfs_create_dir(regulator->supply_name,
+						rdev->debugfs);
+	if (IS_ERR_OR_NULL(regulator->debugfs)) {
+		rdev_warn(rdev, "Failed to create debugfs directory\n");
+		regulator->debugfs = NULL;
+	} else {
+		debugfs_create_u32("uA_load", 0444, regulator->debugfs,
+				   &regulator->uA_load);
+		debugfs_create_u32("min_uV", 0444, regulator->debugfs,
+				   &regulator->min_uV);
+		debugfs_create_u32("max_uV", 0444, regulator->debugfs,
+				   &regulator->max_uV);
 	}
+#endif
+
 	mutex_unlock(&rdev->mutex);
 	return regulator;
 link_name_err:
@@ -1272,13 +1296,17 @@ void regulator_put(struct regulator *regulator)
 	mutex_lock(&regulator_list_mutex);
 	rdev = regulator->rdev;
 
+#ifdef CONFIG_DEBUG_FS
+	debugfs_remove_recursive(regulator->debugfs);
+#endif
+
 	/* remove any sysfs entries */
 	if (regulator->dev) {
 		sysfs_remove_link(&rdev->dev.kobj, regulator->supply_name);
-		kfree(regulator->supply_name);
 		device_remove_file(regulator->dev, &regulator->dev_attr);
 		kfree(regulator->dev_attr.attr.name);
 	}
+	kfree(regulator->supply_name);
 	list_del(&regulator->list);
 	kfree(regulator);
 

commit 7d51a0dbe51282f3ed13cadf6e7f13a974374be2
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Thu Jun 9 16:06:37 2011 +0100

    regulator: Add rdev_crit() macro
    
    No actual users but provide the macro so there's less surprise when it's
    not there.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index f0cc3983ffee..cc3dfd66f395 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -34,6 +34,8 @@
 
 #include "dummy.h"
 
+#define rdev_crit(rdev, fmt, ...)					\
+	pr_crit("%s: " fmt, rdev_get_name(rdev), ##__VA_ARGS__)
 #define rdev_err(rdev, fmt, ...)					\
 	pr_err("%s: " fmt, rdev_get_name(rdev), ##__VA_ARGS__)
 #define rdev_warn(rdev, fmt, ...)					\

commit 3801b86aa482d26a8ae460f67fca29e016491a86
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Thu Jun 9 16:22:22 2011 +0100

    regulator: Refactor supply implementation to work as regular consumers
    
    Currently the regulator supply implementation is somewhat complex and
    fragile as it doesn't look like standard consumers but is instead a
    parallel implementation. This causes issues with locking and reference
    counting.
    
    Move the implementation over to using standard consumers to address this.
    Rather than only notifying the supply on the first enable/disable we do so
    every time the regulator is enabled or disabled, simplifying locking as we
    don't need to hold a lock on the consumer we are about to enable.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index e3b67ee48b23..f0cc3983ffee 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -82,8 +82,7 @@ struct regulator {
 };
 
 static int _regulator_is_enabled(struct regulator_dev *rdev);
-static int _regulator_disable(struct regulator_dev *rdev,
-		struct regulator_dev **supply_rdev_ptr);
+static int _regulator_disable(struct regulator_dev *rdev);
 static int _regulator_get_voltage(struct regulator_dev *rdev);
 static int _regulator_get_current_limit(struct regulator_dev *rdev);
 static unsigned int _regulator_get_mode(struct regulator_dev *rdev);
@@ -91,6 +90,9 @@ static void _notifier_call_chain(struct regulator_dev *rdev,
 				  unsigned long event, void *data);
 static int _regulator_do_set_voltage(struct regulator_dev *rdev,
 				     int min_uV, int max_uV);
+static struct regulator *create_regulator(struct regulator_dev *rdev,
+					  struct device *dev,
+					  const char *supply_name);
 
 static const char *rdev_get_name(struct regulator_dev *rdev)
 {
@@ -930,21 +932,20 @@ static int set_machine_constraints(struct regulator_dev *rdev,
  * core if it's child is enabled.
  */
 static int set_supply(struct regulator_dev *rdev,
-	struct regulator_dev *supply_rdev)
+		      struct regulator_dev *supply_rdev)
 {
 	int err;
 
-	err = sysfs_create_link(&rdev->dev.kobj, &supply_rdev->dev.kobj,
-				"supply");
-	if (err) {
-		rdev_err(rdev, "could not add device link %s err %d\n",
-			 supply_rdev->dev.kobj.name, err);
-		       goto out;
+	rdev_info(rdev, "supplied by %s\n", rdev_get_name(supply_rdev));
+
+	rdev->supply = create_regulator(supply_rdev, &rdev->dev, "SUPPLY");
+	if (IS_ERR(rdev->supply)) {
+		err = PTR_ERR(rdev->supply);
+		rdev->supply = NULL;
+		return err;
 	}
-	rdev->supply = supply_rdev;
-	list_add(&rdev->slist, &supply_rdev->supply_list);
-out:
-	return err;
+
+	return 0;
 }
 
 /**
@@ -1303,19 +1304,6 @@ static int _regulator_enable(struct regulator_dev *rdev)
 {
 	int ret, delay;
 
-	if (rdev->use_count == 0) {
-		/* do we need to enable the supply regulator first */
-		if (rdev->supply) {
-			mutex_lock(&rdev->supply->mutex);
-			ret = _regulator_enable(rdev->supply);
-			mutex_unlock(&rdev->supply->mutex);
-			if (ret < 0) {
-				rdev_err(rdev, "failed to enable: %d\n", ret);
-				return ret;
-			}
-		}
-	}
-
 	/* check voltage and requested load before enabling */
 	if (rdev->constraints &&
 	    (rdev->constraints->valid_ops_mask & REGULATOR_CHANGE_DRMS))
@@ -1390,19 +1378,27 @@ int regulator_enable(struct regulator *regulator)
 	struct regulator_dev *rdev = regulator->rdev;
 	int ret = 0;
 
+	if (rdev->supply) {
+		ret = regulator_enable(rdev->supply);
+		if (ret != 0)
+			return ret;
+	}
+
 	mutex_lock(&rdev->mutex);
 	ret = _regulator_enable(rdev);
 	mutex_unlock(&rdev->mutex);
+
+	if (ret != 0)
+		regulator_disable(rdev->supply);
+
 	return ret;
 }
 EXPORT_SYMBOL_GPL(regulator_enable);
 
 /* locks held by regulator_disable() */
-static int _regulator_disable(struct regulator_dev *rdev,
-		struct regulator_dev **supply_rdev_ptr)
+static int _regulator_disable(struct regulator_dev *rdev)
 {
 	int ret = 0;
-	*supply_rdev_ptr = NULL;
 
 	if (WARN(rdev->use_count <= 0,
 		 "unbalanced disables for %s\n", rdev_get_name(rdev)))
@@ -1429,9 +1425,6 @@ static int _regulator_disable(struct regulator_dev *rdev,
 					     NULL);
 		}
 
-		/* decrease our supplies ref count and disable if required */
-		*supply_rdev_ptr = rdev->supply;
-
 		rdev->use_count = 0;
 	} else if (rdev->use_count > 1) {
 
@@ -1442,6 +1435,7 @@ static int _regulator_disable(struct regulator_dev *rdev,
 
 		rdev->use_count--;
 	}
+
 	return ret;
 }
 
@@ -1460,29 +1454,21 @@ static int _regulator_disable(struct regulator_dev *rdev,
 int regulator_disable(struct regulator *regulator)
 {
 	struct regulator_dev *rdev = regulator->rdev;
-	struct regulator_dev *supply_rdev = NULL;
 	int ret = 0;
 
 	mutex_lock(&rdev->mutex);
-	ret = _regulator_disable(rdev, &supply_rdev);
+	ret = _regulator_disable(rdev);
 	mutex_unlock(&rdev->mutex);
 
-	/* decrease our supplies ref count and disable if required */
-	while (supply_rdev != NULL) {
-		rdev = supply_rdev;
-
-		mutex_lock(&rdev->mutex);
-		_regulator_disable(rdev, &supply_rdev);
-		mutex_unlock(&rdev->mutex);
-	}
+	if (ret == 0 && rdev->supply)
+		regulator_disable(rdev->supply);
 
 	return ret;
 }
 EXPORT_SYMBOL_GPL(regulator_disable);
 
 /* locks held by regulator_force_disable() */
-static int _regulator_force_disable(struct regulator_dev *rdev,
-		struct regulator_dev **supply_rdev_ptr)
+static int _regulator_force_disable(struct regulator_dev *rdev)
 {
 	int ret = 0;
 
@@ -1499,10 +1485,6 @@ static int _regulator_force_disable(struct regulator_dev *rdev,
 			REGULATOR_EVENT_DISABLE, NULL);
 	}
 
-	/* decrease our supplies ref count and disable if required */
-	*supply_rdev_ptr = rdev->supply;
-
-	rdev->use_count = 0;
 	return ret;
 }
 
@@ -1518,16 +1500,16 @@ static int _regulator_force_disable(struct regulator_dev *rdev,
 int regulator_force_disable(struct regulator *regulator)
 {
 	struct regulator_dev *rdev = regulator->rdev;
-	struct regulator_dev *supply_rdev = NULL;
 	int ret;
 
 	mutex_lock(&rdev->mutex);
 	regulator->uA_load = 0;
-	ret = _regulator_force_disable(rdev, &supply_rdev);
+	ret = _regulator_force_disable(regulator->rdev);
 	mutex_unlock(&rdev->mutex);
 
-	if (supply_rdev)
-		regulator_disable(get_device_regulator(rdev_get_dev(supply_rdev)));
+	if (rdev->supply)
+		while (rdev->open_count--)
+			regulator_disable(rdev->supply);
 
 	return ret;
 }
@@ -2138,7 +2120,7 @@ int regulator_set_optimum_mode(struct regulator *regulator, int uA_load)
 	/* get input voltage */
 	input_uV = 0;
 	if (rdev->supply)
-		input_uV = _regulator_get_voltage(rdev->supply);
+		input_uV = regulator_get_voltage(rdev->supply);
 	if (input_uV <= 0)
 		input_uV = rdev->constraints->input_uV;
 	if (input_uV <= 0) {
@@ -2208,17 +2190,8 @@ EXPORT_SYMBOL_GPL(regulator_unregister_notifier);
 static void _notifier_call_chain(struct regulator_dev *rdev,
 				  unsigned long event, void *data)
 {
-	struct regulator_dev *_rdev;
-
 	/* call rdev chain first */
 	blocking_notifier_call_chain(&rdev->notifier, event, NULL);
-
-	/* now notify regulator we supply */
-	list_for_each_entry(_rdev, &rdev->supply_list, slist) {
-		mutex_lock(&_rdev->mutex);
-		_notifier_call_chain(_rdev, event, data);
-		mutex_unlock(&_rdev->mutex);
-	}
 }
 
 /**
@@ -2610,9 +2583,7 @@ struct regulator_dev *regulator_register(struct regulator_desc *regulator_desc,
 	rdev->owner = regulator_desc->owner;
 	rdev->desc = regulator_desc;
 	INIT_LIST_HEAD(&rdev->consumer_list);
-	INIT_LIST_HEAD(&rdev->supply_list);
 	INIT_LIST_HEAD(&rdev->list);
-	INIT_LIST_HEAD(&rdev->slist);
 	BLOCKING_INIT_NOTIFIER_HEAD(&rdev->notifier);
 
 	/* preform any regulator specific init */
@@ -2724,7 +2695,7 @@ void regulator_unregister(struct regulator_dev *rdev)
 	unset_regulator_supplies(rdev);
 	list_del(&rdev->list);
 	if (rdev->supply)
-		sysfs_remove_link(&rdev->dev.kobj, "supply");
+		regulator_put(rdev->supply);
 	device_unregister(&rdev->dev);
 	kfree(rdev->constraints);
 	mutex_unlock(&regulator_list_mutex);

commit e0eaedefda8e14ed3f445f382c568c5d69e4223f
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Thu Jun 9 16:22:21 2011 +0100

    regulator: Include the device name in the microamps_requested_ file
    
    We may have multiple devices requesting a supply with the same name so
    include the device name in the generated filename for microamps_requested
    to avoid duplicate files.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 75312bd6aac4..e3b67ee48b23 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1053,8 +1053,9 @@ static struct regulator *create_regulator(struct regulator_dev *rdev,
 
 	if (dev) {
 		/* create a 'requested_microamps_name' sysfs entry */
-		size = scnprintf(buf, REG_STR_SIZE, "microamps_requested_%s",
-			supply_name);
+		size = scnprintf(buf, REG_STR_SIZE,
+				 "microamps_requested_%s-%s",
+				 dev_name(dev), supply_name);
 		if (size >= REG_STR_SIZE)
 			goto overflow_err;
 

commit f5726ae33c382366ea1b23240d5620dcf675d81d
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Thu Jun 9 16:22:20 2011 +0100

    regulator: Increase the limit on sysfs file names
    
    With verbose filenames we can easily hit 32 characters.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 7b38af90a012..75312bd6aac4 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1033,7 +1033,7 @@ static void unset_regulator_supplies(struct regulator_dev *rdev)
 	}
 }
 
-#define REG_STR_SIZE	32
+#define REG_STR_SIZE	64
 
 static struct regulator *create_regulator(struct regulator_dev *rdev,
 					  struct device *dev,

commit f21e0e81d81b649ad309cedc7226f1bed72982e0
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue May 24 08:12:40 2011 +0800

    regulator: Do bulk enables of regulators in parallel
    
    In order to reduce the impact of ramp times rather than enabling the
    regulators for a device in series use async tasks to run the actual
    enables. This means that the delays which the enables implement can all
    run in parallel, though it does mean that the order in which the
    supplies come on may be unstable.
    
    For super bonus fun points if any of the regulators are shared between
    multiple supplies on the same device (as is rather likely) then this
    will test our locking.  Note that in this case we only delay once for
    each physical regulator so the threads shouldn't block each other while
    delaying.
    
    It'd be even nicer if we could coalesce writes to a shared enable registers
    in PMICs but that's definitely future work, and it may also be useful
    and is certainly more achievable to optimise out the parallelism if none
    of the regulators implement ramp delays.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index d3e38790906e..7b38af90a012 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -20,6 +20,7 @@
 #include <linux/debugfs.h>
 #include <linux/device.h>
 #include <linux/slab.h>
+#include <linux/async.h>
 #include <linux/err.h>
 #include <linux/mutex.h>
 #include <linux/suspend.h>
@@ -2264,6 +2265,13 @@ int regulator_bulk_get(struct device *dev, int num_consumers,
 }
 EXPORT_SYMBOL_GPL(regulator_bulk_get);
 
+static void regulator_bulk_enable_async(void *data, async_cookie_t cookie)
+{
+	struct regulator_bulk_data *bulk = data;
+
+	bulk->ret = regulator_enable(bulk->consumer);
+}
+
 /**
  * regulator_bulk_enable - enable multiple regulator consumers
  *
@@ -2279,21 +2287,33 @@ EXPORT_SYMBOL_GPL(regulator_bulk_get);
 int regulator_bulk_enable(int num_consumers,
 			  struct regulator_bulk_data *consumers)
 {
+	LIST_HEAD(async_domain);
 	int i;
-	int ret;
+	int ret = 0;
+
+	for (i = 0; i < num_consumers; i++)
+		async_schedule_domain(regulator_bulk_enable_async,
+				      &consumers[i], &async_domain);
+
+	async_synchronize_full_domain(&async_domain);
 
+	/* If any consumer failed we need to unwind any that succeeded */
 	for (i = 0; i < num_consumers; i++) {
-		ret = regulator_enable(consumers[i].consumer);
-		if (ret != 0)
+		if (consumers[i].ret != 0) {
+			ret = consumers[i].ret;
 			goto err;
+		}
 	}
 
 	return 0;
 
 err:
-	pr_err("Failed to enable %s: %d\n", consumers[i].supply, ret);
-	for (--i; i >= 0; --i)
-		regulator_disable(consumers[i].consumer);
+	for (i = 0; i < num_consumers; i++)
+		if (consumers[i].ret == 0)
+			regulator_disable(consumers[i].consumer);
+		else
+			pr_err("Failed to enable %s: %d\n",
+			       consumers[i].supply, consumers[i].ret);
 
 	return ret;
 }

commit cb220d16f91f8d5fa1450c7af17e028e8cb3f0f1
Author: Axel Lin <axel.lin@gmail.com>
Date:   Mon May 23 20:08:10 2011 +0800

    regulator: Fix _regulator_get_voltage if get_voltage callback is NULL
    
    In the case of get_voltage callback is NULL, current implementation in
    _regulator_get_voltage will return -EINVAL.
    
    Also returns proper error if ret is negative value.
    
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 9493f6111a38..d3e38790906e 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1886,12 +1886,14 @@ static int _regulator_get_voltage(struct regulator_dev *rdev)
 		if (sel < 0)
 			return sel;
 		ret = rdev->desc->ops->list_voltage(rdev, sel);
-	}
-	if (rdev->desc->ops->get_voltage)
+	} else if (rdev->desc->ops->get_voltage) {
 		ret = rdev->desc->ops->get_voltage(rdev);
-	else
+	} else {
 		return -EINVAL;
+	}
 
+	if (ret < 0)
+		return ret;
 	return ret - rdev->constraints->uV_offset;
 }
 

commit 4aa922c024b2a194d7b68b22a66dfcf86e7838b3
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Sat May 14 13:42:34 2011 -0700

    regulator: Only apply voltage constraints from consumers that set them
    
    When applying the set_voltage() requests from consumers skip over those
    consumers that haven't set anything, otherwise we'll come out with a
    maximum voltage of zero.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 7287000595e5..9493f6111a38 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -158,6 +158,13 @@ static int regulator_check_consumers(struct regulator_dev *rdev,
 	struct regulator *regulator;
 
 	list_for_each_entry(regulator, &rdev->consumer_list, list) {
+		/*
+		 * Assume consumers that didn't say anything are OK
+		 * with anything in the constraint range.
+		 */
+		if (!regulator->min_uV && !regulator->max_uV)
+			continue;
+
 		if (*max_uV > regulator->max_uV)
 			*max_uV = regulator->max_uV;
 		if (*min_uV < regulator->min_uV)

commit a4b4148379ef1ad460fc1aa6bcf2cde99cd91166
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Sat May 14 11:19:45 2011 -0700

    regulator: If we can't configure optimum mode we're always in the best one
    
    If either a regulator driver can't tell us what the optimum mode is (or
    doesn't have modes in the first place) or the system doesn't allow DRMS
    changes then it's more helpful for users to just say that we're in the
    optimal mode, even if it's from a selection of one.
    
    Still report errors if the process of picking and setting a mode changes as
    this may indicate that we're stuck in a low power mode and unable to deliver
    a higher current that the consumer just asked for.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 58452ac0f165..7287000595e5 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2097,16 +2097,26 @@ int regulator_set_optimum_mode(struct regulator *regulator, int uA_load)
 
 	mutex_lock(&rdev->mutex);
 
+	/*
+	 * first check to see if we can set modes at all, otherwise just
+	 * tell the consumer everything is OK.
+	 */
 	regulator->uA_load = uA_load;
 	ret = regulator_check_drms(rdev);
-	if (ret < 0)
+	if (ret < 0) {
+		ret = 0;
 		goto out;
-	ret = -EINVAL;
+	}
 
-	/* sanity check */
 	if (!rdev->desc->ops->get_optimum_mode)
 		goto out;
 
+	/*
+	 * we can actually do this so any errors are indicators of
+	 * potential real failure.
+	 */
+	ret = -EINVAL;
+
 	/* get output voltage */
 	output_uV = _regulator_get_voltage(rdev);
 	if (output_uV <= 0) {

commit bf5892a8167e4aa5a9a6d72f803fde850e0c5753
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Sun May 8 22:13:37 2011 +0100

    regulator: Support voltage offsets to compensate for drops in system
    
    Some systems, particularly physically large systems used for early
    prototyping, may experience substantial voltage drops between the regulator
    and the consumers as a result of long traces in the system. With these
    systems voltages may need to be set higher than requested in order to
    ensure reliable system operation.
    
    Allow systems to work around such hardware issues by allowing constraints
    to supply an offset to be applied to any requested and reported voltages.
    This is not ideal, especially since the voltage drop may be load dependant,
    but is sufficient for most affected systems, it is not expected to be used
    in production hardware. The offset is applied after all constraint
    processing so constraints should be specified in terms of consumer values
    not physically configured values.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 432faa5cb8af..58452ac0f165 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -724,6 +724,10 @@ static void print_constraints(struct regulator_dev *rdev)
 			count += sprintf(buf + count, "at %d mV ", ret / 1000);
 	}
 
+	if (constraints->uV_offset)
+		count += sprintf(buf, "%dmV offset ",
+				 constraints->uV_offset / 1000);
+
 	if (constraints->min_uA && constraints->max_uA) {
 		if (constraints->min_uA == constraints->max_uA)
 			count += sprintf(buf + count, "%d mA ",
@@ -1641,6 +1645,9 @@ static int _regulator_do_set_voltage(struct regulator_dev *rdev,
 
 	trace_regulator_set_voltage(rdev_get_name(rdev), min_uV, max_uV);
 
+	min_uV += rdev->constraints->uV_offset;
+	max_uV += rdev->constraints->uV_offset;
+
 	if (rdev->desc->ops->set_voltage) {
 		ret = rdev->desc->ops->set_voltage(rdev, min_uV, max_uV,
 						   &selector);
@@ -1865,18 +1872,20 @@ EXPORT_SYMBOL_GPL(regulator_sync_voltage);
 
 static int _regulator_get_voltage(struct regulator_dev *rdev)
 {
-	int sel;
+	int sel, ret;
 
 	if (rdev->desc->ops->get_voltage_sel) {
 		sel = rdev->desc->ops->get_voltage_sel(rdev);
 		if (sel < 0)
 			return sel;
-		return rdev->desc->ops->list_voltage(rdev, sel);
+		ret = rdev->desc->ops->list_voltage(rdev, sel);
 	}
 	if (rdev->desc->ops->get_voltage)
-		return rdev->desc->ops->get_voltage(rdev);
+		ret = rdev->desc->ops->get_voltage(rdev);
 	else
 		return -EINVAL;
+
+	return ret - rdev->constraints->uV_offset;
 }
 
 /**

commit 492c826b9facefa84995f4dea917e301b5ee0884
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Sun May 8 22:30:18 2011 +0100

    regulator: Remove supply_regulator_dev from machine configuration
    
    supply_regulator_dev (using a struct pointer) has been deprecated in favour
    of supply_regulator (using a regulator name) for quite a few releases
    now with a warning generated if it is used and there are no current in tree
    users so just remove the code.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 98d25fcb3930..432faa5cb8af 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2596,14 +2596,6 @@ struct regulator_dev *regulator_register(struct regulator_desc *regulator_desc,
 	if (ret < 0)
 		goto scrub;
 
-	/* set supply regulator if it exists */
-	if (init_data->supply_regulator && init_data->supply_regulator_dev) {
-		dev_err(dev,
-			"Supply regulator specified by both name and dev\n");
-		ret = -EINVAL;
-		goto scrub;
-	}
-
 	if (init_data->supply_regulator) {
 		struct regulator_dev *r;
 		int found = 0;
@@ -2628,14 +2620,6 @@ struct regulator_dev *regulator_register(struct regulator_desc *regulator_desc,
 			goto scrub;
 	}
 
-	if (init_data->supply_regulator_dev) {
-		dev_warn(dev, "Uses supply_regulator_dev instead of regulator_supply\n");
-		ret = set_supply(rdev,
-			dev_get_drvdata(init_data->supply_regulator_dev));
-		if (ret < 0)
-			goto scrub;
-	}
-
 	/* add consumers devices */
 	for (i = 0; i < init_data->num_consumer_supplies; i++) {
 		ret = set_consumer_device_supply(rdev,

commit 82d158397b6eeb464263a6ef6a739c4118a34720
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon May 9 11:41:02 2011 +0200

    regulator: Factor out references to rdev in regulator_force_disable()
    
    Don't go looking up the rdev pointer every time, just use a local variable
    like everything else.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index a2728a498c3f..98d25fcb3930 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1504,13 +1504,14 @@ static int _regulator_force_disable(struct regulator_dev *rdev,
  */
 int regulator_force_disable(struct regulator *regulator)
 {
+	struct regulator_dev *rdev = regulator->rdev;
 	struct regulator_dev *supply_rdev = NULL;
 	int ret;
 
-	mutex_lock(&regulator->rdev->mutex);
+	mutex_lock(&rdev->mutex);
 	regulator->uA_load = 0;
-	ret = _regulator_force_disable(regulator->rdev, &supply_rdev);
-	mutex_unlock(&regulator->rdev->mutex);
+	ret = _regulator_force_disable(rdev, &supply_rdev);
+	mutex_unlock(&rdev->mutex);
 
 	if (supply_rdev)
 		regulator_disable(get_device_regulator(rdev_get_dev(supply_rdev)));

commit 22c51b47aa7cded7e4768540ebbbfddc91e31d90
Author: Axel Lin <axel.lin@gmail.com>
Date:   Fri Apr 1 18:25:25 2011 +0800

    regulator: Fix the argument of calling regulator_mode_constrain
    
    The second parameter of regulator_mode_constrain takes a pointer.
    
    This patch fixes below warning:
    drivers/regulator/core.c: In function 'regulator_set_mode':
    drivers/regulator/core.c:2014: warning: passing argument 2 of 'regulator_mode_constrain' makes pointer from integer without a cast
    drivers/regulator/core.c:200: note: expected 'int *' but argument is of type 'unsigned int'
    
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@vega.(none)>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 7104404a9fa7..a2728a498c3f 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2011,7 +2011,7 @@ int regulator_set_mode(struct regulator *regulator, unsigned int mode)
 	}
 
 	/* constraints check */
-	ret = regulator_mode_constrain(rdev, mode);
+	ret = regulator_mode_constrain(rdev, &mode);
 	if (ret < 0)
 		goto out;
 

commit 2c6082341d1896218ca974cc2bb6876e36fcba5c
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Mar 30 06:29:12 2011 +0900

    regulator: When constraining modes fall back to higher power modes
    
    If a mode requested by a consumer is not allowed by constraints
    automatically fall back to a higher power mode if possible. This
    ensures that consumers get at least the output they requested while
    allowing machine drivers to transparently limit lower power modes
    if required.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 0fae51c4845a..7104404a9fa7 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -197,9 +197,9 @@ static int regulator_check_current_limit(struct regulator_dev *rdev,
 }
 
 /* operating mode constraint check */
-static int regulator_check_mode(struct regulator_dev *rdev, int mode)
+static int regulator_mode_constrain(struct regulator_dev *rdev, int *mode)
 {
-	switch (mode) {
+	switch (*mode) {
 	case REGULATOR_MODE_FAST:
 	case REGULATOR_MODE_NORMAL:
 	case REGULATOR_MODE_IDLE:
@@ -217,11 +217,17 @@ static int regulator_check_mode(struct regulator_dev *rdev, int mode)
 		rdev_err(rdev, "operation not allowed\n");
 		return -EPERM;
 	}
-	if (!(rdev->constraints->valid_modes_mask & mode)) {
-		rdev_err(rdev, "invalid mode %x\n", mode);
-		return -EINVAL;
+
+	/* The modes are bitmasks, the most power hungry modes having
+	 * the lowest values. If the requested mode isn't supported
+	 * try higher modes. */
+	while (*mode) {
+		if (rdev->constraints->valid_modes_mask & *mode)
+			return 0;
+		*mode /= 2;
 	}
-	return 0;
+
+	return -EINVAL;
 }
 
 /* dynamic regulator mode switching constraint check */
@@ -612,7 +618,7 @@ static void drms_uA_update(struct regulator_dev *rdev)
 						  output_uV, current_uA);
 
 	/* check the new mode is allowed */
-	err = regulator_check_mode(rdev, mode);
+	err = regulator_mode_constrain(rdev, &mode);
 	if (err == 0)
 		rdev->desc->ops->set_mode(rdev, mode);
 }
@@ -2005,7 +2011,7 @@ int regulator_set_mode(struct regulator *regulator, unsigned int mode)
 	}
 
 	/* constraints check */
-	ret = regulator_check_mode(rdev, mode);
+	ret = regulator_mode_constrain(rdev, mode);
 	if (ret < 0)
 		goto out;
 
@@ -2116,7 +2122,7 @@ int regulator_set_optimum_mode(struct regulator *regulator, int uA_load)
 	mode = rdev->desc->ops->get_optimum_mode(rdev,
 						 input_uV, output_uV,
 						 total_uA_load);
-	ret = regulator_check_mode(rdev, mode);
+	ret = regulator_mode_constrain(rdev, &mode);
 	if (ret < 0) {
 		rdev_err(rdev, "failed to get optimum mode @ %d uA %d -> %d uV\n",
 			 total_uA_load, input_uV, output_uV);

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 3ffc6979d164..0fae51c4845a 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1313,7 +1313,7 @@ static int _regulator_enable(struct regulator_dev *rdev)
 				return -EINVAL;
 
 			/* Query before enabling in case configuration
-			 * dependant.  */
+			 * dependent.  */
 			ret = _regulator_get_enable_time(rdev);
 			if (ret >= 0) {
 				delay = ret;

commit 88cd222b259d62148ab8c82398498b1a01314476
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Thu Mar 17 13:24:52 2011 +0100

    regulator: provide consumer interface for fall/rise time
    
    This exposes the functionality for rise/fall fime when setting
    voltage to the consumers.
    
    Cc: Bengt Jonsson <bengt.g.jonsson@stericsson.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index e7e4460dcb92..3ffc6979d164 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1764,6 +1764,51 @@ int regulator_set_voltage(struct regulator *regulator, int min_uV, int max_uV)
 }
 EXPORT_SYMBOL_GPL(regulator_set_voltage);
 
+/**
+ * regulator_set_voltage_time - get raise/fall time
+ * @regulator: regulator source
+ * @old_uV: starting voltage in microvolts
+ * @new_uV: target voltage in microvolts
+ *
+ * Provided with the starting and ending voltage, this function attempts to
+ * calculate the time in microseconds required to rise or fall to this new
+ * voltage.
+ */
+int regulator_set_voltage_time(struct regulator *regulator,
+			       int old_uV, int new_uV)
+{
+	struct regulator_dev	*rdev = regulator->rdev;
+	struct regulator_ops	*ops = rdev->desc->ops;
+	int old_sel = -1;
+	int new_sel = -1;
+	int voltage;
+	int i;
+
+	/* Currently requires operations to do this */
+	if (!ops->list_voltage || !ops->set_voltage_time_sel
+	    || !rdev->desc->n_voltages)
+		return -EINVAL;
+
+	for (i = 0; i < rdev->desc->n_voltages; i++) {
+		/* We only look for exact voltage matches here */
+		voltage = regulator_list_voltage(regulator, i);
+		if (voltage < 0)
+			return -EINVAL;
+		if (voltage == 0)
+			continue;
+		if (voltage == old_uV)
+			old_sel = i;
+		if (voltage == new_uV)
+			new_sel = i;
+	}
+
+	if (old_sel < 0 || new_sel < 0)
+		return -EINVAL;
+
+	return ops->set_voltage_time_sel(rdev, old_sel, new_sel);
+}
+EXPORT_SYMBOL_GPL(regulator_set_voltage_time);
+
 /**
  * regulator_sync_voltage - re-apply last regulator output voltage
  * @regulator: regulator source

commit 77af1b2641faf45788a0d480db94082ebee931dc
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Thu Mar 17 13:24:36 2011 +0100

    regulator: add set_voltage_time_sel infrastructure
    
    This makes it possible to set the stabilization time for voltage
    regulators in the same manner as enable_time(). The interface
    only supports regulators that implements fixed selectors.
    
    Cc: Bengt Jonsson <bengt.g.jonsson@stericsson.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index e611f6797e6a..e7e4460dcb92 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1629,6 +1629,7 @@ static int _regulator_do_set_voltage(struct regulator_dev *rdev,
 				     int min_uV, int max_uV)
 {
 	int ret;
+	int delay = 0;
 	unsigned int selector;
 
 	trace_regulator_set_voltage(rdev_get_name(rdev), min_uV, max_uV);
@@ -1662,6 +1663,22 @@ static int _regulator_do_set_voltage(struct regulator_dev *rdev,
 			}
 		}
 
+		/*
+		 * If we can't obtain the old selector there is not enough
+		 * info to call set_voltage_time_sel().
+		 */
+		if (rdev->desc->ops->set_voltage_time_sel &&
+		    rdev->desc->ops->get_voltage_sel) {
+			unsigned int old_selector = 0;
+
+			ret = rdev->desc->ops->get_voltage_sel(rdev);
+			if (ret < 0)
+				return ret;
+			old_selector = ret;
+			delay = rdev->desc->ops->set_voltage_time_sel(rdev,
+						old_selector, selector);
+		}
+
 		if (best_val != INT_MAX) {
 			ret = rdev->desc->ops->set_voltage_sel(rdev, selector);
 			selector = best_val;
@@ -1672,6 +1689,14 @@ static int _regulator_do_set_voltage(struct regulator_dev *rdev,
 		ret = -EINVAL;
 	}
 
+	/* Insert any necessary delays */
+	if (delay >= 1000) {
+		mdelay(delay / 1000);
+		udelay(delay % 1000);
+	} else if (delay) {
+		udelay(delay);
+	}
+
 	if (ret == 0)
 		_notifier_call_chain(rdev, REGULATOR_EVENT_VOLTAGE_CHANGE,
 				     NULL);

commit 7a32b589a9c856493bccb02db55047edc04eee7b
Author: MyungJoo Ham <myungjoo.ham@samsung.com>
Date:   Fri Mar 11 10:13:59 2011 +0900

    Regulator: add suspend-finish API for regulator core.
    
    The regulator core had suspend-prepare that turns off the regulators
    when entering a system-wide suspend. However, it did not have
    suspend-finish that pairs with suspend-prepare and the regulator core
    has assumed that the regulator devices and their drivers support
    autonomous recover at resume.
    
    This patch adds regulator_suspend_finish that pairs with the
    previously-existed regulator_suspend_prepare. The function
    regulator_suspend_finish turns on the regulators that have always_on set
    or positive use_count so that we can reset the regulator states
    appropriately at resume.
    
    In regulator_suspend_finish, if has_full_constraints, it disables
    unnecessary regulators.
    
    Signed-off-by: MyungJoo Ham <myungjoo.ham@samsung.com>
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    --
    Updates
    v3
            comments corrected (Thanks to Igor)
    v2
            disable unnecessary regulators (Thanks to Mark)
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index a2dc6223e8d2..e611f6797e6a 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2655,6 +2655,47 @@ int regulator_suspend_prepare(suspend_state_t state)
 }
 EXPORT_SYMBOL_GPL(regulator_suspend_prepare);
 
+/**
+ * regulator_suspend_finish - resume regulators from system wide suspend
+ *
+ * Turn on regulators that might be turned off by regulator_suspend_prepare
+ * and that should be turned on according to the regulators properties.
+ */
+int regulator_suspend_finish(void)
+{
+	struct regulator_dev *rdev;
+	int ret = 0, error;
+
+	mutex_lock(&regulator_list_mutex);
+	list_for_each_entry(rdev, &regulator_list, list) {
+		struct regulator_ops *ops = rdev->desc->ops;
+
+		mutex_lock(&rdev->mutex);
+		if ((rdev->use_count > 0  || rdev->constraints->always_on) &&
+				ops->enable) {
+			error = ops->enable(rdev);
+			if (error)
+				ret = error;
+		} else {
+			if (!has_full_constraints)
+				goto unlock;
+			if (!ops->disable)
+				goto unlock;
+			if (ops->is_enabled && !ops->is_enabled(rdev))
+				goto unlock;
+
+			error = ops->disable(rdev);
+			if (error)
+				ret = error;
+		}
+unlock:
+		mutex_unlock(&rdev->mutex);
+	}
+	mutex_unlock(&regulator_list_mutex);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(regulator_suspend_finish);
+
 /**
  * regulator_has_full_constraints - the system has fully specified constraints
  *

commit 23c2f041efa891e6ec0706dc9ad4f776a9aa8c14
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Thu Feb 24 17:39:09 2011 +0000

    regulator: If we fail when setting up a supply say which supply
    
    Makes it a bit easier to identify if it's a problem with the supplies,
    the usual error would be omitting the supply name entirely.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 9fa20957847d..a2dc6223e8d2 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2565,8 +2565,11 @@ struct regulator_dev *regulator_register(struct regulator_desc *regulator_desc,
 			init_data->consumer_supplies[i].dev,
 			init_data->consumer_supplies[i].dev_name,
 			init_data->consumer_supplies[i].supply);
-		if (ret < 0)
+		if (ret < 0) {
+			dev_err(dev, "Failed to set supply %s\n",
+				init_data->consumer_supplies[i].supply);
 			goto unset_supplies;
+		}
 	}
 
 	list_add(&rdev->list, &regulator_list);

commit 1130e5b3ff4a7f3f54a48d46e9d0d81b47765bd8
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Dec 21 23:49:31 2010 +0000

    regulator: Add initial per-regulator debugfs support
    
    We only expose the use and open counts to userspace, providing a tiny
    bit of insight into what the API is up to.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 6066a8f2d5bb..9fa20957847d 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -17,6 +17,7 @@
 
 #include <linux/kernel.h>
 #include <linux/init.h>
+#include <linux/debugfs.h>
 #include <linux/device.h>
 #include <linux/slab.h>
 #include <linux/err.h>
@@ -47,6 +48,10 @@ static LIST_HEAD(regulator_map_list);
 static bool has_full_constraints;
 static bool board_wants_dummy_regulator;
 
+#ifdef CONFIG_DEBUG_FS
+static struct dentry *debugfs_root;
+#endif
+
 /*
  * struct regulator_map
  *
@@ -2404,6 +2409,23 @@ static int add_regulator_attributes(struct regulator_dev *rdev)
 	return status;
 }
 
+static void rdev_init_debugfs(struct regulator_dev *rdev)
+{
+#ifdef CONFIG_DEBUG_FS
+	rdev->debugfs = debugfs_create_dir(rdev_get_name(rdev), debugfs_root);
+	if (IS_ERR(rdev->debugfs) || !rdev->debugfs) {
+		rdev_warn(rdev, "Failed to create debugfs directory\n");
+		rdev->debugfs = NULL;
+		return;
+	}
+
+	debugfs_create_u32("use_count", 0444, rdev->debugfs,
+			   &rdev->use_count);
+	debugfs_create_u32("open_count", 0444, rdev->debugfs,
+			   &rdev->open_count);
+#endif
+}
+
 /**
  * regulator_register - register regulator
  * @regulator_desc: regulator to register
@@ -2548,6 +2570,8 @@ struct regulator_dev *regulator_register(struct regulator_desc *regulator_desc,
 	}
 
 	list_add(&rdev->list, &regulator_list);
+
+	rdev_init_debugfs(rdev);
 out:
 	mutex_unlock(&regulator_list_mutex);
 	return rdev;
@@ -2580,6 +2604,9 @@ void regulator_unregister(struct regulator_dev *rdev)
 		return;
 
 	mutex_lock(&regulator_list_mutex);
+#ifdef CONFIG_DEBUG_FS
+	debugfs_remove_recursive(rdev->debugfs);
+#endif
 	WARN_ON(rdev->open_count);
 	unset_regulator_supplies(rdev);
 	list_del(&rdev->list);
@@ -2723,6 +2750,14 @@ static int __init regulator_init(void)
 
 	ret = class_register(&regulator_class);
 
+#ifdef CONFIG_DEBUG_FS
+	debugfs_root = debugfs_create_dir("regulator", NULL);
+	if (IS_ERR(debugfs_root) || !debugfs_root) {
+		pr_warn("regulator: Failed to create debugfs directory\n");
+		debugfs_root = NULL;
+	}
+#endif
+
 	regulator_dummy_init();
 
 	return ret;

commit 21cf891a47ff5e7bd77fdc524a25072c447d56bb
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Dec 21 23:30:07 2010 +0000

    regulator: Make regulator_has_full_constraints a bool
    
    It's a boolean value so use the type.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 911b774c745c..6066a8f2d5bb 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -44,7 +44,7 @@
 static DEFINE_MUTEX(regulator_list_mutex);
 static LIST_HEAD(regulator_list);
 static LIST_HEAD(regulator_map_list);
-static int has_full_constraints;
+static bool has_full_constraints;
 static bool board_wants_dummy_regulator;
 
 /*

commit 13ce29f80fe3f61d3865b90244b1d1430f553e9f
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Fri Dec 17 16:04:12 2010 +0000

    regulator: Clean up logging a bit
    
    The recent introduction of standard regulator API logging macros means
    that all our log messages have at least the function name in them and
    logging that the constraints are for the regulator API is probably a
    bit much.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index ab419f8b2a84..911b774c745c 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -739,7 +739,7 @@ static void print_constraints(struct regulator_dev *rdev)
 	if (constraints->valid_modes_mask & REGULATOR_MODE_STANDBY)
 		count += sprintf(buf + count, "standby");
 
-	rdev_info(rdev, "regulator: %s\n", buf);
+	rdev_info(rdev, "%s\n", buf);
 }
 
 static int machine_constraints_voltage(struct regulator_dev *rdev,

commit 95a3c23ae620c1b4c499746e70f4034bdc067737
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Thu Dec 16 15:49:37 2010 +0000

    regulator: Optimise out noop voltage changes
    
    If a consumer sets the same voltage range as is currently configured
    for that consumer there's no need to run through setting the voltage
    again. This pattern may occur with some CPUfreq implementations where
    the same voltage range is used for multiple frequencies.
    
    Reported-by: Saravana Kannan <skannan@codeaurora.org>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index a12cba32460e..ab419f8b2a84 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1697,10 +1697,17 @@ static int _regulator_do_set_voltage(struct regulator_dev *rdev,
 int regulator_set_voltage(struct regulator *regulator, int min_uV, int max_uV)
 {
 	struct regulator_dev *rdev = regulator->rdev;
-	int ret;
+	int ret = 0;
 
 	mutex_lock(&rdev->mutex);
 
+	/* If we're setting the same range as last time the change
+	 * should be a noop (some cpufreq implementations use the same
+	 * voltage for multiple frequencies, for example).
+	 */
+	if (regulator->min_uV == min_uV && regulator->max_uV == max_uV)
+		goto out;
+
 	/* sanity check */
 	if (!rdev->desc->ops->set_voltage &&
 	    !rdev->desc->ops->set_voltage_sel) {

commit 606a25628187ce863b48d43ca42bc0cbe8342de9
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Thu Dec 16 15:49:36 2010 +0000

    regulator: Add API to re-apply voltage to hardware
    
    When cooperating with an external control source the regulator setup
    may be changed underneath the API. Currently consumers can just redo
    the regulator_set_voltage() to restore a previously set configuration
    but provide an explicit API for doing this as optimsations in the
    regulator_set_voltage() implementation will shortly prevent that.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 3d72cc8e2f3e..a12cba32460e 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1727,6 +1727,53 @@ int regulator_set_voltage(struct regulator *regulator, int min_uV, int max_uV)
 }
 EXPORT_SYMBOL_GPL(regulator_set_voltage);
 
+/**
+ * regulator_sync_voltage - re-apply last regulator output voltage
+ * @regulator: regulator source
+ *
+ * Re-apply the last configured voltage.  This is intended to be used
+ * where some external control source the consumer is cooperating with
+ * has caused the configured voltage to change.
+ */
+int regulator_sync_voltage(struct regulator *regulator)
+{
+	struct regulator_dev *rdev = regulator->rdev;
+	int ret, min_uV, max_uV;
+
+	mutex_lock(&rdev->mutex);
+
+	if (!rdev->desc->ops->set_voltage &&
+	    !rdev->desc->ops->set_voltage_sel) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	/* This is only going to work if we've had a voltage configured. */
+	if (!regulator->min_uV && !regulator->max_uV) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	min_uV = regulator->min_uV;
+	max_uV = regulator->max_uV;
+
+	/* This should be a paranoia check... */
+	ret = regulator_check_voltage(rdev, &min_uV, &max_uV);
+	if (ret < 0)
+		goto out;
+
+	ret = regulator_check_consumers(rdev, &min_uV, &max_uV);
+	if (ret < 0)
+		goto out;
+
+	ret = _regulator_do_set_voltage(rdev, min_uV, max_uV);
+
+out:
+	mutex_unlock(&rdev->mutex);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(regulator_sync_voltage);
+
 static int _regulator_get_voltage(struct regulator_dev *rdev)
 {
 	int sel;

commit ded06a5270ddd6c3c3e25d9ddcaaaa4cb8385c2f
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Thu Dec 16 13:59:10 2010 +0000

    regulator: Only notify voltage changes when they succeed
    
    Currently we notify a voltage change whenever we exit set_voltage(),
    even if the change failed for some reason (eg, a constraints issue).
    This shouldn't cause any substantial ill effects but is wasteful as
    listeners get notified on noops. Fix this by moving the notification
    into _do_set_voltage() and only notifying if we don't return an error.
    
    Reported-by: Saravana Kannan <skannan@codeaurora.org>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index a0579f069002..3d72cc8e2f3e 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1667,6 +1667,10 @@ static int _regulator_do_set_voltage(struct regulator_dev *rdev,
 		ret = -EINVAL;
 	}
 
+	if (ret == 0)
+		_notifier_call_chain(rdev, REGULATOR_EVENT_VOLTAGE_CHANGE,
+				     NULL);
+
 	trace_regulator_set_voltage_complete(rdev_get_name(rdev), selector);
 
 	return ret;
@@ -1718,7 +1722,6 @@ int regulator_set_voltage(struct regulator *regulator, int min_uV, int max_uV)
 	ret = _regulator_do_set_voltage(rdev, min_uV, max_uV);
 
 out:
-	_notifier_call_chain(rdev, REGULATOR_EVENT_VOLTAGE_CHANGE, NULL);
 	mutex_unlock(&rdev->mutex);
 	return ret;
 }

commit e8eef82b2c652d031bee9dff9762325672f5a1e0
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Sun Dec 12 14:36:17 2010 +0000

    regulator: Provide a selector based set_voltage_sel() operation
    
    Many regulator drivers implement voltage setting by looping through a
    table of possible values, normally because the set of available voltages
    can't be mapped onto selectors with simple calcuation. Factor out these
    loops by providing a variant of set_voltage() which takes a selector rather
    than a voltage range as an argument and implementing a loop through the
    available selectors in the core.
    
    This is not going to be suitable for use with all devices as when the
    regulator voltage can be mapped onto selector values with a simple
    calculation the linear scan through the available values will be more
    expensive than just doing the calculation, especially for regulators
    that provide fine grained voltage control.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 23c5f7c80bff..a0579f069002 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1637,6 +1637,32 @@ static int _regulator_do_set_voltage(struct regulator_dev *rdev,
 								 selector);
 		else
 			selector = -1;
+	} else if (rdev->desc->ops->set_voltage_sel) {
+		int best_val = INT_MAX;
+		int i;
+
+		selector = 0;
+
+		/* Find the smallest voltage that falls within the specified
+		 * range.
+		 */
+		for (i = 0; i < rdev->desc->n_voltages; i++) {
+			ret = rdev->desc->ops->list_voltage(rdev, i);
+			if (ret < 0)
+				continue;
+
+			if (ret < best_val && ret >= min_uV && ret <= max_uV) {
+				best_val = ret;
+				selector = i;
+			}
+		}
+
+		if (best_val != INT_MAX) {
+			ret = rdev->desc->ops->set_voltage_sel(rdev, selector);
+			selector = best_val;
+		} else {
+			ret = -EINVAL;
+		}
 	} else {
 		ret = -EINVAL;
 	}
@@ -1672,7 +1698,8 @@ int regulator_set_voltage(struct regulator *regulator, int min_uV, int max_uV)
 	mutex_lock(&rdev->mutex);
 
 	/* sanity check */
-	if (!rdev->desc->ops->set_voltage) {
+	if (!rdev->desc->ops->set_voltage &&
+	    !rdev->desc->ops->set_voltage_sel) {
 		ret = -EINVAL;
 		goto out;
 	}
@@ -2256,7 +2283,7 @@ static int add_regulator_attributes(struct regulator_dev *rdev)
 		return status;
 
 	/* constraints need specific supporting methods */
-	if (ops->set_voltage) {
+	if (ops->set_voltage || ops->set_voltage_sel) {
 		status = device_create_file(dev, &dev_attr_min_microvolts);
 		if (status < 0)
 			return status;
@@ -2354,12 +2381,18 @@ struct regulator_dev *regulator_register(struct regulator_desc *regulator_desc,
 	/* Only one of each should be implemented */
 	WARN_ON(regulator_desc->ops->get_voltage &&
 		regulator_desc->ops->get_voltage_sel);
+	WARN_ON(regulator_desc->ops->set_voltage &&
+		regulator_desc->ops->set_voltage_sel);
 
 	/* If we're using selectors we must implement list_voltage. */
 	if (regulator_desc->ops->get_voltage_sel &&
 	    !regulator_desc->ops->list_voltage) {
 		return ERR_PTR(-EINVAL);
 	}
+	if (regulator_desc->ops->set_voltage_sel &&
+	    !regulator_desc->ops->list_voltage) {
+		return ERR_PTR(-EINVAL);
+	}
 
 	rdev = kzalloc(sizeof(struct regulator_dev), GFP_KERNEL);
 	if (rdev == NULL)

commit 757902513019e6ee469791ff76f954b19ca8d036
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Sun Dec 12 14:25:50 2010 +0000

    regulator: Factor out voltage set operation into a separate function
    
    Push all the callers of the chip set_voltage() operation out into a single
    function to facilitiate future refactoring.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index b362dbde80f7..23c5f7c80bff 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -83,6 +83,8 @@ static int _regulator_get_current_limit(struct regulator_dev *rdev);
 static unsigned int _regulator_get_mode(struct regulator_dev *rdev);
 static void _notifier_call_chain(struct regulator_dev *rdev,
 				  unsigned long event, void *data);
+static int _regulator_do_set_voltage(struct regulator_dev *rdev,
+				     int min_uV, int max_uV);
 
 static const char *rdev_get_name(struct regulator_dev *rdev)
 {
@@ -745,22 +747,19 @@ static int machine_constraints_voltage(struct regulator_dev *rdev,
 {
 	struct regulator_ops *ops = rdev->desc->ops;
 	int ret;
-	unsigned selector;
 
 	/* do we need to apply the constraint voltage */
 	if (rdev->constraints->apply_uV &&
-		rdev->constraints->min_uV == rdev->constraints->max_uV &&
-		ops->set_voltage) {
-		ret = ops->set_voltage(rdev,
-				       rdev->constraints->min_uV,
-				       rdev->constraints->max_uV,
-				       &selector);
-			if (ret < 0) {
-				rdev_err(rdev, "failed to apply %duV constraint\n",
-					 rdev->constraints->min_uV);
-				rdev->constraints = NULL;
-				return ret;
-			}
+	    rdev->constraints->min_uV == rdev->constraints->max_uV) {
+		ret = _regulator_do_set_voltage(rdev,
+						rdev->constraints->min_uV,
+						rdev->constraints->max_uV);
+		if (ret < 0) {
+			rdev_err(rdev, "failed to apply %duV constraint\n",
+				 rdev->constraints->min_uV);
+			rdev->constraints = NULL;
+			return ret;
+		}
 	}
 
 	/* constrain machine-level voltage specs to fit
@@ -1621,6 +1620,32 @@ int regulator_is_supported_voltage(struct regulator *regulator,
 	return 0;
 }
 
+static int _regulator_do_set_voltage(struct regulator_dev *rdev,
+				     int min_uV, int max_uV)
+{
+	int ret;
+	unsigned int selector;
+
+	trace_regulator_set_voltage(rdev_get_name(rdev), min_uV, max_uV);
+
+	if (rdev->desc->ops->set_voltage) {
+		ret = rdev->desc->ops->set_voltage(rdev, min_uV, max_uV,
+						   &selector);
+
+		if (rdev->desc->ops->list_voltage)
+			selector = rdev->desc->ops->list_voltage(rdev,
+								 selector);
+		else
+			selector = -1;
+	} else {
+		ret = -EINVAL;
+	}
+
+	trace_regulator_set_voltage_complete(rdev_get_name(rdev), selector);
+
+	return ret;
+}
+
 /**
  * regulator_set_voltage - set regulator output voltage
  * @regulator: regulator source
@@ -1643,7 +1668,6 @@ int regulator_set_voltage(struct regulator *regulator, int min_uV, int max_uV)
 {
 	struct regulator_dev *rdev = regulator->rdev;
 	int ret;
-	unsigned selector;
 
 	mutex_lock(&rdev->mutex);
 
@@ -1664,16 +1688,7 @@ int regulator_set_voltage(struct regulator *regulator, int min_uV, int max_uV)
 	if (ret < 0)
 		goto out;
 
-	trace_regulator_set_voltage(rdev_get_name(rdev), min_uV, max_uV);
-
-	ret = rdev->desc->ops->set_voltage(rdev, min_uV, max_uV, &selector);
-
-	if (rdev->desc->ops->list_voltage)
-		selector = rdev->desc->ops->list_voltage(rdev, selector);
-	else
-		selector = -1;
-
-	trace_regulator_set_voltage_complete(rdev_get_name(rdev), selector);
+	ret = _regulator_do_set_voltage(rdev, min_uV, max_uV);
 
 out:
 	_notifier_call_chain(rdev, REGULATOR_EVENT_VOLTAGE_CHANGE, NULL);

commit 476c2d83c7ffb2429b2a504fbdb4326fc8a9d0e8
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Fri Dec 10 17:28:07 2010 +0000

    regulator: Allow drivers to report voltages as selectors
    
    Since drivers already have to provide an API for translating selectors
    into voltages they may as well just report the selector values directly
    to the core API rather than implement the lookup themselves. The old
    interface is left in place for now, but may be removed in future.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 671eb53b5cdc..b362dbde80f7 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -577,7 +577,9 @@ static void drms_uA_update(struct regulator_dev *rdev)
 
 	err = regulator_check_drms(rdev);
 	if (err < 0 || !rdev->desc->ops->get_optimum_mode ||
-	    !rdev->desc->ops->get_voltage || !rdev->desc->ops->set_mode)
+	    (!rdev->desc->ops->get_voltage &&
+	     !rdev->desc->ops->get_voltage_sel) ||
+	    !rdev->desc->ops->set_mode)
 		return;
 
 	/* get output voltage */
@@ -1682,7 +1684,14 @@ EXPORT_SYMBOL_GPL(regulator_set_voltage);
 
 static int _regulator_get_voltage(struct regulator_dev *rdev)
 {
-	/* sanity check */
+	int sel;
+
+	if (rdev->desc->ops->get_voltage_sel) {
+		sel = rdev->desc->ops->get_voltage_sel(rdev);
+		if (sel < 0)
+			return sel;
+		return rdev->desc->ops->list_voltage(rdev, sel);
+	}
 	if (rdev->desc->ops->get_voltage)
 		return rdev->desc->ops->get_voltage(rdev);
 	else
@@ -2191,7 +2200,7 @@ static int add_regulator_attributes(struct regulator_dev *rdev)
 	int			status = 0;
 
 	/* some attributes need specific methods to be displayed */
-	if (ops->get_voltage) {
+	if (ops->get_voltage || ops->get_voltage_sel) {
 		status = device_create_file(dev, &dev_attr_microvolts);
 		if (status < 0)
 			return status;
@@ -2327,6 +2336,16 @@ struct regulator_dev *regulator_register(struct regulator_desc *regulator_desc,
 	if (!init_data)
 		return ERR_PTR(-EINVAL);
 
+	/* Only one of each should be implemented */
+	WARN_ON(regulator_desc->ops->get_voltage &&
+		regulator_desc->ops->get_voltage_sel);
+
+	/* If we're using selectors we must implement list_voltage. */
+	if (regulator_desc->ops->get_voltage_sel &&
+	    !regulator_desc->ops->list_voltage) {
+		return ERR_PTR(-EINVAL);
+	}
+
 	rdev = kzalloc(sizeof(struct regulator_dev), GFP_KERNEL);
 	if (rdev == NULL)
 		return ERR_PTR(-ENOMEM);

commit 1bf5a1f86a328122714680cd59951074b4f31e07
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Fri Dec 10 17:28:06 2010 +0000

    regulator: Use _regulator_get_voltage() consistently
    
    Rather than referencing the get_voltage() operation directly in the
    ops struct use the internal _regulator_get_voltage() API call to do
    so, facilitating refactoring.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 5d07e5dd417f..671eb53b5cdc 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -581,14 +581,15 @@ static void drms_uA_update(struct regulator_dev *rdev)
 		return;
 
 	/* get output voltage */
-	output_uV = rdev->desc->ops->get_voltage(rdev);
+	output_uV = _regulator_get_voltage(rdev);
 	if (output_uV <= 0)
 		return;
 
 	/* get input voltage */
-	if (rdev->supply && rdev->supply->desc->ops->get_voltage)
-		input_uV = rdev->supply->desc->ops->get_voltage(rdev->supply);
-	else
+	input_uV = 0;
+	if (rdev->supply)
+		input_uV = _regulator_get_voltage(rdev);
+	if (input_uV <= 0)
 		input_uV = rdev->constraints->input_uV;
 	if (input_uV <= 0)
 		return;
@@ -1908,16 +1909,17 @@ int regulator_set_optimum_mode(struct regulator *regulator, int uA_load)
 		goto out;
 
 	/* get output voltage */
-	output_uV = rdev->desc->ops->get_voltage(rdev);
+	output_uV = _regulator_get_voltage(rdev);
 	if (output_uV <= 0) {
 		rdev_err(rdev, "invalid output voltage found\n");
 		goto out;
 	}
 
 	/* get input voltage */
-	if (rdev->supply && rdev->supply->desc->ops->get_voltage)
-		input_uV = rdev->supply->desc->ops->get_voltage(rdev->supply);
-	else
+	input_uV = 0;
+	if (rdev->supply)
+		input_uV = _regulator_get_voltage(rdev->supply);
+	if (input_uV <= 0)
 		input_uV = rdev->constraints->input_uV;
 	if (input_uV <= 0) {
 		rdev_err(rdev, "invalid input voltage found\n");

commit 43e7ee33f2a8d20238267b789791386739247478
Author: Joe Perches <joe@perches.com>
Date:   Mon Dec 6 14:05:19 2010 -0800

    drivers/regulator: Update WARN uses
    
    Align arguments.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index a1b12379b09f..5d07e5dd417f 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1379,8 +1379,7 @@ static int _regulator_disable(struct regulator_dev *rdev,
 	*supply_rdev_ptr = NULL;
 
 	if (WARN(rdev->use_count <= 0,
-			"unbalanced disables for %s\n",
-			rdev_get_name(rdev)))
+		 "unbalanced disables for %s\n", rdev_get_name(rdev)))
 		return -EIO;
 
 	/* are we the last user and permitted to disable ? */

commit 05fda3b1abc23d832144e9497fb218870927d645
Author: Thomas Petazzoni <t-petazzoni@ti.com>
Date:   Fri Dec 3 11:31:07 2010 +0100

    regulator: Take into account the requirements of all consumers
    
    Extend the regulator_set_voltage() function to take into account the
    voltage requirements of all consumers of the regulator being changed,
    in order to set the voltage to the minimum voltage acceptable to all
    consumers. The existing behaviour was that the latest
    regulator_set_voltage() call would win over previous
    regulator_set_voltage() calls even if setting the voltage to a
    non-acceptable level from other consumers.
    
    Signed-off-by: Thomas Petazzoni <t-petazzoni@ti.com>
    Cc: Liam Girdwood <lrg@slimlogic.co.uk>
    Cc: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Cc: Kevin Hilman <khilman@deeprootsystems.com>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index e63366f826f9..a1b12379b09f 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -142,6 +142,27 @@ static int regulator_check_voltage(struct regulator_dev *rdev,
 	return 0;
 }
 
+/* Make sure we select a voltage that suits the needs of all
+ * regulator consumers
+ */
+static int regulator_check_consumers(struct regulator_dev *rdev,
+				     int *min_uV, int *max_uV)
+{
+	struct regulator *regulator;
+
+	list_for_each_entry(regulator, &rdev->consumer_list, list) {
+		if (*max_uV > regulator->max_uV)
+			*max_uV = regulator->max_uV;
+		if (*min_uV < regulator->min_uV)
+			*min_uV = regulator->min_uV;
+	}
+
+	if (*min_uV > *max_uV)
+		return -EINVAL;
+
+	return 0;
+}
+
 /* current constraint check */
 static int regulator_check_current_limit(struct regulator_dev *rdev,
 					int *min_uA, int *max_uA)
@@ -1637,6 +1658,10 @@ int regulator_set_voltage(struct regulator *regulator, int min_uV, int max_uV)
 	regulator->min_uV = min_uV;
 	regulator->max_uV = max_uV;
 
+	ret = regulator_check_consumers(rdev, &min_uV, &max_uV);
+	if (ret < 0)
+		goto out;
+
 	trace_regulator_set_voltage(rdev_get_name(rdev), min_uV, max_uV);
 
 	ret = rdev->desc->ops->set_voltage(rdev, min_uV, max_uV, &selector);

commit 5da84fd99bb1ab1c7cd39d0cf7c08bb63931a59a
Author: Joe Perches <joe@perches.com>
Date:   Tue Nov 30 05:53:48 2010 -0800

    regulator: Add and use rdev_<level> macros
    
    On Tue, 2010-11-30 at 10:52 +0000, Mark Brown wrote:
    > On Mon, Nov 29, 2010 at 05:12:56PM -0800, Joe Perches wrote:
    > > Just to please broonie...
    > > Signed-off-by: Joe Perches <joe@perches.com>
    > As usual when fixing review issues please revise your original patch
    > rather than posting a fresh patch.
    
    Here's an earlier comment:
    
    On Thu, 2010-11-18 at 13:30 +0000, Mark Brown wrote:
    > This looks reasonable, please rebase on top of Daniel's patches and
    > submit it properly (with changelog and so on).
    
    Sometimes it's simpler for an upstream maintainer to do
    something like:
    
    git am -s <patch1.mbox>
    patch -p1 < patch2.mbox
    git commit --amend file
    
    instead of back and forthing.
    
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 40cf7b9ea943..e63366f826f9 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -32,6 +32,15 @@
 
 #include "dummy.h"
 
+#define rdev_err(rdev, fmt, ...)					\
+	pr_err("%s: " fmt, rdev_get_name(rdev), ##__VA_ARGS__)
+#define rdev_warn(rdev, fmt, ...)					\
+	pr_warn("%s: " fmt, rdev_get_name(rdev), ##__VA_ARGS__)
+#define rdev_info(rdev, fmt, ...)					\
+	pr_info("%s: " fmt, rdev_get_name(rdev), ##__VA_ARGS__)
+#define rdev_dbg(rdev, fmt, ...)					\
+	pr_debug("%s: " fmt, rdev_get_name(rdev), ##__VA_ARGS__)
+
 static DEFINE_MUTEX(regulator_list_mutex);
 static LIST_HEAD(regulator_list);
 static LIST_HEAD(regulator_map_list);
@@ -114,11 +123,11 @@ static int regulator_check_voltage(struct regulator_dev *rdev,
 	BUG_ON(*min_uV > *max_uV);
 
 	if (!rdev->constraints) {
-		pr_err("no constraints for %s\n", rdev_get_name(rdev));
+		rdev_err(rdev, "no constraints\n");
 		return -ENODEV;
 	}
 	if (!(rdev->constraints->valid_ops_mask & REGULATOR_CHANGE_VOLTAGE)) {
-		pr_err("operation not allowed for %s\n", rdev_get_name(rdev));
+		rdev_err(rdev, "operation not allowed\n");
 		return -EPERM;
 	}
 
@@ -140,11 +149,11 @@ static int regulator_check_current_limit(struct regulator_dev *rdev,
 	BUG_ON(*min_uA > *max_uA);
 
 	if (!rdev->constraints) {
-		pr_err("no constraints for %s\n", rdev_get_name(rdev));
+		rdev_err(rdev, "no constraints\n");
 		return -ENODEV;
 	}
 	if (!(rdev->constraints->valid_ops_mask & REGULATOR_CHANGE_CURRENT)) {
-		pr_err("operation not allowed for %s\n", rdev_get_name(rdev));
+		rdev_err(rdev, "operation not allowed\n");
 		return -EPERM;
 	}
 
@@ -173,15 +182,15 @@ static int regulator_check_mode(struct regulator_dev *rdev, int mode)
 	}
 
 	if (!rdev->constraints) {
-		pr_err("no constraints for %s\n", rdev_get_name(rdev));
+		rdev_err(rdev, "no constraints\n");
 		return -ENODEV;
 	}
 	if (!(rdev->constraints->valid_ops_mask & REGULATOR_CHANGE_MODE)) {
-		pr_err("operation not allowed for %s\n", rdev_get_name(rdev));
+		rdev_err(rdev, "operation not allowed\n");
 		return -EPERM;
 	}
 	if (!(rdev->constraints->valid_modes_mask & mode)) {
-		pr_err("invalid mode %x for %s\n", mode, rdev_get_name(rdev));
+		rdev_err(rdev, "invalid mode %x\n", mode);
 		return -EINVAL;
 	}
 	return 0;
@@ -191,11 +200,11 @@ static int regulator_check_mode(struct regulator_dev *rdev, int mode)
 static int regulator_check_drms(struct regulator_dev *rdev)
 {
 	if (!rdev->constraints) {
-		pr_err("no constraints for %s\n", rdev_get_name(rdev));
+		rdev_err(rdev, "no constraints\n");
 		return -ENODEV;
 	}
 	if (!(rdev->constraints->valid_ops_mask & REGULATOR_CHANGE_DRMS)) {
-		pr_err("operation not allowed for %s\n", rdev_get_name(rdev));
+		rdev_err(rdev, "operation not allowed\n");
 		return -EPERM;
 	}
 	return 0;
@@ -592,18 +601,17 @@ static int suspend_set_state(struct regulator_dev *rdev,
 	 */
 	if (!rstate->enabled && !rstate->disabled) {
 		if (can_set_state)
-			pr_warning("No configuration for %s\n",
-				   rdev_get_name(rdev));
+			rdev_warn(rdev, "No configuration\n");
 		return 0;
 	}
 
 	if (rstate->enabled && rstate->disabled) {
-		pr_err("invalid configuration for %s\n", rdev_get_name(rdev));
+		rdev_err(rdev, "invalid configuration\n");
 		return -EINVAL;
 	}
 
 	if (!can_set_state) {
-		pr_err("no way to set suspend state\n");
+		rdev_err(rdev, "no way to set suspend state\n");
 		return -EINVAL;
 	}
 
@@ -612,14 +620,14 @@ static int suspend_set_state(struct regulator_dev *rdev,
 	else
 		ret = rdev->desc->ops->set_suspend_disable(rdev);
 	if (ret < 0) {
-		pr_err("failed to enabled/disable\n");
+		rdev_err(rdev, "failed to enabled/disable\n");
 		return ret;
 	}
 
 	if (rdev->desc->ops->set_suspend_voltage && rstate->uV > 0) {
 		ret = rdev->desc->ops->set_suspend_voltage(rdev, rstate->uV);
 		if (ret < 0) {
-			pr_err("failed to set voltage\n");
+			rdev_err(rdev, "failed to set voltage\n");
 			return ret;
 		}
 	}
@@ -627,7 +635,7 @@ static int suspend_set_state(struct regulator_dev *rdev,
 	if (rdev->desc->ops->set_suspend_mode && rstate->mode > 0) {
 		ret = rdev->desc->ops->set_suspend_mode(rdev, rstate->mode);
 		if (ret < 0) {
-			pr_err("failed to set mode\n");
+			rdev_err(rdev, "failed to set mode\n");
 			return ret;
 		}
 	}
@@ -705,14 +713,13 @@ static void print_constraints(struct regulator_dev *rdev)
 	if (constraints->valid_modes_mask & REGULATOR_MODE_STANDBY)
 		count += sprintf(buf + count, "standby");
 
-	printk(KERN_INFO "regulator: %s: %s\n", rdev_get_name(rdev), buf);
+	rdev_info(rdev, "regulator: %s\n", buf);
 }
 
 static int machine_constraints_voltage(struct regulator_dev *rdev,
 	struct regulation_constraints *constraints)
 {
 	struct regulator_ops *ops = rdev->desc->ops;
-	const char *name = rdev_get_name(rdev);
 	int ret;
 	unsigned selector;
 
@@ -725,8 +732,8 @@ static int machine_constraints_voltage(struct regulator_dev *rdev,
 				       rdev->constraints->max_uV,
 				       &selector);
 			if (ret < 0) {
-				pr_err("failed to apply %duV constraint to %s\n",
-					rdev->constraints->min_uV, name);
+				rdev_err(rdev, "failed to apply %duV constraint\n",
+					 rdev->constraints->min_uV);
 				rdev->constraints = NULL;
 				return ret;
 			}
@@ -758,8 +765,7 @@ static int machine_constraints_voltage(struct regulator_dev *rdev,
 
 		/* else require explicit machine-level constraints */
 		if (cmin <= 0 || cmax <= 0 || cmax < cmin) {
-			pr_err("invalid '%s' voltage constraints\n",
-				name);
+			rdev_err(rdev, "invalid voltage constraints\n");
 			return -EINVAL;
 		}
 
@@ -780,20 +786,19 @@ static int machine_constraints_voltage(struct regulator_dev *rdev,
 
 		/* final: [min_uV..max_uV] valid iff constraints valid */
 		if (max_uV < min_uV) {
-			pr_err("unsupportable '%s' voltage constraints\n",
-				name);
+			rdev_err(rdev, "unsupportable voltage constraints\n");
 			return -EINVAL;
 		}
 
 		/* use regulator's subset of machine constraints */
 		if (constraints->min_uV < min_uV) {
-			pr_debug("override '%s' min_uV, %d -> %d\n",
-				 name, constraints->min_uV, min_uV);
+			rdev_dbg(rdev, "override min_uV, %d -> %d\n",
+				 constraints->min_uV, min_uV);
 			constraints->min_uV = min_uV;
 		}
 		if (constraints->max_uV > max_uV) {
-			pr_debug("override '%s' max_uV, %d -> %d\n",
-				 name, constraints->max_uV, max_uV);
+			rdev_dbg(rdev, "override max_uV, %d -> %d\n",
+				 constraints->max_uV, max_uV);
 			constraints->max_uV = max_uV;
 		}
 	}
@@ -816,7 +821,6 @@ static int set_machine_constraints(struct regulator_dev *rdev,
 	const struct regulation_constraints *constraints)
 {
 	int ret = 0;
-	const char *name;
 	struct regulator_ops *ops = rdev->desc->ops;
 
 	rdev->constraints = kmemdup(constraints, sizeof(*constraints),
@@ -824,8 +828,6 @@ static int set_machine_constraints(struct regulator_dev *rdev,
 	if (!rdev->constraints)
 		return -ENOMEM;
 
-	name = rdev_get_name(rdev);
-
 	ret = machine_constraints_voltage(rdev, rdev->constraints);
 	if (ret != 0)
 		goto out;
@@ -834,8 +836,7 @@ static int set_machine_constraints(struct regulator_dev *rdev,
 	if (constraints->initial_state) {
 		ret = suspend_prepare(rdev, rdev->constraints->initial_state);
 		if (ret < 0) {
-			pr_err("failed to set suspend state for %s\n",
-				name);
+			rdev_err(rdev, "failed to set suspend state\n");
 			rdev->constraints = NULL;
 			goto out;
 		}
@@ -843,16 +844,14 @@ static int set_machine_constraints(struct regulator_dev *rdev,
 
 	if (constraints->initial_mode) {
 		if (!ops->set_mode) {
-			pr_err("no set_mode operation for %s\n",
-				name);
+			rdev_err(rdev, "no set_mode operation\n");
 			ret = -EINVAL;
 			goto out;
 		}
 
 		ret = ops->set_mode(rdev, rdev->constraints->initial_mode);
 		if (ret < 0) {
-			pr_err("failed to set initial mode for %s: %d\n",
-				name, ret);
+			rdev_err(rdev, "failed to set initial mode: %d\n", ret);
 			goto out;
 		}
 	}
@@ -864,7 +863,7 @@ static int set_machine_constraints(struct regulator_dev *rdev,
 	    ops->enable) {
 		ret = ops->enable(rdev);
 		if (ret < 0) {
-			pr_err("failed to enable %s\n", name);
+			rdev_err(rdev, "failed to enable\n");
 			rdev->constraints = NULL;
 			goto out;
 		}
@@ -892,8 +891,8 @@ static int set_supply(struct regulator_dev *rdev,
 	err = sysfs_create_link(&rdev->dev.kobj, &supply_rdev->dev.kobj,
 				"supply");
 	if (err) {
-		pr_err("could not add device link %s err %d\n",
-			supply_rdev->dev.kobj.name, err);
+		rdev_err(rdev, "could not add device link %s err %d\n",
+			 supply_rdev->dev.kobj.name, err);
 		       goto out;
 	}
 	rdev->supply = supply_rdev;
@@ -949,10 +948,10 @@ static int set_consumer_device_supply(struct regulator_dev *rdev,
 			continue;
 
 		dev_dbg(consumer_dev, "%s/%s is '%s' supply; fail %s/%s\n",
-				dev_name(&node->regulator->dev),
-				node->regulator->desc->name,
-				supply,
-				dev_name(&rdev->dev), rdev_get_name(rdev));
+			dev_name(&node->regulator->dev),
+			node->regulator->desc->name,
+			supply,
+			dev_name(&rdev->dev), rdev_get_name(rdev));
 		return -EBUSY;
 	}
 
@@ -1023,8 +1022,7 @@ static struct regulator *create_regulator(struct regulator_dev *rdev,
 		regulator->dev_attr.show = device_requested_uA_show;
 		err = device_create_file(dev, &regulator->dev_attr);
 		if (err < 0) {
-			pr_warning("could not add regulator_dev"
-				" requested microamps sysfs entry\n");
+			rdev_warn(rdev, "could not add regulator_dev requested microamps sysfs entry\n");
 			goto attr_name_err;
 		}
 
@@ -1041,8 +1039,8 @@ static struct regulator *create_regulator(struct regulator_dev *rdev,
 		err = sysfs_create_link(&rdev->dev.kobj, &dev->kobj,
 					buf);
 		if (err) {
-			pr_warning("could not add device link %s err %d\n",
-			       dev->kobj.name, err);
+			rdev_warn(rdev, "could not add device link %s err %d\n",
+				  dev->kobj.name, err);
 			goto link_name_err;
 		}
 	}
@@ -1079,7 +1077,7 @@ static struct regulator *_regulator_get(struct device *dev, const char *id,
 	int ret;
 
 	if (id == NULL) {
-		pr_err("regulator: get() with no identifier\n");
+		pr_err("get() with no identifier\n");
 		return regulator;
 	}
 
@@ -1113,8 +1111,8 @@ static struct regulator *_regulator_get(struct device *dev, const char *id,
 	 * substitute in a dummy regulator so consumers can continue.
 	 */
 	if (!has_full_constraints) {
-		pr_warning("%s supply %s not found, using dummy regulator\n",
-			   devname, id);
+		pr_warn("%s supply %s not found, using dummy regulator\n",
+			devname, id);
 		rdev = dummy_regulator_rdev;
 		goto found;
 	}
@@ -1265,8 +1263,7 @@ static int _regulator_enable(struct regulator_dev *rdev)
 			ret = _regulator_enable(rdev->supply);
 			mutex_unlock(&rdev->supply->mutex);
 			if (ret < 0) {
-				pr_err("failed to enable %s: %d\n",
-				       rdev_get_name(rdev), ret);
+				rdev_err(rdev, "failed to enable: %d\n", ret);
 				return ret;
 			}
 		}
@@ -1293,8 +1290,7 @@ static int _regulator_enable(struct regulator_dev *rdev)
 			if (ret >= 0) {
 				delay = ret;
 			} else {
-				pr_warning("enable_time() failed for %s: %d\n",
-					   rdev_get_name(rdev),
+				rdev_warn(rdev, "enable_time() failed: %d\n",
 					   ret);
 				delay = 0;
 			}
@@ -1320,8 +1316,7 @@ static int _regulator_enable(struct regulator_dev *rdev)
 			trace_regulator_enable_complete(rdev_get_name(rdev));
 
 		} else if (ret < 0) {
-			pr_err("is_enabled() failed for %s: %d\n",
-				rdev_get_name(rdev), ret);
+			rdev_err(rdev, "is_enabled() failed: %d\n", ret);
 			return ret;
 		}
 		/* Fallthrough on positive return values - already enabled */
@@ -1378,8 +1373,7 @@ static int _regulator_disable(struct regulator_dev *rdev,
 
 			ret = rdev->desc->ops->disable(rdev);
 			if (ret < 0) {
-				pr_err("failed to disable %s\n",
-					rdev_get_name(rdev));
+				rdev_err(rdev, "failed to disable\n");
 				return ret;
 			}
 
@@ -1451,8 +1445,7 @@ static int _regulator_force_disable(struct regulator_dev *rdev,
 		/* ah well, who wants to live forever... */
 		ret = rdev->desc->ops->disable(rdev);
 		if (ret < 0) {
-			pr_err("failed to force disable %s\n",
-				rdev_get_name(rdev));
+			rdev_err(rdev, "failed to force disable\n");
 			return ret;
 		}
 		/* notify other consumers that power has been forced off */
@@ -1893,8 +1886,7 @@ int regulator_set_optimum_mode(struct regulator *regulator, int uA_load)
 	/* get output voltage */
 	output_uV = rdev->desc->ops->get_voltage(rdev);
 	if (output_uV <= 0) {
-		pr_err("invalid output voltage found for %s\n",
-			rdev_get_name(rdev));
+		rdev_err(rdev, "invalid output voltage found\n");
 		goto out;
 	}
 
@@ -1904,8 +1896,7 @@ int regulator_set_optimum_mode(struct regulator *regulator, int uA_load)
 	else
 		input_uV = rdev->constraints->input_uV;
 	if (input_uV <= 0) {
-		pr_err("invalid input voltage found for %s\n",
-			rdev_get_name(rdev));
+		rdev_err(rdev, "invalid input voltage found\n");
 		goto out;
 	}
 
@@ -1918,16 +1909,14 @@ int regulator_set_optimum_mode(struct regulator *regulator, int uA_load)
 						 total_uA_load);
 	ret = regulator_check_mode(rdev, mode);
 	if (ret < 0) {
-		pr_err("failed to get optimum mode for %s @"
-			" %d uA %d -> %d uV\n",  rdev_get_name(rdev),
-			total_uA_load, input_uV, output_uV);
+		rdev_err(rdev, "failed to get optimum mode @ %d uA %d -> %d uV\n",
+			 total_uA_load, input_uV, output_uV);
 		goto out;
 	}
 
 	ret = rdev->desc->ops->set_mode(rdev, mode);
 	if (ret < 0) {
-		pr_err("failed to set optimum mode %x for %s\n",
-			 mode, rdev_get_name(rdev));
+		rdev_err(rdev, "failed to set optimum mode %x\n", mode);
 		goto out;
 	}
 	ret = mode;
@@ -2058,7 +2047,7 @@ int regulator_bulk_enable(int num_consumers,
 	return 0;
 
 err:
-	printk(KERN_ERR "Failed to enable %s: %d\n", consumers[i].supply, ret);
+	pr_err("Failed to enable %s: %d\n", consumers[i].supply, ret);
 	for (--i; i >= 0; --i)
 		regulator_disable(consumers[i].consumer);
 
@@ -2093,8 +2082,7 @@ int regulator_bulk_disable(int num_consumers,
 	return 0;
 
 err:
-	printk(KERN_ERR "Failed to disable %s: %d\n", consumers[i].supply,
-	       ret);
+	pr_err("Failed to disable %s: %d\n", consumers[i].supply, ret);
 	for (--i; i >= 0; --i)
 		regulator_enable(consumers[i].consumer);
 
@@ -2477,7 +2465,7 @@ int regulator_suspend_prepare(suspend_state_t state)
 		mutex_unlock(&rdev->mutex);
 
 		if (ret < 0) {
-			pr_err("failed to prepare %s\n", rdev_get_name(rdev));
+			rdev_err(rdev, "failed to prepare\n");
 			goto out;
 		}
 	}
@@ -2599,7 +2587,6 @@ static int __init regulator_init_complete(void)
 	struct regulator_ops *ops;
 	struct regulation_constraints *c;
 	int enabled, ret;
-	const char *name;
 
 	mutex_lock(&regulator_list_mutex);
 
@@ -2611,8 +2598,6 @@ static int __init regulator_init_complete(void)
 		ops = rdev->desc->ops;
 		c = rdev->constraints;
 
-		name = rdev_get_name(rdev);
-
 		if (!ops->disable || (c && c->always_on))
 			continue;
 
@@ -2633,10 +2618,10 @@ static int __init regulator_init_complete(void)
 		if (has_full_constraints) {
 			/* We log since this may kill the system if it
 			 * goes wrong. */
-			pr_info("disabling %s\n", name);
+			rdev_info(rdev, "disabling\n");
 			ret = ops->disable(rdev);
 			if (ret != 0) {
-				pr_err("couldn't disable %s: %d\n", name, ret);
+				rdev_err(rdev, "couldn't disable: %d\n", ret);
 			}
 		} else {
 			/* The intention is that in future we will
@@ -2644,8 +2629,7 @@ static int __init regulator_init_complete(void)
 			 * so warn even if we aren't going to do
 			 * anything here.
 			 */
-			pr_warning("incomplete constraints, leaving %s on\n",
-				   name);
+			rdev_warn(rdev, "incomplete constraints, leaving on\n");
 		}
 
 unlock:

commit f8c12fe329c8da9f50d8b2b1183eeaa4d587e747
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Nov 29 15:55:17 2010 +0000

    regulator: Copy constraints from regulators when initialising them
    
    Currently the regulator API uses the constraints structure passed in to
    the core throughout the lifetime of the object. This means that it is not
    possible to mark the constraints as __initdata so if the kernel supports
    many boards the constraints for all of them are kept around throughout the
    lifetime of the system, consuming memory needlessly. By copying constraints
    that are actually used we allow the use of __initdata, saving memory when
    multiple boards are supported.
    
    This also means the constraints can be const.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 64a56a7a1f9d..40cf7b9ea943 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -813,23 +813,26 @@ static int machine_constraints_voltage(struct regulator_dev *rdev,
  * set_mode.
  */
 static int set_machine_constraints(struct regulator_dev *rdev,
-	struct regulation_constraints *constraints)
+	const struct regulation_constraints *constraints)
 {
 	int ret = 0;
 	const char *name;
 	struct regulator_ops *ops = rdev->desc->ops;
 
-	rdev->constraints = constraints;
+	rdev->constraints = kmemdup(constraints, sizeof(*constraints),
+				    GFP_KERNEL);
+	if (!rdev->constraints)
+		return -ENOMEM;
 
 	name = rdev_get_name(rdev);
 
-	ret = machine_constraints_voltage(rdev, constraints);
+	ret = machine_constraints_voltage(rdev, rdev->constraints);
 	if (ret != 0)
 		goto out;
 
 	/* do we need to setup our suspend state */
 	if (constraints->initial_state) {
-		ret = suspend_prepare(rdev, constraints->initial_state);
+		ret = suspend_prepare(rdev, rdev->constraints->initial_state);
 		if (ret < 0) {
 			pr_err("failed to set suspend state for %s\n",
 				name);
@@ -846,7 +849,7 @@ static int set_machine_constraints(struct regulator_dev *rdev,
 			goto out;
 		}
 
-		ret = ops->set_mode(rdev, constraints->initial_mode);
+		ret = ops->set_mode(rdev, rdev->constraints->initial_mode);
 		if (ret < 0) {
 			pr_err("failed to set initial mode for %s: %d\n",
 				name, ret);
@@ -857,7 +860,8 @@ static int set_machine_constraints(struct regulator_dev *rdev,
 	/* If the constraints say the regulator should be on at this point
 	 * and we have control then make sure it is enabled.
 	 */
-	if ((constraints->always_on || constraints->boot_on) && ops->enable) {
+	if ((rdev->constraints->always_on || rdev->constraints->boot_on) &&
+	    ops->enable) {
 		ret = ops->enable(rdev);
 		if (ret < 0) {
 			pr_err("failed to enable %s\n", name);
@@ -2289,7 +2293,7 @@ static int add_regulator_attributes(struct regulator_dev *rdev)
  * Returns 0 on success.
  */
 struct regulator_dev *regulator_register(struct regulator_desc *regulator_desc,
-	struct device *dev, struct regulator_init_data *init_data,
+	struct device *dev, const struct regulator_init_data *init_data,
 	void *driver_data)
 {
 	static atomic_t regulator_no = ATOMIC_INIT(0);
@@ -2444,6 +2448,7 @@ void regulator_unregister(struct regulator_dev *rdev)
 	if (rdev->supply)
 		sysfs_remove_link(&rdev->dev.kobj, "supply");
 	device_unregister(&rdev->dev);
+	kfree(rdev->constraints);
 	mutex_unlock(&regulator_list_mutex);
 }
 EXPORT_SYMBOL_GPL(regulator_unregister);

commit 50ba5ca4be30674517ca33425648ec43d93f9a69
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Nov 22 13:51:19 2010 +0000

    regulator: Remove regulator core version announcement
    
    The version hasn't been updated since the regulator API was merged in
    2.6.27 so just remove it - now we're in mainline the kernel version is
    much more useful.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index fe47860c6633..64a56a7a1f9d 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -32,8 +32,6 @@
 
 #include "dummy.h"
 
-#define REGULATOR_VERSION "0.5"
-
 static DEFINE_MUTEX(regulator_list_mutex);
 static LIST_HEAD(regulator_list);
 static LIST_HEAD(regulator_map_list);
@@ -2580,8 +2578,6 @@ static int __init regulator_init(void)
 {
 	int ret;
 
-	printk(KERN_INFO "regulator: core version %s\n", REGULATOR_VERSION);
-
 	ret = class_register(&regulator_class);
 
 	regulator_dummy_init();

commit 4c35508fc0b7883820923b3b8eb9fea25d35cf72
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Nov 22 13:51:18 2010 +0000

    regulator: Fix obfuscated log messages
    
    Don't use %s to format fixed static strings into log messages, it just
    makes searching for and reading the message in the kernel source
    needlessly hard.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 8d492f40cebf..fe47860c6633 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -760,7 +760,7 @@ static int machine_constraints_voltage(struct regulator_dev *rdev,
 
 		/* else require explicit machine-level constraints */
 		if (cmin <= 0 || cmax <= 0 || cmax < cmin) {
-			pr_err("%s '%s' voltage constraints\n", "invalid",
+			pr_err("invalid '%s' voltage constraints\n",
 				name);
 			return -EINVAL;
 		}
@@ -782,22 +782,20 @@ static int machine_constraints_voltage(struct regulator_dev *rdev,
 
 		/* final: [min_uV..max_uV] valid iff constraints valid */
 		if (max_uV < min_uV) {
-			pr_err("%s '%s' voltage constraints\n", "unsupportable",
+			pr_err("unsupportable '%s' voltage constraints\n",
 				name);
 			return -EINVAL;
 		}
 
 		/* use regulator's subset of machine constraints */
 		if (constraints->min_uV < min_uV) {
-			pr_debug("override '%s' %s, %d -> %d\n",
-				 name, "min_uV",
-				 constraints->min_uV, min_uV);
+			pr_debug("override '%s' min_uV, %d -> %d\n",
+				 name, constraints->min_uV, min_uV);
 			constraints->min_uV = min_uV;
 		}
 		if (constraints->max_uV > max_uV) {
-			pr_debug("override '%s' %s, %d -> %d\n",
-				 name, "max_uV",
-				 constraints->max_uV, max_uV);
+			pr_debug("override '%s' max_uV, %d -> %d\n",
+				 name, constraints->max_uV, max_uV);
 			constraints->max_uV = max_uV;
 		}
 	}

commit 1d7372e15ebd7f56a336fabe6ee31f8e692cd9cb
Author: Daniel Walker <dwalker@codeaurora.org>
Date:   Wed Nov 17 15:30:28 2010 -0800

    drivers: regulator: core: convert to using pr_ macros
    
    The regulator framework uses a lot of printks with a
    specific formatting using __func__. This converts them
    to use pr_ calls with a central format string.
    
    Cc: bleong@codeaurora.org
    Signed-off-by: Daniel Walker <dwalker@codeaurora.org>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 7c0906367239..8d492f40cebf 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -13,7 +13,7 @@
  *
  */
 
-#define pr_fmt(fmt) "%s:" fmt, __func__
+#define pr_fmt(fmt) "%s: " fmt, __func__
 
 #include <linux/kernel.h>
 #include <linux/init.h>
@@ -116,13 +116,11 @@ static int regulator_check_voltage(struct regulator_dev *rdev,
 	BUG_ON(*min_uV > *max_uV);
 
 	if (!rdev->constraints) {
-		printk(KERN_ERR "%s: no constraints for %s\n", __func__,
-		       rdev_get_name(rdev));
+		pr_err("no constraints for %s\n", rdev_get_name(rdev));
 		return -ENODEV;
 	}
 	if (!(rdev->constraints->valid_ops_mask & REGULATOR_CHANGE_VOLTAGE)) {
-		printk(KERN_ERR "%s: operation not allowed for %s\n",
-		       __func__, rdev_get_name(rdev));
+		pr_err("operation not allowed for %s\n", rdev_get_name(rdev));
 		return -EPERM;
 	}
 
@@ -144,13 +142,11 @@ static int regulator_check_current_limit(struct regulator_dev *rdev,
 	BUG_ON(*min_uA > *max_uA);
 
 	if (!rdev->constraints) {
-		printk(KERN_ERR "%s: no constraints for %s\n", __func__,
-		       rdev_get_name(rdev));
+		pr_err("no constraints for %s\n", rdev_get_name(rdev));
 		return -ENODEV;
 	}
 	if (!(rdev->constraints->valid_ops_mask & REGULATOR_CHANGE_CURRENT)) {
-		printk(KERN_ERR "%s: operation not allowed for %s\n",
-		       __func__, rdev_get_name(rdev));
+		pr_err("operation not allowed for %s\n", rdev_get_name(rdev));
 		return -EPERM;
 	}
 
@@ -179,18 +175,15 @@ static int regulator_check_mode(struct regulator_dev *rdev, int mode)
 	}
 
 	if (!rdev->constraints) {
-		printk(KERN_ERR "%s: no constraints for %s\n", __func__,
-		       rdev_get_name(rdev));
+		pr_err("no constraints for %s\n", rdev_get_name(rdev));
 		return -ENODEV;
 	}
 	if (!(rdev->constraints->valid_ops_mask & REGULATOR_CHANGE_MODE)) {
-		printk(KERN_ERR "%s: operation not allowed for %s\n",
-		       __func__, rdev_get_name(rdev));
+		pr_err("operation not allowed for %s\n", rdev_get_name(rdev));
 		return -EPERM;
 	}
 	if (!(rdev->constraints->valid_modes_mask & mode)) {
-		printk(KERN_ERR "%s: invalid mode %x for %s\n",
-		       __func__, mode, rdev_get_name(rdev));
+		pr_err("invalid mode %x for %s\n", mode, rdev_get_name(rdev));
 		return -EINVAL;
 	}
 	return 0;
@@ -200,13 +193,11 @@ static int regulator_check_mode(struct regulator_dev *rdev, int mode)
 static int regulator_check_drms(struct regulator_dev *rdev)
 {
 	if (!rdev->constraints) {
-		printk(KERN_ERR "%s: no constraints for %s\n", __func__,
-		       rdev_get_name(rdev));
+		pr_err("no constraints for %s\n", rdev_get_name(rdev));
 		return -ENODEV;
 	}
 	if (!(rdev->constraints->valid_ops_mask & REGULATOR_CHANGE_DRMS)) {
-		printk(KERN_ERR "%s: operation not allowed for %s\n",
-		       __func__, rdev_get_name(rdev));
+		pr_err("operation not allowed for %s\n", rdev_get_name(rdev));
 		return -EPERM;
 	}
 	return 0;
@@ -603,20 +594,18 @@ static int suspend_set_state(struct regulator_dev *rdev,
 	 */
 	if (!rstate->enabled && !rstate->disabled) {
 		if (can_set_state)
-			printk(KERN_WARNING "%s: No configuration for %s\n",
-			       __func__, rdev_get_name(rdev));
+			pr_warning("No configuration for %s\n",
+				   rdev_get_name(rdev));
 		return 0;
 	}
 
 	if (rstate->enabled && rstate->disabled) {
-		printk(KERN_ERR "%s: invalid configuration for %s\n",
-		       __func__, rdev_get_name(rdev));
+		pr_err("invalid configuration for %s\n", rdev_get_name(rdev));
 		return -EINVAL;
 	}
 
 	if (!can_set_state) {
-		printk(KERN_ERR "%s: no way to set suspend state\n",
-			__func__);
+		pr_err("no way to set suspend state\n");
 		return -EINVAL;
 	}
 
@@ -625,15 +614,14 @@ static int suspend_set_state(struct regulator_dev *rdev,
 	else
 		ret = rdev->desc->ops->set_suspend_disable(rdev);
 	if (ret < 0) {
-		printk(KERN_ERR "%s: failed to enabled/disable\n", __func__);
+		pr_err("failed to enabled/disable\n");
 		return ret;
 	}
 
 	if (rdev->desc->ops->set_suspend_voltage && rstate->uV > 0) {
 		ret = rdev->desc->ops->set_suspend_voltage(rdev, rstate->uV);
 		if (ret < 0) {
-			printk(KERN_ERR "%s: failed to set voltage\n",
-				__func__);
+			pr_err("failed to set voltage\n");
 			return ret;
 		}
 	}
@@ -641,7 +629,7 @@ static int suspend_set_state(struct regulator_dev *rdev,
 	if (rdev->desc->ops->set_suspend_mode && rstate->mode > 0) {
 		ret = rdev->desc->ops->set_suspend_mode(rdev, rstate->mode);
 		if (ret < 0) {
-			printk(KERN_ERR "%s: failed to set mode\n", __func__);
+			pr_err("failed to set mode\n");
 			return ret;
 		}
 	}
@@ -739,9 +727,8 @@ static int machine_constraints_voltage(struct regulator_dev *rdev,
 				       rdev->constraints->max_uV,
 				       &selector);
 			if (ret < 0) {
-				printk(KERN_ERR "%s: failed to apply %duV constraint to %s\n",
-				       __func__,
-				       rdev->constraints->min_uV, name);
+				pr_err("failed to apply %duV constraint to %s\n",
+					rdev->constraints->min_uV, name);
 				rdev->constraints = NULL;
 				return ret;
 			}
@@ -848,8 +835,8 @@ static int set_machine_constraints(struct regulator_dev *rdev,
 	if (constraints->initial_state) {
 		ret = suspend_prepare(rdev, constraints->initial_state);
 		if (ret < 0) {
-			printk(KERN_ERR "%s: failed to set suspend state for %s\n",
-			       __func__, name);
+			pr_err("failed to set suspend state for %s\n",
+				name);
 			rdev->constraints = NULL;
 			goto out;
 		}
@@ -857,17 +844,16 @@ static int set_machine_constraints(struct regulator_dev *rdev,
 
 	if (constraints->initial_mode) {
 		if (!ops->set_mode) {
-			printk(KERN_ERR "%s: no set_mode operation for %s\n",
-			       __func__, name);
+			pr_err("no set_mode operation for %s\n",
+				name);
 			ret = -EINVAL;
 			goto out;
 		}
 
 		ret = ops->set_mode(rdev, constraints->initial_mode);
 		if (ret < 0) {
-			printk(KERN_ERR
-			       "%s: failed to set initial mode for %s: %d\n",
-			       __func__, name, ret);
+			pr_err("failed to set initial mode for %s: %d\n",
+				name, ret);
 			goto out;
 		}
 	}
@@ -878,8 +864,7 @@ static int set_machine_constraints(struct regulator_dev *rdev,
 	if ((constraints->always_on || constraints->boot_on) && ops->enable) {
 		ret = ops->enable(rdev);
 		if (ret < 0) {
-			printk(KERN_ERR "%s: failed to enable %s\n",
-			       __func__, name);
+			pr_err("failed to enable %s\n", name);
 			rdev->constraints = NULL;
 			goto out;
 		}
@@ -907,9 +892,8 @@ static int set_supply(struct regulator_dev *rdev,
 	err = sysfs_create_link(&rdev->dev.kobj, &supply_rdev->dev.kobj,
 				"supply");
 	if (err) {
-		printk(KERN_ERR
-		       "%s: could not add device link %s err %d\n",
-		       __func__, supply_rdev->dev.kobj.name, err);
+		pr_err("could not add device link %s err %d\n",
+			supply_rdev->dev.kobj.name, err);
 		       goto out;
 	}
 	rdev->supply = supply_rdev;
@@ -1039,8 +1023,8 @@ static struct regulator *create_regulator(struct regulator_dev *rdev,
 		regulator->dev_attr.show = device_requested_uA_show;
 		err = device_create_file(dev, &regulator->dev_attr);
 		if (err < 0) {
-			printk(KERN_WARNING "%s: could not add regulator_dev"
-				" load sysfs\n", __func__);
+			pr_warning("could not add regulator_dev"
+				" requested microamps sysfs entry\n");
 			goto attr_name_err;
 		}
 
@@ -1057,9 +1041,8 @@ static struct regulator *create_regulator(struct regulator_dev *rdev,
 		err = sysfs_create_link(&rdev->dev.kobj, &dev->kobj,
 					buf);
 		if (err) {
-			printk(KERN_WARNING
-			       "%s: could not add device link %s err %d\n",
-			       __func__, dev->kobj.name, err);
+			pr_warning("could not add device link %s err %d\n",
+			       dev->kobj.name, err);
 			goto link_name_err;
 		}
 	}
@@ -1096,7 +1079,7 @@ static struct regulator *_regulator_get(struct device *dev, const char *id,
 	int ret;
 
 	if (id == NULL) {
-		printk(KERN_ERR "regulator: get() with no identifier\n");
+		pr_err("regulator: get() with no identifier\n");
 		return regulator;
 	}
 
@@ -1282,8 +1265,8 @@ static int _regulator_enable(struct regulator_dev *rdev)
 			ret = _regulator_enable(rdev->supply);
 			mutex_unlock(&rdev->supply->mutex);
 			if (ret < 0) {
-				printk(KERN_ERR "%s: failed to enable %s: %d\n",
-				       __func__, rdev_get_name(rdev), ret);
+				pr_err("failed to enable %s: %d\n",
+				       rdev_get_name(rdev), ret);
 				return ret;
 			}
 		}
@@ -1310,10 +1293,9 @@ static int _regulator_enable(struct regulator_dev *rdev)
 			if (ret >= 0) {
 				delay = ret;
 			} else {
-				printk(KERN_WARNING
-					"%s: enable_time() failed for %s: %d\n",
-					__func__, rdev_get_name(rdev),
-					ret);
+				pr_warning("enable_time() failed for %s: %d\n",
+					   rdev_get_name(rdev),
+					   ret);
 				delay = 0;
 			}
 
@@ -1338,8 +1320,8 @@ static int _regulator_enable(struct regulator_dev *rdev)
 			trace_regulator_enable_complete(rdev_get_name(rdev));
 
 		} else if (ret < 0) {
-			printk(KERN_ERR "%s: is_enabled() failed for %s: %d\n",
-			       __func__, rdev_get_name(rdev), ret);
+			pr_err("is_enabled() failed for %s: %d\n",
+				rdev_get_name(rdev), ret);
 			return ret;
 		}
 		/* Fallthrough on positive return values - already enabled */
@@ -1396,8 +1378,8 @@ static int _regulator_disable(struct regulator_dev *rdev,
 
 			ret = rdev->desc->ops->disable(rdev);
 			if (ret < 0) {
-				printk(KERN_ERR "%s: failed to disable %s\n",
-				       __func__, rdev_get_name(rdev));
+				pr_err("failed to disable %s\n",
+					rdev_get_name(rdev));
 				return ret;
 			}
 
@@ -1469,8 +1451,8 @@ static int _regulator_force_disable(struct regulator_dev *rdev,
 		/* ah well, who wants to live forever... */
 		ret = rdev->desc->ops->disable(rdev);
 		if (ret < 0) {
-			printk(KERN_ERR "%s: failed to force disable %s\n",
-			       __func__, rdev_get_name(rdev));
+			pr_err("failed to force disable %s\n",
+				rdev_get_name(rdev));
 			return ret;
 		}
 		/* notify other consumers that power has been forced off */
@@ -1911,8 +1893,8 @@ int regulator_set_optimum_mode(struct regulator *regulator, int uA_load)
 	/* get output voltage */
 	output_uV = rdev->desc->ops->get_voltage(rdev);
 	if (output_uV <= 0) {
-		printk(KERN_ERR "%s: invalid output voltage found for %s\n",
-			__func__, rdev_get_name(rdev));
+		pr_err("invalid output voltage found for %s\n",
+			rdev_get_name(rdev));
 		goto out;
 	}
 
@@ -1922,8 +1904,8 @@ int regulator_set_optimum_mode(struct regulator *regulator, int uA_load)
 	else
 		input_uV = rdev->constraints->input_uV;
 	if (input_uV <= 0) {
-		printk(KERN_ERR "%s: invalid input voltage found for %s\n",
-			__func__, rdev_get_name(rdev));
+		pr_err("invalid input voltage found for %s\n",
+			rdev_get_name(rdev));
 		goto out;
 	}
 
@@ -1936,16 +1918,16 @@ int regulator_set_optimum_mode(struct regulator *regulator, int uA_load)
 						 total_uA_load);
 	ret = regulator_check_mode(rdev, mode);
 	if (ret < 0) {
-		printk(KERN_ERR "%s: failed to get optimum mode for %s @"
-			" %d uA %d -> %d uV\n", __func__, rdev_get_name(rdev),
+		pr_err("failed to get optimum mode for %s @"
+			" %d uA %d -> %d uV\n",  rdev_get_name(rdev),
 			total_uA_load, input_uV, output_uV);
 		goto out;
 	}
 
 	ret = rdev->desc->ops->set_mode(rdev, mode);
 	if (ret < 0) {
-		printk(KERN_ERR "%s: failed to set optimum mode %x for %s\n",
-			__func__, mode, rdev_get_name(rdev));
+		pr_err("failed to set optimum mode %x for %s\n",
+			 mode, rdev_get_name(rdev));
 		goto out;
 	}
 	ret = mode;
@@ -2494,8 +2476,7 @@ int regulator_suspend_prepare(suspend_state_t state)
 		mutex_unlock(&rdev->mutex);
 
 		if (ret < 0) {
-			printk(KERN_ERR "%s: failed to prepare %s\n",
-				__func__, rdev_get_name(rdev));
+			pr_err("failed to prepare %s\n", rdev_get_name(rdev));
 			goto out;
 		}
 	}
@@ -2653,13 +2634,10 @@ static int __init regulator_init_complete(void)
 		if (has_full_constraints) {
 			/* We log since this may kill the system if it
 			 * goes wrong. */
-			printk(KERN_INFO "%s: disabling %s\n",
-			       __func__, name);
+			pr_info("disabling %s\n", name);
 			ret = ops->disable(rdev);
 			if (ret != 0) {
-				printk(KERN_ERR
-				       "%s: couldn't disable %s: %d\n",
-				       __func__, name, ret);
+				pr_err("couldn't disable %s: %d\n", name, ret);
 			}
 		} else {
 			/* The intention is that in future we will
@@ -2667,9 +2645,8 @@ static int __init regulator_init_complete(void)
 			 * so warn even if we aren't going to do
 			 * anything here.
 			 */
-			printk(KERN_WARNING
-			       "%s: incomplete constraints, leaving %s on\n",
-			       __func__, name);
+			pr_warning("incomplete constraints, leaving %s on\n",
+				   name);
 		}
 
 unlock:

commit c5e28ed78274468b92522e7f1e9a5e6080559100
Author: Daniel Walker <dwalker@codeaurora.org>
Date:   Wed Nov 17 15:30:27 2010 -0800

    drivers: regulator: core: use pr_fmt
    
    This adds a pr_fmt line which uses the __func__ macro. I also
    convert the current pr_ lines to remove their __func__ usage.
    
    Cc: bleong@codeaurora.org
    Signed-off-by: Daniel Walker <dwalker@codeaurora.org>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index a48cf582dcd0..7c0906367239 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -13,6 +13,8 @@
  *
  */
 
+#define pr_fmt(fmt) "%s:" fmt, __func__
+
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/device.h>
@@ -771,8 +773,8 @@ static int machine_constraints_voltage(struct regulator_dev *rdev,
 
 		/* else require explicit machine-level constraints */
 		if (cmin <= 0 || cmax <= 0 || cmax < cmin) {
-			pr_err("%s: %s '%s' voltage constraints\n",
-				       __func__, "invalid", name);
+			pr_err("%s '%s' voltage constraints\n", "invalid",
+				name);
 			return -EINVAL;
 		}
 
@@ -793,22 +795,22 @@ static int machine_constraints_voltage(struct regulator_dev *rdev,
 
 		/* final: [min_uV..max_uV] valid iff constraints valid */
 		if (max_uV < min_uV) {
-			pr_err("%s: %s '%s' voltage constraints\n",
-				       __func__, "unsupportable", name);
+			pr_err("%s '%s' voltage constraints\n", "unsupportable",
+				name);
 			return -EINVAL;
 		}
 
 		/* use regulator's subset of machine constraints */
 		if (constraints->min_uV < min_uV) {
-			pr_debug("%s: override '%s' %s, %d -> %d\n",
-				       __func__, name, "min_uV",
-					constraints->min_uV, min_uV);
+			pr_debug("override '%s' %s, %d -> %d\n",
+				 name, "min_uV",
+				 constraints->min_uV, min_uV);
 			constraints->min_uV = min_uV;
 		}
 		if (constraints->max_uV > max_uV) {
-			pr_debug("%s: override '%s' %s, %d -> %d\n",
-				       __func__, name, "max_uV",
-					constraints->max_uV, max_uV);
+			pr_debug("override '%s' %s, %d -> %d\n",
+				 name, "max_uV",
+				 constraints->max_uV, max_uV);
 			constraints->max_uV = max_uV;
 		}
 	}

commit acaf6ffefdf65188071f88664435b86651d70e7c
Author: Bengt Jonsson <bengt.g.jonsson@stericsson.com>
Date:   Wed Nov 10 11:06:22 2010 +0100

    regulator: enable supply regulator only when use count is zero
    
    Supply regulators are disabled only when the last
    reference count is removed on the child regulator
    (the use count goes from 1 to 0). This patch changes
    the behaviour of enable so the supply regulator is
    enabled only when the use count of the child
    regulator goes from 0 to 1.
    
    Signed-off-by: Bengt Jonsson <bengt.g.jonsson@stericsson.com>
    Acked-by: Linus Walleij <linus.walleij@stericsson.com>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 8a5d0ae191b3..a48cf582dcd0 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1273,15 +1273,17 @@ static int _regulator_enable(struct regulator_dev *rdev)
 {
 	int ret, delay;
 
-	/* do we need to enable the supply regulator first */
-	if (rdev->supply) {
-		mutex_lock(&rdev->supply->mutex);
-		ret = _regulator_enable(rdev->supply);
-		mutex_unlock(&rdev->supply->mutex);
-		if (ret < 0) {
-			printk(KERN_ERR "%s: failed to enable %s: %d\n",
-			       __func__, rdev_get_name(rdev), ret);
-			return ret;
+	if (rdev->use_count == 0) {
+		/* do we need to enable the supply regulator first */
+		if (rdev->supply) {
+			mutex_lock(&rdev->supply->mutex);
+			ret = _regulator_enable(rdev->supply);
+			mutex_unlock(&rdev->supply->mutex);
+			if (ret < 0) {
+				printk(KERN_ERR "%s: failed to enable %s: %d\n",
+				       __func__, rdev_get_name(rdev), ret);
+				return ret;
+			}
 		}
 	}
 

commit 02fa3ec01a0df7a8ccc356d8e245a9a1423b3596
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Nov 10 14:38:30 2010 +0000

    regulator: Add basic trace facilities
    
    Provide some basic trace facilities to the regulator API. We generate
    events on regulator enable, disable and voltage setting over the actual
    hardware operations (which are assumed to be the expensive ones which
    require interaction with the actual device). This is intended to facilitate
    debug of the performance and behaviour with consumers allowing unified
    traces to be generated including the regulator operations within the
    context of the other components of the system.
    
    For enable we log the explicit delay for the voltage ramp separately to
    the interaction with the hardware to highlight the time consumed in I/O.
    We should add a similar delay for voltage changes, though there the
    relatively small magnitude of the changes in the context of the I/O
    costs makes it much less critical for most regulators.
    
    Only hardware interactions are currently traced as the primary focus is
    on the performance and synchronisation of actual hardware interactions.
    Additional tracepoints for debugging of the logical operations can be
    added later if required.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 67d3a61f3785..8a5d0ae191b3 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -25,6 +25,9 @@
 #include <linux/regulator/driver.h>
 #include <linux/regulator/machine.h>
 
+#define CREATE_TRACE_POINTS
+#include <trace/events/regulator.h>
+
 #include "dummy.h"
 
 #define REGULATOR_VERSION "0.5"
@@ -1310,6 +1313,8 @@ static int _regulator_enable(struct regulator_dev *rdev)
 				delay = 0;
 			}
 
+			trace_regulator_enable(rdev_get_name(rdev));
+
 			/* Allow the regulator to ramp; it would be useful
 			 * to extend this for bulk operations so that the
 			 * regulators can ramp together.  */
@@ -1317,6 +1322,8 @@ static int _regulator_enable(struct regulator_dev *rdev)
 			if (ret < 0)
 				return ret;
 
+			trace_regulator_enable_delay(rdev_get_name(rdev));
+
 			if (delay >= 1000) {
 				mdelay(delay / 1000);
 				udelay(delay % 1000);
@@ -1324,6 +1331,8 @@ static int _regulator_enable(struct regulator_dev *rdev)
 				udelay(delay);
 			}
 
+			trace_regulator_enable_complete(rdev_get_name(rdev));
+
 		} else if (ret < 0) {
 			printk(KERN_ERR "%s: is_enabled() failed for %s: %d\n",
 			       __func__, rdev_get_name(rdev), ret);
@@ -1379,6 +1388,8 @@ static int _regulator_disable(struct regulator_dev *rdev,
 		/* we are last user */
 		if (_regulator_can_change_status(rdev) &&
 		    rdev->desc->ops->disable) {
+			trace_regulator_disable(rdev_get_name(rdev));
+
 			ret = rdev->desc->ops->disable(rdev);
 			if (ret < 0) {
 				printk(KERN_ERR "%s: failed to disable %s\n",
@@ -1386,6 +1397,8 @@ static int _regulator_disable(struct regulator_dev *rdev,
 				return ret;
 			}
 
+			trace_regulator_disable_complete(rdev_get_name(rdev));
+
 			_notifier_call_chain(rdev, REGULATOR_EVENT_DISABLE,
 					     NULL);
 		}
@@ -1645,6 +1658,8 @@ int regulator_set_voltage(struct regulator *regulator, int min_uV, int max_uV)
 	regulator->min_uV = min_uV;
 	regulator->max_uV = max_uV;
 
+	trace_regulator_set_voltage(rdev_get_name(rdev), min_uV, max_uV);
+
 	ret = rdev->desc->ops->set_voltage(rdev, min_uV, max_uV, &selector);
 
 	if (rdev->desc->ops->list_voltage)
@@ -1652,6 +1667,8 @@ int regulator_set_voltage(struct regulator *regulator, int min_uV, int max_uV)
 	else
 		selector = -1;
 
+	trace_regulator_set_voltage_complete(rdev_get_name(rdev), selector);
+
 out:
 	_notifier_call_chain(rdev, REGULATOR_EVENT_VOLTAGE_CHANGE, NULL);
 	mutex_unlock(&rdev->mutex);

commit 3a93f2a9f4d8f73d74c0e552feb68a10f778a219
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Nov 10 14:38:29 2010 +0000

    regulator: Report actual configured voltage to set_voltage()
    
    Change the interface used by set_voltage() to report the selected value
    to the regulator core in terms of a selector used by list_voltage().
    This allows the regulator core to know the voltage that was chosen
    without having to do an explict get_voltage(), which would be much more
    expensive as it will generally access hardware.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 81336e23848a..67d3a61f3785 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -723,13 +723,16 @@ static int machine_constraints_voltage(struct regulator_dev *rdev,
 	struct regulator_ops *ops = rdev->desc->ops;
 	const char *name = rdev_get_name(rdev);
 	int ret;
+	unsigned selector;
 
 	/* do we need to apply the constraint voltage */
 	if (rdev->constraints->apply_uV &&
 		rdev->constraints->min_uV == rdev->constraints->max_uV &&
 		ops->set_voltage) {
 		ret = ops->set_voltage(rdev,
-			rdev->constraints->min_uV, rdev->constraints->max_uV);
+				       rdev->constraints->min_uV,
+				       rdev->constraints->max_uV,
+				       &selector);
 			if (ret < 0) {
 				printk(KERN_ERR "%s: failed to apply %duV constraint to %s\n",
 				       __func__,
@@ -1625,6 +1628,7 @@ int regulator_set_voltage(struct regulator *regulator, int min_uV, int max_uV)
 {
 	struct regulator_dev *rdev = regulator->rdev;
 	int ret;
+	unsigned selector;
 
 	mutex_lock(&rdev->mutex);
 
@@ -1640,7 +1644,13 @@ int regulator_set_voltage(struct regulator *regulator, int min_uV, int max_uV)
 		goto out;
 	regulator->min_uV = min_uV;
 	regulator->max_uV = max_uV;
-	ret = rdev->desc->ops->set_voltage(rdev, min_uV, max_uV);
+
+	ret = rdev->desc->ops->set_voltage(rdev, min_uV, max_uV, &selector);
+
+	if (rdev->desc->ops->list_voltage)
+		selector = rdev->desc->ops->list_voltage(rdev, selector);
+	else
+		selector = -1;
 
 out:
 	_notifier_call_chain(rdev, REGULATOR_EVENT_VOLTAGE_CHANGE, NULL);

commit 63cee946148821bca42be10130b061c2d0f5af7e
Author: Mattias Wallin <mattias.wallin@stericsson.com>
Date:   Thu Nov 4 11:01:31 2010 +0100

    regulator: lock supply in regulator enable
    
    This patch add locks around regulator supply enable.
    
    Signed-off-by: Mattias Wallin <mattias.wallin@stericsson.com>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index ba521f0f0fac..81336e23848a 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1267,17 +1267,15 @@ static int _regulator_enable(struct regulator_dev *rdev)
 {
 	int ret, delay;
 
-	if (rdev->use_count == 0) {
-		/* do we need to enable the supply regulator first */
-		if (rdev->supply) {
-			mutex_lock(&rdev->supply->mutex);
-			ret = _regulator_enable(rdev->supply);
-			mutex_unlock(&rdev->supply->mutex);
-			if (ret < 0) {
-				printk(KERN_ERR "%s: failed to enable %s: %d\n",
-				       __func__, rdev_get_name(rdev), ret);
-				return ret;
-			}
+	/* do we need to enable the supply regulator first */
+	if (rdev->supply) {
+		mutex_lock(&rdev->supply->mutex);
+		ret = _regulator_enable(rdev->supply);
+		mutex_unlock(&rdev->supply->mutex);
+		if (ret < 0) {
+			printk(KERN_ERR "%s: failed to enable %s: %d\n",
+			       __func__, rdev_get_name(rdev), ret);
+			return ret;
 		}
 	}
 

commit 06c63f9396133f312c5a49c2285c2c8015e80934
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Thu Nov 18 15:02:26 2010 -0800

    regulator: fix kernel-doc for set_consumer_device_supply
    
    Fix kernel-doc warning for set_consumer_device_supply():
    
    Warning(drivers/regulator/core.c:912): missing initial short description on line:
     * set_consumer_device_supply: Bind a regulator to a symbolic supply
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Cc:     Liam Girdwood <lrg@slimlogic.co.uk>
    Cc:     Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index c577c6d344ac..ba521f0f0fac 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -911,7 +911,7 @@ static int set_supply(struct regulator_dev *rdev,
 }
 
 /**
- * set_consumer_device_supply: Bind a regulator to a symbolic supply
+ * set_consumer_device_supply - Bind a regulator to a symbolic supply
  * @rdev:         regulator source
  * @consumer_dev: device the supply applies to
  * @consumer_dev_name: dev_name() string for device supply applies to

commit f3c18a87f3ddcfd31b16f689d01eb6adcc99de74
Author: Bengt Jonsson <bengt.g.jonsson@stericsson.com>
Date:   Wed Nov 10 11:06:22 2010 +0100

    regulator: enable supply regulator only when use count is zero
    
    Supply regulators are disabled only when the last
    reference count is removed on the child regulator
    (the use count goes from 1 to 0). This patch changes
    the behaviour of enable so the supply regulator is
    enabled only when the use count of the child
    regulator goes from 0 to 1.
    
    Signed-off-by: Bengt Jonsson <bengt.g.jonsson@stericsson.com>
    Acked-by: Linus Walleij <linus.walleij@stericsson.com>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 27d062e1395c..c577c6d344ac 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1267,15 +1267,17 @@ static int _regulator_enable(struct regulator_dev *rdev)
 {
 	int ret, delay;
 
-	/* do we need to enable the supply regulator first */
-	if (rdev->supply) {
-		mutex_lock(&rdev->supply->mutex);
-		ret = _regulator_enable(rdev->supply);
-		mutex_unlock(&rdev->supply->mutex);
-		if (ret < 0) {
-			printk(KERN_ERR "%s: failed to enable %s: %d\n",
-			       __func__, rdev_get_name(rdev), ret);
-			return ret;
+	if (rdev->use_count == 0) {
+		/* do we need to enable the supply regulator first */
+		if (rdev->supply) {
+			mutex_lock(&rdev->supply->mutex);
+			ret = _regulator_enable(rdev->supply);
+			mutex_unlock(&rdev->supply->mutex);
+			if (ret < 0) {
+				printk(KERN_ERR "%s: failed to enable %s: %d\n",
+				       __func__, rdev_get_name(rdev), ret);
+				return ret;
+			}
 		}
 	}
 

commit 3aa713e76e8f562c0d28faf18873c4f1836b17c9
Author: Mattias Wallin <mattias.wallin@stericsson.com>
Date:   Thu Nov 4 11:01:31 2010 +0100

    regulator: lock supply in regulator enable
    
    This patch add locks around regulator supply enable.
    
    Signed-off-by: Mattias Wallin <mattias.wallin@stericsson.com>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 711fa1722bce..27d062e1395c 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1269,7 +1269,9 @@ static int _regulator_enable(struct regulator_dev *rdev)
 
 	/* do we need to enable the supply regulator first */
 	if (rdev->supply) {
+		mutex_lock(&rdev->supply->mutex);
 		ret = _regulator_enable(rdev->supply);
+		mutex_unlock(&rdev->supply->mutex);
 		if (ret < 0) {
 			printk(KERN_ERR "%s: failed to enable %s: %d\n",
 			       __func__, rdev_get_name(rdev), ret);

commit 7727da22e820a96ab394db2fc0ab58f7f7ecb323
Author: Axel Lin <axel.lin@gmail.com>
Date:   Fri Nov 5 15:27:17 2010 +0800

    regulator: Return proper error for regulator_register()
    
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 9da85bc21db4..711fa1722bce 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2348,6 +2348,7 @@ struct regulator_dev *regulator_register(struct regulator_desc *regulator_desc,
 	if (init_data->supply_regulator && init_data->supply_regulator_dev) {
 		dev_err(dev,
 			"Supply regulator specified by both name and dev\n");
+		ret = -EINVAL;
 		goto scrub;
 	}
 
@@ -2366,6 +2367,7 @@ struct regulator_dev *regulator_register(struct regulator_desc *regulator_desc,
 		if (!found) {
 			dev_err(dev, "Failed to find supply %s\n",
 				init_data->supply_regulator);
+			ret = -ENODEV;
 			goto scrub;
 		}
 

commit e36c1df8e18183ba2c691fe766a52c94020cdc5e
Author: Axel Lin <axel.lin@gmail.com>
Date:   Fri Nov 5 21:51:32 2010 +0800

    regulator: Ensure enough delay time for enabling regulator
    
    Integer division will truncate the result, this patch ensures we have
    enough delay time for enabling regulator.
    
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index c3f93b401e90..9da85bc21db4 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1312,10 +1312,12 @@ static int _regulator_enable(struct regulator_dev *rdev)
 			if (ret < 0)
 				return ret;
 
-			if (delay >= 1000)
+			if (delay >= 1000) {
 				mdelay(delay / 1000);
-			else if (delay)
+				udelay(delay % 1000);
+			} else if (delay) {
 				udelay(delay);
+			}
 
 		} else if (ret < 0) {
 			printk(KERN_ERR "%s: is_enabled() failed for %s: %d\n",

commit aa7a74040a989eeb7a9265550a2538863e842a93
Author: Axel Lin <axel.lin@gmail.com>
Date:   Fri Nov 5 15:25:12 2010 +0800

    regulator: Remove a redundant device_remove_file call in create_regulator
    
    We already have device_remove_file() in error path,
    no need to call it before goto link_name_err.
    
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index c62563322969..c3f93b401e90 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1052,7 +1052,6 @@ static struct regulator *create_regulator(struct regulator_dev *rdev,
 			printk(KERN_WARNING
 			       "%s: could not add device link %s err %d\n",
 			       __func__, dev->kobj.name, err);
-			device_remove_file(dev, &regulator->dev_attr);
 			goto link_name_err;
 		}
 	}

commit b12a1e29af595d05612153bcb85258193bbf9382
Author: Mattias Wallin <mattias.wallin@stericsson.com>
Date:   Tue Nov 2 14:55:34 2010 +0100

    regulator: regulator disable supply fix
    
    This patch fixes a disable failure when regulator supply is used.
    A while loop in regulator disable checks for supply pointer != NULL
    but the pointer is not always updated, resulting in the while loop
    running too many times causing a disable failure.
    
    Signed-off-by: Mattias Wallin <mattias.wallin@stericsson.com>
    Acked-by: Linus Walleij <linus.walleij@stericsson.com>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index f1d10c974cd4..c62563322969 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1359,6 +1359,7 @@ static int _regulator_disable(struct regulator_dev *rdev,
 		struct regulator_dev **supply_rdev_ptr)
 {
 	int ret = 0;
+	*supply_rdev_ptr = NULL;
 
 	if (WARN(rdev->use_count <= 0,
 			"unbalanced disables for %s\n",

commit 8cbf811dfd027bde8504e541d0009c5722b98be5
Author: Jeffrey Carlyle <jeff.carlyle@motorola.com>
Date:   Fri Oct 8 14:49:19 2010 -0500

    regulator: avoid deadlock when disabling regulator with supply
    
    I have a regulator A that sets regulator B as its supply. When I call
    set_supply to add B as the supply for A, regulator A gets added to the
    supply_list for regulator B.
    
    When I call regulator_disable(A), I end up with a call chain like this:
    
    regulator_disable(A)
    > mutex_lock(A)
    > _regulator_disable(A)
    >> _regulator_disable(B)
    >>> _notifier_call_chain(B)
    >>>> mutex_lock(A)
    
    Which results in dead lock since we are trying to acquire the mutex lock
    for regulator A which we already hold.
    
    This patch addresses this issue by moving the call to disable regulator
    B outside of the lock aquired inside the initial call to
    regulator_disable.
    
    This change also addresses the issue of not acquiring the mutex for
    regulator B before calling _regulator_disable(B).
    
    Signed-off-by: Jeffrey Carlyle <jeff.carlyle@motorola.com>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 4fa08c85f3ce..f1d10c974cd4 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -64,7 +64,8 @@ struct regulator {
 };
 
 static int _regulator_is_enabled(struct regulator_dev *rdev);
-static int _regulator_disable(struct regulator_dev *rdev);
+static int _regulator_disable(struct regulator_dev *rdev,
+		struct regulator_dev **supply_rdev_ptr);
 static int _regulator_get_voltage(struct regulator_dev *rdev);
 static int _regulator_get_current_limit(struct regulator_dev *rdev);
 static unsigned int _regulator_get_mode(struct regulator_dev *rdev);
@@ -1354,7 +1355,8 @@ int regulator_enable(struct regulator *regulator)
 EXPORT_SYMBOL_GPL(regulator_enable);
 
 /* locks held by regulator_disable() */
-static int _regulator_disable(struct regulator_dev *rdev)
+static int _regulator_disable(struct regulator_dev *rdev,
+		struct regulator_dev **supply_rdev_ptr)
 {
 	int ret = 0;
 
@@ -1382,8 +1384,7 @@ static int _regulator_disable(struct regulator_dev *rdev)
 		}
 
 		/* decrease our supplies ref count and disable if required */
-		if (rdev->supply)
-			_regulator_disable(rdev->supply);
+		*supply_rdev_ptr = rdev->supply;
 
 		rdev->use_count = 0;
 	} else if (rdev->use_count > 1) {
@@ -1413,17 +1414,29 @@ static int _regulator_disable(struct regulator_dev *rdev)
 int regulator_disable(struct regulator *regulator)
 {
 	struct regulator_dev *rdev = regulator->rdev;
+	struct regulator_dev *supply_rdev = NULL;
 	int ret = 0;
 
 	mutex_lock(&rdev->mutex);
-	ret = _regulator_disable(rdev);
+	ret = _regulator_disable(rdev, &supply_rdev);
 	mutex_unlock(&rdev->mutex);
+
+	/* decrease our supplies ref count and disable if required */
+	while (supply_rdev != NULL) {
+		rdev = supply_rdev;
+
+		mutex_lock(&rdev->mutex);
+		_regulator_disable(rdev, &supply_rdev);
+		mutex_unlock(&rdev->mutex);
+	}
+
 	return ret;
 }
 EXPORT_SYMBOL_GPL(regulator_disable);
 
 /* locks held by regulator_force_disable() */
-static int _regulator_force_disable(struct regulator_dev *rdev)
+static int _regulator_force_disable(struct regulator_dev *rdev,
+		struct regulator_dev **supply_rdev_ptr)
 {
 	int ret = 0;
 
@@ -1442,8 +1455,7 @@ static int _regulator_force_disable(struct regulator_dev *rdev)
 	}
 
 	/* decrease our supplies ref count and disable if required */
-	if (rdev->supply)
-		_regulator_disable(rdev->supply);
+	*supply_rdev_ptr = rdev->supply;
 
 	rdev->use_count = 0;
 	return ret;
@@ -1460,12 +1472,17 @@ static int _regulator_force_disable(struct regulator_dev *rdev)
  */
 int regulator_force_disable(struct regulator *regulator)
 {
+	struct regulator_dev *supply_rdev = NULL;
 	int ret;
 
 	mutex_lock(&regulator->rdev->mutex);
 	regulator->uA_load = 0;
-	ret = _regulator_force_disable(regulator->rdev);
+	ret = _regulator_force_disable(regulator->rdev, &supply_rdev);
 	mutex_unlock(&regulator->rdev->mutex);
+
+	if (supply_rdev)
+		regulator_disable(get_device_regulator(rdev_get_dev(supply_rdev)));
+
 	return ret;
 }
 EXPORT_SYMBOL_GPL(regulator_force_disable);

commit 688fe99a439f7c9dfcc52fbf7cb347f140a2dc8b
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Oct 5 19:18:32 2010 -0700

    regulator: Add option for machine drivers to enable the dummy regulator
    
    Allow machine drivers to explicitly enable the use of the dummy regulator,
    enabling simpler support for systems with only a few specific supplies
    visible to software.
    
    It is strongly recommended that this is not used on systems with
    substantial software control over their PMICs, for maximum functionality
    constrints should be as fully specified as possible.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index cc8b337b9119..4fa08c85f3ce 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -33,6 +33,7 @@ static DEFINE_MUTEX(regulator_list_mutex);
 static LIST_HEAD(regulator_list);
 static LIST_HEAD(regulator_map_list);
 static int has_full_constraints;
+static bool board_wants_dummy_regulator;
 
 /*
  * struct regulator_map
@@ -1108,6 +1109,11 @@ static struct regulator *_regulator_get(struct device *dev, const char *id,
 		}
 	}
 
+	if (board_wants_dummy_regulator) {
+		rdev = dummy_regulator_rdev;
+		goto found;
+	}
+
 #ifdef CONFIG_REGULATOR_DUMMY
 	if (!devname)
 		devname = "deviceless";
@@ -2462,6 +2468,22 @@ void regulator_has_full_constraints(void)
 }
 EXPORT_SYMBOL_GPL(regulator_has_full_constraints);
 
+/**
+ * regulator_use_dummy_regulator - Provide a dummy regulator when none is found
+ *
+ * Calling this function will cause the regulator API to provide a
+ * dummy regulator to consumers if no physical regulator is found,
+ * allowing most consumers to proceed as though a regulator were
+ * configured.  This allows systems such as those with software
+ * controllable regulators for the CPU core only to be brought up more
+ * readily.
+ */
+void regulator_use_dummy_regulator(void)
+{
+	board_wants_dummy_regulator = true;
+}
+EXPORT_SYMBOL_GPL(regulator_use_dummy_regulator);
+
 /**
  * rdev_get_drvdata - get rdev regulator driver data
  * @rdev: regulator

commit e4a6376b3b2999d169b602a582a8819d95ff79bc
Author: Cyril Chemparathy <cyril@ti.com>
Date:   Wed Sep 22 12:30:15 2010 -0400

    regulator: fix typo in current units
    
    This patch fixes a typo that incorrectly reports mA numbers as uA.
    
    Signed-off-by: Cyril Chemparathy <cyril@ti.com>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index a43eedb214bb..cc8b337b9119 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -700,7 +700,7 @@ static void print_constraints(struct regulator_dev *rdev)
 	    constraints->min_uA != constraints->max_uA) {
 		ret = _regulator_get_current_limit(rdev);
 		if (ret > 0)
-			count += sprintf(buf + count, "at %d uA ", ret / 1000);
+			count += sprintf(buf + count, "at %d mA ", ret / 1000);
 	}
 
 	if (constraints->valid_modes_mask & REGULATOR_MODE_FAST)

commit ad7725cb43b8badb2fec2c2bfca07c067f2e19a7
Author: Vasiliy Kulikov <segooon@gmail.com>
Date:   Sun Sep 19 16:55:01 2010 +0400

    regulator: fix device_register() error handling
    
    If device_register() fails then call put_device().
    See comment to device_register.
    
    Signed-off-by: Vasiliy Kulikov <segooon@gmail.com>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 422a709d271d..a43eedb214bb 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2302,8 +2302,10 @@ struct regulator_dev *regulator_register(struct regulator_desc *regulator_desc,
 	dev_set_name(&rdev->dev, "regulator.%d",
 		     atomic_inc_return(&regulator_no) - 1);
 	ret = device_register(&rdev->dev);
-	if (ret != 0)
+	if (ret != 0) {
+		put_device(&rdev->dev);
 		goto clean;
+	}
 
 	dev_set_drvdata(&rdev->dev, rdev);
 

commit 068a2782f59efe5855091860bbccbadf1c72fffd
Author: Guenter Roeck <guenter.roeck@ericsson.com>
Date:   Wed Jul 28 22:09:24 2010 -0700

    regulator: Remove owner field from attribute initialization in regulator core driver
    
    Signed-off-by: Guenter Roeck <guenter.roeck@ericsson.com>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 2248087b9be2..422a709d271d 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1025,7 +1025,6 @@ static struct regulator *create_regulator(struct regulator_dev *rdev,
 		if (regulator->dev_attr.attr.name == NULL)
 			goto attr_name_err;
 
-		regulator->dev_attr.attr.owner = THIS_MODULE;
 		regulator->dev_attr.attr.mode = 0444;
 		regulator->dev_attr.show = device_requested_uA_show;
 		err = device_create_file(dev, &regulator->dev_attr);

commit 500b4ac90d1103a7c302d5bb16c53f4ffc45d057
Author: Sundar R Iyer <sundar.iyer@stericsson.com>
Date:   Mon May 17 21:24:48 2010 +0530

    regulator: return set_mode is same mode is requested
    
    On Mon, 2010-05-17 at 17:34 +0200, Mark Brown wrote:
    > This doesn't seem like the right error handling - if the driver has a
    > set_mode() you'd *expect* it to have a get_mode() but there's no need
    > for it to be a strict requirement.
    True. In such a case, even a valid request would be lost! So now
    in the updated patch:
     - check if get_mode is present to avoid oops;
     - if get_mode is not present, proceed anyways for the request.
    
    Here is the updated patch:
    
    >From bad0d5eb51ef84be5b100e3dd0f5a590ea0529b6 Mon Sep 17 00:00:00 2001
    From: Sundar R Iyer <sundar.iyer@stericsson.com>
    Date: Fri, 14 May 2010 15:14:17 +0530
    Subject: [PATCH 1/1] regulator: return set_mode when same mode is requested
    
    save I/O costs by returning when the same mode is
    requested for the regulator
    
    Cc: Liam Girdwood <lrg@slimlogic.co.uk>
    Cc: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Linus Walleij <linus.walleij@stericsson.com>
    Signed-off-by: Sundar R Iyer <sundar.iyer@stericsson.com>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 98e5d14f94f3..2248087b9be2 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1745,6 +1745,7 @@ int regulator_set_mode(struct regulator *regulator, unsigned int mode)
 {
 	struct regulator_dev *rdev = regulator->rdev;
 	int ret;
+	int regulator_curr_mode;
 
 	mutex_lock(&rdev->mutex);
 
@@ -1754,6 +1755,15 @@ int regulator_set_mode(struct regulator *regulator, unsigned int mode)
 		goto out;
 	}
 
+	/* return if the same mode is requested */
+	if (rdev->desc->ops->get_mode) {
+		regulator_curr_mode = rdev->desc->ops->get_mode(rdev);
+		if (regulator_curr_mode == mode) {
+			ret = 0;
+			goto out;
+		}
+	}
+
 	/* constraints check */
 	ret = regulator_check_mode(rdev, mode);
 	if (ret < 0)

commit d4033b54fc91221b13e2850bf298683c0f2ff37d
Author: Jani Nikula <ext-jani.1.nikula@nokia.com>
Date:   Thu Apr 29 10:55:11 2010 +0300

    regulator: simplify regulator_register() error handling
    
    Simply remove all consumer supplies for the regulator on errors. Remove
    unset_consumer_device_supply() which is no longer used.
    
    Signed-off-by: Jani Nikula <ext-jani.1.nikula@nokia.com>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index a50672f33afa..98e5d14f94f3 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -981,29 +981,6 @@ static int set_consumer_device_supply(struct regulator_dev *rdev,
 	return 0;
 }
 
-static void unset_consumer_device_supply(struct regulator_dev *rdev,
-	const char *consumer_dev_name, struct device *consumer_dev)
-{
-	struct regulator_map *node, *n;
-
-	if (consumer_dev && !consumer_dev_name)
-		consumer_dev_name = dev_name(consumer_dev);
-
-	list_for_each_entry_safe(node, n, &regulator_map_list, list) {
-		if (rdev != node->regulator)
-			continue;
-
-		if (consumer_dev_name && node->dev_name &&
-		    strcmp(consumer_dev_name, node->dev_name))
-			continue;
-
-		list_del(&node->list);
-		kfree(node->dev_name);
-		kfree(node);
-		return;
-	}
-}
-
 static void unset_regulator_supplies(struct regulator_dev *rdev)
 {
 	struct regulator_map *node, *n;
@@ -2375,13 +2352,8 @@ struct regulator_dev *regulator_register(struct regulator_desc *regulator_desc,
 			init_data->consumer_supplies[i].dev,
 			init_data->consumer_supplies[i].dev_name,
 			init_data->consumer_supplies[i].supply);
-		if (ret < 0) {
-			for (--i; i >= 0; i--)
-				unset_consumer_device_supply(rdev,
-				    init_data->consumer_supplies[i].dev_name,
-				    init_data->consumer_supplies[i].dev);
-			goto scrub;
-		}
+		if (ret < 0)
+			goto unset_supplies;
 	}
 
 	list_add(&rdev->list, &regulator_list);
@@ -2389,6 +2361,9 @@ struct regulator_dev *regulator_register(struct regulator_desc *regulator_desc,
 	mutex_unlock(&regulator_list_mutex);
 	return rdev;
 
+unset_supplies:
+	unset_regulator_supplies(rdev);
+
 scrub:
 	device_unregister(&rdev->dev);
 	/* device core frees rdev */

commit 47bd53f0e8008294ff58c5b37d713f25a8dc56aa
Author: Jani Nikula <ext-jani.1.nikula@nokia.com>
Date:   Thu Apr 29 10:55:10 2010 +0300

    regulator: fix unset_regulator_supplies() to remove all matches
    
    Remove all matching consumer supplies, not just the first, to not leave
    dangling pointers.
    
    Signed-off-by: Jani Nikula <ext-jani.1.nikula@nokia.com>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 2a3494f72465..a50672f33afa 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1013,7 +1013,6 @@ static void unset_regulator_supplies(struct regulator_dev *rdev)
 			list_del(&node->list);
 			kfree(node->dev_name);
 			kfree(node);
-			return;
 		}
 	}
 }

commit 23b5cc2ab6783256cf06779e1d522482b819b808
Author: Jani Nikula <ext-jani.1.nikula@nokia.com>
Date:   Thu Apr 29 10:55:09 2010 +0300

    regulator: prevent registration of matching regulator consumer supplies
    
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    
    Pointer comparison is not sufficient for non-NULL device name matching,
    so use strcmp(). Otherwise the semantics remain the same.
    
    Signed-off-by: Jani Nikula <ext-jani.1.nikula@nokia.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index eb112d961515..2a3494f72465 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -944,8 +944,13 @@ static int set_consumer_device_supply(struct regulator_dev *rdev,
 		has_dev = 0;
 
 	list_for_each_entry(node, &regulator_map_list, list) {
-		if (consumer_dev_name != node->dev_name)
+		if (node->dev_name && consumer_dev_name) {
+			if (strcmp(node->dev_name, consumer_dev_name) != 0)
+				continue;
+		} else if (node->dev_name || consumer_dev_name) {
 			continue;
+		}
+
 		if (strcmp(node->supply, supply) != 0)
 			continue;
 

commit 0178f3e28e2166664916265c5d4922b1376b9fa1
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Apr 26 15:18:14 2010 +0100

    regulator: Allow regulator-regulator supplies to be specified by name
    
    When one regulator supplies another allow the relationship to be specified
    using names rather than struct regulators, in a similar manner to that
    allowed for consumer supplies. This allows static configuration at compile
    time, reducing the need for dynamic init code.
    
    Also change the references to LINE supply to be system supply since line
    is sometimes used for actual supplies and therefore potentially confusing.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 51cf2bb37438..eb112d961515 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2328,7 +2328,37 @@ struct regulator_dev *regulator_register(struct regulator_desc *regulator_desc,
 		goto scrub;
 
 	/* set supply regulator if it exists */
+	if (init_data->supply_regulator && init_data->supply_regulator_dev) {
+		dev_err(dev,
+			"Supply regulator specified by both name and dev\n");
+		goto scrub;
+	}
+
+	if (init_data->supply_regulator) {
+		struct regulator_dev *r;
+		int found = 0;
+
+		list_for_each_entry(r, &regulator_list, list) {
+			if (strcmp(rdev_get_name(r),
+				   init_data->supply_regulator) == 0) {
+				found = 1;
+				break;
+			}
+		}
+
+		if (!found) {
+			dev_err(dev, "Failed to find supply %s\n",
+				init_data->supply_regulator);
+			goto scrub;
+		}
+
+		ret = set_supply(rdev, r);
+		if (ret < 0)
+			goto scrub;
+	}
+
 	if (init_data->supply_regulator_dev) {
+		dev_warn(dev, "Uses supply_regulator_dev instead of regulator_supply\n");
 		ret = set_supply(rdev,
 			dev_get_drvdata(init_data->supply_regulator_dev));
 		if (ret < 0)

commit 6c9468e9eb1252eaefd94ce7f06e1be9b0b641b1
Merge: 4cb3ca7cd7e2 c81eddb0e372
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Fri Apr 23 02:08:44 2010 +0200

    Merge branch 'master' into for-next

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 5af16c2bb540..2b4e40d31190 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -16,6 +16,7 @@
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/device.h>
+#include <linux/slab.h>
 #include <linux/err.h>
 #include <linux/mutex.h>
 #include <linux/suspend.h>

commit 4f26a2abe1eed18dc6adddf2d0ae5553e51578c2
Author: Ameya Palande <ameya.palande@nokia.com>
Date:   Fri Mar 12 20:09:01 2010 +0200

    regulator: Get rid of lockdep warning
    
    WARNING: at kernel/lockdep.c:2706 sysfs_add_file_mode+0x4c/0xa8()
    
    Difference between v1 and v2:
    Moved sysfs_attr_init() call as first one to access the structure.
    
    Signed-off-by: Ameya Palande <ameya.palande@nokia.com>
    CC: Liam Girdwood <lrg@slimlogic.co.uk>
    CC: Mark Brown <broonie@opensource.wolfsonmicro.com>
    CC: David Brownell <dbrownell@users.sourceforge.net>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index c7bbe30010f7..5af16c2bb540 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1038,6 +1038,7 @@ static struct regulator *create_regulator(struct regulator_dev *rdev,
 			goto overflow_err;
 
 		regulator->dev = dev;
+		sysfs_attr_init(&regulator->dev_attr.attr);
 		regulator->dev_attr.attr.name = kstrdup(buf, GFP_KERNEL);
 		if (regulator->dev_attr.attr.name == NULL)
 			goto attr_name_err;

commit 88393161210493e317ae391696ee8ef463cb3c23
Author: Thomas Weber <swirl@gmx.li>
Date:   Tue Mar 16 11:47:56 2010 +0100

    Fix typos in comments
    
    [Ss]ytem => [Ss]ystem
    udpate => update
    paramters => parameters
    orginal => original
    
    Signed-off-by: Thomas Weber <swirl@gmx.li>
    Acked-by: Randy Dunlap <rdunlap@xenotime.net>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index c7bbe30010f7..7461f5bb2bd8 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1538,7 +1538,7 @@ EXPORT_SYMBOL_GPL(regulator_count_voltages);
  * Context: can sleep
  *
  * Returns a voltage that can be passed to @regulator_set_voltage(),
- * zero if this selector code can't be used on this sytem, or a
+ * zero if this selector code can't be used on this system, or a
  * negative errno.
  */
 int regulator_list_voltage(struct regulator *regulator, unsigned selector)

commit 34abbd68efe09765465b81dfedeee9994f13302f
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Fri Feb 12 10:18:08 2010 +0000

    regulator: Provide optional dummy regulator for consumers
    
    In order to ease transitions with drivers are boards start using regulators
    provide an option to cause all regulator_get() calls to succeed, with a
    dummy always on regulator being supplied where one has not been configured.
    A warning is printed whenever the dummy regulator is used to aid system
    development.
    
    This regulator does not implement any regulator operations but will allow
    simple consumers which only do enable() and disable() calls to run. It
    is kept separate from the fixed voltage regulator to avoid Kconfig
    confusion on the part of users when it is extended to allow boards to
    explicitly use the dummy regulator to simplify cases where the majority
    of supplies are from fixed regulators without software control.
    
    This option is currently only effective for systems which do not specify
    full constriants. If required an override could also be provided to allow
    these systems to use the dummy regulator, though it is likely that
    unconfigured supplies on such systems will lead to error due to
    regulators being powered down more aggressively when not in use.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 75a26f780918..c7bbe30010f7 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -24,6 +24,8 @@
 #include <linux/regulator/driver.h>
 #include <linux/regulator/machine.h>
 
+#include "dummy.h"
+
 #define REGULATOR_VERSION "0.5"
 
 static DEFINE_MUTEX(regulator_list_mutex);
@@ -1123,6 +1125,22 @@ static struct regulator *_regulator_get(struct device *dev, const char *id,
 			goto found;
 		}
 	}
+
+#ifdef CONFIG_REGULATOR_DUMMY
+	if (!devname)
+		devname = "deviceless";
+
+	/* If the board didn't flag that it was fully constrained then
+	 * substitute in a dummy regulator so consumers can continue.
+	 */
+	if (!has_full_constraints) {
+		pr_warning("%s supply %s not found, using dummy regulator\n",
+			   devname, id);
+		rdev = dummy_regulator_rdev;
+		goto found;
+	}
+#endif
+
 	mutex_unlock(&regulator_list_mutex);
 	return regulator;
 
@@ -2483,8 +2501,15 @@ EXPORT_SYMBOL_GPL(regulator_get_init_drvdata);
 
 static int __init regulator_init(void)
 {
+	int ret;
+
 	printk(KERN_INFO "regulator: core version %s\n", REGULATOR_VERSION);
-	return class_register(&regulator_class);
+
+	ret = class_register(&regulator_class);
+
+	regulator_dummy_init();
+
+	return ret;
 }
 
 /* init early to allow our consumers to complete system booting */

commit 9a7f6a4c6edc84748c6477c9df56691a0e61b8fd
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Thu Feb 11 17:22:45 2010 +0000

    regulator: Assume regulators are enabled if they don't report anything
    
    If a regulator driver does not provide a way to query if the driver is
    enabled then assume that it is enabled.  This is very likely to reflect
    the actual state is more useful for callers than reporting an error.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index ca8e1642538b..75a26f780918 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1466,9 +1466,9 @@ EXPORT_SYMBOL_GPL(regulator_force_disable);
 
 static int _regulator_is_enabled(struct regulator_dev *rdev)
 {
-	/* sanity check */
+	/* If we don't know then assume that the regulator is always on */
 	if (!rdev->desc->ops->is_enabled)
-		return -EINVAL;
+		return 1;
 
 	return rdev->desc->ops->is_enabled(rdev);
 }

commit 31aae2beeb3d601d556b6a8c39085940ad1e9f42
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Dec 21 12:21:52 2009 +0000

    regulator: Allow regulators to specify the time taken to ramp on enable
    
    Regulators may sometimes take longer to enable than the control operation
    used to do so, either because the regulator has ramp rate control used to
    limit inrush current or because the control operation is very fast (GPIO
    being the most common example of this).  In order to ensure that consumers
    do not rely on the regulator before it is enabled provide an enable_time()
    operation and have the core delay for that time before returning to the
    caller.
    
    This is implemented as a function since the ramp rate may be specified in
    voltage per unit time and therefore the time depend on the configuration.
    In future it would be desirable to allow the bulk operations to run the
    delays for multiple enables in parallel but this is not currently supported.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 6d2ce8a05331..ca8e1642538b 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -19,6 +19,7 @@
 #include <linux/err.h>
 #include <linux/mutex.h>
 #include <linux/suspend.h>
+#include <linux/delay.h>
 #include <linux/regulator/consumer.h>
 #include <linux/regulator/driver.h>
 #include <linux/regulator/machine.h>
@@ -1084,6 +1085,13 @@ static struct regulator *create_regulator(struct regulator_dev *rdev,
 	return NULL;
 }
 
+static int _regulator_get_enable_time(struct regulator_dev *rdev)
+{
+	if (!rdev->desc->ops->enable_time)
+		return 0;
+	return rdev->desc->ops->enable_time(rdev);
+}
+
 /* Internal regulator request function */
 static struct regulator *_regulator_get(struct device *dev, const char *id,
 					int exclusive)
@@ -1251,7 +1259,7 @@ static int _regulator_can_change_status(struct regulator_dev *rdev)
 /* locks held by regulator_enable() */
 static int _regulator_enable(struct regulator_dev *rdev)
 {
-	int ret;
+	int ret, delay;
 
 	/* do we need to enable the supply regulator first */
 	if (rdev->supply) {
@@ -1275,13 +1283,34 @@ static int _regulator_enable(struct regulator_dev *rdev)
 			if (!_regulator_can_change_status(rdev))
 				return -EPERM;
 
-			if (rdev->desc->ops->enable) {
-				ret = rdev->desc->ops->enable(rdev);
-				if (ret < 0)
-					return ret;
-			} else {
+			if (!rdev->desc->ops->enable)
 				return -EINVAL;
+
+			/* Query before enabling in case configuration
+			 * dependant.  */
+			ret = _regulator_get_enable_time(rdev);
+			if (ret >= 0) {
+				delay = ret;
+			} else {
+				printk(KERN_WARNING
+					"%s: enable_time() failed for %s: %d\n",
+					__func__, rdev_get_name(rdev),
+					ret);
+				delay = 0;
 			}
+
+			/* Allow the regulator to ramp; it would be useful
+			 * to extend this for bulk operations so that the
+			 * regulators can ramp together.  */
+			ret = rdev->desc->ops->enable(rdev);
+			if (ret < 0)
+				return ret;
+
+			if (delay >= 1000)
+				mdelay(delay / 1000);
+			else if (delay)
+				udelay(delay);
+
 		} else if (ret < 0) {
 			printk(KERN_ERR "%s: is_enabled() failed for %s: %d\n",
 			       __func__, rdev_get_name(rdev), ret);

commit 84b6826306119dc3c41ef9d7ed6c408112f63301
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Dec 1 21:12:27 2009 +0000

    regulator: Add notifier event on regulator disable
    
    The intended use case is for drivers which disable regulators to save
    power but need to do some work to restore the hardware state when
    restarting.  If the supplies are not actually disabled due to board
    limits or sharing with other active devices this notifier allows the
    driver to avoid unneeded reinitialisation, particularly when used with
    runtime PM.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index b60a4c9f8f16..6d2ce8a05331 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1341,6 +1341,9 @@ static int _regulator_disable(struct regulator_dev *rdev)
 				       __func__, rdev_get_name(rdev));
 				return ret;
 			}
+
+			_notifier_call_chain(rdev, REGULATOR_EVENT_DISABLE,
+					     NULL);
 		}
 
 		/* decrease our supplies ref count and disable if required */
@@ -1399,8 +1402,8 @@ static int _regulator_force_disable(struct regulator_dev *rdev)
 			return ret;
 		}
 		/* notify other consumers that power has been forced off */
-		_notifier_call_chain(rdev, REGULATOR_EVENT_FORCE_DISABLE,
-			NULL);
+		_notifier_call_chain(rdev, REGULATOR_EVENT_FORCE_DISABLE |
+			REGULATOR_EVENT_DISABLE, NULL);
 	}
 
 	/* decrease our supplies ref count and disable if required */

commit 973e9a2795b3b41d8408a0bb6f87b783c5efc88a
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Thu Feb 11 19:20:48 2010 +0000

    regulator: Fix display of null constraints for regulators
    
    If the regulator constraints are empty and there is no voltage
    reported then nothing will be added to the text displayed for the
    constraints, leading to random stack data being printed. This is
    unlikely to happen for practical regulators since most will at
    least report a voltage but should still be fixed.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Cc: stable@kernel.org
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 686ef270ecf7..b60a4c9f8f16 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -661,7 +661,7 @@ static int suspend_prepare(struct regulator_dev *rdev, suspend_state_t state)
 static void print_constraints(struct regulator_dev *rdev)
 {
 	struct regulation_constraints *constraints = rdev->constraints;
-	char buf[80];
+	char buf[80] = "";
 	int count = 0;
 	int ret;
 

commit eb143ac1b9f56ca9c6dc782d795acda1f60c5fd2
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Tue Dec 15 14:30:01 2009 +0100

    regulator: Fix unbalanced disables/enables in regulator_bulk_{enable,disable} error path
    
    Currently it is possible for regulator_bulk_{enable,disable} operations to
    generate unbalanced regulator_{disable,enable} calls in its error path.
    In case of an error only those regulators of the bulk operation which actually
    had been enabled/disabled should get their original state restored.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 1af8df203b72..686ef270ecf7 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1977,7 +1977,7 @@ int regulator_bulk_enable(int num_consumers,
 
 err:
 	printk(KERN_ERR "Failed to enable %s: %d\n", consumers[i].supply, ret);
-	for (i = 0; i < num_consumers; i++)
+	for (--i; i >= 0; --i)
 		regulator_disable(consumers[i].consumer);
 
 	return ret;
@@ -2013,7 +2013,7 @@ int regulator_bulk_disable(int num_consumers,
 err:
 	printk(KERN_ERR "Failed to disable %s: %d\n", consumers[i].supply,
 	       ret);
-	for (i = 0; i < num_consumers; i++)
+	for (--i; i >= 0; --i)
 		regulator_enable(consumers[i].consumer);
 
 	return ret;

commit fa2984d4691c96367d6666694ecc6744135174c6
Author: Stefan Roese <sr@denx.de>
Date:   Fri Nov 27 15:56:34 2009 +0100

    regulator: core.c: Small coding style cleanup (indentation fixup)
    
    Signed-off-by: Stefan Roese <sr@denx.de>
    Cc: Liam Girdwood <lrg@slimlogic.co.uk>
    Cc: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 2dab0d9e11f5..1af8df203b72 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -390,7 +390,7 @@ static ssize_t regulator_total_uA_show(struct device *dev,
 
 	mutex_lock(&rdev->mutex);
 	list_for_each_entry(regulator, &rdev->consumer_list, list)
-	    uA += regulator->uA_load;
+		uA += regulator->uA_load;
 	mutex_unlock(&rdev->mutex);
 	return sprintf(buf, "%d\n", uA);
 }
@@ -565,7 +565,7 @@ static void drms_uA_update(struct regulator_dev *rdev)
 
 	/* calc total requested load */
 	list_for_each_entry(sibling, &rdev->consumer_list, list)
-	    current_uA += sibling->uA_load;
+		current_uA += sibling->uA_load;
 
 	/* now get the optimum mode for our new total regulator load */
 	mode = rdev->desc->ops->get_optimum_mode(rdev, input_uV,
@@ -1829,7 +1829,7 @@ int regulator_set_optimum_mode(struct regulator *regulator, int uA_load)
 
 	/* calc total requested load for this regulator */
 	list_for_each_entry(consumer, &rdev->consumer_list, list)
-	    total_uA_load += consumer->uA_load;
+		total_uA_load += consumer->uA_load;
 
 	mode = rdev->desc->ops->get_optimum_mode(rdev,
 						 input_uV, output_uV,
@@ -1898,9 +1898,9 @@ static void _notifier_call_chain(struct regulator_dev *rdev,
 
 	/* now notify regulator we supply */
 	list_for_each_entry(_rdev, &rdev->supply_list, slist) {
-	  mutex_lock(&_rdev->mutex);
-	  _notifier_call_chain(_rdev, event, data);
-	  mutex_unlock(&_rdev->mutex);
+		mutex_lock(&_rdev->mutex);
+		_notifier_call_chain(_rdev, event, data);
+		mutex_unlock(&_rdev->mutex);
 	}
 }
 

commit 638f85c54f4fed0f8f1fbc23745a8f334112e892
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Thu Oct 22 16:31:33 2009 +0100

    regulator: Handle regulators without suspend mode configuration
    
    Since some regulators in the system may not support suspend mode
    configuration we need to allow some regulators to have a missing
    suspend mode configuration. Do this by requiring that disabled
    regulators are explicitly flagged and then skip over regulators
    that have no state specified.
    
    Try to avoid surprises by warning the if we could set the state
    but no configuration is provided.  This also ensures that an all
    zeros configuration generates a warning rather than silently
    disabling the regulator.
    
    Reported-by: Joonyoung Shim <jy0922.shim@samsung.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 7d0c0d7d90ca..2dab0d9e11f5 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -581,10 +581,29 @@ static int suspend_set_state(struct regulator_dev *rdev,
 	struct regulator_state *rstate)
 {
 	int ret = 0;
+	bool can_set_state;
 
-	/* enable & disable are mandatory for suspend control */
-	if (!rdev->desc->ops->set_suspend_enable ||
-		!rdev->desc->ops->set_suspend_disable) {
+	can_set_state = rdev->desc->ops->set_suspend_enable &&
+		rdev->desc->ops->set_suspend_disable;
+
+	/* If we have no suspend mode configration don't set anything;
+	 * only warn if the driver actually makes the suspend mode
+	 * configurable.
+	 */
+	if (!rstate->enabled && !rstate->disabled) {
+		if (can_set_state)
+			printk(KERN_WARNING "%s: No configuration for %s\n",
+			       __func__, rdev_get_name(rdev));
+		return 0;
+	}
+
+	if (rstate->enabled && rstate->disabled) {
+		printk(KERN_ERR "%s: invalid configuration for %s\n",
+		       __func__, rdev_get_name(rdev));
+		return -EINVAL;
+	}
+
+	if (!can_set_state) {
 		printk(KERN_ERR "%s: no way to set suspend state\n",
 			__func__);
 		return -EINVAL;

commit 1083c39346d482b9001944d05c09191027892226
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Thu Oct 22 16:31:32 2009 +0100

    regulator: Factor out regulator name pretty printing
    
    Some of the regulator API functions have code to allow the machine
    constraints to override the device supplied name for the regulator
    in the constraints in order to help tie logging to supplies on the
    board and disambiguate when there is more than one regulator chip
    in the system. Factor this code out into a new rdev_get_name()
    function and use it throughout the regulator API so that we always
    use the same name.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index d3be67e18519..7d0c0d7d90ca 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -66,6 +66,16 @@ static unsigned int _regulator_get_mode(struct regulator_dev *rdev);
 static void _notifier_call_chain(struct regulator_dev *rdev,
 				  unsigned long event, void *data);
 
+static const char *rdev_get_name(struct regulator_dev *rdev)
+{
+	if (rdev->constraints && rdev->constraints->name)
+		return rdev->constraints->name;
+	else if (rdev->desc->name)
+		return rdev->desc->name;
+	else
+		return "";
+}
+
 /* gets the regulator for a given consumer device */
 static struct regulator *get_device_regulator(struct device *dev)
 {
@@ -96,12 +106,12 @@ static int regulator_check_voltage(struct regulator_dev *rdev,
 
 	if (!rdev->constraints) {
 		printk(KERN_ERR "%s: no constraints for %s\n", __func__,
-		       rdev->desc->name);
+		       rdev_get_name(rdev));
 		return -ENODEV;
 	}
 	if (!(rdev->constraints->valid_ops_mask & REGULATOR_CHANGE_VOLTAGE)) {
 		printk(KERN_ERR "%s: operation not allowed for %s\n",
-		       __func__, rdev->desc->name);
+		       __func__, rdev_get_name(rdev));
 		return -EPERM;
 	}
 
@@ -124,12 +134,12 @@ static int regulator_check_current_limit(struct regulator_dev *rdev,
 
 	if (!rdev->constraints) {
 		printk(KERN_ERR "%s: no constraints for %s\n", __func__,
-		       rdev->desc->name);
+		       rdev_get_name(rdev));
 		return -ENODEV;
 	}
 	if (!(rdev->constraints->valid_ops_mask & REGULATOR_CHANGE_CURRENT)) {
 		printk(KERN_ERR "%s: operation not allowed for %s\n",
-		       __func__, rdev->desc->name);
+		       __func__, rdev_get_name(rdev));
 		return -EPERM;
 	}
 
@@ -159,17 +169,17 @@ static int regulator_check_mode(struct regulator_dev *rdev, int mode)
 
 	if (!rdev->constraints) {
 		printk(KERN_ERR "%s: no constraints for %s\n", __func__,
-		       rdev->desc->name);
+		       rdev_get_name(rdev));
 		return -ENODEV;
 	}
 	if (!(rdev->constraints->valid_ops_mask & REGULATOR_CHANGE_MODE)) {
 		printk(KERN_ERR "%s: operation not allowed for %s\n",
-		       __func__, rdev->desc->name);
+		       __func__, rdev_get_name(rdev));
 		return -EPERM;
 	}
 	if (!(rdev->constraints->valid_modes_mask & mode)) {
 		printk(KERN_ERR "%s: invalid mode %x for %s\n",
-		       __func__, mode, rdev->desc->name);
+		       __func__, mode, rdev_get_name(rdev));
 		return -EINVAL;
 	}
 	return 0;
@@ -180,12 +190,12 @@ static int regulator_check_drms(struct regulator_dev *rdev)
 {
 	if (!rdev->constraints) {
 		printk(KERN_ERR "%s: no constraints for %s\n", __func__,
-		       rdev->desc->name);
+		       rdev_get_name(rdev));
 		return -ENODEV;
 	}
 	if (!(rdev->constraints->valid_ops_mask & REGULATOR_CHANGE_DRMS)) {
 		printk(KERN_ERR "%s: operation not allowed for %s\n",
-		       __func__, rdev->desc->name);
+		       __func__, rdev_get_name(rdev));
 		return -EPERM;
 	}
 	return 0;
@@ -230,16 +240,8 @@ static ssize_t regulator_name_show(struct device *dev,
 			     struct device_attribute *attr, char *buf)
 {
 	struct regulator_dev *rdev = dev_get_drvdata(dev);
-	const char *name;
 
-	if (rdev->constraints && rdev->constraints->name)
-		name = rdev->constraints->name;
-	else if (rdev->desc->name)
-		name = rdev->desc->name;
-	else
-		name = "";
-
-	return sprintf(buf, "%s\n", name);
+	return sprintf(buf, "%s\n", rdev_get_name(rdev));
 }
 
 static ssize_t regulator_print_opmode(char *buf, int mode)
@@ -687,13 +689,14 @@ static void print_constraints(struct regulator_dev *rdev)
 	if (constraints->valid_modes_mask & REGULATOR_MODE_STANDBY)
 		count += sprintf(buf + count, "standby");
 
-	printk(KERN_INFO "regulator: %s: %s\n", rdev->desc->name, buf);
+	printk(KERN_INFO "regulator: %s: %s\n", rdev_get_name(rdev), buf);
 }
 
 static int machine_constraints_voltage(struct regulator_dev *rdev,
-	const char *name, struct regulation_constraints *constraints)
+	struct regulation_constraints *constraints)
 {
 	struct regulator_ops *ops = rdev->desc->ops;
+	const char *name = rdev_get_name(rdev);
 	int ret;
 
 	/* do we need to apply the constraint voltage */
@@ -800,16 +803,11 @@ static int set_machine_constraints(struct regulator_dev *rdev,
 	const char *name;
 	struct regulator_ops *ops = rdev->desc->ops;
 
-	if (constraints->name)
-		name = constraints->name;
-	else if (rdev->desc->name)
-		name = rdev->desc->name;
-	else
-		name = "regulator";
-
 	rdev->constraints = constraints;
 
-	ret = machine_constraints_voltage(rdev, name, constraints);
+	name = rdev_get_name(rdev);
+
+	ret = machine_constraints_voltage(rdev, constraints);
 	if (ret != 0)
 		goto out;
 
@@ -932,7 +930,7 @@ static int set_consumer_device_supply(struct regulator_dev *rdev,
 				dev_name(&node->regulator->dev),
 				node->regulator->desc->name,
 				supply,
-				dev_name(&rdev->dev), rdev->desc->name);
+				dev_name(&rdev->dev), rdev_get_name(rdev));
 		return -EBUSY;
 	}
 
@@ -1241,7 +1239,7 @@ static int _regulator_enable(struct regulator_dev *rdev)
 		ret = _regulator_enable(rdev->supply);
 		if (ret < 0) {
 			printk(KERN_ERR "%s: failed to enable %s: %d\n",
-			       __func__, rdev->desc->name, ret);
+			       __func__, rdev_get_name(rdev), ret);
 			return ret;
 		}
 	}
@@ -1267,7 +1265,7 @@ static int _regulator_enable(struct regulator_dev *rdev)
 			}
 		} else if (ret < 0) {
 			printk(KERN_ERR "%s: is_enabled() failed for %s: %d\n",
-			       __func__, rdev->desc->name, ret);
+			       __func__, rdev_get_name(rdev), ret);
 			return ret;
 		}
 		/* Fallthrough on positive return values - already enabled */
@@ -1308,7 +1306,7 @@ static int _regulator_disable(struct regulator_dev *rdev)
 
 	if (WARN(rdev->use_count <= 0,
 			"unbalanced disables for %s\n",
-			rdev->desc->name))
+			rdev_get_name(rdev)))
 		return -EIO;
 
 	/* are we the last user and permitted to disable ? */
@@ -1321,7 +1319,7 @@ static int _regulator_disable(struct regulator_dev *rdev)
 			ret = rdev->desc->ops->disable(rdev);
 			if (ret < 0) {
 				printk(KERN_ERR "%s: failed to disable %s\n",
-				       __func__, rdev->desc->name);
+				       __func__, rdev_get_name(rdev));
 				return ret;
 			}
 		}
@@ -1378,7 +1376,7 @@ static int _regulator_force_disable(struct regulator_dev *rdev)
 		ret = rdev->desc->ops->disable(rdev);
 		if (ret < 0) {
 			printk(KERN_ERR "%s: failed to force disable %s\n",
-			       __func__, rdev->desc->name);
+			       __func__, rdev_get_name(rdev));
 			return ret;
 		}
 		/* notify other consumers that power has been forced off */
@@ -1795,7 +1793,7 @@ int regulator_set_optimum_mode(struct regulator *regulator, int uA_load)
 	output_uV = rdev->desc->ops->get_voltage(rdev);
 	if (output_uV <= 0) {
 		printk(KERN_ERR "%s: invalid output voltage found for %s\n",
-			__func__, rdev->desc->name);
+			__func__, rdev_get_name(rdev));
 		goto out;
 	}
 
@@ -1806,7 +1804,7 @@ int regulator_set_optimum_mode(struct regulator *regulator, int uA_load)
 		input_uV = rdev->constraints->input_uV;
 	if (input_uV <= 0) {
 		printk(KERN_ERR "%s: invalid input voltage found for %s\n",
-			__func__, rdev->desc->name);
+			__func__, rdev_get_name(rdev));
 		goto out;
 	}
 
@@ -1820,7 +1818,7 @@ int regulator_set_optimum_mode(struct regulator *regulator, int uA_load)
 	ret = regulator_check_mode(rdev, mode);
 	if (ret < 0) {
 		printk(KERN_ERR "%s: failed to get optimum mode for %s @"
-			" %d uA %d -> %d uV\n", __func__, rdev->desc->name,
+			" %d uA %d -> %d uV\n", __func__, rdev_get_name(rdev),
 			total_uA_load, input_uV, output_uV);
 		goto out;
 	}
@@ -1828,7 +1826,7 @@ int regulator_set_optimum_mode(struct regulator *regulator, int uA_load)
 	ret = rdev->desc->ops->set_mode(rdev, mode);
 	if (ret < 0) {
 		printk(KERN_ERR "%s: failed to set optimum mode %x for %s\n",
-			__func__, mode, rdev->desc->name);
+			__func__, mode, rdev_get_name(rdev));
 		goto out;
 	}
 	ret = mode;
@@ -2346,7 +2344,7 @@ int regulator_suspend_prepare(suspend_state_t state)
 
 		if (ret < 0) {
 			printk(KERN_ERR "%s: failed to prepare %s\n",
-				__func__, rdev->desc->name);
+				__func__, rdev_get_name(rdev));
 			goto out;
 		}
 	}
@@ -2459,12 +2457,7 @@ static int __init regulator_init_complete(void)
 		ops = rdev->desc->ops;
 		c = rdev->constraints;
 
-		if (c && c->name)
-			name = c->name;
-		else if (rdev->desc->name)
-			name = rdev->desc->name;
-		else
-			name = "regulator";
+		name = rdev_get_name(rdev);
 
 		if (!ops->disable || (c && c->always_on))
 			continue;

commit 8f031b48cd2eab5fc3e4dffa06706372e90d63fe
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Thu Oct 22 16:31:31 2009 +0100

    regulator: Display actual settings with constraints
    
    When voltage or current constraints are either missing or specify
    a range display the actual setting along with the constraints if
    we can. This can aid debugging of configuration problems.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 1848a3f0980e..d3be67e18519 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -641,25 +641,43 @@ static void print_constraints(struct regulator_dev *rdev)
 {
 	struct regulation_constraints *constraints = rdev->constraints;
 	char buf[80];
-	int count;
+	int count = 0;
+	int ret;
 
-	if (rdev->desc->type == REGULATOR_VOLTAGE) {
+	if (constraints->min_uV && constraints->max_uV) {
 		if (constraints->min_uV == constraints->max_uV)
-			count = sprintf(buf, "%d mV ",
-					constraints->min_uV / 1000);
+			count += sprintf(buf + count, "%d mV ",
+					 constraints->min_uV / 1000);
 		else
-			count = sprintf(buf, "%d <--> %d mV ",
-					constraints->min_uV / 1000,
-					constraints->max_uV / 1000);
-	} else {
+			count += sprintf(buf + count, "%d <--> %d mV ",
+					 constraints->min_uV / 1000,
+					 constraints->max_uV / 1000);
+	}
+
+	if (!constraints->min_uV ||
+	    constraints->min_uV != constraints->max_uV) {
+		ret = _regulator_get_voltage(rdev);
+		if (ret > 0)
+			count += sprintf(buf + count, "at %d mV ", ret / 1000);
+	}
+
+	if (constraints->min_uA && constraints->max_uA) {
 		if (constraints->min_uA == constraints->max_uA)
-			count = sprintf(buf, "%d mA ",
-					constraints->min_uA / 1000);
+			count += sprintf(buf + count, "%d mA ",
+					 constraints->min_uA / 1000);
 		else
-			count = sprintf(buf, "%d <--> %d mA ",
-					constraints->min_uA / 1000,
-					constraints->max_uA / 1000);
+			count += sprintf(buf + count, "%d <--> %d mA ",
+					 constraints->min_uA / 1000,
+					 constraints->max_uA / 1000);
 	}
+
+	if (!constraints->min_uA ||
+	    constraints->min_uA != constraints->max_uA) {
+		ret = _regulator_get_current_limit(rdev);
+		if (ret > 0)
+			count += sprintf(buf + count, "at %d uA ", ret / 1000);
+	}
+
 	if (constraints->valid_modes_mask & REGULATOR_MODE_FAST)
 		count += sprintf(buf + count, "fast ");
 	if (constraints->valid_modes_mask & REGULATOR_MODE_NORMAL)

commit af5866c9cdc9e43ef775a14765fd8eab95c7fd20
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Thu Oct 22 16:31:30 2009 +0100

    regulator: Also lift apply_uV into machine_constraints_voltage()
    
    It makes sense to do all the voltage configuration in the one split
    out function.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index c1a49917af24..1848a3f0980e 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -676,6 +676,22 @@ static int machine_constraints_voltage(struct regulator_dev *rdev,
 	const char *name, struct regulation_constraints *constraints)
 {
 	struct regulator_ops *ops = rdev->desc->ops;
+	int ret;
+
+	/* do we need to apply the constraint voltage */
+	if (rdev->constraints->apply_uV &&
+		rdev->constraints->min_uV == rdev->constraints->max_uV &&
+		ops->set_voltage) {
+		ret = ops->set_voltage(rdev,
+			rdev->constraints->min_uV, rdev->constraints->max_uV);
+			if (ret < 0) {
+				printk(KERN_ERR "%s: failed to apply %duV constraint to %s\n",
+				       __func__,
+				       rdev->constraints->min_uV, name);
+				rdev->constraints = NULL;
+				return ret;
+			}
+	}
 
 	/* constrain machine-level voltage specs to fit
 	 * the actual range supported by this regulator.
@@ -773,27 +789,12 @@ static int set_machine_constraints(struct regulator_dev *rdev,
 	else
 		name = "regulator";
 
+	rdev->constraints = constraints;
+
 	ret = machine_constraints_voltage(rdev, name, constraints);
 	if (ret != 0)
 		goto out;
 
-	rdev->constraints = constraints;
-
-	/* do we need to apply the constraint voltage */
-	if (rdev->constraints->apply_uV &&
-		rdev->constraints->min_uV == rdev->constraints->max_uV &&
-		ops->set_voltage) {
-		ret = ops->set_voltage(rdev,
-			rdev->constraints->min_uV, rdev->constraints->max_uV);
-			if (ret < 0) {
-				printk(KERN_ERR "%s: failed to apply %duV constraint to %s\n",
-				       __func__,
-				       rdev->constraints->min_uV, name);
-				rdev->constraints = NULL;
-				goto out;
-			}
-	}
-
 	/* do we need to setup our suspend state */
 	if (constraints->initial_state) {
 		ret = suspend_prepare(rdev, constraints->initial_state);

commit e79055d62ea6ca3c36962209f4c819614972c95a
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Oct 19 15:53:50 2009 +0100

    regulator: Factor out voltage constraint setup
    
    This allows constraints to take effect on regulators that support
    voltage setting but for which the board does not specify a voltage
    range (for example, because it is fixed correctly at system startup).
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 9b43dab16387..c1a49917af24 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -672,31 +672,11 @@ static void print_constraints(struct regulator_dev *rdev)
 	printk(KERN_INFO "regulator: %s: %s\n", rdev->desc->name, buf);
 }
 
-/**
- * set_machine_constraints - sets regulator constraints
- * @rdev: regulator source
- * @constraints: constraints to apply
- *
- * Allows platform initialisation code to define and constrain
- * regulator circuits e.g. valid voltage/current ranges, etc.  NOTE:
- * Constraints *must* be set by platform code in order for some
- * regulator operations to proceed i.e. set_voltage, set_current_limit,
- * set_mode.
- */
-static int set_machine_constraints(struct regulator_dev *rdev,
-	struct regulation_constraints *constraints)
+static int machine_constraints_voltage(struct regulator_dev *rdev,
+	const char *name, struct regulation_constraints *constraints)
 {
-	int ret = 0;
-	const char *name;
 	struct regulator_ops *ops = rdev->desc->ops;
 
-	if (constraints->name)
-		name = constraints->name;
-	else if (rdev->desc->name)
-		name = rdev->desc->name;
-	else
-		name = "regulator";
-
 	/* constrain machine-level voltage specs to fit
 	 * the actual range supported by this regulator.
 	 */
@@ -719,14 +699,13 @@ static int set_machine_constraints(struct regulator_dev *rdev,
 
 		/* voltage constraints are optional */
 		if ((cmin == 0) && (cmax == 0))
-			goto out;
+			return 0;
 
 		/* else require explicit machine-level constraints */
 		if (cmin <= 0 || cmax <= 0 || cmax < cmin) {
 			pr_err("%s: %s '%s' voltage constraints\n",
 				       __func__, "invalid", name);
-			ret = -EINVAL;
-			goto out;
+			return -EINVAL;
 		}
 
 		/* initial: [cmin..cmax] valid, [min_uV..max_uV] not */
@@ -748,8 +727,7 @@ static int set_machine_constraints(struct regulator_dev *rdev,
 		if (max_uV < min_uV) {
 			pr_err("%s: %s '%s' voltage constraints\n",
 				       __func__, "unsupportable", name);
-			ret = -EINVAL;
-			goto out;
+			return -EINVAL;
 		}
 
 		/* use regulator's subset of machine constraints */
@@ -767,6 +745,38 @@ static int set_machine_constraints(struct regulator_dev *rdev,
 		}
 	}
 
+	return 0;
+}
+
+/**
+ * set_machine_constraints - sets regulator constraints
+ * @rdev: regulator source
+ * @constraints: constraints to apply
+ *
+ * Allows platform initialisation code to define and constrain
+ * regulator circuits e.g. valid voltage/current ranges, etc.  NOTE:
+ * Constraints *must* be set by platform code in order for some
+ * regulator operations to proceed i.e. set_voltage, set_current_limit,
+ * set_mode.
+ */
+static int set_machine_constraints(struct regulator_dev *rdev,
+	struct regulation_constraints *constraints)
+{
+	int ret = 0;
+	const char *name;
+	struct regulator_ops *ops = rdev->desc->ops;
+
+	if (constraints->name)
+		name = constraints->name;
+	else if (rdev->desc->name)
+		name = rdev->desc->name;
+	else
+		name = "regulator";
+
+	ret = machine_constraints_voltage(rdev, name, constraints);
+	if (ret != 0)
+		goto out;
+
 	rdev->constraints = constraints;
 
 	/* do we need to apply the constraint voltage */

commit 5b307627738f1f6cbc31fad9e28a299b5fe55602
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Oct 13 13:06:49 2009 +0100

    regulator: Report error codes for bulk operations
    
    If we're going to log an error we may as well log what the error
    code that we're failing on is.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index efe568deda12..9b43dab16387 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1885,9 +1885,9 @@ int regulator_bulk_get(struct device *dev, int num_consumers,
 		consumers[i].consumer = regulator_get(dev,
 						      consumers[i].supply);
 		if (IS_ERR(consumers[i].consumer)) {
-			dev_err(dev, "Failed to get supply '%s'\n",
-				consumers[i].supply);
 			ret = PTR_ERR(consumers[i].consumer);
+			dev_err(dev, "Failed to get supply '%s': %d\n",
+				consumers[i].supply, ret);
 			consumers[i].consumer = NULL;
 			goto err;
 		}
@@ -1930,7 +1930,7 @@ int regulator_bulk_enable(int num_consumers,
 	return 0;
 
 err:
-	printk(KERN_ERR "Failed to enable %s\n", consumers[i].supply);
+	printk(KERN_ERR "Failed to enable %s: %d\n", consumers[i].supply, ret);
 	for (i = 0; i < num_consumers; i++)
 		regulator_disable(consumers[i].consumer);
 
@@ -1965,7 +1965,8 @@ int regulator_bulk_disable(int num_consumers,
 	return 0;
 
 err:
-	printk(KERN_ERR "Failed to disable %s\n", consumers[i].supply);
+	printk(KERN_ERR "Failed to disable %s: %d\n", consumers[i].supply,
+	       ret);
 	for (i = 0; i < num_consumers; i++)
 		regulator_enable(consumers[i].consumer);
 

commit 60ef66fcf40f0e7bc9579981aa16bd8218942a83
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Oct 13 13:06:50 2009 +0100

    regulator: Handle missing constraints in _regulator_disable()
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 744ea1d0b59b..efe568deda12 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1283,7 +1283,8 @@ static int _regulator_disable(struct regulator_dev *rdev)
 		return -EIO;
 
 	/* are we the last user and permitted to disable ? */
-	if (rdev->use_count == 1 && !rdev->constraints->always_on) {
+	if (rdev->use_count == 1 &&
+	    (rdev->constraints && !rdev->constraints->always_on)) {
 
 		/* we are last user */
 		if (_regulator_can_change_status(rdev) &&

commit a7433cff9ed8e7982de8e0f210f0325d0f3d1949
Author: Linus Walleij <linus.walleij@stericsson.com>
Date:   Wed Aug 26 12:54:04 2009 +0200

    REGULATOR Handle positive returncode from enable
    
    This makes _regulator_enable() properly handle the case where
    a regulator is already on when you try to enable it. Currently
    it will erroneously handle positive return values as an error.
    
    Signed-off-by: Linus Walleij <linus.walleij@stericsson.com>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index dbf27bf028c4..744ea1d0b59b 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1236,11 +1236,12 @@ static int _regulator_enable(struct regulator_dev *rdev)
 			} else {
 				return -EINVAL;
 			}
-		} else {
+		} else if (ret < 0) {
 			printk(KERN_ERR "%s: is_enabled() failed for %s: %d\n",
 			       __func__, rdev->desc->name, ret);
 			return ret;
 		}
+		/* Fallthrough on positive return values - already enabled */
 	}
 
 	rdev->use_count++;

commit 9a2372fa7a403ba327873d0208a619d781a8a150
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Aug 3 18:49:57 2009 +0100

    regulator: regulator_enable() permission checking
    
    The regulator_enable() code wasn't actually checking that the
    machine constraints had given permission to enable the regulator.
    Add code to do that, but only if the regulator is not already on
    due to something like always_on or being left on at startup since
    in those cases there's no physical change being introduced and the
    constraint wouldn't make any sense.
    
    Also add matching code for disable(). We need to do less there since
    either regulator_enable() should have succeeded first or the board
    setup makes no sense.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 60fcd986ff3f..dbf27bf028c4 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1191,16 +1191,21 @@ void regulator_put(struct regulator *regulator)
 }
 EXPORT_SYMBOL_GPL(regulator_put);
 
+static int _regulator_can_change_status(struct regulator_dev *rdev)
+{
+	if (!rdev->constraints)
+		return 0;
+
+	if (rdev->constraints->valid_ops_mask & REGULATOR_CHANGE_STATUS)
+		return 1;
+	else
+		return 0;
+}
+
 /* locks held by regulator_enable() */
 static int _regulator_enable(struct regulator_dev *rdev)
 {
-	int ret = -EINVAL;
-
-	if (!rdev->constraints) {
-		printk(KERN_ERR "%s: %s has no constraints\n",
-		       __func__, rdev->desc->name);
-		return ret;
-	}
+	int ret;
 
 	/* do we need to enable the supply regulator first */
 	if (rdev->supply) {
@@ -1213,24 +1218,34 @@ static int _regulator_enable(struct regulator_dev *rdev)
 	}
 
 	/* check voltage and requested load before enabling */
-	if (rdev->desc->ops->enable) {
+	if (rdev->constraints &&
+	    (rdev->constraints->valid_ops_mask & REGULATOR_CHANGE_DRMS))
+		drms_uA_update(rdev);
 
-		if (rdev->constraints &&
-			(rdev->constraints->valid_ops_mask &
-			REGULATOR_CHANGE_DRMS))
-			drms_uA_update(rdev);
-
-		ret = rdev->desc->ops->enable(rdev);
-		if (ret < 0) {
-			printk(KERN_ERR "%s: failed to enable %s: %d\n",
+	if (rdev->use_count == 0) {
+		/* The regulator may on if it's not switchable or left on */
+		ret = _regulator_is_enabled(rdev);
+		if (ret == -EINVAL || ret == 0) {
+			if (!_regulator_can_change_status(rdev))
+				return -EPERM;
+
+			if (rdev->desc->ops->enable) {
+				ret = rdev->desc->ops->enable(rdev);
+				if (ret < 0)
+					return ret;
+			} else {
+				return -EINVAL;
+			}
+		} else {
+			printk(KERN_ERR "%s: is_enabled() failed for %s: %d\n",
 			       __func__, rdev->desc->name, ret);
 			return ret;
 		}
-		rdev->use_count++;
-		return ret;
 	}
 
-	return ret;
+	rdev->use_count++;
+
+	return 0;
 }
 
 /**
@@ -1270,7 +1285,8 @@ static int _regulator_disable(struct regulator_dev *rdev)
 	if (rdev->use_count == 1 && !rdev->constraints->always_on) {
 
 		/* we are last user */
-		if (rdev->desc->ops->disable) {
+		if (_regulator_can_change_status(rdev) &&
+		    rdev->desc->ops->disable) {
 			ret = rdev->desc->ops->disable(rdev);
 			if (ret < 0) {
 				printk(KERN_ERR "%s: failed to disable %s\n",

commit 9332546fe88fa88bf6a7d9b1dce53ff5d314934e
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Aug 3 18:49:56 2009 +0100

    regulator: Push locking for regulator_is_enabled() out
    
    Allows use by more of the internal regulator API code.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index dfbf4312ec34..60fcd986ff3f 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -280,8 +280,13 @@ static ssize_t regulator_state_show(struct device *dev,
 				   struct device_attribute *attr, char *buf)
 {
 	struct regulator_dev *rdev = dev_get_drvdata(dev);
+	ssize_t ret;
+
+	mutex_lock(&rdev->mutex);
+	ret = regulator_print_state(buf, _regulator_is_enabled(rdev));
+	mutex_unlock(&rdev->mutex);
 
-	return regulator_print_state(buf, _regulator_is_enabled(rdev));
+	return ret;
 }
 static DEVICE_ATTR(state, 0444, regulator_state_show, NULL);
 
@@ -1365,20 +1370,11 @@ EXPORT_SYMBOL_GPL(regulator_force_disable);
 
 static int _regulator_is_enabled(struct regulator_dev *rdev)
 {
-	int ret;
-
-	mutex_lock(&rdev->mutex);
-
 	/* sanity check */
-	if (!rdev->desc->ops->is_enabled) {
-		ret = -EINVAL;
-		goto out;
-	}
+	if (!rdev->desc->ops->is_enabled)
+		return -EINVAL;
 
-	ret = rdev->desc->ops->is_enabled(rdev);
-out:
-	mutex_unlock(&rdev->mutex);
-	return ret;
+	return rdev->desc->ops->is_enabled(rdev);
 }
 
 /**
@@ -1395,7 +1391,13 @@ static int _regulator_is_enabled(struct regulator_dev *rdev)
  */
 int regulator_is_enabled(struct regulator *regulator)
 {
-	return _regulator_is_enabled(regulator->rdev);
+	int ret;
+
+	mutex_lock(&regulator->rdev->mutex);
+	ret = _regulator_is_enabled(regulator->rdev);
+	mutex_unlock(&regulator->rdev->mutex);
+
+	return ret;
 }
 EXPORT_SYMBOL_GPL(regulator_is_enabled);
 

commit f25e0b4fcc38d120e704c377791158c4b2a54daa
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Aug 3 18:49:55 2009 +0100

    regulator: Check for constraints in regulator_init_complete()
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 6e0c723371d8..dfbf4312ec34 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2409,14 +2409,14 @@ static int __init regulator_init_complete(void)
 		ops = rdev->desc->ops;
 		c = rdev->constraints;
 
-		if (c->name)
+		if (c && c->name)
 			name = c->name;
 		else if (rdev->desc->name)
 			name = rdev->desc->name;
 		else
 			name = "regulator";
 
-		if (!ops->disable || c->always_on)
+		if (!ops->disable || (c && c->always_on))
 			continue;
 
 		mutex_lock(&rdev->mutex);

commit b39480ac37951de126455991744c9dbb61bbb839
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Aug 3 18:49:54 2009 +0100

    regulator: Check for constraints before using them for name
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index e38db55600e0..6e0c723371d8 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -232,7 +232,7 @@ static ssize_t regulator_name_show(struct device *dev,
 	struct regulator_dev *rdev = dev_get_drvdata(dev);
 	const char *name;
 
-	if (rdev->constraints->name)
+	if (rdev->constraints && rdev->constraints->name)
 		name = rdev->constraints->name;
 	else if (rdev->desc->name)
 		name = rdev->desc->name;

commit 9ed2099edca26d07947beb42c12bd1d6669e82bc
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Jul 21 16:00:26 2009 +0100

    regulator: Fix support for deviceless supply mappings
    
    The patch to add support for looking up consumers by device name
    had the side effect of causing us to require a device which is
    at best premature since at least cpufreq still operates outside
    the device model. Remove that requirement.
    
    Reported-by: Haojian Zhuang <haojian.zhuang@gmail.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 79a6910eb894..e38db55600e0 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -872,6 +872,7 @@ static int set_consumer_device_supply(struct regulator_dev *rdev,
 	const char *supply)
 {
 	struct regulator_map *node;
+	int has_dev;
 
 	if (consumer_dev && consumer_dev_name)
 		return -EINVAL;
@@ -882,6 +883,11 @@ static int set_consumer_device_supply(struct regulator_dev *rdev,
 	if (supply == NULL)
 		return -EINVAL;
 
+	if (consumer_dev_name != NULL)
+		has_dev = 1;
+	else
+		has_dev = 0;
+
 	list_for_each_entry(node, &regulator_map_list, list) {
 		if (consumer_dev_name != node->dev_name)
 			continue;
@@ -896,17 +902,19 @@ static int set_consumer_device_supply(struct regulator_dev *rdev,
 		return -EBUSY;
 	}
 
-	node = kmalloc(sizeof(struct regulator_map), GFP_KERNEL);
+	node = kzalloc(sizeof(struct regulator_map), GFP_KERNEL);
 	if (node == NULL)
 		return -ENOMEM;
 
 	node->regulator = rdev;
-	node->dev_name = kstrdup(consumer_dev_name, GFP_KERNEL);
 	node->supply = supply;
 
-	if (node->dev_name == NULL) {
-		kfree(node);
-		return -ENOMEM;
+	if (has_dev) {
+		node->dev_name = kstrdup(consumer_dev_name, GFP_KERNEL);
+		if (node->dev_name == NULL) {
+			kfree(node);
+			return -ENOMEM;
+		}
 	}
 
 	list_add(&node->list, &regulator_map_list);

commit 6bf87d17c9f5b855e9dde7b3d6f726385b966814
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Jul 21 16:00:25 2009 +0100

    regulator: Warn when unregistering an in-use regulator
    
    We're probably going to start oopsing fairly soon after this happens.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index e11c2222d9af..79a6910eb894 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2253,6 +2253,7 @@ void regulator_unregister(struct regulator_dev *rdev)
 		return;
 
 	mutex_lock(&regulator_list_mutex);
+	WARN_ON(rdev->open_count);
 	unset_regulator_supplies(rdev);
 	list_del(&rdev->list);
 	if (rdev->supply)

commit a7a1ad9066e0266c8a4357ba3dbaeebfb80f531d
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Jul 21 16:00:24 2009 +0100

    regulator: Add regulator voltage range check API
    
    Simplify checking of support for voltage ranges by providing an API which
    wraps the existing count and list operations.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 68549008582c..e11c2222d9af 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1441,6 +1441,35 @@ int regulator_list_voltage(struct regulator *regulator, unsigned selector)
 }
 EXPORT_SYMBOL_GPL(regulator_list_voltage);
 
+/**
+ * regulator_is_supported_voltage - check if a voltage range can be supported
+ *
+ * @regulator: Regulator to check.
+ * @min_uV: Minimum required voltage in uV.
+ * @max_uV: Maximum required voltage in uV.
+ *
+ * Returns a boolean or a negative error code.
+ */
+int regulator_is_supported_voltage(struct regulator *regulator,
+				   int min_uV, int max_uV)
+{
+	int i, voltages, ret;
+
+	ret = regulator_count_voltages(regulator);
+	if (ret < 0)
+		return ret;
+	voltages = ret;
+
+	for (i = 0; i < voltages; i++) {
+		ret = regulator_list_voltage(regulator, i);
+
+		if (ret >= min_uV && ret <= max_uV)
+			return 1;
+	}
+
+	return 0;
+}
+
 /**
  * regulator_set_voltage - set regulator output voltage
  * @regulator: regulator source

commit 5ffbd136e6c51c8d1eec7a4a0c5d2180c81aea30
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Jul 21 16:00:23 2009 +0100

    regulator: Add regulator_get_exclusive() API
    
    Some consumers require complete control of the regulator and can't
    tolerate sharing it with other consumers, most commonly because they need
    to have the regulator actually disabled so can't have other consumers
    forcing it on. This new regulator_get_exclusive() API call allows these
    consumers to explicitly request this, documenting the assumptions that
    they are making.
    
    In order to simplify coding of such consumers the use count for regulators
    they request is forced to match the enabled state of the regulator when
    it is requested. This is not possible for consumers which can share
    regulators due to the need to keep track of the ownership of use counts.
    
    A new API call is used rather than an additional argument to the existing
    regulator_get() in order to avoid merge headaches with driver code in
    other trees.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 24e05b7607b4..68549008582c 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1025,25 +1025,15 @@ static struct regulator *create_regulator(struct regulator_dev *rdev,
 	return NULL;
 }
 
-/**
- * regulator_get - lookup and obtain a reference to a regulator.
- * @dev: device for regulator "consumer"
- * @id: Supply name or regulator ID.
- *
- * Returns a struct regulator corresponding to the regulator producer,
- * or IS_ERR() condition containing errno.
- *
- * Use of supply names configured via regulator_set_device_supply() is
- * strongly encouraged.  It is recommended that the supply name used
- * should match the name used for the supply and/or the relevant
- * device pins in the datasheet.
- */
-struct regulator *regulator_get(struct device *dev, const char *id)
+/* Internal regulator request function */
+static struct regulator *_regulator_get(struct device *dev, const char *id,
+					int exclusive)
 {
 	struct regulator_dev *rdev;
 	struct regulator_map *map;
 	struct regulator *regulator = ERR_PTR(-ENODEV);
 	const char *devname = NULL;
+	int ret;
 
 	if (id == NULL) {
 		printk(KERN_ERR "regulator: get() with no identifier\n");
@@ -1070,6 +1060,16 @@ struct regulator *regulator_get(struct device *dev, const char *id)
 	return regulator;
 
 found:
+	if (rdev->exclusive) {
+		regulator = ERR_PTR(-EPERM);
+		goto out;
+	}
+
+	if (exclusive && rdev->open_count) {
+		regulator = ERR_PTR(-EBUSY);
+		goto out;
+	}
+
 	if (!try_module_get(rdev->owner))
 		goto out;
 
@@ -1079,12 +1079,69 @@ struct regulator *regulator_get(struct device *dev, const char *id)
 		module_put(rdev->owner);
 	}
 
+	rdev->open_count++;
+	if (exclusive) {
+		rdev->exclusive = 1;
+
+		ret = _regulator_is_enabled(rdev);
+		if (ret > 0)
+			rdev->use_count = 1;
+		else
+			rdev->use_count = 0;
+	}
+
 out:
 	mutex_unlock(&regulator_list_mutex);
+
 	return regulator;
 }
+
+/**
+ * regulator_get - lookup and obtain a reference to a regulator.
+ * @dev: device for regulator "consumer"
+ * @id: Supply name or regulator ID.
+ *
+ * Returns a struct regulator corresponding to the regulator producer,
+ * or IS_ERR() condition containing errno.
+ *
+ * Use of supply names configured via regulator_set_device_supply() is
+ * strongly encouraged.  It is recommended that the supply name used
+ * should match the name used for the supply and/or the relevant
+ * device pins in the datasheet.
+ */
+struct regulator *regulator_get(struct device *dev, const char *id)
+{
+	return _regulator_get(dev, id, 0);
+}
 EXPORT_SYMBOL_GPL(regulator_get);
 
+/**
+ * regulator_get_exclusive - obtain exclusive access to a regulator.
+ * @dev: device for regulator "consumer"
+ * @id: Supply name or regulator ID.
+ *
+ * Returns a struct regulator corresponding to the regulator producer,
+ * or IS_ERR() condition containing errno.  Other consumers will be
+ * unable to obtain this reference is held and the use count for the
+ * regulator will be initialised to reflect the current state of the
+ * regulator.
+ *
+ * This is intended for use by consumers which cannot tolerate shared
+ * use of the regulator such as those which need to force the
+ * regulator off for correct operation of the hardware they are
+ * controlling.
+ *
+ * Use of supply names configured via regulator_set_device_supply() is
+ * strongly encouraged.  It is recommended that the supply name used
+ * should match the name used for the supply and/or the relevant
+ * device pins in the datasheet.
+ */
+struct regulator *regulator_get_exclusive(struct device *dev, const char *id)
+{
+	return _regulator_get(dev, id, 1);
+}
+EXPORT_SYMBOL_GPL(regulator_get_exclusive);
+
 /**
  * regulator_put - "free" the regulator source
  * @regulator: regulator source
@@ -1113,6 +1170,9 @@ void regulator_put(struct regulator *regulator)
 	list_del(&regulator->list);
 	kfree(regulator);
 
+	rdev->open_count--;
+	rdev->exclusive = 0;
+
 	module_put(rdev->owner);
 	mutex_unlock(&regulator_list_mutex);
 }

commit 40f9244f4da8976eeb6d5ed6313c635ba238a9d3
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Jun 17 17:56:39 2009 +0100

    regulator: Allow consumer supplies to be set up with dev_name()
    
    Follow the approach suggested by Russell King and implemented by him in
    the clkdev API and allow consumer device supply mapings to be set up
    using the dev_name() for the consumer instead of the struct device.
    In order to avoid making existing machines instabuggy and creating merge
    issues the use of struct device is still supported for the time being.
    
    This resolves problems working with buses such as I2C which make the
    struct device available late providing that the final device name is
    known, which is the case for most embedded systems with fixed setups.
    
    Consumers must still use the struct device when calling regulator_get().
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 91ba9bfaa706..24e05b7607b4 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -37,7 +37,7 @@ static int has_full_constraints;
  */
 struct regulator_map {
 	struct list_head list;
-	struct device *dev;
+	const char *dev_name;   /* The dev_name() for the consumer */
 	const char *supply;
 	struct regulator_dev *regulator;
 };
@@ -857,23 +857,33 @@ static int set_supply(struct regulator_dev *rdev,
  * set_consumer_device_supply: Bind a regulator to a symbolic supply
  * @rdev:         regulator source
  * @consumer_dev: device the supply applies to
+ * @consumer_dev_name: dev_name() string for device supply applies to
  * @supply:       symbolic name for supply
  *
  * Allows platform initialisation code to map physical regulator
  * sources to symbolic names for supplies for use by devices.  Devices
  * should use these symbolic names to request regulators, avoiding the
  * need to provide board-specific regulator names as platform data.
+ *
+ * Only one of consumer_dev and consumer_dev_name may be specified.
  */
 static int set_consumer_device_supply(struct regulator_dev *rdev,
-	struct device *consumer_dev, const char *supply)
+	struct device *consumer_dev, const char *consumer_dev_name,
+	const char *supply)
 {
 	struct regulator_map *node;
 
+	if (consumer_dev && consumer_dev_name)
+		return -EINVAL;
+
+	if (!consumer_dev_name && consumer_dev)
+		consumer_dev_name = dev_name(consumer_dev);
+
 	if (supply == NULL)
 		return -EINVAL;
 
 	list_for_each_entry(node, &regulator_map_list, list) {
-		if (consumer_dev != node->dev)
+		if (consumer_dev_name != node->dev_name)
 			continue;
 		if (strcmp(node->supply, supply) != 0)
 			continue;
@@ -891,25 +901,38 @@ static int set_consumer_device_supply(struct regulator_dev *rdev,
 		return -ENOMEM;
 
 	node->regulator = rdev;
-	node->dev = consumer_dev;
+	node->dev_name = kstrdup(consumer_dev_name, GFP_KERNEL);
 	node->supply = supply;
 
+	if (node->dev_name == NULL) {
+		kfree(node);
+		return -ENOMEM;
+	}
+
 	list_add(&node->list, &regulator_map_list);
 	return 0;
 }
 
 static void unset_consumer_device_supply(struct regulator_dev *rdev,
-	struct device *consumer_dev)
+	const char *consumer_dev_name, struct device *consumer_dev)
 {
 	struct regulator_map *node, *n;
 
+	if (consumer_dev && !consumer_dev_name)
+		consumer_dev_name = dev_name(consumer_dev);
+
 	list_for_each_entry_safe(node, n, &regulator_map_list, list) {
-		if (rdev == node->regulator &&
-			consumer_dev == node->dev) {
-			list_del(&node->list);
-			kfree(node);
-			return;
-		}
+		if (rdev != node->regulator)
+			continue;
+
+		if (consumer_dev_name && node->dev_name &&
+		    strcmp(consumer_dev_name, node->dev_name))
+			continue;
+
+		list_del(&node->list);
+		kfree(node->dev_name);
+		kfree(node);
+		return;
 	}
 }
 
@@ -920,6 +943,7 @@ static void unset_regulator_supplies(struct regulator_dev *rdev)
 	list_for_each_entry_safe(node, n, &regulator_map_list, list) {
 		if (rdev == node->regulator) {
 			list_del(&node->list);
+			kfree(node->dev_name);
 			kfree(node);
 			return;
 		}
@@ -1019,17 +1043,25 @@ struct regulator *regulator_get(struct device *dev, const char *id)
 	struct regulator_dev *rdev;
 	struct regulator_map *map;
 	struct regulator *regulator = ERR_PTR(-ENODEV);
+	const char *devname = NULL;
 
 	if (id == NULL) {
 		printk(KERN_ERR "regulator: get() with no identifier\n");
 		return regulator;
 	}
 
+	if (dev)
+		devname = dev_name(dev);
+
 	mutex_lock(&regulator_list_mutex);
 
 	list_for_each_entry(map, &regulator_map_list, list) {
-		if (dev == map->dev &&
-		    strcmp(map->supply, id) == 0) {
+		/* If the mapping has a device set up it must match */
+		if (map->dev_name &&
+		    (!devname || strcmp(map->dev_name, devname)))
+			continue;
+
+		if (strcmp(map->supply, id) == 0) {
 			rdev = map->regulator;
 			goto found;
 		}
@@ -2091,11 +2123,13 @@ struct regulator_dev *regulator_register(struct regulator_desc *regulator_desc,
 	for (i = 0; i < init_data->num_consumer_supplies; i++) {
 		ret = set_consumer_device_supply(rdev,
 			init_data->consumer_supplies[i].dev,
+			init_data->consumer_supplies[i].dev_name,
 			init_data->consumer_supplies[i].supply);
 		if (ret < 0) {
 			for (--i; i >= 0; i--)
 				unset_consumer_device_supply(rdev,
-					init_data->consumer_supplies[i].dev);
+				    init_data->consumer_supplies[i].dev_name,
+				    init_data->consumer_supplies[i].dev);
 			goto scrub;
 		}
 	}

commit be721979dd6b335e4ab6f83abb5cc11c33662aa8
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Aug 4 20:09:52 2009 +0200

    regulator: Provide mode to status conversion function
    
    This is useful for implementing get_status() in terms of get_mode().
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 98c3a74e9949..91ba9bfaa706 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1864,6 +1864,30 @@ int regulator_notifier_call_chain(struct regulator_dev *rdev,
 }
 EXPORT_SYMBOL_GPL(regulator_notifier_call_chain);
 
+/**
+ * regulator_mode_to_status - convert a regulator mode into a status
+ *
+ * @mode: Mode to convert
+ *
+ * Convert a regulator mode into a status.
+ */
+int regulator_mode_to_status(unsigned int mode)
+{
+	switch (mode) {
+	case REGULATOR_MODE_FAST:
+		return REGULATOR_STATUS_FAST;
+	case REGULATOR_MODE_NORMAL:
+		return REGULATOR_STATUS_NORMAL;
+	case REGULATOR_MODE_IDLE:
+		return REGULATOR_STATUS_IDLE;
+	case REGULATOR_STATUS_STANDBY:
+		return REGULATOR_STATUS_STANDBY;
+	default:
+		return 0;
+	}
+}
+EXPORT_SYMBOL_GPL(regulator_mode_to_status);
+
 /*
  * To avoid cluttering sysfs (and memory) with useless state, only
  * create attributes that can be meaningfully displayed.

commit 3e59091828ed5406c879b899b4257fcef7271e2c
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Apr 28 11:09:38 2009 +0100

    regulator: Fix default constraints for fixed voltage regulators
    
    Default voltage constraints were being provided for fixed voltage
    regulator where board constraints were not provided but these constraints
    used INT_MIN as the default minimum voltage which is not a valid value
    since it is less than zero. Use 1uV instead.
    
    Also set the default values we set in the constraints themselves since
    otherwise the max_uV constraint we determine will not be stored in the
    actual constraint strucutre and will therefore not be used.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 2f14c16f58c3..98c3a74e9949 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -703,10 +703,13 @@ static int set_machine_constraints(struct regulator_dev *rdev,
 		int	cmin = constraints->min_uV;
 		int	cmax = constraints->max_uV;
 
-		/* it's safe to autoconfigure fixed-voltage supplies */
+		/* it's safe to autoconfigure fixed-voltage supplies
+		   and the constraints are used by list_voltage. */
 		if (count == 1 && !cmin) {
-			cmin = INT_MIN;
+			cmin = 1;
 			cmax = INT_MAX;
+			constraints->min_uV = cmin;
+			constraints->max_uV = cmax;
 		}
 
 		/* voltage constraints are optional */

commit 53032dafc6b93ac178ca2340ff8eb4ee2b3d1a92
Author: Paul Walmsley <paul@pwsan.com>
Date:   Sat Apr 25 05:28:36 2009 -0600

    regulator core: fix double-free in regulator_register() error path
    
    During regulator registration, any error after device_register() will
    cause a double-free on the struct regulator_dev 'rdev'.  The bug is in
    drivers/regulator/core.c:regulator_register():
    
    ...
    scrub:
            device_unregister(&rdev->dev);
    clean:
            kfree(rdev);                           <---
            rdev = ERR_PTR(ret);
            goto out;
    ...
    
    device_unregister() calls regulator_dev_release() which frees rdev.  The
    subsequent kfree corrupts memory and causes some OMAP3 systems to oops on
    boot in regulator_get().
    
    Applies against 2.6.30-rc3.
    
    Signed-off-by: Paul Walmsley <paul@pwsan.com>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index cb62be63caed..2f14c16f58c3 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2080,6 +2080,10 @@ struct regulator_dev *regulator_register(struct regulator_desc *regulator_desc,
 
 scrub:
 	device_unregister(&rdev->dev);
+	/* device core frees rdev */
+	rdev = ERR_PTR(ret);
+	goto out;
+
 clean:
 	kfree(rdev);
 	rdev = ERR_PTR(ret);

commit cd78dfc6c6e321a310a73ef7b0df3d262704dd55
Author: Diego Liziero <diegoliz@gmail.com>
Date:   Tue Apr 14 03:04:47 2009 +0200

    drivers/regulator: fix when type is different from REGULATOR_VOLTAGE or REGULATOR_CURRENT
    
    When regulator_desc->type is something different from REGULATOR_VOLTAGE or REGULATOR_CURRENT
    the if should probably return ERR_PTR(-EINVAL)
    
    The semantic patch that makes this change is as follows:
    (http://www.emn.fr/x-info/coccinelle/)
    
    @@ expression E; constant C; @@
    (
    - !E == C
    + E != C
    )
    
    Signed-off-by: Diego Liziero <diegoliz@gmail.com>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 47fc6e6fe9bc..cb62be63caed 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2001,8 +2001,8 @@ struct regulator_dev *regulator_register(struct regulator_desc *regulator_desc,
 	if (regulator_desc->name == NULL || regulator_desc->ops == NULL)
 		return ERR_PTR(-EINVAL);
 
-	if (!regulator_desc->type == REGULATOR_VOLTAGE &&
-	    !regulator_desc->type == REGULATOR_CURRENT)
+	if (regulator_desc->type != REGULATOR_VOLTAGE &&
+	    regulator_desc->type != REGULATOR_CURRENT)
 		return ERR_PTR(-EINVAL);
 
 	if (!init_data)

commit 036de8efae4b81f8e1504fab654070cecce6dfa9
Author: Dan Carpenter <error27@gmail.com>
Date:   Wed Apr 8 13:52:39 2009 +0300

    unreachable code in drms_uA_update()
    
    I removed the extra semi-colon and indented the return statement.
    
    The unreachable code was found by smatch (http://repo.or.cz/w/smatch.git).
    The patch was compile tested.
    
    regards,
    dan carpenter
    
    Signed-off-by: Dan Carpenter <error27@gmail.com>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 01f7702a805d..47fc6e6fe9bc 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -540,8 +540,8 @@ static void drms_uA_update(struct regulator_dev *rdev)
 
 	err = regulator_check_drms(rdev);
 	if (err < 0 || !rdev->desc->ops->get_optimum_mode ||
-	    !rdev->desc->ops->get_voltage || !rdev->desc->ops->set_mode);
-	return;
+	    !rdev->desc->ops->get_voltage || !rdev->desc->ops->set_mode)
+		return;
 
 	/* get output voltage */
 	output_uV = rdev->desc->ops->get_voltage(rdev);

commit ca7255614e0861e36480103f4a402a115803d7b5
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Mar 16 19:36:34 2009 +0000

    regulator: Support disabling of unused regulators by machines
    
    At present it is not possible for machine constraints to disable
    regulators which have been left on when the system starts, for example
    as a result of fixed default configurations in hardware. This means that
    power may be wasted by these regulators if they are not in use.
    
    Provide intial support for this with a late_initcall which will disable
    any unused regulators if the machine has enabled this feature by calling
    regulator_has_full_constraints(). If this has not been called then print
    a warning to encourage users to fully specify their constraints so that
    we can change this to be the default behaviour in future.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 8588a2490e0a..01f7702a805d 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -28,6 +28,7 @@
 static DEFINE_MUTEX(regulator_list_mutex);
 static LIST_HEAD(regulator_list);
 static LIST_HEAD(regulator_map_list);
+static int has_full_constraints;
 
 /*
  * struct regulator_map
@@ -2142,6 +2143,23 @@ int regulator_suspend_prepare(suspend_state_t state)
 }
 EXPORT_SYMBOL_GPL(regulator_suspend_prepare);
 
+/**
+ * regulator_has_full_constraints - the system has fully specified constraints
+ *
+ * Calling this function will cause the regulator API to disable all
+ * regulators which have a zero use count and don't have an always_on
+ * constraint in a late_initcall.
+ *
+ * The intention is that this will become the default behaviour in a
+ * future kernel release so users are encouraged to use this facility
+ * now.
+ */
+void regulator_has_full_constraints(void)
+{
+	has_full_constraints = 1;
+}
+EXPORT_SYMBOL_GPL(regulator_has_full_constraints);
+
 /**
  * rdev_get_drvdata - get rdev regulator driver data
  * @rdev: regulator
@@ -2209,3 +2227,77 @@ static int __init regulator_init(void)
 
 /* init early to allow our consumers to complete system booting */
 core_initcall(regulator_init);
+
+static int __init regulator_init_complete(void)
+{
+	struct regulator_dev *rdev;
+	struct regulator_ops *ops;
+	struct regulation_constraints *c;
+	int enabled, ret;
+	const char *name;
+
+	mutex_lock(&regulator_list_mutex);
+
+	/* If we have a full configuration then disable any regulators
+	 * which are not in use or always_on.  This will become the
+	 * default behaviour in the future.
+	 */
+	list_for_each_entry(rdev, &regulator_list, list) {
+		ops = rdev->desc->ops;
+		c = rdev->constraints;
+
+		if (c->name)
+			name = c->name;
+		else if (rdev->desc->name)
+			name = rdev->desc->name;
+		else
+			name = "regulator";
+
+		if (!ops->disable || c->always_on)
+			continue;
+
+		mutex_lock(&rdev->mutex);
+
+		if (rdev->use_count)
+			goto unlock;
+
+		/* If we can't read the status assume it's on. */
+		if (ops->is_enabled)
+			enabled = ops->is_enabled(rdev);
+		else
+			enabled = 1;
+
+		if (!enabled)
+			goto unlock;
+
+		if (has_full_constraints) {
+			/* We log since this may kill the system if it
+			 * goes wrong. */
+			printk(KERN_INFO "%s: disabling %s\n",
+			       __func__, name);
+			ret = ops->disable(rdev);
+			if (ret != 0) {
+				printk(KERN_ERR
+				       "%s: couldn't disable %s: %d\n",
+				       __func__, name, ret);
+			}
+		} else {
+			/* The intention is that in future we will
+			 * assume that full constraints are provided
+			 * so warn even if we aren't going to do
+			 * anything here.
+			 */
+			printk(KERN_WARNING
+			       "%s: incomplete constraints, leaving %s on\n",
+			       __func__, name);
+		}
+
+unlock:
+		mutex_unlock(&rdev->mutex);
+	}
+
+	mutex_unlock(&regulator_list_mutex);
+
+	return 0;
+}
+late_initcall(regulator_init_complete);

commit 50f075963f127d713ff0c30359baefc0f89d9ae2
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Mar 16 19:36:33 2009 +0000

    regulator: Don't increment use_count for boot_on regulators
    
    Don't set use_count for regulators that are enabled at boot since this
    stops the supply being disabled by well-behaved consumers which do
    balanced enables and disabled. Any consumers which don't do disables
    which are not matched by enables are unable to share regulators - shared
    regulators are the common case so the API should facilitate them.
    
    Consumers that want to disable regulators that are enabled when they
    start have two options:
    
     - Do a regulator_enable() prior to the disable to bring the use count
       in sync with the hardware state; this will ensure that if the
       regulator was enabled by another driver then this consumer will play
       nicely with it.
     - Use regulator_force_disable(); this explicitly bypasses any checks
       done by the core and documents the inability of the driver to share
       the supply.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 944887578d66..8588a2490e0a 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -814,7 +814,6 @@ static int set_machine_constraints(struct regulator_dev *rdev,
 			rdev->constraints = NULL;
 			goto out;
 		}
-		rdev->use_count = 1;
 	}
 
 	print_constraints(rdev);

commit cd94b5053081963614f6ad77b9b66a7968056c84
Author: David Brownell <dbrownell@users.sourceforge.net>
Date:   Wed Mar 11 16:43:34 2009 -0800

    regulator: refcount fixes
    
    Fix some refcounting issues in the regulator framework, supporting
    regulator_disable() for regulators that were enabled at boot time
    via machine constraints:
    
     - Update those regulators' usecounts after enabling, so they
       can cleanly be disabled at that level.
    
     - Remove the problematic per-consumer usecount, so there's
       only one level of enable/disable.
    
    Buggy consumers could notice different bug symptoms.  The main
    example would be refcounting bugs; also, any (out-of-tree) users
    of the experimental regulator_set_optimum_mode() stuff which
    don't call it when they're done using a regulator.
    
    This is a net minor codeshrink.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 019a8a42ac18..944887578d66 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -52,7 +52,6 @@ struct regulator {
 	int uA_load;
 	int min_uV;
 	int max_uV;
-	int enabled; /* count of client enables */
 	char *supply_name;
 	struct device_attribute dev_attr;
 	struct regulator_dev *rdev;
@@ -815,6 +814,7 @@ static int set_machine_constraints(struct regulator_dev *rdev,
 			rdev->constraints = NULL;
 			goto out;
 		}
+		rdev->use_count = 1;
 	}
 
 	print_constraints(rdev);
@@ -1068,10 +1068,6 @@ void regulator_put(struct regulator *regulator)
 	mutex_lock(&regulator_list_mutex);
 	rdev = regulator->rdev;
 
-	if (WARN(regulator->enabled, "Releasing supply %s while enabled\n",
-			       regulator->supply_name))
-		_regulator_disable(rdev);
-
 	/* remove any sysfs entries */
 	if (regulator->dev) {
 		sysfs_remove_link(&rdev->dev.kobj, regulator->supply_name);
@@ -1146,12 +1142,7 @@ int regulator_enable(struct regulator *regulator)
 	int ret = 0;
 
 	mutex_lock(&rdev->mutex);
-	if (regulator->enabled == 0)
-		ret = _regulator_enable(rdev);
-	else if (regulator->enabled < 0)
-		ret = -EIO;
-	if (ret == 0)
-		regulator->enabled++;
+	ret = _regulator_enable(rdev);
 	mutex_unlock(&rdev->mutex);
 	return ret;
 }
@@ -1162,6 +1153,11 @@ static int _regulator_disable(struct regulator_dev *rdev)
 {
 	int ret = 0;
 
+	if (WARN(rdev->use_count <= 0,
+			"unbalanced disables for %s\n",
+			rdev->desc->name))
+		return -EIO;
+
 	/* are we the last user and permitted to disable ? */
 	if (rdev->use_count == 1 && !rdev->constraints->always_on) {
 
@@ -1210,16 +1206,7 @@ int regulator_disable(struct regulator *regulator)
 	int ret = 0;
 
 	mutex_lock(&rdev->mutex);
-	if (regulator->enabled == 1) {
-		ret = _regulator_disable(rdev);
-		if (ret == 0)
-			regulator->uA_load = 0;
-	} else if (WARN(regulator->enabled <= 0,
-			"unbalanced disables for supply %s\n",
-			regulator->supply_name))
-		ret = -EIO;
-	if (ret == 0)
-		regulator->enabled--;
+	ret = _regulator_disable(rdev);
 	mutex_unlock(&rdev->mutex);
 	return ret;
 }
@@ -1266,7 +1253,6 @@ int regulator_force_disable(struct regulator *regulator)
 	int ret;
 
 	mutex_lock(&regulator->rdev->mutex);
-	regulator->enabled = 0;
 	regulator->uA_load = 0;
 	ret = _regulator_force_disable(regulator->rdev);
 	mutex_unlock(&regulator->rdev->mutex);

commit 1dc60343f874ce4bfbbc2c3d2f7865fc897df479
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Mar 11 23:35:52 2009 +0000

    regulator: Don't warn if we failed to get a regulator
    
    The consumer can print a message if required, some consumers may have
    optional regulators and wish to downgrade the logging for them or ignore
    their absence.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 08441e24946e..019a8a42ac18 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1031,8 +1031,6 @@ struct regulator *regulator_get(struct device *dev, const char *id)
 			goto found;
 		}
 	}
-	printk(KERN_ERR "regulator: Unable to get requested regulator: %s\n",
-	       id);
 	mutex_unlock(&regulator_list_mutex);
 	return regulator;
 

commit cacf90f24e80cec9334f98e0377149f943fe9f16
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Mar 2 16:32:46 2009 +0000

    regulator: Allow boot_on regulators to be disabled by clients
    
    Rather than incrementing the reference count for boot_on regulators
    (which prevents them being disabled later on) simply force the
    regulator to be enabled when applying the constraints. Previously
    boot_on was essentially equivalent to always_on.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 2ff76349f392..08441e24946e 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -776,10 +776,6 @@ static int set_machine_constraints(struct regulator_dev *rdev,
 			}
 	}
 
-	/* are we enabled at boot time by firmware / bootloader */
-	if (rdev->constraints->boot_on)
-		rdev->use_count = 1;
-
 	/* do we need to setup our suspend state */
 	if (constraints->initial_state) {
 		ret = suspend_prepare(rdev, constraints->initial_state);
@@ -808,11 +804,10 @@ static int set_machine_constraints(struct regulator_dev *rdev,
 		}
 	}
 
-	/* if always_on is set then turn the regulator on if it's not
-	 * already on. */
-	if (constraints->always_on && ops->enable &&
-	    ((ops->is_enabled && !ops->is_enabled(rdev)) ||
-	     (!ops->is_enabled && !constraints->boot_on))) {
+	/* If the constraints say the regulator should be on at this point
+	 * and we have control then make sure it is enabled.
+	 */
+	if ((constraints->always_on || constraints->boot_on) && ops->enable) {
 		ret = ops->enable(rdev);
 		if (ret < 0) {
 			printk(KERN_ERR "%s: failed to enable %s\n",

commit 3e2b9abda554e9f6105996dca77cca9ef98de17a
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Mar 10 16:28:36 2009 +0000

    regulator: Don't warn on omitted voltage constraints
    
    Specifying voltage constraints is optional (and only needed if the
    consumer is allowed to change the voltage) so don't complain unless
    a voltage has been specified.
    
    Also avoid surprises with a dangling else while we're here.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index da357a07c98e..2ff76349f392 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -709,8 +709,12 @@ static int set_machine_constraints(struct regulator_dev *rdev,
 			cmax = INT_MAX;
 		}
 
+		/* voltage constraints are optional */
+		if ((cmin == 0) && (cmax == 0))
+			goto out;
+
 		/* else require explicit machine-level constraints */
-		else if (cmin <= 0 || cmax <= 0 || cmax < cmin) {
+		if (cmin <= 0 || cmax <= 0 || cmax < cmin) {
 			pr_err("%s: %s '%s' voltage constraints\n",
 				       __func__, "invalid", name);
 			ret = -EINVAL;

commit 4367cfdc7c657ad8a797f51b9ffd3c64b31910e7
Author: David Brownell <dbrownell@users.sourceforge.net>
Date:   Thu Feb 26 11:48:36 2009 -0800

    regulator: enumerate voltages (v2)
    
    Add a basic mechanism for regulators to report the discrete
    voltages they support:  list_voltage() enumerates them using
    selectors numbered from 0 to an upper bound.
    
    Use those methods to force machine-level constraints into bounds.
    (Example:  regulator supports 1.8V, 2.4V, 2.6V, 3.3V, and board
    constraints for that rail are 2.0V to 3.6V ... so the range of
    voltages is then 2.4V to 3.3V on this board.)
    
    Export those voltages to the regulator consumer interface, so for
    example regulator hooked up to an MMC/SD/SDIO slot can report the
    actual voltage options available to cards connected there.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 75abcd85e51b..da357a07c98e 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -692,6 +692,69 @@ static int set_machine_constraints(struct regulator_dev *rdev,
 	else
 		name = "regulator";
 
+	/* constrain machine-level voltage specs to fit
+	 * the actual range supported by this regulator.
+	 */
+	if (ops->list_voltage && rdev->desc->n_voltages) {
+		int	count = rdev->desc->n_voltages;
+		int	i;
+		int	min_uV = INT_MAX;
+		int	max_uV = INT_MIN;
+		int	cmin = constraints->min_uV;
+		int	cmax = constraints->max_uV;
+
+		/* it's safe to autoconfigure fixed-voltage supplies */
+		if (count == 1 && !cmin) {
+			cmin = INT_MIN;
+			cmax = INT_MAX;
+		}
+
+		/* else require explicit machine-level constraints */
+		else if (cmin <= 0 || cmax <= 0 || cmax < cmin) {
+			pr_err("%s: %s '%s' voltage constraints\n",
+				       __func__, "invalid", name);
+			ret = -EINVAL;
+			goto out;
+		}
+
+		/* initial: [cmin..cmax] valid, [min_uV..max_uV] not */
+		for (i = 0; i < count; i++) {
+			int	value;
+
+			value = ops->list_voltage(rdev, i);
+			if (value <= 0)
+				continue;
+
+			/* maybe adjust [min_uV..max_uV] */
+			if (value >= cmin && value < min_uV)
+				min_uV = value;
+			if (value <= cmax && value > max_uV)
+				max_uV = value;
+		}
+
+		/* final: [min_uV..max_uV] valid iff constraints valid */
+		if (max_uV < min_uV) {
+			pr_err("%s: %s '%s' voltage constraints\n",
+				       __func__, "unsupportable", name);
+			ret = -EINVAL;
+			goto out;
+		}
+
+		/* use regulator's subset of machine constraints */
+		if (constraints->min_uV < min_uV) {
+			pr_debug("%s: override '%s' %s, %d -> %d\n",
+				       __func__, name, "min_uV",
+					constraints->min_uV, min_uV);
+			constraints->min_uV = min_uV;
+		}
+		if (constraints->max_uV > max_uV) {
+			pr_debug("%s: override '%s' %s, %d -> %d\n",
+				       __func__, name, "max_uV",
+					constraints->max_uV, max_uV);
+			constraints->max_uV = max_uV;
+		}
+	}
+
 	rdev->constraints = constraints;
 
 	/* do we need to apply the constraint voltage */
@@ -1250,6 +1313,56 @@ int regulator_is_enabled(struct regulator *regulator)
 }
 EXPORT_SYMBOL_GPL(regulator_is_enabled);
 
+/**
+ * regulator_count_voltages - count regulator_list_voltage() selectors
+ * @regulator: regulator source
+ *
+ * Returns number of selectors, or negative errno.  Selectors are
+ * numbered starting at zero, and typically correspond to bitfields
+ * in hardware registers.
+ */
+int regulator_count_voltages(struct regulator *regulator)
+{
+	struct regulator_dev	*rdev = regulator->rdev;
+
+	return rdev->desc->n_voltages ? : -EINVAL;
+}
+EXPORT_SYMBOL_GPL(regulator_count_voltages);
+
+/**
+ * regulator_list_voltage - enumerate supported voltages
+ * @regulator: regulator source
+ * @selector: identify voltage to list
+ * Context: can sleep
+ *
+ * Returns a voltage that can be passed to @regulator_set_voltage(),
+ * zero if this selector code can't be used on this sytem, or a
+ * negative errno.
+ */
+int regulator_list_voltage(struct regulator *regulator, unsigned selector)
+{
+	struct regulator_dev	*rdev = regulator->rdev;
+	struct regulator_ops	*ops = rdev->desc->ops;
+	int			ret;
+
+	if (!ops->list_voltage || selector >= rdev->desc->n_voltages)
+		return -EINVAL;
+
+	mutex_lock(&rdev->mutex);
+	ret = ops->list_voltage(rdev, selector);
+	mutex_unlock(&rdev->mutex);
+
+	if (ret > 0) {
+		if (ret < rdev->constraints->min_uV)
+			ret = 0;
+		else if (ret > rdev->constraints->max_uV)
+			ret = 0;
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(regulator_list_voltage);
+
 /**
  * regulator_set_voltage - set regulator output voltage
  * @regulator: regulator source

commit a308466c24b4f42bab6945026e938874d22cde50
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Thu Feb 26 19:24:19 2009 +0000

    regulator: Allow regulators to set the initial operating mode
    
    This is useful when wishing to run in a fixed operating mode that isn't
    the default.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index d55a25a6fab2..75abcd85e51b 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -724,6 +724,23 @@ static int set_machine_constraints(struct regulator_dev *rdev,
 		}
 	}
 
+	if (constraints->initial_mode) {
+		if (!ops->set_mode) {
+			printk(KERN_ERR "%s: no set_mode operation for %s\n",
+			       __func__, name);
+			ret = -EINVAL;
+			goto out;
+		}
+
+		ret = ops->set_mode(rdev, constraints->initial_mode);
+		if (ret < 0) {
+			printk(KERN_ERR
+			       "%s: failed to set initial mode for %s: %d\n",
+			       __func__, name, ret);
+			goto out;
+		}
+	}
+
 	/* if always_on is set then turn the regulator on if it's not
 	 * already on. */
 	if (constraints->always_on && ops->enable &&

commit fe203ddfa5451a13589b1c7da9edab80b7fc06d1
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Feb 11 15:32:06 2009 +0000

    regulator: Suggest use of datasheet supply or pin names for consumers
    
    Update the documentation to suggest the use of datasheet names for
    the supplies requested by regulator consumers. Doing this makes it
    easier to tie the design for a given platform up with the requirements
    of the driver for a consumer.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index b85e4a9dafcf..d55a25a6fab2 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -925,9 +925,12 @@ static struct regulator *create_regulator(struct regulator_dev *rdev,
  * @id: Supply name or regulator ID.
  *
  * Returns a struct regulator corresponding to the regulator producer,
- * or IS_ERR() condition containing errno.  Use of supply names
- * configured via regulator_set_device_supply() is strongly
- * encouraged.
+ * or IS_ERR() condition containing errno.
+ *
+ * Use of supply names configured via regulator_set_device_supply() is
+ * strongly encouraged.  It is recommended that the supply name used
+ * should match the name used for the supply and/or the relevant
+ * device pins in the datasheet.
  */
 struct regulator *regulator_get(struct device *dev, const char *id)
 {

commit 0f1d747bfa89de4ca52dc1dffdcce35a2b8a1532
Author: Mike Rapoport <mike@compulab.co.il>
Date:   Thu Jan 22 16:00:29 2009 +0200

    regulator: add unset_regulator_supplies to fix regulator_unregister
    
    Currently regulator_unregister does not clear regulator <--> consumer
    mapping.
    This patch introduces unset_regulator_supplies that clear the map.
    
    Signed-off-by: Mike Rapoport <mike@compulab.co.il>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 0ed13c2a8c3c..b85e4a9dafcf 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -831,6 +831,19 @@ static void unset_consumer_device_supply(struct regulator_dev *rdev,
 	}
 }
 
+static void unset_regulator_supplies(struct regulator_dev *rdev)
+{
+	struct regulator_map *node, *n;
+
+	list_for_each_entry_safe(node, n, &regulator_map_list, list) {
+		if (rdev == node->regulator) {
+			list_del(&node->list);
+			kfree(node);
+			return;
+		}
+	}
+}
+
 #define REG_STR_SIZE	32
 
 static struct regulator *create_regulator(struct regulator_dev *rdev,
@@ -1970,6 +1983,7 @@ void regulator_unregister(struct regulator_dev *rdev)
 		return;
 
 	mutex_lock(&regulator_list_mutex);
+	unset_regulator_supplies(rdev);
 	list_del(&rdev->list);
 	if (rdev->supply)
 		sysfs_remove_link(&rdev->dev.kobj, "supply");

commit 1fa9ad52b07811ebf258f3f6907de8dbf020ec2d
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Jan 21 14:08:40 2009 +0000

    regulator: Hoist struct regulator_dev out of core to fix notifiers
    
    Commit 872ed3fe176833f7d43748eb88010da4bbd2f983 caused regulator drivers
    to take the struct regulator_dev lock themselves which requires that the
    struct be visible to them. Band aid this by making the struct visible.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index f17362ac9c61..0ed13c2a8c3c 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -29,33 +29,6 @@ static DEFINE_MUTEX(regulator_list_mutex);
 static LIST_HEAD(regulator_list);
 static LIST_HEAD(regulator_map_list);
 
-/*
- * struct regulator_dev
- *
- * Voltage / Current regulator class device. One for each regulator.
- */
-struct regulator_dev {
-	struct regulator_desc *desc;
-	int use_count;
-
-	/* lists we belong to */
-	struct list_head list; /* list of all regulators */
-	struct list_head slist; /* list of supplied regulators */
-
-	/* lists we own */
-	struct list_head consumer_list; /* consumers we supply */
-	struct list_head supply_list; /* regulators we supply */
-
-	struct blocking_notifier_head notifier;
-	struct mutex mutex; /* consumer lock */
-	struct module *owner;
-	struct device dev;
-	struct regulation_constraints *constraints;
-	struct regulator_dev *supply;	/* for tree */
-
-	void *reg_data;		/* regulator_dev data */
-};
-
 /*
  * struct regulator_map
  *

commit 0527100fd11d9710c7e153d791da78824b7b46fa
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Jan 19 13:37:02 2009 +0000

    regulator: Pass regulator init data as explict argument when registering
    
    Rather than having the regulator init data read from the platform_data
    member of the struct device that is registered for the regulator make
    the init data an explict argument passed in when registering. This
    allows drivers to use the platform data for their own purposes if they
    wish.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 96c877dd9daf..f17362ac9c61 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1879,17 +1879,18 @@ static int add_regulator_attributes(struct regulator_dev *rdev)
  * regulator_register - register regulator
  * @regulator_desc: regulator to register
  * @dev: struct device for the regulator
+ * @init_data: platform provided init data, passed through by driver
  * @driver_data: private regulator data
  *
  * Called by regulator drivers to register a regulator.
  * Returns 0 on success.
  */
 struct regulator_dev *regulator_register(struct regulator_desc *regulator_desc,
-	struct device *dev, void *driver_data)
+	struct device *dev, struct regulator_init_data *init_data,
+	void *driver_data)
 {
 	static atomic_t regulator_no = ATOMIC_INIT(0);
 	struct regulator_dev *rdev;
-	struct regulator_init_data *init_data = dev->platform_data;
 	int ret, i;
 
 	if (regulator_desc == NULL)

commit b136fb4463d13eea129bf090a8a465bba6bf0003
Author: Jonathan Cameron <jic23@cam.ac.uk>
Date:   Mon Jan 19 18:20:58 2009 +0000

    Regulator: Push lock out of _notifier_call_chain + add voltage change event.
    
    Regulator: Push lock out of _notifier_call_chain and into caller functions
    (side effect of fixing deadlock in regulator_force_disable)
    + Add a voltage changed event.
    Signed-off-by: Jonathan Cameron <jic23@cam.ac.uk>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 0ff95c3ccf5b..96c877dd9daf 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1284,6 +1284,7 @@ int regulator_set_voltage(struct regulator *regulator, int min_uV, int max_uV)
 	ret = rdev->desc->ops->set_voltage(rdev, min_uV, max_uV);
 
 out:
+	_notifier_call_chain(rdev, REGULATOR_EVENT_VOLTAGE_CHANGE, NULL);
 	mutex_unlock(&rdev->mutex);
 	return ret;
 }
@@ -1584,20 +1585,23 @@ int regulator_unregister_notifier(struct regulator *regulator,
 }
 EXPORT_SYMBOL_GPL(regulator_unregister_notifier);
 
-/* notify regulator consumers and downstream regulator consumers */
+/* notify regulator consumers and downstream regulator consumers.
+ * Note mutex must be held by caller.
+ */
 static void _notifier_call_chain(struct regulator_dev *rdev,
 				  unsigned long event, void *data)
 {
 	struct regulator_dev *_rdev;
 
 	/* call rdev chain first */
-	mutex_lock(&rdev->mutex);
 	blocking_notifier_call_chain(&rdev->notifier, event, NULL);
-	mutex_unlock(&rdev->mutex);
 
 	/* now notify regulator we supply */
-	list_for_each_entry(_rdev, &rdev->supply_list, slist)
-		_notifier_call_chain(_rdev, event, data);
+	list_for_each_entry(_rdev, &rdev->supply_list, slist) {
+	  mutex_lock(&_rdev->mutex);
+	  _notifier_call_chain(_rdev, event, data);
+	  mutex_unlock(&_rdev->mutex);
+	}
 }
 
 /**
@@ -1744,6 +1748,7 @@ EXPORT_SYMBOL_GPL(regulator_bulk_free);
  *
  * Called by regulator drivers to notify clients a regulator event has
  * occurred. We also notify regulator clients downstream.
+ * Note lock must be held by caller.
  */
 int regulator_notifier_call_chain(struct regulator_dev *rdev,
 				  unsigned long event, void *data)

commit 853116a10544206b6b2cf42ebc9d78fba2668888
Author: David Brownell <dbrownell@users.sourceforge.net>
Date:   Wed Jan 14 23:03:17 2009 -0800

    regulator: add get_status()
    
    Based on previous LKML discussions:
    
     * Update docs for regulator sysfs class attributes to highlight
       the fact that all current attributes are intended to be control
       inputs, including notably "state" and "opmode" which previously
       implied otherwise.
    
     * Define a new regulator driver get_status() method, which is the
       first method reporting regulator outputs instead of inputs.
       It can report on/off and error status; or instead of simply
       "on", report the actual operating mode.
    
    For the moment, this is a sysfs-only interface, not accessible to
    regulator clients.  Such clients can use the current notification
    interfaces to detect errors, if the regulator reports them.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index f511a406fcaa..0ff95c3ccf5b 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -312,6 +312,47 @@ static ssize_t regulator_state_show(struct device *dev,
 }
 static DEVICE_ATTR(state, 0444, regulator_state_show, NULL);
 
+static ssize_t regulator_status_show(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	struct regulator_dev *rdev = dev_get_drvdata(dev);
+	int status;
+	char *label;
+
+	status = rdev->desc->ops->get_status(rdev);
+	if (status < 0)
+		return status;
+
+	switch (status) {
+	case REGULATOR_STATUS_OFF:
+		label = "off";
+		break;
+	case REGULATOR_STATUS_ON:
+		label = "on";
+		break;
+	case REGULATOR_STATUS_ERROR:
+		label = "error";
+		break;
+	case REGULATOR_STATUS_FAST:
+		label = "fast";
+		break;
+	case REGULATOR_STATUS_NORMAL:
+		label = "normal";
+		break;
+	case REGULATOR_STATUS_IDLE:
+		label = "idle";
+		break;
+	case REGULATOR_STATUS_STANDBY:
+		label = "standby";
+		break;
+	default:
+		return -ERANGE;
+	}
+
+	return sprintf(buf, "%s\n", label);
+}
+static DEVICE_ATTR(status, 0444, regulator_status_show, NULL);
+
 static ssize_t regulator_min_uA_show(struct device *dev,
 				    struct device_attribute *attr, char *buf)
 {
@@ -1744,6 +1785,11 @@ static int add_regulator_attributes(struct regulator_dev *rdev)
 		if (status < 0)
 			return status;
 	}
+	if (ops->get_status) {
+		status = device_create_file(dev, &dev_attr_status);
+		if (status < 0)
+			return status;
+	}
 
 	/* some attributes are type-specific */
 	if (rdev->desc->type == REGULATOR_CURRENT) {

commit 6001e13c5f708eb68c744a69df3c2c281156030d
Author: David Brownell <dbrownell@users.sourceforge.net>
Date:   Wed Dec 31 12:54:19 2008 +0000

    regulator: catch some registration errors
    
    Prevent registration of duplicate "struct regulator" names.
    They'd be unavailable, and clearly indicate something wrong.
    
    [Edited to remove check for NULL consumer device until we have a
    solution for things like cpufreq -- broonie]
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 7341c97cd916..f511a406fcaa 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -776,6 +776,20 @@ static int set_consumer_device_supply(struct regulator_dev *rdev,
 	if (supply == NULL)
 		return -EINVAL;
 
+	list_for_each_entry(node, &regulator_map_list, list) {
+		if (consumer_dev != node->dev)
+			continue;
+		if (strcmp(node->supply, supply) != 0)
+			continue;
+
+		dev_dbg(consumer_dev, "%s/%s is '%s' supply; fail %s/%s\n",
+				dev_name(&node->regulator->dev),
+				node->regulator->desc->name,
+				supply,
+				dev_name(&rdev->dev), rdev->desc->name);
+		return -EBUSY;
+	}
+
 	node = kmalloc(sizeof(struct regulator_map), GFP_KERNEL);
 	if (node == NULL)
 		return -ENOMEM;

commit cf7bbcdf4d267eff580cb7ce6cf4fe16a940a005
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Dec 31 12:52:43 2008 +0000

    regulator: Fix some kerneldoc rendering issues
    
    There are some minor textual changes in here as well, mostly to enable()
    and disable() but the primary goal of these changes is to fix
    misrenderings of the kerneldoc documentation for the regulator API.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index fda44009024d..7341c97cd916 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1012,10 +1012,12 @@ static int _regulator_enable(struct regulator_dev *rdev)
  * regulator_enable - enable regulator output
  * @regulator: regulator source
  *
- * Enable the regulator output at the predefined voltage or current value.
+ * Request that the regulator be enabled with the regulator output at
+ * the predefined voltage or current value.  Calls to regulator_enable()
+ * must be balanced with calls to regulator_disable().
+ *
  * NOTE: the output value can be set by other drivers, boot loader or may be
- * hardwired in the regulator.  Calls to regulator_enable() must be balanced
- * with calls to regulator_disable().
+ * hardwired in the regulator.
  */
 int regulator_enable(struct regulator *regulator)
 {
@@ -1073,11 +1075,13 @@ static int _regulator_disable(struct regulator_dev *rdev)
  * regulator_disable - disable regulator output
  * @regulator: regulator source
  *
- * Disable the regulator output voltage or current.
+ * Disable the regulator output voltage or current.  Calls to
+ * regulator_enable() must be balanced with calls to
+ * regulator_disable().
  *
  * NOTE: this will only disable the regulator output if no other consumer
- * devices have it enabled.  Calls to regulator_enable() must be balanced with
- * calls to regulator_disable().
+ * devices have it enabled, the regulator device supports disabling and
+ * machine constraints permit this operation.
  */
 int regulator_disable(struct regulator *regulator)
 {
@@ -1936,7 +1940,7 @@ void regulator_unregister(struct regulator_dev *rdev)
 EXPORT_SYMBOL_GPL(regulator_unregister);
 
 /**
- * regulator_suspend_prepare: prepare regulators for system wide suspend
+ * regulator_suspend_prepare - prepare regulators for system wide suspend
  * @state: system suspend state
  *
  * Configure each regulator with it's suspend operating parameters for state.

commit c8e7e4640facbe99d10a6e262523b25be129b9b9
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Dec 31 12:52:42 2008 +0000

    regulator: Add missing kerneldoc
    
    This is only the documentation that the kerneldoc system warns about.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index ea12c68c327f..fda44009024d 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -656,6 +656,7 @@ static void print_constraints(struct regulator_dev *rdev)
 /**
  * set_machine_constraints - sets regulator constraints
  * @rdev: regulator source
+ * @constraints: constraints to apply
  *
  * Allows platform initialisation code to define and constrain
  * regulator circuits e.g. valid voltage/current ranges, etc.  NOTE:

commit 69279fb9a95051971ac03e558c4d46e7ba84ab3a
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Dec 31 12:52:41 2008 +0000

    regulator: Clean up kerneldoc warnings
    
    Remove kerneldoc warnings that don't relate to missing documentation,
    mostly by renaming parameters in the documentation to match their
    actual names.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 7ba9491a05cb..ea12c68c327f 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -655,7 +655,7 @@ static void print_constraints(struct regulator_dev *rdev)
 
 /**
  * set_machine_constraints - sets regulator constraints
- * @regulator: regulator source
+ * @rdev: regulator source
  *
  * Allows platform initialisation code to define and constrain
  * regulator circuits e.g. valid voltage/current ranges, etc.  NOTE:
@@ -730,8 +730,8 @@ static int set_machine_constraints(struct regulator_dev *rdev,
 
 /**
  * set_supply - set regulator supply regulator
- * @regulator: regulator name
- * @supply: supply regulator name
+ * @rdev: regulator name
+ * @supply_rdev: supply regulator name
  *
  * Called by platform initialisation code to set the supply regulator for this
  * regulator. This ensures that a regulators supply will also be enabled by the
@@ -758,9 +758,9 @@ static int set_supply(struct regulator_dev *rdev,
 
 /**
  * set_consumer_device_supply: Bind a regulator to a symbolic supply
- * @regulator: regulator source
- * @dev:       device the supply applies to
- * @supply:    symbolic name for supply
+ * @rdev:         regulator source
+ * @consumer_dev: device the supply applies to
+ * @supply:       symbolic name for supply
  *
  * Allows platform initialisation code to map physical regulator
  * sources to symbolic names for supplies for use by devices.  Devices
@@ -1013,9 +1013,8 @@ static int _regulator_enable(struct regulator_dev *rdev)
  *
  * Enable the regulator output at the predefined voltage or current value.
  * NOTE: the output value can be set by other drivers, boot loader or may be
- * hardwired in the regulator.
- * NOTE: calls to regulator_enable() must be balanced with calls to
- * regulator_disable().
+ * hardwired in the regulator.  Calls to regulator_enable() must be balanced
+ * with calls to regulator_disable().
  */
 int regulator_enable(struct regulator *regulator)
 {
@@ -1074,10 +1073,10 @@ static int _regulator_disable(struct regulator_dev *rdev)
  * @regulator: regulator source
  *
  * Disable the regulator output voltage or current.
+ *
  * NOTE: this will only disable the regulator output if no other consumer
- * devices have it enabled.
- * NOTE: calls to regulator_enable() must be balanced with calls to
- * regulator_disable().
+ * devices have it enabled.  Calls to regulator_enable() must be balanced with
+ * calls to regulator_disable().
  */
 int regulator_disable(struct regulator *regulator)
 {
@@ -1200,7 +1199,7 @@ EXPORT_SYMBOL_GPL(regulator_is_enabled);
  *
  * NOTE: If the regulator is shared between several devices then the lowest
  * request voltage that meets the system constraints will be used.
- * NOTE: Regulator system constraints must be set for this regulator before
+ * Regulator system constraints must be set for this regulator before
  * calling this function otherwise this call will fail.
  */
 int regulator_set_voltage(struct regulator *regulator, int min_uV, int max_uV)
@@ -1498,7 +1497,7 @@ EXPORT_SYMBOL_GPL(regulator_set_optimum_mode);
 /**
  * regulator_register_notifier - register regulator event notifier
  * @regulator: regulator source
- * @notifier_block: notifier block
+ * @nb: notifier block
  *
  * Register notifier block to receive regulator events.
  */
@@ -1513,7 +1512,7 @@ EXPORT_SYMBOL_GPL(regulator_register_notifier);
 /**
  * regulator_unregister_notifier - unregister regulator event notifier
  * @regulator: regulator source
- * @notifier_block: notifier block
+ * @nb: notifier block
  *
  * Unregister regulator event notifier block.
  */
@@ -1679,9 +1678,9 @@ EXPORT_SYMBOL_GPL(regulator_bulk_free);
 
 /**
  * regulator_notifier_call_chain - call regulator event notifier
- * @regulator: regulator source
+ * @rdev: regulator source
  * @event: notifier block
- * @data:
+ * @data: callback-specific data.
  *
  * Called by regulator drivers to notify clients a regulator event has
  * occurred. We also notify regulator clients downstream.
@@ -1808,8 +1807,9 @@ static int add_regulator_attributes(struct regulator_dev *rdev)
 
 /**
  * regulator_register - register regulator
- * @regulator: regulator source
- * @reg_data: private regulator data
+ * @regulator_desc: regulator to register
+ * @dev: struct device for the regulator
+ * @driver_data: private regulator data
  *
  * Called by regulator drivers to register a regulator.
  * Returns 0 on success.
@@ -1916,7 +1916,7 @@ EXPORT_SYMBOL_GPL(regulator_register);
 
 /**
  * regulator_unregister - unregister regulator
- * @regulator: regulator source
+ * @rdev: regulator to unregister
  *
  * Called by regulator drivers to unregister a regulator.
  */
@@ -1971,7 +1971,7 @@ EXPORT_SYMBOL_GPL(regulator_suspend_prepare);
 
 /**
  * rdev_get_drvdata - get rdev regulator driver data
- * @regulator: regulator
+ * @rdev: regulator
  *
  * Get rdev regulator driver private data. This call can be used in the
  * regulator driver context.
@@ -2008,7 +2008,7 @@ EXPORT_SYMBOL_GPL(regulator_set_drvdata);
 
 /**
  * regulator_get_id - get regulator ID
- * @regulator: regulator
+ * @rdev: regulator
  */
 int rdev_get_id(struct regulator_dev *rdev)
 {

commit 8dc5390d4f3fd8acc73773a56fea13544e7924dc
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed Dec 31 12:52:40 2008 +0000

    regulator: Remove extraneous kerneldoc annotations
    
    Some of the internal structures have no kerneldoc but the ** at the start
    of the comment marking them for documentation.  Remove the annotation
    until some is added.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 895f73887cf0..7ba9491a05cb 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -29,7 +29,7 @@ static DEFINE_MUTEX(regulator_list_mutex);
 static LIST_HEAD(regulator_list);
 static LIST_HEAD(regulator_map_list);
 
-/**
+/*
  * struct regulator_dev
  *
  * Voltage / Current regulator class device. One for each regulator.
@@ -56,7 +56,7 @@ struct regulator_dev {
 	void *reg_data;		/* regulator_dev data */
 };
 
-/**
+/*
  * struct regulator_map
  *
  * Used to provide symbolic supply names to devices.

commit 74f544c1fc0339acf6f66ff438b8543b1f9faf10
Author: Mike Rapoport <mike@compulab.co.il>
Date:   Tue Nov 25 14:53:53 2008 +0200

    regulator: move set_machine_constraints after regulator device initialization
    
    Calling set_machine_constraints before regulator device initialization
    causes crash when constraints have apply_uV set.
    
    Signed-off-by: Mike Rapoport <mike@compulab.co.il>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 9a5ff97d158d..895f73887cf0 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1858,11 +1858,6 @@ struct regulator_dev *regulator_register(struct regulator_desc *regulator_desc,
 			goto clean;
 	}
 
-	/* set regulator constraints */
-	ret = set_machine_constraints(rdev, &init_data->constraints);
-	if (ret < 0)
-		goto clean;
-
 	/* register with sysfs */
 	rdev->dev.class = &regulator_class;
 	rdev->dev.parent = dev;
@@ -1874,6 +1869,11 @@ struct regulator_dev *regulator_register(struct regulator_desc *regulator_desc,
 
 	dev_set_drvdata(&rdev->dev, rdev);
 
+	/* set regulator constraints */
+	ret = set_machine_constraints(rdev, &init_data->constraints);
+	if (ret < 0)
+		goto scrub;
+
 	/* add attributes supported by this regulator */
 	ret = add_regulator_attributes(rdev);
 	if (ret < 0)

commit 7ad68e2f970fd84d15ad67ce3216aed05f944a9c
Author: David Brownell <dbrownell@users.sourceforge.net>
Date:   Tue Nov 11 17:39:02 2008 -0800

    regulator: sysfs attribute reduction (v2)
    
    Clean up the sysfs interface to regulators by only exposing the
    attributes that can be properly displayed.  For example: when a
    particular regulator method is needed to display the value, only
    create that attribute when that method exists.
    
    This cleaned-up interface is much more comprehensible.  Most
    regulators only support a subset of the possible methods, so
    often more than half the attributes would be meaningless.  Many
    "not defined" values are no longer necessary.  (But handling
    of out-of-range values still looks a bit iffy.)
    
    Documentation is updated to reflect that few of the attributes
    are *always* present, and to briefly explain why a regulator may
    not have a given attribute.
    
    This adds object code, about a dozen bytes more than was removed
    by the preceding patch, but saves a bunch of per-regulator data
    associated with the now-removed attributes.  So there's a net
    reduction in memory footprint.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 5109f7d4809a..9a5ff97d158d 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -242,6 +242,7 @@ static ssize_t regulator_uV_show(struct device *dev,
 
 	return ret;
 }
+static DEVICE_ATTR(microvolts, 0444, regulator_uV_show, NULL);
 
 static ssize_t regulator_uA_show(struct device *dev,
 				struct device_attribute *attr, char *buf)
@@ -250,6 +251,7 @@ static ssize_t regulator_uA_show(struct device *dev,
 
 	return sprintf(buf, "%d\n", _regulator_get_current_limit(rdev));
 }
+static DEVICE_ATTR(microamps, 0444, regulator_uA_show, NULL);
 
 static ssize_t regulator_name_show(struct device *dev,
 			     struct device_attribute *attr, char *buf)
@@ -289,6 +291,7 @@ static ssize_t regulator_opmode_show(struct device *dev,
 
 	return regulator_print_opmode(buf, _regulator_get_mode(rdev));
 }
+static DEVICE_ATTR(opmode, 0444, regulator_opmode_show, NULL);
 
 static ssize_t regulator_print_state(char *buf, int state)
 {
@@ -307,6 +310,7 @@ static ssize_t regulator_state_show(struct device *dev,
 
 	return regulator_print_state(buf, _regulator_is_enabled(rdev));
 }
+static DEVICE_ATTR(state, 0444, regulator_state_show, NULL);
 
 static ssize_t regulator_min_uA_show(struct device *dev,
 				    struct device_attribute *attr, char *buf)
@@ -318,6 +322,7 @@ static ssize_t regulator_min_uA_show(struct device *dev,
 
 	return sprintf(buf, "%d\n", rdev->constraints->min_uA);
 }
+static DEVICE_ATTR(min_microamps, 0444, regulator_min_uA_show, NULL);
 
 static ssize_t regulator_max_uA_show(struct device *dev,
 				    struct device_attribute *attr, char *buf)
@@ -329,6 +334,7 @@ static ssize_t regulator_max_uA_show(struct device *dev,
 
 	return sprintf(buf, "%d\n", rdev->constraints->max_uA);
 }
+static DEVICE_ATTR(max_microamps, 0444, regulator_max_uA_show, NULL);
 
 static ssize_t regulator_min_uV_show(struct device *dev,
 				    struct device_attribute *attr, char *buf)
@@ -340,6 +346,7 @@ static ssize_t regulator_min_uV_show(struct device *dev,
 
 	return sprintf(buf, "%d\n", rdev->constraints->min_uV);
 }
+static DEVICE_ATTR(min_microvolts, 0444, regulator_min_uV_show, NULL);
 
 static ssize_t regulator_max_uV_show(struct device *dev,
 				    struct device_attribute *attr, char *buf)
@@ -351,6 +358,7 @@ static ssize_t regulator_max_uV_show(struct device *dev,
 
 	return sprintf(buf, "%d\n", rdev->constraints->max_uV);
 }
+static DEVICE_ATTR(max_microvolts, 0444, regulator_max_uV_show, NULL);
 
 static ssize_t regulator_total_uA_show(struct device *dev,
 				      struct device_attribute *attr, char *buf)
@@ -365,6 +373,7 @@ static ssize_t regulator_total_uA_show(struct device *dev,
 	mutex_unlock(&rdev->mutex);
 	return sprintf(buf, "%d\n", uA);
 }
+static DEVICE_ATTR(requested_microamps, 0444, regulator_total_uA_show, NULL);
 
 static ssize_t regulator_num_users_show(struct device *dev,
 				      struct device_attribute *attr, char *buf)
@@ -392,131 +401,106 @@ static ssize_t regulator_suspend_mem_uV_show(struct device *dev,
 {
 	struct regulator_dev *rdev = dev_get_drvdata(dev);
 
-	if (!rdev->constraints)
-		return sprintf(buf, "not defined\n");
 	return sprintf(buf, "%d\n", rdev->constraints->state_mem.uV);
 }
+static DEVICE_ATTR(suspend_mem_microvolts, 0444,
+		regulator_suspend_mem_uV_show, NULL);
 
 static ssize_t regulator_suspend_disk_uV_show(struct device *dev,
 				struct device_attribute *attr, char *buf)
 {
 	struct regulator_dev *rdev = dev_get_drvdata(dev);
 
-	if (!rdev->constraints)
-		return sprintf(buf, "not defined\n");
 	return sprintf(buf, "%d\n", rdev->constraints->state_disk.uV);
 }
+static DEVICE_ATTR(suspend_disk_microvolts, 0444,
+		regulator_suspend_disk_uV_show, NULL);
 
 static ssize_t regulator_suspend_standby_uV_show(struct device *dev,
 				struct device_attribute *attr, char *buf)
 {
 	struct regulator_dev *rdev = dev_get_drvdata(dev);
 
-	if (!rdev->constraints)
-		return sprintf(buf, "not defined\n");
 	return sprintf(buf, "%d\n", rdev->constraints->state_standby.uV);
 }
+static DEVICE_ATTR(suspend_standby_microvolts, 0444,
+		regulator_suspend_standby_uV_show, NULL);
 
 static ssize_t regulator_suspend_mem_mode_show(struct device *dev,
 				struct device_attribute *attr, char *buf)
 {
 	struct regulator_dev *rdev = dev_get_drvdata(dev);
 
-	if (!rdev->constraints)
-		return sprintf(buf, "not defined\n");
 	return regulator_print_opmode(buf,
 		rdev->constraints->state_mem.mode);
 }
+static DEVICE_ATTR(suspend_mem_mode, 0444,
+		regulator_suspend_mem_mode_show, NULL);
 
 static ssize_t regulator_suspend_disk_mode_show(struct device *dev,
 				struct device_attribute *attr, char *buf)
 {
 	struct regulator_dev *rdev = dev_get_drvdata(dev);
 
-	if (!rdev->constraints)
-		return sprintf(buf, "not defined\n");
 	return regulator_print_opmode(buf,
 		rdev->constraints->state_disk.mode);
 }
+static DEVICE_ATTR(suspend_disk_mode, 0444,
+		regulator_suspend_disk_mode_show, NULL);
 
 static ssize_t regulator_suspend_standby_mode_show(struct device *dev,
 				struct device_attribute *attr, char *buf)
 {
 	struct regulator_dev *rdev = dev_get_drvdata(dev);
 
-	if (!rdev->constraints)
-		return sprintf(buf, "not defined\n");
 	return regulator_print_opmode(buf,
 		rdev->constraints->state_standby.mode);
 }
+static DEVICE_ATTR(suspend_standby_mode, 0444,
+		regulator_suspend_standby_mode_show, NULL);
 
 static ssize_t regulator_suspend_mem_state_show(struct device *dev,
 				   struct device_attribute *attr, char *buf)
 {
 	struct regulator_dev *rdev = dev_get_drvdata(dev);
 
-	if (!rdev->constraints)
-		return sprintf(buf, "not defined\n");
-
 	return regulator_print_state(buf,
 			rdev->constraints->state_mem.enabled);
 }
+static DEVICE_ATTR(suspend_mem_state, 0444,
+		regulator_suspend_mem_state_show, NULL);
 
 static ssize_t regulator_suspend_disk_state_show(struct device *dev,
 				   struct device_attribute *attr, char *buf)
 {
 	struct regulator_dev *rdev = dev_get_drvdata(dev);
 
-	if (!rdev->constraints)
-		return sprintf(buf, "not defined\n");
-
 	return regulator_print_state(buf,
 			rdev->constraints->state_disk.enabled);
 }
+static DEVICE_ATTR(suspend_disk_state, 0444,
+		regulator_suspend_disk_state_show, NULL);
 
 static ssize_t regulator_suspend_standby_state_show(struct device *dev,
 				   struct device_attribute *attr, char *buf)
 {
 	struct regulator_dev *rdev = dev_get_drvdata(dev);
 
-	if (!rdev->constraints)
-		return sprintf(buf, "not defined\n");
-
 	return regulator_print_state(buf,
 			rdev->constraints->state_standby.enabled);
 }
+static DEVICE_ATTR(suspend_standby_state, 0444,
+		regulator_suspend_standby_state_show, NULL);
+
 
+/*
+ * These are the only attributes are present for all regulators.
+ * Other attributes are a function of regulator functionality.
+ */
 static struct device_attribute regulator_dev_attrs[] = {
 	__ATTR(name, 0444, regulator_name_show, NULL),
-	__ATTR(microvolts, 0444, regulator_uV_show, NULL),
-	__ATTR(microamps, 0444, regulator_uA_show, NULL),
-	__ATTR(opmode, 0444, regulator_opmode_show, NULL),
-	__ATTR(state, 0444, regulator_state_show, NULL),
-	__ATTR(min_microvolts, 0444, regulator_min_uV_show, NULL),
-	__ATTR(min_microamps, 0444, regulator_min_uA_show, NULL),
-	__ATTR(max_microvolts, 0444, regulator_max_uV_show, NULL),
-	__ATTR(max_microamps, 0444, regulator_max_uA_show, NULL),
-	__ATTR(requested_microamps, 0444, regulator_total_uA_show, NULL),
 	__ATTR(num_users, 0444, regulator_num_users_show, NULL),
 	__ATTR(type, 0444, regulator_type_show, NULL),
-	__ATTR(suspend_mem_microvolts, 0444,
-		regulator_suspend_mem_uV_show, NULL),
-	__ATTR(suspend_disk_microvolts, 0444,
-		regulator_suspend_disk_uV_show, NULL),
-	__ATTR(suspend_standby_microvolts, 0444,
-		regulator_suspend_standby_uV_show, NULL),
-	__ATTR(suspend_mem_mode, 0444,
-		regulator_suspend_mem_mode_show, NULL),
-	__ATTR(suspend_disk_mode, 0444,
-		regulator_suspend_disk_mode_show, NULL),
-	__ATTR(suspend_standby_mode, 0444,
-		regulator_suspend_standby_mode_show, NULL),
-	__ATTR(suspend_mem_state, 0444,
-		regulator_suspend_mem_state_show, NULL),
-	__ATTR(suspend_disk_state, 0444,
-		regulator_suspend_disk_state_show, NULL),
-	__ATTR(suspend_standby_state, 0444,
-		regulator_suspend_standby_state_show, NULL),
 	__ATTR_NULL,
 };
 
@@ -1711,6 +1695,117 @@ int regulator_notifier_call_chain(struct regulator_dev *rdev,
 }
 EXPORT_SYMBOL_GPL(regulator_notifier_call_chain);
 
+/*
+ * To avoid cluttering sysfs (and memory) with useless state, only
+ * create attributes that can be meaningfully displayed.
+ */
+static int add_regulator_attributes(struct regulator_dev *rdev)
+{
+	struct device		*dev = &rdev->dev;
+	struct regulator_ops	*ops = rdev->desc->ops;
+	int			status = 0;
+
+	/* some attributes need specific methods to be displayed */
+	if (ops->get_voltage) {
+		status = device_create_file(dev, &dev_attr_microvolts);
+		if (status < 0)
+			return status;
+	}
+	if (ops->get_current_limit) {
+		status = device_create_file(dev, &dev_attr_microamps);
+		if (status < 0)
+			return status;
+	}
+	if (ops->get_mode) {
+		status = device_create_file(dev, &dev_attr_opmode);
+		if (status < 0)
+			return status;
+	}
+	if (ops->is_enabled) {
+		status = device_create_file(dev, &dev_attr_state);
+		if (status < 0)
+			return status;
+	}
+
+	/* some attributes are type-specific */
+	if (rdev->desc->type == REGULATOR_CURRENT) {
+		status = device_create_file(dev, &dev_attr_requested_microamps);
+		if (status < 0)
+			return status;
+	}
+
+	/* all the other attributes exist to support constraints;
+	 * don't show them if there are no constraints, or if the
+	 * relevant supporting methods are missing.
+	 */
+	if (!rdev->constraints)
+		return status;
+
+	/* constraints need specific supporting methods */
+	if (ops->set_voltage) {
+		status = device_create_file(dev, &dev_attr_min_microvolts);
+		if (status < 0)
+			return status;
+		status = device_create_file(dev, &dev_attr_max_microvolts);
+		if (status < 0)
+			return status;
+	}
+	if (ops->set_current_limit) {
+		status = device_create_file(dev, &dev_attr_min_microamps);
+		if (status < 0)
+			return status;
+		status = device_create_file(dev, &dev_attr_max_microamps);
+		if (status < 0)
+			return status;
+	}
+
+	/* suspend mode constraints need multiple supporting methods */
+	if (!(ops->set_suspend_enable && ops->set_suspend_disable))
+		return status;
+
+	status = device_create_file(dev, &dev_attr_suspend_standby_state);
+	if (status < 0)
+		return status;
+	status = device_create_file(dev, &dev_attr_suspend_mem_state);
+	if (status < 0)
+		return status;
+	status = device_create_file(dev, &dev_attr_suspend_disk_state);
+	if (status < 0)
+		return status;
+
+	if (ops->set_suspend_voltage) {
+		status = device_create_file(dev,
+				&dev_attr_suspend_standby_microvolts);
+		if (status < 0)
+			return status;
+		status = device_create_file(dev,
+				&dev_attr_suspend_mem_microvolts);
+		if (status < 0)
+			return status;
+		status = device_create_file(dev,
+				&dev_attr_suspend_disk_microvolts);
+		if (status < 0)
+			return status;
+	}
+
+	if (ops->set_suspend_mode) {
+		status = device_create_file(dev,
+				&dev_attr_suspend_standby_mode);
+		if (status < 0)
+			return status;
+		status = device_create_file(dev,
+				&dev_attr_suspend_mem_mode);
+		if (status < 0)
+			return status;
+		status = device_create_file(dev,
+				&dev_attr_suspend_disk_mode);
+		if (status < 0)
+			return status;
+	}
+
+	return status;
+}
+
 /**
  * regulator_register - register regulator
  * @regulator: regulator source
@@ -1779,6 +1874,11 @@ struct regulator_dev *regulator_register(struct regulator_desc *regulator_desc,
 
 	dev_set_drvdata(&rdev->dev, rdev);
 
+	/* add attributes supported by this regulator */
+	ret = add_regulator_attributes(rdev);
+	if (ret < 0)
+		goto scrub;
+
 	/* set supply regulator if it exists */
 	if (init_data->supply_regulator_dev) {
 		ret = set_supply(rdev,

commit 4fca9545d17b99cdb2774716b034c62a70151bcd
Author: David Brownell <dbrownell@users.sourceforge.net>
Date:   Tue Nov 11 17:38:53 2008 -0800

    regulator: code shrink (v2)
    
    Shrink regulator core by removing duplication in attribute printing
    and probe() cleanup paths.  Saves about 340 bytes (object) on ARM.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 686dfa990726..5109f7d4809a 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -267,12 +267,8 @@ static ssize_t regulator_name_show(struct device *dev,
 	return sprintf(buf, "%s\n", name);
 }
 
-static ssize_t regulator_opmode_show(struct device *dev,
-				    struct device_attribute *attr, char *buf)
+static ssize_t regulator_print_opmode(char *buf, int mode)
 {
-	struct regulator_dev *rdev = dev_get_drvdata(dev);
-	int mode = _regulator_get_mode(rdev);
-
 	switch (mode) {
 	case REGULATOR_MODE_FAST:
 		return sprintf(buf, "fast\n");
@@ -286,12 +282,16 @@ static ssize_t regulator_opmode_show(struct device *dev,
 	return sprintf(buf, "unknown\n");
 }
 
-static ssize_t regulator_state_show(struct device *dev,
-				   struct device_attribute *attr, char *buf)
+static ssize_t regulator_opmode_show(struct device *dev,
+				    struct device_attribute *attr, char *buf)
 {
 	struct regulator_dev *rdev = dev_get_drvdata(dev);
-	int state = _regulator_is_enabled(rdev);
 
+	return regulator_print_opmode(buf, _regulator_get_mode(rdev));
+}
+
+static ssize_t regulator_print_state(char *buf, int state)
+{
 	if (state > 0)
 		return sprintf(buf, "enabled\n");
 	else if (state == 0)
@@ -300,6 +300,14 @@ static ssize_t regulator_state_show(struct device *dev,
 		return sprintf(buf, "unknown\n");
 }
 
+static ssize_t regulator_state_show(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	struct regulator_dev *rdev = dev_get_drvdata(dev);
+
+	return regulator_print_state(buf, _regulator_is_enabled(rdev));
+}
+
 static ssize_t regulator_min_uA_show(struct device *dev,
 				    struct device_attribute *attr, char *buf)
 {
@@ -409,22 +417,6 @@ static ssize_t regulator_suspend_standby_uV_show(struct device *dev,
 	return sprintf(buf, "%d\n", rdev->constraints->state_standby.uV);
 }
 
-static ssize_t suspend_opmode_show(struct regulator_dev *rdev,
-	unsigned int mode, char *buf)
-{
-	switch (mode) {
-	case REGULATOR_MODE_FAST:
-		return sprintf(buf, "fast\n");
-	case REGULATOR_MODE_NORMAL:
-		return sprintf(buf, "normal\n");
-	case REGULATOR_MODE_IDLE:
-		return sprintf(buf, "idle\n");
-	case REGULATOR_MODE_STANDBY:
-		return sprintf(buf, "standby\n");
-	}
-	return sprintf(buf, "unknown\n");
-}
-
 static ssize_t regulator_suspend_mem_mode_show(struct device *dev,
 				struct device_attribute *attr, char *buf)
 {
@@ -432,8 +424,8 @@ static ssize_t regulator_suspend_mem_mode_show(struct device *dev,
 
 	if (!rdev->constraints)
 		return sprintf(buf, "not defined\n");
-	return suspend_opmode_show(rdev,
-		rdev->constraints->state_mem.mode, buf);
+	return regulator_print_opmode(buf,
+		rdev->constraints->state_mem.mode);
 }
 
 static ssize_t regulator_suspend_disk_mode_show(struct device *dev,
@@ -443,8 +435,8 @@ static ssize_t regulator_suspend_disk_mode_show(struct device *dev,
 
 	if (!rdev->constraints)
 		return sprintf(buf, "not defined\n");
-	return suspend_opmode_show(rdev,
-		rdev->constraints->state_disk.mode, buf);
+	return regulator_print_opmode(buf,
+		rdev->constraints->state_disk.mode);
 }
 
 static ssize_t regulator_suspend_standby_mode_show(struct device *dev,
@@ -454,8 +446,8 @@ static ssize_t regulator_suspend_standby_mode_show(struct device *dev,
 
 	if (!rdev->constraints)
 		return sprintf(buf, "not defined\n");
-	return suspend_opmode_show(rdev,
-		rdev->constraints->state_standby.mode, buf);
+	return regulator_print_opmode(buf,
+		rdev->constraints->state_standby.mode);
 }
 
 static ssize_t regulator_suspend_mem_state_show(struct device *dev,
@@ -466,10 +458,8 @@ static ssize_t regulator_suspend_mem_state_show(struct device *dev,
 	if (!rdev->constraints)
 		return sprintf(buf, "not defined\n");
 
-	if (rdev->constraints->state_mem.enabled)
-		return sprintf(buf, "enabled\n");
-	else
-		return sprintf(buf, "disabled\n");
+	return regulator_print_state(buf,
+			rdev->constraints->state_mem.enabled);
 }
 
 static ssize_t regulator_suspend_disk_state_show(struct device *dev,
@@ -480,10 +470,8 @@ static ssize_t regulator_suspend_disk_state_show(struct device *dev,
 	if (!rdev->constraints)
 		return sprintf(buf, "not defined\n");
 
-	if (rdev->constraints->state_disk.enabled)
-		return sprintf(buf, "enabled\n");
-	else
-		return sprintf(buf, "disabled\n");
+	return regulator_print_state(buf,
+			rdev->constraints->state_disk.enabled);
 }
 
 static ssize_t regulator_suspend_standby_state_show(struct device *dev,
@@ -494,10 +482,8 @@ static ssize_t regulator_suspend_standby_state_show(struct device *dev,
 	if (!rdev->constraints)
 		return sprintf(buf, "not defined\n");
 
-	if (rdev->constraints->state_standby.enabled)
-		return sprintf(buf, "enabled\n");
-	else
-		return sprintf(buf, "disabled\n");
+	return regulator_print_state(buf,
+			rdev->constraints->state_standby.enabled);
 }
 
 static struct device_attribute regulator_dev_attrs[] = {
@@ -1773,20 +1759,14 @@ struct regulator_dev *regulator_register(struct regulator_desc *regulator_desc,
 	/* preform any regulator specific init */
 	if (init_data->regulator_init) {
 		ret = init_data->regulator_init(rdev->reg_data);
-		if (ret < 0) {
-			kfree(rdev);
-			rdev = ERR_PTR(ret);
-			goto out;
-		}
+		if (ret < 0)
+			goto clean;
 	}
 
 	/* set regulator constraints */
 	ret = set_machine_constraints(rdev, &init_data->constraints);
-	if (ret < 0) {
-		kfree(rdev);
-		rdev = ERR_PTR(ret);
-		goto out;
-	}
+	if (ret < 0)
+		goto clean;
 
 	/* register with sysfs */
 	rdev->dev.class = &regulator_class;
@@ -1794,11 +1774,8 @@ struct regulator_dev *regulator_register(struct regulator_desc *regulator_desc,
 	dev_set_name(&rdev->dev, "regulator.%d",
 		     atomic_inc_return(&regulator_no) - 1);
 	ret = device_register(&rdev->dev);
-	if (ret != 0) {
-		kfree(rdev);
-		rdev = ERR_PTR(ret);
-		goto out;
-	}
+	if (ret != 0)
+		goto clean;
 
 	dev_set_drvdata(&rdev->dev, rdev);
 
@@ -1806,12 +1783,8 @@ struct regulator_dev *regulator_register(struct regulator_desc *regulator_desc,
 	if (init_data->supply_regulator_dev) {
 		ret = set_supply(rdev,
 			dev_get_drvdata(init_data->supply_regulator_dev));
-		if (ret < 0) {
-			device_unregister(&rdev->dev);
-			kfree(rdev);
-			rdev = ERR_PTR(ret);
-			goto out;
-		}
+		if (ret < 0)
+			goto scrub;
 	}
 
 	/* add consumers devices */
@@ -1823,10 +1796,7 @@ struct regulator_dev *regulator_register(struct regulator_desc *regulator_desc,
 			for (--i; i >= 0; i--)
 				unset_consumer_device_supply(rdev,
 					init_data->consumer_supplies[i].dev);
-			device_unregister(&rdev->dev);
-			kfree(rdev);
-			rdev = ERR_PTR(ret);
-			goto out;
+			goto scrub;
 		}
 	}
 
@@ -1834,6 +1804,13 @@ struct regulator_dev *regulator_register(struct regulator_desc *regulator_desc,
 out:
 	mutex_unlock(&regulator_list_mutex);
 	return rdev;
+
+scrub:
+	device_unregister(&rdev->dev);
+clean:
+	kfree(rdev);
+	rdev = ERR_PTR(ret);
+	goto out;
 }
 EXPORT_SYMBOL_GPL(regulator_register);
 

commit e573520b171095c106ffbbbf4f9cbed6d9bff576
Author: David Brownell <dbrownell@users.sourceforge.net>
Date:   Sun Nov 16 11:46:56 2008 -0800

    regulator: improved mode error checks
    
    Minor bugfixes in handling of regulator modes:
    
     - have the routine verifying regulator modes check against
       the set of legal modes (!);
    
     - have regulator_set_optimum_mode() verify the return value
       of regulator_ops.get_optimum_mode(), like drms_uA_update();
    
     - one call to regulator_ops.set_mode() treated zero as a
       failure code; make this consistent with other callers.
    
    Both regulator_set_mode() and regulator_set_optimum_mode() now
    require valid_ops_mask to include REGULATOR_CHANGE_MODE; that
    seems like a bugfix too.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index c2b7ec901036..686dfa990726 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -174,6 +174,16 @@ static int regulator_check_current_limit(struct regulator_dev *rdev,
 /* operating mode constraint check */
 static int regulator_check_mode(struct regulator_dev *rdev, int mode)
 {
+	switch (mode) {
+	case REGULATOR_MODE_FAST:
+	case REGULATOR_MODE_NORMAL:
+	case REGULATOR_MODE_IDLE:
+	case REGULATOR_MODE_STANDBY:
+		break;
+	default:
+		return -EINVAL;
+	}
+
 	if (!rdev->constraints) {
 		printk(KERN_ERR "%s: no constraints for %s\n", __func__,
 		       rdev->desc->name);
@@ -1494,7 +1504,8 @@ int regulator_set_optimum_mode(struct regulator *regulator, int uA_load)
 	mode = rdev->desc->ops->get_optimum_mode(rdev,
 						 input_uV, output_uV,
 						 total_uA_load);
-	if (ret <= 0) {
+	ret = regulator_check_mode(rdev, mode);
+	if (ret < 0) {
 		printk(KERN_ERR "%s: failed to get optimum mode for %s @"
 			" %d uA %d -> %d uV\n", __func__, rdev->desc->name,
 			total_uA_load, input_uV, output_uV);
@@ -1502,7 +1513,7 @@ int regulator_set_optimum_mode(struct regulator *regulator, int uA_load)
 	}
 
 	ret = rdev->desc->ops->set_mode(rdev, mode);
-	if (ret <= 0) {
+	if (ret < 0) {
 		printk(KERN_ERR "%s: failed to set optimum mode %x for %s\n",
 			__func__, mode, rdev->desc->name);
 		goto out;

commit 412aec610559bdb602a0a21ce149ba8ffbb6f983
Author: David Brownell <dbrownell@users.sourceforge.net>
Date:   Sun Nov 16 11:44:46 2008 -0800

    regulator: enable/disable refcounting
    
    Make the <linux/regulator.h> framework treat enable/disable call
    pairs like the <linux/clk.h> and <linux/interrupt.h> frameworks do:
    they're refcounted, so that different parts of a driver don't need
    to put work into coordination that frameworks normally handle.
    It's a minor object code shrink.
    
    It also makes the regulator_is_disabled() kerneldoc say what it's
    actually returning:  return value is not a refcount, and may report
    an error (e.g. I/O error from I2C).
    
    It also fixes some minor regulator_put() goofage:  removing unlocked
    access to the enable state.  (But still not making regulator put/get
    match the refcounting pattern they invoke.)
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 9a644d41b813..c2b7ec901036 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -79,7 +79,7 @@ struct regulator {
 	int uA_load;
 	int min_uV;
 	int max_uV;
-	int enabled; /* client has called enabled */
+	int enabled; /* count of client enables */
 	char *supply_name;
 	struct device_attribute dev_attr;
 	struct regulator_dev *rdev;
@@ -963,16 +963,13 @@ void regulator_put(struct regulator *regulator)
 	if (regulator == NULL || IS_ERR(regulator))
 		return;
 
-	if (regulator->enabled) {
-		printk(KERN_WARNING "Releasing supply %s while enabled\n",
-		       regulator->supply_name);
-		WARN_ON(regulator->enabled);
-		regulator_disable(regulator);
-	}
-
 	mutex_lock(&regulator_list_mutex);
 	rdev = regulator->rdev;
 
+	if (WARN(regulator->enabled, "Releasing supply %s while enabled\n",
+			       regulator->supply_name))
+		_regulator_disable(rdev);
+
 	/* remove any sysfs entries */
 	if (regulator->dev) {
 		sysfs_remove_link(&rdev->dev.kobj, regulator->supply_name);
@@ -1042,21 +1039,17 @@ static int _regulator_enable(struct regulator_dev *rdev)
  */
 int regulator_enable(struct regulator *regulator)
 {
-	int ret;
-
-	if (regulator->enabled) {
-		printk(KERN_CRIT "Regulator %s already enabled\n",
-		       regulator->supply_name);
-		WARN_ON(regulator->enabled);
-		return 0;
-	}
+	struct regulator_dev *rdev = regulator->rdev;
+	int ret = 0;
 
-	mutex_lock(&regulator->rdev->mutex);
-	regulator->enabled = 1;
-	ret = _regulator_enable(regulator->rdev);
-	if (ret != 0)
-		regulator->enabled = 0;
-	mutex_unlock(&regulator->rdev->mutex);
+	mutex_lock(&rdev->mutex);
+	if (regulator->enabled == 0)
+		ret = _regulator_enable(rdev);
+	else if (regulator->enabled < 0)
+		ret = -EIO;
+	if (ret == 0)
+		regulator->enabled++;
+	mutex_unlock(&rdev->mutex);
 	return ret;
 }
 EXPORT_SYMBOL_GPL(regulator_enable);
@@ -1108,19 +1101,21 @@ static int _regulator_disable(struct regulator_dev *rdev)
  */
 int regulator_disable(struct regulator *regulator)
 {
-	int ret;
-
-	if (!regulator->enabled) {
-		printk(KERN_ERR "%s: not in use by this consumer\n",
-			__func__);
-		return 0;
-	}
+	struct regulator_dev *rdev = regulator->rdev;
+	int ret = 0;
 
-	mutex_lock(&regulator->rdev->mutex);
-	regulator->enabled = 0;
-	regulator->uA_load = 0;
-	ret = _regulator_disable(regulator->rdev);
-	mutex_unlock(&regulator->rdev->mutex);
+	mutex_lock(&rdev->mutex);
+	if (regulator->enabled == 1) {
+		ret = _regulator_disable(rdev);
+		if (ret == 0)
+			regulator->uA_load = 0;
+	} else if (WARN(regulator->enabled <= 0,
+			"unbalanced disables for supply %s\n",
+			regulator->supply_name))
+		ret = -EIO;
+	if (ret == 0)
+		regulator->enabled--;
+	mutex_unlock(&rdev->mutex);
 	return ret;
 }
 EXPORT_SYMBOL_GPL(regulator_disable);
@@ -1196,7 +1191,13 @@ static int _regulator_is_enabled(struct regulator_dev *rdev)
  * regulator_is_enabled - is the regulator output enabled
  * @regulator: regulator source
  *
- * Returns zero for disabled otherwise return number of enable requests.
+ * Returns positive if the regulator driver backing the source/client
+ * has requested that the device be enabled, zero if it hasn't, else a
+ * negative errno code.
+ *
+ * Note that the device backing this regulator handle can have multiple
+ * users, so it might be enabled even if regulator_enable() was never
+ * called for this particular source.
  */
 int regulator_is_enabled(struct regulator *regulator)
 {

commit 812460a927c1d0dc1fbdbec9aa07de1b04043d83
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Sun Nov 2 03:55:10 2008 +0100

    regulator: struct device - replace bus_id with dev_name(), dev_set_name()
    
    This patch is part of a larger patch series which will remove
    the "char bus_id[20]" name string from struct device. The device
    name is managed in the kobject anyway, and without any size
    limitation, and just needlessly copied into "struct device".
    
    To set and read the device name dev_name(dev) and dev_set_name(dev)
    must be used. If your code uses static kobjects, which it shouldn't
    do, "const char *init_name" can be used to statically provide the
    name the registered device should have. At registration time, the
    init_name field is cleared, to enforce the use of dev_name(dev) to
    access the device name at a later time.
    
    We need to get rid of all occurrences of bus_id in the entire tree
    to be able to enable the new interface. Please apply this patch,
    and possibly convert any remaining remaining occurrences of bus_id.
    
    We want to submit a patch to -next, which will remove bus_id from
    "struct device", to find the remaining pieces to convert, and finally
    switch over to the new api, which will remove the 20 bytes array
    and does no longer have a size limitation.
    
    Thanks,
    Kay
    
    From: Kay Sievers <kay.sievers@vrfy.org>
    Subject: regulator: struct device - replace bus_id with dev_name(), dev_set_name()
    
    Cc: Liam Girdwood <lrg@slimlogic.co.uk>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-Off-By: Kay Sievers <kay.sievers@vrfy.org>
    
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 02a774424e8d..9a644d41b813 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1779,8 +1779,8 @@ struct regulator_dev *regulator_register(struct regulator_desc *regulator_desc,
 	/* register with sysfs */
 	rdev->dev.class = &regulator_class;
 	rdev->dev.parent = dev;
-	snprintf(rdev->dev.bus_id, sizeof(rdev->dev.bus_id),
-		 "regulator.%d", atomic_inc_return(&regulator_no) - 1);
+	dev_set_name(&rdev->dev, "regulator.%d",
+		     atomic_inc_return(&regulator_no) - 1);
 	ret = device_register(&rdev->dev);
 	if (ret != 0) {
 		kfree(rdev);

commit bc558a60b58f638ee0188affb627d4894a97b1c7
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Fri Oct 10 15:33:20 2008 +0100

    regulator: Export regulator name via sysfs
    
    Provide a new file 'name' in the regulator sysfs class with a human
    readable name for the regulator for use in applications.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 9a6757decd3d..02a774424e8d 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -241,6 +241,22 @@ static ssize_t regulator_uA_show(struct device *dev,
 	return sprintf(buf, "%d\n", _regulator_get_current_limit(rdev));
 }
 
+static ssize_t regulator_name_show(struct device *dev,
+			     struct device_attribute *attr, char *buf)
+{
+	struct regulator_dev *rdev = dev_get_drvdata(dev);
+	const char *name;
+
+	if (rdev->constraints->name)
+		name = rdev->constraints->name;
+	else if (rdev->desc->name)
+		name = rdev->desc->name;
+	else
+		name = "";
+
+	return sprintf(buf, "%s\n", name);
+}
+
 static ssize_t regulator_opmode_show(struct device *dev,
 				    struct device_attribute *attr, char *buf)
 {
@@ -473,7 +489,9 @@ static ssize_t regulator_suspend_standby_state_show(struct device *dev,
 	else
 		return sprintf(buf, "disabled\n");
 }
+
 static struct device_attribute regulator_dev_attrs[] = {
+	__ATTR(name, 0444, regulator_name_show, NULL),
 	__ATTR(microvolts, 0444, regulator_uV_show, NULL),
 	__ATTR(microamps, 0444, regulator_uA_show, NULL),
 	__ATTR(opmode, 0444, regulator_opmode_show, NULL),

commit e5fda26c7ea9430d7d953364f900bafdce2be67b
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Sep 9 16:21:20 2008 +0100

    regulator: Enable regulators marked as always_on
    
    If the machine constraints mark a regulator as always_on but this was
    not done by the bootloader then enable the regulator when applying
    constraints.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 04408896705e..9a6757decd3d 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -670,6 +670,7 @@ static int set_machine_constraints(struct regulator_dev *rdev,
 {
 	int ret = 0;
 	const char *name;
+	struct regulator_ops *ops = rdev->desc->ops;
 
 	if (constraints->name)
 		name = constraints->name;
@@ -683,8 +684,8 @@ static int set_machine_constraints(struct regulator_dev *rdev,
 	/* do we need to apply the constraint voltage */
 	if (rdev->constraints->apply_uV &&
 		rdev->constraints->min_uV == rdev->constraints->max_uV &&
-		rdev->desc->ops->set_voltage) {
-		ret = rdev->desc->ops->set_voltage(rdev,
+		ops->set_voltage) {
+		ret = ops->set_voltage(rdev,
 			rdev->constraints->min_uV, rdev->constraints->max_uV);
 			if (ret < 0) {
 				printk(KERN_ERR "%s: failed to apply %duV constraint to %s\n",
@@ -710,6 +711,20 @@ static int set_machine_constraints(struct regulator_dev *rdev,
 		}
 	}
 
+	/* if always_on is set then turn the regulator on if it's not
+	 * already on. */
+	if (constraints->always_on && ops->enable &&
+	    ((ops->is_enabled && !ops->is_enabled(rdev)) ||
+	     (!ops->is_enabled && !constraints->boot_on))) {
+		ret = ops->enable(rdev);
+		if (ret < 0) {
+			printk(KERN_ERR "%s: failed to enable %s\n",
+			       __func__, name);
+			rdev->constraints = NULL;
+			goto out;
+		}
+	}
+
 	print_constraints(rdev);
 out:
 	return ret;

commit e06f5b4fea243b152c79fe5d9552a852069de483
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Sep 9 16:21:19 2008 +0100

    regulator: Additional diagnostics for machine constraints
    
    Try to find a human readable name for the regulator we're failing on and
    print a specific diagnostic when we fail to set the suspend state.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 65e07b941a36..04408896705e 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -669,6 +669,14 @@ static int set_machine_constraints(struct regulator_dev *rdev,
 	struct regulation_constraints *constraints)
 {
 	int ret = 0;
+	const char *name;
+
+	if (constraints->name)
+		name = constraints->name;
+	else if (rdev->desc->name)
+		name = rdev->desc->name;
+	else
+		name = "regulator";
 
 	rdev->constraints = constraints;
 
@@ -679,9 +687,9 @@ static int set_machine_constraints(struct regulator_dev *rdev,
 		ret = rdev->desc->ops->set_voltage(rdev,
 			rdev->constraints->min_uV, rdev->constraints->max_uV);
 			if (ret < 0) {
-				printk(KERN_ERR "%s: failed to apply %duV"
-					" constraint\n", __func__,
-					rdev->constraints->min_uV);
+				printk(KERN_ERR "%s: failed to apply %duV constraint to %s\n",
+				       __func__,
+				       rdev->constraints->min_uV, name);
 				rdev->constraints = NULL;
 				goto out;
 			}
@@ -692,8 +700,15 @@ static int set_machine_constraints(struct regulator_dev *rdev,
 		rdev->use_count = 1;
 
 	/* do we need to setup our suspend state */
-	if (constraints->initial_state)
+	if (constraints->initial_state) {
 		ret = suspend_prepare(rdev, constraints->initial_state);
+		if (ret < 0) {
+			printk(KERN_ERR "%s: failed to set suspend state for %s\n",
+			       __func__, name);
+			rdev->constraints = NULL;
+			goto out;
+		}
+	}
 
 	print_constraints(rdev);
 out:

commit 46fabe1edd44a8893d88d7982f88d01ccf77f0bb
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Tue Sep 9 16:21:18 2008 +0100

    regulator: check for init_data on registration
    
    Since it is now mandatory to supply constraints via init_data on device
    registration check for that when registering, saving us from oopsing
    later on.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 84202eaace57..65e07b941a36 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -1691,6 +1691,9 @@ struct regulator_dev *regulator_register(struct regulator_desc *regulator_desc,
 	    !regulator_desc->type == REGULATOR_CURRENT)
 		return ERR_PTR(-EINVAL);
 
+	if (!init_data)
+		return ERR_PTR(-EINVAL);
+
 	rdev = kzalloc(sizeof(struct regulator_dev), GFP_KERNEL);
 	if (rdev == NULL)
 		return ERR_PTR(-ENOMEM);

commit a5766f11cfd3a0c03450d99c8fe548c2940be884
Author: Liam Girdwood <lrg@slimlogic.co.uk>
Date:   Fri Oct 10 13:22:20 2008 +0100

    regulator: core - Rework machine API to remove string based functions.
    
    This improves the machine level API in order to configure
    regulator constraints and consumers as platform data and removes the
    old string based API that required several calls to set up each regulator.
    
    The intention is to create a struct regulator_init_data, populate
    it's fields with constraints, consumers devices, etc and then register
    the regulator device from board.c in the standard Linux way.
    
    e.g. regulator LDO2 (supplying codec and sim) platform data.
    
    /* regulator LDO2 consumer devices */
    static struct regulator_consumer_supply ldo2_consumers[] = {
    {
            .dev    = &platform_audio_device.dev,
            .supply = "codec_avdd",
    },
    {
            .dev    = &platform_sim_device.dev,
            .supply = "sim_vcc",
    }
    };
    
    /* regulator LDO2 constraints  */
    static struct regulator_init_data ldo2_data = {
            .constraints = {
                    .min_uV = 3300000,
                    .max_uV = 3300000,
                    .valid_modes_mask = REGULATOR_MODE_NORMAL,
                    .apply_uV = 1,
            },
            .num_consumer_supplies = ARRAY_SIZE(ldo2_consumers),
            .consumer_supplies = ldo2_consumers,
    };
    
    /* machine regulator devices with thier consumers and constraints */
    static struct platform_device wm8350_regulator_devices[] = {
    {
            .name = "wm8350-regulator",
            .id = WM8350_LDO_2,
            .dev = {
                    .platform_data = &ldo2_data,
            },
    },
    };
    
    Changes in detail:-
    
      o Removed all const char* regulator config functions in machine API.
      o Created new struct regulator_init_data to contain regulator
        machine configuration constraints and consmuers.
      o Changed set_supply(), set_machine_constraints(),
        set_consumer_device_supply() to remove their string identifier
        parameters. Also made them static and moved functions nearer top of
        core.c.
      o Removed no longer used inline func to_rdev()
      o Added regulator_get_init_drvdata() to retrieve init data.
      o Added struct device* as parameter to regulator_register().
      o Changed my email address.
    
    Signed-off-by: Eric Miao <eric.miao@marvell.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Liam Girdwood <lrg@slimlogic.co.uk>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 9c7986261568..84202eaace57 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -2,8 +2,9 @@
  * core.c  --  Voltage/Current Regulator framework.
  *
  * Copyright 2007, 2008 Wolfson Microelectronics PLC.
+ * Copyright 2008 SlimLogic Ltd.
  *
- * Author: Liam Girdwood <liam.girdwood@wolfsonmicro.com>
+ * Author: Liam Girdwood <lrg@slimlogic.co.uk>
  *
  *  This program is free software; you can redistribute  it and/or modify it
  *  under  the terms of  the GNU General  Public License as published by the
@@ -64,14 +65,9 @@ struct regulator_map {
 	struct list_head list;
 	struct device *dev;
 	const char *supply;
-	const char *regulator;
+	struct regulator_dev *regulator;
 };
 
-static inline struct regulator_dev *to_rdev(struct device *d)
-{
-	return container_of(d, struct regulator_dev, dev);
-}
-
 /*
  * struct regulator
  *
@@ -227,7 +223,7 @@ static ssize_t device_requested_uA_show(struct device *dev,
 static ssize_t regulator_uV_show(struct device *dev,
 				struct device_attribute *attr, char *buf)
 {
-	struct regulator_dev *rdev = to_rdev(dev);
+	struct regulator_dev *rdev = dev_get_drvdata(dev);
 	ssize_t ret;
 
 	mutex_lock(&rdev->mutex);
@@ -240,7 +236,7 @@ static ssize_t regulator_uV_show(struct device *dev,
 static ssize_t regulator_uA_show(struct device *dev,
 				struct device_attribute *attr, char *buf)
 {
-	struct regulator_dev *rdev = to_rdev(dev);
+	struct regulator_dev *rdev = dev_get_drvdata(dev);
 
 	return sprintf(buf, "%d\n", _regulator_get_current_limit(rdev));
 }
@@ -248,7 +244,7 @@ static ssize_t regulator_uA_show(struct device *dev,
 static ssize_t regulator_opmode_show(struct device *dev,
 				    struct device_attribute *attr, char *buf)
 {
-	struct regulator_dev *rdev = to_rdev(dev);
+	struct regulator_dev *rdev = dev_get_drvdata(dev);
 	int mode = _regulator_get_mode(rdev);
 
 	switch (mode) {
@@ -267,7 +263,7 @@ static ssize_t regulator_opmode_show(struct device *dev,
 static ssize_t regulator_state_show(struct device *dev,
 				   struct device_attribute *attr, char *buf)
 {
-	struct regulator_dev *rdev = to_rdev(dev);
+	struct regulator_dev *rdev = dev_get_drvdata(dev);
 	int state = _regulator_is_enabled(rdev);
 
 	if (state > 0)
@@ -281,7 +277,7 @@ static ssize_t regulator_state_show(struct device *dev,
 static ssize_t regulator_min_uA_show(struct device *dev,
 				    struct device_attribute *attr, char *buf)
 {
-	struct regulator_dev *rdev = to_rdev(dev);
+	struct regulator_dev *rdev = dev_get_drvdata(dev);
 
 	if (!rdev->constraints)
 		return sprintf(buf, "constraint not defined\n");
@@ -292,7 +288,7 @@ static ssize_t regulator_min_uA_show(struct device *dev,
 static ssize_t regulator_max_uA_show(struct device *dev,
 				    struct device_attribute *attr, char *buf)
 {
-	struct regulator_dev *rdev = to_rdev(dev);
+	struct regulator_dev *rdev = dev_get_drvdata(dev);
 
 	if (!rdev->constraints)
 		return sprintf(buf, "constraint not defined\n");
@@ -303,7 +299,7 @@ static ssize_t regulator_max_uA_show(struct device *dev,
 static ssize_t regulator_min_uV_show(struct device *dev,
 				    struct device_attribute *attr, char *buf)
 {
-	struct regulator_dev *rdev = to_rdev(dev);
+	struct regulator_dev *rdev = dev_get_drvdata(dev);
 
 	if (!rdev->constraints)
 		return sprintf(buf, "constraint not defined\n");
@@ -314,7 +310,7 @@ static ssize_t regulator_min_uV_show(struct device *dev,
 static ssize_t regulator_max_uV_show(struct device *dev,
 				    struct device_attribute *attr, char *buf)
 {
-	struct regulator_dev *rdev = to_rdev(dev);
+	struct regulator_dev *rdev = dev_get_drvdata(dev);
 
 	if (!rdev->constraints)
 		return sprintf(buf, "constraint not defined\n");
@@ -325,7 +321,7 @@ static ssize_t regulator_max_uV_show(struct device *dev,
 static ssize_t regulator_total_uA_show(struct device *dev,
 				      struct device_attribute *attr, char *buf)
 {
-	struct regulator_dev *rdev = to_rdev(dev);
+	struct regulator_dev *rdev = dev_get_drvdata(dev);
 	struct regulator *regulator;
 	int uA = 0;
 
@@ -339,14 +335,14 @@ static ssize_t regulator_total_uA_show(struct device *dev,
 static ssize_t regulator_num_users_show(struct device *dev,
 				      struct device_attribute *attr, char *buf)
 {
-	struct regulator_dev *rdev = to_rdev(dev);
+	struct regulator_dev *rdev = dev_get_drvdata(dev);
 	return sprintf(buf, "%d\n", rdev->use_count);
 }
 
 static ssize_t regulator_type_show(struct device *dev,
 				  struct device_attribute *attr, char *buf)
 {
-	struct regulator_dev *rdev = to_rdev(dev);
+	struct regulator_dev *rdev = dev_get_drvdata(dev);
 
 	switch (rdev->desc->type) {
 	case REGULATOR_VOLTAGE:
@@ -360,7 +356,7 @@ static ssize_t regulator_type_show(struct device *dev,
 static ssize_t regulator_suspend_mem_uV_show(struct device *dev,
 				struct device_attribute *attr, char *buf)
 {
-	struct regulator_dev *rdev = to_rdev(dev);
+	struct regulator_dev *rdev = dev_get_drvdata(dev);
 
 	if (!rdev->constraints)
 		return sprintf(buf, "not defined\n");
@@ -370,7 +366,7 @@ static ssize_t regulator_suspend_mem_uV_show(struct device *dev,
 static ssize_t regulator_suspend_disk_uV_show(struct device *dev,
 				struct device_attribute *attr, char *buf)
 {
-	struct regulator_dev *rdev = to_rdev(dev);
+	struct regulator_dev *rdev = dev_get_drvdata(dev);
 
 	if (!rdev->constraints)
 		return sprintf(buf, "not defined\n");
@@ -380,7 +376,7 @@ static ssize_t regulator_suspend_disk_uV_show(struct device *dev,
 static ssize_t regulator_suspend_standby_uV_show(struct device *dev,
 				struct device_attribute *attr, char *buf)
 {
-	struct regulator_dev *rdev = to_rdev(dev);
+	struct regulator_dev *rdev = dev_get_drvdata(dev);
 
 	if (!rdev->constraints)
 		return sprintf(buf, "not defined\n");
@@ -406,7 +402,7 @@ static ssize_t suspend_opmode_show(struct regulator_dev *rdev,
 static ssize_t regulator_suspend_mem_mode_show(struct device *dev,
 				struct device_attribute *attr, char *buf)
 {
-	struct regulator_dev *rdev = to_rdev(dev);
+	struct regulator_dev *rdev = dev_get_drvdata(dev);
 
 	if (!rdev->constraints)
 		return sprintf(buf, "not defined\n");
@@ -417,7 +413,7 @@ static ssize_t regulator_suspend_mem_mode_show(struct device *dev,
 static ssize_t regulator_suspend_disk_mode_show(struct device *dev,
 				struct device_attribute *attr, char *buf)
 {
-	struct regulator_dev *rdev = to_rdev(dev);
+	struct regulator_dev *rdev = dev_get_drvdata(dev);
 
 	if (!rdev->constraints)
 		return sprintf(buf, "not defined\n");
@@ -428,7 +424,7 @@ static ssize_t regulator_suspend_disk_mode_show(struct device *dev,
 static ssize_t regulator_suspend_standby_mode_show(struct device *dev,
 				struct device_attribute *attr, char *buf)
 {
-	struct regulator_dev *rdev = to_rdev(dev);
+	struct regulator_dev *rdev = dev_get_drvdata(dev);
 
 	if (!rdev->constraints)
 		return sprintf(buf, "not defined\n");
@@ -439,7 +435,7 @@ static ssize_t regulator_suspend_standby_mode_show(struct device *dev,
 static ssize_t regulator_suspend_mem_state_show(struct device *dev,
 				   struct device_attribute *attr, char *buf)
 {
-	struct regulator_dev *rdev = to_rdev(dev);
+	struct regulator_dev *rdev = dev_get_drvdata(dev);
 
 	if (!rdev->constraints)
 		return sprintf(buf, "not defined\n");
@@ -453,7 +449,7 @@ static ssize_t regulator_suspend_mem_state_show(struct device *dev,
 static ssize_t regulator_suspend_disk_state_show(struct device *dev,
 				   struct device_attribute *attr, char *buf)
 {
-	struct regulator_dev *rdev = to_rdev(dev);
+	struct regulator_dev *rdev = dev_get_drvdata(dev);
 
 	if (!rdev->constraints)
 		return sprintf(buf, "not defined\n");
@@ -467,7 +463,7 @@ static ssize_t regulator_suspend_disk_state_show(struct device *dev,
 static ssize_t regulator_suspend_standby_state_show(struct device *dev,
 				   struct device_attribute *attr, char *buf)
 {
-	struct regulator_dev *rdev = to_rdev(dev);
+	struct regulator_dev *rdev = dev_get_drvdata(dev);
 
 	if (!rdev->constraints)
 		return sprintf(buf, "not defined\n");
@@ -512,7 +508,7 @@ static struct device_attribute regulator_dev_attrs[] = {
 
 static void regulator_dev_release(struct device *dev)
 {
-	struct regulator_dev *rdev = to_rdev(dev);
+	struct regulator_dev *rdev = dev_get_drvdata(dev);
 	kfree(rdev);
 }
 
@@ -569,8 +565,11 @@ static int suspend_set_state(struct regulator_dev *rdev,
 
 	/* enable & disable are mandatory for suspend control */
 	if (!rdev->desc->ops->set_suspend_enable ||
-		!rdev->desc->ops->set_suspend_disable)
+		!rdev->desc->ops->set_suspend_disable) {
+		printk(KERN_ERR "%s: no way to set suspend state\n",
+			__func__);
 		return -EINVAL;
+	}
 
 	if (rstate->enabled)
 		ret = rdev->desc->ops->set_suspend_enable(rdev);
@@ -656,6 +655,125 @@ static void print_constraints(struct regulator_dev *rdev)
 	printk(KERN_INFO "regulator: %s: %s\n", rdev->desc->name, buf);
 }
 
+/**
+ * set_machine_constraints - sets regulator constraints
+ * @regulator: regulator source
+ *
+ * Allows platform initialisation code to define and constrain
+ * regulator circuits e.g. valid voltage/current ranges, etc.  NOTE:
+ * Constraints *must* be set by platform code in order for some
+ * regulator operations to proceed i.e. set_voltage, set_current_limit,
+ * set_mode.
+ */
+static int set_machine_constraints(struct regulator_dev *rdev,
+	struct regulation_constraints *constraints)
+{
+	int ret = 0;
+
+	rdev->constraints = constraints;
+
+	/* do we need to apply the constraint voltage */
+	if (rdev->constraints->apply_uV &&
+		rdev->constraints->min_uV == rdev->constraints->max_uV &&
+		rdev->desc->ops->set_voltage) {
+		ret = rdev->desc->ops->set_voltage(rdev,
+			rdev->constraints->min_uV, rdev->constraints->max_uV);
+			if (ret < 0) {
+				printk(KERN_ERR "%s: failed to apply %duV"
+					" constraint\n", __func__,
+					rdev->constraints->min_uV);
+				rdev->constraints = NULL;
+				goto out;
+			}
+	}
+
+	/* are we enabled at boot time by firmware / bootloader */
+	if (rdev->constraints->boot_on)
+		rdev->use_count = 1;
+
+	/* do we need to setup our suspend state */
+	if (constraints->initial_state)
+		ret = suspend_prepare(rdev, constraints->initial_state);
+
+	print_constraints(rdev);
+out:
+	return ret;
+}
+
+/**
+ * set_supply - set regulator supply regulator
+ * @regulator: regulator name
+ * @supply: supply regulator name
+ *
+ * Called by platform initialisation code to set the supply regulator for this
+ * regulator. This ensures that a regulators supply will also be enabled by the
+ * core if it's child is enabled.
+ */
+static int set_supply(struct regulator_dev *rdev,
+	struct regulator_dev *supply_rdev)
+{
+	int err;
+
+	err = sysfs_create_link(&rdev->dev.kobj, &supply_rdev->dev.kobj,
+				"supply");
+	if (err) {
+		printk(KERN_ERR
+		       "%s: could not add device link %s err %d\n",
+		       __func__, supply_rdev->dev.kobj.name, err);
+		       goto out;
+	}
+	rdev->supply = supply_rdev;
+	list_add(&rdev->slist, &supply_rdev->supply_list);
+out:
+	return err;
+}
+
+/**
+ * set_consumer_device_supply: Bind a regulator to a symbolic supply
+ * @regulator: regulator source
+ * @dev:       device the supply applies to
+ * @supply:    symbolic name for supply
+ *
+ * Allows platform initialisation code to map physical regulator
+ * sources to symbolic names for supplies for use by devices.  Devices
+ * should use these symbolic names to request regulators, avoiding the
+ * need to provide board-specific regulator names as platform data.
+ */
+static int set_consumer_device_supply(struct regulator_dev *rdev,
+	struct device *consumer_dev, const char *supply)
+{
+	struct regulator_map *node;
+
+	if (supply == NULL)
+		return -EINVAL;
+
+	node = kmalloc(sizeof(struct regulator_map), GFP_KERNEL);
+	if (node == NULL)
+		return -ENOMEM;
+
+	node->regulator = rdev;
+	node->dev = consumer_dev;
+	node->supply = supply;
+
+	list_add(&node->list, &regulator_map_list);
+	return 0;
+}
+
+static void unset_consumer_device_supply(struct regulator_dev *rdev,
+	struct device *consumer_dev)
+{
+	struct regulator_map *node, *n;
+
+	list_for_each_entry_safe(node, n, &regulator_map_list, list) {
+		if (rdev == node->regulator &&
+			consumer_dev == node->dev) {
+			list_del(&node->list);
+			kfree(node);
+			return;
+		}
+	}
+}
+
 #define REG_STR_SIZE	32
 
 static struct regulator *create_regulator(struct regulator_dev *rdev,
@@ -746,7 +864,6 @@ struct regulator *regulator_get(struct device *dev, const char *id)
 	struct regulator_dev *rdev;
 	struct regulator_map *map;
 	struct regulator *regulator = ERR_PTR(-ENODEV);
-	const char *supply = id;
 
 	if (id == NULL) {
 		printk(KERN_ERR "regulator: get() with no identifier\n");
@@ -758,15 +875,9 @@ struct regulator *regulator_get(struct device *dev, const char *id)
 	list_for_each_entry(map, &regulator_map_list, list) {
 		if (dev == map->dev &&
 		    strcmp(map->supply, id) == 0) {
-			supply = map->regulator;
-			break;
-		}
-	}
-
-	list_for_each_entry(rdev, &regulator_list, list) {
-		if (strcmp(supply, rdev->desc->name) == 0 &&
-		    try_module_get(rdev->owner))
+			rdev = map->regulator;
 			goto found;
+		}
 	}
 	printk(KERN_ERR "regulator: Unable to get requested regulator: %s\n",
 	       id);
@@ -774,12 +885,16 @@ struct regulator *regulator_get(struct device *dev, const char *id)
 	return regulator;
 
 found:
+	if (!try_module_get(rdev->owner))
+		goto out;
+
 	regulator = create_regulator(rdev, dev, id);
 	if (regulator == NULL) {
 		regulator = ERR_PTR(-ENOMEM);
 		module_put(rdev->owner);
 	}
 
+out:
 	mutex_unlock(&regulator_list_mutex);
 	return regulator;
 }
@@ -1559,11 +1674,12 @@ EXPORT_SYMBOL_GPL(regulator_notifier_call_chain);
  * Returns 0 on success.
  */
 struct regulator_dev *regulator_register(struct regulator_desc *regulator_desc,
-					  void *reg_data)
+	struct device *dev, void *driver_data)
 {
 	static atomic_t regulator_no = ATOMIC_INIT(0);
 	struct regulator_dev *rdev;
-	int ret;
+	struct regulator_init_data *init_data = dev->platform_data;
+	int ret, i;
 
 	if (regulator_desc == NULL)
 		return ERR_PTR(-EINVAL);
@@ -1582,7 +1698,7 @@ struct regulator_dev *regulator_register(struct regulator_desc *regulator_desc,
 	mutex_lock(&regulator_list_mutex);
 
 	mutex_init(&rdev->mutex);
-	rdev->reg_data = reg_data;
+	rdev->reg_data = driver_data;
 	rdev->owner = regulator_desc->owner;
 	rdev->desc = regulator_desc;
 	INIT_LIST_HEAD(&rdev->consumer_list);
@@ -1591,20 +1707,68 @@ struct regulator_dev *regulator_register(struct regulator_desc *regulator_desc,
 	INIT_LIST_HEAD(&rdev->slist);
 	BLOCKING_INIT_NOTIFIER_HEAD(&rdev->notifier);
 
+	/* preform any regulator specific init */
+	if (init_data->regulator_init) {
+		ret = init_data->regulator_init(rdev->reg_data);
+		if (ret < 0) {
+			kfree(rdev);
+			rdev = ERR_PTR(ret);
+			goto out;
+		}
+	}
+
+	/* set regulator constraints */
+	ret = set_machine_constraints(rdev, &init_data->constraints);
+	if (ret < 0) {
+		kfree(rdev);
+		rdev = ERR_PTR(ret);
+		goto out;
+	}
+
+	/* register with sysfs */
 	rdev->dev.class = &regulator_class;
-	device_initialize(&rdev->dev);
+	rdev->dev.parent = dev;
 	snprintf(rdev->dev.bus_id, sizeof(rdev->dev.bus_id),
-		 "regulator_%ld_%s",
-		 (unsigned long)atomic_inc_return(&regulator_no) - 1,
-		 regulator_desc->name);
-
-	ret = device_add(&rdev->dev);
-	if (ret == 0)
-		list_add(&rdev->list, &regulator_list);
-	else {
+		 "regulator.%d", atomic_inc_return(&regulator_no) - 1);
+	ret = device_register(&rdev->dev);
+	if (ret != 0) {
 		kfree(rdev);
 		rdev = ERR_PTR(ret);
+		goto out;
+	}
+
+	dev_set_drvdata(&rdev->dev, rdev);
+
+	/* set supply regulator if it exists */
+	if (init_data->supply_regulator_dev) {
+		ret = set_supply(rdev,
+			dev_get_drvdata(init_data->supply_regulator_dev));
+		if (ret < 0) {
+			device_unregister(&rdev->dev);
+			kfree(rdev);
+			rdev = ERR_PTR(ret);
+			goto out;
+		}
+	}
+
+	/* add consumers devices */
+	for (i = 0; i < init_data->num_consumer_supplies; i++) {
+		ret = set_consumer_device_supply(rdev,
+			init_data->consumer_supplies[i].dev,
+			init_data->consumer_supplies[i].supply);
+		if (ret < 0) {
+			for (--i; i >= 0; i--)
+				unset_consumer_device_supply(rdev,
+					init_data->consumer_supplies[i].dev);
+			device_unregister(&rdev->dev);
+			kfree(rdev);
+			rdev = ERR_PTR(ret);
+			goto out;
+		}
 	}
+
+	list_add(&rdev->list, &regulator_list);
+out:
 	mutex_unlock(&regulator_list_mutex);
 	return rdev;
 }
@@ -1630,187 +1794,6 @@ void regulator_unregister(struct regulator_dev *rdev)
 }
 EXPORT_SYMBOL_GPL(regulator_unregister);
 
-/**
- * regulator_set_supply - set regulator supply regulator
- * @regulator: regulator name
- * @supply: supply regulator name
- *
- * Called by platform initialisation code to set the supply regulator for this
- * regulator. This ensures that a regulators supply will also be enabled by the
- * core if it's child is enabled.
- */
-int regulator_set_supply(const char *regulator, const char *supply)
-{
-	struct regulator_dev *rdev, *supply_rdev;
-	int err;
-
-	if (regulator == NULL || supply == NULL)
-		return -EINVAL;
-
-	mutex_lock(&regulator_list_mutex);
-
-	list_for_each_entry(rdev, &regulator_list, list) {
-		if (!strcmp(rdev->desc->name, regulator))
-			goto found_regulator;
-	}
-	mutex_unlock(&regulator_list_mutex);
-	return -ENODEV;
-
-found_regulator:
-	list_for_each_entry(supply_rdev, &regulator_list, list) {
-		if (!strcmp(supply_rdev->desc->name, supply))
-			goto found_supply;
-	}
-	mutex_unlock(&regulator_list_mutex);
-	return -ENODEV;
-
-found_supply:
-	err = sysfs_create_link(&rdev->dev.kobj, &supply_rdev->dev.kobj,
-				"supply");
-	if (err) {
-		printk(KERN_ERR
-		       "%s: could not add device link %s err %d\n",
-		       __func__, supply_rdev->dev.kobj.name, err);
-		       goto out;
-	}
-	rdev->supply = supply_rdev;
-	list_add(&rdev->slist, &supply_rdev->supply_list);
-out:
-	mutex_unlock(&regulator_list_mutex);
-	return err;
-}
-EXPORT_SYMBOL_GPL(regulator_set_supply);
-
-/**
- * regulator_get_supply - get regulator supply regulator
- * @regulator: regulator name
- *
- * Returns the supply supply regulator name or NULL if no supply regulator
- * exists (i.e the regulator is supplied directly from USB, Line, Battery, etc)
- */
-const char *regulator_get_supply(const char *regulator)
-{
-	struct regulator_dev *rdev;
-
-	if (regulator == NULL)
-		return NULL;
-
-	mutex_lock(&regulator_list_mutex);
-	list_for_each_entry(rdev, &regulator_list, list) {
-		if (!strcmp(rdev->desc->name, regulator))
-			goto found;
-	}
-	mutex_unlock(&regulator_list_mutex);
-	return NULL;
-
-found:
-	mutex_unlock(&regulator_list_mutex);
-	if (rdev->supply)
-		return rdev->supply->desc->name;
-	else
-		return NULL;
-}
-EXPORT_SYMBOL_GPL(regulator_get_supply);
-
-/**
- * regulator_set_machine_constraints - sets regulator constraints
- * @regulator: regulator source
- *
- * Allows platform initialisation code to define and constrain
- * regulator circuits e.g. valid voltage/current ranges, etc.  NOTE:
- * Constraints *must* be set by platform code in order for some
- * regulator operations to proceed i.e. set_voltage, set_current_limit,
- * set_mode.
- */
-int regulator_set_machine_constraints(const char *regulator_name,
-	struct regulation_constraints *constraints)
-{
-	struct regulator_dev *rdev;
-	int ret = 0;
-
-	if (regulator_name == NULL)
-		return -EINVAL;
-
-	mutex_lock(&regulator_list_mutex);
-
-	list_for_each_entry(rdev, &regulator_list, list) {
-		if (!strcmp(regulator_name, rdev->desc->name))
-			goto found;
-	}
-	ret = -ENODEV;
-	goto out;
-
-found:
-	mutex_lock(&rdev->mutex);
-	rdev->constraints = constraints;
-
-	/* do we need to apply the constraint voltage */
-	if (rdev->constraints->apply_uV &&
-		rdev->constraints->min_uV == rdev->constraints->max_uV &&
-		rdev->desc->ops->set_voltage) {
-		ret = rdev->desc->ops->set_voltage(rdev,
-			rdev->constraints->min_uV, rdev->constraints->max_uV);
-			if (ret < 0) {
-				printk(KERN_ERR "%s: failed to apply %duV"
-					" constraint\n", __func__,
-					rdev->constraints->min_uV);
-				rdev->constraints = NULL;
-				goto out;
-			}
-	}
-
-	/* are we enabled at boot time by firmware / bootloader */
-	if (rdev->constraints->boot_on)
-		rdev->use_count = 1;
-
-	/* do we need to setup our suspend state */
-	if (constraints->initial_state)
-		ret = suspend_prepare(rdev, constraints->initial_state);
-
-	print_constraints(rdev);
-	mutex_unlock(&rdev->mutex);
-
-out:
-	mutex_unlock(&regulator_list_mutex);
-	return ret;
-}
-EXPORT_SYMBOL_GPL(regulator_set_machine_constraints);
-
-
-/**
- * regulator_set_device_supply: Bind a regulator to a symbolic supply
- * @regulator: regulator source
- * @dev:       device the supply applies to
- * @supply:    symbolic name for supply
- *
- * Allows platform initialisation code to map physical regulator
- * sources to symbolic names for supplies for use by devices.  Devices
- * should use these symbolic names to request regulators, avoiding the
- * need to provide board-specific regulator names as platform data.
- */
-int regulator_set_device_supply(const char *regulator, struct device *dev,
-				const char *supply)
-{
-	struct regulator_map *node;
-
-	if (regulator == NULL || supply == NULL)
-		return -EINVAL;
-
-	node = kmalloc(sizeof(struct regulator_map), GFP_KERNEL);
-	if (node == NULL)
-		return -ENOMEM;
-
-	node->regulator = regulator;
-	node->dev = dev;
-	node->supply = supply;
-
-	mutex_lock(&regulator_list_mutex);
-	list_add(&node->list, &regulator_map_list);
-	mutex_unlock(&regulator_list_mutex);
-	return 0;
-}
-EXPORT_SYMBOL_GPL(regulator_set_device_supply);
-
 /**
  * regulator_suspend_prepare: prepare regulators for system wide suspend
  * @state: system suspend state
@@ -1893,6 +1876,18 @@ int rdev_get_id(struct regulator_dev *rdev)
 }
 EXPORT_SYMBOL_GPL(rdev_get_id);
 
+struct device *rdev_get_dev(struct regulator_dev *rdev)
+{
+	return &rdev->dev;
+}
+EXPORT_SYMBOL_GPL(rdev_get_dev);
+
+void *regulator_get_init_drvdata(struct regulator_init_data *reg_init_data)
+{
+	return reg_init_data->driver_data;
+}
+EXPORT_SYMBOL_GPL(regulator_get_init_drvdata);
+
 static int __init regulator_init(void)
 {
 	printk(KERN_INFO "regulator: core version %s\n", REGULATOR_VERSION);

commit 414c70cb91c445ec813b61e16fe4882807e40240
Author: Liam Girdwood <lg@opensource.wolfsonmicro.com>
Date:   Wed Apr 30 15:59:04 2008 +0100

    regulator: regulator framework core
    
    This adds the regulator framework core.
    
    This framework is designed to provide a generic interface to voltage
    and current regulators within the Linux kernel. It's intended to
    provide voltage and current control to client or consumer drivers and
    also provide status information to user space applications through a
    sysfs interface.
    
    The intention is to allow systems to dynamically control regulator
    output in order to save power and prolong battery life. This applies
    to both voltage regulators (where voltage output is controllable) and
    current sinks (where current output is controllable).
    
    This framework safely compiles out if not selected so that client
    drivers can still be used in systems with no software controllable
    regulators.
    
    Signed-off-by: Liam Girdwood <lg@opensource.wolfsonmicro.com>
    Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
new file mode 100644
index 000000000000..9c7986261568
--- /dev/null
+++ b/drivers/regulator/core.c
@@ -0,0 +1,1903 @@
+/*
+ * core.c  --  Voltage/Current Regulator framework.
+ *
+ * Copyright 2007, 2008 Wolfson Microelectronics PLC.
+ *
+ * Author: Liam Girdwood <liam.girdwood@wolfsonmicro.com>
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/mutex.h>
+#include <linux/suspend.h>
+#include <linux/regulator/consumer.h>
+#include <linux/regulator/driver.h>
+#include <linux/regulator/machine.h>
+
+#define REGULATOR_VERSION "0.5"
+
+static DEFINE_MUTEX(regulator_list_mutex);
+static LIST_HEAD(regulator_list);
+static LIST_HEAD(regulator_map_list);
+
+/**
+ * struct regulator_dev
+ *
+ * Voltage / Current regulator class device. One for each regulator.
+ */
+struct regulator_dev {
+	struct regulator_desc *desc;
+	int use_count;
+
+	/* lists we belong to */
+	struct list_head list; /* list of all regulators */
+	struct list_head slist; /* list of supplied regulators */
+
+	/* lists we own */
+	struct list_head consumer_list; /* consumers we supply */
+	struct list_head supply_list; /* regulators we supply */
+
+	struct blocking_notifier_head notifier;
+	struct mutex mutex; /* consumer lock */
+	struct module *owner;
+	struct device dev;
+	struct regulation_constraints *constraints;
+	struct regulator_dev *supply;	/* for tree */
+
+	void *reg_data;		/* regulator_dev data */
+};
+
+/**
+ * struct regulator_map
+ *
+ * Used to provide symbolic supply names to devices.
+ */
+struct regulator_map {
+	struct list_head list;
+	struct device *dev;
+	const char *supply;
+	const char *regulator;
+};
+
+static inline struct regulator_dev *to_rdev(struct device *d)
+{
+	return container_of(d, struct regulator_dev, dev);
+}
+
+/*
+ * struct regulator
+ *
+ * One for each consumer device.
+ */
+struct regulator {
+	struct device *dev;
+	struct list_head list;
+	int uA_load;
+	int min_uV;
+	int max_uV;
+	int enabled; /* client has called enabled */
+	char *supply_name;
+	struct device_attribute dev_attr;
+	struct regulator_dev *rdev;
+};
+
+static int _regulator_is_enabled(struct regulator_dev *rdev);
+static int _regulator_disable(struct regulator_dev *rdev);
+static int _regulator_get_voltage(struct regulator_dev *rdev);
+static int _regulator_get_current_limit(struct regulator_dev *rdev);
+static unsigned int _regulator_get_mode(struct regulator_dev *rdev);
+static void _notifier_call_chain(struct regulator_dev *rdev,
+				  unsigned long event, void *data);
+
+/* gets the regulator for a given consumer device */
+static struct regulator *get_device_regulator(struct device *dev)
+{
+	struct regulator *regulator = NULL;
+	struct regulator_dev *rdev;
+
+	mutex_lock(&regulator_list_mutex);
+	list_for_each_entry(rdev, &regulator_list, list) {
+		mutex_lock(&rdev->mutex);
+		list_for_each_entry(regulator, &rdev->consumer_list, list) {
+			if (regulator->dev == dev) {
+				mutex_unlock(&rdev->mutex);
+				mutex_unlock(&regulator_list_mutex);
+				return regulator;
+			}
+		}
+		mutex_unlock(&rdev->mutex);
+	}
+	mutex_unlock(&regulator_list_mutex);
+	return NULL;
+}
+
+/* Platform voltage constraint check */
+static int regulator_check_voltage(struct regulator_dev *rdev,
+				   int *min_uV, int *max_uV)
+{
+	BUG_ON(*min_uV > *max_uV);
+
+	if (!rdev->constraints) {
+		printk(KERN_ERR "%s: no constraints for %s\n", __func__,
+		       rdev->desc->name);
+		return -ENODEV;
+	}
+	if (!(rdev->constraints->valid_ops_mask & REGULATOR_CHANGE_VOLTAGE)) {
+		printk(KERN_ERR "%s: operation not allowed for %s\n",
+		       __func__, rdev->desc->name);
+		return -EPERM;
+	}
+
+	if (*max_uV > rdev->constraints->max_uV)
+		*max_uV = rdev->constraints->max_uV;
+	if (*min_uV < rdev->constraints->min_uV)
+		*min_uV = rdev->constraints->min_uV;
+
+	if (*min_uV > *max_uV)
+		return -EINVAL;
+
+	return 0;
+}
+
+/* current constraint check */
+static int regulator_check_current_limit(struct regulator_dev *rdev,
+					int *min_uA, int *max_uA)
+{
+	BUG_ON(*min_uA > *max_uA);
+
+	if (!rdev->constraints) {
+		printk(KERN_ERR "%s: no constraints for %s\n", __func__,
+		       rdev->desc->name);
+		return -ENODEV;
+	}
+	if (!(rdev->constraints->valid_ops_mask & REGULATOR_CHANGE_CURRENT)) {
+		printk(KERN_ERR "%s: operation not allowed for %s\n",
+		       __func__, rdev->desc->name);
+		return -EPERM;
+	}
+
+	if (*max_uA > rdev->constraints->max_uA)
+		*max_uA = rdev->constraints->max_uA;
+	if (*min_uA < rdev->constraints->min_uA)
+		*min_uA = rdev->constraints->min_uA;
+
+	if (*min_uA > *max_uA)
+		return -EINVAL;
+
+	return 0;
+}
+
+/* operating mode constraint check */
+static int regulator_check_mode(struct regulator_dev *rdev, int mode)
+{
+	if (!rdev->constraints) {
+		printk(KERN_ERR "%s: no constraints for %s\n", __func__,
+		       rdev->desc->name);
+		return -ENODEV;
+	}
+	if (!(rdev->constraints->valid_ops_mask & REGULATOR_CHANGE_MODE)) {
+		printk(KERN_ERR "%s: operation not allowed for %s\n",
+		       __func__, rdev->desc->name);
+		return -EPERM;
+	}
+	if (!(rdev->constraints->valid_modes_mask & mode)) {
+		printk(KERN_ERR "%s: invalid mode %x for %s\n",
+		       __func__, mode, rdev->desc->name);
+		return -EINVAL;
+	}
+	return 0;
+}
+
+/* dynamic regulator mode switching constraint check */
+static int regulator_check_drms(struct regulator_dev *rdev)
+{
+	if (!rdev->constraints) {
+		printk(KERN_ERR "%s: no constraints for %s\n", __func__,
+		       rdev->desc->name);
+		return -ENODEV;
+	}
+	if (!(rdev->constraints->valid_ops_mask & REGULATOR_CHANGE_DRMS)) {
+		printk(KERN_ERR "%s: operation not allowed for %s\n",
+		       __func__, rdev->desc->name);
+		return -EPERM;
+	}
+	return 0;
+}
+
+static ssize_t device_requested_uA_show(struct device *dev,
+			     struct device_attribute *attr, char *buf)
+{
+	struct regulator *regulator;
+
+	regulator = get_device_regulator(dev);
+	if (regulator == NULL)
+		return 0;
+
+	return sprintf(buf, "%d\n", regulator->uA_load);
+}
+
+static ssize_t regulator_uV_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct regulator_dev *rdev = to_rdev(dev);
+	ssize_t ret;
+
+	mutex_lock(&rdev->mutex);
+	ret = sprintf(buf, "%d\n", _regulator_get_voltage(rdev));
+	mutex_unlock(&rdev->mutex);
+
+	return ret;
+}
+
+static ssize_t regulator_uA_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct regulator_dev *rdev = to_rdev(dev);
+
+	return sprintf(buf, "%d\n", _regulator_get_current_limit(rdev));
+}
+
+static ssize_t regulator_opmode_show(struct device *dev,
+				    struct device_attribute *attr, char *buf)
+{
+	struct regulator_dev *rdev = to_rdev(dev);
+	int mode = _regulator_get_mode(rdev);
+
+	switch (mode) {
+	case REGULATOR_MODE_FAST:
+		return sprintf(buf, "fast\n");
+	case REGULATOR_MODE_NORMAL:
+		return sprintf(buf, "normal\n");
+	case REGULATOR_MODE_IDLE:
+		return sprintf(buf, "idle\n");
+	case REGULATOR_MODE_STANDBY:
+		return sprintf(buf, "standby\n");
+	}
+	return sprintf(buf, "unknown\n");
+}
+
+static ssize_t regulator_state_show(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	struct regulator_dev *rdev = to_rdev(dev);
+	int state = _regulator_is_enabled(rdev);
+
+	if (state > 0)
+		return sprintf(buf, "enabled\n");
+	else if (state == 0)
+		return sprintf(buf, "disabled\n");
+	else
+		return sprintf(buf, "unknown\n");
+}
+
+static ssize_t regulator_min_uA_show(struct device *dev,
+				    struct device_attribute *attr, char *buf)
+{
+	struct regulator_dev *rdev = to_rdev(dev);
+
+	if (!rdev->constraints)
+		return sprintf(buf, "constraint not defined\n");
+
+	return sprintf(buf, "%d\n", rdev->constraints->min_uA);
+}
+
+static ssize_t regulator_max_uA_show(struct device *dev,
+				    struct device_attribute *attr, char *buf)
+{
+	struct regulator_dev *rdev = to_rdev(dev);
+
+	if (!rdev->constraints)
+		return sprintf(buf, "constraint not defined\n");
+
+	return sprintf(buf, "%d\n", rdev->constraints->max_uA);
+}
+
+static ssize_t regulator_min_uV_show(struct device *dev,
+				    struct device_attribute *attr, char *buf)
+{
+	struct regulator_dev *rdev = to_rdev(dev);
+
+	if (!rdev->constraints)
+		return sprintf(buf, "constraint not defined\n");
+
+	return sprintf(buf, "%d\n", rdev->constraints->min_uV);
+}
+
+static ssize_t regulator_max_uV_show(struct device *dev,
+				    struct device_attribute *attr, char *buf)
+{
+	struct regulator_dev *rdev = to_rdev(dev);
+
+	if (!rdev->constraints)
+		return sprintf(buf, "constraint not defined\n");
+
+	return sprintf(buf, "%d\n", rdev->constraints->max_uV);
+}
+
+static ssize_t regulator_total_uA_show(struct device *dev,
+				      struct device_attribute *attr, char *buf)
+{
+	struct regulator_dev *rdev = to_rdev(dev);
+	struct regulator *regulator;
+	int uA = 0;
+
+	mutex_lock(&rdev->mutex);
+	list_for_each_entry(regulator, &rdev->consumer_list, list)
+	    uA += regulator->uA_load;
+	mutex_unlock(&rdev->mutex);
+	return sprintf(buf, "%d\n", uA);
+}
+
+static ssize_t regulator_num_users_show(struct device *dev,
+				      struct device_attribute *attr, char *buf)
+{
+	struct regulator_dev *rdev = to_rdev(dev);
+	return sprintf(buf, "%d\n", rdev->use_count);
+}
+
+static ssize_t regulator_type_show(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	struct regulator_dev *rdev = to_rdev(dev);
+
+	switch (rdev->desc->type) {
+	case REGULATOR_VOLTAGE:
+		return sprintf(buf, "voltage\n");
+	case REGULATOR_CURRENT:
+		return sprintf(buf, "current\n");
+	}
+	return sprintf(buf, "unknown\n");
+}
+
+static ssize_t regulator_suspend_mem_uV_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct regulator_dev *rdev = to_rdev(dev);
+
+	if (!rdev->constraints)
+		return sprintf(buf, "not defined\n");
+	return sprintf(buf, "%d\n", rdev->constraints->state_mem.uV);
+}
+
+static ssize_t regulator_suspend_disk_uV_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct regulator_dev *rdev = to_rdev(dev);
+
+	if (!rdev->constraints)
+		return sprintf(buf, "not defined\n");
+	return sprintf(buf, "%d\n", rdev->constraints->state_disk.uV);
+}
+
+static ssize_t regulator_suspend_standby_uV_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct regulator_dev *rdev = to_rdev(dev);
+
+	if (!rdev->constraints)
+		return sprintf(buf, "not defined\n");
+	return sprintf(buf, "%d\n", rdev->constraints->state_standby.uV);
+}
+
+static ssize_t suspend_opmode_show(struct regulator_dev *rdev,
+	unsigned int mode, char *buf)
+{
+	switch (mode) {
+	case REGULATOR_MODE_FAST:
+		return sprintf(buf, "fast\n");
+	case REGULATOR_MODE_NORMAL:
+		return sprintf(buf, "normal\n");
+	case REGULATOR_MODE_IDLE:
+		return sprintf(buf, "idle\n");
+	case REGULATOR_MODE_STANDBY:
+		return sprintf(buf, "standby\n");
+	}
+	return sprintf(buf, "unknown\n");
+}
+
+static ssize_t regulator_suspend_mem_mode_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct regulator_dev *rdev = to_rdev(dev);
+
+	if (!rdev->constraints)
+		return sprintf(buf, "not defined\n");
+	return suspend_opmode_show(rdev,
+		rdev->constraints->state_mem.mode, buf);
+}
+
+static ssize_t regulator_suspend_disk_mode_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct regulator_dev *rdev = to_rdev(dev);
+
+	if (!rdev->constraints)
+		return sprintf(buf, "not defined\n");
+	return suspend_opmode_show(rdev,
+		rdev->constraints->state_disk.mode, buf);
+}
+
+static ssize_t regulator_suspend_standby_mode_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct regulator_dev *rdev = to_rdev(dev);
+
+	if (!rdev->constraints)
+		return sprintf(buf, "not defined\n");
+	return suspend_opmode_show(rdev,
+		rdev->constraints->state_standby.mode, buf);
+}
+
+static ssize_t regulator_suspend_mem_state_show(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	struct regulator_dev *rdev = to_rdev(dev);
+
+	if (!rdev->constraints)
+		return sprintf(buf, "not defined\n");
+
+	if (rdev->constraints->state_mem.enabled)
+		return sprintf(buf, "enabled\n");
+	else
+		return sprintf(buf, "disabled\n");
+}
+
+static ssize_t regulator_suspend_disk_state_show(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	struct regulator_dev *rdev = to_rdev(dev);
+
+	if (!rdev->constraints)
+		return sprintf(buf, "not defined\n");
+
+	if (rdev->constraints->state_disk.enabled)
+		return sprintf(buf, "enabled\n");
+	else
+		return sprintf(buf, "disabled\n");
+}
+
+static ssize_t regulator_suspend_standby_state_show(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	struct regulator_dev *rdev = to_rdev(dev);
+
+	if (!rdev->constraints)
+		return sprintf(buf, "not defined\n");
+
+	if (rdev->constraints->state_standby.enabled)
+		return sprintf(buf, "enabled\n");
+	else
+		return sprintf(buf, "disabled\n");
+}
+static struct device_attribute regulator_dev_attrs[] = {
+	__ATTR(microvolts, 0444, regulator_uV_show, NULL),
+	__ATTR(microamps, 0444, regulator_uA_show, NULL),
+	__ATTR(opmode, 0444, regulator_opmode_show, NULL),
+	__ATTR(state, 0444, regulator_state_show, NULL),
+	__ATTR(min_microvolts, 0444, regulator_min_uV_show, NULL),
+	__ATTR(min_microamps, 0444, regulator_min_uA_show, NULL),
+	__ATTR(max_microvolts, 0444, regulator_max_uV_show, NULL),
+	__ATTR(max_microamps, 0444, regulator_max_uA_show, NULL),
+	__ATTR(requested_microamps, 0444, regulator_total_uA_show, NULL),
+	__ATTR(num_users, 0444, regulator_num_users_show, NULL),
+	__ATTR(type, 0444, regulator_type_show, NULL),
+	__ATTR(suspend_mem_microvolts, 0444,
+		regulator_suspend_mem_uV_show, NULL),
+	__ATTR(suspend_disk_microvolts, 0444,
+		regulator_suspend_disk_uV_show, NULL),
+	__ATTR(suspend_standby_microvolts, 0444,
+		regulator_suspend_standby_uV_show, NULL),
+	__ATTR(suspend_mem_mode, 0444,
+		regulator_suspend_mem_mode_show, NULL),
+	__ATTR(suspend_disk_mode, 0444,
+		regulator_suspend_disk_mode_show, NULL),
+	__ATTR(suspend_standby_mode, 0444,
+		regulator_suspend_standby_mode_show, NULL),
+	__ATTR(suspend_mem_state, 0444,
+		regulator_suspend_mem_state_show, NULL),
+	__ATTR(suspend_disk_state, 0444,
+		regulator_suspend_disk_state_show, NULL),
+	__ATTR(suspend_standby_state, 0444,
+		regulator_suspend_standby_state_show, NULL),
+	__ATTR_NULL,
+};
+
+static void regulator_dev_release(struct device *dev)
+{
+	struct regulator_dev *rdev = to_rdev(dev);
+	kfree(rdev);
+}
+
+static struct class regulator_class = {
+	.name = "regulator",
+	.dev_release = regulator_dev_release,
+	.dev_attrs = regulator_dev_attrs,
+};
+
+/* Calculate the new optimum regulator operating mode based on the new total
+ * consumer load. All locks held by caller */
+static void drms_uA_update(struct regulator_dev *rdev)
+{
+	struct regulator *sibling;
+	int current_uA = 0, output_uV, input_uV, err;
+	unsigned int mode;
+
+	err = regulator_check_drms(rdev);
+	if (err < 0 || !rdev->desc->ops->get_optimum_mode ||
+	    !rdev->desc->ops->get_voltage || !rdev->desc->ops->set_mode);
+	return;
+
+	/* get output voltage */
+	output_uV = rdev->desc->ops->get_voltage(rdev);
+	if (output_uV <= 0)
+		return;
+
+	/* get input voltage */
+	if (rdev->supply && rdev->supply->desc->ops->get_voltage)
+		input_uV = rdev->supply->desc->ops->get_voltage(rdev->supply);
+	else
+		input_uV = rdev->constraints->input_uV;
+	if (input_uV <= 0)
+		return;
+
+	/* calc total requested load */
+	list_for_each_entry(sibling, &rdev->consumer_list, list)
+	    current_uA += sibling->uA_load;
+
+	/* now get the optimum mode for our new total regulator load */
+	mode = rdev->desc->ops->get_optimum_mode(rdev, input_uV,
+						  output_uV, current_uA);
+
+	/* check the new mode is allowed */
+	err = regulator_check_mode(rdev, mode);
+	if (err == 0)
+		rdev->desc->ops->set_mode(rdev, mode);
+}
+
+static int suspend_set_state(struct regulator_dev *rdev,
+	struct regulator_state *rstate)
+{
+	int ret = 0;
+
+	/* enable & disable are mandatory for suspend control */
+	if (!rdev->desc->ops->set_suspend_enable ||
+		!rdev->desc->ops->set_suspend_disable)
+		return -EINVAL;
+
+	if (rstate->enabled)
+		ret = rdev->desc->ops->set_suspend_enable(rdev);
+	else
+		ret = rdev->desc->ops->set_suspend_disable(rdev);
+	if (ret < 0) {
+		printk(KERN_ERR "%s: failed to enabled/disable\n", __func__);
+		return ret;
+	}
+
+	if (rdev->desc->ops->set_suspend_voltage && rstate->uV > 0) {
+		ret = rdev->desc->ops->set_suspend_voltage(rdev, rstate->uV);
+		if (ret < 0) {
+			printk(KERN_ERR "%s: failed to set voltage\n",
+				__func__);
+			return ret;
+		}
+	}
+
+	if (rdev->desc->ops->set_suspend_mode && rstate->mode > 0) {
+		ret = rdev->desc->ops->set_suspend_mode(rdev, rstate->mode);
+		if (ret < 0) {
+			printk(KERN_ERR "%s: failed to set mode\n", __func__);
+			return ret;
+		}
+	}
+	return ret;
+}
+
+/* locks held by caller */
+static int suspend_prepare(struct regulator_dev *rdev, suspend_state_t state)
+{
+	if (!rdev->constraints)
+		return -EINVAL;
+
+	switch (state) {
+	case PM_SUSPEND_STANDBY:
+		return suspend_set_state(rdev,
+			&rdev->constraints->state_standby);
+	case PM_SUSPEND_MEM:
+		return suspend_set_state(rdev,
+			&rdev->constraints->state_mem);
+	case PM_SUSPEND_MAX:
+		return suspend_set_state(rdev,
+			&rdev->constraints->state_disk);
+	default:
+		return -EINVAL;
+	}
+}
+
+static void print_constraints(struct regulator_dev *rdev)
+{
+	struct regulation_constraints *constraints = rdev->constraints;
+	char buf[80];
+	int count;
+
+	if (rdev->desc->type == REGULATOR_VOLTAGE) {
+		if (constraints->min_uV == constraints->max_uV)
+			count = sprintf(buf, "%d mV ",
+					constraints->min_uV / 1000);
+		else
+			count = sprintf(buf, "%d <--> %d mV ",
+					constraints->min_uV / 1000,
+					constraints->max_uV / 1000);
+	} else {
+		if (constraints->min_uA == constraints->max_uA)
+			count = sprintf(buf, "%d mA ",
+					constraints->min_uA / 1000);
+		else
+			count = sprintf(buf, "%d <--> %d mA ",
+					constraints->min_uA / 1000,
+					constraints->max_uA / 1000);
+	}
+	if (constraints->valid_modes_mask & REGULATOR_MODE_FAST)
+		count += sprintf(buf + count, "fast ");
+	if (constraints->valid_modes_mask & REGULATOR_MODE_NORMAL)
+		count += sprintf(buf + count, "normal ");
+	if (constraints->valid_modes_mask & REGULATOR_MODE_IDLE)
+		count += sprintf(buf + count, "idle ");
+	if (constraints->valid_modes_mask & REGULATOR_MODE_STANDBY)
+		count += sprintf(buf + count, "standby");
+
+	printk(KERN_INFO "regulator: %s: %s\n", rdev->desc->name, buf);
+}
+
+#define REG_STR_SIZE	32
+
+static struct regulator *create_regulator(struct regulator_dev *rdev,
+					  struct device *dev,
+					  const char *supply_name)
+{
+	struct regulator *regulator;
+	char buf[REG_STR_SIZE];
+	int err, size;
+
+	regulator = kzalloc(sizeof(*regulator), GFP_KERNEL);
+	if (regulator == NULL)
+		return NULL;
+
+	mutex_lock(&rdev->mutex);
+	regulator->rdev = rdev;
+	list_add(&regulator->list, &rdev->consumer_list);
+
+	if (dev) {
+		/* create a 'requested_microamps_name' sysfs entry */
+		size = scnprintf(buf, REG_STR_SIZE, "microamps_requested_%s",
+			supply_name);
+		if (size >= REG_STR_SIZE)
+			goto overflow_err;
+
+		regulator->dev = dev;
+		regulator->dev_attr.attr.name = kstrdup(buf, GFP_KERNEL);
+		if (regulator->dev_attr.attr.name == NULL)
+			goto attr_name_err;
+
+		regulator->dev_attr.attr.owner = THIS_MODULE;
+		regulator->dev_attr.attr.mode = 0444;
+		regulator->dev_attr.show = device_requested_uA_show;
+		err = device_create_file(dev, &regulator->dev_attr);
+		if (err < 0) {
+			printk(KERN_WARNING "%s: could not add regulator_dev"
+				" load sysfs\n", __func__);
+			goto attr_name_err;
+		}
+
+		/* also add a link to the device sysfs entry */
+		size = scnprintf(buf, REG_STR_SIZE, "%s-%s",
+				 dev->kobj.name, supply_name);
+		if (size >= REG_STR_SIZE)
+			goto attr_err;
+
+		regulator->supply_name = kstrdup(buf, GFP_KERNEL);
+		if (regulator->supply_name == NULL)
+			goto attr_err;
+
+		err = sysfs_create_link(&rdev->dev.kobj, &dev->kobj,
+					buf);
+		if (err) {
+			printk(KERN_WARNING
+			       "%s: could not add device link %s err %d\n",
+			       __func__, dev->kobj.name, err);
+			device_remove_file(dev, &regulator->dev_attr);
+			goto link_name_err;
+		}
+	}
+	mutex_unlock(&rdev->mutex);
+	return regulator;
+link_name_err:
+	kfree(regulator->supply_name);
+attr_err:
+	device_remove_file(regulator->dev, &regulator->dev_attr);
+attr_name_err:
+	kfree(regulator->dev_attr.attr.name);
+overflow_err:
+	list_del(&regulator->list);
+	kfree(regulator);
+	mutex_unlock(&rdev->mutex);
+	return NULL;
+}
+
+/**
+ * regulator_get - lookup and obtain a reference to a regulator.
+ * @dev: device for regulator "consumer"
+ * @id: Supply name or regulator ID.
+ *
+ * Returns a struct regulator corresponding to the regulator producer,
+ * or IS_ERR() condition containing errno.  Use of supply names
+ * configured via regulator_set_device_supply() is strongly
+ * encouraged.
+ */
+struct regulator *regulator_get(struct device *dev, const char *id)
+{
+	struct regulator_dev *rdev;
+	struct regulator_map *map;
+	struct regulator *regulator = ERR_PTR(-ENODEV);
+	const char *supply = id;
+
+	if (id == NULL) {
+		printk(KERN_ERR "regulator: get() with no identifier\n");
+		return regulator;
+	}
+
+	mutex_lock(&regulator_list_mutex);
+
+	list_for_each_entry(map, &regulator_map_list, list) {
+		if (dev == map->dev &&
+		    strcmp(map->supply, id) == 0) {
+			supply = map->regulator;
+			break;
+		}
+	}
+
+	list_for_each_entry(rdev, &regulator_list, list) {
+		if (strcmp(supply, rdev->desc->name) == 0 &&
+		    try_module_get(rdev->owner))
+			goto found;
+	}
+	printk(KERN_ERR "regulator: Unable to get requested regulator: %s\n",
+	       id);
+	mutex_unlock(&regulator_list_mutex);
+	return regulator;
+
+found:
+	regulator = create_regulator(rdev, dev, id);
+	if (regulator == NULL) {
+		regulator = ERR_PTR(-ENOMEM);
+		module_put(rdev->owner);
+	}
+
+	mutex_unlock(&regulator_list_mutex);
+	return regulator;
+}
+EXPORT_SYMBOL_GPL(regulator_get);
+
+/**
+ * regulator_put - "free" the regulator source
+ * @regulator: regulator source
+ *
+ * Note: drivers must ensure that all regulator_enable calls made on this
+ * regulator source are balanced by regulator_disable calls prior to calling
+ * this function.
+ */
+void regulator_put(struct regulator *regulator)
+{
+	struct regulator_dev *rdev;
+
+	if (regulator == NULL || IS_ERR(regulator))
+		return;
+
+	if (regulator->enabled) {
+		printk(KERN_WARNING "Releasing supply %s while enabled\n",
+		       regulator->supply_name);
+		WARN_ON(regulator->enabled);
+		regulator_disable(regulator);
+	}
+
+	mutex_lock(&regulator_list_mutex);
+	rdev = regulator->rdev;
+
+	/* remove any sysfs entries */
+	if (regulator->dev) {
+		sysfs_remove_link(&rdev->dev.kobj, regulator->supply_name);
+		kfree(regulator->supply_name);
+		device_remove_file(regulator->dev, &regulator->dev_attr);
+		kfree(regulator->dev_attr.attr.name);
+	}
+	list_del(&regulator->list);
+	kfree(regulator);
+
+	module_put(rdev->owner);
+	mutex_unlock(&regulator_list_mutex);
+}
+EXPORT_SYMBOL_GPL(regulator_put);
+
+/* locks held by regulator_enable() */
+static int _regulator_enable(struct regulator_dev *rdev)
+{
+	int ret = -EINVAL;
+
+	if (!rdev->constraints) {
+		printk(KERN_ERR "%s: %s has no constraints\n",
+		       __func__, rdev->desc->name);
+		return ret;
+	}
+
+	/* do we need to enable the supply regulator first */
+	if (rdev->supply) {
+		ret = _regulator_enable(rdev->supply);
+		if (ret < 0) {
+			printk(KERN_ERR "%s: failed to enable %s: %d\n",
+			       __func__, rdev->desc->name, ret);
+			return ret;
+		}
+	}
+
+	/* check voltage and requested load before enabling */
+	if (rdev->desc->ops->enable) {
+
+		if (rdev->constraints &&
+			(rdev->constraints->valid_ops_mask &
+			REGULATOR_CHANGE_DRMS))
+			drms_uA_update(rdev);
+
+		ret = rdev->desc->ops->enable(rdev);
+		if (ret < 0) {
+			printk(KERN_ERR "%s: failed to enable %s: %d\n",
+			       __func__, rdev->desc->name, ret);
+			return ret;
+		}
+		rdev->use_count++;
+		return ret;
+	}
+
+	return ret;
+}
+
+/**
+ * regulator_enable - enable regulator output
+ * @regulator: regulator source
+ *
+ * Enable the regulator output at the predefined voltage or current value.
+ * NOTE: the output value can be set by other drivers, boot loader or may be
+ * hardwired in the regulator.
+ * NOTE: calls to regulator_enable() must be balanced with calls to
+ * regulator_disable().
+ */
+int regulator_enable(struct regulator *regulator)
+{
+	int ret;
+
+	if (regulator->enabled) {
+		printk(KERN_CRIT "Regulator %s already enabled\n",
+		       regulator->supply_name);
+		WARN_ON(regulator->enabled);
+		return 0;
+	}
+
+	mutex_lock(&regulator->rdev->mutex);
+	regulator->enabled = 1;
+	ret = _regulator_enable(regulator->rdev);
+	if (ret != 0)
+		regulator->enabled = 0;
+	mutex_unlock(&regulator->rdev->mutex);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(regulator_enable);
+
+/* locks held by regulator_disable() */
+static int _regulator_disable(struct regulator_dev *rdev)
+{
+	int ret = 0;
+
+	/* are we the last user and permitted to disable ? */
+	if (rdev->use_count == 1 && !rdev->constraints->always_on) {
+
+		/* we are last user */
+		if (rdev->desc->ops->disable) {
+			ret = rdev->desc->ops->disable(rdev);
+			if (ret < 0) {
+				printk(KERN_ERR "%s: failed to disable %s\n",
+				       __func__, rdev->desc->name);
+				return ret;
+			}
+		}
+
+		/* decrease our supplies ref count and disable if required */
+		if (rdev->supply)
+			_regulator_disable(rdev->supply);
+
+		rdev->use_count = 0;
+	} else if (rdev->use_count > 1) {
+
+		if (rdev->constraints &&
+			(rdev->constraints->valid_ops_mask &
+			REGULATOR_CHANGE_DRMS))
+			drms_uA_update(rdev);
+
+		rdev->use_count--;
+	}
+	return ret;
+}
+
+/**
+ * regulator_disable - disable regulator output
+ * @regulator: regulator source
+ *
+ * Disable the regulator output voltage or current.
+ * NOTE: this will only disable the regulator output if no other consumer
+ * devices have it enabled.
+ * NOTE: calls to regulator_enable() must be balanced with calls to
+ * regulator_disable().
+ */
+int regulator_disable(struct regulator *regulator)
+{
+	int ret;
+
+	if (!regulator->enabled) {
+		printk(KERN_ERR "%s: not in use by this consumer\n",
+			__func__);
+		return 0;
+	}
+
+	mutex_lock(&regulator->rdev->mutex);
+	regulator->enabled = 0;
+	regulator->uA_load = 0;
+	ret = _regulator_disable(regulator->rdev);
+	mutex_unlock(&regulator->rdev->mutex);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(regulator_disable);
+
+/* locks held by regulator_force_disable() */
+static int _regulator_force_disable(struct regulator_dev *rdev)
+{
+	int ret = 0;
+
+	/* force disable */
+	if (rdev->desc->ops->disable) {
+		/* ah well, who wants to live forever... */
+		ret = rdev->desc->ops->disable(rdev);
+		if (ret < 0) {
+			printk(KERN_ERR "%s: failed to force disable %s\n",
+			       __func__, rdev->desc->name);
+			return ret;
+		}
+		/* notify other consumers that power has been forced off */
+		_notifier_call_chain(rdev, REGULATOR_EVENT_FORCE_DISABLE,
+			NULL);
+	}
+
+	/* decrease our supplies ref count and disable if required */
+	if (rdev->supply)
+		_regulator_disable(rdev->supply);
+
+	rdev->use_count = 0;
+	return ret;
+}
+
+/**
+ * regulator_force_disable - force disable regulator output
+ * @regulator: regulator source
+ *
+ * Forcibly disable the regulator output voltage or current.
+ * NOTE: this *will* disable the regulator output even if other consumer
+ * devices have it enabled. This should be used for situations when device
+ * damage will likely occur if the regulator is not disabled (e.g. over temp).
+ */
+int regulator_force_disable(struct regulator *regulator)
+{
+	int ret;
+
+	mutex_lock(&regulator->rdev->mutex);
+	regulator->enabled = 0;
+	regulator->uA_load = 0;
+	ret = _regulator_force_disable(regulator->rdev);
+	mutex_unlock(&regulator->rdev->mutex);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(regulator_force_disable);
+
+static int _regulator_is_enabled(struct regulator_dev *rdev)
+{
+	int ret;
+
+	mutex_lock(&rdev->mutex);
+
+	/* sanity check */
+	if (!rdev->desc->ops->is_enabled) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	ret = rdev->desc->ops->is_enabled(rdev);
+out:
+	mutex_unlock(&rdev->mutex);
+	return ret;
+}
+
+/**
+ * regulator_is_enabled - is the regulator output enabled
+ * @regulator: regulator source
+ *
+ * Returns zero for disabled otherwise return number of enable requests.
+ */
+int regulator_is_enabled(struct regulator *regulator)
+{
+	return _regulator_is_enabled(regulator->rdev);
+}
+EXPORT_SYMBOL_GPL(regulator_is_enabled);
+
+/**
+ * regulator_set_voltage - set regulator output voltage
+ * @regulator: regulator source
+ * @min_uV: Minimum required voltage in uV
+ * @max_uV: Maximum acceptable voltage in uV
+ *
+ * Sets a voltage regulator to the desired output voltage. This can be set
+ * during any regulator state. IOW, regulator can be disabled or enabled.
+ *
+ * If the regulator is enabled then the voltage will change to the new value
+ * immediately otherwise if the regulator is disabled the regulator will
+ * output at the new voltage when enabled.
+ *
+ * NOTE: If the regulator is shared between several devices then the lowest
+ * request voltage that meets the system constraints will be used.
+ * NOTE: Regulator system constraints must be set for this regulator before
+ * calling this function otherwise this call will fail.
+ */
+int regulator_set_voltage(struct regulator *regulator, int min_uV, int max_uV)
+{
+	struct regulator_dev *rdev = regulator->rdev;
+	int ret;
+
+	mutex_lock(&rdev->mutex);
+
+	/* sanity check */
+	if (!rdev->desc->ops->set_voltage) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	/* constraints check */
+	ret = regulator_check_voltage(rdev, &min_uV, &max_uV);
+	if (ret < 0)
+		goto out;
+	regulator->min_uV = min_uV;
+	regulator->max_uV = max_uV;
+	ret = rdev->desc->ops->set_voltage(rdev, min_uV, max_uV);
+
+out:
+	mutex_unlock(&rdev->mutex);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(regulator_set_voltage);
+
+static int _regulator_get_voltage(struct regulator_dev *rdev)
+{
+	/* sanity check */
+	if (rdev->desc->ops->get_voltage)
+		return rdev->desc->ops->get_voltage(rdev);
+	else
+		return -EINVAL;
+}
+
+/**
+ * regulator_get_voltage - get regulator output voltage
+ * @regulator: regulator source
+ *
+ * This returns the current regulator voltage in uV.
+ *
+ * NOTE: If the regulator is disabled it will return the voltage value. This
+ * function should not be used to determine regulator state.
+ */
+int regulator_get_voltage(struct regulator *regulator)
+{
+	int ret;
+
+	mutex_lock(&regulator->rdev->mutex);
+
+	ret = _regulator_get_voltage(regulator->rdev);
+
+	mutex_unlock(&regulator->rdev->mutex);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(regulator_get_voltage);
+
+/**
+ * regulator_set_current_limit - set regulator output current limit
+ * @regulator: regulator source
+ * @min_uA: Minimuum supported current in uA
+ * @max_uA: Maximum supported current in uA
+ *
+ * Sets current sink to the desired output current. This can be set during
+ * any regulator state. IOW, regulator can be disabled or enabled.
+ *
+ * If the regulator is enabled then the current will change to the new value
+ * immediately otherwise if the regulator is disabled the regulator will
+ * output at the new current when enabled.
+ *
+ * NOTE: Regulator system constraints must be set for this regulator before
+ * calling this function otherwise this call will fail.
+ */
+int regulator_set_current_limit(struct regulator *regulator,
+			       int min_uA, int max_uA)
+{
+	struct regulator_dev *rdev = regulator->rdev;
+	int ret;
+
+	mutex_lock(&rdev->mutex);
+
+	/* sanity check */
+	if (!rdev->desc->ops->set_current_limit) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	/* constraints check */
+	ret = regulator_check_current_limit(rdev, &min_uA, &max_uA);
+	if (ret < 0)
+		goto out;
+
+	ret = rdev->desc->ops->set_current_limit(rdev, min_uA, max_uA);
+out:
+	mutex_unlock(&rdev->mutex);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(regulator_set_current_limit);
+
+static int _regulator_get_current_limit(struct regulator_dev *rdev)
+{
+	int ret;
+
+	mutex_lock(&rdev->mutex);
+
+	/* sanity check */
+	if (!rdev->desc->ops->get_current_limit) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	ret = rdev->desc->ops->get_current_limit(rdev);
+out:
+	mutex_unlock(&rdev->mutex);
+	return ret;
+}
+
+/**
+ * regulator_get_current_limit - get regulator output current
+ * @regulator: regulator source
+ *
+ * This returns the current supplied by the specified current sink in uA.
+ *
+ * NOTE: If the regulator is disabled it will return the current value. This
+ * function should not be used to determine regulator state.
+ */
+int regulator_get_current_limit(struct regulator *regulator)
+{
+	return _regulator_get_current_limit(regulator->rdev);
+}
+EXPORT_SYMBOL_GPL(regulator_get_current_limit);
+
+/**
+ * regulator_set_mode - set regulator operating mode
+ * @regulator: regulator source
+ * @mode: operating mode - one of the REGULATOR_MODE constants
+ *
+ * Set regulator operating mode to increase regulator efficiency or improve
+ * regulation performance.
+ *
+ * NOTE: Regulator system constraints must be set for this regulator before
+ * calling this function otherwise this call will fail.
+ */
+int regulator_set_mode(struct regulator *regulator, unsigned int mode)
+{
+	struct regulator_dev *rdev = regulator->rdev;
+	int ret;
+
+	mutex_lock(&rdev->mutex);
+
+	/* sanity check */
+	if (!rdev->desc->ops->set_mode) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	/* constraints check */
+	ret = regulator_check_mode(rdev, mode);
+	if (ret < 0)
+		goto out;
+
+	ret = rdev->desc->ops->set_mode(rdev, mode);
+out:
+	mutex_unlock(&rdev->mutex);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(regulator_set_mode);
+
+static unsigned int _regulator_get_mode(struct regulator_dev *rdev)
+{
+	int ret;
+
+	mutex_lock(&rdev->mutex);
+
+	/* sanity check */
+	if (!rdev->desc->ops->get_mode) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	ret = rdev->desc->ops->get_mode(rdev);
+out:
+	mutex_unlock(&rdev->mutex);
+	return ret;
+}
+
+/**
+ * regulator_get_mode - get regulator operating mode
+ * @regulator: regulator source
+ *
+ * Get the current regulator operating mode.
+ */
+unsigned int regulator_get_mode(struct regulator *regulator)
+{
+	return _regulator_get_mode(regulator->rdev);
+}
+EXPORT_SYMBOL_GPL(regulator_get_mode);
+
+/**
+ * regulator_set_optimum_mode - set regulator optimum operating mode
+ * @regulator: regulator source
+ * @uA_load: load current
+ *
+ * Notifies the regulator core of a new device load. This is then used by
+ * DRMS (if enabled by constraints) to set the most efficient regulator
+ * operating mode for the new regulator loading.
+ *
+ * Consumer devices notify their supply regulator of the maximum power
+ * they will require (can be taken from device datasheet in the power
+ * consumption tables) when they change operational status and hence power
+ * state. Examples of operational state changes that can affect power
+ * consumption are :-
+ *
+ *    o Device is opened / closed.
+ *    o Device I/O is about to begin or has just finished.
+ *    o Device is idling in between work.
+ *
+ * This information is also exported via sysfs to userspace.
+ *
+ * DRMS will sum the total requested load on the regulator and change
+ * to the most efficient operating mode if platform constraints allow.
+ *
+ * Returns the new regulator mode or error.
+ */
+int regulator_set_optimum_mode(struct regulator *regulator, int uA_load)
+{
+	struct regulator_dev *rdev = regulator->rdev;
+	struct regulator *consumer;
+	int ret, output_uV, input_uV, total_uA_load = 0;
+	unsigned int mode;
+
+	mutex_lock(&rdev->mutex);
+
+	regulator->uA_load = uA_load;
+	ret = regulator_check_drms(rdev);
+	if (ret < 0)
+		goto out;
+	ret = -EINVAL;
+
+	/* sanity check */
+	if (!rdev->desc->ops->get_optimum_mode)
+		goto out;
+
+	/* get output voltage */
+	output_uV = rdev->desc->ops->get_voltage(rdev);
+	if (output_uV <= 0) {
+		printk(KERN_ERR "%s: invalid output voltage found for %s\n",
+			__func__, rdev->desc->name);
+		goto out;
+	}
+
+	/* get input voltage */
+	if (rdev->supply && rdev->supply->desc->ops->get_voltage)
+		input_uV = rdev->supply->desc->ops->get_voltage(rdev->supply);
+	else
+		input_uV = rdev->constraints->input_uV;
+	if (input_uV <= 0) {
+		printk(KERN_ERR "%s: invalid input voltage found for %s\n",
+			__func__, rdev->desc->name);
+		goto out;
+	}
+
+	/* calc total requested load for this regulator */
+	list_for_each_entry(consumer, &rdev->consumer_list, list)
+	    total_uA_load += consumer->uA_load;
+
+	mode = rdev->desc->ops->get_optimum_mode(rdev,
+						 input_uV, output_uV,
+						 total_uA_load);
+	if (ret <= 0) {
+		printk(KERN_ERR "%s: failed to get optimum mode for %s @"
+			" %d uA %d -> %d uV\n", __func__, rdev->desc->name,
+			total_uA_load, input_uV, output_uV);
+		goto out;
+	}
+
+	ret = rdev->desc->ops->set_mode(rdev, mode);
+	if (ret <= 0) {
+		printk(KERN_ERR "%s: failed to set optimum mode %x for %s\n",
+			__func__, mode, rdev->desc->name);
+		goto out;
+	}
+	ret = mode;
+out:
+	mutex_unlock(&rdev->mutex);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(regulator_set_optimum_mode);
+
+/**
+ * regulator_register_notifier - register regulator event notifier
+ * @regulator: regulator source
+ * @notifier_block: notifier block
+ *
+ * Register notifier block to receive regulator events.
+ */
+int regulator_register_notifier(struct regulator *regulator,
+			      struct notifier_block *nb)
+{
+	return blocking_notifier_chain_register(&regulator->rdev->notifier,
+						nb);
+}
+EXPORT_SYMBOL_GPL(regulator_register_notifier);
+
+/**
+ * regulator_unregister_notifier - unregister regulator event notifier
+ * @regulator: regulator source
+ * @notifier_block: notifier block
+ *
+ * Unregister regulator event notifier block.
+ */
+int regulator_unregister_notifier(struct regulator *regulator,
+				struct notifier_block *nb)
+{
+	return blocking_notifier_chain_unregister(&regulator->rdev->notifier,
+						  nb);
+}
+EXPORT_SYMBOL_GPL(regulator_unregister_notifier);
+
+/* notify regulator consumers and downstream regulator consumers */
+static void _notifier_call_chain(struct regulator_dev *rdev,
+				  unsigned long event, void *data)
+{
+	struct regulator_dev *_rdev;
+
+	/* call rdev chain first */
+	mutex_lock(&rdev->mutex);
+	blocking_notifier_call_chain(&rdev->notifier, event, NULL);
+	mutex_unlock(&rdev->mutex);
+
+	/* now notify regulator we supply */
+	list_for_each_entry(_rdev, &rdev->supply_list, slist)
+		_notifier_call_chain(_rdev, event, data);
+}
+
+/**
+ * regulator_bulk_get - get multiple regulator consumers
+ *
+ * @dev:           Device to supply
+ * @num_consumers: Number of consumers to register
+ * @consumers:     Configuration of consumers; clients are stored here.
+ *
+ * @return 0 on success, an errno on failure.
+ *
+ * This helper function allows drivers to get several regulator
+ * consumers in one operation.  If any of the regulators cannot be
+ * acquired then any regulators that were allocated will be freed
+ * before returning to the caller.
+ */
+int regulator_bulk_get(struct device *dev, int num_consumers,
+		       struct regulator_bulk_data *consumers)
+{
+	int i;
+	int ret;
+
+	for (i = 0; i < num_consumers; i++)
+		consumers[i].consumer = NULL;
+
+	for (i = 0; i < num_consumers; i++) {
+		consumers[i].consumer = regulator_get(dev,
+						      consumers[i].supply);
+		if (IS_ERR(consumers[i].consumer)) {
+			dev_err(dev, "Failed to get supply '%s'\n",
+				consumers[i].supply);
+			ret = PTR_ERR(consumers[i].consumer);
+			consumers[i].consumer = NULL;
+			goto err;
+		}
+	}
+
+	return 0;
+
+err:
+	for (i = 0; i < num_consumers && consumers[i].consumer; i++)
+		regulator_put(consumers[i].consumer);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(regulator_bulk_get);
+
+/**
+ * regulator_bulk_enable - enable multiple regulator consumers
+ *
+ * @num_consumers: Number of consumers
+ * @consumers:     Consumer data; clients are stored here.
+ * @return         0 on success, an errno on failure
+ *
+ * This convenience API allows consumers to enable multiple regulator
+ * clients in a single API call.  If any consumers cannot be enabled
+ * then any others that were enabled will be disabled again prior to
+ * return.
+ */
+int regulator_bulk_enable(int num_consumers,
+			  struct regulator_bulk_data *consumers)
+{
+	int i;
+	int ret;
+
+	for (i = 0; i < num_consumers; i++) {
+		ret = regulator_enable(consumers[i].consumer);
+		if (ret != 0)
+			goto err;
+	}
+
+	return 0;
+
+err:
+	printk(KERN_ERR "Failed to enable %s\n", consumers[i].supply);
+	for (i = 0; i < num_consumers; i++)
+		regulator_disable(consumers[i].consumer);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(regulator_bulk_enable);
+
+/**
+ * regulator_bulk_disable - disable multiple regulator consumers
+ *
+ * @num_consumers: Number of consumers
+ * @consumers:     Consumer data; clients are stored here.
+ * @return         0 on success, an errno on failure
+ *
+ * This convenience API allows consumers to disable multiple regulator
+ * clients in a single API call.  If any consumers cannot be enabled
+ * then any others that were disabled will be disabled again prior to
+ * return.
+ */
+int regulator_bulk_disable(int num_consumers,
+			   struct regulator_bulk_data *consumers)
+{
+	int i;
+	int ret;
+
+	for (i = 0; i < num_consumers; i++) {
+		ret = regulator_disable(consumers[i].consumer);
+		if (ret != 0)
+			goto err;
+	}
+
+	return 0;
+
+err:
+	printk(KERN_ERR "Failed to disable %s\n", consumers[i].supply);
+	for (i = 0; i < num_consumers; i++)
+		regulator_enable(consumers[i].consumer);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(regulator_bulk_disable);
+
+/**
+ * regulator_bulk_free - free multiple regulator consumers
+ *
+ * @num_consumers: Number of consumers
+ * @consumers:     Consumer data; clients are stored here.
+ *
+ * This convenience API allows consumers to free multiple regulator
+ * clients in a single API call.
+ */
+void regulator_bulk_free(int num_consumers,
+			 struct regulator_bulk_data *consumers)
+{
+	int i;
+
+	for (i = 0; i < num_consumers; i++) {
+		regulator_put(consumers[i].consumer);
+		consumers[i].consumer = NULL;
+	}
+}
+EXPORT_SYMBOL_GPL(regulator_bulk_free);
+
+/**
+ * regulator_notifier_call_chain - call regulator event notifier
+ * @regulator: regulator source
+ * @event: notifier block
+ * @data:
+ *
+ * Called by regulator drivers to notify clients a regulator event has
+ * occurred. We also notify regulator clients downstream.
+ */
+int regulator_notifier_call_chain(struct regulator_dev *rdev,
+				  unsigned long event, void *data)
+{
+	_notifier_call_chain(rdev, event, data);
+	return NOTIFY_DONE;
+
+}
+EXPORT_SYMBOL_GPL(regulator_notifier_call_chain);
+
+/**
+ * regulator_register - register regulator
+ * @regulator: regulator source
+ * @reg_data: private regulator data
+ *
+ * Called by regulator drivers to register a regulator.
+ * Returns 0 on success.
+ */
+struct regulator_dev *regulator_register(struct regulator_desc *regulator_desc,
+					  void *reg_data)
+{
+	static atomic_t regulator_no = ATOMIC_INIT(0);
+	struct regulator_dev *rdev;
+	int ret;
+
+	if (regulator_desc == NULL)
+		return ERR_PTR(-EINVAL);
+
+	if (regulator_desc->name == NULL || regulator_desc->ops == NULL)
+		return ERR_PTR(-EINVAL);
+
+	if (!regulator_desc->type == REGULATOR_VOLTAGE &&
+	    !regulator_desc->type == REGULATOR_CURRENT)
+		return ERR_PTR(-EINVAL);
+
+	rdev = kzalloc(sizeof(struct regulator_dev), GFP_KERNEL);
+	if (rdev == NULL)
+		return ERR_PTR(-ENOMEM);
+
+	mutex_lock(&regulator_list_mutex);
+
+	mutex_init(&rdev->mutex);
+	rdev->reg_data = reg_data;
+	rdev->owner = regulator_desc->owner;
+	rdev->desc = regulator_desc;
+	INIT_LIST_HEAD(&rdev->consumer_list);
+	INIT_LIST_HEAD(&rdev->supply_list);
+	INIT_LIST_HEAD(&rdev->list);
+	INIT_LIST_HEAD(&rdev->slist);
+	BLOCKING_INIT_NOTIFIER_HEAD(&rdev->notifier);
+
+	rdev->dev.class = &regulator_class;
+	device_initialize(&rdev->dev);
+	snprintf(rdev->dev.bus_id, sizeof(rdev->dev.bus_id),
+		 "regulator_%ld_%s",
+		 (unsigned long)atomic_inc_return(&regulator_no) - 1,
+		 regulator_desc->name);
+
+	ret = device_add(&rdev->dev);
+	if (ret == 0)
+		list_add(&rdev->list, &regulator_list);
+	else {
+		kfree(rdev);
+		rdev = ERR_PTR(ret);
+	}
+	mutex_unlock(&regulator_list_mutex);
+	return rdev;
+}
+EXPORT_SYMBOL_GPL(regulator_register);
+
+/**
+ * regulator_unregister - unregister regulator
+ * @regulator: regulator source
+ *
+ * Called by regulator drivers to unregister a regulator.
+ */
+void regulator_unregister(struct regulator_dev *rdev)
+{
+	if (rdev == NULL)
+		return;
+
+	mutex_lock(&regulator_list_mutex);
+	list_del(&rdev->list);
+	if (rdev->supply)
+		sysfs_remove_link(&rdev->dev.kobj, "supply");
+	device_unregister(&rdev->dev);
+	mutex_unlock(&regulator_list_mutex);
+}
+EXPORT_SYMBOL_GPL(regulator_unregister);
+
+/**
+ * regulator_set_supply - set regulator supply regulator
+ * @regulator: regulator name
+ * @supply: supply regulator name
+ *
+ * Called by platform initialisation code to set the supply regulator for this
+ * regulator. This ensures that a regulators supply will also be enabled by the
+ * core if it's child is enabled.
+ */
+int regulator_set_supply(const char *regulator, const char *supply)
+{
+	struct regulator_dev *rdev, *supply_rdev;
+	int err;
+
+	if (regulator == NULL || supply == NULL)
+		return -EINVAL;
+
+	mutex_lock(&regulator_list_mutex);
+
+	list_for_each_entry(rdev, &regulator_list, list) {
+		if (!strcmp(rdev->desc->name, regulator))
+			goto found_regulator;
+	}
+	mutex_unlock(&regulator_list_mutex);
+	return -ENODEV;
+
+found_regulator:
+	list_for_each_entry(supply_rdev, &regulator_list, list) {
+		if (!strcmp(supply_rdev->desc->name, supply))
+			goto found_supply;
+	}
+	mutex_unlock(&regulator_list_mutex);
+	return -ENODEV;
+
+found_supply:
+	err = sysfs_create_link(&rdev->dev.kobj, &supply_rdev->dev.kobj,
+				"supply");
+	if (err) {
+		printk(KERN_ERR
+		       "%s: could not add device link %s err %d\n",
+		       __func__, supply_rdev->dev.kobj.name, err);
+		       goto out;
+	}
+	rdev->supply = supply_rdev;
+	list_add(&rdev->slist, &supply_rdev->supply_list);
+out:
+	mutex_unlock(&regulator_list_mutex);
+	return err;
+}
+EXPORT_SYMBOL_GPL(regulator_set_supply);
+
+/**
+ * regulator_get_supply - get regulator supply regulator
+ * @regulator: regulator name
+ *
+ * Returns the supply supply regulator name or NULL if no supply regulator
+ * exists (i.e the regulator is supplied directly from USB, Line, Battery, etc)
+ */
+const char *regulator_get_supply(const char *regulator)
+{
+	struct regulator_dev *rdev;
+
+	if (regulator == NULL)
+		return NULL;
+
+	mutex_lock(&regulator_list_mutex);
+	list_for_each_entry(rdev, &regulator_list, list) {
+		if (!strcmp(rdev->desc->name, regulator))
+			goto found;
+	}
+	mutex_unlock(&regulator_list_mutex);
+	return NULL;
+
+found:
+	mutex_unlock(&regulator_list_mutex);
+	if (rdev->supply)
+		return rdev->supply->desc->name;
+	else
+		return NULL;
+}
+EXPORT_SYMBOL_GPL(regulator_get_supply);
+
+/**
+ * regulator_set_machine_constraints - sets regulator constraints
+ * @regulator: regulator source
+ *
+ * Allows platform initialisation code to define and constrain
+ * regulator circuits e.g. valid voltage/current ranges, etc.  NOTE:
+ * Constraints *must* be set by platform code in order for some
+ * regulator operations to proceed i.e. set_voltage, set_current_limit,
+ * set_mode.
+ */
+int regulator_set_machine_constraints(const char *regulator_name,
+	struct regulation_constraints *constraints)
+{
+	struct regulator_dev *rdev;
+	int ret = 0;
+
+	if (regulator_name == NULL)
+		return -EINVAL;
+
+	mutex_lock(&regulator_list_mutex);
+
+	list_for_each_entry(rdev, &regulator_list, list) {
+		if (!strcmp(regulator_name, rdev->desc->name))
+			goto found;
+	}
+	ret = -ENODEV;
+	goto out;
+
+found:
+	mutex_lock(&rdev->mutex);
+	rdev->constraints = constraints;
+
+	/* do we need to apply the constraint voltage */
+	if (rdev->constraints->apply_uV &&
+		rdev->constraints->min_uV == rdev->constraints->max_uV &&
+		rdev->desc->ops->set_voltage) {
+		ret = rdev->desc->ops->set_voltage(rdev,
+			rdev->constraints->min_uV, rdev->constraints->max_uV);
+			if (ret < 0) {
+				printk(KERN_ERR "%s: failed to apply %duV"
+					" constraint\n", __func__,
+					rdev->constraints->min_uV);
+				rdev->constraints = NULL;
+				goto out;
+			}
+	}
+
+	/* are we enabled at boot time by firmware / bootloader */
+	if (rdev->constraints->boot_on)
+		rdev->use_count = 1;
+
+	/* do we need to setup our suspend state */
+	if (constraints->initial_state)
+		ret = suspend_prepare(rdev, constraints->initial_state);
+
+	print_constraints(rdev);
+	mutex_unlock(&rdev->mutex);
+
+out:
+	mutex_unlock(&regulator_list_mutex);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(regulator_set_machine_constraints);
+
+
+/**
+ * regulator_set_device_supply: Bind a regulator to a symbolic supply
+ * @regulator: regulator source
+ * @dev:       device the supply applies to
+ * @supply:    symbolic name for supply
+ *
+ * Allows platform initialisation code to map physical regulator
+ * sources to symbolic names for supplies for use by devices.  Devices
+ * should use these symbolic names to request regulators, avoiding the
+ * need to provide board-specific regulator names as platform data.
+ */
+int regulator_set_device_supply(const char *regulator, struct device *dev,
+				const char *supply)
+{
+	struct regulator_map *node;
+
+	if (regulator == NULL || supply == NULL)
+		return -EINVAL;
+
+	node = kmalloc(sizeof(struct regulator_map), GFP_KERNEL);
+	if (node == NULL)
+		return -ENOMEM;
+
+	node->regulator = regulator;
+	node->dev = dev;
+	node->supply = supply;
+
+	mutex_lock(&regulator_list_mutex);
+	list_add(&node->list, &regulator_map_list);
+	mutex_unlock(&regulator_list_mutex);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(regulator_set_device_supply);
+
+/**
+ * regulator_suspend_prepare: prepare regulators for system wide suspend
+ * @state: system suspend state
+ *
+ * Configure each regulator with it's suspend operating parameters for state.
+ * This will usually be called by machine suspend code prior to supending.
+ */
+int regulator_suspend_prepare(suspend_state_t state)
+{
+	struct regulator_dev *rdev;
+	int ret = 0;
+
+	/* ON is handled by regulator active state */
+	if (state == PM_SUSPEND_ON)
+		return -EINVAL;
+
+	mutex_lock(&regulator_list_mutex);
+	list_for_each_entry(rdev, &regulator_list, list) {
+
+		mutex_lock(&rdev->mutex);
+		ret = suspend_prepare(rdev, state);
+		mutex_unlock(&rdev->mutex);
+
+		if (ret < 0) {
+			printk(KERN_ERR "%s: failed to prepare %s\n",
+				__func__, rdev->desc->name);
+			goto out;
+		}
+	}
+out:
+	mutex_unlock(&regulator_list_mutex);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(regulator_suspend_prepare);
+
+/**
+ * rdev_get_drvdata - get rdev regulator driver data
+ * @regulator: regulator
+ *
+ * Get rdev regulator driver private data. This call can be used in the
+ * regulator driver context.
+ */
+void *rdev_get_drvdata(struct regulator_dev *rdev)
+{
+	return rdev->reg_data;
+}
+EXPORT_SYMBOL_GPL(rdev_get_drvdata);
+
+/**
+ * regulator_get_drvdata - get regulator driver data
+ * @regulator: regulator
+ *
+ * Get regulator driver private data. This call can be used in the consumer
+ * driver context when non API regulator specific functions need to be called.
+ */
+void *regulator_get_drvdata(struct regulator *regulator)
+{
+	return regulator->rdev->reg_data;
+}
+EXPORT_SYMBOL_GPL(regulator_get_drvdata);
+
+/**
+ * regulator_set_drvdata - set regulator driver data
+ * @regulator: regulator
+ * @data: data
+ */
+void regulator_set_drvdata(struct regulator *regulator, void *data)
+{
+	regulator->rdev->reg_data = data;
+}
+EXPORT_SYMBOL_GPL(regulator_set_drvdata);
+
+/**
+ * regulator_get_id - get regulator ID
+ * @regulator: regulator
+ */
+int rdev_get_id(struct regulator_dev *rdev)
+{
+	return rdev->desc->id;
+}
+EXPORT_SYMBOL_GPL(rdev_get_id);
+
+static int __init regulator_init(void)
+{
+	printk(KERN_INFO "regulator: core version %s\n", REGULATOR_VERSION);
+	return class_register(&regulator_class);
+}
+
+/* init early to allow our consumers to complete system booting */
+core_initcall(regulator_init);
