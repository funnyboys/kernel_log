commit 6af4ea0ba708172be8caf1ba5047b2b8a9d2fea3
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Jul 19 16:10:36 2013 +0400

    oprofilefs_create_...() do not need superblock argument
    
    same story as with oprofilefs_mkdir()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/oprofile/oprofile_stats.c b/drivers/oprofile/oprofile_stats.c
index 8cf2fa9710a4..59659cea4582 100644
--- a/drivers/oprofile/oprofile_stats.c
+++ b/drivers/oprofile/oprofile_stats.c
@@ -59,26 +59,26 @@ void oprofile_create_stats_files(struct dentry *root)
 		 * but we can't simply lock them, and they are
 		 * informational only.
 		 */
-		oprofilefs_create_ro_ulong(root->d_sb, cpudir, "sample_received",
+		oprofilefs_create_ro_ulong(cpudir, "sample_received",
 			&cpu_buf->sample_received);
-		oprofilefs_create_ro_ulong(root->d_sb, cpudir, "sample_lost_overflow",
+		oprofilefs_create_ro_ulong(cpudir, "sample_lost_overflow",
 			&cpu_buf->sample_lost_overflow);
-		oprofilefs_create_ro_ulong(root->d_sb, cpudir, "backtrace_aborted",
+		oprofilefs_create_ro_ulong(cpudir, "backtrace_aborted",
 			&cpu_buf->backtrace_aborted);
-		oprofilefs_create_ro_ulong(root->d_sb, cpudir, "sample_invalid_eip",
+		oprofilefs_create_ro_ulong(cpudir, "sample_invalid_eip",
 			&cpu_buf->sample_invalid_eip);
 	}
 
-	oprofilefs_create_ro_atomic(root->d_sb, dir, "sample_lost_no_mm",
+	oprofilefs_create_ro_atomic(dir, "sample_lost_no_mm",
 		&oprofile_stats.sample_lost_no_mm);
-	oprofilefs_create_ro_atomic(root->d_sb, dir, "sample_lost_no_mapping",
+	oprofilefs_create_ro_atomic(dir, "sample_lost_no_mapping",
 		&oprofile_stats.sample_lost_no_mapping);
-	oprofilefs_create_ro_atomic(root->d_sb, dir, "event_lost_overflow",
+	oprofilefs_create_ro_atomic(dir, "event_lost_overflow",
 		&oprofile_stats.event_lost_overflow);
-	oprofilefs_create_ro_atomic(root->d_sb, dir, "bt_lost_no_mapping",
+	oprofilefs_create_ro_atomic(dir, "bt_lost_no_mapping",
 		&oprofile_stats.bt_lost_no_mapping);
 #ifdef CONFIG_OPROFILE_EVENT_MULTIPLEX
-	oprofilefs_create_ro_atomic(root->d_sb, dir, "multiplex_counter",
+	oprofilefs_create_ro_atomic(dir, "multiplex_counter",
 		&oprofile_stats.multiplex_counter);
 #endif
 }

commit ecde28237e10de3750a97579f42bc2ec65b8a0e1
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Jul 19 15:58:27 2013 +0400

    oprofilefs_mkdir() doesn't need superblock argument
    
    it's always equal to ->d_sb of the second argument (parent dentry),
    due to either being literally that, or ->d_sb of parent's parent.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/oprofile/oprofile_stats.c b/drivers/oprofile/oprofile_stats.c
index 627dce478311..8cf2fa9710a4 100644
--- a/drivers/oprofile/oprofile_stats.c
+++ b/drivers/oprofile/oprofile_stats.c
@@ -46,14 +46,14 @@ void oprofile_create_stats_files(struct dentry *root)
 	char buf[10];
 	int i;
 
-	dir = oprofilefs_mkdir(root->d_sb, root, "stats");
+	dir = oprofilefs_mkdir(root, "stats");
 	if (!dir)
 		return;
 
 	for_each_possible_cpu(i) {
 		cpu_buf = &per_cpu(op_cpu_buffer, i);
 		snprintf(buf, 10, "cpu%d", i);
-		cpudir = oprofilefs_mkdir(root->d_sb, dir, buf);
+		cpudir = oprofilefs_mkdir(dir, buf);
 
 		/* Strictly speaking access to these ulongs is racy,
 		 * but we can't simply lock them, and they are

commit 40437c718a69562bafaf9e5c9d17b6628e2576b1
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Jul 19 15:54:56 2013 +0400

    don't bother with passing superblock to oprofile_create_stats_files()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/oprofile/oprofile_stats.c b/drivers/oprofile/oprofile_stats.c
index 917d28ebeacd..627dce478311 100644
--- a/drivers/oprofile/oprofile_stats.c
+++ b/drivers/oprofile/oprofile_stats.c
@@ -38,7 +38,7 @@ void oprofile_reset_stats(void)
 }
 
 
-void oprofile_create_stats_files(struct super_block *sb, struct dentry *root)
+void oprofile_create_stats_files(struct dentry *root)
 {
 	struct oprofile_cpu_buffer *cpu_buf;
 	struct dentry *cpudir;
@@ -46,39 +46,39 @@ void oprofile_create_stats_files(struct super_block *sb, struct dentry *root)
 	char buf[10];
 	int i;
 
-	dir = oprofilefs_mkdir(sb, root, "stats");
+	dir = oprofilefs_mkdir(root->d_sb, root, "stats");
 	if (!dir)
 		return;
 
 	for_each_possible_cpu(i) {
 		cpu_buf = &per_cpu(op_cpu_buffer, i);
 		snprintf(buf, 10, "cpu%d", i);
-		cpudir = oprofilefs_mkdir(sb, dir, buf);
+		cpudir = oprofilefs_mkdir(root->d_sb, dir, buf);
 
 		/* Strictly speaking access to these ulongs is racy,
 		 * but we can't simply lock them, and they are
 		 * informational only.
 		 */
-		oprofilefs_create_ro_ulong(sb, cpudir, "sample_received",
+		oprofilefs_create_ro_ulong(root->d_sb, cpudir, "sample_received",
 			&cpu_buf->sample_received);
-		oprofilefs_create_ro_ulong(sb, cpudir, "sample_lost_overflow",
+		oprofilefs_create_ro_ulong(root->d_sb, cpudir, "sample_lost_overflow",
 			&cpu_buf->sample_lost_overflow);
-		oprofilefs_create_ro_ulong(sb, cpudir, "backtrace_aborted",
+		oprofilefs_create_ro_ulong(root->d_sb, cpudir, "backtrace_aborted",
 			&cpu_buf->backtrace_aborted);
-		oprofilefs_create_ro_ulong(sb, cpudir, "sample_invalid_eip",
+		oprofilefs_create_ro_ulong(root->d_sb, cpudir, "sample_invalid_eip",
 			&cpu_buf->sample_invalid_eip);
 	}
 
-	oprofilefs_create_ro_atomic(sb, dir, "sample_lost_no_mm",
+	oprofilefs_create_ro_atomic(root->d_sb, dir, "sample_lost_no_mm",
 		&oprofile_stats.sample_lost_no_mm);
-	oprofilefs_create_ro_atomic(sb, dir, "sample_lost_no_mapping",
+	oprofilefs_create_ro_atomic(root->d_sb, dir, "sample_lost_no_mapping",
 		&oprofile_stats.sample_lost_no_mapping);
-	oprofilefs_create_ro_atomic(sb, dir, "event_lost_overflow",
+	oprofilefs_create_ro_atomic(root->d_sb, dir, "event_lost_overflow",
 		&oprofile_stats.event_lost_overflow);
-	oprofilefs_create_ro_atomic(sb, dir, "bt_lost_no_mapping",
+	oprofilefs_create_ro_atomic(root->d_sb, dir, "bt_lost_no_mapping",
 		&oprofile_stats.bt_lost_no_mapping);
 #ifdef CONFIG_OPROFILE_EVENT_MULTIPLEX
-	oprofilefs_create_ro_atomic(sb, dir, "multiplex_counter",
+	oprofilefs_create_ro_atomic(root->d_sb, dir, "multiplex_counter",
 		&oprofile_stats.multiplex_counter);
 #endif
 }

commit b3e9f672b6cd0f4c2982c1bcc0b3c3fb39d3b0fe
Author: Tejun Heo <tj@kernel.org>
Date:   Thu Oct 29 22:34:13 2009 +0900

    percpu: make percpu symbols in oprofile unique
    
    This patch updates percpu related symbols in oprofile such that percpu
    symbols are unique and don't clash with local symbols.  This serves
    two purposes of decreasing the possibility of global percpu symbol
    collision and allowing dropping per_cpu__ prefix from percpu symbols.
    
    * drivers/oprofile/cpu_buffer.c: s/cpu_buffer/op_cpu_buffer/
    
    Partly based on Rusty Russell's "alloc_percpu: rename percpu vars
    which cause name clashes" patch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Acked-by: Robert Richter <robert.richter@amd.com>
    Cc: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/drivers/oprofile/oprofile_stats.c b/drivers/oprofile/oprofile_stats.c
index 61689e814d46..917d28ebeacd 100644
--- a/drivers/oprofile/oprofile_stats.c
+++ b/drivers/oprofile/oprofile_stats.c
@@ -23,7 +23,7 @@ void oprofile_reset_stats(void)
 	int i;
 
 	for_each_possible_cpu(i) {
-		cpu_buf = &per_cpu(cpu_buffer, i);
+		cpu_buf = &per_cpu(op_cpu_buffer, i);
 		cpu_buf->sample_received = 0;
 		cpu_buf->sample_lost_overflow = 0;
 		cpu_buf->backtrace_aborted = 0;
@@ -51,7 +51,7 @@ void oprofile_create_stats_files(struct super_block *sb, struct dentry *root)
 		return;
 
 	for_each_possible_cpu(i) {
-		cpu_buf = &per_cpu(cpu_buffer, i);
+		cpu_buf = &per_cpu(op_cpu_buffer, i);
 		snprintf(buf, 10, "cpu%d", i);
 		cpudir = oprofilefs_mkdir(sb, dir, buf);
 

commit 1b294f5960cd89e49eeb3e797860c552b03f2272
Author: Robert Richter <robert.richter@amd.com>
Date:   Thu Jul 9 14:56:25 2009 +0200

    oprofile: Adding switch counter to oprofile statistic variables
    
    This patch moves the multiplexing switch counter from x86 code to
    common oprofile statistic variables. Now the value will be available
    and usable for all architectures. The initialization and
    incrementation also moved to common code.
    
    Signed-off-by: Robert Richter <robert.richter@amd.com>

diff --git a/drivers/oprofile/oprofile_stats.c b/drivers/oprofile/oprofile_stats.c
index 77a57a6792f6..61689e814d46 100644
--- a/drivers/oprofile/oprofile_stats.c
+++ b/drivers/oprofile/oprofile_stats.c
@@ -16,9 +16,6 @@
 #include "cpu_buffer.h"
 
 struct oprofile_stat_struct oprofile_stats;
-#ifdef CONFIG_OPROFILE_EVENT_MULTIPLEX
-atomic_t multiplex_counter;
-#endif
 
 void oprofile_reset_stats(void)
 {
@@ -37,9 +34,7 @@ void oprofile_reset_stats(void)
 	atomic_set(&oprofile_stats.sample_lost_no_mapping, 0);
 	atomic_set(&oprofile_stats.event_lost_overflow, 0);
 	atomic_set(&oprofile_stats.bt_lost_no_mapping, 0);
-#ifdef CONFIG_OPROFILE_EVENT_MULTIPLEX
-	atomic_set(&multiplex_counter, 0);
-#endif
+	atomic_set(&oprofile_stats.multiplex_counter, 0);
 }
 
 
@@ -84,6 +79,6 @@ void oprofile_create_stats_files(struct super_block *sb, struct dentry *root)
 		&oprofile_stats.bt_lost_no_mapping);
 #ifdef CONFIG_OPROFILE_EVENT_MULTIPLEX
 	oprofilefs_create_ro_atomic(sb, dir, "multiplex_counter",
-		&multiplex_counter);
+		&oprofile_stats.multiplex_counter);
 #endif
 }

commit 4d4036e0e7299c6cbb2d2421b4b30b7a409ce61a
Author: Jason Yeh <jason.yeh@amd.com>
Date:   Wed Jul 8 13:49:38 2009 +0200

    oprofile: Implement performance counter multiplexing
    
    The number of hardware counters is limited. The multiplexing feature
    enables OProfile to gather more events than counters are provided by
    the hardware. This is realized by switching between events at an user
    specified time interval.
    
    A new file (/dev/oprofile/time_slice) is added for the user to specify
    the timer interval in ms. If the number of events to profile is higher
    than the number of hardware counters available, the patch will
    schedule a work queue that switches the event counter and re-writes
    the different sets of values into it. The switching mechanism needs to
    be implemented for each architecture to support multiplexing. This
    patch only implements AMD CPU support, but multiplexing can be easily
    extended for other models and architectures.
    
    There are follow-on patches that rework parts of this patch.
    
    Signed-off-by: Jason Yeh <jason.yeh@amd.com>
    Signed-off-by: Robert Richter <robert.richter@amd.com>

diff --git a/drivers/oprofile/oprofile_stats.c b/drivers/oprofile/oprofile_stats.c
index 3c2270a8300c..77a57a6792f6 100644
--- a/drivers/oprofile/oprofile_stats.c
+++ b/drivers/oprofile/oprofile_stats.c
@@ -16,6 +16,9 @@
 #include "cpu_buffer.h"
 
 struct oprofile_stat_struct oprofile_stats;
+#ifdef CONFIG_OPROFILE_EVENT_MULTIPLEX
+atomic_t multiplex_counter;
+#endif
 
 void oprofile_reset_stats(void)
 {
@@ -34,6 +37,9 @@ void oprofile_reset_stats(void)
 	atomic_set(&oprofile_stats.sample_lost_no_mapping, 0);
 	atomic_set(&oprofile_stats.event_lost_overflow, 0);
 	atomic_set(&oprofile_stats.bt_lost_no_mapping, 0);
+#ifdef CONFIG_OPROFILE_EVENT_MULTIPLEX
+	atomic_set(&multiplex_counter, 0);
+#endif
 }
 
 
@@ -76,4 +82,8 @@ void oprofile_create_stats_files(struct super_block *sb, struct dentry *root)
 		&oprofile_stats.event_lost_overflow);
 	oprofilefs_create_ro_atomic(sb, dir, "bt_lost_no_mapping",
 		&oprofile_stats.bt_lost_no_mapping);
+#ifdef CONFIG_OPROFILE_EVENT_MULTIPLEX
+	oprofilefs_create_ro_atomic(sb, dir, "multiplex_counter",
+		&multiplex_counter);
+#endif
 }

commit 2b8777ca0c944bf6498c45ed9c5c246bd63a719e
Author: Maynard Johnson <maynardj@us.ibm.com>
Date:   Wed May 27 10:15:08 2009 -0500

    oprofile: reset bt_lost_no_mapping with other stats
    
    The bt_lost_no_mapping is not getting reset at the start of a
    profiling run, thus the oprofiled.log shows erroneous values for this
    statistic. The attached patch fixes this problem.
    
    Signed-off-by: Maynard Johnson <maynardj@us.ibm.com>
    Signed-off-by: Robert Richter <robert.richter@amd.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/drivers/oprofile/oprofile_stats.c b/drivers/oprofile/oprofile_stats.c
index e1f6ce03705e..3c2270a8300c 100644
--- a/drivers/oprofile/oprofile_stats.c
+++ b/drivers/oprofile/oprofile_stats.c
@@ -33,6 +33,7 @@ void oprofile_reset_stats(void)
 	atomic_set(&oprofile_stats.sample_lost_no_mm, 0);
 	atomic_set(&oprofile_stats.sample_lost_no_mapping, 0);
 	atomic_set(&oprofile_stats.event_lost_overflow, 0);
+	atomic_set(&oprofile_stats.bt_lost_no_mapping, 0);
 }
 
 

commit 6a18037d4165f691063b43816be3152e9006eb06
Author: Robert Richter <robert.richter@amd.com>
Date:   Thu Oct 16 15:01:40 2008 +0200

    oprofile: fixing whitespaces in drivers/oprofile/*
    
    Signed-off-by: Robert Richter <robert.richter@amd.com>

diff --git a/drivers/oprofile/oprofile_stats.c b/drivers/oprofile/oprofile_stats.c
index e0c45498d175..e1f6ce03705e 100644
--- a/drivers/oprofile/oprofile_stats.c
+++ b/drivers/oprofile/oprofile_stats.c
@@ -11,17 +11,17 @@
 #include <linux/smp.h>
 #include <linux/cpumask.h>
 #include <linux/threads.h>
- 
+
 #include "oprofile_stats.h"
 #include "cpu_buffer.h"
- 
+
 struct oprofile_stat_struct oprofile_stats;
- 
+
 void oprofile_reset_stats(void)
 {
 	struct oprofile_cpu_buffer *cpu_buf;
 	int i;
- 
+
 	for_each_possible_cpu(i) {
 		cpu_buf = &per_cpu(cpu_buffer, i);
 		cpu_buf->sample_received = 0;
@@ -29,7 +29,7 @@ void oprofile_reset_stats(void)
 		cpu_buf->backtrace_aborted = 0;
 		cpu_buf->sample_invalid_eip = 0;
 	}
- 
+
 	atomic_set(&oprofile_stats.sample_lost_no_mm, 0);
 	atomic_set(&oprofile_stats.sample_lost_no_mapping, 0);
 	atomic_set(&oprofile_stats.event_lost_overflow, 0);
@@ -52,7 +52,7 @@ void oprofile_create_stats_files(struct super_block *sb, struct dentry *root)
 		cpu_buf = &per_cpu(cpu_buffer, i);
 		snprintf(buf, 10, "cpu%d", i);
 		cpudir = oprofilefs_mkdir(sb, dir, buf);
- 
+
 		/* Strictly speaking access to these ulongs is racy,
 		 * but we can't simply lock them, and they are
 		 * informational only.
@@ -66,7 +66,7 @@ void oprofile_create_stats_files(struct super_block *sb, struct dentry *root)
 		oprofilefs_create_ro_ulong(sb, cpudir, "sample_invalid_eip",
 			&cpu_buf->sample_invalid_eip);
 	}
- 
+
 	oprofilefs_create_ro_atomic(sb, dir, "sample_lost_no_mm",
 		&oprofile_stats.sample_lost_no_mm);
 	oprofilefs_create_ro_atomic(sb, dir, "sample_lost_no_mapping",

commit 25ad2913cae9c9e3ed28075caeb2eefccd636f4f
Author: Robert Richter <robert.richter@amd.com>
Date:   Fri Sep 5 17:12:36 2008 +0200

    oprofile: more whitespace fixes
    
    Signed-off-by: Robert Richter <robert.richter@amd.com>

diff --git a/drivers/oprofile/oprofile_stats.c b/drivers/oprofile/oprofile_stats.c
index f99b28e7b79a..e0c45498d175 100644
--- a/drivers/oprofile/oprofile_stats.c
+++ b/drivers/oprofile/oprofile_stats.c
@@ -19,7 +19,7 @@ struct oprofile_stat_struct oprofile_stats;
  
 void oprofile_reset_stats(void)
 {
-	struct oprofile_cpu_buffer * cpu_buf; 
+	struct oprofile_cpu_buffer *cpu_buf;
 	int i;
  
 	for_each_possible_cpu(i) {
@@ -36,11 +36,11 @@ void oprofile_reset_stats(void)
 }
 
 
-void oprofile_create_stats_files(struct super_block * sb, struct dentry * root)
+void oprofile_create_stats_files(struct super_block *sb, struct dentry *root)
 {
-	struct oprofile_cpu_buffer * cpu_buf;
-	struct dentry * cpudir;
-	struct dentry * dir;
+	struct oprofile_cpu_buffer *cpu_buf;
+	struct dentry *cpudir;
+	struct dentry *dir;
 	char buf[10];
 	int i;
 

commit 608dfddd845da5ab6accef70154c8910529699f7
Author: Mike Travis <travis@sgi.com>
Date:   Mon Apr 28 02:14:15 2008 -0700

    oprofile: change cpu_buffer from array to per_cpu variable
    
    Change cpu_buffer from array to per_cpu variable in oprofile functions.
    
    [akpm@linux-foundation.org: coding-style fixes]
    Cc: Philippe Elie <phil.el@wanadoo.fr>
    Signed-off-by: Mike Travis <travis@sgi.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/oprofile/oprofile_stats.c b/drivers/oprofile/oprofile_stats.c
index d1f6d776e9e4..f99b28e7b79a 100644
--- a/drivers/oprofile/oprofile_stats.c
+++ b/drivers/oprofile/oprofile_stats.c
@@ -23,7 +23,7 @@ void oprofile_reset_stats(void)
 	int i;
  
 	for_each_possible_cpu(i) {
-		cpu_buf = &cpu_buffer[i]; 
+		cpu_buf = &per_cpu(cpu_buffer, i);
 		cpu_buf->sample_received = 0;
 		cpu_buf->sample_lost_overflow = 0;
 		cpu_buf->backtrace_aborted = 0;
@@ -49,7 +49,7 @@ void oprofile_create_stats_files(struct super_block * sb, struct dentry * root)
 		return;
 
 	for_each_possible_cpu(i) {
-		cpu_buf = &cpu_buffer[i]; 
+		cpu_buf = &per_cpu(cpu_buffer, i);
 		snprintf(buf, 10, "cpu%d", i);
 		cpudir = oprofilefs_mkdir(sb, dir, buf);
  

commit df9d177aa28d50e64bae6fbd6b263833079e3571
Author: Philippe Elie <phil.el@wanadoo.fr>
Date:   Wed Nov 14 16:58:48 2007 -0800

    oProfile: oops when profile_pc() returns ~0LU
    
    Instruction pointer returned by profile_pc() can be a random value.  This
    break the assumption than we can safely set struct op_sample.eip field to a
    magic value to signal to the per-cpu buffer reader side special event like
    task switch ending up in a segfault in get_task_mm() when profile_pc()
    return ~0UL.  Fixed by sanitizing the sampled eip and reject/log invalid
    eip.
    
    Problem reported by Sami Farin, patch tested by him.
    
    Signed-off-by: Philippe Elie <phil.el@wanadoo.fr>
    Tested-by: Sami Farin <safari-kernel@safari.iki.fi>
    Cc: <stable@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/oprofile/oprofile_stats.c b/drivers/oprofile/oprofile_stats.c
index f0acb661c253..d1f6d776e9e4 100644
--- a/drivers/oprofile/oprofile_stats.c
+++ b/drivers/oprofile/oprofile_stats.c
@@ -26,6 +26,8 @@ void oprofile_reset_stats(void)
 		cpu_buf = &cpu_buffer[i]; 
 		cpu_buf->sample_received = 0;
 		cpu_buf->sample_lost_overflow = 0;
+		cpu_buf->backtrace_aborted = 0;
+		cpu_buf->sample_invalid_eip = 0;
 	}
  
 	atomic_set(&oprofile_stats.sample_lost_no_mm, 0);
@@ -61,6 +63,8 @@ void oprofile_create_stats_files(struct super_block * sb, struct dentry * root)
 			&cpu_buf->sample_lost_overflow);
 		oprofilefs_create_ro_ulong(sb, cpudir, "backtrace_aborted",
 			&cpu_buf->backtrace_aborted);
+		oprofilefs_create_ro_ulong(sb, cpudir, "sample_invalid_eip",
+			&cpu_buf->sample_invalid_eip);
 	}
  
 	oprofilefs_create_ro_atomic(sb, dir, "sample_lost_no_mm",

commit fe449f48368623eb47715061b4977ce982d8e03b
Author: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
Date:   Tue Mar 28 01:56:38 2006 -0800

    [PATCH] for_each_possible_cpu: oprofile.
    
    This patch replaces for_each_cpu with for_each_possible_cpu.
    
    Signed-off-by: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/oprofile/oprofile_stats.c b/drivers/oprofile/oprofile_stats.c
index e94b1e4a2a84..f0acb661c253 100644
--- a/drivers/oprofile/oprofile_stats.c
+++ b/drivers/oprofile/oprofile_stats.c
@@ -22,7 +22,7 @@ void oprofile_reset_stats(void)
 	struct oprofile_cpu_buffer * cpu_buf; 
 	int i;
  
-	for_each_cpu(i) {
+	for_each_possible_cpu(i) {
 		cpu_buf = &cpu_buffer[i]; 
 		cpu_buf->sample_received = 0;
 		cpu_buf->sample_lost_overflow = 0;
@@ -46,7 +46,7 @@ void oprofile_create_stats_files(struct super_block * sb, struct dentry * root)
 	if (!dir)
 		return;
 
-	for_each_cpu(i) {
+	for_each_possible_cpu(i) {
 		cpu_buf = &cpu_buffer[i]; 
 		snprintf(buf, 10, "cpu%d", i);
 		cpudir = oprofilefs_mkdir(sb, dir, buf);

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/oprofile/oprofile_stats.c b/drivers/oprofile/oprofile_stats.c
new file mode 100644
index 000000000000..e94b1e4a2a84
--- /dev/null
+++ b/drivers/oprofile/oprofile_stats.c
@@ -0,0 +1,74 @@
+/**
+ * @file oprofile_stats.c
+ *
+ * @remark Copyright 2002 OProfile authors
+ * @remark Read the file COPYING
+ *
+ * @author John Levon
+ */
+
+#include <linux/oprofile.h>
+#include <linux/smp.h>
+#include <linux/cpumask.h>
+#include <linux/threads.h>
+ 
+#include "oprofile_stats.h"
+#include "cpu_buffer.h"
+ 
+struct oprofile_stat_struct oprofile_stats;
+ 
+void oprofile_reset_stats(void)
+{
+	struct oprofile_cpu_buffer * cpu_buf; 
+	int i;
+ 
+	for_each_cpu(i) {
+		cpu_buf = &cpu_buffer[i]; 
+		cpu_buf->sample_received = 0;
+		cpu_buf->sample_lost_overflow = 0;
+	}
+ 
+	atomic_set(&oprofile_stats.sample_lost_no_mm, 0);
+	atomic_set(&oprofile_stats.sample_lost_no_mapping, 0);
+	atomic_set(&oprofile_stats.event_lost_overflow, 0);
+}
+
+
+void oprofile_create_stats_files(struct super_block * sb, struct dentry * root)
+{
+	struct oprofile_cpu_buffer * cpu_buf;
+	struct dentry * cpudir;
+	struct dentry * dir;
+	char buf[10];
+	int i;
+
+	dir = oprofilefs_mkdir(sb, root, "stats");
+	if (!dir)
+		return;
+
+	for_each_cpu(i) {
+		cpu_buf = &cpu_buffer[i]; 
+		snprintf(buf, 10, "cpu%d", i);
+		cpudir = oprofilefs_mkdir(sb, dir, buf);
+ 
+		/* Strictly speaking access to these ulongs is racy,
+		 * but we can't simply lock them, and they are
+		 * informational only.
+		 */
+		oprofilefs_create_ro_ulong(sb, cpudir, "sample_received",
+			&cpu_buf->sample_received);
+		oprofilefs_create_ro_ulong(sb, cpudir, "sample_lost_overflow",
+			&cpu_buf->sample_lost_overflow);
+		oprofilefs_create_ro_ulong(sb, cpudir, "backtrace_aborted",
+			&cpu_buf->backtrace_aborted);
+	}
+ 
+	oprofilefs_create_ro_atomic(sb, dir, "sample_lost_no_mm",
+		&oprofile_stats.sample_lost_no_mm);
+	oprofilefs_create_ro_atomic(sb, dir, "sample_lost_no_mapping",
+		&oprofile_stats.sample_lost_no_mapping);
+	oprofilefs_create_ro_atomic(sb, dir, "event_lost_overflow",
+		&oprofile_stats.event_lost_overflow);
+	oprofilefs_create_ro_atomic(sb, dir, "bt_lost_no_mapping",
+		&oprofile_stats.bt_lost_no_mapping);
+}
