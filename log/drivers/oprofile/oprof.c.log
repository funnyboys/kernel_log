commit dcfce4a095932e6e95d83ad982be3609947963bc
Author: Robert Richter <robert.richter@amd.com>
Date:   Tue Oct 11 17:11:08 2011 +0200

    oprofile, x86: Reimplement nmi timer mode using perf event
    
    The legacy x86 nmi watchdog code was removed with the implementation
    of the perf based nmi watchdog. This broke Oprofile's nmi timer
    mode. To run nmi timer mode we relied on a continuous ticking nmi
    source which the nmi watchdog provided. The nmi tick was no longer
    available and current watchdog can not be used anymore since it runs
    with very long periods in the range of seconds. This patch
    reimplements the nmi timer mode using a perf counter nmi source.
    
    V2:
    * removing pr_info()
    * fix undefined reference to `__udivdi3' for 32 bit build
    * fix section mismatch of .cpuinit.data:nmi_timer_cpu_nb
    * removed nmi timer setup in arch/x86
    * implemented function stubs for op_nmi_init/exit()
    * made code more readable in oprofile_init()
    
    V3:
    * fix architectural initialization in oprofile_init()
    * fix CONFIG_OPROFILE_NMI_TIMER dependencies
    
    Acked-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Signed-off-by: Robert Richter <robert.richter@amd.com>

diff --git a/drivers/oprofile/oprof.c b/drivers/oprofile/oprof.c
index f7cd06967aed..ed2c3ec07024 100644
--- a/drivers/oprofile/oprof.c
+++ b/drivers/oprofile/oprof.c
@@ -246,26 +246,24 @@ static int __init oprofile_init(void)
 	int err;
 
 	/* always init architecture to setup backtrace support */
+	timer_mode = 0;
 	err = oprofile_arch_init(&oprofile_ops);
+	if (!err) {
+		if (!timer && !oprofilefs_register())
+			return 0;
+		oprofile_arch_exit();
+	}
 
-	timer_mode = err || timer;	/* fall back to timer mode on errors */
-	if (timer_mode) {
-		if (!err)
-			oprofile_arch_exit();
+	/* setup timer mode: */
+	timer_mode = 1;
+	/* no nmi timer mode if oprofile.timer is set */
+	if (timer || op_nmi_timer_init(&oprofile_ops)) {
 		err = oprofile_timer_init(&oprofile_ops);
 		if (err)
 			return err;
 	}
 
-	err = oprofilefs_register();
-	if (!err)
-		return 0;
-
-	/* failed */
-	if (!timer_mode)
-		oprofile_arch_exit();
-
-	return err;
+	return oprofilefs_register();
 }
 
 

commit 75c43a20b220f885c39ffa7cdbbb1191e257a9a9
Author: Robert Richter <robert.richter@amd.com>
Date:   Fri Oct 14 15:46:10 2011 +0200

    oprofile: Remove exit function for timer mode
    
    Remove exit functions by moving init/exit code to oprofile's setup/
    shutdown functions. Doing so the oprofile module exit code will be
    easier and less error-prone.
    
    Signed-off-by: Robert Richter <robert.richter@amd.com>

diff --git a/drivers/oprofile/oprof.c b/drivers/oprofile/oprof.c
index f8c752e408a6..f7cd06967aed 100644
--- a/drivers/oprofile/oprof.c
+++ b/drivers/oprofile/oprof.c
@@ -262,9 +262,7 @@ static int __init oprofile_init(void)
 		return 0;
 
 	/* failed */
-	if (timer_mode)
-		oprofile_timer_exit();
-	else
+	if (!timer_mode)
 		oprofile_arch_exit();
 
 	return err;
@@ -274,9 +272,7 @@ static int __init oprofile_init(void)
 static void __exit oprofile_exit(void)
 {
 	oprofilefs_unregister();
-	if (timer_mode)
-		oprofile_timer_exit();
-	else
+	if (!timer_mode)
 		oprofile_arch_exit();
 }
 

commit 87121ca504fd1d963a66b3fb0c72054b0fd9a177
Author: Robert Richter <robert.richter@amd.com>
Date:   Fri Oct 7 16:31:46 2011 +0200

    oprofile: Fix crash when unloading module (hr timer mode)
    
    Oprofile may crash in a KVM guest while unlaoding modules. This
    happens if oprofile_arch_init() fails and oprofile switches to the hr
    timer mode as a fallback. In this case oprofile_arch_exit() is called,
    but it never was initialized properly which causes the crash. This
    patch fixes this.
    
    oprofile: using timer interrupt.
    BUG: unable to handle kernel NULL pointer dereference at 0000000000000008
    IP: [<ffffffff8123c226>] unregister_syscore_ops+0x41/0x58
    PGD 41da3f067 PUD 41d80e067 PMD 0
    Oops: 0002 [#1] PREEMPT SMP
    CPU 5
    Modules linked in: oprofile(-)
    
    Pid: 2382, comm: modprobe Not tainted 3.1.0-rc7-00018-g709a39d #18 Advanced Micro Device Anaheim/Anaheim
    RIP: 0010:[<ffffffff8123c226>]  [<ffffffff8123c226>] unregister_syscore_ops+0x41/0x58
    RSP: 0018:ffff88041de1de98  EFLAGS: 00010296
    RAX: 0000000000000000 RBX: ffffffffa00060e0 RCX: dead000000200200
    RDX: 0000000000000000 RSI: dead000000100100 RDI: ffffffff8178c620
    RBP: ffff88041de1dea8 R08: 0000000000000001 R09: 0000000000000082
    R10: 0000000000000000 R11: ffff88041de1dde8 R12: 0000000000000080
    R13: fffffffffffffff5 R14: 0000000000000001 R15: 0000000000610210
    FS:  00007f9ae5bef700(0000) GS:ffff88042fd40000(0000) knlGS:0000000000000000
    CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b
    CR2: 0000000000000008 CR3: 000000041ca44000 CR4: 00000000000006e0
    DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
    DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400
    Process modprobe (pid: 2382, threadinfo ffff88041de1c000, task ffff88042db6d040)
    Stack:
     ffff88041de1deb8 ffffffffa0006770 ffff88041de1deb8 ffffffffa000251e
     ffff88041de1dec8 ffffffffa00022c2 ffff88041de1ded8 ffffffffa0004993
     ffff88041de1df78 ffffffff81073115 656c69666f72706f 0000000000610200
    Call Trace:
     [<ffffffffa000251e>] op_nmi_exit+0x15/0x17 [oprofile]
     [<ffffffffa00022c2>] oprofile_arch_exit+0xe/0x10 [oprofile]
     [<ffffffffa0004993>] oprofile_exit+0x13/0x15 [oprofile]
     [<ffffffff81073115>] sys_delete_module+0x1c3/0x22f
     [<ffffffff811bf09e>] ? trace_hardirqs_on_thunk+0x3a/0x3f
     [<ffffffff8148070b>] system_call_fastpath+0x16/0x1b
    Code: 20 c6 78 81 e8 c5 cc 23 00 48 8b 13 48 8b 43 08 48 be 00 01 10 00 00 00 ad de 48 b9 00 02 20 00 00 00 ad de 48 c7 c7 20 c6 78 81
     89 42 08 48 89 10 48 89 33 48 89 4b 08 e8 a6 c0 23 00 5a 5b
    RIP  [<ffffffff8123c226>] unregister_syscore_ops+0x41/0x58
     RSP <ffff88041de1de98>
    CR2: 0000000000000008
    ---[ end trace 06d4e95b6aa3b437 ]---
    
    CC: stable@kernel.org # 2.6.37+
    Signed-off-by: Robert Richter <robert.richter@amd.com>

diff --git a/drivers/oprofile/oprof.c b/drivers/oprofile/oprof.c
index dccd8636095c..f8c752e408a6 100644
--- a/drivers/oprofile/oprof.c
+++ b/drivers/oprofile/oprof.c
@@ -239,26 +239,45 @@ int oprofile_set_ulong(unsigned long *addr, unsigned long val)
 	return err;
 }
 
+static int timer_mode;
+
 static int __init oprofile_init(void)
 {
 	int err;
 
+	/* always init architecture to setup backtrace support */
 	err = oprofile_arch_init(&oprofile_ops);
-	if (err < 0 || timer) {
-		printk(KERN_INFO "oprofile: using timer interrupt.\n");
+
+	timer_mode = err || timer;	/* fall back to timer mode on errors */
+	if (timer_mode) {
+		if (!err)
+			oprofile_arch_exit();
 		err = oprofile_timer_init(&oprofile_ops);
 		if (err)
 			return err;
 	}
-	return oprofilefs_register();
+
+	err = oprofilefs_register();
+	if (!err)
+		return 0;
+
+	/* failed */
+	if (timer_mode)
+		oprofile_timer_exit();
+	else
+		oprofile_arch_exit();
+
+	return err;
 }
 
 
 static void __exit oprofile_exit(void)
 {
-	oprofile_timer_exit();
 	oprofilefs_unregister();
-	oprofile_arch_exit();
+	if (timer_mode)
+		oprofile_timer_exit();
+	else
+		oprofile_arch_exit();
 }
 
 

commit b76a06e08d94b2a63e47837dfe46bbbf0a3af6c2
Author: Anton Blanchard <anton@samba.org>
Date:   Sun May 8 19:32:36 2011 -0400

    oprofile: Use linux/mutex.h
    
    The oprofile code is still including asm/mutex.h instead of
    linux/mutex.h.
    
    Signed-off-by: Anton Blanchard <anton@samba.org>
    Signed-off-by: Robert Richter <robert.richter@amd.com>

diff --git a/drivers/oprofile/oprof.c b/drivers/oprofile/oprof.c
index f9bda64fcd1b..dccd8636095c 100644
--- a/drivers/oprofile/oprof.c
+++ b/drivers/oprofile/oprof.c
@@ -14,7 +14,7 @@
 #include <linux/moduleparam.h>
 #include <linux/workqueue.h>
 #include <linux/time.h>
-#include <asm/mutex.h>
+#include <linux/mutex.h>
 
 #include "oprof.h"
 #include "event_buffer.h"

commit 7df01d96b295e400167e78061b81d4c91630b12d
Author: Robert Richter <robert.richter@amd.com>
Date:   Mon Oct 4 21:09:36 2010 +0200

    oprofile: disable write access to oprofilefs while profiler is running
    
    Oprofile counters are setup when profiling is disabled. Thus, writing
    to oprofilefs has no immediate effect. Changes are updated only after
    oprofile is reenabled.
    
    To keep userland and kernel states synchronized, we now allow
    configuration of oprofile only if profiling is disabled.  In this case
    it checks if the profiler is running and then disables write access to
    oprofilefs by returning -EBUSY. The change should be backward
    compatible with current oprofile userland daemon.
    
    Acked-by: Maynard Johnson <maynardj@us.ibm.com>
    Cc: William Cohen <wcohen@redhat.com>
    Cc: Suravee Suthikulpanit <suravee.suthikulpanit@amd.com>
    Signed-off-by: Robert Richter <robert.richter@amd.com>

diff --git a/drivers/oprofile/oprof.c b/drivers/oprofile/oprof.c
index b4a685719dba..f9bda64fcd1b 100644
--- a/drivers/oprofile/oprof.c
+++ b/drivers/oprofile/oprof.c
@@ -225,26 +225,17 @@ void oprofile_shutdown(void)
 	mutex_unlock(&start_mutex);
 }
 
-int oprofile_set_backtrace(unsigned long val)
+int oprofile_set_ulong(unsigned long *addr, unsigned long val)
 {
-	int err = 0;
+	int err = -EBUSY;
 
 	mutex_lock(&start_mutex);
-
-	if (oprofile_started) {
-		err = -EBUSY;
-		goto out;
+	if (!oprofile_started) {
+		*addr = val;
+		err = 0;
 	}
-
-	if (!oprofile_ops.backtrace) {
-		err = -EINVAL;
-		goto out;
-	}
-
-	oprofile_backtrace_depth = val;
-
-out:
 	mutex_unlock(&start_mutex);
+
 	return err;
 }
 

commit 979048e1f26190d16b5aea87166177f37e614439
Author: Will Deacon <will.deacon@arm.com>
Date:   Sun Aug 29 14:51:59 2010 -0400

    oprofile: don't call arch exit code from init code on failure
    
    oprofile_init calls oprofile_arch_init to initialise the architecture-specific
    backend code. If this backend code returns failure, oprofile_arch_exit is
    called immediately, making it difficult to allocate and free resources
    correctly.
    
    This patch removes the oprofile_arch_exit call from oprofile_init,
    meaning that all architectures must ensure that oprofile_arch_init
    cleans up any mess it's made before returning an error. As far as
    I can tell, this only affects the code for ARM.
    
    Cc: Robert Richter <robert.richter@amd.com>
    Cc: Matt Fleming <matt@console-pimps.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Robert Richter <robert.richter@amd.com>

diff --git a/drivers/oprofile/oprof.c b/drivers/oprofile/oprof.c
index b336cd9ee7a1..b4a685719dba 100644
--- a/drivers/oprofile/oprof.c
+++ b/drivers/oprofile/oprof.c
@@ -257,16 +257,9 @@ static int __init oprofile_init(void)
 		printk(KERN_INFO "oprofile: using timer interrupt.\n");
 		err = oprofile_timer_init(&oprofile_ops);
 		if (err)
-			goto out_arch;
+			return err;
 	}
-	err = oprofilefs_register();
-	if (err)
-		goto out_arch;
-	return 0;
-
-out_arch:
-	oprofile_arch_exit();
-	return err;
+	return oprofilefs_register();
 }
 
 

commit bc078e4eab65f11bbaeed380593ab8151b30d703
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Tue Mar 2 16:01:10 2010 +0100

    oprofile: convert oprofile from timer_hook to hrtimer
    
    Oprofile is currently broken on systems running with NOHZ enabled.
    A maximum of 1 tick is accounted via the timer_hook if a cpu sleeps
    for a longer period of time. This does bad things to the percentages
    in the profiler output. To solve this problem convert oprofile to
    use a restarting hrtimer instead of the timer_hook.
    
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Signed-off-by: Robert Richter <robert.richter@amd.com>

diff --git a/drivers/oprofile/oprof.c b/drivers/oprofile/oprof.c
index dc8a0428260d..b336cd9ee7a1 100644
--- a/drivers/oprofile/oprof.c
+++ b/drivers/oprofile/oprof.c
@@ -253,22 +253,26 @@ static int __init oprofile_init(void)
 	int err;
 
 	err = oprofile_arch_init(&oprofile_ops);
-
 	if (err < 0 || timer) {
 		printk(KERN_INFO "oprofile: using timer interrupt.\n");
-		oprofile_timer_init(&oprofile_ops);
+		err = oprofile_timer_init(&oprofile_ops);
+		if (err)
+			goto out_arch;
 	}
-
 	err = oprofilefs_register();
 	if (err)
-		oprofile_arch_exit();
+		goto out_arch;
+	return 0;
 
+out_arch:
+	oprofile_arch_exit();
 	return err;
 }
 
 
 static void __exit oprofile_exit(void)
 {
+	oprofile_timer_exit();
 	oprofilefs_unregister();
 	oprofile_arch_exit();
 }

commit 1b294f5960cd89e49eeb3e797860c552b03f2272
Author: Robert Richter <robert.richter@amd.com>
Date:   Thu Jul 9 14:56:25 2009 +0200

    oprofile: Adding switch counter to oprofile statistic variables
    
    This patch moves the multiplexing switch counter from x86 code to
    common oprofile statistic variables. Now the value will be available
    and usable for all architectures. The initialization and
    incrementation also moved to common code.
    
    Signed-off-by: Robert Richter <robert.richter@amd.com>

diff --git a/drivers/oprofile/oprof.c b/drivers/oprofile/oprof.c
index a48294a8ebe8..dc8a0428260d 100644
--- a/drivers/oprofile/oprof.c
+++ b/drivers/oprofile/oprof.c
@@ -107,8 +107,11 @@ static void stop_switch_worker(void)
 
 static void switch_worker(struct work_struct *work)
 {
-	if (!oprofile_ops.switch_events())
-		start_switch_worker();
+	if (oprofile_ops.switch_events())
+		return;
+
+	atomic_inc(&oprofile_stats.multiplex_counter);
+	start_switch_worker();
 }
 
 /* User inputs in ms, converts to jiffies */

commit a5659d17adb815fb35e11745e2f39c3f0bfd579f
Author: Robert Richter <robert.richter@amd.com>
Date:   Fri Jun 19 16:45:34 2009 +0200

    oprofile: Grouping multiplexing code in oprof.c
    
    This patch moves multiplexing code to a single section of code. This
    reduces the use of #ifdefs especially within functions.
    
    Signed-off-by: Robert Richter <robert.richter@amd.com>

diff --git a/drivers/oprofile/oprof.c b/drivers/oprofile/oprof.c
index fa6cccd87cf8..a48294a8ebe8 100644
--- a/drivers/oprofile/oprof.c
+++ b/drivers/oprofile/oprof.c
@@ -29,13 +29,6 @@ unsigned long oprofile_backtrace_depth;
 static unsigned long is_setup;
 static DEFINE_MUTEX(start_mutex);
 
-#ifdef CONFIG_OPROFILE_EVENT_MULTIPLEX
-
-static void switch_worker(struct work_struct *work);
-static DECLARE_DELAYED_WORK(switch_work, switch_worker);
-
-#endif
-
 /* timer
    0 - use performance monitoring hardware if available
    1 - use the timer int mechanism regardless
@@ -98,9 +91,18 @@ int oprofile_setup(void)
 
 #ifdef CONFIG_OPROFILE_EVENT_MULTIPLEX
 
+static void switch_worker(struct work_struct *work);
+static DECLARE_DELAYED_WORK(switch_work, switch_worker);
+
 static void start_switch_worker(void)
 {
-	schedule_delayed_work(&switch_work, oprofile_time_slice);
+	if (oprofile_ops.switch_events)
+		schedule_delayed_work(&switch_work, oprofile_time_slice);
+}
+
+static void stop_switch_worker(void)
+{
+	cancel_delayed_work_sync(&switch_work);
 }
 
 static void switch_worker(struct work_struct *work)
@@ -109,6 +111,43 @@ static void switch_worker(struct work_struct *work)
 		start_switch_worker();
 }
 
+/* User inputs in ms, converts to jiffies */
+int oprofile_set_timeout(unsigned long val_msec)
+{
+	int err = 0;
+	unsigned long time_slice;
+
+	mutex_lock(&start_mutex);
+
+	if (oprofile_started) {
+		err = -EBUSY;
+		goto out;
+	}
+
+	if (!oprofile_ops.switch_events) {
+		err = -EINVAL;
+		goto out;
+	}
+
+	time_slice = msecs_to_jiffies(val_msec);
+	if (time_slice == MAX_JIFFY_OFFSET) {
+		err = -EINVAL;
+		goto out;
+	}
+
+	oprofile_time_slice = time_slice;
+
+out:
+	mutex_unlock(&start_mutex);
+	return err;
+
+}
+
+#else
+
+static inline void start_switch_worker(void) { }
+static inline void stop_switch_worker(void) { }
+
 #endif
 
 /* Actually start profiling (echo 1>/dev/oprofile/enable) */
@@ -131,10 +170,7 @@ int oprofile_start(void)
 	if ((err = oprofile_ops.start()))
 		goto out;
 
-#ifdef CONFIG_OPROFILE_EVENT_MULTIPLEX
-	if (oprofile_ops.switch_events)
-		start_switch_worker();
-#endif
+	start_switch_worker();
 
 	oprofile_started = 1;
 out:
@@ -152,9 +188,7 @@ void oprofile_stop(void)
 	oprofile_ops.stop();
 	oprofile_started = 0;
 
-#ifdef CONFIG_OPROFILE_EVENT_MULTIPLEX
-	cancel_delayed_work_sync(&switch_work);
-#endif
+	stop_switch_worker();
 
 	/* wake up the daemon to read what remains */
 	wake_up_buffer_waiter();
@@ -188,42 +222,6 @@ void oprofile_shutdown(void)
 	mutex_unlock(&start_mutex);
 }
 
-#ifdef CONFIG_OPROFILE_EVENT_MULTIPLEX
-
-/* User inputs in ms, converts to jiffies */
-int oprofile_set_timeout(unsigned long val_msec)
-{
-	int err = 0;
-	unsigned long time_slice;
-
-	mutex_lock(&start_mutex);
-
-	if (oprofile_started) {
-		err = -EBUSY;
-		goto out;
-	}
-
-	if (!oprofile_ops.switch_events) {
-		err = -EINVAL;
-		goto out;
-	}
-
-	time_slice = msecs_to_jiffies(val_msec);
-	if (time_slice == MAX_JIFFY_OFFSET) {
-		err = -EINVAL;
-		goto out;
-	}
-
-	oprofile_time_slice = time_slice;
-
-out:
-	mutex_unlock(&start_mutex);
-	return err;
-
-}
-
-#endif
-
 int oprofile_set_backtrace(unsigned long val)
 {
 	int err = 0;

commit 16422a6e2d16a39861ae5b0b11d9b411a245ab83
Author: Robert Richter <robert.richter@amd.com>
Date:   Wed Jul 15 15:44:18 2009 +0200

    oprofile: Remove oprofile_multiplexing_init()
    
    oprofile_multiplexing_init() can be removed when moving the
    initialization of oprofile_time_slice to oprofile_create_files().
    
    Signed-off-by: Robert Richter <robert.richter@amd.com>

diff --git a/drivers/oprofile/oprof.c b/drivers/oprofile/oprof.c
index 2b33de716412..fa6cccd87cf8 100644
--- a/drivers/oprofile/oprof.c
+++ b/drivers/oprofile/oprof.c
@@ -33,7 +33,6 @@ static DEFINE_MUTEX(start_mutex);
 
 static void switch_worker(struct work_struct *work);
 static DECLARE_DELAYED_WORK(switch_work, switch_worker);
-#define TIME_SLICE_DEFAULT		1
 
 #endif
 
@@ -248,23 +247,10 @@ int oprofile_set_backtrace(unsigned long val)
 	return err;
 }
 
-#ifdef CONFIG_OPROFILE_EVENT_MULTIPLEX
-
-static void __init oprofile_multiplexing_init(void)
-{
-	oprofile_time_slice = msecs_to_jiffies(TIME_SLICE_DEFAULT);
-}
-
-#endif
-
 static int __init oprofile_init(void)
 {
 	int err;
 
-#ifdef CONFIG_OPROFILE_EVENT_MULTIPLEX
-	oprofile_multiplexing_init();
-#endif
-
 	err = oprofile_arch_init(&oprofile_ops);
 
 	if (err < 0 || timer) {

commit afe1b50fe6aa56093e9234bdc08779e9fe20b5bf
Author: Robert Richter <robert.richter@amd.com>
Date:   Wed Jul 15 15:19:29 2009 +0200

    oprofile: Rename variable timeout_jiffies and move to oprofile_files.c
    
    This patch renames timeout_jiffies into an oprofile specific name. The
    macro MULTIPLEXING_TIMER_DEFAULT is changed too.
    
    Also, since this variable is controlled using oprofilefs, its
    definition is moved to oprofile_files.c.
    
    Signed-off-by: Robert Richter <robert.richter@amd.com>

diff --git a/drivers/oprofile/oprof.c b/drivers/oprofile/oprof.c
index 42c9c765f9f1..2b33de716412 100644
--- a/drivers/oprofile/oprof.c
+++ b/drivers/oprofile/oprof.c
@@ -33,8 +33,7 @@ static DEFINE_MUTEX(start_mutex);
 
 static void switch_worker(struct work_struct *work);
 static DECLARE_DELAYED_WORK(switch_work, switch_worker);
-unsigned long timeout_jiffies;
-#define MULTIPLEXING_TIMER_DEFAULT 1
+#define TIME_SLICE_DEFAULT		1
 
 #endif
 
@@ -102,7 +101,7 @@ int oprofile_setup(void)
 
 static void start_switch_worker(void)
 {
-	schedule_delayed_work(&switch_work, timeout_jiffies);
+	schedule_delayed_work(&switch_work, oprofile_time_slice);
 }
 
 static void switch_worker(struct work_struct *work)
@@ -216,7 +215,7 @@ int oprofile_set_timeout(unsigned long val_msec)
 		goto out;
 	}
 
-	timeout_jiffies = time_slice;
+	oprofile_time_slice = time_slice;
 
 out:
 	mutex_unlock(&start_mutex);
@@ -253,7 +252,7 @@ int oprofile_set_backtrace(unsigned long val)
 
 static void __init oprofile_multiplexing_init(void)
 {
-	timeout_jiffies = msecs_to_jiffies(MULTIPLEXING_TIMER_DEFAULT);
+	oprofile_time_slice = msecs_to_jiffies(TIME_SLICE_DEFAULT);
 }
 
 #endif

commit 2051cade7ccbe45a8bf8b7809d56b23d6d75ad03
Author: Robert Richter <robert.richter@amd.com>
Date:   Wed Jul 15 15:44:18 2009 +0200

    oprofile: oprofile_set_timeout(), return with error for invalid args
    
    Return with -EINVAL for invalid parameters instead of setting the
    default value in oprofile_set_timeout().
    
    Signed-off-by: Robert Richter <robert.richter@amd.com>

diff --git a/drivers/oprofile/oprof.c b/drivers/oprofile/oprof.c
index 7bc64af7cf99..42c9c765f9f1 100644
--- a/drivers/oprofile/oprof.c
+++ b/drivers/oprofile/oprof.c
@@ -196,6 +196,7 @@ void oprofile_shutdown(void)
 int oprofile_set_timeout(unsigned long val_msec)
 {
 	int err = 0;
+	unsigned long time_slice;
 
 	mutex_lock(&start_mutex);
 
@@ -209,9 +210,13 @@ int oprofile_set_timeout(unsigned long val_msec)
 		goto out;
 	}
 
-	timeout_jiffies = msecs_to_jiffies(val_msec);
-	if (timeout_jiffies == MAX_JIFFY_OFFSET)
-		timeout_jiffies = msecs_to_jiffies(MULTIPLEXING_TIMER_DEFAULT);
+	time_slice = msecs_to_jiffies(val_msec);
+	if (time_slice == MAX_JIFFY_OFFSET) {
+		err = -EINVAL;
+		goto out;
+	}
+
+	timeout_jiffies = time_slice;
 
 out:
 	mutex_unlock(&start_mutex);

commit 4d4036e0e7299c6cbb2d2421b4b30b7a409ce61a
Author: Jason Yeh <jason.yeh@amd.com>
Date:   Wed Jul 8 13:49:38 2009 +0200

    oprofile: Implement performance counter multiplexing
    
    The number of hardware counters is limited. The multiplexing feature
    enables OProfile to gather more events than counters are provided by
    the hardware. This is realized by switching between events at an user
    specified time interval.
    
    A new file (/dev/oprofile/time_slice) is added for the user to specify
    the timer interval in ms. If the number of events to profile is higher
    than the number of hardware counters available, the patch will
    schedule a work queue that switches the event counter and re-writes
    the different sets of values into it. The switching mechanism needs to
    be implemented for each architecture to support multiplexing. This
    patch only implements AMD CPU support, but multiplexing can be easily
    extended for other models and architectures.
    
    There are follow-on patches that rework parts of this patch.
    
    Signed-off-by: Jason Yeh <jason.yeh@amd.com>
    Signed-off-by: Robert Richter <robert.richter@amd.com>

diff --git a/drivers/oprofile/oprof.c b/drivers/oprofile/oprof.c
index 3cffce90f82a..7bc64af7cf99 100644
--- a/drivers/oprofile/oprof.c
+++ b/drivers/oprofile/oprof.c
@@ -12,6 +12,8 @@
 #include <linux/init.h>
 #include <linux/oprofile.h>
 #include <linux/moduleparam.h>
+#include <linux/workqueue.h>
+#include <linux/time.h>
 #include <asm/mutex.h>
 
 #include "oprof.h"
@@ -27,6 +29,15 @@ unsigned long oprofile_backtrace_depth;
 static unsigned long is_setup;
 static DEFINE_MUTEX(start_mutex);
 
+#ifdef CONFIG_OPROFILE_EVENT_MULTIPLEX
+
+static void switch_worker(struct work_struct *work);
+static DECLARE_DELAYED_WORK(switch_work, switch_worker);
+unsigned long timeout_jiffies;
+#define MULTIPLEXING_TIMER_DEFAULT 1
+
+#endif
+
 /* timer
    0 - use performance monitoring hardware if available
    1 - use the timer int mechanism regardless
@@ -87,6 +98,20 @@ int oprofile_setup(void)
 	return err;
 }
 
+#ifdef CONFIG_OPROFILE_EVENT_MULTIPLEX
+
+static void start_switch_worker(void)
+{
+	schedule_delayed_work(&switch_work, timeout_jiffies);
+}
+
+static void switch_worker(struct work_struct *work)
+{
+	if (!oprofile_ops.switch_events())
+		start_switch_worker();
+}
+
+#endif
 
 /* Actually start profiling (echo 1>/dev/oprofile/enable) */
 int oprofile_start(void)
@@ -108,6 +133,11 @@ int oprofile_start(void)
 	if ((err = oprofile_ops.start()))
 		goto out;
 
+#ifdef CONFIG_OPROFILE_EVENT_MULTIPLEX
+	if (oprofile_ops.switch_events)
+		start_switch_worker();
+#endif
+
 	oprofile_started = 1;
 out:
 	mutex_unlock(&start_mutex);
@@ -123,6 +153,11 @@ void oprofile_stop(void)
 		goto out;
 	oprofile_ops.stop();
 	oprofile_started = 0;
+
+#ifdef CONFIG_OPROFILE_EVENT_MULTIPLEX
+	cancel_delayed_work_sync(&switch_work);
+#endif
+
 	/* wake up the daemon to read what remains */
 	wake_up_buffer_waiter();
 out:
@@ -155,6 +190,36 @@ void oprofile_shutdown(void)
 	mutex_unlock(&start_mutex);
 }
 
+#ifdef CONFIG_OPROFILE_EVENT_MULTIPLEX
+
+/* User inputs in ms, converts to jiffies */
+int oprofile_set_timeout(unsigned long val_msec)
+{
+	int err = 0;
+
+	mutex_lock(&start_mutex);
+
+	if (oprofile_started) {
+		err = -EBUSY;
+		goto out;
+	}
+
+	if (!oprofile_ops.switch_events) {
+		err = -EINVAL;
+		goto out;
+	}
+
+	timeout_jiffies = msecs_to_jiffies(val_msec);
+	if (timeout_jiffies == MAX_JIFFY_OFFSET)
+		timeout_jiffies = msecs_to_jiffies(MULTIPLEXING_TIMER_DEFAULT);
+
+out:
+	mutex_unlock(&start_mutex);
+	return err;
+
+}
+
+#endif
 
 int oprofile_set_backtrace(unsigned long val)
 {
@@ -179,10 +244,23 @@ int oprofile_set_backtrace(unsigned long val)
 	return err;
 }
 
+#ifdef CONFIG_OPROFILE_EVENT_MULTIPLEX
+
+static void __init oprofile_multiplexing_init(void)
+{
+	timeout_jiffies = msecs_to_jiffies(MULTIPLEXING_TIMER_DEFAULT);
+}
+
+#endif
+
 static int __init oprofile_init(void)
 {
 	int err;
 
+#ifdef CONFIG_OPROFILE_EVENT_MULTIPLEX
+	oprofile_multiplexing_init();
+#endif
+
 	err = oprofile_arch_init(&oprofile_ops);
 
 	if (err < 0 || timer) {

commit 4c50d9ea9ca9e46b65aeffed3e0d6f54ff38c8d4
Author: Robert Richter <robert.richter@amd.com>
Date:   Thu Jan 22 14:14:14 2009 +0100

    cpumask: modifiy oprofile initialization
    
    Delta patch to f7df8ed164996cd2c6aca9674388be6ef78d8b37 for
    tip/cpus4096.
    
    Moved initialization to sync_start()/sync_stop(). No changes needed in
    buffer_sync.h and oprof.c anymore.
    
    Signed-off-by: Robert Richter <robert.richter@amd.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/drivers/oprofile/oprof.c b/drivers/oprofile/oprof.c
index ced39f602292..3cffce90f82a 100644
--- a/drivers/oprofile/oprof.c
+++ b/drivers/oprofile/oprof.c
@@ -183,10 +183,6 @@ static int __init oprofile_init(void)
 {
 	int err;
 
-	err = buffer_sync_init();
-	if (err)
-		return err;
-
 	err = oprofile_arch_init(&oprofile_ops);
 
 	if (err < 0 || timer) {
@@ -195,10 +191,8 @@ static int __init oprofile_init(void)
 	}
 
 	err = oprofilefs_register();
-	if (err) {
+	if (err)
 		oprofile_arch_exit();
-		buffer_sync_cleanup();
-	}
 
 	return err;
 }
@@ -208,7 +202,6 @@ static void __exit oprofile_exit(void)
 {
 	oprofilefs_unregister();
 	oprofile_arch_exit();
-	buffer_sync_cleanup();
 }
 
 

commit f7df8ed164996cd2c6aca9674388be6ef78d8b37
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Sat Jan 10 21:58:09 2009 -0800

    cpumask: convert misc driver functions
    
    Impact: use new cpumask API.
    
    Convert misc driver functions to use struct cpumask.
    
    To Do:
      - Convert iucv_buffer_cpumask to cpumask_var_t.
    
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Mike Travis <travis@sgi.com>
    Acked-by: Dean Nelson <dcn@sgi.com>
    Cc: Robert Richter <robert.richter@amd.com>
    Cc: oprofile-list@lists.sf.net
    Cc: Jeremy Fitzhardinge <jeremy@xensource.com>
    Cc: Chris Wright <chrisw@sous-sol.org>
    Cc: virtualization@lists.osdl.org
    Cc: xen-devel@lists.xensource.com
    Cc: Ursula Braun <ursula.braun@de.ibm.com>
    Cc: linux390@de.ibm.com
    Cc: linux-s390@vger.kernel.org

diff --git a/drivers/oprofile/oprof.c b/drivers/oprofile/oprof.c
index 3cffce90f82a..ced39f602292 100644
--- a/drivers/oprofile/oprof.c
+++ b/drivers/oprofile/oprof.c
@@ -183,6 +183,10 @@ static int __init oprofile_init(void)
 {
 	int err;
 
+	err = buffer_sync_init();
+	if (err)
+		return err;
+
 	err = oprofile_arch_init(&oprofile_ops);
 
 	if (err < 0 || timer) {
@@ -191,8 +195,10 @@ static int __init oprofile_init(void)
 	}
 
 	err = oprofilefs_register();
-	if (err)
+	if (err) {
 		oprofile_arch_exit();
+		buffer_sync_cleanup();
+	}
 
 	return err;
 }
@@ -202,6 +208,7 @@ static void __exit oprofile_exit(void)
 {
 	oprofilefs_unregister();
 	oprofile_arch_exit();
+	buffer_sync_cleanup();
 }
 
 

commit bd2172f58094b3f8afa017e68f3f0b57577824e1
Author: Robert Richter <robert.richter@amd.com>
Date:   Tue Dec 16 16:19:54 2008 +0100

    oprofile: rename kernel-wide identifiers
    
    This patch renames kernel-wide identifiers to something more oprofile
    specific names.
    
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Robert Richter <robert.richter@amd.com>

diff --git a/drivers/oprofile/oprof.c b/drivers/oprofile/oprof.c
index cd375907f26f..3cffce90f82a 100644
--- a/drivers/oprofile/oprof.c
+++ b/drivers/oprofile/oprof.c
@@ -23,7 +23,7 @@
 struct oprofile_operations oprofile_ops;
 
 unsigned long oprofile_started;
-unsigned long backtrace_depth;
+unsigned long oprofile_backtrace_depth;
 static unsigned long is_setup;
 static DEFINE_MUTEX(start_mutex);
 
@@ -172,7 +172,7 @@ int oprofile_set_backtrace(unsigned long val)
 		goto out;
 	}
 
-	backtrace_depth = val;
+	oprofile_backtrace_depth = val;
 
 out:
 	mutex_unlock(&start_mutex);

commit 6a18037d4165f691063b43816be3152e9006eb06
Author: Robert Richter <robert.richter@amd.com>
Date:   Thu Oct 16 15:01:40 2008 +0200

    oprofile: fixing whitespaces in drivers/oprofile/*
    
    Signed-off-by: Robert Richter <robert.richter@amd.com>

diff --git a/drivers/oprofile/oprof.c b/drivers/oprofile/oprof.c
index 50062cea292c..cd375907f26f 100644
--- a/drivers/oprofile/oprof.c
+++ b/drivers/oprofile/oprof.c
@@ -94,7 +94,7 @@ int oprofile_start(void)
 	int err = -EINVAL;
 
 	mutex_lock(&start_mutex);
- 
+
 	if (!is_setup)
 		goto out;
 

commit c92960fccb9f32a1d6110f6dcfe483ed96c62beb
Author: Robert Richter <robert.richter@amd.com>
Date:   Fri Sep 5 17:12:36 2008 +0200

    oprofile: whitespace fixes
    
    Signed-off-by: Robert Richter <robert.richter@amd.com>

diff --git a/drivers/oprofile/oprof.c b/drivers/oprofile/oprof.c
index 2c645170f06e..50062cea292c 100644
--- a/drivers/oprofile/oprof.c
+++ b/drivers/oprofile/oprof.c
@@ -19,7 +19,7 @@
 #include "cpu_buffer.h"
 #include "buffer_sync.h"
 #include "oprofile_stats.h"
- 
+
 struct oprofile_operations oprofile_ops;
 
 unsigned long oprofile_started;
@@ -36,7 +36,7 @@ static int timer = 0;
 int oprofile_setup(void)
 {
 	int err;
- 
+
 	mutex_lock(&start_mutex);
 
 	if ((err = alloc_cpu_buffers()))
@@ -44,10 +44,10 @@ int oprofile_setup(void)
 
 	if ((err = alloc_event_buffer()))
 		goto out1;
- 
+
 	if (oprofile_ops.setup && (err = oprofile_ops.setup()))
 		goto out2;
- 
+
 	/* Note even though this starts part of the
 	 * profiling overhead, it's necessary to prevent
 	 * us missing task deaths and eventually oopsing
@@ -74,7 +74,7 @@ int oprofile_setup(void)
 	is_setup = 1;
 	mutex_unlock(&start_mutex);
 	return 0;
- 
+
 out3:
 	if (oprofile_ops.shutdown)
 		oprofile_ops.shutdown();
@@ -92,17 +92,17 @@ int oprofile_setup(void)
 int oprofile_start(void)
 {
 	int err = -EINVAL;
- 
+
 	mutex_lock(&start_mutex);
  
 	if (!is_setup)
 		goto out;
 
-	err = 0; 
- 
+	err = 0;
+
 	if (oprofile_started)
 		goto out;
- 
+
 	oprofile_reset_stats();
 
 	if ((err = oprofile_ops.start()))
@@ -114,7 +114,7 @@ int oprofile_start(void)
 	return err;
 }
 
- 
+
 /* echo 0>/dev/oprofile/enable */
 void oprofile_stop(void)
 {
@@ -204,13 +204,13 @@ static void __exit oprofile_exit(void)
 	oprofile_arch_exit();
 }
 
- 
+
 module_init(oprofile_init);
 module_exit(oprofile_exit);
 
 module_param_named(timer, timer, int, 0644);
 MODULE_PARM_DESC(timer, "force use of timer interrupt");
- 
+
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("John Levon <levon@movementarian.org>");
 MODULE_DESCRIPTION("OProfile system profiler");

commit 4c168eaf7ea39f25a45a3d8c7eebc3fedb633a1d
Author: Robert Richter <robert.richter@amd.com>
Date:   Wed Sep 24 11:08:52 2008 +0200

    Revert "Oprofile Multiplexing Patch"
    
    Reverting commit 1a960b402a51d80abf54e3f8e4972374ffe5f22d for the main
    branch. Multiplexing will be tracked on a separate feature branch.
    
    Conflicts:
    
        arch/x86/oprofile/nmi_int.c

diff --git a/drivers/oprofile/oprof.c b/drivers/oprofile/oprof.c
index b2fa5df64a62..2c645170f06e 100644
--- a/drivers/oprofile/oprof.c
+++ b/drivers/oprofile/oprof.c
@@ -12,8 +12,6 @@
 #include <linux/init.h>
 #include <linux/oprofile.h>
 #include <linux/moduleparam.h>
-#include <linux/workqueue.h>
-#include <linux/time.h>
 #include <asm/mutex.h>
 
 #include "oprof.h"
@@ -21,18 +19,13 @@
 #include "cpu_buffer.h"
 #include "buffer_sync.h"
 #include "oprofile_stats.h"
-
-static unsigned long is_setup;
-static void switch_worker(struct work_struct *work);
-static DECLARE_DELAYED_WORK(switch_work, switch_worker);
-static DEFINE_MUTEX(start_mutex);
  
 struct oprofile_operations oprofile_ops;
 
-unsigned long timeout_jiffies;
 unsigned long oprofile_started;
 unsigned long backtrace_depth;
-/* Multiplexing defaults at 1 msec*/
+static unsigned long is_setup;
+static DEFINE_MUTEX(start_mutex);
 
 /* timer
    0 - use performance monitoring hardware if available
@@ -94,16 +87,6 @@ int oprofile_setup(void)
 	return err;
 }
 
-static void start_switch_worker(void)
-{
-	schedule_delayed_work(&switch_work, timeout_jiffies);
-}
-
-static void switch_worker(struct work_struct *work)
-{
-	if (!oprofile_ops.switch_events())
-		start_switch_worker();
-}
 
 /* Actually start profiling (echo 1>/dev/oprofile/enable) */
 int oprofile_start(void)
@@ -111,6 +94,7 @@ int oprofile_start(void)
 	int err = -EINVAL;
  
 	mutex_lock(&start_mutex);
+ 
 	if (!is_setup)
 		goto out;
 
@@ -124,9 +108,6 @@ int oprofile_start(void)
 	if ((err = oprofile_ops.start()))
 		goto out;
 
-	if (oprofile_ops.switch_events)
-		start_switch_worker();
-
 	oprofile_started = 1;
 out:
 	mutex_unlock(&start_mutex);
@@ -142,7 +123,6 @@ void oprofile_stop(void)
 		goto out;
 	oprofile_ops.stop();
 	oprofile_started = 0;
-	cancel_delayed_work_sync(&switch_work);
 	/* wake up the daemon to read what remains */
 	wake_up_buffer_waiter();
 out:
@@ -175,32 +155,6 @@ void oprofile_shutdown(void)
 	mutex_unlock(&start_mutex);
 }
 
-/* User inputs in ms, converts to jiffies */
-int oprofile_set_timeout(unsigned long val_msec)
-{
-	int err = 0;
-
-	mutex_lock(&start_mutex);
-
-	if (oprofile_started) {
-		err = -EBUSY;
-		goto out;
-	}
-
-	if (!oprofile_ops.switch_events) {
-		err = -EINVAL;
-		goto out;
-	}
-
-	timeout_jiffies = msecs_to_jiffies(val_msec);
-	if (timeout_jiffies == MAX_JIFFY_OFFSET)
-		timeout_jiffies = msecs_to_jiffies(1);
-
-out:
-	mutex_unlock(&start_mutex);
-	return err;
-
-}
 
 int oprofile_set_backtrace(unsigned long val)
 {
@@ -225,16 +179,10 @@ int oprofile_set_backtrace(unsigned long val)
 	return err;
 }
 
-static void __init oprofile_switch_timer_init(void)
-{
-	timeout_jiffies = msecs_to_jiffies(1);
-}
-
 static int __init oprofile_init(void)
 {
 	int err;
 
-	oprofile_switch_timer_init();
 	err = oprofile_arch_init(&oprofile_ops);
 
 	if (err < 0 || timer) {

commit 1a960b402a51d80abf54e3f8e4972374ffe5f22d
Author: Jason Yeh <jason.yeh@amd.com>
Date:   Wed Jul 23 23:05:53 2008 +0200

    Oprofile Multiplexing Patch
    
    This patch introduces multiplexing support for the Oprofile kernel
    module. It basically adds a new function pointer in oprofile_operator
    allowing each architecture to supply its callback to switch between
    different sets of event when the timer expires. Userspace tools can
    modify the time slice through /dev/oprofile/time_slice.
    
    It also modifies the number of counters exposed to the userspace through
    /dev/oprofile. For example, the number of counters for AMD CPUs are
    changed to 32 and multiplexed in the sets of 4.
    
    Signed-off-by: Jason Yeh <jason.yeh@amd.com>
    Signed-off-by: Robert Richter <robert.richter@amd.com>
    Cc: oprofile-list <oprofile-list@lists.sourceforge.net>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/drivers/oprofile/oprof.c b/drivers/oprofile/oprof.c
index 2c645170f06e..b2fa5df64a62 100644
--- a/drivers/oprofile/oprof.c
+++ b/drivers/oprofile/oprof.c
@@ -12,6 +12,8 @@
 #include <linux/init.h>
 #include <linux/oprofile.h>
 #include <linux/moduleparam.h>
+#include <linux/workqueue.h>
+#include <linux/time.h>
 #include <asm/mutex.h>
 
 #include "oprof.h"
@@ -19,13 +21,18 @@
 #include "cpu_buffer.h"
 #include "buffer_sync.h"
 #include "oprofile_stats.h"
+
+static unsigned long is_setup;
+static void switch_worker(struct work_struct *work);
+static DECLARE_DELAYED_WORK(switch_work, switch_worker);
+static DEFINE_MUTEX(start_mutex);
  
 struct oprofile_operations oprofile_ops;
 
+unsigned long timeout_jiffies;
 unsigned long oprofile_started;
 unsigned long backtrace_depth;
-static unsigned long is_setup;
-static DEFINE_MUTEX(start_mutex);
+/* Multiplexing defaults at 1 msec*/
 
 /* timer
    0 - use performance monitoring hardware if available
@@ -87,6 +94,16 @@ int oprofile_setup(void)
 	return err;
 }
 
+static void start_switch_worker(void)
+{
+	schedule_delayed_work(&switch_work, timeout_jiffies);
+}
+
+static void switch_worker(struct work_struct *work)
+{
+	if (!oprofile_ops.switch_events())
+		start_switch_worker();
+}
 
 /* Actually start profiling (echo 1>/dev/oprofile/enable) */
 int oprofile_start(void)
@@ -94,7 +111,6 @@ int oprofile_start(void)
 	int err = -EINVAL;
  
 	mutex_lock(&start_mutex);
- 
 	if (!is_setup)
 		goto out;
 
@@ -108,6 +124,9 @@ int oprofile_start(void)
 	if ((err = oprofile_ops.start()))
 		goto out;
 
+	if (oprofile_ops.switch_events)
+		start_switch_worker();
+
 	oprofile_started = 1;
 out:
 	mutex_unlock(&start_mutex);
@@ -123,6 +142,7 @@ void oprofile_stop(void)
 		goto out;
 	oprofile_ops.stop();
 	oprofile_started = 0;
+	cancel_delayed_work_sync(&switch_work);
 	/* wake up the daemon to read what remains */
 	wake_up_buffer_waiter();
 out:
@@ -155,6 +175,32 @@ void oprofile_shutdown(void)
 	mutex_unlock(&start_mutex);
 }
 
+/* User inputs in ms, converts to jiffies */
+int oprofile_set_timeout(unsigned long val_msec)
+{
+	int err = 0;
+
+	mutex_lock(&start_mutex);
+
+	if (oprofile_started) {
+		err = -EBUSY;
+		goto out;
+	}
+
+	if (!oprofile_ops.switch_events) {
+		err = -EINVAL;
+		goto out;
+	}
+
+	timeout_jiffies = msecs_to_jiffies(val_msec);
+	if (timeout_jiffies == MAX_JIFFY_OFFSET)
+		timeout_jiffies = msecs_to_jiffies(1);
+
+out:
+	mutex_unlock(&start_mutex);
+	return err;
+
+}
 
 int oprofile_set_backtrace(unsigned long val)
 {
@@ -179,10 +225,16 @@ int oprofile_set_backtrace(unsigned long val)
 	return err;
 }
 
+static void __init oprofile_switch_timer_init(void)
+{
+	timeout_jiffies = msecs_to_jiffies(1);
+}
+
 static int __init oprofile_init(void)
 {
 	int err;
 
+	oprofile_switch_timer_init();
 	err = oprofile_arch_init(&oprofile_ops);
 
 	if (err < 0 || timer) {

commit 1474855d0878cced6f39f51f3c2bd7428b44cb1e
Author: Bob Nelson <rrnelson@linux.vnet.ibm.com>
Date:   Fri Jul 20 21:39:53 2007 +0200

    [CELL] oprofile: add support to OProfile for profiling CELL BE SPUs
    
    From: Maynard Johnson <mpjohn@us.ibm.com>
    
    This patch updates the existing arch/powerpc/oprofile/op_model_cell.c
    to add in the SPU profiling capabilities.  In addition, a 'cell' subdirectory
    was added to arch/powerpc/oprofile to hold Cell-specific SPU profiling code.
    Exports spu_set_profile_private_kref and spu_get_profile_private_kref which
    are used by OProfile to store private profile information in spufs data
    structures.
    
    Also incorporated several fixes from other patches (rrn).  Check pointer
    returned from kzalloc.  Eliminated unnecessary cast.  Better error
    handling and cleanup in the related area.  64-bit unsigned long parameter
    was being demoted to 32-bit unsigned int and eventually promoted back to
    unsigned long.
    
    Signed-off-by: Carl Love <carll@us.ibm.com>
    Signed-off-by: Maynard Johnson <mpjohn@us.ibm.com>
    Signed-off-by: Bob Nelson <rrnelson@us.ibm.com>
    Signed-off-by: Arnd Bergmann <arnd.bergmann@de.ibm.com>
    Acked-by: Paul Mackerras <paulus@samba.org>

diff --git a/drivers/oprofile/oprof.c b/drivers/oprofile/oprof.c
index e5162a64018b..2c645170f06e 100644
--- a/drivers/oprofile/oprof.c
+++ b/drivers/oprofile/oprof.c
@@ -53,9 +53,24 @@ int oprofile_setup(void)
 	 * us missing task deaths and eventually oopsing
 	 * when trying to process the event buffer.
 	 */
+	if (oprofile_ops.sync_start) {
+		int sync_ret = oprofile_ops.sync_start();
+		switch (sync_ret) {
+		case 0:
+			goto post_sync;
+		case 1:
+			goto do_generic;
+		case -1:
+			goto out3;
+		default:
+			goto out3;
+		}
+	}
+do_generic:
 	if ((err = sync_start()))
 		goto out3;
 
+post_sync:
 	is_setup = 1;
 	mutex_unlock(&start_mutex);
 	return 0;
@@ -118,7 +133,20 @@ void oprofile_stop(void)
 void oprofile_shutdown(void)
 {
 	mutex_lock(&start_mutex);
+	if (oprofile_ops.sync_stop) {
+		int sync_ret = oprofile_ops.sync_stop();
+		switch (sync_ret) {
+		case 0:
+			goto post_sync;
+		case 1:
+			goto do_generic;
+		default:
+			goto post_sync;
+		}
+	}
+do_generic:
 	sync_stop();
+post_sync:
 	if (oprofile_ops.shutdown)
 		oprofile_ops.shutdown();
 	is_setup = 0;

commit 59cc185ada89245204c658ebcf64422968736672
Author: Markus Armbruster <armbru@redhat.com>
Date:   Sun Jun 25 05:47:33 2006 -0700

    [PATCH] oprofile: convert from semaphores to mutexes
    
    Signed-off-by: Markus Armbruster <armbru@redhat.com>
    Cc: Philippe Elie <phil.el@wanadoo.fr>
    Cc: John Levon <levon@movementarian.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/oprofile/oprof.c b/drivers/oprofile/oprof.c
index b3f1cd6a24c1..e5162a64018b 100644
--- a/drivers/oprofile/oprof.c
+++ b/drivers/oprofile/oprof.c
@@ -12,7 +12,7 @@
 #include <linux/init.h>
 #include <linux/oprofile.h>
 #include <linux/moduleparam.h>
-#include <asm/semaphore.h>
+#include <asm/mutex.h>
 
 #include "oprof.h"
 #include "event_buffer.h"
@@ -25,7 +25,7 @@ struct oprofile_operations oprofile_ops;
 unsigned long oprofile_started;
 unsigned long backtrace_depth;
 static unsigned long is_setup;
-static DECLARE_MUTEX(start_sem);
+static DEFINE_MUTEX(start_mutex);
 
 /* timer
    0 - use performance monitoring hardware if available
@@ -37,7 +37,7 @@ int oprofile_setup(void)
 {
 	int err;
  
-	down(&start_sem);
+	mutex_lock(&start_mutex);
 
 	if ((err = alloc_cpu_buffers()))
 		goto out;
@@ -57,7 +57,7 @@ int oprofile_setup(void)
 		goto out3;
 
 	is_setup = 1;
-	up(&start_sem);
+	mutex_unlock(&start_mutex);
 	return 0;
  
 out3:
@@ -68,7 +68,7 @@ int oprofile_setup(void)
 out1:
 	free_cpu_buffers();
 out:
-	up(&start_sem);
+	mutex_unlock(&start_mutex);
 	return err;
 }
 
@@ -78,7 +78,7 @@ int oprofile_start(void)
 {
 	int err = -EINVAL;
  
-	down(&start_sem);
+	mutex_lock(&start_mutex);
  
 	if (!is_setup)
 		goto out;
@@ -95,7 +95,7 @@ int oprofile_start(void)
 
 	oprofile_started = 1;
 out:
-	up(&start_sem); 
+	mutex_unlock(&start_mutex);
 	return err;
 }
 
@@ -103,7 +103,7 @@ int oprofile_start(void)
 /* echo 0>/dev/oprofile/enable */
 void oprofile_stop(void)
 {
-	down(&start_sem);
+	mutex_lock(&start_mutex);
 	if (!oprofile_started)
 		goto out;
 	oprofile_ops.stop();
@@ -111,20 +111,20 @@ void oprofile_stop(void)
 	/* wake up the daemon to read what remains */
 	wake_up_buffer_waiter();
 out:
-	up(&start_sem);
+	mutex_unlock(&start_mutex);
 }
 
 
 void oprofile_shutdown(void)
 {
-	down(&start_sem);
+	mutex_lock(&start_mutex);
 	sync_stop();
 	if (oprofile_ops.shutdown)
 		oprofile_ops.shutdown();
 	is_setup = 0;
 	free_event_buffer();
 	free_cpu_buffers();
-	up(&start_sem);
+	mutex_unlock(&start_mutex);
 }
 
 
@@ -132,7 +132,7 @@ int oprofile_set_backtrace(unsigned long val)
 {
 	int err = 0;
 
-	down(&start_sem);
+	mutex_lock(&start_mutex);
 
 	if (oprofile_started) {
 		err = -EBUSY;
@@ -147,7 +147,7 @@ int oprofile_set_backtrace(unsigned long val)
 	backtrace_depth = val;
 
 out:
-	up(&start_sem);
+	mutex_unlock(&start_mutex);
 	return err;
 }
 

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/oprofile/oprof.c b/drivers/oprofile/oprof.c
new file mode 100644
index 000000000000..b3f1cd6a24c1
--- /dev/null
+++ b/drivers/oprofile/oprof.c
@@ -0,0 +1,188 @@
+/**
+ * @file oprof.c
+ *
+ * @remark Copyright 2002 OProfile authors
+ * @remark Read the file COPYING
+ *
+ * @author John Levon <levon@movementarian.org>
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/oprofile.h>
+#include <linux/moduleparam.h>
+#include <asm/semaphore.h>
+
+#include "oprof.h"
+#include "event_buffer.h"
+#include "cpu_buffer.h"
+#include "buffer_sync.h"
+#include "oprofile_stats.h"
+ 
+struct oprofile_operations oprofile_ops;
+
+unsigned long oprofile_started;
+unsigned long backtrace_depth;
+static unsigned long is_setup;
+static DECLARE_MUTEX(start_sem);
+
+/* timer
+   0 - use performance monitoring hardware if available
+   1 - use the timer int mechanism regardless
+ */
+static int timer = 0;
+
+int oprofile_setup(void)
+{
+	int err;
+ 
+	down(&start_sem);
+
+	if ((err = alloc_cpu_buffers()))
+		goto out;
+
+	if ((err = alloc_event_buffer()))
+		goto out1;
+ 
+	if (oprofile_ops.setup && (err = oprofile_ops.setup()))
+		goto out2;
+ 
+	/* Note even though this starts part of the
+	 * profiling overhead, it's necessary to prevent
+	 * us missing task deaths and eventually oopsing
+	 * when trying to process the event buffer.
+	 */
+	if ((err = sync_start()))
+		goto out3;
+
+	is_setup = 1;
+	up(&start_sem);
+	return 0;
+ 
+out3:
+	if (oprofile_ops.shutdown)
+		oprofile_ops.shutdown();
+out2:
+	free_event_buffer();
+out1:
+	free_cpu_buffers();
+out:
+	up(&start_sem);
+	return err;
+}
+
+
+/* Actually start profiling (echo 1>/dev/oprofile/enable) */
+int oprofile_start(void)
+{
+	int err = -EINVAL;
+ 
+	down(&start_sem);
+ 
+	if (!is_setup)
+		goto out;
+
+	err = 0; 
+ 
+	if (oprofile_started)
+		goto out;
+ 
+	oprofile_reset_stats();
+
+	if ((err = oprofile_ops.start()))
+		goto out;
+
+	oprofile_started = 1;
+out:
+	up(&start_sem); 
+	return err;
+}
+
+ 
+/* echo 0>/dev/oprofile/enable */
+void oprofile_stop(void)
+{
+	down(&start_sem);
+	if (!oprofile_started)
+		goto out;
+	oprofile_ops.stop();
+	oprofile_started = 0;
+	/* wake up the daemon to read what remains */
+	wake_up_buffer_waiter();
+out:
+	up(&start_sem);
+}
+
+
+void oprofile_shutdown(void)
+{
+	down(&start_sem);
+	sync_stop();
+	if (oprofile_ops.shutdown)
+		oprofile_ops.shutdown();
+	is_setup = 0;
+	free_event_buffer();
+	free_cpu_buffers();
+	up(&start_sem);
+}
+
+
+int oprofile_set_backtrace(unsigned long val)
+{
+	int err = 0;
+
+	down(&start_sem);
+
+	if (oprofile_started) {
+		err = -EBUSY;
+		goto out;
+	}
+
+	if (!oprofile_ops.backtrace) {
+		err = -EINVAL;
+		goto out;
+	}
+
+	backtrace_depth = val;
+
+out:
+	up(&start_sem);
+	return err;
+}
+
+static int __init oprofile_init(void)
+{
+	int err;
+
+	err = oprofile_arch_init(&oprofile_ops);
+
+	if (err < 0 || timer) {
+		printk(KERN_INFO "oprofile: using timer interrupt.\n");
+		oprofile_timer_init(&oprofile_ops);
+	}
+
+	err = oprofilefs_register();
+	if (err)
+		oprofile_arch_exit();
+
+	return err;
+}
+
+
+static void __exit oprofile_exit(void)
+{
+	oprofilefs_unregister();
+	oprofile_arch_exit();
+}
+
+ 
+module_init(oprofile_init);
+module_exit(oprofile_exit);
+
+module_param_named(timer, timer, int, 0644);
+MODULE_PARM_DESC(timer, "force use of timer interrupt");
+ 
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("John Levon <levon@movementarian.org>");
+MODULE_DESCRIPTION("OProfile system profiler");
