commit e48bbb52a2aad8613291a9e4e757bbf995769015
Author: Claudiu.Beznea@microchip.com <Claudiu.Beznea@microchip.com>
Date:   Tue Jan 21 10:03:39 2020 +0000

    power: reset: at91-reset: handle nrst async for sam9x60
    
    Handle NRST asynchronously for SAM9X60 to avoid problem with fast drop of
    VDDCORE on shutdown operations in the first 100 us after CPU is shutdown.
    
    Signed-off-by: Claudiu Beznea <claudiu.beznea@microchip.com>
    Signed-off-by: Sebastian Reichel <sebastian.reichel@collabora.com>

diff --git a/drivers/power/reset/at91-reset.c b/drivers/power/reset/at91-reset.c
index 537ccb180568..3ff9d93a5226 100644
--- a/drivers/power/reset/at91-reset.c
+++ b/drivers/power/reset/at91-reset.c
@@ -35,6 +35,7 @@
 
 #define AT91_RSTC_MR	0x08		/* Reset Controller Mode Register */
 #define AT91_RSTC_URSTEN	BIT(0)		/* User Reset Enable */
+#define AT91_RSTC_URSTASYNC	BIT(2)		/* User Reset Asynchronous Control */
 #define AT91_RSTC_URSTIEN	BIT(4)		/* User Reset Interrupt Enable */
 #define AT91_RSTC_ERSTL		GENMASK(11, 8)	/* External Reset Length */
 
@@ -228,6 +229,13 @@ static int __init at91_reset_probe(struct platform_device *pdev)
 
 	platform_set_drvdata(pdev, reset);
 
+	if (of_device_is_compatible(pdev->dev.of_node, "microchip,sam9x60-rstc")) {
+		u32 val = readl(reset->rstc_base + AT91_RSTC_MR);
+
+		writel(AT91_RSTC_KEY | AT91_RSTC_URSTASYNC | val,
+		       reset->rstc_base + AT91_RSTC_MR);
+	}
+
 	ret = register_restart_handler(&reset->nb);
 	if (ret) {
 		clk_disable_unprepare(reset->sclk);

commit 766b0162e613a89a330382e566e29da57f5f0de5
Author: Claudiu.Beznea@microchip.com <Claudiu.Beznea@microchip.com>
Date:   Tue Jan 21 10:03:39 2020 +0000

    power: reset: at91-reset: get rid of at91_reset_data
    
    After refactoring struct at91_reset_data and
    struct at91_reset_data at91sam9260_reset_data are not needed anymore.
    
    Signed-off-by: Claudiu Beznea <claudiu.beznea@microchip.com>
    Signed-off-by: Sebastian Reichel <sebastian.reichel@collabora.com>

diff --git a/drivers/power/reset/at91-reset.c b/drivers/power/reset/at91-reset.c
index 9c1b69f76a01..537ccb180568 100644
--- a/drivers/power/reset/at91-reset.c
+++ b/drivers/power/reset/at91-reset.c
@@ -49,10 +49,6 @@ enum reset_type {
 	RESET_TYPE_ULP2		= 8,
 };
 
-struct at91_reset_data {
-	u32 args;
-};
-
 struct at91_reset {
 	void __iomem *rstc_base;
 	void __iomem *ramc_base[2];
@@ -156,42 +152,29 @@ static const struct of_device_id at91_ramc_of_match[] = {
 	{ /* sentinel */ }
 };
 
-static const struct at91_reset_data at91sam9260_reset_data = {
-	.args = AT91_RSTC_KEY | AT91_RSTC_PERRST | AT91_RSTC_PROCRST,
-};
-
-static const struct at91_reset_data at91sam9g45_reset_data = {
-	.args = AT91_RSTC_KEY | AT91_RSTC_PERRST | AT91_RSTC_PROCRST,
-};
-
-static const struct at91_reset_data sama5d3_reset_data = {
-	.args = AT91_RSTC_KEY | AT91_RSTC_PERRST | AT91_RSTC_PROCRST,
-};
-
-static const struct at91_reset_data samx7_reset_data = {
-	.args = AT91_RSTC_KEY | AT91_RSTC_PROCRST,
-};
-
 static const struct of_device_id at91_reset_of_match[] = {
 	{
 		.compatible = "atmel,at91sam9260-rstc",
-		.data = &at91sam9260_reset_data
+		.data = (void *)(AT91_RSTC_KEY | AT91_RSTC_PERRST |
+				 AT91_RSTC_PROCRST),
 	},
 	{
 		.compatible = "atmel,at91sam9g45-rstc",
-		.data = &at91sam9g45_reset_data
+		.data = (void *)(AT91_RSTC_KEY | AT91_RSTC_PERRST |
+				 AT91_RSTC_PROCRST)
 	},
 	{
 		.compatible = "atmel,sama5d3-rstc",
-		.data = &sama5d3_reset_data
+		.data = (void *)(AT91_RSTC_KEY | AT91_RSTC_PERRST |
+				 AT91_RSTC_PROCRST)
 	},
 	{
 		.compatible = "atmel,samx7-rstc",
-		.data = &samx7_reset_data
+		.data = (void *)(AT91_RSTC_KEY | AT91_RSTC_PROCRST)
 	},
 	{
 		.compatible = "microchip,sam9x60-rstc",
-		.data = &samx7_reset_data
+		.data = (void *)(AT91_RSTC_KEY | AT91_RSTC_PROCRST)
 	},
 	{ /* sentinel */ }
 };
@@ -199,7 +182,6 @@ MODULE_DEVICE_TABLE(of, at91_reset_of_match);
 
 static int __init at91_reset_probe(struct platform_device *pdev)
 {
-	const struct at91_reset_data *reset_data;
 	const struct of_device_id *match;
 	struct at91_reset *reset;
 	struct device_node *np;
@@ -230,10 +212,9 @@ static int __init at91_reset_probe(struct platform_device *pdev)
 	}
 
 	match = of_match_node(at91_reset_of_match, pdev->dev.of_node);
-	reset_data = match->data;
 	reset->nb.notifier_call = at91_reset;
 	reset->nb.priority = 192;
-	reset->args = reset_data->args;
+	reset->args = (u32)match->data;
 
 	reset->sclk = devm_clk_get(&pdev->dev, NULL);
 	if (IS_ERR(reset->sclk))

commit 51aa7d45f905ca03d3c61d32a09537903a7ea707
Author: Claudiu.Beznea@microchip.com <Claudiu.Beznea@microchip.com>
Date:   Tue Jan 21 10:03:38 2020 +0000

    power: reset: at91-reset: keep only one reset function
    
    Keep only one reset function. With this, notifier_call member of
    struct at91_reset_data could be removed.
    
    Signed-off-by: Claudiu Beznea <claudiu.beznea@microchip.com>
    Signed-off-by: Sebastian Reichel <sebastian.reichel@collabora.com>

diff --git a/drivers/power/reset/at91-reset.c b/drivers/power/reset/at91-reset.c
index 61433060d784..9c1b69f76a01 100644
--- a/drivers/power/reset/at91-reset.c
+++ b/drivers/power/reset/at91-reset.c
@@ -50,8 +50,6 @@ enum reset_type {
 };
 
 struct at91_reset_data {
-	int (*notifier_call)(struct notifier_block *this, unsigned long mode,
-			     void *cmd);
 	u32 args;
 };
 
@@ -69,38 +67,8 @@ struct at91_reset {
 * reset register it can be left driving the data bus and
 * killing the chance of a subsequent boot from NAND
 */
-static int at91sam9260_restart(struct notifier_block *this, unsigned long mode,
-			       void *cmd)
-{
-	struct at91_reset *reset = container_of(this, struct at91_reset, nb);
-
-	asm volatile(
-		/* Align to cache lines */
-		".balign 32\n\t"
-
-		/* Disable SDRAM accesses */
-		"str	%2, [%0, #" __stringify(AT91_SDRAMC_TR) "]\n\t"
-
-		/* Power down SDRAM */
-		"str	%3, [%0, %5]\n\t"
-
-		/* Reset CPU */
-		"str	%4, [%1, #" __stringify(AT91_RSTC_CR) "]\n\t"
-
-		"b	.\n\t"
-		:
-		: "r" (reset->ramc_base[0]),
-		  "r" (reset->rstc_base),
-		  "r" (1),
-		  "r" cpu_to_le32(AT91_SDRAMC_LPCB_POWER_DOWN),
-		  "r" (reset->args),
-		  "r" (reset->ramc_lpr));
-
-	return NOTIFY_DONE;
-}
-
-static int at91sam9g45_restart(struct notifier_block *this, unsigned long mode,
-			       void *cmd)
+static int at91_reset(struct notifier_block *this, unsigned long mode,
+		      void *cmd)
 {
 	struct at91_reset *reset = container_of(this, struct at91_reset, nb);
 
@@ -137,16 +105,6 @@ static int at91sam9g45_restart(struct notifier_block *this, unsigned long mode,
 	return NOTIFY_DONE;
 }
 
-static int sama5d3_restart(struct notifier_block *this, unsigned long mode,
-			   void *cmd)
-{
-	struct at91_reset *reset = container_of(this, struct at91_reset, nb);
-
-	writel(reset->args, reset->rstc_base);
-
-	return NOTIFY_DONE;
-}
-
 static void __init at91_reset_status(struct platform_device *pdev,
 				     void __iomem *base)
 {
@@ -199,22 +157,18 @@ static const struct of_device_id at91_ramc_of_match[] = {
 };
 
 static const struct at91_reset_data at91sam9260_reset_data = {
-	.notifier_call = at91sam9260_restart,
 	.args = AT91_RSTC_KEY | AT91_RSTC_PERRST | AT91_RSTC_PROCRST,
 };
 
 static const struct at91_reset_data at91sam9g45_reset_data = {
-	.notifier_call = at91sam9g45_restart,
 	.args = AT91_RSTC_KEY | AT91_RSTC_PERRST | AT91_RSTC_PROCRST,
 };
 
 static const struct at91_reset_data sama5d3_reset_data = {
-	.notifier_call = sama5d3_restart,
 	.args = AT91_RSTC_KEY | AT91_RSTC_PERRST | AT91_RSTC_PROCRST,
 };
 
 static const struct at91_reset_data samx7_reset_data = {
-	.notifier_call = sama5d3_restart,
 	.args = AT91_RSTC_KEY | AT91_RSTC_PROCRST,
 };
 
@@ -277,7 +231,7 @@ static int __init at91_reset_probe(struct platform_device *pdev)
 
 	match = of_match_node(at91_reset_of_match, pdev->dev.of_node);
 	reset_data = match->data;
-	reset->nb.notifier_call = reset_data->notifier_call;
+	reset->nb.notifier_call = at91_reset;
 	reset->nb.priority = 192;
 	reset->args = reset_data->args;
 

commit fcd0532fac2ac82cec6d7b43298c8ecfc93e1049
Author: Claudiu.Beznea@microchip.com <Claudiu.Beznea@microchip.com>
Date:   Tue Jan 21 10:03:37 2020 +0000

    power: reset: at91-reset: make at91sam9g45_restart() generic
    
    Make at91sam9g45_restart() generic.
    
    Signed-off-by: Claudiu Beznea <claudiu.beznea@microchip.com>
    Signed-off-by: Sebastian Reichel <sebastian.reichel@collabora.com>

diff --git a/drivers/power/reset/at91-reset.c b/drivers/power/reset/at91-reset.c
index 4e1961334e4d..61433060d784 100644
--- a/drivers/power/reset/at91-reset.c
+++ b/drivers/power/reset/at91-reset.c
@@ -105,32 +105,23 @@ static int at91sam9g45_restart(struct notifier_block *this, unsigned long mode,
 	struct at91_reset *reset = container_of(this, struct at91_reset, nb);
 
 	asm volatile(
-		/*
-		 * Test wether we have a second RAM controller to care
-		 * about.
-		 *
-		 * First, test that we can dereference the virtual address.
-		 */
-		"cmp	%1, #0\n\t"
-		"beq	1f\n\t"
-
-		/* Then, test that the RAM controller is enabled */
-		"ldr	r4, [%1]\n\t"
-		"cmp	r4, #0\n\t"
-
 		/* Align to cache lines */
 		".balign 32\n\t"
 
 		/* Disable SDRAM0 accesses */
-		"1:	str	%3, [%0, #" __stringify(AT91_DDRSDRC_RTR) "]\n\t"
+		"	tst	%0, #0\n\t"
+		"	beq	1f\n\t"
+		"	str	%3, [%0, #" __stringify(AT91_DDRSDRC_RTR) "]\n\t"
 		/* Power down SDRAM0 */
 		"	str	%4, [%0, %6]\n\t"
 		/* Disable SDRAM1 accesses */
+		"1:	tst	%1, #0\n\t"
+		"	beq	2f\n\t"
 		"	strne	%3, [%1, #" __stringify(AT91_DDRSDRC_RTR) "]\n\t"
 		/* Power down SDRAM1 */
 		"	strne	%4, [%1, %6]\n\t"
 		/* Reset CPU */
-		"	str	%5, [%2, #" __stringify(AT91_RSTC_CR) "]\n\t"
+		"2:	str	%5, [%2, #" __stringify(AT91_RSTC_CR) "]\n\t"
 
 		"	b	.\n\t"
 		:

commit 68a84a3e68a2238036dd6c7dbb677fe62a92d70a
Author: Claudiu.Beznea@microchip.com <Claudiu.Beznea@microchip.com>
Date:   Tue Jan 21 10:03:34 2020 +0000

    power: reset: at91-reset: introduce ramc_lpr to struct at91_reset
    
    Introduce ramc_lpr to struct at91_reset. This will lead to the
    unification of at91sam9260_restart() and at91sam9g45_restart().
    
    Signed-off-by: Claudiu Beznea <claudiu.beznea@microchip.com>
    Signed-off-by: Sebastian Reichel <sebastian.reichel@collabora.com>

diff --git a/drivers/power/reset/at91-reset.c b/drivers/power/reset/at91-reset.c
index 3b1d566350f4..4e1961334e4d 100644
--- a/drivers/power/reset/at91-reset.c
+++ b/drivers/power/reset/at91-reset.c
@@ -61,6 +61,7 @@ struct at91_reset {
 	struct clk *sclk;
 	struct notifier_block nb;
 	u32 args;
+	u32 ramc_lpr;
 };
 
 /*
@@ -81,7 +82,7 @@ static int at91sam9260_restart(struct notifier_block *this, unsigned long mode,
 		"str	%2, [%0, #" __stringify(AT91_SDRAMC_TR) "]\n\t"
 
 		/* Power down SDRAM */
-		"str	%3, [%0, #" __stringify(AT91_SDRAMC_LPR) "]\n\t"
+		"str	%3, [%0, %5]\n\t"
 
 		/* Reset CPU */
 		"str	%4, [%1, #" __stringify(AT91_RSTC_CR) "]\n\t"
@@ -92,7 +93,8 @@ static int at91sam9260_restart(struct notifier_block *this, unsigned long mode,
 		  "r" (reset->rstc_base),
 		  "r" (1),
 		  "r" cpu_to_le32(AT91_SDRAMC_LPCB_POWER_DOWN),
-		  "r" (reset->args));
+		  "r" (reset->args),
+		  "r" (reset->ramc_lpr));
 
 	return NOTIFY_DONE;
 }
@@ -122,11 +124,11 @@ static int at91sam9g45_restart(struct notifier_block *this, unsigned long mode,
 		/* Disable SDRAM0 accesses */
 		"1:	str	%3, [%0, #" __stringify(AT91_DDRSDRC_RTR) "]\n\t"
 		/* Power down SDRAM0 */
-		"	str	%4, [%0, #" __stringify(AT91_DDRSDRC_LPR) "]\n\t"
+		"	str	%4, [%0, %6]\n\t"
 		/* Disable SDRAM1 accesses */
 		"	strne	%3, [%1, #" __stringify(AT91_DDRSDRC_RTR) "]\n\t"
 		/* Power down SDRAM1 */
-		"	strne	%4, [%1, #" __stringify(AT91_DDRSDRC_LPR) "]\n\t"
+		"	strne	%4, [%1, %6]\n\t"
 		/* Reset CPU */
 		"	str	%5, [%2, #" __stringify(AT91_RSTC_CR) "]\n\t"
 
@@ -137,7 +139,8 @@ static int at91sam9g45_restart(struct notifier_block *this, unsigned long mode,
 		  "r" (reset->rstc_base),
 		  "r" (1),
 		  "r" cpu_to_le32(AT91_DDRSDRC_LPCB_POWER_DOWN),
-		  "r" (reset->args)
+		  "r" (reset->args),
+		  "r" (reset->ramc_lpr)
 		: "r4");
 
 	return NOTIFY_DONE;
@@ -193,8 +196,14 @@ static void __init at91_reset_status(struct platform_device *pdev,
 }
 
 static const struct of_device_id at91_ramc_of_match[] = {
-	{ .compatible = "atmel,at91sam9260-sdramc", },
-	{ .compatible = "atmel,at91sam9g45-ddramc", },
+	{
+		.compatible = "atmel,at91sam9260-sdramc",
+		.data = (void *)AT91_SDRAMC_LPR,
+	},
+	{
+		.compatible = "atmel,at91sam9g45-ddramc",
+		.data = (void *)AT91_DDRSDRC_LPR,
+	},
 	{ /* sentinel */ }
 };
 
@@ -263,7 +272,8 @@ static int __init at91_reset_probe(struct platform_device *pdev)
 
 	if (!of_device_is_compatible(pdev->dev.of_node, "atmel,sama5d3-rstc")) {
 		/* we need to shutdown the ddr controller, so get ramc base */
-		for_each_matching_node(np, at91_ramc_of_match) {
+		for_each_matching_node_and_match(np, at91_ramc_of_match, &match) {
+			reset->ramc_lpr = (u32)match->data;
 			reset->ramc_base[idx] = of_iomap(np, 0);
 			if (!reset->ramc_base[idx]) {
 				dev_err(&pdev->dev, "Could not map ram controller address\n");

commit 7cb290d3dd559dff5028b9418a31ecb99988f640
Author: Claudiu.Beznea@microchip.com <Claudiu.Beznea@microchip.com>
Date:   Tue Jan 21 10:03:33 2020 +0000

    power: reset: at91-reset: use r4 as tmp argument
    
    Use r4 as temporary register. On ARM r0-r3 should be used to hold
    function arguments.
    
    Signed-off-by: Claudiu Beznea <claudiu.beznea@microchip.com>
    Signed-off-by: Sebastian Reichel <sebastian.reichel@collabora.com>

diff --git a/drivers/power/reset/at91-reset.c b/drivers/power/reset/at91-reset.c
index dc48f6850796..3b1d566350f4 100644
--- a/drivers/power/reset/at91-reset.c
+++ b/drivers/power/reset/at91-reset.c
@@ -113,8 +113,8 @@ static int at91sam9g45_restart(struct notifier_block *this, unsigned long mode,
 		"beq	1f\n\t"
 
 		/* Then, test that the RAM controller is enabled */
-		"ldr	r0, [%1]\n\t"
-		"cmp	r0, #0\n\t"
+		"ldr	r4, [%1]\n\t"
+		"cmp	r4, #0\n\t"
 
 		/* Align to cache lines */
 		".balign 32\n\t"
@@ -138,7 +138,7 @@ static int at91sam9g45_restart(struct notifier_block *this, unsigned long mode,
 		  "r" (1),
 		  "r" cpu_to_le32(AT91_DDRSDRC_LPCB_POWER_DOWN),
 		  "r" (reset->args)
-		: "r0");
+		: "r4");
 
 	return NOTIFY_DONE;
 }

commit 25b80b7d5a5b41cb52db441e37a04d71e7196f60
Author: Claudiu.Beznea@microchip.com <Claudiu.Beznea@microchip.com>
Date:   Tue Jan 21 10:03:33 2020 +0000

    power: reset: at91-reset: introduce args member in at91_reset_data
    
    Introduce args member in struct at91_reset_data. It stores the value
    that needs to be written in mode register so that the reboot actions
    to happen. With these changes samx7_restart() could be removed.
    
    Signed-off-by: Claudiu Beznea <claudiu.beznea@microchip.com>
    Signed-off-by: Sebastian Reichel <sebastian.reichel@collabora.com>

diff --git a/drivers/power/reset/at91-reset.c b/drivers/power/reset/at91-reset.c
index c653bd7ac29a..dc48f6850796 100644
--- a/drivers/power/reset/at91-reset.c
+++ b/drivers/power/reset/at91-reset.c
@@ -52,6 +52,7 @@ enum reset_type {
 struct at91_reset_data {
 	int (*notifier_call)(struct notifier_block *this, unsigned long mode,
 			     void *cmd);
+	u32 args;
 };
 
 struct at91_reset {
@@ -59,6 +60,7 @@ struct at91_reset {
 	void __iomem *ramc_base[2];
 	struct clk *sclk;
 	struct notifier_block nb;
+	u32 args;
 };
 
 /*
@@ -90,7 +92,7 @@ static int at91sam9260_restart(struct notifier_block *this, unsigned long mode,
 		  "r" (reset->rstc_base),
 		  "r" (1),
 		  "r" cpu_to_le32(AT91_SDRAMC_LPCB_POWER_DOWN),
-		  "r" cpu_to_le32(AT91_RSTC_KEY | AT91_RSTC_PERRST | AT91_RSTC_PROCRST));
+		  "r" (reset->args));
 
 	return NOTIFY_DONE;
 }
@@ -135,7 +137,7 @@ static int at91sam9g45_restart(struct notifier_block *this, unsigned long mode,
 		  "r" (reset->rstc_base),
 		  "r" (1),
 		  "r" cpu_to_le32(AT91_DDRSDRC_LPCB_POWER_DOWN),
-		  "r" cpu_to_le32(AT91_RSTC_KEY | AT91_RSTC_PERRST | AT91_RSTC_PROCRST)
+		  "r" (reset->args)
 		: "r0");
 
 	return NOTIFY_DONE;
@@ -146,19 +148,7 @@ static int sama5d3_restart(struct notifier_block *this, unsigned long mode,
 {
 	struct at91_reset *reset = container_of(this, struct at91_reset, nb);
 
-	writel(cpu_to_le32(AT91_RSTC_KEY | AT91_RSTC_PERRST | AT91_RSTC_PROCRST),
-	       reset->rstc_base);
-
-	return NOTIFY_DONE;
-}
-
-static int samx7_restart(struct notifier_block *this, unsigned long mode,
-			 void *cmd)
-{
-	struct at91_reset *reset = container_of(this, struct at91_reset, nb);
-
-	writel(cpu_to_le32(AT91_RSTC_KEY | AT91_RSTC_PROCRST),
-	       reset->rstc_base);
+	writel(reset->args, reset->rstc_base);
 
 	return NOTIFY_DONE;
 }
@@ -210,18 +200,22 @@ static const struct of_device_id at91_ramc_of_match[] = {
 
 static const struct at91_reset_data at91sam9260_reset_data = {
 	.notifier_call = at91sam9260_restart,
+	.args = AT91_RSTC_KEY | AT91_RSTC_PERRST | AT91_RSTC_PROCRST,
 };
 
 static const struct at91_reset_data at91sam9g45_reset_data = {
 	.notifier_call = at91sam9g45_restart,
+	.args = AT91_RSTC_KEY | AT91_RSTC_PERRST | AT91_RSTC_PROCRST,
 };
 
 static const struct at91_reset_data sama5d3_reset_data = {
 	.notifier_call = sama5d3_restart,
+	.args = AT91_RSTC_KEY | AT91_RSTC_PERRST | AT91_RSTC_PROCRST,
 };
 
 static const struct at91_reset_data samx7_reset_data = {
-	.notifier_call = samx7_restart,
+	.notifier_call = sama5d3_restart,
+	.args = AT91_RSTC_KEY | AT91_RSTC_PROCRST,
 };
 
 static const struct of_device_id at91_reset_of_match[] = {
@@ -284,6 +278,7 @@ static int __init at91_reset_probe(struct platform_device *pdev)
 	reset_data = match->data;
 	reset->nb.notifier_call = reset_data->notifier_call;
 	reset->nb.priority = 192;
+	reset->args = reset_data->args;
 
 	reset->sclk = devm_clk_get(&pdev->dev, NULL);
 	if (IS_ERR(reset->sclk))

commit a5bbad258a9ec41df4a158c828b9ef0af7955854
Author: Claudiu.Beznea@microchip.com <Claudiu.Beznea@microchip.com>
Date:   Tue Jan 21 10:03:32 2020 +0000

    power: reset: at91-reset: introduce struct at91_reset_data
    
    Introduce struct at91_reset_data to be able to provide per SoC
    data. At the moment this being only notifier callback.
    
    Signed-off-by: Claudiu Beznea <claudiu.beznea@microchip.com>
    Signed-off-by: Sebastian Reichel <sebastian.reichel@collabora.com>

diff --git a/drivers/power/reset/at91-reset.c b/drivers/power/reset/at91-reset.c
index 7ba77555e9e1..c653bd7ac29a 100644
--- a/drivers/power/reset/at91-reset.c
+++ b/drivers/power/reset/at91-reset.c
@@ -49,6 +49,11 @@ enum reset_type {
 	RESET_TYPE_ULP2		= 8,
 };
 
+struct at91_reset_data {
+	int (*notifier_call)(struct notifier_block *this, unsigned long mode,
+			     void *cmd);
+};
+
 struct at91_reset {
 	void __iomem *rstc_base;
 	void __iomem *ramc_base[2];
@@ -203,18 +208,50 @@ static const struct of_device_id at91_ramc_of_match[] = {
 	{ /* sentinel */ }
 };
 
+static const struct at91_reset_data at91sam9260_reset_data = {
+	.notifier_call = at91sam9260_restart,
+};
+
+static const struct at91_reset_data at91sam9g45_reset_data = {
+	.notifier_call = at91sam9g45_restart,
+};
+
+static const struct at91_reset_data sama5d3_reset_data = {
+	.notifier_call = sama5d3_restart,
+};
+
+static const struct at91_reset_data samx7_reset_data = {
+	.notifier_call = samx7_restart,
+};
+
 static const struct of_device_id at91_reset_of_match[] = {
-	{ .compatible = "atmel,at91sam9260-rstc", .data = at91sam9260_restart },
-	{ .compatible = "atmel,at91sam9g45-rstc", .data = at91sam9g45_restart },
-	{ .compatible = "atmel,sama5d3-rstc", .data = sama5d3_restart },
-	{ .compatible = "atmel,samx7-rstc", .data = samx7_restart },
-	{ .compatible = "microchip,sam9x60-rstc", .data = samx7_restart },
+	{
+		.compatible = "atmel,at91sam9260-rstc",
+		.data = &at91sam9260_reset_data
+	},
+	{
+		.compatible = "atmel,at91sam9g45-rstc",
+		.data = &at91sam9g45_reset_data
+	},
+	{
+		.compatible = "atmel,sama5d3-rstc",
+		.data = &sama5d3_reset_data
+	},
+	{
+		.compatible = "atmel,samx7-rstc",
+		.data = &samx7_reset_data
+	},
+	{
+		.compatible = "microchip,sam9x60-rstc",
+		.data = &samx7_reset_data
+	},
 	{ /* sentinel */ }
 };
 MODULE_DEVICE_TABLE(of, at91_reset_of_match);
 
 static int __init at91_reset_probe(struct platform_device *pdev)
 {
+	const struct at91_reset_data *reset_data;
 	const struct of_device_id *match;
 	struct at91_reset *reset;
 	struct device_node *np;
@@ -244,7 +281,8 @@ static int __init at91_reset_probe(struct platform_device *pdev)
 	}
 
 	match = of_match_node(at91_reset_of_match, pdev->dev.of_node);
-	reset->nb.notifier_call = match->data;
+	reset_data = match->data;
+	reset->nb.notifier_call = reset_data->notifier_call;
 	reset->nb.priority = 192;
 
 	reset->sclk = devm_clk_get(&pdev->dev, NULL);

commit 583ef884c8dc8e5ec9a7fde12d40ef7fdf18f5fb
Author: Claudiu.Beznea@microchip.com <Claudiu.Beznea@microchip.com>
Date:   Tue Jan 21 10:03:32 2020 +0000

    power: reset: at91-reset: devm_kzalloc() for at91_reset data structure
    
    Allocate at91_reset data on probe and set it as platform data.
    
    Signed-off-by: Claudiu Beznea <claudiu.beznea@microchip.com>
    Signed-off-by: Sebastian Reichel <sebastian.reichel@collabora.com>

diff --git a/drivers/power/reset/at91-reset.c b/drivers/power/reset/at91-reset.c
index bd05496c5ac7..7ba77555e9e1 100644
--- a/drivers/power/reset/at91-reset.c
+++ b/drivers/power/reset/at91-reset.c
@@ -56,8 +56,6 @@ struct at91_reset {
 	struct notifier_block nb;
 };
 
-static struct at91_reset *reset;
-
 /*
 * unless the SDRAM is cleanly shutdown before we hit the
 * reset register it can be left driving the data bus and
@@ -66,6 +64,8 @@ static struct at91_reset *reset;
 static int at91sam9260_restart(struct notifier_block *this, unsigned long mode,
 			       void *cmd)
 {
+	struct at91_reset *reset = container_of(this, struct at91_reset, nb);
+
 	asm volatile(
 		/* Align to cache lines */
 		".balign 32\n\t"
@@ -93,6 +93,8 @@ static int at91sam9260_restart(struct notifier_block *this, unsigned long mode,
 static int at91sam9g45_restart(struct notifier_block *this, unsigned long mode,
 			       void *cmd)
 {
+	struct at91_reset *reset = container_of(this, struct at91_reset, nb);
+
 	asm volatile(
 		/*
 		 * Test wether we have a second RAM controller to care
@@ -137,6 +139,8 @@ static int at91sam9g45_restart(struct notifier_block *this, unsigned long mode,
 static int sama5d3_restart(struct notifier_block *this, unsigned long mode,
 			   void *cmd)
 {
+	struct at91_reset *reset = container_of(this, struct at91_reset, nb);
+
 	writel(cpu_to_le32(AT91_RSTC_KEY | AT91_RSTC_PERRST | AT91_RSTC_PROCRST),
 	       reset->rstc_base);
 
@@ -146,6 +150,8 @@ static int sama5d3_restart(struct notifier_block *this, unsigned long mode,
 static int samx7_restart(struct notifier_block *this, unsigned long mode,
 			 void *cmd)
 {
+	struct at91_reset *reset = container_of(this, struct at91_reset, nb);
+
 	writel(cpu_to_le32(AT91_RSTC_KEY | AT91_RSTC_PROCRST),
 	       reset->rstc_base);
 
@@ -210,6 +216,7 @@ MODULE_DEVICE_TABLE(of, at91_reset_of_match);
 static int __init at91_reset_probe(struct platform_device *pdev)
 {
 	const struct of_device_id *match;
+	struct at91_reset *reset;
 	struct device_node *np;
 	int ret, idx = 0;
 
@@ -250,6 +257,8 @@ static int __init at91_reset_probe(struct platform_device *pdev)
 		return ret;
 	}
 
+	platform_set_drvdata(pdev, reset);
+
 	ret = register_restart_handler(&reset->nb);
 	if (ret) {
 		clk_disable_unprepare(reset->sclk);
@@ -263,6 +272,8 @@ static int __init at91_reset_probe(struct platform_device *pdev)
 
 static int __exit at91_reset_remove(struct platform_device *pdev)
 {
+	struct at91_reset *reset = platform_get_drvdata(pdev);
+
 	unregister_restart_handler(&reset->nb);
 	clk_disable_unprepare(reset->sclk);
 

commit 55f8e6fdefbe926e1729bba3a7608eed7d7f24f5
Author: Claudiu.Beznea@microchip.com <Claudiu.Beznea@microchip.com>
Date:   Tue Jan 21 10:03:32 2020 +0000

    power: reset: at91-reset: pass rstc base address to at91_reset_status()
    
    Add new argument to at91_reset_status() that is the pointer to reset
    controller base address.
    
    Signed-off-by: Claudiu Beznea <claudiu.beznea@microchip.com>
    Signed-off-by: Sebastian Reichel <sebastian.reichel@collabora.com>

diff --git a/drivers/power/reset/at91-reset.c b/drivers/power/reset/at91-reset.c
index 4bb5eef4b258..bd05496c5ac7 100644
--- a/drivers/power/reset/at91-reset.c
+++ b/drivers/power/reset/at91-reset.c
@@ -152,10 +152,11 @@ static int samx7_restart(struct notifier_block *this, unsigned long mode,
 	return NOTIFY_DONE;
 }
 
-static void __init at91_reset_status(struct platform_device *pdev)
+static void __init at91_reset_status(struct platform_device *pdev,
+				     void __iomem *base)
 {
 	const char *reason;
-	u32 reg = readl(reset->rstc_base + AT91_RSTC_SR);
+	u32 reg = readl(base + AT91_RSTC_SR);
 
 	switch ((reg & AT91_RSTC_RSTTYP) >> 8) {
 	case RESET_TYPE_GENERAL:
@@ -255,7 +256,7 @@ static int __init at91_reset_probe(struct platform_device *pdev)
 		return ret;
 	}
 
-	at91_reset_status(pdev);
+	at91_reset_status(pdev, reset->rstc_base);
 
 	return 0;
 }

commit b7967b7919f0e3787d6e23424b5ad367fbb937e2
Author: Claudiu.Beznea@microchip.com <Claudiu.Beznea@microchip.com>
Date:   Tue Jan 21 10:03:31 2020 +0000

    power: reset: at91-reset: convert reset in pointer to struct at91_reset
    
    Convert reset in pointer to struct at91_reset.
    
    Signed-off-by: Claudiu Beznea <claudiu.beznea@microchip.com>
    Signed-off-by: Sebastian Reichel <sebastian.reichel@collabora.com>

diff --git a/drivers/power/reset/at91-reset.c b/drivers/power/reset/at91-reset.c
index e8840193620d..4bb5eef4b258 100644
--- a/drivers/power/reset/at91-reset.c
+++ b/drivers/power/reset/at91-reset.c
@@ -56,7 +56,7 @@ struct at91_reset {
 	struct notifier_block nb;
 };
 
-static struct at91_reset reset;
+static struct at91_reset *reset;
 
 /*
 * unless the SDRAM is cleanly shutdown before we hit the
@@ -81,8 +81,8 @@ static int at91sam9260_restart(struct notifier_block *this, unsigned long mode,
 
 		"b	.\n\t"
 		:
-		: "r" (reset.ramc_base[0]),
-		  "r" (reset.rstc_base),
+		: "r" (reset->ramc_base[0]),
+		  "r" (reset->rstc_base),
 		  "r" (1),
 		  "r" cpu_to_le32(AT91_SDRAMC_LPCB_POWER_DOWN),
 		  "r" cpu_to_le32(AT91_RSTC_KEY | AT91_RSTC_PERRST | AT91_RSTC_PROCRST));
@@ -123,9 +123,9 @@ static int at91sam9g45_restart(struct notifier_block *this, unsigned long mode,
 
 		"	b	.\n\t"
 		:
-		: "r" (reset.ramc_base[0]),
-		  "r" (reset.ramc_base[1]),
-		  "r" (reset.rstc_base),
+		: "r" (reset->ramc_base[0]),
+		  "r" (reset->ramc_base[1]),
+		  "r" (reset->rstc_base),
 		  "r" (1),
 		  "r" cpu_to_le32(AT91_DDRSDRC_LPCB_POWER_DOWN),
 		  "r" cpu_to_le32(AT91_RSTC_KEY | AT91_RSTC_PERRST | AT91_RSTC_PROCRST)
@@ -138,7 +138,7 @@ static int sama5d3_restart(struct notifier_block *this, unsigned long mode,
 			   void *cmd)
 {
 	writel(cpu_to_le32(AT91_RSTC_KEY | AT91_RSTC_PERRST | AT91_RSTC_PROCRST),
-	       reset.rstc_base);
+	       reset->rstc_base);
 
 	return NOTIFY_DONE;
 }
@@ -147,7 +147,7 @@ static int samx7_restart(struct notifier_block *this, unsigned long mode,
 			 void *cmd)
 {
 	writel(cpu_to_le32(AT91_RSTC_KEY | AT91_RSTC_PROCRST),
-	       reset.rstc_base);
+	       reset->rstc_base);
 
 	return NOTIFY_DONE;
 }
@@ -155,7 +155,7 @@ static int samx7_restart(struct notifier_block *this, unsigned long mode,
 static void __init at91_reset_status(struct platform_device *pdev)
 {
 	const char *reason;
-	u32 reg = readl(reset.rstc_base + AT91_RSTC_SR);
+	u32 reg = readl(reset->rstc_base + AT91_RSTC_SR);
 
 	switch ((reg & AT91_RSTC_RSTTYP) >> 8) {
 	case RESET_TYPE_GENERAL:
@@ -212,8 +212,12 @@ static int __init at91_reset_probe(struct platform_device *pdev)
 	struct device_node *np;
 	int ret, idx = 0;
 
-	reset.rstc_base = of_iomap(pdev->dev.of_node, 0);
-	if (!reset.rstc_base) {
+	reset = devm_kzalloc(&pdev->dev, sizeof(*reset), GFP_KERNEL);
+	if (!reset)
+		return -ENOMEM;
+
+	reset->rstc_base = of_iomap(pdev->dev.of_node, 0);
+	if (!reset->rstc_base) {
 		dev_err(&pdev->dev, "Could not map reset controller address\n");
 		return -ENODEV;
 	}
@@ -221,8 +225,8 @@ static int __init at91_reset_probe(struct platform_device *pdev)
 	if (!of_device_is_compatible(pdev->dev.of_node, "atmel,sama5d3-rstc")) {
 		/* we need to shutdown the ddr controller, so get ramc base */
 		for_each_matching_node(np, at91_ramc_of_match) {
-			reset.ramc_base[idx] = of_iomap(np, 0);
-			if (!reset.ramc_base[idx]) {
+			reset->ramc_base[idx] = of_iomap(np, 0);
+			if (!reset->ramc_base[idx]) {
 				dev_err(&pdev->dev, "Could not map ram controller address\n");
 				of_node_put(np);
 				return -ENODEV;
@@ -232,22 +236,22 @@ static int __init at91_reset_probe(struct platform_device *pdev)
 	}
 
 	match = of_match_node(at91_reset_of_match, pdev->dev.of_node);
-	reset.nb.notifier_call = match->data;
-	reset.nb.priority = 192;
+	reset->nb.notifier_call = match->data;
+	reset->nb.priority = 192;
 
-	reset.sclk = devm_clk_get(&pdev->dev, NULL);
-	if (IS_ERR(reset.sclk))
-		return PTR_ERR(reset.sclk);
+	reset->sclk = devm_clk_get(&pdev->dev, NULL);
+	if (IS_ERR(reset->sclk))
+		return PTR_ERR(reset->sclk);
 
-	ret = clk_prepare_enable(reset.sclk);
+	ret = clk_prepare_enable(reset->sclk);
 	if (ret) {
 		dev_err(&pdev->dev, "Could not enable slow clock\n");
 		return ret;
 	}
 
-	ret = register_restart_handler(&reset.nb);
+	ret = register_restart_handler(&reset->nb);
 	if (ret) {
-		clk_disable_unprepare(reset.sclk);
+		clk_disable_unprepare(reset->sclk);
 		return ret;
 	}
 
@@ -258,8 +262,8 @@ static int __init at91_reset_probe(struct platform_device *pdev)
 
 static int __exit at91_reset_remove(struct platform_device *pdev)
 {
-	unregister_restart_handler(&reset.nb);
-	clk_disable_unprepare(reset.sclk);
+	unregister_restart_handler(&reset->nb);
+	clk_disable_unprepare(reset->sclk);
 
 	return 0;
 }

commit 1e3c4af9de26a0246cf00aba207c49846e80c37b
Author: Claudiu.Beznea@microchip.com <Claudiu.Beznea@microchip.com>
Date:   Tue Jan 21 10:03:31 2020 +0000

    power: reset: at91-reset: add notifier block to struct at91_reset
    
    Add struct notifier_block to struct at91_reset.
    
    Signed-off-by: Claudiu Beznea <claudiu.beznea@microchip.com>
    Signed-off-by: Sebastian Reichel <sebastian.reichel@collabora.com>

diff --git a/drivers/power/reset/at91-reset.c b/drivers/power/reset/at91-reset.c
index 1bc39bfda0aa..e8840193620d 100644
--- a/drivers/power/reset/at91-reset.c
+++ b/drivers/power/reset/at91-reset.c
@@ -53,6 +53,7 @@ struct at91_reset {
 	void __iomem *rstc_base;
 	void __iomem *ramc_base[2];
 	struct clk *sclk;
+	struct notifier_block nb;
 };
 
 static struct at91_reset reset;
@@ -205,10 +206,6 @@ static const struct of_device_id at91_reset_of_match[] = {
 };
 MODULE_DEVICE_TABLE(of, at91_reset_of_match);
 
-static struct notifier_block at91_restart_nb = {
-	.priority = 192,
-};
-
 static int __init at91_reset_probe(struct platform_device *pdev)
 {
 	const struct of_device_id *match;
@@ -235,7 +232,8 @@ static int __init at91_reset_probe(struct platform_device *pdev)
 	}
 
 	match = of_match_node(at91_reset_of_match, pdev->dev.of_node);
-	at91_restart_nb.notifier_call = match->data;
+	reset.nb.notifier_call = match->data;
+	reset.nb.priority = 192;
 
 	reset.sclk = devm_clk_get(&pdev->dev, NULL);
 	if (IS_ERR(reset.sclk))
@@ -247,7 +245,7 @@ static int __init at91_reset_probe(struct platform_device *pdev)
 		return ret;
 	}
 
-	ret = register_restart_handler(&at91_restart_nb);
+	ret = register_restart_handler(&reset.nb);
 	if (ret) {
 		clk_disable_unprepare(reset.sclk);
 		return ret;
@@ -260,7 +258,7 @@ static int __init at91_reset_probe(struct platform_device *pdev)
 
 static int __exit at91_reset_remove(struct platform_device *pdev)
 {
-	unregister_restart_handler(&at91_restart_nb);
+	unregister_restart_handler(&reset.nb);
 	clk_disable_unprepare(reset.sclk);
 
 	return 0;

commit f9e6ce74cbf2a34f4d37bccbbfc7865e5b3e01dd
Author: Claudiu.Beznea@microchip.com <Claudiu.Beznea@microchip.com>
Date:   Tue Jan 21 10:03:30 2020 +0000

    power: reset: at91-reset: add sclk to struct at91_reset
    
    Add sclk to struct at91_reset.
    
    Signed-off-by: Claudiu Beznea <claudiu.beznea@microchip.com>
    Signed-off-by: Sebastian Reichel <sebastian.reichel@collabora.com>

diff --git a/drivers/power/reset/at91-reset.c b/drivers/power/reset/at91-reset.c
index 999d3a1653d2..1bc39bfda0aa 100644
--- a/drivers/power/reset/at91-reset.c
+++ b/drivers/power/reset/at91-reset.c
@@ -52,12 +52,11 @@ enum reset_type {
 struct at91_reset {
 	void __iomem *rstc_base;
 	void __iomem *ramc_base[2];
+	struct clk *sclk;
 };
 
 static struct at91_reset reset;
 
-static struct clk *sclk;
-
 /*
 * unless the SDRAM is cleanly shutdown before we hit the
 * reset register it can be left driving the data bus and
@@ -238,11 +237,11 @@ static int __init at91_reset_probe(struct platform_device *pdev)
 	match = of_match_node(at91_reset_of_match, pdev->dev.of_node);
 	at91_restart_nb.notifier_call = match->data;
 
-	sclk = devm_clk_get(&pdev->dev, NULL);
-	if (IS_ERR(sclk))
-		return PTR_ERR(sclk);
+	reset.sclk = devm_clk_get(&pdev->dev, NULL);
+	if (IS_ERR(reset.sclk))
+		return PTR_ERR(reset.sclk);
 
-	ret = clk_prepare_enable(sclk);
+	ret = clk_prepare_enable(reset.sclk);
 	if (ret) {
 		dev_err(&pdev->dev, "Could not enable slow clock\n");
 		return ret;
@@ -250,7 +249,7 @@ static int __init at91_reset_probe(struct platform_device *pdev)
 
 	ret = register_restart_handler(&at91_restart_nb);
 	if (ret) {
-		clk_disable_unprepare(sclk);
+		clk_disable_unprepare(reset.sclk);
 		return ret;
 	}
 
@@ -262,7 +261,7 @@ static int __init at91_reset_probe(struct platform_device *pdev)
 static int __exit at91_reset_remove(struct platform_device *pdev)
 {
 	unregister_restart_handler(&at91_restart_nb);
-	clk_disable_unprepare(sclk);
+	clk_disable_unprepare(reset.sclk);
 
 	return 0;
 }

commit 4d9ce0f56aeeb46c8be0e8974646f163d3f6b72d
Author: Claudiu.Beznea@microchip.com <Claudiu.Beznea@microchip.com>
Date:   Tue Jan 21 10:03:30 2020 +0000

    power: reset: at91-reset: add ramc_base[] to struct at91_reset
    
    Add ramc_base[] to struct at91_reset.
    
    Signed-off-by: Claudiu Beznea <claudiu.beznea@microchip.com>
    Signed-off-by: Sebastian Reichel <sebastian.reichel@collabora.com>

diff --git a/drivers/power/reset/at91-reset.c b/drivers/power/reset/at91-reset.c
index 2df0610e5527..999d3a1653d2 100644
--- a/drivers/power/reset/at91-reset.c
+++ b/drivers/power/reset/at91-reset.c
@@ -51,11 +51,11 @@ enum reset_type {
 
 struct at91_reset {
 	void __iomem *rstc_base;
+	void __iomem *ramc_base[2];
 };
 
 static struct at91_reset reset;
 
-static void __iomem *at91_ramc_base[2];
 static struct clk *sclk;
 
 /*
@@ -81,7 +81,7 @@ static int at91sam9260_restart(struct notifier_block *this, unsigned long mode,
 
 		"b	.\n\t"
 		:
-		: "r" (at91_ramc_base[0]),
+		: "r" (reset.ramc_base[0]),
 		  "r" (reset.rstc_base),
 		  "r" (1),
 		  "r" cpu_to_le32(AT91_SDRAMC_LPCB_POWER_DOWN),
@@ -123,8 +123,8 @@ static int at91sam9g45_restart(struct notifier_block *this, unsigned long mode,
 
 		"	b	.\n\t"
 		:
-		: "r" (at91_ramc_base[0]),
-		  "r" (at91_ramc_base[1]),
+		: "r" (reset.ramc_base[0]),
+		  "r" (reset.ramc_base[1]),
 		  "r" (reset.rstc_base),
 		  "r" (1),
 		  "r" cpu_to_le32(AT91_DDRSDRC_LPCB_POWER_DOWN),
@@ -225,8 +225,8 @@ static int __init at91_reset_probe(struct platform_device *pdev)
 	if (!of_device_is_compatible(pdev->dev.of_node, "atmel,sama5d3-rstc")) {
 		/* we need to shutdown the ddr controller, so get ramc base */
 		for_each_matching_node(np, at91_ramc_of_match) {
-			at91_ramc_base[idx] = of_iomap(np, 0);
-			if (!at91_ramc_base[idx]) {
+			reset.ramc_base[idx] = of_iomap(np, 0);
+			if (!reset.ramc_base[idx]) {
 				dev_err(&pdev->dev, "Could not map ram controller address\n");
 				of_node_put(np);
 				return -ENODEV;

commit b2a16610f2ba72468b4a7ac1e462af1e9c70bae8
Author: Claudiu.Beznea@microchip.com <Claudiu.Beznea@microchip.com>
Date:   Tue Jan 21 10:03:29 2020 +0000

    power: reset: at91-reset: introduce struct at91_reset
    
    Introduce struct at91_reset intended to keep all the at91 reset controller
    data.
    
    Signed-off-by: Claudiu Beznea <claudiu.beznea@microchip.com>
    Signed-off-by: Sebastian Reichel <sebastian.reichel@collabora.com>

diff --git a/drivers/power/reset/at91-reset.c b/drivers/power/reset/at91-reset.c
index d94e3267c3b6..2df0610e5527 100644
--- a/drivers/power/reset/at91-reset.c
+++ b/drivers/power/reset/at91-reset.c
@@ -49,7 +49,13 @@ enum reset_type {
 	RESET_TYPE_ULP2		= 8,
 };
 
-static void __iomem *at91_ramc_base[2], *at91_rstc_base;
+struct at91_reset {
+	void __iomem *rstc_base;
+};
+
+static struct at91_reset reset;
+
+static void __iomem *at91_ramc_base[2];
 static struct clk *sclk;
 
 /*
@@ -76,7 +82,7 @@ static int at91sam9260_restart(struct notifier_block *this, unsigned long mode,
 		"b	.\n\t"
 		:
 		: "r" (at91_ramc_base[0]),
-		  "r" (at91_rstc_base),
+		  "r" (reset.rstc_base),
 		  "r" (1),
 		  "r" cpu_to_le32(AT91_SDRAMC_LPCB_POWER_DOWN),
 		  "r" cpu_to_le32(AT91_RSTC_KEY | AT91_RSTC_PERRST | AT91_RSTC_PROCRST));
@@ -119,7 +125,7 @@ static int at91sam9g45_restart(struct notifier_block *this, unsigned long mode,
 		:
 		: "r" (at91_ramc_base[0]),
 		  "r" (at91_ramc_base[1]),
-		  "r" (at91_rstc_base),
+		  "r" (reset.rstc_base),
 		  "r" (1),
 		  "r" cpu_to_le32(AT91_DDRSDRC_LPCB_POWER_DOWN),
 		  "r" cpu_to_le32(AT91_RSTC_KEY | AT91_RSTC_PERRST | AT91_RSTC_PROCRST)
@@ -131,8 +137,8 @@ static int at91sam9g45_restart(struct notifier_block *this, unsigned long mode,
 static int sama5d3_restart(struct notifier_block *this, unsigned long mode,
 			   void *cmd)
 {
-	writel(AT91_RSTC_KEY | AT91_RSTC_PERRST | AT91_RSTC_PROCRST,
-	       at91_rstc_base);
+	writel(cpu_to_le32(AT91_RSTC_KEY | AT91_RSTC_PERRST | AT91_RSTC_PROCRST),
+	       reset.rstc_base);
 
 	return NOTIFY_DONE;
 }
@@ -140,14 +146,16 @@ static int sama5d3_restart(struct notifier_block *this, unsigned long mode,
 static int samx7_restart(struct notifier_block *this, unsigned long mode,
 			 void *cmd)
 {
-	writel(AT91_RSTC_KEY | AT91_RSTC_PROCRST, at91_rstc_base);
+	writel(cpu_to_le32(AT91_RSTC_KEY | AT91_RSTC_PROCRST),
+	       reset.rstc_base);
+
 	return NOTIFY_DONE;
 }
 
 static void __init at91_reset_status(struct platform_device *pdev)
 {
 	const char *reason;
-	u32 reg = readl(at91_rstc_base + AT91_RSTC_SR);
+	u32 reg = readl(reset.rstc_base + AT91_RSTC_SR);
 
 	switch ((reg & AT91_RSTC_RSTTYP) >> 8) {
 	case RESET_TYPE_GENERAL:
@@ -208,8 +216,8 @@ static int __init at91_reset_probe(struct platform_device *pdev)
 	struct device_node *np;
 	int ret, idx = 0;
 
-	at91_rstc_base = of_iomap(pdev->dev.of_node, 0);
-	if (!at91_rstc_base) {
+	reset.rstc_base = of_iomap(pdev->dev.of_node, 0);
+	if (!reset.rstc_base) {
 		dev_err(&pdev->dev, "Could not map reset controller address\n");
 		return -ENODEV;
 	}

commit c045006420813ed43c794ccf334c7b6116a16366
Author: Ben Dooks (Codethink) <ben.dooks@codethink.co.uk>
Date:   Tue Oct 15 16:54:14 2019 +0100

    power: reset: at91: fix __le32 cast in reset code
    
    The writel() takes standard integers, not __le32 so
    fix the following sparse warnings by removing the
    cpu_to_le32() calls.
    
    drivers/power/reset/at91-reset.c:134:9: warning: cast from restricted __le32
    drivers/power/reset/at91-reset.c:143:9: warning: cast from restricted __le32
    
    This has made no code changes, the md5sums pre and post applying
    this patch are the same. The at91 should be natively little endian
    anyway.
    
    Signed-off-by: Ben Dooks <ben.dooks@codethink.co.uk>
    Signed-off-by: Sebastian Reichel <sebastian.reichel@collabora.com>

diff --git a/drivers/power/reset/at91-reset.c b/drivers/power/reset/at91-reset.c
index 44ca983a49a1..d94e3267c3b6 100644
--- a/drivers/power/reset/at91-reset.c
+++ b/drivers/power/reset/at91-reset.c
@@ -131,7 +131,7 @@ static int at91sam9g45_restart(struct notifier_block *this, unsigned long mode,
 static int sama5d3_restart(struct notifier_block *this, unsigned long mode,
 			   void *cmd)
 {
-	writel(cpu_to_le32(AT91_RSTC_KEY | AT91_RSTC_PERRST | AT91_RSTC_PROCRST),
+	writel(AT91_RSTC_KEY | AT91_RSTC_PERRST | AT91_RSTC_PROCRST,
 	       at91_rstc_base);
 
 	return NOTIFY_DONE;
@@ -140,9 +140,7 @@ static int sama5d3_restart(struct notifier_block *this, unsigned long mode,
 static int samx7_restart(struct notifier_block *this, unsigned long mode,
 			 void *cmd)
 {
-	writel(cpu_to_le32(AT91_RSTC_KEY | AT91_RSTC_PROCRST),
-	       at91_rstc_base);
-
+	writel(AT91_RSTC_KEY | AT91_RSTC_PROCRST, at91_rstc_base);
 	return NOTIFY_DONE;
 }
 

commit 655ab0bc462d1ae2aa344b1ecf35ca1a3ed726dc
Author: Nicolas Ferre <nicolas.ferre@microchip.com>
Date:   Wed Feb 6 19:12:21 2019 +0100

    power: reset: at91-reset: add support for sam9x60 SoC
    
    Add support for additional reset causes and the proper compatibility
    string for sam9x60 SoC. The restart function is the same as the samx7.
    
    Signed-off-by: Nicolas Ferre <nicolas.ferre@microchip.com>
    Reviewed-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Signed-off-by: Sebastian Reichel <sebastian.reichel@collabora.com>

diff --git a/drivers/power/reset/at91-reset.c b/drivers/power/reset/at91-reset.c
index f44a9ffcc2ab..44ca983a49a1 100644
--- a/drivers/power/reset/at91-reset.c
+++ b/drivers/power/reset/at91-reset.c
@@ -44,6 +44,9 @@ enum reset_type {
 	RESET_TYPE_WATCHDOG	= 2,
 	RESET_TYPE_SOFTWARE	= 3,
 	RESET_TYPE_USER		= 4,
+	RESET_TYPE_CPU_FAIL	= 6,
+	RESET_TYPE_XTAL_FAIL	= 7,
+	RESET_TYPE_ULP2		= 8,
 };
 
 static void __iomem *at91_ramc_base[2], *at91_rstc_base;
@@ -164,6 +167,15 @@ static void __init at91_reset_status(struct platform_device *pdev)
 	case RESET_TYPE_USER:
 		reason = "user reset";
 		break;
+	case RESET_TYPE_CPU_FAIL:
+		reason = "CPU clock failure detection";
+		break;
+	case RESET_TYPE_XTAL_FAIL:
+		reason = "32.768 kHz crystal failure detection";
+		break;
+	case RESET_TYPE_ULP2:
+		reason = "ULP2 reset";
+		break;
 	default:
 		reason = "unknown reset";
 		break;
@@ -183,6 +195,7 @@ static const struct of_device_id at91_reset_of_match[] = {
 	{ .compatible = "atmel,at91sam9g45-rstc", .data = at91sam9g45_restart },
 	{ .compatible = "atmel,sama5d3-rstc", .data = sama5d3_restart },
 	{ .compatible = "atmel,samx7-rstc", .data = samx7_restart },
+	{ .compatible = "microchip,sam9x60-rstc", .data = samx7_restart },
 	{ /* sentinel */ }
 };
 MODULE_DEVICE_TABLE(of, at91_reset_of_match);

commit fd73a3e618889877d32e338622a363d04d9be709
Author: Ladislav Michl <ladis@linux-mips.org>
Date:   Fri Mar 16 11:06:26 2018 +0100

    power: reset: at91-reset: Switch from the pr_*() to the dev_*() logging functions
    
    Use dev_info() instead of pr_info().
    
    Signed-off-by: Ladislav Michl <ladis@linux-mips.org>
    Acked-by: Nicolas Ferre <nicolas.ferre@microchip.com>
    Signed-off-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>

diff --git a/drivers/power/reset/at91-reset.c b/drivers/power/reset/at91-reset.c
index b99769f8ab15..f44a9ffcc2ab 100644
--- a/drivers/power/reset/at91-reset.c
+++ b/drivers/power/reset/at91-reset.c
@@ -145,8 +145,8 @@ static int samx7_restart(struct notifier_block *this, unsigned long mode,
 
 static void __init at91_reset_status(struct platform_device *pdev)
 {
+	const char *reason;
 	u32 reg = readl(at91_rstc_base + AT91_RSTC_SR);
-	char *reason;
 
 	switch ((reg & AT91_RSTC_RSTTYP) >> 8) {
 	case RESET_TYPE_GENERAL:
@@ -169,7 +169,7 @@ static void __init at91_reset_status(struct platform_device *pdev)
 		break;
 	}
 
-	pr_info("AT91: Starting after %s\n", reason);
+	dev_info(&pdev->dev, "Starting after %s\n", reason);
 }
 
 static const struct of_device_id at91_ramc_of_match[] = {

commit b6d30432e04c750504dcfa19223cad830c89d02b
Author: Alexandre Belloni <alexandre.belloni@free-electrons.com>
Date:   Wed Jan 18 00:07:38 2017 +0100

    power: reset: at91-reset: remove leftover platform_device_id
    
    commit eacd8d09db7f ("power/reset: at91-reset: remove useless
    at91_reset_platform_probe()") removed non DT probe support but forgot to
    remove the now useless id_table. Do that now.
    
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Signed-off-by: Sebastian Reichel <sre@kernel.org>

diff --git a/drivers/power/reset/at91-reset.c b/drivers/power/reset/at91-reset.c
index bb2588f0a4c7..b99769f8ab15 100644
--- a/drivers/power/reset/at91-reset.c
+++ b/drivers/power/reset/at91-reset.c
@@ -248,20 +248,12 @@ static int __exit at91_reset_remove(struct platform_device *pdev)
 	return 0;
 }
 
-static const struct platform_device_id at91_reset_plat_match[] = {
-	{ "at91-sam9260-reset", (unsigned long)at91sam9260_restart },
-	{ "at91-sam9g45-reset", (unsigned long)at91sam9g45_restart },
-	{ /* sentinel */ }
-};
-MODULE_DEVICE_TABLE(platform, at91_reset_plat_match);
-
 static struct platform_driver at91_reset_driver = {
 	.remove = __exit_p(at91_reset_remove),
 	.driver = {
 		.name = "at91-reset",
 		.of_match_table = at91_reset_of_match,
 	},
-	.id_table = at91_reset_plat_match,
 };
 module_platform_driver_probe(at91_reset_driver, at91_reset_probe);
 

commit f22dfd86f0b32660ba026e38d8478faf174f9481
Author: Szemző András <sza@esh.hu>
Date:   Wed Jan 18 00:07:37 2017 +0100

    power: reset: at91-reset: add samx7 support
    
    Add samx7 support. It is lacking a few bits and needs a new reset function.
    
    Signed-off-by: Szemző András <sza@esh.hu>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Signed-off-by: Sebastian Reichel <sre@kernel.org>

diff --git a/drivers/power/reset/at91-reset.c b/drivers/power/reset/at91-reset.c
index 568580cf0655..bb2588f0a4c7 100644
--- a/drivers/power/reset/at91-reset.c
+++ b/drivers/power/reset/at91-reset.c
@@ -134,6 +134,15 @@ static int sama5d3_restart(struct notifier_block *this, unsigned long mode,
 	return NOTIFY_DONE;
 }
 
+static int samx7_restart(struct notifier_block *this, unsigned long mode,
+			 void *cmd)
+{
+	writel(cpu_to_le32(AT91_RSTC_KEY | AT91_RSTC_PROCRST),
+	       at91_rstc_base);
+
+	return NOTIFY_DONE;
+}
+
 static void __init at91_reset_status(struct platform_device *pdev)
 {
 	u32 reg = readl(at91_rstc_base + AT91_RSTC_SR);
@@ -173,6 +182,7 @@ static const struct of_device_id at91_reset_of_match[] = {
 	{ .compatible = "atmel,at91sam9260-rstc", .data = at91sam9260_restart },
 	{ .compatible = "atmel,at91sam9g45-rstc", .data = at91sam9g45_restart },
 	{ .compatible = "atmel,sama5d3-rstc", .data = sama5d3_restart },
+	{ .compatible = "atmel,samx7-rstc", .data = samx7_restart },
 	{ /* sentinel */ }
 };
 MODULE_DEVICE_TABLE(of, at91_reset_of_match);

commit 991de440363d294bee06bfaf484a3843f3f3fd81
Author: Javier Martinez Canillas <javier@osg.samsung.com>
Date:   Mon Oct 17 15:36:12 2016 -0300

    power: reset: at91-reset: Fix module autoload
    
    If the driver is built as a module, autoload won't work because the module
    alias information is not filled. So user-space can't match the registered
    device with the corresponding module.
    
    Export the module alias information using the MODULE_DEVICE_TABLE() macro.
    
    Before this patch:
    
    $ modinfo drivers/power/reset/at91-reset.ko | grep alias
    $
    
    After this patch:
    
    $ modinfo drivers/power/reset/at91-reset.ko | grep alias
    alias:          of:N*T*Catmel,sama5d3-rstcC*
    alias:          of:N*T*Catmel,sama5d3-rstc
    alias:          of:N*T*Catmel,at91sam9g45-rstcC*
    alias:          of:N*T*Catmel,at91sam9g45-rstc
    alias:          of:N*T*Catmel,at91sam9260-rstcC*
    alias:          of:N*T*Catmel,at91sam9260-rstc
    alias:          platform:at91-sam9g45-reset
    alias:          platform:at91-sam9260-reset
    
    Signed-off-by: Javier Martinez Canillas <javier@osg.samsung.com>
    Signed-off-by: Sebastian Reichel <sre@kernel.org>

diff --git a/drivers/power/reset/at91-reset.c b/drivers/power/reset/at91-reset.c
index 1b5d450586d1..568580cf0655 100644
--- a/drivers/power/reset/at91-reset.c
+++ b/drivers/power/reset/at91-reset.c
@@ -175,6 +175,7 @@ static const struct of_device_id at91_reset_of_match[] = {
 	{ .compatible = "atmel,sama5d3-rstc", .data = sama5d3_restart },
 	{ /* sentinel */ }
 };
+MODULE_DEVICE_TABLE(of, at91_reset_of_match);
 
 static struct notifier_block at91_restart_nb = {
 	.priority = 192,
@@ -242,6 +243,7 @@ static const struct platform_device_id at91_reset_plat_match[] = {
 	{ "at91-sam9g45-reset", (unsigned long)at91sam9g45_restart },
 	{ /* sentinel */ }
 };
+MODULE_DEVICE_TABLE(platform, at91_reset_plat_match);
 
 static struct platform_driver at91_reset_driver = {
 	.remove = __exit_p(at91_reset_remove),

commit c4c0edfbf875a5ecb38a4aa65e2bdb87739e81d6
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Wed Nov 18 23:04:14 2015 +0100

    power/reset: at91-reset: add missing of_node_put
    
    for_each_matching_node performs an of_node_get on each iteration, so
    a break out of the loop requires an of_node_put.
    
    A simplified version of the semantic patch that fixes this problem is as
    follows (http://coccinelle.lip6.fr):
    
    // <smpl>
    @@
    expression e,e1;
    local idexpression np;
    @@
    
     for_each_matching_node(np, e1) {
       ... when != of_node_put(np)
           when != e = np
    (
       return np;
    |
    +  of_node_put(np);
    ?  return ...;
    )
       ...
     }
    // </smpl>
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Signed-off-by: Sebastian Reichel <sre@kernel.org>

diff --git a/drivers/power/reset/at91-reset.c b/drivers/power/reset/at91-reset.c
index 3f6b5dd7c3d4..1b5d450586d1 100644
--- a/drivers/power/reset/at91-reset.c
+++ b/drivers/power/reset/at91-reset.c
@@ -198,6 +198,7 @@ static int __init at91_reset_probe(struct platform_device *pdev)
 			at91_ramc_base[idx] = of_iomap(np, 0);
 			if (!at91_ramc_base[idx]) {
 				dev_err(&pdev->dev, "Could not map ram controller address\n");
+				of_node_put(np);
 				return -ENODEV;
 			}
 			idx++;

commit bc312cbdfa4c4eaa074bae29adbff231c743619a
Author: Nicolas Ferre <nicolas.ferre@atmel.com>
Date:   Thu Sep 10 12:35:13 2015 +0200

    power: reset: at91-reset/trivial: driver applies to SAMA5 family as well
    
    This diver doesn't applies only on SAM9 SoC families but on SAMA5 families
    as well.
    
    Signed-off-by: Nicolas Ferre <nicolas.ferre@atmel.com>
    Signed-off-by: Sebastian Reichel <sre@kernel.org>

diff --git a/drivers/power/reset/at91-reset.c b/drivers/power/reset/at91-reset.c
index 3d9c43a66806..3f6b5dd7c3d4 100644
--- a/drivers/power/reset/at91-reset.c
+++ b/drivers/power/reset/at91-reset.c
@@ -1,5 +1,5 @@
 /*
- * Atmel AT91 SAM9 SoCs reset code
+ * Atmel AT91 SAM9 & SAMA5 SoCs reset code
  *
  * Copyright (C) 2007 Atmel Corporation.
  * Copyright (C) BitBox Ltd 2010

commit 2b2c6148fe851042cefbf272146b77634a4da39d
Author: Alexandre Belloni <alexandre.belloni@free-electrons.com>
Date:   Tue Aug 11 11:12:48 2015 +0200

    power/reset: at91-reset: get and use slow clock
    
    Commit dca1a4b5ff6e ("clk: at91: keep slow clk enabled to prevent system
    hang") added a workaround for the slow clock as it is not properly handled
    by its users.
    
    Get and use the slow clock as it is necessary for the at91 reset
    controller.
    
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Signed-off-by: Sebastian Reichel <sre@kernel.org>

diff --git a/drivers/power/reset/at91-reset.c b/drivers/power/reset/at91-reset.c
index 6374f5c9ee91..3d9c43a66806 100644
--- a/drivers/power/reset/at91-reset.c
+++ b/drivers/power/reset/at91-reset.c
@@ -11,6 +11,7 @@
  * warranty of any kind, whether express or implied.
  */
 
+#include <linux/clk.h>
 #include <linux/io.h>
 #include <linux/module.h>
 #include <linux/of_address.h>
@@ -46,6 +47,7 @@ enum reset_type {
 };
 
 static void __iomem *at91_ramc_base[2], *at91_rstc_base;
+static struct clk *sclk;
 
 /*
 * unless the SDRAM is cleanly shutdown before we hit the
@@ -205,9 +207,21 @@ static int __init at91_reset_probe(struct platform_device *pdev)
 	match = of_match_node(at91_reset_of_match, pdev->dev.of_node);
 	at91_restart_nb.notifier_call = match->data;
 
+	sclk = devm_clk_get(&pdev->dev, NULL);
+	if (IS_ERR(sclk))
+		return PTR_ERR(sclk);
+
+	ret = clk_prepare_enable(sclk);
+	if (ret) {
+		dev_err(&pdev->dev, "Could not enable slow clock\n");
+		return ret;
+	}
+
 	ret = register_restart_handler(&at91_restart_nb);
-	if (ret)
+	if (ret) {
+		clk_disable_unprepare(sclk);
 		return ret;
+	}
 
 	at91_reset_status(pdev);
 
@@ -217,6 +231,7 @@ static int __init at91_reset_probe(struct platform_device *pdev)
 static int __exit at91_reset_remove(struct platform_device *pdev)
 {
 	unregister_restart_handler(&at91_restart_nb);
+	clk_disable_unprepare(sclk);
 
 	return 0;
 }

commit 6e64180a7c0219d769e05b6dbe5af4a073c1eb92
Author: Alexandre Belloni <alexandre.belloni@free-electrons.com>
Date:   Tue Aug 11 11:12:47 2015 +0200

    power/reset: at91-reset: allow compiling as a module
    
    It was not possible to compile at91-reset as a module. Implement .remove()
    to allow it. Also switch to module_platform_driver_probe() as it is not
    hotpluggable.
    
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Signed-off-by: Sebastian Reichel <sre@kernel.org>

diff --git a/drivers/power/reset/at91-reset.c b/drivers/power/reset/at91-reset.c
index 16e12bd507a1..6374f5c9ee91 100644
--- a/drivers/power/reset/at91-reset.c
+++ b/drivers/power/reset/at91-reset.c
@@ -178,7 +178,7 @@ static struct notifier_block at91_restart_nb = {
 	.priority = 192,
 };
 
-static int at91_reset_probe(struct platform_device *pdev)
+static int __init at91_reset_probe(struct platform_device *pdev)
 {
 	const struct of_device_id *match;
 	struct device_node *np;
@@ -214,6 +214,13 @@ static int at91_reset_probe(struct platform_device *pdev)
 	return 0;
 }
 
+static int __exit at91_reset_remove(struct platform_device *pdev)
+{
+	unregister_restart_handler(&at91_restart_nb);
+
+	return 0;
+}
+
 static const struct platform_device_id at91_reset_plat_match[] = {
 	{ "at91-sam9260-reset", (unsigned long)at91sam9260_restart },
 	{ "at91-sam9g45-reset", (unsigned long)at91sam9g45_restart },
@@ -221,11 +228,15 @@ static const struct platform_device_id at91_reset_plat_match[] = {
 };
 
 static struct platform_driver at91_reset_driver = {
-	.probe = at91_reset_probe,
+	.remove = __exit_p(at91_reset_remove),
 	.driver = {
 		.name = "at91-reset",
 		.of_match_table = at91_reset_of_match,
 	},
 	.id_table = at91_reset_plat_match,
 };
-module_platform_driver(at91_reset_driver);
+module_platform_driver_probe(at91_reset_driver, at91_reset_probe);
+
+MODULE_AUTHOR("Atmel Corporation");
+MODULE_DESCRIPTION("Reset driver for Atmel SoCs");
+MODULE_LICENSE("GPL v2");

commit eacd8d09db7f4504eea6b5fdc55a8fe5eaf62bed
Author: Alexandre Belloni <alexandre.belloni@free-electrons.com>
Date:   Tue Aug 11 11:12:46 2015 +0200

    power/reset: at91-reset: remove useless at91_reset_platform_probe()
    
    Since all the at91 platforms are now DT only, at91_reset_platform_probe()
    is now useless, remove it.
    
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Signed-off-by: Sebastian Reichel <sre@kernel.org>

diff --git a/drivers/power/reset/at91-reset.c b/drivers/power/reset/at91-reset.c
index c378d4ec826f..16e12bd507a1 100644
--- a/drivers/power/reset/at91-reset.c
+++ b/drivers/power/reset/at91-reset.c
@@ -178,11 +178,11 @@ static struct notifier_block at91_restart_nb = {
 	.priority = 192,
 };
 
-static int at91_reset_of_probe(struct platform_device *pdev)
+static int at91_reset_probe(struct platform_device *pdev)
 {
 	const struct of_device_id *match;
 	struct device_node *np;
-	int idx = 0;
+	int ret, idx = 0;
 
 	at91_rstc_base = of_iomap(pdev->dev.of_node, 0);
 	if (!at91_rstc_base) {
@@ -204,49 +204,8 @@ static int at91_reset_of_probe(struct platform_device *pdev)
 
 	match = of_match_node(at91_reset_of_match, pdev->dev.of_node);
 	at91_restart_nb.notifier_call = match->data;
-	return register_restart_handler(&at91_restart_nb);
-}
-
-static int at91_reset_platform_probe(struct platform_device *pdev)
-{
-	const struct platform_device_id *match;
-	struct resource *res;
-	int idx = 0;
-
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	at91_rstc_base = devm_ioremap_resource(&pdev->dev, res);
-	if (IS_ERR(at91_rstc_base)) {
-		dev_err(&pdev->dev, "Could not map reset controller address\n");
-		return PTR_ERR(at91_rstc_base);
-	}
-
-	for (idx = 0; idx < 2; idx++) {
-		res = platform_get_resource(pdev, IORESOURCE_MEM, idx + 1 );
-		at91_ramc_base[idx] = devm_ioremap(&pdev->dev, res->start,
-						   resource_size(res));
-		if (!at91_ramc_base[idx]) {
-			dev_err(&pdev->dev, "Could not map ram controller address\n");
-			return -ENOMEM;
-		}
-	}
-
-	match = platform_get_device_id(pdev);
-	at91_restart_nb.notifier_call =
-		(int (*)(struct notifier_block *,
-			 unsigned long, void *)) match->driver_data;
-
-	return register_restart_handler(&at91_restart_nb);
-}
-
-static int at91_reset_probe(struct platform_device *pdev)
-{
-	int ret;
-
-	if (pdev->dev.of_node)
-		ret = at91_reset_of_probe(pdev);
-	else
-		ret = at91_reset_platform_probe(pdev);
 
+	ret = register_restart_handler(&at91_restart_nb);
 	if (ret)
 		return ret;
 

commit 1ae25d626cfe7e11adc2c3e71d0de1f882954ef3
Author: Josh Wu <josh.wu@atmel.com>
Date:   Mon Jul 20 17:32:05 2015 +0800

    power: reset: at91: add sama5d3 reset function
    
    This patch introduces a new compatible string: "atmel,sama5d3-rstc" and
    new reset function for sama5d3 and later chips.
    
    As in sama5d3 or later chips, we don't have to shutdown the DDR
    controller before reset. Shutdown the DDR controller before reset is a
    workaround to avoid DDR signal driving the bus, but since sama5d3 and
    later chips there is no such a conflict.
    
    So in this patch:
       1. the sama5d3 reset function only need to write the rstc register
    and return.
       2. we can remove the code related with sama5d3 DDR controller as
    we don't use it at all.
    
    Signed-off-by: Josh Wu <josh.wu@atmel.com>
    Acked-by: Nicolas Ferre <nicolas.ferre@atmel.com>
    Acked-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Reviewed-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Sebastian Reichel <sre@kernel.org>

diff --git a/drivers/power/reset/at91-reset.c b/drivers/power/reset/at91-reset.c
index 36dc52fb2ec8..c378d4ec826f 100644
--- a/drivers/power/reset/at91-reset.c
+++ b/drivers/power/reset/at91-reset.c
@@ -123,6 +123,15 @@ static int at91sam9g45_restart(struct notifier_block *this, unsigned long mode,
 	return NOTIFY_DONE;
 }
 
+static int sama5d3_restart(struct notifier_block *this, unsigned long mode,
+			   void *cmd)
+{
+	writel(cpu_to_le32(AT91_RSTC_KEY | AT91_RSTC_PERRST | AT91_RSTC_PROCRST),
+	       at91_rstc_base);
+
+	return NOTIFY_DONE;
+}
+
 static void __init at91_reset_status(struct platform_device *pdev)
 {
 	u32 reg = readl(at91_rstc_base + AT91_RSTC_SR);
@@ -155,13 +164,13 @@ static void __init at91_reset_status(struct platform_device *pdev)
 static const struct of_device_id at91_ramc_of_match[] = {
 	{ .compatible = "atmel,at91sam9260-sdramc", },
 	{ .compatible = "atmel,at91sam9g45-ddramc", },
-	{ .compatible = "atmel,sama5d3-ddramc", },
 	{ /* sentinel */ }
 };
 
 static const struct of_device_id at91_reset_of_match[] = {
 	{ .compatible = "atmel,at91sam9260-rstc", .data = at91sam9260_restart },
 	{ .compatible = "atmel,at91sam9g45-rstc", .data = at91sam9g45_restart },
+	{ .compatible = "atmel,sama5d3-rstc", .data = sama5d3_restart },
 	{ /* sentinel */ }
 };
 
@@ -181,13 +190,16 @@ static int at91_reset_of_probe(struct platform_device *pdev)
 		return -ENODEV;
 	}
 
-	for_each_matching_node(np, at91_ramc_of_match) {
-		at91_ramc_base[idx] = of_iomap(np, 0);
-		if (!at91_ramc_base[idx]) {
-			dev_err(&pdev->dev, "Could not map ram controller address\n");
-			return -ENODEV;
+	if (!of_device_is_compatible(pdev->dev.of_node, "atmel,sama5d3-rstc")) {
+		/* we need to shutdown the ddr controller, so get ramc base */
+		for_each_matching_node(np, at91_ramc_of_match) {
+			at91_ramc_base[idx] = of_iomap(np, 0);
+			if (!at91_ramc_base[idx]) {
+				dev_err(&pdev->dev, "Could not map ram controller address\n");
+				return -ENODEV;
+			}
+			idx++;
 		}
-		idx++;
 	}
 
 	match = of_match_node(at91_reset_of_match, pdev->dev.of_node);

commit 323667209223368b50e16994e0fa8cf833940ce6
Author: Krzysztof Kozlowski <k.kozlowski.k@gmail.com>
Date:   Sat May 2 00:46:44 2015 +0900

    power: at91-reset: Constify platform_device_id
    
    The platform_device_id is not modified by the driver and core uses it as
    const.
    
    Signed-off-by: Krzysztof Kozlowski <k.kozlowski.k@gmail.com>
    Acked-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Signed-off-by: Sebastian Reichel <sre@kernel.org>

diff --git a/drivers/power/reset/at91-reset.c b/drivers/power/reset/at91-reset.c
index ca461ebc7ae8..36dc52fb2ec8 100644
--- a/drivers/power/reset/at91-reset.c
+++ b/drivers/power/reset/at91-reset.c
@@ -243,7 +243,7 @@ static int at91_reset_probe(struct platform_device *pdev)
 	return 0;
 }
 
-static struct platform_device_id at91_reset_plat_match[] = {
+static const struct platform_device_id at91_reset_plat_match[] = {
 	{ "at91-sam9260-reset", (unsigned long)at91sam9260_restart },
 	{ "at91-sam9g45-reset", (unsigned long)at91sam9g45_restart },
 	{ /* sentinel */ }

commit 932df43005389300a3336421e4aedb25390ae144
Author: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
Date:   Thu Apr 16 20:19:43 2015 +0800

    power/reset: at91: fix return value check in at91_reset_platform_probe()
    
    In case of error, the function devm_ioremap() returns NULL
    not ERR_PTR(). The IS_ERR() test in the return value check
    should be replaced with NULL test.
    
    Fixes: ecfe64d8c55f ("power: reset: Add AT91 reset driver")
    Signed-off-by: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
    Signed-off-by: Sebastian Reichel <sre@kernel.org>

diff --git a/drivers/power/reset/at91-reset.c b/drivers/power/reset/at91-reset.c
index 01c7055c4200..ca461ebc7ae8 100644
--- a/drivers/power/reset/at91-reset.c
+++ b/drivers/power/reset/at91-reset.c
@@ -212,9 +212,9 @@ static int at91_reset_platform_probe(struct platform_device *pdev)
 		res = platform_get_resource(pdev, IORESOURCE_MEM, idx + 1 );
 		at91_ramc_base[idx] = devm_ioremap(&pdev->dev, res->start,
 						   resource_size(res));
-		if (IS_ERR(at91_ramc_base[idx])) {
+		if (!at91_ramc_base[idx]) {
 			dev_err(&pdev->dev, "Could not map ram controller address\n");
-			return PTR_ERR(at91_ramc_base[idx]);
+			return -ENOMEM;
 		}
 	}
 

commit 7be5ac2c32bd26c47a05367c0135cb6e67b3d452
Author: Ben Dooks <ben.dooks@codethink.co.uk>
Date:   Thu Mar 26 14:16:22 2015 +0000

    power/reset: at91: big endian fixes for atsama5d3x
    
    Fix the passing of big endian data to routines that will be writing
    it to the bus in the wrong order.
    
    Signed-off-by: Ben Dooks <ben.dooks@codethink.co.uk>
    Signed-off-by: Sebastian Reichel <sre@kernel.org>

diff --git a/drivers/power/reset/at91-reset.c b/drivers/power/reset/at91-reset.c
index 68b18962f73a..01c7055c4200 100644
--- a/drivers/power/reset/at91-reset.c
+++ b/drivers/power/reset/at91-reset.c
@@ -73,8 +73,8 @@ static int at91sam9260_restart(struct notifier_block *this, unsigned long mode,
 		: "r" (at91_ramc_base[0]),
 		  "r" (at91_rstc_base),
 		  "r" (1),
-		  "r" (AT91_SDRAMC_LPCB_POWER_DOWN),
-		  "r" (AT91_RSTC_KEY | AT91_RSTC_PERRST | AT91_RSTC_PROCRST));
+		  "r" cpu_to_le32(AT91_SDRAMC_LPCB_POWER_DOWN),
+		  "r" cpu_to_le32(AT91_RSTC_KEY | AT91_RSTC_PERRST | AT91_RSTC_PROCRST));
 
 	return NOTIFY_DONE;
 }
@@ -116,8 +116,8 @@ static int at91sam9g45_restart(struct notifier_block *this, unsigned long mode,
 		  "r" (at91_ramc_base[1]),
 		  "r" (at91_rstc_base),
 		  "r" (1),
-		  "r" (AT91_DDRSDRC_LPCB_POWER_DOWN),
-		  "r" (AT91_RSTC_KEY | AT91_RSTC_PERRST | AT91_RSTC_PROCRST)
+		  "r" cpu_to_le32(AT91_DDRSDRC_LPCB_POWER_DOWN),
+		  "r" cpu_to_le32(AT91_RSTC_KEY | AT91_RSTC_PERRST | AT91_RSTC_PROCRST)
 		: "r0");
 
 	return NOTIFY_DONE;

commit 8fb0885504cc029bd48877fa89ba91c33c0110b5
Author: Fabian Frederick <fabf@skynet.be>
Date:   Mon Mar 16 20:17:12 2015 +0100

    power: constify of_device_id array
    
    of_device_id is always used as const.
    (See driver.of_match_table and open firmware functions)
    
    Signed-off-by: Fabian Frederick <fabf@skynet.be>
    
    [for vexpress]
    Acked-by: Sudeep Holla <sudeep.holla@arm.com>
    
    Signed-off-by: Sebastian Reichel <sre@kernel.org>

diff --git a/drivers/power/reset/at91-reset.c b/drivers/power/reset/at91-reset.c
index 13584e24736a..68b18962f73a 100644
--- a/drivers/power/reset/at91-reset.c
+++ b/drivers/power/reset/at91-reset.c
@@ -152,14 +152,14 @@ static void __init at91_reset_status(struct platform_device *pdev)
 	pr_info("AT91: Starting after %s\n", reason);
 }
 
-static struct of_device_id at91_ramc_of_match[] = {
+static const struct of_device_id at91_ramc_of_match[] = {
 	{ .compatible = "atmel,at91sam9260-sdramc", },
 	{ .compatible = "atmel,at91sam9g45-ddramc", },
 	{ .compatible = "atmel,sama5d3-ddramc", },
 	{ /* sentinel */ }
 };
 
-static struct of_device_id at91_reset_of_match[] = {
+static const struct of_device_id at91_reset_of_match[] = {
 	{ .compatible = "atmel,at91sam9260-rstc", .data = at91sam9260_restart },
 	{ .compatible = "atmel,at91sam9g45-rstc", .data = at91sam9g45_restart },
 	{ /* sentinel */ }

commit 481ff6ff967fefdbfb967f7251e40c22a312d244
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Sun Jan 25 12:30:41 2015 -0800

    power/reset: at91: Register with kernel restart handler
    
    Register with kernel restart handler instead of setting arm_pm_restart
    directly. Register with high priority since the driver unconditionally
    overwrites other restart handlers if instantiated.
    
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Sebastian Reichel <sre@kernel.org>

diff --git a/drivers/power/reset/at91-reset.c b/drivers/power/reset/at91-reset.c
index 69a75d99ae92..13584e24736a 100644
--- a/drivers/power/reset/at91-reset.c
+++ b/drivers/power/reset/at91-reset.c
@@ -17,8 +17,6 @@
 #include <linux/platform_device.h>
 #include <linux/reboot.h>
 
-#include <asm/system_misc.h>
-
 #include <soc/at91/at91sam9_ddrsdr.h>
 #include <soc/at91/at91sam9_sdramc.h>
 
@@ -54,7 +52,8 @@ static void __iomem *at91_ramc_base[2], *at91_rstc_base;
 * reset register it can be left driving the data bus and
 * killing the chance of a subsequent boot from NAND
 */
-static void at91sam9260_restart(enum reboot_mode mode, const char *cmd)
+static int at91sam9260_restart(struct notifier_block *this, unsigned long mode,
+			       void *cmd)
 {
 	asm volatile(
 		/* Align to cache lines */
@@ -76,9 +75,12 @@ static void at91sam9260_restart(enum reboot_mode mode, const char *cmd)
 		  "r" (1),
 		  "r" (AT91_SDRAMC_LPCB_POWER_DOWN),
 		  "r" (AT91_RSTC_KEY | AT91_RSTC_PERRST | AT91_RSTC_PROCRST));
+
+	return NOTIFY_DONE;
 }
 
-static void at91sam9g45_restart(enum reboot_mode mode, const char *cmd)
+static int at91sam9g45_restart(struct notifier_block *this, unsigned long mode,
+			       void *cmd)
 {
 	asm volatile(
 		/*
@@ -117,6 +119,8 @@ static void at91sam9g45_restart(enum reboot_mode mode, const char *cmd)
 		  "r" (AT91_DDRSDRC_LPCB_POWER_DOWN),
 		  "r" (AT91_RSTC_KEY | AT91_RSTC_PERRST | AT91_RSTC_PROCRST)
 		: "r0");
+
+	return NOTIFY_DONE;
 }
 
 static void __init at91_reset_status(struct platform_device *pdev)
@@ -161,6 +165,10 @@ static struct of_device_id at91_reset_of_match[] = {
 	{ /* sentinel */ }
 };
 
+static struct notifier_block at91_restart_nb = {
+	.priority = 192,
+};
+
 static int at91_reset_of_probe(struct platform_device *pdev)
 {
 	const struct of_device_id *match;
@@ -183,9 +191,8 @@ static int at91_reset_of_probe(struct platform_device *pdev)
 	}
 
 	match = of_match_node(at91_reset_of_match, pdev->dev.of_node);
-	arm_pm_restart = match->data;
-
-	return 0;
+	at91_restart_nb.notifier_call = match->data;
+	return register_restart_handler(&at91_restart_nb);
 }
 
 static int at91_reset_platform_probe(struct platform_device *pdev)
@@ -212,10 +219,11 @@ static int at91_reset_platform_probe(struct platform_device *pdev)
 	}
 
 	match = platform_get_device_id(pdev);
-	arm_pm_restart = (void (*)(enum reboot_mode, const char*))
-		match->driver_data;
+	at91_restart_nb.notifier_call =
+		(int (*)(struct notifier_block *,
+			 unsigned long, void *)) match->driver_data;
 
-	return 0;
+	return register_restart_handler(&at91_restart_nb);
 }
 
 static int at91_reset_probe(struct platform_device *pdev)

commit f0a0a58e6f46c2dded813ee860b9cbd795b4e571
Author: Alexandre Belloni <alexandre.belloni@free-electrons.com>
Date:   Fri Nov 7 21:58:21 2014 +0100

    ARM: at91: move sdramc/ddrsdr header to include/soc/at91
    
    Move the (DDR) SDRAM controller headers to include/soc/at91 to remove the
    dependency on mach/ headers from the at91-reset driver.
    
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Signed-off-by: Nicolas Ferre <nicolas.ferre@atmel.com>

diff --git a/drivers/power/reset/at91-reset.c b/drivers/power/reset/at91-reset.c
index 3cb36693343a..69a75d99ae92 100644
--- a/drivers/power/reset/at91-reset.c
+++ b/drivers/power/reset/at91-reset.c
@@ -19,8 +19,8 @@
 
 #include <asm/system_misc.h>
 
-#include <mach/at91sam9_ddrsdr.h>
-#include <mach/at91sam9_sdramc.h>
+#include <soc/at91/at91sam9_ddrsdr.h>
+#include <soc/at91/at91sam9_sdramc.h>
 
 #define AT91_RSTC_CR	0x00		/* Reset Controller Control Register */
 #define AT91_RSTC_PROCRST	BIT(0)		/* Processor Reset */

commit 7cb4e717d474b118930c3b5fa3a2581eb1fdee72
Author: Alexandre Belloni <alexandre.belloni@free-electrons.com>
Date:   Mon Oct 20 20:27:09 2014 +0200

    power: reset: at91-reset: fix power down register
    
    In the case of at91sam9g45_restart(), the driver is writing
    AT91_DDRSDRC_LPCB_POWER_DOWN to AT91_DDRSDRC_RTR, this should actually be
    AT91_DDRSDRC_LPR.
    
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Acked-by: Sebastian Reichel <sre@kernel.org>
    Signed-off-by: Nicolas Ferre <nicolas.ferre@atmel.com>

diff --git a/drivers/power/reset/at91-reset.c b/drivers/power/reset/at91-reset.c
index 3611806c9cfd..3cb36693343a 100644
--- a/drivers/power/reset/at91-reset.c
+++ b/drivers/power/reset/at91-reset.c
@@ -100,11 +100,11 @@ static void at91sam9g45_restart(enum reboot_mode mode, const char *cmd)
 		/* Disable SDRAM0 accesses */
 		"1:	str	%3, [%0, #" __stringify(AT91_DDRSDRC_RTR) "]\n\t"
 		/* Power down SDRAM0 */
-		"	str	%4, [%0, #" __stringify(AT91_DDRSDRC_RTR) "]\n\t"
+		"	str	%4, [%0, #" __stringify(AT91_DDRSDRC_LPR) "]\n\t"
 		/* Disable SDRAM1 accesses */
 		"	strne	%3, [%1, #" __stringify(AT91_DDRSDRC_RTR) "]\n\t"
 		/* Power down SDRAM1 */
-		"	strne	%4, [%1, #" __stringify(AT91_DDRSDRC_RTR) "]\n\t"
+		"	strne	%4, [%1, #" __stringify(AT91_DDRSDRC_LPR) "]\n\t"
 		/* Reset CPU */
 		"	str	%5, [%2, #" __stringify(AT91_RSTC_CR) "]\n\t"
 

commit ecfe64d8c55f8f210a609cd2eabfcc03f03672a9
Author: Maxime Ripard <maxime.ripard@free-electrons.com>
Date:   Wed Jul 2 17:46:58 2014 +0200

    power: reset: Add AT91 reset driver
    
    Implement the reset behaviour of the various AT91 SoCS in drivers/power/reset.
    
    It used to be (and still is) located in arch/arm/mach-at91, and in order to
    preserve bisectability is not removed yet, but every board should be converted
    to use this driver instead.
    
    Signed-off-by: Maxime Ripard <maxime.ripard@free-electrons.com>
    Acked-by: Nicolas Ferre <nicolas.ferre@atmel.com>
    Acked-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>

diff --git a/drivers/power/reset/at91-reset.c b/drivers/power/reset/at91-reset.c
new file mode 100644
index 000000000000..3611806c9cfd
--- /dev/null
+++ b/drivers/power/reset/at91-reset.c
@@ -0,0 +1,252 @@
+/*
+ * Atmel AT91 SAM9 SoCs reset code
+ *
+ * Copyright (C) 2007 Atmel Corporation.
+ * Copyright (C) BitBox Ltd 2010
+ * Copyright (C) 2011 Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcosoft.com>
+ * Copyright (C) 2014 Free Electrons
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+#include <linux/reboot.h>
+
+#include <asm/system_misc.h>
+
+#include <mach/at91sam9_ddrsdr.h>
+#include <mach/at91sam9_sdramc.h>
+
+#define AT91_RSTC_CR	0x00		/* Reset Controller Control Register */
+#define AT91_RSTC_PROCRST	BIT(0)		/* Processor Reset */
+#define AT91_RSTC_PERRST	BIT(2)		/* Peripheral Reset */
+#define AT91_RSTC_EXTRST	BIT(3)		/* External Reset */
+#define AT91_RSTC_KEY		(0xa5 << 24)	/* KEY Password */
+
+#define AT91_RSTC_SR	0x04		/* Reset Controller Status Register */
+#define AT91_RSTC_URSTS		BIT(0)		/* User Reset Status */
+#define AT91_RSTC_RSTTYP	GENMASK(10, 8)	/* Reset Type */
+#define AT91_RSTC_NRSTL		BIT(16)		/* NRST Pin Level */
+#define AT91_RSTC_SRCMP		BIT(17)		/* Software Reset Command in Progress */
+
+#define AT91_RSTC_MR	0x08		/* Reset Controller Mode Register */
+#define AT91_RSTC_URSTEN	BIT(0)		/* User Reset Enable */
+#define AT91_RSTC_URSTIEN	BIT(4)		/* User Reset Interrupt Enable */
+#define AT91_RSTC_ERSTL		GENMASK(11, 8)	/* External Reset Length */
+
+enum reset_type {
+	RESET_TYPE_GENERAL	= 0,
+	RESET_TYPE_WAKEUP	= 1,
+	RESET_TYPE_WATCHDOG	= 2,
+	RESET_TYPE_SOFTWARE	= 3,
+	RESET_TYPE_USER		= 4,
+};
+
+static void __iomem *at91_ramc_base[2], *at91_rstc_base;
+
+/*
+* unless the SDRAM is cleanly shutdown before we hit the
+* reset register it can be left driving the data bus and
+* killing the chance of a subsequent boot from NAND
+*/
+static void at91sam9260_restart(enum reboot_mode mode, const char *cmd)
+{
+	asm volatile(
+		/* Align to cache lines */
+		".balign 32\n\t"
+
+		/* Disable SDRAM accesses */
+		"str	%2, [%0, #" __stringify(AT91_SDRAMC_TR) "]\n\t"
+
+		/* Power down SDRAM */
+		"str	%3, [%0, #" __stringify(AT91_SDRAMC_LPR) "]\n\t"
+
+		/* Reset CPU */
+		"str	%4, [%1, #" __stringify(AT91_RSTC_CR) "]\n\t"
+
+		"b	.\n\t"
+		:
+		: "r" (at91_ramc_base[0]),
+		  "r" (at91_rstc_base),
+		  "r" (1),
+		  "r" (AT91_SDRAMC_LPCB_POWER_DOWN),
+		  "r" (AT91_RSTC_KEY | AT91_RSTC_PERRST | AT91_RSTC_PROCRST));
+}
+
+static void at91sam9g45_restart(enum reboot_mode mode, const char *cmd)
+{
+	asm volatile(
+		/*
+		 * Test wether we have a second RAM controller to care
+		 * about.
+		 *
+		 * First, test that we can dereference the virtual address.
+		 */
+		"cmp	%1, #0\n\t"
+		"beq	1f\n\t"
+
+		/* Then, test that the RAM controller is enabled */
+		"ldr	r0, [%1]\n\t"
+		"cmp	r0, #0\n\t"
+
+		/* Align to cache lines */
+		".balign 32\n\t"
+
+		/* Disable SDRAM0 accesses */
+		"1:	str	%3, [%0, #" __stringify(AT91_DDRSDRC_RTR) "]\n\t"
+		/* Power down SDRAM0 */
+		"	str	%4, [%0, #" __stringify(AT91_DDRSDRC_RTR) "]\n\t"
+		/* Disable SDRAM1 accesses */
+		"	strne	%3, [%1, #" __stringify(AT91_DDRSDRC_RTR) "]\n\t"
+		/* Power down SDRAM1 */
+		"	strne	%4, [%1, #" __stringify(AT91_DDRSDRC_RTR) "]\n\t"
+		/* Reset CPU */
+		"	str	%5, [%2, #" __stringify(AT91_RSTC_CR) "]\n\t"
+
+		"	b	.\n\t"
+		:
+		: "r" (at91_ramc_base[0]),
+		  "r" (at91_ramc_base[1]),
+		  "r" (at91_rstc_base),
+		  "r" (1),
+		  "r" (AT91_DDRSDRC_LPCB_POWER_DOWN),
+		  "r" (AT91_RSTC_KEY | AT91_RSTC_PERRST | AT91_RSTC_PROCRST)
+		: "r0");
+}
+
+static void __init at91_reset_status(struct platform_device *pdev)
+{
+	u32 reg = readl(at91_rstc_base + AT91_RSTC_SR);
+	char *reason;
+
+	switch ((reg & AT91_RSTC_RSTTYP) >> 8) {
+	case RESET_TYPE_GENERAL:
+		reason = "general reset";
+		break;
+	case RESET_TYPE_WAKEUP:
+		reason = "wakeup";
+		break;
+	case RESET_TYPE_WATCHDOG:
+		reason = "watchdog reset";
+		break;
+	case RESET_TYPE_SOFTWARE:
+		reason = "software reset";
+		break;
+	case RESET_TYPE_USER:
+		reason = "user reset";
+		break;
+	default:
+		reason = "unknown reset";
+		break;
+	}
+
+	pr_info("AT91: Starting after %s\n", reason);
+}
+
+static struct of_device_id at91_ramc_of_match[] = {
+	{ .compatible = "atmel,at91sam9260-sdramc", },
+	{ .compatible = "atmel,at91sam9g45-ddramc", },
+	{ .compatible = "atmel,sama5d3-ddramc", },
+	{ /* sentinel */ }
+};
+
+static struct of_device_id at91_reset_of_match[] = {
+	{ .compatible = "atmel,at91sam9260-rstc", .data = at91sam9260_restart },
+	{ .compatible = "atmel,at91sam9g45-rstc", .data = at91sam9g45_restart },
+	{ /* sentinel */ }
+};
+
+static int at91_reset_of_probe(struct platform_device *pdev)
+{
+	const struct of_device_id *match;
+	struct device_node *np;
+	int idx = 0;
+
+	at91_rstc_base = of_iomap(pdev->dev.of_node, 0);
+	if (!at91_rstc_base) {
+		dev_err(&pdev->dev, "Could not map reset controller address\n");
+		return -ENODEV;
+	}
+
+	for_each_matching_node(np, at91_ramc_of_match) {
+		at91_ramc_base[idx] = of_iomap(np, 0);
+		if (!at91_ramc_base[idx]) {
+			dev_err(&pdev->dev, "Could not map ram controller address\n");
+			return -ENODEV;
+		}
+		idx++;
+	}
+
+	match = of_match_node(at91_reset_of_match, pdev->dev.of_node);
+	arm_pm_restart = match->data;
+
+	return 0;
+}
+
+static int at91_reset_platform_probe(struct platform_device *pdev)
+{
+	const struct platform_device_id *match;
+	struct resource *res;
+	int idx = 0;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	at91_rstc_base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(at91_rstc_base)) {
+		dev_err(&pdev->dev, "Could not map reset controller address\n");
+		return PTR_ERR(at91_rstc_base);
+	}
+
+	for (idx = 0; idx < 2; idx++) {
+		res = platform_get_resource(pdev, IORESOURCE_MEM, idx + 1 );
+		at91_ramc_base[idx] = devm_ioremap(&pdev->dev, res->start,
+						   resource_size(res));
+		if (IS_ERR(at91_ramc_base[idx])) {
+			dev_err(&pdev->dev, "Could not map ram controller address\n");
+			return PTR_ERR(at91_ramc_base[idx]);
+		}
+	}
+
+	match = platform_get_device_id(pdev);
+	arm_pm_restart = (void (*)(enum reboot_mode, const char*))
+		match->driver_data;
+
+	return 0;
+}
+
+static int at91_reset_probe(struct platform_device *pdev)
+{
+	int ret;
+
+	if (pdev->dev.of_node)
+		ret = at91_reset_of_probe(pdev);
+	else
+		ret = at91_reset_platform_probe(pdev);
+
+	if (ret)
+		return ret;
+
+	at91_reset_status(pdev);
+
+	return 0;
+}
+
+static struct platform_device_id at91_reset_plat_match[] = {
+	{ "at91-sam9260-reset", (unsigned long)at91sam9260_restart },
+	{ "at91-sam9g45-reset", (unsigned long)at91sam9g45_restart },
+	{ /* sentinel */ }
+};
+
+static struct platform_driver at91_reset_driver = {
+	.probe = at91_reset_probe,
+	.driver = {
+		.name = "at91-reset",
+		.of_match_table = at91_reset_of_match,
+	},
+	.id_table = at91_reset_plat_match,
+};
+module_platform_driver(at91_reset_driver);
