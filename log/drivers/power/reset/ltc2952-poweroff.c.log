commit 1072ceada4586f7c1d316a0dd9fa751a7055969c
Author: Hongbo Yao <yaohongbo@huawei.com>
Date:   Sat May 9 18:36:11 2020 +0800

    power: reset: ltc2952: remove unused variable
    
    Fix gcc '-Wunused-but-set-variable' warning:
    drivers/power/reset/ltc2952-poweroff.c:97:16: warning: variable
    â€˜overrunsâ€™ set but not used [-Wunused-but-set-variable]
      unsigned long overruns;
    
    Reported-by: Hulk Robot <hulkci@huawei.com>
    Signed-off-by: Hongbo Yao <yaohongbo@huawei.com>
    Signed-off-by: Sebastian Reichel <sebastian.reichel@collabora.com>

diff --git a/drivers/power/reset/ltc2952-poweroff.c b/drivers/power/reset/ltc2952-poweroff.c
index e4a0cc45b3d1..318927938b05 100644
--- a/drivers/power/reset/ltc2952-poweroff.c
+++ b/drivers/power/reset/ltc2952-poweroff.c
@@ -94,7 +94,6 @@ static enum hrtimer_restart ltc2952_poweroff_timer_wde(struct hrtimer *timer)
 {
 	ktime_t now;
 	int state;
-	unsigned long overruns;
 	struct ltc2952_poweroff *data = to_ltc2952(timer, timer_wde);
 
 	if (data->kernel_panic)
@@ -104,7 +103,7 @@ static enum hrtimer_restart ltc2952_poweroff_timer_wde(struct hrtimer *timer)
 	gpiod_set_value(data->gpio_watchdog, !state);
 
 	now = hrtimer_cb_get_time(timer);
-	overruns = hrtimer_forward(timer, now, data->wde_interval);
+	hrtimer_forward(timer, now, data->wde_interval);
 
 	return HRTIMER_RESTART;
 }

commit c942fddf8793b2013be8c901b47d0a8dc02bf99f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:06 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 157
    
    Based on 3 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version [author] [kishon] [vijay] [abraham]
      [i] [kishon]@[ti] [com] this program is distributed in the hope that
      it will be useful but without any warranty without even the implied
      warranty of merchantability or fitness for a particular purpose see
      the gnu general public license for more details
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version [author] [graeme] [gregory]
      [gg]@[slimlogic] [co] [uk] [author] [kishon] [vijay] [abraham] [i]
      [kishon]@[ti] [com] [based] [on] [twl6030]_[usb] [c] [author] [hema]
      [hk] [hemahk]@[ti] [com] this program is distributed in the hope
      that it will be useful but without any warranty without even the
      implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1105 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.202006027@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/power/reset/ltc2952-poweroff.c b/drivers/power/reset/ltc2952-poweroff.c
index c484584745bc..e4a0cc45b3d1 100644
--- a/drivers/power/reset/ltc2952-poweroff.c
+++ b/drivers/power/reset/ltc2952-poweroff.c
@@ -1,19 +1,10 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * LTC2952 (PowerPath) driver
  *
  * Copyright (C) 2014, Xsens Technologies BV <info@xsens.com>
  * Maintainer: RenÃ© Moll <linux@r-moll.nl>
  *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
  * ----------------------------------------
  * - Description
  * ----------------------------------------
@@ -50,7 +41,6 @@
  *
  * The driver requires a non-shared, edge-triggered interrupt on the trigger
  * GPIO.
- *
  */
 
 #include <linux/kernel.h>

commit 3723c63247854c97fe044c12a40e29043e9bbc1b
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu Aug 23 17:01:26 2018 -0700

    treewide: convert ISO_8859-1 text comments to utf-8
    
    Almost all files in the kernel are either plain text or UTF-8 encoded.  A
    couple however are ISO_8859-1, usually just a few characters in a C
    comments, for historic reasons.
    
    This converts them all to UTF-8 for consistency.
    
    Link: http://lkml.kernel.org/r/20180724111600.4158975-1-arnd@arndb.de
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Simon Horman <horms@verge.net.au>                     [IPVS portion]
    Acked-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>        [IIO]
    Acked-by: Michael Ellerman <mpe@ellerman.id.au>                 [powerpc]
    Acked-by: Rob Herring <robh@kernel.org>
    Cc: Joe Perches <joe@perches.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Samuel Ortiz <sameo@linux.intel.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Rob Herring <robh+dt@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/power/reset/ltc2952-poweroff.c b/drivers/power/reset/ltc2952-poweroff.c
index 6b911b6b10a6..c484584745bc 100644
--- a/drivers/power/reset/ltc2952-poweroff.c
+++ b/drivers/power/reset/ltc2952-poweroff.c
@@ -2,7 +2,7 @@
  * LTC2952 (PowerPath) driver
  *
  * Copyright (C) 2014, Xsens Technologies BV <info@xsens.com>
- * Maintainer: René Moll <linux@r-moll.nl>
+ * Maintainer: RenÃ© Moll <linux@r-moll.nl>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -319,6 +319,6 @@ static struct platform_driver ltc2952_poweroff_driver = {
 
 module_platform_driver(ltc2952_poweroff_driver);
 
-MODULE_AUTHOR("René Moll <rene.moll@xsens.com>");
+MODULE_AUTHOR("RenÃ© Moll <rene.moll@xsens.com>");
 MODULE_DESCRIPTION("LTC PowerPath power-off driver");
 MODULE_LICENSE("GPL v2");

commit ac3167257b9fe16c9426c2087ead1c9f1b0992b1
Author: Randy Dunlap <rdunlap@infradead.org>
Date:   Tue Jun 19 22:47:28 2018 -0700

    headers: separate linux/mod_devicetable.h from linux/platform_device.h
    
    At over 4000 #includes, <linux/platform_device.h> is the 9th most
    #included header file in the Linux kernel.  It does not need
    <linux/mod_devicetable.h>, so drop that header and explicitly add
    <linux/mod_devicetable.h> to source files that need it.
    
       4146 #include <linux/platform_device.h>
    
    After this patch, there are 225 files that use <linux/mod_devicetable.h>,
    for a reduction of around 3900 times that <linux/mod_devicetable.h>
    does not have to be read & parsed.
    
        225 #include <linux/mod_devicetable.h>
    
    This patch was build-tested on 20 different arch-es.
    
    It also makes these drivers SubmitChecklist#1 compliant.
    
    Signed-off-by: Randy Dunlap <rdunlap@infradead.org>
    Reported-by: kbuild test robot <lkp@intel.com> # drivers/media/platform/vimc/
    Reported-by: kbuild test robot <lkp@intel.com> # drivers/pinctrl/pinctrl-u300.c
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/power/reset/ltc2952-poweroff.c b/drivers/power/reset/ltc2952-poweroff.c
index bfcd6fba6363..6b911b6b10a6 100644
--- a/drivers/power/reset/ltc2952-poweroff.c
+++ b/drivers/power/reset/ltc2952-poweroff.c
@@ -62,6 +62,7 @@
 #include <linux/slab.h>
 #include <linux/kmod.h>
 #include <linux/module.h>
+#include <linux/mod_devicetable.h>
 #include <linux/gpio/consumer.h>
 #include <linux/reboot.h>
 

commit 8b0e195314fabd58a331c4f7b6db75a1565535d7
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun Dec 25 12:30:41 2016 +0100

    ktime: Cleanup ktime_set() usage
    
    ktime_set(S,N) was required for the timespec storage type and is still
    useful for situations where a Seconds and Nanoseconds part of a time value
    needs to be converted. For anything where the Seconds argument is 0, this
    is pointless and can be replaced with a simple assignment.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Peter Zijlstra <peterz@infradead.org>

diff --git a/drivers/power/reset/ltc2952-poweroff.c b/drivers/power/reset/ltc2952-poweroff.c
index 15fed9d8f871..bfcd6fba6363 100644
--- a/drivers/power/reset/ltc2952-poweroff.c
+++ b/drivers/power/reset/ltc2952-poweroff.c
@@ -169,7 +169,7 @@ static void ltc2952_poweroff_kill(void)
 
 static void ltc2952_poweroff_default(struct ltc2952_poweroff *data)
 {
-	data->wde_interval = ktime_set(0, 300L*1E6L);
+	data->wde_interval = 300L * 1E6L;
 	data->trigger_delay = ktime_set(2, 500L*1E6L);
 
 	hrtimer_init(&data->timer_trigger, CLOCK_MONOTONIC, HRTIMER_MODE_REL);

commit 36a1624d8844b6c165daf61649e6b68c02d0835f
Merge: 5262f25f0983 43df61051ab9
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jun 23 16:10:27 2015 -0700

    Merge tag 'for-4.2' of git://git.infradead.org/battery-2.6
    
    Pull power supply and reset updates from Sebastian Reichel:
    
     - new charger drivers: BQ24257, BQ25890, AXP288, RT9455
    
     - MAX17042 battery: add health & temperature support
    
     - BQ2415x charger: add ACPI support
    
     - misc fixes and cleanups
    
    * tag 'for-4.2' of git://git.infradead.org/battery-2.6: (32 commits)
      power_supply: Correct kerneldoc copy paste errors
      wm831x_power: Fix off-by-one at free_irq()
      power_supply: rt9455_charger: Fix error reported by static analysis tool
      power_supply: bq24257: use flags argument of devm_gpiod_get
      power_supply: bq25890: use flags argument of devm_gpiod_get
      sbs-battery: add option to always register battery
      power: Add devm_power_supply_get_by_phandle() helper function
      power_supply: max17042: Add OF support for setting thresholds
      power_supply: sysfs: Bring back write to writeable properties
      power_supply: rt9455_charger: Check if CONFIG_USB_PHY is enabled
      power: reset: gpio-restart: increase priority slightly
      power_supply: bq25890: make chip_id int
      power_supply: Add support for Richtek RT9455 battery charger
      Documentation: devicetree: Add Richtek RT9455 bindings
      of: Add vendor prefix for Richtek Technology Corporation
      power_supply: 88pm860x_charger: Do not call free_irq() twice
      power: bq24190_charger: Change first_time flag reset condition
      power: axp288_charger: axp288 charger driver
      power: max17042_battery: add HEALTH and TEMP_* properties support
      power_supply: Add support for TI BQ25890 charger chip
      ...

commit 9f6cd98fc3c64ebcebf63c04f16246f79bcc4c70
Author: Uwe Kleine-KÃ¶nig <u.kleine-koenig@pengutronix.de>
Date:   Mon May 18 22:45:07 2015 +0200

    power: reset: ltc2952: use _optional variant of devm_gpiod_get
    
    devm_gpiod_get_optional returns NULL if devm_gpiod_get would return an
    ENOENT error pointer.
    
    There is no semantic change intended.
    
    Signed-off-by: Uwe Kleine-KÃ¶nig <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Sebastian Reichel <sre@kernel.org>

diff --git a/drivers/power/reset/ltc2952-poweroff.c b/drivers/power/reset/ltc2952-poweroff.c
index 1e08195551fe..62c91acd6584 100644
--- a/drivers/power/reset/ltc2952-poweroff.c
+++ b/drivers/power/reset/ltc2952-poweroff.c
@@ -202,16 +202,15 @@ static int ltc2952_poweroff_init(struct platform_device *pdev)
 		return ret;
 	}
 
-	data->gpio_trigger = devm_gpiod_get(&pdev->dev, "trigger", GPIOD_IN);
+	data->gpio_trigger = devm_gpiod_get_optional(&pdev->dev, "trigger",
+						     GPIOD_IN);
 	if (IS_ERR(data->gpio_trigger)) {
 		/*
 		 * It's not a problem if the trigger gpio isn't available, but
 		 * it is worth a warning if its use was defined in the device
 		 * tree.
 		 */
-		if (PTR_ERR(data->gpio_trigger) != -ENOENT)
-			dev_err(&pdev->dev,
-				"unable to claim gpio \"trigger\"\n");
+		dev_err(&pdev->dev, "unable to claim gpio \"trigger\"\n");
 		data->gpio_trigger = NULL;
 	}
 

commit d8818257d3befce6ce7da4c09112654914c3fd58
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Apr 14 21:09:20 2015 +0000

    power: reset: ltc2952: Remove bogus hrtimer_start() return value checks
    
    The return value of hrtimer_start() tells whether the timer was
    inactive or active already when hrtimer_start() was called.
    
    The code emits a bogus warning if the timer was active already
    claiming that the timer could not be started.
    
    Remove it.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Sebastian Reichel <sre@kernel.org>
    Cc: Dmitry Eremin-Solenikov <dbaryshkov@gmail.com>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: Frans Klaver <frans.klaver@xsens.com>
    Cc: "RenÃ© Moll" <linux@r-moll.nl>
    Cc: Wolfram Sang <wsa@the-dreams.de>
    Cc: linux-pm@vger.kernel.org
    Acked-by: Frans Klaver <frans.klaver@xsens.com>
    Signed-off-by: Sebastian Reichel <sre@kernel.org>

diff --git a/drivers/power/reset/ltc2952-poweroff.c b/drivers/power/reset/ltc2952-poweroff.c
index 7ef193b6f7fe..1e08195551fe 100644
--- a/drivers/power/reset/ltc2952-poweroff.c
+++ b/drivers/power/reset/ltc2952-poweroff.c
@@ -120,18 +120,7 @@ static enum hrtimer_restart ltc2952_poweroff_timer_wde(struct hrtimer *timer)
 
 static void ltc2952_poweroff_start_wde(struct ltc2952_poweroff *data)
 {
-	if (hrtimer_start(&data->timer_wde, data->wde_interval,
-			  HRTIMER_MODE_REL)) {
-		/*
-		 * The device will not toggle the watchdog reset,
-		 * thus shut down is only safe if the PowerPath controller
-		 * has a long enough time-off before triggering a hardware
-		 * power-off.
-		 *
-		 * Only sending a warning as the system will power-off anyway
-		 */
-		dev_err(data->dev, "unable to start the timer\n");
-	}
+	hrtimer_start(&data->timer_wde, data->wde_interval, HRTIMER_MODE_REL);
 }
 
 static enum hrtimer_restart
@@ -165,9 +154,8 @@ static irqreturn_t ltc2952_poweroff_handler(int irq, void *dev_id)
 	}
 
 	if (gpiod_get_value(data->gpio_trigger)) {
-		if (hrtimer_start(&data->timer_trigger, data->trigger_delay,
-				  HRTIMER_MODE_REL))
-			dev_err(data->dev, "unable to start the wait timer\n");
+		hrtimer_start(&data->timer_trigger, data->trigger_delay,
+			      HRTIMER_MODE_REL);
 	} else {
 		hrtimer_cancel(&data->timer_trigger);
 		/* omitting return value check, timer should have been valid */

commit 4101ecc23db90ae7e9b2a4b1cfe4aaf37405b4a8
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Apr 13 16:43:35 2015 +0200

    power: reset: ltc2952: Remove bogus hrtimer_start() return value checks
    
    The return value of hrtimer_start() tells whether the timer was
    inactive or active already when hrtimer_start() was called.
    
    The code emits a bogus warning if the timer was active already
    claiming that the timer could not be started.
    
    Remove it along with the bogus comment in the else path.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Frans Klaver <frans.klaver@xsens.com>
    Cc: Sebastian Reichel <sre@kernel.org>
    Cc: Dmitry Eremin-Solenikov <dbaryshkov@gmail.com>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: Wolfram Sang <wsa@the-dreams.de>
    Cc: linux-pm@vger.kernel.org

diff --git a/drivers/power/reset/ltc2952-poweroff.c b/drivers/power/reset/ltc2952-poweroff.c
index 7ef193b6f7fe..5f855f99bdfc 100644
--- a/drivers/power/reset/ltc2952-poweroff.c
+++ b/drivers/power/reset/ltc2952-poweroff.c
@@ -120,18 +120,7 @@ static enum hrtimer_restart ltc2952_poweroff_timer_wde(struct hrtimer *timer)
 
 static void ltc2952_poweroff_start_wde(struct ltc2952_poweroff *data)
 {
-	if (hrtimer_start(&data->timer_wde, data->wde_interval,
-			  HRTIMER_MODE_REL)) {
-		/*
-		 * The device will not toggle the watchdog reset,
-		 * thus shut down is only safe if the PowerPath controller
-		 * has a long enough time-off before triggering a hardware
-		 * power-off.
-		 *
-		 * Only sending a warning as the system will power-off anyway
-		 */
-		dev_err(data->dev, "unable to start the timer\n");
-	}
+	hrtimer_start(&data->timer_wde, data->wde_interval, HRTIMER_MODE_REL);
 }
 
 static enum hrtimer_restart
@@ -165,12 +154,10 @@ static irqreturn_t ltc2952_poweroff_handler(int irq, void *dev_id)
 	}
 
 	if (gpiod_get_value(data->gpio_trigger)) {
-		if (hrtimer_start(&data->timer_trigger, data->trigger_delay,
-				  HRTIMER_MODE_REL))
-			dev_err(data->dev, "unable to start the wait timer\n");
+		hrtimer_start(&data->timer_trigger, data->trigger_delay,
+			      HRTIMER_MODE_REL);
 	} else {
 		hrtimer_cancel(&data->timer_trigger);
-		/* omitting return value check, timer should have been valid */
 	}
 	return IRQ_HANDLED;
 }

commit ee18185331ded6bbcf1aa59b9a81545c1ff5eecd
Author: Frans Klaver <frans.klaver@xsens.com>
Date:   Wed Jan 14 09:15:45 2015 +0100

    power: reset: ltc2952: make trigger input optional
    
    Currently the ltc2952 supports only one button sequence to initiate
    powerdown. This is not always desirable, as even prolonged button
    presses can happen in use.
    
    Allow ltc2952 users to pick their own power down sequence, by making the
    trigger input optional. Since this still means that the ltc2952 may
    power down the platform if the power button is pressed for about 5
    seconds, we still need to make sure to start the watchdog toggle to
    prolong the system power for as long as we need it.
    
    This will still allow the system to control power using the kill signal.
    
    Signed-off-by: Frans Klaver <frans.klaver@xsens.com>
    Signed-off-by: Sebastian Reichel <sre@kernel.org>

diff --git a/drivers/power/reset/ltc2952-poweroff.c b/drivers/power/reset/ltc2952-poweroff.c
index b99bc251f5b4..7ef193b6f7fe 100644
--- a/drivers/power/reset/ltc2952-poweroff.c
+++ b/drivers/power/reset/ltc2952-poweroff.c
@@ -32,7 +32,9 @@
  * - trigger (input)
  *     A level change indicates the shut-down trigger. If it's state reverts
  *     within the time-out defined by trigger_delay, the shut down is not
- *     executed.
+ *     executed. If no pin is assigned to this input, the driver will start the
+ *     watchdog toggle immediately. The chip will only power off the system if
+ *     it is requested to do so through the kill line.
  *
  * - watchdog (output)
  *     Once a shut down is triggered, the driver will toggle this signal,
@@ -116,15 +118,10 @@ static enum hrtimer_restart ltc2952_poweroff_timer_wde(struct hrtimer *timer)
 	return HRTIMER_RESTART;
 }
 
-static enum hrtimer_restart
-ltc2952_poweroff_timer_trigger(struct hrtimer *timer)
+static void ltc2952_poweroff_start_wde(struct ltc2952_poweroff *data)
 {
-	struct ltc2952_poweroff *data = to_ltc2952(timer, timer_trigger);
-	int ret = hrtimer_start(&data->timer_wde,
-				data->wde_interval, HRTIMER_MODE_REL);
-
-	if (ret) {
-		dev_err(data->dev, "unable to start the timer\n");
+	if (hrtimer_start(&data->timer_wde, data->wde_interval,
+			  HRTIMER_MODE_REL)) {
 		/*
 		 * The device will not toggle the watchdog reset,
 		 * thus shut down is only safe if the PowerPath controller
@@ -133,10 +130,17 @@ ltc2952_poweroff_timer_trigger(struct hrtimer *timer)
 		 *
 		 * Only sending a warning as the system will power-off anyway
 		 */
+		dev_err(data->dev, "unable to start the timer\n");
 	}
+}
 
-	dev_info(data->dev, "executing shutdown\n");
+static enum hrtimer_restart
+ltc2952_poweroff_timer_trigger(struct hrtimer *timer)
+{
+	struct ltc2952_poweroff *data = to_ltc2952(timer, timer_trigger);
 
+	ltc2952_poweroff_start_wde(data);
+	dev_info(data->dev, "executing shutdown\n");
 	orderly_poweroff(true);
 
 	return HRTIMER_NORESTART;
@@ -190,7 +194,7 @@ static void ltc2952_poweroff_default(struct ltc2952_poweroff *data)
 
 static int ltc2952_poweroff_init(struct platform_device *pdev)
 {
-	int ret, virq;
+	int ret;
 	struct ltc2952_poweroff *data = platform_get_drvdata(pdev);
 
 	ltc2952_poweroff_default(data);
@@ -210,29 +214,48 @@ static int ltc2952_poweroff_init(struct platform_device *pdev)
 		return ret;
 	}
 
-	data->gpio_trigger = devm_gpiod_get(&pdev->dev, "trigger",
-					    GPIOD_IN);
-	if (IS_ERR(ltc2952_data->gpio_trigger)) {
-		ret = PTR_ERR(ltc2952_data->gpio_trigger);
-		dev_err(&pdev->dev, "unable to claim gpio \"trigger\"\n");
-		return ret;
-	}
-
-	virq = gpiod_to_irq(data->gpio_trigger);
-	if (virq < 0) {
-		dev_err(&pdev->dev, "cannot map GPIO as interrupt");
-		return ret;
+	data->gpio_trigger = devm_gpiod_get(&pdev->dev, "trigger", GPIOD_IN);
+	if (IS_ERR(data->gpio_trigger)) {
+		/*
+		 * It's not a problem if the trigger gpio isn't available, but
+		 * it is worth a warning if its use was defined in the device
+		 * tree.
+		 */
+		if (PTR_ERR(data->gpio_trigger) != -ENOENT)
+			dev_err(&pdev->dev,
+				"unable to claim gpio \"trigger\"\n");
+		data->gpio_trigger = NULL;
 	}
 
-	ret = devm_request_irq(&pdev->dev, virq,
-			       ltc2952_poweroff_handler,
-			       (IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING),
-			       "ltc2952-poweroff",
-			       data);
-
-	if (ret) {
-		dev_err(&pdev->dev, "cannot configure an interrupt handler\n");
-		return ret;
+	if (devm_request_irq(&pdev->dev, gpiod_to_irq(data->gpio_trigger),
+			     ltc2952_poweroff_handler,
+			     (IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING),
+			     "ltc2952-poweroff",
+			     data)) {
+		/*
+		 * Some things may have happened:
+		 * - No trigger input was defined
+		 * - Claiming the GPIO failed
+		 * - We could not map to an IRQ
+		 * - We couldn't register an interrupt handler
+		 *
+		 * None of these really are problems, but all of them
+		 * disqualify the push button from controlling the power.
+		 *
+		 * It is therefore important to note that if the ltc2952
+		 * detects a button press for long enough, it will still start
+		 * its own powerdown window and cut the power on us if we don't
+		 * start the watchdog trigger.
+		 */
+		if (data->gpio_trigger) {
+			dev_warn(&pdev->dev,
+				 "unable to configure the trigger interrupt\n");
+			devm_gpiod_put(&pdev->dev, data->gpio_trigger);
+			data->gpio_trigger = NULL;
+		}
+		dev_info(&pdev->dev,
+			 "power down trigger input will not be used\n");
+		ltc2952_poweroff_start_wde(data);
 	}
 
 	return 0;

commit c1ada2ff8045eacc11a3b894f2056aa5457b17b5
Author: Frans Klaver <frans.klaver@xsens.com>
Date:   Wed Jan 14 09:15:44 2015 +0100

    power: reset: ltc2952: check trigger value before starting timer
    
    In ltc2952_poweroff_handler it is theoretically possible that the timer
    fails to start on first pass (button press), but succeeds in starting on
    the second (button release). This will cause the button press to be
    misinterpreted, and will incorrectly shut down the system. Because a
    picture says more than a thousand words:
    
    Expected behavior:
    tmr:      ++++++++++
    btn: -----__________-----
    
    Faulty behavior:
    tmr:                +++++
    btn: -----__________-----
    
    Legend:
    + timer runs
    _ button pressed
    - button depressed
    
    To prevent this from happening, check the value of the gpio before
    starting the timer. If the button is active, we should start the timer,
    else we should stop it.
    
    The situation described can now still occur if the polarity of the input
    pin is set incorrectly, but that at least is predictable behavior and
    can be detected during the first tests.
    
    Signed-off-by: Frans Klaver <frans.klaver@xsens.com>
    Signed-off-by: Sebastian Reichel <sre@kernel.org>

diff --git a/drivers/power/reset/ltc2952-poweroff.c b/drivers/power/reset/ltc2952-poweroff.c
index 240b294a0980..b99bc251f5b4 100644
--- a/drivers/power/reset/ltc2952-poweroff.c
+++ b/drivers/power/reset/ltc2952-poweroff.c
@@ -160,7 +160,7 @@ static irqreturn_t ltc2952_poweroff_handler(int irq, void *dev_id)
 		return IRQ_HANDLED;
 	}
 
-	if (!hrtimer_active(&data->timer_trigger)) {
+	if (gpiod_get_value(data->gpio_trigger)) {
 		if (hrtimer_start(&data->timer_trigger, data->trigger_delay,
 				  HRTIMER_MODE_REL))
 			dev_err(data->dev, "unable to start the wait timer\n");

commit 2f6ea8ad738e7a9be1a675a4404606723797cc16
Author: Frans Klaver <frans.klaver@xsens.com>
Date:   Wed Jan 14 09:15:43 2015 +0100

    power: reset: ltc2952: disable timers in _remove
    
    Disable the timers when ltc2952_poweroff is removed. We don't want to
    risk calling functions on data that no longer exist.
    
    Signed-off-by: Frans Klaver <frans.klaver@xsens.com>
    Signed-off-by: Sebastian Reichel <sre@kernel.org>

diff --git a/drivers/power/reset/ltc2952-poweroff.c b/drivers/power/reset/ltc2952-poweroff.c
index 8e04b3299f9a..240b294a0980 100644
--- a/drivers/power/reset/ltc2952-poweroff.c
+++ b/drivers/power/reset/ltc2952-poweroff.c
@@ -285,6 +285,8 @@ static int ltc2952_poweroff_remove(struct platform_device *pdev)
 	struct ltc2952_poweroff *data = platform_get_drvdata(pdev);
 
 	pm_power_off = NULL;
+	hrtimer_cancel(&data->timer_trigger);
+	hrtimer_cancel(&data->timer_wde);
 	atomic_notifier_chain_unregister(&panic_notifier_list,
 					 &data->panic_notifier);
 	return 0;

commit 5689b786f77308e7aa10fd736e87b270ae42026e
Author: Frans Klaver <frans.klaver@xsens.com>
Date:   Wed Jan 14 09:15:42 2015 +0100

    power: reset: ltc2952: fix C++ style function pointers
    
    The function pointers for the timers and pm_power_off are assigned with
    C++ style
            foo = &func;
    
    Let's change it instead to the more C style
            foo = func;
    
    Signed-off-by: Frans Klaver <frans.klaver@xsens.com>
    Signed-off-by: Sebastian Reichel <sre@kernel.org>

diff --git a/drivers/power/reset/ltc2952-poweroff.c b/drivers/power/reset/ltc2952-poweroff.c
index 736af3961019..8e04b3299f9a 100644
--- a/drivers/power/reset/ltc2952-poweroff.c
+++ b/drivers/power/reset/ltc2952-poweroff.c
@@ -182,10 +182,10 @@ static void ltc2952_poweroff_default(struct ltc2952_poweroff *data)
 	data->trigger_delay = ktime_set(2, 500L*1E6L);
 
 	hrtimer_init(&data->timer_trigger, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
-	data->timer_trigger.function = &ltc2952_poweroff_timer_trigger;
+	data->timer_trigger.function = ltc2952_poweroff_timer_trigger;
 
 	hrtimer_init(&data->timer_wde, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
-	data->timer_wde.function = &ltc2952_poweroff_timer_wde;
+	data->timer_wde.function = ltc2952_poweroff_timer_wde;
 }
 
 static int ltc2952_poweroff_init(struct platform_device *pdev)
@@ -270,7 +270,7 @@ static int ltc2952_poweroff_probe(struct platform_device *pdev)
 
 	/* TODO: remove ltc2952_data */
 	ltc2952_data = data;
-	pm_power_off = &ltc2952_poweroff_kill;
+	pm_power_off = ltc2952_poweroff_kill;
 
 	data->panic_notifier.notifier_call = ltc2952_poweroff_notify_panic;
 	atomic_notifier_chain_register(&panic_notifier_list,

commit 5c3faad29b266da015e3726cff6556df5c3cd9f5
Author: Frans Klaver <frans.klaver@xsens.com>
Date:   Wed Jan 14 09:15:41 2015 +0100

    power: reset: ltc2952: cleanup control flow in poweroff_handler
    
    ltc2952_poweroff_handler uses gotos to return from the function. Since
    we don't do cleanups exiting this function, just return IRQ_HANDLED on
    the spot and be done with it.
    
    While at it, remove the variable 'ret'. It was never used very much.
    
    Signed-off-by: Frans Klaver <frans.klaver@xsens.com>
    Signed-off-by: Sebastian Reichel <sre@kernel.org>

diff --git a/drivers/power/reset/ltc2952-poweroff.c b/drivers/power/reset/ltc2952-poweroff.c
index d29948762ceb..736af3961019 100644
--- a/drivers/power/reset/ltc2952-poweroff.c
+++ b/drivers/power/reset/ltc2952-poweroff.c
@@ -153,29 +153,21 @@ ltc2952_poweroff_timer_trigger(struct hrtimer *timer)
  */
 static irqreturn_t ltc2952_poweroff_handler(int irq, void *dev_id)
 {
-	int ret;
 	struct ltc2952_poweroff *data = dev_id;
 
-	if (data->kernel_panic)
-		goto irq_ok;
-
-	if (hrtimer_active(&data->timer_wde)) {
+	if (data->kernel_panic || hrtimer_active(&data->timer_wde)) {
 		/* shutdown is already triggered, nothing to do any more */
-		goto irq_ok;
+		return IRQ_HANDLED;
 	}
 
 	if (!hrtimer_active(&data->timer_trigger)) {
-		ret = hrtimer_start(&data->timer_trigger, data->trigger_delay,
-			HRTIMER_MODE_REL);
-
-		if (ret)
+		if (hrtimer_start(&data->timer_trigger, data->trigger_delay,
+				  HRTIMER_MODE_REL))
 			dev_err(data->dev, "unable to start the wait timer\n");
 	} else {
-		ret = hrtimer_cancel(&data->timer_trigger);
+		hrtimer_cancel(&data->timer_trigger);
 		/* omitting return value check, timer should have been valid */
 	}
-
-irq_ok:
 	return IRQ_HANDLED;
 }
 

commit 0428c40d4c448f5dc63b0f76de14fa0affa7aa2f
Author: Frans Klaver <frans.klaver@xsens.com>
Date:   Wed Jan 14 09:15:40 2015 +0100

    power: reset: ltc2952: drop empty suspend/resume functions
    
    Documentation/SubmittingDrivers suggests these be implemented even when
    they do nothing. On the other hand, the platform code calls these
    functions 'legacy'. Suspend and resume operations should go into a
    pm_ops structure, pointed at by the driver's pm field. This approach
    would lead to a lot of boiler plate, while achieving nothing. Drop the
    functions instead.
    
    Signed-off-by: Frans Klaver <frans.klaver@xsens.com>
    Signed-off-by: Sebastian Reichel <sre@kernel.org>

diff --git a/drivers/power/reset/ltc2952-poweroff.c b/drivers/power/reset/ltc2952-poweroff.c
index 8c936ed555c1..d29948762ceb 100644
--- a/drivers/power/reset/ltc2952-poweroff.c
+++ b/drivers/power/reset/ltc2952-poweroff.c
@@ -184,17 +184,6 @@ static void ltc2952_poweroff_kill(void)
 	gpiod_set_value(ltc2952_data->gpio_kill, 1);
 }
 
-static int ltc2952_poweroff_suspend(struct platform_device *pdev,
-	pm_message_t state)
-{
-	return -ENOSYS;
-}
-
-static int ltc2952_poweroff_resume(struct platform_device *pdev)
-{
-	return -ENOSYS;
-}
-
 static void ltc2952_poweroff_default(struct ltc2952_poweroff *data)
 {
 	data->wde_interval = ktime_set(0, 300L*1E6L);
@@ -322,8 +311,6 @@ static struct platform_driver ltc2952_poweroff_driver = {
 		.name = "ltc2952-poweroff",
 		.of_match_table = of_ltc2952_poweroff_match,
 	},
-	.suspend = ltc2952_poweroff_suspend,
-	.resume = ltc2952_poweroff_resume,
 };
 
 module_platform_driver(ltc2952_poweroff_driver);

commit 818ca4c8c7be4910f896c702645009f09813347f
Author: Frans Klaver <frans.klaver@xsens.com>
Date:   Wed Jan 14 09:15:39 2015 +0100

    power: reset: ltc2952: remove global variable poweroff_panic
    
    As per Documentation/CodingStyle ch.4, we should keep global variables
    to a mininum. Move the panic state into the driver data, regardless of
    whether panic is a system state or not.
    
    This removes the need for the custom _init and _exit functions, so
    replace them with a call to the module_platform_driver() macro.
    
    Signed-off-by: Frans Klaver <frans.klaver@xsens.com>
    Signed-off-by: Sebastian Reichel <sre@kernel.org>

diff --git a/drivers/power/reset/ltc2952-poweroff.c b/drivers/power/reset/ltc2952-poweroff.c
index 83042691cd79..8c936ed555c1 100644
--- a/drivers/power/reset/ltc2952-poweroff.c
+++ b/drivers/power/reset/ltc2952-poweroff.c
@@ -75,6 +75,9 @@ struct ltc2952_poweroff {
 	struct gpio_desc *gpio_trigger;
 	struct gpio_desc *gpio_watchdog;
 	struct gpio_desc *gpio_kill;
+
+	bool kernel_panic;
+	struct notifier_block panic_notifier;
 };
 
 #define to_ltc2952(p, m) container_of(p, struct ltc2952_poweroff, m)
@@ -84,7 +87,6 @@ struct ltc2952_poweroff {
  * remove it entirely once we don't need the global state anymore.
  */
 static struct ltc2952_poweroff *ltc2952_data;
-static int ltc2952_poweroff_panic;
 
 /**
  * ltc2952_poweroff_timer_wde - Timer callback
@@ -102,7 +104,7 @@ static enum hrtimer_restart ltc2952_poweroff_timer_wde(struct hrtimer *timer)
 	unsigned long overruns;
 	struct ltc2952_poweroff *data = to_ltc2952(timer, timer_wde);
 
-	if (ltc2952_poweroff_panic)
+	if (data->kernel_panic)
 		return HRTIMER_NORESTART;
 
 	state = gpiod_get_value(data->gpio_watchdog);
@@ -154,7 +156,7 @@ static irqreturn_t ltc2952_poweroff_handler(int irq, void *dev_id)
 	int ret;
 	struct ltc2952_poweroff *data = dev_id;
 
-	if (ltc2952_poweroff_panic)
+	if (data->kernel_panic)
 		goto irq_ok;
 
 	if (hrtimer_active(&data->timer_wde)) {
@@ -255,6 +257,15 @@ static int ltc2952_poweroff_init(struct platform_device *pdev)
 	return 0;
 }
 
+static int ltc2952_poweroff_notify_panic(struct notifier_block *nb,
+					 unsigned long code, void *unused)
+{
+	struct ltc2952_poweroff *data = to_ltc2952(nb, panic_notifier);
+
+	data->kernel_panic = true;
+	return NOTIFY_DONE;
+}
+
 static int ltc2952_poweroff_probe(struct platform_device *pdev)
 {
 	int ret;
@@ -280,6 +291,9 @@ static int ltc2952_poweroff_probe(struct platform_device *pdev)
 	ltc2952_data = data;
 	pm_power_off = &ltc2952_poweroff_kill;
 
+	data->panic_notifier.notifier_call = ltc2952_poweroff_notify_panic;
+	atomic_notifier_chain_register(&panic_notifier_list,
+				       &data->panic_notifier);
 	dev_info(&pdev->dev, "probe successful\n");
 
 	return 0;
@@ -287,8 +301,11 @@ static int ltc2952_poweroff_probe(struct platform_device *pdev)
 
 static int ltc2952_poweroff_remove(struct platform_device *pdev)
 {
-	pm_power_off = NULL;
+	struct ltc2952_poweroff *data = platform_get_drvdata(pdev);
 
+	pm_power_off = NULL;
+	atomic_notifier_chain_unregister(&panic_notifier_list,
+					 &data->panic_notifier);
 	return 0;
 }
 
@@ -309,37 +326,7 @@ static struct platform_driver ltc2952_poweroff_driver = {
 	.resume = ltc2952_poweroff_resume,
 };
 
-static int ltc2952_poweroff_notify_panic(struct notifier_block *nb,
-	unsigned long code, void *unused)
-{
-	ltc2952_poweroff_panic = 1;
-	return NOTIFY_DONE;
-}
-
-static struct notifier_block ltc2952_poweroff_panic_nb = {
-	.notifier_call = ltc2952_poweroff_notify_panic,
-};
-
-static int __init ltc2952_poweroff_platform_init(void)
-{
-	ltc2952_poweroff_panic = 0;
-
-	atomic_notifier_chain_register(&panic_notifier_list,
-		&ltc2952_poweroff_panic_nb);
-
-	return platform_driver_register(&ltc2952_poweroff_driver);
-}
-
-static void __exit ltc2952_poweroff_platform_exit(void)
-{
-	atomic_notifier_chain_unregister(&panic_notifier_list,
-		&ltc2952_poweroff_panic_nb);
-
-	platform_driver_unregister(&ltc2952_poweroff_driver);
-}
-
-module_init(ltc2952_poweroff_platform_init);
-module_exit(ltc2952_poweroff_platform_exit);
+module_platform_driver(ltc2952_poweroff_driver);
 
 MODULE_AUTHOR("René Moll <rene.moll@xsens.com>");
 MODULE_DESCRIPTION("LTC PowerPath power-off driver");

commit a5f67be5200787aacc7143144bdab7efe7cd268a
Author: Frans Klaver <frans.klaver@xsens.com>
Date:   Wed Jan 14 09:15:38 2015 +0100

    power: reset: ltc2952: reduce dependency on global variables
    
    Documentation/CodingStyle ch.4 mentions in a side node that global
    variables should only be used if you really need them. Reduce the use of
    the global instance of ltc2952_poweroff so we may eventually remove it
    entirely.
    
    While at it, rename ltc2952_poweroff_data to ltc2952_poweroff, just to
    save that little bit of typing.
    
    Signed-off-by: Frans Klaver <frans.klaver@xsens.com>
    Signed-off-by: Sebastian Reichel <sre@kernel.org>

diff --git a/drivers/power/reset/ltc2952-poweroff.c b/drivers/power/reset/ltc2952-poweroff.c
index 4caa9d285026..83042691cd79 100644
--- a/drivers/power/reset/ltc2952-poweroff.c
+++ b/drivers/power/reset/ltc2952-poweroff.c
@@ -63,7 +63,7 @@
 #include <linux/gpio/consumer.h>
 #include <linux/reboot.h>
 
-struct ltc2952_poweroff_data {
+struct ltc2952_poweroff {
 	struct hrtimer timer_trigger;
 	struct hrtimer timer_wde;
 
@@ -77,8 +77,14 @@ struct ltc2952_poweroff_data {
 	struct gpio_desc *gpio_kill;
 };
 
+#define to_ltc2952(p, m) container_of(p, struct ltc2952_poweroff, m)
+
+/*
+ * This global variable is only needed for pm_power_off. We should
+ * remove it entirely once we don't need the global state anymore.
+ */
+static struct ltc2952_poweroff *ltc2952_data;
 static int ltc2952_poweroff_panic;
-static struct ltc2952_poweroff_data *ltc2952_data;
 
 /**
  * ltc2952_poweroff_timer_wde - Timer callback
@@ -94,29 +100,29 @@ static enum hrtimer_restart ltc2952_poweroff_timer_wde(struct hrtimer *timer)
 	ktime_t now;
 	int state;
 	unsigned long overruns;
+	struct ltc2952_poweroff *data = to_ltc2952(timer, timer_wde);
 
 	if (ltc2952_poweroff_panic)
 		return HRTIMER_NORESTART;
 
-	state = gpiod_get_value(ltc2952_data->gpio_watchdog);
-	gpiod_set_value(ltc2952_data->gpio_watchdog, !state);
+	state = gpiod_get_value(data->gpio_watchdog);
+	gpiod_set_value(data->gpio_watchdog, !state);
 
 	now = hrtimer_cb_get_time(timer);
-	overruns = hrtimer_forward(timer, now, ltc2952_data->wde_interval);
+	overruns = hrtimer_forward(timer, now, data->wde_interval);
 
 	return HRTIMER_RESTART;
 }
 
-static enum hrtimer_restart ltc2952_poweroff_timer_trigger(
-	struct hrtimer *timer)
+static enum hrtimer_restart
+ltc2952_poweroff_timer_trigger(struct hrtimer *timer)
 {
-	int ret;
-
-	ret = hrtimer_start(&ltc2952_data->timer_wde,
-			    ltc2952_data->wde_interval, HRTIMER_MODE_REL);
+	struct ltc2952_poweroff *data = to_ltc2952(timer, timer_trigger);
+	int ret = hrtimer_start(&data->timer_wde,
+				data->wde_interval, HRTIMER_MODE_REL);
 
 	if (ret) {
-		dev_err(ltc2952_data->dev, "unable to start the timer\n");
+		dev_err(data->dev, "unable to start the timer\n");
 		/*
 		 * The device will not toggle the watchdog reset,
 		 * thus shut down is only safe if the PowerPath controller
@@ -127,7 +133,7 @@ static enum hrtimer_restart ltc2952_poweroff_timer_trigger(
 		 */
 	}
 
-	dev_info(ltc2952_data->dev, "executing shutdown\n");
+	dev_info(data->dev, "executing shutdown\n");
 
 	orderly_poweroff(true);
 
@@ -146,7 +152,7 @@ static enum hrtimer_restart ltc2952_poweroff_timer_trigger(
 static irqreturn_t ltc2952_poweroff_handler(int irq, void *dev_id)
 {
 	int ret;
-	struct ltc2952_poweroff_data *data = dev_id;
+	struct ltc2952_poweroff *data = dev_id;
 
 	if (ltc2952_poweroff_panic)
 		goto irq_ok;
@@ -187,7 +193,7 @@ static int ltc2952_poweroff_resume(struct platform_device *pdev)
 	return -ENOSYS;
 }
 
-static void ltc2952_poweroff_default(struct ltc2952_poweroff_data *data)
+static void ltc2952_poweroff_default(struct ltc2952_poweroff *data)
 {
 	data->wde_interval = ktime_set(0, 300L*1E6L);
 	data->trigger_delay = ktime_set(2, 500L*1E6L);
@@ -202,36 +208,34 @@ static void ltc2952_poweroff_default(struct ltc2952_poweroff_data *data)
 static int ltc2952_poweroff_init(struct platform_device *pdev)
 {
 	int ret, virq;
-	struct ltc2952_poweroff_data *data;
+	struct ltc2952_poweroff *data = platform_get_drvdata(pdev);
 
-	data = ltc2952_data;
-	ltc2952_poweroff_default(ltc2952_data);
+	ltc2952_poweroff_default(data);
 
-	ltc2952_data->gpio_watchdog = devm_gpiod_get(&pdev->dev, "watchdog",
-						     GPIOD_OUT_LOW);
-	if (IS_ERR(ltc2952_data->gpio_watchdog)) {
-		ret = PTR_ERR(ltc2952_data->gpio_watchdog);
+	data->gpio_watchdog = devm_gpiod_get(&pdev->dev, "watchdog",
+					     GPIOD_OUT_LOW);
+	if (IS_ERR(data->gpio_watchdog)) {
+		ret = PTR_ERR(data->gpio_watchdog);
 		dev_err(&pdev->dev, "unable to claim gpio \"watchdog\"\n");
 		return ret;
 	}
 
-	ltc2952_data->gpio_kill = devm_gpiod_get(&pdev->dev, "kill",
-						 GPIOD_OUT_LOW);
-	if (IS_ERR(ltc2952_data->gpio_kill)) {
-		ret = PTR_ERR(ltc2952_data->gpio_kill);
+	data->gpio_kill = devm_gpiod_get(&pdev->dev, "kill", GPIOD_OUT_LOW);
+	if (IS_ERR(data->gpio_kill)) {
+		ret = PTR_ERR(data->gpio_kill);
 		dev_err(&pdev->dev, "unable to claim gpio \"kill\"\n");
 		return ret;
 	}
 
-	ltc2952_data->gpio_trigger = devm_gpiod_get(&pdev->dev, "trigger",
-						    GPIOD_IN);
+	data->gpio_trigger = devm_gpiod_get(&pdev->dev, "trigger",
+					    GPIOD_IN);
 	if (IS_ERR(ltc2952_data->gpio_trigger)) {
 		ret = PTR_ERR(ltc2952_data->gpio_trigger);
 		dev_err(&pdev->dev, "unable to claim gpio \"trigger\"\n");
 		return ret;
 	}
 
-	virq = gpiod_to_irq(ltc2952_data->gpio_trigger);
+	virq = gpiod_to_irq(data->gpio_trigger);
 	if (virq < 0) {
 		dev_err(&pdev->dev, "cannot map GPIO as interrupt");
 		return ret;
@@ -241,7 +245,7 @@ static int ltc2952_poweroff_init(struct platform_device *pdev)
 			       ltc2952_poweroff_handler,
 			       (IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING),
 			       "ltc2952-poweroff",
-			       ltc2952_data);
+			       data);
 
 	if (ret) {
 		dev_err(&pdev->dev, "cannot configure an interrupt handler\n");
@@ -254,23 +258,26 @@ static int ltc2952_poweroff_init(struct platform_device *pdev)
 static int ltc2952_poweroff_probe(struct platform_device *pdev)
 {
 	int ret;
+	struct ltc2952_poweroff *data;
 
 	if (pm_power_off) {
 		dev_err(&pdev->dev, "pm_power_off already registered");
 		return -EBUSY;
 	}
 
-	ltc2952_data = devm_kzalloc(&pdev->dev, sizeof(*ltc2952_data),
-				    GFP_KERNEL);
-	if (!ltc2952_data)
+	data = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);
+	if (!data)
 		return -ENOMEM;
 
-	ltc2952_data->dev = &pdev->dev;
+	data->dev = &pdev->dev;
+	platform_set_drvdata(pdev, data);
 
 	ret = ltc2952_poweroff_init(pdev);
 	if (ret)
 		return ret;
 
+	/* TODO: remove ltc2952_data */
+	ltc2952_data = data;
 	pm_power_off = &ltc2952_poweroff_kill;
 
 	dev_info(&pdev->dev, "probe successful\n");

commit 62113b31174a9dba99eda8a4222417dd526c7c79
Author: Frans Klaver <frans.klaver@xsens.com>
Date:   Wed Jan 14 09:15:37 2015 +0100

    power: reset: ltc2952: prefer devm_gpiod_get over gpiod_get
    
    This reduces cleanup code and chance of errors.
    
    Signed-off-by: Frans Klaver <frans.klaver@xsens.com>
    Signed-off-by: Sebastian Reichel <sre@kernel.org>

diff --git a/drivers/power/reset/ltc2952-poweroff.c b/drivers/power/reset/ltc2952-poweroff.c
index accadfc01270..4caa9d285026 100644
--- a/drivers/power/reset/ltc2952-poweroff.c
+++ b/drivers/power/reset/ltc2952-poweroff.c
@@ -207,44 +207,34 @@ static int ltc2952_poweroff_init(struct platform_device *pdev)
 	data = ltc2952_data;
 	ltc2952_poweroff_default(ltc2952_data);
 
-	ltc2952_data->gpio_watchdog = gpiod_get(&pdev->dev, "watchdog");
+	ltc2952_data->gpio_watchdog = devm_gpiod_get(&pdev->dev, "watchdog",
+						     GPIOD_OUT_LOW);
 	if (IS_ERR(ltc2952_data->gpio_watchdog)) {
 		ret = PTR_ERR(ltc2952_data->gpio_watchdog);
 		dev_err(&pdev->dev, "unable to claim gpio \"watchdog\"\n");
 		return ret;
 	}
 
-	ltc2952_data->gpio_kill = gpiod_get(&pdev->dev, "kill");
+	ltc2952_data->gpio_kill = devm_gpiod_get(&pdev->dev, "kill",
+						 GPIOD_OUT_LOW);
 	if (IS_ERR(ltc2952_data->gpio_kill)) {
 		ret = PTR_ERR(ltc2952_data->gpio_kill);
 		dev_err(&pdev->dev, "unable to claim gpio \"kill\"\n");
-		goto err_kill;
+		return ret;
 	}
 
-	ltc2952_data->gpio_trigger = gpiod_get(&pdev->dev, "trigger");
+	ltc2952_data->gpio_trigger = devm_gpiod_get(&pdev->dev, "trigger",
+						    GPIOD_IN);
 	if (IS_ERR(ltc2952_data->gpio_trigger)) {
 		ret = PTR_ERR(ltc2952_data->gpio_trigger);
 		dev_err(&pdev->dev, "unable to claim gpio \"trigger\"\n");
-		goto err_trigger;
-	}
-
-	ret = gpiod_direction_output(
-		ltc2952_data->gpio_watchdog, 0);
-	if (ret) {
-		dev_err(&pdev->dev, "unable to use watchdog-gpio as output\n");
-		goto err_io;
-	}
-
-	ret = gpiod_direction_output(ltc2952_data->gpio_kill, 0);
-	if (ret) {
-		dev_err(&pdev->dev, "unable to use kill-gpio as output\n");
-		goto err_io;
+		return ret;
 	}
 
 	virq = gpiod_to_irq(ltc2952_data->gpio_trigger);
 	if (virq < 0) {
 		dev_err(&pdev->dev, "cannot map GPIO as interrupt");
-		goto err_io;
+		return ret;
 	}
 
 	ret = devm_request_irq(&pdev->dev, virq,
@@ -255,19 +245,10 @@ static int ltc2952_poweroff_init(struct platform_device *pdev)
 
 	if (ret) {
 		dev_err(&pdev->dev, "cannot configure an interrupt handler\n");
-		goto err_io;
+		return ret;
 	}
 
 	return 0;
-
-err_io:
-	gpiod_put(ltc2952_data->gpio_trigger);
-err_trigger:
-	gpiod_put(ltc2952_data->gpio_kill);
-err_kill:
-	gpiod_put(ltc2952_data->gpio_watchdog);
-
-	return ret;
 }
 
 static int ltc2952_poweroff_probe(struct platform_device *pdev)
@@ -301,11 +282,6 @@ static int ltc2952_poweroff_remove(struct platform_device *pdev)
 {
 	pm_power_off = NULL;
 
-	if (ltc2952_data) {
-		gpiod_put(ltc2952_data->gpio_trigger);
-		gpiod_put(ltc2952_data->gpio_watchdog);
-		gpiod_put(ltc2952_data->gpio_kill);
-	}
 	return 0;
 }
 

commit f66472df697ed6341e2317d5c825f2d6916ae47f
Author: Frans Klaver <frans.klaver@xsens.com>
Date:   Wed Jan 14 09:15:36 2015 +0100

    power: reset: ltc2952: unroll gpio_desc array
    
    The three gpio's used by this driver are stored in an array of pointers.
    This doesn't add much besides cleanups in a loop. In fact, it makes most
    of the usage sites harder to read. Unroll the loop, and live with the
    fact that cleanups become slightly larger.
    
    Signed-off-by: Frans Klaver <frans.klaver@xsens.com>
    Signed-off-by: Sebastian Reichel <sre@kernel.org>

diff --git a/drivers/power/reset/ltc2952-poweroff.c b/drivers/power/reset/ltc2952-poweroff.c
index 0b0792a9ad56..accadfc01270 100644
--- a/drivers/power/reset/ltc2952-poweroff.c
+++ b/drivers/power/reset/ltc2952-poweroff.c
@@ -72,21 +72,14 @@ struct ltc2952_poweroff_data {
 
 	struct device *dev;
 
-	/**
-	 * 0: trigger
-	 * 1: watchdog
-	 * 2: kill
-	 */
-	struct gpio_desc *gpio[3];
+	struct gpio_desc *gpio_trigger;
+	struct gpio_desc *gpio_watchdog;
+	struct gpio_desc *gpio_kill;
 };
 
 static int ltc2952_poweroff_panic;
 static struct ltc2952_poweroff_data *ltc2952_data;
 
-#define POWERPATH_IO_TRIGGER	0
-#define POWERPATH_IO_WATCHDOG	1
-#define POWERPATH_IO_KILL	2
-
 /**
  * ltc2952_poweroff_timer_wde - Timer callback
  * Toggles the watchdog reset signal each wde_interval
@@ -105,8 +98,8 @@ static enum hrtimer_restart ltc2952_poweroff_timer_wde(struct hrtimer *timer)
 	if (ltc2952_poweroff_panic)
 		return HRTIMER_NORESTART;
 
-	state = gpiod_get_value(ltc2952_data->gpio[POWERPATH_IO_WATCHDOG]);
-	gpiod_set_value(ltc2952_data->gpio[POWERPATH_IO_WATCHDOG], !state);
+	state = gpiod_get_value(ltc2952_data->gpio_watchdog);
+	gpiod_set_value(ltc2952_data->gpio_watchdog, !state);
 
 	now = hrtimer_cb_get_time(timer);
 	overruns = hrtimer_forward(timer, now, ltc2952_data->wde_interval);
@@ -120,7 +113,7 @@ static enum hrtimer_restart ltc2952_poweroff_timer_trigger(
 	int ret;
 
 	ret = hrtimer_start(&ltc2952_data->timer_wde,
-		ltc2952_data->wde_interval, HRTIMER_MODE_REL);
+			    ltc2952_data->wde_interval, HRTIMER_MODE_REL);
 
 	if (ret) {
 		dev_err(ltc2952_data->dev, "unable to start the timer\n");
@@ -180,7 +173,7 @@ static irqreturn_t ltc2952_poweroff_handler(int irq, void *dev_id)
 
 static void ltc2952_poweroff_kill(void)
 {
-	gpiod_set_value(ltc2952_data->gpio[POWERPATH_IO_KILL], 1);
+	gpiod_set_value(ltc2952_data->gpio_kill, 1);
 }
 
 static int ltc2952_poweroff_suspend(struct platform_device *pdev,
@@ -196,11 +189,6 @@ static int ltc2952_poweroff_resume(struct platform_device *pdev)
 
 static void ltc2952_poweroff_default(struct ltc2952_poweroff_data *data)
 {
-	unsigned int i;
-
-	for (i = 0; i < ARRAY_SIZE(data->gpio); i++)
-		data->gpio[i] = NULL;
-
 	data->wde_interval = ktime_set(0, 300L*1E6L);
 	data->trigger_delay = ktime_set(2, 500L*1E6L);
 
@@ -214,45 +202,46 @@ static void ltc2952_poweroff_default(struct ltc2952_poweroff_data *data)
 static int ltc2952_poweroff_init(struct platform_device *pdev)
 {
 	int ret, virq;
-	unsigned int i;
 	struct ltc2952_poweroff_data *data;
 
-	static char *name[] = {
-		"trigger",
-		"watchdog",
-		"kill",
-		NULL
-	};
-
 	data = ltc2952_data;
 	ltc2952_poweroff_default(ltc2952_data);
 
-	for (i = 0; i < ARRAY_SIZE(ltc2952_data->gpio); i++) {
-		ltc2952_data->gpio[i] = gpiod_get(&pdev->dev, name[i]);
+	ltc2952_data->gpio_watchdog = gpiod_get(&pdev->dev, "watchdog");
+	if (IS_ERR(ltc2952_data->gpio_watchdog)) {
+		ret = PTR_ERR(ltc2952_data->gpio_watchdog);
+		dev_err(&pdev->dev, "unable to claim gpio \"watchdog\"\n");
+		return ret;
+	}
 
-		if (IS_ERR(ltc2952_data->gpio[i])) {
-			ret = PTR_ERR(ltc2952_data->gpio[i]);
-			dev_err(&pdev->dev,
-				"unable to claim the following gpio: %s\n",
-				name[i]);
-			goto err_io;
-		}
+	ltc2952_data->gpio_kill = gpiod_get(&pdev->dev, "kill");
+	if (IS_ERR(ltc2952_data->gpio_kill)) {
+		ret = PTR_ERR(ltc2952_data->gpio_kill);
+		dev_err(&pdev->dev, "unable to claim gpio \"kill\"\n");
+		goto err_kill;
+	}
+
+	ltc2952_data->gpio_trigger = gpiod_get(&pdev->dev, "trigger");
+	if (IS_ERR(ltc2952_data->gpio_trigger)) {
+		ret = PTR_ERR(ltc2952_data->gpio_trigger);
+		dev_err(&pdev->dev, "unable to claim gpio \"trigger\"\n");
+		goto err_trigger;
 	}
 
 	ret = gpiod_direction_output(
-		ltc2952_data->gpio[POWERPATH_IO_WATCHDOG], 0);
+		ltc2952_data->gpio_watchdog, 0);
 	if (ret) {
 		dev_err(&pdev->dev, "unable to use watchdog-gpio as output\n");
 		goto err_io;
 	}
 
-	ret = gpiod_direction_output(ltc2952_data->gpio[POWERPATH_IO_KILL], 0);
+	ret = gpiod_direction_output(ltc2952_data->gpio_kill, 0);
 	if (ret) {
 		dev_err(&pdev->dev, "unable to use kill-gpio as output\n");
 		goto err_io;
 	}
 
-	virq = gpiod_to_irq(ltc2952_data->gpio[POWERPATH_IO_TRIGGER]);
+	virq = gpiod_to_irq(ltc2952_data->gpio_trigger);
 	if (virq < 0) {
 		dev_err(&pdev->dev, "cannot map GPIO as interrupt");
 		goto err_io;
@@ -272,9 +261,11 @@ static int ltc2952_poweroff_init(struct platform_device *pdev)
 	return 0;
 
 err_io:
-	for (i = 0; i < ARRAY_SIZE(ltc2952_data->gpio); i++)
-		if (ltc2952_data->gpio[i])
-			gpiod_put(ltc2952_data->gpio[i]);
+	gpiod_put(ltc2952_data->gpio_trigger);
+err_trigger:
+	gpiod_put(ltc2952_data->gpio_kill);
+err_kill:
+	gpiod_put(ltc2952_data->gpio_watchdog);
 
 	return ret;
 }
@@ -308,14 +299,13 @@ static int ltc2952_poweroff_probe(struct platform_device *pdev)
 
 static int ltc2952_poweroff_remove(struct platform_device *pdev)
 {
-	unsigned int i;
-
 	pm_power_off = NULL;
 
-	if (ltc2952_data)
-		for (i = 0; i < ARRAY_SIZE(ltc2952_data->gpio); i++)
-			gpiod_put(ltc2952_data->gpio[i]);
-
+	if (ltc2952_data) {
+		gpiod_put(ltc2952_data->gpio_trigger);
+		gpiod_put(ltc2952_data->gpio_watchdog);
+		gpiod_put(ltc2952_data->gpio_kill);
+	}
 	return 0;
 }
 

commit 07d08237d3ff08c6a53c6e8496bd255176e1d68f
Author: Frans Klaver <frans.klaver@xsens.com>
Date:   Wed Jan 14 09:15:35 2015 +0100

    power: reset: ltc2952: prefer devm_request_irq over request_irq
    
    Make use of the fact that we allocated resources can be automatically
    deallocated. This reduces cleanup code and chance of errors. It also
    removes the need for the virq member of the ltc2952_poweroff_data
    struct.
    
    Signed-off-by: Frans Klaver <frans.klaver@xsens.com>
    Signed-off-by: Sebastian Reichel <sre@kernel.org>

diff --git a/drivers/power/reset/ltc2952-poweroff.c b/drivers/power/reset/ltc2952-poweroff.c
index 6487b991ed45..0b0792a9ad56 100644
--- a/drivers/power/reset/ltc2952-poweroff.c
+++ b/drivers/power/reset/ltc2952-poweroff.c
@@ -72,8 +72,6 @@ struct ltc2952_poweroff_data {
 
 	struct device *dev;
 
-	unsigned int virq;
-
 	/**
 	 * 0: trigger
 	 * 1: watchdog
@@ -260,13 +258,11 @@ static int ltc2952_poweroff_init(struct platform_device *pdev)
 		goto err_io;
 	}
 
-	ltc2952_data->virq = virq;
-	ret = request_irq(virq,
-		ltc2952_poweroff_handler,
-		(IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING),
-		"ltc2952-poweroff",
-		ltc2952_data
-	);
+	ret = devm_request_irq(&pdev->dev, virq,
+			       ltc2952_poweroff_handler,
+			       (IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING),
+			       "ltc2952-poweroff",
+			       ltc2952_data);
 
 	if (ret) {
 		dev_err(&pdev->dev, "cannot configure an interrupt handler\n");
@@ -316,12 +312,9 @@ static int ltc2952_poweroff_remove(struct platform_device *pdev)
 
 	pm_power_off = NULL;
 
-	if (ltc2952_data) {
-		free_irq(ltc2952_data->virq, ltc2952_data);
-
+	if (ltc2952_data)
 		for (i = 0; i < ARRAY_SIZE(ltc2952_data->gpio); i++)
 			gpiod_put(ltc2952_data->gpio[i]);
-	}
 
 	return 0;
 }

commit 0a5c6a2276fe06a3ebb6a9ed26c0b8007074958e
Author: Frans Klaver <frans.klaver@xsens.com>
Date:   Wed Jan 14 09:15:34 2015 +0100

    power: reset: ltc2952: prefer devm_kzalloc over kzalloc
    
    Make use of the fact that the allocated resources can be automatically
    deallocated. This reduces cleanup code and chance of leaks.
    
    Signed-off-by: Frans Klaver <frans.klaver@xsens.com>
    Signed-off-by: Sebastian Reichel <sre@kernel.org>

diff --git a/drivers/power/reset/ltc2952-poweroff.c b/drivers/power/reset/ltc2952-poweroff.c
index 34f38a3dc3ff..6487b991ed45 100644
--- a/drivers/power/reset/ltc2952-poweroff.c
+++ b/drivers/power/reset/ltc2952-poweroff.c
@@ -292,7 +292,8 @@ static int ltc2952_poweroff_probe(struct platform_device *pdev)
 		return -EBUSY;
 	}
 
-	ltc2952_data = kzalloc(sizeof(*ltc2952_data), GFP_KERNEL);
+	ltc2952_data = devm_kzalloc(&pdev->dev, sizeof(*ltc2952_data),
+				    GFP_KERNEL);
 	if (!ltc2952_data)
 		return -ENOMEM;
 
@@ -300,17 +301,13 @@ static int ltc2952_poweroff_probe(struct platform_device *pdev)
 
 	ret = ltc2952_poweroff_init(pdev);
 	if (ret)
-		goto err;
+		return ret;
 
 	pm_power_off = &ltc2952_poweroff_kill;
 
 	dev_info(&pdev->dev, "probe successful\n");
 
 	return 0;
-
-err:
-	kfree(ltc2952_data);
-	return ret;
 }
 
 static int ltc2952_poweroff_remove(struct platform_device *pdev)
@@ -324,8 +321,6 @@ static int ltc2952_poweroff_remove(struct platform_device *pdev)
 
 		for (i = 0; i < ARRAY_SIZE(ltc2952_data->gpio); i++)
 			gpiod_put(ltc2952_data->gpio[i]);
-
-		kfree(ltc2952_data);
 	}
 
 	return 0;

commit 5938ee2bb2e45bfd601896677eb5db3e21339689
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Mon Oct 20 16:21:28 2014 +0200

    power: reset: drop owner assignment from platform_drivers
    
    A platform_driver does not need to set an owner, it will be populated by the
    driver core.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/power/reset/ltc2952-poweroff.c b/drivers/power/reset/ltc2952-poweroff.c
index 116a1cef8f7b..34f38a3dc3ff 100644
--- a/drivers/power/reset/ltc2952-poweroff.c
+++ b/drivers/power/reset/ltc2952-poweroff.c
@@ -342,7 +342,6 @@ static struct platform_driver ltc2952_poweroff_driver = {
 	.remove = ltc2952_poweroff_remove,
 	.driver = {
 		.name = "ltc2952-poweroff",
-		.owner = THIS_MODULE,
 		.of_match_table = of_ltc2952_poweroff_match,
 	},
 	.suspend = ltc2952_poweroff_suspend,

commit 6647156c00cc70c1e93161c3cf178071b3381bbb
Author: RenÃ© Moll <Rene.Moll@xsens.com>
Date:   Fri Aug 8 13:12:17 2014 +0000

    power: reset: add LTC2952 poweroff driver
    
    This adds a driver for the LTC2952, an external power control chip,
    which signals the OS to shut down. Additionally this driver lets the
    kernel power down the board.
    
    Signed-off-by: RenÃ© Moll <rene.moll@xsens.com>
    Signed-off-by: Sebastian Reichel <sre@kernel.org>

diff --git a/drivers/power/reset/ltc2952-poweroff.c b/drivers/power/reset/ltc2952-poweroff.c
new file mode 100644
index 000000000000..116a1cef8f7b
--- /dev/null
+++ b/drivers/power/reset/ltc2952-poweroff.c
@@ -0,0 +1,386 @@
+/*
+ * LTC2952 (PowerPath) driver
+ *
+ * Copyright (C) 2014, Xsens Technologies BV <info@xsens.com>
+ * Maintainer: René Moll <linux@r-moll.nl>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * ----------------------------------------
+ * - Description
+ * ----------------------------------------
+ *
+ * This driver is to be used with an external PowerPath Controller (LTC2952).
+ * Its function is to determine when a external shut down is triggered
+ * and react by properly shutting down the system.
+ *
+ * This driver expects a device tree with a ltc2952 entry for pin mapping.
+ *
+ * ----------------------------------------
+ * - GPIO
+ * ----------------------------------------
+ *
+ * The following GPIOs are used:
+ * - trigger (input)
+ *     A level change indicates the shut-down trigger. If it's state reverts
+ *     within the time-out defined by trigger_delay, the shut down is not
+ *     executed.
+ *
+ * - watchdog (output)
+ *     Once a shut down is triggered, the driver will toggle this signal,
+ *     with an internal (wde_interval) to stall the hardware shut down.
+ *
+ * - kill (output)
+ *     The last action during shut down is triggering this signalling, such
+ *     that the PowerPath Control will power down the hardware.
+ *
+ * ----------------------------------------
+ * - Interrupts
+ * ----------------------------------------
+ *
+ * The driver requires a non-shared, edge-triggered interrupt on the trigger
+ * GPIO.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/ktime.h>
+#include <linux/slab.h>
+#include <linux/kmod.h>
+#include <linux/module.h>
+#include <linux/gpio/consumer.h>
+#include <linux/reboot.h>
+
+struct ltc2952_poweroff_data {
+	struct hrtimer timer_trigger;
+	struct hrtimer timer_wde;
+
+	ktime_t trigger_delay;
+	ktime_t wde_interval;
+
+	struct device *dev;
+
+	unsigned int virq;
+
+	/**
+	 * 0: trigger
+	 * 1: watchdog
+	 * 2: kill
+	 */
+	struct gpio_desc *gpio[3];
+};
+
+static int ltc2952_poweroff_panic;
+static struct ltc2952_poweroff_data *ltc2952_data;
+
+#define POWERPATH_IO_TRIGGER	0
+#define POWERPATH_IO_WATCHDOG	1
+#define POWERPATH_IO_KILL	2
+
+/**
+ * ltc2952_poweroff_timer_wde - Timer callback
+ * Toggles the watchdog reset signal each wde_interval
+ *
+ * @timer: corresponding timer
+ *
+ * Returns HRTIMER_RESTART for an infinite loop which will only stop when the
+ * machine actually shuts down
+ */
+static enum hrtimer_restart ltc2952_poweroff_timer_wde(struct hrtimer *timer)
+{
+	ktime_t now;
+	int state;
+	unsigned long overruns;
+
+	if (ltc2952_poweroff_panic)
+		return HRTIMER_NORESTART;
+
+	state = gpiod_get_value(ltc2952_data->gpio[POWERPATH_IO_WATCHDOG]);
+	gpiod_set_value(ltc2952_data->gpio[POWERPATH_IO_WATCHDOG], !state);
+
+	now = hrtimer_cb_get_time(timer);
+	overruns = hrtimer_forward(timer, now, ltc2952_data->wde_interval);
+
+	return HRTIMER_RESTART;
+}
+
+static enum hrtimer_restart ltc2952_poweroff_timer_trigger(
+	struct hrtimer *timer)
+{
+	int ret;
+
+	ret = hrtimer_start(&ltc2952_data->timer_wde,
+		ltc2952_data->wde_interval, HRTIMER_MODE_REL);
+
+	if (ret) {
+		dev_err(ltc2952_data->dev, "unable to start the timer\n");
+		/*
+		 * The device will not toggle the watchdog reset,
+		 * thus shut down is only safe if the PowerPath controller
+		 * has a long enough time-off before triggering a hardware
+		 * power-off.
+		 *
+		 * Only sending a warning as the system will power-off anyway
+		 */
+	}
+
+	dev_info(ltc2952_data->dev, "executing shutdown\n");
+
+	orderly_poweroff(true);
+
+	return HRTIMER_NORESTART;
+}
+
+/**
+ * ltc2952_poweroff_handler - Interrupt handler
+ * Triggered each time the trigger signal changes state and (de)activates a
+ * time-out (timer_trigger). Once the time-out is actually reached the shut
+ * down is executed.
+ *
+ * @irq: IRQ number
+ * @dev_id: pointer to the main data structure
+ */
+static irqreturn_t ltc2952_poweroff_handler(int irq, void *dev_id)
+{
+	int ret;
+	struct ltc2952_poweroff_data *data = dev_id;
+
+	if (ltc2952_poweroff_panic)
+		goto irq_ok;
+
+	if (hrtimer_active(&data->timer_wde)) {
+		/* shutdown is already triggered, nothing to do any more */
+		goto irq_ok;
+	}
+
+	if (!hrtimer_active(&data->timer_trigger)) {
+		ret = hrtimer_start(&data->timer_trigger, data->trigger_delay,
+			HRTIMER_MODE_REL);
+
+		if (ret)
+			dev_err(data->dev, "unable to start the wait timer\n");
+	} else {
+		ret = hrtimer_cancel(&data->timer_trigger);
+		/* omitting return value check, timer should have been valid */
+	}
+
+irq_ok:
+	return IRQ_HANDLED;
+}
+
+static void ltc2952_poweroff_kill(void)
+{
+	gpiod_set_value(ltc2952_data->gpio[POWERPATH_IO_KILL], 1);
+}
+
+static int ltc2952_poweroff_suspend(struct platform_device *pdev,
+	pm_message_t state)
+{
+	return -ENOSYS;
+}
+
+static int ltc2952_poweroff_resume(struct platform_device *pdev)
+{
+	return -ENOSYS;
+}
+
+static void ltc2952_poweroff_default(struct ltc2952_poweroff_data *data)
+{
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(data->gpio); i++)
+		data->gpio[i] = NULL;
+
+	data->wde_interval = ktime_set(0, 300L*1E6L);
+	data->trigger_delay = ktime_set(2, 500L*1E6L);
+
+	hrtimer_init(&data->timer_trigger, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	data->timer_trigger.function = &ltc2952_poweroff_timer_trigger;
+
+	hrtimer_init(&data->timer_wde, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	data->timer_wde.function = &ltc2952_poweroff_timer_wde;
+}
+
+static int ltc2952_poweroff_init(struct platform_device *pdev)
+{
+	int ret, virq;
+	unsigned int i;
+	struct ltc2952_poweroff_data *data;
+
+	static char *name[] = {
+		"trigger",
+		"watchdog",
+		"kill",
+		NULL
+	};
+
+	data = ltc2952_data;
+	ltc2952_poweroff_default(ltc2952_data);
+
+	for (i = 0; i < ARRAY_SIZE(ltc2952_data->gpio); i++) {
+		ltc2952_data->gpio[i] = gpiod_get(&pdev->dev, name[i]);
+
+		if (IS_ERR(ltc2952_data->gpio[i])) {
+			ret = PTR_ERR(ltc2952_data->gpio[i]);
+			dev_err(&pdev->dev,
+				"unable to claim the following gpio: %s\n",
+				name[i]);
+			goto err_io;
+		}
+	}
+
+	ret = gpiod_direction_output(
+		ltc2952_data->gpio[POWERPATH_IO_WATCHDOG], 0);
+	if (ret) {
+		dev_err(&pdev->dev, "unable to use watchdog-gpio as output\n");
+		goto err_io;
+	}
+
+	ret = gpiod_direction_output(ltc2952_data->gpio[POWERPATH_IO_KILL], 0);
+	if (ret) {
+		dev_err(&pdev->dev, "unable to use kill-gpio as output\n");
+		goto err_io;
+	}
+
+	virq = gpiod_to_irq(ltc2952_data->gpio[POWERPATH_IO_TRIGGER]);
+	if (virq < 0) {
+		dev_err(&pdev->dev, "cannot map GPIO as interrupt");
+		goto err_io;
+	}
+
+	ltc2952_data->virq = virq;
+	ret = request_irq(virq,
+		ltc2952_poweroff_handler,
+		(IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING),
+		"ltc2952-poweroff",
+		ltc2952_data
+	);
+
+	if (ret) {
+		dev_err(&pdev->dev, "cannot configure an interrupt handler\n");
+		goto err_io;
+	}
+
+	return 0;
+
+err_io:
+	for (i = 0; i < ARRAY_SIZE(ltc2952_data->gpio); i++)
+		if (ltc2952_data->gpio[i])
+			gpiod_put(ltc2952_data->gpio[i]);
+
+	return ret;
+}
+
+static int ltc2952_poweroff_probe(struct platform_device *pdev)
+{
+	int ret;
+
+	if (pm_power_off) {
+		dev_err(&pdev->dev, "pm_power_off already registered");
+		return -EBUSY;
+	}
+
+	ltc2952_data = kzalloc(sizeof(*ltc2952_data), GFP_KERNEL);
+	if (!ltc2952_data)
+		return -ENOMEM;
+
+	ltc2952_data->dev = &pdev->dev;
+
+	ret = ltc2952_poweroff_init(pdev);
+	if (ret)
+		goto err;
+
+	pm_power_off = &ltc2952_poweroff_kill;
+
+	dev_info(&pdev->dev, "probe successful\n");
+
+	return 0;
+
+err:
+	kfree(ltc2952_data);
+	return ret;
+}
+
+static int ltc2952_poweroff_remove(struct platform_device *pdev)
+{
+	unsigned int i;
+
+	pm_power_off = NULL;
+
+	if (ltc2952_data) {
+		free_irq(ltc2952_data->virq, ltc2952_data);
+
+		for (i = 0; i < ARRAY_SIZE(ltc2952_data->gpio); i++)
+			gpiod_put(ltc2952_data->gpio[i]);
+
+		kfree(ltc2952_data);
+	}
+
+	return 0;
+}
+
+static const struct of_device_id of_ltc2952_poweroff_match[] = {
+	{ .compatible = "lltc,ltc2952"},
+	{},
+};
+MODULE_DEVICE_TABLE(of, of_ltc2952_poweroff_match);
+
+static struct platform_driver ltc2952_poweroff_driver = {
+	.probe = ltc2952_poweroff_probe,
+	.remove = ltc2952_poweroff_remove,
+	.driver = {
+		.name = "ltc2952-poweroff",
+		.owner = THIS_MODULE,
+		.of_match_table = of_ltc2952_poweroff_match,
+	},
+	.suspend = ltc2952_poweroff_suspend,
+	.resume = ltc2952_poweroff_resume,
+};
+
+static int ltc2952_poweroff_notify_panic(struct notifier_block *nb,
+	unsigned long code, void *unused)
+{
+	ltc2952_poweroff_panic = 1;
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block ltc2952_poweroff_panic_nb = {
+	.notifier_call = ltc2952_poweroff_notify_panic,
+};
+
+static int __init ltc2952_poweroff_platform_init(void)
+{
+	ltc2952_poweroff_panic = 0;
+
+	atomic_notifier_chain_register(&panic_notifier_list,
+		&ltc2952_poweroff_panic_nb);
+
+	return platform_driver_register(&ltc2952_poweroff_driver);
+}
+
+static void __exit ltc2952_poweroff_platform_exit(void)
+{
+	atomic_notifier_chain_unregister(&panic_notifier_list,
+		&ltc2952_poweroff_panic_nb);
+
+	platform_driver_unregister(&ltc2952_poweroff_driver);
+}
+
+module_init(ltc2952_poweroff_platform_init);
+module_exit(ltc2952_poweroff_platform_exit);
+
+MODULE_AUTHOR("René Moll <rene.moll@xsens.com>");
+MODULE_DESCRIPTION("LTC PowerPath power-off driver");
+MODULE_LICENSE("GPL v2");
