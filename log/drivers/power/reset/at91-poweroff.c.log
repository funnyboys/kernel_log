commit caa6e150f8fbcf4011cb7f3b30448f1b1de63b4f
Author: Claudiu Beznea <claudiu.beznea@microchip.com>
Date:   Thu Dec 6 17:29:46 2018 +0000

    power: reset: at91-poweroff: move shdwc related data to one structure
    
    Move SHDWC realted data to only one structure to have them grouped.
    Inspired from commit 9be74f0d39c1 ("power: reset: at91-poweroff: make
    mpddrc_base part of struct shdwc").
    
    Signed-off-by: Claudiu Beznea <claudiu.beznea@microchip.com>
    Signed-off-by: Sebastian Reichel <sebastian.reichel@collabora.com>

diff --git a/drivers/power/reset/at91-poweroff.c b/drivers/power/reset/at91-poweroff.c
index d3d87af24e55..9e74e131c675 100644
--- a/drivers/power/reset/at91-poweroff.c
+++ b/drivers/power/reset/at91-poweroff.c
@@ -51,14 +51,16 @@ static const char *shdwc_wakeup_modes[] = {
 	[AT91_SHDW_WKMODE0_ANYLEVEL]	= "any",
 };
 
-static void __iomem *at91_shdwc_base;
-static struct clk *sclk;
-static void __iomem *mpddrc_base;
+static struct shdwc {
+	struct clk *sclk;
+	void __iomem *shdwc_base;
+	void __iomem *mpddrc_base;
+} at91_shdwc;
 
 static void __init at91_wakeup_status(struct platform_device *pdev)
 {
 	const char *reason;
-	u32 reg = readl(at91_shdwc_base + AT91_SHDW_SR);
+	u32 reg = readl(at91_shdwc.shdwc_base + AT91_SHDW_SR);
 
 	/* Simple power-on, just bail out */
 	if (!reg)
@@ -92,9 +94,9 @@ static void at91_poweroff(void)
 
 		"	b	.\n\t"
 		:
-		: "r" (mpddrc_base),
+		: "r" (at91_shdwc.mpddrc_base),
 		  "r" cpu_to_le32(AT91_DDRSDRC_LPDDR2_PWOFF),
-		  "r" (at91_shdwc_base),
+		  "r" (at91_shdwc.shdwc_base),
 		  "r" cpu_to_le32(AT91_SHDW_KEY | AT91_SHDW_SHDW)
 		: "r6");
 }
@@ -144,7 +146,7 @@ static void at91_poweroff_dt_set_wakeup_mode(struct platform_device *pdev)
 	if (of_property_read_bool(np, "atmel,wakeup-rtt-timer"))
 			mode |= AT91_SHDW_RTTWKEN;
 
-	writel(wakeup_mode | mode, at91_shdwc_base + AT91_SHDW_MR);
+	writel(wakeup_mode | mode, at91_shdwc.shdwc_base + AT91_SHDW_MR);
 }
 
 static int __init at91_poweroff_probe(struct platform_device *pdev)
@@ -155,15 +157,15 @@ static int __init at91_poweroff_probe(struct platform_device *pdev)
 	int ret;
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	at91_shdwc_base = devm_ioremap_resource(&pdev->dev, res);
-	if (IS_ERR(at91_shdwc_base))
-		return PTR_ERR(at91_shdwc_base);
+	at91_shdwc.shdwc_base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(at91_shdwc.shdwc_base))
+		return PTR_ERR(at91_shdwc.shdwc_base);
 
-	sclk = devm_clk_get(&pdev->dev, NULL);
-	if (IS_ERR(sclk))
-		return PTR_ERR(sclk);
+	at91_shdwc.sclk = devm_clk_get(&pdev->dev, NULL);
+	if (IS_ERR(at91_shdwc.sclk))
+		return PTR_ERR(at91_shdwc.sclk);
 
-	ret = clk_prepare_enable(sclk);
+	ret = clk_prepare_enable(at91_shdwc.sclk);
 	if (ret) {
 		dev_err(&pdev->dev, "Could not enable slow clock\n");
 		return ret;
@@ -176,20 +178,20 @@ static int __init at91_poweroff_probe(struct platform_device *pdev)
 
 	np = of_find_compatible_node(NULL, NULL, "atmel,sama5d3-ddramc");
 	if (np) {
-		mpddrc_base = of_iomap(np, 0);
+		at91_shdwc.mpddrc_base = of_iomap(np, 0);
 		of_node_put(np);
 
-		if (!mpddrc_base) {
+		if (!at91_shdwc.mpddrc_base) {
 			ret = -ENOMEM;
 			goto clk_disable;
 		}
 
-		ddr_type = readl(mpddrc_base + AT91_DDRSDRC_MDR) &
+		ddr_type = readl(at91_shdwc.mpddrc_base + AT91_DDRSDRC_MDR) &
 				 AT91_DDRSDRC_MD;
 		if (ddr_type != AT91_DDRSDRC_MD_LPDDR2 &&
 		    ddr_type != AT91_DDRSDRC_MD_LPDDR3) {
-			iounmap(mpddrc_base);
-			mpddrc_base = NULL;
+			iounmap(at91_shdwc.mpddrc_base);
+			at91_shdwc.mpddrc_base = NULL;
 		}
 	}
 
@@ -198,7 +200,7 @@ static int __init at91_poweroff_probe(struct platform_device *pdev)
 	return 0;
 
 clk_disable:
-	clk_disable_unprepare(sclk);
+	clk_disable_unprepare(at91_shdwc.sclk);
 	return ret;
 }
 
@@ -207,10 +209,10 @@ static int __exit at91_poweroff_remove(struct platform_device *pdev)
 	if (pm_power_off == at91_poweroff)
 		pm_power_off = NULL;
 
-	if (mpddrc_base)
-		iounmap(mpddrc_base);
+	if (at91_shdwc.mpddrc_base)
+		iounmap(at91_shdwc.mpddrc_base);
 
-	clk_disable_unprepare(sclk);
+	clk_disable_unprepare(at91_shdwc.sclk);
 
 	return 0;
 }

commit e6ae9a05a41abdb80b4d93574e84609a35cfb98c
Author: Claudiu.Beznea@microchip.com <Claudiu.Beznea@microchip.com>
Date:   Mon Nov 5 11:14:31 2018 +0000

    power: reset: at91-poweroff: remove at91_ramc_of_match
    
    Remove at91_ramc_of_match[] since it is not used anywhere in this code.
    
    Signed-off-by: Claudiu Beznea <claudiu.beznea@microchip.com>
    Signed-off-by: Sebastian Reichel <sebastian.reichel@collabora.com>

diff --git a/drivers/power/reset/at91-poweroff.c b/drivers/power/reset/at91-poweroff.c
index 82533f4c72fc..d3d87af24e55 100644
--- a/drivers/power/reset/at91-poweroff.c
+++ b/drivers/power/reset/at91-poweroff.c
@@ -215,11 +215,6 @@ static int __exit at91_poweroff_remove(struct platform_device *pdev)
 	return 0;
 }
 
-static const struct of_device_id at91_ramc_of_match[] = {
-	{ .compatible = "atmel,sama5d3-ddramc", },
-	{ /* sentinel */ }
-};
-
 static const struct of_device_id at91_poweroff_of_match[] = {
 	{ .compatible = "atmel,at91sam9260-shdwc", },
 	{ .compatible = "atmel,at91sam9rl-shdwc", },

commit 996463fdb8cdec453a8b56ab6956da40a5af1360
Author: Claudiu.Beznea@microchip.com <Claudiu.Beznea@microchip.com>
Date:   Mon Nov 5 11:14:23 2018 +0000

    power: reset: at91-poweroff: use one poweroff function for at91-poweroff
    
    Use only one poweroff function and adapt it to work for both scenarios
    (with LPDDR or not). The assignement of pm_power_off was moved at the
    end of probe after all initializations are OK. This patch adapt the idea
    from commit 4e018c1e9b05 ("power: reset: at91-poweroff: use only one
    poweroff function").
    
    Signed-off-by: Claudiu Beznea <claudiu.beznea@microchip.com>
    Signed-off-by: Sebastian Reichel <sebastian.reichel@collabora.com>

diff --git a/drivers/power/reset/at91-poweroff.c b/drivers/power/reset/at91-poweroff.c
index fb2fc8f741a1..82533f4c72fc 100644
--- a/drivers/power/reset/at91-poweroff.c
+++ b/drivers/power/reset/at91-poweroff.c
@@ -75,11 +75,6 @@ static void __init at91_wakeup_status(struct platform_device *pdev)
 }
 
 static void at91_poweroff(void)
-{
-	writel(AT91_SHDW_KEY | AT91_SHDW_SHDW, at91_shdwc_base + AT91_SHDW_CR);
-}
-
-static void at91_lpddr_poweroff(void)
 {
 	asm volatile(
 		/* Align to cache lines */
@@ -89,9 +84,11 @@ static void at91_lpddr_poweroff(void)
 		"	ldr	r6, [%2, #" __stringify(AT91_SHDW_CR) "]\n\t"
 
 		/* Power down SDRAM0 */
+		"	tst	%0, #0\n\t"
+		"	beq	1f\n\t"
 		"	str	%1, [%0, #" __stringify(AT91_DDRSDRC_LPR) "]\n\t"
 		/* Shutdown CPU */
-		"	str	%3, [%2, #" __stringify(AT91_SHDW_CR) "]\n\t"
+		"1:	str	%3, [%2, #" __stringify(AT91_SHDW_CR) "]\n\t"
 
 		"	b	.\n\t"
 		:
@@ -177,34 +174,42 @@ static int __init at91_poweroff_probe(struct platform_device *pdev)
 	if (pdev->dev.of_node)
 		at91_poweroff_dt_set_wakeup_mode(pdev);
 
-	pm_power_off = at91_poweroff;
-
 	np = of_find_compatible_node(NULL, NULL, "atmel,sama5d3-ddramc");
-	if (!np)
-		return 0;
+	if (np) {
+		mpddrc_base = of_iomap(np, 0);
+		of_node_put(np);
 
-	mpddrc_base = of_iomap(np, 0);
-	of_node_put(np);
+		if (!mpddrc_base) {
+			ret = -ENOMEM;
+			goto clk_disable;
+		}
 
-	if (!mpddrc_base)
-		return 0;
+		ddr_type = readl(mpddrc_base + AT91_DDRSDRC_MDR) &
+				 AT91_DDRSDRC_MD;
+		if (ddr_type != AT91_DDRSDRC_MD_LPDDR2 &&
+		    ddr_type != AT91_DDRSDRC_MD_LPDDR3) {
+			iounmap(mpddrc_base);
+			mpddrc_base = NULL;
+		}
+	}
 
-	ddr_type = readl(mpddrc_base + AT91_DDRSDRC_MDR) & AT91_DDRSDRC_MD;
-	if ((ddr_type == AT91_DDRSDRC_MD_LPDDR2) ||
-	    (ddr_type == AT91_DDRSDRC_MD_LPDDR3))
-		pm_power_off = at91_lpddr_poweroff;
-	else
-		iounmap(mpddrc_base);
+	pm_power_off = at91_poweroff;
 
 	return 0;
+
+clk_disable:
+	clk_disable_unprepare(sclk);
+	return ret;
 }
 
 static int __exit at91_poweroff_remove(struct platform_device *pdev)
 {
-	if (pm_power_off == at91_poweroff ||
-	    pm_power_off == at91_lpddr_poweroff)
+	if (pm_power_off == at91_poweroff)
 		pm_power_off = NULL;
 
+	if (mpddrc_base)
+		iounmap(mpddrc_base);
+
 	clk_disable_unprepare(sclk);
 
 	return 0;

commit ab08824826d72ef9c185b7aad4e9a1e98bf2fa51
Author: Ladislav Michl <ladis@linux-mips.org>
Date:   Fri Mar 16 11:03:25 2018 +0100

    power: reset: at91-poweroff: Remove redundant dev_err call in at91_poweroff_probe()
    
    There is an error message within devm_ioremap_resource
    already, so remove the dev_err call to avoid redundancy.
    
    Signed-off-by: Ladislav Michl <ladis@linux-mips.org>
    Acked-by: Nicolas Ferre <nicolas.ferre@microchip.com>
    Signed-off-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>

diff --git a/drivers/power/reset/at91-poweroff.c b/drivers/power/reset/at91-poweroff.c
index f8f88798cb66..fb2fc8f741a1 100644
--- a/drivers/power/reset/at91-poweroff.c
+++ b/drivers/power/reset/at91-poweroff.c
@@ -159,10 +159,8 @@ static int __init at91_poweroff_probe(struct platform_device *pdev)
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	at91_shdwc_base = devm_ioremap_resource(&pdev->dev, res);
-	if (IS_ERR(at91_shdwc_base)) {
-		dev_err(&pdev->dev, "Could not map reset controller address\n");
+	if (IS_ERR(at91_shdwc_base))
 		return PTR_ERR(at91_shdwc_base);
-	}
 
 	sclk = devm_clk_get(&pdev->dev, NULL);
 	if (IS_ERR(sclk))

commit 062836db01f982683e3c5bb6cbf571ee7a13016a
Author: Ladislav Michl <ladis@linux-mips.org>
Date:   Fri Mar 16 11:02:05 2018 +0100

    power: reset: at91-poweroff: Switch from the pr_*() to the dev_*() logging functions
    
    Use dev_info() instead of pr_info().
    
    Signed-off-by: Ladislav Michl <ladis@linux-mips.org>
    Acked-by: Nicolas Ferre <nicolas.ferre@microchip.com>
    Signed-off-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>

diff --git a/drivers/power/reset/at91-poweroff.c b/drivers/power/reset/at91-poweroff.c
index c30c40193aaa..f8f88798cb66 100644
--- a/drivers/power/reset/at91-poweroff.c
+++ b/drivers/power/reset/at91-poweroff.c
@@ -55,10 +55,10 @@ static void __iomem *at91_shdwc_base;
 static struct clk *sclk;
 static void __iomem *mpddrc_base;
 
-static void __init at91_wakeup_status(void)
+static void __init at91_wakeup_status(struct platform_device *pdev)
 {
+	const char *reason;
 	u32 reg = readl(at91_shdwc_base + AT91_SHDW_SR);
-	char *reason = "unknown";
 
 	/* Simple power-on, just bail out */
 	if (!reg)
@@ -68,8 +68,10 @@ static void __init at91_wakeup_status(void)
 		reason = "RTT";
 	else if (reg & AT91_SHDW_RTCWK)
 		reason = "RTC";
+	else
+		reason = "unknown";
 
-	pr_info("AT91: Wake-Up source: %s\n", reason);
+	dev_info(&pdev->dev, "Wake-Up source: %s\n", reason);
 }
 
 static void at91_poweroff(void)
@@ -172,7 +174,7 @@ static int __init at91_poweroff_probe(struct platform_device *pdev)
 		return ret;
 	}
 
-	at91_wakeup_status();
+	at91_wakeup_status(pdev);
 
 	if (pdev->dev.of_node)
 		at91_poweroff_dt_set_wakeup_mode(pdev);

commit 2e9bbbf694fd9ed4d96a303dadce4d8ccf2a4af3
Author: Alexandre Belloni <alexandre.belloni@free-electrons.com>
Date:   Wed May 31 11:49:14 2017 +0200

    power: reset: at91-poweroff: fix clobber list
    
    Assembly in at91_lpddr_poweroff has r0 in the clobber list but uses r6.
    
    Reported-by: Ben Hutchings <ben.hutchings@codethink.co.uk>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Acked-by: Nicolas Ferre <nicolas.ferre@microchip.com>
    Signed-off-by: Sebastian Reichel <sre@kernel.org>

diff --git a/drivers/power/reset/at91-poweroff.c b/drivers/power/reset/at91-poweroff.c
index c6c3beea72f9..c30c40193aaa 100644
--- a/drivers/power/reset/at91-poweroff.c
+++ b/drivers/power/reset/at91-poweroff.c
@@ -97,7 +97,7 @@ static void at91_lpddr_poweroff(void)
 		  "r" cpu_to_le32(AT91_DDRSDRC_LPDDR2_PWOFF),
 		  "r" (at91_shdwc_base),
 		  "r" cpu_to_le32(AT91_SHDW_KEY | AT91_SHDW_SHDW)
-		: "r0");
+		: "r6");
 }
 
 static int at91_poweroff_get_wakeup_mode(struct device_node *np)

commit 0b0408745e7ff24757cbfd571d69026c0ddb803c
Author: Alexandre Belloni <alexandre.belloni@free-electrons.com>
Date:   Tue Oct 25 11:37:59 2016 +0200

    power: reset: at91-poweroff: timely shutdown LPDDR memories
    
    LPDDR memories can only handle up to 400 uncontrolled power off. Ensure the
    proper power off sequence is used before shutting down the platform.
    
    Cc: <stable@vger.kernel.org> # 4.4+
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Signed-off-by: Sebastian Reichel <sre@kernel.org>

diff --git a/drivers/power/reset/at91-poweroff.c b/drivers/power/reset/at91-poweroff.c
index a85dd4d233af..c6c3beea72f9 100644
--- a/drivers/power/reset/at91-poweroff.c
+++ b/drivers/power/reset/at91-poweroff.c
@@ -14,9 +14,12 @@
 #include <linux/io.h>
 #include <linux/module.h>
 #include <linux/of.h>
+#include <linux/of_address.h>
 #include <linux/platform_device.h>
 #include <linux/printk.h>
 
+#include <soc/at91/at91sam9_ddrsdr.h>
+
 #define AT91_SHDW_CR	0x00		/* Shut Down Control Register */
 #define AT91_SHDW_SHDW		BIT(0)			/* Shut Down command */
 #define AT91_SHDW_KEY		(0xa5 << 24)		/* KEY Password */
@@ -50,6 +53,7 @@ static const char *shdwc_wakeup_modes[] = {
 
 static void __iomem *at91_shdwc_base;
 static struct clk *sclk;
+static void __iomem *mpddrc_base;
 
 static void __init at91_wakeup_status(void)
 {
@@ -73,6 +77,29 @@ static void at91_poweroff(void)
 	writel(AT91_SHDW_KEY | AT91_SHDW_SHDW, at91_shdwc_base + AT91_SHDW_CR);
 }
 
+static void at91_lpddr_poweroff(void)
+{
+	asm volatile(
+		/* Align to cache lines */
+		".balign 32\n\t"
+
+		/* Ensure AT91_SHDW_CR is in the TLB by reading it */
+		"	ldr	r6, [%2, #" __stringify(AT91_SHDW_CR) "]\n\t"
+
+		/* Power down SDRAM0 */
+		"	str	%1, [%0, #" __stringify(AT91_DDRSDRC_LPR) "]\n\t"
+		/* Shutdown CPU */
+		"	str	%3, [%2, #" __stringify(AT91_SHDW_CR) "]\n\t"
+
+		"	b	.\n\t"
+		:
+		: "r" (mpddrc_base),
+		  "r" cpu_to_le32(AT91_DDRSDRC_LPDDR2_PWOFF),
+		  "r" (at91_shdwc_base),
+		  "r" cpu_to_le32(AT91_SHDW_KEY | AT91_SHDW_SHDW)
+		: "r0");
+}
+
 static int at91_poweroff_get_wakeup_mode(struct device_node *np)
 {
 	const char *pm;
@@ -124,6 +151,8 @@ static void at91_poweroff_dt_set_wakeup_mode(struct platform_device *pdev)
 static int __init at91_poweroff_probe(struct platform_device *pdev)
 {
 	struct resource *res;
+	struct device_node *np;
+	u32 ddr_type;
 	int ret;
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
@@ -150,12 +179,30 @@ static int __init at91_poweroff_probe(struct platform_device *pdev)
 
 	pm_power_off = at91_poweroff;
 
+	np = of_find_compatible_node(NULL, NULL, "atmel,sama5d3-ddramc");
+	if (!np)
+		return 0;
+
+	mpddrc_base = of_iomap(np, 0);
+	of_node_put(np);
+
+	if (!mpddrc_base)
+		return 0;
+
+	ddr_type = readl(mpddrc_base + AT91_DDRSDRC_MDR) & AT91_DDRSDRC_MD;
+	if ((ddr_type == AT91_DDRSDRC_MD_LPDDR2) ||
+	    (ddr_type == AT91_DDRSDRC_MD_LPDDR3))
+		pm_power_off = at91_lpddr_poweroff;
+	else
+		iounmap(mpddrc_base);
+
 	return 0;
 }
 
 static int __exit at91_poweroff_remove(struct platform_device *pdev)
 {
-	if (pm_power_off == at91_poweroff)
+	if (pm_power_off == at91_poweroff ||
+	    pm_power_off == at91_lpddr_poweroff)
 		pm_power_off = NULL;
 
 	clk_disable_unprepare(sclk);
@@ -163,6 +210,11 @@ static int __exit at91_poweroff_remove(struct platform_device *pdev)
 	return 0;
 }
 
+static const struct of_device_id at91_ramc_of_match[] = {
+	{ .compatible = "atmel,sama5d3-ddramc", },
+	{ /* sentinel */ }
+};
+
 static const struct of_device_id at91_poweroff_of_match[] = {
 	{ .compatible = "atmel,at91sam9260-shdwc", },
 	{ .compatible = "atmel,at91sam9rl-shdwc", },

commit c9ba9b77631d7bb81c953b83e17f6924380c09e1
Author: Javier Martinez Canillas <javier@osg.samsung.com>
Date:   Mon Oct 17 15:36:13 2016 -0300

    power: reset: at91-poweroff: Fix module autoload
    
    If the driver is built as a module, autoload won't work because the module
    alias information is not filled. So user-space can't match the registered
    device with the corresponding module.
    
    Export the module alias information using the MODULE_DEVICE_TABLE() macro.
    
    Before this patch:
    
    $ modinfo drivers/power/reset/at91-poweroff.ko | grep alias
    $
    
    After this patch:
    
    $ modinfo drivers/power/reset/at91-poweroff.ko | grep alias
    alias:          of:N*T*Catmel,at91sam9x5-shdwcC*
    alias:          of:N*T*Catmel,at91sam9x5-shdwc
    alias:          of:N*T*Catmel,at91sam9rl-shdwcC*
    alias:          of:N*T*Catmel,at91sam9rl-shdwc
    alias:          of:N*T*Catmel,at91sam9260-shdwcC*
    alias:          of:N*T*Catmel,at91sam9260-shdwc
    
    Signed-off-by: Javier Martinez Canillas <javier@osg.samsung.com>
    Signed-off-by: Sebastian Reichel <sre@kernel.org>

diff --git a/drivers/power/reset/at91-poweroff.c b/drivers/power/reset/at91-poweroff.c
index e9e24df35f26..a85dd4d233af 100644
--- a/drivers/power/reset/at91-poweroff.c
+++ b/drivers/power/reset/at91-poweroff.c
@@ -169,6 +169,7 @@ static const struct of_device_id at91_poweroff_of_match[] = {
 	{ .compatible = "atmel,at91sam9x5-shdwc", },
 	{ /*sentinel*/ }
 };
+MODULE_DEVICE_TABLE(of, at91_poweroff_of_match);
 
 static struct platform_driver at91_poweroff_driver = {
 	.remove = __exit_p(at91_poweroff_remove),

commit 064380a12e12412f25db049a503126228babbae5
Author: Alexandre Belloni <alexandre.belloni@free-electrons.com>
Date:   Tue Aug 11 11:12:50 2015 +0200

    power/reset: at91-poweroff: get and use slow clock
    
    Commit dca1a4b5ff6e ("clk: at91: keep slow clk enabled to prevent system
    hang") added a workaround for the slow clock as it is not properly handled
    by its users.
    
    Get and use the slow clock as it is necessary for the at91 shutdown
    controller.
    
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Signed-off-by: Sebastian Reichel <sre@kernel.org>

diff --git a/drivers/power/reset/at91-poweroff.c b/drivers/power/reset/at91-poweroff.c
index 3e698d916c4f..e9e24df35f26 100644
--- a/drivers/power/reset/at91-poweroff.c
+++ b/drivers/power/reset/at91-poweroff.c
@@ -10,6 +10,7 @@
  * warranty of any kind, whether express or implied.
  */
 
+#include <linux/clk.h>
 #include <linux/io.h>
 #include <linux/module.h>
 #include <linux/of.h>
@@ -48,6 +49,7 @@ static const char *shdwc_wakeup_modes[] = {
 };
 
 static void __iomem *at91_shdwc_base;
+static struct clk *sclk;
 
 static void __init at91_wakeup_status(void)
 {
@@ -122,6 +124,7 @@ static void at91_poweroff_dt_set_wakeup_mode(struct platform_device *pdev)
 static int __init at91_poweroff_probe(struct platform_device *pdev)
 {
 	struct resource *res;
+	int ret;
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	at91_shdwc_base = devm_ioremap_resource(&pdev->dev, res);
@@ -130,6 +133,16 @@ static int __init at91_poweroff_probe(struct platform_device *pdev)
 		return PTR_ERR(at91_shdwc_base);
 	}
 
+	sclk = devm_clk_get(&pdev->dev, NULL);
+	if (IS_ERR(sclk))
+		return PTR_ERR(sclk);
+
+	ret = clk_prepare_enable(sclk);
+	if (ret) {
+		dev_err(&pdev->dev, "Could not enable slow clock\n");
+		return ret;
+	}
+
 	at91_wakeup_status();
 
 	if (pdev->dev.of_node)
@@ -145,6 +158,8 @@ static int __exit at91_poweroff_remove(struct platform_device *pdev)
 	if (pm_power_off == at91_poweroff)
 		pm_power_off = NULL;
 
+	clk_disable_unprepare(sclk);
+
 	return 0;
 }
 

commit 6dd1ad1f236e7e683e92efd6b5b3953615900701
Author: Alexandre Belloni <alexandre.belloni@free-electrons.com>
Date:   Tue Aug 11 11:12:49 2015 +0200

    power/reset: at91-poweroff: allow compiling as a module
    
    It was not possible to compile at91-poweroff as a module. Implement
    .remove() to allow it. Also switch to module_platform_driver_probe() as it
    is not hotpluggable.
    
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Signed-off-by: Sebastian Reichel <sre@kernel.org>

diff --git a/drivers/power/reset/at91-poweroff.c b/drivers/power/reset/at91-poweroff.c
index 9847cfb7e23d..3e698d916c4f 100644
--- a/drivers/power/reset/at91-poweroff.c
+++ b/drivers/power/reset/at91-poweroff.c
@@ -119,7 +119,7 @@ static void at91_poweroff_dt_set_wakeup_mode(struct platform_device *pdev)
 	writel(wakeup_mode | mode, at91_shdwc_base + AT91_SHDW_MR);
 }
 
-static int at91_poweroff_probe(struct platform_device *pdev)
+static int __init at91_poweroff_probe(struct platform_device *pdev)
 {
 	struct resource *res;
 
@@ -140,6 +140,14 @@ static int at91_poweroff_probe(struct platform_device *pdev)
 	return 0;
 }
 
+static int __exit at91_poweroff_remove(struct platform_device *pdev)
+{
+	if (pm_power_off == at91_poweroff)
+		pm_power_off = NULL;
+
+	return 0;
+}
+
 static const struct of_device_id at91_poweroff_of_match[] = {
 	{ .compatible = "atmel,at91sam9260-shdwc", },
 	{ .compatible = "atmel,at91sam9rl-shdwc", },
@@ -148,10 +156,14 @@ static const struct of_device_id at91_poweroff_of_match[] = {
 };
 
 static struct platform_driver at91_poweroff_driver = {
-	.probe = at91_poweroff_probe,
+	.remove = __exit_p(at91_poweroff_remove),
 	.driver = {
 		.name = "at91-poweroff",
 		.of_match_table = at91_poweroff_of_match,
 	},
 };
-module_platform_driver(at91_poweroff_driver);
+module_platform_driver_probe(at91_poweroff_driver, at91_poweroff_probe);
+
+MODULE_AUTHOR("Atmel Corporation");
+MODULE_DESCRIPTION("Shutdown driver for Atmel SoCs");
+MODULE_LICENSE("GPL v2");

commit 8fb0885504cc029bd48877fa89ba91c33c0110b5
Author: Fabian Frederick <fabf@skynet.be>
Date:   Mon Mar 16 20:17:12 2015 +0100

    power: constify of_device_id array
    
    of_device_id is always used as const.
    (See driver.of_match_table and open firmware functions)
    
    Signed-off-by: Fabian Frederick <fabf@skynet.be>
    
    [for vexpress]
    Acked-by: Sudeep Holla <sudeep.holla@arm.com>
    
    Signed-off-by: Sebastian Reichel <sre@kernel.org>

diff --git a/drivers/power/reset/at91-poweroff.c b/drivers/power/reset/at91-poweroff.c
index 4b72ea51c364..9847cfb7e23d 100644
--- a/drivers/power/reset/at91-poweroff.c
+++ b/drivers/power/reset/at91-poweroff.c
@@ -140,7 +140,7 @@ static int at91_poweroff_probe(struct platform_device *pdev)
 	return 0;
 }
 
-static struct of_device_id at91_poweroff_of_match[] = {
+static const struct of_device_id at91_poweroff_of_match[] = {
 	{ .compatible = "atmel,at91sam9260-shdwc", },
 	{ .compatible = "atmel,at91sam9rl-shdwc", },
 	{ .compatible = "atmel,at91sam9x5-shdwc", },

commit a538cf04ef67861a208075a6d57d0f045822e1d6
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Fri Oct 10 17:41:17 2014 -0700

    power/reset: at91-poweroff: Fix error handling and other compiler warnings
    
    at91_poweroff_get_wakeup_mode can return a negative error code and should
    therefore not return an enum type. Similar, its result should not be
    assigned to an enum type. Otherwise, the returned value is never negative,
    resulting in a compiler warning and a missed error condition, which in turn
    results in writing bad values into a chip register.
    
    Also fix other compiler warnings which can be easily avoided.
    
    drivers/power/reset/at91-poweroff.c:74:24:
            warning: type qualifiers ignored on function return type
    drivers/power/reset/at91-poweroff.c:74:24:
            warning: no previous prototype for 'at91_poweroff_get_wakeup_mode'
    drivers/power/reset/at91-poweroff.c:83:16:
            warning: comparison between signed and unsigned integer expressions
    drivers/power/reset/at91-poweroff.c:97:2:
            warning: comparison of unsigned expression < 0 is always false
    
    Cc: Maxime Ripard <maxime.ripard@free-electrons.com>
    Cc: Nicolas Ferre <nicolas.ferre@atmel.com>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Acked-by: Maxime Ripard <maxime.ripard@free-electrons.com>
    Signed-off-by: Sebastian Reichel <sre@kernel.org>

diff --git a/drivers/power/reset/at91-poweroff.c b/drivers/power/reset/at91-poweroff.c
index c61000333bb9..4b72ea51c364 100644
--- a/drivers/power/reset/at91-poweroff.c
+++ b/drivers/power/reset/at91-poweroff.c
@@ -71,10 +71,11 @@ static void at91_poweroff(void)
 	writel(AT91_SHDW_KEY | AT91_SHDW_SHDW, at91_shdwc_base + AT91_SHDW_CR);
 }
 
-const enum wakeup_type at91_poweroff_get_wakeup_mode(struct device_node *np)
+static int at91_poweroff_get_wakeup_mode(struct device_node *np)
 {
 	const char *pm;
-	int err, i;
+	unsigned int i;
+	int err;
 
 	err = of_property_read_string(np, "atmel,wakeup-mode", &pm);
 	if (err < 0)
@@ -90,7 +91,7 @@ const enum wakeup_type at91_poweroff_get_wakeup_mode(struct device_node *np)
 static void at91_poweroff_dt_set_wakeup_mode(struct platform_device *pdev)
 {
 	struct device_node *np = pdev->dev.of_node;
-	enum wakeup_type wakeup_mode;
+	int wakeup_mode;
 	u32 mode = 0, tmp;
 
 	wakeup_mode = at91_poweroff_get_wakeup_mode(np);

commit 405a72c5e78b5c560c8b2711d4000fa5eb063e1b
Author: Nicolas Ferre <nicolas.ferre@atmel.com>
Date:   Mon Sep 1 16:11:19 2014 +0200

    power: reset: at91-poweroff: fix wakeup status register index
    
    The wakeup status is read from Shutdown Status Register and not the
    SHDW_CR which is the one at address 0.
    
    Signed-off-by: Nicolas Ferre <nicolas.ferre@atmel.com>

diff --git a/drivers/power/reset/at91-poweroff.c b/drivers/power/reset/at91-poweroff.c
index 40bf42d146f1..c61000333bb9 100644
--- a/drivers/power/reset/at91-poweroff.c
+++ b/drivers/power/reset/at91-poweroff.c
@@ -51,7 +51,7 @@ static void __iomem *at91_shdwc_base;
 
 static void __init at91_wakeup_status(void)
 {
-	u32 reg = readl(at91_shdwc_base);
+	u32 reg = readl(at91_shdwc_base + AT91_SHDW_SR);
 	char *reason = "unknown";
 
 	/* Simple power-on, just bail out */

commit ae499f0fadaf28bf3138676fa2d3f6cf7d57556a
Author: Maxime Ripard <maxime.ripard@free-electrons.com>
Date:   Thu Jul 3 14:07:18 2014 +0200

    power: reset: Add AT91 poweroff driver
    
    Add a driver to handle the shutdown of the Atmel SoCs. This code used to be
    (and still is) in arch/arm/mach-at91. We didn't remove it yet so that we can
    convert all the boards to using this driver, before removing it entirely in a
    separate patch.
    
    Signed-off-by: Maxime Ripard <maxime.ripard@free-electrons.com>
    Acked-by: Nicolas Ferre <nicolas.ferre@atmel.com>
    Acked-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>

diff --git a/drivers/power/reset/at91-poweroff.c b/drivers/power/reset/at91-poweroff.c
new file mode 100644
index 000000000000..40bf42d146f1
--- /dev/null
+++ b/drivers/power/reset/at91-poweroff.c
@@ -0,0 +1,156 @@
+/*
+ * Atmel AT91 SAM9 SoCs reset code
+ *
+ * Copyright (C) 2007 Atmel Corporation.
+ * Copyright (C) 2011 Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
+ * Copyright (C) 2014 Free Electrons
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/printk.h>
+
+#define AT91_SHDW_CR	0x00		/* Shut Down Control Register */
+#define AT91_SHDW_SHDW		BIT(0)			/* Shut Down command */
+#define AT91_SHDW_KEY		(0xa5 << 24)		/* KEY Password */
+
+#define AT91_SHDW_MR	0x04		/* Shut Down Mode Register */
+#define AT91_SHDW_WKMODE0	GENMASK(2, 0)		/* Wake-up 0 Mode Selection */
+#define AT91_SHDW_CPTWK0_MAX	0xf			/* Maximum Counter On Wake Up 0 */
+#define AT91_SHDW_CPTWK0	(AT91_SHDW_CPTWK0_MAX << 4) /* Counter On Wake Up 0 */
+#define AT91_SHDW_CPTWK0_(x)	((x) << 4)
+#define AT91_SHDW_RTTWKEN	BIT(16)			/* Real Time Timer Wake-up Enable */
+#define AT91_SHDW_RTCWKEN	BIT(17)			/* Real Time Clock Wake-up Enable */
+
+#define AT91_SHDW_SR	0x08		/* Shut Down Status Register */
+#define AT91_SHDW_WAKEUP0	BIT(0)			/* Wake-up 0 Status */
+#define AT91_SHDW_RTTWK		BIT(16)			/* Real-time Timer Wake-up */
+#define AT91_SHDW_RTCWK		BIT(17)			/* Real-time Clock Wake-up [SAM9RL] */
+
+enum wakeup_type {
+	AT91_SHDW_WKMODE0_NONE		= 0,
+	AT91_SHDW_WKMODE0_HIGH		= 1,
+	AT91_SHDW_WKMODE0_LOW		= 2,
+	AT91_SHDW_WKMODE0_ANYLEVEL	= 3,
+};
+
+static const char *shdwc_wakeup_modes[] = {
+	[AT91_SHDW_WKMODE0_NONE]	= "none",
+	[AT91_SHDW_WKMODE0_HIGH]	= "high",
+	[AT91_SHDW_WKMODE0_LOW]		= "low",
+	[AT91_SHDW_WKMODE0_ANYLEVEL]	= "any",
+};
+
+static void __iomem *at91_shdwc_base;
+
+static void __init at91_wakeup_status(void)
+{
+	u32 reg = readl(at91_shdwc_base);
+	char *reason = "unknown";
+
+	/* Simple power-on, just bail out */
+	if (!reg)
+		return;
+
+	if (reg & AT91_SHDW_RTTWK)
+		reason = "RTT";
+	else if (reg & AT91_SHDW_RTCWK)
+		reason = "RTC";
+
+	pr_info("AT91: Wake-Up source: %s\n", reason);
+}
+
+static void at91_poweroff(void)
+{
+	writel(AT91_SHDW_KEY | AT91_SHDW_SHDW, at91_shdwc_base + AT91_SHDW_CR);
+}
+
+const enum wakeup_type at91_poweroff_get_wakeup_mode(struct device_node *np)
+{
+	const char *pm;
+	int err, i;
+
+	err = of_property_read_string(np, "atmel,wakeup-mode", &pm);
+	if (err < 0)
+		return AT91_SHDW_WKMODE0_ANYLEVEL;
+
+	for (i = 0; i < ARRAY_SIZE(shdwc_wakeup_modes); i++)
+		if (!strcasecmp(pm, shdwc_wakeup_modes[i]))
+			return i;
+
+	return -ENODEV;
+}
+
+static void at91_poweroff_dt_set_wakeup_mode(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	enum wakeup_type wakeup_mode;
+	u32 mode = 0, tmp;
+
+	wakeup_mode = at91_poweroff_get_wakeup_mode(np);
+	if (wakeup_mode < 0) {
+		dev_warn(&pdev->dev, "shdwc unknown wakeup mode\n");
+		return;
+	}
+
+	if (!of_property_read_u32(np, "atmel,wakeup-counter", &tmp)) {
+		if (tmp > AT91_SHDW_CPTWK0_MAX) {
+			dev_warn(&pdev->dev,
+				 "shdwc wakeup counter 0x%x > 0x%x reduce it to 0x%x\n",
+				 tmp, AT91_SHDW_CPTWK0_MAX, AT91_SHDW_CPTWK0_MAX);
+			tmp = AT91_SHDW_CPTWK0_MAX;
+		}
+		mode |= AT91_SHDW_CPTWK0_(tmp);
+	}
+
+	if (of_property_read_bool(np, "atmel,wakeup-rtc-timer"))
+			mode |= AT91_SHDW_RTCWKEN;
+
+	if (of_property_read_bool(np, "atmel,wakeup-rtt-timer"))
+			mode |= AT91_SHDW_RTTWKEN;
+
+	writel(wakeup_mode | mode, at91_shdwc_base + AT91_SHDW_MR);
+}
+
+static int at91_poweroff_probe(struct platform_device *pdev)
+{
+	struct resource *res;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	at91_shdwc_base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(at91_shdwc_base)) {
+		dev_err(&pdev->dev, "Could not map reset controller address\n");
+		return PTR_ERR(at91_shdwc_base);
+	}
+
+	at91_wakeup_status();
+
+	if (pdev->dev.of_node)
+		at91_poweroff_dt_set_wakeup_mode(pdev);
+
+	pm_power_off = at91_poweroff;
+
+	return 0;
+}
+
+static struct of_device_id at91_poweroff_of_match[] = {
+	{ .compatible = "atmel,at91sam9260-shdwc", },
+	{ .compatible = "atmel,at91sam9rl-shdwc", },
+	{ .compatible = "atmel,at91sam9x5-shdwc", },
+	{ /*sentinel*/ }
+};
+
+static struct platform_driver at91_poweroff_driver = {
+	.probe = at91_poweroff_probe,
+	.driver = {
+		.name = "at91-poweroff",
+		.of_match_table = at91_poweroff_of_match,
+	},
+};
+module_platform_driver(at91_poweroff_driver);
