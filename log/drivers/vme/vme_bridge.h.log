commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/vme/vme_bridge.h b/drivers/vme/vme_bridge.h
index 2662e916b96a..42ecf961004e 100644
--- a/drivers/vme/vme_bridge.h
+++ b/drivers/vme/vme_bridge.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef _VME_BRIDGE_H_
 #define _VME_BRIDGE_H_
 

commit fa54b326803d91b04705a6adf0ff963593a9fe5c
Author: Aaron Sierra <asierra@xes-inc.com>
Date:   Fri Apr 29 16:41:02 2016 -0500

    vme: change LM callback argument to void pointer
    
    Make the location monitor callback function prototype more useful by
    changing the argument from an integer to a void pointer.
    
    All VME bridge drivers were simply passing the location monitor index
    (e.g. 0-3) as the argument to these callbacks. It is much more useful
    to pass back a pointer to data that the callback-registering driver
    cares about.
    
    There appear to be no in-kernel callers of vme_lm_attach (or
    vme_lme_request for that matter), so this change only affects the VME
    subsystem and bridge drivers.
    
    This has been tested with Tsi148 hardware, but the CA91Cx42 changes
    have only been compiled.
    
    Signed-off-by: Aaron Sierra <asierra@xes-inc.com>
    Acked-by: Martyn Welch <martyn@welchs.me.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/vme/vme_bridge.h b/drivers/vme/vme_bridge.h
index cb8246fd97be..2662e916b96a 100644
--- a/drivers/vme/vme_bridge.h
+++ b/drivers/vme/vme_bridge.h
@@ -160,7 +160,8 @@ struct vme_bridge {
 	int (*lm_set) (struct vme_lm_resource *, unsigned long long, u32, u32);
 	int (*lm_get) (struct vme_lm_resource *, unsigned long long *, u32 *,
 		u32 *);
-	int (*lm_attach) (struct vme_lm_resource *, int, void (*callback)(int));
+	int (*lm_attach)(struct vme_lm_resource *, int,
+			 void (*callback)(void *), void *);
 	int (*lm_detach) (struct vme_lm_resource *, int);
 
 	/* CR/CSR space functions */

commit 326071b3c985683f8a18417bed3ea2ab930a7ba1
Author: Aaron Sierra <asierra@xes-inc.com>
Date:   Sun Apr 24 15:11:38 2016 -0500

    vme: add vme_init_bridge for common bridge init
    
    Consolidate vme_bridge structure setup that every bridge was required
    to do itself. This came about because .irq_mtx is only used within the
    VME core, but was required to be setup externally.
    
    This returns the structure passed in to support shorthand like this:
    
        bridge = vme_init_bridge(&priv->bridge);
    
    Signed-off-by: Aaron Sierra <asierra@xes-inc.com>
    Acked-by: Martyn Welch <martyn@welchs.me.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/vme/vme_bridge.h b/drivers/vme/vme_bridge.h
index b59cbee231dd..cb8246fd97be 100644
--- a/drivers/vme/vme_bridge.h
+++ b/drivers/vme/vme_bridge.h
@@ -177,6 +177,7 @@ void vme_bus_error_handler(struct vme_bridge *bridge,
 			   unsigned long long address, int am);
 void vme_irq_handler(struct vme_bridge *, int, int);
 
+struct vme_bridge *vme_init_bridge(struct vme_bridge *);
 int vme_register_bridge(struct vme_bridge *);
 void vme_unregister_bridge(struct vme_bridge *);
 struct vme_error_handler *vme_register_error_handler(

commit 8e483ed1342a4ea45b70f0f33ac54eff7a33d918
Merge: e880e87488d5 e2d8680741ed
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Nov 4 22:15:15 2015 -0800

    Merge tag 'char-misc-4.4-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/char-misc
    
    Pull char/misc driver updates from Greg KH:
     "Here is the big char/misc driver update for 4.4-rc1.  Lots of
      different driver and subsystem updates, hwtracing being the largest
      with the addition of some new platforms that are now supported.  Full
      details in the shortlog.
    
      All of these have been in linux-next for a long time with no reported
      issues"
    
    * tag 'char-misc-4.4-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/char-misc: (181 commits)
      fpga: socfpga: Fix check of return value of devm_request_irq
      lkdtm: fix ACCESS_USERSPACE test
      mcb: Destroy IDA on module unload
      mcb: Do not return zero on error path in mcb_pci_probe()
      mei: bus: set the device name before running fixup
      mei: bus: use correct lock ordering
      mei: Fix debugfs filename in error output
      char: ipmi: ipmi_ssif: Replace timeval with timespec64
      fpga: zynq-fpga: Fix issue with drvdata being overwritten.
      fpga manager: remove unnecessary null pointer checks
      fpga manager: ensure lifetime with of_fpga_mgr_get
      fpga: zynq-fpga: Change fw format to handle bin instead of bit.
      fpga: zynq-fpga: Fix unbalanced clock handling
      misc: sram: partition base address belongs to __iomem space
      coresight: etm3x: adding documentation for sysFS's cpu interface
      vme: 8-bit status/id takes 256 values, not 255
      fpga manager: Adding FPGA Manager support for Xilinx Zynq 7000
      ARM: zynq: dt: Updated devicetree for Zynq 7000 platform.
      ARM: dt: fpga: Added binding docs for Xilinx Zynq FPGA manager.
      ver_linux: proc/modules, limit text processing to 'sed'
      ...

commit ad1bfe410e91189522514ea784668dc75a4e64c4
Author: Dmitry Kalinkin <dmitry.kalinkin@gmail.com>
Date:   Sun Oct 11 01:00:58 2015 +0300

    vme: 8-bit status/id takes 256 values, not 255
    
    Fixes an off by one array size.
    
    Signed-off-by: Dmitry Kalinkin <dmitry.kalinkin@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/vme/vme_bridge.h b/drivers/vme/vme_bridge.h
index 934949abd745..a3ef63b336e4 100644
--- a/drivers/vme/vme_bridge.h
+++ b/drivers/vme/vme_bridge.h
@@ -1,6 +1,8 @@
 #ifndef _VME_BRIDGE_H_
 #define _VME_BRIDGE_H_
 
+#include <linux/vme.h>
+
 #define VME_CRCSR_BUF_SIZE (508*1024)
 /*
  * Resource structures
@@ -88,7 +90,7 @@ struct vme_callback {
 
 struct vme_irq {
 	int count;
-	struct vme_callback callback[255];
+	struct vme_callback callback[VME_NUM_STATUSID];
 };
 
 /* Allow 16 characters for name (including null character) */

commit 0b0496625715374c7d0b747268c11528e8af32a3
Author: Dmitry Kalinkin <dmitry.kalinkin@gmail.com>
Date:   Fri Sep 18 02:01:44 2015 +0300

    vme: change bus error handling scheme
    
    The current VME bus error handler adds errors to the bridge error list.
    vme_master_{read,write} then traverses that list to look for relevant
    errors.
    
    Such scheme didn't work well for accesses going through vme_master_mmap
    because they would also allocate a vme_bus_error, but have no way to do
    vme_clear_errors call to free that memory.
    
    This changes the error handling process to be other way around: now
    vme_master_{read,write} defines a window in VME address space that will
    catch possible errors.  VME bus error interrupt only traverses these
    windows and marks those that had errors in them.
    
    Signed-off-by: Dmitry Kalinkin <dmitry.kalinkin@gmail.com>
    Cc: Igor Alekseev <igor.alekseev@itep.ru>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/vme/vme_bridge.h b/drivers/vme/vme_bridge.h
index 92fbe18cbc42..397578a73883 100644
--- a/drivers/vme/vme_bridge.h
+++ b/drivers/vme/vme_bridge.h
@@ -75,10 +75,13 @@ struct vme_lm_resource {
 	int monitors;
 };
 
-struct vme_bus_error {
+struct vme_error_handler {
 	struct list_head list;
-	u32 aspace;
-	unsigned long long address;
+	unsigned long long start;	/* Beginning of error window */
+	unsigned long long end;		/* End of error window */
+	unsigned long long first_error;	/* Address of the first error */
+	u32 aspace;			/* Address space of error window*/
+	unsigned num_errors;		/* Number of errors */
 };
 
 struct vme_callback {
@@ -106,8 +109,10 @@ struct vme_bridge {
 	struct list_head dma_resources;
 	struct list_head lm_resources;
 
-	struct list_head vme_errors;	/* List for errors generated on VME */
-	struct list_head devices;	/* List of devices on this bridge */
+	/* List for registered errors handlers */
+	struct list_head vme_error_handlers;
+	/* List of devices on this bridge */
+	struct list_head devices;
 
 	/* Bridge Info - XXX Move to private structure? */
 	struct device *parent;	/* Parent device (eg. pdev->dev for PCI) */
@@ -168,13 +173,13 @@ struct vme_bridge {
 
 void vme_bus_error_handler(struct vme_bridge *bridge,
 			   unsigned long long address, int am);
-struct vme_bus_error *vme_find_error(struct vme_bridge *bridge, u32 aspace,
-				     unsigned long long address, size_t count);
-void vme_clear_errors(struct vme_bridge *bridge, u32 aspace,
-		      unsigned long long address, size_t count);
 void vme_irq_handler(struct vme_bridge *, int, int);
 
 int vme_register_bridge(struct vme_bridge *);
 void vme_unregister_bridge(struct vme_bridge *);
+struct vme_error_handler *vme_register_error_handler(
+	struct vme_bridge *bridge, u32 aspace,
+	unsigned long long address, size_t len);
+void vme_unregister_error_handler(struct vme_error_handler *handler);
 
 #endif /* _VME_BRIDGE_H_ */

commit 472f16f33c7d53515af83c805d4babd8a6c24a19
Author: Dmitry Kalinkin <dmitry.kalinkin@gmail.com>
Date:   Fri Sep 18 02:01:43 2015 +0300

    vme: include address space in error filtering
    
    Also changes vme_bus_error_handler to take generic address modifier code
    instead of raw contents of a device-specific attribute register.
    
    Signed-off-by: Dmitry Kalinkin <dmitry.kalinkin@gmail.com>
    Cc: Igor Alekseev <igor.alekseev@itep.ru>
    Acked-by: Martyn Welch <martyn@welchs.me.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/vme/vme_bridge.h b/drivers/vme/vme_bridge.h
index d8d6b144003b..92fbe18cbc42 100644
--- a/drivers/vme/vme_bridge.h
+++ b/drivers/vme/vme_bridge.h
@@ -77,8 +77,8 @@ struct vme_lm_resource {
 
 struct vme_bus_error {
 	struct list_head list;
+	u32 aspace;
 	unsigned long long address;
-	u32 attributes;
 };
 
 struct vme_callback {
@@ -167,7 +167,7 @@ struct vme_bridge {
 };
 
 void vme_bus_error_handler(struct vme_bridge *bridge,
-			   unsigned long long address, u32 attributes);
+			   unsigned long long address, int am);
 struct vme_bus_error *vme_find_error(struct vme_bridge *bridge, u32 aspace,
 				     unsigned long long address, size_t count);
 void vme_clear_errors(struct vme_bridge *bridge, u32 aspace,

commit e2c6393fda98dde5534dd6f83bd15f76abed6555
Author: Dmitry Kalinkin <dmitry.kalinkin@gmail.com>
Date:   Fri Sep 18 02:01:42 2015 +0300

    vme: move tsi148 error handling into VME subsystem
    
    Error handling code found in tsi148 is not device specific. In fact it
    already relies on shared vme_bus_error struct and vme_bridge.vme_errors
    field. The other bridge driver could reuse this code if it is shared.
    
    This introduces a slight behavior change: vme error message won't be
    triggered in a rare case when err_chk=1 and kmalloc fails.
    
    Signed-off-by: Dmitry Kalinkin <dmitry.kalinkin@gmail.com>
    Cc: Igor Alekseev <igor.alekseev@itep.ru>
    Acked-by: Martyn Welch <martyn@welchs.me.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/vme/vme_bridge.h b/drivers/vme/vme_bridge.h
index 934949abd745..d8d6b144003b 100644
--- a/drivers/vme/vme_bridge.h
+++ b/drivers/vme/vme_bridge.h
@@ -166,6 +166,12 @@ struct vme_bridge {
 		void *vaddr, dma_addr_t dma);
 };
 
+void vme_bus_error_handler(struct vme_bridge *bridge,
+			   unsigned long long address, u32 attributes);
+struct vme_bus_error *vme_find_error(struct vme_bridge *bridge, u32 aspace,
+				     unsigned long long address, size_t count);
+void vme_clear_errors(struct vme_bridge *bridge, u32 aspace,
+		      unsigned long long address, size_t count);
 void vme_irq_handler(struct vme_bridge *, int, int);
 
 int vme_register_bridge(struct vme_bridge *);

commit db3b9e990e75573402cda22faf933760f076c033
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu Apr 26 12:34:58 2012 -0700

    Staging: VME: move VME drivers out of staging
    
    This moves the VME core, VME board drivers, and VME bridge drivers out
    of the drivers/staging/vme/ area to drivers/vme/.
    
    The VME device drivers have not moved out yet due to some API questions
    they are still working through, that should happen soon, hopefully.
    
    Cc: Martyn Welch <martyn.welch@ge.com>
    Cc: Manohar Vanga <manohar.vanga@cern.ch>
    Cc: Vincent Bossier <vincent.bossier@gmail.com>
    Cc: "Emilio G. Cota" <cota@braap.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/vme/vme_bridge.h b/drivers/vme/vme_bridge.h
new file mode 100644
index 000000000000..934949abd745
--- /dev/null
+++ b/drivers/vme/vme_bridge.h
@@ -0,0 +1,174 @@
+#ifndef _VME_BRIDGE_H_
+#define _VME_BRIDGE_H_
+
+#define VME_CRCSR_BUF_SIZE (508*1024)
+/*
+ * Resource structures
+ */
+struct vme_master_resource {
+	struct list_head list;
+	struct vme_bridge *parent;
+	/*
+	 * We are likely to need to access the VME bus in interrupt context, so
+	 * protect master routines with a spinlock rather than a mutex.
+	 */
+	spinlock_t lock;
+	int locked;
+	int number;
+	u32 address_attr;
+	u32 cycle_attr;
+	u32 width_attr;
+	struct resource bus_resource;
+	void __iomem *kern_base;
+};
+
+struct vme_slave_resource {
+	struct list_head list;
+	struct vme_bridge *parent;
+	struct mutex mtx;
+	int locked;
+	int number;
+	u32 address_attr;
+	u32 cycle_attr;
+};
+
+struct vme_dma_pattern {
+	u32 pattern;
+	u32 type;
+};
+
+struct vme_dma_pci {
+	dma_addr_t address;
+};
+
+struct vme_dma_vme {
+	unsigned long long address;
+	u32 aspace;
+	u32 cycle;
+	u32 dwidth;
+};
+
+struct vme_dma_list {
+	struct list_head list;
+	struct vme_dma_resource *parent;
+	struct list_head entries;
+	struct mutex mtx;
+};
+
+struct vme_dma_resource {
+	struct list_head list;
+	struct vme_bridge *parent;
+	struct mutex mtx;
+	int locked;
+	int number;
+	struct list_head pending;
+	struct list_head running;
+	u32 route_attr;
+};
+
+struct vme_lm_resource {
+	struct list_head list;
+	struct vme_bridge *parent;
+	struct mutex mtx;
+	int locked;
+	int number;
+	int monitors;
+};
+
+struct vme_bus_error {
+	struct list_head list;
+	unsigned long long address;
+	u32 attributes;
+};
+
+struct vme_callback {
+	void (*func)(int, int, void*);
+	void *priv_data;
+};
+
+struct vme_irq {
+	int count;
+	struct vme_callback callback[255];
+};
+
+/* Allow 16 characters for name (including null character) */
+#define VMENAMSIZ 16
+
+/* This structure stores all the information about one bridge
+ * The structure should be dynamically allocated by the driver and one instance
+ * of the structure should be present for each VME chip present in the system.
+ */
+struct vme_bridge {
+	char name[VMENAMSIZ];
+	int num;
+	struct list_head master_resources;
+	struct list_head slave_resources;
+	struct list_head dma_resources;
+	struct list_head lm_resources;
+
+	struct list_head vme_errors;	/* List for errors generated on VME */
+	struct list_head devices;	/* List of devices on this bridge */
+
+	/* Bridge Info - XXX Move to private structure? */
+	struct device *parent;	/* Parent device (eg. pdev->dev for PCI) */
+	void *driver_priv;	/* Private pointer for the bridge driver */
+	struct list_head bus_list; /* list of VME buses */
+
+	/* Interrupt callbacks */
+	struct vme_irq irq[7];
+	/* Locking for VME irq callback configuration */
+	struct mutex irq_mtx;
+
+	/* Slave Functions */
+	int (*slave_get) (struct vme_slave_resource *, int *,
+		unsigned long long *, unsigned long long *, dma_addr_t *,
+		u32 *, u32 *);
+	int (*slave_set) (struct vme_slave_resource *, int, unsigned long long,
+		unsigned long long, dma_addr_t, u32, u32);
+
+	/* Master Functions */
+	int (*master_get) (struct vme_master_resource *, int *,
+		unsigned long long *, unsigned long long *, u32 *, u32 *,
+		u32 *);
+	int (*master_set) (struct vme_master_resource *, int,
+		unsigned long long, unsigned long long,  u32, u32, u32);
+	ssize_t (*master_read) (struct vme_master_resource *, void *, size_t,
+		loff_t);
+	ssize_t (*master_write) (struct vme_master_resource *, void *, size_t,
+		loff_t);
+	unsigned int (*master_rmw) (struct vme_master_resource *, unsigned int,
+		unsigned int, unsigned int, loff_t);
+
+	/* DMA Functions */
+	int (*dma_list_add) (struct vme_dma_list *, struct vme_dma_attr *,
+		struct vme_dma_attr *, size_t);
+	int (*dma_list_exec) (struct vme_dma_list *);
+	int (*dma_list_empty) (struct vme_dma_list *);
+
+	/* Interrupt Functions */
+	void (*irq_set) (struct vme_bridge *, int, int, int);
+	int (*irq_generate) (struct vme_bridge *, int, int);
+
+	/* Location monitor functions */
+	int (*lm_set) (struct vme_lm_resource *, unsigned long long, u32, u32);
+	int (*lm_get) (struct vme_lm_resource *, unsigned long long *, u32 *,
+		u32 *);
+	int (*lm_attach) (struct vme_lm_resource *, int, void (*callback)(int));
+	int (*lm_detach) (struct vme_lm_resource *, int);
+
+	/* CR/CSR space functions */
+	int (*slot_get) (struct vme_bridge *);
+
+	/* Bridge parent interface */
+	void *(*alloc_consistent)(struct device *dev, size_t size,
+		dma_addr_t *dma);
+	void (*free_consistent)(struct device *dev, size_t size,
+		void *vaddr, dma_addr_t dma);
+};
+
+void vme_irq_handler(struct vme_bridge *, int, int);
+
+int vme_register_bridge(struct vme_bridge *);
+void vme_unregister_bridge(struct vme_bridge *);
+
+#endif /* _VME_BRIDGE_H_ */
