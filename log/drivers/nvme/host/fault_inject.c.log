commit f79d5fda4ea08c33a114087573d86f703149ee0e
Author: Akinobu Mita <akinobu.mita@gmail.com>
Date:   Sun Jun 9 23:17:01 2019 +0900

    nvme: enable to inject errors into admin commands
    
    This enables to inject errors into the commands submitted to the admin
    queue.
    
    It is useful to test error handling in the controller initialization.
    
            # echo 100 > /sys/kernel/debug/nvme0/fault_inject/probability
            # echo 1 > /sys/kernel/debug/nvme0/fault_inject/times
            # echo 10 > /sys/kernel/debug/nvme0/fault_inject/space
            # nvme reset /dev/nvme0
            # dmesg
            ...
            nvme nvme0: Could not set queue count (16385)
            nvme nvme0: IO queues not created
    
    Signed-off-by: Akinobu Mita <akinobu.mita@gmail.com>
    Reviewed-by: Minwoo Im <minwoo.im.dev@gmail.com>
    Reviewed-by: Sagi Grimberg <sagi@grimberg.me>
    Reviewed-by: Chaitanya Kulkarni <chaitanya.kulkarni@wdc.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/nvme/host/fault_inject.c b/drivers/nvme/host/fault_inject.c
index e37b8c2fddea..1352159733b0 100644
--- a/drivers/nvme/host/fault_inject.c
+++ b/drivers/nvme/host/fault_inject.c
@@ -60,9 +60,6 @@ void nvme_should_fail(struct request *req)
 	struct nvme_fault_inject *fault_inject = NULL;
 	u16 status;
 
-	/*
-	 * make sure this request is coming from a valid namespace
-	 */
 	if (disk) {
 		struct nvme_ns *ns = disk->private_data;
 
@@ -70,6 +67,8 @@ void nvme_should_fail(struct request *req)
 			fault_inject = &ns->fault_inject;
 		else
 			WARN_ONCE(1, "No namespace found for request\n");
+	} else {
+		fault_inject = &nvme_req(req)->ctrl->fault_inject;
 	}
 
 	if (fault_inject && should_fail(&fault_inject->attr, 1)) {

commit a3646451edd52ba238cbe4f618aaf6eb9bf9d60c
Author: Akinobu Mita <akinobu.mita@gmail.com>
Date:   Thu Jun 20 08:49:02 2019 +0200

    nvme: prepare for fault injection into admin commands
    
    Currenlty fault injection support for nvme only enables to inject errors
    into the commands submitted to I/O queues.
    
    In preparation for fault injection into the admin commands, this makes
    the helper functions independent of struct nvme_ns.
    
    Signed-off-by: Akinobu Mita <akinobu.mita@gmail.com>
    Reviewed-by: Minwoo Im <minwoo.im.dev@gmail.com>
    Reviewed-by: Sagi Grimberg <sagi@grimberg.me>
    Reviewed-by: Chaitanya Kulkarni <chaitanya.kulkarni@wdc.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/nvme/host/fault_inject.c b/drivers/nvme/host/fault_inject.c
index 4cfd2c9222d4..e37b8c2fddea 100644
--- a/drivers/nvme/host/fault_inject.c
+++ b/drivers/nvme/host/fault_inject.c
@@ -15,11 +15,10 @@ static DECLARE_FAULT_ATTR(fail_default_attr);
 static char *fail_request;
 module_param(fail_request, charp, 0000);
 
-void nvme_fault_inject_init(struct nvme_ns *ns)
+void nvme_fault_inject_init(struct nvme_fault_inject *fault_inj,
+			    const char *dev_name)
 {
 	struct dentry *dir, *parent;
-	char *name = ns->disk->disk_name;
-	struct nvme_fault_inject *fault_inj = &ns->fault_inject;
 	struct fault_attr *attr = &fault_inj->attr;
 
 	/* set default fault injection attribute */
@@ -27,20 +26,20 @@ void nvme_fault_inject_init(struct nvme_ns *ns)
 		setup_fault_attr(&fail_default_attr, fail_request);
 
 	/* create debugfs directory and attribute */
-	parent = debugfs_create_dir(name, NULL);
+	parent = debugfs_create_dir(dev_name, NULL);
 	if (!parent) {
-		pr_warn("%s: failed to create debugfs directory\n", name);
+		pr_warn("%s: failed to create debugfs directory\n", dev_name);
 		return;
 	}
 
 	*attr = fail_default_attr;
 	dir = fault_create_debugfs_attr("fault_inject", parent, attr);
 	if (IS_ERR(dir)) {
-		pr_warn("%s: failed to create debugfs attr\n", name);
+		pr_warn("%s: failed to create debugfs attr\n", dev_name);
 		debugfs_remove_recursive(parent);
 		return;
 	}
-	ns->fault_inject.parent = parent;
+	fault_inj->parent = parent;
 
 	/* create debugfs for status code and dont_retry */
 	fault_inj->status = NVME_SC_INVALID_OPCODE;
@@ -49,29 +48,34 @@ void nvme_fault_inject_init(struct nvme_ns *ns)
 	debugfs_create_bool("dont_retry", 0600, dir, &fault_inj->dont_retry);
 }
 
-void nvme_fault_inject_fini(struct nvme_ns *ns)
+void nvme_fault_inject_fini(struct nvme_fault_inject *fault_inject)
 {
 	/* remove debugfs directories */
-	debugfs_remove_recursive(ns->fault_inject.parent);
+	debugfs_remove_recursive(fault_inject->parent);
 }
 
 void nvme_should_fail(struct request *req)
 {
 	struct gendisk *disk = req->rq_disk;
-	struct nvme_ns *ns = NULL;
+	struct nvme_fault_inject *fault_inject = NULL;
 	u16 status;
 
 	/*
 	 * make sure this request is coming from a valid namespace
 	 */
-	if (!disk)
-		return;
+	if (disk) {
+		struct nvme_ns *ns = disk->private_data;
+
+		if (ns)
+			fault_inject = &ns->fault_inject;
+		else
+			WARN_ONCE(1, "No namespace found for request\n");
+	}
 
-	ns = disk->private_data;
-	if (ns && should_fail(&ns->fault_inject.attr, 1)) {
+	if (fault_inject && should_fail(&fault_inject->attr, 1)) {
 		/* inject status code and DNR bit */
-		status = ns->fault_inject.status;
-		if (ns->fault_inject.dont_retry)
+		status = fault_inject->status;
+		if (fault_inject->dont_retry)
 			status |= NVME_SC_DNR;
 		nvme_req(req)->status =	status;
 	}

commit bc50ad7501dd3629af9aa423ed0d1eae0061bcf1
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Feb 18 09:36:29 2019 +0100

    nvme: convert to SPDX identifiers
    
    Update license to use SPDX-License-Identifier instead of verbose license
    text.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Sagi Grimberg <sagi@grimberg.me>

diff --git a/drivers/nvme/host/fault_inject.c b/drivers/nvme/host/fault_inject.c
index 02632266ac06..4cfd2c9222d4 100644
--- a/drivers/nvme/host/fault_inject.c
+++ b/drivers/nvme/host/fault_inject.c
@@ -1,8 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * fault injection support for nvme.
  *
  * Copyright (c) 2018, Oracle and/or its affiliates
- *
  */
 
 #include <linux/moduleparam.h>

commit b9e03857f2e22788db6ccb67512a6604a6b4f6db
Author: Thomas Tai <thomas.tai@oracle.com>
Date:   Thu Feb 8 13:38:29 2018 -0500

    nvme: Add fault injection feature
    
    Linux's fault injection framework provides a systematic way to support
    error injection via debugfs in the /sys/kernel/debug directory. This
    patch uses the framework to add error injection to NVMe driver. The
    fault injection source code is stored in a separate file and only linked
    if CONFIG_FAULT_INJECTION_DEBUG_FS kernel config is selected.
    
    Once the error injection is enabled, NVME_SC_INVALID_OPCODE with no
    retry will be injected into the nvme_end_request. Users can change
    the default status code and no retry flag via debufs. Following example
    shows how to enable and inject an error. For more examples, refer to
    Documentation/fault-injection/nvme-fault-injection.txt
    
    How to enable nvme fault injection:
    
    First, enable CONFIG_FAULT_INJECTION_DEBUG_FS kernel config,
    recompile the kernel. After booting up the kernel, do the
    following.
    
    How to inject an error:
    
    mount /dev/nvme0n1 /mnt
    echo 1 > /sys/kernel/debug/nvme0n1/fault_inject/times
    echo 100 > /sys/kernel/debug/nvme0n1/fault_inject/probability
    cp a.file /mnt
    
    Expected Result:
    
    cp: cannot stat ‘/mnt/a.file’: Input/output error
    
    Message from dmesg:
    
    FAULT_INJECTION: forcing a failure.
    name fault_inject, interval 1, probability 100, space 0, times 1
    CPU: 0 PID: 0 Comm: swapper/0 Not tainted 4.15.0-rc8+ #2
    Hardware name: innotek GmbH VirtualBox/VirtualBox,
    BIOS VirtualBox 12/01/2006
    Call Trace:
      <IRQ>
      dump_stack+0x5c/0x7d
      should_fail+0x148/0x170
      nvme_should_fail+0x2f/0x50 [nvme_core]
      nvme_process_cq+0xe7/0x1d0 [nvme]
      nvme_irq+0x1e/0x40 [nvme]
      __handle_irq_event_percpu+0x3a/0x190
      handle_irq_event_percpu+0x30/0x70
      handle_irq_event+0x36/0x60
      handle_fasteoi_irq+0x78/0x120
      handle_irq+0xa7/0x130
      ? tick_irq_enter+0xa8/0xc0
      do_IRQ+0x43/0xc0
      common_interrupt+0xa2/0xa2
      </IRQ>
    RIP: 0010:native_safe_halt+0x2/0x10
    RSP: 0018:ffffffff82003e90 EFLAGS: 00000246 ORIG_RAX: ffffffffffffffdd
    RAX: ffffffff817a10c0 RBX: ffffffff82012480 RCX: 0000000000000000
    RDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000000000
    RBP: 0000000000000000 R08: 000000008e38ce64 R09: 0000000000000000
    R10: 0000000000000000 R11: 0000000000000000 R12: ffffffff82012480
    R13: ffffffff82012480 R14: 0000000000000000 R15: 0000000000000000
      ? __sched_text_end+0x4/0x4
      default_idle+0x18/0xf0
      do_idle+0x150/0x1d0
      cpu_startup_entry+0x6f/0x80
      start_kernel+0x4c4/0x4e4
      ? set_init_arg+0x55/0x55
      secondary_startup_64+0xa5/0xb0
      print_req_error: I/O error, dev nvme0n1, sector 9240
    EXT4-fs error (device nvme0n1): ext4_find_entry:1436:
    inode #2: comm cp: reading directory lblock 0
    
    Signed-off-by: Thomas Tai <thomas.tai@oracle.com>
    Reviewed-by: Eric Saint-Etienne <eric.saint.etienne@oracle.com>
    Signed-off-by: Karl Volz <karl.volz@oracle.com>
    Reviewed-by: Keith Busch <keith.busch@intel.com>
    Signed-off-by: Sagi Grimberg <sagi@grimberg.me>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/drivers/nvme/host/fault_inject.c b/drivers/nvme/host/fault_inject.c
new file mode 100644
index 000000000000..02632266ac06
--- /dev/null
+++ b/drivers/nvme/host/fault_inject.c
@@ -0,0 +1,79 @@
+/*
+ * fault injection support for nvme.
+ *
+ * Copyright (c) 2018, Oracle and/or its affiliates
+ *
+ */
+
+#include <linux/moduleparam.h>
+#include "nvme.h"
+
+static DECLARE_FAULT_ATTR(fail_default_attr);
+/* optional fault injection attributes boot time option:
+ * nvme_core.fail_request=<interval>,<probability>,<space>,<times>
+ */
+static char *fail_request;
+module_param(fail_request, charp, 0000);
+
+void nvme_fault_inject_init(struct nvme_ns *ns)
+{
+	struct dentry *dir, *parent;
+	char *name = ns->disk->disk_name;
+	struct nvme_fault_inject *fault_inj = &ns->fault_inject;
+	struct fault_attr *attr = &fault_inj->attr;
+
+	/* set default fault injection attribute */
+	if (fail_request)
+		setup_fault_attr(&fail_default_attr, fail_request);
+
+	/* create debugfs directory and attribute */
+	parent = debugfs_create_dir(name, NULL);
+	if (!parent) {
+		pr_warn("%s: failed to create debugfs directory\n", name);
+		return;
+	}
+
+	*attr = fail_default_attr;
+	dir = fault_create_debugfs_attr("fault_inject", parent, attr);
+	if (IS_ERR(dir)) {
+		pr_warn("%s: failed to create debugfs attr\n", name);
+		debugfs_remove_recursive(parent);
+		return;
+	}
+	ns->fault_inject.parent = parent;
+
+	/* create debugfs for status code and dont_retry */
+	fault_inj->status = NVME_SC_INVALID_OPCODE;
+	fault_inj->dont_retry = true;
+	debugfs_create_x16("status", 0600, dir,	&fault_inj->status);
+	debugfs_create_bool("dont_retry", 0600, dir, &fault_inj->dont_retry);
+}
+
+void nvme_fault_inject_fini(struct nvme_ns *ns)
+{
+	/* remove debugfs directories */
+	debugfs_remove_recursive(ns->fault_inject.parent);
+}
+
+void nvme_should_fail(struct request *req)
+{
+	struct gendisk *disk = req->rq_disk;
+	struct nvme_ns *ns = NULL;
+	u16 status;
+
+	/*
+	 * make sure this request is coming from a valid namespace
+	 */
+	if (!disk)
+		return;
+
+	ns = disk->private_data;
+	if (ns && should_fail(&ns->fault_inject.attr, 1)) {
+		/* inject status code and DNR bit */
+		status = ns->fault_inject.status;
+		if (ns->fault_inject.dont_retry)
+			status |= NVME_SC_DNR;
+		nvme_req(req)->status =	status;
+	}
+}
+EXPORT_SYMBOL_GPL(nvme_should_fail);
