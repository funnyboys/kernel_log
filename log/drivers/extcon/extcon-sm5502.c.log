commit 2ddf50a75dab49eeb534dbdad92972f56a84046d
Author: Xu Wang <vulab@iscas.ac.cn>
Date:   Fri Dec 13 09:48:34 2019 +0000

    extcon: sm5502: Remove unneeded semicolon
    
    Remove unneeded semicolon reported by coccinelle.
    
    Signed-off-by: Xu Wang <vulab@iscas.ac.cn>
    [cw00.choi: Edit patch title and description]
    Signed-off-by: Chanwoo Choi <cw00.choi@samsung.com>

diff --git a/drivers/extcon/extcon-sm5502.c b/drivers/extcon/extcon-sm5502.c
index bcf65aaca5d2..106d4da647bd 100644
--- a/drivers/extcon/extcon-sm5502.c
+++ b/drivers/extcon/extcon-sm5502.c
@@ -249,7 +249,7 @@ static int sm5502_muic_set_path(struct sm5502_muic_info *info,
 		dev_err(info->dev, "Unknown DM_CON/DP_CON switch type (%d)\n",
 				con_sw);
 		return -EINVAL;
-	};
+	}
 
 	switch (vbus_sw) {
 	case VBUSIN_SWITCH_OPEN:
@@ -268,7 +268,7 @@ static int sm5502_muic_set_path(struct sm5502_muic_info *info,
 	default:
 		dev_err(info->dev, "Unknown VBUS switch type (%d)\n", vbus_sw);
 		return -EINVAL;
-	};
+	}
 
 	return 0;
 }
@@ -357,13 +357,13 @@ static unsigned int sm5502_muic_get_cable_type(struct sm5502_muic_info *info)
 				"cannot identify the cable type: adc(0x%x)\n",
 				adc);
 			return -EINVAL;
-		};
+		}
 		break;
 	default:
 		dev_err(info->dev,
 			"failed to identify the cable type: adc(0x%x)\n", adc);
 		return -EINVAL;
-	};
+	}
 
 	return cable_type;
 }
@@ -405,7 +405,7 @@ static int sm5502_muic_cable_handler(struct sm5502_muic_info *info,
 		dev_dbg(info->dev,
 			"cannot handle this cable_type (0x%x)\n", cable_type);
 		return 0;
-	};
+	}
 
 	/* Change internal hardware path(DM_CON/DP_CON, VBUSIN) */
 	ret = sm5502_muic_set_path(info, con_sw, vbus_sw, attached);

commit ddd1bbbae486ff5913c8fc72c853dcea60713236
Author: Colin Ian King <colin.king@canonical.com>
Date:   Fri Oct 25 14:12:27 2019 +0100

    extcon: sm5502: remove redundant assignment to variable cable_type
    
    The variable cable_type is being initialized with a value that
    is never read and is being re-assigned a little later on. The
    assignment is redundant and hence can be removed.
    
    Addresses-Coverity: ("Unused value")
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Chanwoo Choi <cw00.choi@samsung.com>

diff --git a/drivers/extcon/extcon-sm5502.c b/drivers/extcon/extcon-sm5502.c
index b3d93baf4fc5..bcf65aaca5d2 100644
--- a/drivers/extcon/extcon-sm5502.c
+++ b/drivers/extcon/extcon-sm5502.c
@@ -276,7 +276,7 @@ static int sm5502_muic_set_path(struct sm5502_muic_info *info,
 /* Return cable type of attached or detached accessories */
 static unsigned int sm5502_muic_get_cable_type(struct sm5502_muic_info *info)
 {
-	unsigned int cable_type = -1, adc, dev_type1;
+	unsigned int cable_type, adc, dev_type1;
 	int ret;
 
 	/* Read ADC value according to external cable or button */

commit 6942635032cfd3e003e980d2dfa4e6323a3ce145
Author: Stephan Gerhold <stephan@gerhold.net>
Date:   Thu Oct 10 17:47:20 2019 +0200

    extcon: sm5502: Reset registers during initialization
    
    On some devices (e.g. Samsung Galaxy A5 (2015)), the bootloader
    seems to keep interrupts enabled for SM5502 when booting Linux.
    Changing the cable state (i.e. plugging in a cable) - until the driver
    is loaded - will therefore produce an interrupt that is never read.
    
    In this situation, the cable state will be stuck forever on the
    initial state because SM5502 stops sending interrupts.
    This can be avoided by clearing those pending interrupts after
    the driver has been loaded.
    
    One way to do this is to reset all registers to default state
    by writing to SM5502_REG_RESET. This ensures that we start from
    a clean state, with all interrupts disabled.
    
    Suggested-by: Chanwoo Choi <cw00.choi@samsung.com>
    Signed-off-by: Stephan Gerhold <stephan@gerhold.net>
    Signed-off-by: Chanwoo Choi <cw00.choi@samsung.com>

diff --git a/drivers/extcon/extcon-sm5502.c b/drivers/extcon/extcon-sm5502.c
index dc43847ad2b0..b3d93baf4fc5 100644
--- a/drivers/extcon/extcon-sm5502.c
+++ b/drivers/extcon/extcon-sm5502.c
@@ -65,6 +65,10 @@ struct sm5502_muic_info {
 /* Default value of SM5502 register to bring up MUIC device. */
 static struct reg_data sm5502_reg_data[] = {
 	{
+		.reg = SM5502_REG_RESET,
+		.val = SM5502_REG_RESET_MASK,
+		.invert = true,
+	}, {
 		.reg = SM5502_REG_CONTROL,
 		.val = SM5502_REG_CONTROL_MASK_INT_MASK,
 		.invert = false,

commit 005ad18727b489eb9fd6182f8941042e274387dc
Author: Vasyl Gomonovych <gomonovych@gmail.com>
Date:   Fri Jul 19 18:28:06 2019 +0200

    extcon: sm5502: Add IRQ_ONESHOT
    
    Do not fire irq again until thread done
    
    Signed-off-by: Vasyl Gomonovych <gomonovych@gmail.com>
    Signed-off-by: Chanwoo Choi <cw00.choi@samsung.com>

diff --git a/drivers/extcon/extcon-sm5502.c b/drivers/extcon/extcon-sm5502.c
index 98e4f616b8f1..dc43847ad2b0 100644
--- a/drivers/extcon/extcon-sm5502.c
+++ b/drivers/extcon/extcon-sm5502.c
@@ -597,7 +597,7 @@ static int sm5022_muic_i2c_probe(struct i2c_client *i2c,
 
 		ret = devm_request_threaded_irq(info->dev, virq, NULL,
 						sm5502_muic_irq_handler,
-						IRQF_NO_SUSPEND,
+						IRQF_NO_SUSPEND | IRQF_ONESHOT,
 						muic_irq->name, info);
 		if (ret) {
 			dev_err(info->dev,

commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/extcon/extcon-sm5502.c b/drivers/extcon/extcon-sm5502.c
index 0cfb5a3efdf6..98e4f616b8f1 100644
--- a/drivers/extcon/extcon-sm5502.c
+++ b/drivers/extcon/extcon-sm5502.c
@@ -1,13 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * extcon-sm5502.c - Silicon Mitus SM5502 extcon drvier to support USB switches
  *
  * Copyright (c) 2014 Samsung Electronics Co., Ltd
  * Author: Chanwoo Choi <cw00.choi@samsung.com>
- *
- * This program is free software; you can redistribute  it and/or modify it
- * under  the terms of  the GNU General  Public License as published by the
- * Free Software Foundation;  either version 2 of the  License, or (at your
- * option) any later version.
  */
 
 #include <linux/err.h>

commit 176aa36012135d172394a928a03fb03dfecd83f9
Author: Chanwoo Choi <cw00.choi@samsung.com>
Date:   Thu Sep 21 12:11:24 2017 +0900

    extcon: Split out extcon header file for consumer and provider device
    
    The extcon has two type of extcon devices as following.
    - 'extcon provider deivce' adds new extcon device and detect the
       state/properties of external connector. Also, it notifies the
       state/properties to the extcon consumer device.
    - 'extcon consumer device' gets the change state/properties
       from extcon provider device.
    Prior to that, include/linux/extcon.h contains all exported API for
    both provider and consumer device driver. To clarify the meaning of
    header file and to remove the wrong use-case on consumer device,
    this patch separates into extcon.h and extcon-provider.h.
    
    [Description for include/linux/{extcon.h|extcon-provider.h}]
    - extcon.h includes the extcon API and data structure for extcon consumer
      device driver. This header file contains the following APIs:
      : Register/unregister the notifier to catch the change of extcon device
      : Get the extcon device instance
      : Get the extcon device name
      : Get the state of each external connector
      : Get the property value of each external connector
      : Get the property capability of each external connector
    
    - extcon-provider.h includes the extcon API and data structure for extcon
      provider device driver. This header file contains the following APIs:
      : Include 'include/linux/extcon.h'
      : Allocate the memory for extcon device instance
      : Register/unregister extcon device
      : Set the state of each external connector
      : Set the property value of each external connector
      : Set the property capability of each external connector
    
    Signed-off-by: Chanwoo Choi <cw00.choi@samsung.com>
    Acked-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Acked-by: Chen-Yu Tsai <wens@csie.org>
    Acked-by: Charles Keepax <ckeepax@opensource.cirrus.com>
    Acked-by: Lee Jones <lee.jones@linaro.org>
    Acked-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Acked-by: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
    Acked-by: Kishon Vijay Abraham I <kishon@ti.com>

diff --git a/drivers/extcon/extcon-sm5502.c b/drivers/extcon/extcon-sm5502.c
index 106ef0297b53..0cfb5a3efdf6 100644
--- a/drivers/extcon/extcon-sm5502.c
+++ b/drivers/extcon/extcon-sm5502.c
@@ -19,7 +19,7 @@
 #include <linux/platform_device.h>
 #include <linux/regmap.h>
 #include <linux/slab.h>
-#include <linux/extcon.h>
+#include <linux/extcon-provider.h>
 
 #include "extcon-sm5502.h"
 

commit af57fa4de24654aa4b2ee648dcd14a3e31bce3a6
Author: Srikant Ritolia <s.ritolia@samsung.com>
Date:   Wed Dec 7 17:29:39 2016 +0530

    extcon: Restructure multi-line comments to follow codingstyle
    
    Aligning all block comments in extcon subsystem as per linux coding style.
    Found using checkpatch.pl script.
    
    Signed-off-by: Srikant Ritolia <s.ritolia@samsung.com>
    Signed-off-by: Chanwoo Choi <cw00.choi@samsung.com>

diff --git a/drivers/extcon/extcon-sm5502.c b/drivers/extcon/extcon-sm5502.c
index b22325688503..106ef0297b53 100644
--- a/drivers/extcon/extcon-sm5502.c
+++ b/drivers/extcon/extcon-sm5502.c
@@ -135,8 +135,10 @@ enum sm5502_muic_acc_type {
 	SM5502_MUIC_ADC_AUDIO_TYPE1,
 	SM5502_MUIC_ADC_OPEN = 0x1f,
 
-	/* The below accessories have same ADC value (0x1f or 0x1e).
-	   So, Device type1 is used to separate specific accessory. */
+	/*
+	 * The below accessories have same ADC value (0x1f or 0x1e).
+	 * So, Device type1 is used to separate specific accessory.
+	 */
 							/* |---------|--ADC| */
 							/* |    [7:5]|[4:0]| */
 	SM5502_MUIC_ADC_AUDIO_TYPE1_FULL_REMOTE = 0x3e,	/* |      001|11110| */

commit 8670b4598064007abfc44554e713fa2004734e1d
Author: Chanwoo Choi <cw00.choi@samsung.com>
Date:   Tue Aug 16 15:55:34 2016 +0900

    extcon: Use the extcon_set_state_sync() instead of deprecated functions
    
    This patch alters the renamed extcon API to set the state of the external
    connectors instead of deprecated extcon_set_cable_state_().
    
    Because the patch[1] modifies the function name to maintain the function
    naming pattern.
    - extcon_set_cable_state_() -> extcon_set_state_sync()
    - extcon_get_cable_state_() -> extcon_get_state()
    
    [1] https://lkml.org/lkml/2016/8/4/729
    - extcon: Rename the extcon_set/get_state() to maintain the function naming pattern
    
    Signed-off-by: Chanwoo Choi <cw00.choi@samsung.com>
    Acked-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Acked-by: Roger Quadros <rogerq@ti.com>

diff --git a/drivers/extcon/extcon-sm5502.c b/drivers/extcon/extcon-sm5502.c
index df769a17e736..b22325688503 100644
--- a/drivers/extcon/extcon-sm5502.c
+++ b/drivers/extcon/extcon-sm5502.c
@@ -411,9 +411,9 @@ static int sm5502_muic_cable_handler(struct sm5502_muic_info *info,
 		return ret;
 
 	/* Change the state of external accessory */
-	extcon_set_cable_state_(info->edev, id, attached);
+	extcon_set_state_sync(info->edev, id, attached);
 	if (id == EXTCON_USB)
-		extcon_set_cable_state_(info->edev, EXTCON_CHG_USB_SDP,
+		extcon_set_state_sync(info->edev, EXTCON_CHG_USB_SDP,
 					attached);
 
 	return 0;

commit 8b45b6a0741678902810d7be95e635c210fbb198
Author: Chanwoo Choi <cw00.choi@samsung.com>
Date:   Mon Nov 9 10:10:15 2015 +0900

    extcon: Add the EXTCON_CHG_USB_SDP to support SDP charing port
    
    This patch adds the new EXTCON_CHG_USB_SDP connector to support SDP (Standard
    Downstream Port) USB charging port. The commit 11eecf910bd8 ("extcon: Modify
    the id and name of external connector") add the new EXTCON_CHG_USB_SDP
    connector which support the both data transfer and usb charging at the same
    time.
    
    Signed-off-by: Chanwoo Choi <cw00.choi@samsung.com>
    Reviewed-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>

diff --git a/drivers/extcon/extcon-sm5502.c b/drivers/extcon/extcon-sm5502.c
index 571de2e6e7c4..df769a17e736 100644
--- a/drivers/extcon/extcon-sm5502.c
+++ b/drivers/extcon/extcon-sm5502.c
@@ -95,6 +95,7 @@ static struct reg_data sm5502_reg_data[] = {
 static const unsigned int sm5502_extcon_cable[] = {
 	EXTCON_USB,
 	EXTCON_USB_HOST,
+	EXTCON_CHG_USB_SDP,
 	EXTCON_CHG_USB_DCP,
 	EXTCON_NONE,
 };
@@ -411,6 +412,9 @@ static int sm5502_muic_cable_handler(struct sm5502_muic_info *info,
 
 	/* Change the state of external accessory */
 	extcon_set_cable_state_(info->edev, id, attached);
+	if (id == EXTCON_USB)
+		extcon_set_cable_state_(info->edev, EXTCON_CHG_USB_SDP,
+					attached);
 
 	return 0;
 }

commit d58593426e5cf41009f2e9d6eec3f47fe0cbedeb
Author: Geliang Tang <geliangtang@163.com>
Date:   Mon Dec 28 23:00:15 2015 +0800

    extcon: Use to_i2c_client for both rt8973a and sm5502
    
    Use to_i2c_client() instead of open-coding it.
    
    Signed-off-by: Geliang Tang <geliangtang@163.com>
    Signed-off-by: Chanwoo Choi <cw00.choi@samsung.com>

diff --git a/drivers/extcon/extcon-sm5502.c b/drivers/extcon/extcon-sm5502.c
index 7aac3cc7efd7..571de2e6e7c4 100644
--- a/drivers/extcon/extcon-sm5502.c
+++ b/drivers/extcon/extcon-sm5502.c
@@ -655,7 +655,7 @@ MODULE_DEVICE_TABLE(of, sm5502_dt_match);
 #ifdef CONFIG_PM_SLEEP
 static int sm5502_muic_suspend(struct device *dev)
 {
-	struct i2c_client *i2c = container_of(dev, struct i2c_client, dev);
+	struct i2c_client *i2c = to_i2c_client(dev);
 	struct sm5502_muic_info *info = i2c_get_clientdata(i2c);
 
 	enable_irq_wake(info->irq);
@@ -665,7 +665,7 @@ static int sm5502_muic_suspend(struct device *dev)
 
 static int sm5502_muic_resume(struct device *dev)
 {
-	struct i2c_client *i2c = container_of(dev, struct i2c_client, dev);
+	struct i2c_client *i2c = to_i2c_client(dev);
 	struct sm5502_muic_info *info = i2c_get_clientdata(i2c);
 
 	disable_irq_wake(info->irq);

commit 11eecf910bd81d36425020743b2df73651c5b466
Author: Chanwoo Choi <cw00.choi@samsung.com>
Date:   Sat Oct 3 14:15:13 2015 +0900

    extcon: Modify the id and name of external connector
    
    This patch modifies the id and name of external connector with the
    additional prefix to clarify both attribute and meaning of external
    connector as following:
    - EXTCON_CHG_* mean the charger connector.
    - EXTCON_JACK_* mean the jack connector.
    - EXTCON_DISP_* mean the display port connector.
    
    Following table show the new name of external connector with old name:
    --------------------------------------------------
    Old extcon name         | New extcon name        |
    --------------------------------------------------
    EXTCON_TA               | EXTCON_CHG_USB_DCP     |
    EXTCON_CHARGE_DOWNSTREAM| EXTCON_CHG_USB_CDP     |
    EXTCON_FAST_CHARGER     | EXTCON_CHG_USB_FAST    |
    EXTCON_SLOW_CHARGER     | EXTCON_CHG_USB_SLOW    |
    --------------------------------------------------
    EXTCON_MICROPHONE       | EXTCON_JACK_MICROPHONE |
    EXTCON_HEADPHONE        | EXTCON_JACK_HEADPHONE  |
    EXTCON_LINE_IN          | EXTCON_JACK_LINE_IN    |
    EXTCON_LINE_OUT         | EXTCON_JACK_LINE_OUT   |
    EXTCON_VIDEO_IN         | EXTCON_JACK_VIDEO_IN   |
    EXTCON_VIDEO_OUT        | EXTCON_JACK_VIDEO_OUT  |
    EXTCON_SPDIF_IN         | EXTCON_JACK_SPDIF_IN   |
    EXTCON_SPDIF_OUT        | EXTCON_JACK_SPDIF_OUT  |
    --------------------------------------------------
    EXTCON_HMDI             | EXTCON_DISP_HDMI       |
    EXTCON_MHL              | EXTCON_DISP_MHL        |
    EXTCON_DVI              | EXTCON_DISP_DVI        |
    EXTCON_VGA              | EXTCON_DISP_VGA        |
    --------------------------------------------------
    
    And, when altering the name of USB charger connector, EXTCON refers to the
    "Battery Charging v1.2 Spec and Adopters Agreement"[1] to use the standard
    name of USB charging port as following. Following name of USB charging port
    are already used in power_supply subsystem. We chan check it on patch[2].
    - EXTCON_CHG_USB_SDP    /* Standard Downstream Port */
    - EXTCON_CHG_USB_DCP    /* Dedicated Charging Port */
    - EXTCON_CHG_USB_CDP    /* Charging Downstream Port */
    - EXTCON_CHG_USB_ACA    /* Accessory Charger Adapter */
    
    [1] www.usb.org/developers/docs/devclass_docs/BCv1.2_070312.zip
    [2] commit 85efc8a18ced ("power_supply: Add types for USB chargers")
    
    Signed-off-by: Chanwoo Choi <cw00.choi@samsung.com>
    [ckeepax: For the Arizona changes]
    Acked-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Reviewed-by: Roger Quadros <rogerq@ti.com>

diff --git a/drivers/extcon/extcon-sm5502.c b/drivers/extcon/extcon-sm5502.c
index 2945091bfd0e..7aac3cc7efd7 100644
--- a/drivers/extcon/extcon-sm5502.c
+++ b/drivers/extcon/extcon-sm5502.c
@@ -95,7 +95,7 @@ static struct reg_data sm5502_reg_data[] = {
 static const unsigned int sm5502_extcon_cable[] = {
 	EXTCON_USB,
 	EXTCON_USB_HOST,
-	EXTCON_TA,
+	EXTCON_CHG_USB_DCP,
 	EXTCON_NONE,
 };
 
@@ -389,7 +389,7 @@ static int sm5502_muic_cable_handler(struct sm5502_muic_info *info,
 		vbus_sw	= VBUSIN_SWITCH_VBUSOUT_WITH_USB;
 		break;
 	case SM5502_MUIC_ADC_OPEN_TA:
-		id	= EXTCON_TA;
+		id	= EXTCON_CHG_USB_DCP;
 		con_sw	= DM_DP_SWITCH_OPEN;
 		vbus_sw	= VBUSIN_SWITCH_VBUSOUT;
 		break;

commit 363b389106e6762bc855d3da794461be18597d52
Author: Andrzej Hajda <a.hajda@samsung.com>
Date:   Thu Sep 24 16:00:21 2015 +0200

    extcon: sm5502: fix handling regmap_irq_get_virq result
    
    The function can return negative value.
    
    The problem has been detected using proposed semantic patch
    scripts/coccinelle/tests/assign_signed_to_unsigned.cocci [1].
    
    [1]: http://permalink.gmane.org/gmane.linux.kernel/2046107
    
    Signed-off-by: Andrzej Hajda <a.hajda@samsung.com>
    Signed-off-by: Chanwoo Choi <cw00.choi@samsung.com>

diff --git a/drivers/extcon/extcon-sm5502.c b/drivers/extcon/extcon-sm5502.c
index 92ae48415fb2..2945091bfd0e 100644
--- a/drivers/extcon/extcon-sm5502.c
+++ b/drivers/extcon/extcon-sm5502.c
@@ -586,7 +586,7 @@ static int sm5022_muic_i2c_probe(struct i2c_client *i2c,
 
 	for (i = 0; i < info->num_muic_irqs; i++) {
 		struct muic_irq *muic_irq = &info->muic_irqs[i];
-		unsigned int virq = 0;
+		int virq = 0;
 
 		virq = regmap_irq_get_virq(info->irq_data, muic_irq->irq);
 		if (virq <= 0)

commit ff612f9170eaa9ca7ade357b270f582b0c44ed70
Author: Javier Martinez Canillas <javier@osg.samsung.com>
Date:   Tue Aug 25 08:31:15 2015 +0200

    extcon: Export OF module alias information in missing drivers
    
    The I2C core always reports the MODALIAS uevent as "i2c:<modalias>"
    regardless of the mechanism that was used to register the device
    (i.e: OF or board code) and the table that is used later to match
    the driver with the device (i.e: I2C id table or OF match table).
    
    So drivers needs to export the I2C id table and this be built into
    the module or udev won't have the necessary information to autoload
    the needed driver module when the device is added.
    
    But this means that OF-only drivers needs to have both OF and I2C id
    tables that have to be kept in sync and also the dev node compatible
    manufacturer prefix is stripped when reporting the MODALIAS. Which can
    lead to issues if two vendors use the same I2C device name for example.
    
    To avoid the above, the I2C core behavior may be changed in the future
    to not require an SPI device table for OF-only drivers and report the
    OF module alias. So, it's better to also export the OF table even when
    is unused now to prevent breaking module loading when the core changes.
    
    Signed-off-by: Javier Martinez Canillas <javier@osg.samsung.com>
    Signed-off-by: Chanwoo Choi <cw00.choi@samsung.com>

diff --git a/drivers/extcon/extcon-sm5502.c b/drivers/extcon/extcon-sm5502.c
index 0ffefefa2e26..92ae48415fb2 100644
--- a/drivers/extcon/extcon-sm5502.c
+++ b/drivers/extcon/extcon-sm5502.c
@@ -650,6 +650,7 @@ static const struct of_device_id sm5502_dt_match[] = {
 	{ .compatible = "siliconmitus,sm5502-muic" },
 	{ },
 };
+MODULE_DEVICE_TABLE(of, sm5502_dt_match);
 
 #ifdef CONFIG_PM_SLEEP
 static int sm5502_muic_suspend(struct device *dev)

commit bef025a1f8e0e566f954613f4e5087f6b156e2a5
Author: Krzysztof Kozlowski <k.kozlowski@samsung.com>
Date:   Fri Jul 10 14:50:20 2015 +0900

    extcon: Drop owner assignment from i2c_driver
    
    i2c_driver does not need to set an owner because i2c_register_driver()
    will set it.
    
    Signed-off-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Signed-off-by: Chanwoo Choi <cw00.choi@samsung.com>

diff --git a/drivers/extcon/extcon-sm5502.c b/drivers/extcon/extcon-sm5502.c
index 817dece23b4c..0ffefefa2e26 100644
--- a/drivers/extcon/extcon-sm5502.c
+++ b/drivers/extcon/extcon-sm5502.c
@@ -685,7 +685,6 @@ MODULE_DEVICE_TABLE(i2c, sm5502_i2c_id);
 static struct i2c_driver sm5502_muic_i2c_driver = {
 	.driver		= {
 		.name	= "sm5502",
-		.owner	= THIS_MODULE,
 		.pm	= &sm5502_muic_pm_ops,
 		.of_match_table = sm5502_dt_match,
 	},

commit 73b6ecdb93e8e77752cae9077c424fcdc6f23c39
Author: Chanwoo Choi <cw00.choi@samsung.com>
Date:   Fri Jun 12 11:10:06 2015 +0900

    extcon: Redefine the unique id of supported external connectors without 'enum extcon' type
    
    This patch just redefine the unique id of supported external connectors without
    'enum extcon' type. Because unique id would be used on devictree file(*.dts) to
    indicate the specific external connectors like key number of input framework.
    So, I have the plan to move this definitions to following header file which
    includes the unique id of supported external connectors.
    - include/dt-bindings/extcon/extcon.h
    
    Fixes: 2a9de9c0f08d ("extcon: Use the unique id for external connector instead of string")
    Signed-off-by: Chanwoo Choi <cw00.choi@samsung.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/extcon/extcon-sm5502.c b/drivers/extcon/extcon-sm5502.c
index 520693d6fa8a..817dece23b4c 100644
--- a/drivers/extcon/extcon-sm5502.c
+++ b/drivers/extcon/extcon-sm5502.c
@@ -92,7 +92,7 @@ static struct reg_data sm5502_reg_data[] = {
 };
 
 /* List of detectable cables */
-static const enum extcon sm5502_extcon_cable[] = {
+static const unsigned int sm5502_extcon_cable[] = {
 	EXTCON_USB,
 	EXTCON_USB_HOST,
 	EXTCON_TA,
@@ -372,7 +372,7 @@ static int sm5502_muic_cable_handler(struct sm5502_muic_info *info,
 	unsigned int cable_type = SM5502_MUIC_ADC_GROUND;
 	unsigned int con_sw = DM_DP_SWITCH_OPEN;
 	unsigned int vbus_sw = VBUSIN_SWITCH_OPEN;
-	enum extcon id;
+	unsigned int id;
 	int ret;
 
 	/* Get the type of attached or detached cable */

commit 2a9de9c0f08d61fbe3764a21d22d0b72df97d6ae
Author: Chanwoo Choi <cw00.choi@samsung.com>
Date:   Fri Apr 24 19:16:05 2015 +0900

    extcon: Use the unique id for external connector instead of string
    
    This patch uses the unique id to identify the type of external connector instead
    of string name. The string name have the many potential issues. So, this patch
    defines the 'extcon' enumeration which includes all supported external connector
    on EXTCON subsystem. If new external connector is necessary, the unique id of
    new connector have to be added in 'extcon' enumeration. There are current
    supported external connector in 'enum extcon' as following:
    
    enum extcon {
            EXTCON_NONE             = 0x0,
    
            /* USB external connector */
            EXTCON_USB              = 0x1,
            EXTCON_USB_HOST         = 0x2,
    
            /* Charger external connector */
            EXTCON_TA               = 0x10,
            EXTCON_FAST_CHARGER     = 0x11,
            EXTCON_SLOW_CHARGER     = 0x12,
            EXTCON_CHARGE_DOWNSTREAM = 0x13,
    
            /* Audio and video external connector */
            EXTCON_LINE_IN          = 0x20,
            EXTCON_LINE_OUT         = 0x21,
            EXTCON_MICROPHONE       = 0x22,
            EXTCON_HEADPHONE        = 0x23,
    
            EXTCON_HDMI             = 0x30,
            EXTCON_MHL              = 0x31,
            EXTCON_DVI              = 0x32,
            EXTCON_VGA              = 0x33,
            EXTCON_SPDIF_IN         = 0x34,
            EXTCON_SPDIF_OUT        = 0x35,
            EXTCON_VIDEO_IN         = 0x36,
            EXTCON_VIDEO_OUT        = 0x37,
    
            /* Miscellaneous external connector */
            EXTCON_DOCK             = 0x50,
            EXTCON_JIG              = 0x51,
            EXTCON_MECHANICAL       = 0x52,
    
            EXTCON_END,
    };
    
    For example in extcon-arizona.c:
    To use unique id removes the potential issue about handling
    the inconsistent name of external connector with string.
    - Previously, use the string to register the type of arizona jack connector
    static const char *arizona_cable[] = {
            "Mechanical",
            "Microphone",
            "Headphone",
            "Line-out",
    };
    - Newly, use the unique id to register the type of arizona jack connector
    static const enum extcon arizona_cable[] = {
            EXTCON_MECHANICAL,
            EXTCON_MICROPHONE,
            EXTCON_HEADPHONE,
            EXTCON_LINE_OUT,
    
            EXTCON_NONE,
    };
    
    And this patch modify the prototype of extcon_{get|set}_cable_state_() which
    uses the 'enum extcon id' instead of 'cable_index'. Because although one more
    extcon drivers support USB cable, each extcon driver might has the differnt
    'cable_index' for USB cable. All extcon drivers can use the unique id number
    for same external connector with modified extcon_{get|set}_cable_state_().
    
    - Previously, use 'cable_index' on these functions:
    extcon_get_cable_state_(struct extcon_dev*, int cable_index)
    extcon_set_cable_state_(struct extcon_dev*, int cable_index, bool state)
    
    -Newly, use 'enum extcon id' on these functions:
    extcon_get_cable_state_(struct extcon_dev*, enum extcon id)
    extcon_set_cable_state_(struct extcon_dev*, enum extcon id, bool state)
    
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Chanwoo Choi <cw00.choi@samsung.com>
    Acked-by: Roger Quadros <rogerq@ti.com>
    Acked-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Acked-by: Ramakrishna Pallala <ramakrishna.pallala@intel.com>
    Reviewed-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    [arnd: Report the build break about drivers/usb/phy/phy-tahvo.c after using the
    unique id for external connector insteadf of string]
    Reported-by: Arnd Bergmann <arnd@arndb.de>
    [dan.carpenter: Report the build warning of extcon_{set|get}_cable_state_()]
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>

diff --git a/drivers/extcon/extcon-sm5502.c b/drivers/extcon/extcon-sm5502.c
index 6f1d11f8723b..520693d6fa8a 100644
--- a/drivers/extcon/extcon-sm5502.c
+++ b/drivers/extcon/extcon-sm5502.c
@@ -92,19 +92,11 @@ static struct reg_data sm5502_reg_data[] = {
 };
 
 /* List of detectable cables */
-enum {
-	EXTCON_CABLE_USB = 0,
-	EXTCON_CABLE_USB_HOST,
-	EXTCON_CABLE_TA,
-
-	EXTCON_CABLE_END,
-};
-
-static const char *sm5502_extcon_cable[] = {
-	[EXTCON_CABLE_USB]	= "USB",
-	[EXTCON_CABLE_USB_HOST]	= "USB-Host",
-	[EXTCON_CABLE_TA]	= "TA",
-	NULL,
+static const enum extcon sm5502_extcon_cable[] = {
+	EXTCON_USB,
+	EXTCON_USB_HOST,
+	EXTCON_TA,
+	EXTCON_NONE,
 };
 
 /* Define supported accessory type */
@@ -377,16 +369,12 @@ static int sm5502_muic_cable_handler(struct sm5502_muic_info *info,
 				     bool attached)
 {
 	static unsigned int prev_cable_type = SM5502_MUIC_ADC_GROUND;
-	const char **cable_names = info->edev->supported_cable;
 	unsigned int cable_type = SM5502_MUIC_ADC_GROUND;
 	unsigned int con_sw = DM_DP_SWITCH_OPEN;
 	unsigned int vbus_sw = VBUSIN_SWITCH_OPEN;
-	unsigned int idx = 0;
+	enum extcon id;
 	int ret;
 
-	if (!cable_names)
-		return 0;
-
 	/* Get the type of attached or detached cable */
 	if (attached)
 		cable_type = sm5502_muic_get_cable_type(info);
@@ -396,17 +384,17 @@ static int sm5502_muic_cable_handler(struct sm5502_muic_info *info,
 
 	switch (cable_type) {
 	case SM5502_MUIC_ADC_OPEN_USB:
-		idx	= EXTCON_CABLE_USB;
+		id	= EXTCON_USB;
 		con_sw	= DM_DP_SWITCH_USB;
 		vbus_sw	= VBUSIN_SWITCH_VBUSOUT_WITH_USB;
 		break;
 	case SM5502_MUIC_ADC_OPEN_TA:
-		idx	= EXTCON_CABLE_TA;
+		id	= EXTCON_TA;
 		con_sw	= DM_DP_SWITCH_OPEN;
 		vbus_sw	= VBUSIN_SWITCH_VBUSOUT;
 		break;
 	case SM5502_MUIC_ADC_OPEN_USB_OTG:
-		idx	= EXTCON_CABLE_USB_HOST;
+		id	= EXTCON_USB_HOST;
 		con_sw	= DM_DP_SWITCH_USB;
 		vbus_sw	= VBUSIN_SWITCH_OPEN;
 		break;
@@ -422,7 +410,7 @@ static int sm5502_muic_cable_handler(struct sm5502_muic_info *info,
 		return ret;
 
 	/* Change the state of external accessory */
-	extcon_set_cable_state(info->edev, cable_names[idx], attached);
+	extcon_set_cable_state_(info->edev, id, attached);
 
 	return 0;
 }

commit d71aadda19f83521eca301cb154b81a7bcca78a2
Author: Chanwoo Choi <cw00.choi@samsung.com>
Date:   Mon May 4 20:20:27 2015 +0900

    extcon: Remove the optional name of extcon device
    
    This patch removes the optional name of extcon device. Instead,
    extcon_dev_register() set the device name as 'extcon[number]' naming pattern.
    - /sys/class/extcon/[hardcoded device name] -> /sys/class/extcon/extcon[number]
    
    Signed-off-by: Chanwoo Choi <cw00.choi@samsung.com>
    Acked-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Cc: MyungJoo Ham <myungjoo.ham@samsung.com>
    Cc: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Cc: Graeme Gregory <gg@slimlogic.co.uk>
    Cc: Kishon Vijay Abraham I <kishon@ti.com>
    Cc: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Cc: Jaewon Kim <jaewon02.kim@samsung.com>

diff --git a/drivers/extcon/extcon-sm5502.c b/drivers/extcon/extcon-sm5502.c
index 2f93cf307852..6f1d11f8723b 100644
--- a/drivers/extcon/extcon-sm5502.c
+++ b/drivers/extcon/extcon-sm5502.c
@@ -623,7 +623,6 @@ static int sm5022_muic_i2c_probe(struct i2c_client *i2c,
 		dev_err(info->dev, "failed to allocate memory for extcon\n");
 		return -ENOMEM;
 	}
-	info->edev->name = np->name;
 
 	/* Register extcon device */
 	ret = devm_extcon_dev_register(info->dev, info->edev);

commit 34825e511971e193db16a96350faeb60eff0d842
Author: Chanwoo Choi <cw00.choi@samsung.com>
Date:   Sat Mar 7 01:41:36 2015 +0900

    extcon: Fix the checkpatch warning
    
    This patch fixes the checkpatch warning about coding style.
    
    Signed-off-by: Chanwoo Choi <cw00.choi@samsung.com>

diff --git a/drivers/extcon/extcon-sm5502.c b/drivers/extcon/extcon-sm5502.c
index b0f7bd82af90..2f93cf307852 100644
--- a/drivers/extcon/extcon-sm5502.c
+++ b/drivers/extcon/extcon-sm5502.c
@@ -359,8 +359,8 @@ static unsigned int sm5502_muic_get_cable_type(struct sm5502_muic_info *info)
 			break;
 		default:
 			dev_dbg(info->dev,
-				"cannot identify the cable type: adc(0x%x) "
-				"dev_type1(0x%x)\n", adc, dev_type1);
+				"cannot identify the cable type: adc(0x%x)\n",
+				adc);
 			return -EINVAL;
 		};
 		break;
@@ -659,7 +659,7 @@ static int sm5502_muic_i2c_remove(struct i2c_client *i2c)
 	return 0;
 }
 
-static struct of_device_id sm5502_dt_match[] = {
+static const struct of_device_id sm5502_dt_match[] = {
 	{ .compatible = "siliconmitus,sm5502-muic" },
 	{ },
 };

commit b7c7e0865944131820e1a65ff3b08d94ae553d0f
Author: Jean Delvare <jdelvare@suse.de>
Date:   Tue Sep 16 23:16:15 2014 +0200

    extcon: sm5502: Drop useless include
    
    Don't include <linux/input.h> when the driver does not use anything
    from this header file.
    
    Signed-off-by: Jean Delvare <jdelvare@suse.de>
    Acked-by: MyungJoo Ham <myungjoo.ham@samsung.com>
    Signed-off-by: Chanwoo Choi <cw00.choi@samsung.com>
    Cc: Chanwoo Choi <cw00.choi@samsung.com>
    Cc: MyungJoo Ham <myungjoo.ham@samsung.com>

diff --git a/drivers/extcon/extcon-sm5502.c b/drivers/extcon/extcon-sm5502.c
index 8e6e66942d61..b0f7bd82af90 100644
--- a/drivers/extcon/extcon-sm5502.c
+++ b/drivers/extcon/extcon-sm5502.c
@@ -12,7 +12,6 @@
 
 #include <linux/err.h>
 #include <linux/i2c.h>
-#include <linux/input.h>
 #include <linux/interrupt.h>
 #include <linux/irqdomain.h>
 #include <linux/kernel.h>

commit fbae30d8dd35454bd4a55445d1bb51c620f8e646
Author: Chanwoo Choi <cw00.choi@samsung.com>
Date:   Tue Aug 12 10:15:39 2014 +0900

    extcon: sm5502: Clean up codes by using checkpatch script
    
    This patch just clean up codes by using checkpatch script and fix warning
    message about if statement.
    
    - the result of checkpatch script as following:
    WARNING: void function return statements are not generally useful
    +       return;
    +}
    
    WARNING: quoted string split across lines
    +                       dev_err(info->dev, "failed: irq request (IRQ: %d,"
    +                               " error :%d)\n", muic_irq->irq, ret);
    
    - warning message about coding style.
    
            drivers/extcon/extcon-sm5502.c:398 sm5502_muic_cable_handler()
                    warn: we tested 'attached' before and it was 'false'
    
    Signed-off-by: Chanwoo Choi <cw00.choi@samsung.com>

diff --git a/drivers/extcon/extcon-sm5502.c b/drivers/extcon/extcon-sm5502.c
index f94d66aae9e3..8e6e66942d61 100644
--- a/drivers/extcon/extcon-sm5502.c
+++ b/drivers/extcon/extcon-sm5502.c
@@ -391,7 +391,7 @@ static int sm5502_muic_cable_handler(struct sm5502_muic_info *info,
 	/* Get the type of attached or detached cable */
 	if (attached)
 		cable_type = sm5502_muic_get_cable_type(info);
-	else if (!attached)
+	else
 		cable_type = prev_cable_type;
 	prev_cable_type = cable_type;
 
@@ -453,8 +453,6 @@ static void sm5502_muic_irq_work(struct work_struct *work)
 		dev_err(info->dev, "failed to handle MUIC interrupt\n");
 
 	mutex_unlock(&info->mutex);
-
-	return;
 }
 
 /*
@@ -613,8 +611,9 @@ static int sm5022_muic_i2c_probe(struct i2c_client *i2c,
 						IRQF_NO_SUSPEND,
 						muic_irq->name, info);
 		if (ret) {
-			dev_err(info->dev, "failed: irq request (IRQ: %d,"
-				" error :%d)\n", muic_irq->irq, ret);
+			dev_err(info->dev,
+				"failed: irq request (IRQ: %d, error :%d)\n",
+				muic_irq->irq, ret);
 			return ret;
 		}
 	}

commit ca2a07e45d1d3d31a0a85d2f63d81a897c610040
Author: Chanwoo Choi <cw00.choi@samsung.com>
Date:   Thu Jul 31 16:32:46 2014 +0900

    extcon: sm5502: Move sm5502.h header file to extcon directory
    
    This patch move sm5502.h header file from 'include/linux/extcon' to
    'driver/extcon' because sm5502.h is used for driver/extcon/extcon-sm5502.c.
    and remove duplicate license description.
    
    Signed-off-by: Chanwoo Choi <cw00.choi@samsung.com>

diff --git a/drivers/extcon/extcon-sm5502.c b/drivers/extcon/extcon-sm5502.c
index a1ba9242e9cb..f94d66aae9e3 100644
--- a/drivers/extcon/extcon-sm5502.c
+++ b/drivers/extcon/extcon-sm5502.c
@@ -8,11 +8,6 @@
  * under  the terms of  the GNU General  Public License as published by the
  * Free Software Foundation;  either version 2 of the  License, or (at your
  * option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
  */
 
 #include <linux/err.h>
@@ -26,7 +21,8 @@
 #include <linux/regmap.h>
 #include <linux/slab.h>
 #include <linux/extcon.h>
-#include <linux/extcon/sm5502.h>
+
+#include "extcon-sm5502.h"
 
 #define	DELAY_MS_DEFAULT		17000	/* unit: millisecond */
 

commit 0ccc7955acc19e7f4515e51993b7b95cf5a35fdc
Author: Chanwoo Choi <cw00.choi@samsung.com>
Date:   Wed Jul 30 15:39:02 2014 +0900

    extcon: sm5502: Fix bug to check cable type
    
    This patch fix bug when checking cable type. SM5502 have to use ADC value
    to get correct cable type.
    
    Signed-off-by: Chanwoo Choi <cw00.choi@samsung.com>

diff --git a/drivers/extcon/extcon-sm5502.c b/drivers/extcon/extcon-sm5502.c
index 560d7dccec7b..a1ba9242e9cb 100644
--- a/drivers/extcon/extcon-sm5502.c
+++ b/drivers/extcon/extcon-sm5502.c
@@ -300,7 +300,7 @@ static unsigned int sm5502_muic_get_cable_type(struct sm5502_muic_info *info)
 	 * If ADC is SM5502_MUIC_ADC_GROUND(0x0), external cable hasn't
 	 * connected with to MUIC device.
 	 */
-	cable_type &= SM5502_REG_ADC_MASK;
+	cable_type = adc & SM5502_REG_ADC_MASK;
 	if (cable_type == SM5502_MUIC_ADC_GROUND)
 		return SM5502_MUIC_ADC_GROUND;
 

commit a75fed2ee6c187ab32b1cb01882c1032c4c9e4a8
Author: Chanwoo Choi <cw00.choi@samsung.com>
Date:   Wed May 28 15:35:29 2014 +0900

    extcon: sm5502: Change internal hardware switch according to cable type
    
    This patch changes internal hardware DP_CON/DM_CON switch according to
    cable type. The SM5502 MUIC device can set hardware switch as following:
    - OPEN (not connected state) / USB / UART / AUDIO
    Also, this patch set VBUSIN switch according to cable type.
    
    Signed-off-by: Chanwoo Choi <cw00.choi@samsung.com>

diff --git a/drivers/extcon/extcon-sm5502.c b/drivers/extcon/extcon-sm5502.c
index a32d40f97ff0..560d7dccec7b 100644
--- a/drivers/extcon/extcon-sm5502.c
+++ b/drivers/extcon/extcon-sm5502.c
@@ -228,6 +228,61 @@ static const struct regmap_config sm5502_muic_regmap_config = {
 	.max_register	= SM5502_REG_END,
 };
 
+/* Change DM_CON/DP_CON/VBUSIN switch according to cable type */
+static int sm5502_muic_set_path(struct sm5502_muic_info *info,
+				unsigned int con_sw, unsigned int vbus_sw,
+				bool attached)
+{
+	int ret;
+
+	if (!attached) {
+		con_sw	= DM_DP_SWITCH_OPEN;
+		vbus_sw	= VBUSIN_SWITCH_OPEN;
+	}
+
+	switch (con_sw) {
+	case DM_DP_SWITCH_OPEN:
+	case DM_DP_SWITCH_USB:
+	case DM_DP_SWITCH_AUDIO:
+	case DM_DP_SWITCH_UART:
+		ret = regmap_update_bits(info->regmap, SM5502_REG_MANUAL_SW1,
+					 SM5502_REG_MANUAL_SW1_DP_MASK |
+					 SM5502_REG_MANUAL_SW1_DM_MASK,
+					 con_sw);
+		if (ret < 0) {
+			dev_err(info->dev,
+				"cannot update DM_CON/DP_CON switch\n");
+			return ret;
+		}
+		break;
+	default:
+		dev_err(info->dev, "Unknown DM_CON/DP_CON switch type (%d)\n",
+				con_sw);
+		return -EINVAL;
+	};
+
+	switch (vbus_sw) {
+	case VBUSIN_SWITCH_OPEN:
+	case VBUSIN_SWITCH_VBUSOUT:
+	case VBUSIN_SWITCH_MIC:
+	case VBUSIN_SWITCH_VBUSOUT_WITH_USB:
+		ret = regmap_update_bits(info->regmap, SM5502_REG_MANUAL_SW1,
+					 SM5502_REG_MANUAL_SW1_VBUSIN_MASK,
+					 vbus_sw);
+		if (ret < 0) {
+			dev_err(info->dev,
+				"cannot update VBUSIN switch\n");
+			return ret;
+		}
+		break;
+	default:
+		dev_err(info->dev, "Unknown VBUS switch type (%d)\n", vbus_sw);
+		return -EINVAL;
+	};
+
+	return 0;
+}
+
 /* Return cable type of attached or detached accessories */
 static unsigned int sm5502_muic_get_cable_type(struct sm5502_muic_info *info)
 {
@@ -329,7 +384,10 @@ static int sm5502_muic_cable_handler(struct sm5502_muic_info *info,
 	static unsigned int prev_cable_type = SM5502_MUIC_ADC_GROUND;
 	const char **cable_names = info->edev->supported_cable;
 	unsigned int cable_type = SM5502_MUIC_ADC_GROUND;
+	unsigned int con_sw = DM_DP_SWITCH_OPEN;
+	unsigned int vbus_sw = VBUSIN_SWITCH_OPEN;
 	unsigned int idx = 0;
+	int ret;
 
 	if (!cable_names)
 		return 0;
@@ -343,15 +401,19 @@ static int sm5502_muic_cable_handler(struct sm5502_muic_info *info,
 
 	switch (cable_type) {
 	case SM5502_MUIC_ADC_OPEN_USB:
-		idx = EXTCON_CABLE_USB;
+		idx	= EXTCON_CABLE_USB;
+		con_sw	= DM_DP_SWITCH_USB;
+		vbus_sw	= VBUSIN_SWITCH_VBUSOUT_WITH_USB;
 		break;
 	case SM5502_MUIC_ADC_OPEN_TA:
-		idx = EXTCON_CABLE_TA;
+		idx	= EXTCON_CABLE_TA;
+		con_sw	= DM_DP_SWITCH_OPEN;
+		vbus_sw	= VBUSIN_SWITCH_VBUSOUT;
 		break;
 	case SM5502_MUIC_ADC_OPEN_USB_OTG:
-		idx = EXTCON_CABLE_USB_HOST;
-		break;
-	case SM5502_MUIC_ADC_GROUND:
+		idx	= EXTCON_CABLE_USB_HOST;
+		con_sw	= DM_DP_SWITCH_USB;
+		vbus_sw	= VBUSIN_SWITCH_OPEN;
 		break;
 	default:
 		dev_dbg(info->dev,
@@ -359,6 +421,12 @@ static int sm5502_muic_cable_handler(struct sm5502_muic_info *info,
 		return 0;
 	};
 
+	/* Change internal hardware path(DM_CON/DP_CON, VBUSIN) */
+	ret = sm5502_muic_set_path(info, con_sw, vbus_sw, attached);
+	if (ret < 0)
+		return ret;
+
+	/* Change the state of external accessory */
 	extcon_set_cable_state(info->edev, cable_names[idx], attached);
 
 	return 0;

commit e1954452f500cb21c09ea401f6f431ab55b35ba3
Author: Chanwoo Choi <cw00.choi@samsung.com>
Date:   Wed May 28 14:21:55 2014 +0900

    extcon: sm5502: Detect cable state after completing platform booting
    
    This patch detect whether cable is connected or not and the cable type
    after completing kernel/platform booting using system_power_efficient_wq.
    
    Signed-off-by: Chanwoo Choi <cw00.choi@samsung.com>

diff --git a/drivers/extcon/extcon-sm5502.c b/drivers/extcon/extcon-sm5502.c
index 9f318c222b89..a32d40f97ff0 100644
--- a/drivers/extcon/extcon-sm5502.c
+++ b/drivers/extcon/extcon-sm5502.c
@@ -28,6 +28,8 @@
 #include <linux/extcon.h>
 #include <linux/extcon/sm5502.h>
 
+#define	DELAY_MS_DEFAULT		17000	/* unit: millisecond */
+
 struct muic_irq {
 	unsigned int irq;
 	const char *name;
@@ -59,6 +61,14 @@ struct sm5502_muic_info {
 	unsigned int num_reg_data;
 
 	struct mutex mutex;
+
+	/*
+	 * Use delayed workqueue to detect cable state and then
+	 * notify cable state to notifiee/platform through uevent.
+	 * After completing the booting of platform, the extcon provider
+	 * driver should notify cable state to upper layer.
+	 */
+	struct delayed_work wq_detcable;
 };
 
 /* Default value of SM5502 register to bring up MUIC device. */
@@ -341,6 +351,8 @@ static int sm5502_muic_cable_handler(struct sm5502_muic_info *info,
 	case SM5502_MUIC_ADC_OPEN_USB_OTG:
 		idx = EXTCON_CABLE_USB_HOST;
 		break;
+	case SM5502_MUIC_ADC_GROUND:
+		break;
 	default:
 		dev_dbg(info->dev,
 			"cannot handle this cable_type (0x%x)\n", cable_type);
@@ -433,6 +445,18 @@ static irqreturn_t sm5502_muic_irq_handler(int irq, void *data)
 	return IRQ_HANDLED;
 }
 
+static void sm5502_muic_detect_cable_wq(struct work_struct *work)
+{
+	struct sm5502_muic_info *info = container_of(to_delayed_work(work),
+				struct sm5502_muic_info, wq_detcable);
+	int ret;
+
+	/* Notify the state of connector cable or not  */
+	ret = sm5502_muic_cable_handler(info, true);
+	if (ret < 0)
+		dev_warn(info->dev, "failed to detect cable state\n");
+}
+
 static void sm5502_init_dev_type(struct sm5502_muic_info *info)
 {
 	unsigned int reg_data, vendor_id, version_id;
@@ -546,6 +570,18 @@ static int sm5022_muic_i2c_probe(struct i2c_client *i2c,
 		return ret;
 	}
 
+	/*
+	 * Detect accessory after completing the initialization of platform
+	 *
+	 * - Use delayed workqueue to detect cable state and then
+	 * notify cable state to notifiee/platform through uevent.
+	 * After completing the booting of platform, the extcon provider
+	 * driver should notify cable state to upper layer.
+	 */
+	INIT_DELAYED_WORK(&info->wq_detcable, sm5502_muic_detect_cable_wq);
+	queue_delayed_work(system_power_efficient_wq, &info->wq_detcable,
+			msecs_to_jiffies(DELAY_MS_DEFAULT));
+
 	/* Initialize SM5502 device and print vendor id and version id */
 	sm5502_init_dev_type(info);
 

commit 914b881f9452fd615cc597b434fd8c0e12a7dae2
Author: Chanwoo Choi <cw00.choi@samsung.com>
Date:   Thu May 22 14:06:33 2014 +0900

    extcon: sm5502: Add support new SM5502 extcon device driver
    
    This patch add new SM5502 MUIC(Micro-USB Interface Controller) device by using
    EXTCON subsystem. The extcon-sm5502 driver is capable of identifying the type
    of the external power source and attached accessory. An external power sources,
    such as Deticated Charger or a standard USB port, are able to charge the battery
    in the smart phone via the connector.
    
    Signed-off-by: Chanwoo Choi <cw00.choi@samsung.com>

diff --git a/drivers/extcon/extcon-sm5502.c b/drivers/extcon/extcon-sm5502.c
new file mode 100644
index 000000000000..9f318c222b89
--- /dev/null
+++ b/drivers/extcon/extcon-sm5502.c
@@ -0,0 +1,620 @@
+/*
+ * extcon-sm5502.c - Silicon Mitus SM5502 extcon drvier to support USB switches
+ *
+ * Copyright (c) 2014 Samsung Electronics Co., Ltd
+ * Author: Chanwoo Choi <cw00.choi@samsung.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/err.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/irqdomain.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/regmap.h>
+#include <linux/slab.h>
+#include <linux/extcon.h>
+#include <linux/extcon/sm5502.h>
+
+struct muic_irq {
+	unsigned int irq;
+	const char *name;
+	unsigned int virq;
+};
+
+struct reg_data {
+	u8 reg;
+	unsigned int val;
+	bool invert;
+};
+
+struct sm5502_muic_info {
+	struct device *dev;
+	struct extcon_dev *edev;
+
+	struct i2c_client *i2c;
+	struct regmap *regmap;
+
+	struct regmap_irq_chip_data *irq_data;
+	struct muic_irq *muic_irqs;
+	unsigned int num_muic_irqs;
+	int irq;
+	bool irq_attach;
+	bool irq_detach;
+	struct work_struct irq_work;
+
+	struct reg_data *reg_data;
+	unsigned int num_reg_data;
+
+	struct mutex mutex;
+};
+
+/* Default value of SM5502 register to bring up MUIC device. */
+static struct reg_data sm5502_reg_data[] = {
+	{
+		.reg = SM5502_REG_CONTROL,
+		.val = SM5502_REG_CONTROL_MASK_INT_MASK,
+		.invert = false,
+	}, {
+		.reg = SM5502_REG_INTMASK1,
+		.val = SM5502_REG_INTM1_KP_MASK
+			| SM5502_REG_INTM1_LKP_MASK
+			| SM5502_REG_INTM1_LKR_MASK,
+		.invert = true,
+	}, {
+		.reg = SM5502_REG_INTMASK2,
+		.val = SM5502_REG_INTM2_VBUS_DET_MASK
+			| SM5502_REG_INTM2_REV_ACCE_MASK
+			| SM5502_REG_INTM2_ADC_CHG_MASK
+			| SM5502_REG_INTM2_STUCK_KEY_MASK
+			| SM5502_REG_INTM2_STUCK_KEY_RCV_MASK
+			| SM5502_REG_INTM2_MHL_MASK,
+		.invert = true,
+	},
+	{ }
+};
+
+/* List of detectable cables */
+enum {
+	EXTCON_CABLE_USB = 0,
+	EXTCON_CABLE_USB_HOST,
+	EXTCON_CABLE_TA,
+
+	EXTCON_CABLE_END,
+};
+
+static const char *sm5502_extcon_cable[] = {
+	[EXTCON_CABLE_USB]	= "USB",
+	[EXTCON_CABLE_USB_HOST]	= "USB-Host",
+	[EXTCON_CABLE_TA]	= "TA",
+	NULL,
+};
+
+/* Define supported accessory type */
+enum sm5502_muic_acc_type {
+	SM5502_MUIC_ADC_GROUND = 0x0,
+	SM5502_MUIC_ADC_SEND_END_BUTTON,
+	SM5502_MUIC_ADC_REMOTE_S1_BUTTON,
+	SM5502_MUIC_ADC_REMOTE_S2_BUTTON,
+	SM5502_MUIC_ADC_REMOTE_S3_BUTTON,
+	SM5502_MUIC_ADC_REMOTE_S4_BUTTON,
+	SM5502_MUIC_ADC_REMOTE_S5_BUTTON,
+	SM5502_MUIC_ADC_REMOTE_S6_BUTTON,
+	SM5502_MUIC_ADC_REMOTE_S7_BUTTON,
+	SM5502_MUIC_ADC_REMOTE_S8_BUTTON,
+	SM5502_MUIC_ADC_REMOTE_S9_BUTTON,
+	SM5502_MUIC_ADC_REMOTE_S10_BUTTON,
+	SM5502_MUIC_ADC_REMOTE_S11_BUTTON,
+	SM5502_MUIC_ADC_REMOTE_S12_BUTTON,
+	SM5502_MUIC_ADC_RESERVED_ACC_1,
+	SM5502_MUIC_ADC_RESERVED_ACC_2,
+	SM5502_MUIC_ADC_RESERVED_ACC_3,
+	SM5502_MUIC_ADC_RESERVED_ACC_4,
+	SM5502_MUIC_ADC_RESERVED_ACC_5,
+	SM5502_MUIC_ADC_AUDIO_TYPE2,
+	SM5502_MUIC_ADC_PHONE_POWERED_DEV,
+	SM5502_MUIC_ADC_TTY_CONVERTER,
+	SM5502_MUIC_ADC_UART_CABLE,
+	SM5502_MUIC_ADC_TYPE1_CHARGER,
+	SM5502_MUIC_ADC_FACTORY_MODE_BOOT_OFF_USB,
+	SM5502_MUIC_ADC_FACTORY_MODE_BOOT_ON_USB,
+	SM5502_MUIC_ADC_AUDIO_VIDEO_CABLE,
+	SM5502_MUIC_ADC_TYPE2_CHARGER,
+	SM5502_MUIC_ADC_FACTORY_MODE_BOOT_OFF_UART,
+	SM5502_MUIC_ADC_FACTORY_MODE_BOOT_ON_UART,
+	SM5502_MUIC_ADC_AUDIO_TYPE1,
+	SM5502_MUIC_ADC_OPEN = 0x1f,
+
+	/* The below accessories have same ADC value (0x1f or 0x1e).
+	   So, Device type1 is used to separate specific accessory. */
+							/* |---------|--ADC| */
+							/* |    [7:5]|[4:0]| */
+	SM5502_MUIC_ADC_AUDIO_TYPE1_FULL_REMOTE = 0x3e,	/* |      001|11110| */
+	SM5502_MUIC_ADC_AUDIO_TYPE1_SEND_END = 0x5e,	/* |      010|11110| */
+							/* |Dev Type1|--ADC| */
+	SM5502_MUIC_ADC_OPEN_USB = 0x5f,		/* |      010|11111| */
+	SM5502_MUIC_ADC_OPEN_TA = 0xdf,			/* |      110|11111| */
+	SM5502_MUIC_ADC_OPEN_USB_OTG = 0xff,		/* |      111|11111| */
+};
+
+/* List of supported interrupt for SM5502 */
+static struct muic_irq sm5502_muic_irqs[] = {
+	{ SM5502_IRQ_INT1_ATTACH,	"muic-attach" },
+	{ SM5502_IRQ_INT1_DETACH,	"muic-detach" },
+	{ SM5502_IRQ_INT1_KP,		"muic-kp" },
+	{ SM5502_IRQ_INT1_LKP,		"muic-lkp" },
+	{ SM5502_IRQ_INT1_LKR,		"muic-lkr" },
+	{ SM5502_IRQ_INT1_OVP_EVENT,	"muic-ovp-event" },
+	{ SM5502_IRQ_INT1_OCP_EVENT,	"muic-ocp-event" },
+	{ SM5502_IRQ_INT1_OVP_OCP_DIS,	"muic-ovp-ocp-dis" },
+	{ SM5502_IRQ_INT2_VBUS_DET,	"muic-vbus-det" },
+	{ SM5502_IRQ_INT2_REV_ACCE,	"muic-rev-acce" },
+	{ SM5502_IRQ_INT2_ADC_CHG,	"muic-adc-chg" },
+	{ SM5502_IRQ_INT2_STUCK_KEY,	"muic-stuck-key" },
+	{ SM5502_IRQ_INT2_STUCK_KEY_RCV, "muic-stuck-key-rcv" },
+	{ SM5502_IRQ_INT2_MHL,		"muic-mhl" },
+};
+
+/* Define interrupt list of SM5502 to register regmap_irq */
+static const struct regmap_irq sm5502_irqs[] = {
+	/* INT1 interrupts */
+	{ .reg_offset = 0, .mask = SM5502_IRQ_INT1_ATTACH_MASK, },
+	{ .reg_offset = 0, .mask = SM5502_IRQ_INT1_DETACH_MASK, },
+	{ .reg_offset = 0, .mask = SM5502_IRQ_INT1_KP_MASK, },
+	{ .reg_offset = 0, .mask = SM5502_IRQ_INT1_LKP_MASK, },
+	{ .reg_offset = 0, .mask = SM5502_IRQ_INT1_LKR_MASK, },
+	{ .reg_offset = 0, .mask = SM5502_IRQ_INT1_OVP_EVENT_MASK, },
+	{ .reg_offset = 0, .mask = SM5502_IRQ_INT1_OCP_EVENT_MASK, },
+	{ .reg_offset = 0, .mask = SM5502_IRQ_INT1_OVP_OCP_DIS_MASK, },
+
+	/* INT2 interrupts */
+	{ .reg_offset = 1, .mask = SM5502_IRQ_INT2_VBUS_DET_MASK,},
+	{ .reg_offset = 1, .mask = SM5502_IRQ_INT2_REV_ACCE_MASK, },
+	{ .reg_offset = 1, .mask = SM5502_IRQ_INT2_ADC_CHG_MASK, },
+	{ .reg_offset = 1, .mask = SM5502_IRQ_INT2_STUCK_KEY_MASK, },
+	{ .reg_offset = 1, .mask = SM5502_IRQ_INT2_STUCK_KEY_RCV_MASK, },
+	{ .reg_offset = 1, .mask = SM5502_IRQ_INT2_MHL_MASK, },
+};
+
+static const struct regmap_irq_chip sm5502_muic_irq_chip = {
+	.name			= "sm5502",
+	.status_base		= SM5502_REG_INT1,
+	.mask_base		= SM5502_REG_INTMASK1,
+	.mask_invert		= false,
+	.num_regs		= 2,
+	.irqs			= sm5502_irqs,
+	.num_irqs		= ARRAY_SIZE(sm5502_irqs),
+};
+
+/* Define regmap configuration of SM5502 for I2C communication  */
+static bool sm5502_muic_volatile_reg(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case SM5502_REG_INTMASK1:
+	case SM5502_REG_INTMASK2:
+		return true;
+	default:
+		break;
+	}
+	return false;
+}
+
+static const struct regmap_config sm5502_muic_regmap_config = {
+	.reg_bits	= 8,
+	.val_bits	= 8,
+	.volatile_reg	= sm5502_muic_volatile_reg,
+	.max_register	= SM5502_REG_END,
+};
+
+/* Return cable type of attached or detached accessories */
+static unsigned int sm5502_muic_get_cable_type(struct sm5502_muic_info *info)
+{
+	unsigned int cable_type = -1, adc, dev_type1;
+	int ret;
+
+	/* Read ADC value according to external cable or button */
+	ret = regmap_read(info->regmap, SM5502_REG_ADC, &adc);
+	if (ret) {
+		dev_err(info->dev, "failed to read ADC register\n");
+		return ret;
+	}
+
+	/*
+	 * If ADC is SM5502_MUIC_ADC_GROUND(0x0), external cable hasn't
+	 * connected with to MUIC device.
+	 */
+	cable_type &= SM5502_REG_ADC_MASK;
+	if (cable_type == SM5502_MUIC_ADC_GROUND)
+		return SM5502_MUIC_ADC_GROUND;
+
+	switch (cable_type) {
+	case SM5502_MUIC_ADC_GROUND:
+	case SM5502_MUIC_ADC_SEND_END_BUTTON:
+	case SM5502_MUIC_ADC_REMOTE_S1_BUTTON:
+	case SM5502_MUIC_ADC_REMOTE_S2_BUTTON:
+	case SM5502_MUIC_ADC_REMOTE_S3_BUTTON:
+	case SM5502_MUIC_ADC_REMOTE_S4_BUTTON:
+	case SM5502_MUIC_ADC_REMOTE_S5_BUTTON:
+	case SM5502_MUIC_ADC_REMOTE_S6_BUTTON:
+	case SM5502_MUIC_ADC_REMOTE_S7_BUTTON:
+	case SM5502_MUIC_ADC_REMOTE_S8_BUTTON:
+	case SM5502_MUIC_ADC_REMOTE_S9_BUTTON:
+	case SM5502_MUIC_ADC_REMOTE_S10_BUTTON:
+	case SM5502_MUIC_ADC_REMOTE_S11_BUTTON:
+	case SM5502_MUIC_ADC_REMOTE_S12_BUTTON:
+	case SM5502_MUIC_ADC_RESERVED_ACC_1:
+	case SM5502_MUIC_ADC_RESERVED_ACC_2:
+	case SM5502_MUIC_ADC_RESERVED_ACC_3:
+	case SM5502_MUIC_ADC_RESERVED_ACC_4:
+	case SM5502_MUIC_ADC_RESERVED_ACC_5:
+	case SM5502_MUIC_ADC_AUDIO_TYPE2:
+	case SM5502_MUIC_ADC_PHONE_POWERED_DEV:
+	case SM5502_MUIC_ADC_TTY_CONVERTER:
+	case SM5502_MUIC_ADC_UART_CABLE:
+	case SM5502_MUIC_ADC_TYPE1_CHARGER:
+	case SM5502_MUIC_ADC_FACTORY_MODE_BOOT_OFF_USB:
+	case SM5502_MUIC_ADC_FACTORY_MODE_BOOT_ON_USB:
+	case SM5502_MUIC_ADC_AUDIO_VIDEO_CABLE:
+	case SM5502_MUIC_ADC_TYPE2_CHARGER:
+	case SM5502_MUIC_ADC_FACTORY_MODE_BOOT_OFF_UART:
+	case SM5502_MUIC_ADC_FACTORY_MODE_BOOT_ON_UART:
+		break;
+	case SM5502_MUIC_ADC_AUDIO_TYPE1:
+		/*
+		 * Check whether cable type is
+		 * SM5502_MUIC_ADC_AUDIO_TYPE1_FULL_REMOTE
+		 * or SM5502_MUIC_ADC_AUDIO_TYPE1_SEND_END
+		 * by using Button event.
+		 */
+		break;
+	case SM5502_MUIC_ADC_OPEN:
+		ret = regmap_read(info->regmap, SM5502_REG_DEV_TYPE1,
+				  &dev_type1);
+		if (ret) {
+			dev_err(info->dev, "failed to read DEV_TYPE1 reg\n");
+			return ret;
+		}
+
+		switch (dev_type1) {
+		case SM5502_REG_DEV_TYPE1_USB_SDP_MASK:
+			cable_type = SM5502_MUIC_ADC_OPEN_USB;
+			break;
+		case SM5502_REG_DEV_TYPE1_DEDICATED_CHG_MASK:
+			cable_type = SM5502_MUIC_ADC_OPEN_TA;
+			break;
+		case SM5502_REG_DEV_TYPE1_USB_OTG_MASK:
+			cable_type = SM5502_MUIC_ADC_OPEN_USB_OTG;
+			break;
+		default:
+			dev_dbg(info->dev,
+				"cannot identify the cable type: adc(0x%x) "
+				"dev_type1(0x%x)\n", adc, dev_type1);
+			return -EINVAL;
+		};
+		break;
+	default:
+		dev_err(info->dev,
+			"failed to identify the cable type: adc(0x%x)\n", adc);
+		return -EINVAL;
+	};
+
+	return cable_type;
+}
+
+static int sm5502_muic_cable_handler(struct sm5502_muic_info *info,
+				     bool attached)
+{
+	static unsigned int prev_cable_type = SM5502_MUIC_ADC_GROUND;
+	const char **cable_names = info->edev->supported_cable;
+	unsigned int cable_type = SM5502_MUIC_ADC_GROUND;
+	unsigned int idx = 0;
+
+	if (!cable_names)
+		return 0;
+
+	/* Get the type of attached or detached cable */
+	if (attached)
+		cable_type = sm5502_muic_get_cable_type(info);
+	else if (!attached)
+		cable_type = prev_cable_type;
+	prev_cable_type = cable_type;
+
+	switch (cable_type) {
+	case SM5502_MUIC_ADC_OPEN_USB:
+		idx = EXTCON_CABLE_USB;
+		break;
+	case SM5502_MUIC_ADC_OPEN_TA:
+		idx = EXTCON_CABLE_TA;
+		break;
+	case SM5502_MUIC_ADC_OPEN_USB_OTG:
+		idx = EXTCON_CABLE_USB_HOST;
+		break;
+	default:
+		dev_dbg(info->dev,
+			"cannot handle this cable_type (0x%x)\n", cable_type);
+		return 0;
+	};
+
+	extcon_set_cable_state(info->edev, cable_names[idx], attached);
+
+	return 0;
+}
+
+static void sm5502_muic_irq_work(struct work_struct *work)
+{
+	struct sm5502_muic_info *info = container_of(work,
+			struct sm5502_muic_info, irq_work);
+	int ret = 0;
+
+	if (!info->edev)
+		return;
+
+	mutex_lock(&info->mutex);
+
+	/* Detect attached or detached cables */
+	if (info->irq_attach) {
+		ret = sm5502_muic_cable_handler(info, true);
+		info->irq_attach = false;
+	}
+	if (info->irq_detach) {
+		ret = sm5502_muic_cable_handler(info, false);
+		info->irq_detach = false;
+	}
+
+	if (ret < 0)
+		dev_err(info->dev, "failed to handle MUIC interrupt\n");
+
+	mutex_unlock(&info->mutex);
+
+	return;
+}
+
+/*
+ * Sets irq_attach or irq_detach in sm5502_muic_info and returns 0.
+ * Returns -ESRCH if irq_type does not match registered IRQ for this dev type.
+ */
+static int sm5502_parse_irq(struct sm5502_muic_info *info, int irq_type)
+{
+	switch (irq_type) {
+	case SM5502_IRQ_INT1_ATTACH:
+		info->irq_attach = true;
+		break;
+	case SM5502_IRQ_INT1_DETACH:
+		info->irq_detach = true;
+		break;
+	case SM5502_IRQ_INT1_KP:
+	case SM5502_IRQ_INT1_LKP:
+	case SM5502_IRQ_INT1_LKR:
+	case SM5502_IRQ_INT1_OVP_EVENT:
+	case SM5502_IRQ_INT1_OCP_EVENT:
+	case SM5502_IRQ_INT1_OVP_OCP_DIS:
+	case SM5502_IRQ_INT2_VBUS_DET:
+	case SM5502_IRQ_INT2_REV_ACCE:
+	case SM5502_IRQ_INT2_ADC_CHG:
+	case SM5502_IRQ_INT2_STUCK_KEY:
+	case SM5502_IRQ_INT2_STUCK_KEY_RCV:
+	case SM5502_IRQ_INT2_MHL:
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static irqreturn_t sm5502_muic_irq_handler(int irq, void *data)
+{
+	struct sm5502_muic_info *info = data;
+	int i, irq_type = -1, ret;
+
+	for (i = 0; i < info->num_muic_irqs; i++)
+		if (irq == info->muic_irqs[i].virq)
+			irq_type = info->muic_irqs[i].irq;
+
+	ret = sm5502_parse_irq(info, irq_type);
+	if (ret < 0) {
+		dev_warn(info->dev, "cannot handle is interrupt:%d\n",
+				    irq_type);
+		return IRQ_HANDLED;
+	}
+	schedule_work(&info->irq_work);
+
+	return IRQ_HANDLED;
+}
+
+static void sm5502_init_dev_type(struct sm5502_muic_info *info)
+{
+	unsigned int reg_data, vendor_id, version_id;
+	int i, ret;
+
+	/* To test I2C, Print version_id and vendor_id of SM5502 */
+	ret = regmap_read(info->regmap, SM5502_REG_DEVICE_ID, &reg_data);
+	if (ret) {
+		dev_err(info->dev,
+			"failed to read DEVICE_ID register: %d\n", ret);
+		return;
+	}
+
+	vendor_id = ((reg_data & SM5502_REG_DEVICE_ID_VENDOR_MASK) >>
+				SM5502_REG_DEVICE_ID_VENDOR_SHIFT);
+	version_id = ((reg_data & SM5502_REG_DEVICE_ID_VERSION_MASK) >>
+				SM5502_REG_DEVICE_ID_VERSION_SHIFT);
+
+	dev_info(info->dev, "Device type: version: 0x%x, vendor: 0x%x\n",
+			    version_id, vendor_id);
+
+	/* Initiazle the register of SM5502 device to bring-up */
+	for (i = 0; i < info->num_reg_data; i++) {
+		unsigned int val = 0;
+
+		if (!info->reg_data[i].invert)
+			val |= ~info->reg_data[i].val;
+		else
+			val = info->reg_data[i].val;
+		regmap_write(info->regmap, info->reg_data[i].reg, val);
+	}
+}
+
+static int sm5022_muic_i2c_probe(struct i2c_client *i2c,
+				 const struct i2c_device_id *id)
+{
+	struct device_node *np = i2c->dev.of_node;
+	struct sm5502_muic_info *info;
+	int i, ret, irq_flags;
+
+	if (!np)
+		return -EINVAL;
+
+	info = devm_kzalloc(&i2c->dev, sizeof(*info), GFP_KERNEL);
+	if (!info)
+		return -ENOMEM;
+	i2c_set_clientdata(i2c, info);
+
+	info->dev = &i2c->dev;
+	info->i2c = i2c;
+	info->irq = i2c->irq;
+	info->muic_irqs = sm5502_muic_irqs;
+	info->num_muic_irqs = ARRAY_SIZE(sm5502_muic_irqs);
+	info->reg_data = sm5502_reg_data;
+	info->num_reg_data = ARRAY_SIZE(sm5502_reg_data);
+
+	mutex_init(&info->mutex);
+
+	INIT_WORK(&info->irq_work, sm5502_muic_irq_work);
+
+	info->regmap = devm_regmap_init_i2c(i2c, &sm5502_muic_regmap_config);
+	if (IS_ERR(info->regmap)) {
+		ret = PTR_ERR(info->regmap);
+		dev_err(info->dev, "failed to allocate register map: %d\n",
+				   ret);
+		return ret;
+	}
+
+	/* Support irq domain for SM5502 MUIC device */
+	irq_flags = IRQF_TRIGGER_FALLING | IRQF_ONESHOT | IRQF_SHARED;
+	ret = regmap_add_irq_chip(info->regmap, info->irq, irq_flags, 0,
+				  &sm5502_muic_irq_chip, &info->irq_data);
+	if (ret != 0) {
+		dev_err(info->dev, "failed to request IRQ %d: %d\n",
+				    info->irq, ret);
+		return ret;
+	}
+
+	for (i = 0; i < info->num_muic_irqs; i++) {
+		struct muic_irq *muic_irq = &info->muic_irqs[i];
+		unsigned int virq = 0;
+
+		virq = regmap_irq_get_virq(info->irq_data, muic_irq->irq);
+		if (virq <= 0)
+			return -EINVAL;
+		muic_irq->virq = virq;
+
+		ret = devm_request_threaded_irq(info->dev, virq, NULL,
+						sm5502_muic_irq_handler,
+						IRQF_NO_SUSPEND,
+						muic_irq->name, info);
+		if (ret) {
+			dev_err(info->dev, "failed: irq request (IRQ: %d,"
+				" error :%d)\n", muic_irq->irq, ret);
+			return ret;
+		}
+	}
+
+	/* Allocate extcon device */
+	info->edev = devm_extcon_dev_allocate(info->dev, sm5502_extcon_cable);
+	if (IS_ERR(info->edev)) {
+		dev_err(info->dev, "failed to allocate memory for extcon\n");
+		return -ENOMEM;
+	}
+	info->edev->name = np->name;
+
+	/* Register extcon device */
+	ret = devm_extcon_dev_register(info->dev, info->edev);
+	if (ret) {
+		dev_err(info->dev, "failed to register extcon device\n");
+		return ret;
+	}
+
+	/* Initialize SM5502 device and print vendor id and version id */
+	sm5502_init_dev_type(info);
+
+	return 0;
+}
+
+static int sm5502_muic_i2c_remove(struct i2c_client *i2c)
+{
+	struct sm5502_muic_info *info = i2c_get_clientdata(i2c);
+
+	regmap_del_irq_chip(info->irq, info->irq_data);
+
+	return 0;
+}
+
+static struct of_device_id sm5502_dt_match[] = {
+	{ .compatible = "siliconmitus,sm5502-muic" },
+	{ },
+};
+
+#ifdef CONFIG_PM_SLEEP
+static int sm5502_muic_suspend(struct device *dev)
+{
+	struct i2c_client *i2c = container_of(dev, struct i2c_client, dev);
+	struct sm5502_muic_info *info = i2c_get_clientdata(i2c);
+
+	enable_irq_wake(info->irq);
+
+	return 0;
+}
+
+static int sm5502_muic_resume(struct device *dev)
+{
+	struct i2c_client *i2c = container_of(dev, struct i2c_client, dev);
+	struct sm5502_muic_info *info = i2c_get_clientdata(i2c);
+
+	disable_irq_wake(info->irq);
+
+	return 0;
+}
+#endif
+
+static SIMPLE_DEV_PM_OPS(sm5502_muic_pm_ops,
+			 sm5502_muic_suspend, sm5502_muic_resume);
+
+static const struct i2c_device_id sm5502_i2c_id[] = {
+	{ "sm5502", TYPE_SM5502 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, sm5502_i2c_id);
+
+static struct i2c_driver sm5502_muic_i2c_driver = {
+	.driver		= {
+		.name	= "sm5502",
+		.owner	= THIS_MODULE,
+		.pm	= &sm5502_muic_pm_ops,
+		.of_match_table = sm5502_dt_match,
+	},
+	.probe	= sm5022_muic_i2c_probe,
+	.remove	= sm5502_muic_i2c_remove,
+	.id_table = sm5502_i2c_id,
+};
+
+static int __init sm5502_muic_i2c_init(void)
+{
+	return i2c_add_driver(&sm5502_muic_i2c_driver);
+}
+subsys_initcall(sm5502_muic_i2c_init);
+
+MODULE_DESCRIPTION("Silicon Mitus SM5502 Extcon driver");
+MODULE_AUTHOR("Chanwoo Choi <cw00.choi@samsung.com>");
+MODULE_LICENSE("GPL");
