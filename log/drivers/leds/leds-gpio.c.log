commit 90a8e82d3ca8c1f85ac63f4a94c9b034f05af4ee
Author: Jacek Anaszewski <jacek.anaszewski@gmail.com>
Date:   Thu Dec 5 22:25:01 2019 +0100

    leds: gpio: Fix uninitialized gpio label for fwnode based probe
    
    When switching to using generic LED name composition mechanism via
    devm_led_classdev_register_ext() API the part of code initializing
    struct gpio_led's template name property was removed alongside.
    It was however overlooked that the property was also passed to
    devm_fwnode_get_gpiod_from_child() in place of "label" parameter,
    which when set to NULL, results in gpio label being initialized to '?'.
    
    It could be observed in debugfs and failed to properly identify
    gpio association with LED consumer.
    
    Fix this shortcoming by updating the GPIO label after the LED is
    registered and its final name is known.
    
    Fixes: d7235f5feaa0 ("leds: gpio: Use generic support for composing LED names")
    Cc: Russell King <linux@armlinux.org.uk>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Jacek Anaszewski <jacek.anaszewski@gmail.com>
    [fixed comment]
    Signed-off-by: Pavel Machek <pavel@ucw.cz>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index a5c73f3d5f79..2bf74595610f 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -151,9 +151,14 @@ static struct gpio_leds_priv *gpio_leds_create(struct platform_device *pdev)
 		struct gpio_led led = {};
 		const char *state = NULL;
 
+		/*
+		 * Acquire gpiod from DT with uninitialized label, which
+		 * will be updated after LED class device is registered,
+		 * Only then the final LED name is known.
+		 */
 		led.gpiod = devm_fwnode_get_gpiod_from_child(dev, NULL, child,
 							     GPIOD_ASIS,
-							     led.name);
+							     NULL);
 		if (IS_ERR(led.gpiod)) {
 			fwnode_handle_put(child);
 			return ERR_CAST(led.gpiod);
@@ -186,6 +191,9 @@ static struct gpio_leds_priv *gpio_leds_create(struct platform_device *pdev)
 			fwnode_handle_put(child);
 			return ERR_PTR(ret);
 		}
+		/* Set gpiod label to match the corresponding LED name. */
+		gpiod_set_consumer_name(led_dat->gpiod,
+					led_dat->cdev.dev->kobj.name);
 		priv->num_leds++;
 	}
 

commit d7235f5feaa0d53e27a369a3198827c921103c24
Author: Jacek Anaszewski <jacek.anaszewski@gmail.com>
Date:   Sun Jun 9 20:19:04 2019 +0200

    leds: gpio: Use generic support for composing LED names
    
    Switch to using generic LED support for composing LED class
    device name.
    
    Signed-off-by: Jacek Anaszewski <jacek.anaszewski@gmail.com>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Pavel Machek <pavel@ucw.cz>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index 8f463c912db8..a5c73f3d5f79 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -73,11 +73,11 @@ static int gpio_blink_set(struct led_classdev *led_cdev,
 
 static int create_gpio_led(const struct gpio_led *template,
 	struct gpio_led_data *led_dat, struct device *parent,
-	struct device_node *np, gpio_blink_set_t blink_set)
+	struct fwnode_handle *fwnode, gpio_blink_set_t blink_set)
 {
+	struct led_init_data init_data = {};
 	int ret, state;
 
-	led_dat->cdev.name = template->name;
 	led_dat->cdev.default_trigger = template->default_trigger;
 	led_dat->can_sleep = gpiod_cansleep(led_dat->gpiod);
 	if (!led_dat->can_sleep)
@@ -108,7 +108,16 @@ static int create_gpio_led(const struct gpio_led *template,
 	if (ret < 0)
 		return ret;
 
-	return devm_led_classdev_register(parent, &led_dat->cdev);
+	if (template->name) {
+		led_dat->cdev.name = template->name;
+		ret = devm_led_classdev_register(parent, &led_dat->cdev);
+	} else {
+		init_data.fwnode = fwnode;
+		ret = devm_led_classdev_register_ext(parent, &led_dat->cdev,
+						     &init_data);
+	}
+
+	return ret;
 }
 
 struct gpio_leds_priv {
@@ -141,15 +150,6 @@ static struct gpio_leds_priv *gpio_leds_create(struct platform_device *pdev)
 		struct gpio_led_data *led_dat = &priv->leds[priv->num_leds];
 		struct gpio_led led = {};
 		const char *state = NULL;
-		struct device_node *np = to_of_node(child);
-
-		ret = fwnode_property_read_string(child, "label", &led.name);
-		if (ret && IS_ENABLED(CONFIG_OF) && np)
-			led.name = np->name;
-		if (!led.name) {
-			fwnode_handle_put(child);
-			return ERR_PTR(-EINVAL);
-		}
 
 		led.gpiod = devm_fwnode_get_gpiod_from_child(dev, NULL, child,
 							     GPIOD_ASIS,
@@ -181,7 +181,7 @@ static struct gpio_leds_priv *gpio_leds_create(struct platform_device *pdev)
 		if (fwnode_property_present(child, "panic-indicator"))
 			led.panic_indicator = 1;
 
-		ret = create_gpio_led(&led, led_dat, dev, np, NULL);
+		ret = create_gpio_led(&led, led_dat, dev, child, NULL);
 		if (ret < 0) {
 			fwnode_handle_put(child);
 			return ERR_PTR(ret);

commit b2b998c0f944993c9ef435569651e407d607af41
Author: Jacek Anaszewski <jacek.anaszewski@gmail.com>
Date:   Sun Jun 9 20:19:03 2019 +0200

    leds: class: Improve LED and LED flash class registration API
    
    Replace of_led_classdev_register() with led_classdev_register_ext(), which
    accepts easily extendable struct led_init_data, instead of the fixed
    struct device_node argument. The latter can be now passed in an fwnode
    property of the struct led_init_data.
    
    The modification is driven by the need for passing additional arguments
    required for the forthcoming generic mechanism for composing LED names.
    Currently the LED name is conveyed in the "name" char pointer property of
    the struct led_classdev. This is redundant since LED class device name
    is accessible throughout the whole LED class device life time via
    associated struct device's kobj->name property.
    
    The change will not break any existing clients since the patch alters
    also existing led_classdev{_flash}_register() macro wrappers, that pass
    NULL in place of init_data, which leads to using legacy name
    initialization path basing on the struct led_classdev's "name" property.
    
    Three existing users of devm_of_led_classdev_registers() are modified
    to use devm_led_classdev_register(), which will not impact their
    operation since they in fact didn't need to pass struct device_node on
    registration from the beginning.
    
    Signed-off-by: Jacek Anaszewski <jacek.anaszewski@gmail.com>
    Cc: Baolin Wang <baolin.wang@linaro.org>
    Cc: Dan Murphy <dmurphy@ti.com>
    Cc: Daniel Mack <daniel@zonque.org>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: Oleh Kravchenko <oleg@kaa.org.ua>
    Cc: Sakari Ailus <sakari.ailus@linux.intel.com>
    Cc: Simon Shields <simon@lineageos.org>
    Acked-by: Pavel Machek <pavel@ucw.cz>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index bdc98ddca1dc..8f463c912db8 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -108,7 +108,7 @@ static int create_gpio_led(const struct gpio_led *template,
 	if (ret < 0)
 		return ret;
 
-	return devm_of_led_classdev_register(parent, np, &led_dat->cdev);
+	return devm_led_classdev_register(parent, &led_dat->cdev);
 }
 
 struct gpio_leds_priv {

commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index 998f2ff6914d..bdc98ddca1dc 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -1,14 +1,10 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * LEDs driver for GPIOs
  *
  * Copyright (C) 2007 8D Technologies inc.
  * Raphael Assenat <raph@8d.com>
  * Copyright (C) 2008 Freescale Semiconductor, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
  */
 #include <linux/err.h>
 #include <linux/gpio.h>

commit b086592e5dcd9cee360f44be801fbcadb24d5c46
Author: Krzysztof Kozlowski <krzk@kernel.org>
Date:   Fri Dec 7 11:10:06 2018 +0100

    leds: gpio: Drop unneeded manual of_node assignment
    
    This reverts the main change of commit bff23714bc36 ("leds: leds-gpio:
    Set of_node for created LED devices") because of_node assignment is
    handled by core since commit 7ea79ae86c28 ("leds: gpio: use OF variant
    of LED registering function").  Basically the code was overwriting the
    of_node with same value.
    
    No functional change expected.
    
    Signed-off-by: Krzysztof Kozlowski <krzk@kernel.org>
    Tested-by: Rafał Miłecki <rafal@milecki.pl>
    Signed-off-by: Jacek Anaszewski <jacek.anaszewski@gmail.com>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index 45e012093865..998f2ff6914d 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -190,7 +190,6 @@ static struct gpio_leds_priv *gpio_leds_create(struct platform_device *pdev)
 			fwnode_handle_put(child);
 			return ERR_PTR(ret);
 		}
-		led_dat->cdev.dev->of_node = np;
 		priv->num_leds++;
 	}
 

commit 72b8ad40e14302f869382656a914bb803796b4ed
Author: Liviu Dudau <liviu@dudau.co.uk>
Date:   Thu Oct 18 01:14:32 2018 +0100

    leds: gpio: set led_dat->gpiod pointer for OF defined GPIO leds
    
    Commit 45d4c6de4e49 ("leds: gpio: Try to lookup gpiod from device")
    removed the common code path that set the led_dat->gpiod pointer in
    create_gpio_led(), but only added it back for the devices that have
    a valid gpio_led_platform_data structure. Calling gpio_leds_create()
    in gpio_led_probe() is not enough to get a valid gpiod pointer.
    
    Fortunately enough, gpio_leds_create() already gets the needed pointer,
    we just need to assign it to the relevant gpio_led_data structure.
    
    Fixes: 45d4c6de4e49 ("leds: gpio: Try to lookup gpiod from device")
    Signed-off-by: Liviu Dudau <liviu@dudau.co.uk>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Jacek Anaszewski <jacek.anaszewski@gmail.com>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index 32fa752565bc..45e012093865 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -163,6 +163,8 @@ static struct gpio_leds_priv *gpio_leds_create(struct platform_device *pdev)
 			return ERR_CAST(led.gpiod);
 		}
 
+		led_dat->gpiod = led.gpiod;
+
 		fwnode_property_read_string(child, "linux,default-trigger",
 					    &led.default_trigger);
 

commit 45d4c6de4e497e5b0026c77044ae5fcddf8fecd8
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Fri Sep 7 00:09:40 2018 +0200

    leds: gpio: Try to lookup gpiod from device
    
    This augments the GPIO lookup code in the GPIO LEDs to
    attempt to look up a GPIO descriptor from the device with
    index.
    
    This makes it possible to use GPIO machine look-up tables
    and stop passing global GPIO numbers through platform data.
    
    Using this we can stepwise convert existing board files
    to use machine descriptor tables and then eventually drop
    the legacy GPIO support and only include
    <linux/gpio/consumer.h> and use descriptors exclusively.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Jacek Anaszewski <jacek.anaszewski@gmail.com>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index 764c31301f90..32fa752565bc 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -81,35 +81,6 @@ static int create_gpio_led(const struct gpio_led *template,
 {
 	int ret, state;
 
-	led_dat->gpiod = template->gpiod;
-	if (!led_dat->gpiod) {
-		/*
-		 * This is the legacy code path for platform code that
-		 * still uses GPIO numbers. Ultimately we would like to get
-		 * rid of this block completely.
-		 */
-		unsigned long flags = GPIOF_OUT_INIT_LOW;
-
-		/* skip leds that aren't available */
-		if (!gpio_is_valid(template->gpio)) {
-			dev_info(parent, "Skipping unavailable LED gpio %d (%s)\n",
-					template->gpio, template->name);
-			return 0;
-		}
-
-		if (template->active_low)
-			flags |= GPIOF_ACTIVE_LOW;
-
-		ret = devm_gpio_request_one(parent, template->gpio, flags,
-					    template->name);
-		if (ret < 0)
-			return ret;
-
-		led_dat->gpiod = gpio_to_desc(template->gpio);
-		if (!led_dat->gpiod)
-			return -EINVAL;
-	}
-
 	led_dat->cdev.name = template->name;
 	led_dat->cdev.default_trigger = template->default_trigger;
 	led_dat->can_sleep = gpiod_cansleep(led_dat->gpiod);
@@ -231,6 +202,52 @@ static const struct of_device_id of_gpio_leds_match[] = {
 
 MODULE_DEVICE_TABLE(of, of_gpio_leds_match);
 
+static struct gpio_desc *gpio_led_get_gpiod(struct device *dev, int idx,
+					    const struct gpio_led *template)
+{
+	struct gpio_desc *gpiod;
+	unsigned long flags = GPIOF_OUT_INIT_LOW;
+	int ret;
+
+	/*
+	 * This means the LED does not come from the device tree
+	 * or ACPI, so let's try just getting it by index from the
+	 * device, this will hit the board file, if any and get
+	 * the GPIO from there.
+	 */
+	gpiod = devm_gpiod_get_index(dev, NULL, idx, flags);
+	if (!IS_ERR(gpiod)) {
+		gpiod_set_consumer_name(gpiod, template->name);
+		return gpiod;
+	}
+	if (PTR_ERR(gpiod) != -ENOENT)
+		return gpiod;
+
+	/*
+	 * This is the legacy code path for platform code that
+	 * still uses GPIO numbers. Ultimately we would like to get
+	 * rid of this block completely.
+	 */
+
+	/* skip leds that aren't available */
+	if (!gpio_is_valid(template->gpio))
+		return ERR_PTR(-ENOENT);
+
+	if (template->active_low)
+		flags |= GPIOF_ACTIVE_LOW;
+
+	ret = devm_gpio_request_one(dev, template->gpio, flags,
+				    template->name);
+	if (ret < 0)
+		return ERR_PTR(ret);
+
+	gpiod = gpio_to_desc(template->gpio);
+	if (!gpiod)
+		return ERR_PTR(-EINVAL);
+
+	return gpiod;
+}
+
 static int gpio_led_probe(struct platform_device *pdev)
 {
 	struct gpio_led_platform_data *pdata = dev_get_platdata(&pdev->dev);
@@ -246,7 +263,22 @@ static int gpio_led_probe(struct platform_device *pdev)
 
 		priv->num_leds = pdata->num_leds;
 		for (i = 0; i < priv->num_leds; i++) {
-			ret = create_gpio_led(&pdata->leds[i], &priv->leds[i],
+			const struct gpio_led *template = &pdata->leds[i];
+			struct gpio_led_data *led_dat = &priv->leds[i];
+
+			if (template->gpiod)
+				led_dat->gpiod = template->gpiod;
+			else
+				led_dat->gpiod =
+					gpio_led_get_gpiod(&pdev->dev,
+							   i, template);
+			if (IS_ERR(led_dat->gpiod)) {
+				dev_info(&pdev->dev, "Skipping unavailable LED gpio %d (%s)\n",
+					 template->gpio, template->name);
+				continue;
+			}
+
+			ret = create_gpio_led(template, led_dat,
 					      &pdev->dev, NULL,
 					      pdata->gpio_blink_set);
 			if (ret < 0)

commit f5808ac158f2b16b686a3d3c0879c5d6048aba14
Author: Andrew Jeffery <andrew@aj.id.au>
Date:   Mon Aug 28 09:47:11 2017 +0930

    leds: gpio: Allow LED to retain state at shutdown
    
    In some systems, such as Baseboard Management Controllers (BMCs), we
    want to retain the state of LEDs across a reboot of the BMC (whilst the
    host remains up). Implement support for the retain-state-shutdown
    devicetree property in leds-gpio.
    
    Signed-off-by: Andrew Jeffery <andrew@aj.id.au>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Tested-by: Brandon Wyman <bjwyman@gmail.com>
    Signed-off-by: Jacek Anaszewski <jacek.anaszewski@gmail.com>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index e753ba93ba1e..764c31301f90 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -134,6 +134,8 @@ static int create_gpio_led(const struct gpio_led *template,
 		led_dat->cdev.flags |= LED_CORE_SUSPENDRESUME;
 	if (template->panic_indicator)
 		led_dat->cdev.flags |= LED_PANIC_INDICATOR;
+	if (template->retain_state_shutdown)
+		led_dat->cdev.flags |= LED_RETAIN_AT_SHUTDOWN;
 
 	ret = gpiod_direction_output(led_dat->gpiod, state);
 	if (ret < 0)
@@ -205,6 +207,8 @@ static struct gpio_leds_priv *gpio_leds_create(struct platform_device *pdev)
 
 		if (fwnode_property_present(child, "retain-state-suspended"))
 			led.retain_state_suspended = 1;
+		if (fwnode_property_present(child, "retain-state-shutdown"))
+			led.retain_state_shutdown = 1;
 		if (fwnode_property_present(child, "panic-indicator"))
 			led.panic_indicator = 1;
 
@@ -267,7 +271,8 @@ static void gpio_led_shutdown(struct platform_device *pdev)
 	for (i = 0; i < priv->num_leds; i++) {
 		struct gpio_led_data *led = &priv->leds[i];
 
-		gpio_led_set(&led->cdev, LED_OFF);
+		if (!(led->cdev.flags & LED_RETAIN_AT_SHUTDOWN))
+			gpio_led_set(&led->cdev, LED_OFF);
 	}
 }
 

commit 7ea79ae86c28e729d51fa5703b093d27cca25217
Author: Rafał Miłecki <rafal@milecki.pl>
Date:   Mon Mar 6 06:19:45 2017 +0100

    leds: gpio: use OF variant of LED registering function
    
    In leds-gpio we support LEDs specified in DT so we should use
    (devm_)of_led_classdev_register. This allows passing DT node as argument
    for use by the LED subsystem.
    
    Signed-off-by: Rafał Miłecki <rafal@milecki.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Jacek Anaszewski <jacek.anaszewski@gmail.com>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index 066fc7590729..e753ba93ba1e 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -77,7 +77,7 @@ static int gpio_blink_set(struct led_classdev *led_cdev,
 
 static int create_gpio_led(const struct gpio_led *template,
 	struct gpio_led_data *led_dat, struct device *parent,
-	gpio_blink_set_t blink_set)
+	struct device_node *np, gpio_blink_set_t blink_set)
 {
 	int ret, state;
 
@@ -139,7 +139,7 @@ static int create_gpio_led(const struct gpio_led *template,
 	if (ret < 0)
 		return ret;
 
-	return devm_led_classdev_register(parent, &led_dat->cdev);
+	return devm_of_led_classdev_register(parent, np, &led_dat->cdev);
 }
 
 struct gpio_leds_priv {
@@ -208,7 +208,7 @@ static struct gpio_leds_priv *gpio_leds_create(struct platform_device *pdev)
 		if (fwnode_property_present(child, "panic-indicator"))
 			led.panic_indicator = 1;
 
-		ret = create_gpio_led(&led, led_dat, dev, NULL);
+		ret = create_gpio_led(&led, led_dat, dev, np, NULL);
 		if (ret < 0) {
 			fwnode_handle_put(child);
 			return ERR_PTR(ret);
@@ -242,9 +242,9 @@ static int gpio_led_probe(struct platform_device *pdev)
 
 		priv->num_leds = pdata->num_leds;
 		for (i = 0; i < priv->num_leds; i++) {
-			ret = create_gpio_led(&pdata->leds[i],
-					      &priv->leds[i],
-					      &pdev->dev, pdata->gpio_blink_set);
+			ret = create_gpio_led(&pdata->leds[i], &priv->leds[i],
+					      &pdev->dev, NULL,
+					      pdata->gpio_blink_set);
 			if (ret < 0)
 				return ret;
 		}

commit 4b0947974e593d52aace18ca5c7e2746fdebae60
Author: Boris Brezillon <boris.brezillon@free-electrons.com>
Date:   Thu Feb 2 14:53:10 2017 +0100

    gpio: Rename devm_get_gpiod_from_child()
    
    Rename devm_get_gpiod_from_child() into
    devm_fwnode_get_gpiod_from_child() to reflect the fact that this
    function is operating on a fwnode object.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Acked-by: Jacek Anaszewski <jacek.anaszewski@gmail.com>
    Acked-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index 6c4825d96693..066fc7590729 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -182,8 +182,9 @@ static struct gpio_leds_priv *gpio_leds_create(struct platform_device *pdev)
 			return ERR_PTR(-EINVAL);
 		}
 
-		led.gpiod = devm_get_gpiod_from_child(dev, NULL, child,
-						      GPIOD_ASIS, led.name);
+		led.gpiod = devm_fwnode_get_gpiod_from_child(dev, NULL, child,
+							     GPIOD_ASIS,
+							     led.name);
 		if (IS_ERR(led.gpiod)) {
 			fwnode_handle_put(child);
 			return ERR_CAST(led.gpiod);

commit b2987d7438e0ca949d81774ca8b43d370a1f9947
Author: Alexander Stein <alexander.stein@systec-electronic.com>
Date:   Thu Jan 12 17:39:24 2017 +0100

    gpio: Pass GPIO label down to gpiod_request
    
    Currently all users of fwnode_get_named_gpiod() have no way to
    specify a label for the GPIO. So GPIOs listed in debugfs are shown
    with label "?". With this change a proper label is used.
    
    Also adjust all users so they can pass a label, properly retrieved
    from device tree properties.
    
    Signed-off-by: Alexander Stein <alexander.stein@systec-electronic.com>
    Cc: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Jacek Anaszewski <jacek.anaszewski@gmail.com>
    Acked-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Acked-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index 00cc671cddcc..6c4825d96693 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -174,12 +174,6 @@ static struct gpio_leds_priv *gpio_leds_create(struct platform_device *pdev)
 		const char *state = NULL;
 		struct device_node *np = to_of_node(child);
 
-		led.gpiod = devm_get_gpiod_from_child(dev, NULL, child, GPIOD_ASIS);
-		if (IS_ERR(led.gpiod)) {
-			fwnode_handle_put(child);
-			return ERR_CAST(led.gpiod);
-		}
-
 		ret = fwnode_property_read_string(child, "label", &led.name);
 		if (ret && IS_ENABLED(CONFIG_OF) && np)
 			led.name = np->name;
@@ -188,6 +182,13 @@ static struct gpio_leds_priv *gpio_leds_create(struct platform_device *pdev)
 			return ERR_PTR(-EINVAL);
 		}
 
+		led.gpiod = devm_get_gpiod_from_child(dev, NULL, child,
+						      GPIOD_ASIS, led.name);
+		if (IS_ERR(led.gpiod)) {
+			fwnode_handle_put(child);
+			return ERR_CAST(led.gpiod);
+		}
+
 		fwnode_property_read_string(child, "linux,default-trigger",
 					    &led.default_trigger);
 

commit a264d10ff45c688293d9112fddd8d29c819e0853
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Mon Jan 9 16:02:28 2017 +0200

    gpiolib: Convert fwnode_get_named_gpiod() to configure GPIO
    
    Make fwnode_get_named_gpiod() consistent with the rest of
    gpiod_get() like API, i.e. configure GPIO pin immediately after
    request.
    
    Besides obvious clean up it will help to configure pins based
    on firmware provided resources.
    
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index d400dcaf4d29..00cc671cddcc 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -174,7 +174,7 @@ static struct gpio_leds_priv *gpio_leds_create(struct platform_device *pdev)
 		const char *state = NULL;
 		struct device_node *np = to_of_node(child);
 
-		led.gpiod = devm_get_gpiod_from_child(dev, NULL, child);
+		led.gpiod = devm_get_gpiod_from_child(dev, NULL, child, GPIOD_ASIS);
 		if (IS_ERR(led.gpiod)) {
 			fwnode_handle_put(child);
 			return ERR_CAST(led.gpiod);

commit 74b69e5246d13840963b7b23e21dbab541cb26d2
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Wed Sep 14 20:55:43 2016 +0200

    leds: gpio: fix and simplify error handling in gpio_leds_create
    
    Simplify the error handling and add a missing call to fwnode_handle_put
    when checking led.name.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Jacek Anaszewski <j.anaszewski@samsung.com>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index ab273f85ac3c..d400dcaf4d29 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -177,16 +177,15 @@ static struct gpio_leds_priv *gpio_leds_create(struct platform_device *pdev)
 		led.gpiod = devm_get_gpiod_from_child(dev, NULL, child);
 		if (IS_ERR(led.gpiod)) {
 			fwnode_handle_put(child);
-			ret = PTR_ERR(led.gpiod);
-			goto err;
+			return ERR_CAST(led.gpiod);
 		}
 
 		ret = fwnode_property_read_string(child, "label", &led.name);
 		if (ret && IS_ENABLED(CONFIG_OF) && np)
 			led.name = np->name;
 		if (!led.name) {
-			ret = -EINVAL;
-			goto err;
+			fwnode_handle_put(child);
+			return ERR_PTR(-EINVAL);
 		}
 
 		fwnode_property_read_string(child, "linux,default-trigger",
@@ -210,16 +209,13 @@ static struct gpio_leds_priv *gpio_leds_create(struct platform_device *pdev)
 		ret = create_gpio_led(&led, led_dat, dev, NULL);
 		if (ret < 0) {
 			fwnode_handle_put(child);
-			goto err;
+			return ERR_PTR(ret);
 		}
 		led_dat->cdev.dev->of_node = np;
 		priv->num_leds++;
 	}
 
 	return priv;
-
-err:
-	return ERR_PTR(ret);
 }
 
 static const struct of_device_id of_gpio_leds_match[] = {

commit bc2c0dd85a0a31505ca2f92bef891ddac9126725
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Wed Sep 14 20:55:27 2016 +0200

    leds: gpio: switch to managed version of led_classdev_register
    
    Using the managed version of led_classdev_register allows to
    significantly simplify the code.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Jacek Anaszewski <j.anaszewski@samsung.com>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index 00a24e32c6c6..ab273f85ac3c 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -139,7 +139,7 @@ static int create_gpio_led(const struct gpio_led *template,
 	if (ret < 0)
 		return ret;
 
-	return led_classdev_register(parent, &led_dat->cdev);
+	return devm_led_classdev_register(parent, &led_dat->cdev);
 }
 
 struct gpio_leds_priv {
@@ -219,8 +219,6 @@ static struct gpio_leds_priv *gpio_leds_create(struct platform_device *pdev)
 	return priv;
 
 err:
-	for (count = priv->num_leds - 1; count >= 0; count--)
-		led_classdev_unregister(&priv->leds[count].cdev);
 	return ERR_PTR(ret);
 }
 
@@ -249,13 +247,8 @@ static int gpio_led_probe(struct platform_device *pdev)
 			ret = create_gpio_led(&pdata->leds[i],
 					      &priv->leds[i],
 					      &pdev->dev, pdata->gpio_blink_set);
-			if (ret < 0) {
-				/* On failure: unwind the led creations */
-				for (i = i - 1; i >= 0; i--)
-					led_classdev_unregister(
-							&priv->leds[i].cdev);
+			if (ret < 0)
 				return ret;
-			}
 		}
 	} else {
 		priv = gpio_leds_create(pdev);
@@ -268,17 +261,6 @@ static int gpio_led_probe(struct platform_device *pdev)
 	return 0;
 }
 
-static int gpio_led_remove(struct platform_device *pdev)
-{
-	struct gpio_leds_priv *priv = platform_get_drvdata(pdev);
-	int i;
-
-	for (i = 0; i < priv->num_leds; i++)
-		led_classdev_unregister(&priv->leds[i].cdev);
-
-	return 0;
-}
-
 static void gpio_led_shutdown(struct platform_device *pdev)
 {
 	struct gpio_leds_priv *priv = platform_get_drvdata(pdev);
@@ -293,7 +275,6 @@ static void gpio_led_shutdown(struct platform_device *pdev)
 
 static struct platform_driver gpio_led_driver = {
 	.probe		= gpio_led_probe,
-	.remove		= gpio_led_remove,
 	.shutdown	= gpio_led_shutdown,
 	.driver		= {
 		.name	= "leds-gpio",

commit bec69de89bab29c739ab84ceb04ae63d6811babf
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Wed Sep 14 20:55:18 2016 +0200

    leds: gpio: fix and simplify reading property "label"
    
    Checking for the presence of the property first isn't strictly needed
    as we can react on the return code of fwnode_property_read_string.
    Also, even if the presence of a property "label" was checked,
    reading a string value for it theoretically still can fail and
    this case isn't handled.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Jacek Anaszewski <j.anaszewski@samsung.com>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index 171ba2fbb59a..00a24e32c6c6 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -181,16 +181,14 @@ static struct gpio_leds_priv *gpio_leds_create(struct platform_device *pdev)
 			goto err;
 		}
 
-		if (fwnode_property_present(child, "label")) {
-			fwnode_property_read_string(child, "label", &led.name);
-		} else {
-			if (IS_ENABLED(CONFIG_OF) && !led.name && np)
-				led.name = np->name;
-			if (!led.name) {
-				ret = -EINVAL;
-				goto err;
-			}
+		ret = fwnode_property_read_string(child, "label", &led.name);
+		if (ret && IS_ENABLED(CONFIG_OF) && np)
+			led.name = np->name;
+		if (!led.name) {
+			ret = -EINVAL;
+			goto err;
 		}
+
 		fwnode_property_read_string(child, "linux,default-trigger",
 					    &led.default_trigger);
 

commit 8ca03da5e0f70a413986221da4c88459bb6f6878
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Wed Sep 14 20:55:06 2016 +0200

    leds: gpio: simplify gpio_leds_create
    
    Definition of np can be moved into the loop as well to simplify
    the code a little.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Jacek Anaszewski <j.anaszewski@samsung.com>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index da4aa8e95a58..171ba2fbb59a 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -159,7 +159,6 @@ static struct gpio_leds_priv *gpio_leds_create(struct platform_device *pdev)
 	struct fwnode_handle *child;
 	struct gpio_leds_priv *priv;
 	int count, ret;
-	struct device_node *np;
 
 	count = device_get_child_node_count(dev);
 	if (!count)
@@ -173,6 +172,7 @@ static struct gpio_leds_priv *gpio_leds_create(struct platform_device *pdev)
 		struct gpio_led_data *led_dat = &priv->leds[priv->num_leds];
 		struct gpio_led led = {};
 		const char *state = NULL;
+		struct device_node *np = to_of_node(child);
 
 		led.gpiod = devm_get_gpiod_from_child(dev, NULL, child);
 		if (IS_ERR(led.gpiod)) {
@@ -181,8 +181,6 @@ static struct gpio_leds_priv *gpio_leds_create(struct platform_device *pdev)
 			goto err;
 		}
 
-		np = to_of_node(child);
-
 		if (fwnode_property_present(child, "label")) {
 			fwnode_property_read_string(child, "label", &led.name);
 		} else {

commit 4580809436fc391aff9d876a14d07f66a5de6b28
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Wed Sep 14 20:55:00 2016 +0200

    leds: gpio: add helper cdev_to_gpio_led_data
    
    Add a helper for the container_of as it's used more than once.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Jacek Anaszewski <j.anaszewski@samsung.com>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index 10c851ecc6ce..da4aa8e95a58 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -29,11 +29,16 @@ struct gpio_led_data {
 	gpio_blink_set_t platform_gpio_blink_set;
 };
 
+static inline struct gpio_led_data *
+			cdev_to_gpio_led_data(struct led_classdev *led_cdev)
+{
+	return container_of(led_cdev, struct gpio_led_data, cdev);
+}
+
 static void gpio_led_set(struct led_classdev *led_cdev,
 	enum led_brightness value)
 {
-	struct gpio_led_data *led_dat =
-		container_of(led_cdev, struct gpio_led_data, cdev);
+	struct gpio_led_data *led_dat = cdev_to_gpio_led_data(led_cdev);
 	int level;
 
 	if (value == LED_OFF)
@@ -63,8 +68,7 @@ static int gpio_led_set_blocking(struct led_classdev *led_cdev,
 static int gpio_blink_set(struct led_classdev *led_cdev,
 	unsigned long *delay_on, unsigned long *delay_off)
 {
-	struct gpio_led_data *led_dat =
-		container_of(led_cdev, struct gpio_led_data, cdev);
+	struct gpio_led_data *led_dat = cdev_to_gpio_led_data(led_cdev);
 
 	led_dat->blinking = 1;
 	return led_dat->platform_gpio_blink_set(led_dat->gpiod, GPIO_LED_BLINK,

commit 061b5c1d013a94af385ba8980ea3b2617f1ff0f6
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Wed Sep 14 20:54:31 2016 +0200

    leds: gpio: fix an unhandled error case in create_gpio_led
    
    gpiod_get_value_cansleep returns 0, 1, or an error code.
    So far errors are not handled and treated the same as 1.
    Change this to bail out if an error code is returned and
    remove the double negation.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Jacek Anaszewski <j.anaszewski@samsung.com>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index 3599b2e4977c..10c851ecc6ce 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -118,10 +118,13 @@ static int create_gpio_led(const struct gpio_led *template,
 		led_dat->platform_gpio_blink_set = blink_set;
 		led_dat->cdev.blink_set = gpio_blink_set;
 	}
-	if (template->default_state == LEDS_GPIO_DEFSTATE_KEEP)
-		state = !!gpiod_get_value_cansleep(led_dat->gpiod);
-	else
+	if (template->default_state == LEDS_GPIO_DEFSTATE_KEEP) {
+		state = gpiod_get_value_cansleep(led_dat->gpiod);
+		if (state < 0)
+			return state;
+	} else {
 		state = (template->default_state == LEDS_GPIO_DEFSTATE_ON);
+	}
 	led_dat->cdev.brightness = state ? LED_FULL : LED_OFF;
 	if (!template->retain_state_suspended)
 		led_dat->cdev.flags |= LED_CORE_SUSPENDRESUME;

commit 68620e594c250ba8c43a78e77f5296cb9952582e
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Wed Sep 14 20:54:12 2016 +0200

    leds: gpio: introduce gpio_blink_set_t
    
    Introduce a typedef gpio_blink_set_t to improve readability of the code.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Jacek Anaszewski <j.anaszewski@samsung.com>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index 9b991d46ed84..3599b2e4977c 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -26,8 +26,7 @@ struct gpio_led_data {
 	struct gpio_desc *gpiod;
 	u8 can_sleep;
 	u8 blinking;
-	int (*platform_gpio_blink_set)(struct gpio_desc *desc, int state,
-			unsigned long *delay_on, unsigned long *delay_off);
+	gpio_blink_set_t platform_gpio_blink_set;
 };
 
 static void gpio_led_set(struct led_classdev *led_cdev,
@@ -74,8 +73,7 @@ static int gpio_blink_set(struct led_classdev *led_cdev,
 
 static int create_gpio_led(const struct gpio_led *template,
 	struct gpio_led_data *led_dat, struct device *parent,
-	int (*blink_set)(struct gpio_desc *, int, unsigned long *,
-			 unsigned long *))
+	gpio_blink_set_t blink_set)
 {
 	int ret, state;
 

commit bff23714bc36a1322d0f14519022df0d1a4b21f3
Author: Rafał Miłecki <zajec5@gmail.com>
Date:   Fri Jul 8 14:53:38 2016 +0200

    leds: leds-gpio: Set of_node for created LED devices
    
    When working with Device Tree we iterate over children of "gpio-leds"
    compatible node and create LED device for each of them. We take care of
    all common DT properties (label, default trigger, state, etc.), however
    some triggers may want to support more of them.
    
    It could be useful for timer trigger to support setting delay on/off
    values with Device Tree property. Or for transient trigger to support
    e.g. duration property.
    
    We obviously should handle such properties in triggers, not in generic
    code. To let trigger drivers read properties from DT node we need to set
    of_node to point the relevant node. This change allows using all kind of
    of helpers in e.g. "activate" callbacks.
    
    Signed-off-by: Rafał Miłecki <zajec5@gmail.com>
    Signed-off-by: Jacek Anaszewski <j.anaszewski@samsung.com>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index 8229f063b483..9b991d46ed84 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -165,6 +165,7 @@ static struct gpio_leds_priv *gpio_leds_create(struct platform_device *pdev)
 		return ERR_PTR(-ENOMEM);
 
 	device_for_each_child_node(dev, child) {
+		struct gpio_led_data *led_dat = &priv->leds[priv->num_leds];
 		struct gpio_led led = {};
 		const char *state = NULL;
 
@@ -205,12 +206,12 @@ static struct gpio_leds_priv *gpio_leds_create(struct platform_device *pdev)
 		if (fwnode_property_present(child, "panic-indicator"))
 			led.panic_indicator = 1;
 
-		ret = create_gpio_led(&led, &priv->leds[priv->num_leds],
-				      dev, NULL);
+		ret = create_gpio_led(&led, led_dat, dev, NULL);
 		if (ret < 0) {
 			fwnode_handle_put(child);
 			goto err;
 		}
+		led_dat->cdev.dev->of_node = np;
 		priv->num_leds++;
 	}
 

commit 80d6737b27bbdf645a815c136606836b435f0268
Author: Ezequiel Garcia <ezequiel@vanguardiasur.com.ar>
Date:   Thu Apr 28 19:03:40 2016 -0300

    leds: gpio: Support the "panic-indicator" firmware property
    
    Calling a GPIO LEDs is quite likely to work even if the kernel
    has paniced, so they are ideal to blink in this situation.
    This commit adds support for the new "panic-indicator"
    firmware property, allowing to mark a given LED to blink on
    a kernel panic.
    
    Signed-off-by: Ezequiel Garcia <ezequiel@vanguardiasur.com.ar>
    Reviewed-by: Matthias Brugger <mbrugger@suse.com>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Jacek Anaszewski <j.anaszewski@samsung.com>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index 61143f55597e..8229f063b483 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -127,6 +127,8 @@ static int create_gpio_led(const struct gpio_led *template,
 	led_dat->cdev.brightness = state ? LED_FULL : LED_OFF;
 	if (!template->retain_state_suspended)
 		led_dat->cdev.flags |= LED_CORE_SUSPENDRESUME;
+	if (template->panic_indicator)
+		led_dat->cdev.flags |= LED_PANIC_INDICATOR;
 
 	ret = gpiod_direction_output(led_dat->gpiod, state);
 	if (ret < 0)
@@ -200,6 +202,8 @@ static struct gpio_leds_priv *gpio_leds_create(struct platform_device *pdev)
 
 		if (fwnode_property_present(child, "retain-state-suspended"))
 			led.retain_state_suspended = 1;
+		if (fwnode_property_present(child, "panic-indicator"))
+			led.panic_indicator = 1;
 
 		ret = create_gpio_led(&led, &priv->leds[priv->num_leds],
 				      dev, NULL);

commit eae7c98acd13b35bc37608a430086b417b1150fe
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Fri Feb 19 10:52:34 2016 +0100

    leds: gpio: Use GPIOF_OUT_INIT_LOW instead of hardcoded zero
    
    Use the GPIO flag definition instead of a numeric literal, so the casual
    reader grepping for GPIOF_ will find the GPIO flags used.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Jacek Anaszewski <j.anaszewski@samsung.com>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index 5883dede3423..61143f55597e 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -86,7 +86,7 @@ static int create_gpio_led(const struct gpio_led *template,
 		 * still uses GPIO numbers. Ultimately we would like to get
 		 * rid of this block completely.
 		 */
-		unsigned long flags = 0;
+		unsigned long flags = GPIOF_OUT_INIT_LOW;
 
 		/* skip leds that aren't available */
 		if (!gpio_is_valid(template->gpio)) {

commit 2d88a331e48095cf60ad9bdf3177bd401bf99727
Author: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
Date:   Sat Feb 6 22:37:33 2016 +0800

    leds: leds-gpio: Fix return value check in create_gpio_led()
    
    In case of error, the function gpio_to_desc() returns NULL
    pointer not ERR_PTR(). The IS_ERR() test in the return value
    check should be replaced with NULL test.
    
    Signed-off-by: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
    Signed-off-by: Jacek Anaszewski <j.anaszewski@samsung.com>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index 7bc53280dbfd..5883dede3423 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -104,8 +104,8 @@ static int create_gpio_led(const struct gpio_led *template,
 			return ret;
 
 		led_dat->gpiod = gpio_to_desc(template->gpio);
-		if (IS_ERR(led_dat->gpiod))
-			return PTR_ERR(led_dat->gpiod);
+		if (!led_dat->gpiod)
+			return -EINVAL;
 	}
 
 	led_dat->cdev.name = template->name;

commit d5b8a09000da3dcd79649293121afe4439153c7a
Author: Jacek Anaszewski <j.anaszewski@samsung.com>
Date:   Thu Aug 20 15:52:32 2015 +0200

    leds: gpio: Remove work queue
    
    Now the core implements the work queue, remove it from the drivers,
    and switch to using brightness_set_blocking op.
    
    Signed-off-by: Jacek Anaszewski <j.anaszewski@samsung.com>
    Cc: Raphael Assenat <raph@8d.com>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index 5db4515a4fd7..7bc53280dbfd 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -20,32 +20,16 @@
 #include <linux/platform_device.h>
 #include <linux/property.h>
 #include <linux/slab.h>
-#include <linux/workqueue.h>
 
 struct gpio_led_data {
 	struct led_classdev cdev;
 	struct gpio_desc *gpiod;
-	struct work_struct work;
-	u8 new_level;
 	u8 can_sleep;
 	u8 blinking;
 	int (*platform_gpio_blink_set)(struct gpio_desc *desc, int state,
 			unsigned long *delay_on, unsigned long *delay_off);
 };
 
-static void gpio_led_work(struct work_struct *work)
-{
-	struct gpio_led_data *led_dat =
-		container_of(work, struct gpio_led_data, work);
-
-	if (led_dat->blinking) {
-		led_dat->platform_gpio_blink_set(led_dat->gpiod,
-					led_dat->new_level, NULL, NULL);
-		led_dat->blinking = 0;
-	} else
-		gpiod_set_value_cansleep(led_dat->gpiod, led_dat->new_level);
-}
-
 static void gpio_led_set(struct led_classdev *led_cdev,
 	enum led_brightness value)
 {
@@ -58,23 +42,25 @@ static void gpio_led_set(struct led_classdev *led_cdev,
 	else
 		level = 1;
 
-	/* Setting GPIOs with I2C/etc requires a task context, and we don't
-	 * seem to have a reliable way to know if we're already in one; so
-	 * let's just assume the worst.
-	 */
-	if (led_dat->can_sleep) {
-		led_dat->new_level = level;
-		schedule_work(&led_dat->work);
+	if (led_dat->blinking) {
+		led_dat->platform_gpio_blink_set(led_dat->gpiod, level,
+						 NULL, NULL);
+		led_dat->blinking = 0;
 	} else {
-		if (led_dat->blinking) {
-			led_dat->platform_gpio_blink_set(led_dat->gpiod, level,
-							 NULL, NULL);
-			led_dat->blinking = 0;
-		} else
+		if (led_dat->can_sleep)
+			gpiod_set_value_cansleep(led_dat->gpiod, level);
+		else
 			gpiod_set_value(led_dat->gpiod, level);
 	}
 }
 
+static int gpio_led_set_blocking(struct led_classdev *led_cdev,
+	enum led_brightness value)
+{
+	gpio_led_set(led_cdev, value);
+	return 0;
+}
+
 static int gpio_blink_set(struct led_classdev *led_cdev,
 	unsigned long *delay_on, unsigned long *delay_off)
 {
@@ -125,12 +111,15 @@ static int create_gpio_led(const struct gpio_led *template,
 	led_dat->cdev.name = template->name;
 	led_dat->cdev.default_trigger = template->default_trigger;
 	led_dat->can_sleep = gpiod_cansleep(led_dat->gpiod);
+	if (!led_dat->can_sleep)
+		led_dat->cdev.brightness_set = gpio_led_set;
+	else
+		led_dat->cdev.brightness_set_blocking = gpio_led_set_blocking;
 	led_dat->blinking = 0;
 	if (blink_set) {
 		led_dat->platform_gpio_blink_set = blink_set;
 		led_dat->cdev.blink_set = gpio_blink_set;
 	}
-	led_dat->cdev.brightness_set = gpio_led_set;
 	if (template->default_state == LEDS_GPIO_DEFSTATE_KEEP)
 		state = !!gpiod_get_value_cansleep(led_dat->gpiod);
 	else
@@ -143,17 +132,9 @@ static int create_gpio_led(const struct gpio_led *template,
 	if (ret < 0)
 		return ret;
 
-	INIT_WORK(&led_dat->work, gpio_led_work);
-
 	return led_classdev_register(parent, &led_dat->cdev);
 }
 
-static void delete_gpio_led(struct gpio_led_data *led)
-{
-	led_classdev_unregister(&led->cdev);
-	cancel_work_sync(&led->work);
-}
-
 struct gpio_leds_priv {
 	int num_leds;
 	struct gpio_led_data leds[];
@@ -233,7 +214,7 @@ static struct gpio_leds_priv *gpio_leds_create(struct platform_device *pdev)
 
 err:
 	for (count = priv->num_leds - 1; count >= 0; count--)
-		delete_gpio_led(&priv->leds[count]);
+		led_classdev_unregister(&priv->leds[count].cdev);
 	return ERR_PTR(ret);
 }
 
@@ -265,7 +246,8 @@ static int gpio_led_probe(struct platform_device *pdev)
 			if (ret < 0) {
 				/* On failure: unwind the led creations */
 				for (i = i - 1; i >= 0; i--)
-					delete_gpio_led(&priv->leds[i]);
+					led_classdev_unregister(
+							&priv->leds[i].cdev);
 				return ret;
 			}
 		}
@@ -286,7 +268,7 @@ static int gpio_led_remove(struct platform_device *pdev)
 	int i;
 
 	for (i = 0; i < priv->num_leds; i++)
-		delete_gpio_led(&priv->leds[i]);
+		led_classdev_unregister(&priv->leds[i].cdev);
 
 	return 0;
 }

commit 707f33ed85ff423016674d27bb2e60fe8fa352ce
Author: Heiko Schocher <hs@denx.de>
Date:   Tue Oct 13 07:17:12 2015 +0200

    leds: leds-gpio: add shutdown function
    
    add a shutdown function for setting the gpio-leds
    into off state when shuting down.
    
    Signed-off-by: Heiko Schocher <hs@denx.de>
    Signed-off-by: Jacek Anaszewski <j.anaszewski@samsung.com>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index af1876a3a77c..5db4515a4fd7 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -291,9 +291,22 @@ static int gpio_led_remove(struct platform_device *pdev)
 	return 0;
 }
 
+static void gpio_led_shutdown(struct platform_device *pdev)
+{
+	struct gpio_leds_priv *priv = platform_get_drvdata(pdev);
+	int i;
+
+	for (i = 0; i < priv->num_leds; i++) {
+		struct gpio_led_data *led = &priv->leds[i];
+
+		gpio_led_set(&led->cdev, LED_OFF);
+	}
+}
+
 static struct platform_driver gpio_led_driver = {
 	.probe		= gpio_led_probe,
 	.remove		= gpio_led_remove,
+	.shutdown	= gpio_led_shutdown,
 	.driver		= {
 		.name	= "leds-gpio",
 		.of_match_table = of_gpio_leds_match,

commit 13d45f79a2af84de9083310db58b309a61065208
Merge: 05fde26a943a b67893206fc0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jul 1 19:09:11 2015 -0700

    Merge branch 'for-next' of git://git.kernel.org/pub/scm/linux/kernel/git/cooloney/linux-leds
    
    Pull LED subsystem updates from Bryan Wu:
     "In this cycle, we finished to merge patches for LED Flash class
      driver.
    
      Other than that we have some bug fixes and new drivers for LED
      controllers"
    
    * 'for-next' of git://git.kernel.org/pub/scm/linux/kernel/git/cooloney/linux-leds: (33 commits)
      leds:lp55xx: fix firmware loading error
      leds: fix max77693-led build errors
      leds: fix aat1290 build errors
      leds: aat1290: pass flags parameter to devm_gpiod_get
      leds: ktd2692: pass flags parameter to devm_gpiod_get
      drivers/leds: don't use module_init in non-modular leds-cobalt-raq.c
      leds: aat1290: add support for V4L2 Flash sub-device
      DT: aat1290: Document handling external strobe sources
      leds: max77693: add support for V4L2 Flash sub-device
      media: Add registration helpers for V4L2 flash sub-devices
      v4l: async: Add a pointer to of_node to struct v4l2_subdev, match it
      Documentation: leds: Add description of v4l2-flash sub-device
      leds: add BCM6358 LED driver
      leds: add DT binding for BCM6358 LED controller
      leds: fix brightness changing when software blinking is active
      Documentation: leds-lp5523: describe master fader attributes
      leds: lp5523: add master_fader support
      leds: leds-gpio: Allow compile test if !GPIOLIB
      leds: leds-gpio: Add missing #include <linux/of.h>
      gpiolib: Add missing dummies for the unified device properties interface
      ...

commit c181fb3e723351e2f7a1f76b6c0627a4b8ad1723
Author: Alexander Sverdlin <alexander.sverdlin@gmail.com>
Date:   Mon Jun 22 22:38:53 2015 +0200

    ACPI / OF: Rename of_node() and acpi_node() to to_of_node() and to_acpi_node()
    
    Commit 8a0662d9 introduced of_node and acpi_node symbols in global namespace
    but there were already ~63 of_node local variables or function parameters
    (no single acpi_node though, but anyway).
    
    After debugging undefined but used of_node local varible (which turned out
    to reference static function of_node() instead) it became clear that the names
    for the functions are too short and too generic for global scope.
    
    Signed-off-by: Alexander Sverdlin <alexander.sverdlin@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index 15eb3f86f670..d2d54d62afee 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -191,7 +191,7 @@ static struct gpio_leds_priv *gpio_leds_create(struct platform_device *pdev)
 			goto err;
 		}
 
-		np = of_node(child);
+		np = to_of_node(child);
 
 		if (fwnode_property_present(child, "label")) {
 			fwnode_property_read_string(child, "label", &led.name);

commit 403097f7205dcf8e6a53091063b6a4b847d35484
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Thu May 7 01:08:09 2015 -0700

    leds: leds-gpio: Add missing #include <linux/of.h>
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Acked-by: Jacek Anaszewski <j.anaszewski@samsung.com>
    Signed-off-by: Bryan Wu <cooloney@gmail.com>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index c3db74a1aba7..3af4f2bff83f 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -16,6 +16,7 @@
 #include <linux/kernel.h>
 #include <linux/leds.h>
 #include <linux/module.h>
+#include <linux/of.h>
 #include <linux/platform_device.h>
 #include <linux/property.h>
 #include <linux/slab.h>

commit 0e14e0bfe85dd22ba19446bdfdc2cf0e941b9731
Author: Jacek Anaszewski <j.anaszewski@samsung.com>
Date:   Thu Apr 16 00:30:50 2015 -0700

    leds: gpio: Fix error handling for led name null pointer case
    
    Make sure that already registered LEDs will be torn down properly
    if the name of the next LED to create is unavailable.
    
    Signed-off-by: Jacek Anaszewski <j.anaszewski@samsung.com>
    Cc: Richard Purdie <rpurdie@rpsys.net>
    Signed-off-by: Bryan Wu <cooloney@gmail.com>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index 25df4a240972..c3db74a1aba7 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -198,8 +198,10 @@ static struct gpio_leds_priv *gpio_leds_create(struct platform_device *pdev)
 		} else {
 			if (IS_ENABLED(CONFIG_OF) && !led.name && np)
 				led.name = np->name;
-			if (!led.name)
-				return ERR_PTR(-EINVAL);
+			if (!led.name) {
+				ret = -EINVAL;
+				goto err;
+			}
 		}
 		fwnode_property_read_string(child, "linux,default-trigger",
 					    &led.default_trigger);

commit 65c6b7e3ab70effc150dacc9c2fbd6581925dd53
Author: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
Date:   Tue Apr 14 14:23:30 2015 -0700

    leds: gpio: Fix device teardown on probe deferral
    
    In gpio_leds_create(), when devm_get_gpiod_from_child() fails with
    -EPROBE_DEFER on the second gpio led to be created, the first already
    registered led is not torn down properly. This causes create_gpio_led()
    to fail for the first led on re-probe().
    
    Fix this misbehaviour by incrementing num_leds only if all
    potentially failing calls completed successfully.
    
    Signed-off-by: Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
    Acked-by: Jacek Anaszewski <j.anaszewski@samsung.com>
    Signed-off-by: Bryan Wu <cooloney@gmail.com>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index 15eb3f86f670..25df4a240972 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -217,18 +217,19 @@ static struct gpio_leds_priv *gpio_leds_create(struct platform_device *pdev)
 		if (fwnode_property_present(child, "retain-state-suspended"))
 			led.retain_state_suspended = 1;
 
-		ret = create_gpio_led(&led, &priv->leds[priv->num_leds++],
+		ret = create_gpio_led(&led, &priv->leds[priv->num_leds],
 				      dev, NULL);
 		if (ret < 0) {
 			fwnode_handle_put(child);
 			goto err;
 		}
+		priv->num_leds++;
 	}
 
 	return priv;
 
 err:
-	for (count = priv->num_leds - 2; count >= 0; count--)
+	for (count = priv->num_leds - 1; count >= 0; count--)
 		delete_gpio_led(&priv->leds[count]);
 	return ERR_PTR(ret);
 }

commit 1feb57a245a4910b03202a814ffc51a900bd4aca
Author: Olliver Schinagl <oliver@schinagl.nl>
Date:   Wed Jan 21 22:33:46 2015 +0100

    gpio: add parameter to allow the use named gpios
    
    The gpio binding document says that new code should always use named
    gpios. Patch 40b73183 added support to parse a list of gpios from child
    nodes, but does not make it possible to use named gpios. This patch adds
    the con_id property and implements it is done in gpiolib.c, where the
    old-style of using unnamed gpios still works.
    
    Signed-off-by: Olliver Schinagl <oliver@schinagl.nl>
    Acked-by: Bryan Wu <cooloney@gmail.com>
    Acked-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Reviewed-by: Alexandre Courbot <acourbot@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index d26af0a79a90..15eb3f86f670 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -184,7 +184,7 @@ static struct gpio_leds_priv *gpio_leds_create(struct platform_device *pdev)
 		struct gpio_led led = {};
 		const char *state = NULL;
 
-		led.gpiod = devm_get_gpiod_from_child(dev, child);
+		led.gpiod = devm_get_gpiod_from_child(dev, NULL, child);
 		if (IS_ERR(led.gpiod)) {
 			fwnode_handle_put(child);
 			ret = PTR_ERR(led.gpiod);

commit c6e71f813f7208d80bfe0f435d627fad1b204558
Author: Soren Brinkmann <soren.brinkmann@xilinx.com>
Date:   Sat Jan 31 19:15:00 2015 -0800

    leds: leds-gpio: Pass on error codes unmodified
    
    Instead of overriding error codes, pass them on unmodified. This
    way a EPROBE_DEFER is correctly passed to the driver core. This results
    in the LED driver correctly requesting probe deferral in cases the GPIO
    controller is not yet available.
    
    Signed-off-by: Soren Brinkmann <soren.brinkmann@xilinx.com>
    Reported-and-tested-by: Andreas Färber <afaerber@suse.de>
    Signed-off-by: Bryan Wu <cooloney@gmail.com>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index 7ea1ea42c2d2..d26af0a79a90 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -187,6 +187,7 @@ static struct gpio_leds_priv *gpio_leds_create(struct platform_device *pdev)
 		led.gpiod = devm_get_gpiod_from_child(dev, child);
 		if (IS_ERR(led.gpiod)) {
 			fwnode_handle_put(child);
+			ret = PTR_ERR(led.gpiod);
 			goto err;
 		}
 
@@ -229,7 +230,7 @@ static struct gpio_leds_priv *gpio_leds_create(struct platform_device *pdev)
 err:
 	for (count = priv->num_leds - 2; count >= 0; count--)
 		delete_gpio_led(&priv->leds[count]);
-	return ERR_PTR(-ENODEV);
+	return ERR_PTR(ret);
 }
 
 static const struct of_device_id of_gpio_leds_match[] = {

commit c0f486fde3f353232c1cc2fd4d62783ac782a467
Merge: 385336e321c4 2ec1c17cadd0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Dec 18 20:28:33 2014 -0800

    Merge tag 'pm+acpi-3.19-rc1-2' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull more ACPI and power management updates from Rafael Wysocki:
     "These are regression fixes (leds-gpio, ACPI backlight driver,
      operating performance points library, ACPI device enumeration
      messages, cpupower tool), other bug fixes (ACPI EC driver, ACPI device
      PM), some cleanups in the operating performance points (OPP)
      framework, continuation of CONFIG_PM_RUNTIME elimination, a couple of
      minor intel_pstate driver changes, a new MAINTAINERS entry for it and
      an ACPI fan driver change needed for better support of thermal
      management in user space.
    
      Specifics:
    
       - Fix a regression in leds-gpio introduced by a recent commit that
         inadvertently changed the name of one of the properties used by the
         driver (Fabio Estevam).
    
       - Fix a regression in the ACPI backlight driver introduced by a
         recent fix that missed one special case that had to be taken into
         account (Aaron Lu).
    
       - Drop the level of some new kernel messages from the ACPI core
         introduced by a recent commit to KERN_DEBUG which they should have
         used from the start and drop some other unuseful KERN_ERR messages
         printed by ACPI (Rafael J Wysocki).
    
       - Revert an incorrect commit modifying the cpupower tool (Prarit
         Bhargava).
    
       - Fix two regressions introduced by recent commits in the OPP library
         and clean up some existing minor issues in that code (Viresh
         Kumar).
    
       - Continue to replace CONFIG_PM_RUNTIME with CONFIG_PM throughout the
         tree (or drop it where that can be done) in order to make it
         possible to eliminate CONFIG_PM_RUNTIME (Rafael J Wysocki, Ulf
         Hansson, Ludovic Desroches).
    
         There will be one more "CONFIG_PM_RUNTIME removal" batch after this
         one, because some new uses of it have been introduced during the
         current merge window, but that should be sufficient to finally get
         rid of it.
    
       - Make the ACPI EC driver more robust against race conditions related
         to GPE handler installation failures (Lv Zheng).
    
       - Prevent the ACPI device PM core code from attempting to disable
         GPEs that it has not enabled which confuses ACPICA and makes it
         report errors unnecessarily (Rafael J Wysocki).
    
       - Add a "force" command line switch to the intel_pstate driver to
         make it possible to override the blacklisting of some systems in
         that driver if needed (Ethan Zhao).
    
       - Improve intel_pstate code documentation and add a MAINTAINERS entry
         for it (Kristen Carlson Accardi).
    
       - Make the ACPI fan driver create cooling device interfaces witn
         names that reflect the IDs of the ACPI device objects they are
         associated with, except for "generic" ACPI fans (PNP ID "PNP0C0B").
    
         That's necessary for user space thermal management tools to be able
         to connect the fans with the parts of the system they are supposed
         to be cooling properly.  From Srinivas Pandruvada"
    
    * tag 'pm+acpi-3.19-rc1-2' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (32 commits)
      MAINTAINERS: add entry for intel_pstate
      ACPI / video: update the skip case for acpi_video_device_in_dod()
      power / PM: Eliminate CONFIG_PM_RUNTIME
      NFC / PM: Replace CONFIG_PM_RUNTIME with CONFIG_PM
      SCSI / PM: Replace CONFIG_PM_RUNTIME with CONFIG_PM
      ACPI / EC: Fix unexpected ec_remove_handlers() invocations
      Revert "tools: cpupower: fix return checks for sysfs_get_idlestate_count()"
      tracing / PM: Replace CONFIG_PM_RUNTIME with CONFIG_PM
      x86 / PM: Replace CONFIG_PM_RUNTIME in io_apic.c
      PM: Remove the SET_PM_RUNTIME_PM_OPS() macro
      mmc: atmel-mci: use SET_RUNTIME_PM_OPS() macro
      PM / Kconfig: Replace PM_RUNTIME with PM in dependencies
      ARM / PM: Replace CONFIG_PM_RUNTIME with CONFIG_PM
      sound / PM: Replace CONFIG_PM_RUNTIME with CONFIG_PM
      phy / PM: Replace CONFIG_PM_RUNTIME with CONFIG_PM
      video / PM: Replace CONFIG_PM_RUNTIME with CONFIG_PM
      tty / PM: Replace CONFIG_PM_RUNTIME with CONFIG_PM
      spi: Replace CONFIG_PM_RUNTIME with CONFIG_PM
      ACPI / PM: Do not disable wakeup GPEs that have not been enabled
      ACPI / utils: Drop error messages from acpi_evaluate_reference()
      ...

commit e6b5be2be4e30037eb551e0ed09dd97bd00d85d3
Merge: 37da7bbbe84f f1c488a78d9f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Dec 14 16:10:09 2014 -0800

    Merge tag 'driver-core-3.19-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core
    
    Pull driver core update from Greg KH:
     "Here's the set of driver core patches for 3.19-rc1.
    
      They are dominated by the removal of the .owner field in platform
      drivers.  They touch a lot of files, but they are "simple" changes,
      just removing a line in a structure.
    
      Other than that, a few minor driver core and debugfs changes.  There
      are some ath9k patches coming in through this tree that have been
      acked by the wireless maintainers as they relied on the debugfs
      changes.
    
      Everything has been in linux-next for a while"
    
    * tag 'driver-core-3.19-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core: (324 commits)
      Revert "ath: ath9k: use debugfs_create_devm_seqfile() helper for seq_file entries"
      fs: debugfs: add forward declaration for struct device type
      firmware class: Deletion of an unnecessary check before the function call "vunmap"
      firmware loader: fix hung task warning dump
      devcoredump: provide a one-way disable function
      device: Add dev_<level>_once variants
      ath: ath9k: use debugfs_create_devm_seqfile() helper for seq_file entries
      ath: use seq_file api for ath9k debugfs files
      debugfs: add helper function to create device related seq_file
      drivers/base: cacheinfo: remove noisy error boot message
      Revert "core: platform: add warning if driver has no owner"
      drivers: base: support cpu cache information interface to userspace via sysfs
      drivers: base: add cpu_device_create to support per-cpu devices
      topology: replace custom attribute macros with standard DEVICE_ATTR*
      cpumask: factor out show_cpumap into separate helper function
      driver core: Fix unbalanced device reference in drivers_probe
      driver core: fix race with userland in device_add()
      sysfs/kernfs: make read requests on pre-alloc files use the buffer.
      sysfs/kernfs: allow attributes to request write buffer be pre-allocated.
      fs: sysfs: return EGBIG on write if offset is larger than file size
      ...

commit d735d25e60fffeffc256fa5d59551dc92dc07e36
Author: Fabio Estevam <fabio.estevam@freescale.com>
Date:   Wed Dec 10 01:57:07 2014 +0100

    leds: leds-gpio: Fix the "default-state" property check
    
    Commit a43f2cbbb009f9 ("leds: leds-gpio: Make use of device property API")
    caused a regression by reading the incorrect string for the "default-state"
    property.
    
    Fix the property string check to restore the original behaviour.
    
    Fixes: a43f2cbbb009 (leds: leds-gpio: Make use of device property API)
    Reported-by: Jean-Michel Hautbois <jean-michel.hautbois@vodalys.com>
    Signed-off-by: Fabio Estevam <fabio.estevam@freescale.com>
    Acked-by: Bryan Wu <cooloney@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index 868e6fc17cba..5fb4440127d9 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -203,7 +203,7 @@ static struct gpio_leds_priv *gpio_leds_create(struct platform_device *pdev)
 		fwnode_property_read_string(child, "linux,default-trigger",
 					    &led.default_trigger);
 
-		if (!fwnode_property_read_string(child, "linux,default_state",
+		if (!fwnode_property_read_string(child, "default-state",
 						 &state)) {
 			if (!strcmp(state, "keep"))
 				led.default_state = LEDS_GPIO_DEFSTATE_KEEP;

commit 29470ea8d828e4dec74e94f7f17b7479ff5ef276
Author: Fabio Estevam <fabio.estevam@freescale.com>
Date:   Thu Dec 4 02:28:19 2014 +0100

    leds: leds-gpio: Fix multiple instances registration without 'label' property
    
    Since commit a43f2cbbb009f96 ("leds: leds-gpio: Make use of device property
    API") it is no longer possible to register multiple gpio leds without passing
    the 'label' property.
    
    According to Documentation/devicetree/bindings/leds/common.txt:
    
    "Optional properties for child nodes:
    - label : The label for this LED.  If omitted, the label is
      taken from the node name (excluding the unit address)."
    
    So retrieve the node name when the 'label' property is absent to keep the old
    behaviour and fix this regression.
    
    Fixes: a43f2cbbb009 (leds: leds-gpio: Make use of device property API)
    Reported-by: Jean-Michel Hautbois <jean-michel.hautbois@vodalys.com>
    Signed-off-by: Fabio Estevam <fabio.estevam@freescale.com>
    Acked-by: Grant Likely <grant.likely@linaro.org>
    Acked-by: Bryan Wu <cooloney@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index b3c5d9d6a42b..868e6fc17cba 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -170,6 +170,7 @@ static struct gpio_leds_priv *gpio_leds_create(struct platform_device *pdev)
 	struct fwnode_handle *child;
 	struct gpio_leds_priv *priv;
 	int count, ret;
+	struct device_node *np;
 
 	count = device_get_child_node_count(dev);
 	if (!count)
@@ -189,7 +190,16 @@ static struct gpio_leds_priv *gpio_leds_create(struct platform_device *pdev)
 			goto err;
 		}
 
-		fwnode_property_read_string(child, "label", &led.name);
+		np = of_node(child);
+
+		if (fwnode_property_present(child, "label")) {
+			fwnode_property_read_string(child, "label", &led.name);
+		} else {
+			if (IS_ENABLED(CONFIG_OF) && !led.name && np)
+				led.name = np->name;
+			if (!led.name)
+				return ERR_PTR(-EINVAL);
+		}
 		fwnode_property_read_string(child, "linux,default-trigger",
 					    &led.default_trigger);
 

commit ec98a4975e66a3aa366cd227edab027b01adea37
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Thu Nov 6 12:23:23 2014 +0100

    leds: leds-gpio: Fix legacy GPIO number case
    
    In the legacy case, led_dat->gpiod is initialized correctly, but
    overwritten later by template->gpiod, which is NULL, causing leds-gpio
    to fail with:
    
        gpiod_direction_output: invalid GPIO
        leds-gpio: probe of leds-gpio failed with error -22
    
    Move the initialization of led_dat->gpiod from template->gpiod up, and
    always use led_dat->gpiod later, to fix this.
    
    Fixes: 5c51277a9ababfa4 (leds: leds-gpio: Add support for GPIO descriptors)
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index ba4698c32bb0..b3c5d9d6a42b 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -92,7 +92,8 @@ static int create_gpio_led(const struct gpio_led *template,
 {
 	int ret, state;
 
-	if (!template->gpiod) {
+	led_dat->gpiod = template->gpiod;
+	if (!led_dat->gpiod) {
 		/*
 		 * This is the legacy code path for platform code that
 		 * still uses GPIO numbers. Ultimately we would like to get
@@ -122,8 +123,7 @@ static int create_gpio_led(const struct gpio_led *template,
 
 	led_dat->cdev.name = template->name;
 	led_dat->cdev.default_trigger = template->default_trigger;
-	led_dat->gpiod = template->gpiod;
-	led_dat->can_sleep = gpiod_cansleep(template->gpiod);
+	led_dat->can_sleep = gpiod_cansleep(led_dat->gpiod);
 	led_dat->blinking = 0;
 	if (blink_set) {
 		led_dat->platform_gpio_blink_set = blink_set;

commit c673a2b4008103525a3cf21bedf15ffac37bfef0
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Fri Oct 31 13:40:58 2014 +0200

    leds: leds-gpio: Convert gpio_blink_set() to use GPIO descriptors
    
    Commit 21f2aae91e902aad ("leds: leds-gpio: Add support for GPIO
    descriptors") already converted most of the driver to use GPIO descriptors.
    What is still missing is the platform specific hook gpio_blink_set() and
    board files which pass legacy GPIO numbers to this driver in platform data.
    
    In this patch we handle the former and convert gpio_blink_set() to take
    GPIO descriptor instead. In order to do this we convert the existing four
    users to accept GPIO descriptor and translate it to legacy GPIO number in
    the platform code. This effectively "pushes" legacy GPIO number usage from
    the driver to platforms.
    
    Also add comment to the remaining block describing that it is legacy code
    path and we are getting rid of it eventually.
    
    Suggested-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Alexandre Courbot <acourbot@nvidia.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index edd370dbb22f..ba4698c32bb0 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -28,7 +28,7 @@ struct gpio_led_data {
 	u8 new_level;
 	u8 can_sleep;
 	u8 blinking;
-	int (*platform_gpio_blink_set)(unsigned gpio, int state,
+	int (*platform_gpio_blink_set)(struct gpio_desc *desc, int state,
 			unsigned long *delay_on, unsigned long *delay_off);
 };
 
@@ -38,13 +38,8 @@ static void gpio_led_work(struct work_struct *work)
 		container_of(work, struct gpio_led_data, work);
 
 	if (led_dat->blinking) {
-		int gpio = desc_to_gpio(led_dat->gpiod);
-		int level = led_dat->new_level;
-
-		if (gpiod_is_active_low(led_dat->gpiod))
-			level = !level;
-
-		led_dat->platform_gpio_blink_set(gpio, level, NULL, NULL);
+		led_dat->platform_gpio_blink_set(led_dat->gpiod,
+					led_dat->new_level, NULL, NULL);
 		led_dat->blinking = 0;
 	} else
 		gpiod_set_value_cansleep(led_dat->gpiod, led_dat->new_level);
@@ -71,13 +66,8 @@ static void gpio_led_set(struct led_classdev *led_cdev,
 		schedule_work(&led_dat->work);
 	} else {
 		if (led_dat->blinking) {
-			int gpio = desc_to_gpio(led_dat->gpiod);
-
-			if (gpiod_is_active_low(led_dat->gpiod))
-				level = !level;
-
-			led_dat->platform_gpio_blink_set(gpio, level, NULL,
-							 NULL);
+			led_dat->platform_gpio_blink_set(led_dat->gpiod, level,
+							 NULL, NULL);
 			led_dat->blinking = 0;
 		} else
 			gpiod_set_value(led_dat->gpiod, level);
@@ -89,20 +79,25 @@ static int gpio_blink_set(struct led_classdev *led_cdev,
 {
 	struct gpio_led_data *led_dat =
 		container_of(led_cdev, struct gpio_led_data, cdev);
-	int gpio = desc_to_gpio(led_dat->gpiod);
 
 	led_dat->blinking = 1;
-	return led_dat->platform_gpio_blink_set(gpio, GPIO_LED_BLINK,
+	return led_dat->platform_gpio_blink_set(led_dat->gpiod, GPIO_LED_BLINK,
 						delay_on, delay_off);
 }
 
 static int create_gpio_led(const struct gpio_led *template,
 	struct gpio_led_data *led_dat, struct device *parent,
-	int (*blink_set)(unsigned, int, unsigned long *, unsigned long *))
+	int (*blink_set)(struct gpio_desc *, int, unsigned long *,
+			 unsigned long *))
 {
 	int ret, state;
 
 	if (!template->gpiod) {
+		/*
+		 * This is the legacy code path for platform code that
+		 * still uses GPIO numbers. Ultimately we would like to get
+		 * rid of this block completely.
+		 */
 		unsigned long flags = 0;
 
 		/* skip leds that aren't available */

commit a43f2cbbb009f96231bbbe24ad4f824215dedb81
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Oct 27 23:30:10 2014 +0100

    leds: leds-gpio: Make use of device property API
    
    Make use of device property API in this driver so that both OF and ACPI
    based system can use the same driver.
    
    This change contains material from Max Eliaser and Mika Westerberg.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Bryan Wu <cooloney@gmail.com>
    Acked-by: Grant Likely <grant.likely@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index 1ff95ce9487a..edd370dbb22f 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -16,10 +16,8 @@
 #include <linux/kernel.h>
 #include <linux/leds.h>
 #include <linux/module.h>
-#include <linux/of.h>
-#include <linux/of_gpio.h>
-#include <linux/of_platform.h>
 #include <linux/platform_device.h>
+#include <linux/property.h>
 #include <linux/slab.h>
 #include <linux/workqueue.h>
 
@@ -171,40 +169,37 @@ static inline int sizeof_gpio_leds_priv(int num_leds)
 		(sizeof(struct gpio_led_data) * num_leds);
 }
 
-/* Code to create from OpenFirmware platform devices */
-#ifdef CONFIG_OF_GPIO
-static struct gpio_leds_priv *gpio_leds_create_of(struct platform_device *pdev)
+static struct gpio_leds_priv *gpio_leds_create(struct platform_device *pdev)
 {
-	struct device_node *np = pdev->dev.of_node, *child;
+	struct device *dev = &pdev->dev;
+	struct fwnode_handle *child;
 	struct gpio_leds_priv *priv;
 	int count, ret;
 
-	/* count LEDs in this device, so we know how much to allocate */
-	count = of_get_available_child_count(np);
+	count = device_get_child_node_count(dev);
 	if (!count)
 		return ERR_PTR(-ENODEV);
 
-	for_each_available_child_of_node(np, child)
-		if (of_get_gpio(child, 0) == -EPROBE_DEFER)
-			return ERR_PTR(-EPROBE_DEFER);
-
-	priv = devm_kzalloc(&pdev->dev, sizeof_gpio_leds_priv(count),
-			GFP_KERNEL);
+	priv = devm_kzalloc(dev, sizeof_gpio_leds_priv(count), GFP_KERNEL);
 	if (!priv)
 		return ERR_PTR(-ENOMEM);
 
-	for_each_available_child_of_node(np, child) {
+	device_for_each_child_node(dev, child) {
 		struct gpio_led led = {};
-		enum of_gpio_flags flags;
-		const char *state;
-
-		led.gpio = of_get_gpio_flags(child, 0, &flags);
-		led.active_low = flags & OF_GPIO_ACTIVE_LOW;
-		led.name = of_get_property(child, "label", NULL) ? : child->name;
-		led.default_trigger =
-			of_get_property(child, "linux,default-trigger", NULL);
-		state = of_get_property(child, "default-state", NULL);
-		if (state) {
+		const char *state = NULL;
+
+		led.gpiod = devm_get_gpiod_from_child(dev, child);
+		if (IS_ERR(led.gpiod)) {
+			fwnode_handle_put(child);
+			goto err;
+		}
+
+		fwnode_property_read_string(child, "label", &led.name);
+		fwnode_property_read_string(child, "linux,default-trigger",
+					    &led.default_trigger);
+
+		if (!fwnode_property_read_string(child, "linux,default_state",
+						 &state)) {
 			if (!strcmp(state, "keep"))
 				led.default_state = LEDS_GPIO_DEFSTATE_KEEP;
 			else if (!strcmp(state, "on"))
@@ -213,13 +208,13 @@ static struct gpio_leds_priv *gpio_leds_create_of(struct platform_device *pdev)
 				led.default_state = LEDS_GPIO_DEFSTATE_OFF;
 		}
 
-		if (of_get_property(child, "retain-state-suspended", NULL))
+		if (fwnode_property_present(child, "retain-state-suspended"))
 			led.retain_state_suspended = 1;
 
 		ret = create_gpio_led(&led, &priv->leds[priv->num_leds++],
-				      &pdev->dev, NULL);
+				      dev, NULL);
 		if (ret < 0) {
-			of_node_put(child);
+			fwnode_handle_put(child);
 			goto err;
 		}
 	}
@@ -238,12 +233,6 @@ static const struct of_device_id of_gpio_leds_match[] = {
 };
 
 MODULE_DEVICE_TABLE(of, of_gpio_leds_match);
-#else /* CONFIG_OF_GPIO */
-static struct gpio_leds_priv *gpio_leds_create_of(struct platform_device *pdev)
-{
-	return ERR_PTR(-ENODEV);
-}
-#endif /* CONFIG_OF_GPIO */
 
 static int gpio_led_probe(struct platform_device *pdev)
 {
@@ -271,7 +260,7 @@ static int gpio_led_probe(struct platform_device *pdev)
 			}
 		}
 	} else {
-		priv = gpio_leds_create_of(pdev);
+		priv = gpio_leds_create(pdev);
 		if (IS_ERR(priv))
 			return PTR_ERR(priv);
 	}
@@ -298,7 +287,7 @@ static struct platform_driver gpio_led_driver = {
 	.driver		= {
 		.name	= "leds-gpio",
 		.owner	= THIS_MODULE,
-		.of_match_table = of_match_ptr(of_gpio_leds_match),
+		.of_match_table = of_gpio_leds_match,
 	},
 };
 

commit 5c51277a9ababfa44a7f944100bdc9fbda139905
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Mon Oct 27 23:29:32 2014 +0100

    leds: leds-gpio: Add support for GPIO descriptors
    
    GPIO descriptors are the preferred way over legacy GPIO numbers
    nowadays. Convert the driver to use GPIO descriptors internally but
    still allow passing legacy GPIO numbers from platform data to support
    existing platforms.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Alexandre Courbot <acourbot@nvidia.com>
    Acked-by: Bryan Wu <cooloney@gmail.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Grant Likely <grant.likely@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index b4518c8751c8..1ff95ce9487a 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -12,6 +12,7 @@
  */
 #include <linux/err.h>
 #include <linux/gpio.h>
+#include <linux/gpio/consumer.h>
 #include <linux/kernel.h>
 #include <linux/leds.h>
 #include <linux/module.h>
@@ -24,11 +25,10 @@
 
 struct gpio_led_data {
 	struct led_classdev cdev;
-	unsigned gpio;
+	struct gpio_desc *gpiod;
 	struct work_struct work;
 	u8 new_level;
 	u8 can_sleep;
-	u8 active_low;
 	u8 blinking;
 	int (*platform_gpio_blink_set)(unsigned gpio, int state,
 			unsigned long *delay_on, unsigned long *delay_off);
@@ -40,12 +40,16 @@ static void gpio_led_work(struct work_struct *work)
 		container_of(work, struct gpio_led_data, work);
 
 	if (led_dat->blinking) {
-		led_dat->platform_gpio_blink_set(led_dat->gpio,
-						 led_dat->new_level,
-						 NULL, NULL);
+		int gpio = desc_to_gpio(led_dat->gpiod);
+		int level = led_dat->new_level;
+
+		if (gpiod_is_active_low(led_dat->gpiod))
+			level = !level;
+
+		led_dat->platform_gpio_blink_set(gpio, level, NULL, NULL);
 		led_dat->blinking = 0;
 	} else
-		gpio_set_value_cansleep(led_dat->gpio, led_dat->new_level);
+		gpiod_set_value_cansleep(led_dat->gpiod, led_dat->new_level);
 }
 
 static void gpio_led_set(struct led_classdev *led_cdev,
@@ -60,9 +64,6 @@ static void gpio_led_set(struct led_classdev *led_cdev,
 	else
 		level = 1;
 
-	if (led_dat->active_low)
-		level = !level;
-
 	/* Setting GPIOs with I2C/etc requires a task context, and we don't
 	 * seem to have a reliable way to know if we're already in one; so
 	 * let's just assume the worst.
@@ -72,11 +73,16 @@ static void gpio_led_set(struct led_classdev *led_cdev,
 		schedule_work(&led_dat->work);
 	} else {
 		if (led_dat->blinking) {
-			led_dat->platform_gpio_blink_set(led_dat->gpio, level,
-							 NULL, NULL);
+			int gpio = desc_to_gpio(led_dat->gpiod);
+
+			if (gpiod_is_active_low(led_dat->gpiod))
+				level = !level;
+
+			led_dat->platform_gpio_blink_set(gpio, level, NULL,
+							 NULL);
 			led_dat->blinking = 0;
 		} else
-			gpio_set_value(led_dat->gpio, level);
+			gpiod_set_value(led_dat->gpiod, level);
 	}
 }
 
@@ -85,9 +91,10 @@ static int gpio_blink_set(struct led_classdev *led_cdev,
 {
 	struct gpio_led_data *led_dat =
 		container_of(led_cdev, struct gpio_led_data, cdev);
+	int gpio = desc_to_gpio(led_dat->gpiod);
 
 	led_dat->blinking = 1;
-	return led_dat->platform_gpio_blink_set(led_dat->gpio, GPIO_LED_BLINK,
+	return led_dat->platform_gpio_blink_set(gpio, GPIO_LED_BLINK,
 						delay_on, delay_off);
 }
 
@@ -97,24 +104,33 @@ static int create_gpio_led(const struct gpio_led *template,
 {
 	int ret, state;
 
-	led_dat->gpio = -1;
+	if (!template->gpiod) {
+		unsigned long flags = 0;
 
-	/* skip leds that aren't available */
-	if (!gpio_is_valid(template->gpio)) {
-		dev_info(parent, "Skipping unavailable LED gpio %d (%s)\n",
-				template->gpio, template->name);
-		return 0;
-	}
+		/* skip leds that aren't available */
+		if (!gpio_is_valid(template->gpio)) {
+			dev_info(parent, "Skipping unavailable LED gpio %d (%s)\n",
+					template->gpio, template->name);
+			return 0;
+		}
 
-	ret = devm_gpio_request(parent, template->gpio, template->name);
-	if (ret < 0)
-		return ret;
+		if (template->active_low)
+			flags |= GPIOF_ACTIVE_LOW;
+
+		ret = devm_gpio_request_one(parent, template->gpio, flags,
+					    template->name);
+		if (ret < 0)
+			return ret;
+
+		led_dat->gpiod = gpio_to_desc(template->gpio);
+		if (IS_ERR(led_dat->gpiod))
+			return PTR_ERR(led_dat->gpiod);
+	}
 
 	led_dat->cdev.name = template->name;
 	led_dat->cdev.default_trigger = template->default_trigger;
-	led_dat->gpio = template->gpio;
-	led_dat->can_sleep = gpio_cansleep(template->gpio);
-	led_dat->active_low = template->active_low;
+	led_dat->gpiod = template->gpiod;
+	led_dat->can_sleep = gpiod_cansleep(template->gpiod);
 	led_dat->blinking = 0;
 	if (blink_set) {
 		led_dat->platform_gpio_blink_set = blink_set;
@@ -122,30 +138,24 @@ static int create_gpio_led(const struct gpio_led *template,
 	}
 	led_dat->cdev.brightness_set = gpio_led_set;
 	if (template->default_state == LEDS_GPIO_DEFSTATE_KEEP)
-		state = !!gpio_get_value_cansleep(led_dat->gpio) ^ led_dat->active_low;
+		state = !!gpiod_get_value_cansleep(led_dat->gpiod);
 	else
 		state = (template->default_state == LEDS_GPIO_DEFSTATE_ON);
 	led_dat->cdev.brightness = state ? LED_FULL : LED_OFF;
 	if (!template->retain_state_suspended)
 		led_dat->cdev.flags |= LED_CORE_SUSPENDRESUME;
 
-	ret = gpio_direction_output(led_dat->gpio, led_dat->active_low ^ state);
+	ret = gpiod_direction_output(led_dat->gpiod, state);
 	if (ret < 0)
 		return ret;
 
 	INIT_WORK(&led_dat->work, gpio_led_work);
 
-	ret = led_classdev_register(parent, &led_dat->cdev);
-	if (ret < 0)
-		return ret;
-
-	return 0;
+	return led_classdev_register(parent, &led_dat->cdev);
 }
 
 static void delete_gpio_led(struct gpio_led_data *led)
 {
-	if (!gpio_is_valid(led->gpio))
-		return;
 	led_classdev_unregister(&led->cdev);
 	cancel_work_sync(&led->work);
 }

commit a8a93c6f9922c0d70459668c1300b226cb3918ab
Merge: 0df1f2487d2f 79cd17629331
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Nov 3 19:53:56 2014 -0800

    Merge branch 'platform/remove_owner' of git://git.kernel.org/pub/scm/linux/kernel/git/wsa/linux into driver-core-next
    
    Remove all .owner fields from platform drivers

commit 81902d5f658f5c8c0fbdff7c598fe24d4d521c05
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Mon Oct 20 16:20:43 2014 +0200

    leds: drop owner assignment from platform_drivers
    
    A platform_driver does not need to set an owner, it will be populated by the
    driver core.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index 57ff20fecf57..eda0c87dd9e4 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -289,7 +289,6 @@ static struct platform_driver gpio_led_driver = {
 	.remove		= gpio_led_remove,
 	.driver		= {
 		.name	= "leds-gpio",
-		.owner	= THIS_MODULE,
 		.of_match_table = of_match_ptr(of_gpio_leds_match),
 	},
 };

commit a4c84e6aafda0ddd8cb004c464cd11e47e211049
Author: Xiubo Li <Li.Xiubo@freescale.com>
Date:   Sun Sep 28 01:57:16 2014 -0700

    leds: gpio: cleanup the leds-gpio driver
    
    Remove stray blank line and space.
    
    Signed-off-by: Xiubo Li <Li.Xiubo@freescale.com>
    Signed-off-by: Bryan Wu <cooloney@gmail.com>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index 1b1e6176982d..b4518c8751c8 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -36,7 +36,7 @@ struct gpio_led_data {
 
 static void gpio_led_work(struct work_struct *work)
 {
-	struct gpio_led_data	*led_dat =
+	struct gpio_led_data *led_dat =
 		container_of(work, struct gpio_led_data, work);
 
 	if (led_dat->blinking) {
@@ -235,14 +235,12 @@ static struct gpio_leds_priv *gpio_leds_create_of(struct platform_device *pdev)
 }
 #endif /* CONFIG_OF_GPIO */
 
-
 static int gpio_led_probe(struct platform_device *pdev)
 {
 	struct gpio_led_platform_data *pdata = dev_get_platdata(&pdev->dev);
 	struct gpio_leds_priv *priv;
 	int i, ret = 0;
 
-
 	if (pdata && pdata->num_leds) {
 		priv = devm_kzalloc(&pdev->dev,
 				sizeof_gpio_leds_priv(pdata->num_leds),

commit 4cc72346f05ef549403d997d66fd517109e59d24
Author: Xiubo Li <Li.Xiubo@freescale.com>
Date:   Sun Sep 28 01:57:14 2014 -0700

    led: gpio: Sort include headers alphabetically
    
    If the inlcude headers aren't sorted alphabetically, then the
    logical choice is to append new ones, however that creates a
    lot of potential for conflicts or duplicates because every change
    will then add new includes in the same location.
    
    Signed-off-by: Xiubo Li <Li.Xiubo@freescale.com>
    Signed-off-by: Bryan Wu <cooloney@gmail.com>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index 57ff20fecf57..1b1e6176982d 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -10,17 +10,17 @@
  * published by the Free Software Foundation.
  *
  */
-#include <linux/kernel.h>
-#include <linux/platform_device.h>
+#include <linux/err.h>
 #include <linux/gpio.h>
+#include <linux/kernel.h>
 #include <linux/leds.h>
+#include <linux/module.h>
 #include <linux/of.h>
-#include <linux/of_platform.h>
 #include <linux/of_gpio.h>
+#include <linux/of_platform.h>
+#include <linux/platform_device.h>
 #include <linux/slab.h>
 #include <linux/workqueue.h>
-#include <linux/module.h>
-#include <linux/err.h>
 
 struct gpio_led_data {
 	struct led_classdev cdev;

commit 472b854bbc0b55de850faa802250fc1aa7692e45
Author: Paolo Pisati <paolo.pisati@canonical.com>
Date:   Thu Mar 6 09:18:37 2014 -0800

    leds-gpio: of: introduce MODULE_DEVICE_TABLE for module autoloading
    
    Enable autoloading of leds-gpio module when a corresponing DT entry is present.
    
    Signed-off-by: Paolo Pisati <paolo.pisati@canonical.com>
    Signed-off-by: Bryan Wu <cooloney@gmail.com>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index 953fb37f0375..57ff20fecf57 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -226,6 +226,8 @@ static const struct of_device_id of_gpio_leds_match[] = {
 	{ .compatible = "gpio-leds", },
 	{},
 };
+
+MODULE_DEVICE_TABLE(of, of_gpio_leds_match);
 #else /* CONFIG_OF_GPIO */
 static struct gpio_leds_priv *gpio_leds_create_of(struct platform_device *pdev)
 {

commit 7c7d2a26dbb336ddabe53818750f4c32e2b45ddd
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Tue Jan 21 13:22:57 2014 -0800

    drivers/leds: delete non-required instances of include <linux/init.h>
    
    None of these files are actually using any __init type directives
    and hence don't need to include <linux/init.h>.  Most are just a
    left over from __devinit and __cpuinit removal, or simply due to
    code getting copied from one driver to the next.
    
    Cc: Bryan Wu <cooloney@gmail.com>
    Cc: Richard Purdie <rpurdie@rpsys.net>
    Cc: linux-leds@vger.kernel.org
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: Bryan Wu <cooloney@gmail.com>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index 1bb3f1ab1d91..953fb37f0375 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -11,7 +11,6 @@
  *
  */
 #include <linux/kernel.h>
-#include <linux/init.h>
 #include <linux/platform_device.h>
 #include <linux/gpio.h>
 #include <linux/leds.h>

commit 4270a78d23eece0b25a13bff1e71d114ec547de4
Author: Robin Gong <b38343@freescale.com>
Date:   Mon Jan 20 03:41:26 2014 -0800

    leds: leds-gpio: add retain-state-suspended property
    
    Some gpio-leds need retain the state even in suspend, such as charger led.
    But this property missed in devicetree, add it.
    
    (cooloney@gmail.com: fold DT binding updates into this patch)
    
    Signed-off-by: Robin Gong <b38343@freescale.com>
    Signed-off-by: Bryan Wu <cooloney@gmail.com>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index 78b0e273a903..1bb3f1ab1d91 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -204,6 +204,9 @@ static struct gpio_leds_priv *gpio_leds_create_of(struct platform_device *pdev)
 				led.default_state = LEDS_GPIO_DEFSTATE_OFF;
 		}
 
+		if (of_get_property(child, "retain-state-suspended", NULL))
+			led.retain_state_suspended = 1;
+
 		ret = create_gpio_led(&led, &priv->leds[priv->num_leds++],
 				      &pdev->dev, NULL);
 		if (ret < 0) {

commit b0bb83df0a004ff6ef9b1a11784361c9eb63dbf9
Author: Josh Wu <josh.wu@atmel.com>
Date:   Thu Sep 26 04:27:56 2013 -0700

    leds-gpio: of: led should not be created if its status is disabled
    
    now the leds-gpio driver will create every child led node without
    checking the status is disabled or not.
    
    for example, if we have a led node like d3, and its status is disabled:
            leds {
                    d3 {
                            label = "d3";
                            gpios = <&pioE 24 0>;
                            status = "disabled";
                    };
            };
    
    we except the d3 should not be created. And the gpios should not be
    request as well.
    
    But current driver will create d3 and request its gpio.
    
    This patch fix this by using for_each_available_child_of_node() and
    of_get_available_child_count() to enumerate all child nodes. So the
    disabled node will be inavailable.
    
    Signed-off-by: Josh Wu <josh.wu@atmel.com>
    Signed-off-by: Bryan Wu <cooloney@gmail.com>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index 7ccafdeab9c1..78b0e273a903 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -171,11 +171,11 @@ static struct gpio_leds_priv *gpio_leds_create_of(struct platform_device *pdev)
 	int count, ret;
 
 	/* count LEDs in this device, so we know how much to allocate */
-	count = of_get_child_count(np);
+	count = of_get_available_child_count(np);
 	if (!count)
 		return ERR_PTR(-ENODEV);
 
-	for_each_child_of_node(np, child)
+	for_each_available_child_of_node(np, child)
 		if (of_get_gpio(child, 0) == -EPROBE_DEFER)
 			return ERR_PTR(-EPROBE_DEFER);
 
@@ -184,7 +184,7 @@ static struct gpio_leds_priv *gpio_leds_create_of(struct platform_device *pdev)
 	if (!priv)
 		return ERR_PTR(-ENOMEM);
 
-	for_each_child_of_node(np, child) {
+	for_each_available_child_of_node(np, child) {
 		struct gpio_led led = {};
 		enum of_gpio_flags flags;
 		const char *state;

commit c68f46dd6aec29b4db9eb85d014981bbdd686428
Author: Sachin Kamat <sachin.kamat@linaro.org>
Date:   Sat Sep 28 04:38:30 2013 -0700

    leds: Include linux/of.h header
    
    'of_match_ptr' is defined in linux/of.h. Include it explicitly.
    
    Signed-off-by: Sachin Kamat <sachin.kamat@linaro.org>
    Signed-off-by: Bryan Wu <cooloney@gmail.com>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index e8b01e57348d..7ccafdeab9c1 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -15,6 +15,7 @@
 #include <linux/platform_device.h>
 #include <linux/gpio.h>
 #include <linux/leds.h>
+#include <linux/of.h>
 #include <linux/of_platform.h>
 #include <linux/of_gpio.h>
 #include <linux/slab.h>

commit 87aae1ea82f93f0f00cb955044ea1db3501cf233
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Tue Jul 30 01:07:35 2013 -0700

    leds: use dev_get_platdata()
    
    Use the wrapper function for retrieving the platform data instead of
    accessing dev->platform_data directly.
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Signed-off-by: Bryan Wu <cooloney@gmail.com>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index 84d74c373cae..e8b01e57348d 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -233,7 +233,7 @@ static struct gpio_leds_priv *gpio_leds_create_of(struct platform_device *pdev)
 
 static int gpio_led_probe(struct platform_device *pdev)
 {
-	struct gpio_led_platform_data *pdata = pdev->dev.platform_data;
+	struct gpio_led_platform_data *pdata = dev_get_platdata(&pdev->dev);
 	struct gpio_leds_priv *priv;
 	int i, ret = 0;
 

commit bfa855bad39b7a266c00efdd2dc5887bcd41bb70
Author: Fabio Estevam <fabio.estevam@freescale.com>
Date:   Mon May 20 08:23:45 2013 -0700

    leds: leds-gpio: Let device core handle pinctrl
    
    Since commit ab78029 (drivers/pinctrl: grab default handles from device core)
    we can rely on device core for handling pinctrl, so remove
    devm_pinctrl_get_select_default() from the driver.
    
    Reported-by: Stephen Warren <warren@wwwdotorg.org>
    Signed-off-by: Fabio Estevam <fabio.estevam@freescale.com>
    Signed-off-by: Bryan Wu <cooloney@gmail.com>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index 02c4cc1f39b2..84d74c373cae 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -20,7 +20,6 @@
 #include <linux/slab.h>
 #include <linux/workqueue.h>
 #include <linux/module.h>
-#include <linux/pinctrl/consumer.h>
 #include <linux/err.h>
 
 struct gpio_led_data {
@@ -236,13 +235,8 @@ static int gpio_led_probe(struct platform_device *pdev)
 {
 	struct gpio_led_platform_data *pdata = pdev->dev.platform_data;
 	struct gpio_leds_priv *priv;
-	struct pinctrl *pinctrl;
 	int i, ret = 0;
 
-	pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
-	if (IS_ERR(pinctrl))
-		dev_warn(&pdev->dev,
-			"pins are not configured from the driver\n");
 
 	if (pdata && pdata->num_leds) {
 		priv = devm_kzalloc(&pdev->dev,

commit d9041d5886f9c0cd33dd320d2bd98f8626d50725
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Thu May 2 23:43:44 2013 -0700

    leds: leds-gpio: remove unnecessary platform_set_drvdata()
    
    The driver core clears the driver data to NULL after device_release
    or on probe failure, since commit 0998d0631001288a5974afc0b2a5f568bcdecb4d
    (device-core: Ensure drvdata = NULL when no driver is bound).
    Thus, it is not needed to manually clear the device driver data to NULL.
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Signed-off-by: Bryan Wu <cooloney@gmail.com>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index b02b679abf31..02c4cc1f39b2 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -282,8 +282,6 @@ static int gpio_led_remove(struct platform_device *pdev)
 	for (i = 0; i < priv->num_leds; i++)
 		delete_gpio_led(&priv->leds[i]);
 
-	platform_set_drvdata(pdev, NULL);
-
 	return 0;
 }
 

commit 803d19d57a042e86e9e9b685bbc3f4a0a751040f
Author: Timo Teräs <timo.teras@iki.fi>
Date:   Fri May 17 00:48:39 2013 -0700

    leds: leds-gpio: reserve gpio before using it
    
    This reverts commit a99d76f (leds: leds-gpio: use gpio_request_one)
    and commit 2d7c22f (leds: leds-gpio: set devm_gpio_request_one()
    flags param correctly) which was a fix of the first one.
    
    The conversion to devm_gpio_request in commit e3b1d44c (leds:
    leds-gpio: use devm_gpio_request_one) is not reverted.
    
    The problem is that gpio_cansleep() and gpio_get_value_cansleep()
    calls can crash if the gpio is not first reserved. Incidentally this
    same bug existed earlier and was fixed similarly in commit d95cbe61
    (leds: Fix potential leds-gpio oops). But the OOPS is real. It happens
    when GPIOs are provided by module which is not yet loaded.
    
    So this fixes the following BUG during my ALIX boot (3.9.2-vanilla):
    
    BUG: unable to handle kernel NULL pointer dereference at 0000004c
    IP: [<c11287d6>] __gpio_cansleep+0xe/0x1a
    *pde = 00000000
    Oops: 0000 [#1] SMP
    Modules linked in: leds_gpio(+) via_rhine mii cs5535_mfd mfd_core
    geode_rng rng_core geode_aes isofs nls_utf8 nls_cp437 vfat fat
    ata_generic pata_amd pata_cs5536 pata_acpi libata ehci_pci ehci_hcd
    ohci_hcd usb_storage usbcore usb_common sd_mod scsi_mod squashfs loop
    Pid: 881, comm: modprobe Not tainted 3.9.2 #1-Alpine
    EIP: 0060:[<c11287d6>] EFLAGS: 00010282 CPU: 0
    EIP is at __gpio_cansleep+0xe/0x1a
    EAX: 00000000 EBX: cf364018 ECX: c132b8b9 EDX: 00000000
    ESI: c13993a4 EDI: c1399370 EBP: cded9dbc ESP: cded9dbc
     DS: 007b ES: 007b FS: 00d8 GS: 0033 SS: 0068
    CR0: 8005003b CR2: 0000004c CR3: 0f0c4000 CR4: 00000090
    DR0: 00000000 DR1: 00000000 DR2: 00000000 DR3: 00000000
    DR6: ffff0ff0 DR7: 00000400
    Process modprobe (pid: 881, ti=cded8000 task=cf094aa0 task.ti=cded8000)
    Stack:
     cded9de0 d09471cb 00000000 c1399260 cf364014 00000000 c1399260 c1399254
     d0949014 cded9df4 c118cd59 c1399260 d0949014 d0949014 cded9e08 c118ba47
     c1399260 d0949014 c1399294 cded9e1c c118bb75 cded9e24 d0949014 00000000
    Call Trace:
     [<d09471cb>] gpio_led_probe+0xba/0x203 [leds_gpio]
     [<c118cd59>] platform_drv_probe+0x26/0x48
     [<c118ba47>] driver_probe_device+0x75/0x15c
     [<c118bb75>] __driver_attach+0x47/0x63
     [<c118a727>] bus_for_each_dev+0x3c/0x66
     [<c118b6f9>] driver_attach+0x14/0x16
     [<c118bb2e>] ? driver_probe_device+0x15c/0x15c
     [<c118b3d5>] bus_add_driver+0xbd/0x1bc
     [<d08b4000>] ? 0xd08b3fff
     [<d08b4000>] ? 0xd08b3fff
     [<c118bffc>] driver_register+0x74/0xec
     [<d08b4000>] ? 0xd08b3fff
     [<c118c8e8>] platform_driver_register+0x38/0x3a
     [<d08b400d>] gpio_led_driver_init+0xd/0x1000 [leds_gpio]
     [<c100116c>] do_one_initcall+0x6b/0x10f
     [<d08b4000>] ? 0xd08b3fff
     [<c105e918>] load_module+0x1631/0x1907
     [<c10975d6>] ? insert_vmalloc_vmlist+0x14/0x43
     [<c1098d5b>] ? __vmalloc_node_range+0x13e/0x15f
     [<c105ec50>] sys_init_module+0x62/0x77
     [<c1257888>] syscall_call+0x7/0xb
    EIP: [<c11287d6>] __gpio_cansleep+0xe/0x1a SS:ESP 0068:cded9dbc
    CR2: 000000000000004c
     ---[ end trace 5308fb20d2514822 ]---
    
    Signed-off-by: Timo Teräs <timo.teras@iki.f>
    Cc: Sachin Kamat <sachin.kamat@linaro.org>
    Cc: Raphael Assenat <raph@8d.com>
    Cc: Trent Piepho <tpiepho@freescale.com>
    Cc: Javier Martinez Canillas <javier.martinez@collabora.co.uk>
    Cc: Arnaud Patard <arnaud.patard@rtp-net.org>
    Cc: Ezequiel Garcia <ezequiel.garcia@free-electrons.com>
    Acked-by: Jingoo Han <jg1.han@samsung.com>
    Signed-off-by: Bryan Wu <cooloney@gmail.com>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index a0d931bcb37c..b02b679abf31 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -107,6 +107,10 @@ static int create_gpio_led(const struct gpio_led *template,
 		return 0;
 	}
 
+	ret = devm_gpio_request(parent, template->gpio, template->name);
+	if (ret < 0)
+		return ret;
+
 	led_dat->cdev.name = template->name;
 	led_dat->cdev.default_trigger = template->default_trigger;
 	led_dat->gpio = template->gpio;
@@ -126,10 +130,7 @@ static int create_gpio_led(const struct gpio_led *template,
 	if (!template->retain_state_suspended)
 		led_dat->cdev.flags |= LED_CORE_SUSPENDRESUME;
 
-	ret = devm_gpio_request_one(parent, template->gpio,
-				    (led_dat->active_low ^ state) ?
-				    GPIOF_OUT_INIT_HIGH : GPIOF_OUT_INIT_LOW,
-				    template->name);
+	ret = gpio_direction_output(led_dat->gpio, led_dat->active_low ^ state);
 	if (ret < 0)
 		return ret;
 

commit 2d7c22f67d5c342a6296127af4f224208449b779
Author: Javier Martinez Canillas <javier.martinez@collabora.co.uk>
Date:   Thu Dec 20 04:56:59 2012 -0800

    leds: leds-gpio: set devm_gpio_request_one() flags param correctly
    
    commit a99d76f leds: leds-gpio: use gpio_request_one
    
    changed the leds-gpio driver to use gpio_request_one() instead
    of gpio_request() + gpio_direction_output()
    
    Unfortunately, it also made a semantic change that breaks the
    leds-gpio driver.
    
    The gpio_request_one() flags parameter was set to:
    
    GPIOF_DIR_OUT | (led_dat->active_low ^ state)
    
    Since GPIOF_DIR_OUT is 0, the final flags value will just be the
    XOR'ed value of led_dat->active_low and state.
    
    This value were used to distinguish between HIGH/LOW output initial
    level and call gpio_direction_output() accordingly.
    
    With this new semantic gpio_request_one() will take the flags value
    of 1 as a configuration of input direction (GPIOF_DIR_IN) and will
    call gpio_direction_input() instead of gpio_direction_output().
    
    int gpio_request_one(unsigned gpio, unsigned long flags, const char *label)
    {
    ..
            if (flags & GPIOF_DIR_IN)
                    err = gpio_direction_input(gpio);
            else
                    err = gpio_direction_output(gpio,
                                    (flags & GPIOF_INIT_HIGH) ? 1 : 0);
    ..
    }
    
    The right semantic is to evaluate led_dat->active_low ^ state and
    set the output initial level explicitly.
    
    Signed-off-by: Javier Martinez Canillas <javier.martinez@collabora.co.uk>
    Reported-by: Arnaud Patard <arnaud.patard@rtp-net.org>
    Tested-by: Ezequiel Garcia <ezequiel.garcia@free-electrons.com>
    Signed-off-by: Bryan Wu <cooloney@gmail.com>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index 1885a26776b1..a0d931bcb37c 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -127,8 +127,9 @@ static int create_gpio_led(const struct gpio_led *template,
 		led_dat->cdev.flags |= LED_CORE_SUSPENDRESUME;
 
 	ret = devm_gpio_request_one(parent, template->gpio,
-			GPIOF_DIR_OUT | (led_dat->active_low ^ state),
-			template->name);
+				    (led_dat->active_low ^ state) ?
+				    GPIOF_OUT_INIT_HIGH : GPIOF_OUT_INIT_LOW,
+				    template->name);
 	if (ret < 0)
 		return ret;
 

commit e81d372ff9f694e13fa46e8b5aaed505c7fd2a1f
Merge: 75e300c8ba58 2f05e1d4458f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Dec 15 12:52:42 2012 -0800

    Merge branch 'for-next' of git://git.kernel.org/pub/scm/linux/kernel/git/cooloney/linux-leds
    
    Pull LED subsystem update from Bryan Wu.
    
    * 'for-next' of git://git.kernel.org/pub/scm/linux/kernel/git/cooloney/linux-leds: (47 commits)
      leds: leds-lp5521: return an error code on error in probe()
      leds: leds-clevo-mail: Use pr_* instead of printks
      leds: leds-rb532: Fix checkpatch errors
      leds: led-triggers: Fix checkpatch warnings
      leds: ledtrig-backlight: Fix checkpatch error
      leds: leds-wrap: Use <linux/io.h> instead of <asm/io.h>
      leds: leds-wm8350: Use dev_err instead of printk
      leds: leds-pwm: Fix checkpatch warning
      leds: leds-pca955x: Use dev_info instead of printk
      leds: leds-net48xx: Use linux/io.h instead of asm/io.h
      leds: leds-lt3593: Fix checkpatch warnings
      leds: leds-gpio: Use dev_info instead of printk
      leds: leds-da903x: Fix checkpatch error and warnings
      leds: leds-bd2802: Fix checkpatch warnings
      leds: leds-adp5520: Fix checkpatch warnings
      leds: led-class: Fix checkpatch warning
      leds: leds-ns2: use devm_gpio_request_one
      leds: leds-lt3593: use devm_gpio_request_one
      leds: leds-gpio: use devm_gpio_request_one
      leds: lp3944: Fix return value
      ...

commit 678e8a6be911dd8684b894687ae88ff3b0ae4659
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:26:00 2012 -0500

    leds: remove use of __devexit
    
    CONFIG_HOTPLUG is going away as an option so __devexit is no
    longer needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Richard Purdie <rpurdie@rpsys.net>
    Cc: Jan-Simon Moeller <jansimon.moeller@gmx.de>
    Acked-by: Bryan Wu <cooloney@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index 5c9efc73f06a..291c20797ca0 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -273,7 +273,7 @@ static int gpio_led_probe(struct platform_device *pdev)
 	return 0;
 }
 
-static int __devexit gpio_led_remove(struct platform_device *pdev)
+static int gpio_led_remove(struct platform_device *pdev)
 {
 	struct gpio_leds_priv *priv = platform_get_drvdata(pdev);
 	int i;

commit 98ea1ea20cb7090d5ae2003c23fc8a7f14fca4c7
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:23:02 2012 -0500

    leds: remove use of __devinit
    
    CONFIG_HOTPLUG is going away as an option so __devinit is no longer
    needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Richard Purdie <rpurdie@rpsys.net>
    Cc: Jan-Simon Moeller <jansimon.moeller@gmx.de>
    Acked-by: Bryan Wu <cooloney@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index 51bc51311de0..5c9efc73f06a 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -91,7 +91,7 @@ static int gpio_blink_set(struct led_classdev *led_cdev,
 						delay_on, delay_off);
 }
 
-static int __devinit create_gpio_led(const struct gpio_led *template,
+static int create_gpio_led(const struct gpio_led *template,
 	struct gpio_led_data *led_dat, struct device *parent,
 	int (*blink_set)(unsigned, int, unsigned long *, unsigned long *))
 {
@@ -167,7 +167,7 @@ static inline int sizeof_gpio_leds_priv(int num_leds)
 
 /* Code to create from OpenFirmware platform devices */
 #ifdef CONFIG_OF_GPIO
-static struct gpio_leds_priv * __devinit gpio_leds_create_of(struct platform_device *pdev)
+static struct gpio_leds_priv *gpio_leds_create_of(struct platform_device *pdev)
 {
 	struct device_node *np = pdev->dev.of_node, *child;
 	struct gpio_leds_priv *priv;
@@ -224,14 +224,14 @@ static const struct of_device_id of_gpio_leds_match[] = {
 	{},
 };
 #else /* CONFIG_OF_GPIO */
-static struct gpio_leds_priv * __devinit gpio_leds_create_of(struct platform_device *pdev)
+static struct gpio_leds_priv *gpio_leds_create_of(struct platform_device *pdev)
 {
 	return NULL;
 }
 #endif /* CONFIG_OF_GPIO */
 
 
-static int __devinit gpio_led_probe(struct platform_device *pdev)
+static int gpio_led_probe(struct platform_device *pdev)
 {
 	struct gpio_led_platform_data *pdata = pdev->dev.platform_data;
 	struct gpio_leds_priv *priv;

commit df07cf81268192e42c4cdf91f5f4bf9aaac1b2f0
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:20:20 2012 -0500

    leds: remove use of __devexit_p
    
    CONFIG_HOTPLUG is going away as an option so __devexit_p is no longer
    needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Richard Purdie <rpurdie@rpsys.net>
    Cc: Jan-Simon Moeller <jansimon.moeller@gmx.de>
    Acked-by: Bryan Wu <cooloney@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index 087d1e66f4f7..51bc51311de0 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -288,7 +288,7 @@ static int __devexit gpio_led_remove(struct platform_device *pdev)
 
 static struct platform_driver gpio_led_driver = {
 	.probe		= gpio_led_probe,
-	.remove		= __devexit_p(gpio_led_remove),
+	.remove		= gpio_led_remove,
 	.driver		= {
 		.name	= "leds-gpio",
 		.owner	= THIS_MODULE,

commit 39de81a963ad261bcf2275ce5b1d6674a30c0428
Author: Sachin Kamat <sachin.kamat@linaro.org>
Date:   Sun Nov 25 11:38:05 2012 +0530

    leds: leds-gpio: Use dev_info instead of printk
    
    Fixes the following checkpatch warning:
    WARNING: Prefer netdev_info(netdev, ... then dev_info(dev, ... then pr_info(...  to printk(KERN_INFO ...
    FILE: leds/leds-gpio.c:105:
                    printk(KERN_INFO "Skipping unavailable LED gpio %d (%s)\n",
    
    Signed-off-by: Sachin Kamat <sachin.kamat@linaro.org>
    Signed-off-by: Bryan Wu <cooloney@gmail.com>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index 77e2e4057929..4f3179245ffe 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -102,7 +102,7 @@ static int __devinit create_gpio_led(const struct gpio_led *template,
 
 	/* skip leds that aren't available */
 	if (!gpio_is_valid(template->gpio)) {
-		printk(KERN_INFO "Skipping unavailable LED gpio %d (%s)\n",
+		dev_info(parent, "Skipping unavailable LED gpio %d (%s)\n",
 				template->gpio, template->name);
 		return 0;
 	}

commit e3b1d44c3550e5badfa5b78ffec80e15d7d9b287
Author: Sachin Kamat <sachin.kamat@linaro.org>
Date:   Sun Nov 25 10:10:20 2012 +0530

    leds: leds-gpio: use devm_gpio_request_one
    
    devm_gpio_request_one is device managed and makes error handling
    and cleanup simpler.
    
    Cc: Raphael Assenat <raph@8d.com>
    Cc: Trent Piepho <tpiepho@freescale.com>
    Signed-off-by: Sachin Kamat <sachin.kamat@linaro.org>
    Signed-off-by: Bryan Wu <cooloney@gmail.com>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index 6a2109638fbe..77e2e4057929 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -126,7 +126,7 @@ static int __devinit create_gpio_led(const struct gpio_led *template,
 	if (!template->retain_state_suspended)
 		led_dat->cdev.flags |= LED_CORE_SUSPENDRESUME;
 
-	ret = gpio_request_one(template->gpio,
+	ret = devm_gpio_request_one(parent, template->gpio,
 			GPIOF_DIR_OUT | (led_dat->active_low ^ state),
 			template->name);
 	if (ret < 0)
@@ -136,12 +136,9 @@ static int __devinit create_gpio_led(const struct gpio_led *template,
 
 	ret = led_classdev_register(parent, &led_dat->cdev);
 	if (ret < 0)
-		goto err;
+		return ret;
 
 	return 0;
-err:
-	gpio_free(led_dat->gpio);
-	return ret;
 }
 
 static void delete_gpio_led(struct gpio_led_data *led)
@@ -150,7 +147,6 @@ static void delete_gpio_led(struct gpio_led_data *led)
 		return;
 	led_classdev_unregister(&led->cdev);
 	cancel_work_sync(&led->work);
-	gpio_free(led->gpio);
 }
 
 struct gpio_leds_priv {

commit 04553e925baaa815025c6fd3cdc301a794fa2c74
Author: Roland Stigge <stigge@antcom.de>
Date:   Sun Oct 28 08:34:59 2012 -0700

    leds: leds-gpio: Defer probing in case of deferred gpio probing
    
    This patch makes leds-gpio's probe() return -EPROBE_DEFER if any of the gpios
    to register are deferred themselves. This makes a change of
    gpio_leds_create_of()'s return value necessary: Instead of returning NULL on
    error, we now use ERR_PTR() error coding.
    
    Signed-off-by: Roland Stigge <stigge@antcom.de>
    Signed-off-by: Bryan Wu <cooloney@gmail.com>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index 0b4185315261..6a2109638fbe 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -21,6 +21,7 @@
 #include <linux/workqueue.h>
 #include <linux/module.h>
 #include <linux/pinctrl/consumer.h>
+#include <linux/err.h>
 
 struct gpio_led_data {
 	struct led_classdev cdev;
@@ -174,12 +175,16 @@ static struct gpio_leds_priv * __devinit gpio_leds_create_of(struct platform_dev
 	/* count LEDs in this device, so we know how much to allocate */
 	count = of_get_child_count(np);
 	if (!count)
-		return NULL;
+		return ERR_PTR(-ENODEV);
+
+	for_each_child_of_node(np, child)
+		if (of_get_gpio(child, 0) == -EPROBE_DEFER)
+			return ERR_PTR(-EPROBE_DEFER);
 
 	priv = devm_kzalloc(&pdev->dev, sizeof_gpio_leds_priv(count),
 			GFP_KERNEL);
 	if (!priv)
-		return NULL;
+		return ERR_PTR(-ENOMEM);
 
 	for_each_child_of_node(np, child) {
 		struct gpio_led led = {};
@@ -214,7 +219,7 @@ static struct gpio_leds_priv * __devinit gpio_leds_create_of(struct platform_dev
 err:
 	for (count = priv->num_leds - 2; count >= 0; count--)
 		delete_gpio_led(&priv->leds[count]);
-	return NULL;
+	return ERR_PTR(-ENODEV);
 }
 
 static const struct of_device_id of_gpio_leds_match[] = {
@@ -224,7 +229,7 @@ static const struct of_device_id of_gpio_leds_match[] = {
 #else /* CONFIG_OF_GPIO */
 static struct gpio_leds_priv * __devinit gpio_leds_create_of(struct platform_device *pdev)
 {
-	return NULL;
+	return ERR_PTR(-ENODEV);
 }
 #endif /* CONFIG_OF_GPIO */
 
@@ -262,8 +267,8 @@ static int __devinit gpio_led_probe(struct platform_device *pdev)
 		}
 	} else {
 		priv = gpio_leds_create_of(pdev);
-		if (!priv)
-			return -ENODEV;
+		if (IS_ERR(priv))
+			return PTR_ERR(priv);
 	}
 
 	platform_set_drvdata(pdev, priv);

commit a99d76f9eb5336291fa6af713844d1c779484e30
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Tue Oct 23 05:17:11 2012 -0700

    leds: leds-gpio: use gpio_request_one
    
    Using gpio_request_one can make the code simpler because it can
    set the direction and initial value in one shot.
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Signed-off-by: Bryan Wu <cooloney@gmail.com>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index 087d1e66f4f7..0b4185315261 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -106,10 +106,6 @@ static int __devinit create_gpio_led(const struct gpio_led *template,
 		return 0;
 	}
 
-	ret = gpio_request(template->gpio, template->name);
-	if (ret < 0)
-		return ret;
-
 	led_dat->cdev.name = template->name;
 	led_dat->cdev.default_trigger = template->default_trigger;
 	led_dat->gpio = template->gpio;
@@ -129,10 +125,12 @@ static int __devinit create_gpio_led(const struct gpio_led *template,
 	if (!template->retain_state_suspended)
 		led_dat->cdev.flags |= LED_CORE_SUSPENDRESUME;
 
-	ret = gpio_direction_output(led_dat->gpio, led_dat->active_low ^ state);
+	ret = gpio_request_one(template->gpio,
+			GPIOF_DIR_OUT | (led_dat->active_low ^ state),
+			template->name);
 	if (ret < 0)
-		goto err;
-		
+		return ret;
+
 	INIT_WORK(&led_dat->work, gpio_led_work);
 
 	ret = led_classdev_register(parent, &led_dat->cdev);

commit 8fe4554f675c5822a0e12382e6843965ffd11c30
Author: AnilKumar Ch <anilkumar@ti.com>
Date:   Sat Sep 1 16:16:30 2012 +0800

    leds: leds-gpio: adopt pinctrl support
    
    Adopt pinctrl support to leds-gpio driver based on leds-gpio
    device pointer, pinctrl driver configure SoC pins to GPIO
    mode according to definitions provided in .dts file.
    
    Signed-off-by: AnilKumar Ch <anilkumar@ti.com>
    Acked-by: Marek Vasut <marex@denx.de>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Bryan Wu <bryan.wu@canonical.com>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index cde85ba1903a..087d1e66f4f7 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -20,6 +20,7 @@
 #include <linux/slab.h>
 #include <linux/workqueue.h>
 #include <linux/module.h>
+#include <linux/pinctrl/consumer.h>
 
 struct gpio_led_data {
 	struct led_classdev cdev;
@@ -234,8 +235,14 @@ static int __devinit gpio_led_probe(struct platform_device *pdev)
 {
 	struct gpio_led_platform_data *pdata = pdev->dev.platform_data;
 	struct gpio_leds_priv *priv;
+	struct pinctrl *pinctrl;
 	int i, ret = 0;
 
+	pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
+	if (IS_ERR(pinctrl))
+		dev_warn(&pdev->dev,
+			"pins are not configured from the driver\n");
+
 	if (pdata && pdata->num_leds) {
 		priv = devm_kzalloc(&pdev->dev,
 				sizeof_gpio_leds_priv(pdata->num_leds),

commit 127aedc8ecae2628511533ddeb239e99e4bed5e8
Author: Tobias Klauser <klto@zhaw.ch>
Date:   Tue Aug 21 17:21:53 2012 +0800

    leds: leds-gpio: Use of_get_child_count() helper
    
    Use of_get_child_count() instead of custom implementation.
    
    Signed-off-by: Tobias Klauser <klto@zhaw.ch>
    Signed-off-by: Bryan Wu <bryan.wu@canonical.com>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index c392c1e95531..cde85ba1903a 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -170,11 +170,10 @@ static struct gpio_leds_priv * __devinit gpio_leds_create_of(struct platform_dev
 {
 	struct device_node *np = pdev->dev.of_node, *child;
 	struct gpio_leds_priv *priv;
-	int count = 0, ret;
+	int count, ret;
 
 	/* count LEDs in this device, so we know how much to allocate */
-	for_each_child_of_node(np, child)
-		count++;
+	count = of_get_child_count(np);
 	if (!count)
 		return NULL;
 

commit 59c4dce13018b04275478e95b3929eca55afcdfb
Author: Tobias Klauser <tklauser@distanz.ch>
Date:   Thu Aug 16 18:36:13 2012 +0800

    leds: leds-gpio: Use platform_{get,set}_drvdata
    
    Use the wrapper functions, so we can directly pass a struct
    platfrom_device.
    
    Signed-off-by: Tobias Klauser <tklauser@distanz.ch>
    Signed-off-by: Bryan Wu <bryan.wu@canonical.com>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index 4043f7732e57..c392c1e95531 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -269,13 +269,13 @@ static int __devinit gpio_led_probe(struct platform_device *pdev)
 
 static int __devexit gpio_led_remove(struct platform_device *pdev)
 {
-	struct gpio_leds_priv *priv = dev_get_drvdata(&pdev->dev);
+	struct gpio_leds_priv *priv = platform_get_drvdata(pdev);
 	int i;
 
 	for (i = 0; i < priv->num_leds; i++)
 		delete_gpio_led(&priv->leds[i]);
 
-	dev_set_drvdata(&pdev->dev, NULL);
+	platform_set_drvdata(pdev, NULL);
 
 	return 0;
 }

commit 6ebcebddffbf5c074e467c725aafbd21dfd46ed5
Author: Tobias Klauser <tklauser@distanz.ch>
Date:   Thu Aug 16 18:35:36 2012 +0800

    leds: leds-gpio: use of_match_ptr()
    
    Instead of having to define the match table to NULL if CONFIG_OF isn't
    set, use the of_match_ptr() macro which will do this for us.
    
    Signed-off-by: Tobias Klauser <tklauser@distanz.ch>
    Signed-off-by: Bryan Wu <bryan.wu@canonical.com>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index c032b2180340..4043f7732e57 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -228,7 +228,6 @@ static struct gpio_leds_priv * __devinit gpio_leds_create_of(struct platform_dev
 {
 	return NULL;
 }
-#define of_gpio_leds_match NULL
 #endif /* CONFIG_OF_GPIO */
 
 
@@ -287,7 +286,7 @@ static struct platform_driver gpio_led_driver = {
 	.driver		= {
 		.name	= "leds-gpio",
 		.owner	= THIS_MODULE,
-		.of_match_table = of_gpio_leds_match,
+		.of_match_table = of_match_ptr(of_gpio_leds_match),
 	},
 };
 

commit 198b8611315f793a8f674c3ca3324028e19634aa
Author: Sachin Kamat <sachin.kamat@linaro.org>
Date:   Wed Jul 4 11:35:44 2012 +0800

    leds: Use devm_kzalloc in leds-gpio.c file
    
    devm_kzalloc() makes cleanup simpler.
    
    Signed-off-by: Sachin Kamat <sachin.kamat@linaro.org>
    Signed-off-by: Bryan Wu <bryan.wu@canonical.com>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index f4c470a3bc8d..c032b2180340 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -178,7 +178,8 @@ static struct gpio_leds_priv * __devinit gpio_leds_create_of(struct platform_dev
 	if (!count)
 		return NULL;
 
-	priv = kzalloc(sizeof_gpio_leds_priv(count), GFP_KERNEL);
+	priv = devm_kzalloc(&pdev->dev, sizeof_gpio_leds_priv(count),
+			GFP_KERNEL);
 	if (!priv)
 		return NULL;
 
@@ -215,7 +216,6 @@ static struct gpio_leds_priv * __devinit gpio_leds_create_of(struct platform_dev
 err:
 	for (count = priv->num_leds - 2; count >= 0; count--)
 		delete_gpio_led(&priv->leds[count]);
-	kfree(priv);
 	return NULL;
 }
 
@@ -239,8 +239,9 @@ static int __devinit gpio_led_probe(struct platform_device *pdev)
 	int i, ret = 0;
 
 	if (pdata && pdata->num_leds) {
-		priv = kzalloc(sizeof_gpio_leds_priv(pdata->num_leds),
-				GFP_KERNEL);
+		priv = devm_kzalloc(&pdev->dev,
+				sizeof_gpio_leds_priv(pdata->num_leds),
+					GFP_KERNEL);
 		if (!priv)
 			return -ENOMEM;
 
@@ -253,7 +254,6 @@ static int __devinit gpio_led_probe(struct platform_device *pdev)
 				/* On failure: unwind the led creations */
 				for (i = i - 1; i >= 0; i--)
 					delete_gpio_led(&priv->leds[i]);
-				kfree(priv);
 				return ret;
 			}
 		}
@@ -277,7 +277,6 @@ static int __devexit gpio_led_remove(struct platform_device *pdev)
 		delete_gpio_led(&priv->leds[i]);
 
 	dev_set_drvdata(&pdev->dev, NULL);
-	kfree(priv);
 
 	return 0;
 }

commit 16db7f9095bf6bb394c9ddb64e738e64a0fea733
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Fri Mar 23 15:02:11 2012 -0700

    drivers/leds/leds-gpio.c: use linux/gpio.h rather than asm/gpio.h
    
    Direct usage of the asm include has long been deprecated by the
    introduction of gpiolib.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Cc: Richard Purdie <rpurdie@rpsys.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index 7df74cb97e70..f4c470a3bc8d 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -13,6 +13,7 @@
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/platform_device.h>
+#include <linux/gpio.h>
 #include <linux/leds.h>
 #include <linux/of_platform.h>
 #include <linux/of_gpio.h>
@@ -20,8 +21,6 @@
 #include <linux/workqueue.h>
 #include <linux/module.h>
 
-#include <asm/gpio.h>
-
 struct gpio_led_data {
 	struct led_classdev cdev;
 	unsigned gpio;

commit 892a8843fbef07a7f2ab62d5f7ff5c16ea0903b0
Author: Axel Lin <axel.lin@gmail.com>
Date:   Tue Jan 10 15:09:24 2012 -0800

    leds: convert led platform drivers to module_platform_driver
    
    Factor out some boilerplate code for platform driver registration into
    module_platform_driver.
    
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Acked-by: Haojian Zhuang <hzhuang1@marvell.com>         [led-88pm860x.c]
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Cc: Richard Purdie <rpurdie@rpsys.net>
    Cc: Michael Hennerich <hennerich@blackfin.uclinux.org>
    Cc: Mike Rapoport <mike@compulab.co.il>
    Cc: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index 399a86f2013a..7df74cb97e70 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -293,21 +293,9 @@ static struct platform_driver gpio_led_driver = {
 	},
 };
 
-MODULE_ALIAS("platform:leds-gpio");
-
-static int __init gpio_led_init(void)
-{
-	return platform_driver_register(&gpio_led_driver);
-}
-
-static void __exit gpio_led_exit(void)
-{
-	platform_driver_unregister(&gpio_led_driver);
-}
-
-module_init(gpio_led_init);
-module_exit(gpio_led_exit);
+module_platform_driver(gpio_led_driver);
 
 MODULE_AUTHOR("Raphael Assenat <raph@8d.com>, Trent Piepho <tpiepho@freescale.com>");
 MODULE_DESCRIPTION("GPIO LED driver");
 MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:leds-gpio");

commit 32aaeffbd4a7457bf2f7448b33b5946ff2a960eb
Merge: 208bca086040 67b84999b1a8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Nov 6 19:44:47 2011 -0800

    Merge branch 'modsplit-Oct31_2011' of git://git.kernel.org/pub/scm/linux/kernel/git/paulg/linux
    
    * 'modsplit-Oct31_2011' of git://git.kernel.org/pub/scm/linux/kernel/git/paulg/linux: (230 commits)
      Revert "tracing: Include module.h in define_trace.h"
      irq: don't put module.h into irq.h for tracking irqgen modules.
      bluetooth: macroize two small inlines to avoid module.h
      ip_vs.h: fix implicit use of module_get/module_put from module.h
      nf_conntrack.h: fix up fallout from implicit moduleparam.h presence
      include: replace linux/module.h with "struct module" wherever possible
      include: convert various register fcns to macros to avoid include chaining
      crypto.h: remove unused crypto_tfm_alg_modname() inline
      uwb.h: fix implicit use of asm/page.h for PAGE_SIZE
      pm_runtime.h: explicitly requires notifier.h
      linux/dmaengine.h: fix implicit use of bitmap.h and asm/page.h
      miscdevice.h: fix up implicit use of lists and types
      stop_machine.h: fix implicit use of smp.h for smp_processor_id
      of: fix implicit use of errno.h in include/linux/of.h
      of_platform.h: delete needless include <linux/module.h>
      acpi: remove module.h include from platform/aclinux.h
      miscdevice.h: delete unnecessary inclusion of module.h
      device_cgroup.h: delete needless include <linux/module.h>
      net: sch_generic remove redundant use of <linux/module.h>
      net: inet_timewait_sock doesnt need <linux/module.h>
      ...
    
    Fix up trivial conflicts (other header files, and  removal of the ab3550 mfd driver) in
     - drivers/media/dvb/frontends/dibx000_common.c
     - drivers/media/video/{mt9m111.c,ov6650.c}
     - drivers/mfd/ab3550-core.c
     - include/linux/dmaengine.h

commit dabc69c24271bd6ac126e3dda4f2d72234da81df
Author: David Daney <david.daney@cavium.com>
Date:   Mon Oct 31 17:12:17 2011 -0700

    drivers/leds/leds-gpio.c: use gpio_get_value_cansleep() when initializing
    
    I get the following warning:
    
    ------------[ cut here ]------------
    WARNING: at drivers/gpio/gpiolib.c:1559 __gpio_get_value+0x90/0x98()
    Modules linked in:
    Call Trace:
    [<ffffffff81440950>] dump_stack+0x8/0x34
    [<ffffffff81141478>] warn_slowpath_common+0x78/0xa0
    [<ffffffff812f0958>] __gpio_get_value+0x90/0x98
    [<ffffffff81434f04>] create_gpio_led+0xdc/0x194
    [<ffffffff8143524c>] gpio_led_probe+0x290/0x36c
    [<ffffffff8130e8b0>] driver_probe_device+0x78/0x1b0
    [<ffffffff8130eaa8>] __driver_attach+0xc0/0xc8
    [<ffffffff8130d7ac>] bus_for_each_dev+0x64/0xb0
    [<ffffffff8130e130>] bus_add_driver+0x1c8/0x2a8
    [<ffffffff8130f100>] driver_register+0x90/0x180
    [<ffffffff81100438>] do_one_initcall+0x38/0x160
    
    ---[ end trace ee38723fbefcd65c ]---
    
    My GPIOs are on an I2C port expander, so we must use the *_cansleep()
    variant of the GPIO functions.  This is was not being done in
    create_gpio_led().
    
    We can change gpio_get_value() to gpio_get_value_cansleep() because it is
    only called from the platform_driver probe function, which is a context
    where we can sleep.
    
    Only tested on my gpio_cansleep() system, but it seems safe for all
    systems.
    
    Signed-off-by: David Daney <david.daney@cavium.com>
    Cc: Richard Purdie <rpurdie@rpsys.net>
    Acked-by: Trent Piepho <tpiepho@gmail.com>
    Cc: Grant Likely <grant.likely@secretlab.ca>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index 3d8bc327a68d..504cc26c7e4b 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -121,7 +121,7 @@ static int __devinit create_gpio_led(const struct gpio_led *template,
 	}
 	led_dat->cdev.brightness_set = gpio_led_set;
 	if (template->default_state == LEDS_GPIO_DEFSTATE_KEEP)
-		state = !!gpio_get_value(led_dat->gpio) ^ led_dat->active_low;
+		state = !!gpio_get_value_cansleep(led_dat->gpio) ^ led_dat->active_low;
 	else
 		state = (template->default_state == LEDS_GPIO_DEFSTATE_ON);
 	led_dat->cdev.brightness = state ? LED_FULL : LED_OFF;

commit 54f4dedb5368fff81b722b551e2f15a75175d7b7
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Sun Jul 3 13:56:03 2011 -0400

    drivers/leds: Add module.h to files using it implicitly
    
    A pending cleanup will mean that module.h won't be implicitly
    everywhere anymore.  Make sure the modular drivers in the leds
    dir are actually calling out for <module.h> explicitly in advance.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index 3d8bc327a68d..2ba756b035de 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -18,6 +18,7 @@
 #include <linux/of_gpio.h>
 #include <linux/slab.h>
 #include <linux/workqueue.h>
+#include <linux/module.h>
 
 #include <asm/gpio.h>
 

commit 2bcc7ed5b83b0a59c6976476e8788675038fb11b
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Tue May 31 16:23:43 2011 +0800

    leds: remove config option LEDS_GPIO_PLATFORM from Kconfig
    
    Since the commit a314c5c0040aab51ebb1ecfd37a9198a91962243
    (leds/leds-gpio: merge platform_driver with of_platform_driver),
    the config option LEDS_GPIO_PLATFORM becomes useless, so remove it.
    
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
    [grant.likely: also remove LEDS_GPIO_OF for same reason]
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index b0480c8fbcbf..3d8bc327a68d 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -165,7 +165,7 @@ static inline int sizeof_gpio_leds_priv(int num_leds)
 }
 
 /* Code to create from OpenFirmware platform devices */
-#ifdef CONFIG_LEDS_GPIO_OF
+#ifdef CONFIG_OF_GPIO
 static struct gpio_leds_priv * __devinit gpio_leds_create_of(struct platform_device *pdev)
 {
 	struct device_node *np = pdev->dev.of_node, *child;
@@ -223,13 +223,13 @@ static const struct of_device_id of_gpio_leds_match[] = {
 	{ .compatible = "gpio-leds", },
 	{},
 };
-#else
+#else /* CONFIG_OF_GPIO */
 static struct gpio_leds_priv * __devinit gpio_leds_create_of(struct platform_device *pdev)
 {
 	return NULL;
 }
 #define of_gpio_leds_match NULL
-#endif
+#endif /* CONFIG_OF_GPIO */
 
 
 static int __devinit gpio_led_probe(struct platform_device *pdev)

commit a314c5c0040aab51ebb1ecfd37a9198a91962243
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Tue Feb 22 20:06:04 2011 -0700

    leds/leds-gpio: merge platform_driver with of_platform_driver
    
    Both interfaces can be driven with the same driver, and
    of_platform_driver is getting removed.  This patch merges the two
    driver registrations.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index 4d9fa38d9ff6..b0480c8fbcbf 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -14,6 +14,8 @@
 #include <linux/init.h>
 #include <linux/platform_device.h>
 #include <linux/leds.h>
+#include <linux/of_platform.h>
+#include <linux/of_gpio.h>
 #include <linux/slab.h>
 #include <linux/workqueue.h>
 
@@ -151,96 +153,34 @@ static void delete_gpio_led(struct gpio_led_data *led)
 	gpio_free(led->gpio);
 }
 
-#ifdef CONFIG_LEDS_GPIO_PLATFORM
-static int __devinit gpio_led_probe(struct platform_device *pdev)
-{
-	struct gpio_led_platform_data *pdata = pdev->dev.platform_data;
-	struct gpio_led_data *leds_data;
-	int i, ret = 0;
-
-	if (!pdata)
-		return -EBUSY;
-
-	leds_data = kzalloc(sizeof(struct gpio_led_data) * pdata->num_leds,
-				GFP_KERNEL);
-	if (!leds_data)
-		return -ENOMEM;
-
-	for (i = 0; i < pdata->num_leds; i++) {
-		ret = create_gpio_led(&pdata->leds[i], &leds_data[i],
-				      &pdev->dev, pdata->gpio_blink_set);
-		if (ret < 0)
-			goto err;
-	}
-
-	platform_set_drvdata(pdev, leds_data);
-
-	return 0;
-
-err:
-	for (i = i - 1; i >= 0; i--)
-		delete_gpio_led(&leds_data[i]);
-
-	kfree(leds_data);
-
-	return ret;
-}
+struct gpio_leds_priv {
+	int num_leds;
+	struct gpio_led_data leds[];
+};
 
-static int __devexit gpio_led_remove(struct platform_device *pdev)
+static inline int sizeof_gpio_leds_priv(int num_leds)
 {
-	int i;
-	struct gpio_led_platform_data *pdata = pdev->dev.platform_data;
-	struct gpio_led_data *leds_data;
-
-	leds_data = platform_get_drvdata(pdev);
-
-	for (i = 0; i < pdata->num_leds; i++)
-		delete_gpio_led(&leds_data[i]);
-
-	kfree(leds_data);
-
-	return 0;
+	return sizeof(struct gpio_leds_priv) +
+		(sizeof(struct gpio_led_data) * num_leds);
 }
 
-static struct platform_driver gpio_led_driver = {
-	.probe		= gpio_led_probe,
-	.remove		= __devexit_p(gpio_led_remove),
-	.driver		= {
-		.name	= "leds-gpio",
-		.owner	= THIS_MODULE,
-	},
-};
-
-MODULE_ALIAS("platform:leds-gpio");
-#endif /* CONFIG_LEDS_GPIO_PLATFORM */
-
 /* Code to create from OpenFirmware platform devices */
 #ifdef CONFIG_LEDS_GPIO_OF
-#include <linux/of_platform.h>
-#include <linux/of_gpio.h>
-
-struct gpio_led_of_platform_data {
-	int num_leds;
-	struct gpio_led_data led_data[];
-};
-
-static int __devinit of_gpio_leds_probe(struct platform_device *ofdev,
-					const struct of_device_id *match)
+static struct gpio_leds_priv * __devinit gpio_leds_create_of(struct platform_device *pdev)
 {
-	struct device_node *np = ofdev->dev.of_node, *child;
-	struct gpio_led_of_platform_data *pdata;
+	struct device_node *np = pdev->dev.of_node, *child;
+	struct gpio_leds_priv *priv;
 	int count = 0, ret;
 
-	/* count LEDs defined by this device, so we know how much to allocate */
+	/* count LEDs in this device, so we know how much to allocate */
 	for_each_child_of_node(np, child)
 		count++;
 	if (!count)
-		return 0; /* or ENODEV? */
+		return NULL;
 
-	pdata = kzalloc(sizeof(*pdata) + sizeof(struct gpio_led_data) * count,
-			GFP_KERNEL);
-	if (!pdata)
-		return -ENOMEM;
+	priv = kzalloc(sizeof_gpio_leds_priv(count), GFP_KERNEL);
+	if (!priv)
+		return NULL;
 
 	for_each_child_of_node(np, child) {
 		struct gpio_led led = {};
@@ -256,92 +196,112 @@ static int __devinit of_gpio_leds_probe(struct platform_device *ofdev,
 		if (state) {
 			if (!strcmp(state, "keep"))
 				led.default_state = LEDS_GPIO_DEFSTATE_KEEP;
-			else if(!strcmp(state, "on"))
+			else if (!strcmp(state, "on"))
 				led.default_state = LEDS_GPIO_DEFSTATE_ON;
 			else
 				led.default_state = LEDS_GPIO_DEFSTATE_OFF;
 		}
 
-		ret = create_gpio_led(&led, &pdata->led_data[pdata->num_leds++],
-				      &ofdev->dev, NULL);
+		ret = create_gpio_led(&led, &priv->leds[priv->num_leds++],
+				      &pdev->dev, NULL);
 		if (ret < 0) {
 			of_node_put(child);
 			goto err;
 		}
 	}
 
-	dev_set_drvdata(&ofdev->dev, pdata);
-
-	return 0;
+	return priv;
 
 err:
-	for (count = pdata->num_leds - 2; count >= 0; count--)
-		delete_gpio_led(&pdata->led_data[count]);
+	for (count = priv->num_leds - 2; count >= 0; count--)
+		delete_gpio_led(&priv->leds[count]);
+	kfree(priv);
+	return NULL;
+}
 
-	kfree(pdata);
+static const struct of_device_id of_gpio_leds_match[] = {
+	{ .compatible = "gpio-leds", },
+	{},
+};
+#else
+static struct gpio_leds_priv * __devinit gpio_leds_create_of(struct platform_device *pdev)
+{
+	return NULL;
+}
+#define of_gpio_leds_match NULL
+#endif
 
-	return ret;
+
+static int __devinit gpio_led_probe(struct platform_device *pdev)
+{
+	struct gpio_led_platform_data *pdata = pdev->dev.platform_data;
+	struct gpio_leds_priv *priv;
+	int i, ret = 0;
+
+	if (pdata && pdata->num_leds) {
+		priv = kzalloc(sizeof_gpio_leds_priv(pdata->num_leds),
+				GFP_KERNEL);
+		if (!priv)
+			return -ENOMEM;
+
+		priv->num_leds = pdata->num_leds;
+		for (i = 0; i < priv->num_leds; i++) {
+			ret = create_gpio_led(&pdata->leds[i],
+					      &priv->leds[i],
+					      &pdev->dev, pdata->gpio_blink_set);
+			if (ret < 0) {
+				/* On failure: unwind the led creations */
+				for (i = i - 1; i >= 0; i--)
+					delete_gpio_led(&priv->leds[i]);
+				kfree(priv);
+				return ret;
+			}
+		}
+	} else {
+		priv = gpio_leds_create_of(pdev);
+		if (!priv)
+			return -ENODEV;
+	}
+
+	platform_set_drvdata(pdev, priv);
+
+	return 0;
 }
 
-static int __devexit of_gpio_leds_remove(struct platform_device *ofdev)
+static int __devexit gpio_led_remove(struct platform_device *pdev)
 {
-	struct gpio_led_of_platform_data *pdata = dev_get_drvdata(&ofdev->dev);
+	struct gpio_leds_priv *priv = dev_get_drvdata(&pdev->dev);
 	int i;
 
-	for (i = 0; i < pdata->num_leds; i++)
-		delete_gpio_led(&pdata->led_data[i]);
-
-	kfree(pdata);
+	for (i = 0; i < priv->num_leds; i++)
+		delete_gpio_led(&priv->leds[i]);
 
-	dev_set_drvdata(&ofdev->dev, NULL);
+	dev_set_drvdata(&pdev->dev, NULL);
+	kfree(priv);
 
 	return 0;
 }
 
-static const struct of_device_id of_gpio_leds_match[] = {
-	{ .compatible = "gpio-leds", },
-	{},
-};
-
-static struct of_platform_driver of_gpio_leds_driver = {
-	.driver = {
-		.name = "of_gpio_leds",
-		.owner = THIS_MODULE,
+static struct platform_driver gpio_led_driver = {
+	.probe		= gpio_led_probe,
+	.remove		= __devexit_p(gpio_led_remove),
+	.driver		= {
+		.name	= "leds-gpio",
+		.owner	= THIS_MODULE,
 		.of_match_table = of_gpio_leds_match,
 	},
-	.probe = of_gpio_leds_probe,
-	.remove = __devexit_p(of_gpio_leds_remove),
 };
-#endif
+
+MODULE_ALIAS("platform:leds-gpio");
 
 static int __init gpio_led_init(void)
 {
-	int ret = 0;
-
-#ifdef CONFIG_LEDS_GPIO_PLATFORM	
-	ret = platform_driver_register(&gpio_led_driver);
-	if (ret)
-		return ret;
-#endif
-#ifdef CONFIG_LEDS_GPIO_OF
-	ret = of_register_platform_driver(&of_gpio_leds_driver);
-#endif
-#ifdef CONFIG_LEDS_GPIO_PLATFORM	
-	if (ret)
-		platform_driver_unregister(&gpio_led_driver);
-#endif
-
-	return ret;
+	return platform_driver_register(&gpio_led_driver);
 }
 
 static void __exit gpio_led_exit(void)
 {
-#ifdef CONFIG_LEDS_GPIO_PLATFORM
 	platform_driver_unregister(&gpio_led_driver);
-#endif
-#ifdef CONFIG_LEDS_GPIO_OF
-	of_unregister_platform_driver(&of_gpio_leds_driver);
-#endif
 }
 
 module_init(gpio_led_init);

commit 25672b9dde18b86e736b8138bcffbaf7158d160a
Author: Davidlohr Bueso <dave@gnu.org>
Date:   Thu Nov 11 14:05:24 2010 -0800

    drivers/leds/leds-gpio.c: properly initialize return value
    
    In the event that none of the configs are set (CONFIG_LEDS_GPIO_PLATFORM,
    CONFIG_LEDS_GPIO_OF, CONFIG_LEDS_GPIO_PLATFORM), we will return a bogus
    value when initializing the module.
    
    Signed-off-by: Davidlohr Bueso <dave@gnu.org>
    Acked-by: Richard Purdie <rpurdie@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index ea57e05d08f3..4d9fa38d9ff6 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -316,7 +316,7 @@ static struct of_platform_driver of_gpio_leds_driver = {
 
 static int __init gpio_led_init(void)
 {
-	int ret;
+	int ret = 0;
 
 #ifdef CONFIG_LEDS_GPIO_PLATFORM	
 	ret = platform_driver_register(&gpio_led_driver);

commit 2dc11581376829303b98eadb2de253bee065a56a
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Fri Aug 6 09:25:50 2010 -0600

    of/device: Replace struct of_device with struct platform_device
    
    of_device is just an alias for platform_device, so remove it entirely.  Also
    replace to_of_device() with to_platform_device() and update comment blocks.
    
    This patch was initially generated from the following semantic patch, and then
    edited by hand to pick up the bits that coccinelle didn't catch.
    
    @@
    @@
    -struct of_device
    +struct platform_device
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Reviewed-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index cc22eeefa10b..ea57e05d08f3 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -224,7 +224,7 @@ struct gpio_led_of_platform_data {
 	struct gpio_led_data led_data[];
 };
 
-static int __devinit of_gpio_leds_probe(struct of_device *ofdev,
+static int __devinit of_gpio_leds_probe(struct platform_device *ofdev,
 					const struct of_device_id *match)
 {
 	struct device_node *np = ofdev->dev.of_node, *child;
@@ -283,7 +283,7 @@ static int __devinit of_gpio_leds_probe(struct of_device *ofdev,
 	return ret;
 }
 
-static int __devexit of_gpio_leds_remove(struct of_device *ofdev)
+static int __devexit of_gpio_leds_remove(struct platform_device *ofdev)
 {
 	struct gpio_led_of_platform_data *pdata = dev_get_drvdata(&ofdev->dev);
 	int i;

commit 5f8269da9c69dc3851f532af0d53693b521fdb91
Author: Richard Purdie <rpurdie@linux.intel.com>
Date:   Thu May 27 14:04:36 2010 +0100

    leds: Fix leds-gpio openfirmware compile issue
    
    Fix a compile issue when openfirmware is enabled from commit
    2146325df2c2640059a9e064890c30c6e259b458.
    
    Signed-off-by: Richard Purdie <rpurdie@linux.intel.com>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index 26843dd6b859..cc22eeefa10b 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -250,7 +250,6 @@ static int __devinit of_gpio_leds_probe(struct of_device *ofdev,
 		led.gpio = of_get_gpio_flags(child, 0, &flags);
 		led.active_low = flags & OF_GPIO_ACTIVE_LOW;
 		led.name = of_get_property(child, "label", NULL) ? : child->name;
-		led.blinking = 0;
 		led.default_trigger =
 			of_get_property(child, "linux,default-trigger", NULL);
 		state = of_get_property(child, "default-state", NULL);

commit 2146325df2c2640059a9e064890c30c6e259b458
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Sat May 22 20:54:55 2010 +1000

    leds: leds-gpio: Change blink_set callback to be able to turn off blinking
    
    The leds-gpio blink_set() callback follows the same prototype as the
    main leds subsystem blink_set() one.
    
    The problem is that to stop blink, normally, a leds driver does it
    in the brightness_set() callback when asked to set a new fixed value.
    
    However, with leds-gpio, the platform has no hook to do so, as this
    later callback results in a standard GPIO manipulation.
    
    This changes the leds-gpio specific callback to take a new argument
    that indicates whether the LED should be blinking or not and in what
    state it should be set if not. We also update the dns323 platform
    which seems to be the only user of this so far.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Richard Purdie <rpurdie@linux.intel.com>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index 6d94b0b9979c..26843dd6b859 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -26,7 +26,8 @@ struct gpio_led_data {
 	u8 new_level;
 	u8 can_sleep;
 	u8 active_low;
-	int (*platform_gpio_blink_set)(unsigned gpio,
+	u8 blinking;
+	int (*platform_gpio_blink_set)(unsigned gpio, int state,
 			unsigned long *delay_on, unsigned long *delay_off);
 };
 
@@ -35,7 +36,13 @@ static void gpio_led_work(struct work_struct *work)
 	struct gpio_led_data	*led_dat =
 		container_of(work, struct gpio_led_data, work);
 
-	gpio_set_value_cansleep(led_dat->gpio, led_dat->new_level);
+	if (led_dat->blinking) {
+		led_dat->platform_gpio_blink_set(led_dat->gpio,
+						 led_dat->new_level,
+						 NULL, NULL);
+		led_dat->blinking = 0;
+	} else
+		gpio_set_value_cansleep(led_dat->gpio, led_dat->new_level);
 }
 
 static void gpio_led_set(struct led_classdev *led_cdev,
@@ -60,8 +67,14 @@ static void gpio_led_set(struct led_classdev *led_cdev,
 	if (led_dat->can_sleep) {
 		led_dat->new_level = level;
 		schedule_work(&led_dat->work);
-	} else
-		gpio_set_value(led_dat->gpio, level);
+	} else {
+		if (led_dat->blinking) {
+			led_dat->platform_gpio_blink_set(led_dat->gpio, level,
+							 NULL, NULL);
+			led_dat->blinking = 0;
+		} else
+			gpio_set_value(led_dat->gpio, level);
+	}
 }
 
 static int gpio_blink_set(struct led_classdev *led_cdev,
@@ -70,12 +83,14 @@ static int gpio_blink_set(struct led_classdev *led_cdev,
 	struct gpio_led_data *led_dat =
 		container_of(led_cdev, struct gpio_led_data, cdev);
 
-	return led_dat->platform_gpio_blink_set(led_dat->gpio, delay_on, delay_off);
+	led_dat->blinking = 1;
+	return led_dat->platform_gpio_blink_set(led_dat->gpio, GPIO_LED_BLINK,
+						delay_on, delay_off);
 }
 
 static int __devinit create_gpio_led(const struct gpio_led *template,
 	struct gpio_led_data *led_dat, struct device *parent,
-	int (*blink_set)(unsigned, unsigned long *, unsigned long *))
+	int (*blink_set)(unsigned, int, unsigned long *, unsigned long *))
 {
 	int ret, state;
 
@@ -97,6 +112,7 @@ static int __devinit create_gpio_led(const struct gpio_led *template,
 	led_dat->gpio = template->gpio;
 	led_dat->can_sleep = gpio_cansleep(template->gpio);
 	led_dat->active_low = template->active_low;
+	led_dat->blinking = 0;
 	if (blink_set) {
 		led_dat->platform_gpio_blink_set = blink_set;
 		led_dat->cdev.blink_set = gpio_blink_set;
@@ -113,7 +129,7 @@ static int __devinit create_gpio_led(const struct gpio_led *template,
 	ret = gpio_direction_output(led_dat->gpio, led_dat->active_low ^ state);
 	if (ret < 0)
 		goto err;
-
+		
 	INIT_WORK(&led_dat->work, gpio_led_work);
 
 	ret = led_classdev_register(parent, &led_dat->cdev);
@@ -234,6 +250,7 @@ static int __devinit of_gpio_leds_probe(struct of_device *ofdev,
 		led.gpio = of_get_gpio_flags(child, 0, &flags);
 		led.active_low = flags & OF_GPIO_ACTIVE_LOW;
 		led.name = of_get_property(child, "label", NULL) ? : child->name;
+		led.blinking = 0;
 		led.default_trigger =
 			of_get_property(child, "linux,default-trigger", NULL);
 		state = of_get_property(child, "default-state", NULL);

commit 4018294b53d1dae026880e45f174c1cc63b5d435
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Tue Apr 13 16:13:02 2010 -0700

    of: Remove duplicate fields from of_platform_driver
    
    .name, .match_table and .owner are duplicated in both of_platform_driver
    and device_driver.  This patch is a removes the extra copies from struct
    of_platform_driver and converts all users to the device_driver members.
    
    This patch is a pretty mechanical change.  The usage model doesn't change
    and if any drivers have been missed, or if anything has been fixed up
    incorrectly, then it will fail with a compile time error, and the fixup
    will be trivial.  This patch looks big and scary because it touches so
    many files, but it should be pretty safe.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Acked-by: Sean MacLennan <smaclennan@pikatech.com>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index a77a23e783db..6d94b0b9979c 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -291,8 +291,8 @@ static struct of_platform_driver of_gpio_leds_driver = {
 	.driver = {
 		.name = "of_gpio_leds",
 		.owner = THIS_MODULE,
+		.of_match_table = of_gpio_leds_match,
 	},
-	.match_table = of_gpio_leds_match,
 	.probe = of_gpio_leds_probe,
 	.remove = __devexit_p(of_gpio_leds_remove),
 };

commit 61c7a080a5a061c976988fd4b844dfb468dda255
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Tue Apr 13 16:12:29 2010 -0700

    of: Always use 'struct device.of_node' to get device node pointer.
    
    The following structure elements duplicate the information in
    'struct device.of_node' and so are being eliminated.  This patch
    makes all readers of these elements use device.of_node instead.
    
    (struct of_device *)->node
    (struct dev_archdata *)->prom_node (sparc)
    (struct dev_archdata *)->of_node (powerpc & microblaze)
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index c6e4b772b757..a77a23e783db 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -211,7 +211,7 @@ struct gpio_led_of_platform_data {
 static int __devinit of_gpio_leds_probe(struct of_device *ofdev,
 					const struct of_device_id *match)
 {
-	struct device_node *np = ofdev->node, *child;
+	struct device_node *np = ofdev->dev.of_node, *child;
 	struct gpio_led_of_platform_data *pdata;
 	int count = 0, ret;
 

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index 0823e2622e8c..c6e4b772b757 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -14,6 +14,7 @@
 #include <linux/init.h>
 #include <linux/platform_device.h>
 #include <linux/leds.h>
+#include <linux/slab.h>
 #include <linux/workqueue.h>
 
 #include <asm/gpio.h>

commit 0493a4ff10959ff4c8e0d65efee25b7ffd4fa5db
Author: Anton Vorontsov <avorontsov@ru.mvista.com>
Date:   Thu Mar 11 13:58:47 2010 -0800

    leds-gpio: fix default state handling on OF platforms
    
    The driver wrongly sets default state for LEDs that don't specify
    default-state property.
    
    Currently the driver handles default state this way:
    
    memset(&led, 0, sizeof(led));
    for_each_child_of_node(np, child) {
            state = of_get_property(child, "default-state", NULL);
            if (state) {
                    if (!strcmp(state, "keep"))
                            led.default_state = LEDS_GPIO_DEFSTATE_KEEP;
                    ...
            }
            ret = create_gpio_led(&led, ...);
    }
    
    Which means that all LEDs that do not specify default-state will inherit
    the last value of the default-state property, which is wrong.
    
    This patch fixes the issue by moving LED's template initialization into
    the loop body.
    
    Signed-off-by: Anton Vorontsov <avorontsov@ru.mvista.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Richard Purdie <rpurdie@linux.intel.com>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index e5225d28f392..0823e2622e8c 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -211,7 +211,6 @@ static int __devinit of_gpio_leds_probe(struct of_device *ofdev,
 					const struct of_device_id *match)
 {
 	struct device_node *np = ofdev->node, *child;
-	struct gpio_led led;
 	struct gpio_led_of_platform_data *pdata;
 	int count = 0, ret;
 
@@ -226,8 +225,8 @@ static int __devinit of_gpio_leds_probe(struct of_device *ofdev,
 	if (!pdata)
 		return -ENOMEM;
 
-	memset(&led, 0, sizeof(led));
 	for_each_child_of_node(np, child) {
+		struct gpio_led led = {};
 		enum of_gpio_flags flags;
 		const char *state;
 

commit 0b4634fce1f3f7028421630260d54093276db490
Author: Dmitry Eremin-Solenikov <dbaryshkov@gmail.com>
Date:   Mon Nov 16 01:48:32 2009 +0300

    leds-gpio: fix possible crash on OF device unbinding
    
    If there are leds present in the OF tree, but the GPIOs for (some) of
    them are unavailable, led_data doesn't get populated with correct
    devices. Then, on device unbinding, one can crash the kernel.
    
    Workaround this by setting led->gpio to invalid value early.
    
    Signed-off-by: Dmitry Eremin-Solenikov <dbaryshkov@gmail.com>
    Signed-off-by: Richard Purdie <rpurdie@linux.intel.com>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index 7467980b8cf9..e5225d28f392 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -78,6 +78,8 @@ static int __devinit create_gpio_led(const struct gpio_led *template,
 {
 	int ret, state;
 
+	led_dat->gpio = -1;
+
 	/* skip leds that aren't available */
 	if (!gpio_is_valid(template->gpio)) {
 		printk(KERN_INFO "Skipping unavailable LED gpio %d (%s)\n",

commit 2fea09222ab48517d729a7fb4542092cf428f528
Author: Michal Simek <monstr@monstr.eu>
Date:   Thu Aug 6 16:04:51 2009 -0700

    leds: gpio-leds: fix typographics fault
    
    [akpm@linux-foundation.org: coding-style fixes]
    Signed-off-by: Michal Simek <monstr@monstr.eu>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Richard Purdie <rpurdie@linux.intel.com>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index 6b06638eb5b4..7467980b8cf9 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -80,7 +80,7 @@ static int __devinit create_gpio_led(const struct gpio_led *template,
 
 	/* skip leds that aren't available */
 	if (!gpio_is_valid(template->gpio)) {
-		printk(KERN_INFO "Skipping unavilable LED gpio %d (%s)\n", 
+		printk(KERN_INFO "Skipping unavailable LED gpio %d (%s)\n",
 				template->gpio, template->name);
 		return 0;
 	}

commit ed88bae6918fa990cbfe47316bd0f790121aaf00
Author: Trent Piepho <xyzzy@speakeasy.org>
Date:   Tue May 12 15:33:12 2009 -0700

    leds: Add options to have GPIO LEDs start on or keep their state
    
    There already is a "default-on" trigger but there are problems with it.
    
    For one, it's a inefficient way to do it and requires led trigger support
    to be compiled in.
    
    But the real reason is that is produces a glitch on the LED.  The GPIO is
    allocate with the LED *off*, then *later* when the trigger runs it is
    turned back on.  If the LED was already on via the GPIO's reset default or
    action of the firmware, this produces a glitch where the LED goes from on
    to off to on.  While normally this is fast enough that it wouldn't be
    noticeable to a human observer, there are still serious problems.
    
    One is that there may be something else on the GPIO line, like a hardware
    alarm or watchdog, that is fast enough to notice the glitch.
    
    Another is that the kernel may panic before the LED is turned back on, thus
    hanging with the LED in the wrong state.  This is not just speculation, but
    actually happened to me with an embedded system that has an LED which
    should turn off when the kernel finishes booting, which was left in the
    incorrect state due to a bug in the OF LED binding code.
    
    We also let GPIO LEDs get their initial value from whatever the current
    state of the GPIO line is.  On some systems the LEDs are put into some
    state by the firmware or hardware before Linux boots, and it is desired to
    have them keep this state which is otherwise unknown to Linux.
    
    This requires that the underlying GPIO driver support reading the value of
    output GPIOs.  Some drivers support this and some do not.
    
    The platform device binding gains a field in the platform data
    "default_state" that controls this.  There are three constants defined to
    select from on, off, or keeping the current state.  The OpenFirmware
    binding uses a property named "default-state" that can be set to "on",
    "off", or "keep".  The default if the property isn't present is off.
    
    Signed-off-by: Trent Piepho <xyzzy@speakeasy.org>
    Acked-by: Grant Likely <grant.likely@secretlab.ca>
    Acked-by: Wolfram Sang <w.sang@pengutronix.de>
    Acked-by: Sean MacLennan <smaclennan@pikatech.com>
    Signed-off-by: Richard Purdie <rpurdie@linux.intel.com>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index 76895e691042..6b06638eb5b4 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -76,7 +76,7 @@ static int __devinit create_gpio_led(const struct gpio_led *template,
 	struct gpio_led_data *led_dat, struct device *parent,
 	int (*blink_set)(unsigned, unsigned long *, unsigned long *))
 {
-	int ret;
+	int ret, state;
 
 	/* skip leds that aren't available */
 	if (!gpio_is_valid(template->gpio)) {
@@ -99,11 +99,15 @@ static int __devinit create_gpio_led(const struct gpio_led *template,
 		led_dat->cdev.blink_set = gpio_blink_set;
 	}
 	led_dat->cdev.brightness_set = gpio_led_set;
-	led_dat->cdev.brightness = LED_OFF;
+	if (template->default_state == LEDS_GPIO_DEFSTATE_KEEP)
+		state = !!gpio_get_value(led_dat->gpio) ^ led_dat->active_low;
+	else
+		state = (template->default_state == LEDS_GPIO_DEFSTATE_ON);
+	led_dat->cdev.brightness = state ? LED_FULL : LED_OFF;
 	if (!template->retain_state_suspended)
 		led_dat->cdev.flags |= LED_CORE_SUSPENDRESUME;
 
-	ret = gpio_direction_output(led_dat->gpio, led_dat->active_low);
+	ret = gpio_direction_output(led_dat->gpio, led_dat->active_low ^ state);
 	if (ret < 0)
 		goto err;
 
@@ -223,12 +227,22 @@ static int __devinit of_gpio_leds_probe(struct of_device *ofdev,
 	memset(&led, 0, sizeof(led));
 	for_each_child_of_node(np, child) {
 		enum of_gpio_flags flags;
+		const char *state;
 
 		led.gpio = of_get_gpio_flags(child, 0, &flags);
 		led.active_low = flags & OF_GPIO_ACTIVE_LOW;
 		led.name = of_get_property(child, "label", NULL) ? : child->name;
 		led.default_trigger =
 			of_get_property(child, "linux,default-trigger", NULL);
+		state = of_get_property(child, "default-state", NULL);
+		if (state) {
+			if (!strcmp(state, "keep"))
+				led.default_state = LEDS_GPIO_DEFSTATE_KEEP;
+			else if(!strcmp(state, "on"))
+				led.default_state = LEDS_GPIO_DEFSTATE_ON;
+			else
+				led.default_state = LEDS_GPIO_DEFSTATE_OFF;
+		}
 
 		ret = create_gpio_led(&led, &pdata->led_data[pdata->num_leds++],
 				      &ofdev->dev, NULL);

commit 7fd02170e25b3b60fc21cd7b64bf1ed42e6a7cbe
Author: Zhenwen Xu <helight.xu@gmail.com>
Date:   Wed Jun 10 12:48:51 2009 -0700

    leds: leds-gpio - fix a section mismatch
    
    WARNING: drivers/leds/leds-gpio.o(.text+0x153): Section mismatch in reference from the function gpio_led_probe() to the function .devinit.text:create_gpio_led()
    
    The function gpio_led_probe() references the function __devinit
    create_gpio_led().  This is often because gpio_led_probe lacks a __devinit
    annotation or the annotation of create_gpio_led is wrong.
    
    Signed-off-by: Zhenwen Xu <helight.xu@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Richard Purdie <rpurdie@linux.intel.com>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index d2109054de85..76895e691042 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -129,7 +129,7 @@ static void delete_gpio_led(struct gpio_led_data *led)
 }
 
 #ifdef CONFIG_LEDS_GPIO_PLATFORM
-static int gpio_led_probe(struct platform_device *pdev)
+static int __devinit gpio_led_probe(struct platform_device *pdev)
 {
 	struct gpio_led_platform_data *pdata = pdev->dev.platform_data;
 	struct gpio_led_data *leds_data;

commit ac15e95090c2588ada4904c8c4ae8edd347acdf0
Author: David Brownell <david-b@pacbell.net>
Date:   Tue Apr 7 17:51:49 2009 -0700

    leds: just ignore invalid GPIOs in leds-gpio
    
    Fix build problems with leds-gpio:
    
      CC      drivers/leds/leds-gpio.o
    drivers/leds/leds-gpio.c: In function 'create_gpio_led':
    drivers/leds/leds-gpio.c:85: warning: 'return' with no value, in function returning non-void
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Richard Purdie <rpurdie@linux.intel.com>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index 102ef4a14c5f..d2109054de85 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -82,7 +82,7 @@ static int __devinit create_gpio_led(const struct gpio_led *template,
 	if (!gpio_is_valid(template->gpio)) {
 		printk(KERN_INFO "Skipping unavilable LED gpio %d (%s)\n", 
 				template->gpio, template->name);
-		return;
+		return 0;
 	}
 
 	ret = gpio_request(template->gpio, template->name);

commit d379ee8acd0719736ee7f1d1ccc3b5765880eaf8
Author: David Brownell <dbrownell@users.sourceforge.net>
Date:   Thu Mar 5 16:46:44 2009 -0800

    leds: just ignore invalid GPIOs in leds-gpio
    
    Sometimes it's awkward to make sure that the array in the
    platform_data handed to the leds-gpio driver has only valid
    data ... some leds may not be always available, and coping
    with that currently requires patching or rebuilding the array.
    
    This patch fixes that by making it be OK to pass an invalid
    GPIO (such as "-EINVAL") ... such table entries are skipped.
    
    [rpurdie@linux.intel.com: adjusted to apply against other led tree changes]
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Tested-by: Diego Dompe <diego.dompe@ridgerun.com>
    Signed-off-by: Richard Purdie <rpurdie@linux.intel.com>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index 8fa352ac20f8..102ef4a14c5f 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -78,6 +78,13 @@ static int __devinit create_gpio_led(const struct gpio_led *template,
 {
 	int ret;
 
+	/* skip leds that aren't available */
+	if (!gpio_is_valid(template->gpio)) {
+		printk(KERN_INFO "Skipping unavilable LED gpio %d (%s)\n", 
+				template->gpio, template->name);
+		return;
+	}
+
 	ret = gpio_request(template->gpio, template->name);
 	if (ret < 0)
 		return ret;
@@ -114,6 +121,8 @@ static int __devinit create_gpio_led(const struct gpio_led *template,
 
 static void delete_gpio_led(struct gpio_led_data *led)
 {
+	if (!gpio_is_valid(led->gpio))
+		return;
 	led_classdev_unregister(&led->cdev);
 	cancel_work_sync(&led->work);
 	gpio_free(led->gpio);

commit defb512d2576992c63ba1c18c24eea31cfeaa26e
Author: Richard Purdie <rpurdie@linux.intel.com>
Date:   Tue Feb 17 15:04:07 2009 +0000

    leds: Add suspend/resume state flags to leds-gpio
    
    Add an option to preserve LED state when suspending/resuming to the LED
    gpio driver. Based on a suggestion from Robert Jarzmik.
    
    Tested-by: Robert Jarzmik <robert.jarzmik@free.fr>
    Signed-off-by: Richard Purdie <rpurdie@linux.intel.com>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index 0daa2d21cbde..8fa352ac20f8 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -93,7 +93,8 @@ static int __devinit create_gpio_led(const struct gpio_led *template,
 	}
 	led_dat->cdev.brightness_set = gpio_led_set;
 	led_dat->cdev.brightness = LED_OFF;
-	led_dat->cdev.flags |= LED_CORE_SUSPENDRESUME;
+	if (!template->retain_state_suspended)
+		led_dat->cdev.flags |= LED_CORE_SUSPENDRESUME;
 
 	ret = gpio_direction_output(led_dat->gpio, led_dat->active_low);
 	if (ret < 0)

commit b2bdc3e7130001804f27e7c1254930143119f435
Author: Richard Purdie <rpurdie@linux.intel.com>
Date:   Mon Feb 2 23:04:42 2009 +0000

    leds: Fix leds-gpio driver multiple module_init/exit usage
    
    You can't have multiple module_init()/module_exit calls so resort to messy
    ifdefs potentially pending some code refactoring.
    
    Signed-off-by: Richard Purdie <rpurdie@linux.intel.com>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index f8bcf98fc15c..0daa2d21cbde 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -178,19 +178,6 @@ static struct platform_driver gpio_led_driver = {
 	},
 };
 
-static int __init gpio_led_init(void)
-{
-	return platform_driver_register(&gpio_led_driver);
-}
-
-static void __exit gpio_led_exit(void)
-{
-	platform_driver_unregister(&gpio_led_driver);
-}
-
-module_init(gpio_led_init);
-module_exit(gpio_led_exit);
-
 MODULE_ALIAS("platform:leds-gpio");
 #endif /* CONFIG_LEDS_GPIO_PLATFORM */
 
@@ -283,19 +270,40 @@ static struct of_platform_driver of_gpio_leds_driver = {
 	.probe = of_gpio_leds_probe,
 	.remove = __devexit_p(of_gpio_leds_remove),
 };
+#endif
 
-static int __init of_gpio_leds_init(void)
+static int __init gpio_led_init(void)
 {
-	return of_register_platform_driver(&of_gpio_leds_driver);
+	int ret;
+
+#ifdef CONFIG_LEDS_GPIO_PLATFORM	
+	ret = platform_driver_register(&gpio_led_driver);
+	if (ret)
+		return ret;
+#endif
+#ifdef CONFIG_LEDS_GPIO_OF
+	ret = of_register_platform_driver(&of_gpio_leds_driver);
+#endif
+#ifdef CONFIG_LEDS_GPIO_PLATFORM	
+	if (ret)
+		platform_driver_unregister(&gpio_led_driver);
+#endif
+
+	return ret;
 }
-module_init(of_gpio_leds_init);
 
-static void __exit of_gpio_leds_exit(void)
+static void __exit gpio_led_exit(void)
 {
+#ifdef CONFIG_LEDS_GPIO_PLATFORM
+	platform_driver_unregister(&gpio_led_driver);
+#endif
+#ifdef CONFIG_LEDS_GPIO_OF
 	of_unregister_platform_driver(&of_gpio_leds_driver);
-}
-module_exit(of_gpio_leds_exit);
 #endif
+}
+
+module_init(gpio_led_init);
+module_exit(gpio_led_exit);
 
 MODULE_AUTHOR("Raphael Assenat <raph@8d.com>, Trent Piepho <tpiepho@freescale.com>");
 MODULE_DESCRIPTION("GPIO LED driver");

commit a7d878af94b223013a48078e0c8c0a654c24a057
Author: Trent Piepho <tpiepho@freescale.com>
Date:   Sat Jan 10 17:26:01 2009 +0000

    leds: Add openfirmware platform device support
    
    Add bindings to support LEDs defined as of_platform devices in addition to
    the existing bindings for platform devices.
    
    New options in Kconfig allow the platform binding code and/or the
    of_platform code to be turned on.  The of_platform code is of course only
    available on archs that have OF support.
    
    The existing probe and remove methods are refactored to use new functions
    create_gpio_led(), to create and register one led, and delete_gpio_led(),
    to unregister and free one led.  The new probe and remove methods for the
    of_platform driver can then share most of the common probe and remove code
    with the platform driver.
    
    The suspend and resume methods aren't shared, but they are very short.  The
    actual led driving code is the same for LEDs created by either binding.
    
    The OF bindings are based on patch by Anton Vorontsov
    <avorontsov@ru.mvista.com>.  They have been extended to allow multiple LEDs
    per device.
    
    Signed-off-by: Trent Piepho <tpiepho@freescale.com>
    Acked-by: Grant Likely <grant.likely@secretlab.ca>
    Acked-by: Sean MacLennan <smaclennan@pikatech.com>
    Signed-off-by: Richard Purdie <rpurdie@linux.intel.com>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index 2e3df08b649b..f8bcf98fc15c 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -3,6 +3,7 @@
  *
  * Copyright (C) 2007 8D Technologies inc.
  * Raphael Assenat <raph@8d.com>
+ * Copyright (C) 2008 Freescale Semiconductor, Inc.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -71,11 +72,57 @@ static int gpio_blink_set(struct led_classdev *led_cdev,
 	return led_dat->platform_gpio_blink_set(led_dat->gpio, delay_on, delay_off);
 }
 
+static int __devinit create_gpio_led(const struct gpio_led *template,
+	struct gpio_led_data *led_dat, struct device *parent,
+	int (*blink_set)(unsigned, unsigned long *, unsigned long *))
+{
+	int ret;
+
+	ret = gpio_request(template->gpio, template->name);
+	if (ret < 0)
+		return ret;
+
+	led_dat->cdev.name = template->name;
+	led_dat->cdev.default_trigger = template->default_trigger;
+	led_dat->gpio = template->gpio;
+	led_dat->can_sleep = gpio_cansleep(template->gpio);
+	led_dat->active_low = template->active_low;
+	if (blink_set) {
+		led_dat->platform_gpio_blink_set = blink_set;
+		led_dat->cdev.blink_set = gpio_blink_set;
+	}
+	led_dat->cdev.brightness_set = gpio_led_set;
+	led_dat->cdev.brightness = LED_OFF;
+	led_dat->cdev.flags |= LED_CORE_SUSPENDRESUME;
+
+	ret = gpio_direction_output(led_dat->gpio, led_dat->active_low);
+	if (ret < 0)
+		goto err;
+
+	INIT_WORK(&led_dat->work, gpio_led_work);
+
+	ret = led_classdev_register(parent, &led_dat->cdev);
+	if (ret < 0)
+		goto err;
+
+	return 0;
+err:
+	gpio_free(led_dat->gpio);
+	return ret;
+}
+
+static void delete_gpio_led(struct gpio_led_data *led)
+{
+	led_classdev_unregister(&led->cdev);
+	cancel_work_sync(&led->work);
+	gpio_free(led->gpio);
+}
+
+#ifdef CONFIG_LEDS_GPIO_PLATFORM
 static int gpio_led_probe(struct platform_device *pdev)
 {
 	struct gpio_led_platform_data *pdata = pdev->dev.platform_data;
-	struct gpio_led *cur_led;
-	struct gpio_led_data *leds_data, *led_dat;
+	struct gpio_led_data *leds_data;
 	int i, ret = 0;
 
 	if (!pdata)
@@ -87,35 +134,10 @@ static int gpio_led_probe(struct platform_device *pdev)
 		return -ENOMEM;
 
 	for (i = 0; i < pdata->num_leds; i++) {
-		cur_led = &pdata->leds[i];
-		led_dat = &leds_data[i];
-
-		ret = gpio_request(cur_led->gpio, cur_led->name);
+		ret = create_gpio_led(&pdata->leds[i], &leds_data[i],
+				      &pdev->dev, pdata->gpio_blink_set);
 		if (ret < 0)
 			goto err;
-
-		led_dat->cdev.name = cur_led->name;
-		led_dat->cdev.default_trigger = cur_led->default_trigger;
-		led_dat->gpio = cur_led->gpio;
-		led_dat->can_sleep = gpio_cansleep(cur_led->gpio);
-		led_dat->active_low = cur_led->active_low;
-		if (pdata->gpio_blink_set) {
-			led_dat->platform_gpio_blink_set = pdata->gpio_blink_set;
-			led_dat->cdev.blink_set = gpio_blink_set;
-		}
-		led_dat->cdev.brightness_set = gpio_led_set;
-		led_dat->cdev.brightness = LED_OFF;
-		led_dat->cdev.flags |= LED_CORE_SUSPENDRESUME;
-
-		gpio_direction_output(led_dat->gpio, led_dat->active_low);
-
-		INIT_WORK(&led_dat->work, gpio_led_work);
-
-		ret = led_classdev_register(&pdev->dev, &led_dat->cdev);
-		if (ret < 0) {
-			gpio_free(led_dat->gpio);
-			goto err;
-		}
 	}
 
 	platform_set_drvdata(pdev, leds_data);
@@ -123,13 +145,8 @@ static int gpio_led_probe(struct platform_device *pdev)
 	return 0;
 
 err:
-	if (i > 0) {
-		for (i = i - 1; i >= 0; i--) {
-			led_classdev_unregister(&leds_data[i].cdev);
-			cancel_work_sync(&leds_data[i].work);
-			gpio_free(leds_data[i].gpio);
-		}
-	}
+	for (i = i - 1; i >= 0; i--)
+		delete_gpio_led(&leds_data[i]);
 
 	kfree(leds_data);
 
@@ -144,11 +161,8 @@ static int __devexit gpio_led_remove(struct platform_device *pdev)
 
 	leds_data = platform_get_drvdata(pdev);
 
-	for (i = 0; i < pdata->num_leds; i++) {
-		led_classdev_unregister(&leds_data[i].cdev);
-		cancel_work_sync(&leds_data[i].work);
-		gpio_free(leds_data[i].gpio);
-	}
+	for (i = 0; i < pdata->num_leds; i++)
+		delete_gpio_led(&leds_data[i]);
 
 	kfree(leds_data);
 
@@ -177,7 +191,112 @@ static void __exit gpio_led_exit(void)
 module_init(gpio_led_init);
 module_exit(gpio_led_exit);
 
-MODULE_AUTHOR("Raphael Assenat <raph@8d.com>");
+MODULE_ALIAS("platform:leds-gpio");
+#endif /* CONFIG_LEDS_GPIO_PLATFORM */
+
+/* Code to create from OpenFirmware platform devices */
+#ifdef CONFIG_LEDS_GPIO_OF
+#include <linux/of_platform.h>
+#include <linux/of_gpio.h>
+
+struct gpio_led_of_platform_data {
+	int num_leds;
+	struct gpio_led_data led_data[];
+};
+
+static int __devinit of_gpio_leds_probe(struct of_device *ofdev,
+					const struct of_device_id *match)
+{
+	struct device_node *np = ofdev->node, *child;
+	struct gpio_led led;
+	struct gpio_led_of_platform_data *pdata;
+	int count = 0, ret;
+
+	/* count LEDs defined by this device, so we know how much to allocate */
+	for_each_child_of_node(np, child)
+		count++;
+	if (!count)
+		return 0; /* or ENODEV? */
+
+	pdata = kzalloc(sizeof(*pdata) + sizeof(struct gpio_led_data) * count,
+			GFP_KERNEL);
+	if (!pdata)
+		return -ENOMEM;
+
+	memset(&led, 0, sizeof(led));
+	for_each_child_of_node(np, child) {
+		enum of_gpio_flags flags;
+
+		led.gpio = of_get_gpio_flags(child, 0, &flags);
+		led.active_low = flags & OF_GPIO_ACTIVE_LOW;
+		led.name = of_get_property(child, "label", NULL) ? : child->name;
+		led.default_trigger =
+			of_get_property(child, "linux,default-trigger", NULL);
+
+		ret = create_gpio_led(&led, &pdata->led_data[pdata->num_leds++],
+				      &ofdev->dev, NULL);
+		if (ret < 0) {
+			of_node_put(child);
+			goto err;
+		}
+	}
+
+	dev_set_drvdata(&ofdev->dev, pdata);
+
+	return 0;
+
+err:
+	for (count = pdata->num_leds - 2; count >= 0; count--)
+		delete_gpio_led(&pdata->led_data[count]);
+
+	kfree(pdata);
+
+	return ret;
+}
+
+static int __devexit of_gpio_leds_remove(struct of_device *ofdev)
+{
+	struct gpio_led_of_platform_data *pdata = dev_get_drvdata(&ofdev->dev);
+	int i;
+
+	for (i = 0; i < pdata->num_leds; i++)
+		delete_gpio_led(&pdata->led_data[i]);
+
+	kfree(pdata);
+
+	dev_set_drvdata(&ofdev->dev, NULL);
+
+	return 0;
+}
+
+static const struct of_device_id of_gpio_leds_match[] = {
+	{ .compatible = "gpio-leds", },
+	{},
+};
+
+static struct of_platform_driver of_gpio_leds_driver = {
+	.driver = {
+		.name = "of_gpio_leds",
+		.owner = THIS_MODULE,
+	},
+	.match_table = of_gpio_leds_match,
+	.probe = of_gpio_leds_probe,
+	.remove = __devexit_p(of_gpio_leds_remove),
+};
+
+static int __init of_gpio_leds_init(void)
+{
+	return of_register_platform_driver(&of_gpio_leds_driver);
+}
+module_init(of_gpio_leds_init);
+
+static void __exit of_gpio_leds_exit(void)
+{
+	of_unregister_platform_driver(&of_gpio_leds_driver);
+}
+module_exit(of_gpio_leds_exit);
+#endif
+
+MODULE_AUTHOR("Raphael Assenat <raph@8d.com>, Trent Piepho <tpiepho@freescale.com>");
 MODULE_DESCRIPTION("GPIO LED driver");
 MODULE_LICENSE("GPL");
-MODULE_ALIAS("platform:leds-gpio");

commit 859cb7f2a4244ea6da206d3fe9cc8a6810947a68
Author: Richard Purdie <rpurdie@linux.intel.com>
Date:   Thu Jan 8 17:55:03 2009 +0000

    leds: Add suspend/resume to the core class
    
    Add suspend/resume to the core class and remove all the now unneeded
    code from various drivers. Originally the class code couldn't support
    suspend/resume but since class_device can there is no reason for
    each driver doing its own suspend/resume anymore.

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index b13bd2950e95..2e3df08b649b 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -105,6 +105,7 @@ static int gpio_led_probe(struct platform_device *pdev)
 		}
 		led_dat->cdev.brightness_set = gpio_led_set;
 		led_dat->cdev.brightness = LED_OFF;
+		led_dat->cdev.flags |= LED_CORE_SUSPENDRESUME;
 
 		gpio_direction_output(led_dat->gpio, led_dat->active_low);
 
@@ -154,44 +155,9 @@ static int __devexit gpio_led_remove(struct platform_device *pdev)
 	return 0;
 }
 
-#ifdef CONFIG_PM
-static int gpio_led_suspend(struct platform_device *pdev, pm_message_t state)
-{
-	struct gpio_led_platform_data *pdata = pdev->dev.platform_data;
-	struct gpio_led_data *leds_data;
-	int i;
-
-	leds_data = platform_get_drvdata(pdev);
-
-	for (i = 0; i < pdata->num_leds; i++)
-		led_classdev_suspend(&leds_data[i].cdev);
-
-	return 0;
-}
-
-static int gpio_led_resume(struct platform_device *pdev)
-{
-	struct gpio_led_platform_data *pdata = pdev->dev.platform_data;
-	struct gpio_led_data *leds_data;
-	int i;
-
-	leds_data = platform_get_drvdata(pdev);
-
-	for (i = 0; i < pdata->num_leds; i++)
-		led_classdev_resume(&leds_data[i].cdev);
-
-	return 0;
-}
-#else
-#define gpio_led_suspend NULL
-#define gpio_led_resume NULL
-#endif
-
 static struct platform_driver gpio_led_driver = {
 	.probe		= gpio_led_probe,
 	.remove		= __devexit_p(gpio_led_remove),
-	.suspend	= gpio_led_suspend,
-	.resume		= gpio_led_resume,
 	.driver		= {
 		.name	= "leds-gpio",
 		.owner	= THIS_MODULE,

commit ca3259b3603539e72faacc6821050ee889a52103
Author: Herbert Valerio Riedel <hvr@gnu.org>
Date:   Sun Mar 9 23:48:25 2008 +0000

    leds: enable support for blink_set() platform hook in leds-gpio
    
    Enhance leds-gpio to provide hardware-based led flashing by passing
    through the blink_set() call to a optionally set platform-specific
    function pointer.
    
    Signed-off-by: Herbert Valerio Riedel <hvr@gnu.org>
    Signed-off-by: Richard Purdie <rpurdie@rpsys.net>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index 1aae8b332134..b13bd2950e95 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -24,6 +24,8 @@ struct gpio_led_data {
 	u8 new_level;
 	u8 can_sleep;
 	u8 active_low;
+	int (*platform_gpio_blink_set)(unsigned gpio,
+			unsigned long *delay_on, unsigned long *delay_off);
 };
 
 static void gpio_led_work(struct work_struct *work)
@@ -60,6 +62,15 @@ static void gpio_led_set(struct led_classdev *led_cdev,
 		gpio_set_value(led_dat->gpio, level);
 }
 
+static int gpio_blink_set(struct led_classdev *led_cdev,
+	unsigned long *delay_on, unsigned long *delay_off)
+{
+	struct gpio_led_data *led_dat =
+		container_of(led_cdev, struct gpio_led_data, cdev);
+
+	return led_dat->platform_gpio_blink_set(led_dat->gpio, delay_on, delay_off);
+}
+
 static int gpio_led_probe(struct platform_device *pdev)
 {
 	struct gpio_led_platform_data *pdata = pdev->dev.platform_data;
@@ -88,6 +99,10 @@ static int gpio_led_probe(struct platform_device *pdev)
 		led_dat->gpio = cur_led->gpio;
 		led_dat->can_sleep = gpio_cansleep(cur_led->gpio);
 		led_dat->active_low = cur_led->active_low;
+		if (pdata->gpio_blink_set) {
+			led_dat->platform_gpio_blink_set = pdata->gpio_blink_set;
+			led_dat->cdev.blink_set = gpio_blink_set;
+		}
 		led_dat->cdev.brightness_set = gpio_led_set;
 		led_dat->cdev.brightness = LED_OFF;
 

commit 3c4ded9715c05724939c9a4bd72555c2ade71d97
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Tue Apr 15 14:34:30 2008 -0700

    leds: fix platform driver hotplug/coldplug
    
    Since 43cc71eed1250755986da4c0f9898f9a635cb3bf, the platform
    modalias is prefixed with "platform:". Add MODULE_ALIAS() to the
    hotpluggable platform LED drivers, to re-enable auto loading.
    
    [dbrownell@users.sourceforge.net: more drivers, registration fixes]
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Acked-by: Richard Purdie <rpurdie@rpsys.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index 4c0b05852cb6..1aae8b332134 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -199,3 +199,4 @@ module_exit(gpio_led_exit);
 MODULE_AUTHOR("Raphael Assenat <raph@8d.com>");
 MODULE_DESCRIPTION("GPIO LED driver");
 MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:leds-gpio");

commit 306dd85c1d41e20a07d1e821e27f5df4927bb5e7
Author: David Brownell <dbrownell@users.sourceforge.net>
Date:   Thu Mar 27 00:59:02 2008 +0000

    leds: Remove incorrect use of preempt_count() from leds-gpio
    
    It appears that we can't just check to see if we're in a task
    context ... so instead of trying that, just make the relevant
    leds always schedule a little worklet.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Richard Purdie <rpurdie@rpsys.net>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index d13b622419df..4c0b05852cb6 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -49,13 +49,13 @@ static void gpio_led_set(struct led_classdev *led_cdev,
 	if (led_dat->active_low)
 		level = !level;
 
-	/* setting GPIOs with I2C/etc requires a preemptible task context */
+	/* Setting GPIOs with I2C/etc requires a task context, and we don't
+	 * seem to have a reliable way to know if we're already in one; so
+	 * let's just assume the worst.
+	 */
 	if (led_dat->can_sleep) {
-		if (preempt_count()) {
-			led_dat->new_level = level;
-			schedule_work(&led_dat->work);
-		} else
-			gpio_set_value_cansleep(led_dat->gpio, level);
+		led_dat->new_level = level;
+		schedule_work(&led_dat->work);
 	} else
 		gpio_set_value(led_dat->gpio, level);
 }

commit d95cbe6158a679d50e03787bb1dc21ff73dac372
Author: Uwe Kleine-König <Uwe.Kleine-Koenig@digi.com>
Date:   Sun Mar 9 20:42:27 2008 +0000

    leds: Fix potential leds-gpio oops
    
    Call gpio_cansleep only after gpio_request succeeded avoiding an
    oops.
    
    Signed-off-by: Uwe Kleine-König <Uwe.Kleine-Koenig@digi.com>
    Acked-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Richard Purdie <rpurdie@rpsys.net>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index 6c0a9c4761ee..d13b622419df 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -79,6 +79,10 @@ static int gpio_led_probe(struct platform_device *pdev)
 		cur_led = &pdata->leds[i];
 		led_dat = &leds_data[i];
 
+		ret = gpio_request(cur_led->gpio, cur_led->name);
+		if (ret < 0)
+			goto err;
+
 		led_dat->cdev.name = cur_led->name;
 		led_dat->cdev.default_trigger = cur_led->default_trigger;
 		led_dat->gpio = cur_led->gpio;
@@ -87,10 +91,6 @@ static int gpio_led_probe(struct platform_device *pdev)
 		led_dat->cdev.brightness_set = gpio_led_set;
 		led_dat->cdev.brightness = LED_OFF;
 
-		ret = gpio_request(led_dat->gpio, led_dat->cdev.name);
-		if (ret < 0)
-			goto err;
-
 		gpio_direction_output(led_dat->gpio, led_dat->active_low);
 
 		INIT_WORK(&led_dat->work, gpio_led_work);

commit 2b7f1b8c8f4a8991dfeefc31844e15c642b6de2a
Author: Raphael Assenat <raph@8d.com>
Date:   Sun Jan 13 22:55:18 2008 +0000

    leds: Fix led-gpio active_low default brightness
    
    When gpio_direction_output() is called, led_dat->active_low is used
    as default value. This means that the led will always be off by
    default. cdev.brightness should really have been set to LED_OFF
    unconditionally to reflect this behavior.
    
    Signed-off-by: Raphael Assenat <raph@8d.com>
    Signed-off-by: Richard Purdie <rpurdie@rpsys.net>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index 99bc50059d35..6c0a9c4761ee 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -85,7 +85,7 @@ static int gpio_led_probe(struct platform_device *pdev)
 		led_dat->can_sleep = gpio_cansleep(cur_led->gpio);
 		led_dat->active_low = cur_led->active_low;
 		led_dat->cdev.brightness_set = gpio_led_set;
-		led_dat->cdev.brightness = cur_led->active_low ? LED_FULL : LED_OFF;
+		led_dat->cdev.brightness = LED_OFF;
 
 		ret = gpio_request(led_dat->gpio, led_dat->cdev.name);
 		if (ret < 0)

commit 199fb21d520ac8c09de1f1288e667988815aa79a
Author: David Brownell <dbrownell@users.sourceforge.net>
Date:   Wed Oct 31 10:37:37 2007 +0100

    leds: bugfixes for leds-gpio
    
    Three bugfixes to the leds-gpio driver, plus minor whitespace tweaks:
    
     - Do the INIT_WORK() before registering each LED, so if its trigger
       becomes immediately active it can schedule work without oopsing..
    
     - Use normal registration, not platform_driver_probe(), so that
       devices appearing "late" (hotplug type) can still be bound.
    
     - Mark the driver remove code as "__devexit", preventing oopses
       when the underlying device is removed.
    
    These issues came up when using this driver with some GPIO expanders
    living on serial busses, which act unlike "normal" platform devices:
    they can appear and vanish along with the serial bus driver.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Richard Purdie <rpurdie@rpsys.net>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index 47d90db280ce..99bc50059d35 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -60,7 +60,7 @@ static void gpio_led_set(struct led_classdev *led_cdev,
 		gpio_set_value(led_dat->gpio, level);
 }
 
-static int __init gpio_led_probe(struct platform_device *pdev)
+static int gpio_led_probe(struct platform_device *pdev)
 {
 	struct gpio_led_platform_data *pdata = pdev->dev.platform_data;
 	struct gpio_led *cur_led;
@@ -93,13 +93,13 @@ static int __init gpio_led_probe(struct platform_device *pdev)
 
 		gpio_direction_output(led_dat->gpio, led_dat->active_low);
 
+		INIT_WORK(&led_dat->work, gpio_led_work);
+
 		ret = led_classdev_register(&pdev->dev, &led_dat->cdev);
 		if (ret < 0) {
 			gpio_free(led_dat->gpio);
 			goto err;
 		}
-
-		INIT_WORK(&led_dat->work, gpio_led_work);
 	}
 
 	platform_set_drvdata(pdev, leds_data);
@@ -110,17 +110,17 @@ static int __init gpio_led_probe(struct platform_device *pdev)
 	if (i > 0) {
 		for (i = i - 1; i >= 0; i--) {
 			led_classdev_unregister(&leds_data[i].cdev);
+			cancel_work_sync(&leds_data[i].work);
 			gpio_free(leds_data[i].gpio);
 		}
 	}
 
-	flush_scheduled_work();
 	kfree(leds_data);
 
 	return ret;
 }
 
-static int __exit gpio_led_remove(struct platform_device *pdev)
+static int __devexit gpio_led_remove(struct platform_device *pdev)
 {
 	int i;
 	struct gpio_led_platform_data *pdata = pdev->dev.platform_data;
@@ -130,9 +130,10 @@ static int __exit gpio_led_remove(struct platform_device *pdev)
 
 	for (i = 0; i < pdata->num_leds; i++) {
 		led_classdev_unregister(&leds_data[i].cdev);
+		cancel_work_sync(&leds_data[i].work);
 		gpio_free(leds_data[i].gpio);
 	}
-	
+
 	kfree(leds_data);
 
 	return 0;
@@ -144,7 +145,7 @@ static int gpio_led_suspend(struct platform_device *pdev, pm_message_t state)
 	struct gpio_led_platform_data *pdata = pdev->dev.platform_data;
 	struct gpio_led_data *leds_data;
 	int i;
-	
+
 	leds_data = platform_get_drvdata(pdev);
 
 	for (i = 0; i < pdata->num_leds; i++)
@@ -172,7 +173,8 @@ static int gpio_led_resume(struct platform_device *pdev)
 #endif
 
 static struct platform_driver gpio_led_driver = {
-	.remove		= __exit_p(gpio_led_remove),
+	.probe		= gpio_led_probe,
+	.remove		= __devexit_p(gpio_led_remove),
 	.suspend	= gpio_led_suspend,
 	.resume		= gpio_led_resume,
 	.driver		= {
@@ -183,7 +185,7 @@ static struct platform_driver gpio_led_driver = {
 
 static int __init gpio_led_init(void)
 {
-	return platform_driver_probe(&gpio_led_driver, gpio_led_probe);
+	return platform_driver_register(&gpio_led_driver);
 }
 
 static void __exit gpio_led_exit(void)

commit 00852279af5ad26956bc7f4d0e86fdb40192e542
Author: David Brownell <david-b@pacbell.net>
Date:   Thu May 10 10:51:41 2007 +0100

    leds: Teach leds-gpio to handle timer-unsafe GPIOs
    
    Teach the new leds-gpio driver that some GPIOs can't be accessed from
    timer callbacks ... which is how all today's standard triggers use them.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Richard Purdie <rpurdie@rpsys.net>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
index 431dcb61902c..47d90db280ce 100644
--- a/drivers/leds/leds-gpio.c
+++ b/drivers/leds/leds-gpio.c
@@ -13,14 +13,26 @@
 #include <linux/init.h>
 #include <linux/platform_device.h>
 #include <linux/leds.h>
+#include <linux/workqueue.h>
+
 #include <asm/gpio.h>
 
 struct gpio_led_data {
 	struct led_classdev cdev;
 	unsigned gpio;
+	struct work_struct work;
+	u8 new_level;
+	u8 can_sleep;
 	u8 active_low;
 };
 
+static void gpio_led_work(struct work_struct *work)
+{
+	struct gpio_led_data	*led_dat =
+		container_of(work, struct gpio_led_data, work);
+
+	gpio_set_value_cansleep(led_dat->gpio, led_dat->new_level);
+}
 
 static void gpio_led_set(struct led_classdev *led_cdev,
 	enum led_brightness value)
@@ -37,7 +49,15 @@ static void gpio_led_set(struct led_classdev *led_cdev,
 	if (led_dat->active_low)
 		level = !level;
 
-	gpio_set_value(led_dat->gpio, level);
+	/* setting GPIOs with I2C/etc requires a preemptible task context */
+	if (led_dat->can_sleep) {
+		if (preempt_count()) {
+			led_dat->new_level = level;
+			schedule_work(&led_dat->work);
+		} else
+			gpio_set_value_cansleep(led_dat->gpio, level);
+	} else
+		gpio_set_value(led_dat->gpio, level);
 }
 
 static int __init gpio_led_probe(struct platform_device *pdev)
@@ -62,6 +82,7 @@ static int __init gpio_led_probe(struct platform_device *pdev)
 		led_dat->cdev.name = cur_led->name;
 		led_dat->cdev.default_trigger = cur_led->default_trigger;
 		led_dat->gpio = cur_led->gpio;
+		led_dat->can_sleep = gpio_cansleep(cur_led->gpio);
 		led_dat->active_low = cur_led->active_low;
 		led_dat->cdev.brightness_set = gpio_led_set;
 		led_dat->cdev.brightness = cur_led->active_low ? LED_FULL : LED_OFF;
@@ -77,6 +98,8 @@ static int __init gpio_led_probe(struct platform_device *pdev)
 			gpio_free(led_dat->gpio);
 			goto err;
 		}
+
+		INIT_WORK(&led_dat->work, gpio_led_work);
 	}
 
 	platform_set_drvdata(pdev, leds_data);
@@ -90,6 +113,8 @@ static int __init gpio_led_probe(struct platform_device *pdev)
 			gpio_free(leds_data[i].gpio);
 		}
 	}
+
+	flush_scheduled_work();
 	kfree(leds_data);
 
 	return ret;

commit 22e03f3b58dfcca30f0c8de185022132459638d1
Author: Raphael Assenat <raph@8d.com>
Date:   Tue Feb 27 19:49:53 2007 +0000

    leds: Add generic GPIO LED driver
    
    This patch adds support for GPIO connected leds via the new GPIO framework.
    
    Information about leds (gpio, polarity, name, default trigger) is passed
    to the driver via platform_data.
    
    Signed-off-by: Raphael Assenat <raph@8d.com>
    Signed-off-by: Richard Purdie <rpurdie@rpsys.net>

diff --git a/drivers/leds/leds-gpio.c b/drivers/leds/leds-gpio.c
new file mode 100644
index 000000000000..431dcb61902c
--- /dev/null
+++ b/drivers/leds/leds-gpio.c
@@ -0,0 +1,174 @@
+/*
+ * LEDs driver for GPIOs
+ *
+ * Copyright (C) 2007 8D Technologies inc.
+ * Raphael Assenat <raph@8d.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/leds.h>
+#include <asm/gpio.h>
+
+struct gpio_led_data {
+	struct led_classdev cdev;
+	unsigned gpio;
+	u8 active_low;
+};
+
+
+static void gpio_led_set(struct led_classdev *led_cdev,
+	enum led_brightness value)
+{
+	struct gpio_led_data *led_dat =
+		container_of(led_cdev, struct gpio_led_data, cdev);
+	int level;
+
+	if (value == LED_OFF)
+		level = 0;
+	else
+		level = 1;
+
+	if (led_dat->active_low)
+		level = !level;
+
+	gpio_set_value(led_dat->gpio, level);
+}
+
+static int __init gpio_led_probe(struct platform_device *pdev)
+{
+	struct gpio_led_platform_data *pdata = pdev->dev.platform_data;
+	struct gpio_led *cur_led;
+	struct gpio_led_data *leds_data, *led_dat;
+	int i, ret = 0;
+
+	if (!pdata)
+		return -EBUSY;
+
+	leds_data = kzalloc(sizeof(struct gpio_led_data) * pdata->num_leds,
+				GFP_KERNEL);
+	if (!leds_data)
+		return -ENOMEM;
+
+	for (i = 0; i < pdata->num_leds; i++) {
+		cur_led = &pdata->leds[i];
+		led_dat = &leds_data[i];
+
+		led_dat->cdev.name = cur_led->name;
+		led_dat->cdev.default_trigger = cur_led->default_trigger;
+		led_dat->gpio = cur_led->gpio;
+		led_dat->active_low = cur_led->active_low;
+		led_dat->cdev.brightness_set = gpio_led_set;
+		led_dat->cdev.brightness = cur_led->active_low ? LED_FULL : LED_OFF;
+
+		ret = gpio_request(led_dat->gpio, led_dat->cdev.name);
+		if (ret < 0)
+			goto err;
+
+		gpio_direction_output(led_dat->gpio, led_dat->active_low);
+
+		ret = led_classdev_register(&pdev->dev, &led_dat->cdev);
+		if (ret < 0) {
+			gpio_free(led_dat->gpio);
+			goto err;
+		}
+	}
+
+	platform_set_drvdata(pdev, leds_data);
+
+	return 0;
+
+err:
+	if (i > 0) {
+		for (i = i - 1; i >= 0; i--) {
+			led_classdev_unregister(&leds_data[i].cdev);
+			gpio_free(leds_data[i].gpio);
+		}
+	}
+	kfree(leds_data);
+
+	return ret;
+}
+
+static int __exit gpio_led_remove(struct platform_device *pdev)
+{
+	int i;
+	struct gpio_led_platform_data *pdata = pdev->dev.platform_data;
+	struct gpio_led_data *leds_data;
+
+	leds_data = platform_get_drvdata(pdev);
+
+	for (i = 0; i < pdata->num_leds; i++) {
+		led_classdev_unregister(&leds_data[i].cdev);
+		gpio_free(leds_data[i].gpio);
+	}
+	
+	kfree(leds_data);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int gpio_led_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct gpio_led_platform_data *pdata = pdev->dev.platform_data;
+	struct gpio_led_data *leds_data;
+	int i;
+	
+	leds_data = platform_get_drvdata(pdev);
+
+	for (i = 0; i < pdata->num_leds; i++)
+		led_classdev_suspend(&leds_data[i].cdev);
+
+	return 0;
+}
+
+static int gpio_led_resume(struct platform_device *pdev)
+{
+	struct gpio_led_platform_data *pdata = pdev->dev.platform_data;
+	struct gpio_led_data *leds_data;
+	int i;
+
+	leds_data = platform_get_drvdata(pdev);
+
+	for (i = 0; i < pdata->num_leds; i++)
+		led_classdev_resume(&leds_data[i].cdev);
+
+	return 0;
+}
+#else
+#define gpio_led_suspend NULL
+#define gpio_led_resume NULL
+#endif
+
+static struct platform_driver gpio_led_driver = {
+	.remove		= __exit_p(gpio_led_remove),
+	.suspend	= gpio_led_suspend,
+	.resume		= gpio_led_resume,
+	.driver		= {
+		.name	= "leds-gpio",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init gpio_led_init(void)
+{
+	return platform_driver_probe(&gpio_led_driver, gpio_led_probe);
+}
+
+static void __exit gpio_led_exit(void)
+{
+	platform_driver_unregister(&gpio_led_driver);
+}
+
+module_init(gpio_led_init);
+module_exit(gpio_led_exit);
+
+MODULE_AUTHOR("Raphael Assenat <raph@8d.com>");
+MODULE_DESCRIPTION("GPIO LED driver");
+MODULE_LICENSE("GPL");
