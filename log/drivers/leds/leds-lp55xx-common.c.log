commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/leds/leds-lp55xx-common.c b/drivers/leds/leds-lp55xx-common.c
index 723f2f17497a..44ced02b49f9 100644
--- a/drivers/leds/leds-lp55xx-common.c
+++ b/drivers/leds/leds-lp55xx-common.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * LP5521/LP5523/LP55231/LP5562 Common Driver
  *
@@ -5,10 +6,6 @@
  *
  * Author: Milo(Woogyom) Kim <milo.kim@ti.com>
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
  * Derived from leds-lp5521.c, leds-lp5523.c
  */
 

commit 5ddb0869bfc1bca6cfc592c74c64a026f936638c
Author: Michal Kazior <michal@plume.com>
Date:   Mon Feb 11 10:29:27 2019 +0100

    leds: lp55xx: fix null deref on firmware load failure
    
    I've stumbled upon a kernel crash and the logs
    pointed me towards the lp5562 driver:
    
    > <4>[306013.841294] lp5562 0-0030: Direct firmware load for lp5562 failed with error -2
    > <4>[306013.894990] lp5562 0-0030: Falling back to user helper
    > ...
    > <3>[306073.924886] lp5562 0-0030: firmware request failed
    > <1>[306073.939456] Unable to handle kernel NULL pointer dereference at virtual address 00000000
    > <4>[306074.251011] PC is at _raw_spin_lock+0x1c/0x58
    > <4>[306074.255539] LR is at release_firmware+0x6c/0x138
    > ...
    
    After taking a look I noticed firmware_release()
    could be called with either NULL or a dangling
    pointer.
    
    Fixes: 10c06d178df11 ("leds-lp55xx: support firmware interface")
    Signed-off-by: Michal Kazior <michal@plume.com>
    Signed-off-by: Jacek Anaszewski <jacek.anaszewski@gmail.com>

diff --git a/drivers/leds/leds-lp55xx-common.c b/drivers/leds/leds-lp55xx-common.c
index 3d79a6380761..723f2f17497a 100644
--- a/drivers/leds/leds-lp55xx-common.c
+++ b/drivers/leds/leds-lp55xx-common.c
@@ -201,7 +201,7 @@ static void lp55xx_firmware_loaded(const struct firmware *fw, void *context)
 
 	if (!fw) {
 		dev_err(dev, "firmware request failed\n");
-		goto out;
+		return;
 	}
 
 	/* handling firmware data is chip dependent */
@@ -214,9 +214,9 @@ static void lp55xx_firmware_loaded(const struct firmware *fw, void *context)
 
 	mutex_unlock(&chip->lock);
 
-out:
 	/* firmware should be released for other channel use */
 	release_firmware(chip->fw);
+	chip->fw = NULL;
 }
 
 static int lp55xx_request_firmware(struct lp55xx_chip *chip)

commit a86854d0c599b3202307abceb68feee4d7061578
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Jun 12 14:07:58 2018 -0700

    treewide: devm_kzalloc() -> devm_kcalloc()
    
    The devm_kzalloc() function has a 2-factor argument form, devm_kcalloc().
    This patch replaces cases of:
    
            devm_kzalloc(handle, a * b, gfp)
    
    with:
            devm_kcalloc(handle, a * b, gfp)
    
    as well as handling cases of:
    
            devm_kzalloc(handle, a * b * c, gfp)
    
    with:
    
            devm_kzalloc(handle, array3_size(a, b, c), gfp)
    
    as it's slightly less ugly than:
    
            devm_kcalloc(handle, array_size(a, b), c, gfp)
    
    This does, however, attempt to ignore constant size factors like:
    
            devm_kzalloc(handle, 4 * 1024, gfp)
    
    though any constants defined via macros get caught up in the conversion.
    
    Any factors with a sizeof() of "unsigned char", "char", and "u8" were
    dropped, since they're redundant.
    
    Some manual whitespace fixes were needed in this patch, as Coccinelle
    really liked to write "=devm_kcalloc..." instead of "= devm_kcalloc...".
    
    The Coccinelle script used for this was:
    
    // Fix redundant parens around sizeof().
    @@
    expression HANDLE;
    type TYPE;
    expression THING, E;
    @@
    
    (
      devm_kzalloc(HANDLE,
    -       (sizeof(TYPE)) * E
    +       sizeof(TYPE) * E
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (sizeof(THING)) * E
    +       sizeof(THING) * E
      , ...)
    )
    
    // Drop single-byte sizes and redundant parens.
    @@
    expression HANDLE;
    expression COUNT;
    typedef u8;
    typedef __u8;
    @@
    
    (
      devm_kzalloc(HANDLE,
    -       sizeof(u8) * (COUNT)
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(__u8) * (COUNT)
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(char) * (COUNT)
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(unsigned char) * (COUNT)
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(u8) * COUNT
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(__u8) * COUNT
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(char) * COUNT
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(unsigned char) * COUNT
    +       COUNT
      , ...)
    )
    
    // 2-factor product with sizeof(type/expression) and identifier or constant.
    @@
    expression HANDLE;
    type TYPE;
    expression THING;
    identifier COUNT_ID;
    constant COUNT_CONST;
    @@
    
    (
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * (COUNT_ID)
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * COUNT_ID
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * COUNT_CONST
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * (COUNT_ID)
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * COUNT_ID
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(THING)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * COUNT_CONST
    +       COUNT_CONST, sizeof(THING)
      , ...)
    )
    
    // 2-factor product, only identifiers.
    @@
    expression HANDLE;
    identifier SIZE, COUNT;
    @@
    
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       SIZE * COUNT
    +       COUNT, SIZE
      , ...)
    
    // 3-factor product with 1 sizeof(type) or sizeof(expression), with
    // redundant parens removed.
    @@
    expression HANDLE;
    expression THING;
    identifier STRIDE, COUNT;
    type TYPE;
    @@
    
    (
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    )
    
    // 3-factor product with 2 sizeof(variable), with redundant parens removed.
    @@
    expression HANDLE;
    expression THING1, THING2;
    identifier COUNT;
    type TYPE1, TYPE2;
    @@
    
    (
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE1) * sizeof(TYPE2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    )
    
    // 3-factor product, only identifiers, with redundant parens removed.
    @@
    expression HANDLE;
    identifier STRIDE, SIZE, COUNT;
    @@
    
    (
      devm_kzalloc(HANDLE,
    -       (COUNT) * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       COUNT * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       COUNT * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (COUNT) * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       COUNT * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (COUNT) * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (COUNT) * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       COUNT * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    )
    
    // Any remaining multi-factor products, first at least 3-factor products,
    // when they're not all constants...
    @@
    expression HANDLE;
    expression E1, E2, E3;
    constant C1, C2, C3;
    @@
    
    (
      devm_kzalloc(HANDLE, C1 * C2 * C3, ...)
    |
      devm_kzalloc(HANDLE,
    -       (E1) * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (E1) * (E2) * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (E1) * (E2) * (E3)
    +       array3_size(E1, E2, E3)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       E1 * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    )
    
    // And then all remaining 2 factors products when they're not all constants,
    // keeping sizeof() as the second factor argument.
    @@
    expression HANDLE;
    expression THING, E1, E2;
    type TYPE;
    constant C1, C2, C3;
    @@
    
    (
      devm_kzalloc(HANDLE, sizeof(THING) * C2, ...)
    |
      devm_kzalloc(HANDLE, sizeof(TYPE) * C2, ...)
    |
      devm_kzalloc(HANDLE, C1 * C2 * C3, ...)
    |
      devm_kzalloc(HANDLE, C1 * C2, ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * (E2)
    +       E2, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * E2
    +       E2, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * (E2)
    +       E2, sizeof(THING)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * E2
    +       E2, sizeof(THING)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       (E1) * E2
    +       E1, E2
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       (E1) * (E2)
    +       E1, E2
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       E1 * E2
    +       E1, E2
      , ...)
    )
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/drivers/leds/leds-lp55xx-common.c b/drivers/leds/leds-lp55xx-common.c
index 5377f22ff994..3d79a6380761 100644
--- a/drivers/leds/leds-lp55xx-common.c
+++ b/drivers/leds/leds-lp55xx-common.c
@@ -560,7 +560,7 @@ struct lp55xx_platform_data *lp55xx_of_populate_pdata(struct device *dev,
 		return ERR_PTR(-EINVAL);
 	}
 
-	cfg = devm_kzalloc(dev, sizeof(*cfg) * num_channels, GFP_KERNEL);
+	cfg = devm_kcalloc(dev, num_channels, sizeof(*cfg), GFP_KERNEL);
 	if (!cfg)
 		return ERR_PTR(-ENOMEM);
 

commit 95b2af637e283e3d549c8a6af9f182b0bd972a2e
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Thu Aug 20 12:22:57 2015 +0200

    leds: lp55xx: Remove work queue
    
    Now the core implements the work queue, remove it from the drivers,
    and switch to using brightness_set_blocking op.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: Jacek Anaszewski <j.anaszewski@samsung.com>
    Cc: Milo Kim <milo.kim@ti.com>

diff --git a/drivers/leds/leds-lp55xx-common.c b/drivers/leds/leds-lp55xx-common.c
index 59b76833f0d3..5377f22ff994 100644
--- a/drivers/leds/leds-lp55xx-common.c
+++ b/drivers/leds/leds-lp55xx-common.c
@@ -134,13 +134,14 @@ static struct attribute *lp55xx_led_attrs[] = {
 };
 ATTRIBUTE_GROUPS(lp55xx_led);
 
-static void lp55xx_set_brightness(struct led_classdev *cdev,
+static int lp55xx_set_brightness(struct led_classdev *cdev,
 			     enum led_brightness brightness)
 {
 	struct lp55xx_led *led = cdev_to_lp55xx_led(cdev);
+	struct lp55xx_device_config *cfg = led->chip->cfg;
 
 	led->brightness = (u8)brightness;
-	schedule_work(&led->brightness_work);
+	return cfg->brightness_fn(led);
 }
 
 static int lp55xx_init_led(struct lp55xx_led *led,
@@ -172,7 +173,7 @@ static int lp55xx_init_led(struct lp55xx_led *led,
 		return -EINVAL;
 	}
 
-	led->cdev.brightness_set = lp55xx_set_brightness;
+	led->cdev.brightness_set_blocking = lp55xx_set_brightness;
 	led->cdev.groups = lp55xx_led_groups;
 
 	if (pdata->led_config[chan].name) {
@@ -464,7 +465,7 @@ int lp55xx_register_leds(struct lp55xx_led *led, struct lp55xx_chip *chip)
 	int ret;
 	int i;
 
-	if (!cfg->brightness_work_fn) {
+	if (!cfg->brightness_fn) {
 		dev_err(&chip->cl->dev, "empty brightness configuration\n");
 		return -EINVAL;
 	}
@@ -481,8 +482,6 @@ int lp55xx_register_leds(struct lp55xx_led *led, struct lp55xx_chip *chip)
 		if (ret)
 			goto err_init_led;
 
-		INIT_WORK(&each->brightness_work, cfg->brightness_work_fn);
-
 		chip->num_leds++;
 		each->chip = chip;
 
@@ -507,7 +506,6 @@ void lp55xx_unregister_leds(struct lp55xx_led *led, struct lp55xx_chip *chip)
 	for (i = 0; i < chip->num_leds; i++) {
 		each = led + i;
 		led_classdev_unregister(&each->cdev);
-		flush_work(&each->brightness_work);
 	}
 }
 EXPORT_SYMBOL_GPL(lp55xx_unregister_leds);

commit ed133352047e46687afd98c299ec8ce7f6ea07bd
Author: Milo Kim <milo.kim@ti.com>
Date:   Mon Aug 24 16:09:55 2015 +0900

    leds:lp55xx: use the private data instead of updating I2C device platform data
    
    Currently, lp55xx_of_populate_pdata() allocates lp55xx_platform_data if
    it's null. And it parses the DT and copies values into the
    'client->dev.platform_data'. This may have architectural issue.
    Platform data is configurable through the DT or I2C board info inside the
    platform area. However, lp55xx common driver changes this configuration
    when it is loaded. So 'client->dev.platform_data' is not null anymore.
    Eventually, the driver initialization is not identical when it's unloaded
    and loaded again.
    The lp55xx common driver should use the private data, 'lp55xx_chip->pdata'
    instead of changing the original platform data.
    
    So, lp55xx_of_populate_pdata() is modified as follows.
    * Do not update 'dev->platform_data'. Return the pointer of new allocated
       lp55xx_platform_data. Then the driver points it to private data,
       'lp55xx_chip->pdata'.
    * Each lp55xx driver checks the pointer and handles an error case.
    
    Then, original platform data configuration will be kept regardless of
    loading or unloading the driver.
    The driver allocates the memory and copies them from the DT if it's NULL.
    After the driver is loaded again, 'client->dev.platform_data' is same as
    initial load, so the driver is initialized identically.
    
    Cc: Toshi Kikuchi <toshik@chromium.org>
    Cc: linux-leds@vger.kernel.org
    Signed-off-by: Milo Kim <milo.kim@ti.com>
    Signed-off-by: Jacek Anaszewski <j.anaszewski@samsung.com>

diff --git a/drivers/leds/leds-lp55xx-common.c b/drivers/leds/leds-lp55xx-common.c
index 96d51e9879c9..59b76833f0d3 100644
--- a/drivers/leds/leds-lp55xx-common.c
+++ b/drivers/leds/leds-lp55xx-common.c
@@ -543,7 +543,8 @@ void lp55xx_unregister_sysfs(struct lp55xx_chip *chip)
 }
 EXPORT_SYMBOL_GPL(lp55xx_unregister_sysfs);
 
-int lp55xx_of_populate_pdata(struct device *dev, struct device_node *np)
+struct lp55xx_platform_data *lp55xx_of_populate_pdata(struct device *dev,
+						      struct device_node *np)
 {
 	struct device_node *child;
 	struct lp55xx_platform_data *pdata;
@@ -553,17 +554,17 @@ int lp55xx_of_populate_pdata(struct device *dev, struct device_node *np)
 
 	pdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);
 	if (!pdata)
-		return -ENOMEM;
+		return ERR_PTR(-ENOMEM);
 
 	num_channels = of_get_child_count(np);
 	if (num_channels == 0) {
 		dev_err(dev, "no LED channels\n");
-		return -EINVAL;
+		return ERR_PTR(-EINVAL);
 	}
 
 	cfg = devm_kzalloc(dev, sizeof(*cfg) * num_channels, GFP_KERNEL);
 	if (!cfg)
-		return -ENOMEM;
+		return ERR_PTR(-ENOMEM);
 
 	pdata->led_config = &cfg[0];
 	pdata->num_channels = num_channels;
@@ -588,9 +589,7 @@ int lp55xx_of_populate_pdata(struct device *dev, struct device_node *np)
 	/* LP8501 specific */
 	of_property_read_u8(np, "pwr-sel", (u8 *)&pdata->pwr_sel);
 
-	dev->platform_data = pdata;
-
-	return 0;
+	return pdata;
 }
 EXPORT_SYMBOL_GPL(lp55xx_of_populate_pdata);
 

commit b67893206fc0a0e8af87130e67f3d8ae553fc87c
Author: Milo Kim <milo.kim@ti.com>
Date:   Sun Jun 28 17:39:14 2015 -0700

    leds:lp55xx: fix firmware loading error
    
    LP55xx driver uses not firmware file but raw data to load program through
    the firmware interface.(Documents/leds/leds-lp55xx.txt)
    
      For example, here is how to run blinking green channel pattern.
      (The second engine is seleted and MUX is mapped to 'RGB' mode)
      echo 2 > /sys/bus/i2c/devices/xxxx/select_engine
      echo "RGB" > /sys/bus/i2c/devices/xxxx/engine_mux
      echo 1 > /sys/class/firmware/lp5562/loading
      echo "4000600040FF6000" > /sys/class/firmware/lp5562/data
      echo 0 > /sys/class/firmware/lp5562/loading
      echo 1 > /sys/bus/i2c/devices/xxxx/run_engine
    
    However, '/sys/class/firmware/<device name>' is not created after the
    firmware loader user helper was introduced.
    This feature is used in the case below.
    
      As soon as the firmware download is requested by the driver, firmware
      class subsystem tries to find the binary file.
      If it gets failed, then it just falls back to user helper to load
      raw data manually. Here, you can see the device file under
      /sys/class/firmware/.
    
    To make it happen, LP55xx driver requires two configurations.
    
      1. Enable CONFIG_FW_LOADER_USER_HELPER_FALLBACK in Kconfig
      2. Set option, 'FW_OPT_USERHELPER' on requesting the firmware data.
         It means the second option should be 'false' in
         request_firmware_nowait().
         This option enables to load firmware data manually by calling
         fw_load_from_user_helper().
    
    Cc: linux-leds@vger.kernel.org
    Signed-off-by: Milo Kim <milo.kim@ti.com>
    Acked-by: Jacek Anaszewski <j.anaszewski@samsung.com>
    Signed-off-by: Bryan Wu <cooloney@gmail.com>

diff --git a/drivers/leds/leds-lp55xx-common.c b/drivers/leds/leds-lp55xx-common.c
index 77c26bc32eed..96d51e9879c9 100644
--- a/drivers/leds/leds-lp55xx-common.c
+++ b/drivers/leds/leds-lp55xx-common.c
@@ -223,7 +223,7 @@ static int lp55xx_request_firmware(struct lp55xx_chip *chip)
 	const char *name = chip->cl->name;
 	struct device *dev = &chip->cl->dev;
 
-	return request_firmware_nowait(THIS_MODULE, true, name, dev,
+	return request_firmware_nowait(THIS_MODULE, false, name, dev,
 				GFP_KERNEL, chip, lp55xx_firmware_loaded);
 }
 

commit 44a1255b03aeedb56cbe7cf27461458bd4513049
Author: Johan Hovold <johan@kernel.org>
Date:   Wed Jun 25 10:08:56 2014 -0700

    leds: lp55xx-common: fix attribute-creation race
    
    Use the attribute groups of the led-class to create the LED attributes
    during probe in order to avoid racing with userspace.
    
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Bryan Wu <cooloney@gmail.com>

diff --git a/drivers/leds/leds-lp55xx-common.c b/drivers/leds/leds-lp55xx-common.c
index 3fbfb31602c7..77c26bc32eed 100644
--- a/drivers/leds/leds-lp55xx-common.c
+++ b/drivers/leds/leds-lp55xx-common.c
@@ -127,15 +127,12 @@ static DEVICE_ATTR(led_current, S_IRUGO | S_IWUSR, lp55xx_show_current,
 		lp55xx_store_current);
 static DEVICE_ATTR(max_current, S_IRUGO , lp55xx_show_max_current, NULL);
 
-static struct attribute *lp55xx_led_attributes[] = {
+static struct attribute *lp55xx_led_attrs[] = {
 	&dev_attr_led_current.attr,
 	&dev_attr_max_current.attr,
 	NULL,
 };
-
-static struct attribute_group lp55xx_led_attr_group = {
-	.attrs = lp55xx_led_attributes
-};
+ATTRIBUTE_GROUPS(lp55xx_led);
 
 static void lp55xx_set_brightness(struct led_classdev *cdev,
 			     enum led_brightness brightness)
@@ -176,6 +173,7 @@ static int lp55xx_init_led(struct lp55xx_led *led,
 	}
 
 	led->cdev.brightness_set = lp55xx_set_brightness;
+	led->cdev.groups = lp55xx_led_groups;
 
 	if (pdata->led_config[chan].name) {
 		led->cdev.name = pdata->led_config[chan].name;
@@ -185,24 +183,12 @@ static int lp55xx_init_led(struct lp55xx_led *led,
 		led->cdev.name = name;
 	}
 
-	/*
-	 * register led class device for each channel and
-	 * add device attributes
-	 */
-
 	ret = led_classdev_register(dev, &led->cdev);
 	if (ret) {
 		dev_err(dev, "led register err: %d\n", ret);
 		return ret;
 	}
 
-	ret = sysfs_create_group(&led->cdev.dev->kobj, &lp55xx_led_attr_group);
-	if (ret) {
-		dev_err(dev, "led sysfs err: %d\n", ret);
-		led_classdev_unregister(&led->cdev);
-		return ret;
-	}
-
 	return 0;
 }
 
@@ -520,8 +506,6 @@ void lp55xx_unregister_leds(struct lp55xx_led *led, struct lp55xx_chip *chip)
 
 	for (i = 0; i < chip->num_leds; i++) {
 		each = led + i;
-		sysfs_remove_group(&each->cdev.dev->kobj,
-						&lp55xx_led_attr_group);
 		led_classdev_unregister(&each->cdev);
 		flush_work(&each->brightness_work);
 	}

commit 660216bf82e0cd65603c0935193c1f7c4aca04fb
Author: Johan Hovold <johan@kernel.org>
Date:   Wed Jun 25 10:08:55 2014 -0700

    leds: lp55xx-common: fix sysfs entry leak
    
    Make sure the sysfs group is removed when the LEDs are unregistered.
    
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Bryan Wu <cooloney@gmail.com>

diff --git a/drivers/leds/leds-lp55xx-common.c b/drivers/leds/leds-lp55xx-common.c
index 88317b4f7bf3..3fbfb31602c7 100644
--- a/drivers/leds/leds-lp55xx-common.c
+++ b/drivers/leds/leds-lp55xx-common.c
@@ -520,6 +520,8 @@ void lp55xx_unregister_leds(struct lp55xx_led *led, struct lp55xx_chip *chip)
 
 	for (i = 0; i < chip->num_leds; i++) {
 		each = led + i;
+		sysfs_remove_group(&each->cdev.dev->kobj,
+						&lp55xx_led_attr_group);
 		led_classdev_unregister(&each->cdev);
 		flush_work(&each->brightness_work);
 	}

commit 93ad8a1d59a35ef7b489a83552daee6506f47815
Author: Milo Kim <milo.kim@ti.com>
Date:   Wed Nov 20 22:14:34 2013 -0800

    leds: lp5523: Support LED MUX configuration on running a pattern
    
    There are two ways to run a pattern in LP5523.
    One is using legacy sysfs files such as 'enginex_mode','enginex_load' and
    'enginex_leds'. ('x' is from 1 to 3).
    Among them, 'enginex_leds' are used for selecting specific LED channel MUX.
    (MUX means which LEDs are used for running a pattern from LED 1 to 9.)
    
    The other way is using the firmware interface.
    In this mode, the default LED MUX strings are used.
    In other words, LED MUX is not configurable on the fly.
    
    This patch enables dynamic LED MUX configuration when the firmware is loaded.
    By accessing the sysfs file 'enginex_leds', the LED channels can be configured.
    To synchronize the operation mode, each engine mode should be set to 'LOAD'.
    
    The documentation is updated as well.
    
    Cc: Pali Roh√°r <pali.rohar@gmail.com>
    Signed-off-by: Milo Kim <milo.kim@ti.com>
    Signed-off-by: Bryan Wu <cooloney@gmail.com>

diff --git a/drivers/leds/leds-lp55xx-common.c b/drivers/leds/leds-lp55xx-common.c
index 9acc6bb7deef..88317b4f7bf3 100644
--- a/drivers/leds/leds-lp55xx-common.c
+++ b/drivers/leds/leds-lp55xx-common.c
@@ -210,6 +210,7 @@ static void lp55xx_firmware_loaded(const struct firmware *fw, void *context)
 {
 	struct lp55xx_chip *chip = context;
 	struct device *dev = &chip->cl->dev;
+	enum lp55xx_engine_index idx = chip->engine_idx;
 
 	if (!fw) {
 		dev_err(dev, "firmware request failed\n");
@@ -219,6 +220,7 @@ static void lp55xx_firmware_loaded(const struct firmware *fw, void *context)
 	/* handling firmware data is chip dependent */
 	mutex_lock(&chip->lock);
 
+	chip->engines[idx - 1].mode = LP55XX_ENGINE_LOAD;
 	chip->fw = fw;
 	if (chip->cfg->firmware_cb)
 		chip->cfg->firmware_cb(chip);

commit 30dae2f98612d7c8cd855861b9de205ebd9ef4fa
Author: Sebastian Reichel <sre@debian.org>
Date:   Tue Oct 22 11:02:56 2013 -0700

    leds: lp55xx: handle enable pin in driver
    
    This patch moves the handling of the chip's enable pin from the board
    code into the driver. It also updates all board-code files using the
    driver to incorporate this change.
    
    This is needed for device tree support of the enable pin.
    
    Signed-off-by: Sebastian Reichel <sre@debian.org>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Bryan Wu <cooloney@gmail.com>

diff --git a/drivers/leds/leds-lp55xx-common.c b/drivers/leds/leds-lp55xx-common.c
index 075acf5b9fab..9acc6bb7deef 100644
--- a/drivers/leds/leds-lp55xx-common.c
+++ b/drivers/leds/leds-lp55xx-common.c
@@ -20,6 +20,8 @@
 #include <linux/module.h>
 #include <linux/platform_data/leds-lp55xx.h>
 #include <linux/slab.h>
+#include <linux/gpio.h>
+#include <linux/of_gpio.h>
 
 #include "leds-lp55xx-common.h"
 
@@ -407,18 +409,18 @@ int lp55xx_init_device(struct lp55xx_chip *chip)
 	if (!pdata || !cfg)
 		return -EINVAL;
 
-	if (pdata->setup_resources) {
-		ret = pdata->setup_resources();
+	if (gpio_is_valid(pdata->enable_gpio)) {
+		ret = devm_gpio_request_one(dev, pdata->enable_gpio,
+					    GPIOF_DIR_OUT, "lp5523_enable");
 		if (ret < 0) {
-			dev_err(dev, "setup resoure err: %d\n", ret);
+			dev_err(dev, "could not acquire enable gpio (err=%d)\n",
+				ret);
 			goto err;
 		}
-	}
 
-	if (pdata->enable) {
-		pdata->enable(0);
+		gpio_set_value(pdata->enable_gpio, 0);
 		usleep_range(1000, 2000); /* Keep enable down at least 1ms */
-		pdata->enable(1);
+		gpio_set_value(pdata->enable_gpio, 1);
 		usleep_range(1000, 2000); /* 500us abs min. */
 	}
 
@@ -459,11 +461,8 @@ void lp55xx_deinit_device(struct lp55xx_chip *chip)
 	if (chip->clk)
 		clk_disable_unprepare(chip->clk);
 
-	if (pdata->enable)
-		pdata->enable(0);
-
-	if (pdata->release_resources)
-		pdata->release_resources();
+	if (gpio_is_valid(pdata->enable_gpio))
+		gpio_set_value(pdata->enable_gpio, 0);
 }
 EXPORT_SYMBOL_GPL(lp55xx_deinit_device);
 
@@ -596,6 +595,8 @@ int lp55xx_of_populate_pdata(struct device *dev, struct device_node *np)
 	of_property_read_string(np, "label", &pdata->label);
 	of_property_read_u8(np, "clock-mode", &pdata->clock_mode);
 
+	pdata->enable_gpio = of_get_named_gpio(np, "enable-gpio", 0);
+
 	/* LP8501 specific */
 	of_property_read_u8(np, "pwr-sel", (u8 *)&pdata->pwr_sel);
 

commit f65f0a1a9836abbfbe5c9b8fa0452e4d8eb7bf00
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Sun Sep 15 03:50:17 2013 -0700

    leds: lp55xx: enable setting default trigger
    
    This enables setting a default trigger on an LP55xx channel,
    either from platform data or device tree. This mechanism is
    identical to the mechanism for GPIO LEDs and references the
    common LEDs device tree bindings.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Tested-by: Milo Kim <milo.kim@ti.com>
    Acked-by: Milo Kim <milo.kim@ti.com>
    Signed-off-by: Bryan Wu <cooloney@gmail.com>

diff --git a/drivers/leds/leds-lp55xx-common.c b/drivers/leds/leds-lp55xx-common.c
index 351825b96f16..075acf5b9fab 100644
--- a/drivers/leds/leds-lp55xx-common.c
+++ b/drivers/leds/leds-lp55xx-common.c
@@ -165,6 +165,7 @@ static int lp55xx_init_led(struct lp55xx_led *led,
 	led->led_current = pdata->led_config[chan].led_current;
 	led->max_current = pdata->led_config[chan].max_current;
 	led->chan_nr = pdata->led_config[chan].chan_nr;
+	led->cdev.default_trigger = pdata->led_config[chan].default_trigger;
 
 	if (led->chan_nr >= max_channel) {
 		dev_err(dev, "Use channel numbers between 0 and %d\n",
@@ -586,6 +587,8 @@ int lp55xx_of_populate_pdata(struct device *dev, struct device_node *np)
 		of_property_read_string(child, "chan-name", &cfg[i].name);
 		of_property_read_u8(child, "led-cur", &cfg[i].led_current);
 		of_property_read_u8(child, "max-cur", &cfg[i].max_current);
+		cfg[i].default_trigger =
+			of_get_property(child, "linux,default-trigger", NULL);
 
 		i++;
 	}

commit 33b3a561f417ec3e1013999ce8bdb6c055abb1ce
Author: Kim, Milo <Milo.Kim@ti.com>
Date:   Tue Jul 9 02:11:37 2013 -0700

    leds: support new LP8501 device - another LP55xx common
    
    LP8501 can drive up to 9 channels like LP5523.
    LEDs can be controlled directly via the I2C and programmable engines are
    supported.
    
    LP55xx common driver
     LP8501 is one of LP55xx family device, so LP55xx common code are used.
     Chip specific data is defined in the structure, 'lp55xx_device_config'.
    
    Differences between LP8501 and LP5523
     Different register layout for LED output control and others.
     LP8501 specific feature for separate output power selection.
     LP8501 doesn't support external clock detection.
     Different programming engine data.
    
    LP8501 specific feature - output power selection
     Output channels are selected by power selection - Vout or Vdd.
     Separate power for VDD1-6 and VDD7-9 are available.
     It is configurable in the platform data.
     To support this feature, LP55xx DT structure and header are changed.
     Device tree binding is updated as well.
    
    LED pattern data
     Example pattern data is updated in the driver documentation.
    
    Signed-off-by: Milo Kim <milo.kim@ti.com>
    Signed-off-by: Bryan Wu <cooloney@gmail.com>

diff --git a/drivers/leds/leds-lp55xx-common.c b/drivers/leds/leds-lp55xx-common.c
index c2fecd4d391c..351825b96f16 100644
--- a/drivers/leds/leds-lp55xx-common.c
+++ b/drivers/leds/leds-lp55xx-common.c
@@ -593,6 +593,9 @@ int lp55xx_of_populate_pdata(struct device *dev, struct device_node *np)
 	of_property_read_string(np, "label", &pdata->label);
 	of_property_read_u8(np, "clock-mode", &pdata->clock_mode);
 
+	/* LP8501 specific */
+	of_property_read_u8(np, "pwr-sel", (u8 *)&pdata->pwr_sel);
+
 	dev->platform_data = pdata;
 
 	return 0;

commit 2dac912809490ea3a6e5c16b83b54a08f36fc3d9
Author: Kim, Milo <Milo.Kim@ti.com>
Date:   Tue May 7 00:14:48 2013 -0700

    leds: lp55xx: support dynamic channel settings in the device tree structure
    
    Currently, the LP55xx DT structure supports max 3 channels.
    However, LP5523 has max 9 channels and LP5562 has 4 channels.
    To enhance this constraint, the DT structure has been changed.
    
     (a) Use the child node for various channel settings instead of fixed array
     (b) Remove 'num_channel' property.
         This value can be retrieved by counting the children node.
     (c) 'chan-name' property supported
     (d) Documentation updates for LP5521 and LP5523
    
    (cooloney@gmail.com: fix a coding style issue in leds-lp55xx.txt)
    
    Cc: Gabriel Fernandez <gabriel.fernandez@stericsson.com>
    Signed-off-by: Milo(Woogyom) Kim <milo.kim@ti.com>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Bryan Wu <cooloney@gmail.com>

diff --git a/drivers/leds/leds-lp55xx-common.c b/drivers/leds/leds-lp55xx-common.c
index a0d2bd2fa23c..c2fecd4d391c 100644
--- a/drivers/leds/leds-lp55xx-common.c
+++ b/drivers/leds/leds-lp55xx-common.c
@@ -557,51 +557,42 @@ EXPORT_SYMBOL_GPL(lp55xx_unregister_sysfs);
 
 int lp55xx_of_populate_pdata(struct device *dev, struct device_node *np)
 {
+	struct device_node *child;
 	struct lp55xx_platform_data *pdata;
-	u8 led_cur[3];
-	u8 max_cur[3];
-	u8 clock_mode;
-	u8 num_channel;
-	const char *label;
-	struct lp55xx_led_config *led_config;
-	int ret;
-	int i;
+	struct lp55xx_led_config *cfg;
+	int num_channels;
+	int i = 0;
 
 	pdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);
 	if (!pdata)
 		return -ENOMEM;
 
-	ret = of_property_read_u8(np, "num-channel", &num_channel);
-	if (ret < 0)
-		return ret;
-	ret = of_property_read_u8_array(np, "led-cur", led_cur, num_channel);
-	if (ret < 0)
-		return ret;
-	ret = of_property_read_u8_array(np, "max-cur", max_cur, num_channel);
-	if (ret < 0)
-		return ret;
-	ret = of_property_read_string(np, "label", &label);
-	if (ret < 0)
-		return ret;
-	ret = of_property_read_u8_array(np, "clock-mode", &clock_mode, 1);
-	if (ret < 0)
-		return ret;
+	num_channels = of_get_child_count(np);
+	if (num_channels == 0) {
+		dev_err(dev, "no LED channels\n");
+		return -EINVAL;
+	}
 
-	led_config = devm_kzalloc(dev, sizeof(*led_config) * num_channel,
-				  GFP_KERNEL);
-	if (!led_config)
+	cfg = devm_kzalloc(dev, sizeof(*cfg) * num_channels, GFP_KERNEL);
+	if (!cfg)
 		return -ENOMEM;
 
-	for (i = 0; i < num_channel; i++) {
-		led_config[i].chan_nr = i;
-		led_config[i].led_current = led_cur[i];
-		led_config[i].max_current = max_cur[i];
+	pdata->led_config = &cfg[0];
+	pdata->num_channels = num_channels;
+
+	for_each_child_of_node(np, child) {
+		cfg[i].chan_nr = i;
+
+		of_property_read_string(child, "chan-name", &cfg[i].name);
+		of_property_read_u8(child, "led-cur", &cfg[i].led_current);
+		of_property_read_u8(child, "max-cur", &cfg[i].max_current);
+
+		i++;
 	}
-	pdata->label = kzalloc(sizeof(char) * 32, GFP_KERNEL);
-	strcpy((char *)pdata->label, (char *) label);
-	pdata->led_config = &led_config[0];
-	pdata->num_channels = num_channel;
-	pdata->clock_mode = clock_mode;
+
+	of_property_read_string(np, "label", &pdata->label);
+	of_property_read_u8(np, "clock-mode", &pdata->clock_mode);
+
 	dev->platform_data = pdata;
 
 	return 0;

commit 7542a04b1515f0f878b267beb233c4ef067243fb
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Apr 23 04:52:59 2013 -0700

    leds: lp55xx: add support for Device Tree bindings
    
    This patch allows the lp5521 driver to be successfully probed and
    initialised when Device Tree support is enabled.
    
    Based on a patch by Gabriel Fernandez, rewritten in accordance
    with review feedback.
    
    Cc: Gabriel Fernandez <gabriel.fernandez@stericsson.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Milo Kim <milo.kim@ti.com>
    Signed-off-by: Bryan Wu <cooloney@gmail.com>

diff --git a/drivers/leds/leds-lp55xx-common.c b/drivers/leds/leds-lp55xx-common.c
index ba34199dc3d9..a0d2bd2fa23c 100644
--- a/drivers/leds/leds-lp55xx-common.c
+++ b/drivers/leds/leds-lp55xx-common.c
@@ -19,6 +19,7 @@
 #include <linux/leds.h>
 #include <linux/module.h>
 #include <linux/platform_data/leds-lp55xx.h>
+#include <linux/slab.h>
 
 #include "leds-lp55xx-common.h"
 
@@ -554,6 +555,59 @@ void lp55xx_unregister_sysfs(struct lp55xx_chip *chip)
 }
 EXPORT_SYMBOL_GPL(lp55xx_unregister_sysfs);
 
+int lp55xx_of_populate_pdata(struct device *dev, struct device_node *np)
+{
+	struct lp55xx_platform_data *pdata;
+	u8 led_cur[3];
+	u8 max_cur[3];
+	u8 clock_mode;
+	u8 num_channel;
+	const char *label;
+	struct lp55xx_led_config *led_config;
+	int ret;
+	int i;
+
+	pdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);
+	if (!pdata)
+		return -ENOMEM;
+
+	ret = of_property_read_u8(np, "num-channel", &num_channel);
+	if (ret < 0)
+		return ret;
+	ret = of_property_read_u8_array(np, "led-cur", led_cur, num_channel);
+	if (ret < 0)
+		return ret;
+	ret = of_property_read_u8_array(np, "max-cur", max_cur, num_channel);
+	if (ret < 0)
+		return ret;
+	ret = of_property_read_string(np, "label", &label);
+	if (ret < 0)
+		return ret;
+	ret = of_property_read_u8_array(np, "clock-mode", &clock_mode, 1);
+	if (ret < 0)
+		return ret;
+
+	led_config = devm_kzalloc(dev, sizeof(*led_config) * num_channel,
+				  GFP_KERNEL);
+	if (!led_config)
+		return -ENOMEM;
+
+	for (i = 0; i < num_channel; i++) {
+		led_config[i].chan_nr = i;
+		led_config[i].led_current = led_cur[i];
+		led_config[i].max_current = max_cur[i];
+	}
+	pdata->label = kzalloc(sizeof(char) * 32, GFP_KERNEL);
+	strcpy((char *)pdata->label, (char *) label);
+	pdata->led_config = &led_config[0];
+	pdata->num_channels = num_channel;
+	pdata->clock_mode = clock_mode;
+	dev->platform_data = pdata;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(lp55xx_of_populate_pdata);
+
 MODULE_AUTHOR("Milo Kim <milo.kim@ti.com>");
 MODULE_DESCRIPTION("LP55xx Common Driver");
 MODULE_LICENSE("GPL");

commit 53b4192266436e75dea96c8ef495eadd6f3df981
Author: Kim, Milo <Milo.Kim@ti.com>
Date:   Wed Mar 20 17:37:00 2013 -0700

    leds: lp55xx: use common clock framework when external clock is used
    
    Program execution is timed with 32768Hz clock in the LP55xx family devices.
    To run LED functionalities, LP55xx devices provide two options.
    One is using internal clock. The other is using external clock.
    This patch enables external clock detection automatically.
    If external clock is not detected, then the internal clock will be used in the
    LP55xx driver.
    
    Valid clock rate is 32768Hz in LP55xx devices.
    
    This new API is used in each LP55xx driver like LP5521 and LP5562.
    
    Signed-off-by: Milo(Woogyom) Kim <milo.kim@ti.com>
    Signed-off-by: Bryan Wu <cooloney@gmail.com>

diff --git a/drivers/leds/leds-lp55xx-common.c b/drivers/leds/leds-lp55xx-common.c
index 715a6027316f..ba34199dc3d9 100644
--- a/drivers/leds/leds-lp55xx-common.c
+++ b/drivers/leds/leds-lp55xx-common.c
@@ -12,6 +12,7 @@
  * Derived from leds-lp5521.c, leds-lp5523.c
  */
 
+#include <linux/clk.h>
 #include <linux/delay.h>
 #include <linux/firmware.h>
 #include <linux/i2c.h>
@@ -21,6 +22,9 @@
 
 #include "leds-lp55xx-common.h"
 
+/* External clock rate */
+#define LP55XX_CLK_32K			32768
+
 static struct lp55xx_led *cdev_to_lp55xx_led(struct led_classdev *cdev)
 {
 	return container_of(cdev, struct lp55xx_led, cdev);
@@ -357,6 +361,35 @@ int lp55xx_update_bits(struct lp55xx_chip *chip, u8 reg, u8 mask, u8 val)
 }
 EXPORT_SYMBOL_GPL(lp55xx_update_bits);
 
+bool lp55xx_is_extclk_used(struct lp55xx_chip *chip)
+{
+	struct clk *clk;
+	int err;
+
+	clk = devm_clk_get(&chip->cl->dev, "32k_clk");
+	if (IS_ERR(clk))
+		goto use_internal_clk;
+
+	err = clk_prepare_enable(clk);
+	if (err)
+		goto use_internal_clk;
+
+	if (clk_get_rate(clk) != LP55XX_CLK_32K) {
+		clk_disable_unprepare(clk);
+		goto use_internal_clk;
+	}
+
+	dev_info(&chip->cl->dev, "%dHz external clock used\n",	LP55XX_CLK_32K);
+
+	chip->clk = clk;
+	return true;
+
+use_internal_clk:
+	dev_info(&chip->cl->dev, "internal clock used\n");
+	return false;
+}
+EXPORT_SYMBOL_GPL(lp55xx_is_extclk_used);
+
 int lp55xx_init_device(struct lp55xx_chip *chip)
 {
 	struct lp55xx_platform_data *pdata;
@@ -421,6 +454,9 @@ void lp55xx_deinit_device(struct lp55xx_chip *chip)
 {
 	struct lp55xx_platform_data *pdata = chip->pdata;
 
+	if (chip->clk)
+		clk_disable_unprepare(chip->clk);
+
 	if (pdata->enable)
 		pdata->enable(0);
 

commit 24d321284745cbc593fba8115585329d48703704
Author: Kim, Milo <Milo.Kim@ti.com>
Date:   Thu Mar 14 17:19:36 2013 -0700

    leds: lp55xx: fix the sysfs read operation
    
    According to a sysfs documentation(Documentation/filesystem/sysfs.txt),
    scnprintf() should be used in a read operation method.
    It guarantees safe buffer size(PAGE_SIZE) which is allocated by the sysfs.
    
    Signed-off-by: Milo(Woogyom) Kim <milo.kim@ti.com>
    Signed-off-by: Bryan Wu <cooloney@gmail.com>

diff --git a/drivers/leds/leds-lp55xx-common.c b/drivers/leds/leds-lp55xx-common.c
index 8a388a4afed7..715a6027316f 100644
--- a/drivers/leds/leds-lp55xx-common.c
+++ b/drivers/leds/leds-lp55xx-common.c
@@ -80,7 +80,7 @@ static ssize_t lp55xx_show_current(struct device *dev,
 {
 	struct lp55xx_led *led = dev_to_lp55xx_led(dev);
 
-	return sprintf(buf, "%d\n", led->led_current);
+	return scnprintf(buf, PAGE_SIZE, "%d\n", led->led_current);
 }
 
 static ssize_t lp55xx_store_current(struct device *dev,
@@ -113,7 +113,7 @@ static ssize_t lp55xx_show_max_current(struct device *dev,
 {
 	struct lp55xx_led *led = dev_to_lp55xx_led(dev);
 
-	return sprintf(buf, "%d\n", led->max_current);
+	return scnprintf(buf, PAGE_SIZE, "%d\n", led->max_current);
 }
 
 static DEVICE_ATTR(led_current, S_IRUGO | S_IWUSR, lp55xx_show_current,

commit ff45262a85dbf1bc74463c5dcea1d71a406d4d8e
Author: Kim, Milo <Milo.Kim@ti.com>
Date:   Mon Feb 18 21:10:14 2013 -0800

    leds: add new LP5562 LED driver
    
    LP5562 can drive up to 4 channels, RGB and White.
    LEDs can be controlled directly via the led class control interface.
    
     LP55xx common driver
      LP5562 is one of LP55xx family device, so LP55xx common code are used.
      On the other hand, chip specific configuration is defined in the structure
      'lp55xx_device_config'
    
     LED pattern data
      LP5562 has also internal program memory which is used for running various LED
      patterns. LP5562 driver supports the firmware interface and the predefined
      pattern data as well.
    
     LP5562 device attributes: 'led_pattern' and 'engine_mux'
      A 'led_pattern' is an index code which runs the predefined pattern data.
      And 'engine_mux' is updated with the firmware interface is activated.
      Detailed description has been updated in the documentation files,
      'leds-lp55xx.txt' and 'leds-lp5562.txt'.
    
     Changes on the header file
      LP5562 configurable definitions are added.
      Pattern RGB data is fixed as constant value.
      (No side effect on other devices, LP5521 or LP5523.)
    
    (cooloney@gmail.com: remove redundant mutex_unlock(). Reported by Dan
    Carpenter <dan.carpenter@oracle.com>)
    
    Signed-off-by: Milo(Woogyom) Kim <milo.kim@ti.com>
    Signed-off-by: Bryan Wu <cooloney@gmail.com>

diff --git a/drivers/leds/leds-lp55xx-common.c b/drivers/leds/leds-lp55xx-common.c
index d9eb84157423..8a388a4afed7 100644
--- a/drivers/leds/leds-lp55xx-common.c
+++ b/drivers/leds/leds-lp55xx-common.c
@@ -1,5 +1,5 @@
 /*
- * LP5521/LP5523/LP55231 Common Driver
+ * LP5521/LP5523/LP55231/LP5562 Common Driver
  *
  * Copyright 2012 Texas Instruments
  *

commit 109b833071b44a4a6f5dc56385025543ed15a500
Author: Milo(Woogyom) Kim <milo.kim@ti.com>
Date:   Tue Feb 5 19:28:44 2013 +0900

    leds-lp55xx: fix problem on removing LED attributes
    
     LP55XX common device attributes, 'led_current' and 'max_current' are created
     while loading the driver.
     Those are LED device attributes which are removed automatically on releasing
     led class devices - led_classdev_unregister().
     Therefore, this duplicate code should be removed.
    
    Signed-off-by: Milo(Woogyom) Kim <milo.kim@ti.com>
    Signed-off-by: Bryan Wu <cooloney@gmail.com>

diff --git a/drivers/leds/leds-lp55xx-common.c b/drivers/leds/leds-lp55xx-common.c
index 782ab84fe65f..d9eb84157423 100644
--- a/drivers/leds/leds-lp55xx-common.c
+++ b/drivers/leds/leds-lp55xx-common.c
@@ -478,12 +478,9 @@ void lp55xx_unregister_leds(struct lp55xx_led *led, struct lp55xx_chip *chip)
 {
 	int i;
 	struct lp55xx_led *each;
-	struct kobject *kobj;
 
 	for (i = 0; i < chip->num_leds; i++) {
 		each = led + i;
-		kobj = &led->cdev.dev->kobj;
-		sysfs_remove_group(kobj, &lp55xx_led_attr_group);
 		led_classdev_unregister(&each->cdev);
 		flush_work(&each->brightness_work);
 	}

commit ba6fa84651ff9a609e0ceb8265e3335ab6ed656d
Author: Milo(Woogyom) Kim <milo.kim@ti.com>
Date:   Tue Feb 5 19:23:04 2013 +0900

    leds-lp55xx: add new function for removing device attribtues
    
     lp55xx_unregister_sysfs() is used for removing lp55xx device attributes.
     Chip specific and engine attributes are removed on unloading the driver.
    
    Signed-off-by: Milo(Woogyom) Kim <milo.kim@ti.com>
    Signed-off-by: Bryan Wu <cooloney@gmail.com>

diff --git a/drivers/leds/leds-lp55xx-common.c b/drivers/leds/leds-lp55xx-common.c
index 9638ad4dc635..782ab84fe65f 100644
--- a/drivers/leds/leds-lp55xx-common.c
+++ b/drivers/leds/leds-lp55xx-common.c
@@ -509,6 +509,18 @@ int lp55xx_register_sysfs(struct lp55xx_chip *chip)
 }
 EXPORT_SYMBOL_GPL(lp55xx_register_sysfs);
 
+void lp55xx_unregister_sysfs(struct lp55xx_chip *chip)
+{
+	struct device *dev = &chip->cl->dev;
+	struct lp55xx_device_config *cfg = chip->cfg;
+
+	if (cfg->dev_attr_group)
+		sysfs_remove_group(&dev->kobj, cfg->dev_attr_group);
+
+	sysfs_remove_group(&dev->kobj, &lp55xx_engine_attr_group);
+}
+EXPORT_SYMBOL_GPL(lp55xx_unregister_sysfs);
+
 MODULE_AUTHOR("Milo Kim <milo.kim@ti.com>");
 MODULE_DESCRIPTION("LP55xx Common Driver");
 MODULE_LICENSE("GPL");

commit 240085e255cd2818aff2ccde3066b7db1f29076a
Author: Milo(Woogyom) Kim <milo.kim@ti.com>
Date:   Tue Feb 5 19:20:01 2013 +0900

    leds-lp55xx: support device specific attributes
    
     To support device specific attributes, new common driver function is added.
     Eventually those are created on registering the sysfs with common dev attrs.
     Furthermore, this patch makes adding device attributes simple in each driver.
    
    Signed-off-by: Milo(Woogyom) Kim <milo.kim@ti.com>
    Signed-off-by: Bryan Wu <cooloney@gmail.com>

diff --git a/drivers/leds/leds-lp55xx-common.c b/drivers/leds/leds-lp55xx-common.c
index 578902ab604f..9638ad4dc635 100644
--- a/drivers/leds/leds-lp55xx-common.c
+++ b/drivers/leds/leds-lp55xx-common.c
@@ -493,8 +493,19 @@ EXPORT_SYMBOL_GPL(lp55xx_unregister_leds);
 int lp55xx_register_sysfs(struct lp55xx_chip *chip)
 {
 	struct device *dev = &chip->cl->dev;
+	struct lp55xx_device_config *cfg = chip->cfg;
+	int ret;
+
+	if (!cfg->run_engine || !cfg->firmware_cb)
+		goto dev_specific_attrs;
+
+	ret = sysfs_create_group(&dev->kobj, &lp55xx_engine_attr_group);
+	if (ret)
+		return ret;
 
-	return sysfs_create_group(&dev->kobj, &lp55xx_engine_attr_group);
+dev_specific_attrs:
+	return cfg->dev_attr_group ?
+		sysfs_create_group(&dev->kobj, cfg->dev_attr_group) : 0;
 }
 EXPORT_SYMBOL_GPL(lp55xx_register_sysfs);
 

commit 10c06d178df11b0b2b746321a80ea14241997127
Author: Milo(Woogyom) Kim <milo.kim@ti.com>
Date:   Tue Feb 5 19:17:20 2013 +0900

    leds-lp55xx: support firmware interface
    
     This patch provides additional device attributes which enable
     loading the firmware. ('select_engine' and 'run_engine')
     To run a LED pattern, two parts of driver should be enabled.
    
     Common features : lp55xx-common
     ===============================
     Firmware interface for loading LED patterns
    
     Chip specific features : leds-lp5521, leds-lp5523
     =================================================
     Register addresses for loading firmware data
     Register addresses for running selected engine
    
     Pattern programming sequence
     ============================
     LP55xx chips have three program engines.
     To load and run a LED pattern, the programming sequence is as follows.
     (1) Select an engine number (1/2/3)
     (2) Set engine mode to load
     (3) Write pattern data into selected area
     (4) Set engine mode to run
    
     This sequence is almost same as the firmware interface.
     (1) Select an engine number               : 'select_engine' dev attribute
     (2) Mode change to load                   : 'loading' of firmware class
     (3) Write pattern data into selected area : 'data' of firmware class
     (4) Mode change to run                    : 'run_engine' dev attribute
    
     (1) and (4) are device specific features which provide callback functions
     (2) and (3) are common features.
    
     For example,
     echo 1 or 2 or 3 > /sys/bus/i2c/devices/xxxx/select_engine
     echo 1 > /sys/class/firmware/lp5521/loading
     echo "4000600040FF6000" > /sys/class/firmware/lp5521/data
     echo 0 > /sys/class/firmware/lp5521/loading
     echo 1 > /sys/bus/i2c/devices/xxxx/run_engine
    
     As soon as 'loading' is set to 0, registered callback is called.
     Inside the callback, the selected engine is loaded and memory is updated.
     To run programmed pattern, 'run_engine' attribute should be enabled.
    
     Device specific data structure
     ==============================
     o Firmware callback
       load selected engine and update program memory
     o Run engine
       change the engine mode
     o 'engine_idx' and firmware data, 'fw'
       Those are used in the driver internally with callback functions
    
    Signed-off-by: Milo(Woogyom) Kim <milo.kim@ti.com>
    Signed-off-by: Bryan Wu <cooloney@gmail.com>

diff --git a/drivers/leds/leds-lp55xx-common.c b/drivers/leds/leds-lp55xx-common.c
index 98407ca45e4f..578902ab604f 100644
--- a/drivers/leds/leds-lp55xx-common.c
+++ b/drivers/leds/leds-lp55xx-common.c
@@ -13,6 +13,7 @@
  */
 
 #include <linux/delay.h>
+#include <linux/firmware.h>
 #include <linux/i2c.h>
 #include <linux/leds.h>
 #include <linux/module.h>
@@ -197,7 +198,123 @@ static int lp55xx_init_led(struct lp55xx_led *led,
 	return 0;
 }
 
+static void lp55xx_firmware_loaded(const struct firmware *fw, void *context)
+{
+	struct lp55xx_chip *chip = context;
+	struct device *dev = &chip->cl->dev;
+
+	if (!fw) {
+		dev_err(dev, "firmware request failed\n");
+		goto out;
+	}
+
+	/* handling firmware data is chip dependent */
+	mutex_lock(&chip->lock);
+
+	chip->fw = fw;
+	if (chip->cfg->firmware_cb)
+		chip->cfg->firmware_cb(chip);
+
+	mutex_unlock(&chip->lock);
+
+out:
+	/* firmware should be released for other channel use */
+	release_firmware(chip->fw);
+}
+
+static int lp55xx_request_firmware(struct lp55xx_chip *chip)
+{
+	const char *name = chip->cl->name;
+	struct device *dev = &chip->cl->dev;
+
+	return request_firmware_nowait(THIS_MODULE, true, name, dev,
+				GFP_KERNEL, chip, lp55xx_firmware_loaded);
+}
+
+static ssize_t lp55xx_show_engine_select(struct device *dev,
+			    struct device_attribute *attr,
+			    char *buf)
+{
+	struct lp55xx_led *led = i2c_get_clientdata(to_i2c_client(dev));
+	struct lp55xx_chip *chip = led->chip;
+
+	return sprintf(buf, "%d\n", chip->engine_idx);
+}
+
+static ssize_t lp55xx_store_engine_select(struct device *dev,
+			     struct device_attribute *attr,
+			     const char *buf, size_t len)
+{
+	struct lp55xx_led *led = i2c_get_clientdata(to_i2c_client(dev));
+	struct lp55xx_chip *chip = led->chip;
+	unsigned long val;
+	int ret;
+
+	if (kstrtoul(buf, 0, &val))
+		return -EINVAL;
+
+	/* select the engine to be run */
+
+	switch (val) {
+	case LP55XX_ENGINE_1:
+	case LP55XX_ENGINE_2:
+	case LP55XX_ENGINE_3:
+		mutex_lock(&chip->lock);
+		chip->engine_idx = val;
+		ret = lp55xx_request_firmware(chip);
+		mutex_unlock(&chip->lock);
+		break;
+	default:
+		dev_err(dev, "%lu: invalid engine index. (1, 2, 3)\n", val);
+		return -EINVAL;
+	}
+
+	if (ret) {
+		dev_err(dev, "request firmware err: %d\n", ret);
+		return ret;
+	}
+
+	return len;
+}
+
+static inline void lp55xx_run_engine(struct lp55xx_chip *chip, bool start)
+{
+	if (chip->cfg->run_engine)
+		chip->cfg->run_engine(chip, start);
+}
+
+static ssize_t lp55xx_store_engine_run(struct device *dev,
+			     struct device_attribute *attr,
+			     const char *buf, size_t len)
+{
+	struct lp55xx_led *led = i2c_get_clientdata(to_i2c_client(dev));
+	struct lp55xx_chip *chip = led->chip;
+	unsigned long val;
+
+	if (kstrtoul(buf, 0, &val))
+		return -EINVAL;
+
+	/* run or stop the selected engine */
+
+	if (val <= 0) {
+		lp55xx_run_engine(chip, false);
+		return len;
+	}
+
+	mutex_lock(&chip->lock);
+	lp55xx_run_engine(chip, true);
+	mutex_unlock(&chip->lock);
+
+	return len;
+}
+
+static DEVICE_ATTR(select_engine, S_IRUGO | S_IWUSR,
+		   lp55xx_show_engine_select, lp55xx_store_engine_select);
+static DEVICE_ATTR(run_engine, S_IWUSR, NULL, lp55xx_store_engine_run);
+
 static struct attribute *lp55xx_engine_attributes[] = {
+	&dev_attr_select_engine.attr,
+	&dev_attr_run_engine.attr,
 	NULL,
 };
 

commit b3b6f8119d752c969c6394314dc7ab80e6611111
Author: Milo(Woogyom) Kim <milo.kim@ti.com>
Date:   Tue Feb 5 19:15:27 2013 +0900

    leds-lp55xx: add new lp55xx_register_sysfs() for the firmware interface
    
     LP55xx family chips have internal program memory which run various patterns.
     Using this memory, LEDs continue on blinking/dimming without continuous I2C
     commands. That means the I2C HOST can be entered into sleep once the memory
     is updated.
    
     An application can get hex data from a file and write them into
     the program memory through the I2C. This is general firwmare interface.
    
     This patch is the initial step for adding the firmware interface.
    
    Signed-off-by: Milo(Woogyom) Kim <milo.kim@ti.com>
    Signed-off-by: Bryan Wu <cooloney@gmail.com>

diff --git a/drivers/leds/leds-lp55xx-common.c b/drivers/leds/leds-lp55xx-common.c
index cd19027895e5..98407ca45e4f 100644
--- a/drivers/leds/leds-lp55xx-common.c
+++ b/drivers/leds/leds-lp55xx-common.c
@@ -197,6 +197,14 @@ static int lp55xx_init_led(struct lp55xx_led *led,
 	return 0;
 }
 
+static struct attribute *lp55xx_engine_attributes[] = {
+	NULL,
+};
+
+static const struct attribute_group lp55xx_engine_attr_group = {
+	.attrs = lp55xx_engine_attributes,
+};
+
 int lp55xx_write(struct lp55xx_chip *chip, u8 reg, u8 val)
 {
 	return i2c_smbus_write_byte_data(chip->cl, reg, val);
@@ -365,6 +373,14 @@ void lp55xx_unregister_leds(struct lp55xx_led *led, struct lp55xx_chip *chip)
 }
 EXPORT_SYMBOL_GPL(lp55xx_unregister_leds);
 
+int lp55xx_register_sysfs(struct lp55xx_chip *chip)
+{
+	struct device *dev = &chip->cl->dev;
+
+	return sysfs_create_group(&dev->kobj, &lp55xx_engine_attr_group);
+}
+EXPORT_SYMBOL_GPL(lp55xx_register_sysfs);
+
 MODULE_AUTHOR("Milo Kim <milo.kim@ti.com>");
 MODULE_DESCRIPTION("LP55xx Common Driver");
 MODULE_LICENSE("GPL");

commit d9067d28461cb2e817cacb84c727959cbd57d247
Author: Milo(Woogyom) Kim <milo.kim@ti.com>
Date:   Tue Feb 5 19:12:47 2013 +0900

    leds-lp55xx: fix error condition in lp55xx_register_leds()
    
     Use lp55xx_unregister_leds() rather than duplicate code.
    
    Signed-off-by: Milo(Woogyom) Kim <milo.kim@ti.com>
    Signed-off-by: Bryan Wu <cooloney@gmail.com>

diff --git a/drivers/leds/leds-lp55xx-common.c b/drivers/leds/leds-lp55xx-common.c
index dcd64f5285e8..cd19027895e5 100644
--- a/drivers/leds/leds-lp55xx-common.c
+++ b/drivers/leds/leds-lp55xx-common.c
@@ -344,11 +344,7 @@ int lp55xx_register_leds(struct lp55xx_led *led, struct lp55xx_chip *chip)
 	return 0;
 
 err_init_led:
-	for (i = 0; i < chip->num_leds; i++) {
-		each = led + i;
-		led_classdev_unregister(&each->cdev);
-		flush_work(&each->brightness_work);
-	}
+	lp55xx_unregister_leds(led, chip);
 	return ret;
 }
 EXPORT_SYMBOL_GPL(lp55xx_register_leds);

commit c3a68ebfcd22abc186f2328149732c801449b297
Author: Milo(Woogyom) Kim <milo.kim@ti.com>
Date:   Tue Feb 5 19:11:18 2013 +0900

    leds-lp55xx: use lp55xx_unregister_leds()
    
     To unregister led class devices and sysfs attributes,
     LP5521 and LP5523 have each driver function.
     This patch makes both drivers simple using common driver function,
     lp55xx_unregister_leds().
    
     And some unused variables are removed.
    
    Signed-off-by: Milo(Woogyom) Kim <milo.kim@ti.com>
    Signed-off-by: Bryan Wu <cooloney@gmail.com>

diff --git a/drivers/leds/leds-lp55xx-common.c b/drivers/leds/leds-lp55xx-common.c
index 6b3d03709f5f..dcd64f5285e8 100644
--- a/drivers/leds/leds-lp55xx-common.c
+++ b/drivers/leds/leds-lp55xx-common.c
@@ -353,6 +353,22 @@ int lp55xx_register_leds(struct lp55xx_led *led, struct lp55xx_chip *chip)
 }
 EXPORT_SYMBOL_GPL(lp55xx_register_leds);
 
+void lp55xx_unregister_leds(struct lp55xx_led *led, struct lp55xx_chip *chip)
+{
+	int i;
+	struct lp55xx_led *each;
+	struct kobject *kobj;
+
+	for (i = 0; i < chip->num_leds; i++) {
+		each = led + i;
+		kobj = &led->cdev.dev->kobj;
+		sysfs_remove_group(kobj, &lp55xx_led_attr_group);
+		led_classdev_unregister(&each->cdev);
+		flush_work(&each->brightness_work);
+	}
+}
+EXPORT_SYMBOL_GPL(lp55xx_unregister_leds);
+
 MODULE_AUTHOR("Milo Kim <milo.kim@ti.com>");
 MODULE_DESCRIPTION("LP55xx Common Driver");
 MODULE_LICENSE("GPL");

commit a96bfa135ddc8045166fc6311ce4d21bfcb8d13d
Author: Milo(Woogyom) Kim <milo.kim@ti.com>
Date:   Tue Feb 5 19:09:32 2013 +0900

    leds-lp55xx: provide common LED current setting
    
     LED current is configurable via the sysfs.
     Max current is a read-only attribute.
     These attributes code can be shared in lp55xx common driver.
    
     Device attributes: 'led_current' and 'max_current'
     move to lp55xx common driver
    
     Replaced functions:
     show_max_current()  => lp55xx_show_max_current()
     show_current()      => lp55xx_show_current()
     store_current()     => lp55xx_store_current()
    
     LED setting function: set_led_current()
     Current registers are device specific, so configurable function is added
     in each driver.
    
    Signed-off-by: Milo(Woogyom) Kim <milo.kim@ti.com>
    Signed-off-by: Bryan Wu <cooloney@gmail.com>

diff --git a/drivers/leds/leds-lp55xx-common.c b/drivers/leds/leds-lp55xx-common.c
index 8244d78447f4..6b3d03709f5f 100644
--- a/drivers/leds/leds-lp55xx-common.c
+++ b/drivers/leds/leds-lp55xx-common.c
@@ -25,6 +25,11 @@ static struct lp55xx_led *cdev_to_lp55xx_led(struct led_classdev *cdev)
 	return container_of(cdev, struct lp55xx_led, cdev);
 }
 
+static struct lp55xx_led *dev_to_lp55xx_led(struct device *dev)
+{
+	return cdev_to_lp55xx_led(dev_get_drvdata(dev));
+}
+
 static void lp55xx_reset_device(struct lp55xx_chip *chip)
 {
 	struct lp55xx_device_config *cfg = chip->cfg;
@@ -68,7 +73,55 @@ static int lp55xx_post_init_device(struct lp55xx_chip *chip)
 	return cfg->post_init_device(chip);
 }
 
+static ssize_t lp55xx_show_current(struct device *dev,
+			    struct device_attribute *attr,
+			    char *buf)
+{
+	struct lp55xx_led *led = dev_to_lp55xx_led(dev);
+
+	return sprintf(buf, "%d\n", led->led_current);
+}
+
+static ssize_t lp55xx_store_current(struct device *dev,
+			     struct device_attribute *attr,
+			     const char *buf, size_t len)
+{
+	struct lp55xx_led *led = dev_to_lp55xx_led(dev);
+	struct lp55xx_chip *chip = led->chip;
+	unsigned long curr;
+
+	if (kstrtoul(buf, 0, &curr))
+		return -EINVAL;
+
+	if (curr > led->max_current)
+		return -EINVAL;
+
+	if (!chip->cfg->set_led_current)
+		return len;
+
+	mutex_lock(&chip->lock);
+	chip->cfg->set_led_current(led, (u8)curr);
+	mutex_unlock(&chip->lock);
+
+	return len;
+}
+
+static ssize_t lp55xx_show_max_current(struct device *dev,
+			    struct device_attribute *attr,
+			    char *buf)
+{
+	struct lp55xx_led *led = dev_to_lp55xx_led(dev);
+
+	return sprintf(buf, "%d\n", led->max_current);
+}
+
+static DEVICE_ATTR(led_current, S_IRUGO | S_IWUSR, lp55xx_show_current,
+		lp55xx_store_current);
+static DEVICE_ATTR(max_current, S_IRUGO , lp55xx_show_max_current, NULL);
+
 static struct attribute *lp55xx_led_attributes[] = {
+	&dev_attr_led_current.attr,
+	&dev_attr_max_current.attr,
 	NULL,
 };
 

commit a6e4679a09a0a2bcfa63074272fc9fb2a40f11ad
Author: Milo(Woogyom) Kim <milo.kim@ti.com>
Date:   Tue Feb 5 19:08:40 2013 +0900

    leds-lp55xx: use lp55xx_set_brightness()
    
     lp5521_set_brightness() and lp5523_set_brightness() are replaced with
     common function, lp55xx_set_brightness().
     This function is invoked when the brightness of each LED channel is updated.
     LP5521 and LP5523 have different register address for the brightness control,
     so this work is done by chip specific brightness_work_fn().
    
     lp5521/5523_led_brightness_work():
     use lp55xx_led and lp55xx_chip data structure.
     use lp55xx write function.
    
    Signed-off-by: Milo(Woogyom) Kim <milo.kim@ti.com>
    Signed-off-by: Bryan Wu <cooloney@gmail.com>

diff --git a/drivers/leds/leds-lp55xx-common.c b/drivers/leds/leds-lp55xx-common.c
index 75ab1c3c03ed..8244d78447f4 100644
--- a/drivers/leds/leds-lp55xx-common.c
+++ b/drivers/leds/leds-lp55xx-common.c
@@ -20,6 +20,11 @@
 
 #include "leds-lp55xx-common.h"
 
+static struct lp55xx_led *cdev_to_lp55xx_led(struct led_classdev *cdev)
+{
+	return container_of(cdev, struct lp55xx_led, cdev);
+}
+
 static void lp55xx_reset_device(struct lp55xx_chip *chip)
 {
 	struct lp55xx_device_config *cfg = chip->cfg;
@@ -74,6 +79,10 @@ static struct attribute_group lp55xx_led_attr_group = {
 static void lp55xx_set_brightness(struct led_classdev *cdev,
 			     enum led_brightness brightness)
 {
+	struct lp55xx_led *led = cdev_to_lp55xx_led(cdev);
+
+	led->brightness = (u8)brightness;
+	schedule_work(&led->brightness_work);
 }
 
 static int lp55xx_init_led(struct lp55xx_led *led,

commit 0e2023463a3c9412728cb2c36c79aca0bb731cc8
Author: Milo(Woogyom) Kim <milo.kim@ti.com>
Date:   Tue Feb 5 19:07:34 2013 +0900

    leds-lp55xx: use lp55xx_init_led() common function
    
     lp5521_init_led() and lp5523_init_led() are replaced with one common function,
     lp55xx_init_led().
     Max channels is configurable, so it's used in lp55xx_init_led().
    
     'LP5523_LEDS' are changed to 'LP5523_MAX_LEDS'.
    
     lp55xx_set_brightness, lp55xx_led_attributes: skeleton
     Will be filled in next patches.
    
    Signed-off-by: Milo(Woogyom) Kim <milo.kim@ti.com>
    Signed-off-by: Bryan Wu <cooloney@gmail.com>

diff --git a/drivers/leds/leds-lp55xx-common.c b/drivers/leds/leds-lp55xx-common.c
index 1fab1d1c4502..75ab1c3c03ed 100644
--- a/drivers/leds/leds-lp55xx-common.c
+++ b/drivers/leds/leds-lp55xx-common.c
@@ -63,9 +63,75 @@ static int lp55xx_post_init_device(struct lp55xx_chip *chip)
 	return cfg->post_init_device(chip);
 }
 
+static struct attribute *lp55xx_led_attributes[] = {
+	NULL,
+};
+
+static struct attribute_group lp55xx_led_attr_group = {
+	.attrs = lp55xx_led_attributes
+};
+
+static void lp55xx_set_brightness(struct led_classdev *cdev,
+			     enum led_brightness brightness)
+{
+}
+
 static int lp55xx_init_led(struct lp55xx_led *led,
 			struct lp55xx_chip *chip, int chan)
 {
+	struct lp55xx_platform_data *pdata = chip->pdata;
+	struct lp55xx_device_config *cfg = chip->cfg;
+	struct device *dev = &chip->cl->dev;
+	char name[32];
+	int ret;
+	int max_channel = cfg->max_channel;
+
+	if (chan >= max_channel) {
+		dev_err(dev, "invalid channel: %d / %d\n", chan, max_channel);
+		return -EINVAL;
+	}
+
+	if (pdata->led_config[chan].led_current == 0)
+		return 0;
+
+	led->led_current = pdata->led_config[chan].led_current;
+	led->max_current = pdata->led_config[chan].max_current;
+	led->chan_nr = pdata->led_config[chan].chan_nr;
+
+	if (led->chan_nr >= max_channel) {
+		dev_err(dev, "Use channel numbers between 0 and %d\n",
+			max_channel - 1);
+		return -EINVAL;
+	}
+
+	led->cdev.brightness_set = lp55xx_set_brightness;
+
+	if (pdata->led_config[chan].name) {
+		led->cdev.name = pdata->led_config[chan].name;
+	} else {
+		snprintf(name, sizeof(name), "%s:channel%d",
+			pdata->label ? : chip->cl->name, chan);
+		led->cdev.name = name;
+	}
+
+	/*
+	 * register led class device for each channel and
+	 * add device attributes
+	 */
+
+	ret = led_classdev_register(dev, &led->cdev);
+	if (ret) {
+		dev_err(dev, "led register err: %d\n", ret);
+		return ret;
+	}
+
+	ret = sysfs_create_group(&led->cdev.dev->kobj, &lp55xx_led_attr_group);
+	if (ret) {
+		dev_err(dev, "led sysfs err: %d\n", ret);
+		led_classdev_unregister(&led->cdev);
+		return ret;
+	}
+
 	return 0;
 }
 

commit 9e9b3db1b2f725bacaf1b7e8708a0c78265bde97
Author: Milo(Woogyom) Kim <milo.kim@ti.com>
Date:   Tue Feb 5 19:06:27 2013 +0900

    leds-lp55xx: use lp55xx common led registration function
    
     LED class devices are registered in lp5521_register_leds() and
     lp5523_register_leds().
     Two separate functions are merged into consolidated lp55xx function,
     lp55xx_register_leds().
    
     Error handling fix:
     Unregistering LEDS are handled in lp55xx_register_leds() when LED registration
     failure occurs. So each driver error handler is changed to 'err_register_leds'
    
     Chip dependency: 'brightness_work_fn' and 'set_led_current'
     To make the structure abstract, both functions are configured in each driver.
     Those functions should be done by each driver because register control is
     chip-dependant work.
    
     lp55xx_init_led: skeleton
     Will be filled in next patch
    
    Signed-off-by: Milo(Woogyom) Kim <milo.kim@ti.com>
    Signed-off-by: Bryan Wu <cooloney@gmail.com>

diff --git a/drivers/leds/leds-lp55xx-common.c b/drivers/leds/leds-lp55xx-common.c
index bcabf2cb949a..1fab1d1c4502 100644
--- a/drivers/leds/leds-lp55xx-common.c
+++ b/drivers/leds/leds-lp55xx-common.c
@@ -63,6 +63,12 @@ static int lp55xx_post_init_device(struct lp55xx_chip *chip)
 	return cfg->post_init_device(chip);
 }
 
+static int lp55xx_init_led(struct lp55xx_led *led,
+			struct lp55xx_chip *chip, int chan)
+{
+	return 0;
+}
+
 int lp55xx_write(struct lp55xx_chip *chip, u8 reg, u8 val)
 {
 	return i2c_smbus_write_byte_data(chip->cl, reg, val);
@@ -170,6 +176,55 @@ void lp55xx_deinit_device(struct lp55xx_chip *chip)
 }
 EXPORT_SYMBOL_GPL(lp55xx_deinit_device);
 
+int lp55xx_register_leds(struct lp55xx_led *led, struct lp55xx_chip *chip)
+{
+	struct lp55xx_platform_data *pdata = chip->pdata;
+	struct lp55xx_device_config *cfg = chip->cfg;
+	int num_channels = pdata->num_channels;
+	struct lp55xx_led *each;
+	u8 led_current;
+	int ret;
+	int i;
+
+	if (!cfg->brightness_work_fn) {
+		dev_err(&chip->cl->dev, "empty brightness configuration\n");
+		return -EINVAL;
+	}
+
+	for (i = 0; i < num_channels; i++) {
+
+		/* do not initialize channels that are not connected */
+		if (pdata->led_config[i].led_current == 0)
+			continue;
+
+		led_current = pdata->led_config[i].led_current;
+		each = led + i;
+		ret = lp55xx_init_led(each, chip, i);
+		if (ret)
+			goto err_init_led;
+
+		INIT_WORK(&each->brightness_work, cfg->brightness_work_fn);
+
+		chip->num_leds++;
+		each->chip = chip;
+
+		/* setting led current at each channel */
+		if (cfg->set_led_current)
+			cfg->set_led_current(each, led_current);
+	}
+
+	return 0;
+
+err_init_led:
+	for (i = 0; i < chip->num_leds; i++) {
+		each = led + i;
+		led_classdev_unregister(&each->cdev);
+		flush_work(&each->brightness_work);
+	}
+	return ret;
+}
+EXPORT_SYMBOL_GPL(lp55xx_register_leds);
+
 MODULE_AUTHOR("Milo Kim <milo.kim@ti.com>");
 MODULE_DESCRIPTION("LP55xx Common Driver");
 MODULE_LICENSE("GPL");

commit 6ce6176263393dd80b9a537c1e1462b8529f240b
Author: Milo(Woogyom) Kim <milo.kim@ti.com>
Date:   Tue Feb 5 19:03:02 2013 +0900

    leds-lp55xx: use lp55xx common deinit function
    
     Two separate de-init functions are merged into one common function.
     And it is used in err_post_init of lp55xx_init_device().
    
    Signed-off-by: Milo(Woogyom) Kim <milo.kim@ti.com>
    Signed-off-by: Bryan Wu <cooloney@gmail.com>

diff --git a/drivers/leds/leds-lp55xx-common.c b/drivers/leds/leds-lp55xx-common.c
index c06745f160c3..bcabf2cb949a 100644
--- a/drivers/leds/leds-lp55xx-common.c
+++ b/drivers/leds/leds-lp55xx-common.c
@@ -152,14 +152,23 @@ int lp55xx_init_device(struct lp55xx_chip *chip)
 	return 0;
 
 err_post_init:
+	lp55xx_deinit_device(chip);
+err:
+	return ret;
+}
+EXPORT_SYMBOL_GPL(lp55xx_init_device);
+
+void lp55xx_deinit_device(struct lp55xx_chip *chip)
+{
+	struct lp55xx_platform_data *pdata = chip->pdata;
+
 	if (pdata->enable)
 		pdata->enable(0);
+
 	if (pdata->release_resources)
 		pdata->release_resources();
-err:
-	return ret;
 }
-EXPORT_SYMBOL_GPL(lp55xx_init_device);
+EXPORT_SYMBOL_GPL(lp55xx_deinit_device);
 
 MODULE_AUTHOR("Milo Kim <milo.kim@ti.com>");
 MODULE_DESCRIPTION("LP55xx Common Driver");

commit 22ebeb488b3dbbb64b81146b366551107ae34af8
Author: Milo(Woogyom) Kim <milo.kim@ti.com>
Date:   Tue Feb 5 18:58:35 2013 +0900

    leds-lp55xx: clean up init function
    
     lp5521/5523_init_device() are replaced with lp55xx common function,
     lp55xx_init_device().
    
     Error handler in init_device:
     deinit function are matched with 'err_post_init' section in
     lp55xx_init_device().
    
     Remove LP5523 engine intialization code:
     Engine functionality is not mandatory but optional.
     Moreover engine initialization is done internally with device reset command.
     Therefore, this code is unnecessary.
    
    Signed-off-by: Milo(Woogyom) Kim <milo.kim@ti.com>
    Signed-off-by: Bryan Wu <cooloney@gmail.com>

diff --git a/drivers/leds/leds-lp55xx-common.c b/drivers/leds/leds-lp55xx-common.c
index 74beb363b787..c06745f160c3 100644
--- a/drivers/leds/leds-lp55xx-common.c
+++ b/drivers/leds/leds-lp55xx-common.c
@@ -144,9 +144,18 @@ int lp55xx_init_device(struct lp55xx_chip *chip)
 
 	/* chip specific initialization */
 	ret = lp55xx_post_init_device(chip);
+	if (ret) {
+		dev_err(dev, "post init device err: %d\n", ret);
+		goto err_post_init;
+	}
 
 	return 0;
 
+err_post_init:
+	if (pdata->enable)
+		pdata->enable(0);
+	if (pdata->release_resources)
+		pdata->release_resources();
 err:
 	return ret;
 }

commit ffbdccdbbaee814963a09d25b1cc598cfe131366
Author: Milo(Woogyom) Kim <milo.kim@ti.com>
Date:   Tue Feb 5 18:57:36 2013 +0900

    leds-lp55xx: use lp55xx common init function - post int
    
     LP5521/5523 chip configuration is replaced with lp55xx common function,
     lp55xx_post_init_device().
    
     Name change:
     lp5521/5523_configure() to lp5521/5523_post_init_device()
     These are called in init function.
    
     Register access function
     Argument type is changed from 'i2c_client' to 'lp55xx_chip'.
     Use exported R/W functions of lp55xx common driver.
    
     Temporary variables in lp5521/5523_init_device()
     These functions will be removed but temporary variables are needed for
     blocking build warnings - incompatible pointer.
    
    Signed-off-by: Milo(Woogyom) Kim <milo.kim@ti.com>
    Signed-off-by: Bryan Wu <cooloney@gmail.com>

diff --git a/drivers/leds/leds-lp55xx-common.c b/drivers/leds/leds-lp55xx-common.c
index 6fede0b96715..74beb363b787 100644
--- a/drivers/leds/leds-lp55xx-common.c
+++ b/drivers/leds/leds-lp55xx-common.c
@@ -53,6 +53,16 @@ static int lp55xx_detect_device(struct lp55xx_chip *chip)
 	return 0;
 }
 
+static int lp55xx_post_init_device(struct lp55xx_chip *chip)
+{
+	struct lp55xx_device_config *cfg = chip->cfg;
+
+	if (!cfg->post_init_device)
+		return 0;
+
+	return cfg->post_init_device(chip);
+}
+
 int lp55xx_write(struct lp55xx_chip *chip, u8 reg, u8 val)
 {
 	return i2c_smbus_write_byte_data(chip->cl, reg, val);
@@ -132,6 +142,11 @@ int lp55xx_init_device(struct lp55xx_chip *chip)
 		goto err;
 	}
 
+	/* chip specific initialization */
+	ret = lp55xx_post_init_device(chip);
+
+	return 0;
+
 err:
 	return ret;
 }

commit e3a700d8aae190e09fb06abe0ddd2e172a682508
Author: Milo(Woogyom) Kim <milo.kim@ti.com>
Date:   Tue Feb 5 18:09:56 2013 +0900

    leds-lp55xx: use lp55xx common init function - detect
    
     LP5521/5523 chip detection functions are replaced with lp55xx common function,
     lp55xx_detect_device().
     Chip dependent address and values are configurable in each driver.
     In init function, chip detection is executed.
    
    Signed-off-by: Milo(Woogyom) Kim <milo.kim@ti.com>
    Signed-off-by: Bryan Wu <cooloney@gmail.com>

diff --git a/drivers/leds/leds-lp55xx-common.c b/drivers/leds/leds-lp55xx-common.c
index bbf2bbf03807..6fede0b96715 100644
--- a/drivers/leds/leds-lp55xx-common.c
+++ b/drivers/leds/leds-lp55xx-common.c
@@ -30,6 +30,29 @@ static void lp55xx_reset_device(struct lp55xx_chip *chip)
 	lp55xx_write(chip, addr, val);
 }
 
+static int lp55xx_detect_device(struct lp55xx_chip *chip)
+{
+	struct lp55xx_device_config *cfg = chip->cfg;
+	u8 addr = cfg->enable.addr;
+	u8 val  = cfg->enable.val;
+	int ret;
+
+	ret = lp55xx_write(chip, addr, val);
+	if (ret)
+		return ret;
+
+	usleep_range(1000, 2000);
+
+	ret = lp55xx_read(chip, addr, &val);
+	if (ret)
+		return ret;
+
+	if (val != cfg->enable.val)
+		return -ENODEV;
+
+	return 0;
+}
+
 int lp55xx_write(struct lp55xx_chip *chip, u8 reg, u8 val)
 {
 	return i2c_smbus_write_byte_data(chip->cl, reg, val);
@@ -103,6 +126,12 @@ int lp55xx_init_device(struct lp55xx_chip *chip)
 	 */
 	usleep_range(10000, 20000);
 
+	ret = lp55xx_detect_device(chip);
+	if (ret) {
+		dev_err(dev, "device detection err: %d\n", ret);
+		goto err;
+	}
+
 err:
 	return ret;
 }

commit 48068d5de16c23c256c085b2cd3ff03bec393900
Author: Milo(Woogyom) Kim <milo.kim@ti.com>
Date:   Tue Feb 5 18:08:49 2013 +0900

    leds-lp55xx: use lp55xx common init function - reset
    
     LP5521/5523 reset device functions are moved to lp55xx common driver.
     Value of register address and value are chip dependent.
     Those are configured in each driver.
     In init function, reset command is executed.
    
    Signed-off-by: Milo(Woogyom) Kim <milo.kim@ti.com>
    Signed-off-by: Bryan Wu <cooloney@gmail.com>

diff --git a/drivers/leds/leds-lp55xx-common.c b/drivers/leds/leds-lp55xx-common.c
index 05a854c0d9b2..bbf2bbf03807 100644
--- a/drivers/leds/leds-lp55xx-common.c
+++ b/drivers/leds/leds-lp55xx-common.c
@@ -20,6 +20,16 @@
 
 #include "leds-lp55xx-common.h"
 
+static void lp55xx_reset_device(struct lp55xx_chip *chip)
+{
+	struct lp55xx_device_config *cfg = chip->cfg;
+	u8 addr = cfg->reset.addr;
+	u8 val  = cfg->reset.val;
+
+	/* no error checking here because no ACK from the device after reset */
+	lp55xx_write(chip, addr, val);
+}
+
 int lp55xx_write(struct lp55xx_chip *chip, u8 reg, u8 val)
 {
 	return i2c_smbus_write_byte_data(chip->cl, reg, val);
@@ -58,14 +68,16 @@ EXPORT_SYMBOL_GPL(lp55xx_update_bits);
 int lp55xx_init_device(struct lp55xx_chip *chip)
 {
 	struct lp55xx_platform_data *pdata;
+	struct lp55xx_device_config *cfg;
 	struct device *dev = &chip->cl->dev;
 	int ret = 0;
 
 	WARN_ON(!chip);
 
 	pdata = chip->pdata;
+	cfg = chip->cfg;
 
-	if (!pdata)
+	if (!pdata || !cfg)
 		return -EINVAL;
 
 	if (pdata->setup_resources) {
@@ -83,6 +95,14 @@ int lp55xx_init_device(struct lp55xx_chip *chip)
 		usleep_range(1000, 2000); /* 500us abs min. */
 	}
 
+	lp55xx_reset_device(chip);
+
+	/*
+	 * Exact value is not available. 10 - 20ms
+	 * appears to be enough for reset.
+	 */
+	usleep_range(10000, 20000);
+
 err:
 	return ret;
 }

commit a85908dd7799e4fa242812ce27a8f774c721d1fb
Author: Milo(Woogyom) Kim <milo.kim@ti.com>
Date:   Tue Feb 5 18:07:20 2013 +0900

    leds-lp55xx: use lp55xx common init function - platform data
    
     LP5521/5523 platform data functions are moved to lp55xx common driver.
     New init function, lp55xx_init_device() is created.
    
    Signed-off-by: Milo(Woogyom) Kim <milo.kim@ti.com>
    Signed-off-by: Bryan Wu <cooloney@gmail.com>

diff --git a/drivers/leds/leds-lp55xx-common.c b/drivers/leds/leds-lp55xx-common.c
index 1c716ecfa817..05a854c0d9b2 100644
--- a/drivers/leds/leds-lp55xx-common.c
+++ b/drivers/leds/leds-lp55xx-common.c
@@ -12,6 +12,7 @@
  * Derived from leds-lp5521.c, leds-lp5523.c
  */
 
+#include <linux/delay.h>
 #include <linux/i2c.h>
 #include <linux/leds.h>
 #include <linux/module.h>
@@ -54,6 +55,39 @@ int lp55xx_update_bits(struct lp55xx_chip *chip, u8 reg, u8 mask, u8 val)
 }
 EXPORT_SYMBOL_GPL(lp55xx_update_bits);
 
+int lp55xx_init_device(struct lp55xx_chip *chip)
+{
+	struct lp55xx_platform_data *pdata;
+	struct device *dev = &chip->cl->dev;
+	int ret = 0;
+
+	WARN_ON(!chip);
+
+	pdata = chip->pdata;
+
+	if (!pdata)
+		return -EINVAL;
+
+	if (pdata->setup_resources) {
+		ret = pdata->setup_resources();
+		if (ret < 0) {
+			dev_err(dev, "setup resoure err: %d\n", ret);
+			goto err;
+		}
+	}
+
+	if (pdata->enable) {
+		pdata->enable(0);
+		usleep_range(1000, 2000); /* Keep enable down at least 1ms */
+		pdata->enable(1);
+		usleep_range(1000, 2000); /* 500us abs min. */
+	}
+
+err:
+	return ret;
+}
+EXPORT_SYMBOL_GPL(lp55xx_init_device);
+
 MODULE_AUTHOR("Milo Kim <milo.kim@ti.com>");
 MODULE_DESCRIPTION("LP55xx Common Driver");
 MODULE_LICENSE("GPL");

commit c93d08fa75020835741c7b1d0523ff854e8acde1
Author: Milo(Woogyom) Kim <milo.kim@ti.com>
Date:   Tue Feb 5 18:01:23 2013 +0900

    leds-lp55xx: add new common driver for lp5521/5523
    
     This patch supports basic common driver code for LP5521, LP5523/55231 devices.
    
     ( Driver Structure Data )
    
     lp55xx_led and lp55xx_chip
     In lp55xx common driver, two different data structure is used.
     o lp55xx_led
       control multi output LED channels such as led current, channel index.
     o lp55xx_chip
       general chip control such like the I2C and platform data.
    
     For example, LP5521 has maximum 3 LED channels.
     LP5523/55231 has 9 output channels.
    
     lp55xx_chip for LP5521 ... lp55xx_led #1
                                lp55xx_led #2
                                lp55xx_led #3
    
     lp55xx_chip for LP5523 ... lp55xx_led #1
                                lp55xx_led #2
                                .
                                .
                                lp55xx_led #9
    
     ( Platform Data )
    
     LP5521 and LP5523/55231 have own specific platform data.
     However, this data can be handled with just one platform data structure.
     The lp55xx platform data is declared in the header.
     This structure is derived from leds-lp5521.h and leds-lp5523.h
    
    Signed-off-by: Milo(Woogyom) Kim <milo.kim@ti.com>
    Signed-off-by: Bryan Wu <cooloney@gmail.com>

diff --git a/drivers/leds/leds-lp55xx-common.c b/drivers/leds/leds-lp55xx-common.c
new file mode 100644
index 000000000000..1c716ecfa817
--- /dev/null
+++ b/drivers/leds/leds-lp55xx-common.c
@@ -0,0 +1,59 @@
+/*
+ * LP5521/LP5523/LP55231 Common Driver
+ *
+ * Copyright 2012 Texas Instruments
+ *
+ * Author: Milo(Woogyom) Kim <milo.kim@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Derived from leds-lp5521.c, leds-lp5523.c
+ */
+
+#include <linux/i2c.h>
+#include <linux/leds.h>
+#include <linux/module.h>
+#include <linux/platform_data/leds-lp55xx.h>
+
+#include "leds-lp55xx-common.h"
+
+int lp55xx_write(struct lp55xx_chip *chip, u8 reg, u8 val)
+{
+	return i2c_smbus_write_byte_data(chip->cl, reg, val);
+}
+EXPORT_SYMBOL_GPL(lp55xx_write);
+
+int lp55xx_read(struct lp55xx_chip *chip, u8 reg, u8 *val)
+{
+	s32 ret;
+
+	ret = i2c_smbus_read_byte_data(chip->cl, reg);
+	if (ret < 0)
+		return ret;
+
+	*val = ret;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(lp55xx_read);
+
+int lp55xx_update_bits(struct lp55xx_chip *chip, u8 reg, u8 mask, u8 val)
+{
+	int ret;
+	u8 tmp;
+
+	ret = lp55xx_read(chip, reg, &tmp);
+	if (ret)
+		return ret;
+
+	tmp &= ~mask;
+	tmp |= val & mask;
+
+	return lp55xx_write(chip, reg, tmp);
+}
+EXPORT_SYMBOL_GPL(lp55xx_update_bits);
+
+MODULE_AUTHOR("Milo Kim <milo.kim@ti.com>");
+MODULE_DESCRIPTION("LP55xx Common Driver");
+MODULE_LICENSE("GPL");
