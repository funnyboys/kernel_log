commit fd81d7e946c6bdb86dbf0bd88fee3e1a545e7979
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Thu Aug 22 18:19:28 2019 +0300

    leds: Switch to use fwnode instead of be stuck with OF one
    
    There is no need to be stuck with OF node when we may use agnostic
    firmware node instead.
    
    It allows users to get property if needed independently of provider.
    
    Note, some OF parts are left because %pfw [1] is in progress.
    
    [1]: https://lore.kernel.org/patchwork/cover/1054863/
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Jacek Anaszewski <jacek.anaszewski@gmail.com>

diff --git a/drivers/leds/led-core.c b/drivers/leds/led-core.c
index f0c1c403f678..f1f718dbe0f8 100644
--- a/drivers/leds/led-core.c
+++ b/drivers/leds/led-core.c
@@ -324,14 +324,11 @@ EXPORT_SYMBOL_GPL(led_update_brightness);
 
 u32 *led_get_default_pattern(struct led_classdev *led_cdev, unsigned int *size)
 {
-	struct device_node *np = dev_of_node(led_cdev->dev);
+	struct fwnode_handle *fwnode = led_cdev->dev->fwnode;
 	u32 *pattern;
 	int count;
 
-	if (!np)
-		return NULL;
-
-	count = of_property_count_u32_elems(np, "led-pattern");
+	count = fwnode_property_count_u32(fwnode, "led-pattern");
 	if (count < 0)
 		return NULL;
 
@@ -339,7 +336,7 @@ u32 *led_get_default_pattern(struct led_classdev *led_cdev, unsigned int *size)
 	if (!pattern)
 		return NULL;
 
-	if (of_property_read_u32_array(np, "led-pattern", pattern, count)) {
+	if (fwnode_property_read_u32_array(fwnode, "led-pattern", pattern, count)) {
 		kfree(pattern);
 		return NULL;
 	}

commit bb4e9af0348dfeafd66c7e7f82e8a0983fe5390c
Author: Jacek Anaszewski <jacek.anaszewski@gmail.com>
Date:   Sun Jun 9 20:19:04 2019 +0200

    leds: core: Add support for composing LED class device names
    
    Add generic support for composing LED class device name. The newly
    introduced led_compose_name() function composes device name according
    to either <color:function> or <devicename:color:function> pattern,
    depending on the configuration of initialization data.
    
    Backward compatibility with in-driver hard-coded LED class device
    names is assured thanks to the default_label and devicename properties
    of newly introduced struct led_init_data.
    
    In case none of the aforementioned properties was found, then, for OF
    nodes, the node name is adopted for LED class device name.
    
    At the occassion of amending the Documentation/leds/leds-class.txt
    unify spelling: colour -> color.
    
    Alongside these changes added is a new tool - tools/leds/get_led_device_info.sh.
    The tool allows retrieving details of a LED class device's parent device,
    which proves that using vendor or product name for devicename part
    of LED name doesn't convey any added value since that information had been
    already available in sysfs. The script performs also basic validation
    of a LED class device name.
    
    Signed-off-by: Jacek Anaszewski <jacek.anaszewski@gmail.com>
    Cc: Baolin Wang <baolin.wang@linaro.org>
    Cc: Dan Murphy <dmurphy@ti.com>
    Cc: Daniel Mack <daniel@zonque.org>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: Oleh Kravchenko <oleg@kaa.org.ua>
    Cc: Sakari Ailus <sakari.ailus@linux.intel.com>
    Cc: Simon Shields <simon@lineageos.org>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Pavel Machek <pavel@ucw.cz>

diff --git a/drivers/leds/led-core.c b/drivers/leds/led-core.c
index 7107cd7e87cf..f0c1c403f678 100644
--- a/drivers/leds/led-core.c
+++ b/drivers/leds/led-core.c
@@ -13,8 +13,10 @@
 #include <linux/module.h>
 #include <linux/mutex.h>
 #include <linux/of.h>
+#include <linux/property.h>
 #include <linux/rwsem.h>
 #include <linux/slab.h>
+#include <uapi/linux/uleds.h>
 #include "leds.h"
 
 DECLARE_RWSEM(leds_list_lock);
@@ -23,6 +25,18 @@ EXPORT_SYMBOL_GPL(leds_list_lock);
 LIST_HEAD(leds_list);
 EXPORT_SYMBOL_GPL(leds_list);
 
+const char * const led_colors[LED_COLOR_ID_MAX] = {
+	[LED_COLOR_ID_WHITE] = "white",
+	[LED_COLOR_ID_RED] = "red",
+	[LED_COLOR_ID_GREEN] = "green",
+	[LED_COLOR_ID_BLUE] = "blue",
+	[LED_COLOR_ID_AMBER] = "amber",
+	[LED_COLOR_ID_VIOLET] = "violet",
+	[LED_COLOR_ID_YELLOW] = "yellow",
+	[LED_COLOR_ID_IR] = "ir",
+};
+EXPORT_SYMBOL_GPL(led_colors);
+
 static int __led_set_brightness(struct led_classdev *led_cdev,
 				enum led_brightness value)
 {
@@ -353,3 +367,116 @@ void led_sysfs_enable(struct led_classdev *led_cdev)
 	led_cdev->flags &= ~LED_SYSFS_DISABLE;
 }
 EXPORT_SYMBOL_GPL(led_sysfs_enable);
+
+static void led_parse_fwnode_props(struct device *dev,
+				   struct fwnode_handle *fwnode,
+				   struct led_properties *props)
+{
+	int ret;
+
+	if (!fwnode)
+		return;
+
+	if (fwnode_property_present(fwnode, "label")) {
+		ret = fwnode_property_read_string(fwnode, "label", &props->label);
+		if (ret)
+			dev_err(dev, "Error parsing 'label' property (%d)\n", ret);
+		return;
+	}
+
+	if (fwnode_property_present(fwnode, "color")) {
+		ret = fwnode_property_read_u32(fwnode, "color", &props->color);
+		if (ret)
+			dev_err(dev, "Error parsing 'color' property (%d)\n", ret);
+		else if (props->color >= LED_COLOR_ID_MAX)
+			dev_err(dev, "LED color identifier out of range\n");
+		else
+			props->color_present = true;
+	}
+
+
+	if (!fwnode_property_present(fwnode, "function"))
+		return;
+
+	ret = fwnode_property_read_string(fwnode, "function", &props->function);
+	if (ret) {
+		dev_err(dev,
+			"Error parsing 'function' property (%d)\n",
+			ret);
+	}
+
+	if (!fwnode_property_present(fwnode, "function-enumerator"))
+		return;
+
+	ret = fwnode_property_read_u32(fwnode, "function-enumerator",
+				       &props->func_enum);
+	if (ret) {
+		dev_err(dev,
+			"Error parsing 'function-enumerator' property (%d)\n",
+			ret);
+	} else {
+		props->func_enum_present = true;
+	}
+}
+
+int led_compose_name(struct device *dev, struct led_init_data *init_data,
+		     char *led_classdev_name)
+{
+	struct led_properties props = {};
+	struct fwnode_handle *fwnode = init_data->fwnode;
+	const char *devicename = init_data->devicename;
+
+	if (!led_classdev_name)
+		return -EINVAL;
+
+	led_parse_fwnode_props(dev, fwnode, &props);
+
+	if (props.label) {
+		/*
+		 * If init_data.devicename is NULL, then it indicates that
+		 * DT label should be used as-is for LED class device name.
+		 * Otherwise the label is prepended with devicename to compose
+		 * the final LED class device name.
+		 */
+		if (!devicename) {
+			strscpy(led_classdev_name, props.label,
+				LED_MAX_NAME_SIZE);
+		} else {
+			snprintf(led_classdev_name, LED_MAX_NAME_SIZE, "%s:%s",
+				 devicename, props.label);
+		}
+	} else if (props.function || props.color_present) {
+		char tmp_buf[LED_MAX_NAME_SIZE];
+
+		if (props.func_enum_present) {
+			snprintf(tmp_buf, LED_MAX_NAME_SIZE, "%s:%s-%d",
+				 props.color_present ? led_colors[props.color] : "",
+				 props.function ?: "", props.func_enum);
+		} else {
+			snprintf(tmp_buf, LED_MAX_NAME_SIZE, "%s:%s",
+				 props.color_present ? led_colors[props.color] : "",
+				 props.function ?: "");
+		}
+		if (init_data->devname_mandatory) {
+			snprintf(led_classdev_name, LED_MAX_NAME_SIZE, "%s:%s",
+				 devicename, tmp_buf);
+		} else {
+			strscpy(led_classdev_name, tmp_buf, LED_MAX_NAME_SIZE);
+
+		}
+	} else if (init_data->default_label) {
+		if (!devicename) {
+			dev_err(dev, "Legacy LED naming requires devicename segment");
+			return -EINVAL;
+		}
+		snprintf(led_classdev_name, LED_MAX_NAME_SIZE, "%s:%s",
+			 devicename, init_data->default_label);
+	} else if (is_of_node(fwnode)) {
+		strscpy(led_classdev_name, to_of_node(fwnode)->name,
+			LED_MAX_NAME_SIZE);
+	} else
+		return -EINVAL;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(led_compose_name);

commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/leds/led-core.c b/drivers/leds/led-core.c
index e3da7c03da1b..7107cd7e87cf 100644
--- a/drivers/leds/led-core.c
+++ b/drivers/leds/led-core.c
@@ -1,14 +1,10 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * LED Class Core
  *
  * Copyright 2005-2006 Openedhand Ltd.
  *
  * Author: Richard Purdie <rpurdie@openedhand.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
  */
 
 #include <linux/kernel.h>

commit 8c0f693c6effbc3f42f77a9e81209af9af20910c
Author: Pavel Machek <pavel@ucw.cz>
Date:   Sun May 26 09:38:55 2019 +0200

    leds: avoid flush_work in atomic context
    
    It turns out that various triggers use led_blink_setup() from atomic
    context, so we can't do a flush_work there. Flush is still needed for
    slow LEDs, but we can move it to sysfs code where it is safe.
    
        WARNING: inconsistent lock state
        5.2.0-rc1 #1 Tainted: G        W
        --------------------------------
        inconsistent {SOFTIRQ-ON-W} -> {IN-SOFTIRQ-W} usage.
        swapper/1/0 [HC0[0]:SC1[1]:HE1:SE0] takes:
        000000006e30541b
        ((work_completion)(&led_cdev->set_brightness_work)){+.?.}, at:
        +__flush_work+0x3b/0x38a
        {SOFTIRQ-ON-W} state was registered at:
          lock_acquire+0x146/0x1a1
         __flush_work+0x5b/0x38a
         flush_work+0xb/0xd
         led_blink_setup+0x1e/0xd3
         led_blink_set+0x3f/0x44
         tpt_trig_timer+0xdb/0x106
         ieee80211_mod_tpt_led_trig+0xed/0x112
    
    Fixes: 0db37915d912 ("leds: avoid races with workqueue")
    Signed-off-by: Pavel Machek <pavel@ucw.cz>
    Tested-by: Hugh Dickins <hughd@google.com>
    Signed-off-by: Jacek Anaszewski <jacek.anaszewski@gmail.com>

diff --git a/drivers/leds/led-core.c b/drivers/leds/led-core.c
index e9ae7f87ab90..e3da7c03da1b 100644
--- a/drivers/leds/led-core.c
+++ b/drivers/leds/led-core.c
@@ -164,11 +164,6 @@ static void led_blink_setup(struct led_classdev *led_cdev,
 		     unsigned long *delay_on,
 		     unsigned long *delay_off)
 {
-	/*
-	 * If "set brightness to 0" is pending in workqueue, we don't
-	 * want that to be reordered after blink_set()
-	 */
-	flush_work(&led_cdev->set_brightness_work);
 	if (!test_bit(LED_BLINK_ONESHOT, &led_cdev->work_flags) &&
 	    led_cdev->blink_set &&
 	    !led_cdev->blink_set(led_cdev, delay_on, delay_off))

commit 0db37915d912e8dc6588f25da76d3ed36718d92f
Author: Pavel Machek <pavel@ucw.cz>
Date:   Mon Apr 29 17:22:59 2019 +0200

    leds: avoid races with workqueue
    
    There are races between "main" thread and workqueue. They manifest
    themselves on Thinkpad X60:
    
    This should result in LED blinking, but it turns it off instead:
    
        root@amd:/data/pavel# cd /sys/class/leds/tpacpi\:\:power
        root@amd:/sys/class/leds/tpacpi::power# echo timer > trigger
        root@amd:/sys/class/leds/tpacpi::power# echo timer > trigger
    
    It should be possible to transition from blinking to solid on by echo
    0 > brightness; echo 1 > brightness... but that does not work, either,
    if done too quickly.
    
    Synchronization of the workqueue fixes both.
    
    Fixes: 1afcadfcd184 ("leds: core: Use set_brightness_work for the blocking op")
    Signed-off-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Jacek Anaszewski <jacek.anaszewski@gmail.com>

diff --git a/drivers/leds/led-core.c b/drivers/leds/led-core.c
index e3da7c03da1b..e9ae7f87ab90 100644
--- a/drivers/leds/led-core.c
+++ b/drivers/leds/led-core.c
@@ -164,6 +164,11 @@ static void led_blink_setup(struct led_classdev *led_cdev,
 		     unsigned long *delay_on,
 		     unsigned long *delay_off)
 {
+	/*
+	 * If "set brightness to 0" is pending in workqueue, we don't
+	 * want that to be reordered after blink_set()
+	 */
+	flush_work(&led_cdev->set_brightness_work);
 	if (!test_bit(LED_BLINK_ONESHOT, &led_cdev->work_flags) &&
 	    led_cdev->blink_set &&
 	    !led_cdev->blink_set(led_cdev, delay_on, delay_off))

commit 8e1f456129e61371fb190c71ea182a9f6e21282e
Author: Krzysztof Kozlowski <krzk@kernel.org>
Date:   Wed Jan 9 15:44:46 2019 +0100

    leds: Add helper for getting default pattern from Device Tree
    
    Multiple LED triggers might need to access default pattern so add a
    helper for that.
    
    Signed-off-by: Krzysztof Kozlowski <krzk@kernel.org>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Jacek Anaszewski <jacek.anaszewski@gmail.com>

diff --git a/drivers/leds/led-core.c b/drivers/leds/led-core.c
index ede4fa0ac2cc..e3da7c03da1b 100644
--- a/drivers/leds/led-core.c
+++ b/drivers/leds/led-core.c
@@ -16,7 +16,9 @@
 #include <linux/list.h>
 #include <linux/module.h>
 #include <linux/mutex.h>
+#include <linux/of.h>
 #include <linux/rwsem.h>
+#include <linux/slab.h>
 #include "leds.h"
 
 DECLARE_RWSEM(leds_list_lock);
@@ -310,6 +312,34 @@ int led_update_brightness(struct led_classdev *led_cdev)
 }
 EXPORT_SYMBOL_GPL(led_update_brightness);
 
+u32 *led_get_default_pattern(struct led_classdev *led_cdev, unsigned int *size)
+{
+	struct device_node *np = dev_of_node(led_cdev->dev);
+	u32 *pattern;
+	int count;
+
+	if (!np)
+		return NULL;
+
+	count = of_property_count_u32_elems(np, "led-pattern");
+	if (count < 0)
+		return NULL;
+
+	pattern = kcalloc(count, sizeof(*pattern), GFP_KERNEL);
+	if (!pattern)
+		return NULL;
+
+	if (of_property_read_u32_array(np, "led-pattern", pattern, count)) {
+		kfree(pattern);
+		return NULL;
+	}
+
+	*size = count;
+
+	return pattern;
+}
+EXPORT_SYMBOL_GPL(led_get_default_pattern);
+
 /* Caller must ensure led_cdev->led_access held */
 void led_sysfs_disable(struct led_classdev *led_cdev)
 {

commit 7b6af2c53192f1766892ef40c8f48a413509ed72
Author: Jacek Anaszewski <jacek.anaszewski@gmail.com>
Date:   Wed Jan 3 21:13:45 2018 +0100

    leds: core: Fix regression caused by commit 2b83ff96f51d
    
    Commit 2b83ff96f51d ("led: core: Fix brightness setting when setting delay_off=0")
    replaced del_timer_sync(&led_cdev->blink_timer) with led_stop_software_blink()
    in led_blink_set(), which additionally clears LED_BLINK_SW flag as well as
    zeroes blink_delay_on and blink_delay_off properties of the struct led_classdev.
    
    Cleansing of the latter ones wasn't required to fix the original issue but
    wasn't considered harmful. It nonetheless turned out to be so in case when
    pointer to one or both props is passed to led_blink_set() like in the
    ledtrig-timer.c. In such cases zeroes are passed later in delay_on and/or
    delay_off arguments to led_blink_setup(), which results either in stopping
    the software blinking or setting blinking frequency always to 1Hz.
    
    Avoid using led_stop_software_blink() and add a single call required
    to clear LED_BLINK_SW flag, which was the only needed modification to
    fix the original issue.
    
    Fixes 2b83ff96f51d ("led: core: Fix brightness setting when setting delay_off=0")
    Signed-off-by: Jacek Anaszewski <jacek.anaszewski@gmail.com>

diff --git a/drivers/leds/led-core.c b/drivers/leds/led-core.c
index f3654fd2eaf3..ede4fa0ac2cc 100644
--- a/drivers/leds/led-core.c
+++ b/drivers/leds/led-core.c
@@ -186,8 +186,9 @@ void led_blink_set(struct led_classdev *led_cdev,
 		   unsigned long *delay_on,
 		   unsigned long *delay_off)
 {
-	led_stop_software_blink(led_cdev);
+	del_timer_sync(&led_cdev->blink_timer);
 
+	clear_bit(LED_BLINK_SW, &led_cdev->work_flags);
 	clear_bit(LED_BLINK_ONESHOT, &led_cdev->work_flags);
 	clear_bit(LED_BLINK_ONESHOT_STOP, &led_cdev->work_flags);
 

commit 2b83ff96f51d0b039c4561b9f95c824d7bddb85c
Author: Matthieu CASTET <matthieu.castet@parrot.com>
Date:   Tue Dec 12 11:10:44 2017 +0100

    led: core: Fix brightness setting when setting delay_off=0
    
    With the current code, the following sequence won't work :
    echo timer > trigger
    
    echo 0 >  delay_off
    * at this point we call
    ** led_delay_off_store
    ** led_blink_set
    *** stop timer
    ** led_blink_setup
    ** led_set_software_blink
    *** if !delay_on, led off
    *** if !delay_off, set led_set_brightness_nosleep <--- LED_BLINK_SW is set but timer is stop
    *** otherwise start timer/set LED_BLINK_SW flag
    
    echo xxx > brightness
    * led_set_brightness
    ** if LED_BLINK_SW
    *** if brightness=0, led off
    *** else apply brightness if next timer <--- timer is stop, and will never apply new setting
    ** otherwise set led_set_brightness_nosleep
    
    To fix that, when we delete the timer, we should clear LED_BLINK_SW.
    
    Cc: linux-leds@vger.kernel.org
    Signed-off-by: Matthieu CASTET <matthieu.castet@parrot.com>
    Signed-off-by: Jacek Anaszewski <jacek.anaszewski@gmail.com>

diff --git a/drivers/leds/led-core.c b/drivers/leds/led-core.c
index fd83c7f77a95..f3654fd2eaf3 100644
--- a/drivers/leds/led-core.c
+++ b/drivers/leds/led-core.c
@@ -186,7 +186,7 @@ void led_blink_set(struct led_classdev *led_cdev,
 		   unsigned long *delay_on,
 		   unsigned long *delay_off)
 {
-	del_timer_sync(&led_cdev->blink_timer);
+	led_stop_software_blink(led_cdev);
 
 	clear_bit(LED_BLINK_ONESHOT, &led_cdev->work_flags);
 	clear_bit(LED_BLINK_ONESHOT_STOP, &led_cdev->work_flags);

commit 49404665b935447d4f2d5509fbff569b7bf8c495
Author: Kees Cook <keescook@chromium.org>
Date:   Wed Oct 25 03:30:01 2017 -0700

    leds: Convert timers to use timer_setup()
    
    In preparation for unconditionally passing the struct timer_list pointer to
    all timer callbacks, switch to using the new timer_setup() and from_timer()
    to pass the timer pointer explicitly.
    
    Cc: Richard Purdie <rpurdie@rpsys.net>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: Willy Tarreau <w@1wt.eu>
    Cc: linux-leds@vger.kernel.org
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Jacek Anaszewski <jacek.anaszewski@gmail.com>

diff --git a/drivers/leds/led-core.c b/drivers/leds/led-core.c
index ef1360445413..fd83c7f77a95 100644
--- a/drivers/leds/led-core.c
+++ b/drivers/leds/led-core.c
@@ -45,9 +45,9 @@ static int __led_set_brightness_blocking(struct led_classdev *led_cdev,
 	return led_cdev->brightness_set_blocking(led_cdev, value);
 }
 
-static void led_timer_function(unsigned long data)
+static void led_timer_function(struct timer_list *t)
 {
-	struct led_classdev *led_cdev = (void *)data;
+	struct led_classdev *led_cdev = from_timer(led_cdev, t, blink_timer);
 	unsigned long brightness;
 	unsigned long delay;
 
@@ -178,8 +178,7 @@ void led_init_core(struct led_classdev *led_cdev)
 {
 	INIT_WORK(&led_cdev->set_brightness_work, set_brightness_delayed);
 
-	setup_timer(&led_cdev->blink_timer, led_timer_function,
-		    (unsigned long)led_cdev);
+	timer_setup(&led_cdev->blink_timer, led_timer_function, 0);
 }
 EXPORT_SYMBOL_GPL(led_init_core);
 

commit eb1610b4c273370f491c5e194e5a56e3470d81e8
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Sun Oct 23 21:47:26 2016 +0200

    led: core: Fix blink_brightness setting race
    
    All 3 of led_timer_func, led_set_brightness and led_set_software_blink
    set blink_brightness. If led_timer_func or led_set_software_blink race
    with led_set_brightness they may end up overwriting the new
    blink_brightness. The new atomic work_flags does not protect against
    this as it just protects the flags and not blink_brightness.
    
    This commit introduces a new new_blink_brightness value which gets
    set by led_set_brightness and read by led_timer_func on LED on, fixing
    this.
    
    Dealing with the new brightness at LED on time, makes the new
    brightness apply sooner, which also fixes a led_set_brightness which
    happens while a oneshot blink which ends in LED on is running not
    getting applied.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Jacek Anaszewski <j.anaszewski@samsung.com>

diff --git a/drivers/leds/led-core.c b/drivers/leds/led-core.c
index bd6bb4d44f05..ef1360445413 100644
--- a/drivers/leds/led-core.c
+++ b/drivers/leds/led-core.c
@@ -66,17 +66,17 @@ static void led_timer_function(unsigned long data)
 	brightness = led_get_brightness(led_cdev);
 	if (!brightness) {
 		/* Time to switch the LED on. */
-		brightness = led_cdev->blink_brightness;
+		if (test_and_clear_bit(LED_BLINK_BRIGHTNESS_CHANGE,
+					&led_cdev->work_flags))
+			brightness = led_cdev->new_blink_brightness;
+		else
+			brightness = led_cdev->blink_brightness;
 		delay = led_cdev->blink_delay_on;
 	} else {
 		/* Store the current brightness value to be able
 		 * to restore it when the delay_off period is over.
-		 * Do it only if there is no pending blink brightness
-		 * change, to avoid overwriting the new value.
 		 */
-		if (!test_and_clear_bit(LED_BLINK_BRIGHTNESS_CHANGE,
-					&led_cdev->work_flags))
-			led_cdev->blink_brightness = brightness;
+		led_cdev->blink_brightness = brightness;
 		brightness = LED_OFF;
 		delay = led_cdev->blink_delay_off;
 	}
@@ -245,7 +245,7 @@ void led_set_brightness(struct led_classdev *led_cdev,
 		} else {
 			set_bit(LED_BLINK_BRIGHTNESS_CHANGE,
 				&led_cdev->work_flags);
-			led_cdev->blink_brightness = brightness;
+			led_cdev->new_blink_brightness = brightness;
 		}
 		return;
 	}

commit a9c6ce57ec2f136d08141e8220a0ffaca216f7b0
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Tue Nov 8 14:38:46 2016 +0100

    led: core: Use atomic bit-field for the blink-flags
    
    All the LED_BLINK* flags are accessed read-modify-write from e.g.
    led_set_brightness and led_blink_set_oneshot while both
    set_brightness_work and the blink_timer may be running.
    
    If these race then the modify step done by one of them may be lost,
    switch the LED_BLINK* flags to a new atomic work_flags bit-field
    to avoid this race.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Jacek Anaszewski <j.anaszewski@samsung.com>

diff --git a/drivers/leds/led-core.c b/drivers/leds/led-core.c
index 3bce44893021..bd6bb4d44f05 100644
--- a/drivers/leds/led-core.c
+++ b/drivers/leds/led-core.c
@@ -53,12 +53,13 @@ static void led_timer_function(unsigned long data)
 
 	if (!led_cdev->blink_delay_on || !led_cdev->blink_delay_off) {
 		led_set_brightness_nosleep(led_cdev, LED_OFF);
-		led_cdev->flags &= ~LED_BLINK_SW;
+		clear_bit(LED_BLINK_SW, &led_cdev->work_flags);
 		return;
 	}
 
-	if (led_cdev->flags & LED_BLINK_ONESHOT_STOP) {
-		led_cdev->flags &=  ~(LED_BLINK_ONESHOT_STOP | LED_BLINK_SW);
+	if (test_and_clear_bit(LED_BLINK_ONESHOT_STOP,
+			       &led_cdev->work_flags)) {
+		clear_bit(LED_BLINK_SW, &led_cdev->work_flags);
 		return;
 	}
 
@@ -73,10 +74,9 @@ static void led_timer_function(unsigned long data)
 		 * Do it only if there is no pending blink brightness
 		 * change, to avoid overwriting the new value.
 		 */
-		if (!(led_cdev->flags & LED_BLINK_BRIGHTNESS_CHANGE))
+		if (!test_and_clear_bit(LED_BLINK_BRIGHTNESS_CHANGE,
+					&led_cdev->work_flags))
 			led_cdev->blink_brightness = brightness;
-		else
-			led_cdev->flags &= ~LED_BLINK_BRIGHTNESS_CHANGE;
 		brightness = LED_OFF;
 		delay = led_cdev->blink_delay_off;
 	}
@@ -87,13 +87,15 @@ static void led_timer_function(unsigned long data)
 	 * the final blink state so that the led is toggled each delay_on +
 	 * delay_off milliseconds in worst case.
 	 */
-	if (led_cdev->flags & LED_BLINK_ONESHOT) {
-		if (led_cdev->flags & LED_BLINK_INVERT) {
+	if (test_bit(LED_BLINK_ONESHOT, &led_cdev->work_flags)) {
+		if (test_bit(LED_BLINK_INVERT, &led_cdev->work_flags)) {
 			if (brightness)
-				led_cdev->flags |= LED_BLINK_ONESHOT_STOP;
+				set_bit(LED_BLINK_ONESHOT_STOP,
+					&led_cdev->work_flags);
 		} else {
 			if (!brightness)
-				led_cdev->flags |= LED_BLINK_ONESHOT_STOP;
+				set_bit(LED_BLINK_ONESHOT_STOP,
+					&led_cdev->work_flags);
 		}
 	}
 
@@ -106,10 +108,9 @@ static void set_brightness_delayed(struct work_struct *ws)
 		container_of(ws, struct led_classdev, set_brightness_work);
 	int ret = 0;
 
-	if (led_cdev->flags & LED_BLINK_DISABLE) {
+	if (test_and_clear_bit(LED_BLINK_DISABLE, &led_cdev->work_flags)) {
 		led_cdev->delayed_set_value = LED_OFF;
 		led_stop_software_blink(led_cdev);
-		led_cdev->flags &= ~LED_BLINK_DISABLE;
 	}
 
 	ret = __led_set_brightness(led_cdev, led_cdev->delayed_set_value);
@@ -152,7 +153,7 @@ static void led_set_software_blink(struct led_classdev *led_cdev,
 		return;
 	}
 
-	led_cdev->flags |= LED_BLINK_SW;
+	set_bit(LED_BLINK_SW, &led_cdev->work_flags);
 	mod_timer(&led_cdev->blink_timer, jiffies + 1);
 }
 
@@ -161,7 +162,7 @@ static void led_blink_setup(struct led_classdev *led_cdev,
 		     unsigned long *delay_on,
 		     unsigned long *delay_off)
 {
-	if (!(led_cdev->flags & LED_BLINK_ONESHOT) &&
+	if (!test_bit(LED_BLINK_ONESHOT, &led_cdev->work_flags) &&
 	    led_cdev->blink_set &&
 	    !led_cdev->blink_set(led_cdev, delay_on, delay_off))
 		return;
@@ -188,8 +189,8 @@ void led_blink_set(struct led_classdev *led_cdev,
 {
 	del_timer_sync(&led_cdev->blink_timer);
 
-	led_cdev->flags &= ~LED_BLINK_ONESHOT;
-	led_cdev->flags &= ~LED_BLINK_ONESHOT_STOP;
+	clear_bit(LED_BLINK_ONESHOT, &led_cdev->work_flags);
+	clear_bit(LED_BLINK_ONESHOT_STOP, &led_cdev->work_flags);
 
 	led_blink_setup(led_cdev, delay_on, delay_off);
 }
@@ -200,17 +201,17 @@ void led_blink_set_oneshot(struct led_classdev *led_cdev,
 			   unsigned long *delay_off,
 			   int invert)
 {
-	if ((led_cdev->flags & LED_BLINK_ONESHOT) &&
+	if (test_bit(LED_BLINK_ONESHOT, &led_cdev->work_flags) &&
 	     timer_pending(&led_cdev->blink_timer))
 		return;
 
-	led_cdev->flags |= LED_BLINK_ONESHOT;
-	led_cdev->flags &= ~LED_BLINK_ONESHOT_STOP;
+	set_bit(LED_BLINK_ONESHOT, &led_cdev->work_flags);
+	clear_bit(LED_BLINK_ONESHOT_STOP, &led_cdev->work_flags);
 
 	if (invert)
-		led_cdev->flags |= LED_BLINK_INVERT;
+		set_bit(LED_BLINK_INVERT, &led_cdev->work_flags);
 	else
-		led_cdev->flags &= ~LED_BLINK_INVERT;
+		clear_bit(LED_BLINK_INVERT, &led_cdev->work_flags);
 
 	led_blink_setup(led_cdev, delay_on, delay_off);
 }
@@ -221,7 +222,7 @@ void led_stop_software_blink(struct led_classdev *led_cdev)
 	del_timer_sync(&led_cdev->blink_timer);
 	led_cdev->blink_delay_on = 0;
 	led_cdev->blink_delay_off = 0;
-	led_cdev->flags &= ~LED_BLINK_SW;
+	clear_bit(LED_BLINK_SW, &led_cdev->work_flags);
 }
 EXPORT_SYMBOL_GPL(led_stop_software_blink);
 
@@ -232,17 +233,18 @@ void led_set_brightness(struct led_classdev *led_cdev,
 	 * If software blink is active, delay brightness setting
 	 * until the next timer tick.
 	 */
-	if (led_cdev->flags & LED_BLINK_SW) {
+	if (test_bit(LED_BLINK_SW, &led_cdev->work_flags)) {
 		/*
 		 * If we need to disable soft blinking delegate this to the
 		 * work queue task to avoid problems in case we are called
 		 * from hard irq context.
 		 */
 		if (brightness == LED_OFF) {
-			led_cdev->flags |= LED_BLINK_DISABLE;
+			set_bit(LED_BLINK_DISABLE, &led_cdev->work_flags);
 			schedule_work(&led_cdev->set_brightness_work);
 		} else {
-			led_cdev->flags |= LED_BLINK_BRIGHTNESS_CHANGE;
+			set_bit(LED_BLINK_BRIGHTNESS_CHANGE,
+				&led_cdev->work_flags);
 			led_cdev->blink_brightness = brightness;
 		}
 		return;

commit 7cfe749fad5158247282f2fee30773fd454029ab
Author: Tony Makkiel <tony.makkiel@daqri.com>
Date:   Wed May 18 17:22:45 2016 +0100

    leds: core: Fix brightness setting upon hardware blinking enabled
    
    Commit 76931edd54f8 ("leds: fix brightness changing when software blinking
    is active") changed the semantics of led_set_brightness() which according
    to the documentation should disable blinking upon any brightness setting.
    Moreover it made it different for soft blink case, where it was possible
    to change blink brightness, and for hardware blink case, where setting
    any brightness greater than 0 was ignored.
    
    While the change itself is against the documentation claims, it was driven
    also by the fact that timer trigger remained active after turning blinking
    off. Fixing that would have required major refactoring in the led-core,
    led-class, and led-triggers because of cyclic dependencies.
    
    Finally, it has been decided that allowing for brightness change during
    blinking is beneficial as it can be accomplished without disturbing
    blink rhythm.
    
    The change in brightness setting semantics will not affect existing
    LED class drivers that implement blink_set op thanks to the LED_BLINK_SW
    flag introduced by this patch. The flag state will be from now on checked
    in led_set_brightness() which will allow to distinguish between software
    and hardware blink mode. In the latter case the control will be passed
    directly to the drivers which apply their semantics on brightness set,
    which is disable the blinking in case of most such drivers. New drivers
    will apply new semantics and just change the brightness while hardware
    blinking is on, if possible.
    
    The issue was smuggled by subsequent LED core improvements, which modified
    the code that originally introduced the problem.
    
    Fixes: f1e80c07416a ("leds: core: Add two new LED_BLINK_ flags")
    Signed-off-by: Tony Makkiel <tony.makkiel@daqri.com>
    Signed-off-by: Jacek Anaszewski <j.anaszewski@samsung.com>

diff --git a/drivers/leds/led-core.c b/drivers/leds/led-core.c
index 3495d5d6547f..3bce44893021 100644
--- a/drivers/leds/led-core.c
+++ b/drivers/leds/led-core.c
@@ -53,11 +53,12 @@ static void led_timer_function(unsigned long data)
 
 	if (!led_cdev->blink_delay_on || !led_cdev->blink_delay_off) {
 		led_set_brightness_nosleep(led_cdev, LED_OFF);
+		led_cdev->flags &= ~LED_BLINK_SW;
 		return;
 	}
 
 	if (led_cdev->flags & LED_BLINK_ONESHOT_STOP) {
-		led_cdev->flags &= ~LED_BLINK_ONESHOT_STOP;
+		led_cdev->flags &=  ~(LED_BLINK_ONESHOT_STOP | LED_BLINK_SW);
 		return;
 	}
 
@@ -151,6 +152,7 @@ static void led_set_software_blink(struct led_classdev *led_cdev,
 		return;
 	}
 
+	led_cdev->flags |= LED_BLINK_SW;
 	mod_timer(&led_cdev->blink_timer, jiffies + 1);
 }
 
@@ -219,6 +221,7 @@ void led_stop_software_blink(struct led_classdev *led_cdev)
 	del_timer_sync(&led_cdev->blink_timer);
 	led_cdev->blink_delay_on = 0;
 	led_cdev->blink_delay_off = 0;
+	led_cdev->flags &= ~LED_BLINK_SW;
 }
 EXPORT_SYMBOL_GPL(led_stop_software_blink);
 
@@ -226,10 +229,10 @@ void led_set_brightness(struct led_classdev *led_cdev,
 			enum led_brightness brightness)
 {
 	/*
-	 * In case blinking is on delay brightness setting
+	 * If software blink is active, delay brightness setting
 	 * until the next timer tick.
 	 */
-	if (led_cdev->blink_delay_on || led_cdev->blink_delay_off) {
+	if (led_cdev->flags & LED_BLINK_SW) {
 		/*
 		 * If we need to disable soft blinking delegate this to the
 		 * work queue task to avoid problems in case we are called

commit d4887af9c2b6ab550516f14106133a1e436c0712
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Tue Feb 16 20:21:56 2016 +0100

    leds: core: add helpers for calling brightness_set(_blocking)
    
    Add helpers for calling brightness_set(_blocking) allowing to
    simplify the code and make it better readable.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Jacek Anaszewski <j.anaszewski@samsung.com>

diff --git a/drivers/leds/led-core.c b/drivers/leds/led-core.c
index ad684b6d0b72..3495d5d6547f 100644
--- a/drivers/leds/led-core.c
+++ b/drivers/leds/led-core.c
@@ -25,6 +25,26 @@ EXPORT_SYMBOL_GPL(leds_list_lock);
 LIST_HEAD(leds_list);
 EXPORT_SYMBOL_GPL(leds_list);
 
+static int __led_set_brightness(struct led_classdev *led_cdev,
+				enum led_brightness value)
+{
+	if (!led_cdev->brightness_set)
+		return -ENOTSUPP;
+
+	led_cdev->brightness_set(led_cdev, value);
+
+	return 0;
+}
+
+static int __led_set_brightness_blocking(struct led_classdev *led_cdev,
+					 enum led_brightness value)
+{
+	if (!led_cdev->brightness_set_blocking)
+		return -ENOTSUPP;
+
+	return led_cdev->brightness_set_blocking(led_cdev, value);
+}
+
 static void led_timer_function(unsigned long data)
 {
 	struct led_classdev *led_cdev = (void *)data;
@@ -91,13 +111,10 @@ static void set_brightness_delayed(struct work_struct *ws)
 		led_cdev->flags &= ~LED_BLINK_DISABLE;
 	}
 
-	if (led_cdev->brightness_set)
-		led_cdev->brightness_set(led_cdev, led_cdev->delayed_set_value);
-	else if (led_cdev->brightness_set_blocking)
-		ret = led_cdev->brightness_set_blocking(led_cdev,
-						led_cdev->delayed_set_value);
-	else
-		ret = -ENOTSUPP;
+	ret = __led_set_brightness(led_cdev, led_cdev->delayed_set_value);
+	if (ret == -ENOTSUPP)
+		ret = __led_set_brightness_blocking(led_cdev,
+					led_cdev->delayed_set_value);
 	if (ret < 0 &&
 	    /* LED HW might have been unplugged, therefore don't warn */
 	    !(ret == -ENODEV && (led_cdev->flags & LED_UNREGISTERING) &&
@@ -236,10 +253,8 @@ void led_set_brightness_nopm(struct led_classdev *led_cdev,
 			      enum led_brightness value)
 {
 	/* Use brightness_set op if available, it is guaranteed not to sleep */
-	if (led_cdev->brightness_set) {
-		led_cdev->brightness_set(led_cdev, value);
+	if (!__led_set_brightness(led_cdev, value))
 		return;
-	}
 
 	/* If brightness setting can sleep, delegate it to a work queue task */
 	led_cdev->delayed_set_value = value;
@@ -270,10 +285,7 @@ int led_set_brightness_sync(struct led_classdev *led_cdev,
 	if (led_cdev->flags & LED_SUSPENDED)
 		return 0;
 
-	if (led_cdev->brightness_set_blocking)
-		return led_cdev->brightness_set_blocking(led_cdev,
-							 led_cdev->brightness);
-	return -ENOTSUPP;
+	return __led_set_brightness_blocking(led_cdev, led_cdev->brightness);
 }
 EXPORT_SYMBOL_GPL(led_set_brightness_sync);
 

commit d84d80f38f0ff4eb4becf1a3569c8e7b2c463b61
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Fri Jan 22 21:43:48 2016 +0100

    leds: core: avoid error message when a USB LED device is unplugged
    
    When a USB LED device is unplugged the remove call chain calls
    led_classdev_unregister which tries to switch the LED off.
    As the device has been removed already this results in a ENODEV
    error message in dmesg.
    Avoid this error message by ignoring ENODEV in calls from
    led_classdev_unregister if the LED device is flagged as pluggable.
    
    Therefore a new flag LED_HW_PLUGGABLE was introduced which should be set by
    all LED drivers handling pluggable LED devices (mainly USB LED devices).
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Jacek Anaszewski <j.anaszewski@samsung.com>

diff --git a/drivers/leds/led-core.c b/drivers/leds/led-core.c
index 19e1e60dfaa3..ad684b6d0b72 100644
--- a/drivers/leds/led-core.c
+++ b/drivers/leds/led-core.c
@@ -98,7 +98,10 @@ static void set_brightness_delayed(struct work_struct *ws)
 						led_cdev->delayed_set_value);
 	else
 		ret = -ENOTSUPP;
-	if (ret < 0)
+	if (ret < 0 &&
+	    /* LED HW might have been unplugged, therefore don't warn */
+	    !(ret == -ENODEV && (led_cdev->flags & LED_UNREGISTERING) &&
+	    (led_cdev->flags & LED_HW_PLUGGABLE)))
 		dev_err(led_cdev->dev,
 			"Setting an LED's brightness failed (%d)\n", ret);
 }

commit 13ae79bbe4c214047f51623304d83b46eb02897d
Author: Jacek Anaszewski <j.anaszewski@samsung.com>
Date:   Wed Oct 7 11:10:43 2015 +0200

    leds: core: Drivers shouldn't enforce SYNC/ASYNC brightness setting
    
    This patch removes SET_BRIGHTNESS_ASYNC and SET_BRIGHTNESS_SYNC flags.
    led_set_brightness() now calls led_set_brightness_nosleep() instead of
    choosing between sync and async op basing on the flags defined by the
    driver.
    
    From now on, if a user wants to make sure that brightness will be set
    synchronously, they have to use led_set_brightness_sync() API. It is now
    being made publicly available since it has become apparent that it is
    a caller who should decide whether brightness is to be set in
    a synchronous or an asynchronous way.
    
    Signed-off-by: Jacek Anaszewski <j.anaszewski@samsung.com>
    Acked-by: Sakari Ailus <sakari.ailus@linux.intel.com>

diff --git a/drivers/leds/led-core.c b/drivers/leds/led-core.c
index f57a96cb7b7d..19e1e60dfaa3 100644
--- a/drivers/leds/led-core.c
+++ b/drivers/leds/led-core.c
@@ -205,8 +205,6 @@ EXPORT_SYMBOL_GPL(led_stop_software_blink);
 void led_set_brightness(struct led_classdev *led_cdev,
 			enum led_brightness brightness)
 {
-	int ret = 0;
-
 	/*
 	 * In case blinking is on delay brightness setting
 	 * until the next timer tick.
@@ -227,17 +225,7 @@ void led_set_brightness(struct led_classdev *led_cdev,
 		return;
 	}
 
-	if (led_cdev->flags & SET_BRIGHTNESS_ASYNC) {
-		led_set_brightness_nosleep(led_cdev, brightness);
-		return;
-	} else if (led_cdev->flags & SET_BRIGHTNESS_SYNC)
-		ret = led_set_brightness_sync(led_cdev, brightness);
-	else
-		ret = -EINVAL;
-
-	if (ret < 0)
-		dev_dbg(led_cdev->dev, "Setting LED brightness failed (%d)\n",
-			ret);
+	led_set_brightness_nosleep(led_cdev, brightness);
 }
 EXPORT_SYMBOL_GPL(led_set_brightness);
 
@@ -268,6 +256,24 @@ void led_set_brightness_nosleep(struct led_classdev *led_cdev,
 }
 EXPORT_SYMBOL_GPL(led_set_brightness_nosleep);
 
+int led_set_brightness_sync(struct led_classdev *led_cdev,
+			    enum led_brightness value)
+{
+	if (led_cdev->blink_delay_on || led_cdev->blink_delay_off)
+		return -EBUSY;
+
+	led_cdev->brightness = min(value, led_cdev->max_brightness);
+
+	if (led_cdev->flags & LED_SUSPENDED)
+		return 0;
+
+	if (led_cdev->brightness_set_blocking)
+		return led_cdev->brightness_set_blocking(led_cdev,
+							 led_cdev->brightness);
+	return -ENOTSUPP;
+}
+EXPORT_SYMBOL_GPL(led_set_brightness_sync);
+
 int led_update_brightness(struct led_classdev *led_cdev)
 {
 	int ret = 0;

commit 1afcadfcd184c3b52e38bae15c247a5fa4a0e054
Author: Jacek Anaszewski <j.anaszewski@samsung.com>
Date:   Mon Oct 19 09:04:01 2015 +0200

    leds: core: Use set_brightness_work for the blocking op
    
    This patch makes LED core capable of setting brightness for drivers
    that implement brightness_set_blocking op. It removes from LED class
    drivers responsibility for using work queues on their own.
    
    In order to achieve this set_brightness_delayed callback is being
    modified to directly call one of available ops for brightness setting.
    
    led_set_brightness_async() function didn't set brightness in an
    asynchronous way in all cases. It was mistakenly assuming that all
    LED subsystem drivers used work queue in their brightness_set op,
    whereas only half of them did that. Since it has no users now,
    it is being removed.
    
    Signed-off-by: Jacek Anaszewski <j.anaszewski@samsung.com>
    Acked-by: Sakari Ailus <sakari.ailus@linux.intel.com>

diff --git a/drivers/leds/led-core.c b/drivers/leds/led-core.c
index 3d168592db65..f57a96cb7b7d 100644
--- a/drivers/leds/led-core.c
+++ b/drivers/leds/led-core.c
@@ -83,6 +83,7 @@ static void set_brightness_delayed(struct work_struct *ws)
 {
 	struct led_classdev *led_cdev =
 		container_of(ws, struct led_classdev, set_brightness_work);
+	int ret = 0;
 
 	if (led_cdev->flags & LED_BLINK_DISABLE) {
 		led_cdev->delayed_set_value = LED_OFF;
@@ -90,7 +91,16 @@ static void set_brightness_delayed(struct work_struct *ws)
 		led_cdev->flags &= ~LED_BLINK_DISABLE;
 	}
 
-	led_set_brightness_async(led_cdev, led_cdev->delayed_set_value);
+	if (led_cdev->brightness_set)
+		led_cdev->brightness_set(led_cdev, led_cdev->delayed_set_value);
+	else if (led_cdev->brightness_set_blocking)
+		ret = led_cdev->brightness_set_blocking(led_cdev,
+						led_cdev->delayed_set_value);
+	else
+		ret = -ENOTSUPP;
+	if (ret < 0)
+		dev_err(led_cdev->dev,
+			"Setting an LED's brightness failed (%d)\n", ret);
 }
 
 static void led_set_software_blink(struct led_classdev *led_cdev,

commit 81fe8e5b73e3f4de578ac7f53c1d956d4f58b8d4
Author: Jacek Anaszewski <j.anaszewski@samsung.com>
Date:   Wed Oct 7 11:10:41 2015 +0200

    leds: core: Add led_set_brightness_nosleep{nopm} functions
    
    This patch adds led_set_brightness_nosleep() and led_set_brightness_nopm()
    functions, that guarantee setting LED brightness in a non-blocking way.
    The latter is used from pm_ops context and doesn't modify the brightness
    cached in the struct led_classdev. Its execution always ends up with
    a call to brightness setting op - either directly or through
    a set_brightness_work, regardless of LED_SUSPENDED flag state.
    
    The patch also replaces led_set_brightness_async() with
    led_set_brightness_nosleep() in all places where the most vital was setting
    brightness in a non sleeping way but not necessarily asynchronously, which
    is not needed for non-blocking drivers.
    
    Signed-off-by: Jacek Anaszewski <j.anaszewski@samsung.com>
    Acked-by: Sakari Ailus <sakari.ailus@linux.intel.com>

diff --git a/drivers/leds/led-core.c b/drivers/leds/led-core.c
index 7cf59243e0ef..3d168592db65 100644
--- a/drivers/leds/led-core.c
+++ b/drivers/leds/led-core.c
@@ -32,7 +32,7 @@ static void led_timer_function(unsigned long data)
 	unsigned long delay;
 
 	if (!led_cdev->blink_delay_on || !led_cdev->blink_delay_off) {
-		led_set_brightness_async(led_cdev, LED_OFF);
+		led_set_brightness_nosleep(led_cdev, LED_OFF);
 		return;
 	}
 
@@ -60,7 +60,7 @@ static void led_timer_function(unsigned long data)
 		delay = led_cdev->blink_delay_off;
 	}
 
-	led_set_brightness_async(led_cdev, brightness);
+	led_set_brightness_nosleep(led_cdev, brightness);
 
 	/* Return in next iteration if led is in one-shot mode and we are in
 	 * the final blink state so that the led is toggled each delay_on +
@@ -110,13 +110,14 @@ static void led_set_software_blink(struct led_classdev *led_cdev,
 
 	/* never on - just set to off */
 	if (!delay_on) {
-		led_set_brightness_async(led_cdev, LED_OFF);
+		led_set_brightness_nosleep(led_cdev, LED_OFF);
 		return;
 	}
 
 	/* never off - just set to brightness */
 	if (!delay_off) {
-		led_set_brightness_async(led_cdev, led_cdev->blink_brightness);
+		led_set_brightness_nosleep(led_cdev,
+					   led_cdev->blink_brightness);
 		return;
 	}
 
@@ -217,7 +218,7 @@ void led_set_brightness(struct led_classdev *led_cdev,
 	}
 
 	if (led_cdev->flags & SET_BRIGHTNESS_ASYNC) {
-		led_set_brightness_async(led_cdev, brightness);
+		led_set_brightness_nosleep(led_cdev, brightness);
 		return;
 	} else if (led_cdev->flags & SET_BRIGHTNESS_SYNC)
 		ret = led_set_brightness_sync(led_cdev, brightness);
@@ -230,6 +231,33 @@ void led_set_brightness(struct led_classdev *led_cdev,
 }
 EXPORT_SYMBOL_GPL(led_set_brightness);
 
+void led_set_brightness_nopm(struct led_classdev *led_cdev,
+			      enum led_brightness value)
+{
+	/* Use brightness_set op if available, it is guaranteed not to sleep */
+	if (led_cdev->brightness_set) {
+		led_cdev->brightness_set(led_cdev, value);
+		return;
+	}
+
+	/* If brightness setting can sleep, delegate it to a work queue task */
+	led_cdev->delayed_set_value = value;
+	schedule_work(&led_cdev->set_brightness_work);
+}
+EXPORT_SYMBOL_GPL(led_set_brightness_nopm);
+
+void led_set_brightness_nosleep(struct led_classdev *led_cdev,
+				enum led_brightness value)
+{
+	led_cdev->brightness = min(value, led_cdev->max_brightness);
+
+	if (led_cdev->flags & LED_SUSPENDED)
+		return;
+
+	led_set_brightness_nopm(led_cdev, led_cdev->brightness);
+}
+EXPORT_SYMBOL_GPL(led_set_brightness_nosleep);
+
 int led_update_brightness(struct led_classdev *led_cdev)
 {
 	int ret = 0;

commit f1e80c07416adacc9ba1d9c5a4635c27b571f0df
Author: Jacek Anaszewski <j.anaszewski@samsung.com>
Date:   Wed Oct 7 11:10:39 2015 +0200

    leds: core: Add two new LED_BLINK_ flags
    
    This patch adds LED_BLINK_BRIGHTNESS_CHANGE flag to indicate that blink
    brightness has changed, and LED_BLINK_DISABLE flag to indicate that
    blinking deactivation has been requested. In order to use the flags
    led_timer_function and set_brightness_delayed callbacks as well as
    led_set_brightness() function are being modified. The main goal of these
    modifications is to prepare set_brightness_work for extension of the
    scope of its responsibilities.
    
    Signed-off-by: Jacek Anaszewski <j.anaszewski@samsung.com>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Acked-by: Sakari Ailus <sakari.ailus@linux.intel.com>

diff --git a/drivers/leds/led-core.c b/drivers/leds/led-core.c
index ee9309e2ca82..7cf59243e0ef 100644
--- a/drivers/leds/led-core.c
+++ b/drivers/leds/led-core.c
@@ -44,18 +44,18 @@ static void led_timer_function(unsigned long data)
 	brightness = led_get_brightness(led_cdev);
 	if (!brightness) {
 		/* Time to switch the LED on. */
-		if (led_cdev->delayed_set_value) {
-			led_cdev->blink_brightness =
-					led_cdev->delayed_set_value;
-			led_cdev->delayed_set_value = 0;
-		}
 		brightness = led_cdev->blink_brightness;
 		delay = led_cdev->blink_delay_on;
 	} else {
 		/* Store the current brightness value to be able
 		 * to restore it when the delay_off period is over.
+		 * Do it only if there is no pending blink brightness
+		 * change, to avoid overwriting the new value.
 		 */
-		led_cdev->blink_brightness = brightness;
+		if (!(led_cdev->flags & LED_BLINK_BRIGHTNESS_CHANGE))
+			led_cdev->blink_brightness = brightness;
+		else
+			led_cdev->flags &= ~LED_BLINK_BRIGHTNESS_CHANGE;
 		brightness = LED_OFF;
 		delay = led_cdev->blink_delay_off;
 	}
@@ -84,7 +84,11 @@ static void set_brightness_delayed(struct work_struct *ws)
 	struct led_classdev *led_cdev =
 		container_of(ws, struct led_classdev, set_brightness_work);
 
-	led_stop_software_blink(led_cdev);
+	if (led_cdev->flags & LED_BLINK_DISABLE) {
+		led_cdev->delayed_set_value = LED_OFF;
+		led_stop_software_blink(led_cdev);
+		led_cdev->flags &= ~LED_BLINK_DISABLE;
+	}
 
 	led_set_brightness_async(led_cdev, led_cdev->delayed_set_value);
 }
@@ -192,11 +196,23 @@ void led_set_brightness(struct led_classdev *led_cdev,
 {
 	int ret = 0;
 
-	/* delay brightness if soft-blink is active */
+	/*
+	 * In case blinking is on delay brightness setting
+	 * until the next timer tick.
+	 */
 	if (led_cdev->blink_delay_on || led_cdev->blink_delay_off) {
-		led_cdev->delayed_set_value = brightness;
-		if (brightness == LED_OFF)
+		/*
+		 * If we need to disable soft blinking delegate this to the
+		 * work queue task to avoid problems in case we are called
+		 * from hard irq context.
+		 */
+		if (brightness == LED_OFF) {
+			led_cdev->flags |= LED_BLINK_DISABLE;
 			schedule_work(&led_cdev->set_brightness_work);
+		} else {
+			led_cdev->flags |= LED_BLINK_BRIGHTNESS_CHANGE;
+			led_cdev->blink_brightness = brightness;
+		}
 		return;
 	}
 

commit 2806e2ff489975eb40eb5b363a689716e78fd116
Author: Jacek Anaszewski <j.anaszewski@samsung.com>
Date:   Mon Sep 28 15:07:10 2015 +0200

    leds: core: Use EXPORT_SYMBOL_GPL consistently
    
    LED core has a mixture of EXPORT_SYMBOL and EXPORT_SYMBOL_GPL macros.
    This patch fixes this discrepancy and switches to using EXPORT_SYMBOL_GPL
    for each exported function.
    
    Signed-off-by: Jacek Anaszewski <j.anaszewski@samsung.com>
    Acked-by: Pavel Machek <pavel@ucw.cz>

diff --git a/drivers/leds/led-core.c b/drivers/leds/led-core.c
index c1c3af089634..ee9309e2ca82 100644
--- a/drivers/leds/led-core.c
+++ b/drivers/leds/led-core.c
@@ -156,7 +156,7 @@ void led_blink_set(struct led_classdev *led_cdev,
 
 	led_blink_setup(led_cdev, delay_on, delay_off);
 }
-EXPORT_SYMBOL(led_blink_set);
+EXPORT_SYMBOL_GPL(led_blink_set);
 
 void led_blink_set_oneshot(struct led_classdev *led_cdev,
 			   unsigned long *delay_on,
@@ -177,7 +177,7 @@ void led_blink_set_oneshot(struct led_classdev *led_cdev,
 
 	led_blink_setup(led_cdev, delay_on, delay_off);
 }
-EXPORT_SYMBOL(led_blink_set_oneshot);
+EXPORT_SYMBOL_GPL(led_blink_set_oneshot);
 
 void led_stop_software_blink(struct led_classdev *led_cdev)
 {
@@ -212,7 +212,7 @@ void led_set_brightness(struct led_classdev *led_cdev,
 		dev_dbg(led_cdev->dev, "Setting LED brightness failed (%d)\n",
 			ret);
 }
-EXPORT_SYMBOL(led_set_brightness);
+EXPORT_SYMBOL_GPL(led_set_brightness);
 
 int led_update_brightness(struct led_classdev *led_cdev)
 {
@@ -228,7 +228,7 @@ int led_update_brightness(struct led_classdev *led_cdev)
 
 	return ret;
 }
-EXPORT_SYMBOL(led_update_brightness);
+EXPORT_SYMBOL_GPL(led_update_brightness);
 
 /* Caller must ensure led_cdev->led_access held */
 void led_sysfs_disable(struct led_classdev *led_cdev)

commit 757b06ae04b3b6c8958ab067e879a8865d076d2a
Author: Jacek Anaszewski <j.anaszewski@samsung.com>
Date:   Mon Sep 28 14:38:04 2015 +0200

    leds: core: Move LED core callbacks out of led-class.c
    
    Since the API for controlling LED brightness and blinking is defined in
    the LED core, move the related timer and work callbacks to the led-core.c,
    and initialize them through a new led_core_init API.
    
    Signed-off-by: Jacek Anaszewski <j.anaszewski@samsung.com>
    Acked-by: Andrew Lunn <andrew@lunn.ch>
    Acked-by: Pavel Machek <pavel@ucw.cz>

diff --git a/drivers/leds/led-core.c b/drivers/leds/led-core.c
index 549de7e24cfd..c1c3af089634 100644
--- a/drivers/leds/led-core.c
+++ b/drivers/leds/led-core.c
@@ -25,6 +25,70 @@ EXPORT_SYMBOL_GPL(leds_list_lock);
 LIST_HEAD(leds_list);
 EXPORT_SYMBOL_GPL(leds_list);
 
+static void led_timer_function(unsigned long data)
+{
+	struct led_classdev *led_cdev = (void *)data;
+	unsigned long brightness;
+	unsigned long delay;
+
+	if (!led_cdev->blink_delay_on || !led_cdev->blink_delay_off) {
+		led_set_brightness_async(led_cdev, LED_OFF);
+		return;
+	}
+
+	if (led_cdev->flags & LED_BLINK_ONESHOT_STOP) {
+		led_cdev->flags &= ~LED_BLINK_ONESHOT_STOP;
+		return;
+	}
+
+	brightness = led_get_brightness(led_cdev);
+	if (!brightness) {
+		/* Time to switch the LED on. */
+		if (led_cdev->delayed_set_value) {
+			led_cdev->blink_brightness =
+					led_cdev->delayed_set_value;
+			led_cdev->delayed_set_value = 0;
+		}
+		brightness = led_cdev->blink_brightness;
+		delay = led_cdev->blink_delay_on;
+	} else {
+		/* Store the current brightness value to be able
+		 * to restore it when the delay_off period is over.
+		 */
+		led_cdev->blink_brightness = brightness;
+		brightness = LED_OFF;
+		delay = led_cdev->blink_delay_off;
+	}
+
+	led_set_brightness_async(led_cdev, brightness);
+
+	/* Return in next iteration if led is in one-shot mode and we are in
+	 * the final blink state so that the led is toggled each delay_on +
+	 * delay_off milliseconds in worst case.
+	 */
+	if (led_cdev->flags & LED_BLINK_ONESHOT) {
+		if (led_cdev->flags & LED_BLINK_INVERT) {
+			if (brightness)
+				led_cdev->flags |= LED_BLINK_ONESHOT_STOP;
+		} else {
+			if (!brightness)
+				led_cdev->flags |= LED_BLINK_ONESHOT_STOP;
+		}
+	}
+
+	mod_timer(&led_cdev->blink_timer, jiffies + msecs_to_jiffies(delay));
+}
+
+static void set_brightness_delayed(struct work_struct *ws)
+{
+	struct led_classdev *led_cdev =
+		container_of(ws, struct led_classdev, set_brightness_work);
+
+	led_stop_software_blink(led_cdev);
+
+	led_set_brightness_async(led_cdev, led_cdev->delayed_set_value);
+}
+
 static void led_set_software_blink(struct led_classdev *led_cdev,
 				   unsigned long delay_on,
 				   unsigned long delay_off)
@@ -72,6 +136,15 @@ static void led_blink_setup(struct led_classdev *led_cdev,
 	led_set_software_blink(led_cdev, *delay_on, *delay_off);
 }
 
+void led_init_core(struct led_classdev *led_cdev)
+{
+	INIT_WORK(&led_cdev->set_brightness_work, set_brightness_delayed);
+
+	setup_timer(&led_cdev->blink_timer, led_timer_function,
+		    (unsigned long)led_cdev);
+}
+EXPORT_SYMBOL_GPL(led_init_core);
+
 void led_blink_set(struct led_classdev *led_cdev,
 		   unsigned long *delay_on,
 		   unsigned long *delay_off)

commit 76931edd54f87d1e49536cd068df4783fae24d45
Author: Stas Sergeev <stsp@list.ru>
Date:   Thu May 14 08:24:02 2015 -0700

    leds: fix brightness changing when software blinking is active
    
    The following sequence:
    echo timer >/sys/class/leds/<name>/trigger
    echo 1 >/sys/class/leds/<name>/brightness
    should change the ON brightness for blinking.
    The function led_set_brightness() was mistakenly initiating the
    delayed blink stop procedure, which resulted in no blinking with
    the timer trigger still active.
    
    This patch fixes the problem by changing led_set_brightness()
    to not initiate the delayed blink stop when brightness is not 0.
    
    CC: Richard Purdie <rpurdie@rpsys.net>
    CC: Kyungmin Park <kyungmin.park@samsung.com>
    CC: linux-leds@vger.kernel.org
    CC: linux-kernel@vger.kernel.org
    
    Acked-by: Jacek Anaszewski <j.anaszewski@samsung.com>
    Signed-off-by: Stas Sergeev <stsp@users.sourceforge.net>
    Signed-off-by: Bryan Wu <cooloney@gmail.com>

diff --git a/drivers/leds/led-core.c b/drivers/leds/led-core.c
index 9886dace5ad2..549de7e24cfd 100644
--- a/drivers/leds/led-core.c
+++ b/drivers/leds/led-core.c
@@ -119,10 +119,11 @@ void led_set_brightness(struct led_classdev *led_cdev,
 {
 	int ret = 0;
 
-	/* delay brightness setting if need to stop soft-blink timer */
+	/* delay brightness if soft-blink is active */
 	if (led_cdev->blink_delay_on || led_cdev->blink_delay_off) {
 		led_cdev->delayed_set_value = brightness;
-		schedule_work(&led_cdev->set_brightness_work);
+		if (brightness == LED_OFF)
+			schedule_work(&led_cdev->set_brightness_work);
 		return;
 	}
 

commit 4d71a4a12b130ad033219e6f58c74a64059415eb
Author: Jacek Anaszewski <j.anaszewski@samsung.com>
Date:   Fri Nov 14 02:50:18 2014 -0800

    leds: Add support for setting brightness in a synchronous way
    
    There are use cases when setting a LED brightness has to
    have immediate effect (e.g. setting a torch LED brightness).
    This patch extends LED subsystem to support such operations.
    The LED subsystem internal API __led_set_brightness is changed
    to led_set_brightness_async and new led_set_brightness_sync API
    is added.
    
    Signed-off-by: Jacek Anaszewski <j.anaszewski@samsung.com>
    Acked-by: Kyungmin Park <kyungmin.park@samsung.com>
    Cc: Richard Purdie <rpurdie@rpsys.net>
    Signed-off-by: Bryan Wu <cooloney@gmail.com>

diff --git a/drivers/leds/led-core.c b/drivers/leds/led-core.c
index be6d9fa5e971..9886dace5ad2 100644
--- a/drivers/leds/led-core.c
+++ b/drivers/leds/led-core.c
@@ -42,13 +42,13 @@ static void led_set_software_blink(struct led_classdev *led_cdev,
 
 	/* never on - just set to off */
 	if (!delay_on) {
-		__led_set_brightness(led_cdev, LED_OFF);
+		led_set_brightness_async(led_cdev, LED_OFF);
 		return;
 	}
 
 	/* never off - just set to brightness */
 	if (!delay_off) {
-		__led_set_brightness(led_cdev, led_cdev->blink_brightness);
+		led_set_brightness_async(led_cdev, led_cdev->blink_brightness);
 		return;
 	}
 
@@ -117,6 +117,8 @@ EXPORT_SYMBOL_GPL(led_stop_software_blink);
 void led_set_brightness(struct led_classdev *led_cdev,
 			enum led_brightness brightness)
 {
+	int ret = 0;
+
 	/* delay brightness setting if need to stop soft-blink timer */
 	if (led_cdev->blink_delay_on || led_cdev->blink_delay_off) {
 		led_cdev->delayed_set_value = brightness;
@@ -124,7 +126,17 @@ void led_set_brightness(struct led_classdev *led_cdev,
 		return;
 	}
 
-	__led_set_brightness(led_cdev, brightness);
+	if (led_cdev->flags & SET_BRIGHTNESS_ASYNC) {
+		led_set_brightness_async(led_cdev, brightness);
+		return;
+	} else if (led_cdev->flags & SET_BRIGHTNESS_SYNC)
+		ret = led_set_brightness_sync(led_cdev, brightness);
+	else
+		ret = -EINVAL;
+
+	if (ret < 0)
+		dev_dbg(led_cdev->dev, "Setting LED brightness failed (%d)\n",
+			ret);
 }
 EXPORT_SYMBOL(led_set_brightness);
 

commit acd899e4f3066b6662f6047da5b795cc762093cb
Author: Jacek Anaszewski <j.anaszewski@samsung.com>
Date:   Mon Sep 22 08:21:04 2014 -0700

    leds: implement sysfs interface locking mechanism
    
    Add a mechanism for locking LED subsystem sysfs interface.
    This patch prepares ground for addition of LED Flash Class
    extension, whose API will be integrated with V4L2 Flash API.
    Such a fusion enforces introducing a locking scheme, which
    will secure consistent access to the LED Flash Class device.
    
    The mechanism being introduced allows for disabling LED
    subsystem sysfs interface by calling led_sysfs_disable function
    and enabling it by calling led_sysfs_enable. The functions
    alter the LED_SYSFS_DISABLE flag state and must be called
    under mutex lock. The state of the lock is checked with use
    of led_sysfs_is_disabled function. Such a design allows for
    providing immediate feedback to the user space on whether
    the LED Flash Class device is available or is under V4L2 Flash
    sub-device control.
    
    Signed-off-by: Jacek Anaszewski <j.anaszewski@samsung.com>
    Acked-by: Kyungmin Park <kyungmin.park@samsung.com>
    Cc: Richard Purdie <rpurdie@rpsys.net>
    Signed-off-by: Bryan Wu <cooloney@gmail.com>

diff --git a/drivers/leds/led-core.c b/drivers/leds/led-core.c
index aaa8eba9099f..be6d9fa5e971 100644
--- a/drivers/leds/led-core.c
+++ b/drivers/leds/led-core.c
@@ -143,3 +143,21 @@ int led_update_brightness(struct led_classdev *led_cdev)
 	return ret;
 }
 EXPORT_SYMBOL(led_update_brightness);
+
+/* Caller must ensure led_cdev->led_access held */
+void led_sysfs_disable(struct led_classdev *led_cdev)
+{
+	lockdep_assert_held(&led_cdev->led_access);
+
+	led_cdev->flags |= LED_SYSFS_DISABLE;
+}
+EXPORT_SYMBOL_GPL(led_sysfs_disable);
+
+/* Caller must ensure led_cdev->led_access held */
+void led_sysfs_enable(struct led_classdev *led_cdev)
+{
+	lockdep_assert_held(&led_cdev->led_access);
+
+	led_cdev->flags &= ~LED_SYSFS_DISABLE;
+}
+EXPORT_SYMBOL_GPL(led_sysfs_enable);

commit 3ef7de5304edf60d0b8674dd7cdacc104e15a93c
Author: Jacek Anaszewski <j.anaszewski@samsung.com>
Date:   Wed Aug 20 06:41:55 2014 -0700

    leds: Improve and export led_update_brightness
    
    led_update_brightness helper function used to be exploited only locally
    in the led-class.c module, where its result was being passed to the
    brightness_show sysfs callback. With the introduction of v4l2-flash
    subdevice the same functionality becomes required for reading current
    brightness from a LED device. This patch adds checking of return value
    of the brightness_get callback and moves the led_update_brightness()
    function to the LED subsystem public API.
    
    Signed-off-by: Jacek Anaszewski <j.anaszewski@samsung.com>
    Acked-by: Kyungmin Park <kyungmin.park@samsung.com>
    Cc: Richard Purdie <rpurdie@rpsys.net>
    Signed-off-by: Bryan Wu <cooloney@gmail.com>

diff --git a/drivers/leds/led-core.c b/drivers/leds/led-core.c
index 50b579ad948e..aaa8eba9099f 100644
--- a/drivers/leds/led-core.c
+++ b/drivers/leds/led-core.c
@@ -127,3 +127,19 @@ void led_set_brightness(struct led_classdev *led_cdev,
 	__led_set_brightness(led_cdev, brightness);
 }
 EXPORT_SYMBOL(led_set_brightness);
+
+int led_update_brightness(struct led_classdev *led_cdev)
+{
+	int ret = 0;
+
+	if (led_cdev->brightness_get) {
+		ret = led_cdev->brightness_get(led_cdev);
+		if (ret >= 0) {
+			led_cdev->brightness = ret;
+			return 0;
+		}
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL(led_update_brightness);

commit 047133066e6c2549403fe5a2d619f47ba4212ef5
Author: Jacek Anaszewski <j.anaszewski@samsung.com>
Date:   Thu Aug 7 05:10:22 2014 -0700

    leds: Reorder include directives
    
    Reorder include directives so that they are arranged
    in alphabetical order.
    
    Signed-off-by: Jacek Anaszewski <j.anaszewski@samsung.com>
    Acked-by: Kyungmin Park <kyungmin.park@samsung.com>
    Cc: Richard Purdie <rpurdie@rpsys.net>
    Signed-off-by: Bryan Wu <cooloney@gmail.com>

diff --git a/drivers/leds/led-core.c b/drivers/leds/led-core.c
index 71b40d3bf776..50b579ad948e 100644
--- a/drivers/leds/led-core.c
+++ b/drivers/leds/led-core.c
@@ -12,10 +12,11 @@
  */
 
 #include <linux/kernel.h>
+#include <linux/leds.h>
 #include <linux/list.h>
 #include <linux/module.h>
+#include <linux/mutex.h>
 #include <linux/rwsem.h>
-#include <linux/leds.h>
 #include "leds.h"
 
 DECLARE_RWSEM(leds_list_lock);

commit 9067359faf890b3a18ab38c792d458fba77b32b4
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Tue Sep 2 02:03:12 2014 -0700

    Revert "leds: convert blink timer to workqueue"
    
    This reverts commit 8b37e1bef5a6b60e949e28a4db3006e4b00bd758.
    
    It's broken as it changes led_blink_set() in a way that it can now sleep
    (while synchronously waiting for workqueue to be cancelled). That's a
    problem, because it's possible that this function gets called from atomic
    context (tpt_trig_timer() takes a readlock and thus disables preemption).
    
    This has been brought up 3 weeks ago already [1] but no proper fix has
    materialized, and I keep seeing the problem since 3.17-rc1.
    
    [1] https://lkml.org/lkml/2014/8/16/128
    
     BUG: sleeping function called from invalid context at kernel/workqueue.c:2650
     in_atomic(): 1, irqs_disabled(): 0, pid: 2335, name: wpa_supplicant
     5 locks held by wpa_supplicant/2335:
      #0:  (rtnl_mutex){+.+.+.}, at: [<ffffffff814c7c92>] rtnl_lock+0x12/0x20
      #1:  (&wdev->mtx){+.+.+.}, at: [<ffffffffc06e649c>] cfg80211_mgd_wext_siwessid+0x5c/0x180 [cfg80211]
      #2:  (&local->mtx){+.+.+.}, at: [<ffffffffc0817dea>] ieee80211_prep_connection+0x17a/0x9a0 [mac80211]
      #3:  (&local->chanctx_mtx){+.+.+.}, at: [<ffffffffc08081ed>] ieee80211_vif_use_channel+0x5d/0x2a0 [mac80211]
      #4:  (&trig->leddev_list_lock){.+.+..}, at: [<ffffffffc081e68c>] tpt_trig_timer+0xec/0x170 [mac80211]
     CPU: 0 PID: 2335 Comm: wpa_supplicant Not tainted 3.17.0-rc3 #1
     Hardware name: LENOVO 7470BN2/7470BN2, BIOS 6DET38WW (2.02 ) 12/19/2008
      ffff8800360b5a50 ffff8800751f76d8 ffffffff8159e97f ffff8800360b5a30
      ffff8800751f76e8 ffffffff810739a5 ffff8800751f77b0 ffffffff8106862f
      ffffffff810685d0 0aa2209200000000 ffff880000000004 ffff8800361c59d0
     Call Trace:
      [<ffffffff8159e97f>] dump_stack+0x4d/0x66
      [<ffffffff810739a5>] __might_sleep+0xe5/0x120
      [<ffffffff8106862f>] flush_work+0x5f/0x270
      [<ffffffff810685d0>] ? mod_delayed_work_on+0x80/0x80
      [<ffffffff810945ca>] ? mark_held_locks+0x6a/0x90
      [<ffffffff81068a5f>] ? __cancel_work_timer+0x6f/0x100
      [<ffffffff810946ed>] ? trace_hardirqs_on_caller+0xfd/0x1c0
      [<ffffffff81068a6b>] __cancel_work_timer+0x7b/0x100
      [<ffffffff81068b0e>] cancel_delayed_work_sync+0xe/0x10
      [<ffffffff8147cf3b>] led_blink_set+0x1b/0x40
      [<ffffffffc081e6b0>] tpt_trig_timer+0x110/0x170 [mac80211]
      [<ffffffffc081ecdd>] ieee80211_mod_tpt_led_trig+0x9d/0x160 [mac80211]
      [<ffffffffc07e4278>] __ieee80211_recalc_idle+0x98/0x140 [mac80211]
      [<ffffffffc07e59ce>] ieee80211_idle_off+0xe/0x10 [mac80211]
      [<ffffffffc0804e5b>] ieee80211_add_chanctx+0x3b/0x220 [mac80211]
      [<ffffffffc08062e4>] ieee80211_new_chanctx+0x44/0xf0 [mac80211]
      [<ffffffffc080838a>] ieee80211_vif_use_channel+0x1fa/0x2a0 [mac80211]
      [<ffffffffc0817df8>] ieee80211_prep_connection+0x188/0x9a0 [mac80211]
      [<ffffffffc081c246>] ieee80211_mgd_auth+0x256/0x2e0 [mac80211]
      [<ffffffffc07eab33>] ieee80211_auth+0x13/0x20 [mac80211]
      [<ffffffffc06cb006>] cfg80211_mlme_auth+0x106/0x270 [cfg80211]
      [<ffffffffc06ce085>] cfg80211_conn_do_work+0x155/0x3b0 [cfg80211]
      [<ffffffffc06cf670>] cfg80211_connect+0x3f0/0x540 [cfg80211]
      [<ffffffffc06e6148>] cfg80211_mgd_wext_connect+0x158/0x1f0 [cfg80211]
      [<ffffffffc06e651e>] cfg80211_mgd_wext_siwessid+0xde/0x180 [cfg80211]
      [<ffffffffc06e36c0>] ? cfg80211_wext_giwessid+0x50/0x50 [cfg80211]
      [<ffffffffc06e36dd>] cfg80211_wext_siwessid+0x1d/0x40 [cfg80211]
      [<ffffffff81584d0c>] ioctl_standard_iw_point+0x14c/0x3e0
      [<ffffffff810946ed>] ? trace_hardirqs_on_caller+0xfd/0x1c0
      [<ffffffff8158502a>] ioctl_standard_call+0x8a/0xd0
      [<ffffffff81584fa0>] ? ioctl_standard_iw_point+0x3e0/0x3e0
      [<ffffffff81584b76>] wireless_process_ioctl.constprop.10+0xb6/0x100
      [<ffffffff8158521d>] wext_handle_ioctl+0x5d/0xb0
      [<ffffffff814cfb29>] dev_ioctl+0x329/0x620
      [<ffffffff810946ed>] ? trace_hardirqs_on_caller+0xfd/0x1c0
      [<ffffffff8149c7f2>] sock_ioctl+0x142/0x2e0
      [<ffffffff811b0140>] do_vfs_ioctl+0x300/0x520
      [<ffffffff815a67fb>] ? sysret_check+0x1b/0x56
      [<ffffffff810946ed>] ? trace_hardirqs_on_caller+0xfd/0x1c0
      [<ffffffff811b03e1>] SyS_ioctl+0x81/0xa0
      [<ffffffff815a67d6>] system_call_fastpath+0x1a/0x1f
     wlan0: send auth to 00:0b:6b:3c:8c:e4 (try 1/3)
     wlan0: authenticated
     wlan0: associate with 00:0b:6b:3c:8c:e4 (try 1/3)
     wlan0: RX AssocResp from 00:0b:6b:3c:8c:e4 (capab=0x431 status=0 aid=2)
     wlan0: associated
     IPv6: ADDRCONF(NETDEV_CHANGE): wlan0: link becomes ready
     cfg80211: Calling CRDA for country: NA
     wlan0: Limiting TX power to 27 (27 - 0) dBm as advertised by 00:0b:6b:3c:8c:e4
    
     =================================
     [ INFO: inconsistent lock state ]
     3.17.0-rc3 #1 Not tainted
     ---------------------------------
     inconsistent {SOFTIRQ-ON-W} -> {IN-SOFTIRQ-W} usage.
     swapper/0/0 [HC0[0]:SC1[1]:HE1:SE0] takes:
      ((&(&led_cdev->blink_work)->work)){+.?...}, at: [<ffffffff810685d0>] flush_work+0x0/0x270
     {SOFTIRQ-ON-W} state was registered at:
       [<ffffffff81094dbe>] __lock_acquire+0x30e/0x1a30
       [<ffffffff81096c81>] lock_acquire+0x91/0x110
       [<ffffffff81068608>] flush_work+0x38/0x270
       [<ffffffff81068a6b>] __cancel_work_timer+0x7b/0x100
       [<ffffffff81068b0e>] cancel_delayed_work_sync+0xe/0x10
       [<ffffffff8147cf3b>] led_blink_set+0x1b/0x40
       [<ffffffffc081e6b0>] tpt_trig_timer+0x110/0x170 [mac80211]
       [<ffffffffc081ecdd>] ieee80211_mod_tpt_led_trig+0x9d/0x160 [mac80211]
       [<ffffffffc07e4278>] __ieee80211_recalc_idle+0x98/0x140 [mac80211]
       [<ffffffffc07e59ce>] ieee80211_idle_off+0xe/0x10 [mac80211]
       [<ffffffffc0804e5b>] ieee80211_add_chanctx+0x3b/0x220 [mac80211]
       [<ffffffffc08062e4>] ieee80211_new_chanctx+0x44/0xf0 [mac80211]
       [<ffffffffc080838a>] ieee80211_vif_use_channel+0x1fa/0x2a0 [mac80211]
       [<ffffffffc0817df8>] ieee80211_prep_connection+0x188/0x9a0 [mac80211]
       [<ffffffffc081c246>] ieee80211_mgd_auth+0x256/0x2e0 [mac80211]
       [<ffffffffc07eab33>] ieee80211_auth+0x13/0x20 [mac80211]
       [<ffffffffc06cb006>] cfg80211_mlme_auth+0x106/0x270 [cfg80211]
       [<ffffffffc06ce085>] cfg80211_conn_do_work+0x155/0x3b0 [cfg80211]
       [<ffffffffc06cf670>] cfg80211_connect+0x3f0/0x540 [cfg80211]
       [<ffffffffc06e6148>] cfg80211_mgd_wext_connect+0x158/0x1f0 [cfg80211]
       [<ffffffffc06e651e>] cfg80211_mgd_wext_siwessid+0xde/0x180 [cfg80211]
       [<ffffffffc06e36dd>] cfg80211_wext_siwessid+0x1d/0x40 [cfg80211]
       [<ffffffff81584d0c>] ioctl_standard_iw_point+0x14c/0x3e0
       [<ffffffff8158502a>] ioctl_standard_call+0x8a/0xd0
       [<ffffffff81584b76>] wireless_process_ioctl.constprop.10+0xb6/0x100
       [<ffffffff8158521d>] wext_handle_ioctl+0x5d/0xb0
       [<ffffffff814cfb29>] dev_ioctl+0x329/0x620
       [<ffffffff8149c7f2>] sock_ioctl+0x142/0x2e0
       [<ffffffff811b0140>] do_vfs_ioctl+0x300/0x520
       [<ffffffff811b03e1>] SyS_ioctl+0x81/0xa0
       [<ffffffff815a67d6>] system_call_fastpath+0x1a/0x1f
     irq event stamp: 493416
     hardirqs last  enabled at (493416): [<ffffffff81068a5f>] __cancel_work_timer+0x6f/0x100
     hardirqs last disabled at (493415): [<ffffffff81067e9f>] try_to_grab_pending+0x1f/0x160
     softirqs last  enabled at (493408): [<ffffffff81053ced>] _local_bh_enable+0x1d/0x50
     softirqs last disabled at (493409): [<ffffffff81054c75>] irq_exit+0xa5/0xb0
    
     other info that might help us debug this:
      Possible unsafe locking scenario:
    
            CPU0
            ----
       lock((&(&led_cdev->blink_work)->work));
       <Interrupt>
         lock((&(&led_cdev->blink_work)->work));
    
      *** DEADLOCK ***
    
     2 locks held by swapper/0/0:
      #0:  (((&tpt_trig->timer))){+.-...}, at: [<ffffffff810b4c50>] call_timer_fn+0x0/0x180
      #1:  (&trig->leddev_list_lock){.+.?..}, at: [<ffffffffc081e68c>] tpt_trig_timer+0xec/0x170 [mac80211]
    
     stack backtrace:
     CPU: 0 PID: 0 Comm: swapper/0 Not tainted 3.17.0-rc3 #1
     Hardware name: LENOVO 7470BN2/7470BN2, BIOS 6DET38WW (2.02 ) 12/19/2008
      ffffffff8246eb30 ffff88007c203b00 ffffffff8159e97f ffffffff81a194c0
      ffff88007c203b50 ffffffff81599c29 0000000000000001 ffffffff00000001
      ffff880000000000 0000000000000006 ffffffff81a194c0 ffffffff81093ad0
     Call Trace:
      <IRQ>  [<ffffffff8159e97f>] dump_stack+0x4d/0x66
      [<ffffffff81599c29>] print_usage_bug+0x1f4/0x205
      [<ffffffff81093ad0>] ? check_usage_backwards+0x140/0x140
      [<ffffffff810944d3>] mark_lock+0x223/0x2b0
      [<ffffffff81094d60>] __lock_acquire+0x2b0/0x1a30
      [<ffffffff81096c81>] lock_acquire+0x91/0x110
      [<ffffffff810685d0>] ? mod_delayed_work_on+0x80/0x80
      [<ffffffffc081e5a0>] ? __ieee80211_get_rx_led_name+0x10/0x10 [mac80211]
      [<ffffffff81068608>] flush_work+0x38/0x270
      [<ffffffff810685d0>] ? mod_delayed_work_on+0x80/0x80
      [<ffffffff810945ca>] ? mark_held_locks+0x6a/0x90
      [<ffffffff81068a5f>] ? __cancel_work_timer+0x6f/0x100
      [<ffffffffc081e5a0>] ? __ieee80211_get_rx_led_name+0x10/0x10 [mac80211]
      [<ffffffff8109469d>] ? trace_hardirqs_on_caller+0xad/0x1c0
      [<ffffffffc081e5a0>] ? __ieee80211_get_rx_led_name+0x10/0x10 [mac80211]
      [<ffffffff81068a6b>] __cancel_work_timer+0x7b/0x100
      [<ffffffff81068b0e>] cancel_delayed_work_sync+0xe/0x10
      [<ffffffff8147cf3b>] led_blink_set+0x1b/0x40
      [<ffffffffc081e6b0>] tpt_trig_timer+0x110/0x170 [mac80211]
      [<ffffffff810b4cc5>] call_timer_fn+0x75/0x180
      [<ffffffff810b4c50>] ? process_timeout+0x10/0x10
      [<ffffffffc081e5a0>] ? __ieee80211_get_rx_led_name+0x10/0x10 [mac80211]
      [<ffffffff810b50ac>] run_timer_softirq+0x1fc/0x2f0
      [<ffffffff81054805>] __do_softirq+0x115/0x2e0
      [<ffffffff81054c75>] irq_exit+0xa5/0xb0
      [<ffffffff810049b3>] do_IRQ+0x53/0xf0
      [<ffffffff815a74af>] common_interrupt+0x6f/0x6f
      <EOI>  [<ffffffff8147b56e>] ? cpuidle_enter_state+0x6e/0x180
      [<ffffffff8147b732>] cpuidle_enter+0x12/0x20
      [<ffffffff8108bba0>] cpu_startup_entry+0x330/0x360
      [<ffffffff8158fb51>] rest_init+0xc1/0xd0
      [<ffffffff8158fa90>] ? csum_partial_copy_generic+0x170/0x170
      [<ffffffff81af3ff2>] start_kernel+0x44f/0x45a
      [<ffffffff81af399c>] ? set_init_arg+0x53/0x53
      [<ffffffff81af35ad>] x86_64_start_reservations+0x2a/0x2c
      [<ffffffff81af36a0>] x86_64_start_kernel+0xf1/0xf4
    
    Cc: Vincent Donnefort <vdonnefort@gmail.com>
    Cc: Hugh Dickins <hughd@google.com>
    Cc: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>
    Signed-off-by: Bryan Wu <cooloney@gmail.com>

diff --git a/drivers/leds/led-core.c b/drivers/leds/led-core.c
index 4bb116867b88..71b40d3bf776 100644
--- a/drivers/leds/led-core.c
+++ b/drivers/leds/led-core.c
@@ -16,7 +16,6 @@
 #include <linux/module.h>
 #include <linux/rwsem.h>
 #include <linux/leds.h>
-#include <linux/workqueue.h>
 #include "leds.h"
 
 DECLARE_RWSEM(leds_list_lock);
@@ -52,7 +51,7 @@ static void led_set_software_blink(struct led_classdev *led_cdev,
 		return;
 	}
 
-	queue_delayed_work(system_wq, &led_cdev->blink_work, 1);
+	mod_timer(&led_cdev->blink_timer, jiffies + 1);
 }
 
 
@@ -76,7 +75,7 @@ void led_blink_set(struct led_classdev *led_cdev,
 		   unsigned long *delay_on,
 		   unsigned long *delay_off)
 {
-	cancel_delayed_work_sync(&led_cdev->blink_work);
+	del_timer_sync(&led_cdev->blink_timer);
 
 	led_cdev->flags &= ~LED_BLINK_ONESHOT;
 	led_cdev->flags &= ~LED_BLINK_ONESHOT_STOP;
@@ -91,7 +90,7 @@ void led_blink_set_oneshot(struct led_classdev *led_cdev,
 			   int invert)
 {
 	if ((led_cdev->flags & LED_BLINK_ONESHOT) &&
-	     delayed_work_pending(&led_cdev->blink_work))
+	     timer_pending(&led_cdev->blink_timer))
 		return;
 
 	led_cdev->flags |= LED_BLINK_ONESHOT;
@@ -108,7 +107,7 @@ EXPORT_SYMBOL(led_blink_set_oneshot);
 
 void led_stop_software_blink(struct led_classdev *led_cdev)
 {
-	cancel_delayed_work_sync(&led_cdev->blink_work);
+	del_timer_sync(&led_cdev->blink_timer);
 	led_cdev->blink_delay_on = 0;
 	led_cdev->blink_delay_off = 0;
 }
@@ -117,7 +116,7 @@ EXPORT_SYMBOL_GPL(led_stop_software_blink);
 void led_set_brightness(struct led_classdev *led_cdev,
 			enum led_brightness brightness)
 {
-	/* delay brightness setting if need to stop soft-blink work */
+	/* delay brightness setting if need to stop soft-blink timer */
 	if (led_cdev->blink_delay_on || led_cdev->blink_delay_off) {
 		led_cdev->delayed_set_value = brightness;
 		schedule_work(&led_cdev->set_brightness_work);

commit 8b37e1bef5a6b60e949e28a4db3006e4b00bd758
Author: Vincent Donnefort <vdonnefort@gmail.com>
Date:   Sat Jun 14 02:21:40 2014 -0700

    leds: convert blink timer to workqueue
    
    This patch converts the blink timer from led-core to workqueue which is more
    suitable for this kind of non-priority operations. Moreover, timer may lead to
    errors when a LED setting function use a scheduling function such as pinctrl
    which is using mutex.
    
    Signed-off-by: Vincent Donnefort <vdonnefort@gmail.com>
    Signed-off-by: Bryan Wu <cooloney@gmail.com>

diff --git a/drivers/leds/led-core.c b/drivers/leds/led-core.c
index 71b40d3bf776..4bb116867b88 100644
--- a/drivers/leds/led-core.c
+++ b/drivers/leds/led-core.c
@@ -16,6 +16,7 @@
 #include <linux/module.h>
 #include <linux/rwsem.h>
 #include <linux/leds.h>
+#include <linux/workqueue.h>
 #include "leds.h"
 
 DECLARE_RWSEM(leds_list_lock);
@@ -51,7 +52,7 @@ static void led_set_software_blink(struct led_classdev *led_cdev,
 		return;
 	}
 
-	mod_timer(&led_cdev->blink_timer, jiffies + 1);
+	queue_delayed_work(system_wq, &led_cdev->blink_work, 1);
 }
 
 
@@ -75,7 +76,7 @@ void led_blink_set(struct led_classdev *led_cdev,
 		   unsigned long *delay_on,
 		   unsigned long *delay_off)
 {
-	del_timer_sync(&led_cdev->blink_timer);
+	cancel_delayed_work_sync(&led_cdev->blink_work);
 
 	led_cdev->flags &= ~LED_BLINK_ONESHOT;
 	led_cdev->flags &= ~LED_BLINK_ONESHOT_STOP;
@@ -90,7 +91,7 @@ void led_blink_set_oneshot(struct led_classdev *led_cdev,
 			   int invert)
 {
 	if ((led_cdev->flags & LED_BLINK_ONESHOT) &&
-	     timer_pending(&led_cdev->blink_timer))
+	     delayed_work_pending(&led_cdev->blink_work))
 		return;
 
 	led_cdev->flags |= LED_BLINK_ONESHOT;
@@ -107,7 +108,7 @@ EXPORT_SYMBOL(led_blink_set_oneshot);
 
 void led_stop_software_blink(struct led_classdev *led_cdev)
 {
-	del_timer_sync(&led_cdev->blink_timer);
+	cancel_delayed_work_sync(&led_cdev->blink_work);
 	led_cdev->blink_delay_on = 0;
 	led_cdev->blink_delay_off = 0;
 }
@@ -116,7 +117,7 @@ EXPORT_SYMBOL_GPL(led_stop_software_blink);
 void led_set_brightness(struct led_classdev *led_cdev,
 			enum led_brightness brightness)
 {
-	/* delay brightness setting if need to stop soft-blink timer */
+	/* delay brightness setting if need to stop soft-blink work */
 	if (led_cdev->blink_delay_on || led_cdev->blink_delay_off) {
 		led_cdev->delayed_set_value = brightness;
 		schedule_work(&led_cdev->set_brightness_work);

commit 8d82fef8bbee588d071372eb02439d2053b4bfe4
Author: Stefan Sørensen <stefan.sorensen@spectralink.com>
Date:   Tue Feb 4 00:11:42 2014 -0800

    leds: Turn off led if blinking is disabled
    
    When using the timer trigger and setting delay_on to 0, the led
    will stay in whatever state is was in, while intuitively one
    would expect it to turn off. This patch changes the behaviour to
    turn it off.
    
    Signed-off-by: Stefan Sørensen <stefan.sorensen@spectralink.com>
    Signed-off-by: Bryan Wu <cooloney@gmail.com>

diff --git a/drivers/leds/led-core.c b/drivers/leds/led-core.c
index ce8921a753a3..71b40d3bf776 100644
--- a/drivers/leds/led-core.c
+++ b/drivers/leds/led-core.c
@@ -39,9 +39,11 @@ static void led_set_software_blink(struct led_classdev *led_cdev,
 	led_cdev->blink_delay_on = delay_on;
 	led_cdev->blink_delay_off = delay_off;
 
-	/* never on - don't blink */
-	if (!delay_on)
+	/* never on - just set to off */
+	if (!delay_on) {
+		__led_set_brightness(led_cdev, LED_OFF);
 		return;
+	}
 
 	/* never off - just set to brightness */
 	if (!delay_off) {

commit d23a22a74fded23a12434c9463fe66cec2b0afcd
Author: Fabio Baltieri <fabio.baltieri@gmail.com>
Date:   Wed Aug 15 21:44:34 2012 +0800

    leds: delay led_set_brightness if stopping soft-blink
    
    Delay execution of led_set_brightness() if need to stop soft-blink
    timer.
    
    This allows led_set_brightness to be called in hard-irq context even if
    soft-blink was activated on that LED.
    
    Signed-off-by: Fabio Baltieri <fabio.baltieri@gmail.com>
    Cc: Pawel Moll <pawel.moll@arm.com>
    Signed-off-by: Bryan Wu <bryan.wu@canonical.com>

diff --git a/drivers/leds/led-core.c b/drivers/leds/led-core.c
index 2ab05af3de31..ce8921a753a3 100644
--- a/drivers/leds/led-core.c
+++ b/drivers/leds/led-core.c
@@ -103,13 +103,23 @@ void led_blink_set_oneshot(struct led_classdev *led_cdev,
 }
 EXPORT_SYMBOL(led_blink_set_oneshot);
 
-void led_set_brightness(struct led_classdev *led_cdev,
-			enum led_brightness brightness)
+void led_stop_software_blink(struct led_classdev *led_cdev)
 {
-	/* stop and clear soft-blink timer */
 	del_timer_sync(&led_cdev->blink_timer);
 	led_cdev->blink_delay_on = 0;
 	led_cdev->blink_delay_off = 0;
+}
+EXPORT_SYMBOL_GPL(led_stop_software_blink);
+
+void led_set_brightness(struct led_classdev *led_cdev,
+			enum led_brightness brightness)
+{
+	/* delay brightness setting if need to stop soft-blink timer */
+	if (led_cdev->blink_delay_on || led_cdev->blink_delay_off) {
+		led_cdev->delayed_set_value = brightness;
+		schedule_work(&led_cdev->set_brightness_work);
+		return;
+	}
 
 	__led_set_brightness(led_cdev, brightness);
 }

commit 20c0e6b8787c5289202f688b6be78dff4568c1df
Author: Bryan Wu <bryan.wu@canonical.com>
Date:   Fri Jun 15 22:15:27 2012 +0800

    leds: fix sparse warnings due to missing static
    
    drivers/leds/led-core.c:56:6: sparse: symbol 'led_blink_setup' was not declared. Should it be static?
    drivers/leds/led-triggers.c:233:6: sparse: symbol 'led_trigger_blink_setup' was not declared. Should it be static?
    
    Reported-by: Fengguang Wu <wfg@linux.intel.com>
    Signed-off-by: Bryan Wu <bryan.wu@canonical.com>

diff --git a/drivers/leds/led-core.c b/drivers/leds/led-core.c
index 8a09c5fc2a6d..2ab05af3de31 100644
--- a/drivers/leds/led-core.c
+++ b/drivers/leds/led-core.c
@@ -53,7 +53,7 @@ static void led_set_software_blink(struct led_classdev *led_cdev,
 }
 
 
-void led_blink_setup(struct led_classdev *led_cdev,
+static void led_blink_setup(struct led_classdev *led_cdev,
 		     unsigned long *delay_on,
 		     unsigned long *delay_off)
 {

commit 19cd67e2d51225b164560b54b85f943e07deee8a
Author: Shuah Khan <shuahkhan@gmail.com>
Date:   Thu Jun 14 04:34:30 2012 +0800

    leds: Rename led_brightness_set() to led_set_brightness()
    
    Rename leds external interface led_brightness_set() to led_set_brightness().
    This is the second phase of the change to reduce confusion between the
    leds internal and external interfaces that set brightness. With this change,
    now the external interface is led_set_brightness(). The first phase renamed
    the internal interface led_set_brightness() to __led_set_brightness().
    There are no changes to the interface implementations.
    
    Signed-off-by: Shuah Khan <shuahkhan@gmail.com>
    Signed-off-by: Bryan Wu <bryan.wu@canonical.com>

diff --git a/drivers/leds/led-core.c b/drivers/leds/led-core.c
index 176961b2db6b..8a09c5fc2a6d 100644
--- a/drivers/leds/led-core.c
+++ b/drivers/leds/led-core.c
@@ -103,7 +103,7 @@ void led_blink_set_oneshot(struct led_classdev *led_cdev,
 }
 EXPORT_SYMBOL(led_blink_set_oneshot);
 
-void led_brightness_set(struct led_classdev *led_cdev,
+void led_set_brightness(struct led_classdev *led_cdev,
 			enum led_brightness brightness)
 {
 	/* stop and clear soft-blink timer */
@@ -113,4 +113,4 @@ void led_brightness_set(struct led_classdev *led_cdev,
 
 	__led_set_brightness(led_cdev, brightness);
 }
-EXPORT_SYMBOL(led_brightness_set);
+EXPORT_SYMBOL(led_set_brightness);

commit 0da3e65ba892b8c63d55fa5ec197b6fae55f75f8
Author: Shuah Khan <shuahkhan@gmail.com>
Date:   Wed Jun 13 10:01:37 2012 +0800

    leds: Rename led_set_brightness() to __led_set_brightness()
    
    Rename leds internal interface led_set_brightness() to __led_set_brightness()
    to reduce confusion between led_set_brightness() and the external interface
    led_brightness_set(). led_brightness_set() cancels the timer and then calls
    led_set_brightness().
    
    Signed-off-by: Shuah Khan <shuahkhan@gmail.com>
    Signed-off-by: Bryan Wu <bryan.wu@canonical.com>

diff --git a/drivers/leds/led-core.c b/drivers/leds/led-core.c
index 31f1f78ef40b..176961b2db6b 100644
--- a/drivers/leds/led-core.c
+++ b/drivers/leds/led-core.c
@@ -45,7 +45,7 @@ static void led_set_software_blink(struct led_classdev *led_cdev,
 
 	/* never off - just set to brightness */
 	if (!delay_off) {
-		led_set_brightness(led_cdev, led_cdev->blink_brightness);
+		__led_set_brightness(led_cdev, led_cdev->blink_brightness);
 		return;
 	}
 
@@ -111,6 +111,6 @@ void led_brightness_set(struct led_classdev *led_cdev,
 	led_cdev->blink_delay_on = 0;
 	led_cdev->blink_delay_off = 0;
 
-	led_set_brightness(led_cdev, brightness);
+	__led_set_brightness(led_cdev, brightness);
 }
 EXPORT_SYMBOL(led_brightness_set);

commit 437864828d82b9dee50b5741106fbf5fa12b139a
Author: Fabio Baltieri <fabio.baltieri@gmail.com>
Date:   Thu Jun 7 03:12:34 2012 +0800

    leds: fix led_brightness_set when soft-blinking
    
    Move led_stop_software_blink() code into led_brightness_set() to ensure
    software blink timer is stopped and cleared when changing trigger.
    
    Also use led_set_brightness() instead of calling
    led_cdev->brightness_set() directly to keep led_cdev->brightness
    consistent with current LED status.
    
    This ensure proper cleaning when changing triggers, as without this fix
    a LED may be turned off while leaving it's led_cdev->brightness = 1,
    leading to an erratic software-blink behaviour.
    
    The problem was easy to reproduce by changing the trigger from "timer"
    to "oneshot".
    
    Signed-off-by: Fabio Baltieri <fabio.baltieri@gmail.com>
    Signed-off-by: Bryan Wu <bryan.wu@canonical.com>

diff --git a/drivers/leds/led-core.c b/drivers/leds/led-core.c
index a6f4d910ca08..31f1f78ef40b 100644
--- a/drivers/leds/led-core.c
+++ b/drivers/leds/led-core.c
@@ -24,13 +24,6 @@ EXPORT_SYMBOL_GPL(leds_list_lock);
 LIST_HEAD(leds_list);
 EXPORT_SYMBOL_GPL(leds_list);
 
-static void led_stop_software_blink(struct led_classdev *led_cdev)
-{
-	/* deactivate previous settings */
-	led_cdev->blink_delay_on = 0;
-	led_cdev->blink_delay_off = 0;
-}
-
 static void led_set_software_blink(struct led_classdev *led_cdev,
 				   unsigned long delay_on,
 				   unsigned long delay_off)
@@ -113,7 +106,11 @@ EXPORT_SYMBOL(led_blink_set_oneshot);
 void led_brightness_set(struct led_classdev *led_cdev,
 			enum led_brightness brightness)
 {
-	led_stop_software_blink(led_cdev);
-	led_cdev->brightness_set(led_cdev, brightness);
+	/* stop and clear soft-blink timer */
+	del_timer_sync(&led_cdev->blink_timer);
+	led_cdev->blink_delay_on = 0;
+	led_cdev->blink_delay_off = 0;
+
+	led_set_brightness(led_cdev, brightness);
 }
 EXPORT_SYMBOL(led_brightness_set);

commit 5bb629c504394f4d42c53a25d75ccb02a393f92f
Author: Fabio Baltieri <fabio.baltieri@gmail.com>
Date:   Sun May 27 07:19:22 2012 +0800

    leds: add oneshot blink functions
    
    Add two new functions, led_blink_set_oneshot and
    led_trigger_blink_oneshot, to be used by triggers for one-shot blink of
    led devices.
    
    This is implemented extending the existing software-blink code, and uses
    the same timer and handler function.
    
    The behavior of the code is to do a blink-on, blink-off sequence when
    the function is called, ignoring other calls until the sequence is
    completed so that the leds keep blinking at constant rate if the
    functions are called repeatedly.
    
    This is meant to be used by drivers which needs to trigger on sporadic
    event, but doesn't have clear busy/idle trigger points.
    
    After the blink sequence the led remains off. This behavior can be
    inverted setting the "invert" argument, which blink the led off, than on
    and leave the led on after the sequence.
    
    (bryan.wu@canonical.com: rebase to commit 'leds: don't disable blinking
    when writing the same value to delay_on or delay_off')
    
    Signed-off-by: Fabio Baltieri <fabio.baltieri@gmail.com>
    Acked-by: Shuah Khan <shuahkhan@gmail.com>
    Signed-off-by: Bryan Wu <bryan.wu@canonical.com>

diff --git a/drivers/leds/led-core.c b/drivers/leds/led-core.c
index d65353d8d3fc..a6f4d910ca08 100644
--- a/drivers/leds/led-core.c
+++ b/drivers/leds/led-core.c
@@ -27,7 +27,6 @@ EXPORT_SYMBOL_GPL(leds_list);
 static void led_stop_software_blink(struct led_classdev *led_cdev)
 {
 	/* deactivate previous settings */
-	del_timer_sync(&led_cdev->blink_timer);
 	led_cdev->blink_delay_on = 0;
 	led_cdev->blink_delay_off = 0;
 }
@@ -61,13 +60,12 @@ static void led_set_software_blink(struct led_classdev *led_cdev,
 }
 
 
-void led_blink_set(struct led_classdev *led_cdev,
-		   unsigned long *delay_on,
-		   unsigned long *delay_off)
+void led_blink_setup(struct led_classdev *led_cdev,
+		     unsigned long *delay_on,
+		     unsigned long *delay_off)
 {
-	del_timer_sync(&led_cdev->blink_timer);
-
-	if (led_cdev->blink_set &&
+	if (!(led_cdev->flags & LED_BLINK_ONESHOT) &&
+	    led_cdev->blink_set &&
 	    !led_cdev->blink_set(led_cdev, delay_on, delay_off))
 		return;
 
@@ -77,8 +75,41 @@ void led_blink_set(struct led_classdev *led_cdev,
 
 	led_set_software_blink(led_cdev, *delay_on, *delay_off);
 }
+
+void led_blink_set(struct led_classdev *led_cdev,
+		   unsigned long *delay_on,
+		   unsigned long *delay_off)
+{
+	del_timer_sync(&led_cdev->blink_timer);
+
+	led_cdev->flags &= ~LED_BLINK_ONESHOT;
+	led_cdev->flags &= ~LED_BLINK_ONESHOT_STOP;
+
+	led_blink_setup(led_cdev, delay_on, delay_off);
+}
 EXPORT_SYMBOL(led_blink_set);
 
+void led_blink_set_oneshot(struct led_classdev *led_cdev,
+			   unsigned long *delay_on,
+			   unsigned long *delay_off,
+			   int invert)
+{
+	if ((led_cdev->flags & LED_BLINK_ONESHOT) &&
+	     timer_pending(&led_cdev->blink_timer))
+		return;
+
+	led_cdev->flags |= LED_BLINK_ONESHOT;
+	led_cdev->flags &= ~LED_BLINK_ONESHOT_STOP;
+
+	if (invert)
+		led_cdev->flags |= LED_BLINK_INVERT;
+	else
+		led_cdev->flags &= ~LED_BLINK_INVERT;
+
+	led_blink_setup(led_cdev, delay_on, delay_off);
+}
+EXPORT_SYMBOL(led_blink_set_oneshot);
+
 void led_brightness_set(struct led_classdev *led_cdev,
 			enum led_brightness brightness)
 {

commit 3fbd8716da4c69ddbb76c022f3f4a0d50723c68f
Author: Rafal Prylowski <prylowski@metasoft.pl>
Date:   Mon May 28 23:35:54 2012 +0800

    leds: don't disable blinking when writing the same value to delay_on or delay_off
    
    Function led_set_software_blink() assumes that blink timer is still running,
    but commit 488bc35bf40df89d37486c1826b178a2fba36ce7 introduced disabling
    of blink timer before each call to led_set_software_blink().
    
    Correct led_software_blink():
    1) remove protection against reprogramming blink timer to the same values,
       because it only disables blinking now,
    2) remove unnecessary call to led_stop_software_blink().
    
    Signed-off-by: Rafal Prylowski <prylowski@metasoft.pl>
    Cc: Richard Purdie <rpurdie@rpsys.net>
    Signed-off-by: Bryan Wu <bryan.wu@canonical.com>

diff --git a/drivers/leds/led-core.c b/drivers/leds/led-core.c
index d6860043f6f9..d65353d8d3fc 100644
--- a/drivers/leds/led-core.c
+++ b/drivers/leds/led-core.c
@@ -44,13 +44,6 @@ static void led_set_software_blink(struct led_classdev *led_cdev,
 	if (!led_cdev->blink_brightness)
 		led_cdev->blink_brightness = led_cdev->max_brightness;
 
-	if (led_get_trigger_data(led_cdev) &&
-	    delay_on == led_cdev->blink_delay_on &&
-	    delay_off == led_cdev->blink_delay_off)
-		return;
-
-	led_stop_software_blink(led_cdev);
-
 	led_cdev->blink_delay_on = delay_on;
 	led_cdev->blink_delay_off = delay_off;
 

commit a403d930c58eb8448f81fa90c125ac36dc8ef89d
Author: Bryan Wu <bryan.wu@canonical.com>
Date:   Fri Mar 23 15:02:14 2012 -0700

    led-class: change back LEDS_CLASS to tristate instead of bool
    
    After moving some core functions to led-core.c, led-class.c can be built
    as module again.
    
    Signed-off-by: Bryan Wu <bryan.wu@canonical.com>
    Acked-by: Richard Purdie <richard.purdie@linuxfoundation.org>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/leds/led-core.c b/drivers/leds/led-core.c
index 016d19f5486f..d6860043f6f9 100644
--- a/drivers/leds/led-core.c
+++ b/drivers/leds/led-core.c
@@ -23,3 +23,73 @@ EXPORT_SYMBOL_GPL(leds_list_lock);
 
 LIST_HEAD(leds_list);
 EXPORT_SYMBOL_GPL(leds_list);
+
+static void led_stop_software_blink(struct led_classdev *led_cdev)
+{
+	/* deactivate previous settings */
+	del_timer_sync(&led_cdev->blink_timer);
+	led_cdev->blink_delay_on = 0;
+	led_cdev->blink_delay_off = 0;
+}
+
+static void led_set_software_blink(struct led_classdev *led_cdev,
+				   unsigned long delay_on,
+				   unsigned long delay_off)
+{
+	int current_brightness;
+
+	current_brightness = led_get_brightness(led_cdev);
+	if (current_brightness)
+		led_cdev->blink_brightness = current_brightness;
+	if (!led_cdev->blink_brightness)
+		led_cdev->blink_brightness = led_cdev->max_brightness;
+
+	if (led_get_trigger_data(led_cdev) &&
+	    delay_on == led_cdev->blink_delay_on &&
+	    delay_off == led_cdev->blink_delay_off)
+		return;
+
+	led_stop_software_blink(led_cdev);
+
+	led_cdev->blink_delay_on = delay_on;
+	led_cdev->blink_delay_off = delay_off;
+
+	/* never on - don't blink */
+	if (!delay_on)
+		return;
+
+	/* never off - just set to brightness */
+	if (!delay_off) {
+		led_set_brightness(led_cdev, led_cdev->blink_brightness);
+		return;
+	}
+
+	mod_timer(&led_cdev->blink_timer, jiffies + 1);
+}
+
+
+void led_blink_set(struct led_classdev *led_cdev,
+		   unsigned long *delay_on,
+		   unsigned long *delay_off)
+{
+	del_timer_sync(&led_cdev->blink_timer);
+
+	if (led_cdev->blink_set &&
+	    !led_cdev->blink_set(led_cdev, delay_on, delay_off))
+		return;
+
+	/* blink with 1 Hz as default if nothing specified */
+	if (!*delay_on && !*delay_off)
+		*delay_on = *delay_off = 500;
+
+	led_set_software_blink(led_cdev, *delay_on, *delay_off);
+}
+EXPORT_SYMBOL(led_blink_set);
+
+void led_brightness_set(struct led_classdev *led_cdev,
+			enum led_brightness brightness)
+{
+	led_stop_software_blink(led_cdev);
+	led_cdev->brightness_set(led_cdev, brightness);
+}
+EXPORT_SYMBOL(led_brightness_set);

commit 4d404fd5c51772720e9c72aa3185bd5119bc6e69
Author: Németh Márton <nm127@freemail.hu>
Date:   Sun Mar 9 20:59:57 2008 +0000

    leds: Cleanup various whitespace and code style issues
    
    Break the lines which were more than 80 characters into more
    lines; replace SPACEs with TABs; correct ident at switch-case;
    change character encoding from ISO-8859-2 to UTF-8.
    
    The order of the functions in led-triggers.c changed in order
    the similar functions can still be together under titles
    "Used by LED Class", "LED Trigger Interface" and "Simple
    LED Tigger Interface" as was grouped before when exported
    with EXPORT_SYMBOL.
    
    Signed-off-by: Márton Németh <nm127@freemail.hu>
    Signed-off-by: Richard Purdie <rpurdie@rpsys.net>

diff --git a/drivers/leds/led-core.c b/drivers/leds/led-core.c
index 5d1ca10524b6..016d19f5486f 100644
--- a/drivers/leds/led-core.c
+++ b/drivers/leds/led-core.c
@@ -19,7 +19,7 @@
 #include "leds.h"
 
 DECLARE_RWSEM(leds_list_lock);
-LIST_HEAD(leds_list);
+EXPORT_SYMBOL_GPL(leds_list_lock);
 
+LIST_HEAD(leds_list);
 EXPORT_SYMBOL_GPL(leds_list);
-EXPORT_SYMBOL_GPL(leds_list_lock);

commit 72f8da329e07ad8a72c1f0e96b8955cfeb7c7329
Author: Richard Purdie <rpurdie@rpsys.net>
Date:   Mon Dec 31 23:09:44 2007 +0000

    leds: Fix leds_list_lock locking issues
    
    Covert leds_list_lock to a rw_sempahore to match previous LED trigger
    locking fixes, fixing lock ordering.
    
    Signed-off-by: Richard Purdie <rpurdie@rpsys.net>

diff --git a/drivers/leds/led-core.c b/drivers/leds/led-core.c
index 9b015f9af351..5d1ca10524b6 100644
--- a/drivers/leds/led-core.c
+++ b/drivers/leds/led-core.c
@@ -14,11 +14,11 @@
 #include <linux/kernel.h>
 #include <linux/list.h>
 #include <linux/module.h>
-#include <linux/spinlock.h>
+#include <linux/rwsem.h>
 #include <linux/leds.h>
 #include "leds.h"
 
-DEFINE_RWLOCK(leds_list_lock);
+DECLARE_RWSEM(leds_list_lock);
 LIST_HEAD(leds_list);
 
 EXPORT_SYMBOL_GPL(leds_list);

commit 34af946a22724c4e2b204957f2b24b22a0fb121c
Author: Ingo Molnar <mingo@elte.hu>
Date:   Tue Jun 27 02:53:55 2006 -0700

    [PATCH] spin/rwlock init cleanups
    
    locking init cleanups:
    
     - convert " = SPIN_LOCK_UNLOCKED" to spin_lock_init() or DEFINE_SPINLOCK()
     - convert rwlocks in a similar manner
    
    this patch was generated automatically.
    
    Motivation:
    
     - cleanliness
     - lockdep needs control of lock initialization, which the open-coded
       variants do not give
     - it's also useful for -rt and for lock debugging in general
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/leds/led-core.c b/drivers/leds/led-core.c
index fe6541326c71..9b015f9af351 100644
--- a/drivers/leds/led-core.c
+++ b/drivers/leds/led-core.c
@@ -18,7 +18,7 @@
 #include <linux/leds.h>
 #include "leds.h"
 
-rwlock_t leds_list_lock = RW_LOCK_UNLOCKED;
+DEFINE_RWLOCK(leds_list_lock);
 LIST_HEAD(leds_list);
 
 EXPORT_SYMBOL_GPL(leds_list);

commit c72a1d608dd0eb3d553a08bfdf1c0041bebaa8a0
Author: Richard Purdie <rpurdie@rpsys.net>
Date:   Fri Mar 31 02:31:04 2006 -0800

    [PATCH] LED: add LED class
    
    Add the foundations of a new LEDs subsystem.  This patch adds a class which
    presents LED devices within sysfs and allows their brightness to be
    controlled.
    
    Signed-off-by: Richard Purdie <rpurdie@rpsys.net>
    Cc: Russell King <rmk@arm.linux.org.uk>
    Cc: Greg KH <greg@kroah.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/leds/led-core.c b/drivers/leds/led-core.c
new file mode 100644
index 000000000000..fe6541326c71
--- /dev/null
+++ b/drivers/leds/led-core.c
@@ -0,0 +1,25 @@
+/*
+ * LED Class Core
+ *
+ * Copyright 2005-2006 Openedhand Ltd.
+ *
+ * Author: Richard Purdie <rpurdie@openedhand.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/spinlock.h>
+#include <linux/leds.h>
+#include "leds.h"
+
+rwlock_t leds_list_lock = RW_LOCK_UNLOCKED;
+LIST_HEAD(leds_list);
+
+EXPORT_SYMBOL_GPL(leds_list);
+EXPORT_SYMBOL_GPL(leds_list_lock);
