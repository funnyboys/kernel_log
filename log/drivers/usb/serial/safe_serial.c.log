commit 6ca98bc2843e0bc4c2745ff6be7d46694c1398d1
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Nov 3 12:40:56 2017 +0100

    USB: serial: Remove redundant license text
    
    Now that the SPDX tag is in all USB files, that identifies the license
    in a specific and legally-defined manner.  So the extra GPL text wording
    can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/safe_serial.c b/drivers/usb/serial/safe_serial.c
index 3dd85f025cbe..6accbecb6318 100644
--- a/drivers/usb/serial/safe_serial.c
+++ b/drivers/usb/serial/safe_serial.c
@@ -6,11 +6,6 @@
  *      Copyright (C) 2001 Lineo
  *      Copyright (C) 2001 Hewlett-Packard
  *
- *	This program is free software; you can redistribute it and/or modify
- *	it under the terms of the GNU General Public License as published by
- *	the Free Software Foundation; either version 2 of the License, or
- *	(at your option) any later version.
- *
  * By:
  *      Stuart Lynne <sl@lineo.com>, Tom Rushworth <tbr@lineo.com>
  */

commit 5fd54ace4721fc5ce2bb5aef6318fcf17f421460
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Nov 3 11:28:30 2017 +0100

    USB: add SPDX identifiers to all remaining files in drivers/usb/
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/usb/ and include/linux/usb* files with the correct
    SPDX license identifier based on the license text in the file itself.
    The SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Acked-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/safe_serial.c b/drivers/usb/serial/safe_serial.c
index 27d7a7016298..3dd85f025cbe 100644
--- a/drivers/usb/serial/safe_serial.c
+++ b/drivers/usb/serial/safe_serial.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  * Safe Encapsulated USB Serial Driver
  *

commit 4abf87f41a6cedf7a780af63991d6bebec303be0
Author: Joe Perches <joe@perches.com>
Date:   Wed Jul 12 14:37:40 2017 -0700

    USB: serial: safe_serial: move __inline__ before return type
    
    Make the code like the rest of the kernel.
    Also use inline instead of __inline__.
    
    Link: http://lkml.kernel.org/r/a5072b74b6c293e6ec93c4900482e9d3267f15b2.1499284835.git.joe@perches.com
    Signed-off-by: Joe Perches <joe@perches.com>
    Cc: Johan Hovold <johan@kernel.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/usb/serial/safe_serial.c b/drivers/usb/serial/safe_serial.c
index 8a069aa154ed..27d7a7016298 100644
--- a/drivers/usb/serial/safe_serial.c
+++ b/drivers/usb/serial/safe_serial.c
@@ -180,7 +180,7 @@ static const __u16 crc10_table[256] = {
  * Perform a memcpy and calculate fcs using ppp 10bit CRC algorithm. Return
  * new 10 bit FCS.
  */
-static __u16 __inline__ fcs_compute10(unsigned char *sp, int len, __u16 fcs)
+static inline __u16 fcs_compute10(unsigned char *sp, int len, __u16 fcs)
 {
 	for (; len-- > 0; fcs = CRC10_FCS(fcs, *sp++));
 	return fcs;

commit 8c76d7cd520ebffc1ea9ea0850d87a224a50c7f2
Author: Johan Hovold <johan@kernel.org>
Date:   Mon Mar 6 17:36:41 2017 +0100

    USB: serial: safe_serial: fix information leak in completion handler
    
    Add missing sanity check to the bulk-in completion handler to avoid an
    integer underflow that could be triggered by a malicious device.
    
    This avoids leaking up to 56 bytes from after the URB transfer buffer to
    user space.
    
    Fixes: 1da177e4c3f4 ("Linux-2.6.12-rc2")
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Johan Hovold <johan@kernel.org>

diff --git a/drivers/usb/serial/safe_serial.c b/drivers/usb/serial/safe_serial.c
index 93c6c9b08daa..8a069aa154ed 100644
--- a/drivers/usb/serial/safe_serial.c
+++ b/drivers/usb/serial/safe_serial.c
@@ -200,6 +200,11 @@ static void safe_process_read_urb(struct urb *urb)
 	if (!safe)
 		goto out;
 
+	if (length < 2) {
+		dev_err(&port->dev, "malformed packet\n");
+		return;
+	}
+
 	fcs = fcs_compute10(data, length, CRC10_INITFCS);
 	if (fcs) {
 		dev_err(&port->dev, "%s - bad CRC %x\n", __func__, fcs);

commit ce9d8562536f1289f7cb7afb1d4b2e0d27d2eb2c
Author: Mathieu OTHACEHE <m.othacehe@gmail.com>
Date:   Thu Feb 4 19:01:29 2016 +0100

    USB: serial: fix boolinit.cocci warnings
    
    Bool initializations should use true and false. Bool tests don't need
    comparisons.
    
    Also, use IS_ENABLED instead of ifdef.
    
    Generated by: scripts/coccinelle/misc/boolinit.cocci
    
    Signed-off-by: Mathieu OTHACEHE <m.othacehe@gmail.com>
    Signed-off-by: Johan Hovold <johan@kernel.org>

diff --git a/drivers/usb/serial/safe_serial.c b/drivers/usb/serial/safe_serial.c
index b2dff0f14743..93c6c9b08daa 100644
--- a/drivers/usb/serial/safe_serial.c
+++ b/drivers/usb/serial/safe_serial.c
@@ -76,13 +76,8 @@
 #include <linux/usb.h>
 #include <linux/usb/serial.h>
 
-
-#ifndef CONFIG_USB_SERIAL_SAFE_PADDED
-#define CONFIG_USB_SERIAL_SAFE_PADDED 0
-#endif
-
-static bool safe = 1;
-static bool padded = CONFIG_USB_SERIAL_SAFE_PADDED;
+static bool safe = true;
+static bool padded = IS_ENABLED(CONFIG_USB_SERIAL_SAFE_PADDED);
 
 #define DRIVER_AUTHOR "sl@lineo.com, tbr@lineo.com, Johan Hovold <jhovold@gmail.com>"
 #define DRIVER_DESC "USB Safe Encapsulated Serial"
@@ -278,7 +273,7 @@ static int safe_startup(struct usb_serial *serial)
 	case LINEO_SAFESERIAL_CRC:
 		break;
 	case LINEO_SAFESERIAL_CRC_PADDED:
-		padded = 1;
+		padded = true;
 		break;
 	default:
 		return -EINVAL;

commit 803a536243b3a1ed2289f41897b11b72bd083309
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Wed Jan 8 11:08:26 2014 -0500

    usb: delete non-required instances of include <linux/init.h>
    
    None of these files are actually using any __init type directives
    and hence don't need to include <linux/init.h>.  Most are just a
    left over from __devinit and __cpuinit removal, or simply due to
    code getting copied from one driver to the next.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/safe_serial.c b/drivers/usb/serial/safe_serial.c
index d0e602af3ba5..b2dff0f14743 100644
--- a/drivers/usb/serial/safe_serial.c
+++ b/drivers/usb/serial/safe_serial.c
@@ -67,7 +67,6 @@
 #include <linux/kernel.h>
 #include <linux/errno.h>
 #include <linux/gfp.h>
-#include <linux/init.h>
 #include <linux/tty.h>
 #include <linux/tty_driver.h>
 #include <linux/tty_flip.h>

commit 5c6b98dd0437ba8c1b515bf11357784335613d65
Author: Johan Hovold <jhovold@gmail.com>
Date:   Sun Dec 29 19:22:54 2013 +0100

    USB: serial: constify device-id tables
    
    Declare device-id tables as const where possible.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/safe_serial.c b/drivers/usb/serial/safe_serial.c
index ba895989d8c4..d0e602af3ba5 100644
--- a/drivers/usb/serial/safe_serial.c
+++ b/drivers/usb/serial/safe_serial.c
@@ -125,7 +125,7 @@ MODULE_PARM_DESC(padded, "Pad to full wMaxPacketSize On/Off");
 	.bInterfaceClass = (ic), \
 	.bInterfaceSubClass = (isc),
 
-static struct usb_device_id id_table[] = {
+static const struct usb_device_id id_table[] = {
 	{MY_USB_DEVICE(0x49f, 0xffff, CDC_DEVICE_CLASS, LINEO_INTERFACE_CLASS, LINEO_INTERFACE_SUBCLASS_SAFESERIAL)},	/* Itsy */
 	{MY_USB_DEVICE(0x3f0, 0x2101, CDC_DEVICE_CLASS, LINEO_INTERFACE_CLASS, LINEO_INTERFACE_SUBCLASS_SAFESERIAL)},	/* Calypso */
 	{MY_USB_DEVICE(0x4dd, 0x8001, CDC_DEVICE_CLASS, LINEO_INTERFACE_CLASS, LINEO_INTERFACE_SUBCLASS_SAFESERIAL)},	/* Iris */

commit 8b61d927beb2479ebff654aef686be4df2d84fc0
Author: Johan Hovold <jhovold@gmail.com>
Date:   Wed Jun 26 16:47:40 2013 +0200

    USB: safe_serial: remove vendor/product module parameters
    
    Remove the vendor and product module parameters which were added a long
    time ago when we did not have the dynamic sysfs interface to add
    new device ids (and which isn't limited to a single new vid/pid pair).
    
    A vid/pid pair can be added dynamically using sysfs, for example:
    
      echo 04dd 1234 >/sys/bus/usb-serial/drivers/safe_serial/new_id
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/safe_serial.c b/drivers/usb/serial/safe_serial.c
index 21cd7bf2a8cc..ba895989d8c4 100644
--- a/drivers/usb/serial/safe_serial.c
+++ b/drivers/usb/serial/safe_serial.c
@@ -92,13 +92,6 @@ MODULE_AUTHOR(DRIVER_AUTHOR);
 MODULE_DESCRIPTION(DRIVER_DESC);
 MODULE_LICENSE("GPL");
 
-static __u16 vendor;		/* no default */
-static __u16 product;		/* no default */
-module_param(vendor, ushort, 0);
-MODULE_PARM_DESC(vendor, "User specified USB idVendor (required)");
-module_param(product, ushort, 0);
-MODULE_PARM_DESC(product, "User specified USB idProduct (required)");
-
 module_param(safe, bool, 0);
 MODULE_PARM_DESC(safe, "Turn Safe Encapsulation On/Off");
 
@@ -140,8 +133,6 @@ static struct usb_device_id id_table[] = {
 	{MY_USB_DEVICE(0x4dd, 0x8003, CDC_DEVICE_CLASS, LINEO_INTERFACE_CLASS, LINEO_INTERFACE_SUBCLASS_SAFESERIAL)},	/* Collie */
 	{MY_USB_DEVICE(0x4dd, 0x8004, CDC_DEVICE_CLASS, LINEO_INTERFACE_CLASS, LINEO_INTERFACE_SUBCLASS_SAFESERIAL)},	/* Collie */
 	{MY_USB_DEVICE(0x5f9, 0xffff, CDC_DEVICE_CLASS, LINEO_INTERFACE_CLASS, LINEO_INTERFACE_SUBCLASS_SAFESERIAL)},	/* Sharp tmp */
-	/* extra null entry for module vendor/produc parameters */
-	{MY_USB_DEVICE(0, 0, CDC_DEVICE_CLASS, LINEO_INTERFACE_CLASS, LINEO_INTERFACE_SUBCLASS_SAFESERIAL)},
 	{}			/* terminating entry  */
 };
 
@@ -272,7 +263,19 @@ static int safe_prepare_write_buffer(struct usb_serial_port *port,
 
 static int safe_startup(struct usb_serial *serial)
 {
-	switch (serial->interface->cur_altsetting->desc.bInterfaceProtocol) {
+	struct usb_interface_descriptor	*desc;
+
+	if (serial->dev->descriptor.bDeviceClass != CDC_DEVICE_CLASS)
+		return -ENODEV;
+
+	desc = &serial->interface->cur_altsetting->desc;
+
+	if (desc->bInterfaceClass != LINEO_INTERFACE_CLASS)
+		return -ENODEV;
+	if (desc->bInterfaceSubClass != LINEO_INTERFACE_SUBCLASS_SAFESERIAL)
+		return -ENODEV;
+
+	switch (desc->bInterfaceProtocol) {
 	case LINEO_SAFESERIAL_CRC:
 		break;
 	case LINEO_SAFESERIAL_CRC_PADDED:
@@ -300,30 +303,4 @@ static struct usb_serial_driver * const serial_drivers[] = {
 	&safe_device, NULL
 };
 
-static int __init safe_init(void)
-{
-	int i;
-
-	/* if we have vendor / product parameters patch them into id list */
-	if (vendor || product) {
-		pr_info("vendor: %x product: %x\n", vendor, product);
-
-		for (i = 0; i < ARRAY_SIZE(id_table); i++) {
-			if (!id_table[i].idVendor && !id_table[i].idProduct) {
-				id_table[i].idVendor = vendor;
-				id_table[i].idProduct = product;
-				break;
-			}
-		}
-	}
-
-	return usb_serial_register_drivers(serial_drivers, KBUILD_MODNAME, id_table);
-}
-
-static void __exit safe_exit(void)
-{
-	usb_serial_deregister_drivers(serial_drivers);
-}
-
-module_init(safe_init);
-module_exit(safe_exit);
+module_usb_serial_driver(serial_drivers, id_table);

commit 2e124b4a390ca85325fae75764bef92f0547fa25
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Thu Jan 3 15:53:06 2013 +0100

    TTY: switch tty_flip_buffer_push
    
    Now, we start converting tty buffer functions to actually use
    tty_port. This will allow us to get rid of the need of tty in many
    call sites. Only tty_port will needed and hence no more
    tty_port_tty_get in those paths.
    
    Now, the one where most of tty_port_tty_get gets removed:
    tty_flip_buffer_push.
    
    IOW we also closed all the races in drivers not using tty_port_tty_get
    at all yet.
    
    Also we move tty_flip_buffer_push declaration from include/linux/tty.h
    to include/linux/tty_flip.h to all others while we are changing it
    anyway.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/safe_serial.c b/drivers/usb/serial/safe_serial.c
index ad12e9e2c7ee..21cd7bf2a8cc 100644
--- a/drivers/usb/serial/safe_serial.c
+++ b/drivers/usb/serial/safe_serial.c
@@ -207,38 +207,31 @@ static void safe_process_read_urb(struct urb *urb)
 	unsigned char *data = urb->transfer_buffer;
 	unsigned char length = urb->actual_length;
 	int actual_length;
-	struct tty_struct *tty;
 	__u16 fcs;
 
 	if (!length)
 		return;
 
-	tty = tty_port_tty_get(&port->port);
-	if (!tty)
-		return;
-
 	if (!safe)
 		goto out;
 
 	fcs = fcs_compute10(data, length, CRC10_INITFCS);
 	if (fcs) {
 		dev_err(&port->dev, "%s - bad CRC %x\n", __func__, fcs);
-		goto err;
+		return;
 	}
 
 	actual_length = data[length - 2] >> 2;
 	if (actual_length > (length - 2)) {
 		dev_err(&port->dev, "%s - inconsistent lengths %d:%d\n",
 				__func__, actual_length, length);
-		goto err;
+		return;
 	}
 	dev_info(&urb->dev->dev, "%s - actual: %d\n", __func__, actual_length);
 	length = actual_length;
 out:
 	tty_insert_flip_string(&port->port, data, length);
-	tty_flip_buffer_push(tty);
-err:
-	tty_kref_put(tty);
+	tty_flip_buffer_push(&port->port);
 }
 
 static int safe_prepare_write_buffer(struct usb_serial_port *port,

commit 05c7cd39907184328f48d3e7899f9cdd653ad336
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Thu Jan 3 15:53:04 2013 +0100

    TTY: switch tty_insert_flip_string
    
    Now, we start converting tty buffer functions to actually use
    tty_port. This will allow us to get rid of the need of tty in many
    call sites. Only tty_port will needed and hence no more
    tty_port_tty_get in those paths.
    
    tty_insert_flip_string this time.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/safe_serial.c b/drivers/usb/serial/safe_serial.c
index c949ce6ef0c6..ad12e9e2c7ee 100644
--- a/drivers/usb/serial/safe_serial.c
+++ b/drivers/usb/serial/safe_serial.c
@@ -235,7 +235,7 @@ static void safe_process_read_urb(struct urb *urb)
 	dev_info(&urb->dev->dev, "%s - actual: %d\n", __func__, actual_length);
 	length = actual_length;
 out:
-	tty_insert_flip_string(tty, data, length);
+	tty_insert_flip_string(&port->port, data, length);
 	tty_flip_buffer_push(tty);
 err:
 	tty_kref_put(tty);

commit 93ba0f037bfc7d6c6431c0db767f2244ac583578
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Sep 18 17:07:24 2012 +0100

    USB: serial: safe-serial: fix up printk() usage
    
    The driver was calling printk() directly at startup, which is just
    noise.  Switch over to using pr_info() where needed, and get rid of the
    totally useless version number that had never ever been incremented.
    
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Mauro Carvalho Chehab <mchehab@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/safe_serial.c b/drivers/usb/serial/safe_serial.c
index e3457e2d2c0d..c949ce6ef0c6 100644
--- a/drivers/usb/serial/safe_serial.c
+++ b/drivers/usb/serial/safe_serial.c
@@ -62,6 +62,7 @@
  *
  */
 
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
 
 #include <linux/kernel.h>
 #include <linux/errno.h>
@@ -84,7 +85,6 @@
 static bool safe = 1;
 static bool padded = CONFIG_USB_SERIAL_SAFE_PADDED;
 
-#define DRIVER_VERSION "v0.1"
 #define DRIVER_AUTHOR "sl@lineo.com, tbr@lineo.com, Johan Hovold <jhovold@gmail.com>"
 #define DRIVER_DESC "USB Safe Encapsulated Serial"
 
@@ -311,13 +311,9 @@ static int __init safe_init(void)
 {
 	int i;
 
-	printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
-	       DRIVER_DESC "\n");
-
 	/* if we have vendor / product parameters patch them into id list */
 	if (vendor || product) {
-		printk(KERN_INFO KBUILD_MODNAME ": vendor: %x product: %x\n",
-		       vendor, product);
+		pr_info("vendor: %x product: %x\n", vendor, product);
 
 		for (i = 0; i < ARRAY_SIZE(id_table); i++) {
 			if (!id_table[i].idVendor && !id_table[i].idProduct) {

commit 40c9616bdd4abf319860195361abd7387710b3aa
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Sep 14 12:31:55 2012 -0700

    USB: serial: safe_serial.c: remove debug module parameter
    
    Now that the dbg() macro is no longer being used in the driver,
    the debug module parameter doesn't do anything at all.  So remove
    it so as to not confuse people.
    
    CC: Rusty Russell <rusty@rustcorp.com.au>
    CC: Alan Stern <stern@rowland.harvard.edu>
    CC: Mauro Carvalho Chehab <mchehab@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/safe_serial.c b/drivers/usb/serial/safe_serial.c
index 36e9d9fc0618..e3457e2d2c0d 100644
--- a/drivers/usb/serial/safe_serial.c
+++ b/drivers/usb/serial/safe_serial.c
@@ -81,7 +81,6 @@
 #define CONFIG_USB_SERIAL_SAFE_PADDED 0
 #endif
 
-static bool debug;
 static bool safe = 1;
 static bool padded = CONFIG_USB_SERIAL_SAFE_PADDED;
 
@@ -100,9 +99,6 @@ MODULE_PARM_DESC(vendor, "User specified USB idVendor (required)");
 module_param(product, ushort, 0);
 MODULE_PARM_DESC(product, "User specified USB idProduct (required)");
 
-module_param(debug, bool, S_IRUGO | S_IWUSR);
-MODULE_PARM_DESC(debug, "Debug enabled or not");
-
 module_param(safe, bool, 0);
 MODULE_PARM_DESC(safe, "Turn Safe Encapsulation On/Off");
 

commit 68e24113457e437b1576670f2419b77ed0531e9e
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue May 8 15:46:14 2012 -0700

    USB: serial: rework usb_serial_register/deregister_drivers()
    
    This reworks the usb_serial_register_drivers() and
    usb_serial_deregister_drivers() to not need a pointer to a struct
    usb_driver anymore.  The usb_driver structure is now created dynamically
    and registered and unregistered as needed.
    
    This saves lines of code in each usb-serial driver.  All in-kernel users
    of these functions were also fixed up at this time.  The pl2303 driver
    was tested that everything worked properly.
    
    Thanks for the idea to do this from Alan Stern.
    
    Cc: Adhir Ramjiawan <adhirramjiawan0@gmail.com>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Al Borchers <alborchers@steinerpoint.com>
    Cc: Aleksey Babahin <tamerlan311@gmail.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Andrew Worsley <amworsley@gmail.com>
    Cc: Bart Hartgers <bart.hartgers@gmail.com>
    Cc: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Dan Carpenter <error27@gmail.com>
    Cc: Dan Williams <dcbw@redhat.com>
    Cc: Donald Lee <donald@asix.com.tw>
    Cc: Eric Dumazet <eric.dumazet@gmail.com>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Felipe Balbi <balbi@ti.com>
    Cc: Gary Brubaker <xavyer@ix.netcom.com>
    Cc: Jesper Juhl <jj@chaosbits.net>
    Cc: Jiri Kosina <jkosina@suse.cz>
    Cc: Johan Hovold <jhovold@gmail.com>
    Cc: Julia Lawall <julia@diku.dk>
    Cc: Kautuk Consul <consul.kautuk@gmail.com>
    Cc: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Cc: Lonnie Mendez <dignome@gmail.com>
    Cc: Matthias Bruestle and Harald Welte <support@reiner-sct.com>
    Cc: Matthias Urlichs <smurf@smurf.noris.de>
    Cc: Mauro Carvalho Chehab <mchehab@redhat.com>
    Cc: Michal Sroczynski <msroczyn@gmail.com>
    Cc: "Michał Wróbel" <michal.wrobel@flytronic.pl>
    Cc: Oliver Neukum <oliver@neukum.name>
    Cc: Paul Gortmaker <paul.gortmaker@windriver.com>
    Cc: Peter Berger <pberger@brimson.com>
    Cc: Preston Fick <preston.fick@silabs.com>
    Cc: "Rafael J. Wysocki" <rjw@sisk.pl>
    Cc: Rigbert Hamisch <rigbert@gmx.de>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Cc: Simon Arlott <simon@fire.lp0.eu>
    Cc: Support Department <support@connecttech.com>
    Cc: Thomas Tuttle <ttuttle@chromium.org>
    Cc: Uwe Bonnes <bon@elektron.ikp.physik.tu-darmstadt.de>
    Cc: Wang YanQing <Udknight@gmail.com>
    Cc: William Greathouse <wgreathouse@smva.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/safe_serial.c b/drivers/usb/serial/safe_serial.c
index 546ea12455f3..36e9d9fc0618 100644
--- a/drivers/usb/serial/safe_serial.c
+++ b/drivers/usb/serial/safe_serial.c
@@ -151,11 +151,6 @@ static struct usb_device_id id_table[] = {
 
 MODULE_DEVICE_TABLE(usb, id_table);
 
-static struct usb_driver safe_driver = {
-	.name =		"safe_serial",
-	.id_table =	id_table,
-};
-
 static const __u16 crc10_table[256] = {
 	0x000, 0x233, 0x255, 0x066, 0x299, 0x0aa, 0x0cc, 0x2ff,
 	0x301, 0x132, 0x154, 0x367, 0x198, 0x3ab, 0x3cd, 0x1fe,
@@ -337,12 +332,12 @@ static int __init safe_init(void)
 		}
 	}
 
-	return usb_serial_register_drivers(&safe_driver, serial_drivers);
+	return usb_serial_register_drivers(serial_drivers, KBUILD_MODNAME, id_table);
 }
 
 static void __exit safe_exit(void)
 {
-	usb_serial_deregister_drivers(&safe_driver, serial_drivers);
+	usb_serial_deregister_drivers(serial_drivers);
 }
 
 module_init(safe_init);

commit 32078f915d1acab356080b144aa89fe3487f3979
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon May 7 14:02:13 2012 -0700

    USB: serial: remove usb_serial_disconnect call in all drivers
    
    This is now set by the usb-serial core, no need for the driver to
    individually set it.
    
    Thanks to Alan Stern for the idea to get rid of it.
    
    Cc: William Greathouse <wgreathouse@smva.com>
    Cc: Matthias Bruestle and Harald Welte <support@reiner-sct.com>
    Cc: Lonnie Mendez <dignome@gmail.com>
    Cc: Peter Berger <pberger@brimson.com>
    Cc: Al Borchers <alborchers@steinerpoint.com>
    Cc: Gary Brubaker <xavyer@ix.netcom.com>
    Cc: Oliver Neukum <oliver@neukum.name>
    Cc: Matthias Urlichs <smurf@smurf.noris.de>
    Cc: Support Department <support@connecttech.com>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Mauro Carvalho Chehab <mchehab@redhat.com>
    Cc: Kautuk Consul <consul.kautuk@gmail.com>
    Cc: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Paul Gortmaker <paul.gortmaker@windriver.com>
    Cc: Bart Hartgers <bart.hartgers@gmail.com>
    Cc: Johan Hovold <jhovold@gmail.com>
    Cc: Preston Fick <preston.fick@silabs.com>
    Cc: Uwe Bonnes <bon@elektron.ikp.physik.tu-darmstadt.de>
    Cc: Simon Arlott <simon@fire.lp0.eu>
    Cc: Andrew Worsley <amworsley@gmail.com>
    Cc: "Michał Wróbel" <michal.wrobel@flytronic.pl>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Eric Dumazet <eric.dumazet@gmail.com>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Felipe Balbi <balbi@ti.com>
    Cc: Aleksey Babahin <tamerlan311@gmail.com>
    Cc: Dan Carpenter <error27@gmail.com>
    Cc: Jiri Kosina <jkosina@suse.cz>
    Cc: Donald Lee <donald@asix.com.tw>
    Cc: Julia Lawall <julia@diku.dk>
    Cc: Michal Sroczynski <msroczyn@gmail.com>
    Cc: Wang YanQing <Udknight@gmail.com>
    Cc: Dan Williams <dcbw@redhat.com>
    Cc: Thomas Tuttle <ttuttle@chromium.org>
    Cc: Rigbert Hamisch <rigbert@gmx.de>
    Cc: "Rafael J. Wysocki" <rjw@sisk.pl>
    Cc: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Cc: Jesper Juhl <jj@chaosbits.net>
    Cc: Adhir Ramjiawan <adhirramjiawan0@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/safe_serial.c b/drivers/usb/serial/safe_serial.c
index 15db52206d69..546ea12455f3 100644
--- a/drivers/usb/serial/safe_serial.c
+++ b/drivers/usb/serial/safe_serial.c
@@ -153,7 +153,6 @@ MODULE_DEVICE_TABLE(usb, id_table);
 
 static struct usb_driver safe_driver = {
 	.name =		"safe_serial",
-	.disconnect =	usb_serial_disconnect,
 	.id_table =	id_table,
 };
 

commit 5026bb07be87ef5892742e6853ae6efa0f41961f
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon May 7 13:48:33 2012 -0700

    USB: serial: remove usb_serial_probe call in all drivers
    
    This is now set by the usb-serial core, no need for the driver to
    individually set it.
    
    Thanks to Alan Stern for the idea to get rid of it.
    
    Cc: William Greathouse <wgreathouse@smva.com>
    Cc: Matthias Bruestle and Harald Welte <support@reiner-sct.com>
    Cc: Lonnie Mendez <dignome@gmail.com>
    Cc: Peter Berger <pberger@brimson.com>
    Cc: Al Borchers <alborchers@steinerpoint.com>
    Cc: Gary Brubaker <xavyer@ix.netcom.com>
    Cc: Oliver Neukum <oliver@neukum.name>
    Cc: Matthias Urlichs <smurf@smurf.noris.de>
    Cc: Support Department <support@connecttech.com>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Mauro Carvalho Chehab <mchehab@redhat.com>
    Cc: Kautuk Consul <consul.kautuk@gmail.com>
    Cc: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Paul Gortmaker <paul.gortmaker@windriver.com>
    Cc: Bart Hartgers <bart.hartgers@gmail.com>
    Cc: Johan Hovold <jhovold@gmail.com>
    Cc: Preston Fick <preston.fick@silabs.com>
    Cc: Uwe Bonnes <bon@elektron.ikp.physik.tu-darmstadt.de>
    Cc: Simon Arlott <simon@fire.lp0.eu>
    Cc: Andrew Worsley <amworsley@gmail.com>
    Cc: "Michał Wróbel" <michal.wrobel@flytronic.pl>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Eric Dumazet <eric.dumazet@gmail.com>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Felipe Balbi <balbi@ti.com>
    Cc: Aleksey Babahin <tamerlan311@gmail.com>
    Cc: Dan Carpenter <error27@gmail.com>
    Cc: Jiri Kosina <jkosina@suse.cz>
    Cc: Donald Lee <donald@asix.com.tw>
    Cc: Julia Lawall <julia@diku.dk>
    Cc: Michal Sroczynski <msroczyn@gmail.com>
    Cc: Wang YanQing <Udknight@gmail.com>
    Cc: Dan Williams <dcbw@redhat.com>
    Cc: Thomas Tuttle <ttuttle@chromium.org>
    Cc: Rigbert Hamisch <rigbert@gmx.de>
    Cc: "Rafael J. Wysocki" <rjw@sisk.pl>
    Cc: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Cc: Jesper Juhl <jj@chaosbits.net>
    Cc: Adhir Ramjiawan <adhirramjiawan0@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/safe_serial.c b/drivers/usb/serial/safe_serial.c
index ae4ee30c7411..15db52206d69 100644
--- a/drivers/usb/serial/safe_serial.c
+++ b/drivers/usb/serial/safe_serial.c
@@ -153,7 +153,6 @@ MODULE_DEVICE_TABLE(usb, id_table);
 
 static struct usb_driver safe_driver = {
 	.name =		"safe_serial",
-	.probe =	usb_serial_probe,
 	.disconnect =	usb_serial_disconnect,
 	.id_table =	id_table,
 };

commit d860322f34e4a53f347b1aeae23d5b72f1e91b8c
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Thu Feb 23 14:57:25 2012 -0500

    usb-serial: use new registration API in [q-s]* drivers
    
    This patch (as1528) modifies the following usb-serial drivers to
    utilize the new usb_serial_{de}register_drivers() routines:
    
            qcaux, qcserial, safe_serial, siemens_mpi, sierra,
            spcp8x5, ssu100, and symbolserial.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/safe_serial.c b/drivers/usb/serial/safe_serial.c
index d074b3740dcb..ae4ee30c7411 100644
--- a/drivers/usb/serial/safe_serial.c
+++ b/drivers/usb/serial/safe_serial.c
@@ -156,7 +156,6 @@ static struct usb_driver safe_driver = {
 	.probe =	usb_serial_probe,
 	.disconnect =	usb_serial_disconnect,
 	.id_table =	id_table,
-	.no_dynamic_id = 	1,
 };
 
 static const __u16 crc10_table[256] = {
@@ -309,16 +308,19 @@ static struct usb_serial_driver safe_device = {
 		.name =		"safe_serial",
 	},
 	.id_table =		id_table,
-	.usb_driver =		&safe_driver,
 	.num_ports =		1,
 	.process_read_urb =	safe_process_read_urb,
 	.prepare_write_buffer =	safe_prepare_write_buffer,
 	.attach =		safe_startup,
 };
 
+static struct usb_serial_driver * const serial_drivers[] = {
+	&safe_device, NULL
+};
+
 static int __init safe_init(void)
 {
-	int i, retval;
+	int i;
 
 	printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
 	       DRIVER_DESC "\n");
@@ -337,24 +339,12 @@ static int __init safe_init(void)
 		}
 	}
 
-	retval = usb_serial_register(&safe_device);
-	if (retval)
-		goto failed_usb_serial_register;
-	retval = usb_register(&safe_driver);
-	if (retval)
-		goto failed_usb_register;
-
-	return 0;
-failed_usb_register:
-	usb_serial_deregister(&safe_device);
-failed_usb_serial_register:
-	return retval;
+	return usb_serial_register_drivers(&safe_driver, serial_drivers);
 }
 
 static void __exit safe_exit(void)
 {
-	usb_deregister(&safe_driver);
-	usb_serial_deregister(&safe_device);
+	usb_serial_deregister_drivers(&safe_driver, serial_drivers);
 }
 
 module_init(safe_init);

commit 90ab5ee94171b3e28de6bb42ee30b527014e0be7
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Fri Jan 13 09:32:20 2012 +1030

    module_param: make bool parameters really bool (drivers & misc)
    
    module_param(bool) used to counter-intuitively take an int.  In
    fddd5201 (mid-2009) we allowed bool or int/unsigned int using a messy
    trick.
    
    It's time to remove the int/unsigned int option.  For this version
    it'll simply give a warning, but it'll break next kernel version.
    
    Acked-by: Mauro Carvalho Chehab <mchehab@redhat.com>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/drivers/usb/serial/safe_serial.c b/drivers/usb/serial/safe_serial.c
index a36e2313eed0..d074b3740dcb 100644
--- a/drivers/usb/serial/safe_serial.c
+++ b/drivers/usb/serial/safe_serial.c
@@ -81,9 +81,9 @@
 #define CONFIG_USB_SERIAL_SAFE_PADDED 0
 #endif
 
-static int debug;
-static int safe = 1;
-static int padded = CONFIG_USB_SERIAL_SAFE_PADDED;
+static bool debug;
+static bool safe = 1;
+static bool padded = CONFIG_USB_SERIAL_SAFE_PADDED;
 
 #define DRIVER_VERSION "v0.1"
 #define DRIVER_AUTHOR "sl@lineo.com, tbr@lineo.com, Johan Hovold <jhovold@gmail.com>"

commit 6d1bf48e240bde4e9c7313ccdd2fe32f37f67ad4
Author: Johan Hovold <jhovold@gmail.com>
Date:   Wed May 19 00:01:32 2010 +0200

    USB: safe_serial: straighten out read processing
    
    Clean up read processing logic.
    
    Tested using a cp210x device in a loopback setup.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/safe_serial.c b/drivers/usb/serial/safe_serial.c
index d9af5c5ed9e8..a36e2313eed0 100644
--- a/drivers/usb/serial/safe_serial.c
+++ b/drivers/usb/serial/safe_serial.c
@@ -218,7 +218,9 @@ static void safe_process_read_urb(struct urb *urb)
 	struct usb_serial_port *port = urb->context;
 	unsigned char *data = urb->transfer_buffer;
 	unsigned char length = urb->actual_length;
+	int actual_length;
 	struct tty_struct *tty;
+	__u16 fcs;
 
 	if (!length)
 		return;
@@ -227,30 +229,27 @@ static void safe_process_read_urb(struct urb *urb)
 	if (!tty)
 		return;
 
-	if (safe) {
-		__u16 fcs;
-		fcs = fcs_compute10(data, length, CRC10_INITFCS);
-		if (!fcs) {
-			int actual_length = data[length - 2] >> 2;
-			if (actual_length <= (length - 2)) {
-				dev_info(&urb->dev->dev, "%s - actual: %d\n",
-					 __func__, actual_length);
-				tty_insert_flip_string(tty,
-							data, actual_length);
-				tty_flip_buffer_push(tty);
-			} else {
-				dev_err(&port->dev,
-					"%s - inconsistent lengths %d:%d\n",
-					__func__, actual_length, length);
-			}
-		} else {
-			dev_err(&port->dev, "%s - bad CRC %x\n", __func__, fcs);
-		}
-	} else {
-		tty_insert_flip_string(tty, data, length);
-		tty_flip_buffer_push(tty);
+	if (!safe)
+		goto out;
+
+	fcs = fcs_compute10(data, length, CRC10_INITFCS);
+	if (fcs) {
+		dev_err(&port->dev, "%s - bad CRC %x\n", __func__, fcs);
+		goto err;
 	}
 
+	actual_length = data[length - 2] >> 2;
+	if (actual_length > (length - 2)) {
+		dev_err(&port->dev, "%s - inconsistent lengths %d:%d\n",
+				__func__, actual_length, length);
+		goto err;
+	}
+	dev_info(&urb->dev->dev, "%s - actual: %d\n", __func__, actual_length);
+	length = actual_length;
+out:
+	tty_insert_flip_string(tty, data, length);
+	tty_flip_buffer_push(tty);
+err:
 	tty_kref_put(tty);
 }
 

commit 12e2e52cc578714d5824a27dd1a131a5418d636b
Author: Johan Hovold <jhovold@gmail.com>
Date:   Wed May 19 00:01:31 2010 +0200

    USB: safe_serial: reimplement read using generic framework
    
    Use process_read_urb to implement read processing.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/safe_serial.c b/drivers/usb/serial/safe_serial.c
index 915c094ef92c..d9af5c5ed9e8 100644
--- a/drivers/usb/serial/safe_serial.c
+++ b/drivers/usb/serial/safe_serial.c
@@ -213,38 +213,20 @@ static __u16 __inline__ fcs_compute10(unsigned char *sp, int len, __u16 fcs)
 	return fcs;
 }
 
-static void safe_read_bulk_callback(struct urb *urb)
+static void safe_process_read_urb(struct urb *urb)
 {
-	struct usb_serial_port *port =  urb->context;
+	struct usb_serial_port *port = urb->context;
 	unsigned char *data = urb->transfer_buffer;
 	unsigned char length = urb->actual_length;
 	struct tty_struct *tty;
-	int result;
-	int status = urb->status;
 
-	dbg("%s", __func__);
-
-	if (status) {
-		dbg("%s - nonzero read bulk status received: %d",
-		    __func__, status);
+	if (!length)
 		return;
-	}
 
-	dbg("safe_read_bulk_callback length: %d",
-					port->read_urb->actual_length);
-#ifdef ECHO_RCV
-	{
-		int i;
-		unsigned char *cp = port->read_urb->transfer_buffer;
-		for (i = 0; i < port->read_urb->actual_length; i++) {
-			if ((i % 32) == 0)
-				printk("\nru[%02x] ", i);
-			printk("%02x ", *cp++);
-		}
-		printk("\n");
-	}
-#endif
 	tty = tty_port_tty_get(&port->port);
+	if (!tty)
+		return;
+
 	if (safe) {
 		__u16 fcs;
 		fcs = fcs_compute10(data, length, CRC10_INITFCS);
@@ -268,21 +250,8 @@ static void safe_read_bulk_callback(struct urb *urb)
 		tty_insert_flip_string(tty, data, length);
 		tty_flip_buffer_push(tty);
 	}
-	tty_kref_put(tty);
 
-	/* Continue trying to always read  */
-	usb_fill_bulk_urb(urb, port->serial->dev,
-			usb_rcvbulkpipe(port->serial->dev,
-					port->bulk_in_endpointAddress),
-			urb->transfer_buffer, urb->transfer_buffer_length,
-			safe_read_bulk_callback, port);
-
-	result = usb_submit_urb(urb, GFP_ATOMIC);
-	if (result)
-		dev_err(&port->dev,
-			"%s - failed resubmitting read urb, error %d\n",
-			__func__, result);
-		/* FIXME: Need a mechanism to retry later if this happens */
+	tty_kref_put(tty);
 }
 
 static int safe_prepare_write_buffer(struct usb_serial_port *port,
@@ -343,7 +312,7 @@ static struct usb_serial_driver safe_device = {
 	.id_table =		id_table,
 	.usb_driver =		&safe_driver,
 	.num_ports =		1,
-	.read_bulk_callback =	safe_read_bulk_callback,
+	.process_read_urb =	safe_process_read_urb,
 	.prepare_write_buffer =	safe_prepare_write_buffer,
 	.attach =		safe_startup,
 };

commit 241c80ea72be4828c63f5dd44b142e54d0a12f5d
Author: Johan Hovold <jhovold@gmail.com>
Date:   Wed May 19 00:01:30 2010 +0200

    USB: safe_serial: reimplement write using generic framework
    
    Kill custom single-urb write implementation.
    
    Note that this driver still depended on the write callback from the old
    generic framework.
    
    Tested against original read processing using a cp210x device in a
    loopback setup.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/safe_serial.c b/drivers/usb/serial/safe_serial.c
index 43a0cadd5782..915c094ef92c 100644
--- a/drivers/usb/serial/safe_serial.c
+++ b/drivers/usb/serial/safe_serial.c
@@ -1,6 +1,7 @@
 /*
  * Safe Encapsulated USB Serial Driver
  *
+ *      Copyright (C) 2010 Johan Hovold <jhovold@gmail.com>
  *      Copyright (C) 2001 Lineo
  *      Copyright (C) 2001 Hewlett-Packard
  *
@@ -84,8 +85,8 @@ static int debug;
 static int safe = 1;
 static int padded = CONFIG_USB_SERIAL_SAFE_PADDED;
 
-#define DRIVER_VERSION "v0.0b"
-#define DRIVER_AUTHOR "sl@lineo.com, tbr@lineo.com"
+#define DRIVER_VERSION "v0.1"
+#define DRIVER_AUTHOR "sl@lineo.com, tbr@lineo.com, Johan Hovold <jhovold@gmail.com>"
 #define DRIVER_DESC "USB Safe Encapsulated Serial"
 
 MODULE_AUTHOR(DRIVER_AUTHOR);
@@ -284,119 +285,40 @@ static void safe_read_bulk_callback(struct urb *urb)
 		/* FIXME: Need a mechanism to retry later if this happens */
 }
 
-static int safe_write(struct tty_struct *tty, struct usb_serial_port *port,
-					const unsigned char *buf, int count)
+static int safe_prepare_write_buffer(struct usb_serial_port *port,
+						void *dest, size_t size)
 {
-	unsigned char *data;
-	int result;
-	int i;
-	int packet_length;
-
-	dbg("safe_write port: %p %d urb: %p count: %d",
-				port, port->number, port->write_urb, count);
-
-	if (!port->write_urb) {
-		dbg("%s - write urb NULL", __func__);
-		return 0;
-	}
-
-	dbg("safe_write write_urb: %d transfer_buffer_length",
-	     port->write_urb->transfer_buffer_length);
-
-	if (!port->write_urb->transfer_buffer_length) {
-		dbg("%s - write urb transfer_buffer_length zero", __func__);
-		return 0;
-	}
-	if (count == 0) {
-		dbg("%s - write request of 0 bytes", __func__);
-		return 0;
-	}
-	spin_lock_bh(&port->lock);
-	if (port->write_urb_busy) {
-		spin_unlock_bh(&port->lock);
-		dbg("%s - already writing", __func__);
-		return 0;
-	}
-	port->write_urb_busy = 1;
-	spin_unlock_bh(&port->lock);
-
-	packet_length = port->bulk_out_size;	/* get max packetsize */
-
-	i = packet_length - (safe ? 2 : 0);	/* get bytes to send */
-	count = (count > i) ? i : count;
-
-
-	/* get the data into the transfer buffer */
-	data = port->write_urb->transfer_buffer;
-	memset(data, '0', packet_length);
-
-	memcpy(data, buf, count);
-
-	if (safe) {
-		__u16 fcs;
-
-		/* pad if necessary */
-		if (!padded)
-			packet_length = count + 2;
-		/* set count */
-		data[packet_length - 2] = count << 2;
-		data[packet_length - 1] = 0;
-
-		/* compute fcs and insert into trailer */
-		fcs = fcs_compute10(data, packet_length, CRC10_INITFCS);
-		data[packet_length - 2] |= fcs >> 8;
-		data[packet_length - 1] |= fcs & 0xff;
-
-		/* set length to send */
-		port->write_urb->transfer_buffer_length = packet_length;
+	unsigned char *buf = dest;
+	int count;
+	int trailer_len;
+	int pkt_len;
+	__u16 fcs;
+
+	trailer_len = safe ? 2 : 0;
+
+	count = kfifo_out_locked(&port->write_fifo, buf, size - trailer_len,
+								&port->lock);
+	if (!safe)
+		return count;
+
+	/* pad if necessary */
+	if (padded) {
+		pkt_len = size;
+		memset(buf + count, '0', pkt_len - count - trailer_len);
 	} else {
-		port->write_urb->transfer_buffer_length = count;
-	}
-
-	usb_serial_debug_data(debug, &port->dev, __func__, count,
-					port->write_urb->transfer_buffer);
-#ifdef ECHO_TX
-	{
-		int i;
-		unsigned char *cp = port->write_urb->transfer_buffer;
-		for (i = 0; i < port->write_urb->transfer_buffer_length; i++) {
-			if ((i % 32) == 0)
-				printk("\nsu[%02x] ", i);
-			printk("%02x ", *cp++);
-		}
-		printk("\n");
+		pkt_len = count + trailer_len;
 	}
-#endif
-	port->write_urb->dev = port->serial->dev;
-	result = usb_submit_urb(port->write_urb, GFP_KERNEL);
-	if (result) {
-		port->write_urb_busy = 0;
-		dev_err(&port->dev,
-			"%s - failed submitting write urb, error %d\n",
-			__func__, result);
-		return 0;
-	}
-	dbg("%s urb: %p submitted", __func__, port->write_urb);
 
-	return count;
-}
-
-static int safe_write_room(struct tty_struct *tty)
-{
-	struct usb_serial_port *port = tty->driver_data;
-	int room = 0;		/* Default: no room */
-	unsigned long flags;
-
-	dbg("%s", __func__);
+	/* set count */
+	buf[pkt_len - 2] = count << 2;
+	buf[pkt_len - 1] = 0;
 
-	spin_lock_irqsave(&port->lock, flags);
-	if (port->write_urb_busy)
-		room = port->bulk_out_size - (safe ? 2 : 0);
-	spin_unlock_irqrestore(&port->lock, flags);
+	/* compute fcs and insert into trailer */
+	fcs = fcs_compute10(buf, pkt_len, CRC10_INITFCS);
+	buf[pkt_len - 2] |= fcs >> 8;
+	buf[pkt_len - 1] |= fcs & 0xff;
 
-	if (room)
-		dbg("safe_write_room returns %d", room);
-	return room;
+	return pkt_len;
 }
 
 static int safe_startup(struct usb_serial *serial)
@@ -421,9 +343,8 @@ static struct usb_serial_driver safe_device = {
 	.id_table =		id_table,
 	.usb_driver =		&safe_driver,
 	.num_ports =		1,
-	.write =		safe_write,
-	.write_room =		safe_write_room,
 	.read_bulk_callback =	safe_read_bulk_callback,
+	.prepare_write_buffer =	safe_prepare_write_buffer,
 	.attach =		safe_startup,
 };
 

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/usb/serial/safe_serial.c b/drivers/usb/serial/safe_serial.c
index 4b463cd140ef..43a0cadd5782 100644
--- a/drivers/usb/serial/safe_serial.c
+++ b/drivers/usb/serial/safe_serial.c
@@ -64,8 +64,8 @@
 
 #include <linux/kernel.h>
 #include <linux/errno.h>
+#include <linux/gfp.h>
 #include <linux/init.h>
-#include <linux/slab.h>
 #include <linux/tty.h>
 #include <linux/tty_driver.h>
 #include <linux/tty_flip.h>

commit 194343d9364ea07c9f27c4505380a15a905e8a24
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed Aug 20 16:56:34 2008 -0700

    USB: remove use of err() in drivers/usb/serial
    
    err() is going away, so switch to dev_err() or printk() if it's really
    needed.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/safe_serial.c b/drivers/usb/serial/safe_serial.c
index 40cff61cb4a2..4b463cd140ef 100644
--- a/drivers/usb/serial/safe_serial.c
+++ b/drivers/usb/serial/safe_serial.c
@@ -256,11 +256,12 @@ static void safe_read_bulk_callback(struct urb *urb)
 							data, actual_length);
 				tty_flip_buffer_push(tty);
 			} else {
-				err("%s - inconsistent lengths %d:%d",
+				dev_err(&port->dev,
+					"%s - inconsistent lengths %d:%d\n",
 					__func__, actual_length, length);
 			}
 		} else {
-			err("%s - bad CRC %x", __func__, fcs);
+			dev_err(&port->dev, "%s - bad CRC %x\n", __func__, fcs);
 		}
 	} else {
 		tty_insert_flip_string(tty, data, length);
@@ -277,8 +278,9 @@ static void safe_read_bulk_callback(struct urb *urb)
 
 	result = usb_submit_urb(urb, GFP_ATOMIC);
 	if (result)
-		err("%s - failed resubmitting read urb, error %d",
-							__func__, result);
+		dev_err(&port->dev,
+			"%s - failed resubmitting read urb, error %d\n",
+			__func__, result);
 		/* FIXME: Need a mechanism to retry later if this happens */
 }
 
@@ -369,8 +371,9 @@ static int safe_write(struct tty_struct *tty, struct usb_serial_port *port,
 	result = usb_submit_urb(port->write_urb, GFP_KERNEL);
 	if (result) {
 		port->write_urb_busy = 0;
-		err("%s - failed submitting write urb, error %d",
-							__func__, result);
+		dev_err(&port->dev,
+			"%s - failed submitting write urb, error %d\n",
+			__func__, result);
 		return 0;
 	}
 	dbg("%s urb: %p submitted", __func__, port->write_urb);

commit c197a8db59daf06dc5e77acd5a9681329cb22458
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Aug 18 13:21:04 2008 -0700

    USB: remove info() macro from usb/serial drivers
    
    USB should not be having it's own printk macros, so remove info() and
    use the system-wide standard of dev_info() wherever possible.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/safe_serial.c b/drivers/usb/serial/safe_serial.c
index 72903ac9f5c0..40cff61cb4a2 100644
--- a/drivers/usb/serial/safe_serial.c
+++ b/drivers/usb/serial/safe_serial.c
@@ -250,8 +250,8 @@ static void safe_read_bulk_callback(struct urb *urb)
 		if (!fcs) {
 			int actual_length = data[length - 2] >> 2;
 			if (actual_length <= (length - 2)) {
-				info("%s - actual: %d", __func__,
-							actual_length);
+				dev_info(&urb->dev->dev, "%s - actual: %d\n",
+					 __func__, actual_length);
 				tty_insert_flip_string(tty,
 							data, actual_length);
 				tty_flip_buffer_push(tty);
@@ -428,14 +428,13 @@ static int __init safe_init(void)
 {
 	int i, retval;
 
-	info(DRIVER_VERSION " " DRIVER_AUTHOR);
-	info(DRIVER_DESC);
-	info("vendor: %x product: %x safe: %d padded: %d\n",
-					vendor, product, safe, padded);
+	printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
+	       DRIVER_DESC "\n");
 
 	/* if we have vendor / product parameters patch them into id list */
 	if (vendor || product) {
-		info("vendor: %x product: %x\n", vendor, product);
+		printk(KERN_INFO KBUILD_MODNAME ": vendor: %x product: %x\n",
+		       vendor, product);
 
 		for (i = 0; i < ARRAY_SIZE(id_table); i++) {
 			if (!id_table[i].idVendor && !id_table[i].idProduct) {

commit 4a90f09b20f4622dcbff1f0e1e6bae1704f8ad8c
Author: Alan Cox <alan@redhat.com>
Date:   Mon Oct 13 10:39:46 2008 +0100

    tty: usb-serial krefs
    
    Use kref in the USB serial drivers so that we don't free tty structures
    from under the URB receive handlers as has historically been the case if
    you were unlucky. This also gives us a framework for general tty drivers to
    use tty_port objects and refcount.
    
    Contains two err->dev_err changes merged together to fix clashes in the
    -next tree.
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/usb/serial/safe_serial.c b/drivers/usb/serial/safe_serial.c
index def52d07a4ea..72903ac9f5c0 100644
--- a/drivers/usb/serial/safe_serial.c
+++ b/drivers/usb/serial/safe_serial.c
@@ -217,6 +217,7 @@ static void safe_read_bulk_callback(struct urb *urb)
 	struct usb_serial_port *port =  urb->context;
 	unsigned char *data = urb->transfer_buffer;
 	unsigned char length = urb->actual_length;
+	struct tty_struct *tty;
 	int result;
 	int status = urb->status;
 
@@ -242,6 +243,7 @@ static void safe_read_bulk_callback(struct urb *urb)
 		printk("\n");
 	}
 #endif
+	tty = tty_port_tty_get(&port->port);
 	if (safe) {
 		__u16 fcs;
 		fcs = fcs_compute10(data, length, CRC10_INITFCS);
@@ -250,9 +252,9 @@ static void safe_read_bulk_callback(struct urb *urb)
 			if (actual_length <= (length - 2)) {
 				info("%s - actual: %d", __func__,
 							actual_length);
-				tty_insert_flip_string(port->port.tty,
+				tty_insert_flip_string(tty,
 							data, actual_length);
-				tty_flip_buffer_push(port->port.tty);
+				tty_flip_buffer_push(tty);
 			} else {
 				err("%s - inconsistent lengths %d:%d",
 					__func__, actual_length, length);
@@ -261,9 +263,10 @@ static void safe_read_bulk_callback(struct urb *urb)
 			err("%s - bad CRC %x", __func__, fcs);
 		}
 	} else {
-		tty_insert_flip_string(port->port.tty, data, length);
-		tty_flip_buffer_push(port->port.tty);
+		tty_insert_flip_string(tty, data, length);
+		tty_flip_buffer_push(tty);
 	}
+	tty_kref_put(tty);
 
 	/* Continue trying to always read  */
 	usb_fill_bulk_urb(urb, port->serial->dev,

commit 43c8f435b2ca39f12ad89d91d9ee2be04a196f93
Author: Alan Cox <alan@redhat.com>
Date:   Tue Jul 22 11:15:26 2008 +0100

    tty-usb-safe-serial: Coding style
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/usb/serial/safe_serial.c b/drivers/usb/serial/safe_serial.c
index f823e4dcea1e..def52d07a4ea 100644
--- a/drivers/usb/serial/safe_serial.c
+++ b/drivers/usb/serial/safe_serial.c
@@ -13,24 +13,25 @@
  *      Stuart Lynne <sl@lineo.com>, Tom Rushworth <tbr@lineo.com>
  */
 
-/* 
- * The encapsultaion is designed to overcome difficulties with some USB hardware.
+/*
+ * The encapsultaion is designed to overcome difficulties with some USB
+ * hardware.
  *
  * While the USB protocol has a CRC over the data while in transit, i.e. while
- * being carried over the bus, there is no end to end protection. If the hardware
- * has any problems getting the data into or out of the USB transmit and receive
- * FIFO's then data can be lost. 
+ * being carried over the bus, there is no end to end protection. If the
+ * hardware has any problems getting the data into or out of the USB transmit
+ * and receive FIFO's then data can be lost.
  *
- * This protocol adds a two byte trailer to each USB packet to specify the number
- * of bytes of valid data and a 10 bit CRC that will allow the receiver to verify
- * that the entire USB packet was received without error.
+ * This protocol adds a two byte trailer to each USB packet to specify the
+ * number of bytes of valid data and a 10 bit CRC that will allow the receiver
+ * to verify that the entire USB packet was received without error.
  *
- * Because in this case the sender and receiver are the class and function drivers
- * there is now end to end protection.
+ * Because in this case the sender and receiver are the class and function
+ * drivers there is now end to end protection.
  *
- * There is an additional option that can be used to force all transmitted packets
- * to be padded to the maximum packet size. This provides a work around for some
- * devices which have problems with small USB packets.
+ * There is an additional option that can be used to force all transmitted
+ * packets to be padded to the maximum packet size. This provides a work
+ * around for some devices which have problems with small USB packets.
  *
  * Assuming a packetsize of N:
  *
@@ -44,11 +45,12 @@
  *      | Data Length       | 10 bit CRC                                |
  *      + 7 . 6 . 5 . 4 . 3 . 2 . 1 . 0 | 7 . 6 . 5 . 4 . 3 . 2 . 1 . 0 +
  *
- * The 10 bit CRC is computed across the sent data, followed by the trailer with
- * the length set and the CRC set to zero. The CRC is then OR'd into the trailer.
+ * The 10 bit CRC is computed across the sent data, followed by the trailer
+ * with the length set and the CRC set to zero. The CRC is then OR'd into
+ * the trailer.
  *
- * When received a 10 bit CRC is computed over the entire frame including the trailer
- * and should be equal to zero.
+ * When received a 10 bit CRC is computed over the entire frame including
+ * the trailer and should be equal to zero.
  *
  * Two module parameters are used to control the encapsulation, if both are
  * turned of the module works as a simple serial device with NO
@@ -69,7 +71,7 @@
 #include <linux/tty_flip.h>
 #include <linux/module.h>
 #include <linux/spinlock.h>
-#include <asm/uaccess.h>
+#include <linux/uaccess.h>
 #include <linux/usb.h>
 #include <linux/usb/serial.h>
 
@@ -86,12 +88,12 @@ static int padded = CONFIG_USB_SERIAL_SAFE_PADDED;
 #define DRIVER_AUTHOR "sl@lineo.com, tbr@lineo.com"
 #define DRIVER_DESC "USB Safe Encapsulated Serial"
 
-MODULE_AUTHOR (DRIVER_AUTHOR);
-MODULE_DESCRIPTION (DRIVER_DESC);
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_DESCRIPTION(DRIVER_DESC);
 MODULE_LICENSE("GPL");
 
-static __u16 vendor;		// no default
-static __u16 product;		// no default
+static __u16 vendor;		/* no default */
+static __u16 product;		/* no default */
 module_param(vendor, ushort, 0);
 MODULE_PARM_DESC(vendor, "User specified USB idVendor (required)");
 module_param(product, ushort, 0);
@@ -122,30 +124,31 @@ MODULE_PARM_DESC(padded, "Pad to full wMaxPacketSize On/Off");
 #define LINEO_SAFESERIAL_CRC_PADDED             0x02
 
 
-#define MY_USB_DEVICE(vend,prod,dc,ic,isc) \
-        .match_flags = USB_DEVICE_ID_MATCH_DEVICE | USB_DEVICE_ID_MATCH_DEV_CLASS | \
-                USB_DEVICE_ID_MATCH_INT_CLASS | USB_DEVICE_ID_MATCH_INT_SUBCLASS, \
-        .idVendor = (vend), \
-        .idProduct = (prod),\
-        .bDeviceClass = (dc),\
-        .bInterfaceClass = (ic), \
-        .bInterfaceSubClass = (isc),
+#define MY_USB_DEVICE(vend, prod, dc, ic, isc) \
+	.match_flags = USB_DEVICE_ID_MATCH_DEVICE | \
+		       USB_DEVICE_ID_MATCH_DEV_CLASS | \
+		       USB_DEVICE_ID_MATCH_INT_CLASS | \
+		       USB_DEVICE_ID_MATCH_INT_SUBCLASS, \
+	.idVendor = (vend), \
+	.idProduct = (prod),\
+	.bDeviceClass = (dc),\
+	.bInterfaceClass = (ic), \
+	.bInterfaceSubClass = (isc),
 
 static struct usb_device_id id_table[] = {
-	{MY_USB_DEVICE (0x49f, 0xffff, CDC_DEVICE_CLASS, LINEO_INTERFACE_CLASS, LINEO_INTERFACE_SUBCLASS_SAFESERIAL)},	// Itsy
-	{MY_USB_DEVICE (0x3f0, 0x2101, CDC_DEVICE_CLASS, LINEO_INTERFACE_CLASS, LINEO_INTERFACE_SUBCLASS_SAFESERIAL)},	// Calypso
-	{MY_USB_DEVICE (0x4dd, 0x8001, CDC_DEVICE_CLASS, LINEO_INTERFACE_CLASS, LINEO_INTERFACE_SUBCLASS_SAFESERIAL)},	// Iris 
-	{MY_USB_DEVICE (0x4dd, 0x8002, CDC_DEVICE_CLASS, LINEO_INTERFACE_CLASS, LINEO_INTERFACE_SUBCLASS_SAFESERIAL)},	// Collie 
-	{MY_USB_DEVICE (0x4dd, 0x8003, CDC_DEVICE_CLASS, LINEO_INTERFACE_CLASS, LINEO_INTERFACE_SUBCLASS_SAFESERIAL)},	// Collie 
-	{MY_USB_DEVICE (0x4dd, 0x8004, CDC_DEVICE_CLASS, LINEO_INTERFACE_CLASS, LINEO_INTERFACE_SUBCLASS_SAFESERIAL)},	// Collie 
-	{MY_USB_DEVICE (0x5f9, 0xffff, CDC_DEVICE_CLASS, LINEO_INTERFACE_CLASS, LINEO_INTERFACE_SUBCLASS_SAFESERIAL)},	// Sharp tmp
-	// extra null entry for module 
-	// vendor/produc parameters
-	{MY_USB_DEVICE (0, 0, CDC_DEVICE_CLASS, LINEO_INTERFACE_CLASS, LINEO_INTERFACE_SUBCLASS_SAFESERIAL)},
-	{}			// terminating entry 
+	{MY_USB_DEVICE(0x49f, 0xffff, CDC_DEVICE_CLASS, LINEO_INTERFACE_CLASS, LINEO_INTERFACE_SUBCLASS_SAFESERIAL)},	/* Itsy */
+	{MY_USB_DEVICE(0x3f0, 0x2101, CDC_DEVICE_CLASS, LINEO_INTERFACE_CLASS, LINEO_INTERFACE_SUBCLASS_SAFESERIAL)},	/* Calypso */
+	{MY_USB_DEVICE(0x4dd, 0x8001, CDC_DEVICE_CLASS, LINEO_INTERFACE_CLASS, LINEO_INTERFACE_SUBCLASS_SAFESERIAL)},	/* Iris */
+	{MY_USB_DEVICE(0x4dd, 0x8002, CDC_DEVICE_CLASS, LINEO_INTERFACE_CLASS, LINEO_INTERFACE_SUBCLASS_SAFESERIAL)},	/* Collie */
+	{MY_USB_DEVICE(0x4dd, 0x8003, CDC_DEVICE_CLASS, LINEO_INTERFACE_CLASS, LINEO_INTERFACE_SUBCLASS_SAFESERIAL)},	/* Collie */
+	{MY_USB_DEVICE(0x4dd, 0x8004, CDC_DEVICE_CLASS, LINEO_INTERFACE_CLASS, LINEO_INTERFACE_SUBCLASS_SAFESERIAL)},	/* Collie */
+	{MY_USB_DEVICE(0x5f9, 0xffff, CDC_DEVICE_CLASS, LINEO_INTERFACE_CLASS, LINEO_INTERFACE_SUBCLASS_SAFESERIAL)},	/* Sharp tmp */
+	/* extra null entry for module vendor/produc parameters */
+	{MY_USB_DEVICE(0, 0, CDC_DEVICE_CLASS, LINEO_INTERFACE_CLASS, LINEO_INTERFACE_SUBCLASS_SAFESERIAL)},
+	{}			/* terminating entry  */
 };
 
-MODULE_DEVICE_TABLE (usb, id_table);
+MODULE_DEVICE_TABLE(usb, id_table);
 
 static struct usb_driver safe_driver = {
 	.name =		"safe_serial",
@@ -156,29 +159,45 @@ static struct usb_driver safe_driver = {
 };
 
 static const __u16 crc10_table[256] = {
-	0x000, 0x233, 0x255, 0x066, 0x299, 0x0aa, 0x0cc, 0x2ff, 0x301, 0x132, 0x154, 0x367, 0x198, 0x3ab, 0x3cd, 0x1fe,
-	0x031, 0x202, 0x264, 0x057, 0x2a8, 0x09b, 0x0fd, 0x2ce, 0x330, 0x103, 0x165, 0x356, 0x1a9, 0x39a, 0x3fc, 0x1cf,
-	0x062, 0x251, 0x237, 0x004, 0x2fb, 0x0c8, 0x0ae, 0x29d, 0x363, 0x150, 0x136, 0x305, 0x1fa, 0x3c9, 0x3af, 0x19c,
-	0x053, 0x260, 0x206, 0x035, 0x2ca, 0x0f9, 0x09f, 0x2ac, 0x352, 0x161, 0x107, 0x334, 0x1cb, 0x3f8, 0x39e, 0x1ad,
-	0x0c4, 0x2f7, 0x291, 0x0a2, 0x25d, 0x06e, 0x008, 0x23b, 0x3c5, 0x1f6, 0x190, 0x3a3, 0x15c, 0x36f, 0x309, 0x13a,
-	0x0f5, 0x2c6, 0x2a0, 0x093, 0x26c, 0x05f, 0x039, 0x20a, 0x3f4, 0x1c7, 0x1a1, 0x392, 0x16d, 0x35e, 0x338, 0x10b,
-	0x0a6, 0x295, 0x2f3, 0x0c0, 0x23f, 0x00c, 0x06a, 0x259, 0x3a7, 0x194, 0x1f2, 0x3c1, 0x13e, 0x30d, 0x36b, 0x158,
-	0x097, 0x2a4, 0x2c2, 0x0f1, 0x20e, 0x03d, 0x05b, 0x268, 0x396, 0x1a5, 0x1c3, 0x3f0, 0x10f, 0x33c, 0x35a, 0x169,
-	0x188, 0x3bb, 0x3dd, 0x1ee, 0x311, 0x122, 0x144, 0x377, 0x289, 0x0ba, 0x0dc, 0x2ef, 0x010, 0x223, 0x245, 0x076,
-	0x1b9, 0x38a, 0x3ec, 0x1df, 0x320, 0x113, 0x175, 0x346, 0x2b8, 0x08b, 0x0ed, 0x2de, 0x021, 0x212, 0x274, 0x047,
-	0x1ea, 0x3d9, 0x3bf, 0x18c, 0x373, 0x140, 0x126, 0x315, 0x2eb, 0x0d8, 0x0be, 0x28d, 0x072, 0x241, 0x227, 0x014,
-	0x1db, 0x3e8, 0x38e, 0x1bd, 0x342, 0x171, 0x117, 0x324, 0x2da, 0x0e9, 0x08f, 0x2bc, 0x043, 0x270, 0x216, 0x025,
-	0x14c, 0x37f, 0x319, 0x12a, 0x3d5, 0x1e6, 0x180, 0x3b3, 0x24d, 0x07e, 0x018, 0x22b, 0x0d4, 0x2e7, 0x281, 0x0b2,
-	0x17d, 0x34e, 0x328, 0x11b, 0x3e4, 0x1d7, 0x1b1, 0x382, 0x27c, 0x04f, 0x029, 0x21a, 0x0e5, 0x2d6, 0x2b0, 0x083,
-	0x12e, 0x31d, 0x37b, 0x148, 0x3b7, 0x184, 0x1e2, 0x3d1, 0x22f, 0x01c, 0x07a, 0x249, 0x0b6, 0x285, 0x2e3, 0x0d0,
-	0x11f, 0x32c, 0x34a, 0x179, 0x386, 0x1b5, 0x1d3, 0x3e0, 0x21e, 0x02d, 0x04b, 0x278, 0x087, 0x2b4, 0x2d2, 0x0e1,
+	0x000, 0x233, 0x255, 0x066, 0x299, 0x0aa, 0x0cc, 0x2ff,
+	0x301, 0x132, 0x154, 0x367, 0x198, 0x3ab, 0x3cd, 0x1fe,
+	0x031, 0x202, 0x264, 0x057, 0x2a8, 0x09b, 0x0fd, 0x2ce,
+	0x330, 0x103, 0x165, 0x356, 0x1a9, 0x39a, 0x3fc, 0x1cf,
+	0x062, 0x251, 0x237, 0x004, 0x2fb, 0x0c8, 0x0ae, 0x29d,
+	0x363, 0x150, 0x136, 0x305, 0x1fa, 0x3c9, 0x3af, 0x19c,
+	0x053, 0x260, 0x206, 0x035, 0x2ca, 0x0f9, 0x09f, 0x2ac,
+	0x352, 0x161, 0x107, 0x334, 0x1cb, 0x3f8, 0x39e, 0x1ad,
+	0x0c4, 0x2f7, 0x291, 0x0a2, 0x25d, 0x06e, 0x008, 0x23b,
+	0x3c5, 0x1f6, 0x190, 0x3a3, 0x15c, 0x36f, 0x309, 0x13a,
+	0x0f5, 0x2c6, 0x2a0, 0x093, 0x26c, 0x05f, 0x039, 0x20a,
+	0x3f4, 0x1c7, 0x1a1, 0x392, 0x16d, 0x35e, 0x338, 0x10b,
+	0x0a6, 0x295, 0x2f3, 0x0c0, 0x23f, 0x00c, 0x06a, 0x259,
+	0x3a7, 0x194, 0x1f2, 0x3c1, 0x13e, 0x30d, 0x36b, 0x158,
+	0x097, 0x2a4, 0x2c2, 0x0f1, 0x20e, 0x03d, 0x05b, 0x268,
+	0x396, 0x1a5, 0x1c3, 0x3f0, 0x10f, 0x33c, 0x35a, 0x169,
+	0x188, 0x3bb, 0x3dd, 0x1ee, 0x311, 0x122, 0x144, 0x377,
+	0x289, 0x0ba, 0x0dc, 0x2ef, 0x010, 0x223, 0x245, 0x076,
+	0x1b9, 0x38a, 0x3ec, 0x1df, 0x320, 0x113, 0x175, 0x346,
+	0x2b8, 0x08b, 0x0ed, 0x2de, 0x021, 0x212, 0x274, 0x047,
+	0x1ea, 0x3d9, 0x3bf, 0x18c, 0x373, 0x140, 0x126, 0x315,
+	0x2eb, 0x0d8, 0x0be, 0x28d, 0x072, 0x241, 0x227, 0x014,
+	0x1db, 0x3e8, 0x38e, 0x1bd, 0x342, 0x171, 0x117, 0x324,
+	0x2da, 0x0e9, 0x08f, 0x2bc, 0x043, 0x270, 0x216, 0x025,
+	0x14c, 0x37f, 0x319, 0x12a, 0x3d5, 0x1e6, 0x180, 0x3b3,
+	0x24d, 0x07e, 0x018, 0x22b, 0x0d4, 0x2e7, 0x281, 0x0b2,
+	0x17d, 0x34e, 0x328, 0x11b, 0x3e4, 0x1d7, 0x1b1, 0x382,
+	0x27c, 0x04f, 0x029, 0x21a, 0x0e5, 0x2d6, 0x2b0, 0x083,
+	0x12e, 0x31d, 0x37b, 0x148, 0x3b7, 0x184, 0x1e2, 0x3d1,
+	0x22f, 0x01c, 0x07a, 0x249, 0x0b6, 0x285, 0x2e3, 0x0d0,
+	0x11f, 0x32c, 0x34a, 0x179, 0x386, 0x1b5, 0x1d3, 0x3e0,
+	0x21e, 0x02d, 0x04b, 0x278, 0x087, 0x2b4, 0x2d2, 0x0e1,
 };
 
-#define CRC10_INITFCS     0x000	// Initial FCS value
-#define CRC10_GOODFCS     0x000	// Good final FCS value
-#define CRC10_FCS(fcs, c) ( (((fcs) << 8) & 0x3ff) ^ crc10_table[((fcs) >> 2) & 0xff] ^ (c))
+#define CRC10_INITFCS     0x000	/* Initial FCS value */
+#define CRC10_GOODFCS     0x000	/* Good final FCS value */
+#define CRC10_FCS(fcs, c) ((((fcs) << 8) & 0x3ff) ^ crc10_table[((fcs) >> 2) & 0xff] ^ (c))
 
-/**     
+/**
  * fcs_compute10 - memcpy and calculate 10 bit CRC across buffer
  * @sp: pointer to buffer
  * @len: number of bytes
@@ -187,13 +206,13 @@ static const __u16 crc10_table[256] = {
  * Perform a memcpy and calculate fcs using ppp 10bit CRC algorithm. Return
  * new 10 bit FCS.
  */
-static __u16 __inline__ fcs_compute10 (unsigned char *sp, int len, __u16 fcs)
+static __u16 __inline__ fcs_compute10(unsigned char *sp, int len, __u16 fcs)
 {
-	for (; len-- > 0; fcs = CRC10_FCS (fcs, *sp++));
+	for (; len-- > 0; fcs = CRC10_FCS(fcs, *sp++));
 	return fcs;
 }
 
-static void safe_read_bulk_callback (struct urb *urb)
+static void safe_read_bulk_callback(struct urb *urb)
 {
 	struct usb_serial_port *port =  urb->context;
 	unsigned char *data = urb->transfer_buffer;
@@ -201,7 +220,7 @@ static void safe_read_bulk_callback (struct urb *urb)
 	int result;
 	int status = urb->status;
 
-	dbg ("%s", __func__);
+	dbg("%s", __func__);
 
 	if (status) {
 		dbg("%s - nonzero read bulk status received: %d",
@@ -209,50 +228,55 @@ static void safe_read_bulk_callback (struct urb *urb)
 		return;
 	}
 
-	dbg ("safe_read_bulk_callback length: %d", port->read_urb->actual_length);
+	dbg("safe_read_bulk_callback length: %d",
+					port->read_urb->actual_length);
 #ifdef ECHO_RCV
 	{
 		int i;
 		unsigned char *cp = port->read_urb->transfer_buffer;
 		for (i = 0; i < port->read_urb->actual_length; i++) {
-			if ((i % 32) == 0) {
-				printk ("\nru[%02x] ", i);
-			}
-			printk ("%02x ", *cp++);
+			if ((i % 32) == 0)
+				printk("\nru[%02x] ", i);
+			printk("%02x ", *cp++);
 		}
-		printk ("\n");
+		printk("\n");
 	}
 #endif
 	if (safe) {
 		__u16 fcs;
-		if (!(fcs = fcs_compute10 (data, length, CRC10_INITFCS))) {
+		fcs = fcs_compute10(data, length, CRC10_INITFCS);
+		if (!fcs) {
 			int actual_length = data[length - 2] >> 2;
 			if (actual_length <= (length - 2)) {
-				info ("%s - actual: %d", __func__, actual_length);
-				tty_insert_flip_string(port->port.tty, data, actual_length);
-				tty_flip_buffer_push (port->port.tty);
+				info("%s - actual: %d", __func__,
+							actual_length);
+				tty_insert_flip_string(port->port.tty,
+							data, actual_length);
+				tty_flip_buffer_push(port->port.tty);
 			} else {
-				err ("%s - inconsistent lengths %d:%d", __func__,
-				     actual_length, length);
+				err("%s - inconsistent lengths %d:%d",
+					__func__, actual_length, length);
 			}
 		} else {
-			err ("%s - bad CRC %x", __func__, fcs);
+			err("%s - bad CRC %x", __func__, fcs);
 		}
 	} else {
 		tty_insert_flip_string(port->port.tty, data, length);
-		tty_flip_buffer_push (port->port.tty);
+		tty_flip_buffer_push(port->port.tty);
 	}
 
 	/* Continue trying to always read  */
-	usb_fill_bulk_urb (urb, port->serial->dev,
-		       usb_rcvbulkpipe (port->serial->dev, port->bulk_in_endpointAddress),
-		       urb->transfer_buffer, urb->transfer_buffer_length,
-		       safe_read_bulk_callback, port);
-
-	if ((result = usb_submit_urb (urb, GFP_ATOMIC))) {
-		err ("%s - failed resubmitting read urb, error %d", __func__, result);
+	usb_fill_bulk_urb(urb, port->serial->dev,
+			usb_rcvbulkpipe(port->serial->dev,
+					port->bulk_in_endpointAddress),
+			urb->transfer_buffer, urb->transfer_buffer_length,
+			safe_read_bulk_callback, port);
+
+	result = usb_submit_urb(urb, GFP_ATOMIC);
+	if (result)
+		err("%s - failed resubmitting read urb, error %d",
+							__func__, result);
 		/* FIXME: Need a mechanism to retry later if this happens */
-	}
 }
 
 static int safe_write(struct tty_struct *tty, struct usb_serial_port *port,
@@ -263,23 +287,23 @@ static int safe_write(struct tty_struct *tty, struct usb_serial_port *port,
 	int i;
 	int packet_length;
 
-	dbg ("safe_write port: %p %d urb: %p count: %d", port, port->number, port->write_urb,
-	     count);
+	dbg("safe_write port: %p %d urb: %p count: %d",
+				port, port->number, port->write_urb, count);
 
 	if (!port->write_urb) {
-		dbg ("%s - write urb NULL", __func__);
+		dbg("%s - write urb NULL", __func__);
 		return 0;
 	}
 
-	dbg ("safe_write write_urb: %d transfer_buffer_length",
+	dbg("safe_write write_urb: %d transfer_buffer_length",
 	     port->write_urb->transfer_buffer_length);
 
 	if (!port->write_urb->transfer_buffer_length) {
-		dbg ("%s - write urb transfer_buffer_length zero", __func__);
+		dbg("%s - write urb transfer_buffer_length zero", __func__);
 		return 0;
 	}
 	if (count == 0) {
-		dbg ("%s - write request of 0 bytes", __func__);
+		dbg("%s - write request of 0 bytes", __func__);
 		return 0;
 	}
 	spin_lock_bh(&port->lock);
@@ -291,63 +315,64 @@ static int safe_write(struct tty_struct *tty, struct usb_serial_port *port,
 	port->write_urb_busy = 1;
 	spin_unlock_bh(&port->lock);
 
-	packet_length = port->bulk_out_size;	// get max packetsize
+	packet_length = port->bulk_out_size;	/* get max packetsize */
 
-	i = packet_length - (safe ? 2 : 0);	// get bytes to send
+	i = packet_length - (safe ? 2 : 0);	/* get bytes to send */
 	count = (count > i) ? i : count;
 
 
-	// get the data into the transfer buffer
+	/* get the data into the transfer buffer */
 	data = port->write_urb->transfer_buffer;
-	memset (data, '0', packet_length);
+	memset(data, '0', packet_length);
 
-	memcpy (data, buf, count);
+	memcpy(data, buf, count);
 
 	if (safe) {
 		__u16 fcs;
 
-		// pad if necessary
-		if (!padded) {
+		/* pad if necessary */
+		if (!padded)
 			packet_length = count + 2;
-		}
-		// set count
+		/* set count */
 		data[packet_length - 2] = count << 2;
 		data[packet_length - 1] = 0;
 
-		// compute fcs and insert into trailer
-		fcs = fcs_compute10 (data, packet_length, CRC10_INITFCS);
+		/* compute fcs and insert into trailer */
+		fcs = fcs_compute10(data, packet_length, CRC10_INITFCS);
 		data[packet_length - 2] |= fcs >> 8;
 		data[packet_length - 1] |= fcs & 0xff;
 
-		// set length to send
+		/* set length to send */
 		port->write_urb->transfer_buffer_length = packet_length;
 	} else {
 		port->write_urb->transfer_buffer_length = count;
 	}
 
-	usb_serial_debug_data(debug, &port->dev, __func__, count, port->write_urb->transfer_buffer);
+	usb_serial_debug_data(debug, &port->dev, __func__, count,
+					port->write_urb->transfer_buffer);
 #ifdef ECHO_TX
 	{
 		int i;
 		unsigned char *cp = port->write_urb->transfer_buffer;
 		for (i = 0; i < port->write_urb->transfer_buffer_length; i++) {
-			if ((i % 32) == 0) {
-				printk ("\nsu[%02x] ", i);
-			}
-			printk ("%02x ", *cp++);
+			if ((i % 32) == 0)
+				printk("\nsu[%02x] ", i);
+			printk("%02x ", *cp++);
 		}
-		printk ("\n");
+		printk("\n");
 	}
 #endif
 	port->write_urb->dev = port->serial->dev;
-	if ((result = usb_submit_urb (port->write_urb, GFP_KERNEL))) {
+	result = usb_submit_urb(port->write_urb, GFP_KERNEL);
+	if (result) {
 		port->write_urb_busy = 0;
-		err ("%s - failed submitting write urb, error %d", __func__, result);
+		err("%s - failed submitting write urb, error %d",
+							__func__, result);
 		return 0;
 	}
-	dbg ("%s urb: %p submitted", __func__, port->write_urb);
+	dbg("%s urb: %p submitted", __func__, port->write_urb);
 
-	return (count);
+	return count;
 }
 
 static int safe_write_room(struct tty_struct *tty)
@@ -356,21 +381,19 @@ static int safe_write_room(struct tty_struct *tty)
 	int room = 0;		/* Default: no room */
 	unsigned long flags;
 
-	dbg ("%s", __func__);
+	dbg("%s", __func__);
 
 	spin_lock_irqsave(&port->lock, flags);
 	if (port->write_urb_busy)
 		room = port->bulk_out_size - (safe ? 2 : 0);
 	spin_unlock_irqrestore(&port->lock, flags);
 
-	if (room) {
-		dbg ("safe_write_room returns %d", room);
-	}
-
+	if (room)
+		dbg("safe_write_room returns %d", room);
 	return room;
 }
 
-static int safe_startup (struct usb_serial *serial)
+static int safe_startup(struct usb_serial *serial)
 {
 	switch (serial->interface->cur_altsetting->desc.bInterfaceProtocol) {
 	case LINEO_SAFESERIAL_CRC:
@@ -398,17 +421,18 @@ static struct usb_serial_driver safe_device = {
 	.attach =		safe_startup,
 };
 
-static int __init safe_init (void)
+static int __init safe_init(void)
 {
 	int i, retval;
 
-	info (DRIVER_VERSION " " DRIVER_AUTHOR);
-	info (DRIVER_DESC);
-	info ("vendor: %x product: %x safe: %d padded: %d\n", vendor, product, safe, padded);
+	info(DRIVER_VERSION " " DRIVER_AUTHOR);
+	info(DRIVER_DESC);
+	info("vendor: %x product: %x safe: %d padded: %d\n",
+					vendor, product, safe, padded);
 
-	// if we have vendor / product parameters patch them into id list
+	/* if we have vendor / product parameters patch them into id list */
 	if (vendor || product) {
-		info ("vendor: %x product: %x\n", vendor, product);
+		info("vendor: %x product: %x\n", vendor, product);
 
 		for (i = 0; i < ARRAY_SIZE(id_table); i++) {
 			if (!id_table[i].idVendor && !id_table[i].idProduct) {
@@ -433,11 +457,11 @@ static int __init safe_init (void)
 	return retval;
 }
 
-static void __exit safe_exit (void)
+static void __exit safe_exit(void)
 {
-	usb_deregister (&safe_driver);
-	usb_serial_deregister (&safe_device);
+	usb_deregister(&safe_driver);
+	usb_serial_deregister(&safe_device);
 }
 
-module_init (safe_init);
-module_exit (safe_exit);
+module_init(safe_init);
+module_exit(safe_exit);

commit 95da310e66ee8090119596c70ca8432e57f9a97f
Author: Alan Cox <alan@redhat.com>
Date:   Tue Jul 22 11:09:07 2008 +0100

    usb_serial: API all change
    
    USB serial likes to use port->tty back pointers for the real work it does and
    to do so without any actual locking. Unfortunately when you consider hangup
    events, hangup/parallel reopen or even worse hangup followed by parallel close
    events the tty->port and port->tty pointers are not guaranteed to be the same
    as port->tty is the active tty while tty->port is the port the tty may or
    may not still be attached to.
    
    So rework the entire API to pass the tty struct. For console cases we need
    to pass both for now. This shows up multiple drivers that immediately crash
    with USB console some of which have been fixed in the process.
    
    Longer term we need a proper tty as console abstraction
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/usb/serial/safe_serial.c b/drivers/usb/serial/safe_serial.c
index 94bddf06ea4f..f823e4dcea1e 100644
--- a/drivers/usb/serial/safe_serial.c
+++ b/drivers/usb/serial/safe_serial.c
@@ -229,8 +229,8 @@ static void safe_read_bulk_callback (struct urb *urb)
 			int actual_length = data[length - 2] >> 2;
 			if (actual_length <= (length - 2)) {
 				info ("%s - actual: %d", __func__, actual_length);
-				tty_insert_flip_string(port->tty, data, actual_length);
-				tty_flip_buffer_push (port->tty);
+				tty_insert_flip_string(port->port.tty, data, actual_length);
+				tty_flip_buffer_push (port->port.tty);
 			} else {
 				err ("%s - inconsistent lengths %d:%d", __func__,
 				     actual_length, length);
@@ -239,8 +239,8 @@ static void safe_read_bulk_callback (struct urb *urb)
 			err ("%s - bad CRC %x", __func__, fcs);
 		}
 	} else {
-		tty_insert_flip_string(port->tty, data, length);
-		tty_flip_buffer_push (port->tty);
+		tty_insert_flip_string(port->port.tty, data, length);
+		tty_flip_buffer_push (port->port.tty);
 	}
 
 	/* Continue trying to always read  */
@@ -255,7 +255,8 @@ static void safe_read_bulk_callback (struct urb *urb)
 	}
 }
 
-static int safe_write (struct usb_serial_port *port, const unsigned char *buf, int count)
+static int safe_write(struct tty_struct *tty, struct usb_serial_port *port,
+					const unsigned char *buf, int count)
 {
 	unsigned char *data;
 	int result;
@@ -349,8 +350,9 @@ static int safe_write (struct usb_serial_port *port, const unsigned char *buf, i
 	return (count);
 }
 
-static int safe_write_room (struct usb_serial_port *port)
+static int safe_write_room(struct tty_struct *tty)
 {
+	struct usb_serial_port *port = tty->driver_data;
 	int room = 0;		/* Default: no room */
 	unsigned long flags;
 

commit cdc97792289179974af6dda781c855696358d307
Author: Ming Lei <tom.leiming@gmail.com>
Date:   Sun Feb 24 18:41:47 2008 +0800

    USB: remove unnecessary type casting of urb->context
    
    urb->context code cleanup
    
    Signed-off-by: Ming Lei <tom.leiming@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/safe_serial.c b/drivers/usb/serial/safe_serial.c
index e6acac49a9c8..94bddf06ea4f 100644
--- a/drivers/usb/serial/safe_serial.c
+++ b/drivers/usb/serial/safe_serial.c
@@ -195,7 +195,7 @@ static __u16 __inline__ fcs_compute10 (unsigned char *sp, int len, __u16 fcs)
 
 static void safe_read_bulk_callback (struct urb *urb)
 {
-	struct usb_serial_port *port = (struct usb_serial_port *) urb->context;
+	struct usb_serial_port *port =  urb->context;
 	unsigned char *data = urb->transfer_buffer;
 	unsigned char length = urb->actual_length;
 	int result;

commit a5b6f60c5a30c494017c7a2d11c4067f90d3d0df
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Tue Apr 8 17:16:06 2008 +0100

    usb serial: more fixes and groundwork for tty changes
    
     - If a termios change fails due to lack of memory we should copy the
       old settings back over as the device has not changed
     - Note various locking problems
     - kl5kusb105 had various remaining tty flag handling problems
     - Make safe_serial use tty_insert_flip_string not open coded loops
     - set termios speed properly in usb_serial
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/safe_serial.c b/drivers/usb/serial/safe_serial.c
index 3fe98a52b914..e6acac49a9c8 100644
--- a/drivers/usb/serial/safe_serial.c
+++ b/drivers/usb/serial/safe_serial.c
@@ -198,7 +198,6 @@ static void safe_read_bulk_callback (struct urb *urb)
 	struct usb_serial_port *port = (struct usb_serial_port *) urb->context;
 	unsigned char *data = urb->transfer_buffer;
 	unsigned char length = urb->actual_length;
-	int i;
 	int result;
 	int status = urb->status;
 
@@ -227,16 +226,10 @@ static void safe_read_bulk_callback (struct urb *urb)
 	if (safe) {
 		__u16 fcs;
 		if (!(fcs = fcs_compute10 (data, length, CRC10_INITFCS))) {
-
 			int actual_length = data[length - 2] >> 2;
-
 			if (actual_length <= (length - 2)) {
-
 				info ("%s - actual: %d", __func__, actual_length);
-
-				for (i = 0; i < actual_length; i++) {
-					tty_insert_flip_char (port->tty, data[i], 0);
-				}
+				tty_insert_flip_string(port->tty, data, actual_length);
 				tty_flip_buffer_push (port->tty);
 			} else {
 				err ("%s - inconsistent lengths %d:%d", __func__,
@@ -246,9 +239,7 @@ static void safe_read_bulk_callback (struct urb *urb)
 			err ("%s - bad CRC %x", __func__, fcs);
 		}
 	} else {
-		for (i = 0; i < length; i++) {
-			tty_insert_flip_char (port->tty, data[i], 0);
-		}
+		tty_insert_flip_string(port->tty, data, length);
 		tty_flip_buffer_push (port->tty);
 	}
 
@@ -260,6 +251,7 @@ static void safe_read_bulk_callback (struct urb *urb)
 
 	if ((result = usb_submit_urb (urb, GFP_ATOMIC))) {
 		err ("%s - failed resubmitting read urb, error %d", __func__, result);
+		/* FIXME: Need a mechanism to retry later if this happens */
 	}
 }
 
@@ -275,7 +267,7 @@ static int safe_write (struct usb_serial_port *port, const unsigned char *buf, i
 
 	if (!port->write_urb) {
 		dbg ("%s - write urb NULL", __func__);
-		return (0);
+		return 0;
 	}
 
 	dbg ("safe_write write_urb: %d transfer_buffer_length",
@@ -283,11 +275,11 @@ static int safe_write (struct usb_serial_port *port, const unsigned char *buf, i
 
 	if (!port->write_urb->transfer_buffer_length) {
 		dbg ("%s - write urb transfer_buffer_length zero", __func__);
-		return (0);
+		return 0;
 	}
 	if (count == 0) {
 		dbg ("%s - write request of 0 bytes", __func__);
-		return (0);
+		return 0;
 	}
 	spin_lock_bh(&port->lock);
 	if (port->write_urb_busy) {
@@ -359,18 +351,21 @@ static int safe_write (struct usb_serial_port *port, const unsigned char *buf, i
 
 static int safe_write_room (struct usb_serial_port *port)
 {
-	int room = 0;		// Default: no room
+	int room = 0;		/* Default: no room */
+	unsigned long flags;
 
 	dbg ("%s", __func__);
 
+	spin_lock_irqsave(&port->lock, flags);
 	if (port->write_urb_busy)
 		room = port->bulk_out_size - (safe ? 2 : 0);
+	spin_unlock_irqrestore(&port->lock, flags);
 
 	if (room) {
 		dbg ("safe_write_room returns %d", room);
 	}
 
-	return (room);
+	return room;
 }
 
 static int safe_startup (struct usb_serial *serial)

commit 441b62c1edb986827154768d89bbac0ba779984f
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Mon Mar 3 16:08:34 2008 -0800

    USB: replace remaining __FUNCTION__ occurrences
    
    __FUNCTION__ is gcc-specific, use __func__
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/safe_serial.c b/drivers/usb/serial/safe_serial.c
index 353c54fa0580..3fe98a52b914 100644
--- a/drivers/usb/serial/safe_serial.c
+++ b/drivers/usb/serial/safe_serial.c
@@ -202,11 +202,11 @@ static void safe_read_bulk_callback (struct urb *urb)
 	int result;
 	int status = urb->status;
 
-	dbg ("%s", __FUNCTION__);
+	dbg ("%s", __func__);
 
 	if (status) {
 		dbg("%s - nonzero read bulk status received: %d",
-		    __FUNCTION__, status);
+		    __func__, status);
 		return;
 	}
 
@@ -232,18 +232,18 @@ static void safe_read_bulk_callback (struct urb *urb)
 
 			if (actual_length <= (length - 2)) {
 
-				info ("%s - actual: %d", __FUNCTION__, actual_length);
+				info ("%s - actual: %d", __func__, actual_length);
 
 				for (i = 0; i < actual_length; i++) {
 					tty_insert_flip_char (port->tty, data[i], 0);
 				}
 				tty_flip_buffer_push (port->tty);
 			} else {
-				err ("%s - inconsistent lengths %d:%d", __FUNCTION__,
+				err ("%s - inconsistent lengths %d:%d", __func__,
 				     actual_length, length);
 			}
 		} else {
-			err ("%s - bad CRC %x", __FUNCTION__, fcs);
+			err ("%s - bad CRC %x", __func__, fcs);
 		}
 	} else {
 		for (i = 0; i < length; i++) {
@@ -259,7 +259,7 @@ static void safe_read_bulk_callback (struct urb *urb)
 		       safe_read_bulk_callback, port);
 
 	if ((result = usb_submit_urb (urb, GFP_ATOMIC))) {
-		err ("%s - failed resubmitting read urb, error %d", __FUNCTION__, result);
+		err ("%s - failed resubmitting read urb, error %d", __func__, result);
 	}
 }
 
@@ -274,7 +274,7 @@ static int safe_write (struct usb_serial_port *port, const unsigned char *buf, i
 	     count);
 
 	if (!port->write_urb) {
-		dbg ("%s - write urb NULL", __FUNCTION__);
+		dbg ("%s - write urb NULL", __func__);
 		return (0);
 	}
 
@@ -282,17 +282,17 @@ static int safe_write (struct usb_serial_port *port, const unsigned char *buf, i
 	     port->write_urb->transfer_buffer_length);
 
 	if (!port->write_urb->transfer_buffer_length) {
-		dbg ("%s - write urb transfer_buffer_length zero", __FUNCTION__);
+		dbg ("%s - write urb transfer_buffer_length zero", __func__);
 		return (0);
 	}
 	if (count == 0) {
-		dbg ("%s - write request of 0 bytes", __FUNCTION__);
+		dbg ("%s - write request of 0 bytes", __func__);
 		return (0);
 	}
 	spin_lock_bh(&port->lock);
 	if (port->write_urb_busy) {
 		spin_unlock_bh(&port->lock);
-		dbg("%s - already writing", __FUNCTION__);
+		dbg("%s - already writing", __func__);
 		return 0;
 	}
 	port->write_urb_busy = 1;
@@ -332,7 +332,7 @@ static int safe_write (struct usb_serial_port *port, const unsigned char *buf, i
 		port->write_urb->transfer_buffer_length = count;
 	}
 
-	usb_serial_debug_data(debug, &port->dev, __FUNCTION__, count, port->write_urb->transfer_buffer);
+	usb_serial_debug_data(debug, &port->dev, __func__, count, port->write_urb->transfer_buffer);
 #ifdef ECHO_TX
 	{
 		int i;
@@ -349,10 +349,10 @@ static int safe_write (struct usb_serial_port *port, const unsigned char *buf, i
 	port->write_urb->dev = port->serial->dev;
 	if ((result = usb_submit_urb (port->write_urb, GFP_KERNEL))) {
 		port->write_urb_busy = 0;
-		err ("%s - failed submitting write urb, error %d", __FUNCTION__, result);
+		err ("%s - failed submitting write urb, error %d", __func__, result);
 		return 0;
 	}
-	dbg ("%s urb: %p submitted", __FUNCTION__, port->write_urb);
+	dbg ("%s urb: %p submitted", __func__, port->write_urb);
 
 	return (count);
 }
@@ -361,7 +361,7 @@ static int safe_write_room (struct usb_serial_port *port)
 {
 	int room = 0;		// Default: no room
 
-	dbg ("%s", __FUNCTION__);
+	dbg ("%s", __func__);
 
 	if (port->write_urb_busy)
 		room = port->bulk_out_size - (safe ? 2 : 0);

commit 0ba4034e20abf372dae6c6cabeeeab600acb5889
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed Apr 16 09:17:38 2008 -0700

    USB: serial: remove unneeded number endpoints settings
    
    The usb-serial core no longer checks these fields so remove them from
    all of the individual drivers.  They will be removed from the usb-serial
    core in a patch later in the series.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/safe_serial.c b/drivers/usb/serial/safe_serial.c
index 4e6dcc199be9..353c54fa0580 100644
--- a/drivers/usb/serial/safe_serial.c
+++ b/drivers/usb/serial/safe_serial.c
@@ -394,9 +394,6 @@ static struct usb_serial_driver safe_device = {
 	},
 	.id_table =		id_table,
 	.usb_driver =		&safe_driver,
-	.num_interrupt_in =	NUM_DONT_CARE,
-	.num_bulk_in =		NUM_DONT_CARE,
-	.num_bulk_out =		NUM_DONT_CARE,
 	.num_ports =		1,
 	.write =		safe_write,
 	.write_room =		safe_write_room,

commit 9f705bde6e77c24a3ba737ac45abc0f8e619e92e
Author: Robert P. J. Day <rpjday@mindspring.com>
Date:   Wed Aug 1 18:16:55 2007 -0400

    USB: Remove dead references to "SAFE_SERIAL" CONFIG variables.
    
    Remove the references to CONFIG_USBD_SAFE_SERIAL_{VENDOR,PRODUCT},
    which aren't defined in any Kconfig file.
    
    Signed-off-by: Robert P. J. Day <rpjday@mindspring.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/safe_serial.c b/drivers/usb/serial/safe_serial.c
index 51669b7622bb..4e6dcc199be9 100644
--- a/drivers/usb/serial/safe_serial.c
+++ b/drivers/usb/serial/safe_serial.c
@@ -90,18 +90,12 @@ MODULE_AUTHOR (DRIVER_AUTHOR);
 MODULE_DESCRIPTION (DRIVER_DESC);
 MODULE_LICENSE("GPL");
 
-#if defined(CONFIG_USBD_SAFE_SERIAL_VENDOR) && !defined(CONFIG_USBD_SAFE_SERIAL_PRODUCT)
-#error "SAFE_SERIAL_VENDOR defined without SAFE_SERIAL_PRODUCT"
-#endif
-
-#if ! defined(CONFIG_USBD_SAFE_SERIAL_VENDOR)
 static __u16 vendor;		// no default
 static __u16 product;		// no default
 module_param(vendor, ushort, 0);
 MODULE_PARM_DESC(vendor, "User specified USB idVendor (required)");
 module_param(product, ushort, 0);
 MODULE_PARM_DESC(product, "User specified USB idProduct (required)");
-#endif
 
 module_param(debug, bool, S_IRUGO | S_IWUSR);
 MODULE_PARM_DESC(debug, "Debug enabled or not");
@@ -145,11 +139,6 @@ static struct usb_device_id id_table[] = {
 	{MY_USB_DEVICE (0x4dd, 0x8003, CDC_DEVICE_CLASS, LINEO_INTERFACE_CLASS, LINEO_INTERFACE_SUBCLASS_SAFESERIAL)},	// Collie 
 	{MY_USB_DEVICE (0x4dd, 0x8004, CDC_DEVICE_CLASS, LINEO_INTERFACE_CLASS, LINEO_INTERFACE_SUBCLASS_SAFESERIAL)},	// Collie 
 	{MY_USB_DEVICE (0x5f9, 0xffff, CDC_DEVICE_CLASS, LINEO_INTERFACE_CLASS, LINEO_INTERFACE_SUBCLASS_SAFESERIAL)},	// Sharp tmp
-#if defined(CONFIG_USB_SAFE_SERIAL_VENDOR)
-	{MY_USB_DEVICE
-	 (CONFIG_USB_SAFE_SERIAL_VENDOR, CONFIG_USB_SAFE_SERIAL_PRODUCT, CDC_DEVICE_CLASS,
-	  LINEO_INTERFACE_CLASS, LINEO_INTERFACE_SUBCLASS_SAFESERIAL)},
-#endif
 	// extra null entry for module 
 	// vendor/produc parameters
 	{MY_USB_DEVICE (0, 0, CDC_DEVICE_CLASS, LINEO_INTERFACE_CLASS, LINEO_INTERFACE_SUBCLASS_SAFESERIAL)},

commit 3aec6e26d7655eea07be8bbec4728447274ed43f
Author: Robert P. J. Day <rpjday@mindspring.com>
Date:   Mon Jul 30 06:38:31 2007 -0400

    USB: Typo: "USB_SAFE_PADDED" -> "USB_SERIAL_SAFE_PADDED".
    
    Fix typo in safe_serial.c to match the actual CONFIG variable.
    
    Signed-off-by: Robert P. J. Day <rpjday@mindspring.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/safe_serial.c b/drivers/usb/serial/safe_serial.c
index 86899d55d8d8..51669b7622bb 100644
--- a/drivers/usb/serial/safe_serial.c
+++ b/drivers/usb/serial/safe_serial.c
@@ -74,13 +74,13 @@
 #include <linux/usb/serial.h>
 
 
-#ifndef CONFIG_USB_SAFE_PADDED
-#define CONFIG_USB_SAFE_PADDED 0
+#ifndef CONFIG_USB_SERIAL_SAFE_PADDED
+#define CONFIG_USB_SERIAL_SAFE_PADDED 0
 #endif
 
 static int debug;
 static int safe = 1;
-static int padded = CONFIG_USB_SAFE_PADDED;
+static int padded = CONFIG_USB_SERIAL_SAFE_PADDED;
 
 #define DRIVER_VERSION "v0.0b"
 #define DRIVER_AUTHOR "sl@lineo.com, tbr@lineo.com"

commit 3a75ab943688d765cdb60b33f3f9db72c752c521
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Jun 15 15:44:13 2007 -0700

    USB: serial: safe_serial: clean up urb->status usage
    
    This done in anticipation of removal of urb->status, which will make
    that patch easier to review and apply in the future.
    
    
    Cc: <linux-usb-devel@lists.sourceforge.net>
    Cc: Stuart Lynne <sl@lineo.com>
    Cc: Tom Rushworth <tbr@lineo.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/safe_serial.c b/drivers/usb/serial/safe_serial.c
index 5a03a3fc9386..86899d55d8d8 100644
--- a/drivers/usb/serial/safe_serial.c
+++ b/drivers/usb/serial/safe_serial.c
@@ -211,11 +211,13 @@ static void safe_read_bulk_callback (struct urb *urb)
 	unsigned char length = urb->actual_length;
 	int i;
 	int result;
+	int status = urb->status;
 
 	dbg ("%s", __FUNCTION__);
 
-	if (urb->status) {
-		dbg ("%s - nonzero read bulk status received: %d", __FUNCTION__, urb->status);
+	if (status) {
+		dbg("%s - nonzero read bulk status received: %d",
+		    __FUNCTION__, status);
 		return;
 	}
 

commit d9b1b787736852f462dbf277b3ca708cbbf693ae
Author: Johannes Hölzl <johannes.hoelzl@gmx.de>
Date:   Sun Dec 17 21:50:24 2006 +0100

    USB serial: add driver pointer to all usb-serial drivers
    
    Every usb serial driver should have a pointer to the corresponding usb driver.
    So the usb serial core can add a new id not only to the usb serial driver, but
    also to the usb driver.
    
    Also the usb drivers of ark3116, mos7720 and mos7840 missed the flag
    no_dynamic_id=1. This is added now.
    
    Signed-off-by: Johannes Hölzl <johannes.hoelzl@gmx.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/safe_serial.c b/drivers/usb/serial/safe_serial.c
index 30b7ebc8d45d..5a03a3fc9386 100644
--- a/drivers/usb/serial/safe_serial.c
+++ b/drivers/usb/serial/safe_serial.c
@@ -402,6 +402,7 @@ static struct usb_serial_driver safe_device = {
 		.name =		"safe_serial",
 	},
 	.id_table =		id_table,
+	.usb_driver =		&safe_driver,
 	.num_interrupt_in =	NUM_DONT_CARE,
 	.num_bulk_in =		NUM_DONT_CARE,
 	.num_bulk_out =		NUM_DONT_CARE,

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/drivers/usb/serial/safe_serial.c b/drivers/usb/serial/safe_serial.c
index 1e07dfad6853..30b7ebc8d45d 100644
--- a/drivers/usb/serial/safe_serial.c
+++ b/drivers/usb/serial/safe_serial.c
@@ -204,7 +204,7 @@ static __u16 __inline__ fcs_compute10 (unsigned char *sp, int len, __u16 fcs)
 	return fcs;
 }
 
-static void safe_read_bulk_callback (struct urb *urb, struct pt_regs *regs)
+static void safe_read_bulk_callback (struct urb *urb)
 {
 	struct usb_serial_port *port = (struct usb_serial_port *) urb->context;
 	unsigned char *data = urb->transfer_buffer;

commit e81ee637e4aed723f71007c90a901268317ed6d6
Author: Peter Zijlstra <a.p.zijlstra@chello.nl>
Date:   Mon Sep 25 12:51:41 2006 +0200

    usb-serial: possible irq lock inversion (PPP vs. usb/serial)
    
    =========================================================
    [ INFO: possible irq lock inversion dependency detected ]

diff --git a/drivers/usb/serial/safe_serial.c b/drivers/usb/serial/safe_serial.c
index 789771ecdb11..1e07dfad6853 100644
--- a/drivers/usb/serial/safe_serial.c
+++ b/drivers/usb/serial/safe_serial.c
@@ -298,14 +298,14 @@ static int safe_write (struct usb_serial_port *port, const unsigned char *buf, i
 		dbg ("%s - write request of 0 bytes", __FUNCTION__);
 		return (0);
 	}
-	spin_lock(&port->lock);
+	spin_lock_bh(&port->lock);
 	if (port->write_urb_busy) {
-		spin_unlock(&port->lock);
+		spin_unlock_bh(&port->lock);
 		dbg("%s - already writing", __FUNCTION__);
 		return 0;
 	}
 	port->write_urb_busy = 1;
-	spin_unlock(&port->lock);
+	spin_unlock_bh(&port->lock);
 
 	packet_length = port->bulk_out_size;	// get max packetsize
 

commit a969888ce91673c7f4b86520d851a6f0d5a5fa7d
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Jul 11 21:22:58 2006 -0700

    [PATCH] USB: move usb-serial.h to include/linux/usb/
    
    USB serial outside of the kernel tree can not build properly due to
    usb-serial.h being buried down in the source tree.  This patch moves the
    location of the file to include/linux/usb and fixes up all of the usb
    serial drivers to handle the move properly.
    
    Cc: Sergei Organov <osv@javad.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/safe_serial.c b/drivers/usb/serial/safe_serial.c
index 897d8447252b..789771ecdb11 100644
--- a/drivers/usb/serial/safe_serial.c
+++ b/drivers/usb/serial/safe_serial.c
@@ -71,7 +71,7 @@
 #include <linux/spinlock.h>
 #include <asm/uaccess.h>
 #include <linux/usb.h>
-#include "usb-serial.h"
+#include <linux/usb/serial.h>
 
 
 #ifndef CONFIG_USB_SAFE_PADDED

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jörn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jörn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/drivers/usb/serial/safe_serial.c b/drivers/usb/serial/safe_serial.c
index f0215f850d2d..897d8447252b 100644
--- a/drivers/usb/serial/safe_serial.c
+++ b/drivers/usb/serial/safe_serial.c
@@ -60,7 +60,6 @@
  */
 
 
-#include <linux/config.h>
 #include <linux/kernel.h>
 #include <linux/errno.h>
 #include <linux/init.h>

commit 52950ed40dc97456209979af1d8f51b63cf6dcab
Author: Tobias Klauser <tklauser@nuerscht.ch>
Date:   Sun Dec 11 16:20:08 2005 +0100

    [PATCH] USB: Use ARRAY_SIZE macro
    
    Use ARRAY_SIZE macro instead of sizeof(x)/sizeof(x[0]) and remove
    duplicates of ARRAY_SIZE. Some trailing whitespaces are also removed.
    
    Patch is compile-tested on i386.
    
    Signed-off-by: Tobias Klauser <tklauser@nuerscht.ch>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/safe_serial.c b/drivers/usb/serial/safe_serial.c
index 86dc21c728a5..f0215f850d2d 100644
--- a/drivers/usb/serial/safe_serial.c
+++ b/drivers/usb/serial/safe_serial.c
@@ -425,7 +425,7 @@ static int __init safe_init (void)
 	if (vendor || product) {
 		info ("vendor: %x product: %x\n", vendor, product);
 
-		for (i = 0; i < (sizeof (id_table) / sizeof (struct usb_device_id)); i++) {
+		for (i = 0; i < ARRAY_SIZE(id_table); i++) {
 			if (!id_table[i].idVendor && !id_table[i].idProduct) {
 				id_table[i].idVendor = vendor;
 				id_table[i].idProduct = product;

commit 4c4c9432a6c916729c7296c47fe93b053a73e20c
Author: Arjan van de Ven <arjan@infradead.org>
Date:   Tue Nov 29 09:43:42 2005 +0100

    [PATCH] USB: mark various usb tables const
    
    patch below marks various USB tables and variables as const so that they
    end up in .rodata section and don't cacheline share with things that get
    written to. For the non-array variables it also allows gcc to optimize
    more.
    
    Signed-off-by: Arjan van de Ven <arjan@infradead.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/safe_serial.c b/drivers/usb/serial/safe_serial.c
index 3ea284ce7b8b..86dc21c728a5 100644
--- a/drivers/usb/serial/safe_serial.c
+++ b/drivers/usb/serial/safe_serial.c
@@ -167,7 +167,7 @@ static struct usb_driver safe_driver = {
 	.no_dynamic_id = 	1,
 };
 
-static __u16 crc10_table[256] = {
+static const __u16 crc10_table[256] = {
 	0x000, 0x233, 0x255, 0x066, 0x299, 0x0aa, 0x0cc, 0x2ff, 0x301, 0x132, 0x154, 0x367, 0x198, 0x3ab, 0x3cd, 0x1fe,
 	0x031, 0x202, 0x264, 0x057, 0x2a8, 0x09b, 0x0fd, 0x2ce, 0x330, 0x103, 0x165, 0x356, 0x1a9, 0x39a, 0x3fc, 0x1cf,
 	0x062, 0x251, 0x237, 0x004, 0x2fb, 0x0c8, 0x0ae, 0x29d, 0x363, 0x150, 0x136, 0x305, 0x1fa, 0x3c9, 0x3af, 0x19c,

commit 75318d2d7cab77b14c5d3dbd5e69f2680a769e16
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Nov 21 14:53:03 2005 -0800

    [PATCH] USB: remove .owner field from struct usb_driver
    
    It is no longer needed, so let's remove it, saving a bit of memory.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/safe_serial.c b/drivers/usb/serial/safe_serial.c
index f8241c152043..3ea284ce7b8b 100644
--- a/drivers/usb/serial/safe_serial.c
+++ b/drivers/usb/serial/safe_serial.c
@@ -160,7 +160,6 @@ static struct usb_device_id id_table[] = {
 MODULE_DEVICE_TABLE (usb, id_table);
 
 static struct usb_driver safe_driver = {
-	.owner =	THIS_MODULE,
 	.name =		"safe_serial",
 	.probe =	usb_serial_probe,
 	.disconnect =	usb_serial_disconnect,

commit ba9dc657af86d05d2971633e57d1f6f94ed60472
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed Nov 16 13:41:28 2005 -0800

    [PATCH] USB: allow usb drivers to disable dynamic ids
    
    This lets drivers, like the usb-serial ones, disable the ability to add
    ids from sysfs.
    
    The usb-serial drivers are "odd" in that they are really usb-serial bus
    drivers, not usb bus drivers, so the dynamic id logic will have to go
    into the usb-serial bus core for those drivers to get that ability.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/safe_serial.c b/drivers/usb/serial/safe_serial.c
index c22bdc0c4dfd..f8241c152043 100644
--- a/drivers/usb/serial/safe_serial.c
+++ b/drivers/usb/serial/safe_serial.c
@@ -165,6 +165,7 @@ static struct usb_driver safe_driver = {
 	.probe =	usb_serial_probe,
 	.disconnect =	usb_serial_disconnect,
 	.id_table =	id_table,
+	.no_dynamic_id = 	1,
 };
 
 static __u16 crc10_table[256] = {

commit 269bda1c123c7caf88e1deb2264f9086f0344192
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Jun 20 21:15:16 2005 -0700

    [PATCH] USB Serial: move name to driver structure
    
    This fixes up a lot of problems in sysfs with some of the usb serial
    drivers, they had incorrect driver names.  Also saves a tiny ammount
    of memory.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/safe_serial.c b/drivers/usb/serial/safe_serial.c
index 42a86ab689f4..c22bdc0c4dfd 100644
--- a/drivers/usb/serial/safe_serial.c
+++ b/drivers/usb/serial/safe_serial.c
@@ -400,8 +400,8 @@ static int safe_startup (struct usb_serial *serial)
 static struct usb_serial_driver safe_device = {
 	.driver = {
 		.owner =	THIS_MODULE,
+		.name =		"safe_serial",
 	},
-	.name =			"Safe",
 	.id_table =		id_table,
 	.num_interrupt_in =	NUM_DONT_CARE,
 	.num_bulk_in =		NUM_DONT_CARE,

commit 18fcac353fdc7cd072b0d24c8667042e675a4c11
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Jun 20 21:15:16 2005 -0700

    [PATCH] USB Serial: get rid of the .owner field in usb_serial_driver
    
    Don't duplicate something that's already in struct driver.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/safe_serial.c b/drivers/usb/serial/safe_serial.c
index 87871bb647df..42a86ab689f4 100644
--- a/drivers/usb/serial/safe_serial.c
+++ b/drivers/usb/serial/safe_serial.c
@@ -398,7 +398,9 @@ static int safe_startup (struct usb_serial *serial)
 }
 
 static struct usb_serial_driver safe_device = {
-	.owner =		THIS_MODULE,
+	.driver = {
+		.owner =	THIS_MODULE,
+	},
 	.name =			"Safe",
 	.id_table =		id_table,
 	.num_interrupt_in =	NUM_DONT_CARE,

commit ea65370d025f5005649e5cb37c4d025e92c6fc38
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Jun 20 21:15:16 2005 -0700

    [PATCH] USB Serial: rename usb_serial_device_type to usb_serial_driver
    
    I'm tired of trying to explain why a "device_type" is really a driver.
    This better describes exactly what this structure is.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/safe_serial.c b/drivers/usb/serial/safe_serial.c
index 88bf14abfa7a..87871bb647df 100644
--- a/drivers/usb/serial/safe_serial.c
+++ b/drivers/usb/serial/safe_serial.c
@@ -397,7 +397,7 @@ static int safe_startup (struct usb_serial *serial)
 	return 0;
 }
 
-static struct usb_serial_device_type safe_device = {
+static struct usb_serial_driver safe_device = {
 	.owner =		THIS_MODULE,
 	.name =			"Safe",
 	.id_table =		id_table,

commit 521daed8db4443a1574a98fc3abae8e230f09eaa
Author: Randy Dunlap <rdunlap@xenotime.net>
Date:   Sun Oct 2 17:15:33 2005 -0700

    [PATCH] safe_serial: use preprocessor directive for error
    
    Use valid #preprocessor instruction to generate an error.
    
    Signed-off-by: Randy Dunlap <rdunlap@xenotime.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
     drivers/usb/serial/safe_serial.c |    2 +-
     1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/drivers/usb/serial/safe_serial.c b/drivers/usb/serial/safe_serial.c
index 96a17568cbf1..88bf14abfa7a 100644
--- a/drivers/usb/serial/safe_serial.c
+++ b/drivers/usb/serial/safe_serial.c
@@ -92,7 +92,7 @@ MODULE_DESCRIPTION (DRIVER_DESC);
 MODULE_LICENSE("GPL");
 
 #if defined(CONFIG_USBD_SAFE_SERIAL_VENDOR) && !defined(CONFIG_USBD_SAFE_SERIAL_PRODUCT)
-#abort "SAFE_SERIAL_VENDOR defined without SAFE_SERIAL_PRODUCT"
+#error "SAFE_SERIAL_VENDOR defined without SAFE_SERIAL_PRODUCT"
 #endif
 
 #if ! defined(CONFIG_USBD_SAFE_SERIAL_VENDOR)

commit 507ca9bc0476662f3463888d583864834eab1e11
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Sat Apr 23 12:49:16 2005 -0700

    [PATCH] USB: add ability for usb-serial drivers to determine if their write urb is currently being used.
    
    This removes a lot of racy and buggy code by trying to check the status of the urb.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/safe_serial.c b/drivers/usb/serial/safe_serial.c
index 0e85ed6c6c19..96a17568cbf1 100644
--- a/drivers/usb/serial/safe_serial.c
+++ b/drivers/usb/serial/safe_serial.c
@@ -299,10 +299,14 @@ static int safe_write (struct usb_serial_port *port, const unsigned char *buf, i
 		dbg ("%s - write request of 0 bytes", __FUNCTION__);
 		return (0);
 	}
-	if (port->write_urb->status == -EINPROGRESS) {
-		dbg ("%s - already writing", __FUNCTION__);
-		return (0);
+	spin_lock(&port->lock);
+	if (port->write_urb_busy) {
+		spin_unlock(&port->lock);
+		dbg("%s - already writing", __FUNCTION__);
+		return 0;
 	}
+	port->write_urb_busy = 1;
+	spin_unlock(&port->lock);
 
 	packet_length = port->bulk_out_size;	// get max packetsize
 
@@ -354,6 +358,7 @@ static int safe_write (struct usb_serial_port *port, const unsigned char *buf, i
 #endif
 	port->write_urb->dev = port->serial->dev;
 	if ((result = usb_submit_urb (port->write_urb, GFP_KERNEL))) {
+		port->write_urb_busy = 0;
 		err ("%s - failed submitting write urb, error %d", __FUNCTION__, result);
 		return 0;
 	}
@@ -368,7 +373,7 @@ static int safe_write_room (struct usb_serial_port *port)
 
 	dbg ("%s", __FUNCTION__);
 
-	if (port->write_urb->status != -EINPROGRESS)
+	if (port->write_urb_busy)
 		room = port->bulk_out_size - (safe ? 2 : 0);
 
 	if (room) {

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/usb/serial/safe_serial.c b/drivers/usb/serial/safe_serial.c
new file mode 100644
index 000000000000..0e85ed6c6c19
--- /dev/null
+++ b/drivers/usb/serial/safe_serial.c
@@ -0,0 +1,451 @@
+/*
+ * Safe Encapsulated USB Serial Driver
+ *
+ *      Copyright (C) 2001 Lineo
+ *      Copyright (C) 2001 Hewlett-Packard
+ *
+ *	This program is free software; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License as published by
+ *	the Free Software Foundation; either version 2 of the License, or
+ *	(at your option) any later version.
+ *
+ * By:
+ *      Stuart Lynne <sl@lineo.com>, Tom Rushworth <tbr@lineo.com>
+ */
+
+/* 
+ * The encapsultaion is designed to overcome difficulties with some USB hardware.
+ *
+ * While the USB protocol has a CRC over the data while in transit, i.e. while
+ * being carried over the bus, there is no end to end protection. If the hardware
+ * has any problems getting the data into or out of the USB transmit and receive
+ * FIFO's then data can be lost. 
+ *
+ * This protocol adds a two byte trailer to each USB packet to specify the number
+ * of bytes of valid data and a 10 bit CRC that will allow the receiver to verify
+ * that the entire USB packet was received without error.
+ *
+ * Because in this case the sender and receiver are the class and function drivers
+ * there is now end to end protection.
+ *
+ * There is an additional option that can be used to force all transmitted packets
+ * to be padded to the maximum packet size. This provides a work around for some
+ * devices which have problems with small USB packets.
+ *
+ * Assuming a packetsize of N:
+ *
+ *      0..N-2  data and optional padding
+ *
+ *      N-2     bits 7-2 - number of bytes of valid data
+ *              bits 1-0 top two bits of 10 bit CRC
+ *      N-1     bottom 8 bits of 10 bit CRC
+ *
+ *
+ *      | Data Length       | 10 bit CRC                                |
+ *      + 7 . 6 . 5 . 4 . 3 . 2 . 1 . 0 | 7 . 6 . 5 . 4 . 3 . 2 . 1 . 0 +
+ *
+ * The 10 bit CRC is computed across the sent data, followed by the trailer with
+ * the length set and the CRC set to zero. The CRC is then OR'd into the trailer.
+ *
+ * When received a 10 bit CRC is computed over the entire frame including the trailer
+ * and should be equal to zero.
+ *
+ * Two module parameters are used to control the encapsulation, if both are
+ * turned of the module works as a simple serial device with NO
+ * encapsulation.
+ *
+ * See linux/drivers/usbd/serial_fd for a device function driver
+ * implementation of this.
+ *
+ */
+
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/tty.h>
+#include <linux/tty_driver.h>
+#include <linux/tty_flip.h>
+#include <linux/module.h>
+#include <linux/spinlock.h>
+#include <asm/uaccess.h>
+#include <linux/usb.h>
+#include "usb-serial.h"
+
+
+#ifndef CONFIG_USB_SAFE_PADDED
+#define CONFIG_USB_SAFE_PADDED 0
+#endif
+
+static int debug;
+static int safe = 1;
+static int padded = CONFIG_USB_SAFE_PADDED;
+
+#define DRIVER_VERSION "v0.0b"
+#define DRIVER_AUTHOR "sl@lineo.com, tbr@lineo.com"
+#define DRIVER_DESC "USB Safe Encapsulated Serial"
+
+MODULE_AUTHOR (DRIVER_AUTHOR);
+MODULE_DESCRIPTION (DRIVER_DESC);
+MODULE_LICENSE("GPL");
+
+#if defined(CONFIG_USBD_SAFE_SERIAL_VENDOR) && !defined(CONFIG_USBD_SAFE_SERIAL_PRODUCT)
+#abort "SAFE_SERIAL_VENDOR defined without SAFE_SERIAL_PRODUCT"
+#endif
+
+#if ! defined(CONFIG_USBD_SAFE_SERIAL_VENDOR)
+static __u16 vendor;		// no default
+static __u16 product;		// no default
+module_param(vendor, ushort, 0);
+MODULE_PARM_DESC(vendor, "User specified USB idVendor (required)");
+module_param(product, ushort, 0);
+MODULE_PARM_DESC(product, "User specified USB idProduct (required)");
+#endif
+
+module_param(debug, bool, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(debug, "Debug enabled or not");
+
+module_param(safe, bool, 0);
+MODULE_PARM_DESC(safe, "Turn Safe Encapsulation On/Off");
+
+module_param(padded, bool, 0);
+MODULE_PARM_DESC(padded, "Pad to full wMaxPacketSize On/Off");
+
+#define CDC_DEVICE_CLASS                        0x02
+
+#define CDC_INTERFACE_CLASS                     0x02
+#define CDC_INTERFACE_SUBCLASS                  0x06
+
+#define LINEO_INTERFACE_CLASS                   0xff
+
+#define LINEO_INTERFACE_SUBCLASS_SAFENET        0x01
+#define LINEO_SAFENET_CRC                       0x01
+#define LINEO_SAFENET_CRC_PADDED                0x02
+
+#define LINEO_INTERFACE_SUBCLASS_SAFESERIAL     0x02
+#define LINEO_SAFESERIAL_CRC                    0x01
+#define LINEO_SAFESERIAL_CRC_PADDED             0x02
+
+
+#define MY_USB_DEVICE(vend,prod,dc,ic,isc) \
+        .match_flags = USB_DEVICE_ID_MATCH_DEVICE | USB_DEVICE_ID_MATCH_DEV_CLASS | \
+                USB_DEVICE_ID_MATCH_INT_CLASS | USB_DEVICE_ID_MATCH_INT_SUBCLASS, \
+        .idVendor = (vend), \
+        .idProduct = (prod),\
+        .bDeviceClass = (dc),\
+        .bInterfaceClass = (ic), \
+        .bInterfaceSubClass = (isc),
+
+static struct usb_device_id id_table[] = {
+	{MY_USB_DEVICE (0x49f, 0xffff, CDC_DEVICE_CLASS, LINEO_INTERFACE_CLASS, LINEO_INTERFACE_SUBCLASS_SAFESERIAL)},	// Itsy
+	{MY_USB_DEVICE (0x3f0, 0x2101, CDC_DEVICE_CLASS, LINEO_INTERFACE_CLASS, LINEO_INTERFACE_SUBCLASS_SAFESERIAL)},	// Calypso
+	{MY_USB_DEVICE (0x4dd, 0x8001, CDC_DEVICE_CLASS, LINEO_INTERFACE_CLASS, LINEO_INTERFACE_SUBCLASS_SAFESERIAL)},	// Iris 
+	{MY_USB_DEVICE (0x4dd, 0x8002, CDC_DEVICE_CLASS, LINEO_INTERFACE_CLASS, LINEO_INTERFACE_SUBCLASS_SAFESERIAL)},	// Collie 
+	{MY_USB_DEVICE (0x4dd, 0x8003, CDC_DEVICE_CLASS, LINEO_INTERFACE_CLASS, LINEO_INTERFACE_SUBCLASS_SAFESERIAL)},	// Collie 
+	{MY_USB_DEVICE (0x4dd, 0x8004, CDC_DEVICE_CLASS, LINEO_INTERFACE_CLASS, LINEO_INTERFACE_SUBCLASS_SAFESERIAL)},	// Collie 
+	{MY_USB_DEVICE (0x5f9, 0xffff, CDC_DEVICE_CLASS, LINEO_INTERFACE_CLASS, LINEO_INTERFACE_SUBCLASS_SAFESERIAL)},	// Sharp tmp
+#if defined(CONFIG_USB_SAFE_SERIAL_VENDOR)
+	{MY_USB_DEVICE
+	 (CONFIG_USB_SAFE_SERIAL_VENDOR, CONFIG_USB_SAFE_SERIAL_PRODUCT, CDC_DEVICE_CLASS,
+	  LINEO_INTERFACE_CLASS, LINEO_INTERFACE_SUBCLASS_SAFESERIAL)},
+#endif
+	// extra null entry for module 
+	// vendor/produc parameters
+	{MY_USB_DEVICE (0, 0, CDC_DEVICE_CLASS, LINEO_INTERFACE_CLASS, LINEO_INTERFACE_SUBCLASS_SAFESERIAL)},
+	{}			// terminating entry 
+};
+
+MODULE_DEVICE_TABLE (usb, id_table);
+
+static struct usb_driver safe_driver = {
+	.owner =	THIS_MODULE,
+	.name =		"safe_serial",
+	.probe =	usb_serial_probe,
+	.disconnect =	usb_serial_disconnect,
+	.id_table =	id_table,
+};
+
+static __u16 crc10_table[256] = {
+	0x000, 0x233, 0x255, 0x066, 0x299, 0x0aa, 0x0cc, 0x2ff, 0x301, 0x132, 0x154, 0x367, 0x198, 0x3ab, 0x3cd, 0x1fe,
+	0x031, 0x202, 0x264, 0x057, 0x2a8, 0x09b, 0x0fd, 0x2ce, 0x330, 0x103, 0x165, 0x356, 0x1a9, 0x39a, 0x3fc, 0x1cf,
+	0x062, 0x251, 0x237, 0x004, 0x2fb, 0x0c8, 0x0ae, 0x29d, 0x363, 0x150, 0x136, 0x305, 0x1fa, 0x3c9, 0x3af, 0x19c,
+	0x053, 0x260, 0x206, 0x035, 0x2ca, 0x0f9, 0x09f, 0x2ac, 0x352, 0x161, 0x107, 0x334, 0x1cb, 0x3f8, 0x39e, 0x1ad,
+	0x0c4, 0x2f7, 0x291, 0x0a2, 0x25d, 0x06e, 0x008, 0x23b, 0x3c5, 0x1f6, 0x190, 0x3a3, 0x15c, 0x36f, 0x309, 0x13a,
+	0x0f5, 0x2c6, 0x2a0, 0x093, 0x26c, 0x05f, 0x039, 0x20a, 0x3f4, 0x1c7, 0x1a1, 0x392, 0x16d, 0x35e, 0x338, 0x10b,
+	0x0a6, 0x295, 0x2f3, 0x0c0, 0x23f, 0x00c, 0x06a, 0x259, 0x3a7, 0x194, 0x1f2, 0x3c1, 0x13e, 0x30d, 0x36b, 0x158,
+	0x097, 0x2a4, 0x2c2, 0x0f1, 0x20e, 0x03d, 0x05b, 0x268, 0x396, 0x1a5, 0x1c3, 0x3f0, 0x10f, 0x33c, 0x35a, 0x169,
+	0x188, 0x3bb, 0x3dd, 0x1ee, 0x311, 0x122, 0x144, 0x377, 0x289, 0x0ba, 0x0dc, 0x2ef, 0x010, 0x223, 0x245, 0x076,
+	0x1b9, 0x38a, 0x3ec, 0x1df, 0x320, 0x113, 0x175, 0x346, 0x2b8, 0x08b, 0x0ed, 0x2de, 0x021, 0x212, 0x274, 0x047,
+	0x1ea, 0x3d9, 0x3bf, 0x18c, 0x373, 0x140, 0x126, 0x315, 0x2eb, 0x0d8, 0x0be, 0x28d, 0x072, 0x241, 0x227, 0x014,
+	0x1db, 0x3e8, 0x38e, 0x1bd, 0x342, 0x171, 0x117, 0x324, 0x2da, 0x0e9, 0x08f, 0x2bc, 0x043, 0x270, 0x216, 0x025,
+	0x14c, 0x37f, 0x319, 0x12a, 0x3d5, 0x1e6, 0x180, 0x3b3, 0x24d, 0x07e, 0x018, 0x22b, 0x0d4, 0x2e7, 0x281, 0x0b2,
+	0x17d, 0x34e, 0x328, 0x11b, 0x3e4, 0x1d7, 0x1b1, 0x382, 0x27c, 0x04f, 0x029, 0x21a, 0x0e5, 0x2d6, 0x2b0, 0x083,
+	0x12e, 0x31d, 0x37b, 0x148, 0x3b7, 0x184, 0x1e2, 0x3d1, 0x22f, 0x01c, 0x07a, 0x249, 0x0b6, 0x285, 0x2e3, 0x0d0,
+	0x11f, 0x32c, 0x34a, 0x179, 0x386, 0x1b5, 0x1d3, 0x3e0, 0x21e, 0x02d, 0x04b, 0x278, 0x087, 0x2b4, 0x2d2, 0x0e1,
+};
+
+#define CRC10_INITFCS     0x000	// Initial FCS value
+#define CRC10_GOODFCS     0x000	// Good final FCS value
+#define CRC10_FCS(fcs, c) ( (((fcs) << 8) & 0x3ff) ^ crc10_table[((fcs) >> 2) & 0xff] ^ (c))
+
+/**     
+ * fcs_compute10 - memcpy and calculate 10 bit CRC across buffer
+ * @sp: pointer to buffer
+ * @len: number of bytes
+ * @fcs: starting FCS
+ *
+ * Perform a memcpy and calculate fcs using ppp 10bit CRC algorithm. Return
+ * new 10 bit FCS.
+ */
+static __u16 __inline__ fcs_compute10 (unsigned char *sp, int len, __u16 fcs)
+{
+	for (; len-- > 0; fcs = CRC10_FCS (fcs, *sp++));
+	return fcs;
+}
+
+static void safe_read_bulk_callback (struct urb *urb, struct pt_regs *regs)
+{
+	struct usb_serial_port *port = (struct usb_serial_port *) urb->context;
+	unsigned char *data = urb->transfer_buffer;
+	unsigned char length = urb->actual_length;
+	int i;
+	int result;
+
+	dbg ("%s", __FUNCTION__);
+
+	if (urb->status) {
+		dbg ("%s - nonzero read bulk status received: %d", __FUNCTION__, urb->status);
+		return;
+	}
+
+	dbg ("safe_read_bulk_callback length: %d", port->read_urb->actual_length);
+#ifdef ECHO_RCV
+	{
+		int i;
+		unsigned char *cp = port->read_urb->transfer_buffer;
+		for (i = 0; i < port->read_urb->actual_length; i++) {
+			if ((i % 32) == 0) {
+				printk ("\nru[%02x] ", i);
+			}
+			printk ("%02x ", *cp++);
+		}
+		printk ("\n");
+	}
+#endif
+	if (safe) {
+		__u16 fcs;
+		if (!(fcs = fcs_compute10 (data, length, CRC10_INITFCS))) {
+
+			int actual_length = data[length - 2] >> 2;
+
+			if (actual_length <= (length - 2)) {
+
+				info ("%s - actual: %d", __FUNCTION__, actual_length);
+
+				for (i = 0; i < actual_length; i++) {
+					tty_insert_flip_char (port->tty, data[i], 0);
+				}
+				tty_flip_buffer_push (port->tty);
+			} else {
+				err ("%s - inconsistent lengths %d:%d", __FUNCTION__,
+				     actual_length, length);
+			}
+		} else {
+			err ("%s - bad CRC %x", __FUNCTION__, fcs);
+		}
+	} else {
+		for (i = 0; i < length; i++) {
+			tty_insert_flip_char (port->tty, data[i], 0);
+		}
+		tty_flip_buffer_push (port->tty);
+	}
+
+	/* Continue trying to always read  */
+	usb_fill_bulk_urb (urb, port->serial->dev,
+		       usb_rcvbulkpipe (port->serial->dev, port->bulk_in_endpointAddress),
+		       urb->transfer_buffer, urb->transfer_buffer_length,
+		       safe_read_bulk_callback, port);
+
+	if ((result = usb_submit_urb (urb, GFP_ATOMIC))) {
+		err ("%s - failed resubmitting read urb, error %d", __FUNCTION__, result);
+	}
+}
+
+static int safe_write (struct usb_serial_port *port, const unsigned char *buf, int count)
+{
+	unsigned char *data;
+	int result;
+	int i;
+	int packet_length;
+
+	dbg ("safe_write port: %p %d urb: %p count: %d", port, port->number, port->write_urb,
+	     count);
+
+	if (!port->write_urb) {
+		dbg ("%s - write urb NULL", __FUNCTION__);
+		return (0);
+	}
+
+	dbg ("safe_write write_urb: %d transfer_buffer_length",
+	     port->write_urb->transfer_buffer_length);
+
+	if (!port->write_urb->transfer_buffer_length) {
+		dbg ("%s - write urb transfer_buffer_length zero", __FUNCTION__);
+		return (0);
+	}
+	if (count == 0) {
+		dbg ("%s - write request of 0 bytes", __FUNCTION__);
+		return (0);
+	}
+	if (port->write_urb->status == -EINPROGRESS) {
+		dbg ("%s - already writing", __FUNCTION__);
+		return (0);
+	}
+
+	packet_length = port->bulk_out_size;	// get max packetsize
+
+	i = packet_length - (safe ? 2 : 0);	// get bytes to send
+	count = (count > i) ? i : count;
+
+
+	// get the data into the transfer buffer
+	data = port->write_urb->transfer_buffer;
+	memset (data, '0', packet_length);
+
+	memcpy (data, buf, count);
+
+	if (safe) {
+		__u16 fcs;
+
+		// pad if necessary
+		if (!padded) {
+			packet_length = count + 2;
+		}
+		// set count
+		data[packet_length - 2] = count << 2;
+		data[packet_length - 1] = 0;
+
+		// compute fcs and insert into trailer
+		fcs = fcs_compute10 (data, packet_length, CRC10_INITFCS);
+		data[packet_length - 2] |= fcs >> 8;
+		data[packet_length - 1] |= fcs & 0xff;
+
+		// set length to send
+		port->write_urb->transfer_buffer_length = packet_length;
+	} else {
+		port->write_urb->transfer_buffer_length = count;
+	}
+
+	usb_serial_debug_data(debug, &port->dev, __FUNCTION__, count, port->write_urb->transfer_buffer);
+#ifdef ECHO_TX
+	{
+		int i;
+		unsigned char *cp = port->write_urb->transfer_buffer;
+		for (i = 0; i < port->write_urb->transfer_buffer_length; i++) {
+			if ((i % 32) == 0) {
+				printk ("\nsu[%02x] ", i);
+			}
+			printk ("%02x ", *cp++);
+		}
+		printk ("\n");
+	}
+#endif
+	port->write_urb->dev = port->serial->dev;
+	if ((result = usb_submit_urb (port->write_urb, GFP_KERNEL))) {
+		err ("%s - failed submitting write urb, error %d", __FUNCTION__, result);
+		return 0;
+	}
+	dbg ("%s urb: %p submitted", __FUNCTION__, port->write_urb);
+
+	return (count);
+}
+
+static int safe_write_room (struct usb_serial_port *port)
+{
+	int room = 0;		// Default: no room
+
+	dbg ("%s", __FUNCTION__);
+
+	if (port->write_urb->status != -EINPROGRESS)
+		room = port->bulk_out_size - (safe ? 2 : 0);
+
+	if (room) {
+		dbg ("safe_write_room returns %d", room);
+	}
+
+	return (room);
+}
+
+static int safe_startup (struct usb_serial *serial)
+{
+	switch (serial->interface->cur_altsetting->desc.bInterfaceProtocol) {
+	case LINEO_SAFESERIAL_CRC:
+		break;
+	case LINEO_SAFESERIAL_CRC_PADDED:
+		padded = 1;
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static struct usb_serial_device_type safe_device = {
+	.owner =		THIS_MODULE,
+	.name =			"Safe",
+	.id_table =		id_table,
+	.num_interrupt_in =	NUM_DONT_CARE,
+	.num_bulk_in =		NUM_DONT_CARE,
+	.num_bulk_out =		NUM_DONT_CARE,
+	.num_ports =		1,
+	.write =		safe_write,
+	.write_room =		safe_write_room,
+	.read_bulk_callback =	safe_read_bulk_callback,
+	.attach =		safe_startup,
+};
+
+static int __init safe_init (void)
+{
+	int i, retval;
+
+	info (DRIVER_VERSION " " DRIVER_AUTHOR);
+	info (DRIVER_DESC);
+	info ("vendor: %x product: %x safe: %d padded: %d\n", vendor, product, safe, padded);
+
+	// if we have vendor / product parameters patch them into id list
+	if (vendor || product) {
+		info ("vendor: %x product: %x\n", vendor, product);
+
+		for (i = 0; i < (sizeof (id_table) / sizeof (struct usb_device_id)); i++) {
+			if (!id_table[i].idVendor && !id_table[i].idProduct) {
+				id_table[i].idVendor = vendor;
+				id_table[i].idProduct = product;
+				break;
+			}
+		}
+	}
+
+	retval = usb_serial_register(&safe_device);
+	if (retval)
+		goto failed_usb_serial_register;
+	retval = usb_register(&safe_driver);
+	if (retval)
+		goto failed_usb_register;
+
+	return 0;
+failed_usb_register:
+	usb_serial_deregister(&safe_device);
+failed_usb_serial_register:
+	return retval;
+}
+
+static void __exit safe_exit (void)
+{
+	usb_deregister (&safe_driver);
+	usb_serial_deregister (&safe_device);
+}
+
+module_init (safe_init);
+module_exit (safe_exit);
