commit cecc113c1af0dd41ccf265c1fdb84dbd05e63423
Author: Scott Chen <scott@labau.com.tw>
Date:   Wed Mar 11 14:14:23 2020 +0800

    USB: serial: pl2303: add device-id for HP LD381
    
    Add a device id for HP LD381 Display
    LD381:   03f0:0f7f
    
    Signed-off-by: Scott Chen <scott@labau.com.tw>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Johan Hovold <johan@kernel.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index aab737e1e7b6..c5a2995dfa2e 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -99,6 +99,7 @@ static const struct usb_device_id id_table[] = {
 	{ USB_DEVICE(SUPERIAL_VENDOR_ID, SUPERIAL_PRODUCT_ID) },
 	{ USB_DEVICE(HP_VENDOR_ID, HP_LD220_PRODUCT_ID) },
 	{ USB_DEVICE(HP_VENDOR_ID, HP_LD220TA_PRODUCT_ID) },
+	{ USB_DEVICE(HP_VENDOR_ID, HP_LD381_PRODUCT_ID) },
 	{ USB_DEVICE(HP_VENDOR_ID, HP_LD960_PRODUCT_ID) },
 	{ USB_DEVICE(HP_VENDOR_ID, HP_LD960TA_PRODUCT_ID) },
 	{ USB_DEVICE(HP_VENDOR_ID, HP_LCM220_PRODUCT_ID) },

commit ebd09f1cd417fce9c85de3abcabf51eadf907a2a
Author: Charles Yeh <charlesyeh522@gmail.com>
Date:   Tue Sep 24 20:14:00 2019 +0800

    USB: serial: pl2303: add support for PL2303HXN
    
    Prolific has developed a new USB to UART chip: PL2303HXN
    PL2303HXN : PL2303GC/PL2303GS/PL2303GT/PL2303GL/PL2303GE/PL2303GB
    The Vendor request used by the PL2303HXN (TYPE_HXN) is different from
    the existing PL2303 series (TYPE_HX & TYPE_01).
    Therefore, different Vendor requests are used to issue related commands.
    
    1. Added a new TYPE_HXN type in pl2303_type_data, and then executes
       new Vendor request,new flow control and other related instructions
       if TYPE_HXN is recognized.
    
    2. Because the new PL2303HXN only accept the new Vendor request,
       the old Vendor request cannot be accepted (the error message
       will be returned)
       So first determine the TYPE_HX or TYPE_HXN through
       PL2303_READ_TYPE_HX_STATUS in pl2303_startup.
    
      2.1 If the return message is "1", then the PL2303 is the existing
          TYPE_HX/ TYPE_01 series.
          The other settings in pl2303_startup are to continue execution.
      2.2 If the return message is "not 1", then the PL2303 is the new
          TYPE_HXN series.
          The other settings in pl2303_startup are ignored.
          (PL2303HXN will directly use the default value in the hardware,
           no need to add additional settings through the software)
    
    3. In pl2303_open: Because TYPE_HXN is different from the instruction of reset
       down/up stream used by TYPE_HX.
       Therefore, we will also execute different instructions here.
    
    4. In pl2303_set_termios: The UART flow control instructions used by
       TYPE_HXN/TYPE_HX/TYPE_01 are different.
       Therefore, we will also execute different instructions here.
    
    5. In pl2303_vendor_read & pl2303_vendor_write, since TYPE_HXN is different
       from the vendor request instruction used by TYPE_HX/TYPE_01,
       it will also execute different instructions here.
    
    6. In pl2303_update_reg: TYPE_HXN used different register for flow control.
       Therefore, we will also execute different instructions here.
    
    Signed-off-by: Charles Yeh <charlesyeh522@gmail.com>
    Signed-off-by: Johan Hovold <johan@kernel.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 9d27b76c5c6e..aab737e1e7b6 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -47,6 +47,12 @@ static const struct usb_device_id id_table[] = {
 	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_MOTOROLA) },
 	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_ZTEK) },
 	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_TB) },
+	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_GC) },
+	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_GB) },
+	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_GT) },
+	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_GL) },
+	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_GE) },
+	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_GS) },
 	{ USB_DEVICE(IODATA_VENDOR_ID, IODATA_PRODUCT_ID) },
 	{ USB_DEVICE(IODATA_VENDOR_ID, IODATA_PRODUCT_ID_RSAQ5) },
 	{ USB_DEVICE(ATEN_VENDOR_ID, ATEN_PRODUCT_ID),
@@ -130,9 +136,11 @@ MODULE_DEVICE_TABLE(usb, id_table);
 
 #define VENDOR_WRITE_REQUEST_TYPE	0x40
 #define VENDOR_WRITE_REQUEST		0x01
+#define VENDOR_WRITE_NREQUEST		0x80
 
 #define VENDOR_READ_REQUEST_TYPE	0xc0
 #define VENDOR_READ_REQUEST		0x01
+#define VENDOR_READ_NREQUEST		0x81
 
 #define UART_STATE_INDEX		8
 #define UART_STATE_MSR_MASK		0x8b
@@ -148,11 +156,24 @@ MODULE_DEVICE_TABLE(usb, id_table);
 
 #define PL2303_FLOWCTRL_MASK		0xf0
 
+#define PL2303_READ_TYPE_HX_STATUS	0x8080
+
+#define PL2303_HXN_RESET_REG		0x07
+#define PL2303_HXN_RESET_UPSTREAM_PIPE	0x02
+#define PL2303_HXN_RESET_DOWNSTREAM_PIPE	0x01
+
+#define PL2303_HXN_FLOWCTRL_REG		0x0a
+#define PL2303_HXN_FLOWCTRL_MASK	0x1c
+#define PL2303_HXN_FLOWCTRL_NONE	0x1c
+#define PL2303_HXN_FLOWCTRL_RTS_CTS	0x18
+#define PL2303_HXN_FLOWCTRL_XON_XOFF	0x0c
+
 static void pl2303_set_break(struct usb_serial_port *port, bool enable);
 
 enum pl2303_type {
 	TYPE_01,	/* Type 0 and 1 (difference unknown) */
 	TYPE_HX,	/* HX version of the pl2303 chip */
+	TYPE_HXN,	/* HXN version of the pl2303 chip */
 	TYPE_COUNT
 };
 
@@ -184,16 +205,26 @@ static const struct pl2303_type_data pl2303_type_data[TYPE_COUNT] = {
 	[TYPE_HX] = {
 		.max_baud_rate		= 12000000,
 	},
+	[TYPE_HXN] = {
+		.max_baud_rate		= 12000000,
+	},
 };
 
 static int pl2303_vendor_read(struct usb_serial *serial, u16 value,
 							unsigned char buf[1])
 {
+	struct pl2303_serial_private *spriv = usb_get_serial_data(serial);
 	struct device *dev = &serial->interface->dev;
+	u8 request;
 	int res;
 
+	if (spriv->type == &pl2303_type_data[TYPE_HXN])
+		request = VENDOR_READ_NREQUEST;
+	else
+		request = VENDOR_READ_REQUEST;
+
 	res = usb_control_msg(serial->dev, usb_rcvctrlpipe(serial->dev, 0),
-			VENDOR_READ_REQUEST, VENDOR_READ_REQUEST_TYPE,
+			request, VENDOR_READ_REQUEST_TYPE,
 			value, 0, buf, 1, 100);
 	if (res != 1) {
 		dev_err(dev, "%s - failed to read [%04x]: %d\n", __func__,
@@ -211,13 +242,20 @@ static int pl2303_vendor_read(struct usb_serial *serial, u16 value,
 
 static int pl2303_vendor_write(struct usb_serial *serial, u16 value, u16 index)
 {
+	struct pl2303_serial_private *spriv = usb_get_serial_data(serial);
 	struct device *dev = &serial->interface->dev;
+	u8 request;
 	int res;
 
 	dev_dbg(dev, "%s - [%04x] = %02x\n", __func__, value, index);
 
+	if (spriv->type == &pl2303_type_data[TYPE_HXN])
+		request = VENDOR_WRITE_NREQUEST;
+	else
+		request = VENDOR_WRITE_REQUEST;
+
 	res = usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),
-			VENDOR_WRITE_REQUEST, VENDOR_WRITE_REQUEST_TYPE,
+			request, VENDOR_WRITE_REQUEST_TYPE,
 			value, index, NULL, 0, 100);
 	if (res) {
 		dev_err(dev, "%s - failed to write [%04x]: %d\n", __func__,
@@ -230,6 +268,7 @@ static int pl2303_vendor_write(struct usb_serial *serial, u16 value, u16 index)
 
 static int pl2303_update_reg(struct usb_serial *serial, u8 reg, u8 mask, u8 val)
 {
+	struct pl2303_serial_private *spriv = usb_get_serial_data(serial);
 	int ret = 0;
 	u8 *buf;
 
@@ -237,7 +276,11 @@ static int pl2303_update_reg(struct usb_serial *serial, u8 reg, u8 mask, u8 val)
 	if (!buf)
 		return -ENOMEM;
 
-	ret = pl2303_vendor_read(serial, reg | 0x80, buf);
+	if (spriv->type == &pl2303_type_data[TYPE_HXN])
+		ret = pl2303_vendor_read(serial, reg, buf);
+	else
+		ret = pl2303_vendor_read(serial, reg | 0x80, buf);
+
 	if (ret)
 		goto out_free;
 
@@ -320,6 +363,7 @@ static int pl2303_startup(struct usb_serial *serial)
 	struct pl2303_serial_private *spriv;
 	enum pl2303_type type = TYPE_01;
 	unsigned char *buf;
+	int res;
 
 	spriv = kzalloc(sizeof(*spriv), GFP_KERNEL);
 	if (!spriv)
@@ -341,26 +385,37 @@ static int pl2303_startup(struct usb_serial *serial)
 		type = TYPE_01;		/* type 1 */
 	dev_dbg(&serial->interface->dev, "device type: %d\n", type);
 
+	if (type == TYPE_HX) {
+		res = usb_control_msg(serial->dev,
+				usb_rcvctrlpipe(serial->dev, 0),
+				VENDOR_READ_REQUEST, VENDOR_READ_REQUEST_TYPE,
+				PL2303_READ_TYPE_HX_STATUS, 0, buf, 1, 100);
+		if (res != 1)
+			type = TYPE_HXN;
+	}
+
 	spriv->type = &pl2303_type_data[type];
 	spriv->quirks = (unsigned long)usb_get_serial_data(serial);
 	spriv->quirks |= spriv->type->quirks;
 
 	usb_set_serial_data(serial, spriv);
 
-	pl2303_vendor_read(serial, 0x8484, buf);
-	pl2303_vendor_write(serial, 0x0404, 0);
-	pl2303_vendor_read(serial, 0x8484, buf);
-	pl2303_vendor_read(serial, 0x8383, buf);
-	pl2303_vendor_read(serial, 0x8484, buf);
-	pl2303_vendor_write(serial, 0x0404, 1);
-	pl2303_vendor_read(serial, 0x8484, buf);
-	pl2303_vendor_read(serial, 0x8383, buf);
-	pl2303_vendor_write(serial, 0, 1);
-	pl2303_vendor_write(serial, 1, 0);
-	if (spriv->quirks & PL2303_QUIRK_LEGACY)
-		pl2303_vendor_write(serial, 2, 0x24);
-	else
-		pl2303_vendor_write(serial, 2, 0x44);
+	if (type != TYPE_HXN) {
+		pl2303_vendor_read(serial, 0x8484, buf);
+		pl2303_vendor_write(serial, 0x0404, 0);
+		pl2303_vendor_read(serial, 0x8484, buf);
+		pl2303_vendor_read(serial, 0x8383, buf);
+		pl2303_vendor_read(serial, 0x8484, buf);
+		pl2303_vendor_write(serial, 0x0404, 1);
+		pl2303_vendor_read(serial, 0x8484, buf);
+		pl2303_vendor_read(serial, 0x8383, buf);
+		pl2303_vendor_write(serial, 0, 1);
+		pl2303_vendor_write(serial, 1, 0);
+		if (spriv->quirks & PL2303_QUIRK_LEGACY)
+			pl2303_vendor_write(serial, 2, 0x24);
+		else
+			pl2303_vendor_write(serial, 2, 0x44);
+	}
 
 	kfree(buf);
 
@@ -719,14 +774,31 @@ static void pl2303_set_termios(struct tty_struct *tty,
 	}
 
 	if (C_CRTSCTS(tty)) {
-		if (spriv->quirks & PL2303_QUIRK_LEGACY)
+		if (spriv->quirks & PL2303_QUIRK_LEGACY) {
 			pl2303_update_reg(serial, 0, PL2303_FLOWCTRL_MASK, 0x40);
-		else
+		} else if (spriv->type == &pl2303_type_data[TYPE_HXN]) {
+			pl2303_update_reg(serial, PL2303_HXN_FLOWCTRL_REG,
+					PL2303_HXN_FLOWCTRL_MASK,
+					PL2303_HXN_FLOWCTRL_RTS_CTS);
+		} else {
 			pl2303_update_reg(serial, 0, PL2303_FLOWCTRL_MASK, 0x60);
+		}
 	} else if (pl2303_enable_xonxoff(tty, spriv->type)) {
-		pl2303_update_reg(serial, 0, PL2303_FLOWCTRL_MASK, 0xc0);
+		if (spriv->type == &pl2303_type_data[TYPE_HXN]) {
+			pl2303_update_reg(serial, PL2303_HXN_FLOWCTRL_REG,
+					PL2303_HXN_FLOWCTRL_MASK,
+					PL2303_HXN_FLOWCTRL_XON_XOFF);
+		} else {
+			pl2303_update_reg(serial, 0, PL2303_FLOWCTRL_MASK, 0xc0);
+		}
 	} else {
-		pl2303_update_reg(serial, 0, PL2303_FLOWCTRL_MASK, 0);
+		if (spriv->type == &pl2303_type_data[TYPE_HXN]) {
+			pl2303_update_reg(serial, PL2303_HXN_FLOWCTRL_REG,
+					PL2303_HXN_FLOWCTRL_MASK,
+					PL2303_HXN_FLOWCTRL_NONE);
+		} else {
+			pl2303_update_reg(serial, 0, PL2303_FLOWCTRL_MASK, 0);
+		}
 	}
 
 	kfree(buf);
@@ -767,8 +839,14 @@ static int pl2303_open(struct tty_struct *tty, struct usb_serial_port *port)
 		usb_clear_halt(serial->dev, port->read_urb->pipe);
 	} else {
 		/* reset upstream data pipes */
-		pl2303_vendor_write(serial, 8, 0);
-		pl2303_vendor_write(serial, 9, 0);
+		if (spriv->type == &pl2303_type_data[TYPE_HXN]) {
+			pl2303_vendor_write(serial, PL2303_HXN_RESET_REG,
+					PL2303_HXN_RESET_UPSTREAM_PIPE |
+					PL2303_HXN_RESET_DOWNSTREAM_PIPE);
+		} else {
+			pl2303_vendor_write(serial, 8, 0);
+			pl2303_vendor_write(serial, 9, 0);
+		}
 	}
 
 	/* Setup termios */

commit ecefae6db042283bf88ef3777f2381b18df8ed46
Author: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
Date:   Tue Jun 18 18:05:38 2019 -0300

    docs: usb: rename files to .rst and add them to drivers-api
    
    While there are a mix of things here, most of the stuff
    were written from Kernel developer's PoV. So, add them to
    the driver-api book.
    
    A follow up for this patch would be to move documents from
    there that are specific to sysadmins, adding them to the
    admin-guide.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
    Acked-by: Johan Hovold <johan@kernel.org>
    Acked-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index d7abde14b3cf..9d27b76c5c6e 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -7,7 +7,7 @@
  *
  * Original driver for 2.2.x by anonymous
  *
- * See Documentation/usb/usb-serial.txt for more information on using this
+ * See Documentation/usb/usb-serial.rst for more information on using this
  * driver
  */
 

commit c5f81656a18b271976a86724dadd8344e54de74e
Author: Chris Packham <chris.packham@alliedtelesis.co.nz>
Date:   Tue May 14 17:35:42 2019 +1200

    USB: serial: pl2303: add Allied Telesis VT-Kit3
    
    This is adds the vendor and device id for the AT-VT-Kit3 which is a
    pl2303-based device.
    
    Signed-off-by: Chris Packham <chris.packham@alliedtelesis.co.nz>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Johan Hovold <johan@kernel.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 55122ac84518..d7abde14b3cf 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -106,6 +106,7 @@ static const struct usb_device_id id_table[] = {
 	{ USB_DEVICE(SANWA_VENDOR_ID, SANWA_PRODUCT_ID) },
 	{ USB_DEVICE(ADLINK_VENDOR_ID, ADLINK_ND6530_PRODUCT_ID) },
 	{ USB_DEVICE(SMART_VENDOR_ID, SMART_PRODUCT_ID) },
+	{ USB_DEVICE(AT_VENDOR_ID, AT_VTKIT3_PRODUCT_ID) },
 	{ }					/* Terminating entry */
 };
 

commit f64c3ab230682e8395a7fbd01f3eb5140c837d4e
Author: Johan Hovold <johan@kernel.org>
Date:   Tue Apr 2 10:19:31 2019 +0200

    USB: serial: pl2303: fix tranceiver suspend mode
    
    Add helper function to update register bits instead of overwriting the
    entire control register when updating the flow-control settings.
    
    This specifically avoids having the tranceiver suspend mode (bit 0)
    depend on the flow control setting.
    
    The tranceiver is currently configured at probe to be disabled during
    suspend, but this was overridden when disabling flow control or enabling
    xon/xoff.
    
    Fixes: 715f9527c1c1 ("USB: flow control fix for pl2303")
    Fixes: 7041d9c3f01b ("USB: serial: pl2303: add support for tx xon/xoff flow control")
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Johan Hovold <johan@kernel.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index f1d904706758..55122ac84518 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -145,6 +145,8 @@ MODULE_DEVICE_TABLE(usb, id_table);
 #define UART_OVERRUN_ERROR		0x40
 #define UART_CTS			0x80
 
+#define PL2303_FLOWCTRL_MASK		0xf0
+
 static void pl2303_set_break(struct usb_serial_port *port, bool enable);
 
 enum pl2303_type {
@@ -225,6 +227,29 @@ static int pl2303_vendor_write(struct usb_serial *serial, u16 value, u16 index)
 	return 0;
 }
 
+static int pl2303_update_reg(struct usb_serial *serial, u8 reg, u8 mask, u8 val)
+{
+	int ret = 0;
+	u8 *buf;
+
+	buf = kmalloc(1, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	ret = pl2303_vendor_read(serial, reg | 0x80, buf);
+	if (ret)
+		goto out_free;
+
+	*buf &= ~mask;
+	*buf |= val & mask;
+
+	ret = pl2303_vendor_write(serial, reg, *buf);
+out_free:
+	kfree(buf);
+
+	return ret;
+}
+
 static int pl2303_probe(struct usb_serial *serial,
 					const struct usb_device_id *id)
 {
@@ -694,13 +719,13 @@ static void pl2303_set_termios(struct tty_struct *tty,
 
 	if (C_CRTSCTS(tty)) {
 		if (spriv->quirks & PL2303_QUIRK_LEGACY)
-			pl2303_vendor_write(serial, 0x0, 0x41);
+			pl2303_update_reg(serial, 0, PL2303_FLOWCTRL_MASK, 0x40);
 		else
-			pl2303_vendor_write(serial, 0x0, 0x61);
+			pl2303_update_reg(serial, 0, PL2303_FLOWCTRL_MASK, 0x60);
 	} else if (pl2303_enable_xonxoff(tty, spriv->type)) {
-		pl2303_vendor_write(serial, 0x0, 0xc0);
+		pl2303_update_reg(serial, 0, PL2303_FLOWCTRL_MASK, 0xc0);
 	} else {
-		pl2303_vendor_write(serial, 0x0, 0x0);
+		pl2303_update_reg(serial, 0, PL2303_FLOWCTRL_MASK, 0);
 	}
 
 	kfree(buf);

commit 68270dab97107b5679080b596aa2f5a360f79873
Author: Johan Hovold <johan@kernel.org>
Date:   Tue Apr 2 10:19:30 2019 +0200

    USB: serial: pl2303: fix non-supported xon/xoff
    
    Older pl2303 devices do not support automatic xon/xoff flow control, so
    add add a flag to prevent trying to enable it for legacy device types.
    
    Refactor the IXON test into a helper function to improve readability.
    
    Fixes: 7041d9c3f01b ("USB: serial: pl2303: add support for tx xon/xoff flow control")
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Johan Hovold <johan@kernel.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index bb3f9aa4a909..f1d904706758 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -156,6 +156,7 @@ enum pl2303_type {
 struct pl2303_type_data {
 	speed_t max_baud_rate;
 	unsigned long quirks;
+	unsigned int no_autoxonxoff:1;
 };
 
 struct pl2303_serial_private {
@@ -173,11 +174,12 @@ struct pl2303_private {
 
 static const struct pl2303_type_data pl2303_type_data[TYPE_COUNT] = {
 	[TYPE_01] = {
-		.max_baud_rate =	1228800,
-		.quirks =		PL2303_QUIRK_LEGACY,
+		.max_baud_rate		= 1228800,
+		.quirks			= PL2303_QUIRK_LEGACY,
+		.no_autoxonxoff		= true,
 	},
 	[TYPE_HX] = {
-		.max_baud_rate =	12000000,
+		.max_baud_rate		= 12000000,
 	},
 };
 
@@ -552,6 +554,20 @@ static bool pl2303_termios_change(const struct ktermios *a, const struct ktermio
 	return tty_termios_hw_change(a, b) || ixon_change;
 }
 
+static bool pl2303_enable_xonxoff(struct tty_struct *tty, const struct pl2303_type_data *type)
+{
+	if (!I_IXON(tty) || I_IXANY(tty))
+		return false;
+
+	if (START_CHAR(tty) != 0x11 || STOP_CHAR(tty) != 0x13)
+		return false;
+
+	if (type->no_autoxonxoff)
+		return false;
+
+	return true;
+}
+
 static void pl2303_set_termios(struct tty_struct *tty,
 		struct usb_serial_port *port, struct ktermios *old_termios)
 {
@@ -681,8 +697,7 @@ static void pl2303_set_termios(struct tty_struct *tty,
 			pl2303_vendor_write(serial, 0x0, 0x41);
 		else
 			pl2303_vendor_write(serial, 0x0, 0x61);
-	} else if (I_IXON(tty) && !I_IXANY(tty) && START_CHAR(tty) == 0x11 &&
-			STOP_CHAR(tty) == 0x13) {
+	} else if (pl2303_enable_xonxoff(tty, spriv->type)) {
 		pl2303_vendor_write(serial, 0x0, 0xc0);
 	} else {
 		pl2303_vendor_write(serial, 0x0, 0x0);

commit 4dcf9ddc9ad5ab649abafa98c5a4d54b1a33dabb
Author: Charles Yeh <charlesyeh522@gmail.com>
Date:   Tue Jan 15 23:13:56 2019 +0800

    USB: serial: pl2303: add new PID to support PL2303TB
    
    Add new PID to support PL2303TB (TYPE_HX)
    
    Signed-off-by: Charles Yeh <charlesyeh522@gmail.com>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Johan Hovold <johan@kernel.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 98e7a5df0f6d..bb3f9aa4a909 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -46,6 +46,7 @@ static const struct usb_device_id id_table[] = {
 	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_HCR331) },
 	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_MOTOROLA) },
 	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_ZTEK) },
+	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_TB) },
 	{ USB_DEVICE(IODATA_VENDOR_ID, IODATA_PRODUCT_ID) },
 	{ USB_DEVICE(IODATA_VENDOR_ID, IODATA_PRODUCT_ID_RSAQ5) },
 	{ USB_DEVICE(ATEN_VENDOR_ID, ATEN_PRODUCT_ID),

commit 8d503f206c336677954160ac62f0c7d9c219cd89
Author: Scott Chen <scott@labau.com.tw>
Date:   Thu Dec 13 06:01:47 2018 -0500

    USB: serial: pl2303: add ids for Hewlett-Packard HP POS pole displays
    
    Add device ids to pl2303 for the HP POS pole displays:
    LM920:   03f0:026b
    TD620:   03f0:0956
    LD960TA: 03f0:4439
    LD220TA: 03f0:4349
    LM940:   03f0:5039
    
    Signed-off-by: Scott Chen <scott@labau.com.tw>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Johan Hovold <johan@kernel.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index a4e0d13fc121..98e7a5df0f6d 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -91,9 +91,14 @@ static const struct usb_device_id id_table[] = {
 	{ USB_DEVICE(YCCABLE_VENDOR_ID, YCCABLE_PRODUCT_ID) },
 	{ USB_DEVICE(SUPERIAL_VENDOR_ID, SUPERIAL_PRODUCT_ID) },
 	{ USB_DEVICE(HP_VENDOR_ID, HP_LD220_PRODUCT_ID) },
+	{ USB_DEVICE(HP_VENDOR_ID, HP_LD220TA_PRODUCT_ID) },
 	{ USB_DEVICE(HP_VENDOR_ID, HP_LD960_PRODUCT_ID) },
+	{ USB_DEVICE(HP_VENDOR_ID, HP_LD960TA_PRODUCT_ID) },
 	{ USB_DEVICE(HP_VENDOR_ID, HP_LCM220_PRODUCT_ID) },
 	{ USB_DEVICE(HP_VENDOR_ID, HP_LCM960_PRODUCT_ID) },
+	{ USB_DEVICE(HP_VENDOR_ID, HP_LM920_PRODUCT_ID) },
+	{ USB_DEVICE(HP_VENDOR_ID, HP_LM940_PRODUCT_ID) },
+	{ USB_DEVICE(HP_VENDOR_ID, HP_TD620_PRODUCT_ID) },
 	{ USB_DEVICE(CRESSI_VENDOR_ID, CRESSI_EDY_PRODUCT_ID) },
 	{ USB_DEVICE(ZEAGLE_VENDOR_ID, ZEAGLE_N2ITION3_PRODUCT_ID) },
 	{ USB_DEVICE(SONY_VENDOR_ID, SONY_QN3USB_PRODUCT_ID) },

commit 9326ec59ec64399e031aa2fe3ab6404d24423630
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Sep 12 07:23:18 2018 -0400

    pl2303: switch to ->get_serial()
    
    Reviewed-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index e41f725ac7aa..a4e0d13fc121 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -808,29 +808,16 @@ static int pl2303_carrier_raised(struct usb_serial_port *port)
 	return 0;
 }
 
-static int pl2303_ioctl(struct tty_struct *tty,
-			unsigned int cmd, unsigned long arg)
+static int pl2303_get_serial(struct tty_struct *tty,
+			struct serial_struct *ss)
 {
-	struct serial_struct ser;
 	struct usb_serial_port *port = tty->driver_data;
 
-	switch (cmd) {
-	case TIOCGSERIAL:
-		memset(&ser, 0, sizeof ser);
-		ser.type = PORT_16654;
-		ser.line = port->minor;
-		ser.port = port->port_number;
-		ser.baud_base = 460800;
-
-		if (copy_to_user((void __user *)arg, &ser, sizeof ser))
-			return -EFAULT;
-
-		return 0;
-	default:
-		break;
-	}
-
-	return -ENOIOCTLCMD;
+	ss->type = PORT_16654;
+	ss->line = port->minor;
+	ss->port = port->port_number;
+	ss->baud_base = 460800;
+	return 0;
 }
 
 static void pl2303_set_break(struct usb_serial_port *port, bool enable)
@@ -1016,7 +1003,7 @@ static struct usb_serial_driver pl2303_device = {
 	.close =		pl2303_close,
 	.dtr_rts =		pl2303_dtr_rts,
 	.carrier_raised =	pl2303_carrier_raised,
-	.ioctl =		pl2303_ioctl,
+	.get_serial =		pl2303_get_serial,
 	.break_ctl =		pl2303_break_ctl,
 	.set_termios =		pl2303_set_termios,
 	.tiocmget =		pl2303_tiocmget,

commit 29c692c96b3a39cd1911fb79cd2505af8d070f07
Author: Movie Song <MovieSong@aten-itlab.cn>
Date:   Thu Jul 19 02:20:48 2018 +0800

    USB: serial: pl2303: add a new device id for ATEN
    
    Signed-off-by: Movie Song <MovieSong@aten-itlab.cn>
    Cc: Johan Hovold <johan@kernel.org>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 5d1a1931967e..e41f725ac7aa 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -52,6 +52,8 @@ static const struct usb_device_id id_table[] = {
 		.driver_info = PL2303_QUIRK_ENDPOINT_HACK },
 	{ USB_DEVICE(ATEN_VENDOR_ID, ATEN_PRODUCT_UC485),
 		.driver_info = PL2303_QUIRK_ENDPOINT_HACK },
+	{ USB_DEVICE(ATEN_VENDOR_ID, ATEN_PRODUCT_UC232B),
+		.driver_info = PL2303_QUIRK_ENDPOINT_HACK },
 	{ USB_DEVICE(ATEN_VENDOR_ID, ATEN_PRODUCT_ID2) },
 	{ USB_DEVICE(ATEN_VENDOR_ID2, ATEN_PRODUCT_ID) },
 	{ USB_DEVICE(ELCOM_VENDOR_ID, ELCOM_PRODUCT_ID) },

commit 7041d9c3f01b365daa50340a5d2dce84a09ea813
Author: Florian Zumbiehl <florz@florz.de>
Date:   Sun May 20 02:23:12 2018 +0200

    USB: serial: pl2303: add support for tx xon/xoff flow control
    
    Support hardware-level Xon/Xoff flow control in transmit direction with
    pl2303.
    
    I only know how to get the hardware to do IXON/!IXANY with ^S/^Q as control
    characters, so I preserve the old behaviour for all other cases.
    
    Signed-off-by: Florian Zumbiehl <florz@florz.de>
    [ johan: rewrite logic using pl2303_termios_change() helper ]
    Signed-off-by: Johan Hovold <johan@kernel.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 46dd09da2434..5d1a1931967e 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -533,6 +533,17 @@ static int pl2303_set_line_request(struct usb_serial_port *port,
 	return 0;
 }
 
+static bool pl2303_termios_change(const struct ktermios *a, const struct ktermios *b)
+{
+	bool ixon_change;
+
+	ixon_change = ((a->c_iflag ^ b->c_iflag) & (IXON | IXANY)) ||
+			a->c_cc[VSTART] != b->c_cc[VSTART] ||
+			a->c_cc[VSTOP] != b->c_cc[VSTOP];
+
+	return tty_termios_hw_change(a, b) || ixon_change;
+}
+
 static void pl2303_set_termios(struct tty_struct *tty,
 		struct usb_serial_port *port, struct ktermios *old_termios)
 {
@@ -544,7 +555,7 @@ static void pl2303_set_termios(struct tty_struct *tty,
 	int ret;
 	u8 control;
 
-	if (old_termios && !tty_termios_hw_change(&tty->termios, old_termios))
+	if (old_termios && !pl2303_termios_change(&tty->termios, old_termios))
 		return;
 
 	buf = kzalloc(7, GFP_KERNEL);
@@ -662,6 +673,9 @@ static void pl2303_set_termios(struct tty_struct *tty,
 			pl2303_vendor_write(serial, 0x0, 0x41);
 		else
 			pl2303_vendor_write(serial, 0x0, 0x61);
+	} else if (I_IXON(tty) && !I_IXANY(tty) && START_CHAR(tty) == 0x11 &&
+			STOP_CHAR(tty) == 0x13) {
+		pl2303_vendor_write(serial, 0x0, 0xc0);
 	} else {
 		pl2303_vendor_write(serial, 0x0, 0x0);
 	}

commit d08dd3f3dd2ae351b793fc5b76abdbf0fd317b12
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu Jan 25 09:48:55 2018 +0100

    USB: serial: pl2303: new device id for Chilitag
    
    This adds a new device id for Chilitag devices to the pl2303 driver.
    
    Reported-by: "Chu.Mike [朱堅宜]" <Mike-Chu@prolific.com.tw>
    Cc: stable <stable@vger.kernel.org>
    Acked-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 57ae832a49ff..46dd09da2434 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -38,6 +38,7 @@ static const struct usb_device_id id_table[] = {
 	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_RSAQ2) },
 	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_DCU11) },
 	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_RSAQ3) },
+	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_CHILITAG) },
 	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_PHAROS) },
 	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_ALDIGA) },
 	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_MMX) },

commit 627cfa89b1fe8d189ee71718fe9eb607026db301
Author: Johan Hovold <johan@kernel.org>
Date:   Fri Nov 3 18:12:08 2017 +0100

    USB: serial: fix module-license macros
    
    Several GPL-2.0 drivers used "GPL" rather than "GPL v2" in their
    MODULE_LICENSE macros; fix the macros to match the licenses.
    
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 71fbf2ff1fc3..57ae832a49ff 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -1022,4 +1022,4 @@ static struct usb_serial_driver * const serial_drivers[] = {
 module_usb_serial_driver(serial_drivers, id_table);
 
 MODULE_DESCRIPTION("Prolific PL2303 USB to serial adaptor driver");
-MODULE_LICENSE("GPL");
+MODULE_LICENSE("GPL v2");

commit 6ca98bc2843e0bc4c2745ff6be7d46694c1398d1
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Nov 3 12:40:56 2017 +0100

    USB: serial: Remove redundant license text
    
    Now that the SPDX tag is in all USB files, that identifies the license
    in a specific and legally-defined manner.  So the extra GPL text wording
    can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 5a12f5d81fc2..71fbf2ff1fc3 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -7,10 +7,6 @@
  *
  * Original driver for 2.2.x by anonymous
  *
- *	This program is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU General Public License version
- *	2 as published by the Free Software Foundation.
- *
  * See Documentation/usb/usb-serial.txt for more information on using this
  * driver
  */

commit 5fd54ace4721fc5ce2bb5aef6318fcf17f421460
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Nov 3 11:28:30 2017 +0100

    USB: add SPDX identifiers to all remaining files in drivers/usb/
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/usb/ and include/linux/usb* files with the correct
    SPDX license identifier based on the license text in the file itself.
    The SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Acked-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index a585b477415d..5a12f5d81fc2 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Prolific PL2303 USB to serial adaptor driver
  *

commit 3b6bcd3d093c698d32e93d4da57679b8fbc5e01e
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu Aug 10 11:54:12 2017 -0700

    USB: serial: pl2303: add new ATEN device id
    
    This adds a new ATEN device id for a new pl2303-based device.
    
    Reported-by: Peter Kuo <PeterKuo@aten.com.tw>
    Cc: stable <stable@vger.kernel.org>
    Cc: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index c9ebefd8f35f..a585b477415d 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -52,6 +52,8 @@ static const struct usb_device_id id_table[] = {
 	{ USB_DEVICE(IODATA_VENDOR_ID, IODATA_PRODUCT_ID_RSAQ5) },
 	{ USB_DEVICE(ATEN_VENDOR_ID, ATEN_PRODUCT_ID),
 		.driver_info = PL2303_QUIRK_ENDPOINT_HACK },
+	{ USB_DEVICE(ATEN_VENDOR_ID, ATEN_PRODUCT_UC485),
+		.driver_info = PL2303_QUIRK_ENDPOINT_HACK },
 	{ USB_DEVICE(ATEN_VENDOR_ID, ATEN_PRODUCT_ID2) },
 	{ USB_DEVICE(ATEN_VENDOR_ID2, ATEN_PRODUCT_ID) },
 	{ USB_DEVICE(ELCOM_VENDOR_ID, ELCOM_PRODUCT_ID) },

commit 9d717271d6b5cbbe6aaa975648d9dcfe9b6e7b82
Author: Johan Hovold <johan@kernel.org>
Date:   Thu Mar 16 17:13:35 2017 +0100

    USB: serial: pl2303: clean up legacy endpoint hack
    
    Implement the "horrible endpoint hack" for some legacy devices as a
    quirk and clean up the code somewhat.
    
    Note that the bulk-endpoint check can be removed as core will already
    have verified this.
    
    Signed-off-by: Johan Hovold <johan@kernel.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index b8edd7bc71f2..c9ebefd8f35f 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -33,9 +33,11 @@
 
 #define PL2303_QUIRK_UART_STATE_IDX0		BIT(0)
 #define PL2303_QUIRK_LEGACY			BIT(1)
+#define PL2303_QUIRK_ENDPOINT_HACK		BIT(2)
 
 static const struct usb_device_id id_table[] = {
-	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID) },
+	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID),
+		.driver_info = PL2303_QUIRK_ENDPOINT_HACK },
 	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_RSAQ2) },
 	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_DCU11) },
 	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_RSAQ3) },
@@ -48,7 +50,8 @@ static const struct usb_device_id id_table[] = {
 	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_ZTEK) },
 	{ USB_DEVICE(IODATA_VENDOR_ID, IODATA_PRODUCT_ID) },
 	{ USB_DEVICE(IODATA_VENDOR_ID, IODATA_PRODUCT_ID_RSAQ5) },
-	{ USB_DEVICE(ATEN_VENDOR_ID, ATEN_PRODUCT_ID) },
+	{ USB_DEVICE(ATEN_VENDOR_ID, ATEN_PRODUCT_ID),
+		.driver_info = PL2303_QUIRK_ENDPOINT_HACK },
 	{ USB_DEVICE(ATEN_VENDOR_ID, ATEN_PRODUCT_ID2) },
 	{ USB_DEVICE(ATEN_VENDOR_ID2, ATEN_PRODUCT_ID) },
 	{ USB_DEVICE(ELCOM_VENDOR_ID, ELCOM_PRODUCT_ID) },
@@ -68,7 +71,8 @@ static const struct usb_device_id id_table[] = {
 		.driver_info = PL2303_QUIRK_UART_STATE_IDX0 },
 	{ USB_DEVICE(SIEMENS_VENDOR_ID, SIEMENS_PRODUCT_ID_X75),
 		.driver_info = PL2303_QUIRK_UART_STATE_IDX0 },
-	{ USB_DEVICE(SIEMENS_VENDOR_ID, SIEMENS_PRODUCT_ID_EF81) },
+	{ USB_DEVICE(SIEMENS_VENDOR_ID, SIEMENS_PRODUCT_ID_EF81),
+		.driver_info = PL2303_QUIRK_ENDPOINT_HACK },
 	{ USB_DEVICE(BENQ_VENDOR_ID, BENQ_PRODUCT_ID_S81) }, /* Benq/Siemens S81 */
 	{ USB_DEVICE(SYNTECH_VENDOR_ID, SYNTECH_PRODUCT_ID) },
 	{ USB_DEVICE(NOKIA_CA42_VENDOR_ID, NOKIA_CA42_PRODUCT_ID) },
@@ -78,7 +82,8 @@ static const struct usb_device_id id_table[] = {
 	{ USB_DEVICE(SPEEDDRAGON_VENDOR_ID, SPEEDDRAGON_PRODUCT_ID) },
 	{ USB_DEVICE(DATAPILOT_U2_VENDOR_ID, DATAPILOT_U2_PRODUCT_ID) },
 	{ USB_DEVICE(BELKIN_VENDOR_ID, BELKIN_PRODUCT_ID) },
-	{ USB_DEVICE(ALCOR_VENDOR_ID, ALCOR_PRODUCT_ID) },
+	{ USB_DEVICE(ALCOR_VENDOR_ID, ALCOR_PRODUCT_ID),
+		.driver_info = PL2303_QUIRK_ENDPOINT_HACK },
 	{ USB_DEVICE(WS002IN_VENDOR_ID, WS002IN_PRODUCT_ID) },
 	{ USB_DEVICE(COREGA_VENDOR_ID, COREGA_PRODUCT_ID) },
 	{ USB_DEVICE(YCCABLE_VENDOR_ID, YCCABLE_PRODUCT_ID) },
@@ -218,7 +223,12 @@ static int pl2303_probe(struct usb_serial *serial,
 	return 0;
 }
 
-static int pl2303_calc_num_ports(struct usb_serial *serial,
+/*
+ * Use interrupt endpoint from first interface if available.
+ *
+ * This is needed due to the looney way its endpoints are set up.
+ */
+static int pl2303_endpoint_hack(struct usb_serial *serial,
 					struct usb_serial_endpoints *epds)
 {
 	struct usb_interface *interface = serial->interface;
@@ -228,43 +238,41 @@ static int pl2303_calc_num_ports(struct usb_serial *serial,
 	struct usb_endpoint_descriptor *endpoint;
 	unsigned int i;
 
-	/* BEGIN HORRIBLE HACK FOR PL2303 */
-	/* this is needed due to the looney way its endpoints are set up */
-	if (((le16_to_cpu(dev->descriptor.idVendor) == PL2303_VENDOR_ID) &&
-	     (le16_to_cpu(dev->descriptor.idProduct) == PL2303_PRODUCT_ID)) ||
-	    ((le16_to_cpu(dev->descriptor.idVendor) == ATEN_VENDOR_ID) &&
-	     (le16_to_cpu(dev->descriptor.idProduct) == ATEN_PRODUCT_ID)) ||
-	    ((le16_to_cpu(dev->descriptor.idVendor) == ALCOR_VENDOR_ID) &&
-	     (le16_to_cpu(dev->descriptor.idProduct) == ALCOR_PRODUCT_ID)) ||
-	    ((le16_to_cpu(dev->descriptor.idVendor) == SIEMENS_VENDOR_ID) &&
-	     (le16_to_cpu(dev->descriptor.idProduct) == SIEMENS_PRODUCT_ID_EF81))) {
-		if (interface != dev->actconfig->interface[0]) {
-			/* check out the endpoints of the other interface*/
-			iface_desc = dev->actconfig->interface[0]->cur_altsetting;
-			for (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {
-				endpoint = &iface_desc->endpoint[i].desc;
-				if (usb_endpoint_is_int_in(endpoint)) {
-					/* we found a interrupt in endpoint */
-					dev_dbg(ddev, "found interrupt in for Prolific device on separate interface\n");
-					if (epds->num_interrupt_in < ARRAY_SIZE(epds->interrupt_in))
-						epds->interrupt_in[epds->num_interrupt_in++] = endpoint;
-				}
-			}
-		}
+	if (interface == dev->actconfig->interface[0])
+		return 0;
 
-		/* Now make sure the PL-2303 is configured correctly.
-		 * If not, give up now and hope this hack will work
-		 * properly during a later invocation of usb_serial_probe
-		 */
-		if (epds->num_bulk_in == 0 || epds->num_bulk_out == 0) {
-			dev_info(ddev, "PL-2303 hack: descriptors matched but endpoints did not\n");
-			return -ENODEV;
-		}
+	/* check out the endpoints of the other interface */
+	iface_desc = dev->actconfig->interface[0]->cur_altsetting;
+
+	for (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {
+		endpoint = &iface_desc->endpoint[i].desc;
+
+		if (!usb_endpoint_is_int_in(endpoint))
+			continue;
+
+		dev_dbg(ddev, "found interrupt in on separate interface\n");
+		if (epds->num_interrupt_in < ARRAY_SIZE(epds->interrupt_in))
+			epds->interrupt_in[epds->num_interrupt_in++] = endpoint;
+	}
+
+	return 0;
+}
+
+static int pl2303_calc_num_ports(struct usb_serial *serial,
+					struct usb_serial_endpoints *epds)
+{
+	unsigned long quirks = (unsigned long)usb_get_serial_data(serial);
+	struct device *dev = &serial->interface->dev;
+	int ret;
+
+	if (quirks & PL2303_QUIRK_ENDPOINT_HACK) {
+		ret = pl2303_endpoint_hack(serial, epds);
+		if (ret)
+			return ret;
 	}
-	/* END HORRIBLE HACK FOR PL2303 */
 
 	if (epds->num_interrupt_in < 1) {
-		dev_err(ddev, "required interrupt-in endpoint missing\n");
+		dev_err(dev, "required interrupt-in endpoint missing\n");
 		return -ENODEV;
 	}
 

commit 9fda620a5f3d7711d0b27d36eeec3a24a097af97
Author: Johan Hovold <johan@kernel.org>
Date:   Thu Mar 16 17:13:34 2017 +0100

    USB: serial: move pl2303 hack out of usb-serial core
    
    Some pl2303 devices require the use of the interrupt endpoint of an
    unrelated interface. This has so far been dealt with in usb-serial core,
    but can now be moved to a driver calc_num_ports callback.
    
    Note that we relax the endpoint requirements checked by core and instead
    verify that we have an interrupt-in endpoint in calc_num_ports for all
    devices so that the hack can first be applied.
    
    Signed-off-by: Johan Hovold <johan@kernel.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 60840004568a..b8edd7bc71f2 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -218,6 +218,59 @@ static int pl2303_probe(struct usb_serial *serial,
 	return 0;
 }
 
+static int pl2303_calc_num_ports(struct usb_serial *serial,
+					struct usb_serial_endpoints *epds)
+{
+	struct usb_interface *interface = serial->interface;
+	struct usb_device *dev = serial->dev;
+	struct device *ddev = &interface->dev;
+	struct usb_host_interface *iface_desc;
+	struct usb_endpoint_descriptor *endpoint;
+	unsigned int i;
+
+	/* BEGIN HORRIBLE HACK FOR PL2303 */
+	/* this is needed due to the looney way its endpoints are set up */
+	if (((le16_to_cpu(dev->descriptor.idVendor) == PL2303_VENDOR_ID) &&
+	     (le16_to_cpu(dev->descriptor.idProduct) == PL2303_PRODUCT_ID)) ||
+	    ((le16_to_cpu(dev->descriptor.idVendor) == ATEN_VENDOR_ID) &&
+	     (le16_to_cpu(dev->descriptor.idProduct) == ATEN_PRODUCT_ID)) ||
+	    ((le16_to_cpu(dev->descriptor.idVendor) == ALCOR_VENDOR_ID) &&
+	     (le16_to_cpu(dev->descriptor.idProduct) == ALCOR_PRODUCT_ID)) ||
+	    ((le16_to_cpu(dev->descriptor.idVendor) == SIEMENS_VENDOR_ID) &&
+	     (le16_to_cpu(dev->descriptor.idProduct) == SIEMENS_PRODUCT_ID_EF81))) {
+		if (interface != dev->actconfig->interface[0]) {
+			/* check out the endpoints of the other interface*/
+			iface_desc = dev->actconfig->interface[0]->cur_altsetting;
+			for (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {
+				endpoint = &iface_desc->endpoint[i].desc;
+				if (usb_endpoint_is_int_in(endpoint)) {
+					/* we found a interrupt in endpoint */
+					dev_dbg(ddev, "found interrupt in for Prolific device on separate interface\n");
+					if (epds->num_interrupt_in < ARRAY_SIZE(epds->interrupt_in))
+						epds->interrupt_in[epds->num_interrupt_in++] = endpoint;
+				}
+			}
+		}
+
+		/* Now make sure the PL-2303 is configured correctly.
+		 * If not, give up now and hope this hack will work
+		 * properly during a later invocation of usb_serial_probe
+		 */
+		if (epds->num_bulk_in == 0 || epds->num_bulk_out == 0) {
+			dev_info(ddev, "PL-2303 hack: descriptors matched but endpoints did not\n");
+			return -ENODEV;
+		}
+	}
+	/* END HORRIBLE HACK FOR PL2303 */
+
+	if (epds->num_interrupt_in < 1) {
+		dev_err(ddev, "required interrupt-in endpoint missing\n");
+		return -ENODEV;
+	}
+
+	return 1;
+}
+
 static int pl2303_startup(struct usb_serial *serial)
 {
 	struct pl2303_serial_private *spriv;
@@ -930,10 +983,9 @@ static struct usb_serial_driver pl2303_device = {
 		.name =		"pl2303",
 	},
 	.id_table =		id_table,
-	.num_ports =		1,
 	.num_bulk_in =		1,
 	.num_bulk_out =		1,
-	.num_interrupt_in =	1,
+	.num_interrupt_in =	0,	/* see pl2303_calc_num_ports */
 	.bulk_in_size =		256,
 	.bulk_out_size =	256,
 	.open =			pl2303_open,
@@ -949,6 +1001,7 @@ static struct usb_serial_driver pl2303_device = {
 	.process_read_urb =	pl2303_process_read_urb,
 	.read_int_callback =	pl2303_read_int_callback,
 	.probe =		pl2303_probe,
+	.calc_num_ports =	pl2303_calc_num_ports,
 	.attach =		pl2303_startup,
 	.release =		pl2303_release,
 	.port_probe =		pl2303_port_probe,

commit 590298b2232503ee5088c3abfe6cf69d51ade427
Author: Johan Hovold <johan@kernel.org>
Date:   Thu Mar 2 12:51:31 2017 +0100

    USB: serial: pl2303: simplify endpoint check
    
    Simplify the endpoint sanity check by letting core verify that the
    required endpoints are present.
    
    Signed-off-by: Johan Hovold <johan@kernel.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index ca69eb42071b..60840004568a 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -221,17 +221,9 @@ static int pl2303_probe(struct usb_serial *serial,
 static int pl2303_startup(struct usb_serial *serial)
 {
 	struct pl2303_serial_private *spriv;
-	unsigned char num_ports = serial->num_ports;
 	enum pl2303_type type = TYPE_01;
 	unsigned char *buf;
 
-	if (serial->num_bulk_in < num_ports ||
-			serial->num_bulk_out < num_ports ||
-			serial->num_interrupt_in < num_ports) {
-		dev_err(&serial->interface->dev, "missing endpoints\n");
-		return -ENODEV;
-	}
-
 	spriv = kzalloc(sizeof(*spriv), GFP_KERNEL);
 	if (!spriv)
 		return -ENOMEM;
@@ -939,6 +931,9 @@ static struct usb_serial_driver pl2303_device = {
 	},
 	.id_table =		id_table,
 	.num_ports =		1,
+	.num_bulk_in =		1,
+	.num_bulk_out =		1,
+	.num_interrupt_in =	1,
 	.bulk_in_size =		256,
 	.bulk_out_size =	256,
 	.open =			pl2303_open,

commit 54a21903df2f8020bd4bc9fe38668c031255e148
Merge: 255348289f71 5182c2cf2a9b
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu Feb 9 13:57:05 2017 +0100

    Merge tag 'usb-serial-4.11-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/johan/usb-serial into usb-next
    
    Johan writes:
    
    USB-serial updates for v4.11-rc1
    
    These updates include
    
     - a new driver for Renesas uPD78F0730-based devices
    
     - several fixes of failures to check for short transfers, some of which could
       lead to minor information leaks, and in one case a loop-condition underflow
    
     - a fix of a long-standing regression in the ftdi_sio driver which resulted
       in excessive bulk-in interrupts
    
     - a fix for ftdi_sio line-status over-reporting which could lead to an
       endless stream of NULL-characters being forwarded to user space
    
     - a fix for a regression in the console driver
    
     - a fix for another mos7840 NULL-pointer dereference due to a missing endpoint
       sanity check
    
    Included are also some clean ups and fixes for various minor issues, as well as
    a couple of new device IDs that came in late.
    
    All but the final patch have been in linux-next with no reported issues.
    
    Signed-off-by: Johan Hovold <johan@kernel.org>

commit d07830db1bdb254e4b50d366010b219286b8c937
Author: Marcel J.E. Mol <marcel@mesa.nl>
Date:   Mon Jan 30 19:26:40 2017 +0100

    USB: serial: pl2303: add ATEN device ID
    
    Seems that ATEN serial-to-usb devices using pl2303 exist with
    different device ids. This patch adds a missing device ID so it
    is recognised by the driver.
    
    Signed-off-by: Marcel J.E. Mol <marcel@mesa.nl>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Johan Hovold <johan@kernel.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 46fca6b75846..1db4b61bdf7b 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -49,6 +49,7 @@ static const struct usb_device_id id_table[] = {
 	{ USB_DEVICE(IODATA_VENDOR_ID, IODATA_PRODUCT_ID) },
 	{ USB_DEVICE(IODATA_VENDOR_ID, IODATA_PRODUCT_ID_RSAQ5) },
 	{ USB_DEVICE(ATEN_VENDOR_ID, ATEN_PRODUCT_ID) },
+	{ USB_DEVICE(ATEN_VENDOR_ID, ATEN_PRODUCT_ID2) },
 	{ USB_DEVICE(ATEN_VENDOR_ID2, ATEN_PRODUCT_ID) },
 	{ USB_DEVICE(ELCOM_VENDOR_ID, ELCOM_PRODUCT_ID) },
 	{ USB_DEVICE(ELCOM_VENDOR_ID, ELCOM_PRODUCT_ID_UCSGT) },

commit b5fda434b13de8328c57421e31ac91d401c93b97
Author: Johan Hovold <johan@kernel.org>
Date:   Thu Jan 12 14:56:19 2017 +0100

    USB: serial: pl2303: fix line-setting error handling
    
    Make sure to return an error on zero-length transfers when retrieving
    the line settings even if the driver currently ignores the return value.
    
    Also remove a redundant check for short transfer when setting the line
    settings.
    
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Johan Hovold <johan@kernel.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 46fca6b75846..3ba713570c6b 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -449,7 +449,7 @@ static int pl2303_get_line_request(struct usb_serial_port *port,
 	if (ret != 7) {
 		dev_err(&port->dev, "%s - failed: %d\n", __func__, ret);
 
-		if (ret > 0)
+		if (ret >= 0)
 			ret = -EIO;
 
 		return ret;
@@ -469,12 +469,8 @@ static int pl2303_set_line_request(struct usb_serial_port *port,
 	ret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
 				SET_LINE_REQUEST, SET_LINE_REQUEST_TYPE,
 				0, 0, buf, 7, 100);
-	if (ret != 7) {
+	if (ret < 0) {
 		dev_err(&port->dev, "%s - failed: %d\n", __func__, ret);
-
-		if (ret > 0)
-			ret = -EIO;
-
 		return ret;
 	}
 

commit 76ab439ed1b68778e9059c79ecc5d14de76c89a8
Author: Johan Hovold <johan@kernel.org>
Date:   Tue Jan 3 16:40:00 2017 +0100

    USB: serial: pl2303: fix NULL-deref at open
    
    Fix NULL-pointer dereference in open() should a type-0 or type-1 device
    lack the expected endpoints:
    
    Unable to handle kernel NULL pointer dereference at virtual address 00000030
    ...
    PC is at pl2303_open+0x38/0xec [pl2303]
    
    Note that a missing interrupt-in endpoint would have caused open() to
    fail.
    
    Fixes: 1da177e4c3f4 ("Linux-2.6.12-rc2")
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Johan Hovold <johan@kernel.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index ae682e4eeaef..46fca6b75846 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -220,9 +220,17 @@ static int pl2303_probe(struct usb_serial *serial,
 static int pl2303_startup(struct usb_serial *serial)
 {
 	struct pl2303_serial_private *spriv;
+	unsigned char num_ports = serial->num_ports;
 	enum pl2303_type type = TYPE_01;
 	unsigned char *buf;
 
+	if (serial->num_bulk_in < num_ports ||
+			serial->num_bulk_out < num_ports ||
+			serial->num_interrupt_in < num_ports) {
+		dev_err(&serial->interface->dev, "missing endpoints\n");
+		return -ENODEV;
+	}
+
 	spriv = kzalloc(sizeof(*spriv), GFP_KERNEL);
 	if (!spriv)
 		return -ENOMEM;

commit 49bda21266fdf195142e8b5dea057f09e96ada9f
Author: Michał Pecio <michal.pecio@gmail.com>
Date:   Sun Jul 26 11:14:34 2015 +0200

    USB: pl2303: fix baud-rate divisor calculations
    
    This commit fixes the following issues:
    
    1. The 9th bit of buf was believed to be the LSB of divisor's
    exponent, but the hardware interprets it as MSB (9th bit) of the
    mantissa. The exponent is actually one bit shorter and applies
    to base 4, not 2 as previously believed.
    
    2. Loop iterations doubled the exponent instead of incrementing.
    
    3. The exponent wasn't checked for overflow.
    
    4. The function returned requested rate instead of actual rate.
    
    Due to issue #2, the old code deviated from the wrong formula
    described in #1 and actually yielded correct rates when divisor
    was lower than 4096 by using exponents of 0, 2 or 4 base-2,
    interpreted as 0, 1, 2 base-4 with the 9th mantissa bit clear.
    However, at 93.75 kbaud or less the rate turned out too slow
    due to #2 or too fast due to #2 and #3.
    
    I tested this patch by sending and validating 0x00,0x01,..,0xff
    to an FTDI dongle at 234, 987, 2401, 9601, 31415, 115199, 250k,
    500k, 750k, 1M, 1.5M, 3M+1 baud. All rates passed.
    
    I also used pv to check speed at some rates unsupported by FTDI:
    45 (the lowest possible), 2M, 4M, 5M and 6M-1. Looked sane.
    
    Signed-off-by: Michal Pecio <michal.pecio@gmail.com>
    Fixes: 399aa9a75ad3 ("USB: pl2303: use divisors for unsupported baud
    rates")
    Cc: stable <stable@vger.kernel.org> # v3.18
    [johan: update summary ]
    Signed-off-by: Johan Hovold <johan@kernel.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index f5257af33ecf..ae682e4eeaef 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -362,21 +362,38 @@ static speed_t pl2303_encode_baud_rate_direct(unsigned char buf[4],
 static speed_t pl2303_encode_baud_rate_divisor(unsigned char buf[4],
 								speed_t baud)
 {
-	unsigned int tmp;
+	unsigned int baseline, mantissa, exponent;
 
 	/*
 	 * Apparently the formula is:
-	 * baudrate = 12M * 32 / (2^buf[1]) / buf[0]
+	 *   baudrate = 12M * 32 / (mantissa * 4^exponent)
+	 * where
+	 *   mantissa = buf[8:0]
+	 *   exponent = buf[11:9]
 	 */
-	tmp = 12000000 * 32 / baud;
+	baseline = 12000000 * 32;
+	mantissa = baseline / baud;
+	if (mantissa == 0)
+		mantissa = 1;	/* Avoid dividing by zero if baud > 32*12M. */
+	exponent = 0;
+	while (mantissa >= 512) {
+		if (exponent < 7) {
+			mantissa >>= 2;	/* divide by 4 */
+			exponent++;
+		} else {
+			/* Exponent is maxed. Trim mantissa and leave. */
+			mantissa = 511;
+			break;
+		}
+	}
+
 	buf[3] = 0x80;
 	buf[2] = 0;
-	buf[1] = (tmp >= 256);
-	while (tmp >= 256) {
-		tmp >>= 2;
-		buf[1] <<= 1;
-	}
-	buf[0] = tmp;
+	buf[1] = exponent << 1 | mantissa >> 8;
+	buf[0] = mantissa & 0xff;
+
+	/* Calculate and return the exact baud rate. */
+	baud = (baseline / mantissa) >> (exponent << 1);
 
 	return baud;
 }

commit 48ef23a4f686b1e4519d4193c20d26834ff810ff
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Wed Apr 22 14:35:08 2015 +0200

    USB: pl2303: Remove support for Samsung I330
    
    This phone is already supported by the visor driver.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Fixes: 1da177e4c3f4 ("Linux-2.6.12-rc2")
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Johan Hovold <johan@kernel.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 829604d11f3f..f5257af33ecf 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -61,7 +61,6 @@ static const struct usb_device_id id_table[] = {
 	{ USB_DEVICE(DCU10_VENDOR_ID, DCU10_PRODUCT_ID) },
 	{ USB_DEVICE(SITECOM_VENDOR_ID, SITECOM_PRODUCT_ID) },
 	{ USB_DEVICE(ALCATEL_VENDOR_ID, ALCATEL_PRODUCT_ID) },
-	{ USB_DEVICE(SAMSUNG_VENDOR_ID, SAMSUNG_PRODUCT_ID) },
 	{ USB_DEVICE(SIEMENS_VENDOR_ID, SIEMENS_PRODUCT_ID_SX1),
 		.driver_info = PL2303_QUIRK_UART_STATE_IDX0 },
 	{ USB_DEVICE(SIEMENS_VENDOR_ID, SIEMENS_PRODUCT_ID_X65),

commit 52772a7fd3d354ec1b88d85c83e98cbdcfb02787
Author: Johan Hovold <johan@kernel.org>
Date:   Thu Feb 26 16:50:24 2015 +0100

    USB: pl2303: disable break on shutdown
    
    Currently an enabled break state is not disabled on final close nor on
    re-open and has to be disabled manually.
    
    Fix this by disabling break on port shutdown.
    
    Reported-by: Jari Ruusu <jariruusu@users.sourceforge.net>
    Tested-by: Jari Ruusu <jariruusu@users.sourceforge.net>
    Signed-off-by: Johan Hovold <johan@kernel.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 0f872e6b2c87..829604d11f3f 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -132,6 +132,7 @@ MODULE_DEVICE_TABLE(usb, id_table);
 #define UART_OVERRUN_ERROR		0x40
 #define UART_CTS			0x80
 
+static void pl2303_set_break(struct usb_serial_port *port, bool enable);
 
 enum pl2303_type {
 	TYPE_01,	/* Type 0 and 1 (difference unknown) */
@@ -615,6 +616,7 @@ static void pl2303_close(struct usb_serial_port *port)
 {
 	usb_serial_generic_close(port);
 	usb_kill_urb(port->interrupt_in_urb);
+	pl2303_set_break(port, false);
 }
 
 static int pl2303_open(struct tty_struct *tty, struct usb_serial_port *port)
@@ -741,17 +743,16 @@ static int pl2303_ioctl(struct tty_struct *tty,
 	return -ENOIOCTLCMD;
 }
 
-static void pl2303_break_ctl(struct tty_struct *tty, int break_state)
+static void pl2303_set_break(struct usb_serial_port *port, bool enable)
 {
-	struct usb_serial_port *port = tty->driver_data;
 	struct usb_serial *serial = port->serial;
 	u16 state;
 	int result;
 
-	if (break_state == 0)
-		state = BREAK_OFF;
-	else
+	if (enable)
 		state = BREAK_ON;
+	else
+		state = BREAK_OFF;
 
 	dev_dbg(&port->dev, "%s - turning break %s\n", __func__,
 			state == BREAK_OFF ? "off" : "on");
@@ -763,6 +764,13 @@ static void pl2303_break_ctl(struct tty_struct *tty, int break_state)
 		dev_err(&port->dev, "error sending break = %d\n", result);
 }
 
+static void pl2303_break_ctl(struct tty_struct *tty, int state)
+{
+	struct usb_serial_port *port = tty->driver_data;
+
+	pl2303_set_break(port, state);
+}
+
 static void pl2303_update_line_status(struct usb_serial_port *port,
 				      unsigned char *data,
 				      unsigned int actual_length)

commit 399aa9a75ad372b301e5050f3653a297a767fdc4
Author: Lauri Hintsala <lauri.hintsala@bluegiga.com>
Date:   Wed Aug 13 15:02:53 2014 +0300

    USB: pl2303: use divisors for unsupported baud rates
    
    Use direct method for supported baud rates, otherwise use divisors.
    Limit baud rate to 12 Mbaud with HX type.
    
    This change has been tested to work with PL-2303HX at 115200, 500000,
    1000000, 2000000, 2500000, 3000000 and 4000000 baud rates.
    
    Signed-off-by: Lauri Hintsala <lauri.hintsala@bluegiga.com>
    Signed-off-by: Johan Hovold <johan@kernel.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index e9bad928039f..0f872e6b2c87 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -162,6 +162,9 @@ static const struct pl2303_type_data pl2303_type_data[TYPE_COUNT] = {
 		.max_baud_rate =	1228800,
 		.quirks =		PL2303_QUIRK_LEGACY,
 	},
+	[TYPE_HX] = {
+		.max_baud_rate =	12000000,
+	},
 };
 
 static int pl2303_vendor_read(struct usb_serial *serial, u16 value,
@@ -395,16 +398,14 @@ static void pl2303_encode_baud_rate(struct tty_struct *tty,
 	if (spriv->type->max_baud_rate)
 		baud = min_t(speed_t, baud, spriv->type->max_baud_rate);
 	/*
-	 * Set baud rate to nearest supported value.
-	 *
-	 * NOTE: Baud rate 500k can only be set using divisors.
+	 * Use direct method for supported baud rates, otherwise use divisors.
 	 */
 	baud_sup = pl2303_get_supported_baud_rate(baud);
 
-	if (baud == 500000)
-		baud = pl2303_encode_baud_rate_divisor(buf, baud);
+	if (baud == baud_sup)
+		baud = pl2303_encode_baud_rate_direct(buf, baud);
 	else
-		baud = pl2303_encode_baud_rate_direct(buf, baud_sup);
+		baud = pl2303_encode_baud_rate_divisor(buf, baud);
 
 	/* Save resulting baud rate */
 	tty_encode_baud_rate(tty, baud, baud);

commit 91fcb1ce420e0a5f8d92d556d7008a78bc6ce1eb
Author: Greg KH <gregkh@linuxfoundation.org>
Date:   Fri Aug 15 15:22:21 2014 +0800

    USB: serial: pl2303: add device id for ztek device
    
    This adds a new device id to the pl2303 driver for the ZTEK device.
    
    Reported-by: Mike Chu <Mike-Chu@prolific.com.tw>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Johan Hovold <johan@kernel.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index b3d5a35c0d4b..e9bad928039f 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -45,6 +45,7 @@ static const struct usb_device_id id_table[] = {
 	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_GPRS) },
 	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_HCR331) },
 	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_MOTOROLA) },
+	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_ZTEK) },
 	{ USB_DEVICE(IODATA_VENDOR_ID, IODATA_PRODUCT_ID) },
 	{ USB_DEVICE(IODATA_VENDOR_ID, IODATA_PRODUCT_ID_RSAQ5) },
 	{ USB_DEVICE(ATEN_VENDOR_ID, ATEN_PRODUCT_ID) },

commit b16c02fbfb963fa2941b7517ebf1f8a21946775e
Author: Aaron Sanders <aaron.sanders@hp.com>
Date:   Mon Mar 31 15:54:21 2014 +0200

    USB: pl2303: add ids for Hewlett-Packard HP POS pole displays
    
    Add device ids to pl2303 for the Hewlett-Packard HP POS pole displays:
    
    LD960: 03f0:0B39
    LCM220: 03f0:3139
    LCM960: 03f0:3239
    
    [ Johan: fix indentation and sort PIDs numerically ]
    
    Signed-off-by: Aaron Sanders <aaron.sanders@hp.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 2e22fc22c382..b3d5a35c0d4b 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -83,6 +83,9 @@ static const struct usb_device_id id_table[] = {
 	{ USB_DEVICE(YCCABLE_VENDOR_ID, YCCABLE_PRODUCT_ID) },
 	{ USB_DEVICE(SUPERIAL_VENDOR_ID, SUPERIAL_PRODUCT_ID) },
 	{ USB_DEVICE(HP_VENDOR_ID, HP_LD220_PRODUCT_ID) },
+	{ USB_DEVICE(HP_VENDOR_ID, HP_LD960_PRODUCT_ID) },
+	{ USB_DEVICE(HP_VENDOR_ID, HP_LCM220_PRODUCT_ID) },
+	{ USB_DEVICE(HP_VENDOR_ID, HP_LCM960_PRODUCT_ID) },
 	{ USB_DEVICE(CRESSI_VENDOR_ID, CRESSI_EDY_PRODUCT_ID) },
 	{ USB_DEVICE(ZEAGLE_VENDOR_ID, ZEAGLE_N2ITION3_PRODUCT_ID) },
 	{ USB_DEVICE(SONY_VENDOR_ID, SONY_QN3USB_PRODUCT_ID) },

commit 803a536243b3a1ed2289f41897b11b72bd083309
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Wed Jan 8 11:08:26 2014 -0500

    usb: delete non-required instances of include <linux/init.h>
    
    None of these files are actually using any __init type directives
    and hence don't need to include <linux/init.h>.  Most are just a
    left over from __devinit and __cpuinit removal, or simply due to
    code getting copied from one driver to the next.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index abee31825fc5..2e22fc22c382 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -16,7 +16,6 @@
 
 #include <linux/kernel.h>
 #include <linux/errno.h>
-#include <linux/init.h>
 #include <linux/slab.h>
 #include <linux/tty.h>
 #include <linux/tty_driver.h>

commit a4bcb2945926901bbacf978eb0c0fdda5b327dc7
Author: Johan Hovold <jhovold@gmail.com>
Date:   Thu Jan 2 22:49:23 2014 +0100

    USB: pl2303: switch to generic TIOCMIWAIT implementation
    
    Switch to the generic TIOCMIWAIT implementation which does not suffer
    from the races involved when using the deprecated sleep_on functions.
    
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 64f093f16981..abee31825fc5 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -712,46 +712,6 @@ static int pl2303_carrier_raised(struct usb_serial_port *port)
 	return 0;
 }
 
-static int pl2303_tiocmiwait(struct tty_struct *tty, unsigned long arg)
-{
-	struct usb_serial_port *port = tty->driver_data;
-	struct pl2303_private *priv = usb_get_serial_port_data(port);
-	unsigned long flags;
-	unsigned int prevstatus;
-	unsigned int status;
-	unsigned int changed;
-
-	spin_lock_irqsave(&priv->lock, flags);
-	prevstatus = priv->line_status;
-	spin_unlock_irqrestore(&priv->lock, flags);
-
-	while (1) {
-		interruptible_sleep_on(&port->port.delta_msr_wait);
-		/* see if a signal did it */
-		if (signal_pending(current))
-			return -ERESTARTSYS;
-
-		if (port->serial->disconnected)
-			return -EIO;
-
-		spin_lock_irqsave(&priv->lock, flags);
-		status = priv->line_status;
-		spin_unlock_irqrestore(&priv->lock, flags);
-
-		changed = prevstatus ^ status;
-
-		if (((arg & TIOCM_RNG) && (changed & UART_RING)) ||
-		    ((arg & TIOCM_DSR) && (changed & UART_DSR)) ||
-		    ((arg & TIOCM_CD)  && (changed & UART_DCD)) ||
-		    ((arg & TIOCM_CTS) && (changed & UART_CTS))) {
-			return 0;
-		}
-		prevstatus = status;
-	}
-	/* NOTREACHED */
-	return 0;
-}
-
 static int pl2303_ioctl(struct tty_struct *tty,
 			unsigned int cmd, unsigned long arg)
 {
@@ -830,7 +790,14 @@ static void pl2303_update_line_status(struct usb_serial_port *port,
 		usb_serial_handle_break(port);
 
 	if (delta & UART_STATE_MSR_MASK) {
+		if (delta & UART_CTS)
+			port->icount.cts++;
+		if (delta & UART_DSR)
+			port->icount.dsr++;
+		if (delta & UART_RING)
+			port->icount.rng++;
 		if (delta & UART_DCD) {
+			port->icount.dcd++;
 			tty = tty_port_tty_get(&port->port);
 			if (tty) {
 				usb_serial_handle_dcd_change(port, tty,
@@ -950,7 +917,7 @@ static struct usb_serial_driver pl2303_device = {
 	.set_termios =		pl2303_set_termios,
 	.tiocmget =		pl2303_tiocmget,
 	.tiocmset =		pl2303_tiocmset,
-	.tiocmiwait =		pl2303_tiocmiwait,
+	.tiocmiwait =		usb_serial_generic_tiocmiwait,
 	.process_read_urb =	pl2303_process_read_urb,
 	.read_int_callback =	pl2303_read_int_callback,
 	.probe =		pl2303_probe,

commit dbfd2866ac36bab52a4f37384e935eb5df76ad60
Author: Johan Hovold <jhovold@gmail.com>
Date:   Thu Jan 2 22:49:22 2014 +0100

    USB: pl2303: only wake up MSR queue on changes
    
    Only wake up MSR wait queue on actual modem-status changes.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 11de1f169308..64f093f16981 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -118,6 +118,7 @@ MODULE_DEVICE_TABLE(usb, id_table);
 #define VENDOR_READ_REQUEST		0x01
 
 #define UART_STATE_INDEX		8
+#define UART_STATE_MSR_MASK		0x8b
 #define UART_STATE_TRANSIENT_MASK	0x74
 #define UART_DCD			0x01
 #define UART_DSR			0x02
@@ -828,15 +829,17 @@ static void pl2303_update_line_status(struct usb_serial_port *port,
 	if (status & UART_BREAK_ERROR)
 		usb_serial_handle_break(port);
 
-	wake_up_interruptible(&port->port.delta_msr_wait);
-
-	if (delta & UART_DCD) {
-		tty = tty_port_tty_get(&port->port);
-		if (tty) {
-			usb_serial_handle_dcd_change(port, tty,
+	if (delta & UART_STATE_MSR_MASK) {
+		if (delta & UART_DCD) {
+			tty = tty_port_tty_get(&port->port);
+			if (tty) {
+				usb_serial_handle_dcd_change(port, tty,
 							status & UART_DCD);
-			tty_kref_put(tty);
+				tty_kref_put(tty);
+			}
 		}
+
+		wake_up_interruptible(&port->port.delta_msr_wait);
 	}
 }
 

commit 6020c3bec359873c1e4081785f220db99694c4e4
Author: Johan Hovold <jhovold@gmail.com>
Date:   Thu Jan 2 22:49:21 2014 +0100

    USB: pl2303: clean up line-status handling
    
    Clean up line-status handling somewhat.
    Get tty-reference only when actually needed.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 9951dfddc784..11de1f169308 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -808,7 +808,8 @@ static void pl2303_update_line_status(struct usb_serial_port *port,
 	struct tty_struct *tty;
 	unsigned long flags;
 	unsigned int status_idx = UART_STATE_INDEX;
-	u8 prev_line_status;
+	u8 status;
+	u8 delta;
 
 	if (spriv->quirks & PL2303_QUIRK_UART_STATE_IDX0)
 		status_idx = 0;
@@ -816,24 +817,27 @@ static void pl2303_update_line_status(struct usb_serial_port *port,
 	if (actual_length < status_idx + 1)
 		return;
 
+	status = data[status_idx];
+
 	/* Save off the uart status for others to look at */
 	spin_lock_irqsave(&priv->lock, flags);
-	prev_line_status = priv->line_status;
-	priv->line_status = data[status_idx];
+	delta = priv->line_status ^ status;
+	priv->line_status = status;
 	spin_unlock_irqrestore(&priv->lock, flags);
 
-	if (priv->line_status & UART_BREAK_ERROR)
+	if (status & UART_BREAK_ERROR)
 		usb_serial_handle_break(port);
 
 	wake_up_interruptible(&port->port.delta_msr_wait);
 
-	tty = tty_port_tty_get(&port->port);
-	if (!tty)
-		return;
-	if ((priv->line_status ^ prev_line_status) & UART_DCD)
-		usb_serial_handle_dcd_change(port, tty,
-				priv->line_status & UART_DCD);
-	tty_kref_put(tty);
+	if (delta & UART_DCD) {
+		tty = tty_port_tty_get(&port->port);
+		if (tty) {
+			usb_serial_handle_dcd_change(port, tty,
+							status & UART_DCD);
+			tty_kref_put(tty);
+		}
+	}
 }
 
 static void pl2303_read_int_callback(struct urb *urb)

commit b693468155f5650dcaf01089ecf2b56ab66f9271
Author: Johan Hovold <jhovold@gmail.com>
Date:   Thu Jan 2 22:49:20 2014 +0100

    USB: pl2303: make type data const
    
    Declare constant device-type data as const.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 253cc9c367c1..9951dfddc784 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -141,7 +141,7 @@ struct pl2303_type_data {
 };
 
 struct pl2303_serial_private {
-	struct pl2303_type_data *type;
+	const struct pl2303_type_data *type;
 	unsigned long quirks;
 };
 
@@ -153,7 +153,7 @@ struct pl2303_private {
 	u8 line_settings[7];
 };
 
-static struct pl2303_type_data pl2303_type_data[TYPE_COUNT] = {
+static const struct pl2303_type_data pl2303_type_data[TYPE_COUNT] = {
 	[TYPE_01] = {
 		.max_baud_rate =	1228800,
 		.quirks =		PL2303_QUIRK_LEGACY,

commit 619c43543a946dd2f094d2f1bfc81a3fd48356d8
Author: Johan Hovold <jhovold@gmail.com>
Date:   Sun Dec 29 19:23:18 2013 +0100

    USB: pl2303: use C_CMSPAR macro
    
    Use the new C_CMSPAR macro for consistency.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 28e598638e0a..253cc9c367c1 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -523,7 +523,7 @@ static void pl2303_set_termios(struct tty_struct *tty,
 		/* For reference buf[5]=3 is mark parity */
 		/* For reference buf[5]=4 is space parity */
 		if (C_PARODD(tty)) {
-			if (tty->termios.c_cflag & CMSPAR) {
+			if (C_CMSPAR(tty)) {
 				buf[5] = 3;
 				dev_dbg(&port->dev, "parity = mark\n");
 			} else {
@@ -531,7 +531,7 @@ static void pl2303_set_termios(struct tty_struct *tty,
 				dev_dbg(&port->dev, "parity = odd\n");
 			}
 		} else {
-			if (tty->termios.c_cflag & CMSPAR) {
+			if (C_CMSPAR(tty)) {
 				buf[5] = 4;
 				dev_dbg(&port->dev, "parity = space\n");
 			} else {

commit 5d85045f4b082800beb384094fc67fa0d2096563
Author: Johan Hovold <jhovold@gmail.com>
Date:   Sun Dec 29 19:23:15 2013 +0100

    USB: pl2303: use direct baud-rate encoding when possible
    
    Use direct baud-rate encoding rather than divisors for supported baud
    rates.
    
    This restores the way baud rates were set prior to commit 8d48fdf689fe
    ("USB: PL2303: correctly handle baudrates above 115200") which added
    divisor encoding, but also switched to the new encoding method for all
    baudrates above 115200.
    
    As noted by Frank Schäfer <fschaefer.oss@googlemail.com>, baud rate 500k
    was later errounously added to the supported baud-rate table although
    it can only be set using divisors.
    
    Note that the current implementation could easily be extended to support
    arbitrary non-standard baud rates using divisors (e.g. by falling back
    to divisors when the table lookup fails).
    
    Cc: Frank Schäfer <fschaefer.oss@googlemail.com>
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index b4e72979def7..28e598638e0a 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -312,14 +312,15 @@ static int pl2303_set_control_lines(struct usb_serial_port *port, u8 value)
 }
 
 /*
- * Returns the nearest supported baud rate.
+ * Returns the nearest supported baud rate that can be set directly without
+ * using divisors.
  */
 static speed_t pl2303_get_supported_baud_rate(speed_t baud)
 {
 	static const speed_t baud_sup[] = {
 		75, 150, 300, 600, 1200, 1800, 2400, 3600, 4800, 7200, 9600,
 		14400, 19200, 28800, 38400, 57600, 115200, 230400, 460800,
-		500000, 614400, 921600, 1228800, 2457600, 3000000, 6000000
+		614400, 921600, 1228800, 2457600, 3000000, 6000000
 	};
 
 	unsigned i;
@@ -379,6 +380,7 @@ static void pl2303_encode_baud_rate(struct tty_struct *tty,
 {
 	struct usb_serial *serial = port->serial;
 	struct pl2303_serial_private *spriv = usb_get_serial_data(serial);
+	speed_t	baud_sup;
 	speed_t baud;
 
 	baud = tty_get_baud_rate(tty);
@@ -388,14 +390,17 @@ static void pl2303_encode_baud_rate(struct tty_struct *tty,
 
 	if (spriv->type->max_baud_rate)
 		baud = min_t(speed_t, baud, spriv->type->max_baud_rate);
+	/*
+	 * Set baud rate to nearest supported value.
+	 *
+	 * NOTE: Baud rate 500k can only be set using divisors.
+	 */
+	baud_sup = pl2303_get_supported_baud_rate(baud);
 
-	/* Set baud rate to nearest supported value. */
-	baud = pl2303_get_supported_baud_rate(baud);
-
-	if (baud <= 115200)
-		baud = pl2303_encode_baud_rate_direct(buf, baud);
-	else
+	if (baud == 500000)
 		baud = pl2303_encode_baud_rate_divisor(buf, baud);
+	else
+		baud = pl2303_encode_baud_rate_direct(buf, baud_sup);
 
 	/* Save resulting baud rate */
 	tty_encode_baud_rate(tty, baud, baud);

commit 20b4c787199f4fcf0fae5ed78a4ff0104e2afaa3
Author: Johan Hovold <jhovold@gmail.com>
Date:   Sun Dec 29 19:23:14 2013 +0100

    USB: pl2303: add helper function for direct baud-rate encoding
    
    Add helper function for direct baud-rate encoding.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 44f4b546adeb..b4e72979def7 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -339,6 +339,18 @@ static speed_t pl2303_get_supported_baud_rate(speed_t baud)
 	return baud;
 }
 
+/*
+ * NOTE: If unsupported baud rates are set directly, the PL2303 seems to
+ *       use 9600 baud.
+ */
+static speed_t pl2303_encode_baud_rate_direct(unsigned char buf[4],
+								speed_t baud)
+{
+	put_unaligned_le32(baud, buf);
+
+	return baud;
+}
+
 static speed_t pl2303_encode_baud_rate_divisor(unsigned char buf[4],
 								speed_t baud)
 {
@@ -376,16 +388,12 @@ static void pl2303_encode_baud_rate(struct tty_struct *tty,
 
 	if (spriv->type->max_baud_rate)
 		baud = min_t(speed_t, baud, spriv->type->max_baud_rate);
-	/*
-	 * Set baud rate to nearest supported value.
-	 *
-	 * NOTE: If unsupported values are set directly, the PL2303 seems to
-	 *       use 9600 baud.
-	 */
+
+	/* Set baud rate to nearest supported value. */
 	baud = pl2303_get_supported_baud_rate(baud);
 
 	if (baud <= 115200)
-		put_unaligned_le32(baud, buf);
+		baud = pl2303_encode_baud_rate_direct(buf, baud);
 	else
 		baud = pl2303_encode_baud_rate_divisor(buf, baud);
 

commit c82c6d45a2fc882fedfde517ba86690b2d5ed555
Author: Johan Hovold <jhovold@gmail.com>
Date:   Sun Dec 29 19:23:13 2013 +0100

    USB: pl2303: refactor baud-rate divisor handling
    
    Refactor baud-rate divisor handling.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 394903b4ecb7..44f4b546adeb 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -339,6 +339,28 @@ static speed_t pl2303_get_supported_baud_rate(speed_t baud)
 	return baud;
 }
 
+static speed_t pl2303_encode_baud_rate_divisor(unsigned char buf[4],
+								speed_t baud)
+{
+	unsigned int tmp;
+
+	/*
+	 * Apparently the formula is:
+	 * baudrate = 12M * 32 / (2^buf[1]) / buf[0]
+	 */
+	tmp = 12000000 * 32 / baud;
+	buf[3] = 0x80;
+	buf[2] = 0;
+	buf[1] = (tmp >= 256);
+	while (tmp >= 256) {
+		tmp >>= 2;
+		buf[1] <<= 1;
+	}
+	buf[0] = tmp;
+
+	return baud;
+}
+
 static void pl2303_encode_baud_rate(struct tty_struct *tty,
 					struct usb_serial_port *port,
 					u8 buf[4])
@@ -362,23 +384,10 @@ static void pl2303_encode_baud_rate(struct tty_struct *tty,
 	 */
 	baud = pl2303_get_supported_baud_rate(baud);
 
-	if (baud <= 115200) {
+	if (baud <= 115200)
 		put_unaligned_le32(baud, buf);
-	} else {
-		/*
-		 * Apparently the formula for higher speeds is:
-		 * baudrate = 12M * 32 / (2^buf[1]) / buf[0]
-		 */
-		unsigned tmp = 12000000 * 32 / baud;
-		buf[3] = 0x80;
-		buf[2] = 0;
-		buf[1] = (tmp >= 256);
-		while (tmp >= 256) {
-			tmp >>= 2;
-			buf[1] <<= 1;
-		}
-		buf[0] = tmp;
-	}
+	else
+		baud = pl2303_encode_baud_rate_divisor(buf, baud);
 
 	/* Save resulting baud rate */
 	tty_encode_baud_rate(tty, baud, baud);

commit 871996ede12306cd1d75ed8135bed6f1fcbcd0e6
Author: Johan Hovold <jhovold@gmail.com>
Date:   Sun Dec 29 19:23:12 2013 +0100

    USB: pl2303: enforce baud-rate limits before lookup
    
    Enforce any baud-rate limits before doing table lookup.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 9a95b92310f2..394903b4ecb7 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -351,6 +351,9 @@ static void pl2303_encode_baud_rate(struct tty_struct *tty,
 	dev_dbg(&port->dev, "baud requested = %u\n", baud);
 	if (!baud)
 		return;
+
+	if (spriv->type->max_baud_rate)
+		baud = min_t(speed_t, baud, spriv->type->max_baud_rate);
 	/*
 	 * Set baud rate to nearest supported value.
 	 *
@@ -359,9 +362,6 @@ static void pl2303_encode_baud_rate(struct tty_struct *tty,
 	 */
 	baud = pl2303_get_supported_baud_rate(baud);
 
-	if (spriv->type->max_baud_rate)
-		baud = min_t(speed_t, baud, spriv->type->max_baud_rate);
-
 	if (baud <= 115200) {
 		put_unaligned_le32(baud, buf);
 	} else {

commit 59afe10e8dd33d26f8c2ae7572f9023044e71bab
Author: Johan Hovold <jhovold@gmail.com>
Date:   Sun Dec 29 19:23:11 2013 +0100

    USB: pl2303: refactor baud-rate table lookup
    
    Refactor supported baud-rate table lookup.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 8d792afbe27f..9a95b92310f2 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -311,31 +311,19 @@ static int pl2303_set_control_lines(struct usb_serial_port *port, u8 value)
 	return retval;
 }
 
-static void pl2303_encode_baud_rate(struct tty_struct *tty,
-					struct usb_serial_port *port,
-					u8 buf[4])
+/*
+ * Returns the nearest supported baud rate.
+ */
+static speed_t pl2303_get_supported_baud_rate(speed_t baud)
 {
-	const speed_t baud_sup[] = { 75, 150, 300, 600, 1200, 1800, 2400, 3600,
-	                         4800, 7200, 9600, 14400, 19200, 28800, 38400,
-	                         57600, 115200, 230400, 460800, 500000, 614400,
-	                         921600, 1228800, 2457600, 3000000, 6000000 };
+	static const speed_t baud_sup[] = {
+		75, 150, 300, 600, 1200, 1800, 2400, 3600, 4800, 7200, 9600,
+		14400, 19200, 28800, 38400, 57600, 115200, 230400, 460800,
+		500000, 614400, 921600, 1228800, 2457600, 3000000, 6000000
+	};
 
-	struct usb_serial *serial = port->serial;
-	struct pl2303_serial_private *spriv = usb_get_serial_data(serial);
-	speed_t baud;
-	int i;
+	unsigned i;
 
-	/*
-	 * NOTE: Only the values defined in baud_sup are supported!
-	 *       => if unsupported values are set, the PL2303 seems to use
-	 *          9600 baud (at least my PL2303X always does)
-	 */
-	baud = tty_get_baud_rate(tty);
-	dev_dbg(&port->dev, "baud requested = %u\n", baud);
-	if (!baud)
-		return;
-
-	/* Set baud rate to nearest supported value */
 	for (i = 0; i < ARRAY_SIZE(baud_sup); ++i) {
 		if (baud_sup[i] > baud)
 			break;
@@ -348,6 +336,29 @@ static void pl2303_encode_baud_rate(struct tty_struct *tty,
 	else
 		baud = baud_sup[i];
 
+	return baud;
+}
+
+static void pl2303_encode_baud_rate(struct tty_struct *tty,
+					struct usb_serial_port *port,
+					u8 buf[4])
+{
+	struct usb_serial *serial = port->serial;
+	struct pl2303_serial_private *spriv = usb_get_serial_data(serial);
+	speed_t baud;
+
+	baud = tty_get_baud_rate(tty);
+	dev_dbg(&port->dev, "baud requested = %u\n", baud);
+	if (!baud)
+		return;
+	/*
+	 * Set baud rate to nearest supported value.
+	 *
+	 * NOTE: If unsupported values are set directly, the PL2303 seems to
+	 *       use 9600 baud.
+	 */
+	baud = pl2303_get_supported_baud_rate(baud);
+
 	if (spriv->type->max_baud_rate)
 		baud = min_t(speed_t, baud, spriv->type->max_baud_rate);
 

commit 79816824c1ae73542d9523283ce353142b67563e
Author: Johan Hovold <jhovold@gmail.com>
Date:   Sun Dec 29 19:23:10 2013 +0100

    USB: pl2303: rename pl2303_encode_baud_rate
    
    Rename baud-rate encoding function to match tty naming.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 35aa4973a137..8d792afbe27f 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -311,7 +311,7 @@ static int pl2303_set_control_lines(struct usb_serial_port *port, u8 value)
 	return retval;
 }
 
-static void pl2303_encode_baudrate(struct tty_struct *tty,
+static void pl2303_encode_baud_rate(struct tty_struct *tty,
 					struct usb_serial_port *port,
 					u8 buf[4])
 {
@@ -335,7 +335,7 @@ static void pl2303_encode_baudrate(struct tty_struct *tty,
 	if (!baud)
 		return;
 
-	/* Set baudrate to nearest supported value */
+	/* Set baud rate to nearest supported value */
 	for (i = 0; i < ARRAY_SIZE(baud_sup); ++i) {
 		if (baud_sup[i] > baud)
 			break;
@@ -461,7 +461,7 @@ static void pl2303_set_termios(struct tty_struct *tty,
 	dev_dbg(&port->dev, "data bits = %d\n", buf[6]);
 
 	/* For reference buf[0]:buf[3] baud rate value */
-	pl2303_encode_baudrate(tty, port, &buf[0]);
+	pl2303_encode_baud_rate(tty, port, &buf[0]);
 
 	/* For reference buf[4]=0 is 1 stop bits */
 	/* For reference buf[4]=1 is 1.5 stop bits */

commit 359defdaa46c6ecf6a29600f3d57c663c9c35fd2
Author: Johan Hovold <jhovold@gmail.com>
Date:   Sun Dec 29 19:23:09 2013 +0100

    USB: pl2303: add device-type abstraction
    
    Encode all device-type specifics in a struct rather than testing for
    device type and spreading such information throughout the driver.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 014dea1e6d03..35aa4973a137 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -132,10 +132,16 @@ MODULE_DEVICE_TABLE(usb, id_table);
 enum pl2303_type {
 	TYPE_01,	/* Type 0 and 1 (difference unknown) */
 	TYPE_HX,	/* HX version of the pl2303 chip */
+	TYPE_COUNT
+};
+
+struct pl2303_type_data {
+	speed_t max_baud_rate;
+	unsigned long quirks;
 };
 
 struct pl2303_serial_private {
-	enum pl2303_type type;
+	struct pl2303_type_data *type;
 	unsigned long quirks;
 };
 
@@ -147,6 +153,13 @@ struct pl2303_private {
 	u8 line_settings[7];
 };
 
+static struct pl2303_type_data pl2303_type_data[TYPE_COUNT] = {
+	[TYPE_01] = {
+		.max_baud_rate =	1228800,
+		.quirks =		PL2303_QUIRK_LEGACY,
+	},
+};
+
 static int pl2303_vendor_read(struct usb_serial *serial, u16 value,
 							unsigned char buf[1])
 {
@@ -223,10 +236,9 @@ static int pl2303_startup(struct usb_serial *serial)
 		type = TYPE_01;		/* type 1 */
 	dev_dbg(&serial->interface->dev, "device type: %d\n", type);
 
-	spriv->type = type;
+	spriv->type = &pl2303_type_data[type];
 	spriv->quirks = (unsigned long)usb_get_serial_data(serial);
-	if (type == TYPE_01)
-		spriv->quirks |= PL2303_QUIRK_LEGACY;
+	spriv->quirks |= spriv->type->quirks;
 
 	usb_set_serial_data(serial, spriv);
 
@@ -336,9 +348,8 @@ static void pl2303_encode_baudrate(struct tty_struct *tty,
 	else
 		baud = baud_sup[i];
 
-	/* type_0, type_1 only support up to 1228800 baud */
-	if (spriv->type == TYPE_01)
-		baud = min_t(speed_t, baud, 1228800);
+	if (spriv->type->max_baud_rate)
+		baud = min_t(speed_t, baud, spriv->type->max_baud_rate);
 
 	if (baud <= 115200) {
 		put_unaligned_le32(baud, buf);

commit 23c6acb9684ac87c2e752f61900c7a1a2dd543ac
Author: Johan Hovold <jhovold@gmail.com>
Date:   Sun Dec 29 19:23:08 2013 +0100

    USB: pl2303: add quirk for legacy devices
    
    Add quirk for legacy devices (type 0 and 1) rather than testing on
    device type throughout the driver.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 52f0c96cd98d..014dea1e6d03 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -33,6 +33,7 @@
 
 
 #define PL2303_QUIRK_UART_STATE_IDX0		BIT(0)
+#define PL2303_QUIRK_LEGACY			BIT(1)
 
 static const struct usb_device_id id_table[] = {
 	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID) },
@@ -224,6 +225,8 @@ static int pl2303_startup(struct usb_serial *serial)
 
 	spriv->type = type;
 	spriv->quirks = (unsigned long)usb_get_serial_data(serial);
+	if (type == TYPE_01)
+		spriv->quirks |= PL2303_QUIRK_LEGACY;
 
 	usb_set_serial_data(serial, spriv);
 
@@ -237,7 +240,7 @@ static int pl2303_startup(struct usb_serial *serial)
 	pl2303_vendor_read(serial, 0x8383, buf);
 	pl2303_vendor_write(serial, 0, 1);
 	pl2303_vendor_write(serial, 1, 0);
-	if (type == TYPE_01)
+	if (spriv->quirks & PL2303_QUIRK_LEGACY)
 		pl2303_vendor_write(serial, 2, 0x24);
 	else
 		pl2303_vendor_write(serial, 2, 0x44);
@@ -531,7 +534,7 @@ static void pl2303_set_termios(struct tty_struct *tty,
 	}
 
 	if (C_CRTSCTS(tty)) {
-		if (spriv->type == TYPE_01)
+		if (spriv->quirks & PL2303_QUIRK_LEGACY)
 			pl2303_vendor_write(serial, 0x0, 0x41);
 		else
 			pl2303_vendor_write(serial, 0x0, 0x61);
@@ -571,7 +574,7 @@ static int pl2303_open(struct tty_struct *tty, struct usb_serial_port *port)
 	struct pl2303_serial_private *spriv = usb_get_serial_data(serial);
 	int result;
 
-	if (spriv->type == TYPE_01) {
+	if (spriv->quirks & PL2303_QUIRK_LEGACY) {
 		usb_clear_halt(serial->dev, port->write_urb->pipe);
 		usb_clear_halt(serial->dev, port->read_urb->pipe);
 	} else {

commit 7f966ac7a939633ff6fa8cec58982676c243b4f8
Author: Johan Hovold <jhovold@gmail.com>
Date:   Sun Dec 29 19:23:07 2013 +0100

    USB: pl2303: clean up type handling
    
    Merge types 0 and 1, whose differences are unknown and have always been
    treated the same.
    Add TYPE_-prefix to both types.
    Test for TYPE_01 (rather than !TYPE_HX) for legacy device quirks.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 40f7b80b3601..52f0c96cd98d 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -129,9 +129,8 @@ MODULE_DEVICE_TABLE(usb, id_table);
 
 
 enum pl2303_type {
-	type_0,		/* don't know the difference between type 0 and */
-	type_1,		/* type 1, until someone from prolific tells us... */
-	HX,		/* HX version of the pl2303 chip */
+	TYPE_01,	/* Type 0 and 1 (difference unknown) */
+	TYPE_HX,	/* HX version of the pl2303 chip */
 };
 
 struct pl2303_serial_private {
@@ -200,7 +199,7 @@ static int pl2303_probe(struct usb_serial *serial,
 static int pl2303_startup(struct usb_serial *serial)
 {
 	struct pl2303_serial_private *spriv;
-	enum pl2303_type type = type_0;
+	enum pl2303_type type = TYPE_01;
 	unsigned char *buf;
 
 	spriv = kzalloc(sizeof(*spriv), GFP_KERNEL);
@@ -214,13 +213,13 @@ static int pl2303_startup(struct usb_serial *serial)
 	}
 
 	if (serial->dev->descriptor.bDeviceClass == 0x02)
-		type = type_0;
+		type = TYPE_01;		/* type 0 */
 	else if (serial->dev->descriptor.bMaxPacketSize0 == 0x40)
-		type = HX;
+		type = TYPE_HX;
 	else if (serial->dev->descriptor.bDeviceClass == 0x00)
-		type = type_1;
+		type = TYPE_01;		/* type 1 */
 	else if (serial->dev->descriptor.bDeviceClass == 0xFF)
-		type = type_1;
+		type = TYPE_01;		/* type 1 */
 	dev_dbg(&serial->interface->dev, "device type: %d\n", type);
 
 	spriv->type = type;
@@ -238,10 +237,10 @@ static int pl2303_startup(struct usb_serial *serial)
 	pl2303_vendor_read(serial, 0x8383, buf);
 	pl2303_vendor_write(serial, 0, 1);
 	pl2303_vendor_write(serial, 1, 0);
-	if (type == HX)
-		pl2303_vendor_write(serial, 2, 0x44);
-	else
+	if (type == TYPE_01)
 		pl2303_vendor_write(serial, 2, 0x24);
+	else
+		pl2303_vendor_write(serial, 2, 0x44);
 
 	kfree(buf);
 
@@ -335,7 +334,7 @@ static void pl2303_encode_baudrate(struct tty_struct *tty,
 		baud = baud_sup[i];
 
 	/* type_0, type_1 only support up to 1228800 baud */
-	if (spriv->type != HX)
+	if (spriv->type == TYPE_01)
 		baud = min_t(speed_t, baud, 1228800);
 
 	if (baud <= 115200) {
@@ -532,10 +531,10 @@ static void pl2303_set_termios(struct tty_struct *tty,
 	}
 
 	if (C_CRTSCTS(tty)) {
-		if (spriv->type == HX)
-			pl2303_vendor_write(serial, 0x0, 0x61);
-		else
+		if (spriv->type == TYPE_01)
 			pl2303_vendor_write(serial, 0x0, 0x41);
+		else
+			pl2303_vendor_write(serial, 0x0, 0x61);
 	} else {
 		pl2303_vendor_write(serial, 0x0, 0x0);
 	}
@@ -572,7 +571,7 @@ static int pl2303_open(struct tty_struct *tty, struct usb_serial_port *port)
 	struct pl2303_serial_private *spriv = usb_get_serial_data(serial);
 	int result;
 
-	if (spriv->type != HX) {
+	if (spriv->type == TYPE_01) {
 		usb_clear_halt(serial->dev, port->write_urb->pipe);
 		usb_clear_halt(serial->dev, port->read_urb->pipe);
 	} else {

commit f84ee3b2f5e5e39041c39268a9eab5046a050d44
Author: Johan Hovold <jhovold@gmail.com>
Date:   Sun Dec 29 19:23:06 2013 +0100

    USB: pl2303: use speed_t for baud rates
    
    Use speed_t for baud rates throughout.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 8dd1c4a0aefd..40f7b80b3601 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -301,14 +301,14 @@ static void pl2303_encode_baudrate(struct tty_struct *tty,
 					struct usb_serial_port *port,
 					u8 buf[4])
 {
-	const int baud_sup[] = { 75, 150, 300, 600, 1200, 1800, 2400, 3600,
+	const speed_t baud_sup[] = { 75, 150, 300, 600, 1200, 1800, 2400, 3600,
 	                         4800, 7200, 9600, 14400, 19200, 28800, 38400,
 	                         57600, 115200, 230400, 460800, 500000, 614400,
 	                         921600, 1228800, 2457600, 3000000, 6000000 };
 
 	struct usb_serial *serial = port->serial;
 	struct pl2303_serial_private *spriv = usb_get_serial_data(serial);
-	int baud;
+	speed_t baud;
 	int i;
 
 	/*
@@ -317,7 +317,7 @@ static void pl2303_encode_baudrate(struct tty_struct *tty,
 	 *          9600 baud (at least my PL2303X always does)
 	 */
 	baud = tty_get_baud_rate(tty);
-	dev_dbg(&port->dev, "baud requested = %d\n", baud);
+	dev_dbg(&port->dev, "baud requested = %u\n", baud);
 	if (!baud)
 		return;
 
@@ -336,7 +336,7 @@ static void pl2303_encode_baudrate(struct tty_struct *tty,
 
 	/* type_0, type_1 only support up to 1228800 baud */
 	if (spriv->type != HX)
-		baud = min_t(int, baud, 1228800);
+		baud = min_t(speed_t, baud, 1228800);
 
 	if (baud <= 115200) {
 		put_unaligned_le32(baud, buf);
@@ -358,7 +358,7 @@ static void pl2303_encode_baudrate(struct tty_struct *tty,
 
 	/* Save resulting baud rate */
 	tty_encode_baud_rate(tty, baud, baud);
-	dev_dbg(&port->dev, "baud set = %d\n", baud);
+	dev_dbg(&port->dev, "baud set = %u\n", baud);
 }
 
 static int pl2303_get_line_request(struct usb_serial_port *port,

commit 228e4105374cffd5372b1dbdf1f8ec8cf1d964ae
Author: Johan Hovold <jhovold@gmail.com>
Date:   Sun Dec 29 19:23:05 2013 +0100

    USB: pl2303: add line-status quirk for Siemens phones
    
    Implement line-status handling for Siemens phones as a quirk rather than
    spreading such information all over the driver by matching on vendor and
    and product ids.
    
    Note that the SIEMENS_PRODUCT_ID_EF81, which was added after the
    line-status handling for the other Siemens phones was fixed, might also
    need this quirk.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 440b99c15435..8dd1c4a0aefd 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -31,6 +31,9 @@
 #include <asm/unaligned.h>
 #include "pl2303.h"
 
+
+#define PL2303_QUIRK_UART_STATE_IDX0		BIT(0)
+
 static const struct usb_device_id id_table[] = {
 	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID) },
 	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_RSAQ2) },
@@ -58,9 +61,12 @@ static const struct usb_device_id id_table[] = {
 	{ USB_DEVICE(SITECOM_VENDOR_ID, SITECOM_PRODUCT_ID) },
 	{ USB_DEVICE(ALCATEL_VENDOR_ID, ALCATEL_PRODUCT_ID) },
 	{ USB_DEVICE(SAMSUNG_VENDOR_ID, SAMSUNG_PRODUCT_ID) },
-	{ USB_DEVICE(SIEMENS_VENDOR_ID, SIEMENS_PRODUCT_ID_SX1) },
-	{ USB_DEVICE(SIEMENS_VENDOR_ID, SIEMENS_PRODUCT_ID_X65) },
-	{ USB_DEVICE(SIEMENS_VENDOR_ID, SIEMENS_PRODUCT_ID_X75) },
+	{ USB_DEVICE(SIEMENS_VENDOR_ID, SIEMENS_PRODUCT_ID_SX1),
+		.driver_info = PL2303_QUIRK_UART_STATE_IDX0 },
+	{ USB_DEVICE(SIEMENS_VENDOR_ID, SIEMENS_PRODUCT_ID_X65),
+		.driver_info = PL2303_QUIRK_UART_STATE_IDX0 },
+	{ USB_DEVICE(SIEMENS_VENDOR_ID, SIEMENS_PRODUCT_ID_X75),
+		.driver_info = PL2303_QUIRK_UART_STATE_IDX0 },
 	{ USB_DEVICE(SIEMENS_VENDOR_ID, SIEMENS_PRODUCT_ID_EF81) },
 	{ USB_DEVICE(BENQ_VENDOR_ID, BENQ_PRODUCT_ID_S81) }, /* Benq/Siemens S81 */
 	{ USB_DEVICE(SYNTECH_VENDOR_ID, SYNTECH_PRODUCT_ID) },
@@ -110,7 +116,7 @@ MODULE_DEVICE_TABLE(usb, id_table);
 #define VENDOR_READ_REQUEST_TYPE	0xc0
 #define VENDOR_READ_REQUEST		0x01
 
-#define UART_STATE			0x08
+#define UART_STATE_INDEX		8
 #define UART_STATE_TRANSIENT_MASK	0x74
 #define UART_DCD			0x01
 #define UART_DSR			0x02
@@ -130,6 +136,7 @@ enum pl2303_type {
 
 struct pl2303_serial_private {
 	enum pl2303_type type;
+	unsigned long quirks;
 };
 
 struct pl2303_private {
@@ -182,6 +189,14 @@ static int pl2303_vendor_write(struct usb_serial *serial, u16 value, u16 index)
 	return 0;
 }
 
+static int pl2303_probe(struct usb_serial *serial,
+					const struct usb_device_id *id)
+{
+	usb_set_serial_data(serial, (void *)id->driver_info);
+
+	return 0;
+}
+
 static int pl2303_startup(struct usb_serial *serial)
 {
 	struct pl2303_serial_private *spriv;
@@ -209,6 +224,8 @@ static int pl2303_startup(struct usb_serial *serial)
 	dev_dbg(&serial->interface->dev, "device type: %d\n", type);
 
 	spriv->type = type;
+	spriv->quirks = (unsigned long)usb_get_serial_data(serial);
+
 	usb_set_serial_data(serial, spriv);
 
 	pl2303_vendor_read(serial, 0x8484, buf);
@@ -739,27 +756,18 @@ static void pl2303_update_line_status(struct usb_serial_port *port,
 				      unsigned char *data,
 				      unsigned int actual_length)
 {
+	struct usb_serial *serial = port->serial;
+	struct pl2303_serial_private *spriv = usb_get_serial_data(serial);
 	struct pl2303_private *priv = usb_get_serial_port_data(port);
 	struct tty_struct *tty;
 	unsigned long flags;
-	u8 status_idx = UART_STATE;
-	u8 length = UART_STATE + 1;
+	unsigned int status_idx = UART_STATE_INDEX;
 	u8 prev_line_status;
-	u16 idv, idp;
 
-	idv = le16_to_cpu(port->serial->dev->descriptor.idVendor);
-	idp = le16_to_cpu(port->serial->dev->descriptor.idProduct);
-
-	if (idv == SIEMENS_VENDOR_ID) {
-		if (idp == SIEMENS_PRODUCT_ID_X65 ||
-		    idp == SIEMENS_PRODUCT_ID_SX1 ||
-		    idp == SIEMENS_PRODUCT_ID_X75) {
-			length = 1;
-			status_idx = 0;
-		}
-	}
+	if (spriv->quirks & PL2303_QUIRK_UART_STATE_IDX0)
+		status_idx = 0;
 
-	if (actual_length < length)
+	if (actual_length < status_idx + 1)
 		return;
 
 	/* Save off the uart status for others to look at */
@@ -892,6 +900,7 @@ static struct usb_serial_driver pl2303_device = {
 	.tiocmiwait =		pl2303_tiocmiwait,
 	.process_read_urb =	pl2303_process_read_urb,
 	.read_int_callback =	pl2303_read_int_callback,
+	.probe =		pl2303_probe,
 	.attach =		pl2303_startup,
 	.release =		pl2303_release,
 	.port_probe =		pl2303_port_probe,

commit 294bb2c6178da6334f54bd88aac7dca63fd89b06
Author: Johan Hovold <jhovold@gmail.com>
Date:   Sun Dec 29 19:23:04 2013 +0100

    USB: pl2303: remove redundant line-request call
    
    Remove redundant get_line_request (the read back settings are never
    used).
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 28b10cfcb4d3..440b99c15435 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -514,9 +514,6 @@ static void pl2303_set_termios(struct tty_struct *tty,
 		spin_unlock_irqrestore(&priv->lock, flags);
 	}
 
-	memset(buf, 0, 7);
-	pl2303_get_line_request(port, buf);
-
 	if (C_CRTSCTS(tty)) {
 		if (spriv->type == HX)
 			pl2303_vendor_write(serial, 0x0, 0x61);

commit 383d19c58729e34b3b94e47da20aa7fe4970a577
Author: Johan Hovold <jhovold@gmail.com>
Date:   Sun Dec 29 19:23:03 2013 +0100

    USB: pl2303: add error handling to line requests
    
    Refactor and add error handling to line requests.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 1fe8545e9926..28b10cfcb4d3 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -344,6 +344,52 @@ static void pl2303_encode_baudrate(struct tty_struct *tty,
 	dev_dbg(&port->dev, "baud set = %d\n", baud);
 }
 
+static int pl2303_get_line_request(struct usb_serial_port *port,
+							unsigned char buf[7])
+{
+	struct usb_device *udev = port->serial->dev;
+	int ret;
+
+	ret = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),
+				GET_LINE_REQUEST, GET_LINE_REQUEST_TYPE,
+				0, 0, buf, 7, 100);
+	if (ret != 7) {
+		dev_err(&port->dev, "%s - failed: %d\n", __func__, ret);
+
+		if (ret > 0)
+			ret = -EIO;
+
+		return ret;
+	}
+
+	dev_dbg(&port->dev, "%s - %7ph\n", __func__, buf);
+
+	return 0;
+}
+
+static int pl2303_set_line_request(struct usb_serial_port *port,
+							unsigned char buf[7])
+{
+	struct usb_device *udev = port->serial->dev;
+	int ret;
+
+	ret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
+				SET_LINE_REQUEST, SET_LINE_REQUEST_TYPE,
+				0, 0, buf, 7, 100);
+	if (ret != 7) {
+		dev_err(&port->dev, "%s - failed: %d\n", __func__, ret);
+
+		if (ret > 0)
+			ret = -EIO;
+
+		return ret;
+	}
+
+	dev_dbg(&port->dev, "%s - %7ph\n", __func__, buf);
+
+	return 0;
+}
+
 static void pl2303_set_termios(struct tty_struct *tty,
 		struct usb_serial_port *port, struct ktermios *old_termios)
 {
@@ -352,7 +398,7 @@ static void pl2303_set_termios(struct tty_struct *tty,
 	struct pl2303_private *priv = usb_get_serial_port_data(port);
 	unsigned long flags;
 	unsigned char *buf;
-	int i;
+	int ret;
 	u8 control;
 
 	if (old_termios && !tty_termios_hw_change(&tty->termios, old_termios))
@@ -366,10 +412,7 @@ static void pl2303_set_termios(struct tty_struct *tty,
 		return;
 	}
 
-	i = usb_control_msg(serial->dev, usb_rcvctrlpipe(serial->dev, 0),
-			    GET_LINE_REQUEST, GET_LINE_REQUEST_TYPE,
-			    0, 0, buf, 7, 100);
-	dev_dbg(&port->dev, "0xa1:0x21:0:0  %d - %7ph\n", i, buf);
+	pl2303_get_line_request(port, buf);
 
 	switch (C_CSIZE(tty)) {
 	case CS5:
@@ -451,14 +494,8 @@ static void pl2303_set_termios(struct tty_struct *tty,
 	 *       only used in set_termios, which is serialised against itself.
 	 */
 	if (!old_termios || memcmp(buf, priv->line_settings, 7)) {
-		i = usb_control_msg(serial->dev,
-				    usb_sndctrlpipe(serial->dev, 0),
-				    SET_LINE_REQUEST, SET_LINE_REQUEST_TYPE,
-				    0, 0, buf, 7, 100);
-
-		dev_dbg(&port->dev, "0x21:0x20:0:0  %d\n", i);
-
-		if (i == 7)
+		ret = pl2303_set_line_request(port, buf);
+		if (!ret)
 			memcpy(priv->line_settings, buf, 7);
 	}
 
@@ -478,10 +515,7 @@ static void pl2303_set_termios(struct tty_struct *tty,
 	}
 
 	memset(buf, 0, 7);
-	i = usb_control_msg(serial->dev, usb_rcvctrlpipe(serial->dev, 0),
-			    GET_LINE_REQUEST, GET_LINE_REQUEST_TYPE,
-			    0, 0, buf, 7, 100);
-	dev_dbg(&port->dev, "0xa1:0x21:0:0  %d - %7ph\n", i, buf);
+	pl2303_get_line_request(port, buf);
 
 	if (C_CRTSCTS(tty)) {
 		if (spriv->type == HX)

commit a6ec8245bf09fd51a0561ff372a12473b48d269b
Author: Johan Hovold <jhovold@gmail.com>
Date:   Sun Dec 29 19:23:02 2013 +0100

    USB: pl2303: add error handling to set_control_lines
    
    Add error handling to set_control_lines.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 4058ceec884d..1fe8545e9926 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -269,12 +269,13 @@ static int pl2303_set_control_lines(struct usb_serial_port *port, u8 value)
 	struct usb_device *dev = port->serial->dev;
 	int retval;
 
+	dev_dbg(&port->dev, "%s - %02x\n", __func__, value);
+
 	retval = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
 				 SET_CONTROL_REQUEST, SET_CONTROL_REQUEST_TYPE,
 				 value, 0, NULL, 0, 100);
-
-	dev_dbg(&port->dev, "%s - value = %d, retval = %d\n", __func__,
-		value, retval);
+	if (retval)
+		dev_err(&port->dev, "%s - failed: %d\n", __func__, retval);
 
 	return retval;
 }

commit 362eb02603be7bb835c47f2cf585954a5080449d
Author: Johan Hovold <jhovold@gmail.com>
Date:   Sun Dec 29 19:23:01 2013 +0100

    USB: pl2303: add error handling to vendor read and write functions
    
    Add error handling and clean up vendor read and write functions.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index a44154ac335c..4058ceec884d 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -140,35 +140,46 @@ struct pl2303_private {
 	u8 line_settings[7];
 };
 
-static int pl2303_vendor_read(u16 value, u16 index,
-		struct usb_serial *serial, unsigned char *buf)
+static int pl2303_vendor_read(struct usb_serial *serial, u16 value,
+							unsigned char buf[1])
 {
+	struct device *dev = &serial->interface->dev;
 	int res;
 
 	res = usb_control_msg(serial->dev, usb_rcvctrlpipe(serial->dev, 0),
 			VENDOR_READ_REQUEST, VENDOR_READ_REQUEST_TYPE,
-			value, index, buf, 1, 100);
+			value, 0, buf, 1, 100);
+	if (res != 1) {
+		dev_err(dev, "%s - failed to read [%04x]: %d\n", __func__,
+								value, res);
+		if (res >= 0)
+			res = -EIO;
+
+		return res;
+	}
 
-	dev_dbg(&serial->interface->dev, "0x%x:0x%x:0x%x:0x%x  %d - %x\n",
-		VENDOR_READ_REQUEST_TYPE, VENDOR_READ_REQUEST, value, index,
-		res, buf[0]);
+	dev_dbg(dev, "%s - [%04x] = %02x\n", __func__, value, buf[0]);
 
-	return res;
+	return 0;
 }
 
-static int pl2303_vendor_write(u16 value, u16 index, struct usb_serial *serial)
+static int pl2303_vendor_write(struct usb_serial *serial, u16 value, u16 index)
 {
+	struct device *dev = &serial->interface->dev;
 	int res;
 
+	dev_dbg(dev, "%s - [%04x] = %02x\n", __func__, value, index);
+
 	res = usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),
 			VENDOR_WRITE_REQUEST, VENDOR_WRITE_REQUEST_TYPE,
 			value, index, NULL, 0, 100);
+	if (res) {
+		dev_err(dev, "%s - failed to write [%04x]: %d\n", __func__,
+								value, res);
+		return res;
+	}
 
-	dev_dbg(&serial->interface->dev, "0x%x:0x%x:0x%x:0x%x  %d\n",
-		VENDOR_WRITE_REQUEST_TYPE, VENDOR_WRITE_REQUEST, value, index,
-		res);
-
-	return res;
+	return 0;
 }
 
 static int pl2303_startup(struct usb_serial *serial)
@@ -181,7 +192,7 @@ static int pl2303_startup(struct usb_serial *serial)
 	if (!spriv)
 		return -ENOMEM;
 
-	buf = kmalloc(10, GFP_KERNEL);
+	buf = kmalloc(1, GFP_KERNEL);
 	if (!buf) {
 		kfree(spriv);
 		return -ENOMEM;
@@ -200,20 +211,20 @@ static int pl2303_startup(struct usb_serial *serial)
 	spriv->type = type;
 	usb_set_serial_data(serial, spriv);
 
-	pl2303_vendor_read(0x8484, 0, serial, buf);
-	pl2303_vendor_write(0x0404, 0, serial);
-	pl2303_vendor_read(0x8484, 0, serial, buf);
-	pl2303_vendor_read(0x8383, 0, serial, buf);
-	pl2303_vendor_read(0x8484, 0, serial, buf);
-	pl2303_vendor_write(0x0404, 1, serial);
-	pl2303_vendor_read(0x8484, 0, serial, buf);
-	pl2303_vendor_read(0x8383, 0, serial, buf);
-	pl2303_vendor_write(0, 1, serial);
-	pl2303_vendor_write(1, 0, serial);
+	pl2303_vendor_read(serial, 0x8484, buf);
+	pl2303_vendor_write(serial, 0x0404, 0);
+	pl2303_vendor_read(serial, 0x8484, buf);
+	pl2303_vendor_read(serial, 0x8383, buf);
+	pl2303_vendor_read(serial, 0x8484, buf);
+	pl2303_vendor_write(serial, 0x0404, 1);
+	pl2303_vendor_read(serial, 0x8484, buf);
+	pl2303_vendor_read(serial, 0x8383, buf);
+	pl2303_vendor_write(serial, 0, 1);
+	pl2303_vendor_write(serial, 1, 0);
 	if (type == HX)
-		pl2303_vendor_write(2, 0x44, serial);
+		pl2303_vendor_write(serial, 2, 0x44);
 	else
-		pl2303_vendor_write(2, 0x24, serial);
+		pl2303_vendor_write(serial, 2, 0x24);
 
 	kfree(buf);
 
@@ -473,11 +484,11 @@ static void pl2303_set_termios(struct tty_struct *tty,
 
 	if (C_CRTSCTS(tty)) {
 		if (spriv->type == HX)
-			pl2303_vendor_write(0x0, 0x61, serial);
+			pl2303_vendor_write(serial, 0x0, 0x61);
 		else
-			pl2303_vendor_write(0x0, 0x41, serial);
+			pl2303_vendor_write(serial, 0x0, 0x41);
 	} else {
-		pl2303_vendor_write(0x0, 0x0, serial);
+		pl2303_vendor_write(serial, 0x0, 0x0);
 	}
 
 	kfree(buf);
@@ -517,8 +528,8 @@ static int pl2303_open(struct tty_struct *tty, struct usb_serial_port *port)
 		usb_clear_halt(serial->dev, port->read_urb->pipe);
 	} else {
 		/* reset upstream data pipes */
-		pl2303_vendor_write(8, 0, serial);
-		pl2303_vendor_write(9, 0, serial);
+		pl2303_vendor_write(serial, 8, 0);
+		pl2303_vendor_write(serial, 9, 0);
 	}
 
 	/* Setup termios */

commit ccfe8188a321f4039a7e52c8336bb4ff3ca35139
Author: Johan Hovold <jhovold@gmail.com>
Date:   Sun Dec 29 19:23:00 2013 +0100

    USB: pl2303: clean up driver somewhat
    
    Use u16 rather than __u16.
    Fix multi-line comment style.
    Remove some comments.
    Remove unnecessary whitespace and add some where appropriate.
    Drop DRIVER_DESC define.
    Merge and simplify multi-line error message.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 6234d55372cb..a44154ac335c 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -12,7 +12,6 @@
  *
  * See Documentation/usb/usb-serial.txt for more information on using this
  * driver
- *
  */
 
 #include <linux/kernel.h>
@@ -32,11 +31,6 @@
 #include <asm/unaligned.h>
 #include "pl2303.h"
 
-/*
- * Version Information
- */
-#define DRIVER_DESC "Prolific PL2303 USB to serial adaptor driver"
-
 static const struct usb_device_id id_table[] = {
 	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID) },
 	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_RSAQ2) },
@@ -146,27 +140,34 @@ struct pl2303_private {
 	u8 line_settings[7];
 };
 
-static int pl2303_vendor_read(__u16 value, __u16 index,
+static int pl2303_vendor_read(u16 value, u16 index,
 		struct usb_serial *serial, unsigned char *buf)
 {
-	int res = usb_control_msg(serial->dev, usb_rcvctrlpipe(serial->dev, 0),
+	int res;
+
+	res = usb_control_msg(serial->dev, usb_rcvctrlpipe(serial->dev, 0),
 			VENDOR_READ_REQUEST, VENDOR_READ_REQUEST_TYPE,
 			value, index, buf, 1, 100);
+
 	dev_dbg(&serial->interface->dev, "0x%x:0x%x:0x%x:0x%x  %d - %x\n",
 		VENDOR_READ_REQUEST_TYPE, VENDOR_READ_REQUEST, value, index,
 		res, buf[0]);
+
 	return res;
 }
 
-static int pl2303_vendor_write(__u16 value, __u16 index,
-		struct usb_serial *serial)
+static int pl2303_vendor_write(u16 value, u16 index, struct usb_serial *serial)
 {
-	int res = usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),
+	int res;
+
+	res = usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),
 			VENDOR_WRITE_REQUEST, VENDOR_WRITE_REQUEST_TYPE,
 			value, index, NULL, 0, 100);
+
 	dev_dbg(&serial->interface->dev, "0x%x:0x%x:0x%x:0x%x  %d\n",
 		VENDOR_WRITE_REQUEST_TYPE, VENDOR_WRITE_REQUEST, value, index,
 		res);
+
 	return res;
 }
 
@@ -215,14 +216,14 @@ static int pl2303_startup(struct usb_serial *serial)
 		pl2303_vendor_write(2, 0x24, serial);
 
 	kfree(buf);
+
 	return 0;
 }
 
 static void pl2303_release(struct usb_serial *serial)
 {
-	struct pl2303_serial_private *spriv;
+	struct pl2303_serial_private *spriv = usb_get_serial_data(serial);
 
-	spriv = usb_get_serial_data(serial);
 	kfree(spriv);
 }
 
@@ -245,9 +246,8 @@ static int pl2303_port_probe(struct usb_serial_port *port)
 
 static int pl2303_port_remove(struct usb_serial_port *port)
 {
-	struct pl2303_private *priv;
+	struct pl2303_private *priv = usb_get_serial_port_data(port);
 
-	priv = usb_get_serial_port_data(port);
 	kfree(priv);
 
 	return 0;
@@ -261,8 +261,10 @@ static int pl2303_set_control_lines(struct usb_serial_port *port, u8 value)
 	retval = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
 				 SET_CONTROL_REQUEST, SET_CONTROL_REQUEST_TYPE,
 				 value, 0, NULL, 0, 100);
+
 	dev_dbg(&port->dev, "%s - value = %d, retval = %d\n", __func__,
 		value, retval);
+
 	return retval;
 }
 
@@ -488,13 +490,13 @@ static void pl2303_dtr_rts(struct usb_serial_port *port, int on)
 	u8 control;
 
 	spin_lock_irqsave(&priv->lock, flags);
-	/* Change DTR and RTS */
 	if (on)
 		priv->line_control |= (CONTROL_DTR | CONTROL_RTS);
 	else
 		priv->line_control &= ~(CONTROL_DTR | CONTROL_RTS);
 	control = priv->line_control;
 	spin_unlock_irqrestore(&priv->lock, flags);
+
 	pl2303_set_control_lines(port, control);
 }
 
@@ -525,8 +527,8 @@ static int pl2303_open(struct tty_struct *tty, struct usb_serial_port *port)
 
 	result = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);
 	if (result) {
-		dev_err(&port->dev, "%s - failed submitting interrupt urb,"
-			" error %d\n", __func__, result);
+		dev_err(&port->dev, "failed to submit interrupt urb: %d\n",
+			result);
 		return result;
 	}
 
@@ -596,8 +598,10 @@ static int pl2303_tiocmget(struct tty_struct *tty)
 static int pl2303_carrier_raised(struct usb_serial_port *port)
 {
 	struct pl2303_private *priv = usb_get_serial_port_data(port);
+
 	if (priv->line_status & UART_DCD)
 		return 1;
+
 	return 0;
 }
 
@@ -662,6 +666,7 @@ static int pl2303_ioctl(struct tty_struct *tty,
 	default:
 		break;
 	}
+
 	return -ENOIOCTLCMD;
 }
 
@@ -676,6 +681,7 @@ static void pl2303_break_ctl(struct tty_struct *tty, int break_state)
 		state = BREAK_OFF;
 	else
 		state = BREAK_ON;
+
 	dev_dbg(&port->dev, "%s - turning break %s\n", __func__,
 			state == BREAK_OFF ? "off" : "on");
 
@@ -690,7 +696,6 @@ static void pl2303_update_line_status(struct usb_serial_port *port,
 				      unsigned char *data,
 				      unsigned int actual_length)
 {
-
 	struct pl2303_private *priv = usb_get_serial_port_data(port);
 	struct tty_struct *tty;
 	unsigned long flags;
@@ -702,12 +707,10 @@ static void pl2303_update_line_status(struct usb_serial_port *port,
 	idv = le16_to_cpu(port->serial->dev->descriptor.idVendor);
 	idp = le16_to_cpu(port->serial->dev->descriptor.idProduct);
 
-
 	if (idv == SIEMENS_VENDOR_ID) {
 		if (idp == SIEMENS_PRODUCT_ID_X65 ||
 		    idp == SIEMENS_PRODUCT_ID_SX1 ||
 		    idp == SIEMENS_PRODUCT_ID_X75) {
-
 			length = 1;
 			status_idx = 0;
 		}
@@ -721,8 +724,10 @@ static void pl2303_update_line_status(struct usb_serial_port *port,
 	prev_line_status = priv->line_status;
 	priv->line_status = data[status_idx];
 	spin_unlock_irqrestore(&priv->lock, flags);
+
 	if (priv->line_status & UART_BREAK_ERROR)
 		usb_serial_handle_break(port);
+
 	wake_up_interruptible(&port->port.delta_msr_wait);
 
 	tty = tty_port_tty_get(&port->port);
@@ -766,10 +771,11 @@ static void pl2303_read_int_callback(struct urb *urb)
 
 exit:
 	retval = usb_submit_urb(urb, GFP_ATOMIC);
-	if (retval)
+	if (retval) {
 		dev_err(&port->dev,
 			"%s - usb_submit_urb failed with result %d\n",
 			__func__, retval);
+	}
 }
 
 static void pl2303_process_read_urb(struct urb *urb)
@@ -791,8 +797,10 @@ static void pl2303_process_read_urb(struct urb *urb)
 	if (!urb->actual_length)
 		return;
 
-	/* break takes precedence over parity, */
-	/* which takes precedence over framing errors */
+	/*
+	 * Break takes precedence over parity, which takes precedence over
+	 * framing errors.
+	 */
 	if (line_status & UART_BREAK_ERROR)
 		tty_flag = TTY_BREAK;
 	else if (line_status & UART_PARITY_ERROR)
@@ -820,7 +828,6 @@ static void pl2303_process_read_urb(struct urb *urb)
 	tty_flip_buffer_push(&port->port);
 }
 
-/* All of the device info needed for the PL2303 SIO serial converter */
 static struct usb_serial_driver pl2303_device = {
 	.driver = {
 		.owner =	THIS_MODULE,
@@ -832,7 +839,7 @@ static struct usb_serial_driver pl2303_device = {
 	.bulk_out_size =	256,
 	.open =			pl2303_open,
 	.close =		pl2303_close,
-	.dtr_rts = 		pl2303_dtr_rts,
+	.dtr_rts =		pl2303_dtr_rts,
 	.carrier_raised =	pl2303_carrier_raised,
 	.ioctl =		pl2303_ioctl,
 	.break_ctl =		pl2303_break_ctl,
@@ -854,5 +861,5 @@ static struct usb_serial_driver * const serial_drivers[] = {
 
 module_usb_serial_driver(serial_drivers, id_table);
 
-MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_DESCRIPTION("Prolific PL2303 USB to serial adaptor driver");
 MODULE_LICENSE("GPL");

commit 71c671bf4cead0e801eccbed3fe790e817f6b6d4
Author: Johan Hovold <jhovold@gmail.com>
Date:   Sun Dec 29 19:22:59 2013 +0100

    USB: pl2303: remove bogus delta_msr_wait wake up
    
    Remove bogus MSR wait-queue wake up from process_read_urb which never
    updates the MSR flags.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 3dd5398174c1..6234d55372cb 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -787,7 +787,6 @@ static void pl2303_process_read_urb(struct urb *urb)
 	line_status = priv->line_status;
 	priv->line_status &= ~UART_STATE_TRANSIENT_MASK;
 	spin_unlock_irqrestore(&priv->lock, flags);
-	wake_up_interruptible(&port->port.delta_msr_wait);
 
 	if (!urb->actual_length)
 		return;

commit 10c642d0772ac1391ae4f9fdeb13217ab019117a
Author: Johan Hovold <jhovold@gmail.com>
Date:   Sun Dec 29 19:22:56 2013 +0100

    USB: serial: remove redundant OOM messages
    
    Remove redundant error messages on allocation failures, which have
    already been logged.
    
    Cc: Joe Perches <joe@perches.com>
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 9a7dfa3738d9..3dd5398174c1 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -346,7 +346,6 @@ static void pl2303_set_termios(struct tty_struct *tty,
 
 	buf = kzalloc(7, GFP_KERNEL);
 	if (!buf) {
-		dev_err(&port->dev, "%s - out of memory.\n", __func__);
 		/* Report back no change occurred */
 		if (old_termios)
 			tty->termios = *old_termios;

commit 4d5147ec90531d11e7677e2c38941fc18e160641
Author: Johan Hovold <jhovold@gmail.com>
Date:   Sun Dec 29 19:22:55 2013 +0100

    USB: serial: clean up ioctl debugging
    
    Remove redundant ioctl debugging from subdrivers. The ioctl request code
    has already been logged by usb-serial core.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index beb8edce4ef2..9a7dfa3738d9 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -648,8 +648,6 @@ static int pl2303_ioctl(struct tty_struct *tty,
 	struct serial_struct ser;
 	struct usb_serial_port *port = tty->driver_data;
 
-	dev_dbg(&port->dev, "%s cmd = 0x%04x\n", __func__, cmd);
-
 	switch (cmd) {
 	case TIOCGSERIAL:
 		memset(&ser, 0, sizeof ser);
@@ -663,7 +661,6 @@ static int pl2303_ioctl(struct tty_struct *tty,
 
 		return 0;
 	default:
-		dev_dbg(&port->dev, "%s not supported = 0x%04x\n", __func__, cmd);
 		break;
 	}
 	return -ENOIOCTLCMD;

commit 623c8263376c0b8a4b0c220232e7313d762cd0cc
Author: Johan Hovold <jhovold@gmail.com>
Date:   Sun Dec 29 19:22:53 2013 +0100

    USB: pl2303: fix data corruption on termios updates
    
    Some PL2303 devices are known to lose bytes if you change serial
    settings even to the same values as before. Avoid this by comparing the
    encoded settings with the previsouly used ones before configuring the
    device.
    
    The common case was fixed by commit bf5e5834bffc6 ("pl2303: Fix mode
    switching regression"), but this problem was still possible to trigger,
    for instance, by using the TCSETS2-interface to repeatedly request
    115201 baud, which gets mapped to 115200 and thus always triggers a
    settings update.
    
    Cc: Frank Schäfer <fschaefer.oss@googlemail.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 1e3318dfa1cb..beb8edce4ef2 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -142,6 +142,8 @@ struct pl2303_private {
 	spinlock_t lock;
 	u8 line_control;
 	u8 line_status;
+
+	u8 line_settings[7];
 };
 
 static int pl2303_vendor_read(__u16 value, __u16 index,
@@ -339,11 +341,6 @@ static void pl2303_set_termios(struct tty_struct *tty,
 	int i;
 	u8 control;
 
-	/*
-	 * The PL2303 is reported to lose bytes if you change serial settings
-	 * even to the same values as before. Thus we actually need to filter
-	 * in this specific case.
-	 */
 	if (old_termios && !tty_termios_hw_change(&tty->termios, old_termios))
 		return;
 
@@ -428,10 +425,29 @@ static void pl2303_set_termios(struct tty_struct *tty,
 		dev_dbg(&port->dev, "parity = none\n");
 	}
 
-	i = usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),
-			    SET_LINE_REQUEST, SET_LINE_REQUEST_TYPE,
-			    0, 0, buf, 7, 100);
-	dev_dbg(&port->dev, "0x21:0x20:0:0  %d\n", i);
+	/*
+	 * Some PL2303 are known to lose bytes if you change serial settings
+	 * even to the same values as before. Thus we actually need to filter
+	 * in this specific case.
+	 *
+	 * Note that the tty_termios_hw_change check above is not sufficient
+	 * as a previously requested baud rate may differ from the one
+	 * actually used (and stored in old_termios).
+	 *
+	 * NOTE: No additional locking needed for line_settings as it is
+	 *       only used in set_termios, which is serialised against itself.
+	 */
+	if (!old_termios || memcmp(buf, priv->line_settings, 7)) {
+		i = usb_control_msg(serial->dev,
+				    usb_sndctrlpipe(serial->dev, 0),
+				    SET_LINE_REQUEST, SET_LINE_REQUEST_TYPE,
+				    0, 0, buf, 7, 100);
+
+		dev_dbg(&port->dev, "0x21:0x20:0:0  %d\n", i);
+
+		if (i == 7)
+			memcpy(priv->line_settings, buf, 7);
+	}
 
 	/* change control lines if we are switching to or from B0 */
 	spin_lock_irqsave(&priv->lock, flags);

commit a313249937820f8b1996133fc285efbd6aad2c5b
Author: Colin Leitner <colin.leitner@googlemail.com>
Date:   Mon Nov 4 19:40:43 2013 +0100

    USB: pl2303: fixed handling of CS5 setting
    
    This patch fixes the CS5 setting on the PL2303 USB-to-serial devices. CS5 has a
    value of 0 and the CSIZE setting has been skipped altogether by the enclosing
    if. Tested on 3.11.6 and the scope shows the correct output after the fix has
    been applied.
    
    Tagged to be added to stable, because it fixes a user visible driver bug and is
    simple enough to backport easily.
    
    Signed-off-by: Colin Leitner <colin.leitner@gmail.com>
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 1e6de4cd079d..1e3318dfa1cb 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -361,23 +361,21 @@ static void pl2303_set_termios(struct tty_struct *tty,
 			    0, 0, buf, 7, 100);
 	dev_dbg(&port->dev, "0xa1:0x21:0:0  %d - %7ph\n", i, buf);
 
-	if (C_CSIZE(tty)) {
-		switch (C_CSIZE(tty)) {
-		case CS5:
-			buf[6] = 5;
-			break;
-		case CS6:
-			buf[6] = 6;
-			break;
-		case CS7:
-			buf[6] = 7;
-			break;
-		default:
-		case CS8:
-			buf[6] = 8;
-		}
-		dev_dbg(&port->dev, "data bits = %d\n", buf[6]);
+	switch (C_CSIZE(tty)) {
+	case CS5:
+		buf[6] = 5;
+		break;
+	case CS6:
+		buf[6] = 6;
+		break;
+	case CS7:
+		buf[6] = 7;
+		break;
+	default:
+	case CS8:
+		buf[6] = 8;
 	}
+	dev_dbg(&port->dev, "data bits = %d\n", buf[6]);
 
 	/* For reference buf[0]:buf[3] baud rate value */
 	pl2303_encode_baudrate(tty, port, &buf[0]);

commit 54dc5792ea933a3ff8c62a1f9ea9e4e6cbdd324a
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Nov 1 09:19:56 2013 -0700

    Revert "USB: pl2303: restrict the divisor based baud rate encoding method to the "HX" chip type"
    
    This reverts commit b8bdad608213caffa081a97d2e937e5fe08c4046.
    
    Revert all of the pl2303 changes that went into 3.12-rc1 and -rc2 as
    they cause regressions on some versions of the chip.  This will all be
    revisited for later kernel versions when we can figure out how to handle
    this in a way that does not break working devices.
    
    Reported-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Cc: Frank Schäfer <fschaefer.oss@googlemail.com>
    Acked-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 244820193e10..1e6de4cd079d 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -305,14 +305,10 @@ static void pl2303_encode_baudrate(struct tty_struct *tty,
 	if (spriv->type != HX)
 		baud = min_t(int, baud, 1228800);
 
-	if (spriv->type != HX || baud <= 115200) {
-		/* Direct (standard) baud rate encoding method */
+	if (baud <= 115200) {
 		put_unaligned_le32(baud, buf);
 	} else {
 		/*
-		 * NOTE: it's not clear if the type_0/1 chips
-		 * support this method
-		 *
 		 * Apparently the formula for higher speeds is:
 		 * baudrate = 12M * 32 / (2^buf[1]) / buf[0]
 		 */

commit 1796a228762cd0b86e14d6d4a3de9ecfe65b3b8d
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Nov 1 09:19:45 2013 -0700

    Revert "usb: pl2303: fix+improve the divsor based baud rate encoding method"
    
    This reverts commit 57ce61aad748ceaa08c859da04043ad7dae7c15e.
    
    Revert all of the pl2303 changes that went into 3.12-rc1 and -rc2 as
    they cause regressions on some versions of the chip.  This will all be
    revisited for later kernel versions when we can figure out how to handle
    this in a way that does not break working devices.
    
    Reported-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Cc: Frank Schäfer <fschaefer.oss@googlemail.com>
    Acked-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index b93b3b30dec5..244820193e10 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -4,11 +4,6 @@
  * Copyright (C) 2001-2007 Greg Kroah-Hartman (greg@kroah.com)
  * Copyright (C) 2003 IBM Corp.
  *
- * Copyright (C) 2009, 2013 Frank Schäfer <fschaefer.oss@googlemail.com>
- *  - fixes, improvements and documentation for the baud rate encoding methods
- * Copyright (C) 2013 Reinhard Max <max@suse.de>
- *  - fixes and improvements for the divisor based baud rate encoding method
- *
  * Original driver for 2.2.x by anonymous
  *
  *	This program is free software; you can redistribute it and/or
@@ -315,58 +310,21 @@ static void pl2303_encode_baudrate(struct tty_struct *tty,
 		put_unaligned_le32(baud, buf);
 	} else {
 		/*
-		 * Divisor based baud rate encoding method
-		 *
 		 * NOTE: it's not clear if the type_0/1 chips
 		 * support this method
 		 *
-		 * divisor = 12MHz * 32 / baudrate = 2^A * B
-		 *
-		 * with
-		 *
-		 * A = buf[1] & 0x0e
-		 * B = buf[0]  +  (buf[1] & 0x01) << 8
-		 *
-		 * Special cases:
-		 * => 8 < B < 16: device seems to work not properly
-		 * => B <= 8: device uses the max. value B = 512 instead
+		 * Apparently the formula for higher speeds is:
+		 * baudrate = 12M * 32 / (2^buf[1]) / buf[0]
 		 */
-
-		/* Determine factors A and B */
-		unsigned int A = 0;
-		unsigned int B = 12000000 * 32 / baud;  /* 12MHz */
-		B <<= 1; /* Add one bit for rounding */
-		while (B > (512 << 1) && A <= 14) {
-			A += 2;
-			B >>= 2;
-		}
-		if (A > 14) { /* max. divisor = min. baudrate reached */
-			A = 14;
-			B = 512;
-			/* => ~45.78 baud */
-		} else {
-			B = (B + 1) >> 1; /* Round the last bit */
-		}
-		/* Handle special cases */
-		if (B == 512)
-			B = 0; /* also: 1 to 8 */
-		else if (B < 16)
-			/*
-			 * NOTE: With the current algorithm this happens
-			 * only for A=0 and means that the min. divisor
-			 * (respectively: the max. baudrate) is reached.
-			 */
-			B = 16;		/* => 24 MBaud */
-		/* Encode the baud rate */
-		buf[3] = 0x80;     /* Select divisor encoding method */
+		unsigned tmp = 12000000 * 32 / baud;
+		buf[3] = 0x80;
 		buf[2] = 0;
-		buf[1] = (A & 0x0e);		/* A */
-		buf[1] |= ((B & 0x100) >> 8);	/* MSB of B */
-		buf[0] = B & 0xff;		/* 8 LSBs of B */
-		/* Calculate the actual/resulting baud rate */
-		if (B <= 8)
-			B = 512;
-		baud = 12000000 * 32 / ((1 << A) * B);
+		buf[1] = (tmp >= 256);
+		while (tmp >= 256) {
+			tmp >>= 2;
+			buf[1] <<= 1;
+		}
+		buf[0] = tmp;
 	}
 
 	/* Save resulting baud rate */

commit 7e12a6fcbf266eb0d5b19761f91b2964ad18e371
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Nov 1 09:19:34 2013 -0700

    Revert "usb: pl2303: do not round to the next nearest standard baud rate for the divisor based baud rate encoding method"
    
    This reverts commit 75417d9f99f89ab241de69d7db15af5842b488c4.
    
    Revert all of the pl2303 changes that went into 3.12-rc1 and -rc2 as
    they cause regressions on some versions of the chip.  This will all be
    revisited for later kernel versions when we can figure out how to handle
    this in a way that does not break working devices.
    
    Reported-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Cc: Frank Schäfer <fschaefer.oss@googlemail.com>
    Acked-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 04390dff926a..b93b3b30dec5 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -273,46 +273,44 @@ static void pl2303_encode_baudrate(struct tty_struct *tty,
 					struct usb_serial_port *port,
 					u8 buf[4])
 {
+	const int baud_sup[] = { 75, 150, 300, 600, 1200, 1800, 2400, 3600,
+	                         4800, 7200, 9600, 14400, 19200, 28800, 38400,
+	                         57600, 115200, 230400, 460800, 500000, 614400,
+	                         921600, 1228800, 2457600, 3000000, 6000000 };
+
 	struct usb_serial *serial = port->serial;
 	struct pl2303_serial_private *spriv = usb_get_serial_data(serial);
 	int baud;
+	int i;
 
+	/*
+	 * NOTE: Only the values defined in baud_sup are supported!
+	 *       => if unsupported values are set, the PL2303 seems to use
+	 *          9600 baud (at least my PL2303X always does)
+	 */
 	baud = tty_get_baud_rate(tty);
 	dev_dbg(&port->dev, "baud requested = %d\n", baud);
 	if (!baud)
 		return;
 
-	if (spriv->type != HX || baud <= 115200) {
-		/*
-		 * NOTE: Only the values defined in baud_sup are supported !
-		 *       => if unsupported values are set, the PL2303 seems to
-		 *	    use 9600 baud (at least my PL2303X always does)
-		 */
-		const int baud_sup[] = { 75, 150, 300, 600, 1200, 1800, 2400,
-					 3600, 4800, 7200, 9600, 14400, 19200,
-					 28800, 38400, 57600, 115200, 230400,
-					 460800, 500000, 614400, 921600,
-					 1228800, 2457600, 3000000, 6000000 };
-		int i;
-
-		/* Set baudrate to nearest supported value */
-		for (i = 0; i < ARRAY_SIZE(baud_sup); ++i) {
-			if (baud_sup[i] > baud)
-				break;
-		}
+	/* Set baudrate to nearest supported value */
+	for (i = 0; i < ARRAY_SIZE(baud_sup); ++i) {
+		if (baud_sup[i] > baud)
+			break;
+	}
 
-		if (i == ARRAY_SIZE(baud_sup))
-			baud = baud_sup[i - 1];
-		else if (i > 0
-			     && (baud_sup[i] - baud) > (baud - baud_sup[i - 1]))
-			baud = baud_sup[i - 1];
-		else
-			baud = baud_sup[i];
+	if (i == ARRAY_SIZE(baud_sup))
+		baud = baud_sup[i - 1];
+	else if (i > 0 && (baud_sup[i] - baud) > (baud - baud_sup[i - 1]))
+		baud = baud_sup[i - 1];
+	else
+		baud = baud_sup[i];
 
-		/* type_0, type_1 only support up to 1228800 baud */
-		if (spriv->type != HX)
-			baud = min_t(int, baud, 1228800);
+	/* type_0, type_1 only support up to 1228800 baud */
+	if (spriv->type != HX)
+		baud = min_t(int, baud, 1228800);
 
+	if (spriv->type != HX || baud <= 115200) {
 		/* Direct (standard) baud rate encoding method */
 		put_unaligned_le32(baud, buf);
 	} else {
@@ -333,17 +331,10 @@ static void pl2303_encode_baudrate(struct tty_struct *tty,
 		 * => 8 < B < 16: device seems to work not properly
 		 * => B <= 8: device uses the max. value B = 512 instead
 		 */
-		unsigned int A, B;
 
-		/* Respect the specified baud rate limits */
-		baud = max_t(int, baud, 75);
-		if (spriv->type == HX)
-			baud = min_t(int, baud, 6000000);
-		else
-			baud = min_t(int, baud, 1228800);
 		/* Determine factors A and B */
-		A = 0;
-		B = 12000000 * 32 / baud;  /* 12MHz */
+		unsigned int A = 0;
+		unsigned int B = 12000000 * 32 / baud;  /* 12MHz */
 		B <<= 1; /* Add one bit for rounding */
 		while (B > (512 << 1) && A <= 14) {
 			A += 2;

commit 336b9daf90d2a1575088ab93d7bfe82dcd10dd8d
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Nov 1 09:19:24 2013 -0700

    Revert "usb: pl2303: remove 500000 baud from the list of standard baud rates"
    
    This reverts commit b9208c721ce736125fe58d398319513a27850fd8.
    
    Revert all of the pl2303 changes that went into 3.12-rc1 and -rc2 as
    they cause regressions on some versions of the chip.  This will all be
    revisited for later kernel versions when we can figure out how to handle
    this in a way that does not break working devices.
    
    Reported-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Cc: Frank Schäfer <fschaefer.oss@googlemail.com>
    Acked-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index a0ea92ed35c6..04390dff926a 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -291,8 +291,8 @@ static void pl2303_encode_baudrate(struct tty_struct *tty,
 		const int baud_sup[] = { 75, 150, 300, 600, 1200, 1800, 2400,
 					 3600, 4800, 7200, 9600, 14400, 19200,
 					 28800, 38400, 57600, 115200, 230400,
-					 460800, 614400, 921600, 1228800,
-					 2457600, 3000000, 6000000 };
+					 460800, 500000, 614400, 921600,
+					 1228800, 2457600, 3000000, 6000000 };
 		int i;
 
 		/* Set baudrate to nearest supported value */

commit 692ed4ddf0010dd643d38d6ef1a15bf64a7fbc6d
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Nov 1 09:19:03 2013 -0700

    Revert "usb: pl2303: move the two baud rate encoding methods to separate functions"
    
    This reverts commit e917ba01d69ad705a4cd6a6c77538f55d84f5907.
    
    Revert all of the pl2303 changes that went into 3.12-rc1 and -rc2 as
    they cause regressions on some versions of the chip.  This will all be
    revisited for later kernel versions when we can figure out how to handle
    this in a way that does not break working devices.
    
    Reported-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Cc: Frank Schäfer <fschaefer.oss@googlemail.com>
    Acked-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 693ed7e4871a..a0ea92ed35c6 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -269,128 +269,115 @@ static int pl2303_set_control_lines(struct usb_serial_port *port, u8 value)
 	return retval;
 }
 
-static int pl2303_baudrate_encode_direct(int baud, enum pl2303_type type,
-								      u8 buf[4])
-{
-	/*
-	 * NOTE: Only the values defined in baud_sup are supported !
-	 *       => if unsupported values are set, the PL2303 seems to
-	 *	    use 9600 baud (at least my PL2303X always does)
-	 */
-	const int baud_sup[] = { 75, 150, 300, 600, 1200, 1800, 2400, 3600,
-				 4800, 7200, 9600, 14400, 19200, 28800, 38400,
-				 57600, 115200, 230400, 460800, 614400, 921600,
-				 1228800, 2457600, 3000000, 6000000 };
-	int i;
-
-	/* Set baudrate to nearest supported value */
-	for (i = 0; i < ARRAY_SIZE(baud_sup); ++i) {
-		if (baud_sup[i] > baud)
-			break;
-	}
-	if (i == ARRAY_SIZE(baud_sup))
-		baud = baud_sup[i - 1];
-	else if (i > 0 && (baud_sup[i] - baud) > (baud - baud_sup[i - 1]))
-		baud = baud_sup[i - 1];
-	else
-		baud = baud_sup[i];
-	/* type_0, type_1 only support up to 1228800 baud */
-	if (type != HX)
-		baud = min_t(int, baud, 1228800);
-	/* Direct (standard) baud rate encoding method */
-	put_unaligned_le32(baud, buf);
-
-	return baud;
-}
-
-static int pl2303_baudrate_encode_divisor(int baud, enum pl2303_type type,
-								      u8 buf[4])
-{
-	/*
-	 * Divisor based baud rate encoding method
-	 *
-	 * NOTE: it's not clear if the type_0/1 chips support this method
-	 *
-	 * divisor = 12MHz * 32 / baudrate = 2^A * B
-	 *
-	 * with
-	 *
-	 * A = buf[1] & 0x0e
-	 * B = buf[0]  +  (buf[1] & 0x01) << 8
-	 *
-	 * Special cases:
-	 * => 8 < B < 16: device seems to work not properly
-	 * => B <= 8: device uses the max. value B = 512 instead
-	 */
-	unsigned int A, B;
-
-	/* Respect the specified baud rate limits */
-	baud = max_t(int, baud, 75);
-	if (type == HX)
-		baud = min_t(int, baud, 6000000);
-	else
-		baud = min_t(int, baud, 1228800);
-	/* Determine factors A and B */
-	A = 0;
-	B = 12000000 * 32 / baud;  /* 12MHz */
-	B <<= 1; /* Add one bit for rounding */
-	while (B > (512 << 1) && A <= 14) {
-		A += 2;
-		B >>= 2;
-	}
-	if (A > 14) { /* max. divisor = min. baudrate reached */
-		A = 14;
-		B = 512;
-		/* => ~45.78 baud */
-	} else {
-		B = (B + 1) >> 1; /* Round the last bit */
-	}
-	/* Handle special cases */
-	if (B == 512)
-		B = 0; /* also: 1 to 8 */
-	else if (B < 16)
-		/*
-		 * NOTE: With the current algorithm this happens
-		 * only for A=0 and means that the min. divisor
-		 * (respectively: the max. baudrate) is reached.
-		 */
-		B = 16;		/* => 24 MBaud */
-	/* Encode the baud rate */
-	buf[3] = 0x80;     /* Select divisor encoding method */
-	buf[2] = 0;
-	buf[1] = (A & 0x0e);		/* A */
-	buf[1] |= ((B & 0x100) >> 8);	/* MSB of B */
-	buf[0] = B & 0xff;		/* 8 LSBs of B */
-	/* Calculate the actual/resulting baud rate */
-	if (B <= 8)
-		B = 512;
-	baud = 12000000 * 32 / ((1 << A) * B);
-
-	return baud;
-}
-
 static void pl2303_encode_baudrate(struct tty_struct *tty,
 					struct usb_serial_port *port,
-					enum pl2303_type type,
 					u8 buf[4])
 {
+	struct usb_serial *serial = port->serial;
+	struct pl2303_serial_private *spriv = usb_get_serial_data(serial);
 	int baud;
 
 	baud = tty_get_baud_rate(tty);
 	dev_dbg(&port->dev, "baud requested = %d\n", baud);
 	if (!baud)
 		return;
-	/*
-	 * There are two methods for setting/encoding the baud rate
-	 * 1) Direct method: encodes the baud rate value directly
-	 *    => supported by all chip types
-	 * 2) Divisor based method: encodes a divisor to a base value (12MHz*32)
-	 *    => supported by HX chips (and likely not by type_0/1 chips)
-	 */
-	if (type != HX || baud <= 115200)
-		baud = pl2303_baudrate_encode_direct(baud, type, buf);
-	else
-		baud = pl2303_baudrate_encode_divisor(baud, type, buf);
+
+	if (spriv->type != HX || baud <= 115200) {
+		/*
+		 * NOTE: Only the values defined in baud_sup are supported !
+		 *       => if unsupported values are set, the PL2303 seems to
+		 *	    use 9600 baud (at least my PL2303X always does)
+		 */
+		const int baud_sup[] = { 75, 150, 300, 600, 1200, 1800, 2400,
+					 3600, 4800, 7200, 9600, 14400, 19200,
+					 28800, 38400, 57600, 115200, 230400,
+					 460800, 614400, 921600, 1228800,
+					 2457600, 3000000, 6000000 };
+		int i;
+
+		/* Set baudrate to nearest supported value */
+		for (i = 0; i < ARRAY_SIZE(baud_sup); ++i) {
+			if (baud_sup[i] > baud)
+				break;
+		}
+
+		if (i == ARRAY_SIZE(baud_sup))
+			baud = baud_sup[i - 1];
+		else if (i > 0
+			     && (baud_sup[i] - baud) > (baud - baud_sup[i - 1]))
+			baud = baud_sup[i - 1];
+		else
+			baud = baud_sup[i];
+
+		/* type_0, type_1 only support up to 1228800 baud */
+		if (spriv->type != HX)
+			baud = min_t(int, baud, 1228800);
+
+		/* Direct (standard) baud rate encoding method */
+		put_unaligned_le32(baud, buf);
+	} else {
+		/*
+		 * Divisor based baud rate encoding method
+		 *
+		 * NOTE: it's not clear if the type_0/1 chips
+		 * support this method
+		 *
+		 * divisor = 12MHz * 32 / baudrate = 2^A * B
+		 *
+		 * with
+		 *
+		 * A = buf[1] & 0x0e
+		 * B = buf[0]  +  (buf[1] & 0x01) << 8
+		 *
+		 * Special cases:
+		 * => 8 < B < 16: device seems to work not properly
+		 * => B <= 8: device uses the max. value B = 512 instead
+		 */
+		unsigned int A, B;
+
+		/* Respect the specified baud rate limits */
+		baud = max_t(int, baud, 75);
+		if (spriv->type == HX)
+			baud = min_t(int, baud, 6000000);
+		else
+			baud = min_t(int, baud, 1228800);
+		/* Determine factors A and B */
+		A = 0;
+		B = 12000000 * 32 / baud;  /* 12MHz */
+		B <<= 1; /* Add one bit for rounding */
+		while (B > (512 << 1) && A <= 14) {
+			A += 2;
+			B >>= 2;
+		}
+		if (A > 14) { /* max. divisor = min. baudrate reached */
+			A = 14;
+			B = 512;
+			/* => ~45.78 baud */
+		} else {
+			B = (B + 1) >> 1; /* Round the last bit */
+		}
+		/* Handle special cases */
+		if (B == 512)
+			B = 0; /* also: 1 to 8 */
+		else if (B < 16)
+			/*
+			 * NOTE: With the current algorithm this happens
+			 * only for A=0 and means that the min. divisor
+			 * (respectively: the max. baudrate) is reached.
+			 */
+			B = 16;		/* => 24 MBaud */
+		/* Encode the baud rate */
+		buf[3] = 0x80;     /* Select divisor encoding method */
+		buf[2] = 0;
+		buf[1] = (A & 0x0e);		/* A */
+		buf[1] |= ((B & 0x100) >> 8);	/* MSB of B */
+		buf[0] = B & 0xff;		/* 8 LSBs of B */
+		/* Calculate the actual/resulting baud rate */
+		if (B <= 8)
+			B = 512;
+		baud = 12000000 * 32 / ((1 << A) * B);
+	}
+
 	/* Save resulting baud rate */
 	tty_encode_baud_rate(tty, baud, baud);
 	dev_dbg(&port->dev, "baud set = %d\n", baud);
@@ -447,8 +434,8 @@ static void pl2303_set_termios(struct tty_struct *tty,
 		dev_dbg(&port->dev, "data bits = %d\n", buf[6]);
 	}
 
-	/* For reference:   buf[0]:buf[3] baud rate value */
-	pl2303_encode_baudrate(tty, port, spriv->type, buf);
+	/* For reference buf[0]:buf[3] baud rate value */
+	pl2303_encode_baudrate(tty, port, &buf[0]);
 
 	/* For reference buf[4]=0 is 1 stop bits */
 	/* For reference buf[4]=1 is 1.5 stop bits */

commit 92dfe410880b8bde731ca1a6e7da2dd3b13404e6
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Nov 1 09:18:47 2013 -0700

    Revert "usb: pl2303: increase the allowed baud rate range for the divisor based encoding method"
    
    This reverts commit b5c16c6a031c52cc4b7dda6c3de46462fbc92eab.
    
    Revert all of the pl2303 changes that went into 3.12-rc1 and -rc2 as
    they cause regressions on some versions of the chip.  This will all be
    revisited for later kernel versions when we can figure out how to handle
    this in a way that does not break working devices.
    
    Reported-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Cc: Frank Schäfer <fschaefer.oss@googlemail.com>
    Acked-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 61c9f9d28ee9..693ed7e4871a 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -324,20 +324,12 @@ static int pl2303_baudrate_encode_divisor(int baud, enum pl2303_type type,
 	 */
 	unsigned int A, B;
 
-	/*
-	 * NOTE: The Windows driver allows maximum baud rates of 110% of the
-	 * specified maximium value.
-	 * Quick tests with early (2004) HX (rev. A) chips suggest, that even
-	 * higher baud rates (up to the maximum of 24M baud !) are working fine,
-	 * but that should really be tested carefully in "real life" scenarios
-	 * before removing the upper limit completely.
-	 * Baud rates smaller than the specified 75 baud are definitely working
-	 * fine.
-	 */
+	/* Respect the specified baud rate limits */
+	baud = max_t(int, baud, 75);
 	if (type == HX)
-		baud = min_t(int, baud, 6000000 * 1.1);
+		baud = min_t(int, baud, 6000000);
 	else
-		baud = min_t(int, baud, 1228800 * 1.1);
+		baud = min_t(int, baud, 1228800);
 	/* Determine factors A and B */
 	A = 0;
 	B = 12000000 * 32 / baud;  /* 12MHz */

commit e2afb1d66644a3c55e3a46ba312e302a065ecac5
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Nov 1 09:18:38 2013 -0700

    Revert "usb: pl2303: also use the divisor based baud rate encoding method for baud rates < 115200 with HX chips"
    
    This reverts commit 61fa8d694b8547894b57ea0d99d0120a58f6ebf8.
    
    Revert all of the pl2303 changes that went into 3.12-rc1 and -rc2 as
    they cause regressions on some versions of the chip.  This will all be
    revisited for later kernel versions when we can figure out how to handle
    this in a way that does not break working devices.
    
    Reported-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Cc: Frank Schäfer <fschaefer.oss@googlemail.com>
    Acked-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 09fb55cf3be7..61c9f9d28ee9 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -395,7 +395,7 @@ static void pl2303_encode_baudrate(struct tty_struct *tty,
 	 * 2) Divisor based method: encodes a divisor to a base value (12MHz*32)
 	 *    => supported by HX chips (and likely not by type_0/1 chips)
 	 */
-	if (type != HX)
+	if (type != HX || baud <= 115200)
 		baud = pl2303_baudrate_encode_direct(baud, type, buf);
 	else
 		baud = pl2303_baudrate_encode_divisor(baud, type, buf);

commit 233c3dda5cd1bb26fa871b94db17627117e51026
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Nov 1 09:18:25 2013 -0700

    Revert "usb: pl2303: add two comments concerning the supported baud rates with HX chips"
    
    This reverts commit c23bda365dfbf56aa4d6d4a97f83136c36050e01.
    
    Revert all of the pl2303 changes that went into 3.12-rc1 and -rc2 as
    they cause regressions on some versions of the chip.  This will all be
    revisited for later kernel versions when we can figure out how to handle
    this in a way that does not break working devices.
    
    Reported-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Cc: Frank Schäfer <fschaefer.oss@googlemail.com>
    Acked-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 6638c5d9079d..09fb55cf3be7 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -281,12 +281,6 @@ static int pl2303_baudrate_encode_direct(int baud, enum pl2303_type type,
 				 4800, 7200, 9600, 14400, 19200, 28800, 38400,
 				 57600, 115200, 230400, 460800, 614400, 921600,
 				 1228800, 2457600, 3000000, 6000000 };
-	/*
-	 * NOTE: The PL2303HX (tested with rev. 3A) also supports the following
-	 * baud rates: 128000, 134400, 161280, 201600, 268800, 403200, 806400.
-	 * As long as we are not using this encoding method for them, there is
-	 * no point in complicating the code to support them.
-	 */
 	int i;
 
 	/* Set baudrate to nearest supported value */
@@ -400,12 +394,6 @@ static void pl2303_encode_baudrate(struct tty_struct *tty,
 	 *    => supported by all chip types
 	 * 2) Divisor based method: encodes a divisor to a base value (12MHz*32)
 	 *    => supported by HX chips (and likely not by type_0/1 chips)
-	 *
-	 * NOTE: Although the divisor based baud rate encoding method is much
-	 * more flexible, some of the standard baud rate values can not be
-	 * realized exactly. But the difference is very small (max. 0.2%) and
-	 * the device likely uses the same baud rate generator for both methods
-	 * so that there is likley no difference.
 	 */
 	if (type != HX)
 		baud = pl2303_baudrate_encode_direct(baud, type, buf);

commit 281393ad0bcfc309434d2bff38abc15805c2cbc4
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Nov 1 09:18:10 2013 -0700

    Revert "pl2303: simplify the else-if contruct for type_1 chips in pl2303_startup()"
    
    This reverts commit 73b583af597542329e6adae44524da6f27afed62.
    
    Revert all of the pl2303 changes that went into 3.12-rc1 and -rc2 as
    they cause regressions on some versions of the chip.  This will all be
    revisited for later kernel versions when we can figure out how to handle
    this in a way that does not break working devices.
    
    Reported-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Cc: Frank Schäfer <fschaefer.oss@googlemail.com>
    Acked-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 7efb39cd6f74..6638c5d9079d 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -193,8 +193,9 @@ static int pl2303_startup(struct usb_serial *serial)
 		type = type_0;
 	else if (serial->dev->descriptor.bMaxPacketSize0 == 0x40)
 		type = HX;
-	else if (serial->dev->descriptor.bDeviceClass == 0x00
-		 || serial->dev->descriptor.bDeviceClass == 0xFF)
+	else if (serial->dev->descriptor.bDeviceClass == 0x00)
+		type = type_1;
+	else if (serial->dev->descriptor.bDeviceClass == 0xFF)
 		type = type_1;
 	dev_dbg(&serial->interface->dev, "device type: %d\n", type);
 

commit b52e111363e366202386f3e67f71681dbbb8e5d9
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Nov 1 09:17:50 2013 -0700

    Revert "pl2303: improve the chip type information output on startup"
    
    This reverts commit a77a8c23e4db9fb1f776147eda0d85117359c700.
    
    Revert all of the pl2303 changes that went into 3.12-rc1 and -rc2 as
    they cause regressions on some versions of the chip.  This will all be
    revisited for later kernel versions when we can figure out how to handle
    this in a way that does not break working devices.
    
    Reported-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Cc: Frank Schäfer <fschaefer.oss@googlemail.com>
    Acked-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 409000a836dd..7efb39cd6f74 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -177,7 +177,6 @@ static int pl2303_startup(struct usb_serial *serial)
 {
 	struct pl2303_serial_private *spriv;
 	enum pl2303_type type = type_0;
-	char *type_str = "unknown (treating as type_0)";
 	unsigned char *buf;
 
 	spriv = kzalloc(sizeof(*spriv), GFP_KERNEL);
@@ -190,18 +189,14 @@ static int pl2303_startup(struct usb_serial *serial)
 		return -ENOMEM;
 	}
 
-	if (serial->dev->descriptor.bDeviceClass == 0x02) {
+	if (serial->dev->descriptor.bDeviceClass == 0x02)
 		type = type_0;
-		type_str = "type_0";
-	} else if (serial->dev->descriptor.bMaxPacketSize0 == 0x40) {
+	else if (serial->dev->descriptor.bMaxPacketSize0 == 0x40)
 		type = HX;
-		type_str = "X/HX";
-	} else if (serial->dev->descriptor.bDeviceClass == 0x00
-		   || serial->dev->descriptor.bDeviceClass == 0xFF) {
+	else if (serial->dev->descriptor.bDeviceClass == 0x00
+		 || serial->dev->descriptor.bDeviceClass == 0xFF)
 		type = type_1;
-		type_str = "type_1";
-	}
-	dev_dbg(&serial->interface->dev, "device type: %s\n", type_str);
+	dev_dbg(&serial->interface->dev, "device type: %d\n", type);
 
 	spriv->type = type;
 	usb_set_serial_data(serial, spriv);

commit e8bbd5c42b65b662756d67290a5c4dcda1abc596
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Nov 1 09:16:09 2013 -0700

    Revert "pl2303: improve the chip type detection/distinction"
    
    This reverts commit 034d1527adebd302115c87ef343497a889638275.
    
    Revert all of the pl2303 changes that went into 3.12-rc1 and -rc2 as
    they cause regressions on some versions of the chip.  This will all be
    revisited for later kernel versions when we can figure out how to handle
    this in a way that does not break working devices.
    
    Reported-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Cc: Frank Schäfer <fschaefer.oss@googlemail.com>
    Acked-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index e7a84f0f5179..409000a836dd 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -134,17 +134,10 @@ MODULE_DEVICE_TABLE(usb, id_table);
 
 
 enum pl2303_type {
-	type_0,		/* H version ? */
-	type_1,		/* H version ? */
-	HX_TA,		/* HX(A) / X(A) / TA version  */ /* TODO: improve */
-	HXD_EA_RA_SA,	/* HXD / EA / RA / SA version */ /* TODO: improve */
-	TB,		/* TB version */
+	type_0,		/* don't know the difference between type 0 and */
+	type_1,		/* type 1, until someone from prolific tells us... */
+	HX,		/* HX version of the pl2303 chip */
 };
-/*
- * NOTE: don't know the difference between type 0 and type 1,
- * until someone from Prolific tells us...
- * TODO: distinguish between X/HX, TA and HXD, EA, RA, SA variants
- */
 
 struct pl2303_serial_private {
 	enum pl2303_type type;
@@ -201,28 +194,8 @@ static int pl2303_startup(struct usb_serial *serial)
 		type = type_0;
 		type_str = "type_0";
 	} else if (serial->dev->descriptor.bMaxPacketSize0 == 0x40) {
-		/*
-		 * NOTE: The bcdDevice version is the only difference between
-		 * the device descriptors of the X/HX, HXD, EA, RA, SA, TA, TB
-		 */
-		if (le16_to_cpu(serial->dev->descriptor.bcdDevice) == 0x300) {
-			type = HX_TA;
-			type_str = "X/HX/TA";
-		} else if (le16_to_cpu(serial->dev->descriptor.bcdDevice)
-								     == 0x400) {
-			type = HXD_EA_RA_SA;
-			type_str = "HXD/EA/RA/SA";
-		} else if (le16_to_cpu(serial->dev->descriptor.bcdDevice)
-								     == 0x500) {
-			type = TB;
-			type_str = "TB";
-		} else {
-			dev_info(&serial->interface->dev,
-					   "unknown/unsupported device type\n");
-			kfree(spriv);
-			kfree(buf);
-			return -ENODEV;
-		}
+		type = HX;
+		type_str = "X/HX";
 	} else if (serial->dev->descriptor.bDeviceClass == 0x00
 		   || serial->dev->descriptor.bDeviceClass == 0xFF) {
 		type = type_1;
@@ -243,10 +216,10 @@ static int pl2303_startup(struct usb_serial *serial)
 	pl2303_vendor_read(0x8383, 0, serial, buf);
 	pl2303_vendor_write(0, 1, serial);
 	pl2303_vendor_write(1, 0, serial);
-	if (type == type_0 || type == type_1)
-		pl2303_vendor_write(2, 0x24, serial);
-	else
+	if (type == HX)
 		pl2303_vendor_write(2, 0x44, serial);
+	else
+		pl2303_vendor_write(2, 0x24, serial);
 
 	kfree(buf);
 	return 0;
@@ -311,19 +284,12 @@ static int pl2303_baudrate_encode_direct(int baud, enum pl2303_type type,
 	const int baud_sup[] = { 75, 150, 300, 600, 1200, 1800, 2400, 3600,
 				 4800, 7200, 9600, 14400, 19200, 28800, 38400,
 				 57600, 115200, 230400, 460800, 614400, 921600,
-				 1228800, 2457600, 3000000, 6000000, 12000000 };
+				 1228800, 2457600, 3000000, 6000000 };
 	/*
-	 * NOTE: With the exception of type_0/1 devices, the following
-	 * additional baud rates are supported (tested with HX rev. 3A only):
-	 * 110*, 56000*, 128000, 134400, 161280, 201600, 256000*, 268800,
-	 * 403200, 806400.	(*: not HX)
-	 *
-	 * Maximum values: HXD, TB: 12000000; HX, TA: 6000000;
-	 *                 type_0+1: 1228800; RA: 921600; SA: 115200
-	 *
-	 * As long as we are not using this encoding method for anything else
-	 * than the type_0+1 and HX chips, there is no point in complicating
-	 * the code to support them.
+	 * NOTE: The PL2303HX (tested with rev. 3A) also supports the following
+	 * baud rates: 128000, 134400, 161280, 201600, 268800, 403200, 806400.
+	 * As long as we are not using this encoding method for them, there is
+	 * no point in complicating the code to support them.
 	 */
 	int i;
 
@@ -338,14 +304,8 @@ static int pl2303_baudrate_encode_direct(int baud, enum pl2303_type type,
 		baud = baud_sup[i - 1];
 	else
 		baud = baud_sup[i];
-	/* Respect the chip type specific baud rate limits */
-	/*
-	 * FIXME: as long as we don't know how to distinguish between the
-	 * HXD, EA, RA, and SA chip variants, allow the max. value of 12M.
-	 */
-	if (type == HX_TA)
-		baud = min_t(int, baud, 6000000);
-	else if (type == type_0 || type == type_1)
+	/* type_0, type_1 only support up to 1228800 baud */
+	if (type != HX)
 		baud = min_t(int, baud, 1228800);
 	/* Direct (standard) baud rate encoding method */
 	put_unaligned_le32(baud, buf);
@@ -384,19 +344,10 @@ static int pl2303_baudrate_encode_divisor(int baud, enum pl2303_type type,
 	 * Baud rates smaller than the specified 75 baud are definitely working
 	 * fine.
 	 */
-	if (type == type_0 || type == type_1)
-		baud = min_t(int, baud, 1228800 * 1.1);
-	else if (type == HX_TA)
+	if (type == HX)
 		baud = min_t(int, baud, 6000000 * 1.1);
-	else if (type == HXD_EA_RA_SA)
-		/* HXD, EA: 12Mbps; RA: 1Mbps; SA: 115200 bps */
-		/*
-		 * FIXME: as long as we don't know how to distinguish between
-		 * these chip variants, allow the max. of these values
-		 */
-		baud = min_t(int, baud, 12000000 * 1.1);
-	else if (type == TB)
-		baud = min_t(int, baud, 12000000 * 1.1);
+	else
+		baud = min_t(int, baud, 1228800 * 1.1);
 	/* Determine factors A and B */
 	A = 0;
 	B = 12000000 * 32 / baud;  /* 12MHz */
@@ -460,7 +411,7 @@ static void pl2303_encode_baudrate(struct tty_struct *tty,
 	 * the device likely uses the same baud rate generator for both methods
 	 * so that there is likley no difference.
 	 */
-	if (type == type_0 || type == type_1)
+	if (type != HX)
 		baud = pl2303_baudrate_encode_direct(baud, type, buf);
 	else
 		baud = pl2303_baudrate_encode_divisor(baud, type, buf);
@@ -598,10 +549,10 @@ static void pl2303_set_termios(struct tty_struct *tty,
 	dev_dbg(&port->dev, "0xa1:0x21:0:0  %d - %7ph\n", i, buf);
 
 	if (C_CRTSCTS(tty)) {
-		if (spriv->type == type_0 || spriv->type == type_1)
-			pl2303_vendor_write(0x0, 0x41, serial);
-		else
+		if (spriv->type == HX)
 			pl2303_vendor_write(0x0, 0x61, serial);
+		else
+			pl2303_vendor_write(0x0, 0x41, serial);
 	} else {
 		pl2303_vendor_write(0x0, 0x0, serial);
 	}
@@ -638,7 +589,7 @@ static int pl2303_open(struct tty_struct *tty, struct usb_serial_port *port)
 	struct pl2303_serial_private *spriv = usb_get_serial_data(serial);
 	int result;
 
-	if (spriv->type == type_0 || spriv->type == type_1) {
+	if (spriv->type != HX) {
 		usb_clear_halt(serial->dev, port->write_urb->pipe);
 		usb_clear_halt(serial->dev, port->read_urb->pipe);
 	} else {

commit 09169197c9f5e3b42f0c83c6d7071b3e9c94153e
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Nov 1 09:12:52 2013 -0700

    Revert "USB: pl2303: distinguish between original and cloned HX chips"
    
    This reverts commit 7d26a78f62ff4fb08bc5ba740a8af4aa7ac67da4.
    
    Revert all of the pl2303 changes that went into 3.12-rc1 and -rc2 as
    they cause regressions on some versions of the chip.  This will all be
    revisited for later kernel versions when we can figure out how to handle
    this in a way that does not break working devices.
    
    Reported-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Cc: Frank Schäfer <fschaefer.oss@googlemail.com>
    Acked-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index bedf8e47713b..e7a84f0f5179 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -139,7 +139,6 @@ enum pl2303_type {
 	HX_TA,		/* HX(A) / X(A) / TA version  */ /* TODO: improve */
 	HXD_EA_RA_SA,	/* HXD / EA / RA / SA version */ /* TODO: improve */
 	TB,		/* TB version */
-	HX_CLONE,	/* Cheap and less functional clone of the HX chip */
 };
 /*
  * NOTE: don't know the difference between type 0 and type 1,
@@ -207,23 +206,8 @@ static int pl2303_startup(struct usb_serial *serial)
 		 * the device descriptors of the X/HX, HXD, EA, RA, SA, TA, TB
 		 */
 		if (le16_to_cpu(serial->dev->descriptor.bcdDevice) == 0x300) {
-			/* Check if the device is a clone */
-			pl2303_vendor_read(0x9494, 0, serial, buf);
-			/*
-			 * NOTE: Not sure if this read is really needed.
-			 * The HX returns 0x00, the clone 0x02, but the Windows
-			 * driver seems to ignore the value and continues.
-			 */
-			pl2303_vendor_write(0x0606, 0xaa, serial);
-			pl2303_vendor_read(0x8686, 0, serial, buf);
-			if (buf[0] != 0xaa) {
-				type = HX_CLONE;
-				type_str = "X/HX clone (limited functionality)";
-			} else {
-				type = HX_TA;
-				type_str = "X/HX/TA";
-			}
-			pl2303_vendor_write(0x0606, 0x00, serial);
+			type = HX_TA;
+			type_str = "X/HX/TA";
 		} else if (le16_to_cpu(serial->dev->descriptor.bcdDevice)
 								     == 0x400) {
 			type = HXD_EA_RA_SA;
@@ -321,9 +305,8 @@ static int pl2303_baudrate_encode_direct(int baud, enum pl2303_type type,
 {
 	/*
 	 * NOTE: Only the values defined in baud_sup are supported !
-	 * => if unsupported values are set, the PL2303 uses 9600 baud instead
-	 * => HX clones just don't work at unsupported baud rates < 115200 baud,
-	 *    for baud rates > 115200 they run at 115200 baud
+	 *       => if unsupported values are set, the PL2303 seems to
+	 *	    use 9600 baud (at least my PL2303X always does)
 	 */
 	const int baud_sup[] = { 75, 150, 300, 600, 1200, 1800, 2400, 3600,
 				 4800, 7200, 9600, 14400, 19200, 28800, 38400,
@@ -333,14 +316,14 @@ static int pl2303_baudrate_encode_direct(int baud, enum pl2303_type type,
 	 * NOTE: With the exception of type_0/1 devices, the following
 	 * additional baud rates are supported (tested with HX rev. 3A only):
 	 * 110*, 56000*, 128000, 134400, 161280, 201600, 256000*, 268800,
-	 * 403200, 806400.	(*: not HX and HX clones)
+	 * 403200, 806400.	(*: not HX)
 	 *
 	 * Maximum values: HXD, TB: 12000000; HX, TA: 6000000;
-	 *                 type_0+1: 1228800; RA: 921600; HX clones, SA: 115200
+	 *                 type_0+1: 1228800; RA: 921600; SA: 115200
 	 *
 	 * As long as we are not using this encoding method for anything else
-	 * than the type_0+1, HX and HX clone chips, there is no point in
-	 * complicating the code to support them.
+	 * than the type_0+1 and HX chips, there is no point in complicating
+	 * the code to support them.
 	 */
 	int i;
 
@@ -364,8 +347,6 @@ static int pl2303_baudrate_encode_direct(int baud, enum pl2303_type type,
 		baud = min_t(int, baud, 6000000);
 	else if (type == type_0 || type == type_1)
 		baud = min_t(int, baud, 1228800);
-	else if (type == HX_CLONE)
-		baud = min_t(int, baud, 115200);
 	/* Direct (standard) baud rate encoding method */
 	put_unaligned_le32(baud, buf);
 
@@ -378,8 +359,7 @@ static int pl2303_baudrate_encode_divisor(int baud, enum pl2303_type type,
 	/*
 	 * Divisor based baud rate encoding method
 	 *
-	 * NOTE: HX clones do NOT support this method.
-	 * It's not clear if the type_0/1 chips support it.
+	 * NOTE: it's not clear if the type_0/1 chips support this method
 	 *
 	 * divisor = 12MHz * 32 / baudrate = 2^A * B
 	 *
@@ -472,7 +452,7 @@ static void pl2303_encode_baudrate(struct tty_struct *tty,
 	 * 1) Direct method: encodes the baud rate value directly
 	 *    => supported by all chip types
 	 * 2) Divisor based method: encodes a divisor to a base value (12MHz*32)
-	 *    => not supported by HX clones (and likely type_0/1 chips)
+	 *    => supported by HX chips (and likely not by type_0/1 chips)
 	 *
 	 * NOTE: Although the divisor based baud rate encoding method is much
 	 * more flexible, some of the standard baud rate values can not be
@@ -480,7 +460,7 @@ static void pl2303_encode_baudrate(struct tty_struct *tty,
 	 * the device likely uses the same baud rate generator for both methods
 	 * so that there is likley no difference.
 	 */
-	if (type == type_0 || type == type_1 || type == HX_CLONE)
+	if (type == type_0 || type == type_1)
 		baud = pl2303_baudrate_encode_direct(baud, type, buf);
 	else
 		baud = pl2303_baudrate_encode_divisor(baud, type, buf);
@@ -833,7 +813,6 @@ static void pl2303_break_ctl(struct tty_struct *tty, int break_state)
 	result = usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),
 				 BREAK_REQUEST, BREAK_REQUEST_TYPE, state,
 				 0, NULL, 0, 100);
-	/* NOTE: HX clones don't support sending breaks, -EPIPE is returned */
 	if (result)
 		dev_err(&port->dev, "error sending break = %d\n", result);
 }

commit 7d26a78f62ff4fb08bc5ba740a8af4aa7ac67da4
Author: Frank Schäfer <fschaefer.oss@googlemail.com>
Date:   Sat Sep 14 15:36:48 2013 +0200

    USB: pl2303: distinguish between original and cloned HX chips
    
    According to Prolific, several (unauthorized) cheap and less functional
    clones of the PL2303HX chip are in circulation. [1]
    I've had the chance to test such a cloned device and it turned out that
    it doesn't support any baud rates above 115200 baud (original: 6 Mbaud)
    It also doesn't support the divisior based baud rate encoding method,
    so no continuous baud rate adjustment is possible.
    Nevertheless, these devices have been working (unintentionally) with
    the driver up to commit 61fa8d694b ("pl2303: also use the divisor based
    baud rate encoding method for baud rates < 115200 with HX chips"), and
    this commit broke support for them.
    Fortunately, it is pretty simple to distinguish between the original
    and the cloned HX chips, so I've added a check and an extra chip type
    to keep the clones working.
    The same check is used by the latest Prolific Windows driver, so it
    should be solid.
    
    [1] http://www.prolific.com.tw/US/ShowProduct.aspx?p_id=225&pcid=41
    
    Signed-off-by: Frank Schäfer <fschaefer.oss@googlemail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index e7a84f0f5179..bedf8e47713b 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -139,6 +139,7 @@ enum pl2303_type {
 	HX_TA,		/* HX(A) / X(A) / TA version  */ /* TODO: improve */
 	HXD_EA_RA_SA,	/* HXD / EA / RA / SA version */ /* TODO: improve */
 	TB,		/* TB version */
+	HX_CLONE,	/* Cheap and less functional clone of the HX chip */
 };
 /*
  * NOTE: don't know the difference between type 0 and type 1,
@@ -206,8 +207,23 @@ static int pl2303_startup(struct usb_serial *serial)
 		 * the device descriptors of the X/HX, HXD, EA, RA, SA, TA, TB
 		 */
 		if (le16_to_cpu(serial->dev->descriptor.bcdDevice) == 0x300) {
-			type = HX_TA;
-			type_str = "X/HX/TA";
+			/* Check if the device is a clone */
+			pl2303_vendor_read(0x9494, 0, serial, buf);
+			/*
+			 * NOTE: Not sure if this read is really needed.
+			 * The HX returns 0x00, the clone 0x02, but the Windows
+			 * driver seems to ignore the value and continues.
+			 */
+			pl2303_vendor_write(0x0606, 0xaa, serial);
+			pl2303_vendor_read(0x8686, 0, serial, buf);
+			if (buf[0] != 0xaa) {
+				type = HX_CLONE;
+				type_str = "X/HX clone (limited functionality)";
+			} else {
+				type = HX_TA;
+				type_str = "X/HX/TA";
+			}
+			pl2303_vendor_write(0x0606, 0x00, serial);
 		} else if (le16_to_cpu(serial->dev->descriptor.bcdDevice)
 								     == 0x400) {
 			type = HXD_EA_RA_SA;
@@ -305,8 +321,9 @@ static int pl2303_baudrate_encode_direct(int baud, enum pl2303_type type,
 {
 	/*
 	 * NOTE: Only the values defined in baud_sup are supported !
-	 *       => if unsupported values are set, the PL2303 seems to
-	 *	    use 9600 baud (at least my PL2303X always does)
+	 * => if unsupported values are set, the PL2303 uses 9600 baud instead
+	 * => HX clones just don't work at unsupported baud rates < 115200 baud,
+	 *    for baud rates > 115200 they run at 115200 baud
 	 */
 	const int baud_sup[] = { 75, 150, 300, 600, 1200, 1800, 2400, 3600,
 				 4800, 7200, 9600, 14400, 19200, 28800, 38400,
@@ -316,14 +333,14 @@ static int pl2303_baudrate_encode_direct(int baud, enum pl2303_type type,
 	 * NOTE: With the exception of type_0/1 devices, the following
 	 * additional baud rates are supported (tested with HX rev. 3A only):
 	 * 110*, 56000*, 128000, 134400, 161280, 201600, 256000*, 268800,
-	 * 403200, 806400.	(*: not HX)
+	 * 403200, 806400.	(*: not HX and HX clones)
 	 *
 	 * Maximum values: HXD, TB: 12000000; HX, TA: 6000000;
-	 *                 type_0+1: 1228800; RA: 921600; SA: 115200
+	 *                 type_0+1: 1228800; RA: 921600; HX clones, SA: 115200
 	 *
 	 * As long as we are not using this encoding method for anything else
-	 * than the type_0+1 and HX chips, there is no point in complicating
-	 * the code to support them.
+	 * than the type_0+1, HX and HX clone chips, there is no point in
+	 * complicating the code to support them.
 	 */
 	int i;
 
@@ -347,6 +364,8 @@ static int pl2303_baudrate_encode_direct(int baud, enum pl2303_type type,
 		baud = min_t(int, baud, 6000000);
 	else if (type == type_0 || type == type_1)
 		baud = min_t(int, baud, 1228800);
+	else if (type == HX_CLONE)
+		baud = min_t(int, baud, 115200);
 	/* Direct (standard) baud rate encoding method */
 	put_unaligned_le32(baud, buf);
 
@@ -359,7 +378,8 @@ static int pl2303_baudrate_encode_divisor(int baud, enum pl2303_type type,
 	/*
 	 * Divisor based baud rate encoding method
 	 *
-	 * NOTE: it's not clear if the type_0/1 chips support this method
+	 * NOTE: HX clones do NOT support this method.
+	 * It's not clear if the type_0/1 chips support it.
 	 *
 	 * divisor = 12MHz * 32 / baudrate = 2^A * B
 	 *
@@ -452,7 +472,7 @@ static void pl2303_encode_baudrate(struct tty_struct *tty,
 	 * 1) Direct method: encodes the baud rate value directly
 	 *    => supported by all chip types
 	 * 2) Divisor based method: encodes a divisor to a base value (12MHz*32)
-	 *    => supported by HX chips (and likely not by type_0/1 chips)
+	 *    => not supported by HX clones (and likely type_0/1 chips)
 	 *
 	 * NOTE: Although the divisor based baud rate encoding method is much
 	 * more flexible, some of the standard baud rate values can not be
@@ -460,7 +480,7 @@ static void pl2303_encode_baudrate(struct tty_struct *tty,
 	 * the device likely uses the same baud rate generator for both methods
 	 * so that there is likley no difference.
 	 */
-	if (type == type_0 || type == type_1)
+	if (type == type_0 || type == type_1 || type == HX_CLONE)
 		baud = pl2303_baudrate_encode_direct(baud, type, buf);
 	else
 		baud = pl2303_baudrate_encode_divisor(baud, type, buf);
@@ -813,6 +833,7 @@ static void pl2303_break_ctl(struct tty_struct *tty, int break_state)
 	result = usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),
 				 BREAK_REQUEST, BREAK_REQUEST_TYPE, state,
 				 0, NULL, 0, 100);
+	/* NOTE: HX clones don't support sending breaks, -EPIPE is returned */
 	if (result)
 		dev_err(&port->dev, "error sending break = %d\n", result);
 }

commit 034d1527adebd302115c87ef343497a889638275
Author: Frank Schäfer <fschaefer.oss@googlemail.com>
Date:   Wed Aug 14 20:09:11 2013 +0200

    pl2303: improve the chip type detection/distinction
    
    The driver currently knows about 3 different PL2303 chip types:
    The two legacy chip types type_0 and type_1 (PL2303H ?) and the HX
    type.
    The device distinction is currently completely based on the examination
    of the USB descriptors.
    During the last years, Prolific has introduced further PL2303 chips,
    such as the HXD (HX rev. D), TA (which replaced the X/HX chips), SA,
    RA, EA and TB variants.
    Unfortunately, all these new chips are currently detected as HX chips,
    because they are all using the same bMaxPacketSize0 = 0x40 value in the
    USB device descriptor.
    
    At this point it is not clear if these chips are really working with
    the driver, there are just some positive indicators (like device
    manufacturers claiming Linux support for these devices or commit
    8d48fdf689 "correctly handle baudrates above 115200" which should only
    be necessary for newer devices, ...)
    
    For a complete support of all devices, we need to distinguish between
    them, because they differ in several functional aspects, such  as the
    maximum supported baud rate (HXD, TB, EA: 12Mbps, HX, TA: 6Mbps,
    RA: 1Mbps, SA: 115.2kbps), handshaking line support, RS422/485 and
    GPIO ports support (currently not supported by the driver).
    And there might be further differences that we don't know yet.
    
    This patch improves the chip type detection by evaluating the bcdDevice
    value of the device descriptor. The values are taken from the
    datasheets and are safe to use because manufacturers can't change them:
    
    3.00: X/HX, TA
    4.00: HXD, EA, RA, SA
    5.00: TB
    
    The rest of the device descriptors is completely identical, so no
    further distinction is possible this way.
    Anyway, Prolifics "checkChipVersion.exe"-tool is definitely able to
    distinguish for example between the X/HX and the TA chips, so there
    must be a possibility to improve the distinction further...
    
    Signed-off-by: Frank Schäfer <fschaefer.oss@googlemail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 409000a836dd..e7a84f0f5179 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -134,10 +134,17 @@ MODULE_DEVICE_TABLE(usb, id_table);
 
 
 enum pl2303_type {
-	type_0,		/* don't know the difference between type 0 and */
-	type_1,		/* type 1, until someone from prolific tells us... */
-	HX,		/* HX version of the pl2303 chip */
+	type_0,		/* H version ? */
+	type_1,		/* H version ? */
+	HX_TA,		/* HX(A) / X(A) / TA version  */ /* TODO: improve */
+	HXD_EA_RA_SA,	/* HXD / EA / RA / SA version */ /* TODO: improve */
+	TB,		/* TB version */
 };
+/*
+ * NOTE: don't know the difference between type 0 and type 1,
+ * until someone from Prolific tells us...
+ * TODO: distinguish between X/HX, TA and HXD, EA, RA, SA variants
+ */
 
 struct pl2303_serial_private {
 	enum pl2303_type type;
@@ -194,8 +201,28 @@ static int pl2303_startup(struct usb_serial *serial)
 		type = type_0;
 		type_str = "type_0";
 	} else if (serial->dev->descriptor.bMaxPacketSize0 == 0x40) {
-		type = HX;
-		type_str = "X/HX";
+		/*
+		 * NOTE: The bcdDevice version is the only difference between
+		 * the device descriptors of the X/HX, HXD, EA, RA, SA, TA, TB
+		 */
+		if (le16_to_cpu(serial->dev->descriptor.bcdDevice) == 0x300) {
+			type = HX_TA;
+			type_str = "X/HX/TA";
+		} else if (le16_to_cpu(serial->dev->descriptor.bcdDevice)
+								     == 0x400) {
+			type = HXD_EA_RA_SA;
+			type_str = "HXD/EA/RA/SA";
+		} else if (le16_to_cpu(serial->dev->descriptor.bcdDevice)
+								     == 0x500) {
+			type = TB;
+			type_str = "TB";
+		} else {
+			dev_info(&serial->interface->dev,
+					   "unknown/unsupported device type\n");
+			kfree(spriv);
+			kfree(buf);
+			return -ENODEV;
+		}
 	} else if (serial->dev->descriptor.bDeviceClass == 0x00
 		   || serial->dev->descriptor.bDeviceClass == 0xFF) {
 		type = type_1;
@@ -216,10 +243,10 @@ static int pl2303_startup(struct usb_serial *serial)
 	pl2303_vendor_read(0x8383, 0, serial, buf);
 	pl2303_vendor_write(0, 1, serial);
 	pl2303_vendor_write(1, 0, serial);
-	if (type == HX)
-		pl2303_vendor_write(2, 0x44, serial);
-	else
+	if (type == type_0 || type == type_1)
 		pl2303_vendor_write(2, 0x24, serial);
+	else
+		pl2303_vendor_write(2, 0x44, serial);
 
 	kfree(buf);
 	return 0;
@@ -284,12 +311,19 @@ static int pl2303_baudrate_encode_direct(int baud, enum pl2303_type type,
 	const int baud_sup[] = { 75, 150, 300, 600, 1200, 1800, 2400, 3600,
 				 4800, 7200, 9600, 14400, 19200, 28800, 38400,
 				 57600, 115200, 230400, 460800, 614400, 921600,
-				 1228800, 2457600, 3000000, 6000000 };
+				 1228800, 2457600, 3000000, 6000000, 12000000 };
 	/*
-	 * NOTE: The PL2303HX (tested with rev. 3A) also supports the following
-	 * baud rates: 128000, 134400, 161280, 201600, 268800, 403200, 806400.
-	 * As long as we are not using this encoding method for them, there is
-	 * no point in complicating the code to support them.
+	 * NOTE: With the exception of type_0/1 devices, the following
+	 * additional baud rates are supported (tested with HX rev. 3A only):
+	 * 110*, 56000*, 128000, 134400, 161280, 201600, 256000*, 268800,
+	 * 403200, 806400.	(*: not HX)
+	 *
+	 * Maximum values: HXD, TB: 12000000; HX, TA: 6000000;
+	 *                 type_0+1: 1228800; RA: 921600; SA: 115200
+	 *
+	 * As long as we are not using this encoding method for anything else
+	 * than the type_0+1 and HX chips, there is no point in complicating
+	 * the code to support them.
 	 */
 	int i;
 
@@ -304,8 +338,14 @@ static int pl2303_baudrate_encode_direct(int baud, enum pl2303_type type,
 		baud = baud_sup[i - 1];
 	else
 		baud = baud_sup[i];
-	/* type_0, type_1 only support up to 1228800 baud */
-	if (type != HX)
+	/* Respect the chip type specific baud rate limits */
+	/*
+	 * FIXME: as long as we don't know how to distinguish between the
+	 * HXD, EA, RA, and SA chip variants, allow the max. value of 12M.
+	 */
+	if (type == HX_TA)
+		baud = min_t(int, baud, 6000000);
+	else if (type == type_0 || type == type_1)
 		baud = min_t(int, baud, 1228800);
 	/* Direct (standard) baud rate encoding method */
 	put_unaligned_le32(baud, buf);
@@ -344,10 +384,19 @@ static int pl2303_baudrate_encode_divisor(int baud, enum pl2303_type type,
 	 * Baud rates smaller than the specified 75 baud are definitely working
 	 * fine.
 	 */
-	if (type == HX)
-		baud = min_t(int, baud, 6000000 * 1.1);
-	else
+	if (type == type_0 || type == type_1)
 		baud = min_t(int, baud, 1228800 * 1.1);
+	else if (type == HX_TA)
+		baud = min_t(int, baud, 6000000 * 1.1);
+	else if (type == HXD_EA_RA_SA)
+		/* HXD, EA: 12Mbps; RA: 1Mbps; SA: 115200 bps */
+		/*
+		 * FIXME: as long as we don't know how to distinguish between
+		 * these chip variants, allow the max. of these values
+		 */
+		baud = min_t(int, baud, 12000000 * 1.1);
+	else if (type == TB)
+		baud = min_t(int, baud, 12000000 * 1.1);
 	/* Determine factors A and B */
 	A = 0;
 	B = 12000000 * 32 / baud;  /* 12MHz */
@@ -411,7 +460,7 @@ static void pl2303_encode_baudrate(struct tty_struct *tty,
 	 * the device likely uses the same baud rate generator for both methods
 	 * so that there is likley no difference.
 	 */
-	if (type != HX)
+	if (type == type_0 || type == type_1)
 		baud = pl2303_baudrate_encode_direct(baud, type, buf);
 	else
 		baud = pl2303_baudrate_encode_divisor(baud, type, buf);
@@ -549,10 +598,10 @@ static void pl2303_set_termios(struct tty_struct *tty,
 	dev_dbg(&port->dev, "0xa1:0x21:0:0  %d - %7ph\n", i, buf);
 
 	if (C_CRTSCTS(tty)) {
-		if (spriv->type == HX)
-			pl2303_vendor_write(0x0, 0x61, serial);
-		else
+		if (spriv->type == type_0 || spriv->type == type_1)
 			pl2303_vendor_write(0x0, 0x41, serial);
+		else
+			pl2303_vendor_write(0x0, 0x61, serial);
 	} else {
 		pl2303_vendor_write(0x0, 0x0, serial);
 	}
@@ -589,7 +638,7 @@ static int pl2303_open(struct tty_struct *tty, struct usb_serial_port *port)
 	struct pl2303_serial_private *spriv = usb_get_serial_data(serial);
 	int result;
 
-	if (spriv->type != HX) {
+	if (spriv->type == type_0 || spriv->type == type_1) {
 		usb_clear_halt(serial->dev, port->write_urb->pipe);
 		usb_clear_halt(serial->dev, port->read_urb->pipe);
 	} else {

commit a77a8c23e4db9fb1f776147eda0d85117359c700
Author: Frank Schäfer <fschaefer.oss@googlemail.com>
Date:   Wed Aug 14 20:09:10 2013 +0200

    pl2303: improve the chip type information output on startup
    
    The chip type distinction is getting more and more relevant and
    complicating, so always print the chip type.
    Printing a name string is also much better than just printing an
    internal index number.
    
    Signed-off-by: Frank Schäfer <fschaefer.oss@googlemail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 7efb39cd6f74..409000a836dd 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -177,6 +177,7 @@ static int pl2303_startup(struct usb_serial *serial)
 {
 	struct pl2303_serial_private *spriv;
 	enum pl2303_type type = type_0;
+	char *type_str = "unknown (treating as type_0)";
 	unsigned char *buf;
 
 	spriv = kzalloc(sizeof(*spriv), GFP_KERNEL);
@@ -189,14 +190,18 @@ static int pl2303_startup(struct usb_serial *serial)
 		return -ENOMEM;
 	}
 
-	if (serial->dev->descriptor.bDeviceClass == 0x02)
+	if (serial->dev->descriptor.bDeviceClass == 0x02) {
 		type = type_0;
-	else if (serial->dev->descriptor.bMaxPacketSize0 == 0x40)
+		type_str = "type_0";
+	} else if (serial->dev->descriptor.bMaxPacketSize0 == 0x40) {
 		type = HX;
-	else if (serial->dev->descriptor.bDeviceClass == 0x00
-		 || serial->dev->descriptor.bDeviceClass == 0xFF)
+		type_str = "X/HX";
+	} else if (serial->dev->descriptor.bDeviceClass == 0x00
+		   || serial->dev->descriptor.bDeviceClass == 0xFF) {
 		type = type_1;
-	dev_dbg(&serial->interface->dev, "device type: %d\n", type);
+		type_str = "type_1";
+	}
+	dev_dbg(&serial->interface->dev, "device type: %s\n", type_str);
 
 	spriv->type = type;
 	usb_set_serial_data(serial, spriv);

commit 73b583af597542329e6adae44524da6f27afed62
Author: Frank Schäfer <fschaefer.oss@googlemail.com>
Date:   Wed Aug 14 20:09:09 2013 +0200

    pl2303: simplify the else-if contruct for type_1 chips in pl2303_startup()
    
    There is no need for two else-if constructs for the type_1 chip
    detection in pl2303_startup(), so merge them.
    
    Signed-off-by: Frank Schäfer <fschaefer.oss@googlemail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 6638c5d9079d..7efb39cd6f74 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -193,9 +193,8 @@ static int pl2303_startup(struct usb_serial *serial)
 		type = type_0;
 	else if (serial->dev->descriptor.bMaxPacketSize0 == 0x40)
 		type = HX;
-	else if (serial->dev->descriptor.bDeviceClass == 0x00)
-		type = type_1;
-	else if (serial->dev->descriptor.bDeviceClass == 0xFF)
+	else if (serial->dev->descriptor.bDeviceClass == 0x00
+		 || serial->dev->descriptor.bDeviceClass == 0xFF)
 		type = type_1;
 	dev_dbg(&serial->interface->dev, "device type: %d\n", type);
 

commit c23bda365dfbf56aa4d6d4a97f83136c36050e01
Author: Frank Schäfer <fschaefer.oss@googlemail.com>
Date:   Tue Aug 6 19:26:29 2013 +0200

    usb: pl2303: add two comments concerning the supported baud rates with HX chips
    
    I've found some new datasheets which describe some additionally
    supported standard baud rates and I've verified them with my HX
    (rev. 3A) device. But adding support for individual (chip type
    specific) baud rates would add a good amount of extra code (especially
    when support for further chips will be added to the driver one day),
    which makes no sense as long as we are not using the direct baud rate
    encoding method for newer chips.
    So for now, just drop a comment about these additionally supported baud
    rates.
    
    The second comment is about the baud rate differences between the two
    encoding methods. In theory, we could optimize the code a bit by
    comparing the resulting baud rates of both methods and selecting the
    one which is closer to the requested baud rate. But that seems to be a
    bit overkill, because the differences are very small and the device
    likely uses the same baud rate generator for both methods so that the
    resulting baud rate would be the same.
    
    Signed-off-by: Frank Schäfer <fschaefer.oss@googlemail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 09fb55cf3be7..6638c5d9079d 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -281,6 +281,12 @@ static int pl2303_baudrate_encode_direct(int baud, enum pl2303_type type,
 				 4800, 7200, 9600, 14400, 19200, 28800, 38400,
 				 57600, 115200, 230400, 460800, 614400, 921600,
 				 1228800, 2457600, 3000000, 6000000 };
+	/*
+	 * NOTE: The PL2303HX (tested with rev. 3A) also supports the following
+	 * baud rates: 128000, 134400, 161280, 201600, 268800, 403200, 806400.
+	 * As long as we are not using this encoding method for them, there is
+	 * no point in complicating the code to support them.
+	 */
 	int i;
 
 	/* Set baudrate to nearest supported value */
@@ -394,6 +400,12 @@ static void pl2303_encode_baudrate(struct tty_struct *tty,
 	 *    => supported by all chip types
 	 * 2) Divisor based method: encodes a divisor to a base value (12MHz*32)
 	 *    => supported by HX chips (and likely not by type_0/1 chips)
+	 *
+	 * NOTE: Although the divisor based baud rate encoding method is much
+	 * more flexible, some of the standard baud rate values can not be
+	 * realized exactly. But the difference is very small (max. 0.2%) and
+	 * the device likely uses the same baud rate generator for both methods
+	 * so that there is likley no difference.
 	 */
 	if (type != HX)
 		baud = pl2303_baudrate_encode_direct(baud, type, buf);

commit 61fa8d694b8547894b57ea0d99d0120a58f6ebf8
Author: Frank Schäfer <fschaefer.oss@googlemail.com>
Date:   Tue Aug 6 19:26:28 2013 +0200

    usb: pl2303: also use the divisor based baud rate encoding method for baud rates < 115200 with HX chips
    
    Now that the divisor based baud rate encoding method has been fixed and
    extended, it can also be used for baud rates < 115200 baud with HX
    chips.
    This makes it possible to adjust the baud rate almost continuously
    instead of just beeing able to select between 16 fixed standard values.
    
    Tested with a PL2303HX 04463A (week 46, 2004, rev 3A).
    
    Signed-off-by: Frank Schäfer <fschaefer.oss@googlemail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 61c9f9d28ee9..09fb55cf3be7 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -395,7 +395,7 @@ static void pl2303_encode_baudrate(struct tty_struct *tty,
 	 * 2) Divisor based method: encodes a divisor to a base value (12MHz*32)
 	 *    => supported by HX chips (and likely not by type_0/1 chips)
 	 */
-	if (type != HX || baud <= 115200)
+	if (type != HX)
 		baud = pl2303_baudrate_encode_direct(baud, type, buf);
 	else
 		baud = pl2303_baudrate_encode_divisor(baud, type, buf);

commit b5c16c6a031c52cc4b7dda6c3de46462fbc92eab
Author: Frank Schäfer <fschaefer.oss@googlemail.com>
Date:   Tue Aug 6 19:26:27 2013 +0200

    usb: pl2303: increase the allowed baud rate range for the divisor based encoding method
    
    Reinhard Max has done some tests with a PL2303HX (rev A) and a logic
    analyzer and it seems, that although the PL2303HX is specified for baud
    rates from 75 to 6M baud, the full divisor range can be used with the
    divisor based baud rate encoding method. This corresponds to baud rates
    from 46 to 24M baud.
    Baud rates down to 46 baud (max. divisor) have been confirmed to work
    even under heavy/permanent load, so remove the lower limit.
    Baud rates up to 24M baud should really be tested carefully in "real
    life" scenarios before removing the upper limit completely.
    Anyway, the Windows driver allows maximum baud rates of 110% of the
    specified limit, so for now, increase the upper limit to this value.
    
    Signed-off-by: Frank Schäfer <fschaefer.oss@googlemail.com>
    Signed-off-by: Reinhard Max <max@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 693ed7e4871a..61c9f9d28ee9 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -324,12 +324,20 @@ static int pl2303_baudrate_encode_divisor(int baud, enum pl2303_type type,
 	 */
 	unsigned int A, B;
 
-	/* Respect the specified baud rate limits */
-	baud = max_t(int, baud, 75);
+	/*
+	 * NOTE: The Windows driver allows maximum baud rates of 110% of the
+	 * specified maximium value.
+	 * Quick tests with early (2004) HX (rev. A) chips suggest, that even
+	 * higher baud rates (up to the maximum of 24M baud !) are working fine,
+	 * but that should really be tested carefully in "real life" scenarios
+	 * before removing the upper limit completely.
+	 * Baud rates smaller than the specified 75 baud are definitely working
+	 * fine.
+	 */
 	if (type == HX)
-		baud = min_t(int, baud, 6000000);
+		baud = min_t(int, baud, 6000000 * 1.1);
 	else
-		baud = min_t(int, baud, 1228800);
+		baud = min_t(int, baud, 1228800 * 1.1);
 	/* Determine factors A and B */
 	A = 0;
 	B = 12000000 * 32 / baud;  /* 12MHz */

commit e917ba01d69ad705a4cd6a6c77538f55d84f5907
Author: Frank Schäfer <fschaefer.oss@googlemail.com>
Date:   Tue Aug 6 19:26:26 2013 +0200

    usb: pl2303: move the two baud rate encoding methods to separate functions
    
    Signed-off-by: Frank Schäfer <fschaefer.oss@googlemail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index a0ea92ed35c6..693ed7e4871a 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -269,115 +269,128 @@ static int pl2303_set_control_lines(struct usb_serial_port *port, u8 value)
 	return retval;
 }
 
+static int pl2303_baudrate_encode_direct(int baud, enum pl2303_type type,
+								      u8 buf[4])
+{
+	/*
+	 * NOTE: Only the values defined in baud_sup are supported !
+	 *       => if unsupported values are set, the PL2303 seems to
+	 *	    use 9600 baud (at least my PL2303X always does)
+	 */
+	const int baud_sup[] = { 75, 150, 300, 600, 1200, 1800, 2400, 3600,
+				 4800, 7200, 9600, 14400, 19200, 28800, 38400,
+				 57600, 115200, 230400, 460800, 614400, 921600,
+				 1228800, 2457600, 3000000, 6000000 };
+	int i;
+
+	/* Set baudrate to nearest supported value */
+	for (i = 0; i < ARRAY_SIZE(baud_sup); ++i) {
+		if (baud_sup[i] > baud)
+			break;
+	}
+	if (i == ARRAY_SIZE(baud_sup))
+		baud = baud_sup[i - 1];
+	else if (i > 0 && (baud_sup[i] - baud) > (baud - baud_sup[i - 1]))
+		baud = baud_sup[i - 1];
+	else
+		baud = baud_sup[i];
+	/* type_0, type_1 only support up to 1228800 baud */
+	if (type != HX)
+		baud = min_t(int, baud, 1228800);
+	/* Direct (standard) baud rate encoding method */
+	put_unaligned_le32(baud, buf);
+
+	return baud;
+}
+
+static int pl2303_baudrate_encode_divisor(int baud, enum pl2303_type type,
+								      u8 buf[4])
+{
+	/*
+	 * Divisor based baud rate encoding method
+	 *
+	 * NOTE: it's not clear if the type_0/1 chips support this method
+	 *
+	 * divisor = 12MHz * 32 / baudrate = 2^A * B
+	 *
+	 * with
+	 *
+	 * A = buf[1] & 0x0e
+	 * B = buf[0]  +  (buf[1] & 0x01) << 8
+	 *
+	 * Special cases:
+	 * => 8 < B < 16: device seems to work not properly
+	 * => B <= 8: device uses the max. value B = 512 instead
+	 */
+	unsigned int A, B;
+
+	/* Respect the specified baud rate limits */
+	baud = max_t(int, baud, 75);
+	if (type == HX)
+		baud = min_t(int, baud, 6000000);
+	else
+		baud = min_t(int, baud, 1228800);
+	/* Determine factors A and B */
+	A = 0;
+	B = 12000000 * 32 / baud;  /* 12MHz */
+	B <<= 1; /* Add one bit for rounding */
+	while (B > (512 << 1) && A <= 14) {
+		A += 2;
+		B >>= 2;
+	}
+	if (A > 14) { /* max. divisor = min. baudrate reached */
+		A = 14;
+		B = 512;
+		/* => ~45.78 baud */
+	} else {
+		B = (B + 1) >> 1; /* Round the last bit */
+	}
+	/* Handle special cases */
+	if (B == 512)
+		B = 0; /* also: 1 to 8 */
+	else if (B < 16)
+		/*
+		 * NOTE: With the current algorithm this happens
+		 * only for A=0 and means that the min. divisor
+		 * (respectively: the max. baudrate) is reached.
+		 */
+		B = 16;		/* => 24 MBaud */
+	/* Encode the baud rate */
+	buf[3] = 0x80;     /* Select divisor encoding method */
+	buf[2] = 0;
+	buf[1] = (A & 0x0e);		/* A */
+	buf[1] |= ((B & 0x100) >> 8);	/* MSB of B */
+	buf[0] = B & 0xff;		/* 8 LSBs of B */
+	/* Calculate the actual/resulting baud rate */
+	if (B <= 8)
+		B = 512;
+	baud = 12000000 * 32 / ((1 << A) * B);
+
+	return baud;
+}
+
 static void pl2303_encode_baudrate(struct tty_struct *tty,
 					struct usb_serial_port *port,
+					enum pl2303_type type,
 					u8 buf[4])
 {
-	struct usb_serial *serial = port->serial;
-	struct pl2303_serial_private *spriv = usb_get_serial_data(serial);
 	int baud;
 
 	baud = tty_get_baud_rate(tty);
 	dev_dbg(&port->dev, "baud requested = %d\n", baud);
 	if (!baud)
 		return;
-
-	if (spriv->type != HX || baud <= 115200) {
-		/*
-		 * NOTE: Only the values defined in baud_sup are supported !
-		 *       => if unsupported values are set, the PL2303 seems to
-		 *	    use 9600 baud (at least my PL2303X always does)
-		 */
-		const int baud_sup[] = { 75, 150, 300, 600, 1200, 1800, 2400,
-					 3600, 4800, 7200, 9600, 14400, 19200,
-					 28800, 38400, 57600, 115200, 230400,
-					 460800, 614400, 921600, 1228800,
-					 2457600, 3000000, 6000000 };
-		int i;
-
-		/* Set baudrate to nearest supported value */
-		for (i = 0; i < ARRAY_SIZE(baud_sup); ++i) {
-			if (baud_sup[i] > baud)
-				break;
-		}
-
-		if (i == ARRAY_SIZE(baud_sup))
-			baud = baud_sup[i - 1];
-		else if (i > 0
-			     && (baud_sup[i] - baud) > (baud - baud_sup[i - 1]))
-			baud = baud_sup[i - 1];
-		else
-			baud = baud_sup[i];
-
-		/* type_0, type_1 only support up to 1228800 baud */
-		if (spriv->type != HX)
-			baud = min_t(int, baud, 1228800);
-
-		/* Direct (standard) baud rate encoding method */
-		put_unaligned_le32(baud, buf);
-	} else {
-		/*
-		 * Divisor based baud rate encoding method
-		 *
-		 * NOTE: it's not clear if the type_0/1 chips
-		 * support this method
-		 *
-		 * divisor = 12MHz * 32 / baudrate = 2^A * B
-		 *
-		 * with
-		 *
-		 * A = buf[1] & 0x0e
-		 * B = buf[0]  +  (buf[1] & 0x01) << 8
-		 *
-		 * Special cases:
-		 * => 8 < B < 16: device seems to work not properly
-		 * => B <= 8: device uses the max. value B = 512 instead
-		 */
-		unsigned int A, B;
-
-		/* Respect the specified baud rate limits */
-		baud = max_t(int, baud, 75);
-		if (spriv->type == HX)
-			baud = min_t(int, baud, 6000000);
-		else
-			baud = min_t(int, baud, 1228800);
-		/* Determine factors A and B */
-		A = 0;
-		B = 12000000 * 32 / baud;  /* 12MHz */
-		B <<= 1; /* Add one bit for rounding */
-		while (B > (512 << 1) && A <= 14) {
-			A += 2;
-			B >>= 2;
-		}
-		if (A > 14) { /* max. divisor = min. baudrate reached */
-			A = 14;
-			B = 512;
-			/* => ~45.78 baud */
-		} else {
-			B = (B + 1) >> 1; /* Round the last bit */
-		}
-		/* Handle special cases */
-		if (B == 512)
-			B = 0; /* also: 1 to 8 */
-		else if (B < 16)
-			/*
-			 * NOTE: With the current algorithm this happens
-			 * only for A=0 and means that the min. divisor
-			 * (respectively: the max. baudrate) is reached.
-			 */
-			B = 16;		/* => 24 MBaud */
-		/* Encode the baud rate */
-		buf[3] = 0x80;     /* Select divisor encoding method */
-		buf[2] = 0;
-		buf[1] = (A & 0x0e);		/* A */
-		buf[1] |= ((B & 0x100) >> 8);	/* MSB of B */
-		buf[0] = B & 0xff;		/* 8 LSBs of B */
-		/* Calculate the actual/resulting baud rate */
-		if (B <= 8)
-			B = 512;
-		baud = 12000000 * 32 / ((1 << A) * B);
-	}
-
+	/*
+	 * There are two methods for setting/encoding the baud rate
+	 * 1) Direct method: encodes the baud rate value directly
+	 *    => supported by all chip types
+	 * 2) Divisor based method: encodes a divisor to a base value (12MHz*32)
+	 *    => supported by HX chips (and likely not by type_0/1 chips)
+	 */
+	if (type != HX || baud <= 115200)
+		baud = pl2303_baudrate_encode_direct(baud, type, buf);
+	else
+		baud = pl2303_baudrate_encode_divisor(baud, type, buf);
 	/* Save resulting baud rate */
 	tty_encode_baud_rate(tty, baud, baud);
 	dev_dbg(&port->dev, "baud set = %d\n", baud);
@@ -434,8 +447,8 @@ static void pl2303_set_termios(struct tty_struct *tty,
 		dev_dbg(&port->dev, "data bits = %d\n", buf[6]);
 	}
 
-	/* For reference buf[0]:buf[3] baud rate value */
-	pl2303_encode_baudrate(tty, port, &buf[0]);
+	/* For reference:   buf[0]:buf[3] baud rate value */
+	pl2303_encode_baudrate(tty, port, spriv->type, buf);
 
 	/* For reference buf[4]=0 is 1 stop bits */
 	/* For reference buf[4]=1 is 1.5 stop bits */

commit b9208c721ce736125fe58d398319513a27850fd8
Author: Frank Schäfer <fschaefer.oss@googlemail.com>
Date:   Tue Aug 6 19:26:25 2013 +0200

    usb: pl2303: remove 500000 baud from the list of standard baud rates
    
    Commit 0c967e7e "USB: serial: pl2303 works at 500kbps" added 500000
    baud to the list of supported standard baud rates.
    But the reason why the driver works with this baud rate is, that since
    commit 8d48fdf6 "USB: PL2303: correctly handle baudrates above 115200"
    a second (divisor based) baud rate encoding method is used for values
    above 115200 baud, which is not limited to a fixed set of standard baud
    rates.
    
    Remove the 500000 baud value from the list of standard baud rates
    again, because this list is only used with the direct baud rate
    encoding method and 500000 baud is not supported with this method.
    
    Signed-off-by: Frank Schäfer <fschaefer.oss@googlemail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 04390dff926a..a0ea92ed35c6 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -291,8 +291,8 @@ static void pl2303_encode_baudrate(struct tty_struct *tty,
 		const int baud_sup[] = { 75, 150, 300, 600, 1200, 1800, 2400,
 					 3600, 4800, 7200, 9600, 14400, 19200,
 					 28800, 38400, 57600, 115200, 230400,
-					 460800, 500000, 614400, 921600,
-					 1228800, 2457600, 3000000, 6000000 };
+					 460800, 614400, 921600, 1228800,
+					 2457600, 3000000, 6000000 };
 		int i;
 
 		/* Set baudrate to nearest supported value */

commit 75417d9f99f89ab241de69d7db15af5842b488c4
Author: Frank Schäfer <fschaefer.oss@googlemail.com>
Date:   Tue Aug 6 19:26:24 2013 +0200

    usb: pl2303: do not round to the next nearest standard baud rate for the divisor based baud rate encoding method
    
    In opposition to the direct baud rate encoding method, the divisor
    based method is not limited to a fixed set of standard baud rates.
    Hence, there is no need to round to the next nearest standard value.
    
    Reported-by: Mastro Gippo <gipmad@gmail.com>
    Signed-off-by: Frank Schäfer <fschaefer.oss@googlemail.com>
    Signed-off-by: Reinhard Max <max@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index b93b3b30dec5..04390dff926a 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -273,44 +273,46 @@ static void pl2303_encode_baudrate(struct tty_struct *tty,
 					struct usb_serial_port *port,
 					u8 buf[4])
 {
-	const int baud_sup[] = { 75, 150, 300, 600, 1200, 1800, 2400, 3600,
-	                         4800, 7200, 9600, 14400, 19200, 28800, 38400,
-	                         57600, 115200, 230400, 460800, 500000, 614400,
-	                         921600, 1228800, 2457600, 3000000, 6000000 };
-
 	struct usb_serial *serial = port->serial;
 	struct pl2303_serial_private *spriv = usb_get_serial_data(serial);
 	int baud;
-	int i;
 
-	/*
-	 * NOTE: Only the values defined in baud_sup are supported!
-	 *       => if unsupported values are set, the PL2303 seems to use
-	 *          9600 baud (at least my PL2303X always does)
-	 */
 	baud = tty_get_baud_rate(tty);
 	dev_dbg(&port->dev, "baud requested = %d\n", baud);
 	if (!baud)
 		return;
 
-	/* Set baudrate to nearest supported value */
-	for (i = 0; i < ARRAY_SIZE(baud_sup); ++i) {
-		if (baud_sup[i] > baud)
-			break;
-	}
+	if (spriv->type != HX || baud <= 115200) {
+		/*
+		 * NOTE: Only the values defined in baud_sup are supported !
+		 *       => if unsupported values are set, the PL2303 seems to
+		 *	    use 9600 baud (at least my PL2303X always does)
+		 */
+		const int baud_sup[] = { 75, 150, 300, 600, 1200, 1800, 2400,
+					 3600, 4800, 7200, 9600, 14400, 19200,
+					 28800, 38400, 57600, 115200, 230400,
+					 460800, 500000, 614400, 921600,
+					 1228800, 2457600, 3000000, 6000000 };
+		int i;
+
+		/* Set baudrate to nearest supported value */
+		for (i = 0; i < ARRAY_SIZE(baud_sup); ++i) {
+			if (baud_sup[i] > baud)
+				break;
+		}
 
-	if (i == ARRAY_SIZE(baud_sup))
-		baud = baud_sup[i - 1];
-	else if (i > 0 && (baud_sup[i] - baud) > (baud - baud_sup[i - 1]))
-		baud = baud_sup[i - 1];
-	else
-		baud = baud_sup[i];
+		if (i == ARRAY_SIZE(baud_sup))
+			baud = baud_sup[i - 1];
+		else if (i > 0
+			     && (baud_sup[i] - baud) > (baud - baud_sup[i - 1]))
+			baud = baud_sup[i - 1];
+		else
+			baud = baud_sup[i];
 
-	/* type_0, type_1 only support up to 1228800 baud */
-	if (spriv->type != HX)
-		baud = min_t(int, baud, 1228800);
+		/* type_0, type_1 only support up to 1228800 baud */
+		if (spriv->type != HX)
+			baud = min_t(int, baud, 1228800);
 
-	if (spriv->type != HX || baud <= 115200) {
 		/* Direct (standard) baud rate encoding method */
 		put_unaligned_le32(baud, buf);
 	} else {
@@ -331,10 +333,17 @@ static void pl2303_encode_baudrate(struct tty_struct *tty,
 		 * => 8 < B < 16: device seems to work not properly
 		 * => B <= 8: device uses the max. value B = 512 instead
 		 */
+		unsigned int A, B;
 
+		/* Respect the specified baud rate limits */
+		baud = max_t(int, baud, 75);
+		if (spriv->type == HX)
+			baud = min_t(int, baud, 6000000);
+		else
+			baud = min_t(int, baud, 1228800);
 		/* Determine factors A and B */
-		unsigned int A = 0;
-		unsigned int B = 12000000 * 32 / baud;  /* 12MHz */
+		A = 0;
+		B = 12000000 * 32 / baud;  /* 12MHz */
 		B <<= 1; /* Add one bit for rounding */
 		while (B > (512 << 1) && A <= 14) {
 			A += 2;

commit 57ce61aad748ceaa08c859da04043ad7dae7c15e
Author: Frank Schäfer <fschaefer.oss@googlemail.com>
Date:   Tue Aug 6 19:26:23 2013 +0200

    usb: pl2303: fix+improve the divsor based baud rate encoding method
    
    Based on the formula in the code description, Reinhard Max and me have
    investigated the devices behavior / functional principle of the divisor
    based baud rate encoding method.
    
    It turned out, that (although beeing a good starting point) the current
    code has some flaws. It doesn't work correctly for a wide range of baud
    rates and the divisor resolution can be improved. It also doesn't
    report the actually set baud rate.
    
    This patch fixes and improves the code for the divisor based baud rate
    encoding method a lot. It can now be used for the whole range of baud
    rates from 46 baud to 24M baud with a very good divisor resolution and
    userspace can read back the resulting baud rate.
    
    It also documents the formula used for encoding and the hardware
    behavior (including special cases).
    
    The basic algorithm, rounding and several code comments/explanations
    are provided by Reinhard Max.
    I've added some minor fixes, the handling of the special cases and
    further code/algorithm descriptions.
    
    Signed-off-by: Frank Schäfer <fschaefer.oss@googlemail.com>
    Signed-off-by: Reinhard Max <max@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 244820193e10..b93b3b30dec5 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -4,6 +4,11 @@
  * Copyright (C) 2001-2007 Greg Kroah-Hartman (greg@kroah.com)
  * Copyright (C) 2003 IBM Corp.
  *
+ * Copyright (C) 2009, 2013 Frank Schäfer <fschaefer.oss@googlemail.com>
+ *  - fixes, improvements and documentation for the baud rate encoding methods
+ * Copyright (C) 2013 Reinhard Max <max@suse.de>
+ *  - fixes and improvements for the divisor based baud rate encoding method
+ *
  * Original driver for 2.2.x by anonymous
  *
  *	This program is free software; you can redistribute it and/or
@@ -310,21 +315,58 @@ static void pl2303_encode_baudrate(struct tty_struct *tty,
 		put_unaligned_le32(baud, buf);
 	} else {
 		/*
+		 * Divisor based baud rate encoding method
+		 *
 		 * NOTE: it's not clear if the type_0/1 chips
 		 * support this method
 		 *
-		 * Apparently the formula for higher speeds is:
-		 * baudrate = 12M * 32 / (2^buf[1]) / buf[0]
+		 * divisor = 12MHz * 32 / baudrate = 2^A * B
+		 *
+		 * with
+		 *
+		 * A = buf[1] & 0x0e
+		 * B = buf[0]  +  (buf[1] & 0x01) << 8
+		 *
+		 * Special cases:
+		 * => 8 < B < 16: device seems to work not properly
+		 * => B <= 8: device uses the max. value B = 512 instead
 		 */
-		unsigned tmp = 12000000 * 32 / baud;
-		buf[3] = 0x80;
-		buf[2] = 0;
-		buf[1] = (tmp >= 256);
-		while (tmp >= 256) {
-			tmp >>= 2;
-			buf[1] <<= 1;
+
+		/* Determine factors A and B */
+		unsigned int A = 0;
+		unsigned int B = 12000000 * 32 / baud;  /* 12MHz */
+		B <<= 1; /* Add one bit for rounding */
+		while (B > (512 << 1) && A <= 14) {
+			A += 2;
+			B >>= 2;
 		}
-		buf[0] = tmp;
+		if (A > 14) { /* max. divisor = min. baudrate reached */
+			A = 14;
+			B = 512;
+			/* => ~45.78 baud */
+		} else {
+			B = (B + 1) >> 1; /* Round the last bit */
+		}
+		/* Handle special cases */
+		if (B == 512)
+			B = 0; /* also: 1 to 8 */
+		else if (B < 16)
+			/*
+			 * NOTE: With the current algorithm this happens
+			 * only for A=0 and means that the min. divisor
+			 * (respectively: the max. baudrate) is reached.
+			 */
+			B = 16;		/* => 24 MBaud */
+		/* Encode the baud rate */
+		buf[3] = 0x80;     /* Select divisor encoding method */
+		buf[2] = 0;
+		buf[1] = (A & 0x0e);		/* A */
+		buf[1] |= ((B & 0x100) >> 8);	/* MSB of B */
+		buf[0] = B & 0xff;		/* 8 LSBs of B */
+		/* Calculate the actual/resulting baud rate */
+		if (B <= 8)
+			B = 512;
+		baud = 12000000 * 32 / ((1 << A) * B);
 	}
 
 	/* Save resulting baud rate */

commit b8bdad608213caffa081a97d2e937e5fe08c4046
Author: Frank Schäfer <fschaefer.oss@googlemail.com>
Date:   Tue Jul 30 21:49:04 2013 +0200

    USB: pl2303: restrict the divisor based baud rate encoding method to the "HX" chip type
    
    It's not clear if the type_0 and type_1 chips support the divisor based baud
    rate encoding method, so don't use it until anyone with such chip has tested it
    to avoid regressions with the following patches.
    
    Even if it has been working fine with these chips since the code has been added
    2 years ago, this change will not cause any regressions, because the baud rates
    currently supported/allowed with the divisor based method are supported with
    the direct method, too.
    
    The code for the divisor based method also isn't entirely correct (yet), so that the
    direct encoding method actually works better (sets the baud rate more precisely).
    
    Signed-off-by: Frank Schäfer <fschaefer.oss@googlemail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 1e6de4cd079d..244820193e10 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -305,10 +305,14 @@ static void pl2303_encode_baudrate(struct tty_struct *tty,
 	if (spriv->type != HX)
 		baud = min_t(int, baud, 1228800);
 
-	if (baud <= 115200) {
+	if (spriv->type != HX || baud <= 115200) {
+		/* Direct (standard) baud rate encoding method */
 		put_unaligned_le32(baud, buf);
 	} else {
 		/*
+		 * NOTE: it's not clear if the type_0/1 chips
+		 * support this method
+		 *
 		 * Apparently the formula for higher speeds is:
 		 * baudrate = 12M * 32 / (2^buf[1]) / buf[0]
 		 */

commit 02f00c4a9183ebf15aa50e57391b0f44e2f092c2
Author: Frank Schäfer <fschaefer.oss@googlemail.com>
Date:   Mon Jul 29 18:33:22 2013 +0200

    USB: serial: pl2303: fix the upper baud rate limit check for type_0/1 chips
    
    Fixes the following regression that has been introduced recently with
    commit b2d6d98fc7:
    With type_0 and type_1 chips
    - all baud rates < 1228800 baud are rounded up to 1228800 baud
    - the device silently runs at 9600 baud for all baud rates > 1228800
      baud
    
    Signed-off-by: Frank Schäfer <fschaefer.oss@googlemail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 299a0ffcb165..1e6de4cd079d 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -303,7 +303,7 @@ static void pl2303_encode_baudrate(struct tty_struct *tty,
 
 	/* type_0, type_1 only support up to 1228800 baud */
 	if (spriv->type != HX)
-		baud = max_t(int, baud, 1228800);
+		baud = min_t(int, baud, 1228800);
 
 	if (baud <= 115200) {
 		put_unaligned_le32(baud, buf);

commit 3ba19fe31b726371b45f91a8de9341f5625e75e4
Author: Johan Hovold <jhovold@gmail.com>
Date:   Wed Jun 26 16:47:30 2013 +0200

    USB: pl2303: remove debugging noise
    
    Only log the tty_flags in process_read_urb on errors.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 91f14c6950f9..299a0ffcb165 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -790,8 +790,10 @@ static void pl2303_process_read_urb(struct urb *urb)
 		tty_flag = TTY_PARITY;
 	else if (line_status & UART_FRAME_ERROR)
 		tty_flag = TTY_FRAME;
-	dev_dbg(&port->dev, "%s - tty_flag = %d\n", __func__, tty_flag);
 
+	if (tty_flag != TTY_NORMAL)
+		dev_dbg(&port->dev, "%s - tty_flag = %d\n", __func__,
+								tty_flag);
 	/* overrun is special, not associated with a char */
 	if (line_status & UART_OVERRUN_ERROR)
 		tty_insert_flip_char(&port->port, 0, TTY_OVERRUN);

commit 87265b4514f5a0b79efdccdcb1c6331285652640
Author: Johan Hovold <jhovold@gmail.com>
Date:   Wed Jun 26 16:47:29 2013 +0200

    USB: pl2303: clean up set_termios
    
    Clean up set_termios somewhat.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index dd59c640edcc..91f14c6950f9 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -335,20 +335,18 @@ static void pl2303_set_termios(struct tty_struct *tty,
 	struct pl2303_serial_private *spriv = usb_get_serial_data(serial);
 	struct pl2303_private *priv = usb_get_serial_port_data(port);
 	unsigned long flags;
-	unsigned int cflag;
 	unsigned char *buf;
 	int i;
 	u8 control;
 
-	/* The PL2303 is reported to lose bytes if you change
-	   serial settings even to the same values as before. Thus
-	   we actually need to filter in this specific case */
-
+	/*
+	 * The PL2303 is reported to lose bytes if you change serial settings
+	 * even to the same values as before. Thus we actually need to filter
+	 * in this specific case.
+	 */
 	if (old_termios && !tty_termios_hw_change(&tty->termios, old_termios))
 		return;
 
-	cflag = tty->termios.c_cflag;
-
 	buf = kzalloc(7, GFP_KERNEL);
 	if (!buf) {
 		dev_err(&port->dev, "%s - out of memory.\n", __func__);
@@ -363,8 +361,8 @@ static void pl2303_set_termios(struct tty_struct *tty,
 			    0, 0, buf, 7, 100);
 	dev_dbg(&port->dev, "0xa1:0x21:0:0  %d - %7ph\n", i, buf);
 
-	if (cflag & CSIZE) {
-		switch (cflag & CSIZE) {
+	if (C_CSIZE(tty)) {
+		switch (C_CSIZE(tty)) {
 		case CS5:
 			buf[6] = 5;
 			break;
@@ -377,7 +375,6 @@ static void pl2303_set_termios(struct tty_struct *tty,
 		default:
 		case CS8:
 			buf[6] = 8;
-			break;
 		}
 		dev_dbg(&port->dev, "data bits = %d\n", buf[6]);
 	}
@@ -388,11 +385,12 @@ static void pl2303_set_termios(struct tty_struct *tty,
 	/* For reference buf[4]=0 is 1 stop bits */
 	/* For reference buf[4]=1 is 1.5 stop bits */
 	/* For reference buf[4]=2 is 2 stop bits */
-	if (cflag & CSTOPB) {
-		/* NOTE: Comply with "real" UARTs / RS232:
+	if (C_CSTOPB(tty)) {
+		/*
+		 * NOTE: Comply with "real" UARTs / RS232:
 		 *       use 1.5 instead of 2 stop bits with 5 data bits
 		 */
-		if ((cflag & CSIZE) == CS5) {
+		if (C_CSIZE(tty) == CS5) {
 			buf[4] = 1;
 			dev_dbg(&port->dev, "stop bits = 1.5\n");
 		} else {
@@ -404,14 +402,14 @@ static void pl2303_set_termios(struct tty_struct *tty,
 		dev_dbg(&port->dev, "stop bits = 1\n");
 	}
 
-	if (cflag & PARENB) {
+	if (C_PARENB(tty)) {
 		/* For reference buf[5]=0 is none parity */
 		/* For reference buf[5]=1 is odd parity */
 		/* For reference buf[5]=2 is even parity */
 		/* For reference buf[5]=3 is mark parity */
 		/* For reference buf[5]=4 is space parity */
-		if (cflag & PARODD) {
-			if (cflag & CMSPAR) {
+		if (C_PARODD(tty)) {
+			if (tty->termios.c_cflag & CMSPAR) {
 				buf[5] = 3;
 				dev_dbg(&port->dev, "parity = mark\n");
 			} else {
@@ -419,7 +417,7 @@ static void pl2303_set_termios(struct tty_struct *tty,
 				dev_dbg(&port->dev, "parity = odd\n");
 			}
 		} else {
-			if (cflag & CMSPAR) {
+			if (tty->termios.c_cflag & CMSPAR) {
 				buf[5] = 4;
 				dev_dbg(&port->dev, "parity = space\n");
 			} else {
@@ -440,7 +438,7 @@ static void pl2303_set_termios(struct tty_struct *tty,
 	/* change control lines if we are switching to or from B0 */
 	spin_lock_irqsave(&priv->lock, flags);
 	control = priv->line_control;
-	if ((cflag & CBAUD) == B0)
+	if (C_BAUD(tty) == B0)
 		priv->line_control &= ~(CONTROL_DTR | CONTROL_RTS);
 	else if (old_termios && (old_termios->c_cflag & CBAUD) == B0)
 		priv->line_control |= (CONTROL_DTR | CONTROL_RTS);
@@ -452,14 +450,13 @@ static void pl2303_set_termios(struct tty_struct *tty,
 		spin_unlock_irqrestore(&priv->lock, flags);
 	}
 
-	buf[0] = buf[1] = buf[2] = buf[3] = buf[4] = buf[5] = buf[6] = 0;
-
+	memset(buf, 0, 7);
 	i = usb_control_msg(serial->dev, usb_rcvctrlpipe(serial->dev, 0),
 			    GET_LINE_REQUEST, GET_LINE_REQUEST_TYPE,
 			    0, 0, buf, 7, 100);
 	dev_dbg(&port->dev, "0xa1:0x21:0:0  %d - %7ph\n", i, buf);
 
-	if (cflag & CRTSCTS) {
+	if (C_CRTSCTS(tty)) {
 		if (spriv->type == HX)
 			pl2303_vendor_write(0x0, 0x61, serial);
 		else

commit b2d6d98fc71bb94ada78d433f26a93498802d3f8
Author: Johan Hovold <jhovold@gmail.com>
Date:   Wed Jun 26 16:47:28 2013 +0200

    USB: pl2303: clean up baud-rate handling
    
    Clean up baud-rate handling somewhat.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index c15d64d6e1e7..dd59c640edcc 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -29,6 +29,7 @@
 #include <linux/uaccess.h>
 #include <linux/usb.h>
 #include <linux/usb/serial.h>
+#include <asm/unaligned.h>
 #include "pl2303.h"
 
 /*
@@ -275,65 +276,56 @@ static void pl2303_encode_baudrate(struct tty_struct *tty,
 	struct usb_serial *serial = port->serial;
 	struct pl2303_serial_private *spriv = usb_get_serial_data(serial);
 	int baud;
-	int baud_floor, baud_ceil;
-	int k;
+	int i;
 
-	/* NOTE: Only the values defined in baud_sup are supported !
+	/*
+	 * NOTE: Only the values defined in baud_sup are supported!
 	 *       => if unsupported values are set, the PL2303 seems to use
 	 *          9600 baud (at least my PL2303X always does)
 	 */
 	baud = tty_get_baud_rate(tty);
 	dev_dbg(&port->dev, "baud requested = %d\n", baud);
-	if (baud) {
-		/* Set baudrate to nearest supported value */
-		for (k=0; k<ARRAY_SIZE(baud_sup); k++) {
-			if (baud_sup[k] / baud) {
-				baud_ceil = baud_sup[k];
-				if (k==0) {
-					baud = baud_ceil;
-				} else {
-					baud_floor = baud_sup[k-1];
-					if ((baud_ceil % baud)
-					    > (baud % baud_floor))
-						baud = baud_floor;
-					else
-						baud = baud_ceil;
-				}
-				break;
-			}
-		}
-		if (baud > 1228800) {
-			/* type_0, type_1 only support up to 1228800 baud */
-			if (spriv->type != HX)
-				baud = 1228800;
-			else if (baud > 6000000)
-				baud = 6000000;
-		}
-		dev_dbg(&port->dev, "baud set = %d\n", baud);
-		if (baud <= 115200) {
-			buf[0] = baud & 0xff;
-			buf[1] = (baud >> 8) & 0xff;
-			buf[2] = (baud >> 16) & 0xff;
-			buf[3] = (baud >> 24) & 0xff;
-		} else {
-			/* apparently the formula for higher speeds is:
-			 * baudrate = 12M * 32 / (2^buf[1]) / buf[0]
-			 */
-			unsigned tmp = 12*1000*1000*32 / baud;
-			buf[3] = 0x80;
-			buf[2] = 0;
-			buf[1] = (tmp >= 256);
-			while (tmp >= 256) {
-				tmp >>= 2;
-				buf[1] <<= 1;
-			}
-			buf[0] = tmp;
+	if (!baud)
+		return;
+
+	/* Set baudrate to nearest supported value */
+	for (i = 0; i < ARRAY_SIZE(baud_sup); ++i) {
+		if (baud_sup[i] > baud)
+			break;
+	}
+
+	if (i == ARRAY_SIZE(baud_sup))
+		baud = baud_sup[i - 1];
+	else if (i > 0 && (baud_sup[i] - baud) > (baud - baud_sup[i - 1]))
+		baud = baud_sup[i - 1];
+	else
+		baud = baud_sup[i];
+
+	/* type_0, type_1 only support up to 1228800 baud */
+	if (spriv->type != HX)
+		baud = max_t(int, baud, 1228800);
+
+	if (baud <= 115200) {
+		put_unaligned_le32(baud, buf);
+	} else {
+		/*
+		 * Apparently the formula for higher speeds is:
+		 * baudrate = 12M * 32 / (2^buf[1]) / buf[0]
+		 */
+		unsigned tmp = 12000000 * 32 / baud;
+		buf[3] = 0x80;
+		buf[2] = 0;
+		buf[1] = (tmp >= 256);
+		while (tmp >= 256) {
+			tmp >>= 2;
+			buf[1] <<= 1;
 		}
+		buf[0] = tmp;
 	}
 
 	/* Save resulting baud rate */
-	if (baud)
-		tty_encode_baud_rate(tty, baud, baud);
+	tty_encode_baud_rate(tty, baud, baud);
+	dev_dbg(&port->dev, "baud set = %d\n", baud);
 }
 
 static void pl2303_set_termios(struct tty_struct *tty,

commit 15e7cead1ed89d445cf86c75a72368e98a7a9039
Author: Johan Hovold <jhovold@gmail.com>
Date:   Wed Jun 26 16:47:27 2013 +0200

    USB: pl2303: refactor baud-rate handling
    
    Break out baud-rate handling from set_termios.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index ed9edb2e1849..c15d64d6e1e7 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -263,68 +263,21 @@ static int pl2303_set_control_lines(struct usb_serial_port *port, u8 value)
 	return retval;
 }
 
-static void pl2303_set_termios(struct tty_struct *tty,
-		struct usb_serial_port *port, struct ktermios *old_termios)
+static void pl2303_encode_baudrate(struct tty_struct *tty,
+					struct usb_serial_port *port,
+					u8 buf[4])
 {
-	struct usb_serial *serial = port->serial;
-	struct pl2303_serial_private *spriv = usb_get_serial_data(serial);
-	struct pl2303_private *priv = usb_get_serial_port_data(port);
-	unsigned long flags;
-	unsigned int cflag;
-	unsigned char *buf;
-	int baud;
-	int i;
-	u8 control;
 	const int baud_sup[] = { 75, 150, 300, 600, 1200, 1800, 2400, 3600,
 	                         4800, 7200, 9600, 14400, 19200, 28800, 38400,
 	                         57600, 115200, 230400, 460800, 500000, 614400,
 	                         921600, 1228800, 2457600, 3000000, 6000000 };
+
+	struct usb_serial *serial = port->serial;
+	struct pl2303_serial_private *spriv = usb_get_serial_data(serial);
+	int baud;
 	int baud_floor, baud_ceil;
 	int k;
 
-	/* The PL2303 is reported to lose bytes if you change
-	   serial settings even to the same values as before. Thus
-	   we actually need to filter in this specific case */
-
-	if (old_termios && !tty_termios_hw_change(&tty->termios, old_termios))
-		return;
-
-	cflag = tty->termios.c_cflag;
-
-	buf = kzalloc(7, GFP_KERNEL);
-	if (!buf) {
-		dev_err(&port->dev, "%s - out of memory.\n", __func__);
-		/* Report back no change occurred */
-		if (old_termios)
-			tty->termios = *old_termios;
-		return;
-	}
-
-	i = usb_control_msg(serial->dev, usb_rcvctrlpipe(serial->dev, 0),
-			    GET_LINE_REQUEST, GET_LINE_REQUEST_TYPE,
-			    0, 0, buf, 7, 100);
-	dev_dbg(&port->dev, "0xa1:0x21:0:0  %d - %7ph\n", i, buf);
-
-	if (cflag & CSIZE) {
-		switch (cflag & CSIZE) {
-		case CS5:
-			buf[6] = 5;
-			break;
-		case CS6:
-			buf[6] = 6;
-			break;
-		case CS7:
-			buf[6] = 7;
-			break;
-		default:
-		case CS8:
-			buf[6] = 8;
-			break;
-		}
-		dev_dbg(&port->dev, "data bits = %d\n", buf[6]);
-	}
-
-	/* For reference buf[0]:buf[3] baud rate value */
 	/* NOTE: Only the values defined in baud_sup are supported !
 	 *       => if unsupported values are set, the PL2303 seems to use
 	 *          9600 baud (at least my PL2303X always does)
@@ -378,6 +331,68 @@ static void pl2303_set_termios(struct tty_struct *tty,
 		}
 	}
 
+	/* Save resulting baud rate */
+	if (baud)
+		tty_encode_baud_rate(tty, baud, baud);
+}
+
+static void pl2303_set_termios(struct tty_struct *tty,
+		struct usb_serial_port *port, struct ktermios *old_termios)
+{
+	struct usb_serial *serial = port->serial;
+	struct pl2303_serial_private *spriv = usb_get_serial_data(serial);
+	struct pl2303_private *priv = usb_get_serial_port_data(port);
+	unsigned long flags;
+	unsigned int cflag;
+	unsigned char *buf;
+	int i;
+	u8 control;
+
+	/* The PL2303 is reported to lose bytes if you change
+	   serial settings even to the same values as before. Thus
+	   we actually need to filter in this specific case */
+
+	if (old_termios && !tty_termios_hw_change(&tty->termios, old_termios))
+		return;
+
+	cflag = tty->termios.c_cflag;
+
+	buf = kzalloc(7, GFP_KERNEL);
+	if (!buf) {
+		dev_err(&port->dev, "%s - out of memory.\n", __func__);
+		/* Report back no change occurred */
+		if (old_termios)
+			tty->termios = *old_termios;
+		return;
+	}
+
+	i = usb_control_msg(serial->dev, usb_rcvctrlpipe(serial->dev, 0),
+			    GET_LINE_REQUEST, GET_LINE_REQUEST_TYPE,
+			    0, 0, buf, 7, 100);
+	dev_dbg(&port->dev, "0xa1:0x21:0:0  %d - %7ph\n", i, buf);
+
+	if (cflag & CSIZE) {
+		switch (cflag & CSIZE) {
+		case CS5:
+			buf[6] = 5;
+			break;
+		case CS6:
+			buf[6] = 6;
+			break;
+		case CS7:
+			buf[6] = 7;
+			break;
+		default:
+		case CS8:
+			buf[6] = 8;
+			break;
+		}
+		dev_dbg(&port->dev, "data bits = %d\n", buf[6]);
+	}
+
+	/* For reference buf[0]:buf[3] baud rate value */
+	pl2303_encode_baudrate(tty, port, &buf[0]);
+
 	/* For reference buf[4]=0 is 1 stop bits */
 	/* For reference buf[4]=1 is 1.5 stop bits */
 	/* For reference buf[4]=2 is 2 stop bits */
@@ -461,10 +476,6 @@ static void pl2303_set_termios(struct tty_struct *tty,
 		pl2303_vendor_write(0x0, 0x0, serial);
 	}
 
-	/* Save resulting baud rate */
-	if (baud)
-		tty_encode_baud_rate(tty, baud, baud);
-
 	kfree(buf);
 }
 

commit d7be62211125c85fa1dd796e92aadce84961a502
Author: Johan Hovold <jhovold@gmail.com>
Date:   Wed Jun 26 16:47:23 2013 +0200

    USB: serial: set drain delay at port probe
    
    The port drain delay is constant and should be set at port probe rather
    than open.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index cb6bbed374f2..ed9edb2e1849 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -235,6 +235,8 @@ static int pl2303_port_probe(struct usb_serial_port *port)
 
 	usb_set_serial_port_data(port, priv);
 
+	port->port.drain_delay = 256;
+
 	return 0;
 }
 
@@ -521,7 +523,6 @@ static int pl2303_open(struct tty_struct *tty, struct usb_serial_port *port)
 		return result;
 	}
 
-	port->port.drain_delay = 256;
 	return 0;
 }
 

commit e5b1e2062e0535e8ffef79bb34d857e21380d101
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Jun 7 11:04:28 2013 -0700

    USB: serial: make minor allocation dynamic
    
    This moves the allocation of minor device numbers from a static array to
    be dynamic, using the idr interface.  This means that you could
    potentially get "gaps" in a minor number range for a single USB serial
    device with multiple ports, but all should still work properly.
    
    We remove the 'minor' field from the usb_serial structure, as it no
    longer makes any sense for it (use the field in the usb_serial_port
    structure if you really want to know this number), and take the fact
    that we were overloading a number in this field to determine if we had
    initialized the minor numbers or not, and just use a flag variable
    instead.
    
    Note, we still have the limitation of 255 USB to serial devices in the
    system, as that is all we are registering with the TTY layer at this
    point in time.
    
    Tested-by: Tobias Winter <tobias@linuxdingsda.de>
    Reviewed-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 042ae6be3cbe..cb6bbed374f2 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -639,7 +639,7 @@ static int pl2303_ioctl(struct tty_struct *tty,
 	case TIOCGSERIAL:
 		memset(&ser, 0, sizeof ser);
 		ser.type = PORT_16654;
-		ser.line = port->serial->minor;
+		ser.line = port->minor;
 		ser.port = port->port_number;
 		ser.baud_base = 460800;
 

commit 1508124d8a4e0995362d93d82e5555a74bfc998f
Merge: 976f8bef9cfb 7d132055814e
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Jun 17 12:02:38 2013 -0700

    Merge 3.10-rc6 into usb-next
    
    We want the fixes in this branch as well.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 1143832eca8f1d64da7d85642c956ae9d25c69e1
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu Jun 6 10:32:00 2013 -0700

    USB: serial: ports: add minor and port number
    
    The usb_serial_port structure had the number field, which was the minor
    number for the port, which almost no one really cared about.  They
    really wanted the number of the port within the device, which you had to
    subtract from the minor of the parent usb_serial_device structure.  To
    clean this up, provide the real minor number of the port, and the number
    of the port within the serial device separately, as these numbers might
    not be related in the future.
    
    Bonus is that this cleans up a lot of logic in the drivers, and saves
    lines overall.
    
    Tested-by: Tobias Winter <tobias@linuxdingsda.de>
    Reviewed-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    
    --
     drivers/staging/serqt_usb2/serqt_usb2.c |   21 +++--------
     drivers/usb/serial/ark3116.c            |    2 -
     drivers/usb/serial/bus.c                |    6 +--
     drivers/usb/serial/console.c            |    2 -
     drivers/usb/serial/cp210x.c             |    2 -
     drivers/usb/serial/cypress_m8.c         |    4 +-
     drivers/usb/serial/digi_acceleport.c    |    6 ---
     drivers/usb/serial/f81232.c             |    5 +-
     drivers/usb/serial/garmin_gps.c         |    6 +--
     drivers/usb/serial/io_edgeport.c        |   58 ++++++++++++--------------------
     drivers/usb/serial/io_ti.c              |   21 ++++-------
     drivers/usb/serial/keyspan.c            |   29 +++++++---------
     drivers/usb/serial/metro-usb.c          |    4 +-
     drivers/usb/serial/mos7720.c            |   37 +++++++++-----------
     drivers/usb/serial/mos7840.c            |   52 +++++++++-------------------
     drivers/usb/serial/opticon.c            |    2 -
     drivers/usb/serial/pl2303.c             |    2 -
     drivers/usb/serial/quatech2.c           |    7 +--
     drivers/usb/serial/sierra.c             |    2 -
     drivers/usb/serial/ti_usb_3410_5052.c   |   10 ++---
     drivers/usb/serial/usb-serial.c         |    7 ++-
     drivers/usb/serial/usb_wwan.c           |    2 -
     drivers/usb/serial/whiteheat.c          |   20 +++++------
     include/linux/usb/serial.h              |    6 ++-
     24 files changed, 133 insertions(+), 180 deletions(-)

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 97c1e6a9dd4f..966c20c9ced4 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -640,7 +640,7 @@ static int pl2303_ioctl(struct tty_struct *tty,
 		memset(&ser, 0, sizeof ser);
 		ser.type = PORT_16654;
 		ser.line = port->serial->minor;
-		ser.port = port->number;
+		ser.port = port->port_number;
 		ser.baud_base = 460800;
 
 		if (copy_to_user((void __user *)arg, &ser, sizeof ser))

commit 2d8f4447b58bba5f8cb895c07690434c02307eaf
Author: Johan Hovold <jhovold@gmail.com>
Date:   Mon Jun 10 18:29:38 2013 +0200

    USB: pl2303: fix device initialisation at open
    
    Do not use uninitialised termios data to determine when to configure the
    device at open.
    
    This also prevents stack data from leaking to userspace in the OOM error
    path.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 7151659367a0..048cd44d51b1 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -284,7 +284,7 @@ static void pl2303_set_termios(struct tty_struct *tty,
 	   serial settings even to the same values as before. Thus
 	   we actually need to filter in this specific case */
 
-	if (!tty_termios_hw_change(&tty->termios, old_termios))
+	if (old_termios && !tty_termios_hw_change(&tty->termios, old_termios))
 		return;
 
 	cflag = tty->termios.c_cflag;
@@ -293,7 +293,8 @@ static void pl2303_set_termios(struct tty_struct *tty,
 	if (!buf) {
 		dev_err(&port->dev, "%s - out of memory.\n", __func__);
 		/* Report back no change occurred */
-		tty->termios = *old_termios;
+		if (old_termios)
+			tty->termios = *old_termios;
 		return;
 	}
 
@@ -433,7 +434,7 @@ static void pl2303_set_termios(struct tty_struct *tty,
 	control = priv->line_control;
 	if ((cflag & CBAUD) == B0)
 		priv->line_control &= ~(CONTROL_DTR | CONTROL_RTS);
-	else if ((old_termios->c_cflag & CBAUD) == B0)
+	else if (old_termios && (old_termios->c_cflag & CBAUD) == B0)
 		priv->line_control |= (CONTROL_DTR | CONTROL_RTS);
 	if (control != priv->line_control) {
 		control = priv->line_control;
@@ -492,7 +493,6 @@ static void pl2303_close(struct usb_serial_port *port)
 
 static int pl2303_open(struct tty_struct *tty, struct usb_serial_port *port)
 {
-	struct ktermios tmp_termios;
 	struct usb_serial *serial = port->serial;
 	struct pl2303_serial_private *spriv = usb_get_serial_data(serial);
 	int result;
@@ -508,7 +508,7 @@ static int pl2303_open(struct tty_struct *tty, struct usb_serial_port *port)
 
 	/* Setup termios */
 	if (tty)
-		pl2303_set_termios(tty, port, &tmp_termios);
+		pl2303_set_termios(tty, port, NULL);
 
 	result = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);
 	if (result) {

commit 0c967e7ecdc2cf42853b4c76f0b2e94ba53c5b92
Author: Luca Olivetti <luca@ventoso.org>
Date:   Tue May 21 13:31:31 2013 +0200

    USB: serial: pl2303 works at 500kbps
    
    My PL2303HX works at 500kbps after applying this patch.
    I suppose that it could work at other non standard speeds since this fix
    
    "correctly handle baudrates above 115200"
    https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/drivers/usb/serial/pl2303.c?id=8d48fdf689fed2c73c493e5146d1463689246442
    
    came after this one
    
    "fix baud rate handling in case of unsupported values"
    https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/drivers/usb/serial/pl2303.c?id=25b8286805e856c8c7fda127018e31032c918015
    
    but I only can test it with 500000.
    Patch made against mainline but tested with 3.4.45
    
    Signed-off-by: Luca Olivetti <luca@ventoso.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index dc74c25b383d..97c1e6a9dd4f 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -275,7 +275,7 @@ static void pl2303_set_termios(struct tty_struct *tty,
 	u8 control;
 	const int baud_sup[] = { 75, 150, 300, 600, 1200, 1800, 2400, 3600,
 	                         4800, 7200, 9600, 14400, 19200, 28800, 38400,
-	                         57600, 115200, 230400, 460800, 614400,
+	                         57600, 115200, 230400, 460800, 500000, 614400,
 	                         921600, 1228800, 2457600, 3000000, 6000000 };
 	int baud_floor, baud_ceil;
 	int k;

commit 715cf92aeb061c47f7170d0d7899311b7597bc66
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue May 28 12:49:17 2013 +0300

    usb: serial: dump small buffers with help of %*ph
    
    There is a specifier we may use to dump small buffers.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 7151659367a0..dc74c25b383d 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -300,8 +300,7 @@ static void pl2303_set_termios(struct tty_struct *tty,
 	i = usb_control_msg(serial->dev, usb_rcvctrlpipe(serial->dev, 0),
 			    GET_LINE_REQUEST, GET_LINE_REQUEST_TYPE,
 			    0, 0, buf, 7, 100);
-	dev_dbg(&port->dev, "0xa1:0x21:0:0  %d - %x %x %x %x %x %x %x\n", i,
-	    buf[0], buf[1], buf[2], buf[3], buf[4], buf[5], buf[6]);
+	dev_dbg(&port->dev, "0xa1:0x21:0:0  %d - %7ph\n", i, buf);
 
 	if (cflag & CSIZE) {
 		switch (cflag & CSIZE) {
@@ -448,8 +447,7 @@ static void pl2303_set_termios(struct tty_struct *tty,
 	i = usb_control_msg(serial->dev, usb_rcvctrlpipe(serial->dev, 0),
 			    GET_LINE_REQUEST, GET_LINE_REQUEST_TYPE,
 			    0, 0, buf, 7, 100);
-	dev_dbg(&port->dev, "0xa1:0x21:0:0  %d - %x %x %x %x %x %x %x\n", i,
-	     buf[0], buf[1], buf[2], buf[3], buf[4], buf[5], buf[6]);
+	dev_dbg(&port->dev, "0xa1:0x21:0:0  %d - %7ph\n", i, buf);
 
 	if (cflag & CRTSCTS) {
 		if (spriv->type == HX)

commit 5ddbb26b8b571231cace9f013b2d0ae66229b316
Author: Johan Hovold <jhovold@gmail.com>
Date:   Thu Mar 21 12:37:45 2013 +0100

    USB: pl2303: remove disconnect test from tiocmset
    
    Remove unnecessary disconnect test in tiocmset. No ioctls will be made
    after disconnect returns.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 4dff17902fa0..7151659367a0 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -531,7 +531,6 @@ static int pl2303_tiocmset(struct tty_struct *tty,
 			   unsigned int set, unsigned int clear)
 {
 	struct usb_serial_port *port = tty->driver_data;
-	struct usb_serial *serial = port->serial;
 	struct pl2303_private *priv = usb_get_serial_port_data(port);
 	unsigned long flags;
 	u8 control;
@@ -549,17 +548,11 @@ static int pl2303_tiocmset(struct tty_struct *tty,
 	control = priv->line_control;
 	spin_unlock_irqrestore(&priv->lock, flags);
 
-	mutex_lock(&serial->disc_mutex);
-	if (!serial->disconnected) {
-		ret = pl2303_set_control_lines(port, control);
-		if (ret)
-			ret = usb_translate_errors(ret);
-	} else {
-		ret = -ENODEV;
-	}
-	mutex_unlock(&serial->disc_mutex);
+	ret = pl2303_set_control_lines(port, control);
+	if (ret)
+		return usb_translate_errors(ret);
 
-	return ret;
+	return 0;
 }
 
 static int pl2303_tiocmget(struct tty_struct *tty)

commit aff5b323b319758257a838cdc45f494c6674447c
Author: Johan Hovold <jhovold@gmail.com>
Date:   Thu Mar 21 12:37:44 2013 +0100

    USB: pl2303: fix return value of tiocmset
    
    Make sure we return 0 or a negative error number appropriate for
    userspace on errors.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 997eba4dcbeb..4dff17902fa0 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -550,10 +550,13 @@ static int pl2303_tiocmset(struct tty_struct *tty,
 	spin_unlock_irqrestore(&priv->lock, flags);
 
 	mutex_lock(&serial->disc_mutex);
-	if (!serial->disconnected)
+	if (!serial->disconnected) {
 		ret = pl2303_set_control_lines(port, control);
-	else
+		if (ret)
+			ret = usb_translate_errors(ret);
+	} else {
 		ret = -ENODEV;
+	}
 	mutex_unlock(&serial->disc_mutex);
 
 	return ret;

commit 6d0cad657a133818038683120fff9c5c5f8dc751
Author: Johan Hovold <jhovold@gmail.com>
Date:   Thu Mar 21 12:37:21 2013 +0100

    USB: pl2303: fix TIOCMIWAIT and disconnect
    
    Use tty-port modem-status-change wait queue on which processes are woken
    up at hangup and disconnect.
    
    Currently a process waiting on modem-status changes will not be woken on
    device disconnect.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 1f7fd1aaa2f5..997eba4dcbeb 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -607,7 +607,7 @@ static int pl2303_tiocmiwait(struct tty_struct *tty, unsigned long arg)
 	spin_unlock_irqrestore(&priv->lock, flags);
 
 	while (1) {
-		interruptible_sleep_on(&port->delta_msr_wait);
+		interruptible_sleep_on(&port->port.delta_msr_wait);
 		/* see if a signal did it */
 		if (signal_pending(current))
 			return -ERESTARTSYS;
@@ -718,7 +718,7 @@ static void pl2303_update_line_status(struct usb_serial_port *port,
 	spin_unlock_irqrestore(&priv->lock, flags);
 	if (priv->line_status & UART_BREAK_ERROR)
 		usb_serial_handle_break(port);
-	wake_up_interruptible(&port->delta_msr_wait);
+	wake_up_interruptible(&port->port.delta_msr_wait);
 
 	tty = tty_port_tty_get(&port->port);
 	if (!tty)
@@ -782,7 +782,7 @@ static void pl2303_process_read_urb(struct urb *urb)
 	line_status = priv->line_status;
 	priv->line_status &= ~UART_STATE_TRANSIENT_MASK;
 	spin_unlock_irqrestore(&priv->lock, flags);
-	wake_up_interruptible(&port->delta_msr_wait);
+	wake_up_interruptible(&port->port.delta_msr_wait);
 
 	if (!urb->actual_length)
 		return;

commit 824d11bef5540062d17380c65ee52d4b2948ca84
Author: Johan Hovold <jhovold@gmail.com>
Date:   Thu Mar 21 12:37:20 2013 +0100

    USB: pl2303: add custom tiocmiwait operation
    
    Break out TIOCMIWAIT handling from custom ioctl operation and use
    tiocmiwait operation field instead.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index e7e407b67994..1f7fd1aaa2f5 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -593,8 +593,9 @@ static int pl2303_carrier_raised(struct usb_serial_port *port)
 	return 0;
 }
 
-static int wait_modem_info(struct usb_serial_port *port, unsigned int arg)
+static int pl2303_tiocmiwait(struct tty_struct *tty, unsigned long arg)
 {
+	struct usb_serial_port *port = tty->driver_data;
 	struct pl2303_private *priv = usb_get_serial_port_data(port);
 	unsigned long flags;
 	unsigned int prevstatus;
@@ -652,10 +653,6 @@ static int pl2303_ioctl(struct tty_struct *tty,
 			return -EFAULT;
 
 		return 0;
-
-	case TIOCMIWAIT:
-		dev_dbg(&port->dev, "%s TIOCMIWAIT\n", __func__);
-		return wait_modem_info(port, arg);
 	default:
 		dev_dbg(&port->dev, "%s not supported = 0x%04x\n", __func__, cmd);
 		break;
@@ -836,6 +833,7 @@ static struct usb_serial_driver pl2303_device = {
 	.set_termios =		pl2303_set_termios,
 	.tiocmget =		pl2303_tiocmget,
 	.tiocmset =		pl2303_tiocmset,
+	.tiocmiwait =		pl2303_tiocmiwait,
 	.process_read_urb =	pl2303_process_read_urb,
 	.read_int_callback =	pl2303_read_int_callback,
 	.attach =		pl2303_startup,

commit f45d0a5aa593cdf48a37489fc61c145e16964288
Author: Johan Hovold <jhovold@gmail.com>
Date:   Thu Mar 21 12:36:22 2013 +0100

    USB: pl2303: make set_control_lines a port operation
    
    Pass usb-serial port rather than usb device to set_control_lines, and
    make sure port device is used for all port related debugging.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 5b2e62f6dc50..e7e407b67994 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -248,14 +248,15 @@ static int pl2303_port_remove(struct usb_serial_port *port)
 	return 0;
 }
 
-static int set_control_lines(struct usb_device *dev, u8 value)
+static int pl2303_set_control_lines(struct usb_serial_port *port, u8 value)
 {
+	struct usb_device *dev = port->serial->dev;
 	int retval;
 
 	retval = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
 				 SET_CONTROL_REQUEST, SET_CONTROL_REQUEST_TYPE,
 				 value, 0, NULL, 0, 100);
-	dev_dbg(&dev->dev, "%s - value = %d, retval = %d\n", __func__,
+	dev_dbg(&port->dev, "%s - value = %d, retval = %d\n", __func__,
 		value, retval);
 	return retval;
 }
@@ -437,7 +438,7 @@ static void pl2303_set_termios(struct tty_struct *tty,
 	if (control != priv->line_control) {
 		control = priv->line_control;
 		spin_unlock_irqrestore(&priv->lock, flags);
-		set_control_lines(serial->dev, control);
+		pl2303_set_control_lines(port, control);
 	} else {
 		spin_unlock_irqrestore(&priv->lock, flags);
 	}
@@ -480,7 +481,7 @@ static void pl2303_dtr_rts(struct usb_serial_port *port, int on)
 		priv->line_control &= ~(CONTROL_DTR | CONTROL_RTS);
 	control = priv->line_control;
 	spin_unlock_irqrestore(&priv->lock, flags);
-	set_control_lines(port->serial->dev, control);
+	pl2303_set_control_lines(port, control);
 }
 
 static void pl2303_close(struct usb_serial_port *port)
@@ -550,7 +551,7 @@ static int pl2303_tiocmset(struct tty_struct *tty,
 
 	mutex_lock(&serial->disc_mutex);
 	if (!serial->disconnected)
-		ret = set_control_lines(serial->dev, control);
+		ret = pl2303_set_control_lines(port, control);
 	else
 		ret = -ENODEV;
 	mutex_unlock(&serial->disc_mutex);

commit 7b5789a86890423e1460362798140c26822798b1
Author: Johan Hovold <jhovold@gmail.com>
Date:   Thu Mar 21 12:36:21 2013 +0100

    USB: pl2303: use interface device for debug
    
    Use interface rather than usb-serial device for debugging interface
    related operations. This gives more descriptive messages, such as
    
    [  905.669436] pl2303 1-4.1:1.0: 0x40:0x1:0x8:0x0  0
    
    rather than
    
    [  341.943535] usb 1-4.1: 0x40:0x1:0x8:0x0  0
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 3b10018d89a3..5b2e62f6dc50 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -149,7 +149,7 @@ static int pl2303_vendor_read(__u16 value, __u16 index,
 	int res = usb_control_msg(serial->dev, usb_rcvctrlpipe(serial->dev, 0),
 			VENDOR_READ_REQUEST, VENDOR_READ_REQUEST_TYPE,
 			value, index, buf, 1, 100);
-	dev_dbg(&serial->dev->dev, "0x%x:0x%x:0x%x:0x%x  %d - %x\n",
+	dev_dbg(&serial->interface->dev, "0x%x:0x%x:0x%x:0x%x  %d - %x\n",
 		VENDOR_READ_REQUEST_TYPE, VENDOR_READ_REQUEST, value, index,
 		res, buf[0]);
 	return res;
@@ -161,7 +161,7 @@ static int pl2303_vendor_write(__u16 value, __u16 index,
 	int res = usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),
 			VENDOR_WRITE_REQUEST, VENDOR_WRITE_REQUEST_TYPE,
 			value, index, NULL, 0, 100);
-	dev_dbg(&serial->dev->dev, "0x%x:0x%x:0x%x:0x%x  %d\n",
+	dev_dbg(&serial->interface->dev, "0x%x:0x%x:0x%x:0x%x  %d\n",
 		VENDOR_WRITE_REQUEST_TYPE, VENDOR_WRITE_REQUEST, value, index,
 		res);
 	return res;

commit 40509ca982c00c4b70fc00be887509feca0bff15
Author: Johan Hovold <jhovold@gmail.com>
Date:   Tue Mar 19 09:21:22 2013 +0100

    USB: pl2303: fix use-after-free in TIOCMIWAIT
    
    Use the port wait queue and make sure to check the serial disconnected
    flag before accessing private port data after waking up.
    
    This is is needed as the private port data (including the wait queue
    itself) can be gone when waking up after a disconnect.
    
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 54adc9125e5c..3b10018d89a3 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -139,7 +139,6 @@ struct pl2303_serial_private {
 
 struct pl2303_private {
 	spinlock_t lock;
-	wait_queue_head_t delta_msr_wait;
 	u8 line_control;
 	u8 line_status;
 };
@@ -233,7 +232,6 @@ static int pl2303_port_probe(struct usb_serial_port *port)
 		return -ENOMEM;
 
 	spin_lock_init(&priv->lock);
-	init_waitqueue_head(&priv->delta_msr_wait);
 
 	usb_set_serial_port_data(port, priv);
 
@@ -607,11 +605,14 @@ static int wait_modem_info(struct usb_serial_port *port, unsigned int arg)
 	spin_unlock_irqrestore(&priv->lock, flags);
 
 	while (1) {
-		interruptible_sleep_on(&priv->delta_msr_wait);
+		interruptible_sleep_on(&port->delta_msr_wait);
 		/* see if a signal did it */
 		if (signal_pending(current))
 			return -ERESTARTSYS;
 
+		if (port->serial->disconnected)
+			return -EIO;
+
 		spin_lock_irqsave(&priv->lock, flags);
 		status = priv->line_status;
 		spin_unlock_irqrestore(&priv->lock, flags);
@@ -719,7 +720,7 @@ static void pl2303_update_line_status(struct usb_serial_port *port,
 	spin_unlock_irqrestore(&priv->lock, flags);
 	if (priv->line_status & UART_BREAK_ERROR)
 		usb_serial_handle_break(port);
-	wake_up_interruptible(&priv->delta_msr_wait);
+	wake_up_interruptible(&port->delta_msr_wait);
 
 	tty = tty_port_tty_get(&port->port);
 	if (!tty)
@@ -783,7 +784,7 @@ static void pl2303_process_read_urb(struct urb *urb)
 	line_status = priv->line_status;
 	priv->line_status &= ~UART_STATE_TRANSIENT_MASK;
 	spin_unlock_irqrestore(&priv->lock, flags);
-	wake_up_interruptible(&priv->delta_msr_wait);
+	wake_up_interruptible(&port->delta_msr_wait);
 
 	if (!urb->actual_length)
 		return;

commit 2e124b4a390ca85325fae75764bef92f0547fa25
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Thu Jan 3 15:53:06 2013 +0100

    TTY: switch tty_flip_buffer_push
    
    Now, we start converting tty buffer functions to actually use
    tty_port. This will allow us to get rid of the need of tty in many
    call sites. Only tty_port will needed and hence no more
    tty_port_tty_get in those paths.
    
    Now, the one where most of tty_port_tty_get gets removed:
    tty_flip_buffer_push.
    
    IOW we also closed all the races in drivers not using tty_port_tty_get
    at all yet.
    
    Also we move tty_flip_buffer_push declaration from include/linux/tty.h
    to include/linux/tty_flip.h to all others while we are changing it
    anyway.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 00047f3c7293..54adc9125e5c 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -772,7 +772,6 @@ static void pl2303_process_read_urb(struct urb *urb)
 {
 	struct usb_serial_port *port = urb->context;
 	struct pl2303_private *priv = usb_get_serial_port_data(port);
-	struct tty_struct *tty;
 	unsigned char *data = urb->transfer_buffer;
 	char tty_flag = TTY_NORMAL;
 	unsigned long flags;
@@ -789,10 +788,6 @@ static void pl2303_process_read_urb(struct urb *urb)
 	if (!urb->actual_length)
 		return;
 
-	tty = tty_port_tty_get(&port->port);
-	if (!tty)
-		return;
-
 	/* break takes precedence over parity, */
 	/* which takes precedence over framing errors */
 	if (line_status & UART_BREAK_ERROR)
@@ -817,8 +812,7 @@ static void pl2303_process_read_urb(struct urb *urb)
 							urb->actual_length);
 	}
 
-	tty_flip_buffer_push(tty);
-	tty_kref_put(tty);
+	tty_flip_buffer_push(&port->port);
 }
 
 /* All of the device info needed for the PL2303 SIO serial converter */

commit 92a19f9cec9a80ad93c06e115822deb729e2c6ad
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Thu Jan 3 15:53:03 2013 +0100

    TTY: switch tty_insert_flip_char
    
    Now, we start converting tty buffer functions to actually use
    tty_port. This will allow us to get rid of the need of tty in many
    call sites. Only tty_port will needed and hence no more
    tty_port_tty_get in those paths.
    
    tty_insert_flip_char is the next one to proceed. This one is used all
    over the code, so the patch is huge.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 86789b0477c5..00047f3c7293 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -805,12 +805,13 @@ static void pl2303_process_read_urb(struct urb *urb)
 
 	/* overrun is special, not associated with a char */
 	if (line_status & UART_OVERRUN_ERROR)
-		tty_insert_flip_char(tty, 0, TTY_OVERRUN);
+		tty_insert_flip_char(&port->port, 0, TTY_OVERRUN);
 
 	if (port->port.console && port->sysrq) {
 		for (i = 0; i < urb->actual_length; ++i)
 			if (!usb_serial_handle_sysrq_char(port, data[i]))
-				tty_insert_flip_char(tty, data[i], tty_flag);
+				tty_insert_flip_char(&port->port, data[i],
+						tty_flag);
 	} else {
 		tty_insert_flip_string_fixed_flag(&port->port, data, tty_flag,
 							urb->actual_length);

commit 2f69335710884ae6112fc8196ebe29b5cda7b79b
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Thu Jan 3 15:53:02 2013 +0100

    TTY: convert more flipping functions
    
    Now, we start converting tty buffer functions to actually use
    tty_port. This will allow us to get rid of the need of tty pointer in
    many call sites. Only tty_port will be needed and hence no more
    tty_port_tty_get calls in those paths.
    
    Now 4 string flipping ones are on turn:
    * tty_insert_flip_string_flags
    * tty_insert_flip_string_fixed_flag
    * tty_prepare_flip_string
    * tty_prepare_flip_string_flags
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 600241901361..86789b0477c5 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -812,7 +812,7 @@ static void pl2303_process_read_urb(struct urb *urb)
 			if (!usb_serial_handle_sysrq_char(port, data[i]))
 				tty_insert_flip_char(tty, data[i], tty_flag);
 	} else {
-		tty_insert_flip_string_fixed_flag(tty, data, tty_flag,
+		tty_insert_flip_string_fixed_flag(&port->port, data, tty_flag,
 							urb->actual_length);
 	}
 

commit 8bf769eb5f6efc33f95088850f33fcc05d28b508
Author: Johan Hovold <jhovold@gmail.com>
Date:   Mon Oct 15 15:47:21 2012 +0200

    USB: pl2303: fix port-data memory leak
    
    Fix port-data memory leak by allocating and freeing port data in
    port_probe/remove rather than in attach/release, and by introducing
    serial private data to store the device type which is interface rather
    than port specific.
    
    Since commit 0998d0631001288 (device-core: Ensure drvdata = NULL when no
    driver is bound) the port private data is no longer freed at release.
    
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 892ebdc7a364..600241901361 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -133,12 +133,15 @@ enum pl2303_type {
 	HX,		/* HX version of the pl2303 chip */
 };
 
+struct pl2303_serial_private {
+	enum pl2303_type type;
+};
+
 struct pl2303_private {
 	spinlock_t lock;
 	wait_queue_head_t delta_msr_wait;
 	u8 line_control;
 	u8 line_status;
-	enum pl2303_type type;
 };
 
 static int pl2303_vendor_read(__u16 value, __u16 index,
@@ -167,14 +170,19 @@ static int pl2303_vendor_write(__u16 value, __u16 index,
 
 static int pl2303_startup(struct usb_serial *serial)
 {
-	struct pl2303_private *priv;
+	struct pl2303_serial_private *spriv;
 	enum pl2303_type type = type_0;
 	unsigned char *buf;
-	int i;
+
+	spriv = kzalloc(sizeof(*spriv), GFP_KERNEL);
+	if (!spriv)
+		return -ENOMEM;
 
 	buf = kmalloc(10, GFP_KERNEL);
-	if (buf == NULL)
+	if (!buf) {
+		kfree(spriv);
 		return -ENOMEM;
+	}
 
 	if (serial->dev->descriptor.bDeviceClass == 0x02)
 		type = type_0;
@@ -186,15 +194,8 @@ static int pl2303_startup(struct usb_serial *serial)
 		type = type_1;
 	dev_dbg(&serial->interface->dev, "device type: %d\n", type);
 
-	for (i = 0; i < serial->num_ports; ++i) {
-		priv = kzalloc(sizeof(struct pl2303_private), GFP_KERNEL);
-		if (!priv)
-			goto cleanup;
-		spin_lock_init(&priv->lock);
-		init_waitqueue_head(&priv->delta_msr_wait);
-		priv->type = type;
-		usb_set_serial_port_data(serial->port[i], priv);
-	}
+	spriv->type = type;
+	usb_set_serial_data(serial, spriv);
 
 	pl2303_vendor_read(0x8484, 0, serial, buf);
 	pl2303_vendor_write(0x0404, 0, serial);
@@ -213,15 +214,40 @@ static int pl2303_startup(struct usb_serial *serial)
 
 	kfree(buf);
 	return 0;
+}
 
-cleanup:
-	kfree(buf);
-	for (--i; i >= 0; --i) {
-		priv = usb_get_serial_port_data(serial->port[i]);
-		kfree(priv);
-		usb_set_serial_port_data(serial->port[i], NULL);
-	}
-	return -ENOMEM;
+static void pl2303_release(struct usb_serial *serial)
+{
+	struct pl2303_serial_private *spriv;
+
+	spriv = usb_get_serial_data(serial);
+	kfree(spriv);
+}
+
+static int pl2303_port_probe(struct usb_serial_port *port)
+{
+	struct pl2303_private *priv;
+
+	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	spin_lock_init(&priv->lock);
+	init_waitqueue_head(&priv->delta_msr_wait);
+
+	usb_set_serial_port_data(port, priv);
+
+	return 0;
+}
+
+static int pl2303_port_remove(struct usb_serial_port *port)
+{
+	struct pl2303_private *priv;
+
+	priv = usb_get_serial_port_data(port);
+	kfree(priv);
+
+	return 0;
 }
 
 static int set_control_lines(struct usb_device *dev, u8 value)
@@ -240,6 +266,7 @@ static void pl2303_set_termios(struct tty_struct *tty,
 		struct usb_serial_port *port, struct ktermios *old_termios)
 {
 	struct usb_serial *serial = port->serial;
+	struct pl2303_serial_private *spriv = usb_get_serial_data(serial);
 	struct pl2303_private *priv = usb_get_serial_port_data(port);
 	unsigned long flags;
 	unsigned int cflag;
@@ -323,7 +350,7 @@ static void pl2303_set_termios(struct tty_struct *tty,
 		}
 		if (baud > 1228800) {
 			/* type_0, type_1 only support up to 1228800 baud */
-			if (priv->type != HX)
+			if (spriv->type != HX)
 				baud = 1228800;
 			else if (baud > 6000000)
 				baud = 6000000;
@@ -426,7 +453,7 @@ static void pl2303_set_termios(struct tty_struct *tty,
 	     buf[0], buf[1], buf[2], buf[3], buf[4], buf[5], buf[6]);
 
 	if (cflag & CRTSCTS) {
-		if (priv->type == HX)
+		if (spriv->type == HX)
 			pl2303_vendor_write(0x0, 0x61, serial);
 		else
 			pl2303_vendor_write(0x0, 0x41, serial);
@@ -468,10 +495,10 @@ static int pl2303_open(struct tty_struct *tty, struct usb_serial_port *port)
 {
 	struct ktermios tmp_termios;
 	struct usb_serial *serial = port->serial;
-	struct pl2303_private *priv = usb_get_serial_port_data(port);
+	struct pl2303_serial_private *spriv = usb_get_serial_data(serial);
 	int result;
 
-	if (priv->type != HX) {
+	if (spriv->type != HX) {
 		usb_clear_halt(serial->dev, port->write_urb->pipe);
 		usb_clear_halt(serial->dev, port->read_urb->pipe);
 	} else {
@@ -655,17 +682,6 @@ static void pl2303_break_ctl(struct tty_struct *tty, int break_state)
 		dev_err(&port->dev, "error sending break = %d\n", result);
 }
 
-static void pl2303_release(struct usb_serial *serial)
-{
-	int i;
-	struct pl2303_private *priv;
-
-	for (i = 0; i < serial->num_ports; ++i) {
-		priv = usb_get_serial_port_data(serial->port[i]);
-		kfree(priv);
-	}
-}
-
 static void pl2303_update_line_status(struct usb_serial_port *port,
 				      unsigned char *data,
 				      unsigned int actual_length)
@@ -827,6 +843,8 @@ static struct usb_serial_driver pl2303_device = {
 	.read_int_callback =	pl2303_read_int_callback,
 	.attach =		pl2303_startup,
 	.release =		pl2303_release,
+	.port_probe =		pl2303_port_probe,
+	.port_remove =		pl2303_port_remove,
 };
 
 static struct usb_serial_driver * const serial_drivers[] = {

commit d9a807461fc8cc0d6ba589ea0730d139122af012
Merge: 3498d13b8090 70c048a238c7
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Oct 1 13:23:01 2012 -0700

    Merge tag 'usb-3.6' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/usb
    
    Pull USB changes from Greg Kroah-Hartman:
     "Here is the big USB pull request for 3.7-rc1
    
      There are lots of gadget driver changes (including copying a bunch of
      files into the drivers/staging/ccg/ directory so that the other gadget
      drivers can be fixed up properly without breaking that driver), and we
      remove the old obsolete ub.c driver from the tree.
    
      There are also the usual XHCI set of updates, and other various driver
      changes and updates.  We also are trying hard to remove the old dbg()
      macro, but the final bits of that removal will be coming in through
      the networking tree before we can delete it for good.
    
      All of these patches have been in the linux-next tree.
    
      Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>"
    
    Fix up several annoying - but fairly mindless - conflicts due to the
    termios structure having moved into the tty device, and often clashing
    with dbg -> dev_dbg conversion.
    
    * tag 'usb-3.6' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/usb: (339 commits)
      USB: ezusb: move ezusb.c from drivers/usb/serial to drivers/usb/misc
      USB: uas: fix gcc warning
      USB: uas: fix locking
      USB: Fix race condition when removing host controllers
      USB: uas: add locking
      USB: uas: fix abort
      USB: uas: remove aborted field, replace with status bit.
      USB: uas: fix task management
      USB: uas: keep track of command urbs
      xhci: Intel Panther Point BEI quirk.
      powerpc/usb: remove checking PHY_CLK_VALID for UTMI PHY
      USB: ftdi_sio: add TIAO USB Multi-Protocol Adapter (TUMPA) support
      Revert "usb : Add sysfs files to control port power."
      USB: serial: remove vizzini driver
      usb: host: xhci: Fix Null pointer dereferencing with 71c731a for non-x86 systems
      Increase XHCI suspend timeout to 16ms
      USB: ohci-at91: fix null pointer in ohci_hcd_at91_overcurrent_irq
      USB: sierra_ms: don't keep unused variable
      fsl/usb: Add support for USB controller version 2.4
      USB: qcaux: add Pantech vendor class match
      ...

commit 8c3b8f0aea54f5c9d77d3bd4bf037d8868026d72
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Sep 18 10:16:12 2012 +0100

    USB: Serial: pl2303.c: remove debug module parameter
    
    Now that all usb-serial modules are only using dev_dbg()
    the debug module parameter does not do anything at all, so
    remove it to reduce any confusion if someone were to try to
    use it.
    
    CC: Johan Hovold <jhovold@gmail.com>
    CC: Alan Stern <stern@rowland.harvard.edu>
    CC: Wang YanQing <Udknight@gmail.com>
    CC: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 5eccbe5b81b5..ef10a9c6ce46 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -36,8 +36,6 @@
  */
 #define DRIVER_DESC "Prolific PL2303 USB to serial adaptor driver"
 
-static bool debug;
-
 static const struct usb_device_id id_table[] = {
 	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID) },
 	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_RSAQ2) },
@@ -839,7 +837,3 @@ module_usb_serial_driver(serial_drivers, id_table);
 
 MODULE_DESCRIPTION(DRIVER_DESC);
 MODULE_LICENSE("GPL");
-
-module_param(debug, bool, S_IRUGO | S_IWUSR);
-MODULE_PARM_DESC(debug, "Debug enabled or not");
-

commit 59d33f2fc2d63796296b1b76143e039d6e7cf532
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Sep 18 09:58:57 2012 +0100

    USB: serial: remove debug parameter from usb_serial_debug_data()
    
    We should use dev_dbg() for usb_serial_debug_data() like all of the rest
    of the usb-serial drivers use, so remove the debug parameter as it's not
    needed.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 13b8dd6481f5..5eccbe5b81b5 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -741,7 +741,7 @@ static void pl2303_read_int_callback(struct urb *urb)
 		goto exit;
 	}
 
-	usb_serial_debug_data(debug, &port->dev, __func__,
+	usb_serial_debug_data(&port->dev, __func__,
 			      urb->actual_length, urb->transfer_buffer);
 
 	pl2303_update_line_status(port, data, actual_length);

commit adc8d746caa67fff4b53ba3e5163a6cbacc3b523
Author: Alan Cox <alan@linux.intel.com>
Date:   Sat Jul 14 15:31:47 2012 +0100

    tty: move the termios object into the tty
    
    This will let us sort out a whole pile of tty related races. The
    alternative would be to keep points and refcount the termios objects.
    However
    1. They are tiny anyway
    2. Many devices don't use the stored copies
    3. We can remove a pty special case
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 13b8dd6481f5..2b9108a8ea64 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -260,16 +260,16 @@ static void pl2303_set_termios(struct tty_struct *tty,
 	   serial settings even to the same values as before. Thus
 	   we actually need to filter in this specific case */
 
-	if (!tty_termios_hw_change(tty->termios, old_termios))
+	if (!tty_termios_hw_change(&tty->termios, old_termios))
 		return;
 
-	cflag = tty->termios->c_cflag;
+	cflag = tty->termios.c_cflag;
 
 	buf = kzalloc(7, GFP_KERNEL);
 	if (!buf) {
 		dev_err(&port->dev, "%s - out of memory.\n", __func__);
 		/* Report back no change occurred */
-		*tty->termios = *old_termios;
+		tty->termios = *old_termios;
 		return;
 	}
 

commit 68e24113457e437b1576670f2419b77ed0531e9e
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue May 8 15:46:14 2012 -0700

    USB: serial: rework usb_serial_register/deregister_drivers()
    
    This reworks the usb_serial_register_drivers() and
    usb_serial_deregister_drivers() to not need a pointer to a struct
    usb_driver anymore.  The usb_driver structure is now created dynamically
    and registered and unregistered as needed.
    
    This saves lines of code in each usb-serial driver.  All in-kernel users
    of these functions were also fixed up at this time.  The pl2303 driver
    was tested that everything worked properly.
    
    Thanks for the idea to do this from Alan Stern.
    
    Cc: Adhir Ramjiawan <adhirramjiawan0@gmail.com>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Al Borchers <alborchers@steinerpoint.com>
    Cc: Aleksey Babahin <tamerlan311@gmail.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Andrew Worsley <amworsley@gmail.com>
    Cc: Bart Hartgers <bart.hartgers@gmail.com>
    Cc: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Dan Carpenter <error27@gmail.com>
    Cc: Dan Williams <dcbw@redhat.com>
    Cc: Donald Lee <donald@asix.com.tw>
    Cc: Eric Dumazet <eric.dumazet@gmail.com>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Felipe Balbi <balbi@ti.com>
    Cc: Gary Brubaker <xavyer@ix.netcom.com>
    Cc: Jesper Juhl <jj@chaosbits.net>
    Cc: Jiri Kosina <jkosina@suse.cz>
    Cc: Johan Hovold <jhovold@gmail.com>
    Cc: Julia Lawall <julia@diku.dk>
    Cc: Kautuk Consul <consul.kautuk@gmail.com>
    Cc: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Cc: Lonnie Mendez <dignome@gmail.com>
    Cc: Matthias Bruestle and Harald Welte <support@reiner-sct.com>
    Cc: Matthias Urlichs <smurf@smurf.noris.de>
    Cc: Mauro Carvalho Chehab <mchehab@redhat.com>
    Cc: Michal Sroczynski <msroczyn@gmail.com>
    Cc: "Michał Wróbel" <michal.wrobel@flytronic.pl>
    Cc: Oliver Neukum <oliver@neukum.name>
    Cc: Paul Gortmaker <paul.gortmaker@windriver.com>
    Cc: Peter Berger <pberger@brimson.com>
    Cc: Preston Fick <preston.fick@silabs.com>
    Cc: "Rafael J. Wysocki" <rjw@sisk.pl>
    Cc: Rigbert Hamisch <rigbert@gmx.de>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Cc: Simon Arlott <simon@fire.lp0.eu>
    Cc: Support Department <support@connecttech.com>
    Cc: Thomas Tuttle <ttuttle@chromium.org>
    Cc: Uwe Bonnes <bon@elektron.ikp.physik.tu-darmstadt.de>
    Cc: Wang YanQing <Udknight@gmail.com>
    Cc: William Greathouse <wgreathouse@smva.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 642136e39fa6..13b8dd6481f5 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -95,11 +95,6 @@ static const struct usb_device_id id_table[] = {
 
 MODULE_DEVICE_TABLE(usb, id_table);
 
-static struct usb_driver pl2303_driver = {
-	.name =		"pl2303",
-	.id_table =	id_table,
-};
-
 #define SET_LINE_REQUEST_TYPE		0x21
 #define SET_LINE_REQUEST		0x20
 
@@ -840,7 +835,7 @@ static struct usb_serial_driver * const serial_drivers[] = {
 	&pl2303_device, NULL
 };
 
-module_usb_serial_driver(pl2303_driver, serial_drivers);
+module_usb_serial_driver(serial_drivers, id_table);
 
 MODULE_DESCRIPTION(DRIVER_DESC);
 MODULE_LICENSE("GPL");

commit 32078f915d1acab356080b144aa89fe3487f3979
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon May 7 14:02:13 2012 -0700

    USB: serial: remove usb_serial_disconnect call in all drivers
    
    This is now set by the usb-serial core, no need for the driver to
    individually set it.
    
    Thanks to Alan Stern for the idea to get rid of it.
    
    Cc: William Greathouse <wgreathouse@smva.com>
    Cc: Matthias Bruestle and Harald Welte <support@reiner-sct.com>
    Cc: Lonnie Mendez <dignome@gmail.com>
    Cc: Peter Berger <pberger@brimson.com>
    Cc: Al Borchers <alborchers@steinerpoint.com>
    Cc: Gary Brubaker <xavyer@ix.netcom.com>
    Cc: Oliver Neukum <oliver@neukum.name>
    Cc: Matthias Urlichs <smurf@smurf.noris.de>
    Cc: Support Department <support@connecttech.com>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Mauro Carvalho Chehab <mchehab@redhat.com>
    Cc: Kautuk Consul <consul.kautuk@gmail.com>
    Cc: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Paul Gortmaker <paul.gortmaker@windriver.com>
    Cc: Bart Hartgers <bart.hartgers@gmail.com>
    Cc: Johan Hovold <jhovold@gmail.com>
    Cc: Preston Fick <preston.fick@silabs.com>
    Cc: Uwe Bonnes <bon@elektron.ikp.physik.tu-darmstadt.de>
    Cc: Simon Arlott <simon@fire.lp0.eu>
    Cc: Andrew Worsley <amworsley@gmail.com>
    Cc: "Michał Wróbel" <michal.wrobel@flytronic.pl>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Eric Dumazet <eric.dumazet@gmail.com>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Felipe Balbi <balbi@ti.com>
    Cc: Aleksey Babahin <tamerlan311@gmail.com>
    Cc: Dan Carpenter <error27@gmail.com>
    Cc: Jiri Kosina <jkosina@suse.cz>
    Cc: Donald Lee <donald@asix.com.tw>
    Cc: Julia Lawall <julia@diku.dk>
    Cc: Michal Sroczynski <msroczyn@gmail.com>
    Cc: Wang YanQing <Udknight@gmail.com>
    Cc: Dan Williams <dcbw@redhat.com>
    Cc: Thomas Tuttle <ttuttle@chromium.org>
    Cc: Rigbert Hamisch <rigbert@gmx.de>
    Cc: "Rafael J. Wysocki" <rjw@sisk.pl>
    Cc: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Cc: Jesper Juhl <jj@chaosbits.net>
    Cc: Adhir Ramjiawan <adhirramjiawan0@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 93607a4d330b..642136e39fa6 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -97,7 +97,6 @@ MODULE_DEVICE_TABLE(usb, id_table);
 
 static struct usb_driver pl2303_driver = {
 	.name =		"pl2303",
-	.disconnect =	usb_serial_disconnect,
 	.id_table =	id_table,
 };
 

commit 5026bb07be87ef5892742e6853ae6efa0f41961f
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon May 7 13:48:33 2012 -0700

    USB: serial: remove usb_serial_probe call in all drivers
    
    This is now set by the usb-serial core, no need for the driver to
    individually set it.
    
    Thanks to Alan Stern for the idea to get rid of it.
    
    Cc: William Greathouse <wgreathouse@smva.com>
    Cc: Matthias Bruestle and Harald Welte <support@reiner-sct.com>
    Cc: Lonnie Mendez <dignome@gmail.com>
    Cc: Peter Berger <pberger@brimson.com>
    Cc: Al Borchers <alborchers@steinerpoint.com>
    Cc: Gary Brubaker <xavyer@ix.netcom.com>
    Cc: Oliver Neukum <oliver@neukum.name>
    Cc: Matthias Urlichs <smurf@smurf.noris.de>
    Cc: Support Department <support@connecttech.com>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Mauro Carvalho Chehab <mchehab@redhat.com>
    Cc: Kautuk Consul <consul.kautuk@gmail.com>
    Cc: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Paul Gortmaker <paul.gortmaker@windriver.com>
    Cc: Bart Hartgers <bart.hartgers@gmail.com>
    Cc: Johan Hovold <jhovold@gmail.com>
    Cc: Preston Fick <preston.fick@silabs.com>
    Cc: Uwe Bonnes <bon@elektron.ikp.physik.tu-darmstadt.de>
    Cc: Simon Arlott <simon@fire.lp0.eu>
    Cc: Andrew Worsley <amworsley@gmail.com>
    Cc: "Michał Wróbel" <michal.wrobel@flytronic.pl>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Eric Dumazet <eric.dumazet@gmail.com>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Felipe Balbi <balbi@ti.com>
    Cc: Aleksey Babahin <tamerlan311@gmail.com>
    Cc: Dan Carpenter <error27@gmail.com>
    Cc: Jiri Kosina <jkosina@suse.cz>
    Cc: Donald Lee <donald@asix.com.tw>
    Cc: Julia Lawall <julia@diku.dk>
    Cc: Michal Sroczynski <msroczyn@gmail.com>
    Cc: Wang YanQing <Udknight@gmail.com>
    Cc: Dan Williams <dcbw@redhat.com>
    Cc: Thomas Tuttle <ttuttle@chromium.org>
    Cc: Rigbert Hamisch <rigbert@gmx.de>
    Cc: "Rafael J. Wysocki" <rjw@sisk.pl>
    Cc: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Cc: Jesper Juhl <jj@chaosbits.net>
    Cc: Adhir Ramjiawan <adhirramjiawan0@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 34e51a04dde0..93607a4d330b 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -97,7 +97,6 @@ MODULE_DEVICE_TABLE(usb, id_table);
 
 static struct usb_driver pl2303_driver = {
 	.name =		"pl2303",
-	.probe =	usb_serial_probe,
 	.disconnect =	usb_serial_disconnect,
 	.id_table =	id_table,
 };

commit c7f3619b90fc4c43ed326ec8b3f0299374763c92
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon May 7 11:24:05 2012 -0400

    usb-serial: clean up unneeded PM-related fields
    
    This patch (as1551) cleans up the PM-related entries in the usb_driver
    structures of the various USB serial driver modules.  Those entries
    are now filled in by the usb-serial core during driver registration,
    so they don't need to be initialized explicitly in the source code.
    
    The same is true of the one remaining no_dynamic_id entry.
    
    reset_resume remains a small problem, because the serial core doesn't
    support it.  The patch ignores these entries.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 9eec2c3574d8..34e51a04dde0 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -100,9 +100,6 @@ static struct usb_driver pl2303_driver = {
 	.probe =	usb_serial_probe,
 	.disconnect =	usb_serial_disconnect,
 	.id_table =	id_table,
-	.suspend =      usb_serial_suspend,
-	.resume =       usb_serial_resume,
-	.supports_autosuspend =	1,
 };
 
 #define SET_LINE_REQUEST_TYPE		0x21

commit d8789b2b90aeb53ce59ac232d2ff0d8357d53893
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu May 3 16:39:27 2012 -0700

    USB: serial: pl2303: convert dbg() calls to dev_dbg()
    
    This converts the usage of dbg() to dev_dbg() where needed, and removed
    a bunch of these calls where they were just "tracing" calls, which are
    no longer needed.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index c6bb88d5effd..9eec2c3574d8 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -159,8 +159,9 @@ static int pl2303_vendor_read(__u16 value, __u16 index,
 	int res = usb_control_msg(serial->dev, usb_rcvctrlpipe(serial->dev, 0),
 			VENDOR_READ_REQUEST, VENDOR_READ_REQUEST_TYPE,
 			value, index, buf, 1, 100);
-	dbg("0x%x:0x%x:0x%x:0x%x  %d - %x", VENDOR_READ_REQUEST_TYPE,
-			VENDOR_READ_REQUEST, value, index, res, buf[0]);
+	dev_dbg(&serial->dev->dev, "0x%x:0x%x:0x%x:0x%x  %d - %x\n",
+		VENDOR_READ_REQUEST_TYPE, VENDOR_READ_REQUEST, value, index,
+		res, buf[0]);
 	return res;
 }
 
@@ -170,8 +171,9 @@ static int pl2303_vendor_write(__u16 value, __u16 index,
 	int res = usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),
 			VENDOR_WRITE_REQUEST, VENDOR_WRITE_REQUEST_TYPE,
 			value, index, NULL, 0, 100);
-	dbg("0x%x:0x%x:0x%x:0x%x  %d", VENDOR_WRITE_REQUEST_TYPE,
-			VENDOR_WRITE_REQUEST, value, index, res);
+	dev_dbg(&serial->dev->dev, "0x%x:0x%x:0x%x:0x%x  %d\n",
+		VENDOR_WRITE_REQUEST_TYPE, VENDOR_WRITE_REQUEST, value, index,
+		res);
 	return res;
 }
 
@@ -194,7 +196,7 @@ static int pl2303_startup(struct usb_serial *serial)
 		type = type_1;
 	else if (serial->dev->descriptor.bDeviceClass == 0xFF)
 		type = type_1;
-	dbg("device type: %d", type);
+	dev_dbg(&serial->interface->dev, "device type: %d\n", type);
 
 	for (i = 0; i < serial->num_ports; ++i) {
 		priv = kzalloc(sizeof(struct pl2303_private), GFP_KERNEL);
@@ -241,7 +243,8 @@ static int set_control_lines(struct usb_device *dev, u8 value)
 	retval = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
 				 SET_CONTROL_REQUEST, SET_CONTROL_REQUEST_TYPE,
 				 value, 0, NULL, 0, 100);
-	dbg("%s - value = %d, retval = %d", __func__, value, retval);
+	dev_dbg(&dev->dev, "%s - value = %d, retval = %d\n", __func__,
+		value, retval);
 	return retval;
 }
 
@@ -263,8 +266,6 @@ static void pl2303_set_termios(struct tty_struct *tty,
 	int baud_floor, baud_ceil;
 	int k;
 
-	dbg("%s -  port %d", __func__, port->number);
-
 	/* The PL2303 is reported to lose bytes if you change
 	   serial settings even to the same values as before. Thus
 	   we actually need to filter in this specific case */
@@ -285,7 +286,7 @@ static void pl2303_set_termios(struct tty_struct *tty,
 	i = usb_control_msg(serial->dev, usb_rcvctrlpipe(serial->dev, 0),
 			    GET_LINE_REQUEST, GET_LINE_REQUEST_TYPE,
 			    0, 0, buf, 7, 100);
-	dbg("0xa1:0x21:0:0  %d - %x %x %x %x %x %x %x", i,
+	dev_dbg(&port->dev, "0xa1:0x21:0:0  %d - %x %x %x %x %x %x %x\n", i,
 	    buf[0], buf[1], buf[2], buf[3], buf[4], buf[5], buf[6]);
 
 	if (cflag & CSIZE) {
@@ -304,7 +305,7 @@ static void pl2303_set_termios(struct tty_struct *tty,
 			buf[6] = 8;
 			break;
 		}
-		dbg("%s - data bits = %d", __func__, buf[6]);
+		dev_dbg(&port->dev, "data bits = %d\n", buf[6]);
 	}
 
 	/* For reference buf[0]:buf[3] baud rate value */
@@ -313,7 +314,7 @@ static void pl2303_set_termios(struct tty_struct *tty,
 	 *          9600 baud (at least my PL2303X always does)
 	 */
 	baud = tty_get_baud_rate(tty);
-	dbg("%s - baud requested = %d", __func__, baud);
+	dev_dbg(&port->dev, "baud requested = %d\n", baud);
 	if (baud) {
 		/* Set baudrate to nearest supported value */
 		for (k=0; k<ARRAY_SIZE(baud_sup); k++) {
@@ -339,7 +340,7 @@ static void pl2303_set_termios(struct tty_struct *tty,
 			else if (baud > 6000000)
 				baud = 6000000;
 		}
-		dbg("%s - baud set = %d", __func__, baud);
+		dev_dbg(&port->dev, "baud set = %d\n", baud);
 		if (baud <= 115200) {
 			buf[0] = baud & 0xff;
 			buf[1] = (baud >> 8) & 0xff;
@@ -370,14 +371,14 @@ static void pl2303_set_termios(struct tty_struct *tty,
 		 */
 		if ((cflag & CSIZE) == CS5) {
 			buf[4] = 1;
-			dbg("%s - stop bits = 1.5", __func__);
+			dev_dbg(&port->dev, "stop bits = 1.5\n");
 		} else {
 			buf[4] = 2;
-			dbg("%s - stop bits = 2", __func__);
+			dev_dbg(&port->dev, "stop bits = 2\n");
 		}
 	} else {
 		buf[4] = 0;
-		dbg("%s - stop bits = 1", __func__);
+		dev_dbg(&port->dev, "stop bits = 1\n");
 	}
 
 	if (cflag & PARENB) {
@@ -389,29 +390,29 @@ static void pl2303_set_termios(struct tty_struct *tty,
 		if (cflag & PARODD) {
 			if (cflag & CMSPAR) {
 				buf[5] = 3;
-				dbg("%s - parity = mark", __func__);
+				dev_dbg(&port->dev, "parity = mark\n");
 			} else {
 				buf[5] = 1;
-				dbg("%s - parity = odd", __func__);
+				dev_dbg(&port->dev, "parity = odd\n");
 			}
 		} else {
 			if (cflag & CMSPAR) {
 				buf[5] = 4;
-				dbg("%s - parity = space", __func__);
+				dev_dbg(&port->dev, "parity = space\n");
 			} else {
 				buf[5] = 2;
-				dbg("%s - parity = even", __func__);
+				dev_dbg(&port->dev, "parity = even\n");
 			}
 		}
 	} else {
 		buf[5] = 0;
-		dbg("%s - parity = none", __func__);
+		dev_dbg(&port->dev, "parity = none\n");
 	}
 
 	i = usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),
 			    SET_LINE_REQUEST, SET_LINE_REQUEST_TYPE,
 			    0, 0, buf, 7, 100);
-	dbg("0x21:0x20:0:0  %d", i);
+	dev_dbg(&port->dev, "0x21:0x20:0:0  %d\n", i);
 
 	/* change control lines if we are switching to or from B0 */
 	spin_lock_irqsave(&priv->lock, flags);
@@ -433,7 +434,7 @@ static void pl2303_set_termios(struct tty_struct *tty,
 	i = usb_control_msg(serial->dev, usb_rcvctrlpipe(serial->dev, 0),
 			    GET_LINE_REQUEST, GET_LINE_REQUEST_TYPE,
 			    0, 0, buf, 7, 100);
-	dbg("0xa1:0x21:0:0  %d - %x %x %x %x %x %x %x", i,
+	dev_dbg(&port->dev, "0xa1:0x21:0:0  %d - %x %x %x %x %x %x %x\n", i,
 	     buf[0], buf[1], buf[2], buf[3], buf[4], buf[5], buf[6]);
 
 	if (cflag & CRTSCTS) {
@@ -471,8 +472,6 @@ static void pl2303_dtr_rts(struct usb_serial_port *port, int on)
 
 static void pl2303_close(struct usb_serial_port *port)
 {
-	dbg("%s - port %d", __func__, port->number);
-
 	usb_serial_generic_close(port);
 	usb_kill_urb(port->interrupt_in_urb);
 }
@@ -484,8 +483,6 @@ static int pl2303_open(struct tty_struct *tty, struct usb_serial_port *port)
 	struct pl2303_private *priv = usb_get_serial_port_data(port);
 	int result;
 
-	dbg("%s -  port %d", __func__, port->number);
-
 	if (priv->type != HX) {
 		usb_clear_halt(serial->dev, port->write_urb->pipe);
 		usb_clear_halt(serial->dev, port->read_urb->pipe);
@@ -499,7 +496,6 @@ static int pl2303_open(struct tty_struct *tty, struct usb_serial_port *port)
 	if (tty)
 		pl2303_set_termios(tty, port, &tmp_termios);
 
-	dbg("%s - submitting interrupt urb", __func__);
 	result = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);
 	if (result) {
 		dev_err(&port->dev, "%s - failed submitting interrupt urb,"
@@ -558,8 +554,6 @@ static int pl2303_tiocmget(struct tty_struct *tty)
 	unsigned int status;
 	unsigned int result;
 
-	dbg("%s (%d)", __func__, port->number);
-
 	spin_lock_irqsave(&priv->lock, flags);
 	mcr = priv->line_control;
 	status = priv->line_status;
@@ -572,7 +566,7 @@ static int pl2303_tiocmget(struct tty_struct *tty)
 		  | ((status & UART_RING)	? TIOCM_RI  : 0)
 		  | ((status & UART_DCD)	? TIOCM_CD  : 0);
 
-	dbg("%s - result = %x", __func__, result);
+	dev_dbg(&port->dev, "%s - result = %x\n", __func__, result);
 
 	return result;
 }
@@ -626,7 +620,8 @@ static int pl2303_ioctl(struct tty_struct *tty,
 {
 	struct serial_struct ser;
 	struct usb_serial_port *port = tty->driver_data;
-	dbg("%s (%d) cmd = 0x%04x", __func__, port->number, cmd);
+
+	dev_dbg(&port->dev, "%s cmd = 0x%04x\n", __func__, cmd);
 
 	switch (cmd) {
 	case TIOCGSERIAL:
@@ -642,10 +637,10 @@ static int pl2303_ioctl(struct tty_struct *tty,
 		return 0;
 
 	case TIOCMIWAIT:
-		dbg("%s (%d) TIOCMIWAIT", __func__,  port->number);
+		dev_dbg(&port->dev, "%s TIOCMIWAIT\n", __func__);
 		return wait_modem_info(port, arg);
 	default:
-		dbg("%s not supported = 0x%04x", __func__, cmd);
+		dev_dbg(&port->dev, "%s not supported = 0x%04x\n", __func__, cmd);
 		break;
 	}
 	return -ENOIOCTLCMD;
@@ -658,20 +653,18 @@ static void pl2303_break_ctl(struct tty_struct *tty, int break_state)
 	u16 state;
 	int result;
 
-	dbg("%s - port %d", __func__, port->number);
-
 	if (break_state == 0)
 		state = BREAK_OFF;
 	else
 		state = BREAK_ON;
-	dbg("%s - turning break %s", __func__,
+	dev_dbg(&port->dev, "%s - turning break %s\n", __func__,
 			state == BREAK_OFF ? "off" : "on");
 
 	result = usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),
 				 BREAK_REQUEST, BREAK_REQUEST_TYPE, state,
 				 0, NULL, 0, 100);
 	if (result)
-		dbg("%s - error sending break = %d", __func__, result);
+		dev_err(&port->dev, "error sending break = %d\n", result);
 }
 
 static void pl2303_release(struct usb_serial *serial)
@@ -679,8 +672,6 @@ static void pl2303_release(struct usb_serial *serial)
 	int i;
 	struct pl2303_private *priv;
 
-	dbg("%s", __func__);
-
 	for (i = 0; i < serial->num_ports; ++i) {
 		priv = usb_get_serial_port_data(serial->port[i]);
 		kfree(priv);
@@ -743,8 +734,6 @@ static void pl2303_read_int_callback(struct urb *urb)
 	int status = urb->status;
 	int retval;
 
-	dbg("%s (%d)", __func__, port->number);
-
 	switch (status) {
 	case 0:
 		/* success */
@@ -753,12 +742,12 @@ static void pl2303_read_int_callback(struct urb *urb)
 	case -ENOENT:
 	case -ESHUTDOWN:
 		/* this urb is terminated, clean up */
-		dbg("%s - urb shutting down with status: %d", __func__,
-		    status);
+		dev_dbg(&port->dev, "%s - urb shutting down with status: %d\n",
+			__func__, status);
 		return;
 	default:
-		dbg("%s - nonzero urb status received: %d", __func__,
-		    status);
+		dev_dbg(&port->dev, "%s - nonzero urb status received: %d\n",
+			__func__, status);
 		goto exit;
 	}
 
@@ -770,7 +759,7 @@ static void pl2303_read_int_callback(struct urb *urb)
 exit:
 	retval = usb_submit_urb(urb, GFP_ATOMIC);
 	if (retval)
-		dev_err(&urb->dev->dev,
+		dev_err(&port->dev,
 			"%s - usb_submit_urb failed with result %d\n",
 			__func__, retval);
 }
@@ -808,7 +797,7 @@ static void pl2303_process_read_urb(struct urb *urb)
 		tty_flag = TTY_PARITY;
 	else if (line_status & UART_FRAME_ERROR)
 		tty_flag = TTY_FRAME;
-	dbg("%s - tty_flag = %d", __func__, tty_flag);
+	dev_dbg(&port->dev, "%s - tty_flag = %d\n", __func__, tty_flag);
 
 	/* overrun is special, not associated with a char */
 	if (line_status & UART_OVERRUN_ERROR)

commit 729be47735638c3441f67d8c7e99c20f6086e5df
Author: Johan Hovold <jhovold@gmail.com>
Date:   Wed Apr 25 16:12:09 2012 +0200

    USB: pl2303: remove unused define
    
    Remove unused closing-wait define.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 4917b4e79bb5..c6bb88d5effd 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -38,8 +38,6 @@
 
 static bool debug;
 
-#define PL2303_CLOSING_WAIT	(30*HZ)
-
 static const struct usb_device_id id_table[] = {
 	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID) },
 	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_RSAQ2) },

commit 6f1efd6c5aa63ddcfe1ffc60ade716f5421766f4
Author: Johan Hovold <jhovold@gmail.com>
Date:   Wed Apr 25 15:56:31 2012 +0200

    USB: pl2303: fix abuse of interface data
    
    Fix abuse of interface data which was used to signal device disconnect.
    
    Use the usb_serial disconnect flag and mutex where appropriate.
    
    Note that tiocmget does not need to check for disconnect as it does not
    access the device.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index a1a9062954c4..4917b4e79bb5 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -523,12 +523,11 @@ static int pl2303_tiocmset(struct tty_struct *tty,
 			   unsigned int set, unsigned int clear)
 {
 	struct usb_serial_port *port = tty->driver_data;
+	struct usb_serial *serial = port->serial;
 	struct pl2303_private *priv = usb_get_serial_port_data(port);
 	unsigned long flags;
 	u8 control;
-
-	if (!usb_get_intfdata(port->serial->interface))
-		return -ENODEV;
+	int ret;
 
 	spin_lock_irqsave(&priv->lock, flags);
 	if (set & TIOCM_RTS)
@@ -542,7 +541,14 @@ static int pl2303_tiocmset(struct tty_struct *tty,
 	control = priv->line_control;
 	spin_unlock_irqrestore(&priv->lock, flags);
 
-	return set_control_lines(port->serial->dev, control);
+	mutex_lock(&serial->disc_mutex);
+	if (!serial->disconnected)
+		ret = set_control_lines(serial->dev, control);
+	else
+		ret = -ENODEV;
+	mutex_unlock(&serial->disc_mutex);
+
+	return ret;
 }
 
 static int pl2303_tiocmget(struct tty_struct *tty)
@@ -556,9 +562,6 @@ static int pl2303_tiocmget(struct tty_struct *tty)
 
 	dbg("%s (%d)", __func__, port->number);
 
-	if (!usb_get_intfdata(port->serial->interface))
-		return -ENODEV;
-
 	spin_lock_irqsave(&priv->lock, flags);
 	mcr = priv->line_control;
 	status = priv->line_status;

commit ce5c9851855bab190c9a142761d54ba583ab094c
Author: Johan Hovold <jhovold@gmail.com>
Date:   Fri Mar 23 15:23:18 2012 +0100

    USB: pl2303: fix DTR/RTS being raised on baud rate change
    
    DTR/RTS should only be raised when changing baudrate from B0 and not on
    any baud rate change (> B0).
    
    Reported-by: Søren Holm <sgh@sgh.dk>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index ff4a174fa5de..a1a9062954c4 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -420,7 +420,7 @@ static void pl2303_set_termios(struct tty_struct *tty,
 	control = priv->line_control;
 	if ((cflag & CBAUD) == B0)
 		priv->line_control &= ~(CONTROL_DTR | CONTROL_RTS);
-	else
+	else if ((old_termios->c_cflag & CBAUD) == B0)
 		priv->line_control |= (CONTROL_DTR | CONTROL_RTS);
 	if (control != priv->line_control) {
 		control = priv->line_control;

commit d1cddb4a8e9b09c33158acae05c48069d74fa4d0
Author: Greg KH <gregkh@linuxfoundation.org>
Date:   Fri Feb 24 15:38:14 2012 -0800

    USB: create module_usb_serial_driver macro
    
    Now that Alan Stern has cleaned up the usb serial driver registration,
    we have the ability to create a module_usb_serial_driver macro to make
    things a bit simpler, like the other *_driver macros created.
    
    But, as we need two functions here, we can't reuse the existing
    module_driver() macro, so we need to roll our own.
    
    Here's a patch implementing module_usb_serial_driver() and it converts
    the pl2303 driver to use it, showing a nice cleanup.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index cc65d810c8f5..ff4a174fa5de 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -855,23 +855,7 @@ static struct usb_serial_driver * const serial_drivers[] = {
 	&pl2303_device, NULL
 };
 
-static int __init pl2303_init(void)
-{
-	int retval;
-
-	retval = usb_serial_register_drivers(&pl2303_driver, serial_drivers);
-	if (retval == 0)
-		printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_DESC "\n");
-	return retval;
-}
-
-static void __exit pl2303_exit(void)
-{
-	usb_serial_deregister_drivers(&pl2303_driver, serial_drivers);
-}
-
-module_init(pl2303_init);
-module_exit(pl2303_exit);
+module_usb_serial_driver(pl2303_driver, serial_drivers);
 
 MODULE_DESCRIPTION(DRIVER_DESC);
 MODULE_LICENSE("GPL");

commit f667ddad41e303ebc2c6d5bf3105dffe2fbdd717
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Thu Feb 23 14:57:18 2012 -0500

    usb-serial: use new registration API in [n-p]* drivers
    
    This patch (as1527) modifies the following usb-serial drivers to
    utilize the new usb_serial_{de}register_drivers() routines:
    
            navman, omninet, opticon, option, oti6858, and pl2303.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 3d8cda57ce7a..cc65d810c8f5 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -104,7 +104,6 @@ static struct usb_driver pl2303_driver = {
 	.id_table =	id_table,
 	.suspend =      usb_serial_suspend,
 	.resume =       usb_serial_resume,
-	.no_dynamic_id = 	1,
 	.supports_autosuspend =	1,
 };
 
@@ -834,7 +833,6 @@ static struct usb_serial_driver pl2303_device = {
 		.name =		"pl2303",
 	},
 	.id_table =		id_table,
-	.usb_driver = 		&pl2303_driver,
 	.num_ports =		1,
 	.bulk_in_size =		256,
 	.bulk_out_size =	256,
@@ -853,28 +851,23 @@ static struct usb_serial_driver pl2303_device = {
 	.release =		pl2303_release,
 };
 
+static struct usb_serial_driver * const serial_drivers[] = {
+	&pl2303_device, NULL
+};
+
 static int __init pl2303_init(void)
 {
 	int retval;
 
-	retval = usb_serial_register(&pl2303_device);
-	if (retval)
-		goto failed_usb_serial_register;
-	retval = usb_register(&pl2303_driver);
-	if (retval)
-		goto failed_usb_register;
-	printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_DESC "\n");
-	return 0;
-failed_usb_register:
-	usb_serial_deregister(&pl2303_device);
-failed_usb_serial_register:
+	retval = usb_serial_register_drivers(&pl2303_driver, serial_drivers);
+	if (retval == 0)
+		printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_DESC "\n");
 	return retval;
 }
 
 static void __exit pl2303_exit(void)
 {
-	usb_deregister(&pl2303_driver);
-	usb_serial_deregister(&pl2303_device);
+	usb_serial_deregister_drivers(&pl2303_driver, serial_drivers);
 }
 
 module_init(pl2303_init);

commit 90ab5ee94171b3e28de6bb42ee30b527014e0be7
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Fri Jan 13 09:32:20 2012 +1030

    module_param: make bool parameters really bool (drivers & misc)
    
    module_param(bool) used to counter-intuitively take an int.  In
    fddd5201 (mid-2009) we allowed bool or int/unsigned int using a messy
    trick.
    
    It's time to remove the int/unsigned int option.  For this version
    it'll simply give a warning, but it'll break next kernel version.
    
    Acked-by: Mauro Carvalho Chehab <mchehab@redhat.com>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 329295615d06..3d8cda57ce7a 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -36,7 +36,7 @@
  */
 #define DRIVER_DESC "Prolific PL2303 USB to serial adaptor driver"
 
-static int debug;
+static bool debug;
 
 #define PL2303_CLOSING_WAIT	(30*HZ)
 

commit 47b649590dbbea182f854d6470ee1cd59b7b7684
Merge: 3af5154a869b caca6a03d365
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Sat Nov 26 19:46:19 2011 -0800

    Merge 3.2-rc3 into usb-linus
    
    This pulls in the latest USB bugfixes and helps a few of the drivers
    merge nicer in the future due to changes in both branches.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit f5230a53c1d551811b077ccad219105786da1bec
Author: Johan Hovold <jhovold@gmail.com>
Date:   Sun Nov 6 19:06:36 2011 +0100

    USB: pl2303: use usb_serial_generic_open
    
    Use generic open rather than calling usb_serial_submit_read_urb
    directly.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 9fdc944ff48d..56aa1e6cc380 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -511,7 +511,7 @@ static int pl2303_open(struct tty_struct *tty, struct usb_serial_port *port)
 		return result;
 	}
 
-	result = usb_serial_generic_submit_read_urb(port, GFP_KERNEL);
+	result = usb_serial_generic_open(tty, port);
 	if (result) {
 		usb_kill_urb(port->interrupt_in_urb);
 		return result;

commit d4691c3fa3d371835b1eacb39066ab113c4b9d8c
Author: Johan Hovold <jhovold@gmail.com>
Date:   Sun Nov 6 19:06:35 2011 +0100

    USB: pl2302: clean up error handling in open
    
    Reorder urb submission and simply kill interrupt urb should read-urb
    submission fail (rather than calling close).
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 506d1e930c3e..9fdc944ff48d 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -503,21 +503,20 @@ static int pl2303_open(struct tty_struct *tty, struct usb_serial_port *port)
 	if (tty)
 		pl2303_set_termios(tty, port, &tmp_termios);
 
-	dbg("%s - submitting read urb", __func__);
-	result = usb_serial_generic_submit_read_urb(port, GFP_KERNEL);
-	if (result) {
-		pl2303_close(port);
-		return result;
-	}
-
 	dbg("%s - submitting interrupt urb", __func__);
 	result = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);
 	if (result) {
 		dev_err(&port->dev, "%s - failed submitting interrupt urb,"
 			" error %d\n", __func__, result);
-		pl2303_close(port);
 		return result;
 	}
+
+	result = usb_serial_generic_submit_read_urb(port, GFP_KERNEL);
+	if (result) {
+		usb_kill_urb(port->interrupt_in_urb);
+		return result;
+	}
+
 	port->port.drain_delay = 256;
 	return 0;
 }

commit db6e9186c90188edea20aaa5161ea073440cc2a1
Author: Johan Hovold <jhovold@gmail.com>
Date:   Sun Nov 6 19:06:34 2011 +0100

    USB: pl2303: return errors from usb_submit_urb in open
    
    Return errors from usb_submit_urb rather than EPROTO on errors in open.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 9083d1e616b4..506d1e930c3e 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -507,7 +507,7 @@ static int pl2303_open(struct tty_struct *tty, struct usb_serial_port *port)
 	result = usb_serial_generic_submit_read_urb(port, GFP_KERNEL);
 	if (result) {
 		pl2303_close(port);
-		return -EPROTO;
+		return result;
 	}
 
 	dbg("%s - submitting interrupt urb", __func__);
@@ -516,7 +516,7 @@ static int pl2303_open(struct tty_struct *tty, struct usb_serial_port *port)
 		dev_err(&port->dev, "%s - failed submitting interrupt urb,"
 			" error %d\n", __func__, result);
 		pl2303_close(port);
-		return -EPROTO;
+		return result;
 	}
 	port->port.drain_delay = 256;
 	return 0;

commit 0c16595539b612fe948559433dda08ff96a8bdc7
Author: wangyanqing <udknight@gmail.com>
Date:   Thu Nov 10 14:04:08 2011 +0800

    USB: serial: pl2303: rm duplicate id
    
    I get report from customer that his usb-serial
    converter doesn't work well,it sometimes work,
    but sometimes it doesn't.
    
    The usb-serial converter's id:
    vendor_id product_id
    0x4348    0x5523
    
    Then I search the usb-serial codes, and there are
    two drivers announce support this device, pl2303
    and ch341, commit 026dfaf1 cause it. Through many
    times to test, ch341 works well with this device,
    and pl2303 doesn't work quite often(it just work quite little).
    
    ch341 works well with this device, so we doesn't
    need pl2303 to support.I try to revert 026dfaf1 first,
    but it failed. So I prepare this patch by hand to revert it.
    
    Signed-off-by: Wang YanQing <Udknight@gmail.com>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 9083d1e616b4..fc2d66f7f4eb 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -91,7 +91,6 @@ static const struct usb_device_id id_table[] = {
 	{ USB_DEVICE(SONY_VENDOR_ID, SONY_QN3USB_PRODUCT_ID) },
 	{ USB_DEVICE(SANWA_VENDOR_ID, SANWA_PRODUCT_ID) },
 	{ USB_DEVICE(ADLINK_VENDOR_ID, ADLINK_ND6530_PRODUCT_ID) },
-	{ USB_DEVICE(WINCHIPHEAD_VENDOR_ID, WINCHIPHEAD_USBSER_PRODUCT_ID) },
 	{ USB_DEVICE(SMART_VENDOR_ID, SMART_PRODUCT_ID) },
 	{ }					/* Terminating entry */
 };

commit 598f0b703506da841d3459dc0c48506be14d1778
Author: Eric Benoit <eric@ecks.ca>
Date:   Sat Sep 24 02:04:50 2011 -0400

    USB: pl2303: add id for SMART device
    
    Add vendor and product ID for the SMART USB to serial adapter. These
    were meant to be used with their SMART Board whiteboards, but can be
    re-purposed for other tasks. Tested and working (at at least 9600 bps).
    
    Signed-off-by: Eric Benoit <eric@ecks.ca>
    Cc: stable <stable@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 0ae840f789a4..9083d1e616b4 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -92,6 +92,7 @@ static const struct usb_device_id id_table[] = {
 	{ USB_DEVICE(SANWA_VENDOR_ID, SANWA_PRODUCT_ID) },
 	{ USB_DEVICE(ADLINK_VENDOR_ID, ADLINK_ND6530_PRODUCT_ID) },
 	{ USB_DEVICE(WINCHIPHEAD_VENDOR_ID, WINCHIPHEAD_USBSER_PRODUCT_ID) },
+	{ USB_DEVICE(SMART_VENDOR_ID, SMART_PRODUCT_ID) },
 	{ }					/* Terminating entry */
 };
 

commit 55a46269ccedec140e2487a2344e8a247d48b385
Author: Michał Sroczyński <msroczyn@gmail.com>
Date:   Thu Aug 25 19:52:27 2011 +0200

    USB: pl2303: remove unreachable code
    
    Signed-off-by: Michal Sroczynski <msroczyn@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 1d33260de014..0ae840f789a4 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -360,9 +360,6 @@ static void pl2303_set_termios(struct tty_struct *tty,
 				tmp >>= 2;
 				buf[1] <<= 1;
 			}
-			if (tmp > 256) {
-				tmp %= 256;
-			}
 			buf[0] = tmp;
 		}
 	}

commit 026dfaf18973404a01f488d6aa556a8c466e06a4
Author: Wolfgang Denk <wd@denx.de>
Date:   Tue Jul 19 11:25:38 2011 +0200

    USB: serial: add IDs for WinChipHead USB->RS232 adapter
    
    Add ID 4348:5523 for WinChipHead USB->RS 232 adapter with
    Prolifec PL2303 chipset
    
    Signed-off-by: Wolfgang Denk <wd@denx.de>
    Cc: stable <stable@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index ee28115aa9b4..1d33260de014 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -91,6 +91,7 @@ static const struct usb_device_id id_table[] = {
 	{ USB_DEVICE(SONY_VENDOR_ID, SONY_QN3USB_PRODUCT_ID) },
 	{ USB_DEVICE(SANWA_VENDOR_ID, SANWA_PRODUCT_ID) },
 	{ USB_DEVICE(ADLINK_VENDOR_ID, ADLINK_ND6530_PRODUCT_ID) },
+	{ USB_DEVICE(WINCHIPHEAD_VENDOR_ID, WINCHIPHEAD_USBSER_PRODUCT_ID) },
 	{ }					/* Terminating entry */
 };
 

commit 8d48fdf689fed2c73c493e5146d1463689246442
Author: Michał Sroczyński <msroczyn@gmail.com>
Date:   Tue Jul 5 21:53:35 2011 +0200

    USB: PL2303: correctly handle baudrates above 115200
    
    PL2303: correctly handle baudrates above 115200
    
    Signed-off-by: Michal Sroczynski <msroczyn@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 30461fcc2206..ee28115aa9b4 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -342,10 +342,28 @@ static void pl2303_set_termios(struct tty_struct *tty,
 				baud = 6000000;
 		}
 		dbg("%s - baud set = %d", __func__, baud);
-		buf[0] = baud & 0xff;
-		buf[1] = (baud >> 8) & 0xff;
-		buf[2] = (baud >> 16) & 0xff;
-		buf[3] = (baud >> 24) & 0xff;
+		if (baud <= 115200) {
+			buf[0] = baud & 0xff;
+			buf[1] = (baud >> 8) & 0xff;
+			buf[2] = (baud >> 16) & 0xff;
+			buf[3] = (baud >> 24) & 0xff;
+		} else {
+			/* apparently the formula for higher speeds is:
+			 * baudrate = 12M * 32 / (2^buf[1]) / buf[0]
+			 */
+			unsigned tmp = 12*1000*1000*32 / baud;
+			buf[3] = 0x80;
+			buf[2] = 0;
+			buf[1] = (tmp >= 256);
+			while (tmp >= 256) {
+				tmp >>= 2;
+				buf[1] <<= 1;
+			}
+			if (tmp > 256) {
+				tmp %= 256;
+			}
+			buf[0] = tmp;
+		}
 	}
 
 	/* For reference buf[4]=0 is 1 stop bits */

commit 00a0d0d65b61241a718d0aee96f46b9a2d93bf26
Author: Alan Cox <alan@linux.intel.com>
Date:   Mon Feb 14 16:27:06 2011 +0000

    tty: remove filp from the USB tty ioctls
    
    We don't use it so we can trim it from here as we try and stamp the file
    object dependencies out of the serial code.
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index b797992fa54b..30461fcc2206 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -606,7 +606,7 @@ static int wait_modem_info(struct usb_serial_port *port, unsigned int arg)
 	return 0;
 }
 
-static int pl2303_ioctl(struct tty_struct *tty, struct file *file,
+static int pl2303_ioctl(struct tty_struct *tty,
 			unsigned int cmd, unsigned long arg)
 {
 	struct serial_struct ser;

commit 20b9d17715017ae4dd4ec87fabc36d33b9de708e
Author: Alan Cox <alan@linux.intel.com>
Date:   Mon Feb 14 16:26:50 2011 +0000

    tiocmset: kill the file pointer argument
    
    Doing tiocmget was such fun we should do tiocmset as well for the same
    reasons
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 6cb4f503a3f1..b797992fa54b 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -505,7 +505,7 @@ static int pl2303_open(struct tty_struct *tty, struct usb_serial_port *port)
 	return 0;
 }
 
-static int pl2303_tiocmset(struct tty_struct *tty, struct file *file,
+static int pl2303_tiocmset(struct tty_struct *tty,
 			   unsigned int set, unsigned int clear)
 {
 	struct usb_serial_port *port = tty->driver_data;

commit 60b33c133ca0b7c0b6072c87234b63fee6e80558
Author: Alan Cox <alan@linux.intel.com>
Date:   Mon Feb 14 16:26:14 2011 +0000

    tiocmget: kill off the passing of the struct file
    
    We don't actually need this and it causes problems for internal use of
    this functionality. Currently there is a single use of the FILE * pointer.
    That is the serial core which uses it to check tty_hung_up_p. However if
    that is true then IO_ERROR is also already set so the check may be removed.
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 08c9181b8e48..6cb4f503a3f1 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -531,7 +531,7 @@ static int pl2303_tiocmset(struct tty_struct *tty, struct file *file,
 	return set_control_lines(port->serial->dev, control);
 }
 
-static int pl2303_tiocmget(struct tty_struct *tty, struct file *file)
+static int pl2303_tiocmget(struct tty_struct *tty)
 {
 	struct usb_serial_port *port = tty->driver_data;
 	struct pl2303_private *priv = usb_get_serial_port_data(port);

commit d14fc1a74e846d7851f24fc9519fe87dc12a1231
Author: Libor Pechacek <lpechacek@suse.cz>
Date:   Fri Jan 14 14:30:21 2011 +0100

    USB: serial: handle Data Carrier Detect changes
    
    Alan's commit 335f8514f200e63d689113d29cb7253a5c282967 introduced
    .carrier_raised function in several drivers.  That also means
    tty_port_block_til_ready can now suspend the process trying to open the serial
    port when Carrier Detect is low and put it into tty_port.open_wait queue.  We
    need to wake up the process when Carrier Detect goes high and trigger TTY
    hangup when CD goes low.
    
    Some of the devices do not report modem status line changes, or at least we
    don't understand the status message, so for those we remove .carrier_raised
    again.
    
    Signed-off-by: Libor Pechacek <lpechacek@suse.cz>
    Cc: stable <stable@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 45c40e6e9737..08c9181b8e48 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -678,9 +678,11 @@ static void pl2303_update_line_status(struct usb_serial_port *port,
 {
 
 	struct pl2303_private *priv = usb_get_serial_port_data(port);
+	struct tty_struct *tty;
 	unsigned long flags;
 	u8 status_idx = UART_STATE;
 	u8 length = UART_STATE + 1;
+	u8 prev_line_status;
 	u16 idv, idp;
 
 	idv = le16_to_cpu(port->serial->dev->descriptor.idVendor);
@@ -702,11 +704,20 @@ static void pl2303_update_line_status(struct usb_serial_port *port,
 
 	/* Save off the uart status for others to look at */
 	spin_lock_irqsave(&priv->lock, flags);
+	prev_line_status = priv->line_status;
 	priv->line_status = data[status_idx];
 	spin_unlock_irqrestore(&priv->lock, flags);
 	if (priv->line_status & UART_BREAK_ERROR)
 		usb_serial_handle_break(port);
 	wake_up_interruptible(&priv->delta_msr_wait);
+
+	tty = tty_port_tty_get(&port->port);
+	if (!tty)
+		return;
+	if ((priv->line_status ^ prev_line_status) & UART_DCD)
+		usb_serial_handle_dcd_change(port, tty,
+				priv->line_status & UART_DCD);
+	tty_kref_put(tty);
 }
 
 static void pl2303_read_int_callback(struct urb *urb)

commit 96a3e79edff6f41b0f115a82f1a39d66218077a7
Author: Dario Lombardo <dario.lombardo@libero.it>
Date:   Fri Jan 21 15:35:19 2011 +0100

    drivers: update to pl2303 usb-serial to support Motorola cables
    
    Added 0x0307 device id to support Motorola cables to the pl2303 usb
    serial driver. This cable has a modified chip that is a pl2303, but
    declares itself as 0307. Fixed by adding the right device id to the
    supported devices list, assigning it the code labeled
    PL2303_PRODUCT_ID_MOTOROLA.
    
    Signed-off-by: Dario Lombardo <dario.lombardo@libero.it>
    Cc: stable <stable@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 8ae4c6cbc38a..45c40e6e9737 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -50,6 +50,7 @@ static const struct usb_device_id id_table[] = {
 	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_MMX) },
 	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_GPRS) },
 	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_HCR331) },
+	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_MOTOROLA) },
 	{ USB_DEVICE(IODATA_VENDOR_ID, IODATA_PRODUCT_ID) },
 	{ USB_DEVICE(IODATA_VENDOR_ID, IODATA_PRODUCT_ID_RSAQ5) },
 	{ USB_DEVICE(ATEN_VENDOR_ID, ATEN_PRODUCT_ID) },

commit 2637d139fb9a1bd428a003b7671fda40a034854f
Merge: 494e2fbe1f8b 288933c02b44
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Aug 28 13:55:31 2010 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/dtor/input
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/dtor/input:
      Input: pxa27x_keypad - remove input_free_device() in pxa27x_keypad_remove()
      Input: mousedev - fix regression of inverting axes
      Input: uinput - add devname alias to allow module on-demand load
      Input: hil_kbd - fix compile error
      USB: drop tty argument from usb_serial_handle_sysrq_char()
      Input: sysrq - drop tty argument form handle_sysrq()
      Input: sysrq - drop tty argument from sysrq ops handlers

commit f36ecd5de93e4c85a9e3d25100c6e233155b12e5
Author: Jef Driesen <jefdriesen@telenet.be>
Date:   Mon Aug 9 15:55:32 2010 +0200

    USB: pl2303: New vendor and product id
    
    Add support for the Zeagle N2iTiON3 dive computer interface. Since
    Zeagle devices are actually manufactured by Seiko, this patch will
    support other Seiko based models as well.
    
    Signed-off-by: Jef Driesen <jefdriesen@telenet.be>
    Cc: stable <stable@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 6b6001822279..c98f0fb675ba 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -86,6 +86,7 @@ static const struct usb_device_id id_table[] = {
 	{ USB_DEVICE(SUPERIAL_VENDOR_ID, SUPERIAL_PRODUCT_ID) },
 	{ USB_DEVICE(HP_VENDOR_ID, HP_LD220_PRODUCT_ID) },
 	{ USB_DEVICE(CRESSI_VENDOR_ID, CRESSI_EDY_PRODUCT_ID) },
+	{ USB_DEVICE(ZEAGLE_VENDOR_ID, ZEAGLE_N2ITION3_PRODUCT_ID) },
 	{ USB_DEVICE(SONY_VENDOR_ID, SONY_QN3USB_PRODUCT_ID) },
 	{ USB_DEVICE(SANWA_VENDOR_ID, SANWA_PRODUCT_ID) },
 	{ USB_DEVICE(ADLINK_VENDOR_ID, ADLINK_ND6530_PRODUCT_ID) },

commit 6ee9f4b4affe751d313d2538999aeec134d413a6
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Tue Aug 17 21:15:47 2010 -0700

    USB: drop tty argument from usb_serial_handle_sysrq_char()
    
    Since handle_sysrq() does not take tty as argument anymore we can
    drop it from usb_serial_handle_sysrq_char() as well.
    
    Acked-by: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Acked-by: Jason Wessel <jason.wessel@windriver.com>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 6b6001822279..34ad7b3d5948 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -788,7 +788,7 @@ static void pl2303_process_read_urb(struct urb *urb)
 
 	if (port->port.console && port->sysrq) {
 		for (i = 0; i < urb->actual_length; ++i)
-			if (!usb_serial_handle_sysrq_char(tty, port, data[i]))
+			if (!usb_serial_handle_sysrq_char(port, data[i]))
 				tty_insert_flip_char(tty, data[i], tty_flag);
 	} else {
 		tty_insert_flip_string_fixed_flag(tty, data, tty_flag,

commit d45cc8df7f59eb4db28408076ce979cd5e18f2b7
Author: Johan Hovold <jhovold@gmail.com>
Date:   Sat May 8 15:18:41 2010 +0200

    USB: pl2303: use tty_insert_flip_string_fixed_flag
    
    Use tty_insert_flip_string_fixed_flag to report errors to line
    discipline.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 18d1c44faa51..6b6001822279 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -786,12 +786,13 @@ static void pl2303_process_read_urb(struct urb *urb)
 	if (line_status & UART_OVERRUN_ERROR)
 		tty_insert_flip_char(tty, 0, TTY_OVERRUN);
 
-	if (tty_flag == TTY_NORMAL && !(port->port.console && port->sysrq))
-		tty_insert_flip_string(tty, data, urb->actual_length);
-	else {
+	if (port->port.console && port->sysrq) {
 		for (i = 0; i < urb->actual_length; ++i)
 			if (!usb_serial_handle_sysrq_char(tty, port, data[i]))
 				tty_insert_flip_char(tty, data[i], tty_flag);
+	} else {
+		tty_insert_flip_string_fixed_flag(tty, data, tty_flag,
+							urb->actual_length);
 	}
 
 	tty_flip_buffer_push(tty);

commit 8b0127b2082601e40295045414a8318f2c8ee5a0
Author: Johan Hovold <jhovold@gmail.com>
Date:   Wed Mar 17 23:06:04 2010 +0100

    USB: pl2303: use generic close
    
    Use usb_serial_generic_close to kill the read and write urbs and to
    reset the write fifo.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 28037c1af93e..18d1c44faa51 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -456,21 +456,10 @@ static void pl2303_dtr_rts(struct usb_serial_port *port, int on)
 
 static void pl2303_close(struct usb_serial_port *port)
 {
-	unsigned long flags;
-
 	dbg("%s - port %d", __func__, port->number);
 
-	spin_lock_irqsave(&port->lock, flags);
-	/* clear out any remaining data in the buffer */
-	kfifo_reset_out(&port->write_fifo);
-	spin_unlock_irqrestore(&port->lock, flags);
-
-	/* shutdown our urbs */
-	dbg("%s - shutting down urbs", __func__);
-	usb_kill_urb(port->write_urb);
-	usb_kill_urb(port->read_urb);
+	usb_serial_generic_close(port);
 	usb_kill_urb(port->interrupt_in_urb);
-
 }
 
 static int pl2303_open(struct tty_struct *tty, struct usb_serial_port *port)

commit 684c6e30d389f67ef727c8f5a7b23a09b4cb02e4
Author: Johan Hovold <jhovold@gmail.com>
Date:   Wed Mar 17 23:06:03 2010 +0100

    USB: pl2303: switch to generic write implementation
    
    Replace custom fifo-based write implementation with the generic
    kfifo-based one.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 77e968045f75..28037c1af93e 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -40,16 +40,6 @@ static int debug;
 
 #define PL2303_CLOSING_WAIT	(30*HZ)
 
-#define PL2303_BUF_SIZE		1024
-#define PL2303_TMP_BUF_SIZE	1024
-
-struct pl2303_buf {
-	unsigned int	buf_size;
-	char		*buf_buf;
-	char		*buf_get;
-	char		*buf_put;
-};
-
 static const struct usb_device_id id_table[] = {
 	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID) },
 	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_RSAQ2) },
@@ -157,173 +147,12 @@ enum pl2303_type {
 
 struct pl2303_private {
 	spinlock_t lock;
-	struct pl2303_buf *buf;
-	int write_urb_in_use;
 	wait_queue_head_t delta_msr_wait;
 	u8 line_control;
 	u8 line_status;
 	enum pl2303_type type;
 };
 
-/*
- * pl2303_buf_alloc
- *
- * Allocate a circular buffer and all associated memory.
- */
-static struct pl2303_buf *pl2303_buf_alloc(unsigned int size)
-{
-	struct pl2303_buf *pb;
-
-	if (size == 0)
-		return NULL;
-
-	pb = kmalloc(sizeof(struct pl2303_buf), GFP_KERNEL);
-	if (pb == NULL)
-		return NULL;
-
-	pb->buf_buf = kmalloc(size, GFP_KERNEL);
-	if (pb->buf_buf == NULL) {
-		kfree(pb);
-		return NULL;
-	}
-
-	pb->buf_size = size;
-	pb->buf_get = pb->buf_put = pb->buf_buf;
-
-	return pb;
-}
-
-/*
- * pl2303_buf_free
- *
- * Free the buffer and all associated memory.
- */
-static void pl2303_buf_free(struct pl2303_buf *pb)
-{
-	if (pb) {
-		kfree(pb->buf_buf);
-		kfree(pb);
-	}
-}
-
-/*
- * pl2303_buf_clear
- *
- * Clear out all data in the circular buffer.
- */
-static void pl2303_buf_clear(struct pl2303_buf *pb)
-{
-	if (pb != NULL)
-		pb->buf_get = pb->buf_put;
-		/* equivalent to a get of all data available */
-}
-
-/*
- * pl2303_buf_data_avail
- *
- * Return the number of bytes of data available in the circular
- * buffer.
- */
-static unsigned int pl2303_buf_data_avail(struct pl2303_buf *pb)
-{
-	if (pb == NULL)
-		return 0;
-
-	return (pb->buf_size + pb->buf_put - pb->buf_get) % pb->buf_size;
-}
-
-/*
- * pl2303_buf_space_avail
- *
- * Return the number of bytes of space available in the circular
- * buffer.
- */
-static unsigned int pl2303_buf_space_avail(struct pl2303_buf *pb)
-{
-	if (pb == NULL)
-		return 0;
-
-	return (pb->buf_size + pb->buf_get - pb->buf_put - 1) % pb->buf_size;
-}
-
-/*
- * pl2303_buf_put
- *
- * Copy data data from a user buffer and put it into the circular buffer.
- * Restrict to the amount of space available.
- *
- * Return the number of bytes copied.
- */
-static unsigned int pl2303_buf_put(struct pl2303_buf *pb, const char *buf,
-				   unsigned int count)
-{
-	unsigned int len;
-
-	if (pb == NULL)
-		return 0;
-
-	len  = pl2303_buf_space_avail(pb);
-	if (count > len)
-		count = len;
-
-	if (count == 0)
-		return 0;
-
-	len = pb->buf_buf + pb->buf_size - pb->buf_put;
-	if (count > len) {
-		memcpy(pb->buf_put, buf, len);
-		memcpy(pb->buf_buf, buf+len, count - len);
-		pb->buf_put = pb->buf_buf + count - len;
-	} else {
-		memcpy(pb->buf_put, buf, count);
-		if (count < len)
-			pb->buf_put += count;
-		else /* count == len */
-			pb->buf_put = pb->buf_buf;
-	}
-
-	return count;
-}
-
-/*
- * pl2303_buf_get
- *
- * Get data from the circular buffer and copy to the given buffer.
- * Restrict to the amount of data available.
- *
- * Return the number of bytes copied.
- */
-static unsigned int pl2303_buf_get(struct pl2303_buf *pb, char *buf,
-				   unsigned int count)
-{
-	unsigned int len;
-
-	if (pb == NULL)
-		return 0;
-
-	len = pl2303_buf_data_avail(pb);
-	if (count > len)
-		count = len;
-
-	if (count == 0)
-		return 0;
-
-	len = pb->buf_buf + pb->buf_size - pb->buf_get;
-	if (count > len) {
-		memcpy(buf, pb->buf_get, len);
-		memcpy(buf+len, pb->buf_buf, count - len);
-		pb->buf_get = pb->buf_buf + count - len;
-	} else {
-		memcpy(buf, pb->buf_get, count);
-		if (count < len)
-			pb->buf_get += count;
-		else /* count == len */
-			pb->buf_get = pb->buf_buf;
-	}
-
-	return count;
-}
-
 static int pl2303_vendor_read(__u16 value, __u16 index,
 		struct usb_serial *serial, unsigned char *buf)
 {
@@ -372,11 +201,6 @@ static int pl2303_startup(struct usb_serial *serial)
 		if (!priv)
 			goto cleanup;
 		spin_lock_init(&priv->lock);
-		priv->buf = pl2303_buf_alloc(PL2303_BUF_SIZE);
-		if (priv->buf == NULL) {
-			kfree(priv);
-			goto cleanup;
-		}
 		init_waitqueue_head(&priv->delta_msr_wait);
 		priv->type = type;
 		usb_set_serial_port_data(serial->port[i], priv);
@@ -404,7 +228,6 @@ static int pl2303_startup(struct usb_serial *serial)
 	kfree(buf);
 	for (--i; i >= 0; --i) {
 		priv = usb_get_serial_port_data(serial->port[i]);
-		pl2303_buf_free(priv->buf);
 		kfree(priv);
 		usb_set_serial_port_data(serial->port[i], NULL);
 	}
@@ -422,102 +245,6 @@ static int set_control_lines(struct usb_device *dev, u8 value)
 	return retval;
 }
 
-static void pl2303_send(struct usb_serial_port *port)
-{
-	int count, result;
-	struct pl2303_private *priv = usb_get_serial_port_data(port);
-	unsigned long flags;
-
-	dbg("%s - port %d", __func__, port->number);
-
-	spin_lock_irqsave(&priv->lock, flags);
-
-	if (priv->write_urb_in_use) {
-		spin_unlock_irqrestore(&priv->lock, flags);
-		return;
-	}
-
-	count = pl2303_buf_get(priv->buf, port->write_urb->transfer_buffer,
-			       port->bulk_out_size);
-
-	if (count == 0) {
-		spin_unlock_irqrestore(&priv->lock, flags);
-		return;
-	}
-
-	priv->write_urb_in_use = 1;
-
-	spin_unlock_irqrestore(&priv->lock, flags);
-
-	usb_serial_debug_data(debug, &port->dev, __func__, count,
-			      port->write_urb->transfer_buffer);
-
-	port->write_urb->transfer_buffer_length = count;
-	result = usb_submit_urb(port->write_urb, GFP_ATOMIC);
-	if (result) {
-		dev_err(&port->dev, "%s - failed submitting write urb,"
-			" error %d\n", __func__, result);
-		priv->write_urb_in_use = 0;
-		/* TODO: reschedule pl2303_send */
-	}
-
-	usb_serial_port_softint(port);
-}
-
-static int pl2303_write(struct tty_struct *tty, struct usb_serial_port *port,
-				const unsigned char *buf, int count)
-{
-	struct pl2303_private *priv = usb_get_serial_port_data(port);
-	unsigned long flags;
-
-	dbg("%s - port %d, %d bytes", __func__, port->number, count);
-
-	if (!count)
-		return count;
-
-	spin_lock_irqsave(&priv->lock, flags);
-	count = pl2303_buf_put(priv->buf, buf, count);
-	spin_unlock_irqrestore(&priv->lock, flags);
-
-	pl2303_send(port);
-
-	return count;
-}
-
-static int pl2303_write_room(struct tty_struct *tty)
-{
-	struct usb_serial_port *port = tty->driver_data;
-	struct pl2303_private *priv = usb_get_serial_port_data(port);
-	int room = 0;
-	unsigned long flags;
-
-	dbg("%s - port %d", __func__, port->number);
-
-	spin_lock_irqsave(&priv->lock, flags);
-	room = pl2303_buf_space_avail(priv->buf);
-	spin_unlock_irqrestore(&priv->lock, flags);
-
-	dbg("%s - returns %d", __func__, room);
-	return room;
-}
-
-static int pl2303_chars_in_buffer(struct tty_struct *tty)
-{
-	struct usb_serial_port *port = tty->driver_data;
-	struct pl2303_private *priv = usb_get_serial_port_data(port);
-	int chars = 0;
-	unsigned long flags;
-
-	dbg("%s - port %d", __func__, port->number);
-
-	spin_lock_irqsave(&priv->lock, flags);
-	chars = pl2303_buf_data_avail(priv->buf);
-	spin_unlock_irqrestore(&priv->lock, flags);
-
-	dbg("%s - returns %d", __func__, chars);
-	return chars;
-}
-
 static void pl2303_set_termios(struct tty_struct *tty,
 		struct usb_serial_port *port, struct ktermios *old_termios)
 {
@@ -729,15 +456,14 @@ static void pl2303_dtr_rts(struct usb_serial_port *port, int on)
 
 static void pl2303_close(struct usb_serial_port *port)
 {
-	struct pl2303_private *priv = usb_get_serial_port_data(port);
 	unsigned long flags;
 
 	dbg("%s - port %d", __func__, port->number);
 
-	spin_lock_irqsave(&priv->lock, flags);
+	spin_lock_irqsave(&port->lock, flags);
 	/* clear out any remaining data in the buffer */
-	pl2303_buf_clear(priv->buf);
-	spin_unlock_irqrestore(&priv->lock, flags);
+	kfifo_reset_out(&port->write_fifo);
+	spin_unlock_irqrestore(&port->lock, flags);
 
 	/* shutdown our urbs */
 	dbg("%s - shutting down urbs", __func__);
@@ -951,10 +677,7 @@ static void pl2303_release(struct usb_serial *serial)
 
 	for (i = 0; i < serial->num_ports; ++i) {
 		priv = usb_get_serial_port_data(serial->port[i]);
-		if (priv) {
-			pl2303_buf_free(priv->buf);
-			kfree(priv);
-		}
+		kfree(priv);
 	}
 }
 
@@ -1086,47 +809,6 @@ static void pl2303_process_read_urb(struct urb *urb)
 	tty_kref_put(tty);
 }
 
-static void pl2303_write_bulk_callback(struct urb *urb)
-{
-	struct usb_serial_port *port =  urb->context;
-	struct pl2303_private *priv = usb_get_serial_port_data(port);
-	int result;
-	int status = urb->status;
-
-	dbg("%s - port %d", __func__, port->number);
-
-	switch (status) {
-	case 0:
-		/* success */
-		break;
-	case -ECONNRESET:
-	case -ENOENT:
-	case -ESHUTDOWN:
-		/* this urb is terminated, clean up */
-		dbg("%s - urb shutting down with status: %d", __func__,
-		    status);
-		priv->write_urb_in_use = 0;
-		return;
-	default:
-		/* error in the urb, so we have to resubmit it */
-		dbg("%s - Overflow in write", __func__);
-		dbg("%s - nonzero write bulk status received: %d", __func__,
-		    status);
-		port->write_urb->transfer_buffer_length = 1;
-		result = usb_submit_urb(port->write_urb, GFP_ATOMIC);
-		if (result)
-			dev_err(&urb->dev->dev, "%s - failed resubmitting write"
-				" urb, error %d\n", __func__, result);
-		else
-			return;
-	}
-
-	priv->write_urb_in_use = 0;
-
-	/* send any buffered data */
-	pl2303_send(port);
-}
-
 /* All of the device info needed for the PL2303 SIO serial converter */
 static struct usb_serial_driver pl2303_device = {
 	.driver = {
@@ -1142,7 +824,6 @@ static struct usb_serial_driver pl2303_device = {
 	.close =		pl2303_close,
 	.dtr_rts = 		pl2303_dtr_rts,
 	.carrier_raised =	pl2303_carrier_raised,
-	.write =		pl2303_write,
 	.ioctl =		pl2303_ioctl,
 	.break_ctl =		pl2303_break_ctl,
 	.set_termios =		pl2303_set_termios,
@@ -1150,9 +831,6 @@ static struct usb_serial_driver pl2303_device = {
 	.tiocmset =		pl2303_tiocmset,
 	.process_read_urb =	pl2303_process_read_urb,
 	.read_int_callback =	pl2303_read_int_callback,
-	.write_bulk_callback =	pl2303_write_bulk_callback,
-	.write_room =		pl2303_write_room,
-	.chars_in_buffer =	pl2303_chars_in_buffer,
 	.attach =		pl2303_startup,
 	.release =		pl2303_release,
 };

commit f08e07ac8b87b1a4b8ff88a061195e99282dfbbd
Author: Johan Hovold <jhovold@gmail.com>
Date:   Wed Mar 17 23:05:58 2010 +0100

    USB: pl2303: switch to generic read implementation
    
    Use generic read implementation and use process_read_urb to do device
    specific processing (handle line status).
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 7aff62260fd4..77e968045f75 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -770,10 +770,8 @@ static int pl2303_open(struct tty_struct *tty, struct usb_serial_port *port)
 		pl2303_set_termios(tty, port, &tmp_termios);
 
 	dbg("%s - submitting read urb", __func__);
-	result = usb_submit_urb(port->read_urb, GFP_KERNEL);
+	result = usb_serial_generic_submit_read_urb(port, GFP_KERNEL);
 	if (result) {
-		dev_err(&port->dev, "%s - failed submitting read urb,"
-			" error %d\n", __func__, result);
 		pl2303_close(port);
 		return -EPROTO;
 	}
@@ -1037,13 +1035,31 @@ static void pl2303_read_int_callback(struct urb *urb)
 			__func__, retval);
 }
 
-static void pl2303_push_data(struct tty_struct *tty,
-		struct usb_serial_port *port, struct urb *urb,
-		u8 line_status)
+static void pl2303_process_read_urb(struct urb *urb)
 {
+	struct usb_serial_port *port = urb->context;
+	struct pl2303_private *priv = usb_get_serial_port_data(port);
+	struct tty_struct *tty;
 	unsigned char *data = urb->transfer_buffer;
-	/* get tty_flag from status */
 	char tty_flag = TTY_NORMAL;
+	unsigned long flags;
+	u8 line_status;
+	int i;
+
+	/* update line status */
+	spin_lock_irqsave(&priv->lock, flags);
+	line_status = priv->line_status;
+	priv->line_status &= ~UART_STATE_TRANSIENT_MASK;
+	spin_unlock_irqrestore(&priv->lock, flags);
+	wake_up_interruptible(&priv->delta_msr_wait);
+
+	if (!urb->actual_length)
+		return;
+
+	tty = tty_port_tty_get(&port->port);
+	if (!tty)
+		return;
+
 	/* break takes precedence over parity, */
 	/* which takes precedence over framing errors */
 	if (line_status & UART_BREAK_ERROR)
@@ -1061,63 +1077,13 @@ static void pl2303_push_data(struct tty_struct *tty,
 	if (tty_flag == TTY_NORMAL && !(port->port.console && port->sysrq))
 		tty_insert_flip_string(tty, data, urb->actual_length);
 	else {
-		int i;
 		for (i = 0; i < urb->actual_length; ++i)
 			if (!usb_serial_handle_sysrq_char(tty, port, data[i]))
 				tty_insert_flip_char(tty, data[i], tty_flag);
 	}
-	tty_flip_buffer_push(tty);
-}
-
-static void pl2303_read_bulk_callback(struct urb *urb)
-{
-	struct usb_serial_port *port =  urb->context;
-	struct pl2303_private *priv = usb_get_serial_port_data(port);
-	struct tty_struct *tty;
-	unsigned long flags;
-	int result;
-	int status = urb->status;
-	u8 line_status;
-
-	dbg("%s - port %d", __func__, port->number);
-
-	if (status) {
-		dbg("%s - urb status = %d", __func__, status);
-		if (status == -EPROTO) {
-			/* PL2303 mysteriously fails with -EPROTO reschedule
-			 * the read */
-			dbg("%s - caught -EPROTO, resubmitting the urb",
-			    __func__);
-			result = usb_submit_urb(urb, GFP_ATOMIC);
-			if (result)
-				dev_err(&urb->dev->dev, "%s - failed"
-					" resubmitting read urb, error %d\n",
-					__func__, result);
-			return;
-		}
-		dbg("%s - unable to handle the error, exiting.", __func__);
-		return;
-	}
 
-	usb_serial_debug_data(debug, &port->dev, __func__,
-			      urb->actual_length, urb->transfer_buffer);
-
-	spin_lock_irqsave(&priv->lock, flags);
-	line_status = priv->line_status;
-	priv->line_status &= ~UART_STATE_TRANSIENT_MASK;
-	spin_unlock_irqrestore(&priv->lock, flags);
-	wake_up_interruptible(&priv->delta_msr_wait);
-
-	tty = tty_port_tty_get(&port->port);
-	if (tty && urb->actual_length) {
-		pl2303_push_data(tty, port, urb, line_status);
-	}
+	tty_flip_buffer_push(tty);
 	tty_kref_put(tty);
-	/* Schedule the next read _if_ we are still open */
-	result = usb_submit_urb(urb, GFP_ATOMIC);
-	if (result && result != -EPERM)
-		dev_err(&urb->dev->dev, "%s - failed resubmitting"
-			" read urb, error %d\n", __func__, result);
 }
 
 static void pl2303_write_bulk_callback(struct urb *urb)
@@ -1182,7 +1148,7 @@ static struct usb_serial_driver pl2303_device = {
 	.set_termios =		pl2303_set_termios,
 	.tiocmget =		pl2303_tiocmget,
 	.tiocmset =		pl2303_tiocmset,
-	.read_bulk_callback =	pl2303_read_bulk_callback,
+	.process_read_urb =	pl2303_process_read_urb,
 	.read_int_callback =	pl2303_read_int_callback,
 	.write_bulk_callback =	pl2303_write_bulk_callback,
 	.write_room =		pl2303_write_room,

commit 7919c2fd9e07276403b9a4d9ae52305e0d70f923
Author: Johan Hovold <jhovold@gmail.com>
Date:   Wed Mar 17 23:00:41 2010 +0100

    USB: pl2303: increase bulk-in buffer size to 256 byte
    
    The pl2303 requires a bulk-in buffer larger than endpoint size to keep
    up at high baudrates without loosing data.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 03fe472fee32..7aff62260fd4 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -1170,6 +1170,7 @@ static struct usb_serial_driver pl2303_device = {
 	.id_table =		id_table,
 	.usb_driver = 		&pl2303_driver,
 	.num_ports =		1,
+	.bulk_in_size =		256,
 	.bulk_out_size =	256,
 	.open =			pl2303_open,
 	.close =		pl2303_close,

commit 3efeaff6298290b36499532f0b4c87aa4bae8aef
Author: Johan Hovold <jhovold@gmail.com>
Date:   Wed Mar 17 23:00:40 2010 +0100

    USB: pl2303: increase the bulk-out buffer size to 256 byte
    
    Increase the bulk-out buffer size from 64 to 256 byte.
    
    This gives a significant increase in throughput already at 1Mbaud as well
    as lowered CPU usage. The buffer is big enough to keep up also at 3Mbaud
    (128b would not suffice).
    
            64b         256b
    921k:   640 KB/s    870 KB/s
    3M:     640 KB/s    2520 KB/s
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index b10b0efe3e06..03fe472fee32 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -1170,6 +1170,7 @@ static struct usb_serial_driver pl2303_device = {
 	.id_table =		id_table,
 	.usb_driver = 		&pl2303_driver,
 	.num_ports =		1,
+	.bulk_out_size =	256,
 	.open =			pl2303_open,
 	.close =		pl2303_close,
 	.dtr_rts = 		pl2303_dtr_rts,

commit bd5afa9eac6daa408412a31a6c69e87e8bd28c7e
Author: Jason Wessel <jason.wessel@windriver.com>
Date:   Mon Mar 8 21:50:12 2010 -0600

    usb-serial: Use tty_port version console instead of usb_serial_port
    
    Replace all instances of using the console variable in struct
    usb_serial_port with the struct tty_port version.
    
    CC: Alan Cox <alan@linux.intel.com>
    CC: Alan Stern <stern@rowland.harvard.edu>
    CC: Oliver Neukum <oliver@neukum.org>
    CC: Andrew Morton <akpm@linux-foundation.org>
    CC: linux-usb@vger.kernel.org
    CC: linux-kernel@vger.kernel.org
    Signed-off-by: Jason Wessel <jason.wessel@windriver.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index c28b1607eacc..b10b0efe3e06 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -1058,7 +1058,7 @@ static void pl2303_push_data(struct tty_struct *tty,
 	if (line_status & UART_OVERRUN_ERROR)
 		tty_insert_flip_char(tty, 0, TTY_OVERRUN);
 
-	if (tty_flag == TTY_NORMAL && !(port->console && port->sysrq))
+	if (tty_flag == TTY_NORMAL && !(port->port.console && port->sysrq))
 		tty_insert_flip_string(tty, data, urb->actual_length);
 	else {
 		int i;

commit 18344a1cd5889d48dac67229fcf024ed300030d5
Author: Simone Contini <s.contini@oltrelinux.com>
Date:   Mon Apr 12 23:25:10 2010 +0200

    USB: serial: pl2303: Hybrid reader Uniform HCR331
    
    I tried a magnetic stripe reader
    (http://www.kimaldi.com/kimaldi_eng/productos/lectores_de_tarjetas/lectores_tarjeta_chip_y_dni/lector_hibrido_uniform_hcr_331)
    and I see that it is interfaced with a PL2303. I wrote a patch to use
    your driver which simply adds the product ID for the device and it
    seems working fine.
    
    
    From: Simone Contini <s.contini@oltrelinux.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index c97a0bb5b6db..c28b1607eacc 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -59,6 +59,7 @@ static const struct usb_device_id id_table[] = {
 	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_ALDIGA) },
 	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_MMX) },
 	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_GPRS) },
+	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_HCR331) },
 	{ USB_DEVICE(IODATA_VENDOR_ID, IODATA_PRODUCT_ID) },
 	{ USB_DEVICE(IODATA_VENDOR_ID, IODATA_PRODUCT_ID_RSAQ5) },
 	{ USB_DEVICE(ATEN_VENDOR_ID, ATEN_PRODUCT_ID) },

commit 9a61d72602771906e11a5944e8571f8006387b39
Author: Manuel Jander <manuel.jander@gmail.com>
Date:   Mon Mar 29 23:51:57 2010 +0200

    USB: pl2303: add AdLink ND-6530 USB IDs
    
    I read a rumor that the AdLink ND6530 USB RS232, RS422 and RS485
    isolated adapter is actually a PL2303 based usb serial adapter. I
    tried it out, and as far as I can tell it works.
    
    Signed-off-by: Manuel Jander <manuel.jander@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 73d5f346d3e0..c97a0bb5b6db 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -97,6 +97,7 @@ static const struct usb_device_id id_table[] = {
 	{ USB_DEVICE(CRESSI_VENDOR_ID, CRESSI_EDY_PRODUCT_ID) },
 	{ USB_DEVICE(SONY_VENDOR_ID, SONY_QN3USB_PRODUCT_ID) },
 	{ USB_DEVICE(SANWA_VENDOR_ID, SANWA_PRODUCT_ID) },
+	{ USB_DEVICE(ADLINK_VENDOR_ID, ADLINK_ND6530_PRODUCT_ID) },
 	{ }					/* Terminating entry */
 };
 

commit 124d255382ddd37ffa920e9f5183efa54bbfe4f2
Author: Johan Hovold <jhovold@gmail.com>
Date:   Thu Feb 25 20:52:30 2010 +0100

    USB: pl2303: remove unnecessary reset of usb_device in urbs
    
    URBs are initialised at probe and do not change.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 895d0722183e..73d5f346d3e0 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -451,7 +451,6 @@ static void pl2303_send(struct usb_serial_port *port)
 			      port->write_urb->transfer_buffer);
 
 	port->write_urb->transfer_buffer_length = count;
-	port->write_urb->dev = port->serial->dev;
 	result = usb_submit_urb(port->write_urb, GFP_ATOMIC);
 	if (result) {
 		dev_err(&port->dev, "%s - failed submitting write urb,"
@@ -769,7 +768,6 @@ static int pl2303_open(struct tty_struct *tty, struct usb_serial_port *port)
 		pl2303_set_termios(tty, port, &tmp_termios);
 
 	dbg("%s - submitting read urb", __func__);
-	port->read_urb->dev = serial->dev;
 	result = usb_submit_urb(port->read_urb, GFP_KERNEL);
 	if (result) {
 		dev_err(&port->dev, "%s - failed submitting read urb,"
@@ -779,7 +777,6 @@ static int pl2303_open(struct tty_struct *tty, struct usb_serial_port *port)
 	}
 
 	dbg("%s - submitting interrupt urb", __func__);
-	port->interrupt_in_urb->dev = serial->dev;
 	result = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);
 	if (result) {
 		dev_err(&port->dev, "%s - failed submitting interrupt urb,"
@@ -1089,7 +1086,6 @@ static void pl2303_read_bulk_callback(struct urb *urb)
 			 * the read */
 			dbg("%s - caught -EPROTO, resubmitting the urb",
 			    __func__);
-			urb->dev = port->serial->dev;
 			result = usb_submit_urb(urb, GFP_ATOMIC);
 			if (result)
 				dev_err(&urb->dev->dev, "%s - failed"
@@ -1116,7 +1112,6 @@ static void pl2303_read_bulk_callback(struct urb *urb)
 	}
 	tty_kref_put(tty);
 	/* Schedule the next read _if_ we are still open */
-	urb->dev = port->serial->dev;
 	result = usb_submit_urb(urb, GFP_ATOMIC);
 	if (result && result != -EPERM)
 		dev_err(&urb->dev->dev, "%s - failed resubmitting"
@@ -1150,7 +1145,6 @@ static void pl2303_write_bulk_callback(struct urb *urb)
 		dbg("%s - nonzero write bulk status received: %d", __func__,
 		    status);
 		port->write_urb->transfer_buffer_length = 1;
-		port->write_urb->dev = port->serial->dev;
 		result = usb_submit_urb(port->write_urb, GFP_ATOMIC);
 		if (result)
 			dev_err(&urb->dev->dev, "%s - failed resubmitting write"

commit 67b9946dd07eeef8188e4cab816d2c370bcaa7b2
Author: John Tsiombikas <nuclear@member.fsf.org>
Date:   Thu Feb 25 17:09:08 2010 +0200

    USB: pl2303: initial TIOCGSERIAL support
    
    I've got a trivial patch for the pl2303 driver, that's what I needed to
    make the wacom serial tablet driver work properly. It uses the
    TIOCGSERIAL ioctl to determine if it's talking to a serial device or
    not, which I gather is rather common, but the pl2303 driver didn't
    implement that ioctl.
    
    Here's a patch, I'm not sure it's absolutely correct, I mostly looked at
    other similar usbserial drivers to see what I must do, but it works for
    me.
    
    Signed-off-by: John Tsiombikas <nuclear@member.fsf.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 571dcf182866..895d0722183e 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -895,10 +895,23 @@ static int wait_modem_info(struct usb_serial_port *port, unsigned int arg)
 static int pl2303_ioctl(struct tty_struct *tty, struct file *file,
 			unsigned int cmd, unsigned long arg)
 {
+	struct serial_struct ser;
 	struct usb_serial_port *port = tty->driver_data;
 	dbg("%s (%d) cmd = 0x%04x", __func__, port->number, cmd);
 
 	switch (cmd) {
+	case TIOCGSERIAL:
+		memset(&ser, 0, sizeof ser);
+		ser.type = PORT_16654;
+		ser.line = port->serial->minor;
+		ser.port = port->number;
+		ser.baud_base = 460800;
+
+		if (copy_to_user((void __user *)arg, &ser, sizeof ser))
+			return -EFAULT;
+
+		return 0;
+
 	case TIOCMIWAIT:
 		dbg("%s (%d) TIOCMIWAIT", __func__,  port->number);
 		return wait_modem_info(port, arg);

commit 1f87158e44e79e62c8250f278c225ce4ab695f4b
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Feb 17 10:05:47 2010 -0500

    USB: remove references to port->port.count from the serial drivers
    
    This patch (as1344) removes references to port->port.count from the
    USB serial drivers.  Now that serial ports are properly reference
    counted, port.count checking is unnecessary and incorrect.  Drivers
    should assume that the port is in use from the time the open method
    runs until the close method is called.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index a3e5a56dc066..571dcf182866 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -1071,10 +1071,6 @@ static void pl2303_read_bulk_callback(struct urb *urb)
 
 	if (status) {
 		dbg("%s - urb status = %d", __func__, status);
-		if (!port->port.count) {
-			dbg("%s - port is closed, exiting.", __func__);
-			return;
-		}
 		if (status == -EPROTO) {
 			/* PL2303 mysteriously fails with -EPROTO reschedule
 			 * the read */
@@ -1107,15 +1103,11 @@ static void pl2303_read_bulk_callback(struct urb *urb)
 	}
 	tty_kref_put(tty);
 	/* Schedule the next read _if_ we are still open */
-	if (port->port.count) {
-		urb->dev = port->serial->dev;
-		result = usb_submit_urb(urb, GFP_ATOMIC);
-		if (result)
-			dev_err(&urb->dev->dev, "%s - failed resubmitting"
-				" read urb, error %d\n", __func__, result);
-	}
-
-	return;
+	urb->dev = port->serial->dev;
+	result = usb_submit_urb(urb, GFP_ATOMIC);
+	if (result && result != -EPERM)
+		dev_err(&urb->dev->dev, "%s - failed resubmitting"
+			" read urb, error %d\n", __func__, result);
 }
 
 static void pl2303_write_bulk_callback(struct urb *urb)

commit a108bfcb372d8c4452701039308fb95747911c59
Author: Alan Cox <alan@linux.intel.com>
Date:   Thu Feb 18 16:44:01 2010 +0000

    USB: tty: Prune uses of tty_request_room in the USB layer
    
    We have lots of callers that do not need to do this in the first place.
    Remove the calls as they both cost CPU and for big buffers can mess up the
    multi-page allocation avoidance.
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 767000c70149..a3e5a56dc066 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -1042,7 +1042,6 @@ static void pl2303_push_data(struct tty_struct *tty,
 		tty_flag = TTY_FRAME;
 	dbg("%s - tty_flag = %d", __func__, tty_flag);
 
-	tty_buffer_request_room(tty, urb->actual_length + 1);
 	/* overrun is special, not associated with a char */
 	if (line_status & UART_OVERRUN_ERROR)
 		tty_insert_flip_char(tty, 0, TTY_OVERRUN);

commit 7d40d7e85a25e01948bcb4dc3eda1355af318337
Author: Németh Márton <nm127@freemail.hu>
Date:   Sun Jan 10 15:34:24 2010 +0100

    USB serial: make USB device id constant
    
    The id_table field of the struct usb_device_id is constant in <linux/usb.h>
    so it is worth to make the initialization data also constant.
    
    The semantic match that finds this kind of pattern is as follows:
    (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @r@
    disable decl_init,const_decl_init;
    identifier I1, I2, x;
    @@
            struct I1 {
              ...
              const struct I2 *x;
              ...
            };
    @s@
    identifier r.I1, y;
    identifier r.x, E;
    @@
            struct I1 y = {
              .x = E,
            };
    @c@
    identifier r.I2;
    identifier s.E;
    @@
            const struct I2 E[] = ... ;
    @depends on !c@
    identifier r.I2;
    identifier s.E;
    @@
    +       const
            struct I2 E[] = ...;
    // </smpl>
    
    Signed-off-by: Németh Márton <nm127@freemail.hu>
    Cc: Julia Lawall <julia@diku.dk>
    Cc: cocci@diku.dk
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 9ec1a49e2362..767000c70149 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -50,7 +50,7 @@ struct pl2303_buf {
 	char		*buf_put;
 };
 
-static struct usb_device_id id_table [] = {
+static const struct usb_device_id id_table[] = {
 	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID) },
 	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_RSAQ2) },
 	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_DCU11) },

commit 9388e2e71a51fab0aa2309bbb45e8a23d89a95a9
Author: Johan Hovold <jhovold@gmail.com>
Date:   Thu Oct 8 11:36:46 2009 +0200

    USB: pl2303: fix error characters not being reported to ldisc
    
    Fix regression introduced by commit
    d4fc4a7bfc2dee626f4fec1e209e58eaa4312de6 (tty: Fix the PL2303 private
    methods for sysrq).
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Cc: stable <stable@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 1128e01525b1..9ec1a49e2362 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -1046,13 +1046,15 @@ static void pl2303_push_data(struct tty_struct *tty,
 	/* overrun is special, not associated with a char */
 	if (line_status & UART_OVERRUN_ERROR)
 		tty_insert_flip_char(tty, 0, TTY_OVERRUN);
-	if (port->console && port->sysrq) {
+
+	if (tty_flag == TTY_NORMAL && !(port->console && port->sysrq))
+		tty_insert_flip_string(tty, data, urb->actual_length);
+	else {
 		int i;
 		for (i = 0; i < urb->actual_length; ++i)
 			if (!usb_serial_handle_sysrq_char(tty, port, data[i]))
 				tty_insert_flip_char(tty, data[i], tty_flag);
-	} else
-		tty_insert_flip_string(tty, data, urb->actual_length);
+	}
 	tty_flip_buffer_push(tty);
 }
 

commit 29cf1b72f34519413b3fafbccc9ac776eb948ede
Author: Frank Schaefer <schaefer.frank@gmx.net>
Date:   Tue Aug 18 20:34:24 2009 +0200

    USB-serial: pl2303: use 1.5 instead of 2 stop bits with 5 data bits
    
    This is how "real" UARTs (e.g. 16550) work and AFAIK what RS232 specifies, too.
    Make the driver more compliant.
    
    Signed-off-by: Frank Schaefer <schaefer.frank@gmx.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 6ed33c7e53e2..1128e01525b1 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -622,8 +622,16 @@ static void pl2303_set_termios(struct tty_struct *tty,
 	/* For reference buf[4]=1 is 1.5 stop bits */
 	/* For reference buf[4]=2 is 2 stop bits */
 	if (cflag & CSTOPB) {
-		buf[4] = 2;
-		dbg("%s - stop bits = 2", __func__);
+		/* NOTE: Comply with "real" UARTs / RS232:
+		 *       use 1.5 instead of 2 stop bits with 5 data bits
+		 */
+		if ((cflag & CSIZE) == CS5) {
+			buf[4] = 1;
+			dbg("%s - stop bits = 1.5", __func__);
+		} else {
+			buf[4] = 2;
+			dbg("%s - stop bits = 2", __func__);
+		}
 	} else {
 		buf[4] = 0;
 		dbg("%s - stop bits = 1", __func__);

commit 6dd81b45fd7628f3eb308f387aee696366718f25
Author: Frank Schaefer <schaefer.frank@gmx.net>
Date:   Tue Aug 18 20:31:11 2009 +0200

    USB-serial: pl2303: add space/mark parity
    
    The device supports it, so why not use it ? Works fine !
    
    Signed-off-by: Frank Schaefer <schaefer.frank@gmx.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 82055b07e02c..6ed33c7e53e2 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -636,11 +636,21 @@ static void pl2303_set_termios(struct tty_struct *tty,
 		/* For reference buf[5]=3 is mark parity */
 		/* For reference buf[5]=4 is space parity */
 		if (cflag & PARODD) {
-			buf[5] = 1;
-			dbg("%s - parity = odd", __func__);
+			if (cflag & CMSPAR) {
+				buf[5] = 3;
+				dbg("%s - parity = mark", __func__);
+			} else {
+				buf[5] = 1;
+				dbg("%s - parity = odd", __func__);
+			}
 		} else {
-			buf[5] = 2;
-			dbg("%s - parity = even", __func__);
+			if (cflag & CMSPAR) {
+				buf[5] = 4;
+				dbg("%s - parity = space", __func__);
+			} else {
+				buf[5] = 2;
+				dbg("%s - parity = even", __func__);
+			}
 		}
 	} else {
 		buf[5] = 0;

commit 25b8286805e856c8c7fda127018e31032c918015
Author: Frank Schaefer <schaefer.frank@gmx.net>
Date:   Tue Aug 18 20:15:07 2009 +0200

    USB-serial: pl2303: fix baud rate handling in case of unsupported values
    
    According to the datasheets, the PL2303 supports a set of 25 baudrates.
    The baudrate is set as a 4 byte value directly.
    
    During my experiments with device 067b:2303 (PL2303X), I noticed that
     - the bridge-controller always uses 9600 baud if invalid/unsupported baud rate
       values are set
     - the baud rate value returned by usb_control_msg(..., GET_LINE_REQUEST, ...)
       does not reflect the actually used baudrate. Always the last set value is
       returned, even if it was invalid and not used by the controller.
    
    This patch fixes the following issues with the current code:
    1.) make sure that only supported baudrates are set (are there any buggy
        chip revisions out there which don't "like" other values... ?).
    2.) always set the baudrate to the next nearest supported baudrate.
    3.) applications can now read back the resulting baudrate properly, because
        tty_encode_baud_rate(...) is now fed with the actually used baudrate.
    
    Signed-off-by: Frank Schaefer <schaefer.frank@gmx.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 4cbe59c4ae7f..82055b07e02c 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -528,6 +528,12 @@ static void pl2303_set_termios(struct tty_struct *tty,
 	int baud;
 	int i;
 	u8 control;
+	const int baud_sup[] = { 75, 150, 300, 600, 1200, 1800, 2400, 3600,
+	                         4800, 7200, 9600, 14400, 19200, 28800, 38400,
+	                         57600, 115200, 230400, 460800, 614400,
+	                         921600, 1228800, 2457600, 3000000, 6000000 };
+	int baud_floor, baud_ceil;
+	int k;
 
 	dbg("%s -  port %d", __func__, port->number);
 
@@ -573,9 +579,39 @@ static void pl2303_set_termios(struct tty_struct *tty,
 		dbg("%s - data bits = %d", __func__, buf[6]);
 	}
 
+	/* For reference buf[0]:buf[3] baud rate value */
+	/* NOTE: Only the values defined in baud_sup are supported !
+	 *       => if unsupported values are set, the PL2303 seems to use
+	 *          9600 baud (at least my PL2303X always does)
+	 */
 	baud = tty_get_baud_rate(tty);
-	dbg("%s - baud = %d", __func__, baud);
+	dbg("%s - baud requested = %d", __func__, baud);
 	if (baud) {
+		/* Set baudrate to nearest supported value */
+		for (k=0; k<ARRAY_SIZE(baud_sup); k++) {
+			if (baud_sup[k] / baud) {
+				baud_ceil = baud_sup[k];
+				if (k==0) {
+					baud = baud_ceil;
+				} else {
+					baud_floor = baud_sup[k-1];
+					if ((baud_ceil % baud)
+					    > (baud % baud_floor))
+						baud = baud_floor;
+					else
+						baud = baud_ceil;
+				}
+				break;
+			}
+		}
+		if (baud > 1228800) {
+			/* type_0, type_1 only support up to 1228800 baud */
+			if (priv->type != HX)
+				baud = 1228800;
+			else if (baud > 6000000)
+				baud = 6000000;
+		}
+		dbg("%s - baud set = %d", __func__, baud);
 		buf[0] = baud & 0xff;
 		buf[1] = (baud >> 8) & 0xff;
 		buf[2] = (baud >> 16) & 0xff;
@@ -648,7 +684,7 @@ static void pl2303_set_termios(struct tty_struct *tty,
 		pl2303_vendor_write(0x0, 0x0, serial);
 	}
 
-	/* FIXME: Need to read back resulting baud rate */
+	/* Save resulting baud rate */
 	if (baud)
 		tty_encode_baud_rate(tty, baud, baud);
 

commit 35904e6b5106fda51b04c8b8080c04466865415f
Author: Pawel Ludwikow <pludwiko@rab.ict.pwr.wroc.pl>
Date:   Thu Aug 27 14:15:50 2009 +0200

    USB: serial: pl2303: new hardware support - sanwa multimeter
    
    I'd like to present my small patch enabling to use Sanwa PC5000
    mulitimeter with linux.
    
    Signed-off-by: Pawel Ludwikow <pludwiko@rab.ict.pwr.wroc.pl>
    Cc: stable <stable@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index a63ea99936f7..4cbe59c4ae7f 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -96,6 +96,7 @@ static struct usb_device_id id_table [] = {
 	{ USB_DEVICE(HP_VENDOR_ID, HP_LD220_PRODUCT_ID) },
 	{ USB_DEVICE(CRESSI_VENDOR_ID, CRESSI_EDY_PRODUCT_ID) },
 	{ USB_DEVICE(SONY_VENDOR_ID, SONY_QN3USB_PRODUCT_ID) },
+	{ USB_DEVICE(SANWA_VENDOR_ID, SANWA_PRODUCT_ID) },
 	{ }					/* Terminating entry */
 };
 

commit a509a7e478e4766114d69f12d19d644ac63e9765
Author: Alan Cox <alan@linux.intel.com>
Date:   Sat Sep 19 13:13:26 2009 -0700

    tty: USB does not need the filp argument in the drivers
    
    And indeed none of them use it. Clean this up as it will make moving to a
    standard open method rather easier.
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 3e86815b2705..a63ea99936f7 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -691,8 +691,7 @@ static void pl2303_close(struct usb_serial_port *port)
 
 }
 
-static int pl2303_open(struct tty_struct *tty,
-			struct usb_serial_port *port, struct file *filp)
+static int pl2303_open(struct tty_struct *tty, struct usb_serial_port *port)
 {
 	struct ktermios tmp_termios;
 	struct usb_serial *serial = port->serial;
@@ -714,8 +713,6 @@ static int pl2303_open(struct tty_struct *tty,
 	if (tty)
 		pl2303_set_termios(tty, port, &tmp_termios);
 
-	/* FIXME: need to assert RTS and DTR if CRTSCTS off */
-
 	dbg("%s - submitting read urb", __func__);
 	port->read_urb->dev = serial->dev;
 	result = usb_submit_urb(port->read_urb, GFP_KERNEL);

commit 49276560c9004fce24c42e3c0ad75f34d956fc63
Author: Khanh-Dang Nguyen Thu Lam <kdntl@yahoo.fr>
Date:   Tue Jul 28 19:41:17 2009 +0200

    USB: pl2303: New vendor and product id
    
    I am submitting a patch for the pl2303 driver.  This patch adds support
    for the "Sony QN-3USB" cable (vendor=0x054c, product=0x0437).  This USB
    cable is a so-called data cable used to connect a Sony mobile phone to a
    computer.  Supported models are Sony CMD-J5, J6, J7, J16, J26, J70 and
    Z7.
    
    I have used this patch with my Sony CMD-J70 for several days and I
    haven't encountered any kernel/hardware issue.
    
    
    From: Khanh-Dang Nguyen Thu Lam <kdntl@yahoo.fr>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 7d15bfa7c2db..3e86815b2705 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -95,6 +95,7 @@ static struct usb_device_id id_table [] = {
 	{ USB_DEVICE(SUPERIAL_VENDOR_ID, SUPERIAL_PRODUCT_ID) },
 	{ USB_DEVICE(HP_VENDOR_ID, HP_LD220_PRODUCT_ID) },
 	{ USB_DEVICE(CRESSI_VENDOR_ID, CRESSI_EDY_PRODUCT_ID) },
+	{ USB_DEVICE(SONY_VENDOR_ID, SONY_QN3USB_PRODUCT_ID) },
 	{ }					/* Terminating entry */
 };
 

commit 8540d66615c39010168ab97eaafb476ec2851298
Author: Gianpaolo Cugola <gianpaoloc@gmail.com>
Date:   Fri Jun 5 22:57:52 2009 +0200

    USB: pl2303: New vendor and product id for the prolific driver
    
    I recently bought a PC interface for the Cressi Edy dive computer
    (www.cressi.it) and discovered that it uses the pl2303 chip, albeit
    with ad-hoc vendor and product ids (04b8, 0521 respectively). Being in
    the process of writing a linux software for such device (cressi only
    provides a windows software), I patched the pl2303 linux driver to
    have the interface recognized. I am submitting you the patch (very
    basic) for inclusion in next kernel version.
    
    From: Gianpaolo Cugola <gianpaoloc@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index efaf59c4f5d0..7d15bfa7c2db 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -94,6 +94,7 @@ static struct usb_device_id id_table [] = {
 	{ USB_DEVICE(YCCABLE_VENDOR_ID, YCCABLE_PRODUCT_ID) },
 	{ USB_DEVICE(SUPERIAL_VENDOR_ID, SUPERIAL_PRODUCT_ID) },
 	{ USB_DEVICE(HP_VENDOR_ID, HP_LD220_PRODUCT_ID) },
+	{ USB_DEVICE(CRESSI_VENDOR_ID, CRESSI_EDY_PRODUCT_ID) },
 	{ }					/* Terminating entry */
 };
 

commit d4fc4a7bfc2dee626f4fec1e209e58eaa4312de6
Author: Alan Cox <alan@linux.intel.com>
Date:   Thu Jul 9 13:36:58 2009 +0100

    tty: Fix the PL2303 private methods for sysrq
    
    PL2303 has private data shovelling methods that also have no fast path. Fix
    them to work the same way as the default handler.
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 8835802067f7..efaf59c4f5d0 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -971,18 +971,46 @@ static void pl2303_read_int_callback(struct urb *urb)
 			__func__, retval);
 }
 
+static void pl2303_push_data(struct tty_struct *tty,
+		struct usb_serial_port *port, struct urb *urb,
+		u8 line_status)
+{
+	unsigned char *data = urb->transfer_buffer;
+	/* get tty_flag from status */
+	char tty_flag = TTY_NORMAL;
+	/* break takes precedence over parity, */
+	/* which takes precedence over framing errors */
+	if (line_status & UART_BREAK_ERROR)
+		tty_flag = TTY_BREAK;
+	else if (line_status & UART_PARITY_ERROR)
+		tty_flag = TTY_PARITY;
+	else if (line_status & UART_FRAME_ERROR)
+		tty_flag = TTY_FRAME;
+	dbg("%s - tty_flag = %d", __func__, tty_flag);
+
+	tty_buffer_request_room(tty, urb->actual_length + 1);
+	/* overrun is special, not associated with a char */
+	if (line_status & UART_OVERRUN_ERROR)
+		tty_insert_flip_char(tty, 0, TTY_OVERRUN);
+	if (port->console && port->sysrq) {
+		int i;
+		for (i = 0; i < urb->actual_length; ++i)
+			if (!usb_serial_handle_sysrq_char(tty, port, data[i]))
+				tty_insert_flip_char(tty, data[i], tty_flag);
+	} else
+		tty_insert_flip_string(tty, data, urb->actual_length);
+	tty_flip_buffer_push(tty);
+}
+
 static void pl2303_read_bulk_callback(struct urb *urb)
 {
 	struct usb_serial_port *port =  urb->context;
 	struct pl2303_private *priv = usb_get_serial_port_data(port);
 	struct tty_struct *tty;
-	unsigned char *data = urb->transfer_buffer;
 	unsigned long flags;
-	int i;
 	int result;
 	int status = urb->status;
 	u8 line_status;
-	char tty_flag;
 
 	dbg("%s - port %d", __func__, port->number);
 
@@ -1010,10 +1038,7 @@ static void pl2303_read_bulk_callback(struct urb *urb)
 	}
 
 	usb_serial_debug_data(debug, &port->dev, __func__,
-			      urb->actual_length, data);
-
-	/* get tty_flag from status */
-	tty_flag = TTY_NORMAL;
+			      urb->actual_length, urb->transfer_buffer);
 
 	spin_lock_irqsave(&priv->lock, flags);
 	line_status = priv->line_status;
@@ -1021,26 +1046,9 @@ static void pl2303_read_bulk_callback(struct urb *urb)
 	spin_unlock_irqrestore(&priv->lock, flags);
 	wake_up_interruptible(&priv->delta_msr_wait);
 
-	/* break takes precedence over parity, */
-	/* which takes precedence over framing errors */
-	if (line_status & UART_BREAK_ERROR)
-		tty_flag = TTY_BREAK;
-	else if (line_status & UART_PARITY_ERROR)
-		tty_flag = TTY_PARITY;
-	else if (line_status & UART_FRAME_ERROR)
-		tty_flag = TTY_FRAME;
-	dbg("%s - tty_flag = %d", __func__, tty_flag);
-
 	tty = tty_port_tty_get(&port->port);
 	if (tty && urb->actual_length) {
-		tty_buffer_request_room(tty, urb->actual_length + 1);
-		/* overrun is special, not associated with a char */
-		if (line_status & UART_OVERRUN_ERROR)
-			tty_insert_flip_char(tty, 0, TTY_OVERRUN);
-		for (i = 0; i < urb->actual_length; ++i)
-			if (!usb_serial_handle_sysrq_char(tty, port, data[i]))
-				tty_insert_flip_char(tty, data[i], tty_flag);
-		tty_flip_buffer_push(tty);
+		pl2303_push_data(tty, port, urb, line_status);
 	}
 	tty_kref_put(tty);
 	/* Schedule the next read _if_ we are still open */

commit 24a15a62dcb1968bf4ffdae55c88fa934d971180
Author: Alan Cox <alan@linux.intel.com>
Date:   Thu Jul 9 13:36:22 2009 +0100

    tty: Fix USB kref leak
    
    The sysrq code acquired a kref leak. Fix it by passing the tty separately
    from the caller (thus effectively using the callers kref which all the
    callers hold anyway)
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index ec6c132a25b5..8835802067f7 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -1038,7 +1038,7 @@ static void pl2303_read_bulk_callback(struct urb *urb)
 		if (line_status & UART_OVERRUN_ERROR)
 			tty_insert_flip_char(tty, 0, TTY_OVERRUN);
 		for (i = 0; i < urb->actual_length; ++i)
-			if (!usb_serial_handle_sysrq_char(port, data[i]))
+			if (!usb_serial_handle_sysrq_char(tty, port, data[i]))
 				tty_insert_flip_char(tty, data[i], tty_flag);
 		tty_flip_buffer_push(tty);
 	}

commit f9c99bb8b3a1ec81af68d484a551307326c2e933
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Jun 2 11:53:55 2009 -0400

    USB: usb-serial: replace shutdown with disconnect, release
    
    This patch (as1254) splits up the shutdown method of usb_serial_driver
    into a disconnect and a release method.
    
    The problem is that the usb-serial core was calling shutdown during
    disconnect handling, but drivers didn't expect it to be called until
    after all the open file references had been closed.  The result was an
    oops when the close method tried to use memory that had been
    deallocated by shutdown.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 6357b57f628c..ec6c132a25b5 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -878,7 +878,7 @@ static void pl2303_break_ctl(struct tty_struct *tty, int break_state)
 		dbg("%s - error sending break = %d", __func__, result);
 }
 
-static void pl2303_shutdown(struct usb_serial *serial)
+static void pl2303_release(struct usb_serial *serial)
 {
 	int i;
 	struct pl2303_private *priv;
@@ -890,7 +890,6 @@ static void pl2303_shutdown(struct usb_serial *serial)
 		if (priv) {
 			pl2303_buf_free(priv->buf);
 			kfree(priv);
-			usb_set_serial_port_data(serial->port[i], NULL);
 		}
 	}
 }
@@ -1123,7 +1122,7 @@ static struct usb_serial_driver pl2303_device = {
 	.write_room =		pl2303_write_room,
 	.chars_in_buffer =	pl2303_chars_in_buffer,
 	.attach =		pl2303_startup,
-	.shutdown =		pl2303_shutdown,
+	.release =		pl2303_release,
 };
 
 static int __init pl2303_init(void)

commit 430eb0d27c1b36c5191c16b2472b26137673a8d4
Author: Jason Wessel <jason.wessel@windriver.com>
Date:   Fri May 29 13:34:16 2009 -0500

    USB: pl2303 usb_serial: implement sysrq handling on break
    
    Add callbacks to process the sysrq when using a pl2303 usb device as a
    console.
    
    Signed-off-by: Jason Wessel <jason.wessel@windriver.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index e02dc3d643c7..6357b57f628c 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -927,6 +927,8 @@ static void pl2303_update_line_status(struct usb_serial_port *port,
 	spin_lock_irqsave(&priv->lock, flags);
 	priv->line_status = data[status_idx];
 	spin_unlock_irqrestore(&priv->lock, flags);
+	if (priv->line_status & UART_BREAK_ERROR)
+		usb_serial_handle_break(port);
 	wake_up_interruptible(&priv->delta_msr_wait);
 }
 
@@ -1037,7 +1039,8 @@ static void pl2303_read_bulk_callback(struct urb *urb)
 		if (line_status & UART_OVERRUN_ERROR)
 			tty_insert_flip_char(tty, 0, TTY_OVERRUN);
 		for (i = 0; i < urb->actual_length; ++i)
-			tty_insert_flip_char(tty, data[i], tty_flag);
+			if (!usb_serial_handle_sysrq_char(port, data[i]))
+				tty_insert_flip_char(tty, data[i], tty_flag);
 		tty_flip_buffer_push(tty);
 	}
 	tty_kref_put(tty);

commit 335f8514f200e63d689113d29cb7253a5c282967
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Thu Jun 11 12:26:29 2009 +0100

    tty: Bring the usb tty port structure into more use
    
    This allows us to clean stuff up, but is probably also going to cause
    some app breakage with buggy apps as we now implement proper POSIX behaviour
    for USB ports matching all the other ports. This does also mean other apps
    that break on USB will now work properly.
    
    Signed-off-by: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 751a533a4347..e02dc3d643c7 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -652,69 +652,41 @@ static void pl2303_set_termios(struct tty_struct *tty,
 	kfree(buf);
 }
 
-static void pl2303_close(struct tty_struct *tty,
-			struct usb_serial_port *port, struct file *filp)
+static void pl2303_dtr_rts(struct usb_serial_port *port, int on)
+{
+	struct pl2303_private *priv = usb_get_serial_port_data(port);
+	unsigned long flags;
+	u8 control;
+
+	spin_lock_irqsave(&priv->lock, flags);
+	/* Change DTR and RTS */
+	if (on)
+		priv->line_control |= (CONTROL_DTR | CONTROL_RTS);
+	else
+		priv->line_control &= ~(CONTROL_DTR | CONTROL_RTS);
+	control = priv->line_control;
+	spin_unlock_irqrestore(&priv->lock, flags);
+	set_control_lines(port->serial->dev, control);
+}
+
+static void pl2303_close(struct usb_serial_port *port)
 {
 	struct pl2303_private *priv = usb_get_serial_port_data(port);
 	unsigned long flags;
-	unsigned int c_cflag;
-	int bps;
-	long timeout;
-	wait_queue_t wait;
 
 	dbg("%s - port %d", __func__, port->number);
 
-	/* wait for data to drain from the buffer */
 	spin_lock_irqsave(&priv->lock, flags);
-	timeout = PL2303_CLOSING_WAIT;
-	init_waitqueue_entry(&wait, current);
-	add_wait_queue(&tty->write_wait, &wait);
-	for (;;) {
-		set_current_state(TASK_INTERRUPTIBLE);
-		if (pl2303_buf_data_avail(priv->buf) == 0 ||
-		    timeout == 0 || signal_pending(current) ||
-		    port->serial->disconnected)
-			break;
-		spin_unlock_irqrestore(&priv->lock, flags);
-		timeout = schedule_timeout(timeout);
-		spin_lock_irqsave(&priv->lock, flags);
-	}
-	set_current_state(TASK_RUNNING);
-	remove_wait_queue(&tty->write_wait, &wait);
 	/* clear out any remaining data in the buffer */
 	pl2303_buf_clear(priv->buf);
 	spin_unlock_irqrestore(&priv->lock, flags);
 
-	/* wait for characters to drain from the device */
-	/* (this is long enough for the entire 256 byte */
-	/* pl2303 hardware buffer to drain with no flow */
-	/* control for data rates of 1200 bps or more, */
-	/* for lower rates we should really know how much */
-	/* data is in the buffer to compute a delay */
-	/* that is not unnecessarily long) */
-	bps = tty_get_baud_rate(tty);
-	if (bps > 1200)
-		timeout = max((HZ*2560)/bps, HZ/10);
-	else
-		timeout = 2*HZ;
-	schedule_timeout_interruptible(timeout);
-
 	/* shutdown our urbs */
 	dbg("%s - shutting down urbs", __func__);
 	usb_kill_urb(port->write_urb);
 	usb_kill_urb(port->read_urb);
 	usb_kill_urb(port->interrupt_in_urb);
 
-	if (tty) {
-		c_cflag = tty->termios->c_cflag;
-		if (c_cflag & HUPCL) {
-			/* drop DTR and RTS */
-			spin_lock_irqsave(&priv->lock, flags);
-			priv->line_control = 0;
-			spin_unlock_irqrestore(&priv->lock, flags);
-			set_control_lines(port->serial->dev, 0);
-		}
-	}
 }
 
 static int pl2303_open(struct tty_struct *tty,
@@ -748,7 +720,7 @@ static int pl2303_open(struct tty_struct *tty,
 	if (result) {
 		dev_err(&port->dev, "%s - failed submitting read urb,"
 			" error %d\n", __func__, result);
-		pl2303_close(tty, port, NULL);
+		pl2303_close(port);
 		return -EPROTO;
 	}
 
@@ -758,9 +730,10 @@ static int pl2303_open(struct tty_struct *tty,
 	if (result) {
 		dev_err(&port->dev, "%s - failed submitting interrupt urb,"
 			" error %d\n", __func__, result);
-		pl2303_close(tty, port, NULL);
+		pl2303_close(port);
 		return -EPROTO;
 	}
+	port->port.drain_delay = 256;
 	return 0;
 }
 
@@ -821,6 +794,14 @@ static int pl2303_tiocmget(struct tty_struct *tty, struct file *file)
 	return result;
 }
 
+static int pl2303_carrier_raised(struct usb_serial_port *port)
+{
+	struct pl2303_private *priv = usb_get_serial_port_data(port);
+	if (priv->line_status & UART_DCD)
+		return 1;
+	return 0;
+}
+
 static int wait_modem_info(struct usb_serial_port *port, unsigned int arg)
 {
 	struct pl2303_private *priv = usb_get_serial_port_data(port);
@@ -1125,6 +1106,8 @@ static struct usb_serial_driver pl2303_device = {
 	.num_ports =		1,
 	.open =			pl2303_open,
 	.close =		pl2303_close,
+	.dtr_rts = 		pl2303_dtr_rts,
+	.carrier_raised =	pl2303_carrier_raised,
 	.write =		pl2303_write,
 	.ioctl =		pl2303_ioctl,
 	.break_ctl =		pl2303_break_ctl,

commit 912299f6f0587bb6c221705ed9949709b36b3c56
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Mon Apr 6 17:35:12 2009 +0100

    tty: pl2303 needs identifiers for Siemens S81 as well as EF81
    
    Closes bug 9065
    
    Signed-off-by: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 1aed584be5eb..751a533a4347 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -79,6 +79,7 @@ static struct usb_device_id id_table [] = {
 	{ USB_DEVICE(SIEMENS_VENDOR_ID, SIEMENS_PRODUCT_ID_X65) },
 	{ USB_DEVICE(SIEMENS_VENDOR_ID, SIEMENS_PRODUCT_ID_X75) },
 	{ USB_DEVICE(SIEMENS_VENDOR_ID, SIEMENS_PRODUCT_ID_EF81) },
+	{ USB_DEVICE(BENQ_VENDOR_ID, BENQ_PRODUCT_ID_S81) }, /* Benq/Siemens S81 */
 	{ USB_DEVICE(SYNTECH_VENDOR_ID, SYNTECH_PRODUCT_ID) },
 	{ USB_DEVICE(NOKIA_CA42_VENDOR_ID, NOKIA_CA42_PRODUCT_ID) },
 	{ USB_DEVICE(CA_42_CA42_VENDOR_ID, CA_42_CA42_PRODUCT_ID) },

commit af4b8514aafd53d97b05a0a30b7d4cfd2cbb7b81
Author: Mike Provencher <mike.provencher@hp.com>
Date:   Tue Dec 16 14:30:14 2008 -0600

    USB: pl2303: add id for Hewlett-Packard LD220-HP POS pole display
    
    Add id for the Hewlett-Packard LD220-HP POS pole display.
    
    Bus 002 Device 002: ID 03f0:3524 Hewlett-Packard
    
    Signed-off-by: Mike Provencher <mike.provencher@hp.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 029b314a1fb2..1aed584be5eb 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -92,6 +92,7 @@ static struct usb_device_id id_table [] = {
 	{ USB_DEVICE(COREGA_VENDOR_ID, COREGA_PRODUCT_ID) },
 	{ USB_DEVICE(YCCABLE_VENDOR_ID, YCCABLE_PRODUCT_ID) },
 	{ USB_DEVICE(SUPERIAL_VENDOR_ID, SUPERIAL_PRODUCT_ID) },
+	{ USB_DEVICE(HP_VENDOR_ID, HP_LD220_PRODUCT_ID) },
 	{ }					/* Terminating entry */
 };
 

commit 7c99200142c04d0f1ed3f048014591f841efdaed
Author: Matthew Arnold <Matthew.Arnold-1@uts.edu.au>
Date:   Sat Dec 13 22:42:53 2008 +1100

    USB: add 5372:2303 to pl2303
    
    This patch adds the "Superial" USB-Serial converter to pl2303 so that it
    is detected, by the correct driver.  Adds the relevant vendor:product
    (5372:2303) to the device tables in pl2303.c & pl2303.h.  The patch has
    been tested against 2.6.24-22-generic.
    
    Signed-off-by: Matthew D Arnold <matthew.arnold-1@uts.edu.au>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 491c8857b644..029b314a1fb2 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -91,6 +91,7 @@ static struct usb_device_id id_table [] = {
 	{ USB_DEVICE(WS002IN_VENDOR_ID, WS002IN_PRODUCT_ID) },
 	{ USB_DEVICE(COREGA_VENDOR_ID, COREGA_PRODUCT_ID) },
 	{ USB_DEVICE(YCCABLE_VENDOR_ID, YCCABLE_PRODUCT_ID) },
+	{ USB_DEVICE(SUPERIAL_VENDOR_ID, SUPERIAL_PRODUCT_ID) },
 	{ }					/* Terminating entry */
 };
 

commit c197a8db59daf06dc5e77acd5a9681329cb22458
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Aug 18 13:21:04 2008 -0700

    USB: remove info() macro from usb/serial drivers
    
    USB should not be having it's own printk macros, so remove info() and
    use the system-wide standard of dev_info() wherever possible.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 908437847165..491c8857b644 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -1147,7 +1147,7 @@ static int __init pl2303_init(void)
 	retval = usb_register(&pl2303_driver);
 	if (retval)
 		goto failed_usb_register;
-	info(DRIVER_DESC);
+	printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_DESC "\n");
 	return 0;
 failed_usb_register:
 	usb_serial_deregister(&pl2303_device);

commit 4a90f09b20f4622dcbff1f0e1e6bae1704f8ad8c
Author: Alan Cox <alan@redhat.com>
Date:   Mon Oct 13 10:39:46 2008 +0100

    tty: usb-serial krefs
    
    Use kref in the USB serial drivers so that we don't free tty structures
    from under the URB receive handlers as has historically been the case if
    you were unlucky. This also gives us a framework for general tty drivers to
    use tty_port objects and refcount.
    
    Contains two err->dev_err changes merged together to fix clashes in the
    -next tree.
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 8d6006894bf5..908437847165 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -1046,7 +1046,7 @@ static void pl2303_read_bulk_callback(struct urb *urb)
 		tty_flag = TTY_FRAME;
 	dbg("%s - tty_flag = %d", __func__, tty_flag);
 
-	tty = port->port.tty;
+	tty = tty_port_tty_get(&port->port);
 	if (tty && urb->actual_length) {
 		tty_buffer_request_room(tty, urb->actual_length + 1);
 		/* overrun is special, not associated with a char */
@@ -1056,7 +1056,7 @@ static void pl2303_read_bulk_callback(struct urb *urb)
 			tty_insert_flip_char(tty, data[i], tty_flag);
 		tty_flip_buffer_push(tty);
 	}
-
+	tty_kref_put(tty);
 	/* Schedule the next read _if_ we are still open */
 	if (port->port.count) {
 		urb->dev = port->serial->dev;

commit 4ad6de0b3f5d050b70e4c94a0cc8b26503f8cf28
Author: Jason Wessel <jason.wessel@windriver.com>
Date:   Mon Oct 13 10:35:51 2008 +0100

    usb: fix pl2303 initialization
    
    This patch removes the private check for the termios_initialized for
    the pl2303 usb driver.  It forced the baud to 9600 on the first call
    to pl2303_set_termios()
    
    Based on the tty changes in the 2.6.27 kernel, the termios passed to
    the *_set_termios functions is always populated the first time.
    
    This means there is no need to privately initialize the settings the
    first time, and doing so will not allow the use of the kernel
    parameter "console=ttyUSB0,115200" as an example.
    
    Signed-off-by: Jason Wessel <jason.wessel@windriver.com>
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 1ede1441cb1b..8d6006894bf5 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -154,7 +154,6 @@ struct pl2303_private {
 	wait_queue_head_t delta_msr_wait;
 	u8 line_control;
 	u8 line_status;
-	u8 termios_initialized;
 	enum pl2303_type type;
 };
 
@@ -526,16 +525,6 @@ static void pl2303_set_termios(struct tty_struct *tty,
 
 	dbg("%s -  port %d", __func__, port->number);
 
-	spin_lock_irqsave(&priv->lock, flags);
-	if (!priv->termios_initialized) {
-		*(tty->termios) = tty_std_termios;
-		tty->termios->c_cflag = B9600 | CS8 | CREAD | HUPCL | CLOCAL;
-		tty->termios->c_ispeed = 9600;
-		tty->termios->c_ospeed = 9600;
-		priv->termios_initialized = 1;
-	}
-	spin_unlock_irqrestore(&priv->lock, flags);
-
 	/* The PL2303 is reported to lose bytes if you change
 	   serial settings even to the same values as before. Thus
 	   we actually need to filter in this specific case */

commit 8c809681ba0289afd0ed7bbb63679a0568dd441d
Author: Tollef Fog Heen <tfheen@err.no>
Date:   Tue Jul 22 09:28:05 2008 +0200

    USB: pl2023: Remove USB id (4348:5523) handled by ch341
    
    USB ID 4348:5523 is handled by the ch341 driver.  Remove it from the
    pl2023 driver.
    
    Reverts 002e8f2c80c6be76bb312940bc278fc10b2b2487.
    
    Signed-off-by: Tollef Fog Heen <tfheen@err.no>
    Cc: stable <stable@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 2c9c446ad625..1ede1441cb1b 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -90,7 +90,6 @@ static struct usb_device_id id_table [] = {
 	{ USB_DEVICE(ALCOR_VENDOR_ID, ALCOR_PRODUCT_ID) },
 	{ USB_DEVICE(WS002IN_VENDOR_ID, WS002IN_PRODUCT_ID) },
 	{ USB_DEVICE(COREGA_VENDOR_ID, COREGA_PRODUCT_ID) },
-	{ USB_DEVICE(HL340_VENDOR_ID, HL340_PRODUCT_ID) },
 	{ USB_DEVICE(YCCABLE_VENDOR_ID, YCCABLE_PRODUCT_ID) },
 	{ }					/* Terminating entry */
 };

commit 3a0f43e9deffd9619ac34e3b6b9ba7089aa1e511
Author: Alan Cox <alan@redhat.com>
Date:   Tue Jul 22 11:14:49 2008 +0100

    tty-usb-pl2303: Coding style
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index a0016725d314..2c9c446ad625 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -10,7 +10,8 @@
  *	modify it under the terms of the GNU General Public License version
  *	2 as published by the Free Software Foundation.
  *
- * See Documentation/usb/usb-serial.txt for more information on using this driver
+ * See Documentation/usb/usb-serial.txt for more information on using this
+ * driver
  *
  */
 
@@ -25,7 +26,7 @@
 #include <linux/module.h>
 #include <linux/moduleparam.h>
 #include <linux/spinlock.h>
-#include <asm/uaccess.h>
+#include <linux/uaccess.h>
 #include <linux/usb.h>
 #include <linux/usb/serial.h>
 #include "pl2303.h"
@@ -116,7 +117,7 @@ static struct usb_driver pl2303_driver = {
 #define CONTROL_RTS			0x02
 
 #define BREAK_REQUEST_TYPE		0x21
-#define BREAK_REQUEST			0x23	
+#define BREAK_REQUEST			0x23
 #define BREAK_ON			0xffff
 #define BREAK_OFF			0x0000
 
@@ -222,7 +223,7 @@ static unsigned int pl2303_buf_data_avail(struct pl2303_buf *pb)
 	if (pb == NULL)
 		return 0;
 
-	return ((pb->buf_size + pb->buf_put - pb->buf_get) % pb->buf_size);
+	return (pb->buf_size + pb->buf_put - pb->buf_get) % pb->buf_size;
 }
 
 /*
@@ -236,7 +237,7 @@ static unsigned int pl2303_buf_space_avail(struct pl2303_buf *pb)
 	if (pb == NULL)
 		return 0;
 
-	return ((pb->buf_size + pb->buf_get - pb->buf_put - 1) % pb->buf_size);
+	return (pb->buf_size + pb->buf_get - pb->buf_put - 1) % pb->buf_size;
 }
 
 /*
@@ -395,7 +396,7 @@ static int pl2303_startup(struct usb_serial *serial)
 
 cleanup:
 	kfree(buf);
-	for (--i; i>=0; --i) {
+	for (--i; i >= 0; --i) {
 		priv = usb_get_serial_port_data(serial->port[i]);
 		pl2303_buf_free(priv->buf);
 		kfree(priv);
@@ -407,7 +408,7 @@ static int pl2303_startup(struct usb_serial *serial)
 static int set_control_lines(struct usb_device *dev, u8 value)
 {
 	int retval;
-	
+
 	retval = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
 				 SET_CONTROL_REQUEST, SET_CONTROL_REQUEST_TYPE,
 				 value, 0, NULL, 0, 100);
@@ -452,7 +453,7 @@ static void pl2303_send(struct usb_serial_port *port)
 		dev_err(&port->dev, "%s - failed submitting write urb,"
 			" error %d\n", __func__, result);
 		priv->write_urb_in_use = 0;
-		// TODO: reschedule pl2303_send
+		/* TODO: reschedule pl2303_send */
 	}
 
 	usb_serial_port_softint(port);
@@ -561,11 +562,19 @@ static void pl2303_set_termios(struct tty_struct *tty,
 
 	if (cflag & CSIZE) {
 		switch (cflag & CSIZE) {
-			case CS5:	buf[6] = 5;	break;
-			case CS6:	buf[6] = 6;	break;
-			case CS7:	buf[6] = 7;	break;
-			default:
-			case CS8:	buf[6] = 8;	break;
+		case CS5:
+			buf[6] = 5;
+			break;
+		case CS6:
+			buf[6] = 6;
+			break;
+		case CS7:
+			buf[6] = 7;
+			break;
+		default:
+		case CS8:
+			buf[6] = 8;
+			break;
 		}
 		dbg("%s - data bits = %d", __func__, buf[6]);
 	}
@@ -694,7 +703,7 @@ static void pl2303_close(struct tty_struct *tty,
 	/* that is not unnecessarily long) */
 	bps = tty_get_baud_rate(tty);
 	if (bps > 1200)
-		timeout = max((HZ*2560)/bps,HZ/10);
+		timeout = max((HZ*2560)/bps, HZ/10);
 	else
 		timeout = 2*HZ;
 	schedule_timeout_interruptible(timeout);
@@ -740,7 +749,7 @@ static int pl2303_open(struct tty_struct *tty,
 	if (tty)
 		pl2303_set_termios(tty, port, &tmp_termios);
 
-	//FIXME: need to assert RTS and DTR if CRTSCTS off
+	/* FIXME: need to assert RTS and DTR if CRTSCTS off */
 
 	dbg("%s - submitting read urb", __func__);
 	port->read_urb->dev = serial->dev;
@@ -843,12 +852,12 @@ static int wait_modem_info(struct usb_serial_port *port, unsigned int arg)
 		status = priv->line_status;
 		spin_unlock_irqrestore(&priv->lock, flags);
 
-		changed=prevstatus^status;
+		changed = prevstatus ^ status;
 
 		if (((arg & TIOCM_RNG) && (changed & UART_RING)) ||
 		    ((arg & TIOCM_DSR) && (changed & UART_DSR)) ||
 		    ((arg & TIOCM_CD)  && (changed & UART_DCD)) ||
-		    ((arg & TIOCM_CTS) && (changed & UART_CTS)) ) {
+		    ((arg & TIOCM_CTS) && (changed & UART_CTS))) {
 			return 0;
 		}
 		prevstatus = status;
@@ -864,15 +873,13 @@ static int pl2303_ioctl(struct tty_struct *tty, struct file *file,
 	dbg("%s (%d) cmd = 0x%04x", __func__, port->number, cmd);
 
 	switch (cmd) {
-		case TIOCMIWAIT:
-			dbg("%s (%d) TIOCMIWAIT", __func__,  port->number);
-			return wait_modem_info(port, arg);
-
-		default:
-			dbg("%s not supported = 0x%04x", __func__, cmd);
-			break;
+	case TIOCMIWAIT:
+		dbg("%s (%d) TIOCMIWAIT", __func__,  port->number);
+		return wait_modem_info(port, arg);
+	default:
+		dbg("%s not supported = 0x%04x", __func__, cmd);
+		break;
 	}
-
 	return -ENOIOCTLCMD;
 }
 
@@ -889,7 +896,8 @@ static void pl2303_break_ctl(struct tty_struct *tty, int break_state)
 		state = BREAK_OFF;
 	else
 		state = BREAK_ON;
-	dbg("%s - turning break %s", __func__, state==BREAK_OFF ? "off" : "on");
+	dbg("%s - turning break %s", __func__,
+			state == BREAK_OFF ? "off" : "on");
 
 	result = usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),
 				 BREAK_REQUEST, BREAK_REQUEST_TYPE, state,
@@ -943,7 +951,7 @@ static void pl2303_update_line_status(struct usb_serial_port *port,
 	if (actual_length < length)
 		return;
 
-        /* Save off the uart status for others to look at */
+	/* Save off the uart status for others to look at */
 	spin_lock_irqsave(&priv->lock, flags);
 	priv->line_status = data[status_idx];
 	spin_unlock_irqrestore(&priv->lock, flags);
@@ -1042,7 +1050,7 @@ static void pl2303_read_bulk_callback(struct urb *urb)
 
 	/* break takes precedence over parity, */
 	/* which takes precedence over framing errors */
-	if (line_status & UART_BREAK_ERROR )
+	if (line_status & UART_BREAK_ERROR)
 		tty_flag = TTY_BREAK;
 	else if (line_status & UART_PARITY_ERROR)
 		tty_flag = TTY_PARITY;

commit 95da310e66ee8090119596c70ca8432e57f9a97f
Author: Alan Cox <alan@redhat.com>
Date:   Tue Jul 22 11:09:07 2008 +0100

    usb_serial: API all change
    
    USB serial likes to use port->tty back pointers for the real work it does and
    to do so without any actual locking. Unfortunately when you consider hangup
    events, hangup/parallel reopen or even worse hangup followed by parallel close
    events the tty->port and port->tty pointers are not guaranteed to be the same
    as port->tty is the active tty while tty->port is the port the tty may or
    may not still be attached to.
    
    So rework the entire API to pass the tty struct. For console cases we need
    to pass both for now. This shows up multiple drivers that immediately crash
    with USB console some of which have been fixed in the process.
    
    Longer term we need a proper tty as console abstraction
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 2a0dd1b50dc4..a0016725d314 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -458,8 +458,8 @@ static void pl2303_send(struct usb_serial_port *port)
 	usb_serial_port_softint(port);
 }
 
-static int pl2303_write(struct usb_serial_port *port, const unsigned char *buf,
-			int count)
+static int pl2303_write(struct tty_struct *tty, struct usb_serial_port *port,
+				const unsigned char *buf, int count)
 {
 	struct pl2303_private *priv = usb_get_serial_port_data(port);
 	unsigned long flags;
@@ -478,8 +478,9 @@ static int pl2303_write(struct usb_serial_port *port, const unsigned char *buf,
 	return count;
 }
 
-static int pl2303_write_room(struct usb_serial_port *port)
+static int pl2303_write_room(struct tty_struct *tty)
 {
+	struct usb_serial_port *port = tty->driver_data;
 	struct pl2303_private *priv = usb_get_serial_port_data(port);
 	int room = 0;
 	unsigned long flags;
@@ -494,8 +495,9 @@ static int pl2303_write_room(struct usb_serial_port *port)
 	return room;
 }
 
-static int pl2303_chars_in_buffer(struct usb_serial_port *port)
+static int pl2303_chars_in_buffer(struct tty_struct *tty)
 {
+	struct usb_serial_port *port = tty->driver_data;
 	struct pl2303_private *priv = usb_get_serial_port_data(port);
 	int chars = 0;
 	unsigned long flags;
@@ -510,8 +512,8 @@ static int pl2303_chars_in_buffer(struct usb_serial_port *port)
 	return chars;
 }
 
-static void pl2303_set_termios(struct usb_serial_port *port,
-			       struct ktermios *old_termios)
+static void pl2303_set_termios(struct tty_struct *tty,
+		struct usb_serial_port *port, struct ktermios *old_termios)
 {
 	struct usb_serial *serial = port->serial;
 	struct pl2303_private *priv = usb_get_serial_port_data(port);
@@ -526,11 +528,10 @@ static void pl2303_set_termios(struct usb_serial_port *port,
 
 	spin_lock_irqsave(&priv->lock, flags);
 	if (!priv->termios_initialized) {
-		*(port->tty->termios) = tty_std_termios;
-		port->tty->termios->c_cflag = B9600 | CS8 | CREAD |
-					      HUPCL | CLOCAL;
-		port->tty->termios->c_ispeed = 9600;
-		port->tty->termios->c_ospeed = 9600;
+		*(tty->termios) = tty_std_termios;
+		tty->termios->c_cflag = B9600 | CS8 | CREAD | HUPCL | CLOCAL;
+		tty->termios->c_ispeed = 9600;
+		tty->termios->c_ospeed = 9600;
 		priv->termios_initialized = 1;
 	}
 	spin_unlock_irqrestore(&priv->lock, flags);
@@ -539,16 +540,16 @@ static void pl2303_set_termios(struct usb_serial_port *port,
 	   serial settings even to the same values as before. Thus
 	   we actually need to filter in this specific case */
 
-	if (!tty_termios_hw_change(port->tty->termios, old_termios))
+	if (!tty_termios_hw_change(tty->termios, old_termios))
 		return;
 
-	cflag = port->tty->termios->c_cflag;
+	cflag = tty->termios->c_cflag;
 
 	buf = kzalloc(7, GFP_KERNEL);
 	if (!buf) {
 		dev_err(&port->dev, "%s - out of memory.\n", __func__);
 		/* Report back no change occurred */
-		*port->tty->termios = *old_termios;
+		*tty->termios = *old_termios;
 		return;
 	}
 
@@ -569,7 +570,7 @@ static void pl2303_set_termios(struct usb_serial_port *port,
 		dbg("%s - data bits = %d", __func__, buf[6]);
 	}
 
-	baud = tty_get_baud_rate(port->tty);;
+	baud = tty_get_baud_rate(tty);
 	dbg("%s - baud = %d", __func__, baud);
 	if (baud) {
 		buf[0] = baud & 0xff;
@@ -646,12 +647,13 @@ static void pl2303_set_termios(struct usb_serial_port *port,
 
 	/* FIXME: Need to read back resulting baud rate */
 	if (baud)
-		tty_encode_baud_rate(port->tty, baud, baud);
+		tty_encode_baud_rate(tty, baud, baud);
 
 	kfree(buf);
 }
 
-static void pl2303_close(struct usb_serial_port *port, struct file *filp)
+static void pl2303_close(struct tty_struct *tty,
+			struct usb_serial_port *port, struct file *filp)
 {
 	struct pl2303_private *priv = usb_get_serial_port_data(port);
 	unsigned long flags;
@@ -666,7 +668,7 @@ static void pl2303_close(struct usb_serial_port *port, struct file *filp)
 	spin_lock_irqsave(&priv->lock, flags);
 	timeout = PL2303_CLOSING_WAIT;
 	init_waitqueue_entry(&wait, current);
-	add_wait_queue(&port->tty->write_wait, &wait);
+	add_wait_queue(&tty->write_wait, &wait);
 	for (;;) {
 		set_current_state(TASK_INTERRUPTIBLE);
 		if (pl2303_buf_data_avail(priv->buf) == 0 ||
@@ -678,7 +680,7 @@ static void pl2303_close(struct usb_serial_port *port, struct file *filp)
 		spin_lock_irqsave(&priv->lock, flags);
 	}
 	set_current_state(TASK_RUNNING);
-	remove_wait_queue(&port->tty->write_wait, &wait);
+	remove_wait_queue(&tty->write_wait, &wait);
 	/* clear out any remaining data in the buffer */
 	pl2303_buf_clear(priv->buf);
 	spin_unlock_irqrestore(&priv->lock, flags);
@@ -690,7 +692,7 @@ static void pl2303_close(struct usb_serial_port *port, struct file *filp)
 	/* for lower rates we should really know how much */
 	/* data is in the buffer to compute a delay */
 	/* that is not unnecessarily long) */
-	bps = tty_get_baud_rate(port->tty);
+	bps = tty_get_baud_rate(tty);
 	if (bps > 1200)
 		timeout = max((HZ*2560)/bps,HZ/10);
 	else
@@ -703,8 +705,8 @@ static void pl2303_close(struct usb_serial_port *port, struct file *filp)
 	usb_kill_urb(port->read_urb);
 	usb_kill_urb(port->interrupt_in_urb);
 
-	if (port->tty) {
-		c_cflag = port->tty->termios->c_cflag;
+	if (tty) {
+		c_cflag = tty->termios->c_cflag;
 		if (c_cflag & HUPCL) {
 			/* drop DTR and RTS */
 			spin_lock_irqsave(&priv->lock, flags);
@@ -715,7 +717,8 @@ static void pl2303_close(struct usb_serial_port *port, struct file *filp)
 	}
 }
 
-static int pl2303_open(struct usb_serial_port *port, struct file *filp)
+static int pl2303_open(struct tty_struct *tty,
+			struct usb_serial_port *port, struct file *filp)
 {
 	struct ktermios tmp_termios;
 	struct usb_serial *serial = port->serial;
@@ -734,9 +737,8 @@ static int pl2303_open(struct usb_serial_port *port, struct file *filp)
 	}
 
 	/* Setup termios */
-	if (port->tty) {
-		pl2303_set_termios(port, &tmp_termios);
-	}
+	if (tty)
+		pl2303_set_termios(tty, port, &tmp_termios);
 
 	//FIXME: need to assert RTS and DTR if CRTSCTS off
 
@@ -746,7 +748,7 @@ static int pl2303_open(struct usb_serial_port *port, struct file *filp)
 	if (result) {
 		dev_err(&port->dev, "%s - failed submitting read urb,"
 			" error %d\n", __func__, result);
-		pl2303_close(port, NULL);
+		pl2303_close(tty, port, NULL);
 		return -EPROTO;
 	}
 
@@ -756,15 +758,16 @@ static int pl2303_open(struct usb_serial_port *port, struct file *filp)
 	if (result) {
 		dev_err(&port->dev, "%s - failed submitting interrupt urb,"
 			" error %d\n", __func__, result);
-		pl2303_close(port, NULL);
+		pl2303_close(tty, port, NULL);
 		return -EPROTO;
 	}
 	return 0;
 }
 
-static int pl2303_tiocmset(struct usb_serial_port *port, struct file *file,
+static int pl2303_tiocmset(struct tty_struct *tty, struct file *file,
 			   unsigned int set, unsigned int clear)
 {
+	struct usb_serial_port *port = tty->driver_data;
 	struct pl2303_private *priv = usb_get_serial_port_data(port);
 	unsigned long flags;
 	u8 control;
@@ -787,8 +790,9 @@ static int pl2303_tiocmset(struct usb_serial_port *port, struct file *file,
 	return set_control_lines(port->serial->dev, control);
 }
 
-static int pl2303_tiocmget(struct usb_serial_port *port, struct file *file)
+static int pl2303_tiocmget(struct tty_struct *tty, struct file *file)
 {
+	struct usb_serial_port *port = tty->driver_data;
 	struct pl2303_private *priv = usb_get_serial_port_data(port);
 	unsigned long flags;
 	unsigned int mcr;
@@ -853,9 +857,10 @@ static int wait_modem_info(struct usb_serial_port *port, unsigned int arg)
 	return 0;
 }
 
-static int pl2303_ioctl(struct usb_serial_port *port, struct file *file,
+static int pl2303_ioctl(struct tty_struct *tty, struct file *file,
 			unsigned int cmd, unsigned long arg)
 {
+	struct usb_serial_port *port = tty->driver_data;
 	dbg("%s (%d) cmd = 0x%04x", __func__, port->number, cmd);
 
 	switch (cmd) {
@@ -871,8 +876,9 @@ static int pl2303_ioctl(struct usb_serial_port *port, struct file *file,
 	return -ENOIOCTLCMD;
 }
 
-static void pl2303_break_ctl(struct usb_serial_port *port, int break_state)
+static void pl2303_break_ctl(struct tty_struct *tty, int break_state)
 {
+	struct usb_serial_port *port = tty->driver_data;
 	struct usb_serial *serial = port->serial;
 	u16 state;
 	int result;
@@ -1001,7 +1007,7 @@ static void pl2303_read_bulk_callback(struct urb *urb)
 
 	if (status) {
 		dbg("%s - urb status = %d", __func__, status);
-		if (!port->open_count) {
+		if (!port->port.count) {
 			dbg("%s - port is closed, exiting.", __func__);
 			return;
 		}
@@ -1044,7 +1050,7 @@ static void pl2303_read_bulk_callback(struct urb *urb)
 		tty_flag = TTY_FRAME;
 	dbg("%s - tty_flag = %d", __func__, tty_flag);
 
-	tty = port->tty;
+	tty = port->port.tty;
 	if (tty && urb->actual_length) {
 		tty_buffer_request_room(tty, urb->actual_length + 1);
 		/* overrun is special, not associated with a char */
@@ -1056,7 +1062,7 @@ static void pl2303_read_bulk_callback(struct urb *urb)
 	}
 
 	/* Schedule the next read _if_ we are still open */
-	if (port->open_count) {
+	if (port->port.count) {
 		urb->dev = port->serial->dev;
 		result = usb_submit_urb(urb, GFP_ATOMIC);
 		if (result)

commit 727df3569b358ef440683787c2b9fe8cc55a0954
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed Jul 2 15:25:41 2008 -0500

    USB: add a pl2303 device id
    
    As reported by Ken A Scott <kscott9@sent.com>
    
    Cc: Ken A Scott <kscott9@sent.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 103195abd417..2a0dd1b50dc4 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -57,6 +57,7 @@ static struct usb_device_id id_table [] = {
 	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_PHAROS) },
 	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_ALDIGA) },
 	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_MMX) },
+	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_GPRS) },
 	{ USB_DEVICE(IODATA_VENDOR_ID, IODATA_PRODUCT_ID) },
 	{ USB_DEVICE(IODATA_VENDOR_ID, IODATA_PRODUCT_ID_RSAQ5) },
 	{ USB_DEVICE(ATEN_VENDOR_ID, ATEN_PRODUCT_ID) },

commit 4be2fa186d54758296d30c565d7b5111dd45b000
Author: Steve Murphy <steve@gnusis.org>
Date:   Fri May 23 23:39:05 2008 +0530

    USB: pl2303: another product ID
    
    I've just got a USB GPRS/EDGE modem branded Manufacturer Micromax Model
    MMX610U (see http://www.airtel.in/level2_t3data.aspx?path=1/106/179)
    working by adding another product ID to pl2303.  Modem info reports same
    module as  Max Arnold's i.e.SIMCOM SIM600  but  with product ID 0x0612
    (cf Ox0611).
    
    From: Steve Murphy <steve@gnusis.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 234c5eea95a2..103195abd417 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -56,6 +56,7 @@ static struct usb_device_id id_table [] = {
 	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_RSAQ3) },
 	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_PHAROS) },
 	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_ALDIGA) },
+	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_MMX) },
 	{ USB_DEVICE(IODATA_VENDOR_ID, IODATA_PRODUCT_ID) },
 	{ USB_DEVICE(IODATA_VENDOR_ID, IODATA_PRODUCT_ID_RSAQ5) },
 	{ USB_DEVICE(ATEN_VENDOR_ID, ATEN_PRODUCT_ID) },

commit 26ab705396b65a469233a8327ecb51b8aebb6be0
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Sat May 17 00:13:56 2008 +0900

    usb-serial: Use ftdi_sio driver for RATOC REX-USB60F
    
    This patch reverts 57833ea6b95a3995149f1f6d1a8d8862ab7a0ba2
    ("usb-serial: pl2303: add support for RATOC REX-USB60F") and adds
    support for the device to ftdi_sio driver.
    
    Cc: Akira Tsukamoto <akirat@rd.scei.sony.co.jp>
    Cc: stable <stable@kernel.org>
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index c605fb68f807..234c5eea95a2 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -66,7 +66,6 @@ static struct usb_device_id id_table [] = {
 	{ USB_DEVICE(ITEGNO_VENDOR_ID, ITEGNO_PRODUCT_ID_2080) },
 	{ USB_DEVICE(MA620_VENDOR_ID, MA620_PRODUCT_ID) },
 	{ USB_DEVICE(RATOC_VENDOR_ID, RATOC_PRODUCT_ID) },
-	{ USB_DEVICE(RATOC_VENDOR_ID, RATOC_PRODUCT_ID_USB60F) },
 	{ USB_DEVICE(TRIPP_VENDOR_ID, TRIPP_PRODUCT_ID) },
 	{ USB_DEVICE(RADIOSHACK_VENDOR_ID, RADIOSHACK_PRODUCT_ID) },
 	{ USB_DEVICE(DCU10_VENDOR_ID, DCU10_PRODUCT_ID) },

commit cdc97792289179974af6dda781c855696358d307
Author: Ming Lei <tom.leiming@gmail.com>
Date:   Sun Feb 24 18:41:47 2008 +0800

    USB: remove unnecessary type casting of urb->context
    
    urb->context code cleanup
    
    Signed-off-by: Ming Lei <tom.leiming@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index c60930ec9341..c605fb68f807 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -945,7 +945,7 @@ static void pl2303_update_line_status(struct usb_serial_port *port,
 
 static void pl2303_read_int_callback(struct urb *urb)
 {
-	struct usb_serial_port *port = (struct usb_serial_port *) urb->context;
+	struct usb_serial_port *port =  urb->context;
 	unsigned char *data = urb->transfer_buffer;
 	unsigned int actual_length = urb->actual_length;
 	int status = urb->status;
@@ -985,7 +985,7 @@ static void pl2303_read_int_callback(struct urb *urb)
 
 static void pl2303_read_bulk_callback(struct urb *urb)
 {
-	struct usb_serial_port *port = (struct usb_serial_port *) urb->context;
+	struct usb_serial_port *port =  urb->context;
 	struct pl2303_private *priv = usb_get_serial_port_data(port);
 	struct tty_struct *tty;
 	unsigned char *data = urb->transfer_buffer;
@@ -1068,7 +1068,7 @@ static void pl2303_read_bulk_callback(struct urb *urb)
 
 static void pl2303_write_bulk_callback(struct urb *urb)
 {
-	struct usb_serial_port *port = (struct usb_serial_port *) urb->context;
+	struct usb_serial_port *port =  urb->context;
 	struct pl2303_private *priv = usb_get_serial_port_data(port);
 	int result;
 	int status = urb->status;

commit a5b6f60c5a30c494017c7a2d11c4067f90d3d0df
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Tue Apr 8 17:16:06 2008 +0100

    usb serial: more fixes and groundwork for tty changes
    
     - If a termios change fails due to lack of memory we should copy the
       old settings back over as the device has not changed
     - Note various locking problems
     - kl5kusb105 had various remaining tty flag handling problems
     - Make safe_serial use tty_insert_flip_string not open coded loops
     - set termios speed properly in usb_serial
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 2b4ab371c762..c60930ec9341 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -546,6 +546,8 @@ static void pl2303_set_termios(struct usb_serial_port *port,
 	buf = kzalloc(7, GFP_KERNEL);
 	if (!buf) {
 		dev_err(&port->dev, "%s - out of memory.\n", __func__);
+		/* Report back no change occurred */
+		*port->tty->termios = *old_termios;
 		return;
 	}
 

commit 441b62c1edb986827154768d89bbac0ba779984f
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Mon Mar 3 16:08:34 2008 -0800

    USB: replace remaining __FUNCTION__ occurrences
    
    __FUNCTION__ is gcc-specific, use __func__
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 1fbb4dbdf23d..2b4ab371c762 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -410,7 +410,7 @@ static int set_control_lines(struct usb_device *dev, u8 value)
 	retval = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
 				 SET_CONTROL_REQUEST, SET_CONTROL_REQUEST_TYPE,
 				 value, 0, NULL, 0, 100);
-	dbg("%s - value = %d, retval = %d", __FUNCTION__, value, retval);
+	dbg("%s - value = %d, retval = %d", __func__, value, retval);
 	return retval;
 }
 
@@ -420,7 +420,7 @@ static void pl2303_send(struct usb_serial_port *port)
 	struct pl2303_private *priv = usb_get_serial_port_data(port);
 	unsigned long flags;
 
-	dbg("%s - port %d", __FUNCTION__, port->number);
+	dbg("%s - port %d", __func__, port->number);
 
 	spin_lock_irqsave(&priv->lock, flags);
 
@@ -441,7 +441,7 @@ static void pl2303_send(struct usb_serial_port *port)
 
 	spin_unlock_irqrestore(&priv->lock, flags);
 
-	usb_serial_debug_data(debug, &port->dev, __FUNCTION__, count,
+	usb_serial_debug_data(debug, &port->dev, __func__, count,
 			      port->write_urb->transfer_buffer);
 
 	port->write_urb->transfer_buffer_length = count;
@@ -449,7 +449,7 @@ static void pl2303_send(struct usb_serial_port *port)
 	result = usb_submit_urb(port->write_urb, GFP_ATOMIC);
 	if (result) {
 		dev_err(&port->dev, "%s - failed submitting write urb,"
-			" error %d\n", __FUNCTION__, result);
+			" error %d\n", __func__, result);
 		priv->write_urb_in_use = 0;
 		// TODO: reschedule pl2303_send
 	}
@@ -463,7 +463,7 @@ static int pl2303_write(struct usb_serial_port *port, const unsigned char *buf,
 	struct pl2303_private *priv = usb_get_serial_port_data(port);
 	unsigned long flags;
 
-	dbg("%s - port %d, %d bytes", __FUNCTION__, port->number, count);
+	dbg("%s - port %d, %d bytes", __func__, port->number, count);
 
 	if (!count)
 		return count;
@@ -483,13 +483,13 @@ static int pl2303_write_room(struct usb_serial_port *port)
 	int room = 0;
 	unsigned long flags;
 
-	dbg("%s - port %d", __FUNCTION__, port->number);
+	dbg("%s - port %d", __func__, port->number);
 
 	spin_lock_irqsave(&priv->lock, flags);
 	room = pl2303_buf_space_avail(priv->buf);
 	spin_unlock_irqrestore(&priv->lock, flags);
 
-	dbg("%s - returns %d", __FUNCTION__, room);
+	dbg("%s - returns %d", __func__, room);
 	return room;
 }
 
@@ -499,13 +499,13 @@ static int pl2303_chars_in_buffer(struct usb_serial_port *port)
 	int chars = 0;
 	unsigned long flags;
 
-	dbg("%s - port %d", __FUNCTION__, port->number);
+	dbg("%s - port %d", __func__, port->number);
 
 	spin_lock_irqsave(&priv->lock, flags);
 	chars = pl2303_buf_data_avail(priv->buf);
 	spin_unlock_irqrestore(&priv->lock, flags);
 
-	dbg("%s - returns %d", __FUNCTION__, chars);
+	dbg("%s - returns %d", __func__, chars);
 	return chars;
 }
 
@@ -521,7 +521,7 @@ static void pl2303_set_termios(struct usb_serial_port *port,
 	int i;
 	u8 control;
 
-	dbg("%s -  port %d", __FUNCTION__, port->number);
+	dbg("%s -  port %d", __func__, port->number);
 
 	spin_lock_irqsave(&priv->lock, flags);
 	if (!priv->termios_initialized) {
@@ -545,7 +545,7 @@ static void pl2303_set_termios(struct usb_serial_port *port,
 
 	buf = kzalloc(7, GFP_KERNEL);
 	if (!buf) {
-		dev_err(&port->dev, "%s - out of memory.\n", __FUNCTION__);
+		dev_err(&port->dev, "%s - out of memory.\n", __func__);
 		return;
 	}
 
@@ -563,11 +563,11 @@ static void pl2303_set_termios(struct usb_serial_port *port,
 			default:
 			case CS8:	buf[6] = 8;	break;
 		}
-		dbg("%s - data bits = %d", __FUNCTION__, buf[6]);
+		dbg("%s - data bits = %d", __func__, buf[6]);
 	}
 
 	baud = tty_get_baud_rate(port->tty);;
-	dbg("%s - baud = %d", __FUNCTION__, baud);
+	dbg("%s - baud = %d", __func__, baud);
 	if (baud) {
 		buf[0] = baud & 0xff;
 		buf[1] = (baud >> 8) & 0xff;
@@ -580,10 +580,10 @@ static void pl2303_set_termios(struct usb_serial_port *port,
 	/* For reference buf[4]=2 is 2 stop bits */
 	if (cflag & CSTOPB) {
 		buf[4] = 2;
-		dbg("%s - stop bits = 2", __FUNCTION__);
+		dbg("%s - stop bits = 2", __func__);
 	} else {
 		buf[4] = 0;
-		dbg("%s - stop bits = 1", __FUNCTION__);
+		dbg("%s - stop bits = 1", __func__);
 	}
 
 	if (cflag & PARENB) {
@@ -594,14 +594,14 @@ static void pl2303_set_termios(struct usb_serial_port *port,
 		/* For reference buf[5]=4 is space parity */
 		if (cflag & PARODD) {
 			buf[5] = 1;
-			dbg("%s - parity = odd", __FUNCTION__);
+			dbg("%s - parity = odd", __func__);
 		} else {
 			buf[5] = 2;
-			dbg("%s - parity = even", __FUNCTION__);
+			dbg("%s - parity = even", __func__);
 		}
 	} else {
 		buf[5] = 0;
-		dbg("%s - parity = none", __FUNCTION__);
+		dbg("%s - parity = none", __func__);
 	}
 
 	i = usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),
@@ -657,7 +657,7 @@ static void pl2303_close(struct usb_serial_port *port, struct file *filp)
 	long timeout;
 	wait_queue_t wait;
 
-	dbg("%s - port %d", __FUNCTION__, port->number);
+	dbg("%s - port %d", __func__, port->number);
 
 	/* wait for data to drain from the buffer */
 	spin_lock_irqsave(&priv->lock, flags);
@@ -695,7 +695,7 @@ static void pl2303_close(struct usb_serial_port *port, struct file *filp)
 	schedule_timeout_interruptible(timeout);
 
 	/* shutdown our urbs */
-	dbg("%s - shutting down urbs", __FUNCTION__);
+	dbg("%s - shutting down urbs", __func__);
 	usb_kill_urb(port->write_urb);
 	usb_kill_urb(port->read_urb);
 	usb_kill_urb(port->interrupt_in_urb);
@@ -719,7 +719,7 @@ static int pl2303_open(struct usb_serial_port *port, struct file *filp)
 	struct pl2303_private *priv = usb_get_serial_port_data(port);
 	int result;
 
-	dbg("%s -  port %d", __FUNCTION__, port->number);
+	dbg("%s -  port %d", __func__, port->number);
 
 	if (priv->type != HX) {
 		usb_clear_halt(serial->dev, port->write_urb->pipe);
@@ -737,22 +737,22 @@ static int pl2303_open(struct usb_serial_port *port, struct file *filp)
 
 	//FIXME: need to assert RTS and DTR if CRTSCTS off
 
-	dbg("%s - submitting read urb", __FUNCTION__);
+	dbg("%s - submitting read urb", __func__);
 	port->read_urb->dev = serial->dev;
 	result = usb_submit_urb(port->read_urb, GFP_KERNEL);
 	if (result) {
 		dev_err(&port->dev, "%s - failed submitting read urb,"
-			" error %d\n", __FUNCTION__, result);
+			" error %d\n", __func__, result);
 		pl2303_close(port, NULL);
 		return -EPROTO;
 	}
 
-	dbg("%s - submitting interrupt urb", __FUNCTION__);
+	dbg("%s - submitting interrupt urb", __func__);
 	port->interrupt_in_urb->dev = serial->dev;
 	result = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);
 	if (result) {
 		dev_err(&port->dev, "%s - failed submitting interrupt urb,"
-			" error %d\n", __FUNCTION__, result);
+			" error %d\n", __func__, result);
 		pl2303_close(port, NULL);
 		return -EPROTO;
 	}
@@ -792,7 +792,7 @@ static int pl2303_tiocmget(struct usb_serial_port *port, struct file *file)
 	unsigned int status;
 	unsigned int result;
 
-	dbg("%s (%d)", __FUNCTION__, port->number);
+	dbg("%s (%d)", __func__, port->number);
 
 	if (!usb_get_intfdata(port->serial->interface))
 		return -ENODEV;
@@ -809,7 +809,7 @@ static int pl2303_tiocmget(struct usb_serial_port *port, struct file *file)
 		  | ((status & UART_RING)	? TIOCM_RI  : 0)
 		  | ((status & UART_DCD)	? TIOCM_CD  : 0);
 
-	dbg("%s - result = %x", __FUNCTION__, result);
+	dbg("%s - result = %x", __func__, result);
 
 	return result;
 }
@@ -853,15 +853,15 @@ static int wait_modem_info(struct usb_serial_port *port, unsigned int arg)
 static int pl2303_ioctl(struct usb_serial_port *port, struct file *file,
 			unsigned int cmd, unsigned long arg)
 {
-	dbg("%s (%d) cmd = 0x%04x", __FUNCTION__, port->number, cmd);
+	dbg("%s (%d) cmd = 0x%04x", __func__, port->number, cmd);
 
 	switch (cmd) {
 		case TIOCMIWAIT:
-			dbg("%s (%d) TIOCMIWAIT", __FUNCTION__,  port->number);
+			dbg("%s (%d) TIOCMIWAIT", __func__,  port->number);
 			return wait_modem_info(port, arg);
 
 		default:
-			dbg("%s not supported = 0x%04x", __FUNCTION__, cmd);
+			dbg("%s not supported = 0x%04x", __func__, cmd);
 			break;
 	}
 
@@ -874,19 +874,19 @@ static void pl2303_break_ctl(struct usb_serial_port *port, int break_state)
 	u16 state;
 	int result;
 
-	dbg("%s - port %d", __FUNCTION__, port->number);
+	dbg("%s - port %d", __func__, port->number);
 
 	if (break_state == 0)
 		state = BREAK_OFF;
 	else
 		state = BREAK_ON;
-	dbg("%s - turning break %s", __FUNCTION__, state==BREAK_OFF ? "off" : "on");
+	dbg("%s - turning break %s", __func__, state==BREAK_OFF ? "off" : "on");
 
 	result = usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),
 				 BREAK_REQUEST, BREAK_REQUEST_TYPE, state,
 				 0, NULL, 0, 100);
 	if (result)
-		dbg("%s - error sending break = %d", __FUNCTION__, result);
+		dbg("%s - error sending break = %d", __func__, result);
 }
 
 static void pl2303_shutdown(struct usb_serial *serial)
@@ -894,7 +894,7 @@ static void pl2303_shutdown(struct usb_serial *serial)
 	int i;
 	struct pl2303_private *priv;
 
-	dbg("%s", __FUNCTION__);
+	dbg("%s", __func__);
 
 	for (i = 0; i < serial->num_ports; ++i) {
 		priv = usb_get_serial_port_data(serial->port[i]);
@@ -949,7 +949,7 @@ static void pl2303_read_int_callback(struct urb *urb)
 	int status = urb->status;
 	int retval;
 
-	dbg("%s (%d)", __FUNCTION__, port->number);
+	dbg("%s (%d)", __func__, port->number);
 
 	switch (status) {
 	case 0:
@@ -959,16 +959,16 @@ static void pl2303_read_int_callback(struct urb *urb)
 	case -ENOENT:
 	case -ESHUTDOWN:
 		/* this urb is terminated, clean up */
-		dbg("%s - urb shutting down with status: %d", __FUNCTION__,
+		dbg("%s - urb shutting down with status: %d", __func__,
 		    status);
 		return;
 	default:
-		dbg("%s - nonzero urb status received: %d", __FUNCTION__,
+		dbg("%s - nonzero urb status received: %d", __func__,
 		    status);
 		goto exit;
 	}
 
-	usb_serial_debug_data(debug, &port->dev, __FUNCTION__,
+	usb_serial_debug_data(debug, &port->dev, __func__,
 			      urb->actual_length, urb->transfer_buffer);
 
 	pl2303_update_line_status(port, data, actual_length);
@@ -978,7 +978,7 @@ static void pl2303_read_int_callback(struct urb *urb)
 	if (retval)
 		dev_err(&urb->dev->dev,
 			"%s - usb_submit_urb failed with result %d\n",
-			__FUNCTION__, retval);
+			__func__, retval);
 }
 
 static void pl2303_read_bulk_callback(struct urb *urb)
@@ -994,32 +994,32 @@ static void pl2303_read_bulk_callback(struct urb *urb)
 	u8 line_status;
 	char tty_flag;
 
-	dbg("%s - port %d", __FUNCTION__, port->number);
+	dbg("%s - port %d", __func__, port->number);
 
 	if (status) {
-		dbg("%s - urb status = %d", __FUNCTION__, status);
+		dbg("%s - urb status = %d", __func__, status);
 		if (!port->open_count) {
-			dbg("%s - port is closed, exiting.", __FUNCTION__);
+			dbg("%s - port is closed, exiting.", __func__);
 			return;
 		}
 		if (status == -EPROTO) {
 			/* PL2303 mysteriously fails with -EPROTO reschedule
 			 * the read */
 			dbg("%s - caught -EPROTO, resubmitting the urb",
-			    __FUNCTION__);
+			    __func__);
 			urb->dev = port->serial->dev;
 			result = usb_submit_urb(urb, GFP_ATOMIC);
 			if (result)
 				dev_err(&urb->dev->dev, "%s - failed"
 					" resubmitting read urb, error %d\n",
-					__FUNCTION__, result);
+					__func__, result);
 			return;
 		}
-		dbg("%s - unable to handle the error, exiting.", __FUNCTION__);
+		dbg("%s - unable to handle the error, exiting.", __func__);
 		return;
 	}
 
-	usb_serial_debug_data(debug, &port->dev, __FUNCTION__,
+	usb_serial_debug_data(debug, &port->dev, __func__,
 			      urb->actual_length, data);
 
 	/* get tty_flag from status */
@@ -1039,7 +1039,7 @@ static void pl2303_read_bulk_callback(struct urb *urb)
 		tty_flag = TTY_PARITY;
 	else if (line_status & UART_FRAME_ERROR)
 		tty_flag = TTY_FRAME;
-	dbg("%s - tty_flag = %d", __FUNCTION__, tty_flag);
+	dbg("%s - tty_flag = %d", __func__, tty_flag);
 
 	tty = port->tty;
 	if (tty && urb->actual_length) {
@@ -1058,7 +1058,7 @@ static void pl2303_read_bulk_callback(struct urb *urb)
 		result = usb_submit_urb(urb, GFP_ATOMIC);
 		if (result)
 			dev_err(&urb->dev->dev, "%s - failed resubmitting"
-				" read urb, error %d\n", __FUNCTION__, result);
+				" read urb, error %d\n", __func__, result);
 	}
 
 	return;
@@ -1071,7 +1071,7 @@ static void pl2303_write_bulk_callback(struct urb *urb)
 	int result;
 	int status = urb->status;
 
-	dbg("%s - port %d", __FUNCTION__, port->number);
+	dbg("%s - port %d", __func__, port->number);
 
 	switch (status) {
 	case 0:
@@ -1081,21 +1081,21 @@ static void pl2303_write_bulk_callback(struct urb *urb)
 	case -ENOENT:
 	case -ESHUTDOWN:
 		/* this urb is terminated, clean up */
-		dbg("%s - urb shutting down with status: %d", __FUNCTION__,
+		dbg("%s - urb shutting down with status: %d", __func__,
 		    status);
 		priv->write_urb_in_use = 0;
 		return;
 	default:
 		/* error in the urb, so we have to resubmit it */
-		dbg("%s - Overflow in write", __FUNCTION__);
-		dbg("%s - nonzero write bulk status received: %d", __FUNCTION__,
+		dbg("%s - Overflow in write", __func__);
+		dbg("%s - nonzero write bulk status received: %d", __func__,
 		    status);
 		port->write_urb->transfer_buffer_length = 1;
 		port->write_urb->dev = port->serial->dev;
 		result = usb_submit_urb(port->write_urb, GFP_ATOMIC);
 		if (result)
 			dev_err(&urb->dev->dev, "%s - failed resubmitting write"
-				" urb, error %d\n", __FUNCTION__, result);
+				" urb, error %d\n", __func__, result);
 		else
 			return;
 	}

commit 0ba4034e20abf372dae6c6cabeeeab600acb5889
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed Apr 16 09:17:38 2008 -0700

    USB: serial: remove unneeded number endpoints settings
    
    The usb-serial core no longer checks these fields so remove them from
    all of the individual drivers.  They will be removed from the usb-serial
    core in a patch later in the series.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 2af778555bdc..1fbb4dbdf23d 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -1114,9 +1114,6 @@ static struct usb_serial_driver pl2303_device = {
 	},
 	.id_table =		id_table,
 	.usb_driver = 		&pl2303_driver,
-	.num_interrupt_in =	NUM_DONT_CARE,
-	.num_bulk_in =		1,
-	.num_bulk_out =		1,
 	.num_ports =		1,
 	.open =			pl2303_open,
 	.close =		pl2303_close,

commit b483b6aaa56f0db72fa50e85b6499a32d82009bf
Author: Max Arnold <lwarxx@gmail.com>
Date:   Thu Mar 20 16:43:56 2008 +0700

    USB: pl2303: another product ID
    
    Device like this http://aldiga.com/english/A-100-USB-EDGE10.htm
    contains Prolific 2303 chip.
    Actually their site a bit outdated - I have AlDiga AL-11U
    GSM/GPRS/EDGE modem and it works with pl2303 module after adding
    corresponding product ID.
    
    By default modem uses baud rate 460800.  GSM chipset - SIMCom SIM600,
    quad band 850/900/1800/1900 MHz
    
    Device info:
    
    T:  Bus=04 Lev=01 Prnt=01 Port=00 Cnt=01 Dev#=  5 Spd=12  MxCh= 0
    D:  Ver= 1.10 Cls=00(>ifc ) Sub=00 Prot=00 MxPS= 8 #Cfgs=  1
    P:  Vendor=067b ProdID=0611 Rev= 0.00
    C:* #Ifs= 1 Cfg#= 1 Atr=a0 MxPwr=500mA
    I:* If#= 0 Alt= 0 #EPs= 3 Cls=ff(vend.) Sub=00 Prot=00 Driver=pl2303
    E:  Ad=81(I) Atr=03(Int.) MxPS=  10 Ivl=1ms
    E:  Ad=02(O) Atr=02(Bulk) MxPS=  64 Ivl=0ms
    E:  Ad=83(I) Atr=02(Bulk) MxPS=  64 Ivl=0ms
    
    From: Max Arnold <lwarxx@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index ae3ec1a64008..2af778555bdc 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -55,6 +55,7 @@ static struct usb_device_id id_table [] = {
 	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_DCU11) },
 	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_RSAQ3) },
 	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_PHAROS) },
+	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_ALDIGA) },
 	{ USB_DEVICE(IODATA_VENDOR_ID, IODATA_PRODUCT_ID) },
 	{ USB_DEVICE(IODATA_VENDOR_ID, IODATA_PRODUCT_ID_RSAQ5) },
 	{ USB_DEVICE(ATEN_VENDOR_ID, ATEN_PRODUCT_ID) },

commit 0915f490d81c1a5098b399ec6c0be45bd421ee1d
Author: Oliver Neukum <oliver@neukum.org>
Date:   Wed Jan 23 12:28:45 2008 +0100

    USB: last abuses of intfdata in close for usb-serial drivers
    
    these drivers abused intfdata in close() as flags for binding.
    That races with reprobing of those devices. This patch fixes that by using
    the flag and the locks introduced with the patch against mos7720.
    
    Signed-off-by: Oliver Neukum <oneukum@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index ac3d8765f482..ae3ec1a64008 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -667,7 +667,7 @@ static void pl2303_close(struct usb_serial_port *port, struct file *filp)
 		set_current_state(TASK_INTERRUPTIBLE);
 		if (pl2303_buf_data_avail(priv->buf) == 0 ||
 		    timeout == 0 || signal_pending(current) ||
-		    !usb_get_intfdata(port->serial->interface))	/* disconnect */
+		    port->serial->disconnected)
 			break;
 		spin_unlock_irqrestore(&priv->lock, flags);
 		timeout = schedule_timeout(timeout);

commit fcf9e55e066d12c18add7c8a292bf879b45b1d55
Author: Sarah Sharp <saharabeara@gmail.com>
Date:   Fri Dec 14 14:09:30 2007 -0800

    USB: pl2303: Add autosuspend support to pl2303 usb serial converter.
    
    Signed-off-by: Sarah Sharp <saharabeara@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index c27f2f822f13..ac3d8765f482 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -99,7 +99,10 @@ static struct usb_driver pl2303_driver = {
 	.probe =	usb_serial_probe,
 	.disconnect =	usb_serial_disconnect,
 	.id_table =	id_table,
+	.suspend =      usb_serial_suspend,
+	.resume =       usb_serial_resume,
 	.no_dynamic_id = 	1,
+	.supports_autosuspend =	1,
 };
 
 #define SET_LINE_REQUEST_TYPE		0x21

commit 3e152505a57db6622deb1322c22551c046e33d16
Author: Sarah Sharp <saharabeara@gmail.com>
Date:   Fri Dec 14 14:08:35 2007 -0800

    USB: pl2303: Move pl2303 vendor specific init to probe function.
    
    Without this fix, the pl2303 usb-serial adapter would not suspend properly
    unless it had been opened first.  A pl2303 type_1 chip will still break if the
    system is hibernated while the RS-232 connector is powered by another system.
    This was broken before, and a reset resume does not fix it.  All other suspend
    and autosuspend scenarios work with ATEN pl2303 adaptors with HX and type_1 chips.
    
    Signed-off-by: Sarah Sharp <saharabeara@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index fd8c09fd3288..c27f2f822f13 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -338,8 +338,13 @@ static int pl2303_startup(struct usb_serial *serial)
 {
 	struct pl2303_private *priv;
 	enum pl2303_type type = type_0;
+	unsigned char *buf;
 	int i;
 
+	buf = kmalloc(10, GFP_KERNEL);
+	if (buf == NULL)
+		return -ENOMEM;
+
 	if (serial->dev->descriptor.bDeviceClass == 0x02)
 		type = type_0;
 	else if (serial->dev->descriptor.bMaxPacketSize0 == 0x40)
@@ -364,9 +369,27 @@ static int pl2303_startup(struct usb_serial *serial)
 		priv->type = type;
 		usb_set_serial_port_data(serial->port[i], priv);
 	}
+
+	pl2303_vendor_read(0x8484, 0, serial, buf);
+	pl2303_vendor_write(0x0404, 0, serial);
+	pl2303_vendor_read(0x8484, 0, serial, buf);
+	pl2303_vendor_read(0x8383, 0, serial, buf);
+	pl2303_vendor_read(0x8484, 0, serial, buf);
+	pl2303_vendor_write(0x0404, 1, serial);
+	pl2303_vendor_read(0x8484, 0, serial, buf);
+	pl2303_vendor_read(0x8383, 0, serial, buf);
+	pl2303_vendor_write(0, 1, serial);
+	pl2303_vendor_write(1, 0, serial);
+	if (type == HX)
+		pl2303_vendor_write(2, 0x44, serial);
+	else
+		pl2303_vendor_write(2, 0x24, serial);
+
+	kfree(buf);
 	return 0;
 
 cleanup:
+	kfree(buf);
 	for (--i; i>=0; --i) {
 		priv = usb_get_serial_port_data(serial->port[i]);
 		pl2303_buf_free(priv->buf);
@@ -690,7 +713,6 @@ static int pl2303_open(struct usb_serial_port *port, struct file *filp)
 	struct ktermios tmp_termios;
 	struct usb_serial *serial = port->serial;
 	struct pl2303_private *priv = usb_get_serial_port_data(port);
-	unsigned char *buf;
 	int result;
 
 	dbg("%s -  port %d", __FUNCTION__, port->number);
@@ -698,35 +720,12 @@ static int pl2303_open(struct usb_serial_port *port, struct file *filp)
 	if (priv->type != HX) {
 		usb_clear_halt(serial->dev, port->write_urb->pipe);
 		usb_clear_halt(serial->dev, port->read_urb->pipe);
-	}
-
-	buf = kmalloc(10, GFP_KERNEL);
-	if (buf==NULL)
-		return -ENOMEM;
-
-	pl2303_vendor_read(0x8484, 0, serial, buf);
-	pl2303_vendor_write(0x0404, 0, serial);
-	pl2303_vendor_read(0x8484, 0, serial, buf);
-	pl2303_vendor_read(0x8383, 0, serial, buf);
-	pl2303_vendor_read(0x8484, 0, serial, buf);
-	pl2303_vendor_write(0x0404, 1, serial);
-	pl2303_vendor_read(0x8484, 0, serial, buf);
-	pl2303_vendor_read(0x8383, 0, serial, buf);
-	pl2303_vendor_write(0, 1, serial);
-	pl2303_vendor_write(1, 0, serial);
-
-	if (priv->type == HX) {
-		/* HX chip */
-		pl2303_vendor_write(2, 0x44, serial);
+	} else {
 		/* reset upstream data pipes */
 		pl2303_vendor_write(8, 0, serial);
 		pl2303_vendor_write(9, 0, serial);
-	} else {
-		pl2303_vendor_write(2, 0x24, serial);
 	}
 
-	kfree(buf);
-
 	/* Setup termios */
 	if (port->tty) {
 		pl2303_set_termios(port, &tmp_termios);

commit eb44da0b3aa0105cb38d81c5747a8feae64834be
Author: Sarah Sharp <saharabeara@gmail.com>
Date:   Fri Dec 14 14:08:00 2007 -0800

    USB: pl2303: Cleanup FISH and SOUP macros in pl2303 driver.
    
    Replace the FISH and SOUP macros that violated the macro guidelines in CodingStyle.
    Turn them into function calls with clearer variable names.
    
    Signed-off-by: Sarah Sharp <saharabeara@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index b7da8b5c3a86..fd8c09fd3288 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -312,6 +312,28 @@ static unsigned int pl2303_buf_get(struct pl2303_buf *pb, char *buf,
 	return count;
 }
 
+static int pl2303_vendor_read(__u16 value, __u16 index,
+		struct usb_serial *serial, unsigned char *buf)
+{
+	int res = usb_control_msg(serial->dev, usb_rcvctrlpipe(serial->dev, 0),
+			VENDOR_READ_REQUEST, VENDOR_READ_REQUEST_TYPE,
+			value, index, buf, 1, 100);
+	dbg("0x%x:0x%x:0x%x:0x%x  %d - %x", VENDOR_READ_REQUEST_TYPE,
+			VENDOR_READ_REQUEST, value, index, res, buf[0]);
+	return res;
+}
+
+static int pl2303_vendor_write(__u16 value, __u16 index,
+		struct usb_serial *serial)
+{
+	int res = usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),
+			VENDOR_WRITE_REQUEST, VENDOR_WRITE_REQUEST_TYPE,
+			value, index, NULL, 0, 100);
+	dbg("0x%x:0x%x:0x%x:0x%x  %d", VENDOR_WRITE_REQUEST_TYPE,
+			VENDOR_WRITE_REQUEST, value, index, res);
+	return res;
+}
+
 static int pl2303_startup(struct usb_serial *serial)
 {
 	struct pl2303_private *priv;
@@ -584,24 +606,12 @@ static void pl2303_set_termios(struct usb_serial_port *port,
 	     buf[0], buf[1], buf[2], buf[3], buf[4], buf[5], buf[6]);
 
 	if (cflag & CRTSCTS) {
-		__u16 index;
 		if (priv->type == HX)
-			index = 0x61;
+			pl2303_vendor_write(0x0, 0x61, serial);
 		else
-			index = 0x41;
-		i = usb_control_msg(serial->dev,
-				    usb_sndctrlpipe(serial->dev, 0),
-				    VENDOR_WRITE_REQUEST,
-				    VENDOR_WRITE_REQUEST_TYPE,
-				    0x0, index, NULL, 0, 100);
-		dbg("0x40:0x1:0x0:0x%x  %d", index, i);
+			pl2303_vendor_write(0x0, 0x41, serial);
 	} else {
-		i = usb_control_msg(serial->dev,
-				    usb_sndctrlpipe(serial->dev, 0),
-				    VENDOR_WRITE_REQUEST,
-				    VENDOR_WRITE_REQUEST_TYPE,
-				    0x0, 0x0, NULL, 0, 100);
-		dbg ("0x40:0x1:0x0:0x0  %d", i);
+		pl2303_vendor_write(0x0, 0x0, serial);
 	}
 
 	/* FIXME: Need to read back resulting baud rate */
@@ -694,35 +704,25 @@ static int pl2303_open(struct usb_serial_port *port, struct file *filp)
 	if (buf==NULL)
 		return -ENOMEM;
 
-#define FISH(a,b,c,d)								\
-	result=usb_control_msg(serial->dev, usb_rcvctrlpipe(serial->dev,0),	\
-			       b, a, c, d, buf, 1, 100);			\
-	dbg("0x%x:0x%x:0x%x:0x%x  %d - %x",a,b,c,d,result,buf[0]);
-
-#define SOUP(a,b,c,d)								\
-	result=usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev,0),	\
-			       b, a, c, d, NULL, 0, 100);			\
-	dbg("0x%x:0x%x:0x%x:0x%x  %d",a,b,c,d,result);
-
-	FISH (VENDOR_READ_REQUEST_TYPE, VENDOR_READ_REQUEST, 0x8484, 0);
-	SOUP (VENDOR_WRITE_REQUEST_TYPE, VENDOR_WRITE_REQUEST, 0x0404, 0);
-	FISH (VENDOR_READ_REQUEST_TYPE, VENDOR_READ_REQUEST, 0x8484, 0);
-	FISH (VENDOR_READ_REQUEST_TYPE, VENDOR_READ_REQUEST, 0x8383, 0);
-	FISH (VENDOR_READ_REQUEST_TYPE, VENDOR_READ_REQUEST, 0x8484, 0);
-	SOUP (VENDOR_WRITE_REQUEST_TYPE, VENDOR_WRITE_REQUEST, 0x0404, 1);
-	FISH (VENDOR_READ_REQUEST_TYPE, VENDOR_READ_REQUEST, 0x8484, 0);
-	FISH (VENDOR_READ_REQUEST_TYPE, VENDOR_READ_REQUEST, 0x8383, 0);
-	SOUP (VENDOR_WRITE_REQUEST_TYPE, VENDOR_WRITE_REQUEST, 0, 1);
-	SOUP (VENDOR_WRITE_REQUEST_TYPE, VENDOR_WRITE_REQUEST, 1, 0);
+	pl2303_vendor_read(0x8484, 0, serial, buf);
+	pl2303_vendor_write(0x0404, 0, serial);
+	pl2303_vendor_read(0x8484, 0, serial, buf);
+	pl2303_vendor_read(0x8383, 0, serial, buf);
+	pl2303_vendor_read(0x8484, 0, serial, buf);
+	pl2303_vendor_write(0x0404, 1, serial);
+	pl2303_vendor_read(0x8484, 0, serial, buf);
+	pl2303_vendor_read(0x8383, 0, serial, buf);
+	pl2303_vendor_write(0, 1, serial);
+	pl2303_vendor_write(1, 0, serial);
 
 	if (priv->type == HX) {
 		/* HX chip */
-		SOUP (VENDOR_WRITE_REQUEST_TYPE, VENDOR_WRITE_REQUEST, 2, 0x44);
+		pl2303_vendor_write(2, 0x44, serial);
 		/* reset upstream data pipes */
-          	SOUP (VENDOR_WRITE_REQUEST_TYPE, VENDOR_WRITE_REQUEST, 8, 0);
-        	SOUP (VENDOR_WRITE_REQUEST_TYPE, VENDOR_WRITE_REQUEST, 9, 0);
+		pl2303_vendor_write(8, 0, serial);
+		pl2303_vendor_write(9, 0, serial);
 	} else {
-		SOUP (VENDOR_WRITE_REQUEST_TYPE, VENDOR_WRITE_REQUEST, 2, 0x24);
+		pl2303_vendor_write(2, 0x24, serial);
 	}
 
 	kfree(buf);

commit 57833ea6b95a3995149f1f6d1a8d8862ab7a0ba2
Author: Akira Tsukamoto <akirat@rd.scei.sony.co.jp>
Date:   Fri Jan 18 18:58:28 2008 +0900

    USB: pl2303: add support for RATOC REX-USB60F
    
    pl2303: add support for RATOC REX-USB60F
    
    This patch adds support for RATOC REX-USB60F Serial Adapters,
    which is widely used in Japan recently.
    
    Cc: stable <stable@kernel.org>
    Signed-off-by: Akira Tsukamoto <akirat@rd.scei.sony.co.jp>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 1509fba26219..b7da8b5c3a86 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -65,6 +65,7 @@ static struct usb_device_id id_table [] = {
 	{ USB_DEVICE(ITEGNO_VENDOR_ID, ITEGNO_PRODUCT_ID_2080) },
 	{ USB_DEVICE(MA620_VENDOR_ID, MA620_PRODUCT_ID) },
 	{ USB_DEVICE(RATOC_VENDOR_ID, RATOC_PRODUCT_ID) },
+	{ USB_DEVICE(RATOC_VENDOR_ID, RATOC_PRODUCT_ID_USB60F) },
 	{ USB_DEVICE(TRIPP_VENDOR_ID, TRIPP_PRODUCT_ID) },
 	{ USB_DEVICE(RADIOSHACK_VENDOR_ID, RADIOSHACK_PRODUCT_ID) },
 	{ USB_DEVICE(DCU10_VENDOR_ID, DCU10_PRODUCT_ID) },

commit 94cb373a75a903a6246d3e671cabd3e7b7084105
Author: Daniel Kozák <kozzi11@gmail.com>
Date:   Sat Jan 12 11:53:09 2008 +0100

    USB: remove duplicate entry in Option driver and Pl2303 driver for Huawei modem
    
    Remove entry for Huawei E620 UMTS/HSDPA card (ID: 12d1:1001) in pl2303 driver
    Option driver is use instead
    
    Cc: stable <stable@kernel.org>
    Signed-off-by: Daniel Kozák <kozzi11@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 3f499fcfd83c..1509fba26219 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -84,7 +84,6 @@ static struct usb_device_id id_table [] = {
 	{ USB_DEVICE(DATAPILOT_U2_VENDOR_ID, DATAPILOT_U2_PRODUCT_ID) },
 	{ USB_DEVICE(BELKIN_VENDOR_ID, BELKIN_PRODUCT_ID) },
 	{ USB_DEVICE(ALCOR_VENDOR_ID, ALCOR_PRODUCT_ID) },
-	{ USB_DEVICE(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_ID) },
 	{ USB_DEVICE(WS002IN_VENDOR_ID, WS002IN_PRODUCT_ID) },
 	{ USB_DEVICE(COREGA_VENDOR_ID, COREGA_PRODUCT_ID) },
 	{ USB_DEVICE(HL340_VENDOR_ID, HL340_PRODUCT_ID) },

commit cc311ee7d29d96f0bf15599f4456012d6f5ea23c
Author: Damien Stuart <dstuart@dstuart.org>
Date:   Sun Jan 6 13:51:39 2008 -0500

    USB: Adding YC Cable USB Serial device to pl2303
    
    This simply adds the "YC Cable" as a vendor and its pl2303-based
    USB<->Serial adapter as a product.  This particular adapter is sold by
    Radio Shack.  I've done limited testing on a few different systems with
    no issues.
    
    Cc: stable <stable@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index fbce1ba333b0..3f499fcfd83c 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -88,6 +88,7 @@ static struct usb_device_id id_table [] = {
 	{ USB_DEVICE(WS002IN_VENDOR_ID, WS002IN_PRODUCT_ID) },
 	{ USB_DEVICE(COREGA_VENDOR_ID, COREGA_PRODUCT_ID) },
 	{ USB_DEVICE(HL340_VENDOR_ID, HL340_PRODUCT_ID) },
+	{ USB_DEVICE(YCCABLE_VENDOR_ID, YCCABLE_PRODUCT_ID) },
 	{ }					/* Terminating entry */
 };
 

commit 002e8f2c80c6be76bb312940bc278fc10b2b2487
Author: Piotr Roszatycki <dexter@debian.org>
Date:   Wed Jan 2 11:16:57 2008 +0100

    USB: add support for 4348:5523 WinChipHead USB->RS 232 adapter
    
    add support for:
    
      4348:5523 WinChipHead USB->RS 232 adapter with Prolifec PL 2303 chipset
    
    [ mingo@elte.hu: merged it and nursed it upstream ]
    
    Cc: stable <stable@kernel.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 0da1df9c79bf..fbce1ba333b0 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -87,6 +87,7 @@ static struct usb_device_id id_table [] = {
 	{ USB_DEVICE(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_ID) },
 	{ USB_DEVICE(WS002IN_VENDOR_ID, WS002IN_PRODUCT_ID) },
 	{ USB_DEVICE(COREGA_VENDOR_ID, COREGA_PRODUCT_ID) },
+	{ USB_DEVICE(HL340_VENDOR_ID, HL340_PRODUCT_ID) },
 	{ }					/* Terminating entry */
 };
 

commit bf5e5834bffc62b50cd4a201804506eb11ef1af8
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Tue Jan 8 14:55:51 2008 +0000

    pl2303: Fix mode switching regression
    
    Cleaning out all the incorrect 'no change made' checks for termios
    settings showed up a problem with the PL2303. The hardware here seems to
    lose sync and bits if you tell it to make no changes. This shows up with
    a real world application.
    
    To fix this the driver check for meaningful hardware changes is restored
    but doing the tests correctly and as a tty layer function so it doesn't
    get duplicated wrongly everywhere if other drivers turn out to need it.
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Tested-by: Mirko Parthey <mirko.parthey@informatik.tu-chemnitz.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index cf8add91de05..0da1df9c79bf 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -483,6 +483,13 @@ static void pl2303_set_termios(struct usb_serial_port *port,
 	}
 	spin_unlock_irqrestore(&priv->lock, flags);
 
+	/* The PL2303 is reported to lose bytes if you change
+	   serial settings even to the same values as before. Thus
+	   we actually need to filter in this specific case */
+
+	if (!tty_termios_hw_change(port->tty->termios, old_termios))
+		return;
+
 	cflag = port->tty->termios->c_cflag;
 
 	buf = kzalloc(7, GFP_KERNEL);

commit 9e3285dba5cac12d656da66fd7d420ff1bc0ecc0
Author: Magnus Damm <magnus.damm@gmail.com>
Date:   Thu Nov 8 16:45:46 2007 +0900

    USB: pl2303: add support for Corega CG-USBRS232R
    
    pl2303: add support for Corega CG-USBRS232R
    
    This patch adds support for Corega CG-USBRS232R Serial Adapters.
    
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 2cd3f1d4b687..cf8add91de05 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -86,6 +86,7 @@ static struct usb_device_id id_table [] = {
 	{ USB_DEVICE(ALCOR_VENDOR_ID, ALCOR_PRODUCT_ID) },
 	{ USB_DEVICE(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_ID) },
 	{ USB_DEVICE(WS002IN_VENDOR_ID, WS002IN_PRODUCT_ID) },
+	{ USB_DEVICE(COREGA_VENDOR_ID, COREGA_PRODUCT_ID) },
 	{ }					/* Terminating entry */
 };
 

commit 8a28dea3accda319d51a1bf4d3e280771d946f78
Author: Masakazu Mokuno <mokuno@sm.sony.co.jp>
Date:   Tue Oct 23 13:51:57 2007 +0900

    usb: serial/pl2303: support for IO Data Device RSAQ5
    
    This patch adds support for the IO Data Device USB-RSAQ5, PL2303 based
    USB-serial converter, to pl2303 driver
    
    Signed-off-by: Masakazu Mokuno <mokuno@sm.sony.co.jp>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 1103b2f514b7..2cd3f1d4b687 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -56,6 +56,7 @@ static struct usb_device_id id_table [] = {
 	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_RSAQ3) },
 	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_PHAROS) },
 	{ USB_DEVICE(IODATA_VENDOR_ID, IODATA_PRODUCT_ID) },
+	{ USB_DEVICE(IODATA_VENDOR_ID, IODATA_PRODUCT_ID_RSAQ5) },
 	{ USB_DEVICE(ATEN_VENDOR_ID, ATEN_PRODUCT_ID) },
 	{ USB_DEVICE(ATEN_VENDOR_ID2, ATEN_PRODUCT_ID) },
 	{ USB_DEVICE(ELCOM_VENDOR_ID, ELCOM_PRODUCT_ID) },

commit df64c47184aedf34fd2a69a4b7f68584fe982fdf
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Mon Oct 15 20:54:47 2007 +0100

    USB: pl2303: remove can't happen checks, set speed properly and report baud rate
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 1da57fd9ea23..1103b2f514b7 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -470,16 +470,13 @@ static void pl2303_set_termios(struct usb_serial_port *port,
 
 	dbg("%s -  port %d", __FUNCTION__, port->number);
 
-	if ((!port->tty) || (!port->tty->termios)) {
-		dbg("%s - no tty structures", __FUNCTION__);
-		return;
-	}
-
 	spin_lock_irqsave(&priv->lock, flags);
 	if (!priv->termios_initialized) {
 		*(port->tty->termios) = tty_std_termios;
 		port->tty->termios->c_cflag = B9600 | CS8 | CREAD |
 					      HUPCL | CLOCAL;
+		port->tty->termios->c_ispeed = 9600;
+		port->tty->termios->c_ospeed = 9600;
 		priv->termios_initialized = 1;
 	}
 	spin_unlock_irqrestore(&priv->lock, flags);
@@ -596,6 +593,10 @@ static void pl2303_set_termios(struct usb_serial_port *port,
 		dbg ("0x40:0x1:0x0:0x0  %d", i);
 	}
 
+	/* FIXME: Need to read back resulting baud rate */
+	if (baud)
+		tty_encode_baud_rate(port->tty, baud, baud);
+
 	kfree(buf);
 }
 

commit e7beb667842ad0f6ec95a22e7c88e71dfbd60649
Author: Andreas Loibl <andreas@andreas-loibl.de>
Date:   Fri Aug 24 01:51:11 2007 +0200

    usb: serial/pl2303: support for BenQ Siemens Mobile Phone EF81
    
    This patch adds support for the BenQ Mobile Phone EF81 to pl2303
    
    Signed-off-by: Andreas Loibl <andreas@andreas-loibl.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index f9f85f56f0db..1da57fd9ea23 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -73,6 +73,7 @@ static struct usb_device_id id_table [] = {
 	{ USB_DEVICE(SIEMENS_VENDOR_ID, SIEMENS_PRODUCT_ID_SX1) },
 	{ USB_DEVICE(SIEMENS_VENDOR_ID, SIEMENS_PRODUCT_ID_X65) },
 	{ USB_DEVICE(SIEMENS_VENDOR_ID, SIEMENS_PRODUCT_ID_X75) },
+	{ USB_DEVICE(SIEMENS_VENDOR_ID, SIEMENS_PRODUCT_ID_EF81) },
 	{ USB_DEVICE(SYNTECH_VENDOR_ID, SYNTECH_PRODUCT_ID) },
 	{ USB_DEVICE(NOKIA_CA42_VENDOR_ID, NOKIA_CA42_PRODUCT_ID) },
 	{ USB_DEVICE(CA_42_CA42_VENDOR_ID, CA_42_CA42_PRODUCT_ID) },

commit e0c79f512cf469bc11fe9d53a4dcc5d0c39a3b79
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Mon Jul 9 12:03:10 2007 -0700

    USB: pl2303: remove bogus checks and fix speed support to use tty_get_baud_rate()
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 4348c1feab4e..f9f85f56f0db 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -484,15 +484,6 @@ static void pl2303_set_termios(struct usb_serial_port *port,
 	spin_unlock_irqrestore(&priv->lock, flags);
 
 	cflag = port->tty->termios->c_cflag;
-	/* check that they really want us to change something */
-	if (old_termios) {
-		if ((cflag == old_termios->c_cflag) &&
-		    (RELEVANT_IFLAG(port->tty->termios->c_iflag) ==
-		     RELEVANT_IFLAG(old_termios->c_iflag))) {
-			dbg("%s - nothing to change...", __FUNCTION__);
-			return;
-		}
-	}
 
 	buf = kzalloc(7, GFP_KERNEL);
 	if (!buf) {
@@ -517,29 +508,7 @@ static void pl2303_set_termios(struct usb_serial_port *port,
 		dbg("%s - data bits = %d", __FUNCTION__, buf[6]);
 	}
 
-	baud = 0;
-	switch (cflag & CBAUD) {
-		case B0:	baud = 0;	break;
-		case B75:	baud = 75;	break;
-		case B150:	baud = 150;	break;
-		case B300:	baud = 300;	break;
-		case B600:	baud = 600;	break;
-		case B1200:	baud = 1200;	break;
-		case B1800:	baud = 1800;	break;
-		case B2400:	baud = 2400;	break;
-		case B4800:	baud = 4800;	break;
-		case B9600:	baud = 9600;	break;
-		case B19200:	baud = 19200;	break;
-		case B38400:	baud = 38400;	break;
-		case B57600:	baud = 57600;	break;
-		case B115200:	baud = 115200;	break;
-		case B230400:	baud = 230400;	break;
-		case B460800:	baud = 460800;	break;
-		default:
-			dev_err(&port->dev, "pl2303 driver does not support"
-				" the baudrate requested (fix it)\n");
-			break;
-	}
+	baud = tty_get_baud_rate(port->tty);;
 	dbg("%s - baud = %d", __FUNCTION__, baud);
 	if (baud) {
 		buf[0] = baud & 0xff;

commit 461d696aeeae294ad22dfcaae462d1757f955778
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Jun 15 15:44:13 2007 -0700

    USB: serial: pl2303: clean up urb->status usage
    
    This done in anticipation of removal of urb->status, which will make
    that patch easier to review and apply in the future.
    
    
    Cc: <linux-usb-devel@lists.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 3022d65bb697..4348c1feab4e 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -961,11 +961,12 @@ static void pl2303_read_int_callback(struct urb *urb)
 	struct usb_serial_port *port = (struct usb_serial_port *) urb->context;
 	unsigned char *data = urb->transfer_buffer;
 	unsigned int actual_length = urb->actual_length;
-	int status;
+	int status = urb->status;
+	int retval;
 
 	dbg("%s (%d)", __FUNCTION__, port->number);
 
-	switch (urb->status) {
+	switch (status) {
 	case 0:
 		/* success */
 		break;
@@ -974,11 +975,11 @@ static void pl2303_read_int_callback(struct urb *urb)
 	case -ESHUTDOWN:
 		/* this urb is terminated, clean up */
 		dbg("%s - urb shutting down with status: %d", __FUNCTION__,
-		    urb->status);
+		    status);
 		return;
 	default:
 		dbg("%s - nonzero urb status received: %d", __FUNCTION__,
-		    urb->status);
+		    status);
 		goto exit;
 	}
 
@@ -988,11 +989,11 @@ static void pl2303_read_int_callback(struct urb *urb)
 	pl2303_update_line_status(port, data, actual_length);
 
 exit:
-	status = usb_submit_urb(urb, GFP_ATOMIC);
-	if (status)
+	retval = usb_submit_urb(urb, GFP_ATOMIC);
+	if (retval)
 		dev_err(&urb->dev->dev,
 			"%s - usb_submit_urb failed with result %d\n",
-			__FUNCTION__, status);
+			__FUNCTION__, retval);
 }
 
 static void pl2303_read_bulk_callback(struct urb *urb)
@@ -1004,23 +1005,23 @@ static void pl2303_read_bulk_callback(struct urb *urb)
 	unsigned long flags;
 	int i;
 	int result;
-	u8 status;
+	int status = urb->status;
+	u8 line_status;
 	char tty_flag;
 
 	dbg("%s - port %d", __FUNCTION__, port->number);
 
-	if (urb->status) {
-		dbg("%s - urb->status = %d", __FUNCTION__, urb->status);
+	if (status) {
+		dbg("%s - urb status = %d", __FUNCTION__, status);
 		if (!port->open_count) {
 			dbg("%s - port is closed, exiting.", __FUNCTION__);
 			return;
 		}
-		if (urb->status == -EPROTO) {
+		if (status == -EPROTO) {
 			/* PL2303 mysteriously fails with -EPROTO reschedule
 			 * the read */
 			dbg("%s - caught -EPROTO, resubmitting the urb",
 			    __FUNCTION__);
-			urb->status = 0;
 			urb->dev = port->serial->dev;
 			result = usb_submit_urb(urb, GFP_ATOMIC);
 			if (result)
@@ -1040,18 +1041,18 @@ static void pl2303_read_bulk_callback(struct urb *urb)
 	tty_flag = TTY_NORMAL;
 
 	spin_lock_irqsave(&priv->lock, flags);
-	status = priv->line_status;
+	line_status = priv->line_status;
 	priv->line_status &= ~UART_STATE_TRANSIENT_MASK;
 	spin_unlock_irqrestore(&priv->lock, flags);
 	wake_up_interruptible(&priv->delta_msr_wait);
 
 	/* break takes precedence over parity, */
 	/* which takes precedence over framing errors */
-	if (status & UART_BREAK_ERROR )
+	if (line_status & UART_BREAK_ERROR )
 		tty_flag = TTY_BREAK;
-	else if (status & UART_PARITY_ERROR)
+	else if (line_status & UART_PARITY_ERROR)
 		tty_flag = TTY_PARITY;
-	else if (status & UART_FRAME_ERROR)
+	else if (line_status & UART_FRAME_ERROR)
 		tty_flag = TTY_FRAME;
 	dbg("%s - tty_flag = %d", __FUNCTION__, tty_flag);
 
@@ -1059,7 +1060,7 @@ static void pl2303_read_bulk_callback(struct urb *urb)
 	if (tty && urb->actual_length) {
 		tty_buffer_request_room(tty, urb->actual_length + 1);
 		/* overrun is special, not associated with a char */
-		if (status & UART_OVERRUN_ERROR)
+		if (line_status & UART_OVERRUN_ERROR)
 			tty_insert_flip_char(tty, 0, TTY_OVERRUN);
 		for (i = 0; i < urb->actual_length; ++i)
 			tty_insert_flip_char(tty, data[i], tty_flag);
@@ -1083,10 +1084,11 @@ static void pl2303_write_bulk_callback(struct urb *urb)
 	struct usb_serial_port *port = (struct usb_serial_port *) urb->context;
 	struct pl2303_private *priv = usb_get_serial_port_data(port);
 	int result;
+	int status = urb->status;
 
 	dbg("%s - port %d", __FUNCTION__, port->number);
 
-	switch (urb->status) {
+	switch (status) {
 	case 0:
 		/* success */
 		break;
@@ -1095,14 +1097,14 @@ static void pl2303_write_bulk_callback(struct urb *urb)
 	case -ESHUTDOWN:
 		/* this urb is terminated, clean up */
 		dbg("%s - urb shutting down with status: %d", __FUNCTION__,
-		    urb->status);
+		    status);
 		priv->write_urb_in_use = 0;
 		return;
 	default:
 		/* error in the urb, so we have to resubmit it */
 		dbg("%s - Overflow in write", __FUNCTION__);
 		dbg("%s - nonzero write bulk status received: %d", __FUNCTION__,
-		    urb->status);
+		    status);
 		port->write_urb->transfer_buffer_length = 1;
 		port->write_urb->dev = port->serial->dev;
 		result = usb_submit_urb(port->write_urb, GFP_ATOMIC);

commit 4d0dce3e0b794942407391c52f8dd2760802f391
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Jun 12 11:43:37 2007 -0700

    USB: fix up license wording on some of my usb-serial drivers
    
    Also update the copyright date on the pl2303 driver, as it was out of date.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 5027ae9afaab..3022d65bb697 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -1,14 +1,14 @@
 /*
  * Prolific PL2303 USB to serial adaptor driver
  *
- * Copyright (C) 2001-2004 Greg Kroah-Hartman (greg@kroah.com)
+ * Copyright (C) 2001-2007 Greg Kroah-Hartman (greg@kroah.com)
  * Copyright (C) 2003 IBM Corp.
  *
  * Original driver for 2.2.x by anonymous
  *
- *	This program is free software; you can redistribute it and/or modify
- *	it under the terms of the GNU General Public License as published by
- *	the Free Software Foundation; either version 2 of the License.
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License version
+ *	2 as published by the Free Software Foundation.
  *
  * See Documentation/usb/usb-serial.txt for more information on using this driver
  *

commit 715f9527c1c1edd1a9c7a55ab4535211279c9374
Author: t.sefzick <t.sefzick@fz-juelich.de>
Date:   Wed Apr 25 15:05:22 2007 +0200

    USB: flow control fix for pl2303
    
    in order to be able to switch back to 'flow-control none'
    after having activated 'flow-control rts/cts', I made
    a small change to 'pl2303.c'.
    
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 83dfae93a45d..5027ae9afaab 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -617,6 +617,13 @@ static void pl2303_set_termios(struct usb_serial_port *port,
 				    VENDOR_WRITE_REQUEST_TYPE,
 				    0x0, index, NULL, 0, 100);
 		dbg("0x40:0x1:0x0:0x%x  %d", index, i);
+	} else {
+		i = usb_control_msg(serial->dev,
+				    usb_sndctrlpipe(serial->dev, 0),
+				    VENDOR_WRITE_REQUEST,
+				    VENDOR_WRITE_REQUEST_TYPE,
+				    0x0, 0x0, NULL, 0, 100);
+		dbg ("0x40:0x1:0x0:0x0  %d", i);
 	}
 
 	kfree(buf);

commit 2d94b981c7fcb0fba4aa3442cd180066dbedbbc8
Author: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
Date:   Fri Jan 26 22:51:38 2007 +0900

    USB: PL2303: Willcom WS002IN Support.
    
    Signed-off-by: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 6c083d4e2c9b..83dfae93a45d 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -83,6 +83,7 @@ static struct usb_device_id id_table [] = {
 	{ USB_DEVICE(BELKIN_VENDOR_ID, BELKIN_PRODUCT_ID) },
 	{ USB_DEVICE(ALCOR_VENDOR_ID, ALCOR_PRODUCT_ID) },
 	{ USB_DEVICE(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_ID) },
+	{ USB_DEVICE(WS002IN_VENDOR_ID, WS002IN_PRODUCT_ID) },
 	{ }					/* Terminating entry */
 };
 

commit d9b1b787736852f462dbf277b3ca708cbbf693ae
Author: Johannes Hölzl <johannes.hoelzl@gmx.de>
Date:   Sun Dec 17 21:50:24 2006 +0100

    USB serial: add driver pointer to all usb-serial drivers
    
    Every usb serial driver should have a pointer to the corresponding usb driver.
    So the usb serial core can add a new id not only to the usb serial driver, but
    also to the usb driver.
    
    Also the usb drivers of ark3116, mos7720 and mos7840 missed the flag
    no_dynamic_id=1. This is added now.
    
    Signed-off-by: Johannes Hölzl <johannes.hoelzl@gmx.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 5dc2ac9afa90..6c083d4e2c9b 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -1118,6 +1118,7 @@ static struct usb_serial_driver pl2303_device = {
 		.name =		"pl2303",
 	},
 	.id_table =		id_table,
+	.usb_driver = 		&pl2303_driver,
 	.num_interrupt_in =	NUM_DONT_CARE,
 	.num_bulk_in =		1,
 	.num_bulk_out =		1,

commit 5cbded585d129d0226cb48ac4202b253c781be26
Author: Robert P. J. Day <rpjday@mindspring.com>
Date:   Wed Dec 13 00:35:56 2006 -0800

    [PATCH] getting rid of all casts of k[cmz]alloc() calls
    
    Run this:
    
            #!/bin/sh
            for f in $(grep -Erl "\([^\)]*\) *k[cmz]alloc" *) ; do
              echo "De-casting $f..."
              perl -pi -e "s/ ?= ?\([^\)]*\) *(k[cmz]alloc) *\(/ = \1\(/" $f
            done
    
    And then go through and reinstate those cases where code is casting pointers
    to non-pointers.
    
    And then drop a few hunks which conflicted with outstanding work.
    
    Cc: Russell King <rmk@arm.linux.org.uk>, Ian Molton <spyro@f2s.com>
    Cc: Mikael Starvik <starvik@axis.com>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Kyle McMartin <kyle@mcmartin.ca>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Jeff Dike <jdike@addtoit.com>
    Cc: Greg KH <greg@kroah.com>
    Cc: Jens Axboe <jens.axboe@oracle.com>
    Cc: Paul Fulghum <paulkf@microgate.com>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Cc: Karsten Keil <kkeil@suse.de>
    Cc: Mauro Carvalho Chehab <mchehab@infradead.org>
    Cc: Jeff Garzik <jeff@garzik.org>
    Cc: James Bottomley <James.Bottomley@steeleye.com>
    Cc: Ian Kent <raven@themaw.net>
    Cc: Steven French <sfrench@us.ibm.com>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: Neil Brown <neilb@cse.unsw.edu.au>
    Cc: Jaroslav Kysela <perex@suse.cz>
    Cc: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index d124d780e42e..5dc2ac9afa90 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -159,7 +159,7 @@ static struct pl2303_buf *pl2303_buf_alloc(unsigned int size)
 	if (size == 0)
 		return NULL;
 
-	pb = (struct pl2303_buf *)kmalloc(sizeof(struct pl2303_buf), GFP_KERNEL);
+	pb = kmalloc(sizeof(struct pl2303_buf), GFP_KERNEL);
 	if (pb == NULL)
 		return NULL;
 

commit 606d099cdd1080bbb50ea50dc52d98252f8f10a1
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Fri Dec 8 02:38:45 2006 -0800

    [PATCH] tty: switch to ktermios
    
    This is the grungy swap all the occurrences in the right places patch that
    goes with the updates.  At this point we have the same functionality as
    before (except that sgttyb() returns speeds not zero) and are ready to
    begin turning new stuff on providing nobody reports lots of bugs
    
    If you are a tty driver author converting an out of tree driver the only
    impact should be termios->ktermios name changes for the speed/property
    setting functions from your upper layers.
    
    If you are implementing your own TCGETS function before then your driver
    was broken already and its about to get a whole lot more painful for you so
    please fix it 8)
    
    Also fill in c_ispeed/ospeed on init for most devices, although the current
    code will do this for you anyway but I'd like eventually to lose that extra
    paranoia
    
    [akpm@osdl.org: bluetooth fix]
    [mp3@de.ibm.com: sclp fix]
    [mp3@de.ibm.com: warning fix for tty3270]
    [hugh@veritas.com: fix tty_ioctl powerpc build]
    [jdike@addtoit.com: uml: fix ->set_termios declaration]
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Martin Peschke <mp3@de.ibm.com>
    Acked-by: Peter Oberparleiter <oberpar@de.ibm.com>
    Cc: Cornelia Huck <cornelia.huck@de.ibm.com>
    Signed-off-by: Hugh Dickins <hugh@veritas.com>
    Signed-off-by: Jeff Dike <jdike@addtoit.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index bc800c8787a8..d124d780e42e 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -455,7 +455,7 @@ static int pl2303_chars_in_buffer(struct usb_serial_port *port)
 }
 
 static void pl2303_set_termios(struct usb_serial_port *port,
-			       struct termios *old_termios)
+			       struct ktermios *old_termios)
 {
 	struct usb_serial *serial = port->serial;
 	struct pl2303_private *priv = usb_get_serial_port_data(port);
@@ -687,7 +687,7 @@ static void pl2303_close(struct usb_serial_port *port, struct file *filp)
 
 static int pl2303_open(struct usb_serial_port *port, struct file *filp)
 {
-	struct termios tmp_termios;
+	struct ktermios tmp_termios;
 	struct usb_serial *serial = port->serial;
 	struct pl2303_private *priv = usb_get_serial_port_data(port);
 	unsigned char *buf;

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 9c18173e33fb..bc800c8787a8 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -948,7 +948,7 @@ static void pl2303_update_line_status(struct usb_serial_port *port,
 	wake_up_interruptible(&priv->delta_msr_wait);
 }
 
-static void pl2303_read_int_callback(struct urb *urb, struct pt_regs *regs)
+static void pl2303_read_int_callback(struct urb *urb)
 {
 	struct usb_serial_port *port = (struct usb_serial_port *) urb->context;
 	unsigned char *data = urb->transfer_buffer;
@@ -987,7 +987,7 @@ static void pl2303_read_int_callback(struct urb *urb, struct pt_regs *regs)
 			__FUNCTION__, status);
 }
 
-static void pl2303_read_bulk_callback(struct urb *urb, struct pt_regs *regs)
+static void pl2303_read_bulk_callback(struct urb *urb)
 {
 	struct usb_serial_port *port = (struct usb_serial_port *) urb->context;
 	struct pl2303_private *priv = usb_get_serial_port_data(port);
@@ -1070,7 +1070,7 @@ static void pl2303_read_bulk_callback(struct urb *urb, struct pt_regs *regs)
 	return;
 }
 
-static void pl2303_write_bulk_callback(struct urb *urb, struct pt_regs *regs)
+static void pl2303_write_bulk_callback(struct urb *urb)
 {
 	struct usb_serial_port *port = (struct usb_serial_port *) urb->context;
 	struct pl2303_private *priv = usb_get_serial_port_data(port);

commit b697f70f763fe92d5fd05e7e2043bd2b5f12b073
Author: Wesley PA4WDH <pa4wdh@gmail.com>
Date:   Thu Sep 28 20:45:38 2006 +0200

    USB: Add vendor / product ID to pl2303
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 1036d436ed23..9c18173e33fb 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -82,6 +82,7 @@ static struct usb_device_id id_table [] = {
 	{ USB_DEVICE(DATAPILOT_U2_VENDOR_ID, DATAPILOT_U2_PRODUCT_ID) },
 	{ USB_DEVICE(BELKIN_VENDOR_ID, BELKIN_PRODUCT_ID) },
 	{ USB_DEVICE(ALCOR_VENDOR_ID, ALCOR_PRODUCT_ID) },
+	{ USB_DEVICE(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_ID) },
 	{ }					/* Terminating entry */
 };
 

commit 8fd801339350b63cbb90730ff8b2be349fb3dc67
Author: Johannes Steingraeber <Jo_Stein@web.de>
Date:   Sat Sep 16 16:17:34 2006 +0200

    usb serial: support Alcor Micro Corp. USB 2.0 TO RS-232 through pl2303 driver
    
    Patch to add support for Alcor Micro Corp. USB 2.0 TO RS-232 converter.
    This patch adds VID and PID to pl2303.[ch], adds it to the "HORRIBLE
    HACK FOR PL2303" in usb-serial.c and also prevents cdc-acm to claim
    driving this device by blacklisting it in hid-core.
    
    Signed-off-by: Johannes Steingraeber <Jo_Stein@web.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 51caf8a61463..1036d436ed23 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -81,6 +81,7 @@ static struct usb_device_id id_table [] = {
 	{ USB_DEVICE(SPEEDDRAGON_VENDOR_ID, SPEEDDRAGON_PRODUCT_ID) },
 	{ USB_DEVICE(DATAPILOT_U2_VENDOR_ID, DATAPILOT_U2_PRODUCT_ID) },
 	{ USB_DEVICE(BELKIN_VENDOR_ID, BELKIN_PRODUCT_ID) },
+	{ USB_DEVICE(ALCOR_VENDOR_ID, ALCOR_PRODUCT_ID) },
 	{ }					/* Terminating entry */
 };
 

commit 9c53761681497d598a31ed2f6b29b5b3480c49db
Author: Thiago Galesi <thiagogalesi@gmail.com>
Date:   Sat Jul 29 10:47:12 2006 -0300

    USB: pl2303: cosmetic changes to quirk
    
    Cosmetic changes to quirk in pl2303_update_line_status
    
    Signed-off-by: Thiago Galesi <thiagogalesi@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index e2d8f9b94eed..51caf8a61463 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -920,13 +920,20 @@ static void pl2303_update_line_status(struct usb_serial_port *port,
 	unsigned long flags;
 	u8 status_idx = UART_STATE;
 	u8 length = UART_STATE + 1;
+	u16 idv, idp;
 
-	if ((le16_to_cpu(port->serial->dev->descriptor.idVendor) == SIEMENS_VENDOR_ID) &&
-	    (le16_to_cpu(port->serial->dev->descriptor.idProduct) == SIEMENS_PRODUCT_ID_X65 ||
-	     le16_to_cpu(port->serial->dev->descriptor.idProduct) == SIEMENS_PRODUCT_ID_SX1 ||
-	     le16_to_cpu(port->serial->dev->descriptor.idProduct) == SIEMENS_PRODUCT_ID_X75)) {
-		length = 1;
-		status_idx = 0;
+	idv = le16_to_cpu(port->serial->dev->descriptor.idVendor);
+	idp = le16_to_cpu(port->serial->dev->descriptor.idProduct);
+
+
+	if (idv == SIEMENS_VENDOR_ID) {
+		if (idp == SIEMENS_PRODUCT_ID_X65 ||
+		    idp == SIEMENS_PRODUCT_ID_SX1 ||
+		    idp == SIEMENS_PRODUCT_ID_X75) {
+
+			length = 1;
+			status_idx = 0;
+		}
 	}
 
 	if (actual_length < length)

commit 572d3138eb0cf17a2bf36944cc1d2c753578862e
Author: Thiago Galesi <thiagogalesi@gmail.com>
Date:   Sat Jul 29 10:46:37 2006 -0300

    USB: pl2303: reduce number of prototypes
    
    Reduce number of needed prototypes in Prolific pl2303 driver
    
    Signed-off-by: Thiago Galesi <thiagogalesi@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 0cd42bf4c6c8..e2d8f9b94eed 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -127,65 +127,6 @@ static struct usb_driver pl2303_driver = {
 #define UART_OVERRUN_ERROR		0x40
 #define UART_CTS			0x80
 
-/* function prototypes for a PL2303 serial converter */
-static int pl2303_open (struct usb_serial_port *port, struct file *filp);
-static void pl2303_close (struct usb_serial_port *port, struct file *filp);
-static void pl2303_set_termios (struct usb_serial_port *port,
-				struct termios *old);
-static int pl2303_ioctl (struct usb_serial_port *port, struct file *file,
-			 unsigned int cmd, unsigned long arg);
-static void pl2303_read_int_callback (struct urb *urb, struct pt_regs *regs);
-static void pl2303_read_bulk_callback (struct urb *urb, struct pt_regs *regs);
-static void pl2303_write_bulk_callback (struct urb *urb, struct pt_regs *regs);
-static int pl2303_write (struct usb_serial_port *port,
-			 const unsigned char *buf, int count);
-static void pl2303_send (struct usb_serial_port *port);
-static int pl2303_write_room(struct usb_serial_port *port);
-static int pl2303_chars_in_buffer(struct usb_serial_port *port);
-static void pl2303_break_ctl(struct usb_serial_port *port,int break_state);
-static int pl2303_tiocmget (struct usb_serial_port *port, struct file *file);
-static int pl2303_tiocmset (struct usb_serial_port *port, struct file *file,
-			    unsigned int set, unsigned int clear);
-static int pl2303_startup (struct usb_serial *serial);
-static void pl2303_shutdown (struct usb_serial *serial);
-static struct pl2303_buf *pl2303_buf_alloc(unsigned int size);
-static void pl2303_buf_free(struct pl2303_buf *pb);
-static void pl2303_buf_clear(struct pl2303_buf *pb);
-static unsigned int pl2303_buf_data_avail(struct pl2303_buf *pb);
-static unsigned int pl2303_buf_space_avail(struct pl2303_buf *pb);
-static unsigned int pl2303_buf_put(struct pl2303_buf *pb, const char *buf,
-	unsigned int count);
-static unsigned int pl2303_buf_get(struct pl2303_buf *pb, char *buf,
-	unsigned int count);
-
-
-/* All of the device info needed for the PL2303 SIO serial converter */
-static struct usb_serial_driver pl2303_device = {
-	.driver = {
-		.owner =	THIS_MODULE,
-		.name =		"pl2303",
-	},
-	.id_table =		id_table,
-	.num_interrupt_in =	NUM_DONT_CARE,
-	.num_bulk_in =		1,
-	.num_bulk_out =		1,
-	.num_ports =		1,
-	.open =			pl2303_open,
-	.close =		pl2303_close,
-	.write =		pl2303_write,
-	.ioctl =		pl2303_ioctl,
-	.break_ctl =		pl2303_break_ctl,
-	.set_termios =		pl2303_set_termios,
-	.tiocmget =		pl2303_tiocmget,
-	.tiocmset =		pl2303_tiocmset,
-	.read_bulk_callback =	pl2303_read_bulk_callback,
-	.read_int_callback =	pl2303_read_int_callback,
-	.write_bulk_callback =	pl2303_write_bulk_callback,
-	.write_room =		pl2303_write_room,
-	.chars_in_buffer =	pl2303_chars_in_buffer,
-	.attach =		pl2303_startup,
-	.shutdown =		pl2303_shutdown,
-};
 
 enum pl2303_type {
 	type_0,		/* don't know the difference between type 0 and */
@@ -204,6 +145,164 @@ struct pl2303_private {
 	enum pl2303_type type;
 };
 
+/*
+ * pl2303_buf_alloc
+ *
+ * Allocate a circular buffer and all associated memory.
+ */
+static struct pl2303_buf *pl2303_buf_alloc(unsigned int size)
+{
+	struct pl2303_buf *pb;
+
+	if (size == 0)
+		return NULL;
+
+	pb = (struct pl2303_buf *)kmalloc(sizeof(struct pl2303_buf), GFP_KERNEL);
+	if (pb == NULL)
+		return NULL;
+
+	pb->buf_buf = kmalloc(size, GFP_KERNEL);
+	if (pb->buf_buf == NULL) {
+		kfree(pb);
+		return NULL;
+	}
+
+	pb->buf_size = size;
+	pb->buf_get = pb->buf_put = pb->buf_buf;
+
+	return pb;
+}
+
+/*
+ * pl2303_buf_free
+ *
+ * Free the buffer and all associated memory.
+ */
+static void pl2303_buf_free(struct pl2303_buf *pb)
+{
+	if (pb) {
+		kfree(pb->buf_buf);
+		kfree(pb);
+	}
+}
+
+/*
+ * pl2303_buf_clear
+ *
+ * Clear out all data in the circular buffer.
+ */
+static void pl2303_buf_clear(struct pl2303_buf *pb)
+{
+	if (pb != NULL)
+		pb->buf_get = pb->buf_put;
+		/* equivalent to a get of all data available */
+}
+
+/*
+ * pl2303_buf_data_avail
+ *
+ * Return the number of bytes of data available in the circular
+ * buffer.
+ */
+static unsigned int pl2303_buf_data_avail(struct pl2303_buf *pb)
+{
+	if (pb == NULL)
+		return 0;
+
+	return ((pb->buf_size + pb->buf_put - pb->buf_get) % pb->buf_size);
+}
+
+/*
+ * pl2303_buf_space_avail
+ *
+ * Return the number of bytes of space available in the circular
+ * buffer.
+ */
+static unsigned int pl2303_buf_space_avail(struct pl2303_buf *pb)
+{
+	if (pb == NULL)
+		return 0;
+
+	return ((pb->buf_size + pb->buf_get - pb->buf_put - 1) % pb->buf_size);
+}
+
+/*
+ * pl2303_buf_put
+ *
+ * Copy data data from a user buffer and put it into the circular buffer.
+ * Restrict to the amount of space available.
+ *
+ * Return the number of bytes copied.
+ */
+static unsigned int pl2303_buf_put(struct pl2303_buf *pb, const char *buf,
+				   unsigned int count)
+{
+	unsigned int len;
+
+	if (pb == NULL)
+		return 0;
+
+	len  = pl2303_buf_space_avail(pb);
+	if (count > len)
+		count = len;
+
+	if (count == 0)
+		return 0;
+
+	len = pb->buf_buf + pb->buf_size - pb->buf_put;
+	if (count > len) {
+		memcpy(pb->buf_put, buf, len);
+		memcpy(pb->buf_buf, buf+len, count - len);
+		pb->buf_put = pb->buf_buf + count - len;
+	} else {
+		memcpy(pb->buf_put, buf, count);
+		if (count < len)
+			pb->buf_put += count;
+		else /* count == len */
+			pb->buf_put = pb->buf_buf;
+	}
+
+	return count;
+}
+
+/*
+ * pl2303_buf_get
+ *
+ * Get data from the circular buffer and copy to the given buffer.
+ * Restrict to the amount of data available.
+ *
+ * Return the number of bytes copied.
+ */
+static unsigned int pl2303_buf_get(struct pl2303_buf *pb, char *buf,
+				   unsigned int count)
+{
+	unsigned int len;
+
+	if (pb == NULL)
+		return 0;
+
+	len = pl2303_buf_data_avail(pb);
+	if (count > len)
+		count = len;
+
+	if (count == 0)
+		return 0;
+
+	len = pb->buf_buf + pb->buf_size - pb->buf_get;
+	if (count > len) {
+		memcpy(buf, pb->buf_get, len);
+		memcpy(buf+len, pb->buf_buf, count - len);
+		pb->buf_get = pb->buf_buf + count - len;
+	} else {
+		memcpy(buf, pb->buf_get, count);
+		if (count < len)
+			pb->buf_get += count;
+		else /* count == len */
+			pb->buf_get = pb->buf_buf;
+	}
+
+	return count;
+}
 
 static int pl2303_startup(struct usb_serial *serial)
 {
@@ -258,26 +357,6 @@ static int set_control_lines(struct usb_device *dev, u8 value)
 	return retval;
 }
 
-static int pl2303_write(struct usb_serial_port *port, const unsigned char *buf,
-			int count)
-{
-	struct pl2303_private *priv = usb_get_serial_port_data(port);
-	unsigned long flags;
-
-	dbg("%s - port %d, %d bytes", __FUNCTION__, port->number, count);
-
-	if (!count)
-		return count;
-
-	spin_lock_irqsave(&priv->lock, flags);
-	count = pl2303_buf_put(priv->buf, buf, count);
-	spin_unlock_irqrestore(&priv->lock, flags);
-
-	pl2303_send(port);
-
-	return count;
-}
-
 static void pl2303_send(struct usb_serial_port *port)
 {
 	int count, result;
@@ -321,6 +400,26 @@ static void pl2303_send(struct usb_serial_port *port)
 	usb_serial_port_softint(port);
 }
 
+static int pl2303_write(struct usb_serial_port *port, const unsigned char *buf,
+			int count)
+{
+	struct pl2303_private *priv = usb_get_serial_port_data(port);
+	unsigned long flags;
+
+	dbg("%s - port %d, %d bytes", __FUNCTION__, port->number, count);
+
+	if (!count)
+		return count;
+
+	spin_lock_irqsave(&priv->lock, flags);
+	count = pl2303_buf_put(priv->buf, buf, count);
+	spin_unlock_irqrestore(&priv->lock, flags);
+
+	pl2303_send(port);
+
+	return count;
+}
+
 static int pl2303_write_room(struct usb_serial_port *port)
 {
 	struct pl2303_private *priv = usb_get_serial_port_data(port);
@@ -516,8 +615,72 @@ static void pl2303_set_termios(struct usb_serial_port *port,
 				    0x0, index, NULL, 0, 100);
 		dbg("0x40:0x1:0x0:0x%x  %d", index, i);
 	}
-
-	kfree(buf);
+
+	kfree(buf);
+}
+
+static void pl2303_close(struct usb_serial_port *port, struct file *filp)
+{
+	struct pl2303_private *priv = usb_get_serial_port_data(port);
+	unsigned long flags;
+	unsigned int c_cflag;
+	int bps;
+	long timeout;
+	wait_queue_t wait;
+
+	dbg("%s - port %d", __FUNCTION__, port->number);
+
+	/* wait for data to drain from the buffer */
+	spin_lock_irqsave(&priv->lock, flags);
+	timeout = PL2303_CLOSING_WAIT;
+	init_waitqueue_entry(&wait, current);
+	add_wait_queue(&port->tty->write_wait, &wait);
+	for (;;) {
+		set_current_state(TASK_INTERRUPTIBLE);
+		if (pl2303_buf_data_avail(priv->buf) == 0 ||
+		    timeout == 0 || signal_pending(current) ||
+		    !usb_get_intfdata(port->serial->interface))	/* disconnect */
+			break;
+		spin_unlock_irqrestore(&priv->lock, flags);
+		timeout = schedule_timeout(timeout);
+		spin_lock_irqsave(&priv->lock, flags);
+	}
+	set_current_state(TASK_RUNNING);
+	remove_wait_queue(&port->tty->write_wait, &wait);
+	/* clear out any remaining data in the buffer */
+	pl2303_buf_clear(priv->buf);
+	spin_unlock_irqrestore(&priv->lock, flags);
+
+	/* wait for characters to drain from the device */
+	/* (this is long enough for the entire 256 byte */
+	/* pl2303 hardware buffer to drain with no flow */
+	/* control for data rates of 1200 bps or more, */
+	/* for lower rates we should really know how much */
+	/* data is in the buffer to compute a delay */
+	/* that is not unnecessarily long) */
+	bps = tty_get_baud_rate(port->tty);
+	if (bps > 1200)
+		timeout = max((HZ*2560)/bps,HZ/10);
+	else
+		timeout = 2*HZ;
+	schedule_timeout_interruptible(timeout);
+
+	/* shutdown our urbs */
+	dbg("%s - shutting down urbs", __FUNCTION__);
+	usb_kill_urb(port->write_urb);
+	usb_kill_urb(port->read_urb);
+	usb_kill_urb(port->interrupt_in_urb);
+
+	if (port->tty) {
+		c_cflag = port->tty->termios->c_cflag;
+		if (c_cflag & HUPCL) {
+			/* drop DTR and RTS */
+			spin_lock_irqsave(&priv->lock, flags);
+			priv->line_control = 0;
+			spin_unlock_irqrestore(&priv->lock, flags);
+			set_control_lines(port->serial->dev, 0);
+		}
+	}
 }
 
 static int pl2303_open(struct usb_serial_port *port, struct file *filp)
@@ -601,70 +764,6 @@ static int pl2303_open(struct usb_serial_port *port, struct file *filp)
 	return 0;
 }
 
-static void pl2303_close(struct usb_serial_port *port, struct file *filp)
-{
-	struct pl2303_private *priv = usb_get_serial_port_data(port);
-	unsigned long flags;
-	unsigned int c_cflag;
-	int bps;
-	long timeout;
-	wait_queue_t wait;
-
-	dbg("%s - port %d", __FUNCTION__, port->number);
-
-	/* wait for data to drain from the buffer */
-	spin_lock_irqsave(&priv->lock, flags);
-	timeout = PL2303_CLOSING_WAIT;
-	init_waitqueue_entry(&wait, current);
-	add_wait_queue(&port->tty->write_wait, &wait);
-	for (;;) {
-		set_current_state(TASK_INTERRUPTIBLE);
-		if (pl2303_buf_data_avail(priv->buf) == 0 ||
-		    timeout == 0 || signal_pending(current) ||
-		    !usb_get_intfdata(port->serial->interface))	/* disconnect */
-			break;
-		spin_unlock_irqrestore(&priv->lock, flags);
-		timeout = schedule_timeout(timeout);
-		spin_lock_irqsave(&priv->lock, flags);
-	}
-	set_current_state(TASK_RUNNING);
-	remove_wait_queue(&port->tty->write_wait, &wait);
-	/* clear out any remaining data in the buffer */
-	pl2303_buf_clear(priv->buf);
-	spin_unlock_irqrestore(&priv->lock, flags);
-
-	/* wait for characters to drain from the device */
-	/* (this is long enough for the entire 256 byte */
-	/* pl2303 hardware buffer to drain with no flow */
-	/* control for data rates of 1200 bps or more, */
-	/* for lower rates we should really know how much */
-	/* data is in the buffer to compute a delay */
-	/* that is not unnecessarily long) */
-	bps = tty_get_baud_rate(port->tty);
-	if (bps > 1200)
-		timeout = max((HZ*2560)/bps,HZ/10);
-	else
-		timeout = 2*HZ;
-	schedule_timeout_interruptible(timeout);
-
-	/* shutdown our urbs */
-	dbg("%s - shutting down urbs", __FUNCTION__);
-	usb_kill_urb(port->write_urb);
-	usb_kill_urb(port->read_urb);
-	usb_kill_urb(port->interrupt_in_urb);
-
-	if (port->tty) {
-		c_cflag = port->tty->termios->c_cflag;
-		if (c_cflag & HUPCL) {
-			/* drop DTR and RTS */
-			spin_lock_irqsave(&priv->lock, flags);
-			priv->line_control = 0;
-			spin_unlock_irqrestore(&priv->lock, flags);
-			set_control_lines(port->serial->dev, 0);
-		}
-	}
-}
-
 static int pl2303_tiocmset(struct usb_serial_port *port, struct file *file,
 			   unsigned int set, unsigned int clear)
 {
@@ -1003,164 +1102,33 @@ static void pl2303_write_bulk_callback(struct urb *urb, struct pt_regs *regs)
 	pl2303_send(port);
 }
 
-/*
- * pl2303_buf_alloc
- *
- * Allocate a circular buffer and all associated memory.
- */
-static struct pl2303_buf *pl2303_buf_alloc(unsigned int size)
-{
-	struct pl2303_buf *pb;
-
-	if (size == 0)
-		return NULL;
-
-	pb = (struct pl2303_buf *)kmalloc(sizeof(struct pl2303_buf), GFP_KERNEL);
-	if (pb == NULL)
-		return NULL;
-
-	pb->buf_buf = kmalloc(size, GFP_KERNEL);
-	if (pb->buf_buf == NULL) {
-		kfree(pb);
-		return NULL;
-	}
-
-	pb->buf_size = size;
-	pb->buf_get = pb->buf_put = pb->buf_buf;
-
-	return pb;
-}
-
-/*
- * pl2303_buf_free
- *
- * Free the buffer and all associated memory.
- */
-static void pl2303_buf_free(struct pl2303_buf *pb)
-{
-	if (pb) {
-		kfree(pb->buf_buf);
-		kfree(pb);
-	}
-}
-
-/*
- * pl2303_buf_clear
- *
- * Clear out all data in the circular buffer.
- */
-static void pl2303_buf_clear(struct pl2303_buf *pb)
-{
-	if (pb != NULL)
-		pb->buf_get = pb->buf_put;
-		/* equivalent to a get of all data available */
-}
-
-/*
- * pl2303_buf_data_avail
- *
- * Return the number of bytes of data available in the circular
- * buffer.
- */
-static unsigned int pl2303_buf_data_avail(struct pl2303_buf *pb)
-{
-	if (pb == NULL)
-		return 0;
-
-	return ((pb->buf_size + pb->buf_put - pb->buf_get) % pb->buf_size);
-}
-
-/*
- * pl2303_buf_space_avail
- *
- * Return the number of bytes of space available in the circular
- * buffer.
- */
-static unsigned int pl2303_buf_space_avail(struct pl2303_buf *pb)
-{
-	if (pb == NULL)
-		return 0;
-
-	return ((pb->buf_size + pb->buf_get - pb->buf_put - 1) % pb->buf_size);
-}
-
-/*
- * pl2303_buf_put
- *
- * Copy data data from a user buffer and put it into the circular buffer.
- * Restrict to the amount of space available.
- *
- * Return the number of bytes copied.
- */
-static unsigned int pl2303_buf_put(struct pl2303_buf *pb, const char *buf,
-				   unsigned int count)
-{
-	unsigned int len;
-
-	if (pb == NULL)
-		return 0;
-
-	len  = pl2303_buf_space_avail(pb);
-	if (count > len)
-		count = len;
-
-	if (count == 0)
-		return 0;
-
-	len = pb->buf_buf + pb->buf_size - pb->buf_put;
-	if (count > len) {
-		memcpy(pb->buf_put, buf, len);
-		memcpy(pb->buf_buf, buf+len, count - len);
-		pb->buf_put = pb->buf_buf + count - len;
-	} else {
-		memcpy(pb->buf_put, buf, count);
-		if (count < len)
-			pb->buf_put += count;
-		else /* count == len */
-			pb->buf_put = pb->buf_buf;
-	}
-
-	return count;
-}
-
-/*
- * pl2303_buf_get
- *
- * Get data from the circular buffer and copy to the given buffer.
- * Restrict to the amount of data available.
- *
- * Return the number of bytes copied.
- */
-static unsigned int pl2303_buf_get(struct pl2303_buf *pb, char *buf,
-				   unsigned int count)
-{
-	unsigned int len;
-
-	if (pb == NULL)
-		return 0;
-
-	len = pl2303_buf_data_avail(pb);
-	if (count > len)
-		count = len;
-
-	if (count == 0)
-		return 0;
-
-	len = pb->buf_buf + pb->buf_size - pb->buf_get;
-	if (count > len) {
-		memcpy(buf, pb->buf_get, len);
-		memcpy(buf+len, pb->buf_buf, count - len);
-		pb->buf_get = pb->buf_buf + count - len;
-	} else {
-		memcpy(buf, pb->buf_get, count);
-		if (count < len)
-			pb->buf_get += count;
-		else /* count == len */
-			pb->buf_get = pb->buf_buf;
-	}
-
-	return count;
-}
+/* All of the device info needed for the PL2303 SIO serial converter */
+static struct usb_serial_driver pl2303_device = {
+	.driver = {
+		.owner =	THIS_MODULE,
+		.name =		"pl2303",
+	},
+	.id_table =		id_table,
+	.num_interrupt_in =	NUM_DONT_CARE,
+	.num_bulk_in =		1,
+	.num_bulk_out =		1,
+	.num_ports =		1,
+	.open =			pl2303_open,
+	.close =		pl2303_close,
+	.write =		pl2303_write,
+	.ioctl =		pl2303_ioctl,
+	.break_ctl =		pl2303_break_ctl,
+	.set_termios =		pl2303_set_termios,
+	.tiocmget =		pl2303_tiocmget,
+	.tiocmset =		pl2303_tiocmset,
+	.read_bulk_callback =	pl2303_read_bulk_callback,
+	.read_int_callback =	pl2303_read_int_callback,
+	.write_bulk_callback =	pl2303_write_bulk_callback,
+	.write_room =		pl2303_write_room,
+	.chars_in_buffer =	pl2303_chars_in_buffer,
+	.attach =		pl2303_startup,
+	.shutdown =		pl2303_shutdown,
+};
 
 static int __init pl2303_init(void)
 {

commit 10a18cd1a31e34d123d5ae4736a3393432352750
Author: Thiago Galesi <thiagogalesi@gmail.com>
Date:   Sat Jul 29 10:45:43 2006 -0300

    USB: pl2303: cosmetic changes to pl2303_buf_{clear, data_avail}
    
    Changes the functions pl2303_buf_clear and pl2303_buf_data_avail for
    the purpose of keeping them under the 80 column limit, making them
    more similar to similar functions and making then simpler.
    
    Signed-off-by: Thiago Galesi <thiagogalesi@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 90d0e7935665..0cd42bf4c6c8 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -1064,10 +1064,10 @@ static void pl2303_buf_clear(struct pl2303_buf *pb)
  */
 static unsigned int pl2303_buf_data_avail(struct pl2303_buf *pb)
 {
-	if (pb != NULL)
-		return ((pb->buf_size + pb->buf_put - pb->buf_get) % pb->buf_size);
-	else
+	if (pb == NULL)
 		return 0;
+
+	return ((pb->buf_size + pb->buf_put - pb->buf_get) % pb->buf_size);
 }
 
 /*
@@ -1078,10 +1078,10 @@ static unsigned int pl2303_buf_data_avail(struct pl2303_buf *pb)
  */
 static unsigned int pl2303_buf_space_avail(struct pl2303_buf *pb)
 {
-	if (pb != NULL)
-		return ((pb->buf_size + pb->buf_get - pb->buf_put - 1) % pb->buf_size);
-	else
+	if (pb == NULL)
 		return 0;
+
+	return ((pb->buf_size + pb->buf_get - pb->buf_put - 1) % pb->buf_size);
 }
 
 /*

commit 372db8a780f63368c6960a167b7a19aad776d704
Author: Thiago Galesi <thiagogalesi@gmail.com>
Date:   Mon Jul 31 15:39:27 2006 -0300

    USB: pl2303: remove 80-columns limit violations in pl2303 driver
    
    Fixes several lines that overrun 80 columns in Prolific pl2303 driver
    and cleans up some space usages in the function calls.
    
    Signed-off-by: Thiago Galesi <thiagogalesi@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 54c32ccce626..90d0e7935665 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -84,7 +84,7 @@ static struct usb_device_id id_table [] = {
 	{ }					/* Terminating entry */
 };
 
-MODULE_DEVICE_TABLE (usb, id_table);
+MODULE_DEVICE_TABLE(usb, id_table);
 
 static struct usb_driver pl2303_driver = {
 	.name =		"pl2303",
@@ -205,7 +205,7 @@ struct pl2303_private {
 };
 
 
-static int pl2303_startup (struct usb_serial *serial)
+static int pl2303_startup(struct usb_serial *serial)
 {
 	struct pl2303_private *priv;
 	enum pl2303_type type = type_0;
@@ -247,18 +247,19 @@ static int pl2303_startup (struct usb_serial *serial)
 	return -ENOMEM;
 }
 
-static int set_control_lines (struct usb_device *dev, u8 value)
+static int set_control_lines(struct usb_device *dev, u8 value)
 {
 	int retval;
 	
-	retval = usb_control_msg (dev, usb_sndctrlpipe (dev, 0),
-				  SET_CONTROL_REQUEST, SET_CONTROL_REQUEST_TYPE,
-				  value, 0, NULL, 0, 100);
+	retval = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
+				 SET_CONTROL_REQUEST, SET_CONTROL_REQUEST_TYPE,
+				 value, 0, NULL, 0, 100);
 	dbg("%s - value = %d, retval = %d", __FUNCTION__, value, retval);
 	return retval;
 }
 
-static int pl2303_write (struct usb_serial_port *port,  const unsigned char *buf, int count)
+static int pl2303_write(struct usb_serial_port *port, const unsigned char *buf,
+			int count)
 {
 	struct pl2303_private *priv = usb_get_serial_port_data(port);
 	unsigned long flags;
@@ -293,7 +294,7 @@ static void pl2303_send(struct usb_serial_port *port)
 	}
 
 	count = pl2303_buf_get(priv->buf, port->write_urb->transfer_buffer,
-		port->bulk_out_size);
+			       port->bulk_out_size);
 
 	if (count == 0) {
 		spin_unlock_irqrestore(&priv->lock, flags);
@@ -304,13 +305,15 @@ static void pl2303_send(struct usb_serial_port *port)
 
 	spin_unlock_irqrestore(&priv->lock, flags);
 
-	usb_serial_debug_data(debug, &port->dev, __FUNCTION__, count, port->write_urb->transfer_buffer);
+	usb_serial_debug_data(debug, &port->dev, __FUNCTION__, count,
+			      port->write_urb->transfer_buffer);
 
 	port->write_urb->transfer_buffer_length = count;
 	port->write_urb->dev = port->serial->dev;
-	result = usb_submit_urb (port->write_urb, GFP_ATOMIC);
+	result = usb_submit_urb(port->write_urb, GFP_ATOMIC);
 	if (result) {
-		dev_err(&port->dev, "%s - failed submitting write urb, error %d\n", __FUNCTION__, result);
+		dev_err(&port->dev, "%s - failed submitting write urb,"
+			" error %d\n", __FUNCTION__, result);
 		priv->write_urb_in_use = 0;
 		// TODO: reschedule pl2303_send
 	}
@@ -350,7 +353,8 @@ static int pl2303_chars_in_buffer(struct usb_serial_port *port)
 	return chars;
 }
 
-static void pl2303_set_termios (struct usb_serial_port *port, struct termios *old_termios)
+static void pl2303_set_termios(struct usb_serial_port *port,
+			       struct termios *old_termios)
 {
 	struct usb_serial *serial = port->serial;
 	struct pl2303_private *priv = usb_get_serial_port_data(port);
@@ -371,7 +375,8 @@ static void pl2303_set_termios (struct usb_serial_port *port, struct termios *ol
 	spin_lock_irqsave(&priv->lock, flags);
 	if (!priv->termios_initialized) {
 		*(port->tty->termios) = tty_std_termios;
-		port->tty->termios->c_cflag = B9600 | CS8 | CREAD | HUPCL | CLOCAL;
+		port->tty->termios->c_cflag = B9600 | CS8 | CREAD |
+					      HUPCL | CLOCAL;
 		priv->termios_initialized = 1;
 	}
 	spin_unlock_irqrestore(&priv->lock, flags);
@@ -380,24 +385,24 @@ static void pl2303_set_termios (struct usb_serial_port *port, struct termios *ol
 	/* check that they really want us to change something */
 	if (old_termios) {
 		if ((cflag == old_termios->c_cflag) &&
-		    (RELEVANT_IFLAG(port->tty->termios->c_iflag) == RELEVANT_IFLAG(old_termios->c_iflag))) {
-		    dbg("%s - nothing to change...", __FUNCTION__);
-		    return;
+		    (RELEVANT_IFLAG(port->tty->termios->c_iflag) ==
+		     RELEVANT_IFLAG(old_termios->c_iflag))) {
+			dbg("%s - nothing to change...", __FUNCTION__);
+			return;
 		}
 	}
 
-	buf = kzalloc (7, GFP_KERNEL);
+	buf = kzalloc(7, GFP_KERNEL);
 	if (!buf) {
 		dev_err(&port->dev, "%s - out of memory.\n", __FUNCTION__);
 		return;
 	}
-	
-	i = usb_control_msg (serial->dev, usb_rcvctrlpipe (serial->dev, 0),
-			     GET_LINE_REQUEST, GET_LINE_REQUEST_TYPE,
-			     0, 0, buf, 7, 100);
-	dbg ("0xa1:0x21:0:0  %d - %x %x %x %x %x %x %x", i,
-	     buf[0], buf[1], buf[2], buf[3], buf[4], buf[5], buf[6]);
 
+	i = usb_control_msg(serial->dev, usb_rcvctrlpipe(serial->dev, 0),
+			    GET_LINE_REQUEST, GET_LINE_REQUEST_TYPE,
+			    0, 0, buf, 7, 100);
+	dbg("0xa1:0x21:0:0  %d - %x %x %x %x %x %x %x", i,
+	    buf[0], buf[1], buf[2], buf[3], buf[4], buf[5], buf[6]);
 
 	if (cflag & CSIZE) {
 		switch (cflag & CSIZE) {
@@ -429,7 +434,8 @@ static void pl2303_set_termios (struct usb_serial_port *port, struct termios *ol
 		case B230400:	baud = 230400;	break;
 		case B460800:	baud = 460800;	break;
 		default:
-			dev_err(&port->dev, "pl2303 driver does not support the baudrate requested (fix it)\n");
+			dev_err(&port->dev, "pl2303 driver does not support"
+				" the baudrate requested (fix it)\n");
 			break;
 	}
 	dbg("%s - baud = %d", __FUNCTION__, baud);
@@ -469,10 +475,10 @@ static void pl2303_set_termios (struct usb_serial_port *port, struct termios *ol
 		dbg("%s - parity = none", __FUNCTION__);
 	}
 
-	i = usb_control_msg (serial->dev, usb_sndctrlpipe (serial->dev, 0),
-			     SET_LINE_REQUEST, SET_LINE_REQUEST_TYPE, 
-			     0, 0, buf, 7, 100);
-	dbg ("0x21:0x20:0:0  %d", i);
+	i = usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),
+			    SET_LINE_REQUEST, SET_LINE_REQUEST_TYPE,
+			    0, 0, buf, 7, 100);
+	dbg("0x21:0x20:0:0  %d", i);
 
 	/* change control lines if we are switching to or from B0 */
 	spin_lock_irqsave(&priv->lock, flags);
@@ -488,13 +494,13 @@ static void pl2303_set_termios (struct usb_serial_port *port, struct termios *ol
 	} else {
 		spin_unlock_irqrestore(&priv->lock, flags);
 	}
-	
+
 	buf[0] = buf[1] = buf[2] = buf[3] = buf[4] = buf[5] = buf[6] = 0;
 
-	i = usb_control_msg (serial->dev, usb_rcvctrlpipe (serial->dev, 0),
-			     GET_LINE_REQUEST, GET_LINE_REQUEST_TYPE,
-			     0, 0, buf, 7, 100);
-	dbg ("0xa1:0x21:0:0  %d - %x %x %x %x %x %x %x", i,
+	i = usb_control_msg(serial->dev, usb_rcvctrlpipe(serial->dev, 0),
+			    GET_LINE_REQUEST, GET_LINE_REQUEST_TYPE,
+			    0, 0, buf, 7, 100);
+	dbg("0xa1:0x21:0:0  %d - %x %x %x %x %x %x %x", i,
 	     buf[0], buf[1], buf[2], buf[3], buf[4], buf[5], buf[6]);
 
 	if (cflag & CRTSCTS) {
@@ -503,18 +509,18 @@ static void pl2303_set_termios (struct usb_serial_port *port, struct termios *ol
 			index = 0x61;
 		else
 			index = 0x41;
-		i = usb_control_msg(serial->dev, 
+		i = usb_control_msg(serial->dev,
 				    usb_sndctrlpipe(serial->dev, 0),
 				    VENDOR_WRITE_REQUEST,
 				    VENDOR_WRITE_REQUEST_TYPE,
 				    0x0, index, NULL, 0, 100);
-		dbg ("0x40:0x1:0x0:0x%x  %d", index, i);
+		dbg("0x40:0x1:0x0:0x%x  %d", index, i);
 	}
 
-	kfree (buf);
+	kfree(buf);
 }
 
-static int pl2303_open (struct usb_serial_port *port, struct file *filp)
+static int pl2303_open(struct usb_serial_port *port, struct file *filp)
 {
 	struct termios tmp_termios;
 	struct usb_serial *serial = port->serial;
@@ -568,33 +574,34 @@ static int pl2303_open (struct usb_serial_port *port, struct file *filp)
 
 	/* Setup termios */
 	if (port->tty) {
-		pl2303_set_termios (port, &tmp_termios);
+		pl2303_set_termios(port, &tmp_termios);
 	}
 
 	//FIXME: need to assert RTS and DTR if CRTSCTS off
 
 	dbg("%s - submitting read urb", __FUNCTION__);
 	port->read_urb->dev = serial->dev;
-	result = usb_submit_urb (port->read_urb, GFP_KERNEL);
+	result = usb_submit_urb(port->read_urb, GFP_KERNEL);
 	if (result) {
-		dev_err(&port->dev, "%s - failed submitting read urb, error %d\n", __FUNCTION__, result);
-		pl2303_close (port, NULL);
+		dev_err(&port->dev, "%s - failed submitting read urb,"
+			" error %d\n", __FUNCTION__, result);
+		pl2303_close(port, NULL);
 		return -EPROTO;
 	}
 
 	dbg("%s - submitting interrupt urb", __FUNCTION__);
 	port->interrupt_in_urb->dev = serial->dev;
-	result = usb_submit_urb (port->interrupt_in_urb, GFP_KERNEL);
+	result = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);
 	if (result) {
-		dev_err(&port->dev, "%s - failed submitting interrupt urb, error %d\n", __FUNCTION__, result);
-		pl2303_close (port, NULL);
+		dev_err(&port->dev, "%s - failed submitting interrupt urb,"
+			" error %d\n", __FUNCTION__, result);
+		pl2303_close(port, NULL);
 		return -EPROTO;
 	}
 	return 0;
 }
 
-
-static void pl2303_close (struct usb_serial_port *port, struct file *filp)
+static void pl2303_close(struct usb_serial_port *port, struct file *filp)
 {
 	struct pl2303_private *priv = usb_get_serial_port_data(port);
 	unsigned long flags;
@@ -612,9 +619,9 @@ static void pl2303_close (struct usb_serial_port *port, struct file *filp)
 	add_wait_queue(&port->tty->write_wait, &wait);
 	for (;;) {
 		set_current_state(TASK_INTERRUPTIBLE);
-		if (pl2303_buf_data_avail(priv->buf) == 0
-		|| timeout == 0 || signal_pending(current)
-		|| !usb_get_intfdata(port->serial->interface))	/* disconnect */
+		if (pl2303_buf_data_avail(priv->buf) == 0 ||
+		    timeout == 0 || signal_pending(current) ||
+		    !usb_get_intfdata(port->serial->interface))	/* disconnect */
 			break;
 		spin_unlock_irqrestore(&priv->lock, flags);
 		timeout = schedule_timeout(timeout);
@@ -652,14 +659,14 @@ static void pl2303_close (struct usb_serial_port *port, struct file *filp)
 			/* drop DTR and RTS */
 			spin_lock_irqsave(&priv->lock, flags);
 			priv->line_control = 0;
-			spin_unlock_irqrestore (&priv->lock, flags);
-			set_control_lines (port->serial->dev, 0);
+			spin_unlock_irqrestore(&priv->lock, flags);
+			set_control_lines(port->serial->dev, 0);
 		}
 	}
 }
 
-static int pl2303_tiocmset (struct usb_serial_port *port, struct file *file,
-			    unsigned int set, unsigned int clear)
+static int pl2303_tiocmset(struct usb_serial_port *port, struct file *file,
+			   unsigned int set, unsigned int clear)
 {
 	struct pl2303_private *priv = usb_get_serial_port_data(port);
 	unsigned long flags;
@@ -668,7 +675,7 @@ static int pl2303_tiocmset (struct usb_serial_port *port, struct file *file,
 	if (!usb_get_intfdata(port->serial->interface))
 		return -ENODEV;
 
-	spin_lock_irqsave (&priv->lock, flags);
+	spin_lock_irqsave(&priv->lock, flags);
 	if (set & TIOCM_RTS)
 		priv->line_control |= CONTROL_RTS;
 	if (set & TIOCM_DTR)
@@ -678,12 +685,12 @@ static int pl2303_tiocmset (struct usb_serial_port *port, struct file *file,
 	if (clear & TIOCM_DTR)
 		priv->line_control &= ~CONTROL_DTR;
 	control = priv->line_control;
-	spin_unlock_irqrestore (&priv->lock, flags);
+	spin_unlock_irqrestore(&priv->lock, flags);
 
-	return set_control_lines (port->serial->dev, control);
+	return set_control_lines(port->serial->dev, control);
 }
 
-static int pl2303_tiocmget (struct usb_serial_port *port, struct file *file)
+static int pl2303_tiocmget(struct usb_serial_port *port, struct file *file)
 {
 	struct pl2303_private *priv = usb_get_serial_port_data(port);
 	unsigned long flags;
@@ -696,10 +703,10 @@ static int pl2303_tiocmget (struct usb_serial_port *port, struct file *file)
 	if (!usb_get_intfdata(port->serial->interface))
 		return -ENODEV;
 
-	spin_lock_irqsave (&priv->lock, flags);
+	spin_lock_irqsave(&priv->lock, flags);
 	mcr = priv->line_control;
 	status = priv->line_status;
-	spin_unlock_irqrestore (&priv->lock, flags);
+	spin_unlock_irqrestore(&priv->lock, flags);
 
 	result = ((mcr & CONTROL_DTR)		? TIOCM_DTR : 0)
 		  | ((mcr & CONTROL_RTS)	? TIOCM_RTS : 0)
@@ -721,22 +728,22 @@ static int wait_modem_info(struct usb_serial_port *port, unsigned int arg)
 	unsigned int status;
 	unsigned int changed;
 
-	spin_lock_irqsave (&priv->lock, flags);
+	spin_lock_irqsave(&priv->lock, flags);
 	prevstatus = priv->line_status;
-	spin_unlock_irqrestore (&priv->lock, flags);
+	spin_unlock_irqrestore(&priv->lock, flags);
 
 	while (1) {
 		interruptible_sleep_on(&priv->delta_msr_wait);
 		/* see if a signal did it */
 		if (signal_pending(current))
 			return -ERESTARTSYS;
-		
-		spin_lock_irqsave (&priv->lock, flags);
+
+		spin_lock_irqsave(&priv->lock, flags);
 		status = priv->line_status;
-		spin_unlock_irqrestore (&priv->lock, flags);
-		
+		spin_unlock_irqrestore(&priv->lock, flags);
+
 		changed=prevstatus^status;
-		
+
 		if (((arg & TIOCM_RNG) && (changed & UART_RING)) ||
 		    ((arg & TIOCM_DSR) && (changed & UART_DSR)) ||
 		    ((arg & TIOCM_CD)  && (changed & UART_DCD)) ||
@@ -749,7 +756,8 @@ static int wait_modem_info(struct usb_serial_port *port, unsigned int arg)
 	return 0;
 }
 
-static int pl2303_ioctl (struct usb_serial_port *port, struct file *file, unsigned int cmd, unsigned long arg)
+static int pl2303_ioctl(struct usb_serial_port *port, struct file *file,
+			unsigned int cmd, unsigned long arg)
 {
 	dbg("%s (%d) cmd = 0x%04x", __FUNCTION__, port->number, cmd);
 
@@ -766,7 +774,7 @@ static int pl2303_ioctl (struct usb_serial_port *port, struct file *file, unsign
 	return -ENOIOCTLCMD;
 }
 
-static void pl2303_break_ctl (struct usb_serial_port *port, int break_state)
+static void pl2303_break_ctl(struct usb_serial_port *port, int break_state)
 {
 	struct usb_serial *serial = port->serial;
 	u16 state;
@@ -780,15 +788,14 @@ static void pl2303_break_ctl (struct usb_serial_port *port, int break_state)
 		state = BREAK_ON;
 	dbg("%s - turning break %s", __FUNCTION__, state==BREAK_OFF ? "off" : "on");
 
-	result = usb_control_msg (serial->dev, usb_sndctrlpipe (serial->dev, 0),
-				  BREAK_REQUEST, BREAK_REQUEST_TYPE, state, 
-				  0, NULL, 0, 100);
+	result = usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),
+				 BREAK_REQUEST, BREAK_REQUEST_TYPE, state,
+				 0, NULL, 0, 100);
 	if (result)
 		dbg("%s - error sending break = %d", __FUNCTION__, result);
 }
 
-
-static void pl2303_shutdown (struct usb_serial *serial)
+static void pl2303_shutdown(struct usb_serial *serial)
 {
 	int i;
 	struct pl2303_private *priv;
@@ -802,7 +809,7 @@ static void pl2303_shutdown (struct usb_serial *serial)
 			kfree(priv);
 			usb_set_serial_port_data(serial->port[i], NULL);
 		}
-	}		
+	}
 }
 
 static void pl2303_update_line_status(struct usb_serial_port *port,
@@ -830,10 +837,10 @@ static void pl2303_update_line_status(struct usb_serial_port *port,
 	spin_lock_irqsave(&priv->lock, flags);
 	priv->line_status = data[status_idx];
 	spin_unlock_irqrestore(&priv->lock, flags);
-	wake_up_interruptible (&priv->delta_msr_wait);
+	wake_up_interruptible(&priv->delta_msr_wait);
 }
 
-static void pl2303_read_int_callback (struct urb *urb, struct pt_regs *regs)
+static void pl2303_read_int_callback(struct urb *urb, struct pt_regs *regs)
 {
 	struct usb_serial_port *port = (struct usb_serial_port *) urb->context;
 	unsigned char *data = urb->transfer_buffer;
@@ -850,25 +857,29 @@ static void pl2303_read_int_callback (struct urb *urb, struct pt_regs *regs)
 	case -ENOENT:
 	case -ESHUTDOWN:
 		/* this urb is terminated, clean up */
-		dbg("%s - urb shutting down with status: %d", __FUNCTION__, urb->status);
+		dbg("%s - urb shutting down with status: %d", __FUNCTION__,
+		    urb->status);
 		return;
 	default:
-		dbg("%s - nonzero urb status received: %d", __FUNCTION__, urb->status);
+		dbg("%s - nonzero urb status received: %d", __FUNCTION__,
+		    urb->status);
 		goto exit;
 	}
 
-	usb_serial_debug_data(debug, &port->dev, __FUNCTION__, urb->actual_length, urb->transfer_buffer);
+	usb_serial_debug_data(debug, &port->dev, __FUNCTION__,
+			      urb->actual_length, urb->transfer_buffer);
+
 	pl2303_update_line_status(port, data, actual_length);
 
 exit:
-	status = usb_submit_urb (urb, GFP_ATOMIC);
+	status = usb_submit_urb(urb, GFP_ATOMIC);
 	if (status)
-		dev_err(&urb->dev->dev, "%s - usb_submit_urb failed with result %d\n",
+		dev_err(&urb->dev->dev,
+			"%s - usb_submit_urb failed with result %d\n",
 			__FUNCTION__, status);
 }
 
-
-static void pl2303_read_bulk_callback (struct urb *urb, struct pt_regs *regs)
+static void pl2303_read_bulk_callback(struct urb *urb, struct pt_regs *regs)
 {
 	struct usb_serial_port *port = (struct usb_serial_port *) urb->context;
 	struct pl2303_private *priv = usb_get_serial_port_data(port);
@@ -889,20 +900,25 @@ static void pl2303_read_bulk_callback (struct urb *urb, struct pt_regs *regs)
 			return;
 		}
 		if (urb->status == -EPROTO) {
-			/* PL2303 mysteriously fails with -EPROTO reschedule the read */
-			dbg("%s - caught -EPROTO, resubmitting the urb", __FUNCTION__);
+			/* PL2303 mysteriously fails with -EPROTO reschedule
+			 * the read */
+			dbg("%s - caught -EPROTO, resubmitting the urb",
+			    __FUNCTION__);
 			urb->status = 0;
 			urb->dev = port->serial->dev;
 			result = usb_submit_urb(urb, GFP_ATOMIC);
 			if (result)
-				dev_err(&urb->dev->dev, "%s - failed resubmitting read urb, error %d\n", __FUNCTION__, result);
+				dev_err(&urb->dev->dev, "%s - failed"
+					" resubmitting read urb, error %d\n",
+					__FUNCTION__, result);
 			return;
 		}
 		dbg("%s - unable to handle the error, exiting.", __FUNCTION__);
 		return;
 	}
 
-	usb_serial_debug_data(debug, &port->dev, __FUNCTION__, urb->actual_length, data);
+	usb_serial_debug_data(debug, &port->dev, __FUNCTION__,
+			      urb->actual_length, data);
 
 	/* get tty_flag from status */
 	tty_flag = TTY_NORMAL;
@@ -911,7 +927,7 @@ static void pl2303_read_bulk_callback (struct urb *urb, struct pt_regs *regs)
 	status = priv->line_status;
 	priv->line_status &= ~UART_STATE_TRANSIENT_MASK;
 	spin_unlock_irqrestore(&priv->lock, flags);
-	wake_up_interruptible (&priv->delta_msr_wait);
+	wake_up_interruptible(&priv->delta_msr_wait);
 
 	/* break takes precedence over parity, */
 	/* which takes precedence over framing errors */
@@ -930,8 +946,8 @@ static void pl2303_read_bulk_callback (struct urb *urb, struct pt_regs *regs)
 		if (status & UART_OVERRUN_ERROR)
 			tty_insert_flip_char(tty, 0, TTY_OVERRUN);
 		for (i = 0; i < urb->actual_length; ++i)
-			tty_insert_flip_char (tty, data[i], tty_flag);
-		tty_flip_buffer_push (tty);
+			tty_insert_flip_char(tty, data[i], tty_flag);
+		tty_flip_buffer_push(tty);
 	}
 
 	/* Schedule the next read _if_ we are still open */
@@ -939,15 +955,14 @@ static void pl2303_read_bulk_callback (struct urb *urb, struct pt_regs *regs)
 		urb->dev = port->serial->dev;
 		result = usb_submit_urb(urb, GFP_ATOMIC);
 		if (result)
-			dev_err(&urb->dev->dev, "%s - failed resubmitting read urb, error %d\n", __FUNCTION__, result);
+			dev_err(&urb->dev->dev, "%s - failed resubmitting"
+				" read urb, error %d\n", __FUNCTION__, result);
 	}
 
 	return;
 }
 
-
-
-static void pl2303_write_bulk_callback (struct urb *urb, struct pt_regs *regs)
+static void pl2303_write_bulk_callback(struct urb *urb, struct pt_regs *regs)
 {
 	struct usb_serial_port *port = (struct usb_serial_port *) urb->context;
 	struct pl2303_private *priv = usb_get_serial_port_data(port);
@@ -963,18 +978,21 @@ static void pl2303_write_bulk_callback (struct urb *urb, struct pt_regs *regs)
 	case -ENOENT:
 	case -ESHUTDOWN:
 		/* this urb is terminated, clean up */
-		dbg("%s - urb shutting down with status: %d", __FUNCTION__, urb->status);
+		dbg("%s - urb shutting down with status: %d", __FUNCTION__,
+		    urb->status);
 		priv->write_urb_in_use = 0;
 		return;
 	default:
 		/* error in the urb, so we have to resubmit it */
 		dbg("%s - Overflow in write", __FUNCTION__);
-		dbg("%s - nonzero write bulk status received: %d", __FUNCTION__, urb->status);
+		dbg("%s - nonzero write bulk status received: %d", __FUNCTION__,
+		    urb->status);
 		port->write_urb->transfer_buffer_length = 1;
 		port->write_urb->dev = port->serial->dev;
-		result = usb_submit_urb (port->write_urb, GFP_ATOMIC);
+		result = usb_submit_urb(port->write_urb, GFP_ATOMIC);
 		if (result)
-			dev_err(&urb->dev->dev, "%s - failed resubmitting write urb, error %d\n", __FUNCTION__, result);
+			dev_err(&urb->dev->dev, "%s - failed resubmitting write"
+				" urb, error %d\n", __FUNCTION__, result);
 		else
 			return;
 	}
@@ -985,19 +1003,15 @@ static void pl2303_write_bulk_callback (struct urb *urb, struct pt_regs *regs)
 	pl2303_send(port);
 }
 
-
 /*
  * pl2303_buf_alloc
  *
  * Allocate a circular buffer and all associated memory.
  */
-
 static struct pl2303_buf *pl2303_buf_alloc(unsigned int size)
 {
-
 	struct pl2303_buf *pb;
 
-
 	if (size == 0)
 		return NULL;
 
@@ -1015,16 +1029,13 @@ static struct pl2303_buf *pl2303_buf_alloc(unsigned int size)
 	pb->buf_get = pb->buf_put = pb->buf_buf;
 
 	return pb;
-
 }
 
-
 /*
  * pl2303_buf_free
  *
  * Free the buffer and all associated memory.
  */
-
 static void pl2303_buf_free(struct pl2303_buf *pb)
 {
 	if (pb) {
@@ -1033,13 +1044,11 @@ static void pl2303_buf_free(struct pl2303_buf *pb)
 	}
 }
 
-
 /*
  * pl2303_buf_clear
  *
  * Clear out all data in the circular buffer.
  */
-
 static void pl2303_buf_clear(struct pl2303_buf *pb)
 {
 	if (pb != NULL)
@@ -1047,14 +1056,12 @@ static void pl2303_buf_clear(struct pl2303_buf *pb)
 		/* equivalent to a get of all data available */
 }
 
-
 /*
  * pl2303_buf_data_avail
  *
  * Return the number of bytes of data available in the circular
  * buffer.
  */
-
 static unsigned int pl2303_buf_data_avail(struct pl2303_buf *pb)
 {
 	if (pb != NULL)
@@ -1063,14 +1070,12 @@ static unsigned int pl2303_buf_data_avail(struct pl2303_buf *pb)
 		return 0;
 }
 
-
 /*
  * pl2303_buf_space_avail
  *
  * Return the number of bytes of space available in the circular
  * buffer.
  */
-
 static unsigned int pl2303_buf_space_avail(struct pl2303_buf *pb)
 {
 	if (pb != NULL)
@@ -1079,7 +1084,6 @@ static unsigned int pl2303_buf_space_avail(struct pl2303_buf *pb)
 		return 0;
 }
 
-
 /*
  * pl2303_buf_put
  *
@@ -1088,14 +1092,11 @@ static unsigned int pl2303_buf_space_avail(struct pl2303_buf *pb)
  *
  * Return the number of bytes copied.
  */
-
 static unsigned int pl2303_buf_put(struct pl2303_buf *pb, const char *buf,
-	unsigned int count)
+				   unsigned int count)
 {
-
 	unsigned int len;
 
-
 	if (pb == NULL)
 		return 0;
 
@@ -1120,10 +1121,8 @@ static unsigned int pl2303_buf_put(struct pl2303_buf *pb, const char *buf,
 	}
 
 	return count;
-
 }
 
-
 /*
  * pl2303_buf_get
  *
@@ -1132,14 +1131,11 @@ static unsigned int pl2303_buf_put(struct pl2303_buf *pb, const char *buf,
  *
  * Return the number of bytes copied.
  */
-
 static unsigned int pl2303_buf_get(struct pl2303_buf *pb, char *buf,
-	unsigned int count)
+				   unsigned int count)
 {
-
 	unsigned int len;
 
-
 	if (pb == NULL)
 		return 0;
 
@@ -1164,12 +1160,12 @@ static unsigned int pl2303_buf_get(struct pl2303_buf *pb, char *buf,
 	}
 
 	return count;
-
 }
 
-static int __init pl2303_init (void)
+static int __init pl2303_init(void)
 {
 	int retval;
+
 	retval = usb_serial_register(&pl2303_device);
 	if (retval)
 		goto failed_usb_serial_register;
@@ -1184,14 +1180,12 @@ static int __init pl2303_init (void)
 	return retval;
 }
 
-
-static void __exit pl2303_exit (void)
+static void __exit pl2303_exit(void)
 {
-	usb_deregister (&pl2303_driver);
-	usb_serial_deregister (&pl2303_device);
+	usb_deregister(&pl2303_driver);
+	usb_serial_deregister(&pl2303_device);
 }
 
-
 module_init(pl2303_init);
 module_exit(pl2303_exit);
 

commit a009b75aa0ed55f0bc473c8a3b3e872cbca807ec
Author: Luiz Fernando N. Capitulino <lcapitulino@mandriva.com.br>
Date:   Tue Jul 25 16:58:30 2006 -0300

    USB: pl2303: Removes unneeded goto.
    
    Signed-off-by: Luiz Fernando N. Capitulino <lcapitulino@mandriva.com.br>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 65e4d046951a..54c32ccce626 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -824,16 +824,13 @@ static void pl2303_update_line_status(struct usb_serial_port *port,
 	}
 
 	if (actual_length < length)
-		goto exit;
+		return;
 
         /* Save off the uart status for others to look at */
 	spin_lock_irqsave(&priv->lock, flags);
 	priv->line_status = data[status_idx];
 	spin_unlock_irqrestore(&priv->lock, flags);
 	wake_up_interruptible (&priv->delta_msr_wait);
-
-exit:
-	return;
 }
 
 static void pl2303_read_int_callback (struct urb *urb, struct pt_regs *regs)

commit be729523369ec7825bde4a0e774ee7932e9d3dff
Author: Tomasz Kazmierczak <tomek.fizyk@op.pl>
Date:   Fri Aug 18 23:43:29 2006 +0200

    [PATCH] USB: pl2303: removed support for OTi's DKU-5 clone cable
    
    This patch removes support for a clone of Nokia DKU-5 cable made by Ours
    Technology Inc, as it turned out that the cable does not use the pl2303
    chip, but OTI-6858 chip which is not compatible with the pl2303.
    
    Signed-off-by: Tomasz Kazmierczak <tomek.fizyk@op.pl>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index efbbc0adb89a..65e4d046951a 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -79,7 +79,6 @@ static struct usb_device_id id_table [] = {
 	{ USB_DEVICE(SAGEM_VENDOR_ID, SAGEM_PRODUCT_ID) },
 	{ USB_DEVICE(LEADTEK_VENDOR_ID, LEADTEK_9531_PRODUCT_ID) },
 	{ USB_DEVICE(SPEEDDRAGON_VENDOR_ID, SPEEDDRAGON_PRODUCT_ID) },
-	{ USB_DEVICE(OTI_VENDOR_ID, OTI_PRODUCT_ID) },
 	{ USB_DEVICE(DATAPILOT_U2_VENDOR_ID, DATAPILOT_U2_PRODUCT_ID) },
 	{ USB_DEVICE(BELKIN_VENDOR_ID, BELKIN_PRODUCT_ID) },
 	{ }					/* Terminating entry */

commit b7aa94b682dc6b6dcdc01d36f8e65cef5aae81e2
Author: Kim Oldfield <luv@oldfield.wattle.id.au>
Date:   Tue Jul 25 15:54:59 2006 +1000

    USB: New USB ID for Belkin Serial Adapter
    
    Can you add the USB IDs for the Belkin USB Serial adapter (P/N F5U257)
    to the pl2303 driver in the Linux Kernel? Are you the appropriate person
    to approach for this?
    
    I recently purchased a Belkin USB Serial adapter (P/N F5U257) and found
    that it didn't work. After a bit of experimentation I found that it
    works with the pl2303 driver once the ID has been added. See attached
    patch to fix this. Also attached is the output from lsusb -v just in
    case you require any information from there.
    
    
    From: Kim Oldfield <luv@oldfield.wattle.id.au>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 259db31b65c1..efbbc0adb89a 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -81,6 +81,7 @@ static struct usb_device_id id_table [] = {
 	{ USB_DEVICE(SPEEDDRAGON_VENDOR_ID, SPEEDDRAGON_PRODUCT_ID) },
 	{ USB_DEVICE(OTI_VENDOR_ID, OTI_PRODUCT_ID) },
 	{ USB_DEVICE(DATAPILOT_U2_VENDOR_ID, DATAPILOT_U2_PRODUCT_ID) },
+	{ USB_DEVICE(BELKIN_VENDOR_ID, BELKIN_PRODUCT_ID) },
 	{ }					/* Terminating entry */
 };
 

commit a969888ce91673c7f4b86520d851a6f0d5a5fa7d
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Jul 11 21:22:58 2006 -0700

    [PATCH] USB: move usb-serial.h to include/linux/usb/
    
    USB serial outside of the kernel tree can not build properly due to
    usb-serial.h being buried down in the source tree.  This patch moves the
    location of the file to include/linux/usb and fixes up all of the usb
    serial drivers to handle the move properly.
    
    Cc: Sergei Organov <osv@javad.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 559330eb3126..259db31b65c1 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -27,7 +27,7 @@
 #include <linux/spinlock.h>
 #include <asm/uaccess.h>
 #include <linux/usb.h>
-#include "usb-serial.h"
+#include <linux/usb/serial.h>
 #include "pl2303.h"
 
 /*

commit 3b92847425a98d26ad9d2b8682d3ce6020c90752
Author: Matthew Meno <mmeno@idealcorp.com>
Date:   Wed Jun 21 15:25:53 2006 -0400

    [PATCH] USB: Support for Susteen Datapilot Universal-2 cable in pl2303
    
    The Susteen Datapilot cable
    (http://www.susteen.com/productdetail/71/producthl/Notempty) has an
    internal pl2303 to communicate with a set of dummy connector-ends that
    connect to a variety of cell phones. I've found that it works right out
    of the box by simply adding the product/vendor id to the pl2303 driver.
    
    Signed-off-by: Matt Meno <mmeno@idealcorp.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 93d623a0d092..559330eb3126 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -80,6 +80,7 @@ static struct usb_device_id id_table [] = {
 	{ USB_DEVICE(LEADTEK_VENDOR_ID, LEADTEK_9531_PRODUCT_ID) },
 	{ USB_DEVICE(SPEEDDRAGON_VENDOR_ID, SPEEDDRAGON_PRODUCT_ID) },
 	{ USB_DEVICE(OTI_VENDOR_ID, OTI_PRODUCT_ID) },
+	{ USB_DEVICE(DATAPILOT_U2_VENDOR_ID, DATAPILOT_U2_PRODUCT_ID) },
 	{ }					/* Terminating entry */
 };
 

commit 3d861494729c70d9ebeb7d93caa107897925c355
Author: Peter Moulder <Peter.Moulder@infotech.monash.edu.au>
Date:   Mon Jun 19 22:47:49 2006 +1000

    [PATCH] USB: Addition of vendor/product id pair for pl2303 driver
    
    Text from the back of the box, for your information/amusement:
    
     USB DATA CABLE
       FOR K700 Series
    
     The USB Cable is an ideal link between your mobile phone and PC. Employing
     the user-friendiy [sic] USB standard,its capacity for rapid data transfer enables functions
     such as synchronization of phone book and calendar,as well as Internet browsing via
     a modem-enabled phone.Autual [sic] connection speed is dependent on phone capacity.
    
     MADE IN CHINA
    
    From: Peter Moulder <Peter.Moulder@infotech.monash.edu.au>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index de93a2b909e7..93d623a0d092 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -52,6 +52,7 @@ struct pl2303_buf {
 static struct usb_device_id id_table [] = {
 	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID) },
 	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_RSAQ2) },
+	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_DCU11) },
 	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_RSAQ3) },
 	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_PHAROS) },
 	{ USB_DEVICE(IODATA_VENDOR_ID, IODATA_PRODUCT_ID) },

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jörn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jörn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index d88704387202..de93a2b909e7 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -14,7 +14,6 @@
  *
  */
 
-#include <linux/config.h>
 #include <linux/kernel.h>
 #include <linux/errno.h>
 #include <linux/init.h>

commit 80b47853b19114dd53e83e15bf1db3e183a66824
Author: Pete Zaitcev <zaitcev@redhat.com>
Date:   Mon May 22 22:05:17 2006 -0700

    [PATCH] USB: Syntax cleanup for pl2303 (trailing backslash)
    
    Remove the silly trailing backslash.
    
    Signed-off-by: Pete Zaitcev <zaitcev@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 2ca6dd94796f..d88704387202 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -600,7 +600,7 @@ static void pl2303_close (struct usb_serial_port *port, struct file *filp)
 	unsigned int c_cflag;
 	int bps;
 	long timeout;
-	wait_queue_t wait;						\
+	wait_queue_t wait;
 
 	dbg("%s - port %d", __FUNCTION__, port->number);
 

commit cf2c7481d2ff7f0c266de873b2fe93883e9782f9
Author: Pete Zaitcev <zaitcev@redhat.com>
Date:   Mon May 22 21:58:49 2006 -0700

    [PATCH] USB serial: encapsulate schedule_work, remove double-calling
    
    I'm going to throw schedule_work away, it's retarded. But for starters,
    let's have it encapsulated.
    
    Also, generic and whiteheat were both calling usb_serial_port_softint
    and scheduled work. Only one was necessary.
    
    Signed-off-by: Pete Zaitcev <zaitcev@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index c96714bb1cb8..2ca6dd94796f 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -314,7 +314,7 @@ static void pl2303_send(struct usb_serial_port *port)
 		// TODO: reschedule pl2303_send
 	}
 
-	schedule_work(&port->work);
+	usb_serial_port_softint(port);
 }
 
 static int pl2303_write_room(struct usb_serial_port *port)

commit 58381719845d9ee19a321c2eb69cfa9b7886be9a
Author: Wang Jun <wangjun1974@gmail.com>
Date:   Wed Apr 19 16:32:07 2006 +0800

    [PATCH] USB: add new iTegno usb CDMA 1x card support for pl2303
    
    Add new iTegno usb CDMA 1x card (usbid '0eba:2080') support to pl2303 driver
    
    Signed-off-by: Wang Jun <wangjun1974@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index ccf746b27d4e..c96714bb1cb8 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -61,6 +61,7 @@ static struct usb_device_id id_table [] = {
 	{ USB_DEVICE(ELCOM_VENDOR_ID, ELCOM_PRODUCT_ID) },
 	{ USB_DEVICE(ELCOM_VENDOR_ID, ELCOM_PRODUCT_ID_UCSGT) },
 	{ USB_DEVICE(ITEGNO_VENDOR_ID, ITEGNO_PRODUCT_ID) },
+	{ USB_DEVICE(ITEGNO_VENDOR_ID, ITEGNO_PRODUCT_ID_2080) },
 	{ USB_DEVICE(MA620_VENDOR_ID, MA620_PRODUCT_ID) },
 	{ USB_DEVICE(RATOC_VENDOR_ID, RATOC_PRODUCT_ID) },
 	{ USB_DEVICE(TRIPP_VENDOR_ID, TRIPP_PRODUCT_ID) },

commit e853bf4af372afdae732c48be04a6b154f2de3d4
Author: Tomasz Kazmierczak <tomek.fizyk@op.pl>
Date:   Thu Apr 6 22:07:12 2006 +0200

    [PATCH] USB: pl2303: added support for OTi's DKU-5 clone cable
    
    This patch adds support for a clone of Nokia DKU-5 cable made by
    Ours Technology Inc for Nokia phones with PopPort (Nokia 3100 and others).
    The cable uses PL2303 USB-to-serial converter from Prolific Technology Inc.
    
    Signed-off-by: Tomasz Kazmierczak <tomek.fizyk@op.pl>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index b3014fda645c..ccf746b27d4e 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -78,6 +78,7 @@ static struct usb_device_id id_table [] = {
 	{ USB_DEVICE(SAGEM_VENDOR_ID, SAGEM_PRODUCT_ID) },
 	{ USB_DEVICE(LEADTEK_VENDOR_ID, LEADTEK_9531_PRODUCT_ID) },
 	{ USB_DEVICE(SPEEDDRAGON_VENDOR_ID, SPEEDDRAGON_PRODUCT_ID) },
+	{ USB_DEVICE(OTI_VENDOR_ID, OTI_PRODUCT_ID) },
 	{ }					/* Terminating entry */
 };
 

commit 491b04ce1c9adfa0cd73f095086f3c37da81b667
Author: Dick Streefland <dick@streefland.net>
Date:   Wed Mar 1 00:53:33 2006 -0800

    [PATCH] USB: support for USB-to-serial cable from Speed Dragon Multimedia
    
    The USB data cable for my Samsung GSM phone contains the USB-to-serial
    converter chip MS3303H from Speed Dragon Multimedia, Inc.  that appears to
    be compatible with the PL2303 chip.  The following patch adds support for
    this chip to the pl2303 driver.
    
    Signed-off-by: Dick Streefland <dick@streefland.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index fb3b6b7b9065..b3014fda645c 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -77,6 +77,7 @@ static struct usb_device_id id_table [] = {
 	{ USB_DEVICE(CA_42_CA42_VENDOR_ID, CA_42_CA42_PRODUCT_ID) },
 	{ USB_DEVICE(SAGEM_VENDOR_ID, SAGEM_PRODUCT_ID) },
 	{ USB_DEVICE(LEADTEK_VENDOR_ID, LEADTEK_9531_PRODUCT_ID) },
+	{ USB_DEVICE(SPEEDDRAGON_VENDOR_ID, SPEEDDRAGON_PRODUCT_ID) },
 	{ }					/* Terminating entry */
 };
 

commit 96050b11f690878c19c1cd39970ab7325d91e18b
Author: Julian Bradfield <jcb+luu@inf.ed.ac.uk>
Date:   Wed Mar 1 10:19:44 2006 +0000

    [PATCH] USB: PL2303 and TIOCMIWAIT
    
    A while ago, I posted about TIOCMIWAIT not working with the PL2303
    USB-serial adapter.
    
    After a brief exchange with Greg, I tracked this to a missing wake-up
    in the USB interrupt procedures. I got our systems staff to install
    the enclosed very simple patch to our 2.6.12 kernels, and it all works
    fine as expected. I guess this should also apply to the latest version
    and go into the mainstream.
    
    Apologies for the long delay in posting the result.
    
    The routine being patched is pl2303_update_line_status
    
    Signed-off-by: Julian Bradfield <jcb+luu@inf.ed.ac.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index cf2213bae0e0..fb3b6b7b9065 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -826,6 +826,7 @@ static void pl2303_update_line_status(struct usb_serial_port *port,
 	spin_lock_irqsave(&priv->lock, flags);
 	priv->line_status = data[status_idx];
 	spin_unlock_irqrestore(&priv->lock, flags);
+	wake_up_interruptible (&priv->delta_msr_wait);
 
 exit:
 	return;

commit 80b6ca48321974a6566a1c9048ba34f60420bca6
Author: Eric Sesterhenn <snakebyte@gmx.de>
Date:   Mon Feb 27 21:29:43 2006 +0100

    [PATCH] USB: kzalloc() conversion for rest of drivers/usb
    
    Signed-off-by: Eric Sesterhenn <snakebyte@gmx.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 37c81c08faad..cf2213bae0e0 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -218,10 +218,9 @@ static int pl2303_startup (struct usb_serial *serial)
 	dbg("device type: %d", type);
 
 	for (i = 0; i < serial->num_ports; ++i) {
-		priv = kmalloc (sizeof (struct pl2303_private), GFP_KERNEL);
+		priv = kzalloc(sizeof(struct pl2303_private), GFP_KERNEL);
 		if (!priv)
 			goto cleanup;
-		memset (priv, 0x00, sizeof (struct pl2303_private));
 		spin_lock_init(&priv->lock);
 		priv->buf = pl2303_buf_alloc(PL2303_BUF_SIZE);
 		if (priv->buf == NULL) {
@@ -383,12 +382,11 @@ static void pl2303_set_termios (struct usb_serial_port *port, struct termios *ol
 		}
 	}
 
-	buf = kmalloc (7, GFP_KERNEL);
+	buf = kzalloc (7, GFP_KERNEL);
 	if (!buf) {
 		dev_err(&port->dev, "%s - out of memory.\n", __FUNCTION__);
 		return;
 	}
-	memset (buf, 0x00, 0x07);
 	
 	i = usb_control_msg (serial->dev, usb_rcvctrlpipe (serial->dev, 0),
 			     GET_LINE_REQUEST, GET_LINE_REQUEST_TYPE,

commit c6c27721a42b991965bb792d5c196b8331d008d5
Author: Christian Lindner <christian.lindner@gmx.net>
Date:   Wed Feb 1 14:10:52 2006 +0100

    [PATCH] USB: PL2303: Leadtek 9531 GPS-Mouse
    
    The patch adds the USB ID (0413:2101) for the Leadtek GPS-Mouse 9531 to
    the driver pl2303.
    
    Signed-off-by: Christian Lindner <christian.lindner@gmx.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index e8e575e037c1..37c81c08faad 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -73,9 +73,10 @@ static struct usb_device_id id_table [] = {
 	{ USB_DEVICE(SIEMENS_VENDOR_ID, SIEMENS_PRODUCT_ID_X65) },
 	{ USB_DEVICE(SIEMENS_VENDOR_ID, SIEMENS_PRODUCT_ID_X75) },
 	{ USB_DEVICE(SYNTECH_VENDOR_ID, SYNTECH_PRODUCT_ID) },
-	{ USB_DEVICE(NOKIA_CA42_VENDOR_ID, NOKIA_CA42_PRODUCT_ID ) },
-	{ USB_DEVICE(CA_42_CA42_VENDOR_ID, CA_42_CA42_PRODUCT_ID ) },
+	{ USB_DEVICE(NOKIA_CA42_VENDOR_ID, NOKIA_CA42_PRODUCT_ID) },
+	{ USB_DEVICE(CA_42_CA42_VENDOR_ID, CA_42_CA42_PRODUCT_ID) },
 	{ USB_DEVICE(SAGEM_VENDOR_ID, SAGEM_PRODUCT_ID) },
+	{ USB_DEVICE(LEADTEK_VENDOR_ID, LEADTEK_9531_PRODUCT_ID) },
 	{ }					/* Terminating entry */
 };
 

commit 6cceb05f8df6e28ab90f44bdeba50d33928cdee5
Author: Denis MONTERRAT <denis.monterrat@sagem.com>
Date:   Thu Jan 19 14:52:38 2006 +0100

    [PATCH] USB: add new pl2303 device ids
    
    Signed-off-by: FALIPOU F Developer <fred.falipou@free.fr>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 58ef1d0d9cc7..e8e575e037c1 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -75,6 +75,7 @@ static struct usb_device_id id_table [] = {
 	{ USB_DEVICE(SYNTECH_VENDOR_ID, SYNTECH_PRODUCT_ID) },
 	{ USB_DEVICE(NOKIA_CA42_VENDOR_ID, NOKIA_CA42_PRODUCT_ID ) },
 	{ USB_DEVICE(CA_42_CA42_VENDOR_ID, CA_42_CA42_PRODUCT_ID ) },
+	{ USB_DEVICE(SAGEM_VENDOR_ID, SAGEM_PRODUCT_ID) },
 	{ }					/* Terminating entry */
 };
 

commit 838b42814c640ddcc378ba29cd31ffd64fb36bc5
Author: Martin Gingras <martin.gingras@gmail.com>
Date:   Mon Jan 9 12:35:41 2006 -0500

    [PATCH] USB: pl2303: Added support for CA-42 clone cable
    
    Added support for CA-42 clone cable (www.ca-42.com)
    
    Signed-off-by: Martin Gingras <martin.gingras@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 0eb883f44ada..58ef1d0d9cc7 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -73,7 +73,8 @@ static struct usb_device_id id_table [] = {
 	{ USB_DEVICE(SIEMENS_VENDOR_ID, SIEMENS_PRODUCT_ID_X65) },
 	{ USB_DEVICE(SIEMENS_VENDOR_ID, SIEMENS_PRODUCT_ID_X75) },
 	{ USB_DEVICE(SYNTECH_VENDOR_ID, SYNTECH_PRODUCT_ID) },
-	{ USB_DEVICE( NOKIA_CA42_VENDOR_ID, NOKIA_CA42_PRODUCT_ID ) },
+	{ USB_DEVICE(NOKIA_CA42_VENDOR_ID, NOKIA_CA42_PRODUCT_ID ) },
+	{ USB_DEVICE(CA_42_CA42_VENDOR_ID, CA_42_CA42_PRODUCT_ID ) },
 	{ }					/* Terminating entry */
 };
 

commit 3824ba7df91745da6ebac703c87c3b801c34fdd0
Author: Adrian Bunk <bunk@stusta.de>
Date:   Sat Jan 14 03:08:16 2006 +0100

    [PATCH] remove unused tmp_buf_sem's
    
    tmp_buf_sem sems to be a common name for something completely unused...
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de> ("usb portion")
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 9ffff1938239..0eb883f44ada 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -43,8 +43,6 @@ static int debug;
 #define PL2303_BUF_SIZE		1024
 #define PL2303_TMP_BUF_SIZE	1024
 
-static DECLARE_MUTEX(pl2303_tmp_buf_sem);
-
 struct pl2303_buf {
 	unsigned int	buf_size;
 	char		*buf_buf;

commit 33f0f88f1c51ae5c2d593d26960c760ea154c2e2
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Mon Jan 9 20:54:13 2006 -0800

    [PATCH] TTY layer buffering revamp
    
    The API and code have been through various bits of initial review by
    serial driver people but they definitely need to live somewhere for a
    while so the unconverted drivers can get knocked into shape, existing
    drivers that have been updated can be better tuned and bugs whacked out.
    
    This replaces the tty flip buffers with kmalloc objects in rings. In the
    normal situation for an IRQ driven serial port at typical speeds the
    behaviour is pretty much the same, two buffers end up allocated and the
    kernel cycles between them as before.
    
    When there are delays or at high speed we now behave far better as the
    buffer pool can grow a bit rather than lose characters. This also means
    that we can operate at higher speeds reliably.
    
    For drivers that receive characters in blocks (DMA based, USB and
    especially virtualisation) the layer allows a lot of driver specific
    code that works around the tty layer with private secondary queues to be
    removed. The IBM folks need this sort of layer, the smart serial port
    people do, the virtualisers do (because a virtualised tty typically
    operates at infinite speed rather than emulating 9600 baud).
    
    Finally many drivers had invalid and unsafe attempts to avoid buffer
    overflows by directly invoking tty methods extracted out of the innards
    of work queue structs. These are no longer needed and all go away. That
    fixes various random hangs with serial ports on overflow.
    
    The other change in here is to optimise the receive_room path that is
    used by some callers. It turns out that only one ldisc uses receive room
    except asa constant and it updates it far far less than the value is
    read. We thus make it a variable not a function call.
    
    I expect the code to contain bugs due to the size alone but I'll be
    watching and squashing them and feeding out new patches as it goes.
    
    Because the buffers now dynamically expand you should only run out of
    buffering when the kernel runs out of memory for real.  That means a lot of
    the horrible hacks high performance drivers used to do just aren't needed any
    more.
    
    Description:
    
    tty_insert_flip_char is an old API and continues to work as before, as does
    tty_flip_buffer_push() [this is why many drivers dont need modification].  It
    does now also return the number of chars inserted
    
    There are also
    
    tty_buffer_request_room(tty, len)
    
    which asks for a buffer block of the length requested and returns the space
    found.  This improves efficiency with hardware that knows how much to
    transfer.
    
    and tty_insert_flip_string_flags(tty, str, flags, len)
    
    to insert a string of characters and flags
    
    For a smart interface the usual code is
    
        len = tty_request_buffer_room(tty, amount_hardware_says);
        tty_insert_flip_string(tty, buffer_from_card, len);
    
    More description!
    
    At the moment tty buffers are attached directly to the tty.  This is causing a
    lot of the problems related to tty layer locking, also problems at high speed
    and also with bursty data (such as occurs in virtualised environments)
    
    I'm working on ripping out the flip buffers and replacing them with a pool of
    dynamically allocated buffers.  This allows both for old style "byte I/O"
    devices and also helps virtualisation and smart devices where large blocks of
    data suddenely materialise and need storing.
    
    So far so good.  Lots of drivers reference tty->flip.*.  Several of them also
    call directly and unsafely into function pointers it provides.  This will all
    break.  Most drivers can use tty_insert_flip_char which can be kept as an API
    but others need more.
    
    At the moment I've added the following interfaces, if people think more will
    be needed now is a good time to say
    
     int tty_buffer_request_room(tty, size)
    
    Try and ensure at least size bytes are available, returns actual room (may be
    zero).  At the moment it just uses the flipbuf space but that will change.
    Repeated calls without characters being added are not cumulative.  (ie if you
    call it with 1, 1, 1, and then 4 you'll have four characters of space.  The
    other functions will also try and grow buffers in future but this will be a
    more efficient way when you know block sizes.
    
     int tty_insert_flip_char(tty, ch, flag)
    
    As before insert a character if there is room.  Now returns 1 for success, 0
    for failure.
    
     int tty_insert_flip_string(tty, str, len)
    
    Insert a block of non error characters.  Returns the number inserted.
    
     int tty_prepare_flip_string(tty, strptr, len)
    
    Adjust the buffer to allow len characters to be added.  Returns a buffer
    pointer in strptr and the length available.  This allows for hardware that
    needs to use functions like insl or mencpy_fromio.
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Cc: Paul Fulghum <paulkf@microgate.com>
    Signed-off-by: Hirokazu Takata <takata@linux-m32r.org>
    Signed-off-by: Serge Hallyn <serue@us.ibm.com>
    Signed-off-by: Jeff Dike <jdike@addtoit.com>
    Signed-off-by: John Hawkes <hawkes@sgi.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index f03721056190..9ffff1938239 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -924,16 +924,12 @@ static void pl2303_read_bulk_callback (struct urb *urb, struct pt_regs *regs)
 
 	tty = port->tty;
 	if (tty && urb->actual_length) {
+		tty_buffer_request_room(tty, urb->actual_length + 1);
 		/* overrun is special, not associated with a char */
 		if (status & UART_OVERRUN_ERROR)
 			tty_insert_flip_char(tty, 0, TTY_OVERRUN);
-
-		for (i = 0; i < urb->actual_length; ++i) {
-			if (tty->flip.count >= TTY_FLIPBUF_SIZE) {
-				tty_flip_buffer_push(tty);
-			}
+		for (i = 0; i < urb->actual_length; ++i)
 			tty_insert_flip_char (tty, data[i], tty_flag);
-		}
 		tty_flip_buffer_push (tty);
 	}
 

commit 95f209f93663103db2a8fb989e226ac68a98b036
Author: Horst Schirmeier <horst@schirmeier.com>
Date:   Thu Jul 28 15:32:20 2005 +0200

    [PATCH] USB: pl2303_update_line_status data length fix
    
    Minimum data length must be UART_STATE + 1, as data[UART_STATE] is being
    accessed for the new line_state. Although PL-2303 hardware is not
    expected to send data with exactly UART_STATE length, this keeps it on
    the safe side.
    
    Signed-off-by: Horst Schirmeier <horst@schirmeier.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index c96ba9fc19e0..f03721056190 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -810,7 +810,7 @@ static void pl2303_update_line_status(struct usb_serial_port *port,
 	struct pl2303_private *priv = usb_get_serial_port_data(port);
 	unsigned long flags;
 	u8 status_idx = UART_STATE;
-	u8 length = UART_STATE;
+	u8 length = UART_STATE + 1;
 
 	if ((le16_to_cpu(port->serial->dev->descriptor.idVendor) == SIEMENS_VENDOR_ID) &&
 	    (le16_to_cpu(port->serial->dev->descriptor.idProduct) == SIEMENS_PRODUCT_ID_X65 ||

commit 75318d2d7cab77b14c5d3dbd5e69f2680a769e16
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Nov 21 14:53:03 2005 -0800

    [PATCH] USB: remove .owner field from struct usb_driver
    
    It is no longer needed, so let's remove it, saving a bit of memory.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index e302a320444c..c96ba9fc19e0 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -82,7 +82,6 @@ static struct usb_device_id id_table [] = {
 MODULE_DEVICE_TABLE (usb, id_table);
 
 static struct usb_driver pl2303_driver = {
-	.owner =	THIS_MODULE,
 	.name =		"pl2303",
 	.probe =	usb_serial_probe,
 	.disconnect =	usb_serial_disconnect,

commit ba9dc657af86d05d2971633e57d1f6f94ed60472
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed Nov 16 13:41:28 2005 -0800

    [PATCH] USB: allow usb drivers to disable dynamic ids
    
    This lets drivers, like the usb-serial ones, disable the ability to add
    ids from sysfs.
    
    The usb-serial drivers are "odd" in that they are really usb-serial bus
    drivers, not usb bus drivers, so the dynamic id logic will have to go
    into the usb-serial bus core for those drivers to get that ability.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 41a45a5025b2..e302a320444c 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -87,6 +87,7 @@ static struct usb_driver pl2303_driver = {
 	.probe =	usb_serial_probe,
 	.disconnect =	usb_serial_disconnect,
 	.id_table =	id_table,
+	.no_dynamic_id = 	1,
 };
 
 #define SET_LINE_REQUEST_TYPE		0x21

commit b8f4c1d6674463e5824eada1ad7ec799276718bd
Author: Luiz Fernando Capitulino <lcapitulino@mandriva.com.br>
Date:   Thu Nov 17 09:47:36 2005 -0800

    [PATCH] USB: pl2303: updates pl2303_update_line_status()
    
    Updates pl2303_update_line_status() to handle X75 and SX1 Siemens mobiles
    
    Signed-off-by: Luiz Capitulino <lcapitulino@mandriva.com.br>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index f6ce321a8655..41a45a5025b2 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -813,7 +813,9 @@ static void pl2303_update_line_status(struct usb_serial_port *port,
 	u8 length = UART_STATE;
 
 	if ((le16_to_cpu(port->serial->dev->descriptor.idVendor) == SIEMENS_VENDOR_ID) &&
-	    (le16_to_cpu(port->serial->dev->descriptor.idProduct) == SIEMENS_PRODUCT_ID_X65)) {
+	    (le16_to_cpu(port->serial->dev->descriptor.idProduct) == SIEMENS_PRODUCT_ID_X65 ||
+	     le16_to_cpu(port->serial->dev->descriptor.idProduct) == SIEMENS_PRODUCT_ID_SX1 ||
+	     le16_to_cpu(port->serial->dev->descriptor.idProduct) == SIEMENS_PRODUCT_ID_X75)) {
 		length = 1;
 		status_idx = 0;
 	}

commit a8310f3b8b713e52d77c56d4b8865685ee40d02a
Author: Luiz Fernando Capitulino <lcapitulino@mandriva.com.br>
Date:   Thu Nov 17 09:47:32 2005 -0800

    [PATCH] USB: pl2303: adds new IDs.
    
    This patch adds two new Siemens mobiles IDs for the pl2303 driver.
    
    Signed-off-by: Luiz Capitulino <lcapitulino@mandriva.com.br>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 165c119bf10e..f6ce321a8655 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -71,7 +71,9 @@ static struct usb_device_id id_table [] = {
 	{ USB_DEVICE(SITECOM_VENDOR_ID, SITECOM_PRODUCT_ID) },
 	{ USB_DEVICE(ALCATEL_VENDOR_ID, ALCATEL_PRODUCT_ID) },
 	{ USB_DEVICE(SAMSUNG_VENDOR_ID, SAMSUNG_PRODUCT_ID) },
+	{ USB_DEVICE(SIEMENS_VENDOR_ID, SIEMENS_PRODUCT_ID_SX1) },
 	{ USB_DEVICE(SIEMENS_VENDOR_ID, SIEMENS_PRODUCT_ID_X65) },
+	{ USB_DEVICE(SIEMENS_VENDOR_ID, SIEMENS_PRODUCT_ID_X75) },
 	{ USB_DEVICE(SYNTECH_VENDOR_ID, SYNTECH_PRODUCT_ID) },
 	{ USB_DEVICE( NOKIA_CA42_VENDOR_ID, NOKIA_CA42_PRODUCT_ID ) },
 	{ }					/* Terminating entry */

commit 17a882fc0c91477b2582a6dfd4ca93ae7eb58cd3
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Jun 20 21:15:16 2005 -0700

    [PATCH] USB Serial: remove driver version from a few drivers
    
    These numbers are pointless, as they have not been changed in _years_,
    so we should just remove them to stop pretending there is an actual
    "version number" for these drivers.
    
    This should also help reduce confusion when people try to ask for
    support of a specific driver version, as there has been no way to tell
    what they are talking about.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index f8f4e93e8c0b..165c119bf10e 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -34,7 +34,6 @@
 /*
  * Version Information
  */
-#define DRIVER_VERSION "v0.12"
 #define DRIVER_DESC "Prolific PL2303 USB to serial adaptor driver"
 
 static int debug;
@@ -1176,7 +1175,7 @@ static int __init pl2303_init (void)
 	retval = usb_register(&pl2303_driver);
 	if (retval)
 		goto failed_usb_register;
-	info(DRIVER_DESC " " DRIVER_VERSION);
+	info(DRIVER_DESC);
 	return 0;
 failed_usb_register:
 	usb_serial_deregister(&pl2303_device);
@@ -1196,7 +1195,6 @@ module_init(pl2303_init);
 module_exit(pl2303_exit);
 
 MODULE_DESCRIPTION(DRIVER_DESC);
-MODULE_VERSION(DRIVER_VERSION);
 MODULE_LICENSE("GPL");
 
 module_param(debug, bool, S_IRUGO | S_IWUSR);

commit 269bda1c123c7caf88e1deb2264f9086f0344192
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Jun 20 21:15:16 2005 -0700

    [PATCH] USB Serial: move name to driver structure
    
    This fixes up a lot of problems in sysfs with some of the usb serial
    drivers, they had incorrect driver names.  Also saves a tiny ammount
    of memory.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 29719ceab19a..f8f4e93e8c0b 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -157,8 +157,8 @@ static unsigned int pl2303_buf_get(struct pl2303_buf *pb, char *buf,
 static struct usb_serial_driver pl2303_device = {
 	.driver = {
 		.owner =	THIS_MODULE,
+		.name =		"pl2303",
 	},
-	.name =			"PL-2303",
 	.id_table =		id_table,
 	.num_interrupt_in =	NUM_DONT_CARE,
 	.num_bulk_in =		1,

commit 502b95c1cc9e2c855a26f90fc999c5211b8ba957
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Jun 20 21:15:16 2005 -0700

    [PATCH] USB Serial: move old changelog comments out of source code
    
    Create a new file just for these things, as they just get in the
    way in the source files.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index beef3c4cee6e..29719ceab19a 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -8,31 +8,10 @@
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
- *	the Free Software Foundation; either version 2 of the License, or
- *	(at your option) any later version.
+ *	the Free Software Foundation; either version 2 of the License.
  *
  * See Documentation/usb/usb-serial.txt for more information on using this driver
  *
- * 2002_Mar_26 gkh
- *	allowed driver to work properly if there is no tty assigned to a port
- *	(this happens for serial console devices.)
- *
- * 2001_Oct_06 gkh
- *	Added RTS and DTR line control.  Thanks to joe@bndlg.de for parts of it.
- *
- * 2001_Sep_19 gkh
- *	Added break support.
- *
- * 2001_Aug_30 gkh
- *	fixed oops in write_bulk_callback.
- *
- * 2001_Aug_28 gkh
- *	reworked buffer logic to be like other usb-serial drivers.  Hopefully
- *	removing some reported problems.
- *
- * 2001_Jun_06 gkh
- *	finished porting to 2.4 format.
- * 
  */
 
 #include <linux/config.h>

commit 18fcac353fdc7cd072b0d24c8667042e675a4c11
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Jun 20 21:15:16 2005 -0700

    [PATCH] USB Serial: get rid of the .owner field in usb_serial_driver
    
    Don't duplicate something that's already in struct driver.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 7134648e078d..beef3c4cee6e 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -176,7 +176,9 @@ static unsigned int pl2303_buf_get(struct pl2303_buf *pb, char *buf,
 
 /* All of the device info needed for the PL2303 SIO serial converter */
 static struct usb_serial_driver pl2303_device = {
-	.owner =		THIS_MODULE,
+	.driver = {
+		.owner =	THIS_MODULE,
+	},
 	.name =			"PL-2303",
 	.id_table =		id_table,
 	.num_interrupt_in =	NUM_DONT_CARE,

commit ea65370d025f5005649e5cb37c4d025e92c6fc38
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Jun 20 21:15:16 2005 -0700

    [PATCH] USB Serial: rename usb_serial_device_type to usb_serial_driver
    
    I'm tired of trying to explain why a "device_type" is really a driver.
    This better describes exactly what this structure is.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 3cf245bdda54..7134648e078d 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -175,7 +175,7 @@ static unsigned int pl2303_buf_get(struct pl2303_buf *pb, char *buf,
 
 
 /* All of the device info needed for the PL2303 SIO serial converter */
-static struct usb_serial_device_type pl2303_device = {
+static struct usb_serial_driver pl2303_device = {
 	.owner =		THIS_MODULE,
 	.name =			"PL-2303",
 	.id_table =		id_table,

commit 68e110a078a7e8a416ba06bfa6372ae28222809e
Author: Robert Spanton <rds204@ecs.soton.ac.uk>
Date:   Tue Aug 30 23:38:23 2005 +0100

    [PATCH] USB: PL2303: CA-42 Phone cable
    
    This patch adds the product ID and vendor ID for a Nokia CA-42 USB cable
    to the list of devices handled by the pl2303 driver. The patch is
    against 2.6.13.
    
    Signed-off-by: Robert Spanton <rds204@zepler.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index ea8c6e74be4f..3cf245bdda54 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -95,6 +95,7 @@ static struct usb_device_id id_table [] = {
 	{ USB_DEVICE(SAMSUNG_VENDOR_ID, SAMSUNG_PRODUCT_ID) },
 	{ USB_DEVICE(SIEMENS_VENDOR_ID, SIEMENS_PRODUCT_ID_X65) },
 	{ USB_DEVICE(SYNTECH_VENDOR_ID, SYNTECH_PRODUCT_ID) },
+	{ USB_DEVICE( NOKIA_CA42_VENDOR_ID, NOKIA_CA42_PRODUCT_ID ) },
 	{ }					/* Terminating entry */
 };
 

commit 22c438632850c0d6257b45c90afed0cea6953afc
Author: Nishanth Aravamudan <nacc@us.ibm.com>
Date:   Mon Aug 15 11:30:11 2005 -0700

    [PATCH] drivers/usb: fix-up schedule_timeout() usage
    
    Description: Use schedule_timeout_{,un}interruptible() instead of
    set_current_state()/schedule_timeout() to reduce kernel size.
    
    Signed-off-by: Nishanth Aravamudan <nacc@us.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 461474176cfb..ea8c6e74be4f 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -652,8 +652,7 @@ static void pl2303_close (struct usb_serial_port *port, struct file *filp)
 		timeout = max((HZ*2560)/bps,HZ/10);
 	else
 		timeout = 2*HZ;
-	set_current_state(TASK_INTERRUPTIBLE);
-	schedule_timeout(timeout);
+	schedule_timeout_interruptible(timeout);
 
 	/* shutdown our urbs */
 	dbg("%s - shutting down urbs", __FUNCTION__);

commit 1694899fd1af43636351aac97f415fd3c9cefb1d
Author: Dariusz M <D.Marcinkiewicz@elka.pw.edu.pl>
Date:   Thu Jul 28 18:06:13 2005 +0200

    [PATCH] USB: pl2303 driver, makes pl2303HX chip work correctly
    
    This trivial patch makes pl2303 driver work correctly with pl2303HX chip.
    Apparently some bug in HX version of pl2303 makes the chip loose some
    transmitted bytes or stop working at all after reception of
    USB_REQ_CLEAR_FEATURE mesage. Logs generated by UsbSnoop application reveal
    that windows driver does not send this type of messages to the converter.
    
    From: "Dariusz M." <D.Marcinkiewicz@elka.pw.edu.pl>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 7eab5d4cf3a8..461474176cfb 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -538,8 +538,10 @@ static int pl2303_open (struct usb_serial_port *port, struct file *filp)
 
 	dbg("%s -  port %d", __FUNCTION__, port->number);
 
-	usb_clear_halt(serial->dev, port->write_urb->pipe);
-	usb_clear_halt(serial->dev, port->read_urb->pipe);
+	if (priv->type != HX) {
+		usb_clear_halt(serial->dev, port->write_urb->pipe);
+		usb_clear_halt(serial->dev, port->read_urb->pipe);
+	}
 
 	buf = kmalloc(10, GFP_KERNEL);
 	if (buf==NULL)

commit 1bc3c9e1e44c2059fe2ffa6ff70ad0a925d7b05f
Author: Jesper Juhl <juhl-lkml@dif.dk>
Date:   Mon Apr 18 17:39:34 2005 -0700

    [PATCH] USB: kfree cleanup for drivers/usb/* - no need to check for NULL
    
    Get rid of a bunch of redundant NULL pointer checks in drivers/usb/*,
    there's no need to check a pointer for NULL before calling kfree() on it.
    
    Signed-off-by: Jesper Juhl <juhl-lkml@dif.dk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    
    
    Index: gregkh-2.6/drivers/usb/class/audio.c
    ===================================================================

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 8e9b007bf44d..7eab5d4cf3a8 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -1044,9 +1044,8 @@ static struct pl2303_buf *pl2303_buf_alloc(unsigned int size)
 
 static void pl2303_buf_free(struct pl2303_buf *pb)
 {
-	if (pb != NULL) {
-		if (pb->buf_buf != NULL)
-			kfree(pb->buf_buf);
+	if (pb) {
+		kfree(pb->buf_buf);
 		kfree(pb);
 	}
 }

commit acbb36f116243bed515357264ecbb6ff9c6d2a5b
Author: Peter Favrholdt <pfavr@mip.sdu.dk>
Date:   Mon Apr 18 17:39:32 2005 -0700

    [PATCH] USB: pl2303 new vendor/model ids
    
    Please accept the attached patch which adds the vendorid 0x0745 and
    modelid 0x0001 (ID 0745:0001) "Syntech Information Co., Ltd."
    
    The device is an USB IR cradle for a barcode scanner (CPT-8001C) from
    Cipherlab.
    
    
    From: Peter Favrholdt <pfavr@mip.sdu.dk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    
    diff -u kernel-source-2.6.11/drivers/usb/serial/pl2303.c ../kernel-source-2.6.11/drivers/usb/serial/pl2303.c

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index dceda2e43c15..8e9b007bf44d 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -94,6 +94,7 @@ static struct usb_device_id id_table [] = {
 	{ USB_DEVICE(ALCATEL_VENDOR_ID, ALCATEL_PRODUCT_ID) },
 	{ USB_DEVICE(SAMSUNG_VENDOR_ID, SAMSUNG_PRODUCT_ID) },
 	{ USB_DEVICE(SIEMENS_VENDOR_ID, SIEMENS_PRODUCT_ID_X65) },
+	{ USB_DEVICE(SYNTECH_VENDOR_ID, SYNTECH_PRODUCT_ID) },
 	{ }					/* Terminating entry */
 };
 

commit 97bb13ec5bc156352cca8af90080597e04299a73
Author: Flavio Leitner <fbl@conectiva.com.br>
Date:   Mon Apr 18 17:39:31 2005 -0700

    [PATCH] pl2303 - status line
    
    I'm attaching a patch to fix status when using Siemens X65
    mobile. This mobile use first byte instead of normal UART_STATE
    byte.
    
    
    From: Flavio Leitner <fbl@conectiva.com.br>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    
    
    Index: gregkh-2.6/drivers/usb/serial/pl2303.c
    ===================================================================

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index a52115407ea1..dceda2e43c15 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -817,15 +817,40 @@ static void pl2303_shutdown (struct usb_serial *serial)
 	}		
 }
 
+static void pl2303_update_line_status(struct usb_serial_port *port,
+				      unsigned char *data,
+				      unsigned int actual_length)
+{
+
+	struct pl2303_private *priv = usb_get_serial_port_data(port);
+	unsigned long flags;
+	u8 status_idx = UART_STATE;
+	u8 length = UART_STATE;
+
+	if ((le16_to_cpu(port->serial->dev->descriptor.idVendor) == SIEMENS_VENDOR_ID) &&
+	    (le16_to_cpu(port->serial->dev->descriptor.idProduct) == SIEMENS_PRODUCT_ID_X65)) {
+		length = 1;
+		status_idx = 0;
+	}
+
+	if (actual_length < length)
+		goto exit;
+
+        /* Save off the uart status for others to look at */
+	spin_lock_irqsave(&priv->lock, flags);
+	priv->line_status = data[status_idx];
+	spin_unlock_irqrestore(&priv->lock, flags);
+
+exit:
+	return;
+}
 
 static void pl2303_read_int_callback (struct urb *urb, struct pt_regs *regs)
 {
 	struct usb_serial_port *port = (struct usb_serial_port *) urb->context;
-	struct pl2303_private *priv = usb_get_serial_port_data(port);
 	unsigned char *data = urb->transfer_buffer;
-	unsigned long flags;
+	unsigned int actual_length = urb->actual_length;
 	int status;
-	u8 uart_state;
 
 	dbg("%s (%d)", __FUNCTION__, port->number);
 
@@ -844,19 +869,9 @@ static void pl2303_read_int_callback (struct urb *urb, struct pt_regs *regs)
 		goto exit;
 	}
 
-
 	usb_serial_debug_data(debug, &port->dev, __FUNCTION__, urb->actual_length, urb->transfer_buffer);
+	pl2303_update_line_status(port, data, actual_length);
 
-	if (urb->actual_length < UART_STATE)
-		goto exit;
-
-	/* Save off the uart status for others to look at */
-	uart_state = data[UART_STATE];
-	spin_lock_irqsave(&priv->lock, flags);
-	uart_state |= (priv->line_status & UART_STATE_TRANSIENT_MASK);
-	priv->line_status = uart_state;
-	spin_unlock_irqrestore(&priv->lock, flags);
-		
 exit:
 	status = usb_submit_urb (urb, GFP_ATOMIC);
 	if (status)

commit 6fdd8e8e33730a2abc886113bd0b6c4343f63cc9
Author: Flavio Leitner <fbl@conectiva.com.br>
Date:   Mon Apr 18 17:39:31 2005 -0700

    [PATCH] pl2303 - unplug device.
    
    It's possible to unplug usb device and do tiocmset() and tiocmget() without
    valid interface in pl2303 module.
    
    The patch below check this and return -ENODEV if interface was removed.
    
    From: Flavio Leitner <fbl@conectiva.com.br>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    
    diff -purN linux-05-04-11/drivers/usb/serial/pl2303.c linux-05-04-11.usb/drivers/usb/serial/pl2303.c

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 3368d2b0412d..a52115407ea1 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -677,6 +677,9 @@ static int pl2303_tiocmset (struct usb_serial_port *port, struct file *file,
 	unsigned long flags;
 	u8 control;
 
+	if (!usb_get_intfdata(port->serial->interface))
+		return -ENODEV;
+
 	spin_lock_irqsave (&priv->lock, flags);
 	if (set & TIOCM_RTS)
 		priv->line_control |= CONTROL_RTS;
@@ -702,6 +705,9 @@ static int pl2303_tiocmget (struct usb_serial_port *port, struct file *file)
 
 	dbg("%s (%d)", __FUNCTION__, port->number);
 
+	if (!usb_get_intfdata(port->serial->interface))
+		return -ENODEV;
+
 	spin_lock_irqsave (&priv->lock, flags);
 	mcr = priv->line_control;
 	status = priv->line_status;

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
new file mode 100644
index 000000000000..3368d2b0412d
--- /dev/null
+++ b/drivers/usb/serial/pl2303.c
@@ -0,0 +1,1200 @@
+/*
+ * Prolific PL2303 USB to serial adaptor driver
+ *
+ * Copyright (C) 2001-2004 Greg Kroah-Hartman (greg@kroah.com)
+ * Copyright (C) 2003 IBM Corp.
+ *
+ * Original driver for 2.2.x by anonymous
+ *
+ *	This program is free software; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License as published by
+ *	the Free Software Foundation; either version 2 of the License, or
+ *	(at your option) any later version.
+ *
+ * See Documentation/usb/usb-serial.txt for more information on using this driver
+ *
+ * 2002_Mar_26 gkh
+ *	allowed driver to work properly if there is no tty assigned to a port
+ *	(this happens for serial console devices.)
+ *
+ * 2001_Oct_06 gkh
+ *	Added RTS and DTR line control.  Thanks to joe@bndlg.de for parts of it.
+ *
+ * 2001_Sep_19 gkh
+ *	Added break support.
+ *
+ * 2001_Aug_30 gkh
+ *	fixed oops in write_bulk_callback.
+ *
+ * 2001_Aug_28 gkh
+ *	reworked buffer logic to be like other usb-serial drivers.  Hopefully
+ *	removing some reported problems.
+ *
+ * 2001_Jun_06 gkh
+ *	finished porting to 2.4 format.
+ * 
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/tty.h>
+#include <linux/tty_driver.h>
+#include <linux/tty_flip.h>
+#include <linux/serial.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/spinlock.h>
+#include <asm/uaccess.h>
+#include <linux/usb.h>
+#include "usb-serial.h"
+#include "pl2303.h"
+
+/*
+ * Version Information
+ */
+#define DRIVER_VERSION "v0.12"
+#define DRIVER_DESC "Prolific PL2303 USB to serial adaptor driver"
+
+static int debug;
+
+#define PL2303_CLOSING_WAIT	(30*HZ)
+
+#define PL2303_BUF_SIZE		1024
+#define PL2303_TMP_BUF_SIZE	1024
+
+static DECLARE_MUTEX(pl2303_tmp_buf_sem);
+
+struct pl2303_buf {
+	unsigned int	buf_size;
+	char		*buf_buf;
+	char		*buf_get;
+	char		*buf_put;
+};
+
+static struct usb_device_id id_table [] = {
+	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID) },
+	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_RSAQ2) },
+	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_RSAQ3) },
+	{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_PHAROS) },
+	{ USB_DEVICE(IODATA_VENDOR_ID, IODATA_PRODUCT_ID) },
+	{ USB_DEVICE(ATEN_VENDOR_ID, ATEN_PRODUCT_ID) },
+	{ USB_DEVICE(ATEN_VENDOR_ID2, ATEN_PRODUCT_ID) },
+	{ USB_DEVICE(ELCOM_VENDOR_ID, ELCOM_PRODUCT_ID) },
+	{ USB_DEVICE(ELCOM_VENDOR_ID, ELCOM_PRODUCT_ID_UCSGT) },
+	{ USB_DEVICE(ITEGNO_VENDOR_ID, ITEGNO_PRODUCT_ID) },
+	{ USB_DEVICE(MA620_VENDOR_ID, MA620_PRODUCT_ID) },
+	{ USB_DEVICE(RATOC_VENDOR_ID, RATOC_PRODUCT_ID) },
+	{ USB_DEVICE(TRIPP_VENDOR_ID, TRIPP_PRODUCT_ID) },
+	{ USB_DEVICE(RADIOSHACK_VENDOR_ID, RADIOSHACK_PRODUCT_ID) },
+	{ USB_DEVICE(DCU10_VENDOR_ID, DCU10_PRODUCT_ID) },
+	{ USB_DEVICE(SITECOM_VENDOR_ID, SITECOM_PRODUCT_ID) },
+	{ USB_DEVICE(ALCATEL_VENDOR_ID, ALCATEL_PRODUCT_ID) },
+	{ USB_DEVICE(SAMSUNG_VENDOR_ID, SAMSUNG_PRODUCT_ID) },
+	{ USB_DEVICE(SIEMENS_VENDOR_ID, SIEMENS_PRODUCT_ID_X65) },
+	{ }					/* Terminating entry */
+};
+
+MODULE_DEVICE_TABLE (usb, id_table);
+
+static struct usb_driver pl2303_driver = {
+	.owner =	THIS_MODULE,
+	.name =		"pl2303",
+	.probe =	usb_serial_probe,
+	.disconnect =	usb_serial_disconnect,
+	.id_table =	id_table,
+};
+
+#define SET_LINE_REQUEST_TYPE		0x21
+#define SET_LINE_REQUEST		0x20
+
+#define SET_CONTROL_REQUEST_TYPE	0x21
+#define SET_CONTROL_REQUEST		0x22
+#define CONTROL_DTR			0x01
+#define CONTROL_RTS			0x02
+
+#define BREAK_REQUEST_TYPE		0x21
+#define BREAK_REQUEST			0x23	
+#define BREAK_ON			0xffff
+#define BREAK_OFF			0x0000
+
+#define GET_LINE_REQUEST_TYPE		0xa1
+#define GET_LINE_REQUEST		0x21
+
+#define VENDOR_WRITE_REQUEST_TYPE	0x40
+#define VENDOR_WRITE_REQUEST		0x01
+
+#define VENDOR_READ_REQUEST_TYPE	0xc0
+#define VENDOR_READ_REQUEST		0x01
+
+#define UART_STATE			0x08
+#define UART_STATE_TRANSIENT_MASK	0x74
+#define UART_DCD			0x01
+#define UART_DSR			0x02
+#define UART_BREAK_ERROR		0x04
+#define UART_RING			0x08
+#define UART_FRAME_ERROR		0x10
+#define UART_PARITY_ERROR		0x20
+#define UART_OVERRUN_ERROR		0x40
+#define UART_CTS			0x80
+
+/* function prototypes for a PL2303 serial converter */
+static int pl2303_open (struct usb_serial_port *port, struct file *filp);
+static void pl2303_close (struct usb_serial_port *port, struct file *filp);
+static void pl2303_set_termios (struct usb_serial_port *port,
+				struct termios *old);
+static int pl2303_ioctl (struct usb_serial_port *port, struct file *file,
+			 unsigned int cmd, unsigned long arg);
+static void pl2303_read_int_callback (struct urb *urb, struct pt_regs *regs);
+static void pl2303_read_bulk_callback (struct urb *urb, struct pt_regs *regs);
+static void pl2303_write_bulk_callback (struct urb *urb, struct pt_regs *regs);
+static int pl2303_write (struct usb_serial_port *port,
+			 const unsigned char *buf, int count);
+static void pl2303_send (struct usb_serial_port *port);
+static int pl2303_write_room(struct usb_serial_port *port);
+static int pl2303_chars_in_buffer(struct usb_serial_port *port);
+static void pl2303_break_ctl(struct usb_serial_port *port,int break_state);
+static int pl2303_tiocmget (struct usb_serial_port *port, struct file *file);
+static int pl2303_tiocmset (struct usb_serial_port *port, struct file *file,
+			    unsigned int set, unsigned int clear);
+static int pl2303_startup (struct usb_serial *serial);
+static void pl2303_shutdown (struct usb_serial *serial);
+static struct pl2303_buf *pl2303_buf_alloc(unsigned int size);
+static void pl2303_buf_free(struct pl2303_buf *pb);
+static void pl2303_buf_clear(struct pl2303_buf *pb);
+static unsigned int pl2303_buf_data_avail(struct pl2303_buf *pb);
+static unsigned int pl2303_buf_space_avail(struct pl2303_buf *pb);
+static unsigned int pl2303_buf_put(struct pl2303_buf *pb, const char *buf,
+	unsigned int count);
+static unsigned int pl2303_buf_get(struct pl2303_buf *pb, char *buf,
+	unsigned int count);
+
+
+/* All of the device info needed for the PL2303 SIO serial converter */
+static struct usb_serial_device_type pl2303_device = {
+	.owner =		THIS_MODULE,
+	.name =			"PL-2303",
+	.id_table =		id_table,
+	.num_interrupt_in =	NUM_DONT_CARE,
+	.num_bulk_in =		1,
+	.num_bulk_out =		1,
+	.num_ports =		1,
+	.open =			pl2303_open,
+	.close =		pl2303_close,
+	.write =		pl2303_write,
+	.ioctl =		pl2303_ioctl,
+	.break_ctl =		pl2303_break_ctl,
+	.set_termios =		pl2303_set_termios,
+	.tiocmget =		pl2303_tiocmget,
+	.tiocmset =		pl2303_tiocmset,
+	.read_bulk_callback =	pl2303_read_bulk_callback,
+	.read_int_callback =	pl2303_read_int_callback,
+	.write_bulk_callback =	pl2303_write_bulk_callback,
+	.write_room =		pl2303_write_room,
+	.chars_in_buffer =	pl2303_chars_in_buffer,
+	.attach =		pl2303_startup,
+	.shutdown =		pl2303_shutdown,
+};
+
+enum pl2303_type {
+	type_0,		/* don't know the difference between type 0 and */
+	type_1,		/* type 1, until someone from prolific tells us... */
+	HX,		/* HX version of the pl2303 chip */
+};
+
+struct pl2303_private {
+	spinlock_t lock;
+	struct pl2303_buf *buf;
+	int write_urb_in_use;
+	wait_queue_head_t delta_msr_wait;
+	u8 line_control;
+	u8 line_status;
+	u8 termios_initialized;
+	enum pl2303_type type;
+};
+
+
+static int pl2303_startup (struct usb_serial *serial)
+{
+	struct pl2303_private *priv;
+	enum pl2303_type type = type_0;
+	int i;
+
+	if (serial->dev->descriptor.bDeviceClass == 0x02)
+		type = type_0;
+	else if (serial->dev->descriptor.bMaxPacketSize0 == 0x40)
+		type = HX;
+	else if (serial->dev->descriptor.bDeviceClass == 0x00)
+		type = type_1;
+	else if (serial->dev->descriptor.bDeviceClass == 0xFF)
+		type = type_1;
+	dbg("device type: %d", type);
+
+	for (i = 0; i < serial->num_ports; ++i) {
+		priv = kmalloc (sizeof (struct pl2303_private), GFP_KERNEL);
+		if (!priv)
+			goto cleanup;
+		memset (priv, 0x00, sizeof (struct pl2303_private));
+		spin_lock_init(&priv->lock);
+		priv->buf = pl2303_buf_alloc(PL2303_BUF_SIZE);
+		if (priv->buf == NULL) {
+			kfree(priv);
+			goto cleanup;
+		}
+		init_waitqueue_head(&priv->delta_msr_wait);
+		priv->type = type;
+		usb_set_serial_port_data(serial->port[i], priv);
+	}
+	return 0;
+
+cleanup:
+	for (--i; i>=0; --i) {
+		priv = usb_get_serial_port_data(serial->port[i]);
+		pl2303_buf_free(priv->buf);
+		kfree(priv);
+		usb_set_serial_port_data(serial->port[i], NULL);
+	}
+	return -ENOMEM;
+}
+
+static int set_control_lines (struct usb_device *dev, u8 value)
+{
+	int retval;
+	
+	retval = usb_control_msg (dev, usb_sndctrlpipe (dev, 0),
+				  SET_CONTROL_REQUEST, SET_CONTROL_REQUEST_TYPE,
+				  value, 0, NULL, 0, 100);
+	dbg("%s - value = %d, retval = %d", __FUNCTION__, value, retval);
+	return retval;
+}
+
+static int pl2303_write (struct usb_serial_port *port,  const unsigned char *buf, int count)
+{
+	struct pl2303_private *priv = usb_get_serial_port_data(port);
+	unsigned long flags;
+
+	dbg("%s - port %d, %d bytes", __FUNCTION__, port->number, count);
+
+	if (!count)
+		return count;
+
+	spin_lock_irqsave(&priv->lock, flags);
+	count = pl2303_buf_put(priv->buf, buf, count);
+	spin_unlock_irqrestore(&priv->lock, flags);
+
+	pl2303_send(port);
+
+	return count;
+}
+
+static void pl2303_send(struct usb_serial_port *port)
+{
+	int count, result;
+	struct pl2303_private *priv = usb_get_serial_port_data(port);
+	unsigned long flags;
+
+	dbg("%s - port %d", __FUNCTION__, port->number);
+
+	spin_lock_irqsave(&priv->lock, flags);
+
+	if (priv->write_urb_in_use) {
+		spin_unlock_irqrestore(&priv->lock, flags);
+		return;
+	}
+
+	count = pl2303_buf_get(priv->buf, port->write_urb->transfer_buffer,
+		port->bulk_out_size);
+
+	if (count == 0) {
+		spin_unlock_irqrestore(&priv->lock, flags);
+		return;
+	}
+
+	priv->write_urb_in_use = 1;
+
+	spin_unlock_irqrestore(&priv->lock, flags);
+
+	usb_serial_debug_data(debug, &port->dev, __FUNCTION__, count, port->write_urb->transfer_buffer);
+
+	port->write_urb->transfer_buffer_length = count;
+	port->write_urb->dev = port->serial->dev;
+	result = usb_submit_urb (port->write_urb, GFP_ATOMIC);
+	if (result) {
+		dev_err(&port->dev, "%s - failed submitting write urb, error %d\n", __FUNCTION__, result);
+		priv->write_urb_in_use = 0;
+		// TODO: reschedule pl2303_send
+	}
+
+	schedule_work(&port->work);
+}
+
+static int pl2303_write_room(struct usb_serial_port *port)
+{
+	struct pl2303_private *priv = usb_get_serial_port_data(port);
+	int room = 0;
+	unsigned long flags;
+
+	dbg("%s - port %d", __FUNCTION__, port->number);
+
+	spin_lock_irqsave(&priv->lock, flags);
+	room = pl2303_buf_space_avail(priv->buf);
+	spin_unlock_irqrestore(&priv->lock, flags);
+
+	dbg("%s - returns %d", __FUNCTION__, room);
+	return room;
+}
+
+static int pl2303_chars_in_buffer(struct usb_serial_port *port)
+{
+	struct pl2303_private *priv = usb_get_serial_port_data(port);
+	int chars = 0;
+	unsigned long flags;
+
+	dbg("%s - port %d", __FUNCTION__, port->number);
+
+	spin_lock_irqsave(&priv->lock, flags);
+	chars = pl2303_buf_data_avail(priv->buf);
+	spin_unlock_irqrestore(&priv->lock, flags);
+
+	dbg("%s - returns %d", __FUNCTION__, chars);
+	return chars;
+}
+
+static void pl2303_set_termios (struct usb_serial_port *port, struct termios *old_termios)
+{
+	struct usb_serial *serial = port->serial;
+	struct pl2303_private *priv = usb_get_serial_port_data(port);
+	unsigned long flags;
+	unsigned int cflag;
+	unsigned char *buf;
+	int baud;
+	int i;
+	u8 control;
+
+	dbg("%s -  port %d", __FUNCTION__, port->number);
+
+	if ((!port->tty) || (!port->tty->termios)) {
+		dbg("%s - no tty structures", __FUNCTION__);
+		return;
+	}
+
+	spin_lock_irqsave(&priv->lock, flags);
+	if (!priv->termios_initialized) {
+		*(port->tty->termios) = tty_std_termios;
+		port->tty->termios->c_cflag = B9600 | CS8 | CREAD | HUPCL | CLOCAL;
+		priv->termios_initialized = 1;
+	}
+	spin_unlock_irqrestore(&priv->lock, flags);
+
+	cflag = port->tty->termios->c_cflag;
+	/* check that they really want us to change something */
+	if (old_termios) {
+		if ((cflag == old_termios->c_cflag) &&
+		    (RELEVANT_IFLAG(port->tty->termios->c_iflag) == RELEVANT_IFLAG(old_termios->c_iflag))) {
+		    dbg("%s - nothing to change...", __FUNCTION__);
+		    return;
+		}
+	}
+
+	buf = kmalloc (7, GFP_KERNEL);
+	if (!buf) {
+		dev_err(&port->dev, "%s - out of memory.\n", __FUNCTION__);
+		return;
+	}
+	memset (buf, 0x00, 0x07);
+	
+	i = usb_control_msg (serial->dev, usb_rcvctrlpipe (serial->dev, 0),
+			     GET_LINE_REQUEST, GET_LINE_REQUEST_TYPE,
+			     0, 0, buf, 7, 100);
+	dbg ("0xa1:0x21:0:0  %d - %x %x %x %x %x %x %x", i,
+	     buf[0], buf[1], buf[2], buf[3], buf[4], buf[5], buf[6]);
+
+
+	if (cflag & CSIZE) {
+		switch (cflag & CSIZE) {
+			case CS5:	buf[6] = 5;	break;
+			case CS6:	buf[6] = 6;	break;
+			case CS7:	buf[6] = 7;	break;
+			default:
+			case CS8:	buf[6] = 8;	break;
+		}
+		dbg("%s - data bits = %d", __FUNCTION__, buf[6]);
+	}
+
+	baud = 0;
+	switch (cflag & CBAUD) {
+		case B0:	baud = 0;	break;
+		case B75:	baud = 75;	break;
+		case B150:	baud = 150;	break;
+		case B300:	baud = 300;	break;
+		case B600:	baud = 600;	break;
+		case B1200:	baud = 1200;	break;
+		case B1800:	baud = 1800;	break;
+		case B2400:	baud = 2400;	break;
+		case B4800:	baud = 4800;	break;
+		case B9600:	baud = 9600;	break;
+		case B19200:	baud = 19200;	break;
+		case B38400:	baud = 38400;	break;
+		case B57600:	baud = 57600;	break;
+		case B115200:	baud = 115200;	break;
+		case B230400:	baud = 230400;	break;
+		case B460800:	baud = 460800;	break;
+		default:
+			dev_err(&port->dev, "pl2303 driver does not support the baudrate requested (fix it)\n");
+			break;
+	}
+	dbg("%s - baud = %d", __FUNCTION__, baud);
+	if (baud) {
+		buf[0] = baud & 0xff;
+		buf[1] = (baud >> 8) & 0xff;
+		buf[2] = (baud >> 16) & 0xff;
+		buf[3] = (baud >> 24) & 0xff;
+	}
+
+	/* For reference buf[4]=0 is 1 stop bits */
+	/* For reference buf[4]=1 is 1.5 stop bits */
+	/* For reference buf[4]=2 is 2 stop bits */
+	if (cflag & CSTOPB) {
+		buf[4] = 2;
+		dbg("%s - stop bits = 2", __FUNCTION__);
+	} else {
+		buf[4] = 0;
+		dbg("%s - stop bits = 1", __FUNCTION__);
+	}
+
+	if (cflag & PARENB) {
+		/* For reference buf[5]=0 is none parity */
+		/* For reference buf[5]=1 is odd parity */
+		/* For reference buf[5]=2 is even parity */
+		/* For reference buf[5]=3 is mark parity */
+		/* For reference buf[5]=4 is space parity */
+		if (cflag & PARODD) {
+			buf[5] = 1;
+			dbg("%s - parity = odd", __FUNCTION__);
+		} else {
+			buf[5] = 2;
+			dbg("%s - parity = even", __FUNCTION__);
+		}
+	} else {
+		buf[5] = 0;
+		dbg("%s - parity = none", __FUNCTION__);
+	}
+
+	i = usb_control_msg (serial->dev, usb_sndctrlpipe (serial->dev, 0),
+			     SET_LINE_REQUEST, SET_LINE_REQUEST_TYPE, 
+			     0, 0, buf, 7, 100);
+	dbg ("0x21:0x20:0:0  %d", i);
+
+	/* change control lines if we are switching to or from B0 */
+	spin_lock_irqsave(&priv->lock, flags);
+	control = priv->line_control;
+	if ((cflag & CBAUD) == B0)
+		priv->line_control &= ~(CONTROL_DTR | CONTROL_RTS);
+	else
+		priv->line_control |= (CONTROL_DTR | CONTROL_RTS);
+	if (control != priv->line_control) {
+		control = priv->line_control;
+		spin_unlock_irqrestore(&priv->lock, flags);
+		set_control_lines(serial->dev, control);
+	} else {
+		spin_unlock_irqrestore(&priv->lock, flags);
+	}
+	
+	buf[0] = buf[1] = buf[2] = buf[3] = buf[4] = buf[5] = buf[6] = 0;
+
+	i = usb_control_msg (serial->dev, usb_rcvctrlpipe (serial->dev, 0),
+			     GET_LINE_REQUEST, GET_LINE_REQUEST_TYPE,
+			     0, 0, buf, 7, 100);
+	dbg ("0xa1:0x21:0:0  %d - %x %x %x %x %x %x %x", i,
+	     buf[0], buf[1], buf[2], buf[3], buf[4], buf[5], buf[6]);
+
+	if (cflag & CRTSCTS) {
+		__u16 index;
+		if (priv->type == HX)
+			index = 0x61;
+		else
+			index = 0x41;
+		i = usb_control_msg(serial->dev, 
+				    usb_sndctrlpipe(serial->dev, 0),
+				    VENDOR_WRITE_REQUEST,
+				    VENDOR_WRITE_REQUEST_TYPE,
+				    0x0, index, NULL, 0, 100);
+		dbg ("0x40:0x1:0x0:0x%x  %d", index, i);
+	}
+
+	kfree (buf);
+}
+
+static int pl2303_open (struct usb_serial_port *port, struct file *filp)
+{
+	struct termios tmp_termios;
+	struct usb_serial *serial = port->serial;
+	struct pl2303_private *priv = usb_get_serial_port_data(port);
+	unsigned char *buf;
+	int result;
+
+	dbg("%s -  port %d", __FUNCTION__, port->number);
+
+	usb_clear_halt(serial->dev, port->write_urb->pipe);
+	usb_clear_halt(serial->dev, port->read_urb->pipe);
+
+	buf = kmalloc(10, GFP_KERNEL);
+	if (buf==NULL)
+		return -ENOMEM;
+
+#define FISH(a,b,c,d)								\
+	result=usb_control_msg(serial->dev, usb_rcvctrlpipe(serial->dev,0),	\
+			       b, a, c, d, buf, 1, 100);			\
+	dbg("0x%x:0x%x:0x%x:0x%x  %d - %x",a,b,c,d,result,buf[0]);
+
+#define SOUP(a,b,c,d)								\
+	result=usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev,0),	\
+			       b, a, c, d, NULL, 0, 100);			\
+	dbg("0x%x:0x%x:0x%x:0x%x  %d",a,b,c,d,result);
+
+	FISH (VENDOR_READ_REQUEST_TYPE, VENDOR_READ_REQUEST, 0x8484, 0);
+	SOUP (VENDOR_WRITE_REQUEST_TYPE, VENDOR_WRITE_REQUEST, 0x0404, 0);
+	FISH (VENDOR_READ_REQUEST_TYPE, VENDOR_READ_REQUEST, 0x8484, 0);
+	FISH (VENDOR_READ_REQUEST_TYPE, VENDOR_READ_REQUEST, 0x8383, 0);
+	FISH (VENDOR_READ_REQUEST_TYPE, VENDOR_READ_REQUEST, 0x8484, 0);
+	SOUP (VENDOR_WRITE_REQUEST_TYPE, VENDOR_WRITE_REQUEST, 0x0404, 1);
+	FISH (VENDOR_READ_REQUEST_TYPE, VENDOR_READ_REQUEST, 0x8484, 0);
+	FISH (VENDOR_READ_REQUEST_TYPE, VENDOR_READ_REQUEST, 0x8383, 0);
+	SOUP (VENDOR_WRITE_REQUEST_TYPE, VENDOR_WRITE_REQUEST, 0, 1);
+	SOUP (VENDOR_WRITE_REQUEST_TYPE, VENDOR_WRITE_REQUEST, 1, 0);
+
+	if (priv->type == HX) {
+		/* HX chip */
+		SOUP (VENDOR_WRITE_REQUEST_TYPE, VENDOR_WRITE_REQUEST, 2, 0x44);
+		/* reset upstream data pipes */
+          	SOUP (VENDOR_WRITE_REQUEST_TYPE, VENDOR_WRITE_REQUEST, 8, 0);
+        	SOUP (VENDOR_WRITE_REQUEST_TYPE, VENDOR_WRITE_REQUEST, 9, 0);
+	} else {
+		SOUP (VENDOR_WRITE_REQUEST_TYPE, VENDOR_WRITE_REQUEST, 2, 0x24);
+	}
+
+	kfree(buf);
+
+	/* Setup termios */
+	if (port->tty) {
+		pl2303_set_termios (port, &tmp_termios);
+	}
+
+	//FIXME: need to assert RTS and DTR if CRTSCTS off
+
+	dbg("%s - submitting read urb", __FUNCTION__);
+	port->read_urb->dev = serial->dev;
+	result = usb_submit_urb (port->read_urb, GFP_KERNEL);
+	if (result) {
+		dev_err(&port->dev, "%s - failed submitting read urb, error %d\n", __FUNCTION__, result);
+		pl2303_close (port, NULL);
+		return -EPROTO;
+	}
+
+	dbg("%s - submitting interrupt urb", __FUNCTION__);
+	port->interrupt_in_urb->dev = serial->dev;
+	result = usb_submit_urb (port->interrupt_in_urb, GFP_KERNEL);
+	if (result) {
+		dev_err(&port->dev, "%s - failed submitting interrupt urb, error %d\n", __FUNCTION__, result);
+		pl2303_close (port, NULL);
+		return -EPROTO;
+	}
+	return 0;
+}
+
+
+static void pl2303_close (struct usb_serial_port *port, struct file *filp)
+{
+	struct pl2303_private *priv = usb_get_serial_port_data(port);
+	unsigned long flags;
+	unsigned int c_cflag;
+	int bps;
+	long timeout;
+	wait_queue_t wait;						\
+
+	dbg("%s - port %d", __FUNCTION__, port->number);
+
+	/* wait for data to drain from the buffer */
+	spin_lock_irqsave(&priv->lock, flags);
+	timeout = PL2303_CLOSING_WAIT;
+	init_waitqueue_entry(&wait, current);
+	add_wait_queue(&port->tty->write_wait, &wait);
+	for (;;) {
+		set_current_state(TASK_INTERRUPTIBLE);
+		if (pl2303_buf_data_avail(priv->buf) == 0
+		|| timeout == 0 || signal_pending(current)
+		|| !usb_get_intfdata(port->serial->interface))	/* disconnect */
+			break;
+		spin_unlock_irqrestore(&priv->lock, flags);
+		timeout = schedule_timeout(timeout);
+		spin_lock_irqsave(&priv->lock, flags);
+	}
+	set_current_state(TASK_RUNNING);
+	remove_wait_queue(&port->tty->write_wait, &wait);
+	/* clear out any remaining data in the buffer */
+	pl2303_buf_clear(priv->buf);
+	spin_unlock_irqrestore(&priv->lock, flags);
+
+	/* wait for characters to drain from the device */
+	/* (this is long enough for the entire 256 byte */
+	/* pl2303 hardware buffer to drain with no flow */
+	/* control for data rates of 1200 bps or more, */
+	/* for lower rates we should really know how much */
+	/* data is in the buffer to compute a delay */
+	/* that is not unnecessarily long) */
+	bps = tty_get_baud_rate(port->tty);
+	if (bps > 1200)
+		timeout = max((HZ*2560)/bps,HZ/10);
+	else
+		timeout = 2*HZ;
+	set_current_state(TASK_INTERRUPTIBLE);
+	schedule_timeout(timeout);
+
+	/* shutdown our urbs */
+	dbg("%s - shutting down urbs", __FUNCTION__);
+	usb_kill_urb(port->write_urb);
+	usb_kill_urb(port->read_urb);
+	usb_kill_urb(port->interrupt_in_urb);
+
+	if (port->tty) {
+		c_cflag = port->tty->termios->c_cflag;
+		if (c_cflag & HUPCL) {
+			/* drop DTR and RTS */
+			spin_lock_irqsave(&priv->lock, flags);
+			priv->line_control = 0;
+			spin_unlock_irqrestore (&priv->lock, flags);
+			set_control_lines (port->serial->dev, 0);
+		}
+	}
+}
+
+static int pl2303_tiocmset (struct usb_serial_port *port, struct file *file,
+			    unsigned int set, unsigned int clear)
+{
+	struct pl2303_private *priv = usb_get_serial_port_data(port);
+	unsigned long flags;
+	u8 control;
+
+	spin_lock_irqsave (&priv->lock, flags);
+	if (set & TIOCM_RTS)
+		priv->line_control |= CONTROL_RTS;
+	if (set & TIOCM_DTR)
+		priv->line_control |= CONTROL_DTR;
+	if (clear & TIOCM_RTS)
+		priv->line_control &= ~CONTROL_RTS;
+	if (clear & TIOCM_DTR)
+		priv->line_control &= ~CONTROL_DTR;
+	control = priv->line_control;
+	spin_unlock_irqrestore (&priv->lock, flags);
+
+	return set_control_lines (port->serial->dev, control);
+}
+
+static int pl2303_tiocmget (struct usb_serial_port *port, struct file *file)
+{
+	struct pl2303_private *priv = usb_get_serial_port_data(port);
+	unsigned long flags;
+	unsigned int mcr;
+	unsigned int status;
+	unsigned int result;
+
+	dbg("%s (%d)", __FUNCTION__, port->number);
+
+	spin_lock_irqsave (&priv->lock, flags);
+	mcr = priv->line_control;
+	status = priv->line_status;
+	spin_unlock_irqrestore (&priv->lock, flags);
+
+	result = ((mcr & CONTROL_DTR)		? TIOCM_DTR : 0)
+		  | ((mcr & CONTROL_RTS)	? TIOCM_RTS : 0)
+		  | ((status & UART_CTS)	? TIOCM_CTS : 0)
+		  | ((status & UART_DSR)	? TIOCM_DSR : 0)
+		  | ((status & UART_RING)	? TIOCM_RI  : 0)
+		  | ((status & UART_DCD)	? TIOCM_CD  : 0);
+
+	dbg("%s - result = %x", __FUNCTION__, result);
+
+	return result;
+}
+
+static int wait_modem_info(struct usb_serial_port *port, unsigned int arg)
+{
+	struct pl2303_private *priv = usb_get_serial_port_data(port);
+	unsigned long flags;
+	unsigned int prevstatus;
+	unsigned int status;
+	unsigned int changed;
+
+	spin_lock_irqsave (&priv->lock, flags);
+	prevstatus = priv->line_status;
+	spin_unlock_irqrestore (&priv->lock, flags);
+
+	while (1) {
+		interruptible_sleep_on(&priv->delta_msr_wait);
+		/* see if a signal did it */
+		if (signal_pending(current))
+			return -ERESTARTSYS;
+		
+		spin_lock_irqsave (&priv->lock, flags);
+		status = priv->line_status;
+		spin_unlock_irqrestore (&priv->lock, flags);
+		
+		changed=prevstatus^status;
+		
+		if (((arg & TIOCM_RNG) && (changed & UART_RING)) ||
+		    ((arg & TIOCM_DSR) && (changed & UART_DSR)) ||
+		    ((arg & TIOCM_CD)  && (changed & UART_DCD)) ||
+		    ((arg & TIOCM_CTS) && (changed & UART_CTS)) ) {
+			return 0;
+		}
+		prevstatus = status;
+	}
+	/* NOTREACHED */
+	return 0;
+}
+
+static int pl2303_ioctl (struct usb_serial_port *port, struct file *file, unsigned int cmd, unsigned long arg)
+{
+	dbg("%s (%d) cmd = 0x%04x", __FUNCTION__, port->number, cmd);
+
+	switch (cmd) {
+		case TIOCMIWAIT:
+			dbg("%s (%d) TIOCMIWAIT", __FUNCTION__,  port->number);
+			return wait_modem_info(port, arg);
+
+		default:
+			dbg("%s not supported = 0x%04x", __FUNCTION__, cmd);
+			break;
+	}
+
+	return -ENOIOCTLCMD;
+}
+
+static void pl2303_break_ctl (struct usb_serial_port *port, int break_state)
+{
+	struct usb_serial *serial = port->serial;
+	u16 state;
+	int result;
+
+	dbg("%s - port %d", __FUNCTION__, port->number);
+
+	if (break_state == 0)
+		state = BREAK_OFF;
+	else
+		state = BREAK_ON;
+	dbg("%s - turning break %s", __FUNCTION__, state==BREAK_OFF ? "off" : "on");
+
+	result = usb_control_msg (serial->dev, usb_sndctrlpipe (serial->dev, 0),
+				  BREAK_REQUEST, BREAK_REQUEST_TYPE, state, 
+				  0, NULL, 0, 100);
+	if (result)
+		dbg("%s - error sending break = %d", __FUNCTION__, result);
+}
+
+
+static void pl2303_shutdown (struct usb_serial *serial)
+{
+	int i;
+	struct pl2303_private *priv;
+
+	dbg("%s", __FUNCTION__);
+
+	for (i = 0; i < serial->num_ports; ++i) {
+		priv = usb_get_serial_port_data(serial->port[i]);
+		if (priv) {
+			pl2303_buf_free(priv->buf);
+			kfree(priv);
+			usb_set_serial_port_data(serial->port[i], NULL);
+		}
+	}		
+}
+
+
+static void pl2303_read_int_callback (struct urb *urb, struct pt_regs *regs)
+{
+	struct usb_serial_port *port = (struct usb_serial_port *) urb->context;
+	struct pl2303_private *priv = usb_get_serial_port_data(port);
+	unsigned char *data = urb->transfer_buffer;
+	unsigned long flags;
+	int status;
+	u8 uart_state;
+
+	dbg("%s (%d)", __FUNCTION__, port->number);
+
+	switch (urb->status) {
+	case 0:
+		/* success */
+		break;
+	case -ECONNRESET:
+	case -ENOENT:
+	case -ESHUTDOWN:
+		/* this urb is terminated, clean up */
+		dbg("%s - urb shutting down with status: %d", __FUNCTION__, urb->status);
+		return;
+	default:
+		dbg("%s - nonzero urb status received: %d", __FUNCTION__, urb->status);
+		goto exit;
+	}
+
+
+	usb_serial_debug_data(debug, &port->dev, __FUNCTION__, urb->actual_length, urb->transfer_buffer);
+
+	if (urb->actual_length < UART_STATE)
+		goto exit;
+
+	/* Save off the uart status for others to look at */
+	uart_state = data[UART_STATE];
+	spin_lock_irqsave(&priv->lock, flags);
+	uart_state |= (priv->line_status & UART_STATE_TRANSIENT_MASK);
+	priv->line_status = uart_state;
+	spin_unlock_irqrestore(&priv->lock, flags);
+		
+exit:
+	status = usb_submit_urb (urb, GFP_ATOMIC);
+	if (status)
+		dev_err(&urb->dev->dev, "%s - usb_submit_urb failed with result %d\n",
+			__FUNCTION__, status);
+}
+
+
+static void pl2303_read_bulk_callback (struct urb *urb, struct pt_regs *regs)
+{
+	struct usb_serial_port *port = (struct usb_serial_port *) urb->context;
+	struct pl2303_private *priv = usb_get_serial_port_data(port);
+	struct tty_struct *tty;
+	unsigned char *data = urb->transfer_buffer;
+	unsigned long flags;
+	int i;
+	int result;
+	u8 status;
+	char tty_flag;
+
+	dbg("%s - port %d", __FUNCTION__, port->number);
+
+	if (urb->status) {
+		dbg("%s - urb->status = %d", __FUNCTION__, urb->status);
+		if (!port->open_count) {
+			dbg("%s - port is closed, exiting.", __FUNCTION__);
+			return;
+		}
+		if (urb->status == -EPROTO) {
+			/* PL2303 mysteriously fails with -EPROTO reschedule the read */
+			dbg("%s - caught -EPROTO, resubmitting the urb", __FUNCTION__);
+			urb->status = 0;
+			urb->dev = port->serial->dev;
+			result = usb_submit_urb(urb, GFP_ATOMIC);
+			if (result)
+				dev_err(&urb->dev->dev, "%s - failed resubmitting read urb, error %d\n", __FUNCTION__, result);
+			return;
+		}
+		dbg("%s - unable to handle the error, exiting.", __FUNCTION__);
+		return;
+	}
+
+	usb_serial_debug_data(debug, &port->dev, __FUNCTION__, urb->actual_length, data);
+
+	/* get tty_flag from status */
+	tty_flag = TTY_NORMAL;
+
+	spin_lock_irqsave(&priv->lock, flags);
+	status = priv->line_status;
+	priv->line_status &= ~UART_STATE_TRANSIENT_MASK;
+	spin_unlock_irqrestore(&priv->lock, flags);
+	wake_up_interruptible (&priv->delta_msr_wait);
+
+	/* break takes precedence over parity, */
+	/* which takes precedence over framing errors */
+	if (status & UART_BREAK_ERROR )
+		tty_flag = TTY_BREAK;
+	else if (status & UART_PARITY_ERROR)
+		tty_flag = TTY_PARITY;
+	else if (status & UART_FRAME_ERROR)
+		tty_flag = TTY_FRAME;
+	dbg("%s - tty_flag = %d", __FUNCTION__, tty_flag);
+
+	tty = port->tty;
+	if (tty && urb->actual_length) {
+		/* overrun is special, not associated with a char */
+		if (status & UART_OVERRUN_ERROR)
+			tty_insert_flip_char(tty, 0, TTY_OVERRUN);
+
+		for (i = 0; i < urb->actual_length; ++i) {
+			if (tty->flip.count >= TTY_FLIPBUF_SIZE) {
+				tty_flip_buffer_push(tty);
+			}
+			tty_insert_flip_char (tty, data[i], tty_flag);
+		}
+		tty_flip_buffer_push (tty);
+	}
+
+	/* Schedule the next read _if_ we are still open */
+	if (port->open_count) {
+		urb->dev = port->serial->dev;
+		result = usb_submit_urb(urb, GFP_ATOMIC);
+		if (result)
+			dev_err(&urb->dev->dev, "%s - failed resubmitting read urb, error %d\n", __FUNCTION__, result);
+	}
+
+	return;
+}
+
+
+
+static void pl2303_write_bulk_callback (struct urb *urb, struct pt_regs *regs)
+{
+	struct usb_serial_port *port = (struct usb_serial_port *) urb->context;
+	struct pl2303_private *priv = usb_get_serial_port_data(port);
+	int result;
+
+	dbg("%s - port %d", __FUNCTION__, port->number);
+
+	switch (urb->status) {
+	case 0:
+		/* success */
+		break;
+	case -ECONNRESET:
+	case -ENOENT:
+	case -ESHUTDOWN:
+		/* this urb is terminated, clean up */
+		dbg("%s - urb shutting down with status: %d", __FUNCTION__, urb->status);
+		priv->write_urb_in_use = 0;
+		return;
+	default:
+		/* error in the urb, so we have to resubmit it */
+		dbg("%s - Overflow in write", __FUNCTION__);
+		dbg("%s - nonzero write bulk status received: %d", __FUNCTION__, urb->status);
+		port->write_urb->transfer_buffer_length = 1;
+		port->write_urb->dev = port->serial->dev;
+		result = usb_submit_urb (port->write_urb, GFP_ATOMIC);
+		if (result)
+			dev_err(&urb->dev->dev, "%s - failed resubmitting write urb, error %d\n", __FUNCTION__, result);
+		else
+			return;
+	}
+
+	priv->write_urb_in_use = 0;
+
+	/* send any buffered data */
+	pl2303_send(port);
+}
+
+
+/*
+ * pl2303_buf_alloc
+ *
+ * Allocate a circular buffer and all associated memory.
+ */
+
+static struct pl2303_buf *pl2303_buf_alloc(unsigned int size)
+{
+
+	struct pl2303_buf *pb;
+
+
+	if (size == 0)
+		return NULL;
+
+	pb = (struct pl2303_buf *)kmalloc(sizeof(struct pl2303_buf), GFP_KERNEL);
+	if (pb == NULL)
+		return NULL;
+
+	pb->buf_buf = kmalloc(size, GFP_KERNEL);
+	if (pb->buf_buf == NULL) {
+		kfree(pb);
+		return NULL;
+	}
+
+	pb->buf_size = size;
+	pb->buf_get = pb->buf_put = pb->buf_buf;
+
+	return pb;
+
+}
+
+
+/*
+ * pl2303_buf_free
+ *
+ * Free the buffer and all associated memory.
+ */
+
+static void pl2303_buf_free(struct pl2303_buf *pb)
+{
+	if (pb != NULL) {
+		if (pb->buf_buf != NULL)
+			kfree(pb->buf_buf);
+		kfree(pb);
+	}
+}
+
+
+/*
+ * pl2303_buf_clear
+ *
+ * Clear out all data in the circular buffer.
+ */
+
+static void pl2303_buf_clear(struct pl2303_buf *pb)
+{
+	if (pb != NULL)
+		pb->buf_get = pb->buf_put;
+		/* equivalent to a get of all data available */
+}
+
+
+/*
+ * pl2303_buf_data_avail
+ *
+ * Return the number of bytes of data available in the circular
+ * buffer.
+ */
+
+static unsigned int pl2303_buf_data_avail(struct pl2303_buf *pb)
+{
+	if (pb != NULL)
+		return ((pb->buf_size + pb->buf_put - pb->buf_get) % pb->buf_size);
+	else
+		return 0;
+}
+
+
+/*
+ * pl2303_buf_space_avail
+ *
+ * Return the number of bytes of space available in the circular
+ * buffer.
+ */
+
+static unsigned int pl2303_buf_space_avail(struct pl2303_buf *pb)
+{
+	if (pb != NULL)
+		return ((pb->buf_size + pb->buf_get - pb->buf_put - 1) % pb->buf_size);
+	else
+		return 0;
+}
+
+
+/*
+ * pl2303_buf_put
+ *
+ * Copy data data from a user buffer and put it into the circular buffer.
+ * Restrict to the amount of space available.
+ *
+ * Return the number of bytes copied.
+ */
+
+static unsigned int pl2303_buf_put(struct pl2303_buf *pb, const char *buf,
+	unsigned int count)
+{
+
+	unsigned int len;
+
+
+	if (pb == NULL)
+		return 0;
+
+	len  = pl2303_buf_space_avail(pb);
+	if (count > len)
+		count = len;
+
+	if (count == 0)
+		return 0;
+
+	len = pb->buf_buf + pb->buf_size - pb->buf_put;
+	if (count > len) {
+		memcpy(pb->buf_put, buf, len);
+		memcpy(pb->buf_buf, buf+len, count - len);
+		pb->buf_put = pb->buf_buf + count - len;
+	} else {
+		memcpy(pb->buf_put, buf, count);
+		if (count < len)
+			pb->buf_put += count;
+		else /* count == len */
+			pb->buf_put = pb->buf_buf;
+	}
+
+	return count;
+
+}
+
+
+/*
+ * pl2303_buf_get
+ *
+ * Get data from the circular buffer and copy to the given buffer.
+ * Restrict to the amount of data available.
+ *
+ * Return the number of bytes copied.
+ */
+
+static unsigned int pl2303_buf_get(struct pl2303_buf *pb, char *buf,
+	unsigned int count)
+{
+
+	unsigned int len;
+
+
+	if (pb == NULL)
+		return 0;
+
+	len = pl2303_buf_data_avail(pb);
+	if (count > len)
+		count = len;
+
+	if (count == 0)
+		return 0;
+
+	len = pb->buf_buf + pb->buf_size - pb->buf_get;
+	if (count > len) {
+		memcpy(buf, pb->buf_get, len);
+		memcpy(buf+len, pb->buf_buf, count - len);
+		pb->buf_get = pb->buf_buf + count - len;
+	} else {
+		memcpy(buf, pb->buf_get, count);
+		if (count < len)
+			pb->buf_get += count;
+		else /* count == len */
+			pb->buf_get = pb->buf_buf;
+	}
+
+	return count;
+
+}
+
+static int __init pl2303_init (void)
+{
+	int retval;
+	retval = usb_serial_register(&pl2303_device);
+	if (retval)
+		goto failed_usb_serial_register;
+	retval = usb_register(&pl2303_driver);
+	if (retval)
+		goto failed_usb_register;
+	info(DRIVER_DESC " " DRIVER_VERSION);
+	return 0;
+failed_usb_register:
+	usb_serial_deregister(&pl2303_device);
+failed_usb_serial_register:
+	return retval;
+}
+
+
+static void __exit pl2303_exit (void)
+{
+	usb_deregister (&pl2303_driver);
+	usb_serial_deregister (&pl2303_device);
+}
+
+
+module_init(pl2303_init);
+module_exit(pl2303_exit);
+
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_VERSION(DRIVER_VERSION);
+MODULE_LICENSE("GPL");
+
+module_param(debug, bool, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(debug, "Debug enabled or not");
+
