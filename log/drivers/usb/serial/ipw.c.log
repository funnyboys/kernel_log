commit 6ca98bc2843e0bc4c2745ff6be7d46694c1398d1
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Nov 3 12:40:56 2017 +0100

    USB: serial: Remove redundant license text
    
    Now that the SPDX tag is in all USB files, that identifies the license
    in a specific and legally-defined manner.  So the extra GPL text wording
    can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/ipw.c b/drivers/usb/serial/ipw.c
index 4a534e8037d5..d04c7cc5c1c2 100644
--- a/drivers/usb/serial/ipw.c
+++ b/drivers/usb/serial/ipw.c
@@ -5,11 +5,6 @@
  *   Copyright (C) 2004 Roelf Diedericks <roelfd@inet.co.za>
  *   Copyright (C) 2004 Greg Kroah-Hartman <greg@kroah.com>
  *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; either version 2 of the License, or
- *   (at your option) any later version.
- *
  * All information about the device was acquired using SnoopyPro
  * on MSFT's O/S, and examing the MSFT drivers' debug output
  * (insanely left _on_ in the enduser version)

commit 5fd54ace4721fc5ce2bb5aef6318fcf17f421460
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Nov 3 11:28:30 2017 +0100

    USB: add SPDX identifiers to all remaining files in drivers/usb/
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/usb/ and include/linux/usb* files with the correct
    SPDX license identifier based on the license text in the file itself.
    The SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Acked-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/ipw.c b/drivers/usb/serial/ipw.c
index 8b1cf18a668b..4a534e8037d5 100644
--- a/drivers/usb/serial/ipw.c
+++ b/drivers/usb/serial/ipw.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  * IPWireless 3G UMTS TDD Modem driver (USB connected)
  *

commit 803a536243b3a1ed2289f41897b11b72bd083309
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Wed Jan 8 11:08:26 2014 -0500

    usb: delete non-required instances of include <linux/init.h>
    
    None of these files are actually using any __init type directives
    and hence don't need to include <linux/init.h>.  Most are just a
    left over from __devinit and __cpuinit removal, or simply due to
    code getting copied from one driver to the next.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/ipw.c b/drivers/usb/serial/ipw.c
index 155eab14b30e..8b1cf18a668b 100644
--- a/drivers/usb/serial/ipw.c
+++ b/drivers/usb/serial/ipw.c
@@ -38,7 +38,6 @@
 
 #include <linux/kernel.h>
 #include <linux/errno.h>
-#include <linux/init.h>
 #include <linux/slab.h>
 #include <linux/tty.h>
 #include <linux/tty_flip.h>

commit bcbec053d2197031d04b8e040c61695b5d7a949d
Author: Johan Hovold <jhovold@gmail.com>
Date:   Wed Oct 31 11:59:52 2012 +0100

    USB: serial: remove driver version information
    
    Remove all MODULE_VERSION macros and driver-version information (except
    for garmin_gps which uses it in a status reply).
    
    It is the kernel version that matters and not some private version
    scheme which rarely even gets updated.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/ipw.c b/drivers/usb/serial/ipw.c
index 4264821a3b34..155eab14b30e 100644
--- a/drivers/usb/serial/ipw.c
+++ b/drivers/usb/serial/ipw.c
@@ -49,10 +49,6 @@
 #include <linux/uaccess.h>
 #include "usb-wwan.h"
 
-/*
- * Version Information
- */
-#define DRIVER_VERSION	"v0.4"
 #define DRIVER_AUTHOR	"Roelf Diedericks"
 #define DRIVER_DESC	"IPWireless tty driver"
 

commit a997448c89905b80aa4022f734f03685e733d711
Author: Johan Hovold <jhovold@gmail.com>
Date:   Thu Oct 25 15:42:39 2012 +0200

    USB: ipw: fix interface-data memory leak in error path
    
    Move interface data allocation to attach so that it is deallocated
    should usb-serial probe fail.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/ipw.c b/drivers/usb/serial/ipw.c
index add45b7d8aa7..4264821a3b34 100644
--- a/drivers/usb/serial/ipw.c
+++ b/drivers/usb/serial/ipw.c
@@ -203,8 +203,7 @@ static int ipw_open(struct tty_struct *tty, struct usb_serial_port *port)
 	return 0;
 }
 
-/* fake probe - only to allocate data structures */
-static int ipw_probe(struct usb_serial *serial, const struct usb_device_id *id)
+static int ipw_attach(struct usb_serial *serial)
 {
 	struct usb_wwan_intf_private *data;
 
@@ -303,7 +302,7 @@ static struct usb_serial_driver ipw_device = {
 	.num_ports =		1,
 	.open =			ipw_open,
 	.close =		ipw_close,
-	.probe =		ipw_probe,
+	.attach =		ipw_attach,
 	.release =		ipw_release,
 	.port_probe =		usb_wwan_port_probe,
 	.port_remove =		usb_wwan_port_remove,

commit b8f0e82044c9ba40e92340c8a6d47d6bd6d819bc
Author: Johan Hovold <jhovold@gmail.com>
Date:   Thu Oct 25 10:29:16 2012 +0200

    USB: usb-wwan: fix multiple memory leaks in error paths
    
    Fix port-data memory leak in usb-serial probe error path by moving port
    data allocation to port_probe.
    
    Since commit a1028f0abf ("usb: usb_wwan: replace release and disconnect
    with a port_remove hook") port data is deallocated in port_remove. This
    leaves a possibility for memory leaks if usb-serial probe fails after
    attach but before the port in question has been successfully registered.
    
    Note that this patch also fixes two additional memory leaks in the error
    path of attach should port initialisation fail for any port as the urbs
    were never freed and neither was the data of any of the successfully
    initialised ports.
    
    Compile-only tested.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/ipw.c b/drivers/usb/serial/ipw.c
index 20a132ec39e2..add45b7d8aa7 100644
--- a/drivers/usb/serial/ipw.c
+++ b/drivers/usb/serial/ipw.c
@@ -304,8 +304,8 @@ static struct usb_serial_driver ipw_device = {
 	.open =			ipw_open,
 	.close =		ipw_close,
 	.probe =		ipw_probe,
-	.attach =		usb_wwan_startup,
 	.release =		ipw_release,
+	.port_probe =		usb_wwan_port_probe,
 	.port_remove =		usb_wwan_port_remove,
 	.dtr_rts =		ipw_dtr_rts,
 	.write =		usb_wwan_write,

commit f3004d54027d1c440f1e45ec3aa7caba6cca6f1a
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Sep 14 12:31:32 2012 -0700

    USB: serial: ipw.c: remove debug module parameter
    
    Now that the dbg() macro is no longer being used in the driver,
    the debug module parameter doesn't do anything at all.  So remove
    it so as to not confuse people.
    
    CC: Rusty Russell <rusty@rustcorp.com.au>
    CC: Alan Stern <stern@rowland.harvard.edu>
    CC: Mauro Carvalho Chehab <mchehab@redhat.com>
    CC: "Bjørn Mork" <bjorn@mork.no>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/ipw.c b/drivers/usb/serial/ipw.c
index fbd54a1bab30..20a132ec39e2 100644
--- a/drivers/usb/serial/ipw.c
+++ b/drivers/usb/serial/ipw.c
@@ -138,8 +138,6 @@ static const struct usb_device_id id_table[] = {
 };
 MODULE_DEVICE_TABLE(usb, id_table);
 
-static bool debug;
-
 static int ipw_open(struct tty_struct *tty, struct usb_serial_port *port)
 {
 	struct usb_device *udev = port->serial->dev;
@@ -323,6 +321,3 @@ module_usb_serial_driver(serial_drivers, id_table);
 MODULE_AUTHOR(DRIVER_AUTHOR);
 MODULE_DESCRIPTION(DRIVER_DESC);
 MODULE_LICENSE("GPL");
-
-module_param(debug, bool, S_IRUGO | S_IWUSR);
-MODULE_PARM_DESC(debug, "Debug enabled or not");

commit 592ba39fab1072d6d37f4118f4b0efa15377ced5
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu Sep 13 17:18:16 2012 -0700

    USB: serial: ipw.c: remove dbg() usage
    
    dbg() was a very old USB-serial-specific macro.
    This patch removes it from being used in the
    driver and uses dev_dbg() instead.
    
    CC: Rusty Russell <rusty@rustcorp.com.au>
    CC: Alan Stern <stern@rowland.harvard.edu>
    CC: Mauro Carvalho Chehab <mchehab@redhat.com>
    CC: "Bjørn Mork" <bjorn@mork.no>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/ipw.c b/drivers/usb/serial/ipw.c
index 2cb30c535839..fbd54a1bab30 100644
--- a/drivers/usb/serial/ipw.c
+++ b/drivers/usb/serial/ipw.c
@@ -142,7 +142,8 @@ static bool debug;
 
 static int ipw_open(struct tty_struct *tty, struct usb_serial_port *port)
 {
-	struct usb_device *dev = port->serial->dev;
+	struct usb_device *udev = port->serial->dev;
+	struct device *dev = &port->dev;
 	u8 buf_flow_static[16] = IPW_BYTES_FLOWINIT;
 	u8 *buf_flow_init;
 	int result;
@@ -154,8 +155,8 @@ static int ipw_open(struct tty_struct *tty, struct usb_serial_port *port)
 	/* --1: Tell the modem to initialize (we think) From sniffs this is
 	 *	always the first thing that gets sent to the modem during
 	 *	opening of the device */
-	dbg("%s: Sending SIO_INIT (we guess)", __func__);
-	result = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
+	dev_dbg(dev, "%s: Sending SIO_INIT (we guess)\n", __func__);
+	result = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
 			 IPW_SIO_INIT,
 			 USB_TYPE_VENDOR | USB_RECIP_INTERFACE | USB_DIR_OUT,
 			 0,
@@ -164,22 +165,19 @@ static int ipw_open(struct tty_struct *tty, struct usb_serial_port *port)
 			 0,
 			 100000);
 	if (result < 0)
-		dev_err(&port->dev,
-			"Init of modem failed (error = %d)\n", result);
+		dev_err(dev, "Init of modem failed (error = %d)\n", result);
 
 	/* reset the bulk pipes */
-	usb_clear_halt(dev,
-			usb_rcvbulkpipe(dev, port->bulk_in_endpointAddress));
-	usb_clear_halt(dev,
-			usb_sndbulkpipe(dev, port->bulk_out_endpointAddress));
+	usb_clear_halt(udev, usb_rcvbulkpipe(udev, port->bulk_in_endpointAddress));
+	usb_clear_halt(udev, usb_sndbulkpipe(udev, port->bulk_out_endpointAddress));
 
 	/*--2: Start reading from the device */
-	dbg("%s: setting up bulk read callback", __func__);
+	dev_dbg(dev, "%s: setting up bulk read callback\n", __func__);
 	usb_wwan_open(tty, port);
 
 	/*--3: Tell the modem to open the floodgates on the rx bulk channel */
-	dbg("%s:asking modem for RxRead (RXBULK_ON)", __func__);
-	result = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
+	dev_dbg(dev, "%s:asking modem for RxRead (RXBULK_ON)\n", __func__);
+	result = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
 			 IPW_SIO_RXCTL,
 			 USB_TYPE_VENDOR | USB_RECIP_INTERFACE | USB_DIR_OUT,
 			 IPW_RXBULK_ON,
@@ -188,12 +186,11 @@ static int ipw_open(struct tty_struct *tty, struct usb_serial_port *port)
 			 0,
 			 100000);
 	if (result < 0)
-		dev_err(&port->dev,
-			"Enabling bulk RxRead failed (error = %d)\n", result);
+		dev_err(dev, "Enabling bulk RxRead failed (error = %d)\n", result);
 
 	/*--4: setup the initial flowcontrol */
-	dbg("%s:setting init flowcontrol (%s)", __func__, buf_flow_init);
-	result = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
+	dev_dbg(dev, "%s:setting init flowcontrol (%s)\n", __func__, buf_flow_init);
+	result = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
 			 IPW_SIO_HANDFLOW,
 			 USB_TYPE_VENDOR | USB_RECIP_INTERFACE | USB_DIR_OUT,
 			 0,
@@ -202,8 +199,7 @@ static int ipw_open(struct tty_struct *tty, struct usb_serial_port *port)
 			 0x10,
 			 200000);
 	if (result < 0)
-		dev_err(&port->dev,
-			"initial flowcontrol failed (error = %d)\n", result);
+		dev_err(dev, "initial flowcontrol failed (error = %d)\n", result);
 
 	kfree(buf_flow_init);
 	return 0;
@@ -233,12 +229,13 @@ static void ipw_release(struct usb_serial *serial)
 
 static void ipw_dtr_rts(struct usb_serial_port *port, int on)
 {
-	struct usb_device *dev = port->serial->dev;
+	struct usb_device *udev = port->serial->dev;
+	struct device *dev = &port->dev;
 	int result;
 
-	dbg("%s: on = %d", __func__, on);
+	dev_dbg(dev, "%s: on = %d\n", __func__, on);
 
-	result = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
+	result = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
 			 IPW_SIO_SET_PIN,
 			 USB_TYPE_VENDOR | USB_RECIP_INTERFACE | USB_DIR_OUT,
 			 on ? IPW_PIN_SETDTR : IPW_PIN_CLRDTR,
@@ -247,10 +244,9 @@ static void ipw_dtr_rts(struct usb_serial_port *port, int on)
 			 0,
 			 200000);
 	if (result < 0)
-		dev_err(&port->dev, "setting dtr failed (error = %d)\n",
-								result);
+		dev_err(dev, "setting dtr failed (error = %d)\n", result);
 
-	result = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
+	result = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
 			 IPW_SIO_SET_PIN, USB_TYPE_VENDOR |
 					USB_RECIP_INTERFACE | USB_DIR_OUT,
 			 on ? IPW_PIN_SETRTS : IPW_PIN_CLRRTS,
@@ -259,18 +255,18 @@ static void ipw_dtr_rts(struct usb_serial_port *port, int on)
 			 0,
 			 200000);
 	if (result < 0)
-		dev_err(&port->dev, "setting rts failed (error = %d)\n",
-								result);
+		dev_err(dev, "setting rts failed (error = %d)\n", result);
 }
 
 static void ipw_close(struct usb_serial_port *port)
 {
-	struct usb_device *dev = port->serial->dev;
+	struct usb_device *udev = port->serial->dev;
+	struct device *dev = &port->dev;
 	int result;
 
 	/*--3: purge */
-	dbg("%s:sending purge", __func__);
-	result = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
+	dev_dbg(dev, "%s:sending purge\n", __func__);
+	result = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
 			 IPW_SIO_PURGE, USB_TYPE_VENDOR |
 			 		USB_RECIP_INTERFACE | USB_DIR_OUT,
 			 0x03,
@@ -279,12 +275,12 @@ static void ipw_close(struct usb_serial_port *port)
 			 0,
 			 200000);
 	if (result < 0)
-		dev_err(&port->dev, "purge failed (error = %d)\n", result);
+		dev_err(dev, "purge failed (error = %d)\n", result);
 
 
 	/* send RXBULK_off (tell modem to stop transmitting bulk data on
 	   rx chan) */
-	result = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
+	result = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
 			 IPW_SIO_RXCTL,
 			 USB_TYPE_VENDOR | USB_RECIP_INTERFACE | USB_DIR_OUT,
 			 IPW_RXBULK_OFF,
@@ -294,8 +290,7 @@ static void ipw_close(struct usb_serial_port *port)
 			 100000);
 
 	if (result < 0)
-		dev_err(&port->dev,
-			"Disabling bulk RxRead failed (error = %d)\n", result);
+		dev_err(dev, "Disabling bulk RxRead failed (error = %d)\n", result);
 
 	usb_wwan_close(port);
 }

commit a1028f0abfb321e0f87c10ac0cce8508097c2b42
Author: Bjørn Mork <bjorn@mork.no>
Date:   Fri Jul 27 01:11:41 2012 +0200

    usb: usb_wwan: replace release and disconnect with a port_remove hook
    
    Doing port specific cleanup in the .port_remove hook is a
    lot simpler and safer than doing it in the USB driver
    .release or .disconnect methods. The removal of the port
    from the usb-serial bus will happen before the USB driver
    cleanup, so we must be careful about accessing port specific
    driver data from any USB driver functions.
    
    This problem surfaced after the commit
    
     0998d0631 device-core: Ensure drvdata = NULL when no driver is bound
    
    which turned the previous unsafe access into a reliable NULL
    pointer dereference.
    
    Fixes the following Oops:
    
    [  243.148471] BUG: unable to handle kernel NULL pointer dereference at           (null)
    [  243.148508] IP: [<ffffffffa0468527>] stop_read_write_urbs+0x37/0x80 [usb_wwan]
    [  243.148556] PGD 79d60067 PUD 79d61067 PMD 0
    [  243.148590] Oops: 0000 [#1] SMP
    [  243.148617] Modules linked in: sr_mod cdrom qmi_wwan usbnet option cdc_wdm usb_wwan usbserial usb_storage uas fuse af_packet ip6table_filter ip6_tables iptable_filter ip_tables x_tables tun edd
    cpufreq_conservative cpufreq_userspace cpufreq_powersave snd_pcm_oss snd_mixer_oss acpi_cpufreq snd_seq mperf snd_seq_device coretemp arc4 sg hp_wmi sparse_keymap uvcvideo videobuf2_core
    videodev videobuf2_vmalloc videobuf2_memops rtl8192ce rtl8192c_common rtlwifi joydev pcspkr microcode mac80211 i2c_i801 lpc_ich r8169 snd_hda_codec_idt cfg80211 snd_hda_intel snd_hda_codec rfkill
    snd_hwdep snd_pcm wmi snd_timer ac snd soundcore snd_page_alloc battery uhci_hcd i915 drm_kms_helper drm i2c_algo_bit ehci_hcd thermal usbcore video usb_common button processor thermal_sys
    [  243.149007] CPU 1
    [  243.149027] Pid: 135, comm: khubd Not tainted 3.5.0-rc7-next-20120720-1-vanilla #1 Hewlett-Packard HP Mini 110-3700                /1584
    [  243.149072] RIP: 0010:[<ffffffffa0468527>]  [<ffffffffa0468527>] stop_read_write_urbs+0x37/0x80 [usb_wwan]
    [  243.149118] RSP: 0018:ffff880037e75b30  EFLAGS: 00010286
    [  243.149133] RAX: 0000000000000000 RBX: 0000000000000000 RCX: ffff88005912aa28
    [  243.149150] RDX: ffff88005e95f028 RSI: 0000000000000000 RDI: ffff88005f7c1a10
    [  243.149166] RBP: ffff880037e75b60 R08: 0000000000000000 R09: ffffffff812cea90
    [  243.149182] R10: 0000000000000000 R11: 0000000000000001 R12: ffff88006539b440
    [  243.149198] R13: ffff88006539b440 R14: 0000000000000000 R15: 0000000000000000
    [  243.149216] FS:  0000000000000000(0000) GS:ffff88007ee80000(0000) knlGS:0000000000000000
    [  243.149233] CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b
    [  243.149248] CR2: 0000000000000000 CR3: 0000000079fe0000 CR4: 00000000000007e0
    [  243.149264] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
    [  243.149280] DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400
    [  243.149298] Process khubd (pid: 135, threadinfo ffff880037e74000, task ffff880037d40600)
    [  243.149313] Stack:
    [  243.149323]  ffff880037e75b40 ffff88006539b440 ffff8800799bc830 ffff88005f7c1800
    [  243.149348]  0000000000000001 ffff88006539b448 ffff880037e75b70 ffffffffa04685e9
    [  243.149371]  ffff880037e75bc0 ffffffffa0473765 ffff880037354988 ffff88007b594800
    [  243.149395] Call Trace:
    [  243.149419]  [<ffffffffa04685e9>] usb_wwan_disconnect+0x9/0x10 [usb_wwan]
    [  243.149447]  [<ffffffffa0473765>] usb_serial_disconnect+0xd5/0x120 [usbserial]
    [  243.149511]  [<ffffffffa0046b48>] usb_unbind_interface+0x58/0x1a0 [usbcore]
    [  243.149545]  [<ffffffff8139ebd7>] __device_release_driver+0x77/0xe0
    [  243.149567]  [<ffffffff8139ec67>] device_release_driver+0x27/0x40
    [  243.149587]  [<ffffffff8139e5cf>] bus_remove_device+0xdf/0x150
    [  243.149608]  [<ffffffff8139bc78>] device_del+0x118/0x1a0
    [  243.149661]  [<ffffffffa0044590>] usb_disable_device+0xb0/0x280 [usbcore]
    [  243.149718]  [<ffffffffa003c6fd>] usb_disconnect+0x9d/0x140 [usbcore]
    [  243.149770]  [<ffffffffa003da7d>] hub_port_connect_change+0xad/0x8a0 [usbcore]
    [  243.149825]  [<ffffffffa0043bf5>] ? usb_control_msg+0xe5/0x110 [usbcore]
    [  243.149878]  [<ffffffffa003e6e3>] hub_events+0x473/0x760 [usbcore]
    [  243.149931]  [<ffffffffa003ea05>] hub_thread+0x35/0x1d0 [usbcore]
    [  243.149955]  [<ffffffff81061960>] ? add_wait_queue+0x60/0x60
    [  243.150004]  [<ffffffffa003e9d0>] ? hub_events+0x760/0x760 [usbcore]
    [  243.150026]  [<ffffffff8106133e>] kthread+0x8e/0xa0
    [  243.150047]  [<ffffffff8157ec04>] kernel_thread_helper+0x4/0x10
    [  243.150068]  [<ffffffff810612b0>] ? flush_kthread_work+0x120/0x120
    [  243.150088]  [<ffffffff8157ec00>] ? gs_change+0xb/0xb
    [  243.150101] Code: fd 41 54 53 48 83 ec 08 80 7f 1a 00 74 57 49 89 fc 31 db 90 49 8b 7c 24 20 45 31 f6 48 81 c7 10 02 00 00 e8 bc 64 f3 e0 49 89 c7 <4b> 8b 3c 37 49 83 c6 08 e8 4c a5 bd ff 49 83 fe 20
    75 ed 45 30
    [  243.150257] RIP  [<ffffffffa0468527>] stop_read_write_urbs+0x37/0x80 [usb_wwan]
    [  243.150282]  RSP <ffff880037e75b30>
    [  243.150294] CR2: 0000000000000000
    [  243.177170] ---[ end trace fba433d9015ffb8c ]---
    
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reported-by: Thomas Schäfer <tschaefer@t-online.de>
    Suggested-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Bjørn Mork <bjorn@mork.no>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/ipw.c b/drivers/usb/serial/ipw.c
index 5811d34b6c6b..2cb30c535839 100644
--- a/drivers/usb/serial/ipw.c
+++ b/drivers/usb/serial/ipw.c
@@ -227,7 +227,6 @@ static void ipw_release(struct usb_serial *serial)
 {
 	struct usb_wwan_intf_private *data = usb_get_serial_data(serial);
 
-	usb_wwan_release(serial);
 	usb_set_serial_data(serial, NULL);
 	kfree(data);
 }
@@ -309,12 +308,12 @@ static struct usb_serial_driver ipw_device = {
 	.description =		"IPWireless converter",
 	.id_table =		id_table,
 	.num_ports =		1,
-	.disconnect =		usb_wwan_disconnect,
 	.open =			ipw_open,
 	.close =		ipw_close,
 	.probe =		ipw_probe,
 	.attach =		usb_wwan_startup,
 	.release =		ipw_release,
+	.port_remove =		usb_wwan_port_remove,
 	.dtr_rts =		ipw_dtr_rts,
 	.write =		usb_wwan_write,
 };

commit 68e24113457e437b1576670f2419b77ed0531e9e
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue May 8 15:46:14 2012 -0700

    USB: serial: rework usb_serial_register/deregister_drivers()
    
    This reworks the usb_serial_register_drivers() and
    usb_serial_deregister_drivers() to not need a pointer to a struct
    usb_driver anymore.  The usb_driver structure is now created dynamically
    and registered and unregistered as needed.
    
    This saves lines of code in each usb-serial driver.  All in-kernel users
    of these functions were also fixed up at this time.  The pl2303 driver
    was tested that everything worked properly.
    
    Thanks for the idea to do this from Alan Stern.
    
    Cc: Adhir Ramjiawan <adhirramjiawan0@gmail.com>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Al Borchers <alborchers@steinerpoint.com>
    Cc: Aleksey Babahin <tamerlan311@gmail.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Andrew Worsley <amworsley@gmail.com>
    Cc: Bart Hartgers <bart.hartgers@gmail.com>
    Cc: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Dan Carpenter <error27@gmail.com>
    Cc: Dan Williams <dcbw@redhat.com>
    Cc: Donald Lee <donald@asix.com.tw>
    Cc: Eric Dumazet <eric.dumazet@gmail.com>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Felipe Balbi <balbi@ti.com>
    Cc: Gary Brubaker <xavyer@ix.netcom.com>
    Cc: Jesper Juhl <jj@chaosbits.net>
    Cc: Jiri Kosina <jkosina@suse.cz>
    Cc: Johan Hovold <jhovold@gmail.com>
    Cc: Julia Lawall <julia@diku.dk>
    Cc: Kautuk Consul <consul.kautuk@gmail.com>
    Cc: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Cc: Lonnie Mendez <dignome@gmail.com>
    Cc: Matthias Bruestle and Harald Welte <support@reiner-sct.com>
    Cc: Matthias Urlichs <smurf@smurf.noris.de>
    Cc: Mauro Carvalho Chehab <mchehab@redhat.com>
    Cc: Michal Sroczynski <msroczyn@gmail.com>
    Cc: "Michał Wróbel" <michal.wrobel@flytronic.pl>
    Cc: Oliver Neukum <oliver@neukum.name>
    Cc: Paul Gortmaker <paul.gortmaker@windriver.com>
    Cc: Peter Berger <pberger@brimson.com>
    Cc: Preston Fick <preston.fick@silabs.com>
    Cc: "Rafael J. Wysocki" <rjw@sisk.pl>
    Cc: Rigbert Hamisch <rigbert@gmx.de>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Cc: Simon Arlott <simon@fire.lp0.eu>
    Cc: Support Department <support@connecttech.com>
    Cc: Thomas Tuttle <ttuttle@chromium.org>
    Cc: Uwe Bonnes <bon@elektron.ikp.physik.tu-darmstadt.de>
    Cc: Wang YanQing <Udknight@gmail.com>
    Cc: William Greathouse <wgreathouse@smva.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/ipw.c b/drivers/usb/serial/ipw.c
index 76901336cfeb..5811d34b6c6b 100644
--- a/drivers/usb/serial/ipw.c
+++ b/drivers/usb/serial/ipw.c
@@ -132,17 +132,11 @@ enum {
 
 #define IPW_WANTS_TO_SEND	0x30
 
-static const struct usb_device_id usb_ipw_ids[] = {
+static const struct usb_device_id id_table[] = {
 	{ USB_DEVICE(IPW_VID, IPW_PID) },
 	{ },
 };
-
-MODULE_DEVICE_TABLE(usb, usb_ipw_ids);
-
-static struct usb_driver usb_ipw_driver = {
-	.name =		"ipwtty",
-	.id_table =	usb_ipw_ids,
-};
+MODULE_DEVICE_TABLE(usb, id_table);
 
 static bool debug;
 
@@ -313,7 +307,7 @@ static struct usb_serial_driver ipw_device = {
 		.name =		"ipw",
 	},
 	.description =		"IPWireless converter",
-	.id_table =		usb_ipw_ids,
+	.id_table =		id_table,
 	.num_ports =		1,
 	.disconnect =		usb_wwan_disconnect,
 	.open =			ipw_open,
@@ -329,7 +323,7 @@ static struct usb_serial_driver * const serial_drivers[] = {
 	&ipw_device, NULL
 };
 
-module_usb_serial_driver(usb_ipw_driver, serial_drivers);
+module_usb_serial_driver(serial_drivers, id_table);
 
 /* Module information */
 MODULE_AUTHOR(DRIVER_AUTHOR);

commit 32078f915d1acab356080b144aa89fe3487f3979
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon May 7 14:02:13 2012 -0700

    USB: serial: remove usb_serial_disconnect call in all drivers
    
    This is now set by the usb-serial core, no need for the driver to
    individually set it.
    
    Thanks to Alan Stern for the idea to get rid of it.
    
    Cc: William Greathouse <wgreathouse@smva.com>
    Cc: Matthias Bruestle and Harald Welte <support@reiner-sct.com>
    Cc: Lonnie Mendez <dignome@gmail.com>
    Cc: Peter Berger <pberger@brimson.com>
    Cc: Al Borchers <alborchers@steinerpoint.com>
    Cc: Gary Brubaker <xavyer@ix.netcom.com>
    Cc: Oliver Neukum <oliver@neukum.name>
    Cc: Matthias Urlichs <smurf@smurf.noris.de>
    Cc: Support Department <support@connecttech.com>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Mauro Carvalho Chehab <mchehab@redhat.com>
    Cc: Kautuk Consul <consul.kautuk@gmail.com>
    Cc: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Paul Gortmaker <paul.gortmaker@windriver.com>
    Cc: Bart Hartgers <bart.hartgers@gmail.com>
    Cc: Johan Hovold <jhovold@gmail.com>
    Cc: Preston Fick <preston.fick@silabs.com>
    Cc: Uwe Bonnes <bon@elektron.ikp.physik.tu-darmstadt.de>
    Cc: Simon Arlott <simon@fire.lp0.eu>
    Cc: Andrew Worsley <amworsley@gmail.com>
    Cc: "Michał Wróbel" <michal.wrobel@flytronic.pl>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Eric Dumazet <eric.dumazet@gmail.com>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Felipe Balbi <balbi@ti.com>
    Cc: Aleksey Babahin <tamerlan311@gmail.com>
    Cc: Dan Carpenter <error27@gmail.com>
    Cc: Jiri Kosina <jkosina@suse.cz>
    Cc: Donald Lee <donald@asix.com.tw>
    Cc: Julia Lawall <julia@diku.dk>
    Cc: Michal Sroczynski <msroczyn@gmail.com>
    Cc: Wang YanQing <Udknight@gmail.com>
    Cc: Dan Williams <dcbw@redhat.com>
    Cc: Thomas Tuttle <ttuttle@chromium.org>
    Cc: Rigbert Hamisch <rigbert@gmx.de>
    Cc: "Rafael J. Wysocki" <rjw@sisk.pl>
    Cc: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Cc: Jesper Juhl <jj@chaosbits.net>
    Cc: Adhir Ramjiawan <adhirramjiawan0@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/ipw.c b/drivers/usb/serial/ipw.c
index b42e1bb3c7e9..76901336cfeb 100644
--- a/drivers/usb/serial/ipw.c
+++ b/drivers/usb/serial/ipw.c
@@ -141,7 +141,6 @@ MODULE_DEVICE_TABLE(usb, usb_ipw_ids);
 
 static struct usb_driver usb_ipw_driver = {
 	.name =		"ipwtty",
-	.disconnect =	usb_serial_disconnect,
 	.id_table =	usb_ipw_ids,
 };
 

commit 5026bb07be87ef5892742e6853ae6efa0f41961f
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon May 7 13:48:33 2012 -0700

    USB: serial: remove usb_serial_probe call in all drivers
    
    This is now set by the usb-serial core, no need for the driver to
    individually set it.
    
    Thanks to Alan Stern for the idea to get rid of it.
    
    Cc: William Greathouse <wgreathouse@smva.com>
    Cc: Matthias Bruestle and Harald Welte <support@reiner-sct.com>
    Cc: Lonnie Mendez <dignome@gmail.com>
    Cc: Peter Berger <pberger@brimson.com>
    Cc: Al Borchers <alborchers@steinerpoint.com>
    Cc: Gary Brubaker <xavyer@ix.netcom.com>
    Cc: Oliver Neukum <oliver@neukum.name>
    Cc: Matthias Urlichs <smurf@smurf.noris.de>
    Cc: Support Department <support@connecttech.com>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Mauro Carvalho Chehab <mchehab@redhat.com>
    Cc: Kautuk Consul <consul.kautuk@gmail.com>
    Cc: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Paul Gortmaker <paul.gortmaker@windriver.com>
    Cc: Bart Hartgers <bart.hartgers@gmail.com>
    Cc: Johan Hovold <jhovold@gmail.com>
    Cc: Preston Fick <preston.fick@silabs.com>
    Cc: Uwe Bonnes <bon@elektron.ikp.physik.tu-darmstadt.de>
    Cc: Simon Arlott <simon@fire.lp0.eu>
    Cc: Andrew Worsley <amworsley@gmail.com>
    Cc: "Michał Wróbel" <michal.wrobel@flytronic.pl>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Eric Dumazet <eric.dumazet@gmail.com>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Felipe Balbi <balbi@ti.com>
    Cc: Aleksey Babahin <tamerlan311@gmail.com>
    Cc: Dan Carpenter <error27@gmail.com>
    Cc: Jiri Kosina <jkosina@suse.cz>
    Cc: Donald Lee <donald@asix.com.tw>
    Cc: Julia Lawall <julia@diku.dk>
    Cc: Michal Sroczynski <msroczyn@gmail.com>
    Cc: Wang YanQing <Udknight@gmail.com>
    Cc: Dan Williams <dcbw@redhat.com>
    Cc: Thomas Tuttle <ttuttle@chromium.org>
    Cc: Rigbert Hamisch <rigbert@gmx.de>
    Cc: "Rafael J. Wysocki" <rjw@sisk.pl>
    Cc: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Cc: Jesper Juhl <jj@chaosbits.net>
    Cc: Adhir Ramjiawan <adhirramjiawan0@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/ipw.c b/drivers/usb/serial/ipw.c
index 52c61d7cecd2..b42e1bb3c7e9 100644
--- a/drivers/usb/serial/ipw.c
+++ b/drivers/usb/serial/ipw.c
@@ -141,7 +141,6 @@ MODULE_DEVICE_TABLE(usb, usb_ipw_ids);
 
 static struct usb_driver usb_ipw_driver = {
 	.name =		"ipwtty",
-	.probe =	usb_serial_probe,
 	.disconnect =	usb_serial_disconnect,
 	.id_table =	usb_ipw_ids,
 };

commit 1ae4c01ed5a8041ffa12b90dbe6e0465653d3a5a
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu May 3 16:44:17 2012 -0700

    USB: ipw.c: remove dbg() tracing calls
    
    dbg() was used a lot a long time ago to trace code flow.  Now that we have
    ftrace, this isn't needed at all, so remove these calls.
    
    CC: Rusty Russell <rusty@rustcorp.com.au>
    CC: Oliver Neukum <oneukum@suse.de>
    CC: Alan Stern <stern@rowland.harvard.edu>
    CC: Mauro Carvalho Chehab <mchehab@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/ipw.c b/drivers/usb/serial/ipw.c
index 76a06406e26a..52c61d7cecd2 100644
--- a/drivers/usb/serial/ipw.c
+++ b/drivers/usb/serial/ipw.c
@@ -155,8 +155,6 @@ static int ipw_open(struct tty_struct *tty, struct usb_serial_port *port)
 	u8 *buf_flow_init;
 	int result;
 
-	dbg("%s", __func__);
-
 	buf_flow_init = kmemdup(buf_flow_static, 16, GFP_KERNEL);
 	if (!buf_flow_init)
 		return -ENOMEM;

commit f939484bb6473e51c1516ab9a4f3a7620cd95d72
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Feb 28 13:11:56 2012 -0800

    USB: serial: ipw.c: use module_usb_serial_driver
    
    This converts the ipw.c driver to use the module_usb_serial_driver() call
    instead of having to have a module_init/module_exit function, saving a lot
    of duplicated code.
    
    CC: Rusty Russell <rusty@rustcorp.com.au>
    CC: Oliver Neukum <oneukum@suse.de>
    CC: Alan Stern <stern@rowland.harvard.edu>
    CC: Mauro Carvalho Chehab <mchehab@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/ipw.c b/drivers/usb/serial/ipw.c
index 27b8886f1055..76a06406e26a 100644
--- a/drivers/usb/serial/ipw.c
+++ b/drivers/usb/serial/ipw.c
@@ -333,25 +333,7 @@ static struct usb_serial_driver * const serial_drivers[] = {
 	&ipw_device, NULL
 };
 
-
-static int __init usb_ipw_init(void)
-{
-	int retval;
-
-	retval = usb_serial_register_drivers(&usb_ipw_driver, serial_drivers);
-	if (retval == 0)
-		printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
-			       DRIVER_DESC "\n");
-	return retval;
-}
-
-static void __exit usb_ipw_exit(void)
-{
-	usb_serial_deregister_drivers(&usb_ipw_driver, serial_drivers);
-}
-
-module_init(usb_ipw_init);
-module_exit(usb_ipw_exit);
+module_usb_serial_driver(usb_ipw_driver, serial_drivers);
 
 /* Module information */
 MODULE_AUTHOR(DRIVER_AUTHOR);

commit 7dbe2460989b10644651e779b17b683627feea48
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Thu Feb 23 14:56:57 2012 -0500

    usb-serial: use new registration API in [i-j]* drivers
    
    This patch (as1525) modifies the following usb-serial drivers to
    utilize the new usb_serial_{de}register_drivers() routines:
    
            io_edgeport, io_ti, ipaq, ipw, ir-usb, and iuu_phoenix.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/ipw.c b/drivers/usb/serial/ipw.c
index 6f9356f3f99e..27b8886f1055 100644
--- a/drivers/usb/serial/ipw.c
+++ b/drivers/usb/serial/ipw.c
@@ -144,7 +144,6 @@ static struct usb_driver usb_ipw_driver = {
 	.probe =	usb_serial_probe,
 	.disconnect =	usb_serial_disconnect,
 	.id_table =	usb_ipw_ids,
-	.no_dynamic_id = 	1,
 };
 
 static bool debug;
@@ -318,7 +317,6 @@ static struct usb_serial_driver ipw_device = {
 		.name =		"ipw",
 	},
 	.description =		"IPWireless converter",
-	.usb_driver =		&usb_ipw_driver,
 	.id_table =		usb_ipw_ids,
 	.num_ports =		1,
 	.disconnect =		usb_wwan_disconnect,
@@ -331,29 +329,25 @@ static struct usb_serial_driver ipw_device = {
 	.write =		usb_wwan_write,
 };
 
+static struct usb_serial_driver * const serial_drivers[] = {
+	&ipw_device, NULL
+};
 
 
 static int __init usb_ipw_init(void)
 {
 	int retval;
 
-	retval = usb_serial_register(&ipw_device);
-	if (retval)
-		return retval;
-	retval = usb_register(&usb_ipw_driver);
-	if (retval) {
-		usb_serial_deregister(&ipw_device);
-		return retval;
-	}
-	printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
-	       DRIVER_DESC "\n");
-	return 0;
+	retval = usb_serial_register_drivers(&usb_ipw_driver, serial_drivers);
+	if (retval == 0)
+		printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
+			       DRIVER_DESC "\n");
+	return retval;
 }
 
 static void __exit usb_ipw_exit(void)
 {
-	usb_deregister(&usb_ipw_driver);
-	usb_serial_deregister(&ipw_device);
+	usb_serial_deregister_drivers(&usb_ipw_driver, serial_drivers);
 }
 
 module_init(usb_ipw_init);

commit 90ab5ee94171b3e28de6bb42ee30b527014e0be7
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Fri Jan 13 09:32:20 2012 +1030

    module_param: make bool parameters really bool (drivers & misc)
    
    module_param(bool) used to counter-intuitively take an int.  In
    fddd5201 (mid-2009) we allowed bool or int/unsigned int using a messy
    trick.
    
    It's time to remove the int/unsigned int option.  For this version
    it'll simply give a warning, but it'll break next kernel version.
    
    Acked-by: Mauro Carvalho Chehab <mchehab@redhat.com>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/drivers/usb/serial/ipw.c b/drivers/usb/serial/ipw.c
index 5170799d6e94..6f9356f3f99e 100644
--- a/drivers/usb/serial/ipw.c
+++ b/drivers/usb/serial/ipw.c
@@ -147,7 +147,7 @@ static struct usb_driver usb_ipw_driver = {
 	.no_dynamic_id = 	1,
 };
 
-static int debug;
+static bool debug;
 
 static int ipw_open(struct tty_struct *tty, struct usb_serial_port *port)
 {

commit 53e77df25f64567ee1f55e7d76b8843689c79d9e
Author: Oliver Neukum <oneukum@suse.de>
Date:   Wed Jul 13 13:54:48 2011 +0200

    USB: ipw: convert to usb-wwan framework
    
    From 2d487c10136f76cf3705881d34868e8592839cfe Mon Sep 17 00:00:00 2001
    From: Oliver Neukum <oliver@neukum.org>
    Date: Tue, 12 Jul 2011 15:36:51 +0200
    Subject: [PATCH] USB: ipw: convert to usb-wwan framework
    
    This patch allows the ipw driver to use the multibuffer
    infrastructure of usb-wwan. This improves speed.
    
    Signed-off-by: Oliver Neukum<oneukum@suse.de>
    Tested-by: Michal Hybner <dta081@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ipw.c b/drivers/usb/serial/ipw.c
index ca77e88836bd..5170799d6e94 100644
--- a/drivers/usb/serial/ipw.c
+++ b/drivers/usb/serial/ipw.c
@@ -47,6 +47,7 @@
 #include <linux/usb.h>
 #include <linux/usb/serial.h>
 #include <linux/uaccess.h>
+#include "usb-wwan.h"
 
 /*
  * Version Information
@@ -185,7 +186,7 @@ static int ipw_open(struct tty_struct *tty, struct usb_serial_port *port)
 
 	/*--2: Start reading from the device */
 	dbg("%s: setting up bulk read callback", __func__);
-	usb_serial_generic_open(tty, port);
+	usb_wwan_open(tty, port);
 
 	/*--3: Tell the modem to open the floodgates on the rx bulk channel */
 	dbg("%s:asking modem for RxRead (RXBULK_ON)", __func__);
@@ -219,6 +220,29 @@ static int ipw_open(struct tty_struct *tty, struct usb_serial_port *port)
 	return 0;
 }
 
+/* fake probe - only to allocate data structures */
+static int ipw_probe(struct usb_serial *serial, const struct usb_device_id *id)
+{
+	struct usb_wwan_intf_private *data;
+
+	data = kzalloc(sizeof(struct usb_wwan_intf_private), GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	spin_lock_init(&data->susp_lock);
+	usb_set_serial_data(serial, data);
+	return 0;
+}
+
+static void ipw_release(struct usb_serial *serial)
+{
+	struct usb_wwan_intf_private *data = usb_get_serial_data(serial);
+
+	usb_wwan_release(serial);
+	usb_set_serial_data(serial, NULL);
+	kfree(data);
+}
+
 static void ipw_dtr_rts(struct usb_serial_port *port, int on)
 {
 	struct usb_device *dev = port->serial->dev;
@@ -285,7 +309,7 @@ static void ipw_close(struct usb_serial_port *port)
 		dev_err(&port->dev,
 			"Disabling bulk RxRead failed (error = %d)\n", result);
 
-	usb_serial_generic_close(port);
+	usb_wwan_close(port);
 }
 
 static struct usb_serial_driver ipw_device = {
@@ -297,9 +321,14 @@ static struct usb_serial_driver ipw_device = {
 	.usb_driver =		&usb_ipw_driver,
 	.id_table =		usb_ipw_ids,
 	.num_ports =		1,
+	.disconnect =		usb_wwan_disconnect,
 	.open =			ipw_open,
 	.close =		ipw_close,
+	.probe =		ipw_probe,
+	.attach =		usb_wwan_startup,
+	.release =		ipw_release,
 	.dtr_rts =		ipw_dtr_rts,
+	.write =		usb_wwan_write,
 };
 
 

commit b2c573790381720e8b0aca1f392b4063f84cfcb6
Author: Johan Hovold <jhovold@gmail.com>
Date:   Thu May 13 21:33:10 2010 +0200

    USB: ipw: reimplement using generic framework
    
    Compile-only tested.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ipw.c b/drivers/usb/serial/ipw.c
index 585ec1e237b6..ca77e88836bd 100644
--- a/drivers/usb/serial/ipw.c
+++ b/drivers/usb/serial/ipw.c
@@ -34,7 +34,6 @@
  * DCD, DTR, RTS, CTS which are currently faked.
  * It's good enough for PPP at this point. It's based off all kinds of
  * code found in usb/serial and usb/class
- *
  */
 
 #include <linux/kernel.h>
@@ -52,7 +51,7 @@
 /*
  * Version Information
  */
-#define DRIVER_VERSION	"v0.3"
+#define DRIVER_VERSION	"v0.4"
 #define DRIVER_AUTHOR	"Roelf Diedericks"
 #define DRIVER_DESC	"IPWireless tty driver"
 
@@ -65,8 +64,6 @@
 /* Message sizes */
 #define EVENT_BUFFER_SIZE	0xFF
 #define CHAR2INT16(c1, c0)	(((u32)((c1) & 0xff) << 8) + (u32)((c0) & 0xff))
-#define NUM_BULK_URBS		24
-#define NUM_CONTROL_URBS	16
 
 /* vendor/product pairs that are known work with this driver*/
 #define IPW_VID		0x0bc3
@@ -151,47 +148,6 @@ static struct usb_driver usb_ipw_driver = {
 
 static int debug;
 
-static void ipw_read_bulk_callback(struct urb *urb)
-{
-	struct usb_serial_port *port = urb->context;
-	unsigned char *data = urb->transfer_buffer;
-	struct tty_struct *tty;
-	int result;
-	int status = urb->status;
-
-	dbg("%s - port %d", __func__, port->number);
-
-	if (status) {
-		dbg("%s - nonzero read bulk status received: %d",
-		    __func__, status);
-		return;
-	}
-
-	usb_serial_debug_data(debug, &port->dev, __func__,
-					urb->actual_length, data);
-
-	tty = tty_port_tty_get(&port->port);
-	if (tty && urb->actual_length) {
-		tty_insert_flip_string(tty, data, urb->actual_length);
-		tty_flip_buffer_push(tty);
-	}
-	tty_kref_put(tty);
-
-	/* Continue trying to always read  */
-	usb_fill_bulk_urb(port->read_urb, port->serial->dev,
-			  usb_rcvbulkpipe(port->serial->dev,
-					   port->bulk_in_endpointAddress),
-			  port->read_urb->transfer_buffer,
-			  port->read_urb->transfer_buffer_length,
-			  ipw_read_bulk_callback, port);
-	result = usb_submit_urb(port->read_urb, GFP_ATOMIC);
-	if (result)
-		dev_err(&port->dev,
-			"%s - failed resubmitting read urb, error %d\n",
-							__func__, result);
-	return;
-}
-
 static int ipw_open(struct tty_struct *tty, struct usb_serial_port *port)
 {
 	struct usb_device *dev = port->serial->dev;
@@ -229,15 +185,7 @@ static int ipw_open(struct tty_struct *tty, struct usb_serial_port *port)
 
 	/*--2: Start reading from the device */
 	dbg("%s: setting up bulk read callback", __func__);
-	usb_fill_bulk_urb(port->read_urb, dev,
-			  usb_rcvbulkpipe(dev, port->bulk_in_endpointAddress),
-			  port->bulk_in_buffer,
-			  port->bulk_in_size,
-			  ipw_read_bulk_callback, port);
-	result = usb_submit_urb(port->read_urb, GFP_KERNEL);
-	if (result < 0)
-		dbg("%s - usb_submit_urb(read bulk) failed with status %d",
-							__func__, result);
+	usb_serial_generic_open(tty, port);
 
 	/*--3: Tell the modem to open the floodgates on the rx bulk channel */
 	dbg("%s:asking modem for RxRead (RXBULK_ON)", __func__);
@@ -337,72 +285,7 @@ static void ipw_close(struct usb_serial_port *port)
 		dev_err(&port->dev,
 			"Disabling bulk RxRead failed (error = %d)\n", result);
 
-	/* shutdown any in-flight urbs that we know about */
-	usb_kill_urb(port->read_urb);
-	usb_kill_urb(port->write_urb);
-}
-
-static void ipw_write_bulk_callback(struct urb *urb)
-{
-	struct usb_serial_port *port = urb->context;
-	int status = urb->status;
-
-	dbg("%s", __func__);
-
-	port->write_urb_busy = 0;
-
-	if (status)
-		dbg("%s - nonzero write bulk status received: %d",
-		    __func__, status);
-
-	usb_serial_port_softint(port);
-}
-
-static int ipw_write(struct tty_struct *tty, struct usb_serial_port *port,
-					const unsigned char *buf, int count)
-{
-	struct usb_device *dev = port->serial->dev;
-	int ret;
-
-	dbg("%s: TOP: count=%d, in_interrupt=%ld", __func__,
-		count, in_interrupt());
-
-	if (count == 0) {
-		dbg("%s - write request of 0 bytes", __func__);
-		return 0;
-	}
-
-	spin_lock_bh(&port->lock);
-	if (port->write_urb_busy) {
-		spin_unlock_bh(&port->lock);
-		dbg("%s - already writing", __func__);
-		return 0;
-	}
-	port->write_urb_busy = 1;
-	spin_unlock_bh(&port->lock);
-
-	count = min(count, port->bulk_out_size);
-	memcpy(port->bulk_out_buffer, buf, count);
-
-	dbg("%s count now:%d", __func__, count);
-
-	usb_fill_bulk_urb(port->write_urb, dev,
-			  usb_sndbulkpipe(dev, port->bulk_out_endpointAddress),
-			  port->write_urb->transfer_buffer,
-			  count,
-			  ipw_write_bulk_callback,
-			  port);
-
-	ret = usb_submit_urb(port->write_urb, GFP_ATOMIC);
-	if (ret != 0) {
-		port->write_urb_busy = 0;
-		dbg("%s - usb_submit_urb(write bulk) failed with error = %d",
-								__func__, ret);
-		return ret;
-	}
-
-	dbg("%s returning %d", __func__, count);
-	return count;
+	usb_serial_generic_close(port);
 }
 
 static struct usb_serial_driver ipw_device = {
@@ -411,15 +294,12 @@ static struct usb_serial_driver ipw_device = {
 		.name =		"ipw",
 	},
 	.description =		"IPWireless converter",
-	.usb_driver = 		&usb_ipw_driver,
+	.usb_driver =		&usb_ipw_driver,
 	.id_table =		usb_ipw_ids,
 	.num_ports =		1,
 	.open =			ipw_open,
 	.close =		ipw_close,
 	.dtr_rts =		ipw_dtr_rts,
-	.write =		ipw_write,
-	.write_bulk_callback =	ipw_write_bulk_callback,
-	.read_bulk_callback =	ipw_read_bulk_callback,
 };
 
 

commit 55c6d85cabb33461139e430f48b9dea794d46f67
Author: Johan Hovold <jhovold@gmail.com>
Date:   Thu May 13 21:33:09 2010 +0200

    USB: ipw: remove dummy port_probe and port_remove
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ipw.c b/drivers/usb/serial/ipw.c
index 18b335e0959c..585ec1e237b6 100644
--- a/drivers/usb/serial/ipw.c
+++ b/drivers/usb/serial/ipw.c
@@ -405,17 +405,6 @@ static int ipw_write(struct tty_struct *tty, struct usb_serial_port *port,
 	return count;
 }
 
-static int ipw_probe(struct usb_serial_port *port)
-{
-	return 0;
-}
-
-static int ipw_disconnect(struct usb_serial_port *port)
-{
-	usb_set_serial_port_data(port, NULL);
-	return 0;
-}
-
 static struct usb_serial_driver ipw_device = {
 	.driver = {
 		.owner =	THIS_MODULE,
@@ -428,8 +417,6 @@ static struct usb_serial_driver ipw_device = {
 	.open =			ipw_open,
 	.close =		ipw_close,
 	.dtr_rts =		ipw_dtr_rts,
-	.port_probe = 		ipw_probe,
-	.port_remove =		ipw_disconnect,
 	.write =		ipw_write,
 	.write_bulk_callback =	ipw_write_bulk_callback,
 	.read_bulk_callback =	ipw_read_bulk_callback,

commit 605204bfb0047523b3acda535163875a75268a6a
Author: Johan Hovold <jhovold@gmail.com>
Date:   Thu May 13 21:33:08 2010 +0200

    USB: ipw: clean up dtr-rts handling
    
    No need to raise dtr/rts in open as this is taken care of by tty layer.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ipw.c b/drivers/usb/serial/ipw.c
index e1d07840cee6..18b335e0959c 100644
--- a/drivers/usb/serial/ipw.c
+++ b/drivers/usb/serial/ipw.c
@@ -267,35 +267,6 @@ static int ipw_open(struct tty_struct *tty, struct usb_serial_port *port)
 		dev_err(&port->dev,
 			"initial flowcontrol failed (error = %d)\n", result);
 
-
-	/*--5: raise the dtr */
-	dbg("%s:raising dtr", __func__);
-	result = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
-			 IPW_SIO_SET_PIN,
-			 USB_TYPE_VENDOR | USB_RECIP_INTERFACE | USB_DIR_OUT,
-			 IPW_PIN_SETDTR,
-			 0,
-			 NULL,
-			 0,
-			 200000);
-	if (result < 0)
-		dev_err(&port->dev,
-				"setting dtr failed (error = %d)\n", result);
-
-	/*--6: raise the rts */
-	dbg("%s:raising rts", __func__);
-	result = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
-			 IPW_SIO_SET_PIN,
-			 USB_TYPE_VENDOR | USB_RECIP_INTERFACE | USB_DIR_OUT,
-			 IPW_PIN_SETRTS,
-			 0,
-			 NULL,
-			 0,
-			 200000);
-	if (result < 0)
-		dev_err(&port->dev,
-				"setting dtr failed (error = %d)\n", result);
-
 	kfree(buf_flow_init);
 	return 0;
 }
@@ -305,8 +276,8 @@ static void ipw_dtr_rts(struct usb_serial_port *port, int on)
 	struct usb_device *dev = port->serial->dev;
 	int result;
 
-	/*--1: drop the dtr */
-	dbg("%s:dropping dtr", __func__);
+	dbg("%s: on = %d", __func__, on);
+
 	result = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
 			 IPW_SIO_SET_PIN,
 			 USB_TYPE_VENDOR | USB_RECIP_INTERFACE | USB_DIR_OUT,
@@ -316,22 +287,20 @@ static void ipw_dtr_rts(struct usb_serial_port *port, int on)
 			 0,
 			 200000);
 	if (result < 0)
-		dev_err(&port->dev, "dropping dtr failed (error = %d)\n",
+		dev_err(&port->dev, "setting dtr failed (error = %d)\n",
 								result);
 
-	/*--2: drop the rts */
-	dbg("%s:dropping rts", __func__);
 	result = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
 			 IPW_SIO_SET_PIN, USB_TYPE_VENDOR |
-			 		USB_RECIP_INTERFACE | USB_DIR_OUT,
+					USB_RECIP_INTERFACE | USB_DIR_OUT,
 			 on ? IPW_PIN_SETRTS : IPW_PIN_CLRRTS,
 			 0,
 			 NULL,
 			 0,
 			 200000);
 	if (result < 0)
-		dev_err(&port->dev,
-				"dropping rts failed (error = %d)\n", result);
+		dev_err(&port->dev, "setting rts failed (error = %d)\n",
+								result);
 }
 
 static void ipw_close(struct usb_serial_port *port)

commit a108bfcb372d8c4452701039308fb95747911c59
Author: Alan Cox <alan@linux.intel.com>
Date:   Thu Feb 18 16:44:01 2010 +0000

    USB: tty: Prune uses of tty_request_room in the USB layer
    
    We have lots of callers that do not need to do this in the first place.
    Remove the calls as they both cost CPU and for big buffers can mess up the
    multi-page allocation avoidance.
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ipw.c b/drivers/usb/serial/ipw.c
index c0afa7a219d7..e1d07840cee6 100644
--- a/drivers/usb/serial/ipw.c
+++ b/drivers/usb/serial/ipw.c
@@ -172,7 +172,6 @@ static void ipw_read_bulk_callback(struct urb *urb)
 
 	tty = tty_port_tty_get(&port->port);
 	if (tty && urb->actual_length) {
-		tty_buffer_request_room(tty, urb->actual_length);
 		tty_insert_flip_string(tty, data, urb->actual_length);
 		tty_flip_buffer_push(tty);
 	}

commit 7d40d7e85a25e01948bcb4dc3eda1355af318337
Author: Németh Márton <nm127@freemail.hu>
Date:   Sun Jan 10 15:34:24 2010 +0100

    USB serial: make USB device id constant
    
    The id_table field of the struct usb_device_id is constant in <linux/usb.h>
    so it is worth to make the initialization data also constant.
    
    The semantic match that finds this kind of pattern is as follows:
    (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @r@
    disable decl_init,const_decl_init;
    identifier I1, I2, x;
    @@
            struct I1 {
              ...
              const struct I2 *x;
              ...
            };
    @s@
    identifier r.I1, y;
    identifier r.x, E;
    @@
            struct I1 y = {
              .x = E,
            };
    @c@
    identifier r.I2;
    identifier s.E;
    @@
            const struct I2 E[] = ... ;
    @depends on !c@
    identifier r.I2;
    identifier s.E;
    @@
    +       const
            struct I2 E[] = ...;
    // </smpl>
    
    Signed-off-by: Németh Márton <nm127@freemail.hu>
    Cc: Julia Lawall <julia@diku.dk>
    Cc: cocci@diku.dk
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ipw.c b/drivers/usb/serial/ipw.c
index 727d323f092a..c0afa7a219d7 100644
--- a/drivers/usb/serial/ipw.c
+++ b/drivers/usb/serial/ipw.c
@@ -134,7 +134,7 @@ enum {
 
 #define IPW_WANTS_TO_SEND	0x30
 
-static struct usb_device_id usb_ipw_ids[] = {
+static const struct usb_device_id usb_ipw_ids[] = {
 	{ USB_DEVICE(IPW_VID, IPW_PID) },
 	{ },
 };

commit a509a7e478e4766114d69f12d19d644ac63e9765
Author: Alan Cox <alan@linux.intel.com>
Date:   Sat Sep 19 13:13:26 2009 -0700

    tty: USB does not need the filp argument in the drivers
    
    And indeed none of them use it. Clean this up as it will make moving to a
    standard open method rather easier.
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ipw.c b/drivers/usb/serial/ipw.c
index 29ad038b9c8d..727d323f092a 100644
--- a/drivers/usb/serial/ipw.c
+++ b/drivers/usb/serial/ipw.c
@@ -193,8 +193,7 @@ static void ipw_read_bulk_callback(struct urb *urb)
 	return;
 }
 
-static int ipw_open(struct tty_struct *tty,
-			struct usb_serial_port *port, struct file *filp)
+static int ipw_open(struct tty_struct *tty, struct usb_serial_port *port)
 {
 	struct usb_device *dev = port->serial->dev;
 	u8 buf_flow_static[16] = IPW_BYTES_FLOWINIT;

commit 335f8514f200e63d689113d29cb7253a5c282967
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Thu Jun 11 12:26:29 2009 +0100

    tty: Bring the usb tty port structure into more use
    
    This allows us to clean stuff up, but is probably also going to cause
    some app breakage with buggy apps as we now implement proper POSIX behaviour
    for USB ports matching all the other ports. This does also mean other apps
    that break on USB will now work properly.
    
    Signed-off-by: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/usb/serial/ipw.c b/drivers/usb/serial/ipw.c
index da2a2b46644a..29ad038b9c8d 100644
--- a/drivers/usb/serial/ipw.c
+++ b/drivers/usb/serial/ipw.c
@@ -302,23 +302,17 @@ static int ipw_open(struct tty_struct *tty,
 	return 0;
 }
 
-static void ipw_close(struct tty_struct *tty,
-			struct usb_serial_port *port, struct file *filp)
+static void ipw_dtr_rts(struct usb_serial_port *port, int on)
 {
 	struct usb_device *dev = port->serial->dev;
 	int result;
 
-	if (tty_hung_up_p(filp)) {
-		dbg("%s: tty_hung_up_p ...", __func__);
-		return;
-	}
-
 	/*--1: drop the dtr */
 	dbg("%s:dropping dtr", __func__);
 	result = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
 			 IPW_SIO_SET_PIN,
 			 USB_TYPE_VENDOR | USB_RECIP_INTERFACE | USB_DIR_OUT,
-			 IPW_PIN_CLRDTR,
+			 on ? IPW_PIN_SETDTR : IPW_PIN_CLRDTR,
 			 0,
 			 NULL,
 			 0,
@@ -332,7 +326,7 @@ static void ipw_close(struct tty_struct *tty,
 	result = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
 			 IPW_SIO_SET_PIN, USB_TYPE_VENDOR |
 			 		USB_RECIP_INTERFACE | USB_DIR_OUT,
-			 IPW_PIN_CLRRTS,
+			 on ? IPW_PIN_SETRTS : IPW_PIN_CLRRTS,
 			 0,
 			 NULL,
 			 0,
@@ -340,7 +334,12 @@ static void ipw_close(struct tty_struct *tty,
 	if (result < 0)
 		dev_err(&port->dev,
 				"dropping rts failed (error = %d)\n", result);
+}
 
+static void ipw_close(struct usb_serial_port *port)
+{
+	struct usb_device *dev = port->serial->dev;
+	int result;
 
 	/*--3: purge */
 	dbg("%s:sending purge", __func__);
@@ -461,6 +460,7 @@ static struct usb_serial_driver ipw_device = {
 	.num_ports =		1,
 	.open =			ipw_open,
 	.close =		ipw_close,
+	.dtr_rts =		ipw_dtr_rts,
 	.port_probe = 		ipw_probe,
 	.port_remove =		ipw_disconnect,
 	.write =		ipw_write,

commit 2400a2bfbd0e912193fe3b077f492d4980141813
Author: Oliver Neukum <oliver@neukum.org>
Date:   Mon Apr 20 17:28:53 2009 +0200

    USB: removal of tty->low_latency hack dating back to the old serial code
    
    This removes tty->low_latency from all USB serial drivers that push
    data into the tty layer at hard interrupt context. It's no longer needed
    and actually harmful.
    
    Signed-off-by: Oliver Neukum <oliver@neukum.org>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ipw.c b/drivers/usb/serial/ipw.c
index f530032ed93d..da2a2b46644a 100644
--- a/drivers/usb/serial/ipw.c
+++ b/drivers/usb/serial/ipw.c
@@ -207,9 +207,6 @@ static int ipw_open(struct tty_struct *tty,
 	if (!buf_flow_init)
 		return -ENOMEM;
 
-	if (tty)
-		tty->low_latency = 1;
-
 	/* --1: Tell the modem to initialize (we think) From sniffs this is
 	 *	always the first thing that gets sent to the modem during
 	 *	opening of the device */

commit 5e5b0e5d6a354f6f457368149eb2e9a61e5576cf
Author: Qinghuang Feng <qhfeng.kernel@gmail.com>
Date:   Fri Nov 14 20:24:11 2008 +0800

    USB: serial: ipw.c: mark {__init|__exit} for usb_ipw_{init|exit}
    
    mark {__init|__exit} for usb_ipw_{init|exit} ()
    
    Signed-off-by: Qinghuang Feng <qhfeng.kernel@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ipw.c b/drivers/usb/serial/ipw.c
index 3ac59a8a980f..f530032ed93d 100644
--- a/drivers/usb/serial/ipw.c
+++ b/drivers/usb/serial/ipw.c
@@ -473,7 +473,7 @@ static struct usb_serial_driver ipw_device = {
 
 
 
-static int usb_ipw_init(void)
+static int __init usb_ipw_init(void)
 {
 	int retval;
 
@@ -490,7 +490,7 @@ static int usb_ipw_init(void)
 	return 0;
 }
 
-static void usb_ipw_exit(void)
+static void __exit usb_ipw_exit(void)
 {
 	usb_deregister(&usb_ipw_driver);
 	usb_serial_deregister(&ipw_device);

commit c197a8db59daf06dc5e77acd5a9681329cb22458
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Aug 18 13:21:04 2008 -0700

    USB: remove info() macro from usb/serial drivers
    
    USB should not be having it's own printk macros, so remove info() and
    use the system-wide standard of dev_info() wherever possible.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ipw.c b/drivers/usb/serial/ipw.c
index 480cac27d646..3ac59a8a980f 100644
--- a/drivers/usb/serial/ipw.c
+++ b/drivers/usb/serial/ipw.c
@@ -485,7 +485,8 @@ static int usb_ipw_init(void)
 		usb_serial_deregister(&ipw_device);
 		return retval;
 	}
-	info(DRIVER_DESC " " DRIVER_VERSION);
+	printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
+	       DRIVER_DESC "\n");
 	return 0;
 }
 

commit 4a90f09b20f4622dcbff1f0e1e6bae1704f8ad8c
Author: Alan Cox <alan@redhat.com>
Date:   Mon Oct 13 10:39:46 2008 +0100

    tty: usb-serial krefs
    
    Use kref in the USB serial drivers so that we don't free tty structures
    from under the URB receive handlers as has historically been the case if
    you were unlucky. This also gives us a framework for general tty drivers to
    use tty_port objects and refcount.
    
    Contains two err->dev_err changes merged together to fix clashes in the
    -next tree.
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/usb/serial/ipw.c b/drivers/usb/serial/ipw.c
index a842025b9b57..480cac27d646 100644
--- a/drivers/usb/serial/ipw.c
+++ b/drivers/usb/serial/ipw.c
@@ -170,12 +170,13 @@ static void ipw_read_bulk_callback(struct urb *urb)
 	usb_serial_debug_data(debug, &port->dev, __func__,
 					urb->actual_length, data);
 
-	tty = port->port.tty;
+	tty = tty_port_tty_get(&port->port);
 	if (tty && urb->actual_length) {
 		tty_buffer_request_room(tty, urb->actual_length);
 		tty_insert_flip_string(tty, data, urb->actual_length);
 		tty_flip_buffer_push(tty);
 	}
+	tty_kref_put(tty);
 
 	/* Continue trying to always read  */
 	usb_fill_bulk_urb(port->read_urb, port->serial->dev,

commit 6d1d1698966ab6a5ac7ddcb16602ffebcf97f887
Author: Alan Cox <alan@redhat.com>
Date:   Tue Jul 22 11:12:51 2008 +0100

    tty-usb-ipw: Coding style
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/usb/serial/ipw.c b/drivers/usb/serial/ipw.c
index a89ebfe9e915..a842025b9b57 100644
--- a/drivers/usb/serial/ipw.c
+++ b/drivers/usb/serial/ipw.c
@@ -10,27 +10,27 @@
  *   (at your option) any later version.
  *
  * All information about the device was acquired using SnoopyPro
- * on MSFT's O/S, and examing the MSFT drivers' debug output 
+ * on MSFT's O/S, and examing the MSFT drivers' debug output
  * (insanely left _on_ in the enduser version)
  *
  * It was written out of frustration with the IPWireless USB modem
  * supplied by Axity3G/Sentech South Africa not supporting
  * Linux whatsoever.
  *
- * Nobody provided any proprietary information that was not already 
+ * Nobody provided any proprietary information that was not already
  * available for this device.
- * 
- * The modem adheres to the "3GPP TS  27.007 AT command set for 3G 
- * User Equipment (UE)" standard, available from 
+ *
+ * The modem adheres to the "3GPP TS  27.007 AT command set for 3G
+ * User Equipment (UE)" standard, available from
  * http://www.3gpp.org/ftp/Specs/html-info/27007.htm
  *
  * The code was only tested the IPWireless handheld modem distributed
  * in South Africa by Sentech.
- * 
+ *
  * It may work for Woosh Inc in .nz too, as it appears they use the
  * same kit.
  *
- * There is still some work to be done in terms of handling 
+ * There is still some work to be done in terms of handling
  * DCD, DTR, RTS, CTS which are currently faked.
  * It's good enough for PPP at this point. It's based off all kinds of
  * code found in usb/serial and usb/class
@@ -47,7 +47,7 @@
 #include <linux/spinlock.h>
 #include <linux/usb.h>
 #include <linux/usb/serial.h>
-#include <asm/uaccess.h>
+#include <linux/uaccess.h>
 
 /*
  * Version Information
@@ -64,7 +64,7 @@
 
 /* Message sizes */
 #define EVENT_BUFFER_SIZE	0xFF
-#define CHAR2INT16(c1,c0)	(((u32)((c1) & 0xff) << 8) + (u32)((c0) & 0xff))
+#define CHAR2INT16(c1, c0)	(((u32)((c1) & 0xff) << 8) + (u32)((c0) & 0xff))
 #define NUM_BULK_URBS		24
 #define NUM_CONTROL_URBS	16
 
@@ -94,33 +94,34 @@ enum {
 
 /* data bits */
 #define ipw_dtb_7		0x700
-#define ipw_dtb_8		0x810	// ok so the define is misleading, I know, but forces 8,n,1
-					// I mean, is there a point to any other setting these days? :)	
+#define ipw_dtb_8		0x810	/* ok so the define is misleading, I know, but forces 8,n,1 */
+					/* I mean, is there a point to any other setting these days? :) */
 
 /* usb control request types : */
-#define IPW_SIO_RXCTL		0x00	// control bulk rx channel transmissions, value=1/0 (on/off)
-#define IPW_SIO_SET_BAUD	0x01	// set baud, value=requested ipw_sio_bxxxx
-#define IPW_SIO_SET_LINE	0x03	// set databits, parity. value=ipw_dtb_x
-#define IPW_SIO_SET_PIN		0x03	// set/clear dtr/rts value=ipw_pin_xxx
-#define IPW_SIO_POLL		0x08	// get serial port status byte, call with value=0
-#define IPW_SIO_INIT		0x11	// initializes ? value=0 (appears as first thing todo on open)
-#define IPW_SIO_PURGE		0x12	// purge all transmissions?, call with value=numchar_to_purge
-#define IPW_SIO_HANDFLOW	0x13	// set xon/xoff limits value=0, and a buffer of 0x10 bytes
-#define IPW_SIO_SETCHARS	0x13	// set the flowcontrol special chars, value=0, buf=6 bytes, 
-					// last 2 bytes contain flowcontrol chars e.g. 00 00 00 00 11 13
+#define IPW_SIO_RXCTL		0x00	/* control bulk rx channel transmissions, value=1/0 (on/off) */
+#define IPW_SIO_SET_BAUD	0x01	/* set baud, value=requested ipw_sio_bxxxx */
+#define IPW_SIO_SET_LINE	0x03	/* set databits, parity. value=ipw_dtb_x */
+#define IPW_SIO_SET_PIN		0x03	/* set/clear dtr/rts value=ipw_pin_xxx */
+#define IPW_SIO_POLL		0x08	/* get serial port status byte, call with value=0 */
+#define IPW_SIO_INIT		0x11	/* initializes ? value=0 (appears as first thing todo on open) */
+#define IPW_SIO_PURGE		0x12	/* purge all transmissions?, call with value=numchar_to_purge */
+#define IPW_SIO_HANDFLOW	0x13	/* set xon/xoff limits value=0, and a buffer of 0x10 bytes */
+#define IPW_SIO_SETCHARS	0x13	/* set the flowcontrol special chars, value=0, buf=6 bytes, */
+					/* last 2 bytes contain flowcontrol chars e.g. 00 00 00 00 11 13 */
 
 /* values used for request IPW_SIO_SET_PIN */
 #define IPW_PIN_SETDTR		0x101
 #define IPW_PIN_SETRTS		0x202
 #define IPW_PIN_CLRDTR		0x100
-#define IPW_PIN_CLRRTS		0x200 // unconfirmed
+#define IPW_PIN_CLRRTS		0x200 /* unconfirmed */
 
 /* values used for request IPW_SIO_RXCTL */
 #define IPW_RXBULK_ON		1
 #define IPW_RXBULK_OFF		0
 
 /* various 16 byte hardcoded transferbuffers used by flow control */
-#define IPW_BYTES_FLOWINIT	{ 0x01, 0, 0, 0, 0x40, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
+#define IPW_BYTES_FLOWINIT	{ 0x01, 0, 0, 0, 0x40, 0, 0, 0, \
+					0, 0, 0, 0, 0, 0, 0, 0 }
 
 /* Interpretation of modem status lines */
 /* These need sorting out by individually connecting pins and checking
@@ -132,17 +133,6 @@ enum {
 #define IPW_CTS			((1<<5) | (1<<4))
 
 #define IPW_WANTS_TO_SEND	0x30
-//#define IPW_DTR			/* Data Terminal Ready */
-//#define IPW_CTS			/* Clear To Send */
-//#define IPW_CD			/* Carrier Detect */
-//#define IPW_DSR			/* Data Set Ready */
-//#define IPW_RxD			/* Receive pin */
-
-//#define IPW_LE
-//#define IPW_RTS		
-//#define IPW_ST		
-//#define IPW_SR		
-//#define IPW_RI			/* Ring Indicator */
 
 static struct usb_device_id usb_ipw_ids[] = {
 	{ USB_DEVICE(IPW_VID, IPW_PID) },
@@ -177,7 +167,8 @@ static void ipw_read_bulk_callback(struct urb *urb)
 		return;
 	}
 
-	usb_serial_debug_data(debug, &port->dev, __func__, urb->actual_length, data);
+	usb_serial_debug_data(debug, &port->dev, __func__,
+					urb->actual_length, data);
 
 	tty = port->port.tty;
 	if (tty && urb->actual_length) {
@@ -187,15 +178,17 @@ static void ipw_read_bulk_callback(struct urb *urb)
 	}
 
 	/* Continue trying to always read  */
-	usb_fill_bulk_urb (port->read_urb, port->serial->dev,
-			   usb_rcvbulkpipe(port->serial->dev,
+	usb_fill_bulk_urb(port->read_urb, port->serial->dev,
+			  usb_rcvbulkpipe(port->serial->dev,
 					   port->bulk_in_endpointAddress),
-			   port->read_urb->transfer_buffer,
-			   port->read_urb->transfer_buffer_length,
-			   ipw_read_bulk_callback, port);
+			  port->read_urb->transfer_buffer,
+			  port->read_urb->transfer_buffer_length,
+			  ipw_read_bulk_callback, port);
 	result = usb_submit_urb(port->read_urb, GFP_ATOMIC);
 	if (result)
-		dev_err(&port->dev, "%s - failed resubmitting read urb, error %d\n", __func__, result);
+		dev_err(&port->dev,
+			"%s - failed resubmitting read urb, error %d\n",
+							__func__, result);
 	return;
 }
 
@@ -216,26 +209,30 @@ static int ipw_open(struct tty_struct *tty,
 	if (tty)
 		tty->low_latency = 1;
 
-	/* --1: Tell the modem to initialize (we think) From sniffs this is always the
-	 * first thing that gets sent to the modem during opening of the device */
-	dbg("%s: Sending SIO_INIT (we guess)",__func__);
-	result = usb_control_msg(dev, usb_sndctrlpipe(dev,0),
-				 IPW_SIO_INIT,
-				 USB_TYPE_VENDOR | USB_RECIP_INTERFACE | USB_DIR_OUT,
-				 0,
-				 0, /* index */
-				 NULL,
-				 0,
-				 100000);
+	/* --1: Tell the modem to initialize (we think) From sniffs this is
+	 *	always the first thing that gets sent to the modem during
+	 *	opening of the device */
+	dbg("%s: Sending SIO_INIT (we guess)", __func__);
+	result = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
+			 IPW_SIO_INIT,
+			 USB_TYPE_VENDOR | USB_RECIP_INTERFACE | USB_DIR_OUT,
+			 0,
+			 0, /* index */
+			 NULL,
+			 0,
+			 100000);
 	if (result < 0)
-		dev_err(&port->dev, "Init of modem failed (error = %d)\n", result);
+		dev_err(&port->dev,
+			"Init of modem failed (error = %d)\n", result);
 
 	/* reset the bulk pipes */
-	usb_clear_halt(dev, usb_rcvbulkpipe(dev, port->bulk_in_endpointAddress));
-	usb_clear_halt(dev, usb_sndbulkpipe(dev, port->bulk_out_endpointAddress));
+	usb_clear_halt(dev,
+			usb_rcvbulkpipe(dev, port->bulk_in_endpointAddress));
+	usb_clear_halt(dev,
+			usb_sndbulkpipe(dev, port->bulk_out_endpointAddress));
 
-	/*--2: Start reading from the device */	
-	dbg("%s: setting up bulk read callback",__func__);
+	/*--2: Start reading from the device */
+	dbg("%s: setting up bulk read callback", __func__);
 	usb_fill_bulk_urb(port->read_urb, dev,
 			  usb_rcvbulkpipe(dev, port->bulk_in_endpointAddress),
 			  port->bulk_in_buffer,
@@ -243,67 +240,72 @@ static int ipw_open(struct tty_struct *tty,
 			  ipw_read_bulk_callback, port);
 	result = usb_submit_urb(port->read_urb, GFP_KERNEL);
 	if (result < 0)
-		dbg("%s - usb_submit_urb(read bulk) failed with status %d", __func__, result);
+		dbg("%s - usb_submit_urb(read bulk) failed with status %d",
+							__func__, result);
 
 	/*--3: Tell the modem to open the floodgates on the rx bulk channel */
-	dbg("%s:asking modem for RxRead (RXBULK_ON)",__func__);
+	dbg("%s:asking modem for RxRead (RXBULK_ON)", __func__);
 	result = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
-				 IPW_SIO_RXCTL,
-				 USB_TYPE_VENDOR | USB_RECIP_INTERFACE | USB_DIR_OUT,
-				 IPW_RXBULK_ON,
-				 0, /* index */
-				 NULL,
-				 0,
-				 100000);
-	if (result < 0) 
-		dev_err(&port->dev, "Enabling bulk RxRead failed (error = %d)\n", result);
+			 IPW_SIO_RXCTL,
+			 USB_TYPE_VENDOR | USB_RECIP_INTERFACE | USB_DIR_OUT,
+			 IPW_RXBULK_ON,
+			 0, /* index */
+			 NULL,
+			 0,
+			 100000);
+	if (result < 0)
+		dev_err(&port->dev,
+			"Enabling bulk RxRead failed (error = %d)\n", result);
 
 	/*--4: setup the initial flowcontrol */
-	dbg("%s:setting init flowcontrol (%s)",__func__,buf_flow_init);
+	dbg("%s:setting init flowcontrol (%s)", __func__, buf_flow_init);
 	result = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
-				 IPW_SIO_HANDFLOW,
-				 USB_TYPE_VENDOR | USB_RECIP_INTERFACE | USB_DIR_OUT,
-				 0,
-				 0,
-				 buf_flow_init,
-				 0x10,
-				 200000);
+			 IPW_SIO_HANDFLOW,
+			 USB_TYPE_VENDOR | USB_RECIP_INTERFACE | USB_DIR_OUT,
+			 0,
+			 0,
+			 buf_flow_init,
+			 0x10,
+			 200000);
 	if (result < 0)
-		dev_err(&port->dev, "initial flowcontrol failed (error = %d)\n", result);
+		dev_err(&port->dev,
+			"initial flowcontrol failed (error = %d)\n", result);
 
 
 	/*--5: raise the dtr */
-	dbg("%s:raising dtr",__func__);
+	dbg("%s:raising dtr", __func__);
 	result = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
-				 IPW_SIO_SET_PIN,
-				 USB_TYPE_VENDOR | USB_RECIP_INTERFACE | USB_DIR_OUT,
-				 IPW_PIN_SETDTR,
-				 0,
-				 NULL,
-				 0,
-				 200000);
+			 IPW_SIO_SET_PIN,
+			 USB_TYPE_VENDOR | USB_RECIP_INTERFACE | USB_DIR_OUT,
+			 IPW_PIN_SETDTR,
+			 0,
+			 NULL,
+			 0,
+			 200000);
 	if (result < 0)
-		dev_err(&port->dev, "setting dtr failed (error = %d)\n", result);
+		dev_err(&port->dev,
+				"setting dtr failed (error = %d)\n", result);
 
 	/*--6: raise the rts */
-	dbg("%s:raising rts",__func__);
+	dbg("%s:raising rts", __func__);
 	result = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
-				 IPW_SIO_SET_PIN,
-				 USB_TYPE_VENDOR | USB_RECIP_INTERFACE | USB_DIR_OUT,
-				 IPW_PIN_SETRTS,
-				 0,
-				 NULL,
-				 0,
-				 200000);
+			 IPW_SIO_SET_PIN,
+			 USB_TYPE_VENDOR | USB_RECIP_INTERFACE | USB_DIR_OUT,
+			 IPW_PIN_SETRTS,
+			 0,
+			 NULL,
+			 0,
+			 200000);
 	if (result < 0)
-		dev_err(&port->dev, "setting dtr failed (error = %d)\n", result);
-	
+		dev_err(&port->dev,
+				"setting dtr failed (error = %d)\n", result);
+
 	kfree(buf_flow_init);
 	return 0;
 }
 
 static void ipw_close(struct tty_struct *tty,
-			struct usb_serial_port *port, struct file * filp)
+			struct usb_serial_port *port, struct file *filp)
 {
 	struct usb_device *dev = port->serial->dev;
 	int result;
@@ -314,56 +316,62 @@ static void ipw_close(struct tty_struct *tty,
 	}
 
 	/*--1: drop the dtr */
-	dbg("%s:dropping dtr",__func__);
+	dbg("%s:dropping dtr", __func__);
 	result = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
-				 IPW_SIO_SET_PIN,
-				 USB_TYPE_VENDOR | USB_RECIP_INTERFACE | USB_DIR_OUT,
-				 IPW_PIN_CLRDTR,
-				 0,
-				 NULL,
-				 0,
-				 200000);
+			 IPW_SIO_SET_PIN,
+			 USB_TYPE_VENDOR | USB_RECIP_INTERFACE | USB_DIR_OUT,
+			 IPW_PIN_CLRDTR,
+			 0,
+			 NULL,
+			 0,
+			 200000);
 	if (result < 0)
-		dev_err(&port->dev, "dropping dtr failed (error = %d)\n", result);
+		dev_err(&port->dev, "dropping dtr failed (error = %d)\n",
+								result);
 
 	/*--2: drop the rts */
-	dbg("%s:dropping rts",__func__);
+	dbg("%s:dropping rts", __func__);
 	result = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
-				 IPW_SIO_SET_PIN, USB_TYPE_VENDOR | USB_RECIP_INTERFACE | USB_DIR_OUT,
-				 IPW_PIN_CLRRTS,
-				 0,
-				 NULL,
-				 0,
-				 200000);
+			 IPW_SIO_SET_PIN, USB_TYPE_VENDOR |
+			 		USB_RECIP_INTERFACE | USB_DIR_OUT,
+			 IPW_PIN_CLRRTS,
+			 0,
+			 NULL,
+			 0,
+			 200000);
 	if (result < 0)
-		dev_err(&port->dev, "dropping rts failed (error = %d)\n", result);
+		dev_err(&port->dev,
+				"dropping rts failed (error = %d)\n", result);
 
 
 	/*--3: purge */
-	dbg("%s:sending purge",__func__);
+	dbg("%s:sending purge", __func__);
 	result = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
-				 IPW_SIO_PURGE, USB_TYPE_VENDOR | USB_RECIP_INTERFACE | USB_DIR_OUT,
-				 0x03,
-				 0,
-				 NULL,
-				 0,
-				 200000);
+			 IPW_SIO_PURGE, USB_TYPE_VENDOR |
+			 		USB_RECIP_INTERFACE | USB_DIR_OUT,
+			 0x03,
+			 0,
+			 NULL,
+			 0,
+			 200000);
 	if (result < 0)
 		dev_err(&port->dev, "purge failed (error = %d)\n", result);
 
 
-	/* send RXBULK_off (tell modem to stop transmitting bulk data on rx chan) */
+	/* send RXBULK_off (tell modem to stop transmitting bulk data on
+	   rx chan) */
 	result = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
-				 IPW_SIO_RXCTL,
-				 USB_TYPE_VENDOR | USB_RECIP_INTERFACE | USB_DIR_OUT,
-				 IPW_RXBULK_OFF,
-				 0, /* index */
-				 NULL,
-				 0,
-				 100000);
+			 IPW_SIO_RXCTL,
+			 USB_TYPE_VENDOR | USB_RECIP_INTERFACE | USB_DIR_OUT,
+			 IPW_RXBULK_OFF,
+			 0, /* index */
+			 NULL,
+			 0,
+			 100000);
 
 	if (result < 0)
-		dev_err(&port->dev, "Disabling bulk RxRead failed (error = %d)\n", result);
+		dev_err(&port->dev,
+			"Disabling bulk RxRead failed (error = %d)\n", result);
 
 	/* shutdown any in-flight urbs that we know about */
 	usb_kill_urb(port->read_urb);
@@ -393,7 +401,7 @@ static int ipw_write(struct tty_struct *tty, struct usb_serial_port *port,
 	int ret;
 
 	dbg("%s: TOP: count=%d, in_interrupt=%ld", __func__,
-		count, in_interrupt() );
+		count, in_interrupt());
 
 	if (count == 0) {
 		dbg("%s - write request of 0 bytes", __func__);
@@ -424,13 +432,14 @@ static int ipw_write(struct tty_struct *tty, struct usb_serial_port *port,
 	ret = usb_submit_urb(port->write_urb, GFP_ATOMIC);
 	if (ret != 0) {
 		port->write_urb_busy = 0;
-		dbg("%s - usb_submit_urb(write bulk) failed with error = %d", __func__, ret);
+		dbg("%s - usb_submit_urb(write bulk) failed with error = %d",
+								__func__, ret);
 		return ret;
 	}
 
 	dbg("%s returning %d", __func__, count);
 	return count;
-} 
+}
 
 static int ipw_probe(struct usb_serial_port *port)
 {
@@ -489,8 +498,8 @@ module_init(usb_ipw_init);
 module_exit(usb_ipw_exit);
 
 /* Module information */
-MODULE_AUTHOR( DRIVER_AUTHOR );
-MODULE_DESCRIPTION( DRIVER_DESC );
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_DESCRIPTION(DRIVER_DESC);
 MODULE_LICENSE("GPL");
 
 module_param(debug, bool, S_IRUGO | S_IWUSR);

commit 95da310e66ee8090119596c70ca8432e57f9a97f
Author: Alan Cox <alan@redhat.com>
Date:   Tue Jul 22 11:09:07 2008 +0100

    usb_serial: API all change
    
    USB serial likes to use port->tty back pointers for the real work it does and
    to do so without any actual locking. Unfortunately when you consider hangup
    events, hangup/parallel reopen or even worse hangup followed by parallel close
    events the tty->port and port->tty pointers are not guaranteed to be the same
    as port->tty is the active tty while tty->port is the port the tty may or
    may not still be attached to.
    
    So rework the entire API to pass the tty struct. For console cases we need
    to pass both for now. This shows up multiple drivers that immediately crash
    with USB console some of which have been fixed in the process.
    
    Longer term we need a proper tty as console abstraction
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/usb/serial/ipw.c b/drivers/usb/serial/ipw.c
index bc85ca5c1c37..a89ebfe9e915 100644
--- a/drivers/usb/serial/ipw.c
+++ b/drivers/usb/serial/ipw.c
@@ -179,7 +179,7 @@ static void ipw_read_bulk_callback(struct urb *urb)
 
 	usb_serial_debug_data(debug, &port->dev, __func__, urb->actual_length, data);
 
-	tty = port->tty;
+	tty = port->port.tty;
 	if (tty && urb->actual_length) {
 		tty_buffer_request_room(tty, urb->actual_length);
 		tty_insert_flip_string(tty, data, urb->actual_length);
@@ -199,7 +199,8 @@ static void ipw_read_bulk_callback(struct urb *urb)
 	return;
 }
 
-static int ipw_open(struct usb_serial_port *port, struct file *filp)
+static int ipw_open(struct tty_struct *tty,
+			struct usb_serial_port *port, struct file *filp)
 {
 	struct usb_device *dev = port->serial->dev;
 	u8 buf_flow_static[16] = IPW_BYTES_FLOWINIT;
@@ -212,8 +213,8 @@ static int ipw_open(struct usb_serial_port *port, struct file *filp)
 	if (!buf_flow_init)
 		return -ENOMEM;
 
-	if (port->tty)
-		port->tty->low_latency = 1;
+	if (tty)
+		tty->low_latency = 1;
 
 	/* --1: Tell the modem to initialize (we think) From sniffs this is always the
 	 * first thing that gets sent to the modem during opening of the device */
@@ -301,7 +302,8 @@ static int ipw_open(struct usb_serial_port *port, struct file *filp)
 	return 0;
 }
 
-static void ipw_close(struct usb_serial_port *port, struct file * filp)
+static void ipw_close(struct tty_struct *tty,
+			struct usb_serial_port *port, struct file * filp)
 {
 	struct usb_device *dev = port->serial->dev;
 	int result;
@@ -384,7 +386,8 @@ static void ipw_write_bulk_callback(struct urb *urb)
 	usb_serial_port_softint(port);
 }
 
-static int ipw_write(struct usb_serial_port *port, const unsigned char *buf, int count)
+static int ipw_write(struct tty_struct *tty, struct usb_serial_port *port,
+					const unsigned char *buf, int count)
 {
 	struct usb_device *dev = port->serial->dev;
 	int ret;

commit 441b62c1edb986827154768d89bbac0ba779984f
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Mon Mar 3 16:08:34 2008 -0800

    USB: replace remaining __FUNCTION__ occurrences
    
    __FUNCTION__ is gcc-specific, use __func__
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ipw.c b/drivers/usb/serial/ipw.c
index ec0ccd14e18e..bc85ca5c1c37 100644
--- a/drivers/usb/serial/ipw.c
+++ b/drivers/usb/serial/ipw.c
@@ -169,15 +169,15 @@ static void ipw_read_bulk_callback(struct urb *urb)
 	int result;
 	int status = urb->status;
 
-	dbg("%s - port %d", __FUNCTION__, port->number);
+	dbg("%s - port %d", __func__, port->number);
 
 	if (status) {
 		dbg("%s - nonzero read bulk status received: %d",
-		    __FUNCTION__, status);
+		    __func__, status);
 		return;
 	}
 
-	usb_serial_debug_data(debug, &port->dev, __FUNCTION__, urb->actual_length, data);
+	usb_serial_debug_data(debug, &port->dev, __func__, urb->actual_length, data);
 
 	tty = port->tty;
 	if (tty && urb->actual_length) {
@@ -195,7 +195,7 @@ static void ipw_read_bulk_callback(struct urb *urb)
 			   ipw_read_bulk_callback, port);
 	result = usb_submit_urb(port->read_urb, GFP_ATOMIC);
 	if (result)
-		dev_err(&port->dev, "%s - failed resubmitting read urb, error %d\n", __FUNCTION__, result);
+		dev_err(&port->dev, "%s - failed resubmitting read urb, error %d\n", __func__, result);
 	return;
 }
 
@@ -206,7 +206,7 @@ static int ipw_open(struct usb_serial_port *port, struct file *filp)
 	u8 *buf_flow_init;
 	int result;
 
-	dbg("%s", __FUNCTION__);
+	dbg("%s", __func__);
 
 	buf_flow_init = kmemdup(buf_flow_static, 16, GFP_KERNEL);
 	if (!buf_flow_init)
@@ -217,7 +217,7 @@ static int ipw_open(struct usb_serial_port *port, struct file *filp)
 
 	/* --1: Tell the modem to initialize (we think) From sniffs this is always the
 	 * first thing that gets sent to the modem during opening of the device */
-	dbg("%s: Sending SIO_INIT (we guess)",__FUNCTION__);
+	dbg("%s: Sending SIO_INIT (we guess)",__func__);
 	result = usb_control_msg(dev, usb_sndctrlpipe(dev,0),
 				 IPW_SIO_INIT,
 				 USB_TYPE_VENDOR | USB_RECIP_INTERFACE | USB_DIR_OUT,
@@ -234,7 +234,7 @@ static int ipw_open(struct usb_serial_port *port, struct file *filp)
 	usb_clear_halt(dev, usb_sndbulkpipe(dev, port->bulk_out_endpointAddress));
 
 	/*--2: Start reading from the device */	
-	dbg("%s: setting up bulk read callback",__FUNCTION__);
+	dbg("%s: setting up bulk read callback",__func__);
 	usb_fill_bulk_urb(port->read_urb, dev,
 			  usb_rcvbulkpipe(dev, port->bulk_in_endpointAddress),
 			  port->bulk_in_buffer,
@@ -242,10 +242,10 @@ static int ipw_open(struct usb_serial_port *port, struct file *filp)
 			  ipw_read_bulk_callback, port);
 	result = usb_submit_urb(port->read_urb, GFP_KERNEL);
 	if (result < 0)
-		dbg("%s - usb_submit_urb(read bulk) failed with status %d", __FUNCTION__, result);
+		dbg("%s - usb_submit_urb(read bulk) failed with status %d", __func__, result);
 
 	/*--3: Tell the modem to open the floodgates on the rx bulk channel */
-	dbg("%s:asking modem for RxRead (RXBULK_ON)",__FUNCTION__);
+	dbg("%s:asking modem for RxRead (RXBULK_ON)",__func__);
 	result = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
 				 IPW_SIO_RXCTL,
 				 USB_TYPE_VENDOR | USB_RECIP_INTERFACE | USB_DIR_OUT,
@@ -258,7 +258,7 @@ static int ipw_open(struct usb_serial_port *port, struct file *filp)
 		dev_err(&port->dev, "Enabling bulk RxRead failed (error = %d)\n", result);
 
 	/*--4: setup the initial flowcontrol */
-	dbg("%s:setting init flowcontrol (%s)",__FUNCTION__,buf_flow_init);
+	dbg("%s:setting init flowcontrol (%s)",__func__,buf_flow_init);
 	result = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
 				 IPW_SIO_HANDFLOW,
 				 USB_TYPE_VENDOR | USB_RECIP_INTERFACE | USB_DIR_OUT,
@@ -272,7 +272,7 @@ static int ipw_open(struct usb_serial_port *port, struct file *filp)
 
 
 	/*--5: raise the dtr */
-	dbg("%s:raising dtr",__FUNCTION__);
+	dbg("%s:raising dtr",__func__);
 	result = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
 				 IPW_SIO_SET_PIN,
 				 USB_TYPE_VENDOR | USB_RECIP_INTERFACE | USB_DIR_OUT,
@@ -285,7 +285,7 @@ static int ipw_open(struct usb_serial_port *port, struct file *filp)
 		dev_err(&port->dev, "setting dtr failed (error = %d)\n", result);
 
 	/*--6: raise the rts */
-	dbg("%s:raising rts",__FUNCTION__);
+	dbg("%s:raising rts",__func__);
 	result = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
 				 IPW_SIO_SET_PIN,
 				 USB_TYPE_VENDOR | USB_RECIP_INTERFACE | USB_DIR_OUT,
@@ -307,12 +307,12 @@ static void ipw_close(struct usb_serial_port *port, struct file * filp)
 	int result;
 
 	if (tty_hung_up_p(filp)) {
-		dbg("%s: tty_hung_up_p ...", __FUNCTION__);
+		dbg("%s: tty_hung_up_p ...", __func__);
 		return;
 	}
 
 	/*--1: drop the dtr */
-	dbg("%s:dropping dtr",__FUNCTION__);
+	dbg("%s:dropping dtr",__func__);
 	result = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
 				 IPW_SIO_SET_PIN,
 				 USB_TYPE_VENDOR | USB_RECIP_INTERFACE | USB_DIR_OUT,
@@ -325,7 +325,7 @@ static void ipw_close(struct usb_serial_port *port, struct file * filp)
 		dev_err(&port->dev, "dropping dtr failed (error = %d)\n", result);
 
 	/*--2: drop the rts */
-	dbg("%s:dropping rts",__FUNCTION__);
+	dbg("%s:dropping rts",__func__);
 	result = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
 				 IPW_SIO_SET_PIN, USB_TYPE_VENDOR | USB_RECIP_INTERFACE | USB_DIR_OUT,
 				 IPW_PIN_CLRRTS,
@@ -338,7 +338,7 @@ static void ipw_close(struct usb_serial_port *port, struct file * filp)
 
 
 	/*--3: purge */
-	dbg("%s:sending purge",__FUNCTION__);
+	dbg("%s:sending purge",__func__);
 	result = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
 				 IPW_SIO_PURGE, USB_TYPE_VENDOR | USB_RECIP_INTERFACE | USB_DIR_OUT,
 				 0x03,
@@ -373,13 +373,13 @@ static void ipw_write_bulk_callback(struct urb *urb)
 	struct usb_serial_port *port = urb->context;
 	int status = urb->status;
 
-	dbg("%s", __FUNCTION__);
+	dbg("%s", __func__);
 
 	port->write_urb_busy = 0;
 
 	if (status)
 		dbg("%s - nonzero write bulk status received: %d",
-		    __FUNCTION__, status);
+		    __func__, status);
 
 	usb_serial_port_softint(port);
 }
@@ -389,18 +389,18 @@ static int ipw_write(struct usb_serial_port *port, const unsigned char *buf, int
 	struct usb_device *dev = port->serial->dev;
 	int ret;
 
-	dbg("%s: TOP: count=%d, in_interrupt=%ld", __FUNCTION__,
+	dbg("%s: TOP: count=%d, in_interrupt=%ld", __func__,
 		count, in_interrupt() );
 
 	if (count == 0) {
-		dbg("%s - write request of 0 bytes", __FUNCTION__);
+		dbg("%s - write request of 0 bytes", __func__);
 		return 0;
 	}
 
 	spin_lock_bh(&port->lock);
 	if (port->write_urb_busy) {
 		spin_unlock_bh(&port->lock);
-		dbg("%s - already writing", __FUNCTION__);
+		dbg("%s - already writing", __func__);
 		return 0;
 	}
 	port->write_urb_busy = 1;
@@ -409,7 +409,7 @@ static int ipw_write(struct usb_serial_port *port, const unsigned char *buf, int
 	count = min(count, port->bulk_out_size);
 	memcpy(port->bulk_out_buffer, buf, count);
 
-	dbg("%s count now:%d", __FUNCTION__, count);
+	dbg("%s count now:%d", __func__, count);
 
 	usb_fill_bulk_urb(port->write_urb, dev,
 			  usb_sndbulkpipe(dev, port->bulk_out_endpointAddress),
@@ -421,11 +421,11 @@ static int ipw_write(struct usb_serial_port *port, const unsigned char *buf, int
 	ret = usb_submit_urb(port->write_urb, GFP_ATOMIC);
 	if (ret != 0) {
 		port->write_urb_busy = 0;
-		dbg("%s - usb_submit_urb(write bulk) failed with error = %d", __FUNCTION__, ret);
+		dbg("%s - usb_submit_urb(write bulk) failed with error = %d", __func__, ret);
 		return ret;
 	}
 
-	dbg("%s returning %d", __FUNCTION__, count);
+	dbg("%s returning %d", __func__, count);
 	return count;
 } 
 

commit 0ba4034e20abf372dae6c6cabeeeab600acb5889
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed Apr 16 09:17:38 2008 -0700

    USB: serial: remove unneeded number endpoints settings
    
    The usb-serial core no longer checks these fields so remove them from
    all of the individual drivers.  They will be removed from the usb-serial
    core in a patch later in the series.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ipw.c b/drivers/usb/serial/ipw.c
index cbe5530f3db2..ec0ccd14e18e 100644
--- a/drivers/usb/serial/ipw.c
+++ b/drivers/usb/serial/ipw.c
@@ -448,9 +448,6 @@ static struct usb_serial_driver ipw_device = {
 	.description =		"IPWireless converter",
 	.usb_driver = 		&usb_ipw_driver,
 	.id_table =		usb_ipw_ids,
-	.num_interrupt_in =	NUM_DONT_CARE,
-	.num_bulk_in =		1,
-	.num_bulk_out =		1,
 	.num_ports =		1,
 	.open =			ipw_open,
 	.close =		ipw_close,

commit 898eb71cb17644964c5895fb190e79e3d0c49679
Author: Joe Perches <joe@perches.com>
Date:   Thu Oct 18 03:06:30 2007 -0700

    Add missing newlines to some uses of dev_<level> messages
    
    Found these while looking at printk uses.
    
    Add missing newlines to dev_<level> uses
    Add missing KERN_<level> prefixes to multiline dev_<level>s
    Fixed a wierd->weird spelling typo
    Added a newline to a printk
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Cc: "Luck, Tony" <tony.luck@intel.com>
    Cc: Jens Axboe <jens.axboe@oracle.com>
    Cc: Mark M. Hoffman <mhoffman@lightlink.com>
    Cc: Roland Dreier <rolandd@cisco.com>
    Cc: Tilman Schmidt <tilman@imap.cc>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: Jeff Garzik <jeff@garzik.org>
    Cc: Stephen Hemminger <shemminger@linux-foundation.org>
    Cc: Greg KH <greg@kroah.com>
    Cc: Jeremy Fitzhardinge <jeremy@goop.org>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Alessandro Zummo <a.zummo@towertech.it>
    Cc: David Brownell <david-b@pacbell.net>
    Cc: James Smart <James.Smart@Emulex.Com>
    Cc: Andrew Vasquez <andrew.vasquez@qlogic.com>
    Cc: "Antonino A. Daplas" <adaplas@pol.net>
    Cc: Evgeniy Polyakov <johnpol@2ka.mipt.ru>
    Cc: Russell King <rmk@arm.linux.org.uk>
    Cc: Jaroslav Kysela <perex@suse.cz>
    Cc: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/usb/serial/ipw.c b/drivers/usb/serial/ipw.c
index 1b94daa61584..cbe5530f3db2 100644
--- a/drivers/usb/serial/ipw.c
+++ b/drivers/usb/serial/ipw.c
@@ -227,7 +227,7 @@ static int ipw_open(struct usb_serial_port *port, struct file *filp)
 				 0,
 				 100000);
 	if (result < 0)
-		dev_err(&port->dev, "Init of modem failed (error = %d)", result);
+		dev_err(&port->dev, "Init of modem failed (error = %d)\n", result);
 
 	/* reset the bulk pipes */
 	usb_clear_halt(dev, usb_rcvbulkpipe(dev, port->bulk_in_endpointAddress));
@@ -255,7 +255,7 @@ static int ipw_open(struct usb_serial_port *port, struct file *filp)
 				 0,
 				 100000);
 	if (result < 0) 
-		dev_err(&port->dev, "Enabling bulk RxRead failed (error = %d)", result);
+		dev_err(&port->dev, "Enabling bulk RxRead failed (error = %d)\n", result);
 
 	/*--4: setup the initial flowcontrol */
 	dbg("%s:setting init flowcontrol (%s)",__FUNCTION__,buf_flow_init);
@@ -268,7 +268,7 @@ static int ipw_open(struct usb_serial_port *port, struct file *filp)
 				 0x10,
 				 200000);
 	if (result < 0)
-		dev_err(&port->dev, "initial flowcontrol failed (error = %d)", result);
+		dev_err(&port->dev, "initial flowcontrol failed (error = %d)\n", result);
 
 
 	/*--5: raise the dtr */
@@ -282,7 +282,7 @@ static int ipw_open(struct usb_serial_port *port, struct file *filp)
 				 0,
 				 200000);
 	if (result < 0)
-		dev_err(&port->dev, "setting dtr failed (error = %d)", result);
+		dev_err(&port->dev, "setting dtr failed (error = %d)\n", result);
 
 	/*--6: raise the rts */
 	dbg("%s:raising rts",__FUNCTION__);
@@ -295,7 +295,7 @@ static int ipw_open(struct usb_serial_port *port, struct file *filp)
 				 0,
 				 200000);
 	if (result < 0)
-		dev_err(&port->dev, "setting dtr failed (error = %d)", result);
+		dev_err(&port->dev, "setting dtr failed (error = %d)\n", result);
 	
 	kfree(buf_flow_init);
 	return 0;
@@ -322,7 +322,7 @@ static void ipw_close(struct usb_serial_port *port, struct file * filp)
 				 0,
 				 200000);
 	if (result < 0)
-		dev_err(&port->dev, "dropping dtr failed (error = %d)", result);
+		dev_err(&port->dev, "dropping dtr failed (error = %d)\n", result);
 
 	/*--2: drop the rts */
 	dbg("%s:dropping rts",__FUNCTION__);
@@ -334,7 +334,7 @@ static void ipw_close(struct usb_serial_port *port, struct file * filp)
 				 0,
 				 200000);
 	if (result < 0)
-		dev_err(&port->dev, "dropping rts failed (error = %d)", result);
+		dev_err(&port->dev, "dropping rts failed (error = %d)\n", result);
 
 
 	/*--3: purge */
@@ -347,7 +347,7 @@ static void ipw_close(struct usb_serial_port *port, struct file * filp)
 				 0,
 				 200000);
 	if (result < 0)
-		dev_err(&port->dev, "purge failed (error = %d)", result);
+		dev_err(&port->dev, "purge failed (error = %d)\n", result);
 
 
 	/* send RXBULK_off (tell modem to stop transmitting bulk data on rx chan) */
@@ -361,7 +361,7 @@ static void ipw_close(struct usb_serial_port *port, struct file * filp)
 				 100000);
 
 	if (result < 0)
-		dev_err(&port->dev, "Disabling bulk RxRead failed (error = %d)", result);
+		dev_err(&port->dev, "Disabling bulk RxRead failed (error = %d)\n", result);
 
 	/* shutdown any in-flight urbs that we know about */
 	usb_kill_urb(port->read_urb);

commit b4a1579772667f9ebc0c9e26ed0b674966085e85
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Jun 15 15:44:13 2007 -0700

    USB: serial: ipw: clean up urb->status usage
    
    This done in anticipation of removal of urb->status, which will make
    that patch easier to review and apply in the future.
    
    
    Cc: <linux-usb-devel@lists.sourceforge.net>
    Cc: Roelf Diedericks <roelfd@inet.co.za>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ipw.c b/drivers/usb/serial/ipw.c
index 1bc586064c77..1b94daa61584 100644
--- a/drivers/usb/serial/ipw.c
+++ b/drivers/usb/serial/ipw.c
@@ -167,11 +167,13 @@ static void ipw_read_bulk_callback(struct urb *urb)
 	unsigned char *data = urb->transfer_buffer;
 	struct tty_struct *tty;
 	int result;
+	int status = urb->status;
 
 	dbg("%s - port %d", __FUNCTION__, port->number);
 
-	if (urb->status) {
-		dbg("%s - nonzero read bulk status received: %d", __FUNCTION__, urb->status);
+	if (status) {
+		dbg("%s - nonzero read bulk status received: %d",
+		    __FUNCTION__, status);
 		return;
 	}
 
@@ -369,13 +371,15 @@ static void ipw_close(struct usb_serial_port *port, struct file * filp)
 static void ipw_write_bulk_callback(struct urb *urb)
 {
 	struct usb_serial_port *port = urb->context;
+	int status = urb->status;
 
 	dbg("%s", __FUNCTION__);
 
 	port->write_urb_busy = 0;
 
-	if (urb->status)
-		dbg("%s - nonzero write bulk status received: %d", __FUNCTION__, urb->status);
+	if (status)
+		dbg("%s - nonzero write bulk status received: %d",
+		    __FUNCTION__, status);
 
 	usb_serial_port_softint(port);
 }

commit d9b1b787736852f462dbf277b3ca708cbbf693ae
Author: Johannes Hölzl <johannes.hoelzl@gmx.de>
Date:   Sun Dec 17 21:50:24 2006 +0100

    USB serial: add driver pointer to all usb-serial drivers
    
    Every usb serial driver should have a pointer to the corresponding usb driver.
    So the usb serial core can add a new id not only to the usb serial driver, but
    also to the usb driver.
    
    Also the usb drivers of ark3116, mos7720 and mos7840 missed the flag
    no_dynamic_id=1. This is added now.
    
    Signed-off-by: Johannes Hölzl <johannes.hoelzl@gmx.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ipw.c b/drivers/usb/serial/ipw.c
index d3b9a351cef8..1bc586064c77 100644
--- a/drivers/usb/serial/ipw.c
+++ b/drivers/usb/serial/ipw.c
@@ -442,6 +442,7 @@ static struct usb_serial_driver ipw_device = {
 		.name =		"ipw",
 	},
 	.description =		"IPWireless converter",
+	.usb_driver = 		&usb_ipw_driver,
 	.id_table =		usb_ipw_ids,
 	.num_interrupt_in =	NUM_DONT_CARE,
 	.num_bulk_in =		1,

commit 5d7efe5b3768bf53df9b87380ea68baacf11f933
Author: Eric Sesterhenn <snakebyte@gmx.de>
Date:   Thu Oct 26 21:06:24 2006 +0200

    USB: kmemdup() cleanup in drivers/usb/
    
    replace open coded kmemdup() to save some screen space,
    and allow inlining/not inlining to be triggered by gcc.
    
    Signed-off-by: Eric Sesterhenn <snakebyte@gmx.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ipw.c b/drivers/usb/serial/ipw.c
index 2a4bb66691ad..d3b9a351cef8 100644
--- a/drivers/usb/serial/ipw.c
+++ b/drivers/usb/serial/ipw.c
@@ -206,10 +206,9 @@ static int ipw_open(struct usb_serial_port *port, struct file *filp)
 
 	dbg("%s", __FUNCTION__);
 
-	buf_flow_init = kmalloc(16, GFP_KERNEL);
+	buf_flow_init = kmemdup(buf_flow_static, 16, GFP_KERNEL);
 	if (!buf_flow_init)
 		return -ENOMEM;
-	memcpy(buf_flow_init, buf_flow_static, 16);
 
 	if (port->tty)
 		port->tty->low_latency = 1;

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/drivers/usb/serial/ipw.c b/drivers/usb/serial/ipw.c
index 812bc213a963..2a4bb66691ad 100644
--- a/drivers/usb/serial/ipw.c
+++ b/drivers/usb/serial/ipw.c
@@ -161,7 +161,7 @@ static struct usb_driver usb_ipw_driver = {
 
 static int debug;
 
-static void ipw_read_bulk_callback(struct urb *urb, struct pt_regs *regs)
+static void ipw_read_bulk_callback(struct urb *urb)
 {
 	struct usb_serial_port *port = urb->context;
 	unsigned char *data = urb->transfer_buffer;
@@ -367,7 +367,7 @@ static void ipw_close(struct usb_serial_port *port, struct file * filp)
 	usb_kill_urb(port->write_urb);
 }
 
-static void ipw_write_bulk_callback(struct urb *urb, struct pt_regs *regs)
+static void ipw_write_bulk_callback(struct urb *urb)
 {
 	struct usb_serial_port *port = urb->context;
 

commit e81ee637e4aed723f71007c90a901268317ed6d6
Author: Peter Zijlstra <a.p.zijlstra@chello.nl>
Date:   Mon Sep 25 12:51:41 2006 +0200

    usb-serial: possible irq lock inversion (PPP vs. usb/serial)
    
    =========================================================
    [ INFO: possible irq lock inversion dependency detected ]

diff --git a/drivers/usb/serial/ipw.c b/drivers/usb/serial/ipw.c
index 87306cb6f9f5..812bc213a963 100644
--- a/drivers/usb/serial/ipw.c
+++ b/drivers/usb/serial/ipw.c
@@ -394,14 +394,14 @@ static int ipw_write(struct usb_serial_port *port, const unsigned char *buf, int
 		return 0;
 	}
 
-	spin_lock(&port->lock);
+	spin_lock_bh(&port->lock);
 	if (port->write_urb_busy) {
-		spin_unlock(&port->lock);
+		spin_unlock_bh(&port->lock);
 		dbg("%s - already writing", __FUNCTION__);
 		return 0;
 	}
 	port->write_urb_busy = 1;
-	spin_unlock(&port->lock);
+	spin_unlock_bh(&port->lock);
 
 	count = min(count, port->bulk_out_size);
 	memcpy(port->bulk_out_buffer, buf, count);

commit a969888ce91673c7f4b86520d851a6f0d5a5fa7d
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Jul 11 21:22:58 2006 -0700

    [PATCH] USB: move usb-serial.h to include/linux/usb/
    
    USB serial outside of the kernel tree can not build properly due to
    usb-serial.h being buried down in the source tree.  This patch moves the
    location of the file to include/linux/usb and fixes up all of the usb
    serial drivers to handle the move properly.
    
    Cc: Sergei Organov <osv@javad.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ipw.c b/drivers/usb/serial/ipw.c
index 4d5275e4dead..87306cb6f9f5 100644
--- a/drivers/usb/serial/ipw.c
+++ b/drivers/usb/serial/ipw.c
@@ -46,8 +46,8 @@
 #include <linux/module.h>
 #include <linux/spinlock.h>
 #include <linux/usb.h>
+#include <linux/usb/serial.h>
 #include <asm/uaccess.h>
-#include "usb-serial.h"
 
 /*
  * Version Information

commit b2f1b0d4649a6597c7320bf359e71014653c630d
Author: Bart Oldeman <bartoldeman@users.sourceforge.net>
Date:   Sun Jul 2 15:07:10 2006 +1200

    [PATCH] USB: ipw.c driver fix
    
    The below patch fixes the ipw module in kernel 2.6.17 for me; without
    this change it simply does not work at all (all but the first writes are
    refused because write_urb_busy is always 1).
    
    This problem was there in 2.6.15 as well, but at that point I used the
    (updated) ipw.c, version 0.4, from
    http://www.neology.co.za/products/opensource/ipwireless/ which no longer
    compiles with 2.6.17. It can be made to after a few changes but
    obviously it's easier if the built-in ipw driver works instead of having
    to download one from the neology site.
    
    From: Bart Oldeman <bartoldeman@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ipw.c b/drivers/usb/serial/ipw.c
index a4a0bfeaab00..4d5275e4dead 100644
--- a/drivers/usb/serial/ipw.c
+++ b/drivers/usb/serial/ipw.c
@@ -373,6 +373,8 @@ static void ipw_write_bulk_callback(struct urb *urb, struct pt_regs *regs)
 
 	dbg("%s", __FUNCTION__);
 
+	port->write_urb_busy = 0;
+
 	if (urb->status)
 		dbg("%s - nonzero write bulk status received: %d", __FUNCTION__, urb->status);
 

commit cf2c7481d2ff7f0c266de873b2fe93883e9782f9
Author: Pete Zaitcev <zaitcev@redhat.com>
Date:   Mon May 22 21:58:49 2006 -0700

    [PATCH] USB serial: encapsulate schedule_work, remove double-calling
    
    I'm going to throw schedule_work away, it's retarded. But for starters,
    let's have it encapsulated.
    
    Also, generic and whiteheat were both calling usb_serial_port_softint
    and scheduled work. Only one was necessary.
    
    Signed-off-by: Pete Zaitcev <zaitcev@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ipw.c b/drivers/usb/serial/ipw.c
index e760a70242c1..a4a0bfeaab00 100644
--- a/drivers/usb/serial/ipw.c
+++ b/drivers/usb/serial/ipw.c
@@ -376,7 +376,7 @@ static void ipw_write_bulk_callback(struct urb *urb, struct pt_regs *regs)
 	if (urb->status)
 		dbg("%s - nonzero write bulk status received: %d", __FUNCTION__, urb->status);
 
-	schedule_work(&port->work);
+	usb_serial_port_softint(port);
 }
 
 static int ipw_write(struct usb_serial_port *port, const unsigned char *buf, int count)

commit 33f0f88f1c51ae5c2d593d26960c760ea154c2e2
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Mon Jan 9 20:54:13 2006 -0800

    [PATCH] TTY layer buffering revamp
    
    The API and code have been through various bits of initial review by
    serial driver people but they definitely need to live somewhere for a
    while so the unconverted drivers can get knocked into shape, existing
    drivers that have been updated can be better tuned and bugs whacked out.
    
    This replaces the tty flip buffers with kmalloc objects in rings. In the
    normal situation for an IRQ driven serial port at typical speeds the
    behaviour is pretty much the same, two buffers end up allocated and the
    kernel cycles between them as before.
    
    When there are delays or at high speed we now behave far better as the
    buffer pool can grow a bit rather than lose characters. This also means
    that we can operate at higher speeds reliably.
    
    For drivers that receive characters in blocks (DMA based, USB and
    especially virtualisation) the layer allows a lot of driver specific
    code that works around the tty layer with private secondary queues to be
    removed. The IBM folks need this sort of layer, the smart serial port
    people do, the virtualisers do (because a virtualised tty typically
    operates at infinite speed rather than emulating 9600 baud).
    
    Finally many drivers had invalid and unsafe attempts to avoid buffer
    overflows by directly invoking tty methods extracted out of the innards
    of work queue structs. These are no longer needed and all go away. That
    fixes various random hangs with serial ports on overflow.
    
    The other change in here is to optimise the receive_room path that is
    used by some callers. It turns out that only one ldisc uses receive room
    except asa constant and it updates it far far less than the value is
    read. We thus make it a variable not a function call.
    
    I expect the code to contain bugs due to the size alone but I'll be
    watching and squashing them and feeding out new patches as it goes.
    
    Because the buffers now dynamically expand you should only run out of
    buffering when the kernel runs out of memory for real.  That means a lot of
    the horrible hacks high performance drivers used to do just aren't needed any
    more.
    
    Description:
    
    tty_insert_flip_char is an old API and continues to work as before, as does
    tty_flip_buffer_push() [this is why many drivers dont need modification].  It
    does now also return the number of chars inserted
    
    There are also
    
    tty_buffer_request_room(tty, len)
    
    which asks for a buffer block of the length requested and returns the space
    found.  This improves efficiency with hardware that knows how much to
    transfer.
    
    and tty_insert_flip_string_flags(tty, str, flags, len)
    
    to insert a string of characters and flags
    
    For a smart interface the usual code is
    
        len = tty_request_buffer_room(tty, amount_hardware_says);
        tty_insert_flip_string(tty, buffer_from_card, len);
    
    More description!
    
    At the moment tty buffers are attached directly to the tty.  This is causing a
    lot of the problems related to tty layer locking, also problems at high speed
    and also with bursty data (such as occurs in virtualised environments)
    
    I'm working on ripping out the flip buffers and replacing them with a pool of
    dynamically allocated buffers.  This allows both for old style "byte I/O"
    devices and also helps virtualisation and smart devices where large blocks of
    data suddenely materialise and need storing.
    
    So far so good.  Lots of drivers reference tty->flip.*.  Several of them also
    call directly and unsafely into function pointers it provides.  This will all
    break.  Most drivers can use tty_insert_flip_char which can be kept as an API
    but others need more.
    
    At the moment I've added the following interfaces, if people think more will
    be needed now is a good time to say
    
     int tty_buffer_request_room(tty, size)
    
    Try and ensure at least size bytes are available, returns actual room (may be
    zero).  At the moment it just uses the flipbuf space but that will change.
    Repeated calls without characters being added are not cumulative.  (ie if you
    call it with 1, 1, 1, and then 4 you'll have four characters of space.  The
    other functions will also try and grow buffers in future but this will be a
    more efficient way when you know block sizes.
    
     int tty_insert_flip_char(tty, ch, flag)
    
    As before insert a character if there is room.  Now returns 1 for success, 0
    for failure.
    
     int tty_insert_flip_string(tty, str, len)
    
    Insert a block of non error characters.  Returns the number inserted.
    
     int tty_prepare_flip_string(tty, strptr, len)
    
    Adjust the buffer to allow len characters to be added.  Returns a buffer
    pointer in strptr and the length available.  This allows for hardware that
    needs to use functions like insl or mencpy_fromio.
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Cc: Paul Fulghum <paulkf@microgate.com>
    Signed-off-by: Hirokazu Takata <takata@linux-m32r.org>
    Signed-off-by: Serge Hallyn <serue@us.ibm.com>
    Signed-off-by: Jeff Dike <jdike@addtoit.com>
    Signed-off-by: John Hawkes <hawkes@sgi.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/usb/serial/ipw.c b/drivers/usb/serial/ipw.c
index 2dd191f5fe76..e760a70242c1 100644
--- a/drivers/usb/serial/ipw.c
+++ b/drivers/usb/serial/ipw.c
@@ -166,7 +166,6 @@ static void ipw_read_bulk_callback(struct urb *urb, struct pt_regs *regs)
 	struct usb_serial_port *port = urb->context;
 	unsigned char *data = urb->transfer_buffer;
 	struct tty_struct *tty;
-	int i;
 	int result;
 
 	dbg("%s - port %d", __FUNCTION__, port->number);
@@ -180,14 +179,8 @@ static void ipw_read_bulk_callback(struct urb *urb, struct pt_regs *regs)
 
 	tty = port->tty;
 	if (tty && urb->actual_length) {
-		for (i = 0; i < urb->actual_length ; ++i) {
-			/* if we insert more than TTY_FLIPBUF_SIZE characters, we drop them. */
-			if(tty->flip.count >= TTY_FLIPBUF_SIZE) {
-				tty_flip_buffer_push(tty);
-			}
-			/* this doesn't actually push the data through unless tty->low_latency is set */
-			tty_insert_flip_char(tty, data[i], 0);
-		}
+		tty_buffer_request_room(tty, urb->actual_length);
+		tty_insert_flip_string(tty, data, urb->actual_length);
 		tty_flip_buffer_push(tty);
 	}
 

commit 75318d2d7cab77b14c5d3dbd5e69f2680a769e16
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Nov 21 14:53:03 2005 -0800

    [PATCH] USB: remove .owner field from struct usb_driver
    
    It is no longer needed, so let's remove it, saving a bit of memory.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ipw.c b/drivers/usb/serial/ipw.c
index 64e2cda2a84a..2dd191f5fe76 100644
--- a/drivers/usb/serial/ipw.c
+++ b/drivers/usb/serial/ipw.c
@@ -152,7 +152,6 @@ static struct usb_device_id usb_ipw_ids[] = {
 MODULE_DEVICE_TABLE(usb, usb_ipw_ids);
 
 static struct usb_driver usb_ipw_driver = {
-	.owner =	THIS_MODULE,
 	.name =		"ipwtty",
 	.probe =	usb_serial_probe,
 	.disconnect =	usb_serial_disconnect,

commit ba9dc657af86d05d2971633e57d1f6f94ed60472
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed Nov 16 13:41:28 2005 -0800

    [PATCH] USB: allow usb drivers to disable dynamic ids
    
    This lets drivers, like the usb-serial ones, disable the ability to add
    ids from sysfs.
    
    The usb-serial drivers are "odd" in that they are really usb-serial bus
    drivers, not usb bus drivers, so the dynamic id logic will have to go
    into the usb-serial bus core for those drivers to get that ability.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ipw.c b/drivers/usb/serial/ipw.c
index 7744b8148bc5..64e2cda2a84a 100644
--- a/drivers/usb/serial/ipw.c
+++ b/drivers/usb/serial/ipw.c
@@ -157,6 +157,7 @@ static struct usb_driver usb_ipw_driver = {
 	.probe =	usb_serial_probe,
 	.disconnect =	usb_serial_disconnect,
 	.id_table =	usb_ipw_ids,
+	.no_dynamic_id = 	1,
 };
 
 static int debug;

commit 569cfaadb0ea21bfcedac85dbc5147b4a9ed42d2
Author: Nicolas Kaiser <nikai@nikai.net>
Date:   Wed Nov 23 15:45:58 2005 -0800

    [PATCH] usb serial: remove redundant include
    
    remove redundant include
    
    Signed-off-by: Nicolas Kaiser <nikai@nikai.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/usb/serial/ipw.c b/drivers/usb/serial/ipw.c
index a02fada85362..7744b8148bc5 100644
--- a/drivers/usb/serial/ipw.c
+++ b/drivers/usb/serial/ipw.c
@@ -46,7 +46,6 @@
 #include <linux/module.h>
 #include <linux/spinlock.h>
 #include <linux/usb.h>
-#include <linux/usb.h>
 #include <asm/uaccess.h>
 #include "usb-serial.h"
 

commit 269bda1c123c7caf88e1deb2264f9086f0344192
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Jun 20 21:15:16 2005 -0700

    [PATCH] USB Serial: move name to driver structure
    
    This fixes up a lot of problems in sysfs with some of the usb serial
    drivers, they had incorrect driver names.  Also saves a tiny ammount
    of memory.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ipw.c b/drivers/usb/serial/ipw.c
index 2ba69623ac05..a02fada85362 100644
--- a/drivers/usb/serial/ipw.c
+++ b/drivers/usb/serial/ipw.c
@@ -446,9 +446,9 @@ static int ipw_disconnect(struct usb_serial_port *port)
 static struct usb_serial_driver ipw_device = {
 	.driver = {
 		.owner =	THIS_MODULE,
+		.name =		"ipw",
 	},
-	.name =			"IPWireless converter",
-	.short_name =		"ipw",
+	.description =		"IPWireless converter",
 	.id_table =		usb_ipw_ids,
 	.num_interrupt_in =	NUM_DONT_CARE,
 	.num_bulk_in =		1,

commit 18fcac353fdc7cd072b0d24c8667042e675a4c11
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Jun 20 21:15:16 2005 -0700

    [PATCH] USB Serial: get rid of the .owner field in usb_serial_driver
    
    Don't duplicate something that's already in struct driver.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ipw.c b/drivers/usb/serial/ipw.c
index 04524d34de3b..2ba69623ac05 100644
--- a/drivers/usb/serial/ipw.c
+++ b/drivers/usb/serial/ipw.c
@@ -444,7 +444,9 @@ static int ipw_disconnect(struct usb_serial_port *port)
 }
 
 static struct usb_serial_driver ipw_device = {
-	.owner =		THIS_MODULE,
+	.driver = {
+		.owner =	THIS_MODULE,
+	},
 	.name =			"IPWireless converter",
 	.short_name =		"ipw",
 	.id_table =		usb_ipw_ids,

commit ea65370d025f5005649e5cb37c4d025e92c6fc38
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Jun 20 21:15:16 2005 -0700

    [PATCH] USB Serial: rename usb_serial_device_type to usb_serial_driver
    
    I'm tired of trying to explain why a "device_type" is really a driver.
    This better describes exactly what this structure is.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ipw.c b/drivers/usb/serial/ipw.c
index 85e242459c27..04524d34de3b 100644
--- a/drivers/usb/serial/ipw.c
+++ b/drivers/usb/serial/ipw.c
@@ -443,7 +443,7 @@ static int ipw_disconnect(struct usb_serial_port *port)
 	return 0;
 }
 
-static struct usb_serial_device_type ipw_device = {
+static struct usb_serial_driver ipw_device = {
 	.owner =		THIS_MODULE,
 	.name =			"IPWireless converter",
 	.short_name =		"ipw",

commit 507ca9bc0476662f3463888d583864834eab1e11
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Sat Apr 23 12:49:16 2005 -0700

    [PATCH] USB: add ability for usb-serial drivers to determine if their write urb is currently being used.
    
    This removes a lot of racy and buggy code by trying to check the status of the urb.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ipw.c b/drivers/usb/serial/ipw.c
index 11105d74f461..85e242459c27 100644
--- a/drivers/usb/serial/ipw.c
+++ b/drivers/usb/serial/ipw.c
@@ -399,16 +399,21 @@ static int ipw_write(struct usb_serial_port *port, const unsigned char *buf, int
 		dbg("%s - write request of 0 bytes", __FUNCTION__);
 		return 0;
 	}
-	
-	/* Racy and broken, FIXME properly! */
-	if (port->write_urb->status == -EINPROGRESS)
+
+	spin_lock(&port->lock);
+	if (port->write_urb_busy) {
+		spin_unlock(&port->lock);
+		dbg("%s - already writing", __FUNCTION__);
 		return 0;
+	}
+	port->write_urb_busy = 1;
+	spin_unlock(&port->lock);
 
 	count = min(count, port->bulk_out_size);
 	memcpy(port->bulk_out_buffer, buf, count);
 
 	dbg("%s count now:%d", __FUNCTION__, count);
-	
+
 	usb_fill_bulk_urb(port->write_urb, dev,
 			  usb_sndbulkpipe(dev, port->bulk_out_endpointAddress),
 			  port->write_urb->transfer_buffer,
@@ -418,6 +423,7 @@ static int ipw_write(struct usb_serial_port *port, const unsigned char *buf, int
 
 	ret = usb_submit_urb(port->write_urb, GFP_ATOMIC);
 	if (ret != 0) {
+		port->write_urb_busy = 0;
 		dbg("%s - usb_submit_urb(write bulk) failed with error = %d", __FUNCTION__, ret);
 		return ret;
 	}

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/usb/serial/ipw.c b/drivers/usb/serial/ipw.c
new file mode 100644
index 000000000000..11105d74f461
--- /dev/null
+++ b/drivers/usb/serial/ipw.c
@@ -0,0 +1,491 @@
+/*
+ * IPWireless 3G UMTS TDD Modem driver (USB connected)
+ *
+ *   Copyright (C) 2004 Roelf Diedericks <roelfd@inet.co.za>
+ *   Copyright (C) 2004 Greg Kroah-Hartman <greg@kroah.com>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ * All information about the device was acquired using SnoopyPro
+ * on MSFT's O/S, and examing the MSFT drivers' debug output 
+ * (insanely left _on_ in the enduser version)
+ *
+ * It was written out of frustration with the IPWireless USB modem
+ * supplied by Axity3G/Sentech South Africa not supporting
+ * Linux whatsoever.
+ *
+ * Nobody provided any proprietary information that was not already 
+ * available for this device.
+ * 
+ * The modem adheres to the "3GPP TS  27.007 AT command set for 3G 
+ * User Equipment (UE)" standard, available from 
+ * http://www.3gpp.org/ftp/Specs/html-info/27007.htm
+ *
+ * The code was only tested the IPWireless handheld modem distributed
+ * in South Africa by Sentech.
+ * 
+ * It may work for Woosh Inc in .nz too, as it appears they use the
+ * same kit.
+ *
+ * There is still some work to be done in terms of handling 
+ * DCD, DTR, RTS, CTS which are currently faked.
+ * It's good enough for PPP at this point. It's based off all kinds of
+ * code found in usb/serial and usb/class
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/module.h>
+#include <linux/spinlock.h>
+#include <linux/usb.h>
+#include <linux/usb.h>
+#include <asm/uaccess.h>
+#include "usb-serial.h"
+
+/*
+ * Version Information
+ */
+#define DRIVER_VERSION	"v0.3"
+#define DRIVER_AUTHOR	"Roelf Diedericks"
+#define DRIVER_DESC	"IPWireless tty driver"
+
+#define IPW_TTY_MAJOR	240	/* real device node major id, experimental range */
+#define IPW_TTY_MINORS	256	/* we support 256 devices, dunno why, it'd be insane :) */
+
+#define USB_IPW_MAGIC	0x6d02	/* magic number for ipw struct */
+
+
+/* Message sizes */
+#define EVENT_BUFFER_SIZE	0xFF
+#define CHAR2INT16(c1,c0)	(((u32)((c1) & 0xff) << 8) + (u32)((c0) & 0xff))
+#define NUM_BULK_URBS		24
+#define NUM_CONTROL_URBS	16
+
+/* vendor/product pairs that are known work with this driver*/
+#define IPW_VID		0x0bc3
+#define IPW_PID		0x0001
+
+
+/* Vendor commands: */
+
+/* baud rates */
+enum {
+	ipw_sio_b256000 = 0x000e,
+	ipw_sio_b128000 = 0x001d,
+	ipw_sio_b115200 = 0x0020,
+	ipw_sio_b57600  = 0x0040,
+	ipw_sio_b56000  = 0x0042,
+	ipw_sio_b38400  = 0x0060,
+	ipw_sio_b19200  = 0x00c0,
+	ipw_sio_b14400  = 0x0100,
+	ipw_sio_b9600   = 0x0180,
+	ipw_sio_b4800   = 0x0300,
+	ipw_sio_b2400   = 0x0600,
+	ipw_sio_b1200   = 0x0c00,
+	ipw_sio_b600    = 0x1800
+};
+
+/* data bits */
+#define ipw_dtb_7		0x700
+#define ipw_dtb_8		0x810	// ok so the define is misleading, I know, but forces 8,n,1
+					// I mean, is there a point to any other setting these days? :)	
+
+/* usb control request types : */
+#define IPW_SIO_RXCTL		0x00	// control bulk rx channel transmissions, value=1/0 (on/off)
+#define IPW_SIO_SET_BAUD	0x01	// set baud, value=requested ipw_sio_bxxxx
+#define IPW_SIO_SET_LINE	0x03	// set databits, parity. value=ipw_dtb_x
+#define IPW_SIO_SET_PIN		0x03	// set/clear dtr/rts value=ipw_pin_xxx
+#define IPW_SIO_POLL		0x08	// get serial port status byte, call with value=0
+#define IPW_SIO_INIT		0x11	// initializes ? value=0 (appears as first thing todo on open)
+#define IPW_SIO_PURGE		0x12	// purge all transmissions?, call with value=numchar_to_purge
+#define IPW_SIO_HANDFLOW	0x13	// set xon/xoff limits value=0, and a buffer of 0x10 bytes
+#define IPW_SIO_SETCHARS	0x13	// set the flowcontrol special chars, value=0, buf=6 bytes, 
+					// last 2 bytes contain flowcontrol chars e.g. 00 00 00 00 11 13
+
+/* values used for request IPW_SIO_SET_PIN */
+#define IPW_PIN_SETDTR		0x101
+#define IPW_PIN_SETRTS		0x202
+#define IPW_PIN_CLRDTR		0x100
+#define IPW_PIN_CLRRTS		0x200 // unconfirmed
+
+/* values used for request IPW_SIO_RXCTL */
+#define IPW_RXBULK_ON		1
+#define IPW_RXBULK_OFF		0
+
+/* various 16 byte hardcoded transferbuffers used by flow control */
+#define IPW_BYTES_FLOWINIT	{ 0x01, 0, 0, 0, 0x40, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
+
+/* Interpretation of modem status lines */
+/* These need sorting out by individually connecting pins and checking
+ * results. FIXME!
+ * When data is being sent we see 0x30 in the lower byte; this must
+ * contain DSR and CTS ...
+ */
+#define IPW_DSR			((1<<4) | (1<<5))
+#define IPW_CTS			((1<<5) | (1<<4))
+
+#define IPW_WANTS_TO_SEND	0x30
+//#define IPW_DTR			/* Data Terminal Ready */
+//#define IPW_CTS			/* Clear To Send */
+//#define IPW_CD			/* Carrier Detect */
+//#define IPW_DSR			/* Data Set Ready */
+//#define IPW_RxD			/* Receive pin */
+
+//#define IPW_LE
+//#define IPW_RTS		
+//#define IPW_ST		
+//#define IPW_SR		
+//#define IPW_RI			/* Ring Indicator */
+
+static struct usb_device_id usb_ipw_ids[] = {
+	{ USB_DEVICE(IPW_VID, IPW_PID) },
+	{ },
+};
+
+MODULE_DEVICE_TABLE(usb, usb_ipw_ids);
+
+static struct usb_driver usb_ipw_driver = {
+	.owner =	THIS_MODULE,
+	.name =		"ipwtty",
+	.probe =	usb_serial_probe,
+	.disconnect =	usb_serial_disconnect,
+	.id_table =	usb_ipw_ids,
+};
+
+static int debug;
+
+static void ipw_read_bulk_callback(struct urb *urb, struct pt_regs *regs)
+{
+	struct usb_serial_port *port = urb->context;
+	unsigned char *data = urb->transfer_buffer;
+	struct tty_struct *tty;
+	int i;
+	int result;
+
+	dbg("%s - port %d", __FUNCTION__, port->number);
+
+	if (urb->status) {
+		dbg("%s - nonzero read bulk status received: %d", __FUNCTION__, urb->status);
+		return;
+	}
+
+	usb_serial_debug_data(debug, &port->dev, __FUNCTION__, urb->actual_length, data);
+
+	tty = port->tty;
+	if (tty && urb->actual_length) {
+		for (i = 0; i < urb->actual_length ; ++i) {
+			/* if we insert more than TTY_FLIPBUF_SIZE characters, we drop them. */
+			if(tty->flip.count >= TTY_FLIPBUF_SIZE) {
+				tty_flip_buffer_push(tty);
+			}
+			/* this doesn't actually push the data through unless tty->low_latency is set */
+			tty_insert_flip_char(tty, data[i], 0);
+		}
+		tty_flip_buffer_push(tty);
+	}
+
+	/* Continue trying to always read  */
+	usb_fill_bulk_urb (port->read_urb, port->serial->dev,
+			   usb_rcvbulkpipe(port->serial->dev,
+					   port->bulk_in_endpointAddress),
+			   port->read_urb->transfer_buffer,
+			   port->read_urb->transfer_buffer_length,
+			   ipw_read_bulk_callback, port);
+	result = usb_submit_urb(port->read_urb, GFP_ATOMIC);
+	if (result)
+		dev_err(&port->dev, "%s - failed resubmitting read urb, error %d\n", __FUNCTION__, result);
+	return;
+}
+
+static int ipw_open(struct usb_serial_port *port, struct file *filp)
+{
+	struct usb_device *dev = port->serial->dev;
+	u8 buf_flow_static[16] = IPW_BYTES_FLOWINIT;
+	u8 *buf_flow_init;
+	int result;
+
+	dbg("%s", __FUNCTION__);
+
+	buf_flow_init = kmalloc(16, GFP_KERNEL);
+	if (!buf_flow_init)
+		return -ENOMEM;
+	memcpy(buf_flow_init, buf_flow_static, 16);
+
+	if (port->tty)
+		port->tty->low_latency = 1;
+
+	/* --1: Tell the modem to initialize (we think) From sniffs this is always the
+	 * first thing that gets sent to the modem during opening of the device */
+	dbg("%s: Sending SIO_INIT (we guess)",__FUNCTION__);
+	result = usb_control_msg(dev, usb_sndctrlpipe(dev,0),
+				 IPW_SIO_INIT,
+				 USB_TYPE_VENDOR | USB_RECIP_INTERFACE | USB_DIR_OUT,
+				 0,
+				 0, /* index */
+				 NULL,
+				 0,
+				 100000);
+	if (result < 0)
+		dev_err(&port->dev, "Init of modem failed (error = %d)", result);
+
+	/* reset the bulk pipes */
+	usb_clear_halt(dev, usb_rcvbulkpipe(dev, port->bulk_in_endpointAddress));
+	usb_clear_halt(dev, usb_sndbulkpipe(dev, port->bulk_out_endpointAddress));
+
+	/*--2: Start reading from the device */	
+	dbg("%s: setting up bulk read callback",__FUNCTION__);
+	usb_fill_bulk_urb(port->read_urb, dev,
+			  usb_rcvbulkpipe(dev, port->bulk_in_endpointAddress),
+			  port->bulk_in_buffer,
+			  port->bulk_in_size,
+			  ipw_read_bulk_callback, port);
+	result = usb_submit_urb(port->read_urb, GFP_KERNEL);
+	if (result < 0)
+		dbg("%s - usb_submit_urb(read bulk) failed with status %d", __FUNCTION__, result);
+
+	/*--3: Tell the modem to open the floodgates on the rx bulk channel */
+	dbg("%s:asking modem for RxRead (RXBULK_ON)",__FUNCTION__);
+	result = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
+				 IPW_SIO_RXCTL,
+				 USB_TYPE_VENDOR | USB_RECIP_INTERFACE | USB_DIR_OUT,
+				 IPW_RXBULK_ON,
+				 0, /* index */
+				 NULL,
+				 0,
+				 100000);
+	if (result < 0) 
+		dev_err(&port->dev, "Enabling bulk RxRead failed (error = %d)", result);
+
+	/*--4: setup the initial flowcontrol */
+	dbg("%s:setting init flowcontrol (%s)",__FUNCTION__,buf_flow_init);
+	result = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
+				 IPW_SIO_HANDFLOW,
+				 USB_TYPE_VENDOR | USB_RECIP_INTERFACE | USB_DIR_OUT,
+				 0,
+				 0,
+				 buf_flow_init,
+				 0x10,
+				 200000);
+	if (result < 0)
+		dev_err(&port->dev, "initial flowcontrol failed (error = %d)", result);
+
+
+	/*--5: raise the dtr */
+	dbg("%s:raising dtr",__FUNCTION__);
+	result = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
+				 IPW_SIO_SET_PIN,
+				 USB_TYPE_VENDOR | USB_RECIP_INTERFACE | USB_DIR_OUT,
+				 IPW_PIN_SETDTR,
+				 0,
+				 NULL,
+				 0,
+				 200000);
+	if (result < 0)
+		dev_err(&port->dev, "setting dtr failed (error = %d)", result);
+
+	/*--6: raise the rts */
+	dbg("%s:raising rts",__FUNCTION__);
+	result = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
+				 IPW_SIO_SET_PIN,
+				 USB_TYPE_VENDOR | USB_RECIP_INTERFACE | USB_DIR_OUT,
+				 IPW_PIN_SETRTS,
+				 0,
+				 NULL,
+				 0,
+				 200000);
+	if (result < 0)
+		dev_err(&port->dev, "setting dtr failed (error = %d)", result);
+	
+	kfree(buf_flow_init);
+	return 0;
+}
+
+static void ipw_close(struct usb_serial_port *port, struct file * filp)
+{
+	struct usb_device *dev = port->serial->dev;
+	int result;
+
+	if (tty_hung_up_p(filp)) {
+		dbg("%s: tty_hung_up_p ...", __FUNCTION__);
+		return;
+	}
+
+	/*--1: drop the dtr */
+	dbg("%s:dropping dtr",__FUNCTION__);
+	result = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
+				 IPW_SIO_SET_PIN,
+				 USB_TYPE_VENDOR | USB_RECIP_INTERFACE | USB_DIR_OUT,
+				 IPW_PIN_CLRDTR,
+				 0,
+				 NULL,
+				 0,
+				 200000);
+	if (result < 0)
+		dev_err(&port->dev, "dropping dtr failed (error = %d)", result);
+
+	/*--2: drop the rts */
+	dbg("%s:dropping rts",__FUNCTION__);
+	result = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
+				 IPW_SIO_SET_PIN, USB_TYPE_VENDOR | USB_RECIP_INTERFACE | USB_DIR_OUT,
+				 IPW_PIN_CLRRTS,
+				 0,
+				 NULL,
+				 0,
+				 200000);
+	if (result < 0)
+		dev_err(&port->dev, "dropping rts failed (error = %d)", result);
+
+
+	/*--3: purge */
+	dbg("%s:sending purge",__FUNCTION__);
+	result = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
+				 IPW_SIO_PURGE, USB_TYPE_VENDOR | USB_RECIP_INTERFACE | USB_DIR_OUT,
+				 0x03,
+				 0,
+				 NULL,
+				 0,
+				 200000);
+	if (result < 0)
+		dev_err(&port->dev, "purge failed (error = %d)", result);
+
+
+	/* send RXBULK_off (tell modem to stop transmitting bulk data on rx chan) */
+	result = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
+				 IPW_SIO_RXCTL,
+				 USB_TYPE_VENDOR | USB_RECIP_INTERFACE | USB_DIR_OUT,
+				 IPW_RXBULK_OFF,
+				 0, /* index */
+				 NULL,
+				 0,
+				 100000);
+
+	if (result < 0)
+		dev_err(&port->dev, "Disabling bulk RxRead failed (error = %d)", result);
+
+	/* shutdown any in-flight urbs that we know about */
+	usb_kill_urb(port->read_urb);
+	usb_kill_urb(port->write_urb);
+}
+
+static void ipw_write_bulk_callback(struct urb *urb, struct pt_regs *regs)
+{
+	struct usb_serial_port *port = urb->context;
+
+	dbg("%s", __FUNCTION__);
+
+	if (urb->status)
+		dbg("%s - nonzero write bulk status received: %d", __FUNCTION__, urb->status);
+
+	schedule_work(&port->work);
+}
+
+static int ipw_write(struct usb_serial_port *port, const unsigned char *buf, int count)
+{
+	struct usb_device *dev = port->serial->dev;
+	int ret;
+
+	dbg("%s: TOP: count=%d, in_interrupt=%ld", __FUNCTION__,
+		count, in_interrupt() );
+
+	if (count == 0) {
+		dbg("%s - write request of 0 bytes", __FUNCTION__);
+		return 0;
+	}
+	
+	/* Racy and broken, FIXME properly! */
+	if (port->write_urb->status == -EINPROGRESS)
+		return 0;
+
+	count = min(count, port->bulk_out_size);
+	memcpy(port->bulk_out_buffer, buf, count);
+
+	dbg("%s count now:%d", __FUNCTION__, count);
+	
+	usb_fill_bulk_urb(port->write_urb, dev,
+			  usb_sndbulkpipe(dev, port->bulk_out_endpointAddress),
+			  port->write_urb->transfer_buffer,
+			  count,
+			  ipw_write_bulk_callback,
+			  port);
+
+	ret = usb_submit_urb(port->write_urb, GFP_ATOMIC);
+	if (ret != 0) {
+		dbg("%s - usb_submit_urb(write bulk) failed with error = %d", __FUNCTION__, ret);
+		return ret;
+	}
+
+	dbg("%s returning %d", __FUNCTION__, count);
+	return count;
+} 
+
+static int ipw_probe(struct usb_serial_port *port)
+{
+	return 0;
+}
+
+static int ipw_disconnect(struct usb_serial_port *port)
+{
+	usb_set_serial_port_data(port, NULL);
+	return 0;
+}
+
+static struct usb_serial_device_type ipw_device = {
+	.owner =		THIS_MODULE,
+	.name =			"IPWireless converter",
+	.short_name =		"ipw",
+	.id_table =		usb_ipw_ids,
+	.num_interrupt_in =	NUM_DONT_CARE,
+	.num_bulk_in =		1,
+	.num_bulk_out =		1,
+	.num_ports =		1,
+	.open =			ipw_open,
+	.close =		ipw_close,
+	.port_probe = 		ipw_probe,
+	.port_remove =		ipw_disconnect,
+	.write =		ipw_write,
+	.write_bulk_callback =	ipw_write_bulk_callback,
+	.read_bulk_callback =	ipw_read_bulk_callback,
+};
+
+
+
+static int usb_ipw_init(void)
+{
+	int retval;
+
+	retval = usb_serial_register(&ipw_device);
+	if (retval)
+		return retval;
+	retval = usb_register(&usb_ipw_driver);
+	if (retval) {
+		usb_serial_deregister(&ipw_device);
+		return retval;
+	}
+	info(DRIVER_DESC " " DRIVER_VERSION);
+	return 0;
+}
+
+static void usb_ipw_exit(void)
+{
+	usb_deregister(&usb_ipw_driver);
+	usb_serial_deregister(&ipw_device);
+}
+
+module_init(usb_ipw_init);
+module_exit(usb_ipw_exit);
+
+/* Module information */
+MODULE_AUTHOR( DRIVER_AUTHOR );
+MODULE_DESCRIPTION( DRIVER_DESC );
+MODULE_LICENSE("GPL");
+
+module_param(debug, bool, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(debug, "Debug enabled or not");
