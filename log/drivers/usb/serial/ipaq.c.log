commit 6ca98bc2843e0bc4c2745ff6be7d46694c1398d1
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Nov 3 12:40:56 2017 +0100

    USB: serial: Remove redundant license text
    
    Now that the SPDX tag is in all USB files, that identifies the license
    in a specific and legally-defined manner.  So the extra GPL text wording
    can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c
index 52da1a82d7f0..f81746c3c26c 100644
--- a/drivers/usb/serial/ipaq.c
+++ b/drivers/usb/serial/ipaq.c
@@ -4,11 +4,6 @@
  *
  *	Copyright (C) 2001 - 2002
  *	    Ganesh Varadarajan <ganesh@veritas.com>
- *
- *	This program is free software; you can redistribute it and/or modify
- *	it under the terms of the GNU General Public License as published by
- *	the Free Software Foundation; either version 2 of the License, or
- *	(at your option) any later version.
  */
 
 #include <linux/kernel.h>

commit 5fd54ace4721fc5ce2bb5aef6318fcf17f421460
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Nov 3 11:28:30 2017 +0100

    USB: add SPDX identifiers to all remaining files in drivers/usb/
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/usb/ and include/linux/usb* files with the correct
    SPDX license identifier based on the license text in the file itself.
    The SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Acked-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c
index cde0dcdce9c4..52da1a82d7f0 100644
--- a/drivers/usb/serial/ipaq.c
+++ b/drivers/usb/serial/ipaq.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  * USB Compaq iPAQ driver
  *

commit 204cc473bc896134870fda21cd279774b3ead024
Author: Johan Hovold <johan@kernel.org>
Date:   Thu Mar 16 17:13:40 2017 +0100

    USB: serial: ipaq: always register a single port
    
    Use the calc_num_ports callback to ignore unused endpoints.
    
    The driver binds to any interface with at least one bulk-in and one
    bulk-out endpoint, but some devices can have three or more endpoints of
    which only either the first or second pair of endpoints is needed.
    
    This avoids allocating resources for unused endpoints, and specifically
    a port is no longer registered for the unused first endpoint pair when
    there are more than three endpoints.
    
    Signed-off-by: Johan Hovold <johan@kernel.org>

diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c
index c638571f0175..cde0dcdce9c4 100644
--- a/drivers/usb/serial/ipaq.c
+++ b/drivers/usb/serial/ipaq.c
@@ -555,39 +555,32 @@ static int ipaq_calc_num_ports(struct usb_serial *serial,
 					struct usb_serial_endpoints *epds)
 {
 	/*
-	 * some devices have 3 endpoints, the 3rd of which
-	 * must be ignored as it would make the core
-	 * create a second port which oopses when used
+	 * Some of the devices in ipaq_id_table[] are composite, and we
+	 * shouldn't bind to all the interfaces. This test will rule out
+	 * some obviously invalid possibilities.
 	 */
-	int ipaq_num_ports = 1;
-
-	dev_dbg(&serial->dev->dev, "%s - numberofendpoints: %d\n", __func__,
-		(int)serial->interface->cur_altsetting->desc.bNumEndpoints);
+	if (epds->num_bulk_in == 0 || epds->num_bulk_out == 0)
+		return -ENODEV;
 
 	/*
-	 * a few devices have 4 endpoints, seemingly Yakuma devices,
-	 * and we need the second pair, so let them have 2 ports
-	 *
-	 * TODO: can we drop port 1 ?
+	 * A few devices have four endpoints, seemingly Yakuma devices, and
+	 * we need the second pair.
 	 */
-	if (serial->interface->cur_altsetting->desc.bNumEndpoints > 3) {
-		ipaq_num_ports = 2;
+	if (epds->num_bulk_in > 1 && epds->num_bulk_out > 1) {
+		epds->bulk_in[0] = epds->bulk_in[1];
+		epds->bulk_out[0] = epds->bulk_out[1];
 	}
 
 	/*
-	 * Some of the devices in ipaq_id_table[] are composite, and we
-	 * shouldn't bind to all the interfaces.  This test will rule out
-	 * some obviously invalid possibilities.
+	 * Other devices have 3 endpoints, but we only use the first bulk in
+	 * and out endpoints.
 	 */
-	if (epds->num_bulk_in < ipaq_num_ports ||
-			epds->num_bulk_out < ipaq_num_ports) {
-		return -ENODEV;
-	}
+	epds->num_bulk_in = 1;
+	epds->num_bulk_out = 1;
 
-	return ipaq_num_ports;
+	return 1;
 }
 
-
 static int ipaq_startup(struct usb_serial *serial)
 {
 	if (serial->dev->actconfig->desc.bConfigurationValue != 1) {
@@ -601,10 +594,6 @@ static int ipaq_startup(struct usb_serial *serial)
 		return -ENODEV;
 	}
 
-	dev_dbg(&serial->dev->dev,
-		"%s - iPAQ module configured for %d ports\n", __func__,
-		serial->num_ports);
-
 	return usb_reset_configuration(serial->dev);
 }
 

commit 03b72aecadc2d7b0e8f200ec70b853e39a7e55da
Author: Johan Hovold <johan@kernel.org>
Date:   Thu Mar 16 17:13:39 2017 +0100

    USB: serial: ipaq: use calc_num_endpoints to verify endpoints
    
    Use the calc_num_ports rather than attach callback to determine which
    interface to bind to in order to avoid allocating port-resources for
    interfaces that won't be bound.
    
    Signed-off-by: Johan Hovold <johan@kernel.org>

diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c
index df5f1a7d7c6f..c638571f0175 100644
--- a/drivers/usb/serial/ipaq.c
+++ b/drivers/usb/serial/ipaq.c
@@ -574,20 +574,22 @@ static int ipaq_calc_num_ports(struct usb_serial *serial,
 		ipaq_num_ports = 2;
 	}
 
+	/*
+	 * Some of the devices in ipaq_id_table[] are composite, and we
+	 * shouldn't bind to all the interfaces.  This test will rule out
+	 * some obviously invalid possibilities.
+	 */
+	if (epds->num_bulk_in < ipaq_num_ports ||
+			epds->num_bulk_out < ipaq_num_ports) {
+		return -ENODEV;
+	}
+
 	return ipaq_num_ports;
 }
 
 
 static int ipaq_startup(struct usb_serial *serial)
 {
-	/* Some of the devices in ipaq_id_table[] are composite, and we
-	 * shouldn't bind to all the interfaces.  This test will rule out
-	 * some obviously invalid possibilities.
-	 */
-	if (serial->num_bulk_in < serial->num_ports ||
-			serial->num_bulk_out < serial->num_ports)
-		return -ENODEV;
-
 	if (serial->dev->actconfig->desc.bConfigurationValue != 1) {
 		/*
 		 * FIXME: HP iPaq rx3715, possibly others, have 1 config that

commit 07814246dd5530860ef758fd9b2b5f2e26472aa2
Author: Johan Hovold <johan@kernel.org>
Date:   Thu Mar 16 17:13:30 2017 +0100

    USB: serial: allow subdrivers to modify port-endpoint mapping
    
    Allow subdrivers to modify the port-endpoint mapping by passing the
    endpoint descriptors to calc_num_ports.
    
    The callback can now also be used to verify that the required endpoints
    exists and abort probing otherwise.
    
    This will allow us to get rid of a few hacks in subdrivers that are
    already modifying the port-endpoint mapping (or aborting probe due to
    missing endpoints), but only after the port structures have been setup.
    
    Signed-off-by: Johan Hovold <johan@kernel.org>

diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c
index ec1b8f2c1183..df5f1a7d7c6f 100644
--- a/drivers/usb/serial/ipaq.c
+++ b/drivers/usb/serial/ipaq.c
@@ -33,7 +33,8 @@ static int initial_wait;
 /* Function prototypes for an ipaq */
 static int  ipaq_open(struct tty_struct *tty,
 			struct usb_serial_port *port);
-static int  ipaq_calc_num_ports(struct usb_serial *serial);
+static int ipaq_calc_num_ports(struct usb_serial *serial,
+					struct usb_serial_endpoints *epds);
 static int  ipaq_startup(struct usb_serial *serial);
 
 static const struct usb_device_id ipaq_id_table[] = {
@@ -550,7 +551,8 @@ static int ipaq_open(struct tty_struct *tty,
 	return usb_serial_generic_open(tty, port);
 }
 
-static int ipaq_calc_num_ports(struct usb_serial *serial)
+static int ipaq_calc_num_ports(struct usb_serial *serial,
+					struct usb_serial_endpoints *epds)
 {
 	/*
 	 * some devices have 3 endpoints, the 3rd of which

commit abdc9a3b4bac97add99e1d77dc6d28623afe682b
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Wed Dec 16 14:06:37 2015 +0300

    USB: ipaq.c: fix a timeout loop
    
    The code expects the loop to end with "retries" set to zero but, because
    it is a post-op, it will end set to -1.  I have fixed this by moving the
    decrement inside the loop.
    
    Fixes: 014aa2a3c32e ('USB: ipaq: minor ipaq_open() cleanup.')
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c
index f51a5d52c0ed..ec1b8f2c1183 100644
--- a/drivers/usb/serial/ipaq.c
+++ b/drivers/usb/serial/ipaq.c
@@ -531,7 +531,8 @@ static int ipaq_open(struct tty_struct *tty,
 	 * through. Since this has a reasonably high failure rate, we retry
 	 * several times.
 	 */
-	while (retries--) {
+	while (retries) {
+		retries--;
 		result = usb_control_msg(serial->dev,
 				usb_sndctrlpipe(serial->dev, 0), 0x22, 0x21,
 				0x1, 0, NULL, 0, 100);

commit 803a536243b3a1ed2289f41897b11b72bd083309
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Wed Jan 8 11:08:26 2014 -0500

    usb: delete non-required instances of include <linux/init.h>
    
    None of these files are actually using any __init type directives
    and hence don't need to include <linux/init.h>.  Most are just a
    left over from __devinit and __cpuinit removal, or simply due to
    code getting copied from one driver to the next.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c
index 3754bc30406e..f51a5d52c0ed 100644
--- a/drivers/usb/serial/ipaq.c
+++ b/drivers/usb/serial/ipaq.c
@@ -12,7 +12,6 @@
 
 #include <linux/kernel.h>
 #include <linux/errno.h>
-#include <linux/init.h>
 #include <linux/slab.h>
 #include <linux/tty.h>
 #include <linux/tty_driver.h>

commit 5c6b98dd0437ba8c1b515bf11357784335613d65
Author: Johan Hovold <jhovold@gmail.com>
Date:   Sun Dec 29 19:22:54 2013 +0100

    USB: serial: constify device-id tables
    
    Declare device-id tables as const where possible.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c
index 76c9a847da5d..3754bc30406e 100644
--- a/drivers/usb/serial/ipaq.c
+++ b/drivers/usb/serial/ipaq.c
@@ -37,7 +37,7 @@ static int  ipaq_open(struct tty_struct *tty,
 static int  ipaq_calc_num_ports(struct usb_serial *serial);
 static int  ipaq_startup(struct usb_serial *serial);
 
-static struct usb_device_id ipaq_id_table [] = {
+static const struct usb_device_id ipaq_id_table[] = {
 	{ USB_DEVICE(0x0104, 0x00BE) }, /* Socket USB Sync */
 	{ USB_DEVICE(0x03F0, 0x1016) }, /* HP USB Sync */
 	{ USB_DEVICE(0x03F0, 0x1116) }, /* HP USB Sync 1611 */

commit bcbec053d2197031d04b8e040c61695b5d7a949d
Author: Johan Hovold <jhovold@gmail.com>
Date:   Wed Oct 31 11:59:52 2012 +0100

    USB: serial: remove driver version information
    
    Remove all MODULE_VERSION macros and driver-version information (except
    for garmin_gps which uses it in a status reply).
    
    It is the kernel version that matters and not some private version
    scheme which rarely even gets updated.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c
index 1068bf22e27e..76c9a847da5d 100644
--- a/drivers/usb/serial/ipaq.c
+++ b/drivers/usb/serial/ipaq.c
@@ -25,11 +25,6 @@
 
 #define KP_RETRIES	100
 
-/*
- * Version Information
- */
-
-#define DRIVER_VERSION "v1.0"
 #define DRIVER_AUTHOR "Ganesh Varadarajan <ganesh@veritas.com>"
 #define DRIVER_DESC "USB PocketPC PDA driver"
 

commit 06e454c40e67df631e2020571ab4e089d9fe0026
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Sep 14 12:31:30 2012 -0700

    USB: serial: ipaq.c: remove debug module parameter
    
    Now that the dbg() macro is no longer being used in the driver,
    the debug module parameter doesn't do anything at all.  So remove
    it so as to not confuse people.
    
    CC: Rusty Russell <rusty@rustcorp.com.au>
    CC: Johan Hovold <jhovold@gmail.com>
    CC: Alan Stern <stern@rowland.harvard.edu>
    CC: Mauro Carvalho Chehab <mchehab@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c
index c85a7eb87d4e..1068bf22e27e 100644
--- a/drivers/usb/serial/ipaq.c
+++ b/drivers/usb/serial/ipaq.c
@@ -33,7 +33,6 @@
 #define DRIVER_AUTHOR "Ganesh Varadarajan <ganesh@veritas.com>"
 #define DRIVER_DESC "USB PocketPC PDA driver"
 
-static bool debug;
 static int connect_retries = KP_RETRIES;
 static int initial_wait;
 
@@ -616,9 +615,6 @@ MODULE_AUTHOR(DRIVER_AUTHOR);
 MODULE_DESCRIPTION(DRIVER_DESC);
 MODULE_LICENSE("GPL");
 
-module_param(debug, bool, S_IRUGO | S_IWUSR);
-MODULE_PARM_DESC(debug, "Debug enabled or not");
-
 module_param(connect_retries, int, S_IRUGO|S_IWUSR);
 MODULE_PARM_DESC(connect_retries,
 		"Maximum number of connect retries (one second each)");

commit f73e1ffa27434772f57a9a7daaa508d06c56fddf
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue May 15 16:27:20 2012 -0700

    USB: ipaq.c: remove dbg() usage
    
    dbg() is a usb-serial specific macro.  This patch converts
    the ipaq.c driver to use dev_dbg() instead to tie into the
    dynamic debug infrastructure.
    
    CC: Rusty Russell <rusty@rustcorp.com.au>
    CC: Johan Hovold <jhovold@gmail.com>
    CC: Alan Stern <stern@rowland.harvard.edu>
    CC: Mauro Carvalho Chehab <mchehab@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c
index bf440b12523c..c85a7eb87d4e 100644
--- a/drivers/usb/serial/ipaq.c
+++ b/drivers/usb/serial/ipaq.c
@@ -565,7 +565,7 @@ static int ipaq_calc_num_ports(struct usb_serial *serial)
 	 */
 	int ipaq_num_ports = 1;
 
-	dbg("%s - numberofendpoints: %d", __FUNCTION__,
+	dev_dbg(&serial->dev->dev, "%s - numberofendpoints: %d\n", __func__,
 		(int)serial->interface->cur_altsetting->desc.bNumEndpoints);
 
 	/*
@@ -603,8 +603,9 @@ static int ipaq_startup(struct usb_serial *serial)
 		return -ENODEV;
 	}
 
-	dbg("%s - iPAQ module configured for %d ports",
-		__FUNCTION__, serial->num_ports);
+	dev_dbg(&serial->dev->dev,
+		"%s - iPAQ module configured for %d ports\n", __func__,
+		serial->num_ports);
 
 	return usb_reset_configuration(serial->dev);
 }

commit 68e24113457e437b1576670f2419b77ed0531e9e
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue May 8 15:46:14 2012 -0700

    USB: serial: rework usb_serial_register/deregister_drivers()
    
    This reworks the usb_serial_register_drivers() and
    usb_serial_deregister_drivers() to not need a pointer to a struct
    usb_driver anymore.  The usb_driver structure is now created dynamically
    and registered and unregistered as needed.
    
    This saves lines of code in each usb-serial driver.  All in-kernel users
    of these functions were also fixed up at this time.  The pl2303 driver
    was tested that everything worked properly.
    
    Thanks for the idea to do this from Alan Stern.
    
    Cc: Adhir Ramjiawan <adhirramjiawan0@gmail.com>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Al Borchers <alborchers@steinerpoint.com>
    Cc: Aleksey Babahin <tamerlan311@gmail.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Andrew Worsley <amworsley@gmail.com>
    Cc: Bart Hartgers <bart.hartgers@gmail.com>
    Cc: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Dan Carpenter <error27@gmail.com>
    Cc: Dan Williams <dcbw@redhat.com>
    Cc: Donald Lee <donald@asix.com.tw>
    Cc: Eric Dumazet <eric.dumazet@gmail.com>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Felipe Balbi <balbi@ti.com>
    Cc: Gary Brubaker <xavyer@ix.netcom.com>
    Cc: Jesper Juhl <jj@chaosbits.net>
    Cc: Jiri Kosina <jkosina@suse.cz>
    Cc: Johan Hovold <jhovold@gmail.com>
    Cc: Julia Lawall <julia@diku.dk>
    Cc: Kautuk Consul <consul.kautuk@gmail.com>
    Cc: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Cc: Lonnie Mendez <dignome@gmail.com>
    Cc: Matthias Bruestle and Harald Welte <support@reiner-sct.com>
    Cc: Matthias Urlichs <smurf@smurf.noris.de>
    Cc: Mauro Carvalho Chehab <mchehab@redhat.com>
    Cc: Michal Sroczynski <msroczyn@gmail.com>
    Cc: "Michał Wróbel" <michal.wrobel@flytronic.pl>
    Cc: Oliver Neukum <oliver@neukum.name>
    Cc: Paul Gortmaker <paul.gortmaker@windriver.com>
    Cc: Peter Berger <pberger@brimson.com>
    Cc: Preston Fick <preston.fick@silabs.com>
    Cc: "Rafael J. Wysocki" <rjw@sisk.pl>
    Cc: Rigbert Hamisch <rigbert@gmx.de>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Cc: Simon Arlott <simon@fire.lp0.eu>
    Cc: Support Department <support@connecttech.com>
    Cc: Thomas Tuttle <ttuttle@chromium.org>
    Cc: Uwe Bonnes <bon@elektron.ikp.physik.tu-darmstadt.de>
    Cc: Wang YanQing <Udknight@gmail.com>
    Cc: William Greathouse <wgreathouse@smva.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c
index 7d1ae700c29d..bf440b12523c 100644
--- a/drivers/usb/serial/ipaq.c
+++ b/drivers/usb/serial/ipaq.c
@@ -502,11 +502,6 @@ static struct usb_device_id ipaq_id_table [] = {
 
 MODULE_DEVICE_TABLE(usb, ipaq_id_table);
 
-static struct usb_driver ipaq_driver = {
-	.name =		"ipaq",
-	.id_table =	ipaq_id_table,
-};
-
 
 /* All of the device info needed for the Compaq iPAQ */
 static struct usb_serial_driver ipaq_device = {
@@ -614,7 +609,7 @@ static int ipaq_startup(struct usb_serial *serial)
 	return usb_reset_configuration(serial->dev);
 }
 
-module_usb_serial_driver(ipaq_driver, serial_drivers);
+module_usb_serial_driver(serial_drivers, ipaq_id_table);
 
 MODULE_AUTHOR(DRIVER_AUTHOR);
 MODULE_DESCRIPTION(DRIVER_DESC);

commit 32078f915d1acab356080b144aa89fe3487f3979
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon May 7 14:02:13 2012 -0700

    USB: serial: remove usb_serial_disconnect call in all drivers
    
    This is now set by the usb-serial core, no need for the driver to
    individually set it.
    
    Thanks to Alan Stern for the idea to get rid of it.
    
    Cc: William Greathouse <wgreathouse@smva.com>
    Cc: Matthias Bruestle and Harald Welte <support@reiner-sct.com>
    Cc: Lonnie Mendez <dignome@gmail.com>
    Cc: Peter Berger <pberger@brimson.com>
    Cc: Al Borchers <alborchers@steinerpoint.com>
    Cc: Gary Brubaker <xavyer@ix.netcom.com>
    Cc: Oliver Neukum <oliver@neukum.name>
    Cc: Matthias Urlichs <smurf@smurf.noris.de>
    Cc: Support Department <support@connecttech.com>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Mauro Carvalho Chehab <mchehab@redhat.com>
    Cc: Kautuk Consul <consul.kautuk@gmail.com>
    Cc: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Paul Gortmaker <paul.gortmaker@windriver.com>
    Cc: Bart Hartgers <bart.hartgers@gmail.com>
    Cc: Johan Hovold <jhovold@gmail.com>
    Cc: Preston Fick <preston.fick@silabs.com>
    Cc: Uwe Bonnes <bon@elektron.ikp.physik.tu-darmstadt.de>
    Cc: Simon Arlott <simon@fire.lp0.eu>
    Cc: Andrew Worsley <amworsley@gmail.com>
    Cc: "Michał Wróbel" <michal.wrobel@flytronic.pl>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Eric Dumazet <eric.dumazet@gmail.com>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Felipe Balbi <balbi@ti.com>
    Cc: Aleksey Babahin <tamerlan311@gmail.com>
    Cc: Dan Carpenter <error27@gmail.com>
    Cc: Jiri Kosina <jkosina@suse.cz>
    Cc: Donald Lee <donald@asix.com.tw>
    Cc: Julia Lawall <julia@diku.dk>
    Cc: Michal Sroczynski <msroczyn@gmail.com>
    Cc: Wang YanQing <Udknight@gmail.com>
    Cc: Dan Williams <dcbw@redhat.com>
    Cc: Thomas Tuttle <ttuttle@chromium.org>
    Cc: Rigbert Hamisch <rigbert@gmx.de>
    Cc: "Rafael J. Wysocki" <rjw@sisk.pl>
    Cc: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Cc: Jesper Juhl <jj@chaosbits.net>
    Cc: Adhir Ramjiawan <adhirramjiawan0@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c
index 340c39e330b0..7d1ae700c29d 100644
--- a/drivers/usb/serial/ipaq.c
+++ b/drivers/usb/serial/ipaq.c
@@ -504,7 +504,6 @@ MODULE_DEVICE_TABLE(usb, ipaq_id_table);
 
 static struct usb_driver ipaq_driver = {
 	.name =		"ipaq",
-	.disconnect =	usb_serial_disconnect,
 	.id_table =	ipaq_id_table,
 };
 

commit 5026bb07be87ef5892742e6853ae6efa0f41961f
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon May 7 13:48:33 2012 -0700

    USB: serial: remove usb_serial_probe call in all drivers
    
    This is now set by the usb-serial core, no need for the driver to
    individually set it.
    
    Thanks to Alan Stern for the idea to get rid of it.
    
    Cc: William Greathouse <wgreathouse@smva.com>
    Cc: Matthias Bruestle and Harald Welte <support@reiner-sct.com>
    Cc: Lonnie Mendez <dignome@gmail.com>
    Cc: Peter Berger <pberger@brimson.com>
    Cc: Al Borchers <alborchers@steinerpoint.com>
    Cc: Gary Brubaker <xavyer@ix.netcom.com>
    Cc: Oliver Neukum <oliver@neukum.name>
    Cc: Matthias Urlichs <smurf@smurf.noris.de>
    Cc: Support Department <support@connecttech.com>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Mauro Carvalho Chehab <mchehab@redhat.com>
    Cc: Kautuk Consul <consul.kautuk@gmail.com>
    Cc: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Paul Gortmaker <paul.gortmaker@windriver.com>
    Cc: Bart Hartgers <bart.hartgers@gmail.com>
    Cc: Johan Hovold <jhovold@gmail.com>
    Cc: Preston Fick <preston.fick@silabs.com>
    Cc: Uwe Bonnes <bon@elektron.ikp.physik.tu-darmstadt.de>
    Cc: Simon Arlott <simon@fire.lp0.eu>
    Cc: Andrew Worsley <amworsley@gmail.com>
    Cc: "Michał Wróbel" <michal.wrobel@flytronic.pl>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Eric Dumazet <eric.dumazet@gmail.com>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Felipe Balbi <balbi@ti.com>
    Cc: Aleksey Babahin <tamerlan311@gmail.com>
    Cc: Dan Carpenter <error27@gmail.com>
    Cc: Jiri Kosina <jkosina@suse.cz>
    Cc: Donald Lee <donald@asix.com.tw>
    Cc: Julia Lawall <julia@diku.dk>
    Cc: Michal Sroczynski <msroczyn@gmail.com>
    Cc: Wang YanQing <Udknight@gmail.com>
    Cc: Dan Williams <dcbw@redhat.com>
    Cc: Thomas Tuttle <ttuttle@chromium.org>
    Cc: Rigbert Hamisch <rigbert@gmx.de>
    Cc: "Rafael J. Wysocki" <rjw@sisk.pl>
    Cc: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Cc: Jesper Juhl <jj@chaosbits.net>
    Cc: Adhir Ramjiawan <adhirramjiawan0@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c
index 65b689a4e36f..340c39e330b0 100644
--- a/drivers/usb/serial/ipaq.c
+++ b/drivers/usb/serial/ipaq.c
@@ -504,7 +504,6 @@ MODULE_DEVICE_TABLE(usb, ipaq_id_table);
 
 static struct usb_driver ipaq_driver = {
 	.name =		"ipaq",
-	.probe =	usb_serial_probe,
 	.disconnect =	usb_serial_disconnect,
 	.id_table =	ipaq_id_table,
 };

commit ef2b895b7533ba1392cb41bc8b3a30d2387e6197
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu May 3 16:44:15 2012 -0700

    USB: ipaq.c: remove dbg() tracing calls
    
    dbg() was used a lot a long time ago to trace code flow.  Now that we have
    ftrace, this isn't needed at all, so remove these calls.
    
    CC: Rusty Russell <rusty@rustcorp.com.au>
    CC: Johan Hovold <jhovold@gmail.com>
    CC: Alan Stern <stern@rowland.harvard.edu>
    CC: Mauro Carvalho Chehab <mchehab@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c
index 61e200ffe6b4..65b689a4e36f 100644
--- a/drivers/usb/serial/ipaq.c
+++ b/drivers/usb/serial/ipaq.c
@@ -536,8 +536,6 @@ static int ipaq_open(struct tty_struct *tty,
 	int			result = 0;
 	int			retries = connect_retries;
 
-	dbg("%s - port %d", __func__, port->number);
-
 	msleep(1000*initial_wait);
 
 	/*
@@ -593,8 +591,6 @@ static int ipaq_calc_num_ports(struct usb_serial *serial)
 
 static int ipaq_startup(struct usb_serial *serial)
 {
-	dbg("%s", __func__);
-
 	/* Some of the devices in ipaq_id_table[] are composite, and we
 	 * shouldn't bind to all the interfaces.  This test will rule out
 	 * some obviously invalid possibilities.

commit b9ee17b7f5a975323a5aa955c4f669ef185bb2fd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Apr 20 08:41:02 2012 -0700

    USB: serial: ipaq: delete duplicate id
    
    With the recent change to remove the module parameters from the ipaq
    driver, we ended up with a duplicate id in the driver.  This patch
    removes it.
    
    Reported-by: Bjørn Mork <bjorn@mork.no>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c
index bd4912f4eaf4..61e200ffe6b4 100644
--- a/drivers/usb/serial/ipaq.c
+++ b/drivers/usb/serial/ipaq.c
@@ -44,7 +44,6 @@ static int  ipaq_calc_num_ports(struct usb_serial *serial);
 static int  ipaq_startup(struct usb_serial *serial);
 
 static struct usb_device_id ipaq_id_table [] = {
-	{ USB_DEVICE(0x049F, 0x0003) },
 	{ USB_DEVICE(0x0104, 0x00BE) }, /* Socket USB Sync */
 	{ USB_DEVICE(0x03F0, 0x1016) }, /* HP USB Sync */
 	{ USB_DEVICE(0x03F0, 0x1116) }, /* HP USB Sync 1611 */

commit cae18768acf684b505c928e5cf7ea741fac45b83
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu Apr 19 15:13:59 2012 -0700

    USB: serial: ipaq: remove product and vendor module parameters
    
    This driver is for devices that are no longer being made, so the ability
    to add new device ids when loading the module is not a feature that
    anyone uses anymore.  So remove it, which simplifies the startup code a
    lot, and saves space.
    
    If you still need to dynamically load device ids, that can be done
    through sysfs.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c
index 10c02b8b5664..bd4912f4eaf4 100644
--- a/drivers/usb/serial/ipaq.c
+++ b/drivers/usb/serial/ipaq.c
@@ -33,7 +33,6 @@
 #define DRIVER_AUTHOR "Ganesh Varadarajan <ganesh@veritas.com>"
 #define DRIVER_DESC "USB PocketPC PDA driver"
 
-static __u16 product, vendor;
 static bool debug;
 static int connect_retries = KP_RETRIES;
 static int initial_wait;
@@ -45,7 +44,6 @@ static int  ipaq_calc_num_ports(struct usb_serial *serial);
 static int  ipaq_startup(struct usb_serial *serial);
 
 static struct usb_device_id ipaq_id_table [] = {
-	/* The first entry is a placeholder for the insmod-specified device */
 	{ USB_DEVICE(0x049F, 0x0003) },
 	{ USB_DEVICE(0x0104, 0x00BE) }, /* Socket USB Sync */
 	{ USB_DEVICE(0x03F0, 0x1016) }, /* HP USB Sync */
@@ -623,30 +621,7 @@ static int ipaq_startup(struct usb_serial *serial)
 	return usb_reset_configuration(serial->dev);
 }
 
-static int __init ipaq_init(void)
-{
-	int retval;
-
-	if (vendor) {
-		ipaq_id_table[0].idVendor = vendor;
-		ipaq_id_table[0].idProduct = product;
-	}
-
-	retval = usb_serial_register_drivers(&ipaq_driver, serial_drivers);
-	if (retval == 0)
-		printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
-			       DRIVER_DESC "\n");
-	return retval;
-}
-
-static void __exit ipaq_exit(void)
-{
-	usb_serial_deregister_drivers(&ipaq_driver, serial_drivers);
-}
-
-
-module_init(ipaq_init);
-module_exit(ipaq_exit);
+module_usb_serial_driver(ipaq_driver, serial_drivers);
 
 MODULE_AUTHOR(DRIVER_AUTHOR);
 MODULE_DESCRIPTION(DRIVER_DESC);
@@ -655,12 +630,6 @@ MODULE_LICENSE("GPL");
 module_param(debug, bool, S_IRUGO | S_IWUSR);
 MODULE_PARM_DESC(debug, "Debug enabled or not");
 
-module_param(vendor, ushort, 0);
-MODULE_PARM_DESC(vendor, "User specified USB idVendor");
-
-module_param(product, ushort, 0);
-MODULE_PARM_DESC(product, "User specified USB idProduct");
-
 module_param(connect_retries, int, S_IRUGO|S_IWUSR);
 MODULE_PARM_DESC(connect_retries,
 		"Maximum number of connect retries (one second each)");

commit 7dbe2460989b10644651e779b17b683627feea48
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Thu Feb 23 14:56:57 2012 -0500

    usb-serial: use new registration API in [i-j]* drivers
    
    This patch (as1525) modifies the following usb-serial drivers to
    utilize the new usb_serial_{de}register_drivers() routines:
    
            io_edgeport, io_ti, ipaq, ipw, ir-usb, and iuu_phoenix.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c
index 06053a920dd8..10c02b8b5664 100644
--- a/drivers/usb/serial/ipaq.c
+++ b/drivers/usb/serial/ipaq.c
@@ -510,7 +510,6 @@ static struct usb_driver ipaq_driver = {
 	.probe =	usb_serial_probe,
 	.disconnect =	usb_serial_disconnect,
 	.id_table =	ipaq_id_table,
-	.no_dynamic_id =	1,
 };
 
 
@@ -521,7 +520,6 @@ static struct usb_serial_driver ipaq_device = {
 		.name =		"ipaq",
 	},
 	.description =		"PocketPC PDA",
-	.usb_driver =		&ipaq_driver,
 	.id_table =		ipaq_id_table,
 	.bulk_in_size =		256,
 	.bulk_out_size =	256,
@@ -530,6 +528,10 @@ static struct usb_serial_driver ipaq_device = {
 	.calc_num_ports =	ipaq_calc_num_ports,
 };
 
+static struct usb_serial_driver * const serial_drivers[] = {
+	&ipaq_device, NULL
+};
+
 static int ipaq_open(struct tty_struct *tty,
 			struct usb_serial_port *port)
 {
@@ -624,30 +626,22 @@ static int ipaq_startup(struct usb_serial *serial)
 static int __init ipaq_init(void)
 {
 	int retval;
-	retval = usb_serial_register(&ipaq_device);
-	if (retval)
-		goto failed_usb_serial_register;
+
 	if (vendor) {
 		ipaq_id_table[0].idVendor = vendor;
 		ipaq_id_table[0].idProduct = product;
 	}
-	retval = usb_register(&ipaq_driver);
-	if (retval)
-		goto failed_usb_register;
-
-	printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
-	       DRIVER_DESC "\n");
-	return 0;
-failed_usb_register:
-	usb_serial_deregister(&ipaq_device);
-failed_usb_serial_register:
+
+	retval = usb_serial_register_drivers(&ipaq_driver, serial_drivers);
+	if (retval == 0)
+		printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
+			       DRIVER_DESC "\n");
 	return retval;
 }
 
 static void __exit ipaq_exit(void)
 {
-	usb_deregister(&ipaq_driver);
-	usb_serial_deregister(&ipaq_device);
+	usb_serial_deregister_drivers(&ipaq_driver, serial_drivers);
 }
 
 

commit 90ab5ee94171b3e28de6bb42ee30b527014e0be7
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Fri Jan 13 09:32:20 2012 +1030

    module_param: make bool parameters really bool (drivers & misc)
    
    module_param(bool) used to counter-intuitively take an int.  In
    fddd5201 (mid-2009) we allowed bool or int/unsigned int using a messy
    trick.
    
    It's time to remove the int/unsigned int option.  For this version
    it'll simply give a warning, but it'll break next kernel version.
    
    Acked-by: Mauro Carvalho Chehab <mchehab@redhat.com>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c
index 36f5cbe90485..06053a920dd8 100644
--- a/drivers/usb/serial/ipaq.c
+++ b/drivers/usb/serial/ipaq.c
@@ -34,7 +34,7 @@
 #define DRIVER_DESC "USB PocketPC PDA driver"
 
 static __u16 product, vendor;
-static int debug;
+static bool debug;
 static int connect_retries = KP_RETRIES;
 static int initial_wait;
 

commit 14b54e39b4121f679376d4175682fe47a9a86447
Author: Johan Hovold <jhovold@gmail.com>
Date:   Sun Nov 6 19:06:20 2011 +0100

    USB: serial: remove changelogs and old todo entries
    
    Remove remaining changelogs from file headers (can still be retrieved
    through git).
    Remove even older changelog entries stored in Changelog.history.
    Remove outdated todo entries from belkin_sa.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c
index 4735931b4c7b..36f5cbe90485 100644
--- a/drivers/usb/serial/ipaq.c
+++ b/drivers/usb/serial/ipaq.c
@@ -8,40 +8,6 @@
  *	it under the terms of the GNU General Public License as published by
  *	the Free Software Foundation; either version 2 of the License, or
  *	(at your option) any later version.
- *
- * (12/12/2002) ganesh
- * 	Added support for practically all devices supported by ActiveSync
- * 	on Windows. Thanks to Wes Cilldhaire <billybobjoehenrybob@hotmail.com>.
- *
- * (26/11/2002) ganesh
- * 	Added insmod options to specify product and vendor id.
- * 	Use modprobe ipaq vendor=0xfoo product=0xbar
- *
- * (26/7/2002) ganesh
- * 	Fixed up broken error handling in ipaq_open. Retry the "kickstart"
- * 	packet much harder - this drastically reduces connection failures.
- *
- * (30/4/2002) ganesh
- * 	Added support for the Casio EM500. Completely untested. Thanks
- * 	to info from Nathan <wfilardo@fuse.net>
- *
- * (19/3/2002) ganesh
- *	Don't submit urbs while holding spinlocks. Not strictly necessary
- *	in 2.5.x.
- *
- * (8/3/2002) ganesh
- * 	The ipaq sometimes emits a '\0' before the CLIENT string. At this
- * 	point of time, the ppp ldisc is not yet attached to the tty, so
- * 	n_tty echoes "^ " to the ipaq, which messes up the chat. In 2.5.6-pre2
- * 	this causes a panic because echo_char() tries to sleep in interrupt
- * 	context.
- * 	The fix is to tell the upper layers that this is a raw device so that
- * 	echoing is suppressed. Thanks to Lyle Lindholm for a detailed bug
- * 	report.
- *
- * (25/2/2002) ganesh
- * 	Added support for the HP Jornada 548 and 568. Completely untested.
- * 	Thanks to info from Heath Robinson and Arieh Davidoff.
  */
 
 #include <linux/kernel.h>

commit c48271e0729a42a0692a5b7e1aa1552d7f2ff8ab
Author: Leann Ogasawara <leann.ogasawara@canonical.com>
Date:   Thu Jun 10 15:49:24 2010 -0700

    Revert "USB: Adding support for HTC Smartphones to ipaq"
    
    ipaq already had this device id defined:
    
    { USB_DEVICE(0x0BB4, 0x00CF) }, /* HTC USB Modem */
    
    Revert the commit which adds the duplicate entry.
    
    This reverts commit 04cab1329336d4577d6638360c905e360934b425.
    
    Originally-by: Ben Collins <ben.collins@canonical.com>
    Signed-off-by: Leann Ogasawara <leann.ogasawara@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c
index 28913fa95fb7..4735931b4c7b 100644
--- a/drivers/usb/serial/ipaq.c
+++ b/drivers/usb/serial/ipaq.c
@@ -534,7 +534,6 @@ static struct usb_device_id ipaq_id_table [] = {
 	{ USB_DEVICE(0x413C, 0x4009) }, /* Dell Axim USB Sync */
 	{ USB_DEVICE(0x4505, 0x0010) }, /* Smartphone */
 	{ USB_DEVICE(0x5E04, 0xCE00) }, /* SAGEM Wireless Assistant */
-	{ USB_DEVICE(0x0BB4, 0x00CF) }, /* HTC smartphone modems */
 	{ }                             /* Terminating entry */
 };
 

commit 6b6962f9c489ecfa43ae27eb798c46717e203322
Author: Johan Hovold <jhovold@gmail.com>
Date:   Sat May 15 17:53:46 2010 +0200

    USB: ipaq: reimplement using generic framework
    
    Kill custom fifo, read and write implementations (single-urb and fifo,
    but still maintained list of 256*256b urb buffers per port).
    
    Compile-only tested.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c
index 87b11461bf11..28913fa95fb7 100644
--- a/drivers/usb/serial/ipaq.c
+++ b/drivers/usb/serial/ipaq.c
@@ -56,7 +56,6 @@
 #include <linux/uaccess.h>
 #include <linux/usb.h>
 #include <linux/usb/serial.h>
-#include "ipaq.h"
 
 #define KP_RETRIES	100
 
@@ -64,7 +63,7 @@
  * Version Information
  */
 
-#define DRIVER_VERSION "v0.5"
+#define DRIVER_VERSION "v1.0"
 #define DRIVER_AUTHOR "Ganesh Varadarajan <ganesh@veritas.com>"
 #define DRIVER_DESC "USB PocketPC PDA driver"
 
@@ -76,20 +75,8 @@ static int initial_wait;
 /* Function prototypes for an ipaq */
 static int  ipaq_open(struct tty_struct *tty,
 			struct usb_serial_port *port);
-static void ipaq_close(struct usb_serial_port *port);
 static int  ipaq_calc_num_ports(struct usb_serial *serial);
 static int  ipaq_startup(struct usb_serial *serial);
-static int ipaq_write(struct tty_struct *tty, struct usb_serial_port *port,
-			const unsigned char *buf, int count);
-static int ipaq_write_bulk(struct usb_serial_port *port,
-				const unsigned char *buf, int count);
-static void ipaq_write_gather(struct usb_serial_port *port);
-static void ipaq_read_bulk_callback(struct urb *urb);
-static void ipaq_write_bulk_callback(struct urb *urb);
-static int ipaq_write_room(struct tty_struct *tty);
-static int ipaq_chars_in_buffer(struct tty_struct *tty);
-static void ipaq_destroy_lists(struct usb_serial_port *port);
-
 
 static struct usb_device_id ipaq_id_table [] = {
 	/* The first entry is a placeholder for the insmod-specified device */
@@ -558,7 +545,7 @@ static struct usb_driver ipaq_driver = {
 	.probe =	usb_serial_probe,
 	.disconnect =	usb_serial_disconnect,
 	.id_table =	ipaq_id_table,
-	.no_dynamic_id = 	1,
+	.no_dynamic_id =	1,
 };
 
 
@@ -569,67 +556,24 @@ static struct usb_serial_driver ipaq_device = {
 		.name =		"ipaq",
 	},
 	.description =		"PocketPC PDA",
-	.usb_driver = 		&ipaq_driver,
+	.usb_driver =		&ipaq_driver,
 	.id_table =		ipaq_id_table,
-	.bulk_in_size =		URBDATA_SIZE,
-	.bulk_out_size =	URBDATA_SIZE,
+	.bulk_in_size =		256,
+	.bulk_out_size =	256,
 	.open =			ipaq_open,
-	.close =		ipaq_close,
 	.attach =		ipaq_startup,
 	.calc_num_ports =	ipaq_calc_num_ports,
-	.write =		ipaq_write,
-	.write_room =		ipaq_write_room,
-	.chars_in_buffer =	ipaq_chars_in_buffer,
-	.read_bulk_callback =	ipaq_read_bulk_callback,
-	.write_bulk_callback =	ipaq_write_bulk_callback,
 };
 
-static spinlock_t	write_list_lock;
-static int		bytes_in;
-static int		bytes_out;
-
 static int ipaq_open(struct tty_struct *tty,
 			struct usb_serial_port *port)
 {
 	struct usb_serial	*serial = port->serial;
-	struct ipaq_private	*priv;
-	struct ipaq_packet	*pkt;
-	int			i, result = 0;
+	int			result = 0;
 	int			retries = connect_retries;
 
 	dbg("%s - port %d", __func__, port->number);
 
-	bytes_in = 0;
-	bytes_out = 0;
-	priv = kmalloc(sizeof(struct ipaq_private), GFP_KERNEL);
-	if (priv == NULL) {
-		dev_err(&port->dev, "%s - Out of memory\n", __func__);
-		return -ENOMEM;
-	}
-	usb_set_serial_port_data(port, priv);
-	priv->active = 0;
-	priv->queue_len = 0;
-	priv->free_len = 0;
-	INIT_LIST_HEAD(&priv->queue);
-	INIT_LIST_HEAD(&priv->freelist);
-
-	for (i = 0; i < URBDATA_QUEUE_MAX / PACKET_SIZE; i++) {
-		pkt = kmalloc(sizeof(struct ipaq_packet), GFP_KERNEL);
-		if (pkt == NULL)
-			goto enomem;
-
-		pkt->data = kmalloc(PACKET_SIZE, GFP_KERNEL);
-		if (pkt->data == NULL) {
-			kfree(pkt);
-			goto enomem;
-		}
-		pkt->len = 0;
-		pkt->written = 0;
-		INIT_LIST_HEAD(&pkt->list);
-		list_add(&pkt->list, &priv->freelist);
-		priv->free_len += PACKET_SIZE;
-	}
-
 	msleep(1000*initial_wait);
 
 	/*
@@ -639,7 +583,6 @@ static int ipaq_open(struct tty_struct *tty,
 	 * through. Since this has a reasonably high failure rate, we retry
 	 * several times.
 	 */
-
 	while (retries--) {
 		result = usb_control_msg(serial->dev,
 				usb_sndctrlpipe(serial->dev, 0), 0x22, 0x21,
@@ -649,269 +592,15 @@ static int ipaq_open(struct tty_struct *tty,
 
 		msleep(1000);
 	}
-
 	if (!retries && result) {
-		dev_err(&port->dev, "%s - failed doing control urb, error %d\n",			__func__, result);
-		goto error;
-	}
-
-	/* Start reading from the device */
-	usb_fill_bulk_urb(port->read_urb, serial->dev,
-		usb_rcvbulkpipe(serial->dev, port->bulk_in_endpointAddress),
-		port->read_urb->transfer_buffer,
-		port->read_urb->transfer_buffer_length,
-		ipaq_read_bulk_callback, port);
-
-	result = usb_submit_urb(port->read_urb, GFP_KERNEL);
-	if (result) {
-		dev_err(&port->dev,
-			"%s - failed submitting read urb, error %d\n",
-			__func__, result);
-		goto error;
-	}
-
-	return 0;
-
-enomem:
-	result = -ENOMEM;
-	dev_err(&port->dev, "%s - Out of memory\n", __func__);
-error:
-	ipaq_destroy_lists(port);
-	kfree(priv);
-	return result;
-}
-
-
-static void ipaq_close(struct usb_serial_port *port)
-{
-	struct ipaq_private	*priv = usb_get_serial_port_data(port);
-
-	dbg("%s - port %d", __func__, port->number);
-
-	/*
-	 * shut down bulk read and write
-	 */
-	usb_kill_urb(port->write_urb);
-	usb_kill_urb(port->read_urb);
-	ipaq_destroy_lists(port);
-	kfree(priv);
-	usb_set_serial_port_data(port, NULL);
-
-	/* Uncomment the following line if you want to see some statistics
-	 * in your syslog */
-	/* info ("Bytes In = %d  Bytes Out = %d", bytes_in, bytes_out); */
-}
-
-static void ipaq_read_bulk_callback(struct urb *urb)
-{
-	struct usb_serial_port	*port = urb->context;
-	struct tty_struct	*tty;
-	unsigned char		*data = urb->transfer_buffer;
-	int			result;
-	int status = urb->status;
-
-	dbg("%s - port %d", __func__, port->number);
-
-	if (status) {
-		dbg("%s - nonzero read bulk status received: %d",
-		    __func__, status);
-		return;
+		dev_err(&port->dev, "%s - failed doing control urb, error %d\n",
+							__func__, result);
+		return result;
 	}
 
-	usb_serial_debug_data(debug, &port->dev, __func__,
-						urb->actual_length, data);
-
-	tty = tty_port_tty_get(&port->port);
-	if (tty && urb->actual_length) {
-		tty_insert_flip_string(tty, data, urb->actual_length);
-		tty_flip_buffer_push(tty);
-		bytes_in += urb->actual_length;
-	}
-	tty_kref_put(tty);
-
-	/* Continue trying to always read  */
-	usb_fill_bulk_urb(port->read_urb, port->serial->dev,
-	    usb_rcvbulkpipe(port->serial->dev, port->bulk_in_endpointAddress),
-	    port->read_urb->transfer_buffer,
-	    port->read_urb->transfer_buffer_length,
-	    ipaq_read_bulk_callback, port);
-	result = usb_submit_urb(port->read_urb, GFP_ATOMIC);
-	if (result)
-		dev_err(&port->dev,
-			"%s - failed resubmitting read urb, error %d\n",
-			__func__, result);
-	return;
+	return usb_serial_generic_open(tty, port);
 }
 
-static int ipaq_write(struct tty_struct *tty, struct usb_serial_port *port,
-			const unsigned char *buf, int count)
-{
-	const unsigned char	*current_position = buf;
-	int			bytes_sent = 0;
-	int			transfer_size;
-
-	dbg("%s - port %d", __func__, port->number);
-
-	while (count > 0) {
-		transfer_size = min(count, PACKET_SIZE);
-		if (ipaq_write_bulk(port, current_position, transfer_size))
-			break;
-		current_position += transfer_size;
-		bytes_sent += transfer_size;
-		count -= transfer_size;
-		bytes_out += transfer_size;
-	}
-
-	return bytes_sent;
-}
-
-static int ipaq_write_bulk(struct usb_serial_port *port,
-					const unsigned char *buf, int count)
-{
-	struct ipaq_private	*priv = usb_get_serial_port_data(port);
-	struct ipaq_packet	*pkt = NULL;
-	int			result = 0;
-	unsigned long		flags;
-
-	if (priv->free_len <= 0) {
-		dbg("%s - we're stuffed", __func__);
-		return -EAGAIN;
-	}
-
-	spin_lock_irqsave(&write_list_lock, flags);
-	if (!list_empty(&priv->freelist)) {
-		pkt = list_entry(priv->freelist.next, struct ipaq_packet, list);
-		list_del(&pkt->list);
-		priv->free_len -= PACKET_SIZE;
-	}
-	spin_unlock_irqrestore(&write_list_lock, flags);
-	if (pkt == NULL) {
-		dbg("%s - we're stuffed", __func__);
-		return -EAGAIN;
-	}
-
-	memcpy(pkt->data, buf, count);
-	usb_serial_debug_data(debug, &port->dev, __func__, count, pkt->data);
-
-	pkt->len = count;
-	pkt->written = 0;
-	spin_lock_irqsave(&write_list_lock, flags);
-	list_add_tail(&pkt->list, &priv->queue);
-	priv->queue_len += count;
-	if (priv->active == 0) {
-		priv->active = 1;
-		ipaq_write_gather(port);
-		spin_unlock_irqrestore(&write_list_lock, flags);
-		result = usb_submit_urb(port->write_urb, GFP_ATOMIC);
-		if (result)
-			dev_err(&port->dev,
-				"%s - failed submitting write urb, error %d\n",
-				__func__, result);
-	} else {
-		spin_unlock_irqrestore(&write_list_lock, flags);
-	}
-	return result;
-}
-
-static void ipaq_write_gather(struct usb_serial_port *port)
-{
-	struct ipaq_private	*priv = usb_get_serial_port_data(port);
-	struct usb_serial	*serial = port->serial;
-	int			count, room;
-	struct ipaq_packet	*pkt, *tmp;
-	struct urb		*urb = port->write_urb;
-
-	room = URBDATA_SIZE;
-	list_for_each_entry_safe(pkt, tmp, &priv->queue, list) {
-		count = min(room, (int)(pkt->len - pkt->written));
-		memcpy(urb->transfer_buffer + (URBDATA_SIZE - room),
-		       pkt->data + pkt->written, count);
-		room -= count;
-		pkt->written += count;
-		priv->queue_len -= count;
-		if (pkt->written == pkt->len) {
-			list_move(&pkt->list, &priv->freelist);
-			priv->free_len += PACKET_SIZE;
-		}
-		if (room == 0)
-			break;
-	}
-
-	count = URBDATA_SIZE - room;
-	usb_fill_bulk_urb(port->write_urb, serial->dev,
-		usb_sndbulkpipe(serial->dev, port->bulk_out_endpointAddress),
-		port->write_urb->transfer_buffer, count,
-		ipaq_write_bulk_callback, port);
-	return;
-}
-
-static void ipaq_write_bulk_callback(struct urb *urb)
-{
-	struct usb_serial_port	*port = urb->context;
-	struct ipaq_private	*priv = usb_get_serial_port_data(port);
-	unsigned long		flags;
-	int			result;
-	int status = urb->status;
-
-	dbg("%s - port %d", __func__, port->number);
-
-	if (status) {
-		dbg("%s - nonzero write bulk status received: %d",
-		    __func__, status);
-		return;
-	}
-
-	spin_lock_irqsave(&write_list_lock, flags);
-	if (!list_empty(&priv->queue)) {
-		ipaq_write_gather(port);
-		spin_unlock_irqrestore(&write_list_lock, flags);
-		result = usb_submit_urb(port->write_urb, GFP_ATOMIC);
-		if (result)
-			dev_err(&port->dev,
-				"%s - failed submitting write urb, error %d\n",
-				__func__, result);
-	} else {
-		priv->active = 0;
-		spin_unlock_irqrestore(&write_list_lock, flags);
-	}
-
-	usb_serial_port_softint(port);
-}
-
-static int ipaq_write_room(struct tty_struct *tty)
-{
-	struct usb_serial_port *port = tty->driver_data;
-	struct ipaq_private	*priv = usb_get_serial_port_data(port);
-
-	dbg("%s - freelen %d", __func__, priv->free_len);
-	return priv->free_len;
-}
-
-static int ipaq_chars_in_buffer(struct tty_struct *tty)
-{
-	struct usb_serial_port *port = tty->driver_data;
-	struct ipaq_private	*priv = usb_get_serial_port_data(port);
-
-	dbg("%s - queuelen %d", __func__, priv->queue_len);
-	return priv->queue_len;
-}
-
-static void ipaq_destroy_lists(struct usb_serial_port *port)
-{
-	struct ipaq_private	*priv = usb_get_serial_port_data(port);
-	struct ipaq_packet	*pkt, *tmp;
-
-	list_for_each_entry_safe(pkt, tmp, &priv->queue, list) {
-		kfree(pkt->data);
-		kfree(pkt);
-	}
-	list_for_each_entry_safe(pkt, tmp, &priv->freelist, list) {
-		kfree(pkt->data);
-		kfree(pkt);
-	}
-}
-
-
 static int ipaq_calc_num_ports(struct usb_serial *serial)
 {
 	/*
@@ -970,7 +659,6 @@ static int ipaq_startup(struct usb_serial *serial)
 static int __init ipaq_init(void)
 {
 	int retval;
-	spin_lock_init(&write_list_lock);
 	retval = usb_serial_register(&ipaq_device);
 	if (retval)
 		goto failed_usb_serial_register;
@@ -991,7 +679,6 @@ static int __init ipaq_init(void)
 	return retval;
 }
 
-
 static void __exit ipaq_exit(void)
 {
 	usb_deregister(&ipaq_driver);

commit bbcb2b907415a90334521a31a8767cd77462c716
Author: Johan Hovold <jhovold@gmail.com>
Date:   Wed Mar 17 23:00:37 2010 +0100

    USB: serial: allow drivers to define bulk buffer sizes
    
    Allow drivers to define custom bulk in/out buffer sizes in struct
    usb_serial_driver. If not set, fall back to the default buffer size
    which matches the endpoint size.
    
    Three drivers are currently freeing the pre-allocated buffers and
    allocating larger ones to achieve this at port probe (ftdi_sio) or even
    at port open (ipaq and iuu_phoenix), which needless to say is suboptimal.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c
index 3fea9298eb15..87b11461bf11 100644
--- a/drivers/usb/serial/ipaq.c
+++ b/drivers/usb/serial/ipaq.c
@@ -571,6 +571,8 @@ static struct usb_serial_driver ipaq_device = {
 	.description =		"PocketPC PDA",
 	.usb_driver = 		&ipaq_driver,
 	.id_table =		ipaq_id_table,
+	.bulk_in_size =		URBDATA_SIZE,
+	.bulk_out_size =	URBDATA_SIZE,
 	.open =			ipaq_open,
 	.close =		ipaq_close,
 	.attach =		ipaq_startup,
@@ -628,32 +630,6 @@ static int ipaq_open(struct tty_struct *tty,
 		priv->free_len += PACKET_SIZE;
 	}
 
-	/*
-	 * Lose the small buffers usbserial provides. Make larger ones.
-	 */
-
-	kfree(port->bulk_in_buffer);
-	kfree(port->bulk_out_buffer);
-	/* make sure the generic serial code knows */
-	port->bulk_out_buffer = NULL;
-
-	port->bulk_in_buffer = kmalloc(URBDATA_SIZE, GFP_KERNEL);
-	if (port->bulk_in_buffer == NULL)
-		goto enomem;
-
-	port->bulk_out_buffer = kmalloc(URBDATA_SIZE, GFP_KERNEL);
-	if (port->bulk_out_buffer == NULL) {
-		/* the buffer is useless, free it */
-		kfree(port->bulk_in_buffer);
-		port->bulk_in_buffer = NULL;
-		goto enomem;
-	}
-	port->read_urb->transfer_buffer = port->bulk_in_buffer;
-	port->write_urb->transfer_buffer = port->bulk_out_buffer;
-	port->read_urb->transfer_buffer_length = URBDATA_SIZE;
-	port->bulk_out_size = port->write_urb->transfer_buffer_length
-							= URBDATA_SIZE;
-
 	msleep(1000*initial_wait);
 
 	/*

commit a108bfcb372d8c4452701039308fb95747911c59
Author: Alan Cox <alan@linux.intel.com>
Date:   Thu Feb 18 16:44:01 2010 +0000

    USB: tty: Prune uses of tty_request_room in the USB layer
    
    We have lots of callers that do not need to do this in the first place.
    Remove the calls as they both cost CPU and for big buffers can mess up the
    multi-page allocation avoidance.
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c
index d6231c38813e..3fea9298eb15 100644
--- a/drivers/usb/serial/ipaq.c
+++ b/drivers/usb/serial/ipaq.c
@@ -747,7 +747,6 @@ static void ipaq_read_bulk_callback(struct urb *urb)
 
 	tty = tty_port_tty_get(&port->port);
 	if (tty && urb->actual_length) {
-		tty_buffer_request_room(tty, urb->actual_length);
 		tty_insert_flip_string(tty, data, urb->actual_length);
 		tty_flip_buffer_push(tty);
 		bytes_in += urb->actual_length;

commit 06bad89da686f6323e95cf925105e8cf88d87caf
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Oct 5 15:53:58 2009 -0400

    USB: ipaq: fix oops when device is plugged in
    
    This patch (as1293) fixes a problem with the ipaq serial driver.  It
    tries to bind to all the interfaces, even those that don't have enough
    endpoints.  The symptom is an invalid memory reference and oops when
    the device is plugged in.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    CC: stable <stable@kernel.org>
    Tested-by: Matthias Geissert <geissert@mathematik.tu-darmstadt.de>
    Tested-by: Tilman Schmidt <tilman@imap.cc>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c
index 24fcc64b837d..d6231c38813e 100644
--- a/drivers/usb/serial/ipaq.c
+++ b/drivers/usb/serial/ipaq.c
@@ -966,6 +966,15 @@ static int ipaq_calc_num_ports(struct usb_serial *serial)
 static int ipaq_startup(struct usb_serial *serial)
 {
 	dbg("%s", __func__);
+
+	/* Some of the devices in ipaq_id_table[] are composite, and we
+	 * shouldn't bind to all the interfaces.  This test will rule out
+	 * some obviously invalid possibilities.
+	 */
+	if (serial->num_bulk_in < serial->num_ports ||
+			serial->num_bulk_out < serial->num_ports)
+		return -ENODEV;
+
 	if (serial->dev->actconfig->desc.bConfigurationValue != 1) {
 		/*
 		 * FIXME: HP iPaq rx3715, possibly others, have 1 config that

commit a509a7e478e4766114d69f12d19d644ac63e9765
Author: Alan Cox <alan@linux.intel.com>
Date:   Sat Sep 19 13:13:26 2009 -0700

    tty: USB does not need the filp argument in the drivers
    
    And indeed none of them use it. Clean this up as it will make moving to a
    standard open method rather easier.
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c
index 2545d45ce16f..24fcc64b837d 100644
--- a/drivers/usb/serial/ipaq.c
+++ b/drivers/usb/serial/ipaq.c
@@ -75,7 +75,7 @@ static int initial_wait;
 
 /* Function prototypes for an ipaq */
 static int  ipaq_open(struct tty_struct *tty,
-			struct usb_serial_port *port, struct file *filp);
+			struct usb_serial_port *port);
 static void ipaq_close(struct usb_serial_port *port);
 static int  ipaq_calc_num_ports(struct usb_serial *serial);
 static int  ipaq_startup(struct usb_serial *serial);
@@ -587,7 +587,7 @@ static int		bytes_in;
 static int		bytes_out;
 
 static int ipaq_open(struct tty_struct *tty,
-			struct usb_serial_port *port, struct file *filp)
+			struct usb_serial_port *port)
 {
 	struct usb_serial	*serial = port->serial;
 	struct ipaq_private	*priv;
@@ -628,11 +628,6 @@ static int ipaq_open(struct tty_struct *tty,
 		priv->free_len += PACKET_SIZE;
 	}
 
-	if (tty) {
-		/* FIXME: These two are bogus */
-		tty->raw = 1;
-		tty->real_raw = 1;
-	}
 	/*
 	 * Lose the small buffers usbserial provides. Make larger ones.
 	 */

commit f9c99bb8b3a1ec81af68d484a551307326c2e933
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Jun 2 11:53:55 2009 -0400

    USB: usb-serial: replace shutdown with disconnect, release
    
    This patch (as1254) splits up the shutdown method of usb_serial_driver
    into a disconnect and a release method.
    
    The problem is that the usb-serial core was calling shutdown during
    disconnect handling, but drivers didn't expect it to be called until
    after all the open file references had been closed.  The result was an
    oops when the close method tried to use memory that had been
    deallocated by shutdown.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c
index c610a99fa477..2545d45ce16f 100644
--- a/drivers/usb/serial/ipaq.c
+++ b/drivers/usb/serial/ipaq.c
@@ -79,7 +79,6 @@ static int  ipaq_open(struct tty_struct *tty,
 static void ipaq_close(struct usb_serial_port *port);
 static int  ipaq_calc_num_ports(struct usb_serial *serial);
 static int  ipaq_startup(struct usb_serial *serial);
-static void ipaq_shutdown(struct usb_serial *serial);
 static int ipaq_write(struct tty_struct *tty, struct usb_serial_port *port,
 			const unsigned char *buf, int count);
 static int ipaq_write_bulk(struct usb_serial_port *port,
@@ -576,7 +575,6 @@ static struct usb_serial_driver ipaq_device = {
 	.close =		ipaq_close,
 	.attach =		ipaq_startup,
 	.calc_num_ports =	ipaq_calc_num_ports,
-	.shutdown =		ipaq_shutdown,
 	.write =		ipaq_write,
 	.write_room =		ipaq_write_room,
 	.chars_in_buffer =	ipaq_chars_in_buffer,
@@ -990,11 +988,6 @@ static int ipaq_startup(struct usb_serial *serial)
 	return usb_reset_configuration(serial->dev);
 }
 
-static void ipaq_shutdown(struct usb_serial *serial)
-{
-	dbg("%s", __func__);
-}
-
 static int __init ipaq_init(void)
 {
 	int retval;

commit 335f8514f200e63d689113d29cb7253a5c282967
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Thu Jun 11 12:26:29 2009 +0100

    tty: Bring the usb tty port structure into more use
    
    This allows us to clean stuff up, but is probably also going to cause
    some app breakage with buggy apps as we now implement proper POSIX behaviour
    for USB ports matching all the other ports. This does also mean other apps
    that break on USB will now work properly.
    
    Signed-off-by: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c
index cd62825a9ac3..c610a99fa477 100644
--- a/drivers/usb/serial/ipaq.c
+++ b/drivers/usb/serial/ipaq.c
@@ -76,8 +76,7 @@ static int initial_wait;
 /* Function prototypes for an ipaq */
 static int  ipaq_open(struct tty_struct *tty,
 			struct usb_serial_port *port, struct file *filp);
-static void ipaq_close(struct tty_struct *tty,
-			struct usb_serial_port *port, struct file *filp);
+static void ipaq_close(struct usb_serial_port *port);
 static int  ipaq_calc_num_ports(struct usb_serial *serial);
 static int  ipaq_startup(struct usb_serial *serial);
 static void ipaq_shutdown(struct usb_serial *serial);
@@ -714,8 +713,7 @@ static int ipaq_open(struct tty_struct *tty,
 }
 
 
-static void ipaq_close(struct tty_struct *tty,
-			struct usb_serial_port *port, struct file *filp)
+static void ipaq_close(struct usb_serial_port *port)
 {
 	struct ipaq_private	*priv = usb_get_serial_port_data(port);
 

commit 2400a2bfbd0e912193fe3b077f492d4980141813
Author: Oliver Neukum <oliver@neukum.org>
Date:   Mon Apr 20 17:28:53 2009 +0200

    USB: removal of tty->low_latency hack dating back to the old serial code
    
    This removes tty->low_latency from all USB serial drivers that push
    data into the tty layer at hard interrupt context. It's no longer needed
    and actually harmful.
    
    Signed-off-by: Oliver Neukum <oliver@neukum.org>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c
index ef92095b0732..cd62825a9ac3 100644
--- a/drivers/usb/serial/ipaq.c
+++ b/drivers/usb/serial/ipaq.c
@@ -631,13 +631,7 @@ static int ipaq_open(struct tty_struct *tty,
 		priv->free_len += PACKET_SIZE;
 	}
 
-	/*
-	 * Force low latency on. This will immediately push data to the line
-	 * discipline instead of queueing.
-	 */
-
 	if (tty) {
-		tty->low_latency = 1;
 		/* FIXME: These two are bogus */
 		tty->raw = 1;
 		tty->real_raw = 1;

commit 1b8fb4141eb52f4aace9f152dad3e4c1609b76fe
Author: Mark Ellis <mark@mpellis.org.uk>
Date:   Mon Mar 9 22:24:29 2009 +0000

    USB: ipaq: handle 4 endpoint devices
    
    The ipaq driver currently enforces one port on all devices. This
    is correct for 2 and 3 endpoint devices, but with 4 endpoint devices
    meaningful communication occurs on the second pair.
    
    This patch allows 2 ports for 4 endpoint devices.
    
    Signed-off-by: Mark Ellis <mark@mpellis.org.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c
index 132be74d2b89..ef92095b0732 100644
--- a/drivers/usb/serial/ipaq.c
+++ b/drivers/usb/serial/ipaq.c
@@ -78,6 +78,7 @@ static int  ipaq_open(struct tty_struct *tty,
 			struct usb_serial_port *port, struct file *filp);
 static void ipaq_close(struct tty_struct *tty,
 			struct usb_serial_port *port, struct file *filp);
+static int  ipaq_calc_num_ports(struct usb_serial *serial);
 static int  ipaq_startup(struct usb_serial *serial);
 static void ipaq_shutdown(struct usb_serial *serial);
 static int ipaq_write(struct tty_struct *tty, struct usb_serial_port *port,
@@ -572,15 +573,10 @@ static struct usb_serial_driver ipaq_device = {
 	.description =		"PocketPC PDA",
 	.usb_driver = 		&ipaq_driver,
 	.id_table =		ipaq_id_table,
-	/*
-	 * some devices have an extra endpoint, which
-	 * must be ignored as it would make the core
-	 * create a second port which oopses when used
-	 */
-	.num_ports =		1,
 	.open =			ipaq_open,
 	.close =		ipaq_close,
 	.attach =		ipaq_startup,
+	.calc_num_ports =	ipaq_calc_num_ports,
 	.shutdown =		ipaq_shutdown,
 	.write =		ipaq_write,
 	.write_room =		ipaq_write_room,
@@ -956,14 +952,49 @@ static void ipaq_destroy_lists(struct usb_serial_port *port)
 }
 
 
+static int ipaq_calc_num_ports(struct usb_serial *serial)
+{
+	/*
+	 * some devices have 3 endpoints, the 3rd of which
+	 * must be ignored as it would make the core
+	 * create a second port which oopses when used
+	 */
+	int ipaq_num_ports = 1;
+
+	dbg("%s - numberofendpoints: %d", __FUNCTION__,
+		(int)serial->interface->cur_altsetting->desc.bNumEndpoints);
+
+	/*
+	 * a few devices have 4 endpoints, seemingly Yakuma devices,
+	 * and we need the second pair, so let them have 2 ports
+	 *
+	 * TODO: can we drop port 1 ?
+	 */
+	if (serial->interface->cur_altsetting->desc.bNumEndpoints > 3) {
+		ipaq_num_ports = 2;
+	}
+
+	return ipaq_num_ports;
+}
+
+
 static int ipaq_startup(struct usb_serial *serial)
 {
 	dbg("%s", __func__);
 	if (serial->dev->actconfig->desc.bConfigurationValue != 1) {
+		/*
+		 * FIXME: HP iPaq rx3715, possibly others, have 1 config that
+		 * is labeled as 2
+		 */
+
 		dev_err(&serial->dev->dev, "active config #%d != 1 ??\n",
 			serial->dev->actconfig->desc.bConfigurationValue);
 		return -ENODEV;
 	}
+
+	dbg("%s - iPAQ module configured for %d ports",
+		__FUNCTION__, serial->num_ports);
+
 	return usb_reset_configuration(serial->dev);
 }
 

commit 194343d9364ea07c9f27c4505380a15a905e8a24
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed Aug 20 16:56:34 2008 -0700

    USB: remove use of err() in drivers/usb/serial
    
    err() is going away, so switch to dev_err() or printk() if it's really
    needed.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c
index 5108cbc64a55..132be74d2b89 100644
--- a/drivers/usb/serial/ipaq.c
+++ b/drivers/usb/serial/ipaq.c
@@ -608,7 +608,7 @@ static int ipaq_open(struct tty_struct *tty,
 	bytes_out = 0;
 	priv = kmalloc(sizeof(struct ipaq_private), GFP_KERNEL);
 	if (priv == NULL) {
-		err("%s - Out of memory", __func__);
+		dev_err(&port->dev, "%s - Out of memory\n", __func__);
 		return -ENOMEM;
 	}
 	usb_set_serial_port_data(port, priv);
@@ -693,8 +693,7 @@ static int ipaq_open(struct tty_struct *tty,
 	}
 
 	if (!retries && result) {
-		err("%s - failed doing control urb, error %d", __func__,
-		    result);
+		dev_err(&port->dev, "%s - failed doing control urb, error %d\n",			__func__, result);
 		goto error;
 	}
 
@@ -707,8 +706,9 @@ static int ipaq_open(struct tty_struct *tty,
 
 	result = usb_submit_urb(port->read_urb, GFP_KERNEL);
 	if (result) {
-		err("%s - failed submitting read urb, error %d",
-						__func__, result);
+		dev_err(&port->dev,
+			"%s - failed submitting read urb, error %d\n",
+			__func__, result);
 		goto error;
 	}
 
@@ -716,7 +716,7 @@ static int ipaq_open(struct tty_struct *tty,
 
 enomem:
 	result = -ENOMEM;
-	err("%s - Out of memory", __func__);
+	dev_err(&port->dev, "%s - Out of memory\n", __func__);
 error:
 	ipaq_destroy_lists(port);
 	kfree(priv);
@@ -781,8 +781,9 @@ static void ipaq_read_bulk_callback(struct urb *urb)
 	    ipaq_read_bulk_callback, port);
 	result = usb_submit_urb(port->read_urb, GFP_ATOMIC);
 	if (result)
-		err("%s - failed resubmitting read urb, error %d",
-							__func__, result);
+		dev_err(&port->dev,
+			"%s - failed resubmitting read urb, error %d\n",
+			__func__, result);
 	return;
 }
 
@@ -847,7 +848,8 @@ static int ipaq_write_bulk(struct usb_serial_port *port,
 		spin_unlock_irqrestore(&write_list_lock, flags);
 		result = usb_submit_urb(port->write_urb, GFP_ATOMIC);
 		if (result)
-			err("%s - failed submitting write urb, error %d",
+			dev_err(&port->dev,
+				"%s - failed submitting write urb, error %d\n",
 				__func__, result);
 	} else {
 		spin_unlock_irqrestore(&write_list_lock, flags);
@@ -909,8 +911,9 @@ static void ipaq_write_bulk_callback(struct urb *urb)
 		spin_unlock_irqrestore(&write_list_lock, flags);
 		result = usb_submit_urb(port->write_urb, GFP_ATOMIC);
 		if (result)
-			err("%s - failed submitting write urb, error %d",
-					__func__, result);
+			dev_err(&port->dev,
+				"%s - failed submitting write urb, error %d\n",
+				__func__, result);
 	} else {
 		priv->active = 0;
 		spin_unlock_irqrestore(&write_list_lock, flags);
@@ -957,7 +960,7 @@ static int ipaq_startup(struct usb_serial *serial)
 {
 	dbg("%s", __func__);
 	if (serial->dev->actconfig->desc.bConfigurationValue != 1) {
-		err("active config #%d != 1 ??",
+		dev_err(&serial->dev->dev, "active config #%d != 1 ??\n",
 			serial->dev->actconfig->desc.bConfigurationValue);
 		return -ENODEV;
 	}

commit c197a8db59daf06dc5e77acd5a9681329cb22458
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Aug 18 13:21:04 2008 -0700

    USB: remove info() macro from usb/serial drivers
    
    USB should not be having it's own printk macros, so remove info() and
    use the system-wide standard of dev_info() wherever possible.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c
index 2affa9c118b2..5108cbc64a55 100644
--- a/drivers/usb/serial/ipaq.c
+++ b/drivers/usb/serial/ipaq.c
@@ -976,7 +976,6 @@ static int __init ipaq_init(void)
 	retval = usb_serial_register(&ipaq_device);
 	if (retval)
 		goto failed_usb_serial_register;
-	info(DRIVER_DESC " " DRIVER_VERSION);
 	if (vendor) {
 		ipaq_id_table[0].idVendor = vendor;
 		ipaq_id_table[0].idProduct = product;
@@ -985,6 +984,8 @@ static int __init ipaq_init(void)
 	if (retval)
 		goto failed_usb_register;
 
+	printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
+	       DRIVER_DESC "\n");
 	return 0;
 failed_usb_register:
 	usb_serial_deregister(&ipaq_device);

commit 4a90f09b20f4622dcbff1f0e1e6bae1704f8ad8c
Author: Alan Cox <alan@redhat.com>
Date:   Mon Oct 13 10:39:46 2008 +0100

    tty: usb-serial krefs
    
    Use kref in the USB serial drivers so that we don't free tty structures
    from under the URB receive handlers as has historically been the case if
    you were unlucky. This also gives us a framework for general tty drivers to
    use tty_port objects and refcount.
    
    Contains two err->dev_err changes merged together to fix clashes in the
    -next tree.
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c
index cd9a2e138c8b..2affa9c118b2 100644
--- a/drivers/usb/serial/ipaq.c
+++ b/drivers/usb/serial/ipaq.c
@@ -764,13 +764,14 @@ static void ipaq_read_bulk_callback(struct urb *urb)
 	usb_serial_debug_data(debug, &port->dev, __func__,
 						urb->actual_length, data);
 
-	tty = port->port.tty;
+	tty = tty_port_tty_get(&port->port);
 	if (tty && urb->actual_length) {
 		tty_buffer_request_room(tty, urb->actual_length);
 		tty_insert_flip_string(tty, data, urb->actual_length);
 		tty_flip_buffer_push(tty);
 		bytes_in += urb->actual_length;
 	}
+	tty_kref_put(tty);
 
 	/* Continue trying to always read  */
 	usb_fill_bulk_urb(port->read_urb, port->serial->dev,

commit 852fef69c0d9510a28a70221cfddd004efa02552
Author: Oliver Neukum <oliver@neukum.org>
Date:   Sat Jul 26 22:42:42 2008 +0200

    fix for a memory leak in an error case introduced by fix for double free
    
    The fix NULLed a pointer without freeing it.
    
    Signed-off-by: Oliver Neukum <oneukum@suse.de>
    Reported-by: Juha Motorsportcom <juha_motorsportcom@luukku.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c
index 832a5a4f3cb3..cd9a2e138c8b 100644
--- a/drivers/usb/serial/ipaq.c
+++ b/drivers/usb/serial/ipaq.c
@@ -651,15 +651,17 @@ static int ipaq_open(struct tty_struct *tty,
 	 */
 
 	kfree(port->bulk_in_buffer);
+	kfree(port->bulk_out_buffer);
+	/* make sure the generic serial code knows */
+	port->bulk_out_buffer = NULL;
+
 	port->bulk_in_buffer = kmalloc(URBDATA_SIZE, GFP_KERNEL);
-	if (port->bulk_in_buffer == NULL) {
-		port->bulk_out_buffer = NULL; /* prevent double free */
+	if (port->bulk_in_buffer == NULL)
 		goto enomem;
-	}
 
-	kfree(port->bulk_out_buffer);
 	port->bulk_out_buffer = kmalloc(URBDATA_SIZE, GFP_KERNEL);
 	if (port->bulk_out_buffer == NULL) {
+		/* the buffer is useless, free it */
 		kfree(port->bulk_in_buffer);
 		port->bulk_in_buffer = NULL;
 		goto enomem;

commit eb6215ccd403153c6376f7eaa7b31eef19e488f5
Author: Alan Cox <alan@redhat.com>
Date:   Tue Jul 22 11:12:41 2008 +0100

    ipaq: Coding style
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c
index a7784642d6a1..832a5a4f3cb3 100644
--- a/drivers/usb/serial/ipaq.c
+++ b/drivers/usb/serial/ipaq.c
@@ -53,7 +53,7 @@
 #include <linux/tty_flip.h>
 #include <linux/module.h>
 #include <linux/spinlock.h>
-#include <asm/uaccess.h>
+#include <linux/uaccess.h>
 #include <linux/usb.h>
 #include <linux/usb/serial.h>
 #include "ipaq.h"
@@ -82,10 +82,10 @@ static int  ipaq_startup(struct usb_serial *serial);
 static void ipaq_shutdown(struct usb_serial *serial);
 static int ipaq_write(struct tty_struct *tty, struct usb_serial_port *port,
 			const unsigned char *buf, int count);
-static int ipaq_write_bulk(struct usb_serial_port *port, const unsigned char *buf,
-			int count);
+static int ipaq_write_bulk(struct usb_serial_port *port,
+				const unsigned char *buf, int count);
 static void ipaq_write_gather(struct usb_serial_port *port);
-static void ipaq_read_bulk_callback (struct urb *urb);
+static void ipaq_read_bulk_callback(struct urb *urb);
 static void ipaq_write_bulk_callback(struct urb *urb);
 static int ipaq_write_room(struct tty_struct *tty);
 static int ipaq_chars_in_buffer(struct tty_struct *tty);
@@ -552,7 +552,7 @@ static struct usb_device_id ipaq_id_table [] = {
 	{ }                             /* Terminating entry */
 };
 
-MODULE_DEVICE_TABLE (usb, ipaq_id_table);
+MODULE_DEVICE_TABLE(usb, ipaq_id_table);
 
 static struct usb_driver ipaq_driver = {
 	.name =		"ipaq",
@@ -620,9 +620,9 @@ static int ipaq_open(struct tty_struct *tty,
 
 	for (i = 0; i < URBDATA_QUEUE_MAX / PACKET_SIZE; i++) {
 		pkt = kmalloc(sizeof(struct ipaq_packet), GFP_KERNEL);
-		if (pkt == NULL) {
+		if (pkt == NULL)
 			goto enomem;
-		}
+
 		pkt->data = kmalloc(PACKET_SIZE, GFP_KERNEL);
 		if (pkt->data == NULL) {
 			kfree(pkt);
@@ -667,8 +667,9 @@ static int ipaq_open(struct tty_struct *tty,
 	port->read_urb->transfer_buffer = port->bulk_in_buffer;
 	port->write_urb->transfer_buffer = port->bulk_out_buffer;
 	port->read_urb->transfer_buffer_length = URBDATA_SIZE;
-	port->bulk_out_size = port->write_urb->transfer_buffer_length = URBDATA_SIZE;
-	
+	port->bulk_out_size = port->write_urb->transfer_buffer_length
+							= URBDATA_SIZE;
+
 	msleep(1000*initial_wait);
 
 	/*
@@ -697,13 +698,15 @@ static int ipaq_open(struct tty_struct *tty,
 
 	/* Start reading from the device */
 	usb_fill_bulk_urb(port->read_urb, serial->dev,
-		      usb_rcvbulkpipe(serial->dev, port->bulk_in_endpointAddress),
-		      port->read_urb->transfer_buffer, port->read_urb->transfer_buffer_length,
-		      ipaq_read_bulk_callback, port);
+		usb_rcvbulkpipe(serial->dev, port->bulk_in_endpointAddress),
+		port->read_urb->transfer_buffer,
+		port->read_urb->transfer_buffer_length,
+		ipaq_read_bulk_callback, port);
 
 	result = usb_submit_urb(port->read_urb, GFP_KERNEL);
 	if (result) {
-		err("%s - failed submitting read urb, error %d", __func__, result);
+		err("%s - failed submitting read urb, error %d",
+						__func__, result);
 		goto error;
 	}
 
@@ -725,7 +728,7 @@ static void ipaq_close(struct tty_struct *tty,
 	struct ipaq_private	*priv = usb_get_serial_port_data(port);
 
 	dbg("%s - port %d", __func__, port->number);
-			 
+
 	/*
 	 * shut down bulk read and write
 	 */
@@ -735,7 +738,8 @@ static void ipaq_close(struct tty_struct *tty,
 	kfree(priv);
 	usb_set_serial_port_data(port, NULL);
 
-	/* Uncomment the following line if you want to see some statistics in your syslog */
+	/* Uncomment the following line if you want to see some statistics
+	 * in your syslog */
 	/* info ("Bytes In = %d  Bytes Out = %d", bytes_in, bytes_out); */
 }
 
@@ -755,7 +759,8 @@ static void ipaq_read_bulk_callback(struct urb *urb)
 		return;
 	}
 
-	usb_serial_debug_data(debug, &port->dev, __func__, urb->actual_length, data);
+	usb_serial_debug_data(debug, &port->dev, __func__,
+						urb->actual_length, data);
 
 	tty = port->port.tty;
 	if (tty && urb->actual_length) {
@@ -766,13 +771,15 @@ static void ipaq_read_bulk_callback(struct urb *urb)
 	}
 
 	/* Continue trying to always read  */
-	usb_fill_bulk_urb(port->read_urb, port->serial->dev, 
-		      usb_rcvbulkpipe(port->serial->dev, port->bulk_in_endpointAddress),
-		      port->read_urb->transfer_buffer, port->read_urb->transfer_buffer_length,
-		      ipaq_read_bulk_callback, port);
+	usb_fill_bulk_urb(port->read_urb, port->serial->dev,
+	    usb_rcvbulkpipe(port->serial->dev, port->bulk_in_endpointAddress),
+	    port->read_urb->transfer_buffer,
+	    port->read_urb->transfer_buffer_length,
+	    ipaq_read_bulk_callback, port);
 	result = usb_submit_urb(port->read_urb, GFP_ATOMIC);
 	if (result)
-		err("%s - failed resubmitting read urb, error %d", __func__, result);
+		err("%s - failed resubmitting read urb, error %d",
+							__func__, result);
 	return;
 }
 
@@ -787,9 +794,8 @@ static int ipaq_write(struct tty_struct *tty, struct usb_serial_port *port,
 
 	while (count > 0) {
 		transfer_size = min(count, PACKET_SIZE);
-		if (ipaq_write_bulk(port, current_position, transfer_size)) {
+		if (ipaq_write_bulk(port, current_position, transfer_size))
 			break;
-		}
 		current_position += transfer_size;
 		bytes_sent += transfer_size;
 		count -= transfer_size;
@@ -797,10 +803,10 @@ static int ipaq_write(struct tty_struct *tty, struct usb_serial_port *port,
 	}
 
 	return bytes_sent;
-} 
+}
 
-static int ipaq_write_bulk(struct usb_serial_port *port, const unsigned char *buf,
-			   int count)
+static int ipaq_write_bulk(struct usb_serial_port *port,
+					const unsigned char *buf, int count)
 {
 	struct ipaq_private	*priv = usb_get_serial_port_data(port);
 	struct ipaq_packet	*pkt = NULL;
@@ -837,9 +843,9 @@ static int ipaq_write_bulk(struct usb_serial_port *port, const unsigned char *bu
 		ipaq_write_gather(port);
 		spin_unlock_irqrestore(&write_list_lock, flags);
 		result = usb_submit_urb(port->write_urb, GFP_ATOMIC);
-		if (result) {
-			err("%s - failed submitting write urb, error %d", __func__, result);
-		}
+		if (result)
+			err("%s - failed submitting write urb, error %d",
+				__func__, result);
 	} else {
 		spin_unlock_irqrestore(&write_list_lock, flags);
 	}
@@ -866,16 +872,15 @@ static void ipaq_write_gather(struct usb_serial_port *port)
 			list_move(&pkt->list, &priv->freelist);
 			priv->free_len += PACKET_SIZE;
 		}
-		if (room == 0) {
+		if (room == 0)
 			break;
-		}
 	}
 
 	count = URBDATA_SIZE - room;
-	usb_fill_bulk_urb(port->write_urb, serial->dev, 
-		      usb_sndbulkpipe(serial->dev, port->bulk_out_endpointAddress),
-		      port->write_urb->transfer_buffer, count, ipaq_write_bulk_callback,
-		      port);
+	usb_fill_bulk_urb(port->write_urb, serial->dev,
+		usb_sndbulkpipe(serial->dev, port->bulk_out_endpointAddress),
+		port->write_urb->transfer_buffer, count,
+		ipaq_write_bulk_callback, port);
 	return;
 }
 
@@ -900,9 +905,9 @@ static void ipaq_write_bulk_callback(struct urb *urb)
 		ipaq_write_gather(port);
 		spin_unlock_irqrestore(&write_list_lock, flags);
 		result = usb_submit_urb(port->write_urb, GFP_ATOMIC);
-		if (result) {
-			err("%s - failed submitting write urb, error %d", __func__, result);
-		}
+		if (result)
+			err("%s - failed submitting write urb, error %d",
+					__func__, result);
 	} else {
 		priv->active = 0;
 		spin_unlock_irqrestore(&write_list_lock, flags);
@@ -953,7 +958,7 @@ static int ipaq_startup(struct usb_serial *serial)
 			serial->dev->actconfig->desc.bConfigurationValue);
 		return -ENODEV;
 	}
-	return usb_reset_configuration (serial->dev);
+	return usb_reset_configuration(serial->dev);
 }
 
 static void ipaq_shutdown(struct usb_serial *serial)
@@ -966,7 +971,7 @@ static int __init ipaq_init(void)
 	int retval;
 	spin_lock_init(&write_list_lock);
 	retval = usb_serial_register(&ipaq_device);
-	if (retval) 
+	if (retval)
 		goto failed_usb_serial_register;
 	info(DRIVER_DESC " " DRIVER_VERSION);
 	if (vendor) {
@@ -976,7 +981,7 @@ static int __init ipaq_init(void)
 	retval = usb_register(&ipaq_driver);
 	if (retval)
 		goto failed_usb_register;
-		  
+
 	return 0;
 failed_usb_register:
 	usb_serial_deregister(&ipaq_device);
@@ -995,8 +1000,8 @@ static void __exit ipaq_exit(void)
 module_init(ipaq_init);
 module_exit(ipaq_exit);
 
-MODULE_AUTHOR( DRIVER_AUTHOR );
-MODULE_DESCRIPTION( DRIVER_DESC );
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_DESCRIPTION(DRIVER_DESC);
 MODULE_LICENSE("GPL");
 
 module_param(debug, bool, S_IRUGO | S_IWUSR);
@@ -1009,7 +1014,9 @@ module_param(product, ushort, 0);
 MODULE_PARM_DESC(product, "User specified USB idProduct");
 
 module_param(connect_retries, int, S_IRUGO|S_IWUSR);
-MODULE_PARM_DESC(connect_retries, "Maximum number of connect retries (one second each)");
+MODULE_PARM_DESC(connect_retries,
+		"Maximum number of connect retries (one second each)");
 
 module_param(initial_wait, int, S_IRUGO|S_IWUSR);
-MODULE_PARM_DESC(initial_wait, "Time to wait before attempting a connection (in seconds)");
+MODULE_PARM_DESC(initial_wait,
+		"Time to wait before attempting a connection (in seconds)");

commit 95da310e66ee8090119596c70ca8432e57f9a97f
Author: Alan Cox <alan@redhat.com>
Date:   Tue Jul 22 11:09:07 2008 +0100

    usb_serial: API all change
    
    USB serial likes to use port->tty back pointers for the real work it does and
    to do so without any actual locking. Unfortunately when you consider hangup
    events, hangup/parallel reopen or even worse hangup followed by parallel close
    events the tty->port and port->tty pointers are not guaranteed to be the same
    as port->tty is the active tty while tty->port is the port the tty may or
    may not still be attached to.
    
    So rework the entire API to pass the tty struct. For console cases we need
    to pass both for now. This shows up multiple drivers that immediately crash
    with USB console some of which have been fixed in the process.
    
    Longer term we need a proper tty as console abstraction
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c
index 80d9ec5570d6..a7784642d6a1 100644
--- a/drivers/usb/serial/ipaq.c
+++ b/drivers/usb/serial/ipaq.c
@@ -74,19 +74,21 @@ static int connect_retries = KP_RETRIES;
 static int initial_wait;
 
 /* Function prototypes for an ipaq */
-static int  ipaq_open (struct usb_serial_port *port, struct file *filp);
-static void ipaq_close (struct usb_serial_port *port, struct file *filp);
-static int  ipaq_startup (struct usb_serial *serial);
-static void ipaq_shutdown (struct usb_serial *serial);
-static int ipaq_write(struct usb_serial_port *port, const unsigned char *buf,
-		       int count);
+static int  ipaq_open(struct tty_struct *tty,
+			struct usb_serial_port *port, struct file *filp);
+static void ipaq_close(struct tty_struct *tty,
+			struct usb_serial_port *port, struct file *filp);
+static int  ipaq_startup(struct usb_serial *serial);
+static void ipaq_shutdown(struct usb_serial *serial);
+static int ipaq_write(struct tty_struct *tty, struct usb_serial_port *port,
+			const unsigned char *buf, int count);
 static int ipaq_write_bulk(struct usb_serial_port *port, const unsigned char *buf,
-			   int count);
+			int count);
 static void ipaq_write_gather(struct usb_serial_port *port);
 static void ipaq_read_bulk_callback (struct urb *urb);
 static void ipaq_write_bulk_callback(struct urb *urb);
-static int ipaq_write_room(struct usb_serial_port *port);
-static int ipaq_chars_in_buffer(struct usb_serial_port *port);
+static int ipaq_write_room(struct tty_struct *tty);
+static int ipaq_chars_in_buffer(struct tty_struct *tty);
 static void ipaq_destroy_lists(struct usb_serial_port *port);
 
 
@@ -591,7 +593,8 @@ static spinlock_t	write_list_lock;
 static int		bytes_in;
 static int		bytes_out;
 
-static int ipaq_open(struct usb_serial_port *port, struct file *filp)
+static int ipaq_open(struct tty_struct *tty,
+			struct usb_serial_port *port, struct file *filp)
 {
 	struct usb_serial	*serial = port->serial;
 	struct ipaq_private	*priv;
@@ -637,10 +640,12 @@ static int ipaq_open(struct usb_serial_port *port, struct file *filp)
 	 * discipline instead of queueing.
 	 */
 
-	port->tty->low_latency = 1;
-	port->tty->raw = 1;
-	port->tty->real_raw = 1;
-
+	if (tty) {
+		tty->low_latency = 1;
+		/* FIXME: These two are bogus */
+		tty->raw = 1;
+		tty->real_raw = 1;
+	}
 	/*
 	 * Lose the small buffers usbserial provides. Make larger ones.
 	 */
@@ -714,7 +719,8 @@ static int ipaq_open(struct usb_serial_port *port, struct file *filp)
 }
 
 
-static void ipaq_close(struct usb_serial_port *port, struct file *filp)
+static void ipaq_close(struct tty_struct *tty,
+			struct usb_serial_port *port, struct file *filp)
 {
 	struct ipaq_private	*priv = usb_get_serial_port_data(port);
 
@@ -751,7 +757,7 @@ static void ipaq_read_bulk_callback(struct urb *urb)
 
 	usb_serial_debug_data(debug, &port->dev, __func__, urb->actual_length, data);
 
-	tty = port->tty;
+	tty = port->port.tty;
 	if (tty && urb->actual_length) {
 		tty_buffer_request_room(tty, urb->actual_length);
 		tty_insert_flip_string(tty, data, urb->actual_length);
@@ -770,8 +776,8 @@ static void ipaq_read_bulk_callback(struct urb *urb)
 	return;
 }
 
-static int ipaq_write(struct usb_serial_port *port, const unsigned char *buf,
-		       int count)
+static int ipaq_write(struct tty_struct *tty, struct usb_serial_port *port,
+			const unsigned char *buf, int count)
 {
 	const unsigned char	*current_position = buf;
 	int			bytes_sent = 0;
@@ -905,16 +911,18 @@ static void ipaq_write_bulk_callback(struct urb *urb)
 	usb_serial_port_softint(port);
 }
 
-static int ipaq_write_room(struct usb_serial_port *port)
+static int ipaq_write_room(struct tty_struct *tty)
 {
+	struct usb_serial_port *port = tty->driver_data;
 	struct ipaq_private	*priv = usb_get_serial_port_data(port);
 
 	dbg("%s - freelen %d", __func__, priv->free_len);
 	return priv->free_len;
 }
 
-static int ipaq_chars_in_buffer(struct usb_serial_port *port)
+static int ipaq_chars_in_buffer(struct tty_struct *tty)
 {
+	struct usb_serial_port *port = tty->driver_data;
 	struct ipaq_private	*priv = usb_get_serial_port_data(port);
 
 	dbg("%s - queuelen %d", __func__, priv->queue_len);

commit df3e1ab7334279bc744344bcf05272dc8b985d3d
Author: Oliver Neukum <oliver@neukum.org>
Date:   Mon Jun 30 14:33:57 2008 +0200

    USB: fix double kfree in ipaq in error case
    
    in the error case the ipaq driver leaves a dangling pointer to already
    freed memory that will be freed again.
    
    Signed-off-by: Oliver Neukum <oneukum@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c
index d9fb3768a2d7..80d9ec5570d6 100644
--- a/drivers/usb/serial/ipaq.c
+++ b/drivers/usb/serial/ipaq.c
@@ -646,12 +646,13 @@ static int ipaq_open(struct usb_serial_port *port, struct file *filp)
 	 */
 
 	kfree(port->bulk_in_buffer);
-	kfree(port->bulk_out_buffer);
 	port->bulk_in_buffer = kmalloc(URBDATA_SIZE, GFP_KERNEL);
 	if (port->bulk_in_buffer == NULL) {
 		port->bulk_out_buffer = NULL; /* prevent double free */
 		goto enomem;
 	}
+
+	kfree(port->bulk_out_buffer);
 	port->bulk_out_buffer = kmalloc(URBDATA_SIZE, GFP_KERNEL);
 	if (port->bulk_out_buffer == NULL) {
 		kfree(port->bulk_in_buffer);

commit b89cbb81aec2015b4020221564ced1569e1a8900
Author: Oliver Neukum <oliver@neukum.org>
Date:   Thu Jul 3 17:14:16 2008 +0200

    USB: adding comment for ipaq forcing number of ports
    
    The reason for forcing a number of ports should be documented.
    
    Signed-off-by: Oliver Neukum <oneukum@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c
index 5e15dec9f315..d9fb3768a2d7 100644
--- a/drivers/usb/serial/ipaq.c
+++ b/drivers/usb/serial/ipaq.c
@@ -570,6 +570,11 @@ static struct usb_serial_driver ipaq_device = {
 	.description =		"PocketPC PDA",
 	.usb_driver = 		&ipaq_driver,
 	.id_table =		ipaq_id_table,
+	/*
+	 * some devices have an extra endpoint, which
+	 * must be ignored as it would make the core
+	 * create a second port which oopses when used
+	 */
 	.num_ports =		1,
 	.open =			ipaq_open,
 	.close =		ipaq_close,

commit 4edb966b375dfbabfc96b580a164c5ae90584aa0
Author: Oliver Neukum <oliver@neukum.org>
Date:   Thu Jul 3 10:05:57 2008 +0200

    USB: fix Oops on loading ipaq module since 2.6.26
    
    Fixes bugzilla.kernel.org #10868
    
    Signed-off-by: Oliver Neukum <oneukum@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c
index ea924dc48496..5e15dec9f315 100644
--- a/drivers/usb/serial/ipaq.c
+++ b/drivers/usb/serial/ipaq.c
@@ -570,7 +570,7 @@ static struct usb_serial_driver ipaq_device = {
 	.description =		"PocketPC PDA",
 	.usb_driver = 		&ipaq_driver,
 	.id_table =		ipaq_id_table,
-	.num_ports =		2,
+	.num_ports =		1,
 	.open =			ipaq_open,
 	.close =		ipaq_close,
 	.attach =		ipaq_startup,

commit cdc97792289179974af6dda781c855696358d307
Author: Ming Lei <tom.leiming@gmail.com>
Date:   Sun Feb 24 18:41:47 2008 +0800

    USB: remove unnecessary type casting of urb->context
    
    urb->context code cleanup
    
    Signed-off-by: Ming Lei <tom.leiming@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c
index c90436ea8060..ea924dc48496 100644
--- a/drivers/usb/serial/ipaq.c
+++ b/drivers/usb/serial/ipaq.c
@@ -729,7 +729,7 @@ static void ipaq_close(struct usb_serial_port *port, struct file *filp)
 
 static void ipaq_read_bulk_callback(struct urb *urb)
 {
-	struct usb_serial_port	*port = (struct usb_serial_port *)urb->context;
+	struct usb_serial_port	*port = urb->context;
 	struct tty_struct	*tty;
 	unsigned char		*data = urb->transfer_buffer;
 	int			result;
@@ -869,7 +869,7 @@ static void ipaq_write_gather(struct usb_serial_port *port)
 
 static void ipaq_write_bulk_callback(struct urb *urb)
 {
-	struct usb_serial_port	*port = (struct usb_serial_port *)urb->context;
+	struct usb_serial_port	*port = urb->context;
 	struct ipaq_private	*priv = usb_get_serial_port_data(port);
 	unsigned long		flags;
 	int			result;

commit 441b62c1edb986827154768d89bbac0ba779984f
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Mon Mar 3 16:08:34 2008 -0800

    USB: replace remaining __FUNCTION__ occurrences
    
    __FUNCTION__ is gcc-specific, use __func__
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c
index 1711dda0ea6d..c90436ea8060 100644
--- a/drivers/usb/serial/ipaq.c
+++ b/drivers/usb/serial/ipaq.c
@@ -594,13 +594,13 @@ static int ipaq_open(struct usb_serial_port *port, struct file *filp)
 	int			i, result = 0;
 	int			retries = connect_retries;
 
-	dbg("%s - port %d", __FUNCTION__, port->number);
+	dbg("%s - port %d", __func__, port->number);
 
 	bytes_in = 0;
 	bytes_out = 0;
 	priv = kmalloc(sizeof(struct ipaq_private), GFP_KERNEL);
 	if (priv == NULL) {
-		err("%s - Out of memory", __FUNCTION__);
+		err("%s - Out of memory", __func__);
 		return -ENOMEM;
 	}
 	usb_set_serial_port_data(port, priv);
@@ -679,7 +679,7 @@ static int ipaq_open(struct usb_serial_port *port, struct file *filp)
 	}
 
 	if (!retries && result) {
-		err("%s - failed doing control urb, error %d", __FUNCTION__,
+		err("%s - failed doing control urb, error %d", __func__,
 		    result);
 		goto error;
 	}
@@ -692,7 +692,7 @@ static int ipaq_open(struct usb_serial_port *port, struct file *filp)
 
 	result = usb_submit_urb(port->read_urb, GFP_KERNEL);
 	if (result) {
-		err("%s - failed submitting read urb, error %d", __FUNCTION__, result);
+		err("%s - failed submitting read urb, error %d", __func__, result);
 		goto error;
 	}
 
@@ -700,7 +700,7 @@ static int ipaq_open(struct usb_serial_port *port, struct file *filp)
 
 enomem:
 	result = -ENOMEM;
-	err("%s - Out of memory", __FUNCTION__);
+	err("%s - Out of memory", __func__);
 error:
 	ipaq_destroy_lists(port);
 	kfree(priv);
@@ -712,7 +712,7 @@ static void ipaq_close(struct usb_serial_port *port, struct file *filp)
 {
 	struct ipaq_private	*priv = usb_get_serial_port_data(port);
 
-	dbg("%s - port %d", __FUNCTION__, port->number);
+	dbg("%s - port %d", __func__, port->number);
 			 
 	/*
 	 * shut down bulk read and write
@@ -735,15 +735,15 @@ static void ipaq_read_bulk_callback(struct urb *urb)
 	int			result;
 	int status = urb->status;
 
-	dbg("%s - port %d", __FUNCTION__, port->number);
+	dbg("%s - port %d", __func__, port->number);
 
 	if (status) {
 		dbg("%s - nonzero read bulk status received: %d",
-		    __FUNCTION__, status);
+		    __func__, status);
 		return;
 	}
 
-	usb_serial_debug_data(debug, &port->dev, __FUNCTION__, urb->actual_length, data);
+	usb_serial_debug_data(debug, &port->dev, __func__, urb->actual_length, data);
 
 	tty = port->tty;
 	if (tty && urb->actual_length) {
@@ -760,7 +760,7 @@ static void ipaq_read_bulk_callback(struct urb *urb)
 		      ipaq_read_bulk_callback, port);
 	result = usb_submit_urb(port->read_urb, GFP_ATOMIC);
 	if (result)
-		err("%s - failed resubmitting read urb, error %d", __FUNCTION__, result);
+		err("%s - failed resubmitting read urb, error %d", __func__, result);
 	return;
 }
 
@@ -771,7 +771,7 @@ static int ipaq_write(struct usb_serial_port *port, const unsigned char *buf,
 	int			bytes_sent = 0;
 	int			transfer_size;
 
-	dbg("%s - port %d", __FUNCTION__, port->number);
+	dbg("%s - port %d", __func__, port->number);
 
 	while (count > 0) {
 		transfer_size = min(count, PACKET_SIZE);
@@ -796,7 +796,7 @@ static int ipaq_write_bulk(struct usb_serial_port *port, const unsigned char *bu
 	unsigned long		flags;
 
 	if (priv->free_len <= 0) {
-		dbg("%s - we're stuffed", __FUNCTION__);
+		dbg("%s - we're stuffed", __func__);
 		return -EAGAIN;
 	}
 
@@ -808,12 +808,12 @@ static int ipaq_write_bulk(struct usb_serial_port *port, const unsigned char *bu
 	}
 	spin_unlock_irqrestore(&write_list_lock, flags);
 	if (pkt == NULL) {
-		dbg("%s - we're stuffed", __FUNCTION__);
+		dbg("%s - we're stuffed", __func__);
 		return -EAGAIN;
 	}
 
 	memcpy(pkt->data, buf, count);
-	usb_serial_debug_data(debug, &port->dev, __FUNCTION__, count, pkt->data);
+	usb_serial_debug_data(debug, &port->dev, __func__, count, pkt->data);
 
 	pkt->len = count;
 	pkt->written = 0;
@@ -826,7 +826,7 @@ static int ipaq_write_bulk(struct usb_serial_port *port, const unsigned char *bu
 		spin_unlock_irqrestore(&write_list_lock, flags);
 		result = usb_submit_urb(port->write_urb, GFP_ATOMIC);
 		if (result) {
-			err("%s - failed submitting write urb, error %d", __FUNCTION__, result);
+			err("%s - failed submitting write urb, error %d", __func__, result);
 		}
 	} else {
 		spin_unlock_irqrestore(&write_list_lock, flags);
@@ -875,11 +875,11 @@ static void ipaq_write_bulk_callback(struct urb *urb)
 	int			result;
 	int status = urb->status;
 
-	dbg("%s - port %d", __FUNCTION__, port->number);
+	dbg("%s - port %d", __func__, port->number);
 
 	if (status) {
 		dbg("%s - nonzero write bulk status received: %d",
-		    __FUNCTION__, status);
+		    __func__, status);
 		return;
 	}
 
@@ -889,7 +889,7 @@ static void ipaq_write_bulk_callback(struct urb *urb)
 		spin_unlock_irqrestore(&write_list_lock, flags);
 		result = usb_submit_urb(port->write_urb, GFP_ATOMIC);
 		if (result) {
-			err("%s - failed submitting write urb, error %d", __FUNCTION__, result);
+			err("%s - failed submitting write urb, error %d", __func__, result);
 		}
 	} else {
 		priv->active = 0;
@@ -903,7 +903,7 @@ static int ipaq_write_room(struct usb_serial_port *port)
 {
 	struct ipaq_private	*priv = usb_get_serial_port_data(port);
 
-	dbg("%s - freelen %d", __FUNCTION__, priv->free_len);
+	dbg("%s - freelen %d", __func__, priv->free_len);
 	return priv->free_len;
 }
 
@@ -911,7 +911,7 @@ static int ipaq_chars_in_buffer(struct usb_serial_port *port)
 {
 	struct ipaq_private	*priv = usb_get_serial_port_data(port);
 
-	dbg("%s - queuelen %d", __FUNCTION__, priv->queue_len);
+	dbg("%s - queuelen %d", __func__, priv->queue_len);
 	return priv->queue_len;
 }
 
@@ -933,7 +933,7 @@ static void ipaq_destroy_lists(struct usb_serial_port *port)
 
 static int ipaq_startup(struct usb_serial *serial)
 {
-	dbg("%s", __FUNCTION__);
+	dbg("%s", __func__);
 	if (serial->dev->actconfig->desc.bConfigurationValue != 1) {
 		err("active config #%d != 1 ??",
 			serial->dev->actconfig->desc.bConfigurationValue);
@@ -944,7 +944,7 @@ static int ipaq_startup(struct usb_serial *serial)
 
 static void ipaq_shutdown(struct usb_serial *serial)
 {
-	dbg("%s", __FUNCTION__);
+	dbg("%s", __func__);
 }
 
 static int __init ipaq_init(void)

commit 0ba4034e20abf372dae6c6cabeeeab600acb5889
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed Apr 16 09:17:38 2008 -0700

    USB: serial: remove unneeded number endpoints settings
    
    The usb-serial core no longer checks these fields so remove them from
    all of the individual drivers.  They will be removed from the usb-serial
    core in a patch later in the series.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c
index 17f2a53b8ba4..1711dda0ea6d 100644
--- a/drivers/usb/serial/ipaq.c
+++ b/drivers/usb/serial/ipaq.c
@@ -570,9 +570,6 @@ static struct usb_serial_driver ipaq_device = {
 	.description =		"PocketPC PDA",
 	.usb_driver = 		&ipaq_driver,
 	.id_table =		ipaq_id_table,
-	.num_interrupt_in =	NUM_DONT_CARE,
-	.num_bulk_in =		NUM_DONT_CARE,
-	.num_bulk_out =		NUM_DONT_CARE,
 	.num_ports =		2,
 	.open =			ipaq_open,
 	.close =		ipaq_close,

commit e1879b19b0abdb387e4aeb0b935a486cc75042fb
Author: Matthias Geissert <matthias.geissert@web.de>
Date:   Thu Mar 6 22:00:33 2008 +0100

    USB: ipaq: fix devices having more than one endpoint
    
    The ipaq module  supports devices with one endpoint only. Some devices,
    e.g. Yakumo Delta 300, have more than one endpoint.
    
    This patch fixes support for devices having up to 2 endpoints which used
    to work on older kernel versions.
    
    Signed-off-by: Matthias Geissert <matthias.geissert@web.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c
index 9b38a08ac83a..17f2a53b8ba4 100644
--- a/drivers/usb/serial/ipaq.c
+++ b/drivers/usb/serial/ipaq.c
@@ -571,9 +571,9 @@ static struct usb_serial_driver ipaq_device = {
 	.usb_driver = 		&ipaq_driver,
 	.id_table =		ipaq_id_table,
 	.num_interrupt_in =	NUM_DONT_CARE,
-	.num_bulk_in =		1,
-	.num_bulk_out =		1,
-	.num_ports =		1,
+	.num_bulk_in =		NUM_DONT_CARE,
+	.num_bulk_out =		NUM_DONT_CARE,
+	.num_ports =		2,
 	.open =			ipaq_open,
 	.close =		ipaq_close,
 	.attach =		ipaq_startup,

commit 96de0e252cedffad61b3cb5e05662c591898e69a
Author: Jan Engelhardt <jengelh@gmx.de>
Date:   Fri Oct 19 23:21:04 2007 +0200

    Convert files to UTF-8 and some cleanups
    
    * Convert files to UTF-8.
    
      * Also correct some people's names
        (one example is Eißfeldt, which was found in a source file.
        Given that the author used an ß at all in a source file
        indicates that the real name has in fact a 'ß' and not an 'ss',
        which is commonly used as a substitute for 'ß' when limited to
        7bit.)
    
      * Correct town names (Goettingen -> Göttingen)
    
      * Update Eberhard Mönkeberg's address (http://lkml.org/lkml/2007/1/8/313)
    
    Signed-off-by: Jan Engelhardt <jengelh@gmx.de>
    Signed-off-by: Adrian Bunk <bunk@kernel.org>

diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c
index e836ad07fdb9..9b38a08ac83a 100644
--- a/drivers/usb/serial/ipaq.c
+++ b/drivers/usb/serial/ipaq.c
@@ -306,7 +306,7 @@ static struct usb_device_id ipaq_id_table [] = {
 	{ USB_DEVICE(0x0930, 0x0705) }, /* TOSHIBA Pocket PC e310 */
 	{ USB_DEVICE(0x0930, 0x0706) }, /* TOSHIBA Pocket PC e740 */
 	{ USB_DEVICE(0x0930, 0x0707) }, /* TOSHIBA Pocket PC e330 Series */
-	{ USB_DEVICE(0x0930, 0x0708) }, /* TOSHIBA Pocket PC e350Series */
+	{ USB_DEVICE(0x0930, 0x0708) }, /* TOSHIBA Pocket PC e350 Series */
 	{ USB_DEVICE(0x0930, 0x0709) }, /* TOSHIBA Pocket PC e750 Series */
 	{ USB_DEVICE(0x0930, 0x070A) }, /* TOSHIBA Pocket PC e400 Series */
 	{ USB_DEVICE(0x0930, 0x070B) }, /* TOSHIBA Pocket PC e800 Series */
@@ -488,7 +488,7 @@ static struct usb_device_id ipaq_id_table [] = {
 	{ USB_DEVICE(0x0BF8, 0x1001) }, /* Fujitsu Siemens Computers USB Sync */
 	{ USB_DEVICE(0x0C44, 0x03A2) }, /* Motorola iDEN Smartphone */
 	{ USB_DEVICE(0x0C8E, 0x6000) }, /* Cesscom Luxian Series */
-	{ USB_DEVICE(0x0CAD, 0x9001) }, /* Motorola PowerPad Pocket PCDevice */
+	{ USB_DEVICE(0x0CAD, 0x9001) }, /* Motorola PowerPad Pocket PC Device */
 	{ USB_DEVICE(0x0F4E, 0x0200) }, /* Freedom Scientific USB Sync */
 	{ USB_DEVICE(0x0F98, 0x0201) }, /* Cyberbank USB Sync */
 	{ USB_DEVICE(0x0FB8, 0x3001) }, /* Wistron USB Sync */

commit eecfb911a03a48ef5f7114246343128bd01c1b5f
Author: Nobuhiro Iwamatsu <iwamatsu@nigauri.org>
Date:   Thu Oct 11 00:37:50 2007 +0900

    USB: Adding support for SHARP WS011SH to ipaq.c
    
    This patch supports for SHARP WS011SH[0] to ipaq.c
    
    [0]: http://www.willcom-inc.com/ja/lineup/ws/011sh/index.html
    (Sorry , Japanese only.)
    
    Signed-off-by: Nobuhiro Iwamatsu <iwamatsu@nigauri.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c
index c1a6484f6524..e836ad07fdb9 100644
--- a/drivers/usb/serial/ipaq.c
+++ b/drivers/usb/serial/ipaq.c
@@ -256,6 +256,7 @@ static struct usb_device_id ipaq_id_table [] = {
 	{ USB_DEVICE(0x04DD, 0x9121) }, /* SHARP WS004SH USB Modem */
 	{ USB_DEVICE(0x04DD, 0x9123) }, /* SHARP WS007SH USB Modem */
 	{ USB_DEVICE(0x04DD, 0x9151) }, /* SHARP S01SH USB Modem */
+	{ USB_DEVICE(0x04DD, 0x91AC) }, /* SHARP WS011SH USB Modem */
 	{ USB_DEVICE(0x04E8, 0x5F00) }, /* Samsung NEXiO USB Sync */
 	{ USB_DEVICE(0x04E8, 0x5F01) }, /* Samsung NEXiO USB Sync */
 	{ USB_DEVICE(0x04E8, 0x5F02) }, /* Samsung NEXiO USB Sync */

commit ed6590a861a16276db34ee626375fa79f3369ac3
Author: Oliver Neukum <oliver@neukum.org>
Date:   Mon Sep 17 20:15:53 2007 +0200

    USB: fix double frees in error code paths of ipaq driver
    
    the error code paths can be enter with buffers to freed buffers.
    Serial core would do a kfree() on memory already freed.
    
    Signed-off-by: Oliver Neukum <oneukum@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c
index 6a3a704b5849..c1a6484f6524 100644
--- a/drivers/usb/serial/ipaq.c
+++ b/drivers/usb/serial/ipaq.c
@@ -646,11 +646,13 @@ static int ipaq_open(struct usb_serial_port *port, struct file *filp)
 	kfree(port->bulk_out_buffer);
 	port->bulk_in_buffer = kmalloc(URBDATA_SIZE, GFP_KERNEL);
 	if (port->bulk_in_buffer == NULL) {
+		port->bulk_out_buffer = NULL; /* prevent double free */
 		goto enomem;
 	}
 	port->bulk_out_buffer = kmalloc(URBDATA_SIZE, GFP_KERNEL);
 	if (port->bulk_out_buffer == NULL) {
 		kfree(port->bulk_in_buffer);
+		port->bulk_in_buffer = NULL;
 		goto enomem;
 	}
 	port->read_urb->transfer_buffer = port->bulk_in_buffer;

commit 04cab1329336d4577d6638360c905e360934b425
Author: Christian Heim <phreak@gentoo.org>
Date:   Sun Aug 19 13:29:15 2007 +0200

    USB: Adding support for HTC Smartphones to ipaq
    
    This patch enables support for HTC Smartphones. The original patch is at
    https://bugs.gentoo.org/show_bug.cgi?id=187522. Original author is Mike Doty
    <kingtaco@gentoo.org>.
    
    Signed-off-by: Christian Heim <phreak@gentoo.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c
index 0455c1552ae9..6a3a704b5849 100644
--- a/drivers/usb/serial/ipaq.c
+++ b/drivers/usb/serial/ipaq.c
@@ -545,6 +545,7 @@ static struct usb_device_id ipaq_id_table [] = {
 	{ USB_DEVICE(0x413C, 0x4009) }, /* Dell Axim USB Sync */
 	{ USB_DEVICE(0x4505, 0x0010) }, /* Smartphone */
 	{ USB_DEVICE(0x5E04, 0xCE00) }, /* SAGEM Wireless Assistant */
+	{ USB_DEVICE(0x0BB4, 0x00CF) }, /* HTC smartphone modems */
 	{ }                             /* Terminating entry */
 };
 

commit 2362deb5782d9861a0dade72e2e29114652c69a3
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Jun 15 15:44:13 2007 -0700

    USB: serial: ipaq: clean up urb->status usage
    
    This done in anticipation of removal of urb->status, which will make
    that patch easier to review and apply in the future.
    
    
    Cc: <linux-usb-devel@lists.sourceforge.net>
    Cc: Ganesh Varadarajan <ganesh@veritas.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c
index 4df0ec74e0b1..0455c1552ae9 100644
--- a/drivers/usb/serial/ipaq.c
+++ b/drivers/usb/serial/ipaq.c
@@ -732,11 +732,13 @@ static void ipaq_read_bulk_callback(struct urb *urb)
 	struct tty_struct	*tty;
 	unsigned char		*data = urb->transfer_buffer;
 	int			result;
+	int status = urb->status;
 
 	dbg("%s - port %d", __FUNCTION__, port->number);
 
-	if (urb->status) {
-		dbg("%s - nonzero read bulk status received: %d", __FUNCTION__, urb->status);
+	if (status) {
+		dbg("%s - nonzero read bulk status received: %d",
+		    __FUNCTION__, status);
 		return;
 	}
 
@@ -870,11 +872,13 @@ static void ipaq_write_bulk_callback(struct urb *urb)
 	struct ipaq_private	*priv = usb_get_serial_port_data(port);
 	unsigned long		flags;
 	int			result;
+	int status = urb->status;
 
 	dbg("%s - port %d", __FUNCTION__, port->number);
-	
-	if (urb->status) {
-		dbg("%s - nonzero write bulk status received: %d", __FUNCTION__, urb->status);
+
+	if (status) {
+		dbg("%s - nonzero write bulk status received: %d",
+		    __FUNCTION__, status);
 		return;
 	}
 

commit c51e9749ab49c5fa6c9cc1cb96bb5f36a571f553
Author: Norihiko Tomiyama <norihiko.tomiyama@ctc-g.co.jp>
Date:   Thu Apr 5 10:05:40 2007 +0900

    Adding PID of SHARP S01SH for ipaq.c
    
    I write a patch adding support "SHARP EMONE(S01SH)" device for ipaq.c.
    EMONE is a PDA with built-in HSDPA function.
    
    
    
    From: Norihiko Tomiyama <norihiko.tomiyama@ctc-g.co.jp>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c
index d16e2e1764ad..4df0ec74e0b1 100644
--- a/drivers/usb/serial/ipaq.c
+++ b/drivers/usb/serial/ipaq.c
@@ -255,6 +255,7 @@ static struct usb_device_id ipaq_id_table [] = {
 	{ USB_DEVICE(0x04DD, 0x9102) }, /* SHARP WS003SH USB Modem */
 	{ USB_DEVICE(0x04DD, 0x9121) }, /* SHARP WS004SH USB Modem */
 	{ USB_DEVICE(0x04DD, 0x9123) }, /* SHARP WS007SH USB Modem */
+	{ USB_DEVICE(0x04DD, 0x9151) }, /* SHARP S01SH USB Modem */
 	{ USB_DEVICE(0x04E8, 0x5F00) }, /* Samsung NEXiO USB Sync */
 	{ USB_DEVICE(0x04E8, 0x5F01) }, /* Samsung NEXiO USB Sync */
 	{ USB_DEVICE(0x04E8, 0x5F02) }, /* Samsung NEXiO USB Sync */

commit 62d909ced019bcae75402578d5dab4522e959823
Author: Andre Spahlinger <andre@spahlenbach.de>
Date:   Mon Mar 5 19:09:35 2007 +0100

    USB: ipaq.c: Additional devices
    
    Additional devices
    
    Signed-off-by: Andre Spahlinger <uenz@gmx.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c
index a408184334ea..d16e2e1764ad 100644
--- a/drivers/usb/serial/ipaq.c
+++ b/drivers/usb/serial/ipaq.c
@@ -247,6 +247,8 @@ static struct usb_device_id ipaq_id_table [] = {
 	{ USB_DEVICE(0x04AD, 0x0301) }, /* USB Sync 0301 */
 	{ USB_DEVICE(0x04AD, 0x0302) }, /* USB Sync 0302 */
 	{ USB_DEVICE(0x04AD, 0x0303) }, /* USB Sync 0303 */
+	{ USB_DEVICE(0x04AD, 0x0306) }, /* GPS Pocket PC USB Sync */
+	{ USB_DEVICE(0x04B7, 0x0531) }, /* MyGuide 7000 XL USB Sync */
 	{ USB_DEVICE(0x04C5, 0x1058) }, /* FUJITSU USB Sync */
 	{ USB_DEVICE(0x04C5, 0x1079) }, /* FUJITSU USB Sync */
 	{ USB_DEVICE(0x04DA, 0x2500) }, /* Panasonic USB Sync */

commit d9b1b787736852f462dbf277b3ca708cbbf693ae
Author: Johannes Hölzl <johannes.hoelzl@gmx.de>
Date:   Sun Dec 17 21:50:24 2006 +0100

    USB serial: add driver pointer to all usb-serial drivers
    
    Every usb serial driver should have a pointer to the corresponding usb driver.
    So the usb serial core can add a new id not only to the usb serial driver, but
    also to the usb driver.
    
    Also the usb drivers of ark3116, mos7720 and mos7840 missed the flag
    no_dynamic_id=1. This is added now.
    
    Signed-off-by: Johannes Hölzl <johannes.hoelzl@gmx.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c
index 42f757a5b876..a408184334ea 100644
--- a/drivers/usb/serial/ipaq.c
+++ b/drivers/usb/serial/ipaq.c
@@ -563,6 +563,7 @@ static struct usb_serial_driver ipaq_device = {
 		.name =		"ipaq",
 	},
 	.description =		"PocketPC PDA",
+	.usb_driver = 		&ipaq_driver,
 	.id_table =		ipaq_id_table,
 	.num_interrupt_in =	NUM_DONT_CARE,
 	.num_bulk_in =		1,

commit 5cbded585d129d0226cb48ac4202b253c781be26
Author: Robert P. J. Day <rpjday@mindspring.com>
Date:   Wed Dec 13 00:35:56 2006 -0800

    [PATCH] getting rid of all casts of k[cmz]alloc() calls
    
    Run this:
    
            #!/bin/sh
            for f in $(grep -Erl "\([^\)]*\) *k[cmz]alloc" *) ; do
              echo "De-casting $f..."
              perl -pi -e "s/ ?= ?\([^\)]*\) *(k[cmz]alloc) *\(/ = \1\(/" $f
            done
    
    And then go through and reinstate those cases where code is casting pointers
    to non-pointers.
    
    And then drop a few hunks which conflicted with outstanding work.
    
    Cc: Russell King <rmk@arm.linux.org.uk>, Ian Molton <spyro@f2s.com>
    Cc: Mikael Starvik <starvik@axis.com>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Kyle McMartin <kyle@mcmartin.ca>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Jeff Dike <jdike@addtoit.com>
    Cc: Greg KH <greg@kroah.com>
    Cc: Jens Axboe <jens.axboe@oracle.com>
    Cc: Paul Fulghum <paulkf@microgate.com>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Cc: Karsten Keil <kkeil@suse.de>
    Cc: Mauro Carvalho Chehab <mchehab@infradead.org>
    Cc: Jeff Garzik <jeff@garzik.org>
    Cc: James Bottomley <James.Bottomley@steeleye.com>
    Cc: Ian Kent <raven@themaw.net>
    Cc: Steven French <sfrench@us.ibm.com>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: Neil Brown <neilb@cse.unsw.edu.au>
    Cc: Jaroslav Kysela <perex@suse.cz>
    Cc: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c
index d72cf8bc7f76..42f757a5b876 100644
--- a/drivers/usb/serial/ipaq.c
+++ b/drivers/usb/serial/ipaq.c
@@ -595,7 +595,7 @@ static int ipaq_open(struct usb_serial_port *port, struct file *filp)
 
 	bytes_in = 0;
 	bytes_out = 0;
-	priv = (struct ipaq_private *)kmalloc(sizeof(struct ipaq_private), GFP_KERNEL);
+	priv = kmalloc(sizeof(struct ipaq_private), GFP_KERNEL);
 	if (priv == NULL) {
 		err("%s - Out of memory", __FUNCTION__);
 		return -ENOMEM;

commit 0029908ba9661ef26f7020309966aae23c2027b8
Author: Alex Sanks <alex@sanks.net>
Date:   Sun Oct 29 16:38:31 2006 -0800

    USB: ipaq: Add HTC Modem Support
    
    Adds support for HTC Smart Phones in modem mode (as opposed to sync
    mode).  Loads and works with pppd on my T-Mobile SDA.
    
    Signed-off-by: Alex Sanks <alex@sanks.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c
index 6238aff1e772..d72cf8bc7f76 100644
--- a/drivers/usb/serial/ipaq.c
+++ b/drivers/usb/serial/ipaq.c
@@ -320,6 +320,7 @@ static struct usb_device_id ipaq_id_table [] = {
 	{ USB_DEVICE(0x0B05, 0x9200) }, /* ASUS USB Sync */
 	{ USB_DEVICE(0x0B05, 0x9202) }, /* ASUS USB Sync */
 	{ USB_DEVICE(0x0BB4, 0x00CE) }, /* HTC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x00CF) }, /* HTC USB Modem */
 	{ USB_DEVICE(0x0BB4, 0x0A01) }, /* PocketPC USB Sync */
 	{ USB_DEVICE(0x0BB4, 0x0A02) }, /* PocketPC USB Sync */
 	{ USB_DEVICE(0x0BB4, 0x0A03) }, /* PocketPC USB Sync */

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c
index cbc725a6c58e..6238aff1e772 100644
--- a/drivers/usb/serial/ipaq.c
+++ b/drivers/usb/serial/ipaq.c
@@ -83,8 +83,8 @@ static int ipaq_write(struct usb_serial_port *port, const unsigned char *buf,
 static int ipaq_write_bulk(struct usb_serial_port *port, const unsigned char *buf,
 			   int count);
 static void ipaq_write_gather(struct usb_serial_port *port);
-static void ipaq_read_bulk_callback (struct urb *urb, struct pt_regs *regs);
-static void ipaq_write_bulk_callback(struct urb *urb, struct pt_regs *regs);
+static void ipaq_read_bulk_callback (struct urb *urb);
+static void ipaq_write_bulk_callback(struct urb *urb);
 static int ipaq_write_room(struct usb_serial_port *port);
 static int ipaq_chars_in_buffer(struct usb_serial_port *port);
 static void ipaq_destroy_lists(struct usb_serial_port *port);
@@ -721,7 +721,7 @@ static void ipaq_close(struct usb_serial_port *port, struct file *filp)
 	/* info ("Bytes In = %d  Bytes Out = %d", bytes_in, bytes_out); */
 }
 
-static void ipaq_read_bulk_callback(struct urb *urb, struct pt_regs *regs)
+static void ipaq_read_bulk_callback(struct urb *urb)
 {
 	struct usb_serial_port	*port = (struct usb_serial_port *)urb->context;
 	struct tty_struct	*tty;
@@ -859,7 +859,7 @@ static void ipaq_write_gather(struct usb_serial_port *port)
 	return;
 }
 
-static void ipaq_write_bulk_callback(struct urb *urb, struct pt_regs *regs)
+static void ipaq_write_bulk_callback(struct urb *urb)
 {
 	struct usb_serial_port	*port = (struct usb_serial_port *)urb->context;
 	struct ipaq_private	*priv = usb_get_serial_port_data(port);

commit 1b495f753a65835e7dd9d043b12f2fca6a105b3d
Author: Matthias Urlichs <smurf@smurf.noris.de>
Date:   Sun Sep 24 21:38:47 2006 +0200

    USB: another device ID for ipaq
    
    Add yet another device ID to the ipaq USB-serial driver.
    
    Signed-Off-By: Matthias Urlichs <matthias@urlichs.de>
    Cc: Ganesh Varadarajan <ganesh@veritas.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c
index bfc6998cd16f..cbc725a6c58e 100644
--- a/drivers/usb/serial/ipaq.c
+++ b/drivers/usb/serial/ipaq.c
@@ -479,6 +479,7 @@ static struct usb_device_id ipaq_id_table [] = {
 	{ USB_DEVICE(0x0BB4, 0x0A9D) }, /* SmartPhone USB Sync */
 	{ USB_DEVICE(0x0BB4, 0x0A9E) }, /* SmartPhone USB Sync */
 	{ USB_DEVICE(0x0BB4, 0x0A9F) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0BCE) }, /* "High Tech Computer Corp" */
 	{ USB_DEVICE(0x0BF8, 0x1001) }, /* Fujitsu Siemens Computers USB Sync */
 	{ USB_DEVICE(0x0C44, 0x03A2) }, /* Motorola iDEN Smartphone */
 	{ USB_DEVICE(0x0C8E, 0x6000) }, /* Cesscom Luxian Series */

commit 014aa2a3c32ebe33f97e9d219d91d3c5c7231bf7
Author: Luiz Fernando N. Capitulino <lcapitulino@mandriva.com.br>
Date:   Thu Jul 27 10:30:43 2006 -0300

    USB: ipaq: minor ipaq_open() cleanup.
    
     Commit b512504e5671f83638be0ddr085c4b1832f623d3 made ipaq_open() a bit
    messy by moving the read urb submission far from its usb_fill_bulk_urb()
    call and the comment explaining what it does.
    
     This patch put they together again. Although only compiled tested, should
    not break the fix introduced by b512504e5671f83638be0ddr085c4b1832f623d3,
    of course.
    
    Signed-off-by: Luiz Fernando N. Capitulino <lcapitulino@mandriva.com.br>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c
index 9840bade79f9..bfc6998cd16f 100644
--- a/drivers/usb/serial/ipaq.c
+++ b/drivers/usb/serial/ipaq.c
@@ -652,11 +652,6 @@ static int ipaq_open(struct usb_serial_port *port, struct file *filp)
 	port->bulk_out_size = port->write_urb->transfer_buffer_length = URBDATA_SIZE;
 	
 	msleep(1000*initial_wait);
-	/* Start reading from the device */
-	usb_fill_bulk_urb(port->read_urb, serial->dev, 
-		      usb_rcvbulkpipe(serial->dev, port->bulk_in_endpointAddress),
-		      port->read_urb->transfer_buffer, port->read_urb->transfer_buffer_length,
-		      ipaq_read_bulk_callback, port);
 
 	/*
 	 * Send out control message observed in win98 sniffs. Not sure what
@@ -670,18 +665,31 @@ static int ipaq_open(struct usb_serial_port *port, struct file *filp)
 		result = usb_control_msg(serial->dev,
 				usb_sndctrlpipe(serial->dev, 0), 0x22, 0x21,
 				0x1, 0, NULL, 0, 100);
-		if (result == 0) {
-			result = usb_submit_urb(port->read_urb, GFP_KERNEL);
-			if (result) {
-				err("%s - failed submitting read urb, error %d", __FUNCTION__, result);
-				goto error;
-			}
-			return 0;
-		}
+		if (!result)
+			break;
+
 		msleep(1000);
 	}
-	err("%s - failed doing control urb, error %d", __FUNCTION__, result);
-	goto error;
+
+	if (!retries && result) {
+		err("%s - failed doing control urb, error %d", __FUNCTION__,
+		    result);
+		goto error;
+	}
+
+	/* Start reading from the device */
+	usb_fill_bulk_urb(port->read_urb, serial->dev,
+		      usb_rcvbulkpipe(serial->dev, port->bulk_in_endpointAddress),
+		      port->read_urb->transfer_buffer, port->read_urb->transfer_buffer_length,
+		      ipaq_read_bulk_callback, port);
+
+	result = usb_submit_urb(port->read_urb, GFP_KERNEL);
+	if (result) {
+		err("%s - failed submitting read urb, error %d", __FUNCTION__, result);
+		goto error;
+	}
+
+	return 0;
 
 enomem:
 	result = -ENOMEM;

commit 922fdaa692e23bf57a10c16047d993c181991579
Author: Norihiko Tomiyama <norihiko.tomiyama@ctc-g.co.jp>
Date:   Tue Aug 8 14:31:25 2006 +0900

    USB: Additional PID for SHARP W-ZERO3
    
    I write a patch for ipaq.c.
    Would you like to add upstream tree ?
    
    This patch enables a support of "SHARP W-ZERO3(WS004SH)" and "SHARP W-ZERO3[es](WS007SH)".
    
    From: Norihiko Tomiyama <norihiko.tomiyama@ctc-g.co.jp>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c
index 7e1bd5d6dfa0..9840bade79f9 100644
--- a/drivers/usb/serial/ipaq.c
+++ b/drivers/usb/serial/ipaq.c
@@ -251,6 +251,8 @@ static struct usb_device_id ipaq_id_table [] = {
 	{ USB_DEVICE(0x04C5, 0x1079) }, /* FUJITSU USB Sync */
 	{ USB_DEVICE(0x04DA, 0x2500) }, /* Panasonic USB Sync */
 	{ USB_DEVICE(0x04DD, 0x9102) }, /* SHARP WS003SH USB Modem */
+	{ USB_DEVICE(0x04DD, 0x9121) }, /* SHARP WS004SH USB Modem */
+	{ USB_DEVICE(0x04DD, 0x9123) }, /* SHARP WS007SH USB Modem */
 	{ USB_DEVICE(0x04E8, 0x5F00) }, /* Samsung NEXiO USB Sync */
 	{ USB_DEVICE(0x04E8, 0x5F01) }, /* Samsung NEXiO USB Sync */
 	{ USB_DEVICE(0x04E8, 0x5F02) }, /* Samsung NEXiO USB Sync */

commit aec0d50b8a86bf04ea8e5885fef4f498d5d3168c
Author: Norihiko Tomiyama <norihiko.tomiyama@ctc-g.co.jp>
Date:   Thu Jul 13 09:43:02 2006 +0900

    USB: adding support for SHARP WS003SH to ipaq.c
    
    This small patch enables a support of "SHARP WS003SH".
    "SHARP WS003SH" (usullary called "W-ZERO3") is most polular All-in-one handheld
    CellPhone-plus-WindowsMobile5.0 in Japan.
    
    "SHARP WS003SH" has two modes, "Modem" and "ActiveSync".
    But, "ActiveSync" mode uses NDIS connection.
    Therefore, ipaq.c can only support "Modem" mode.
    
    http://www.sharp.co.jp/ws/ (Japanese Site)
    http://greggman.com/edit/editheadlines/2005-12-24.htm
    
    From: Norihiko Tomiyama <norihiko.tomiyama@ctc-g.co.jp>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c
index 59c5d999009a..7e1bd5d6dfa0 100644
--- a/drivers/usb/serial/ipaq.c
+++ b/drivers/usb/serial/ipaq.c
@@ -250,6 +250,7 @@ static struct usb_device_id ipaq_id_table [] = {
 	{ USB_DEVICE(0x04C5, 0x1058) }, /* FUJITSU USB Sync */
 	{ USB_DEVICE(0x04C5, 0x1079) }, /* FUJITSU USB Sync */
 	{ USB_DEVICE(0x04DA, 0x2500) }, /* Panasonic USB Sync */
+	{ USB_DEVICE(0x04DD, 0x9102) }, /* SHARP WS003SH USB Modem */
 	{ USB_DEVICE(0x04E8, 0x5F00) }, /* Samsung NEXiO USB Sync */
 	{ USB_DEVICE(0x04E8, 0x5F01) }, /* Samsung NEXiO USB Sync */
 	{ USB_DEVICE(0x04E8, 0x5F02) }, /* Samsung NEXiO USB Sync */

commit a969888ce91673c7f4b86520d851a6f0d5a5fa7d
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Jul 11 21:22:58 2006 -0700

    [PATCH] USB: move usb-serial.h to include/linux/usb/
    
    USB serial outside of the kernel tree can not build properly due to
    usb-serial.h being buried down in the source tree.  This patch moves the
    location of the file to include/linux/usb and fixes up all of the usb
    serial drivers to handle the move properly.
    
    Cc: Sergei Organov <osv@javad.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c
index 65beea6e54d1..59c5d999009a 100644
--- a/drivers/usb/serial/ipaq.c
+++ b/drivers/usb/serial/ipaq.c
@@ -55,7 +55,7 @@
 #include <linux/spinlock.h>
 #include <asm/uaccess.h>
 #include <linux/usb.h>
-#include "usb-serial.h"
+#include <linux/usb/serial.h>
 #include "ipaq.h"
 
 #define KP_RETRIES	100

commit b33488eb5c27c13c3e88cdf29d344ccdcb0859f2
Author: Frank Gevaerts <frank.gevaerts@fks.be>
Date:   Fri Jun 30 02:34:45 2006 -0700

    [PATCH] USB: ipaq.c timing parameters
    
    Adds configurable waiting periods to the ipaq connection code. These are
    not needed when the pocketpc device is running normally when plugged in,
    but they need extra delays if they are physically connected while
    rebooting.
    
    There are two parameters :
    
    * initial_wait : this is the delay before the driver attemts to start the
      connection. This is needed because the pocktpc device takes much
      longer to boot if the driver starts sending control packets too soon.
    
    * connect_retries : this is the number of times the control urb is
      retried before finally giving up. The patch also adds a 1 second delay
      between retries.
    
    I'm not sure if the cases where this patch is useful are general enough
    to include this in the kernel.
    
    Signed-off-by: Frank Gevaerts <frank.gevaerts@fks.be>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c
index c021905f0637..65beea6e54d1 100644
--- a/drivers/usb/serial/ipaq.c
+++ b/drivers/usb/serial/ipaq.c
@@ -70,6 +70,8 @@
 
 static __u16 product, vendor;
 static int debug;
+static int connect_retries = KP_RETRIES;
+static int initial_wait;
 
 /* Function prototypes for an ipaq */
 static int  ipaq_open (struct usb_serial_port *port, struct file *filp);
@@ -582,7 +584,7 @@ static int ipaq_open(struct usb_serial_port *port, struct file *filp)
 	struct ipaq_private	*priv;
 	struct ipaq_packet	*pkt;
 	int			i, result = 0;
-	int			retries = KP_RETRIES;
+	int			retries = connect_retries;
 
 	dbg("%s - port %d", __FUNCTION__, port->number);
 
@@ -646,6 +648,7 @@ static int ipaq_open(struct usb_serial_port *port, struct file *filp)
 	port->read_urb->transfer_buffer_length = URBDATA_SIZE;
 	port->bulk_out_size = port->write_urb->transfer_buffer_length = URBDATA_SIZE;
 	
+	msleep(1000*initial_wait);
 	/* Start reading from the device */
 	usb_fill_bulk_urb(port->read_urb, serial->dev, 
 		      usb_rcvbulkpipe(serial->dev, port->bulk_in_endpointAddress),
@@ -672,6 +675,7 @@ static int ipaq_open(struct usb_serial_port *port, struct file *filp)
 			}
 			return 0;
 		}
+		msleep(1000);
 	}
 	err("%s - failed doing control urb, error %d", __FUNCTION__, result);
 	goto error;
@@ -967,3 +971,9 @@ MODULE_PARM_DESC(vendor, "User specified USB idVendor");
 
 module_param(product, ushort, 0);
 MODULE_PARM_DESC(product, "User specified USB idProduct");
+
+module_param(connect_retries, int, S_IRUGO|S_IWUSR);
+MODULE_PARM_DESC(connect_retries, "Maximum number of connect retries (one second each)");
+
+module_param(initial_wait, int, S_IRUGO|S_IWUSR);
+MODULE_PARM_DESC(initial_wait, "Time to wait before attempting a connection (in seconds)");

commit b512504e5671f83638be0ddb085c4b1832f623d3
Author: Frank Gevaerts <frank.gevaerts@fks.be>
Date:   Fri Jun 30 02:34:44 2006 -0700

    [PATCH] USB: ipaq.c bugfixes
    
    This patch fixes several problems in the ipaq.c driver with connecting
    and disconnecting pocketpc devices:
    
    * The read urb stayed active if the connect failed, causing nullpointer
      dereferences later on.
    
    * If a write failed, the driver continued as if nothing happened. Now it
      handles that case the same way as other usb serial devices (fix by
      Luiz Fernando N. Capitulino <lcapitulino@mandriva.com.br>)
    
    Signed-off-by: Frank Gevaerts <frank.gevaerts@fks.be>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c
index dbcfe172a5cc..c021905f0637 100644
--- a/drivers/usb/serial/ipaq.c
+++ b/drivers/usb/serial/ipaq.c
@@ -651,11 +651,6 @@ static int ipaq_open(struct usb_serial_port *port, struct file *filp)
 		      usb_rcvbulkpipe(serial->dev, port->bulk_in_endpointAddress),
 		      port->read_urb->transfer_buffer, port->read_urb->transfer_buffer_length,
 		      ipaq_read_bulk_callback, port);
-	result = usb_submit_urb(port->read_urb, GFP_KERNEL);
-	if (result) {
-		err("%s - failed submitting read urb, error %d", __FUNCTION__, result);
-		goto error;
-	}
 
 	/*
 	 * Send out control message observed in win98 sniffs. Not sure what
@@ -670,6 +665,11 @@ static int ipaq_open(struct usb_serial_port *port, struct file *filp)
 				usb_sndctrlpipe(serial->dev, 0), 0x22, 0x21,
 				0x1, 0, NULL, 0, 100);
 		if (result == 0) {
+			result = usb_submit_urb(port->read_urb, GFP_KERNEL);
+			if (result) {
+				err("%s - failed submitting read urb, error %d", __FUNCTION__, result);
+				goto error;
+			}
 			return 0;
 		}
 	}
@@ -854,6 +854,7 @@ static void ipaq_write_bulk_callback(struct urb *urb, struct pt_regs *regs)
 	
 	if (urb->status) {
 		dbg("%s - nonzero write bulk status received: %d", __FUNCTION__, urb->status);
+		return;
 	}
 
 	spin_lock_irqsave(&write_list_lock, flags);

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jörn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jörn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c
index 9da6d2a8f2b0..dbcfe172a5cc 100644
--- a/drivers/usb/serial/ipaq.c
+++ b/drivers/usb/serial/ipaq.c
@@ -44,7 +44,6 @@
  * 	Thanks to info from Heath Robinson and Arieh Davidoff.
  */
 
-#include <linux/config.h>
 #include <linux/kernel.h>
 #include <linux/errno.h>
 #include <linux/init.h>

commit cf2c7481d2ff7f0c266de873b2fe93883e9782f9
Author: Pete Zaitcev <zaitcev@redhat.com>
Date:   Mon May 22 21:58:49 2006 -0700

    [PATCH] USB serial: encapsulate schedule_work, remove double-calling
    
    I'm going to throw schedule_work away, it's retarded. But for starters,
    let's have it encapsulated.
    
    Also, generic and whiteheat were both calling usb_serial_port_softint
    and scheduled work. Only one was necessary.
    
    Signed-off-by: Pete Zaitcev <zaitcev@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c
index 9a5c97989562..9da6d2a8f2b0 100644
--- a/drivers/usb/serial/ipaq.c
+++ b/drivers/usb/serial/ipaq.c
@@ -870,7 +870,7 @@ static void ipaq_write_bulk_callback(struct urb *urb, struct pt_regs *regs)
 		spin_unlock_irqrestore(&write_list_lock, flags);
 	}
 
-	schedule_work(&port->work);
+	usb_serial_port_softint(port);
 }
 
 static int ipaq_write_room(struct usb_serial_port *port)

commit 33f0f88f1c51ae5c2d593d26960c760ea154c2e2
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Mon Jan 9 20:54:13 2006 -0800

    [PATCH] TTY layer buffering revamp
    
    The API and code have been through various bits of initial review by
    serial driver people but they definitely need to live somewhere for a
    while so the unconverted drivers can get knocked into shape, existing
    drivers that have been updated can be better tuned and bugs whacked out.
    
    This replaces the tty flip buffers with kmalloc objects in rings. In the
    normal situation for an IRQ driven serial port at typical speeds the
    behaviour is pretty much the same, two buffers end up allocated and the
    kernel cycles between them as before.
    
    When there are delays or at high speed we now behave far better as the
    buffer pool can grow a bit rather than lose characters. This also means
    that we can operate at higher speeds reliably.
    
    For drivers that receive characters in blocks (DMA based, USB and
    especially virtualisation) the layer allows a lot of driver specific
    code that works around the tty layer with private secondary queues to be
    removed. The IBM folks need this sort of layer, the smart serial port
    people do, the virtualisers do (because a virtualised tty typically
    operates at infinite speed rather than emulating 9600 baud).
    
    Finally many drivers had invalid and unsafe attempts to avoid buffer
    overflows by directly invoking tty methods extracted out of the innards
    of work queue structs. These are no longer needed and all go away. That
    fixes various random hangs with serial ports on overflow.
    
    The other change in here is to optimise the receive_room path that is
    used by some callers. It turns out that only one ldisc uses receive room
    except asa constant and it updates it far far less than the value is
    read. We thus make it a variable not a function call.
    
    I expect the code to contain bugs due to the size alone but I'll be
    watching and squashing them and feeding out new patches as it goes.
    
    Because the buffers now dynamically expand you should only run out of
    buffering when the kernel runs out of memory for real.  That means a lot of
    the horrible hacks high performance drivers used to do just aren't needed any
    more.
    
    Description:
    
    tty_insert_flip_char is an old API and continues to work as before, as does
    tty_flip_buffer_push() [this is why many drivers dont need modification].  It
    does now also return the number of chars inserted
    
    There are also
    
    tty_buffer_request_room(tty, len)
    
    which asks for a buffer block of the length requested and returns the space
    found.  This improves efficiency with hardware that knows how much to
    transfer.
    
    and tty_insert_flip_string_flags(tty, str, flags, len)
    
    to insert a string of characters and flags
    
    For a smart interface the usual code is
    
        len = tty_request_buffer_room(tty, amount_hardware_says);
        tty_insert_flip_string(tty, buffer_from_card, len);
    
    More description!
    
    At the moment tty buffers are attached directly to the tty.  This is causing a
    lot of the problems related to tty layer locking, also problems at high speed
    and also with bursty data (such as occurs in virtualised environments)
    
    I'm working on ripping out the flip buffers and replacing them with a pool of
    dynamically allocated buffers.  This allows both for old style "byte I/O"
    devices and also helps virtualisation and smart devices where large blocks of
    data suddenely materialise and need storing.
    
    So far so good.  Lots of drivers reference tty->flip.*.  Several of them also
    call directly and unsafely into function pointers it provides.  This will all
    break.  Most drivers can use tty_insert_flip_char which can be kept as an API
    but others need more.
    
    At the moment I've added the following interfaces, if people think more will
    be needed now is a good time to say
    
     int tty_buffer_request_room(tty, size)
    
    Try and ensure at least size bytes are available, returns actual room (may be
    zero).  At the moment it just uses the flipbuf space but that will change.
    Repeated calls without characters being added are not cumulative.  (ie if you
    call it with 1, 1, 1, and then 4 you'll have four characters of space.  The
    other functions will also try and grow buffers in future but this will be a
    more efficient way when you know block sizes.
    
     int tty_insert_flip_char(tty, ch, flag)
    
    As before insert a character if there is room.  Now returns 1 for success, 0
    for failure.
    
     int tty_insert_flip_string(tty, str, len)
    
    Insert a block of non error characters.  Returns the number inserted.
    
     int tty_prepare_flip_string(tty, strptr, len)
    
    Adjust the buffer to allow len characters to be added.  Returns a buffer
    pointer in strptr and the length available.  This allows for hardware that
    needs to use functions like insl or mencpy_fromio.
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Cc: Paul Fulghum <paulkf@microgate.com>
    Signed-off-by: Hirokazu Takata <takata@linux-m32r.org>
    Signed-off-by: Serge Hallyn <serue@us.ibm.com>
    Signed-off-by: Jeff Dike <jdike@addtoit.com>
    Signed-off-by: John Hawkes <hawkes@sgi.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c
index 06d07cea0b70..9a5c97989562 100644
--- a/drivers/usb/serial/ipaq.c
+++ b/drivers/usb/serial/ipaq.c
@@ -711,7 +711,7 @@ static void ipaq_read_bulk_callback(struct urb *urb, struct pt_regs *regs)
 	struct usb_serial_port	*port = (struct usb_serial_port *)urb->context;
 	struct tty_struct	*tty;
 	unsigned char		*data = urb->transfer_buffer;
-	int			i, result;
+	int			result;
 
 	dbg("%s - port %d", __FUNCTION__, port->number);
 
@@ -724,14 +724,8 @@ static void ipaq_read_bulk_callback(struct urb *urb, struct pt_regs *regs)
 
 	tty = port->tty;
 	if (tty && urb->actual_length) {
-		for (i = 0; i < urb->actual_length ; ++i) {
-			/* if we insert more than TTY_FLIPBUF_SIZE characters, we drop them. */
-			if(tty->flip.count >= TTY_FLIPBUF_SIZE) {
-				tty_flip_buffer_push(tty);
-			}
-			/* this doesn't actually push the data through unless tty->low_latency is set */
-			tty_insert_flip_char(tty, data[i], 0);
-		}
+		tty_buffer_request_room(tty, urb->actual_length);
+		tty_insert_flip_string(tty, data, urb->actual_length);
 		tty_flip_buffer_push(tty);
 		bytes_in += urb->actual_length;
 	}

commit 75318d2d7cab77b14c5d3dbd5e69f2680a769e16
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Nov 21 14:53:03 2005 -0800

    [PATCH] USB: remove .owner field from struct usb_driver
    
    It is no longer needed, so let's remove it, saving a bit of memory.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c
index efb568be7015..06d07cea0b70 100644
--- a/drivers/usb/serial/ipaq.c
+++ b/drivers/usb/serial/ipaq.c
@@ -542,7 +542,6 @@ static struct usb_device_id ipaq_id_table [] = {
 MODULE_DEVICE_TABLE (usb, ipaq_id_table);
 
 static struct usb_driver ipaq_driver = {
-	.owner =	THIS_MODULE,
 	.name =		"ipaq",
 	.probe =	usb_serial_probe,
 	.disconnect =	usb_serial_disconnect,

commit ba9dc657af86d05d2971633e57d1f6f94ed60472
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed Nov 16 13:41:28 2005 -0800

    [PATCH] USB: allow usb drivers to disable dynamic ids
    
    This lets drivers, like the usb-serial ones, disable the ability to add
    ids from sysfs.
    
    The usb-serial drivers are "odd" in that they are really usb-serial bus
    drivers, not usb bus drivers, so the dynamic id logic will have to go
    into the usb-serial bus core for those drivers to get that ability.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c
index d5d066488100..efb568be7015 100644
--- a/drivers/usb/serial/ipaq.c
+++ b/drivers/usb/serial/ipaq.c
@@ -547,6 +547,7 @@ static struct usb_driver ipaq_driver = {
 	.probe =	usb_serial_probe,
 	.disconnect =	usb_serial_disconnect,
 	.id_table =	ipaq_id_table,
+	.no_dynamic_id = 	1,
 };
 
 

commit eb3c5ed8617d0aa67648cb7d1a486d14099129f2
Author: David Eriksson <twogood@users.sourceforge.net>
Date:   Tue Oct 18 20:12:24 2005 +0200

    [PATCH] USB: Improving the set of vendor/product IDs in the ipaq driver
    
    This is a patch improving the set of vendor/product IDs used in the
    "ipaq" USB serial device driver. The patch size is because I sorted the
    ids this time, forgot about that last time.
    
    Changes:
    
    - Added vendor/product identifiers for Psion Teklogix devices
    - Restored Microsoft's identifier pair 045e/00ce
    - Sorted list of vendor/product identifiers
    
    Signed-off-by: David Eriksson <twogood@users.sourceforge.net>
    Signed-off-by: Ganesh Varadarajan <ganesh@veritas.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c
index 1abaebe6dbc1..d5d066488100 100644
--- a/drivers/usb/serial/ipaq.c
+++ b/drivers/usb/serial/ipaq.c
@@ -92,24 +92,7 @@ static void ipaq_destroy_lists(struct usb_serial_port *port);
 static struct usb_device_id ipaq_id_table [] = {
 	/* The first entry is a placeholder for the insmod-specified device */
 	{ USB_DEVICE(0x049F, 0x0003) },
-	{ USB_DEVICE(0x1690, 0x0601) }, /* Askey USB Sync */
-	{ USB_DEVICE(0x0960, 0x0065) }, /* BCOM USB Sync 0065 */
-	{ USB_DEVICE(0x0960, 0x0066) }, /* BCOM USB Sync 0066 */
-	{ USB_DEVICE(0x0960, 0x0067) }, /* BCOM USB Sync 0067 */
-	{ USB_DEVICE(0x07CF, 0x2001) }, /* CASIO USB Sync 2001 */
-	{ USB_DEVICE(0x07CF, 0x2002) }, /* CASIO USB Sync 2002 */
-	{ USB_DEVICE(0x07CF, 0x2003) }, /* CASIO USB Sync 2003 */
-	{ USB_DEVICE(0x049F, 0x0003) }, /* Compaq iPAQ USB Sync */
-	{ USB_DEVICE(0x049F, 0x0032) }, /* Compaq iPAQ USB Sync */
-	{ USB_DEVICE(0x413C, 0x4001) }, /* Dell Axim USB Sync */
-	{ USB_DEVICE(0x413C, 0x4002) }, /* Dell Axim USB Sync */
-	{ USB_DEVICE(0x413C, 0x4003) }, /* Dell Axim USB Sync */
-	{ USB_DEVICE(0x413C, 0x4004) }, /* Dell Axim USB Sync */
-	{ USB_DEVICE(0x413C, 0x4005) }, /* Dell Axim USB Sync */
-	{ USB_DEVICE(0x413C, 0x4006) }, /* Dell Axim USB Sync */
-	{ USB_DEVICE(0x413C, 0x4007) }, /* Dell Axim USB Sync */
-	{ USB_DEVICE(0x413C, 0x4008) }, /* Dell Axim USB Sync */
-	{ USB_DEVICE(0x413C, 0x4009) }, /* Dell Axim USB Sync */
+	{ USB_DEVICE(0x0104, 0x00BE) }, /* Socket USB Sync */
 	{ USB_DEVICE(0x03F0, 0x1016) }, /* HP USB Sync */
 	{ USB_DEVICE(0x03F0, 0x1116) }, /* HP USB Sync 1611 */
 	{ USB_DEVICE(0x03F0, 0x1216) }, /* HP USB Sync 1612 */
@@ -125,7 +108,13 @@ static struct usb_device_id ipaq_id_table [] = {
 	{ USB_DEVICE(0x03F0, 0x5016) }, /* HP USB Sync 1650 */
 	{ USB_DEVICE(0x03F0, 0x5116) }, /* HP USB Sync 1651 */
 	{ USB_DEVICE(0x03F0, 0x5216) }, /* HP USB Sync 1652 */
-	{ USB_DEVICE(0x094B, 0x0001) }, /* Linkup Systems USB Sync */
+	{ USB_DEVICE(0x0409, 0x00D5) }, /* NEC USB Sync */
+	{ USB_DEVICE(0x0409, 0x00D6) }, /* NEC USB Sync */
+	{ USB_DEVICE(0x0409, 0x00D7) }, /* NEC USB Sync */
+	{ USB_DEVICE(0x0409, 0x8024) }, /* NEC USB Sync */
+	{ USB_DEVICE(0x0409, 0x8025) }, /* NEC USB Sync */
+	{ USB_DEVICE(0x043E, 0x9C01) }, /* LGE USB Sync */
+	{ USB_DEVICE(0x045E, 0x00CE) }, /* Microsoft USB Sync */
 	{ USB_DEVICE(0x045E, 0x0400) }, /* Windows Powered Pocket PC 2002 */
 	{ USB_DEVICE(0x045E, 0x0401) }, /* Windows Powered Pocket PC 2002 */
 	{ USB_DEVICE(0x045E, 0x0402) }, /* Windows Powered Pocket PC 2002 */
@@ -251,17 +240,81 @@ static struct usb_device_id ipaq_id_table [] = {
 	{ USB_DEVICE(0x045E, 0x04E8) }, /* Windows Powered Smartphone 2003 */
 	{ USB_DEVICE(0x045E, 0x04E9) }, /* Windows Powered Smartphone 2003 */
 	{ USB_DEVICE(0x045E, 0x04EA) }, /* Windows Powered Smartphone 2003 */
-	{ USB_DEVICE(0x0961, 0x0010) }, /* Portatec USB Sync */
-	{ USB_DEVICE(0x5E04, 0xCE00) }, /* SAGEM Wireless Assistant */
-	{ USB_DEVICE(0x0104, 0x00BE) }, /* Socket USB Sync */
+	{ USB_DEVICE(0x049F, 0x0003) }, /* Compaq iPAQ USB Sync */
+	{ USB_DEVICE(0x049F, 0x0032) }, /* Compaq iPAQ USB Sync */
+	{ USB_DEVICE(0x04A4, 0x0014) }, /* Hitachi USB Sync */
+	{ USB_DEVICE(0x04AD, 0x0301) }, /* USB Sync 0301 */
+	{ USB_DEVICE(0x04AD, 0x0302) }, /* USB Sync 0302 */
+	{ USB_DEVICE(0x04AD, 0x0303) }, /* USB Sync 0303 */
+	{ USB_DEVICE(0x04C5, 0x1058) }, /* FUJITSU USB Sync */
+	{ USB_DEVICE(0x04C5, 0x1079) }, /* FUJITSU USB Sync */
+	{ USB_DEVICE(0x04DA, 0x2500) }, /* Panasonic USB Sync */
+	{ USB_DEVICE(0x04E8, 0x5F00) }, /* Samsung NEXiO USB Sync */
+	{ USB_DEVICE(0x04E8, 0x5F01) }, /* Samsung NEXiO USB Sync */
+	{ USB_DEVICE(0x04E8, 0x5F02) }, /* Samsung NEXiO USB Sync */
+	{ USB_DEVICE(0x04E8, 0x5F03) }, /* Samsung NEXiO USB Sync */
+	{ USB_DEVICE(0x04E8, 0x5F04) }, /* Samsung NEXiO USB Sync */
+	{ USB_DEVICE(0x04E8, 0x6611) }, /* Samsung MITs USB Sync */
+	{ USB_DEVICE(0x04E8, 0x6613) }, /* Samsung MITs USB Sync */
+	{ USB_DEVICE(0x04E8, 0x6615) }, /* Samsung MITs USB Sync */
+	{ USB_DEVICE(0x04E8, 0x6617) }, /* Samsung MITs USB Sync */
+	{ USB_DEVICE(0x04E8, 0x6619) }, /* Samsung MITs USB Sync */
+	{ USB_DEVICE(0x04E8, 0x661B) }, /* Samsung MITs USB Sync */
+	{ USB_DEVICE(0x04E8, 0x662E) }, /* Samsung MITs USB Sync */
+	{ USB_DEVICE(0x04E8, 0x6630) }, /* Samsung MITs USB Sync */
+	{ USB_DEVICE(0x04E8, 0x6632) }, /* Samsung MITs USB Sync */
+	{ USB_DEVICE(0x04f1, 0x3011) }, /* JVC USB Sync */
+	{ USB_DEVICE(0x04F1, 0x3012) }, /* JVC USB Sync */
+	{ USB_DEVICE(0x0502, 0x1631) }, /* c10 Series */
+	{ USB_DEVICE(0x0502, 0x1632) }, /* c20 Series */
+	{ USB_DEVICE(0x0502, 0x16E1) }, /* Acer n10 Handheld USB Sync */
+	{ USB_DEVICE(0x0502, 0x16E2) }, /* Acer n20 Handheld USB Sync */
+	{ USB_DEVICE(0x0502, 0x16E3) }, /* Acer n30 Handheld USB Sync */
+	{ USB_DEVICE(0x0536, 0x01A0) }, /* HHP PDT */
+	{ USB_DEVICE(0x0543, 0x0ED9) }, /* ViewSonic Color Pocket PC V35 */
+	{ USB_DEVICE(0x0543, 0x1527) }, /* ViewSonic Color Pocket PC V36 */
+	{ USB_DEVICE(0x0543, 0x1529) }, /* ViewSonic Color Pocket PC V37 */
+	{ USB_DEVICE(0x0543, 0x152B) }, /* ViewSonic Color Pocket PC V38 */
+	{ USB_DEVICE(0x0543, 0x152E) }, /* ViewSonic Pocket PC */
+	{ USB_DEVICE(0x0543, 0x1921) }, /* ViewSonic Communicator Pocket PC */
+	{ USB_DEVICE(0x0543, 0x1922) }, /* ViewSonic Smartphone */
+	{ USB_DEVICE(0x0543, 0x1923) }, /* ViewSonic Pocket PC V30 */
+	{ USB_DEVICE(0x05E0, 0x2000) }, /* Symbol USB Sync */
+	{ USB_DEVICE(0x05E0, 0x2001) }, /* Symbol USB Sync 0x2001 */
+	{ USB_DEVICE(0x05E0, 0x2002) }, /* Symbol USB Sync 0x2002 */
+	{ USB_DEVICE(0x05E0, 0x2003) }, /* Symbol USB Sync 0x2003 */
+	{ USB_DEVICE(0x05E0, 0x2004) }, /* Symbol USB Sync 0x2004 */
+	{ USB_DEVICE(0x05E0, 0x2005) }, /* Symbol USB Sync 0x2005 */
+	{ USB_DEVICE(0x05E0, 0x2006) }, /* Symbol USB Sync 0x2006 */
+	{ USB_DEVICE(0x05E0, 0x2007) }, /* Symbol USB Sync 0x2007 */
+	{ USB_DEVICE(0x05E0, 0x2008) }, /* Symbol USB Sync 0x2008 */
+	{ USB_DEVICE(0x05E0, 0x2009) }, /* Symbol USB Sync 0x2009 */
+	{ USB_DEVICE(0x05E0, 0x200A) }, /* Symbol USB Sync 0x200A */
+	{ USB_DEVICE(0x067E, 0x1001) }, /* Intermec Mobile Computer */
+	{ USB_DEVICE(0x07CF, 0x2001) }, /* CASIO USB Sync 2001 */
+	{ USB_DEVICE(0x07CF, 0x2002) }, /* CASIO USB Sync 2002 */
+	{ USB_DEVICE(0x07CF, 0x2003) }, /* CASIO USB Sync 2003 */
 	{ USB_DEVICE(0x0930, 0x0700) }, /* TOSHIBA USB Sync 0700 */
 	{ USB_DEVICE(0x0930, 0x0705) }, /* TOSHIBA Pocket PC e310 */
+	{ USB_DEVICE(0x0930, 0x0706) }, /* TOSHIBA Pocket PC e740 */
 	{ USB_DEVICE(0x0930, 0x0707) }, /* TOSHIBA Pocket PC e330 Series */
 	{ USB_DEVICE(0x0930, 0x0708) }, /* TOSHIBA Pocket PC e350Series */
-	{ USB_DEVICE(0x0930, 0x0706) }, /* TOSHIBA Pocket PC e740 */
 	{ USB_DEVICE(0x0930, 0x0709) }, /* TOSHIBA Pocket PC e750 Series */
 	{ USB_DEVICE(0x0930, 0x070A) }, /* TOSHIBA Pocket PC e400 Series */
 	{ USB_DEVICE(0x0930, 0x070B) }, /* TOSHIBA Pocket PC e800 Series */
+	{ USB_DEVICE(0x094B, 0x0001) }, /* Linkup Systems USB Sync */
+	{ USB_DEVICE(0x0960, 0x0065) }, /* BCOM USB Sync 0065 */
+	{ USB_DEVICE(0x0960, 0x0066) }, /* BCOM USB Sync 0066 */
+	{ USB_DEVICE(0x0960, 0x0067) }, /* BCOM USB Sync 0067 */
+	{ USB_DEVICE(0x0961, 0x0010) }, /* Portatec USB Sync */
+	{ USB_DEVICE(0x099E, 0x0052) }, /* Trimble GeoExplorer */
+	{ USB_DEVICE(0x099E, 0x4000) }, /* TDS Data Collector */
+	{ USB_DEVICE(0x0B05, 0x4200) }, /* ASUS USB Sync */
+	{ USB_DEVICE(0x0B05, 0x4201) }, /* ASUS USB Sync */
+	{ USB_DEVICE(0x0B05, 0x4202) }, /* ASUS USB Sync */
+	{ USB_DEVICE(0x0B05, 0x420F) }, /* ASUS USB Sync */
+	{ USB_DEVICE(0x0B05, 0x9200) }, /* ASUS USB Sync */
+	{ USB_DEVICE(0x0B05, 0x9202) }, /* ASUS USB Sync */
 	{ USB_DEVICE(0x0BB4, 0x00CE) }, /* HTC USB Sync */
 	{ USB_DEVICE(0x0BB4, 0x0A01) }, /* PocketPC USB Sync */
 	{ USB_DEVICE(0x0BB4, 0x0A02) }, /* PocketPC USB Sync */
@@ -422,116 +475,67 @@ static struct usb_device_id ipaq_id_table [] = {
 	{ USB_DEVICE(0x0BB4, 0x0A9D) }, /* SmartPhone USB Sync */
 	{ USB_DEVICE(0x0BB4, 0x0A9E) }, /* SmartPhone USB Sync */
 	{ USB_DEVICE(0x0BB4, 0x0A9F) }, /* SmartPhone USB Sync */
-	{ USB_DEVICE(0x0409, 0x00D5) }, /* NEC USB Sync */
-	{ USB_DEVICE(0x0409, 0x00D6) }, /* NEC USB Sync */
-	{ USB_DEVICE(0x0409, 0x00D7) }, /* NEC USB Sync */
-	{ USB_DEVICE(0x0409, 0x8024) }, /* NEC USB Sync */
-	{ USB_DEVICE(0x0409, 0x8025) }, /* NEC USB Sync */
-	{ USB_DEVICE(0x04A4, 0x0014) }, /* Hitachi USB Sync */
 	{ USB_DEVICE(0x0BF8, 0x1001) }, /* Fujitsu Siemens Computers USB Sync */
-	{ USB_DEVICE(0x0F98, 0x0201) }, /* Cyberbank USB Sync */
-	{ USB_DEVICE(0x0502, 0x16E1) }, /* Acer n10 Handheld USB Sync */
-	{ USB_DEVICE(0x0502, 0x16E3) }, /* Acer n30 Handheld USB Sync */
-	{ USB_DEVICE(0x0502, 0x16E2) }, /* Acer n20 Handheld USB Sync */
-	{ USB_DEVICE(0x0502, 0x1631) }, /* c10 Series */
-	{ USB_DEVICE(0x0502, 0x1632) }, /* c20 Series */
-	{ USB_DEVICE(0x0B05, 0x9202) }, /* ASUS USB Sync */
-	{ USB_DEVICE(0x0B05, 0x420F) }, /* ASUS USB Sync */
-	{ USB_DEVICE(0x0B05, 0x4200) }, /* ASUS USB Sync */
-	{ USB_DEVICE(0x0B05, 0x4201) }, /* ASUS USB Sync */
-	{ USB_DEVICE(0x0B05, 0x4202) }, /* ASUS USB Sync */
-	{ USB_DEVICE(0x0B05, 0x9200) }, /* ASUS USB Sync */
+	{ USB_DEVICE(0x0C44, 0x03A2) }, /* Motorola iDEN Smartphone */
 	{ USB_DEVICE(0x0C8E, 0x6000) }, /* Cesscom Luxian Series */
-	{ USB_DEVICE(0x04AD, 0x0301) }, /* USB Sync 0301 */
-	{ USB_DEVICE(0x04AD, 0x0302) }, /* USB Sync 0302 */
-	{ USB_DEVICE(0x04AD, 0x0303) }, /* USB Sync 0303 */
+	{ USB_DEVICE(0x0CAD, 0x9001) }, /* Motorola PowerPad Pocket PCDevice */
+	{ USB_DEVICE(0x0F4E, 0x0200) }, /* Freedom Scientific USB Sync */
+	{ USB_DEVICE(0x0F98, 0x0201) }, /* Cyberbank USB Sync */
+	{ USB_DEVICE(0x0FB8, 0x3001) }, /* Wistron USB Sync */
+	{ USB_DEVICE(0x0FB8, 0x3002) }, /* Wistron USB Sync */
+	{ USB_DEVICE(0x0FB8, 0x3003) }, /* Wistron USB Sync */
+	{ USB_DEVICE(0x0FB8, 0x4001) }, /* Wistron USB Sync */
+	{ USB_DEVICE(0x1066, 0x00CE) }, /* E-TEN USB Sync */
 	{ USB_DEVICE(0x1066, 0x0300) }, /* E-TEN P3XX Pocket PC */
 	{ USB_DEVICE(0x1066, 0x0500) }, /* E-TEN P5XX Pocket PC */
 	{ USB_DEVICE(0x1066, 0x0600) }, /* E-TEN P6XX Pocket PC */
 	{ USB_DEVICE(0x1066, 0x0700) }, /* E-TEN P7XX Pocket PC */
-	{ USB_DEVICE(0x1066, 0x00CE) }, /* E-TEN USB Sync */
-	{ USB_DEVICE(0x0F4E, 0x0200) }, /* Freedom Scientific USB Sync */
-	{ USB_DEVICE(0x04C5, 0x1058) }, /* FUJITSU USB Sync */
-	{ USB_DEVICE(0x04C5, 0x1079) }, /* FUJITSU USB Sync */
-	{ USB_DEVICE(0x067E, 0x1001) }, /* Intermec Mobile Computer */
-	{ USB_DEVICE(0x04f1, 0x3011) }, /* JVC USB Sync */
-	{ USB_DEVICE(0x04F1, 0x3012) }, /* JVC USB Sync */
-	{ USB_DEVICE(0x3708, 0x20CE) }, /* Legend USB Sync */
-	{ USB_DEVICE(0x3708, 0x21CE) }, /* Lenovo USB Sync */
-	{ USB_DEVICE(0x043E, 0x9C01) }, /* LGE USB Sync */
-	{ USB_DEVICE(0x04DA, 0x2500) }, /* Panasonic USB Sync */
-	{ USB_DEVICE(0x3340, 0x0B1C) }, /* Generic PPC StrongARM */
-	{ USB_DEVICE(0x3340, 0x0E3A) }, /* Generic PPC USB Sync */
-	{ USB_DEVICE(0x3340, 0x0F3A) }, /* Generic SmartPhone USB Sync */
-	{ USB_DEVICE(0x3340, 0x0F1C) }, /* Itautec USB Sync */
-	{ USB_DEVICE(0x3340, 0x1326) }, /* Itautec USB Sync */
-	{ USB_DEVICE(0x3340, 0x3326) }, /* MEDION Winodws Moble USB Sync */
+	{ USB_DEVICE(0x1114, 0x0001) }, /* Psion Teklogix Sync 753x */
+	{ USB_DEVICE(0x1114, 0x0004) }, /* Psion Teklogix Sync netBookPro */
+	{ USB_DEVICE(0x1114, 0x0006) }, /* Psion Teklogix Sync 7525 */
+	{ USB_DEVICE(0x1182, 0x1388) }, /* VES USB Sync */
+	{ USB_DEVICE(0x11D9, 0x1002) }, /* Rugged Pocket PC 2003 */
+	{ USB_DEVICE(0x11D9, 0x1003) }, /* Rugged Pocket PC 2003 */
+	{ USB_DEVICE(0x1231, 0xCE01) }, /* USB Sync 03 */
+	{ USB_DEVICE(0x1231, 0xCE02) }, /* USB Sync 03 */
+	{ USB_DEVICE(0x1690, 0x0601) }, /* Askey USB Sync */
+	{ USB_DEVICE(0x22B8, 0x4204) }, /* Motorola MPx200 Smartphone */
+	{ USB_DEVICE(0x22B8, 0x4214) }, /* Motorola MPc GSM */
+	{ USB_DEVICE(0x22B8, 0x4224) }, /* Motorola MPx220 Smartphone */
+	{ USB_DEVICE(0x22B8, 0x4234) }, /* Motorola MPc CDMA */
+	{ USB_DEVICE(0x22B8, 0x4244) }, /* Motorola MPx100 Smartphone */
+	{ USB_DEVICE(0x3340, 0x011C) }, /* Mio DigiWalker PPC StrongARM */
 	{ USB_DEVICE(0x3340, 0x0326) }, /* Mio DigiWalker 338 */
 	{ USB_DEVICE(0x3340, 0x0426) }, /* Mio DigiWalker 338 */
-	{ USB_DEVICE(0x3340, 0x011C) }, /* Mio DigiWalker PPC StrongARM */
-	{ USB_DEVICE(0x3340, 0x053A) }, /* Mio DigiWalker SmartPhone USB Sync */
 	{ USB_DEVICE(0x3340, 0x043A) }, /* Mio DigiWalker USB Sync */
-	{ USB_DEVICE(0x3340, 0x071C) }, /* MiTAC USB Sync */
 	{ USB_DEVICE(0x3340, 0x051C) }, /* MiTAC USB Sync 528 */
-	{ USB_DEVICE(0x3340, 0x2326) }, /* Vobis USB Sync */
+	{ USB_DEVICE(0x3340, 0x053A) }, /* Mio DigiWalker SmartPhone USB Sync */
+	{ USB_DEVICE(0x3340, 0x071C) }, /* MiTAC USB Sync */
+	{ USB_DEVICE(0x3340, 0x0B1C) }, /* Generic PPC StrongARM */
+	{ USB_DEVICE(0x3340, 0x0E3A) }, /* Generic PPC USB Sync */
+	{ USB_DEVICE(0x3340, 0x0F1C) }, /* Itautec USB Sync */
+	{ USB_DEVICE(0x3340, 0x0F3A) }, /* Generic SmartPhone USB Sync */
+	{ USB_DEVICE(0x3340, 0x1326) }, /* Itautec USB Sync */
 	{ USB_DEVICE(0x3340, 0x191C) }, /* YAKUMO USB Sync */
+	{ USB_DEVICE(0x3340, 0x2326) }, /* Vobis USB Sync */
+	{ USB_DEVICE(0x3340, 0x3326) }, /* MEDION Winodws Moble USB Sync */
+	{ USB_DEVICE(0x3708, 0x20CE) }, /* Legend USB Sync */
+	{ USB_DEVICE(0x3708, 0x21CE) }, /* Lenovo USB Sync */
 	{ USB_DEVICE(0x4113, 0x0210) }, /* Mobile Media Technology USB Sync */
 	{ USB_DEVICE(0x4113, 0x0211) }, /* Mobile Media Technology USB Sync */
 	{ USB_DEVICE(0x4113, 0x0400) }, /* Mobile Media Technology USB Sync */
 	{ USB_DEVICE(0x4113, 0x0410) }, /* Mobile Media Technology USB Sync */
-	{ USB_DEVICE(0x0CAD, 0x9001) }, /* Motorola PowerPad Pocket PCDevice */
-	{ USB_DEVICE(0x0C44, 0x03A2) }, /* Motorola iDEN Smartphone */
-	{ USB_DEVICE(0x04E8, 0x6611) }, /* Samsung MITs USB Sync */
-	{ USB_DEVICE(0x04E8, 0x6613) }, /* Samsung MITs USB Sync */
-	{ USB_DEVICE(0x04E8, 0x6615) }, /* Samsung MITs USB Sync */
-	{ USB_DEVICE(0x04E8, 0x6617) }, /* Samsung MITs USB Sync */
-	{ USB_DEVICE(0x04E8, 0x6619) }, /* Samsung MITs USB Sync */
-	{ USB_DEVICE(0x04E8, 0x661B) }, /* Samsung MITs USB Sync */
-	{ USB_DEVICE(0x04E8, 0x5F00) }, /* Samsung NEXiO USB Sync */
-	{ USB_DEVICE(0x04E8, 0x5F01) }, /* Samsung NEXiO USB Sync */
-	{ USB_DEVICE(0x04E8, 0x5F02) }, /* Samsung NEXiO USB Sync */
-	{ USB_DEVICE(0x04E8, 0x5F03) }, /* Samsung NEXiO USB Sync */
-	{ USB_DEVICE(0x04E8, 0x5F04) }, /* Samsung NEXiO USB Sync */
-	{ USB_DEVICE(0x04E8, 0x662E) }, /* Samsung MITs USB Sync */
-	{ USB_DEVICE(0x04E8, 0x6630) }, /* Samsung MITs USB Sync */
-	{ USB_DEVICE(0x04E8, 0x6632) }, /* Samsung MITs USB Sync */
+	{ USB_DEVICE(0x413C, 0x4001) }, /* Dell Axim USB Sync */
+	{ USB_DEVICE(0x413C, 0x4002) }, /* Dell Axim USB Sync */
+	{ USB_DEVICE(0x413C, 0x4003) }, /* Dell Axim USB Sync */
+	{ USB_DEVICE(0x413C, 0x4004) }, /* Dell Axim USB Sync */
+	{ USB_DEVICE(0x413C, 0x4005) }, /* Dell Axim USB Sync */
+	{ USB_DEVICE(0x413C, 0x4006) }, /* Dell Axim USB Sync */
+	{ USB_DEVICE(0x413C, 0x4007) }, /* Dell Axim USB Sync */
+	{ USB_DEVICE(0x413C, 0x4008) }, /* Dell Axim USB Sync */
+	{ USB_DEVICE(0x413C, 0x4009) }, /* Dell Axim USB Sync */
 	{ USB_DEVICE(0x4505, 0x0010) }, /* Smartphone */
-	{ USB_DEVICE(0x05E0, 0x2000) }, /* Symbol USB Sync */
-	{ USB_DEVICE(0x05E0, 0x2001) }, /* Symbol USB Sync 0x2001 */
-	{ USB_DEVICE(0x05E0, 0x2002) }, /* Symbol USB Sync 0x2002 */
-	{ USB_DEVICE(0x05E0, 0x2003) }, /* Symbol USB Sync 0x2003 */
-	{ USB_DEVICE(0x05E0, 0x2004) }, /* Symbol USB Sync 0x2004 */
-	{ USB_DEVICE(0x05E0, 0x2005) }, /* Symbol USB Sync 0x2005 */
-	{ USB_DEVICE(0x05E0, 0x2006) }, /* Symbol USB Sync 0x2006 */
-	{ USB_DEVICE(0x05E0, 0x2007) }, /* Symbol USB Sync 0x2007 */
-	{ USB_DEVICE(0x05E0, 0x2008) }, /* Symbol USB Sync 0x2008 */
-	{ USB_DEVICE(0x05E0, 0x2009) }, /* Symbol USB Sync 0x2009 */
-	{ USB_DEVICE(0x05E0, 0x200A) }, /* Symbol USB Sync 0x200A */
-	{ USB_DEVICE(0x1182, 0x1388) }, /* VES USB Sync */
-	{ USB_DEVICE(0x0543, 0x0ED9) }, /* ViewSonic Color Pocket PC V35 */
-	{ USB_DEVICE(0x0543, 0x1527) }, /* ViewSonic Color Pocket PC V36 */
-	{ USB_DEVICE(0x0543, 0x1529) }, /* ViewSonic Color Pocket PC V37 */
-	{ USB_DEVICE(0x0543, 0x152B) }, /* ViewSonic Color Pocket PC V38 */
-	{ USB_DEVICE(0x0543, 0x152E) }, /* ViewSonic Pocket PC */
-	{ USB_DEVICE(0x0543, 0x1921) }, /* ViewSonic Communicator Pocket PC */
-	{ USB_DEVICE(0x0543, 0x1922) }, /* ViewSonic Smartphone */
-	{ USB_DEVICE(0x0543, 0x1923) }, /* ViewSonic Pocket PC V30 */
-	{ USB_DEVICE(0x0536, 0x01A0) }, /* HHP PDT */
-	{ USB_DEVICE(0x099E, 0x0052) }, /* Trimble GeoExplorer */
-	{ USB_DEVICE(0x099E, 0x4000) }, /* TDS Data Collector */
-	{ USB_DEVICE(0x0FB8, 0x3001) }, /* Wistron USB Sync */
-	{ USB_DEVICE(0x0FB8, 0x3002) }, /* Wistron USB Sync */
-	{ USB_DEVICE(0x0FB8, 0x3003) }, /* Wistron USB Sync */
-	{ USB_DEVICE(0x0FB8, 0x4001) }, /* Wistron USB Sync */
-	{ USB_DEVICE(0x11D9, 0x1003) }, /* Rugged Pocket PC 2003 */
-	{ USB_DEVICE(0x11D9, 0x1002) }, /* Rugged Pocket PC 2003 */
-	{ USB_DEVICE(0x22B8, 0x4204) }, /* Motorola MPx200 Smartphone */
-	{ USB_DEVICE(0x22B8, 0x4214) }, /* Motorola MPc GSM */
-	{ USB_DEVICE(0x22B8, 0x4224) }, /* Motorola MPx220 Smartphone */
-	{ USB_DEVICE(0x22B8, 0x4234) }, /* Motorola MPc CDMA */
-	{ USB_DEVICE(0x22B8, 0x4244) }, /* Motorola MPx100 Smartphone */
-	{ USB_DEVICE(0x1231, 0xCE01) }, /* USB Sync 03 */
-	{ USB_DEVICE(0x1231, 0xCE02) }, /* USB Sync 03 */
+	{ USB_DEVICE(0x5E04, 0xCE00) }, /* SAGEM Wireless Assistant */
 	{ }                             /* Terminating entry */
 };
 

commit 269bda1c123c7caf88e1deb2264f9086f0344192
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Jun 20 21:15:16 2005 -0700

    [PATCH] USB Serial: move name to driver structure
    
    This fixes up a lot of problems in sysfs with some of the usb serial
    drivers, they had incorrect driver names.  Also saves a tiny ammount
    of memory.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c
index 9aedfb91b20c..1abaebe6dbc1 100644
--- a/drivers/usb/serial/ipaq.c
+++ b/drivers/usb/serial/ipaq.c
@@ -550,8 +550,9 @@ static struct usb_driver ipaq_driver = {
 static struct usb_serial_driver ipaq_device = {
 	.driver = {
 		.owner =	THIS_MODULE,
+		.name =		"ipaq",
 	},
-	.name =			"PocketPC PDA",
+	.description =		"PocketPC PDA",
 	.id_table =		ipaq_id_table,
 	.num_interrupt_in =	NUM_DONT_CARE,
 	.num_bulk_in =		1,

commit 18fcac353fdc7cd072b0d24c8667042e675a4c11
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Jun 20 21:15:16 2005 -0700

    [PATCH] USB Serial: get rid of the .owner field in usb_serial_driver
    
    Don't duplicate something that's already in struct driver.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c
index 9a79ad8d7a5f..9aedfb91b20c 100644
--- a/drivers/usb/serial/ipaq.c
+++ b/drivers/usb/serial/ipaq.c
@@ -548,7 +548,9 @@ static struct usb_driver ipaq_driver = {
 
 /* All of the device info needed for the Compaq iPAQ */
 static struct usb_serial_driver ipaq_device = {
-	.owner =		THIS_MODULE,
+	.driver = {
+		.owner =	THIS_MODULE,
+	},
 	.name =			"PocketPC PDA",
 	.id_table =		ipaq_id_table,
 	.num_interrupt_in =	NUM_DONT_CARE,

commit ea65370d025f5005649e5cb37c4d025e92c6fc38
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Jun 20 21:15:16 2005 -0700

    [PATCH] USB Serial: rename usb_serial_device_type to usb_serial_driver
    
    I'm tired of trying to explain why a "device_type" is really a driver.
    This better describes exactly what this structure is.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c
index c05c2a2a0f31..9a79ad8d7a5f 100644
--- a/drivers/usb/serial/ipaq.c
+++ b/drivers/usb/serial/ipaq.c
@@ -547,7 +547,7 @@ static struct usb_driver ipaq_driver = {
 
 
 /* All of the device info needed for the Compaq iPAQ */
-static struct usb_serial_device_type ipaq_device = {
+static struct usb_serial_driver ipaq_device = {
 	.owner =		THIS_MODULE,
 	.name =			"PocketPC PDA",
 	.id_table =		ipaq_id_table,

commit 507ca9bc0476662f3463888d583864834eab1e11
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Sat Apr 23 12:49:16 2005 -0700

    [PATCH] USB: add ability for usb-serial drivers to determine if their write urb is currently being used.
    
    This removes a lot of racy and buggy code by trying to check the status of the urb.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c
index 3bd69c4ef24b..c05c2a2a0f31 100644
--- a/drivers/usb/serial/ipaq.c
+++ b/drivers/usb/serial/ipaq.c
@@ -818,11 +818,6 @@ static void ipaq_write_gather(struct usb_serial_port *port)
 	struct ipaq_packet	*pkt, *tmp;
 	struct urb		*urb = port->write_urb;
 
-	if (urb->status == -EINPROGRESS) {
-		/* Should never happen */
-		err("%s - flushing while urb is active !", __FUNCTION__);
-		return;
-	}
 	room = URBDATA_SIZE;
 	list_for_each_entry_safe(pkt, tmp, &priv->queue, list) {
 		count = min(room, (int)(pkt->len - pkt->written));

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c
new file mode 100644
index 000000000000..3bd69c4ef24b
--- /dev/null
+++ b/drivers/usb/serial/ipaq.c
@@ -0,0 +1,973 @@
+/*
+ * USB Compaq iPAQ driver
+ *
+ *	Copyright (C) 2001 - 2002
+ *	    Ganesh Varadarajan <ganesh@veritas.com>
+ *
+ *	This program is free software; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License as published by
+ *	the Free Software Foundation; either version 2 of the License, or
+ *	(at your option) any later version.
+ *
+ * (12/12/2002) ganesh
+ * 	Added support for practically all devices supported by ActiveSync
+ * 	on Windows. Thanks to Wes Cilldhaire <billybobjoehenrybob@hotmail.com>.
+ *
+ * (26/11/2002) ganesh
+ * 	Added insmod options to specify product and vendor id.
+ * 	Use modprobe ipaq vendor=0xfoo product=0xbar
+ *
+ * (26/7/2002) ganesh
+ * 	Fixed up broken error handling in ipaq_open. Retry the "kickstart"
+ * 	packet much harder - this drastically reduces connection failures.
+ *
+ * (30/4/2002) ganesh
+ * 	Added support for the Casio EM500. Completely untested. Thanks
+ * 	to info from Nathan <wfilardo@fuse.net>
+ *
+ * (19/3/2002) ganesh
+ *	Don't submit urbs while holding spinlocks. Not strictly necessary
+ *	in 2.5.x.
+ *
+ * (8/3/2002) ganesh
+ * 	The ipaq sometimes emits a '\0' before the CLIENT string. At this
+ * 	point of time, the ppp ldisc is not yet attached to the tty, so
+ * 	n_tty echoes "^ " to the ipaq, which messes up the chat. In 2.5.6-pre2
+ * 	this causes a panic because echo_char() tries to sleep in interrupt
+ * 	context.
+ * 	The fix is to tell the upper layers that this is a raw device so that
+ * 	echoing is suppressed. Thanks to Lyle Lindholm for a detailed bug
+ * 	report.
+ *
+ * (25/2/2002) ganesh
+ * 	Added support for the HP Jornada 548 and 568. Completely untested.
+ * 	Thanks to info from Heath Robinson and Arieh Davidoff.
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/tty.h>
+#include <linux/tty_driver.h>
+#include <linux/tty_flip.h>
+#include <linux/module.h>
+#include <linux/spinlock.h>
+#include <asm/uaccess.h>
+#include <linux/usb.h>
+#include "usb-serial.h"
+#include "ipaq.h"
+
+#define KP_RETRIES	100
+
+/*
+ * Version Information
+ */
+
+#define DRIVER_VERSION "v0.5"
+#define DRIVER_AUTHOR "Ganesh Varadarajan <ganesh@veritas.com>"
+#define DRIVER_DESC "USB PocketPC PDA driver"
+
+static __u16 product, vendor;
+static int debug;
+
+/* Function prototypes for an ipaq */
+static int  ipaq_open (struct usb_serial_port *port, struct file *filp);
+static void ipaq_close (struct usb_serial_port *port, struct file *filp);
+static int  ipaq_startup (struct usb_serial *serial);
+static void ipaq_shutdown (struct usb_serial *serial);
+static int ipaq_write(struct usb_serial_port *port, const unsigned char *buf,
+		       int count);
+static int ipaq_write_bulk(struct usb_serial_port *port, const unsigned char *buf,
+			   int count);
+static void ipaq_write_gather(struct usb_serial_port *port);
+static void ipaq_read_bulk_callback (struct urb *urb, struct pt_regs *regs);
+static void ipaq_write_bulk_callback(struct urb *urb, struct pt_regs *regs);
+static int ipaq_write_room(struct usb_serial_port *port);
+static int ipaq_chars_in_buffer(struct usb_serial_port *port);
+static void ipaq_destroy_lists(struct usb_serial_port *port);
+
+
+static struct usb_device_id ipaq_id_table [] = {
+	/* The first entry is a placeholder for the insmod-specified device */
+	{ USB_DEVICE(0x049F, 0x0003) },
+	{ USB_DEVICE(0x1690, 0x0601) }, /* Askey USB Sync */
+	{ USB_DEVICE(0x0960, 0x0065) }, /* BCOM USB Sync 0065 */
+	{ USB_DEVICE(0x0960, 0x0066) }, /* BCOM USB Sync 0066 */
+	{ USB_DEVICE(0x0960, 0x0067) }, /* BCOM USB Sync 0067 */
+	{ USB_DEVICE(0x07CF, 0x2001) }, /* CASIO USB Sync 2001 */
+	{ USB_DEVICE(0x07CF, 0x2002) }, /* CASIO USB Sync 2002 */
+	{ USB_DEVICE(0x07CF, 0x2003) }, /* CASIO USB Sync 2003 */
+	{ USB_DEVICE(0x049F, 0x0003) }, /* Compaq iPAQ USB Sync */
+	{ USB_DEVICE(0x049F, 0x0032) }, /* Compaq iPAQ USB Sync */
+	{ USB_DEVICE(0x413C, 0x4001) }, /* Dell Axim USB Sync */
+	{ USB_DEVICE(0x413C, 0x4002) }, /* Dell Axim USB Sync */
+	{ USB_DEVICE(0x413C, 0x4003) }, /* Dell Axim USB Sync */
+	{ USB_DEVICE(0x413C, 0x4004) }, /* Dell Axim USB Sync */
+	{ USB_DEVICE(0x413C, 0x4005) }, /* Dell Axim USB Sync */
+	{ USB_DEVICE(0x413C, 0x4006) }, /* Dell Axim USB Sync */
+	{ USB_DEVICE(0x413C, 0x4007) }, /* Dell Axim USB Sync */
+	{ USB_DEVICE(0x413C, 0x4008) }, /* Dell Axim USB Sync */
+	{ USB_DEVICE(0x413C, 0x4009) }, /* Dell Axim USB Sync */
+	{ USB_DEVICE(0x03F0, 0x1016) }, /* HP USB Sync */
+	{ USB_DEVICE(0x03F0, 0x1116) }, /* HP USB Sync 1611 */
+	{ USB_DEVICE(0x03F0, 0x1216) }, /* HP USB Sync 1612 */
+	{ USB_DEVICE(0x03F0, 0x2016) }, /* HP USB Sync 1620 */
+	{ USB_DEVICE(0x03F0, 0x2116) }, /* HP USB Sync 1621 */
+	{ USB_DEVICE(0x03F0, 0x2216) }, /* HP USB Sync 1622 */
+	{ USB_DEVICE(0x03F0, 0x3016) }, /* HP USB Sync 1630 */
+	{ USB_DEVICE(0x03F0, 0x3116) }, /* HP USB Sync 1631 */
+	{ USB_DEVICE(0x03F0, 0x3216) }, /* HP USB Sync 1632 */
+	{ USB_DEVICE(0x03F0, 0x4016) }, /* HP USB Sync 1640 */
+	{ USB_DEVICE(0x03F0, 0x4116) }, /* HP USB Sync 1641 */
+	{ USB_DEVICE(0x03F0, 0x4216) }, /* HP USB Sync 1642 */
+	{ USB_DEVICE(0x03F0, 0x5016) }, /* HP USB Sync 1650 */
+	{ USB_DEVICE(0x03F0, 0x5116) }, /* HP USB Sync 1651 */
+	{ USB_DEVICE(0x03F0, 0x5216) }, /* HP USB Sync 1652 */
+	{ USB_DEVICE(0x094B, 0x0001) }, /* Linkup Systems USB Sync */
+	{ USB_DEVICE(0x045E, 0x0400) }, /* Windows Powered Pocket PC 2002 */
+	{ USB_DEVICE(0x045E, 0x0401) }, /* Windows Powered Pocket PC 2002 */
+	{ USB_DEVICE(0x045E, 0x0402) }, /* Windows Powered Pocket PC 2002 */
+	{ USB_DEVICE(0x045E, 0x0403) }, /* Windows Powered Pocket PC 2002 */
+	{ USB_DEVICE(0x045E, 0x0404) }, /* Windows Powered Pocket PC 2002 */
+	{ USB_DEVICE(0x045E, 0x0405) }, /* Windows Powered Pocket PC 2002 */
+	{ USB_DEVICE(0x045E, 0x0406) }, /* Windows Powered Pocket PC 2002 */
+	{ USB_DEVICE(0x045E, 0x0407) }, /* Windows Powered Pocket PC 2002 */
+	{ USB_DEVICE(0x045E, 0x0408) }, /* Windows Powered Pocket PC 2002 */
+	{ USB_DEVICE(0x045E, 0x0409) }, /* Windows Powered Pocket PC 2002 */
+	{ USB_DEVICE(0x045E, 0x040A) }, /* Windows Powered Pocket PC 2002 */
+	{ USB_DEVICE(0x045E, 0x040B) }, /* Windows Powered Pocket PC 2002 */
+	{ USB_DEVICE(0x045E, 0x040C) }, /* Windows Powered Pocket PC 2002 */
+	{ USB_DEVICE(0x045E, 0x040D) }, /* Windows Powered Pocket PC 2002 */
+	{ USB_DEVICE(0x045E, 0x040E) }, /* Windows Powered Pocket PC 2002 */
+	{ USB_DEVICE(0x045E, 0x040F) }, /* Windows Powered Pocket PC 2002 */
+	{ USB_DEVICE(0x045E, 0x0410) }, /* Windows Powered Pocket PC 2002 */
+	{ USB_DEVICE(0x045E, 0x0411) }, /* Windows Powered Pocket PC 2002 */
+	{ USB_DEVICE(0x045E, 0x0412) }, /* Windows Powered Pocket PC 2002 */
+	{ USB_DEVICE(0x045E, 0x0413) }, /* Windows Powered Pocket PC 2002 */
+	{ USB_DEVICE(0x045E, 0x0414) }, /* Windows Powered Pocket PC 2002 */
+	{ USB_DEVICE(0x045E, 0x0415) }, /* Windows Powered Pocket PC 2002 */
+	{ USB_DEVICE(0x045E, 0x0416) }, /* Windows Powered Pocket PC 2002 */
+	{ USB_DEVICE(0x045E, 0x0417) }, /* Windows Powered Pocket PC 2002 */
+	{ USB_DEVICE(0x045E, 0x0432) }, /* Windows Powered Pocket PC 2003 */
+	{ USB_DEVICE(0x045E, 0x0433) }, /* Windows Powered Pocket PC 2003 */
+	{ USB_DEVICE(0x045E, 0x0434) }, /* Windows Powered Pocket PC 2003 */
+	{ USB_DEVICE(0x045E, 0x0435) }, /* Windows Powered Pocket PC 2003 */
+	{ USB_DEVICE(0x045E, 0x0436) }, /* Windows Powered Pocket PC 2003 */
+	{ USB_DEVICE(0x045E, 0x0437) }, /* Windows Powered Pocket PC 2003 */
+	{ USB_DEVICE(0x045E, 0x0438) }, /* Windows Powered Pocket PC 2003 */
+	{ USB_DEVICE(0x045E, 0x0439) }, /* Windows Powered Pocket PC 2003 */
+	{ USB_DEVICE(0x045E, 0x043A) }, /* Windows Powered Pocket PC 2003 */
+	{ USB_DEVICE(0x045E, 0x043B) }, /* Windows Powered Pocket PC 2003 */
+	{ USB_DEVICE(0x045E, 0x043C) }, /* Windows Powered Pocket PC 2003 */
+	{ USB_DEVICE(0x045E, 0x043D) }, /* Windows Powered Pocket PC 2003 */
+	{ USB_DEVICE(0x045E, 0x043E) }, /* Windows Powered Pocket PC 2003 */
+	{ USB_DEVICE(0x045E, 0x043F) }, /* Windows Powered Pocket PC 2003 */
+	{ USB_DEVICE(0x045E, 0x0440) }, /* Windows Powered Pocket PC 2003 */
+	{ USB_DEVICE(0x045E, 0x0441) }, /* Windows Powered Pocket PC 2003 */
+	{ USB_DEVICE(0x045E, 0x0442) }, /* Windows Powered Pocket PC 2003 */
+	{ USB_DEVICE(0x045E, 0x0443) }, /* Windows Powered Pocket PC 2003 */
+	{ USB_DEVICE(0x045E, 0x0444) }, /* Windows Powered Pocket PC 2003 */
+	{ USB_DEVICE(0x045E, 0x0445) }, /* Windows Powered Pocket PC 2003 */
+	{ USB_DEVICE(0x045E, 0x0446) }, /* Windows Powered Pocket PC 2003 */
+	{ USB_DEVICE(0x045E, 0x0447) }, /* Windows Powered Pocket PC 2003 */
+	{ USB_DEVICE(0x045E, 0x0448) }, /* Windows Powered Pocket PC 2003 */
+	{ USB_DEVICE(0x045E, 0x0449) }, /* Windows Powered Pocket PC 2003 */
+	{ USB_DEVICE(0x045E, 0x044A) }, /* Windows Powered Pocket PC 2003 */
+	{ USB_DEVICE(0x045E, 0x044B) }, /* Windows Powered Pocket PC 2003 */
+	{ USB_DEVICE(0x045E, 0x044C) }, /* Windows Powered Pocket PC 2003 */
+	{ USB_DEVICE(0x045E, 0x044D) }, /* Windows Powered Pocket PC 2003 */
+	{ USB_DEVICE(0x045E, 0x044E) }, /* Windows Powered Pocket PC 2003 */
+	{ USB_DEVICE(0x045E, 0x044F) }, /* Windows Powered Pocket PC 2003 */
+	{ USB_DEVICE(0x045E, 0x0450) }, /* Windows Powered Pocket PC 2003 */
+	{ USB_DEVICE(0x045E, 0x0451) }, /* Windows Powered Pocket PC 2003 */
+	{ USB_DEVICE(0x045E, 0x0452) }, /* Windows Powered Pocket PC 2003 */
+	{ USB_DEVICE(0x045E, 0x0453) }, /* Windows Powered Pocket PC 2003 */
+	{ USB_DEVICE(0x045E, 0x0454) }, /* Windows Powered Pocket PC 2003 */
+	{ USB_DEVICE(0x045E, 0x0455) }, /* Windows Powered Pocket PC 2003 */
+	{ USB_DEVICE(0x045E, 0x0456) }, /* Windows Powered Pocket PC 2003 */
+	{ USB_DEVICE(0x045E, 0x0457) }, /* Windows Powered Pocket PC 2003 */
+	{ USB_DEVICE(0x045E, 0x0458) }, /* Windows Powered Pocket PC 2003 */
+	{ USB_DEVICE(0x045E, 0x0459) }, /* Windows Powered Pocket PC 2003 */
+	{ USB_DEVICE(0x045E, 0x045A) }, /* Windows Powered Pocket PC 2003 */
+	{ USB_DEVICE(0x045E, 0x045B) }, /* Windows Powered Pocket PC 2003 */
+	{ USB_DEVICE(0x045E, 0x045C) }, /* Windows Powered Pocket PC 2003 */
+	{ USB_DEVICE(0x045E, 0x045D) }, /* Windows Powered Pocket PC 2003 */
+	{ USB_DEVICE(0x045E, 0x045E) }, /* Windows Powered Pocket PC 2003 */
+	{ USB_DEVICE(0x045E, 0x045F) }, /* Windows Powered Pocket PC 2003 */
+	{ USB_DEVICE(0x045E, 0x0460) }, /* Windows Powered Pocket PC 2003 */
+	{ USB_DEVICE(0x045E, 0x0461) }, /* Windows Powered Pocket PC 2003 */
+	{ USB_DEVICE(0x045E, 0x0462) }, /* Windows Powered Pocket PC 2003 */
+	{ USB_DEVICE(0x045E, 0x0463) }, /* Windows Powered Pocket PC 2003 */
+	{ USB_DEVICE(0x045E, 0x0464) }, /* Windows Powered Pocket PC 2003 */
+	{ USB_DEVICE(0x045E, 0x0465) }, /* Windows Powered Pocket PC 2003 */
+	{ USB_DEVICE(0x045E, 0x0466) }, /* Windows Powered Pocket PC 2003 */
+	{ USB_DEVICE(0x045E, 0x0467) }, /* Windows Powered Pocket PC 2003 */
+	{ USB_DEVICE(0x045E, 0x0468) }, /* Windows Powered Pocket PC 2003 */
+	{ USB_DEVICE(0x045E, 0x0469) }, /* Windows Powered Pocket PC 2003 */
+	{ USB_DEVICE(0x045E, 0x046A) }, /* Windows Powered Pocket PC 2003 */
+	{ USB_DEVICE(0x045E, 0x046B) }, /* Windows Powered Pocket PC 2003 */
+	{ USB_DEVICE(0x045E, 0x046C) }, /* Windows Powered Pocket PC 2003 */
+	{ USB_DEVICE(0x045E, 0x046D) }, /* Windows Powered Pocket PC 2003 */
+	{ USB_DEVICE(0x045E, 0x046E) }, /* Windows Powered Pocket PC 2003 */
+	{ USB_DEVICE(0x045E, 0x046F) }, /* Windows Powered Pocket PC 2003 */
+	{ USB_DEVICE(0x045E, 0x0470) }, /* Windows Powered Pocket PC 2003 */
+	{ USB_DEVICE(0x045E, 0x0471) }, /* Windows Powered Pocket PC 2003 */
+	{ USB_DEVICE(0x045E, 0x0472) }, /* Windows Powered Pocket PC 2003 */
+	{ USB_DEVICE(0x045E, 0x0473) }, /* Windows Powered Pocket PC 2003 */
+	{ USB_DEVICE(0x045E, 0x0474) }, /* Windows Powered Pocket PC 2003 */
+	{ USB_DEVICE(0x045E, 0x0475) }, /* Windows Powered Pocket PC 2003 */
+	{ USB_DEVICE(0x045E, 0x0476) }, /* Windows Powered Pocket PC 2003 */
+	{ USB_DEVICE(0x045E, 0x0477) }, /* Windows Powered Pocket PC 2003 */
+	{ USB_DEVICE(0x045E, 0x0478) }, /* Windows Powered Pocket PC 2003 */
+	{ USB_DEVICE(0x045E, 0x0479) }, /* Windows Powered Pocket PC 2003 */
+	{ USB_DEVICE(0x045E, 0x047A) }, /* Windows Powered Pocket PC 2003 */
+	{ USB_DEVICE(0x045E, 0x047B) }, /* Windows Powered Pocket PC 2003 */
+	{ USB_DEVICE(0x045E, 0x04C8) }, /* Windows Powered Smartphone 2002 */
+	{ USB_DEVICE(0x045E, 0x04C9) }, /* Windows Powered Smartphone 2002 */
+	{ USB_DEVICE(0x045E, 0x04CA) }, /* Windows Powered Smartphone 2002 */
+	{ USB_DEVICE(0x045E, 0x04CB) }, /* Windows Powered Smartphone 2002 */
+	{ USB_DEVICE(0x045E, 0x04CC) }, /* Windows Powered Smartphone 2002 */
+	{ USB_DEVICE(0x045E, 0x04CD) }, /* Windows Powered Smartphone 2002 */
+	{ USB_DEVICE(0x045E, 0x04CE) }, /* Windows Powered Smartphone 2002 */
+	{ USB_DEVICE(0x045E, 0x04D7) }, /* Windows Powered Smartphone 2003 */
+	{ USB_DEVICE(0x045E, 0x04D8) }, /* Windows Powered Smartphone 2003 */
+	{ USB_DEVICE(0x045E, 0x04D9) }, /* Windows Powered Smartphone 2003 */
+	{ USB_DEVICE(0x045E, 0x04DA) }, /* Windows Powered Smartphone 2003 */
+	{ USB_DEVICE(0x045E, 0x04DB) }, /* Windows Powered Smartphone 2003 */
+	{ USB_DEVICE(0x045E, 0x04DC) }, /* Windows Powered Smartphone 2003 */
+	{ USB_DEVICE(0x045E, 0x04DD) }, /* Windows Powered Smartphone 2003 */
+	{ USB_DEVICE(0x045E, 0x04DE) }, /* Windows Powered Smartphone 2003 */
+	{ USB_DEVICE(0x045E, 0x04DF) }, /* Windows Powered Smartphone 2003 */
+	{ USB_DEVICE(0x045E, 0x04E0) }, /* Windows Powered Smartphone 2003 */
+	{ USB_DEVICE(0x045E, 0x04E1) }, /* Windows Powered Smartphone 2003 */
+	{ USB_DEVICE(0x045E, 0x04E2) }, /* Windows Powered Smartphone 2003 */
+	{ USB_DEVICE(0x045E, 0x04E3) }, /* Windows Powered Smartphone 2003 */
+	{ USB_DEVICE(0x045E, 0x04E4) }, /* Windows Powered Smartphone 2003 */
+	{ USB_DEVICE(0x045E, 0x04E5) }, /* Windows Powered Smartphone 2003 */
+	{ USB_DEVICE(0x045E, 0x04E6) }, /* Windows Powered Smartphone 2003 */
+	{ USB_DEVICE(0x045E, 0x04E7) }, /* Windows Powered Smartphone 2003 */
+	{ USB_DEVICE(0x045E, 0x04E8) }, /* Windows Powered Smartphone 2003 */
+	{ USB_DEVICE(0x045E, 0x04E9) }, /* Windows Powered Smartphone 2003 */
+	{ USB_DEVICE(0x045E, 0x04EA) }, /* Windows Powered Smartphone 2003 */
+	{ USB_DEVICE(0x0961, 0x0010) }, /* Portatec USB Sync */
+	{ USB_DEVICE(0x5E04, 0xCE00) }, /* SAGEM Wireless Assistant */
+	{ USB_DEVICE(0x0104, 0x00BE) }, /* Socket USB Sync */
+	{ USB_DEVICE(0x0930, 0x0700) }, /* TOSHIBA USB Sync 0700 */
+	{ USB_DEVICE(0x0930, 0x0705) }, /* TOSHIBA Pocket PC e310 */
+	{ USB_DEVICE(0x0930, 0x0707) }, /* TOSHIBA Pocket PC e330 Series */
+	{ USB_DEVICE(0x0930, 0x0708) }, /* TOSHIBA Pocket PC e350Series */
+	{ USB_DEVICE(0x0930, 0x0706) }, /* TOSHIBA Pocket PC e740 */
+	{ USB_DEVICE(0x0930, 0x0709) }, /* TOSHIBA Pocket PC e750 Series */
+	{ USB_DEVICE(0x0930, 0x070A) }, /* TOSHIBA Pocket PC e400 Series */
+	{ USB_DEVICE(0x0930, 0x070B) }, /* TOSHIBA Pocket PC e800 Series */
+	{ USB_DEVICE(0x0BB4, 0x00CE) }, /* HTC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A01) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A02) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A03) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A04) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A05) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A06) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A07) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A08) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A09) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A0A) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A0B) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A0C) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A0D) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A0E) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A0F) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A10) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A11) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A12) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A13) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A14) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A15) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A16) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A17) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A18) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A19) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A1A) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A1B) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A1C) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A1D) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A1E) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A1F) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A20) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A21) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A22) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A23) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A24) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A25) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A26) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A27) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A28) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A29) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A2A) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A2B) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A2C) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A2D) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A2E) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A2F) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A30) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A31) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A32) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A33) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A34) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A35) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A36) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A37) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A38) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A39) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A3A) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A3B) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A3C) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A3D) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A3E) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A3F) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A40) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A41) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A42) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A43) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A44) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A45) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A46) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A47) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A48) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A49) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A4A) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A4B) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A4C) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A4D) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A4E) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A4F) }, /* PocketPC USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A50) }, /* HTC SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A51) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A52) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A53) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A54) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A55) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A56) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A57) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A58) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A59) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A5A) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A5B) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A5C) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A5D) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A5E) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A5F) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A60) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A61) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A62) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A63) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A64) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A65) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A66) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A67) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A68) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A69) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A6A) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A6B) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A6C) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A6D) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A6E) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A6F) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A70) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A71) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A72) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A73) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A74) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A75) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A76) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A77) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A78) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A79) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A7A) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A7B) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A7C) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A7D) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A7E) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A7F) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A80) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A81) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A82) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A83) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A84) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A85) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A86) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A87) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A88) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A89) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A8A) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A8B) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A8C) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A8D) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A8E) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A8F) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A90) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A91) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A92) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A93) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A94) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A95) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A96) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A97) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A98) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A99) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A9A) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A9B) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A9C) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A9D) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A9E) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0BB4, 0x0A9F) }, /* SmartPhone USB Sync */
+	{ USB_DEVICE(0x0409, 0x00D5) }, /* NEC USB Sync */
+	{ USB_DEVICE(0x0409, 0x00D6) }, /* NEC USB Sync */
+	{ USB_DEVICE(0x0409, 0x00D7) }, /* NEC USB Sync */
+	{ USB_DEVICE(0x0409, 0x8024) }, /* NEC USB Sync */
+	{ USB_DEVICE(0x0409, 0x8025) }, /* NEC USB Sync */
+	{ USB_DEVICE(0x04A4, 0x0014) }, /* Hitachi USB Sync */
+	{ USB_DEVICE(0x0BF8, 0x1001) }, /* Fujitsu Siemens Computers USB Sync */
+	{ USB_DEVICE(0x0F98, 0x0201) }, /* Cyberbank USB Sync */
+	{ USB_DEVICE(0x0502, 0x16E1) }, /* Acer n10 Handheld USB Sync */
+	{ USB_DEVICE(0x0502, 0x16E3) }, /* Acer n30 Handheld USB Sync */
+	{ USB_DEVICE(0x0502, 0x16E2) }, /* Acer n20 Handheld USB Sync */
+	{ USB_DEVICE(0x0502, 0x1631) }, /* c10 Series */
+	{ USB_DEVICE(0x0502, 0x1632) }, /* c20 Series */
+	{ USB_DEVICE(0x0B05, 0x9202) }, /* ASUS USB Sync */
+	{ USB_DEVICE(0x0B05, 0x420F) }, /* ASUS USB Sync */
+	{ USB_DEVICE(0x0B05, 0x4200) }, /* ASUS USB Sync */
+	{ USB_DEVICE(0x0B05, 0x4201) }, /* ASUS USB Sync */
+	{ USB_DEVICE(0x0B05, 0x4202) }, /* ASUS USB Sync */
+	{ USB_DEVICE(0x0B05, 0x9200) }, /* ASUS USB Sync */
+	{ USB_DEVICE(0x0C8E, 0x6000) }, /* Cesscom Luxian Series */
+	{ USB_DEVICE(0x04AD, 0x0301) }, /* USB Sync 0301 */
+	{ USB_DEVICE(0x04AD, 0x0302) }, /* USB Sync 0302 */
+	{ USB_DEVICE(0x04AD, 0x0303) }, /* USB Sync 0303 */
+	{ USB_DEVICE(0x1066, 0x0300) }, /* E-TEN P3XX Pocket PC */
+	{ USB_DEVICE(0x1066, 0x0500) }, /* E-TEN P5XX Pocket PC */
+	{ USB_DEVICE(0x1066, 0x0600) }, /* E-TEN P6XX Pocket PC */
+	{ USB_DEVICE(0x1066, 0x0700) }, /* E-TEN P7XX Pocket PC */
+	{ USB_DEVICE(0x1066, 0x00CE) }, /* E-TEN USB Sync */
+	{ USB_DEVICE(0x0F4E, 0x0200) }, /* Freedom Scientific USB Sync */
+	{ USB_DEVICE(0x04C5, 0x1058) }, /* FUJITSU USB Sync */
+	{ USB_DEVICE(0x04C5, 0x1079) }, /* FUJITSU USB Sync */
+	{ USB_DEVICE(0x067E, 0x1001) }, /* Intermec Mobile Computer */
+	{ USB_DEVICE(0x04f1, 0x3011) }, /* JVC USB Sync */
+	{ USB_DEVICE(0x04F1, 0x3012) }, /* JVC USB Sync */
+	{ USB_DEVICE(0x3708, 0x20CE) }, /* Legend USB Sync */
+	{ USB_DEVICE(0x3708, 0x21CE) }, /* Lenovo USB Sync */
+	{ USB_DEVICE(0x043E, 0x9C01) }, /* LGE USB Sync */
+	{ USB_DEVICE(0x04DA, 0x2500) }, /* Panasonic USB Sync */
+	{ USB_DEVICE(0x3340, 0x0B1C) }, /* Generic PPC StrongARM */
+	{ USB_DEVICE(0x3340, 0x0E3A) }, /* Generic PPC USB Sync */
+	{ USB_DEVICE(0x3340, 0x0F3A) }, /* Generic SmartPhone USB Sync */
+	{ USB_DEVICE(0x3340, 0x0F1C) }, /* Itautec USB Sync */
+	{ USB_DEVICE(0x3340, 0x1326) }, /* Itautec USB Sync */
+	{ USB_DEVICE(0x3340, 0x3326) }, /* MEDION Winodws Moble USB Sync */
+	{ USB_DEVICE(0x3340, 0x0326) }, /* Mio DigiWalker 338 */
+	{ USB_DEVICE(0x3340, 0x0426) }, /* Mio DigiWalker 338 */
+	{ USB_DEVICE(0x3340, 0x011C) }, /* Mio DigiWalker PPC StrongARM */
+	{ USB_DEVICE(0x3340, 0x053A) }, /* Mio DigiWalker SmartPhone USB Sync */
+	{ USB_DEVICE(0x3340, 0x043A) }, /* Mio DigiWalker USB Sync */
+	{ USB_DEVICE(0x3340, 0x071C) }, /* MiTAC USB Sync */
+	{ USB_DEVICE(0x3340, 0x051C) }, /* MiTAC USB Sync 528 */
+	{ USB_DEVICE(0x3340, 0x2326) }, /* Vobis USB Sync */
+	{ USB_DEVICE(0x3340, 0x191C) }, /* YAKUMO USB Sync */
+	{ USB_DEVICE(0x4113, 0x0210) }, /* Mobile Media Technology USB Sync */
+	{ USB_DEVICE(0x4113, 0x0211) }, /* Mobile Media Technology USB Sync */
+	{ USB_DEVICE(0x4113, 0x0400) }, /* Mobile Media Technology USB Sync */
+	{ USB_DEVICE(0x4113, 0x0410) }, /* Mobile Media Technology USB Sync */
+	{ USB_DEVICE(0x0CAD, 0x9001) }, /* Motorola PowerPad Pocket PCDevice */
+	{ USB_DEVICE(0x0C44, 0x03A2) }, /* Motorola iDEN Smartphone */
+	{ USB_DEVICE(0x04E8, 0x6611) }, /* Samsung MITs USB Sync */
+	{ USB_DEVICE(0x04E8, 0x6613) }, /* Samsung MITs USB Sync */
+	{ USB_DEVICE(0x04E8, 0x6615) }, /* Samsung MITs USB Sync */
+	{ USB_DEVICE(0x04E8, 0x6617) }, /* Samsung MITs USB Sync */
+	{ USB_DEVICE(0x04E8, 0x6619) }, /* Samsung MITs USB Sync */
+	{ USB_DEVICE(0x04E8, 0x661B) }, /* Samsung MITs USB Sync */
+	{ USB_DEVICE(0x04E8, 0x5F00) }, /* Samsung NEXiO USB Sync */
+	{ USB_DEVICE(0x04E8, 0x5F01) }, /* Samsung NEXiO USB Sync */
+	{ USB_DEVICE(0x04E8, 0x5F02) }, /* Samsung NEXiO USB Sync */
+	{ USB_DEVICE(0x04E8, 0x5F03) }, /* Samsung NEXiO USB Sync */
+	{ USB_DEVICE(0x04E8, 0x5F04) }, /* Samsung NEXiO USB Sync */
+	{ USB_DEVICE(0x04E8, 0x662E) }, /* Samsung MITs USB Sync */
+	{ USB_DEVICE(0x04E8, 0x6630) }, /* Samsung MITs USB Sync */
+	{ USB_DEVICE(0x04E8, 0x6632) }, /* Samsung MITs USB Sync */
+	{ USB_DEVICE(0x4505, 0x0010) }, /* Smartphone */
+	{ USB_DEVICE(0x05E0, 0x2000) }, /* Symbol USB Sync */
+	{ USB_DEVICE(0x05E0, 0x2001) }, /* Symbol USB Sync 0x2001 */
+	{ USB_DEVICE(0x05E0, 0x2002) }, /* Symbol USB Sync 0x2002 */
+	{ USB_DEVICE(0x05E0, 0x2003) }, /* Symbol USB Sync 0x2003 */
+	{ USB_DEVICE(0x05E0, 0x2004) }, /* Symbol USB Sync 0x2004 */
+	{ USB_DEVICE(0x05E0, 0x2005) }, /* Symbol USB Sync 0x2005 */
+	{ USB_DEVICE(0x05E0, 0x2006) }, /* Symbol USB Sync 0x2006 */
+	{ USB_DEVICE(0x05E0, 0x2007) }, /* Symbol USB Sync 0x2007 */
+	{ USB_DEVICE(0x05E0, 0x2008) }, /* Symbol USB Sync 0x2008 */
+	{ USB_DEVICE(0x05E0, 0x2009) }, /* Symbol USB Sync 0x2009 */
+	{ USB_DEVICE(0x05E0, 0x200A) }, /* Symbol USB Sync 0x200A */
+	{ USB_DEVICE(0x1182, 0x1388) }, /* VES USB Sync */
+	{ USB_DEVICE(0x0543, 0x0ED9) }, /* ViewSonic Color Pocket PC V35 */
+	{ USB_DEVICE(0x0543, 0x1527) }, /* ViewSonic Color Pocket PC V36 */
+	{ USB_DEVICE(0x0543, 0x1529) }, /* ViewSonic Color Pocket PC V37 */
+	{ USB_DEVICE(0x0543, 0x152B) }, /* ViewSonic Color Pocket PC V38 */
+	{ USB_DEVICE(0x0543, 0x152E) }, /* ViewSonic Pocket PC */
+	{ USB_DEVICE(0x0543, 0x1921) }, /* ViewSonic Communicator Pocket PC */
+	{ USB_DEVICE(0x0543, 0x1922) }, /* ViewSonic Smartphone */
+	{ USB_DEVICE(0x0543, 0x1923) }, /* ViewSonic Pocket PC V30 */
+	{ USB_DEVICE(0x0536, 0x01A0) }, /* HHP PDT */
+	{ USB_DEVICE(0x099E, 0x0052) }, /* Trimble GeoExplorer */
+	{ USB_DEVICE(0x099E, 0x4000) }, /* TDS Data Collector */
+	{ USB_DEVICE(0x0FB8, 0x3001) }, /* Wistron USB Sync */
+	{ USB_DEVICE(0x0FB8, 0x3002) }, /* Wistron USB Sync */
+	{ USB_DEVICE(0x0FB8, 0x3003) }, /* Wistron USB Sync */
+	{ USB_DEVICE(0x0FB8, 0x4001) }, /* Wistron USB Sync */
+	{ USB_DEVICE(0x11D9, 0x1003) }, /* Rugged Pocket PC 2003 */
+	{ USB_DEVICE(0x11D9, 0x1002) }, /* Rugged Pocket PC 2003 */
+	{ USB_DEVICE(0x22B8, 0x4204) }, /* Motorola MPx200 Smartphone */
+	{ USB_DEVICE(0x22B8, 0x4214) }, /* Motorola MPc GSM */
+	{ USB_DEVICE(0x22B8, 0x4224) }, /* Motorola MPx220 Smartphone */
+	{ USB_DEVICE(0x22B8, 0x4234) }, /* Motorola MPc CDMA */
+	{ USB_DEVICE(0x22B8, 0x4244) }, /* Motorola MPx100 Smartphone */
+	{ USB_DEVICE(0x1231, 0xCE01) }, /* USB Sync 03 */
+	{ USB_DEVICE(0x1231, 0xCE02) }, /* USB Sync 03 */
+	{ }                             /* Terminating entry */
+};
+
+MODULE_DEVICE_TABLE (usb, ipaq_id_table);
+
+static struct usb_driver ipaq_driver = {
+	.owner =	THIS_MODULE,
+	.name =		"ipaq",
+	.probe =	usb_serial_probe,
+	.disconnect =	usb_serial_disconnect,
+	.id_table =	ipaq_id_table,
+};
+
+
+/* All of the device info needed for the Compaq iPAQ */
+static struct usb_serial_device_type ipaq_device = {
+	.owner =		THIS_MODULE,
+	.name =			"PocketPC PDA",
+	.id_table =		ipaq_id_table,
+	.num_interrupt_in =	NUM_DONT_CARE,
+	.num_bulk_in =		1,
+	.num_bulk_out =		1,
+	.num_ports =		1,
+	.open =			ipaq_open,
+	.close =		ipaq_close,
+	.attach =		ipaq_startup,
+	.shutdown =		ipaq_shutdown,
+	.write =		ipaq_write,
+	.write_room =		ipaq_write_room,
+	.chars_in_buffer =	ipaq_chars_in_buffer,
+	.read_bulk_callback =	ipaq_read_bulk_callback,
+	.write_bulk_callback =	ipaq_write_bulk_callback,
+};
+
+static spinlock_t	write_list_lock;
+static int		bytes_in;
+static int		bytes_out;
+
+static int ipaq_open(struct usb_serial_port *port, struct file *filp)
+{
+	struct usb_serial	*serial = port->serial;
+	struct ipaq_private	*priv;
+	struct ipaq_packet	*pkt;
+	int			i, result = 0;
+	int			retries = KP_RETRIES;
+
+	dbg("%s - port %d", __FUNCTION__, port->number);
+
+	bytes_in = 0;
+	bytes_out = 0;
+	priv = (struct ipaq_private *)kmalloc(sizeof(struct ipaq_private), GFP_KERNEL);
+	if (priv == NULL) {
+		err("%s - Out of memory", __FUNCTION__);
+		return -ENOMEM;
+	}
+	usb_set_serial_port_data(port, priv);
+	priv->active = 0;
+	priv->queue_len = 0;
+	priv->free_len = 0;
+	INIT_LIST_HEAD(&priv->queue);
+	INIT_LIST_HEAD(&priv->freelist);
+
+	for (i = 0; i < URBDATA_QUEUE_MAX / PACKET_SIZE; i++) {
+		pkt = kmalloc(sizeof(struct ipaq_packet), GFP_KERNEL);
+		if (pkt == NULL) {
+			goto enomem;
+		}
+		pkt->data = kmalloc(PACKET_SIZE, GFP_KERNEL);
+		if (pkt->data == NULL) {
+			kfree(pkt);
+			goto enomem;
+		}
+		pkt->len = 0;
+		pkt->written = 0;
+		INIT_LIST_HEAD(&pkt->list);
+		list_add(&pkt->list, &priv->freelist);
+		priv->free_len += PACKET_SIZE;
+	}
+
+	/*
+	 * Force low latency on. This will immediately push data to the line
+	 * discipline instead of queueing.
+	 */
+
+	port->tty->low_latency = 1;
+	port->tty->raw = 1;
+	port->tty->real_raw = 1;
+
+	/*
+	 * Lose the small buffers usbserial provides. Make larger ones.
+	 */
+
+	kfree(port->bulk_in_buffer);
+	kfree(port->bulk_out_buffer);
+	port->bulk_in_buffer = kmalloc(URBDATA_SIZE, GFP_KERNEL);
+	if (port->bulk_in_buffer == NULL) {
+		goto enomem;
+	}
+	port->bulk_out_buffer = kmalloc(URBDATA_SIZE, GFP_KERNEL);
+	if (port->bulk_out_buffer == NULL) {
+		kfree(port->bulk_in_buffer);
+		goto enomem;
+	}
+	port->read_urb->transfer_buffer = port->bulk_in_buffer;
+	port->write_urb->transfer_buffer = port->bulk_out_buffer;
+	port->read_urb->transfer_buffer_length = URBDATA_SIZE;
+	port->bulk_out_size = port->write_urb->transfer_buffer_length = URBDATA_SIZE;
+	
+	/* Start reading from the device */
+	usb_fill_bulk_urb(port->read_urb, serial->dev, 
+		      usb_rcvbulkpipe(serial->dev, port->bulk_in_endpointAddress),
+		      port->read_urb->transfer_buffer, port->read_urb->transfer_buffer_length,
+		      ipaq_read_bulk_callback, port);
+	result = usb_submit_urb(port->read_urb, GFP_KERNEL);
+	if (result) {
+		err("%s - failed submitting read urb, error %d", __FUNCTION__, result);
+		goto error;
+	}
+
+	/*
+	 * Send out control message observed in win98 sniffs. Not sure what
+	 * it does, but from empirical observations, it seems that the device
+	 * will start the chat sequence once one of these messages gets
+	 * through. Since this has a reasonably high failure rate, we retry
+	 * several times.
+	 */
+
+	while (retries--) {
+		result = usb_control_msg(serial->dev,
+				usb_sndctrlpipe(serial->dev, 0), 0x22, 0x21,
+				0x1, 0, NULL, 0, 100);
+		if (result == 0) {
+			return 0;
+		}
+	}
+	err("%s - failed doing control urb, error %d", __FUNCTION__, result);
+	goto error;
+
+enomem:
+	result = -ENOMEM;
+	err("%s - Out of memory", __FUNCTION__);
+error:
+	ipaq_destroy_lists(port);
+	kfree(priv);
+	return result;
+}
+
+
+static void ipaq_close(struct usb_serial_port *port, struct file *filp)
+{
+	struct ipaq_private	*priv = usb_get_serial_port_data(port);
+
+	dbg("%s - port %d", __FUNCTION__, port->number);
+			 
+	/*
+	 * shut down bulk read and write
+	 */
+	usb_kill_urb(port->write_urb);
+	usb_kill_urb(port->read_urb);
+	ipaq_destroy_lists(port);
+	kfree(priv);
+	usb_set_serial_port_data(port, NULL);
+
+	/* Uncomment the following line if you want to see some statistics in your syslog */
+	/* info ("Bytes In = %d  Bytes Out = %d", bytes_in, bytes_out); */
+}
+
+static void ipaq_read_bulk_callback(struct urb *urb, struct pt_regs *regs)
+{
+	struct usb_serial_port	*port = (struct usb_serial_port *)urb->context;
+	struct tty_struct	*tty;
+	unsigned char		*data = urb->transfer_buffer;
+	int			i, result;
+
+	dbg("%s - port %d", __FUNCTION__, port->number);
+
+	if (urb->status) {
+		dbg("%s - nonzero read bulk status received: %d", __FUNCTION__, urb->status);
+		return;
+	}
+
+	usb_serial_debug_data(debug, &port->dev, __FUNCTION__, urb->actual_length, data);
+
+	tty = port->tty;
+	if (tty && urb->actual_length) {
+		for (i = 0; i < urb->actual_length ; ++i) {
+			/* if we insert more than TTY_FLIPBUF_SIZE characters, we drop them. */
+			if(tty->flip.count >= TTY_FLIPBUF_SIZE) {
+				tty_flip_buffer_push(tty);
+			}
+			/* this doesn't actually push the data through unless tty->low_latency is set */
+			tty_insert_flip_char(tty, data[i], 0);
+		}
+		tty_flip_buffer_push(tty);
+		bytes_in += urb->actual_length;
+	}
+
+	/* Continue trying to always read  */
+	usb_fill_bulk_urb(port->read_urb, port->serial->dev, 
+		      usb_rcvbulkpipe(port->serial->dev, port->bulk_in_endpointAddress),
+		      port->read_urb->transfer_buffer, port->read_urb->transfer_buffer_length,
+		      ipaq_read_bulk_callback, port);
+	result = usb_submit_urb(port->read_urb, GFP_ATOMIC);
+	if (result)
+		err("%s - failed resubmitting read urb, error %d", __FUNCTION__, result);
+	return;
+}
+
+static int ipaq_write(struct usb_serial_port *port, const unsigned char *buf,
+		       int count)
+{
+	const unsigned char	*current_position = buf;
+	int			bytes_sent = 0;
+	int			transfer_size;
+
+	dbg("%s - port %d", __FUNCTION__, port->number);
+
+	while (count > 0) {
+		transfer_size = min(count, PACKET_SIZE);
+		if (ipaq_write_bulk(port, current_position, transfer_size)) {
+			break;
+		}
+		current_position += transfer_size;
+		bytes_sent += transfer_size;
+		count -= transfer_size;
+		bytes_out += transfer_size;
+	}
+
+	return bytes_sent;
+} 
+
+static int ipaq_write_bulk(struct usb_serial_port *port, const unsigned char *buf,
+			   int count)
+{
+	struct ipaq_private	*priv = usb_get_serial_port_data(port);
+	struct ipaq_packet	*pkt = NULL;
+	int			result = 0;
+	unsigned long		flags;
+
+	if (priv->free_len <= 0) {
+		dbg("%s - we're stuffed", __FUNCTION__);
+		return -EAGAIN;
+	}
+
+	spin_lock_irqsave(&write_list_lock, flags);
+	if (!list_empty(&priv->freelist)) {
+		pkt = list_entry(priv->freelist.next, struct ipaq_packet, list);
+		list_del(&pkt->list);
+		priv->free_len -= PACKET_SIZE;
+	}
+	spin_unlock_irqrestore(&write_list_lock, flags);
+	if (pkt == NULL) {
+		dbg("%s - we're stuffed", __FUNCTION__);
+		return -EAGAIN;
+	}
+
+	memcpy(pkt->data, buf, count);
+	usb_serial_debug_data(debug, &port->dev, __FUNCTION__, count, pkt->data);
+
+	pkt->len = count;
+	pkt->written = 0;
+	spin_lock_irqsave(&write_list_lock, flags);
+	list_add_tail(&pkt->list, &priv->queue);
+	priv->queue_len += count;
+	if (priv->active == 0) {
+		priv->active = 1;
+		ipaq_write_gather(port);
+		spin_unlock_irqrestore(&write_list_lock, flags);
+		result = usb_submit_urb(port->write_urb, GFP_ATOMIC);
+		if (result) {
+			err("%s - failed submitting write urb, error %d", __FUNCTION__, result);
+		}
+	} else {
+		spin_unlock_irqrestore(&write_list_lock, flags);
+	}
+	return result;
+}
+
+static void ipaq_write_gather(struct usb_serial_port *port)
+{
+	struct ipaq_private	*priv = usb_get_serial_port_data(port);
+	struct usb_serial	*serial = port->serial;
+	int			count, room;
+	struct ipaq_packet	*pkt, *tmp;
+	struct urb		*urb = port->write_urb;
+
+	if (urb->status == -EINPROGRESS) {
+		/* Should never happen */
+		err("%s - flushing while urb is active !", __FUNCTION__);
+		return;
+	}
+	room = URBDATA_SIZE;
+	list_for_each_entry_safe(pkt, tmp, &priv->queue, list) {
+		count = min(room, (int)(pkt->len - pkt->written));
+		memcpy(urb->transfer_buffer + (URBDATA_SIZE - room),
+		       pkt->data + pkt->written, count);
+		room -= count;
+		pkt->written += count;
+		priv->queue_len -= count;
+		if (pkt->written == pkt->len) {
+			list_move(&pkt->list, &priv->freelist);
+			priv->free_len += PACKET_SIZE;
+		}
+		if (room == 0) {
+			break;
+		}
+	}
+
+	count = URBDATA_SIZE - room;
+	usb_fill_bulk_urb(port->write_urb, serial->dev, 
+		      usb_sndbulkpipe(serial->dev, port->bulk_out_endpointAddress),
+		      port->write_urb->transfer_buffer, count, ipaq_write_bulk_callback,
+		      port);
+	return;
+}
+
+static void ipaq_write_bulk_callback(struct urb *urb, struct pt_regs *regs)
+{
+	struct usb_serial_port	*port = (struct usb_serial_port *)urb->context;
+	struct ipaq_private	*priv = usb_get_serial_port_data(port);
+	unsigned long		flags;
+	int			result;
+
+	dbg("%s - port %d", __FUNCTION__, port->number);
+	
+	if (urb->status) {
+		dbg("%s - nonzero write bulk status received: %d", __FUNCTION__, urb->status);
+	}
+
+	spin_lock_irqsave(&write_list_lock, flags);
+	if (!list_empty(&priv->queue)) {
+		ipaq_write_gather(port);
+		spin_unlock_irqrestore(&write_list_lock, flags);
+		result = usb_submit_urb(port->write_urb, GFP_ATOMIC);
+		if (result) {
+			err("%s - failed submitting write urb, error %d", __FUNCTION__, result);
+		}
+	} else {
+		priv->active = 0;
+		spin_unlock_irqrestore(&write_list_lock, flags);
+	}
+
+	schedule_work(&port->work);
+}
+
+static int ipaq_write_room(struct usb_serial_port *port)
+{
+	struct ipaq_private	*priv = usb_get_serial_port_data(port);
+
+	dbg("%s - freelen %d", __FUNCTION__, priv->free_len);
+	return priv->free_len;
+}
+
+static int ipaq_chars_in_buffer(struct usb_serial_port *port)
+{
+	struct ipaq_private	*priv = usb_get_serial_port_data(port);
+
+	dbg("%s - queuelen %d", __FUNCTION__, priv->queue_len);
+	return priv->queue_len;
+}
+
+static void ipaq_destroy_lists(struct usb_serial_port *port)
+{
+	struct ipaq_private	*priv = usb_get_serial_port_data(port);
+	struct ipaq_packet	*pkt, *tmp;
+
+	list_for_each_entry_safe(pkt, tmp, &priv->queue, list) {
+		kfree(pkt->data);
+		kfree(pkt);
+	}
+	list_for_each_entry_safe(pkt, tmp, &priv->freelist, list) {
+		kfree(pkt->data);
+		kfree(pkt);
+	}
+}
+
+
+static int ipaq_startup(struct usb_serial *serial)
+{
+	dbg("%s", __FUNCTION__);
+	if (serial->dev->actconfig->desc.bConfigurationValue != 1) {
+		err("active config #%d != 1 ??",
+			serial->dev->actconfig->desc.bConfigurationValue);
+		return -ENODEV;
+	}
+	return usb_reset_configuration (serial->dev);
+}
+
+static void ipaq_shutdown(struct usb_serial *serial)
+{
+	dbg("%s", __FUNCTION__);
+}
+
+static int __init ipaq_init(void)
+{
+	int retval;
+	spin_lock_init(&write_list_lock);
+	retval = usb_serial_register(&ipaq_device);
+	if (retval) 
+		goto failed_usb_serial_register;
+	info(DRIVER_DESC " " DRIVER_VERSION);
+	if (vendor) {
+		ipaq_id_table[0].idVendor = vendor;
+		ipaq_id_table[0].idProduct = product;
+	}
+	retval = usb_register(&ipaq_driver);
+	if (retval)
+		goto failed_usb_register;
+		  
+	return 0;
+failed_usb_register:
+	usb_serial_deregister(&ipaq_device);
+failed_usb_serial_register:
+	return retval;
+}
+
+
+static void __exit ipaq_exit(void)
+{
+	usb_deregister(&ipaq_driver);
+	usb_serial_deregister(&ipaq_device);
+}
+
+
+module_init(ipaq_init);
+module_exit(ipaq_exit);
+
+MODULE_AUTHOR( DRIVER_AUTHOR );
+MODULE_DESCRIPTION( DRIVER_DESC );
+MODULE_LICENSE("GPL");
+
+module_param(debug, bool, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(debug, "Debug enabled or not");
+
+module_param(vendor, ushort, 0);
+MODULE_PARM_DESC(vendor, "User specified USB idVendor");
+
+module_param(product, ushort, 0);
+MODULE_PARM_DESC(product, "User specified USB idProduct");
