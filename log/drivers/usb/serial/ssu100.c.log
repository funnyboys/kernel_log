commit ee08cefbb5bd261676c6e7965dffd8ee2ad5e1e8
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Sep 12 07:26:07 2018 -0400

    ssu100: switch to ->get_serial()
    
    Reviewed-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/usb/serial/ssu100.c b/drivers/usb/serial/ssu100.c
index 0900b47b5f57..f6aea9f1be1a 100644
--- a/drivers/usb/serial/ssu100.c
+++ b/drivers/usb/serial/ssu100.c
@@ -331,39 +331,19 @@ static int ssu100_open(struct tty_struct *tty, struct usb_serial_port *port)
 	return usb_serial_generic_open(tty, port);
 }
 
-static int get_serial_info(struct usb_serial_port *port,
-			   struct serial_struct __user *retinfo)
-{
-	struct serial_struct tmp;
-
-	memset(&tmp, 0, sizeof(tmp));
-	tmp.line		= port->minor;
-	tmp.port		= 0;
-	tmp.irq			= 0;
-	tmp.xmit_fifo_size	= port->bulk_out_size;
-	tmp.baud_base		= 9600;
-	tmp.close_delay		= 5*HZ;
-	tmp.closing_wait	= 30*HZ;
-
-	if (copy_to_user(retinfo, &tmp, sizeof(*retinfo)))
-		return -EFAULT;
-	return 0;
-}
-
-static int ssu100_ioctl(struct tty_struct *tty,
-		    unsigned int cmd, unsigned long arg)
+static int get_serial_info(struct tty_struct *tty,
+			   struct serial_struct *ss)
 {
 	struct usb_serial_port *port = tty->driver_data;
 
-	switch (cmd) {
-	case TIOCGSERIAL:
-		return get_serial_info(port,
-				       (struct serial_struct __user *) arg);
-	default:
-		break;
-	}
-
-	return -ENOIOCTLCMD;
+	ss->line		= port->minor;
+	ss->port		= 0;
+	ss->irq			= 0;
+	ss->xmit_fifo_size	= port->bulk_out_size;
+	ss->baud_base		= 9600;
+	ss->close_delay		= 5*HZ;
+	ss->closing_wait	= 30*HZ;
+	return 0;
 }
 
 static int ssu100_attach(struct usb_serial *serial)
@@ -566,7 +546,7 @@ static struct usb_serial_driver ssu100_device = {
 	.tiocmset            = ssu100_tiocmset,
 	.tiocmiwait          = usb_serial_generic_tiocmiwait,
 	.get_icount	     = usb_serial_generic_get_icount,
-	.ioctl               = ssu100_ioctl,
+	.get_serial          = get_serial_info,
 	.set_termios         = ssu100_set_termios,
 };
 

commit 3391ca1dcd70a8e958984f7e95f242d36f0b9ab8
Author: Chengguang Xu <cgxu519@gmx.com>
Date:   Mon Jun 25 15:35:18 2018 +0800

    USB: serial: cast sizeof() to int when comparing with error code
    
    Negative error code will be larger than sizeof().
    
    Note that none of these bugs prevent errors from being detected, even if
    the ir-usb one would cause a less precise debug message to printed.
    
    Signed-off-by: Chengguang Xu <cgxu519@gmx.com>
    [ johan: add comment about implications ]
    Signed-off-by: Johan Hovold <johan@kernel.org>

diff --git a/drivers/usb/serial/ssu100.c b/drivers/usb/serial/ssu100.c
index 2083c267787b..0900b47b5f57 100644
--- a/drivers/usb/serial/ssu100.c
+++ b/drivers/usb/serial/ssu100.c
@@ -104,7 +104,7 @@ static inline int ssu100_getregister(struct usb_device *dev,
 	ret = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),
 			      QT_SET_GET_REGISTER, 0xc0, reg,
 			      uart, data, sizeof(*data), 300);
-	if (ret < sizeof(*data)) {
+	if (ret < (int)sizeof(*data)) {
 		if (ret >= 0)
 			ret = -EIO;
 	}

commit 627cfa89b1fe8d189ee71718fe9eb607026db301
Author: Johan Hovold <johan@kernel.org>
Date:   Fri Nov 3 18:12:08 2017 +0100

    USB: serial: fix module-license macros
    
    Several GPL-2.0 drivers used "GPL" rather than "GPL v2" in their
    MODULE_LICENSE macros; fix the macros to match the licenses.
    
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/ssu100.c b/drivers/usb/serial/ssu100.c
index a7db9aff97a1..2083c267787b 100644
--- a/drivers/usb/serial/ssu100.c
+++ b/drivers/usb/serial/ssu100.c
@@ -577,4 +577,4 @@ static struct usb_serial_driver * const serial_drivers[] = {
 module_usb_serial_driver(serial_drivers, id_table);
 
 MODULE_DESCRIPTION(DRIVER_DESC);
-MODULE_LICENSE("GPL");
+MODULE_LICENSE("GPL v2");

commit 5fd54ace4721fc5ce2bb5aef6318fcf17f421460
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Nov 3 11:28:30 2017 +0100

    USB: add SPDX identifiers to all remaining files in drivers/usb/
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/usb/ and include/linux/usb* files with the correct
    SPDX license identifier based on the license text in the file itself.
    The SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Acked-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/ssu100.c b/drivers/usb/serial/ssu100.c
index 5aa7bbbeba3d..a7db9aff97a1 100644
--- a/drivers/usb/serial/ssu100.c
+++ b/drivers/usb/serial/ssu100.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * usb-serial driver for Quatech SSU-100
  *

commit 51211a3d9b59b5c00f81512c2a16d9f3f607c0d9
Author: Johan Hovold <johan@kernel.org>
Date:   Wed Jan 25 18:22:54 2017 +0100

    USB: serial: drop unused ASYNC flags
    
    Do not report ASYNC_SKIP_TEST or ASYNC_AUTO_IRQ as being set in
    TIOCGSERIAL handlers as these flags are not supported and do not really
    make any sense for USB serial devices in the first place.
    
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Johan Hovold <johan@kernel.org>

diff --git a/drivers/usb/serial/ssu100.c b/drivers/usb/serial/ssu100.c
index 55814538ff1f..5aa7bbbeba3d 100644
--- a/drivers/usb/serial/ssu100.c
+++ b/drivers/usb/serial/ssu100.c
@@ -339,7 +339,6 @@ static int get_serial_info(struct usb_serial_port *port,
 	tmp.line		= port->minor;
 	tmp.port		= 0;
 	tmp.irq			= 0;
-	tmp.flags		= ASYNC_SKIP_TEST | ASYNC_AUTO_IRQ;
 	tmp.xmit_fifo_size	= port->bulk_out_size;
 	tmp.baud_base		= 9600;
 	tmp.close_delay		= 5*HZ;

commit 1eac5c244f705182d1552a53e2f74e2775ed95d6
Author: Johan Hovold <johan@kernel.org>
Date:   Thu Jan 12 14:56:22 2017 +0100

    USB: serial: ssu100: fix control-message error handling
    
    Make sure to detect short control-message transfers rather than continue
    with zero-initialised data when retrieving modem status and during
    device initialisation.
    
    Fixes: 52af95459939 ("USB: add USB serial ssu100 driver")
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Johan Hovold <johan@kernel.org>

diff --git a/drivers/usb/serial/ssu100.c b/drivers/usb/serial/ssu100.c
index 2a156144c76c..55814538ff1f 100644
--- a/drivers/usb/serial/ssu100.c
+++ b/drivers/usb/serial/ssu100.c
@@ -80,9 +80,17 @@ static inline int ssu100_setdevice(struct usb_device *dev, u8 *data)
 
 static inline int ssu100_getdevice(struct usb_device *dev, u8 *data)
 {
-	return usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),
-			       QT_SET_GET_DEVICE, 0xc0, 0, 0,
-			       data, 3, 300);
+	int ret;
+
+	ret = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),
+			      QT_SET_GET_DEVICE, 0xc0, 0, 0,
+			      data, 3, 300);
+	if (ret < 3) {
+		if (ret >= 0)
+			ret = -EIO;
+	}
+
+	return ret;
 }
 
 static inline int ssu100_getregister(struct usb_device *dev,
@@ -90,10 +98,17 @@ static inline int ssu100_getregister(struct usb_device *dev,
 				     unsigned short reg,
 				     u8 *data)
 {
-	return usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),
-			       QT_SET_GET_REGISTER, 0xc0, reg,
-			       uart, data, sizeof(*data), 300);
+	int ret;
+
+	ret = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),
+			      QT_SET_GET_REGISTER, 0xc0, reg,
+			      uart, data, sizeof(*data), 300);
+	if (ret < sizeof(*data)) {
+		if (ret >= 0)
+			ret = -EIO;
+	}
 
+	return ret;
 }
 
 
@@ -289,8 +304,10 @@ static int ssu100_open(struct tty_struct *tty, struct usb_serial_port *port)
 				 QT_OPEN_CLOSE_CHANNEL,
 				 QT_TRANSFER_IN, 0x01,
 				 0, data, 2, 300);
-	if (result < 0) {
+	if (result < 2) {
 		dev_dbg(&port->dev, "%s - open failed %i\n", __func__, result);
+		if (result >= 0)
+			result = -EIO;
 		kfree(data);
 		return result;
 	}

commit 2fbd69c4e33360383907cf0abb245440e62a6f37
Author: Johan Hovold <johan@kernel.org>
Date:   Tue Nov 8 13:26:50 2016 +0100

    USB: serial: fix invalid user-pointer checks
    
    Drop invalid user-pointer checks from ioctl handlers.
    
    A NULL-pointer can be valid in user space and copy_to_user() takes care
    of sanity checking.
    
    Signed-off-by: Johan Hovold <johan@kernel.org>

diff --git a/drivers/usb/serial/ssu100.c b/drivers/usb/serial/ssu100.c
index 70a098de429f..2a156144c76c 100644
--- a/drivers/usb/serial/ssu100.c
+++ b/drivers/usb/serial/ssu100.c
@@ -318,9 +318,6 @@ static int get_serial_info(struct usb_serial_port *port,
 {
 	struct serial_struct tmp;
 
-	if (!retinfo)
-		return -EFAULT;
-
 	memset(&tmp, 0, sizeof(tmp));
 	tmp.line		= port->minor;
 	tmp.port		= 0;

commit 75bcbf29c284dd0154c3e895a0bd1ef0e796160e
Author: Johan Hovold <johan@kernel.org>
Date:   Tue Nov 18 11:25:21 2014 +0100

    USB: ssu100: fix overrun-error reporting
    
    Fix reporting of overrun errors, which should only be reported once
    using the inserted null character.
    
    Fixes: 6b8f1ca5581b ("USB: ssu100: set tty_flags in ssu100_process_packet")
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Johan Hovold <johan@kernel.org>

diff --git a/drivers/usb/serial/ssu100.c b/drivers/usb/serial/ssu100.c
index a7fe664b6b7d..70a098de429f 100644
--- a/drivers/usb/serial/ssu100.c
+++ b/drivers/usb/serial/ssu100.c
@@ -490,10 +490,9 @@ static void ssu100_update_lsr(struct usb_serial_port *port, u8 lsr,
 			if (*tty_flag == TTY_NORMAL)
 				*tty_flag = TTY_FRAME;
 		}
-		if (lsr & UART_LSR_OE){
+		if (lsr & UART_LSR_OE) {
 			port->icount.overrun++;
-			if (*tty_flag == TTY_NORMAL)
-				*tty_flag = TTY_OVERRUN;
+			tty_insert_flip_char(&port->port, 0, TTY_OVERRUN);
 		}
 	}
 
@@ -511,12 +510,8 @@ static void ssu100_process_read_urb(struct urb *urb)
 	if ((len >= 4) &&
 	    (packet[0] == 0x1b) && (packet[1] == 0x1b) &&
 	    ((packet[2] == 0x00) || (packet[2] == 0x01))) {
-		if (packet[2] == 0x00) {
+		if (packet[2] == 0x00)
 			ssu100_update_lsr(port, packet[3], &flag);
-			if (flag == TTY_OVERRUN)
-				tty_insert_flip_char(&port->port, 0,
-						TTY_OVERRUN);
-		}
 		if (packet[2] == 0x01)
 			ssu100_update_msr(port, packet[3]);
 

commit 803a536243b3a1ed2289f41897b11b72bd083309
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Wed Jan 8 11:08:26 2014 -0500

    usb: delete non-required instances of include <linux/init.h>
    
    None of these files are actually using any __init type directives
    and hence don't need to include <linux/init.h>.  Most are just a
    left over from __devinit and __cpuinit removal, or simply due to
    code getting copied from one driver to the next.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/ssu100.c b/drivers/usb/serial/ssu100.c
index a6fec959d2f8..a7fe664b6b7d 100644
--- a/drivers/usb/serial/ssu100.c
+++ b/drivers/usb/serial/ssu100.c
@@ -6,7 +6,6 @@
  */
 
 #include <linux/errno.h>
-#include <linux/init.h>
 #include <linux/slab.h>
 #include <linux/tty.h>
 #include <linux/tty_driver.h>

commit 4d5147ec90531d11e7677e2c38941fc18e160641
Author: Johan Hovold <jhovold@gmail.com>
Date:   Sun Dec 29 19:22:55 2013 +0100

    USB: serial: clean up ioctl debugging
    
    Remove redundant ioctl debugging from subdrivers. The ioctl request code
    has already been logged by usb-serial core.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/ssu100.c b/drivers/usb/serial/ssu100.c
index e5750be49054..a6fec959d2f8 100644
--- a/drivers/usb/serial/ssu100.c
+++ b/drivers/usb/serial/ssu100.c
@@ -342,8 +342,6 @@ static int ssu100_ioctl(struct tty_struct *tty,
 {
 	struct usb_serial_port *port = tty->driver_data;
 
-	dev_dbg(&port->dev, "%s cmd 0x%04x\n", __func__, cmd);
-
 	switch (cmd) {
 	case TIOCGSERIAL:
 		return get_serial_info(port,
@@ -352,8 +350,6 @@ static int ssu100_ioctl(struct tty_struct *tty,
 		break;
 	}
 
-	dev_dbg(&port->dev, "%s arg not supported\n", __func__);
-
 	return -ENOIOCTLCMD;
 }
 

commit e5b1e2062e0535e8ffef79bb34d857e21380d101
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Jun 7 11:04:28 2013 -0700

    USB: serial: make minor allocation dynamic
    
    This moves the allocation of minor device numbers from a static array to
    be dynamic, using the idr interface.  This means that you could
    potentially get "gaps" in a minor number range for a single USB serial
    device with multiple ports, but all should still work properly.
    
    We remove the 'minor' field from the usb_serial structure, as it no
    longer makes any sense for it (use the field in the usb_serial_port
    structure if you really want to know this number), and take the fact
    that we were overloading a number in this field to determine if we had
    initialized the minor numbers or not, and just use a flag variable
    instead.
    
    Note, we still have the limitation of 255 USB to serial devices in the
    system, as that is all we are registering with the TTY layer at this
    point in time.
    
    Tested-by: Tobias Winter <tobias@linuxdingsda.de>
    Reviewed-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/ssu100.c b/drivers/usb/serial/ssu100.c
index 5b62dbbdf996..e5750be49054 100644
--- a/drivers/usb/serial/ssu100.c
+++ b/drivers/usb/serial/ssu100.c
@@ -323,7 +323,7 @@ static int get_serial_info(struct usb_serial_port *port,
 		return -EFAULT;
 
 	memset(&tmp, 0, sizeof(tmp));
-	tmp.line		= port->serial->minor;
+	tmp.line		= port->minor;
 	tmp.port		= 0;
 	tmp.irq			= 0;
 	tmp.flags		= ASYNC_SKIP_TEST | ASYNC_AUTO_IRQ;

commit c24c838e8effd55ba330d1966d9846400af4bec8
Author: Johan Hovold <jhovold@gmail.com>
Date:   Thu Mar 21 12:37:32 2013 +0100

    USB: ssu100: switch to generic TIOCMIWAIT implementation
    
    Switch to the generic TIOCMIWAIT implementation.
    
    This also fixes the issue with processes waiting for
    modem-status-changes not being woken up at disconnect.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/ssu100.c b/drivers/usb/serial/ssu100.c
index 8d94a5a7c4b6..5b62dbbdf996 100644
--- a/drivers/usb/serial/ssu100.c
+++ b/drivers/usb/serial/ssu100.c
@@ -337,49 +337,6 @@ static int get_serial_info(struct usb_serial_port *port,
 	return 0;
 }
 
-static int wait_modem_info(struct usb_serial_port *port, unsigned int arg)
-{
-	struct ssu100_port_private *priv = usb_get_serial_port_data(port);
-	struct async_icount prev, cur;
-	unsigned long flags;
-
-	spin_lock_irqsave(&priv->status_lock, flags);
-	prev = port->icount;
-	spin_unlock_irqrestore(&priv->status_lock, flags);
-
-	while (1) {
-		wait_event_interruptible(port->delta_msr_wait,
-					 (port->serial->disconnected ||
-					  (port->icount.rng != prev.rng) ||
-					  (port->icount.dsr != prev.dsr) ||
-					  (port->icount.dcd != prev.dcd) ||
-					  (port->icount.cts != prev.cts)));
-
-		if (signal_pending(current))
-			return -ERESTARTSYS;
-
-		if (port->serial->disconnected)
-			return -EIO;
-
-		spin_lock_irqsave(&priv->status_lock, flags);
-		cur = port->icount;
-		spin_unlock_irqrestore(&priv->status_lock, flags);
-
-		if ((prev.rng == cur.rng) &&
-		    (prev.dsr == cur.dsr) &&
-		    (prev.dcd == cur.dcd) &&
-		    (prev.cts == cur.cts))
-			return -EIO;
-
-		if ((arg & TIOCM_RNG && (prev.rng != cur.rng)) ||
-		    (arg & TIOCM_DSR && (prev.dsr != cur.dsr)) ||
-		    (arg & TIOCM_CD  && (prev.dcd != cur.dcd)) ||
-		    (arg & TIOCM_CTS && (prev.cts != cur.cts)))
-			return 0;
-	}
-	return 0;
-}
-
 static int ssu100_ioctl(struct tty_struct *tty,
 		    unsigned int cmd, unsigned long arg)
 {
@@ -391,10 +348,6 @@ static int ssu100_ioctl(struct tty_struct *tty,
 	case TIOCGSERIAL:
 		return get_serial_info(port,
 				       (struct serial_struct __user *) arg);
-
-	case TIOCMIWAIT:
-		return wait_modem_info(port, arg);
-
 	default:
 		break;
 	}
@@ -509,7 +462,7 @@ static void ssu100_update_msr(struct usb_serial_port *port, u8 msr)
 			port->icount.dcd++;
 		if (msr & UART_MSR_TERI)
 			port->icount.rng++;
-		wake_up_interruptible(&port->delta_msr_wait);
+		wake_up_interruptible(&port->port.delta_msr_wait);
 	}
 }
 
@@ -607,6 +560,7 @@ static struct usb_serial_driver ssu100_device = {
 	.process_read_urb    = ssu100_process_read_urb,
 	.tiocmget            = ssu100_tiocmget,
 	.tiocmset            = ssu100_tiocmset,
+	.tiocmiwait          = usb_serial_generic_tiocmiwait,
 	.get_icount	     = usb_serial_generic_get_icount,
 	.ioctl               = ssu100_ioctl,
 	.set_termios         = ssu100_set_termios,

commit 31ecdb6befeab20d93b49b8dd640c081b48912d0
Author: Johan Hovold <jhovold@gmail.com>
Date:   Thu Mar 21 12:37:31 2013 +0100

    USB: ssu100: switch to generic get_icount implementation
    
    Switch to the generic get_icount implementation.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/ssu100.c b/drivers/usb/serial/ssu100.c
index 45b8c29060d1..8d94a5a7c4b6 100644
--- a/drivers/usb/serial/ssu100.c
+++ b/drivers/usb/serial/ssu100.c
@@ -61,7 +61,6 @@ struct ssu100_port_private {
 	spinlock_t status_lock;
 	u8 shadowLSR;
 	u8 shadowMSR;
-	struct async_icount icount;
 };
 
 static inline int ssu100_control_msg(struct usb_device *dev,
@@ -345,16 +344,16 @@ static int wait_modem_info(struct usb_serial_port *port, unsigned int arg)
 	unsigned long flags;
 
 	spin_lock_irqsave(&priv->status_lock, flags);
-	prev = priv->icount;
+	prev = port->icount;
 	spin_unlock_irqrestore(&priv->status_lock, flags);
 
 	while (1) {
 		wait_event_interruptible(port->delta_msr_wait,
 					 (port->serial->disconnected ||
-					  (priv->icount.rng != prev.rng) ||
-					  (priv->icount.dsr != prev.dsr) ||
-					  (priv->icount.dcd != prev.dcd) ||
-					  (priv->icount.cts != prev.cts)));
+					  (port->icount.rng != prev.rng) ||
+					  (port->icount.dsr != prev.dsr) ||
+					  (port->icount.dcd != prev.dcd) ||
+					  (port->icount.cts != prev.cts)));
 
 		if (signal_pending(current))
 			return -ERESTARTSYS;
@@ -363,7 +362,7 @@ static int wait_modem_info(struct usb_serial_port *port, unsigned int arg)
 			return -EIO;
 
 		spin_lock_irqsave(&priv->status_lock, flags);
-		cur = priv->icount;
+		cur = port->icount;
 		spin_unlock_irqrestore(&priv->status_lock, flags);
 
 		if ((prev.rng == cur.rng) &&
@@ -381,30 +380,6 @@ static int wait_modem_info(struct usb_serial_port *port, unsigned int arg)
 	return 0;
 }
 
-static int ssu100_get_icount(struct tty_struct *tty,
-			struct serial_icounter_struct *icount)
-{
-	struct usb_serial_port *port = tty->driver_data;
-	struct ssu100_port_private *priv = usb_get_serial_port_data(port);
-	struct async_icount cnow = priv->icount;
-
-	icount->cts = cnow.cts;
-	icount->dsr = cnow.dsr;
-	icount->rng = cnow.rng;
-	icount->dcd = cnow.dcd;
-	icount->rx = cnow.rx;
-	icount->tx = cnow.tx;
-	icount->frame = cnow.frame;
-	icount->overrun = cnow.overrun;
-	icount->parity = cnow.parity;
-	icount->brk = cnow.brk;
-	icount->buf_overrun = cnow.buf_overrun;
-
-	return 0;
-}
-
-
-
 static int ssu100_ioctl(struct tty_struct *tty,
 		    unsigned int cmd, unsigned long arg)
 {
@@ -527,13 +502,13 @@ static void ssu100_update_msr(struct usb_serial_port *port, u8 msr)
 	if (msr & UART_MSR_ANY_DELTA) {
 		/* update input line counters */
 		if (msr & UART_MSR_DCTS)
-			priv->icount.cts++;
+			port->icount.cts++;
 		if (msr & UART_MSR_DDSR)
-			priv->icount.dsr++;
+			port->icount.dsr++;
 		if (msr & UART_MSR_DDCD)
-			priv->icount.dcd++;
+			port->icount.dcd++;
 		if (msr & UART_MSR_TERI)
-			priv->icount.rng++;
+			port->icount.rng++;
 		wake_up_interruptible(&port->delta_msr_wait);
 	}
 }
@@ -553,22 +528,22 @@ static void ssu100_update_lsr(struct usb_serial_port *port, u8 lsr,
 		/* we always want to update icount, but we only want to
 		 * update tty_flag for one case */
 		if (lsr & UART_LSR_BI) {
-			priv->icount.brk++;
+			port->icount.brk++;
 			*tty_flag = TTY_BREAK;
 			usb_serial_handle_break(port);
 		}
 		if (lsr & UART_LSR_PE) {
-			priv->icount.parity++;
+			port->icount.parity++;
 			if (*tty_flag == TTY_NORMAL)
 				*tty_flag = TTY_PARITY;
 		}
 		if (lsr & UART_LSR_FE) {
-			priv->icount.frame++;
+			port->icount.frame++;
 			if (*tty_flag == TTY_NORMAL)
 				*tty_flag = TTY_FRAME;
 		}
 		if (lsr & UART_LSR_OE){
-			priv->icount.overrun++;
+			port->icount.overrun++;
 			if (*tty_flag == TTY_NORMAL)
 				*tty_flag = TTY_OVERRUN;
 		}
@@ -632,7 +607,7 @@ static struct usb_serial_driver ssu100_device = {
 	.process_read_urb    = ssu100_process_read_urb,
 	.tiocmget            = ssu100_tiocmget,
 	.tiocmset            = ssu100_tiocmset,
-	.get_icount	     = ssu100_get_icount,
+	.get_icount	     = usb_serial_generic_get_icount,
 	.ioctl               = ssu100_ioctl,
 	.set_termios         = ssu100_set_termios,
 };

commit 618e183d03a95da200bed48e5277efe428feef26
Author: Johan Hovold <jhovold@gmail.com>
Date:   Thu Mar 21 12:36:40 2013 +0100

    USB: ssu100: remove custom close operation
    
    The generic close operation will be used if the close field is left
    uninitialised.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/ssu100.c b/drivers/usb/serial/ssu100.c
index 97aca3fce883..45b8c29060d1 100644
--- a/drivers/usb/serial/ssu100.c
+++ b/drivers/usb/serial/ssu100.c
@@ -315,11 +315,6 @@ static int ssu100_open(struct tty_struct *tty, struct usb_serial_port *port)
 	return usb_serial_generic_open(tty, port);
 }
 
-static void ssu100_close(struct usb_serial_port *port)
-{
-	usb_serial_generic_close(port);
-}
-
 static int get_serial_info(struct usb_serial_port *port,
 			   struct serial_struct __user *retinfo)
 {
@@ -630,7 +625,6 @@ static struct usb_serial_driver ssu100_device = {
 	.id_table	     = id_table,
 	.num_ports	     = 1,
 	.open		     = ssu100_open,
-	.close		     = ssu100_close,
 	.attach              = ssu100_attach,
 	.port_probe          = ssu100_port_probe,
 	.port_remove         = ssu100_port_remove,

commit bf8773c6eacc9c3241455fdb7e82050ad2323a0a
Author: Johan Hovold <jhovold@gmail.com>
Date:   Thu Mar 21 12:36:39 2013 +0100

    USB: ssu100: remove explicit initialisation of disconnect
    
    The disconnect callback is set to the generic implementation by
    usb-serial core if NULL.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/ssu100.c b/drivers/usb/serial/ssu100.c
index 4b2a19757b4d..97aca3fce883 100644
--- a/drivers/usb/serial/ssu100.c
+++ b/drivers/usb/serial/ssu100.c
@@ -641,7 +641,6 @@ static struct usb_serial_driver ssu100_device = {
 	.get_icount	     = ssu100_get_icount,
 	.ioctl               = ssu100_ioctl,
 	.set_termios         = ssu100_set_termios,
-	.disconnect          = usb_serial_generic_disconnect,
 };
 
 static struct usb_serial_driver * const serial_drivers[] = {

commit 43a66b4c417ad15f6d2f632ce67ad195bdf999e8
Author: Johan Hovold <jhovold@gmail.com>
Date:   Tue Mar 19 09:21:25 2013 +0100

    USB: ssu100: fix use-after-free in TIOCMIWAIT
    
    Use the port wait queue and make sure to check the serial disconnected
    flag before accessing private port data after waking up.
    
    This is is needed as the private port data (including the wait queue
    itself) can be gone when waking up after a disconnect.
    
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/ssu100.c b/drivers/usb/serial/ssu100.c
index b57cf841c5b6..4b2a19757b4d 100644
--- a/drivers/usb/serial/ssu100.c
+++ b/drivers/usb/serial/ssu100.c
@@ -61,7 +61,6 @@ struct ssu100_port_private {
 	spinlock_t status_lock;
 	u8 shadowLSR;
 	u8 shadowMSR;
-	wait_queue_head_t delta_msr_wait; /* Used for TIOCMIWAIT */
 	struct async_icount icount;
 };
 
@@ -355,8 +354,9 @@ static int wait_modem_info(struct usb_serial_port *port, unsigned int arg)
 	spin_unlock_irqrestore(&priv->status_lock, flags);
 
 	while (1) {
-		wait_event_interruptible(priv->delta_msr_wait,
-					 ((priv->icount.rng != prev.rng) ||
+		wait_event_interruptible(port->delta_msr_wait,
+					 (port->serial->disconnected ||
+					  (priv->icount.rng != prev.rng) ||
 					  (priv->icount.dsr != prev.dsr) ||
 					  (priv->icount.dcd != prev.dcd) ||
 					  (priv->icount.cts != prev.cts)));
@@ -364,6 +364,9 @@ static int wait_modem_info(struct usb_serial_port *port, unsigned int arg)
 		if (signal_pending(current))
 			return -ERESTARTSYS;
 
+		if (port->serial->disconnected)
+			return -EIO;
+
 		spin_lock_irqsave(&priv->status_lock, flags);
 		cur = priv->icount;
 		spin_unlock_irqrestore(&priv->status_lock, flags);
@@ -445,7 +448,6 @@ static int ssu100_port_probe(struct usb_serial_port *port)
 		return -ENOMEM;
 
 	spin_lock_init(&priv->status_lock);
-	init_waitqueue_head(&priv->delta_msr_wait);
 
 	usb_set_serial_port_data(port, priv);
 
@@ -537,7 +539,7 @@ static void ssu100_update_msr(struct usb_serial_port *port, u8 msr)
 			priv->icount.dcd++;
 		if (msr & UART_MSR_TERI)
 			priv->icount.rng++;
-		wake_up_interruptible(&priv->delta_msr_wait);
+		wake_up_interruptible(&port->delta_msr_wait);
 	}
 }
 

commit 21eaab6d19ed43e82ed39c8deb7f192134fb4a0e
Merge: 74e1a2a39355 9e17df37d710
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Feb 21 13:41:04 2013 -0800

    Merge tag 'tty-3.9-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/tty
    
    Pull tty/serial patches from Greg Kroah-Hartman:
     "Here's the big tty/serial driver patches for 3.9-rc1.
    
      More tty port rework and fixes from Jiri here, as well as lots of
      individual serial driver updates and fixes.
    
      All of these have been in the linux-next tree for a while."
    
    * tag 'tty-3.9-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/tty: (140 commits)
      tty: mxser: improve error handling in mxser_probe() and mxser_module_init()
      serial: imx: fix uninitialized variable warning
      serial: tegra: assume CONFIG_OF
      TTY: do not update atime/mtime on read/write
      lguest: select CONFIG_TTY to build properly.
      ARM defconfigs: add missing inclusions of linux/platform_device.h
      fb/exynos: include platform_device.h
      ARM: sa1100/assabet: include platform_device.h directly
      serial: imx: Fix recursive locking bug
      pps: Fix build breakage from decoupling pps from tty
      tty: Remove ancient hardpps()
      pps: Additional cleanups in uart_handle_dcd_change
      pps: Move timestamp read into PPS code proper
      pps: Don't crash the machine when exiting will do
      pps: Fix a use-after free bug when unregistering a source.
      pps: Use pps_lookup_dev to reduce ldisc coupling
      pps: Add pps_lookup_dev() function
      tty: serial: uartlite: Support uartlite on big and little endian systems
      tty: serial: uartlite: Fix sparse and checkpatch warnings
      serial/arc-uart: Miscll DT related updates (Grant's review comments)
      ...
    
    Fix up trivial conflicts, mostly just due to the TTY config option
    clashing with the EXPERIMENTAL removal.

commit b2ca699076573c94fee9a73cb0d8645383b602a0
Author: Johan Hovold <jhovold@gmail.com>
Date:   Wed Feb 13 17:53:28 2013 +0100

    USB: serial: fix null-pointer dereferences on disconnect
    
    Make sure serial-driver dtr_rts is called with disc_mutex held after
    checking the disconnected flag.
    
    Due to a bug in the tty layer, dtr_rts may get called after a device has
    been disconnected and the tty-device unregistered. Some drivers have had
    individual checks for disconnect to make sure the disconnected interface
    was not accessed, but this should really be handled in usb-serial core
    (at least until the long-standing tty-bug has been fixed).
    
    Note that the problem has been made more acute with commit 0998d0631001
    ("device-core: Ensure drvdata = NULL when no driver is bound") as the
    port data is now also NULL when dtr_rts is called resulting in further
    oopses.
    
    Reported-by: Chris Ruehl <chris.ruehl@gtsys.com.hk>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/ssu100.c b/drivers/usb/serial/ssu100.c
index 4543ea350229..d938396171e8 100644
--- a/drivers/usb/serial/ssu100.c
+++ b/drivers/usb/serial/ssu100.c
@@ -506,19 +506,16 @@ static void ssu100_dtr_rts(struct usb_serial_port *port, int on)
 {
 	struct usb_device *dev = port->serial->dev;
 
-	mutex_lock(&port->serial->disc_mutex);
-	if (!port->serial->disconnected) {
-		/* Disable flow control */
-		if (!on &&
-		    ssu100_setregister(dev, 0, UART_MCR, 0) < 0)
+	/* Disable flow control */
+	if (!on) {
+		if (ssu100_setregister(dev, 0, UART_MCR, 0) < 0)
 			dev_err(&port->dev, "error from flowcontrol urb\n");
-		/* drop RTS and DTR */
-		if (on)
-			set_mctrl(dev, TIOCM_DTR | TIOCM_RTS);
-		else
-			clear_mctrl(dev, TIOCM_DTR | TIOCM_RTS);
 	}
-	mutex_unlock(&port->serial->disc_mutex);
+	/* drop RTS and DTR */
+	if (on)
+		set_mctrl(dev, TIOCM_DTR | TIOCM_RTS);
+	else
+		clear_mctrl(dev, TIOCM_DTR | TIOCM_RTS);
 }
 
 static void ssu100_update_msr(struct usb_serial_port *port, u8 msr)

commit 2e124b4a390ca85325fae75764bef92f0547fa25
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Thu Jan 3 15:53:06 2013 +0100

    TTY: switch tty_flip_buffer_push
    
    Now, we start converting tty buffer functions to actually use
    tty_port. This will allow us to get rid of the need of tty in many
    call sites. Only tty_port will needed and hence no more
    tty_port_tty_get in those paths.
    
    Now, the one where most of tty_port_tty_get gets removed:
    tty_flip_buffer_push.
    
    IOW we also closed all the races in drivers not using tty_port_tty_get
    at all yet.
    
    Also we move tty_flip_buffer_push declaration from include/linux/tty.h
    to include/linux/tty_flip.h to all others while we are changing it
    anyway.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/ssu100.c b/drivers/usb/serial/ssu100.c
index 38713156e957..58bc7e793524 100644
--- a/drivers/usb/serial/ssu100.c
+++ b/drivers/usb/serial/ssu100.c
@@ -582,7 +582,7 @@ static void ssu100_update_lsr(struct usb_serial_port *port, u8 lsr,
 
 }
 
-static int ssu100_process_packet(struct urb *urb)
+static void ssu100_process_read_urb(struct urb *urb)
 {
 	struct usb_serial_port *port = urb->context;
 	char *packet = (char *)urb->transfer_buffer;
@@ -609,7 +609,7 @@ static int ssu100_process_packet(struct urb *urb)
 		ch = packet;
 
 	if (!len)
-		return 0;	/* status only */
+		return;	/* status only */
 
 	if (port->port.console && port->sysrq) {
 		for (i = 0; i < len; i++, ch++) {
@@ -619,24 +619,7 @@ static int ssu100_process_packet(struct urb *urb)
 	} else
 		tty_insert_flip_string_fixed_flag(&port->port, ch, flag, len);
 
-	return len;
-}
-
-static void ssu100_process_read_urb(struct urb *urb)
-{
-	struct usb_serial_port *port = urb->context;
-	struct tty_struct *tty;
-	int count;
-
-	tty = tty_port_tty_get(&port->port);
-	if (!tty)
-		return;
-
-	count = ssu100_process_packet(urb);
-
-	if (count)
-		tty_flip_buffer_push(tty);
-	tty_kref_put(tty);
+	tty_flip_buffer_push(&port->port);
 }
 
 static struct usb_serial_driver ssu100_device = {

commit 92a19f9cec9a80ad93c06e115822deb729e2c6ad
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Thu Jan 3 15:53:03 2013 +0100

    TTY: switch tty_insert_flip_char
    
    Now, we start converting tty buffer functions to actually use
    tty_port. This will allow us to get rid of the need of tty in many
    call sites. Only tty_port will needed and hence no more
    tty_port_tty_get in those paths.
    
    tty_insert_flip_char is the next one to proceed. This one is used all
    over the code, so the patch is huge.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/ssu100.c b/drivers/usb/serial/ssu100.c
index 37476c6240c2..38713156e957 100644
--- a/drivers/usb/serial/ssu100.c
+++ b/drivers/usb/serial/ssu100.c
@@ -582,8 +582,7 @@ static void ssu100_update_lsr(struct usb_serial_port *port, u8 lsr,
 
 }
 
-static int ssu100_process_packet(struct urb *urb,
-				 struct tty_struct *tty)
+static int ssu100_process_packet(struct urb *urb)
 {
 	struct usb_serial_port *port = urb->context;
 	char *packet = (char *)urb->transfer_buffer;
@@ -598,7 +597,8 @@ static int ssu100_process_packet(struct urb *urb,
 		if (packet[2] == 0x00) {
 			ssu100_update_lsr(port, packet[3], &flag);
 			if (flag == TTY_OVERRUN)
-				tty_insert_flip_char(tty, 0, TTY_OVERRUN);
+				tty_insert_flip_char(&port->port, 0,
+						TTY_OVERRUN);
 		}
 		if (packet[2] == 0x01)
 			ssu100_update_msr(port, packet[3]);
@@ -614,7 +614,7 @@ static int ssu100_process_packet(struct urb *urb,
 	if (port->port.console && port->sysrq) {
 		for (i = 0; i < len; i++, ch++) {
 			if (!usb_serial_handle_sysrq_char(port, *ch))
-				tty_insert_flip_char(tty, *ch, flag);
+				tty_insert_flip_char(&port->port, *ch, flag);
 		}
 	} else
 		tty_insert_flip_string_fixed_flag(&port->port, ch, flag, len);
@@ -632,7 +632,7 @@ static void ssu100_process_read_urb(struct urb *urb)
 	if (!tty)
 		return;
 
-	count = ssu100_process_packet(urb, tty);
+	count = ssu100_process_packet(urb);
 
 	if (count)
 		tty_flip_buffer_push(tty);

commit 2f69335710884ae6112fc8196ebe29b5cda7b79b
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Thu Jan 3 15:53:02 2013 +0100

    TTY: convert more flipping functions
    
    Now, we start converting tty buffer functions to actually use
    tty_port. This will allow us to get rid of the need of tty pointer in
    many call sites. Only tty_port will be needed and hence no more
    tty_port_tty_get calls in those paths.
    
    Now 4 string flipping ones are on turn:
    * tty_insert_flip_string_flags
    * tty_insert_flip_string_fixed_flag
    * tty_prepare_flip_string
    * tty_prepare_flip_string_flags
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/ssu100.c b/drivers/usb/serial/ssu100.c
index 4543ea350229..37476c6240c2 100644
--- a/drivers/usb/serial/ssu100.c
+++ b/drivers/usb/serial/ssu100.c
@@ -617,7 +617,7 @@ static int ssu100_process_packet(struct urb *urb,
 				tty_insert_flip_char(tty, *ch, flag);
 		}
 	} else
-		tty_insert_flip_string_fixed_flag(tty, ch, flag, len);
+		tty_insert_flip_string_fixed_flag(&port->port, ch, flag, len);
 
 	return len;
 }

commit bcbec053d2197031d04b8e040c61695b5d7a949d
Author: Johan Hovold <jhovold@gmail.com>
Date:   Wed Oct 31 11:59:52 2012 +0100

    USB: serial: remove driver version information
    
    Remove all MODULE_VERSION macros and driver-version information (except
    for garmin_gps which uses it in a status reply).
    
    It is the kernel version that matters and not some private version
    scheme which rarely even gets updated.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/ssu100.c b/drivers/usb/serial/ssu100.c
index 868d1e6852e2..4543ea350229 100644
--- a/drivers/usb/serial/ssu100.c
+++ b/drivers/usb/serial/ssu100.c
@@ -46,8 +46,6 @@
 #define FULLPWRBIT          0x00000080
 #define NEXT_BOARD_POWER_BIT        0x00000004
 
-/* Version Information */
-#define DRIVER_VERSION "v0.1"
 #define DRIVER_DESC "Quatech SSU-100 USB to Serial Driver"
 
 #define	USB_VENDOR_ID_QUATECH	0x061d	/* Quatech VID */

commit 638b9e15233c9570bce65301aa9877235316b9f0
Author: Johan Hovold <jhovold@gmail.com>
Date:   Wed Oct 17 16:31:34 2012 +0200

    USB: ssu100: fix port-data memory leak
    
    Fix port-data memory leak by replacing attach and release with
    port_probe and port_remove.
    
    Since commit 0998d0631001288 (device-core: Ensure drvdata = NULL when no
    driver is bound) the port private data is no longer freed at release as
    it is no longer accessible.
    
    Compile-only tested.
    
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/ssu100.c b/drivers/usb/serial/ssu100.c
index 015810b3785b..868d1e6852e2 100644
--- a/drivers/usb/serial/ssu100.c
+++ b/drivers/usb/serial/ssu100.c
@@ -67,13 +67,6 @@ struct ssu100_port_private {
 	struct async_icount icount;
 };
 
-static void ssu100_release(struct usb_serial *serial)
-{
-	struct ssu100_port_private *priv = usb_get_serial_port_data(*serial->port);
-
-	kfree(priv);
-}
-
 static inline int ssu100_control_msg(struct usb_device *dev,
 				     u8 request, u16 data, u16 index)
 {
@@ -441,22 +434,34 @@ static int ssu100_ioctl(struct tty_struct *tty,
 }
 
 static int ssu100_attach(struct usb_serial *serial)
+{
+	return ssu100_initdevice(serial->dev);
+}
+
+static int ssu100_port_probe(struct usb_serial_port *port)
 {
 	struct ssu100_port_private *priv;
-	struct usb_serial_port *port = *serial->port;
 
 	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
-	if (!priv) {
-		dev_err(&port->dev, "%s- kmalloc(%Zd) failed.\n", __func__,
-			sizeof(*priv));
+	if (!priv)
 		return -ENOMEM;
-	}
 
 	spin_lock_init(&priv->status_lock);
 	init_waitqueue_head(&priv->delta_msr_wait);
+
 	usb_set_serial_port_data(port, priv);
 
-	return ssu100_initdevice(serial->dev);
+	return 0;
+}
+
+static int ssu100_port_remove(struct usb_serial_port *port)
+{
+	struct ssu100_port_private *priv;
+
+	priv = usb_get_serial_port_data(port);
+	kfree(priv);
+
+	return 0;
 }
 
 static int ssu100_tiocmget(struct tty_struct *tty)
@@ -647,7 +652,8 @@ static struct usb_serial_driver ssu100_device = {
 	.open		     = ssu100_open,
 	.close		     = ssu100_close,
 	.attach              = ssu100_attach,
-	.release             = ssu100_release,
+	.port_probe          = ssu100_port_probe,
+	.port_remove         = ssu100_port_remove,
 	.dtr_rts             = ssu100_dtr_rts,
 	.process_read_urb    = ssu100_process_read_urb,
 	.tiocmget            = ssu100_tiocmget,

commit d9a807461fc8cc0d6ba589ea0730d139122af012
Merge: 3498d13b8090 70c048a238c7
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Oct 1 13:23:01 2012 -0700

    Merge tag 'usb-3.6' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/usb
    
    Pull USB changes from Greg Kroah-Hartman:
     "Here is the big USB pull request for 3.7-rc1
    
      There are lots of gadget driver changes (including copying a bunch of
      files into the drivers/staging/ccg/ directory so that the other gadget
      drivers can be fixed up properly without breaking that driver), and we
      remove the old obsolete ub.c driver from the tree.
    
      There are also the usual XHCI set of updates, and other various driver
      changes and updates.  We also are trying hard to remove the old dbg()
      macro, but the final bits of that removal will be coming in through
      the networking tree before we can delete it for good.
    
      All of these patches have been in the linux-next tree.
    
      Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>"
    
    Fix up several annoying - but fairly mindless - conflicts due to the
    termios structure having moved into the tty device, and often clashing
    with dbg -> dev_dbg conversion.
    
    * tag 'usb-3.6' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/usb: (339 commits)
      USB: ezusb: move ezusb.c from drivers/usb/serial to drivers/usb/misc
      USB: uas: fix gcc warning
      USB: uas: fix locking
      USB: Fix race condition when removing host controllers
      USB: uas: add locking
      USB: uas: fix abort
      USB: uas: remove aborted field, replace with status bit.
      USB: uas: fix task management
      USB: uas: keep track of command urbs
      xhci: Intel Panther Point BEI quirk.
      powerpc/usb: remove checking PHY_CLK_VALID for UTMI PHY
      USB: ftdi_sio: add TIAO USB Multi-Protocol Adapter (TUMPA) support
      Revert "usb : Add sysfs files to control port power."
      USB: serial: remove vizzini driver
      usb: host: xhci: Fix Null pointer dereferencing with 71c731a for non-x86 systems
      Increase XHCI suspend timeout to 16ms
      USB: ohci-at91: fix null pointer in ohci_hcd_at91_overcurrent_irq
      USB: sierra_ms: don't keep unused variable
      fsl/usb: Add support for USB controller version 2.4
      USB: qcaux: add Pantech vendor class match
      ...

commit 186f3812f5005d3d5435f69f672971afdae3e732
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Sep 14 12:32:00 2012 -0700

    USB: serial: ssu100.c: remove debug module parameter
    
    Now that the dbg() macro is no longer being used in the driver,
    the debug module parameter doesn't do anything at all.  So remove
    it so as to not confuse people.
    
    CC: Alan Stern <stern@rowland.harvard.edu>
    CC: Rusty Russell <rusty@rustcorp.com.au>
    CC: Mauro Carvalho Chehab <mchehab@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/ssu100.c b/drivers/usb/serial/ssu100.c
index e719661899df..6635743bd8c2 100644
--- a/drivers/usb/serial/ssu100.c
+++ b/drivers/usb/serial/ssu100.c
@@ -46,8 +46,6 @@
 #define FULLPWRBIT          0x00000080
 #define NEXT_BOARD_POWER_BIT        0x00000004
 
-static bool debug;
-
 /* Version Information */
 #define DRIVER_VERSION "v0.1"
 #define DRIVER_DESC "Quatech SSU-100 USB to Serial Driver"
@@ -668,6 +666,3 @@ module_usb_serial_driver(serial_drivers, id_table);
 
 MODULE_DESCRIPTION(DRIVER_DESC);
 MODULE_LICENSE("GPL");
-
-module_param(debug, bool, S_IRUGO | S_IWUSR);
-MODULE_PARM_DESC(debug, "Debug enabled or not");

commit 4f0c64120041fc92a35cd1fe84562b7abcd7aeb7
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Sep 14 11:50:35 2012 -0700

    USB: serial: ssu100.c: remove dbg() usage
    
    dbg() was a very old USB-serial-specific macro.
    This patch removes it from being used in the
    driver and uses dev_dbg() instead.
    
    CC: Alan Stern <stern@rowland.harvard.edu>
    CC: Rusty Russell <rusty@rustcorp.com.au>
    CC: Mauro Carvalho Chehab <mchehab@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/ssu100.c b/drivers/usb/serial/ssu100.c
index 3fee23bf0c14..e719661899df 100644
--- a/drivers/usb/serial/ssu100.c
+++ b/drivers/usb/serial/ssu100.c
@@ -135,7 +135,7 @@ static inline int update_mctrl(struct usb_device *dev, unsigned int set,
 	int result;
 
 	if (((set | clear) & (TIOCM_DTR | TIOCM_RTS)) == 0) {
-		dbg("%s - DTR|RTS not being set|cleared", __func__);
+		dev_dbg(&dev->dev, "%s - DTR|RTS not being set|cleared\n", __func__);
 		return 0;	/* no change */
 	}
 
@@ -148,7 +148,7 @@ static inline int update_mctrl(struct usb_device *dev, unsigned int set,
 
 	result = ssu100_setregister(dev, 0, UART_MCR, urb_value);
 	if (result < 0)
-		dbg("%s Error from MODEM_CTRL urb", __func__);
+		dev_dbg(&dev->dev, "%s Error from MODEM_CTRL urb\n", __func__);
 
 	return result;
 }
@@ -164,7 +164,7 @@ static int ssu100_initdevice(struct usb_device *dev)
 
 	result = ssu100_getdevice(dev, data);
 	if (result < 0) {
-		dbg("%s - get_device failed %i", __func__, result);
+		dev_dbg(&dev->dev, "%s - get_device failed %i\n", __func__, result);
 		goto out;
 	}
 
@@ -172,25 +172,25 @@ static int ssu100_initdevice(struct usb_device *dev)
 
 	result = ssu100_setdevice(dev, data);
 	if (result < 0) {
-		dbg("%s - setdevice failed %i", __func__, result);
+		dev_dbg(&dev->dev, "%s - setdevice failed %i\n", __func__, result);
 		goto out;
 	}
 
 	result = ssu100_control_msg(dev, QT_GET_SET_PREBUF_TRIG_LVL, 128, 0);
 	if (result < 0) {
-		dbg("%s - set prebuffer level failed %i", __func__, result);
+		dev_dbg(&dev->dev, "%s - set prebuffer level failed %i\n", __func__, result);
 		goto out;
 	}
 
 	result = ssu100_control_msg(dev, QT_SET_ATF, ATC_DISABLED, 0);
 	if (result < 0) {
-		dbg("%s - set ATFprebuffer level failed %i", __func__, result);
+		dev_dbg(&dev->dev, "%s - set ATFprebuffer level failed %i\n", __func__, result);
 		goto out;
 	}
 
 	result = ssu100_getdevice(dev, data);
 	if (result < 0) {
-		dbg("%s - get_device failed %i", __func__, result);
+		dev_dbg(&dev->dev, "%s - get_device failed %i\n", __func__, result);
 		goto out;
 	}
 
@@ -201,7 +201,7 @@ static int ssu100_initdevice(struct usb_device *dev)
 
 	result = ssu100_setdevice(dev, data);
 	if (result < 0) {
-		dbg("%s - setdevice failed %i", __func__, result);
+		dev_dbg(&dev->dev, "%s - setdevice failed %i\n", __func__, result);
 		goto out;
 	}
 
@@ -249,7 +249,7 @@ static void ssu100_set_termios(struct tty_struct *tty,
 	if (!baud)
 		baud = 9600;
 
-	dbg("%s - got baud = %d\n", __func__, baud);
+	dev_dbg(&port->dev, "%s - got baud = %d\n", __func__, baud);
 
 
 	divisor = MAX_BAUD_RATE / baud;
@@ -261,7 +261,7 @@ static void ssu100_set_termios(struct tty_struct *tty,
 
 	result = ssu100_control_msg(dev, QT_GET_SET_UART, divisor, urb_value);
 	if (result < 0)
-		dbg("%s - set uart failed", __func__);
+		dev_dbg(&port->dev, "%s - set uart failed\n", __func__);
 
 	if (cflag & CRTSCTS)
 		result = ssu100_control_msg(dev, QT_HW_FLOW_CONTROL_MASK,
@@ -270,7 +270,7 @@ static void ssu100_set_termios(struct tty_struct *tty,
 		result = ssu100_control_msg(dev, QT_HW_FLOW_CONTROL_MASK,
 					    0, 0);
 	if (result < 0)
-		dbg("%s - set HW flow control failed", __func__);
+		dev_dbg(&port->dev, "%s - set HW flow control failed\n", __func__);
 
 	if (I_IXOFF(tty) || I_IXON(tty)) {
 		u16 x = ((u16)(START_CHAR(tty) << 8) | (u16)(STOP_CHAR(tty)));
@@ -282,7 +282,7 @@ static void ssu100_set_termios(struct tty_struct *tty,
 					    0, 0);
 
 	if (result < 0)
-		dbg("%s - set SW flow control failed", __func__);
+		dev_dbg(&port->dev, "%s - set SW flow control failed\n", __func__);
 
 }
 
@@ -304,7 +304,7 @@ static int ssu100_open(struct tty_struct *tty, struct usb_serial_port *port)
 				 QT_TRANSFER_IN, 0x01,
 				 0, data, 2, 300);
 	if (result < 0) {
-		dbg("%s - open failed %i", __func__, result);
+		dev_dbg(&port->dev, "%s - open failed %i\n", __func__, result);
 		kfree(data);
 		return result;
 	}
@@ -319,7 +319,7 @@ static int ssu100_open(struct tty_struct *tty, struct usb_serial_port *port)
 /* set to 9600 */
 	result = ssu100_control_msg(dev, QT_GET_SET_UART, 0x30, 0x0300);
 	if (result < 0)
-		dbg("%s - set uart failed", __func__);
+		dev_dbg(&port->dev, "%s - set uart failed\n", __func__);
 
 	if (tty)
 		ssu100_set_termios(tty, port, tty->termios);
@@ -423,7 +423,7 @@ static int ssu100_ioctl(struct tty_struct *tty,
 {
 	struct usb_serial_port *port = tty->driver_data;
 
-	dbg("%s cmd 0x%04x", __func__, cmd);
+	dev_dbg(&port->dev, "%s cmd 0x%04x\n", __func__, cmd);
 
 	switch (cmd) {
 	case TIOCGSERIAL:
@@ -437,7 +437,7 @@ static int ssu100_ioctl(struct tty_struct *tty,
 		break;
 	}
 
-	dbg("%s arg not supported", __func__);
+	dev_dbg(&port->dev, "%s arg not supported\n", __func__);
 
 	return -ENOIOCTLCMD;
 }

commit adc8d746caa67fff4b53ba3e5163a6cbacc3b523
Author: Alan Cox <alan@linux.intel.com>
Date:   Sat Jul 14 15:31:47 2012 +0100

    tty: move the termios object into the tty
    
    This will let us sort out a whole pile of tty related races. The
    alternative would be to keep points and refcount the termios objects.
    However
    1. They are tiny anyway
    2. Many devices don't use the stored copies
    3. We can remove a pty special case
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/ssu100.c b/drivers/usb/serial/ssu100.c
index 3fee23bf0c14..cf2d30cf7588 100644
--- a/drivers/usb/serial/ssu100.c
+++ b/drivers/usb/serial/ssu100.c
@@ -216,7 +216,7 @@ static void ssu100_set_termios(struct tty_struct *tty,
 			       struct ktermios *old_termios)
 {
 	struct usb_device *dev = port->serial->dev;
-	struct ktermios *termios = tty->termios;
+	struct ktermios *termios = &tty->termios;
 	u16 baud, divisor, remainder;
 	unsigned int cflag = termios->c_cflag;
 	u16 urb_value = 0; /* will hold the new flags */
@@ -322,7 +322,7 @@ static int ssu100_open(struct tty_struct *tty, struct usb_serial_port *port)
 		dbg("%s - set uart failed", __func__);
 
 	if (tty)
-		ssu100_set_termios(tty, port, tty->termios);
+		ssu100_set_termios(tty, port, &tty->termios);
 
 	return usb_serial_generic_open(tty, port);
 }

commit 68e24113457e437b1576670f2419b77ed0531e9e
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue May 8 15:46:14 2012 -0700

    USB: serial: rework usb_serial_register/deregister_drivers()
    
    This reworks the usb_serial_register_drivers() and
    usb_serial_deregister_drivers() to not need a pointer to a struct
    usb_driver anymore.  The usb_driver structure is now created dynamically
    and registered and unregistered as needed.
    
    This saves lines of code in each usb-serial driver.  All in-kernel users
    of these functions were also fixed up at this time.  The pl2303 driver
    was tested that everything worked properly.
    
    Thanks for the idea to do this from Alan Stern.
    
    Cc: Adhir Ramjiawan <adhirramjiawan0@gmail.com>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Al Borchers <alborchers@steinerpoint.com>
    Cc: Aleksey Babahin <tamerlan311@gmail.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Andrew Worsley <amworsley@gmail.com>
    Cc: Bart Hartgers <bart.hartgers@gmail.com>
    Cc: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Dan Carpenter <error27@gmail.com>
    Cc: Dan Williams <dcbw@redhat.com>
    Cc: Donald Lee <donald@asix.com.tw>
    Cc: Eric Dumazet <eric.dumazet@gmail.com>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Felipe Balbi <balbi@ti.com>
    Cc: Gary Brubaker <xavyer@ix.netcom.com>
    Cc: Jesper Juhl <jj@chaosbits.net>
    Cc: Jiri Kosina <jkosina@suse.cz>
    Cc: Johan Hovold <jhovold@gmail.com>
    Cc: Julia Lawall <julia@diku.dk>
    Cc: Kautuk Consul <consul.kautuk@gmail.com>
    Cc: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Cc: Lonnie Mendez <dignome@gmail.com>
    Cc: Matthias Bruestle and Harald Welte <support@reiner-sct.com>
    Cc: Matthias Urlichs <smurf@smurf.noris.de>
    Cc: Mauro Carvalho Chehab <mchehab@redhat.com>
    Cc: Michal Sroczynski <msroczyn@gmail.com>
    Cc: "Michał Wróbel" <michal.wrobel@flytronic.pl>
    Cc: Oliver Neukum <oliver@neukum.name>
    Cc: Paul Gortmaker <paul.gortmaker@windriver.com>
    Cc: Peter Berger <pberger@brimson.com>
    Cc: Preston Fick <preston.fick@silabs.com>
    Cc: "Rafael J. Wysocki" <rjw@sisk.pl>
    Cc: Rigbert Hamisch <rigbert@gmx.de>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Cc: Simon Arlott <simon@fire.lp0.eu>
    Cc: Support Department <support@connecttech.com>
    Cc: Thomas Tuttle <ttuttle@chromium.org>
    Cc: Uwe Bonnes <bon@elektron.ikp.physik.tu-darmstadt.de>
    Cc: Wang YanQing <Udknight@gmail.com>
    Cc: William Greathouse <wgreathouse@smva.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/ssu100.c b/drivers/usb/serial/ssu100.c
index f72b03f83be2..3fee23bf0c14 100644
--- a/drivers/usb/serial/ssu100.c
+++ b/drivers/usb/serial/ssu100.c
@@ -59,15 +59,8 @@ static const struct usb_device_id id_table[] = {
 	{USB_DEVICE(USB_VENDOR_ID_QUATECH, QUATECH_SSU100)},
 	{}			/* Terminating entry */
 };
-
 MODULE_DEVICE_TABLE(usb, id_table);
 
-
-static struct usb_driver ssu100_driver = {
-	.name			       = "ssu100",
-	.id_table		       = id_table,
-};
-
 struct ssu100_port_private {
 	spinlock_t status_lock;
 	u8 shadowLSR;
@@ -671,7 +664,7 @@ static struct usb_serial_driver * const serial_drivers[] = {
 	&ssu100_device, NULL
 };
 
-module_usb_serial_driver(ssu100_driver, serial_drivers);
+module_usb_serial_driver(serial_drivers, id_table);
 
 MODULE_DESCRIPTION(DRIVER_DESC);
 MODULE_LICENSE("GPL");

commit 32078f915d1acab356080b144aa89fe3487f3979
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon May 7 14:02:13 2012 -0700

    USB: serial: remove usb_serial_disconnect call in all drivers
    
    This is now set by the usb-serial core, no need for the driver to
    individually set it.
    
    Thanks to Alan Stern for the idea to get rid of it.
    
    Cc: William Greathouse <wgreathouse@smva.com>
    Cc: Matthias Bruestle and Harald Welte <support@reiner-sct.com>
    Cc: Lonnie Mendez <dignome@gmail.com>
    Cc: Peter Berger <pberger@brimson.com>
    Cc: Al Borchers <alborchers@steinerpoint.com>
    Cc: Gary Brubaker <xavyer@ix.netcom.com>
    Cc: Oliver Neukum <oliver@neukum.name>
    Cc: Matthias Urlichs <smurf@smurf.noris.de>
    Cc: Support Department <support@connecttech.com>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Mauro Carvalho Chehab <mchehab@redhat.com>
    Cc: Kautuk Consul <consul.kautuk@gmail.com>
    Cc: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Paul Gortmaker <paul.gortmaker@windriver.com>
    Cc: Bart Hartgers <bart.hartgers@gmail.com>
    Cc: Johan Hovold <jhovold@gmail.com>
    Cc: Preston Fick <preston.fick@silabs.com>
    Cc: Uwe Bonnes <bon@elektron.ikp.physik.tu-darmstadt.de>
    Cc: Simon Arlott <simon@fire.lp0.eu>
    Cc: Andrew Worsley <amworsley@gmail.com>
    Cc: "Michał Wróbel" <michal.wrobel@flytronic.pl>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Eric Dumazet <eric.dumazet@gmail.com>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Felipe Balbi <balbi@ti.com>
    Cc: Aleksey Babahin <tamerlan311@gmail.com>
    Cc: Dan Carpenter <error27@gmail.com>
    Cc: Jiri Kosina <jkosina@suse.cz>
    Cc: Donald Lee <donald@asix.com.tw>
    Cc: Julia Lawall <julia@diku.dk>
    Cc: Michal Sroczynski <msroczyn@gmail.com>
    Cc: Wang YanQing <Udknight@gmail.com>
    Cc: Dan Williams <dcbw@redhat.com>
    Cc: Thomas Tuttle <ttuttle@chromium.org>
    Cc: Rigbert Hamisch <rigbert@gmx.de>
    Cc: "Rafael J. Wysocki" <rjw@sisk.pl>
    Cc: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Cc: Jesper Juhl <jj@chaosbits.net>
    Cc: Adhir Ramjiawan <adhirramjiawan0@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/ssu100.c b/drivers/usb/serial/ssu100.c
index fcc00241afec..f72b03f83be2 100644
--- a/drivers/usb/serial/ssu100.c
+++ b/drivers/usb/serial/ssu100.c
@@ -65,7 +65,6 @@ MODULE_DEVICE_TABLE(usb, id_table);
 
 static struct usb_driver ssu100_driver = {
 	.name			       = "ssu100",
-	.disconnect		       = usb_serial_disconnect,
 	.id_table		       = id_table,
 };
 

commit 5026bb07be87ef5892742e6853ae6efa0f41961f
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon May 7 13:48:33 2012 -0700

    USB: serial: remove usb_serial_probe call in all drivers
    
    This is now set by the usb-serial core, no need for the driver to
    individually set it.
    
    Thanks to Alan Stern for the idea to get rid of it.
    
    Cc: William Greathouse <wgreathouse@smva.com>
    Cc: Matthias Bruestle and Harald Welte <support@reiner-sct.com>
    Cc: Lonnie Mendez <dignome@gmail.com>
    Cc: Peter Berger <pberger@brimson.com>
    Cc: Al Borchers <alborchers@steinerpoint.com>
    Cc: Gary Brubaker <xavyer@ix.netcom.com>
    Cc: Oliver Neukum <oliver@neukum.name>
    Cc: Matthias Urlichs <smurf@smurf.noris.de>
    Cc: Support Department <support@connecttech.com>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Mauro Carvalho Chehab <mchehab@redhat.com>
    Cc: Kautuk Consul <consul.kautuk@gmail.com>
    Cc: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Paul Gortmaker <paul.gortmaker@windriver.com>
    Cc: Bart Hartgers <bart.hartgers@gmail.com>
    Cc: Johan Hovold <jhovold@gmail.com>
    Cc: Preston Fick <preston.fick@silabs.com>
    Cc: Uwe Bonnes <bon@elektron.ikp.physik.tu-darmstadt.de>
    Cc: Simon Arlott <simon@fire.lp0.eu>
    Cc: Andrew Worsley <amworsley@gmail.com>
    Cc: "Michał Wróbel" <michal.wrobel@flytronic.pl>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Eric Dumazet <eric.dumazet@gmail.com>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Felipe Balbi <balbi@ti.com>
    Cc: Aleksey Babahin <tamerlan311@gmail.com>
    Cc: Dan Carpenter <error27@gmail.com>
    Cc: Jiri Kosina <jkosina@suse.cz>
    Cc: Donald Lee <donald@asix.com.tw>
    Cc: Julia Lawall <julia@diku.dk>
    Cc: Michal Sroczynski <msroczyn@gmail.com>
    Cc: Wang YanQing <Udknight@gmail.com>
    Cc: Dan Williams <dcbw@redhat.com>
    Cc: Thomas Tuttle <ttuttle@chromium.org>
    Cc: Rigbert Hamisch <rigbert@gmx.de>
    Cc: "Rafael J. Wysocki" <rjw@sisk.pl>
    Cc: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Cc: Jesper Juhl <jj@chaosbits.net>
    Cc: Adhir Ramjiawan <adhirramjiawan0@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/ssu100.c b/drivers/usb/serial/ssu100.c
index 9820492cf885..fcc00241afec 100644
--- a/drivers/usb/serial/ssu100.c
+++ b/drivers/usb/serial/ssu100.c
@@ -65,7 +65,6 @@ MODULE_DEVICE_TABLE(usb, id_table);
 
 static struct usb_driver ssu100_driver = {
 	.name			       = "ssu100",
-	.probe			       = usb_serial_probe,
 	.disconnect		       = usb_serial_disconnect,
 	.id_table		       = id_table,
 };

commit c7f3619b90fc4c43ed326ec8b3f0299374763c92
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon May 7 11:24:05 2012 -0400

    usb-serial: clean up unneeded PM-related fields
    
    This patch (as1551) cleans up the PM-related entries in the usb_driver
    structures of the various USB serial driver modules.  Those entries
    are now filled in by the usb-serial core during driver registration,
    so they don't need to be initialized explicitly in the source code.
    
    The same is true of the one remaining no_dynamic_id entry.
    
    reset_resume remains a small problem, because the serial core doesn't
    support it.  The patch ignores these entries.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/ssu100.c b/drivers/usb/serial/ssu100.c
index cda513bb01c7..9820492cf885 100644
--- a/drivers/usb/serial/ssu100.c
+++ b/drivers/usb/serial/ssu100.c
@@ -68,9 +68,6 @@ static struct usb_driver ssu100_driver = {
 	.probe			       = usb_serial_probe,
 	.disconnect		       = usb_serial_disconnect,
 	.id_table		       = id_table,
-	.suspend		       = usb_serial_suspend,
-	.resume			       = usb_serial_resume,
-	.supports_autosuspend	       = 1,
 };
 
 struct ssu100_port_private {

commit bb7a9c4a42995fe84af3e9c3a99f4c35d1567437
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu May 3 16:44:53 2012 -0700

    USB: ssu100.c: remove dbg() tracing calls
    
    dbg() was used a lot a long time ago to trace code flow.  Now that we have
    ftrace, this isn't needed at all, so remove these calls.
    
    CC: Rusty Russell <rusty@rustcorp.com.au>
    CC: Alan Stern <stern@rowland.harvard.edu>
    CC: Mauro Carvalho Chehab <mchehab@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/ssu100.c b/drivers/usb/serial/ssu100.c
index 3cdc8a52de44..cda513bb01c7 100644
--- a/drivers/usb/serial/ssu100.c
+++ b/drivers/usb/serial/ssu100.c
@@ -85,7 +85,6 @@ static void ssu100_release(struct usb_serial *serial)
 {
 	struct ssu100_port_private *priv = usb_get_serial_port_data(*serial->port);
 
-	dbg("%s", __func__);
 	kfree(priv);
 }
 
@@ -171,8 +170,6 @@ static int ssu100_initdevice(struct usb_device *dev)
 	u8 *data;
 	int result = 0;
 
-	dbg("%s", __func__);
-
 	data = kzalloc(3, GFP_KERNEL);
 	if (!data)
 		return -ENOMEM;
@@ -237,8 +234,6 @@ static void ssu100_set_termios(struct tty_struct *tty,
 	u16 urb_value = 0; /* will hold the new flags */
 	int result;
 
-	dbg("%s", __func__);
-
 	if (cflag & PARENB) {
 		if (cflag & PARODD)
 			urb_value |= UART_LCR_PARITY;
@@ -312,8 +307,6 @@ static int ssu100_open(struct tty_struct *tty, struct usb_serial_port *port)
 	int result;
 	unsigned long flags;
 
-	dbg("%s - port %d", __func__, port->number);
-
 	data = kzalloc(2, GFP_KERNEL);
 	if (!data)
 		return -ENOMEM;
@@ -348,7 +341,6 @@ static int ssu100_open(struct tty_struct *tty, struct usb_serial_port *port)
 
 static void ssu100_close(struct usb_serial_port *port)
 {
-	dbg("%s", __func__);
 	usb_serial_generic_close(port);
 }
 
@@ -467,8 +459,6 @@ static int ssu100_attach(struct usb_serial *serial)
 	struct ssu100_port_private *priv;
 	struct usb_serial_port *port = *serial->port;
 
-	dbg("%s", __func__);
-
 	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
 	if (!priv) {
 		dev_err(&port->dev, "%s- kmalloc(%Zd) failed.\n", __func__,
@@ -490,8 +480,6 @@ static int ssu100_tiocmget(struct tty_struct *tty)
 	u8 *d;
 	int r;
 
-	dbg("%s\n", __func__);
-
 	d = kzalloc(2, GFP_KERNEL);
 	if (!d)
 		return -ENOMEM;
@@ -522,7 +510,6 @@ static int ssu100_tiocmset(struct tty_struct *tty,
 	struct usb_serial_port *port = tty->driver_data;
 	struct usb_device *dev = port->serial->dev;
 
-	dbg("%s\n", __func__);
 	return update_mctrl(dev, set, clear);
 }
 
@@ -530,8 +517,6 @@ static void ssu100_dtr_rts(struct usb_serial_port *port, int on)
 {
 	struct usb_device *dev = port->serial->dev;
 
-	dbg("%s\n", __func__);
-
 	mutex_lock(&port->serial->disc_mutex);
 	if (!port->serial->disconnected) {
 		/* Disable flow control */
@@ -618,8 +603,6 @@ static int ssu100_process_packet(struct urb *urb,
 	int i;
 	char *ch;
 
-	dbg("%s - port %d", __func__, port->number);
-
 	if ((len >= 4) &&
 	    (packet[0] == 0x1b) && (packet[1] == 0x1b) &&
 	    ((packet[2] == 0x00) || (packet[2] == 0x01))) {
@@ -656,8 +639,6 @@ static void ssu100_process_read_urb(struct urb *urb)
 	struct tty_struct *tty;
 	int count;
 
-	dbg("%s", __func__);
-
 	tty = tty_port_tty_get(&port->port);
 	if (!tty)
 		return;

commit 3a67460715481772068aebf8c945667c285f2207
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Feb 28 13:12:36 2012 -0800

    USB: serial: ssu100.c: use module_usb_serial_driver
    
    This converts the ssu100.c driver to use the module_usb_serial_driver() call
    instead of having to have a module_init/module_exit function, saving a lot
    of duplicated code.
    
    CC: Rusty Russell <rusty@rustcorp.com.au>
    CC: Alan Stern <stern@rowland.harvard.edu>
    CC: Mauro Carvalho Chehab <mchehab@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/ssu100.c b/drivers/usb/serial/ssu100.c
index ab8842107a8b..3cdc8a52de44 100644
--- a/drivers/usb/serial/ssu100.c
+++ b/drivers/usb/serial/ssu100.c
@@ -695,26 +695,7 @@ static struct usb_serial_driver * const serial_drivers[] = {
 	&ssu100_device, NULL
 };
 
-static int __init ssu100_init(void)
-{
-	int retval;
-
-	dbg("%s", __func__);
-
-	retval = usb_serial_register_drivers(&ssu100_driver, serial_drivers);
-	if (retval == 0)
-		printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
-			       DRIVER_DESC "\n");
-	return retval;
-}
-
-static void __exit ssu100_exit(void)
-{
-	usb_serial_deregister_drivers(&ssu100_driver, serial_drivers);
-}
-
-module_init(ssu100_init);
-module_exit(ssu100_exit);
+module_usb_serial_driver(ssu100_driver, serial_drivers);
 
 MODULE_DESCRIPTION(DRIVER_DESC);
 MODULE_LICENSE("GPL");

commit d860322f34e4a53f347b1aeae23d5b72f1e91b8c
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Thu Feb 23 14:57:25 2012 -0500

    usb-serial: use new registration API in [q-s]* drivers
    
    This patch (as1528) modifies the following usb-serial drivers to
    utilize the new usb_serial_{de}register_drivers() routines:
    
            qcaux, qcserial, safe_serial, siemens_mpi, sierra,
            spcp8x5, ssu100, and symbolserial.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/serial/ssu100.c b/drivers/usb/serial/ssu100.c
index 7697858d8858..ab8842107a8b 100644
--- a/drivers/usb/serial/ssu100.c
+++ b/drivers/usb/serial/ssu100.c
@@ -70,7 +70,6 @@ static struct usb_driver ssu100_driver = {
 	.id_table		       = id_table,
 	.suspend		       = usb_serial_suspend,
 	.resume			       = usb_serial_resume,
-	.no_dynamic_id		       = 1,
 	.supports_autosuspend	       = 1,
 };
 
@@ -677,7 +676,6 @@ static struct usb_serial_driver ssu100_device = {
 	},
 	.description	     = DRIVER_DESC,
 	.id_table	     = id_table,
-	.usb_driver	     = &ssu100_driver,
 	.num_ports	     = 1,
 	.open		     = ssu100_open,
 	.close		     = ssu100_close,
@@ -693,37 +691,26 @@ static struct usb_serial_driver ssu100_device = {
 	.disconnect          = usb_serial_generic_disconnect,
 };
 
+static struct usb_serial_driver * const serial_drivers[] = {
+	&ssu100_device, NULL
+};
+
 static int __init ssu100_init(void)
 {
 	int retval;
 
 	dbg("%s", __func__);
 
-	/* register with usb-serial */
-	retval = usb_serial_register(&ssu100_device);
-
-	if (retval)
-		goto failed_usb_sio_register;
-
-	retval = usb_register(&ssu100_driver);
-	if (retval)
-		goto failed_usb_register;
-
-	printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
-	       DRIVER_DESC "\n");
-
-	return 0;
-
-failed_usb_register:
-	usb_serial_deregister(&ssu100_device);
-failed_usb_sio_register:
+	retval = usb_serial_register_drivers(&ssu100_driver, serial_drivers);
+	if (retval == 0)
+		printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
+			       DRIVER_DESC "\n");
 	return retval;
 }
 
 static void __exit ssu100_exit(void)
 {
-	usb_deregister(&ssu100_driver);
-	usb_serial_deregister(&ssu100_device);
+	usb_serial_deregister_drivers(&ssu100_driver, serial_drivers);
 }
 
 module_init(ssu100_init);

commit 90ab5ee94171b3e28de6bb42ee30b527014e0be7
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Fri Jan 13 09:32:20 2012 +1030

    module_param: make bool parameters really bool (drivers & misc)
    
    module_param(bool) used to counter-intuitively take an int.  In
    fddd5201 (mid-2009) we allowed bool or int/unsigned int using a messy
    trick.
    
    It's time to remove the int/unsigned int option.  For this version
    it'll simply give a warning, but it'll break next kernel version.
    
    Acked-by: Mauro Carvalho Chehab <mchehab@redhat.com>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/drivers/usb/serial/ssu100.c b/drivers/usb/serial/ssu100.c
index 87362e48796e..7697858d8858 100644
--- a/drivers/usb/serial/ssu100.c
+++ b/drivers/usb/serial/ssu100.c
@@ -46,7 +46,7 @@
 #define FULLPWRBIT          0x00000080
 #define NEXT_BOARD_POWER_BIT        0x00000004
 
-static int debug;
+static bool debug;
 
 /* Version Information */
 #define DRIVER_VERSION "v0.1"

commit 00a0d0d65b61241a718d0aee96f46b9a2d93bf26
Author: Alan Cox <alan@linux.intel.com>
Date:   Mon Feb 14 16:27:06 2011 +0000

    tty: remove filp from the USB tty ioctls
    
    We don't use it so we can trim it from here as we try and stamp the file
    object dependencies out of the serial code.
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ssu100.c b/drivers/usb/serial/ssu100.c
index abceee9d3af9..87362e48796e 100644
--- a/drivers/usb/serial/ssu100.c
+++ b/drivers/usb/serial/ssu100.c
@@ -439,7 +439,7 @@ static int ssu100_get_icount(struct tty_struct *tty,
 
 
 
-static int ssu100_ioctl(struct tty_struct *tty, struct file *file,
+static int ssu100_ioctl(struct tty_struct *tty,
 		    unsigned int cmd, unsigned long arg)
 {
 	struct usb_serial_port *port = tty->driver_data;

commit 20b9d17715017ae4dd4ec87fabc36d33b9de708e
Author: Alan Cox <alan@linux.intel.com>
Date:   Mon Feb 14 16:26:50 2011 +0000

    tiocmset: kill the file pointer argument
    
    Doing tiocmget was such fun we should do tiocmset as well for the same
    reasons
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ssu100.c b/drivers/usb/serial/ssu100.c
index b21583fa825c..abceee9d3af9 100644
--- a/drivers/usb/serial/ssu100.c
+++ b/drivers/usb/serial/ssu100.c
@@ -517,7 +517,7 @@ static int ssu100_tiocmget(struct tty_struct *tty)
 	return r;
 }
 
-static int ssu100_tiocmset(struct tty_struct *tty, struct file *file,
+static int ssu100_tiocmset(struct tty_struct *tty,
 			   unsigned int set, unsigned int clear)
 {
 	struct usb_serial_port *port = tty->driver_data;

commit 60b33c133ca0b7c0b6072c87234b63fee6e80558
Author: Alan Cox <alan@linux.intel.com>
Date:   Mon Feb 14 16:26:14 2011 +0000

    tiocmget: kill off the passing of the struct file
    
    We don't actually need this and it causes problems for internal use of
    this functionality. Currently there is a single use of the FILE * pointer.
    That is the serial core which uses it to check tty_hung_up_p. However if
    that is true then IO_ERROR is also already set so the check may be removed.
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ssu100.c b/drivers/usb/serial/ssu100.c
index 8359ec798959..b21583fa825c 100644
--- a/drivers/usb/serial/ssu100.c
+++ b/drivers/usb/serial/ssu100.c
@@ -484,7 +484,7 @@ static int ssu100_attach(struct usb_serial *serial)
 	return ssu100_initdevice(serial->dev);
 }
 
-static int ssu100_tiocmget(struct tty_struct *tty, struct file *file)
+static int ssu100_tiocmget(struct tty_struct *tty)
 {
 	struct usb_serial_port *port = tty->driver_data;
 	struct usb_device *dev = port->serial->dev;

commit f7043ecbb3f7b8632a6d6470f8f95160ac868d0f
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Oct 21 14:43:05 2010 -0400

    USB: ssu100: remove max_packet_size calculation
    
    The max_packet_size logic is taken from ftdi_sio, but it's not needed
    for this device.  This also makes proces_read_urb simpler.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ssu100.c b/drivers/usb/serial/ssu100.c
index f5312dd3331b..8359ec798959 100644
--- a/drivers/usb/serial/ssu100.c
+++ b/drivers/usb/serial/ssu100.c
@@ -79,7 +79,6 @@ struct ssu100_port_private {
 	u8 shadowLSR;
 	u8 shadowMSR;
 	wait_queue_head_t delta_msr_wait; /* Used for TIOCMIWAIT */
-	unsigned short max_packet_size;
 	struct async_icount icount;
 };
 
@@ -464,36 +463,6 @@ static int ssu100_ioctl(struct tty_struct *tty, struct file *file,
 	return -ENOIOCTLCMD;
 }
 
-static void ssu100_set_max_packet_size(struct usb_serial_port *port)
-{
-	struct ssu100_port_private *priv = usb_get_serial_port_data(port);
-	struct usb_serial *serial = port->serial;
-	struct usb_device *udev = serial->dev;
-
-	struct usb_interface *interface = serial->interface;
-	struct usb_endpoint_descriptor *ep_desc = &interface->cur_altsetting->endpoint[1].desc;
-
-	unsigned num_endpoints;
-	int i;
-	unsigned long flags;
-
-	num_endpoints = interface->cur_altsetting->desc.bNumEndpoints;
-	dev_info(&udev->dev, "Number of endpoints %d\n", num_endpoints);
-
-	for (i = 0; i < num_endpoints; i++) {
-		dev_info(&udev->dev, "Endpoint %d MaxPacketSize %d\n", i+1,
-			interface->cur_altsetting->endpoint[i].desc.wMaxPacketSize);
-		ep_desc = &interface->cur_altsetting->endpoint[i].desc;
-	}
-
-	/* set max packet size based on descriptor */
-	spin_lock_irqsave(&priv->status_lock, flags);
-	priv->max_packet_size = ep_desc->wMaxPacketSize;
-	spin_unlock_irqrestore(&priv->status_lock, flags);
-
-	dev_info(&udev->dev, "Setting MaxPacketSize %d\n", priv->max_packet_size);
-}
-
 static int ssu100_attach(struct usb_serial *serial)
 {
 	struct ssu100_port_private *priv;
@@ -511,7 +480,6 @@ static int ssu100_attach(struct usb_serial *serial)
 	spin_lock_init(&priv->status_lock);
 	init_waitqueue_head(&priv->delta_msr_wait);
 	usb_set_serial_port_data(port, priv);
-	ssu100_set_max_packet_size(port);
 
 	return ssu100_initdevice(serial->dev);
 }
@@ -641,13 +609,14 @@ static void ssu100_update_lsr(struct usb_serial_port *port, u8 lsr,
 
 }
 
-static int ssu100_process_packet(struct tty_struct *tty,
-				 struct usb_serial_port *port,
-				 struct ssu100_port_private *priv,
-				 char *packet, int len)
+static int ssu100_process_packet(struct urb *urb,
+				 struct tty_struct *tty)
 {
-	int i;
+	struct usb_serial_port *port = urb->context;
+	char *packet = (char *)urb->transfer_buffer;
 	char flag = TTY_NORMAL;
+	u32 len = urb->actual_length;
+	int i;
 	char *ch;
 
 	dbg("%s - port %d", __func__, port->number);
@@ -685,12 +654,8 @@ static int ssu100_process_packet(struct tty_struct *tty,
 static void ssu100_process_read_urb(struct urb *urb)
 {
 	struct usb_serial_port *port = urb->context;
-	struct ssu100_port_private *priv = usb_get_serial_port_data(port);
-	char *data = (char *)urb->transfer_buffer;
 	struct tty_struct *tty;
-	int count = 0;
-	int i;
-	int len;
+	int count;
 
 	dbg("%s", __func__);
 
@@ -698,10 +663,7 @@ static void ssu100_process_read_urb(struct urb *urb)
 	if (!tty)
 		return;
 
-	for (i = 0; i < urb->actual_length; i += priv->max_packet_size) {
-		len = min_t(int, urb->actual_length - i, priv->max_packet_size);
-		count += ssu100_process_packet(tty, port, priv, &data[i], len);
-	}
+	count = ssu100_process_packet(urb, tty);
 
 	if (count)
 		tty_flip_buffer_push(tty);
@@ -717,8 +679,6 @@ static struct usb_serial_driver ssu100_device = {
 	.id_table	     = id_table,
 	.usb_driver	     = &ssu100_driver,
 	.num_ports	     = 1,
-	.bulk_in_size        = 256,
-	.bulk_out_size       = 256,
 	.open		     = ssu100_open,
 	.close		     = ssu100_close,
 	.attach              = ssu100_attach,

commit a9e2e06015201c32c43d3615c9bf5e0d4efb4302
Author: Alan Cox <alan@linux.intel.com>
Date:   Fri Sep 24 15:49:18 2010 +0100

    tty: Fix warning left over from TIOCGICOUNT changes
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ssu100.c b/drivers/usb/serial/ssu100.c
index 8bd60e3c8b28..f5312dd3331b 100644
--- a/drivers/usb/serial/ssu100.c
+++ b/drivers/usb/serial/ssu100.c
@@ -444,8 +444,6 @@ static int ssu100_ioctl(struct tty_struct *tty, struct file *file,
 		    unsigned int cmd, unsigned long arg)
 {
 	struct usb_serial_port *port = tty->driver_data;
-	struct ssu100_port_private *priv = usb_get_serial_port_data(port);
-	void __user *user_arg = (void __user *)arg;
 
 	dbg("%s cmd 0x%04x", __func__, cmd);
 

commit 0bca1b913affbd7e2fdaffee62a499659a466eb5
Author: Alan Cox <alan@linux.intel.com>
Date:   Thu Sep 16 18:21:40 2010 +0100

    tty: Convert the USB drivers to the new icount interface
    
    Simple pasting job using the new ops function. Also fix a couple of devices
    directly returning the internal struct (which happens at this point to match
    for the fields that matter but isn't correct or futureproof)
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ssu100.c b/drivers/usb/serial/ssu100.c
index e986002b3844..8bd60e3c8b28 100644
--- a/drivers/usb/serial/ssu100.c
+++ b/drivers/usb/serial/ssu100.c
@@ -416,6 +416,30 @@ static int wait_modem_info(struct usb_serial_port *port, unsigned int arg)
 	return 0;
 }
 
+static int ssu100_get_icount(struct tty_struct *tty,
+			struct serial_icounter_struct *icount)
+{
+	struct usb_serial_port *port = tty->driver_data;
+	struct ssu100_port_private *priv = usb_get_serial_port_data(port);
+	struct async_icount cnow = priv->icount;
+
+	icount->cts = cnow.cts;
+	icount->dsr = cnow.dsr;
+	icount->rng = cnow.rng;
+	icount->dcd = cnow.dcd;
+	icount->rx = cnow.rx;
+	icount->tx = cnow.tx;
+	icount->frame = cnow.frame;
+	icount->overrun = cnow.overrun;
+	icount->parity = cnow.parity;
+	icount->brk = cnow.brk;
+	icount->buf_overrun = cnow.buf_overrun;
+
+	return 0;
+}
+
+
+
 static int ssu100_ioctl(struct tty_struct *tty, struct file *file,
 		    unsigned int cmd, unsigned long arg)
 {
@@ -433,27 +457,6 @@ static int ssu100_ioctl(struct tty_struct *tty, struct file *file,
 	case TIOCMIWAIT:
 		return wait_modem_info(port, arg);
 
-	case TIOCGICOUNT:
-	{
-		struct serial_icounter_struct icount;
-		struct async_icount cnow = priv->icount;
-		memset(&icount, 0, sizeof(icount));
-		icount.cts = cnow.cts;
-		icount.dsr = cnow.dsr;
-		icount.rng = cnow.rng;
-		icount.dcd = cnow.dcd;
-		icount.rx = cnow.rx;
-		icount.tx = cnow.tx;
-		icount.frame = cnow.frame;
-		icount.overrun = cnow.overrun;
-		icount.parity = cnow.parity;
-		icount.brk = cnow.brk;
-		icount.buf_overrun = cnow.buf_overrun;
-		if (copy_to_user(user_arg, &icount, sizeof(icount)))
-			return -EFAULT;
-		return 0;
-	}
-
 	default:
 		break;
 	}
@@ -726,6 +729,7 @@ static struct usb_serial_driver ssu100_device = {
 	.process_read_urb    = ssu100_process_read_urb,
 	.tiocmget            = ssu100_tiocmget,
 	.tiocmset            = ssu100_tiocmset,
+	.get_icount	     = ssu100_get_icount,
 	.ioctl               = ssu100_ioctl,
 	.set_termios         = ssu100_set_termios,
 	.disconnect          = usb_serial_generic_disconnect,

commit 3c35b002da0c749ec15cf25cfe58f06aa230ae9c
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Wed Aug 25 18:21:23 2010 -0400

    USB: ssu100: turn off debug flag
    
    Remove the hard coding of the debug flag to 1.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ssu100.c b/drivers/usb/serial/ssu100.c
index 68c18fdfc6da..e986002b3844 100644
--- a/drivers/usb/serial/ssu100.c
+++ b/drivers/usb/serial/ssu100.c
@@ -46,7 +46,7 @@
 #define FULLPWRBIT          0x00000080
 #define NEXT_BOARD_POWER_BIT        0x00000004
 
-static int debug = 1;
+static int debug;
 
 /* Version Information */
 #define DRIVER_VERSION "v0.1"

commit 2637d139fb9a1bd428a003b7671fda40a034854f
Merge: 494e2fbe1f8b 288933c02b44
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Aug 28 13:55:31 2010 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/dtor/input
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/dtor/input:
      Input: pxa27x_keypad - remove input_free_device() in pxa27x_keypad_remove()
      Input: mousedev - fix regression of inverting axes
      Input: uinput - add devname alias to allow module on-demand load
      Input: hil_kbd - fix compile error
      USB: drop tty argument from usb_serial_handle_sysrq_char()
      Input: sysrq - drop tty argument form handle_sysrq()
      Input: sysrq - drop tty argument from sysrq ops handlers

commit 6b8f1ca5581bf9783069cd6bde65ba7a3a470aab
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Fri Aug 13 09:59:31 2010 -0400

    USB: ssu100: set tty_flags in ssu100_process_packet
    
    flag was never set in ssu100_process_packet.  Add logic to set it
    before calling tty_insert_flip_*
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ssu100.c b/drivers/usb/serial/ssu100.c
index 55e9672d286a..660c31f14999 100644
--- a/drivers/usb/serial/ssu100.c
+++ b/drivers/usb/serial/ssu100.c
@@ -602,7 +602,8 @@ static void ssu100_update_msr(struct usb_serial_port *port, u8 msr)
 	}
 }
 
-static void ssu100_update_lsr(struct usb_serial_port *port, u8 lsr)
+static void ssu100_update_lsr(struct usb_serial_port *port, u8 lsr,
+			      char *tty_flag)
 {
 	struct ssu100_port_private *priv = usb_get_serial_port_data(port);
 	unsigned long flags;
@@ -611,16 +612,32 @@ static void ssu100_update_lsr(struct usb_serial_port *port, u8 lsr)
 	priv->shadowLSR = lsr;
 	spin_unlock_irqrestore(&priv->status_lock, flags);
 
+	*tty_flag = TTY_NORMAL;
 	if (lsr & UART_LSR_BRK_ERROR_BITS) {
-		if (lsr & UART_LSR_BI)
+		/* we always want to update icount, but we only want to
+		 * update tty_flag for one case */
+		if (lsr & UART_LSR_BI) {
 			priv->icount.brk++;
-		if (lsr & UART_LSR_FE)
-			priv->icount.frame++;
-		if (lsr & UART_LSR_PE)
+			*tty_flag = TTY_BREAK;
+			usb_serial_handle_break(port);
+		}
+		if (lsr & UART_LSR_PE) {
 			priv->icount.parity++;
-		if (lsr & UART_LSR_OE)
+			if (*tty_flag == TTY_NORMAL)
+				*tty_flag = TTY_PARITY;
+		}
+		if (lsr & UART_LSR_FE) {
+			priv->icount.frame++;
+			if (*tty_flag == TTY_NORMAL)
+				*tty_flag = TTY_FRAME;
+		}
+		if (lsr & UART_LSR_OE){
 			priv->icount.overrun++;
+			if (*tty_flag == TTY_NORMAL)
+				*tty_flag = TTY_OVERRUN;
+		}
 	}
+
 }
 
 static int ssu100_process_packet(struct tty_struct *tty,
@@ -629,7 +646,7 @@ static int ssu100_process_packet(struct tty_struct *tty,
 				 char *packet, int len)
 {
 	int i;
-	char flag;
+	char flag = TTY_NORMAL;
 	char *ch;
 
 	dbg("%s - port %d", __func__, port->number);
@@ -637,8 +654,11 @@ static int ssu100_process_packet(struct tty_struct *tty,
 	if ((len >= 4) &&
 	    (packet[0] == 0x1b) && (packet[1] == 0x1b) &&
 	    ((packet[2] == 0x00) || (packet[2] == 0x01))) {
-		if (packet[2] == 0x00)
-			ssu100_update_lsr(port, packet[3]);
+		if (packet[2] == 0x00) {
+			ssu100_update_lsr(port, packet[3], &flag);
+			if (flag == TTY_OVERRUN)
+				tty_insert_flip_char(tty, 0, TTY_OVERRUN);
+		}
 		if (packet[2] == 0x01)
 			ssu100_update_msr(port, packet[3]);
 

commit 85dee135b84f1c7cad252fa4a619ea692077a7fc
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Aug 5 17:01:11 2010 -0400

    USB: ssu100: add disconnect function for ssu100
    
    Add a disconnect function to the functions of this device.  The
    disconnect is a call to usb_serial_generic_disconnect() so it requires
    that symbol to be exported from generic.c.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ssu100.c b/drivers/usb/serial/ssu100.c
index e244491b1a0d..55e9672d286a 100644
--- a/drivers/usb/serial/ssu100.c
+++ b/drivers/usb/serial/ssu100.c
@@ -687,7 +687,6 @@ static void ssu100_process_read_urb(struct urb *urb)
 	tty_kref_put(tty);
 }
 
-
 static struct usb_serial_driver ssu100_device = {
 	.driver = {
 		.owner = THIS_MODULE,
@@ -709,6 +708,7 @@ static struct usb_serial_driver ssu100_device = {
 	.tiocmset            = ssu100_tiocmset,
 	.ioctl               = ssu100_ioctl,
 	.set_termios         = ssu100_set_termios,
+	.disconnect          = usb_serial_generic_disconnect,
 };
 
 static int __init ssu100_init(void)

commit f81c83db563334d8377b26ad45585261f604605a
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Aug 5 17:01:09 2010 -0400

    USB: ssu100: rework logic for TIOCMIWAIT
    
    Rework the logic for TIOCMIWAIT to use wait_event_interruptible.
    
    This also adds support for TIOCGICOUNT.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ssu100.c b/drivers/usb/serial/ssu100.c
index ad5f9ae40687..e244491b1a0d 100644
--- a/drivers/usb/serial/ssu100.c
+++ b/drivers/usb/serial/ssu100.c
@@ -80,6 +80,7 @@ struct ssu100_port_private {
 	u8 shadowMSR;
 	wait_queue_head_t delta_msr_wait; /* Used for TIOCMIWAIT */
 	unsigned short max_packet_size;
+	struct async_icount icount;
 };
 
 static void ssu100_release(struct usb_serial *serial)
@@ -330,11 +331,8 @@ static int ssu100_open(struct tty_struct *tty, struct usb_serial_port *port)
 	}
 
 	spin_lock_irqsave(&priv->status_lock, flags);
-	priv->shadowLSR = data[0]  & (UART_LSR_OE | UART_LSR_PE |
-				      UART_LSR_FE | UART_LSR_BI);
-
-	priv->shadowMSR = data[1]  & (UART_MSR_CTS | UART_MSR_DSR |
-				      UART_MSR_RI | UART_MSR_DCD);
+	priv->shadowLSR = data[0];
+	priv->shadowMSR = data[1];
 	spin_unlock_irqrestore(&priv->status_lock, flags);
 
 	kfree(data);
@@ -379,11 +377,51 @@ static int get_serial_info(struct usb_serial_port *port,
 	return 0;
 }
 
+static int wait_modem_info(struct usb_serial_port *port, unsigned int arg)
+{
+	struct ssu100_port_private *priv = usb_get_serial_port_data(port);
+	struct async_icount prev, cur;
+	unsigned long flags;
+
+	spin_lock_irqsave(&priv->status_lock, flags);
+	prev = priv->icount;
+	spin_unlock_irqrestore(&priv->status_lock, flags);
+
+	while (1) {
+		wait_event_interruptible(priv->delta_msr_wait,
+					 ((priv->icount.rng != prev.rng) ||
+					  (priv->icount.dsr != prev.dsr) ||
+					  (priv->icount.dcd != prev.dcd) ||
+					  (priv->icount.cts != prev.cts)));
+
+		if (signal_pending(current))
+			return -ERESTARTSYS;
+
+		spin_lock_irqsave(&priv->status_lock, flags);
+		cur = priv->icount;
+		spin_unlock_irqrestore(&priv->status_lock, flags);
+
+		if ((prev.rng == cur.rng) &&
+		    (prev.dsr == cur.dsr) &&
+		    (prev.dcd == cur.dcd) &&
+		    (prev.cts == cur.cts))
+			return -EIO;
+
+		if ((arg & TIOCM_RNG && (prev.rng != cur.rng)) ||
+		    (arg & TIOCM_DSR && (prev.dsr != cur.dsr)) ||
+		    (arg & TIOCM_CD  && (prev.dcd != cur.dcd)) ||
+		    (arg & TIOCM_CTS && (prev.cts != cur.cts)))
+			return 0;
+	}
+	return 0;
+}
+
 static int ssu100_ioctl(struct tty_struct *tty, struct file *file,
 		    unsigned int cmd, unsigned long arg)
 {
 	struct usb_serial_port *port = tty->driver_data;
 	struct ssu100_port_private *priv = usb_get_serial_port_data(port);
+	void __user *user_arg = (void __user *)arg;
 
 	dbg("%s cmd 0x%04x", __func__, cmd);
 
@@ -393,28 +431,28 @@ static int ssu100_ioctl(struct tty_struct *tty, struct file *file,
 				       (struct serial_struct __user *) arg);
 
 	case TIOCMIWAIT:
-		while (priv != NULL) {
-			u8 prevMSR = priv->shadowMSR & SERIAL_MSR_MASK;
-			interruptible_sleep_on(&priv->delta_msr_wait);
-			/* see if a signal did it */
-			if (signal_pending(current))
-				return -ERESTARTSYS;
-			else {
-				u8 diff = (priv->shadowMSR & SERIAL_MSR_MASK) ^ prevMSR;
-				if (!diff)
-					return -EIO; /* no change => error */
-
-				/* Return 0 if caller wanted to know about
-				   these bits */
-
-				if (((arg & TIOCM_RNG) && (diff & UART_MSR_RI)) ||
-				    ((arg & TIOCM_DSR) && (diff & UART_MSR_DSR)) ||
-				    ((arg & TIOCM_CD) && (diff & UART_MSR_DCD)) ||
-				    ((arg & TIOCM_CTS) && (diff & UART_MSR_CTS)))
-					return 0;
-			}
-		}
+		return wait_modem_info(port, arg);
+
+	case TIOCGICOUNT:
+	{
+		struct serial_icounter_struct icount;
+		struct async_icount cnow = priv->icount;
+		memset(&icount, 0, sizeof(icount));
+		icount.cts = cnow.cts;
+		icount.dsr = cnow.dsr;
+		icount.rng = cnow.rng;
+		icount.dcd = cnow.dcd;
+		icount.rx = cnow.rx;
+		icount.tx = cnow.tx;
+		icount.frame = cnow.frame;
+		icount.overrun = cnow.overrun;
+		icount.parity = cnow.parity;
+		icount.brk = cnow.brk;
+		icount.buf_overrun = cnow.buf_overrun;
+		if (copy_to_user(user_arg, &icount, sizeof(icount)))
+			return -EFAULT;
 		return 0;
+	}
 
 	default:
 		break;
@@ -541,6 +579,50 @@ static void ssu100_dtr_rts(struct usb_serial_port *port, int on)
 	mutex_unlock(&port->serial->disc_mutex);
 }
 
+static void ssu100_update_msr(struct usb_serial_port *port, u8 msr)
+{
+	struct ssu100_port_private *priv = usb_get_serial_port_data(port);
+	unsigned long flags;
+
+	spin_lock_irqsave(&priv->status_lock, flags);
+	priv->shadowMSR = msr;
+	spin_unlock_irqrestore(&priv->status_lock, flags);
+
+	if (msr & UART_MSR_ANY_DELTA) {
+		/* update input line counters */
+		if (msr & UART_MSR_DCTS)
+			priv->icount.cts++;
+		if (msr & UART_MSR_DDSR)
+			priv->icount.dsr++;
+		if (msr & UART_MSR_DDCD)
+			priv->icount.dcd++;
+		if (msr & UART_MSR_TERI)
+			priv->icount.rng++;
+		wake_up_interruptible(&priv->delta_msr_wait);
+	}
+}
+
+static void ssu100_update_lsr(struct usb_serial_port *port, u8 lsr)
+{
+	struct ssu100_port_private *priv = usb_get_serial_port_data(port);
+	unsigned long flags;
+
+	spin_lock_irqsave(&priv->status_lock, flags);
+	priv->shadowLSR = lsr;
+	spin_unlock_irqrestore(&priv->status_lock, flags);
+
+	if (lsr & UART_LSR_BRK_ERROR_BITS) {
+		if (lsr & UART_LSR_BI)
+			priv->icount.brk++;
+		if (lsr & UART_LSR_FE)
+			priv->icount.frame++;
+		if (lsr & UART_LSR_PE)
+			priv->icount.parity++;
+		if (lsr & UART_LSR_OE)
+			priv->icount.overrun++;
+	}
+}
+
 static int ssu100_process_packet(struct tty_struct *tty,
 				 struct usb_serial_port *port,
 				 struct ssu100_port_private *priv,
@@ -556,15 +638,9 @@ static int ssu100_process_packet(struct tty_struct *tty,
 	    (packet[0] == 0x1b) && (packet[1] == 0x1b) &&
 	    ((packet[2] == 0x00) || (packet[2] == 0x01))) {
 		if (packet[2] == 0x00)
-			priv->shadowLSR = packet[3] & (UART_LSR_OE |
-						       UART_LSR_PE |
-						       UART_LSR_FE |
-						       UART_LSR_BI);
-
-		if (packet[2] == 0x01) {
-			priv->shadowMSR = packet[3];
-			wake_up_interruptible(&priv->delta_msr_wait);
-		}
+			ssu100_update_lsr(port, packet[3]);
+		if (packet[2] == 0x01)
+			ssu100_update_msr(port, packet[3]);
 
 		len -= 4;
 		ch = packet + 4;

commit 556f1a0e9c178193e584209b47cf1cb9f669bd51
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Aug 5 17:01:08 2010 -0400

    USB: ssu100: add register parameter to ssu100_setregister
    
    The function ssu100_setregister was hard coded to only set the MCR
    register.  Add a register parameter so that other registers can be
    set.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ssu100.c b/drivers/usb/serial/ssu100.c
index 3c586b5790e1..ad5f9ae40687 100644
--- a/drivers/usb/serial/ssu100.c
+++ b/drivers/usb/serial/ssu100.c
@@ -127,9 +127,10 @@ static inline int ssu100_getregister(struct usb_device *dev,
 
 static inline int ssu100_setregister(struct usb_device *dev,
 				     unsigned short uart,
+				     unsigned short reg,
 				     u16 data)
 {
-	u16 value = (data << 8) | UART_MCR;
+	u16 value = (data << 8) | reg;
 
 	return usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
 			       QT_SET_GET_REGISTER, 0x40, value, uart,
@@ -159,7 +160,7 @@ static inline int update_mctrl(struct usb_device *dev, unsigned int set,
 	if (set & TIOCM_RTS)
 		urb_value |= UART_MCR_RTS;
 
-	result = ssu100_setregister(dev, 0, urb_value);
+	result = ssu100_setregister(dev, 0, UART_MCR, urb_value);
 	if (result < 0)
 		dbg("%s Error from MODEM_CTRL urb", __func__);
 
@@ -529,7 +530,7 @@ static void ssu100_dtr_rts(struct usb_serial_port *port, int on)
 	if (!port->serial->disconnected) {
 		/* Disable flow control */
 		if (!on &&
-		    ssu100_setregister(dev, 0, 0) < 0)
+		    ssu100_setregister(dev, 0, UART_MCR, 0) < 0)
 			dev_err(&port->dev, "error from flowcontrol urb\n");
 		/* drop RTS and DTR */
 		if (on)

commit 79f203a26a07a9d5701c404925e85eb161b72cde
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Aug 5 17:01:07 2010 -0400

    USB: ssu100: remove duplicate #defines in ssu100
    
    The ssu100 uses a TI16C550C UART so the SERIAL_ defines in this code
    are duplicates of those found in serial_reg.h.  Remove the defines in
    ssu100.c and use the ones in the header file.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ssu100.c b/drivers/usb/serial/ssu100.c
index c7193880a2b6..3c586b5790e1 100644
--- a/drivers/usb/serial/ssu100.c
+++ b/drivers/usb/serial/ssu100.c
@@ -15,6 +15,7 @@
 #include <linux/serial.h>
 #include <linux/usb.h>
 #include <linux/usb/serial.h>
+#include <linux/serial_reg.h>
 #include <linux/uaccess.h>
 
 #define QT_OPEN_CLOSE_CHANNEL       0xca
@@ -27,36 +28,11 @@
 #define QT_HW_FLOW_CONTROL_MASK     0xc5
 #define QT_SW_FLOW_CONTROL_MASK     0xc6
 
-#define MODEM_CTL_REGISTER         0x04
-#define MODEM_STATUS_REGISTER      0x06
-
-
-#define SERIAL_LSR_OE       0x02
-#define SERIAL_LSR_PE       0x04
-#define SERIAL_LSR_FE       0x08
-#define SERIAL_LSR_BI       0x10
-
-#define SERIAL_LSR_TEMT     0x40
-
-#define  SERIAL_MCR_DTR             0x01
-#define  SERIAL_MCR_RTS             0x02
-#define  SERIAL_MCR_LOOP            0x10
-
-#define  SERIAL_MSR_CTS             0x10
-#define  SERIAL_MSR_CD              0x80
-#define  SERIAL_MSR_RI              0x40
-#define  SERIAL_MSR_DSR             0x20
 #define  SERIAL_MSR_MASK            0xf0
 
-#define  SERIAL_CRTSCTS ((SERIAL_MCR_RTS << 8) | SERIAL_MSR_CTS)
-
-#define  SERIAL_8_DATA              0x03
-#define  SERIAL_7_DATA              0x02
-#define  SERIAL_6_DATA              0x01
-#define  SERIAL_5_DATA              0x00
+#define  SERIAL_CRTSCTS ((UART_MCR_RTS << 8) | UART_MSR_CTS)
 
-#define  SERIAL_ODD_PARITY          0X08
-#define  SERIAL_EVEN_PARITY         0X18
+#define  SERIAL_EVEN_PARITY         (UART_LCR_PARITY | UART_LCR_EPAR)
 
 #define  MAX_BAUD_RATE              460800
 
@@ -153,7 +129,7 @@ static inline int ssu100_setregister(struct usb_device *dev,
 				     unsigned short uart,
 				     u16 data)
 {
-	u16 value = (data << 8) | MODEM_CTL_REGISTER;
+	u16 value = (data << 8) | UART_MCR;
 
 	return usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
 			       QT_SET_GET_REGISTER, 0x40, value, uart,
@@ -179,9 +155,9 @@ static inline int update_mctrl(struct usb_device *dev, unsigned int set,
 	clear &= ~set;	/* 'set' takes precedence over 'clear' */
 	urb_value = 0;
 	if (set & TIOCM_DTR)
-		urb_value |= SERIAL_MCR_DTR;
+		urb_value |= UART_MCR_DTR;
 	if (set & TIOCM_RTS)
-		urb_value |= SERIAL_MCR_RTS;
+		urb_value |= UART_MCR_RTS;
 
 	result = ssu100_setregister(dev, 0, urb_value);
 	if (result < 0)
@@ -265,24 +241,24 @@ static void ssu100_set_termios(struct tty_struct *tty,
 
 	if (cflag & PARENB) {
 		if (cflag & PARODD)
-			urb_value |= SERIAL_ODD_PARITY;
+			urb_value |= UART_LCR_PARITY;
 		else
 			urb_value |= SERIAL_EVEN_PARITY;
 	}
 
 	switch (cflag & CSIZE) {
 	case CS5:
-		urb_value |= SERIAL_5_DATA;
+		urb_value |= UART_LCR_WLEN5;
 		break;
 	case CS6:
-		urb_value |= SERIAL_6_DATA;
+		urb_value |= UART_LCR_WLEN6;
 		break;
 	case CS7:
-		urb_value |= SERIAL_7_DATA;
+		urb_value |= UART_LCR_WLEN7;
 		break;
 	default:
 	case CS8:
-		urb_value |= SERIAL_8_DATA;
+		urb_value |= UART_LCR_WLEN8;
 		break;
 	}
 
@@ -353,11 +329,11 @@ static int ssu100_open(struct tty_struct *tty, struct usb_serial_port *port)
 	}
 
 	spin_lock_irqsave(&priv->status_lock, flags);
-	priv->shadowLSR = data[0]  & (SERIAL_LSR_OE | SERIAL_LSR_PE |
-				      SERIAL_LSR_FE | SERIAL_LSR_BI);
+	priv->shadowLSR = data[0]  & (UART_LSR_OE | UART_LSR_PE |
+				      UART_LSR_FE | UART_LSR_BI);
 
-	priv->shadowMSR = data[1]  & (SERIAL_MSR_CTS | SERIAL_MSR_DSR |
-				      SERIAL_MSR_RI | SERIAL_MSR_CD);
+	priv->shadowMSR = data[1]  & (UART_MSR_CTS | UART_MSR_DSR |
+				      UART_MSR_RI | UART_MSR_DCD);
 	spin_unlock_irqrestore(&priv->status_lock, flags);
 
 	kfree(data);
@@ -430,10 +406,10 @@ static int ssu100_ioctl(struct tty_struct *tty, struct file *file,
 				/* Return 0 if caller wanted to know about
 				   these bits */
 
-				if (((arg & TIOCM_RNG) && (diff & SERIAL_MSR_RI)) ||
-				    ((arg & TIOCM_DSR) && (diff & SERIAL_MSR_DSR)) ||
-				    ((arg & TIOCM_CD) && (diff & SERIAL_MSR_CD)) ||
-				    ((arg & TIOCM_CTS) && (diff & SERIAL_MSR_CTS)))
+				if (((arg & TIOCM_RNG) && (diff & UART_MSR_RI)) ||
+				    ((arg & TIOCM_DSR) && (diff & UART_MSR_DSR)) ||
+				    ((arg & TIOCM_CD) && (diff & UART_MSR_DCD)) ||
+				    ((arg & TIOCM_CTS) && (diff & UART_MSR_CTS)))
 					return 0;
 			}
 		}
@@ -513,20 +489,20 @@ static int ssu100_tiocmget(struct tty_struct *tty, struct file *file)
 	if (!d)
 		return -ENOMEM;
 
-	r = ssu100_getregister(dev, 0, MODEM_CTL_REGISTER, d);
+	r = ssu100_getregister(dev, 0, UART_MCR, d);
 	if (r < 0)
 		goto mget_out;
 
-	r = ssu100_getregister(dev, 0, MODEM_STATUS_REGISTER, d+1);
+	r = ssu100_getregister(dev, 0, UART_MSR, d+1);
 	if (r < 0)
 		goto mget_out;
 
-	r = (d[0] & SERIAL_MCR_DTR ? TIOCM_DTR : 0) |
-		(d[0] & SERIAL_MCR_RTS ? TIOCM_RTS : 0) |
-		(d[1] & SERIAL_MSR_CTS ? TIOCM_CTS : 0) |
-		(d[1] & SERIAL_MSR_CD ? TIOCM_CAR : 0) |
-		(d[1] & SERIAL_MSR_RI ? TIOCM_RI : 0) |
-		(d[1] & SERIAL_MSR_DSR ? TIOCM_DSR : 0);
+	r = (d[0] & UART_MCR_DTR ? TIOCM_DTR : 0) |
+		(d[0] & UART_MCR_RTS ? TIOCM_RTS : 0) |
+		(d[1] & UART_MSR_CTS ? TIOCM_CTS : 0) |
+		(d[1] & UART_MSR_DCD ? TIOCM_CAR : 0) |
+		(d[1] & UART_MSR_RI ? TIOCM_RI : 0) |
+		(d[1] & UART_MSR_DSR ? TIOCM_DSR : 0);
 
 mget_out:
 	kfree(d);
@@ -579,10 +555,10 @@ static int ssu100_process_packet(struct tty_struct *tty,
 	    (packet[0] == 0x1b) && (packet[1] == 0x1b) &&
 	    ((packet[2] == 0x00) || (packet[2] == 0x01))) {
 		if (packet[2] == 0x00)
-			priv->shadowLSR = packet[3] & (SERIAL_LSR_OE |
-						       SERIAL_LSR_PE |
-						       SERIAL_LSR_FE |
-						       SERIAL_LSR_BI);
+			priv->shadowLSR = packet[3] & (UART_LSR_OE |
+						       UART_LSR_PE |
+						       UART_LSR_FE |
+						       UART_LSR_BI);
 
 		if (packet[2] == 0x01) {
 			priv->shadowMSR = packet[3];

commit 9b2cef31f2823558eb92a35624d37439599f3f9f
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Aug 5 17:01:06 2010 -0400

    USB: ssu100: refine process_packet in ssu100
    
    The status information does not appear at the start of each incoming
    packet so the check for len < 4 at the start of ssu100_process_packet
    is wrong.  Remove it.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ssu100.c b/drivers/usb/serial/ssu100.c
index 2826f013752d..c7193880a2b6 100644
--- a/drivers/usb/serial/ssu100.c
+++ b/drivers/usb/serial/ssu100.c
@@ -575,12 +575,8 @@ static int ssu100_process_packet(struct tty_struct *tty,
 
 	dbg("%s - port %d", __func__, port->number);
 
-	if (len < 4) {
-		dbg("%s - malformed packet", __func__);
-		return 0;
-	}
-
-	if ((packet[0] == 0x1b) && (packet[1] == 0x1b) &&
+	if ((len >= 4) &&
+	    (packet[0] == 0x1b) && (packet[1] == 0x1b) &&
 	    ((packet[2] == 0x00) || (packet[2] == 0x01))) {
 		if (packet[2] == 0x00)
 			priv->shadowLSR = packet[3] & (SERIAL_LSR_OE |

commit 175230587bcca6dee0a1d6832a8a2138e32ab6ab
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Aug 5 17:01:05 2010 -0400

    USB: ssu100: add locking for port private data in ssu100
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ssu100.c b/drivers/usb/serial/ssu100.c
index 6e82d4f54bc8..2826f013752d 100644
--- a/drivers/usb/serial/ssu100.c
+++ b/drivers/usb/serial/ssu100.c
@@ -99,6 +99,7 @@ static struct usb_driver ssu100_driver = {
 };
 
 struct ssu100_port_private {
+	spinlock_t status_lock;
 	u8 shadowLSR;
 	u8 shadowMSR;
 	wait_queue_head_t delta_msr_wait; /* Used for TIOCMIWAIT */
@@ -333,6 +334,7 @@ static int ssu100_open(struct tty_struct *tty, struct usb_serial_port *port)
 	struct ssu100_port_private *priv = usb_get_serial_port_data(port);
 	u8 *data;
 	int result;
+	unsigned long flags;
 
 	dbg("%s - port %d", __func__, port->number);
 
@@ -350,11 +352,13 @@ static int ssu100_open(struct tty_struct *tty, struct usb_serial_port *port)
 		return result;
 	}
 
+	spin_lock_irqsave(&priv->status_lock, flags);
 	priv->shadowLSR = data[0]  & (SERIAL_LSR_OE | SERIAL_LSR_PE |
 				      SERIAL_LSR_FE | SERIAL_LSR_BI);
 
 	priv->shadowMSR = data[1]  & (SERIAL_MSR_CTS | SERIAL_MSR_DSR |
 				      SERIAL_MSR_RI | SERIAL_MSR_CD);
+	spin_unlock_irqrestore(&priv->status_lock, flags);
 
 	kfree(data);
 
@@ -455,6 +459,7 @@ static void ssu100_set_max_packet_size(struct usb_serial_port *port)
 
 	unsigned num_endpoints;
 	int i;
+	unsigned long flags;
 
 	num_endpoints = interface->cur_altsetting->desc.bNumEndpoints;
 	dev_info(&udev->dev, "Number of endpoints %d\n", num_endpoints);
@@ -466,7 +471,9 @@ static void ssu100_set_max_packet_size(struct usb_serial_port *port)
 	}
 
 	/* set max packet size based on descriptor */
+	spin_lock_irqsave(&priv->status_lock, flags);
 	priv->max_packet_size = ep_desc->wMaxPacketSize;
+	spin_unlock_irqrestore(&priv->status_lock, flags);
 
 	dev_info(&udev->dev, "Setting MaxPacketSize %d\n", priv->max_packet_size);
 }
@@ -485,9 +492,9 @@ static int ssu100_attach(struct usb_serial *serial)
 		return -ENOMEM;
 	}
 
+	spin_lock_init(&priv->status_lock);
 	init_waitqueue_head(&priv->delta_msr_wait);
 	usb_set_serial_port_data(port, priv);
-
 	ssu100_set_max_packet_size(port);
 
 	return ssu100_initdevice(serial->dev);

commit 6ee9f4b4affe751d313d2538999aeec134d413a6
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Tue Aug 17 21:15:47 2010 -0700

    USB: drop tty argument from usb_serial_handle_sysrq_char()
    
    Since handle_sysrq() does not take tty as argument anymore we can
    drop it from usb_serial_handle_sysrq_char() as well.
    
    Acked-by: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Acked-by: Jason Wessel <jason.wessel@windriver.com>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/usb/serial/ssu100.c b/drivers/usb/serial/ssu100.c
index 6e82d4f54bc8..819de4740388 100644
--- a/drivers/usb/serial/ssu100.c
+++ b/drivers/usb/serial/ssu100.c
@@ -596,7 +596,7 @@ static int ssu100_process_packet(struct tty_struct *tty,
 
 	if (port->port.console && port->sysrq) {
 		for (i = 0; i < len; i++, ch++) {
-			if (!usb_serial_handle_sysrq_char(tty, port, *ch))
+			if (!usb_serial_handle_sysrq_char(port, *ch))
 				tty_insert_flip_char(tty, *ch, flag);
 		}
 	} else

commit 52af954599396e5945a895035525c703f2761b20
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Thu Jul 29 11:05:41 2010 -0400

    USB: add USB serial ssu100 driver
    
    Add support for the Quatech SSU-100 single port usb to serial device.
    This driver is based on the ftdi_sio.c driver and the original
    serqt_usb driver from Quatech.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/serial/ssu100.c b/drivers/usb/serial/ssu100.c
new file mode 100644
index 000000000000..6e82d4f54bc8
--- /dev/null
+++ b/drivers/usb/serial/ssu100.c
@@ -0,0 +1,698 @@
+/*
+ * usb-serial driver for Quatech SSU-100
+ *
+ * based on ftdi_sio.c and the original serqt_usb.c from Quatech
+ *
+ */
+
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/tty.h>
+#include <linux/tty_driver.h>
+#include <linux/tty_flip.h>
+#include <linux/module.h>
+#include <linux/serial.h>
+#include <linux/usb.h>
+#include <linux/usb/serial.h>
+#include <linux/uaccess.h>
+
+#define QT_OPEN_CLOSE_CHANNEL       0xca
+#define QT_SET_GET_DEVICE           0xc2
+#define QT_SET_GET_REGISTER         0xc0
+#define QT_GET_SET_PREBUF_TRIG_LVL  0xcc
+#define QT_SET_ATF                  0xcd
+#define QT_GET_SET_UART             0xc1
+#define QT_TRANSFER_IN              0xc0
+#define QT_HW_FLOW_CONTROL_MASK     0xc5
+#define QT_SW_FLOW_CONTROL_MASK     0xc6
+
+#define MODEM_CTL_REGISTER         0x04
+#define MODEM_STATUS_REGISTER      0x06
+
+
+#define SERIAL_LSR_OE       0x02
+#define SERIAL_LSR_PE       0x04
+#define SERIAL_LSR_FE       0x08
+#define SERIAL_LSR_BI       0x10
+
+#define SERIAL_LSR_TEMT     0x40
+
+#define  SERIAL_MCR_DTR             0x01
+#define  SERIAL_MCR_RTS             0x02
+#define  SERIAL_MCR_LOOP            0x10
+
+#define  SERIAL_MSR_CTS             0x10
+#define  SERIAL_MSR_CD              0x80
+#define  SERIAL_MSR_RI              0x40
+#define  SERIAL_MSR_DSR             0x20
+#define  SERIAL_MSR_MASK            0xf0
+
+#define  SERIAL_CRTSCTS ((SERIAL_MCR_RTS << 8) | SERIAL_MSR_CTS)
+
+#define  SERIAL_8_DATA              0x03
+#define  SERIAL_7_DATA              0x02
+#define  SERIAL_6_DATA              0x01
+#define  SERIAL_5_DATA              0x00
+
+#define  SERIAL_ODD_PARITY          0X08
+#define  SERIAL_EVEN_PARITY         0X18
+
+#define  MAX_BAUD_RATE              460800
+
+#define ATC_DISABLED                0x00
+#define DUPMODE_BITS        0xc0
+#define RR_BITS             0x03
+#define LOOPMODE_BITS       0x41
+#define RS232_MODE          0x00
+#define RTSCTS_TO_CONNECTOR 0x40
+#define CLKS_X4             0x02
+#define FULLPWRBIT          0x00000080
+#define NEXT_BOARD_POWER_BIT        0x00000004
+
+static int debug = 1;
+
+/* Version Information */
+#define DRIVER_VERSION "v0.1"
+#define DRIVER_DESC "Quatech SSU-100 USB to Serial Driver"
+
+#define	USB_VENDOR_ID_QUATECH	0x061d	/* Quatech VID */
+#define QUATECH_SSU100	0xC020	/* SSU100 */
+
+static const struct usb_device_id id_table[] = {
+	{USB_DEVICE(USB_VENDOR_ID_QUATECH, QUATECH_SSU100)},
+	{}			/* Terminating entry */
+};
+
+MODULE_DEVICE_TABLE(usb, id_table);
+
+
+static struct usb_driver ssu100_driver = {
+	.name			       = "ssu100",
+	.probe			       = usb_serial_probe,
+	.disconnect		       = usb_serial_disconnect,
+	.id_table		       = id_table,
+	.suspend		       = usb_serial_suspend,
+	.resume			       = usb_serial_resume,
+	.no_dynamic_id		       = 1,
+	.supports_autosuspend	       = 1,
+};
+
+struct ssu100_port_private {
+	u8 shadowLSR;
+	u8 shadowMSR;
+	wait_queue_head_t delta_msr_wait; /* Used for TIOCMIWAIT */
+	unsigned short max_packet_size;
+};
+
+static void ssu100_release(struct usb_serial *serial)
+{
+	struct ssu100_port_private *priv = usb_get_serial_port_data(*serial->port);
+
+	dbg("%s", __func__);
+	kfree(priv);
+}
+
+static inline int ssu100_control_msg(struct usb_device *dev,
+				     u8 request, u16 data, u16 index)
+{
+	return usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
+			       request, 0x40, data, index,
+			       NULL, 0, 300);
+}
+
+static inline int ssu100_setdevice(struct usb_device *dev, u8 *data)
+{
+	u16 x = ((u16)(data[1] << 8) | (u16)(data[0]));
+
+	return ssu100_control_msg(dev, QT_SET_GET_DEVICE, x, 0);
+}
+
+
+static inline int ssu100_getdevice(struct usb_device *dev, u8 *data)
+{
+	return usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),
+			       QT_SET_GET_DEVICE, 0xc0, 0, 0,
+			       data, 3, 300);
+}
+
+static inline int ssu100_getregister(struct usb_device *dev,
+				     unsigned short uart,
+				     unsigned short reg,
+				     u8 *data)
+{
+	return usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),
+			       QT_SET_GET_REGISTER, 0xc0, reg,
+			       uart, data, sizeof(*data), 300);
+
+}
+
+
+static inline int ssu100_setregister(struct usb_device *dev,
+				     unsigned short uart,
+				     u16 data)
+{
+	u16 value = (data << 8) | MODEM_CTL_REGISTER;
+
+	return usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
+			       QT_SET_GET_REGISTER, 0x40, value, uart,
+			       NULL, 0, 300);
+
+}
+
+#define set_mctrl(dev, set)		update_mctrl((dev), (set), 0)
+#define clear_mctrl(dev, clear)	update_mctrl((dev), 0, (clear))
+
+/* these do not deal with device that have more than 1 port */
+static inline int update_mctrl(struct usb_device *dev, unsigned int set,
+			       unsigned int clear)
+{
+	unsigned urb_value;
+	int result;
+
+	if (((set | clear) & (TIOCM_DTR | TIOCM_RTS)) == 0) {
+		dbg("%s - DTR|RTS not being set|cleared", __func__);
+		return 0;	/* no change */
+	}
+
+	clear &= ~set;	/* 'set' takes precedence over 'clear' */
+	urb_value = 0;
+	if (set & TIOCM_DTR)
+		urb_value |= SERIAL_MCR_DTR;
+	if (set & TIOCM_RTS)
+		urb_value |= SERIAL_MCR_RTS;
+
+	result = ssu100_setregister(dev, 0, urb_value);
+	if (result < 0)
+		dbg("%s Error from MODEM_CTRL urb", __func__);
+
+	return result;
+}
+
+static int ssu100_initdevice(struct usb_device *dev)
+{
+	u8 *data;
+	int result = 0;
+
+	dbg("%s", __func__);
+
+	data = kzalloc(3, GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	result = ssu100_getdevice(dev, data);
+	if (result < 0) {
+		dbg("%s - get_device failed %i", __func__, result);
+		goto out;
+	}
+
+	data[1] &= ~FULLPWRBIT;
+
+	result = ssu100_setdevice(dev, data);
+	if (result < 0) {
+		dbg("%s - setdevice failed %i", __func__, result);
+		goto out;
+	}
+
+	result = ssu100_control_msg(dev, QT_GET_SET_PREBUF_TRIG_LVL, 128, 0);
+	if (result < 0) {
+		dbg("%s - set prebuffer level failed %i", __func__, result);
+		goto out;
+	}
+
+	result = ssu100_control_msg(dev, QT_SET_ATF, ATC_DISABLED, 0);
+	if (result < 0) {
+		dbg("%s - set ATFprebuffer level failed %i", __func__, result);
+		goto out;
+	}
+
+	result = ssu100_getdevice(dev, data);
+	if (result < 0) {
+		dbg("%s - get_device failed %i", __func__, result);
+		goto out;
+	}
+
+	data[0] &= ~(RR_BITS | DUPMODE_BITS);
+	data[0] |= CLKS_X4;
+	data[1] &= ~(LOOPMODE_BITS);
+	data[1] |= RS232_MODE;
+
+	result = ssu100_setdevice(dev, data);
+	if (result < 0) {
+		dbg("%s - setdevice failed %i", __func__, result);
+		goto out;
+	}
+
+out:	kfree(data);
+	return result;
+
+}
+
+
+static void ssu100_set_termios(struct tty_struct *tty,
+			       struct usb_serial_port *port,
+			       struct ktermios *old_termios)
+{
+	struct usb_device *dev = port->serial->dev;
+	struct ktermios *termios = tty->termios;
+	u16 baud, divisor, remainder;
+	unsigned int cflag = termios->c_cflag;
+	u16 urb_value = 0; /* will hold the new flags */
+	int result;
+
+	dbg("%s", __func__);
+
+	if (cflag & PARENB) {
+		if (cflag & PARODD)
+			urb_value |= SERIAL_ODD_PARITY;
+		else
+			urb_value |= SERIAL_EVEN_PARITY;
+	}
+
+	switch (cflag & CSIZE) {
+	case CS5:
+		urb_value |= SERIAL_5_DATA;
+		break;
+	case CS6:
+		urb_value |= SERIAL_6_DATA;
+		break;
+	case CS7:
+		urb_value |= SERIAL_7_DATA;
+		break;
+	default:
+	case CS8:
+		urb_value |= SERIAL_8_DATA;
+		break;
+	}
+
+	baud = tty_get_baud_rate(tty);
+	if (!baud)
+		baud = 9600;
+
+	dbg("%s - got baud = %d\n", __func__, baud);
+
+
+	divisor = MAX_BAUD_RATE / baud;
+	remainder = MAX_BAUD_RATE % baud;
+	if (((remainder * 2) >= baud) && (baud != 110))
+		divisor++;
+
+	urb_value = urb_value << 8;
+
+	result = ssu100_control_msg(dev, QT_GET_SET_UART, divisor, urb_value);
+	if (result < 0)
+		dbg("%s - set uart failed", __func__);
+
+	if (cflag & CRTSCTS)
+		result = ssu100_control_msg(dev, QT_HW_FLOW_CONTROL_MASK,
+					    SERIAL_CRTSCTS, 0);
+	else
+		result = ssu100_control_msg(dev, QT_HW_FLOW_CONTROL_MASK,
+					    0, 0);
+	if (result < 0)
+		dbg("%s - set HW flow control failed", __func__);
+
+	if (I_IXOFF(tty) || I_IXON(tty)) {
+		u16 x = ((u16)(START_CHAR(tty) << 8) | (u16)(STOP_CHAR(tty)));
+
+		result = ssu100_control_msg(dev, QT_SW_FLOW_CONTROL_MASK,
+					    x, 0);
+	} else
+		result = ssu100_control_msg(dev, QT_SW_FLOW_CONTROL_MASK,
+					    0, 0);
+
+	if (result < 0)
+		dbg("%s - set SW flow control failed", __func__);
+
+}
+
+
+static int ssu100_open(struct tty_struct *tty, struct usb_serial_port *port)
+{
+	struct usb_device *dev = port->serial->dev;
+	struct ssu100_port_private *priv = usb_get_serial_port_data(port);
+	u8 *data;
+	int result;
+
+	dbg("%s - port %d", __func__, port->number);
+
+	data = kzalloc(2, GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	result = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),
+				 QT_OPEN_CLOSE_CHANNEL,
+				 QT_TRANSFER_IN, 0x01,
+				 0, data, 2, 300);
+	if (result < 0) {
+		dbg("%s - open failed %i", __func__, result);
+		kfree(data);
+		return result;
+	}
+
+	priv->shadowLSR = data[0]  & (SERIAL_LSR_OE | SERIAL_LSR_PE |
+				      SERIAL_LSR_FE | SERIAL_LSR_BI);
+
+	priv->shadowMSR = data[1]  & (SERIAL_MSR_CTS | SERIAL_MSR_DSR |
+				      SERIAL_MSR_RI | SERIAL_MSR_CD);
+
+	kfree(data);
+
+/* set to 9600 */
+	result = ssu100_control_msg(dev, QT_GET_SET_UART, 0x30, 0x0300);
+	if (result < 0)
+		dbg("%s - set uart failed", __func__);
+
+	if (tty)
+		ssu100_set_termios(tty, port, tty->termios);
+
+	return usb_serial_generic_open(tty, port);
+}
+
+static void ssu100_close(struct usb_serial_port *port)
+{
+	dbg("%s", __func__);
+	usb_serial_generic_close(port);
+}
+
+static int get_serial_info(struct usb_serial_port *port,
+			   struct serial_struct __user *retinfo)
+{
+	struct serial_struct tmp;
+
+	if (!retinfo)
+		return -EFAULT;
+
+	memset(&tmp, 0, sizeof(tmp));
+	tmp.line		= port->serial->minor;
+	tmp.port		= 0;
+	tmp.irq			= 0;
+	tmp.flags		= ASYNC_SKIP_TEST | ASYNC_AUTO_IRQ;
+	tmp.xmit_fifo_size	= port->bulk_out_size;
+	tmp.baud_base		= 9600;
+	tmp.close_delay		= 5*HZ;
+	tmp.closing_wait	= 30*HZ;
+
+	if (copy_to_user(retinfo, &tmp, sizeof(*retinfo)))
+		return -EFAULT;
+	return 0;
+}
+
+static int ssu100_ioctl(struct tty_struct *tty, struct file *file,
+		    unsigned int cmd, unsigned long arg)
+{
+	struct usb_serial_port *port = tty->driver_data;
+	struct ssu100_port_private *priv = usb_get_serial_port_data(port);
+
+	dbg("%s cmd 0x%04x", __func__, cmd);
+
+	switch (cmd) {
+	case TIOCGSERIAL:
+		return get_serial_info(port,
+				       (struct serial_struct __user *) arg);
+
+	case TIOCMIWAIT:
+		while (priv != NULL) {
+			u8 prevMSR = priv->shadowMSR & SERIAL_MSR_MASK;
+			interruptible_sleep_on(&priv->delta_msr_wait);
+			/* see if a signal did it */
+			if (signal_pending(current))
+				return -ERESTARTSYS;
+			else {
+				u8 diff = (priv->shadowMSR & SERIAL_MSR_MASK) ^ prevMSR;
+				if (!diff)
+					return -EIO; /* no change => error */
+
+				/* Return 0 if caller wanted to know about
+				   these bits */
+
+				if (((arg & TIOCM_RNG) && (diff & SERIAL_MSR_RI)) ||
+				    ((arg & TIOCM_DSR) && (diff & SERIAL_MSR_DSR)) ||
+				    ((arg & TIOCM_CD) && (diff & SERIAL_MSR_CD)) ||
+				    ((arg & TIOCM_CTS) && (diff & SERIAL_MSR_CTS)))
+					return 0;
+			}
+		}
+		return 0;
+
+	default:
+		break;
+	}
+
+	dbg("%s arg not supported", __func__);
+
+	return -ENOIOCTLCMD;
+}
+
+static void ssu100_set_max_packet_size(struct usb_serial_port *port)
+{
+	struct ssu100_port_private *priv = usb_get_serial_port_data(port);
+	struct usb_serial *serial = port->serial;
+	struct usb_device *udev = serial->dev;
+
+	struct usb_interface *interface = serial->interface;
+	struct usb_endpoint_descriptor *ep_desc = &interface->cur_altsetting->endpoint[1].desc;
+
+	unsigned num_endpoints;
+	int i;
+
+	num_endpoints = interface->cur_altsetting->desc.bNumEndpoints;
+	dev_info(&udev->dev, "Number of endpoints %d\n", num_endpoints);
+
+	for (i = 0; i < num_endpoints; i++) {
+		dev_info(&udev->dev, "Endpoint %d MaxPacketSize %d\n", i+1,
+			interface->cur_altsetting->endpoint[i].desc.wMaxPacketSize);
+		ep_desc = &interface->cur_altsetting->endpoint[i].desc;
+	}
+
+	/* set max packet size based on descriptor */
+	priv->max_packet_size = ep_desc->wMaxPacketSize;
+
+	dev_info(&udev->dev, "Setting MaxPacketSize %d\n", priv->max_packet_size);
+}
+
+static int ssu100_attach(struct usb_serial *serial)
+{
+	struct ssu100_port_private *priv;
+	struct usb_serial_port *port = *serial->port;
+
+	dbg("%s", __func__);
+
+	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
+	if (!priv) {
+		dev_err(&port->dev, "%s- kmalloc(%Zd) failed.\n", __func__,
+			sizeof(*priv));
+		return -ENOMEM;
+	}
+
+	init_waitqueue_head(&priv->delta_msr_wait);
+	usb_set_serial_port_data(port, priv);
+
+	ssu100_set_max_packet_size(port);
+
+	return ssu100_initdevice(serial->dev);
+}
+
+static int ssu100_tiocmget(struct tty_struct *tty, struct file *file)
+{
+	struct usb_serial_port *port = tty->driver_data;
+	struct usb_device *dev = port->serial->dev;
+	u8 *d;
+	int r;
+
+	dbg("%s\n", __func__);
+
+	d = kzalloc(2, GFP_KERNEL);
+	if (!d)
+		return -ENOMEM;
+
+	r = ssu100_getregister(dev, 0, MODEM_CTL_REGISTER, d);
+	if (r < 0)
+		goto mget_out;
+
+	r = ssu100_getregister(dev, 0, MODEM_STATUS_REGISTER, d+1);
+	if (r < 0)
+		goto mget_out;
+
+	r = (d[0] & SERIAL_MCR_DTR ? TIOCM_DTR : 0) |
+		(d[0] & SERIAL_MCR_RTS ? TIOCM_RTS : 0) |
+		(d[1] & SERIAL_MSR_CTS ? TIOCM_CTS : 0) |
+		(d[1] & SERIAL_MSR_CD ? TIOCM_CAR : 0) |
+		(d[1] & SERIAL_MSR_RI ? TIOCM_RI : 0) |
+		(d[1] & SERIAL_MSR_DSR ? TIOCM_DSR : 0);
+
+mget_out:
+	kfree(d);
+	return r;
+}
+
+static int ssu100_tiocmset(struct tty_struct *tty, struct file *file,
+			   unsigned int set, unsigned int clear)
+{
+	struct usb_serial_port *port = tty->driver_data;
+	struct usb_device *dev = port->serial->dev;
+
+	dbg("%s\n", __func__);
+	return update_mctrl(dev, set, clear);
+}
+
+static void ssu100_dtr_rts(struct usb_serial_port *port, int on)
+{
+	struct usb_device *dev = port->serial->dev;
+
+	dbg("%s\n", __func__);
+
+	mutex_lock(&port->serial->disc_mutex);
+	if (!port->serial->disconnected) {
+		/* Disable flow control */
+		if (!on &&
+		    ssu100_setregister(dev, 0, 0) < 0)
+			dev_err(&port->dev, "error from flowcontrol urb\n");
+		/* drop RTS and DTR */
+		if (on)
+			set_mctrl(dev, TIOCM_DTR | TIOCM_RTS);
+		else
+			clear_mctrl(dev, TIOCM_DTR | TIOCM_RTS);
+	}
+	mutex_unlock(&port->serial->disc_mutex);
+}
+
+static int ssu100_process_packet(struct tty_struct *tty,
+				 struct usb_serial_port *port,
+				 struct ssu100_port_private *priv,
+				 char *packet, int len)
+{
+	int i;
+	char flag;
+	char *ch;
+
+	dbg("%s - port %d", __func__, port->number);
+
+	if (len < 4) {
+		dbg("%s - malformed packet", __func__);
+		return 0;
+	}
+
+	if ((packet[0] == 0x1b) && (packet[1] == 0x1b) &&
+	    ((packet[2] == 0x00) || (packet[2] == 0x01))) {
+		if (packet[2] == 0x00)
+			priv->shadowLSR = packet[3] & (SERIAL_LSR_OE |
+						       SERIAL_LSR_PE |
+						       SERIAL_LSR_FE |
+						       SERIAL_LSR_BI);
+
+		if (packet[2] == 0x01) {
+			priv->shadowMSR = packet[3];
+			wake_up_interruptible(&priv->delta_msr_wait);
+		}
+
+		len -= 4;
+		ch = packet + 4;
+	} else
+		ch = packet;
+
+	if (!len)
+		return 0;	/* status only */
+
+	if (port->port.console && port->sysrq) {
+		for (i = 0; i < len; i++, ch++) {
+			if (!usb_serial_handle_sysrq_char(tty, port, *ch))
+				tty_insert_flip_char(tty, *ch, flag);
+		}
+	} else
+		tty_insert_flip_string_fixed_flag(tty, ch, flag, len);
+
+	return len;
+}
+
+static void ssu100_process_read_urb(struct urb *urb)
+{
+	struct usb_serial_port *port = urb->context;
+	struct ssu100_port_private *priv = usb_get_serial_port_data(port);
+	char *data = (char *)urb->transfer_buffer;
+	struct tty_struct *tty;
+	int count = 0;
+	int i;
+	int len;
+
+	dbg("%s", __func__);
+
+	tty = tty_port_tty_get(&port->port);
+	if (!tty)
+		return;
+
+	for (i = 0; i < urb->actual_length; i += priv->max_packet_size) {
+		len = min_t(int, urb->actual_length - i, priv->max_packet_size);
+		count += ssu100_process_packet(tty, port, priv, &data[i], len);
+	}
+
+	if (count)
+		tty_flip_buffer_push(tty);
+	tty_kref_put(tty);
+}
+
+
+static struct usb_serial_driver ssu100_device = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "ssu100",
+	},
+	.description	     = DRIVER_DESC,
+	.id_table	     = id_table,
+	.usb_driver	     = &ssu100_driver,
+	.num_ports	     = 1,
+	.bulk_in_size        = 256,
+	.bulk_out_size       = 256,
+	.open		     = ssu100_open,
+	.close		     = ssu100_close,
+	.attach              = ssu100_attach,
+	.release             = ssu100_release,
+	.dtr_rts             = ssu100_dtr_rts,
+	.process_read_urb    = ssu100_process_read_urb,
+	.tiocmget            = ssu100_tiocmget,
+	.tiocmset            = ssu100_tiocmset,
+	.ioctl               = ssu100_ioctl,
+	.set_termios         = ssu100_set_termios,
+};
+
+static int __init ssu100_init(void)
+{
+	int retval;
+
+	dbg("%s", __func__);
+
+	/* register with usb-serial */
+	retval = usb_serial_register(&ssu100_device);
+
+	if (retval)
+		goto failed_usb_sio_register;
+
+	retval = usb_register(&ssu100_driver);
+	if (retval)
+		goto failed_usb_register;
+
+	printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
+	       DRIVER_DESC "\n");
+
+	return 0;
+
+failed_usb_register:
+	usb_serial_deregister(&ssu100_device);
+failed_usb_sio_register:
+	return retval;
+}
+
+static void __exit ssu100_exit(void)
+{
+	usb_deregister(&ssu100_driver);
+	usb_serial_deregister(&ssu100_device);
+}
+
+module_init(ssu100_init);
+module_exit(ssu100_exit);
+
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_LICENSE("GPL");
+
+module_param(debug, bool, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(debug, "Debug enabled or not");
