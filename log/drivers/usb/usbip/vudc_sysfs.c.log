commit 91148dbad80bb6024389287be4aefcbf20b2d0e4
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Aug 5 21:36:35 2019 +0200

    USB: usbip: convert platform driver to use dev_groups
    
    Platform drivers now have the option to have the platform core create
    and remove any needed sysfs attribute files.  So take advantage of that
    and do not register "by hand" any sysfs files.
    
    Cc: Valentina Manea <valentina.manea.m@gmail.com>
    Acked-by: Shuah Khan <skhan@linuxfoundation.org>
    Link: https://lore.kernel.org/r/20190805193636.25560-5-gregkh@linuxfoundation.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/usbip/vudc_sysfs.c b/drivers/usb/usbip/vudc_sysfs.c
index 6dcd3ff655c3..100f680c572a 100644
--- a/drivers/usb/usbip/vudc_sysfs.c
+++ b/drivers/usb/usbip/vudc_sysfs.c
@@ -215,7 +215,12 @@ static struct bin_attribute *dev_bin_attrs[] = {
 	NULL,
 };
 
-const struct attribute_group vudc_attr_group = {
+static const struct attribute_group vudc_attr_group = {
 	.attrs = dev_attrs,
 	.bin_attrs = dev_bin_attrs,
 };
+
+const struct attribute_group *vudc_groups[] = {
+	&vudc_attr_group,
+	NULL,
+};

commit df3334c223a033f562645712e832ca4cbb326bbf
Author: Colin Ian King <colin.king@canonical.com>
Date:   Thu Feb 22 17:39:17 2018 +0000

    usbip: vudc: fix null pointer dereference on udc->lock
    
    Currently the driver attempts to spin lock on udc->lock before a NULL
    pointer check is performed on udc, hence there is a potential null
    pointer dereference on udc->lock.  Fix this by moving the null check
    on udc before the lock occurs.
    
    Fixes: ea6873a45a22 ("usbip: vudc: Add SysFS infrastructure for VUDC")
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Acked-by: Shuah Khan <shuahkh@osg.samsung.com>
    Reviewed-by: Krzysztof Opasiak <k.opasiak@samsung.com>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/usbip/vudc_sysfs.c b/drivers/usb/usbip/vudc_sysfs.c
index d86f72bbbb91..6dcd3ff655c3 100644
--- a/drivers/usb/usbip/vudc_sysfs.c
+++ b/drivers/usb/usbip/vudc_sysfs.c
@@ -105,10 +105,14 @@ static ssize_t usbip_sockfd_store(struct device *dev, struct device_attribute *a
 	if (rv != 0)
 		return -EINVAL;
 
+	if (!udc) {
+		dev_err(dev, "no device");
+		return -ENODEV;
+	}
 	spin_lock_irqsave(&udc->lock, flags);
 	/* Don't export what we don't have */
-	if (!udc || !udc->driver || !udc->pullup) {
-		dev_err(dev, "no device or gadget not bound");
+	if (!udc->driver || !udc->pullup) {
+		dev_err(dev, "gadget not bound");
 		ret = -ENODEV;
 		goto unlock;
 	}

commit ca35910a1ba21e45368640ac4d884536649966d9
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Jan 23 11:24:07 2018 +0100

    USB: move many drivers to use DEVICE_ATTR_WO
    
    Instead of "open coding" a DEVICE_ATTR() define, use the
    DEVICE_ATTR_WO() macro instead, which does everything properly instead.
    
    This does require a few static functions to be renamed to work properly,
    but thanks to a script from Joe Perches, this was easily done.
    
    Reported-by: Joe Perches <joe@perches.com>
    Cc: Peter Chen <Peter.Chen@nxp.com>
    Cc: Valentina Manea <valentina.manea.m@gmail.com>
    Acked-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Acked-by: Johan Hovold <johan@kernel.org>
    Acked-by: Shuah Khan <shuahkh@osg.samsung.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/usbip/vudc_sysfs.c b/drivers/usb/usbip/vudc_sysfs.c
index 1adc8af292ec..d86f72bbbb91 100644
--- a/drivers/usb/usbip/vudc_sysfs.c
+++ b/drivers/usb/usbip/vudc_sysfs.c
@@ -90,7 +90,7 @@ static ssize_t dev_desc_read(struct file *file, struct kobject *kobj,
 }
 static BIN_ATTR_RO(dev_desc, sizeof(struct usb_device_descriptor));
 
-static ssize_t store_sockfd(struct device *dev, struct device_attribute *attr,
+static ssize_t usbip_sockfd_store(struct device *dev, struct device_attribute *attr,
 		     const char *in, size_t count)
 {
 	struct vudc *udc = (struct vudc *) dev_get_drvdata(dev);
@@ -180,7 +180,7 @@ static ssize_t store_sockfd(struct device *dev, struct device_attribute *attr,
 
 	return ret;
 }
-static DEVICE_ATTR(usbip_sockfd, S_IWUSR, NULL, store_sockfd);
+static DEVICE_ATTR_WO(usbip_sockfd);
 
 static ssize_t usbip_status_show(struct device *dev,
 			       struct device_attribute *attr, char *out)

commit 7f2b019c8d8b0330c142a5934dd77089d5282c74
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Nov 6 15:37:11 2017 +0100

    USB: usbip: Remove redundant license text
    
    Now that the SPDX tag is in all USB files, that identifies the license
    in a specific and legally-defined manner.  So the extra GPL text wording
    can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Valentina Manea <valentina.manea.m@gmail.com>
    Acked-by: Shuah Khan <shuahkh@osg.samsung.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/usbip/vudc_sysfs.c b/drivers/usb/usbip/vudc_sysfs.c
index 49e0123caa53..1adc8af292ec 100644
--- a/drivers/usb/usbip/vudc_sysfs.c
+++ b/drivers/usb/usbip/vudc_sysfs.c
@@ -4,19 +4,6 @@
  * Copyright (C) 2015-2016 Samsung Electronics
  *               Igor Kotrasinski <i.kotrasinsk@samsung.com>
  *               Krzysztof Opasiak <k.opasiak@samsung.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program. If not, see <http://www.gnu.org/licenses/>.
  */
 
 #include <linux/device.h>

commit 6c51441cd0710330ccdb8dd0288e5316256d1c8e
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Nov 7 11:39:57 2017 +0100

    usbip: use monotonic timestamps
    
    This gets rid of the deprecated do_gettimeofday() function in usbip.
    The comment above vgadget_get_frame() mentions that it suffers
    from issues with the time jumps due to suspend and settimeofday,
    so I'm changing it to use ktime_get_ts64() to use monotonic times
    that don't have this problem.
    
    I couldn't tell whether we should use CLOCK_MONOTONIC or
    CLOCK_MONOTONIC_RAW here, the difference being the exact rate
    when correcting for NTP. I picked monotonic time since it doesn't
    change the speed to the existing code and should be better
    synchronized with other machines we talk to.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Reviewed-by: Krzysztof Opasiak <k.opasiak@samsung.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/usbip/vudc_sysfs.c b/drivers/usb/usbip/vudc_sysfs.c
index 7d978b824ed4..49e0123caa53 100644
--- a/drivers/usb/usbip/vudc_sysfs.c
+++ b/drivers/usb/usbip/vudc_sysfs.c
@@ -162,7 +162,7 @@ static ssize_t store_sockfd(struct device *dev, struct device_attribute *attr,
 		udc->ud.status = SDEV_ST_USED;
 		spin_unlock_irq(&udc->ud.lock);
 
-		do_gettimeofday(&udc->start_time);
+		ktime_get_ts64(&udc->start_time);
 		v_start_timer(udc);
 		udc->connected = 1;
 	} else {

commit 5fd54ace4721fc5ce2bb5aef6318fcf17f421460
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Nov 3 11:28:30 2017 +0100

    USB: add SPDX identifiers to all remaining files in drivers/usb/
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/usb/ and include/linux/usb* files with the correct
    SPDX license identifier based on the license text in the file itself.
    The SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Acked-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/usbip/vudc_sysfs.c b/drivers/usb/usbip/vudc_sysfs.c
index 0f98f2c7475f..7d978b824ed4 100644
--- a/drivers/usb/usbip/vudc_sysfs.c
+++ b/drivers/usb/usbip/vudc_sysfs.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  * Copyright (C) 2015 Karol Kosik <karo9@interia.eu>
  * Copyright (C) 2015-2016 Samsung Electronics

commit 7c348f1cfb6d8c6911fcb6d13b4c267a8bc93856
Author: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
Date:   Mon Jun 6 22:23:32 2016 +0100

    usb: usbip: remove null check
    
    The only caller of get_gadget_descs() has already dereferenced udc
    before calling this function, so udc can not be NULL at this point of
    the code and hence no use of checking it.
    
    Signed-off-by: Sudip Mukherjee <sudip.mukherjee@codethink.co.uk>
    Reviewed-by: Krzysztof Opasiak <k.opasiak@samsung.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/usbip/vudc_sysfs.c b/drivers/usb/usbip/vudc_sysfs.c
index 99397fa1e3f0..0f98f2c7475f 100644
--- a/drivers/usb/usbip/vudc_sysfs.c
+++ b/drivers/usb/usbip/vudc_sysfs.c
@@ -40,7 +40,7 @@ int get_gadget_descs(struct vudc *udc)
 	struct usb_ctrlrequest req;
 	int ret;
 
-	if (!udc || !udc->driver || !udc->pullup)
+	if (!udc->driver || !udc->pullup)
 		return -EINVAL;
 
 	req.bRequestType = USB_DIR_IN | USB_TYPE_STANDARD | USB_RECIP_DEVICE;

commit 442ee366bec3cbdaf5794e80f803d87c5787c5d8
Author: Krzysztof Opasiak <k.opasiak@samsung.com>
Date:   Fri Apr 29 12:34:13 2016 +0200

    usb: usbip: Avoid NULL pointer dereference in case of error
    
    One line above we have checked that udc is NULL so we shouldn't
    dereference it while printing error message.
    
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Krzysztof Opasiak <k.opasiak@samsung.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/usbip/vudc_sysfs.c b/drivers/usb/usbip/vudc_sysfs.c
index 40d5c8f72825..99397fa1e3f0 100644
--- a/drivers/usb/usbip/vudc_sysfs.c
+++ b/drivers/usb/usbip/vudc_sysfs.c
@@ -201,7 +201,7 @@ static ssize_t usbip_status_show(struct device *dev,
 	int status;
 
 	if (!udc) {
-		dev_err(&udc->pdev->dev, "no device");
+		dev_err(dev, "no device");
 		return -ENODEV;
 	}
 	spin_lock_irq(&udc->ud.lock);

commit 2a7a10b86c125fd3410bb975e8515ac5dddc3238
Author: Igor Kotrasinski <i.kotrasinsk@gmail.com>
Date:   Fri Apr 29 13:41:24 2016 +0200

    usbip: vudc: make dev_desc attribute binary
    
    We read a struct usb_device_descriptor from it, so make it an actual
    binary attribute.
    
    Signed-off-by: Igor Kotrasinski <i.kotrasinsk@gmail.com>
    Signed-off-by: Krzysztof Opasiak <k.opasiak@samsung.com>
    Tested-by: Krzysztof Opasiak <k.opasiak@samsung.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/usbip/vudc_sysfs.c b/drivers/usb/usbip/vudc_sysfs.c
index 25ca16ab0073..40d5c8f72825 100644
--- a/drivers/usb/usbip/vudc_sysfs.c
+++ b/drivers/usb/usbip/vudc_sysfs.c
@@ -78,10 +78,13 @@ int get_gadget_descs(struct vudc *udc)
 /*
  * Exposes device descriptor from the gadget driver.
  */
-static ssize_t dev_desc_show(struct device *dev,
-			       struct device_attribute *attr, char *out)
+static ssize_t dev_desc_read(struct file *file, struct kobject *kobj,
+			     struct bin_attribute *attr, char *out,
+			     loff_t off, size_t count)
 {
+	struct device *dev = kobj_to_dev(kobj);
 	struct vudc *udc = (struct vudc *)dev_get_drvdata(dev);
+	char *desc_ptr = (char *) &udc->dev_desc;
 	unsigned long flags;
 	int ret;
 
@@ -91,13 +94,13 @@ static ssize_t dev_desc_show(struct device *dev,
 		goto unlock;
 	}
 
-	memcpy(out, &udc->dev_desc, sizeof(udc->dev_desc));
-	ret = sizeof(udc->dev_desc);
+	memcpy(out, desc_ptr + off, count);
+	ret = count;
 unlock:
 	spin_unlock_irqrestore(&udc->lock, flags);
 	return ret;
 }
-static DEVICE_ATTR_RO(dev_desc);
+static BIN_ATTR_RO(dev_desc, sizeof(struct usb_device_descriptor));
 
 static ssize_t store_sockfd(struct device *dev, struct device_attribute *attr,
 		     const char *in, size_t count)
@@ -210,12 +213,17 @@ static ssize_t usbip_status_show(struct device *dev,
 static DEVICE_ATTR_RO(usbip_status);
 
 static struct attribute *dev_attrs[] = {
-	&dev_attr_dev_desc.attr,
 	&dev_attr_usbip_sockfd.attr,
 	&dev_attr_usbip_status.attr,
 	NULL,
 };
 
+static struct bin_attribute *dev_bin_attrs[] = {
+	&bin_attr_dev_desc,
+	NULL,
+};
+
 const struct attribute_group vudc_attr_group = {
 	.attrs = dev_attrs,
+	.bin_attrs = dev_bin_attrs,
 };

commit ea6873a45a22f35c8ab0f9c025df6a6c6dd532f3
Author: Igor Kotrasinski <i.kotrasinsk@samsung.com>
Date:   Tue Mar 8 21:49:03 2016 +0100

    usbip: vudc: Add SysFS infrastructure for VUDC
    
    Add sysfs attributes to allow controlling vudc from usbip tools.
    
    dev_desc - device descriptor of current gadget. This is required to
             be consisten with current usbip protocol and allow to list
             exportable devices on given machine.
    
    usbip_sockfd - allows to pass socket to kernel to start usbip transfer.
    
    usbip_status - currnent status of device
    
    This commit is a result of cooperation between Samsung R&D Institute
    Poland and Open Operating Systems Student Society at University
    of Warsaw (O2S3@UW) consisting of:
    
        Igor Kotrasinski <ikotrasinsk@gmail.com>
        Karol Kosik <karo9@interia.eu>
        Ewelina Kosmider <3w3lfin@gmail.com>
        Dawid Lazarczyk <lazarczyk.dawid@gmail.com>
        Piotr Szulc <ps347277@students.mimuw.edu.pl>
    
    Tutor and project owner:
        Krzysztof Opasiak <k.opasiak@samsung.com>
    
    Signed-off-by: Igor Kotrasinski <i.kotrasinsk@samsung.com>
    Signed-off-by: Karol Kosik <karo9@interia.eu>
    [Various bug fixes, improvements and commit msg update]
    Signed-off-by: Krzysztof Opasiak <k.opasiak@samsung.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/usbip/vudc_sysfs.c b/drivers/usb/usbip/vudc_sysfs.c
new file mode 100644
index 000000000000..25ca16ab0073
--- /dev/null
+++ b/drivers/usb/usbip/vudc_sysfs.c
@@ -0,0 +1,221 @@
+/*
+ * Copyright (C) 2015 Karol Kosik <karo9@interia.eu>
+ * Copyright (C) 2015-2016 Samsung Electronics
+ *               Igor Kotrasinski <i.kotrasinsk@samsung.com>
+ *               Krzysztof Opasiak <k.opasiak@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/device.h>
+#include <linux/list.h>
+#include <linux/usb/gadget.h>
+#include <linux/usb/ch9.h>
+#include <linux/sysfs.h>
+#include <linux/kthread.h>
+#include <linux/byteorder/generic.h>
+
+#include "usbip_common.h"
+#include "vudc.h"
+
+#include <net/sock.h>
+
+/* called with udc->lock held */
+int get_gadget_descs(struct vudc *udc)
+{
+	struct vrequest *usb_req;
+	struct vep *ep0 = to_vep(udc->gadget.ep0);
+	struct usb_device_descriptor *ddesc = &udc->dev_desc;
+	struct usb_ctrlrequest req;
+	int ret;
+
+	if (!udc || !udc->driver || !udc->pullup)
+		return -EINVAL;
+
+	req.bRequestType = USB_DIR_IN | USB_TYPE_STANDARD | USB_RECIP_DEVICE;
+	req.bRequest = USB_REQ_GET_DESCRIPTOR;
+	req.wValue = cpu_to_le16(USB_DT_DEVICE << 8);
+	req.wIndex = cpu_to_le16(0);
+	req.wLength = cpu_to_le16(sizeof(*ddesc));
+
+	spin_unlock(&udc->lock);
+	ret = udc->driver->setup(&(udc->gadget), &req);
+	spin_lock(&udc->lock);
+	if (ret < 0)
+		goto out;
+
+	/* assuming request queue is empty; request is now on top */
+	usb_req = list_last_entry(&ep0->req_queue, struct vrequest, req_entry);
+	list_del(&usb_req->req_entry);
+
+	if (usb_req->req.length > sizeof(*ddesc)) {
+		ret = -EOVERFLOW;
+		goto giveback_req;
+	}
+
+	memcpy(ddesc, usb_req->req.buf, sizeof(*ddesc));
+	udc->desc_cached = 1;
+	ret = 0;
+giveback_req:
+	usb_req->req.status = 0;
+	usb_req->req.actual = usb_req->req.length;
+	usb_gadget_giveback_request(&(ep0->ep), &(usb_req->req));
+out:
+	return ret;
+}
+
+/*
+ * Exposes device descriptor from the gadget driver.
+ */
+static ssize_t dev_desc_show(struct device *dev,
+			       struct device_attribute *attr, char *out)
+{
+	struct vudc *udc = (struct vudc *)dev_get_drvdata(dev);
+	unsigned long flags;
+	int ret;
+
+	spin_lock_irqsave(&udc->lock, flags);
+	if (!udc->desc_cached) {
+		ret = -ENODEV;
+		goto unlock;
+	}
+
+	memcpy(out, &udc->dev_desc, sizeof(udc->dev_desc));
+	ret = sizeof(udc->dev_desc);
+unlock:
+	spin_unlock_irqrestore(&udc->lock, flags);
+	return ret;
+}
+static DEVICE_ATTR_RO(dev_desc);
+
+static ssize_t store_sockfd(struct device *dev, struct device_attribute *attr,
+		     const char *in, size_t count)
+{
+	struct vudc *udc = (struct vudc *) dev_get_drvdata(dev);
+	int rv;
+	int sockfd = 0;
+	int err;
+	struct socket *socket;
+	unsigned long flags;
+	int ret;
+
+	rv = kstrtoint(in, 0, &sockfd);
+	if (rv != 0)
+		return -EINVAL;
+
+	spin_lock_irqsave(&udc->lock, flags);
+	/* Don't export what we don't have */
+	if (!udc || !udc->driver || !udc->pullup) {
+		dev_err(dev, "no device or gadget not bound");
+		ret = -ENODEV;
+		goto unlock;
+	}
+
+	if (sockfd != -1) {
+		if (udc->connected) {
+			dev_err(dev, "Device already connected");
+			ret = -EBUSY;
+			goto unlock;
+		}
+
+		spin_lock_irq(&udc->ud.lock);
+
+		if (udc->ud.status != SDEV_ST_AVAILABLE) {
+			ret = -EINVAL;
+			goto unlock_ud;
+		}
+
+		socket = sockfd_lookup(sockfd, &err);
+		if (!socket) {
+			dev_err(dev, "failed to lookup sock");
+			ret = -EINVAL;
+			goto unlock_ud;
+		}
+
+		udc->ud.tcp_socket = socket;
+
+		spin_unlock_irq(&udc->ud.lock);
+		spin_unlock_irqrestore(&udc->lock, flags);
+
+		udc->ud.tcp_rx = kthread_get_run(&v_rx_loop,
+						    &udc->ud, "vudc_rx");
+		udc->ud.tcp_tx = kthread_get_run(&v_tx_loop,
+						    &udc->ud, "vudc_tx");
+
+		spin_lock_irqsave(&udc->lock, flags);
+		spin_lock_irq(&udc->ud.lock);
+		udc->ud.status = SDEV_ST_USED;
+		spin_unlock_irq(&udc->ud.lock);
+
+		do_gettimeofday(&udc->start_time);
+		v_start_timer(udc);
+		udc->connected = 1;
+	} else {
+		if (!udc->connected) {
+			dev_err(dev, "Device not connected");
+			ret = -EINVAL;
+			goto unlock;
+		}
+
+		spin_lock_irq(&udc->ud.lock);
+		if (udc->ud.status != SDEV_ST_USED) {
+			ret = -EINVAL;
+			goto unlock_ud;
+		}
+		spin_unlock_irq(&udc->ud.lock);
+
+		usbip_event_add(&udc->ud, VUDC_EVENT_DOWN);
+	}
+
+	spin_unlock_irqrestore(&udc->lock, flags);
+
+	return count;
+
+unlock_ud:
+	spin_unlock_irq(&udc->ud.lock);
+unlock:
+	spin_unlock_irqrestore(&udc->lock, flags);
+
+	return ret;
+}
+static DEVICE_ATTR(usbip_sockfd, S_IWUSR, NULL, store_sockfd);
+
+static ssize_t usbip_status_show(struct device *dev,
+			       struct device_attribute *attr, char *out)
+{
+	struct vudc *udc = (struct vudc *) dev_get_drvdata(dev);
+	int status;
+
+	if (!udc) {
+		dev_err(&udc->pdev->dev, "no device");
+		return -ENODEV;
+	}
+	spin_lock_irq(&udc->ud.lock);
+	status = udc->ud.status;
+	spin_unlock_irq(&udc->ud.lock);
+
+	return snprintf(out, PAGE_SIZE, "%d\n", status);
+}
+static DEVICE_ATTR_RO(usbip_status);
+
+static struct attribute *dev_attrs[] = {
+	&dev_attr_dev_desc.attr,
+	&dev_attr_usbip_sockfd.attr,
+	&dev_attr_usbip_status.attr,
+	NULL,
+};
+
+const struct attribute_group vudc_attr_group = {
+	.attrs = dev_attrs,
+};
