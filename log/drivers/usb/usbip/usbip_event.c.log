commit 4c982482341c64f55daf69b6caa5a2bcd9b43824
Author: Shuah Khan <shuahkh@osg.samsung.com>
Date:   Thu Apr 5 16:29:50 2018 -0600

    usbip: usbip_event: fix to not print kernel pointer address
    
    Fix it to not print kernel pointer address. Remove the conditional
    and debug message as it isn't very useful.
    
    Signed-off-by: Shuah Khan <shuahkh@osg.samsung.com>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/usbip/usbip_event.c b/drivers/usb/usbip/usbip_event.c
index 5b4c0864ad92..5d88917c9631 100644
--- a/drivers/usb/usbip/usbip_event.c
+++ b/drivers/usb/usbip/usbip_event.c
@@ -91,10 +91,6 @@ static void event_handler(struct work_struct *work)
 			unset_event(ud, USBIP_EH_UNUSABLE);
 		}
 
-		/* Stop the error handler. */
-		if (ud->event & USBIP_EH_BYE)
-			usbip_dbg_eh("removed %p\n", ud);
-
 		wake_up(&ud->eh_waitq);
 	}
 }

commit 7f2b019c8d8b0330c142a5934dd77089d5282c74
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Nov 6 15:37:11 2017 +0100

    USB: usbip: Remove redundant license text
    
    Now that the SPDX tag is in all USB files, that identifies the license
    in a specific and legally-defined manner.  So the extra GPL text wording
    can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Valentina Manea <valentina.manea.m@gmail.com>
    Acked-by: Shuah Khan <shuahkh@osg.samsung.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/usbip/usbip_event.c b/drivers/usb/usbip/usbip_event.c
index ffeb0f53fc68..5b4c0864ad92 100644
--- a/drivers/usb/usbip/usbip_event.c
+++ b/drivers/usb/usbip/usbip_event.c
@@ -2,21 +2,6 @@
 /*
  * Copyright (C) 2003-2008 Takahiro Hirofuchi
  * Copyright (C) 2015 Nobuo Iwata
- *
- * This is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
- * USA.
  */
 
 #include <linux/kthread.h>

commit 5fd54ace4721fc5ce2bb5aef6318fcf17f421460
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Nov 3 11:28:30 2017 +0100

    USB: add SPDX identifiers to all remaining files in drivers/usb/
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/usb/ and include/linux/usb* files with the correct
    SPDX license identifier based on the license text in the file itself.
    The SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Acked-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/usbip/usbip_event.c b/drivers/usb/usbip/usbip_event.c
index f1635662c299..ffeb0f53fc68 100644
--- a/drivers/usb/usbip/usbip_event.c
+++ b/drivers/usb/usbip/usbip_event.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  * Copyright (C) 2003-2008 Takahiro Hirofuchi
  * Copyright (C) 2015 Nobuo Iwata

commit bb7871ad99ea814565c3d6b551e039c71f24cbb3
Author: Nobuo Iwata <nobuo.iwata@fujixerox.co.jp>
Date:   Thu Mar 24 10:50:59 2016 +0900

    usbip: event handler as one thread
    
    Dear all,
    
    1. Overview
    
    In current USB/IP implementation, event kernel threads are created for
    each port. The functions of the threads are closing connection and
    error handling so they don't have not so many events to handle. There's
    no need to have thread for each port.
    
    BEFORE) vhci side - VHCI_NPORTS(8) threads are created.
    $ ps aux | grep usbip
    root     10059  0.0  0.0      0     0 ?        S    17:06   0:00 [usbip_eh]
    root     10060  0.0  0.0      0     0 ?        S    17:06   0:00 [usbip_eh]
    root     10061  0.0  0.0      0     0 ?        S    17:06   0:00 [usbip_eh]
    root     10062  0.0  0.0      0     0 ?        S    17:06   0:00 [usbip_eh]
    root     10063  0.0  0.0      0     0 ?        S    17:06   0:00 [usbip_eh]
    root     10064  0.0  0.0      0     0 ?        S    17:06   0:00 [usbip_eh]
    root     10065  0.0  0.0      0     0 ?        S    17:06   0:00 [usbip_eh]
    root     10066  0.0  0.0      0     0 ?        S    17:06   0:00 [usbip_eh]
    
    BEFORE) stub side - threads will be created every bind operation.
    $ ps aux | grep usbip
    root      8368  0.0  0.0      0     0 ?        S    17:56   0:00 [usbip_eh]
    root      8399  0.0  0.0      0     0 ?        S    17:56   0:00 [usbip_eh]
    
    This patch put event threads of stub and vhci driver as one workqueue.
    
    AFTER) only one event threads in each vhci and stub side.
    $ ps aux | grep usbip
    root     10457  0.0  0.0      0     0 ?        S<   17:47   0:00 [usbip_event]
    
    2. Modification to usbip_event.c
    
    BEFORE) kernel threads are created in usbip_start_eh().
    
    AFTER) one workqueue is created in new usbip_init_eh().
    
    Event handler which was main loop of kernel thread is modified to
    workqueue handler.
    
    Events themselves are stored in struct usbip_device - same as before.
    usbip_devices which have event are listed in event_list.
    
    The handler picks an element from the list and wakeup usbip_device. The
    wakeup method is same as before.
    
    usbip_in_eh() substitutes statement which checks whether functions are
    called from eh_ops or not. In this function, the worker context is used
    for the checking. The context will be set in a variable in the
    beginning of first event handling. usbip_in_eh() is used in event
    handler so it works well.
    
    3. Modifications to programs using usbip_event.c
    
    Initialization and termination of workqueue are added to init and exit
    routine of usbip_core respectively.
    
    A. version info
    
    v2)
    # Merged 1/2 event handler itself and 2/2 user programs because of auto
    build fail at 1/2 casued unmodified user programs in 1/2.
    
    Signed-off-by: Nobuo Iwata <nobuo.iwata@fujixerox.co.jp>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/usbip/usbip_event.c b/drivers/usb/usbip/usbip_event.c
index 2580a32bcdff..f1635662c299 100644
--- a/drivers/usb/usbip/usbip_event.c
+++ b/drivers/usb/usbip/usbip_event.c
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2003-2008 Takahiro Hirofuchi
+ * Copyright (C) 2015 Nobuo Iwata
  *
  * This is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -19,17 +20,68 @@
 
 #include <linux/kthread.h>
 #include <linux/export.h>
+#include <linux/slab.h>
+#include <linux/workqueue.h>
 
 #include "usbip_common.h"
 
-static int event_handler(struct usbip_device *ud)
+struct usbip_event {
+	struct list_head node;
+	struct usbip_device *ud;
+};
+
+static DEFINE_SPINLOCK(event_lock);
+static LIST_HEAD(event_list);
+
+static void set_event(struct usbip_device *ud, unsigned long event)
 {
-	usbip_dbg_eh("enter\n");
+	unsigned long flags;
 
-	/*
-	 * Events are handled by only this thread.
-	 */
-	while (usbip_event_happened(ud)) {
+	spin_lock_irqsave(&ud->lock, flags);
+	ud->event |= event;
+	spin_unlock_irqrestore(&ud->lock, flags);
+}
+
+static void unset_event(struct usbip_device *ud, unsigned long event)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&ud->lock, flags);
+	ud->event &= ~event;
+	spin_unlock_irqrestore(&ud->lock, flags);
+}
+
+static struct usbip_device *get_event(void)
+{
+	struct usbip_event *ue = NULL;
+	struct usbip_device *ud = NULL;
+	unsigned long flags;
+
+	spin_lock_irqsave(&event_lock, flags);
+	if (!list_empty(&event_list)) {
+		ue = list_first_entry(&event_list, struct usbip_event, node);
+		list_del(&ue->node);
+	}
+	spin_unlock_irqrestore(&event_lock, flags);
+
+	if (ue) {
+		ud = ue->ud;
+		kfree(ue);
+	}
+	return ud;
+}
+
+static struct task_struct *worker_context;
+
+static void event_handler(struct work_struct *work)
+{
+	struct usbip_device *ud;
+
+	if (worker_context == NULL) {
+		worker_context = current;
+	}
+
+	while ((ud = get_event()) != NULL) {
 		usbip_dbg_eh("pending event %lx\n", ud->event);
 
 		/*
@@ -38,79 +90,102 @@ static int event_handler(struct usbip_device *ud)
 		 */
 		if (ud->event & USBIP_EH_SHUTDOWN) {
 			ud->eh_ops.shutdown(ud);
-			ud->event &= ~USBIP_EH_SHUTDOWN;
+			unset_event(ud, USBIP_EH_SHUTDOWN);
 		}
 
 		/* Reset the device. */
 		if (ud->event & USBIP_EH_RESET) {
 			ud->eh_ops.reset(ud);
-			ud->event &= ~USBIP_EH_RESET;
+			unset_event(ud, USBIP_EH_RESET);
 		}
 
 		/* Mark the device as unusable. */
 		if (ud->event & USBIP_EH_UNUSABLE) {
 			ud->eh_ops.unusable(ud);
-			ud->event &= ~USBIP_EH_UNUSABLE;
+			unset_event(ud, USBIP_EH_UNUSABLE);
 		}
 
 		/* Stop the error handler. */
 		if (ud->event & USBIP_EH_BYE)
-			return -1;
+			usbip_dbg_eh("removed %p\n", ud);
+
+		wake_up(&ud->eh_waitq);
 	}
+}
 
+int usbip_start_eh(struct usbip_device *ud)
+{
+	init_waitqueue_head(&ud->eh_waitq);
+	ud->event = 0;
 	return 0;
 }
+EXPORT_SYMBOL_GPL(usbip_start_eh);
 
-static int event_handler_loop(void *data)
+void usbip_stop_eh(struct usbip_device *ud)
 {
-	struct usbip_device *ud = data;
+	unsigned long pending = ud->event & ~USBIP_EH_BYE;
 
-	while (!kthread_should_stop()) {
-		wait_event_interruptible(ud->eh_waitq,
-					 usbip_event_happened(ud) ||
-					 kthread_should_stop());
-		usbip_dbg_eh("wakeup\n");
+	if (!(ud->event & USBIP_EH_BYE))
+		usbip_dbg_eh("usbip_eh stopping but not removed\n");
 
-		if (event_handler(ud) < 0)
-			break;
-	}
+	if (pending)
+		usbip_dbg_eh("usbip_eh waiting completion %lx\n", pending);
 
-	return 0;
+	wait_event_interruptible(ud->eh_waitq, !(ud->event & ~USBIP_EH_BYE));
+	usbip_dbg_eh("usbip_eh has stopped\n");
 }
+EXPORT_SYMBOL_GPL(usbip_stop_eh);
 
-int usbip_start_eh(struct usbip_device *ud)
-{
-	init_waitqueue_head(&ud->eh_waitq);
-	ud->event = 0;
+#define WORK_QUEUE_NAME "usbip_event"
 
-	ud->eh = kthread_run(event_handler_loop, ud, "usbip_eh");
-	if (IS_ERR(ud->eh)) {
-		pr_warn("Unable to start control thread\n");
-		return PTR_ERR(ud->eh);
-	}
+static struct workqueue_struct *usbip_queue;
+static DECLARE_WORK(usbip_work, event_handler);
 
+int usbip_init_eh(void)
+{
+	usbip_queue = create_singlethread_workqueue(WORK_QUEUE_NAME);
+	if (usbip_queue == NULL) {
+		pr_err("failed to create usbip_event\n");
+		return -ENOMEM;
+	}
 	return 0;
 }
-EXPORT_SYMBOL_GPL(usbip_start_eh);
 
-void usbip_stop_eh(struct usbip_device *ud)
+void usbip_finish_eh(void)
 {
-	if (ud->eh == current)
-		return; /* do not wait for myself */
-
-	kthread_stop(ud->eh);
-	usbip_dbg_eh("usbip_eh has finished\n");
+	flush_workqueue(usbip_queue);
+	destroy_workqueue(usbip_queue);
+	usbip_queue = NULL;
 }
-EXPORT_SYMBOL_GPL(usbip_stop_eh);
 
 void usbip_event_add(struct usbip_device *ud, unsigned long event)
 {
+	struct usbip_event *ue;
 	unsigned long flags;
 
-	spin_lock_irqsave(&ud->lock, flags);
-	ud->event |= event;
-	wake_up(&ud->eh_waitq);
-	spin_unlock_irqrestore(&ud->lock, flags);
+	if (ud->event & USBIP_EH_BYE)
+		return;
+
+	set_event(ud, event);
+
+	spin_lock_irqsave(&event_lock, flags);
+
+	list_for_each_entry_reverse(ue, &event_list, node) {
+		if (ue->ud == ud)
+			goto out;
+	}
+
+	ue = kmalloc(sizeof(struct usbip_event), GFP_ATOMIC);
+	if (ue == NULL)
+		goto out;
+
+	ue->ud = ud;
+
+	list_add_tail(&ue->node, &event_list);
+	queue_work(usbip_queue, &usbip_work);
+
+out:
+	spin_unlock_irqrestore(&event_lock, flags);
 }
 EXPORT_SYMBOL_GPL(usbip_event_add);
 
@@ -127,3 +202,12 @@ int usbip_event_happened(struct usbip_device *ud)
 	return happened;
 }
 EXPORT_SYMBOL_GPL(usbip_event_happened);
+
+int usbip_in_eh(struct task_struct *task)
+{
+	if (task == worker_context)
+		return 1;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(usbip_in_eh);

commit 21619792d1eca7e772ca190ba68588e57f29595b
Author: Andrew Goodbody <andrew.goodbody@cambrionix.com>
Date:   Tue Feb 2 17:36:39 2016 +0000

    usb: usbip: Fix possible deadlocks reported by lockdep
    
    Change spin_lock calls to spin_lock_irqsave to prevent
    attmpted recursive lock taking in interrupt context.
    
    This patch fixes Bug 109351
      https://bugzilla.kernel.org/show_bug.cgi?id=109351
    
    Signed-off-by: Andrew Goodbody <andrew.goodbody@cambrionix.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/usbip/usbip_event.c b/drivers/usb/usbip/usbip_event.c
index 64933b993d7a..2580a32bcdff 100644
--- a/drivers/usb/usbip/usbip_event.c
+++ b/drivers/usb/usbip/usbip_event.c
@@ -117,11 +117,12 @@ EXPORT_SYMBOL_GPL(usbip_event_add);
 int usbip_event_happened(struct usbip_device *ud)
 {
 	int happened = 0;
+	unsigned long flags;
 
-	spin_lock(&ud->lock);
+	spin_lock_irqsave(&ud->lock, flags);
 	if (ud->event != 0)
 		happened = 1;
-	spin_unlock(&ud->lock);
+	spin_unlock_irqrestore(&ud->lock, flags);
 
 	return happened;
 }

commit 96c2737716d586a218bc795fcb79d2e2b6003081
Author: Valentina Manea <valentina.manea.m@gmail.com>
Date:   Wed Aug 20 07:31:00 2014 +0300

    usbip: move usbip kernel code out of staging
    
    At this point, USB/IP kernel code is fully functional
    and can be moved out of staging.
    
    Signed-off-by: Valentina Manea <valentina.manea.m@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/usbip/usbip_event.c b/drivers/usb/usbip/usbip_event.c
new file mode 100644
index 000000000000..64933b993d7a
--- /dev/null
+++ b/drivers/usb/usbip/usbip_event.c
@@ -0,0 +1,128 @@
+/*
+ * Copyright (C) 2003-2008 Takahiro Hirofuchi
+ *
+ * This is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+ * USA.
+ */
+
+#include <linux/kthread.h>
+#include <linux/export.h>
+
+#include "usbip_common.h"
+
+static int event_handler(struct usbip_device *ud)
+{
+	usbip_dbg_eh("enter\n");
+
+	/*
+	 * Events are handled by only this thread.
+	 */
+	while (usbip_event_happened(ud)) {
+		usbip_dbg_eh("pending event %lx\n", ud->event);
+
+		/*
+		 * NOTE: shutdown must come first.
+		 * Shutdown the device.
+		 */
+		if (ud->event & USBIP_EH_SHUTDOWN) {
+			ud->eh_ops.shutdown(ud);
+			ud->event &= ~USBIP_EH_SHUTDOWN;
+		}
+
+		/* Reset the device. */
+		if (ud->event & USBIP_EH_RESET) {
+			ud->eh_ops.reset(ud);
+			ud->event &= ~USBIP_EH_RESET;
+		}
+
+		/* Mark the device as unusable. */
+		if (ud->event & USBIP_EH_UNUSABLE) {
+			ud->eh_ops.unusable(ud);
+			ud->event &= ~USBIP_EH_UNUSABLE;
+		}
+
+		/* Stop the error handler. */
+		if (ud->event & USBIP_EH_BYE)
+			return -1;
+	}
+
+	return 0;
+}
+
+static int event_handler_loop(void *data)
+{
+	struct usbip_device *ud = data;
+
+	while (!kthread_should_stop()) {
+		wait_event_interruptible(ud->eh_waitq,
+					 usbip_event_happened(ud) ||
+					 kthread_should_stop());
+		usbip_dbg_eh("wakeup\n");
+
+		if (event_handler(ud) < 0)
+			break;
+	}
+
+	return 0;
+}
+
+int usbip_start_eh(struct usbip_device *ud)
+{
+	init_waitqueue_head(&ud->eh_waitq);
+	ud->event = 0;
+
+	ud->eh = kthread_run(event_handler_loop, ud, "usbip_eh");
+	if (IS_ERR(ud->eh)) {
+		pr_warn("Unable to start control thread\n");
+		return PTR_ERR(ud->eh);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(usbip_start_eh);
+
+void usbip_stop_eh(struct usbip_device *ud)
+{
+	if (ud->eh == current)
+		return; /* do not wait for myself */
+
+	kthread_stop(ud->eh);
+	usbip_dbg_eh("usbip_eh has finished\n");
+}
+EXPORT_SYMBOL_GPL(usbip_stop_eh);
+
+void usbip_event_add(struct usbip_device *ud, unsigned long event)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&ud->lock, flags);
+	ud->event |= event;
+	wake_up(&ud->eh_waitq);
+	spin_unlock_irqrestore(&ud->lock, flags);
+}
+EXPORT_SYMBOL_GPL(usbip_event_add);
+
+int usbip_event_happened(struct usbip_device *ud)
+{
+	int happened = 0;
+
+	spin_lock(&ud->lock);
+	if (ud->event != 0)
+		happened = 1;
+	spin_unlock(&ud->lock);
+
+	return happened;
+}
+EXPORT_SYMBOL_GPL(usbip_event_happened);
