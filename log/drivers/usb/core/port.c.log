commit 1f8b39bc99a31759e97a0428a5c3f64802c1e61d
Author: Eugeniu Rosca <erosca@de.adit-jv.com>
Date:   Wed Feb 26 18:50:36 2020 +0100

    usb: core: port: do error out if usb_autopm_get_interface() fails
    
    Reviewing a fresh portion of coverity defects in USB core
    (specifically CID 1458999), Alan Stern noted below in [1]:
    
    On Tue, Feb 25, 2020 at 02:39:23PM -0500, Alan Stern wrote:
     > A revised search finds line 997 in drivers/usb/core/hub.c and lines
     > 216, 269 in drivers/usb/core/port.c.  (I didn't try looking in any
     > other directories.)  AFAICT all three of these should check the
     > return value, although a error message in the kernel log probably
     > isn't needed.
    
    Factor out the usb_port_runtime_{resume,suspend}() changes into a
    standalone patch to allow conflict-free porting on top of stable v3.9+.
    
    [1] https://lore.kernel.org/lkml/Pine.LNX.4.44L0.2002251419120.1485-100000@iolanthe.rowland.org
    
    Fixes: 971fcd492cebf5 ("usb: add runtime pm support for usb port device")
    Cc: stable@vger.kernel.org # v3.9+
    Suggested-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Eugeniu Rosca <erosca@de.adit-jv.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Link: https://lore.kernel.org/r/20200226175036.14946-3-erosca@de.adit-jv.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/port.c b/drivers/usb/core/port.c
index bbbb35fa639f..235a7c645503 100644
--- a/drivers/usb/core/port.c
+++ b/drivers/usb/core/port.c
@@ -213,7 +213,10 @@ static int usb_port_runtime_resume(struct device *dev)
 	if (!port_dev->is_superspeed && peer)
 		pm_runtime_get_sync(&peer->dev);
 
-	usb_autopm_get_interface(intf);
+	retval = usb_autopm_get_interface(intf);
+	if (retval < 0)
+		return retval;
+
 	retval = usb_hub_set_port_power(hdev, hub, port1, true);
 	msleep(hub_power_on_good_delay(hub));
 	if (udev && !retval) {
@@ -266,7 +269,10 @@ static int usb_port_runtime_suspend(struct device *dev)
 	if (usb_port_block_power_off)
 		return -EBUSY;
 
-	usb_autopm_get_interface(intf);
+	retval = usb_autopm_get_interface(intf);
+	if (retval < 0)
+		return retval;
+
 	retval = usb_hub_set_port_power(hdev, hub, port1, false);
 	usb_clear_port_feature(hdev, port1, USB_PORT_FEAT_C_CONNECTION);
 	if (!port_dev->is_superspeed)

commit 582ee9c5ad2661b359309f379f5c411fd33e511a
Author: Kai-Heng Feng <kai.heng.feng@canonical.com>
Date:   Mon Aug 5 22:24:12 2019 +0800

    USB: Disable USB2 LPM at shutdown
    
    The QCA Rome USB Bluetooth controller has several issues once LPM gets
    enabled:
    - Fails to get enumerated in coldboot. [1]
    - Drains more power (~ 0.2W) when the system is in S5. [2]
    - Disappears after a warmboot. [2]
    
    The issue happens because the device lingers at LPM L1 in S5, so device
    can't get enumerated even after a reboot.
    
    Disable LPM at shutdown to solve the issue.
    
    [1] https://bugs.launchpad.net/bugs/1757218
    [2] https://patchwork.kernel.org/patch/10607097/
    
    Signed-off-by: Kai-Heng Feng <kai.heng.feng@canonical.com>
    Link: https://lore.kernel.org/r/20190805142412.23965-1-kai.heng.feng@canonical.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/port.c b/drivers/usb/core/port.c
index 1a06a4b5fbb1..bbbb35fa639f 100644
--- a/drivers/usb/core/port.c
+++ b/drivers/usb/core/port.c
@@ -285,6 +285,14 @@ static int usb_port_runtime_suspend(struct device *dev)
 }
 #endif
 
+static void usb_port_shutdown(struct device *dev)
+{
+	struct usb_port *port_dev = to_usb_port(dev);
+
+	if (port_dev->child)
+		usb_disable_usb2_hardware_lpm(port_dev->child);
+}
+
 static const struct dev_pm_ops usb_port_pm_ops = {
 #ifdef CONFIG_PM
 	.runtime_suspend =	usb_port_runtime_suspend,
@@ -301,6 +309,7 @@ struct device_type usb_port_device_type = {
 static struct device_driver usb_port_driver = {
 	.name = "usb",
 	.owner = THIS_MODULE,
+	.shutdown = usb_port_shutdown,
 };
 
 static int link_peers(struct usb_port *left, struct usb_port *right)

commit 355c74e55e9992126ec5e568a3edb8e280fe040d
Author: Bjørn Mork <bjorn@mork.no>
Date:   Fri Sep 28 15:40:31 2018 +0200

    usb: export firmware port location in sysfs
    
    The platform firmware "location" data is used to find port peer
    relationships. But firmware is an unreliable source, and there are
    real world examples of errors leading to missing or wrong peer
    relationships.  Debugging this is currently hard.
    
    Exporting the location attribute makes it easier to spot mismatches
    between the firmware data and the real world.
    
    Signed-off-by: Bjørn Mork <bjorn@mork.no>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/port.c b/drivers/usb/core/port.c
index 4a2143195395..1a06a4b5fbb1 100644
--- a/drivers/usb/core/port.c
+++ b/drivers/usb/core/port.c
@@ -16,6 +16,15 @@ static int usb_port_block_power_off;
 
 static const struct attribute_group *port_dev_group[];
 
+static ssize_t location_show(struct device *dev,
+			     struct device_attribute *attr, char *buf)
+{
+	struct usb_port *port_dev = to_usb_port(dev);
+
+	return sprintf(buf, "0x%08x\n", port_dev->location);
+}
+static DEVICE_ATTR_RO(location);
+
 static ssize_t connect_type_show(struct device *dev,
 				 struct device_attribute *attr, char *buf)
 {
@@ -140,6 +149,7 @@ static DEVICE_ATTR_RW(usb3_lpm_permit);
 
 static struct attribute *port_dev_attrs[] = {
 	&dev_attr_connect_type.attr,
+	&dev_attr_location.attr,
 	&dev_attr_quirks.attr,
 	&dev_attr_over_current_count.attr,
 	NULL,

commit 25244227158e1502062041365a439a54cb8fe673
Author: Nicolas Boichat <drinkcat@chromium.org>
Date:   Mon May 28 14:32:18 2018 +0800

    usb: hub: Per-port setting to use old enumeration scheme
    
    The "old" enumeration scheme is considerably faster (it takes
    ~244ms instead of ~356ms to get the descriptor).
    
    It is currently only possible to use the old scheme globally
    (/sys/module/usbcore/parameters/old_scheme_first), which is not
    desirable as the new scheme was introduced to increase compatibility
    with more devices.
    
    However, in our case, we care about time-to-active for a specific
    USB device (which we make the firmware for), on a specific port
    (that is pogo-pin based: not a standard USB port). This new
    sysfs option makes it possible to use the old scheme on a single
    port only.
    
    Signed-off-by: Nicolas Boichat <drinkcat@chromium.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/port.c b/drivers/usb/core/port.c
index 6979bde87d31..4a2143195395 100644
--- a/drivers/usb/core/port.c
+++ b/drivers/usb/core/port.c
@@ -50,6 +50,28 @@ static ssize_t over_current_count_show(struct device *dev,
 }
 static DEVICE_ATTR_RO(over_current_count);
 
+static ssize_t quirks_show(struct device *dev,
+			   struct device_attribute *attr, char *buf)
+{
+	struct usb_port *port_dev = to_usb_port(dev);
+
+	return sprintf(buf, "%08x\n", port_dev->quirks);
+}
+
+static ssize_t quirks_store(struct device *dev, struct device_attribute *attr,
+			    const char *buf, size_t count)
+{
+	struct usb_port *port_dev = to_usb_port(dev);
+	u32 value;
+
+	if (kstrtou32(buf, 16, &value))
+		return -EINVAL;
+
+	port_dev->quirks = value;
+	return count;
+}
+static DEVICE_ATTR_RW(quirks);
+
 static ssize_t usb3_lpm_permit_show(struct device *dev,
 			      struct device_attribute *attr, char *buf)
 {
@@ -118,6 +140,7 @@ static DEVICE_ATTR_RW(usb3_lpm_permit);
 
 static struct attribute *port_dev_attrs[] = {
 	&dev_attr_connect_type.attr,
+	&dev_attr_quirks.attr,
 	&dev_attr_over_current_count.attr,
 	NULL,
 };

commit 1cbd53c8cd85a63383a075347abee8f6e3f14fbe
Author: Richard Leitner <richard.leitner@skidata.com>
Date:   Tue Mar 20 11:17:13 2018 +0100

    usb: core: introduce per-port over-current counters
    
    For some userspace applications information on the number of
    over-current conditions at specific USB hub ports is relevant.
    
    In our case we have a series of USB hardware (using the cp210x driver)
    which communicates using a proprietary protocol. These devices sometimes
    trigger an over-current situation on some hubs. In case of such an
    over-current situation the USB devices offer an interface for reducing
    the max used power. As these conditions are quite rare and imply
    performance reductions of the device we don't want to reduce the max
    power always.
    
    Therefore give user-space applications the possibility to react
    adequately by introducing an over_current_counter in the usb port struct
    which is exported via sysfs.
    
    Signed-off-by: Richard Leitner <richard.leitner@skidata.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/port.c b/drivers/usb/core/port.c
index 1a01e9ad3804..6979bde87d31 100644
--- a/drivers/usb/core/port.c
+++ b/drivers/usb/core/port.c
@@ -41,6 +41,15 @@ static ssize_t connect_type_show(struct device *dev,
 }
 static DEVICE_ATTR_RO(connect_type);
 
+static ssize_t over_current_count_show(struct device *dev,
+				       struct device_attribute *attr, char *buf)
+{
+	struct usb_port *port_dev = to_usb_port(dev);
+
+	return sprintf(buf, "%u\n", port_dev->over_current_count);
+}
+static DEVICE_ATTR_RO(over_current_count);
+
 static ssize_t usb3_lpm_permit_show(struct device *dev,
 			      struct device_attribute *attr, char *buf)
 {
@@ -109,6 +118,7 @@ static DEVICE_ATTR_RW(usb3_lpm_permit);
 
 static struct attribute *port_dev_attrs[] = {
 	&dev_attr_connect_type.attr,
+	&dev_attr_over_current_count.attr,
 	NULL,
 };
 

commit f9d4d453db3a1b8e58705217e106db5b63a4d3fb
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Nov 3 12:41:02 2017 +0100

    USB: core: Remove redundant license text
    
    Now that the SPDX tag is in all USB files, that identifies the license
    in a specific and legally-defined manner.  So the extra GPL text wording
    can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/port.c b/drivers/usb/core/port.c
index bd757a951a18..1a01e9ad3804 100644
--- a/drivers/usb/core/port.c
+++ b/drivers/usb/core/port.c
@@ -5,16 +5,6 @@
  * Copyright (C) 2012 Intel Corp
  *
  * Author: Lan Tianyu <tianyu.lan@intel.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * for more details.
- *
  */
 
 #include <linux/slab.h>

commit 5fd54ace4721fc5ce2bb5aef6318fcf17f421460
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Nov 3 11:28:30 2017 +0100

    USB: add SPDX identifiers to all remaining files in drivers/usb/
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/usb/ and include/linux/usb* files with the correct
    SPDX license identifier based on the license text in the file itself.
    The SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Acked-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/port.c b/drivers/usb/core/port.c
index 460c855be0d0..bd757a951a18 100644
--- a/drivers/usb/core/port.c
+++ b/drivers/usb/core/port.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * usb port device code
  *

commit 9be427efc764464fbcbc1ca3f0d34f575cb0f037
Author: Johan Hovold <johan@kernel.org>
Date:   Mon May 2 15:35:57 2016 +0200

    Revert "USB / PM: Allow USB devices to remain runtime-suspended when sleeping"
    
    This reverts commit e3345db85068ddb937fc0ba40dfc39c293dad977, which
    broke system resume for a large class of devices.
    
    Devices that after having been reset during resume need to be rebound
    due to a missing reset_resume callback, are now left in a suspended
    state. This specifically broke resume of common USB-serial devices,
    which are now unusable after system suspend (until disconnected and
    reconnected) when USB persist is enabled.
    
    During resume, usb_resume_interface will set the needs_binding flag for
    such interfaces, but unlike system resume, run-time resume does not
    honour it.
    
    Cc: stable <stable@vger.kernel.org>     # 4.5
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/port.c b/drivers/usb/core/port.c
index 14718a9ffcfb..460c855be0d0 100644
--- a/drivers/usb/core/port.c
+++ b/drivers/usb/core/port.c
@@ -249,18 +249,12 @@ static int usb_port_runtime_suspend(struct device *dev)
 
 	return retval;
 }
-
-static int usb_port_prepare(struct device *dev)
-{
-	return 1;
-}
 #endif
 
 static const struct dev_pm_ops usb_port_pm_ops = {
 #ifdef CONFIG_PM
 	.runtime_suspend =	usb_port_runtime_suspend,
 	.runtime_resume =	usb_port_runtime_resume,
-	.prepare =		usb_port_prepare,
 #endif
 };
 

commit 30f05309bde49295e02e45c7e615f73aa4e0ccc2
Merge: 3549d8227937 db2b52f75250
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jan 20 19:06:49 2016 -0800

    Merge tag 'pm+acpi-4.5-rc1-2' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull more power management and ACPI updates from Rafael Wysocki:
     "This includes fixes on top of the previous batch of PM+ACPI updates
      and some new material as well.
    
      From the new material perspective the most significant are the driver
      core changes that should allow USB devices to stay suspended over
      system suspend/resume cycles if they have been runtime-suspended
      already beforehand.  Apart from that, ACPICA is updated to upstream
      revision 20160108 (cosmetic mostly, but including one fixup on top of
      the previous ACPICA update) and there are some devfreq updates the
      didn't make it before (due to timing).
    
      A few recent regressions are fixed, most importantly in the cpuidle
      menu governor and in the ACPI backlight driver and some x86 platform
      drivers depending on it.
    
      Some more bugs are fixed and cleanups are made on top of that.
    
      Specifics:
    
       - Modify the driver core and the USB subsystem to allow USB devices
         to stay suspended over system suspend/resume cycles if they have
         been runtime-suspended already beforehand and fix some bugs on top
         of these changes (Tomeu Vizoso, Rafael Wysocki).
    
       - Update ACPICA to upstream revision 20160108, including updates of
         the ACPICA's copyright notices, a code fixup resulting from a
         regression fix that was necessary in the upstream code only (the
         regression fixed by it has never been present in Linux) and a
         compiler warning fix (Bob Moore, Lv Zheng).
    
       - Fix a recent regression in the cpuidle menu governor that broke it
         on practically all architectures other than x86 and make a couple
         of optimizations on top of that fix (Rafael Wysocki).
    
       - Clean up the selection of cpuidle governors depending on whether or
         not the kernel is configured for tickless systems (Jean Delvare).
    
       - Revert a recent commit that introduced a regression in the ACPI
         backlight driver, address the problem it attempted to fix in a
         different way and revert one more cosmetic change depending on the
         problematic commit (Hans de Goede).
    
       - Add two more ACPI backlight quirks (Hans de Goede).
    
       - Fix a few minor problems in the core devfreq code, clean it up a
         bit and update the MAINTAINERS information related to it (Chanwoo
         Choi, MyungJoo Ham).
    
       - Improve an error message in the ACPI fan driver (Andy Lutomirski).
    
       - Fix a recent build regression in the cpupower tool (Shreyas
         Prabhu)"
    
    * tag 'pm+acpi-4.5-rc1-2' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (32 commits)
      cpuidle: menu: Avoid pointless checks in menu_select()
      sched / idle: Drop default_idle_call() fallback from call_cpuidle()
      cpupower: Fix build error in cpufreq-info
      cpuidle: Don't enable all governors by default
      cpuidle: Default to ladder governor on ticking systems
      time: nohz: Expose tick_nohz_enabled
      ACPICA: Update version to 20160108
      ACPICA: Silence a -Wbad-function-cast warning when acpi_uintptr_t is 'uintptr_t'
      ACPICA: Additional 2016 copyright changes
      ACPICA: Reduce regression fix divergence from upstream ACPICA
      ACPI / video: Add disable_backlight_sysfs_if quirk for the Toshiba Satellite R830
      ACPI / video: Revert "thinkpad_acpi: Use acpi_video_handles_brightness_key_presses()"
      ACPI / video: Document acpi_video_handles_brightness_key_presses() a bit
      ACPI / video: Fix using an uninitialized mutex / list_head in acpi_video_handles_brightness_key_presses()
      ACPI / video: Revert "ACPI / video: driver must be registered before checking for keypresses"
      ACPI / fan: Improve acpi_device_update_power error message
      ACPI / video: Add disable_backlight_sysfs_if quirk for the Toshiba Portege R700
      cpuidle: menu: Fix menu_select() for CPUIDLE_DRIVER_STATE_START == 0
      MAINTAINERS: Add devfreq-event entry
      MAINTAINERS: Add missing git repository and directory for devfreq
      ...

commit 6efd3f8cde1d6acc20a715ac6ea17e01421742df
Merge: a72aea722f1b 3ded91041a76
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jan 21 00:42:59 2016 +0100

    Merge branch 'pm-core'
    
    * pm-core:
      driver core: Avoid NULL pointer dereferences in device_is_bound()
      platform: Do not detach from PM domains on shutdown
      USB / PM: Allow USB devices to remain runtime-suspended when sleeping
      PM / sleep: Go direct_complete if driver has no callbacks
      PM / Domains: add setter for dev.pm_domain
      device core: add device_is_bound()

commit e3345db85068ddb937fc0ba40dfc39c293dad977
Author: Tomeu Vizoso <tomeu.vizoso@collabora.com>
Date:   Thu Jan 7 16:46:15 2016 +0100

    USB / PM: Allow USB devices to remain runtime-suspended when sleeping
    
    Have dev_pm_ops.prepare return 1 for USB devices and ports so that USB
    devices can remain runtime-suspended when the system goes to a sleep
    state, if their wakeup state is correct and they have runtime PM enabled.
    
    Signed-off-by: Tomeu Vizoso <tomeu.vizoso@collabora.com>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/usb/core/port.c b/drivers/usb/core/port.c
index 210618319f10..f49707d73b5a 100644
--- a/drivers/usb/core/port.c
+++ b/drivers/usb/core/port.c
@@ -168,12 +168,18 @@ static int usb_port_runtime_suspend(struct device *dev)
 
 	return retval;
 }
+
+static int usb_port_prepare(struct device *dev)
+{
+	return 1;
+}
 #endif
 
 static const struct dev_pm_ops usb_port_pm_ops = {
 #ifdef CONFIG_PM
 	.runtime_suspend =	usb_port_runtime_suspend,
 	.runtime_resume =	usb_port_runtime_resume,
+	.prepare =		usb_port_prepare,
 #endif
 };
 

commit 252ca494ac75f0dc47469f130d6dc67ed14081f4
Merge: 900937c0375e 9f9499ae8e64
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Sun Dec 13 19:20:27 2015 -0800

    Merge 4.4-rc5 into usb-next as we want those fixes here for testing
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 6406eeb3f5bb376c7d9674e61f8da34ce7f05e8d
Author: Don Zickus <dzickus@redhat.com>
Date:   Thu Dec 3 17:26:27 2015 -0500

    usb: Quiet down false peer failure messages
    
    My recent Intel box is spewing these messages:
    
    xhci_hcd 0000:00:14.0: xHCI Host Controller
    xhci_hcd 0000:00:14.0: new USB bus registered, assigned bus number 2
    usb usb2: New USB device found, idVendor=1d6b, idProduct=0003
    usb usb2: New USB device strings: Mfr=3, Product=2, SerialNumber=1
    usb usb2: Product: xHCI Host Controller
    usb usb2: Manufacturer: Linux 4.3.0+ xhci-hcd
    usb usb2: SerialNumber: 0000:00:14.0
    hub 2-0:1.0: USB hub found
    hub 2-0:1.0: 6 ports detected
    usb: failed to peer usb2-port2 and usb1-port1 by location (usb2-port2:none) (usb1-port1:usb2-port1)
    usb usb2-port2: failed to peer to usb1-port1 (-16)
    usb: port power management may be unreliable
    usb: failed to peer usb2-port3 and usb1-port1 by location (usb2-port3:none) (usb1-port1:usb2-port1)
    usb usb2-port3: failed to peer to usb1-port1 (-16)
    usb: failed to peer usb2-port5 and usb1-port1 by location (usb2-port5:none) (usb1-port1:usb2-port1)
    usb usb2-port5: failed to peer to usb1-port1 (-16)
    usb: failed to peer usb2-port6 and usb1-port1 by location (usb2-port6:none) (usb1-port1:usb2-port1)
    usb usb2-port6: failed to peer to usb1-port1 (-16)
    
    Diving into the acpi tables, I noticed the EHCI hub has 12 ports while the XHCI
    hub has 8 ports.  Most of those ports are of connect type USB_PORT_NOT_USED
    (including port 1 of the EHCI hub).
    
    Further the unused ports have location data initialized to 0x80000000.
    
    Now each unused port on the xhci hub walks the port list and finds a matching
    peer with port1 of the EHCI hub because the zero'd out group id bits falsely match.
    After port1 of the XHCI hub, each following matching peer will generate the
    above warning.
    
    These warnings seem to be harmless for this scenario as I don't think it
    matters that unused ports could not create a peer link.
    
    The attached patch utilizes that assumption and just turns the pr_warn into
    pr_debug to quiet things down.
    
    Tested on my Intel box.
    
    Signed-off-by: Don Zickus <dzickus@redhat.com>
    Acked-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/port.c b/drivers/usb/core/port.c
index 210618319f10..5487fe308f01 100644
--- a/drivers/usb/core/port.c
+++ b/drivers/usb/core/port.c
@@ -206,7 +206,7 @@ static int link_peers(struct usb_port *left, struct usb_port *right)
 		else
 			method = "default";
 
-		pr_warn("usb: failed to peer %s and %s by %s (%s:%s) (%s:%s)\n",
+		pr_debug("usb: failed to peer %s and %s by %s (%s:%s) (%s:%s)\n",
 			dev_name(&left->dev), dev_name(&right->dev), method,
 			dev_name(&left->dev),
 			lpeer ? dev_name(&lpeer->dev) : "none",
@@ -265,7 +265,7 @@ static void link_peers_report(struct usb_port *left, struct usb_port *right)
 	if (rc == 0) {
 		dev_dbg(&left->dev, "peered to %s\n", dev_name(&right->dev));
 	} else {
-		dev_warn(&left->dev, "failed to peer to %s (%d)\n",
+		dev_dbg(&left->dev, "failed to peer to %s (%d)\n",
 				dev_name(&right->dev), rc);
 		pr_warn_once("usb: port power management may be unreliable\n");
 		usb_port_block_power_off = 1;

commit 513072d90a8dfe4bf83e1f81810de605eb5d7c3b
Author: Lu Baolu <baolu.lu@linux.intel.com>
Date:   Sat Nov 14 16:26:33 2015 +0800

    usb: core: lpm: add sysfs node for usb3 lpm permit
    
    USB3 LPM is default on in Linux kernel if both xHCI host controller
    and the USB devices declare to be LPM-capable. Unfortunately, some
    devices are known to work well with LPM disabled, but to be broken
    if LPM is enabled, although it declares the LPM capability.  Users
    won't be able to use this kind of devices, until someone puts them
    in the kernel blacklist and gets the kernel upgraded.
    
    This patch adds a sysfs node to permit or forbit USB3 LPM U1 or U2
    entry for a port. The settings apply to both before and after device
    enumeration. Supported values are "0" - neither u1 nor u2 permitted,
    "u1" - only u1 is permitted, "u2" - only u2 is permitted, "u1_u2" -
    both u1 and u2 are permitted. With this interface, users can use an
    LPM-unfriendly USB device on a released Linux kernel.
    
    Signed-off-by: Lu Baolu <baolu.lu@linux.intel.com>
    Signed-off-by: Zhuang Jin Can <jin.can.zhuang@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/port.c b/drivers/usb/core/port.c
index 210618319f10..cb18ce0d9177 100644
--- a/drivers/usb/core/port.c
+++ b/drivers/usb/core/port.c
@@ -50,6 +50,72 @@ static ssize_t connect_type_show(struct device *dev,
 }
 static DEVICE_ATTR_RO(connect_type);
 
+static ssize_t usb3_lpm_permit_show(struct device *dev,
+			      struct device_attribute *attr, char *buf)
+{
+	struct usb_port *port_dev = to_usb_port(dev);
+	const char *p;
+
+	if (port_dev->usb3_lpm_u1_permit) {
+		if (port_dev->usb3_lpm_u2_permit)
+			p = "u1_u2";
+		else
+			p = "u1";
+	} else {
+		if (port_dev->usb3_lpm_u2_permit)
+			p = "u2";
+		else
+			p = "0";
+	}
+
+	return sprintf(buf, "%s\n", p);
+}
+
+static ssize_t usb3_lpm_permit_store(struct device *dev,
+			       struct device_attribute *attr,
+			       const char *buf, size_t count)
+{
+	struct usb_port *port_dev = to_usb_port(dev);
+	struct usb_device *udev = port_dev->child;
+	struct usb_hcd *hcd;
+
+	if (!strncmp(buf, "u1_u2", 5)) {
+		port_dev->usb3_lpm_u1_permit = 1;
+		port_dev->usb3_lpm_u2_permit = 1;
+
+	} else if (!strncmp(buf, "u1", 2)) {
+		port_dev->usb3_lpm_u1_permit = 1;
+		port_dev->usb3_lpm_u2_permit = 0;
+
+	} else if (!strncmp(buf, "u2", 2)) {
+		port_dev->usb3_lpm_u1_permit = 0;
+		port_dev->usb3_lpm_u2_permit = 1;
+
+	} else if (!strncmp(buf, "0", 1)) {
+		port_dev->usb3_lpm_u1_permit = 0;
+		port_dev->usb3_lpm_u2_permit = 0;
+	} else
+		return -EINVAL;
+
+	/* If device is connected to the port, disable or enable lpm
+	 * to make new u1 u2 setting take effect immediately.
+	 */
+	if (udev) {
+		hcd = bus_to_hcd(udev->bus);
+		if (!hcd)
+			return -EINVAL;
+		usb_lock_device(udev);
+		mutex_lock(hcd->bandwidth_mutex);
+		if (!usb_disable_lpm(udev))
+			usb_enable_lpm(udev);
+		mutex_unlock(hcd->bandwidth_mutex);
+		usb_unlock_device(udev);
+	}
+
+	return count;
+}
+static DEVICE_ATTR_RW(usb3_lpm_permit);
+
 static struct attribute *port_dev_attrs[] = {
 	&dev_attr_connect_type.attr,
 	NULL,
@@ -64,6 +130,21 @@ static const struct attribute_group *port_dev_group[] = {
 	NULL,
 };
 
+static struct attribute *port_dev_usb3_attrs[] = {
+	&dev_attr_usb3_lpm_permit.attr,
+	NULL,
+};
+
+static struct attribute_group port_dev_usb3_attr_grp = {
+	.attrs = port_dev_usb3_attrs,
+};
+
+static const struct attribute_group *port_dev_usb3_group[] = {
+	&port_dev_attr_grp,
+	&port_dev_usb3_attr_grp,
+	NULL,
+};
+
 static void usb_port_device_release(struct device *dev)
 {
 	struct usb_port *port_dev = to_usb_port(dev);
@@ -401,6 +482,7 @@ static void find_and_link_peer(struct usb_hub *hub, int port1)
 int usb_hub_create_port_device(struct usb_hub *hub, int port1)
 {
 	struct usb_port *port_dev;
+	struct usb_device *hdev = hub->hdev;
 	int retval;
 
 	port_dev = kzalloc(sizeof(*port_dev), GFP_KERNEL);
@@ -417,7 +499,12 @@ int usb_hub_create_port_device(struct usb_hub *hub, int port1)
 	port_dev->portnum = port1;
 	set_bit(port1, hub->power_bits);
 	port_dev->dev.parent = hub->intfdev;
-	port_dev->dev.groups = port_dev_group;
+	if (hub_is_superspeed(hdev)) {
+		port_dev->usb3_lpm_u1_permit = 1;
+		port_dev->usb3_lpm_u2_permit = 1;
+		port_dev->dev.groups = port_dev_usb3_group;
+	} else
+		port_dev->dev.groups = port_dev_group;
 	port_dev->dev.type = &usb_port_device_type;
 	port_dev->dev.driver = &usb_port_driver;
 	if (hub_is_superspeed(hub->hdev))

commit ceb6c9c862c86423f41c1e20ecf8d454f837f519
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Nov 29 23:47:05 2014 +0100

    USB / PM: Drop CONFIG_PM_RUNTIME from the USB core
    
    After commit b2b49ccbdd54 (PM: Kconfig: Set PM_RUNTIME if PM_SLEEP is
    selected) PM_RUNTIME is always set if PM is set, so quite a few
    depend on CONFIG_PM (or even dropped in some cases).
    
    Replace CONFIG_PM_RUNTIME with CONFIG_PM in the USB core code
    and documentation.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/port.c b/drivers/usb/core/port.c
index cd3f9dc24a06..210618319f10 100644
--- a/drivers/usb/core/port.c
+++ b/drivers/usb/core/port.c
@@ -72,7 +72,7 @@ static void usb_port_device_release(struct device *dev)
 	kfree(port_dev);
 }
 
-#ifdef CONFIG_PM_RUNTIME
+#ifdef CONFIG_PM
 static int usb_port_runtime_resume(struct device *dev)
 {
 	struct usb_port *port_dev = to_usb_port(dev);
@@ -171,7 +171,7 @@ static int usb_port_runtime_suspend(struct device *dev)
 #endif
 
 static const struct dev_pm_ops usb_port_pm_ops = {
-#ifdef CONFIG_PM_RUNTIME
+#ifdef CONFIG_PM
 	.runtime_suspend =	usb_port_runtime_suspend,
 	.runtime_resume =	usb_port_runtime_resume,
 #endif

commit 3cd12f91514da6893954de479dc60b16d3b381f4
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu May 29 12:58:46 2014 -0700

    usb: force warm reset to break link re-connect livelock
    
    Resuming a powered down port sometimes results in the port state being
    stuck in the training sequence.
    
     hub 3-0:1.0: debounce: port 1: total 2000ms stable 0ms status 0x2e0
     port1: can't get reconnection after setting port  power on, status -110
     hub 3-0:1.0: port 1 status 0000.02e0 after resume, -19
     usb 3-1: can't resume, status -19
     hub 3-0:1.0: logical disconnect on port 1
    
    In the case above we wait for the port re-connect timeout of 2 seconds
    and observe that the port status is USB_SS_PORT_LS_POLLING (although it
    is likely toggling between this state and USB_SS_PORT_LS_RX_DETECT).
    This is indicative of a case where the device is failing to progress the
    link training state machine.
    
    It is resolved by issuing a warm reset to get the hub and device link
    state machines back in sync.
    
     hub 3-0:1.0: debounce: port 1: total 2000ms stable 0ms status 0x2e0
     usb usb3: port1 usb_port_runtime_resume requires warm reset
     hub 3-0:1.0: port 1 not warm reset yet, waiting 50ms
     usb 3-1: reset SuperSpeed USB device number 2 using xhci_hcd
    
    After a reconnect timeout when we expect the device to be present, force
    a warm reset of the device.  Note that we can not simply look at the
    link status to determine if a warm reset is required as any of the
    training states USB_SS_PORT_LS_POLLING, USB_SS_PORT_LS_RX_DETECT, or
    USB_SS_PORT_LS_COMP_MOD are valid states that do not indicate the need
    for warm reset by themselves.
    
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Kukjin Kim <kgene.kim@samsung.com>
    Cc: Vincent Palatin <vpalatin@chromium.org>
    Cc: Lan Tianyu <tianyu.lan@intel.com>
    Cc: Ksenia Ragiadakou <burzalodowa@gmail.com>
    Cc: Vivek Gautam <gautam.vivek@samsung.com>
    Cc: Douglas Anderson <dianders@chromium.org>
    Cc: Felipe Balbi <balbi@ti.com>
    Cc: Sunil Joshi <joshi@samsung.com>
    Cc: Hans de Goede <hdegoede@redhat.com>
    Acked-by: Julius Werner <jwerner@chromium.org>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/port.c b/drivers/usb/core/port.c
index fe1b6d0967e3..cd3f9dc24a06 100644
--- a/drivers/usb/core/port.c
+++ b/drivers/usb/core/port.c
@@ -103,16 +103,19 @@ static int usb_port_runtime_resume(struct device *dev)
 	msleep(hub_power_on_good_delay(hub));
 	if (udev && !retval) {
 		/*
-		 * Attempt to wait for usb hub port to be reconnected in order
-		 * to make the resume procedure successful.  The device may have
-		 * disconnected while the port was powered off, so ignore the
-		 * return status.
+		 * Our preference is to simply wait for the port to reconnect,
+		 * as that is the lowest latency method to restart the port.
+		 * However, there are cases where toggling port power results in
+		 * the host port and the device port getting out of sync causing
+		 * a link training live lock.  Upon timeout, flag the port as
+		 * needing warm reset recovery (to be performed later by
+		 * usb_port_resume() as requested via usb_wakeup_notification())
 		 */
-		retval = hub_port_debounce_be_connected(hub, port1);
-		if (retval < 0)
-			dev_dbg(&port_dev->dev, "can't get reconnection after setting port  power on, status %d\n",
-					retval);
-		retval = 0;
+		if (hub_port_debounce_be_connected(hub, port1) < 0) {
+			dev_dbg(&port_dev->dev, "reconnect timeout\n");
+			if (hub_is_superspeed(hdev))
+				set_bit(port1, hub->warm_reset_bits);
+		}
 
 		/* Force the child awake to revalidate after the power loss. */
 		if (!test_and_set_bit(port1, hub->child_usage_bits)) {

commit e3d105055525d9ea9f8e9cb0db8237df3df1bb9f
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue Jun 17 16:16:32 2014 -0700

    usb: fix hub-port pm_runtime_enable() vs runtime pm transitions
    
    Commit 9262c19d14c4 "usb: disable port power control if not supported in
    wHubCharacteristics" gated enabling runtime pm for usb_port devices on
    whether the parent hub supports power control, which causes a
    regression.  The port must still be allowed to carry out runtime pm
    callbacks and receive a -EAGAIN or -EBUSY result.  Otherwise the
    usb_port device will transition to the pm error state and trigger the
    same for the child usb_device.
    
    Prior to the offending commit usb_hub_create_port_device() arranged for
    runtime pm to be disabled is dev_pm_qos_expose_flags() failed.  Instead,
    force the default state of PM_QOS_FLAG_NO_POWER_OFF flag to be set prior
    to enabling runtime pm.  If that policy can not be set then fail
    registration.
    
    Report: http://marc.info/?l=linux-usb&m=140290586301336&w=2
    Fixes: 9262c19d14c4 ("usb: disable port power control if not supported in wHubCharacteristics")
    Reported-by: Bjørn Mork <bjorn@mork.no>
    Reported-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/port.c b/drivers/usb/core/port.c
index 9347ade7d5fe..fe1b6d0967e3 100644
--- a/drivers/usb/core/port.c
+++ b/drivers/usb/core/port.c
@@ -68,6 +68,7 @@ static void usb_port_device_release(struct device *dev)
 {
 	struct usb_port *port_dev = to_usb_port(dev);
 
+	kfree(port_dev->req);
 	kfree(port_dev);
 }
 
@@ -400,9 +401,13 @@ int usb_hub_create_port_device(struct usb_hub *hub, int port1)
 	int retval;
 
 	port_dev = kzalloc(sizeof(*port_dev), GFP_KERNEL);
-	if (!port_dev) {
-		retval = -ENOMEM;
-		goto exit;
+	if (!port_dev)
+		return -ENOMEM;
+
+	port_dev->req = kzalloc(sizeof(*(port_dev->req)), GFP_KERNEL);
+	if (!port_dev->req) {
+		kfree(port_dev);
+		return -ENOMEM;
 	}
 
 	hub->ports[port1 - 1] = port_dev;
@@ -418,31 +423,53 @@ int usb_hub_create_port_device(struct usb_hub *hub, int port1)
 			port1);
 	mutex_init(&port_dev->status_lock);
 	retval = device_register(&port_dev->dev);
-	if (retval)
-		goto error_register;
+	if (retval) {
+		put_device(&port_dev->dev);
+		return retval;
+	}
+
+	/* Set default policy of port-poweroff disabled. */
+	retval = dev_pm_qos_add_request(&port_dev->dev, port_dev->req,
+			DEV_PM_QOS_FLAGS, PM_QOS_FLAG_NO_POWER_OFF);
+	if (retval < 0) {
+		device_unregister(&port_dev->dev);
+		return retval;
+	}
 
 	find_and_link_peer(hub, port1);
 
+	/*
+	 * Enable runtime pm and hold a refernce that hub_configure()
+	 * will drop once the PM_QOS_NO_POWER_OFF flag state has been set
+	 * and the hub has been fully registered (hdev->maxchild set).
+	 */
 	pm_runtime_set_active(&port_dev->dev);
+	pm_runtime_get_noresume(&port_dev->dev);
+	pm_runtime_enable(&port_dev->dev);
+	device_enable_async_suspend(&port_dev->dev);
 
 	/*
-	 * Do not enable port runtime pm if the hub does not support
-	 * power switching.  Also, userspace must have final say of
-	 * whether a port is permitted to power-off.  Do not enable
-	 * runtime pm if we fail to expose pm_qos_no_power_off.
+	 * Keep hidden the ability to enable port-poweroff if the hub
+	 * does not support power switching.
 	 */
-	if (hub_is_port_power_switchable(hub)
-			&& dev_pm_qos_expose_flags(&port_dev->dev,
-			PM_QOS_FLAG_NO_POWER_OFF) == 0)
-		pm_runtime_enable(&port_dev->dev);
+	if (!hub_is_port_power_switchable(hub))
+		return 0;
 
-	device_enable_async_suspend(&port_dev->dev);
-	return 0;
+	/* Attempt to let userspace take over the policy. */
+	retval = dev_pm_qos_expose_flags(&port_dev->dev,
+			PM_QOS_FLAG_NO_POWER_OFF);
+	if (retval < 0) {
+		dev_warn(&port_dev->dev, "failed to expose pm_qos_no_poweroff\n");
+		return 0;
+	}
 
-error_register:
-	put_device(&port_dev->dev);
-exit:
-	return retval;
+	/* Userspace owns the policy, drop the kernel 'no_poweroff' request. */
+	retval = dev_pm_qos_remove_request(port_dev->req);
+	if (retval >= 0) {
+		kfree(port_dev->req);
+		port_dev->req = NULL;
+	}
+	return 0;
 }
 
 void usb_hub_remove_port_device(struct usb_hub *hub, int port1)

commit 6c79fe4afcb0450bd638f6e959e512aad270ff2f
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue Jun 17 16:16:27 2014 -0700

    usb: quiet peer failure warning, disable poweroff
    
    In the case where platform firmware has specified conflicting values for
    port locations it is confusing and otherwise not helpful to throw a
    backtrace.  Instead, include enough information to determine that
    firmware has done something wrong and globally disable port poweroff.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/port.c b/drivers/usb/core/port.c
index 62036faf56c0..9347ade7d5fe 100644
--- a/drivers/usb/core/port.c
+++ b/drivers/usb/core/port.c
@@ -21,6 +21,8 @@
 
 #include "hub.h"
 
+static int usb_port_block_power_off;
+
 static const struct attribute_group *port_dev_group[];
 
 static ssize_t connect_type_show(struct device *dev,
@@ -142,6 +144,9 @@ static int usb_port_runtime_suspend(struct device *dev)
 			== PM_QOS_FLAGS_ALL)
 		return -EAGAIN;
 
+	if (usb_port_block_power_off)
+		return -EBUSY;
+
 	usb_autopm_get_interface(intf);
 	retval = usb_hub_set_port_power(hdev, hub, port1, false);
 	usb_clear_port_feature(hdev, port1, USB_PORT_FEAT_C_CONNECTION);
@@ -190,11 +195,19 @@ static int link_peers(struct usb_port *left, struct usb_port *right)
 	if (left->peer || right->peer) {
 		struct usb_port *lpeer = left->peer;
 		struct usb_port *rpeer = right->peer;
-
-		WARN(1, "failed to peer %s and %s (%s -> %p) (%s -> %p)\n",
-			dev_name(&left->dev), dev_name(&right->dev),
-			dev_name(&left->dev), lpeer,
-			dev_name(&right->dev), rpeer);
+		char *method;
+
+		if (left->location && left->location == right->location)
+			method = "location";
+		else
+			method = "default";
+
+		pr_warn("usb: failed to peer %s and %s by %s (%s:%s) (%s:%s)\n",
+			dev_name(&left->dev), dev_name(&right->dev), method,
+			dev_name(&left->dev),
+			lpeer ? dev_name(&lpeer->dev) : "none",
+			dev_name(&right->dev),
+			rpeer ? dev_name(&rpeer->dev) : "none");
 		return -EBUSY;
 	}
 
@@ -251,6 +264,7 @@ static void link_peers_report(struct usb_port *left, struct usb_port *right)
 		dev_warn(&left->dev, "failed to peer to %s (%d)\n",
 				dev_name(&right->dev), rc);
 		pr_warn_once("usb: port power management may be unreliable\n");
+		usb_port_block_power_off = 1;
 	}
 }
 

commit 7027df36e41836b11f01b0d30eee40c55df7d013
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue May 20 18:09:36 2014 -0700

    usb: resume child device when port is powered on
    
    Unconditionally wake up the child device when the power session is
    recovered.
    
    This addresses the following scenarios:
    
    1/ The device may need a reset on power-session loss, without this
       change port power-on recovery exposes khubd to scenarios that
       usb_port_resume() is set to handle.  Prior to port power control the
       only time a power session would be lost is during dpm_suspend of the
       hub.  In that scenario usb_port_resume() is guaranteed to be called
       prior to khubd running for that port.  With this change we wakeup the
       child device as soon as possible (prior to khubd running again for this
       port).
    
       Although khubd has facilities to wake a child device it will only do
       so if the portstatus / portchange indicates a suspend state.  In the
       case of port power control we are not coming from a hub-port-suspend
       state.  This implementation simply uses pm_request_resume() to wake the
       device and relies on the port_dev->status_lock to prevent any collisions
       between khubd and usb_port_resume().
    
    2/ This mechanism rate limits port power toggling.  The minimum port
       power on/off period is now gated by the child device suspend/resume
       latency.  Empirically this mitigates devices downgrading their connection
       on perceived instability of the host connection.  This ratelimiting is
       really only relevant to port power control testing, but it is a nice
       side effect of closing the above race.  Namely, the race of khubd for
       the given port running while a usb_port_resume() event is pending.
    
    3/ Going forward we are finding that power-session recovery requires
       warm-resets (http://marc.info/?t=138659232900003&r=1&w=2).  This
       mechanism allows for warm-resets to be requested at the same point in
       the resume path for hub dpm_suspend power session losses, or port
       rpm_suspend power session losses.
    
    4/ If the device *was* disconnected the only time we'll know for sure is
       after a failed resume, so it's necessary for usb_port_runtime_resume()
       to expedite a usb_port_resume() to clean up the removed device.  The
       reasoning for this is "least surprise" for the user. Turning on a port
       means that hotplug detection is again enabled for the port, it is
       surprising that devices that were removed while the port was off are not
       disconnected until they are attempted to be used.  As a user "why would
       I try to use a device I removed from the system?"
    
    1, 2, and 4 are not a problem in the system dpm_resume() case because,
    although the power-session is lost, khubd is frozen until after device
    resume.  For the rpm_resume() case pm_request_resume() is used to
    request re-validation of the device, and if it happens to collide with a
    khubd run we rely on the port_dev->status_lock to synchronize those
    operations.
    
    Besides testing, the primary scenario where this mechanism is expected
    to be triggered is when the user changes the port power policy
    (control/pm_qos_no_poweroff, or power/control).   Each time power is
    enabled want to revalidate the child device, where the revalidation is
    handled by usb_port_resume().
    
    Given that this arranges for port_dev->child to be de-referenced in
    usb_port_runtime_resume() we need to make sure not to collide with
    usb_disconnect() that frees the usb_device.  To this end we hold the
    port active with the "child_usage" reference across the disconnect
    event.  Subsequently, the need to access hub->child_usage_bits lead to
    the creation of hub_disconnect_children() to remove any ambiguity of
    which "hub" is being acted on in usb_disconnect() (prompted-by sharp
    eyes from Alan).
    
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/port.c b/drivers/usb/core/port.c
index 8b1655700104..62036faf56c0 100644
--- a/drivers/usb/core/port.c
+++ b/drivers/usb/core/port.c
@@ -76,6 +76,7 @@ static int usb_port_runtime_resume(struct device *dev)
 	struct usb_device *hdev = to_usb_device(dev->parent->parent);
 	struct usb_interface *intf = to_usb_interface(dev->parent);
 	struct usb_hub *hub = usb_hub_to_struct_hub(hdev);
+	struct usb_device *udev = port_dev->child;
 	struct usb_port *peer = port_dev->peer;
 	int port1 = port_dev->portnum;
 	int retval;
@@ -97,7 +98,7 @@ static int usb_port_runtime_resume(struct device *dev)
 	usb_autopm_get_interface(intf);
 	retval = usb_hub_set_port_power(hdev, hub, port1, true);
 	msleep(hub_power_on_good_delay(hub));
-	if (port_dev->child && !retval) {
+	if (udev && !retval) {
 		/*
 		 * Attempt to wait for usb hub port to be reconnected in order
 		 * to make the resume procedure successful.  The device may have
@@ -109,6 +110,12 @@ static int usb_port_runtime_resume(struct device *dev)
 			dev_dbg(&port_dev->dev, "can't get reconnection after setting port  power on, status %d\n",
 					retval);
 		retval = 0;
+
+		/* Force the child awake to revalidate after the power loss. */
+		if (!test_and_set_bit(port1, hub->child_usage_bits)) {
+			pm_runtime_get_noresume(&port_dev->dev);
+			pm_request_resume(&udev->dev);
+		}
 	}
 
 	usb_autopm_put_interface(intf);

commit 5c79a1e303363d46082408fd306cdea6d33013fc
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue May 20 18:09:26 2014 -0700

    usb: introduce port status lock
    
    In general we do not want khubd to act on port status changes that are
    the result of in progress resets or USB runtime PM operations.
    Specifically port power control testing has been able to trigger an
    unintended disconnect in hub_port_connect_change(), paraphrasing:
    
            if ((portstatus & USB_PORT_STAT_CONNECTION) && udev &&
                udev->state != USB_STATE_NOTATTACHED) {
                    if (portstatus & USB_PORT_STAT_ENABLE) {
                            /* Nothing to do */
                    } else if (udev->state == USB_STATE_SUSPENDED &&
                                    udev->persist_enabled) {
                            ...
                    } else {
                            /* Don't resuscitate */;
                    }
            }
    
    ...by falling to the "Don't resuscitate" path or missing
    USB_PORT_STAT_CONNECTION because usb_port_resume() was in the middle of
    modifying the port status.
    
    So, we want a new lock to hold off khubd for a given port while the
    child device is being suspended, resumed, or reset.  The lock ordering
    rules are now usb_lock_device() => usb_lock_port().  This is mandated by
    the device core which may hold the device_lock on the usb_device before
    invoking usb_port_{suspend|resume} which in turn take the status_lock on
    the usb_port.  We attempt to hold the status_lock for the duration of a
    port_event() run, and drop/re-acquire it when needing to take the
    device_lock.  The lock is also dropped/re-acquired during
    hub_port_reconnect().
    
    This patch also deletes hub->busy_bits as all use cases are now covered
    by port PM runtime synchronization or the port->status_lock and it
    pushes down usb_device_lock() into usb_remote_wakeup().
    
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/port.c b/drivers/usb/core/port.c
index fb83c2c13920..8b1655700104 100644
--- a/drivers/usb/core/port.c
+++ b/drivers/usb/core/port.c
@@ -95,8 +95,6 @@ static int usb_port_runtime_resume(struct device *dev)
 		pm_runtime_get_sync(&peer->dev);
 
 	usb_autopm_get_interface(intf);
-	set_bit(port1, hub->busy_bits);
-
 	retval = usb_hub_set_port_power(hdev, hub, port1, true);
 	msleep(hub_power_on_good_delay(hub));
 	if (port_dev->child && !retval) {
@@ -113,7 +111,6 @@ static int usb_port_runtime_resume(struct device *dev)
 		retval = 0;
 	}
 
-	clear_bit(port1, hub->busy_bits);
 	usb_autopm_put_interface(intf);
 
 	return retval;
@@ -139,12 +136,10 @@ static int usb_port_runtime_suspend(struct device *dev)
 		return -EAGAIN;
 
 	usb_autopm_get_interface(intf);
-	set_bit(port1, hub->busy_bits);
 	retval = usb_hub_set_port_power(hdev, hub, port1, false);
 	usb_clear_port_feature(hdev, port1, USB_PORT_FEAT_C_CONNECTION);
 	if (!port_dev->is_superspeed)
 		usb_clear_port_feature(hdev, port1, USB_PORT_FEAT_C_ENABLE);
-	clear_bit(port1, hub->busy_bits);
 	usb_autopm_put_interface(intf);
 
 	/*
@@ -400,6 +395,7 @@ int usb_hub_create_port_device(struct usb_hub *hub, int port1)
 		port_dev->is_superspeed = 1;
 	dev_set_name(&port_dev->dev, "%s-port%d", dev_name(&hub->hdev->dev),
 			port1);
+	mutex_init(&port_dev->status_lock);
 	retval = device_register(&port_dev->dev);
 	if (retval)
 		goto error_register;

commit 6908058469e3253637894d1cb3e2581870c77e1d
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue May 20 18:09:10 2014 -0700

    usb: usb3 ports do not support FEAT_C_ENABLE
    
    The port pm_runtime implementation unconditionally clears FEAT_C_ENABLE
    after clearing PORT_POWER, but the bit is reserved on usb3 hub ports.
    We expect khubd to be prevented from running because the port state is
    not RPM_ACTIVE, so we need to clear any errors for usb2 ports.
    
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/port.c b/drivers/usb/core/port.c
index f41f0512307e..fb83c2c13920 100644
--- a/drivers/usb/core/port.c
+++ b/drivers/usb/core/port.c
@@ -142,7 +142,8 @@ static int usb_port_runtime_suspend(struct device *dev)
 	set_bit(port1, hub->busy_bits);
 	retval = usb_hub_set_port_power(hdev, hub, port1, false);
 	usb_clear_port_feature(hdev, port1, USB_PORT_FEAT_C_CONNECTION);
-	usb_clear_port_feature(hdev, port1,	USB_PORT_FEAT_C_ENABLE);
+	if (!port_dev->is_superspeed)
+		usb_clear_port_feature(hdev, port1, USB_PORT_FEAT_C_ENABLE);
 	clear_bit(port1, hub->busy_bits);
 	usb_autopm_put_interface(intf);
 

commit 7c604079bdf729e7b8c4b0e67c688b5081d1863d
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue May 20 18:09:03 2014 -0700

    usb: don't clear FEAT_C_ENABLE on usb_port_runtime_resume failure
    
    Three reasons:
    1/ It's an invalid operation on usb3 ports
    2/ There's no guarantee of when / if a usb2 port has entered an error
       state relative to PORT_POWER request
    3/ The port is active / powered at this point, so khubd will clear it as
       a matter of course
    
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/port.c b/drivers/usb/core/port.c
index 827b0d38f73d..f41f0512307e 100644
--- a/drivers/usb/core/port.c
+++ b/drivers/usb/core/port.c
@@ -110,7 +110,6 @@ static int usb_port_runtime_resume(struct device *dev)
 		if (retval < 0)
 			dev_dbg(&port_dev->dev, "can't get reconnection after setting port  power on, status %d\n",
 					retval);
-		usb_clear_port_feature(hdev, port1, USB_PORT_FEAT_C_ENABLE);
 		retval = 0;
 	}
 

commit 7ad3c47088f9faec463f5226e5e968a5c3b0e593
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue May 20 18:08:57 2014 -0700

    usb: block suspension of superspeed port while hispeed peer is active
    
    ClearPortFeature(PORT_POWER) on a usb3 port places the port in either a
    DSPORT.Powered-off-detect / DSPORT.Powered-off-reset loop, or the
    DSPORT.Powered-off state.  There is no way to ensure that RX
    terminations will persist in this state, so it is possible a device will
    degrade to its usb2 connection.  Prevent this by blocking power-off of a
    usb3 port while its usb2 peer is active, and powering on a usb3 port
    before its usb2 peer.
    
    By default the latency between peer power-on events is 0.  In order for
    the device to not see usb2 active while usb3 is still powering up inject
    the hub recommended power_on_good delay.  In support of satisfying the
    power_on_good delay outside of hub_power_on() refactor the places where
    the delay is consumed to call a new hub_power_on_good_delay() helper.
    
    Finally, because this introduces several new checks for whether a port
    is_superspeed, cache that disctinction at port creation so that we don't
    need to keep looking up the parent hub device.
    
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    [alan]: add a 'superspeed' flag to the port
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/port.c b/drivers/usb/core/port.c
index 795778c71e31..827b0d38f73d 100644
--- a/drivers/usb/core/port.c
+++ b/drivers/usb/core/port.c
@@ -76,6 +76,7 @@ static int usb_port_runtime_resume(struct device *dev)
 	struct usb_device *hdev = to_usb_device(dev->parent->parent);
 	struct usb_interface *intf = to_usb_interface(dev->parent);
 	struct usb_hub *hub = usb_hub_to_struct_hub(hdev);
+	struct usb_port *peer = port_dev->peer;
 	int port1 = port_dev->portnum;
 	int retval;
 
@@ -86,10 +87,18 @@ static int usb_port_runtime_resume(struct device *dev)
 		return 0;
 	}
 
+	/*
+	 * Power on our usb3 peer before this usb2 port to prevent a usb3
+	 * device from degrading to its usb2 connection
+	 */
+	if (!port_dev->is_superspeed && peer)
+		pm_runtime_get_sync(&peer->dev);
+
 	usb_autopm_get_interface(intf);
 	set_bit(port1, hub->busy_bits);
 
 	retval = usb_hub_set_port_power(hdev, hub, port1, true);
+	msleep(hub_power_on_good_delay(hub));
 	if (port_dev->child && !retval) {
 		/*
 		 * Attempt to wait for usb hub port to be reconnected in order
@@ -107,6 +116,7 @@ static int usb_port_runtime_resume(struct device *dev)
 
 	clear_bit(port1, hub->busy_bits);
 	usb_autopm_put_interface(intf);
+
 	return retval;
 }
 
@@ -116,6 +126,7 @@ static int usb_port_runtime_suspend(struct device *dev)
 	struct usb_device *hdev = to_usb_device(dev->parent->parent);
 	struct usb_interface *intf = to_usb_interface(dev->parent);
 	struct usb_hub *hub = usb_hub_to_struct_hub(hdev);
+	struct usb_port *peer = port_dev->peer;
 	int port1 = port_dev->portnum;
 	int retval;
 
@@ -135,6 +146,15 @@ static int usb_port_runtime_suspend(struct device *dev)
 	usb_clear_port_feature(hdev, port1,	USB_PORT_FEAT_C_ENABLE);
 	clear_bit(port1, hub->busy_bits);
 	usb_autopm_put_interface(intf);
+
+	/*
+	 * Our peer usb3 port may now be able to suspend, so
+	 * asynchronously queue a suspend request to observe that this
+	 * usb2 port is now off.
+	 */
+	if (!port_dev->is_superspeed && peer)
+		pm_runtime_put(&peer->dev);
+
 	return retval;
 }
 #endif
@@ -159,6 +179,7 @@ static struct device_driver usb_port_driver = {
 
 static int link_peers(struct usb_port *left, struct usb_port *right)
 {
+	struct usb_port *ss_port, *hs_port;
 	int rc;
 
 	if (left->peer == right && right->peer == left)
@@ -184,9 +205,36 @@ static int link_peers(struct usb_port *left, struct usb_port *right)
 		return rc;
 	}
 
+	/*
+	 * We need to wake the HiSpeed port to make sure we don't race
+	 * setting ->peer with usb_port_runtime_suspend().  Otherwise we
+	 * may miss a suspend event for the SuperSpeed port.
+	 */
+	if (left->is_superspeed) {
+		ss_port = left;
+		WARN_ON(right->is_superspeed);
+		hs_port = right;
+	} else {
+		ss_port = right;
+		WARN_ON(!right->is_superspeed);
+		hs_port = left;
+	}
+	pm_runtime_get_sync(&hs_port->dev);
+
 	left->peer = right;
 	right->peer = left;
 
+	/*
+	 * The SuperSpeed reference is dropped when the HiSpeed port in
+	 * this relationship suspends, i.e. when it is safe to allow a
+	 * SuperSpeed connection to drop since there is no risk of a
+	 * device degrading to its powered-off HiSpeed connection.
+	 *
+	 * Also, drop the HiSpeed ref taken above.
+	 */
+	pm_runtime_get_sync(&ss_port->dev);
+	pm_runtime_put(&hs_port->dev);
+
 	return 0;
 }
 
@@ -206,14 +254,37 @@ static void link_peers_report(struct usb_port *left, struct usb_port *right)
 
 static void unlink_peers(struct usb_port *left, struct usb_port *right)
 {
+	struct usb_port *ss_port, *hs_port;
+
 	WARN(right->peer != left || left->peer != right,
 			"%s and %s are not peers?\n",
 			dev_name(&left->dev), dev_name(&right->dev));
 
+	/*
+	 * We wake the HiSpeed port to make sure we don't race its
+	 * usb_port_runtime_resume() event which takes a SuperSpeed ref
+	 * when ->peer is !NULL.
+	 */
+	if (left->is_superspeed) {
+		ss_port = left;
+		hs_port = right;
+	} else {
+		ss_port = right;
+		hs_port = left;
+	}
+
+	pm_runtime_get_sync(&hs_port->dev);
+
 	sysfs_remove_link(&left->dev.kobj, "peer");
 	right->peer = NULL;
 	sysfs_remove_link(&right->dev.kobj, "peer");
 	left->peer = NULL;
+
+	/* Drop the SuperSpeed ref held on behalf of the active HiSpeed port */
+	pm_runtime_put(&ss_port->dev);
+
+	/* Drop the ref taken above */
+	pm_runtime_put(&hs_port->dev);
 }
 
 /*
@@ -325,6 +396,8 @@ int usb_hub_create_port_device(struct usb_hub *hub, int port1)
 	port_dev->dev.groups = port_dev_group;
 	port_dev->dev.type = &usb_port_device_type;
 	port_dev->dev.driver = &usb_port_driver;
+	if (hub_is_superspeed(hub->hdev))
+		port_dev->is_superspeed = 1;
 	dev_set_name(&port_dev->dev, "%s-port%d", dev_name(&hub->hdev->dev),
 			port1);
 	retval = device_register(&port_dev->dev);

commit d5c3834e4af3acc4d7fc52faba2711c666655632
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue May 20 18:08:52 2014 -0700

    usb: make usb_port flags atomic, rename did_runtime_put to child_usage
    
    We want to manipulate ->did_runtime_put in usb_port_runtime_resume(),
    but we don't want that to collide with other updates.  Move usb_port
    flags to new port-bitmap fields in usb_hub. "did_runtime_put" is renamed
    "child_usage_bits" to reflect that it is strictly standing in for the
    fact that usb_devices are not the device_model children of their parent
    port.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/port.c b/drivers/usb/core/port.c
index 40c3ac173e9e..795778c71e31 100644
--- a/drivers/usb/core/port.c
+++ b/drivers/usb/core/port.c
@@ -82,7 +82,7 @@ static int usb_port_runtime_resume(struct device *dev)
 	if (!hub)
 		return -EINVAL;
 	if (hub->in_reset) {
-		port_dev->power_is_on = 1;
+		set_bit(port1, hub->power_bits);
 		return 0;
 	}
 
@@ -320,7 +320,7 @@ int usb_hub_create_port_device(struct usb_hub *hub, int port1)
 
 	hub->ports[port1 - 1] = port_dev;
 	port_dev->portnum = port1;
-	port_dev->power_is_on = true;
+	set_bit(port1, hub->power_bits);
 	port_dev->dev.parent = hub->intfdev;
 	port_dev->dev.groups = port_dev_group;
 	port_dev->dev.type = &usb_port_device_type;

commit b7e38eac88265c4cb779edc72a5906116fc6c000
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue May 20 18:08:45 2014 -0700

    usb: sysfs link peer ports
    
    The usb topology after this change will have symlinks between usb3 ports
    and their usb2 peers, for example:
    
    usb2/2-1/2-1:1.0/2-1-port1/peer => ../../../../usb3/3-1/3-1:1.0/3-1-port1
    usb2/2-1/2-1:1.0/2-1-port2/peer => ../../../../usb3/3-1/3-1:1.0/3-1-port2
    usb2/2-1/2-1:1.0/2-1-port3/peer => ../../../../usb3/3-1/3-1:1.0/3-1-port3
    usb2/2-1/2-1:1.0/2-1-port4/peer => ../../../../usb3/3-1/3-1:1.0/3-1-port4
    usb2/2-0:1.0/usb2-port1/peer    => ../../../usb3/3-0:1.0/usb3-port1
    usb2/2-0:1.0/usb2-port2/peer    => ../../../usb3/3-0:1.0/usb3-port2
    usb2/2-0:1.0/usb2-port3/peer    => ../../../usb3/3-0:1.0/usb3-port3
    usb2/2-0:1.0/usb2-port4/peer    => ../../../usb3/3-0:1.0/usb3-port4
    
    usb3/3-1/3-1:1.0/usb3-1-port1/peer => ../../../../usb2/2-1/2-1:1.0/2-1-port1
    usb3/3-1/3-1:1.0/usb3-1-port2/peer => ../../../../usb2/2-1/2-1:1.0/2-1-port2
    usb3/3-1/3-1:1.0/usb3-1-port3/peer => ../../../../usb2/2-1/2-1:1.0/2-1-port3
    usb3/3-1/3-1:1.0/usb3-1-port4/peer => ../../../../usb2/2-1/2-1:1.0/2-1-port4
    usb3/3-0:1.0/usb3-port1/peer       => ../../../usb2/2-0:1.0/usb2-port1
    usb3/3-0:1.0/usb3-port2/peer       => ../../../usb2/2-0:1.0/usb2-port2
    usb3/3-0:1.0/usb3-port3/peer       => ../../../usb2/2-0:1.0/usb2-port3
    usb3/3-0:1.0/usb3-port4/peer       => ../../../usb2/2-0:1.0/usb2-port4
    
    Introduce link_peers_report() to notify on all link_peers() failure
    cases.
    
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/port.c b/drivers/usb/core/port.c
index aea54e8dfe47..40c3ac173e9e 100644
--- a/drivers/usb/core/port.c
+++ b/drivers/usb/core/port.c
@@ -157,10 +157,12 @@ static struct device_driver usb_port_driver = {
 	.owner = THIS_MODULE,
 };
 
-static void link_peers(struct usb_port *left, struct usb_port *right)
+static int link_peers(struct usb_port *left, struct usb_port *right)
 {
+	int rc;
+
 	if (left->peer == right && right->peer == left)
-		return;
+		return 0;
 
 	if (left->peer || right->peer) {
 		struct usb_port *lpeer = left->peer;
@@ -170,11 +172,36 @@ static void link_peers(struct usb_port *left, struct usb_port *right)
 			dev_name(&left->dev), dev_name(&right->dev),
 			dev_name(&left->dev), lpeer,
 			dev_name(&right->dev), rpeer);
-		return;
+		return -EBUSY;
+	}
+
+	rc = sysfs_create_link(&left->dev.kobj, &right->dev.kobj, "peer");
+	if (rc)
+		return rc;
+	rc = sysfs_create_link(&right->dev.kobj, &left->dev.kobj, "peer");
+	if (rc) {
+		sysfs_remove_link(&left->dev.kobj, "peer");
+		return rc;
 	}
 
 	left->peer = right;
 	right->peer = left;
+
+	return 0;
+}
+
+static void link_peers_report(struct usb_port *left, struct usb_port *right)
+{
+	int rc;
+
+	rc = link_peers(left, right);
+	if (rc == 0) {
+		dev_dbg(&left->dev, "peered to %s\n", dev_name(&right->dev));
+	} else {
+		dev_warn(&left->dev, "failed to peer to %s (%d)\n",
+				dev_name(&right->dev), rc);
+		pr_warn_once("usb: port power management may be unreliable\n");
+	}
 }
 
 static void unlink_peers(struct usb_port *left, struct usb_port *right)
@@ -183,7 +210,9 @@ static void unlink_peers(struct usb_port *left, struct usb_port *right)
 			"%s and %s are not peers?\n",
 			dev_name(&left->dev), dev_name(&right->dev));
 
+	sysfs_remove_link(&left->dev.kobj, "peer");
 	right->peer = NULL;
+	sysfs_remove_link(&right->dev.kobj, "peer");
 	left->peer = NULL;
 }
 
@@ -212,7 +241,7 @@ static int match_location(struct usb_device *peer_hdev, void *p)
 	for (port1 = 1; port1 <= peer_hdev->maxchild; port1++) {
 		peer = peer_hub->ports[port1 - 1];
 		if (peer && peer->location == port_dev->location) {
-			link_peers(port_dev, peer);
+			link_peers_report(port_dev, peer);
 			return 1; /* done */
 		}
 	}
@@ -275,7 +304,7 @@ static void find_and_link_peer(struct usb_hub *hub, int port1)
 	 */
 	peer = peer_hub->ports[port1 - 1];
 	if (peer && peer->location == 0)
-		link_peers(port_dev, peer);
+		link_peers_report(port_dev, peer);
 }
 
 int usb_hub_create_port_device(struct usb_hub *hub, int port1)

commit 3bfd659baec822f54e4acb0734669e671d853a35
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue May 20 18:08:40 2014 -0700

    usb: find internal hub tier mismatch via acpi
    
    ACPI identifies peer ports by setting their 'group_token' and
    'group_position' _PLD data to the same value.  If a platform has tier
    mismatch [1] , ACPI can override the default (USB3 defined) peer port
    association for internal hubs.  External hubs follow the default peer
    association scheme.
    
    Location data is cached as an opaque cookie in usb_port_location data.
    
    Note that we only consider the group_token and group_position attributes
    from the _PLD data as ACPI specifies that group_token is a unique
    identifier.
    
    When we find port location data for a port then we assume that the
    firmware will also describe its peer port.  This allows the
    implementation to only ever set the peer once.  This leads to a question
    about what happens when a pm runtime event occurs while the peer
    associations are still resolving.  Since we only ever set the peer
    information once, a USB3 port needs to be prevented from suspending
    while its ->peer pointer is NULL (implemented in a subsequent patch).
    
    There is always the possibility that firmware mis-identifies the ports,
    but there is not much the kernel can do in that case.
    
    [1]: xhci 1.1 appendix D figure 131
    [2]: acpi 5 section 6.1.8
    
    [alan]: don't do default peering when acpi data present
    Suggested-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/port.c b/drivers/usb/core/port.c
index 9b7496b52f2a..aea54e8dfe47 100644
--- a/drivers/usb/core/port.c
+++ b/drivers/usb/core/port.c
@@ -188,8 +188,42 @@ static void unlink_peers(struct usb_port *left, struct usb_port *right)
 }
 
 /*
- * Set the default peer port for root hubs, or via the upstream peer
- * relationship for all other hubs
+ * For each usb hub device in the system check to see if it is in the
+ * peer domain of the given port_dev, and if it is check to see if it
+ * has a port that matches the given port by location
+ */
+static int match_location(struct usb_device *peer_hdev, void *p)
+{
+	int port1;
+	struct usb_hcd *hcd, *peer_hcd;
+	struct usb_port *port_dev = p, *peer;
+	struct usb_hub *peer_hub = usb_hub_to_struct_hub(peer_hdev);
+	struct usb_device *hdev = to_usb_device(port_dev->dev.parent->parent);
+
+	if (!peer_hub)
+		return 0;
+
+	hcd = bus_to_hcd(hdev->bus);
+	peer_hcd = bus_to_hcd(peer_hdev->bus);
+	/* peer_hcd is provisional until we verify it against the known peer */
+	if (peer_hcd != hcd->shared_hcd)
+		return 0;
+
+	for (port1 = 1; port1 <= peer_hdev->maxchild; port1++) {
+		peer = peer_hub->ports[port1 - 1];
+		if (peer && peer->location == port_dev->location) {
+			link_peers(port_dev, peer);
+			return 1; /* done */
+		}
+	}
+
+	return 0;
+}
+
+/*
+ * Find the peer port either via explicit platform firmware "location"
+ * data, the peer hcd for root hubs, or the upstream peer relationship
+ * for all other hubs.
  */
 static void find_and_link_peer(struct usb_hub *hub, int port1)
 {
@@ -198,7 +232,17 @@ static void find_and_link_peer(struct usb_hub *hub, int port1)
 	struct usb_device *peer_hdev;
 	struct usb_hub *peer_hub;
 
-	if (!hdev->parent) {
+	/*
+	 * If location data is available then we can only peer this port
+	 * by a location match, not the default peer (lest we create a
+	 * situation where we need to go back and undo a default peering
+	 * when the port is later peered by location data)
+	 */
+	if (port_dev->location) {
+		/* we link the peer in match_location() if found */
+		usb_for_each_dev(port_dev, match_location);
+		return;
+	} else if (!hdev->parent) {
 		struct usb_hcd *hcd = bus_to_hcd(hdev->bus);
 		struct usb_hcd *peer_hcd = hcd->shared_hcd;
 
@@ -225,8 +269,12 @@ static void find_and_link_peer(struct usb_hub *hub, int port1)
 	if (!peer_hub || port1 > peer_hdev->maxchild)
 		return;
 
+	/*
+	 * we found a valid default peer, last check is to make sure it
+	 * does not have location data
+	 */
 	peer = peer_hub->ports[port1 - 1];
-	if (peer)
+	if (peer && peer->location == 0)
 		link_peers(port_dev, peer);
 }
 

commit 8b1ba80c59fb3e77f9e1761480617d5ea9ee159c
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue May 20 18:08:33 2014 -0700

    usb: assign usb3 external hub port peers
    
    Given that root hub port peers are already established, external hub peer
    ports can be determined by traversing the device topology:
    
    1/ ascend to the parent hub and find the upstream port_dev
    
    2/ walk ->peer to find the peer port
    
    3/ descend to the peer hub via ->child
    
    4/ find the port with the matching port id
    
    Note that this assumes the port labeling scheme required by the
    specification [1].
    
    [1]: usb3 3.1 section 10.3.3
    
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/port.c b/drivers/usb/core/port.c
index 5ecdbf31dfcb..9b7496b52f2a 100644
--- a/drivers/usb/core/port.c
+++ b/drivers/usb/core/port.c
@@ -187,15 +187,18 @@ static void unlink_peers(struct usb_port *left, struct usb_port *right)
 	left->peer = NULL;
 }
 
-/* set the default peer port for root hubs */
+/*
+ * Set the default peer port for root hubs, or via the upstream peer
+ * relationship for all other hubs
+ */
 static void find_and_link_peer(struct usb_hub *hub, int port1)
 {
 	struct usb_port *port_dev = hub->ports[port1 - 1], *peer;
 	struct usb_device *hdev = hub->hdev;
+	struct usb_device *peer_hdev;
+	struct usb_hub *peer_hub;
 
 	if (!hdev->parent) {
-		struct usb_hub *peer_hub;
-		struct usb_device *peer_hdev;
 		struct usb_hcd *hcd = bus_to_hcd(hdev->bus);
 		struct usb_hcd *peer_hcd = hcd->shared_hcd;
 
@@ -203,15 +206,28 @@ static void find_and_link_peer(struct usb_hub *hub, int port1)
 			return;
 
 		peer_hdev = peer_hcd->self.root_hub;
-		peer_hub = usb_hub_to_struct_hub(peer_hdev);
-		if (!peer_hub || port1 > peer_hdev->maxchild)
+	} else {
+		struct usb_port *upstream;
+		struct usb_device *parent = hdev->parent;
+		struct usb_hub *parent_hub = usb_hub_to_struct_hub(parent);
+
+		if (!parent_hub)
 			return;
 
-		peer = peer_hub->ports[port1 - 1];
+		upstream = parent_hub->ports[hdev->portnum - 1];
+		if (!upstream || !upstream->peer)
+			return;
 
-		if (peer)
-			link_peers(port_dev, peer);
+		peer_hdev = upstream->peer->child;
 	}
+
+	peer_hub = usb_hub_to_struct_hub(peer_hdev);
+	if (!peer_hub || port1 > peer_hdev->maxchild)
+		return;
+
+	peer = peer_hub->ports[port1 - 1];
+	if (peer)
+		link_peers(port_dev, peer);
 }
 
 int usb_hub_create_port_device(struct usb_hub *hub, int port1)

commit d8521afe35862f4fbe3ccd6ca37897c0a304edf3
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue May 20 18:08:28 2014 -0700

    usb: assign default peer ports for root hubs
    
    Assume that the peer of a superspeed port is the port with the same id
    on the shared_hcd root hub.  This identification scheme is required of
    external hubs by the USB3 spec [1].  However, for root hubs, tier mismatch
    may be in effect [2].  Tier mismatch can only be enumerated via platform
    firmware.  For now, simply perform the nominal association.
    
    A new lock 'usb_port_peer_mutex' is introduced to synchronize port
    device add/remove with peer lookups.  It protects peering against
    changes to hcd->shared_hcd, hcd->self.root_hub, hdev->maxchild, and
    port_dev->child pointers.
    
    [1]: usb 3.1 section 10.3.3
    [2]: xhci 1.1 appendix D
    
    Cc: Alan Stern <stern@rowland.harvard.edu>
    [alan: usb_port_peer_mutex locking scheme]
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/port.c b/drivers/usb/core/port.c
index 6a8999728cbf..5ecdbf31dfcb 100644
--- a/drivers/usb/core/port.c
+++ b/drivers/usb/core/port.c
@@ -157,9 +157,66 @@ static struct device_driver usb_port_driver = {
 	.owner = THIS_MODULE,
 };
 
+static void link_peers(struct usb_port *left, struct usb_port *right)
+{
+	if (left->peer == right && right->peer == left)
+		return;
+
+	if (left->peer || right->peer) {
+		struct usb_port *lpeer = left->peer;
+		struct usb_port *rpeer = right->peer;
+
+		WARN(1, "failed to peer %s and %s (%s -> %p) (%s -> %p)\n",
+			dev_name(&left->dev), dev_name(&right->dev),
+			dev_name(&left->dev), lpeer,
+			dev_name(&right->dev), rpeer);
+		return;
+	}
+
+	left->peer = right;
+	right->peer = left;
+}
+
+static void unlink_peers(struct usb_port *left, struct usb_port *right)
+{
+	WARN(right->peer != left || left->peer != right,
+			"%s and %s are not peers?\n",
+			dev_name(&left->dev), dev_name(&right->dev));
+
+	right->peer = NULL;
+	left->peer = NULL;
+}
+
+/* set the default peer port for root hubs */
+static void find_and_link_peer(struct usb_hub *hub, int port1)
+{
+	struct usb_port *port_dev = hub->ports[port1 - 1], *peer;
+	struct usb_device *hdev = hub->hdev;
+
+	if (!hdev->parent) {
+		struct usb_hub *peer_hub;
+		struct usb_device *peer_hdev;
+		struct usb_hcd *hcd = bus_to_hcd(hdev->bus);
+		struct usb_hcd *peer_hcd = hcd->shared_hcd;
+
+		if (!peer_hcd)
+			return;
+
+		peer_hdev = peer_hcd->self.root_hub;
+		peer_hub = usb_hub_to_struct_hub(peer_hdev);
+		if (!peer_hub || port1 > peer_hdev->maxchild)
+			return;
+
+		peer = peer_hub->ports[port1 - 1];
+
+		if (peer)
+			link_peers(port_dev, peer);
+	}
+}
+
 int usb_hub_create_port_device(struct usb_hub *hub, int port1)
 {
-	struct usb_port *port_dev = NULL;
+	struct usb_port *port_dev;
 	int retval;
 
 	port_dev = kzalloc(sizeof(*port_dev), GFP_KERNEL);
@@ -181,6 +238,8 @@ int usb_hub_create_port_device(struct usb_hub *hub, int port1)
 	if (retval)
 		goto error_register;
 
+	find_and_link_peer(hub, port1);
+
 	pm_runtime_set_active(&port_dev->dev);
 
 	/*
@@ -203,9 +262,13 @@ int usb_hub_create_port_device(struct usb_hub *hub, int port1)
 	return retval;
 }
 
-void usb_hub_remove_port_device(struct usb_hub *hub,
-				       int port1)
+void usb_hub_remove_port_device(struct usb_hub *hub, int port1)
 {
-	device_unregister(&hub->ports[port1 - 1]->dev);
-}
+	struct usb_port *port_dev = hub->ports[port1 - 1];
+	struct usb_port *peer;
 
+	peer = port_dev->peer;
+	if (peer)
+		unlink_peers(port_dev, peer);
+	device_unregister(&port_dev->dev);
+}

commit d99f6b41308779244662109a9c2bad09a82e8ac6
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue May 20 18:08:17 2014 -0700

    usb: rename usb_port device objects
    
    The current port name "portX" is ambiguous.  Before adding more port
    messages rename ports to "<hub-device-name>-portX"
    
    This is an ABI change, but the suspicion is that it will go unnoticed as
    the port power control implementation has been broken since its
    introduction.  If however, someone was relying on the old name we can
    add sysfs links from the old name to the new name.
    
    Additionally, it unifies/simplifies port dev_printk messages and modifies
    instances of:
            dev_XXX(hub->intfdev, ..."port %d"...
            dev_XXX(&hdev->dev, ..."port%d"...
    into:
            dev_XXX(&port_dev->dev, ...
    
    Now that the names are unique usb_port devices it would be nice if they
    could be included in /sys/bus/usb.  However, it turns out that this
    breaks 'lsusb -t'.  For now, create a dummy port driver so that print
    messages are prefixed "usb 1-1-port3" rather than the
    subsystem-ambiguous " 1-1-port3".
    
    Finally, it corrects an odd usage of sscanf("port%d") in usb-acpi.c.
    
    Suggested-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/port.c b/drivers/usb/core/port.c
index 168fa6ee3348..6a8999728cbf 100644
--- a/drivers/usb/core/port.c
+++ b/drivers/usb/core/port.c
@@ -152,6 +152,11 @@ struct device_type usb_port_device_type = {
 	.pm =		&usb_port_pm_ops,
 };
 
+static struct device_driver usb_port_driver = {
+	.name = "usb",
+	.owner = THIS_MODULE,
+};
+
 int usb_hub_create_port_device(struct usb_hub *hub, int port1)
 {
 	struct usb_port *port_dev = NULL;
@@ -169,8 +174,9 @@ int usb_hub_create_port_device(struct usb_hub *hub, int port1)
 	port_dev->dev.parent = hub->intfdev;
 	port_dev->dev.groups = port_dev_group;
 	port_dev->dev.type = &usb_port_device_type;
-	dev_set_name(&port_dev->dev, "port%d", port1);
-
+	port_dev->dev.driver = &usb_port_driver;
+	dev_set_name(&port_dev->dev, "%s-port%d", dev_name(&hub->hdev->dev),
+			port1);
 	retval = device_register(&port_dev->dev);
 	if (retval)
 		goto error_register;

commit 9262c19d14c433a6a1ba25c3ff897cb89e412309
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue May 20 18:08:12 2014 -0700

    usb: disable port power control if not supported in wHubCharacteristics
    
    A hub indicates whether it supports per-port power control via the
    wHubCharacteristics field in its descriptor.  If it is not supported
    a hub will still emulate ClearPortPower(PORT_POWER) requests by
    stopping the link state machine.  However, since this does not save
    power do not bother suspending.
    
    This also consolidates support checks into a
    hub_is_port_power_switchable() helper.
    
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/port.c b/drivers/usb/core/port.c
index 37647e080599..168fa6ee3348 100644
--- a/drivers/usb/core/port.c
+++ b/drivers/usb/core/port.c
@@ -177,12 +177,15 @@ int usb_hub_create_port_device(struct usb_hub *hub, int port1)
 
 	pm_runtime_set_active(&port_dev->dev);
 
-	/* It would be dangerous if user space couldn't
-	 * prevent usb device from being powered off. So don't
-	 * enable port runtime pm if failed to expose port's pm qos.
+	/*
+	 * Do not enable port runtime pm if the hub does not support
+	 * power switching.  Also, userspace must have final say of
+	 * whether a port is permitted to power-off.  Do not enable
+	 * runtime pm if we fail to expose pm_qos_no_power_off.
 	 */
-	if (!dev_pm_qos_expose_flags(&port_dev->dev,
-			PM_QOS_FLAG_NO_POWER_OFF))
+	if (hub_is_port_power_switchable(hub)
+			&& dev_pm_qos_expose_flags(&port_dev->dev,
+			PM_QOS_FLAG_NO_POWER_OFF) == 0)
 		pm_runtime_enable(&port_dev->dev);
 
 	device_enable_async_suspend(&port_dev->dev);

commit 600856c231ccb0cbf8afcf09066a8ab2a93ab03d
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue May 20 18:08:07 2014 -0700

    USB: mutual exclusion for resetting a hub and power-managing a port
    
    The USB core doesn't properly handle mutual exclusion between
    resetting a hub and changing the power states of the hub's ports.  We
    need to avoid sending port-power requests to the hub while it is being
    reset, because such requests cannot succeed.
    
    This patch fixes the problem by keeping track of when a reset is in
    progress.  At such times, attempts to suspend (power-off) a port will
    fail immediately with -EBUSY, and calls to usb_port_runtime_resume()
    will update the power_is_on flag and return immediately.  When the
    reset is complete, hub_activate() will automatically restore each port
    to the proper power state.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/port.c b/drivers/usb/core/port.c
index 51542f852393..37647e080599 100644
--- a/drivers/usb/core/port.c
+++ b/drivers/usb/core/port.c
@@ -81,6 +81,10 @@ static int usb_port_runtime_resume(struct device *dev)
 
 	if (!hub)
 		return -EINVAL;
+	if (hub->in_reset) {
+		port_dev->power_is_on = 1;
+		return 0;
+	}
 
 	usb_autopm_get_interface(intf);
 	set_bit(port1, hub->busy_bits);
@@ -117,6 +121,8 @@ static int usb_port_runtime_suspend(struct device *dev)
 
 	if (!hub)
 		return -EINVAL;
+	if (hub->in_reset)
+		return -EBUSY;
 
 	if (dev_pm_qos_flags(&port_dev->dev, PM_QOS_FLAG_NO_POWER_OFF)
 			== PM_QOS_FLAGS_ALL)

commit d03f254f2ee2a708af9a7347402d9aed7f6cc4c1
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Aug 23 16:05:26 2013 -0700

    USB: core: be specific about attribute permissions
    
    Instead of having to audit all sysfs attributes, to ensure we get them
    right, use the default macros the driver core provides us (read-only,
    read-write) to make the code simpler, and to prevent any mistakes from
    ever happening.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/port.c b/drivers/usb/core/port.c
index 9909911665ce..51542f852393 100644
--- a/drivers/usb/core/port.c
+++ b/drivers/usb/core/port.c
@@ -23,8 +23,8 @@
 
 static const struct attribute_group *port_dev_group[];
 
-static ssize_t show_port_connect_type(struct device *dev,
-	struct device_attribute *attr, char *buf)
+static ssize_t connect_type_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
 {
 	struct usb_port *port_dev = to_usb_port(dev);
 	char *result;
@@ -46,8 +46,7 @@ static ssize_t show_port_connect_type(struct device *dev,
 
 	return sprintf(buf, "%s\n", result);
 }
-static DEVICE_ATTR(connect_type, S_IRUGO, show_port_connect_type,
-		NULL);
+static DEVICE_ATTR_RO(connect_type);
 
 static struct attribute *port_dev_attrs[] = {
 	&dev_attr_connect_type.attr,

commit d49dad3e11638f66be4e16573ffaa8c46a09e3b3
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Mon Aug 5 18:58:15 2013 -0700

    usb: Don't fail port power resume on device disconnect.
    
    Userspace can tell the kernel to power off any USB port, including ones
    that are visible and connectible to users.  When an attached USB device
    goes into suspend, the port will be powered off if the
    pm_qos_no_port_poweroff file for its port is set to 0, the device does
    not have remote wakeup enabled, and the device is marked as persistent.
    
    If the user disconnects the USB device while the port is powered off,
    the current code does not handle that properly.  If you disconnect a
    device, and then run `lsusb -v -s` for the device, the device disconnect
    does not get handled by the USB core.  The runtime resume of the port
    fails, because hub_port_debounce_be_connected() returns -ETIMEDOUT.
    
    This means the port resume fails and khubd doesn't handle the USB device
    disconnect.  This leaves the device listed in lsusb, and the port's
    runtime_status will be permanently marked as "error".
    
    Fix this by ignoring the return value of hub_port_debounce_be_connected.
    Users can disconnect USB devices while the ports are powered off, and we
    must be able to handle that.
    
    This patch should be backported to kernels as old as 3.9, that
    contain the commit ad493e5e580546e6c3024b76a41535476da1546a "usb: add
    usb port auto power off mechanism"
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Cc: Lan Tianyu <tianyu.lan@intel.com>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>

diff --git a/drivers/usb/core/port.c b/drivers/usb/core/port.c
index d6b0fadf53e9..9909911665ce 100644
--- a/drivers/usb/core/port.c
+++ b/drivers/usb/core/port.c
@@ -89,22 +89,19 @@ static int usb_port_runtime_resume(struct device *dev)
 	retval = usb_hub_set_port_power(hdev, hub, port1, true);
 	if (port_dev->child && !retval) {
 		/*
-		 * Wait for usb hub port to be reconnected in order to make
-		 * the resume procedure successful.
+		 * Attempt to wait for usb hub port to be reconnected in order
+		 * to make the resume procedure successful.  The device may have
+		 * disconnected while the port was powered off, so ignore the
+		 * return status.
 		 */
 		retval = hub_port_debounce_be_connected(hub, port1);
-		if (retval < 0) {
+		if (retval < 0)
 			dev_dbg(&port_dev->dev, "can't get reconnection after setting port  power on, status %d\n",
 					retval);
-			goto out;
-		}
 		usb_clear_port_feature(hdev, port1, USB_PORT_FEAT_C_ENABLE);
-
-		/* Set return value to 0 if debounce successful */
 		retval = 0;
 	}
 
-out:
 	clear_bit(port1, hub->busy_bits);
 	usb_autopm_put_interface(intf);
 	return retval;

commit f991fae5c6d42dfc5029150b05a78cf3f6c18cc9
Merge: d4141531f63a 2c843bd92ec2
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jul 3 14:35:40 2013 -0700

    Merge tag 'pm+acpi-3.11-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull power management and ACPI updates from Rafael Wysocki:
     "This time the total number of ACPI commits is slightly greater than
      the number of cpufreq commits, but Viresh Kumar (who works on cpufreq)
      remains the most active patch submitter.
    
      To me, the most significant change is the addition of offline/online
      device operations to the driver core (with the Greg's blessing) and
      the related modifications of the ACPI core hotplug code.  Next are the
      freezer updates from Colin Cross that should make the freezing of
      tasks a bit less heavy weight.
    
      We also have a couple of regression fixes, a number of fixes for
      issues that have not been identified as regressions, two new drivers
      and a bunch of cleanups all over.
    
      Highlights:
    
       - Hotplug changes to support graceful hot-removal failures.
    
         It sometimes is necessary to fail device hot-removal operations
         gracefully if they cannot be carried out completely.  For example,
         if memory from a memory module being hot-removed has been allocated
         for the kernel's own use and cannot be moved elsewhere, it's
         desirable to fail the hot-removal operation in a graceful way
         rather than to crash the kernel, but currenty a success or a kernel
         crash are the only possible outcomes of an attempted memory
         hot-removal.  Needless to say, that is not a very attractive
         alternative and it had to be addressed.
    
         However, in order to make it work for memory, I first had to make
         it work for CPUs and for this purpose I needed to modify the ACPI
         processor driver.  It's been split into two parts, a resident one
         handling the low-level initialization/cleanup and a modular one
         playing the actual driver's role (but it binds to the CPU system
         device objects rather than to the ACPI device objects representing
         processors).  That's been sort of like a live brain surgery on a
         patient who's riding a bike.
    
         So this is a little scary, but since we found and fixed a couple of
         regressions it caused to happen during the early linux-next testing
         (a month ago), nobody has complained.
    
         As a bonus we remove some duplicated ACPI hotplug code, because the
         ACPI-based CPU hotplug is now going to use the common ACPI hotplug
         code.
    
       - Lighter weight freezing of tasks.
    
         These changes from Colin Cross and Mandeep Singh Baines are
         targeted at making the freezing of tasks a bit less heavy weight
         operation.  They reduce the number of tasks woken up every time
         during the freezing, by using the observation that the freezer
         simply doesn't need to wake up some of them and wait for them all
         to call refrigerator().  The time needed for the freezer to decide
         to report a failure is reduced too.
    
         Also reintroduced is the check causing a lockdep warining to
         trigger when try_to_freeze() is called with locks held (which is
         generally unsafe and shouldn't happen).
    
       - cpufreq updates
    
         First off, a commit from Srivatsa S Bhat fixes a resume regression
         introduced during the 3.10 cycle causing some cpufreq sysfs
         attributes to return wrong values to user space after resume.  The
         fix is kind of fresh, but also it's pretty obvious once Srivatsa
         has identified the root cause.
    
         Second, we have a new freqdomain_cpus sysfs attribute for the
         acpi-cpufreq driver to provide information previously available via
         related_cpus.  From Lan Tianyu.
    
         Finally, we fix a number of issues, mostly related to the
         CPUFREQ_POSTCHANGE notifier and cpufreq Kconfig options and clean
         up some code.  The majority of changes from Viresh Kumar with bits
         from Jacob Shin, Heiko Stübner, Xiaoguang Chen, Ezequiel Garcia,
         Arnd Bergmann, and Tang Yuantian.
    
       - ACPICA update
    
         A usual bunch of updates from the ACPICA upstream.
    
         During the 3.4 cycle we introduced support for ACPI 5 extended
         sleep registers, but they are only supposed to be used if the
         HW-reduced mode bit is set in the FADT flags and the code attempted
         to use them without checking that bit.  That caused suspend/resume
         regressions to happen on some systems.  Fix from Lv Zheng causes
         those registers to be used only if the HW-reduced mode bit is set.
    
         Apart from this some other ACPICA bugs are fixed and code cleanups
         are made by Bob Moore, Tomasz Nowicki, Lv Zheng, Chao Guan, and
         Zhang Rui.
    
       - cpuidle updates
    
         New driver for Xilinx Zynq processors is added by Michal Simek.
    
         Multidriver support simplification, addition of some missing
         kerneldoc comments and Kconfig-related fixes come from Daniel
         Lezcano.
    
       - ACPI power management updates
    
         Changes to make suspend/resume work correctly in Xen guests from
         Konrad Rzeszutek Wilk, sparse warning fix from Fengguang Wu and
         cleanups and fixes of the ACPI device power state selection
         routine.
    
       - ACPI documentation updates
    
         Some previously missing pieces of ACPI documentation are added by
         Lv Zheng and Aaron Lu (hopefully, that will help people to
         uderstand how the ACPI subsystem works) and one outdated doc is
         updated by Hanjun Guo.
    
       - Assorted ACPI updates
    
         We finally nailed down the IA-64 issue that was the reason for
         reverting commit 9f29ab11ddbf ("ACPI / scan: do not match drivers
         against objects having scan handlers"), so we can fix it and move
         the ACPI scan handler check added to the ACPI video driver back to
         the core.
    
         A mechanism for adding CMOS RTC address space handlers is
         introduced by Lan Tianyu to allow some EC-related breakage to be
         fixed on some systems.
    
         A spec-compliant implementation of acpi_os_get_timer() is added by
         Mika Westerberg.
    
         The evaluation of _STA is added to do_acpi_find_child() to avoid
         situations in which a pointer to a disabled device object is
         returned instead of an enabled one with the same _ADR value.  From
         Jeff Wu.
    
         Intel BayTrail PCH (Platform Controller Hub) support is added to
         the ACPI driver for Intel Low-Power Subsystems (LPSS) and that
         driver is modified to work around a couple of known BIOS issues.
         Changes from Mika Westerberg and Heikki Krogerus.
    
         The EC driver is fixed by Vasiliy Kulikov to use get_user() and
         put_user() instead of dereferencing user space pointers blindly.
    
         Code cleanups are made by Bjorn Helgaas, Nicholas Mazzuca and Toshi
         Kani.
    
       - Assorted power management updates
    
         The "runtime idle" helper routine is changed to take the return
         values of the callbacks executed by it into account and to call
         rpm_suspend() if they return 0, which allows us to reduce the
         overall code bloat a bit (by dropping some code that's not
         necessary any more after that modification).
    
         The runtime PM documentation is updated by Alan Stern (to reflect
         the "runtime idle" behavior change).
    
         New trace points for PM QoS are added by Sahara
         (<keun-o.park@windriver.com>).
    
         PM QoS documentation is updated by Lan Tianyu.
    
         Code cleanups are made and minor issues are addressed by Bernie
         Thompson, Bjorn Helgaas, Julius Werner, and Shuah Khan.
    
       - devfreq updates
    
         New driver for the Exynos5-bus device from Abhilash Kesavan.
    
         Minor cleanups, fixes and MAINTAINERS update from MyungJoo Ham,
         Abhilash Kesavan, Paul Bolle, Rajagopal Venkat, and Wei Yongjun.
    
       - OMAP power management updates
    
         Adaptive Voltage Scaling (AVS) SmartReflex voltage control driver
         updates from Andrii Tseglytskyi and Nishanth Menon."
    
    * tag 'pm+acpi-3.11-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (162 commits)
      cpufreq: Fix cpufreq regression after suspend/resume
      ACPI / PM: Fix possible NULL pointer deref in acpi_pm_device_sleep_state()
      PM / Sleep: Warn about system time after resume with pm_trace
      cpufreq: don't leave stale policy pointer in cdbs->cur_policy
      acpi-cpufreq: Add new sysfs attribute freqdomain_cpus
      cpufreq: make sure frequency transitions are serialized
      ACPI: implement acpi_os_get_timer() according the spec
      ACPI / EC: Add HP Folio 13 to ec_dmi_table in order to skip DSDT scan
      ACPI: Add CMOS RTC Operation Region handler support
      ACPI / processor: Drop unused variable from processor_perflib.c
      cpufreq: tegra: call CPUFREQ_POSTCHANGE notfier in error cases
      cpufreq: s3c64xx: call CPUFREQ_POSTCHANGE notfier in error cases
      cpufreq: omap: call CPUFREQ_POSTCHANGE notfier in error cases
      cpufreq: imx6q: call CPUFREQ_POSTCHANGE notfier in error cases
      cpufreq: exynos: call CPUFREQ_POSTCHANGE notfier in error cases
      cpufreq: dbx500: call CPUFREQ_POSTCHANGE notfier in error cases
      cpufreq: davinci: call CPUFREQ_POSTCHANGE notfier in error cases
      cpufreq: arm-big-little: call CPUFREQ_POSTCHANGE notfier in error cases
      cpufreq: powernow-k8: call CPUFREQ_POSTCHANGE notfier in error cases
      cpufreq: pcc: call CPUFREQ_POSTCHANGE notfier in error cases
      ...

commit 41341261aa1707b49f937ba2c20d1a0daa5afac3
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Tue Jun 18 17:28:48 2013 +0300

    usb: check usb_hub_to_struct_hub() return value
    
    usb_hub_to_struct_hub() can return NULL in some unlikely cases.
    Add checks where appropriate, or pass the hub pointer as an additional
    argument if it's known to be valid.
    
    The places it makes sense to check usb_hub_to_struct_hub()
    are picked based on feedback from Alan Stern.
    
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/port.c b/drivers/usb/core/port.c
index b8bad294eeb8..5fd3fee58f8b 100644
--- a/drivers/usb/core/port.c
+++ b/drivers/usb/core/port.c
@@ -86,7 +86,7 @@ static int usb_port_runtime_resume(struct device *dev)
 	usb_autopm_get_interface(intf);
 	set_bit(port1, hub->busy_bits);
 
-	retval = usb_hub_set_port_power(hdev, port1, true);
+	retval = usb_hub_set_port_power(hdev, hub, port1, true);
 	if (port_dev->child && !retval) {
 		/*
 		 * Wait for usb hub port to be reconnected in order to make
@@ -128,7 +128,7 @@ static int usb_port_runtime_suspend(struct device *dev)
 
 	usb_autopm_get_interface(intf);
 	set_bit(port1, hub->busy_bits);
-	retval = usb_hub_set_port_power(hdev, port1, false);
+	retval = usb_hub_set_port_power(hdev, hub, port1, false);
 	usb_clear_port_feature(hdev, port1, USB_PORT_FEAT_C_CONNECTION);
 	usb_clear_port_feature(hdev, port1,	USB_PORT_FEAT_C_ENABLE);
 	clear_bit(port1, hub->busy_bits);

commit 45f0a85c8258741d11bda25c0a5669c06267204a
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Jun 3 21:49:52 2013 +0200

    PM / Runtime: Rework the "runtime idle" helper routine
    
    The "runtime idle" helper routine, rpm_idle(), currently ignores
    return values from .runtime_idle() callbacks executed by it.
    However, it turns out that many subsystems use
    pm_generic_runtime_idle() which checks the return value of the
    driver's callback and executes pm_runtime_suspend() for the device
    unless that value is not 0.  If that logic is moved to rpm_idle()
    instead, pm_generic_runtime_idle() can be dropped and its users
    will not need any .runtime_idle() callbacks any more.
    
    Moreover, the PCI, SCSI, and SATA subsystems' .runtime_idle()
    routines, pci_pm_runtime_idle(), scsi_runtime_idle(), and
    ata_port_runtime_idle(), respectively, as well as a few drivers'
    ones may be simplified if rpm_idle() calls rpm_suspend() after 0 has
    been returned by the .runtime_idle() callback executed by it.
    
    To reduce overall code bloat, make the changes described above.
    
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Tested-by: Kevin Hilman <khilman@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Kevin Hilman <khilman@linaro.org>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>

diff --git a/drivers/usb/core/port.c b/drivers/usb/core/port.c
index b8bad294eeb8..8c1b2c509467 100644
--- a/drivers/usb/core/port.c
+++ b/drivers/usb/core/port.c
@@ -141,7 +141,6 @@ static const struct dev_pm_ops usb_port_pm_ops = {
 #ifdef CONFIG_PM_RUNTIME
 	.runtime_suspend =	usb_port_runtime_suspend,
 	.runtime_resume =	usb_port_runtime_resume,
-	.runtime_idle =		pm_generic_runtime_idle,
 #endif
 };
 

commit 31e918908ccaf2b651ed8f666120f2a03a97193f
Merge: ae3759c25730 31880c37c11e
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Apr 8 08:36:40 2013 -0700

    Merge 3.9-rc6 into usb-next
    
    We want the fixes here as well.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit da259465d7526804b21d274281fb4d60b4216c82
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Apr 2 01:25:09 2013 +0200

    USB / PM: Don't try to hide PM QoS flags from usb_port_device_release()
    
    Remove the call to dev_pm_qos_hide_flags(), added by commit 6e30d7cb
    "usb: Add driver/usb/core/(port.c,hub.h) files", from
    usb_port_device_release(), because (1) it is completely unnecessary
    (the flags have been removed already by the PM core during the
    unregistration of the device object) and (2) it triggers a NULL
    pointer dereference in sysfs_find_dirent() (dev->kobj.sd is NULL at
    this point).
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/port.c b/drivers/usb/core/port.c
index 797f9d514732..65d4e55552c6 100644
--- a/drivers/usb/core/port.c
+++ b/drivers/usb/core/port.c
@@ -67,7 +67,6 @@ static void usb_port_device_release(struct device *dev)
 {
 	struct usb_port *port_dev = to_usb_port(dev);
 
-	dev_pm_qos_hide_flags(dev);
 	kfree(port_dev);
 }
 

commit 84ebc10294a3d7be4c66f51070b7aedbaa24de9b
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Mar 27 16:14:46 2013 -0400

    USB: remove CONFIG_USB_SUSPEND option
    
    This patch (as1675) removes the CONFIG_USB_SUSPEND option, essentially
    replacing it everywhere with CONFIG_PM_RUNTIME (except for one place
    in hub.c, where it is replaced with CONFIG_PM because the code needs
    to be used in both runtime and system PM).  The net result is code
    shrinkage and simplification.
    
    There's very little point in keeping CONFIG_USB_SUSPEND because almost
    everybody enables it.  The few that don't will find that the usbcore
    module has gotten somewhat bigger and they will have to take active
    measures if they want to prevent hubs from being runtime suspended.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    CC: Peter Chen <peter.chen@freescale.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/port.c b/drivers/usb/core/port.c
index 797f9d514732..06c4894bf181 100644
--- a/drivers/usb/core/port.c
+++ b/drivers/usb/core/port.c
@@ -71,7 +71,7 @@ static void usb_port_device_release(struct device *dev)
 	kfree(port_dev);
 }
 
-#ifdef CONFIG_USB_SUSPEND
+#ifdef CONFIG_PM_RUNTIME
 static int usb_port_runtime_resume(struct device *dev)
 {
 	struct usb_port *port_dev = to_usb_port(dev);
@@ -139,7 +139,7 @@ static int usb_port_runtime_suspend(struct device *dev)
 #endif
 
 static const struct dev_pm_ops usb_port_pm_ops = {
-#ifdef CONFIG_USB_SUSPEND
+#ifdef CONFIG_PM_RUNTIME
 	.runtime_suspend =	usb_port_runtime_suspend,
 	.runtime_resume =	usb_port_runtime_resume,
 	.runtime_idle =		pm_generic_runtime_idle,

commit 3b2ab2b84c68fb92accbc735927bc8221e4de973
Author: Lan Tianyu <tianyu.lan@intel.com>
Date:   Tue Jan 29 00:59:06 2013 +0800

    Revert "usb: Register usb port's acpi power resources"
    
    This reverts commit 88bb965ed711e8a5984e70208ebc901a6ff4141f.
    
    The linux-next branch of linux-pm tree has replaced
    acpi_power_resource_(un)register_device() with new routines.
    Commit 88bb965 will cause conflict in the linux-next tree.
    So revert it and this will not affect other functions. Will
    send a new patch with new routines after 3.9 merge window.
    
    Signed-off-by: Lan Tianyu <tianyu.lan@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/port.c b/drivers/usb/core/port.c
index 5df143dbd759..797f9d514732 100644
--- a/drivers/usb/core/port.c
+++ b/drivers/usb/core/port.c
@@ -68,7 +68,6 @@ static void usb_port_device_release(struct device *dev)
 	struct usb_port *port_dev = to_usb_port(dev);
 
 	dev_pm_qos_hide_flags(dev);
-	usb_acpi_unregister_power_resources(dev);
 	kfree(port_dev);
 }
 
@@ -187,11 +186,6 @@ int usb_hub_create_port_device(struct usb_hub *hub, int port1)
 		pm_runtime_enable(&port_dev->dev);
 
 	device_enable_async_suspend(&port_dev->dev);
-
-	retval = usb_acpi_register_power_resources(&port_dev->dev);
-	if (retval && retval != -ENODEV)
-		dev_warn(&port_dev->dev, "the port can't register its ACPI power resource.\n");
-
 	return 0;
 
 error_register:

commit 192fef18d0f5ac9a05a93ff6314fc9865c10fbf9
Author: Lan Tianyu <tianyu.lan@intel.com>
Date:   Wed Jan 23 04:26:32 2013 +0800

    usb: enable usb port device's async suspend.
    
    This patch is to set power.async_suspend for usb port in order
    to allow it to be suspended and resumed asynchronously during
    system sleep transitions.
    
    The power.async_suspend flag is also set for devices that don't have
    suspend or resume callbacks, because otherwise they would make the
    main suspend/resume thread wait for their "asynchronous" children
    (during suspend) or parents (during resume), effectively negating the
    possible gains from executing these devices' suspend and resume
    callbacks asynchronously.
    
    Signed-off-by: Lan Tianyu <tianyu.lan@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/port.c b/drivers/usb/core/port.c
index 9a15b26944ec..5df143dbd759 100644
--- a/drivers/usb/core/port.c
+++ b/drivers/usb/core/port.c
@@ -186,6 +186,7 @@ int usb_hub_create_port_device(struct usb_hub *hub, int port1)
 			PM_QOS_FLAG_NO_POWER_OFF))
 		pm_runtime_enable(&port_dev->dev);
 
+	device_enable_async_suspend(&port_dev->dev);
 
 	retval = usb_acpi_register_power_resources(&port_dev->dev);
 	if (retval && retval != -ENODEV)

commit f6cced1a08b475c5ac946823bb057714be7af4f6
Author: Lan Tianyu <tianyu.lan@intel.com>
Date:   Wed Jan 23 04:26:31 2013 +0800

    usb: expose usb port's pm qos flags to user space
    
    This patch is to expose usb port's pm qos flags(pm_qos_no_power_off,
    pm_qos_remote_wakeup) to user space. User can set pm_qos_no_power_off
    flag to prohibit the port from being powered off.
    
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Lan Tianyu <tianyu.lan@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/port.c b/drivers/usb/core/port.c
index 280433d80887..9a15b26944ec 100644
--- a/drivers/usb/core/port.c
+++ b/drivers/usb/core/port.c
@@ -67,6 +67,7 @@ static void usb_port_device_release(struct device *dev)
 {
 	struct usb_port *port_dev = to_usb_port(dev);
 
+	dev_pm_qos_hide_flags(dev);
 	usb_acpi_unregister_power_resources(dev);
 	kfree(port_dev);
 }
@@ -176,7 +177,15 @@ int usb_hub_create_port_device(struct usb_hub *hub, int port1)
 		goto error_register;
 
 	pm_runtime_set_active(&port_dev->dev);
-	pm_runtime_enable(&port_dev->dev);
+
+	/* It would be dangerous if user space couldn't
+	 * prevent usb device from being powered off. So don't
+	 * enable port runtime pm if failed to expose port's pm qos.
+	 */
+	if (!dev_pm_qos_expose_flags(&port_dev->dev,
+			PM_QOS_FLAG_NO_POWER_OFF))
+		pm_runtime_enable(&port_dev->dev);
+
 
 	retval = usb_acpi_register_power_resources(&port_dev->dev);
 	if (retval && retval != -ENODEV)

commit ad493e5e580546e6c3024b76a41535476da1546a
Author: Lan Tianyu <tianyu.lan@intel.com>
Date:   Wed Jan 23 04:26:30 2013 +0800

    usb: add usb port auto power off mechanism
    
    This patch is to add usb port auto power off mechanism.
    When usb device is suspending, usb core will suspend usb port and
    usb port runtime pm callback will clear PORT_POWER feature to
    power off port if all conditions were met. These conditions are
    remote wakeup disable, pm qos NO_POWER_OFF flag clear and persist
    enable. When it resumes, power on port again.
    
    Add did_runtime_put in the struct usb_port to ensure
    pm_runtime_get/put(portdev) to be called pairedly.  Set did_runtime_put
    to true when call pm_runtime_put(portdev) during suspending. The
    pm_runtime_get(portdev) only will be called when did_runtime_put
    is set to true during resuming. Set did_runtime_put to false after
    calling pm_runtime_get(portdev).
    
    Make clear_port_feature() and hdev_to_hub() as global symbol.
    Rename clear_port_feature() to usb_clear_port_feature() and
    hdev_to_hub() to usb_hub_to_struct_hub().
    
    Extend hub_port_debounce() with the fuction of debouncing to
    be connected. Add two wraps: hub_port_debounce_be_connected()
    and hub_port_debouce_be_stable().
    
    Increase HUB_DEBOUNCE_TIMEOUT to 2000 because some usb ssds
    needs around 1.5 or more to make the hub port status to be
    connected steadily after being powered off and powered on.
    
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Lan Tianyu <tianyu.lan@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/port.c b/drivers/usb/core/port.c
index d288dfed6ccf..280433d80887 100644
--- a/drivers/usb/core/port.c
+++ b/drivers/usb/core/port.c
@@ -77,10 +77,36 @@ static int usb_port_runtime_resume(struct device *dev)
 	struct usb_port *port_dev = to_usb_port(dev);
 	struct usb_device *hdev = to_usb_device(dev->parent->parent);
 	struct usb_interface *intf = to_usb_interface(dev->parent);
+	struct usb_hub *hub = usb_hub_to_struct_hub(hdev);
+	int port1 = port_dev->portnum;
 	int retval;
 
+	if (!hub)
+		return -EINVAL;
+
 	usb_autopm_get_interface(intf);
-	retval = usb_hub_set_port_power(hdev, port_dev->portnum, true);
+	set_bit(port1, hub->busy_bits);
+
+	retval = usb_hub_set_port_power(hdev, port1, true);
+	if (port_dev->child && !retval) {
+		/*
+		 * Wait for usb hub port to be reconnected in order to make
+		 * the resume procedure successful.
+		 */
+		retval = hub_port_debounce_be_connected(hub, port1);
+		if (retval < 0) {
+			dev_dbg(&port_dev->dev, "can't get reconnection after setting port  power on, status %d\n",
+					retval);
+			goto out;
+		}
+		usb_clear_port_feature(hdev, port1, USB_PORT_FEAT_C_ENABLE);
+
+		/* Set return value to 0 if debounce successful */
+		retval = 0;
+	}
+
+out:
+	clear_bit(port1, hub->busy_bits);
 	usb_autopm_put_interface(intf);
 	return retval;
 }
@@ -90,14 +116,23 @@ static int usb_port_runtime_suspend(struct device *dev)
 	struct usb_port *port_dev = to_usb_port(dev);
 	struct usb_device *hdev = to_usb_device(dev->parent->parent);
 	struct usb_interface *intf = to_usb_interface(dev->parent);
+	struct usb_hub *hub = usb_hub_to_struct_hub(hdev);
+	int port1 = port_dev->portnum;
 	int retval;
 
+	if (!hub)
+		return -EINVAL;
+
 	if (dev_pm_qos_flags(&port_dev->dev, PM_QOS_FLAG_NO_POWER_OFF)
 			== PM_QOS_FLAGS_ALL)
 		return -EAGAIN;
 
 	usb_autopm_get_interface(intf);
-	retval = usb_hub_set_port_power(hdev, port_dev->portnum, false);
+	set_bit(port1, hub->busy_bits);
+	retval = usb_hub_set_port_power(hdev, port1, false);
+	usb_clear_port_feature(hdev, port1, USB_PORT_FEAT_C_CONNECTION);
+	usb_clear_port_feature(hdev, port1,	USB_PORT_FEAT_C_ENABLE);
+	clear_bit(port1, hub->busy_bits);
 	usb_autopm_put_interface(intf);
 	return retval;
 }
@@ -130,6 +165,7 @@ int usb_hub_create_port_device(struct usb_hub *hub, int port1)
 
 	hub->ports[port1 - 1] = port_dev;
 	port_dev->portnum = port1;
+	port_dev->power_is_on = true;
 	port_dev->dev.parent = hub->intfdev;
 	port_dev->dev.groups = port_dev_group;
 	port_dev->dev.type = &usb_port_device_type;

commit 971fcd492cebf544714f12d94549d2f0d2002645
Author: Lan Tianyu <tianyu.lan@intel.com>
Date:   Wed Jan 23 04:26:29 2013 +0800

    usb: add runtime pm support for usb port device
    
    This patch is to add runtime pm callback for usb port device.
    Set/clear PORT_POWER feature in the resume/suspend callback.
    Add portnum for struct usb_port to record port number. Do
    pm_rumtime_get_sync/put(portdev) when a device is plugged/unplugged
    to prevent it from being powered off when it is active.
    
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Lan Tianyu <tianyu.lan@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/port.c b/drivers/usb/core/port.c
index 153e799e7320..d288dfed6ccf 100644
--- a/drivers/usb/core/port.c
+++ b/drivers/usb/core/port.c
@@ -17,6 +17,7 @@
  */
 
 #include <linux/slab.h>
+#include <linux/pm_qos.h>
 
 #include "hub.h"
 
@@ -70,9 +71,50 @@ static void usb_port_device_release(struct device *dev)
 	kfree(port_dev);
 }
 
+#ifdef CONFIG_USB_SUSPEND
+static int usb_port_runtime_resume(struct device *dev)
+{
+	struct usb_port *port_dev = to_usb_port(dev);
+	struct usb_device *hdev = to_usb_device(dev->parent->parent);
+	struct usb_interface *intf = to_usb_interface(dev->parent);
+	int retval;
+
+	usb_autopm_get_interface(intf);
+	retval = usb_hub_set_port_power(hdev, port_dev->portnum, true);
+	usb_autopm_put_interface(intf);
+	return retval;
+}
+
+static int usb_port_runtime_suspend(struct device *dev)
+{
+	struct usb_port *port_dev = to_usb_port(dev);
+	struct usb_device *hdev = to_usb_device(dev->parent->parent);
+	struct usb_interface *intf = to_usb_interface(dev->parent);
+	int retval;
+
+	if (dev_pm_qos_flags(&port_dev->dev, PM_QOS_FLAG_NO_POWER_OFF)
+			== PM_QOS_FLAGS_ALL)
+		return -EAGAIN;
+
+	usb_autopm_get_interface(intf);
+	retval = usb_hub_set_port_power(hdev, port_dev->portnum, false);
+	usb_autopm_put_interface(intf);
+	return retval;
+}
+#endif
+
+static const struct dev_pm_ops usb_port_pm_ops = {
+#ifdef CONFIG_USB_SUSPEND
+	.runtime_suspend =	usb_port_runtime_suspend,
+	.runtime_resume =	usb_port_runtime_resume,
+	.runtime_idle =		pm_generic_runtime_idle,
+#endif
+};
+
 struct device_type usb_port_device_type = {
 	.name =		"usb_port",
 	.release =	usb_port_device_release,
+	.pm =		&usb_port_pm_ops,
 };
 
 int usb_hub_create_port_device(struct usb_hub *hub, int port1)
@@ -87,6 +129,7 @@ int usb_hub_create_port_device(struct usb_hub *hub, int port1)
 	}
 
 	hub->ports[port1 - 1] = port_dev;
+	port_dev->portnum = port1;
 	port_dev->dev.parent = hub->intfdev;
 	port_dev->dev.groups = port_dev_group;
 	port_dev->dev.type = &usb_port_device_type;
@@ -96,6 +139,9 @@ int usb_hub_create_port_device(struct usb_hub *hub, int port1)
 	if (retval)
 		goto error_register;
 
+	pm_runtime_set_active(&port_dev->dev);
+	pm_runtime_enable(&port_dev->dev);
+
 	retval = usb_acpi_register_power_resources(&port_dev->dev);
 	if (retval && retval != -ENODEV)
 		dev_warn(&port_dev->dev, "the port can't register its ACPI power resource.\n");

commit 88bb965ed711e8a5984e70208ebc901a6ff4141f
Author: Lan Tianyu <tianyu.lan@intel.com>
Date:   Wed Jan 23 04:26:27 2013 +0800

    usb: Register usb port's acpi power resources
    
    This patch is to register usb port's acpi power resources. Create
    link between usb port device and its acpi power resource.
    
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Lan Tianyu <tianyu.lan@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/port.c b/drivers/usb/core/port.c
index fe5959fc021b..153e799e7320 100644
--- a/drivers/usb/core/port.c
+++ b/drivers/usb/core/port.c
@@ -66,6 +66,7 @@ static void usb_port_device_release(struct device *dev)
 {
 	struct usb_port *port_dev = to_usb_port(dev);
 
+	usb_acpi_unregister_power_resources(dev);
 	kfree(port_dev);
 }
 
@@ -95,6 +96,10 @@ int usb_hub_create_port_device(struct usb_hub *hub, int port1)
 	if (retval)
 		goto error_register;
 
+	retval = usb_acpi_register_power_resources(&port_dev->dev);
+	if (retval && retval != -ENODEV)
+		dev_warn(&port_dev->dev, "the port can't register its ACPI power resource.\n");
+
 	return 0;
 
 error_register:

commit cef7468caff29d3333fba4d0ececd82063ce80d5
Author: Lan Tianyu <tianyu.lan@intel.com>
Date:   Sun Jan 20 01:53:32 2013 +0800

    usb: Add "portX/connect_type" attribute to expose usb port's connect type
    
    Some platforms provide usb port connect types through ACPI. This
    patch is to add this new attribute to expose these information
    to user space.
    
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Lan Tianyu <tianyu.lan@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/port.c b/drivers/usb/core/port.c
index 3734850120ae..fe5959fc021b 100644
--- a/drivers/usb/core/port.c
+++ b/drivers/usb/core/port.c
@@ -20,6 +20,48 @@
 
 #include "hub.h"
 
+static const struct attribute_group *port_dev_group[];
+
+static ssize_t show_port_connect_type(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct usb_port *port_dev = to_usb_port(dev);
+	char *result;
+
+	switch (port_dev->connect_type) {
+	case USB_PORT_CONNECT_TYPE_HOT_PLUG:
+		result = "hotplug";
+		break;
+	case USB_PORT_CONNECT_TYPE_HARD_WIRED:
+		result = "hardwired";
+		break;
+	case USB_PORT_NOT_USED:
+		result = "not used";
+		break;
+	default:
+		result = "unknown";
+		break;
+	}
+
+	return sprintf(buf, "%s\n", result);
+}
+static DEVICE_ATTR(connect_type, S_IRUGO, show_port_connect_type,
+		NULL);
+
+static struct attribute *port_dev_attrs[] = {
+	&dev_attr_connect_type.attr,
+	NULL,
+};
+
+static struct attribute_group port_dev_attr_grp = {
+	.attrs = port_dev_attrs,
+};
+
+static const struct attribute_group *port_dev_group[] = {
+	&port_dev_attr_grp,
+	NULL,
+};
+
 static void usb_port_device_release(struct device *dev)
 {
 	struct usb_port *port_dev = to_usb_port(dev);
@@ -45,6 +87,7 @@ int usb_hub_create_port_device(struct usb_hub *hub, int port1)
 
 	hub->ports[port1 - 1] = port_dev;
 	port_dev->dev.parent = hub->intfdev;
+	port_dev->dev.groups = port_dev_group;
 	port_dev->dev.type = &usb_port_device_type;
 	dev_set_name(&port_dev->dev, "port%d", port1);
 

commit 9f7344fbaf191de63df315c7e0fa4c976e2ea419
Author: Lan Tianyu <tianyu.lan@intel.com>
Date:   Sat Jan 19 22:30:19 2013 +0800

    usb: fix compilation error and warning of driver/usb/core/port.c on arm and blackfin
    
    This patch is to fix compilation error and warning on the arm and blackfin.
    Add linux/slab.h head file to driver/usb/core/port.c. These are reported
    from 0-DAY kernel build testing backend.
    
    head:   6e30d7cba992d626c9d16b3873a7b90c700d0e95
    commit: 6e30d7cba992d626c9d16b3873a7b90c700d0e95 [26/26] usb: Add driver/usb/core/(port.c,hub.h) files
    config: make ARCH=arm at91_dt_defconfig
    
    All error/warnings:
    
       drivers/usb/core/port.c: In function 'usb_port_device_release':
    >> drivers/usb/core/port.c:25:2: error: implicit declaration of function 'kfree' [-Werror=implicit-function-declaration]
       drivers/usb/core/port.c: In function 'usb_hub_create_port_device':
    >> drivers/usb/core/port.c:38:2: error: implicit declaration of function 'kzalloc' [-Werror=implicit-function-declaration]
    >> drivers/usb/core/port.c:38:40: error: 'GFP_KERNEL' undeclared (first use in this function)
       drivers/usb/core/port.c:38:40: note: each undeclared identifier is reported only once for each function it appears in
       cc1: some warnings being treated as errors
    
    head:   6e30d7cba992d626c9d16b3873a7b90c700d0e95
    commit: 6e30d7cba992d626c9d16b3873a7b90c700d0e95 [26/26] usb: Add driver/usb/core/(port.c,hub.h) files
    config: make ARCH=blackfin BF526-EZBRD_defconfig
    
    All warnings:
    
       drivers/usb/core/port.c: In function 'usb_port_device_release':
       drivers/usb/core/port.c:25:2: error: implicit declaration of function 'kfree' [-Werror=implicit-function-declaration]
       drivers/usb/core/port.c: In function 'usb_hub_create_port_device':
       drivers/usb/core/port.c:38:2: error: implicit declaration of function 'kzalloc' [-Werror=implicit-function-declaration]
    >> drivers/usb/core/port.c:38:11: warning: assignment makes pointer from integer without a cast [enabled by default]
       cc1: some warnings being treated as errors
    
    Reported-by: Fengguang Wu <wfg@linux.intel.com>
    Signed-off-by: Lan Tianyu <tianyu.lan@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/port.c b/drivers/usb/core/port.c
index 2bc1cef4e478..3734850120ae 100644
--- a/drivers/usb/core/port.c
+++ b/drivers/usb/core/port.c
@@ -16,6 +16,8 @@
  *
  */
 
+#include <linux/slab.h>
+
 #include "hub.h"
 
 static void usb_port_device_release(struct device *dev)

commit 6e30d7cba992d626c9d16b3873a7b90c700d0e95
Author: Lan Tianyu <tianyu.lan@intel.com>
Date:   Fri Jan 11 20:10:38 2013 +0800

    usb: Add driver/usb/core/(port.c,hub.h) files
    
    This patch is to create driver/usb/core/(port.c,hub.h) files and move usb
    port related code into port.c.
    
    Signed-off-by: Lan Tianyu <tianyu.lan@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/port.c b/drivers/usb/core/port.c
new file mode 100644
index 000000000000..2bc1cef4e478
--- /dev/null
+++ b/drivers/usb/core/port.c
@@ -0,0 +1,66 @@
+/*
+ * usb port device code
+ *
+ * Copyright (C) 2012 Intel Corp
+ *
+ * Author: Lan Tianyu <tianyu.lan@intel.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ */
+
+#include "hub.h"
+
+static void usb_port_device_release(struct device *dev)
+{
+	struct usb_port *port_dev = to_usb_port(dev);
+
+	kfree(port_dev);
+}
+
+struct device_type usb_port_device_type = {
+	.name =		"usb_port",
+	.release =	usb_port_device_release,
+};
+
+int usb_hub_create_port_device(struct usb_hub *hub, int port1)
+{
+	struct usb_port *port_dev = NULL;
+	int retval;
+
+	port_dev = kzalloc(sizeof(*port_dev), GFP_KERNEL);
+	if (!port_dev) {
+		retval = -ENOMEM;
+		goto exit;
+	}
+
+	hub->ports[port1 - 1] = port_dev;
+	port_dev->dev.parent = hub->intfdev;
+	port_dev->dev.type = &usb_port_device_type;
+	dev_set_name(&port_dev->dev, "port%d", port1);
+
+	retval = device_register(&port_dev->dev);
+	if (retval)
+		goto error_register;
+
+	return 0;
+
+error_register:
+	put_device(&port_dev->dev);
+exit:
+	return retval;
+}
+
+void usb_hub_remove_port_device(struct usb_hub *hub,
+				       int port1)
+{
+	device_unregister(&hub->ports[port1 - 1]->dev);
+}
+
