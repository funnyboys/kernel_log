commit e6075b6689506d3c388bd72888df9f42a51ed6d8
Author: Nishad Kamdar <nishadkamdar@gmail.com>
Date:   Sat Mar 28 14:48:50 2020 +0530

    USB: core: Use the correct style for SPDX License Identifier
    
    This patch corrects the SPDX License Identifier style in
    header files related to USB Core.
    For C header files Documentation/process/license-rules.rst
    mandates C-like comments (opposed to C source files where
    C++ style should be used).
    
    Changes made by using a script provided by Joe Perches here:
    https://lkml.org/lkml/2019/2/7/46.
    
    Suggested-by: Joe Perches <joe@perches.com>
    Signed-off-by: Nishad Kamdar <nishadkamdar@gmail.com>
    Link: https://lore.kernel.org/r/20200328091844.GA3648@nishad
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 64ed4023a8c8..19e4c550bc73 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -1,4 +1,4 @@
-// SPDX-License-Identifier: GPL-2.0
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Released under the GPLv2 only.
  */

commit 24e6aea4801bae1dce3b16da6bc64fc06742ac14
Merge: 6bc3f3979edc f8788d86ab28
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Feb 24 08:48:49 2020 +0100

    Merge 5.6-rc3 into usb-next
    
    We need the USB fixes in here as well.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit aeebf2b5466506546c47ca68477d4aa8a96377a6
Author: Bastien Nocera <hadess@hadess.net>
Date:   Wed Oct 16 11:39:30 2019 +0200

    USB: Implement usb_device_match_id()
    
    Match a usb_device with a table of IDs.
    
    Signed-off-by: Bastien Nocera <hadess@hadess.net>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Link: https://lore.kernel.org/r/20191016093933.693-4-hadess@hadess.net
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index bbe24817315e..f1dc63848219 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -69,6 +69,8 @@ extern int usb_match_one_id_intf(struct usb_device *dev,
 				 const struct usb_device_id *id);
 extern int usb_match_device(struct usb_device *dev,
 			    const struct usb_device_id *id);
+extern const struct usb_device_id *usb_device_match_id(struct usb_device *udev,
+				const struct usb_device_id *id);
 extern void usb_forced_unbind_intf(struct usb_interface *intf);
 extern void usb_unbind_and_rebind_marked_interfaces(struct usb_device *udev);
 

commit ef0f7d1877ac21fd926f2349e6a025c201651cf7
Author: Bastien Nocera <hadess@hadess.net>
Date:   Wed Oct 16 11:39:28 2019 +0200

    USB: Export generic USB device driver functions
    
    This will make it possible to implement device drivers which extend the
    generic driver without needing to reimplement it.
    
    Signed-off-by: Bastien Nocera <hadess@hadess.net>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Link: https://lore.kernel.org/r/20191016093933.693-2-hadess@hadess.net
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index cf4783cf661a..bbe24817315e 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -47,6 +47,12 @@ extern void usb_release_bos_descriptor(struct usb_device *dev);
 extern char *usb_cache_string(struct usb_device *udev, int index);
 extern int usb_set_configuration(struct usb_device *dev, int configuration);
 extern int usb_choose_configuration(struct usb_device *udev);
+extern int usb_generic_driver_probe(struct usb_device *udev);
+extern void usb_generic_driver_disconnect(struct usb_device *udev);
+extern int usb_generic_driver_suspend(struct usb_device *udev,
+		pm_message_t msg);
+extern int usb_generic_driver_resume(struct usb_device *udev,
+		pm_message_t msg);
 
 static inline unsigned usb_get_max_power(struct usb_device *udev,
 		struct usb_host_config *c)

commit 73f8bda9b5dc1c69df2bc55c0cbb24461a6391a9
Author: Johan Hovold <johan@kernel.org>
Date:   Mon Feb 3 16:38:28 2020 +0100

    USB: core: add endpoint-blacklist quirk
    
    Add a new device quirk that can be used to blacklist endpoints.
    
    Since commit 3e4f8e21c4f2 ("USB: core: fix check for duplicate
    endpoints") USB core ignores any duplicate endpoints found during
    descriptor parsing.
    
    In order to handle devices where the first interfaces with duplicate
    endpoints are the ones that should have their endpoints ignored, we need
    to add a blacklist.
    
    Tested-by: edes <edes@gmx.net>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Link: https://lore.kernel.org/r/20200203153830.26394-2-johan@kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index cf4783cf661a..3ad0ee57e859 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -37,6 +37,9 @@ extern void usb_authorize_interface(struct usb_interface *);
 extern void usb_detect_quirks(struct usb_device *udev);
 extern void usb_detect_interface_quirks(struct usb_device *udev);
 extern void usb_release_quirk_list(void);
+extern bool usb_endpoint_is_blacklisted(struct usb_device *udev,
+		struct usb_host_interface *intf,
+		struct usb_endpoint_descriptor *epd);
 extern int usb_remove_device(struct usb_device *udev);
 
 extern int usb_get_device_descriptor(struct usb_device *dev,

commit 51fa228c8e05c58f51c97bbc571be94c4592a85e
Merge: 92b8608691bf d45331b00ddb
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Aug 12 07:42:51 2019 +0200

    Merge 5.3-rc4 into usb-next
    
    We need the USB fixes in here as well.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 7794f486ed0b1fa8022dd0a27b9babf86a46d1cf
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Aug 7 10:29:50 2019 -0400

    usbfs: Add ioctls for runtime power management
    
    It has been requested that usbfs should implement runtime power
    management, instead of forcing the device to remain at full power as
    long as the device file is open.  This patch introduces that new
    feature.
    
    It does so by adding three new usbfs ioctls:
    
            USBDEVFS_FORBID_SUSPEND: Prevents the device from going into
            runtime suspend (and causes a resume if the device is already
            suspended).
    
            USBDEVFS_ALLOW_SUSPEND: Allows the device to go into runtime
            suspend.  Some time may elapse before the device actually is
            suspended, depending on things like the autosuspend delay.
    
            USBDEVFS_WAIT_FOR_RESUME: Blocks until the call is interrupted
            by a signal or at least one runtime resume has occurred since
            the most recent ALLOW_SUSPEND ioctl call (which may mean
            immediately, even if the device is currently suspended).  In
            the latter case, the device is prevented from suspending again
            just as if FORBID_SUSPEND was called before the ioctl returns.
    
    For backward compatibility, when the device file is first opened
    runtime suspends are forbidden.  The userspace program can then allow
    suspends whenever it wants, and either resume the device directly (by
    forbidding suspends again) or wait for a resume from some other source
    (such as a remote wakeup).  URBs submitted to a suspended device will
    fail or will complete with an appropriate error code.
    
    This combination of ioctls is sufficient for user programs to have
    nearly the same degree of control over a device's runtime power
    behavior as kernel drivers do.
    
    Still lacking is documentation for the new ioctls.  I intend to add it
    later, after the existing documentation for the usbfs userspace API is
    straightened out into a reasonable form.
    
    Suggested-by: Mayuresh Kulkarni <mkulkarni@opensource.cirrus.com>
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    
    Link: https://lore.kernel.org/r/Pine.LNX.4.44L0.1908071013220.1514-100000@iolanthe.rowland.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index bd8d01f85a13..2932d1ec5def 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -95,6 +95,9 @@ extern int usb_runtime_idle(struct device *dev);
 extern int usb_enable_usb2_hardware_lpm(struct usb_device *udev);
 extern int usb_disable_usb2_hardware_lpm(struct usb_device *udev);
 
+extern void usbfs_notify_suspend(struct usb_device *udev);
+extern void usbfs_notify_resume(struct usb_device *udev);
+
 #else
 
 static inline int usb_port_suspend(struct usb_device *udev, pm_message_t msg)

commit 27709ae4e2fe6cf7da2ae45e718e190c5433342b
Author: Thiébaud Weksteen <tweek@google.com>
Date:   Tue Aug 6 13:00:50 2019 +0200

    usb: setup authorized_default attributes using usb_bus_notify
    
    Currently, the authorized_default and interface_authorized_default
    attributes for HCD are set up after the uevent has been sent to userland.
    This creates a race condition where userland may fail to access this
    file when processing the event. Move the appending of these attributes
    earlier relying on the usb_bus_notify dispatcher.
    
    Signed-off-by: Thiébaud Weksteen <tweek@google.com>
    Cc: stable <stable@vger.kernel.org>
    Link: https://lore.kernel.org/r/20190806110050.38918-1-tweek@google.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index bd8d01f85a13..0c9fde5ad052 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -153,6 +153,11 @@ static inline int is_usb_port(const struct device *dev)
 	return dev->type == &usb_port_device_type;
 }
 
+static inline int is_root_hub(struct usb_device *udev)
+{
+	return (udev->parent == NULL);
+}
+
 /* Do the same for device drivers and interface drivers. */
 
 static inline int is_usb_device_driver(struct device_driver *drv)

commit ffed60971f3d95923b99ea970862c6ab6a22c20f
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Jun 25 16:03:58 2019 -0400

    USB: core: Remove usbfs_mutex
    
    Commit 4a2a8a2cce86 ("usbfs: private mutex for open, release, and
    remove") is now obsolete.  The commit was created back when we had
    to handle both usbfs device nodes and the old usbdevfs filesystem
    (/proc/bus/usb/), but usbdevfs no longer exists.
    
    This means there's no longer any need to hold a mutex during two
    separate removal operations (and thus during an entire notifier chain
    call).  Furthermore, the one remaining remove/release pair doesn't
    race with open thanks to the synchronization provided by the device
    model core in bus_find_device().  Remove and release don't race with
    each other because they both run with the device lock held.
    
    The upshot is that usbfs_mutex isn't needed any more.  This patch
    removes it entirely.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index d95a5358f73d..bd8d01f85a13 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -169,7 +169,6 @@ extern const struct attribute_group *usb_device_groups[];
 extern const struct attribute_group *usb_interface_groups[];
 
 /* usbfs stuff */
-extern struct mutex usbfs_mutex;
 extern struct usb_driver usbfs_driver;
 extern const struct file_operations usbfs_devices_fops;
 extern const struct file_operations usbdev_file_operations;

commit 7529b2574a7aaf902f1f8159fbc2a7caa74be559
Author: Kai-Heng Feng <kai.heng.feng@canonical.com>
Date:   Sat Jan 12 03:54:24 2019 +0800

    USB: Add new USB LPM helpers
    
    Use new helpers to make LPM enabling/disabling more clear.
    
    This is a preparation to subsequent patch.
    
    Signed-off-by: Kai-Heng Feng <kai.heng.feng@canonical.com>
    Cc: stable <stable@vger.kernel.org> # after much soaking
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 546a2219454b..d95a5358f73d 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -92,7 +92,8 @@ extern int usb_remote_wakeup(struct usb_device *dev);
 extern int usb_runtime_suspend(struct device *dev);
 extern int usb_runtime_resume(struct device *dev);
 extern int usb_runtime_idle(struct device *dev);
-extern int usb_set_usb2_hardware_lpm(struct usb_device *udev, int enable);
+extern int usb_enable_usb2_hardware_lpm(struct usb_device *udev);
+extern int usb_disable_usb2_hardware_lpm(struct usb_device *udev);
 
 #else
 
@@ -112,7 +113,12 @@ static inline int usb_autoresume_device(struct usb_device *udev)
 	return 0;
 }
 
-static inline int usb_set_usb2_hardware_lpm(struct usb_device *udev, int enable)
+static inline int usb_enable_usb2_hardware_lpm(struct usb_device *udev)
+{
+	return 0;
+}
+
+static inline int usb_disable_usb2_hardware_lpm(struct usb_device *udev)
 {
 	return 0;
 }

commit 027bd6cafd9a1e3a109b5e5682c85ac84e804a8d
Author: Kai-Heng Feng <kai.heng.feng@canonical.com>
Date:   Tue Mar 20 00:26:06 2018 +0800

    usb: core: Add "quirks" parameter for usbcore
    
    Trying quirks in usbcore needs to rebuild the driver or the entire
    kernel if it's builtin. It can save a lot of time if usbcore has similar
    ability like "usbhid.quirks=" and "usb-storage.quirks=".
    
    Rename the original quirk detection function to "static" as we introduce
    this new "dynamic" function.
    
    Now users can use "usbcore.quirks=" as short term workaround before the
    next kernel release. Also, the quirk parameter can XOR the builtin
    quirks for debugging purpose.
    
    This is inspired by usbhid and usb-storage.
    
    Signed-off-by: Kai-Heng Feng <kai.heng.feng@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 149cc7480971..546a2219454b 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -36,6 +36,7 @@ extern void usb_deauthorize_interface(struct usb_interface *);
 extern void usb_authorize_interface(struct usb_interface *);
 extern void usb_detect_quirks(struct usb_device *udev);
 extern void usb_detect_interface_quirks(struct usb_device *udev);
+extern void usb_release_quirk_list(void);
 extern int usb_remove_device(struct usb_device *udev);
 
 extern int usb_get_device_descriptor(struct usb_device *dev,

commit 95713fb8aa039e9cd89ff545b62bd2a860c36e39
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Mar 12 16:30:40 2018 +0100

    Revert "usb: core: Add "quirks" parameter for usbcore"
    
    This reverts commit b27560e4d9e5240b5544c9c5650c7442e482646e as it
    breaks the build for some arches :(
    
    Reported-by: kbuild test robot <fengguang.wu@intel.com>
    Cc: Kai-Heng Feng <kai.heng.feng@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    
    diff --git a/Documentation/admin-guide/kernel-parameters.txt b/Documentation/admin-guide/kernel-parameters.txt
    index 1d1d53f85ddd..70a7398c20e2 100644
    --- a/Documentation/admin-guide/kernel-parameters.txt
    +++ b/Documentation/admin-guide/kernel-parameters.txt
    @@ -4368,6 +4368,61 @@
    
            usbcore.nousb   [USB] Disable the USB subsystem
    
    +       usbcore.quirks=
    +                       [USB] A list of quirks entries to supplement or
    +                       override the built-in usb core quirk list.  List
    +                       entries are separated by commas.  Each entry has
    +                       the form VID:PID:Flags where VID and PID are Vendor
    +                       and Product ID values (4-digit hex numbers) and
    +                       Flags is a set of characters, each corresponding
    +                       to a common usb core quirk flag as follows:
    +                               a = USB_QUIRK_STRING_FETCH_255 (string
    +                                       descriptors must not be fetched using
    +                                       a 255-byte read);
    +                               b = USB_QUIRK_RESET_RESUME (device can't resume
    +                                       correctly so reset it instead);
    +                               c = USB_QUIRK_NO_SET_INTF (device can't handle
    +                                       Set-Interface requests);
    +                               d = USB_QUIRK_CONFIG_INTF_STRINGS (device can't
    +                                       handle its Configuration or Interface
    +                                       strings);
    +                               e = USB_QUIRK_RESET (device can't be reset
    +                                       (e.g morph devices), don't use reset);
    +                               f = USB_QUIRK_HONOR_BNUMINTERFACES (device has
    +                                       more interface descriptions than the
    +                                       bNumInterfaces count, and can't handle
    +                                       talking to these interfaces);
    +                               g = USB_QUIRK_DELAY_INIT (device needs a pause
    +                                       during initialization, after we read
    +                                       the device descriptor);
    +                               h = USB_QUIRK_LINEAR_UFRAME_INTR_BINTERVAL (For
    +                                       high speed and super speed interrupt
    +                                       endpoints, the USB 2.0 and USB 3.0 spec
    +                                       require the interval in microframes (1
    +                                       microframe = 125 microseconds) to be
    +                                       calculated as interval = 2 ^
    +                                       (bInterval-1).
    +                                       Devices with this quirk report their
    +                                       bInterval as the result of this
    +                                       calculation instead of the exponent
    +                                       variable used in the calculation);
    +                               i = USB_QUIRK_DEVICE_QUALIFIER (device can't
    +                                       handle device_qualifier descriptor
    +                                       requests);
    +                               j = USB_QUIRK_IGNORE_REMOTE_WAKEUP (device
    +                                       generates spurious wakeup, ignore
    +                                       remote wakeup capability);
    +                               k = USB_QUIRK_NO_LPM (device can't handle Link
    +                                       Power Management);
    +                               l = USB_QUIRK_LINEAR_FRAME_INTR_BINTERVAL
    +                                       (Device reports its bInterval as linear
    +                                       frames instead of the USB 2.0
    +                                       calculation);
    +                               m = USB_QUIRK_DISCONNECT_SUSPEND (Device needs
    +                                       to be disconnected before suspend to
    +                                       prevent spurious wakeup)
    +                       Example: quirks=0781:5580:bk,0a5c:5834:gij
    +
            usbhid.mousepoll=
                            [USBHID] The interval which mice are to be polled at.
    
    diff --git a/drivers/usb/core/quirks.c b/drivers/usb/core/quirks.c
    index f4a548471f0f..42faaeead81b 100644
    --- a/drivers/usb/core/quirks.c
    +++ b/drivers/usb/core/quirks.c
    @@ -11,6 +11,143 @@
     #include <linux/usb/hcd.h>
     #include "usb.h"
    
    +struct quirk_entry {
    +       u16 vid;
    +       u16 pid;
    +       u32 flags;
    +};
    +
    +static DEFINE_MUTEX(quirk_mutex);
    +
    +static struct quirk_entry *quirk_list;
    +static unsigned int quirk_count;
    +
    +static char quirks_param[128];
    +
    +static int quirks_param_set(const char *val, const struct kernel_param *kp)
    +{
    +       char *p, *field;
    +       u16 vid, pid;
    +       u32 flags;
    +       size_t i;
    +
    +       mutex_lock(&quirk_mutex);
    +
    +       if (!val || !*val) {
    +               quirk_count = 0;
    +               kfree(quirk_list);
    +               quirk_list = NULL;
    +               goto unlock;
    +       }
    +
    +       for (quirk_count = 1, i = 0; val[i]; i++)
    +               if (val[i] == ',')
    +                       quirk_count++;
    +
    +       if (quirk_list) {
    +               kfree(quirk_list);
    +               quirk_list = NULL;
    +       }
    +
    +       quirk_list = kcalloc(quirk_count, sizeof(struct quirk_entry),
    +                            GFP_KERNEL);
    +       if (!quirk_list) {
    +               mutex_unlock(&quirk_mutex);
    +               return -ENOMEM;
    +       }
    +
    +       for (i = 0, p = (char *)val; p && *p;) {
    +               /* Each entry consists of VID:PID:flags */
    +               field = strsep(&p, ":");
    +               if (!field)
    +                       break;
    +
    +               if (kstrtou16(field, 16, &vid))
    +                       break;
    +
    +               field = strsep(&p, ":");
    +               if (!field)
    +                       break;
    +
    +               if (kstrtou16(field, 16, &pid))
    +                       break;
    +
    +               field = strsep(&p, ",");
    +               if (!field || !*field)
    +                       break;
    +
    +               /* Collect the flags */
    +               for (flags = 0; *field; field++) {
    +                       switch (*field) {
    +                       case 'a':
    +                               flags |= USB_QUIRK_STRING_FETCH_255;
    +                               break;
    +                       case 'b':
    +                               flags |= USB_QUIRK_RESET_RESUME;
    +                               break;
    +                       case 'c':
    +                               flags |= USB_QUIRK_NO_SET_INTF;
    +                               break;
    +                       case 'd':
    +                               flags |= USB_QUIRK_CONFIG_INTF_STRINGS;
    +                               break;
    +                       case 'e':
    +                               flags |= USB_QUIRK_RESET;
    +                               break;
    +                       case 'f':
    +                               flags |= USB_QUIRK_HONOR_BNUMINTERFACES;
    +                               break;
    +                       case 'g':
    +                               flags |= USB_QUIRK_DELAY_INIT;
    +                               break;
    +                       case 'h':
    +                               flags |= USB_QUIRK_LINEAR_UFRAME_INTR_BINTERVAL;
    +                               break;
    +                       case 'i':
    +                               flags |= USB_QUIRK_DEVICE_QUALIFIER;
    +                               break;
    +                       case 'j':
    +                               flags |= USB_QUIRK_IGNORE_REMOTE_WAKEUP;
    +                               break;
    +                       case 'k':
    +                               flags |= USB_QUIRK_NO_LPM;
    +                               break;
    +                       case 'l':
    +                               flags |= USB_QUIRK_LINEAR_FRAME_INTR_BINTERVAL;
    +                               break;
    +                       case 'm':
    +                               flags |= USB_QUIRK_DISCONNECT_SUSPEND;
    +                               break;
    +                       /* Ignore unrecognized flag characters */
    +                       }
    +               }
    +
    +               quirk_list[i++] = (struct quirk_entry)
    +                       { .vid = vid, .pid = pid, .flags = flags };
    +       }
    +
    +       if (i < quirk_count)
    +               quirk_count = i;
    +
    +unlock:
    +       mutex_unlock(&quirk_mutex);
    +
    +       return param_set_copystring(val, kp);
    +}
    +
    +static const struct kernel_param_ops quirks_param_ops = {
    +       .set = quirks_param_set,
    +       .get = param_get_string,
    +};
    +
    +static struct kparam_string quirks_param_string = {
    +       .maxlen = sizeof(quirks_param),
    +       .string = quirks_param,
    +};
    +
    +module_param_cb(quirks, &quirks_param_ops, &quirks_param_string, 0644);
    +MODULE_PARM_DESC(quirks, "Add/modify USB quirks by specifying quirks=vendorID:productID:quirks");
    +
     /* Lists of quirky USB devices, split in device quirks and interface quirks.
      * Device quirks are applied at the very beginning of the enumeration process,
      * right after reading the device descriptor. They can thus only match on device
    @@ -320,8 +457,8 @@ static int usb_amd_resume_quirk(struct usb_device *udev)
            return 0;
     }
    
    -static u32 __usb_detect_quirks(struct usb_device *udev,
    -                              const struct usb_device_id *id)
    +static u32 usb_detect_static_quirks(struct usb_device *udev,
    +                                   const struct usb_device_id *id)
     {
            u32 quirks = 0;
    
    @@ -339,21 +476,43 @@ static u32 __usb_detect_quirks(struct usb_device *udev,
            return quirks;
     }
    
    +static u32 usb_detect_dynamic_quirks(struct usb_device *udev)
    +{
    +       u16 vid = le16_to_cpu(udev->descriptor.idVendor);
    +       u16 pid = le16_to_cpu(udev->descriptor.idProduct);
    +       int i, flags = 0;
    +
    +       mutex_lock(&quirk_mutex);
    +
    +       for (i = 0; i < quirk_count; i++) {
    +               if (vid == quirk_list[i].vid && pid == quirk_list[i].pid) {
    +                       flags = quirk_list[i].flags;
    +                       break;
    +               }
    +       }
    +
    +       mutex_unlock(&quirk_mutex);
    +
    +       return flags;
    +}
    +
     /*
      * Detect any quirks the device has, and do any housekeeping for it if needed.
      */
     void usb_detect_quirks(struct usb_device *udev)
     {
    -       udev->quirks = __usb_detect_quirks(udev, usb_quirk_list);
    +       udev->quirks = usb_detect_static_quirks(udev, usb_quirk_list);
    
            /*
             * Pixart-based mice would trigger remote wakeup issue on AMD
             * Yangtze chipset, so set them as RESET_RESUME flag.
             */
            if (usb_amd_resume_quirk(udev))
    -               udev->quirks |= __usb_detect_quirks(udev,
    +               udev->quirks |= usb_detect_static_quirks(udev,
                                    usb_amd_resume_quirk_list);
    
    +       udev->quirks ^= usb_detect_dynamic_quirks(udev);
    +
            if (udev->quirks)
                    dev_dbg(&udev->dev, "USB quirks for this device: %x\n",
                            udev->quirks);
    @@ -372,7 +531,7 @@ void usb_detect_interface_quirks(struct usb_device *udev)
     {
            u32 quirks;
    
    -       quirks = __usb_detect_quirks(udev, usb_interface_quirk_list);
    +       quirks = usb_detect_static_quirks(udev, usb_interface_quirk_list);
            if (quirks == 0)
                    return;
    
    @@ -380,3 +539,11 @@ void usb_detect_interface_quirks(struct usb_device *udev)
                    quirks);
            udev->quirks |= quirks;
     }
    +
    +void usb_release_quirk_list(void)
    +{
    +       mutex_lock(&quirk_mutex);
    +       kfree(quirk_list);
    +       quirk_list = NULL;
    +       mutex_unlock(&quirk_mutex);
    +}
    diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
    index 2f5fbc56a9dd..0adb6345ff2e 100644
    --- a/drivers/usb/core/usb.c
    +++ b/drivers/usb/core/usb.c
    @@ -1259,6 +1259,7 @@ static void __exit usb_exit(void)
            if (usb_disabled())
                    return;
    
    +       usb_release_quirk_list();
            usb_deregister_device_driver(&usb_generic_driver);
            usb_major_cleanup();
            usb_deregister(&usbfs_driver);
    diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
    index 149cc7480971..546a2219454b 100644
    --- a/drivers/usb/core/usb.h
    +++ b/drivers/usb/core/usb.h
    @@ -36,6 +36,7 @@ extern void usb_deauthorize_interface(struct usb_interface *);
     extern void usb_authorize_interface(struct usb_interface *);
     extern void usb_detect_quirks(struct usb_device *udev);
     extern void usb_detect_interface_quirks(struct usb_device *udev);
    +extern void usb_release_quirk_list(void);
     extern int usb_remove_device(struct usb_device *udev);
    
     extern int usb_get_device_descriptor(struct usb_device *dev,

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 546a2219454b..149cc7480971 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -36,7 +36,6 @@ extern void usb_deauthorize_interface(struct usb_interface *);
 extern void usb_authorize_interface(struct usb_interface *);
 extern void usb_detect_quirks(struct usb_device *udev);
 extern void usb_detect_interface_quirks(struct usb_device *udev);
-extern void usb_release_quirk_list(void);
 extern int usb_remove_device(struct usb_device *udev);
 
 extern int usb_get_device_descriptor(struct usb_device *dev,

commit b27560e4d9e5240b5544c9c5650c7442e482646e
Author: Kai-Heng Feng <kai.heng.feng@canonical.com>
Date:   Thu Mar 8 13:37:05 2018 +0800

    usb: core: Add "quirks" parameter for usbcore
    
    Trying quirks in usbcore needs to rebuild the driver or the entire
    kernel if it's builtin. It can save a lot of time if usbcore has similar
    ability like "usbhid.quirks=" and "usb-storage.quirks=".
    
    Rename the original quirk detection function to "static" as we introduce
    this new "dynamic" function.
    
    Now users can use "usbcore.quirks=" as short term workaround before the
    next kernel release. Also, the quirk parameter can XOR the builtin
    quirks for debugging purpose.
    
    This is inspired by usbhid and usb-storage.
    
    Signed-off-by: Kai-Heng Feng <kai.heng.feng@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 149cc7480971..546a2219454b 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -36,6 +36,7 @@ extern void usb_deauthorize_interface(struct usb_interface *);
 extern void usb_authorize_interface(struct usb_interface *);
 extern void usb_detect_quirks(struct usb_device *udev);
 extern void usb_detect_interface_quirks(struct usb_device *udev);
+extern void usb_release_quirk_list(void);
 extern int usb_remove_device(struct usb_device *udev);
 
 extern int usb_get_device_descriptor(struct usb_device *dev,

commit 886ee36e7205a7b850e2e5c2298a479f581f9b3b
Author: Felipe Balbi <felipe.balbi@linux.intel.com>
Date:   Thu Dec 14 09:50:39 2017 +0200

    usb: core: add support for USB_REQ_SET_ISOCH_DELAY
    
    USB SS and SSP hubs provide wHubDelay values on their hub descriptor
    which we should inform the USB Device about.
    
    The USB Specification 3.0 explains, on section 9.4.11, how to
    calculate the value and how to issue the request. Note that a
    USB_REQ_SET_ISOCH_DELAY is valid on all device states (Default,
    Address, Configured), we just *chose* to issue it from Address state
    right after successfully fetching the USB Device Descriptor.
    
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 2bee08d084ae..149cc7480971 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -40,6 +40,7 @@ extern int usb_remove_device(struct usb_device *udev);
 
 extern int usb_get_device_descriptor(struct usb_device *dev,
 		unsigned int size);
+extern int usb_set_isoch_delay(struct usb_device *dev);
 extern int usb_get_bos_descriptor(struct usb_device *dev);
 extern void usb_release_bos_descriptor(struct usb_device *dev);
 extern char *usb_cache_string(struct usb_device *udev, int index);

commit aa1f3bb56761cf627ed53a40607bead16d6e23bc
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Nov 3 09:18:41 2017 +0100

    USB: core: move existing SPDX tags to top of the file
    
    To match the rest of the kernel, the SPDX tags for the drivers/usb/core/
    files are moved to the first line of the file.  This makes it more
    obvious the tag is present as well as making it match the other 12k
    files in the tree with this location.
    
    It also uses // to match the "expected style" as well.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index f71890a2db4e..2bee08d084ae 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -1,6 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Released under the GPLv2 only.
- * SPDX-License-Identifier: GPL-2.0
  */
 
 #include <linux/pm.h>

commit 8dd8d2c95d0252bc64aa8e061a5fb4fbcd05f826
Author: Daniel Drake <drake@endlessm.com>
Date:   Wed Oct 18 15:15:01 2017 +0800

    USB: Force disconnect Huawei 4G modem during suspend
    
    When going into S3 suspend, the Acer TravelMate P648-M and P648-G3
    laptops immediately wake up 3-4 seconds later for no obvious reason.
    
    Unbinding the integrated Huawei 4G LTE modem before suspend avoids
    the issue, even though we are not using the modem at all (checked
    from rescue.target/runlevel1). The problem also occurs when the option
    and cdc-ether modem drivers aren't loaded; it reproduces just with the
    base usb driver. Under Windows the system can suspend fine.
    
    Seeking a better fix, we've tried a lot of things, including:
     - Check that the device's power/wakeup is disabled
     - Check that remote wakeup is off at the USB level
     - All the quirks in drivers/usb/core/quirks.c e.g. USB_QUIRK_RESET_RESUME,
       USB_QUIRK_RESET, USB_QUIRK_IGNORE_REMOTE_WAKEUP, USB_QUIRK_NO_LPM.
    
    but none of that makes any difference.
    
    There are no errors in the logs showing any suspend/resume-related issues.
    When the system wakes up due to the modem, log-wise it appears to be a
    normal resume.
    
    Introduce a quirk to disable the port during suspend when the modem is
    detected.
    
    The modem from the P648-G3 model is:
    T:  Bus=01 Lev=01 Prnt=01 Port=08 Cnt=04 Dev#=  5 Spd=480  MxCh= 0
    D:  Ver= 2.00 Cls=00(>ifc ) Sub=00 Prot=ff MxPS=64 #Cfgs=  3
    P:  Vendor=12d1 ProdID=15c3 Rev= 1.02
    S:  Manufacturer=Huawei Technologies Co., Ltd.
    S:  Product=HUAWEI Mobile
    S:  SerialNumber=0123456789ABCDEF
    C:  #Ifs= 5 Cfg#= 1 Atr=a0 MxPwr=  2mA
    I:  If#= 0 Alt= 0 #EPs= 3 Cls=ff(vend.) Sub=06 Prot=10 Driver=
    E:  Ad=82(I) Atr=03(Int.) MxPS=  10 Ivl=32ms
    E:  Ad=81(I) Atr=02(Bulk) MxPS= 512 Ivl=0ms
    E:  Ad=01(O) Atr=02(Bulk) MxPS= 512 Ivl=0ms
    I:  If#= 1 Alt= 0 #EPs= 2 Cls=ff(vend.) Sub=06 Prot=13 Driver=
    E:  Ad=83(I) Atr=02(Bulk) MxPS= 512 Ivl=0ms
    E:  Ad=02(O) Atr=02(Bulk) MxPS= 512 Ivl=0ms
    I:  If#= 2 Alt= 0 #EPs= 2 Cls=ff(vend.) Sub=06 Prot=12 Driver=
    E:  Ad=84(I) Atr=02(Bulk) MxPS= 512 Ivl=0ms
    E:  Ad=03(O) Atr=02(Bulk) MxPS= 512 Ivl=0ms
    I:  If#= 3 Alt= 0 #EPs= 1 Cls=ff(vend.) Sub=06 Prot=16 Driver=
    E:  Ad=86(I) Atr=03(Int.) MxPS=  16 Ivl=2ms
    I:  If#= 3 Alt= 1 #EPs= 3 Cls=ff(vend.) Sub=06 Prot=16 Driver=
    E:  Ad=86(I) Atr=03(Int.) MxPS=  16 Ivl=2ms
    E:  Ad=85(I) Atr=02(Bulk) MxPS= 512 Ivl=0ms
    E:  Ad=04(O) Atr=02(Bulk) MxPS= 512 Ivl=0ms
    I:  If#= 4 Alt= 0 #EPs= 2 Cls=ff(vend.) Sub=06 Prot=1b Driver=
    E:  Ad=87(I) Atr=02(Bulk) MxPS= 512 Ivl=0ms
    E:  Ad=05(O) Atr=02(Bulk) MxPS= 512 Ivl=0ms
    C:* #Ifs= 6 Cfg#= 2 Atr=a0 MxPwr=  2mA
    I:* If#= 0 Alt= 0 #EPs= 1 Cls=02(comm.) Sub=06 Prot=00 Driver=cdc_ether
    E:  Ad=82(I) Atr=03(Int.) MxPS=  16 Ivl=2ms
    I:* If#= 1 Alt= 0 #EPs= 2 Cls=0a(data ) Sub=06 Prot=00 Driver=cdc_ether
    E:  Ad=81(I) Atr=02(Bulk) MxPS= 512 Ivl=0ms
    E:  Ad=01(O) Atr=02(Bulk) MxPS= 512 Ivl=0ms
    I:* If#= 2 Alt= 0 #EPs= 3 Cls=ff(vend.) Sub=06 Prot=10 Driver=option
    E:  Ad=84(I) Atr=03(Int.) MxPS=  10 Ivl=32ms
    E:  Ad=83(I) Atr=02(Bulk) MxPS= 512 Ivl=0ms
    E:  Ad=02(O) Atr=02(Bulk) MxPS= 512 Ivl=0ms
    I:* If#= 3 Alt= 0 #EPs= 2 Cls=ff(vend.) Sub=06 Prot=13 Driver=option
    E:  Ad=85(I) Atr=02(Bulk) MxPS= 512 Ivl=0ms
    E:  Ad=03(O) Atr=02(Bulk) MxPS= 512 Ivl=0ms
    I:* If#= 4 Alt= 0 #EPs= 2 Cls=ff(vend.) Sub=06 Prot=12 Driver=option
    E:  Ad=86(I) Atr=02(Bulk) MxPS= 512 Ivl=0ms
    E:  Ad=04(O) Atr=02(Bulk) MxPS= 512 Ivl=0ms
    I:* If#= 5 Alt= 0 #EPs= 2 Cls=ff(vend.) Sub=06 Prot=1b Driver=option
    E:  Ad=87(I) Atr=02(Bulk) MxPS= 512 Ivl=0ms
    E:  Ad=05(O) Atr=02(Bulk) MxPS= 512 Ivl=0ms
    C:  #Ifs= 2 Cfg#= 3 Atr=a0 MxPwr=  2mA
    A:  FirstIf#= 0 IfCount= 2 Cls=02(comm.) Sub=0e Prot=00
    I:  If#= 0 Alt= 0 #EPs= 1 Cls=02(comm.) Sub=0e Prot=00 Driver=
    E:  Ad=82(I) Atr=03(Int.) MxPS=  16 Ivl=2ms
    I:  If#= 1 Alt= 0 #EPs= 0 Cls=0a(data ) Sub=00 Prot=02 Driver=
    I:  If#= 1 Alt= 1 #EPs= 2 Cls=0a(data ) Sub=00 Prot=02 Driver=
    E:  Ad=81(I) Atr=02(Bulk) MxPS= 512 Ivl=0ms
    E:  Ad=01(O) Atr=02(Bulk) MxPS= 512 Ivl=0ms
    
    Based on an earlier patch by Chris Chiu.
    
    Signed-off-by: Daniel Drake <drake@endlessm.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index dc6949248823..f71890a2db4e 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -73,6 +73,7 @@ extern void usb_hub_cleanup(void);
 extern int usb_major_init(void);
 extern void usb_major_cleanup(void);
 extern int usb_device_supports_lpm(struct usb_device *udev);
+extern int usb_port_disable(struct usb_device *udev);
 
 #ifdef	CONFIG_PM
 

commit b65fba3d87216bfe6ae9bc77be5eb6eabb6514a4
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Oct 28 17:16:36 2016 -0400

    USB: core: add missing license information to some files
    
    Some of the USB core files were missing explicit license information.
    As all files in the kernel tree are implicitly licensed under the
    GPLv2-only, be explicit in case someone get confused looking at
    individual files by using the SPDX nomenclature.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 53318126ed91..dc6949248823 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -1,3 +1,8 @@
+/*
+ * Released under the GPLv2 only.
+ * SPDX-License-Identifier: GPL-2.0
+ */
+
 #include <linux/pm.h>
 #include <linux/acpi.h>
 

commit 8a1b2725a60d3267135c15e80984b4406054f650
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Thu Dec 10 09:59:25 2015 +0200

    usb: define USB_SPEED_SUPER_PLUS speed for SuperSpeedPlus USB3.1 devices
    
    Add a new USB_SPEED_SUPER_PLUS device speed, and make sure usb core can
    handle the new speed.
    In most cases the behaviour is the same as with USB_SPEED_SUPER SuperSpeed
    devices. In a few places we add a "Plus" string to inform the user of the
    new speed.
    
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 05b5e17abf92..53318126ed91 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -45,7 +45,7 @@ static inline unsigned usb_get_max_power(struct usb_device *udev,
 		struct usb_host_config *c)
 {
 	/* SuperSpeed power is in 8 mA units; others are in 2 mA units */
-	unsigned mul = (udev->speed == USB_SPEED_SUPER ? 8 : 2);
+	unsigned mul = (udev->speed >= USB_SPEED_SUPER ? 8 : 2);
 
 	return c->desc.bMaxPower * mul;
 }

commit b3910cef3968b2456cdd6c33b1f5e33904319f22
Author: Stefan Koch <stefan.koch10@gmail.com>
Date:   Tue Aug 25 21:10:08 2015 +0200

    usb: interface authorization: Introduces the USB interface authorization
    
    The kernel supports the device authorization because of wireless USB.
    These is usable for wired USB devices, too.
    These new interface authorization allows to enable or disable
    individual interfaces instead a whole device.
    
    If a deauthorized interface will be authorized so the driver probing must
    be triggered manually by writing INTERFACE to /sys/bus/usb/drivers_probe
    
    Signed-off-by: Stefan Koch <stefan.koch10@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 457255a3306a..05b5e17abf92 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -27,6 +27,8 @@ extern void usb_release_interface_cache(struct kref *ref);
 extern void usb_disable_device(struct usb_device *dev, int skip_ep0);
 extern int usb_deauthorize_device(struct usb_device *);
 extern int usb_authorize_device(struct usb_device *);
+extern void usb_deauthorize_interface(struct usb_interface *);
+extern void usb_authorize_interface(struct usb_interface *);
 extern void usb_detect_quirks(struct usb_device *udev);
 extern void usb_detect_interface_quirks(struct usb_device *udev);
 extern int usb_remove_device(struct usb_device *udev);

commit 2d2a316765d956bc5cb6bb367b2ec52ca59ab8e9
Author: Lu Baolu <baolu.lu@linux.intel.com>
Date:   Tue Jun 16 09:08:26 2015 +0800

    usb: core: lpm: set lpm_capable for root hub device
    
    Commit 25cd2882e2fc ("usb/xhci: Change how we indicate a host supports
    Link PM.") removed the code to set lpm_capable for USB 3.0 super-speed
    root hub. The intention of that change was to avoid touching usb core
    internal field, a.k.a. lpm_capable, and let usb core to set it by
    checking U1 and U2 exit latency values in the descriptor.
    
    Usb core checks and sets lpm_capable in hub_port_init(). Unfortunately,
    root hub is a special usb device as it has no parent. Hub_port_init()
    will never be called for a root hub device. That means lpm_capable will
    by no means be set for the root hub. As the result, lpm isn't functional
    at all in Linux kernel.
    
    This patch add the code to check and set lpm_capable when registering a
    root hub device. It could be back-ported to kernels as old as v3.15,
    that contains the Commit 25cd2882e2fc ("usb/xhci: Change how we indicate
    a host supports Link PM.").
    
    Cc: stable@vger.kernel.org # 3.15
    Reported-by: Kevin Strasser <kevin.strasser@linux.intel.com>
    Signed-off-by: Lu Baolu <baolu.lu@linux.intel.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 7eb1e26798e5..457255a3306a 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -65,6 +65,7 @@ extern int  usb_hub_init(void);
 extern void usb_hub_cleanup(void);
 extern int usb_major_init(void);
 extern void usb_major_cleanup(void);
+extern int usb_device_supports_lpm(struct usb_device *udev);
 
 #ifdef	CONFIG_PM
 

commit ceb6c9c862c86423f41c1e20ecf8d454f837f519
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Nov 29 23:47:05 2014 +0100

    USB / PM: Drop CONFIG_PM_RUNTIME from the USB core
    
    After commit b2b49ccbdd54 (PM: Kconfig: Set PM_RUNTIME if PM_SLEEP is
    selected) PM_RUNTIME is always set if PM is set, so quite a few
    depend on CONFIG_PM (or even dropped in some cases).
    
    Replace CONFIG_PM_RUNTIME with CONFIG_PM in the USB core code
    and documentation.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index b1b34d0557c9..7eb1e26798e5 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -75,6 +75,14 @@ extern int usb_resume_complete(struct device *dev);
 extern int usb_port_suspend(struct usb_device *dev, pm_message_t msg);
 extern int usb_port_resume(struct usb_device *dev, pm_message_t msg);
 
+extern void usb_autosuspend_device(struct usb_device *udev);
+extern int usb_autoresume_device(struct usb_device *udev);
+extern int usb_remote_wakeup(struct usb_device *dev);
+extern int usb_runtime_suspend(struct device *dev);
+extern int usb_runtime_resume(struct device *dev);
+extern int usb_runtime_idle(struct device *dev);
+extern int usb_set_usb2_hardware_lpm(struct usb_device *udev, int enable);
+
 #else
 
 static inline int usb_port_suspend(struct usb_device *udev, pm_message_t msg)
@@ -87,20 +95,6 @@ static inline int usb_port_resume(struct usb_device *udev, pm_message_t msg)
 	return 0;
 }
 
-#endif
-
-#ifdef CONFIG_PM_RUNTIME
-
-extern void usb_autosuspend_device(struct usb_device *udev);
-extern int usb_autoresume_device(struct usb_device *udev);
-extern int usb_remote_wakeup(struct usb_device *dev);
-extern int usb_runtime_suspend(struct device *dev);
-extern int usb_runtime_resume(struct device *dev);
-extern int usb_runtime_idle(struct device *dev);
-extern int usb_set_usb2_hardware_lpm(struct usb_device *udev, int enable);
-
-#else
-
 #define usb_autosuspend_device(udev)		do {} while (0)
 static inline int usb_autoresume_device(struct usb_device *udev)
 {
@@ -111,6 +105,7 @@ static inline int usb_set_usb2_hardware_lpm(struct usb_device *udev, int enable)
 {
 	return 0;
 }
+
 #endif
 
 extern struct bus_type usb_bus_type;

commit 59d48b3f1fdf307115af38b91c3ea4ddb57b73a2
Author: Petr Mladek <pmladek@suse.cz>
Date:   Fri Sep 19 17:32:22 2014 +0200

    usb: hub: rename usb_kick_khubd() to usb_kick_hub_wq()
    
    USB hub started to use a workqueue instead of kthread. Let's make it clear from
    the function names.
    
    Signed-off-by: Petr Mladek <pmladek@suse.cz>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index d9d08720c386..b1b34d0557c9 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -48,7 +48,7 @@ static inline unsigned usb_get_max_power(struct usb_device *udev,
 	return c->desc.bMaxPower * mul;
 }
 
-extern void usb_kick_khubd(struct usb_device *dev);
+extern void usb_kick_hub_wq(struct usb_device *dev);
 extern int usb_match_one_id_intf(struct usb_device *dev,
 				 struct usb_host_interface *intf,
 				 const struct usb_device_id *id);

commit 7e73be227b1510a2ba1391185be7cc357e2226ef
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue May 20 18:09:31 2014 -0700

    usb: hub_handle_remote_wakeup() depends on CONFIG_PM_RUNTIME=y
    
    Per Alan:
    "You mean from within hub_handle_remote_wakeup()?  That routine will
    never get called if CONFIG_PM_RUNTIME isn't enabled, because khubd
    never sees wakeup requests if they arise during system suspend.
    
    In fact, that routine ought to go inside the "#ifdef CONFIG_PM_RUNTIME"
    portion of hub.c, along with the other suspend/resume code."
    
    Suggested-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 98dc08e13448..d9d08720c386 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -107,11 +107,6 @@ static inline int usb_autoresume_device(struct usb_device *udev)
 	return 0;
 }
 
-static inline int usb_remote_wakeup(struct usb_device *udev)
-{
-	return 0;
-}
-
 static inline int usb_set_usb2_hardware_lpm(struct usb_device *udev, int enable)
 {
 	return 0;

commit 3bfd659baec822f54e4acb0734669e671d853a35
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue May 20 18:08:40 2014 -0700

    usb: find internal hub tier mismatch via acpi
    
    ACPI identifies peer ports by setting their 'group_token' and
    'group_position' _PLD data to the same value.  If a platform has tier
    mismatch [1] , ACPI can override the default (USB3 defined) peer port
    association for internal hubs.  External hubs follow the default peer
    association scheme.
    
    Location data is cached as an opaque cookie in usb_port_location data.
    
    Note that we only consider the group_token and group_position attributes
    from the _PLD data as ACPI specifies that group_token is a unique
    identifier.
    
    When we find port location data for a port then we assume that the
    firmware will also describe its peer port.  This allows the
    implementation to only ever set the peer once.  This leads to a question
    about what happens when a pm runtime event occurs while the peer
    associations are still resolving.  Since we only ever set the peer
    information once, a USB3 port needs to be prevented from suspending
    while its ->peer pointer is NULL (implemented in a subsequent patch).
    
    There is always the possibility that firmware mis-identifies the ports,
    but there is not much the kernel can do in that case.
    
    [1]: xhci 1.1 appendix D figure 131
    [2]: acpi 5 section 6.1.8
    
    [alan]: don't do default peering when acpi data present
    Suggested-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 6afa738b5ba4..98dc08e13448 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -171,6 +171,12 @@ extern void usbfs_conn_disc_event(void);
 extern int usb_devio_init(void);
 extern void usb_devio_cleanup(void);
 
+/*
+ * Firmware specific cookie identifying a port's location. '0' == no location
+ * data available
+ */
+typedef u32 usb_port_location_t;
+
 /* internal notify stuff */
 extern void usb_notify_add_device(struct usb_device *udev);
 extern void usb_notify_remove_device(struct usb_device *udev);

commit d8521afe35862f4fbe3ccd6ca37897c0a304edf3
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue May 20 18:08:28 2014 -0700

    usb: assign default peer ports for root hubs
    
    Assume that the peer of a superspeed port is the port with the same id
    on the shared_hcd root hub.  This identification scheme is required of
    external hubs by the USB3 spec [1].  However, for root hubs, tier mismatch
    may be in effect [2].  Tier mismatch can only be enumerated via platform
    firmware.  For now, simply perform the nominal association.
    
    A new lock 'usb_port_peer_mutex' is introduced to synchronize port
    device add/remove with peer lookups.  It protects peering against
    changes to hcd->shared_hcd, hcd->self.root_hub, hdev->maxchild, and
    port_dev->child pointers.
    
    [1]: usb 3.1 section 10.3.3
    [2]: xhci 1.1 appendix D
    
    Cc: Alan Stern <stern@rowland.harvard.edu>
    [alan: usb_port_peer_mutex locking scheme]
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 69bfc253a7b8..6afa738b5ba4 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -119,6 +119,7 @@ static inline int usb_set_usb2_hardware_lpm(struct usb_device *udev, int enable)
 #endif
 
 extern struct bus_type usb_bus_type;
+extern struct mutex usb_port_peer_mutex;
 extern struct device_type usb_device_type;
 extern struct device_type usb_if_device_type;
 extern struct device_type usb_ep_device_type;

commit d99f6b41308779244662109a9c2bad09a82e8ac6
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue May 20 18:08:17 2014 -0700

    usb: rename usb_port device objects
    
    The current port name "portX" is ambiguous.  Before adding more port
    messages rename ports to "<hub-device-name>-portX"
    
    This is an ABI change, but the suspicion is that it will go unnoticed as
    the port power control implementation has been broken since its
    introduction.  If however, someone was relying on the old name we can
    add sysfs links from the old name to the new name.
    
    Additionally, it unifies/simplifies port dev_printk messages and modifies
    instances of:
            dev_XXX(hub->intfdev, ..."port %d"...
            dev_XXX(&hdev->dev, ..."port%d"...
    into:
            dev_XXX(&port_dev->dev, ...
    
    Now that the names are unique usb_port devices it would be nice if they
    could be included in /sys/bus/usb.  However, it turns out that this
    breaks 'lsusb -t'.  For now, create a dummy port driver so that print
    messages are prefixed "usb 1-1-port3" rather than the
    subsystem-ambiguous " 1-1-port3".
    
    Finally, it corrects an odd usage of sscanf("port%d") in usb-acpi.c.
    
    Suggested-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 75bf649da82d..69bfc253a7b8 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -175,10 +175,6 @@ extern void usb_notify_add_device(struct usb_device *udev);
 extern void usb_notify_remove_device(struct usb_device *udev);
 extern void usb_notify_add_bus(struct usb_bus *ubus);
 extern void usb_notify_remove_bus(struct usb_bus *ubus);
-extern enum usb_port_connect_type
-	usb_get_hub_port_connect_type(struct usb_device *hdev, int port1);
-extern void usb_set_hub_port_connect_type(struct usb_device *hdev, int port1,
-	enum usb_port_connect_type type);
 extern void usb_hub_adjust_deviceremovable(struct usb_device *hdev,
 		struct usb_hub_descriptor *desc);
 

commit 3e75c6de1ac33fe3500f44573d9212dc82c99f59
Merge: cb1595563880 940ab8f1ef93
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Apr 1 17:06:09 2014 -0700

    Merge tag 'usb-3.15-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/usb
    
    Pull USB patches from Greg KH:
     "Here's the big USB pull request for 3.15-rc1.
    
      The normal set of patches, lots of controller driver updates, and a
      smattering of individual USB driver updates as well.
    
      All have been in linux-next for a while"
    
    * tag 'usb-3.15-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/usb: (249 commits)
      xhci: Transition maintainership to Mathias Nyman.
      USB: disable reset-resume when USB_QUIRK_RESET is set
      USB: unbind all interfaces before rebinding any
      usb: phy: Add ulpi IDs for SMSC USB3320 and TI TUSB1210
      usb: gadget: tcm_usb_gadget: stop format strings
      usb: gadget: f_fs: add missing spinlock and mutex unlock
      usb: gadget: composite: switch over to ERR_CAST()
      usb: gadget: inode: switch over to memdup_user()
      usb: gadget: f_subset: switch over to PTR_RET
      usb: gadget: lpc32xx_udc: fix wrong clk_put() sequence
      USB: keyspan: remove dead debugging code
      USB: serial: add missing newlines to dev_<level> messages.
      USB: serial: add missing braces
      USB: serial: continue to write on errors
      USB: serial: continue to read on errors
      USB: serial: make bulk_out_size a lower limit
      USB: cypress_m8: fix potential scheduling while atomic
      devicetree: bindings: document lsi,zevio-usb
      usb: chipidea: add support for USB OTG controller on LSI Zevio SoCs
      usb: chipidea: imx: Use dev_name() for ci_hdrc name to distinguish USBs
      ...

commit 6aec044cc2f5670cf3b143c151c8be846499bd15
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Mar 12 11:30:38 2014 -0400

    USB: unbind all interfaces before rebinding any
    
    When a driver doesn't have pre_reset, post_reset, or reset_resume
    methods, the USB core unbinds that driver when its device undergoes a
    reset or a reset-resume, and then rebinds it afterward.
    
    The existing straightforward implementation can lead to problems,
    because each interface gets unbound and rebound before the next
    interface is handled.  If a driver claims additional interfaces, the
    claim may fail because the old binding instance may still own the
    additional interface when the new instance tries to claim it.
    
    This patch fixes the problem by first unbinding all the interfaces
    that are marked (i.e., their needs_binding flag is set) and then
    rebinding all of them.
    
    The patch also makes the helper functions in driver.c a little more
    uniform and adjusts some out-of-date comments.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Reported-and-tested-by: "Poulain, Loic" <loic.poulain@intel.com>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 823857767a16..0923add72b59 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -55,7 +55,7 @@ extern int usb_match_one_id_intf(struct usb_device *dev,
 extern int usb_match_device(struct usb_device *dev,
 			    const struct usb_device_id *id);
 extern void usb_forced_unbind_intf(struct usb_interface *intf);
-extern void usb_rebind_intf(struct usb_interface *intf);
+extern void usb_unbind_and_rebind_marked_interfaces(struct usb_device *udev);
 
 extern int usb_hub_claim_port(struct usb_device *hdev, unsigned port,
 		struct dev_state *owner);

commit 9b6f0c4b98171f2a354e1e461fefa90ec2baafa6
Author: Valentina Manea <valentina.manea.m@gmail.com>
Date:   Mon Mar 10 10:36:40 2014 +0200

    usbcore: rename struct dev_state to struct usb_dev_state
    
    Since it is needed outside usbcore and exposed in include/linux/usb.h,
    it conflicts with enum dev_state in rt2x00 wireless driver.
    
    Mark it as usb specific to avoid conflicts in the future.
    
    Signed-off-by: Valentina Manea <valentina.manea.m@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 222bbd2618f1..a87532845bf9 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -2,7 +2,7 @@
 #include <linux/acpi.h>
 
 struct usb_hub_descriptor;
-struct dev_state;
+struct usb_dev_state;
 
 /* Functions local to drivers/usb/core/ */
 
@@ -58,7 +58,7 @@ extern void usb_forced_unbind_intf(struct usb_interface *intf);
 extern void usb_rebind_intf(struct usb_interface *intf);
 
 extern void usb_hub_release_all_ports(struct usb_device *hdev,
-		struct dev_state *owner);
+		struct usb_dev_state *owner);
 extern bool usb_device_is_owned(struct usb_device *udev);
 
 extern int  usb_hub_init(void);

commit 6080cd0e9239469524d2aa07250ad4b9f383960d
Author: Valentina Manea <valentina.manea.m@gmail.com>
Date:   Sat Mar 8 14:53:34 2014 +0200

    staging: usbip: claim ports used by shared devices
    
    A device should not be able to be used concurrently both by
    the server and the client. Claiming the port used by the
    shared device ensures no interface drivers bind to it and
    that it is not usable from the server.
    
    Signed-off-by: Valentina Manea <valentina.manea.m@gmail.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 823857767a16..222bbd2618f1 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -57,10 +57,6 @@ extern int usb_match_device(struct usb_device *dev,
 extern void usb_forced_unbind_intf(struct usb_interface *intf);
 extern void usb_rebind_intf(struct usb_interface *intf);
 
-extern int usb_hub_claim_port(struct usb_device *hdev, unsigned port,
-		struct dev_state *owner);
-extern int usb_hub_release_port(struct usb_device *hdev, unsigned port,
-		struct dev_state *owner);
 extern void usb_hub_release_all_ports(struct usb_device *hdev,
 		struct dev_state *owner);
 extern bool usb_device_is_owned(struct usb_device *udev);

commit 140e3026a57ab7d830dab2f2c57796c222db0ea9
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Wed Jan 22 13:35:02 2014 -0800

    Revert "usbcore: set lpm_capable field for LPM capable root hubs"
    
    Commit 9df89d85b407690afa46ddfbccc80bec6869971d "usbcore: set
    lpm_capable field for LPM capable root hubs" was created under the
    assumption that all USB host controllers should have USB 3.0 Link PM
    enabled for all devices under the hosts.
    
    Unfortunately, that's not the case.  The xHCI driver relies on knowledge
    of the host hardware scheduler to calculate the LPM U1/U2 timeout
    values, and it only sets lpm_capable to one for Intel host controllers
    (that have the XHCI_LPM_SUPPORT quirk set).
    
    When LPM is enabled for some Fresco Logic hosts, it causes failures with
    a AgeStar 3UBT USB 3.0 hard drive dock:
    
    Jan 11 13:59:03 sg-laptop kernel: usb 3-1: new SuperSpeed USB device number 2 using xhci_hcd
    Jan 11 13:59:03 sg-laptop kernel: usb 3-1: Set SEL for device-initiated U1 failed.
    Jan 11 13:59:08 sg-laptop kernel: usb 3-1: Set SEL for device-initiated U2 failed.
    Jan 11 13:59:08 sg-laptop kernel: usb-storage 3-1:1.0: USB Mass Storage device detected
    Jan 11 13:59:08 sg-laptop mtp-probe[613]: checking bus 3, device 2: "/sys/devices/pci0000:00/0000:00:1c.3/0000:04:00.0/usb3/3-1"
    Jan 11 13:59:08 sg-laptop mtp-probe[613]: bus: 3, device: 2 was not an MTP device
    Jan 11 13:59:08 sg-laptop kernel: scsi6 : usb-storage 3-1:1.0
    Jan 11 13:59:13 sg-laptop kernel: usb 3-1: Set SEL for device-initiated U1 failed.
    Jan 11 13:59:18 sg-laptop kernel: usb 3-1: Set SEL for device-initiated U2 failed.
    Jan 11 13:59:18 sg-laptop kernel: usbcore: registered new interface driver usb-storage
    Jan 11 13:59:40 sg-laptop kernel: usb 3-1: reset SuperSpeed USB device number 2 using xhci_hcd
    Jan 11 13:59:41 sg-laptop kernel: usb 3-1: device descriptor read/8, error -71
    Jan 11 13:59:41 sg-laptop kernel: usb 3-1: reset SuperSpeed USB device number 2 using xhci_hcd
    Jan 11 13:59:46 sg-laptop kernel: usb 3-1: device descriptor read/8, error -110
    Jan 11 13:59:46 sg-laptop kernel: scsi 6:0:0:0: Device offlined - not ready after error recovery
    Jan 11 13:59:46 sg-laptop kernel: usb 3-1: USB disconnect, device number 2
    
    lspci for the affected host:
    
    04:00.0 0c03: 1b73:1000 (rev 04) (prog-if 30 [XHCI])
            Subsystem: 1043:1039
            Control: I/O+ Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR- FastB2B- DisINTx-
            Status: Cap+ 66MHz- UDF- FastB2B- ParErr- DEVSEL=fast >TAbort- <TAbort- <MAbort- >SERR- <PERR- INTx-
            Latency: 0, Cache Line Size: 64 bytes
            Interrupt: pin A routed to IRQ 19
            Region 0: Memory at dd200000 (32-bit, non-prefetchable) [size=64K]
            Capabilities: [50] Power Management version 3
                    Flags: PMEClk- DSI- D1- D2- AuxCurrent=0mA PME(D0+,D1-,D2-,D3hot+,D3cold-)
                    Status: D0 NoSoftRst- PME-Enable- DSel=0 DScale=0 PME-
            Capabilities: [68] MSI: Enable- Count=1/1 Maskable- 64bit+
                    Address: 0000000000000000  Data: 0000
            Capabilities: [80] Express (v1) Endpoint, MSI 00
                    DevCap: MaxPayload 128 bytes, PhantFunc 0, Latency L0s <2us, L1 <32us
                            ExtTag- AttnBtn- AttnInd- PwrInd- RBE+ FLReset-
                    DevCtl: Report errors: Correctable- Non-Fatal- Fatal- Unsupported-
                            RlxdOrd+ ExtTag- PhantFunc- AuxPwr- NoSnoop+
                            MaxPayload 128 bytes, MaxReadReq 512 bytes
                    DevSta: CorrErr- UncorrErr- FatalErr- UnsuppReq- AuxPwr- TransPend-
                    LnkCap: Port #0, Speed 2.5GT/s, Width x1, ASPM L0s L1, Latency L0 unlimited, L1 unlimited
                            ClockPM- Surprise- LLActRep- BwNot-
                    LnkCtl: ASPM Disabled; RCB 64 bytes Disabled- Retrain- CommClk+
                            ExtSynch- ClockPM- AutWidDis- BWInt- AutBWInt-
                    LnkSta: Speed 2.5GT/s, Width x1, TrErr- Train- SlotClk+ DLActive- BWMgmt- ABWMgmt-
            Kernel driver in use: xhci_hcd
            Kernel modules: xhci_hcd
    
    The commit was backported to stable kernels, and will need to be
    reverted there as well.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@intel.com>
    Reported-by: Sergey Galanov <sergey.e.galanov@gmail.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index c49383669cd8..823857767a16 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -35,7 +35,6 @@ extern int usb_get_device_descriptor(struct usb_device *dev,
 		unsigned int size);
 extern int usb_get_bos_descriptor(struct usb_device *dev);
 extern void usb_release_bos_descriptor(struct usb_device *dev);
-extern int usb_device_supports_lpm(struct usb_device *udev);
 extern char *usb_cache_string(struct usb_device *udev, int index);
 extern int usb_set_configuration(struct usb_device *dev, int configuration);
 extern int usb_choose_configuration(struct usb_device *udev);

commit 9df89d85b407690afa46ddfbccc80bec6869971d
Author: Xenia Ragiadakou <burzalodowa@gmail.com>
Date:   Sat Aug 31 18:09:12 2013 +0300

    usbcore: set lpm_capable field for LPM capable root hubs
    
    This patch sets the lpm_capable field for root hubs with LPM capabilities.
    
    Signed-off-by: Xenia Ragiadakou <burzalodowa@gmail.com>
    Reported-by: Martin MOKREJS <mmokrejs@gmail.com>
    Suggested-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 823857767a16..c49383669cd8 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -35,6 +35,7 @@ extern int usb_get_device_descriptor(struct usb_device *dev,
 		unsigned int size);
 extern int usb_get_bos_descriptor(struct usb_device *dev);
 extern void usb_release_bos_descriptor(struct usb_device *dev);
+extern int usb_device_supports_lpm(struct usb_device *udev);
 extern char *usb_cache_string(struct usb_device *udev, int index);
 extern int usb_set_configuration(struct usb_device *dev, int configuration);
 extern int usb_choose_configuration(struct usb_device *udev);

commit 84ebc10294a3d7be4c66f51070b7aedbaa24de9b
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Mar 27 16:14:46 2013 -0400

    USB: remove CONFIG_USB_SUSPEND option
    
    This patch (as1675) removes the CONFIG_USB_SUSPEND option, essentially
    replacing it everywhere with CONFIG_PM_RUNTIME (except for one place
    in hub.c, where it is replaced with CONFIG_PM because the code needs
    to be used in both runtime and system PM).  The net result is code
    shrinkage and simplification.
    
    There's very little point in keeping CONFIG_USB_SUSPEND because almost
    everybody enables it.  The few that don't will find that the usbcore
    module has gotten somewhat bigger and they will have to take active
    measures if they want to prevent hubs from being runtime suspended.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    CC: Peter Chen <peter.chen@freescale.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index a7f20bde0e5e..823857767a16 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -93,7 +93,7 @@ static inline int usb_port_resume(struct usb_device *udev, pm_message_t msg)
 
 #endif
 
-#ifdef CONFIG_USB_SUSPEND
+#ifdef CONFIG_PM_RUNTIME
 
 extern void usb_autosuspend_device(struct usb_device *udev);
 extern int usb_autoresume_device(struct usb_device *udev);

commit 3b2ab2b84c68fb92accbc735927bc8221e4de973
Author: Lan Tianyu <tianyu.lan@intel.com>
Date:   Tue Jan 29 00:59:06 2013 +0800

    Revert "usb: Register usb port's acpi power resources"
    
    This reverts commit 88bb965ed711e8a5984e70208ebc901a6ff4141f.
    
    The linux-next branch of linux-pm tree has replaced
    acpi_power_resource_(un)register_device() with new routines.
    Commit 88bb965 will cause conflict in the linux-next tree.
    So revert it and this will not affect other functions. Will
    send a new patch with new routines after 3.9 merge window.
    
    Signed-off-by: Lan Tianyu <tianyu.lan@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 601b044f90f0..a7f20bde0e5e 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -191,13 +191,7 @@ extern int usb_acpi_register(void);
 extern void usb_acpi_unregister(void);
 extern acpi_handle usb_get_hub_port_acpi_handle(struct usb_device *hdev,
 	int port1);
-extern int usb_acpi_register_power_resources(struct device *dev);
-extern void usb_acpi_unregister_power_resources(struct device *dev);
 #else
 static inline int usb_acpi_register(void) { return 0; };
 static inline void usb_acpi_unregister(void) { };
-static inline int usb_acpi_register_power_resources(struct device *dev)
-	{ return 0; };
-static inline void usb_acpi_unregister_power_resources(struct device *dev)
-	{ };
 #endif

commit 88bb965ed711e8a5984e70208ebc901a6ff4141f
Author: Lan Tianyu <tianyu.lan@intel.com>
Date:   Wed Jan 23 04:26:27 2013 +0800

    usb: Register usb port's acpi power resources
    
    This patch is to register usb port's acpi power resources. Create
    link between usb port device and its acpi power resource.
    
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Lan Tianyu <tianyu.lan@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index a7f20bde0e5e..601b044f90f0 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -191,7 +191,13 @@ extern int usb_acpi_register(void);
 extern void usb_acpi_unregister(void);
 extern acpi_handle usb_get_hub_port_acpi_handle(struct usb_device *hdev,
 	int port1);
+extern int usb_acpi_register_power_resources(struct device *dev);
+extern void usb_acpi_unregister_power_resources(struct device *dev);
 #else
 static inline int usb_acpi_register(void) { return 0; };
 static inline void usb_acpi_unregister(void) { };
+static inline int usb_acpi_register_power_resources(struct device *dev)
+	{ return 0; };
+static inline void usb_acpi_unregister_power_resources(struct device *dev)
+	{ };
 #endif

commit d2123fd9e1a56b8006986ed37e0aaf93ef0dd978
Author: Lan Tianyu <tianyu.lan@intel.com>
Date:   Mon Jan 21 22:18:00 2013 +0800

    USB: Set usb port's DeviceRemovable according acpi information
    
    ACPI provide "_PLD" and "_UPC" aml methods to describe usb port
    visibility and connectability. This patch is to add usb_hub_adjust_DeviceRemovable()
    to adjust usb hub port's DeviceRemovable according ACPI information and invoke it in
    the rh_call_control(). When hub descriptor request is issued at first time,
    usb port device isn't created and usb port is not bound with acpi. So first
    hub descriptor request is not changed based on ACPI information. After usb
    port devices being created, call usb_hub_adjust_DeviceRemovable in the hub_configure()
    and then set hub port's DeviceRemovable according ACPI information and this also works
    for non-root hub.
    
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Lan Tianyu <tianyu.lan@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index fb7d8fcb4551..a7f20bde0e5e 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -1,6 +1,7 @@
 #include <linux/pm.h>
 #include <linux/acpi.h>
 
+struct usb_hub_descriptor;
 struct dev_state;
 
 /* Functions local to drivers/usb/core/ */
@@ -182,6 +183,8 @@ extern enum usb_port_connect_type
 	usb_get_hub_port_connect_type(struct usb_device *hdev, int port1);
 extern void usb_set_hub_port_connect_type(struct usb_device *hdev, int port1,
 	enum usb_port_connect_type type);
+extern void usb_hub_adjust_deviceremovable(struct usb_device *hdev,
+		struct usb_hub_descriptor *desc);
 
 #ifdef CONFIG_ACPI
 extern int usb_acpi_register(void);

commit 8d8479db3dde3ef7a9bc803e565842764fa21a53
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Tue Dec 18 15:25:46 2012 +0100

    usb/core: consider link speed while looking at bMaxPower
    
    The USB 2.0 specification says that bMaxPower is the maximum power
    consumption expressed in 2 mA units and the USB 3.0 specification says
    that it is expressed in 8 mA units.
    This patch adds a helper function usb_get_max_power() which computes the
    value based on config & usb_device's speed value. The the device descriptor
    dump computes the value on its own.
    
    Cc: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 1c528c1bf0be..fb7d8fcb4551 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -38,6 +38,15 @@ extern char *usb_cache_string(struct usb_device *udev, int index);
 extern int usb_set_configuration(struct usb_device *dev, int configuration);
 extern int usb_choose_configuration(struct usb_device *udev);
 
+static inline unsigned usb_get_max_power(struct usb_device *udev,
+		struct usb_host_config *c)
+{
+	/* SuperSpeed power is in 8 mA units; others are in 2 mA units */
+	unsigned mul = (udev->speed == USB_SPEED_SUPER ? 8 : 2);
+
+	return c->desc.bMaxPower * mul;
+}
+
 extern void usb_kick_khubd(struct usb_device *dev);
 extern int usb_match_one_id_intf(struct usb_device *dev,
 				 struct usb_host_interface *intf,

commit 05f916894a692f0cc0973aef21521133623b21c0
Author: Lan Tianyu <tianyu.lan@intel.com>
Date:   Wed Sep 5 13:44:34 2012 +0800

    usb/acpi: Store info on device removability.
    
    In the upcoming USB port power off patches, we need to know whether a
    USB port can ever see a disconnect event.  Often USB ports are internal
    to a system, and users can't disconnect USB devices from that port.
    Sometimes those ports will remain empty, because the OEM chose not to
    connect an internal USB device to that port.
    
    According to ACPI Spec 9.13, PLD indicates whether USB port is
    user visible and _UPC indicates whether a USB device can be connected to
    the USB port (we'll call this "connectible").  Here's a matrix of the
    possible combinations:
    
    Visible Connectible
                    Name            Example
    -------------------------------------------------------------------------
    
    Yes     No      Unknown         (Invalid state.)
    
    Yes     Yes     Hot-plug        USB ports on the outside of a laptop.
                                    A user could freely connect and disconnect
                                    USB devices.
    
    No      Yes     Hard-wired      A USB modem hard-wired to a port on the
                                    inside of a laptop.
    
    No      No      Not used        The port is internal to the system and
                                    will remain empty.
    
    Represent each of these four states with an enum usb_port_connect_type.
    The four states are USB_PORT_CONNECT_TYPE_UNKNOWN,
    USB_PORT_CONNECT_TYPE_HOT_PLUG, USB_PORT_CONNECT_TYPE_HARD_WIRED, and
    USB_PORT_NOT_USED.  When we get the USB port's acpi_handle, store the
    state in connect_type in struct usb_port.
    
    Signed-off-by: Lan Tianyu <tianyu.lan@intel.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 1633f6e99e35..1c528c1bf0be 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -169,6 +169,10 @@ extern void usb_notify_add_device(struct usb_device *udev);
 extern void usb_notify_remove_device(struct usb_device *udev);
 extern void usb_notify_add_bus(struct usb_bus *ubus);
 extern void usb_notify_remove_bus(struct usb_bus *ubus);
+extern enum usb_port_connect_type
+	usb_get_hub_port_connect_type(struct usb_device *hdev, int port1);
+extern void usb_set_hub_port_connect_type(struct usb_device *hdev, int port1,
+	enum usb_port_connect_type type);
 
 #ifdef CONFIG_ACPI
 extern int usb_acpi_register(void);

commit d557542421da643358201664903e67fd01dfca1a
Author: Lan Tianyu <tianyu.lan@intel.com>
Date:   Wed Sep 5 13:44:33 2012 +0800

    usb/acpi: Bind ACPI node to USB port, not usb_device.
    
    In the ACPI DSDT table, only usb root hub and usb ports are ACPI device
    nodes.  Originally, we bound the usb port's ACPI node to the usb device
    attached to the port.  However, we want to access those ACPI port
    methods when the port is empty, and there's no usb_device associated
    with that port.
    
    Now that the usb port is a real device, we can bind the port's ACPI node
    to struct usb_port instead.
    
    Signed-off-by: Lan Tianyu <tianyu.lan@intel.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index acb103c5c391..1633f6e99e35 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -1,4 +1,5 @@
 #include <linux/pm.h>
+#include <linux/acpi.h>
 
 struct dev_state;
 
@@ -115,6 +116,7 @@ extern struct bus_type usb_bus_type;
 extern struct device_type usb_device_type;
 extern struct device_type usb_if_device_type;
 extern struct device_type usb_ep_device_type;
+extern struct device_type usb_port_device_type;
 extern struct usb_device_driver usb_generic_driver;
 
 static inline int is_usb_device(const struct device *dev)
@@ -132,6 +134,11 @@ static inline int is_usb_endpoint(const struct device *dev)
 	return dev->type == &usb_ep_device_type;
 }
 
+static inline int is_usb_port(const struct device *dev)
+{
+	return dev->type == &usb_port_device_type;
+}
+
 /* Do the same for device drivers and interface drivers. */
 
 static inline int is_usb_device_driver(struct device_driver *drv)
@@ -166,6 +173,8 @@ extern void usb_notify_remove_bus(struct usb_bus *ubus);
 #ifdef CONFIG_ACPI
 extern int usb_acpi_register(void);
 extern void usb_acpi_unregister(void);
+extern acpi_handle usb_get_hub_port_acpi_handle(struct usb_device *hdev,
+	int port1);
 #else
 static inline int usb_acpi_register(void) { return 0; };
 static inline void usb_acpi_unregister(void) { };

commit 80da2e0df5af700518611b7d1cc4fc9945bcaf95
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Thu Jul 19 12:39:13 2012 +0200

    usb: Add quirk detection based on interface information
    
    When a whole class of devices (possibly from a specific vendor, or
    across multiple vendors) require a quirk, explictly listing all devices
    in the class make the quirks table unnecessarily large. Fix this by
    allowing matching devices based on interface information.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 67875a89cfa1..acb103c5c391 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -26,6 +26,7 @@ extern void usb_disable_device(struct usb_device *dev, int skip_ep0);
 extern int usb_deauthorize_device(struct usb_device *);
 extern int usb_authorize_device(struct usb_device *);
 extern void usb_detect_quirks(struct usb_device *udev);
+extern void usb_detect_interface_quirks(struct usb_device *udev);
 extern int usb_remove_device(struct usb_device *udev);
 
 extern int usb_get_device_descriptor(struct usb_device *dev,
@@ -37,6 +38,9 @@ extern int usb_set_configuration(struct usb_device *dev, int configuration);
 extern int usb_choose_configuration(struct usb_device *udev);
 
 extern void usb_kick_khubd(struct usb_device *dev);
+extern int usb_match_one_id_intf(struct usb_device *dev,
+				 struct usb_host_interface *intf,
+				 const struct usb_device_id *id);
 extern int usb_match_device(struct usb_device *dev,
 			    const struct usb_device_id *id);
 extern void usb_forced_unbind_intf(struct usb_interface *intf);

commit 336c5c310e8f0d5baba7973765339eaf5d989fe1
Author: Lan Tianyu <tianyu.lan@intel.com>
Date:   Fri Jul 6 14:13:52 2012 +0800

    usb: convert port_owners type from void * to struct dev_state *
    
    This patch is to convert port_owners type from void * to struct dev_state *
    in order to make code more readable.
    
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Lan Tianyu <tianyu.lan@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 5c5c538ea73d..67875a89cfa1 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -1,5 +1,7 @@
 #include <linux/pm.h>
 
+struct dev_state;
+
 /* Functions local to drivers/usb/core/ */
 
 extern int usb_create_sysfs_dev_files(struct usb_device *dev);
@@ -41,10 +43,11 @@ extern void usb_forced_unbind_intf(struct usb_interface *intf);
 extern void usb_rebind_intf(struct usb_interface *intf);
 
 extern int usb_hub_claim_port(struct usb_device *hdev, unsigned port,
-		void *owner);
+		struct dev_state *owner);
 extern int usb_hub_release_port(struct usb_device *hdev, unsigned port,
-		void *owner);
-extern void usb_hub_release_all_ports(struct usb_device *hdev, void *owner);
+		struct dev_state *owner);
+extern void usb_hub_release_all_ports(struct usb_device *hdev,
+		struct dev_state *owner);
 extern bool usb_device_is_owned(struct usb_device *udev);
 
 extern int  usb_hub_init(void);

commit da0af6e78ef311d97754aa03e10eade82cc99e16
Author: Matthew Garrett <mjg@redhat.com>
Date:   Fri May 11 16:08:27 2012 +0800

    usb: Bind devices to ACPI devices when possible
    
    Built-in USB devices will typically have a representation in the system
    ACPI tables. Add support for binding the two together so the USB code can
    make use of the associated methods.
    
    Signed-off-by: Matthew Garrett <mjg@redhat.com>
    Signed-off-by: Lan Tianyu <tianyu.lan@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 71648dcbe438..5c5c538ea73d 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -156,3 +156,10 @@ extern void usb_notify_remove_device(struct usb_device *udev);
 extern void usb_notify_add_bus(struct usb_bus *ubus);
 extern void usb_notify_remove_bus(struct usb_bus *ubus);
 
+#ifdef CONFIG_ACPI
+extern int usb_acpi_register(void);
+extern void usb_acpi_unregister(void);
+#else
+static inline int usb_acpi_register(void) { return 0; };
+static inline void usb_acpi_unregister(void) { };
+#endif

commit 98d9a82e5f753a2483d7b4638802d60e94e5d2e4
Author: Oliver Neukum <oliver@neukum.org>
Date:   Wed Jan 11 08:38:35 2012 +0100

    USB: cleanup the handling of the PM complete call
    
    This eliminates the last instance of a function's behavior
    controlled by a parameter as Linus hates such things.
    
    Signed-off-by: Oliver Neukum <oneukum@suse.de>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 45e8479c377d..71648dcbe438 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -56,6 +56,7 @@ extern void usb_major_cleanup(void);
 
 extern int usb_suspend(struct device *dev, pm_message_t msg);
 extern int usb_resume(struct device *dev, pm_message_t msg);
+extern int usb_resume_complete(struct device *dev);
 
 extern int usb_port_suspend(struct usb_device *dev, pm_message_t msg);
 extern int usb_port_resume(struct usb_device *dev, pm_message_t msg);

commit 2c4d6bf295ae10ffcd84f0df6cb642598eb66603
Author: Johan Hovold <jhovold@gmail.com>
Date:   Thu Nov 10 14:58:26 2011 +0100

    USB: move usb_translate_errors to linux/usb.h
    
    Move usb_translate_errors from usb core to linux/usb.h as it is meant to
    be accessed from drivers.
    
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 3888778582c4..45e8479c377d 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -132,20 +132,6 @@ static inline int is_usb_device_driver(struct device_driver *drv)
 			for_devices;
 }
 
-/* translate USB error codes to codes user space understands */
-static inline int usb_translate_errors(int error_code)
-{
-	switch (error_code) {
-	case 0:
-	case -ENOMEM:
-	case -ENODEV:
-		return error_code;
-	default:
-		return -EIO;
-	}
-}
-
-
 /* for labeling diagnostics */
 extern const char *usbcore_name;
 

commit 65580b4321eb36f16ae8b5987bfa1bb948fc5112
Author: Andiry Xu <andiry.xu@amd.com>
Date:   Fri Sep 23 14:19:52 2011 -0700

    xHCI: set USB2 hardware LPM
    
    If the device pass the USB2 software LPM and the host supports hardware
    LPM, enable hardware LPM for the device to let the host decide when to
    put the link into lower power state.
    
    If hardware LPM is enabled for a port and driver wants to put it into
    suspend, it must first disable hardware LPM, resume the port into U0,
    and then suspend the port.
    
    Signed-off-by: Andiry Xu <andiry.xu@amd.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 0d023cd2c149..3888778582c4 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -82,6 +82,7 @@ extern int usb_remote_wakeup(struct usb_device *dev);
 extern int usb_runtime_suspend(struct device *dev);
 extern int usb_runtime_resume(struct device *dev);
 extern int usb_runtime_idle(struct device *dev);
+extern int usb_set_usb2_hardware_lpm(struct usb_device *udev, int enable);
 
 #else
 
@@ -96,6 +97,10 @@ static inline int usb_remote_wakeup(struct usb_device *udev)
 	return 0;
 }
 
+static inline int usb_set_usb2_hardware_lpm(struct usb_device *udev, int enable)
+{
+	return 0;
+}
 #endif
 
 extern struct bus_type usb_bus_type;

commit 3148bf041d169a083aa31bd69bedd5bfb7ffe215
Author: Andiry Xu <andiry.xu@amd.com>
Date:   Fri Sep 23 14:19:47 2011 -0700

    usbcore: get BOS descriptor set
    
    This commit gets BOS(Binary Device Object Store) descriptor set for Super
    Speed devices and High Speed devices which support BOS descriptor.
    
    BOS descriptor is used to report additional USB device-level capabilities
    that are not reported via the Device descriptor. By getting BOS descriptor
    set, driver can check device's device-level capability such as LPM
    capability.
    
    Signed-off-by: Andiry Xu <andiry.xu@amd.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index d44d4b7bbf17..0d023cd2c149 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -28,6 +28,8 @@ extern int usb_remove_device(struct usb_device *udev);
 
 extern int usb_get_device_descriptor(struct usb_device *dev,
 		unsigned int size);
+extern int usb_get_bos_descriptor(struct usb_device *dev);
+extern void usb_release_bos_descriptor(struct usb_device *dev);
 extern char *usb_cache_string(struct usb_device *udev, int index);
 extern int usb_set_configuration(struct usb_device *dev, int configuration);
 extern int usb_choose_configuration(struct usb_device *udev);

commit 643de6240b0b59c420ad71dfeeb3125a3607af92
Author: Michal Nazarewicz <mina86@mina86.com>
Date:   Thu Apr 14 17:47:09 2011 +0200

    usb: core: Change usb_create_sysfs_intf_files()' return type to void
    
    The usb_create_sysfs_intf_files() function always returned zero even
    if it failed to create sysfs fails.  Since this is a desired behaviour
    there is no need to return return code at all.  This commit changes
    function's return type (form int) to void.
    
    Signed-off-by: Michal Nazarewicz <mina86@mina86.com>
    Cc: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index d450b742137e..d44d4b7bbf17 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -4,7 +4,7 @@
 
 extern int usb_create_sysfs_dev_files(struct usb_device *dev);
 extern void usb_remove_sysfs_dev_files(struct usb_device *dev);
-extern int usb_create_sysfs_intf_files(struct usb_interface *intf);
+extern void usb_create_sysfs_intf_files(struct usb_interface *intf);
 extern void usb_remove_sysfs_intf_files(struct usb_interface *intf);
 extern int usb_create_ep_devs(struct device *parent,
 				struct usb_host_endpoint *endpoint,

commit e1620d591a75a10b15cf61dbf8243a0b7e6731a2
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Fri Mar 18 19:55:36 2011 +0100

    USB: Move runtime PM callbacks to usb_device_pm_ops
    
    USB defines usb_device_type pointing to usb_device_pm_ops that
    provides system-wide PM callbacks only and usb_bus_type pointing to
    usb_bus_pm_ops that provides runtime PM callbacks only.  However,
    the USB runtime PM callbacks may be defined in usb_device_pm_ops
    which makes it possible to drop usb_bus_pm_ops and will allow us
    to consolidate the handling of subsystems by the PM core code.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index a9cf484ecae4..d450b742137e 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -77,6 +77,9 @@ static inline int usb_port_resume(struct usb_device *udev, pm_message_t msg)
 extern void usb_autosuspend_device(struct usb_device *udev);
 extern int usb_autoresume_device(struct usb_device *udev);
 extern int usb_remote_wakeup(struct usb_device *dev);
+extern int usb_runtime_suspend(struct device *dev);
+extern int usb_runtime_resume(struct device *dev);
+extern int usb_runtime_idle(struct device *dev);
 
 #else
 

commit 60678b60d78cd268a3aed3044dfbbb85760b2c54
Author: Oliver Neukum <oliver@neukum.org>
Date:   Sun Dec 19 21:54:48 2010 +0100

    USB: add helper to convert USB error codes
    
    This converts error codes specific to USB to generic error codes
    that can be returned to user space. Tests showed that it is so small
    that it is better inlined.
    
    Signed-off-by: Oliver Neukum <oneukum@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index b975450f403e..a9cf484ecae4 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -122,6 +122,19 @@ static inline int is_usb_device_driver(struct device_driver *drv)
 			for_devices;
 }
 
+/* translate USB error codes to codes user space understands */
+static inline int usb_translate_errors(int error_code)
+{
+	switch (error_code) {
+	case 0:
+	case -ENOMEM:
+	case -ENODEV:
+		return error_code;
+	default:
+		return -EIO;
+	}
+}
+
 
 /* for labeling diagnostics */
 extern const char *usbcore_name;

commit fcc4a01eb8661226e80632327673f67bf6a5840b
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Nov 15 15:57:51 2010 -0500

    USB: use the runtime-PM autosuspend implementation
    
    This patch (as1428) converts USB over to the new runtime-PM core
    autosuspend framework.  One slightly awkward aspect of the conversion
    is that USB devices will now have two suspend-delay attributes: the
    old power/autosuspend file and the new power/autosuspend_delay_ms
    file.  One expresses the delay time in seconds and the other in
    milliseconds, but otherwise they do the same thing.  The old attribute
    can be deprecated and then removed eventually.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index cd882203ad34..b975450f403e 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -75,14 +75,12 @@ static inline int usb_port_resume(struct usb_device *udev, pm_message_t msg)
 #ifdef CONFIG_USB_SUSPEND
 
 extern void usb_autosuspend_device(struct usb_device *udev);
-extern void usb_try_autosuspend_device(struct usb_device *udev);
 extern int usb_autoresume_device(struct usb_device *udev);
 extern int usb_remote_wakeup(struct usb_device *dev);
 
 #else
 
 #define usb_autosuspend_device(udev)		do {} while (0)
-#define usb_try_autosuspend_device(udev)	do {} while (0)
 static inline int usb_autoresume_device(struct usb_device *udev)
 {
 	return 0;

commit 9bbdf1e0afe771ca7650f9f476769310bee9d8f3
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Jan 8 12:57:28 2010 -0500

    USB: convert to the runtime PM framework
    
    This patch (as1329) converts the USB stack over to the PM core's
    runtime PM framework.  This involves numerous changes throughout
    usbcore, especially to hub.c and driver.c.  Perhaps the most notable
    change is that CONFIG_USB_SUSPEND now depends on CONFIG_PM_RUNTIME
    instead of CONFIG_PM.
    
    Several fields in the usb_device and usb_interface structures are no
    longer needed.  Some code which used to depend on CONFIG_USB_PM now
    depends on CONFIG_USB_SUSPEND (requiring some rearrangement of header
    files).
    
    The only visible change in behavior should be that following a system
    sleep (resume from RAM or resume from hibernation), autosuspended USB
    devices will be resumed just like everything else.  They won't remain
    suspended.  But if they aren't in use then they will naturally
    autosuspend again in a few seconds.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 2b74a7f99c41..cd882203ad34 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -55,25 +55,8 @@ extern void usb_major_cleanup(void);
 extern int usb_suspend(struct device *dev, pm_message_t msg);
 extern int usb_resume(struct device *dev, pm_message_t msg);
 
-extern void usb_autosuspend_work(struct work_struct *work);
-extern void usb_autoresume_work(struct work_struct *work);
 extern int usb_port_suspend(struct usb_device *dev, pm_message_t msg);
 extern int usb_port_resume(struct usb_device *dev, pm_message_t msg);
-extern int usb_external_suspend_device(struct usb_device *udev,
-		pm_message_t msg);
-extern int usb_external_resume_device(struct usb_device *udev,
-		pm_message_t msg);
-extern int usb_remote_wakeup(struct usb_device *dev);
-
-static inline void usb_pm_lock(struct usb_device *udev)
-{
-	mutex_lock_nested(&udev->pm_mutex, udev->level);
-}
-
-static inline void usb_pm_unlock(struct usb_device *udev)
-{
-	mutex_unlock(&udev->pm_mutex);
-}
 
 #else
 
@@ -87,14 +70,6 @@ static inline int usb_port_resume(struct usb_device *udev, pm_message_t msg)
 	return 0;
 }
 
-static inline int usb_remote_wakeup(struct usb_device *udev)
-{
-	return 0;
-}
-
-static inline void usb_pm_lock(struct usb_device *udev) {}
-static inline void usb_pm_unlock(struct usb_device *udev) {}
-
 #endif
 
 #ifdef CONFIG_USB_SUSPEND
@@ -102,6 +77,7 @@ static inline void usb_pm_unlock(struct usb_device *udev) {}
 extern void usb_autosuspend_device(struct usb_device *udev);
 extern void usb_try_autosuspend_device(struct usb_device *udev);
 extern int usb_autoresume_device(struct usb_device *udev);
+extern int usb_remote_wakeup(struct usb_device *dev);
 
 #else
 
@@ -112,9 +88,13 @@ static inline int usb_autoresume_device(struct usb_device *udev)
 	return 0;
 }
 
+static inline int usb_remote_wakeup(struct usb_device *udev)
+{
+	return 0;
+}
+
 #endif
 
-extern struct workqueue_struct *ksuspend_usb_wq;
 extern struct bus_type usb_bus_type;
 extern struct device_type usb_device_type;
 extern struct device_type usb_if_device_type;
@@ -144,23 +124,6 @@ static inline int is_usb_device_driver(struct device_driver *drv)
 			for_devices;
 }
 
-/* Interfaces and their "power state" are owned by usbcore */
-
-static inline void mark_active(struct usb_interface *f)
-{
-	f->is_active = 1;
-}
-
-static inline void mark_quiesced(struct usb_interface *f)
-{
-	f->is_active = 0;
-}
-
-static inline int is_active(const struct usb_interface *f)
-{
-	return f->is_active;
-}
-
 
 /* for labeling diagnostics */
 extern const char *usbcore_name;

commit 0534d46848990e8eed7cd0832d745d813e827261
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Jan 8 12:56:30 2010 -0500

    USB: consolidate remote wakeup routines
    
    This patch (as1324) makes a small change to the code used for remote
    wakeup of root hubs.  hcd_resume_work() now calls the hub driver's
    remote-wakeup routine instead of implementing its own version.
    
    The patch is complicated by the need to rename remote_wakeup() to
    usb_remote_wakeup(), make it non-static, and declare it in a header
    file.  There's also the additional complication required to make
    everything work when CONFIG_PM isn't set; the do-nothing inline
    routine had to be moved into the header file.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 4c36c7f512a0..2b74a7f99c41 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -63,6 +63,7 @@ extern int usb_external_suspend_device(struct usb_device *udev,
 		pm_message_t msg);
 extern int usb_external_resume_device(struct usb_device *udev,
 		pm_message_t msg);
+extern int usb_remote_wakeup(struct usb_device *dev);
 
 static inline void usb_pm_lock(struct usb_device *udev)
 {
@@ -86,6 +87,11 @@ static inline int usb_port_resume(struct usb_device *udev, pm_message_t msg)
 	return 0;
 }
 
+static inline int usb_remote_wakeup(struct usb_device *udev)
+{
+	return 0;
+}
+
 static inline void usb_pm_lock(struct usb_device *udev) {}
 static inline void usb_pm_unlock(struct usb_device *udev) {}
 

commit 253e05724f9230910344357b1142ad8642ff9f5a
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Oct 27 15:20:13 2009 -0400

    USB: add a "remove hardware" sysfs attribute
    
    This patch (as1297) adds a "remove" attribute to each USB device's
    directory in sysfs.  Writing to this attribute causes the device to be
    deconfigured (the same as writing 0 to the "bConfigurationValue"
    attribute) and then tells the hub driver to disable the device's
    upstream port.  The device remains locked during these activities so
    there is no possibility of it getting reconfigured in between.  The
    port will remain disabled until after the device is unplugged.
    
    The purpose of this is to provide a means for user programs to imitate
    the "Safely remove hardware" applet in Windows.  Some devices do
    expect their ports to be disabled before they are unplugged, and they
    provide visual feedback to users indicating when they can safely be
    unplugged.
    
    The security implications are minimal.  Writing to the "remove"
    attribute is no more dangerous than writing to the
    "bConfigurationValue" attribute.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Cc: David Zeuthen <davidz@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 9a8b15e6377a..4c36c7f512a0 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -24,6 +24,7 @@ extern void usb_disable_device(struct usb_device *dev, int skip_ep0);
 extern int usb_deauthorize_device(struct usb_device *);
 extern int usb_authorize_device(struct usb_device *);
 extern void usb_detect_quirks(struct usb_device *udev);
+extern int usb_remove_device(struct usb_device *udev);
 
 extern int usb_get_device_descriptor(struct usb_device *dev,
 		unsigned int size);

commit 7cbe5dca399a50ce8aa74314b1d276e2fb904e1b
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Jun 29 10:56:54 2009 -0400

    USB: add API for userspace drivers to "claim" ports
    
    This patch (as1258) implements a feature that users have been asking
    for: It gives programs the ability to "claim" a port on a hub, via a
    new usbfs ioctl.  A device plugged into a "claimed" port will not be
    touched by the kernel beyond the immediate necessities of
    initialization and enumeration.
    
    In particular, when a device is plugged into a "claimed" port, the
    kernel will not select and install a configuration.  And when a config
    is installed by usbfs or sysfs, the kernel will not probe any drivers
    for any of the interfaces.  (However the kernel will fetch various
    string descriptors during enumeration.  One could argue that this
    isn't really necessary, but the strings are exported in sysfs.)
    
    The patch does not guarantee exclusive access to these devices; it is
    still possible for more than one program to open the device file
    concurrently.  Programs are responsible for coordinating access among
    themselves.
    
    A demonstration program showing how to use the new interface can be
    found in an attachment to
    
            http://marc.info/?l=linux-usb&m=124345857431452&w=2
    
    The patch also makes a small simplification to the hub driver,
    replacing a bunch of more-or-less useless variants of "out of memory"
    with a single message.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index c0e0ae2bb8e7..9a8b15e6377a 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -37,6 +37,13 @@ extern int usb_match_device(struct usb_device *dev,
 extern void usb_forced_unbind_intf(struct usb_interface *intf);
 extern void usb_rebind_intf(struct usb_interface *intf);
 
+extern int usb_hub_claim_port(struct usb_device *hdev, unsigned port,
+		void *owner);
+extern int usb_hub_release_port(struct usb_device *hdev, unsigned port,
+		void *owner);
+extern void usb_hub_release_all_ports(struct usb_device *hdev, void *owner);
+extern bool usb_device_is_owned(struct usb_device *udev);
+
 extern int  usb_hub_init(void);
 extern void usb_hub_cleanup(void);
 extern int usb_major_init(void);

commit a4dbd6740df0872cdf0a86841f75beec8381964d
Author: David Brownell <dbrownell@users.sourceforge.net>
Date:   Wed Jun 24 10:06:31 2009 -0700

    driver model: constify attribute groups
    
    Let attribute group vectors be declared "const".  We'd
    like to let most attribute metadata live in read-only
    sections... this is a start.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index e2a8cfaade1d..c0e0ae2bb8e7 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -152,8 +152,8 @@ static inline int is_active(const struct usb_interface *f)
 extern const char *usbcore_name;
 
 /* sysfs stuff */
-extern struct attribute_group *usb_device_groups[];
-extern struct attribute_group *usb_interface_groups[];
+extern const struct attribute_group *usb_device_groups[];
+extern const struct attribute_group *usb_interface_groups[];
 
 /* usbfs stuff */
 extern struct mutex usbfs_mutex;

commit 5512966643adb17483efc5f61481a38fc33088bb
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Mon May 4 19:48:32 2009 +0200

    usb: convert endpoint devices to bus-less childs of the usb interface
    
    The endpoint devices look like simple attribute groups now, and no longer
    like devices with a specific subsystem. They will also no longer emit uevents.
    
    It also removes the device node requests for endpoint devices, which are not
    implemented for now.
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index dabf9255a10e..e2a8cfaade1d 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -104,6 +104,7 @@ extern struct workqueue_struct *ksuspend_usb_wq;
 extern struct bus_type usb_bus_type;
 extern struct device_type usb_device_type;
 extern struct device_type usb_if_device_type;
+extern struct device_type usb_ep_device_type;
 extern struct usb_device_driver usb_generic_driver;
 
 static inline int is_usb_device(const struct device *dev)
@@ -111,6 +112,16 @@ static inline int is_usb_device(const struct device *dev)
 	return dev->type == &usb_device_type;
 }
 
+static inline int is_usb_interface(const struct device *dev)
+{
+	return dev->type == &usb_if_device_type;
+}
+
+static inline int is_usb_endpoint(const struct device *dev)
+{
+	return dev->type == &usb_ep_device_type;
+}
+
 /* Do the same for device drivers and interface drivers. */
 
 static inline int is_usb_device_driver(struct device_driver *drv)

commit 820d7a253c5e59a786d5b608f6e8d0419fdc2f6e
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Apr 27 13:17:21 2009 -0700

    USB: remove unused usb_host class
    
    The usb_host class isn't used for anything anymore (it was used for
    debug files, but they have moved to debugfs a few kernel releases ago),
    so let's delete it before someone accidentally puts a file in it.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 79d8a9ea559b..dabf9255a10e 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -41,8 +41,6 @@ extern int  usb_hub_init(void);
 extern void usb_hub_cleanup(void);
 extern int usb_major_init(void);
 extern void usb_major_cleanup(void);
-extern int usb_host_init(void);
-extern void usb_host_cleanup(void);
 
 #ifdef	CONFIG_PM
 

commit 501950d846218ed80a776d2aae5aed9c8b92e778
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Jan 13 11:33:42 2009 -0500

    USB: fix char-device disconnect handling
    
    This patch (as1198) fixes a conceptual bug: Somewhere along the line
    we managed to confuse USB class devices with USB char devices.  As a
    result, the code to send a disconnect signal to userspace would not be
    built if both CONFIG_USB_DEVICE_CLASS and CONFIG_USB_DEVICEFS were
    disabled.
    
    The usb_fs_classdev_common_remove() routine has been renamed to
    usbdev_remove() and it is now called whenever any USB device is
    removed, not just when a class device is unregistered.  The notifier
    registration and unregistration calls are no longer conditionally
    compiled.  And since the common removal code will always be called as
    part of the char device interface, there's no need to call it again as
    part of the usbfs interface; thus the invocation of
    usb_fs_classdev_common_remove() has been taken out of
    usbfs_remove_device().
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Reported-by: Alon Bar-Lev <alon.barlev@gmail.com>
    Tested-by: Alon Bar-Lev <alon.barlev@gmail.com>
    Cc: stable <stable@kernel.org>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 9d0f33fe8719..79d8a9ea559b 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -152,7 +152,6 @@ extern struct usb_driver usbfs_driver;
 extern const struct file_operations usbfs_devices_fops;
 extern const struct file_operations usbdev_file_operations;
 extern void usbfs_conn_disc_event(void);
-extern void usb_fs_classdev_common_remove(struct usb_device *udev);
 
 extern int usb_devio_init(void);
 extern void usb_devio_cleanup(void);

commit ddeac4e75f2527a340f9dc655bde49bb2429b39b
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Thu Jan 15 17:03:33 2009 -0500

    USB: fix toggle mismatch in disable_endpoint paths
    
    This patch (as1200) finishes some fixes that were left incomplete by
    an earlier patch.
    
    Although nobody has addressed this issue in the past, it turns out
    that we need to distinguish between two different modes of disabling
    and enabling endpoints.  In one mode only the data structures in
    usbcore are affected, and in the other mode the host controller and
    device hardware states are affected as well.
    
    The earlier patch added an extra argument to the routines in the
    enable_endpoint pathways to reflect this difference.  This patch adds
    corresponding arguments to the disable_endpoint pathways.  Without
    this change, the endpoint toggle state can get out of sync between
    the host and the device.  The exact mechanism depends on the details
    of the host controller (whether or not it stores its own copy of the
    toggle values).
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Reported-by: Dan Streetman <ddstreet@ieee.org>
    Tested-by: Dan Streetman <ddstreet@ieee.org>
    Cc: stable <stable@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 386177867a8a..9d0f33fe8719 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -15,9 +15,10 @@ extern void usb_enable_endpoint(struct usb_device *dev,
 		struct usb_host_endpoint *ep, bool reset_toggle);
 extern void usb_enable_interface(struct usb_device *dev,
 		struct usb_interface *intf, bool reset_toggles);
-extern void usb_disable_endpoint(struct usb_device *dev, unsigned int epaddr);
+extern void usb_disable_endpoint(struct usb_device *dev, unsigned int epaddr,
+		bool reset_hardware);
 extern void usb_disable_interface(struct usb_device *dev,
-		struct usb_interface *intf);
+		struct usb_interface *intf, bool reset_hardware);
 extern void usb_release_interface_cache(struct kref *ref);
 extern void usb_disable_device(struct usb_device *dev, int skip_ep0);
 extern int usb_deauthorize_device(struct usb_device *);

commit 2caf7fcdb8532045680f06b67b9e63f0c9613aaa
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Dec 31 11:31:33 2008 -0500

    USB: re-enable interface after driver unbinds
    
    This patch (as1197) fixes an error introduced recently.  Since a
    significant number of devices can't handle Set-Interface requests, we
    no longer call usb_set_interface() when a driver unbinds from an
    interface, provided the interface is already in altsetting 0.  However
    the interface still does get disabled, and the call to
    usb_set_interface() was the only thing re-enabling it.  Since the
    interface doesn't get re-enabled, further attempts to use it fail.
    
    So the patch adds a call to usb_enable_interface() when a driver
    unbinds and the interface is in altsetting 0.  For this to work
    right, the interface's endpoints have to be re-enabled but their
    toggles have to be left alone.  Therefore an additional argument is
    added to usb_enable_endpoint() and usb_enable_interface(), a flag
    indicating whether or not the endpoint toggles should be reset.
    
    This is a forward-ported version of a patch which fixes Bugzilla
    #12301.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Reported-by: David Roka <roka@dawid.hu>
    Reported-by: Erik Ekman <erik@kryo.se>
    Tested-by: Erik Ekman <erik@kryo.se>
    Tested-by: Alon Bar-Lev <alon.barlev@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 381eae90c3b7..386177867a8a 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -12,7 +12,9 @@ extern int usb_create_ep_devs(struct device *parent,
 extern void usb_remove_ep_devs(struct usb_host_endpoint *endpoint);
 
 extern void usb_enable_endpoint(struct usb_device *dev,
-		struct usb_host_endpoint *ep);
+		struct usb_host_endpoint *ep, bool reset_toggle);
+extern void usb_enable_interface(struct usb_device *dev,
+		struct usb_interface *intf, bool reset_toggles);
 extern void usb_disable_endpoint(struct usb_device *dev, unsigned int epaddr);
 extern void usb_disable_interface(struct usb_device *dev,
 		struct usb_interface *intf);

commit 3b23dd6f8a718e5339de4f7d86ce76a078b5f771
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Dec 5 14:10:34 2008 -0500

    USB: utilize the bus notifiers
    
    This patch (as1185) makes usbcore take advantage of the bus
    notifications sent out by the driver core.  Now we can create all our
    device and interface attribute files before the device or interface
    uevent is broadcast.
    
    A side effect is that we no longer create the endpoint "pseudo"
    devices at the same time as a device or interface is registered -- it
    seems like a bad idea to try registering an endpoint before the
    registration of its parent is complete.  So the routines for creating
    and removing endpoint devices have been split out and renamed, and
    they are called explicitly when needed.  A new bitflag is used for
    keeping track of whether or not the interface's endpoint devices have
    been created, since (just as with the interface attributes) they vary
    with the altsetting and hence can be changed at random times.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 9fb195665fa8..381eae90c3b7 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -6,10 +6,10 @@ extern int usb_create_sysfs_dev_files(struct usb_device *dev);
 extern void usb_remove_sysfs_dev_files(struct usb_device *dev);
 extern int usb_create_sysfs_intf_files(struct usb_interface *intf);
 extern void usb_remove_sysfs_intf_files(struct usb_interface *intf);
-extern int usb_create_ep_files(struct device *parent,
+extern int usb_create_ep_devs(struct device *parent,
 				struct usb_host_endpoint *endpoint,
 				struct usb_device *udev);
-extern void usb_remove_ep_files(struct usb_host_endpoint *endpoint);
+extern void usb_remove_ep_devs(struct usb_host_endpoint *endpoint);
 
 extern void usb_enable_endpoint(struct usb_device *dev,
 		struct usb_host_endpoint *ep);

commit 65bfd2967c906ca322a4bb69a285fe0de8916ac6
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Nov 25 16:39:18 2008 -0500

    USB: Enhance usage of pm_message_t
    
    This patch (as1177) modifies the USB core suspend and resume
    routines.  The resume functions now will take a pm_message_t argument,
    so they will know what sort of resume is occurring.  The new argument
    is also passed to the port suspend/resume and bus suspend/resume
    routines (although they don't use it for anything but debugging).
    
    In addition, special pm_message_t values are used for user-initiated,
    device-initiated (i.e., remote wakeup), and automatic suspend/resume.
    By testing these values, drivers can tell whether or not a particular
    suspend was an autosuspend.  Unfortunately, they can't do the same for
    resumes -- not until the pm_message_t argument is also passed to the
    drivers' resume methods.  That will require a bigger change.
    
    IMO, the whole Power Management framework should have been set up this
    way in the first place.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index b60ebb4de1a8..9fb195665fa8 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -1,3 +1,5 @@
+#include <linux/pm.h>
+
 /* Functions local to drivers/usb/core/ */
 
 extern int usb_create_sysfs_dev_files(struct usb_device *dev);
@@ -42,15 +44,16 @@ extern void usb_host_cleanup(void);
 #ifdef	CONFIG_PM
 
 extern int usb_suspend(struct device *dev, pm_message_t msg);
-extern int usb_resume(struct device *dev);
+extern int usb_resume(struct device *dev, pm_message_t msg);
 
 extern void usb_autosuspend_work(struct work_struct *work);
 extern void usb_autoresume_work(struct work_struct *work);
-extern int usb_port_suspend(struct usb_device *dev);
-extern int usb_port_resume(struct usb_device *dev);
+extern int usb_port_suspend(struct usb_device *dev, pm_message_t msg);
+extern int usb_port_resume(struct usb_device *dev, pm_message_t msg);
 extern int usb_external_suspend_device(struct usb_device *udev,
 		pm_message_t msg);
-extern int usb_external_resume_device(struct usb_device *udev);
+extern int usb_external_resume_device(struct usb_device *udev,
+		pm_message_t msg);
 
 static inline void usb_pm_lock(struct usb_device *udev)
 {
@@ -64,12 +67,12 @@ static inline void usb_pm_unlock(struct usb_device *udev)
 
 #else
 
-static inline int usb_port_suspend(struct usb_device *udev)
+static inline int usb_port_suspend(struct usb_device *udev, pm_message_t msg)
 {
 	return 0;
 }
 
-static inline int usb_port_resume(struct usb_device *udev)
+static inline int usb_port_resume(struct usb_device *udev, pm_message_t msg)
 {
 	return 0;
 }

commit 9ac39f28b5237a629e41ccfc1f73d3a55723045c
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Nov 12 16:19:49 2008 -0500

    USB: add asynchronous autosuspend/autoresume support
    
    This patch (as1160b) adds support routines for asynchronous autosuspend
    and autoresume, with accompanying documentation updates.  There
    already are several potential users of this interface, and others are
    likely to arise as autosuspend support becomes more widespread.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 9a1a45ac3add..b60ebb4de1a8 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -45,6 +45,7 @@ extern int usb_suspend(struct device *dev, pm_message_t msg);
 extern int usb_resume(struct device *dev);
 
 extern void usb_autosuspend_work(struct work_struct *work);
+extern void usb_autoresume_work(struct work_struct *work);
 extern int usb_port_suspend(struct usb_device *dev);
 extern int usb_port_resume(struct usb_device *dev);
 extern int usb_external_suspend_device(struct usb_device *udev,

commit f2189c477c986db47ac7f9cc32d05f6df18bfe9e
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Aug 12 14:34:10 2008 -0400

    USB: Add new PM callback methods for USB
    
    This patch (as1129) adds support for the new PM callbacks to usbcore.
    The new callbacks merely invoke the same old USB power management
    routines as the old ones did.
    
    A minor improvement is that the callbacks are present only in the
    "USB-device" device_type structure, rather than in the bus_type
    structure.  This way they will be invoked only for USB devices, not
    for USB interfaces.  The core USB PM routines automatically handle
    suspending and resuming interfaces along with their devices.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index d9a6e16dbf84..9a1a45ac3add 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -41,6 +41,9 @@ extern void usb_host_cleanup(void);
 
 #ifdef	CONFIG_PM
 
+extern int usb_suspend(struct device *dev, pm_message_t msg);
+extern int usb_resume(struct device *dev);
+
 extern void usb_autosuspend_work(struct work_struct *work);
 extern int usb_port_suspend(struct usb_device *dev);
 extern int usb_port_resume(struct usb_device *dev);

commit cd9f03759d3eb588e185b04e1854c778b050833e
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Jun 24 14:47:04 2008 -0400

    usbfs: send disconnect signals when device is unregistered
    
    USB device files are accessible in two ways: as files in usbfs and as
    character device nodes.  The two paths are supposed to behave
    identically, but they don't.  When the underlying USB device is
    unplugged, disconnect signals are sent to processes with open usbfs
    files (if they requested these signals) but not to processes with open
    device node files.
    
    This patch (as1104) fixes the bug by moving the disconnect-signalling
    code into a common subroutine which is called from both paths.
    Putting this subroutine in devio.c removes the only out-of-file
    reference to struct dev_state, and so the structure's declaration can
    be moved from usb.h into devio.c.
    
    Finally, the new subroutine performs one extra action: It kills all
    the outstanding async URBs.  (I'd kill the outstanding synchronous
    URBs too, if there was any way to do it.)  In the past this hasn't
    mattered much, because devices were unregistered from usbfs only
    when they were disconnected.  But now the unregistration can also
    occur whenever devices are unbound from the usb_generic driver.  At
    any rate, killing URBs when a device is unregistered from usbfs seems
    like a good thing to do.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index d3eb0a29bca1..d9a6e16dbf84 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -142,26 +142,11 @@ extern struct usb_driver usbfs_driver;
 extern const struct file_operations usbfs_devices_fops;
 extern const struct file_operations usbdev_file_operations;
 extern void usbfs_conn_disc_event(void);
+extern void usb_fs_classdev_common_remove(struct usb_device *udev);
 
 extern int usb_devio_init(void);
 extern void usb_devio_cleanup(void);
 
-struct dev_state {
-	struct list_head list;      /* state list */
-	struct usb_device *dev;
-	struct file *file;
-	spinlock_t lock;            /* protects the async urb lists */
-	struct list_head async_pending;
-	struct list_head async_completed;
-	wait_queue_head_t wait;     /* wake up if a request completed */
-	unsigned int discsignr;
-	struct pid *disc_pid;
-	uid_t disc_uid, disc_euid;
-	void __user *disccontext;
-	unsigned long ifclaimed;
-	u32 secid;
-};
-
 /* internal notify stuff */
 extern void usb_notify_add_device(struct usb_device *udev);
 extern void usb_notify_remove_device(struct usb_device *udev);

commit 78d9a487ee961c356e1a934d9a92eca38ffb3a70
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Jun 23 16:00:40 2008 -0400

    USB: Force unbinding of drivers lacking reset_resume or other methods
    
    This patch (as1024) takes care of a FIXME issue: Drivers that don't
    have the necessary suspend, resume, reset_resume, pre_reset, or
    post_reset methods will be unbound and their interface reprobed when
    one of the unsupported events occurs.
    
    This is made slightly more difficult by the fact that bind operations
    won't work during a system sleep transition.  So instead the code has
    to defer the operation until the transition ends.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 1a8bc21c335e..d3eb0a29bca1 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -29,6 +29,8 @@ extern int usb_choose_configuration(struct usb_device *udev);
 extern void usb_kick_khubd(struct usb_device *dev);
 extern int usb_match_device(struct usb_device *dev,
 			    const struct usb_device_id *id);
+extern void usb_forced_unbind_intf(struct usb_interface *intf);
+extern void usb_rebind_intf(struct usb_interface *intf);
 
 extern int  usb_hub_init(void);
 extern void usb_hub_cleanup(void);

commit 2e5f10e4f0a9649186d8a8c793822b2e0dae8373
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Apr 30 15:37:19 2008 -0400

    USB: create attributes before sending uevent
    
    This patch (as1087d) fixes a long-standing problem in usbcore: Device,
    interface, and endpoint attributes aren't added until _after_ the
    creation uevent has already been broadcast.
    
    Unfortunately there are a few attributes which cannot be created that
    early.  The "descriptors" attribute is binary and so must be created
    separately.  The power-management attributes can't be created until
    the dev/power/ group exists.  And the interface string can vary from
    one altsetting to another, so it has to be created dynamically.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 1bf8ccb9c58d..1a8bc21c335e 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -130,6 +130,10 @@ static inline int is_active(const struct usb_interface *f)
 /* for labeling diagnostics */
 extern const char *usbcore_name;
 
+/* sysfs stuff */
+extern struct attribute_group *usb_device_groups[];
+extern struct attribute_group *usb_interface_groups[];
+
 /* usbfs stuff */
 extern struct mutex usbfs_mutex;
 extern struct usb_driver usbfs_driver;

commit 70a1c9e086c2e267fbc4533cb870f34999b531d6
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Thu Mar 6 17:00:58 2008 -0500

    USB: remove dev->power.power_state
    
    power.power_state is scheduled for removal.  This patch (as1053)
    removes all uses of that field from drivers/usb.  Almost all of them
    were write-only, the most significant exceptions being sl811-hcd.c and
    u132-hcd.c.
    
    Part of this patch was written by Pavel Machek.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Cc: David Brownell <david-b@pacbell.net>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 2375194a9d43..1bf8ccb9c58d 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -114,13 +114,11 @@ static inline int is_usb_device_driver(struct device_driver *drv)
 static inline void mark_active(struct usb_interface *f)
 {
 	f->is_active = 1;
-	f->dev.power.power_state.event = PM_EVENT_ON;
 }
 
 static inline void mark_quiesced(struct usb_interface *f)
 {
 	f->is_active = 0;
-	f->dev.power.power_state.event = PM_EVENT_SUSPEND;
 }
 
 static inline int is_active(const struct usb_interface *f)

commit 84cca820ee798a6bc8b01a4ccc9548943bc41f7f
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed Jan 30 15:21:33 2008 -0800

    USB: fix codingstyle issues in drivers/usb/core/*.h
    
    Fixes a number of coding style issues in the USB internal header files.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index c52626c51f70..2375194a9d43 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -1,22 +1,23 @@
 /* Functions local to drivers/usb/core/ */
 
-extern int usb_create_sysfs_dev_files (struct usb_device *dev);
-extern void usb_remove_sysfs_dev_files (struct usb_device *dev);
-extern int usb_create_sysfs_intf_files (struct usb_interface *intf);
-extern void usb_remove_sysfs_intf_files (struct usb_interface *intf);
-extern int usb_create_ep_files(struct device *parent, struct usb_host_endpoint *endpoint,
+extern int usb_create_sysfs_dev_files(struct usb_device *dev);
+extern void usb_remove_sysfs_dev_files(struct usb_device *dev);
+extern int usb_create_sysfs_intf_files(struct usb_interface *intf);
+extern void usb_remove_sysfs_intf_files(struct usb_interface *intf);
+extern int usb_create_ep_files(struct device *parent,
+				struct usb_host_endpoint *endpoint,
 				struct usb_device *udev);
 extern void usb_remove_ep_files(struct usb_host_endpoint *endpoint);
 
 extern void usb_enable_endpoint(struct usb_device *dev,
 		struct usb_host_endpoint *ep);
-extern void usb_disable_endpoint (struct usb_device *dev, unsigned int epaddr);
-extern void usb_disable_interface (struct usb_device *dev,
+extern void usb_disable_endpoint(struct usb_device *dev, unsigned int epaddr);
+extern void usb_disable_interface(struct usb_device *dev,
 		struct usb_interface *intf);
 extern void usb_release_interface_cache(struct kref *ref);
-extern void usb_disable_device (struct usb_device *dev, int skip_ep0);
-extern int usb_deauthorize_device (struct usb_device *);
-extern int usb_authorize_device (struct usb_device *);
+extern void usb_disable_device(struct usb_device *dev, int skip_ep0);
+extern int usb_deauthorize_device(struct usb_device *);
+extern int usb_authorize_device(struct usb_device *);
 extern void usb_detect_quirks(struct usb_device *udev);
 
 extern int usb_get_device_descriptor(struct usb_device *dev,

commit b5ea060f1e19c6a3f409d3472c723da4517547b8
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Aug 2 22:44:27 2007 -0600

    USB: rename choose_configuration
    
    As it is global, give it a usb specific name in the global namespace.
    
    Cc: Inaky Perez-Gonzalez <inaky@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index e22ec7f8eb15..c52626c51f70 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -23,7 +23,7 @@ extern int usb_get_device_descriptor(struct usb_device *dev,
 		unsigned int size);
 extern char *usb_cache_string(struct usb_device *udev, int index);
 extern int usb_set_configuration(struct usb_device *dev, int configuration);
-extern int choose_configuration(struct usb_device *udev);
+extern int usb_choose_configuration(struct usb_device *udev);
 
 extern void usb_kick_khubd(struct usb_device *dev);
 extern int usb_match_device(struct usb_device *dev,

commit 93993a0a3e528357ae4b9b0eb82fd4b428ebbf64
Author: Inaky Perez-Gonzalez <inaky@linux.intel.com>
Date:   Tue Jul 31 20:34:06 2007 -0700

    usb: introduce usb_authorize/deauthorize()
    
    These USB API functions will do the full authorization/deauthorization
    to be used for a device. When authorized we effectively allow a
    configuration to be set. Reverse that when deauthorized.
    
    Effectively this means that we have to clean all the configuration
    descriptors on deauthorize and reload them when we authorized. We could
    do without throwing them out for wired devices, but for wireless, we can
    read them only after authenticating, and thus, when authorizing an
    authenticated device we would need to read them. So to simplify, always
    release them on deauthorize(), re-read them on authorize().
    
    Also fix leak reported by Ragner Magalhaes; in usb_deauthorize_device(),
    bNumConfigurations was being set to zero before the for loop, and thus
    the different raw descriptors where never being freed.
    
    Signed-off-by: Inaky Perez-Gonzalez <inaky@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index cde6e52b84fe..e22ec7f8eb15 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -15,12 +15,15 @@ extern void usb_disable_interface (struct usb_device *dev,
 		struct usb_interface *intf);
 extern void usb_release_interface_cache(struct kref *ref);
 extern void usb_disable_device (struct usb_device *dev, int skip_ep0);
+extern int usb_deauthorize_device (struct usb_device *);
+extern int usb_authorize_device (struct usb_device *);
 extern void usb_detect_quirks(struct usb_device *udev);
 
 extern int usb_get_device_descriptor(struct usb_device *dev,
 		unsigned int size);
 extern char *usb_cache_string(struct usb_device *udev, int index);
 extern int usb_set_configuration(struct usb_device *dev, int configuration);
+extern int choose_configuration(struct usb_device *udev);
 
 extern void usb_kick_khubd(struct usb_device *dev);
 extern int usb_match_device(struct usb_device *dev,

commit bdd016ba64d909329cb4bacacc8443901c00e112
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Jul 30 17:05:22 2007 -0400

    USB: add ep->enable
    
    This patch (as944) adds an explicit "enabled" field to the
    usb_host_endpoint structure and uses it in place of the current
    mechanism.  This is merely a time-space tradeoff; it makes checking
    whether URBs may be submitted to an endpoint simpler.  The existing
    mechanism is efficient when converting urb->pipe to an endpoint
    pointer, but it's not so efficient when urb->ep is used instead.
    
    As a side effect, the procedure for enabling an endpoint is now a
    little more complicated.  The ad-hoc inline code in usb.c and hub.c
    for enabling ep0 is now replaced with calls to usb_enable_endpoint,
    which is no longer static.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index ad5fa0338f49..cde6e52b84fe 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -8,6 +8,8 @@ extern int usb_create_ep_files(struct device *parent, struct usb_host_endpoint *
 				struct usb_device *udev);
 extern void usb_remove_ep_files(struct usb_host_endpoint *endpoint);
 
+extern void usb_enable_endpoint(struct usb_device *dev,
+		struct usb_host_endpoint *ep);
 extern void usb_disable_endpoint (struct usb_device *dev, unsigned int epaddr);
 extern void usb_disable_interface (struct usb_device *dev,
 		struct usb_interface *intf);

commit 54515fe528d8c6f9bfaf7d0b9fffb908deecad78
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed May 30 15:38:58 2007 -0400

    USB: unify reset_resume and normal resume
    
    This patch (as919) unifies the code paths used for normal resume and
    for reset-resume.  Earlier I had failed to note a section in the USB
    spec which requires the host to resume a suspended port before
    resetting it if the attached device is enabled for remote wakeup.
    Since the port has to be resumed anyway, we might as well reuse the
    existing code.
    
    The main changes are:
    
            usb_reset_suspended_device() is eliminated.
    
            usb_root_hub_lost_power() is moved down next to the
            hub_reset_resume() routine, to which it is logically
            related.
    
            finish_port_resume() does a port reset() if the device's
            reset_resume flag is set.
    
            usb_port_resume() doesn't check whether the port is initially
            enabled if this is a USB-Persist sort of resume.
    
            Code to perform the port reset is added to the resume pathway
            for the non-CONFIG_USB_SUSPEND case.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index a547499c45f4..ad5fa0338f49 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -36,7 +36,6 @@ extern void usb_host_cleanup(void);
 extern void usb_autosuspend_work(struct work_struct *work);
 extern int usb_port_suspend(struct usb_device *dev);
 extern int usb_port_resume(struct usb_device *dev);
-extern int usb_reset_suspended_device(struct usb_device *udev);
 extern int usb_external_suspend_device(struct usb_device *udev,
 		pm_message_t msg);
 extern int usb_external_resume_device(struct usb_device *udev);

commit 4956eccdd6101c5abb71966079e8183d12796d6c
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed May 30 16:51:28 2007 -0400

    USB: remove __usb_port_suspend
    
    This patch (as915b) combines the public routine usb_port_suspend() and
    the private routine __usb_port_suspend() into a single function.
    
    By removing the explicit mention of otg_port in the call to
    __usb_port_suspend(), we prevent a possible error in which the system
    tries to perform HNP on the wrong port when a non-targeted device is
    plugged into a non-OTG port.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 1a4862886733..a547499c45f4 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -53,8 +53,16 @@ static inline void usb_pm_unlock(struct usb_device *udev)
 
 #else
 
-#define usb_port_suspend(dev)		0
-#define usb_port_resume(dev)		0
+static inline int usb_port_suspend(struct usb_device *udev)
+{
+	return 0;
+}
+
+static inline int usb_port_resume(struct usb_device *udev)
+{
+	return 0;
+}
+
 static inline void usb_pm_lock(struct usb_device *udev) {}
 static inline void usb_pm_unlock(struct usb_device *udev) {}
 

commit 0458d5b4c9cc4ca0f62625d0144ddc4b4bc97a3c
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri May 4 11:52:20 2007 -0400

    USB: add USB-Persist facility
    
    This patch (as886) adds the controversial USB-persist facility,
    allowing USB devices to persist across a power loss during system
    suspend.
    
    The facility is controlled by a new Kconfig option (with appropriate
    warnings about the potential dangers); when the option is off the
    behavior will remain the same as it is now.  But when the option is
    on, people will be able to use suspend-to-disk and keep their USB
    filesystems intact -- something particularly valuable for small
    machines where the root filesystem is on a USB device!
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 6f361df374fc..1a4862886733 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -36,6 +36,7 @@ extern void usb_host_cleanup(void);
 extern void usb_autosuspend_work(struct work_struct *work);
 extern int usb_port_suspend(struct usb_device *dev);
 extern int usb_port_resume(struct usb_device *dev);
+extern int usb_reset_suspended_device(struct usb_device *udev);
 extern int usb_external_suspend_device(struct usb_device *udev,
 		pm_message_t msg);
 extern int usb_external_resume_device(struct usb_device *udev);

commit 784a6e1cc406b7ef48476a1f38b83fc551f5616f
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri May 4 11:49:57 2007 -0400

    USB: interface PM state
    
    This patch (as880) strives to keep the PM core's idea of a USB
    interface's power state in synch with usbcore's own idea.  In the end
    this doesn't really matter, but it's better to be consistent.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index bf2eb0dae2ec..6f361df374fc 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -100,11 +100,13 @@ static inline int is_usb_device_driver(struct device_driver *drv)
 static inline void mark_active(struct usb_interface *f)
 {
 	f->is_active = 1;
+	f->dev.power.power_state.event = PM_EVENT_ON;
 }
 
 static inline void mark_quiesced(struct usb_interface *f)
 {
 	f->is_active = 0;
+	f->dev.power.power_state.event = PM_EVENT_SUSPEND;
 }
 
 static inline int is_active(const struct usb_interface *f)

commit 9f8b17e643fe6aa505629658445849397bda4e4f
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Tue Mar 13 15:59:31 2007 +0100

    USB: make usbdevices export their device nodes instead of using a separate class
    
    o The "real" usb-devices export now a device node which can
      populate /dev/bus/usb.
    
    o The usb_device class is optional now and can be disabled in the
      kernel config. Major/minor of the "real" devices and class devices
      are the same.
    
    o The environment of the usb-device event contains DEVNUM and BUSNUM to
      help udev and get rid of the ugly udev rule we need for the class
      devices.
    
    o The usb-devices and usb-interfaces share the same bus, so I used
      the new "struct device_type" to let these devices identify
      themselves. This also removes the current logic of using a magic
      platform-pointer.
      The name of the device_type is also added to the environment
      which makes it easier to distinguish the different kinds of devices
      on the same subsystem.
    
      It looks like this:
        add@/devices/pci0000:00/0000:00:1d.1/usb2/2-1
        ACTION=add
        DEVPATH=/devices/pci0000:00/0000:00:1d.1/usb2/2-1
        SUBSYSTEM=usb
        SEQNUM=1533
        MAJOR=189
        MINOR=131
        DEVTYPE=usb_device
        PRODUCT=46d/c03e/2000
        TYPE=0/0/0
        BUSNUM=002
        DEVNUM=004
    
    This udev rule works as a replacement for usb_device class devices:
      SUBSYSTEM=="usb", ACTION=="add", ENV{DEVTYPE}=="usb_device", \
        NAME="bus/usb/$env{BUSNUM}/$env{DEVNUM}", MODE="0644"
    
    Updated patch, which needs the device_type patches in Greg's tree.
    
    I also got a bugzilla assigned for this. :)
      https://bugzilla.novell.com/show_bug.cgi?id=250659
    
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index c94379e55f2d..bf2eb0dae2ec 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -78,15 +78,13 @@ static inline int usb_autoresume_device(struct usb_device *udev)
 
 extern struct workqueue_struct *ksuspend_usb_wq;
 extern struct bus_type usb_bus_type;
+extern struct device_type usb_device_type;
+extern struct device_type usb_if_device_type;
 extern struct usb_device_driver usb_generic_driver;
 
-/* Here's how we tell apart devices and interfaces.  Luckily there's
- * no such thing as a platform USB device, so we can steal the use
- * of the platform_data field. */
-
 static inline int is_usb_device(const struct device *dev)
 {
-	return dev->platform_data == &usb_generic_driver;
+	return dev->type == &usb_device_type;
 }
 
 /* Do the same for device drivers and interface drivers. */
@@ -122,11 +120,11 @@ extern const char *usbcore_name;
 extern struct mutex usbfs_mutex;
 extern struct usb_driver usbfs_driver;
 extern const struct file_operations usbfs_devices_fops;
-extern const struct file_operations usbfs_device_file_operations;
+extern const struct file_operations usbdev_file_operations;
 extern void usbfs_conn_disc_event(void);
 
-extern int usbdev_init(void);
-extern void usbdev_cleanup(void);
+extern int usb_devio_init(void);
+extern void usb_devio_cleanup(void);
 
 struct dev_state {
 	struct list_head list;      /* state list */

commit 6b157c9bf3bace6eeb4a973da63923ef24995cce
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Mar 13 16:37:30 2007 -0400

    USB: separate autosuspend from external suspend
    
    This patch (as866) adds new entry points for external USB device
    suspend and resume requests, as opposed to internally-generated
    autosuspend or autoresume.  It also changes the existing
    remote-wakeup code paths to use the new routines, since remote wakeup
    is not the same as autoresume.
    
    As part of the change, it turns out to be necessary to do remote
    wakeup of root hubs from a workqueue.  We had been using khubd, but it
    does autoresume rather than an external resume.  Using the
    ksuspend_usb_wq workqueue for this purpose seemed a logical choice.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index b98bc0d381c0..c94379e55f2d 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -21,7 +21,6 @@ extern char *usb_cache_string(struct usb_device *udev, int index);
 extern int usb_set_configuration(struct usb_device *dev, int configuration);
 
 extern void usb_kick_khubd(struct usb_device *dev);
-extern void usb_resume_root_hub(struct usb_device *dev);
 extern int usb_match_device(struct usb_device *dev,
 			    const struct usb_device_id *id);
 
@@ -37,6 +36,9 @@ extern void usb_host_cleanup(void);
 extern void usb_autosuspend_work(struct work_struct *work);
 extern int usb_port_suspend(struct usb_device *dev);
 extern int usb_port_resume(struct usb_device *dev);
+extern int usb_external_suspend_device(struct usb_device *udev,
+		pm_message_t msg);
+extern int usb_external_resume_device(struct usb_device *udev);
 
 static inline void usb_pm_lock(struct usb_device *udev)
 {

commit 718efa64e30a5e9db0351d70c5a91969306a12d1
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Mar 9 15:41:13 2007 -0500

    usbcore: move usb_autosuspend_work
    
    This patch (as864) moves the work routine for USB autosuspend from one
    source file to another.  This permits the removal of one whole global
    symbol (!) and should smooth the way for more changes in the future.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 08b5a04e3755..b98bc0d381c0 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -34,8 +34,7 @@ extern void usb_host_cleanup(void);
 
 #ifdef	CONFIG_PM
 
-extern int usb_suspend_both(struct usb_device *udev, pm_message_t msg);
-extern int usb_resume_both(struct usb_device *udev);
+extern void usb_autosuspend_work(struct work_struct *work);
 extern int usb_port_suspend(struct usb_device *dev);
 extern int usb_port_resume(struct usb_device *dev);
 
@@ -51,11 +50,6 @@ static inline void usb_pm_unlock(struct usb_device *udev)
 
 #else
 
-#define usb_suspend_both(udev, msg)	0
-static inline int usb_resume_both(struct usb_device *udev)
-{
-	return 0;
-}
 #define usb_port_suspend(dev)		0
 #define usb_port_resume(dev)		0
 static inline void usb_pm_lock(struct usb_device *udev) {}

commit 19c262391c4741b012a5031fc438fb694e77c385
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Feb 20 15:03:32 2007 -0500

    USB: export autosuspend delay in sysfs
    
    This patch (as861) adds sysfs attributes to expose the autosuspend
    delay value for each USB device.  If the user changes the delay from 0
    (no autosuspend) to a positive value, an autosuspend is attempted.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index b0a35f45b099..08b5a04e3755 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -66,11 +66,13 @@ static inline void usb_pm_unlock(struct usb_device *udev) {}
 #ifdef CONFIG_USB_SUSPEND
 
 extern void usb_autosuspend_device(struct usb_device *udev);
+extern void usb_try_autosuspend_device(struct usb_device *udev);
 extern int usb_autoresume_device(struct usb_device *udev);
 
 #else
 
-#define usb_autosuspend_device(udev)	do {} while (0)
+#define usb_autosuspend_device(udev)		do {} while (0)
+#define usb_try_autosuspend_device(udev)	do {} while (0)
 static inline int usb_autoresume_device(struct usb_device *udev)
 {
 	return 0;

commit b5e795f8df42936590ba9c606edc715fe3593284
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Feb 20 15:00:53 2007 -0500

    USB: make autosuspend delay a module parameter
    
    This patch (as859) makes the default USB autosuspend delay a module
    parameter of usbcore.  By setting the delay value at boot time, users
    will be able to prevent the system from autosuspending devices which
    for some reason can't handle it.
    
    The patch also stores the autosuspend delay as a per-device value.  A
    later patch will allow the user to change the value, tailoring the
    delay for each individual device.  A delay value of 0 will prevent
    autosuspend.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 045cbd111887..b0a35f45b099 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -65,8 +65,6 @@ static inline void usb_pm_unlock(struct usb_device *udev) {}
 
 #ifdef CONFIG_USB_SUSPEND
 
-#define USB_AUTOSUSPEND_DELAY	(HZ*2)
-
 extern void usb_autosuspend_device(struct usb_device *udev);
 extern int usb_autoresume_device(struct usb_device *udev);
 

commit 7ceec1f1d26f966c0816b86a1aab1e0b3b208757
Author: Oliver Neukum <oneukum@suse.de>
Date:   Fri Jan 26 14:26:21 2007 +0100

    USB: add a blacklist for devices that can't handle some things we throw at them.
    
    This adds a blacklist to the USB core to handle some autosuspend and
    string issues that devices have.
    
    Originally written by Oliver, but hacked up a lot by Greg.
    
    Signed-off-by: Oliver Neukum <oneukum@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 86692a23573f..045cbd111887 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -13,6 +13,7 @@ extern void usb_disable_interface (struct usb_device *dev,
 		struct usb_interface *intf);
 extern void usb_release_interface_cache(struct kref *ref);
 extern void usb_disable_device (struct usb_device *dev, int skip_ep0);
+extern void usb_detect_quirks(struct usb_device *udev);
 
 extern int usb_get_device_descriptor(struct usb_device *dev,
 		unsigned int size);

commit bb417020ba8c559eb52f57379ba17f669f8f72cd
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Jan 26 14:26:21 2007 +0100

    USB: refactor usb device matching and create usb_device_match
    
    This is needed for the quirk match code.
    
    Cc: Oliver Neukum <oliver@neukum.name>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 17830a81be14..86692a23573f 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -21,6 +21,8 @@ extern int usb_set_configuration(struct usb_device *dev, int configuration);
 
 extern void usb_kick_khubd(struct usb_device *dev);
 extern void usb_resume_root_hub(struct usb_device *dev);
+extern int usb_match_device(struct usb_device *dev,
+			    const struct usb_device_id *id);
 
 extern int  usb_hub_init(void);
 extern void usb_hub_cleanup(void);

commit 94fcda1f8ab5e0cacc381c5ca1cc9aa6ad523576
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Nov 20 11:38:46 2006 -0500

    usbcore: remove unused argument in autosuspend
    
    Thanks to several earlier patches, usb_autosuspend_device() and
    usb_autoresume_device() are never called with a second argument other
    than 1.  This patch (as819) removes the now-redundant argument.
    
    It also consolidates some common code between those two routines,
    putting it into a new subroutine called usb_autopm_do_device().  And
    it includes a sizable kerneldoc update for the affected functions.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 13322e33f912..17830a81be14 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -64,14 +64,13 @@ static inline void usb_pm_unlock(struct usb_device *udev) {}
 
 #define USB_AUTOSUSPEND_DELAY	(HZ*2)
 
-extern void usb_autosuspend_device(struct usb_device *udev, int dec_busy_cnt);
-extern int usb_autoresume_device(struct usb_device *udev, int inc_busy_cnt);
+extern void usb_autosuspend_device(struct usb_device *udev);
+extern int usb_autoresume_device(struct usb_device *udev);
 
 #else
 
-#define usb_autosuspend_device(udev, dec_busy_cnt)	do {} while (0)
-static inline int usb_autoresume_device(struct usb_device *udev,
-		int inc_busy_cnt)
+#define usb_autosuspend_device(udev)	do {} while (0)
+static inline int usb_autoresume_device(struct usb_device *udev)
 {
 	return 0;
 }

commit 2425c08b37244005ff221efe4957d8aaff18609c
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Mon Oct 2 02:17:28 2006 -0700

    [PATCH] usb: fixup usb so it uses struct pid
    
    The problem with remembering a user space process by its pid is that it is
    possible that the process will exit, pid wrap around will occur.
    Converting to a struct pid avoid that problem, and paves the way for
    implementing a pid namespace.
    
    Also since usb is the only user of kill_proc_info_as_uid rename
    kill_proc_info_as_uid to kill_pid_info_as_uid and have the new version take
    a struct pid.
    
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index f69df137ec0e..13322e33f912 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -139,7 +139,7 @@ struct dev_state {
 	struct list_head async_completed;
 	wait_queue_head_t wait;     /* wake up if a request completed */
 	unsigned int discsignr;
-	pid_t disc_pid;
+	struct pid *disc_pid;
 	uid_t disc_uid, disc_euid;
 	void __user *disccontext;
 	unsigned long ifclaimed;

commit e0318ebff4d96131bb3524308b845f642e64df81
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Sep 26 14:50:20 2006 -0400

    USB: fix autosuspend when CONFIG_PM isn't set
    
    This patch (as791b) fixes things up to avoid compiler warnings or
    errors when CONFIG_USB_SUSPEND or CONFIG_PM isn't set.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index fb6eb41c374f..f69df137ec0e 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -36,6 +36,16 @@ extern int usb_resume_both(struct usb_device *udev);
 extern int usb_port_suspend(struct usb_device *dev);
 extern int usb_port_resume(struct usb_device *dev);
 
+static inline void usb_pm_lock(struct usb_device *udev)
+{
+	mutex_lock_nested(&udev->pm_mutex, udev->level);
+}
+
+static inline void usb_pm_unlock(struct usb_device *udev)
+{
+	mutex_unlock(&udev->pm_mutex);
+}
+
 #else
 
 #define usb_suspend_both(udev, msg)	0
@@ -45,6 +55,8 @@ static inline int usb_resume_both(struct usb_device *udev)
 }
 #define usb_port_suspend(dev)		0
 #define usb_port_resume(dev)		0
+static inline void usb_pm_lock(struct usb_device *udev) {}
+static inline void usb_pm_unlock(struct usb_device *udev) {}
 
 #endif
 
@@ -58,7 +70,11 @@ extern int usb_autoresume_device(struct usb_device *udev, int inc_busy_cnt);
 #else
 
 #define usb_autosuspend_device(udev, dec_busy_cnt)	do {} while (0)
-#define usb_autoresume_device(udev, inc_busy_cnt)	0
+static inline int usb_autoresume_device(struct usb_device *udev,
+		int inc_busy_cnt)
+{
+	return 0;
+}
 
 #endif
 

commit bd859281c09b4318153dc7222b5e9052aad83b61
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Sep 19 10:14:07 2006 -0400

    USB: create new workqueue thread for USB autosuspend
    
    This patch (as787) creates a new workqueue thread to handle delayed
    USB autosuspend requests.  Previously the code used keventd.  However
    it turns out that the hub driver's suspend routine calls
    flush_scheduled_work(), making it a poor candidate for running in
    keventd (the call immediately deadlocks).  The solution is to use a
    new thread instead of keventd.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 0c09ecced6e1..fb6eb41c374f 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -62,6 +62,7 @@ extern int usb_autoresume_device(struct usb_device *udev, int inc_busy_cnt);
 
 #endif
 
+extern struct workqueue_struct *ksuspend_usb_wq;
 extern struct bus_type usb_bus_type;
 extern struct usb_device_driver usb_generic_driver;
 

commit 1b21d5e166e104f8914441ef52e2cd50ce65b479
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Aug 28 11:43:25 2006 -0700

    USB: fix __must_check warnings in drivers/usb/core/
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index e8bc2e48913a..0c09ecced6e1 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -1,10 +1,10 @@
 /* Functions local to drivers/usb/core/ */
 
-extern void usb_create_sysfs_dev_files (struct usb_device *dev);
+extern int usb_create_sysfs_dev_files (struct usb_device *dev);
 extern void usb_remove_sysfs_dev_files (struct usb_device *dev);
-extern void usb_create_sysfs_intf_files (struct usb_interface *intf);
+extern int usb_create_sysfs_intf_files (struct usb_interface *intf);
 extern void usb_remove_sysfs_intf_files (struct usb_interface *intf);
-extern void usb_create_ep_files(struct device *parent, struct usb_host_endpoint *endpoint,
+extern int usb_create_ep_files(struct device *parent, struct usb_host_endpoint *endpoint,
 				struct usb_device *udev);
 extern void usb_remove_ep_files(struct usb_host_endpoint *endpoint);
 

commit 02c399ee45a54987c152fe5f627ed949bb55f187
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Aug 30 15:47:11 2006 -0400

    usbcore: remove usb_suspend_root_hub
    
    This patch (as740) removes the existing support for autosuspend of
    root hubs.  That support fit in rather awkwardly with the rest of
    usbcore and it was used only by ohci-hcd.  It won't be needed any more
    since the hub driver will take care of autosuspending all hubs, root
    or external.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 10688ad73c6d..e8bc2e48913a 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -20,7 +20,6 @@ extern char *usb_cache_string(struct usb_device *udev, int index);
 extern int usb_set_configuration(struct usb_device *dev, int configuration);
 
 extern void usb_kick_khubd(struct usb_device *dev);
-extern void usb_suspend_root_hub(struct usb_device *hdev);
 extern void usb_resume_root_hub(struct usb_device *dev);
 
 extern int  usb_hub_init(void);

commit 645daaab0b6adc35c1838df2a82f9d729fdb1767
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Aug 30 15:47:02 2006 -0400

    usbcore: add autosuspend/autoresume infrastructure
    
    This patch (as739) adds the basic infrastructure for USB autosuspend
    and autoresume.  The main features are:
    
            PM usage counters added to struct usb_device and struct
            usb_interface, indicating whether it's okay to autosuspend
            them or they are currently in use.
    
            Flag added to usb_device indicating whether the current
            suspend/resume operation originated from outside or as an
            autosuspend/autoresume.
    
            Flag added to usb_driver indicating whether the driver
            supports autosuspend.  If not, no device bound to the driver
            will be autosuspended.
    
            Mutex added to usb_device for protecting PM operations.
            Unlike the device semaphore, the locking rule for the pm_mutex
            is that you must acquire the locks going _up_ the device tree.
    
            New routines handling autosuspend/autoresume requests for
            interfaces and devices.
    
            Suspend and resume requests are propagated up the device tree
            (but not outside the USB subsystem).
    
            work_struct added to usb_device, for carrying out delayed
            autosuspend requests.
    
            Autoresume added (and autosuspend prevented) during probe and
            disconnect.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 5162cb370215..10688ad73c6d 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -49,6 +49,20 @@ static inline int usb_resume_both(struct usb_device *udev)
 
 #endif
 
+#ifdef CONFIG_USB_SUSPEND
+
+#define USB_AUTOSUSPEND_DELAY	(HZ*2)
+
+extern void usb_autosuspend_device(struct usb_device *udev, int dec_busy_cnt);
+extern int usb_autoresume_device(struct usb_device *udev, int inc_busy_cnt);
+
+#else
+
+#define usb_autosuspend_device(udev, dec_busy_cnt)	do {} while (0)
+#define usb_autoresume_device(udev, inc_busy_cnt)	0
+
+#endif
+
 extern struct bus_type usb_bus_type;
 extern struct usb_device_driver usb_generic_driver;
 

commit 42d8a2d22bbaed80f1ade65a08e4e1097a111d4b
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Sun Aug 20 18:58:42 2006 +0400

    USB: Turn usb_resume_both() into static inline
    
    drivers/usb/core/hub.c: In function `hub_events':
    drivers/usb/core/hub.c:2591: warning: statement with no effect
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 67da6d0b316f..5162cb370215 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -40,7 +40,10 @@ extern int usb_port_resume(struct usb_device *dev);
 #else
 
 #define usb_suspend_both(udev, msg)	0
-#define usb_resume_both(udev)		0
+static inline int usb_resume_both(struct usb_device *udev)
+{
+	return 0;
+}
 #define usb_port_suspend(dev)		0
 #define usb_port_resume(dev)		0
 

commit 095bc335360a51623dd8571839bbf465851a7f4b
Author: Luiz Fernando N. Capitulino <lcapitulino@mandriva.com.br>
Date:   Sat Aug 26 23:48:11 2006 -0300

    USB core: Use const where possible.
    
    This patch marks some USB core's functions parameters as const. This
    improves the design (we're saying to the caller that its parameter is
    not going to be modified) and may help in compiler's optimisation work.
    
    Signed-off-by: Luiz Fernando N. Capitulino <lcapitulino@mandriva.com.br>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 6096ead2758c..67da6d0b316f 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -53,7 +53,7 @@ extern struct usb_device_driver usb_generic_driver;
  * no such thing as a platform USB device, so we can steal the use
  * of the platform_data field. */
 
-static inline int is_usb_device(struct device *dev)
+static inline int is_usb_device(const struct device *dev)
 {
 	return dev->platform_data == &usb_generic_driver;
 }
@@ -78,7 +78,7 @@ static inline void mark_quiesced(struct usb_interface *f)
 	f->is_active = 0;
 }
 
-static inline int is_active(struct usb_interface *f)
+static inline int is_active(const struct usb_interface *f)
 {
 	return f->is_active;
 }

commit 066202dd48cf3296b6cc22b5fcf89aef33fa0efc
Author: Luiz Fernando N. Capitulino <lcapitulino@mandriva.com.br>
Date:   Sat Aug 5 20:37:11 2006 -0300

    USB: Make file operations structs in drivers/usb const.
    
    Making structs const prevents accidental bugs and with the proper debug
    options they're protected against corruption.
    
    Signed-off-by: Luiz Fernando N. Capitulino <lcapitulino@mandriva.com.br>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 98675fb1bc4c..6096ead2758c 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -90,8 +90,8 @@ extern const char *usbcore_name;
 /* usbfs stuff */
 extern struct mutex usbfs_mutex;
 extern struct usb_driver usbfs_driver;
-extern struct file_operations usbfs_devices_fops;
-extern struct file_operations usbfs_device_file_operations;
+extern const struct file_operations usbfs_devices_fops;
+extern const struct file_operations usbfs_device_file_operations;
 extern void usbfs_conn_disc_event(void);
 
 extern int usbdev_init(void);

commit d388dab7b562b76525761f89702246686747ba30
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Sat Jul 1 22:14:24 2006 -0400

    hub driver: improve use of #ifdef
    
    This patch (as736) makes the hub driver more readable by improving the
    usage of "#ifdef CONFIG_PM" and "#ifdef CONFIG_USB_SUSPEND".
    
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 74df0db954c9..98675fb1bc4c 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -30,11 +30,22 @@ extern void usb_major_cleanup(void);
 extern int usb_host_init(void);
 extern void usb_host_cleanup(void);
 
+#ifdef	CONFIG_PM
+
 extern int usb_suspend_both(struct usb_device *udev, pm_message_t msg);
 extern int usb_resume_both(struct usb_device *udev);
 extern int usb_port_suspend(struct usb_device *dev);
 extern int usb_port_resume(struct usb_device *dev);
 
+#else
+
+#define usb_suspend_both(udev, msg)	0
+#define usb_resume_both(udev)		0
+#define usb_port_suspend(dev)		0
+#define usb_port_resume(dev)		0
+
+#endif
+
 extern struct bus_type usb_bus_type;
 extern struct usb_device_driver usb_generic_driver;
 

commit 4d064c080265a41324d108fccc26b72106d43db3
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Sat Jul 1 22:11:44 2006 -0400

    usbcore: track whether interfaces are suspended
    
    Currently we rely on intf->dev.power.power_state.event for tracking
    whether intf is suspended.  This is not a reliable technique because
    that value is owned by the PM core, not by usbcore.  This patch (as718b)
    adds a new flag so that we can accurately tell which interfaces are
    suspended and which aren't.
    
    At first one might think these flags aren't needed, since interfaces
    will be suspended along with their devices.  It turns out there are a
    couple of intermediate situations where that's not quite true, such as
    while processing a remote-wakeup request.
    
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index cc42972b6bb0..74df0db954c9 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -59,17 +59,17 @@ static inline int is_usb_device_driver(struct device_driver *drv)
 
 static inline void mark_active(struct usb_interface *f)
 {
-	f->dev.power.power_state.event = PM_EVENT_ON;
+	f->is_active = 1;
 }
 
 static inline void mark_quiesced(struct usb_interface *f)
 {
-	f->dev.power.power_state.event = PM_EVENT_FREEZE;
+	f->is_active = 0;
 }
 
 static inline int is_active(struct usb_interface *f)
 {
-	return f->dev.power.power_state.event == PM_EVENT_ON;
+	return f->is_active;
 }
 
 

commit a8e7c5653562f88c0f5f53eac0a890c012655789
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Sat Jul 1 22:11:02 2006 -0400

    usbcore: resume device resume recursion
    
    This patch (as717b) removes the existing recursion in hub resume code:
    Resuming a hub will no longer automatically resume the devices attached
    to the hub.
    
    At the same time, it adds one level of recursion: Suspending a USB
    device will automatically suspend all the device's interfaces.  Failure
    at an intermediate stage will cause all the already-suspended interfaces
    to be resumed. Attempts to suspend or resume an interface by itself will
    do nothing, although they won't return an error.  Thus the regular
    system-suspend and system-resume procedures should continue to work as
    before; only runtime PM will be affected.
    
    The patch also removes the code that tests state of the interfaces
    before suspending a device.  It's no longer needed, since everything
    gets suspended together.
    
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 1d25ccac7832..cc42972b6bb0 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -30,6 +30,8 @@ extern void usb_major_cleanup(void);
 extern int usb_host_init(void);
 extern void usb_host_cleanup(void);
 
+extern int usb_suspend_both(struct usb_device *udev, pm_message_t msg);
+extern int usb_resume_both(struct usb_device *udev);
 extern int usb_port_suspend(struct usb_device *dev);
 extern int usb_port_resume(struct usb_device *dev);
 

commit 8bb54ab573ecd1b4fe2ed66416a8d99a86e65316
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Sat Jul 1 22:08:49 2006 -0400

    usbcore: add usb_device_driver definition
    
    This patch (as732) adds a usb_device_driver structure, for representing
    drivers that manage an entire USB device as opposed to just an
    interface.  Support routines like usb_register_device_driver,
    usb_deregister_device_driver, usb_probe_device, and usb_unbind_device
    are also added.
    
    Unlike an earlier version of this patch, the new code is type-safe.  To
    accomplish this, the existing struct driver embedded in struct
    usb_driver had to be wrapped in an intermediate wrapper.  This enables
    the core to tell at runtime whether a particular struct driver belongs
    to a device driver or to an interface driver.
    
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 82d397a6f773..1d25ccac7832 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -34,8 +34,24 @@ extern int usb_port_suspend(struct usb_device *dev);
 extern int usb_port_resume(struct usb_device *dev);
 
 extern struct bus_type usb_bus_type;
-extern struct device_driver usb_generic_driver;
-extern int usb_generic_driver_data;
+extern struct usb_device_driver usb_generic_driver;
+
+/* Here's how we tell apart devices and interfaces.  Luckily there's
+ * no such thing as a platform USB device, so we can steal the use
+ * of the platform_data field. */
+
+static inline int is_usb_device(struct device *dev)
+{
+	return dev->platform_data == &usb_generic_driver;
+}
+
+/* Do the same for device drivers and interface drivers. */
+
+static inline int is_usb_device_driver(struct device_driver *drv)
+{
+	return container_of(drv, struct usbdrv_wrap, driver)->
+			for_devices;
+}
 
 /* Interfaces and their "power state" are owned by usbcore */
 

commit 36e56a34586783c7986ce09d39db80b27c95ce24
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Sat Jul 1 22:08:06 2006 -0400

    usbcore: move code among source files
    
    This revised patch (as713b) moves a few routines among source files in
    usbcore.  Some driver-related code in usb.c (claiming interfaces and
    matching IDs) is moved to driver.c, where it belongs.  Also the
    usb_generic stuff in driver.c is moved to a new source file: generic.c.
    (That's the reason for revising the patch.)  Although not very big now,
    it will get bigger in a later patch.
    
    None of the code has been changed; it has only been re-arranged.
    
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 5a4eff5eec86..82d397a6f773 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -33,9 +33,9 @@ extern void usb_host_cleanup(void);
 extern int usb_port_suspend(struct usb_device *dev);
 extern int usb_port_resume(struct usb_device *dev);
 
+extern struct bus_type usb_bus_type;
 extern struct device_driver usb_generic_driver;
 extern int usb_generic_driver_data;
-extern int usb_device_match(struct device *dev, struct device_driver *drv);
 
 /* Interfaces and their "power state" are owned by usbcore */
 

commit 140d8f687457c40a66af362838fac0d7893e7df5
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Sat Jul 1 22:07:21 2006 -0400

    usbcore: rename usb_suspend_device to usb_port_suspend
    
    This revised patch (as715b) renames usb_suspend_device to
    usb_port_suspend, usb_resume_device to usb_port_resume, and
    finish_device_resume to finish_port_resume.  There was no objection to
    the original version of the patch so this should be okay to apply.
    
    The revision was needed only because I have re-arranged the order of the
    earlier patches.
    
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 1217fbbe5829..5a4eff5eec86 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -30,8 +30,8 @@ extern void usb_major_cleanup(void);
 extern int usb_host_init(void);
 extern void usb_host_cleanup(void);
 
-extern int usb_suspend_device(struct usb_device *dev);
-extern int usb_resume_device(struct usb_device *dev);
+extern int usb_port_suspend(struct usb_device *dev);
+extern int usb_port_resume(struct usb_device *dev);
 
 extern struct device_driver usb_generic_driver;
 extern int usb_generic_driver_data;

commit 4a2a8a2cce86b9d001378cc25acb5c61e6ca7d63
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Sat Jul 1 22:05:01 2006 -0400

    usbfs: private mutex for open, release, and remove
    
    The usbfs code doesn't provide sufficient mutual exclusion among open,
    release, and remove.  Release vs. remove is okay because they both
    acquire the device lock, but open is not exclusive with either one.  All
    three routines modify the udev->filelist linked list, so they must not
    run concurrently.
    
    Apparently someone gave this a minimum amount of thought in the past by
    explicitly acquiring the BKL at the start of the usbdev_open routine.
    Oddly enough, there's a comment pointing out that locking is unnecessary
    because chrdev_open already has acquired the BKL.
    
    But this ignores the point that the files in /proc/bus/usb/* are not
    char device files; they are regular files and so they don't get any
    special locking.  Furthermore it's necessary to acquire the same lock in
    the release and remove routines, which the code does not do.
    
    Yet another problem arises because the same file_operations structure is
    accessible through both the /proc/bus/usb/* and /dev/usb/usbdev* file
    nodes.  Even when one of them has been removed, it's still possible for
    userspace to open the other.  So simple locking around the individual
    remove routines is insufficient; we need to lock the entire
    usb_notify_remove_device notifier chain.
    
    Rather than rely on the BKL, this patch (as723) introduces a new private
    mutex for the purpose.  Holding the BKL while invoking a notifier chain
    doesn't seem like a good idea.
    
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 49f69236b420..1217fbbe5829 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -59,6 +59,7 @@ static inline int is_active(struct usb_interface *f)
 extern const char *usbcore_name;
 
 /* usbfs stuff */
+extern struct mutex usbfs_mutex;
 extern struct usb_driver usbfs_driver;
 extern struct file_operations usbfs_devices_fops;
 extern struct file_operations usbfs_device_file_operations;

commit 7a01955f99b65622a00ba5c8b39202ddc6fa65f8
Author: David Quigley <dpquigl@tycho.nsa.gov>
Date:   Fri Jun 30 01:55:48 2006 -0700

    [PATCH] SELinux: update USB code with new kill_proc_info_as_uid
    
    This patch updates the USB core to save and pass the sending task secid when
    sending signals upon AIO completion so that proper security checking can be
    applied by security modules.
    
    Signed-off-by: David Quigley <dpquigl@tycho.nsa.gov>
    Signed-off-by: James Morris <jmorris@namei.org>
    Cc: Stephen Smalley <sds@tycho.nsa.gov>
    Cc: Chris Wright <chrisw@sous-sol.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 7a650c763a62..49f69236b420 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -80,6 +80,7 @@ struct dev_state {
 	uid_t disc_uid, disc_euid;
 	void __user *disccontext;
 	unsigned long ifclaimed;
+	u32 secid;
 };
 
 /* internal notify stuff */

commit 36679ea59846d8f34a48f71ca1a37671ca0ad3c5
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed Jun 14 12:14:34 2006 -0700

    [PATCH] USB: make usb_create_ep_files take a struct device
    
    Instead of a kobject, will make things easier in the future (don't know
    what I was thinking when I did this originally...)
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 941cb397ba04..7a650c763a62 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -4,7 +4,7 @@ extern void usb_create_sysfs_dev_files (struct usb_device *dev);
 extern void usb_remove_sysfs_dev_files (struct usb_device *dev);
 extern void usb_create_sysfs_intf_files (struct usb_interface *intf);
 extern void usb_remove_sysfs_intf_files (struct usb_interface *intf);
-extern void usb_create_ep_files(struct kobject *parent, struct usb_host_endpoint *endpoint,
+extern void usb_create_ep_files(struct device *parent, struct usb_host_endpoint *endpoint,
 				struct usb_device *udev);
 extern void usb_remove_ep_files(struct usb_host_endpoint *endpoint);
 

commit 84412f6291b50690febd81899e46f0f0ef7a13e0
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed Jun 14 12:14:34 2006 -0700

    [PATCH] USB: move the endpoint specific sysfs code to it's own file
    
    This makes it easier to modify in the future without touching anything else.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 4647e1ebc68d..941cb397ba04 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -4,6 +4,9 @@ extern void usb_create_sysfs_dev_files (struct usb_device *dev);
 extern void usb_remove_sysfs_dev_files (struct usb_device *dev);
 extern void usb_create_sysfs_intf_files (struct usb_interface *intf);
 extern void usb_remove_sysfs_intf_files (struct usb_interface *intf);
+extern void usb_create_ep_files(struct kobject *parent, struct usb_host_endpoint *endpoint,
+				struct usb_device *udev);
+extern void usb_remove_ep_files(struct usb_host_endpoint *endpoint);
 
 extern void usb_disable_endpoint (struct usb_device *dev, unsigned int epaddr);
 extern void usb_disable_interface (struct usb_device *dev,

commit 9ad3d6ccf5eee285e233dbaf186369b8d477a666
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Thu Nov 17 17:10:32 2005 -0500

    [PATCH] USB: Remove USB private semaphore
    
    This patch (as605) removes the private udev->serialize semaphore,
    relying instead on the locking provided by the embedded struct device's
    semaphore.  The changes are confined to the core, except that the
    usb_trylock_device routine now uses the return convention of
    down_trylock rather than down_read_trylock (they return opposite values
    for no good reason).
    
    A couple of other associated changes are included as well:
    
            Now that we aren't concerned about HCDs that avoid using the
            hcd glue layer, usb_disconnect no longer needs to acquire the
            usb_bus_lock -- that can be done by usb_remove_hcd where it
            belongs.
    
            Devices aren't locked over the same scope of code in
            usb_new_device and hub_port_connect_change as they used to be.
            This shouldn't cause any trouble.
    
    Along with the preceding driver core patch, this needs a lot of testing.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 98e85fb4d3b7..4647e1ebc68d 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -16,9 +16,6 @@ extern int usb_get_device_descriptor(struct usb_device *dev,
 extern char *usb_cache_string(struct usb_device *udev, int index);
 extern int usb_set_configuration(struct usb_device *dev, int configuration);
 
-extern void usb_lock_all_devices(void);
-extern void usb_unlock_all_devices(void);
-
 extern void usb_kick_khubd(struct usb_device *dev);
 extern void usb_suspend_root_hub(struct usb_device *hdev);
 extern void usb_resume_root_hub(struct usb_device *dev);

commit ddae41be6145f5f9cb4e6df35661a09121b90672
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed Nov 16 13:41:28 2005 -0800

    [PATCH] USB: reorg some functions out of the main usb.c file
    
    This will make the dynamic-id stuff easier to do, as it will be
    self-contained.
    
    No logic was changed at all.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 1c4a68499dce..98e85fb4d3b7 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -33,6 +33,9 @@ extern void usb_host_cleanup(void);
 extern int usb_suspend_device(struct usb_device *dev);
 extern int usb_resume_device(struct usb_device *dev);
 
+extern struct device_driver usb_generic_driver;
+extern int usb_generic_driver_data;
+extern int usb_device_match(struct device *dev, struct device_driver *drv);
 
 /* Interfaces and their "power state" are owned by usbcore */
 

commit 4f62efe67f077db17dad03a1d4c9665000a3eb45
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Oct 24 16:24:14 2005 -0400

    [PATCH] usbcore: Fix handling of sysfs strings and other attributes
    
    This patch (as592) makes a few small improvements to the way device
    strings are handled, and it fixes some bugs in a couple of other sysfs
    attribute routines.  (Look at show_configuration_string() to see what I
    mean.)
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 888dbe443695..1c4a68499dce 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -13,6 +13,7 @@ extern void usb_disable_device (struct usb_device *dev, int skip_ep0);
 
 extern int usb_get_device_descriptor(struct usb_device *dev,
 		unsigned int size);
+extern char *usb_cache_string(struct usb_device *udev, int index);
 extern int usb_set_configuration(struct usb_device *dev, int configuration);
 
 extern void usb_lock_all_devices(void);

commit a7b986b3e107727dd1c1af0ead0b5e52d7726db3
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Jun 20 21:15:16 2005 -0700

    [PATCH] USB: convert usbfs/devio.c to use usb notifiers
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 811cf4482e0d..888dbe443695 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -62,8 +62,6 @@ extern void usbfs_conn_disc_event(void);
 
 extern int usbdev_init(void);
 extern void usbdev_cleanup(void);
-extern void usbdev_add(struct usb_device *dev);
-extern void usbdev_remove(struct usb_device *dev);
 
 struct dev_state {
 	struct list_head list;      /* state list */

commit 3099e75a7ccc3c5b0a4cf988a76d9c4a7fa5e91a
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Jun 20 21:15:16 2005 -0700

    [PATCH] USB: add notifier functions to the USB core for devices and busses
    
    This should let us get rid of all of the different hooks in the USB core for
    when something has changed.
    
    Also, some other parts of the kernel have wanted to know this kind of
    information at times.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 3dc8096c0f92..811cf4482e0d 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -80,3 +80,9 @@ struct dev_state {
 	unsigned long ifclaimed;
 };
 
+/* internal notify stuff */
+extern void usb_notify_add_device(struct usb_device *udev);
+extern void usb_notify_remove_device(struct usb_device *udev);
+extern void usb_notify_add_bus(struct usb_bus *ubus);
+extern void usb_notify_remove_bus(struct usb_bus *ubus);
+

commit 4592bf5a22593704bb9e8c584a81bf6ca4f6cfec
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Jun 20 21:15:16 2005 -0700

    [PATCH] USB: remove the global function usbdev_lookup_minor
    
    It's only used locally.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 4d59f6e07999..3dc8096c0f92 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -64,7 +64,6 @@ extern int usbdev_init(void);
 extern void usbdev_cleanup(void);
 extern void usbdev_add(struct usb_device *dev);
 extern void usbdev_remove(struct usb_device *dev);
-extern struct usb_device *usbdev_lookup_minor(int minor);
 
 struct dev_state {
 	struct list_head list;      /* state list */

commit 5edbfb7c8af0577097dae87cdd4dfdba82bb9579
Author: David Brownell <david-b@pacbell.net>
Date:   Thu Sep 22 22:45:26 2005 -0700

    [PATCH] stop exporting two functions
    
    The way we're looking at USB suspend lately doesn't expect drivers to
    call usb_suspend_device() or usb_resume_device() directly; that'll
    be implicit when no interfaces are in use.
    
    This patch removes those APIs from visibility outside usbcore.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    
     drivers/usb/core/hub.c |   12 ++++--------
     drivers/usb/core/usb.h |    4 ++++
     include/linux/usb.h    |    5 -----
     3 files changed, 8 insertions(+), 13 deletions(-)

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 7add46ecc6a2..4d59f6e07999 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -29,6 +29,10 @@ extern void usb_major_cleanup(void);
 extern int usb_host_init(void);
 extern void usb_host_cleanup(void);
 
+extern int usb_suspend_device(struct usb_device *dev);
+extern int usb_resume_device(struct usb_device *dev);
+
+
 /* Interfaces and their "power state" are owned by usbcore */
 
 static inline void mark_active(struct usb_interface *f)

commit 979d5199fee9e80290ddeb532e5993bd15506712
Author: David Brownell <david-b@pacbell.net>
Date:   Thu Sep 22 22:32:24 2005 -0700

    [PATCH] root hub changes (lesser half)
    
    This patch collects various small updates related to root hubs, to shrink
    later patches which build on them.
    
      - For root hub suspend/resume support:
         * Make the existing usb_hcd_resume_root_hub() routine respect pmcore
           locking, exporting and using the dpm_runtime_resume() method.
         * Add a new usb_hcd_suspend_root_hub() to pair with that routine.
           (Essential to make OHCI autosuspend behave again...)
         * HC_SUSPENDED by itself only refers to the root hub's downstream ports.
           So let HCDs see root hub URBs unless the parent device is suspended.
    
      - Remove an assertion we no longer need (and now, also don't want).
    
      - Generic suspend/resume updates to work better with swsusp.
         * Ignore the FREEZE vs SUSPEND distinction for hardware; trying to
           use it breaks the swsusp snapshots it's supposed to help (sigh).
         * On resume, mark devices as resumed right away, but then
           do nothing else if the device is marked NOTATTACHED.
    
    These changes shouldn't be very noticable by themselves.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    
     drivers/base/power/runtime.c |    1
     drivers/usb/core/hcd.c       |   64 ++++++++++++++++++++++++++++++++++++++-----
     drivers/usb/core/hcd.h       |    1
     drivers/usb/core/hub.c       |   45 ++++++++++++++++++++++++------
     drivers/usb/core/usb.c       |   20 +++++++++----
     drivers/usb/core/usb.h       |    1
     6 files changed, 111 insertions(+), 21 deletions(-)

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 3741a990403e..7add46ecc6a2 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -19,6 +19,7 @@ extern void usb_lock_all_devices(void);
 extern void usb_unlock_all_devices(void);
 
 extern void usb_kick_khubd(struct usb_device *dev);
+extern void usb_suspend_root_hub(struct usb_device *hdev);
 extern void usb_resume_root_hub(struct usb_device *dev);
 
 extern int  usb_hub_init(void);

commit db69087437dd5135a9362da1c37fe072070e8f60
Author: David Brownell <david-b@pacbell.net>
Date:   Tue Sep 13 19:56:33 2005 -0700

    [PATCH] usb_interface power state
    
    This updates the handling of power state for USB interfaces.
    
      - Formalizes an existing invariant:  interface "power state" is a boolean:
        ON when I/O is allowed, and FREEZE otherwise.  It does so by defining
        some inlined helpers, then using them.
    
      - Adds a useful invariant:  the only interfaces marked active are those
        bound to non-suspended drivers.  Later patches build on this invariant.
    
      - Simplifies the interface driver API (and removes some error paths) by
        removing the requirement that they record power state changes during
        suspend and resume callbacks.  Now usbcore does that.
    
    A few drivers were simplified to address that last change.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    
     drivers/usb/core/hub.c       |   33 +++++++++------------
     drivers/usb/core/message.c   |    1
     drivers/usb/core/usb.c       |   65 +++++++++++++++++++++++++++++++++----------
     drivers/usb/core/usb.h       |   18 +++++++++++
     drivers/usb/input/hid-core.c |    2 -
     drivers/usb/misc/usbtest.c   |   10 ------
     drivers/usb/net/pegasus.c    |    2 -
     drivers/usb/net/usbnet.c     |    2 -
     8 files changed, 85 insertions(+), 48 deletions(-)

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index e6504f3370ad..3741a990403e 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -28,6 +28,24 @@ extern void usb_major_cleanup(void);
 extern int usb_host_init(void);
 extern void usb_host_cleanup(void);
 
+/* Interfaces and their "power state" are owned by usbcore */
+
+static inline void mark_active(struct usb_interface *f)
+{
+	f->dev.power.power_state.event = PM_EVENT_ON;
+}
+
+static inline void mark_quiesced(struct usb_interface *f)
+{
+	f->dev.power.power_state.event = PM_EVENT_FREEZE;
+}
+
+static inline int is_active(struct usb_interface *f)
+{
+	return f->dev.power.power_state.event == PM_EVENT_ON;
+}
+
+
 /* for labeling diagnostics */
 extern const char *usbcore_name;
 

commit d7dd8a72ab8d305fbe1c4bb571e0633eba3a8d23
Author: Linus Torvalds <torvalds@g5.osdl.org>
Date:   Mon Oct 10 16:31:30 2005 -0700

    Use the new "kill_proc_info_as_uid()" for USB disconnect too
    
    All the same issues - we can't just save the pointer to the thread, we
    must save the pid/uid/euid combination.
    
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 83d48c8133af..e6504f3370ad 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -52,7 +52,8 @@ struct dev_state {
 	struct list_head async_completed;
 	wait_queue_head_t wait;     /* wake up if a request completed */
 	unsigned int discsignr;
-	struct task_struct *disctask;
+	pid_t disc_pid;
+	uid_t disc_uid, disc_euid;
 	void __user *disccontext;
 	unsigned long ifclaimed;
 };

commit fbf82fd2e1f4e679c60516d772d1862c941ca845
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Sun Jul 31 01:05:53 2005 +0200

    [PATCH] USB: real nodes instead of usbfs
    
    This patch introduces a /sys/class/usb_device/ class
    where every connected usb-device will show up:
    
      tree /sys/class/usb_device/
      /sys/class/usb_device/
      |-- usb1.1
      |   |-- dev
      |   `-- device -> ../../../devices/pci0000:00/0000:00:1d.0/usb1
      |-- usb2.1
      |   |-- dev
      |   `-- device -> ../../../devices/pci0000:00/0000:00:1d.1/usb2
      ...
    
    The presence of the "dev" file lets udev create real device nodes.
      kay@pim:~/src/linux-2.6> tree /dev/bus/usb/
      /dev/bus/usb/
      |-- 1
      |   `-- 1
      |-- 2
      |   `-- 1
      ...
    
    udev rule:
      SUBSYSTEM="usb_device", PROGRAM="/sbin/usb_device %k", NAME="%c"
      (echo $1 | /bin/sed 's/usb\([0-9]*\)\.\([0-9]*\)/bus\/usb\/\1\/\2/')
    
    This makes libusb pick up the real nodes instead of the mounted usbfs:
      export USB_DEVFS_PATH=/dev/bus/usb
    
    Background:
      All this makes it possible to manage usb devices with udev instead of
      the devfs solution. We are currently working on a pam_console/resmgr
      replacement driven by udev and a pam-helper. It applies ACL's to device
      nodes, which is required for modern desktop functionalty like
      "Fast User Switching" or multiple local login support.
    
    New patch with its own major. I've succesfully disabled usbfs and use real
    nodes only on my box. With: "export USB_DEVFS_PATH=/dev/bus/usb" libusb picks
    up the udev managed nodes instead of reading usbfs files.
    
    This makes udev to provide symlinks for libusb to pick up:
      SUBSYSTEM="usb_device", PROGRAM="/sbin/usbdevice %k", SYMLINK="%c"
    
    /sbin/usbdevice:
      #!/bin/sh
      echo $1 | /bin/sed 's/usbdev\([0-9]*\)\.\([0-9]*\)/bus\/usb\/\1\/\2/'
    
    Signed-off-by: Kay Sievers <kay.sievers@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 2c690f6d4c18..83d48c8133af 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -37,6 +37,11 @@ extern struct file_operations usbfs_devices_fops;
 extern struct file_operations usbfs_device_file_operations;
 extern void usbfs_conn_disc_event(void);
 
+extern int usbdev_init(void);
+extern void usbdev_cleanup(void);
+extern void usbdev_add(struct usb_device *dev);
+extern void usbdev_remove(struct usb_device *dev);
+extern struct usb_device *usbdev_lookup_minor(int minor);
 
 struct dev_state {
 	struct list_head list;      /* state list */

commit 6d5e8254bf488a40b7ae2faafbffa232ab19d541
Author: Greg KH <gregkh@suse.de>
Date:   Mon Apr 18 17:39:24 2005 -0700

    [PATCH] USB: fix up some sparse warnings about static functions that aren't static.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    
    
    Index: gregkh-2.6/drivers/usb/core/usb.h
    ===================================================================

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 4c33eee52001..2c690f6d4c18 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -21,6 +21,13 @@ extern void usb_unlock_all_devices(void);
 extern void usb_kick_khubd(struct usb_device *dev);
 extern void usb_resume_root_hub(struct usb_device *dev);
 
+extern int  usb_hub_init(void);
+extern void usb_hub_cleanup(void);
+extern int usb_major_init(void);
+extern void usb_major_cleanup(void);
+extern int usb_host_init(void);
+extern void usb_host_cleanup(void);
+
 /* for labeling diagnostics */
 extern const char *usbcore_name;
 
@@ -30,6 +37,7 @@ extern struct file_operations usbfs_devices_fops;
 extern struct file_operations usbfs_device_file_operations;
 extern void usbfs_conn_disc_event(void);
 
+
 struct dev_state {
 	struct list_head list;      /* state list */
 	struct usb_device *dev;

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
new file mode 100644
index 000000000000..4c33eee52001
--- /dev/null
+++ b/drivers/usb/core/usb.h
@@ -0,0 +1,46 @@
+/* Functions local to drivers/usb/core/ */
+
+extern void usb_create_sysfs_dev_files (struct usb_device *dev);
+extern void usb_remove_sysfs_dev_files (struct usb_device *dev);
+extern void usb_create_sysfs_intf_files (struct usb_interface *intf);
+extern void usb_remove_sysfs_intf_files (struct usb_interface *intf);
+
+extern void usb_disable_endpoint (struct usb_device *dev, unsigned int epaddr);
+extern void usb_disable_interface (struct usb_device *dev,
+		struct usb_interface *intf);
+extern void usb_release_interface_cache(struct kref *ref);
+extern void usb_disable_device (struct usb_device *dev, int skip_ep0);
+
+extern int usb_get_device_descriptor(struct usb_device *dev,
+		unsigned int size);
+extern int usb_set_configuration(struct usb_device *dev, int configuration);
+
+extern void usb_lock_all_devices(void);
+extern void usb_unlock_all_devices(void);
+
+extern void usb_kick_khubd(struct usb_device *dev);
+extern void usb_resume_root_hub(struct usb_device *dev);
+
+/* for labeling diagnostics */
+extern const char *usbcore_name;
+
+/* usbfs stuff */
+extern struct usb_driver usbfs_driver;
+extern struct file_operations usbfs_devices_fops;
+extern struct file_operations usbfs_device_file_operations;
+extern void usbfs_conn_disc_event(void);
+
+struct dev_state {
+	struct list_head list;      /* state list */
+	struct usb_device *dev;
+	struct file *file;
+	spinlock_t lock;            /* protects the async urb lists */
+	struct list_head async_pending;
+	struct list_head async_completed;
+	wait_queue_head_t wait;     /* wake up if a request completed */
+	unsigned int discsignr;
+	struct task_struct *disctask;
+	void __user *disccontext;
+	unsigned long ifclaimed;
+};
+
