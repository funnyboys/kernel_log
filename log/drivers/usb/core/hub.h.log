commit e6075b6689506d3c388bd72888df9f42a51ed6d8
Author: Nishad Kamdar <nishadkamdar@gmail.com>
Date:   Sat Mar 28 14:48:50 2020 +0530

    USB: core: Use the correct style for SPDX License Identifier
    
    This patch corrects the SPDX License Identifier style in
    header files related to USB Core.
    For C header files Documentation/process/license-rules.rst
    mandates C-like comments (opposed to C source files where
    C++ style should be used).
    
    Changes made by using a script provided by Joe Perches here:
    https://lkml.org/lkml/2019/2/7/46.
    
    Suggested-by: Joe Perches <joe@perches.com>
    Signed-off-by: Nishad Kamdar <nishadkamdar@gmail.com>
    Link: https://lore.kernel.org/r/20200328091844.GA3648@nishad
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/hub.h b/drivers/usb/core/hub.h
index a97dd1ba964e..73f4482d833a 100644
--- a/drivers/usb/core/hub.h
+++ b/drivers/usb/core/hub.h
@@ -1,4 +1,4 @@
-// SPDX-License-Identifier: GPL-2.0
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * usb hub driver head file
  *

commit 1208f9e1d758c991b0a46a1bd60c616b906bbe27
Author: Hardik Gajjar <hgajjar@de.adit-jv.com>
Date:   Thu Feb 6 12:49:23 2020 +0100

    USB: hub: Fix the broken detection of USB3 device in SMSC hub
    
    Renesas R-Car H3ULCB + Kingfisher Infotainment Board is either not able
    to detect the USB3.0 mass storage devices or is detecting those as
    USB2.0 high speed devices.
    
    The explanation given by Renesas is that, due to a HW issue, the XHCI
    driver does not wake up after going to sleep on connecting a USB3.0
    device.
    
    In order to mitigate that, disable the auto-suspend feature
    specifically for SMSC hubs from hub_probe() function, as a quirk.
    
    Renesas Kingfisher Infotainment Board has two USB3.0 ports (CN2) which
    are connected via USB5534B 4-port SuperSpeed/Hi-Speed, low-power,
    configurable hub controller.
    
    [1] SanDisk USB 3.0 device detected as USB-2.0 before the patch
     [   74.036390] usb 5-1.1: new high-speed USB device number 4 using xhci-hcd
     [   74.061598] usb 5-1.1: New USB device found, idVendor=0781, idProduct=5581, bcdDevice= 1.00
     [   74.069976] usb 5-1.1: New USB device strings: Mfr=1, Product=2, SerialNumber=3
     [   74.077303] usb 5-1.1: Product: Ultra
     [   74.080980] usb 5-1.1: Manufacturer: SanDisk
     [   74.085263] usb 5-1.1: SerialNumber: 4C530001110208116550
    
    [2] SanDisk USB 3.0 device detected as USB-3.0 after the patch
     [   34.565078] usb 6-1.1: new SuperSpeed Gen 1 USB device number 3 using xhci-hcd
     [   34.588719] usb 6-1.1: New USB device found, idVendor=0781, idProduct=5581, bcdDevice= 1.00
     [   34.597098] usb 6-1.1: New USB device strings: Mfr=1, Product=2, SerialNumber=3
     [   34.604430] usb 6-1.1: Product: Ultra
     [   34.608110] usb 6-1.1: Manufacturer: SanDisk
     [   34.612397] usb 6-1.1: SerialNumber: 4C530001110208116550
    
    Suggested-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Hardik Gajjar <hgajjar@de.adit-jv.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Tested-by: Eugeniu Rosca <erosca@de.adit-jv.com>
    Cc: stable <stable@vger.kernel.org>
    Link: https://lore.kernel.org/r/1580989763-32291-1-git-send-email-hgajjar@de.adit-jv.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/hub.h b/drivers/usb/core/hub.h
index a9e24e4b8df1..a97dd1ba964e 100644
--- a/drivers/usb/core/hub.h
+++ b/drivers/usb/core/hub.h
@@ -61,6 +61,7 @@ struct usb_hub {
 	unsigned		quiescing:1;
 	unsigned		disconnected:1;
 	unsigned		in_reset:1;
+	unsigned		quirk_disable_autosuspend:1;
 
 	unsigned		quirk_check_port_auto_suspend:1;
 

commit 8eb58994dd96da7055721c68e46b732febe671ae
Author: Nicolas Saenz Julienne <nsaenzjulienne@suse.de>
Date:   Tue Jan 8 16:45:22 2019 +0100

    usb: hub: add retry routine after intr URB submit error
    
    The hub sends hot-plug events to the host trough it's interrupt URB. The
    driver takes care of completing the URB and re-submitting it. Completion
    errors are handled in the hub_event() work, yet submission errors are
    ignored, rendering the device unresponsive. All further events are lost.
    
    It is fairly hard to find this issue in the wild, since you have to time
    the USB hot-plug event with the URB submission failure. For instance it
    could be the system running out of memory or some malfunction in the USB
    controller driver. Nevertheless, it's pretty reasonable to think it'll
    happen sometime. One can trigger this issue using eBPF's function
    override feature (see BCC's inject.py script).
    
    This patch adds a retry routine to the event of a submission error. The
    HUB driver will try to re-submit the URB once every second until it's
    successful or the HUB is disconnected.
    
    As some USB subsystems already take care of this issue, the
    implementation was inspired from usbhid/hid_core.c's.
    
    Signed-off-by: Nicolas Saenz Julienne <nsaenzjulienne@suse.de>
    Reviewed-by: Oliver Neukum <oneukum@suse.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/hub.h b/drivers/usb/core/hub.h
index 4accfb63f7dc..a9e24e4b8df1 100644
--- a/drivers/usb/core/hub.h
+++ b/drivers/usb/core/hub.h
@@ -69,6 +69,8 @@ struct usb_hub {
 	struct delayed_work	leds;
 	struct delayed_work	init_work;
 	struct work_struct      events;
+	spinlock_t		irq_urb_lock;
+	struct timer_list	irq_urb_retry;
 	struct usb_port		**ports;
 };
 

commit 25244227158e1502062041365a439a54cb8fe673
Author: Nicolas Boichat <drinkcat@chromium.org>
Date:   Mon May 28 14:32:18 2018 +0800

    usb: hub: Per-port setting to use old enumeration scheme
    
    The "old" enumeration scheme is considerably faster (it takes
    ~244ms instead of ~356ms to get the descriptor).
    
    It is currently only possible to use the old scheme globally
    (/sys/module/usbcore/parameters/old_scheme_first), which is not
    desirable as the new scheme was introduced to increase compatibility
    with more devices.
    
    However, in our case, we care about time-to-active for a specific
    USB device (which we make the firmware for), on a specific port
    (that is pogo-pin based: not a standard USB port). This new
    sysfs option makes it possible to use the old scheme on a single
    port only.
    
    Signed-off-by: Nicolas Boichat <drinkcat@chromium.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/hub.h b/drivers/usb/core/hub.h
index 4dc769ee9c74..4accfb63f7dc 100644
--- a/drivers/usb/core/hub.h
+++ b/drivers/usb/core/hub.h
@@ -98,6 +98,7 @@ struct usb_port {
 	struct mutex status_lock;
 	u32 over_current_count;
 	u8 portnum;
+	u32 quirks;
 	unsigned int is_superspeed:1;
 	unsigned int usb3_lpm_u1_permit:1;
 	unsigned int usb3_lpm_u2_permit:1;

commit 1cbd53c8cd85a63383a075347abee8f6e3f14fbe
Author: Richard Leitner <richard.leitner@skidata.com>
Date:   Tue Mar 20 11:17:13 2018 +0100

    usb: core: introduce per-port over-current counters
    
    For some userspace applications information on the number of
    over-current conditions at specific USB hub ports is relevant.
    
    In our case we have a series of USB hardware (using the cp210x driver)
    which communicates using a proprietary protocol. These devices sometimes
    trigger an over-current situation on some hubs. In case of such an
    over-current situation the USB devices offer an interface for reducing
    the max used power. As these conditions are quite rare and imply
    performance reductions of the device we don't want to reduce the max
    power always.
    
    Therefore give user-space applications the possibility to react
    adequately by introducing an over_current_counter in the usb port struct
    which is exported via sysfs.
    
    Signed-off-by: Richard Leitner <richard.leitner@skidata.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/hub.h b/drivers/usb/core/hub.h
index 2a700ccc868c..4dc769ee9c74 100644
--- a/drivers/usb/core/hub.h
+++ b/drivers/usb/core/hub.h
@@ -96,6 +96,7 @@ struct usb_port {
 	enum usb_port_connect_type connect_type;
 	usb_port_location_t location;
 	struct mutex status_lock;
+	u32 over_current_count;
 	u8 portnum;
 	unsigned int is_superspeed:1;
 	unsigned int usb3_lpm_u1_permit:1;

commit f9d4d453db3a1b8e58705217e106db5b63a4d3fb
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Nov 3 12:41:02 2017 +0100

    USB: core: Remove redundant license text
    
    Now that the SPDX tag is in all USB files, that identifies the license
    in a specific and legally-defined manner.  So the extra GPL text wording
    can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/hub.h b/drivers/usb/core/hub.h
index 7d29bf3f095b..2a700ccc868c 100644
--- a/drivers/usb/core/hub.h
+++ b/drivers/usb/core/hub.h
@@ -9,15 +9,6 @@
  * Copyright (C) 2012 Intel Corp (tianyu.lan@intel.com)
  *
  *  move struct usb_hub to this file.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * for more details.
  */
 
 #include <linux/usb.h>

commit 5fd54ace4721fc5ce2bb5aef6318fcf17f421460
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Nov 3 11:28:30 2017 +0100

    USB: add SPDX identifiers to all remaining files in drivers/usb/
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/usb/ and include/linux/usb* files with the correct
    SPDX license identifier based on the license text in the file itself.
    The SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Acked-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/hub.h b/drivers/usb/core/hub.h
index 34c1a7e22aae..7d29bf3f095b 100644
--- a/drivers/usb/core/hub.h
+++ b/drivers/usb/core/hub.h
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * usb hub driver head file
  *

commit 0cdd49a1d1a483d80170d9e592f832274e8bce1b
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Thu Dec 10 09:59:29 2015 +0200

    usb: Support USB 3.1 extended port status request
    
    usb 3.1 extend the hub get-port-status request by adding different
    request types. the new request types return 4 additional bytes called
    extended port status, these bytes are returned after the regular
    portstatus and portchange values.
    
    The extended port status contains a speed ID for the currently used
    sublink speed. A table of supported Speed IDs with details about the link
    is provided by the hub in the device descriptor BOS SuperSpeedPlus
    device capability Sublink Speed Attributes.
    
    Support this new request. Ask for the extended port status after port
    reset if hub supports USB 3.1. If link is running at SuperSpeedPlus
    set the device speed to USB_SPEED_SUPER_PLUS
    
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/hub.h b/drivers/usb/core/hub.h
index 45d070dd1d03..34c1a7e22aae 100644
--- a/drivers/usb/core/hub.h
+++ b/drivers/usb/core/hub.h
@@ -140,6 +140,13 @@ static inline int hub_is_superspeed(struct usb_device *hdev)
 	return hdev->descriptor.bDeviceProtocol == USB_HUB_PR_SS;
 }
 
+static inline int hub_is_superspeedplus(struct usb_device *hdev)
+{
+	return (hdev->descriptor.bDeviceProtocol == USB_HUB_PR_SS &&
+		le16_to_cpu(hdev->descriptor.bcdUSB) >= 0x0310 &&
+		hdev->bos->ssp_cap);
+}
+
 static inline unsigned hub_power_on_good_delay(struct usb_hub *hub)
 {
 	unsigned delay = hub->descriptor->bPwrOn2PwrGood * 2;

commit 513072d90a8dfe4bf83e1f81810de605eb5d7c3b
Author: Lu Baolu <baolu.lu@linux.intel.com>
Date:   Sat Nov 14 16:26:33 2015 +0800

    usb: core: lpm: add sysfs node for usb3 lpm permit
    
    USB3 LPM is default on in Linux kernel if both xHCI host controller
    and the USB devices declare to be LPM-capable. Unfortunately, some
    devices are known to work well with LPM disabled, but to be broken
    if LPM is enabled, although it declares the LPM capability.  Users
    won't be able to use this kind of devices, until someone puts them
    in the kernel blacklist and gets the kernel upgraded.
    
    This patch adds a sysfs node to permit or forbit USB3 LPM U1 or U2
    entry for a port. The settings apply to both before and after device
    enumeration. Supported values are "0" - neither u1 nor u2 permitted,
    "u1" - only u1 is permitted, "u2" - only u2 is permitted, "u1_u2" -
    both u1 and u2 are permitted. With this interface, users can use an
    LPM-unfriendly USB device on a released Linux kernel.
    
    Signed-off-by: Lu Baolu <baolu.lu@linux.intel.com>
    Signed-off-by: Zhuang Jin Can <jin.can.zhuang@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/hub.h b/drivers/usb/core/hub.h
index 688817fb3246..45d070dd1d03 100644
--- a/drivers/usb/core/hub.h
+++ b/drivers/usb/core/hub.h
@@ -92,6 +92,8 @@ struct usb_hub {
  * @status_lock: synchronize port_event() vs usb_port_{suspend|resume}
  * @portnum: port index num based one
  * @is_superspeed cache super-speed status
+ * @usb3_lpm_u1_permit: whether USB3 U1 LPM is permitted.
+ * @usb3_lpm_u2_permit: whether USB3 U2 LPM is permitted.
  */
 struct usb_port {
 	struct usb_device *child;
@@ -104,6 +106,8 @@ struct usb_port {
 	struct mutex status_lock;
 	u8 portnum;
 	unsigned int is_superspeed:1;
+	unsigned int usb3_lpm_u1_permit:1;
+	unsigned int usb3_lpm_u2_permit:1;
 };
 
 #define to_usb_port(_dev) \
@@ -155,4 +159,3 @@ static inline int hub_port_debounce_be_stable(struct usb_hub *hub,
 {
 	return hub_port_debounce(hub, port1, false);
 }
-

commit 32a6958998c52e2b00c2f6459acf9a1f09f054ad
Author: Petr Mladek <pmladek@suse.cz>
Date:   Fri Sep 19 17:32:21 2014 +0200

    usb: hub: convert khubd into workqueue
    
    There is no need to have separate kthread for handling USB hub events.
    It is more elegant to use the workqueue framework.
    
    The workqueue is allocated as freezable because the original thread was
    freezable as well.
    
    Also it is allocated as ordered because the code is not ready for parallel
    processing of hub events, see choose_devnum().
    
    struct usb_hub is passed via the work item. Therefore we do not need
    hub_event_list.
    
    Also hub_thread() is not longer needed. It would call only hub_event().
    The rest of the code did manipulate the kthread and it is handled by the
    workqueue framework now.
    
    kick_khubd is renamed to kick_hub_wq() to make the function clear. And the
    protection against races is done another way, see below.
    
    hub_event_lock has been removed. It cannot longer be used to protect struct
    usb_hub between hub_event() and hub_disconnect(). Instead we need to get
    hub->kref already in kick_hub_wq().
    
    The lock is not really needed for the other scenarios as well. queue_work()
    returns whether it succeeded. We could revert the needed operations
    accordingly. This is enough to avoid duplicity and inconsistencies.
    
    Yes, the removed lock causes that there is not longer such a strong
    synchronization between scheduling the work and manipulating
    hub->disconnected.
    
    But kick_hub_wq() must never be called together with hub_disconnect()
    otherwise even the original code would have failed. Any callers are
    responsible for this.
    
    Therefore the only problem is that hub_disconnect() could be called in parallel
    with hub_event(). But this was possible even in the past. struct usb_hub is
    still guarded by hub->kref and released in hub_events() when needed.
    
    Note that the source file is still full of the obsolete "khubd" strings.
    Let's remove them in a follow up patch. This patch already is complex enough.
    
    Thanks a lot Alan Stern <stern@rowland.harvard.edu> for code review, many useful
    tips and guidance. Also thanks to Tejun Heo <tj@kernel.org> for hints how to
    allocate the workqueue.
    
    Signed-off-by: Petr Mladek <pmladek@suse.cz>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/hub.h b/drivers/usb/core/hub.h
index c77d8778af4b..688817fb3246 100644
--- a/drivers/usb/core/hub.h
+++ b/drivers/usb/core/hub.h
@@ -41,7 +41,6 @@ struct usb_hub {
 	int			error;		/* last reported error */
 	int			nerrors;	/* track consecutive errors */
 
-	struct list_head	event_list;	/* hubs w/data or errs ready */
 	unsigned long		event_bits[1];	/* status change bitmask */
 	unsigned long		change_bits[1];	/* ports with logical connect
 							status change */
@@ -77,6 +76,7 @@ struct usb_hub {
 	u8			indicator[USB_MAXCHILDREN];
 	struct delayed_work	leds;
 	struct delayed_work	init_work;
+	struct work_struct      events;
 	struct usb_port		**ports;
 };
 

commit 3cd12f91514da6893954de479dc60b16d3b381f4
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu May 29 12:58:46 2014 -0700

    usb: force warm reset to break link re-connect livelock
    
    Resuming a powered down port sometimes results in the port state being
    stuck in the training sequence.
    
     hub 3-0:1.0: debounce: port 1: total 2000ms stable 0ms status 0x2e0
     port1: can't get reconnection after setting port  power on, status -110
     hub 3-0:1.0: port 1 status 0000.02e0 after resume, -19
     usb 3-1: can't resume, status -19
     hub 3-0:1.0: logical disconnect on port 1
    
    In the case above we wait for the port re-connect timeout of 2 seconds
    and observe that the port status is USB_SS_PORT_LS_POLLING (although it
    is likely toggling between this state and USB_SS_PORT_LS_RX_DETECT).
    This is indicative of a case where the device is failing to progress the
    link training state machine.
    
    It is resolved by issuing a warm reset to get the hub and device link
    state machines back in sync.
    
     hub 3-0:1.0: debounce: port 1: total 2000ms stable 0ms status 0x2e0
     usb usb3: port1 usb_port_runtime_resume requires warm reset
     hub 3-0:1.0: port 1 not warm reset yet, waiting 50ms
     usb 3-1: reset SuperSpeed USB device number 2 using xhci_hcd
    
    After a reconnect timeout when we expect the device to be present, force
    a warm reset of the device.  Note that we can not simply look at the
    link status to determine if a warm reset is required as any of the
    training states USB_SS_PORT_LS_POLLING, USB_SS_PORT_LS_RX_DETECT, or
    USB_SS_PORT_LS_COMP_MOD are valid states that do not indicate the need
    for warm reset by themselves.
    
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Kukjin Kim <kgene.kim@samsung.com>
    Cc: Vincent Palatin <vpalatin@chromium.org>
    Cc: Lan Tianyu <tianyu.lan@intel.com>
    Cc: Ksenia Ragiadakou <burzalodowa@gmail.com>
    Cc: Vivek Gautam <gautam.vivek@samsung.com>
    Cc: Douglas Anderson <dianders@chromium.org>
    Cc: Felipe Balbi <balbi@ti.com>
    Cc: Sunil Joshi <joshi@samsung.com>
    Cc: Hans de Goede <hdegoede@redhat.com>
    Acked-by: Julius Werner <jwerner@chromium.org>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/hub.h b/drivers/usb/core/hub.h
index 326308e53961..c77d8778af4b 100644
--- a/drivers/usb/core/hub.h
+++ b/drivers/usb/core/hub.h
@@ -52,6 +52,8 @@ struct usb_hub {
 	unsigned long		power_bits[1]; /* ports that are powered */
 	unsigned long		child_usage_bits[1]; /* ports powered on for
 							children */
+	unsigned long		warm_reset_bits[1]; /* ports requesting warm
+							reset recovery */
 #if USB_MAXCHILDREN > 31 /* 8*sizeof(unsigned long) - 1 */
 #error event_bits[] is too short!
 #endif

commit e3d105055525d9ea9f8e9cb0db8237df3df1bb9f
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue Jun 17 16:16:32 2014 -0700

    usb: fix hub-port pm_runtime_enable() vs runtime pm transitions
    
    Commit 9262c19d14c4 "usb: disable port power control if not supported in
    wHubCharacteristics" gated enabling runtime pm for usb_port devices on
    whether the parent hub supports power control, which causes a
    regression.  The port must still be allowed to carry out runtime pm
    callbacks and receive a -EAGAIN or -EBUSY result.  Otherwise the
    usb_port device will transition to the pm error state and trigger the
    same for the child usb_device.
    
    Prior to the offending commit usb_hub_create_port_device() arranged for
    runtime pm to be disabled is dev_pm_qos_expose_flags() failed.  Instead,
    force the default state of PM_QOS_FLAG_NO_POWER_OFF flag to be set prior
    to enabling runtime pm.  If that policy can not be set then fail
    registration.
    
    Report: http://marc.info/?l=linux-usb&m=140290586301336&w=2
    Fixes: 9262c19d14c4 ("usb: disable port power control if not supported in wHubCharacteristics")
    Reported-by: Bjørn Mork <bjorn@mork.no>
    Reported-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/hub.h b/drivers/usb/core/hub.h
index 0a7cdc0ef0a9..326308e53961 100644
--- a/drivers/usb/core/hub.h
+++ b/drivers/usb/core/hub.h
@@ -84,6 +84,7 @@ struct usb_hub {
  * @dev: generic device interface
  * @port_owner: port's owner
  * @peer: related usb2 and usb3 ports (share the same connector)
+ * @req: default pm qos request for hubs without port power control
  * @connect_type: port's connect type
  * @location: opaque representation of platform connector location
  * @status_lock: synchronize port_event() vs usb_port_{suspend|resume}
@@ -95,6 +96,7 @@ struct usb_port {
 	struct device dev;
 	struct usb_dev_state *port_owner;
 	struct usb_port *peer;
+	struct dev_pm_qos_request *req;
 	enum usb_port_connect_type connect_type;
 	usb_port_location_t location;
 	struct mutex status_lock;

commit 5c79a1e303363d46082408fd306cdea6d33013fc
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue May 20 18:09:26 2014 -0700

    usb: introduce port status lock
    
    In general we do not want khubd to act on port status changes that are
    the result of in progress resets or USB runtime PM operations.
    Specifically port power control testing has been able to trigger an
    unintended disconnect in hub_port_connect_change(), paraphrasing:
    
            if ((portstatus & USB_PORT_STAT_CONNECTION) && udev &&
                udev->state != USB_STATE_NOTATTACHED) {
                    if (portstatus & USB_PORT_STAT_ENABLE) {
                            /* Nothing to do */
                    } else if (udev->state == USB_STATE_SUSPENDED &&
                                    udev->persist_enabled) {
                            ...
                    } else {
                            /* Don't resuscitate */;
                    }
            }
    
    ...by falling to the "Don't resuscitate" path or missing
    USB_PORT_STAT_CONNECTION because usb_port_resume() was in the middle of
    modifying the port status.
    
    So, we want a new lock to hold off khubd for a given port while the
    child device is being suspended, resumed, or reset.  The lock ordering
    rules are now usb_lock_device() => usb_lock_port().  This is mandated by
    the device core which may hold the device_lock on the usb_device before
    invoking usb_port_{suspend|resume} which in turn take the status_lock on
    the usb_port.  We attempt to hold the status_lock for the duration of a
    port_event() run, and drop/re-acquire it when needing to take the
    device_lock.  The lock is also dropped/re-acquired during
    hub_port_reconnect().
    
    This patch also deletes hub->busy_bits as all use cases are now covered
    by port PM runtime synchronization or the port->status_lock and it
    pushes down usb_device_lock() into usb_remote_wakeup().
    
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/hub.h b/drivers/usb/core/hub.h
index 906c355e0631..0a7cdc0ef0a9 100644
--- a/drivers/usb/core/hub.h
+++ b/drivers/usb/core/hub.h
@@ -45,8 +45,6 @@ struct usb_hub {
 	unsigned long		event_bits[1];	/* status change bitmask */
 	unsigned long		change_bits[1];	/* ports with logical connect
 							status change */
-	unsigned long		busy_bits[1];	/* ports being reset or
-							resumed */
 	unsigned long		removed_bits[1]; /* ports with a "removed"
 							device present */
 	unsigned long		wakeup_bits[1];	/* ports that have signaled
@@ -88,6 +86,7 @@ struct usb_hub {
  * @peer: related usb2 and usb3 ports (share the same connector)
  * @connect_type: port's connect type
  * @location: opaque representation of platform connector location
+ * @status_lock: synchronize port_event() vs usb_port_{suspend|resume}
  * @portnum: port index num based one
  * @is_superspeed cache super-speed status
  */
@@ -98,6 +97,7 @@ struct usb_port {
 	struct usb_port *peer;
 	enum usb_port_connect_type connect_type;
 	usb_port_location_t location;
+	struct mutex status_lock;
 	u8 portnum;
 	unsigned int is_superspeed:1;
 };

commit 7ad3c47088f9faec463f5226e5e968a5c3b0e593
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue May 20 18:08:57 2014 -0700

    usb: block suspension of superspeed port while hispeed peer is active
    
    ClearPortFeature(PORT_POWER) on a usb3 port places the port in either a
    DSPORT.Powered-off-detect / DSPORT.Powered-off-reset loop, or the
    DSPORT.Powered-off state.  There is no way to ensure that RX
    terminations will persist in this state, so it is possible a device will
    degrade to its usb2 connection.  Prevent this by blocking power-off of a
    usb3 port while its usb2 peer is active, and powering on a usb3 port
    before its usb2 peer.
    
    By default the latency between peer power-on events is 0.  In order for
    the device to not see usb2 active while usb3 is still powering up inject
    the hub recommended power_on_good delay.  In support of satisfying the
    power_on_good delay outside of hub_power_on() refactor the places where
    the delay is consumed to call a new hub_power_on_good_delay() helper.
    
    Finally, because this introduces several new checks for whether a port
    is_superspeed, cache that disctinction at port creation so that we don't
    need to keep looking up the parent hub device.
    
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    [alan]: add a 'superspeed' flag to the port
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/hub.h b/drivers/usb/core/hub.h
index 3ef1c2e435cc..906c355e0631 100644
--- a/drivers/usb/core/hub.h
+++ b/drivers/usb/core/hub.h
@@ -89,6 +89,7 @@ struct usb_hub {
  * @connect_type: port's connect type
  * @location: opaque representation of platform connector location
  * @portnum: port index num based one
+ * @is_superspeed cache super-speed status
  */
 struct usb_port {
 	struct usb_device *child;
@@ -98,6 +99,7 @@ struct usb_port {
 	enum usb_port_connect_type connect_type;
 	usb_port_location_t location;
 	u8 portnum;
+	unsigned int is_superspeed:1;
 };
 
 #define to_usb_port(_dev) \
@@ -125,6 +127,19 @@ static inline bool hub_is_port_power_switchable(struct usb_hub *hub)
 	return (le16_to_cpu(hcs) & HUB_CHAR_LPSM) < HUB_CHAR_NO_LPSM;
 }
 
+static inline int hub_is_superspeed(struct usb_device *hdev)
+{
+	return hdev->descriptor.bDeviceProtocol == USB_HUB_PR_SS;
+}
+
+static inline unsigned hub_power_on_good_delay(struct usb_hub *hub)
+{
+	unsigned delay = hub->descriptor->bPwrOn2PwrGood * 2;
+
+	/* Wait at least 100 msec for power to become stable */
+	return max(delay, 100U);
+}
+
 static inline int hub_port_debounce_be_connected(struct usb_hub *hub,
 		int port1)
 {

commit d5c3834e4af3acc4d7fc52faba2711c666655632
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue May 20 18:08:52 2014 -0700

    usb: make usb_port flags atomic, rename did_runtime_put to child_usage
    
    We want to manipulate ->did_runtime_put in usb_port_runtime_resume(),
    but we don't want that to collide with other updates.  Move usb_port
    flags to new port-bitmap fields in usb_hub. "did_runtime_put" is renamed
    "child_usage_bits" to reflect that it is strictly standing in for the
    fact that usb_devices are not the device_model children of their parent
    port.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/hub.h b/drivers/usb/core/hub.h
index 048c797f394c..3ef1c2e435cc 100644
--- a/drivers/usb/core/hub.h
+++ b/drivers/usb/core/hub.h
@@ -51,6 +51,9 @@ struct usb_hub {
 							device present */
 	unsigned long		wakeup_bits[1];	/* ports that have signaled
 							remote wakeup */
+	unsigned long		power_bits[1]; /* ports that are powered */
+	unsigned long		child_usage_bits[1]; /* ports powered on for
+							children */
 #if USB_MAXCHILDREN > 31 /* 8*sizeof(unsigned long) - 1 */
 #error event_bits[] is too short!
 #endif
@@ -86,8 +89,6 @@ struct usb_hub {
  * @connect_type: port's connect type
  * @location: opaque representation of platform connector location
  * @portnum: port index num based one
- * @power_is_on: port's power state
- * @did_runtime_put: port has done pm_runtime_put().
  */
 struct usb_port {
 	struct usb_device *child;
@@ -97,8 +98,6 @@ struct usb_port {
 	enum usb_port_connect_type connect_type;
 	usb_port_location_t location;
 	u8 portnum;
-	unsigned power_is_on:1;
-	unsigned did_runtime_put:1;
 };
 
 #define to_usb_port(_dev) \

commit 3bfd659baec822f54e4acb0734669e671d853a35
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue May 20 18:08:40 2014 -0700

    usb: find internal hub tier mismatch via acpi
    
    ACPI identifies peer ports by setting their 'group_token' and
    'group_position' _PLD data to the same value.  If a platform has tier
    mismatch [1] , ACPI can override the default (USB3 defined) peer port
    association for internal hubs.  External hubs follow the default peer
    association scheme.
    
    Location data is cached as an opaque cookie in usb_port_location data.
    
    Note that we only consider the group_token and group_position attributes
    from the _PLD data as ACPI specifies that group_token is a unique
    identifier.
    
    When we find port location data for a port then we assume that the
    firmware will also describe its peer port.  This allows the
    implementation to only ever set the peer once.  This leads to a question
    about what happens when a pm runtime event occurs while the peer
    associations are still resolving.  Since we only ever set the peer
    information once, a USB3 port needs to be prevented from suspending
    while its ->peer pointer is NULL (implemented in a subsequent patch).
    
    There is always the possibility that firmware mis-identifies the ports,
    but there is not much the kernel can do in that case.
    
    [1]: xhci 1.1 appendix D figure 131
    [2]: acpi 5 section 6.1.8
    
    [alan]: don't do default peering when acpi data present
    Suggested-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/hub.h b/drivers/usb/core/hub.h
index fcad5f9d12f0..048c797f394c 100644
--- a/drivers/usb/core/hub.h
+++ b/drivers/usb/core/hub.h
@@ -84,6 +84,7 @@ struct usb_hub {
  * @port_owner: port's owner
  * @peer: related usb2 and usb3 ports (share the same connector)
  * @connect_type: port's connect type
+ * @location: opaque representation of platform connector location
  * @portnum: port index num based one
  * @power_is_on: port's power state
  * @did_runtime_put: port has done pm_runtime_put().
@@ -94,6 +95,7 @@ struct usb_port {
 	struct usb_dev_state *port_owner;
 	struct usb_port *peer;
 	enum usb_port_connect_type connect_type;
+	usb_port_location_t location;
 	u8 portnum;
 	unsigned power_is_on:1;
 	unsigned did_runtime_put:1;

commit d8521afe35862f4fbe3ccd6ca37897c0a304edf3
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue May 20 18:08:28 2014 -0700

    usb: assign default peer ports for root hubs
    
    Assume that the peer of a superspeed port is the port with the same id
    on the shared_hcd root hub.  This identification scheme is required of
    external hubs by the USB3 spec [1].  However, for root hubs, tier mismatch
    may be in effect [2].  Tier mismatch can only be enumerated via platform
    firmware.  For now, simply perform the nominal association.
    
    A new lock 'usb_port_peer_mutex' is introduced to synchronize port
    device add/remove with peer lookups.  It protects peering against
    changes to hcd->shared_hcd, hcd->self.root_hub, hdev->maxchild, and
    port_dev->child pointers.
    
    [1]: usb 3.1 section 10.3.3
    [2]: xhci 1.1 appendix D
    
    Cc: Alan Stern <stern@rowland.harvard.edu>
    [alan: usb_port_peer_mutex locking scheme]
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/hub.h b/drivers/usb/core/hub.h
index 4bd72dd303d5..fcad5f9d12f0 100644
--- a/drivers/usb/core/hub.h
+++ b/drivers/usb/core/hub.h
@@ -82,6 +82,7 @@ struct usb_hub {
  * @child: usb device attached to the port
  * @dev: generic device interface
  * @port_owner: port's owner
+ * @peer: related usb2 and usb3 ports (share the same connector)
  * @connect_type: port's connect type
  * @portnum: port index num based one
  * @power_is_on: port's power state
@@ -91,6 +92,7 @@ struct usb_port {
 	struct usb_device *child;
 	struct device dev;
 	struct usb_dev_state *port_owner;
+	struct usb_port *peer;
 	enum usb_port_connect_type connect_type;
 	u8 portnum;
 	unsigned power_is_on:1;

commit 9262c19d14c433a6a1ba25c3ff897cb89e412309
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue May 20 18:08:12 2014 -0700

    usb: disable port power control if not supported in wHubCharacteristics
    
    A hub indicates whether it supports per-port power control via the
    wHubCharacteristics field in its descriptor.  If it is not supported
    a hub will still emulate ClearPortPower(PORT_POWER) requests by
    stopping the link state machine.  However, since this does not save
    power do not bother suspending.
    
    This also consolidates support checks into a
    hub_is_port_power_switchable() helper.
    
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/hub.h b/drivers/usb/core/hub.h
index f9b521e60128..4bd72dd303d5 100644
--- a/drivers/usb/core/hub.h
+++ b/drivers/usb/core/hub.h
@@ -112,6 +112,16 @@ extern int hub_port_debounce(struct usb_hub *hub, int port1,
 extern int usb_clear_port_feature(struct usb_device *hdev,
 		int port1, int feature);
 
+static inline bool hub_is_port_power_switchable(struct usb_hub *hub)
+{
+	__le16 hcs;
+
+	if (!hub)
+		return false;
+	hcs = hub->descriptor->wHubCharacteristics;
+	return (le16_to_cpu(hcs) & HUB_CHAR_LPSM) < HUB_CHAR_NO_LPSM;
+}
+
 static inline int hub_port_debounce_be_connected(struct usb_hub *hub,
 		int port1)
 {

commit 600856c231ccb0cbf8afcf09066a8ab2a93ab03d
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue May 20 18:08:07 2014 -0700

    USB: mutual exclusion for resetting a hub and power-managing a port
    
    The USB core doesn't properly handle mutual exclusion between
    resetting a hub and changing the power states of the hub's ports.  We
    need to avoid sending port-power requests to the hub while it is being
    reset, because such requests cannot succeed.
    
    This patch fixes the problem by keeping track of when a reset is in
    progress.  At such times, attempts to suspend (power-off) a port will
    fail immediately with -EBUSY, and calls to usb_port_runtime_resume()
    will update the power_is_on flag and return immediately.  When the
    reset is complete, hub_activate() will automatically restore each port
    to the proper power state.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/hub.h b/drivers/usb/core/hub.h
index 33bcb2c6f90a..f9b521e60128 100644
--- a/drivers/usb/core/hub.h
+++ b/drivers/usb/core/hub.h
@@ -66,6 +66,7 @@ struct usb_hub {
 	unsigned		limited_power:1;
 	unsigned		quiescing:1;
 	unsigned		disconnected:1;
+	unsigned		in_reset:1;
 
 	unsigned		quirk_check_port_auto_suspend:1;
 

commit 9b6f0c4b98171f2a354e1e461fefa90ec2baafa6
Author: Valentina Manea <valentina.manea.m@gmail.com>
Date:   Mon Mar 10 10:36:40 2014 +0200

    usbcore: rename struct dev_state to struct usb_dev_state
    
    Since it is needed outside usbcore and exposed in include/linux/usb.h,
    it conflicts with enum dev_state in rt2x00 wireless driver.
    
    Mark it as usb specific to avoid conflicts in the future.
    
    Signed-off-by: Valentina Manea <valentina.manea.m@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/hub.h b/drivers/usb/core/hub.h
index df629a310e44..33bcb2c6f90a 100644
--- a/drivers/usb/core/hub.h
+++ b/drivers/usb/core/hub.h
@@ -89,7 +89,7 @@ struct usb_hub {
 struct usb_port {
 	struct usb_device *child;
 	struct device dev;
-	struct dev_state *port_owner;
+	struct usb_dev_state *port_owner;
 	enum usb_port_connect_type connect_type;
 	u8 portnum;
 	unsigned power_is_on:1;

commit 025d44309f92bd5e3d1b2c7fab66836ab25b541b
Author: Rahul Bedarkar <rahulbedarkar89@gmail.com>
Date:   Sat Jan 4 11:24:41 2014 +0530

    USB: core: correct spelling mistakes in comments and warning
    
    Signed-off-by: Rahul Bedarkar <rahulbedarkar89@gmail.com>
    Acked-by: Randy Dunlap <rdunlap@infradead.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/hub.h b/drivers/usb/core/hub.h
index 4e4790dea343..df629a310e44 100644
--- a/drivers/usb/core/hub.h
+++ b/drivers/usb/core/hub.h
@@ -78,7 +78,7 @@ struct usb_hub {
 
 /**
  * struct usb port - kernel's representation of a usb port
- * @child: usb device attatched to the port
+ * @child: usb device attached to the port
  * @dev: generic device interface
  * @port_owner: port's owner
  * @connect_type: port's connect type

commit e583d9db9960cf40e0bc8afee4946baa9d71596e
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Thu Jul 11 14:58:04 2013 -0400

    USB: global suspend and remote wakeup don't mix
    
    The hub driver was recently changed to use "global" suspend for system
    suspend transitions on non-SuperSpeed buses.  This means that we don't
    suspend devices individually by setting the suspend feature on the
    upstream hub port; instead devices all go into suspend automatically
    when the root hub stops transmitting packets.  The idea was to save
    time and to avoid certain kinds of wakeup races.
    
    Now it turns out that many hubs are buggy; they don't relay wakeup
    requests from a downstream port to their upstream port if the
    downstream port's suspend feature is not set (depending on the speed
    of the downstream port, whether or not the hub is enabled for remote
    wakeup, and possibly other factors).
    
    We can't have hubs dropping wakeup requests.  Therefore this patch
    goes partway back to the old policy: It sets the suspend feature for a
    port if the device attached to that port or any of its descendants is
    enabled for wakeup.  People will still be able to benefit from the
    time savings if they don't care about wakeup and leave it disabled on
    all their devices.
    
    In order to accomplish this, the patch adds a new field to the usb_hub
    structure: wakeup_enabled_descendants is a count of how many devices
    below a suspended hub are enabled for remote wakeup.  A corresponding
    new subroutine determines the number of wakeup-enabled devices at or
    below an arbitrary suspended USB device.
    
    This should be applied to the 3.10 stable kernel.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Reported-and-tested-by: Toralf Förster <toralf.foerster@gmx.de>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/hub.h b/drivers/usb/core/hub.h
index 6508e02b3dac..4e4790dea343 100644
--- a/drivers/usb/core/hub.h
+++ b/drivers/usb/core/hub.h
@@ -59,6 +59,9 @@ struct usb_hub {
 	struct usb_tt		tt;		/* Transaction Translator */
 
 	unsigned		mA_per_port;	/* current for each child */
+#ifdef	CONFIG_PM
+	unsigned		wakeup_enabled_descendants;
+#endif
 
 	unsigned		limited_power:1;
 	unsigned		quiescing:1;

commit 41341261aa1707b49f937ba2c20d1a0daa5afac3
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Tue Jun 18 17:28:48 2013 +0300

    usb: check usb_hub_to_struct_hub() return value
    
    usb_hub_to_struct_hub() can return NULL in some unlikely cases.
    Add checks where appropriate, or pass the hub pointer as an additional
    argument if it's known to be valid.
    
    The places it makes sense to check usb_hub_to_struct_hub()
    are picked based on feedback from Alan Stern.
    
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/hub.h b/drivers/usb/core/hub.h
index 80ab9ee07017..6508e02b3dac 100644
--- a/drivers/usb/core/hub.h
+++ b/drivers/usb/core/hub.h
@@ -100,7 +100,7 @@ extern int usb_hub_create_port_device(struct usb_hub *hub,
 		int port1);
 extern void usb_hub_remove_port_device(struct usb_hub *hub,
 		int port1);
-extern int usb_hub_set_port_power(struct usb_device *hdev,
+extern int usb_hub_set_port_power(struct usb_device *hdev, struct usb_hub *hub,
 		int port1, bool set);
 extern struct usb_hub *usb_hub_to_struct_hub(struct usb_device *hdev);
 extern int hub_port_debounce(struct usb_hub *hub, int port1,

commit ad493e5e580546e6c3024b76a41535476da1546a
Author: Lan Tianyu <tianyu.lan@intel.com>
Date:   Wed Jan 23 04:26:30 2013 +0800

    usb: add usb port auto power off mechanism
    
    This patch is to add usb port auto power off mechanism.
    When usb device is suspending, usb core will suspend usb port and
    usb port runtime pm callback will clear PORT_POWER feature to
    power off port if all conditions were met. These conditions are
    remote wakeup disable, pm qos NO_POWER_OFF flag clear and persist
    enable. When it resumes, power on port again.
    
    Add did_runtime_put in the struct usb_port to ensure
    pm_runtime_get/put(portdev) to be called pairedly.  Set did_runtime_put
    to true when call pm_runtime_put(portdev) during suspending. The
    pm_runtime_get(portdev) only will be called when did_runtime_put
    is set to true during resuming. Set did_runtime_put to false after
    calling pm_runtime_get(portdev).
    
    Make clear_port_feature() and hdev_to_hub() as global symbol.
    Rename clear_port_feature() to usb_clear_port_feature() and
    hdev_to_hub() to usb_hub_to_struct_hub().
    
    Extend hub_port_debounce() with the fuction of debouncing to
    be connected. Add two wraps: hub_port_debounce_be_connected()
    and hub_port_debouce_be_stable().
    
    Increase HUB_DEBOUNCE_TIMEOUT to 2000 because some usb ssds
    needs around 1.5 or more to make the hub port status to be
    connected steadily after being powered off and powered on.
    
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Lan Tianyu <tianyu.lan@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/hub.h b/drivers/usb/core/hub.h
index 452e5cd7b249..80ab9ee07017 100644
--- a/drivers/usb/core/hub.h
+++ b/drivers/usb/core/hub.h
@@ -80,6 +80,8 @@ struct usb_hub {
  * @port_owner: port's owner
  * @connect_type: port's connect type
  * @portnum: port index num based one
+ * @power_is_on: port's power state
+ * @did_runtime_put: port has done pm_runtime_put().
  */
 struct usb_port {
 	struct usb_device *child;
@@ -87,6 +89,8 @@ struct usb_port {
 	struct dev_state *port_owner;
 	enum usb_port_connect_type connect_type;
 	u8 portnum;
+	unsigned power_is_on:1;
+	unsigned did_runtime_put:1;
 };
 
 #define to_usb_port(_dev) \
@@ -98,4 +102,21 @@ extern void usb_hub_remove_port_device(struct usb_hub *hub,
 		int port1);
 extern int usb_hub_set_port_power(struct usb_device *hdev,
 		int port1, bool set);
+extern struct usb_hub *usb_hub_to_struct_hub(struct usb_device *hdev);
+extern int hub_port_debounce(struct usb_hub *hub, int port1,
+		bool must_be_connected);
+extern int usb_clear_port_feature(struct usb_device *hdev,
+		int port1, int feature);
+
+static inline int hub_port_debounce_be_connected(struct usb_hub *hub,
+		int port1)
+{
+	return hub_port_debounce(hub, port1, true);
+}
+
+static inline int hub_port_debounce_be_stable(struct usb_hub *hub,
+		int port1)
+{
+	return hub_port_debounce(hub, port1, false);
+}
 

commit 971fcd492cebf544714f12d94549d2f0d2002645
Author: Lan Tianyu <tianyu.lan@intel.com>
Date:   Wed Jan 23 04:26:29 2013 +0800

    usb: add runtime pm support for usb port device
    
    This patch is to add runtime pm callback for usb port device.
    Set/clear PORT_POWER feature in the resume/suspend callback.
    Add portnum for struct usb_port to record port number. Do
    pm_rumtime_get_sync/put(portdev) when a device is plugged/unplugged
    to prevent it from being powered off when it is active.
    
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Lan Tianyu <tianyu.lan@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/hub.h b/drivers/usb/core/hub.h
index c472058f8f27..452e5cd7b249 100644
--- a/drivers/usb/core/hub.h
+++ b/drivers/usb/core/hub.h
@@ -79,12 +79,14 @@ struct usb_hub {
  * @dev: generic device interface
  * @port_owner: port's owner
  * @connect_type: port's connect type
+ * @portnum: port index num based one
  */
 struct usb_port {
 	struct usb_device *child;
 	struct device dev;
 	struct dev_state *port_owner;
 	enum usb_port_connect_type connect_type;
+	u8 portnum;
 };
 
 #define to_usb_port(_dev) \
@@ -94,4 +96,6 @@ extern int usb_hub_create_port_device(struct usb_hub *hub,
 		int port1);
 extern void usb_hub_remove_port_device(struct usb_hub *hub,
 		int port1);
+extern int usb_hub_set_port_power(struct usb_device *hdev,
+		int port1, bool set);
 

commit bdb6bc06f7d694652c12fb8779bb031c2f220823
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Thu Jan 24 15:04:13 2013 -0500

    USB: fix sign-extension bug in the hub driver
    
    This patch (as1646) fixes a long-standing bug in the USB hub driver.
    Upon conversion from char to unsigned long, the bytes in the status
    buffer are subject to unwanted sign extension.  The bytes should be
    declared as u8 rather than char, to prevent this.
    
    This effects of this bug are minimal.  The hub driver may end up doing
    a little unnecessary extra work because it thinks events have occurred
    on some ports when they really haven't.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/hub.h b/drivers/usb/core/hub.h
index d16a7c98aea9..c472058f8f27 100644
--- a/drivers/usb/core/hub.h
+++ b/drivers/usb/core/hub.h
@@ -31,7 +31,7 @@ struct usb_hub {
 	struct urb		*urb;		/* for interrupt polling pipe */
 
 	/* buffer for urb ... with extra space in case of babble */
-	char			(*buffer)[8];
+	u8			(*buffer)[8];
 	union {
 		struct usb_hub_status	hub;
 		struct usb_port_status	port;

commit 6e30d7cba992d626c9d16b3873a7b90c700d0e95
Author: Lan Tianyu <tianyu.lan@intel.com>
Date:   Fri Jan 11 20:10:38 2013 +0800

    usb: Add driver/usb/core/(port.c,hub.h) files
    
    This patch is to create driver/usb/core/(port.c,hub.h) files and move usb
    port related code into port.c.
    
    Signed-off-by: Lan Tianyu <tianyu.lan@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/hub.h b/drivers/usb/core/hub.h
new file mode 100644
index 000000000000..d16a7c98aea9
--- /dev/null
+++ b/drivers/usb/core/hub.h
@@ -0,0 +1,97 @@
+/*
+ * usb hub driver head file
+ *
+ * Copyright (C) 1999 Linus Torvalds
+ * Copyright (C) 1999 Johannes Erdfelt
+ * Copyright (C) 1999 Gregory P. Smith
+ * Copyright (C) 2001 Brad Hards (bhards@bigpond.net.au)
+ * Copyright (C) 2012 Intel Corp (tianyu.lan@intel.com)
+ *
+ *  move struct usb_hub to this file.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ */
+
+#include <linux/usb.h>
+#include <linux/usb/ch11.h>
+#include <linux/usb/hcd.h>
+#include "usb.h"
+
+struct usb_hub {
+	struct device		*intfdev;	/* the "interface" device */
+	struct usb_device	*hdev;
+	struct kref		kref;
+	struct urb		*urb;		/* for interrupt polling pipe */
+
+	/* buffer for urb ... with extra space in case of babble */
+	char			(*buffer)[8];
+	union {
+		struct usb_hub_status	hub;
+		struct usb_port_status	port;
+	}			*status;	/* buffer for status reports */
+	struct mutex		status_mutex;	/* for the status buffer */
+
+	int			error;		/* last reported error */
+	int			nerrors;	/* track consecutive errors */
+
+	struct list_head	event_list;	/* hubs w/data or errs ready */
+	unsigned long		event_bits[1];	/* status change bitmask */
+	unsigned long		change_bits[1];	/* ports with logical connect
+							status change */
+	unsigned long		busy_bits[1];	/* ports being reset or
+							resumed */
+	unsigned long		removed_bits[1]; /* ports with a "removed"
+							device present */
+	unsigned long		wakeup_bits[1];	/* ports that have signaled
+							remote wakeup */
+#if USB_MAXCHILDREN > 31 /* 8*sizeof(unsigned long) - 1 */
+#error event_bits[] is too short!
+#endif
+
+	struct usb_hub_descriptor *descriptor;	/* class descriptor */
+	struct usb_tt		tt;		/* Transaction Translator */
+
+	unsigned		mA_per_port;	/* current for each child */
+
+	unsigned		limited_power:1;
+	unsigned		quiescing:1;
+	unsigned		disconnected:1;
+
+	unsigned		quirk_check_port_auto_suspend:1;
+
+	unsigned		has_indicators:1;
+	u8			indicator[USB_MAXCHILDREN];
+	struct delayed_work	leds;
+	struct delayed_work	init_work;
+	struct usb_port		**ports;
+};
+
+/**
+ * struct usb port - kernel's representation of a usb port
+ * @child: usb device attatched to the port
+ * @dev: generic device interface
+ * @port_owner: port's owner
+ * @connect_type: port's connect type
+ */
+struct usb_port {
+	struct usb_device *child;
+	struct device dev;
+	struct dev_state *port_owner;
+	enum usb_port_connect_type connect_type;
+};
+
+#define to_usb_port(_dev) \
+	container_of(_dev, struct usb_port, dev)
+
+extern int usb_hub_create_port_device(struct usb_hub *hub,
+		int port1);
+extern void usb_hub_remove_port_device(struct usb_hub *hub,
+		int port1);
+

commit d65d7e7ef3dc5e61e4dfaac54ec6d3e97f9a1108
Author: Eric Lescouet <Eric.Lescouet@virtuallogix.com>
Date:   Sat Apr 24 23:34:27 2010 +0200

    USB: make hub.h public (drivers dependency)
    
    The usbcore headers: hcd.h and hub.h are shared between usbcore,
    HCDs and a couple of other drivers (e.g. USBIP modules).
    So, it makes sense to move them into a more public location and
    to cleanup dependency of those modules on kernel internal headers.
    This patch moves hub.h from drivers/usb/core into include/linux/usb/
    
    Signed-of-by: Eric Lescouet <eric@lescouet.org>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/hub.h b/drivers/usb/core/hub.h
deleted file mode 100644
index de8081f065ed..000000000000
--- a/drivers/usb/core/hub.h
+++ /dev/null
@@ -1,205 +0,0 @@
-#ifndef __LINUX_HUB_H
-#define __LINUX_HUB_H
-
-/*
- * Hub protocol and driver data structures.
- *
- * Some of these are known to the "virtual root hub" code
- * in host controller drivers.
- */
-
-#include <linux/list.h>
-#include <linux/workqueue.h>
-#include <linux/compiler.h>	/* likely()/unlikely() */
-
-/*
- * Hub request types
- */
-
-#define USB_RT_HUB	(USB_TYPE_CLASS | USB_RECIP_DEVICE)
-#define USB_RT_PORT	(USB_TYPE_CLASS | USB_RECIP_OTHER)
-
-/*
- * Hub class requests
- * See USB 2.0 spec Table 11-16
- */
-#define HUB_CLEAR_TT_BUFFER	8
-#define HUB_RESET_TT		9
-#define HUB_GET_TT_STATE	10
-#define HUB_STOP_TT		11
-
-/*
- * Hub Class feature numbers
- * See USB 2.0 spec Table 11-17
- */
-#define C_HUB_LOCAL_POWER	0
-#define C_HUB_OVER_CURRENT	1
-
-/*
- * Port feature numbers
- * See USB 2.0 spec Table 11-17
- */
-#define USB_PORT_FEAT_CONNECTION	0
-#define USB_PORT_FEAT_ENABLE		1
-#define USB_PORT_FEAT_SUSPEND		2	/* L2 suspend */
-#define USB_PORT_FEAT_OVER_CURRENT	3
-#define USB_PORT_FEAT_RESET		4
-#define USB_PORT_FEAT_L1		5	/* L1 suspend */
-#define USB_PORT_FEAT_POWER		8
-#define USB_PORT_FEAT_LOWSPEED		9
-/* This value was never in Table 11-17 */
-#define USB_PORT_FEAT_HIGHSPEED		10
-/* This value is also fake */
-#define USB_PORT_FEAT_SUPERSPEED	11
-#define USB_PORT_FEAT_C_CONNECTION	16
-#define USB_PORT_FEAT_C_ENABLE		17
-#define USB_PORT_FEAT_C_SUSPEND		18
-#define USB_PORT_FEAT_C_OVER_CURRENT	19
-#define USB_PORT_FEAT_C_RESET		20
-#define USB_PORT_FEAT_TEST              21
-#define USB_PORT_FEAT_INDICATOR         22
-#define USB_PORT_FEAT_C_PORT_L1         23
-
-/*
- * Hub Status and Hub Change results
- * See USB 2.0 spec Table 11-19 and Table 11-20
- */
-struct usb_port_status {
-	__le16 wPortStatus;
-	__le16 wPortChange;
-} __attribute__ ((packed));
-
-/*
- * wPortStatus bit field
- * See USB 2.0 spec Table 11-21
- */
-#define USB_PORT_STAT_CONNECTION	0x0001
-#define USB_PORT_STAT_ENABLE		0x0002
-#define USB_PORT_STAT_SUSPEND		0x0004
-#define USB_PORT_STAT_OVERCURRENT	0x0008
-#define USB_PORT_STAT_RESET		0x0010
-#define USB_PORT_STAT_L1		0x0020
-/* bits 6 to 7 are reserved */
-#define USB_PORT_STAT_POWER		0x0100
-#define USB_PORT_STAT_LOW_SPEED		0x0200
-#define USB_PORT_STAT_HIGH_SPEED        0x0400
-#define USB_PORT_STAT_TEST              0x0800
-#define USB_PORT_STAT_INDICATOR         0x1000
-/* bits 13 to 15 are reserved */
-
-/*
- * wPortChange bit field
- * See USB 2.0 spec Table 11-22
- * Bits 0 to 4 shown, bits 5 to 15 are reserved
- */
-#define USB_PORT_STAT_C_CONNECTION	0x0001
-#define USB_PORT_STAT_C_ENABLE		0x0002
-#define USB_PORT_STAT_C_SUSPEND		0x0004
-#define USB_PORT_STAT_C_OVERCURRENT	0x0008
-#define USB_PORT_STAT_C_RESET		0x0010
-#define USB_PORT_STAT_C_L1		0x0020
-
-/*
- * wHubCharacteristics (masks)
- * See USB 2.0 spec Table 11-13, offset 3
- */
-#define HUB_CHAR_LPSM		0x0003 /* D1 .. D0 */
-#define HUB_CHAR_COMPOUND	0x0004 /* D2       */
-#define HUB_CHAR_OCPM		0x0018 /* D4 .. D3 */
-#define HUB_CHAR_TTTT           0x0060 /* D6 .. D5 */
-#define HUB_CHAR_PORTIND        0x0080 /* D7       */
-
-struct usb_hub_status {
-	__le16 wHubStatus;
-	__le16 wHubChange;
-} __attribute__ ((packed));
-
-/*
- * Hub Status & Hub Change bit masks
- * See USB 2.0 spec Table 11-19 and Table 11-20
- * Bits 0 and 1 for wHubStatus and wHubChange
- * Bits 2 to 15 are reserved for both
- */
-#define HUB_STATUS_LOCAL_POWER	0x0001
-#define HUB_STATUS_OVERCURRENT	0x0002
-#define HUB_CHANGE_LOCAL_POWER	0x0001
-#define HUB_CHANGE_OVERCURRENT	0x0002
-
-
-/*
- * Hub descriptor
- * See USB 2.0 spec Table 11-13
- */
-
-#define USB_DT_HUB			(USB_TYPE_CLASS | 0x09)
-#define USB_DT_HUB_NONVAR_SIZE		7
-
-struct usb_hub_descriptor {
-	__u8  bDescLength;
-	__u8  bDescriptorType;
-	__u8  bNbrPorts;
-	__le16 wHubCharacteristics;
-	__u8  bPwrOn2PwrGood;
-	__u8  bHubContrCurrent;
-		/* add 1 bit for hub status change; round to bytes */
-	__u8  DeviceRemovable[(USB_MAXCHILDREN + 1 + 7) / 8];
-	__u8  PortPwrCtrlMask[(USB_MAXCHILDREN + 1 + 7) / 8];
-} __attribute__ ((packed));
-
-
-/* port indicator status selectors, tables 11-7 and 11-25 */
-#define HUB_LED_AUTO	0
-#define HUB_LED_AMBER	1
-#define HUB_LED_GREEN	2
-#define HUB_LED_OFF	3
-
-enum hub_led_mode {
-	INDICATOR_AUTO = 0,
-	INDICATOR_CYCLE,
-	/* software blinks for attention:  software, hardware, reserved */
-	INDICATOR_GREEN_BLINK, INDICATOR_GREEN_BLINK_OFF,
-	INDICATOR_AMBER_BLINK, INDICATOR_AMBER_BLINK_OFF,
-	INDICATOR_ALT_BLINK, INDICATOR_ALT_BLINK_OFF
-} __attribute__ ((packed));
-
-struct usb_device;
-
-/* Transaction Translator Think Times, in bits */
-#define HUB_TTTT_8_BITS		0x00
-#define HUB_TTTT_16_BITS	0x20
-#define HUB_TTTT_24_BITS	0x40
-#define HUB_TTTT_32_BITS	0x60
-
-/*
- * As of USB 2.0, full/low speed devices are segregated into trees.
- * One type grows from USB 1.1 host controllers (OHCI, UHCI etc).
- * The other type grows from high speed hubs when they connect to
- * full/low speed devices using "Transaction Translators" (TTs).
- *
- * TTs should only be known to the hub driver, and high speed bus
- * drivers (only EHCI for now).  They affect periodic scheduling and
- * sometimes control/bulk error recovery.
- */
-struct usb_tt {
-	struct usb_device	*hub;	/* upstream highspeed hub */
-	int			multi;	/* true means one TT per port */
-	unsigned		think_time;	/* think time in ns */
-
-	/* for control/bulk error recovery (CLEAR_TT_BUFFER) */
-	spinlock_t		lock;
-	struct list_head	clear_list;	/* of usb_tt_clear */
-	struct work_struct	clear_work;
-};
-
-struct usb_tt_clear {
-	struct list_head	clear_list;
-	unsigned		tt;
-	u16			devinfo;
-	struct usb_hcd		*hcd;
-	struct usb_host_endpoint	*ep;
-};
-
-extern int usb_hub_clear_tt_buffer(struct urb *urb);
-extern void usb_ep0_reinit(struct usb_device *);
-
-#endif /* __LINUX_HUB_H */

commit cb88a1b887bb8908f6e00ce29e893ea52b074940
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Jun 29 10:43:32 2009 -0400

    USB: fix the clear_tt_buffer interface
    
    This patch (as1255) updates the interface for calling
    usb_hub_clear_tt_buffer().  Even the name of the function is changed!
    
    When an async URB (i.e., Control or Bulk) going through a high-speed
    hub to a non-high-speed device is cancelled or fails, the hub's
    Transaction Translator buffer may be left busy still trying to
    complete the transaction.  The buffer has to be cleared; that's what
    usb_hub_clear_tt_buffer() does.
    
    It isn't safe to send any more URBs to the same endpoint until the TT
    buffer is fully clear.  Therefore the HCD needs to be told when the
    Clear-TT-Buffer request has finished.  This patch adds a callback
    method to struct hc_driver for that purpose, and makes the hub driver
    invoke the callback at the proper time.
    
    The patch also changes a couple of names; "hub_tt_kevent" and
    "tt.kevent" now look rather antiquated.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Cc: stable <stable@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/hub.h b/drivers/usb/core/hub.h
index 889c0f32a40b..de8081f065ed 100644
--- a/drivers/usb/core/hub.h
+++ b/drivers/usb/core/hub.h
@@ -188,16 +188,18 @@ struct usb_tt {
 	/* for control/bulk error recovery (CLEAR_TT_BUFFER) */
 	spinlock_t		lock;
 	struct list_head	clear_list;	/* of usb_tt_clear */
-	struct work_struct			kevent;
+	struct work_struct	clear_work;
 };
 
 struct usb_tt_clear {
 	struct list_head	clear_list;
 	unsigned		tt;
 	u16			devinfo;
+	struct usb_hcd		*hcd;
+	struct usb_host_endpoint	*ep;
 };
 
-extern void usb_hub_tt_clear_buffer(struct usb_device *dev, int pipe);
+extern int usb_hub_clear_tt_buffer(struct urb *urb);
 extern void usb_ep0_reinit(struct usb_device *);
 
 #endif /* __LINUX_HUB_H */

commit d2e9b4d6734db2327af3149d8ca7555307e10828
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Mon Apr 27 19:55:01 2009 -0700

    USB: Add USB 3.0 roothub support to USB core.
    
    Add USB 3.0 root hub descriptors.  This is a kludge because I reused the old
    USB 2.0 descriptors, instead of using the new USB 3.0 hub descriptors with
    endpoint companion descriptors and other descriptors.  I did this because I
    wasn't ready to add USB 3.0 hub changes to khubd.  For now, a USB 3.0 roothub
    looks like a USB 2.0 roothub, with a higher speed.
    
    USB 3.0 hubs have no transaction translator (TT).
    
    Make USB core debugging handle super speed ports.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/hub.h b/drivers/usb/core/hub.h
index 2a116ce53c9b..889c0f32a40b 100644
--- a/drivers/usb/core/hub.h
+++ b/drivers/usb/core/hub.h
@@ -47,7 +47,10 @@
 #define USB_PORT_FEAT_L1		5	/* L1 suspend */
 #define USB_PORT_FEAT_POWER		8
 #define USB_PORT_FEAT_LOWSPEED		9
+/* This value was never in Table 11-17 */
 #define USB_PORT_FEAT_HIGHSPEED		10
+/* This value is also fake */
+#define USB_PORT_FEAT_SUPERSPEED	11
 #define USB_PORT_FEAT_C_CONNECTION	16
 #define USB_PORT_FEAT_C_ENABLE		17
 #define USB_PORT_FEAT_C_SUSPEND		18

commit fc721f5194dc98c8108fb155a4fbae1cd746cf41
Author: Inaky Perez-Gonzalez <inaky@linux.intel.com>
Date:   Tue Apr 8 13:24:46 2008 -0700

    wusb: make ep0_reinit available for modules
    
    We need to be able to call ep0_reinit() [renamed to usb_ep0_reinit()]
    from the WUSB security code. The reason is that when we authenticate
    the device, it's address changes (from having bit 7 set to having it
    cleared). Thus, we need to signal the USB stack to reinitialize EP0,
    so the status with the previous address kept at the HCD layer is
    cleared and properly reinitialized.
    
    Signed-off-by: Inaky Perez-Gonzalez <inaky@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/hub.h b/drivers/usb/core/hub.h
index d672cd81a3e4..2a116ce53c9b 100644
--- a/drivers/usb/core/hub.h
+++ b/drivers/usb/core/hub.h
@@ -195,5 +195,6 @@ struct usb_tt_clear {
 };
 
 extern void usb_hub_tt_clear_buffer(struct usb_device *dev, int pipe);
+extern void usb_ep0_reinit(struct usb_device *);
 
 #endif /* __LINUX_HUB_H */

commit dbe0dbb7dfda52140d3469d7035a08dfa874fca2
Author: David Brownell <david-b@pacbell.net>
Date:   Sun Feb 10 12:24:00 2008 -0800

    USB: defines for USB "Link Power Management" (LPM) ECN
    
    There's a new PM-related change notice for the USB 2.0 specification
    called "Link Power Management" (LPM).  It defines a new "L1 Suspend"
    state which resembles the current (L2) suspend state, except that it
    can be entered and exited much more quickly.  It should thus be more
    useful for runtime PM, even though it doesn't mandate reduced power
    draw from VBUS.
    
    This patch provides the relevant #defines for usbcore.  Actually
    implementing these mechanisms requires host silicon that can generate
    new USB packets, plus hubs handling some new requests and peripherals
    which understand the new packets.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/hub.h b/drivers/usb/core/hub.h
index 1551aed65e05..d672cd81a3e4 100644
--- a/drivers/usb/core/hub.h
+++ b/drivers/usb/core/hub.h
@@ -41,9 +41,10 @@
  */
 #define USB_PORT_FEAT_CONNECTION	0
 #define USB_PORT_FEAT_ENABLE		1
-#define USB_PORT_FEAT_SUSPEND		2
+#define USB_PORT_FEAT_SUSPEND		2	/* L2 suspend */
 #define USB_PORT_FEAT_OVER_CURRENT	3
 #define USB_PORT_FEAT_RESET		4
+#define USB_PORT_FEAT_L1		5	/* L1 suspend */
 #define USB_PORT_FEAT_POWER		8
 #define USB_PORT_FEAT_LOWSPEED		9
 #define USB_PORT_FEAT_HIGHSPEED		10
@@ -54,6 +55,7 @@
 #define USB_PORT_FEAT_C_RESET		20
 #define USB_PORT_FEAT_TEST              21
 #define USB_PORT_FEAT_INDICATOR         22
+#define USB_PORT_FEAT_C_PORT_L1         23
 
 /*
  * Hub Status and Hub Change results
@@ -73,7 +75,8 @@ struct usb_port_status {
 #define USB_PORT_STAT_SUSPEND		0x0004
 #define USB_PORT_STAT_OVERCURRENT	0x0008
 #define USB_PORT_STAT_RESET		0x0010
-/* bits 5 to 7 are reserved */
+#define USB_PORT_STAT_L1		0x0020
+/* bits 6 to 7 are reserved */
 #define USB_PORT_STAT_POWER		0x0100
 #define USB_PORT_STAT_LOW_SPEED		0x0200
 #define USB_PORT_STAT_HIGH_SPEED        0x0400
@@ -91,6 +94,7 @@ struct usb_port_status {
 #define USB_PORT_STAT_C_SUSPEND		0x0004
 #define USB_PORT_STAT_C_OVERCURRENT	0x0008
 #define USB_PORT_STAT_C_RESET		0x0010
+#define USB_PORT_STAT_C_L1		0x0020
 
 /*
  * wHubCharacteristics (masks)

commit 84cca820ee798a6bc8b01a4ccc9548943bc41f7f
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed Jan 30 15:21:33 2008 -0800

    USB: fix codingstyle issues in drivers/usb/core/*.h
    
    Fixes a number of coding style issues in the USB internal header files.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/hub.h b/drivers/usb/core/hub.h
index cf9559c6c9b6..1551aed65e05 100644
--- a/drivers/usb/core/hub.h
+++ b/drivers/usb/core/hub.h
@@ -55,16 +55,16 @@
 #define USB_PORT_FEAT_TEST              21
 #define USB_PORT_FEAT_INDICATOR         22
 
-/* 
+/*
  * Hub Status and Hub Change results
  * See USB 2.0 spec Table 11-19 and Table 11-20
  */
 struct usb_port_status {
 	__le16 wPortStatus;
-	__le16 wPortChange;	
+	__le16 wPortChange;
 } __attribute__ ((packed));
 
-/* 
+/*
  * wPortStatus bit field
  * See USB 2.0 spec Table 11-21
  */
@@ -81,7 +81,7 @@ struct usb_port_status {
 #define USB_PORT_STAT_INDICATOR         0x1000
 /* bits 13 to 15 are reserved */
 
-/* 
+/*
  * wPortChange bit field
  * See USB 2.0 spec Table 11-22
  * Bits 0 to 4 shown, bits 5 to 15 are reserved
@@ -93,7 +93,7 @@ struct usb_port_status {
 #define USB_PORT_STAT_C_RESET		0x0010
 
 /*
- * wHubCharacteristics (masks) 
+ * wHubCharacteristics (masks)
  * See USB 2.0 spec Table 11-13, offset 3
  */
 #define HUB_CHAR_LPSM		0x0003 /* D1 .. D0 */
@@ -119,8 +119,8 @@ struct usb_hub_status {
 #define HUB_CHANGE_OVERCURRENT	0x0002
 
 
-/* 
- * Hub descriptor 
+/*
+ * Hub descriptor
  * See USB 2.0 spec Table 11-13
  */
 
@@ -134,7 +134,7 @@ struct usb_hub_descriptor {
 	__le16 wHubCharacteristics;
 	__u8  bPwrOn2PwrGood;
 	__u8  bHubContrCurrent;
-	    	/* add 1 bit for hub status change; round to bytes */
+		/* add 1 bit for hub status change; round to bytes */
 	__u8  DeviceRemovable[(USB_MAXCHILDREN + 1 + 7) / 8];
 	__u8  PortPwrCtrlMask[(USB_MAXCHILDREN + 1 + 7) / 8];
 } __attribute__ ((packed));
@@ -190,6 +190,6 @@ struct usb_tt_clear {
 	u16			devinfo;
 };
 
-extern void usb_hub_tt_clear_buffer (struct usb_device *dev, int pipe);
+extern void usb_hub_tt_clear_buffer(struct usb_device *dev, int pipe);
 
 #endif /* __LINUX_HUB_H */

commit 1bb5f66bb3b6c2fd7eec1cdfee9cf3f68ef83487
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Nov 6 11:56:13 2006 -0500

    USB: Move private hub declarations out of public header file
    
    This patch (as809b) moves the declaration of the hub driver's private
    data structure from hub.h into the hub.c source file.  Lots of other
    files import hub.h; they have no need to know about the details of the
    hub driver's private data.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/hub.h b/drivers/usb/core/hub.h
index 1b05994de4dc..cf9559c6c9b6 100644
--- a/drivers/usb/core/hub.h
+++ b/drivers/usb/core/hub.h
@@ -192,45 +192,4 @@ struct usb_tt_clear {
 
 extern void usb_hub_tt_clear_buffer (struct usb_device *dev, int pipe);
 
-struct usb_hub {
-	struct device		*intfdev;	/* the "interface" device */
-	struct usb_device	*hdev;
-	struct urb		*urb;		/* for interrupt polling pipe */
-
-	/* buffer for urb ... with extra space in case of babble */
-	char			(*buffer)[8];
-	dma_addr_t		buffer_dma;	/* DMA address for buffer */
-	union {
-		struct usb_hub_status	hub;
-		struct usb_port_status	port;
-	}			*status;	/* buffer for status reports */
-
-	int			error;		/* last reported error */
-	int			nerrors;	/* track consecutive errors */
-
-	struct list_head	event_list;	/* hubs w/data or errs ready */
-	unsigned long		event_bits[1];	/* status change bitmask */
-	unsigned long		change_bits[1];	/* ports with logical connect
-							status change */
-	unsigned long		busy_bits[1];	/* ports being reset or
-							resumed */
-#if USB_MAXCHILDREN > 31 /* 8*sizeof(unsigned long) - 1 */
-#error event_bits[] is too short!
-#endif
-
-	struct usb_hub_descriptor *descriptor;	/* class descriptor */
-	struct usb_tt		tt;		/* Transaction Translator */
-
-	unsigned		mA_per_port;	/* current for each child */
-
-	unsigned		limited_power:1;
-	unsigned		quiescing:1;
-	unsigned		activating:1;
-	unsigned		resume_root_hub:1;
-
-	unsigned		has_indicators:1;
-	u8			indicator[USB_MAXCHILDREN];
-	struct work_struct	leds;
-};
-
 #endif /* __LINUX_HUB_H */

commit 437052516779fea608261a50682b124315f48f01
Author: inaky@linux.intel.com <inaky@linux.intel.com>
Date:   Wed Oct 11 20:05:58 2006 -0700

    usb/hub: allow hubs up to 31 children
    
    Current Wireless USB host hardware (Intel i1480 for example) allows up
    to 22 devices to connect, thus bringing up the max number of children
    in the WUSB Host Controller to 22 'fake' ports. Upcoming hardware
    might raise that limit.
    
    Makes almost no difference to go to 31, as the bit arrays are
    byte-aligned (plus an extra bit in general), so 22 bits fit in 4 bytes
    as 31 do.
    
    As well, the only other array that depends on USB_MAXCHILDREN is
    'struct usb_hub->indicator'. By declaring it 'u8' instead of 'enum
    hub_led_mode', we reduce the size of each entry from 4 bytes (in i386)
    to 1, which will add as we when are doubling USB_MAXCHILDREN
    (with 16 the size of that array is 64 bytes, with 31 would be 128; by
    using u8 that goes down to 31 bytes).
    
    Signed-off-by: Inaky Perez-Gonzalez <inaky.perez-gonzalez@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/hub.h b/drivers/usb/core/hub.h
index 0f8e82a4d480..1b05994de4dc 100644
--- a/drivers/usb/core/hub.h
+++ b/drivers/usb/core/hub.h
@@ -229,7 +229,7 @@ struct usb_hub {
 	unsigned		resume_root_hub:1;
 
 	unsigned		has_indicators:1;
-	enum hub_led_mode	indicator[USB_MAXCHILDREN];
+	u8			indicator[USB_MAXCHILDREN];
 	struct work_struct	leds;
 };
 

commit d5cbad4b8b37acfde3e63d31b92561b87288ad0f
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Aug 11 16:52:39 2006 -0400

    usbcore: khubd and busy-port handling
    
    We don't want khubd to start interfering in the device-resume process
    merely because the PORT_STATUS_C_SUSPEND feature happens to be set.
    Ports need to be marked as busy while a resume is taking place.
    
    In addition, so long as ports are marked as busy, khubd won't be able to
    clear their various status-change features.  On an interrupt-driven root
    hub this could lead to an interrupt storm.  Root hub IRQs should not be
    re-enabled until the busy_bits value is equal to 0.
    
    This patch (as765) fixes these two potential problems.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/hub.h b/drivers/usb/core/hub.h
index 29d5f45a8456..0f8e82a4d480 100644
--- a/drivers/usb/core/hub.h
+++ b/drivers/usb/core/hub.h
@@ -212,7 +212,8 @@ struct usb_hub {
 	unsigned long		event_bits[1];	/* status change bitmask */
 	unsigned long		change_bits[1];	/* ports with logical connect
 							status change */
-	unsigned long		busy_bits[1];	/* ports being reset */
+	unsigned long		busy_bits[1];	/* ports being reset or
+							resumed */
 #if USB_MAXCHILDREN > 31 /* 8*sizeof(unsigned long) - 1 */
 #error event_bits[] is too short!
 #endif

commit 55c527187c9d78f840b284d596a0b298bc1493af
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Nov 23 12:03:12 2005 -0500

    [PATCH] USB: Consider power budget when choosing configuration
    
    This patch (as609) changes the way we keep track of power budgeting for
    USB hubs and devices, and it updates the choose_configuration routine to
    take this information into account.  (This is something we should have
    been doing all along.)  A new field in struct usb_device holds the amount
    of bus current available from the upstream port, and the usb_hub structure
    keeps track of the current available for each downstream port.
    
    Two new rules for configuration selection are added:
    
            Don't select a self-powered configuration when only bus power
            is available.
    
            Don't select a configuration requiring more bus power than is
            available.
    
    However the first rule is #if-ed out, because I found that the internal
    hub in my HP USB keyboard claims that its only configuration is
    self-powered.  The rule would prevent the configuration from being chosen,
    leaving the hub & keyboard unconfigured.  Since similar descriptor errors
    may turn out to be fairly common, it seemed wise not to include a rule
    that would break automatic configuration unnecessarily for such devices.
    
    The second rule may also trigger unnecessarily, although this should be
    less common.  More likely it will annoy people by sometimes failing to
    accept configurations that should never have been chosen in the first
    place.
    
    The patch also changes usbcore's reaction when no configuration is
    suitable.  Instead of raising an error and rejecting the device, now
    the core will simply leave the device unconfigured.  People can always
    work around such problems by installing configurations manually through
    sysfs.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/hub.h b/drivers/usb/core/hub.h
index bf23f8978024..29d5f45a8456 100644
--- a/drivers/usb/core/hub.h
+++ b/drivers/usb/core/hub.h
@@ -220,8 +220,9 @@ struct usb_hub {
 	struct usb_hub_descriptor *descriptor;	/* class descriptor */
 	struct usb_tt		tt;		/* Transaction Translator */
 
-	u8			power_budget;	/* in 2mA units; or zero */
+	unsigned		mA_per_port;	/* current for each child */
 
+	unsigned		limited_power:1;
 	unsigned		quiescing:1;
 	unsigned		activating:1;
 	unsigned		resume_root_hub:1;

commit 74ad9bd2fcf0fa203655e0d904809b06c4202bf8
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Jun 20 21:15:16 2005 -0700

    [PATCH] USB: make wHubCharacteristics __le16 to match other usb descriptor fields
    
    Also has the nice benefit of making sparc alignment issues go away.
    
    Thanks to David Miller for pointing out the problems here.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    
     drivers/usb/core/hub.c |   22 ++++++++++++----------
     drivers/usb/core/hub.h |    2 +-
     2 files changed, 13 insertions(+), 11 deletions(-)

diff --git a/drivers/usb/core/hub.h b/drivers/usb/core/hub.h
index e7fa9b5a521e..bf23f8978024 100644
--- a/drivers/usb/core/hub.h
+++ b/drivers/usb/core/hub.h
@@ -131,7 +131,7 @@ struct usb_hub_descriptor {
 	__u8  bDescLength;
 	__u8  bDescriptorType;
 	__u8  bNbrPorts;
-	__u16 wHubCharacteristics;
+	__le16 wHubCharacteristics;
 	__u8  bPwrOn2PwrGood;
 	__u8  bHubContrCurrent;
 	    	/* add 1 bit for hub status change; round to bytes */

commit e09711aef4180002241c7f2eab37390ddf40d6a0
Author: david-b@pacbell.net <david-b@pacbell.net>
Date:   Sat Aug 13 18:41:04 2005 -0700

    [PATCH] ehci: add think_time
    
    This adds think_time to the usb_tt struct and sets it appropriately
    (measured in ns); this can help us implement better split transaction
    scheduling.
    
    Signed-off-by: Dan Streetman <ddstreet@ieee.org>
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/hub.h b/drivers/usb/core/hub.h
index 53bf5649621e..e7fa9b5a521e 100644
--- a/drivers/usb/core/hub.h
+++ b/drivers/usb/core/hub.h
@@ -157,6 +157,12 @@ enum hub_led_mode {
 
 struct usb_device;
 
+/* Transaction Translator Think Times, in bits */
+#define HUB_TTTT_8_BITS		0x00
+#define HUB_TTTT_16_BITS	0x20
+#define HUB_TTTT_24_BITS	0x40
+#define HUB_TTTT_32_BITS	0x60
+
 /*
  * As of USB 2.0, full/low speed devices are segregated into trees.
  * One type grows from USB 1.1 host controllers (OHCI, UHCI etc).
@@ -170,6 +176,7 @@ struct usb_device;
 struct usb_tt {
 	struct usb_device	*hub;	/* upstream highspeed hub */
 	int			multi;	/* true means one TT per port */
+	unsigned		think_time;	/* think time in ns */
 
 	/* for control/bulk error recovery (CLEAR_TT_BUFFER) */
 	spinlock_t		lock;

commit 7d35b9298539d2818c51fe9070b08cf9876016f4
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Apr 25 11:18:32 2005 -0400

    [PATCH] usbcore: Remove hub_set_power_budget
    
    This patch removes the hub_set_power_budget routine, which was used by a
    couple of HCDs to indicate that the root hub was running on battery power.
    In its place is a new field added to struct usb_hcd, which HCDs can set
    before the root hub is registered.  Special-case code in the hub driver
    knows to look at this field when configuring a root hub.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/hub.h b/drivers/usb/core/hub.h
index d114b847d56f..53bf5649621e 100644
--- a/drivers/usb/core/hub.h
+++ b/drivers/usb/core/hub.h
@@ -224,15 +224,4 @@ struct usb_hub {
 	struct work_struct	leds;
 };
 
-/* use this for low-powered root hubs */
-static inline void
-hub_set_power_budget (struct usb_device *hubdev, unsigned mA)
-{
-	struct usb_hub	*hub;
-
-	hub = (struct usb_hub *)
-		usb_get_intfdata (hubdev->actconfig->interface[0]);
-	hub->power_budget = min(mA,(unsigned)500)/2;
-}
-
 #endif /* __LINUX_HUB_H */

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/usb/core/hub.h b/drivers/usb/core/hub.h
new file mode 100644
index 000000000000..d114b847d56f
--- /dev/null
+++ b/drivers/usb/core/hub.h
@@ -0,0 +1,238 @@
+#ifndef __LINUX_HUB_H
+#define __LINUX_HUB_H
+
+/*
+ * Hub protocol and driver data structures.
+ *
+ * Some of these are known to the "virtual root hub" code
+ * in host controller drivers.
+ */
+
+#include <linux/list.h>
+#include <linux/workqueue.h>
+#include <linux/compiler.h>	/* likely()/unlikely() */
+
+/*
+ * Hub request types
+ */
+
+#define USB_RT_HUB	(USB_TYPE_CLASS | USB_RECIP_DEVICE)
+#define USB_RT_PORT	(USB_TYPE_CLASS | USB_RECIP_OTHER)
+
+/*
+ * Hub class requests
+ * See USB 2.0 spec Table 11-16
+ */
+#define HUB_CLEAR_TT_BUFFER	8
+#define HUB_RESET_TT		9
+#define HUB_GET_TT_STATE	10
+#define HUB_STOP_TT		11
+
+/*
+ * Hub Class feature numbers
+ * See USB 2.0 spec Table 11-17
+ */
+#define C_HUB_LOCAL_POWER	0
+#define C_HUB_OVER_CURRENT	1
+
+/*
+ * Port feature numbers
+ * See USB 2.0 spec Table 11-17
+ */
+#define USB_PORT_FEAT_CONNECTION	0
+#define USB_PORT_FEAT_ENABLE		1
+#define USB_PORT_FEAT_SUSPEND		2
+#define USB_PORT_FEAT_OVER_CURRENT	3
+#define USB_PORT_FEAT_RESET		4
+#define USB_PORT_FEAT_POWER		8
+#define USB_PORT_FEAT_LOWSPEED		9
+#define USB_PORT_FEAT_HIGHSPEED		10
+#define USB_PORT_FEAT_C_CONNECTION	16
+#define USB_PORT_FEAT_C_ENABLE		17
+#define USB_PORT_FEAT_C_SUSPEND		18
+#define USB_PORT_FEAT_C_OVER_CURRENT	19
+#define USB_PORT_FEAT_C_RESET		20
+#define USB_PORT_FEAT_TEST              21
+#define USB_PORT_FEAT_INDICATOR         22
+
+/* 
+ * Hub Status and Hub Change results
+ * See USB 2.0 spec Table 11-19 and Table 11-20
+ */
+struct usb_port_status {
+	__le16 wPortStatus;
+	__le16 wPortChange;	
+} __attribute__ ((packed));
+
+/* 
+ * wPortStatus bit field
+ * See USB 2.0 spec Table 11-21
+ */
+#define USB_PORT_STAT_CONNECTION	0x0001
+#define USB_PORT_STAT_ENABLE		0x0002
+#define USB_PORT_STAT_SUSPEND		0x0004
+#define USB_PORT_STAT_OVERCURRENT	0x0008
+#define USB_PORT_STAT_RESET		0x0010
+/* bits 5 to 7 are reserved */
+#define USB_PORT_STAT_POWER		0x0100
+#define USB_PORT_STAT_LOW_SPEED		0x0200
+#define USB_PORT_STAT_HIGH_SPEED        0x0400
+#define USB_PORT_STAT_TEST              0x0800
+#define USB_PORT_STAT_INDICATOR         0x1000
+/* bits 13 to 15 are reserved */
+
+/* 
+ * wPortChange bit field
+ * See USB 2.0 spec Table 11-22
+ * Bits 0 to 4 shown, bits 5 to 15 are reserved
+ */
+#define USB_PORT_STAT_C_CONNECTION	0x0001
+#define USB_PORT_STAT_C_ENABLE		0x0002
+#define USB_PORT_STAT_C_SUSPEND		0x0004
+#define USB_PORT_STAT_C_OVERCURRENT	0x0008
+#define USB_PORT_STAT_C_RESET		0x0010
+
+/*
+ * wHubCharacteristics (masks) 
+ * See USB 2.0 spec Table 11-13, offset 3
+ */
+#define HUB_CHAR_LPSM		0x0003 /* D1 .. D0 */
+#define HUB_CHAR_COMPOUND	0x0004 /* D2       */
+#define HUB_CHAR_OCPM		0x0018 /* D4 .. D3 */
+#define HUB_CHAR_TTTT           0x0060 /* D6 .. D5 */
+#define HUB_CHAR_PORTIND        0x0080 /* D7       */
+
+struct usb_hub_status {
+	__le16 wHubStatus;
+	__le16 wHubChange;
+} __attribute__ ((packed));
+
+/*
+ * Hub Status & Hub Change bit masks
+ * See USB 2.0 spec Table 11-19 and Table 11-20
+ * Bits 0 and 1 for wHubStatus and wHubChange
+ * Bits 2 to 15 are reserved for both
+ */
+#define HUB_STATUS_LOCAL_POWER	0x0001
+#define HUB_STATUS_OVERCURRENT	0x0002
+#define HUB_CHANGE_LOCAL_POWER	0x0001
+#define HUB_CHANGE_OVERCURRENT	0x0002
+
+
+/* 
+ * Hub descriptor 
+ * See USB 2.0 spec Table 11-13
+ */
+
+#define USB_DT_HUB			(USB_TYPE_CLASS | 0x09)
+#define USB_DT_HUB_NONVAR_SIZE		7
+
+struct usb_hub_descriptor {
+	__u8  bDescLength;
+	__u8  bDescriptorType;
+	__u8  bNbrPorts;
+	__u16 wHubCharacteristics;
+	__u8  bPwrOn2PwrGood;
+	__u8  bHubContrCurrent;
+	    	/* add 1 bit for hub status change; round to bytes */
+	__u8  DeviceRemovable[(USB_MAXCHILDREN + 1 + 7) / 8];
+	__u8  PortPwrCtrlMask[(USB_MAXCHILDREN + 1 + 7) / 8];
+} __attribute__ ((packed));
+
+
+/* port indicator status selectors, tables 11-7 and 11-25 */
+#define HUB_LED_AUTO	0
+#define HUB_LED_AMBER	1
+#define HUB_LED_GREEN	2
+#define HUB_LED_OFF	3
+
+enum hub_led_mode {
+	INDICATOR_AUTO = 0,
+	INDICATOR_CYCLE,
+	/* software blinks for attention:  software, hardware, reserved */
+	INDICATOR_GREEN_BLINK, INDICATOR_GREEN_BLINK_OFF,
+	INDICATOR_AMBER_BLINK, INDICATOR_AMBER_BLINK_OFF,
+	INDICATOR_ALT_BLINK, INDICATOR_ALT_BLINK_OFF
+} __attribute__ ((packed));
+
+struct usb_device;
+
+/*
+ * As of USB 2.0, full/low speed devices are segregated into trees.
+ * One type grows from USB 1.1 host controllers (OHCI, UHCI etc).
+ * The other type grows from high speed hubs when they connect to
+ * full/low speed devices using "Transaction Translators" (TTs).
+ *
+ * TTs should only be known to the hub driver, and high speed bus
+ * drivers (only EHCI for now).  They affect periodic scheduling and
+ * sometimes control/bulk error recovery.
+ */
+struct usb_tt {
+	struct usb_device	*hub;	/* upstream highspeed hub */
+	int			multi;	/* true means one TT per port */
+
+	/* for control/bulk error recovery (CLEAR_TT_BUFFER) */
+	spinlock_t		lock;
+	struct list_head	clear_list;	/* of usb_tt_clear */
+	struct work_struct			kevent;
+};
+
+struct usb_tt_clear {
+	struct list_head	clear_list;
+	unsigned		tt;
+	u16			devinfo;
+};
+
+extern void usb_hub_tt_clear_buffer (struct usb_device *dev, int pipe);
+
+struct usb_hub {
+	struct device		*intfdev;	/* the "interface" device */
+	struct usb_device	*hdev;
+	struct urb		*urb;		/* for interrupt polling pipe */
+
+	/* buffer for urb ... with extra space in case of babble */
+	char			(*buffer)[8];
+	dma_addr_t		buffer_dma;	/* DMA address for buffer */
+	union {
+		struct usb_hub_status	hub;
+		struct usb_port_status	port;
+	}			*status;	/* buffer for status reports */
+
+	int			error;		/* last reported error */
+	int			nerrors;	/* track consecutive errors */
+
+	struct list_head	event_list;	/* hubs w/data or errs ready */
+	unsigned long		event_bits[1];	/* status change bitmask */
+	unsigned long		change_bits[1];	/* ports with logical connect
+							status change */
+	unsigned long		busy_bits[1];	/* ports being reset */
+#if USB_MAXCHILDREN > 31 /* 8*sizeof(unsigned long) - 1 */
+#error event_bits[] is too short!
+#endif
+
+	struct usb_hub_descriptor *descriptor;	/* class descriptor */
+	struct usb_tt		tt;		/* Transaction Translator */
+
+	u8			power_budget;	/* in 2mA units; or zero */
+
+	unsigned		quiescing:1;
+	unsigned		activating:1;
+	unsigned		resume_root_hub:1;
+
+	unsigned		has_indicators:1;
+	enum hub_led_mode	indicator[USB_MAXCHILDREN];
+	struct work_struct	leds;
+};
+
+/* use this for low-powered root hubs */
+static inline void
+hub_set_power_budget (struct usb_device *hubdev, unsigned mA)
+{
+	struct usb_hub	*hub;
+
+	hub = (struct usb_hub *)
+		usb_get_intfdata (hubdev->actconfig->interface[0]);
+	hub->power_budget = min(mA,(unsigned)500)/2;
+}
+
+#endif /* __LINUX_HUB_H */
