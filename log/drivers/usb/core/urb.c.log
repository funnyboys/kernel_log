commit 1cd17f7f0def31e3695501c4f86cd3faf8489840
Author: Emiliano Ingrassia <ingrassia@epigenesys.com>
Date:   Wed Nov 27 17:03:55 2019 +0100

    usb: core: urb: fix URB structure initialization function
    
    Explicitly initialize URB structure urb_list field in usb_init_urb().
    This field can be potentially accessed uninitialized and its
    initialization is coherent with the usage of list_del_init() in
    usb_hcd_unlink_urb_from_ep() and usb_giveback_urb_bh() and its
    explicit initialization in usb_hcd_submit_urb() error path.
    
    Signed-off-by: Emiliano Ingrassia <ingrassia@epigenesys.com>
    Cc: stable <stable@vger.kernel.org>
    Link: https://lore.kernel.org/r/20191127160355.GA27196@ingrassia.epigenesys.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index 0eab79f82ce4..da923ec17612 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -45,6 +45,7 @@ void usb_init_urb(struct urb *urb)
 	if (urb) {
 		memset(urb, 0, sizeof(*urb));
 		kref_init(&urb->kref);
+		INIT_LIST_HEAD(&urb->urb_list);
 		INIT_LIST_HEAD(&urb->anchor_list);
 	}
 }

commit 6756f4c375db11af7039985636bddde676615a94
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Tue Jan 8 09:22:25 2019 -0600

    USB: core: urb: Use struct_size() in kmalloc()
    
    One of the more common cases of allocation size calculations is finding
    the size of a structure that has a zero-sized array at the end, along
    with memory for some number of elements for that array. For example:
    
    struct foo {
        int stuff;
        void *entry[];
    };
    
    instance = kmalloc(sizeof(struct foo) + sizeof(void *) * count, GFP_KERNEL);
    
    Instead of leaving these open-coded and prone to type mistakes, we can
    now use the new struct_size() helper:
    
    instance = kmalloc(struct_size(instance, entry, count), GFP_KERNEL);
    
    This code was detected with the help of Coccinelle.
    
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index f51750bcd152..0eab79f82ce4 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -70,9 +70,8 @@ struct urb *usb_alloc_urb(int iso_packets, gfp_t mem_flags)
 {
 	struct urb *urb;
 
-	urb = kmalloc(sizeof(struct urb) +
-		iso_packets * sizeof(struct usb_iso_packet_descriptor),
-		mem_flags);
+	urb = kmalloc(struct_size(urb, iso_frame_desc, iso_packets),
+		      mem_flags);
 	if (!urb)
 		return NULL;
 	usb_init_urb(urb);

commit edb92eaf1d478ac52e7d258af35739c76c03efea
Author: Thinh Nguyen <Thinh.Nguyen@synopsys.com>
Date:   Fri Mar 16 15:36:17 2018 -0700

    usb: core: urb: Check SSP isoc ep comp descriptor
    
    The maximum bytes per interval for USB SuperSpeed Plus can be set by
    isoc endpoint companion descriptor when it is above 48K. If the
    descriptor is provided, then use its value.
    
    USB 3.1 spec 9.6.8
    
    Acked-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Signed-off-by: Thinh Nguyen <thinhn@synopsys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index 796c9b149728..f51750bcd152 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -433,6 +433,14 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 			max *= mult;
 		}
 
+		if (dev->speed == USB_SPEED_SUPER_PLUS &&
+		    USB_SS_SSP_ISOC_COMP(ep->ss_ep_comp.bmAttributes)) {
+			struct usb_ssp_isoc_ep_comp_descriptor *isoc_ep_comp;
+
+			isoc_ep_comp = &ep->ssp_isoc_ep_comp;
+			max = le32_to_cpu(isoc_ep_comp->dwBytesPerInterval);
+		}
+
 		/* "high bandwidth" mode, 1-3 packets/uframe? */
 		if (dev->speed == USB_SPEED_HIGH)
 			max *= usb_endpoint_maxp_mult(&ep->desc);

commit aa15d3d257f9edcb8d15ed27e228d1c0080cb919
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Dec 11 11:58:21 2017 -0500

    USB: remove the URB_NO_FSBR flag
    
    The URB_NO_FSBR flag has never really been used.  It was introduced as
    a potential way for UHCI to minimize PCI bus usage (by not attempting
    full-speed bulk and control transfers more than once per frame), but
    the flag was not set by any drivers.
    
    There's no point in keeping it around.  This patch simplifies the API
    by removing it.  Unfortunately, it does have to be kept as part of the
    usbfs ABI, but at least we can document in
    include/uapi/linux/usbdevice_fs.h that it doesn't do anything.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Shuah Khan <shuahkh@osg.samsung.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index 9fdf137c4865..796c9b149728 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -479,9 +479,6 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 		if (is_out)
 			allowed |= URB_ZERO_PACKET;
 		/* FALLTHROUGH */
-	case USB_ENDPOINT_XFER_CONTROL:
-		allowed |= URB_NO_FSBR;	/* only affects UHCI */
-		/* FALLTHROUGH */
 	default:			/* all non-iso endpoints */
 		if (!is_out)
 			allowed |= URB_SHORT_NOT_OK;

commit 4e4510fec4af08ead21f6934c1410af1f19a8cad
Merge: 4008e6a9bcee 7087cb8fad5e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Nov 14 18:01:46 2017 -0800

    Merge tag 'sound-4.15-rc1' of ssh://gitolite.kernel.org/pub/scm/linux/kernel/git/tiwai/sound
    
    Pull sound updates from Takashi Iwai:
     "There are no big surprising changes in this cycle, yet not too boring,
      either. The biggest change from diffstat POV is the removal of the
      legacy OSS driver codes that have been already disabled for a long
      time. This will bring a few trivial merge conflicts.
    
      As new features in ASoC side, there are two things: a new AC97 bus
      implementation and AMD Stony platform support. Both include the
      relevant changes shared with other subsystems, e.g. AC97 MFD changes
      and DRM AMD changes.
    
      Some other highlighted topics are:
    
       - A bunch of USB-audio drivers got the hardening against the
         malicious device accesses with a new helper code for endpoint
         sanity check
    
       - Lots of cleanups for ASoC Intel platform code, including support
         for their open source audio firmware
    
       - Continued ASoC core componentization works
    
       - Support for scaling MCLK with sample rate in ASoC simple-card
    
       - Stabler PCM hot-unplug capability, especially for ASoC usages"
    
    * tag 'sound-4.15-rc1' of ssh://gitolite.kernel.org/pub/scm/linux/kernel/git/tiwai/sound: (302 commits)
      Documentation: sound: hd-audio: notes.rst
      ASoC: bcm2835: Support left/right justified and DSP modes
      ASoC: bcm2835: Enforce full symmetry
      ASoC: bcm2835: Support additional samplerates up to 384kHz
      ASoC: bcm2835: Add support for TDM modes
      ASoC: add mclk-fs support to audio graph card
      ASoC: add mclk-fs to audio graph card binding
      ASoC: rt5514: work around link error
      ASoC: rt5514: mark PM functions as __maybe_unused
      ASoC: rt5663: Check the JD status in the button pushing
      ASoC: amd: Modified DMA transfer Mechanism for Playback
      ASoC: rt5645: Wait for 400msec before concluding on value of RT5645_VENDOR_ID2
      ASoC: sun4i-codec: fixed 32bit audio capture support for H3/H2+
      ASoC: da7213: add support for DSP modes
      ASoC: sun8i-codec: Add a comment on the LRCK inversion
      ASoC: sun8i-codec: Set the BCLK divider
      ASoC: rt5663: Delay and retry reading rt5663 ID register
      ASoC: amd: use do_div rather than 64 bit division to fix 32 bit builds
      ASoC: cs42l56: Fix reset GPIO name in example DT binding
      ASoC: rt5514-spi: check irq status to schedule data copy in resume function
      ...

commit aa1f3bb56761cf627ed53a40607bead16d6e23bc
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Nov 3 09:18:41 2017 +0100

    USB: core: move existing SPDX tags to top of the file
    
    To match the rest of the kernel, the SPDX tags for the drivers/usb/core/
    files are moved to the first line of the file.  This makes it more
    obvious the tag is present as well as making it match the other 12k
    files in the tree with this location.
    
    It also uses // to match the "expected style" as well.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index caca5ed6d0f3..f501af0b3079 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -1,6 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Released under the GPLv2 only.
- * SPDX-License-Identifier: GPL-2.0
  */
 
 #include <linux/module.h>

commit 4f4ee7d87989df17aaca80a2e2d62b15d3f3cacc
Author: Gustavo A. R. Silva <garsilva@embeddedor.com>
Date:   Mon Oct 23 22:25:43 2017 -0500

    usb: core: urb: mark expected switch fall-through
    
    In preparation to enabling -Wimplicit-fallthrough, mark switch cases
    where we are expecting to fall through.
    
    Addresses-Coverity-ID: 1162594
    Signed-off-by: Gustavo A. R. Silva <garsilva@embeddedor.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index 47903d510955..caca5ed6d0f3 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -492,6 +492,7 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 			if ((urb->interval < 6)
 				&& (xfertype == USB_ENDPOINT_XFER_INT))
 				return -EINVAL;
+			/* fall through */
 		default:
 			if (urb->interval <= 0)
 				return -EINVAL;

commit e901b9873876ca30a09253731bd3a6b00c44b5b0
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Oct 4 16:15:59 2017 +0200

    usb: core: Add a helper function to check the validity of EP type in URB
    
    This patch adds a new helper function to perform a sanity check of the
    given URB to see whether it contains a valid endpoint.  It's a light-
    weight version of what usb_submit_urb() does, but without the kernel
    warning followed by the stack trace, just returns an error code.
    
    Especially for a driver that doesn't parse the descriptor but fills
    the URB with the fixed endpoint (e.g. some quirks for non-compliant
    devices), this kind of check is preferable at the probe phase before
    actually submitting the urb.
    
    Tested-by: Andrey Konovalov <andreyknvl@google.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Takashi Iwai <tiwai@suse.de>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index 47903d510955..8b800e34407b 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -187,6 +187,31 @@ EXPORT_SYMBOL_GPL(usb_unanchor_urb);
 
 /*-------------------------------------------------------------------*/
 
+static const int pipetypes[4] = {
+	PIPE_CONTROL, PIPE_ISOCHRONOUS, PIPE_BULK, PIPE_INTERRUPT
+};
+
+/**
+ * usb_urb_ep_type_check - sanity check of endpoint in the given urb
+ * @urb: urb to be checked
+ *
+ * This performs a light-weight sanity check for the endpoint in the
+ * given urb.  It returns 0 if the urb contains a valid endpoint, otherwise
+ * a negative error code.
+ */
+int usb_urb_ep_type_check(const struct urb *urb)
+{
+	const struct usb_host_endpoint *ep;
+
+	ep = usb_pipe_endpoint(urb->dev, urb->pipe);
+	if (!ep)
+		return -EINVAL;
+	if (usb_pipetype(urb->pipe) != pipetypes[usb_endpoint_type(&ep->desc)])
+		return -EINVAL;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(usb_urb_ep_type_check);
+
 /**
  * usb_submit_urb - issue an asynchronous transfer request for an endpoint
  * @urb: pointer to the urb describing the request
@@ -326,9 +351,6 @@ EXPORT_SYMBOL_GPL(usb_unanchor_urb);
  */
 int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 {
-	static int			pipetypes[4] = {
-		PIPE_CONTROL, PIPE_ISOCHRONOUS, PIPE_BULK, PIPE_INTERRUPT
-	};
 	int				xfertype, max;
 	struct usb_device		*dev;
 	struct usb_host_endpoint	*ep;
@@ -444,7 +466,7 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 	 */
 
 	/* Check that the pipe's type matches the endpoint's type */
-	if (usb_pipetype(urb->pipe) != pipetypes[xfertype])
+	if (usb_urb_ep_type_check(urb))
 		dev_WARN(&dev->dev, "BOGUS urb xfer, pipe %x != type %x\n",
 			usb_pipetype(urb->pipe), pipetypes[xfertype]);
 

commit 2f964780c03b73de269b08d12aff96a9618d13f3
Author: Vamsi Krishna Samavedam <vskrishn@codeaurora.org>
Date:   Tue May 16 14:38:08 2017 +0200

    USB: core: replace %p with %pK
    
    Format specifier %p can leak kernel addresses while not valuing the
    kptr_restrict system settings. When kptr_restrict is set to (1), kernel
    pointers printed using the %pK format specifier will be replaced with
    Zeros. Debugging Note : &pK prints only Zeros as address. If you need
    actual address information, write 0 to kptr_restrict.
    
    echo 0 > /proc/sys/kernel/kptr_restrict
    
    [Found by poking around in a random vendor kernel tree, it would be nice
    if someone would actually send these types of patches upstream - gkh]
    
    Signed-off-by: Vamsi Krishna Samavedam <vskrishn@codeaurora.org>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index d75cb8c0f7df..47903d510955 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -338,7 +338,7 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 	if (!urb || !urb->complete)
 		return -EINVAL;
 	if (urb->hcpriv) {
-		WARN_ONCE(1, "URB %p submitted while active\n", urb);
+		WARN_ONCE(1, "URB %pK submitted while active\n", urb);
 		return -EBUSY;
 	}
 

commit ae4d814bf1f2b0b7a37b3c30970d6974911f1377
Merge: 37be66767e3c d5c024f3761d
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Nov 18 16:02:15 2016 +0100

    Merge tag 'usb-for-v4.10' of git://git.kernel.org/pub/scm/linux/kernel/git/balbi/usb into usb-next
    
    Felipe writes:
    
    usb: patches for v4.10 merge window
    
    One big merge this time with a total of 166 non-merge commits.
    
    Most of the work, by far, is on dwc2 this time (68.2%) with dwc3 a far
    second (22.5%). The remaining 9.3% are scattered on gadget drivers.
    
    The most important changes for dwc2 are the peripheral side DMA support
    implemented by Synopsys folks and support for the new IOT dwc2
    compatible core from Synopsys.
    
    In dwc3 land we have support for high-bandwidth, high-speed isochronous
    endpoints and some non-critical fixes for large scatter lists.
    
    Apart from these, we have our usual set of cleanups, non-critical fixes,
    etc.

commit 5909cbc881d021b02a00413b3083c771c5a8e309
Author: Mike Krinkin <krinkin.m.u@gmail.com>
Date:   Sun Nov 13 13:31:16 2016 +0300

    usb: core: urb make use of usb_endpoint_maxp_mult
    
    Since usb_endpoint_maxp now returns only lower 11 bits mult
    calculation here isn't correct anymore and that breaks webcam
    for me. Patch make use of usb_endpoint_maxp_mult instead of
    direct calculation.
    
    Fixes: abb621844f6a ("usb: ch9: make usb_endpoint_maxp() return
           only packet size")
    
    Signed-off-by: Mike Krinkin <krinkin.m.u@gmail.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index a9039696476e..bd688a0661f9 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -407,11 +407,8 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 		}
 
 		/* "high bandwidth" mode, 1-3 packets/uframe? */
-		if (dev->speed == USB_SPEED_HIGH) {
-			int	mult = 1 + ((max >> 11) & 0x03);
-			max &= 0x07ff;
-			max *= mult;
-		}
+		if (dev->speed == USB_SPEED_HIGH)
+			max *= usb_endpoint_maxp_mult(&ep->desc);
 
 		if (urb->number_of_packets <= 0)
 			return -EINVAL;

commit b65fba3d87216bfe6ae9bc77be5eb6eabb6514a4
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Oct 28 17:16:36 2016 -0400

    USB: core: add missing license information to some files
    
    Some of the USB core files were missing explicit license information.
    As all files in the kernel tree are implicitly licensed under the
    GPLv2-only, be explicit in case someone get confused looking at
    individual files by using the SPDX nomenclature.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index a9039696476e..0be49a1e3e66 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -1,3 +1,8 @@
+/*
+ * Released under the GPLv2 only.
+ * SPDX-License-Identifier: GPL-2.0
+ */
+
 #include <linux/module.h>
 #include <linux/string.h>
 #include <linux/bitops.h>

commit b62a7a99b89970b66ebc1b1fd8ad29116ffc3519
Author: Wolfram Sang <wsa-dev@sang-engineering.com>
Date:   Thu Aug 25 19:39:01 2016 +0200

    usb: core: urb: don't print on ENOMEM
    
    All kmalloc-based functions print enough information on failures.
    
    Signed-off-by: Wolfram Sang <wsa-dev@sang-engineering.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index c601e25b609f..a9039696476e 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -68,10 +68,8 @@ struct urb *usb_alloc_urb(int iso_packets, gfp_t mem_flags)
 	urb = kmalloc(sizeof(struct urb) +
 		iso_packets * sizeof(struct usb_iso_packet_descriptor),
 		mem_flags);
-	if (!urb) {
-		printk(KERN_ERR "alloc_urb: kmalloc failed\n");
+	if (!urb)
 		return NULL;
-	}
 	usb_init_urb(urb);
 	return urb;
 }

commit 8a1b2725a60d3267135c15e80984b4406054f650
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Thu Dec 10 09:59:25 2015 +0200

    usb: define USB_SPEED_SUPER_PLUS speed for SuperSpeedPlus USB3.1 devices
    
    Add a new USB_SPEED_SUPER_PLUS device speed, and make sure usb core can
    handle the new speed.
    In most cases the behaviour is the same as with USB_SPEED_SUPER SuperSpeed
    devices. In a few places we add a "Plus" string to inform the user of the
    new speed.
    
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index 3d274778caaf..c601e25b609f 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -401,7 +401,7 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 		/* SuperSpeed isoc endpoints have up to 16 bursts of up to
 		 * 3 packets each
 		 */
-		if (dev->speed == USB_SPEED_SUPER) {
+		if (dev->speed >= USB_SPEED_SUPER) {
 			int     burst = 1 + ep->ss_ep_comp.bMaxBurst;
 			int     mult = USB_SS_MULT(ep->ss_ep_comp.bmAttributes);
 			max *= burst;
@@ -499,6 +499,7 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 		}
 		/* too big? */
 		switch (dev->speed) {
+		case USB_SPEED_SUPER_PLUS:
 		case USB_SPEED_SUPER:	/* units are 125us */
 			/* Handle up to 2^(16-1) microframes */
 			if (urb->interval > (1 << 15))

commit ae416ba4e94a30486ba2af0afe052579e7114ab8
Author: Jonas Hesselmann <jonas.hesselmann@hotmail.de>
Date:   Sun Oct 25 19:28:58 2015 +0100

    USB: core: Codestyle fix in urb.c
    
    Delete braces around single statement block suggested by checkpatch.pl
    
    Signed-off-by: Jonas Hesselmann <jonas.hesselmann@hotmail.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index c9e8ee81b6b7..3d274778caaf 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -129,9 +129,8 @@ void usb_anchor_urb(struct urb *urb, struct usb_anchor *anchor)
 	list_add_tail(&urb->anchor_list, &anchor->urb_list);
 	urb->anchor = anchor;
 
-	if (unlikely(anchor->poisoned)) {
+	if (unlikely(anchor->poisoned))
 		atomic_inc(&urb->reject);
-	}
 
 	spin_unlock_irqrestore(&anchor->lock, flags);
 }

commit 9672f0feb566423deb245032a1c9a7a14dacb6eb
Author: Amit Virdi <amit.virdi@st.com>
Date:   Mon Jul 21 10:46:18 2014 +0530

    usb: core: allow zero packet flag for interrupt urbs
    
    Section 4.4.7.2 "Interrupt Transfer Bandwidth Requirements" of the USB3.0 spec
    says:
            A zero-length data payload is a valid transfer and may be useful for
            some implementations.
    
    So, extend the logic of allowing URB_ZERO_PACKET to interrupt urbs too.
    Otherwise, the kernel throws warning of BOGUS transfer flags.
    
    Signed-off-by: Amit Virdi <amit.virdi@st.com>
    Acked-by: Hans de Goede <hdegoede@redhat.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index 991386ceb4ec..c9e8ee81b6b7 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -454,6 +454,7 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 			URB_FREE_BUFFER);
 	switch (xfertype) {
 	case USB_ENDPOINT_XFER_BULK:
+	case USB_ENDPOINT_XFER_INT:
 		if (is_out)
 			allowed |= URB_ZERO_PACKET;
 		/* FALLTHROUGH */

commit d4263348f796f29546f90802177865dd4379dd0a
Merge: be873ac782f5 6d0abeca3242
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Thu Feb 20 14:54:28 2014 +0100

    Merge branch 'master' into for-next

commit e227867f12302633737bd2a48a10a9a72c0630cb
Author: Masanari Iida <standby24x7@gmail.com>
Date:   Tue Feb 18 22:54:36 2014 +0900

    treewide: Fix typo in Documentation/DocBook
    
    This patch fix spelling typo in Documentation/DocBook.
    It is because .html and .xml files are generated by make htmldocs,
    I have to fix a typo within the source files.
    
    Signed-off-by: Masanari Iida <standby24x7@gmail.com>
    Acked-by: Randy Dunlap <rdunlap@infradead.org>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index e62208356c89..e726f5e80448 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -834,7 +834,7 @@ EXPORT_SYMBOL_GPL(usb_unpoison_anchored_urbs);
  *
  * this allows all outstanding URBs to be unlinked starting
  * from the back of the queue. This function is asynchronous.
- * The unlinking is just tiggered. It may happen after this
+ * The unlinking is just triggered. It may happen after this
  * function has returned.
  *
  * This routine should not be called by a driver after its disconnect

commit 803a536243b3a1ed2289f41897b11b72bd083309
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Wed Jan 8 11:08:26 2014 -0500

    usb: delete non-required instances of include <linux/init.h>
    
    None of these files are actually using any __init type directives
    and hence don't need to include <linux/init.h>.  Most are just a
    left over from __devinit and __cpuinit removal, or simply due to
    code getting copied from one driver to the next.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index 172d2698b8db..9ff665f1322f 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -2,7 +2,6 @@
 #include <linux/string.h>
 #include <linux/bitops.h>
 #include <linux/slab.h>
-#include <linux/init.h>
 #include <linux/log2.h>
 #include <linux/usb.h>
 #include <linux/wait.h>

commit 025d44309f92bd5e3d1b2c7fab66836ab25b541b
Author: Rahul Bedarkar <rahulbedarkar89@gmail.com>
Date:   Sat Jan 4 11:24:41 2014 +0530

    USB: core: correct spelling mistakes in comments and warning
    
    Signed-off-by: Rahul Bedarkar <rahulbedarkar89@gmail.com>
    Acked-by: Randy Dunlap <rdunlap@infradead.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index f4cb7fc1c929..172d2698b8db 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -53,7 +53,7 @@ EXPORT_SYMBOL_GPL(usb_init_urb);
  *	valid options for this.
  *
  * Creates an urb for the USB driver to use, initializes a few internal
- * structures, incrementes the usage counter, and returns a pointer to it.
+ * structures, increments the usage counter, and returns a pointer to it.
  *
  * If the driver want to use this urb for interrupt, control, or bulk
  * endpoints, pass '0' as the number of iso packets.
@@ -281,7 +281,7 @@ EXPORT_SYMBOL_GPL(usb_unanchor_urb);
  *
  * Device drivers must explicitly request that repetition, by ensuring that
  * some URB is always on the endpoint's queue (except possibly for short
- * periods during completion callacks).  When there is no longer an urb
+ * periods during completion callbacks).  When there is no longer an urb
  * queued, the endpoint's bandwidth reservation is canceled.  This means
  * drivers can use their completion handlers to ensure they keep bandwidth
  * they need, by reinitializing and resubmitting the just-completed urb

commit 3482528e9aced9234d4e2a4a9538c882a9aa5aa2
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu Dec 19 15:42:20 2013 -0800

    USB: core: remove CONFIG_USB_DEBUG usage
    
    CONFIG_USB_DEBUG is going away, so remove the few places in the USB core
    that relied on them.
    
    This means that we always now do the "debug" checks for every urb
    submitted, which is a good idea, as who knows how many driver bugs we
    have been ignoring when people forget to enable this option.  Also, with
    the overall speed of USB, doing these extra checks should not cause any
    additional overhead.
    
    Also, no longer announce all devices being added to the system if
    CONFIG_USB_DEBUG is enabled, as it's not going to be around much longer.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index 07c58af6b5c0..f4cb7fc1c929 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -325,10 +325,14 @@ EXPORT_SYMBOL_GPL(usb_unanchor_urb);
  */
 int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 {
+	static int			pipetypes[4] = {
+		PIPE_CONTROL, PIPE_ISOCHRONOUS, PIPE_BULK, PIPE_INTERRUPT
+	};
 	int				xfertype, max;
 	struct usb_device		*dev;
 	struct usb_host_endpoint	*ep;
 	int				is_out;
+	unsigned int			allowed;
 
 	if (!urb || !urb->complete)
 		return -EINVAL;
@@ -436,15 +440,10 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 	if (urb->transfer_buffer_length > INT_MAX)
 		return -EMSGSIZE;
 
-#ifdef DEBUG
-	/* stuff that drivers shouldn't do, but which shouldn't
+	/*
+	 * stuff that drivers shouldn't do, but which shouldn't
 	 * cause problems in HCDs if they get it wrong.
 	 */
-	{
-	unsigned int	allowed;
-	static int pipetypes[4] = {
-		PIPE_CONTROL, PIPE_ISOCHRONOUS, PIPE_BULK, PIPE_INTERRUPT
-	};
 
 	/* Check that the pipe's type matches the endpoint's type */
 	if (usb_pipetype(urb->pipe) != pipetypes[xfertype])
@@ -476,8 +475,7 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 	if (allowed != urb->transfer_flags)
 		dev_WARN(&dev->dev, "BOGUS urb flags, %x --> %x\n",
 			urb->transfer_flags, allowed);
-	}
-#endif
+
 	/*
 	 * Force periodic transfer intervals to be legal values that are
 	 * a power of two (so HCDs don't need to).

commit a2cd612dc9be768b516541b2164c843849bc3bb3
Author: Thomas Pugliese <thomas.pugliese@gmail.com>
Date:   Mon Dec 9 13:45:43 2013 -0600

    usb: core: allow isoc URBs for wireless devices with an interval < 6
    
    In usb_submit_urb, do not fail if an isoc URB for a wireless USB device
    has an interval < 6.  Per WUSB spec, isoc endpoints can support values
    from 1-16.  Valid values for interrupt URBs for wireless USB devices are
    still 6-16.
    
    Signed-off-by: Thomas Pugliese <thomas.pugliese@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index e62208356c89..07c58af6b5c0 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -492,9 +492,9 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 		/* too small? */
 		switch (dev->speed) {
 		case USB_SPEED_WIRELESS:
-			if (urb->interval < 6)
+			if ((urb->interval < 6)
+				&& (xfertype == USB_ENDPOINT_XFER_INT))
 				return -EINVAL;
-			break;
 		default:
 			if (urb->interval <= 0)
 				return -EINVAL;

commit 6ec4147e7bdbde168f5bce30de5984aa4f971b22
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Wed Oct 9 17:01:41 2013 +0200

    usb-anchor: Delay usb_wait_anchor_empty_timeout wake up till completion is done
    
    usb_wait_anchor_empty_timeout() should wait till the completion handler
    has run. Both the zd1211rw driver and the uas driver (in its task mgmt) depend
    on the completion handler having completed when usb_wait_anchor_empty_timeout()
    returns, as they read state set by the completion handler after an
    usb_wait_anchor_empty_timeout() call.
    
    But __usb_hcd_giveback_urb() calls usb_unanchor_urb before calling the
    completion handler. This is necessary as the completion handler may
    re-submit and re-anchor the urb. But this introduces a race where the state
    these drivers want to read has not been set yet by the completion handler
    (this race is easily triggered with the uas task mgmt code).
    
    I've considered adding an anchor_count to struct urb, which would be
    incremented on anchor and decremented on unanchor, and then only actually
    do the anchor / unanchor on 0 -> 1 and 1 -> 0 transtions, combined with
    moving the unanchor call in hcd_giveback_urb to after calling the completion
    handler. But this will only work if urb's are only re-anchored to the same
    anchor as they were anchored to before the completion handler ran.
    
    And at least one driver re-anchors to another anchor from the completion
    handler (rtlwifi).
    
    So I have come up with this patch instead, which adds the ability to
    suspend wakeups of usb_wait_anchor_empty_timeout() waiters to the usb_anchor
    functionality, and uses this in __usb_hcd_giveback_urb() to delay wake-ups
    until the completion handler has run.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Acked-by: Oliver Neukum <oliver@neukum.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index c12bc790a6a7..e62208356c89 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -138,13 +138,19 @@ void usb_anchor_urb(struct urb *urb, struct usb_anchor *anchor)
 }
 EXPORT_SYMBOL_GPL(usb_anchor_urb);
 
+static int usb_anchor_check_wakeup(struct usb_anchor *anchor)
+{
+	return atomic_read(&anchor->suspend_wakeups) == 0 &&
+		list_empty(&anchor->urb_list);
+}
+
 /* Callers must hold anchor->lock */
 static void __usb_unanchor_urb(struct urb *urb, struct usb_anchor *anchor)
 {
 	urb->anchor = NULL;
 	list_del(&urb->anchor_list);
 	usb_put_urb(urb);
-	if (list_empty(&anchor->urb_list))
+	if (usb_anchor_check_wakeup(anchor))
 		wake_up(&anchor->wait);
 }
 
@@ -845,6 +851,39 @@ void usb_unlink_anchored_urbs(struct usb_anchor *anchor)
 }
 EXPORT_SYMBOL_GPL(usb_unlink_anchored_urbs);
 
+/**
+ * usb_anchor_suspend_wakeups
+ * @anchor: the anchor you want to suspend wakeups on
+ *
+ * Call this to stop the last urb being unanchored from waking up any
+ * usb_wait_anchor_empty_timeout waiters. This is used in the hcd urb give-
+ * back path to delay waking up until after the completion handler has run.
+ */
+void usb_anchor_suspend_wakeups(struct usb_anchor *anchor)
+{
+	if (anchor)
+		atomic_inc(&anchor->suspend_wakeups);
+}
+EXPORT_SYMBOL_GPL(usb_anchor_suspend_wakeups);
+
+/**
+ * usb_anchor_resume_wakeups
+ * @anchor: the anchor you want to resume wakeups on
+ *
+ * Allow usb_wait_anchor_empty_timeout waiters to be woken up again, and
+ * wake up any current waiters if the anchor is empty.
+ */
+void usb_anchor_resume_wakeups(struct usb_anchor *anchor)
+{
+	if (!anchor)
+		return;
+
+	atomic_dec(&anchor->suspend_wakeups);
+	if (usb_anchor_check_wakeup(anchor))
+		wake_up(&anchor->wait);
+}
+EXPORT_SYMBOL_GPL(usb_anchor_resume_wakeups);
+
 /**
  * usb_wait_anchor_empty_timeout - wait for an anchor to be unused
  * @anchor: the anchor you want to become unused
@@ -858,7 +897,8 @@ EXPORT_SYMBOL_GPL(usb_unlink_anchored_urbs);
 int usb_wait_anchor_empty_timeout(struct usb_anchor *anchor,
 				  unsigned int timeout)
 {
-	return wait_event_timeout(anchor->wait, list_empty(&anchor->urb_list),
+	return wait_event_timeout(anchor->wait,
+				  usb_anchor_check_wakeup(anchor),
 				  msecs_to_jiffies(timeout));
 }
 EXPORT_SYMBOL_GPL(usb_wait_anchor_empty_timeout);

commit bcc48f1a7a0d40ae2e5a26aff72c2b674fd8b596
Author: Ming Lei <ming.lei@canonical.com>
Date:   Thu Aug 8 21:48:22 2013 +0800

    USB: introduce usb_device_no_sg_constraint() helper
    
    Some host controllers(such as xHCI) can support building
    packet from discontinuous buffers, so introduce one flag
    and helper for this kind of host controllers, then the
    feature can help some applications(such as usbnet) by
    supporting arbitrary length of sg buffers.
    
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Ming Lei <ming.lei@canonical.com>
    Reviewed-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index 4e7a311ff6d7..c12bc790a6a7 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -416,7 +416,8 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 			urb->iso_frame_desc[n].status = -EXDEV;
 			urb->iso_frame_desc[n].actual_length = 0;
 		}
-	} else if (dev->speed != USB_SPEED_WIRELESS && urb->num_sgs) {
+	} else if (urb->num_sgs && !urb->dev->bus->no_sg_constraint &&
+			dev->speed != USB_SPEED_WIRELESS) {
 		struct scatterlist *sg;
 		int i;
 

commit 626f090c5cbbe557379978c7a9525011ad7fbbf6
Author: Yacine Belkadi <yacine.belkadi.1@gmail.com>
Date:   Fri Aug 2 20:10:04 2013 +0200

    usb: fix some scripts/kernel-doc warnings
    
    When building the htmldocs (in verbose mode), scripts/kernel-doc reports the
    following type of warnings:
    
    Warning(drivers/usb/core/usb.c:76): No description found for return value of
    'usb_find_alt_setting'
    
    Fix them by:
    - adding some missing descriptions of return values
    - using "Return" sections for those descriptions
    
    Signed-off-by: Yacine Belkadi <yacine.belkadi.1@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index e75115a04a2e..4e7a311ff6d7 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -55,12 +55,12 @@ EXPORT_SYMBOL_GPL(usb_init_urb);
  * Creates an urb for the USB driver to use, initializes a few internal
  * structures, incrementes the usage counter, and returns a pointer to it.
  *
- * If no memory is available, NULL is returned.
- *
  * If the driver want to use this urb for interrupt, control, or bulk
  * endpoints, pass '0' as the number of iso packets.
  *
  * The driver must call usb_free_urb() when it is finished with the urb.
+ *
+ * Return: A pointer to the new urb, or %NULL if no memory is available.
  */
 struct urb *usb_alloc_urb(int iso_packets, gfp_t mem_flags)
 {
@@ -103,7 +103,7 @@ EXPORT_SYMBOL_GPL(usb_free_urb);
  * host controller driver.  This allows proper reference counting to happen
  * for urbs.
  *
- * A pointer to the urb with the incremented reference counter is returned.
+ * Return: A pointer to the urb with the incremented reference counter.
  */
 struct urb *usb_get_urb(struct urb *urb)
 {
@@ -200,13 +200,12 @@ EXPORT_SYMBOL_GPL(usb_unanchor_urb);
  * the particular kind of transfer, although they will not initialize
  * any transfer flags.
  *
- * Successful submissions return 0; otherwise this routine returns a
- * negative error number.  If the submission is successful, the complete()
- * callback from the URB will be called exactly once, when the USB core and
- * Host Controller Driver (HCD) are finished with the URB.  When the completion
- * function is called, control of the URB is returned to the device
- * driver which issued the request.  The completion handler may then
- * immediately free or reuse that URB.
+ * If the submission is successful, the complete() callback from the URB
+ * will be called exactly once, when the USB core and Host Controller Driver
+ * (HCD) are finished with the URB.  When the completion function is called,
+ * control of the URB is returned to the device driver which issued the
+ * request.  The completion handler may then immediately free or reuse that
+ * URB.
  *
  * With few exceptions, USB device drivers should never access URB fields
  * provided by usbcore or the HCD until its complete() is called.
@@ -241,6 +240,9 @@ EXPORT_SYMBOL_GPL(usb_unanchor_urb);
  * that are standardized in the USB 2.0 specification.  For bulk
  * endpoints, a synchronous usb_bulk_msg() call is available.
  *
+ * Return:
+ * 0 on successful submissions. A negative error number otherwise.
+ *
  * Request Queuing:
  *
  * URBs may be submitted to endpoints before previous ones complete, to
@@ -572,6 +574,9 @@ EXPORT_SYMBOL_GPL(usb_submit_urb);
  * particular, when a driver calls this routine, it must insure that the
  * completion handler cannot deallocate the URB.
  *
+ * Return: -EINPROGRESS on success. See description for other values on
+ * failure.
+ *
  * Unlinking and Endpoint Queues:
  *
  * [The behaviors and guarantees described below do not apply to virtual
@@ -846,6 +851,8 @@ EXPORT_SYMBOL_GPL(usb_unlink_anchored_urbs);
  *
  * Call this is you want to be sure all an anchor's
  * URBs have finished
+ *
+ * Return: Non-zero if the anchor became unused. Zero on timeout.
  */
 int usb_wait_anchor_empty_timeout(struct usb_anchor *anchor,
 				  unsigned int timeout)
@@ -859,8 +866,11 @@ EXPORT_SYMBOL_GPL(usb_wait_anchor_empty_timeout);
  * usb_get_from_anchor - get an anchor's oldest urb
  * @anchor: the anchor whose urb you want
  *
- * this will take the oldest urb from an anchor,
+ * This will take the oldest urb from an anchor,
  * unanchor and return it
+ *
+ * Return: The oldest urb from @anchor, or %NULL if @anchor has no
+ * urbs associated with it.
  */
 struct urb *usb_get_from_anchor(struct usb_anchor *anchor)
 {
@@ -909,7 +919,7 @@ EXPORT_SYMBOL_GPL(usb_scuttle_anchored_urbs);
  * usb_anchor_empty - is an anchor empty
  * @anchor: the anchor you want to query
  *
- * returns 1 if the anchor has no urbs associated with it
+ * Return: 1 if the anchor has no urbs associated with it.
  */
 int usb_anchor_empty(struct usb_anchor *anchor)
 {

commit 10e232c597ac757e7f8600649f7e872e86de190f
Author: Ming Lei <ming.lei@canonical.com>
Date:   Fri Jun 28 09:38:12 2013 +0800

    USB: check sg buffer size in usb_submit_urb
    
    USB spec stats that short packet can only appear at the end
    of transfer. Because lost of HC(EHCI/UHCI/OHCI/...) can't
    build a full packet from discontinuous buffers, we introduce
    the limit in usb_submit_urb() to avoid such kind of bad sg buffers
    coming from driver.
    
    The limit might be a bit strict:
            - platform has iommu to do sg list mapping
            - some host controllers may support to build full packet from
            discontinuous buffers.
    
    But considered that most of HCs don't support that, and driver
    need work well or keep consistent on different HCs and ARCHs, we
    have to introduce the limit.
    
    Currently, only usbtest is reported to pass such sg buffers to HC,
    and other users(mass storage, usbfs) don't have the problem.
    
    We don't check it on USB wireless device, because:
            - wireless devices can't be attached to common USB
              bus(EHCI/UHCI/OHCI/...)
            - the max packet size of endpoint may be odd, and often can't
            devide 4KB which is a typical usage in usb mass storage application
    
    Reported-by: Konstantin Filatov <kfilatov@parallels.com>
    Reported-by: Denis V. Lunev <den@openvz.org>
    Cc: Felipe Balbi <balbi@ti.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Ming Lei <ming.lei@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index 16927fa88fbd..e75115a04a2e 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -7,6 +7,7 @@
 #include <linux/usb.h>
 #include <linux/wait.h>
 #include <linux/usb/hcd.h>
+#include <linux/scatterlist.h>
 
 #define to_urb(d) container_of(d, struct urb, kref)
 
@@ -413,6 +414,13 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 			urb->iso_frame_desc[n].status = -EXDEV;
 			urb->iso_frame_desc[n].actual_length = 0;
 		}
+	} else if (dev->speed != USB_SPEED_WIRELESS && urb->num_sgs) {
+		struct scatterlist *sg;
+		int i;
+
+		for_each_sg(urb->sg, sg, urb->num_sgs - 1, i)
+			if (sg->length % max)
+				return -EINVAL;
 	}
 
 	/* the I/O buffer must be mapped/unmapped, except when length=0 */

commit 68a2bed130a10cffbf68620f41d08a900b1d776b
Author: Johan Hovold <jhovold@gmail.com>
Date:   Thu Mar 21 12:36:48 2013 +0100

    USB: fix urb-poison imbalance
    
    The calls to usb_poison_urb and usb_unpoison_urb are expected to be
    balanced. However, if an urb that has not yet been submitted is
    poisoned, its reject counter will not be increased as its ep-field is
    NULL. A consecutive call to unpoison will thus in fact poison the urb
    as its reject counter will be decremented to a negative value,
    effectively preventing the urb from being submitted.
    
    Note that there are currently no in-kernel drivers affected by this.
    
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Johan Hovold <jhovold@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index e0d9d948218c..16927fa88fbd 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -683,10 +683,13 @@ EXPORT_SYMBOL_GPL(usb_kill_urb);
 void usb_poison_urb(struct urb *urb)
 {
 	might_sleep();
-	if (!(urb && urb->dev && urb->ep))
+	if (!urb)
 		return;
 	atomic_inc(&urb->reject);
 
+	if (!urb->dev || !urb->ep)
+		return;
+
 	usb_hcd_unlink_urb(urb, -ENOENT);
 	wait_event(usb_kill_urb_queue, atomic_read(&urb->use_count) == 0);
 }

commit 2f02bc8af3abb846823811af65ec6cc46a4d525d
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Nov 7 16:35:00 2012 -0500

    USB: report submission of active URBs
    
    This patch (as1633) changes slightly the way usbcore handled
    submissions of URBs that are already active.  It will now return
    -EBUSY rather than -EINVAL, and it will call WARN_ONCE to draw
    people's attention to the bug.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index 3662287e2f4f..e0d9d948218c 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -321,8 +321,13 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 	struct usb_host_endpoint	*ep;
 	int				is_out;
 
-	if (!urb || urb->hcpriv || !urb->complete)
+	if (!urb || !urb->complete)
 		return -EINVAL;
+	if (urb->hcpriv) {
+		WARN_ONCE(1, "URB %p submitted while active\n", urb);
+		return -EBUSY;
+	}
+
 	dev = urb->dev;
 	if ((!dev) || (dev->state < USB_STATE_UNAUTHENTICATED))
 		return -ENODEV;

commit a03bede5c73a6876fa891cfe82a65460dc9f4698
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Oct 1 10:31:53 2012 -0400

    USB: update documentation for URB_ISO_ASAP
    
    This patch (as1611) updates the USB documentation and kerneldoc to
    give a more precise meaning for the URB_ISO_ASAP flag and to explain
    more of the details of scheduling for isochronous URBs.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index 9d912bfdcffe..3662287e2f4f 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -214,9 +214,25 @@ EXPORT_SYMBOL_GPL(usb_unanchor_urb);
  * urb->interval is modified to reflect the actual transfer period used
  * (normally some power of two units).  And for isochronous urbs,
  * urb->start_frame is modified to reflect when the URB's transfers were
- * scheduled to start.  Not all isochronous transfer scheduling policies
- * will work, but most host controller drivers should easily handle ISO
- * queues going from now until 10-200 msec into the future.
+ * scheduled to start.
+ *
+ * Not all isochronous transfer scheduling policies will work, but most
+ * host controller drivers should easily handle ISO queues going from now
+ * until 10-200 msec into the future.  Drivers should try to keep at
+ * least one or two msec of data in the queue; many controllers require
+ * that new transfers start at least 1 msec in the future when they are
+ * added.  If the driver is unable to keep up and the queue empties out,
+ * the behavior for new submissions is governed by the URB_ISO_ASAP flag.
+ * If the flag is set, or if the queue is idle, then the URB is always
+ * assigned to the first available (and not yet expired) slot in the
+ * endpoint's schedule.  If the flag is not set and the queue is active
+ * then the URB is always assigned to the next slot in the schedule
+ * following the end of the endpoint's previous URB, even if that slot is
+ * in the past.  When a packet is assigned in this way to a slot that has
+ * already expired, the packet is not transmitted and the corresponding
+ * usb_iso_packet_descriptor's status field will return -EXDEV.  If this
+ * would happen to all the packets in the URB, submission fails with a
+ * -EXDEV error code.
  *
  * For control endpoints, the synchronous usb_control_msg() call is
  * often used (in non-interrupt context) instead of this call.

commit 8815bb09af21316aeb5f8948b24ac62181670db2
Author: Oliver Neukum <oliver@neukum.org>
Date:   Mon Apr 30 09:13:46 2012 +0200

    usbhid: prevent deadlock during timeout
    
    On some HCDs usb_unlink_urb() can directly call the
    completion handler. That limits the spinlocks that can
    be taken in the handler to locks not held while calling
    usb_unlink_urb()
    To prevent a race with resubmission, this patch exposes
    usbcore's infrastructure for blocking submission, uses it
    and so drops the lock without causing a race in usbhid.
    
    Signed-off-by: Oliver Neukum <oneukum@suse.de>
    Acked-by: Jiri Kosina <jkosina@suse.cz>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index cd9b3a2cd8a7..9d912bfdcffe 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -680,6 +680,27 @@ void usb_unpoison_urb(struct urb *urb)
 }
 EXPORT_SYMBOL_GPL(usb_unpoison_urb);
 
+/**
+ * usb_block_urb - reliably prevent further use of an URB
+ * @urb: pointer to URB to be blocked, may be NULL
+ *
+ * After the routine has run, attempts to resubmit the URB will fail
+ * with error -EPERM.  Thus even if the URB's completion handler always
+ * tries to resubmit, it will not succeed and the URB will become idle.
+ *
+ * The URB must not be deallocated while this routine is running.  In
+ * particular, when a driver calls this routine, it must insure that the
+ * completion handler cannot deallocate the URB.
+ */
+void usb_block_urb(struct urb *urb)
+{
+	if (!urb)
+		return;
+
+	atomic_inc(&urb->reject);
+}
+EXPORT_SYMBOL_GPL(usb_block_urb);
+
 /**
  * usb_kill_anchored_urbs - cancel transfer requests en masse
  * @anchor: anchor the requests are bound to

commit da8bfb090c2b30af9f3879443355f7eb1d0fe10a
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Mar 28 16:13:28 2012 -0400

    USB documentation: explain lifetime rules for unlinking URBs
    
    This patch (as1534c) updates the documentation for usb_unlink_urb and
    related functions.  It explains that the caller must prevent the URB
    being unlinked from getting deallocated while the unlink is taking
    place.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    CC: Ming Lei <tom.leiming@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index 7239a73c1b8c..cd9b3a2cd8a7 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -539,6 +539,10 @@ EXPORT_SYMBOL_GPL(usb_submit_urb);
  * never submitted, or it was unlinked before, or the hardware is already
  * finished with it), even if the completion handler has not yet run.
  *
+ * The URB must not be deallocated while this routine is running.  In
+ * particular, when a driver calls this routine, it must insure that the
+ * completion handler cannot deallocate the URB.
+ *
  * Unlinking and Endpoint Queues:
  *
  * [The behaviors and guarantees described below do not apply to virtual
@@ -603,6 +607,10 @@ EXPORT_SYMBOL_GPL(usb_unlink_urb);
  * with error -EPERM.  Thus even if the URB's completion handler always
  * tries to resubmit, it will not succeed and the URB will become idle.
  *
+ * The URB must not be deallocated while this routine is running.  In
+ * particular, when a driver calls this routine, it must insure that the
+ * completion handler cannot deallocate the URB.
+ *
  * This routine may not be used in an interrupt context (such as a bottom
  * half or a completion handler), or when holding a spinlock, or in other
  * situations where the caller can't schedule().
@@ -640,6 +648,10 @@ EXPORT_SYMBOL_GPL(usb_kill_urb);
  * with error -EPERM.  Thus even if the URB's completion handler always
  * tries to resubmit, it will not succeed and the URB will become idle.
  *
+ * The URB must not be deallocated while this routine is running.  In
+ * particular, when a driver calls this routine, it must insure that the
+ * completion handler cannot deallocate the URB.
+ *
  * This routine may not be used in an interrupt context (such as a bottom
  * half or a completion handler), or when holding a spinlock, or in other
  * situations where the caller can't schedule().

commit 371f3b49f2cb1a8b6ac09b6b108841ca92349eb1
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Wed Feb 29 23:04:32 2012 +0100

    usb/core: remove "always" from usb_unlink_urb() kernel doc entry
    
    The kernel doc entry for usb_unlink_urb() contains the phrase "This
    request is always asynchronous.". The "always" leads to the assumption
    that the ->complete() callback is not called from within
    usb_unlink_urb(). This is not true. The HCD is allowed to call the
    ->complete() from within ->urb_dequeue() if it is appropriate for the
    hardware.
    This patch updates the kernel doc so usb-device driver authors make sure
    to drop all locks (and make sure it is okay to drop them) which are
    acquired by the complete callback before calling usb_unlink_urb().
    
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index f4f20c7b7765..7239a73c1b8c 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -527,10 +527,13 @@ EXPORT_SYMBOL_GPL(usb_submit_urb);
  * a driver's I/O routines to insure that all URB-related activity has
  * completed before it returns.
  *
- * This request is always asynchronous.  Success is indicated by
- * returning -EINPROGRESS, at which time the URB will probably not yet
- * have been given back to the device driver.  When it is eventually
- * called, the completion function will see @urb->status == -ECONNRESET.
+ * This request is asynchronous, however the HCD might call the ->complete()
+ * callback during unlink. Therefore when drivers call usb_unlink_urb(), they
+ * must not hold any locks that may be taken by the completion function.
+ * Success is indicated by returning -EINPROGRESS, at which time the URB will
+ * probably not yet have been given back to the device driver. When it is
+ * eventually called, the completion function will see @urb->status ==
+ * -ECONNRESET.
  * Failure is indicated by usb_unlink_urb() returning any other value.
  * Unlinking will fail when @urb is not currently "linked" (i.e., it was
  * never submitted, or it was unlinked before, or the hardware is already

commit 0cb54a3e47cb4baf0bc7463f0a64cfeae5e35697
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Thu Feb 2 15:38:14 2012 -0500

    USB: debugging code shouldn't alter control flow
    
    People have complained that debugging code shouldn't alter the flow of
    control; it should restrict itself to printing out warnings and error
    messages.  Bowing to popular opinion, this patch (as1518) changes the
    debugging checks in usb_submit_urb() to follow this guideline.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Reported-by: Keith Packard <keithp@keithp.com>
    CC: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index 909625b91eb3..f4f20c7b7765 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -403,20 +403,17 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 	 * cause problems in HCDs if they get it wrong.
 	 */
 	{
-	unsigned int	orig_flags = urb->transfer_flags;
 	unsigned int	allowed;
 	static int pipetypes[4] = {
 		PIPE_CONTROL, PIPE_ISOCHRONOUS, PIPE_BULK, PIPE_INTERRUPT
 	};
 
 	/* Check that the pipe's type matches the endpoint's type */
-	if (usb_pipetype(urb->pipe) != pipetypes[xfertype]) {
-		dev_err(&dev->dev, "BOGUS urb xfer, pipe %x != type %x\n",
+	if (usb_pipetype(urb->pipe) != pipetypes[xfertype])
+		dev_WARN(&dev->dev, "BOGUS urb xfer, pipe %x != type %x\n",
 			usb_pipetype(urb->pipe), pipetypes[xfertype]);
-		return -EPIPE;		/* The most suitable error code :-) */
-	}
 
-	/* enforce simple/standard policy */
+	/* Check against a simple/standard policy */
 	allowed = (URB_NO_TRANSFER_DMA_MAP | URB_NO_INTERRUPT | URB_DIR_MASK |
 			URB_FREE_BUFFER);
 	switch (xfertype) {
@@ -435,14 +432,12 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 		allowed |= URB_ISO_ASAP;
 		break;
 	}
-	urb->transfer_flags &= allowed;
+	allowed &= urb->transfer_flags;
 
-	/* fail if submitter gave bogus flags */
-	if (urb->transfer_flags != orig_flags) {
-		dev_err(&dev->dev, "BOGUS urb flags, %x --> %x\n",
-			orig_flags, urb->transfer_flags);
-		return -EINVAL;
-	}
+	/* warn if submitter gave bogus flags */
+	if (allowed != urb->transfer_flags)
+		dev_WARN(&dev->dev, "BOGUS urb flags, %x --> %x\n",
+			urb->transfer_flags, allowed);
 	}
 #endif
 	/*

commit 29cc88979a8818cd8c5019426e945aed118b400e
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Aug 23 03:12:03 2011 -0700

    USB: use usb_endpoint_maxp() instead of le16_to_cpu()
    
    Now ${LINUX}/drivers/usb/* can use usb_endpoint_maxp(desc) to get maximum packet size
    instead of le16_to_cpu(desc->wMaxPacketSize).
    This patch fix it up
    
    Cc: Armin Fuerst <fuerst@in.tum.de>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: Johannes Erdfelt <johannes@erdfelt.com>
    Cc: Vojtech Pavlik <vojtech@suse.cz>
    Cc: Oliver Neukum <oliver@neukum.name>
    Cc: David Kubicek <dave@awk.cz>
    Cc: Johan Hovold <jhovold@gmail.com>
    Cc: Brad Hards <bhards@bigpond.net.au>
    Acked-by: Felipe Balbi <balbi@ti.com>
    Cc: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Cc: Thomas Dahlmann <dahlmann.thomas@arcor.de>
    Cc: David Brownell <david-b@pacbell.net>
    Cc: David Lopo <dlopo@chipidea.mips.com>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Michal Nazarewicz <m.nazarewicz@samsung.com>
    Cc: Xie Xiaobo <X.Xie@freescale.com>
    Cc: Li Yang <leoli@freescale.com>
    Cc: Jiang Bo <tanya.jiang@freescale.com>
    Cc: Yuan-hsin Chen <yhchen@faraday-tech.com>
    Cc: Darius Augulis <augulis.darius@gmail.com>
    Cc: Xiaochen Shen <xiaochen.shen@intel.com>
    Cc: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
    Cc: OKI SEMICONDUCTOR, <toshiharu-linux@dsn.okisemi.com>
    Cc: Robert Jarzmik <robert.jarzmik@free.fr>
    Cc: Ben Dooks <ben@simtec.co.uk>
    Cc: Thomas Abraham <thomas.ab@samsung.com>
    Cc: Herbert Pötzl <herbert@13thfloor.at>
    Cc: Arnaud Patard <arnaud.patard@rtp-net.org>
    Cc: Roman Weissgaerber <weissg@vienna.at>
    Acked-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Cc: Tony Olech <tony.olech@elandigitalsystems.com>
    Cc: Florian Floe Echtler <echtler@fs.tum.de>
    Cc: Christian Lucht <lucht@codemercs.com>
    Cc: Juergen Stuber <starblue@sourceforge.net>
    Cc: Georges Toth <g.toth@e-biz.lu>
    Cc: Bill Ryder <bryder@sgi.com>
    Cc: Kuba Ober <kuba@mareimbrium.org>
    Cc: Inaky Perez-Gonzalez <inaky.perez-gonzalez@intel.com>
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index ae334b067c13..909625b91eb3 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -350,7 +350,7 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 			dev->state < USB_STATE_CONFIGURED)
 		return -ENODEV;
 
-	max = le16_to_cpu(ep->desc.wMaxPacketSize);
+	max = usb_endpoint_maxp(&ep->desc);
 	if (max <= 0) {
 		dev_dbg(&dev->dev,
 			"bogus endpoint ep%d%s in %s (bad maxpacket %d)\n",

commit 500132a0f26ad7d9916102193cbc6c1b1becb373
Author: Paul Zimmerman <Paul.Zimmerman@synopsys.com>
Date:   Mon Feb 28 18:11:27 2011 -0800

    USB: Add support for SuperSpeed isoc endpoints
    
    Use the Mult and bMaxBurst values from the endpoint companion
    descriptor to calculate the max length of an isoc transfer.
    
    Add USB_SS_MULT macro to access Mult field of bmAttributes, at
    Sarah's suggestion.
    
    This patch should be queued for the 2.6.36 and 2.6.37 stable trees, since
    those were the first kernels to have isochronous support for SuperSpeed
    devices.
    
    Signed-off-by: Paul Zimmerman <paulz@synopsys.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Cc: stable@kernel.org

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index c14fc082864f..ae334b067c13 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -366,7 +366,16 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 	if (xfertype == USB_ENDPOINT_XFER_ISOC) {
 		int	n, len;
 
-		/* FIXME SuperSpeed isoc endpoints have up to 16 bursts */
+		/* SuperSpeed isoc endpoints have up to 16 bursts of up to
+		 * 3 packets each
+		 */
+		if (dev->speed == USB_SPEED_SUPER) {
+			int     burst = 1 + ep->ss_ep_comp.bMaxBurst;
+			int     mult = USB_SS_MULT(ep->ss_ep_comp.bmAttributes);
+			max *= burst;
+			max *= mult;
+		}
+
 		/* "high bandwidth" mode, 1-3 packets/uframe? */
 		if (dev->speed == USB_SPEED_HIGH) {
 			int	mult = 1 + ((max >> 11) & 0x03);

commit f7dd64916bb6cfae8c96eaa3c754c30b5046586f
Author: Simon Arlott <simon@fire.lp0.eu>
Date:   Mon Aug 30 22:50:20 2010 +0100

    USB: output an error message when the pipe type doesn't match the endpoint type
    
    Commit f661c6f8c67bd55e93348f160d590ff9edf08904 adds a check of the pipe type if
    CONFIG_USB_DEBUG is enabled, but it doesn't output anything if this scenario
    occurs.
    
    Signed-off-by: Simon Arlott <simon@fire.lp0.eu>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index 419e6b34e2fe..c14fc082864f 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -401,8 +401,11 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 	};
 
 	/* Check that the pipe's type matches the endpoint's type */
-	if (usb_pipetype(urb->pipe) != pipetypes[xfertype])
+	if (usb_pipetype(urb->pipe) != pipetypes[xfertype]) {
+		dev_err(&dev->dev, "BOGUS urb xfer, pipe %x != type %x\n",
+			usb_pipetype(urb->pipe), pipetypes[xfertype]);
 		return -EPIPE;		/* The most suitable error code :-) */
+	}
 
 	/* enforce simple/standard policy */
 	allowed = (URB_NO_TRANSFER_DMA_MAP | URB_NO_INTERRUPT | URB_DIR_MASK |

commit b3e670443b7fb8a2d29831b62b44a039c283e351
Author: Christian Lamparter <chunkeey@googlemail.com>
Date:   Tue Aug 3 02:32:28 2010 +0200

    USB: fix thread-unsafe anchor utiliy routines
    
    This patch fixes a race condition in two utility routines
    related to the removal/unlinking of urbs from an anchor.
    
    If two threads are concurrently accessing the same anchor,
    both could end up with the same urb - thinking they are
    the exclusive owner.
    
    Alan Stern pointed out a related issue in
    usb_unlink_anchored_urbs:
    
    "The URB isn't removed from the anchor until it completes
     (as a by-product of completion, in fact), which might not
     be for quite some time after the unlink call returns.
     In the meantime, the subroutine will keep trying to unlink
     it, over and over again."
    
    Cc: stable <stable@kernel.org>
    Cc: Oliver Neukum <oneukum@suse.de>
    Cc: Greg Kroah-Hartman <greg@kroah.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Christian Lamparter <chunkeey@googlemail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index 7c0555548ac8..419e6b34e2fe 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -137,6 +137,16 @@ void usb_anchor_urb(struct urb *urb, struct usb_anchor *anchor)
 }
 EXPORT_SYMBOL_GPL(usb_anchor_urb);
 
+/* Callers must hold anchor->lock */
+static void __usb_unanchor_urb(struct urb *urb, struct usb_anchor *anchor)
+{
+	urb->anchor = NULL;
+	list_del(&urb->anchor_list);
+	usb_put_urb(urb);
+	if (list_empty(&anchor->urb_list))
+		wake_up(&anchor->wait);
+}
+
 /**
  * usb_unanchor_urb - unanchors an URB
  * @urb: pointer to the urb to anchor
@@ -156,17 +166,14 @@ void usb_unanchor_urb(struct urb *urb)
 		return;
 
 	spin_lock_irqsave(&anchor->lock, flags);
-	if (unlikely(anchor != urb->anchor)) {
-		/* we've lost the race to another thread */
-		spin_unlock_irqrestore(&anchor->lock, flags);
-		return;
-	}
-	urb->anchor = NULL;
-	list_del(&urb->anchor_list);
+	/*
+	 * At this point, we could be competing with another thread which
+	 * has the same intention. To protect the urb from being unanchored
+	 * twice, only the winner of the race gets the job.
+	 */
+	if (likely(anchor == urb->anchor))
+		__usb_unanchor_urb(urb, anchor);
 	spin_unlock_irqrestore(&anchor->lock, flags);
-	usb_put_urb(urb);
-	if (list_empty(&anchor->urb_list))
-		wake_up(&anchor->wait);
 }
 EXPORT_SYMBOL_GPL(usb_unanchor_urb);
 
@@ -749,20 +756,11 @@ EXPORT_SYMBOL_GPL(usb_unpoison_anchored_urbs);
 void usb_unlink_anchored_urbs(struct usb_anchor *anchor)
 {
 	struct urb *victim;
-	unsigned long flags;
 
-	spin_lock_irqsave(&anchor->lock, flags);
-	while (!list_empty(&anchor->urb_list)) {
-		victim = list_entry(anchor->urb_list.prev, struct urb,
-				    anchor_list);
-		usb_get_urb(victim);
-		spin_unlock_irqrestore(&anchor->lock, flags);
-		/* this will unanchor the URB */
+	while ((victim = usb_get_from_anchor(anchor)) != NULL) {
 		usb_unlink_urb(victim);
 		usb_put_urb(victim);
-		spin_lock_irqsave(&anchor->lock, flags);
 	}
-	spin_unlock_irqrestore(&anchor->lock, flags);
 }
 EXPORT_SYMBOL_GPL(usb_unlink_anchored_urbs);
 
@@ -799,12 +797,11 @@ struct urb *usb_get_from_anchor(struct usb_anchor *anchor)
 		victim = list_entry(anchor->urb_list.next, struct urb,
 				    anchor_list);
 		usb_get_urb(victim);
-		spin_unlock_irqrestore(&anchor->lock, flags);
-		usb_unanchor_urb(victim);
+		__usb_unanchor_urb(victim, anchor);
 	} else {
-		spin_unlock_irqrestore(&anchor->lock, flags);
 		victim = NULL;
 	}
+	spin_unlock_irqrestore(&anchor->lock, flags);
 
 	return victim;
 }
@@ -826,12 +823,7 @@ void usb_scuttle_anchored_urbs(struct usb_anchor *anchor)
 	while (!list_empty(&anchor->urb_list)) {
 		victim = list_entry(anchor->urb_list.prev, struct urb,
 				    anchor_list);
-		usb_get_urb(victim);
-		spin_unlock_irqrestore(&anchor->lock, flags);
-		/* this may free the URB */
-		usb_unanchor_urb(victim);
-		usb_put_urb(victim);
-		spin_lock_irqsave(&anchor->lock, flags);
+		__usb_unanchor_urb(victim, anchor);
 	}
 	spin_unlock_irqrestore(&anchor->lock, flags);
 }

commit fe54b058de9d1df5fef9e2a559651f4b7c9f04b1
Author: Matthew Wilcox <willy@linux.intel.com>
Date:   Fri Apr 30 13:11:29 2010 -0600

    USB: Add a usb_pipe_endpoint() convenience function
    
    Converting a pipe number to a struct usb_host_endpoint pointer is a little
    messy.  Introduce a new convenience function to hide the mess.
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index a760e46871c5..7c0555548ac8 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -308,8 +308,7 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 	 * will be required to set urb->ep directly and we will eliminate
 	 * urb->pipe.
 	 */
-	ep = (usb_pipein(urb->pipe) ? dev->ep_in : dev->ep_out)
-			[usb_pipeendpoint(urb->pipe)];
+	ep = usb_pipe_endpoint(dev, urb->pipe);
 	if (!ep)
 		return -ENOENT;
 

commit ff9c895f07d36193c75533bda8193bde8ca99d02
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Apr 2 13:27:28 2010 -0400

    USB: fix usbmon and DMA mapping for scatter-gather URBs
    
    This patch (as1368) fixes a rather obscure bug in usbmon: When tracing
    URBs sent by the scatter-gather library, it accesses the data buffers
    while they are still mapped for DMA.
    
    The solution is to move the mapping and unmapping out of the s-g
    library and into the usual place in hcd.c.  This requires the addition
    of new URB flag bits to describe the kind of mapping needed, since we
    have to call dma_map_sg() if the HCD supports native scatter-gather
    operation and dma_map_page() if it doesn't.  The nice thing about
    having the new flags is that they simplify the testing for unmapping.
    
    The patch removes the only caller of usb_buffer_[un]map_sg(), so those
    functions are #if'ed out.  A later patch will remove them entirely.
    
    As a result of this change, urb->sg will be set in situations where
    it wasn't set previously.  Hence the xhci and whci drivers are
    adjusted to test urb->num_sgs instead, which retains its original
    meaning and is nonzero only when the HCD has to handle a scatterlist.
    
    Finally, even when a submission error occurs we don't want to hand
    URBs to usbmon before they are unmapped.  The submission path is
    rearranged so that map_urb_for_dma() is called only for non-root-hub
    URBs and unmap_urb_for_dma() is called immediately after a submission
    error.  This simplifies the error handling.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    CC: <stable@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index 2532a0917f8c..a760e46871c5 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -333,9 +333,12 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 		is_out = usb_endpoint_dir_out(&ep->desc);
 	}
 
-	/* Cache the direction for later use */
-	urb->transfer_flags = (urb->transfer_flags & ~URB_DIR_MASK) |
-			(is_out ? URB_DIR_OUT : URB_DIR_IN);
+	/* Clear the internal flags and cache the direction for later use */
+	urb->transfer_flags &= ~(URB_DIR_MASK | URB_DMA_MAP_SINGLE |
+			URB_DMA_MAP_PAGE | URB_DMA_MAP_SG | URB_MAP_LOCAL |
+			URB_SETUP_MAP_SINGLE | URB_SETUP_MAP_LOCAL |
+			URB_DMA_SG_COMBINED);
+	urb->transfer_flags |= (is_out ? URB_DIR_OUT : URB_DIR_IN);
 
 	if (xfertype != USB_ENDPOINT_XFER_CONTROL &&
 			dev->state < USB_STATE_CONFIGURED)

commit 0ede76fcec5415ef82a423a95120286895822e2d
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Mar 5 15:10:17 2010 -0500

    USB: remove uses of URB_NO_SETUP_DMA_MAP
    
    This patch (as1350) removes all usages of coherent buffers for USB
    control-request setup-packet buffers.  There's no good reason to
    reserve coherent memory for these things; control requests are hardly
    ever used in large quantity (the major exception is firmware
    transfers, and they aren't time-critical).  Furthermore, only seven
    drivers used it.  We might as well always use streaming DMA mappings
    for setup-packet buffers, and remove some extra complexity from
    usbcore.
    
    The DMA-mapping portion of hcd.c is currently in flux.  A separate
    patch will be submitted to remove support for URB_NO_SETUP_DMA_MAP
    after everything else settles down.  The removal should go smoothly,
    as by then nobody will be using it.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index 09301f4b7225..2532a0917f8c 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -396,8 +396,8 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 		return -EPIPE;		/* The most suitable error code :-) */
 
 	/* enforce simple/standard policy */
-	allowed = (URB_NO_TRANSFER_DMA_MAP | URB_NO_SETUP_DMA_MAP |
-			URB_NO_INTERRUPT | URB_DIR_MASK | URB_FREE_BUFFER);
+	allowed = (URB_NO_TRANSFER_DMA_MAP | URB_NO_INTERRUPT | URB_DIR_MASK |
+			URB_FREE_BUFFER);
 	switch (xfertype) {
 	case USB_ENDPOINT_XFER_BULK:
 		if (is_out)

commit 27729aadd31dafddaaf64c24f8ef6d0ff750f3aa
Author: Eric Lescouet <Eric.Lescouet@virtuallogix.com>
Date:   Sat Apr 24 23:21:52 2010 +0200

    USB: make hcd.h public (drivers dependency)
    
    The usbcore headers: hcd.h and hub.h are shared between usbcore,
    HCDs and a couple of other drivers (e.g. USBIP modules).
    So, it makes sense to move them into a more public location and
    to cleanup dependency of those modules on kernel internal headers.
    This patch moves hcd.h from drivers/usb/core into include/linux/usb/
    
    Signed-of-by: Eric Lescouet <eric@lescouet.org>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index 45a32dadb406..09301f4b7225 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -6,7 +6,7 @@
 #include <linux/log2.h>
 #include <linux/usb.h>
 #include <linux/wait.h>
-#include "hcd.h"
+#include <linux/usb/hcd.h>
 
 #define to_urb(d) container_of(d, struct urb, kref)
 

commit f09a15e6e69884cedec4d1c022089a973aa01f1e
Author: Matthew Wilcox <willy@linux.intel.com>
Date:   Tue Mar 16 12:55:44 2010 -0700

    USB: Fix usb_fill_int_urb for SuperSpeed devices
    
    USB 3 and Wireless USB specify a logarithmic encoding of the endpoint
    interval that matches the USB 2 specification.  usb_fill_int_urb() didn't
    know that and was filling in the interval as if it was USB 1.1.  Fix
    usb_fill_int_urb() for SuperSpeed devices, but leave the wireless case
    alone, because David Vrabel wants to keep the old encoding.
    
    Update the struct urb kernel doc to note that SuperSpeed URBs must have
    urb->interval specified in microframes.
    
    Add a missing break statement in the usb_submit_urb() interrupt URB
    checking, since wireless USB and SuperSpeed USB encode urb->interval
    differently.  This allows xHCI roothubs to actually register with khubd.
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index 27080561a1c2..45a32dadb406 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -453,6 +453,7 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 			if (urb->interval > (1 << 15))
 				return -EINVAL;
 			max = 1 << 15;
+			break;
 		case USB_SPEED_WIRELESS:
 			if (urb->interval > 16)
 				return -EINVAL;

commit 551cdbbeb118bd5ed301f8749aef69219284399b
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Jan 14 11:08:04 2010 -0800

    USB: rename USB_SPEED_VARIABLE to USB_SPEED_WIRELESS
    
    It's really the wireless speed, so rename the thing to make
    more sense.  Based on a recommendation from David Vrabel
    
    Cc: David Vrabel <david.vrabel@csr.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index e2bd153cbd89..27080561a1c2 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -437,7 +437,7 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 	case USB_ENDPOINT_XFER_INT:
 		/* too small? */
 		switch (dev->speed) {
-		case USB_SPEED_VARIABLE:
+		case USB_SPEED_WIRELESS:
 			if (urb->interval < 6)
 				return -EINVAL;
 			break;
@@ -453,7 +453,7 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 			if (urb->interval > (1 << 15))
 				return -EINVAL;
 			max = 1 << 15;
-		case USB_SPEED_VARIABLE:
+		case USB_SPEED_WIRELESS:
 			if (urb->interval > 16)
 				return -EINVAL;
 			break;
@@ -480,7 +480,7 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 		default:
 			return -EINVAL;
 		}
-		if (dev->speed != USB_SPEED_VARIABLE) {
+		if (dev->speed != USB_SPEED_WIRELESS) {
 			/* Round down to a power of 2, no more than max */
 			urb->interval = min(max, 1 << ilog2(urb->interval));
 		}

commit f661c6f8c67bd55e93348f160d590ff9edf08904
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Dec 11 16:20:20 2009 -0500

    USB: check the endpoint type against the pipe type
    
    This patch (as1316) adds some error checking to usb_submit_urb().
    It's conditional on CONFIG_USB_DEBUG, so it won't affect normal users.
    The new check makes sure that the actual type of the endpoint
    described by urb->pipe agrees with the type encoded in the pipe value.
    
    The USB error code documentation is updated to include the code
    returned by the new check, and the usbfs SUBMITURB handler is updated
    to use the correct pipe type when legacy user code tries to submit a
    bulk transfer to an interrupt endpoint.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index e7cae1334693..e2bd153cbd89 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -387,6 +387,13 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 	{
 	unsigned int	orig_flags = urb->transfer_flags;
 	unsigned int	allowed;
+	static int pipetypes[4] = {
+		PIPE_CONTROL, PIPE_ISOCHRONOUS, PIPE_BULK, PIPE_INTERRUPT
+	};
+
+	/* Check that the pipe's type matches the endpoint's type */
+	if (usb_pipetype(urb->pipe) != pipetypes[xfertype])
+		return -EPIPE;		/* The most suitable error code :-) */
 
 	/* enforce simple/standard policy */
 	allowed = (URB_NO_TRANSFER_DMA_MAP | URB_NO_SETUP_DMA_MAP |

commit 8e08b9766b50826e12139a821b6b3bdfcadcceda
Author: David Vrabel <david.vrabel@csr.com>
Date:   Tue Aug 18 16:11:24 2009 +0100

    USB: allow interrupt transfers to WUSB devices
    
    Check urb->interval on interrupt transfers and allow those with valid
    values (6 <= interval <= 16).
    
    Signed-off-by: David Vrabel <david.vrabel@csr.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index 0885d4abdc62..e7cae1334693 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -429,8 +429,16 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 	case USB_ENDPOINT_XFER_ISOC:
 	case USB_ENDPOINT_XFER_INT:
 		/* too small? */
-		if (urb->interval <= 0)
-			return -EINVAL;
+		switch (dev->speed) {
+		case USB_SPEED_VARIABLE:
+			if (urb->interval < 6)
+				return -EINVAL;
+			break;
+		default:
+			if (urb->interval <= 0)
+				return -EINVAL;
+			break;
+		}
 		/* too big? */
 		switch (dev->speed) {
 		case USB_SPEED_SUPER:	/* units are 125us */
@@ -438,6 +446,10 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 			if (urb->interval > (1 << 15))
 				return -EINVAL;
 			max = 1 << 15;
+		case USB_SPEED_VARIABLE:
+			if (urb->interval > 16)
+				return -EINVAL;
+			break;
 		case USB_SPEED_HIGH:	/* units are microframes */
 			/* NOTE usb handles 2^15 */
 			if (urb->interval > (1024 * 8))
@@ -461,8 +473,10 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 		default:
 			return -EINVAL;
 		}
-		/* Round down to a power of 2, no more than max */
-		urb->interval = min(max, 1 << ilog2(urb->interval));
+		if (dev->speed != USB_SPEED_VARIABLE) {
+			/* Round down to a power of 2, no more than max */
+			urb->interval = min(max, 1 << ilog2(urb->interval));
+		}
 	}
 
 	return usb_hcd_submit_urb(urb, mem_flags);

commit 79abb1ab13cee5ba488210798b6e7bbae0b391ac
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Mon Apr 27 19:58:26 2009 -0700

    USB: Support for bandwidth allocation.
    
    Originally, the USB core had no support for allocating bandwidth when a
    particular configuration or alternate setting for an interface was
    selected.  Instead, the device driver's URB submission would fail if
    there was not enough bandwidth for a periodic endpoint.  Drivers could
    work around this, by using the scatter-gather list API to guarantee
    bandwidth.
    
    This patch adds host controller API to allow the USB core to allocate or
    deallocate bandwidth for an endpoint.  Endpoints are added to or dropped
    from a copy of the current schedule by calling add_endpoint() or
    drop_endpoint(), and then the schedule is atomically evaluated with a
    call to check_bandwidth().  This allows all the endpoints for a new
    configuration or alternate setting to be added at the same time that the
    endpoints from the old configuration or alt setting are dropped.
    
    Endpoints must be added to the schedule before any URBs are submitted to
    them.  The HCD must be allowed to reject a new configuration or alt
    setting before the control transfer is sent to the device requesting the
    change.  It may reject the change because there is not enough bandwidth,
    not enough internal resources (such as memory on an embedded host
    controller), or perhaps even for security reasons in a virtualized
    environment.
    
    If the call to check_bandwidth() fails, the USB core must call
    reset_bandwidth().  This causes the schedule to be reverted back to the
    state it was in just after the last successful check_bandwidth() call.
    
    If the call succeeds, the host controller driver (and hardware) will have
    changed its internal state to match the new configuration or alternate
    setting.  The USB core can then issue a control transfer to the device to
    change the configuration or alt setting.  This allows the core to test new
    configurations or alternate settings before unbinding drivers bound to
    interfaces in the old configuration.
    
    WIP:
    
    The USB core must add endpoints from all interfaces in a configuration
    to the schedule, because a driver may claim that interface at any time.
    A slight optimization might be to add the endpoints to the schedule once
    a driver claims that interface.  FIXME
    
    This patch does not cover changing alternate settings, but it does
    handle a configuration change or de-configuration.  FIXME
    
    The code for managing the schedule is currently HCD specific.  A generic
    scheduling algorithm could be added for host controllers without
    built-in scheduling support.  For now, if a host controller does not
    define the check_bandwidth() function, the call to
    usb_hcd_check_bandwidth() will always succeed.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index 02eb0ef7a4c3..0885d4abdc62 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -241,6 +241,12 @@ EXPORT_SYMBOL_GPL(usb_unanchor_urb);
  * If the USB subsystem can't allocate sufficient bandwidth to perform
  * the periodic request, submitting such a periodic request should fail.
  *
+ * For devices under xHCI, the bandwidth is reserved at configuration time, or
+ * when the alt setting is selected.  If there is not enough bus bandwidth, the
+ * configuration/alt setting request will fail.  Therefore, submissions to
+ * periodic endpoints on devices under xHCI should never fail due to bandwidth
+ * constraints.
+ *
  * Device drivers must explicitly request that repetition, by ensuring that
  * some URB is always on the endpoint's queue (except possibly for short
  * periods during completion callacks).  When there is no longer an urb

commit 6b403b020c1f42180b14d28d832da61167cff822
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Mon Apr 27 19:54:10 2009 -0700

    USB: Add SuperSpeed to the list of USB device speeds.
    
    Modify the USB core to handle the new USB 3.0 speed, "SuperSpeed".  This
    is 5.0 Gbps (wire speed).  There are probably more places that check for
    speed that I've missed.
    
    SuperSpeed devices have a 512 byte endpoint 0 max packet size.  This shows
    up as a bMaxPacketSize0 set to 0x09 (see table 9-8 of the USB 3.0 bus
    spec).
    
    xHCI spec says that the xHC can handle intervals up to 2^15 microframes.  That
    might change when real silicon becomes available.
    
    Add FIXME note for SuperSpeed isochronous endpoints.  They can transmit up
    to 16 packets in one "burst" before they wait for an acknowledgment of the
    packets.  They can do up to 3 bursts per microframe (determined by the
    mult value in the endpoint companion descriptor).  The xHCI driver doesn't
    have support for isoc yet, so fix this later.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index 3376055f36e7..02eb0ef7a4c3 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -351,6 +351,7 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 	if (xfertype == USB_ENDPOINT_XFER_ISOC) {
 		int	n, len;
 
+		/* FIXME SuperSpeed isoc endpoints have up to 16 bursts */
 		/* "high bandwidth" mode, 1-3 packets/uframe? */
 		if (dev->speed == USB_SPEED_HIGH) {
 			int	mult = 1 + ((max >> 11) & 0x03);
@@ -426,6 +427,11 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 			return -EINVAL;
 		/* too big? */
 		switch (dev->speed) {
+		case USB_SPEED_SUPER:	/* units are 125us */
+			/* Handle up to 2^(16-1) microframes */
+			if (urb->interval > (1 << 15))
+				return -EINVAL;
+			max = 1 << 15;
 		case USB_SPEED_HIGH:	/* units are microframes */
 			/* NOTE usb handles 2^15 */
 			if (urb->interval > (1024 * 8))

commit 71d2718f2507dc17501d04e2bdca7b8e694ce365
Author: Roel Kluin <roel.kluin@gmail.com>
Date:   Fri Mar 13 12:19:18 2009 +0100

    USB: more u32 conversion after transfer_buffer_length and actual_length
    
    transfer_buffer_length and actual_length have become unsigned, therefore some
    additional conversion of local variables, function arguments and print
    specifications is desired.
    
    A test for a negative urb->transfer_buffer_length became obsolete; instead
    we ensure that it does not exceed INT_MAX. Also, urb->actual_length is always
    less than urb->transfer_buffer_length.
    
    rh_string() does no longer return -EPIPE in the case of an unsupported ID.
    Instead its only caller, rh_call_control() does the check.
    
    Signed-off-by: Roel Kluin <roel.kluin@gmail.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index 7025d801f23a..3376055f36e7 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -370,7 +370,7 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 	}
 
 	/* the I/O buffer must be mapped/unmapped, except when length=0 */
-	if (urb->transfer_buffer_length < 0)
+	if (urb->transfer_buffer_length > INT_MAX)
 		return -EMSGSIZE;
 
 #ifdef DEBUG

commit 6da9c99059bf24fb1faae6b9613bae64ea50c05e
Author: David Vrabel <david.vrabel@csr.com>
Date:   Wed Feb 18 14:43:47 2009 +0000

    USB: allow libusb to talk to unauthenticated WUSB devices
    
    To permit a userspace application to associate with WUSB devices
    using numeric association, control transfers to unauthenticated WUSB
    devices must be allowed.
    
    This requires that wusbcore correctly sets the device state to
    UNAUTHENTICATED, DEFAULT and ADDRESS and that control transfers can be
    performed to UNAUTHENTICATED devices.
    
    Signed-off-by: David Vrabel <david.vrabel@csr.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index 58bc5e3c2560..7025d801f23a 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -295,7 +295,7 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 	if (!urb || urb->hcpriv || !urb->complete)
 		return -EINVAL;
 	dev = urb->dev;
-	if ((!dev) || (dev->state < USB_STATE_DEFAULT))
+	if ((!dev) || (dev->state < USB_STATE_UNAUTHENTICATED))
 		return -ENODEV;
 
 	/* For now, get the endpoint from the pipe.  Eventually drivers

commit 856395d6e137b4e7194972cb7765f3de6a72ba61
Author: Oliver Neukum <oliver@neukum.org>
Date:   Thu Dec 18 09:17:49 2008 +0100

    USB: extension of anchor API to unpoison an anchor
    
    This extension allows unpoisoning an anchor allowing drivers that
    resubmit URBs to reuse an anchor for methods like resume()
    
    Signed-off-by: Oliver Neukum <oneukum@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index b5e9948698bf..58bc5e3c2560 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -678,6 +678,26 @@ void usb_poison_anchored_urbs(struct usb_anchor *anchor)
 }
 EXPORT_SYMBOL_GPL(usb_poison_anchored_urbs);
 
+/**
+ * usb_unpoison_anchored_urbs - let an anchor be used successfully again
+ * @anchor: anchor the requests are bound to
+ *
+ * Reverses the effect of usb_poison_anchored_urbs
+ * the anchor can be used normally after it returns
+ */
+void usb_unpoison_anchored_urbs(struct usb_anchor *anchor)
+{
+	unsigned long flags;
+	struct urb *lazarus;
+
+	spin_lock_irqsave(&anchor->lock, flags);
+	list_for_each_entry(lazarus, &anchor->urb_list, anchor_list) {
+		usb_unpoison_urb(lazarus);
+	}
+	anchor->poisoned = 0;
+	spin_unlock_irqrestore(&anchor->lock, flags);
+}
+EXPORT_SYMBOL_GPL(usb_unpoison_anchored_urbs);
 /**
  * usb_unlink_anchored_urbs - asynchronously cancel transfer requests en masse
  * @anchor: anchor the requests are bound to

commit 49367d8f1d9f26482cf7089489e90f0afd0a942c
Author: Ming Lei <tom.leiming@gmail.com>
Date:   Fri Dec 12 21:38:45 2008 +0800

    USB: mark "reject" field of struct urb as atomic_t
    
    It is enough to protect accesses to reject field of urb
    by marking it as atomic_t,also it is the only reason of
    existence of usb_reject_lock,so remove the lock to make
    code more clean.
    
    Signed-off-by: Ming Lei <tom.leiming@gmail.com>
    Acked-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index 1f68af9db3f7..b5e9948698bf 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -10,7 +10,6 @@
 
 #define to_urb(d) container_of(d, struct urb, kref)
 
-static DEFINE_SPINLOCK(usb_reject_lock);
 
 static void urb_destroy(struct kref *kref)
 {
@@ -131,9 +130,7 @@ void usb_anchor_urb(struct urb *urb, struct usb_anchor *anchor)
 	urb->anchor = anchor;
 
 	if (unlikely(anchor->poisoned)) {
-		spin_lock(&usb_reject_lock);
-		urb->reject++;
-		spin_unlock(&usb_reject_lock);
+		atomic_inc(&urb->reject);
 	}
 
 	spin_unlock_irqrestore(&anchor->lock, flags);
@@ -565,16 +562,12 @@ void usb_kill_urb(struct urb *urb)
 	might_sleep();
 	if (!(urb && urb->dev && urb->ep))
 		return;
-	spin_lock_irq(&usb_reject_lock);
-	++urb->reject;
-	spin_unlock_irq(&usb_reject_lock);
+	atomic_inc(&urb->reject);
 
 	usb_hcd_unlink_urb(urb, -ENOENT);
 	wait_event(usb_kill_urb_queue, atomic_read(&urb->use_count) == 0);
 
-	spin_lock_irq(&usb_reject_lock);
-	--urb->reject;
-	spin_unlock_irq(&usb_reject_lock);
+	atomic_dec(&urb->reject);
 }
 EXPORT_SYMBOL_GPL(usb_kill_urb);
 
@@ -606,9 +599,7 @@ void usb_poison_urb(struct urb *urb)
 	might_sleep();
 	if (!(urb && urb->dev && urb->ep))
 		return;
-	spin_lock_irq(&usb_reject_lock);
-	++urb->reject;
-	spin_unlock_irq(&usb_reject_lock);
+	atomic_inc(&urb->reject);
 
 	usb_hcd_unlink_urb(urb, -ENOENT);
 	wait_event(usb_kill_urb_queue, atomic_read(&urb->use_count) == 0);
@@ -617,14 +608,10 @@ EXPORT_SYMBOL_GPL(usb_poison_urb);
 
 void usb_unpoison_urb(struct urb *urb)
 {
-	unsigned long flags;
-
 	if (!urb)
 		return;
 
-	spin_lock_irqsave(&usb_reject_lock, flags);
-	--urb->reject;
-	spin_unlock_irqrestore(&usb_reject_lock, flags);
+	atomic_dec(&urb->reject);
 }
 EXPORT_SYMBOL_GPL(usb_unpoison_urb);
 

commit 2870fde780bbdf6442e9efe7ca5fc11bcdd2a09a
Author: Rabin Vincent <rabin@rab.in>
Date:   Sun Nov 9 11:40:30 2008 +0530

    USB: mention URB_FREE_BUFFER in usb_free_urb documentation
    
    The usb_free_urb comment says that the transfer buffer will not be
    freed, but this is not the case when URB_FREE_BUFFER is set.
    
    Signed-off-by: Rabin Vincent <rabin@rab.in>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index 4342bd9c3bb6..1f68af9db3f7 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -85,8 +85,8 @@ EXPORT_SYMBOL_GPL(usb_alloc_urb);
  * Must be called when a user of a urb is finished with it.  When the last user
  * of the urb calls this function, the memory of the urb is freed.
  *
- * Note: The transfer buffer associated with the urb is not freed, that must be
- * done elsewhere.
+ * Note: The transfer buffer associated with the urb is not freed unless the
+ * URB_FREE_BUFFER transfer flag is set.
  */
 void usb_free_urb(struct urb *urb)
 {

commit cde217a556ec552d28ac9e136c5a94684a69ae94
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Oct 21 15:28:46 2008 -0400

    USB: fix crash when URBs are unlinked after the device is gone
    
    This patch (as1151) protects usbcore against drivers that try to
    unlink an URB after the URB's device or bus have been removed.  The
    core does not currently check for this, and certain drivers can cause
    a crash if they are running while an HCD is unloaded.
    
    Certainly it would be best to fix the guilty drivers.  But a little
    defensive programming doesn't hurt, especially since it appears that
    quite a few drivers need to be fixed.
    
    The patch prevents the problem by grabbing a reference to the device
    while an unlink is in progress and using a new spinlock to synchronize
    unlinks with device removal.  (There's no need to acquire a reference
    to the bus as well, since the device structure itself keeps a
    reference to the bus.)  In addition, the kerneldoc is updated to
    indicate that URBs should not be unlinked after the disconnect method
    returns.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Cc: stable <stable@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index f2638009a464..4342bd9c3bb6 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -474,6 +474,12 @@ EXPORT_SYMBOL_GPL(usb_submit_urb);
  * indicating that the request has been canceled (rather than any other
  * code).
  *
+ * Drivers should not call this routine or related routines, such as
+ * usb_kill_urb() or usb_unlink_anchored_urbs(), after their disconnect
+ * method has returned.  The disconnect function should synchronize with
+ * a driver's I/O routines to insure that all URB-related activity has
+ * completed before it returns.
+ *
  * This request is always asynchronous.  Success is indicated by
  * returning -EINPROGRESS, at which time the URB will probably not yet
  * have been given back to the device driver.  When it is eventually
@@ -550,6 +556,9 @@ EXPORT_SYMBOL_GPL(usb_unlink_urb);
  * This routine may not be used in an interrupt context (such as a bottom
  * half or a completion handler), or when holding a spinlock, or in other
  * situations where the caller can't schedule().
+ *
+ * This routine should not be called by a driver after its disconnect
+ * method has returned.
  */
 void usb_kill_urb(struct urb *urb)
 {
@@ -588,6 +597,9 @@ EXPORT_SYMBOL_GPL(usb_kill_urb);
  * This routine may not be used in an interrupt context (such as a bottom
  * half or a completion handler), or when holding a spinlock, or in other
  * situations where the caller can't schedule().
+ *
+ * This routine should not be called by a driver after its disconnect
+ * method has returned.
  */
 void usb_poison_urb(struct urb *urb)
 {
@@ -622,6 +634,9 @@ EXPORT_SYMBOL_GPL(usb_unpoison_urb);
  *
  * this allows all outstanding URBs to be killed starting
  * from the back of the queue
+ *
+ * This routine should not be called by a driver after its disconnect
+ * method has returned.
  */
 void usb_kill_anchored_urbs(struct usb_anchor *anchor)
 {
@@ -651,6 +666,9 @@ EXPORT_SYMBOL_GPL(usb_kill_anchored_urbs);
  * this allows all outstanding URBs to be poisoned starting
  * from the back of the queue. Newly added URBs will also be
  * poisoned
+ *
+ * This routine should not be called by a driver after its disconnect
+ * method has returned.
  */
 void usb_poison_anchored_urbs(struct usb_anchor *anchor)
 {
@@ -672,6 +690,7 @@ void usb_poison_anchored_urbs(struct usb_anchor *anchor)
 	spin_unlock_irq(&anchor->lock);
 }
 EXPORT_SYMBOL_GPL(usb_poison_anchored_urbs);
+
 /**
  * usb_unlink_anchored_urbs - asynchronously cancel transfer requests en masse
  * @anchor: anchor the requests are bound to
@@ -680,6 +699,9 @@ EXPORT_SYMBOL_GPL(usb_poison_anchored_urbs);
  * from the back of the queue. This function is asynchronous.
  * The unlinking is just tiggered. It may happen after this
  * function has returned.
+ *
+ * This routine should not be called by a driver after its disconnect
+ * method has returned.
  */
 void usb_unlink_anchored_urbs(struct usb_anchor *anchor)
 {

commit 69a85942ff2df8e1ee0a3b6afe8b1d85dce58333
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Aug 14 09:37:34 2008 -0700

    USB: remove err() macro from usb core code
    
    USB should not be having it's own printk macros, so remove err() and
    use the system-wide standard of dev_err() wherever possible.  In the
    few places that will not work out, use a basic printk().
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index 175d528f4029..f2638009a464 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -70,7 +70,7 @@ struct urb *usb_alloc_urb(int iso_packets, gfp_t mem_flags)
 		iso_packets * sizeof(struct usb_iso_packet_descriptor),
 		mem_flags);
 	if (!urb) {
-		err("alloc_urb: kmalloc failed");
+		printk(KERN_ERR "alloc_urb: kmalloc failed\n");
 		return NULL;
 	}
 	usb_init_urb(urb);
@@ -407,7 +407,7 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 
 	/* fail if submitter gave bogus flags */
 	if (urb->transfer_flags != orig_flags) {
-		err("BOGUS urb flags, %x --> %x",
+		dev_err(&dev->dev, "BOGUS urb flags, %x --> %x\n",
 			orig_flags, urb->transfer_flags);
 		return -EINVAL;
 	}

commit 1987625226a918cd20c334ffce5e2a224cba0718
Author: Oliver Neukum <oliver@neukum.org>
Date:   Mon Aug 25 22:40:25 2008 +0200

    USB: anchor API changes needed for btusb
    
    This extends the anchor API as btusb needs for autosuspend.
    
    
    Signed-off-by: Oliver Neukum <oneukum@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index eebc070c3cc7..175d528f4029 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -716,3 +716,73 @@ int usb_wait_anchor_empty_timeout(struct usb_anchor *anchor,
 				  msecs_to_jiffies(timeout));
 }
 EXPORT_SYMBOL_GPL(usb_wait_anchor_empty_timeout);
+
+/**
+ * usb_get_from_anchor - get an anchor's oldest urb
+ * @anchor: the anchor whose urb you want
+ *
+ * this will take the oldest urb from an anchor,
+ * unanchor and return it
+ */
+struct urb *usb_get_from_anchor(struct usb_anchor *anchor)
+{
+	struct urb *victim;
+	unsigned long flags;
+
+	spin_lock_irqsave(&anchor->lock, flags);
+	if (!list_empty(&anchor->urb_list)) {
+		victim = list_entry(anchor->urb_list.next, struct urb,
+				    anchor_list);
+		usb_get_urb(victim);
+		spin_unlock_irqrestore(&anchor->lock, flags);
+		usb_unanchor_urb(victim);
+	} else {
+		spin_unlock_irqrestore(&anchor->lock, flags);
+		victim = NULL;
+	}
+
+	return victim;
+}
+
+EXPORT_SYMBOL_GPL(usb_get_from_anchor);
+
+/**
+ * usb_scuttle_anchored_urbs - unanchor all an anchor's urbs
+ * @anchor: the anchor whose urbs you want to unanchor
+ *
+ * use this to get rid of all an anchor's urbs
+ */
+void usb_scuttle_anchored_urbs(struct usb_anchor *anchor)
+{
+	struct urb *victim;
+	unsigned long flags;
+
+	spin_lock_irqsave(&anchor->lock, flags);
+	while (!list_empty(&anchor->urb_list)) {
+		victim = list_entry(anchor->urb_list.prev, struct urb,
+				    anchor_list);
+		usb_get_urb(victim);
+		spin_unlock_irqrestore(&anchor->lock, flags);
+		/* this may free the URB */
+		usb_unanchor_urb(victim);
+		usb_put_urb(victim);
+		spin_lock_irqsave(&anchor->lock, flags);
+	}
+	spin_unlock_irqrestore(&anchor->lock, flags);
+}
+
+EXPORT_SYMBOL_GPL(usb_scuttle_anchored_urbs);
+
+/**
+ * usb_anchor_empty - is an anchor empty
+ * @anchor: the anchor you want to query
+ *
+ * returns 1 if the anchor has no urbs associated with it
+ */
+int usb_anchor_empty(struct usb_anchor *anchor)
+{
+	return list_empty(&anchor->urb_list);
+}
+
+EXPORT_SYMBOL_GPL(usb_anchor_empty);
+

commit 6a2839bedc1502b3f0366cc3ad1099a1d92cf8fb
Author: Oliver Neukum <oliver@neukum.org>
Date:   Tue Jul 29 16:18:47 2008 +0200

    USB: extend poisoning to anchors
    
    this extends the poisoning concept to anchors. This way poisoning
    will work with fire and forget drivers.
    
    Signed-off-by: Oliver Neukum <oneukum@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index a7945ab208c2..eebc070c3cc7 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -10,6 +10,8 @@
 
 #define to_urb(d) container_of(d, struct urb, kref)
 
+static DEFINE_SPINLOCK(usb_reject_lock);
+
 static void urb_destroy(struct kref *kref)
 {
 	struct urb *urb = to_urb(kref);
@@ -127,6 +129,13 @@ void usb_anchor_urb(struct urb *urb, struct usb_anchor *anchor)
 	usb_get_urb(urb);
 	list_add_tail(&urb->anchor_list, &anchor->urb_list);
 	urb->anchor = anchor;
+
+	if (unlikely(anchor->poisoned)) {
+		spin_lock(&usb_reject_lock);
+		urb->reject++;
+		spin_unlock(&usb_reject_lock);
+	}
+
 	spin_unlock_irqrestore(&anchor->lock, flags);
 }
 EXPORT_SYMBOL_GPL(usb_anchor_urb);
@@ -522,7 +531,6 @@ int usb_unlink_urb(struct urb *urb)
 }
 EXPORT_SYMBOL_GPL(usb_unlink_urb);
 
-static DEFINE_MUTEX(usb_reject_mutex);
 /**
  * usb_kill_urb - cancel a transfer request and wait for it to finish
  * @urb: pointer to URB describing a previously submitted request,
@@ -548,16 +556,16 @@ void usb_kill_urb(struct urb *urb)
 	might_sleep();
 	if (!(urb && urb->dev && urb->ep))
 		return;
-	mutex_lock(&usb_reject_mutex);
+	spin_lock_irq(&usb_reject_lock);
 	++urb->reject;
-	mutex_unlock(&usb_reject_mutex);
+	spin_unlock_irq(&usb_reject_lock);
 
 	usb_hcd_unlink_urb(urb, -ENOENT);
 	wait_event(usb_kill_urb_queue, atomic_read(&urb->use_count) == 0);
 
-	mutex_lock(&usb_reject_mutex);
+	spin_lock_irq(&usb_reject_lock);
 	--urb->reject;
-	mutex_unlock(&usb_reject_mutex);
+	spin_unlock_irq(&usb_reject_lock);
 }
 EXPORT_SYMBOL_GPL(usb_kill_urb);
 
@@ -586,9 +594,9 @@ void usb_poison_urb(struct urb *urb)
 	might_sleep();
 	if (!(urb && urb->dev && urb->ep))
 		return;
-	mutex_lock(&usb_reject_mutex);
+	spin_lock_irq(&usb_reject_lock);
 	++urb->reject;
-	mutex_unlock(&usb_reject_mutex);
+	spin_unlock_irq(&usb_reject_lock);
 
 	usb_hcd_unlink_urb(urb, -ENOENT);
 	wait_event(usb_kill_urb_queue, atomic_read(&urb->use_count) == 0);
@@ -597,12 +605,14 @@ EXPORT_SYMBOL_GPL(usb_poison_urb);
 
 void usb_unpoison_urb(struct urb *urb)
 {
+	unsigned long flags;
+
 	if (!urb)
 		return;
 
-	mutex_lock(&usb_reject_mutex);
+	spin_lock_irqsave(&usb_reject_lock, flags);
 	--urb->reject;
-	mutex_unlock(&usb_reject_mutex);
+	spin_unlock_irqrestore(&usb_reject_lock, flags);
 }
 EXPORT_SYMBOL_GPL(usb_unpoison_urb);
 
@@ -633,6 +643,35 @@ void usb_kill_anchored_urbs(struct usb_anchor *anchor)
 }
 EXPORT_SYMBOL_GPL(usb_kill_anchored_urbs);
 
+
+/**
+ * usb_poison_anchored_urbs - cease all traffic from an anchor
+ * @anchor: anchor the requests are bound to
+ *
+ * this allows all outstanding URBs to be poisoned starting
+ * from the back of the queue. Newly added URBs will also be
+ * poisoned
+ */
+void usb_poison_anchored_urbs(struct usb_anchor *anchor)
+{
+	struct urb *victim;
+
+	spin_lock_irq(&anchor->lock);
+	anchor->poisoned = 1;
+	while (!list_empty(&anchor->urb_list)) {
+		victim = list_entry(anchor->urb_list.prev, struct urb,
+				    anchor_list);
+		/* we must make sure the URB isn't freed before we kill it*/
+		usb_get_urb(victim);
+		spin_unlock_irq(&anchor->lock);
+		/* this will unanchor the URB */
+		usb_poison_urb(victim);
+		usb_put_urb(victim);
+		spin_lock_irq(&anchor->lock);
+	}
+	spin_unlock_irq(&anchor->lock);
+}
+EXPORT_SYMBOL_GPL(usb_poison_anchored_urbs);
 /**
  * usb_unlink_anchored_urbs - asynchronously cancel transfer requests en masse
  * @anchor: anchor the requests are bound to

commit 55b447bf79ad25591437d24b78caa9d0ae4fec82
Author: Oliver Neukum <oliver@neukum.org>
Date:   Tue Jul 29 15:26:15 2008 +0200

    USB: kill URBs permanently
    
    looking at usb_kill_urb() it seems to me that it is unnecessarily lenient.
    In the use case of disconnect() you never want to use the URB again
    (for the same device) But leaving urb->reject elevated will make it easier
    to avoid races between read/write and disconnect.
    
    Signed-off-by: Oliver Neukum <oneukum@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index 47111e88f791..a7945ab208c2 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -522,6 +522,7 @@ int usb_unlink_urb(struct urb *urb)
 }
 EXPORT_SYMBOL_GPL(usb_unlink_urb);
 
+static DEFINE_MUTEX(usb_reject_mutex);
 /**
  * usb_kill_urb - cancel a transfer request and wait for it to finish
  * @urb: pointer to URB describing a previously submitted request,
@@ -544,24 +545,67 @@ EXPORT_SYMBOL_GPL(usb_unlink_urb);
  */
 void usb_kill_urb(struct urb *urb)
 {
-	static DEFINE_MUTEX(reject_mutex);
-
 	might_sleep();
 	if (!(urb && urb->dev && urb->ep))
 		return;
-	mutex_lock(&reject_mutex);
+	mutex_lock(&usb_reject_mutex);
 	++urb->reject;
-	mutex_unlock(&reject_mutex);
+	mutex_unlock(&usb_reject_mutex);
 
 	usb_hcd_unlink_urb(urb, -ENOENT);
 	wait_event(usb_kill_urb_queue, atomic_read(&urb->use_count) == 0);
 
-	mutex_lock(&reject_mutex);
+	mutex_lock(&usb_reject_mutex);
 	--urb->reject;
-	mutex_unlock(&reject_mutex);
+	mutex_unlock(&usb_reject_mutex);
 }
 EXPORT_SYMBOL_GPL(usb_kill_urb);
 
+/**
+ * usb_poison_urb - reliably kill a transfer and prevent further use of an URB
+ * @urb: pointer to URB describing a previously submitted request,
+ *	may be NULL
+ *
+ * This routine cancels an in-progress request.  It is guaranteed that
+ * upon return all completion handlers will have finished and the URB
+ * will be totally idle and cannot be reused.  These features make
+ * this an ideal way to stop I/O in a disconnect() callback.
+ * If the request has not already finished or been unlinked
+ * the completion handler will see urb->status == -ENOENT.
+ *
+ * After and while the routine runs, attempts to resubmit the URB will fail
+ * with error -EPERM.  Thus even if the URB's completion handler always
+ * tries to resubmit, it will not succeed and the URB will become idle.
+ *
+ * This routine may not be used in an interrupt context (such as a bottom
+ * half or a completion handler), or when holding a spinlock, or in other
+ * situations where the caller can't schedule().
+ */
+void usb_poison_urb(struct urb *urb)
+{
+	might_sleep();
+	if (!(urb && urb->dev && urb->ep))
+		return;
+	mutex_lock(&usb_reject_mutex);
+	++urb->reject;
+	mutex_unlock(&usb_reject_mutex);
+
+	usb_hcd_unlink_urb(urb, -ENOENT);
+	wait_event(usb_kill_urb_queue, atomic_read(&urb->use_count) == 0);
+}
+EXPORT_SYMBOL_GPL(usb_poison_urb);
+
+void usb_unpoison_urb(struct urb *urb)
+{
+	if (!urb)
+		return;
+
+	mutex_lock(&usb_reject_mutex);
+	--urb->reject;
+	mutex_unlock(&usb_reject_mutex);
+}
+EXPORT_SYMBOL_GPL(usb_unpoison_urb);
+
 /**
  * usb_kill_anchored_urbs - cancel transfer requests en masse
  * @anchor: anchor the requests are bound to

commit 77571f05a483c0259e42ba2f482c82debc9a63af
Author: Oliver Neukum <oliver@neukum.org>
Date:   Mon Aug 18 16:36:52 2008 +0200

    USB: fix bug in usb_unlink_anchored_urbs()
    
    Irqs must not accidentally be reenabled.
    
    Signed-off-by: Oliver Neukum <oneukum@suse.de>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index c0b1ae25ae2a..47111e88f791 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -601,15 +601,20 @@ EXPORT_SYMBOL_GPL(usb_kill_anchored_urbs);
 void usb_unlink_anchored_urbs(struct usb_anchor *anchor)
 {
 	struct urb *victim;
+	unsigned long flags;
 
-	spin_lock_irq(&anchor->lock);
+	spin_lock_irqsave(&anchor->lock, flags);
 	while (!list_empty(&anchor->urb_list)) {
 		victim = list_entry(anchor->urb_list.prev, struct urb,
 				    anchor_list);
+		usb_get_urb(victim);
+		spin_unlock_irqrestore(&anchor->lock, flags);
 		/* this will unanchor the URB */
 		usb_unlink_urb(victim);
+		usb_put_urb(victim);
+		spin_lock_irqsave(&anchor->lock, flags);
 	}
-	spin_unlock_irq(&anchor->lock);
+	spin_unlock_irqrestore(&anchor->lock, flags);
 }
 EXPORT_SYMBOL_GPL(usb_unlink_anchored_urbs);
 

commit 441b62c1edb986827154768d89bbac0ba779984f
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Mon Mar 3 16:08:34 2008 -0800

    USB: replace remaining __FUNCTION__ occurrences
    
    __FUNCTION__ is gcc-specific, use __func__
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index 1d3ed1322fbe..c0b1ae25ae2a 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -334,7 +334,7 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 		dev_dbg(&dev->dev,
 			"bogus endpoint ep%d%s in %s (bad maxpacket %d)\n",
 			usb_endpoint_num(&ep->desc), is_out ? "out" : "in",
-			__FUNCTION__, max);
+			__func__, max);
 		return -EMSGSIZE;
 	}
 

commit eda769593bbae8aee4e336b0732f6016353301a3
Author: Oliver Neukum <oliver@neukum.org>
Date:   Thu Apr 10 14:07:37 2008 +0200

    USB: add extension of anchor API, usb_unlink_anchored_urbs
    
    This adds the ability to trigger asynchronous unlinks of anchored URBs. This
    is needed for error handling in the comntext of completion handlers, which
    cannot sleep.
    
    Signed-off-by: Oliver Neukum <oneukum@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index 9d7e63292c01..1d3ed1322fbe 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -589,6 +589,30 @@ void usb_kill_anchored_urbs(struct usb_anchor *anchor)
 }
 EXPORT_SYMBOL_GPL(usb_kill_anchored_urbs);
 
+/**
+ * usb_unlink_anchored_urbs - asynchronously cancel transfer requests en masse
+ * @anchor: anchor the requests are bound to
+ *
+ * this allows all outstanding URBs to be unlinked starting
+ * from the back of the queue. This function is asynchronous.
+ * The unlinking is just tiggered. It may happen after this
+ * function has returned.
+ */
+void usb_unlink_anchored_urbs(struct usb_anchor *anchor)
+{
+	struct urb *victim;
+
+	spin_lock_irq(&anchor->lock);
+	while (!list_empty(&anchor->urb_list)) {
+		victim = list_entry(anchor->urb_list.prev, struct urb,
+				    anchor_list);
+		/* this will unanchor the URB */
+		usb_unlink_urb(victim);
+	}
+	spin_unlock_irq(&anchor->lock);
+}
+EXPORT_SYMBOL_GPL(usb_unlink_anchored_urbs);
+
 /**
  * usb_wait_anchor_empty_timeout - wait for an anchor to be unused
  * @anchor: the anchor you want to become unused

commit 2c044a4803804708984931bcbd03314732e995d5
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed Jan 30 15:21:33 2008 -0800

    USB: fix codingstyle issues in drivers/usb/core/*.c
    
    Fixes a number of coding style issues in the remaining .c files in
    drivers/usb/core/
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index 0b54dc174e2c..9d7e63292c01 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -103,7 +103,7 @@ EXPORT_SYMBOL_GPL(usb_free_urb);
  *
  * A pointer to the urb with the incremented reference counter is returned.
  */
-struct urb * usb_get_urb(struct urb *urb)
+struct urb *usb_get_urb(struct urb *urb)
 {
 	if (urb)
 		kref_get(&urb->kref);
@@ -176,7 +176,7 @@ EXPORT_SYMBOL_GPL(usb_unanchor_urb);
  * describing that request to the USB subsystem.  Request completion will
  * be indicated later, asynchronously, by calling the completion handler.
  * The three types of completion are success, error, and unlink
- * (a software-induced fault, also called "request cancellation").  
+ * (a software-induced fault, also called "request cancellation").
  *
  * URBs may be submitted in interrupt context.
  *
@@ -259,7 +259,7 @@ EXPORT_SYMBOL_GPL(usb_unanchor_urb);
  *       semaphores), or
  *   (c) current->state != TASK_RUNNING, this is the case only after
  *       you've changed it.
- * 
+ *
  * GFP_NOIO is used in the block io path and error handling of storage
  * devices.
  *
@@ -288,7 +288,8 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 
 	if (!urb || urb->hcpriv || !urb->complete)
 		return -EINVAL;
-	if (!(dev = urb->dev) || dev->state < USB_STATE_DEFAULT)
+	dev = urb->dev;
+	if ((!dev) || (dev->state < USB_STATE_DEFAULT))
 		return -ENODEV;
 
 	/* For now, get the endpoint from the pipe.  Eventually drivers
@@ -351,11 +352,11 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 			max *= mult;
 		}
 
-		if (urb->number_of_packets <= 0)		    
+		if (urb->number_of_packets <= 0)
 			return -EINVAL;
 		for (n = 0; n < urb->number_of_packets; n++) {
 			len = urb->iso_frame_desc[n].length;
-			if (len < 0 || len > max) 
+			if (len < 0 || len > max)
 				return -EMSGSIZE;
 			urb->iso_frame_desc[n].status = -EXDEV;
 			urb->iso_frame_desc[n].actual_length = 0;
@@ -420,7 +421,7 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 		/* too big? */
 		switch (dev->speed) {
 		case USB_SPEED_HIGH:	/* units are microframes */
-			// NOTE usb handles 2^15
+			/* NOTE usb handles 2^15 */
 			if (urb->interval > (1024 * 8))
 				urb->interval = 1024 * 8;
 			max = 1024 * 8;
@@ -430,12 +431,12 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 			if (xfertype == USB_ENDPOINT_XFER_INT) {
 				if (urb->interval > 255)
 					return -EINVAL;
-				// NOTE ohci only handles up to 32
+				/* NOTE ohci only handles up to 32 */
 				max = 128;
 			} else {
 				if (urb->interval > 1024)
 					urb->interval = 1024;
-				// NOTE usb and ohci handle up to 2^15
+				/* NOTE usb and ohci handle up to 2^15 */
 				max = 1024;
 			}
 			break;
@@ -574,7 +575,8 @@ void usb_kill_anchored_urbs(struct usb_anchor *anchor)
 
 	spin_lock_irq(&anchor->lock);
 	while (!list_empty(&anchor->urb_list)) {
-		victim = list_entry(anchor->urb_list.prev, struct urb, anchor_list);
+		victim = list_entry(anchor->urb_list.prev, struct urb,
+				    anchor_list);
 		/* we must make sure the URB isn't freed before we kill it*/
 		usb_get_urb(victim);
 		spin_unlock_irq(&anchor->lock);

commit 782e70c6fc2290a0395850e8e02583b8b62264d8
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Jan 25 11:12:21 2008 -0600

    USB: mark USB drivers as being GPL only
    
    Over two years ago, the Linux USB developers stated that they believed
    there was no way to create a USB kernel driver that was not under the
    GPL.  This patch moves the USB apis to enforce that decision.
    
    There are no known closed source USB drivers in the wild, so this patch
    should cause no problems.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index d05ead20081c..0b54dc174e2c 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -42,6 +42,7 @@ void usb_init_urb(struct urb *urb)
 		INIT_LIST_HEAD(&urb->anchor_list);
 	}
 }
+EXPORT_SYMBOL_GPL(usb_init_urb);
 
 /**
  * usb_alloc_urb - creates a new urb for a USB driver to use
@@ -73,6 +74,7 @@ struct urb *usb_alloc_urb(int iso_packets, gfp_t mem_flags)
 	usb_init_urb(urb);
 	return urb;
 }
+EXPORT_SYMBOL_GPL(usb_alloc_urb);
 
 /**
  * usb_free_urb - frees the memory used by a urb when all users of it are finished
@@ -89,6 +91,7 @@ void usb_free_urb(struct urb *urb)
 	if (urb)
 		kref_put(&urb->kref, urb_destroy);
 }
+EXPORT_SYMBOL_GPL(usb_free_urb);
 
 /**
  * usb_get_urb - increments the reference count of the urb
@@ -106,6 +109,7 @@ struct urb * usb_get_urb(struct urb *urb)
 		kref_get(&urb->kref);
 	return urb;
 }
+EXPORT_SYMBOL_GPL(usb_get_urb);
 
 /**
  * usb_anchor_urb - anchors an URB while it is processed
@@ -444,6 +448,7 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 
 	return usb_hcd_submit_urb(urb, mem_flags);
 }
+EXPORT_SYMBOL_GPL(usb_submit_urb);
 
 /*-------------------------------------------------------------------*/
 
@@ -514,6 +519,7 @@ int usb_unlink_urb(struct urb *urb)
 		return -EIDRM;
 	return usb_hcd_unlink_urb(urb, -ECONNRESET);
 }
+EXPORT_SYMBOL_GPL(usb_unlink_urb);
 
 /**
  * usb_kill_urb - cancel a transfer request and wait for it to finish
@@ -553,6 +559,7 @@ void usb_kill_urb(struct urb *urb)
 	--urb->reject;
 	mutex_unlock(&reject_mutex);
 }
+EXPORT_SYMBOL_GPL(usb_kill_urb);
 
 /**
  * usb_kill_anchored_urbs - cancel transfer requests en masse
@@ -595,11 +602,3 @@ int usb_wait_anchor_empty_timeout(struct usb_anchor *anchor,
 				  msecs_to_jiffies(timeout));
 }
 EXPORT_SYMBOL_GPL(usb_wait_anchor_empty_timeout);
-
-EXPORT_SYMBOL(usb_init_urb);
-EXPORT_SYMBOL(usb_alloc_urb);
-EXPORT_SYMBOL(usb_free_urb);
-EXPORT_SYMBOL(usb_get_urb);
-EXPORT_SYMBOL(usb_submit_urb);
-EXPORT_SYMBOL(usb_unlink_urb);
-EXPORT_SYMBOL(usb_kill_urb);

commit 0b28baaf74ca04be2e0cc4d4dd2bbc801697f744
Author: Oliver Neukum <oliver@neukum.org>
Date:   Wed Oct 17 14:37:54 2007 +0200

    USB: add URB_FREE_BUFFER to permissible flags
    
    URB_FREE_BUFFER needs to be allowed in the sanity checks to use drivers that
    use that flag.
    
    
    Signed-off-by: Oliver Neukum <oneukum@suse.de>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Cc: stable <stable@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index c20c03aaf012..d05ead20081c 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -372,7 +372,7 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 
 	/* enforce simple/standard policy */
 	allowed = (URB_NO_TRANSFER_DMA_MAP | URB_NO_SETUP_DMA_MAP |
-			URB_NO_INTERRUPT | URB_DIR_MASK);
+			URB_NO_INTERRUPT | URB_DIR_MASK | URB_FREE_BUFFER);
 	switch (xfertype) {
 	case USB_ENDPOINT_XFER_BULK:
 		if (is_out)

commit 6840d2555afd66290be7a39b400b5e66a840b82d
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Sep 10 11:34:26 2007 -0400

    USB: flush outstanding URBs when suspending
    
    This patch (as989) makes usbcore flush all outstanding URBs for each
    device as the device is suspended.  This will be true even when
    CONFIG_USB_SUSPEND is not enabled.
    
    In addition, an extra can_submit flag is added to the usb_device
    structure.  That flag will be turned off whenever a suspend request
    has been received for the device, even if the device isn't actually
    suspended because CONFIG_USB_SUSPEND isn't set.
    
    It's no longer necessary to check for the device state being equal to
    USB_STATE_SUSPENDED during URB submission; that check can be replaced
    by a check of the can_submit flag.  This also permits us to remove
    some questionable references to the deprecated power.power_state field.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index 76db76fdb4ec..c20c03aaf012 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -286,9 +286,6 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 		return -EINVAL;
 	if (!(dev = urb->dev) || dev->state < USB_STATE_DEFAULT)
 		return -ENODEV;
-	if (dev->bus->controller->power.power_state.event != PM_EVENT_ON
-			|| dev->state == USB_STATE_SUSPENDED)
-		return -EHOSTUNREACH;
 
 	/* For now, get the endpoint from the pipe.  Eventually drivers
 	 * will be required to set urb->ep directly and we will eliminate

commit 1431d2a44ccf68a547094976f363f94177ab00c6
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Aug 24 15:42:39 2007 -0400

    USB: get rid of urb->lock
    
    Now that urb->status isn't used, urb->lock doesn't protect anything.
    This patch (as980) removes it and replaces it with a private mutex in
    the one remaining place it was still used: usb_kill_urb.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index 19f5f66c2733..76db76fdb4ec 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -39,7 +39,6 @@ void usb_init_urb(struct urb *urb)
 	if (urb) {
 		memset(urb, 0, sizeof(*urb));
 		kref_init(&urb->kref);
-		spin_lock_init(&urb->lock);
 		INIT_LIST_HEAD(&urb->anchor_list);
 	}
 }
@@ -541,19 +540,21 @@ int usb_unlink_urb(struct urb *urb)
  */
 void usb_kill_urb(struct urb *urb)
 {
+	static DEFINE_MUTEX(reject_mutex);
+
 	might_sleep();
 	if (!(urb && urb->dev && urb->ep))
 		return;
-	spin_lock_irq(&urb->lock);
+	mutex_lock(&reject_mutex);
 	++urb->reject;
-	spin_unlock_irq(&urb->lock);
+	mutex_unlock(&reject_mutex);
 
 	usb_hcd_unlink_urb(urb, -ENOENT);
 	wait_event(usb_kill_urb_queue, atomic_read(&urb->use_count) == 0);
 
-	spin_lock_irq(&urb->lock);
+	mutex_lock(&reject_mutex);
 	--urb->reject;
-	spin_unlock_irq(&urb->lock);
+	mutex_unlock(&reject_mutex);
 }
 
 /**

commit d617bc83ff48ebf0df253605529d8b3bef15773a
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Thu Aug 2 15:04:52 2007 -0400

    USB: cleanup for previous patches
    
    This patch (as951) cleans up a few loose ends from earlier patches.
    Redundant checks for non-NULL urb->dev are removed, as are checks of
    urb->dev->bus (which can never be NULL).  Conversely, a check for
    non-NULL urb->ep is added to the unlink paths.
    
    A homegrown round-down-to-power-of-2 loop is simplified by using the
    ilog2 routine.  The comparison in usb_urb_dir_in() is made more
    transparent.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index 1acca8696bcd..19f5f66c2733 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -3,6 +3,7 @@
 #include <linux/bitops.h>
 #include <linux/slab.h>
 #include <linux/init.h>
+#include <linux/log2.h>
 #include <linux/usb.h>
 #include <linux/wait.h>
 #include "hcd.h"
@@ -441,10 +442,8 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 		default:
 			return -EINVAL;
 		}
-		/* power of two? */
-		while (max > urb->interval)
-			max >>= 1;
-		urb->interval = max;
+		/* Round down to a power of 2, no more than max */
+		urb->interval = min(max, 1 << ilog2(urb->interval));
 	}
 
 	return usb_hcd_submit_urb(urb, mem_flags);
@@ -513,8 +512,10 @@ int usb_unlink_urb(struct urb *urb)
 {
 	if (!urb)
 		return -EINVAL;
-	if (!(urb->dev && urb->dev->bus))
+	if (!urb->dev)
 		return -ENODEV;
+	if (!urb->ep)
+		return -EIDRM;
 	return usb_hcd_unlink_urb(urb, -ECONNRESET);
 }
 
@@ -541,7 +542,7 @@ int usb_unlink_urb(struct urb *urb)
 void usb_kill_urb(struct urb *urb)
 {
 	might_sleep();
-	if (!(urb && urb->dev && urb->dev->bus))
+	if (!(urb && urb->dev && urb->ep))
 		return;
 	spin_lock_irq(&urb->lock);
 	++urb->reject;

commit 4326ed0be93574dac5b5e475713015159108bd88
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Jul 30 17:08:43 2007 -0400

    USB: address-0 handling during device initialization
    
    This patch (as947) changes the device initialization and enumeration
    code in hub.c; now udev->devnum will be set to 0 while the device is
    being accessed at address 0.  Until now this wasn't needed because the
    address value was passed as part of urb->pipe; without that field the
    device address must be stored elsewhere.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index 1a64a6a850f3..1acca8696bcd 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -284,9 +284,7 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 
 	if (!urb || urb->hcpriv || !urb->complete)
 		return -EINVAL;
-	if (!(dev = urb->dev) ||
-	    (dev->state < USB_STATE_DEFAULT) ||
-	    (!dev->bus) || (dev->devnum <= 0))
+	if (!(dev = urb->dev) || dev->state < USB_STATE_DEFAULT)
 		return -ENODEV;
 	if (dev->bus->controller->power.power_state.event != PM_EVENT_ON
 			|| dev->state == USB_STATE_SUSPENDED)

commit fea3409112a93581db18da4c4332c8bf8d68af6b
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Jul 30 17:06:16 2007 -0400

    USB: add direction bit to urb->transfer_flags
    
    This patch (as945) adds a bit to urb->transfer_flags for recording the
    direction of the URB.  The bit is set/cleared automatically in
    usb_submit_urb() so drivers don't have to worry about it (although as
    a result, it isn't valid until the URB has been submitted).  Inline
    routines are added for easily checking an URB's direction.  They
    replace calls to usb_pipein in the DMA-mapping parts of hcd.c.
    
    For non-control endpoints, the direction is determined directly from
    the endpoint descriptor.  However control endpoints are
    bi-directional; for them the direction is determined from the
    bRequestType byte and the wLength value in the setup packet.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index ff53acb4fab2..1a64a6a850f3 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -309,7 +309,21 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 	 * and don't need to duplicate tests
 	 */
 	xfertype = usb_endpoint_type(&ep->desc);
-	is_out = usb_pipeout(urb->pipe);
+	if (xfertype == USB_ENDPOINT_XFER_CONTROL) {
+		struct usb_ctrlrequest *setup =
+				(struct usb_ctrlrequest *) urb->setup_packet;
+
+		if (!setup)
+			return -ENOEXEC;
+		is_out = !(setup->bRequestType & USB_DIR_IN) ||
+				!setup->wLength;
+	} else {
+		is_out = usb_endpoint_dir_out(&ep->desc);
+	}
+
+	/* Cache the direction for later use */
+	urb->transfer_flags = (urb->transfer_flags & ~URB_DIR_MASK) |
+			(is_out ? URB_DIR_OUT : URB_DIR_IN);
 
 	if (xfertype != USB_ENDPOINT_XFER_CONTROL &&
 			dev->state < USB_STATE_CONFIGURED)
@@ -363,7 +377,7 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 
 	/* enforce simple/standard policy */
 	allowed = (URB_NO_TRANSFER_DMA_MAP | URB_NO_SETUP_DMA_MAP |
-			URB_NO_INTERRUPT);
+			URB_NO_INTERRUPT | URB_DIR_MASK);
 	switch (xfertype) {
 	case USB_ENDPOINT_XFER_BULK:
 		if (is_out)

commit 5b653c79c04c6b152b8dc7d18f8c8a7f77f4b235
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Jul 30 17:04:37 2007 -0400

    USB: add urb->ep
    
    This patch (as943) prepares the way for eliminating urb->pipe by
    introducing an endpoint pointer into struct urb.  For now urb->ep
    is set by usb_submit_urb() from the pipe value; eventually drivers
    will set it themselves and we will remove urb->pipe completely.
    
    The patch also adds new inline routines to retrieve an endpoint
    descriptor's number and transfer type, essentially as replacements for
    usb_pipeendpoint and usb_pipetype.
    
    usb_submit_urb(), usb_hcd_submit_urb(), and usb_hcd_unlink_urb() are
    converted to use the new field and new routines.  Other parts of
    usbcore will be converted in later patches.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index be630228461c..ff53acb4fab2 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -277,9 +277,10 @@ EXPORT_SYMBOL_GPL(usb_unanchor_urb);
  */
 int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 {
-	int			pipe, temp, max;
-	struct usb_device	*dev;
-	int			is_out;
+	int				xfertype, max;
+	struct usb_device		*dev;
+	struct usb_host_endpoint	*ep;
+	int				is_out;
 
 	if (!urb || urb->hcpriv || !urb->complete)
 		return -EINVAL;
@@ -291,30 +292,34 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 			|| dev->state == USB_STATE_SUSPENDED)
 		return -EHOSTUNREACH;
 
+	/* For now, get the endpoint from the pipe.  Eventually drivers
+	 * will be required to set urb->ep directly and we will eliminate
+	 * urb->pipe.
+	 */
+	ep = (usb_pipein(urb->pipe) ? dev->ep_in : dev->ep_out)
+			[usb_pipeendpoint(urb->pipe)];
+	if (!ep)
+		return -ENOENT;
+
+	urb->ep = ep;
 	urb->status = -EINPROGRESS;
 	urb->actual_length = 0;
 
 	/* Lots of sanity checks, so HCDs can rely on clean data
 	 * and don't need to duplicate tests
 	 */
-	pipe = urb->pipe;
-	temp = usb_pipetype(pipe);
-	is_out = usb_pipeout(pipe);
+	xfertype = usb_endpoint_type(&ep->desc);
+	is_out = usb_pipeout(urb->pipe);
 
-	if (!usb_pipecontrol(pipe) && dev->state < USB_STATE_CONFIGURED)
+	if (xfertype != USB_ENDPOINT_XFER_CONTROL &&
+			dev->state < USB_STATE_CONFIGURED)
 		return -ENODEV;
 
-	/* FIXME there should be a sharable lock protecting us against
-	 * config/altsetting changes and disconnects, kicking in here.
-	 * (here == before maxpacket, and eventually endpoint type,
-	 * checks get made.)
-	 */
-
-	max = usb_maxpacket(dev, pipe, is_out);
+	max = le16_to_cpu(ep->desc.wMaxPacketSize);
 	if (max <= 0) {
 		dev_dbg(&dev->dev,
 			"bogus endpoint ep%d%s in %s (bad maxpacket %d)\n",
-			usb_pipeendpoint(pipe), is_out ? "out" : "in",
+			usb_endpoint_num(&ep->desc), is_out ? "out" : "in",
 			__FUNCTION__, max);
 		return -EMSGSIZE;
 	}
@@ -323,7 +328,7 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 	 * but drivers only control those sizes for ISO.
 	 * while we're checking, initialize return status.
 	 */
-	if (temp == PIPE_ISOCHRONOUS) {
+	if (xfertype == USB_ENDPOINT_XFER_ISOC) {
 		int	n, len;
 
 		/* "high bandwidth" mode, 1-3 packets/uframe? */
@@ -359,19 +364,19 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 	/* enforce simple/standard policy */
 	allowed = (URB_NO_TRANSFER_DMA_MAP | URB_NO_SETUP_DMA_MAP |
 			URB_NO_INTERRUPT);
-	switch (temp) {
-	case PIPE_BULK:
+	switch (xfertype) {
+	case USB_ENDPOINT_XFER_BULK:
 		if (is_out)
 			allowed |= URB_ZERO_PACKET;
 		/* FALLTHROUGH */
-	case PIPE_CONTROL:
+	case USB_ENDPOINT_XFER_CONTROL:
 		allowed |= URB_NO_FSBR;	/* only affects UHCI */
 		/* FALLTHROUGH */
 	default:			/* all non-iso endpoints */
 		if (!is_out)
 			allowed |= URB_SHORT_NOT_OK;
 		break;
-	case PIPE_ISOCHRONOUS:
+	case USB_ENDPOINT_XFER_ISOC:
 		allowed |= URB_ISO_ASAP;
 		break;
 	}
@@ -393,9 +398,9 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 	 * supports different values... this uses EHCI/UHCI defaults (and
 	 * EHCI can use smaller non-default values).
 	 */
-	switch (temp) {
-	case PIPE_ISOCHRONOUS:
-	case PIPE_INTERRUPT:
+	switch (xfertype) {
+	case USB_ENDPOINT_XFER_ISOC:
+	case USB_ENDPOINT_XFER_INT:
 		/* too small? */
 		if (urb->interval <= 0)
 			return -EINVAL;
@@ -405,29 +410,29 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 			// NOTE usb handles 2^15
 			if (urb->interval > (1024 * 8))
 				urb->interval = 1024 * 8;
-			temp = 1024 * 8;
+			max = 1024 * 8;
 			break;
 		case USB_SPEED_FULL:	/* units are frames/msec */
 		case USB_SPEED_LOW:
-			if (temp == PIPE_INTERRUPT) {
+			if (xfertype == USB_ENDPOINT_XFER_INT) {
 				if (urb->interval > 255)
 					return -EINVAL;
 				// NOTE ohci only handles up to 32
-				temp = 128;
+				max = 128;
 			} else {
 				if (urb->interval > 1024)
 					urb->interval = 1024;
 				// NOTE usb and ohci handle up to 2^15
-				temp = 1024;
+				max = 1024;
 			}
 			break;
 		default:
 			return -EINVAL;
 		}
 		/* power of two? */
-		while (temp > urb->interval)
-			temp >>= 1;
-		urb->interval = temp;
+		while (max > urb->interval)
+			max >>= 1;
+		urb->interval = max;
 	}
 
 	return usb_hcd_submit_urb(urb, mem_flags);

commit beafef072af10bc8497c9ee51ce2804aa7da26be
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Jul 13 15:47:16 2007 -0400

    USB: documentation update for usb_unlink_urb
    
    This patch (as936) updates the kerneldoc for usb_unlink_urb.  The
    explanation of how endpoint queues are meant to work is now clearer
    and in better agreement with reality.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index 52ec44b828f3..be630228461c 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -440,55 +440,57 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
  * @urb: pointer to urb describing a previously submitted request,
  *	may be NULL
  *
- * This routine cancels an in-progress request.  URBs complete only
- * once per submission, and may be canceled only once per submission.
- * Successful cancellation means the requests's completion handler will
- * be called with a status code indicating that the request has been
- * canceled (rather than any other code) and will quickly be removed
- * from host controller data structures.
- *
- * This request is always asynchronous.
- * Success is indicated by returning -EINPROGRESS,
- * at which time the URB will normally have been unlinked but not yet
- * given back to the device driver.  When it is called, the completion
- * function will see urb->status == -ECONNRESET.  Failure is indicated
- * by any other return value.  Unlinking will fail when the URB is not
- * currently "linked" (i.e., it was never submitted, or it was unlinked
- * before, or the hardware is already finished with it), even if the
- * completion handler has not yet run.
+ * This routine cancels an in-progress request.  URBs complete only once
+ * per submission, and may be canceled only once per submission.
+ * Successful cancellation means termination of @urb will be expedited
+ * and the completion handler will be called with a status code
+ * indicating that the request has been canceled (rather than any other
+ * code).
+ *
+ * This request is always asynchronous.  Success is indicated by
+ * returning -EINPROGRESS, at which time the URB will probably not yet
+ * have been given back to the device driver.  When it is eventually
+ * called, the completion function will see @urb->status == -ECONNRESET.
+ * Failure is indicated by usb_unlink_urb() returning any other value.
+ * Unlinking will fail when @urb is not currently "linked" (i.e., it was
+ * never submitted, or it was unlinked before, or the hardware is already
+ * finished with it), even if the completion handler has not yet run.
  *
  * Unlinking and Endpoint Queues:
  *
+ * [The behaviors and guarantees described below do not apply to virtual
+ * root hubs but only to endpoint queues for physical USB devices.]
+ *
  * Host Controller Drivers (HCDs) place all the URBs for a particular
  * endpoint in a queue.  Normally the queue advances as the controller
  * hardware processes each request.  But when an URB terminates with an
- * error its queue stops, at least until that URB's completion routine
- * returns.  It is guaranteed that the queue will not restart until all
- * its unlinked URBs have been fully retired, with their completion
- * routines run, even if that's not until some time after the original
- * completion handler returns.  Normally the same behavior and guarantees
- * apply when an URB terminates because it was unlinked; however if an
- * URB is unlinked before the hardware has started to execute it, then
- * its queue is not guaranteed to stop until all the preceding URBs have
- * completed.
- *
- * This means that USB device drivers can safely build deep queues for
- * large or complex transfers, and clean them up reliably after any sort
- * of aborted transfer by unlinking all pending URBs at the first fault.
- *
- * Note that an URB terminating early because a short packet was received
- * will count as an error if and only if the URB_SHORT_NOT_OK flag is set.
- * Also, that all unlinks performed in any URB completion handler must
- * be asynchronous.
- *
- * Queues for isochronous endpoints are treated differently, because they
- * advance at fixed rates.  Such queues do not stop when an URB is unlinked.
- * An unlinked URB may leave a gap in the stream of packets.  It is undefined
- * whether such gaps can be filled in.
- *
- * When a control URB terminates with an error, it is likely that the
- * status stage of the transfer will not take place, even if it is merely
- * a soft error resulting from a short-packet with URB_SHORT_NOT_OK set.
+ * error its queue generally stops (see below), at least until that URB's
+ * completion routine returns.  It is guaranteed that a stopped queue
+ * will not restart until all its unlinked URBs have been fully retired,
+ * with their completion routines run, even if that's not until some time
+ * after the original completion handler returns.  The same behavior and
+ * guarantee apply when an URB terminates because it was unlinked.
+ *
+ * Bulk and interrupt endpoint queues are guaranteed to stop whenever an
+ * URB terminates with any sort of error, including -ECONNRESET, -ENOENT,
+ * and -EREMOTEIO.  Control endpoint queues behave the same way except
+ * that they are not guaranteed to stop for -EREMOTEIO errors.  Queues
+ * for isochronous endpoints are treated differently, because they must
+ * advance at fixed rates.  Such queues do not stop when an URB
+ * encounters an error or is unlinked.  An unlinked isochronous URB may
+ * leave a gap in the stream of packets; it is undefined whether such
+ * gaps can be filled in.
+ *
+ * Note that early termination of an URB because a short packet was
+ * received will generate a -EREMOTEIO error if and only if the
+ * URB_SHORT_NOT_OK flag is set.  By setting this flag, USB device
+ * drivers can build deep queues for large or complex bulk transfers
+ * and clean them up reliably after any sort of aborted transfer by
+ * unlinking all pending URBs at the first fault.
+ *
+ * When a control URB terminates with an error other than -EREMOTEIO, it
+ * is quite likely that the status stage of the transfer will not take
+ * place.
  */
 int usb_unlink_urb(struct urb *urb)
 {

commit 8b3b01c898a44c2fc7217eb579982b9d132113f5
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jun 13 08:02:11 2007 +0200

    USB: Add URB_FREE_BUFFER flag and the logic behind it
    
    USB: Add URB_FREE_BUFFER flag for freeing the transfer buffer
    
    In some cases it is not needed that the driver keeps track of the
    transfer buffer of an URB. It can be simply freed along with the
    URB itself when the reference count goes down to zero. The new
    flag URB_FREE_BUFFER enables this behavior.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index ac4273dddf34..52ec44b828f3 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -13,6 +13,9 @@ static void urb_destroy(struct kref *kref)
 {
 	struct urb *urb = to_urb(kref);
 
+	if (urb->transfer_flags & URB_FREE_BUFFER)
+		kfree(urb->transfer_buffer);
+
 	kfree(urb);
 }
 

commit 51a2f077c44e559841b09de6da605b4d3ae40dad
Author: Oliver Neukum <oneukum@suse.de>
Date:   Fri May 25 13:40:56 2007 +0200

    USB: introduce usb_anchor
    
    - introduction of usb_anchor and its methods
    
    Signed-off-by: Oliver Neukum <oneukum@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index 94ea9727ff55..ac4273dddf34 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -4,6 +4,7 @@
 #include <linux/slab.h>
 #include <linux/init.h>
 #include <linux/usb.h>
+#include <linux/wait.h>
 #include "hcd.h"
 
 #define to_urb(d) container_of(d, struct urb, kref)
@@ -11,6 +12,7 @@
 static void urb_destroy(struct kref *kref)
 {
 	struct urb *urb = to_urb(kref);
+
 	kfree(urb);
 }
 
@@ -34,6 +36,7 @@ void usb_init_urb(struct urb *urb)
 		memset(urb, 0, sizeof(*urb));
 		kref_init(&urb->kref);
 		spin_lock_init(&urb->lock);
+		INIT_LIST_HEAD(&urb->anchor_list);
 	}
 }
 
@@ -100,8 +103,60 @@ struct urb * usb_get_urb(struct urb *urb)
 		kref_get(&urb->kref);
 	return urb;
 }
-		
-		
+
+/**
+ * usb_anchor_urb - anchors an URB while it is processed
+ * @urb: pointer to the urb to anchor
+ * @anchor: pointer to the anchor
+ *
+ * This can be called to have access to URBs which are to be executed
+ * without bothering to track them
+ */
+void usb_anchor_urb(struct urb *urb, struct usb_anchor *anchor)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&anchor->lock, flags);
+	usb_get_urb(urb);
+	list_add_tail(&urb->anchor_list, &anchor->urb_list);
+	urb->anchor = anchor;
+	spin_unlock_irqrestore(&anchor->lock, flags);
+}
+EXPORT_SYMBOL_GPL(usb_anchor_urb);
+
+/**
+ * usb_unanchor_urb - unanchors an URB
+ * @urb: pointer to the urb to anchor
+ *
+ * Call this to stop the system keeping track of this URB
+ */
+void usb_unanchor_urb(struct urb *urb)
+{
+	unsigned long flags;
+	struct usb_anchor *anchor;
+
+	if (!urb)
+		return;
+
+	anchor = urb->anchor;
+	if (!anchor)
+		return;
+
+	spin_lock_irqsave(&anchor->lock, flags);
+	if (unlikely(anchor != urb->anchor)) {
+		/* we've lost the race to another thread */
+		spin_unlock_irqrestore(&anchor->lock, flags);
+		return;
+	}
+	urb->anchor = NULL;
+	list_del(&urb->anchor_list);
+	spin_unlock_irqrestore(&anchor->lock, flags);
+	usb_put_urb(urb);
+	if (list_empty(&anchor->urb_list))
+		wake_up(&anchor->wait);
+}
+EXPORT_SYMBOL_GPL(usb_unanchor_urb);
+
 /*-------------------------------------------------------------------*/
 
 /**
@@ -478,6 +533,48 @@ void usb_kill_urb(struct urb *urb)
 	spin_unlock_irq(&urb->lock);
 }
 
+/**
+ * usb_kill_anchored_urbs - cancel transfer requests en masse
+ * @anchor: anchor the requests are bound to
+ *
+ * this allows all outstanding URBs to be killed starting
+ * from the back of the queue
+ */
+void usb_kill_anchored_urbs(struct usb_anchor *anchor)
+{
+	struct urb *victim;
+
+	spin_lock_irq(&anchor->lock);
+	while (!list_empty(&anchor->urb_list)) {
+		victim = list_entry(anchor->urb_list.prev, struct urb, anchor_list);
+		/* we must make sure the URB isn't freed before we kill it*/
+		usb_get_urb(victim);
+		spin_unlock_irq(&anchor->lock);
+		/* this will unanchor the URB */
+		usb_kill_urb(victim);
+		usb_put_urb(victim);
+		spin_lock_irq(&anchor->lock);
+	}
+	spin_unlock_irq(&anchor->lock);
+}
+EXPORT_SYMBOL_GPL(usb_kill_anchored_urbs);
+
+/**
+ * usb_wait_anchor_empty_timeout - wait for an anchor to be unused
+ * @anchor: the anchor you want to become unused
+ * @timeout: how long you are willing to wait in milliseconds
+ *
+ * Call this is you want to be sure all an anchor's
+ * URBs have finished
+ */
+int usb_wait_anchor_empty_timeout(struct usb_anchor *anchor,
+				  unsigned int timeout)
+{
+	return wait_event_timeout(anchor->wait, list_empty(&anchor->urb_list),
+				  msecs_to_jiffies(timeout));
+}
+EXPORT_SYMBOL_GPL(usb_wait_anchor_empty_timeout);
+
 EXPORT_SYMBOL(usb_init_urb);
 EXPORT_SYMBOL(usb_alloc_urb);
 EXPORT_SYMBOL(usb_free_urb);
@@ -485,4 +582,3 @@ EXPORT_SYMBOL(usb_get_urb);
 EXPORT_SYMBOL(usb_submit_urb);
 EXPORT_SYMBOL(usb_unlink_urb);
 EXPORT_SYMBOL(usb_kill_urb);
-

commit 9251644ab33579d80c038b077f78daa23a04fdcd
Author: Oliver Neukum <oneukum@suse.de>
Date:   Tue Jan 23 15:55:28 2007 -0500

    usbcore: trivial whitespace fixes
    
    This patch (as844) makes some trivial whitespace fixes to a few files
    in usbcore.  Oliver did most of the work and Alan added some tidying up.
    
    Signed-off-by: Oliver Neukum <oneukum@suse.de>
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index a4fa3e66c307..94ea9727ff55 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -240,10 +240,10 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 	 * and don't need to duplicate tests
 	 */
 	pipe = urb->pipe;
-	temp = usb_pipetype (pipe);
-	is_out = usb_pipeout (pipe);
+	temp = usb_pipetype(pipe);
+	is_out = usb_pipeout(pipe);
 
-	if (!usb_pipecontrol (pipe) && dev->state < USB_STATE_CONFIGURED)
+	if (!usb_pipecontrol(pipe) && dev->state < USB_STATE_CONFIGURED)
 		return -ENODEV;
 
 	/* FIXME there should be a sharable lock protecting us against
@@ -252,11 +252,11 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 	 * checks get made.)
 	 */
 
-	max = usb_maxpacket (dev, pipe, is_out);
+	max = usb_maxpacket(dev, pipe, is_out);
 	if (max <= 0) {
 		dev_dbg(&dev->dev,
 			"bogus endpoint ep%d%s in %s (bad maxpacket %d)\n",
-			usb_pipeendpoint (pipe), is_out ? "out" : "in",
+			usb_pipeendpoint(pipe), is_out ? "out" : "in",
 			__FUNCTION__, max);
 		return -EMSGSIZE;
 	}
@@ -278,11 +278,11 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 		if (urb->number_of_packets <= 0)		    
 			return -EINVAL;
 		for (n = 0; n < urb->number_of_packets; n++) {
-			len = urb->iso_frame_desc [n].length;
+			len = urb->iso_frame_desc[n].length;
 			if (len < 0 || len > max) 
 				return -EMSGSIZE;
-			urb->iso_frame_desc [n].status = -EXDEV;
-			urb->iso_frame_desc [n].actual_length = 0;
+			urb->iso_frame_desc[n].status = -EXDEV;
+			urb->iso_frame_desc[n].actual_length = 0;
 		}
 	}
 
@@ -321,7 +321,7 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 
 	/* fail if submitter gave bogus flags */
 	if (urb->transfer_flags != orig_flags) {
-		err ("BOGUS urb flags, %x --> %x",
+		err("BOGUS urb flags, %x --> %x",
 			orig_flags, urb->transfer_flags);
 		return -EINVAL;
 	}
@@ -372,7 +372,7 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 		urb->interval = temp;
 	}
 
-	return usb_hcd_submit_urb (urb, mem_flags);
+	return usb_hcd_submit_urb(urb, mem_flags);
 }
 
 /*-------------------------------------------------------------------*/

commit 896fbd7199035958013d106329843d8ae9618753
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Jan 16 11:57:13 2007 -0500

    usbcore: remove unused bandwith-related code
    
    This patch (as841) removes from usbcore a couple of support routines
    meant to help with bandwidth allocation.  With the changes to uhci-hcd
    in the previous patch, these routines are no longer used anywhere.
    Also removed is the CONFIG_USB_BANDWIDTH option; it no longer does
    anything and is no longer needed since the HCDs now handle bandwidth
    issues correctly.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index 9801d08edacf..a4fa3e66c307 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -235,7 +235,6 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 
 	urb->status = -EINPROGRESS;
 	urb->actual_length = 0;
-	urb->bandwidth = 0;
 
 	/* Lots of sanity checks, so HCDs can rely on clean data
 	 * and don't need to duplicate tests

commit ec17cf1cfe0b557210b27313bd584e9b5187d4ca
Author: Tobias Klauser <tklauser@distanz.ch>
Date:   Wed Sep 13 21:38:41 2006 +0200

    USB: Remove unneeded void * casts in core files
    
    The patch removes unneeded casts for the following (void *) pointers:
     - struct file: private
     - struct urb: context
     - struct usb_bus: hcpriv
     - return value of kmalloc()
    
    The patch also contains some whitespace cleanup in the relevant areas.
    
    Signed-off-by: Tobias Klauser <tklauser@distanz.ch>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index 576919927f53..9801d08edacf 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -57,7 +57,7 @@ struct urb *usb_alloc_urb(int iso_packets, gfp_t mem_flags)
 {
 	struct urb *urb;
 
-	urb = (struct urb *)kmalloc(sizeof(struct urb) + 
+	urb = kmalloc(sizeof(struct urb) +
 		iso_packets * sizeof(struct usb_iso_packet_descriptor),
 		mem_flags);
 	if (!urb) {

commit a6d2bb9ff919b4685bd684620ec7a1ffa8bf2349
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Aug 30 11:27:36 2006 -0400

    USB: remove struct usb_operations
    
    All of the currently-supported USB host controller drivers use the HCD
    bus-glue framework.  As part of the program for flattening out the glue
    layer, this patch (as769) removes the usb_operations structure.  All
    function calls now go directly to the HCD routines (slightly renamed
    to remain within the "usb_" namespace).
    
    The patch also removes usb_alloc_bus(), because it's not useful in the
    HCD framework and it wasn't referenced anywhere.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index 9864988377c7..576919927f53 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -221,7 +221,6 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 {
 	int			pipe, temp, max;
 	struct usb_device	*dev;
-	struct usb_operations	*op;
 	int			is_out;
 
 	if (!urb || urb->hcpriv || !urb->complete)
@@ -233,8 +232,6 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 	if (dev->bus->controller->power.power_state.event != PM_EVENT_ON
 			|| dev->state == USB_STATE_SUSPENDED)
 		return -EHOSTUNREACH;
-	if (!(op = dev->bus->op) || !op->submit_urb)
-		return -ENODEV;
 
 	urb->status = -EINPROGRESS;
 	urb->actual_length = 0;
@@ -376,7 +373,7 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 		urb->interval = temp;
 	}
 
-	return op->submit_urb (urb, mem_flags);
+	return usb_hcd_submit_urb (urb, mem_flags);
 }
 
 /*-------------------------------------------------------------------*/
@@ -440,9 +437,9 @@ int usb_unlink_urb(struct urb *urb)
 {
 	if (!urb)
 		return -EINVAL;
-	if (!(urb->dev && urb->dev->bus && urb->dev->bus->op))
+	if (!(urb->dev && urb->dev->bus))
 		return -ENODEV;
-	return urb->dev->bus->op->unlink_urb(urb, -ECONNRESET);
+	return usb_hcd_unlink_urb(urb, -ECONNRESET);
 }
 
 /**
@@ -468,13 +465,13 @@ int usb_unlink_urb(struct urb *urb)
 void usb_kill_urb(struct urb *urb)
 {
 	might_sleep();
-	if (!(urb && urb->dev && urb->dev->bus && urb->dev->bus->op))
+	if (!(urb && urb->dev && urb->dev->bus))
 		return;
 	spin_lock_irq(&urb->lock);
 	++urb->reject;
 	spin_unlock_irq(&urb->lock);
 
-	urb->dev->bus->op->unlink_urb(urb, -ENOENT);
+	usb_hcd_unlink_urb(urb, -ENOENT);
 	wait_event(usb_kill_urb_queue, atomic_read(&urb->use_count) == 0);
 
 	spin_lock_irq(&urb->lock);

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jörn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jörn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index dad4d8fd8180..9864988377c7 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -1,4 +1,3 @@
-#include <linux/config.h>
 #include <linux/module.h>
 #include <linux/string.h>
 #include <linux/bitops.h>

commit e9aa795aaed0b861aaa5a8075748c9c34e2620ee
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Jan 23 17:17:21 2006 -0500

    [PATCH] USB: add might_sleep() to usb_unlink_urb() to warn developers
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index 081796726b95..dad4d8fd8180 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -468,6 +468,7 @@ int usb_unlink_urb(struct urb *urb)
  */
 void usb_kill_urb(struct urb *urb)
 {
+	might_sleep();
 	if (!(urb && urb->dev && urb->dev->bus && urb->dev->bus->op))
 		return;
 	spin_lock_irq(&urb->lock);

commit 654f31189e550cd5924b786487a5d93d9feaada9
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Nov 17 09:48:09 2005 -0800

    [PATCH] USB: move CONFIG_USB_DEBUG checks into the Makefile
    
    This lets us remove a lot of code in the drivers that were all checking
    the same thing.  It also found some bugs in a few of the drivers, which
    has been fixed up.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index f2a1fed2a802..081796726b95 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -4,12 +4,6 @@
 #include <linux/bitops.h>
 #include <linux/slab.h>
 #include <linux/init.h>
-
-#ifdef CONFIG_USB_DEBUG
-	#define DEBUG
-#else
-	#undef DEBUG
-#endif
 #include <linux/usb.h>
 #include "hcd.h"
 

commit b13296c6617f22e8c0174a7af32780617db0e680
Author: David Brownell <david-b@pacbell.net>
Date:   Tue Sep 27 10:38:54 2005 -0700

    [PATCH] updates for "controller suspended" handling
    
    Reject URBs to _all_ devices when their host controllers are suspended;
    even root hub registers will be unavailable.  Also, don't reject urbs
    to root hubs in other cases; the only upstream link is through that
    controller (on PCI or whatever SOC bus is in use).
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    
     drivers/usb/core/hcd.c |   28 ++++++++++++----------------
     drivers/usb/core/urb.c |    3 ++-
     2 files changed, 14 insertions(+), 17 deletions(-)

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index b32898e0a27d..f2a1fed2a802 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -237,7 +237,8 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 	    (dev->state < USB_STATE_DEFAULT) ||
 	    (!dev->bus) || (dev->devnum <= 0))
 		return -ENODEV;
-	if (dev->state == USB_STATE_SUSPENDED)
+	if (dev->bus->controller->power.power_state.event != PM_EVENT_ON
+			|| dev->state == USB_STATE_SUSPENDED)
 		return -EHOSTUNREACH;
 	if (!(op = dev->bus->op) || !op->submit_urb)
 		return -ENODEV;

commit 55016f10e31bb15b85d8c500f979dfdceb37d548
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Oct 21 03:21:58 2005 -0400

    [PATCH] gfp_t: drivers/usb
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index c846fefb7386..b32898e0a27d 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -60,7 +60,7 @@ void usb_init_urb(struct urb *urb)
  *
  * The driver must call usb_free_urb() when it is finished with the urb.
  */
-struct urb *usb_alloc_urb(int iso_packets, unsigned mem_flags)
+struct urb *usb_alloc_urb(int iso_packets, gfp_t mem_flags)
 {
 	struct urb *urb;
 
@@ -224,7 +224,7 @@ struct urb * usb_get_urb(struct urb *urb)
  *      GFP_NOIO, unless b) or c) apply
  *
  */
-int usb_submit_urb(struct urb *urb, unsigned mem_flags)
+int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 {
 	int			pipe, temp, max;
 	struct usb_device	*dev;

commit b375a0495fd622037560c73c05f23ae6f127bb0c
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Jul 29 16:11:07 2005 -0400

    [PATCH] USB: URB_ASYNC_UNLINK flag removed from the kernel
    
    29 July 2005, Cambridge, MA:
    
    This afternoon Alan Stern submitted a patch to remove the URB_ASYNC_UNLINK
    flag from the Linux kernel.  Mr. Stern explained, "This flag is a relic
    from an earlier, less-well-designed system.  For over a year it hasn't
    been used for anything other than printing warning messages."
    
    An anonymous spokesman for the Linux kernel development community
    commented, "This is exactly the sort of thing we see happening all the
    time.  As the kernel evolves, support for old techniques and old code can
    be jettisoned and replaced by newer, better approaches.  Proprietary
    operating systems do not have the freedom or flexibility to change so
    quickly."
    
    Mr. Stern, a staff member at Harvard University's Rowland Institute who
    works on Linux only as a hobby, noted that the patch (labelled as548) did
    not update two files, keyspan.c and option.c, in the USB drivers' "serial"
    subdirectory.  "Those files need more extensive changes," he remarked.
    "They examine the status field of several URBs at times when they're not
    supposed to.  That will need to be fixed before the URB_ASYNC_UNLINK flag
    is removed."
    
    Greg Kroah-Hartman, the kernel maintainer responsible for overseeing all
    of Linux's USB drivers, did not respond to our inquiries or return our
    calls.  His only comment was "Applied, thanks."
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index c0feee25ff0a..c846fefb7386 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -309,9 +309,8 @@ int usb_submit_urb(struct urb *urb, unsigned mem_flags)
 	unsigned int	allowed;
 
 	/* enforce simple/standard policy */
-	allowed = URB_ASYNC_UNLINK;	// affects later unlinks
-	allowed |= (URB_NO_TRANSFER_DMA_MAP | URB_NO_SETUP_DMA_MAP);
-	allowed |= URB_NO_INTERRUPT;
+	allowed = (URB_NO_TRANSFER_DMA_MAP | URB_NO_SETUP_DMA_MAP |
+			URB_NO_INTERRUPT);
 	switch (temp) {
 	case PIPE_BULK:
 		if (is_out)
@@ -400,14 +399,8 @@ int usb_submit_urb(struct urb *urb, unsigned mem_flags)
  * canceled (rather than any other code) and will quickly be removed
  * from host controller data structures.
  *
- * In the past, clearing the URB_ASYNC_UNLINK transfer flag for the
- * URB indicated that the request was synchronous.  This usage is now
- * deprecated; if the flag is clear the call will be forwarded to
- * usb_kill_urb() and the return value will be 0.  In the future, drivers
- * should call usb_kill_urb() directly for synchronous unlinking.
- *
- * When the URB_ASYNC_UNLINK transfer flag for the URB is set, this
- * request is asynchronous.  Success is indicated by returning -EINPROGRESS,
+ * This request is always asynchronous.
+ * Success is indicated by returning -EINPROGRESS,
  * at which time the URB will normally have been unlinked but not yet
  * given back to the device driver.  When it is called, the completion
  * function will see urb->status == -ECONNRESET.  Failure is indicated
@@ -453,17 +446,6 @@ int usb_unlink_urb(struct urb *urb)
 {
 	if (!urb)
 		return -EINVAL;
-	if (!(urb->transfer_flags & URB_ASYNC_UNLINK)) {
-#ifdef CONFIG_DEBUG_KERNEL
-		if (printk_ratelimit()) {
-			printk(KERN_NOTICE "usb_unlink_urb() is deprecated for "
-				"synchronous unlinks.  Use usb_kill_urb() instead.\n");
-			WARN_ON(1);
-		}
-#endif
-		usb_kill_urb(urb);
-		return 0;
-	}
 	if (!(urb->dev && urb->dev->bus && urb->dev->bus->op))
 		return -ENODEV;
 	return urb->dev->bus->op->unlink_urb(urb, -ECONNRESET);

commit 5db539e49fc7471e23bf3c94ca304f008cb7b7f3
Author: Olav Kongas <ok@artecdesign.ee>
Date:   Thu Jun 23 20:25:36 2005 +0300

    [PATCH] USB: Fix kmalloc's flags type in USB
    
    Greg,
    
    This patch fixes the kmalloc() flags argument type in USB
    subsystem; hopefully all of its occurences. The patch was
    made against patch-2.6.12-git2 from Jun 20.
    
    Cleanup of flags for kmalloc() in USB subsystem.
    
    Signed-off-by: Olav Kongas <ok@artecdesign.ee>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index 0faf18d511de..c0feee25ff0a 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -60,7 +60,7 @@ void usb_init_urb(struct urb *urb)
  *
  * The driver must call usb_free_urb() when it is finished with the urb.
  */
-struct urb *usb_alloc_urb(int iso_packets, int mem_flags)
+struct urb *usb_alloc_urb(int iso_packets, unsigned mem_flags)
 {
 	struct urb *urb;
 
@@ -224,7 +224,7 @@ struct urb * usb_get_urb(struct urb *urb)
  *      GFP_NOIO, unless b) or c) apply
  *
  */
-int usb_submit_urb(struct urb *urb, int mem_flags)
+int usb_submit_urb(struct urb *urb, unsigned mem_flags)
 {
 	int			pipe, temp, max;
 	struct usb_device	*dev;

commit 093cf723b2b06d774929ea07982f6a466ff22314
Author: Steven Cole <elenstev@mesatop.com>
Date:   Tue May 3 19:07:24 2005 -0600

    [PATCH] USB: Spelling fixes for drivers/usb.
    
    Here are some spelling corrections for drivers/usb.
    
    cancelation -> cancellation
    succesful -> successful
    cancelation -> cancellation
    decriptor -> descriptor
    Initalize -> Initialize
    wierd -> weird
    Protocoll -> Protocol
    occured -> occurred
    successfull -> successful
    Procesing -> Processing
    devide -> divide
    Isochronuous -> Isochronous
    noticable -> noticeable
    Basicly -> Basically
    transfering -> transferring
    intialize -> initialize
    Incomming -> Incoming
    additionnal -> additional
    asume -> assume
    Unfortunatly -> Unfortunately
    retreive -> retrieve
    tranceiver -> transceiver
    Compatiblity -> Compatibility
    Incorprated -> Incorporated
    existance -> existence
    Ununsual -> Unusual
    
    Signed-off-by: Steven Cole <elenstev@mesatop.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index 16972159a57a..0faf18d511de 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -121,7 +121,7 @@ struct urb * usb_get_urb(struct urb *urb)
  * describing that request to the USB subsystem.  Request completion will
  * be indicated later, asynchronously, by calling the completion handler.
  * The three types of completion are success, error, and unlink
- * (a software-induced fault, also called "request cancelation").  
+ * (a software-induced fault, also called "request cancellation").  
  *
  * URBs may be submitted in interrupt context.
  *
@@ -170,7 +170,7 @@ struct urb * usb_get_urb(struct urb *urb)
  * As of Linux 2.6, all USB endpoint transfer queues support depths greater
  * than one.  This was previously a HCD-specific behavior, except for ISO
  * transfers.  Non-isochronous endpoint queues are inactive during cleanup
- * after faults (transfer errors or cancelation).
+ * after faults (transfer errors or cancellation).
  *
  * Reserved Bandwidth Transfers:
  *
@@ -395,7 +395,7 @@ int usb_submit_urb(struct urb *urb, int mem_flags)
  *
  * This routine cancels an in-progress request.  URBs complete only
  * once per submission, and may be canceled only once per submission.
- * Successful cancelation means the requests's completion handler will
+ * Successful cancellation means the requests's completion handler will
  * be called with a status code indicating that the request has been
  * canceled (rather than any other code) and will quickly be removed
  * from host controller data structures.

commit 8835f6657316162a8937d3f26ccd8f5886ba3845
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Apr 18 17:39:30 2005 -0700

    [PATCH] USB: USB API documentation modification
    
    In response to complaints about excessive latency in the uhci-hcd driver
    I'm planning to convert it to a top-half/bottom-half design.  It turns out
    that to do this, the USB API has to be modified slightly since the driver
    will not be able to meet one of the guarantees in the current API.  This
    patch changes some kerneldoc, specifying the weaker guarantee.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index dc838f81742c..16972159a57a 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -420,12 +420,16 @@ int usb_submit_urb(struct urb *urb, int mem_flags)
  *
  * Host Controller Drivers (HCDs) place all the URBs for a particular
  * endpoint in a queue.  Normally the queue advances as the controller
- * hardware processes each request.  But when an URB terminates with any
- * fault (such as an error, or being unlinked) its queue stops, at least
- * until that URB's completion routine returns.  It is guaranteed that
- * the queue will not restart until all its unlinked URBs have been fully
- * retired, with their completion routines run, even if that's not until
- * some time after the original completion handler returns.
+ * hardware processes each request.  But when an URB terminates with an
+ * error its queue stops, at least until that URB's completion routine
+ * returns.  It is guaranteed that the queue will not restart until all
+ * its unlinked URBs have been fully retired, with their completion
+ * routines run, even if that's not until some time after the original
+ * completion handler returns.  Normally the same behavior and guarantees
+ * apply when an URB terminates because it was unlinked; however if an
+ * URB is unlinked before the hardware has started to execute it, then
+ * its queue is not guaranteed to stop until all the preceding URBs have
+ * completed.
  *
  * This means that USB device drivers can safely build deep queues for
  * large or complex transfers, and clean them up reliably after any sort

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
new file mode 100644
index 000000000000..dc838f81742c
--- /dev/null
+++ b/drivers/usb/core/urb.c
@@ -0,0 +1,511 @@
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/bitops.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+
+#ifdef CONFIG_USB_DEBUG
+	#define DEBUG
+#else
+	#undef DEBUG
+#endif
+#include <linux/usb.h>
+#include "hcd.h"
+
+#define to_urb(d) container_of(d, struct urb, kref)
+
+static void urb_destroy(struct kref *kref)
+{
+	struct urb *urb = to_urb(kref);
+	kfree(urb);
+}
+
+/**
+ * usb_init_urb - initializes a urb so that it can be used by a USB driver
+ * @urb: pointer to the urb to initialize
+ *
+ * Initializes a urb so that the USB subsystem can use it properly.
+ *
+ * If a urb is created with a call to usb_alloc_urb() it is not
+ * necessary to call this function.  Only use this if you allocate the
+ * space for a struct urb on your own.  If you call this function, be
+ * careful when freeing the memory for your urb that it is no longer in
+ * use by the USB core.
+ *
+ * Only use this function if you _really_ understand what you are doing.
+ */
+void usb_init_urb(struct urb *urb)
+{
+	if (urb) {
+		memset(urb, 0, sizeof(*urb));
+		kref_init(&urb->kref);
+		spin_lock_init(&urb->lock);
+	}
+}
+
+/**
+ * usb_alloc_urb - creates a new urb for a USB driver to use
+ * @iso_packets: number of iso packets for this urb
+ * @mem_flags: the type of memory to allocate, see kmalloc() for a list of
+ *	valid options for this.
+ *
+ * Creates an urb for the USB driver to use, initializes a few internal
+ * structures, incrementes the usage counter, and returns a pointer to it.
+ *
+ * If no memory is available, NULL is returned.
+ *
+ * If the driver want to use this urb for interrupt, control, or bulk
+ * endpoints, pass '0' as the number of iso packets.
+ *
+ * The driver must call usb_free_urb() when it is finished with the urb.
+ */
+struct urb *usb_alloc_urb(int iso_packets, int mem_flags)
+{
+	struct urb *urb;
+
+	urb = (struct urb *)kmalloc(sizeof(struct urb) + 
+		iso_packets * sizeof(struct usb_iso_packet_descriptor),
+		mem_flags);
+	if (!urb) {
+		err("alloc_urb: kmalloc failed");
+		return NULL;
+	}
+	usb_init_urb(urb);
+	return urb;
+}
+
+/**
+ * usb_free_urb - frees the memory used by a urb when all users of it are finished
+ * @urb: pointer to the urb to free, may be NULL
+ *
+ * Must be called when a user of a urb is finished with it.  When the last user
+ * of the urb calls this function, the memory of the urb is freed.
+ *
+ * Note: The transfer buffer associated with the urb is not freed, that must be
+ * done elsewhere.
+ */
+void usb_free_urb(struct urb *urb)
+{
+	if (urb)
+		kref_put(&urb->kref, urb_destroy);
+}
+
+/**
+ * usb_get_urb - increments the reference count of the urb
+ * @urb: pointer to the urb to modify, may be NULL
+ *
+ * This must be  called whenever a urb is transferred from a device driver to a
+ * host controller driver.  This allows proper reference counting to happen
+ * for urbs.
+ *
+ * A pointer to the urb with the incremented reference counter is returned.
+ */
+struct urb * usb_get_urb(struct urb *urb)
+{
+	if (urb)
+		kref_get(&urb->kref);
+	return urb;
+}
+		
+		
+/*-------------------------------------------------------------------*/
+
+/**
+ * usb_submit_urb - issue an asynchronous transfer request for an endpoint
+ * @urb: pointer to the urb describing the request
+ * @mem_flags: the type of memory to allocate, see kmalloc() for a list
+ *	of valid options for this.
+ *
+ * This submits a transfer request, and transfers control of the URB
+ * describing that request to the USB subsystem.  Request completion will
+ * be indicated later, asynchronously, by calling the completion handler.
+ * The three types of completion are success, error, and unlink
+ * (a software-induced fault, also called "request cancelation").  
+ *
+ * URBs may be submitted in interrupt context.
+ *
+ * The caller must have correctly initialized the URB before submitting
+ * it.  Functions such as usb_fill_bulk_urb() and usb_fill_control_urb() are
+ * available to ensure that most fields are correctly initialized, for
+ * the particular kind of transfer, although they will not initialize
+ * any transfer flags.
+ *
+ * Successful submissions return 0; otherwise this routine returns a
+ * negative error number.  If the submission is successful, the complete()
+ * callback from the URB will be called exactly once, when the USB core and
+ * Host Controller Driver (HCD) are finished with the URB.  When the completion
+ * function is called, control of the URB is returned to the device
+ * driver which issued the request.  The completion handler may then
+ * immediately free or reuse that URB.
+ *
+ * With few exceptions, USB device drivers should never access URB fields
+ * provided by usbcore or the HCD until its complete() is called.
+ * The exceptions relate to periodic transfer scheduling.  For both
+ * interrupt and isochronous urbs, as part of successful URB submission
+ * urb->interval is modified to reflect the actual transfer period used
+ * (normally some power of two units).  And for isochronous urbs,
+ * urb->start_frame is modified to reflect when the URB's transfers were
+ * scheduled to start.  Not all isochronous transfer scheduling policies
+ * will work, but most host controller drivers should easily handle ISO
+ * queues going from now until 10-200 msec into the future.
+ *
+ * For control endpoints, the synchronous usb_control_msg() call is
+ * often used (in non-interrupt context) instead of this call.
+ * That is often used through convenience wrappers, for the requests
+ * that are standardized in the USB 2.0 specification.  For bulk
+ * endpoints, a synchronous usb_bulk_msg() call is available.
+ *
+ * Request Queuing:
+ *
+ * URBs may be submitted to endpoints before previous ones complete, to
+ * minimize the impact of interrupt latencies and system overhead on data
+ * throughput.  With that queuing policy, an endpoint's queue would never
+ * be empty.  This is required for continuous isochronous data streams,
+ * and may also be required for some kinds of interrupt transfers. Such
+ * queuing also maximizes bandwidth utilization by letting USB controllers
+ * start work on later requests before driver software has finished the
+ * completion processing for earlier (successful) requests.
+ *
+ * As of Linux 2.6, all USB endpoint transfer queues support depths greater
+ * than one.  This was previously a HCD-specific behavior, except for ISO
+ * transfers.  Non-isochronous endpoint queues are inactive during cleanup
+ * after faults (transfer errors or cancelation).
+ *
+ * Reserved Bandwidth Transfers:
+ *
+ * Periodic transfers (interrupt or isochronous) are performed repeatedly,
+ * using the interval specified in the urb.  Submitting the first urb to
+ * the endpoint reserves the bandwidth necessary to make those transfers.
+ * If the USB subsystem can't allocate sufficient bandwidth to perform
+ * the periodic request, submitting such a periodic request should fail.
+ *
+ * Device drivers must explicitly request that repetition, by ensuring that
+ * some URB is always on the endpoint's queue (except possibly for short
+ * periods during completion callacks).  When there is no longer an urb
+ * queued, the endpoint's bandwidth reservation is canceled.  This means
+ * drivers can use their completion handlers to ensure they keep bandwidth
+ * they need, by reinitializing and resubmitting the just-completed urb
+ * until the driver longer needs that periodic bandwidth.
+ *
+ * Memory Flags:
+ *
+ * The general rules for how to decide which mem_flags to use
+ * are the same as for kmalloc.  There are four
+ * different possible values; GFP_KERNEL, GFP_NOFS, GFP_NOIO and
+ * GFP_ATOMIC.
+ *
+ * GFP_NOFS is not ever used, as it has not been implemented yet.
+ *
+ * GFP_ATOMIC is used when
+ *   (a) you are inside a completion handler, an interrupt, bottom half,
+ *       tasklet or timer, or
+ *   (b) you are holding a spinlock or rwlock (does not apply to
+ *       semaphores), or
+ *   (c) current->state != TASK_RUNNING, this is the case only after
+ *       you've changed it.
+ * 
+ * GFP_NOIO is used in the block io path and error handling of storage
+ * devices.
+ *
+ * All other situations use GFP_KERNEL.
+ *
+ * Some more specific rules for mem_flags can be inferred, such as
+ *  (1) start_xmit, timeout, and receive methods of network drivers must
+ *      use GFP_ATOMIC (they are called with a spinlock held);
+ *  (2) queuecommand methods of scsi drivers must use GFP_ATOMIC (also
+ *      called with a spinlock held);
+ *  (3) If you use a kernel thread with a network driver you must use
+ *      GFP_NOIO, unless (b) or (c) apply;
+ *  (4) after you have done a down() you can use GFP_KERNEL, unless (b) or (c)
+ *      apply or your are in a storage driver's block io path;
+ *  (5) USB probe and disconnect can use GFP_KERNEL unless (b) or (c) apply; and
+ *  (6) changing firmware on a running storage or net device uses
+ *      GFP_NOIO, unless b) or c) apply
+ *
+ */
+int usb_submit_urb(struct urb *urb, int mem_flags)
+{
+	int			pipe, temp, max;
+	struct usb_device	*dev;
+	struct usb_operations	*op;
+	int			is_out;
+
+	if (!urb || urb->hcpriv || !urb->complete)
+		return -EINVAL;
+	if (!(dev = urb->dev) ||
+	    (dev->state < USB_STATE_DEFAULT) ||
+	    (!dev->bus) || (dev->devnum <= 0))
+		return -ENODEV;
+	if (dev->state == USB_STATE_SUSPENDED)
+		return -EHOSTUNREACH;
+	if (!(op = dev->bus->op) || !op->submit_urb)
+		return -ENODEV;
+
+	urb->status = -EINPROGRESS;
+	urb->actual_length = 0;
+	urb->bandwidth = 0;
+
+	/* Lots of sanity checks, so HCDs can rely on clean data
+	 * and don't need to duplicate tests
+	 */
+	pipe = urb->pipe;
+	temp = usb_pipetype (pipe);
+	is_out = usb_pipeout (pipe);
+
+	if (!usb_pipecontrol (pipe) && dev->state < USB_STATE_CONFIGURED)
+		return -ENODEV;
+
+	/* FIXME there should be a sharable lock protecting us against
+	 * config/altsetting changes and disconnects, kicking in here.
+	 * (here == before maxpacket, and eventually endpoint type,
+	 * checks get made.)
+	 */
+
+	max = usb_maxpacket (dev, pipe, is_out);
+	if (max <= 0) {
+		dev_dbg(&dev->dev,
+			"bogus endpoint ep%d%s in %s (bad maxpacket %d)\n",
+			usb_pipeendpoint (pipe), is_out ? "out" : "in",
+			__FUNCTION__, max);
+		return -EMSGSIZE;
+	}
+
+	/* periodic transfers limit size per frame/uframe,
+	 * but drivers only control those sizes for ISO.
+	 * while we're checking, initialize return status.
+	 */
+	if (temp == PIPE_ISOCHRONOUS) {
+		int	n, len;
+
+		/* "high bandwidth" mode, 1-3 packets/uframe? */
+		if (dev->speed == USB_SPEED_HIGH) {
+			int	mult = 1 + ((max >> 11) & 0x03);
+			max &= 0x07ff;
+			max *= mult;
+		}
+
+		if (urb->number_of_packets <= 0)		    
+			return -EINVAL;
+		for (n = 0; n < urb->number_of_packets; n++) {
+			len = urb->iso_frame_desc [n].length;
+			if (len < 0 || len > max) 
+				return -EMSGSIZE;
+			urb->iso_frame_desc [n].status = -EXDEV;
+			urb->iso_frame_desc [n].actual_length = 0;
+		}
+	}
+
+	/* the I/O buffer must be mapped/unmapped, except when length=0 */
+	if (urb->transfer_buffer_length < 0)
+		return -EMSGSIZE;
+
+#ifdef DEBUG
+	/* stuff that drivers shouldn't do, but which shouldn't
+	 * cause problems in HCDs if they get it wrong.
+	 */
+	{
+	unsigned int	orig_flags = urb->transfer_flags;
+	unsigned int	allowed;
+
+	/* enforce simple/standard policy */
+	allowed = URB_ASYNC_UNLINK;	// affects later unlinks
+	allowed |= (URB_NO_TRANSFER_DMA_MAP | URB_NO_SETUP_DMA_MAP);
+	allowed |= URB_NO_INTERRUPT;
+	switch (temp) {
+	case PIPE_BULK:
+		if (is_out)
+			allowed |= URB_ZERO_PACKET;
+		/* FALLTHROUGH */
+	case PIPE_CONTROL:
+		allowed |= URB_NO_FSBR;	/* only affects UHCI */
+		/* FALLTHROUGH */
+	default:			/* all non-iso endpoints */
+		if (!is_out)
+			allowed |= URB_SHORT_NOT_OK;
+		break;
+	case PIPE_ISOCHRONOUS:
+		allowed |= URB_ISO_ASAP;
+		break;
+	}
+	urb->transfer_flags &= allowed;
+
+	/* fail if submitter gave bogus flags */
+	if (urb->transfer_flags != orig_flags) {
+		err ("BOGUS urb flags, %x --> %x",
+			orig_flags, urb->transfer_flags);
+		return -EINVAL;
+	}
+	}
+#endif
+	/*
+	 * Force periodic transfer intervals to be legal values that are
+	 * a power of two (so HCDs don't need to).
+	 *
+	 * FIXME want bus->{intr,iso}_sched_horizon values here.  Each HC
+	 * supports different values... this uses EHCI/UHCI defaults (and
+	 * EHCI can use smaller non-default values).
+	 */
+	switch (temp) {
+	case PIPE_ISOCHRONOUS:
+	case PIPE_INTERRUPT:
+		/* too small? */
+		if (urb->interval <= 0)
+			return -EINVAL;
+		/* too big? */
+		switch (dev->speed) {
+		case USB_SPEED_HIGH:	/* units are microframes */
+			// NOTE usb handles 2^15
+			if (urb->interval > (1024 * 8))
+				urb->interval = 1024 * 8;
+			temp = 1024 * 8;
+			break;
+		case USB_SPEED_FULL:	/* units are frames/msec */
+		case USB_SPEED_LOW:
+			if (temp == PIPE_INTERRUPT) {
+				if (urb->interval > 255)
+					return -EINVAL;
+				// NOTE ohci only handles up to 32
+				temp = 128;
+			} else {
+				if (urb->interval > 1024)
+					urb->interval = 1024;
+				// NOTE usb and ohci handle up to 2^15
+				temp = 1024;
+			}
+			break;
+		default:
+			return -EINVAL;
+		}
+		/* power of two? */
+		while (temp > urb->interval)
+			temp >>= 1;
+		urb->interval = temp;
+	}
+
+	return op->submit_urb (urb, mem_flags);
+}
+
+/*-------------------------------------------------------------------*/
+
+/**
+ * usb_unlink_urb - abort/cancel a transfer request for an endpoint
+ * @urb: pointer to urb describing a previously submitted request,
+ *	may be NULL
+ *
+ * This routine cancels an in-progress request.  URBs complete only
+ * once per submission, and may be canceled only once per submission.
+ * Successful cancelation means the requests's completion handler will
+ * be called with a status code indicating that the request has been
+ * canceled (rather than any other code) and will quickly be removed
+ * from host controller data structures.
+ *
+ * In the past, clearing the URB_ASYNC_UNLINK transfer flag for the
+ * URB indicated that the request was synchronous.  This usage is now
+ * deprecated; if the flag is clear the call will be forwarded to
+ * usb_kill_urb() and the return value will be 0.  In the future, drivers
+ * should call usb_kill_urb() directly for synchronous unlinking.
+ *
+ * When the URB_ASYNC_UNLINK transfer flag for the URB is set, this
+ * request is asynchronous.  Success is indicated by returning -EINPROGRESS,
+ * at which time the URB will normally have been unlinked but not yet
+ * given back to the device driver.  When it is called, the completion
+ * function will see urb->status == -ECONNRESET.  Failure is indicated
+ * by any other return value.  Unlinking will fail when the URB is not
+ * currently "linked" (i.e., it was never submitted, or it was unlinked
+ * before, or the hardware is already finished with it), even if the
+ * completion handler has not yet run.
+ *
+ * Unlinking and Endpoint Queues:
+ *
+ * Host Controller Drivers (HCDs) place all the URBs for a particular
+ * endpoint in a queue.  Normally the queue advances as the controller
+ * hardware processes each request.  But when an URB terminates with any
+ * fault (such as an error, or being unlinked) its queue stops, at least
+ * until that URB's completion routine returns.  It is guaranteed that
+ * the queue will not restart until all its unlinked URBs have been fully
+ * retired, with their completion routines run, even if that's not until
+ * some time after the original completion handler returns.
+ *
+ * This means that USB device drivers can safely build deep queues for
+ * large or complex transfers, and clean them up reliably after any sort
+ * of aborted transfer by unlinking all pending URBs at the first fault.
+ *
+ * Note that an URB terminating early because a short packet was received
+ * will count as an error if and only if the URB_SHORT_NOT_OK flag is set.
+ * Also, that all unlinks performed in any URB completion handler must
+ * be asynchronous.
+ *
+ * Queues for isochronous endpoints are treated differently, because they
+ * advance at fixed rates.  Such queues do not stop when an URB is unlinked.
+ * An unlinked URB may leave a gap in the stream of packets.  It is undefined
+ * whether such gaps can be filled in.
+ *
+ * When a control URB terminates with an error, it is likely that the
+ * status stage of the transfer will not take place, even if it is merely
+ * a soft error resulting from a short-packet with URB_SHORT_NOT_OK set.
+ */
+int usb_unlink_urb(struct urb *urb)
+{
+	if (!urb)
+		return -EINVAL;
+	if (!(urb->transfer_flags & URB_ASYNC_UNLINK)) {
+#ifdef CONFIG_DEBUG_KERNEL
+		if (printk_ratelimit()) {
+			printk(KERN_NOTICE "usb_unlink_urb() is deprecated for "
+				"synchronous unlinks.  Use usb_kill_urb() instead.\n");
+			WARN_ON(1);
+		}
+#endif
+		usb_kill_urb(urb);
+		return 0;
+	}
+	if (!(urb->dev && urb->dev->bus && urb->dev->bus->op))
+		return -ENODEV;
+	return urb->dev->bus->op->unlink_urb(urb, -ECONNRESET);
+}
+
+/**
+ * usb_kill_urb - cancel a transfer request and wait for it to finish
+ * @urb: pointer to URB describing a previously submitted request,
+ *	may be NULL
+ *
+ * This routine cancels an in-progress request.  It is guaranteed that
+ * upon return all completion handlers will have finished and the URB
+ * will be totally idle and available for reuse.  These features make
+ * this an ideal way to stop I/O in a disconnect() callback or close()
+ * function.  If the request has not already finished or been unlinked
+ * the completion handler will see urb->status == -ENOENT.
+ *
+ * While the routine is running, attempts to resubmit the URB will fail
+ * with error -EPERM.  Thus even if the URB's completion handler always
+ * tries to resubmit, it will not succeed and the URB will become idle.
+ *
+ * This routine may not be used in an interrupt context (such as a bottom
+ * half or a completion handler), or when holding a spinlock, or in other
+ * situations where the caller can't schedule().
+ */
+void usb_kill_urb(struct urb *urb)
+{
+	if (!(urb && urb->dev && urb->dev->bus && urb->dev->bus->op))
+		return;
+	spin_lock_irq(&urb->lock);
+	++urb->reject;
+	spin_unlock_irq(&urb->lock);
+
+	urb->dev->bus->op->unlink_urb(urb, -ENOENT);
+	wait_event(usb_kill_urb_queue, atomic_read(&urb->use_count) == 0);
+
+	spin_lock_irq(&urb->lock);
+	--urb->reject;
+	spin_unlock_irq(&urb->lock);
+}
+
+EXPORT_SYMBOL(usb_init_urb);
+EXPORT_SYMBOL(usb_alloc_urb);
+EXPORT_SYMBOL(usb_free_urb);
+EXPORT_SYMBOL(usb_get_urb);
+EXPORT_SYMBOL(usb_submit_urb);
+EXPORT_SYMBOL(usb_unlink_urb);
+EXPORT_SYMBOL(usb_kill_urb);
+
