commit 34c7ed72f4f04e73901ca6ec2e1db6c040495935
Author: Marek Szyprowski <m.szyprowski@samsung.com>
Date:   Thu Aug 29 07:30:27 2019 +0200

    usb: core: phy: add support for PHY calibration
    
    Some PHYs (for example Exynos5 USB3.0 DRD PHY) require calibration to be
    done after every USB HCD reset. Generic PHY framework has been already
    extended with phy_calibrate() function in commit 36914111e682 ("drivers:
    phy: add calibrate method"). This patch adds support for it to generic
    PHY handling code in USB HCD core.
    
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Tested-by: Anand Moon <linux.amoon@gmail.com>
    Tested-by: Jochen Sprickerhof <jochen@sprickerhof.de>
    Link: https://lore.kernel.org/r/20190829053028.32438-2-m.szyprowski@samsung.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/phy.c b/drivers/usb/core/phy.c
index 7580493b867a..fb1588e7c282 100644
--- a/drivers/usb/core/phy.c
+++ b/drivers/usb/core/phy.c
@@ -151,6 +151,27 @@ int usb_phy_roothub_set_mode(struct usb_phy_roothub *phy_roothub,
 }
 EXPORT_SYMBOL_GPL(usb_phy_roothub_set_mode);
 
+int usb_phy_roothub_calibrate(struct usb_phy_roothub *phy_roothub)
+{
+	struct usb_phy_roothub *roothub_entry;
+	struct list_head *head;
+	int err;
+
+	if (!phy_roothub)
+		return 0;
+
+	head = &phy_roothub->list;
+
+	list_for_each_entry(roothub_entry, head, list) {
+		err = phy_calibrate(roothub_entry->phy);
+		if (err)
+			return err;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(usb_phy_roothub_calibrate);
+
 int usb_phy_roothub_power_on(struct usb_phy_roothub *phy_roothub)
 {
 	struct usb_phy_roothub *roothub_entry;

commit b97a31348379f7beed7664a8d4eab491e227c165
Author: Miquel Raynal <miquel.raynal@bootlin.com>
Date:   Tue Jan 29 10:23:40 2019 +0100

    usb: core: comply to PHY framework
    
    Current implementation of the USB core does not take into account the
    new PHY framework. Correct the situation by adding a call to
    phy_set_mode() before phy_power_on().
    
    Signed-off-by: Miquel Raynal <miquel.raynal@bootlin.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/phy.c b/drivers/usb/core/phy.c
index 38b2c776c4b4..7580493b867a 100644
--- a/drivers/usb/core/phy.c
+++ b/drivers/usb/core/phy.c
@@ -123,6 +123,34 @@ int usb_phy_roothub_exit(struct usb_phy_roothub *phy_roothub)
 }
 EXPORT_SYMBOL_GPL(usb_phy_roothub_exit);
 
+int usb_phy_roothub_set_mode(struct usb_phy_roothub *phy_roothub,
+			     enum phy_mode mode)
+{
+	struct usb_phy_roothub *roothub_entry;
+	struct list_head *head;
+	int err;
+
+	if (!phy_roothub)
+		return 0;
+
+	head = &phy_roothub->list;
+
+	list_for_each_entry(roothub_entry, head, list) {
+		err = phy_set_mode(roothub_entry->phy, mode);
+		if (err)
+			goto err_out;
+	}
+
+	return 0;
+
+err_out:
+	list_for_each_entry_continue_reverse(roothub_entry, head, list)
+		phy_power_off(roothub_entry->phy);
+
+	return err;
+}
+EXPORT_SYMBOL_GPL(usb_phy_roothub_set_mode);
+
 int usb_phy_roothub_power_on(struct usb_phy_roothub *phy_roothub)
 {
 	struct usb_phy_roothub *roothub_entry;

commit 0a6ab90c0a8fc8ece91ad2bf7e3310ebb563b32b
Author: Chunfeng Yun <chunfeng.yun@mediatek.com>
Date:   Fri Aug 31 18:01:54 2018 +0800

    usb: core: phy: clean up return value check about devm_of_phy_get_by_index()
    
    Use IS_ERR() instead of IS_ERR_OR_NULL() because devm_of_phy_get_by_index()
    never return NULL value;
    But still need ignore the error of -ENODEV, for more information, please
    refer to:
    [0] https://lkml.org/lkml/2018/4/19/88
    [1] https://patchwork.kernel.org/patch/10160181/
    
    Signed-off-by: Chunfeng Yun <chunfeng.yun@mediatek.com>
    Reviewed-by: Johan Hovold <johan@kernel.org>
    Reviewed-by: Martin Blumenstingl <martin.blumenstingl@googlemail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/phy.c b/drivers/usb/core/phy.c
index 9879767452a2..38b2c776c4b4 100644
--- a/drivers/usb/core/phy.c
+++ b/drivers/usb/core/phy.c
@@ -23,10 +23,11 @@ static int usb_phy_roothub_add_phy(struct device *dev, int index,
 				   struct list_head *list)
 {
 	struct usb_phy_roothub *roothub_entry;
-	struct phy *phy = devm_of_phy_get_by_index(dev, dev->of_node, index);
+	struct phy *phy;
 
-	if (IS_ERR_OR_NULL(phy)) {
-		if (!phy || PTR_ERR(phy) == -ENODEV)
+	phy = devm_of_phy_get_by_index(dev, dev->of_node, index);
+	if (IS_ERR(phy)) {
+		if (PTR_ERR(phy) == -ENODEV)
 			return 0;
 		else
 			return PTR_ERR(phy);

commit fec94445db7777c65b0a681b8dc0ed2532304d2a
Author: Martin Blumenstingl <martin.blumenstingl@googlemail.com>
Date:   Wed Apr 18 21:39:49 2018 +0200

    usb: core: phy: make it a no-op if CONFIG_GENERIC_PHY is disabled
    
    If the generic PHY support is disabled the stub of devm_of_phy_get_by_index
    returns ENOSYS. This corner case isn't handled properly by
    usb_phy_roothub_add_phy and at least breaks USB support on Raspberry Pi
    (bcm2835_defconfig):
    
        dwc2 20980000.usb: dwc2_hcd_init() FAILED, returning -38
        dwc2: probe of 20980000.usb failed with error -38
    
    Let usb_phy_roothub_alloc() return in case CONFIG_GENERIC_PHY is
    disabled to fix this issue (compilers might even be smart enough to
    optimize away most of the code within usb_phy_roothub_alloc and
    usb_phy_roothub_add_phy if CONFIG_GENERIC_PHY is disabled). All
    existing usb_phy_roothub_* functions are already NULL-safe, so no
    special handling is required there.
    
    Fixes: 07dbff0ddbd8 ("usb: core: add a wrapper for the USB PHYs on the HCD")
    Reported-by: Stefan Wahren <stefan.wahren@i2se.com>
    Signed-off-by: Martin Blumenstingl <martin.blumenstingl@googlemail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/phy.c b/drivers/usb/core/phy.c
index a39d9bb26a4f..9879767452a2 100644
--- a/drivers/usb/core/phy.c
+++ b/drivers/usb/core/phy.c
@@ -50,6 +50,9 @@ struct usb_phy_roothub *usb_phy_roothub_alloc(struct device *dev)
 	struct usb_phy_roothub *phy_roothub;
 	int i, num_phys, err;
 
+	if (!IS_ENABLED(CONFIG_GENERIC_PHY))
+		return NULL;
+
 	num_phys = of_count_phandle_with_args(dev->of_node, "phys",
 					      "#phy-cells");
 	if (num_phys <= 0)

commit f0e36d478faf37fb26413b2530d04e6b30af3834
Author: Martin Blumenstingl <martin.blumenstingl@googlemail.com>
Date:   Wed Apr 18 21:39:48 2018 +0200

    usb: core: use phy_exit during suspend if wake up is not supported
    
    If the USB controller can wake up the system (which is the case for
    example with the Mediatek USB3 IP) then we must not call phy_exit during
    suspend to ensure that the USB controller doesn't have to re-enumerate
    the devices during resume.
    However, if the USB controller cannot wake up the system (which is the
    case for example on various TI platforms using a dwc3 controller) then
    we must call phy_exit during suspend. Otherwise the PHY driver keeps the
    clocks enabled, which prevents the system from reaching the lowest power
    levels in the suspend state.
    
    Solve this by introducing two new functions in the PHY wrapper which are
    dedicated to the suspend and resume handling.
    If the controller can wake up the system the new usb_phy_roothub_suspend
    function will simply call usb_phy_roothub_power_off. However, if wake up
    is not supported by the controller it will also call
    usb_phy_roothub_exit.
    The also new usb_phy_roothub_resume function takes care of calling
    usb_phy_roothub_init (if the controller can't wake up the system) in
    addition to usb_phy_roothub_power_on.
    
    Fixes: 07dbff0ddbd86c ("usb: core: add a wrapper for the USB PHYs on the HCD")
    Fixes: 178a0bce05cbc1 ("usb: core: hcd: integrate the PHY wrapper into the HCD core")
    Reported-by: Roger Quadros <rogerq@ti.com>
    Suggested-by: Roger Quadros <rogerq@ti.com>
    Suggested-by: Chunfeng Yun <chunfeng.yun@mediatek.com>
    Signed-off-by: Martin Blumenstingl <martin.blumenstingl@googlemail.com>
    Tested-by: Chunfeng Yun <chunfeng.yun@mediatek.com>
    Reviewed-by: Roger Quadros <rogerq@ti.com>
    Tested-by: Keerthy <j-keerthy@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/phy.c b/drivers/usb/core/phy.c
index 44f008cda7a8..a39d9bb26a4f 100644
--- a/drivers/usb/core/phy.c
+++ b/drivers/usb/core/phy.c
@@ -157,3 +157,38 @@ void usb_phy_roothub_power_off(struct usb_phy_roothub *phy_roothub)
 		phy_power_off(roothub_entry->phy);
 }
 EXPORT_SYMBOL_GPL(usb_phy_roothub_power_off);
+
+int usb_phy_roothub_suspend(struct device *controller_dev,
+			    struct usb_phy_roothub *phy_roothub)
+{
+	usb_phy_roothub_power_off(phy_roothub);
+
+	/* keep the PHYs initialized so the device can wake up the system */
+	if (device_may_wakeup(controller_dev))
+		return 0;
+
+	return usb_phy_roothub_exit(phy_roothub);
+}
+EXPORT_SYMBOL_GPL(usb_phy_roothub_suspend);
+
+int usb_phy_roothub_resume(struct device *controller_dev,
+			   struct usb_phy_roothub *phy_roothub)
+{
+	int err;
+
+	/* if the device can't wake up the system _exit was called */
+	if (!device_may_wakeup(controller_dev)) {
+		err = usb_phy_roothub_init(phy_roothub);
+		if (err)
+			return err;
+	}
+
+	err = usb_phy_roothub_power_on(phy_roothub);
+
+	/* undo _init if _power_on failed */
+	if (err && !device_may_wakeup(controller_dev))
+		usb_phy_roothub_exit(phy_roothub);
+
+	return err;
+}
+EXPORT_SYMBOL_GPL(usb_phy_roothub_resume);

commit 63cb03f5c11eef2c08b5812f4533ba87cf778fa8
Author: Martin Blumenstingl <martin.blumenstingl@googlemail.com>
Date:   Wed Apr 18 21:39:47 2018 +0200

    usb: core: split usb_phy_roothub_{init,alloc}
    
    Before this patch usb_phy_roothub_init served two purposes (from a
    caller's point of view - like hcd.c):
    - parsing the PHYs and allocating the list entries
    - calling phy_init on each list entry
    
    While this worked so far it has one disadvantage: if we need to call
    phy_init for each PHY instance then the existing code cannot be re-used.
    Solve this by splitting off usb_phy_roothub_alloc which only parses the
    PHYs and allocates the list entries.
    usb_phy_roothub_init then gets a struct usb_phy_roothub and only calls
    phy_init on each PHY instance (along with the corresponding cleanup if
    that failed somewhere).
    
    This is a preparation step for adding proper suspend support for some
    hardware that requires phy_exit to be called during suspend and phy_init
    to be called during resume.
    
    Signed-off-by: Martin Blumenstingl <martin.blumenstingl@googlemail.com>
    Tested-by: Chunfeng Yun <chunfeng.yun@mediatek.com>
    Reviewed-by: Roger Quadros <rogerq@ti.com>
    Tested-by: Keerthy <j-keerthy@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/phy.c b/drivers/usb/core/phy.c
index f19aaa3c899c..44f008cda7a8 100644
--- a/drivers/usb/core/phy.c
+++ b/drivers/usb/core/phy.c
@@ -19,19 +19,6 @@ struct usb_phy_roothub {
 	struct list_head	list;
 };
 
-static struct usb_phy_roothub *usb_phy_roothub_alloc(struct device *dev)
-{
-	struct usb_phy_roothub *roothub_entry;
-
-	roothub_entry = devm_kzalloc(dev, sizeof(*roothub_entry), GFP_KERNEL);
-	if (!roothub_entry)
-		return ERR_PTR(-ENOMEM);
-
-	INIT_LIST_HEAD(&roothub_entry->list);
-
-	return roothub_entry;
-}
-
 static int usb_phy_roothub_add_phy(struct device *dev, int index,
 				   struct list_head *list)
 {
@@ -45,9 +32,11 @@ static int usb_phy_roothub_add_phy(struct device *dev, int index,
 			return PTR_ERR(phy);
 	}
 
-	roothub_entry = usb_phy_roothub_alloc(dev);
-	if (IS_ERR(roothub_entry))
-		return PTR_ERR(roothub_entry);
+	roothub_entry = devm_kzalloc(dev, sizeof(*roothub_entry), GFP_KERNEL);
+	if (!roothub_entry)
+		return -ENOMEM;
+
+	INIT_LIST_HEAD(&roothub_entry->list);
 
 	roothub_entry->phy = phy;
 
@@ -56,11 +45,9 @@ static int usb_phy_roothub_add_phy(struct device *dev, int index,
 	return 0;
 }
 
-struct usb_phy_roothub *usb_phy_roothub_init(struct device *dev)
+struct usb_phy_roothub *usb_phy_roothub_alloc(struct device *dev)
 {
 	struct usb_phy_roothub *phy_roothub;
-	struct usb_phy_roothub *roothub_entry;
-	struct list_head *head;
 	int i, num_phys, err;
 
 	num_phys = of_count_phandle_with_args(dev->of_node, "phys",
@@ -68,16 +55,31 @@ struct usb_phy_roothub *usb_phy_roothub_init(struct device *dev)
 	if (num_phys <= 0)
 		return NULL;
 
-	phy_roothub = usb_phy_roothub_alloc(dev);
-	if (IS_ERR(phy_roothub))
-		return phy_roothub;
+	phy_roothub = devm_kzalloc(dev, sizeof(*phy_roothub), GFP_KERNEL);
+	if (!phy_roothub)
+		return ERR_PTR(-ENOMEM);
+
+	INIT_LIST_HEAD(&phy_roothub->list);
 
 	for (i = 0; i < num_phys; i++) {
 		err = usb_phy_roothub_add_phy(dev, i, &phy_roothub->list);
 		if (err)
-			goto err_out;
+			return ERR_PTR(err);
 	}
 
+	return phy_roothub;
+}
+EXPORT_SYMBOL_GPL(usb_phy_roothub_alloc);
+
+int usb_phy_roothub_init(struct usb_phy_roothub *phy_roothub)
+{
+	struct usb_phy_roothub *roothub_entry;
+	struct list_head *head;
+	int err;
+
+	if (!phy_roothub)
+		return 0;
+
 	head = &phy_roothub->list;
 
 	list_for_each_entry(roothub_entry, head, list) {
@@ -86,14 +88,13 @@ struct usb_phy_roothub *usb_phy_roothub_init(struct device *dev)
 			goto err_exit_phys;
 	}
 
-	return phy_roothub;
+	return 0;
 
 err_exit_phys:
 	list_for_each_entry_continue_reverse(roothub_entry, head, list)
 		phy_exit(roothub_entry->phy);
 
-err_out:
-	return ERR_PTR(err);
+	return err;
 }
 EXPORT_SYMBOL_GPL(usb_phy_roothub_init);
 

commit dd40438fc6be7454c906093fe2a1b69ca98946fb
Author: Martin Blumenstingl <martin.blumenstingl@googlemail.com>
Date:   Wed Apr 18 21:39:46 2018 +0200

    usb: core: phy: fix return value of usb_phy_roothub_exit()
    
    usb_phy_roothub_exit() should return the error code from the phy_exit()
    call if exiting the PHY failed.
    However, since a wrong variable is used usb_phy_roothub_exit() currently
    always returns 0, even if one of the phy_exit calls returned an error.
    Clang also reports this bug:
    kernel/drivers/usb/core/phy.c:114:8: warning: explicitly assigning value of
    variable of type 'int' to itself [-Wself-assign] error, forbidden
    warning: phy.c:114
    
    Fix this by assigning the error code from phy_exit() to the "ret"
    variable to propagate the error correctly.
    
    Fixes: 07dbff0ddbd86c ("usb: core: add a wrapper for the USB PHYs on the HCD")
    Signed-off-by: Martin Blumenstingl <martin.blumenstingl@googlemail.com>
    Signed-off-by: Rishabh Bhatnagar <rishabhb@codeaurora.org>
    Tested-by: Keerthy <j-keerthy@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/phy.c b/drivers/usb/core/phy.c
index 09b7c43c0ea4..f19aaa3c899c 100644
--- a/drivers/usb/core/phy.c
+++ b/drivers/usb/core/phy.c
@@ -111,7 +111,7 @@ int usb_phy_roothub_exit(struct usb_phy_roothub *phy_roothub)
 	list_for_each_entry(roothub_entry, head, list) {
 		err = phy_exit(roothub_entry->phy);
 		if (err)
-			ret = ret;
+			ret = err;
 	}
 
 	return ret;

commit 07dbff0ddbd86c08c42088e9f996c2650095d684
Author: Martin Blumenstingl <martin.blumenstingl@googlemail.com>
Date:   Sat Mar 3 22:43:04 2018 +0100

    usb: core: add a wrapper for the USB PHYs on the HCD
    
    Many SoC platforms have separate devices for the USB PHY which are
    registered through the generic PHY framework. These PHYs have to be
    enabled to make the USB controller actually work. They also have to be
    disabled again on shutdown/suspend.
    
    Currently (at least) the following HCI platform drivers are using custom
    code to obtain all PHYs via devicetree for the roothub/controller and
    disable/enable them when required:
    - ehci-platform.c has ehci_platform_power_{on,off}
    - xhci-mtk.c has xhci_mtk_phy_{init,exit,power_on,power_off}
    - ohci-platform.c has ohci_platform_power_{on,off}
    
    With this new wrapper the USB PHYs can be specified directly in the
    USB controller's devicetree node (just like on the drivers listed
    above). This allows SoCs like the Amlogic Meson GXL family to operate
    correctly once this is wired up correctly. These SoCs use a dwc3
    controller and require all USB PHYs to be initialized (if one of the USB
    PHYs it not initialized then none of USB port works at all).
    
    Signed-off-by: Martin Blumenstingl <martin.blumenstingl@googlemail.com>
    Tested-by: Yixun Lan <yixun.lan@amlogic.com>
    Cc: Chunfeng Yun <chunfeng.yun@mediatek.com>
    Tested-by: Neil Armstrong <narmstrong@baylibre.con>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/phy.c b/drivers/usb/core/phy.c
new file mode 100644
index 000000000000..09b7c43c0ea4
--- /dev/null
+++ b/drivers/usb/core/phy.c
@@ -0,0 +1,158 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * A wrapper for multiple PHYs which passes all phy_* function calls to
+ * multiple (actual) PHY devices. This is comes handy when initializing
+ * all PHYs on a HCD and to keep them all in the same state.
+ *
+ * Copyright (C) 2018 Martin Blumenstingl <martin.blumenstingl@googlemail.com>
+ */
+
+#include <linux/device.h>
+#include <linux/list.h>
+#include <linux/phy/phy.h>
+#include <linux/of.h>
+
+#include "phy.h"
+
+struct usb_phy_roothub {
+	struct phy		*phy;
+	struct list_head	list;
+};
+
+static struct usb_phy_roothub *usb_phy_roothub_alloc(struct device *dev)
+{
+	struct usb_phy_roothub *roothub_entry;
+
+	roothub_entry = devm_kzalloc(dev, sizeof(*roothub_entry), GFP_KERNEL);
+	if (!roothub_entry)
+		return ERR_PTR(-ENOMEM);
+
+	INIT_LIST_HEAD(&roothub_entry->list);
+
+	return roothub_entry;
+}
+
+static int usb_phy_roothub_add_phy(struct device *dev, int index,
+				   struct list_head *list)
+{
+	struct usb_phy_roothub *roothub_entry;
+	struct phy *phy = devm_of_phy_get_by_index(dev, dev->of_node, index);
+
+	if (IS_ERR_OR_NULL(phy)) {
+		if (!phy || PTR_ERR(phy) == -ENODEV)
+			return 0;
+		else
+			return PTR_ERR(phy);
+	}
+
+	roothub_entry = usb_phy_roothub_alloc(dev);
+	if (IS_ERR(roothub_entry))
+		return PTR_ERR(roothub_entry);
+
+	roothub_entry->phy = phy;
+
+	list_add_tail(&roothub_entry->list, list);
+
+	return 0;
+}
+
+struct usb_phy_roothub *usb_phy_roothub_init(struct device *dev)
+{
+	struct usb_phy_roothub *phy_roothub;
+	struct usb_phy_roothub *roothub_entry;
+	struct list_head *head;
+	int i, num_phys, err;
+
+	num_phys = of_count_phandle_with_args(dev->of_node, "phys",
+					      "#phy-cells");
+	if (num_phys <= 0)
+		return NULL;
+
+	phy_roothub = usb_phy_roothub_alloc(dev);
+	if (IS_ERR(phy_roothub))
+		return phy_roothub;
+
+	for (i = 0; i < num_phys; i++) {
+		err = usb_phy_roothub_add_phy(dev, i, &phy_roothub->list);
+		if (err)
+			goto err_out;
+	}
+
+	head = &phy_roothub->list;
+
+	list_for_each_entry(roothub_entry, head, list) {
+		err = phy_init(roothub_entry->phy);
+		if (err)
+			goto err_exit_phys;
+	}
+
+	return phy_roothub;
+
+err_exit_phys:
+	list_for_each_entry_continue_reverse(roothub_entry, head, list)
+		phy_exit(roothub_entry->phy);
+
+err_out:
+	return ERR_PTR(err);
+}
+EXPORT_SYMBOL_GPL(usb_phy_roothub_init);
+
+int usb_phy_roothub_exit(struct usb_phy_roothub *phy_roothub)
+{
+	struct usb_phy_roothub *roothub_entry;
+	struct list_head *head;
+	int err, ret = 0;
+
+	if (!phy_roothub)
+		return 0;
+
+	head = &phy_roothub->list;
+
+	list_for_each_entry(roothub_entry, head, list) {
+		err = phy_exit(roothub_entry->phy);
+		if (err)
+			ret = ret;
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(usb_phy_roothub_exit);
+
+int usb_phy_roothub_power_on(struct usb_phy_roothub *phy_roothub)
+{
+	struct usb_phy_roothub *roothub_entry;
+	struct list_head *head;
+	int err;
+
+	if (!phy_roothub)
+		return 0;
+
+	head = &phy_roothub->list;
+
+	list_for_each_entry(roothub_entry, head, list) {
+		err = phy_power_on(roothub_entry->phy);
+		if (err)
+			goto err_out;
+	}
+
+	return 0;
+
+err_out:
+	list_for_each_entry_continue_reverse(roothub_entry, head, list)
+		phy_power_off(roothub_entry->phy);
+
+	return err;
+}
+EXPORT_SYMBOL_GPL(usb_phy_roothub_power_on);
+
+void usb_phy_roothub_power_off(struct usb_phy_roothub *phy_roothub)
+{
+	struct usb_phy_roothub *roothub_entry;
+
+	if (!phy_roothub)
+		return;
+
+	list_for_each_entry_reverse(roothub_entry, &phy_roothub->list, list)
+		phy_power_off(roothub_entry->phy);
+}
+EXPORT_SYMBOL_GPL(usb_phy_roothub_power_off);
