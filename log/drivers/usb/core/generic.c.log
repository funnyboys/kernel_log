commit 77419aa403ca1395f66e1e3de87743f54ba144b6
Author: Bastien Nocera <hadess@hadess.net>
Date:   Wed Oct 16 11:39:32 2019 +0200

    USB: Fallback to generic driver when specific driver fails
    
    If ->probe fails for a device specific driver, ask the driver core to
    reprobe us, after having flagged the device for the generic driver to be
    forced.
    
    Signed-off-by: Bastien Nocera <hadess@hadess.net>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Link: https://lore.kernel.org/r/20191016093933.693-6-hadess@hadess.net
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/generic.c b/drivers/usb/core/generic.c
index 84da85c13825..4626227a6dd2 100644
--- a/drivers/usb/core/generic.c
+++ b/drivers/usb/core/generic.c
@@ -213,6 +213,9 @@ static int __check_usb_generic(struct device_driver *drv, void *data)
 
 static bool usb_generic_driver_match(struct usb_device *udev)
 {
+	if (udev->use_generic_driver)
+		return true;
+
 	/*
 	 * If any other driver wants the device, leave the device to this other
 	 * driver.

commit 88b7381a939de0fa1f1b1629c56b03dca7077309
Author: Bastien Nocera <hadess@hadess.net>
Date:   Wed Oct 16 11:39:31 2019 +0200

    USB: Select better matching USB drivers when available
    
    Now that USB device drivers can reuse code from the generic USB device
    driver, we need to make sure that they get selected rather than the
    generic driver. Add an id_table and match vfunc to the usb_device_driver
    struct, which will get used to select a better matching driver at
    ->probe time.
    
    This is a similar mechanism to that used in the HID drivers, with the
    generic driver being selected unless there's a better matching one found
    in the registered drivers (see hid_generic_match() in
    drivers/hid/hid-generic.c).
    
    Signed-off-by: Bastien Nocera <hadess@hadess.net>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Link: https://lore.kernel.org/r/20191016093933.693-5-hadess@hadess.net
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/generic.c b/drivers/usb/core/generic.c
index 28ece4d77749..84da85c13825 100644
--- a/drivers/usb/core/generic.c
+++ b/drivers/usb/core/generic.c
@@ -195,6 +195,34 @@ int usb_choose_configuration(struct usb_device *udev)
 }
 EXPORT_SYMBOL_GPL(usb_choose_configuration);
 
+static int __check_usb_generic(struct device_driver *drv, void *data)
+{
+	struct usb_device *udev = data;
+	struct usb_device_driver *udrv;
+
+	if (!is_usb_device_driver(drv))
+		return 0;
+	udrv = to_usb_device_driver(drv);
+	if (udrv == &usb_generic_driver)
+		return 0;
+	if (!udrv->id_table)
+		return 0;
+
+	return usb_device_match_id(udev, udrv->id_table) != NULL;
+}
+
+static bool usb_generic_driver_match(struct usb_device *udev)
+{
+	/*
+	 * If any other driver wants the device, leave the device to this other
+	 * driver.
+	 */
+	if (bus_for_each_drv(&usb_bus_type, NULL, udev, __check_usb_generic))
+		return false;
+
+	return true;
+}
+
 int usb_generic_driver_probe(struct usb_device *udev)
 {
 	int err, c;
@@ -285,6 +313,7 @@ int usb_generic_driver_resume(struct usb_device *udev, pm_message_t msg)
 
 struct usb_device_driver usb_generic_driver = {
 	.name =	"usb",
+	.match = usb_generic_driver_match,
 	.probe = usb_generic_driver_probe,
 	.disconnect = usb_generic_driver_disconnect,
 #ifdef	CONFIG_PM

commit ef0f7d1877ac21fd926f2349e6a025c201651cf7
Author: Bastien Nocera <hadess@hadess.net>
Date:   Wed Oct 16 11:39:28 2019 +0200

    USB: Export generic USB device driver functions
    
    This will make it possible to implement device drivers which extend the
    generic driver without needing to reimplement it.
    
    Signed-off-by: Bastien Nocera <hadess@hadess.net>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Link: https://lore.kernel.org/r/20191016093933.693-2-hadess@hadess.net
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/generic.c b/drivers/usb/core/generic.c
index 38f8b3e31762..28ece4d77749 100644
--- a/drivers/usb/core/generic.c
+++ b/drivers/usb/core/generic.c
@@ -195,7 +195,7 @@ int usb_choose_configuration(struct usb_device *udev)
 }
 EXPORT_SYMBOL_GPL(usb_choose_configuration);
 
-static int generic_probe(struct usb_device *udev)
+int usb_generic_driver_probe(struct usb_device *udev)
 {
 	int err, c;
 
@@ -222,7 +222,7 @@ static int generic_probe(struct usb_device *udev)
 	return 0;
 }
 
-static void generic_disconnect(struct usb_device *udev)
+void usb_generic_driver_disconnect(struct usb_device *udev)
 {
 	usb_notify_remove_device(udev);
 
@@ -234,7 +234,7 @@ static void generic_disconnect(struct usb_device *udev)
 
 #ifdef	CONFIG_PM
 
-static int generic_suspend(struct usb_device *udev, pm_message_t msg)
+int usb_generic_driver_suspend(struct usb_device *udev, pm_message_t msg)
 {
 	int rc;
 
@@ -262,7 +262,7 @@ static int generic_suspend(struct usb_device *udev, pm_message_t msg)
 	return rc;
 }
 
-static int generic_resume(struct usb_device *udev, pm_message_t msg)
+int usb_generic_driver_resume(struct usb_device *udev, pm_message_t msg)
 {
 	int rc;
 
@@ -285,11 +285,11 @@ static int generic_resume(struct usb_device *udev, pm_message_t msg)
 
 struct usb_device_driver usb_generic_driver = {
 	.name =	"usb",
-	.probe = generic_probe,
-	.disconnect = generic_disconnect,
+	.probe = usb_generic_driver_probe,
+	.disconnect = usb_generic_driver_disconnect,
 #ifdef	CONFIG_PM
-	.suspend = generic_suspend,
-	.resume = generic_resume,
+	.suspend = usb_generic_driver_suspend,
+	.resume = usb_generic_driver_resume,
 #endif
 	.supports_autosuspend = 1,
 };

commit 7794f486ed0b1fa8022dd0a27b9babf86a46d1cf
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Aug 7 10:29:50 2019 -0400

    usbfs: Add ioctls for runtime power management
    
    It has been requested that usbfs should implement runtime power
    management, instead of forcing the device to remain at full power as
    long as the device file is open.  This patch introduces that new
    feature.
    
    It does so by adding three new usbfs ioctls:
    
            USBDEVFS_FORBID_SUSPEND: Prevents the device from going into
            runtime suspend (and causes a resume if the device is already
            suspended).
    
            USBDEVFS_ALLOW_SUSPEND: Allows the device to go into runtime
            suspend.  Some time may elapse before the device actually is
            suspended, depending on things like the autosuspend delay.
    
            USBDEVFS_WAIT_FOR_RESUME: Blocks until the call is interrupted
            by a signal or at least one runtime resume has occurred since
            the most recent ALLOW_SUSPEND ioctl call (which may mean
            immediately, even if the device is currently suspended).  In
            the latter case, the device is prevented from suspending again
            just as if FORBID_SUSPEND was called before the ioctl returns.
    
    For backward compatibility, when the device file is first opened
    runtime suspends are forbidden.  The userspace program can then allow
    suspends whenever it wants, and either resume the device directly (by
    forbidding suspends again) or wait for a resume from some other source
    (such as a remote wakeup).  URBs submitted to a suspended device will
    fail or will complete with an appropriate error code.
    
    This combination of ioctls is sufficient for user programs to have
    nearly the same degree of control over a device's runtime power
    behavior as kernel drivers do.
    
    Still lacking is documentation for the new ioctls.  I intend to add it
    later, after the existing documentation for the usbfs userspace API is
    straightened out into a reasonable form.
    
    Suggested-by: Mayuresh Kulkarni <mkulkarni@opensource.cirrus.com>
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    
    Link: https://lore.kernel.org/r/Pine.LNX.4.44L0.1908071013220.1514-100000@iolanthe.rowland.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/generic.c b/drivers/usb/core/generic.c
index 1ac9c1e5f773..38f8b3e31762 100644
--- a/drivers/usb/core/generic.c
+++ b/drivers/usb/core/generic.c
@@ -257,6 +257,8 @@ static int generic_suspend(struct usb_device *udev, pm_message_t msg)
 	else
 		rc = usb_port_suspend(udev, msg);
 
+	if (rc == 0)
+		usbfs_notify_suspend(udev);
 	return rc;
 }
 
@@ -273,6 +275,9 @@ static int generic_resume(struct usb_device *udev, pm_message_t msg)
 		rc = hcd_bus_resume(udev, msg);
 	else
 		rc = usb_port_resume(udev, msg);
+
+	if (rc == 0)
+		usbfs_notify_resume(udev);
 	return rc;
 }
 

commit 25b0161450363ed7fe9fe618cda202e15817311a
Author: Nikolay Yakimov <root@livid.pp.ru>
Date:   Tue Jan 15 19:13:54 2019 +0300

    USB: Fix configuration selection issues introduced in v4.20.0
    
    Commit f13912d3f014a introduced changes to the usb_choose_configuration function
    to better support USB Audio UAC3-compatible devices. However, there are a few
    problems with this patch. First of all, it adds new "if" clauses in the middle
    of an existing "if"/"else if" tree, which obviously breaks pre-existing logic.
    Secondly, since it continues iterating over configurations in one of the branches,
    other code in the loop can choose an unintended configuration. Finally,
    if an audio device's first configuration is UAC3-compatible, and there
    are multiple UAC3 configurations, the second one would be chosen, due to
    the first configuration never being checked for UAC3-compatibility.
    
    Commit ff2a8c532c14 tries to fix the second issue, but it goes about it in a
    somewhat unnecessarily convoluted way, in my opinion, and does nothing
    to fix the first or the last one.
    
    This patch tries to rectify problems described by essentially rewriting
    code introduced in f13912d3f014a. Notice the code was moved to *before*
    the "if"/"else if" tree.
    
    Signed-off-by: Nikolay Yakimov <root@livid.pp.ru>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/generic.c b/drivers/usb/core/generic.c
index f713cecc1f41..1ac9c1e5f773 100644
--- a/drivers/usb/core/generic.c
+++ b/drivers/usb/core/generic.c
@@ -118,6 +118,31 @@ int usb_choose_configuration(struct usb_device *udev)
 			continue;
 		}
 
+		/*
+		 * Select first configuration as default for audio so that
+		 * devices that don't comply with UAC3 protocol are supported.
+		 * But, still iterate through other configurations and
+		 * select UAC3 compliant config if present.
+		 */
+		if (desc && is_audio(desc)) {
+			/* Always prefer the first found UAC3 config */
+			if (is_uac3_config(desc)) {
+				best = c;
+				break;
+			}
+
+			/* If there is no UAC3 config, prefer the first config */
+			else if (i == 0)
+				best = c;
+
+			/* Unconditional continue, because the rest of the code
+			 * in the loop is irrelevant for audio devices, and
+			 * because it can reassign best, which for audio devices
+			 * we don't want.
+			 */
+			continue;
+		}
+
 		/* When the first config's first interface is one of Microsoft's
 		 * pet nonstandard Ethernet-over-USB protocols, ignore it unless
 		 * this kernel has enabled the necessary host side driver.
@@ -132,25 +157,6 @@ int usb_choose_configuration(struct usb_device *udev)
 #endif
 		}
 
-		/*
-		 * Select first configuration as default for audio so that
-		 * devices that don't comply with UAC3 protocol are supported.
-		 * But, still iterate through other configurations and
-		 * select UAC3 compliant config if present.
-		 */
-		if (i == 0 && num_configs > 1 && desc && is_audio(desc)) {
-			best = c;
-			continue;
-		}
-
-		if (i > 0 && desc && is_audio(desc)) {
-			if (is_uac3_config(desc)) {
-				best = c;
-				break;
-			}
-			continue;
-		}
-
 		/* From the remaining configs, choose the first one whose
 		 * first interface is for a non-vendor-specific class.
 		 * Reason: Linux is more likely to have a class driver

commit ff2a8c532c14fd22fb26a36574d9ff199afbbe54
Author: Saranya Gopal <saranya.gopal@intel.com>
Date:   Sun Jan 6 08:14:02 2019 +0530

    usbcore: Select only first configuration for non-UAC3 compliant devices
    
    In most of the UAC1 and UAC2 audio devices, the first
    configuration is most often the best configuration.
    However, with recent patch to support UAC3 configuration,
    second configuration was unintentionally chosen for
    some of the UAC1/2 devices that had more than one
    configuration. This was because of the existing check
    after the audio config check which selected any config
    which had a non-vendor class. This patch fixes this issue.
    
    Fixes: f13912d3f014 ("usbcore: Select UAC3 configuration for audio if present")
    Reported-by: Con Kolivas <kernel@kolivas.org>
    Signed-off-by: Saranya Gopal <saranya.gopal@intel.com>
    Tested-by: Con Kolivas <kernel@kolivas.org>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/generic.c b/drivers/usb/core/generic.c
index 356b05c82dbc..f713cecc1f41 100644
--- a/drivers/usb/core/generic.c
+++ b/drivers/usb/core/generic.c
@@ -143,9 +143,12 @@ int usb_choose_configuration(struct usb_device *udev)
 			continue;
 		}
 
-		if (i > 0 && desc && is_audio(desc) && is_uac3_config(desc)) {
-			best = c;
-			break;
+		if (i > 0 && desc && is_audio(desc)) {
+			if (is_uac3_config(desc)) {
+				best = c;
+				break;
+			}
+			continue;
 		}
 
 		/* From the remaining configs, choose the first one whose

commit f13912d3f014a7f2fa5c35d25ee8c3f96bda6272
Author: Saranya Gopal <saranya.gopal@intel.com>
Date:   Wed Sep 12 08:46:26 2018 +0530

    usbcore: Select UAC3 configuration for audio if present
    
    USB audio class 3.0 specification introduced many significant
    changes like
     - new power domains, support for LPM/L1
     - new cluster descriptor
     - new high capability and class-specific string descriptors
     - BADD profiles
     - ... and many other things (check spec from link below:
    http://www.usb.org/developers/docs/devclass_docs/USB_Audio_v3.0.zip)
    
    Now that UAC3 is supported in linux, choose UAC3
    configuration for audio if the device supports it.
    Selecting this configuration will enable the system to
    save power by leveraging the new power domains and LPM L1
    capability and also support new codec types and data formats
    for consumer audio applications.
    
    Signed-off-by: Saranya Gopal <saranya.gopal@intel.com>
    Reviewed-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/generic.c b/drivers/usb/core/generic.c
index bc8242bc4564..356b05c82dbc 100644
--- a/drivers/usb/core/generic.c
+++ b/drivers/usb/core/generic.c
@@ -21,6 +21,7 @@
 
 #include <linux/usb.h>
 #include <linux/usb/hcd.h>
+#include <uapi/linux/usb/audio.h>
 #include "usb.h"
 
 static inline const char *plural(int n)
@@ -42,6 +43,16 @@ static int is_activesync(struct usb_interface_descriptor *desc)
 		&& desc->bInterfaceProtocol == 1;
 }
 
+static bool is_audio(struct usb_interface_descriptor *desc)
+{
+	return desc->bInterfaceClass == USB_CLASS_AUDIO;
+}
+
+static bool is_uac3_config(struct usb_interface_descriptor *desc)
+{
+	return desc->bInterfaceProtocol == UAC_VERSION_3;
+}
+
 int usb_choose_configuration(struct usb_device *udev)
 {
 	int i;
@@ -121,6 +132,22 @@ int usb_choose_configuration(struct usb_device *udev)
 #endif
 		}
 
+		/*
+		 * Select first configuration as default for audio so that
+		 * devices that don't comply with UAC3 protocol are supported.
+		 * But, still iterate through other configurations and
+		 * select UAC3 compliant config if present.
+		 */
+		if (i == 0 && num_configs > 1 && desc && is_audio(desc)) {
+			best = c;
+			continue;
+		}
+
+		if (i > 0 && desc && is_audio(desc) && is_uac3_config(desc)) {
+			best = c;
+			break;
+		}
+
 		/* From the remaining configs, choose the first one whose
 		 * first interface is for a non-vendor-specific class.
 		 * Reason: Linux is more likely to have a class driver

commit 64627388b50158fd24d6ad88132525b95a5ef573
Author: Zhengjun Xing <zhengjun.xing@linux.intel.com>
Date:   Wed Mar 21 13:29:42 2018 +0800

    USB:fix USB3 devices behind USB3 hubs not resuming at hibernate thaw
    
    USB3 hubs don't support global suspend.
    
    USB3 specification 10.10, Enhanced SuperSpeed hubs only support selective
    suspend and resume, they do not support global suspend/resume where the
    hub downstream facing ports states are not affected.
    
    When system enters hibernation it first enters freeze process where only
    the root hub enters suspend, usb_port_suspend() is not called for other
    devices, and suspend status flags are not set for them. Other devices are
    expected to suspend globally. Some external USB3 hubs will suspend the
    downstream facing port at global suspend. These devices won't be resumed
    at thaw as the suspend status flag is not set.
    
    A USB3 removable hard disk connected through a USB3 hub that won't resume
    at thaw will fail to synchronize SCSI cache, return “cmd cmplt err -71”
    error, and needs a 60 seconds timeout which causing system hang for 60s
    before the USB host reset the port for the USB3 removable hard disk to
    recover.
    
    Fix this by always calling usb_port_suspend() during freeze for USB3
    devices.
    
    Signed-off-by: Zhengjun Xing <zhengjun.xing@linux.intel.com>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/generic.c b/drivers/usb/core/generic.c
index 83c14dda6300..bc8242bc4564 100644
--- a/drivers/usb/core/generic.c
+++ b/drivers/usb/core/generic.c
@@ -210,8 +210,13 @@ static int generic_suspend(struct usb_device *udev, pm_message_t msg)
 	if (!udev->parent)
 		rc = hcd_bus_suspend(udev, msg);
 
-	/* Non-root devices don't need to do anything for FREEZE or PRETHAW */
-	else if (msg.event == PM_EVENT_FREEZE || msg.event == PM_EVENT_PRETHAW)
+	/*
+	 * Non-root USB2 devices don't need to do anything for FREEZE
+	 * or PRETHAW. USB3 devices don't support global suspend and
+	 * needs to be selectively suspended.
+	 */
+	else if ((msg.event == PM_EVENT_FREEZE || msg.event == PM_EVENT_PRETHAW)
+		 && (udev->speed < USB_SPEED_SUPER))
 		rc = 0;
 	else
 		rc = usb_port_suspend(udev, msg);

commit aa1f3bb56761cf627ed53a40607bead16d6e23bc
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Nov 3 09:18:41 2017 +0100

    USB: core: move existing SPDX tags to top of the file
    
    To match the rest of the kernel, the SPDX tags for the drivers/usb/core/
    files are moved to the first line of the file.  This makes it more
    obvious the tag is present as well as making it match the other 12k
    files in the tree with this location.
    
    It also uses // to match the "expected style" as well.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/generic.c b/drivers/usb/core/generic.c
index bd3e0c5a6db2..83c14dda6300 100644
--- a/drivers/usb/core/generic.c
+++ b/drivers/usb/core/generic.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * drivers/usb/generic.c - generic driver for USB devices (not interfaces)
  *
@@ -16,7 +17,6 @@
  *	(C) Copyright Greg Kroah-Hartman 2002-2003
  *
  * Released under the GPLv2 only.
- * SPDX-License-Identifier: GPL-2.0
  */
 
 #include <linux/usb.h>

commit b65fba3d87216bfe6ae9bc77be5eb6eabb6514a4
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Oct 28 17:16:36 2016 -0400

    USB: core: add missing license information to some files
    
    Some of the USB core files were missing explicit license information.
    As all files in the kernel tree are implicitly licensed under the
    GPLv2-only, be explicit in case someone get confused looking at
    individual files by using the SPDX nomenclature.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/generic.c b/drivers/usb/core/generic.c
index 358ca8dd784f..bd3e0c5a6db2 100644
--- a/drivers/usb/core/generic.c
+++ b/drivers/usb/core/generic.c
@@ -15,6 +15,8 @@
  *		(usb_device_id matching changes by Adam J. Richter)
  *	(C) Copyright Greg Kroah-Hartman 2002-2003
  *
+ * Released under the GPLv2 only.
+ * SPDX-License-Identifier: GPL-2.0
  */
 
 #include <linux/usb.h>

commit b7945b77cd03094458f3624bc82a27e0d36e75d0
Author: Valentina Manea <valentina.manea.m@gmail.com>
Date:   Thu Jan 23 23:12:29 2014 +0200

    staging: usbip: convert usbip-host driver to usb_device_driver
    
    This driver was previously an interface driver. Since USB/IP
    exports a whole device, not just an interface, it would make
    sense to be a device driver.
    
    This patch also modifies the way userspace sees and uses a
    shared device:
    
    * the usbip_status file is no longer created for interface 0, but for
    the whole device (such as
    /sys/devices/pci0000:00/0000:00:01.2/usb1/1-1/usbip_status).
    * per interface information, such as interface class or protocol, is
    no longer sent/received; only device specific information is
    transmitted.
    * since the driver was moved one level below in the USB architecture,
    there is no need to bind/unbind each interface, just the device as a
    whole.
    
    Signed-off-by: Valentina Manea <valentina.manea.m@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/generic.c b/drivers/usb/core/generic.c
index acbfeb0a0119..358ca8dd784f 100644
--- a/drivers/usb/core/generic.c
+++ b/drivers/usb/core/generic.c
@@ -155,6 +155,7 @@ int usb_choose_configuration(struct usb_device *udev)
 	}
 	return i;
 }
+EXPORT_SYMBOL_GPL(usb_choose_configuration);
 
 static int generic_probe(struct usb_device *udev)
 {

commit e9e88fb7bca9f527ccdf4166a240a9023ba6ee73
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Mar 27 16:14:01 2013 -0400

    USB: avoid error messages when a device is disconnected
    
    This patch (as1673) reduces the amount of log spew from the hub driver
    by removing a bunch of error messages in the case where the device in
    question is already known to have been disconnected.  Since the
    disconnect event itself appears in the log, there's no need for other
    error messages.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Tested-by: Jenya Y <jy.gerstmaier@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/generic.c b/drivers/usb/core/generic.c
index 271e761f563e..acbfeb0a0119 100644
--- a/drivers/usb/core/generic.c
+++ b/drivers/usb/core/generic.c
@@ -169,7 +169,7 @@ static int generic_probe(struct usb_device *udev)
 		c = usb_choose_configuration(udev);
 		if (c >= 0) {
 			err = usb_set_configuration(udev, c);
-			if (err) {
+			if (err && err != -ENODEV) {
 				dev_err(&udev->dev, "can't set config #%d, error %d\n",
 					c, err);
 				/* This need not be fatal.  The user can try to

commit 8d8479db3dde3ef7a9bc803e565842764fa21a53
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Tue Dec 18 15:25:46 2012 +0100

    usb/core: consider link speed while looking at bMaxPower
    
    The USB 2.0 specification says that bMaxPower is the maximum power
    consumption expressed in 2 mA units and the USB 3.0 specification says
    that it is expressed in 8 mA units.
    This patch adds a helper function usb_get_max_power() which computes the
    value based on config & usb_device's speed value. The the device descriptor
    dump computes the value on its own.
    
    Cc: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/generic.c b/drivers/usb/core/generic.c
index eff2010eb63f..271e761f563e 100644
--- a/drivers/usb/core/generic.c
+++ b/drivers/usb/core/generic.c
@@ -100,7 +100,7 @@ int usb_choose_configuration(struct usb_device *udev)
 		 */
 
 		/* Rule out configs that draw too much bus current */
-		if (c->desc.bMaxPower * 2 > udev->bus_mA) {
+		if (usb_get_max_power(udev, c) > udev->bus_mA) {
 			insufficient_power++;
 			continue;
 		}

commit c13b86a336d089f248293776a853252fbca15c26
Author: Hindin Joseph <hindin@gmail.com>
Date:   Sun Nov 4 22:50:08 2012 +0200

    USB: fix authorization and claimed port logic
    
        It looks like I've run into some inconsistency in the USB stack behavior.
    
        The USB stack maintains, among others, two states for the attach
    USB device: authorized and owned. Authorization state is accessible to
    the user space code through correspondent sysfs files, the ownership
    can be set by claiming the hub's port with ioctl call. Both state may
    be set before the device is attached, by access the hub settings. When
    the new device is attached, both authorization and ownership prevent
    the kernel USB stack from setting the newly attached device
    configuration, but when the device is authorized, the ownership state
    is ignored. It looks like ignoring the ownership state on
    authorization make the stack behavior inconsistent; it also prevents
    the user space code from completely overriding configuration
    selection, important for implementing workarounds for bugs in the
    device configuration selection.
    
       The following patch makes the stack behavior more consistent, by
    moving ownership test into usb_choose_configuration - the later
    function is used both by generic_probe and usb_authorize_device
    
    Signed-off-by: Joseph Hindin <hindin@gmail.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/core/generic.c b/drivers/usb/core/generic.c
index 69ecd3c92311..eff2010eb63f 100644
--- a/drivers/usb/core/generic.c
+++ b/drivers/usb/core/generic.c
@@ -47,6 +47,9 @@ int usb_choose_configuration(struct usb_device *udev)
 	int insufficient_power = 0;
 	struct usb_host_config *c, *best;
 
+	if (usb_device_is_owned(udev))
+		return 0;
+
 	best = NULL;
 	c = udev->config;
 	num_configs = udev->descriptor.bNumConfigurations;
@@ -160,9 +163,7 @@ static int generic_probe(struct usb_device *udev)
 	/* Choose and set the configuration.  This registers the interfaces
 	 * with the driver core and lets interface drivers bind to them.
 	 */
-	if (usb_device_is_owned(udev))
-		;		/* Don't configure if the device is owned */
-	else if (udev->authorized == 0)
+	if (udev->authorized == 0)
 		dev_err(&udev->dev, "Device is not authorized for usage\n");
 	else {
 		c = usb_choose_configuration(udev);

commit c4e0b508bcdd1af6b1b3c317042336936173591f
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Jul 27 11:28:42 2010 -0400

    USB: accept RNDIS configs if there's no alternative
    
    This patch (as1410) makes a slight change to the strategy used for
    choosing a default configuration.  Currently we skip configs whose
    first interface is RNDIS, if the kernel wasn't built with the
    corresponding driver.  This risks losing access to the other
    interfaces in those configs.  In addition, if there is only one config
    then we will end up not configuring the device at all.
    
    This changes the logic; now such configurations will be skipped only
    if there is at least one other config.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Tested-by: Adam Kropelin <akropel1@rochester.rr.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/generic.c b/drivers/usb/core/generic.c
index 9a34ccb0a1c0..69ecd3c92311 100644
--- a/drivers/usb/core/generic.c
+++ b/drivers/usb/core/generic.c
@@ -105,8 +105,10 @@ int usb_choose_configuration(struct usb_device *udev)
 		/* When the first config's first interface is one of Microsoft's
 		 * pet nonstandard Ethernet-over-USB protocols, ignore it unless
 		 * this kernel has enabled the necessary host side driver.
+		 * But: Don't ignore it if it's the only config.
 		 */
-		if (i == 0 && desc && (is_rndis(desc) || is_activesync(desc))) {
+		if (i == 0 && num_configs > 1 && desc &&
+				(is_rndis(desc) || is_activesync(desc))) {
 #if !defined(CONFIG_USB_NET_RNDIS_HOST) && !defined(CONFIG_USB_NET_RNDIS_HOST_MODULE)
 			continue;
 #else

commit 27729aadd31dafddaaf64c24f8ef6d0ff750f3aa
Author: Eric Lescouet <Eric.Lescouet@virtuallogix.com>
Date:   Sat Apr 24 23:21:52 2010 +0200

    USB: make hcd.h public (drivers dependency)
    
    The usbcore headers: hcd.h and hub.h are shared between usbcore,
    HCDs and a couple of other drivers (e.g. USBIP modules).
    So, it makes sense to move them into a more public location and
    to cleanup dependency of those modules on kernel internal headers.
    This patch moves hcd.h from drivers/usb/core into include/linux/usb/
    
    Signed-of-by: Eric Lescouet <eric@lescouet.org>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/generic.c b/drivers/usb/core/generic.c
index 2c95153c0f24..9a34ccb0a1c0 100644
--- a/drivers/usb/core/generic.c
+++ b/drivers/usb/core/generic.c
@@ -18,8 +18,8 @@
  */
 
 #include <linux/usb.h>
+#include <linux/usb/hcd.h>
 #include "usb.h"
-#include "hcd.h"
 
 static inline const char *plural(int n)
 {

commit 62f9cfa3ece58268b3e92ca59c23b175f86205aa
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Apr 20 10:40:59 2010 -0400

    USB: don't choose configs with no interfaces
    
    This patch (as1372) fixes a bug in the routine that chooses the
    default configuration to install when a new USB device is detected.
    The algorithm is supposed to look for a config whose first interface
    is for a non-vendor-specific class.  But the way it's currently
    written, it will also accept a config with no interfaces at all, which
    is not very useful.  (Believe it or not, such things do exist.)
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Tested-by: Andrew Victor <avictor.za@gmail.com>
    Cc: stable <stable@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/generic.c b/drivers/usb/core/generic.c
index bdf87a8414a1..2c95153c0f24 100644
--- a/drivers/usb/core/generic.c
+++ b/drivers/usb/core/generic.c
@@ -120,7 +120,7 @@ int usb_choose_configuration(struct usb_device *udev)
 		 * than a vendor-specific driver. */
 		else if (udev->descriptor.bDeviceClass !=
 						USB_CLASS_VENDOR_SPEC &&
-				(!desc || desc->bInterfaceClass !=
+				(desc && desc->bInterfaceClass !=
 						USB_CLASS_VENDOR_SPEC)) {
 			best = c;
 			break;

commit b1f0a34ca983a6defb0431aa18c9268eb9ffcc4a
Author: Matthew Wilcox <willy@linux.intel.com>
Date:   Thu Sep 24 16:18:27 2009 -0600

    USB: Convert a dev_info to a dev_dbg
    
    Knowing which configuration was chosen is a debugging aid more than it
    is informational.
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/generic.c b/drivers/usb/core/generic.c
index 05e6d313961e..bdf87a8414a1 100644
--- a/drivers/usb/core/generic.c
+++ b/drivers/usb/core/generic.c
@@ -139,7 +139,7 @@ int usb_choose_configuration(struct usb_device *udev)
 
 	if (best) {
 		i = best->desc.bConfigurationValue;
-		dev_info(&udev->dev,
+		dev_dbg(&udev->dev,
 			"configuration #%d chosen from %d choice%s\n",
 			i, num_configs, plural(num_configs));
 	} else {

commit 7cbe5dca399a50ce8aa74314b1d276e2fb904e1b
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Jun 29 10:56:54 2009 -0400

    USB: add API for userspace drivers to "claim" ports
    
    This patch (as1258) implements a feature that users have been asking
    for: It gives programs the ability to "claim" a port on a hub, via a
    new usbfs ioctl.  A device plugged into a "claimed" port will not be
    touched by the kernel beyond the immediate necessities of
    initialization and enumeration.
    
    In particular, when a device is plugged into a "claimed" port, the
    kernel will not select and install a configuration.  And when a config
    is installed by usbfs or sysfs, the kernel will not probe any drivers
    for any of the interfaces.  (However the kernel will fetch various
    string descriptors during enumeration.  One could argue that this
    isn't really necessary, but the strings are exported in sysfs.)
    
    The patch does not guarantee exclusive access to these devices; it is
    still possible for more than one program to open the device file
    concurrently.  Programs are responsible for coordinating access among
    themselves.
    
    A demonstration program showing how to use the new interface can be
    found in an attachment to
    
            http://marc.info/?l=linux-usb&m=124345857431452&w=2
    
    The patch also makes a small simplification to the hub driver,
    replacing a bunch of more-or-less useless variants of "out of memory"
    with a single message.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/generic.c b/drivers/usb/core/generic.c
index 30ecac3af15a..05e6d313961e 100644
--- a/drivers/usb/core/generic.c
+++ b/drivers/usb/core/generic.c
@@ -158,7 +158,9 @@ static int generic_probe(struct usb_device *udev)
 	/* Choose and set the configuration.  This registers the interfaces
 	 * with the driver core and lets interface drivers bind to them.
 	 */
-	if (udev->authorized == 0)
+	if (usb_device_is_owned(udev))
+		;		/* Don't configure if the device is owned */
+	else if (udev->authorized == 0)
 		dev_err(&udev->dev, "Device is not authorized for usage\n");
 	else {
 		c = usb_choose_configuration(udev);

commit 65bfd2967c906ca322a4bb69a285fe0de8916ac6
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue Nov 25 16:39:18 2008 -0500

    USB: Enhance usage of pm_message_t
    
    This patch (as1177) modifies the USB core suspend and resume
    routines.  The resume functions now will take a pm_message_t argument,
    so they will know what sort of resume is occurring.  The new argument
    is also passed to the port suspend/resume and bus suspend/resume
    routines (although they don't use it for anything but debugging).
    
    In addition, special pm_message_t values are used for user-initiated,
    device-initiated (i.e., remote wakeup), and automatic suspend/resume.
    By testing these values, drivers can tell whether or not a particular
    suspend was an autosuspend.  Unfortunately, they can't do the same for
    resumes -- not until the pm_message_t argument is also passed to the
    drivers' resume methods.  That will require a bigger change.
    
    IMO, the whole Power Management framework should have been set up this
    way in the first place.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/generic.c b/drivers/usb/core/generic.c
index 7e912f21fd36..30ecac3af15a 100644
--- a/drivers/usb/core/generic.c
+++ b/drivers/usb/core/generic.c
@@ -200,18 +200,18 @@ static int generic_suspend(struct usb_device *udev, pm_message_t msg)
 	 * interfaces manually by doing a bus (or "global") suspend.
 	 */
 	if (!udev->parent)
-		rc = hcd_bus_suspend(udev);
+		rc = hcd_bus_suspend(udev, msg);
 
 	/* Non-root devices don't need to do anything for FREEZE or PRETHAW */
 	else if (msg.event == PM_EVENT_FREEZE || msg.event == PM_EVENT_PRETHAW)
 		rc = 0;
 	else
-		rc = usb_port_suspend(udev);
+		rc = usb_port_suspend(udev, msg);
 
 	return rc;
 }
 
-static int generic_resume(struct usb_device *udev)
+static int generic_resume(struct usb_device *udev, pm_message_t msg)
 {
 	int rc;
 
@@ -221,9 +221,9 @@ static int generic_resume(struct usb_device *udev)
 	 * interfaces manually by doing a bus (or "global") resume.
 	 */
 	if (!udev->parent)
-		rc = hcd_bus_resume(udev);
+		rc = hcd_bus_resume(udev, msg);
 	else
-		rc = usb_port_resume(udev);
+		rc = usb_port_resume(udev, msg);
 	return rc;
 }
 

commit e16362a0c8d90e9adbfe477acbe32b021823fb22
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Tue May 20 16:37:34 2008 -0400

    USB: fix possible deadlock involving sysfs attributes
    
    There is a potential deadlock when the usb_generic driver is unbound
    from a device.  The problem is that generic_disconnect() is called
    with the device lock held, and it removes a bunch of device attributes
    from sysfs.  If a user task happens to be running an attribute method
    at the time, the removal will block until the method returns.  But at
    least one of the attribute methods (the store routine for power/level)
    needs to acquire the device lock!
    
    This patch (as1093) eliminates the deadlock by moving the calls to
    create and remove the sysfs attributes from the usb_generic driver
    into usb_new_device() and usb_disconnect(), where they can be invoked
    without holding the device lock.
    
    Besides, the other sysfs attributes are created when the device is
    registered and removed when the device is unregistered.  So it seems
    only fitting for the extra attributes to be created and removed at the
    same time.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/generic.c b/drivers/usb/core/generic.c
index c1cb94e9f242..7e912f21fd36 100644
--- a/drivers/usb/core/generic.c
+++ b/drivers/usb/core/generic.c
@@ -155,9 +155,6 @@ static int generic_probe(struct usb_device *udev)
 {
 	int err, c;
 
-	/* put device-specific files into sysfs */
-	usb_create_sysfs_dev_files(udev);
-
 	/* Choose and set the configuration.  This registers the interfaces
 	 * with the driver core and lets interface drivers bind to them.
 	 */
@@ -189,8 +186,6 @@ static void generic_disconnect(struct usb_device *udev)
 	 * unconfigure the device */
 	if (udev->actconfig)
 		usb_set_configuration(udev, -1);
-
-	usb_remove_sysfs_dev_files(udev);
 }
 
 #ifdef	CONFIG_PM

commit 5ad4f71e2f19a06f738463da1f09ea7fda3a3db2
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Mon Sep 10 11:31:43 2007 -0400

    USB: move decision to ignore FREEZE events
    
    This patch (as987) changes the way FREEZE and PRETHAW suspend events
    are handled in usbcore.  The decision about whether or not to ignore
    them for non-root devices is pushed down into the USB-device driver,
    instead of being made in the core code.
    
    This is appropriate, since devices exported to a virtualized guest or
    over a network may indeed need to handle these types of suspend, even
    though normal devices don't.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/generic.c b/drivers/usb/core/generic.c
index 9148b69785c5..c1cb94e9f242 100644
--- a/drivers/usb/core/generic.c
+++ b/drivers/usb/core/generic.c
@@ -206,8 +206,13 @@ static int generic_suspend(struct usb_device *udev, pm_message_t msg)
 	 */
 	if (!udev->parent)
 		rc = hcd_bus_suspend(udev);
+
+	/* Non-root devices don't need to do anything for FREEZE or PRETHAW */
+	else if (msg.event == PM_EVENT_FREEZE || msg.event == PM_EVENT_PRETHAW)
+		rc = 0;
 	else
 		rc = usb_port_suspend(udev);
+
 	return rc;
 }
 

commit b5ea060f1e19c6a3f409d3472c723da4517547b8
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Aug 2 22:44:27 2007 -0600

    USB: rename choose_configuration
    
    As it is global, give it a usb specific name in the global namespace.
    
    Cc: Inaky Perez-Gonzalez <inaky@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/generic.c b/drivers/usb/core/generic.c
index 7b9e1ec718d2..9148b69785c5 100644
--- a/drivers/usb/core/generic.c
+++ b/drivers/usb/core/generic.c
@@ -40,7 +40,7 @@ static int is_activesync(struct usb_interface_descriptor *desc)
 		&& desc->bInterfaceProtocol == 1;
 }
 
-int choose_configuration(struct usb_device *udev)
+int usb_choose_configuration(struct usb_device *udev)
 {
 	int i;
 	int num_configs;
@@ -164,7 +164,7 @@ static int generic_probe(struct usb_device *udev)
 	if (udev->authorized == 0)
 		dev_err(&udev->dev, "Device is not authorized for usage\n");
 	else {
-		c = choose_configuration(udev);
+		c = usb_choose_configuration(udev);
 		if (c >= 0) {
 			err = usb_set_configuration(udev, c);
 			if (err) {

commit 93993a0a3e528357ae4b9b0eb82fd4b428ebbf64
Author: Inaky Perez-Gonzalez <inaky@linux.intel.com>
Date:   Tue Jul 31 20:34:06 2007 -0700

    usb: introduce usb_authorize/deauthorize()
    
    These USB API functions will do the full authorization/deauthorization
    to be used for a device. When authorized we effectively allow a
    configuration to be set. Reverse that when deauthorized.
    
    Effectively this means that we have to clean all the configuration
    descriptors on deauthorize and reload them when we authorized. We could
    do without throwing them out for wired devices, but for wireless, we can
    read them only after authenticating, and thus, when authorizing an
    authenticated device we would need to read them. So to simplify, always
    release them on deauthorize(), re-read them on authorize().
    
    Also fix leak reported by Ragner Magalhaes; in usb_deauthorize_device(),
    bNumConfigurations was being set to zero before the for loop, and thus
    the different raw descriptors where never being freed.
    
    Signed-off-by: Inaky Perez-Gonzalez <inaky@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/generic.c b/drivers/usb/core/generic.c
index 20b095050a16..7b9e1ec718d2 100644
--- a/drivers/usb/core/generic.c
+++ b/drivers/usb/core/generic.c
@@ -40,7 +40,7 @@ static int is_activesync(struct usb_interface_descriptor *desc)
 		&& desc->bInterfaceProtocol == 1;
 }
 
-static int choose_configuration(struct usb_device *udev)
+int choose_configuration(struct usb_device *udev)
 {
 	int i;
 	int num_configs;

commit f8a374648b58e5cfa14447eca866aed14a4fbfa8
Author: Inaky Perez-Gonzalez <inaky@linux.intel.com>
Date:   Tue Jul 31 20:34:04 2007 -0700

    usb: usb_generic_probe() obeys authorization
    
    If called and the device is not authorized to be used, then we won't
    choose a configuration (as they are not a concept that exists for an
    unauthorized device). However, the device is added to the system.
    
    Signed-off-by: Inaky Perez-Gonzalez <inaky@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/generic.c b/drivers/usb/core/generic.c
index b2fc2b115256..20b095050a16 100644
--- a/drivers/usb/core/generic.c
+++ b/drivers/usb/core/generic.c
@@ -161,17 +161,20 @@ static int generic_probe(struct usb_device *udev)
 	/* Choose and set the configuration.  This registers the interfaces
 	 * with the driver core and lets interface drivers bind to them.
 	 */
-	c = choose_configuration(udev);
-	if (c >= 0) {
-		err = usb_set_configuration(udev, c);
-		if (err) {
-			dev_err(&udev->dev, "can't set config #%d, error %d\n",
+	if (udev->authorized == 0)
+		dev_err(&udev->dev, "Device is not authorized for usage\n");
+	else {
+		c = choose_configuration(udev);
+		if (c >= 0) {
+			err = usb_set_configuration(udev, c);
+			if (err) {
+				dev_err(&udev->dev, "can't set config #%d, error %d\n",
 					c, err);
-			/* This need not be fatal.  The user can try to
-			 * set other configurations. */
+				/* This need not be fatal.  The user can try to
+				 * set other configurations. */
+			}
 		}
 	}
-
 	/* USB device state == configured ... usable */
 	usb_notify_add_device(udev);
 

commit 54515fe528d8c6f9bfaf7d0b9fffb908deecad78
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed May 30 15:38:58 2007 -0400

    USB: unify reset_resume and normal resume
    
    This patch (as919) unifies the code paths used for normal resume and
    for reset-resume.  Earlier I had failed to note a section in the USB
    spec which requires the host to resume a suspended port before
    resetting it if the attached device is enabled for remote wakeup.
    Since the port has to be resumed anyway, we might as well reuse the
    existing code.
    
    The main changes are:
    
            usb_reset_suspended_device() is eliminated.
    
            usb_root_hub_lost_power() is moved down next to the
            hub_reset_resume() routine, to which it is logically
            related.
    
            finish_port_resume() does a port reset() if the device's
            reset_resume flag is set.
    
            usb_port_resume() doesn't check whether the port is initially
            enabled if this is a USB-Persist sort of resume.
    
            Code to perform the port reset is added to the resume pathway
            for the non-CONFIG_USB_SUSPEND case.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/generic.c b/drivers/usb/core/generic.c
index 4cbe7b339513..b2fc2b115256 100644
--- a/drivers/usb/core/generic.c
+++ b/drivers/usb/core/generic.c
@@ -219,8 +219,6 @@ static int generic_resume(struct usb_device *udev)
 	 */
 	if (!udev->parent)
 		rc = hcd_bus_resume(udev);
-	else if (udev->reset_resume)
-		rc = usb_reset_suspended_device(udev);
 	else
 		rc = usb_port_resume(udev);
 	return rc;

commit 686314cfbdac21c9019c0e04487b5d940db62406
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed May 30 15:34:36 2007 -0400

    USB: separate root and non-root suspend/resume
    
    This patch (as916) completes the separation of code paths for suspend
    and resume of root hubs as opposed to non-root devices.  Root hubs
    will be power-managed through their bus_suspend and bus_resume
    methods, whereas normal devices will use usb_port_suspend() and
    usb_port_resume().
    
    Changes to the hcd_bus_{suspend,resume} routines mostly represent
    motion of code that was already present elsewhere.  They include:
    
            Adding debugging log messages,
    
            Setting the device state appropriately, and
    
            Adding a resume recovery time delay.
    
    Changes to the port-suspend and port-resume routines in hub.c include:
    
            Removal of checks for root devices (since they will never
            be triggered), and
    
            Removal of checks for NULL or invalid device pointers (these
            were left over from earlier kernel versions and aren't needed
            at all).
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/generic.c b/drivers/usb/core/generic.c
index d363b0ea7345..4cbe7b339513 100644
--- a/drivers/usb/core/generic.c
+++ b/drivers/usb/core/generic.c
@@ -196,20 +196,15 @@ static int generic_suspend(struct usb_device *udev, pm_message_t msg)
 {
 	int rc;
 
-	rc = usb_port_suspend(udev);
-
-	/* Root hubs don't have upstream ports to suspend,
-	 * so the line above won't do much for them.  We have to
-	 * shut down their downstream HC-to-USB interfaces manually,
-	 * by doing a bus (or "global") suspend.
+	/* Normal USB devices suspend through their upstream port.
+	 * Root hubs don't have upstream ports to suspend,
+	 * so we have to shut down their downstream HC-to-USB
+	 * interfaces manually by doing a bus (or "global") suspend.
 	 */
-	if (rc == 0 && !udev->parent) {
-		rc = hcd_bus_suspend(udev->bus);
-		if (rc) {
-			dev_dbg(&udev->dev, "'global' suspend %d\n", rc);
-			usb_port_resume(udev);
-		}
-	}
+	if (!udev->parent)
+		rc = hcd_bus_suspend(udev);
+	else
+		rc = usb_port_suspend(udev);
 	return rc;
 }
 
@@ -217,25 +212,17 @@ static int generic_resume(struct usb_device *udev)
 {
 	int rc;
 
-	if (udev->reset_resume)
+	/* Normal USB devices resume/reset through their upstream port.
+	 * Root hubs don't have upstream ports to resume or reset,
+	 * so we have to start up their downstream HC-to-USB
+	 * interfaces manually by doing a bus (or "global") resume.
+	 */
+	if (!udev->parent)
+		rc = hcd_bus_resume(udev);
+	else if (udev->reset_resume)
 		rc = usb_reset_suspended_device(udev);
 	else
 		rc = usb_port_resume(udev);
-
-	/* Root hubs don't have upstream ports to resume or reset,
-	 * so the line above won't do much for them.  We have to
-	 * start up their downstream HC-to-USB interfaces manually,
-	 * by doing a bus (or "global") resume.
-	 */
-	if (rc == 0 && !udev->parent) {
-		rc = hcd_bus_resume(udev->bus);
-		if (rc)
-			dev_dbg(&udev->dev, "'global' resume %d\n", rc);
-		else {
-			/* TRSMRCY = 10 msec */
-			msleep(10);
-		}
-	}
 	return rc;
 }
 

commit 0458d5b4c9cc4ca0f62625d0144ddc4b4bc97a3c
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri May 4 11:52:20 2007 -0400

    USB: add USB-Persist facility
    
    This patch (as886) adds the controversial USB-persist facility,
    allowing USB devices to persist across a power loss during system
    suspend.
    
    The facility is controlled by a new Kconfig option (with appropriate
    warnings about the potential dangers); when the option is off the
    behavior will remain the same as it is now.  But when the option is
    on, people will be able to use suspend-to-disk and keep their USB
    filesystems intact -- something particularly valuable for small
    machines where the root filesystem is on a USB device!
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/generic.c b/drivers/usb/core/generic.c
index 7cbf992adccd..d363b0ea7345 100644
--- a/drivers/usb/core/generic.c
+++ b/drivers/usb/core/generic.c
@@ -217,7 +217,10 @@ static int generic_resume(struct usb_device *udev)
 {
 	int rc;
 
-	rc = usb_port_resume(udev);
+	if (udev->reset_resume)
+		rc = usb_reset_suspended_device(udev);
+	else
+		rc = usb_port_resume(udev);
 
 	/* Root hubs don't have upstream ports to resume or reset,
 	 * so the line above won't do much for them.  We have to

commit b6f6436da0c6853eedad86f5075b139c1a3bcb5d
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri May 4 11:51:54 2007 -0400

    USB: move bus_suspend and bus_resume method calls
    
    This patch (as885) moves the root-hub bus_suspend() and bus_resume()
    method calls from the hub driver's suspend and resume methods into the
    usb_generic driver methods, where they make just as much sense.
    
    Their old locations were not fully correct.  For example, in a kernel
    compiled without CONFIG_USB_SUSPEND, if one were to do:
    
            echo -n 1-0:1.0 >/sys/bus/usb/drivers/hub/unbind
    
    to unbind the hub driver from a root hub, there would then be no way
    to suspend that root hub.  Attempts to put the system to sleep would
    fail; the USB controller driver would refuse to suspend because the
    root hub was still active.
    
    The patch also makes a very slight change in the way devices with no
    driver are handled during suspend.  Rather than doing a standard USB
    port-suspend directly, now the suspend routine in usb_generic is
    called.  In practice this should never affect anyone.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/generic.c b/drivers/usb/core/generic.c
index e7ec9b6b7a93..7cbf992adccd 100644
--- a/drivers/usb/core/generic.c
+++ b/drivers/usb/core/generic.c
@@ -19,6 +19,7 @@
 
 #include <linux/usb.h>
 #include "usb.h"
+#include "hcd.h"
 
 static inline const char *plural(int n)
 {
@@ -193,12 +194,46 @@ static void generic_disconnect(struct usb_device *udev)
 
 static int generic_suspend(struct usb_device *udev, pm_message_t msg)
 {
-	return usb_port_suspend(udev);
+	int rc;
+
+	rc = usb_port_suspend(udev);
+
+	/* Root hubs don't have upstream ports to suspend,
+	 * so the line above won't do much for them.  We have to
+	 * shut down their downstream HC-to-USB interfaces manually,
+	 * by doing a bus (or "global") suspend.
+	 */
+	if (rc == 0 && !udev->parent) {
+		rc = hcd_bus_suspend(udev->bus);
+		if (rc) {
+			dev_dbg(&udev->dev, "'global' suspend %d\n", rc);
+			usb_port_resume(udev);
+		}
+	}
+	return rc;
 }
 
 static int generic_resume(struct usb_device *udev)
 {
-	return usb_port_resume(udev);
+	int rc;
+
+	rc = usb_port_resume(udev);
+
+	/* Root hubs don't have upstream ports to resume or reset,
+	 * so the line above won't do much for them.  We have to
+	 * start up their downstream HC-to-USB interfaces manually,
+	 * by doing a bus (or "global") resume.
+	 */
+	if (rc == 0 && !udev->parent) {
+		rc = hcd_bus_resume(udev->bus);
+		if (rc)
+			dev_dbg(&udev->dev, "'global' resume %d\n", rc);
+		else {
+			/* TRSMRCY = 10 msec */
+			msleep(10);
+		}
+	}
+	return rc;
 }
 
 #endif	/* CONFIG_PM */

commit 4d461095ef6967324bc5da5d65d23ad27fc604f9
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri May 4 11:51:25 2007 -0400

    USB: Implement PM FREEZE and PRETHAW
    
    This patch (as884) finally implements the time-saving semantics
    possible with the Power Management FREEZE and PRETHAW events.  Their
    proper handling requires only that devices be quiesced, with
    interrupts and DMA turned off; non-root USB devices don't actually
    need to be put in a suspended state.  The patch checks and avoids
    doing the suspend call when possible.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/generic.c b/drivers/usb/core/generic.c
index 9bbcb20e2d94..e7ec9b6b7a93 100644
--- a/drivers/usb/core/generic.c
+++ b/drivers/usb/core/generic.c
@@ -193,10 +193,6 @@ static void generic_disconnect(struct usb_device *udev)
 
 static int generic_suspend(struct usb_device *udev, pm_message_t msg)
 {
-	/* USB devices enter SUSPEND state through their hubs, but can be
-	 * marked for FREEZE as soon as their children are already idled.
-	 * But those semantics are useless, so we equate the two (sigh).
-	 */
 	return usb_port_suspend(udev);
 }
 

commit 3f141e2aed586c41c2666d49c70c1c1bbb6d6abd
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Thu Feb 8 16:40:43 2007 -0500

    USB: unconfigure devices which have config 0
    
    Some USB devices do have a configuration 0, in contravention of the
    USB spec.  Normally 0 is supposed to indicate that a device is
    unconfigured.
    
    While we can't change what the device is doing, we can change usbcore.
    This patch (as852) allows usb_set_configuration() to accept a config
    value of -1 as indicating that the device should be unconfigured.  The
    request actually sent to the device will still contain 0 as the value.
    But even if the device does have a configuration 0, dev->actconfig
    will be set to NULL and dev->state will be set to USB_STATE_ADDRESS.
    
    Without some sort of special-case handling like this, there is no way
    to unconfigure these non-compliant devices.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/generic.c b/drivers/usb/core/generic.c
index b531a4fd30c2..9bbcb20e2d94 100644
--- a/drivers/usb/core/generic.c
+++ b/drivers/usb/core/generic.c
@@ -184,7 +184,7 @@ static void generic_disconnect(struct usb_device *udev)
 	/* if this is only an unbind, not a physical disconnect, then
 	 * unconfigure the device */
 	if (udev->actconfig)
-		usb_set_configuration(udev, 0);
+		usb_set_configuration(udev, -1);
 
 	usb_remove_sysfs_dev_files(udev);
 }

commit ad55d71a3d4401f44b4ddee1412283c99eedd05c
Author: Ole Andre Vadla Ravnas <oleavr@gmail.com>
Date:   Thu Dec 14 16:01:28 2006 -0800

    rndis_host learns ActiveSync basics
    
    Windows Mobile 5 based devices described as supporting "ActiveSync":
    
     - Speak RNDIS but lack the CDC and union descriptors.  This patch
       updates the cdc ethernet code to fake ACM descriptors we need.
    
     - Require RNDIS_MSG_QUERY messages to include a buffer of the size the
       response should generate.  This patch updates the rndis host code to
       pass this will-be-ignored data.
    
    The resulting RNDIS host code has been reported to work with several
    WM5 based devices.
    
    (Note that a fancier patch is available at synce.sf.net.)
    
    
    Some bugfixes, affecting not just ActiveSync:
        (a) when cleaning up after RNDS init fails, scrub the second interface
            just like cdc_ether does, so disconnect won't oops.
        (b) handle peripherals that use the pad-to-end-of-packet option; some
            devices can't talk to us if that option doesn't work.
        (c) when choosing configurations, don't forget about an RNDIS config
            just because the RNDIS driver is dynamically linked.
    
    Cleanup, streamlining, bugfixes, Kconfig, and matching hub driver update.
    Also for paranoia's sake, refuse to talk to something that looks like a
    real modem instead of RNDIS.
    
    Signed-off-by: Ole Andre Vadla Ravnaas <oleavr@gmail.com>
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/generic.c b/drivers/usb/core/generic.c
index ebb20ff7ac58..b531a4fd30c2 100644
--- a/drivers/usb/core/generic.c
+++ b/drivers/usb/core/generic.c
@@ -25,6 +25,20 @@ static inline const char *plural(int n)
 	return (n == 1 ? "" : "s");
 }
 
+static int is_rndis(struct usb_interface_descriptor *desc)
+{
+	return desc->bInterfaceClass == USB_CLASS_COMM
+		&& desc->bInterfaceSubClass == 2
+		&& desc->bInterfaceProtocol == 0xff;
+}
+
+static int is_activesync(struct usb_interface_descriptor *desc)
+{
+	return desc->bInterfaceClass == USB_CLASS_MISC
+		&& desc->bInterfaceSubClass == 1
+		&& desc->bInterfaceProtocol == 1;
+}
+
 static int choose_configuration(struct usb_device *udev)
 {
 	int i;
@@ -87,14 +101,12 @@ static int choose_configuration(struct usb_device *udev)
 			continue;
 		}
 
-		/* If the first config's first interface is COMM/2/0xff
-		 * (MSFT RNDIS), rule it out unless Linux has host-side
-		 * RNDIS support. */
-		if (i == 0 && desc
-				&& desc->bInterfaceClass == USB_CLASS_COMM
-				&& desc->bInterfaceSubClass == 2
-				&& desc->bInterfaceProtocol == 0xff) {
-#ifndef CONFIG_USB_NET_RNDIS_HOST
+		/* When the first config's first interface is one of Microsoft's
+		 * pet nonstandard Ethernet-over-USB protocols, ignore it unless
+		 * this kernel has enabled the necessary host side driver.
+		 */
+		if (i == 0 && desc && (is_rndis(desc) || is_activesync(desc))) {
+#if !defined(CONFIG_USB_NET_RNDIS_HOST) && !defined(CONFIG_USB_NET_RNDIS_HOST_MODULE)
 			continue;
 #else
 			best = c;

commit 038b0a6d8d32db934bba6a24e74e76e4e327a94f
Author: Dave Jones <davej@redhat.com>
Date:   Wed Oct 4 03:38:54 2006 -0400

    Remove all inclusions of <linux/config.h>
    kbuild explicitly includes this at build time.
    
    Signed-off-by: Dave Jones <davej@redhat.com>

diff --git a/drivers/usb/core/generic.c b/drivers/usb/core/generic.c
index 16332cc57946..ebb20ff7ac58 100644
--- a/drivers/usb/core/generic.c
+++ b/drivers/usb/core/generic.c
@@ -17,7 +17,6 @@
  *
  */
 
-#include <linux/config.h>
 #include <linux/usb.h>
 #include "usb.h"
 

commit 01d883d44a1ca8dc77486635d428cba63e7fdadf
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Wed Aug 30 15:47:18 2006 -0400

    usbcore: non-hub-specific uses of autosuspend
    
    This patch (as741) makes the non-hub parts of usbcore actually use the
    autosuspend facilities added by an earlier patch.
    
            Devices opened through usbfs are autoresumed and then
            autosuspended upon close.
    
            Likewise for usb-skeleton.
    
            Devices are autoresumed for usb_set_configuration.
    
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/generic.c b/drivers/usb/core/generic.c
index 5358e656477c..16332cc57946 100644
--- a/drivers/usb/core/generic.c
+++ b/drivers/usb/core/generic.c
@@ -172,14 +172,10 @@ static void generic_disconnect(struct usb_device *udev)
 
 	/* if this is only an unbind, not a physical disconnect, then
 	 * unconfigure the device */
-	if (udev->state == USB_STATE_CONFIGURED)
+	if (udev->actconfig)
 		usb_set_configuration(udev, 0);
 
 	usb_remove_sysfs_dev_files(udev);
-
-	/* in case the call failed or the device was suspended */
-	if (udev->state >= USB_STATE_CONFIGURED)
-		usb_disable_device(udev, 0);
 }
 
 #ifdef	CONFIG_PM
@@ -208,4 +204,5 @@ struct usb_device_driver usb_generic_driver = {
 	.suspend = generic_suspend,
 	.resume = generic_resume,
 #endif
+	.supports_autosuspend = 1,
 };

commit 114b368c07964caa3f4e1fa575b16e87fa11936c
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Sat Jul 1 22:13:04 2006 -0400

    usbcore: fix up device and power state tests
    
    This patch (as734) rationalizes the various tests of device state and
    power states.  There are duplications and mistaken tests in several
    places.
    
    Perhaps the most interesting challenge is where the hub driver tests to
    see that all the child devices are suspended before allowing itself to
    be suspended.  When CONFIG_USB_SUSPEND is set the test is
    straightforward, since we expect that the children _will_ be suspended.
    But when CONFIG_USB_SUSPEND isn't set, it's not so clear what should be
    done.  The code compromises by checking the child's
    power.power_state.event field.
    
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/generic.c b/drivers/usb/core/generic.c
index b6dacd7551d2..5358e656477c 100644
--- a/drivers/usb/core/generic.c
+++ b/drivers/usb/core/generic.c
@@ -195,9 +195,6 @@ static int generic_suspend(struct usb_device *udev, pm_message_t msg)
 
 static int generic_resume(struct usb_device *udev)
 {
-	if (udev->state == USB_STATE_NOTATTACHED)
-		return 0;
-
 	return usb_port_resume(udev);
 }
 

commit a8e7c5653562f88c0f5f53eac0a890c012655789
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Sat Jul 1 22:11:02 2006 -0400

    usbcore: resume device resume recursion
    
    This patch (as717b) removes the existing recursion in hub resume code:
    Resuming a hub will no longer automatically resume the devices attached
    to the hub.
    
    At the same time, it adds one level of recursion: Suspending a USB
    device will automatically suspend all the device's interfaces.  Failure
    at an intermediate stage will cause all the already-suspended interfaces
    to be resumed. Attempts to suspend or resume an interface by itself will
    do nothing, although they won't return an error.  Thus the regular
    system-suspend and system-resume procedures should continue to work as
    before; only runtime PM will be affected.
    
    The patch also removes the code that tests state of the interfaces
    before suspending a device.  It's no longer needed, since everything
    gets suspended together.
    
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/generic.c b/drivers/usb/core/generic.c
index 1522195de715..b6dacd7551d2 100644
--- a/drivers/usb/core/generic.c
+++ b/drivers/usb/core/generic.c
@@ -184,22 +184,8 @@ static void generic_disconnect(struct usb_device *udev)
 
 #ifdef	CONFIG_PM
 
-static int verify_suspended(struct device *dev, void *unused)
-{
-	if (dev->driver == NULL)
-		return 0;
-	return (dev->power.power_state.event == PM_EVENT_ON) ? -EBUSY : 0;
-}
-
 static int generic_suspend(struct usb_device *udev, pm_message_t msg)
 {
-	int	status;
-
-	/* rule out bogus requests through sysfs */
-	status = device_for_each_child(&udev->dev, NULL, verify_suspended);
-	if (status)
-		return status;
-
 	/* USB devices enter SUSPEND state through their hubs, but can be
 	 * marked for FREEZE as soon as their children are already idled.
 	 * But those semantics are useless, so we equate the two (sigh).

commit 782da727b0d59e93c84a627948b1535a3db90392
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Sat Jul 1 22:09:35 2006 -0400

    usbcore: make usb_generic a usb_device_driver
    
    This patch (as714b) makes usb_generic into a usb_device_driver capable
    of being probed and unbound, just like other drivers.  A fair amount of
    the work that used to get done during discovery or removal of a USB
    device have been moved to the probe and disconnect methods of
    usb_generic: creating the sysfs attributes and selecting an initial
    configuration.  However the normal behavior should continue to be the
    same as before.
    
    We will now have the possibility of creating other USB device drivers,
    They will assist with exporting devices to remote systems
    (USB-over-TCPIP) or to paravirtual guest operating systems.
    
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/generic.c b/drivers/usb/core/generic.c
index fa6f34a12b4b..1522195de715 100644
--- a/drivers/usb/core/generic.c
+++ b/drivers/usb/core/generic.c
@@ -21,24 +21,208 @@
 #include <linux/usb.h>
 #include "usb.h"
 
+static inline const char *plural(int n)
+{
+	return (n == 1 ? "" : "s");
+}
+
+static int choose_configuration(struct usb_device *udev)
+{
+	int i;
+	int num_configs;
+	int insufficient_power = 0;
+	struct usb_host_config *c, *best;
+
+	best = NULL;
+	c = udev->config;
+	num_configs = udev->descriptor.bNumConfigurations;
+	for (i = 0; i < num_configs; (i++, c++)) {
+		struct usb_interface_descriptor	*desc = NULL;
+
+		/* It's possible that a config has no interfaces! */
+		if (c->desc.bNumInterfaces > 0)
+			desc = &c->intf_cache[0]->altsetting->desc;
+
+		/*
+		 * HP's USB bus-powered keyboard has only one configuration
+		 * and it claims to be self-powered; other devices may have
+		 * similar errors in their descriptors.  If the next test
+		 * were allowed to execute, such configurations would always
+		 * be rejected and the devices would not work as expected.
+		 * In the meantime, we run the risk of selecting a config
+		 * that requires external power at a time when that power
+		 * isn't available.  It seems to be the lesser of two evils.
+		 *
+		 * Bugzilla #6448 reports a device that appears to crash
+		 * when it receives a GET_DEVICE_STATUS request!  We don't
+		 * have any other way to tell whether a device is self-powered,
+		 * but since we don't use that information anywhere but here,
+		 * the call has been removed.
+		 *
+		 * Maybe the GET_DEVICE_STATUS call and the test below can
+		 * be reinstated when device firmwares become more reliable.
+		 * Don't hold your breath.
+		 */
+#if 0
+		/* Rule out self-powered configs for a bus-powered device */
+		if (bus_powered && (c->desc.bmAttributes &
+					USB_CONFIG_ATT_SELFPOWER))
+			continue;
+#endif
+
+		/*
+		 * The next test may not be as effective as it should be.
+		 * Some hubs have errors in their descriptor, claiming
+		 * to be self-powered when they are really bus-powered.
+		 * We will overestimate the amount of current such hubs
+		 * make available for each port.
+		 *
+		 * This is a fairly benign sort of failure.  It won't
+		 * cause us to reject configurations that we should have
+		 * accepted.
+		 */
+
+		/* Rule out configs that draw too much bus current */
+		if (c->desc.bMaxPower * 2 > udev->bus_mA) {
+			insufficient_power++;
+			continue;
+		}
+
+		/* If the first config's first interface is COMM/2/0xff
+		 * (MSFT RNDIS), rule it out unless Linux has host-side
+		 * RNDIS support. */
+		if (i == 0 && desc
+				&& desc->bInterfaceClass == USB_CLASS_COMM
+				&& desc->bInterfaceSubClass == 2
+				&& desc->bInterfaceProtocol == 0xff) {
+#ifndef CONFIG_USB_NET_RNDIS_HOST
+			continue;
+#else
+			best = c;
+#endif
+		}
+
+		/* From the remaining configs, choose the first one whose
+		 * first interface is for a non-vendor-specific class.
+		 * Reason: Linux is more likely to have a class driver
+		 * than a vendor-specific driver. */
+		else if (udev->descriptor.bDeviceClass !=
+						USB_CLASS_VENDOR_SPEC &&
+				(!desc || desc->bInterfaceClass !=
+						USB_CLASS_VENDOR_SPEC)) {
+			best = c;
+			break;
+		}
+
+		/* If all the remaining configs are vendor-specific,
+		 * choose the first one. */
+		else if (!best)
+			best = c;
+	}
+
+	if (insufficient_power > 0)
+		dev_info(&udev->dev, "rejected %d configuration%s "
+			"due to insufficient available bus power\n",
+			insufficient_power, plural(insufficient_power));
+
+	if (best) {
+		i = best->desc.bConfigurationValue;
+		dev_info(&udev->dev,
+			"configuration #%d chosen from %d choice%s\n",
+			i, num_configs, plural(num_configs));
+	} else {
+		i = -1;
+		dev_warn(&udev->dev,
+			"no configuration chosen from %d choice%s\n",
+			num_configs, plural(num_configs));
+	}
+	return i;
+}
+
 static int generic_probe(struct usb_device *udev)
 {
+	int err, c;
+
+	/* put device-specific files into sysfs */
+	usb_create_sysfs_dev_files(udev);
+
+	/* Choose and set the configuration.  This registers the interfaces
+	 * with the driver core and lets interface drivers bind to them.
+	 */
+	c = choose_configuration(udev);
+	if (c >= 0) {
+		err = usb_set_configuration(udev, c);
+		if (err) {
+			dev_err(&udev->dev, "can't set config #%d, error %d\n",
+					c, err);
+			/* This need not be fatal.  The user can try to
+			 * set other configurations. */
+		}
+	}
+
+	/* USB device state == configured ... usable */
+	usb_notify_add_device(udev);
+
 	return 0;
 }
+
 static void generic_disconnect(struct usb_device *udev)
 {
+	usb_notify_remove_device(udev);
+
 	/* if this is only an unbind, not a physical disconnect, then
 	 * unconfigure the device */
 	if (udev->state == USB_STATE_CONFIGURED)
 		usb_set_configuration(udev, 0);
 
+	usb_remove_sysfs_dev_files(udev);
+
 	/* in case the call failed or the device was suspended */
 	if (udev->state >= USB_STATE_CONFIGURED)
 		usb_disable_device(udev, 0);
 }
 
+#ifdef	CONFIG_PM
+
+static int verify_suspended(struct device *dev, void *unused)
+{
+	if (dev->driver == NULL)
+		return 0;
+	return (dev->power.power_state.event == PM_EVENT_ON) ? -EBUSY : 0;
+}
+
+static int generic_suspend(struct usb_device *udev, pm_message_t msg)
+{
+	int	status;
+
+	/* rule out bogus requests through sysfs */
+	status = device_for_each_child(&udev->dev, NULL, verify_suspended);
+	if (status)
+		return status;
+
+	/* USB devices enter SUSPEND state through their hubs, but can be
+	 * marked for FREEZE as soon as their children are already idled.
+	 * But those semantics are useless, so we equate the two (sigh).
+	 */
+	return usb_port_suspend(udev);
+}
+
+static int generic_resume(struct usb_device *udev)
+{
+	if (udev->state == USB_STATE_NOTATTACHED)
+		return 0;
+
+	return usb_port_resume(udev);
+}
+
+#endif	/* CONFIG_PM */
+
 struct usb_device_driver usb_generic_driver = {
 	.name =	"usb",
 	.probe = generic_probe,
 	.disconnect = generic_disconnect,
+#ifdef	CONFIG_PM
+	.suspend = generic_suspend,
+	.resume = generic_resume,
+#endif
 };

commit 8bb54ab573ecd1b4fe2ed66416a8d99a86e65316
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Sat Jul 1 22:08:49 2006 -0400

    usbcore: add usb_device_driver definition
    
    This patch (as732) adds a usb_device_driver structure, for representing
    drivers that manage an entire USB device as opposed to just an
    interface.  Support routines like usb_register_device_driver,
    usb_deregister_device_driver, usb_probe_device, and usb_unbind_device
    are also added.
    
    Unlike an earlier version of this patch, the new code is type-safe.  To
    accomplish this, the existing struct driver embedded in struct
    usb_driver had to be wrapped in an intermediate wrapper.  This enables
    the core to tell at runtime whether a particular struct driver belongs
    to a device driver or to an interface driver.
    
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/generic.c b/drivers/usb/core/generic.c
index 7bab9769b34f..fa6f34a12b4b 100644
--- a/drivers/usb/core/generic.c
+++ b/drivers/usb/core/generic.c
@@ -21,14 +21,12 @@
 #include <linux/usb.h>
 #include "usb.h"
 
-static int generic_probe(struct device *dev)
+static int generic_probe(struct usb_device *udev)
 {
 	return 0;
 }
-static int generic_remove(struct device *dev)
+static void generic_disconnect(struct usb_device *udev)
 {
-	struct usb_device *udev = to_usb_device(dev);
-
 	/* if this is only an unbind, not a physical disconnect, then
 	 * unconfigure the device */
 	if (udev->state == USB_STATE_CONFIGURED)
@@ -37,17 +35,10 @@ static int generic_remove(struct device *dev)
 	/* in case the call failed or the device was suspended */
 	if (udev->state >= USB_STATE_CONFIGURED)
 		usb_disable_device(udev, 0);
-	return 0;
 }
 
-struct device_driver usb_generic_driver = {
-	.owner = THIS_MODULE,
+struct usb_device_driver usb_generic_driver = {
 	.name =	"usb",
-	.bus = &usb_bus_type,
 	.probe = generic_probe,
-	.remove = generic_remove,
+	.disconnect = generic_disconnect,
 };
-
-/* Fun hack to determine if the struct device is a
- * usb device or a usb interface. */
-int usb_generic_driver_data;

commit 36e56a34586783c7986ce09d39db80b27c95ce24
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Sat Jul 1 22:08:06 2006 -0400

    usbcore: move code among source files
    
    This revised patch (as713b) moves a few routines among source files in
    usbcore.  Some driver-related code in usb.c (claiming interfaces and
    matching IDs) is moved to driver.c, where it belongs.  Also the
    usb_generic stuff in driver.c is moved to a new source file: generic.c.
    (That's the reason for revising the patch.)  Although not very big now,
    it will get bigger in a later patch.
    
    None of the code has been changed; it has only been re-arranged.
    
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/generic.c b/drivers/usb/core/generic.c
new file mode 100644
index 000000000000..7bab9769b34f
--- /dev/null
+++ b/drivers/usb/core/generic.c
@@ -0,0 +1,53 @@
+/*
+ * drivers/usb/generic.c - generic driver for USB devices (not interfaces)
+ *
+ * (C) Copyright 2005 Greg Kroah-Hartman <gregkh@suse.de>
+ *
+ * based on drivers/usb/usb.c which had the following copyrights:
+ *	(C) Copyright Linus Torvalds 1999
+ *	(C) Copyright Johannes Erdfelt 1999-2001
+ *	(C) Copyright Andreas Gal 1999
+ *	(C) Copyright Gregory P. Smith 1999
+ *	(C) Copyright Deti Fliegl 1999 (new USB architecture)
+ *	(C) Copyright Randy Dunlap 2000
+ *	(C) Copyright David Brownell 2000-2004
+ *	(C) Copyright Yggdrasil Computing, Inc. 2000
+ *		(usb_device_id matching changes by Adam J. Richter)
+ *	(C) Copyright Greg Kroah-Hartman 2002-2003
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/usb.h>
+#include "usb.h"
+
+static int generic_probe(struct device *dev)
+{
+	return 0;
+}
+static int generic_remove(struct device *dev)
+{
+	struct usb_device *udev = to_usb_device(dev);
+
+	/* if this is only an unbind, not a physical disconnect, then
+	 * unconfigure the device */
+	if (udev->state == USB_STATE_CONFIGURED)
+		usb_set_configuration(udev, 0);
+
+	/* in case the call failed or the device was suspended */
+	if (udev->state >= USB_STATE_CONFIGURED)
+		usb_disable_device(udev, 0);
+	return 0;
+}
+
+struct device_driver usb_generic_driver = {
+	.owner = THIS_MODULE,
+	.name =	"usb",
+	.bus = &usb_bus_type,
+	.probe = generic_probe,
+	.remove = generic_remove,
+};
+
+/* Fun hack to determine if the struct device is a
+ * usb device or a usb interface. */
+int usb_generic_driver_data;
