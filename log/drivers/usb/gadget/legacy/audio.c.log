commit 19b94c1f9c9a16d41a8de3ccbdb8536cf1aecdbf
Author: Christophe JAILLET <christophe.jaillet@wanadoo.fr>
Date:   Sun May 3 12:47:07 2020 +0200

    usb: gadget: audio: Fix a missing error return value in audio_bind()
    
    If 'usb_otg_descriptor_alloc()' fails, we must return an error code, not 0.
    
    Fixes: 56023ce0fd70 ("usb: gadget: audio: allocate and init otg descriptor by otg capabilities")
    Reviewed-by: Peter Chen <peter.chen@nxp.com>
    Signed-off-by: Christophe JAILLET <christophe.jaillet@wanadoo.fr>
    Signed-off-by: Felipe Balbi <balbi@kernel.org>

diff --git a/drivers/usb/gadget/legacy/audio.c b/drivers/usb/gadget/legacy/audio.c
index dd81fd538cb8..a748ed0842e8 100644
--- a/drivers/usb/gadget/legacy/audio.c
+++ b/drivers/usb/gadget/legacy/audio.c
@@ -300,8 +300,10 @@ static int audio_bind(struct usb_composite_dev *cdev)
 		struct usb_descriptor_header *usb_desc;
 
 		usb_desc = usb_otg_descriptor_alloc(cdev->gadget);
-		if (!usb_desc)
+		if (!usb_desc) {
+			status = -ENOMEM;
 			goto fail;
+		}
 		usb_otg_descriptor_init(cdev->gadget, usb_desc);
 		otg_desc[0] = usb_desc;
 		otg_desc[1] = NULL;

commit c4094c818f82c347a184e545eb2051a11182d606
Author: Aaron Wu <aaron.wu@analog.com>
Date:   Thu Mar 15 18:50:17 2018 +0800

    usb: Remove Blackfin references in USB support
    
    The website is no longer used for tracking bugs.
    
    Signed-off-by: Aaron Wu <aaron.wu@analog.com>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/drivers/usb/gadget/legacy/audio.c b/drivers/usb/gadget/legacy/audio.c
index 7b11dce98b94..dd81fd538cb8 100644
--- a/drivers/usb/gadget/legacy/audio.c
+++ b/drivers/usb/gadget/legacy/audio.c
@@ -4,8 +4,6 @@
  *
  * Copyright (C) 2008 Bryan Wu <cooloney@kernel.org>
  * Copyright (C) 2008 Analog Devices, Inc
- *
- * Enter bugs at http://blackfin.uclinux.org/
  */
 
 /* #define VERBOSE_DEBUG */

commit d7e285367916b0b57fc24b1c481ffbaa026019a3
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Nov 6 15:37:30 2017 +0100

    USB: gadget: legacy: Remove redundant license text
    
    Now that the SPDX tag is in all USB files, that identifies the license
    in a specific and legally-defined manner.  So the extra GPL text wording
    can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Johan Hovold <johan@kernel.org>
    Cc: Ruslan Bilovol <ruslan.bilovol@gmail.com>
    Cc: Peter Chen <peter.chen@nxp.com>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: David Windsor <dwindsor@gmail.com>
    Acked-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/gadget/legacy/audio.c b/drivers/usb/gadget/legacy/audio.c
index d0bffaa0bc09..7b11dce98b94 100644
--- a/drivers/usb/gadget/legacy/audio.c
+++ b/drivers/usb/gadget/legacy/audio.c
@@ -6,8 +6,6 @@
  * Copyright (C) 2008 Analog Devices, Inc
  *
  * Enter bugs at http://blackfin.uclinux.org/
- *
- * Licensed under the GPL-2 or later.
  */
 
 /* #define VERBOSE_DEBUG */

commit 5fd54ace4721fc5ce2bb5aef6318fcf17f421460
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Nov 3 11:28:30 2017 +0100

    USB: add SPDX identifiers to all remaining files in drivers/usb/
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/usb/ and include/linux/usb* files with the correct
    SPDX license identifier based on the license text in the file itself.
    The SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Acked-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/gadget/legacy/audio.c b/drivers/usb/gadget/legacy/audio.c
index 1f5cdbe162df..d0bffaa0bc09 100644
--- a/drivers/usb/gadget/legacy/audio.c
+++ b/drivers/usb/gadget/legacy/audio.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  * audio.c -- Audio gadget driver
  *

commit 0591bc2360152f851e29246884805bb77a2c3b9d
Author: Ruslan Bilovol <ruslan.bilovol@gmail.com>
Date:   Sun Jun 18 16:23:54 2017 +0300

    usb: gadget: add f_uac1 variant based on a new u_audio api
    
    This patch adds a new function 'f_uac1'
    (f_uac1 with virtual "ALSA card") that
    uses recently created u_audio API. Comparing
    to legacy f_uac1 function implementation it
    doesn't require any real Audio codec to be
    present on the device. In f_uac1 audio
    streams are simply sinked to and sourced
    from a virtual ALSA sound card created
    using u_audio API.
    
    Legacy f_uac1 approach is to write audio
    samples directly to existing ALSA sound
    card
    
    f_uac1 approach is more generic/flexible
    one - create an ALSA sound card that
    represents USB Audio function and allows to
    be used by userspace application that
    may choose to do whatever it wants with the
    data received from the USB Host and choose
    to provide whatever it wants as audio data
    to the USB Host.
    
    f_uac1 also has capture support (gadget->host)
    thanks to easy implementation via u_audio.
    By default, capture interface has 48000kHz/2ch
    configuration, same as playback channel has.
    
    f_uac1 descriptors naming convention
    uses f_uac2 driver naming convention that
    makes it more common and meaningful.
    
    Comparing to f_uac1_legacy, the f_uac1 doesn't
    have volume/mute functionality. This is because
    the f_uac1 volume/mute feature unit was dummy
    implementation since that driver creation (2009)
    and never had any real volume control or mute
    functionality, so there is no any difference
    here.
    
    Since f_uac1 functionality, exposed
    interface to userspace (virtual ALSA card),
    input parameters are so different comparing
    to f_uac1_legacy, that there is no any
    reason to keep them in the same file/module,
    and separate function was created.
    
    g_audio can be built using one of existing
    UAC functions (f_uac1, f_uac1_legacy or f_uac2)
    
    Signed-off-by: Ruslan Bilovol <ruslan.bilovol@gmail.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/gadget/legacy/audio.c b/drivers/usb/gadget/legacy/audio.c
index bf5592a5b9e9..1f5cdbe162df 100644
--- a/drivers/usb/gadget/legacy/audio.c
+++ b/drivers/usb/gadget/legacy/audio.c
@@ -20,7 +20,7 @@
 
 USB_GADGET_COMPOSITE_OPTIONS();
 
-#ifndef CONFIG_GADGET_UAC1_LEGACY
+#ifndef CONFIG_GADGET_UAC1
 #include "u_uac2.h"
 
 /* Playback(USB-IN) Default Stereo - Fl/Fr */
@@ -53,6 +53,39 @@ static int c_ssize = UAC2_DEF_CSSIZE;
 module_param(c_ssize, uint, S_IRUGO);
 MODULE_PARM_DESC(c_ssize, "Capture Sample Size(bytes)");
 #else
+#ifndef CONFIG_GADGET_UAC1_LEGACY
+#include "u_uac1.h"
+
+/* Playback(USB-IN) Default Stereo - Fl/Fr */
+static int p_chmask = UAC1_DEF_PCHMASK;
+module_param(p_chmask, uint, S_IRUGO);
+MODULE_PARM_DESC(p_chmask, "Playback Channel Mask");
+
+/* Playback Default 48 KHz */
+static int p_srate = UAC1_DEF_PSRATE;
+module_param(p_srate, uint, S_IRUGO);
+MODULE_PARM_DESC(p_srate, "Playback Sampling Rate");
+
+/* Playback Default 16bits/sample */
+static int p_ssize = UAC1_DEF_PSSIZE;
+module_param(p_ssize, uint, S_IRUGO);
+MODULE_PARM_DESC(p_ssize, "Playback Sample Size(bytes)");
+
+/* Capture(USB-OUT) Default Stereo - Fl/Fr */
+static int c_chmask = UAC1_DEF_CCHMASK;
+module_param(c_chmask, uint, S_IRUGO);
+MODULE_PARM_DESC(c_chmask, "Capture Channel Mask");
+
+/* Capture Default 48 KHz */
+static int c_srate = UAC1_DEF_CSRATE;
+module_param(c_srate, uint, S_IRUGO);
+MODULE_PARM_DESC(c_srate, "Capture Sampling Rate");
+
+/* Capture Default 16bits/sample */
+static int c_ssize = UAC1_DEF_CSSIZE;
+module_param(c_ssize, uint, S_IRUGO);
+MODULE_PARM_DESC(c_ssize, "Capture Sample Size(bytes)");
+#else /* CONFIG_GADGET_UAC1_LEGACY */
 #include "u_uac1_legacy.h"
 
 static char *fn_play = FILE_PCM_PLAYBACK;
@@ -78,6 +111,7 @@ MODULE_PARM_DESC(req_count, "ISO OUT endpoint request count");
 static int audio_buf_size = UAC1_AUDIO_BUF_SIZE;
 module_param(audio_buf_size, int, S_IRUGO);
 MODULE_PARM_DESC(audio_buf_size, "Audio buffer size");
+#endif /* CONFIG_GADGET_UAC1_LEGACY */
 #endif
 
 /* string IDs are assigned dynamically */
@@ -99,7 +133,7 @@ static struct usb_gadget_strings *audio_strings[] = {
 	NULL,
 };
 
-#ifndef CONFIG_GADGET_UAC1_LEGACY
+#ifndef CONFIG_GADGET_UAC1
 static struct usb_function_instance *fi_uac2;
 static struct usb_function *f_uac2;
 #else
@@ -164,7 +198,7 @@ static int audio_do_config(struct usb_configuration *c)
 		c->bmAttributes |= USB_CONFIG_ATT_WAKEUP;
 	}
 
-#ifdef CONFIG_GADGET_UAC1_LEGACY
+#ifdef CONFIG_GADGET_UAC1
 	f_uac1 = usb_get_function(fi_uac1);
 	if (IS_ERR(f_uac1)) {
 		status = PTR_ERR(f_uac1);
@@ -204,24 +238,32 @@ static struct usb_configuration audio_config_driver = {
 
 static int audio_bind(struct usb_composite_dev *cdev)
 {
-#ifndef CONFIG_GADGET_UAC1_LEGACY
+#ifndef CONFIG_GADGET_UAC1
 	struct f_uac2_opts	*uac2_opts;
+#else
+#ifndef CONFIG_GADGET_UAC1_LEGACY
+	struct f_uac1_opts	*uac1_opts;
 #else
 	struct f_uac1_legacy_opts	*uac1_opts;
+#endif
 #endif
 	int			status;
 
-#ifndef CONFIG_GADGET_UAC1_LEGACY
+#ifndef CONFIG_GADGET_UAC1
 	fi_uac2 = usb_get_function_instance("uac2");
 	if (IS_ERR(fi_uac2))
 		return PTR_ERR(fi_uac2);
+#else
+#ifndef CONFIG_GADGET_UAC1_LEGACY
+	fi_uac1 = usb_get_function_instance("uac1");
 #else
 	fi_uac1 = usb_get_function_instance("uac1_legacy");
+#endif
 	if (IS_ERR(fi_uac1))
 		return PTR_ERR(fi_uac1);
 #endif
 
-#ifndef CONFIG_GADGET_UAC1_LEGACY
+#ifndef CONFIG_GADGET_UAC1
 	uac2_opts = container_of(fi_uac2, struct f_uac2_opts, func_inst);
 	uac2_opts->p_chmask = p_chmask;
 	uac2_opts->p_srate = p_srate;
@@ -231,6 +273,16 @@ static int audio_bind(struct usb_composite_dev *cdev)
 	uac2_opts->c_ssize = c_ssize;
 	uac2_opts->req_number = UAC2_DEF_REQ_NUM;
 #else
+#ifndef CONFIG_GADGET_UAC1_LEGACY
+	uac1_opts = container_of(fi_uac1, struct f_uac1_opts, func_inst);
+	uac1_opts->p_chmask = p_chmask;
+	uac1_opts->p_srate = p_srate;
+	uac1_opts->p_ssize = p_ssize;
+	uac1_opts->c_chmask = c_chmask;
+	uac1_opts->c_srate = c_srate;
+	uac1_opts->c_ssize = c_ssize;
+	uac1_opts->req_number = UAC1_DEF_REQ_NUM;
+#else /* CONFIG_GADGET_UAC1_LEGACY */
 	uac1_opts = container_of(fi_uac1, struct f_uac1_legacy_opts, func_inst);
 	uac1_opts->fn_play = fn_play;
 	uac1_opts->fn_cap = fn_cap;
@@ -238,6 +290,7 @@ static int audio_bind(struct usb_composite_dev *cdev)
 	uac1_opts->req_buf_size = req_buf_size;
 	uac1_opts->req_count = req_count;
 	uac1_opts->audio_buf_size = audio_buf_size;
+#endif /* CONFIG_GADGET_UAC1_LEGACY */
 #endif
 
 	status = usb_string_ids_tab(cdev, strings_dev);
@@ -269,7 +322,7 @@ static int audio_bind(struct usb_composite_dev *cdev)
 	kfree(otg_desc[0]);
 	otg_desc[0] = NULL;
 fail:
-#ifndef CONFIG_GADGET_UAC1_LEGACY
+#ifndef CONFIG_GADGET_UAC1
 	usb_put_function_instance(fi_uac2);
 #else
 	usb_put_function_instance(fi_uac1);
@@ -279,7 +332,7 @@ static int audio_bind(struct usb_composite_dev *cdev)
 
 static int audio_unbind(struct usb_composite_dev *cdev)
 {
-#ifdef CONFIG_GADGET_UAC1_LEGACY
+#ifdef CONFIG_GADGET_UAC1
 	if (!IS_ERR_OR_NULL(f_uac1))
 		usb_put_function(f_uac1);
 	if (!IS_ERR_OR_NULL(fi_uac1))

commit d355339eecd986648420e05f8c958fbc78dbb382
Author: Ruslan Bilovol <ruslan.bilovol@gmail.com>
Date:   Sun Jun 18 16:23:53 2017 +0300

    usb: gadget: function: make current f_uac1 implementation legacy
    
    Before introducing new f_uac1 function (with virtual
    ALSA card) make current implementation legacy.
    
    This includes renaming of existing files, some
    variables, config options and documentation
    
    Signed-off-by: Ruslan Bilovol <ruslan.bilovol@gmail.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/gadget/legacy/audio.c b/drivers/usb/gadget/legacy/audio.c
index 8a39f42a4d56..bf5592a5b9e9 100644
--- a/drivers/usb/gadget/legacy/audio.c
+++ b/drivers/usb/gadget/legacy/audio.c
@@ -20,7 +20,7 @@
 
 USB_GADGET_COMPOSITE_OPTIONS();
 
-#ifndef CONFIG_GADGET_UAC1
+#ifndef CONFIG_GADGET_UAC1_LEGACY
 #include "u_uac2.h"
 
 /* Playback(USB-IN) Default Stereo - Fl/Fr */
@@ -53,7 +53,7 @@ static int c_ssize = UAC2_DEF_CSSIZE;
 module_param(c_ssize, uint, S_IRUGO);
 MODULE_PARM_DESC(c_ssize, "Capture Sample Size(bytes)");
 #else
-#include "u_uac1.h"
+#include "u_uac1_legacy.h"
 
 static char *fn_play = FILE_PCM_PLAYBACK;
 module_param(fn_play, charp, S_IRUGO);
@@ -99,7 +99,7 @@ static struct usb_gadget_strings *audio_strings[] = {
 	NULL,
 };
 
-#ifndef CONFIG_GADGET_UAC1
+#ifndef CONFIG_GADGET_UAC1_LEGACY
 static struct usb_function_instance *fi_uac2;
 static struct usb_function *f_uac2;
 #else
@@ -125,7 +125,7 @@ static struct usb_device_descriptor device_desc = {
 
 	/* .bcdUSB = DYNAMIC */
 
-#ifdef CONFIG_GADGET_UAC1
+#ifdef CONFIG_GADGET_UAC1_LEGACY
 	.bDeviceClass =		USB_CLASS_PER_INTERFACE,
 	.bDeviceSubClass =	0,
 	.bDeviceProtocol =	0,
@@ -164,7 +164,7 @@ static int audio_do_config(struct usb_configuration *c)
 		c->bmAttributes |= USB_CONFIG_ATT_WAKEUP;
 	}
 
-#ifdef CONFIG_GADGET_UAC1
+#ifdef CONFIG_GADGET_UAC1_LEGACY
 	f_uac1 = usb_get_function(fi_uac1);
 	if (IS_ERR(f_uac1)) {
 		status = PTR_ERR(f_uac1);
@@ -204,24 +204,24 @@ static struct usb_configuration audio_config_driver = {
 
 static int audio_bind(struct usb_composite_dev *cdev)
 {
-#ifndef CONFIG_GADGET_UAC1
+#ifndef CONFIG_GADGET_UAC1_LEGACY
 	struct f_uac2_opts	*uac2_opts;
 #else
-	struct f_uac1_opts	*uac1_opts;
+	struct f_uac1_legacy_opts	*uac1_opts;
 #endif
 	int			status;
 
-#ifndef CONFIG_GADGET_UAC1
+#ifndef CONFIG_GADGET_UAC1_LEGACY
 	fi_uac2 = usb_get_function_instance("uac2");
 	if (IS_ERR(fi_uac2))
 		return PTR_ERR(fi_uac2);
 #else
-	fi_uac1 = usb_get_function_instance("uac1");
+	fi_uac1 = usb_get_function_instance("uac1_legacy");
 	if (IS_ERR(fi_uac1))
 		return PTR_ERR(fi_uac1);
 #endif
 
-#ifndef CONFIG_GADGET_UAC1
+#ifndef CONFIG_GADGET_UAC1_LEGACY
 	uac2_opts = container_of(fi_uac2, struct f_uac2_opts, func_inst);
 	uac2_opts->p_chmask = p_chmask;
 	uac2_opts->p_srate = p_srate;
@@ -231,7 +231,7 @@ static int audio_bind(struct usb_composite_dev *cdev)
 	uac2_opts->c_ssize = c_ssize;
 	uac2_opts->req_number = UAC2_DEF_REQ_NUM;
 #else
-	uac1_opts = container_of(fi_uac1, struct f_uac1_opts, func_inst);
+	uac1_opts = container_of(fi_uac1, struct f_uac1_legacy_opts, func_inst);
 	uac1_opts->fn_play = fn_play;
 	uac1_opts->fn_cap = fn_cap;
 	uac1_opts->fn_cntl = fn_cntl;
@@ -269,7 +269,7 @@ static int audio_bind(struct usb_composite_dev *cdev)
 	kfree(otg_desc[0]);
 	otg_desc[0] = NULL;
 fail:
-#ifndef CONFIG_GADGET_UAC1
+#ifndef CONFIG_GADGET_UAC1_LEGACY
 	usb_put_function_instance(fi_uac2);
 #else
 	usb_put_function_instance(fi_uac1);
@@ -279,7 +279,7 @@ static int audio_bind(struct usb_composite_dev *cdev)
 
 static int audio_unbind(struct usb_composite_dev *cdev)
 {
-#ifdef CONFIG_GADGET_UAC1
+#ifdef CONFIG_GADGET_UAC1_LEGACY
 	if (!IS_ERR_OR_NULL(f_uac1))
 		usb_put_function(f_uac1);
 	if (!IS_ERR_OR_NULL(fi_uac1))

commit e92b9d449d0490800160bfeb5ee1175a02979f47
Author: Peter Chen <peter.chen@nxp.com>
Date:   Wed Jan 4 10:19:23 2017 +0800

    usb: gadget: uac2: add req_number as parameter
    
    There are only two requests for uac2, it may not be enough at high
    loading system which usb interrupt handler can't be serviced on
    time, then the data will be lost since it is isoc transfer for audio.
    
    In this patch, we introduce a parameter for the number for usb request,
    and the user can override it if current number for request is not enough
    for his/her use case.
    
    Besides, update this parameter for legacy audio gadget and documentation.
    
    Signed-off-by: Peter Chen <peter.chen@nxp.com>
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>

diff --git a/drivers/usb/gadget/legacy/audio.c b/drivers/usb/gadget/legacy/audio.c
index 5d7b3c6a422b..8a39f42a4d56 100644
--- a/drivers/usb/gadget/legacy/audio.c
+++ b/drivers/usb/gadget/legacy/audio.c
@@ -229,6 +229,7 @@ static int audio_bind(struct usb_composite_dev *cdev)
 	uac2_opts->c_chmask = c_chmask;
 	uac2_opts->c_srate = c_srate;
 	uac2_opts->c_ssize = c_ssize;
+	uac2_opts->req_number = UAC2_DEF_REQ_NUM;
 #else
 	uac1_opts = container_of(fi_uac1, struct f_uac1_opts, func_inst);
 	uac1_opts->fn_play = fn_play;

commit 0aecfc1b359dffddf74bd0e0ea5ee47066d210ac
Author: Igor Kotrasinski <i.kotrasinsk@samsung.com>
Date:   Tue Oct 20 18:33:13 2015 +0200

    usb: gadget: composite: remove redundant bcdUSB setting in legacy
    
    Since composite now overwrites bcdUSB for any gadget, remove
    setting it in legacy gadgets. All legacy gadgets set 0x0200, the
    same as the value additionally set by composite, so there is no
    behaviour change.
    
    Signed-off-by: Igor Kotrasinski <i.kotrasinsk@samsung.com>
    
    Rebase onto current balbi/next
    
    Signed-off-by: Krzysztof Opasiak <k.opasiak@samsung.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/legacy/audio.c b/drivers/usb/gadget/legacy/audio.c
index 685cf3b4b78f..5d7b3c6a422b 100644
--- a/drivers/usb/gadget/legacy/audio.c
+++ b/drivers/usb/gadget/legacy/audio.c
@@ -123,7 +123,7 @@ static struct usb_device_descriptor device_desc = {
 	.bLength =		sizeof device_desc,
 	.bDescriptorType =	USB_DT_DEVICE,
 
-	.bcdUSB =		cpu_to_le16(0x200),
+	/* .bcdUSB = DYNAMIC */
 
 #ifdef CONFIG_GADGET_UAC1
 	.bDeviceClass =		USB_CLASS_PER_INTERFACE,

commit adab43396ed4830c7cee29837e8cedcddb2b5315
Author: Robert Baldyga <r.baldyga@samsung.com>
Date:   Thu Aug 6 14:11:16 2015 +0200

    usb: gadget: remove gadget_chips.h
    
    This header file contains helpers for quirks based on UDC controller name.
    Since we have generic quirk bitfields in usb_gadget structure for all of
    these quirks we don't need to have this header any longer.
    
    This patch removes gadget_chips.h file and makes sure that it's no longer
    included anywhere in kernel sources.
    
    Signed-off-by: Robert Baldyga <r.baldyga@samsung.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/legacy/audio.c b/drivers/usb/gadget/legacy/audio.c
index 9b2c1c68746b..685cf3b4b78f 100644
--- a/drivers/usb/gadget/legacy/audio.c
+++ b/drivers/usb/gadget/legacy/audio.c
@@ -15,7 +15,6 @@
 #include <linux/module.h>
 #include <linux/usb/composite.h>
 
-#include "gadget_chips.h"
 #define DRIVER_DESC		"Linux USB Audio Gadget"
 #define DRIVER_VERSION		"Feb 2, 2012"
 

commit 56023ce0fd7025154494d139b2c9891d75fee622
Author: Li Jun <jun.li@freescale.com>
Date:   Thu Jul 9 15:18:51 2015 +0800

    usb: gadget: audio: allocate and init otg descriptor by otg capabilities
    
    Allocate and initialize usb otg descriptor according to gadget otg
    capabilities, add it for each usb configurations. If otg capability
    is not defined, keep its original otg descriptor unchanged.
    
    Signed-off-by: Li Jun <jun.li@freescale.com>
    Reviewed-by: Roger Quadros <rogerq@ti.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/legacy/audio.c b/drivers/usb/gadget/legacy/audio.c
index b8095bfe57b6..9b2c1c68746b 100644
--- a/drivers/usb/gadget/legacy/audio.c
+++ b/drivers/usb/gadget/legacy/audio.c
@@ -150,20 +150,7 @@ static struct usb_device_descriptor device_desc = {
 	.bNumConfigurations =	1,
 };
 
-static struct usb_otg_descriptor otg_descriptor = {
-	.bLength =		sizeof otg_descriptor,
-	.bDescriptorType =	USB_DT_OTG,
-
-	/* REVISIT SRP-only hardware is possible, although
-	 * it would not be called "OTG" ...
-	 */
-	.bmAttributes =		USB_OTG_SRP | USB_OTG_HNP,
-};
-
-static const struct usb_descriptor_header *otg_desc[] = {
-	(struct usb_descriptor_header *) &otg_descriptor,
-	NULL,
-};
+static const struct usb_descriptor_header *otg_desc[2];
 
 /*-------------------------------------------------------------------------*/
 
@@ -259,14 +246,28 @@ static int audio_bind(struct usb_composite_dev *cdev)
 	device_desc.iManufacturer = strings_dev[USB_GADGET_MANUFACTURER_IDX].id;
 	device_desc.iProduct = strings_dev[USB_GADGET_PRODUCT_IDX].id;
 
+	if (gadget_is_otg(cdev->gadget) && !otg_desc[0]) {
+		struct usb_descriptor_header *usb_desc;
+
+		usb_desc = usb_otg_descriptor_alloc(cdev->gadget);
+		if (!usb_desc)
+			goto fail;
+		usb_otg_descriptor_init(cdev->gadget, usb_desc);
+		otg_desc[0] = usb_desc;
+		otg_desc[1] = NULL;
+	}
+
 	status = usb_add_config(cdev, &audio_config_driver, audio_do_config);
 	if (status < 0)
-		goto fail;
+		goto fail_otg_desc;
 	usb_composite_overwrite_options(cdev, &coverwrite);
 
 	INFO(cdev, "%s, version: %s\n", DRIVER_DESC, DRIVER_VERSION);
 	return 0;
 
+fail_otg_desc:
+	kfree(otg_desc[0]);
+	otg_desc[0] = NULL;
 fail:
 #ifndef CONFIG_GADGET_UAC1
 	usb_put_function_instance(fi_uac2);
@@ -289,6 +290,9 @@ static int audio_unbind(struct usb_composite_dev *cdev)
 	if (!IS_ERR_OR_NULL(fi_uac2))
 		usb_put_function_instance(fi_uac2);
 #endif
+	kfree(otg_desc[0]);
+	otg_desc[0] = NULL;
+
 	return 0;
 }
 

commit b8464bcf0a20970471e8f897fe4706fcc2702263
Author: Vaishali Thakkar <vthakkar1994@gmail.com>
Date:   Sat Jun 6 07:02:53 2015 +0530

    usb: gadget: Convert use of __constant_cpu_to_le16 to cpu_to_le16
    
    In big endian cases, macro cpu_to_le16 unfolds to __swab16 which
    provides special case for constants. In little endian cases,
    __constant_cpu_to_le16 and cpu_to_le16 expand directly to the
    same expression. So, replace __constant_cpu_to_le16 with
    cpu_to_le16 with the goal of getting rid of the definition of
    __constant_cpu_to_le16 completely.
    
    The semantic patch that performs this transformation is as follows:
    
    @@expression x;@@
    
    - __constant_cpu_to_le16(x)
    + cpu_to_le16(x)
    
    Signed-off-by: Vaishali Thakkar <vthakkar1994@gmail.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/legacy/audio.c b/drivers/usb/gadget/legacy/audio.c
index f289caf18a45..b8095bfe57b6 100644
--- a/drivers/usb/gadget/legacy/audio.c
+++ b/drivers/usb/gadget/legacy/audio.c
@@ -124,7 +124,7 @@ static struct usb_device_descriptor device_desc = {
 	.bLength =		sizeof device_desc,
 	.bDescriptorType =	USB_DT_DEVICE,
 
-	.bcdUSB =		__constant_cpu_to_le16(0x200),
+	.bcdUSB =		cpu_to_le16(0x200),
 
 #ifdef CONFIG_GADGET_UAC1
 	.bDeviceClass =		USB_CLASS_PER_INTERFACE,
@@ -141,8 +141,8 @@ static struct usb_device_descriptor device_desc = {
 	 * we support.  (As does bNumConfigurations.)  These values can
 	 * also be overridden by module parameters.
 	 */
-	.idVendor =		__constant_cpu_to_le16(AUDIO_VENDOR_NUM),
-	.idProduct =		__constant_cpu_to_le16(AUDIO_PRODUCT_NUM),
+	.idVendor =		cpu_to_le16(AUDIO_VENDOR_NUM),
+	.idProduct =		cpu_to_le16(AUDIO_PRODUCT_NUM),
 	/* .bcdDevice = f(hardware) */
 	/* .iManufacturer = DYNAMIC */
 	/* .iProduct = DYNAMIC */

commit c94e289f195e0e13cf34d27f9338d28221a85751
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Sat Apr 11 00:14:21 2015 +0200

    usb: gadget: remove incorrect __init/__exit annotations
    
    A recent change introduced a link error for the composite
    printer gadget driver:
    
    `printer_unbind' referenced in section `.ref.data' of drivers/built-in.o: defined in discarded section `.exit.text' of drivers/built-in.o
    
    Evidently the unbind function should not be marked __exit here,
    because it is called through a callback pointer that is not necessarily
    discarded, __composite_unbind() is indeed called from the error path of
    composite_bind(), which can never work for a built-in driver.
    
    Looking at the surrounding code, I found the same problem in all other
    composite gadget drivers in both the bind and unbind functions, as
    well as the udc platform driver 'remove' functions. Those will break
    if anyone uses the 'unbind' sysfs attribute to detach a device from a
    built-in driver.
    
    This patch removes the incorrect annotations from all the gadget
    drivers.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/legacy/audio.c b/drivers/usb/gadget/legacy/audio.c
index f46a3956e43d..f289caf18a45 100644
--- a/drivers/usb/gadget/legacy/audio.c
+++ b/drivers/usb/gadget/legacy/audio.c
@@ -167,7 +167,7 @@ static const struct usb_descriptor_header *otg_desc[] = {
 
 /*-------------------------------------------------------------------------*/
 
-static int __init audio_do_config(struct usb_configuration *c)
+static int audio_do_config(struct usb_configuration *c)
 {
 	int status;
 
@@ -216,7 +216,7 @@ static struct usb_configuration audio_config_driver = {
 
 /*-------------------------------------------------------------------------*/
 
-static int __init audio_bind(struct usb_composite_dev *cdev)
+static int audio_bind(struct usb_composite_dev *cdev)
 {
 #ifndef CONFIG_GADGET_UAC1
 	struct f_uac2_opts	*uac2_opts;
@@ -276,7 +276,7 @@ static int __init audio_bind(struct usb_composite_dev *cdev)
 	return status;
 }
 
-static int __exit audio_unbind(struct usb_composite_dev *cdev)
+static int audio_unbind(struct usb_composite_dev *cdev)
 {
 #ifdef CONFIG_GADGET_UAC1
 	if (!IS_ERR_OR_NULL(f_uac1))
@@ -292,13 +292,13 @@ static int __exit audio_unbind(struct usb_composite_dev *cdev)
 	return 0;
 }
 
-static __refdata struct usb_composite_driver audio_driver = {
+static struct usb_composite_driver audio_driver = {
 	.name		= "g_audio",
 	.dev		= &device_desc,
 	.strings	= audio_strings,
 	.max_speed	= USB_SPEED_HIGH,
 	.bind		= audio_bind,
-	.unbind		= __exit_p(audio_unbind),
+	.unbind		= audio_unbind,
 };
 
 module_usb_composite_driver(audio_driver);

commit bcec9784dd78abfa9d8ca8b7144f6e37ea6abfd5
Author: Andrzej Pietrasiewicz <andrzej.p@samsung.com>
Date:   Tue Jul 22 19:58:42 2014 +0200

    usb: gadget: f_uac1: use defined constants as defaults
    
    When configfs support is added the values in question will have to be
    used in two different places. Substitute them with defined constants
    to avoid duplicating magic numbers.
    
    Tested-by: Sebastian Reimers <sebastian.reimers@googlemail.com>
    Signed-off-by: Andrzej Pietrasiewicz <andrzej.p@samsung.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/legacy/audio.c b/drivers/usb/gadget/legacy/audio.c
index bb40b61e2555..f46a3956e43d 100644
--- a/drivers/usb/gadget/legacy/audio.c
+++ b/drivers/usb/gadget/legacy/audio.c
@@ -54,9 +54,7 @@ static int c_ssize = UAC2_DEF_CSSIZE;
 module_param(c_ssize, uint, S_IRUGO);
 MODULE_PARM_DESC(c_ssize, "Capture Sample Size(bytes)");
 #else
-#define FILE_PCM_PLAYBACK	"/dev/snd/pcmC0D0p"
-#define FILE_PCM_CAPTURE	"/dev/snd/pcmC0D0c"
-#define FILE_CONTROL		"/dev/snd/controlC0"
+#include "u_uac1.h"
 
 static char *fn_play = FILE_PCM_PLAYBACK;
 module_param(fn_play, charp, S_IRUGO);
@@ -70,16 +68,15 @@ static char *fn_cntl = FILE_CONTROL;
 module_param(fn_cntl, charp, S_IRUGO);
 MODULE_PARM_DESC(fn_cntl, "Control device file name");
 
-#define OUT_EP_MAX_PACKET_SIZE	200
-static int req_buf_size = OUT_EP_MAX_PACKET_SIZE;
+static int req_buf_size = UAC1_OUT_EP_MAX_PACKET_SIZE;
 module_param(req_buf_size, int, S_IRUGO);
 MODULE_PARM_DESC(req_buf_size, "ISO OUT endpoint request buffer size");
 
-static int req_count = 256;
+static int req_count = UAC1_REQ_COUNT;
 module_param(req_count, int, S_IRUGO);
 MODULE_PARM_DESC(req_count, "ISO OUT endpoint request count");
 
-static int audio_buf_size = 48000;
+static int audio_buf_size = UAC1_AUDIO_BUF_SIZE;
 module_param(audio_buf_size, int, S_IRUGO);
 MODULE_PARM_DESC(audio_buf_size, "Audio buffer size");
 #endif
@@ -111,10 +108,6 @@ static struct usb_function_instance *fi_uac1;
 static struct usb_function *f_uac1;
 #endif
 
-#ifdef CONFIG_GADGET_UAC1
-#include "u_uac1.h"
-#endif
-
 /*-------------------------------------------------------------------------*/
 
 /* DO NOT REUSE THESE IDs with a protocol-incompatible driver!!  Ever!!

commit 0d992dec967d6edc97b3001598db7c4ac4e4b3c1
Author: Andrzej Pietrasiewicz <andrzej.p@samsung.com>
Date:   Tue Jul 22 19:58:39 2014 +0200

    usb: gadget: audio: convert to new interface of f_uac1
    
    Use the new interface so that the old one can be removed.
    
    Tested-by: Sebastian Reimers <sebastian.reimers@googlemail.com>
    Signed-off-by: Andrzej Pietrasiewicz <andrzej.p@samsung.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/legacy/audio.c b/drivers/usb/gadget/legacy/audio.c
index cf1a5434feaf..bb40b61e2555 100644
--- a/drivers/usb/gadget/legacy/audio.c
+++ b/drivers/usb/gadget/legacy/audio.c
@@ -53,6 +53,35 @@ MODULE_PARM_DESC(c_srate, "Capture Sampling Rate");
 static int c_ssize = UAC2_DEF_CSSIZE;
 module_param(c_ssize, uint, S_IRUGO);
 MODULE_PARM_DESC(c_ssize, "Capture Sample Size(bytes)");
+#else
+#define FILE_PCM_PLAYBACK	"/dev/snd/pcmC0D0p"
+#define FILE_PCM_CAPTURE	"/dev/snd/pcmC0D0c"
+#define FILE_CONTROL		"/dev/snd/controlC0"
+
+static char *fn_play = FILE_PCM_PLAYBACK;
+module_param(fn_play, charp, S_IRUGO);
+MODULE_PARM_DESC(fn_play, "Playback PCM device file name");
+
+static char *fn_cap = FILE_PCM_CAPTURE;
+module_param(fn_cap, charp, S_IRUGO);
+MODULE_PARM_DESC(fn_cap, "Capture PCM device file name");
+
+static char *fn_cntl = FILE_CONTROL;
+module_param(fn_cntl, charp, S_IRUGO);
+MODULE_PARM_DESC(fn_cntl, "Control device file name");
+
+#define OUT_EP_MAX_PACKET_SIZE	200
+static int req_buf_size = OUT_EP_MAX_PACKET_SIZE;
+module_param(req_buf_size, int, S_IRUGO);
+MODULE_PARM_DESC(req_buf_size, "ISO OUT endpoint request buffer size");
+
+static int req_count = 256;
+module_param(req_count, int, S_IRUGO);
+MODULE_PARM_DESC(req_count, "ISO OUT endpoint request count");
+
+static int audio_buf_size = 48000;
+module_param(audio_buf_size, int, S_IRUGO);
+MODULE_PARM_DESC(audio_buf_size, "Audio buffer size");
 #endif
 
 /* string IDs are assigned dynamically */
@@ -77,12 +106,13 @@ static struct usb_gadget_strings *audio_strings[] = {
 #ifndef CONFIG_GADGET_UAC1
 static struct usb_function_instance *fi_uac2;
 static struct usb_function *f_uac2;
+#else
+static struct usb_function_instance *fi_uac1;
+static struct usb_function *f_uac1;
 #endif
 
 #ifdef CONFIG_GADGET_UAC1
-#define USBF_UAC1_INCLUDED
 #include "u_uac1.h"
-#include "f_uac1.c"
 #endif
 
 /*-------------------------------------------------------------------------*/
@@ -146,9 +176,7 @@ static const struct usb_descriptor_header *otg_desc[] = {
 
 static int __init audio_do_config(struct usb_configuration *c)
 {
-#ifndef CONFIG_GADGET_UAC1
 	int status;
-#endif
 
 	/* FIXME alloc iConfiguration string, set it in c->strings */
 
@@ -158,7 +186,17 @@ static int __init audio_do_config(struct usb_configuration *c)
 	}
 
 #ifdef CONFIG_GADGET_UAC1
-	audio_bind_config(c);
+	f_uac1 = usb_get_function(fi_uac1);
+	if (IS_ERR(f_uac1)) {
+		status = PTR_ERR(f_uac1);
+		return status;
+	}
+
+	status = usb_add_function(c, f_uac1);
+	if (status < 0) {
+		usb_put_function(f_uac1);
+		return status;
+	}
 #else
 	f_uac2 = usb_get_function(fi_uac2);
 	if (IS_ERR(f_uac2)) {
@@ -189,6 +227,8 @@ static int __init audio_bind(struct usb_composite_dev *cdev)
 {
 #ifndef CONFIG_GADGET_UAC1
 	struct f_uac2_opts	*uac2_opts;
+#else
+	struct f_uac1_opts	*uac1_opts;
 #endif
 	int			status;
 
@@ -196,6 +236,10 @@ static int __init audio_bind(struct usb_composite_dev *cdev)
 	fi_uac2 = usb_get_function_instance("uac2");
 	if (IS_ERR(fi_uac2))
 		return PTR_ERR(fi_uac2);
+#else
+	fi_uac1 = usb_get_function_instance("uac1");
+	if (IS_ERR(fi_uac1))
+		return PTR_ERR(fi_uac1);
 #endif
 
 #ifndef CONFIG_GADGET_UAC1
@@ -206,6 +250,14 @@ static int __init audio_bind(struct usb_composite_dev *cdev)
 	uac2_opts->c_chmask = c_chmask;
 	uac2_opts->c_srate = c_srate;
 	uac2_opts->c_ssize = c_ssize;
+#else
+	uac1_opts = container_of(fi_uac1, struct f_uac1_opts, func_inst);
+	uac1_opts->fn_play = fn_play;
+	uac1_opts->fn_cap = fn_cap;
+	uac1_opts->fn_cntl = fn_cntl;
+	uac1_opts->req_buf_size = req_buf_size;
+	uac1_opts->req_count = req_count;
+	uac1_opts->audio_buf_size = audio_buf_size;
 #endif
 
 	status = usb_string_ids_tab(cdev, strings_dev);
@@ -225,6 +277,8 @@ static int __init audio_bind(struct usb_composite_dev *cdev)
 fail:
 #ifndef CONFIG_GADGET_UAC1
 	usb_put_function_instance(fi_uac2);
+#else
+	usb_put_function_instance(fi_uac1);
 #endif
 	return status;
 }
@@ -232,7 +286,10 @@ static int __init audio_bind(struct usb_composite_dev *cdev)
 static int __exit audio_unbind(struct usb_composite_dev *cdev)
 {
 #ifdef CONFIG_GADGET_UAC1
-	gaudio_cleanup();
+	if (!IS_ERR_OR_NULL(f_uac1))
+		usb_put_function(f_uac1);
+	if (!IS_ERR_OR_NULL(fi_uac1))
+		usb_put_function_instance(fi_uac1);
 #else
 	if (!IS_ERR_OR_NULL(f_uac2))
 		usb_put_function(f_uac2);

commit f3a3406b3f562f8d15b89979c0ca9e184b269084
Author: Andrzej Pietrasiewicz <andrzej.p@samsung.com>
Date:   Tue Jul 22 19:58:38 2014 +0200

    usb: gadget: f_uac1: convert to new function interface with backward compatibility
    
    Converting uac1 to the new function interface requires converting
    the USB uac1's function code and its users.
    
    This patch converts the f_uac1.c to the new function interface.
    
    The file is now compiled into a separate usb_f_uac1.ko module.
    
    The old function interface is provided by means of a preprocessor
    conditional directives. After all users are converted, the old interface
    can be removed.
    
    Tested-by: Sebastian Reimers <sebastian.reimers@googlemail.com>
    Signed-off-by: Andrzej Pietrasiewicz <andrzej.p@samsung.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/legacy/audio.c b/drivers/usb/gadget/legacy/audio.c
index 47a7de71f7fb..cf1a5434feaf 100644
--- a/drivers/usb/gadget/legacy/audio.c
+++ b/drivers/usb/gadget/legacy/audio.c
@@ -80,6 +80,7 @@ static struct usb_function *f_uac2;
 #endif
 
 #ifdef CONFIG_GADGET_UAC1
+#define USBF_UAC1_INCLUDED
 #include "u_uac1.h"
 #include "f_uac1.c"
 #endif

commit af1a58ca00b3735275c453ebd0b811a71a377470
Author: Andrzej Pietrasiewicz <andrzej.p@samsung.com>
Date:   Tue Jul 22 19:58:37 2014 +0200

    usb: gadget: f_uac1: prepare for separate compilation
    
    Integrating configfs requires converting f_uac1 to new function interface,
    which in turn requires converting it to the new function interface,
    which involves separate compilation of f_uac1.c into usb_f_uac1.ko.
    u_uac1.c contains some module parameters. After this patch is applied
    they are still a part of the resulting g_audio.ko, but can be guarded
    with a compatiblity flag which will be removed when no users of the old
    function interface of f_uac1 are left.
    
    Tested-by: Sebastian Reimers <sebastian.reimers@googlemail.com>
    Signed-off-by: Andrzej Pietrasiewicz <andrzej.p@samsung.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/legacy/audio.c b/drivers/usb/gadget/legacy/audio.c
index c28691fbb576..47a7de71f7fb 100644
--- a/drivers/usb/gadget/legacy/audio.c
+++ b/drivers/usb/gadget/legacy/audio.c
@@ -81,7 +81,6 @@ static struct usb_function *f_uac2;
 
 #ifdef CONFIG_GADGET_UAC1
 #include "u_uac1.h"
-#include "u_uac1.c"
 #include "f_uac1.c"
 #endif
 

commit 065a107cdd70f0621011424009b3ecd4e42481b1
Author: Andrzej Pietrasiewicz <andrzej.p@samsung.com>
Date:   Tue Jul 22 19:58:34 2014 +0200

    usb: gadget: f_uac2: use defined constants as defaults
    
    When configfs is integrated the same values will have to be used
    as defaults. Use symbolic names in order not to duplicate magic numbers.
    
    Tested-by: Sebastian Reimers <sebastian.reimers@googlemail.com>
    Signed-off-by: Andrzej Pietrasiewicz <andrzej.p@samsung.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/legacy/audio.c b/drivers/usb/gadget/legacy/audio.c
index 159af0345986..c28691fbb576 100644
--- a/drivers/usb/gadget/legacy/audio.c
+++ b/drivers/usb/gadget/legacy/audio.c
@@ -22,33 +22,35 @@
 USB_GADGET_COMPOSITE_OPTIONS();
 
 #ifndef CONFIG_GADGET_UAC1
+#include "u_uac2.h"
+
 /* Playback(USB-IN) Default Stereo - Fl/Fr */
-static int p_chmask = 0x3;
+static int p_chmask = UAC2_DEF_PCHMASK;
 module_param(p_chmask, uint, S_IRUGO);
 MODULE_PARM_DESC(p_chmask, "Playback Channel Mask");
 
 /* Playback Default 48 KHz */
-static int p_srate = 48000;
+static int p_srate = UAC2_DEF_PSRATE;
 module_param(p_srate, uint, S_IRUGO);
 MODULE_PARM_DESC(p_srate, "Playback Sampling Rate");
 
 /* Playback Default 16bits/sample */
-static int p_ssize = 2;
+static int p_ssize = UAC2_DEF_PSSIZE;
 module_param(p_ssize, uint, S_IRUGO);
 MODULE_PARM_DESC(p_ssize, "Playback Sample Size(bytes)");
 
 /* Capture(USB-OUT) Default Stereo - Fl/Fr */
-static int c_chmask = 0x3;
+static int c_chmask = UAC2_DEF_CCHMASK;
 module_param(c_chmask, uint, S_IRUGO);
 MODULE_PARM_DESC(c_chmask, "Capture Channel Mask");
 
 /* Capture Default 64 KHz */
-static int c_srate = 64000;
+static int c_srate = UAC2_DEF_CSRATE;
 module_param(c_srate, uint, S_IRUGO);
 MODULE_PARM_DESC(c_srate, "Capture Sampling Rate");
 
 /* Capture Default 16bits/sample */
-static int c_ssize = 2;
+static int c_ssize = UAC2_DEF_CSSIZE;
 module_param(c_ssize, uint, S_IRUGO);
 MODULE_PARM_DESC(c_ssize, "Capture Sample Size(bytes)");
 #endif
@@ -81,8 +83,6 @@ static struct usb_function *f_uac2;
 #include "u_uac1.h"
 #include "u_uac1.c"
 #include "f_uac1.c"
-#else
-#include "u_uac2.h"
 #endif
 
 /*-------------------------------------------------------------------------*/

commit ad94ac0cfdb6e28a2b0da740d2482a7306e947c3
Author: Andrzej Pietrasiewicz <andrzej.p@samsung.com>
Date:   Tue Jul 22 19:58:31 2014 +0200

    usb: gadget: audio: convert to new interface of f_uac2
    
    Use the new interface so that the old one can be removed.
    
    Tested-by: Sebastian Reimers <sebastian.reimers@googlemail.com>
    Signed-off-by: Andrzej Pietrasiewicz <andrzej.p@samsung.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/legacy/audio.c b/drivers/usb/gadget/legacy/audio.c
index a41316bb436a..159af0345986 100644
--- a/drivers/usb/gadget/legacy/audio.c
+++ b/drivers/usb/gadget/legacy/audio.c
@@ -21,6 +21,38 @@
 
 USB_GADGET_COMPOSITE_OPTIONS();
 
+#ifndef CONFIG_GADGET_UAC1
+/* Playback(USB-IN) Default Stereo - Fl/Fr */
+static int p_chmask = 0x3;
+module_param(p_chmask, uint, S_IRUGO);
+MODULE_PARM_DESC(p_chmask, "Playback Channel Mask");
+
+/* Playback Default 48 KHz */
+static int p_srate = 48000;
+module_param(p_srate, uint, S_IRUGO);
+MODULE_PARM_DESC(p_srate, "Playback Sampling Rate");
+
+/* Playback Default 16bits/sample */
+static int p_ssize = 2;
+module_param(p_ssize, uint, S_IRUGO);
+MODULE_PARM_DESC(p_ssize, "Playback Sample Size(bytes)");
+
+/* Capture(USB-OUT) Default Stereo - Fl/Fr */
+static int c_chmask = 0x3;
+module_param(c_chmask, uint, S_IRUGO);
+MODULE_PARM_DESC(c_chmask, "Capture Channel Mask");
+
+/* Capture Default 64 KHz */
+static int c_srate = 64000;
+module_param(c_srate, uint, S_IRUGO);
+MODULE_PARM_DESC(c_srate, "Capture Sampling Rate");
+
+/* Capture Default 16bits/sample */
+static int c_ssize = 2;
+module_param(c_ssize, uint, S_IRUGO);
+MODULE_PARM_DESC(c_ssize, "Capture Sample Size(bytes)");
+#endif
+
 /* string IDs are assigned dynamically */
 
 static struct usb_string strings_dev[] = {
@@ -40,13 +72,17 @@ static struct usb_gadget_strings *audio_strings[] = {
 	NULL,
 };
 
+#ifndef CONFIG_GADGET_UAC1
+static struct usb_function_instance *fi_uac2;
+static struct usb_function *f_uac2;
+#endif
+
 #ifdef CONFIG_GADGET_UAC1
 #include "u_uac1.h"
 #include "u_uac1.c"
 #include "f_uac1.c"
 #else
-#define USB_FUAC2_INCLUDED
-#include "f_uac2.c"
+#include "u_uac2.h"
 #endif
 
 /*-------------------------------------------------------------------------*/
@@ -110,6 +146,10 @@ static const struct usb_descriptor_header *otg_desc[] = {
 
 static int __init audio_do_config(struct usb_configuration *c)
 {
+#ifndef CONFIG_GADGET_UAC1
+	int status;
+#endif
+
 	/* FIXME alloc iConfiguration string, set it in c->strings */
 
 	if (gadget_is_otg(c->cdev->gadget)) {
@@ -117,7 +157,21 @@ static int __init audio_do_config(struct usb_configuration *c)
 		c->bmAttributes |= USB_CONFIG_ATT_WAKEUP;
 	}
 
+#ifdef CONFIG_GADGET_UAC1
 	audio_bind_config(c);
+#else
+	f_uac2 = usb_get_function(fi_uac2);
+	if (IS_ERR(f_uac2)) {
+		status = PTR_ERR(f_uac2);
+		return status;
+	}
+
+	status = usb_add_function(c, f_uac2);
+	if (status < 0) {
+		usb_put_function(f_uac2);
+		return status;
+	}
+#endif
 
 	return 0;
 }
@@ -133,8 +187,27 @@ static struct usb_configuration audio_config_driver = {
 
 static int __init audio_bind(struct usb_composite_dev *cdev)
 {
+#ifndef CONFIG_GADGET_UAC1
+	struct f_uac2_opts	*uac2_opts;
+#endif
 	int			status;
 
+#ifndef CONFIG_GADGET_UAC1
+	fi_uac2 = usb_get_function_instance("uac2");
+	if (IS_ERR(fi_uac2))
+		return PTR_ERR(fi_uac2);
+#endif
+
+#ifndef CONFIG_GADGET_UAC1
+	uac2_opts = container_of(fi_uac2, struct f_uac2_opts, func_inst);
+	uac2_opts->p_chmask = p_chmask;
+	uac2_opts->p_srate = p_srate;
+	uac2_opts->p_ssize = p_ssize;
+	uac2_opts->c_chmask = c_chmask;
+	uac2_opts->c_srate = c_srate;
+	uac2_opts->c_ssize = c_ssize;
+#endif
+
 	status = usb_string_ids_tab(cdev, strings_dev);
 	if (status < 0)
 		goto fail;
@@ -150,6 +223,9 @@ static int __init audio_bind(struct usb_composite_dev *cdev)
 	return 0;
 
 fail:
+#ifndef CONFIG_GADGET_UAC1
+	usb_put_function_instance(fi_uac2);
+#endif
 	return status;
 }
 
@@ -157,6 +233,11 @@ static int __exit audio_unbind(struct usb_composite_dev *cdev)
 {
 #ifdef CONFIG_GADGET_UAC1
 	gaudio_cleanup();
+#else
+	if (!IS_ERR_OR_NULL(f_uac2))
+		usb_put_function(f_uac2);
+	if (!IS_ERR_OR_NULL(fi_uac2))
+		usb_put_function_instance(fi_uac2);
 #endif
 	return 0;
 }

commit f8f93d244afad804e09595fcb14320fe2896fef5
Author: Andrzej Pietrasiewicz <andrzej.p@samsung.com>
Date:   Tue Jul 22 19:58:30 2014 +0200

    usb: gadget: f_uac2: convert to new function interface with backward compatibility
    
    Converting uac2 to the new function interface requires converting
    the USB uac2's function code and its users.
    
    This patch converts the f_uac2.c to the new function interface.
    
    The file is now compiled into a separate usb_f_uac2.ko module.
    
    The old function interface is provided by means of a preprocessor
    conditional directives. After all users are converted, the old interface
    can be removed.
    
    Tested-by: Sebastian Reimers <sebastian.reimers@googlemail.com>
    Signed-off-by: Andrzej Pietrasiewicz <andrzej.p@samsung.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/legacy/audio.c b/drivers/usb/gadget/legacy/audio.c
index 3c2328316c05..a41316bb436a 100644
--- a/drivers/usb/gadget/legacy/audio.c
+++ b/drivers/usb/gadget/legacy/audio.c
@@ -45,6 +45,7 @@ static struct usb_gadget_strings *audio_strings[] = {
 #include "u_uac1.c"
 #include "f_uac1.c"
 #else
+#define USB_FUAC2_INCLUDED
 #include "f_uac2.c"
 #endif
 

commit 5d73abf2a77a090ca4c920ac99c8ec0e272398a9
Author: Andrzej Pietrasiewicz <andrzej.p@samsung.com>
Date:   Tue Jul 22 19:58:29 2014 +0200

    usb: gadget: audio: Use container_of to free audio_dev
    
    Eliminate static struct *agdev_g from f_uac2.c.
    It is used for freeing its memory, but the same address can be found
    by calling container_of in afunc_unbind(). This implies eliminating
    uac2_unbind_config(). The audio_config_driver in audio.c does not have
    its unbind method any more. It has been used only when uac2 is used,
    so uac2 itself can handle unbinding in afunc_unbind().
    
    Tested-by: Sebastian Reimers <sebastian.reimers@googlemail.com>
    Signed-off-by: Andrzej Pietrasiewicz <andrzej.p@samsung.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/legacy/audio.c b/drivers/usb/gadget/legacy/audio.c
index 6eb695e5e43a..3c2328316c05 100644
--- a/drivers/usb/gadget/legacy/audio.c
+++ b/drivers/usb/gadget/legacy/audio.c
@@ -126,9 +126,6 @@ static struct usb_configuration audio_config_driver = {
 	.bConfigurationValue	= 1,
 	/* .iConfiguration = DYNAMIC */
 	.bmAttributes		= USB_CONFIG_ATT_SELFPOWER,
-#ifndef CONFIG_GADGET_UAC1
-	.unbind			= uac2_unbind_config,
-#endif
 };
 
 /*-------------------------------------------------------------------------*/

commit 8443f2d2b7782fef35fe579bf1eb612c24951486
Author: Andrzej Pietrasiewicz <andrzej.p@samsung.com>
Date:   Tue Jul 15 13:09:44 2014 +0200

    usb: gadget: Gadget directory cleanup - group legacy gadgets
    
    The drivers/usb/gadget directory contains many files.
    Files which are related can be distributed into separate directories.
    This patch moves the legacy gadgets (i.e. those not using configfs)
    into a separate directory.
    
    Signed-off-by: Andrzej Pietrasiewicz <andrzej.p@samsung.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/gadget/legacy/audio.c b/drivers/usb/gadget/legacy/audio.c
new file mode 100644
index 000000000000..6eb695e5e43a
--- /dev/null
+++ b/drivers/usb/gadget/legacy/audio.c
@@ -0,0 +1,180 @@
+/*
+ * audio.c -- Audio gadget driver
+ *
+ * Copyright (C) 2008 Bryan Wu <cooloney@kernel.org>
+ * Copyright (C) 2008 Analog Devices, Inc
+ *
+ * Enter bugs at http://blackfin.uclinux.org/
+ *
+ * Licensed under the GPL-2 or later.
+ */
+
+/* #define VERBOSE_DEBUG */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/usb/composite.h>
+
+#include "gadget_chips.h"
+#define DRIVER_DESC		"Linux USB Audio Gadget"
+#define DRIVER_VERSION		"Feb 2, 2012"
+
+USB_GADGET_COMPOSITE_OPTIONS();
+
+/* string IDs are assigned dynamically */
+
+static struct usb_string strings_dev[] = {
+	[USB_GADGET_MANUFACTURER_IDX].s = "",
+	[USB_GADGET_PRODUCT_IDX].s = DRIVER_DESC,
+	[USB_GADGET_SERIAL_IDX].s = "",
+	{  } /* end of list */
+};
+
+static struct usb_gadget_strings stringtab_dev = {
+	.language = 0x0409,	/* en-us */
+	.strings = strings_dev,
+};
+
+static struct usb_gadget_strings *audio_strings[] = {
+	&stringtab_dev,
+	NULL,
+};
+
+#ifdef CONFIG_GADGET_UAC1
+#include "u_uac1.h"
+#include "u_uac1.c"
+#include "f_uac1.c"
+#else
+#include "f_uac2.c"
+#endif
+
+/*-------------------------------------------------------------------------*/
+
+/* DO NOT REUSE THESE IDs with a protocol-incompatible driver!!  Ever!!
+ * Instead:  allocate your own, using normal USB-IF procedures.
+ */
+
+/* Thanks to Linux Foundation for donating this product ID. */
+#define AUDIO_VENDOR_NUM		0x1d6b	/* Linux Foundation */
+#define AUDIO_PRODUCT_NUM		0x0101	/* Linux-USB Audio Gadget */
+
+/*-------------------------------------------------------------------------*/
+
+static struct usb_device_descriptor device_desc = {
+	.bLength =		sizeof device_desc,
+	.bDescriptorType =	USB_DT_DEVICE,
+
+	.bcdUSB =		__constant_cpu_to_le16(0x200),
+
+#ifdef CONFIG_GADGET_UAC1
+	.bDeviceClass =		USB_CLASS_PER_INTERFACE,
+	.bDeviceSubClass =	0,
+	.bDeviceProtocol =	0,
+#else
+	.bDeviceClass =		USB_CLASS_MISC,
+	.bDeviceSubClass =	0x02,
+	.bDeviceProtocol =	0x01,
+#endif
+	/* .bMaxPacketSize0 = f(hardware) */
+
+	/* Vendor and product id defaults change according to what configs
+	 * we support.  (As does bNumConfigurations.)  These values can
+	 * also be overridden by module parameters.
+	 */
+	.idVendor =		__constant_cpu_to_le16(AUDIO_VENDOR_NUM),
+	.idProduct =		__constant_cpu_to_le16(AUDIO_PRODUCT_NUM),
+	/* .bcdDevice = f(hardware) */
+	/* .iManufacturer = DYNAMIC */
+	/* .iProduct = DYNAMIC */
+	/* NO SERIAL NUMBER */
+	.bNumConfigurations =	1,
+};
+
+static struct usb_otg_descriptor otg_descriptor = {
+	.bLength =		sizeof otg_descriptor,
+	.bDescriptorType =	USB_DT_OTG,
+
+	/* REVISIT SRP-only hardware is possible, although
+	 * it would not be called "OTG" ...
+	 */
+	.bmAttributes =		USB_OTG_SRP | USB_OTG_HNP,
+};
+
+static const struct usb_descriptor_header *otg_desc[] = {
+	(struct usb_descriptor_header *) &otg_descriptor,
+	NULL,
+};
+
+/*-------------------------------------------------------------------------*/
+
+static int __init audio_do_config(struct usb_configuration *c)
+{
+	/* FIXME alloc iConfiguration string, set it in c->strings */
+
+	if (gadget_is_otg(c->cdev->gadget)) {
+		c->descriptors = otg_desc;
+		c->bmAttributes |= USB_CONFIG_ATT_WAKEUP;
+	}
+
+	audio_bind_config(c);
+
+	return 0;
+}
+
+static struct usb_configuration audio_config_driver = {
+	.label			= DRIVER_DESC,
+	.bConfigurationValue	= 1,
+	/* .iConfiguration = DYNAMIC */
+	.bmAttributes		= USB_CONFIG_ATT_SELFPOWER,
+#ifndef CONFIG_GADGET_UAC1
+	.unbind			= uac2_unbind_config,
+#endif
+};
+
+/*-------------------------------------------------------------------------*/
+
+static int __init audio_bind(struct usb_composite_dev *cdev)
+{
+	int			status;
+
+	status = usb_string_ids_tab(cdev, strings_dev);
+	if (status < 0)
+		goto fail;
+	device_desc.iManufacturer = strings_dev[USB_GADGET_MANUFACTURER_IDX].id;
+	device_desc.iProduct = strings_dev[USB_GADGET_PRODUCT_IDX].id;
+
+	status = usb_add_config(cdev, &audio_config_driver, audio_do_config);
+	if (status < 0)
+		goto fail;
+	usb_composite_overwrite_options(cdev, &coverwrite);
+
+	INFO(cdev, "%s, version: %s\n", DRIVER_DESC, DRIVER_VERSION);
+	return 0;
+
+fail:
+	return status;
+}
+
+static int __exit audio_unbind(struct usb_composite_dev *cdev)
+{
+#ifdef CONFIG_GADGET_UAC1
+	gaudio_cleanup();
+#endif
+	return 0;
+}
+
+static __refdata struct usb_composite_driver audio_driver = {
+	.name		= "g_audio",
+	.dev		= &device_desc,
+	.strings	= audio_strings,
+	.max_speed	= USB_SPEED_HIGH,
+	.bind		= audio_bind,
+	.unbind		= __exit_p(audio_unbind),
+};
+
+module_usb_composite_driver(audio_driver);
+
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_AUTHOR("Bryan Wu <cooloney@kernel.org>");
+MODULE_LICENSE("GPL");
+
